{"ver":"0.1","info":{"id":"Dt3BDs","date":"1701708180","viewed":112,"name":"blobs and fireworks in comos","username":"nayk","description":"blob, fireworks, cosmos, stars, galaxy , new, copypast ","likes":2,"published":1,"flags":1,"usePreview":0,"tags":["galaxy","blob","stars","cosmos","new","fireworks","copypast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* original https://www.shadertoy.com/view/wslcWN , https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/ldySDh  https://www.shadertoy.com/view/wdtczM*/\n#define iterations 10\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 1.350\n\n#define MULTISAMPLES 3 // Max 4\n\nconst float N = 1.33;\nconst float zoom2 = 2.0;\nconst int max_intersections = 12;\n\nconst float eyedistance = 7.5; // Note: These depend on each other\nconst float min_distance = 3.0;\nconst float max_distance = 10.5;\nconst float min_stepsize = 0.25;\nconst int maxsteps = 30;\n\nconst float pi = 3.1415926536;\n\nvec4 sphere1;\nvec4 sphere2;\nvec4 sphere3;\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec3 x) { return dot(x, x); }\n\nfloat fresnel(float n1, float n2, float cos_theta)\n{\n    float r = sq((n1 - n2) / (n1 + n2));\n    return r + (1.0 - r) * pow(1.0 - clamp(cos_theta, 0.0, 1.0), 5.0);\n}\n\n#define SPARKS 30\n#define FIREWORKS 8.\n#define BASE_PAUSE FIREWORKS / 30.\n#define PI 3.14\n#define PI2 6.28\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 randomSpark(float noise) {\n    vec2 v0 = vec2((noise - .5) * 13., (fract(noise * 123.) - .5) * 15.);\n    return v0;\n}\n\nvec2 circularSpark(float i, float noiseId, float noiseSpark) {\n    noiseId = fract(noiseId * 7897654.45);\n    float a = (PI2 / float(SPARKS)) * i;\n    float speed2 = 10.*clamp(noiseId, .7, 1.);\n    float x = sin(a + iTime*((noiseId-.5)*3.));\n    float y = cos(a + iTime*(fract(noiseId*4567.332) - .5)*2.);\n    vec2 v0 = vec2(x, y) * speed2;\n    return v0;\n}\n\n\nvec2 rocket(vec2 start, float t) {\n    float y = t;\n    float x = sin(y*10.+cos(t*3.))*.1;\n    vec2 p = start + vec2(x, y * 8.);\n    return p;\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvec3 firework(vec2 uv, float index, float pauseTime) {\n    vec3 col = vec3(0.);\n\n\n    float timeScale = 1.;\n    vec2 gravity = vec2(0., -9.8);\n\n    float explodeTime = .9;\n    float rocketTime = 1.1;\n    float episodeTime = rocketTime + explodeTime + pauseTime;\n\n    float ratio = iResolution.x / iResolution.y;\n\n    float timeScaled = (iTime - pauseTime) / timeScale;\n\n    float id = floor(timeScaled / episodeTime);\n    float et = mod(timeScaled, episodeTime);\n\n    float noiseId = n21(vec2(id+1., index+1.));\n\n    float scale = clamp(fract(noiseId*567.53)*30., 10., 30.);\n    uv *= scale;\n\n    rocketTime -= (fract(noiseId*1234.543) * .5);\n\n    vec2 pRocket = rocket(vec2(0. + ((noiseId - .5)*scale*ratio), 0. - scale/2.), clamp(et, 0., rocketTime));\n\n    if (et < rocketTime) {\n        float rd = length(uv - pRocket);\n        col += pow(.05/rd , 1.9) * vec3(0.9, .3, .0);\n    }\n\n\n    if (et > rocketTime && et < (rocketTime + explodeTime)) {\n        float burst = sign(fract(noiseId*44432.22) - .6);\n        for(int i = 0 ; i < SPARKS ; i++) {\n                vec2 center = pRocket;\n                float fi = float(i);\n                float noiseSpark = fract(n21(vec2(id*10.+index*20., float(i+1))) * 332.44);\n                float t = et - rocketTime;\n                vec2 v0;\n\n                if (fract(noiseId*3532.33) > .5) {\n                    v0 = randomSpark(noiseSpark);\n                    t -= noiseSpark * (fract(noiseId*543.) * .2);\n                } else {\n                    v0 = circularSpark(fi, noiseId, noiseSpark);\n\n                    if ( (fract(noiseId*973.22) - .5) > 0.) {\n                        float re = mod(fi, 4. + 10. * noiseId);\n                        t -= floor(re/2.) * burst * .1;\n                    } else {\n                        t -= mod(fi, 2.) == 0. ? 0. : burst * .5*clamp(noiseId, .3, 1.);\n                    }\n                }\n\n                vec2 s = v0*t + (gravity * t * t) / 2.;\n\n                vec2 p = center + s;\n\n                float d = length(uv - p);\n\n                if (t > 0.) {\n                    float fade = clamp((1. - t/explodeTime), 0., 1.);\n                    vec3 sparkColor = vec3(noiseId*.9, .5*fract(noiseId *456.33), .5*fract(noiseId *1456.33));\n                    vec3 c = (.05 / d) * sparkColor;\n                    col += c * fade;\n                }\n            }\n    }\n\n\n    return col;\n}\nfloat f(vec3 p)\n{\n    return 1.0 - (\n        sphere1.w / sq(sphere1.xyz - p) + \n        sphere2.w / sq(sphere2.xyz - p) +\n        sphere3.w / sq(sphere3.xyz - p));\n}\n\nvec3 fd(vec3 p)\n{\n    vec3 d1 = sphere1.xyz - p;\n    vec3 d2 = sphere2.xyz - p;\n    vec3 d3 = sphere3.xyz - p;\n    return 10.0 * (\n        sphere1.w * d1 / sq(sq(d1)) +\n        sphere2.w * d2 / sq(sq(d2)) +\n        sphere3.w * d3 / sq(sq(d3)));\n}\n\nfloat stepsize2(vec3 p)\n{\n    float md = sqrt(min(min(\n        sq(p - sphere1.xyz), \n        sq(p - sphere2.xyz)), \n        sq(p - sphere3.xyz)));\n    return max(min_stepsize, abs(md - 1.0) * 0.667);\n}\n\nvec4 ray(vec3 p, vec3 d)\n{\n    float k = min_distance;\n    float nf = 1.0;\n    vec4 c = vec4(0.0);\n    float cr = 1.0;\n    for (int j = 0; j < max_intersections; ++j)\n    {\n        for (int i = 0; i < maxsteps; ++i)\n        {\n            if (k > max_distance)\n                return c +  cr;\n            float ss = stepsize2(p + d * k);\n            if (f(p + d * (k + ss)) * nf < 0.0)\n            {\n                k += ss - min_stepsize * 0.5;\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                p += d * k;\n                \n                vec3 n = -normalize(fd(p)) * nf;\n                vec3 r = refract(d, n, nf > 0.0 ? 1.0 / N : N);\n\n                if (nf < 0.0)\n                {\n                    float fa = k * 0.025;\n                    c += vec4(0.5, 0.75, 1.0, 1.0) * fa * cr;\n                    cr *= 1.0 - fa;\n                }\n\n                if (r == vec3(0.0))\n                {\n\t                d = reflect(d, n);\n                }\n                else\n                {\n                    float f = nf > 0.0 ? \n                        fresnel(1.0, N, dot(-d, n)) : \n                    \tfresnel(N, 1.0, dot(-d, n));\n                    if (f > 0.5)\n                    {\n                        c +=  (1.0 - f) * cr;\n                        cr *= f;\n                        d = reflect(d, n);\n                    }\n                    else\n                    {                    \n                      \n                        cr *= 1.0 - f;\n                        d = r;\n                        nf *= -1.0;\n                    }\n                }\n                k = 0.0;\n                break;\n            }\n            k += ss;\n        }\n    }\n    return c* cr;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.03),sin(iTime*0.03),-sin(iTime*0.03),cos(iTime*0.03));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.1; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.01);\n\tfloat time=iTime*speed+.25;\nfloat t = iTime;\n vec3 col = vec3(0.);\nuv*=3.;\nvec4 o =fragColor;\nvec2 F = fragCoord;\n vec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = -iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  /vec4(3.1,3.,.5,.5);;                     \n    }\n    for (float i = 0. ; i < FIREWORKS ; i += 1.) {\n        col += firework(uv, i + 1., (i * BASE_PAUSE));\n    }\n\n    vec4 vs1 = cos(t * vec4(0.87, 1.13, 1.2, 1.0) + vec4(0.0, 3.32, 0.97, 2.85)) * vec4(-1.7, 2.1, 2.37, -1.9);\n    vec4 vs2 = cos(t * vec4(1.07, 0.93, 1.1, 0.81) + vec4(0.3, 3.02, 1.15, 2.97)) * vec4(1.77, -1.81, 1.47, 1.9);\n\n    sphere1 = vec4(vs1.x, 0.0, vs1.y, 1.0);\n\tsphere2 = vec4(vs1.z, vs1.w, vs2.z, 0.9);\n\tsphere3 = vec4(vs2.x, vs2.y, vs2.w, 0.8);\n\n    vec2 r = -iMouse.yx / iResolution.yx * pi * 2.0;\n\n    vec4 cs = cos(vec4(r.y, r.x, r.y - pi * 0.5, r.x - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n    vec3 eye = -forward * eyedistance;\n\n\t uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n   \n    vec3 dir2 = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec4 color = ray(eye, dir2);\n#if MULTISAMPLES > 1\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\n#if MULTISAMPLES > 2\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\n#if MULTISAMPLES > 3\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\n#endif\n#endif\n    color /= float(MULTISAMPLES);\n#endif\n\n\tvec3 from=vec3(1.,.5,0.5)+o.xyz+color.xyz;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=vec4(col,1.);\n     fragColor*= vec4(cheap_star(uv,anim) * vec3(0.55,0.5,0.55)*2., 1.0);\n   \n}\n","name":"Image","description":"","type":"image"}]}