{"ver":"0.1","info":{"id":"NdlyRl","date":"1642526518","viewed":312,"name":"Animated Value Noise","username":"Arnklit","description":"I was looking for animated value noise, but couldn't find any. I figured offsetting the values of each point by a sine wave might give a good effect.\nThe base of this noise function is from Material Maker which is under MIT license.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","animated","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License Kasper Arnklit Frandsen 2022\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nfloat value_noise(vec2 coord, vec2 size, float offset) {\n\tvec2 o = floor(coord)+size;\n\tvec2 f = fract(coord);\n\tfloat p00 = rand(mod(o, size));\n\tfloat p01 = rand(mod(o + vec2(0.0, 1.0), size));\n\tfloat p10 = rand(mod(o + vec2(1.0, 0.0), size));\n\tfloat p11 = rand(mod(o + vec2(1.0, 1.0), size));\n\tp00 = sin(p00 * 6.28 + offset) / 2.0 + 0.5; // This is where the animation of the points happen\n\tp01 = sin(p01 * 6.28 + offset) / 2.0 + 0.5; // This is where the animation of the points happen\n\tp10 = sin(p10 * 6.28 + offset) / 2.0 + 0.5; // This is where the animation of the points happen\n\tp11 = sin(p11 * 6.28 + offset) / 2.0 + 0.5; // This is where the animation of the points happen\n\tvec2 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0); // Improved smoothstep for smoother gradients, mostly matters for normal maps\n\treturn mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tfloat noise = value_noise(coord*size, size, offset);\n\t\tfor (int f = 0; f < folds; ++f) {\n\t\t\tnoise = abs(2.0*noise-1.0);\n\t\t}\n\t\tvalue += noise * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    \n    float noise = 0.0;\n   \n\n    // left: animated fbm value noise 5 octaves\n\tif( p.x<0.5 )\n\t{\n\t\tnoise = fbm(uv, vec2(8.0), 0, 5, 0.5, iTime);\n\t}\n    // right: animated fbm value noise 5 octaves, 1 fold\n    else\t\n\t{\n        noise = fbm(uv, vec2(8.0), 1, 5, 0.5, iTime);\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(noise), 1.0);\n}","name":"Image","description":"","type":"image"}]}