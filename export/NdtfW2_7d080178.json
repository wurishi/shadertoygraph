{"ver":"0.1","info":{"id":"NdtfW2","date":"1657231022","viewed":136,"name":"MusicFluidShader","username":"IratusHominem","description":"fluidly music","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["music","fluid","musicfluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n//Level of Detail\n#define lod 4. \n#define distortGrid 1.\n#define animSpeed 0.2\n#define blueLineThickness 0.1\n\nprecision highp float;\n\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t/*\n\t\tThis works by distorting the space which a grid occupies. \n\t*/\n\n\tfragCoord = gl_FragCoord.xy;\n\tvec2 uv = fragCoord/iResolution.xy;\n\tfloat dt = iTime * animSpeed;\n\tuv -= 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec4 tex = texture(iChannel0, uv);\n\tdt += noise(uv*0.5 * lod + dt + uv.yx * lod * 0.5 + dot(uv,uv));\n\tfloat s = sin(dt);\n\tfloat c = cos(dt);\n\tmat2 rot = mat2(c,s,-s,c);\n\t\n\t//Grid distortion \"function\" in the mathematical sense.\n\tfloat gridDensity = \n\t\t(distortGrid) * \n\t\t(\n\t\t\t//noise layer\n\t\t\t(noise(uv*lod - dt + uv*rot) + noise(uv*lod - 0.5) * 0.5 + noise(uv*lod - 0.75 + uv*rot) * 0.25) \n\t\t\t//Space Distortion\n\t\t\t* abs(sin(uv.x + uv.y + noise(noise(uv*lod+dt)+uv.yx*lod + dt)*PI + dt)) * pow((1.0-blueLineThickness)/noise(uv), 2. * noise(uv + dt)) +\n            noise(vec2(dt))\n\t\t) \n\t\t+ (10.0 * (1.0 - distortGrid));\n\t\n\t//Based on the current scaling of the grid,\n\t//this mathematically determines which grid cell we're in\n\tvec2 id = floor(uv * gridDensity);\n\tvec3 col = vec3(abs(id/gridDensity*2.).xy + length((id - noise(id.xy*lod) * id)/gridDensity - cos(dt + length(uv-noise(uv*lod + dt )))*2.),0.0);\n\tfragColor = vec4(noise((col.yz * 0.5 - col.xz + col.xy)*lod + dt) * col.zyx*0.15, 1.0);\n}","name":"Image","description":"","type":"image"}]}