{"ver":"0.1","info":{"id":"3dKSDR","date":"1573773268","viewed":189,"name":"Enchanted Family of Mushrooms","username":"imanbell","description":"-","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["forest","mushroom","glowing","magical","enchanted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define EPSILON 0.001\n\n// https://iquilezles.org/articles/distfunctions\n// Credit to the awesome iq for sdf-related functions\n\n/*** HELPER FUNCTIONS ***/\n\nfloat smoothUnion(in float iSDF1, in float iSDF2, in float iTransitionSize) {\n    \n \tfloat h = clamp(0.5 + 0.5*(iSDF2 - iSDF1)/iTransitionSize, 0.0, 1.0);\n    return mix(iSDF2, iSDF1, h) - iTransitionSize*h*(1.0 - h);   \n    \n}\n\nfloat roundedConeSDF(in vec3 iPoint, in float iSmallRadius, in float iBigRadius, in float iHeight) {\n    \n    vec2 q = vec2(length(iPoint.xz), iPoint.y);\n    \n    float b = (iBigRadius - iSmallRadius)/iHeight;\n    float a = sqrt(1.0 - b*b);\n    float k = dot(q, vec2(-b, a));\n\n    if (k < 0.0) return length(q) - iBigRadius;\n    if (k > a*iHeight) return length(q - vec2(0.0, iHeight)) - iSmallRadius;\n\n    return dot(q, vec2(a, b)) - iBigRadius;\n    \n}\n\n/*** MUSHROOM FUNCTIONS ***/\n\nfloat stemSDF(in vec3 iPoint, vec2 iPosition, in float iRadius, in float iStemHeight) {\n\t\n    // The stem is a capped cylinder with a varying radius    \n    float d = length(iPoint.xz - iPosition) - iRadius*(1.0 + 0.05*cos(2.0*iPoint.y + iPoint.z));\n    d = max(d, -iStemHeight + abs(iPoint.y));\n    return d;\n    \n}\n\nfloat capSDF(in vec3 iPoint, vec2 iPosition, in float iRadius, in float iStemHeight, in float iTiltingAngle) {\n    \n    // We first apply the inverse of the slight tilting rotation we want to the point\n    \n    float c = cos(0.3*iTiltingAngle);\n    float s = sin(0.5*iTiltingAngle);\n    \n    mat3 tiltingMatrix = transpose(mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0)));   \n\n    vec3 tiltedPoint = tiltingMatrix*iPoint;\n    \n    // A cap is a smooth union between a rounded cone and a flattened half sphere\n    \n    float coneSdf = roundedConeSDF(tiltedPoint - vec3(iPosition.x, iStemHeight, iPosition.y), 0.2*iRadius, 0.4*iRadius, 2.0*iStemHeight);\n    \n    float sphereSdf = length(tiltedPoint - vec3(iPosition.x, 0.01*iStemHeight, iPosition.y)) - iRadius;\n\n    float d = smoothUnion(coneSdf, sphereSdf, 2.0);\n    \n    // We apply a small displacement on the surface of the cap\n    \n    vec2 normalizedPoint = normalize(tiltedPoint.xz - iPosition);\n    float cosTheta = normalizedPoint.x;\n    float sinTheta = normalizedPoint.y;\n    float theta = acos(cosTheta)*sign(sinTheta);\n  \n    d -= max(0.0, 0.38*abs(cos(8.0*theta) - 0.5) - 0.5);\n    d = max(d, iStemHeight - tiltedPoint.y);\n    \n    return d;\n    \n}\n\nfloat mushroomSDF(in vec3 iPoint, vec2 iPosition, in float iStemRadius, in float iStemHeight, in float iCapRadius, in float iTiltingAngle) {\n    \n    float d = min(stemSDF(iPoint, iPosition, iStemRadius, iStemHeight),\n\t\t\t\tcapSDF(iPoint, iPosition, iCapRadius, iStemHeight, iTiltingAngle));\n    return d;\n    \n}\n            \nfloat allMushroomsSDF(in vec3 iPoint) {\n    \n    float d = mushroomSDF(iPoint, vec2(-0.5, -3.0), 0.6, 2.0, 4.0, 0.1);\n    d = min(d, mushroomSDF(iPoint, vec2(-8.0, 3.0), 1.1, 1.8, 4.0, -0.2));   \n    d = min(d, mushroomSDF(iPoint, vec2(4.0, 1.0), 1.0, 1.6, 3.0, 0.3));\n    d = min(d, mushroomSDF(iPoint, vec2(-7.5, -7.0), 0.5, 1.0, 2.0, 0.1));\n\td = min(d, mushroomSDF(iPoint, vec2(-2.5, -9.0), 0.25, 1.0, 0.8, -0.15));\n    return d;\n    \n}\n\nfloat rayMarchMushrooms(in vec3 iOrigin, in vec3 iRay) {\n    \n \tfloat t = 0.0;\n    vec3 p = iOrigin;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        p = iOrigin + t*iRay;\n     \tfloat sdist = allMushroomsSDF(p);\n        t += sdist;\n        if (abs(sdist) < EPSILON) {\n            break;\n        }\n    }\n    return t;\n    \n}\n\nvec3 computeMushroomDiffuseColor(in vec3 iPoint) {\n    \n    vec3 softPink = vec3(0.9, 0.6, 0.9);\n    vec3 softBlue = vec3(0.5, 1.0, 1.0);    \n    vec3 color = mix(softPink, softBlue, iPoint.y/0.9);\n    color *= 2.4*texture(iChannel0, (iPoint.xz - 10.0)*0.1).xyz;\n    return color;\n    \n}\n\n/*** FLYING ORB FUNCTIONS ***/\n\nvec3 orbPosition0;\nvec3 orbPosition1;\nvec3 orbPosition2;\nvec3 orbPosition3;\n\nfloat orbSDF(in vec3 iPoint, in vec3 iPosition, in float iRadius) {\n    \n    // An orb is a simple sphere    \n\treturn length(iPoint - iPosition) - iRadius;   \n    \n}\n\nfloat allOrbsSDF(in vec3 iPoint) {\n    \n    float d = orbSDF(iPoint, orbPosition0, 0.15);\n    d = min(d, orbSDF(iPoint, orbPosition1, 0.1));\n    d = min(d, orbSDF(iPoint, orbPosition2, 0.05));\n    d = min(d, orbSDF(iPoint, orbPosition3, 0.1));\n    return d;\n    \n}\n\n/*** GROUND FUNCTIONS ***/\n\nfloat groundSDF(in vec3 iPoint) {\n    \n    // Using a texture as a height map to roughen up the ground    \n    float height = texture(iChannel1, (iPoint.xz + vec2(10.0))*0.2).x;\n    return iPoint.y + 1.1 + 0.1*height;\n    \n}\n\nvec3 computeGroundDiffuseColor(in vec3 iPoint) {\n    \n    return texture(iChannel0, (iPoint.xz + vec2(10.0))*0.05).xyz;\n \n}\n\n/*** COMPUTE NORMALS ***/\n\nfloat sceneSDF(in vec3 iPoint) {\n    \n    float d = min(allMushroomsSDF(iPoint), allOrbsSDF(iPoint));\n    d = min(d, groundSDF(iPoint));\n    return d;\n    \n}\n\nvec3 computeNormal(in vec3 iPoint) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(iPoint.x + EPSILON, iPoint.y, iPoint.z)) - sceneSDF(vec3(iPoint.x - EPSILON, iPoint.y, iPoint.z)),\n        sceneSDF(vec3(iPoint.x, iPoint.y + EPSILON, iPoint.z)) - sceneSDF(vec3(iPoint.x, iPoint.y - EPSILON, iPoint.z)),\n        sceneSDF(vec3(iPoint.x, iPoint.y, iPoint.z  + EPSILON)) - sceneSDF(vec3(iPoint.x, iPoint.y, iPoint.z - EPSILON))\n    ));\n    \n}\n\n/*** RAY MARCHING ***/\n\nfloat rayMarch(in vec3 iOrigin, in vec3 iRay, inout int ioObjectHit) {\n    \n \tfloat t = 0.0;\n    vec3 p = iOrigin;\n\t\n    for (int i = 0; i < MAX_STEPS; i++) {\n        p = iOrigin + t*iRay;\n     \tfloat m = allMushroomsSDF(p);\n     \tfloat o = allOrbsSDF(p);\n     \tfloat g = groundSDF(p);\n\t\t\n\t\tfloat depth = min(min(o, m), g);\n\t\t// We hit an orb\n\t\tif (o < m && o < g) {\n\t\t\tdepth = o;\n\t\t\tioObjectHit = 2;\n\t\t} \n\t\t// We hit a mushroom\n\t\tif (m < o && m < g) {\n\t\t\tdepth = m;\n\t\t\tioObjectHit = 1;\n\t\t}\n\t\t// We hit the ground\n\t\tif (g < o && g < m) {\n\t\t\tdepth = g;\n\t\t\tioObjectHit = 0;\n\t\t}\t\t\n        t += depth; \n        if (abs(depth) < EPSILON) {\n            break;\n        }\n    }\n\t\n    return t;\n    \n}\n\n/*** LIGHTING AND SHADOWS ***/\n\n// The scene's 2 static lights\n\nvec3 lightPosition0 = vec3(15.0, 25.0, -15.0);\nvec3 lightColor0 = vec3(0.4, 0.7, 1.0);\n\nvec3 lightPosition1 = vec3(-15.0, 15.0, 15.0);\nvec3 lightColor1 = vec3(0.8, 0.0, 0.8);\n\n// Computes the shadow created by a particular light\nvec3 computeShadow(in vec3 iPoint, in vec3 iLightPosition) {\n    \n    vec3 ray = normalize(iLightPosition - iPoint);\n    float d = rayMarchMushrooms(iPoint, ray);\n    return vec3(1.0 - 1.0/(1.0 + 0.03*d*d));\n    \n}\n\n// Only mushrooms cast shadows\n// Only static lights create shadows\n// Only the ground receives shadows\nvec3 computeAllShadows(in vec3 iPoint) {\n    \n    vec3 shadow = computeShadow(iPoint, lightPosition0);\n    shadow *= computeShadow(iPoint, lightPosition1);\n    return shadow;\n    \n}\n                                \n// Basic Phong-type lighting\n// Compute the lighting of a particular light\nvec3 computeLighting(in vec3 iLightPosition, in vec3 iLightColor, in vec3 iDiffuseColor, in vec3 iPoint, in vec3 iNormal, in vec3 iOrigin, in bool iAttenuated) {\n\t\n    vec3 pointToLight = iLightPosition - iPoint;\n    float distanceToLight = length(pointToLight);\n    vec3 pointToLight_n = normalize(pointToLight);\n    vec3 reflected = reflect(-pointToLight_n, iNormal);\n    vec3 pointToOrigin_n = normalize(iOrigin - iPoint);\n    float lambertian = max(dot(pointToLight_n, iNormal), 0.0);        \n        \n\tfloat specular = 0.0;\n  \n\tif(lambertian > 0.0) {\n    \tfloat angle = max(dot(reflected, pointToOrigin_n), 0.0);\n    \tspecular = pow(angle, 16.0);\n\t}\n  \t\n    // We soften the lighting if it's too harsh\n    if (iAttenuated) \n\t\treturn 20.0*iLightColor*vec3(lambertian*iDiffuseColor + specular*vec3(1.0, 1.0, 1.0))/(1.0 + distanceToLight*distanceToLight);          \n\telse\n  \t\treturn iLightColor*vec3(lambertian*iDiffuseColor + specular*vec3(0.0, 1.0, 1.0));          \n\n}\n\n// Computes the lighting of the scene using all the light sources: 4 orbs and 2 static lights\nvec3 computeAllLighting(in vec3 iPoint, in vec3 iNormal, in vec3 iOrigin, in vec3 iDiffuseColor) {\n\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    \n    vec3 col = computeLighting(orbPosition0, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(orbPosition1, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(orbPosition2, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(orbPosition3, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(lightPosition0, lightColor0, iDiffuseColor, iPoint, iNormal, iOrigin, false)\n        + computeLighting(lightPosition1, lightColor1, iDiffuseColor, iPoint, iNormal, iOrigin, false);\n\n    return col;\n    \n}\n\n/*** VIEWPOINT ***/\n\n// Computing the matrix needed to transform the ray in world space\nmat4 viewToWorldMatrix(in vec3 iEyePosition, in vec3 iTarget, in vec3 iUpDirection) {\n\t\n    vec3 f = -normalize(iTarget - iEyePosition);\n\tvec3 s = normalize(cross(f, iUpDirection));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1.0)\n\t);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Defining the origin and ray of the raymarching algorithm\n    vec3 target = vec3(-3.0, -3.0, 8.0);\n    vec3 origin = vec3(5.0, 25.0, -40.0);    \n    mat4 rayMatrix = viewToWorldMatrix(origin, target, vec3(0.0, 1.0, 0.0));    \n    vec3 ray = vec3(rayMatrix*vec4(normalize(vec3(uv, 5.0)), 0.0));\n\n    // Defining orb parameters\n    orbPosition0 = vec3(4.0*cos(iTime) - 2.5, -0.5, 6.0*sin(iTime));\n    orbPosition1 = vec3(5.5*cos(iTime + 2.0) - 2.5, 8.0, 6.0*sin(iTime + 2.5));\n    orbPosition2 = vec3(5.0*cos(iTime + 5.0) - 2.5, 7.0, 6.0*sin(iTime + 5.0));\n    orbPosition3 = vec3(13.0*cos(iTime + 3.0) - 2.5, 2.5, 9.0*sin(iTime + 3.0));\n    \n    // Color of the point hit by the ray\n    vec3 diffuseColor;\n    \n\t// This represents the object hit\n\t// 0: ground\n\t// 1: mushroom\n\t// 2: orb\n\tint objectHit = -1;\n    \n    // Depth of the closest point hit by the ray\n\tfloat depth = rayMarch(origin, ray, objectHit);\n\t\n\tvec3 point = origin + depth*ray;    \n    vec3 normal = computeNormal(point);\n\t\n    // Determining the color\n\tswitch (objectHit) {\n\t\tcase 0:\n\t\t\tdiffuseColor = computeGroundDiffuseColor(point);\n\t\t\tdiffuseColor *= computeAllShadows(point);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdiffuseColor = computeMushroomDiffuseColor(point);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tdefault:\n\t\t\tdiffuseColor = vec3(1.0, 1.0, 0.0);\n\t\t\tbreak;\n\t}\n\t\n    // Shading\n    vec3 finalColor = computeAllLighting(point, normal, origin, diffuseColor);\n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}