{"ver":"0.1","info":{"id":"Wdl3zB","date":"1546729760","viewed":387,"name":"Simple PBR Material","username":"bitnenfer","description":"Just a small test of very simple PBR materials.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","brdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAX_DIST 50.0\n#define MIN_DIST EPSILON\n#define PI 3.14159265359\n#define SAT(n) clamp(n, 0.0, 1.0)\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Hit\n{\n    float dist;\n    Material material;\n};\n\nconst Material kInvalidMaterial = Material(vec3(0.0), 0.0, 0.0);\n\n//https://iquilezles.org/articles/morenoise\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n//https://iquilezles.org/articles/morenoise\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n    float f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n    float f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values      \n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n    return vec4( a, d );\n}\n\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\n\nfloat sdfBox(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d,0.0)) + min(0.0, max(d.x, max(d.y, d.z)));\n}\n\nfloat sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nMaterial mixMaterial(Material a, Material b, float s)\n{\n    return Material(\n        mix(a.albedo, b.albedo, s),\n        mix(a.roughness, b.roughness, s),\n        mix(a.metallic, b.metallic, s)\n    );\n}\n\nfloat noiseValue = 0.0;\n\nHit scene(vec3 p)\n{\n    vec3 rep = vec3(3.0, 0.0, 3.0);\n    float n = pow(noiseValue, 2.0);\n    \n    p = mod(p, rep) - rep * 0.5;\n    p.xz *= rot(1.0);\n    \n    float box = sdfBox(p, vec3(0.4)) - 0.1;\n    float sphereA = sdfSphere(p + vec3(+0.9, 0.0, 0.0), 0.5);\n    float sphereB = sdfSphere(p + vec3(-0.9, 0.0, 0.0), 0.5);\n    \n    Material m = Material(vec3(176.0/255.0, 196.0/255.0, 222.0/255.0), SAT(0.35), SAT(1.0));\n    Material b = Material(vec3(183.0/255.0, 65.0/255.0, 14.0/255.0), SAT(pow(1.0 - noiseValue, 10.0)), SAT(0.1));\n\n    return Hit(smin(box, min(sphereA, sphereB), 0.15), mixMaterial(m, b, n));\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(scene(p).dist - vec3(\n        scene(p - e.yxx).dist,\n        scene(p - e.xyx).dist,\n        scene(p - e.xxy).dist\n    ));\n}\n\nvec3 blinnPhong(vec3 n, vec3 v, vec3 l, in Material material)\n{\n    vec3 h = normalize(v + l);\n    vec3 r = -reflect(n, l);\n    float NdotL = max(0.0, dot(n, l));\n    float HdotR = max(0.0, dot(h, r));\n    \n    vec3 ambient = vec3(0.2);\n    vec3 diffuse = vec3(0.6);\n    vec3 specular = vec3(1.0);\n    \n    return (ambient) + (diffuse * NdotL) + (specular * pow(HdotR, 1024.0));\n}\n\nfloat NormalDistributionFunction_GGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = PI * (denom * denom);\n    return a2 / denom;\n}\n\nfloat Geometry_GGX(vec3 n, vec3 v, float a)\n{\n#if 0\n    float a2 = a * a;\n    float NdotV = max(0.0, dot(n, v));\n    float NdotV2 = NdotV * NdotV;\n    float denom = NdotV + sqrt(a2 + (1.0 - a2) * NdotV2);\n    return (2.0 * NdotV) / denom;\n#else\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    float NdotV = max(0.0, dot(n, v));\n    return NdotV / (NdotV * (1.0 - k) + k);\n#endif\n}\n\nfloat Geometry_Smith(vec3 n, vec3 v, vec3 l, float a)\n{\n    float g1 = Geometry_GGX(n, l, a);\n    float g2 = Geometry_GGX(n, v, a);\n    return g1 * g2;\n}\n\nvec3 Fresnel_Schlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 PBR(vec3 p, vec3 n, vec3 v, vec3 l, in Material material)\n{\n    vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n    vec3 h = normalize(v + l);\n    float roughness = material.roughness * material.roughness;\n    float D = NormalDistributionFunction_GGXTR(n, h, roughness);\n    vec3 F = Fresnel_Schlick(v, h, F0);\n    float G = Geometry_Smith(n, v, l, roughness);\n    float NdotL = max(0.0, dot(n, l));\n    float NdotV = max(0.0, dot(n, v));\n    vec3 Kd = (1.0 - F) * (1.0 - material.metallic);\n    vec3 radiance = vec3(2.0);\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, EPSILON);\n    \n    return (material.albedo * 0.03) + ((Kd * material.albedo / PI + specularBRDF) * radiance * NdotL);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 lightDir = normalize(vec3(0.5, 1.0, -0.8));\n    vec3 color = vec3(0.04);\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) *  ar;\n    vec3 ro = vec3(0.0, 2.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float t = 0.0;\n    Hit hit = Hit(MAX_DIST, kInvalidMaterial);\n    \n    float mx = (iMouse.x/iResolution.y*2.0-1.0)*3.14;\n\n    ro.yz *= rot(-0.2);\n    rd.yz *= rot(-0.2);\n\n    ro.xz *= rot(mx);\n    rd.xz *= rot(mx);\n\n    for (int i = 0; i < 200; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n        Hit map = scene(p);\n        if (map.dist < MIN_DIST)\n        {\n            noiseValue = SAT(pow(length(fbmd(p).yzw),2.0));\n            map = scene(p);\n            hit.material = map.material;\n            hit.dist = t;\n            break;\n        }\n        t += map.dist*.5;\n        if (t > MAX_DIST) break;\n    }\n    \n    if (hit.dist < MAX_DIST)\n    {\n        vec3 p = ro + rd * hit.dist;\n        vec3 n = norm(p);\n        vec3 v = normalize(-rd);\n\n        color = PBR(p, n, v, lightDir, hit.material);\n    }\n    \n    color = mix(color, vec3(0.01), SAT(pow(hit.dist / 50.0, 0.9)));\n    \n    // tone mapping\n    color = color / (color + 1.0);\n    \n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}