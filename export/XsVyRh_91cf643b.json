{"ver":"0.1","info":{"id":"XsVyRh","date":"1521044868","viewed":537,"name":"Popping  Isocubes","username":"duvengar","description":"Originally Inspired by this [url=https://assets.catawiki.nl/assets/2017/11/10/d/4/5/d45245d2-c5f8-11e7-8f41-64eeb6a38205.jpg]Vasarely artwork[/url] and 100% based on @Shane's [url=https://www.shadertoy.com/view/Xljczw]Minimal Hexagonal Grid[/url] \n\n","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagon","tiling","spherize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Popping isocubes by @duvengar-2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n///////////////////////////////////////////////////////////////////////////////////////////\n// I've finaly found some time to play with the Minimal Hexagonal Grid example from @Shane.\n// https://www.shadertoy.com/view/Xljczw\n\n\n#define M(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define SAT(a) clamp(.0, .1, a)\n#define T iTime\n#define PI acos(-1.)\n#define TWO_PI (PI * 2.)\n\nconst float LOWRES = 100.;\n\nfloat hash2(vec2 p)\n{\n    // hash2 taken from Dave Hoskins \n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * .2831);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rem(vec2 iR)\n{\n    float slices = 17. * floor(iR.y / LOWRES);\n  \n    return  sqrt(slices);\n}\n\n// taken from:\n// Minimal Hexagonal Grid - Shane\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Helper vector.\n// 30-60-90 triangle, which has sides of 1, sqrt(3) and 2.\n\nconst vec2 s = vec2(1, 1.7320508);\n\n// The 2D hexagonal isosuface function\nfloat hex(in vec2 p)\n{\n    \n    p = abs(p);\n    return max(dot(p, s *.5), p.x ); // Hexagon.\n    \n    //equivalent to:\n    //return max(p.x *.5 + p.y *.866025, p.x); \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n\nvec4 getHex(vec2 p)\n{  \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1)) / s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n    \n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // store global sound amplitude\n    \n    \n    // Normalized domains\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uv2 = ( fragCoord.xy -.5  / iResolution.xy) / iResolution.y;\n    \n    // initialize some variables\n    float motion = 325.543 + T * .5;\t\t   // a speed\n    vec3 col = vec3(.7, .66, 1.55) + .1;       // a weird base color\n    float blr = .002;\t\t\t\t           // a blur value\n \t// scale and twist and rotate the domain\n    uv *= M(.4 * cos(PI) * 1.5 * length(uv));\n    uv *= 1.35;\n   \tuv *= M(PI);\n    // spherize\n    if(length(uv) < 1.)\n    {    \n        float d = mix(1.,1. + ( 1. - dot(uv, uv)),  1.); \n        blr = blr * d; \n   \t\tuv = uv / d;   \n    }\n\t// get a screen scaling ratio (for the stripe pattern scaling along resolutions);\n    float dens = rem(iResolution.xy) ;\n\n    // Finally make some the Hexagons\n    vec2 pos = vec2(.0,.0);\n    pos  -= motion + .1 * iMouse.xy / 10.;  // add motion and mouse interaction\n    vec4 h = getHex( pos + 5. * uv + s.yx); // hexagons center\n    float eDist = hex(h.xy);                // hexagone Edge distance.\n    \n\t//float cDist = length(h.xy);           // @Shane: cDist = dot(h.xy, h.xy);\n    \n    \n    float tilt  = hash2(h.zw*2376.345791);  // random value depending on cel ids\n    // float yoyo = .0;\t\t\t\t        // animation factor to rescale \n    \t\t\t\t\t\t\t\t\t\n    // rotate hexa tiles depending on their unique random number\n    // and animate the unique hexagon radius at the same time;\n    // initialize color, flip et texture attribute.\n    \n    float red, flip, tex = .0;\n \n    // vertical stripes pattern\n    /////////////////////////////////////////////////////////////////////////////////\n    //vec2 pat =   h.xy + motion;\n   \n    vec2 pat = h.xy;\n\t// hashed pattern with diferent angle;\n    // vertical one\n    float p2 = .08*smoothstep(.2, .1-blr,  length(fract(pat.x * dens * 1.75)-.5));\n    // two obliques\n    pat *= M(PI*.33);\n    float p3 = .08*smoothstep(.2, .1-blr,  length(fract(pat.x * dens * 1.75)-.5));\n    pat *= M(PI*.33);\n    float p4 = .08*smoothstep(.2, .1-blr,  length(fract(pat.x * dens * 1.75)-.5));\n    \n    // sorting the cubes\n    ///////////////////////////////////////////////////////////////////////////////////\n\n   \n    // wich tile are flipped?\n    if( cos(5.* motion * sin(h.z - h.w)*tilt) > .0)\n    {\n       flip = 1.;\n       h.xy *= M(PI);   \n    } \n    // wich tile are orange?\n    \n    if(tilt > .7 && flip != .0){\n        red = 1.;\n    }\n  \n    \n    // get polar coordinates in order cut the 3 faces form the hagagon\n    // in order to create the cubes/(Rhombic effect) inside the tiling.\n    vec2 pol  = vec2(atan(h.x, h.y) / TWO_PI + .5, length(uv));\n    vec2 ang = vec2(.3333, .6666);\n    \n    //////////////////////////////////////////////////////////////////\n\n    // Paint orange or gray cube\n        \n    if(red == 1. && flip != .0)\n    {\n        col += vec3(.7,-.1,-.35);\n        col -= .1 * smoothstep(.45,.45-blr, eDist);\n        tex = 1.;\n        \n    } else \n    {\n        col -= .3;     \n    }\n    \n\n    // shading the cubes faces\n    // face 01 (left)\n    if(pol.x <=  ang.x)\n    {\n    \tcol -= .2; \n        col += tex == 1. ? .0 : p2;\n    }\n    // face 02 (right)\n    if(pol.x >= ang.y)\n    {    \n        col -= .375;\n        col += tex == 1. ? .0 : p2;\n    }\n    // face 03 (top)\n    if(pol.x > ang.x && pol.x < ang.y)\n    {\n     col += tex == 1. ? .0 : .25 * (p4+p3);\n    }\n     \n    // face 04 (inside)\n    vec2 ang2 = ang + vec2(-.1665,.1665);\n    if(pol.x  <= ang2.x  || pol.x >= ang2.y ){\n        \n        col += red == 1. && flip == 1. ? .075 : .0; // only for red cubes\n    }\n    \n    // Edges\n    \n    // drawing some tiny dark lines along the inner cubes edges and\n    // simulate three partialy visible cubes.\n    // and drawing the same three lines for the outer cubes to make their edges shinier\n    if( flip == .0){\n       col -= h.y < .0 ? .3 * smoothstep(.02,.0,length(h.x)) : .0; \n       vec2 hr = M(PI*.333) * h.xy;\n       col -= h.y > .0 ? .3 * smoothstep(.02,.0,length(hr.x)) : .0; \n       hr = M(PI*.666) * h.xy;\n       col -= h.y > .0 ? .3 * smoothstep(.02,.0,length(hr.x)) : .0; \n       \n    } else if( red == 1. && flip == 1. ){\n       col += h.y < .0 ? .3 * smoothstep(.015,.0,length(h.x)) : .0; \n       vec2 hr = M(PI*.333) * h.xy;\n       col += h.y > .0 ? .3 * smoothstep(.015,.0,length(hr.x)) : .0; \n       hr = M(PI*.666) * h.xy;\n       col += h.y > .0 ? .3 * smoothstep(.015,.0,length(hr.x)) : .0; \n        \n    }\n    \n    \n    \n    \n    // postprocessing\n  \n    col -= .2 * smoothstep(.49,.5,length(eDist));               // draw a light outline on hexagons\n    if( flip == 1. && red == .0){\n    col -= .2 * smoothstep(.48,.5,length(eDist)); \n    }\n    vec3 fao = vec3((smoothstep(.0,2.,eDist)));                  // Fake lightning gradient \n    col -= flip > .0 ?  fao+.25 :  .5 - fao;                     // apply it as a shadow or light on the cubes\n    col -= flip > .0 ? .05*smoothstep(.0,.5,length(eDist)) : .0;  \n    col -= vec3(-.7, -.85, .0) + smoothstep(.0,4.0,length(uv));  // color correction gradualy from the center \n    col *= 1. - .1 * length(dot(uv,uv));                         // vigneting \n    col  = pow(col, vec3(1.5));                                  // gamma \n\n    // color output\n    //col -= vec3(p2+p3+p4);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}