{"ver":"0.1","info":{"id":"NdGcR3","date":"1655238740","viewed":58,"name":"RayTracing Reflections","username":"modern_shinobi","description":"Multiple spheres and multiple reflections raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spheres","glsl","shadows","raytrace","multiple"],"hasliked":0,"parentid":"7sKcRV","parentname":"RayTracing MultiShadow"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float FLOAT_MAX = 10e+10;\n\n// Common structures definition\nstruct Sphere{\n    float radius;\n    vec3 center;\n    vec3 color;\n};\n\nstruct Plane{\n    float height;\n    vec3 color;\n    vec3 normal;\n};\n\nstruct Light{\n    vec3 dir;\n    float mag;\n    vec3 color;\n    vec3 ray;\n};\n\nstruct Ray{\n    vec3 dir;\n    vec3 origin;\n};\n\nstruct Hit{\n    float d;\n    vec3 point;\n    vec3 normal;\n};\n\n\n// Raycasting Functions definition\nHit RayCastPlane(vec3 rayOrigin, vec3 rayDir, inout Plane plane, float delta){\n    Hit hit = Hit(-1.0, vec3(0), vec3(0));\n    // Move hitpoint by delta to avoid 'acne'\n    rayOrigin += delta * plane.normal;\n    if (rayDir.y != 0.0){\n        hit.d = (plane.height - rayOrigin.y)/rayDir.y;\n        hit.point = rayOrigin + hit.d * rayDir;\n        hit.normal = plane.normal;\n    }\n    return hit;\n}\n\nHit RayCastSphere(vec3 rayOrigin, vec3 rayDir, inout Sphere sphere){\n    Hit hit = Hit(-1.0, vec3(0), vec3(0));\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, rayOrigin-sphere.center);\n    float c = dot(rayOrigin-sphere.center, rayOrigin-sphere.center) - \n                sphere.radius * sphere.radius;\n    \n    float det = b*b - 4.0*a*c;\n    if (det >= 0.0){\n        float d1 = (-b-sqrt(det))/2.0*a;\n        float d2 = (-b+sqrt(det))/2.0*a;\n        hit.d = min(d1,d2);\n        hit.point = rayOrigin + hit.d * rayDir;\n        hit.normal = normalize(hit.point - sphere.center);\n    }\n    return hit;\n}\n\nfloat RandFloat(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Main Function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Camera\n    vec3 cameraPos = vec3(0,1,-1);\n    Ray ray;\n    ray.origin = cameraPos;\n    ray.dir = normalize(vec3(cameraPos.x+uv.x, cameraPos.y+uv.y, 0) - cameraPos);\n    \n    // Light\n    Light light;\n    light.dir = vec3(sin(iTime), -1, cos(iTime));\n    // light.dir = vec3(0.6, -0.5, 1);\n    light.mag = 1.0;\n    light.color = vec3(1,1,1);\n    \n    light.dir = normalize(light.dir);\n    light.ray = light.dir * light.mag;\n    \n    // Objects\n    Plane ground;\n    ground.height = 0.0;\n    ground.color = vec3(0.33,0.75,0);\n    ground.normal = vec3(0,1,0);\n    \n    const int R = 5;    // Num reflections\n    const int N = 3;    // Num spheres\n    const float delta = 10e-5;\n    float shadowFactor = 0.3;\n    Sphere[N] spheres;\n    \n    spheres[0].radius = 1.0;\n    spheres[0].center = vec3(-0.5,1,4);\n    spheres[0].color = vec3(1,0.1,0.1);\n    \n    spheres[1].radius = 1.5;\n    spheres[1].center = vec3(0.8,1.5,6);\n    spheres[1].color = vec3(0.3,0.3,1);\n    \n    spheres[2].radius = 0.5;\n    spheres[2].center = vec3(-1,0.5,3);\n    spheres[2].color = vec3(1,1,0);\n\n    vec3 finalCol = vec3(0);\n    // Raycast Calculations\n    for (int iter=0; iter<R; iter++){\n\n        // Plane distance calculations\n        Hit hitGround = RayCastPlane(ray.origin, ray.dir, ground, 0.0);\n        // Sphere distance calculations\n        Hit[N] hitSphere;\n        for (int i=0; i<N; i++){\n            hitSphere[i] = RayCastSphere(ray.origin, ray.dir, spheres[i]);\n        }\n\n        // Finding closest object to camera\n        vec3 col = vec3(0,0,0);\n        int hitObj = -1;\n        Hit hit = Hit(FLOAT_MAX, vec3(0), vec3(0));\n        \n        // Color and overall distance calculations\n        if (hitGround.d > 0.0){\n            hitObj = 0;\n            hit = hitGround;\n            col = ground.color * dot(hitGround.normal, -light.ray);\n        }\n\n        // Minimum distances for all spheres\n        for (int i=0; i<N; i++){\n            if (hitSphere[i].d < 0.0) hitSphere[i].d = FLOAT_MAX;\n            if (hitSphere[i].d < hit.d){\n                hitObj = i+1;\n                hit = hitSphere[i];\n                col = spheres[i].color * dot(hitSphere[i].normal, -light.ray);\n            }\n        }\n        \n        // If no object hit then exit\n        if (hit.d == FLOAT_MAX){\n            if (iter == 0)\n                if (RandFloat(uv) < 0.001)\n                    finalCol = vec3(1,1,1);       \n            break;\n        }\n\n        // Shadow of ground plane calculation\n        Hit hitShadow = RayCastPlane(hit.point, -light.dir, ground, delta);\n        if (hitShadow.d >= 0.0)\n            col *= 0.0;\n        // Shadows of all objects calculation\n        for (int i=0; i<N; i++){\n            hitShadow = RayCastSphere(hit.point + delta*hit.normal, -light.dir, spheres[i]);\n            if (hitShadow.d >= 0.0)\n                col *= shadowFactor;\n        }\n\n        // Final color assignment\n        finalCol += col * pow(0.4, float(iter));\n        \n        // Change ray\n        ray.origin = hit.point + delta*hit.normal;\n        ray.dir = ray.dir - 2.0 * hit.normal * dot(ray.dir, hit.normal);\n    }\n\n\n    // d = min(hitGround.d, hitSphere.d);\n    // finalCol = vec3(1.0/d);\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}