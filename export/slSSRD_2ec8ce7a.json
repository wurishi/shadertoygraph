{"ver":"0.1","info":{"id":"slSSRD","date":"1627181710","viewed":94,"name":"Repeating Spheres Game","username":"falconXYZ","description":"Repeating Spheres using Ray Marching\n\nWASD to move\nSpace bar and shift to move up/down\nArrow Keys to look around\n\nLooking around is limited due to a bug I need to fix\nI will try to add collisions soon","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["ray","marching","casting"],"hasliked":0,"parentid":"7tBXzW","parentname":"Repeating Spheres"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//WASD TO MOVE\n//SPACE BAR AND SHIFT TO MOVE UP/DOWN\n//ARROW KEYS TO LOOK AROUND\n\n#define MAX_STEPS 256\n#define QUALITY 0.000001\n#define MAX_DISTANCE 1000.0\n\n\n\nfloat map(vec3 pos) {\n    float sphere = distance(mod(pos,4.)-2.,vec3(0.)) - 1.;\n    \n    return sphere;\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3( map(p-e.xyy) , map(p-e.yxy) , map(p-e.yyx) );\n    return normalize(n);\n}\n\nvec3 diffuseLighting(vec3 pos,vec3 lightPos,vec3 Color, float power) {\n    vec3 light = normalize(lightPos - pos);\n    vec3 normal = getNormal(pos);\n    \n    float diffuse = clamp(dot(normal, light),0.0,1.0);\n    return diffuse * Color * power;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.;\n    uv.y *= 0.5;\n    \n   // uv.x+=cos(iTime);\n    //uv.y+=sin(iTime);\n    //uv.x -= 0.6;\n    \n    vec2 rot = texelFetch(iChannel1, ivec2(0,0), 0).xy;\n    float ry = rot.y;\n    float rx = rot.x;\n    \n    vec3 offset = texelFetch( iChannel0, ivec2(0,0), 0 ).xyz;\n    \n    vec3 rayOrigin = vec3(0.0,0.0,-3.0) + vec3(-offset.x,offset.z,offset.y); //0,0,-3\n    \n    vec3 cw = normalize(vec3(cos(rx),cos(ry),sin(ry)+sin(rx)));\n    cw = normalize(vec3(0,1,0));\n    vec3 cu;\n    //if (sin(ry)<0.)\n//    cu = normalize(cross(cw,  vec3(0,-1,0)));\n   // else\n    cu = normalize(cross(cw,  normalize(vec3(0,1,0)*cw)));\n    vec3 cv = normalize(cross(cu,cw));\n    \n    vec3 rayDirection = mat3(cu,cv,cw) * normalize(vec3(uv,1.));\n    \n    float distanceFromOrigin = 0.0;\n    \n    vec3 diffuseWhite;\n    vec3 diffuseRed;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 rayPosition = rayOrigin + (rayDirection * distanceFromOrigin);\n        \n        float map = map(rayPosition);\n        \n        distanceFromOrigin += map;\n        \n        if (map < QUALITY || distanceFromOrigin > MAX_DISTANCE) {\n        \n            break;\n            }\n        diffuseRed = diffuseLighting(rayPosition,rayOrigin+vec3(-3,3,0), vec3(1,0,0), 1.0);\n        diffuseWhite = diffuseLighting(rayPosition,rayOrigin,vec3(1,1,1), 0.3);\n    }\n    vec3 diffuse = diffuseRed + diffuseWhite;\n    diffuse /= 2.0;\n    distanceFromOrigin/=4.0;\n    fragColor = vec4(diffuse,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_W  = 87;\nconst int KEY_A    = 65;\nconst int KEY_S = 83;\nconst int KEY_D  = 68;\nconst int KEY_SPACE = 32;\nconst int KEY_SHIFT = 16;\n\nvec3 handleKeyboard(vec3 offset) {\n    float velocity = 1. / 50.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(-1, 0, 0);\n    vec3 front = texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(0, 1, 0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(1, 0, 0);\n    vec3 back = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(0, -1, 0);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x * vec3(0, 0, 1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).x * vec3(0, 0, -1);\n        \n    \n    offset += (left + front + right + back + up + down) * velocity;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec3 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xyz;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, -1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, 1);\n\n    \n    offset += (left + up + right + down) * velocity;\n    \n//    if (offset.x > 4.)\n//        offset.x = 4.;\n//    if (offset.x < -1.)\n//        offset.x = -1.;\n//    if (offset.y > -3.5)\n//        offset.y = -3.5;\n//    if (offset.y < -6.)\n//        offset.y = -6.;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset;\n    if (iFrame > 5)\n        offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    else\n        offset = vec2(1.6,-4.5);\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0);\n}","name":"Buffer B","description":"","type":"buffer"}]}