{"ver":"0.1","info":{"id":"sdKcRV","date":"1655228551","viewed":103,"name":"modulus interference patterns","username":"graygoose","description":"If black screen, click anywhere to set the mouse. Make sure to play with the constants and the optional defines.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["interference","mod","moirre"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = hueShift(pF(iChannel0).xyz, sin(iTime));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hacked together, could use better color scaling among other things.\n// Uncomment mouse to vary patterns interactively. Otherwise, try changing the constants.\n\n//Try ~5 - ~500\n#define SCALING 50.\n\n#define VSPD1 1.8459\n#define VSPD2 .513\n\n//Change inversely with SCALE.\n#define VSPD3 3.956\n//#define VSPD3 (iMouse.x / iResolution.x * 2.)\n\n\n// Carpet constants: ABC:(R, G, B) channels.\n    // Try settings like ABC = 2,2,1; across all 3 channels. \n    // Or ABC = 5,15,30; pi,e,phi; Mix and match ABCs. \n    // The fewer common factors across channels, the fewer emergent patterns made of secondary colors.\n    // Moirre == Secondary+ patterns\n    // The fewer common factors in general, the more aperiodic it will seem.\n#define AR (BR * 9.)\n#define BR (CR * 4.)\n#define CR 36.\n\n#define AG (BG * 3.)\n#define BG (CG * 6.)\n#define CG 18.\n\n#define AB (BB * 3.)\n#define BB (CB * 9.)\n#define CB 27.\n\n\n// Optional:\n    // Changes the base coordinate for each pattern at 90* phase offset or mouse.\n#define VARYING_COORD\n//#define MOUSE_COORD\n\n    // Pan the plane\n//#define TIME_DISPLACE\n\n    // Vary carpet pattern factors with the mouse. \n    // With only this enabled, explore the space and notice some factors have more structure.\n    // This will not replace varying the carpet constants, as it's only exploring a space within the gratings they define.\n//#define MOUSE\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime / 30.0;\n\n    #ifdef TIME_DISPLACE\n    vec2 pos = vec2(sin(t), cos(t)) * VSPD1;\n    #else\n    vec2 pos = vec2(0.);\n    #endif\n    \n    vec2 uv = trunc((fragCoord/iResolution.y + pos) * SCALING);\n    \n    #ifdef VARYING_COORD\n    vec2 pos2 = vec2(cos(t) * VSPD1,  sin(t) * VSPD2) * VSPD3;\n    vec2 uv2 = trunc((fragCoord/iResolution.y + pos2) * SCALING);\n    #else\n    vec2 uv2 = uv;\n    #endif\n    \n    #ifdef MOUSE_COORD\n    vec2 pos2 = vec2(cos(iMouse.x) * VSPD1, sin(iMouse.y) * VSPD2) * VSPD3;\n    uv2 = trunc((fragCoord/iResolution.y + pos2) * SCALING);\n    #endif\n\n    #ifdef MOUSE\n    float o1 = iMouse.x / iResolution.x; float o2 = iMouse.y / iResolution.y;\n    float o3 = (iMouse.x * iMouse.y) / (iResolution.x * iResolution.y);\n    #else\n    float o1 = 1.;float o2 = 1.;float o3 = 1.;\n    #endif\n    \n    float r = mod(mod(dot(uv, uv2), AR*o1), BR*o2) / (CR*o3);\n    float g = mod(mod(dot(uv, uv2), AG*o3), BG*o1) / (CG*o2);\n    float b = mod(mod(dot(uv, uv2), AB*o2), BB*o3) / (CB*o1);\n\n\n    vec4 col = vec4(r*r-g*b, g*g-r*b, b*b-r*g, 1.0);\n        \n    fragColor = col;//+ (0.8*filter3x3(P, GAUSSIAN, iChannel0, RES));\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Utilities\n    // macros\n#define RES iResolution.xy\n#define P fragCoord.xy\n#define UV (fragCoord.xy/iResolution.xy)\n#define MUV (iMouse.xy/iResolution.xy)\n\n#define pF(c) texelFetch(c, ivec2(P), 0)\n#define sF(c) texture(c, UV)\n\n    // screen\nvec2 wrap(in vec2 p, in vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec4 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec4(vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle)), 0.);\n}\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.847,0.133,0.055,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.05, 0.95, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = filter3x3(P, LAPLACIAN, iChannel0, RES)+filter3x3(P, GAUSSIAN, iChannel1, RES);    \n}","name":"Buffer B","description":"","type":"buffer"}]}