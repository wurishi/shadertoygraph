{"ver":"0.1","info":{"id":"fsfXz8","date":"1618248279","viewed":145,"name":"Infinite Bagua","username":"meico","description":"The image takes the ideas from Taoist cosmology of the Bagua (eight trigrams) and 64 I-ching hexagrams, generalizes that as a binary counting system, then expresses that system with increasing bit depths toward infinity. LOOKS MORE INTERESTING FULLSCREEN","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["yinyang","iching","hexagram","trigram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on chinese hexgrams.\n// https://en.wikipedia.org/wiki/Bagua\n// https://en.wikipedia.org/wiki/Hexagram_(I_Ching)\n\n\n// Constants.\nfloat PI = 3.14159265358979323846264;\nfloat wheelSolidPortion = 5.0 / 6.0;\nfloat nGramSolidPortion = 2.0 / 3.0;\nfloat barSolidPortion = 0.9;\nfloat brokenBarSpacingPortion = 1.0 / 32.0;\nvec4 barColor = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 gapColor = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 bgColor  = vec4(0.5, 0.5, 0.5, 1.0);\n\n// Figure out the radius for the first \"wheel\" since we'll need it to\n// make sure the Taijitu (Yin Yang symbol) looks correct.\n//wheelVal = 2.0 * tan(radius * PI / 2.0)\n//wheelMaxRadius = 2.0 * atan(wheelVal / 2.0) / PI\n//wheel0Val < 1.0  therefore wheel0MaxRadius < 0.2951672353\nfloat wheel0MaxRadius = 0.2951672353;\n\n\n// Coordinate system conversions and rotations.\n// Functions from https://www.shadertoy.com/view/wsG3Dt\nvec2 cartesian2polar(vec2 cartesian){\n\treturn vec2(atan(cartesian.x,cartesian.y),length(cartesian.xy));\n}\nvec2 polar2cartesian(vec2 polar){\n\treturn polar.y*vec2(cos(polar.x),sin(polar.x));\n}\nvec2 rotate2D(vec2 coords, float amount){\n\treturn polar2cartesian(cartesian2polar(coords)+vec2(amount,0.));\n}\n\n\n\n// Create a Taijitu (Yin Yang symbol)\n// Function modifed from https://www.shadertoy.com/view/ldVGzK\nvec4 Taijitu(vec2 i) {\n    float a = dot(i,i);\n    float b = abs(i.y);\n    float v = (a>1. ? .5 : 9./(b-a-.23)/(b>a ? i.y : i.x));\n    return vec4(v,v,v,1);\n}\n\n\n\n// Used to make the visual ordering looks prettier.\n// Reorder the sequential integers to count up even values to the\n// maxVal and then count down in odd vals to zero.\nint GetReorderedVals(int n, int maxVal){\n   int a  =  n * 2;\n   if(a <= maxVal){\n       return a;\n   }else{\n      return (maxVal - (n * 2));  \n   }\n}\n\n\n// Evaluate the main image at a normalized coordinate.\nvec4 MakeImage(vec2 coordNegHalfAspToHalfAsp){\n    // Get the radius.\n    float radius = length(coordNegHalfAspToHalfAsp);\n    float radiusPx = radius * iResolution.y;\n    float diameterPx = 2.0 * PI * radiusPx;\n    \n    // Outside the mandalla is just gapColor.\n    if(radius >= 1.00) {\n        return bgColor;//vec4(1,0,0,1);\n    }\n\n    // Figure out which wheel we are on.\n    float wheelVal = 2.0 * tan(radius * PI / 2.0);\n    int wheelNum = int(wheelVal);\n    float wheelValFract = fract(wheelVal);\n    \n    // Animate the entire complex by making sucessive wheel coords\n    // rotate in opposite directions.\n    //float animBaseRadPerS = 0.3;\n    //float aniWheelRotDir = (wheelNum % 2 == 0)?1.0:-1.0;\n    //float animWheelRotRadsPerS = animBaseRadPerS / (float(wheelNum + 1) * float(wheelNum + 1));\n    //float animWheelRotAng = aniWheelRotDir * animWheelRotRadsPerS * iTime;\n    //coordNegHalfAspToHalfAsp = rotate2D(coordNegHalfAspToHalfAsp, animWheelRotAng);\n    \n    // Figure out the angular value to use.\n    float angNegPiToPi = atan(coordNegHalfAspToHalfAsp.y, coordNegHalfAspToHalfAsp.x);\n    float ang0toTwoPi = (angNegPiToPi > 0.0)?angNegPiToPi:(angNegPiToPi + (2.0 * PI));\n    float angPortion = ang0toTwoPi / (2.0 * PI);\n    \n    // Inside the center wheel place the Taijitu (Yin Yang symbol).\n    if(wheelNum == 0) {\n        // Get normalized coordinates within the center wheel.\n        float taijituSolidRadius = 1.0 *\n            (wheelSolidPortion * wheel0MaxRadius);\n        if(radius > taijituSolidRadius){\n            float bandPortion = \n                (radius - taijituSolidRadius) /\n                (wheel0MaxRadius - taijituSolidRadius);\n            if(bandPortion < 0.25){\n                return bgColor;\n            }else{\n                return gapColor;\n            }\n        }\n        \n        vec2 taijituCoord =\n            coordNegHalfAspToHalfAsp / taijituSolidRadius;\n        \n        // Put a Taijitu (Yin Yang symbol) here.\n        return Taijitu(taijituCoord);\n    }\n    \n    \n    // For the other wheels make the ring of ngrams.\n    \n    // Figure out which ngram's are on this wheel.\n    int nGramCount = int(pow(2.0, float(wheelNum)));\n    \n    // DEBUG : Handle subpixel sampling problems.\n    //if(float(nGramCount) > diameterPx){\n    //    fragColor = vec4(1,0,1,1);  \n    //    return fragColor;\n    //}\n    if( (abs(dFdx(wheelVal)) > 0.25) || (abs(dFdy(wheelVal)) > 0.25)){\n        return  bgColor;//vec4(1,1,0,1);//\n    }\n    // END DEBUG\n\n    // Between wheels are gapColor gaps.\n    if(wheelValFract > wheelSolidPortion) {\n        return gapColor;\n    }\n\n    // Figure out which ngram we're on, slightly rotatating each wheel so\n    // that they nicely visually align.\n    //float nGramVal = angPortion * float(nGramCount);\n    float nGramVal = fract(0.25 + angPortion + 0.5/float(nGramCount)) * float(nGramCount);\n    \n        \n    // DEBUG : Handle subpixel sampling problems.\n    //if( (abs(dFdx(nGramVal)) > 0.25) || (abs(dFdy(nGramVal)) > 0.25)){\n    //    return gapColor;//vec4(1,1,0,1);\n    //}\n    // END DEBUG\n    \n    // Determine which nGram we are on and how far laterally (rotationally)\n    // along it we are.\n    // For the wheel with tri-grams these number 0-7.\n    // For the whell with hea-grams these number 0-63.\n    int nGramNum = int(nGramVal);    \n    int nGramNumToUse =  GetReorderedVals(nGramNum, nGramCount-1);\n    float nGramValFract = fract(nGramVal);\n    \n    // Between nGrams is just gapColor.\n    float halfNGramSolidPortion = nGramSolidPortion / 2.0;\n    float nGramBgnFract = 0.5 - halfNGramSolidPortion;\n    float nGramEndFract = 0.5 + halfNGramSolidPortion;\n    if( (nGramValFract < nGramBgnFract) ||\n        (nGramValFract > nGramEndFract)) {\n        return gapColor;\n    }\n    \n    // Figure out how many horzontal bars (bits aka yÃ¡o) this\n    // ngram has and which one we're on. \n    float nGramPortion =\n        wheelValFract / wheelSolidPortion;\n    float barGap = (1.0 - barSolidPortion) / float(wheelNum - 1);\n    float barSolid = barSolidPortion / float(wheelNum);\n    float barHeight = barSolid + barGap;\n    float barVal = nGramPortion / barHeight;\n    float barHeightFract = fract(barVal);\n    \n    // Between nGram bars are just gapColor gaps.\n    if(barHeightFract > (barSolid / barHeight))\n    {\n        return gapColor;\n    }\n    \n    // Determine if this bar should be a solid (Yang) or\n    // broken (Yin) bar.\n    int barNum = int(barVal);\n    int barBitVal0Or1 = ((nGramNumToUse >> barNum) & 1);\n    if(barBitVal0Or1 == 0){\n        float brokenBaGabBgnFract = 0.5 - brokenBarSpacingPortion/2.0;\n        float brokenBaGabEndFract = 0.5 - brokenBarSpacingPortion/2.0;\n\n        if( (nGramValFract > brokenBaGabBgnFract) &&\n            (nGramValFract < (1.0 - brokenBaGabEndFract))) {\n            return gapColor;\n        }\n    }\n    \n    \n    // It's not the taijitu or a gap, so it must be a bar.\n    return  barColor;\n}\n\n// Take many samples of the main image function.\nint MaxSamples = 8;\nvec4 MakeMultiSampleImage( in vec2 uv, in float ddx_u, in float ddy_v)\n{\n    vec2 ddxy_uv = vec2(ddx_u, ddy_v);\n\n    int sx = MaxSamples;// + int( clamp( ddx_u, 0.0, float(MaxSamples-1) ) );\n    int sy = MaxSamples;// + int( clamp( ddy_v, 0.0, float(MaxSamples-1) ) );\n\n\tvec4 no = vec4(0.0);\n\n\t#if 1\n    for( int j=0; j<MaxSamples; j++ )\n    for( int i=0; i<MaxSamples; i++ )\n    {\n        if( j<sy && i<sx )\n        {\n           vec2 st = vec2( float(i), float(j) ) / vec2( float(sx),float(sy) );\n           no += MakeImage(uv + st * ddxy_uv);\n        }\n    }\n    #else\n    for( int j=0; j<sy; j++ )\n    for( int i=0; i<sx; i++ )\n    {\n        vec2 st = vec2( float(i), float(j) ) / vec2( float(sx),float(sy) );\n        no += MakeImage(uv + st * ddxy_uv);\n    }\n    #endif\t\t\n\n\treturn no / float(sx*sy);\n}\n\n// Actually generate the real image fragment values.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // Get the positon in the normalized coordinate space\n    // that we'll be using.\n    float aspectXtoY = iResolution.x / iResolution.y;\n    vec2 coord0ToAsp = (fragCoord.xy / iResolution.y);\n    vec2 coordNegHalfAspToHalfAsp;\n    coordNegHalfAspToHalfAsp.x = (coord0ToAsp.x - 0.5 * aspectXtoY) * 2.0;\n    coordNegHalfAspToHalfAsp.y = (coord0ToAsp.y - 0.5) * 2.0;\n    \n    //fragColor = MakeImage(coordNegHalfAspToHalfAsp);\n    fragColor = MakeMultiSampleImage( coordNegHalfAspToHalfAsp,\n        dFdx(coordNegHalfAspToHalfAsp).x,\n        dFdy(coordNegHalfAspToHalfAsp).y);\n}\n\n","name":"Image","description":"","type":"image"}]}