{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// MIT License\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat stars(vec3 rd) {\n    if(rd.y <= 0.0) return 0.0;\n    \n    float stars = 0.0;\n    vec2 uv = rd.xz / (rd.y + 1.0);\n    \n    vec2 id = floor(uv * 700.0 + 234.0);\n    float star = hash12(id);\n    float brightness = smoothstep(0.98, 1.0, star);\n    stars += brightness * 0.5;\n    \n    return stars * rd.y;\n}\n\nvec3 getSkyColor(vec3 rd, vec3 sunDir) {\n    float sunHeight = sunDir.y;\n    float dayTime = smoothstep(-0.1, 0.1, sunHeight);\n    float duskDawn = smoothstep(-0.3, 0.3, sunHeight) * (1.0 - dayTime);\n    float night = 1.0 - smoothstep(-0.3, 0.0, sunHeight);\n    \n    // colors\n    vec3 dayZenith = vec3(0.2, 0.4, 0.8);\n    vec3 dayHorizon = vec3(0.8, 0.9, 1.0);\n    vec3 duskZenith = vec3(0.2, 0.15, 0.3);\n    vec3 duskHorizon = vec3(1.0, 0.5, 0.2);\n    vec3 nightZenith = vec3(0.02, 0.02, 0.04);\n    vec3 nightHorizon = vec3(0.04, 0.05, 0.08);\n    \n    float horizon = pow(1.0 - max(rd.y, 0.0), 6.0 + night);\n    \n    // mix colors for each time of day\n    vec3 dayColor = mix(dayZenith, dayHorizon, horizon);\n    vec3 duskColor = mix(duskZenith, duskHorizon, horizon);\n    vec3 nightColor = mix(nightZenith, nightHorizon, horizon);\n    \n    vec3 skyColor = mix(nightColor, duskColor, duskDawn);\n    skyColor = mix(skyColor, dayColor, dayTime);\n    \n    float sunSpot = max(dot(rd, sunDir), 0.0);\n    float sunMask = pow(sunSpot, 64.0) * dayTime;\n    float sun = max(0.0, smoothstep(0.5, 1.5, dot(rd, sunDir))) * 0.5;\n    float sunDisc = smoothstep(0.999, 0.99925, dot(rd, sunDir));\n    \n    float starsIntensity = stars(rd);\n    \n    vec3 moonDir = -sunDir;\n    float moonGlow = pow(max(dot(rd, moonDir), 0.0), 32.0) * 0.5;\n    vec3 moonlight = vec3(0.6, 0.7, 0.9) * moonGlow;\n    float moonDisc = smoothstep(0.9995, 1.0, dot(rd, moonDir));\n    \n    return skyColor + ((sun + sunDisc) * dayTime) + ((moonlight + moonDisc + starsIntensity) * night);\n}\n\nvec3 getAnimatedSunDir(float time) {\n    float angle = time * 0.05 * 2.0 * 3.14;\n    return normalize(vec3(cos(angle), sin(angle), cos(angle)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro;\n    vec3 rd;\n    getRoRd(fragCoord, iResolution.xy, iMouse, iTime, ro, rd);\n    \n    vec3 sunDir = getAnimatedSunDir(iTime);\n    \n    vec3 col = getSkyColor(rd, sunDir);\n    \n    // Tonemapping and gamma correction\n    col.rgb = (col.rgb * (2.51 * col.rgb + 0.03)) / (col.rgb * (2.43 * col.rgb + 0.59) + 0.14);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// MIT License\n\n// ==================== Camera Stuff ==================== \n\nmat3 getCameraMatrix(vec3 ro, vec3 lookAt) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\nvoid getRoRd(vec2 fragCoord, vec2 resolution, vec4 imouse, float time, out vec3 ro, out vec3 rd)\n{    \n    vec2 uv = fragCoord/resolution.xy;\n    vec2 p = (2.0*fragCoord-resolution.xy)/resolution.y;\n    \n    // Orbit camera controls\n    vec2 mouse = imouse.xy/resolution.xy;\n    float camDist = 0.00001f;\n    \n    if (imouse.xy == vec2(0.0)) {\n        mouse = vec2(0.125, 0.6);\n    }\n    \n    mouse.y = 1.0 - mouse.y;\n    \n    // Convert mouse position to spherical coordinates\n    float azimuth = (mouse.x * 2.0 - 1.0) * 3.141592;\n    float elevation = (mouse.y - 0.5) * 3.141592;\n    \n    // Calculate camera position\n    ro = vec3(\n        camDist * cos(elevation) * cos(azimuth),\n        camDist * sin(elevation),\n        camDist * cos(elevation) * sin(azimuth)\n    );\n    \n    // Look at origin\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    mat3 camMat = getCameraMatrix(ro, lookAt);\n    rd = camMat * normalize(vec3(p, 2.0));\n\n}\n\n// ==================== End Of Camera Stuff ==================== ","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcGfDK","date":"1734452230","viewed":88,"name":"Simple Fast Sky","username":"TheNuclearWolf","description":"Played around with this a little with my previous clouds shader and wanted to take it a bit further.\nI like how customizable doing a sky like this is, but its really far from anything accurate haha.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","fast","sky","stars","atmosphere"],"hasliked":0,"parentid":"","parentname":""}}