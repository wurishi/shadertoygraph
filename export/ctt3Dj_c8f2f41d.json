{"ver":"0.1","info":{"id":"ctt3Dj","date":"1690160634","viewed":56,"name":"kawaii omrice","username":"tono","description":"omrice","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["omrice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = acos(-1.);\nmat2 rot(float a ){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 pmod(vec2 p, float r) {\n    float a =  atan(p.x, p.y) + pi/r;\n    float n = (pi * 2.) / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat scaleSphere( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\n\nfloat omrice(vec3 p,float i)\n{\n    float o = 0.;\n    p.y -= 0.1;\n    \n    p.y += clamp(sin(p.x/3. + (iTime+3.)*acos(-1.)/3. + i),0.,1.);\n    \n    o = scaleSphere(p,vec3(1.,0.5,.5),1.);\n    \n    return o;\n}\n\nfloat kechap(vec3 p,float i)\n{\n    float o = 10.;\n    p.y += 0.23;\n    \n    p.z += sin(p.x * 12.)/30.;\n    p.y += clamp(sin(p.x/3. + (iTime+3.)*acos(-1.)/3. + i),0.,1.);\n    o = scaleSphere(p,vec3(0.7,0.2,.4),1.);\n    return o;\n}\n\nvec2 image(vec3 p,float i)\n{\n    float plate = length(p / vec3(1.,.3,1.)) - 1.3;\n    plate = max(-plate , length((p +vec3(0.,-0.2,0.) )/ vec3(1.,.3,1.)) - 1.1);\n    float o = plate * .2;\n    \n    float tt = floor(iTime) + pow(fract(iTime) ,1.2);\n    float id = 0.;\n    p.z+= 0.3;\n    float om = omrice(p,i);\n    float kecha = kechap(p,i);\n    if(o > om){\n        id = 1.;\n        o = om;\n    }\n    if(o > kecha){\n    \tid = 2.;\n        o = kecha;\n    }\n    \n    return vec2(o,id);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 o = vec2(1.);\n    //p.xz = mod(p.xz,3.)-1.5;\n    float sep = 10.;\n    float id = floor(p.z/sep);\n    float t = id;\n    t = 1.;\n//     p.z += iTime;\n//     p.z = mod(p.z , sep)-sep/2.;\n//     p.xy = pmod(p.xy , 8.);\n    \n//     p.y -= 4. + sin(iTime + t);\n//     p.y = mod(p.y , 8.)-4.;\n    p.y += 0.1;\n    o = image(p,t);\n\treturn o;\n}\n\nvec2 march(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 99; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth,0.);\n}\n\nfloat getThick(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 33 ; i++)\n    {\n        vec3 rp = cp + rd * depth * 0.01;\n        float d = map(rp).x;\n        if(d > 0.)\n        {\n            return depth;\n        }\n        depth += max(abs(d) , 0.001);\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat resol = 70. ;\n    p = floor(p * resol)/resol;\n    vec3 cp = vec3(0.,-1.1,-2.);\n    //cp.yz *= rot(-pi * 1.1 );\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = .9;\n    vec3 rd = normalize(fov * cd + cs * p.x + cu * p.y);\n    vec3 col = vec3(1.,0.,0.);\n    col = vec3(105.,216.,243.)/255.;\n    col = vec3(250.,38.,115.)/255.;\n    \n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.01);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(iTime);\n        \n        float shadow = step(march(pos + N * 0.1 ,-sun).x,0.);\n        float rim = (1. - abs(dot(rd,N)) );\n        if(d.y < 1.)\n        {\n            //sara\n            float diff = mix(max(0.,dot(sun,N)),1.,.1 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,30.);\n        \tfloat cstep = 5.;\n            col =  floor( diff * vec3(.7) * cstep) /cstep;\n            col += floor( sp * 2.5 * vec3(1.) * cstep)/cstep;\n            col += floor( rim * vec3(1.) * cstep) / cstep;\n        }\n        else if(d.y == 1.){\n            float diff = mix(max(0.,dot(sun,N)),1.,.7 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,13.);\n            float cstep = 6.;\n            col =  floor( diff * vec3(1.,0.6,0.) * cstep) /cstep;\n            col += floor( sp * vec3(1.) * cstep)/cstep;\n            col += floor( rim * vec3(1.) * cstep) / cstep;\n            //col =  floor(col * cstep) / cstep;\n        }else if(d.y == 2.){\n        \tfloat diff = mix(max(0.,dot(sun,N)),1.,.7 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,13.);\n            \n            float cstep = 6.;\n            col =  floor( diff * vec3(0.8,0.,0.) * cstep) /cstep;\n            //col += floor( sp * 2.5 * vec3(1.) * cstep)/cstep;\n            //col += floor( rim * vec3(1.) * cstep) / cstep;\n            //col =  floor(col * cstep) / cstep;\n        }\n        \n        //col += (clamp(map(pos-2.4*rd).x*.8,.0,1.)-.5) * vec3(.5,.4,.1);\n        //col = floor(col *6.) / 6.;\n        //col *= shadow;\n        //float dd = 1.-exp(-0.0003 * d.x * d.x * d.x);\n    \t//col = mix(col,vec3(1.,.3,0.), dd);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}