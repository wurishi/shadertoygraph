{"ver":"0.1","info":{"id":"tdKcRK","date":"1603272585","viewed":534,"name":"barycentric compact","username":"Artleet","description":"my version of the triangle-based backgrounds inspired by\nhttps://www.shadertoy.com/view/MdfBzl","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["2d","barycentric","triangulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//my version of the triangle-based backgrounds inspired by\n//https://www.shadertoy.com/view/MdfBzl\n\n#define K 5.\n#define T (K + iTime * .2)\n#define S(a, b) vec2(cos(a),-sin(b))\n\n//barycentric coordinates\n//using some methods discovered by FabriceNeyret2\nvec3 b(vec2 a, vec2 b, vec2 c, vec2 p) {\n    a = inverse(mat2(b - a, c - a)) * (p - a);\n    return abs(vec3(1. - a.x - a.y, a));\n}\n\n//simple hash\nvec2 h(vec2 p){\n    return fract(sin(p * 34. + p.yx * 91.) * 4e5) * 2. - 1.;\n}\n\n//animation\nvec2 a(vec2 p){\n    vec2 b = h(p) * T;\n    return (p + S(b.x, b.y) * .2 + .5) / K;\n}\n\n//colour\nvec3 c(vec2 p) {\n    return .5 + .5 * cos(6.283 * (vec3(.8, .8, .5) * dot((p + h(p)) / K, S(T, T)) + vec3(0, .2, .5)));    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 u = fragCoord.xy / iResolution.y, id = floor((u *= mat2(1, 0, -.5, .8)) * K);\n    vec3 x, y, z, w;\n    float m = 1., d, q, r;\n   \n    for(int i=0; i<4; i++){       \n        //setup vertices coordinates\n        //using some methods discovered by FabriceNeyret2\n        //using i-i/2*2 instead i%2 for WebGL 1 compatibility \n        vec2 v0 = id - vec2(i-i/2*2,i/2), v1=v0, v2=v0, v3=v0+1.; v2.x++; v1.y++;\n\n       \t\n        //barycentric coordinates for two tiangles\n \t\tz = b(a(v0), a(v1), a(v2), u), \n        w = b(a(v1), a(v2), a(v3), u);\n        \n        //the sum of the coordinates - 1. to understand is the point inside the triangle or not\n        q = z.x + z.y + z.z - 1.,\n        r = w.x + w.y + w.z - 1.;\n        \n        //setup colours for the vertices of the triangles\n        //interpolation between colours of the vertices\n        z = mat3(c(v2), c(v0), c(v1)) * z, \n        w = mat3(c(v2), c(v1), c(v3)) * w;\n        \n        //if the point is out of the triangle - make a mask for the antialiasing, sum triangle colour otherwise\n        if(q > 1e-6) m = min(m, q * 1e2); else x += z;\n        if(r > 1e-6) m = min(m, r * 1e2); else x += w;\n\t\t\n        //mixing colours for antialiasing on edges\n        if(q < .01) y += z, d++;\n        if(r < .01) y += w, d++;\n    }\n    \n\tfragColor = vec4(mix(y / d, x, m), 1.);\n}","name":"Image","description":"","type":"image"}]}