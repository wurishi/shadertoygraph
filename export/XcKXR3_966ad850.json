{"ver":"0.1","info":{"id":"XcKXR3","date":"1716319043","viewed":253,"name":"Monte-Carlo sampling methods 2","username":"ukeshet","description":"Stratified (bottom left) + importance (bottom right) sampling,\nwithout slowing scene (replace 'render' in Common by your own). \nDrag to move camera or button (=green after 3*3 subpixel pre-sampling). \nDEMO_NOISE adds bad pixels, which the bias removes.","likes":11,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","reflection","importancesampling","sampling","montecarlo","stratifiedsampling"],"hasliked":0,"parentid":"4fKXRK","parentname":"Monte-Carlo sampling methods"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Monte Carlo sampling methods 2: \n// Stratified (bottom left) | importance (bottom right) | unbaised (top) sampling.\n// Demo for ICP course, by ukeshet.\n//\n// Drag mouse to move camera or button (red during 3*3 subpixels pre-sampling).\n// Keeping the button pressed shows only BSamp=4 samples.\n//\n// Improved version of Monte-Carlo sampling methods https://www.shadertoy.com/view/4fKXRK\n// Scene modified from Photorealism by Poisson https://www.shadertoy.com/view/dssXRj\n// _______________________________________________________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo)\n{\n    vec4 setup = texelFetch(iChannel0, ivec2(0), 0);\n    uint cnt,x,y,b1,c1;\n    UnpackCntl(setup.x, cnt, x, y, b1, c1);\n    if (length(Coo-vec2(x,y))<BtnR) { // Color button\n        if (cnt<uint(MinSamp))\n            Col=vec4(1,0,0,1);\n        else\n            Col=vec4(0,1,0,1);        \n        return;\n    }\n    uint Cx,Cy,b,c;\n    UnpackCntl(setup.y, cnt, Cx, Cy, b, c);\n    vec3 col;\n    vec4 dat = texelFetch(iChannel1, ivec2(Coo), 0);\n    if (c==uint(0)) { // Unbiased pre-sampling\n        float J;\n        vec3 col2;\n        UnpackF16(col.x,col.y,dat.x);\n        UnpackF16(col.z,J,dat.y);\n        dat = texelFetch(iChannel2, ivec2(Coo), 0);\n        UnpackF16(col2.x,col2.y,dat.x);\n        UnpackF16(col2.z,J,dat.y);\n        col += col2;\n        dat = texelFetch(iChannel3, ivec2(Coo), 0);\n        UnpackF16(col2.x,col2.y,dat.x);\n        UnpackF16(col2.z,J,dat.y);\n        col = (col+col2)/3.;\n    }\n    else { // Biased sampling\n        if (abs(Coo.y-float(y))<1.1 || \n            (abs(Coo.x-float(x))<1.1 && Coo.y<float(y))) {\n            Col*=0.;\n            return;      \n        }        \n        UnpackF16(col.x,col.y,dat.x); \n        float Q;\n        UnpackF16(col.z,Q,dat.y);\n    }  \n    col = pow(col,vec3(.4545));  // gamma correction\n    col = ACES(col);             // tonemapping\n    vec2 p = Coo/iResolution.xy; // vignette\n    col *= .5+.5*pow(16.*p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n    Col = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A\n// Control buffer: mouse, counter, B-D stat collection, bias computation.\n// ______________________________________________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo)\n{   \n    if (iFrame<1) {\n        Col = vec4(PackCntl(uint(0),uint(iResolution.x*.5+BtnR),\n                            uint(iResolution.y*.33+BtnR),uint(0),uint(0)),\n                   PackCntl(uint(0),uint(iResolution.x)/uint(2),\n                            uint(iResolution.y)/uint(2),uint(0),uint(0)),\n                   0,0);\n        return;\n    }\n    vec4 setup = texelFetch(iChannel0, ivec2(0), 0);\n    uint cnt,x,y,Cx,Cy,b1,b,c1,c;      // b1/c1 button control\n    UnpackCntl(setup.x,cnt,x,y,b1,c1);\n    UnpackCntl(setup.y,cnt,Cx,Cy,b,c); // c=(presampling done?)\n    cnt++;\n    if (iMouse.z>0.) {\n        if (length(iMouse.xy-vec2(x,y))>BtnR && b1==uint(0)) {\n            if (Cx/uint(2)!=uint(iMouse.x)/uint(2) || Cy/uint(2)!=uint(iMouse.y)/uint(2)) {\n                c=cnt=uint(0);\n                Cx=uint(iMouse.x); Cy=uint(iMouse.y);\n            }\n        } else {\n            if (b1==uint(0)) {\n                b1=uint(1); \n                c1=uint(0);\n            }\n            else {\n                if (x/uint(2)==uint(iMouse.x)/uint(2) && y/uint(2)==uint(iMouse.y)/uint(2))\n                    c1=uint(1);\n                else\n                    c1=uint(0);\n            }\n            x=uint(iMouse.x); y=uint(iMouse.y);\n        }\n    } else {\n        if (b1==uint(1) && c==uint(1) && cnt>uint(MinSamp+10))\n            cnt=uint(MinSamp+10);\n        b1=uint(0);\n        c1=uint(0);\n    }\n    if (cnt==uint(MinSamp))  // Done presampling\n        c=uint(1);           // So we have samples 0,1,...,MinSamp.\n    if (abs(Coo.x)<1.5 && abs(Coo.y)<1.5) {\n        cnt = min(cnt,uint(CntMax));\n        Col = vec4(PackCntl(cnt,x,y,b1,c1),PackCntl(cnt,Cx,Cy,b,c),0,0);\n        return;\n    }    \n    if (cnt==uint(MinSamp)) { // Done presampling; sum RGB\n            float Z;\n            vec3 col,tot;\n            Col = texelFetch(iChannel1, ivec2(Coo), 0); // keep B's xy\n            UnpackF16(tot.x,tot.y,Col.x); UnpackF16(tot.z,Z,Col.y);\n            vec4 Bf = texelFetch(iChannel2, ivec2(Coo), 0);\n            UnpackF16(col.x,col.y,Bf.x); UnpackF16(col.z,Z,Bf.y);\n            tot += col;\n            Bf = texelFetch(iChannel3, ivec2(Coo), 0);\n            UnpackF16(col.x,col.y,Bf.x); UnpackF16(col.z,Z,Bf.y);\n            tot = (tot+col)/3.;\n            Col.zw=vec2(PackF16(tot.x,tot.y),PackF16(tot.z,float(cnt)/1024.)); \n    }  \n    if (cnt>uint(MinSamp)) { // Biased sampling\n        Col = texelFetch(iChannel0, ivec2(Coo), 0);\n        if (cnt==uint(MinSamp+1)) { // Collect stats and compute weights\n            vec3 col;\n            float I[9],J[9];\n            vec4 Bf[3];\n            Bf[0] = texelFetch(iChannel1, ivec2(Coo), 0);\n            Bf[1] = texelFetch(iChannel2, ivec2(Coo), 0);\n            Bf[2] = texelFetch(iChannel3, ivec2(Coo), 0);\n            Bf[0].xy = Col.xy; // Buffers A,B already swaped RGB in xy.\n            for (int i=0; i<3; i++) { // Collect statistics\n                UnpackF16(col.x,col.y,Bf[i].x); \n                UnpackF16(col.z,J[3*i],Bf[i].y); \n                UnpackF16(I[3*i],J[3*i+1],Bf[i].z); \n                UnpackF16(I[3*i+1],J[3*i+2],Bf[i].w); \n                I[3*i+2]=max(0.,3.*MyLen(col)-I[3*i]-I[3*i+1]);\n            }\n            // Compute series of 16 sub-pixels for each sampling method\n            float Std=-7.e17, Bri=-7.e17;\n            for (int i=0; i<3; i++) \n                for (int j=0; j<3; j++) {\n                    int ind=i*3+j;\n                    Bri = max(Bri, I[ind]);\n                    float BrF16 = max(0.0078125, I[ind]); // >=1/128\n                    J[ind] = sqrt(max(0.,J[ind]-BrF16*BrF16));\n                    Std = max(Std, J[ind]);\n                }\n            float dBri = Bri/16.-EPS, dStd = Std/16.-EPS;\n            uint F1B=uint(0), F1A=F1B&uint(0x00000000), F2A, F2B; \n            F1B=F2A=F2B=F1A;\n            for (int k=0; k<16; k++) { // Greedy distribution\n                int fnd1=0, fnd2=0;\n                for (int i=0; fnd1+fnd2<2 && i<3; i++) \n                    for (int j=0; fnd1+fnd2<2 && j<3; j++) {\n                        int ind=i*3+j;\n                        if (fnd1==0)\n                            if (I[ind]>=Bri) {\n                                fnd1++;\n                                Bri = I[ind] = I[ind]-dBri;\n                                if (k<8) F1A|=(uint((ind+1)&0xF)<<(4*k));\n                                else F1B|=(uint((ind+1)&0xF)<<(4*k-32));\n                            }\n                        if (fnd2==0)\n                            if (J[ind]>=Std) {\n                                fnd2++;\n                                Std = J[ind] = J[ind]-dStd;\n                                if (k<8) F2A|=(uint((ind+1)&0xF)<<(4*k));\n                                else F2B|=(uint((ind+1)&0xF)<<(4*k-32));\n                            }\n                    }\n            }\n            Col=vec4(uintBitsToFloat(F1A), uintBitsToFloat(F1B), \n                     uintBitsToFloat(F2A), uintBitsToFloat(F2B));\n        } \n    }        \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926536\n#define TAU 6.2831853072\n\n#define DEMO_NOISE // Add burned pixels to scene (to demonstrate sampling)\n#define MAX_BLACK 8\n#define MAX_WHITE 0\n\n#define RGBMax 1. // Keep RGB in [0,1] range\n#define EPS 2e-7\n\n// _________________________________________________________________\n// Section 1. Scene-specific. Revise as necessary. \n// (Farther below, Section 2 provides auxiliary sampling functions.)\n// _________________________________________________________________\n\n#define MOVE_CAMERA\n#define S smoothstep\n\n#define CamPh0 3.8     // Initial camera position angle\n#define CamMinH -.99   // Minimal camera height\n#define Cam0 vec3(8.*sin(CamPh0),-.7,8.*cos(CamPh0)) // initial camera position\n#define SetCam(Cx,Cy) {float ang=CamPh0-TAU*(float(Cx)/iResolution.x-.5); Cam=vec3(8.*sin(ang), max(CamMinH,Cam0.y+(float(Cy)/iResolution.y-.5)*10.), 8.*cos(ang));}\n\n// materials indices\n#define ROUGH 1 // metal and lambertian\n#define DIELECTRIC 2 // glass\n\nfloat seed; // randoms seed\nfloat hash1b(vec2 co, vec2 of) {vec4 k4=vec4(.1031,.11369,.13787,.09713), comb=fract(vec4(co,of)*k4); \n                        comb+=dot(comb,comb.ywzx+19.19); return fract((comb.x+comb.y)*(comb.z+comb.w)); }\n#define hash(co) fract(sin(dot(co.xy,vec2(12.989826,68.233531)))* 4372.5468)\n\n// hash functions by Poisson\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\nvec2 hash2() {return fract(sin((seed+=1.1)*vec2(8472.5636,9854.4213)));}\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// random normalized vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra, vec3 mat, int type, vec2 v,\n                   float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype, inout vec2 outv) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    if (h<0.) return tmax;\n    \n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    float t = t1<.0001 ? t2 : t1;\n    if (t>.0001 && t<tmax) {\n        outn = (oc + rd*t)/ra;\n        outmat = mat;\n        outtype = type;\n        outv = v;\n        return t;\n    }\n    return tmax;\n}\n\n\n// torus sdf\nfloat sdTorus(vec3 p, float ra, float rb) {\n    return length(vec2(length(p.xz)-ra,p.y))-rb;\n}\n\n// full torus sdf\nfloat sdTorusF(vec3 p, float ra, float rb) {\n    return length(max(vec2(length(p.xz)-ra,p.y),0.))-rb;\n}\n\n// glass curve\n// https://www.desmos.com/calculator/u9oxcvjhqp\nfloat glassCurve(float x) {\n//    return .1*S(.95,1.,x)+.35*S(.46,.4,x)*S(-1.3,1.1,x);\n    return .2*S(.95,1.,x)+.22*S(.56,.4,x)*S(-1.3,.4,x);\n}\n\n// glass sdf\nfloat sdGlass(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorus(p + vec3(0,1.475,0)*h, glassCurve(h), .02);\n}\n\n// full glass sdf\nfloat sdGlassF(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorusF(p + vec3(0,1.475,0)*h, glassCurve(h)-.022, 0.);\n}\n\n// bottle curve\n// https://www.desmos.com/calculator/nftvjzacqh\nfloat bottleCurve(float x) {\n    return .07+.12*pow(S(.2,.57,x),1.2);\n}\n\n// bottle sdf\nfloat sdBottle(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorus(p + vec3(0,1.475,0)*h, bottleCurve(h), .025);\n}\n\n// full bottle sdf\nfloat sdBottleF(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*0.6779661017, 0., 1.);\n    return sdTorusF(p + vec3(0,1.475,0)*h, bottleCurve(h)-.027, 0.);\n}\n\n// Mirror sdf\nfloat sdMirror(vec3 p, float w) {\n    float sina=.9,cosa=.436;\n    p.xz=vec2(cosa*p.x-sina*p.z,sina*p.x+cosa*p.z);\n    return length(max(abs(p)-vec3(w,.1,.25),0.));\n}\n\n\n// materials indices\n#define MAT_GLASS 0.\n#define MAT_BOTTLE 1.\n#define MAT_WINE 2.\n#define MAT_MIRR 3.\n#define MAT_MIRR_BASE 4.\n\n// union of two objects\nvec2 opU(vec2 a, vec2 b) {return a.x<b.x ? a : b;}\n\n// scene sdf\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10);\n\n    // wine\n    d = opU(d, vec2(max(sdGlassF(p*.5+vec3(-.4,0,.2)),abs(p.y)-.4-1.08+.0), MAT_WINE));\n    d = opU(d, vec2(max(sdGlassF(p*.5-vec3(-.4,0,.2)),abs(p.y-1.15+.6)-.4), MAT_WINE));\n    d = opU(d, vec2(max(sdBottleF((p-vec3(-1.8,.975,2.7))*.25),abs(p.y-1.5+1.2)-1.2), MAT_WINE));    \n\n    // glasses\n    d = opU(d, vec2(sdGlass(p*.5+vec3(-.4,0,.2))*.5, MAT_GLASS));\n    d = opU(d, vec2(sdGlass(p*.5-vec3(-.4,0,.2))*.5, MAT_GLASS));\n        \n    // bottle\n    d = opU(d, vec2(sdBottle((p-vec3(-1.8,.975,2.7))*.25), MAT_BOTTLE));\n\n    d = opU(d, vec2(sdMirror((p-vec3(-2.6,-.6,-0.7))*.25,.005), MAT_MIRR));\n    d = opU(d, vec2(sdMirror((p-vec3(-2.6,-1.38,-0.7))*.25,.025), MAT_MIRR_BASE));\n\n    return d;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n// raymarching loop\nfloat raymarch(vec3 ro, vec3 rd, float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype, inout vec2 outv) {\n    float t = 0.; // distance\n    float s = sign(map(ro).x); // inside and outside the surface\n    vec2 h; // scene sdf + material idx;\n    \n    float ttmax = tmax;\n    tmax = min(tmax, 16.);\n    \n    for (int i=0; i<256 && t<tmax; i++) {\n        vec3 p = ro + rd*t;\n        h = map(p); h.x *= s;\n        if (abs(h.x)<.0001) break;\n        t += h.x;\n    }\n    \n    if (t>.0001 && t<tmax) {\n        vec3 p = ro + rd*t; // hit point\n        outn = calcNormal(p);\n        outtype = DIELECTRIC;\n        \n        if (h.y==MAT_GLASS) { // glass\n            outmat = vec3(.99);\n            outv = vec2(1.5,0); // ior 1.5\n        } else if (h.y==MAT_BOTTLE) { // bottle\n            outmat = vec3(.1,.6,.1);\n            outv = vec2(1.4,0); // ior 1.4\n        } else if (h.y==MAT_WINE) { // wine\n            outmat = vec3(.15,0,0);\n            outv = vec2(1.3,0); // ior 1.3\n        }  else if (h.y==MAT_MIRR) { // mirror\n            outtype = ROUGH;\n            outmat = vec3(.9,.9,.9);\n            outv = vec2(0.,1.);\n        }  else if (h.y==MAT_MIRR_BASE) { // mirror base\n            outtype = ROUGH;\n            outmat = vec3(.0,.0,.2);\n            outv = vec2(10,.0); \n        }  \n        return t;\n    }\n    return ttmax;\n}\n\n\n\n// diffuse BRDF\nvec3 cosineDirection(vec3 n) {\n  \tvec2 r = hash2();\n    \n\tvec3 u = normalize(cross(n, vec3(0,1,1)));\n\tvec3 v = cross(u, n);\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(TAU*r.x); \n\tfloat ry = ra*sin(TAU*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\treturn normalize(rx*u + ry*v + rz*n);\n}\n\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n\tvec3 w = normalize(ta - ro);\n\tvec3 u = normalize(cross(w, vec3(0,1,0)));\n\tvec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\n// realistic color range\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c =  2.1;\n    float d =   .7;\n    float e =  .12;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// plane intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat plaIntersect(in sampler2D ch, vec3 ro, vec3 rd, vec3 n, float h, vec3 mat, int type, vec2 v, \n                   float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype, inout vec2 outv) {\n    float t = (h-dot(n,ro))/dot(rd,n);\n    if (t>.0001 && t<tmax) {\n\t\toutn = n;\n        vec3 p = ro + rd*t;\n        outmat = pow(texture(ch, p.xz*.5).rgb,vec3(2.2)); // wood texture\n        outtype = type;\n        outv = v;\n\t    return t;\n    }\n    return tmax;\n}\n\n// scene intersection function\n// n is the normal, mat is the object albedo, type is the material type\n// v is the material propreties: \n//  ROUGH -> rougness and reflectance\n//  DIELECTRIC -> refraction index\nfloat intersect(in sampler2D ch, vec3 ro, vec3 rd, out vec3 n, out vec3 mat, out int type, out vec2 v) {\n    float t = 1e10;\n    \n    t = plaIntersect(ch, ro, rd, vec3(0,1,0), -1., vec3(1), ROUGH, vec2(1,-.5), t, n, mat, type, v);\n    t = sphIntersect(ro, rd, vec3(-1.2,-.7,-1.7), .3, vec3(1), DIELECTRIC, vec2(1.5,0), t, n, mat, type, v); // watery\n    t = sphIntersect(ro, rd, vec3(0.1,-.5,-2.0), .5, vec3(.2,.5,1), ROUGH, vec2(1,.03), t, n, mat, type, v); // bluish\n    t = sphIntersect(ro, rd, vec3(0.9,-.55,-2.65), .45, vec3(1,.3,.1), ROUGH, vec2(1,.005), t, n, mat, type, v); // orange\n    t = sphIntersect(ro, rd, vec3(-1.4,-.7,-1.0), .3, vec3(1,.4,.2), ROUGH, vec2(0,-1e10), t, n, mat, type, v); // metallic\n    t = sphIntersect(ro, rd, vec3(-2.2,-.75,-1.1), .25, 3.*vec3(.5,.5,.1), DIELECTRIC, vec2(1.4,0), t, n, mat, type, v); // yellow      \n    t = raymarch(ro, rd, t, n, mat, type, v);  \n    return t;\n}\n\n// rendering function\nvec3 render(in samplerCube ch1, in sampler2D ch2, vec3 ro, vec3 rd) {\n    vec3 col = vec3(1);\n    \n    for (int i=0; i<12; i++) { // ray bounces: reduced 12 to 6\n        vec3 n, mat; int type; vec2 v;\n        float t = intersect(ch2, ro, rd, n, mat, type, v);\n        if (t>=1e10) {\n            // hdr skybox\n            vec3 sky = pow(textureLod(ch1, rd.zyx, 0.).rgb,vec3(4));\n            sky = 8.*pow(sky,vec3(.9,.9,1));\n            return col*sky;\n        } else {\n            vec3 p = ro + rd*t; // hit point\n            ro = p;\n            \n            float fre = dot(rd, n); // fresnel\n            if (type==ROUGH) {\n                vec3 rd0 = reflect(rd, n); // reflected ray\n                vec3 rd1 = cosineDirection(n); // diffuse ray\n                \n                float refProb = v.y + (1.-v.y)*pow(1.+fre, 5.);\n                if (hash1()<refProb) {\n                    rd = rd0;\n                } else {\n                    rd = normalize(mix(rd0, rd1, v.x));\n                    col *= mat;\n                }\n            } else if (type==DIELECTRIC) { // transparent\n                float cosine;\n                if (fre>0.) {\n                    cosine = sqrt(1.-v.x*v.x*(1.-fre*fre));\n                } else {\n                    cosine = -fre;\n                }\n                float s = sign(fre);\n                vec3 m = -n*s;\n                float i = (.5-.5*s)/v.x+v.x*(.5+.5*s);\n    \n                fre = dot(rd, m);\n                \n                float refProb;\n                // reflected and refracted ray\n                vec3 rd1, rd0 = reflect(rd, n);\n                \n                float h = 1.-i*i*(1.-fre*fre);\n                if (h>0.) {\n                    rd1 = i*(rd - m*fre) - m*sqrt(h); // refraction\n                    \n                    float r0 = (1.-v.x)/(1.+v.x);\n                    r0 = r0*r0;\n                    refProb = r0 + (1.-r0)*pow((1.-cosine),5.);\n                } else {\n                    refProb = 1.;\n                }\n        \n                if (hash1()<refProb) {\n                    rd = rd0;\n                } else {\n                    ro -= m*.0009; // bump the point\n                    rd = rd1;\n                    col *= mat;\n                }\n            }\n        }\n    }\n    return vec3(0); // return black if the ray stops\n}\n\nvec3 GetRender(in samplerCube ch1, in sampler2D ch2, vec3 Cam, vec2 p, vec2 co, \n               vec2 ofSeed) { // ofSeed=(0\\1\\2)^2 \n        #ifdef DEMO_NOISE\n            vec2 pos=floor(ofSeed);\n            float h1=0., tmp;\n            for (int i=0;i<MAX_BLACK;i++) {\n                h1 = fract(h1+hash(floor(co+EPS)));\n                tmp = 3.*pos.x+pos.y;\n                if (tmp<h1*9. && tmp>h1*9.-1.)\n                    return vec3(0);\n            }\n            for (int i=0;i<MAX_WHITE;i++) {\n                h1 = fract(h1+hash(floor(co+EPS)));\n                tmp = 3.*pos.x+pos.y;\n                if (tmp<h1*9. && tmp>h1*9.-1.)\n                    return vec3(1);\n            }\n        #endif\n        seed += hash1()*434.251;\n        vec3 n, mat, ro=Cam, ta = vec3(0,.5,0); // target\n        vec2 v;\n        int type; \n        mat3 ca = setCamera(ro, ta); // camera matrix\n        vec3 cOff = vec3(uniformVector().xy,0)*.0; // <- change this value for the aperture\n        float t = intersect(ch2, ro, normalize(ta-ro), n, mat, type, v); // depth of field \n        vec3 rd = ca * normalize(vec3(p,1.78)); // ray direction\n        vec3 fp = ro + rd*t; // focus plane\n        ro += ca*cOff;\n        rd = normalize(fp-ro);\n        return max(min(render(ch1, ch2, ro, rd),RGBMax),0.);\n}\n\n// ________________________________________________\n// ________________________________________________\n// ____                                        ____\n// ____  Above: image defs; change for scene   ____\n// ____  Below: sampling related definitions   ____\n// ________________________________________________\n// ________________________________________________\n\n\n// Section 2. Sampling definitions.\n// Monte-Carlo sampling with 3*3 subpixel pre-sampling\n\n#define MinSamp (3*9) // Samples/pixel before biasing\n// MinSamp must be 9*integer; minimum 3*9 for stratified sampling\n#define CntMax 2046   // Maximal samples/pixel \n#define BSamp 4       // # of biased samples when green button clicked\n#define BtnR 10.      // red/green button size\n#define uBtnR uint(10)\n\nvec3 nCol = vec3(27,91,10)/128.;  // Direction defining brightness.\n#define MyLen(v) dot(v, nCol)\n\n// F16 = a 16-bit unsigned float with a 4-bit-15 bias exponent. \nfloat PackF16(float a, float b) { // pack two F16\n    a=min(1.,max(a,1./32768.)); \n    b=min(1.,max(b,1./32768.));\n    float a_exp = floor(log2(a)+15.);\n    uint a_mantissa = uint((a*exp2(-a_exp+15.)-1.)*4096.);\n    float b_exp = floor(log2(b)+15.);\n    uint b_mantissa = uint((b*exp2(-b_exp+15.)-1.)*4096.);\n    uint a_bits = (uint(a_exp)<<12)|a_mantissa;\n    uint b_bits = (uint(b_exp)<<12)|b_mantissa;\n    return uintBitsToFloat((a_bits<<16)|b_bits);\n}\n\nvoid UnpackF16(out float a, out float b, float org) { // unpack two F16\n    uint comb = floatBitsToUint(org);\n    uint a_bits = comb>>16;\n    uint b_bits = comb&uint(65535);\n    uint a_exp = a_bits>>12;\n    uint a_mantissa = a_bits&uint(4095);\n    uint b_exp = b_bits>>12;\n    uint b_mantissa = b_bits&uint(4095);\n    a = (float(a_mantissa)/4096.+1.)*exp2(float(a_exp)-15.);\n    b = (float(b_mantissa)/4096.+1.)*exp2(float(b_exp)-15.);\n}\n\nfloat ZeroF16=33./1048576.;\n\n// Control float pack/unpack\nfloat PackCntl(uint cnt, uint x, uint y, uint b, uint c) { // y<7 -> float NAN\n    return uintBitsToFloat(((y&uint(0x3FE))<<22) | ((b&uint(0x01))<<22) |\n       ((cnt&uint(0x7FF))<<11) | (x&uint(0x7FE)) | (c&uint(0x01)));\n}\n\nvoid UnpackCntl(float org, out uint cnt, out uint x, out uint y,\n                out uint b, out uint c) {\n    uint comb = floatBitsToUint(org);\n    y = (comb>>22)&uint(0x3FE);\n    b = (comb>>22)&uint(0x01);\n    cnt = (comb>>11)&uint(0x7FF);\n    x = comb&uint(0x7FE);\n    c = comb&uint(0x01);\n}\n\nuint Collect(float offset, in sampler2D ch0, in samplerCube ch1, in sampler2D ch2, in sampler2D ch3, \n             out vec4 Col, in vec2 Coo, vec3 iResolution, float Time) {\n    vec4 setup = texelFetch(ch3, ivec2(0), 0);\n    uint cnt, Cx, Cy, b, c; // c=(enough samples?)\n    UnpackCntl(setup.y,cnt,Cx,Cy,b,c);\n    if (c==uint(0)) {       // Pre-sampling\n        float J1,J2,J3,I1,I2;\n        J1=J2=J3=I1=I2=0.;\n        if (cnt==uint(0)) { // First buffer call\n            Col=vec4(PackF16(ZeroF16,0.),PackF16(ZeroF16,0.),\n                     PackF16(ZeroF16,0.),PackF16(ZeroF16,0.));\n        }\n        else Col = texelFetch(ch0, ivec2(Coo), 0);\n        if (mod(float(cnt)+EPS-offset,3.)>.1)  // not this buffer's turn\n            return c;       \n        if (cnt>=uint(MinSamp))  // presampling just finished\n            return c;\n        vec3 col=vec3(0);\n        if (cnt>uint(2)) {       // previous buffer meaningful\n            UnpackF16(col.x,col.y,Col.x);\n            UnpackF16(col.z,J1,Col.y);\n            UnpackF16(I1,J2,Col.z);\n            UnpackF16(I2,J3,Col.w);\n        }\n        float slct = mod((float(cnt)-1.*offset)/3.+10.*EPS,3.); // ~0\\1\\2\n        seed += float(cnt)+Time + dot(sin(Coo),vec2(443.712,983.234));\n        vec2 of = (vec2(offset,slct)+hash2())/3.-.5; // (-.5,.5)       \n        vec3 Cam; SetCam(Cx,Cy);\n        vec3 ren = GetRender(ch1, ch2, Cam, (Coo+of-.5*iResolution.xy)/iResolution.y, \n                            Coo, (of+.5)*3.+EPS);    // ~(0\\1\\2)^2\n\n        float prvSamp = floor((float(cnt)+EPS)/3.);\n        col = (ren+col*prvSamp)/(prvSamp+1.); \n        float I = MyLen(ren);\n        float J = I*I;\n        prvSamp = floor((float(cnt)+EPS)/9.+EPS);\n        if (slct<.5) {\n           I1=(I1*prvSamp+I)/(prvSamp+1.); \n           J1=(J1*prvSamp+J)/(prvSamp+1.); \n        } else if (slct<1.5) {\n           I2=(I2*prvSamp+I)/(prvSamp+1.); \n           J2=(J2*prvSamp+J)/(prvSamp+1.); \n        } else \n           J3=(J3*prvSamp+J)/(prvSamp+1.); \n        Col = vec4(PackF16(col.x,col.y),PackF16(col.z,J1),\n                   PackF16(I1,J2),PackF16(I2,J3));\n    }\n    return c;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B\n// Pre-samples bottom subpixel row; later performs bias-sampling.\n// ______________________________________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {   \n\n    if (Collect(0., iChannel0, iChannel1, iChannel2, iChannel3, Col, Coo, \n        iResolution, iTime)==uint(1)) { // Presampling done; biased sampling\n        vec4 setup = texelFetch(iChannel3, ivec2(0), 0);\n        uint cnt,Cx,Cy,b,c;   \n        UnpackCntl(setup.y,cnt,Cx,Cy,b,c);\n        uint x,y,b1,c1;\n        UnpackCntl(setup.x,cnt,x,y,b1,c1); \n        vec4 prev = texelFetch(iChannel0, ivec2(Coo), 0);\n        vec4 stat = texelFetch(iChannel3, ivec2(Coo), 0);\n        \n        if (cnt==uint(MinSamp+0)) { // get total RGB\n            Col = vec4(stat.zw, prev.zw);\n            return;\n        }\n        if (cnt<=uint(MinSamp+1) || c1==uint(1) || \n            (cnt>uint(CntMax) && b1==uint(0))) {\n            Col = prev;\n            return;            \n        }\n        int samps = 1;\n        if (b1==uint(1))\n            samps = BSamp;          \n        vec3 col=vec3(0);\n        float Q=0.;\n        if (samps==1) {  // continue biased sampling\n            UnpackF16(col.x,col.y,prev.x); \n            UnpackF16(col.z,Q,prev.y);\n            Q*=1024.;\n        }\n        vec2 of; \n        vec3 ren=vec3(0), Cam; SetCam(Cx,Cy);\n        uint imp,str;\n        float ind;\n        int phase;\n        for (int i=0; i<samps; i++) {\n            if (samps>1)\n                phase = i;\n            else\n                phase = int(mod(float(cnt),16.));\n            if (phase<8) { \n                imp=floatBitsToUint(stat.x); \n                str=floatBitsToUint(stat.z); \n            }\n            else { \n                imp=floatBitsToUint(stat.y); \n                str=floatBitsToUint(stat.w);\n                phase-=8;\n            }\n            seed += iTime + dot(sin(Coo),vec2(443.712,983.234));\n            if (uint(Coo.x)<x && uint(Coo.y)<y) { // stratified\n                ind=float(((str>>(4*phase))&uint(0xF)))-1.;\n                of = (floor(vec2(ind/3.,mod(ind,3.))+EPS)+hash2())/3.-.5;\n            } else if (uint(Coo.x)>x && uint(Coo.y)<y) { // importace\n                ind=float(((imp>>(4*phase))&uint(0xF)))-1.;\n                of = (floor(vec2(ind/3.,mod(ind,3.))+EPS)+hash2())/3.-.5;\n            } else \n                of = hash2()-.5; // unbiased\n            ren += GetRender(iChannel1, iChannel2, Cam, \n                (Coo+of-.5*iResolution.xy)/iResolution.y, Coo, \n                (of+.5)*3.+EPS);\n        }\n        col = (col*Q+ren)/(Q+float(samps));\n        Col.x = PackF16(col.x,col.y);\n        Col.y = PackF16(col.z,(Q+float(samps))/1024.);\n        Col.zw *= 0.;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C\n// Pre-samples middle subpixel row.\n// ________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n   \n    if (Collect(1., iChannel0, iChannel1, iChannel2, iChannel3, \n                Col, Coo, iResolution, iTime) == uint(1)) {\n        Col = texelFetch(iChannel0, ivec2(Coo), 0);\n        return;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D\n// Pre-samples top subpixel row.\n// _____________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n   \n    if (Collect(2., iChannel0, iChannel1, iChannel2, iChannel3, \n                Col, Coo, iResolution, iTime) == uint(1)) {\n        Col = texelFetch(iChannel0, ivec2(Coo), 0);\n        return;\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}