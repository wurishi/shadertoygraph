{"ver":"0.1","info":{"id":"3sfcWX","date":"1585668992","viewed":107,"name":"Project 1","username":"Witiza","description":"testing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bymarcgarcaandlorinportella"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----- DEFINITIONS -----\n#define REF_ITERARATIONS 2\n#define REF_MIX 0.2\n\n\n//--------- GLOBALS ---------\nvec3 CamPos = vec3(0.0,0.0,1.0);\nvec3 Plane = vec3(0.0,-1.0,0.0);\nvec3 Sky = vec3(0.0,50.0,0.0);\nvec3 LookAt = vec3(0.0,0.0,-3.0); \nfloat ambientTerm=0.05;\n\nbool fog = true;\nvec3 fogColor = vec3(1.0);\nfloat fogFactor = -1.0;\nfloat fogStart = 0.1;\nfloat fogEnd = 200.0;\n\n\nmat3 rotationMatrix = mat3(1);\nfloat zoom = 1.0;\nfloat cameraSpeed = 10.0;\n\n//- ACTIVATE ANTIALIASING -\nbool antialiasing = true;\nbool quincuxAntialiasing = false;\n\n//--- TEXTURE SELECTOR ---\nbool otherTexture = false;\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n};\n\nstruct Material\n{\n    bool transparent;\n    vec3 color;\n    float kAmbient;\n    float kDiffuse;\n    float kSpecular;\n    float shininess;\n    float fresnel;\n    float kFresnel;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material material;\n};\n\n// ------------ SPHERES --------------\nSphere spheres[3]=Sphere[3](\n    Sphere(vec3(-3.0,1.0,-3.0),1.0,Material(false,vec3(1.0,0.5,0.0),1.0,1.0,1.0,32.0,10.0,0.1)),\n    Sphere(vec3(3.0,1.0,-3.0),1.0,Material(false,vec3(0.0,0.5,1.0),0.5,1.0,1.0,256.0,5.0,0.3)),\n    Sphere(vec3(0.0,1.0,-3.0),1.0,Material(true,vec3(1.0),0.0,1.0,1.0,32.0,0.2,0.5))\n);\n\nMaterial planeMaterial=Material(false,vec3(1.0),0.5,0.5,1.0,32.0,10.0,0.2);\n\n// ------------- LIGHT ------------------\nLight lightSource = Light(vec3(-10.0,10.0,0.0), vec3(1.0,1.0,1.0));\n\nfloat rand(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(in vec2 fragCoord)\n{\n    vec2 tile = vec2(fragCoord/100.0);\n    vec2 tileMax = floor(tile);\n    \n    vec2 tile_right = vec2(tileMax.x+1.0,tileMax.y);\n    vec2 tile_up = vec2(tileMax.x,tileMax.y+1.0);\n    vec2 tile_diag = vec2(tileMax.x+1.0,tileMax.y+1.0);\n\n    float tileColor_1 = rand(tileMax);\n    float tileColor_2 = rand(tile_right);\n    float tileColor_3 = rand(tile_up);\n    float tileColor_4 = rand(tile_diag);\n    \n    float mixFactor_x=smoothstep(0.0,1.0,fract(fragCoord/100.0).x);\n    \n    float mix_1=mix(tileColor_1,tileColor_2,mixFactor_x);\n\tfloat mix_2=mix(tileColor_3,tileColor_4,mixFactor_x);\n    \n    float mixFactor_y = smoothstep(0.0,1.0,fract(fragCoord/100.0).y);\n\n    float finalMix=mix(mix_1,mix_2,mixFactor_y);\n    \n    return finalMix;\n}\n\nvec3 BrownianNoise(in vec2 fragCoord)\n{\n   \tvec3 color = vec3(0.0);\n    float a =0.5;\n    float f=1.0;\n    \n   \tfor(int i=0; i<8;i++)\n   \t{\n    \tcolor.xy += a*noise(f*fragCoord);\n        color.y *=0.8;\n        a*=0.5;\n        f*=2.0;\n   \t}\n    \n\treturn 1.0-color;\n}\n\n//https://www.shadertoy.com/view/lsXGzf\nvoid Input()\n{\n\n    vec4 mouse = iMouse;\n    if(mouse.z > 0.0)\n    {\n        vec2 displacement = (mouse.xy-mouse.zw);\n        if(length(displacement) != 0.0)\n        {\n        displacement = displacement/cameraSpeed;\n        CamPos.x += displacement.x;\n        zoom += abs(displacement.x)/(cameraSpeed/2.0);\n        zoom += abs(displacement.y)/(cameraSpeed/2.0);\n        CamPos.z -= abs(displacement.x)/(cameraSpeed/4.0);\n        CamPos.z -= abs(displacement.y)/(cameraSpeed/4.0);\n        CamPos.y -= displacement.y;\n        }\n    }\n}\n\nvoid calculateRotationMatrix()\n{\n    vec3 ez = normalize(CamPos-LookAt);\n    vec3 ex = normalize(cross(vec3(0.0,-1.0,0.0),ez));\n    vec3 ey = cross(ex,ez);\n\n    rotationMatrix[0][0] = ex.x;\n    rotationMatrix[0][1] = ex.y;\n    rotationMatrix[0][2] = ex.z;\n    rotationMatrix[1][0] = ey.x;\n    rotationMatrix[1][1] = ey.y;\n    rotationMatrix[1][2] = ey.z;\n    rotationMatrix[2][0] = ez.x;\n    rotationMatrix[2][1] = ez.y;\n    rotationMatrix[2][2] = ez.z;  \n}\n            \nvec3 RayCasting(in vec2 fragCoord)\n{\n    vec2 normCoords=fragCoord/iResolution.xy;\n    float AR = iResolution.x/iResolution.y;\n    vec2 unitCoords= (normCoords-0.5)*2.0;\n    unitCoords.x*=AR;\n    vec3 finalCoord=vec3(unitCoords,0.0);\n    \n    return normalize(finalCoord-vec3(0.0,0.0,zoom));\n}\n\nfloat Intersection(in vec3 plane, in vec3 ray)\n{\n    float t = (plane.y-CamPos.y)/ray.y;\n    \n    return t;\n}\n\n\nvec3 IntersectionPoint(vec3 ray, vec3 point, vec3 plane)\n{\n    float t = (plane.y-point.y)/ray.y;\n    \n    return point+t*ray;\n}\n\nvoid getFogFactor(float dist)\n{\n    fogFactor = (fogEnd-dist)/(fogEnd-fogStart);\n}\n\n\nvec4 PlaneColor(vec3 ray, vec3 point, bool is_reflection)\n{\n    vec4 ret = vec4(0.0);\n    \n    if(Intersection(Plane,ray)>0.0)\n    {\n        vec3 point = IntersectionPoint(ray,point,Plane);\n        \n        if(!is_reflection)\n        \tgetFogFactor(length(point-CamPos));\n        \n        vec2 tileCoords = point.xz;\n        vec2 tile = floor(tileCoords);\n        \n        float sum = tile.x+tile.y;\n        \n        if(mod(sum,2.0)==0.0)\n        {\n            ret.xyz=vec3(0.0);\n        }\n        else\n        {\n            ret.xyz=vec3(1.0);\n        }        \n        \n        ret.w = 1.0;\n        \n    \t//Ambient Light\n    \tvec3 ambient = vec3(0.0);\n    \tvec3 ambientLight = planeMaterial.kAmbient*lightSource.color;\n    \tambient = ambientLight * ret.xyz;\n    \t\n    \t//Diffuse\n    \tvec3 diffuse = vec3(0.0);\n    \tvec3 lightDir =  normalize(lightSource.position-point);\n    \tvec3 normal = vec3(0.0,1.0,0.0);\n    \tfloat diff = max(dot(lightDir,normal),0.0);\n    \tvec3 diffLight=planeMaterial.kDiffuse*lightSource.color;\n    \tdiffuse=diffLight*diff*ret.xyz;\n    \t\n    \t//Spectacular\n    \tvec3 spectacular = vec3(0.0);\n    \tvec3 viewDir = normalize(CamPos - point);\n    \tvec3 halfway = normalize((viewDir + lightDir)/2.0);\n    \tfloat shininess = planeMaterial.shininess;\n    \tfloat spec = pow(max(dot(normal,halfway),0.0),shininess);\n    \tvec3 specularLight = planeMaterial.kSpecular*lightSource.color;\n    \tspectacular = spec*specularLight;\n    \t\n    \tret.xyz = ambient+diffuse+spectacular;\n    }\n    \n    return ret;\n}\n\nvec4 SkyColor(vec3 ray, vec3 point, bool is_reflection)\n{\n    vec4 ret = vec4(0.0);\n    \n    if(Intersection(Sky,ray)>0.0)\n    {\n        vec3 point = IntersectionPoint(ray,point,Sky);\n        if(!is_reflection)\n        \tgetFogFactor(length(point.xz-CamPos.xz));\n        \n        //Adding movement\n        ret.xyz=BrownianNoise(point.xz - iTime*25.0);\n        \n        ret.w = 1.0;\n    }\n    \n    return ret;\n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\nvec4 SphereIntersection(vec3 ray,vec3 point, Sphere sphere,bool front)\n{\n    vec4 iPoint = vec4(0.0);\n    vec3 d=ray; \t\t\t\t\t//ray direction\n    vec3 L=sphere.position-point;\t//vector center-point\n    float t=dot(L,d);\t\t\t\t//projection L over d\n    vec3 p=point+t*d;\t\t\t\t//projection point\n   \t\t\n    float y=length(sphere.position-p);\n    \n    if(t>0.0)\n    {\n    \tfloat x=sqrt(pow(length(L),2.0)-pow(t,2.0));\n        if(x<sphere.radius)\n        {\n            float tcp=sqrt(pow(sphere.radius,2.0)-pow(x,2.0));\n    \t\n    \t\tfloat t_0=t-tcp;\t\t    //Front intersection\n    \t\tfloat t_1=t+tcp;\t\t    //Rare intersection (no needed)\n            \n            if(front)\n            {\n                vec3 sp = point+t_0*d; \t//surface point\n                iPoint=vec4(sp,1.0);\n            }\n            else\n            {\n                vec3 sp = point+t_1*d; \t//surface point\n                iPoint=vec4(sp,1.0);\n            }\n        }\n    }\n    \n    return iPoint;\n}\n\n\n// Selection of the nearest intersected object\nint FrontSphere(vec3 ray, vec3 origin)\n{\n    int sphere=-1;\n    float dist=0.0;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        vec4 intPoint = SphereIntersection(ray, origin, spheres[i],true);\n        if(intPoint.w == 1.0 && (sphere==-1 || length(intPoint.xyz-origin)<dist))\n        {\n            sphere=i;\n            dist = length(intPoint.xyz-origin);\n        }\n    }\n    \n    return sphere;\n}\n\nvec3 Lighting(vec3 sPoint, int idx)\n{\n    vec3 finalColor = vec3(0.0);\n    \n    //Ambient Light\n    vec3 ambient = vec3(0.0);\n    vec3 ambientLight = spheres[idx].material.kAmbient*lightSource.color;\n    ambient = ambientLight * spheres[idx].material.color;\n    \n    //Diffuse\n    vec3 diffuse = vec3(0.0);\n    vec3 lightDir =  normalize(lightSource.position-sPoint);\n    vec3 normal = normalize(sPoint-spheres[idx].position);\n    float diff = max(dot(lightDir,normal),0.0);\n    vec3 diffLight=spheres[idx].material.kDiffuse*lightSource.color;\n    diffuse=diffLight*diff*spheres[idx].material.color;\n    \n    //Spectacular\n    vec3 spectacular = vec3(0.0);\n    vec3 viewDir = normalize(CamPos - sPoint);\n    vec3 halfway = normalize((viewDir + lightDir)/2.0);\n    float shininess = spheres[idx].material.shininess;\n    float spec = pow(max(dot(normal,halfway),0.0),shininess);\n    vec3 specularLight = spheres[idx].material.kSpecular*lightSource.color;\n    spectacular = spec*specularLight;\n    \n    finalColor = (ambient+diffuse+spectacular);\n    return finalColor;\n}   \n\nvec3 CalculateUV(vec3 normal)\n{\n    float pi = 3.14159265;\n    float u = 0.5+((atan(normal.x,normal.z))/(2.0*pi));\n    float v = 0.5-(asin(normal.y)/pi);\n\t\n    if(otherTexture)\n        return vec3(texture(iChannel1,vec2(v,u)));\n    else\n        return vec3(texture(iChannel0,vec2(v,u)));\n\n}\n\nvec4 ReflectionRefractionColor(vec3 ray, vec3 point, vec3 normal, int idx, bool transparent)\n{\n    vec3 ref = vec3(0.0);\n    vec4 interPoint = vec4(0.0);\n    vec3 usedNormal=normal;\n    vec3 usedRay=ray;\n    vec3 usedPoint = point;\n    int usedIndex = idx;\n    bool usedTransparency=transparent;\n    vec4 totalColor=vec4(0.0);\n   \n    for(int i = 0; i<REF_ITERARATIONS;++i)\n    {\n    \t//Ray Calculation\n    \tif(!usedTransparency)\n    \t{\n    \t    ref = reflect(usedRay, usedNormal);\n    \t}\n    \telse\n    \t{\n    \t    //window glass\n    \t    float ref_index = 1.0;\n    \t    ref = refract(usedRay,usedNormal,ref_index);\n    \t    vec3 newhit = SphereIntersection(ref, usedPoint, spheres[usedIndex],false).xyz;\n    \t    vec3 newNormal = newhit-spheres[usedIndex].position;\n    \t    ref = refract(ref,newNormal,ref_index);\n    \t}\n    \t\n    \t// Plane reflection/refraction\n    \tif(PlaneColor(ref,usedPoint,true).w==1.0)\n    \t{\n    \t    interPoint=PlaneColor(ref, usedPoint,true);\n    \t    \n    \t    if(idx != -1)\n    \t    {\n    \t        vec3 test = IntersectionPoint(ref, usedPoint, Plane);\n    \t        \n    \t        for(int i=0;i<3;++i)\n    \t\t\t{\n    \t\t\t    if(SphereIntersection(normalize(lightSource.position - test),test,spheres[i],true).w==1.0)\n   \t\t\t\t\t{\n   \t\t\t\t    \tinterPoint.xyz-=vec3(0.5);\n   \t\t\t\t\t}\n    \t\t\t}\n    \t    }\n    \t}\n    \t\n    \t//Sky Reflection//refraction\n    \tif(SkyColor(ref,usedPoint,true).w==1.0)\n    \t{\n    \t    interPoint=SkyColor(ref, usedPoint,true);\n    \t}\n    \t\n    \tint frontSphere = FrontSphere(ref,usedPoint);\n    \t\n    \tif(frontSphere>-1)\n    \t{\n   \t\t\tvec4 sphereInter = SphereIntersection(ref,usedPoint,spheres[frontSphere],true);\n            \n            if(frontSphere == 0)\n       \t \t{\n            \tspheres[frontSphere].material.color=CalculateUV(normal);\n        \t}\n            \n   \t\t\tif(sphereInter.w == 1.0 && usedIndex!=frontSphere)\n   \t\t\t{\n                if(frontSphere == 0)\n       \t \t\t{\n            \t\tspheres[frontSphere].material.color=CalculateUV(normal);\n        \t\t}\n                \n   \t\t\t    interPoint.xyz = Lighting(sphereInter.xyz,frontSphere);\n    \t   \n                usedIndex=frontSphere;\n                usedNormal=normalize(vec3(sphereInter.xyz-spheres[frontSphere].position));\n                usedPoint=sphereInter.xyz;\n                usedRay=ref;\n                usedTransparency=spheres[frontSphere].material.transparent;\n   \t\t\t    interPoint.w=1.0;\n   \t\t\t}\n    \t}\n       \t\n        if(i==0 && interPoint.w==1.0)\n        {\n            totalColor = interPoint;\n        }\n        else\n        {\n            totalColor.xyz=mix(totalColor.xyz,interPoint.xyz,REF_MIX);\n        }\n    }\n    \n    return totalColor;      \n}   \n\nvec3 Render(in vec2 fragCoord)\n{\n   \n    \n    vec3 ray = RayCasting(fragCoord);\n    ray = rotationMatrix*ray;\n    \n    vec4 reflection = vec4(0.0);\n    vec3 ret=vec3(1.0-ray.y,1.0-ray.y,1.0-ray.y);\n    vec4 planeColor = PlaneColor(ray,CamPos,false);\n    vec4 skyColor = SkyColor(ray,CamPos,false);\n    vec3 skyPoint = IntersectionPoint(ray, CamPos,Sky);\n    vec3 hitPoint = IntersectionPoint(ray, CamPos,Plane);\n    \n    //getFogFactor(length(hitPoint-CamPos));\n    \n     // Rendering Plane\n    if(planeColor.w==1.0)\n   \t{\n   \t    ret=planeColor.xyz;\n        reflection = ReflectionRefractionColor(ray, hitPoint,vec3(0.0,1.0,0.0),-1,planeMaterial.transparent);\n         // Rendering Hard Shadows\n    \tfor(int i=0;i<3;++i)\n    \t{\n    \t    if(SphereIntersection(normalize(lightSource.position - hitPoint),hitPoint,spheres[i],true).w==1.0)\n   \t\t\t{\n   \t\t    \tret-=vec3(0.6);\n   \t\t\t}\n    \t}\n        \n        if(reflection.w == 1.0)\n        {\n            //Fresnel Calculation\n            float R = pow(1.0 + dot(ray, vec3(0.0,1.0,0.0)), planeMaterial.fresnel);\n    \t    R=min(planeMaterial.kFresnel+R,1.0);\n            ret = mix(ret,reflection.xyz,R);\n        }\n    }\n    \n     // Rendering Sky\n    if(skyColor.w==1.0)\n   \t{\n   \t    ret=skyColor.xyz;\n    }\n        \n    int frontSphere = FrontSphere(ray,CamPos); \n    \n\tif(frontSphere>-1)\n    {\n   \t\t// Rendering Spheres\n   \t\tvec4 sPoint=SphereIntersection(ray,CamPos, spheres[frontSphere],true);\n        \n        vec3 normal = normalize(sPoint.xyz-spheres[frontSphere].position);\n        \n        if(frontSphere == 0)\n       \t{\n           spheres[frontSphere].material.color=CalculateUV(normal);\n       \t}\n        \n\t\t   \t\t\n   \t\tif(planeColor.w==1.0)\n   \t\t{   \t    \n   \t\t    if(sPoint.w==1.0 && length(CamPos-sPoint.xyz)<length(CamPos-hitPoint))\n   \t\t\t{\n                getFogFactor(length(sPoint.xyz-CamPos));\n   \t\t    \tret=Lighting(sPoint.xyz,frontSphere);\n    \t        reflection = ReflectionRefractionColor(ray, sPoint.xyz, normal,frontSphere,spheres[frontSphere].material.transparent);\n   \t\t\t\t\n    \t        if(reflection.w == 1.0)\n    \t        {\n                    //Fresnel Calculation\n                    float R = pow(1.0 + dot(ray, normal), spheres[frontSphere].material.fresnel);\n                    R=min(spheres[frontSphere].material.kFresnel+R,1.0);\n    \t        \tret = mix(ret,reflection.xyz,R);\n                    \n    \t        }\n   \t\t\t}\n   \t\t}\n   \t\telse\n   \t\t{\n   \t\t    if(sPoint.w==1.0)\n   \t\t\t{\n                getFogFactor(length(sPoint.xyz-CamPos));\n   \t\t    \tret=Lighting(sPoint.xyz,frontSphere);\n\t\n    \t        reflection = ReflectionRefractionColor(ray, sPoint.xyz, normal,frontSphere,spheres[frontSphere].material.transparent);\n    \t        \n    \t        if(reflection.w == 1.0)\n    \t        {\n                    //Fresnel Calculation\n                    float R = pow(1.0 + dot(ray, normal), spheres[frontSphere].material.fresnel);\n    \t        \tR=min(spheres[frontSphere].material.kFresnel+R,1.0);\n    \t        \tret = mix(ret,reflection.xyz,R);\n    \t        }\n    \t     }\n   \t\t}\n    }\n    \n\tif(fogFactor != -1.0 && fog)\n    \t\tret = (1.0-fogFactor)*fogColor+fogFactor*ret;\n    \n    //return ret;\n    return vec3(ret);\n}\n\n/*http://blog.demofox.org/2015/04/22/quincunx-antialiasing/\n\nQuincunx anti aliasing works by using 5 samples per pixel in the following configuration:\n\n  B        C\n  *--------*\n  |   A    |\n  |   *    |\n  |        |\n  *--------*\n  D        E\n\n\tAll the samples combined have a weigth of 1, but the center one (A), has more weigth than the rest (0.5);\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0].position.y+=sin(iTime);\n    spheres[1].position.y+=sin(iTime+1.0);\n    spheres[2].position.y+=sin(iTime+2.0);\n    \n    Input();\n    calculateRotationMatrix();\n    \n    vec3 finalCol = vec3(0);\n\t\n\tif(antialiasing)\n    {\n    \tif(!quincuxAntialiasing)\n        {\n        \tfinalCol = Render(fragCoord)/4.0;\n        \tfinalCol += Render(fragCoord+vec2(0.5,0.0))/4.0;\n        \tfinalCol += Render(fragCoord+vec2(0.5,0.5))/4.0;\n        \tfinalCol += Render(fragCoord+vec2(0.0,0.5))/4.0;        \n        }\n        \n        if(quincuxAntialiasing)\n        {\n            finalCol = Render(fragCoord)/2.0;\n            finalCol += Render(fragCoord+vec2(-0.5,-0.5))/8.0;\n            finalCol += Render(fragCoord+vec2(-0.5,0.5))/8.0;\n            finalCol += Render(fragCoord+vec2(0.5,-0.5))/8.0;\n            finalCol += Render(fragCoord+vec2(0.5,0.5))/8.0;\n        }\n    \n        fragColor = vec4(finalCol,1.0);\n    }\n    else\n    {\n   \t\tvec3 col = Render(fragCoord);\n    \n\n    \t// Output to screen\n    \tfragColor = vec4(col,1.0);\n    }\n\n}","name":"Image","description":"","type":"image"}]}