{"ver":"0.1","info":{"id":"MttfRH","date":"1538687197","viewed":235,"name":"Stage Play","username":"spookyfox","description":"stage","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["stage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SKY = -1.;\nfloat FLOOR = 0.;\n\nfloat sdPlane(vec3 p, float s, float h) {\n    return s * p.y + h;\n}\n\nfloat sdCylinder(vec3 p) {\n    return length(p.xz - vec2(0, .2)) - .1;\n}\n\nfloat sMin(float a, float b, float k) {\n    // https://iquilezles.org/articles/smin\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 opU(vec2 dm1, vec2 dm2) {\n    // https://www.shadertoy.com/view/Xds3zN\n    return dm1.x < dm2.x ? dm1 : dm2;\n}\n\nvec2 map(vec3 p) {\n    p.x = mod(p.x, 2.0) - 0.5 * 2.0;\n    p.z = mod(p.z, 2.0) - 0.5 * 2.0;\n    vec2 dm;\n    dm = opU(vec2(sdPlane(p, 1., 1.), FLOOR), vec2(sdPlane(p, -1., 1.), FLOOR));\n    dm = vec2(sMin(dm.x, sdCylinder(p), 1.), FLOOR);\n   \treturn dm;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    // Shortest distance and material key.\n    vec2 dm;\n    // Current step size.\n    float s = 0.;\n    for (int i = 0; i < 256; i++) {\n        // Current position in the scene.\n        vec3 p = ro + rd * s;\n        dm = map(p);\n        s += dm.x;\n    }\n    if (dm.x > 0.1) {\n        // Our ray hasn't hit anything.\n        dm.y = SKY;\n    }\n    return vec2(s, dm.y);\n}\n\nvec3 normal(vec3 p) {\n    // Tetrahedron technique\n    // https://iquilezles.org/articles/normalsSDF\n    float h = 0.0001;\n\tvec2 k = vec2(1, -1);\n    return normalize(\n        k.xxx * map(p + k.xxx * h).x +\n        k.xyy * map(p + k.xyy * h).x +\n        k.yxy * map(p + k.yxy * h).x +\n        k.yyx * map(p + k.yyx * h).x);\n}\n\n// General lighting resource: http://www.sunandblackcat.com/tipFullView.php?l=eng&topicid=30\nvec3 light(vec3 ro, vec3 p, vec3 l) {\n\tvec3 n = normal(p);\n    \n    // Material properties (chrome).\n    // https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/3DLighting/MaterialProperties.html\n    vec3 ka = vec3(.25);\n    vec3 kd = vec3(.4);\n    vec3 ks = vec3(.774597);\n    float es = 76.8; // Larger -> smaller highlight.\n    \n    // Ambient.\n    // https://en.wikipedia.org/wiki/Shading#Ambient_lighting\n    float a = 0.5;\n    \n    // Diffuse.\n    // https://en.wikipedia.org/wiki/Lambertian_reflectance\n    float d = clamp(dot(n, normalize(l - p)), 0., 1.);\n    \n    // Specular.\n    // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    vec3 v = normalize(ro - l);\n    vec3 h = normalize(v + l);\n    float s;\n    if (dot(n, l) > 0.) {\n        // Surface is oriented to the light source.\n        s = pow(clamp(dot(n, h), 0., 1.), es);\n    } else {\n        s = 0.;\n    }\n\n    return a * ka + d * kd + s * ks;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 c;\n    // Render by coloring intersections.\n    vec2 dm = rayMarch(ro, rd);\n    if (dm.y == FLOOR) {\n        // The intersection.\n        vec3 p = ro + rd * dm.x;\n        // The point light.\n        vec3 l = vec3(2, 2, -2);\n        c = light(ro, p, l);   \n    } else {\n        c = vec3(0);\n    }\n    // Gamma correction.\n    return pow(c, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Remap xy to [-1, 1] and correct aspect ratio.\n    vec2 xy = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // z: Start behind the screen.\n\tvec3 ro = vec3(0, 0, iTime);\n    // z: Go through the screen.\n    vec3 rd = normalize(vec3(xy, 1));\n\n    fragColor = vec4(render(ro, rd), 1);\n}","name":"Image","description":"","type":"image"}]}