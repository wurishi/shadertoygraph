{"ver":"0.1","info":{"id":"ddj3zK","date":"1667903698","viewed":115,"name":"Pokeball - E.Moret","username":"eliottmoret","description":"Pokeball raymarching fun","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","pokeball","material","rotation"],"hasliked":0,"parentid":"wsKfzK","parentname":"First Raymarcher - Eliott Moret"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 nuv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    float circle = length((nuv + vec2(0.,0.4)) * vec2(4.,15.));\n    circle = smoothstep(1.2, 0.5 , circle) * .25;\n    \n    col.rgb *= 1.-(circle * col.a);\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define BOTCOL vec3(.32,.917,.59)\n#define TOPCOL vec3(.16,.56,.92)\n\n//1 : No Anti-aliasing\n#define AA 2\n\nvec2 rot(vec2 pos, float a)\n{\n    mat2 ROT = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return vec2(ROT*pos);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x,0.0,1.0);\n}\n\nvec3 ACESFilm(vec3 x)\n{\nfloat a = 2.51f;\nfloat b = 0.03f;\nfloat c = 2.43f;\nfloat d = 0.59f;\nfloat e = 0.14f;\nreturn saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\n\n//SDFs\nvec2 sdSphere(vec3 p, vec3 pos, float radius, float id){\n    return vec2(length(p-pos)-radius, id);\n}\n\nvec2 sdBox( vec3 p, vec3 b , float id)\n{\n  vec3 q = abs(p) - b;\n  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), id);\n}\n\nvec2 sdCylinder( vec3 p, vec3 c , float id)\n{\n  return vec2(length(p.xz-c.xy)-c.z, id);\n}\n\n//Merges\nvec2 Union(vec2 d1, vec2 d2){\n    return vec2((d1.x<d2.x) ?  d1 : d2);\n}\n\nvec2 Map(vec3 p){\n    vec2 d;\n            p -= vec3(0.,1.,6.);\n        \n        p.xz = rot(p.xz, iTime*2.);\n        p.xy = rot(p.xy, .45);\n        \n        p += vec3(0.,1.,6.);\n        \n    vec2 sphere01 = sdSphere(p, vec3(0.,1.,6.), 1., 0.);\n    vec2 sphere02 = sdSphere(p, vec3(0.,1.,5.1), 0.15, 0.);\n    \n    d = sphere01; \n    d = Union(d, sphere02);\n      \n    \n    return vec2(d);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd){    \n    float dO=0.;\n    float id;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n\n    \tvec3 p = ro + dO*rd;\n        float dS = Map(p).x;\n        id = Map(p).y;\n        dO += dS;\n        \n        if(dO>MAX_DIST) id = -1.;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, id);\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = Map(p).x;\n    vec2 eps = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n    Map(p-eps.xyy).x,\n    Map(p-eps.yxy).x,\n    Map(p-eps.yyx).x);\n    \n    return normalize(n);\n}\n\nvoid GetMats(in float id, in vec3 p, out vec3 col, out float spec, out float specPow, out float refl){\n    if(id==0.){\n        p -= vec3(0.,1.,6.);\n        \n        p.xz = rot(p.xz, iTime*2.);\n        p.xy = rot(p.xy, .45);\n        \n        p += vec3(0.,1.,6.);\n        \n        col = mix( vec3(.9), vec3(0.9,0.1,0.1), step(0.0,p.y-1.));\n        col = mix( vec3(0.1), col, step(0.1, abs(p.y-1.0)));\n        col = mix( vec3(0.1), col, step(0.25,length(p-(vec3(0.,1.,5.)))));\n        col = mix( vec3(0.9), col, step(0.125,length(p-(vec3(0.,1.,5.)))));\n        spec = 8.0;\n        specPow = 32.;\n        refl = 1.0;\n    }\n    else if (id==1.){\n        col = vec3(0.9,0.9,0.9);\n        spec = .2;\n        specPow = 4.;\n        refl = 1.;\n    }\n    else if (id==2.){\n        col = vec3(0.5,0.5,0.5);\n        spec = 0.5;\n        specPow = 16.;\n        refl = 0.;\n    }\n    else if (id==3.){\n        col = vec3(0.9,0.35,0.0);\n        spec = 0.2;\n        specPow = 16.;\n        refl = 0.;\n    }\n}\n\nvec3 GetLight(vec3 p, vec3 viewDir, vec3 n, float dist, float id){\n\n    vec3 col = vec3(0.,0.,0.);\n    float spec = 0.;\n    float specPow = 1.;\n    float refl = 0.;\n    \n    GetMats(id, p, col, spec, specPow, refl);    \n    \n    vec3 l = normalize(vec3(-1.0,1.,0.25));\n    //NdotL\n    float dif = max(0.,(dot(n, l)*.5+.5));\n    \n    vec3 reflectionVec = reflect(viewDir, n);\n    vec3 cube = texture(iChannel0, reflectionVec).rgb;\n    \n    //Fresnel\n    float f = 1.-pow(dot(n, -viewDir),0.2);\n        \n    //Specular\n    spec = pow(clamp(dot(reflect(l,n), viewDir),0.,1.), specPow)*spec;\n          \n    //Ambient\n    vec3 ambCol =\n    (BOTCOL * pow(max(0.,dot(n, vec3(0.,-1.,0.))), 2.))+    \n    (TOPCOL * pow(max(0.,dot(n, vec3(0.,1.,0.))), 2.))\n    * 0.5;\n\n    //Final surface\n    vec3 surf = (col+spec*col)*dif + cube * 0.01 + ambCol;    \n    surf += cube*f;\n    \n    return surf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec4 tot = vec4(0.0);\n\n#if AA>1\n    for( int M=0; M<AA; M++ )\n    for( int N=0; N<AA; N++ )\n    {\n    vec2 o = vec2(float(M),float(N)) / float(AA) - 0.5;\n    vec2 uv = ((fragCoord-0.5*iResolution.xy)+o*2.)/iResolution.y;\n#else\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n#endif\n\n    vec4 col = vec4(0);\n    \n    vec3 ro = vec3(0,1,2);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 DistId = RayMarch(ro, rd);\n    vec3 p = ro + rd * DistId.x;\n    \n    vec3 n = GetNormal(p);\n    vec3 dif = GetLight(p, rd, n, DistId.x, DistId.y);\n    \n\tcol.rgb = vec3(dif);\n    \n    vec3 bgCol = mix(BOTCOL, TOPCOL, uv.y+.5);\n    \n    col.rgb  = ACESFilm(col.rgb);\n    col.a = step(100., DistId.x);\n    col.rgb = mix(col.rgb, bgCol, col.a);\n    \n    tot += col;\n\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4(tot);\n}","name":"Buffer A","description":"","type":"buffer"}]}