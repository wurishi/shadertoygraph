{"ver":"0.1","info":{"id":"WscSzf","date":"1572912971","viewed":73,"name":"American pyramid","username":"plosique","description":"Calculates the intersection of planes using their respective SDF's ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS=255; \nconst float MAX_DIST=100.0; \nconst float MIN_DIST=0.0; \nconst float EPS=0.001; \nconst float a=0.2; \nconst vec3 ls=vec3(3.0,3.0,-1.0); \n//const vec3 ia=vec3(.85,.64,.32);\n//const vec3 id=vec3(.82,.70,.55); \n//const vec3 is=vec3(.82,.71,0.55); \nconst vec3 Red=vec3(1.,0.,0.); \nconst vec3 Blue=vec3(0.,0.,1.); \nconst vec3 Egypt=vec3(.82,.55,.71);\nconst float kd=0.1; \nconst float ks=0.; \nconst float ka=0.9; \nconst float pi=acos(-1.); \nvec3 n[6]; \nvec3 plpt[6];\n\nfloat rand(vec2 uv){\n    uv=fract(uv*vec2(233.34,851.73));\n    uv+=dot(uv,uv+23.45);\n    return fract(uv.x*uv.y);\n}\nfloat value(vec2 uv){\n    uv*=4.;\n    vec2 uvf=fract(uv);\n    uvf=uvf*uvf*(3.-2.*uvf);\n    vec2 bl=floor(uv);\n    float vbl=rand(bl);\n    float vbr=rand(bl+vec2(1.,0.));\n    float vtl=rand(bl+vec2(0.,1.));\n    float vtr=rand(bl+vec2(1.,1.));\n    float x0=mix(vbl,vbr,uvf.x);\n    float x1=mix(vtl,vtr,uvf.x);\n  return mix(x0,x1,uvf.y);\n} \n\n  \n    \n    \nfloat fractal(vec2 uv){\n    float sum=0.;\n    for(float i=0.;i<4.;++i){\n        sum+=value(uv*pow(2.,i))/pow(2.,i);\n    }\n    return fract(sum/2.);\n}\n\n\nvec2 rotate2D(vec2 plane,float theta){\n    return vec2(plane.x*cos(theta)-plane.y*sin(theta),plane.x*sin(theta)+plane.y*cos(theta)); \n}\n    \n\nfloat planeSDF(vec3 n,vec3 plpt,vec3 pt){ \n    pt.x-=plpt.x;\n    pt.y-=plpt.y;\n    pt.z-=plpt.z;\n\n    return dot(n,pt); \n} \n\n\nfloat sceneSDF(in vec3 pt,out int id){   \n    float ma=planeSDF(n[0],plpt[0],pt);\n    id=0;\n    float val;\n    for(int i=1;i<6;i++){\n        val=planeSDF(n[i],plpt[i],pt);\n        if(ma<val){ \n            id=i;\n            ma=val;\n        } \n    } \n    return ma; \n}\n\nvec2 iter(vec2 uv){ \n    float dx=uv.x/uv.y;\n    float dy=uv.y/uv.x;\n    for(int i=0;i<30;i++){ \n        uv.x*=dx;\n        uv.y*=dy;\n    } \n    return uv;\n}\n\n\n\nvec4 ray_march(in vec3 eye, in vec3 dir){\n    vec4 bkg=vec4(0.0,0.0,0.0,1.0); \n    vec3 pt; \n\tpt=eye;\n    float step_size=0.0;\n    int j; \n    for(int i=0;i<MAX_STEPS;i++){\n        step_size=sceneSDF(pt,j); \n        \n        pt=pt+step_size*dir;\n        \n        if (step_size>MAX_DIST){  \n            return bkg ;\n        } \n        if (step_size<EPS){\n            vec3 N=n[j]; \n            vec3 L=(ls-pt); \n            vec3 V=(eye-pt); \n            vec3 R=reflect(-L,N);\n            vec2 uv; \n            if(j==0 || j==3){ \n              uv=vec2(pt.y,pt.z);\n            }else{\n               uv=vec2(pt.y,pt.x); \n            }\n                \n                \n            \n            //float mul=value(vec2(sin(iTime),cos(iTime)));\n            //uv*=mul;\n            uv=uv+fractal(uv+fractal(uv+fractal(uv+fractal(uv)))); \n            \n            //vec2 uv2=uv+10.;\n            //uv2=uv+fractal(uv2+fractal(uv2+fractal(uv2)));\n            //vec2 uv3=uv+50.;\n            //uv3=uv3+fractal(uv3+fractal(uv3+fractal(uv3)));\n            \n            //uv=mix(uv,uvn,.5+.5*sin(iTime*.5)); \n            //uv1=iter(uv1);\n            //uv2=iter(uv2);\n            //uv3=iter(uv3); \n            //vec3 ia=uv1.x*Red+uv1.y*Blue;\n            //vec3 id=Red*uv2.x+Blue*uv2.y;\n            //vec3 is=Red*uv3.x+Blue*uv3.y; \n            //vec3 ia=Red*fractal(vec2(uv+1000.))+Blue*fractal(vec2(uv+2000.));\n            //vec3 id=Red*fractal(vec2(uv+1500.))+Blue*fractal(vec2(uv+3000.));\n            //vec3 is=Red*fractal(vec2(uv+1200.))+Blue*fractal(vec2(uv+3200.));\n            //vec3 ret=ka*ia+kd*(dot(L,N))*id+ks*pow(dot(R,V),a)*is;\n            //vec3 ret=vec3(0.82,0.71,0.55);  \n            float diff=.1;\n            vec3 ret=vec3(0.82+diff*fractal(uv),.71+diff*fractal(uv+1000.),.55+diff*fractal(uv+2000.)); \n            vec4 ret2=vec4(ret,1.0);\n            return ret2;\n                \n            \n        } \n       \n    }return bkg ;\n}\n\nvec3 ray_dir(vec3 eye,vec3 pix_loc){ \n    return normalize(pix_loc-eye); \n}\n\n\n    \n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv=fragCoord-0.5*iResolution.xy; \n    uv=uv.xy/(0.5*iResolution.y);\n    float diff=iResolution.x/iResolution.y;\n    vec2 posx=rotate2D(vec2(1.,0.),pi/6.); \n    vec2 negx=rotate2D(vec2(-1.,0.),-pi/6.);\n    vec2 posz=rotate2D(vec2(0.,1.),-pi/6.);   \n    vec2 negz=rotate2D(vec2(0,-1.),pi/6.); \n    n[0]=vec3(posx,0.);\n    //n[0]=vec3(1.,0.,0.);\n    n[1]=vec3(0.,1.,0.); \n    //n[2]=vec3(0.,posz.x,posz.y*2.*diff);\n    //n[2]=normalize(n[2]);\n    n[2]=vec3(0.,posz); \n    n[3]=vec3(negx,0.);\n    //n[3]=vec3(-1.,0.,0.); \n    n[4]=vec3(0.,-1.,0.);\n    n[5]=vec3(0.,negz);\n    //n[5]=normalize(n[5]); \n    //n[5]=vec3(0.,0.,-1.);\n    plpt[0]=vec3(1.0,-1.0,0.);\n    plpt[1]=vec3(0.,mod(iTime,20.)/20.,0.);\n    plpt[2]=vec3(0.,1.0,1.0);\n    plpt[3]=vec3(-1.,1.0,0.);\n    plpt[4]=vec3(0.,-1.,0.);\n    plpt[5]=vec3(0.,-1.0,-1.);\n    \n    float theta=iTime;\n    //for(int i=0;i<6;i++){ \n      //  vec2 rotn=rotate2D(vec2(n[i].x,n[i].z),theta);\n        //vec2 rotp=rotate2D(vec2(plpt[i].x,plpt[i].z),theta); \n         //n[i].x=rotn.x;\n         //n[i].z=rotn.y; \n         //plpt[i].x=rotp.x;\n         //plpt[i].z=rotp.y;\n    //} \n    vec2 init=vec2(0.,-10.);\n    vec2 act_eye=rotate2D(init,theta);\n    vec2 loc=rotate2D(vec2(uv.x,-5.),theta); \n    vec3 eye=vec3(act_eye.x,-.5,act_eye.y); \n    vec3 pix_loc=vec3(loc.x,uv.y,loc.y); \n    vec3 dir=ray_dir(eye,pix_loc);  \n    vec4 pix_val=ray_march(eye,dir);\n        \n\n    // Output to screen\n    fragColor = pix_val;\n}","name":"Image","description":"","type":"image"}]}