{"ver":"0.1","info":{"id":"cllcWl","date":"1691360928","viewed":110,"name":"Alpha Deblending Diffusion Model","username":"chronos","description":"Implementation of alpha (De-)blending.\nBased on the paper Iterative :alpha: (De)Blending: https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\nand and earlier shadertoy implementation by Fabrice Neyret.\n","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["blending","diffusion","model","alpha","deblending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on the paper Iterative :alpha: (De)Blending: https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n// and\n// https://www.shadertoy.com/view/mlXyRf by Fabrice Neyret\n\n// Buffer A computes the Transport Map by iterative alpha (de-)blending.\n// Buffer B draws the trails / trace\n// Buffer C draws the particles. Only a few while the mapping is computed, but then shows the rest.\n// The Common tab has additional parameters and helper functions.\n\n// If you have a faster GPU you can increase the 'num_substeps' parameter in the Buffer A tab, or reduce if you are on a slower GPU\n// Alternatively to can reduce or increase the 'total_steps'.\n// Lower number of total iteration steps takes less time but is more noisy\n// Higher number of total iteration steps takes longer time but is less noisy\n\nvec4 draw_target_shape(vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = pixel_to_uv(fragCoord, iResolution.xy);\n    float sdf = circle_sdf(uv, circle_center, radius);\n    float alpha = abs(sdf);\n    return mix(fragColor, vec4(1), smoothstep( 2./iResolution.y, 0., alpha ) );\n}\n\nvec4 draw_source_shape(vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = pixel_to_uv(fragCoord, iResolution.xy);\n   float sdf = square_sdf(uv, box_center, radius);\n   float alpha = abs(sdf);\n   return mix(fragColor, vec4(1), smoothstep( 2./iResolution.y, 0., abs(alpha) ) );\n}\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_trace(vec2 U) { return  texelFetch( iChannel1, ivec2(U), 0 ); }\nvec4 get_particles(vec2 U) { return  texelFetch( iChannel2, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = get_trace(fragCoord);\n\n    // --- draw source & target shapes -------- \n    fragColor = draw_source_shape(fragColor, fragCoord);\n    fragColor = draw_target_shape(fragColor, fragCoord);\n\n    // --- plot particles ----------------------------\n    vec4 particles = get_particles(fragCoord);\n    \n    fragColor = vec4(mix(fragColor.rgb, particles.rgb, particles.a), 1.);\n   \n    fragColor = gamma_correct(fragColor.rgb);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\n// Solver parameters ( mostly used in buffer A)\n\n// For rejection sampling.\n// Increase this if you see stragglers at the end of the simulation, i.e. points outside the target area.\nconst float max_sampling_iterations = 1000.;\n\nconst int num_substeps = 10;      // alpha (de-)blend steps per frame\nconst float total_steps = 10000.; // total number of steps t between 0 and 1\nconst float dt = 1./total_steps;  // step increment\n\n// Shape parameters\nvec2 circle_center = vec2(.75, .45 );\n   \nconst float radius = .50;              // disc( (c,c), r ) to square [0,2r]Â²\nvec2 box_center = vec2(-.75, -.45 );\n\n// Misc parameters\n\nconst int num_particles = 10;\n\n// Gamma / sRGB\n\nconst float GAMMA = 2.2;\n\nvec4 gamma_correct( vec3 color )\n{\n    return vec4(pow(clamp(color, 0., 1.), vec3(1./GAMMA)), 1.);\n}\n\n// Noise functions\n\nuint hash(uint x, uint y)\n{\n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    return x;\n}\n\nfloat hash(vec2 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u;\n    uint y = floatBitsToUint(uv.y);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    uint z = ((x>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    return 2. * uintBitsToFloat(z) - 1.;\n}\n\nvec2 hash2(vec2 uv)\n{\n    float x = hash(uv);\n    float y = hash(uv + vec2(x, 0.));\n    return vec2(x,y);\n}\n\n// SDF functions\n\nfloat circle_sdf(vec2 p, vec2 circle_center, float circle_radius) { return length(p - circle_center) - circle_radius; }\n\nfloat square_sdf(vec2 p, vec2 square_center, float box_radius)\n{ \n    vec2 f = abs(p-square_center) - box_radius;\n    return (f.x >= 0. && f.y >= 0.) ? length(f) : max(f.x, f.y);\n}\n\n// Pixel and UV helper functions\nvec2 pixel_to_uv(vec2 fragCoord, vec2 iResolution) { return (2. * fragCoord.xy - iResolution.xy) / iResolution.y; }\nvec2 uv_to_pixel(vec2 uv, vec2 iResolution) { return 0.5 * (uv.xy * iResolution.y + iResolution.xy); }\nvec2 uncentered_to_centered_uv(vec2 uncentered_uv, vec2 iResolution) { return 2.*(uncentered_uv-.5) * vec2(iResolution.x / iResolution.y, 1.); }\nvec2 centered_to_uncentered_uv(vec2 centered_uv, vec2 iResolution) { return .5*(centered_uv / vec2(iResolution.x / iResolution.y, 1.)+1.); }\n\n// Distribution functions\n\n// float source_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n// float target_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n\nvec2 sample_source_distribution(vec2 hash)\n{\n    // Shrink a little, this reduces spurious points, at least for me...\n    // The only reason I can think of for this problem is because points have to be inside\n    // the convex hull / completion of the union of the source and target shapes,\n    // otherwise there does not exist a valid convex combination\n    // of points from the two shapes that gives the current point as the result.\n    // On the boundary of the convex hull, the chance of finding a valid convex combination\n    // by rejection sampling is very low...\n    hash = (.98*hash+0.01);\n    \n    return (2.*radius * hash) + (box_center-radius);\n}\n\nvec2 sample_target_distribution(vec2 hash)\n{\n    float angle = 2.* PI * hash.y;\n    return circle_center + radius * sqrt(hash.x) * vec2(cos(angle), sin(angle));\n}\n\nbool is_inside_source_distribution(vec2 position)\n{\n    return square_sdf(position, box_center, radius) < 0.;\n}\n\nbool is_inside_target_distribution(vec2 position)\n{\n    return circle_sdf(position, circle_center, radius) < 0.;\n}\n\nvec2 alpha_blend(vec2 source_point, vec2 target_point, float alpha)\n{\n    return mix(source_point, target_point, alpha);\n}\n\nvec2 alpha_deblend(vec2 blended_point, vec2 sample_point, float alpha)\n{\n    // Solve \n    //\n    //    blended_point = (1.-alpha) * sample_point + alpha * target_point\n    //  \n    // for 'target_point'\n    \n    return ( blended_point - (1.-alpha)*sample_point ) / alpha;\n}\n\n// DDIM\n// See appendix C of paper\n\nvec2 ddim_alpha_blend(vec2 source_point, vec2 target_point, float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    float beta_0 = sqrt(1.-alpha);\n    float beta_1 = sqrt(alpha);\n    return beta_0 * source_point + beta_1 * target_point;\n}\n\nvec2 ddim_alpha_deblend(vec2 blended_point, vec2 sample_point, float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    float beta_0 = sqrt(1.-alpha);\n    float beta_1 = sqrt(alpha);\n    return ( blended_point - beta_0*sample_point ) / beta_1;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Transport map buffer\n\n// Each pixel corresponds to a source location\n// The value of each pixel gives a target location\n\n\nvec4 get_transport_map(vec2 U) { return texelFetch( iChannel0, ivec2(U), 0 ); }\n\nvec4 init_transport_map(vec2 fragCoord)\n{\n    vec2 box_uv = fragCoord.xy/iResolution.xy;\n    return vec4(sample_source_distribution(box_uv), 0., 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame==0) \n    {\n        fragColor = init_transport_map(fragCoord);\n    }\n    if(iFrame > 0)\n    {\n        vec4 transport_map = get_transport_map(fragCoord); // previous state\n        fragColor = transport_map;\n        \n        // This gives better results than t = (float(iFrame * num_substeps)/total_steps);\n        // Because of rejection sampling, the pixels may be slightly out of sync in terms of iterations,\n        // We should let the t-value reflect that, so that t = num_steps / total_steps;\n        float num_steps = transport_map.z;\n        float t = num_steps / total_steps;\n        \n        if ( t > 1. ) // end of iterations\n            return;                            \n        \n        vec2 current_point = fragColor.xy;                          // P: previous pivot\n        vec2 next_point = current_point;\n        vec2 Hash;\n        vec2 source_point;                                          // point in the source shape ( square )\n        vec2 target_point;                                          // point in the target shape ( disc )\n        \n        \n        for(int substep = 0; substep < num_substeps; substep++)\n        {\n            bool accepted = false;\n            \n            // ------- deblending phase --------\n            \n            // rejection sampling\n            for( float i = 0.; i < max_sampling_iterations && !accepted; i++)    \n            {  \n                Hash = hash2( current_point + vec2(t -i/1.3) + fragCoord.xy/iResolution.xy );\n                \n                if ( t < .5 ) // --- if first half of iterations:\n                {\n                    target_point = sample_target_distribution(Hash);              \n                    source_point = alpha_deblend(current_point, target_point, 1.-t);\n                    accepted = is_inside_source_distribution(source_point);// reject up to A in square\n                }\n                else // --- if second half of iterations: \n                {\n                    source_point = sample_source_distribution(Hash);\n                    target_point = alpha_deblend(current_point, source_point, t);\n                    accepted = is_inside_target_distribution(target_point); // reject up to B is disc\n                }\n            }\n\n            // ------- alpha blending phase --------\n\n            if (accepted)\n            {\n                num_steps++;\n                t += dt;\n                float alpha = t;  \n                next_point = alpha_blend(source_point, target_point, alpha);\n            }\n            \n            current_point = next_point;\n        }\n        fragColor.xy = current_point;\n        fragColor.z = num_steps;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Trace-lines buffer\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_trace(vec2 U) { return  texelFetch( iChannel1, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 trace = get_trace(fragCoord);\n    \n    float t = get_transport_map(fragCoord).z / total_steps;\n    \n    if(iFrame == 0)\n        fragColor = vec4(0,0,0,1);\n    else\n        fragColor = trace;\n         \n    if(t > 1.) return; // Stop tracing when the schedule is complete\n         \n    vec2 Id = vec2(0);\n    float min_dist_squared = 1e9;\n\n    // Find nearest particle\n    int N = num_particles;\n    for( int i = 0; i < N*N; i++ )\n    {\n        vec2 pixel_uv = ( ( .5 + vec2(i%N, i/N) ) / float(N) );\n        vec2 particle_position_uv = get_transport_map( pixel_uv * iResolution.xy ).xy;\n        vec2 P = uv_to_pixel(particle_position_uv, iResolution.xy) - fragCoord;  // offset to current pixel\n\n        float dist_squared = dot(P,P);\n        if(dist_squared < min_dist_squared)\n        {\n            min_dist_squared = dist_squared;\n            Id = pixel_uv;\n        }\n    }\n    \n    float len = sqrt(min_dist_squared);\n    vec3 dot_color =  vec3(Id, 1);\n   \n    const float trace_strength = 0.01;\n    fragColor.rgb = mix(fragColor.rgb, dot_color, trace_strength * smoothstep( 2.5, 2., len ));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Draw particles buffer\n// Visualizes the resulting transport map\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_particles(vec2 U) { return  texelFetch( iChannel2, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = vec4(0);\n                                 \n    vec2 Id = vec2(0);\n    float min_dist_squared = 1e9;\n    \n    float t = get_transport_map(fragCoord).z / total_steps;\n\n    vec2 pixel_uv_offset = vec2(0);\n    \n    int N = num_particles; // Should be same as buffer B to have trails match particles\n\n    // When we reach the end we store the previous state and try to fill out the target mapping\n    if(t > 1.)\n    {\n        pixel_uv_offset = .499*(2.*hash2(fragCoord.xy + iTime)-1.);\n        N = 5; // Use fewer when filling over time\n        \n        vec4 particles = get_particles(fragCoord);\n        fragColor = particles;\n    }\n    \n    // Find nearest particle\n    for( int i = 0; i < N*N; i++ )\n    {\n        vec2 pixel_uv = (( .5 + vec2(i%N, i/N) + pixel_uv_offset )/float(N));\n        vec2 particle_position_uv = get_transport_map( pixel_uv * iResolution.xy ).xy;\n        vec2 P = uv_to_pixel(particle_position_uv, iResolution.xy) - fragCoord;  // offset to current pixel\n\n        float dist_squared = dot(P, P);\n        if(dist_squared < min_dist_squared)\n        {\n            min_dist_squared = dist_squared;\n            Id = pixel_uv;\n        }\n    }\n\n    float len = sqrt(min_dist_squared);\n    vec2 rowcol = (floor(8.*Id));\n    float checker = mod(rowcol.x + rowcol.y, 2.);\n    vec3(.678, .747, .902);\n    vec4 dot_color =  vec4(vec3(Id,0.) * (.75*checker+.25), 1);\n\n    float alpha = smoothstep( 2.5, 2., len );\n\n    fragColor = mix( fragColor, dot_color, alpha); // draw dots \n}","name":"Buffer C","description":"","type":"buffer"}]}