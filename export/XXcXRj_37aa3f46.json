{"ver":"0.1","info":{"id":"XXcXRj","date":"1719244226","viewed":107,"name":"Binary Tree Explorer","username":"cf","description":"simple binary tree sdf with zoom controls\n\nSlider 1: Tree height (1-11)\nSlider 2/3: Pan center point for zoom\nSlider 4: Zoom level\nMouse: Pan around the tree","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["merkle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdOrientedBox(vec2 p, vec2 a, vec2 b, float th) {\n    vec2 d = normalize(b - a);\n    vec2 q = abs(mat2(d.x, -d.y, d.y, d.x) * (p - (a + b) * 0.5)) - vec2(length(b - a) * 0.5, th);\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n    return length(uv - offset) - r;\n}\n\nfloat sdCircleTopAligned(vec2 uv, float r, vec2 offset) {\n    // simplified thanks to FabriceNeyret2\n    return length(uv - offset - vec2(0, r)) - r;\n}\n\nvec2 sdNode(vec2 uv, float r, vec2 offset, vec2 child, float rMp) {\n    float d1 = sdCircleTopAligned(uv, r * rMp, offset);\n    float d2 = min(sdOrientedBox(uv, offset + vec2(0.0, r * rMp), offset + child, r * 0.4),\n                   sdOrientedBox(uv, offset + vec2(0.0, r * rMp), offset + vec2(-child.x, child.y), r * 0.4));\n    return vec2(min(d1, d2), sign(d2 - d1));\n}\n\n#define calcLOR(a,h) (1. - a * (h + 1.)) / (a * h)\n\nvec2 sdNodeMerkleTreeV2(vec2 uv, float levelOffset, float treeLevels) {\n    float numLeaves = pow(2., treeLevels);\n    float nodeRadius = 1.0 / (4. * numLeaves);\n    float levelSpacing = calcLOR(nodeRadius, treeLevels) * nodeRadius;\n    float treeWidth = numLeaves * nodeRadius * 6. - nodeRadius * 2.;\n    \n    float level = clamp(floor(uv.y / levelSpacing) + levelOffset, 0., treeLevels);\n    float n = pow(2., level);\n    float twn = treeWidth / n;\n    vec2 circleCenter = vec2((floor(mod(uv.x / twn, n)) + 0.5) * twn, level * levelSpacing);\n    \n    return (level >= treeLevels) ? vec2(sdCircleTopAligned(uv, nodeRadius, circleCenter), 1.0)\n                                 : sdNode(uv, nodeRadius, circleCenter, vec2(twn * 0.25, levelSpacing), pow(1.5, treeLevels - level));\n}\n\nvec4 processSliders(in vec2 uv, out vec4 sliderVal) {\n    sliderVal = textureLod(iChannel1, vec2(0), 0.0);\n    return (length(uv) > 1.) ? textureLod(iChannel1, uv / iResolution.xy, 0.0) : vec4(0);\n}\n\n\nvec3 drawScene(vec2 uv, float treeLevels, float zoomFactor) {\n    vec2 node = sdNodeMerkleTreeV2(vec2(uv.x, 1.0 - uv.y), 0.0, treeLevels);\n    // antialiasing thanks to FabriceNeyret2\n    float res = smoothstep(0., 1.5 / iResolution.y * zoomFactor, node.x);\n    return mix(vec3(node.y, (1. - node.y) * 0.25, (1. - node.y) * 0.5), vec3(1.0), res);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 sliderVal, cSlider = processSliders(fragCoord, sliderVal);\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float mpz = 1.25 * sliderVal.w;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    \n    if (iMouse.z > 0.01 && (mousePos.x < 0.8 || mousePos.y < 0.7)) {\n        uv -= (0.5 - mousePos) * 2.0;\n    }\n    \n    uv -= (0.5 - sliderVal.zy) * 2.0;\n    uv *= mpz;\n    \n    vec3 col = drawScene(uv * mpz, 1. + floor(sliderVal.x * 10.), sliderVal.w);\n    fragColor = vec4(mix(col, cSlider.rgb, cSlider.a), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A : slider management (this is not required)\n// Bers : https://www.shadertoy.com/view/MscXzn\n\n#define saturate(x) clamp(x,0.0,1.0)\n\nvec4 sliderVal = vec4(0.4,0.505,0.425,0.8); //Default slider values [0-1]\n\n// vec4 sliderVal = vec4(0.4,0.4,0.,0.5); // bras de galaxies\n// vec4 sliderVal = vec4(1.,0.2,0.,0.1); // bacteries\n\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = textureLod(iChannel0,vec2(0),0.0);\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)/height;\n        t = clamp(t/0.75-0.125,0.,1.); //25% top/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)/width, t);\n    }\n}\n\n//Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  //Cursor radius, in local space\n    const float LW  = 0.030; //Line width\n    float aa  = 14./iResolution.x; //antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization\n    muv = (muv-cMin)/vec2(width,height); //mouse Normalization\n    if( withinUnitRect(uv))\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); //repeat 4x\n\t\tuv.y = uv.y/0.75-0.125; //25% margins\n        return SLIDER_drawSingle(vec2(uv.x*2.-.5, uv.y),t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.8,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.0);\n    vec2 uvSliders = fragCoord.xy / iResolution.xy;\n\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    \n    if(length(fragCoord.xy-vec2(0,0))<1.) \n         fragColor = sliderVal;\n    else {\n\t\tif (!withinUnitRect(uvSliders)) \n            discard;    \n    \tfragColor = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n\t}\n}\n","name":"Buffer A","description":"","type":"buffer"}]}