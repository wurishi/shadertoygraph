{"ver":"0.1","info":{"id":"MX33Rf","date":"1716817348","viewed":39,"name":"AtomCloud","username":"pecelec","description":"Matrix of atoms vibrating ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blackandwhite","dots","vibrating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of points\n#define POINT_COUNT 500\n\n// Speed factor\n#define SPEED 0.005\n\n#define SIZE 0.00001\n\n// Pseudo-random number generator\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Initialize points\nvec2 getInitialPosition(int i) {\n    return vec2(rand(vec2(i, 0.0)), rand(vec2(i, 1.0)));\n}\n\n// Main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = uv.y * iResolution.y / iResolution.x;\n\n    // Time variable\n    float time = iTime;\n\n    // Accumulator for color\n    vec3 color = vec3(0.0);\n\n    // Loop through points\n    for (int i = 0; i < POINT_COUNT; i++) {\n        vec2 pos = getInitialPosition(i);\n\n        // Brownian motion using random noise\n        vec2 motion = vec2(rand(pos + vec2(time, 0.0)), rand(pos + vec2(0.0, time))) - 0.5;\n        pos += motion * SPEED;\n\n        // Keep points within the visible area\n        pos = clamp(pos, 0.0, 1.0);\n\n        // Adjust position for aspect ratio\n        pos.y = pos.y * iResolution.y / iResolution.x;\n\n        // Calculate distance from current pixel\n        float dist = distance(uv, pos);\n\n        // Brightness based on distance\n        float brightness = SIZE / (dist * dist + SIZE); // Avoid division by zero\n\n        // Accumulate color\n        color += vec3(brightness);\n    }\n\n    // Output final color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}