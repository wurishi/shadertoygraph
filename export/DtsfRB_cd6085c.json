{"ver":"0.1","info":{"id":"DtsfRB","date":"1693125929","viewed":363,"name":"blinn-phong-light and-normal","username":"linround","description":"左边是正常的高光反射，右边使用的是blinnPhong模型计算的反射；","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lightblinnphong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415926\n#define TWO_PI 6.28318530718\n\n\nmat4 roateMat(in vec3 u,in float theta){\n    float c = cos(theta) ;\n    float s = sin(theta);\n    u = normalize(u);\n    // 以下是构建一个三维旋转矩阵的列\n    vec4 c0 = vec4(u.x*u.x*(1.0-c)+c,u.x*u.y*(1.-c)+u.z*s,u.x*u.z*(1.-c)-u.y*s,0.0);\n    vec4 c1 = vec4(u.x*u.y*(1.-c)-u.z*s,u.y*u.y*(1.-c)+c,u.y*u.z*(1.-c)+u.x*s,0.0);\n    vec4 c2 = vec4(u.z*u.x*(1.-c)+u.y*s,u.z*u.y*(1.-c)-u.x*s,u.z*u.z*(1.-c)+c,0.0);\n    vec4 c3 = vec4(0.,0.,0.,1.);\n    return mat4(c0,c1,c2,c3);\n}\n\n\nvec3 getSphereMaterial(in vec3 point){\n    const vec3 material1 = vec3(1.0,0.,0.);\n    const vec3 material2 = vec3(0.5,0.5,0.5);\n    const vec3 material3 = vec3(0.0,1.0,0.0);\n    const vec3 material4 = vec3(0.0,0.0,1.0);\n    if(point.x>0.&& point.y>0.){\n        return material1;\n    } else if(point.x<=0. && point.y>0.){\n        return material2;\n    } else if(point.x<=0. && point.y<=0.){\n        return material3;\n    }\n    return material4;\n}\n\n\n\n\n\n\n// 定义基本光照模型相关参数\n\n\nconst vec3 ambientLight = vec3(0.0); // 定义环境光\nconst vec3 light = vec3(1.0); // 定义点光源强度\nconst vec3 lightPos = vec3(0.,0.,5.); // 定义点光源的位置\nconst vec3 viewPos = vec3(0.,0.,5.); // 观察点\nconst float ks = 0.6;// 镜面反射参数 根据材质决定反射能量的大小\nfloat specularEx = 20.;// 镜面反射参数：光滑表面的值较大，理想反射器的值时无限的（决定镜面光斑的大小，可提高视觉效果）\n\nvec3  getDiffuse(in vec3 point,in vec3 kd){\n    vec3 normal = normalize(point);// 该球表面点的法向量\n    vec3 ambientDiffuse = kd*ambientLight;// 环境光对漫反射的贡献\n    vec3 lightDir = normalize(lightPos-point);// 光源的方向：由表面顶点指向光源\n    vec3 lightDiffuse = kd*light*max(dot(normal,lightDir),0.0); // 点光源对漫反射的贡献\n\n    return lightDiffuse + ambientDiffuse;\n}\n\nvec3 getSpecular(in vec3 point){\n    vec3 normal = normalize(point);// 该球表面的法向量\n    vec3 lightDir = normalize(lightPos-point); // 光源方向：由表面顶点指向光源\n    vec3 viewDir = normalize(viewPos - point); // 观察方向，注意要归一化，这样才能计算对应的余弦值\n\n    vec3 lightReflect = reflect(-lightDir,normal); // 反射:由表面点发出\n    vec3 lightSpecular = ks*light*pow(max(dot(lightReflect,viewDir),0.0),specularEx); // 镜面反射值\n\n    return lightSpecular;\n\n}\n\n\nvec3 roateVertex(in vec3 vertex){\n\n    mat4 roate = roateMat(vec3(1.),iTime);\n    return (roate*vec4(vertex,0.)).xyz;\n}\n\n\n\nvec3 makeNormalModel(in vec2 st){\n    st.x+=1.0;\n    vec3 bgColor = vec3(0.);\n    vec3 color;\n    float len = length(st);\n    float r = 1.0;// 球体半径\n    if(len<=1.0){\n        float z = sqrt(r*r - len*len);\n        vec3 sphereVertex = vec3(st,z);\n        vec3 vertexMaterilal= getSphereMaterial(sphereVertex);// 得到该顶点对应的材质\n        vec3 diffuse = getDiffuse(sphereVertex,vertexMaterilal); // 得到该材质产生的漫反射\n        vec3 specular = getSpecular(sphereVertex); // 得到该材质的镜面反射\n        color = diffuse + specular;// 最终产生的结果时漫反射和镜面反射之和\n    }\n    color = mix(bgColor,color,1.);\n    return color;\n}\n\n\nvec3 getBlinnPhongSpecular(in vec3 point){\n    vec3 normal = normalize(point);// 该球表面的法向量\n    vec3 lightDir = normalize(lightPos-point); // 光源方向：由表面顶点指向光源\n    vec3 viewDir = normalize(viewPos - point); // 观察方向，注意要归一化，这样才能计算对应的余弦值\n\n    vec3 hDir = normalize(lightDir+viewDir); // 求得半角向量\n\n    vec3 lightSpecular = ks*light*pow(max(dot(hDir,normal),0.0),specularEx); // 镜面反射值\n\n    return lightSpecular;\n}\nvec3 makeBlinnPhongModel(in vec2 st) {\n    st.x-=1.0;\n    vec3 bgColor = vec3(0.);\n    vec3 color;\n    vec3 centerA = vec3(-1,0,0);\n    float len = length(st);\n    float r = 1.0;// 球体半径\n    if(len<=1.0){\n        float z = sqrt(r*r - len*len);\n        vec3 sphereVertex = vec3(st,z);\n        vec3 vertexMaterilal= getSphereMaterial(sphereVertex);// 得到该顶点对应的材质\n        vec3 diffuse = getDiffuse(sphereVertex,vertexMaterilal); // 得到该材质产生的漫反射\n        vec3 specular = getBlinnPhongSpecular(sphereVertex); // 得到该材质的镜面反射\n        color = diffuse + specular;// 最终产生的结果时漫反射和镜面反射之和\n    }\n    color = mix(bgColor,color,1.);\n    return color;\n}\nvec3 renderSphere(in vec2 st){\n    vec3 bgColor = vec3(0.);\n\n    vec3 color = makeNormalModel(st);\n    color+=makeBlinnPhongModel(st);\n    color = mix(bgColor,color,1.);\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st = (st*4.0)-2.;\n    st.x *=iResolution.x/iResolution.y;\n    vec3 color =  renderSphere(st);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}