{"ver":"0.1","info":{"id":"lcy3Dz","date":"1712608830","viewed":65,"name":"Steel Metal Ball","username":"elifront","description":"Steel metal ball. Learning textures / lighting / cubemaps","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["metal","steelsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.001;\nconst float PI = 3.14159265359;\n\nfloat sdSphere(vec3 p) {\n    return length(p) - .8;\n}\n\n// Estimate normal using gradient\nvec3 getNormalFromP(vec3 p) {\n    float x = sdSphere(vec3(p.x + EPSILON, p.y, p.z)) - sdSphere(vec3(p.x - EPSILON, p.y, p.z));\n    float y = sdSphere(vec3(p.x, p.y + EPSILON, p.z)) - sdSphere(vec3(p.x, p.y - EPSILON, p.z));\n    float z = sdSphere(vec3(p.x, p.y, p.z + EPSILON)) - sdSphere(vec3(p.x, p.y, p.z - EPSILON));\n    return normalize(vec3(x, y, z));\n}\n\n// Phong shading\nvec3 phongShading(vec3 normal, vec3 lightDir, vec3 viewDir,\n    vec3 lightAmbient, vec3 lightDiffuse, vec3 lightSpecular,\n    vec3 materialAmbient, vec3 materialDiffuse, vec3 materialSpecular) {\n    // Ambient component\n    vec3 ambient = lightAmbient * materialAmbient;\n\n    // Diffuse component\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = lightDiffuse * (diff * materialDiffuse);\n\n    // Specular component\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0); // More diffuse specular highlight\n\n    vec3 specular = lightSpecular * (spec * materialSpecular);\n\n    // Summing all components\n    vec3 result = ambient + diffuse + specular;\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n    vec2 um = iMouse.xy / iResolution.xy * 10. - 5.;\n\n    vec3 ro = vec3(0, 0, -3); // ray origin\n    float fov = .5;\n    vec3 rd = normalize(vec3(uv * fov, 1)); // ray direction\n    \n    \n    vec3 col = vec3(0.0);\n    float t = 0.;\n\n\n    // Raymarching\n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        float d = sdSphere(p);\n        if (d < EPSILON * 10. || t > 100.) break;\n        t += d;\n    }\n\n    if (t < 100.) {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormalFromP(p);\n\n        // Adjusted Surface properties for a galvanized steel look\n        vec3 materialAmbient = vec3(0.05, 0.05, 0.05); // Darker ambient for higher contrast\n        vec3 materialDiffuse = vec3(0.2, 0.2, 0.2); // Darker diffuse for higher contrast\n        vec3 materialSpecular = vec3(1.0, 1.0, 1.0); // Brighter specular for more reflectivity\n\n        // Light positions updated to fit three-point lighting setup\n        vec3 positions[3];\n        positions[0] = vec3(2.0, 5.0, -5.0); // Key light position (brightest, primary source)\n        positions[1] = vec3(-2.0, -3.0, -5.0); // Fill light position (softer, opposite key light)\n        positions[2] = vec3(0.0, 0.0, 5.0); // Back light position (behind the object)\n\n        vec3 lightAmbients[3];\n        lightAmbients[0] = vec3(0.2, 0.2, 0.25); // Key light\n        lightAmbients[1] = vec3(0.1, 0.1, 0.15); // Fill light\n        lightAmbients[2] = vec3(0.15, 0.15, 0.2); // Back light\n\n        vec3 lightDiffuses[3];\n        lightDiffuses[0] = vec3(1.0, 1.0, 1.0); // Key light\n        lightDiffuses[1] = vec3(0.5, 0.5, 0.5); // Fill light\n        lightDiffuses[2] = vec3(0.6, 0.6, 0.6); // Back light\n\n        vec3 lightSpeculars[3];\n        lightSpeculars[0] = vec3(1.0, 1.0, 1.0); // Key light\n        lightSpeculars[1] = vec3(0.3, 0.3, 0.3); // Fill light\n        lightSpeculars[2] = vec3(0.5, 0.5, 0.5); // Back light\n\n        vec3 viewDir = normalize(-rd);\n        \n        // Calculate reflection vector\n        vec3 reflectionVector = reflect(rd, normal);\n\n        // Get environment color from the cube map\n        vec3 envColor = texture(iChannel0, reflectionVector).rgb;\n      \n\n        for (int i = 0; i < 3; i++) {\n            // three point lighting\n            vec3 lightDir = normalize(positions[i] - p);\n            col += phongShading(normal, lightDir, viewDir, lightAmbients[i], lightDiffuses[i], lightSpeculars[i], materialAmbient, materialDiffuse, materialSpecular);\n        }\n        \n        float reflectivity = 0.3; // Adjust for more or less reflection\n        col = mix(col, envColor, reflectivity);\n        \n\n    } else {\n        col = vec3(0.);\n;\n    }\n\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}