{"ver":"0.1","info":{"id":"slcBzs","date":"1663513593","viewed":76,"name":"Natural Logarithm Approximation","username":"Envy24","description":"For range (0; 1] used Halley method, for range (1; inf) used Remez algorithm.\nGreen - built-in log function.\nRed - approxamation.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["approximation","logarithm","natural","log2","ln","log10"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  sinOSC(8., 16000., iTime*0.5) / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float signed_dist = NDC.y - fx;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* Approximation by Halley's Method \n   https://stackoverflow.com/questions/9799041/efficient-implementation-of-natural-logarithm-ln-and-exponentiation */\nfloat ln_Halley(float y)\n{\n    const float tolerance = 1e-7;\n    float xc = -y, xn = xc;\n    int i = 0, max_count = 9;\n    \n    do\n    {\n        xc = xn;\n        xn = xc + 2. * (y - exp(xc)) / (y + exp(xc));\n        ++i;\n\n    } while ((i<max_count) && (abs(xc - xn) > tolerance));\n\n    return xn;\n}\n/* Remez algorithm.\n   https://stackoverflow.com/questions/9799041/efficient-implementation-of-natural-logarithm-ln-and-exponentiation */\nfloat ln_Remez(float y) \n{\n    int log2_ = 0;\n    float tmp = y; while (tmp >= 1.) { ++log2_; tmp *= 0.500001; } --log2_;\n    //log2_ = int(log2(y));\n        \n    float divisor = float(1 << log2_);\n    tmp = y / divisor;    // normalized value between [1.0, 2.0]\n\n    // Approximates natural logarithm value at interval [1.; 2.].\n    tmp = -1.7417779972 + (2.8211715373 + (-1.4699394353 + (0.4471783181 - 0.0565717132 * tmp) * tmp) * tmp) * tmp;\n    //tmp = -1.7417939 + (2.8212026 + (-1.4699568 + (0.44717955 - 0.056570851 * tmp) * tmp) * tmp) * tmp;\n    // Add log(divisor) to result.\n    tmp += float(log2_) * 0.69314718; // ln(2) = 0.69314718\n\n    return tmp;\n}\n\nfloat ln(float y) {\n    if (y == 0.0) { return 0.; } // -INFINITY in cmath\n    if (y < 0.0) { return 0.0; } // NAN in cmath\n    if (y > 0. && y <= 1.) { return ln_Halley(y); }\n    return ln_Remez(y);\n}\n\nfloat log2_(float y) { return log(y) / log(2.); }\nfloat log10_(float y) { return log(y) / log(10.); }\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = (TO_CENTERED_NDC(SC) + vec2(1.5, 0.5)) * sinOSC(1., 4000., iTime*0.5);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC); \n         \n    float scale = sinOSC(1., 512., iTime*0.5);\n         /**/\n#define func(x) ( log(x) )\n#define dfdx(x) ( 1./(x) )\n         color.rb -= draw_explicit_func(NDC, scale*func(NDC.x), scale*dfdx(NDC.x));               \n         /**/\n#define func2(x) ( ln(x) )\n#define dfdx2(x, dx) ( ( func2((x)+(dx)) - func2(x) ) / (dx) )\n         color.gb -= draw_explicit_func(NDC, scale*func2(NDC.x), scale*dfdx2(NDC.x, 0.01));            \n         /**/\n         \n         for (int i = 0; i < 7; ++i) { color -= vertical_line(NDC, pow(10., float(i)))*0.4; }\n         \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}