{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n#define SPIKE 0\nfloat spike(float x, float x0, float w)\n{\n#if SPIKE == 0\n\t// blurry\n\t//return 1.0 - smoothstep(0.0, 1.0, 0.5 * abs(x - x0) / w);\n\t\n\tfloat aa = 6.0;\n\treturn 1.0 - smoothstep(0.5 * (w - aa), 0.5 * (w + aa), abs(x - x0));\n#elif SPIKE == 1\n\t// AA\n\tfloat aa = 2.5; //0.75;\n\treturn 1.0 - smoothstep(0.5 * (w - aa), 0.5 * (w + aa), abs(x - x0));\n#else\n\treturn 1.0 - step(0.5 * w, abs(x-x0));\n#endif\n}\n\n/// de(x, y) = |f(x) - y| / (sqrt(1 + (df(x)/dx)Â²))\n/// use as input to smoothstep\nfloat de(const in vec2 p)\n{\n\tfloat fx = exp(p.x) * sin(p.x);\n\tfloat dfx = 0.0;\n\n\treturn abs(fx - p.y) / sqrt(1.0 + dfx * dfx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat w = iResolution.x;\n\tfloat h = iResolution.y;\n\tfloat x = fragCoord.x;\n\tfloat y = fragCoord.y;\n\t\n\tfloat f0 = 6.28 * 5.0 / w;\t// spatial modulation\n\t//f0 = f0 * (1.0 + 0.3 * cos(0.2 * iTime));\n\t//0.1 * sin(0.5 * iTime);\n\t\n#if 1\n\tfloat l0 = 15.0; // line width\n\tfloat s = 0.4;\n\tfloat am = sin(s * 1.0 * iTime); // amplitude modulation\n\tfloat pm = sin(s * 0.1 * iTime);\t// phase modulation\n\t\n\tfloat pv = 6.0;\n\tpm = abs(1.0 - 2.0 * mod(iTime, pv) / pv);\n\tpm = 0.0;\n\t\n\tfloat e0 \t= 10.0; \t\t\t\t\t\t\t\t\t\t\t// spatial modulation factor\n\tfloat ae \t= exp(e0 * (0.5 - abs(x/w - 0.5))) / exp(0.5 * e0);\t// spatial modulation\n\tfloat d_mod = 1.0 - 2.0 * abs(x/w - 0.5); // modulate color around w/2\n#else\n\tfloat l0 = 20.0; // line width\n\tfloat am = 0.8;\n\tfloat pm = 0.0;\n\tfloat ae = 1.0;\n\tfloat d_mod = 1.0;\n#endif\n\t\t\n\tfloat phi = f0 * x + 6.28 * pm;\n\tfloat sin_phi = sin(phi);\n\t\n#if 1\n\t// compensate l0\n\t// h(x) = l0 / abs(cos(am * atan(omega * cos(omega * x)))))\n\t// \t\t= l0 * sqrt(abs(1 + omegaÂ² * cosÂ²(omega x)))\n\t// http://www.wolframalpha.com/input/?i=1%2Fabs%28cos%28atan%28w+cos%28wx%29%29%29%29+for+x%3D0+to+1+w+%3D+0+to+10\n\t\n\tfloat cos_phi2 = 1.0 - (sin_phi * sin_phi);\n\t\n\tfloat a = am * ae * 0.25 * h;\n\t\n\tfloat lc = l0 * sqrt(abs(1.0 + (a * a * f0 * f0 * cos_phi2)));\n#else\n\tfloat lc = l0;\n#endif\t\n\t\n\t//float cos_phi = sqrt(cos_phi2);\n\t//lc = l0 / abs(cos(atan(am * f0 * cos(f0 * x))));\n\t\n\t//l0 = l0 * sqrt(1.0 + f0 * f0 * (1.0 - sin_phi * sin_phi));\n\t\n\t//l0 = l0 * abs((1.0 + f0 * f0 * cos_phi2) / (f0 * sqrt(cos_phi2)));\n\t\n\tfloat fx = am * ae * sin_phi;\n\tfloat fc = 0.5 * h * (1.0 + fx); // centered\n\n\t//d_mod = sqrt(d_mod);// * d_mod;\n\t\n\tvec4 rgba = vec4(1.0, 0.8, 0.5, 0.1);\n\t\n\t//float cos_phi = abs(sin_phi); //1.0 - sqrt(abs(sin_phi));\n\t//l0 = l0 * (1.0 + 0.1 / (cos_phi + 0.01));\n\tfloat st = spike(y,fc, lc); // base alphas\n\t\n\t// signed distance function\n\tfloat sd = abs(y - fc) - 0.5 * l0;\n\tfloat sds = sqrt(x*x + y*y) - 5.0;\n\t\n\t//st = 1.0 - step(1.0, sd);\n\t\n\tfloat lbase = 2.0 + 0.5 * h;\n\t\n#if 0\n\tfloat l1 = spike(y, lbase, 2.0) + spike(y, h - lc, 2.0);\n\tfloat l2 = spike(y, lbase + lc, 2.0);\n#else\n\tfloat l1 = 0.0;\n\tfloat l2 = 0.0;\n#endif\n\t\n\tfragColor.r = rgba.r * d_mod * d_mod * st + l2;\n\tfragColor.g = rgba.g * d_mod * st + l1;// * pm;\n\tfragColor.b = rgba.b * sqrt(d_mod) * st;\n\tfragColor.a = rgba.a; // alpha no workee here ?\n\t\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dl3Wj","date":"1388178306","viewed":153,"name":"sine string","username":"lorcan","description":"string simulation test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""}}