{"ver":"0.1","info":{"id":"mly3WK","date":"1684666675","viewed":125,"name":"Mandelbrot interior distance","username":"kastorp","description":"just a porting of a C library I found [url=https://github.com/adammaj1/Mandelbrot-book-book/blob/main/src/interior-distance.c]here[/url]\nI used it to test my [url=https://www.shadertoy.com/view/clVGzR]Quad Loader[/url]","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://en.wikibooks.org/wiki/Fractals/Iterations_in_the_complex_plane/demm#Interior_distance_estimation\n// https://mathr.co.uk/blog/2014-11-02_practical_interior_distance_rendering.html\n//https://github.com/adammaj1/Mandelbrot-book-book/blob/main/src/interior-distance.c\n\nfloat cnorm(vec2 z){ return dot(z,z);}\nvec2 cmul(vec2 a,vec2 b){ return vec2(a.x*b.x - a.y*b.y,  a.x*b.y + a.y*b.x);}\nvec2 cdiv(vec2 a,vec2 b){ return vec2(a.x*b.x + a.y*b.y, -a.x*b.y + a.y*b.x)/dot(b,b);}\nfloat cabs(vec2 z){return sqrt(cnorm(z));}\n\nvec2  m_attractor(vec2  w0, vec2 c, int p, int n)\n{\n  vec2 w = w0;\n  for (int m = 0; m < n; ++m)\n  {\n    vec2 z = w;\n   vec2 dz = vec2(1,0);\n    for (int i = 0; i < p; ++i)\n    {\n      dz = 2. * cmul(z ,dz);\n      z = cmul(z , z) + c;\n    }\n    w = w - cdiv(z - w, dz - vec2(1,0));\n  }\n  return w;\n}\n\nfloat  m_interior_distance (vec2 z0, vec2 c, int p)\n{\n   vec2 z = z0;\n   vec2 dz= vec2(1,0);\n   vec2 dzdz = vec2(0);\n   vec2 dc =vec2(0);\n   vec2 dcdz =vec2(0);\n    for (int m = 0; m < p; ++m)\n    {\n        dcdz = 2. * (cmul(z , dcdz) + cmul(dz , dc));\n        dc = 2. * cmul(z , dc) + vec2(1,0);\n        dzdz = 2. * (cmul(dz , dz) + cmul(z , dzdz));\n        dz = 2. * cmul(z , dz);\n        z = cmul(z , z) + c;\n    }\n    return (1. - cnorm(dz))\n        / cabs(dcdz + cdiv(cmul(dzdz , dc) , (vec2(1.,0) - dz)));\n}\n\nfloat  m_distance(int N, float R, vec2 c)\n{\n    vec2  dc = vec2(0);\n    vec2 z = vec2(0);\n    float  m = 1e40;\n    int p = 0;\n    for (int n = 1; n <= N; ++n)\n    {\n        dc = 2. * cmul(z , dc) + vec2(1,0);\n        z = cmul(z , z) + c;\n        if (cabs(z) > R)\n            return ( cabs(z) * log(cabs(z)) / cabs(dc));\n           \n        if (cabs(z) < m)\n        {\n            m = cabs(z);\n            p = n;\n            vec2 z0 = m_attractor(z, c, p,64);\n            vec2 w = z0;\n            vec2 dw = vec2(1,0);\n            for (int k = 0; k < p; ++k)\n            {\n                dw = 2. *cmul( w , dw);\n                w = cmul(w , w) + c;\n            }\n            if (cabs(dw) <= 1.)\n                //nb: tan is my addition\n                return -tan(1.5*m_interior_distance(z0, c, p))/3.;\n                //return m_interior_distance(z0, c, p)/2.;\n        }\n    }\n    return 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float z =1.;\n\tvec2 p = z*(2.*fragCoord-iResolution.xy)/iResolution.y-vec2(.5,0);\n    vec2 m = z*(2.*iMouse.xy-iResolution.xy)/iResolution.y-vec2(.5,0);\n    \n    float d=m_distance(100,25.*25.,p);\n    float dm= iMouse.z>0.001 ? m_distance(100,25.*25.,m):1e5;\n     \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.0,1.1,1.2);\n\tcol *= 1.0 - exp(-20.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(100.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.001,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.001, abs(length(p-m)-abs(dm))-0.002));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.001, length(p-m)-0.01));\n    }\n   \n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}