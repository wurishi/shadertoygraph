{"ver":"0.1","info":{"id":"7dcfWj","date":"1657194537","viewed":97,"name":"Fork Fork RGB t chenxiaolo 179","username":"chenxiaolong","description":"Sandbox for RGB to HSV/HSL conversions and vice versa\n\nThings to notice:\n1) There's a visible difference between changing the \"V\" in HSV and the \"L\" in HSL\n2) The round-trip of HSV is slightly more accurate than HSL (but not worth considering in reality)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rgb","hsv","hsl"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\n// RGB\n\nvec3 image0(vec3 rgb) {\n    // Just return the raw image value\n    return rgb;\n}\n\nvec3 image1(vec3 rgb) {\n    // Return the greyscale of the image\n\tconst vec3 weights = vec3(0.299, 0.587, 0.114);\n    return vec3(dot(rgb, weights));\n}\n\nvec3 image2(vec3 rgb) {\n    // Return the exaggerated hue of the image\n    float hue = RGBtoHCV(rgb).x;\n    return HUEtoRGB(hue);\n}\n\n// HSL\n\nvec3 image3(vec3 rgb) {\n    // Round-trip RGB->HSL->RGB with time-dependent hue shift\n    vec3 hsl = RGBtoHSL(rgb);\n    hsl.x = fract(hsl.x + iTime * 0.15);\n    return HSLtoRGB(hsl);\n}\n\nvec3 image4(vec3 rgb) {\n    // Round-trip RGB->HSL->RGB with time-dependent lightness\n    vec3 hsl = RGBtoHSL(rgb);\n    hsl.z = pow(hsl.z, sin(iTime) + 1.5);\n    return HSLtoRGB(hsl);\n}\n\nvec3 image5(vec3 rgb) {\n    // Round-trip RGB->HSL->RGB and display exaggerated errors\n    vec3 hsl = RGBtoHSL(rgb);\n    return abs(rgb - HSLtoRGB(hsl)) * 10000000.;\n}\n\n// HSV\n\nvec3 image6(vec3 rgb) {\n    // Round-trip RGB->HSV->RGB with time-dependent lightness\n    vec3 hsv = RGBtoHSV(rgb);\n    hsv.y = clamp(hsv.y * (1. + sin(iTime * 1.5)), 0., 1.);\n    return HSVtoRGB(hsv);\n}\n\nvec3 image7(vec3 rgb) {\n    // Round-trip RGB->HSV->RGB with time-dependent value\n    vec3 hsv = RGBtoHSV(rgb);\n    hsv.z = pow(hsv.z, sin(iTime) + 1.5);\n    return HSVtoRGB(hsv);\n}\n\nvec3 image8(vec3 rgb) {\n    // Round-trip RGB->HSV->RGB and display exaggerated errors\n    vec3 hsv = RGBtoHSV(rgb);\n    return abs(rgb - HSVtoRGB(hsv)) * 10000000.;\n}\n\n// sRGB\n\nvec3 SRGBtoRGB(vec3 srgb) {\n    // See http://chilliant.blogspot.co.uk/2012/08/srgb-approximations-for-hlsl.html\n    // This is a better approximation than the common \"pow(rgb, 2.2)\"\n    return pow(srgb, vec3(2.1632601288));\n}\n\nvec3 RGBtoSRGB(vec3 rgb) {\n    // This is a better approximation than the common \"pow(rgb, 0.45454545)\"\n    return pow(rgb, vec3(0.46226525728));\n}\n\nvec3 image(int panel, vec2 uv) {\n    // 取纹理像素\n    vec3 rgb = SRGBtoRGB(texture(iChannel0, uv).rgb);\n    switch (panel) {\n        case 0: return RGBtoSRGB(image0(rgb));\n        case 1: return RGBtoSRGB(image1(rgb));\n        case 2: return RGBtoSRGB(image2(rgb));\n        case 3: return RGBtoSRGB(image3(rgb));\n        case 4: return RGBtoSRGB(image4(rgb));\n        case 5: return RGBtoSRGB(image5(rgb));\n        case 6: return RGBtoSRGB(image6(rgb));\n        case 7: return RGBtoSRGB(image7(rgb));\n        case 8: return RGBtoSRGB(image8(rgb));\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float ROWS = 2.;  // 3行\n    const float COLUMNS = 2.;  // 3列\n    const float GAP = 0.05;    // 每列间隔\n    //\n    // \t+---+---+---+\n    // \t| 6 | 7 | 8 |\n    // \t+---+---+---+\n    // \t| 3 | 4 | 5 |\n    // \t+---+---+---+\n    // \t| 0 | 1 | 2 |\n    // \t+---+---+---+\n    //\n    vec3 srgb = vec3(0.1);  // 间隔线颜色\n    vec2 uv = fragCoord / iResolution.xy; // uv坐标 值范围未0～1\n    uv.x -= (1. - COLUMNS / ROWS) * 0.5; // 中心坐标 进行uv.x点中心坐标平移   -0.5～0.5\n    uv = uv * (ROWS + GAP) - GAP;        // 进行坐标映射缩放 ROWS倍\n    // 获取是否在间隔线点坐标  把uv强制从x点坐标0～1映射到 0～ROWS   y点坐标0～1映射到 0～COLUMNS\n    if ((uv.x >= 0.) && (uv.y >= 0.) && (uv.x < COLUMNS))\n    {\n        // 流水线的处理像素点（vexcotr）\n        ivec2 iuv = ivec2(uv); \n        // 本次要处理的vu点  fract(uv)取uV点小数部分 映射到0～（1+GAP）\n        uv = fract(uv) * (1. + GAP);  \n        // 只有在0～1之间可以进行绘制，在1～GAP之间不进行图像取纹理绘制\n        if (max(abs(uv.x), abs(uv.y)) < 1.)\n        {\n\t        int panel = iuv.x + iuv.y * int(COLUMNS); // 要处理第几个面板\n            srgb = image(panel, uv);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(srgb, 1);\n}","name":"Image","description":"","type":"image"}]}