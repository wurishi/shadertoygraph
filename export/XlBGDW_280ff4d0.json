{"ver":"0.1","info":{"id":"XlBGDW","date":"1428861950","viewed":2088,"name":"Raymarch Tutorial2","username":"Daedelus","description":"Loads of comments in simple framework to explain raymarching to some friends..","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["raymarchsimpletutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\na shader executes per pixel\nso every thing you see here is he function for every pixel\n\nraymarching is in principe a function that finds the closest point to any surface in the world\nthen we move our point by that distance and use the same function,\nthe function will probably be closer to an object in the world every time\nand after about 40 to 200 iterations you'll either have found an object or\nmissed them all into infinity\n\nraymarching is not raytracing, a raytracer intersects the world in 1 function\nwhen marching the 'scene' function only computes the distance to the current ray 'position'\nit does not know which direction we are moving, the main loop moves the ray instead\n\nthis is much cheaper because intersection maths are not hardware supported in a GPU\n*/\n\n// these constants are used throughout the shader, \n// they can be altered to avoid glitches or optimize the framerate,\n// their meaning can best be seen in context below\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 40.0\n#define NUMBER_OF_MARCH_STEPS 100\n#define EPSILON 0.0001\n#define DISTANCE_BIAS 0.7\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\nvec2 scene(vec3 position)\n{\n    /*\n\tThis function generates a distance to the given position\n\tThe distance is the closest point in the world to that position\n\t*/\n    // to move the sphere one unit forward, we must subtract that translation from the world position\n    vec3 translate = vec3(0.0, -0.5, 1.0);\n    float distance = sdSphere(position - translate, 0.5);\n\tfloat materialID = 1.0;\n    \n    translate = vec3(0.0, 0.5, 1.0);\n    // A power of raymarching is tiling, we can modify the position in any way we want\n    // leaving the shape as is, creating various results\n    // So let's tile in X with a sine wave offset in Y!\n    vec3 sphere_pos = position - translate;\n    // Because our sphere starts at 0 just tiling it would cut it in half, with\n    // the other half on the other side of the tile. SO instead we offset it by 0.5\n    // then tile it so it stays in tact and then do -0.5 to restore the original position.\n    // When tiling by any tile size, offset your position by half the tile size like this!\n    sphere_pos.x = fract(sphere_pos.x + 0.5) - 0.5; // fract() is mod(v, 1.0) or in mathemathical terms x % 1.0\n    sphere_pos.z = fmod(sphere_pos.z + 1.0, 2.0) - 1.0; // example without fract\n    // now let's animate the height!\n    sphere_pos.y += sin(position.x + iTime) * 0.35; //add time to animate, multiply by samll number to reduce amplitude\n    sphere_pos.y += cos(position.z + iTime);\n    float distance2 = sdSphere(sphere_pos, 0.25);\n\tfloat materialID2 = 2.0; // the second sphere should have another colour\n    \n    // to combine two objects we use the minimum distance\n    if(distance2 < distance)\n    {\n\t\tdistance = distance2;\n        materialID = materialID2;\n    }\n    \n    // we return a vec2 packing the distance and material of the closes object together\n    return vec2(distance, materialID);\n}\n\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    /*\n\tThis function iteratively analyses the scene to approximate the closest ray-hit\n\t*/\n    // We track how far we have moved so we can reconstruct the end-point later\n    float total_distance = NEAR_CLIPPING_PLANE;\n    vec2 result;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        result = scene(position + direction * total_distance);\n        // If our ray is very close to a surface we assume we hit it\n        // and return it's material\n        if(result.x < EPSILON)\n        \tbreak;\n        \n        // Accumulate distance traveled\n        // The result.x contains closest distance to the world\n        // so we can be sure that if we move it that far we will not accidentally\n        // end up inside an object. Due to imprecision we do increase the distance\n        // by slightly less... it avoids normal errors especially.\n        total_distance += result.x * DISTANCE_BIAS;\n        \n        // Stop if we are headed for infinity\n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    // By default we return no material and the furthest possible distance\n    // We only reach this point if we didn't get close to a surface during the loop above\n    return vec2(total_distance, result.y);\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Given the pixel X, Y coordinate and the resolution we can get 0-1 UV space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Our rays should shoot left and right, so we move the 0-1 space and make it -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Last we deal with an aspect ratio in the window, to make sure our results are square\n    // we must correct the X coordinate by the stretching of the resolution\n    uv.x *= iResolution.x / iResolution.y;\n    // Now to conver the UV to a ray we need a camera origin, like 0,0,0; and a direction\n    // We can use the -1 to 1 UVs as ray X and Y, then we make sure the direction is length 1.0\n    // by adding a Z component. Code blow is just an example:\n    //float sqr_length = dot(uv, uv);\n    //vec3 direction = vec3(uv, sqrt(1.0 - sqr_length));\n    \n    // a shorter and easier way is to create a vec3 and normalise it, \n    // we can manually change the Z component to change the final FOV; \n    // smaller Z is bigger FOV\n    vec3 direction = normalize(vec3(uv, 2.5));\n    // if you rotate the direction with a rotatin matrix you can turn the camera too!\n    \n    vec3 camera_origin = vec3(0.0, 0.0, -2.5); // you can move the camera here\n    \n    vec2 result = raymarch(camera_origin, direction); // this raymarches the scene\n    \n    // arbitrary fog to hide artifacts near the far plane\n    // 1.0 / distance results in a nice fog that starts white\n    // but if distance is 0 \n    float fog = 1.0 - result.x / FAR_CLIPPING_PLANE;\n    \n    // now let's pick a color\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == 1.0)\n    {\n        materialColor = vec3(1.0, 0.25, 0.1);\n    }\n    if(result.y == 2.0)\n    {\n       \tmaterialColor = vec3(0.7, 0.7, 0.7);\n    }\n    \n    // We can reconstruct the intersection point using the distance and original ray\n    vec3 intersection = camera_origin + direction * result.x;\n    \n    // The normals can be retrieved in a fast way\n    // by taking samples close to the end-result sample\n    // their resulting distances to the world are used to see how the surface curves in 3D\n    // This math I always steal from somewhere ;)\n    vec3 nrml = normal(intersection, 0.01);\n    \n    // Lambert lighting is the dot product of a directional light and the normal\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    // Wrap the lighting around\n    // https://developer.valvesoftware.com/wiki/Half_Lambert\n    diffuse = diffuse * 0.5 + 0.5;\n    // For real diffuse, use this instead (to avoid negative light)\n    //diffuse = max(0.0, diffuse);\n    \n    // Combine ambient light and diffuse lit directional light\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n\tfragColor = vec4(diffuseLit, 1.0) * fog; /* applying the fog last */\n}\n\n/*\nNow that was pretty complex.\nI have omitted transparency and volumetric objects\n*/","name":"Image","description":"","type":"image"}]}