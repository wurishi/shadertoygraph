{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 state = texture(iChannel0, uv);\n    float u = state.x;\n    \n    // Note that the colors are scaled and gamma applied in order to bring out small amplitudes.\n    // In reality, the reflections may be a bit more damped than they appear here.\n    fragColor = vec4(pow(abs(u), 2.0) * (u > 0.0 ? vec3(1,0.3,0) : vec3(0,0.3,1)), 1);\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.454));\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const float PML_WIDTH = 12.0; // pixels\nconst float PML_EXPONENT = 2.0;\nconst float PML_STRENGTH = 1.0;\nconst float OSCILLATOR_STRENGTH = 4.0;\nconst float OSCILLATOR_WAVELENGTH = 8.0; // pixels\nconst float C = 1.0;\nconst float DT = 0.5;\nconst float DX = 1.0;\n\nconst float PI = 3.14159265358979;\n\nfloat linearstep (float a, float b, float x) {\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// A layer that fades from 0 to 1 near the edges of the domain\nvec2 sigma (vec2 coord, vec3 res) {    \n    return pow(\n        vec2(\n            linearstep(PML_WIDTH, 0.0, coord.x) + linearstep(res.x - PML_WIDTH, res.x, coord.x),\n            linearstep(PML_WIDTH, 0.0, coord.y) + linearstep(res.y - PML_WIDTH, res.y, coord.y)\n        ),\n        vec2(PML_EXPONENT)\n    ) * PML_STRENGTH;\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define U(i ,j) (texelFetch(iChannel0, p + ivec2(i, j), 0).x)\n#define VX(i, j) (texelFetch(iChannel1, p + ivec2(i, j), 0).x)\n#define VY(i, j) (texelFetch(iChannel1, p + ivec2(i, j), 0).y)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 p = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel0, p, 0);\n    float u = state.x, psi = state.y;\n    \n    // Compute dv_x/dx and dv_y/dy\n    float dvxdx = (VX(1, 0) - VX(-1, 0)) / (2.0 * DX);\n    float dvydy = (VY(0, 1) - VY(0, -1)) / (2.0 * DX);\n\n    vec2 s = sigma(fragCoord, iResolution);\n    \n    // Update u, psi, and t\n    fragColor.xy = state.xy + DT * vec2(\n        C * (dvxdx + dvydy) - u * (s.x + s.y) + psi,\n        C * (s.x * dvydy + s.y * dvxdx - u * s.x * s.y)\n    );\n    \n    const int N = 48;\n    float omega = C * PI / OSCILLATOR_WAVELENGTH;\n    float t = float(iFrame) * DT;\n    vec2 p1 = iMouse.z > 0.0 ? iMouse.xy : iResolution.xy * vec2(0.8, 0.5);\n\n\n    for (int i = 0; i < N; i++) {\n        vec2 p0 = iResolution.xy * vec2(0.05, 0.5 + 0.5 * (float(i) - float(N - 1) / 2.0) / float(N - 1));\n                \n        float dr = length(p1 - p0);\n        float dt = dr / C;\n        \n        fragColor.x += 20.0 / float(N) * smoothstep(3.0, 1.0, length(vec2(p) - p0)) * sin(omega * (t + dt));\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define U(i ,j) (texelFetch(iChannel0, p + ivec2(i, j), 0).x)\n#define VX(i, j) (texelFetch(iChannel1, p + ivec2(i, j), 0).x)\n#define VY(i, j) (texelFetch(iChannel1, p + ivec2(i, j), 0).y)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 p = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, p, 0);\n    vec2 v = state.xy;\n    \n    // Compute âˆ‡u = (du/dx, du_dy)\n    vec2 ugrad = vec2(U(1, 0) - U(-1, 0), U(0, 1) - U(0, -1)) / (2.0 * DX);\n\n    vec2 s = sigma(fragCoord, iResolution);\n    \n    // Update (v_x, v_y)\n    fragColor.xy = state.xy + DT * (C * ugrad - s * v);\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"43tcRH","date":"1734751424","viewed":70,"name":"Beamforming test 1","username":"rreusser","description":"A test of beamforming using (completely unnecessary) numerical simulation of the 2D wave equation with PML absorbing boundaries. Click to move the focus.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["waves"],"hasliked":0,"parentid":"","parentname":""}}