{"ver":"0.1","info":{"id":"tdVfz1","date":"1606775383","viewed":79,"name":"mountain generation","username":"triangle_z","description":"procedural_generation","likes":1,"published":1,"flags":16,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEST 1\n\n#if TEST == 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,1.0,0.0,1.0) ;\n}\n\n#elif TEST == 1\n\n/*#define KEY_A 65.0\n#define KEY_1 49.0\n#define KEY_RIGHT_ARROW 39.0\n\nbool isPressed(in float keyCode, inout vec3 camera) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}*/\n\nvec2 hash( vec2 p ) \n{\n   p = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n\n   return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n   vec2 i = floor( p + (p.x+p.y)*K1 );\n   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n   vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n   vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)),\n                          dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridgedNoise( in vec2 p )\n{\n    return 2.0 * (0.5 - abs(0.5 - noise(p))) ;\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase,\n                 in float attenuation, in int noctave)\n{\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridgedNoise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\nconst int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   float x = p.x * cos(a) + p.z * sin(a) ;\n   float y = p.y ;\n   float z = -p.x * sin(a) + p.z * cos(a) ;\n   return vec3(x, y, z) ;\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n   float x = p.x * cos(a) + p.z * sin(a) ;\n   float y = -p.x * sin(a) + p.y * cos(a) ;\n   float z = p.z ;\n   return vec3(x, y, z) ;\n}\n\n// Potential field of the object\n// p : point\nfloat terrain(vec3 p)\n{\n   vec2 pos = vec2(p.x, p.z) ;\n   \n   float y = turbulence(pos,1.2, 0.08, 0.5,11) ;\n   \n   return y - p.y ;\n}\n\nfloat water(vec3 p){\n   float A1 = 0.1 ;\n   float w1 = 0.3 ;\n   float B  = -0.5 ;\n   float A2 = 0.1 ;\n   float w2 = 1. ;\n   float waterLevel = A1 * sin(w1 * iTime) + B + \n       A2 * sin(w2 * (p.x + p.y + iTime)) ;\n   //float waterLevel = B + A1 * sin(w1 * iTime) *\n   //    sin(w2 * (p.x + p.y + iTime)) ;\n   return waterLevel - p.y ;\n}\n\nfloat rainbow(vec3 p){\n    \n    return -1.0 ;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = terrain(p);\n   n.x = terrain( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = terrain( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = terrain( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool hitTerrain, out int s, out bool eau)\n{\n   hitTerrain = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = terrain(p);\n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         hitTerrain = true;\n         eau = false ;\n         break;\n      }  \n      else\n      {\n          float ve = water(p) ;\n          if (ve > 0.0)\n        {\n          s = i ;\n          hitTerrain = true;\n          eau = true ;\n          break ;\n         }\n        }\n      // Move along ray\n      t += max(Epsilon,-v/2.0);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n   return mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, int s, bool eau)\n{\n   // point light\n   const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n   const vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0+dot(n, l));\n   \n   vec3 cBase = vec3(0.498 * p.y + 0.502, 0.973 * p.y, 0.863 * p.y) ;\n   float m = 0.50 ;\n   float modulo = mod(p.y, m) ;\n   if(modulo < 0.05) cBase = vec3(0.0, 0.0, 0.0) ;\n    \n   if(eau) cBase = vec3(0.0,0.5,1.0) ;\n\n   vec3 c = 0.5*cBase+0.5*diff*lightColor;\n   float fog = 0.7*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n       \n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 1.0, 0.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a = mouse.x * 3.14 * 2.0 - 1.5 ;//iTime*0.25;\n   float b = -mouse.y * 4. * 2. ;\n   rd = vec3(rd.x, rd.y+b, rd.z);\n   //rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   ro = rotateY(ro, a);\n   rd = rotateY(rd, a);\n   //ro = rotateZ(ro, b);\n   //rd = rotateZ(rd, b);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n   \n   bool eau ;\n   float t = Trace(ro, rd, hit,s, eau);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = Shade(pos, n, s, eau);\n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}