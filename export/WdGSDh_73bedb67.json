{"ver":"0.1","info":{"id":"WdGSDh","date":"1573845276","viewed":240,"name":"Triangular Tiling Double Weave","username":"fizzer","description":"Alternative title: \"Spaghetti Mess\"","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["tiling","regular","weave","spaghetti"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is similar to my other weaved patterns (https://www.shadertoy.com/view/WsyXWR and https://www.shadertoy.com/view/3dVSRm)\n// but the tiling here is a regular equilateral triangle tiling.\n// Multiple connections are made for each side, so to make the tangents match up I needed to use two\n// quadratic bezier curves.\n\nconst float pi = 3.141592653589;\n\n\n// From IQ: https://www.shadertoy.com/view/MlKcDD\n// signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n\n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n\n    return res;\n}\n\n\n// Based on https://www.shadertoy.com/view/llGSzw\nuint hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nconst uint ccount=(1U<<2U);\n\nvec2 tripos(uint i)\n{\n    uint side = i / ccount;\n    uint x = i % ccount;\n    float th = pi * 2. / 3.;\n    vec2 p0 = vec2(sin(th * float(side + 0U)), -cos(th * float(side + 0U))) / 1.5;\n    vec2 p1 = vec2(sin(th * float(side + 1U)), -cos(th * float(side + 1U))) / 1.5;\n    return mix(p0, p1, (float(x) + 1.5) / float(ccount+1U));\n}\n\nvec2 trinor(uint i)\n{\n    uint side = i / ccount;\n    float th = pi * 2. / 3.;\n    return vec2(sin(th * float(side) + th / 2.), -cos(th * float(side) + th / 2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 4.5 + iMouse.xy / iResolution.xy * 10.;\n\n    // Pixel width for anti-aliasing.\n    float w = max(length(dFdx(p)), length(dFdy(p))) / 2.;\n\n    p.x += iTime / 3.;\n\n    float s = 1. / sqrt(3.);\n\n    vec2 op = p;\n\n    p.x /= s;\n    p.x += mod(floor(p.y), 2.);\n\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    if(fp.x > mix(fp.y, 1. - fp.y, mod(ip.x, 2.)))\n        ip.x += 1.;\n\n    fp = p - ip;\n\n    fp.x *= s;\n    fp.y -= 1. / 3. + mod(ip.x + 1., 2.) / 3.;\n\n\n    if(mod(ip.x, 2.) > .5)\n        fp.y =- fp.y;\n\n    float th = pi * 2. / 3.;\n\n    // Shuffle the indices by using the Fisher-Yates algorithm\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\n    uint inds[3U*ccount];\n\n    inds[0] = 0U;\n\n    uint seed = uint(ip.x + ip.y * 8192.)*319U;\n    for(uint j = 1U; j < uint(inds.length()); ++j)\n    {\n        seed = hash1(seed);\n        uint k = seed % j;\n        uint temp = inds[k];\n        inds[k] = j;\n        inds[j] = temp;\n    }\n\n    vec3 backg = vec3(1., .25, .1);\n\n    fragColor.b=0.;\n    fragColor.rgb=backg;\n\n    float overlaydist = 1e4;\n    float overlaydist2 = 1e4;\n    \n    if(iMouse.z > .5)\n    {\n        overlaydist2 = min(overlaydist2, abs(dot(fp, vec2(0,1))-1./3.) - .01 );\n        overlaydist2 = min(overlaydist2, abs(dot(fp, vec2(sin(th),cos(th)))-1./3.) - .01 );\n        overlaydist2 = min(overlaydist2, abs(dot(fp, vec2(-sin(th),cos(th)))-1./3.) - .01 );\n    }\n    \n    for(uint j = 0U; j < uint(inds.length()); j += 2U)\n    {\n        seed = hash1(seed);\n        vec2 a = tripos(inds[j + 0U]);\n        vec2 b = tripos(inds[j + 1U]);\n\n        if(iMouse.z > .5)\n        {\n            overlaydist = min(overlaydist, length(fp - a) - .04);\n            overlaydist = min(overlaydist, length(fp - b) - .04);\n        }\n        \n        float thickness = .02;\n        float dist;\n        if((hash1(seed) % 19U) == 0U)\n        {\n            dist = min(length(fp-a), length(fp-b));\n        }\n        else\n        {\n            vec2 na = normalize(trinor(inds[j + 0U]));\n            vec2 nb = normalize(trinor(inds[j + 1U]));\n\n            float basedist = distance(a, b);\n            float len = basedist / (1. + dot(normalize(b - a), na) * 8.);\n\n            vec2 c = a + na * -.15;\n            vec2 d = b + nb * -.15;\n\n            dist = min(sdBezier(fp, a, c, (c + d) / 2.), sdBezier(fp, (c + d) / 2., d, b));\n        }\n        \n        float alpha = 1. - smoothstep(-w, +w, dist - thickness - .02);\n\n        vec3 col = mix(vec3(1, 1, .5), vec3(.4, .1, .05), smoothstep(-w, +w, dist - thickness));\n        fragColor.rgb = mix(fragColor.rgb, col, alpha);\n    }\n\n    if(iMouse.z > .5)\n    {\n    \tfragColor.rgb = mix(vec3(1.-smoothstep(-w,w,overlaydist2)), fragColor.rgb/3., smoothstep(-w,w, overlaydist2-.02));\n    \tfragColor.rgb = mix(vec3(1.-smoothstep(-w,w,overlaydist)), fragColor.rgb, smoothstep(-w,w, overlaydist-.02));\n    }\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n    return;\n}\n","name":"Image","description":"","type":"image"}]}