{"ver":"0.1","info":{"id":"ftsXDj","date":"1626590119","viewed":86,"name":"Blub blub","username":"zheck","description":"Trying out some smooth min with (I'm sure some redundant) code from a previous project. I know there is a lot to pick apart about this code (why am I defining the positions of my spheres in two separate locations???)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymatch","smoothmin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPEED 0.5\n#define BLEND_STRENGTH 0.55\n#define SPHERE_ONE_SIZE 0.5\n#define SPHERE_TWO_SIZE 0.25\n#define PI 3.14159265359\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat smoothMin(float dstA, float dstB, float k)\n{\n    float h = max(k-abs(dstA-dstB), 0.0) / k;\n    return min(dstA, dstB) - h*h*h*k*1.0/6.0;\n}\n\nfloat mapObjects( in vec3 position )\n{\n    float modifiedSpeed = iTime * SPEED;\n    vec3 sphere1 = vec3(0.,0.,0.);\n    vec3 sphere2 = vec3(sin(modifiedSpeed),sin(modifiedSpeed),0.);\n    \n    float sphere1Distance = sphere(position + sphere1, SPHERE_ONE_SIZE);\n    float sphere2Distance = sphere(position + sphere2, SPHERE_TWO_SIZE);\n    \n    return smoothMin( sphere1Distance, sphere2Distance, BLEND_STRENGTH);\n}\n\n\nfloat raycast( in vec3 rayOrigin, in vec3 rayDirection, in float searchLimit )\n{\n    float t = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 position = rayOrigin + t * rayDirection;\n        \n        float hitObject = mapObjects(position); \n\n        if( hitObject < 0.001 )\n           break;   \n        \n        t += hitObject;\n        if( t > searchLimit )\n           break;\n    }   \n    if( t > searchLimit )\n        t = 0.0;\n    return t;\n}\n\n\nvec3 calculateNormal( in vec3 position )\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(mapObjects(position+e.xyy)-mapObjects(position-e.xyy),\n                          mapObjects(position+e.yxy)-mapObjects(position-e.yxy),\n                          mapObjects(position+e.yyx)-mapObjects(position-e.yyx) ) );\n}\n\nvec3 collisionPointColor( in vec3 position )\n{\n    vec3 sphere1Color = vec3(0., .0, 1.);\n    vec3 sphere2Color = vec3(1., .0, .0);\n    vec3 returnCol = vec3(0.);\n    \n    float modifiedSpeed = iTime * SPEED;\n    vec3 sphere1 = vec3(0.,0.,0.);\n    vec3 sphere2 = vec3(sin(modifiedSpeed),sin(modifiedSpeed),0.);\n    \n    returnCol += sphere1Color * sphere(position + sphere1, SPHERE_ONE_SIZE);\n    returnCol += sphere2Color * sphere(position + sphere2, SPHERE_TWO_SIZE);\n    return returnCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Push viewport space from 0 -> 1 to -1 -> 1\n    vec2 uv = ( 2.0 * fragCoord - iResolution.xy ) / min( iResolution.x, iResolution.y);\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    if( mouseUV == vec2(0.)) mouseUV = vec2(.5);\n\n    vec3 rayOrigin = vec3(0., 0., 1.5);\n    rayOrigin.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n    rayOrigin.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n    \n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 cameraForward = normalize(cameraTarget - rayOrigin);\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n    \n    vec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + cameraForward);\n    \n    float searchLimit = 10.0;\n    float t = raycast( rayOrigin, rayDirection, searchLimit );\n    \n    vec3 color = texture(iChannel0, rayDirection).xyz;\n    \n    if( t > 0.0)\n    {\n        vec3 collisionPoint = rayOrigin + t * rayDirection;\n        vec3 normalAtCollision = calculateNormal( collisionPoint );\n        color = collisionPointColor(collisionPoint);\n        \n        color *= dot(-normalAtCollision, rayDirection);\n        color = sqrt(color);\n        color *= mix(texture(iChannel0, reflect(rayDirection, normalAtCollision)).xyz, color, (sin(iTime * SPEED) + 1. ) * 0.5);\n\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}