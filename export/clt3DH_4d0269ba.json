{"ver":"0.1","info":{"id":"clt3DH","date":"1682364017","viewed":58,"name":"Scanner Darkly shader","username":"JaminV","description":"toon style shader\nbest viewed on fullscreen","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//applies a mean or median filter for smothing\n\n//resources used: \n//http://blog.geveo.com/Image-Smoothing-Algorithms\n\n#define LISTSIZE 9\n\nfloat medianFunc(float list[LISTSIZE]){\n\n    for(int i=0; i<LISTSIZE-1; i++)\n    {\n        if (list[i] > list[i + 1])\n        {\n            // Swapping the elements.\n            float temp = list[i];\n            list[i] = list[i + 1];\n            list[i + 1] = temp;\n             \n            i = -1;\n        }\n    }\n    //return median\n    return(list[LISTSIZE/2]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    float offset = 1.;\n\n    //get neighboring normalized coordinates\n    vec2 uvUp        = (fragCoord+(0.,offset))/iResolution.xy;\n    vec2 uvDown      = (fragCoord-(0.,offset))/iResolution.xy;\n    vec2 uvLeft      = (fragCoord-(offset,0.))/iResolution.xy;\n    vec2 uvRight     = (fragCoord+(offset,0.))/iResolution.xy;\n    vec2 uvUpRight   = (fragCoord+(offset,offset))/iResolution.xy;\n    vec2 uvUpLeft    = (fragCoord+(-offset,offset))/iResolution.xy;\n    vec2 uvDownRight = (fragCoord+(offset,-offset))/iResolution.xy;\n    vec2 uvDownLeft  = (fragCoord-(offset,offset))/iResolution.xy;\n\n    vec4 colList[LISTSIZE];\n    //get neighboring colors\n    colList[0] = col;\n    colList[1] = texture(iChannel0, uvUp);\n    colList[2] = texture(iChannel0, uvDown);\n    colList[3] = texture(iChannel0, uvLeft);\n    colList[4] = texture(iChannel0, uvRight);\n    colList[5] = texture(iChannel0, uvUpRight);\n    colList[6] = texture(iChannel0, uvUpLeft);\n    colList[7] = texture(iChannel0, uvDownRight);\n    colList[8] = texture(iChannel0, uvDownLeft);\n\n    //Change these values to compare between mean, median or no smoothing\n    bool isSmooth   = false; //true = turn on smoothing\n    bool smoothMean = false;  //true = turn on mean, false = turn on median \n\n    //mean filter\n    if(isSmooth && smoothMean){\n        vec3 colTotal = vec3(0.,0.,0.);\n        for(int i=0;i<LISTSIZE;i++){\n            colTotal += colList[i].xyz;\n        }\n        //find mean of values\n        col.xyz = colTotal/float(LISTSIZE);\n    }\n\n    //median filter\n    if(isSmooth && !smoothMean){\n\n        //divide rgb values\n        float colListR[LISTSIZE];\n        float colListG[LISTSIZE];\n        float colListB[LISTSIZE];\n\n        for(int i=0;i<LISTSIZE;i++){\n            colListR[i] = colList[i].x;\n            colListG[i] = colList[i].y;\n            colListB[i] = colList[i].z;\n        }\n\n        col.x = medianFunc(colListR)/1.;\n        col.y = medianFunc(colListG)/1.;\n        col.z = medianFunc(colListB)/1.;\n    }\n\n    \n    fragColor = col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//applies toon effect by adding black edges and cell shading\n\n//resources used: \n//https://cse.usf.edu/~r1k/MachineVisionBook/MachineVision.files/MachineVision_Chapter5.pdf\n//https://en.wikipedia.org/wiki/Cel_shading\n\nfloat rounder(float colValue, float closestVal){\n    \n    //increse counter until greater than or equal to colValue\n    for(float counter=0.; counter<1.; counter+=closestVal){\n        if(counter >= colValue){\n            return(counter);\n        }\n    }\n    return(colValue);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //get current color value from input\n    vec4 col = texture(iChannel0, uv);\n    \n    \n    //edge detection\n    \n    bool toon = true;\n    \n    if(toon == true){\n        //increase value for increasing neighbor range\n        float offset = 5.;\n\n        //get neighboring normalized coordinates\n        vec2 uvUp    = (fragCoord+(0.,offset))/iResolution.xy;\n        vec2 uvDown  = (fragCoord-(0.,offset))/iResolution.xy;\n        vec2 uvLeft  = (fragCoord-(offset,0.))/iResolution.xy;\n        vec2 uvRight = (fragCoord+(offset,0.))/iResolution.xy;\n       \n        //get neighboring colors\n        vec4 colUp    = texture(iChannel0, uvUp);\n        vec4 colDown  = texture(iChannel0, uvDown);\n        vec4 colLeft  = texture(iChannel0, uvLeft);\n        vec4 colRight = texture(iChannel0, uvRight);\n\n        //calculate gradient\n        vec4 Gradient = abs(colUp-colDown) + abs(colLeft-colRight);\n\n        //decrease value to increase sensitivity of detecting an edge\n        float margin = 0.2;\n\n        //check if edge is detected\n        if(Gradient.x > margin || Gradient.y > margin || Gradient.z > margin){\n            //add black outline when significant edge is found\n            col = vec4(0., 0., 0., 1.);\n        }\n            \n        \n    }\n    \n    //round color to closestValue to mimic a cel shading effect\n    float closestVal = 0.1;\n    col.x = rounder(col.x, closestVal);\n    col.y = rounder(col.y, closestVal);\n    col.z = rounder(col.z, closestVal);\n\n    //Output to screen\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}