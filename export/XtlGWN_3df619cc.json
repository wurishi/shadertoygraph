{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//by ethan shulman\n//some distance functions/equations taken from iq's site https://iquilezles.org/articles/distfunctions\n\n\nconst float lightDist = 18.0;\nconst float lightAtten = 1.5;\nvec3 lightPos = vec3(0.0,2.0,0.0);\nconst vec3 lightDiff = vec3(1.2,0.95,0.7);\nconst vec3 lightAmb = vec3(0.11,0.16,0.15);\n\nconst float viewDist = 100.0;\n\nconst float EPILSON = 0.002;\nconst int maxIter = 128;\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\nvec3 rayPos;\nvec3 startRayPos,startRayDir;\n\n\nvec3 calcNormal(vec2 center) {\n    return normalize(vec3(center.x-rayPos.x,0.0,center.y-rayPos.z));\n}\n\n\nfloat column(vec2 pos, float radius) {\n    float disp = 0.0;\n    disp = (sin(rayPos.y*10.0)+1.0)*0.02 +\n        (sin(rayPos.x*10.0)+1.0)*0.02;\n    \n    return abs(length(pos-rayPos.xz)-radius)-disp;\n}\n\nvec3 pos;\n\nfloat statue() {\n    pos = rayPos-vec3(0.0,-3.0,0.0);\n    vec3 boxExt = vec3(1.0,2.0,1.0);\n    \n    float boxDist = length(max(abs(pos)-boxExt,0.0));\n     \n    vec2 q = vec2(length(pos.xz)-1.5,pos.y);\n  \tfloat torusDist = length(q)-0.5;\n    \n    float sphereDist = length(rayPos-vec3(0.0,-1.8,0.0))-1.2;\n\t   \n     float disp = 0.0;\n    disp = (sin(rayPos.y*10.0)+1.0)*0.01 +\n        (sin(rayPos.x*10.0)+1.0)*0.01;\n    \n    return max(-torusDist,max(boxDist,-sphereDist))-disp;\n}\n\n\nfloat flame() {    \n\tpos = lightPos-rayPos;\n   \n    float am = sin(20.0*pos.x)*cos(20.0*pos.y)*sin(20.0*pos.z); \n    \n    return abs(length(pos)-0.4)-abs(am*0.1);\n}\n\nconst vec3 waterBaseNormal = vec3(0.0,1.0,0.0);\nfloat water() {\n    float h = -5.0;\n    \n    return abs(h-rayPos.y);\n}\n\n\n\nconst vec2 col1 = vec2(4.15,4.2);\nconst vec2 col2 = vec2(4.05,-4.15);\nconst vec2 col3 = vec2(-4.08,-4.08);\nconst vec2 col4 = vec2(-4.1,4.12);\n\n\nfloat sceneDist() {\n    float d;\n    \n    //4 center columns\n    d = column(col1,1.0);\n    d = min(d,column(col2,1.0));\n    d = min(d,column(col3,1.0));\n    d = min(d,column(col4,1.0));\n    \n    //statue\n    d = min(d,statue());\n    \n    //outer wall column\n    d = min(d,column(vec2(0.0,0.0),16.0));\n\n   \t//water\n    d = min(d,water());\n    \n\n    return d;\n}\nint sceneId(out vec2 objPos) {//determine what obj was hit and give its id number and center position\n    \n    float d,buf;\n    int id = 0;\n    \n    //inner columns\n    d = column(col1,1.0);\n    objPos = col1;\n    \n    buf = column(col2,1.0);\n    if (buf < d) {\n        d = buf;\n        objPos = col2;\n    }\n    \n    buf = column(col3,1.0);\n    if (buf < d) {\n        d = buf;\n        objPos = col3;\n    }\n    \n    buf = column(col4,1.0);\n    if (buf < d) {\n        d = buf;\n        objPos = col4;\n    }\n    \n    //statue\n    buf = statue();\n    if (buf < d) {\n        d = buf;\n        id = 3;\n    }\n    \n    \n    //outer column\n    buf = column(vec2(0.0,0.0),16.0);\n    if (buf < d) {\n        id = 1;\n        d = buf;\n    }\n    \n    //water\n    buf = water();\n    if (buf < d) {\n        id = 2;\n    }\n\n    \n    return id;\n}\n\n\nfloat trace() {\n    float scal = 0.0,dist = 0.0;\n    \n    for (int i = 0; i < maxIter; i++) {\n        \n        rayPos = startRayPos+startRayDir*scal;\n        \n\t\tdist = sceneDist();\n        if (dist <= EPILSON) {\n            return dist;\n        }\n        \n        scal += dist+EPILSON;\n        if (scal > viewDist) {\n            break;\n        }\n        \n    }\n    \n    return viewDist;\n}\nfloat shadowTrace() {\n    float scal = 0.0,d = 0.0;\n    \n    for (int i = 0; i < maxIter; i++) {\n        \n        rayPos = startRayPos+startRayDir*scal;\n        \n        d = column(col1,1.0);\n        d = min(d,column(col2,1.0));\n        d = min(d,column(col3,1.0));\n        d = min(d,column(col4,1.0));\n        d = min(d,statue());\n    \n        if (d <= EPILSON) {\n            return d;\n        }\n        \n        scal += d+EPILSON;\n        if (scal > viewDist) {\n            break;\n        }\n        \n    }\n    \n    return viewDist;\n}\n\n\nvec3 reflStart,reflDir;\nvec4 color;\n\nvec2 center,uv;\n\nvec3 samp,lightVec,norm;\n\n\nvec4 colorMap() {\n\tint objId = sceneId(center);\n    if (objId == 0) {\n        //inner 4 columns\n        uv = vec2(atan(center.y-rayPos.z,center.x-rayPos.x),rayPos.y);\n        \n        samp = texture(iChannel0,uv).xyz-vec3(0.7,0.5,0.5)+\n            (texture(iChannel1,uv)*0.4).xyz;\n        \n        \n    \tlightVec = lightPos-rayPos;\n        float len = length(lightVec);\n        float t = 1.0-pow(min(len/lightDist,1.0),lightAtten);\n        \n        if (t == 0.0) {\n            return vec4(lightAmb*samp,1.0);\n        } else {  \n            norm = calcNormal(center);\n            \n            lightVec = normalize(lightVec);\n            \n                            return vec4(lightAmb*samp + \n                    max(dot(-lightVec,norm),0.0)*t*lightDiff*samp,1.0);\n        }\n    }\n    if (objId == 1) {\n        //outer wall\n        samp = texture(iChannel0,vec2(atan(rayPos.z,rayPos.x)*12.0,rayPos.y)*0.2).xyz - \n            vec3(0.43,0.35,0.4);//change color\n        \n        //try and hit light\n        lightVec = lightPos-rayPos;\n        float len = length(lightVec);\n        float t = 1.0-pow(min(len/lightDist,1.0),lightAtten);\n        \n        if (t == 0.0) {\n            return vec4(lightAmb*samp,1.0);\n        } else {\n        \n            startRayDir = normalize(lightVec);\n            startRayPos = rayPos+(startRayDir*0.1);\n            float dist = shadowTrace();\n            if (dist >= viewDist || length(startRayPos-rayPos) > len) {\n                return vec4(lightAmb*samp + t*lightDiff*samp,1.0);\n            }\n\n            return vec4(lightAmb*samp,1.0);\n            \n        }\n    }\n    if (objId == 2) {\n        //water\n        \n        samp = texture(iChannel2,rayPos.xz*0.4).xyz;\n                \n        //refract current ray\n        reflDir = refract(reflDir,waterBaseNormal,1.0+(samp.y-0.5)*0.1);\n        \n        samp *= vec3(0.5,1.0,0.86);//tint blue\n        \n        //try and hit light\n        lightVec = lightPos-rayPos;\n        float len = length(lightVec);\n        float t = 1.0-pow(min(len/lightDist,1.0),lightAtten);\n        \n        if (t == 0.0) {\n            return vec4(lightAmb*samp,0.1);\n        } else {\n        \n            startRayDir = normalize(lightVec);\n            startRayPos = rayPos+(startRayDir*0.1);\n            float dist = shadowTrace();\n            if (dist >= viewDist || length(startRayPos-rayPos) > len) {\n                return vec4(lightAmb*samp + \n                            t*lightDiff*samp,\n                            0.1);\n            }\n\n            return vec4(lightAmb*samp,0.1);\n            \n        }\n    }\n    if (objId == 3) {\n        samp = texture(iChannel2,vec2(rayPos.x+rayPos.z,rayPos.y+rayPos.z)).xyz;\n        \n        //try and hit light\n        lightVec = lightPos-rayPos;\n        float len = length(lightVec);\n        float t = 1.0-pow(min(len/lightDist,1.0),lightAtten);\n        \n        if (t == 0.0) {\n            return vec4(lightAmb*samp,1.0);\n        } else {\n        \n            startRayDir = normalize(lightVec);\n            startRayPos = rayPos+(startRayDir*0.05);\n            float dist = shadowTrace();\n            if (dist >= viewDist || length(startRayPos-rayPos) > len) {\n                return vec4(lightAmb*samp + \n                            t*lightDiff*samp,\n                            1.0);\n            }\n\n            return vec4(lightAmb*samp,1.0);\n            \n        }\n    }\n    \n    \n    //couldnt id object apparently?\n    return vec4(0.0);\n}\n\n\nvec4 scene() {\n    \n    trace();\n    reflStart = rayPos;\n    reflDir = startRayDir;\n    \n    color = colorMap();\n    if (color.w != 1.0) {//water blending+reflections\n        /*\n        \n        //reflections\n        startRayDir = reflect(reflDir,waterBaseNormal);\n        startRayPos = reflStart+(startRayDir*0.2);\n        trace();\n        \n        float oldW = color.w;\n        color = mix(colorMap(),color,0.6);\n        color.w = oldW;\n\t\t*/        \n\n\n\t\t//blending\n        startRayPos = reflStart+(reflDir*0.2);\n        startRayDir = reflDir;\n        trace();\n        return mix(colorMap(),color,color.w);\n    }\n    return color;\n}\n\n\nconst float cameraMoveSpeed = 0.2;\n\nconst vec2 CENTER_UV = vec2(0.5,0.5);\n\nbool once = false;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (!once) {\n        //calculate camera\n        cameraPosition = vec3(sin(iTime*cameraMoveSpeed)*10.0,cos(iTime*cameraMoveSpeed)*5.0+7.0,cos(iTime*cameraMoveSpeed)*10.0);\n        cameraDirection = normalize(-cameraPosition);\n\n\n        //camera vectors\n        cameraRight = cross(cameraDirection,cameraUp);\n        cameraUp = cross(cameraRight,cameraDirection);\n    \n    \tonce = true;\n\t}\n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-CENTER_UV;\n    cUv.x *= iResolution.x/iResolution.y;\n    \n    //calculate perspective ray from uv and camera vectors\n    vec3 rPoint = cUv.x*cameraRight +\n                  cUv.y*cameraUp +\n        \t\t  cameraPosition + cameraDirection;\n    \n  \tstartRayDir = normalize(rPoint-cameraPosition);\n    startRayPos = cameraPosition;\n    \n    \n    fragColor = scene();\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XtlGWN","date":"1422250886","viewed":191,"name":"underground shrine","username":"public_int_i","description":"scene i made to mess around with distance functions","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","distance","function","march","ancient","shrine"],"hasliked":0,"parentid":"","parentname":""}}