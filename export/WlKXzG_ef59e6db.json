{"ver":"0.1","info":{"id":"WlKXzG","date":"1583427660","viewed":49,"name":"Taj Mahal","username":"Dombass","description":"a poor mans taj mahal, playing around wit SDFs\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","india","tajmahal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//a lot of these functions are from https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.3;\n}\n\nfloat boxSDF(vec3 a, vec3 b, float r) {\n    return length(max(abs(a)-b, 0.)) - r;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nconst float MAX = 200.;\n\nfloat tower(vec3 p, vec3 o) {\n    return min(sdRoundCone(p+o+vec3(0, -2., 0), 0.25, 0.1, 1.), sdCappedCylinder(p + o, .25, 2.));\n}\n\nfloat scene(in vec3 pos) {\n\tfloat box = boxSDF(pos,vec3(3.5,0.25,3.5), .2);\n    float sphere = sphereSDF(pos);\n    \n    float tower1 = tower(pos, vec3(-3,-2,-3));\n    float tower2 = tower(pos, vec3(3,-2,-3));\n    float tower3 = tower(pos, vec3(3,-2,3));\n    float tower4 = tower(pos, vec3(-3,-2,3));\n\tfloat taj = min(box, min(tower1, min(tower2, min(tower3, tower4))));\n    float floor = sdPlane(pos, vec4(0., 0.9, 0.15, 0.));\n    float scene = min(floor, taj);\n    return scene;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ) );\n}\n\nfloat distToSurf(vec3 eye, vec3 dir) {\n    float start = 0.0f;\n    float depth = start;\n    \n    for (int i = 0; i < 255; i++) {\n        float dist = scene(eye + depth * dir);\n        \n        if (dist < 0.1) return depth;\n        depth += dist;\n        if (depth > MAX) return MAX;\n    }\n    \n    return MAX;\n}\n\n//const vec3 eye = vec3(0, 0, 10);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = vec3(0., 5., 20.0);\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);\n    \n    float dist = distToSurf(eye, rayDir);\n\n    if (dist > (MAX - 0.1)) {\n        // Didn't hit anything\n        fragColor = vec4(0.6, 0.7, 0.8, 0.0);\n\t\treturn;\n    }\n    \n    vec3 lig = normalize( vec3(-0.1, 0.3, 0.6) );\n    vec3 hal = lig - rayDir;\n    \n    vec3 normal = calcNormal(eye + dist*rayDir);\n    \n    float dif = clamp( dot( normal, lig ), 0.0, 1.0 );\n        \n\t\tfloat spe = pow(clamp(dot(normal,hal),0.0,1.0),16.0)*\n                    dif *\n                    (0.04+0.96*pow(clamp(1.0+dot(hal,rayDir),0.0,1.0),5.0));\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //fragColor = texture(iChannel0, uv);\n    vec3 mate = vec3(0.2);//texture(iChannel0, uv).xyz;//vec3(1.);\n    \n    vec3 col = mate * 4.0*dif*vec3(0.8);\n        col +=       9.0*spe*vec3(1., 0.8, 0.7);\n\tfragColor = vec4(col, 1.0);    \n    //fragColor = vec4(dif);\n}","name":"Image","description":"","type":"image"}]}