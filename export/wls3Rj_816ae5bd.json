{"ver":"0.1","info":{"id":"wls3Rj","date":"1556973757","viewed":89,"name":"raymarched 4d grid fork","username":"slerpy","description":"asdf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["asdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"raymarched 4d grid\" by yx\n// https://shadertoy.com/view/3lsGR2\n\nint mat;\nfloat time;\nvec4 rv;\n\nvoid shuffle()\n{\n    rv=fract(1e4*sin(rv)+rv.wxyz);\n}\n\nmat2 R(float a)\n{\n    return mat2(\n        cos(a),-sin(a),\n        sin(a), cos(a)\n    );\n}\n\nvoid rotate(inout vec4 v)\n{\n    float a = 0.06 * time;\n    v.xy*=R(a);\n    v.xw*=R(a);\n    v.yz*=R(a);\n    v.yw*=R(a);\n    v.zx*=R(a);\n    v.zw*=R(a);\n}\n\nvoid translate(inout vec4 v)\n{\n    float t = 0.2 * time;\n    v[int(t)%4] += 3.*cos(acos(-1.)*fract(t));\n}\n\nfloat box(vec3 p, float r)\n{\n    p=abs(p);\n    return max(\n        max(max(p.x,p.y),p.z)-r,\n        abs(length(p)-r*1.2)-.02\n    );\n}\n\nfloat scene(vec4 p)\n{\n    p=mod(p,3.)-1.5;\n    \n    const float r1 = .1;\n    float cxy=length(p.xy)-r1;\n    float cxz=length(p.xz)-r1;\n    float cxw=length(p.xw)-r1;\n    float cyz=length(p.yz)-r1;\n    float cyw=length(p.yw)-r1;\n    float czw=length(p.zw)-r1;\n    \n    const float r2 = .4;\n    float sxyz=box(p.xyz,r2);\n    float sxyw=box(p.xyw,r2);\n    float sxzw=box(p.xzw,r2);\n    float syzw=box(p.yzw,r2);\n    \n    float d1 = min(min(min(cxy,cxz),min(cxw,cyz)),min(cyw,czw));\n    float d2 = min(min(sxyz,sxyw),min(sxzw,syzw));\n    float dx = min(d1, d2);\n    \n    mat = (dx == d1) ? 0 : 1;\n    \n    return dx;\n}\n\nvec4 normal(vec4 p)\n{\n    vec2 o=vec2(.01,0);\n    return normalize(scene(p)-vec4(\n\t\tscene(p-o.xyyy),scene(p-o.yxyy),\n\t\tscene(p-o.yyxy),scene(p-o.yyyx)\n\t));\n}\n\n\nvec4 noise(vec4 p)\n{   \n    p = mod(p, 3.) - 1.5;\n    p = round(3.*p);\n    \n    for(int i=0; i<13; i++)\n        p = fract(1e4*sin(p) + p.wxyz);\n    \n    return p;\n}\n\n/*\nvec4 tex(vec4 p, vec4 n)\n{\n    n *= n;\n    p /= 3.;\n    \n    vec4 acc = vec4(0);\n    acc += n.x * texture(iChannel1, p.yzw);\n    acc += n.y * texture(iChannel1, p.xzw);\n    acc += n.z * texture(iChannel1, p.xyw);\n    acc += n.w * texture(iChannel1, p.xyz);\n    return acc;\n}\n*/\n\n/*\nvec4 tex(vec4 p, vec4 n)\n{\n\tp = mod(p, 3.) - 1.5;\n    n *= n / dot(n,n);\n    vec4 acc = vec4(0);\n    \n    acc += n.x * texture(iChannel0, p.yz);\n    acc += n.x * texture(iChannel0, p.yw);\n    acc += n.x * texture(iChannel0, p.zw);\n    \n    acc += n.y * texture(iChannel0, p.xz);\n    acc += n.y * texture(iChannel0, p.xw);\n   \tacc += n.y * texture(iChannel0, p.zw);\n    \n    acc += n.z * texture(iChannel0, p.xy);\n    acc += n.z * texture(iChannel0, p.xw);\n    acc += n.z * texture(iChannel0, p.yw);\n    \n    acc += n.w * texture(iChannel0, p.xy);\n    acc += n.w * texture(iChannel0, p.yz);\n    acc += n.w * texture(iChannel0, p.xz);\n    \n    return acc / 3.;\n}\n*/\n\n/*\nvec4 tex(vec4 p, vec4 n)\n{\n    p = mod(p, 3.) - 1.5;\n    n *= n / dot(n,n);\n    n += n.wxyz;\n    \n    vec4 acc = vec4(0);\n    acc += n.x * texture(iChannel0, p.yz);\n   \tacc += n.y * texture(iChannel0, p.zw);\n    acc += n.z * texture(iChannel0, p.yw);\n    acc += n.w * texture(iChannel0, p.xy);\n    return acc / 2.;\n}\n*/\n\n\nfloat badao(vec4 p, vec4 n)\n{\n    const float d = 0.35;\n    return pow(max(scene(p+d*n) / d, .0), 1.2);\n}\n\nfloat badsss(vec4 p, vec4 n)\n{\n    const float d = -0.03;\n    return .4+.6*pow(max(scene(p+d*n) / d, .0), .7);\n}\n\nvec4 render(vec2 coord)\n{\n    shuffle();\n    \n    vec2 uv = (coord+rv.xy-.5*iResolution.xy) / iResolution.y;\n    time = iTime + .5 * rv.z * iTimeDelta;\n    \n    float fisheye = .9;\n    if (fisheye != 0.)\n    \tuv = normalize(uv) * tan(asin(length(uv) * fisheye)) / fisheye;\n\n    float a = 0.05 * time;\n    vec2 zw = vec2(cos(a),sin(a));\n    \n    vec4 cam=vec4(0);\n    vec4 dir=normalize(vec4(uv,zw));\n\n    rotate(dir);\n    translate(cam);\n    \n    float k, t=.2;\n    for(int i=0;i<80;++i){\n\t\tt+=k=scene(cam+dir*t);\n        if(k<.01)break;\n    }\n\n    vec4 h=cam+dir*t;\n    vec4 n=normal(h);\n    \n    cam = h;\n    dir = reflect(dir, n);\n    \n    float t2 = .0;\n    for(int i=0;i<40;++i){\n\t\tt2+=k=scene(cam+dir*t);\n        if(k<.05)break;\n    }\n    \n    vec4 col = 4. * pow(.7, t) * badao(h,n) * badsss(h,n) * (noise(h) + pow(.7, t2 + 2.));\n    \n    return pow(clamp(col, .0, 1.), vec4(.454545454545454545454545));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rv = vec4(fragCoord, iFrame, 1);\n    for(int i=0;i<8;i++)shuffle();\n    \n    vec4 acc = vec4(0);\n    \n    const int n = 2;\n    \n    for(int i=0; i<n; i++)\n        acc += render(fragCoord);\n    \n    fragColor = acc / float(n);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}