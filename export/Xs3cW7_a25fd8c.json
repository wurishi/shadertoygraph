{"ver":"0.1","info":{"id":"Xs3cW7","date":"1519100308","viewed":141,"name":"Efficent spheres","username":"rory618","description":"An alternative way to approximately render this specific scene using a much faster but more limited approach than raymarching. Possibly the camera can move, but its position may need to be estimated using a close rational approximation.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float intersect(vec3 sp, vec3 ro, vec3 rd, float r) {\n\tvec3 op = sp - ro;\n\tfloat t, epsilon = 1e-3, b = dot(op, rd), det = b * b - dot(op, op) + r * r;\n\tif (det < 0.) return 1e6; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 1e6);\n}\nvec4 image(vec2 c){\n    mat3 ABC = mat3(1);\n    vec3 d = normalize(\n        vec3(abs(c),1)*mat3(1)\n    );\n    float r = .25+.2*sin(iTime);\n    float i0 = 1e6;\n    for(int j=0;j<3;j++){\n        i0 = min(i0,intersect(ABC[j],vec3(0),d,r));\n        i0 = min(i0,intersect(ABC*vec3(j!=0,j!=1,j!=2),vec3(0),d,r));\n    }\n    if(i0!=1e6){\n        return texture(iChannel3,reflect(d,normalize(fract(i0*d+.5)-.5))*vec3(sign(c),1));\n        \n    }\n    for(int i = 0; i < 8; i++) {\n        \n        vec3 s = ABC*vec3(1);\n        vec3 y = vec3(dot(cross(ABC[0],s),d)>0.,\n                      dot(cross(ABC[1],s),d)>0.,\n                      dot(cross(ABC[2],s),d)>0.);\n        vec3 n = 1.-y;\n        \n        ABC *= mat3(1          ,n.x*y.y*y.z,y.x*n.y*n.z,\n                    n.x*y.y*n.z,1          ,y.x*n.y*y.z,\n                    y.x*y.y*n.z,n.x*n.y*y.z,1           );\n        \n        float i0 = 1e6;\n        for(int j=0;j<3;j++){\n            //calling intersect 3 timers per iteration kind of wasteful since 1 of them is redundant from the last iteration\n        \ti0 = min(i0,intersect(ABC*vec3(j!=0,j!=1,j!=2),vec3(0),d,r));\n        }\n        if(i0!=1e6){\n            return texture(iChannel3,reflect(d,normalize(fract(i0*d+.5)-.5))*vec3(sign(c),1));\n            \n        }\n        \n    }\n    return vec4(0,0,0,1);\n}\n#define R iResolution\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec2 c = (i*2.-R.xy)/R.y;\n    o = vec4(0);\n\t//8x SSAA for kicks =)\n    for(int j = 0; j < 8; j++){\n    \to += image(c+\n                  (hash33(vec3(j+iFrame,i)).xy-.5)/R.y\n                 );\n    }\n    o/=o.w;\n    \n}","name":"Image","description":"","type":"image"}]}