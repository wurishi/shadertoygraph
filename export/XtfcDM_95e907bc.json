{"ver":"0.1","info":{"id":"XtfcDM","date":"1505325041","viewed":300,"name":"Compound Eye","username":"FlexMonkey","description":"Compound Eye Shader - simulates the eye of an insect or crustacean by creating multiple refracted images in a hexagonal grid.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["compoundeye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tCompound Eye Shader\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/CompoundEye.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n*/\n\nvec4 warp(vec2 fragCoord, \n          float width, float halfWidth, \n          float height, float radius, \n          float bend, vec2 resolution,\n          sampler2D source, vec4 backgroundColor) {\n\n    vec2 destCoord = fragCoord / resolution.y;\n    \n    float y = float(floor(destCoord.y / height)) * height;\n    float yIndex = floor(mod(destCoord.y / height, 2.0));\n    float xOffset = (yIndex < 1.0) ? halfWidth : 0.0;\n    float x = floor((destCoord.x + xOffset) / width) * width; \n    \n    vec2 cellCenter = vec2(x + halfWidth, y + (height / 2.0)); \n    vec2 offsetDestCoord = vec2(destCoord.x + xOffset, destCoord.y);\n  \n    if (distance(cellCenter, offsetDestCoord) > radius) {\n    \treturn backgroundColor; \n    }\n    \n    vec2 spherePos = cellCenter - offsetDestCoord;\n        \n\tfloat z = (radius - spherePos.x * spherePos.x - spherePos.y * spherePos.y);\n    vec3 sphereNormal = normalize(vec3(spherePos.x, spherePos.y, z));\n\n    vec3 refractVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, bend); \n \n    vec4 returnColor = texture(source, \n                               (destCoord - refractVector.xy) *resolution.y/resolution);\n \n    vec3 lightDirection = vec3(-0.75, 0.75, 1.0); \n    vec3 viewDirection = vec3(0.0, 0.0, 1.0);\n    float specular = pow(max(0.0, \n                             dot(reflect(lightDirection, sphereNormal), \n                                 viewDirection)), 1.5);\n    \n    return returnColor + specular; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float width = 0.15;\n    float halfWidth = width * 0.5; \n    float height = sqrt(3.0) / 2.0 * width;\n    float radius = sqrt(height * height) / 2.0;\n    vec2 resolution = iResolution.xy; \n    float bend = 1.15; \n    vec4 backgroundColor = vec4(0.25, 0.25, 0.25, 1.0); \n    \n\tfragColor = warp(fragCoord, \n                     width, halfWidth, \n                     height, radius, \n                     bend, resolution, \n                     iChannel0, backgroundColor);\n}","name":"Image","description":"","type":"image"}]}