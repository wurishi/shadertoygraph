{"ver":"0.1","info":{"id":"WlcXDN","date":"1580919535","viewed":105,"name":"Voronoi Variations","username":"gressettd","description":"Flexible voronoi function. Not all combos work. Red dot = distance metric. Green dot = data index (f1,f2, etc). Blue dot = invert or not.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WORLEY_EUCLIDIAN 0\n#define WORLEY_MANHATTAN 1\n#define WORLEY_CHEBYSHEV 2\n#define WORLEY_TRIANGULAR 3\n#define WORLEY_8THDEG 4\n#define WORLEY_SINE 5\n#define WORLEY_MINK4 6\n#define WORLEY_MINK05 7\n#define WORLEY_QUAD 8\n\n\nuint BaseHash(uvec2 p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17))); \n\th32 = PRIME32_2 * (h32 ^ (h32 >> 15));\n\th32 = PRIME32_3 * (h32 ^ (h32 >> 13));\n\treturn h32 ^ (h32 >> 16);\n}\n\nvec2 Hash22(uvec2 x)\n{\n\tuint n = BaseHash(x);\n\tuvec2 rz = uvec2(n, n * 48271U);\n\treturn vec2((rz.xy >> 1) & uvec2(0x7fffffffU, 0x7fffffffU)) / float(0x7fffffff);\n}\n\n\nvec2 Random2DVector2(vec2 p)\n{\n\treturn Hash22(uvec2(floatBitsToUint(p.x),floatBitsToUint(p.y)));\n}\n\nfloat RootN(float x, float y)\n{\n    return pow(x, (1.0 / y));\n}\n\nfloat Length2P8(vec2 p)\n{\n    float d = pow(p.x,8.0) + pow(p.y,8.0);\n    return RootN(d, 8.0);\n}\n\nfloat Map(float value, float old_lo, float old_hi, float new_lo, float new_hi)\n{\n    float old_range = old_hi - old_lo;\n    float new_range = new_hi - new_lo;\n    return (((value - old_lo) * new_range) / old_range) + new_lo;\n}\n\nfloat DistanceByMetric(vec2 p, vec2 o, vec2 r, int distanceMetric)\n{\n\tfloat d = 0.0;\n\tswitch (distanceMetric)\n\t{\n\tcase WORLEY_EUCLIDIAN:\n\t\td = length(r); // euclidian\n\t\tbreak;\n\n\tcase WORLEY_MANHATTAN:\n\t\td = abs(r.x) + abs(r.y);  // manhattan\n\t\tbreak;\n\n\tcase WORLEY_CHEBYSHEV:\n\t\td = max(abs(r.x), abs(r.y)); // chebyshev\n\t\tbreak;\n\n\tcase WORLEY_TRIANGULAR:\n\t\td = max(abs(r.x)*0.866025 + r.y*0.5, -r.y); // triangular xy plane\n\t\tbreak;\n\n\tcase WORLEY_8THDEG:\n\t\td = Length2P8(r); // 8th degree len.\n\t\tbreak;\n        \n    case WORLEY_SINE:\n        d = length(r) + (1.0 + sin(16.0*length(r))) * 0.5;\n        break;\n        \n    case WORLEY_MINK4:\n        d = sqrt(sqrt(dot(r * r, r * r)));\n        break;\n        \n    case WORLEY_MINK05:\n        d = sqrt(sqrt(abs(r.x))+sqrt(abs(r.y)) );\n        break;\n        \n    case WORLEY_QUAD:\n        d = r.x*r.x+r.y*r.y+r.x*r.y;\n        break;\n\n\t\n\t}\n\n\treturn d;\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(3.14159 * 2.0 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\nvoid WorleyNoise2D(\n    vec2 p, \n    int distanceMetric, \n    bool invert, \n    float falloff,\n    out vec4 cca, \n    out vec4 ccb, out vec4 ccc)\n{\n\n\tvec2 n = floor(p);\n\tvec2 nf = fract(p);\n\tvec2 h = step(0.5, nf) - 2.0;\n\tn += h; \n\tnf -= h;\n\n\tvec4 f = vec4(8.0, 8.0, 8.0, 8.0);\n\tvec2 mg, mr;\n\tfloat res = 0.0;\n\n\tfor(int j=0; j<=3; j++)\n\tfor (int i=0; i<=3; i++)\n\t{\n\t\tvec2 g = vec2(float(i), float(j));\n\t\tvec2 o = Random2DVector2(n + g);\n\t\tvec2 r = g + o - nf;\n\n\t\tfloat d = DistanceByMetric(p, o, r, distanceMetric);\n        \n        res += 1.0 / pow(d, falloff);\n\n\t\tif (d < f.x)\n\t\t{\n\t\t\tf.w = f.z;\n\t\t\tf.z = f.y;\n\t\t\tf.y = f.x;\n\t\t\tf.x = d;\n\t\t\tmr = r;\n\t\t\tmg = g;\n\t\t}\n\t\telse if (d < f.y)\n\t\t{\n\t\t\tf.w = f.z;\n\t\t\tf.z = f.y;\n\t\t\tf.y = d;\n\n\t\t}\n\t\telse if (d < f.z)\n\t\t{\n\t\t\tf.w = f.z;\n\t\t\tf.z = d;\n\n\t\t}\n\t\telse if (d < f.w)\n\t\t{\n\t\t\tf.w = d;\n\t\t}\n\n\t\t\n\n\t}\n\n\t// distance to borders\n\n\tfloat minDist = 8.0;\n\tfor (int j = 0; j <= 3; j++)\n\t\tfor (int i = 0; i <= 3; i++)\n\t\t{\n\t\t\tvec2 g = vec2(float(i), float(j));\n\t\t\tvec2 o = Random2DVector2(n + g);\n\t\t\tvec2 r = g + o - nf;\n\n\t\t\tif (dot(mr - r, mr - r) > 0.00001)\n\t\t\t{\n\t\t\t\tfloat dist = dot(0.5*(mr + r), normalize(r - mr));\n\t\t\t\tminDist = min(minDist, dist);\n\t\t\t}\n\t\t}\n\n    float v;\n    \n\t// f1\n\tcca.x = invert ? 1.0 - f.x : f.x;\n\n\t// f2\n\tcca.y = invert ? 1.0 - f.y : f.y;\n\n\t// f3\n\tcca.z = invert ? 1.0 - f.z : f.z;\n\n\t// f4\n    v= clamp(max(0.5,16.0 * (f.y-f.x)), 0.0, 1.0);\n    v = minDist < (falloff/50.0) ? (1.0 - minDist) : 0.0; // 1.0: 0.0;\n\tcca.w = invert ? 1.0 - v: v;\n\n\t\n\t// f2 - f1\n\tv = f.y - f.x;\n\tccb.x = invert ? 1.0 - v : v;\n\n\t// f1 + f2\n\tv = f.x + f.y;\n\tccb.y = invert ? 1.0 - v : v;\n\n\t// (f1 + f2 + f3 + f4) / 4\n\tv = (f.x + f.y + f.z + f.w) * 0.25;\n\tccb.z = invert ? 1.0 - v : v;\n\n\t// border distance\n\tccb.w = minDist;\n    \n    // f4\n    ccc.x = invert ? 1.0 - f.w : f.w;\n\n    // rounded\n\tv = 1.0 / (1.0 / (f.y - f.x) + 1.0 / (f.z - f.x));\n\tccc.y = invert ? 1.0 - v : v;\n\n    // f2^2 - f1^2\n\tv = (f.y*f.y) - (f.x*f.x);\n\tccc.z = invert ? 1.0 - v : v;\n\n    // smoothed\n\tv = pow(1.0 / res, 0.5 / falloff);\n\tccc.w = invert ? 1.0 - v : v;\n\n\t\n}\n\nvec4 MapColor(float intensity, int pallette)\n{\n    vec4 retval;\n    \n    switch(pallette)\n    {\n        case 0: retval = vec4(intensity); break;\n        case 1: \n        {\n            vec4 bias = vec4(0.000, 0.500, 0.500, 1.0);\n            vec4 scale = vec4(0.000, 0.500, 0.500, 1.0);\n            vec4 freq = vec4(0.000, 0.500, 0.333, 1.0);\n            vec4 phase = vec4(0.000, 0.500, 0.667, 1.0);\n  \n    \t\tvec4 col = ComputeWaveGradientRGB(intensity,bias,scale,freq,phase);\n    \t\tretval =  vec4(col.xyz, 1.0);\n        }\n        break;\n        \n        case 2: retval = vec4(clamp(vec3(3.0, 3.0, 4.0) * intensity - vec3(0.0, 1.0, 3.0), 0.0, 1.0),1.0); break;\n\n    }\n    \n    return retval;\n}\n\nbool InsideCount(vec2 px, int count, vec2 tl)\n{\n    bool rv = false;\n    \n    float md = 9999.0;\n    for(int i =0; i < count; i++)\n    {\n        vec2 c = vec2(tl.x + (float(i) * 20.0), tl.y);\n        float d = length(px-c);\n        md = min(d, md);\n    }\n    \n    rv = md < 8.0;\n    \n    return rv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x, iResolution.y);\n\tfloat maxRes = max(res.x, res.y);\n\tvec2 pos = vec2(fragCoord.x,fragCoord.y);\n    vec2 p = (2.0 * pos - res) / min(res.x, res.y);\n    \n    float scale = Map( (sin(iTime * 0.4)+1.0) * 30.0, 0.0,60.0,1.0,4.0);\n    vec2 translate = vec2(iTime * 0.33);\n    \n    p *= scale;\n    p += translate;\n        \n    int metric = 0; // 0 - 6 \n    int data = 0;   // 0 - 7 change every 6s\n    bool invert = false; // change every 3s\n    \n    int tScale = 1;\n    int iSec = int(floor(iTime)) / tScale;\n    \n    invert = (iSec / 3) % 2 == 1;\n    data = (iSec / 6) % 12;\n    metric = (iSec / 72) % 9;\n    \n    \n    vec4 cca, ccb, ccc;\n    WorleyNoise2D(p, metric, invert, Map(sin(iTime * 3.0), -1.0, 1.0, 2.0, 8.0), cca, ccb, ccc);\n    \n    float value= 0.0;\n    switch(data)\n    {\n        // data index (GREEN)\n        case 0:value = cca.x; break; // f1\n        case 1:value = cca.y; break; // f2\n        case 2:value = cca.z; break; // f3\n        case 3:value = cca.w; break; // f4\n        case 4:value = ccb.x; break; // f2-f1\n        case 5:value = ccb.y; break; // f1+f2\n        case 6:value = ccb.z; break; // (f1+f2+f3+f4)/4\n        case 7:value = ccb.w; break; // border distance\n        case 8:value = ccc.x; break; // f4\n        case 9:value = ccc.y; break; // rounded\n        case 10:value= ccc.z; break; // f2^2 - f1^2\n        case 11:value= ccc.w; break; // smoothed\n    }\n    \n    vec4 col = MapColor(value, 1);\n    \n    // invert: blue. 2 = true, 1 = false\n    if(InsideCount(pos, invert ? 2: 1, vec2(40.0,40.0))) col = vec4(0.0,0.0,1.0,1.0); \n    else\n    // data: green. cc index\n    if(InsideCount(pos, data + 1, vec2(40.0,60.0))) col = vec4(0.0,1.0,0.0,1.0);\n    else\n    // metric: red. \n    if(InsideCount(pos, metric + 1, vec2(40.0,80.0))) col = vec4(1.0,0.0,0.0,1.0);\n    \n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}