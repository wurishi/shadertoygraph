{"ver":"0.1","info":{"id":"mssfD7","date":"1688855149","viewed":169,"name":"TOH Glyphs","username":"fishy","description":"Glyphs from TOH\nhttps://theowlhouse.fandom.com/wiki/Glyph_Magic","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["sdf","glow","glyphs","owlhouse","toh"],"hasliked":0,"parentid":"mdsfD7","parentname":"TOH Glyph SDFs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define init() float r = 0.0\n#define end() return r\n#define add(d) r += 1.0 / (15.0*max(0.0001, d))\n#define mirrorX(p) vec2(abs(p.x), p.y)\n\n// https://github.com/GarrettGunnell/AcerolaFX/blob/main/Shaders/AcerolaFX_Tonemapping.fx\nconst mat3 ACESInputMat = mat3(\n    vec3(0.59719, 0.35458, 0.04823),\n    vec3(0.07600, 0.90834, 0.01566),\n    vec3(0.02840, 0.13383, 0.83777)\n);\n\nconst mat3 ACESOutputMat = mat3(\n    vec3( 1.60475, -0.53108, -0.07367),\n    vec3(-0.10208,  1.10813, -0.00605),\n    vec3(-0.00327, -0.07276,  1.07602)\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 HillACES(vec3 col) {\n    col = col * ACESInputMat;\n    col = RRTAndODTFit(col);\n    return clamp(col * ACESOutputMat, 0.0, 1.0);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing(vec2 p, vec2 o, float r)\n{\n    return abs(distance(p, o) - r);\n}\n\nfloat sdPoint(vec2 p, vec2 o)\n{\n    return distance(p, o);\n}\n\nfloat sdPointedEggRing(vec2 p, vec2 o, float r, float h)\n{\n    return abs(p.y - o.y > 0.0? length(vec2(abs(p.x), p.y) - o + vec2(h, 0.0)) - (r+h) : length(p - o) - r);\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat sdGlyph(vec2 uv, int type)\n{\n    init();\n    add(sdRing(uv, vec2(0), 1.0));\n    switch(type)\n    {\n        case 0:\n            add(sdSegment(mirrorX(uv), vec2(0, 1), vec2(0.15, 0.7)));\n            add(sdRing(uv, vec2(0, 0.66), 0.154));\n            add(sdSegment(mirrorX(uv), vec2(0, 0.506), vec2(0.953, -0.3)));\n            add(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            add(sdSegment(uv, vec2(0, 0.506), vec2(0, -1)));\n            add(sdSegment(uv, vec2(-0.1, 0), vec2(0.1, 0.1)));\n            add(sdSegment(uv, vec2(-0.1, -0.1), vec2(0.1, 0)));\n            end();\n        case 1:\n            add(sdSegment(mirrorX(uv), vec2(0, 1), vec2(0.4, 0.6)));\n            add(sdSegment(mirrorX(uv), vec2(0.4, 0.6), vec2(0.0, -0.3)));\n            add(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            add(sdCubicBezier(mirrorX(uv), vec2(0.0, 0.2), vec2(0.2, 0.2), vec2(0.6, 0.1), vec2(0.97, -0.2), 8.0));\n            add(sdSegment(uv, vec2(0, 1), vec2(0, -0.3)));\n            add(sdSegment(mirrorX(uv), vec2(0, -0.3), vec2(0.15, -0.45)));\n            add(sdSegment(mirrorX(uv), vec2(0.15, -0.45), vec2(0, -0.6)));\n            end();\n        case 2:\n            add(sdSegment(mirrorX(uv), vec2(0, -0.2), vec2(0.25, 0.05)));\n            add(sdRing(uv, vec2(0, -0.5), 0.3));\n            add(sdPoint(uv, vec2(0, -0.5)));\n            add(sdSegment(mirrorX(uv), vec2(0, 0.4), vec2(0.25, 0.65)));\n            add(sdSegment(uv, vec2(0.1, 0.5), vec2(-0.1, 0.5)));\n            add(sdSegment(uv, vec2(-0.25, 0.65), vec2(0.25, 0.65)));\n            add(sdSegment(uv, vec2(0, -0.2), vec2(0, 0.4)));\n            end();\n        case 3:\n            add(sdPointedEggRing(uv, vec2(0.0, -0.5), 0.5, 0.95));\n            add(sdRing(uv, vec2(0.0, -0.5), 0.5));\n            add(sdPoint(uv, vec2(0.0, -0.5)));\n            add(sdPointedEggRing(uv, vec2(0.0, 0.3), 0.3, 0.65));\n            add(sdRing(uv, vec2(0.0, 0.3), 0.3));\n            end();\n    }\n        \n}\n\nvec3[] colors = vec3[](vec3(1.000,0.8,0.325), vec3(0.110,0.667,1.000), vec3(0.200,1.000,0.082), vec3(1.000,0.553,0.059));\nvec3 glyph(vec2 uv, float thickness, int type)\n{\n    float sdf = sdGlyph(uv, type);\n    return sdf * colors[type];\n}\n\nvec3 glyphRow(vec2 uv, float time)\n{\n    uv.y += time;\n    float xrand = hash12(floor(uv.yy));\n    uv.x += time * (xrand-0.5)*4.0;\n    float rand = hash12(floor(uv));\n    return glyph(4.0 * fract(uv) - 2.0, 0.01, int(rand*4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 2.0/iResolution.y;\n\n    //vec3 col = HillACES(glyph(uv*1.5 + m.xy*0.1, 0.01, int(iTime) % 4));\n    vec3 col = max(vec3(0), glyphRow(uv, iTime*0.2)-0.3) / 0.7;\n\n    // Output to screen\n    fragColor = vec4(HillACES(col),1.0);\n}","name":"Image","description":"","type":"image"}]}