{"ver":"0.1","info":{"id":"43SSRz","date":"1710496661","viewed":184,"name":"Sound thingy","username":"_pwd_","description":"Some bits of sound for using the sample´s frequencies as inputs. A few geometric forms deforming and hovering over the device. \n\n\"Temple Ball\" from Gravious: https://soundcloud.com/graviousofficial/temple-ball","likes":11,"published":1,"flags":96,"usePreview":1,"tags":["raymarching","reflection","ray","shadow","antialiasing","fog","raymarcher","csg","specular","softshadows","penumbra","synth","soundreactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//\n//\n// Sound Thingy\n//\n// Some bits of sound for using the sample´s frequencies as inputs.\n// A few geometric forms hovering the device. A litte deform here and\n// there garnished with some postpro ... no more no less.\n// \"Temple Ball\" from Gravious: https://soundcloud.com/graviousofficial/temple-ball\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT\n//\n//\n//\n//\n//\n//\n//\n// Related examples\n//\n// IQ´s article for sure\n// https://iquilezles.org/articles/distfunctions/\n//\n// Drops\n// https://www.shadertoy.com/view/fdXXWH\n//\n// Every 10 secs taken from\n// https://www.shadertoy.com/view/ltKGzc\n//\n//\n//\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec4 c0 = texture(iChannel0,fragCoord.xy/iResolution.xy);\n\t\n    \n    // chromatic aberration\n\tfloat t = pow((((1. + sin(iTime * 10.) * .5)\n\t\t *  .8 + sin(iTime * cos(fragCoord.y) * 41415.92653) * .0125)\n\t\t * ( 1.5 + beat ) + sin(iTime * 7.) * .5), 5.);\n\t\n\tvec4 c1 = texture(iChannel0, fragCoord.xy/(iResolution.xy+vec2(t * .2,.0)));\n\tvec4 c2 = texture(iChannel0, fragCoord.xy/(iResolution.xy+vec2(t * .5,.0)));\n\tvec4 c3 = texture(iChannel0, fragCoord.xy/(iResolution.xy+vec2(t * .9,.0)));\n\t\n    // noise\n    float noise = hash((hash(fragCoord.x) + fragCoord.y) * iTime) * .055;\n    \n\tfragColor = vec4(vec3(c3.r, c2.g, c1.b) + noise, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4scGWl","filepath":"https://soundcloud.com/graviousofficial/temple-ball","previewfilepath":"https://soundcloud.com/graviousofficial/temple-ball","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// utility functions\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotateX(vec3 pos, float alpha) {\n    mat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans * vec4(pos, 1.0));\n}\n\nvec3 rotateY(vec3 pos, float alpha) {\n    mat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans2 * vec4(pos, 1.0));\n}\n\nmat3 rotZ(float a) {\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// basic sdf shapes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdSphere(vec3 p, float r, float wobble) {\n    float w = sin(30.*p.x)*sin(30.*p.y)*sin(30.*p.z) * wobble * 0.025;\n    p.y += sin(wobble) * 0.1;\n    return length(p)-r + w;\n}\n\n// box sdf\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat rBox( vec3 p, vec3 b, float r, float wobble) {\n    float w = sin(30.*p.x)*sin(30.*p.y)*sin(30.*p.z) * wobble * 0.025;\n    p.y += sin(wobble) * 0.1;\n    return length(max(abs(p)-b,0.0))-r + w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t, float wobble) {\n    float w = sin(30.*p.x)*sin(30.*p.y)*sin(30.*p.z) * wobble * 0.025;\n    p.y += sin(wobble) * 0.1;\n    vec3 tp = rotateX(rotateY(rotateX(p,-1.4), -2.4),3.0);\n    return length( vec2(length(tp.xz)-t.x, tp.y)) - t.y + w;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdf blend & displace functions\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\nfloat opIntersection( float d1, float d2 ) { \n    return max(d1,d2); \n}\n\nfloat sampleFreq(float freq){\n    return texture(iChannel0, vec2(freq, 0.0)).x;\n}\n\nfloat smax(float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat deform(vec3 p) {\n\treturn ((cos(2.*p.x)*sin(4.*p.y)*sin(2.*p.z))*cos(30.1 + sin(iTime)*0.1));\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// main sdf\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p) {\n\n    vec2 d = vec2(1e10);\n    // bounding box\n    float bb = sdBox(p,vec3(2));\n\n    if (bb < 0.) {\n        \n        // get frequence samples\n        float press = ((sampleFreq(0.1)) * 4.0) * 0.0095;\n        float press1 = ((sampleFreq(0.4)) * 5.0) * 0.01;\n        float press2 = ((sampleFreq(0.6)) * 5.0) * 0.01;\n        float press3 = ((sampleFreq(1.0)) * 5.0) * 0.01;\n        \n        beat = press;\n        \n        // csg shaping the device´s shell\n        vec3 pl = p;\n        pl.y += 0.361;\n        pl.z += 0.261;\n        vec3 dp = pl;\n        pl = rotateY(pl, -iTime * 0.5);\n        pl *= rotZ(2.0*iTime*0.2);\n        \n        float h1 = -sin(iTime * 0.5);\n        float h2 = cos(iTime * 0.4 +.1);\n        float drop = length(dp+vec3(0,1.2,0.)*h1)-.1;\n        drop = smin(drop,length(dp+vec3(.1,.8,0)*h2)-.05, .1);\n        \n        float pl1 =  sdBox(pl, vec3(0.10, 0.10, 0.10)) + ( sin(30.*pl.x + sin(iTime) * 0.25) * sin(30.*pl.y + cos(iTime)) * sin(30.*pl.z) ) * 0.025;\n        \n        float casing = opIntersection( rBox(p + vec3(0.0, 0.35, 0.0), vec3(0.54,0.05,0.9), 0.015, 0.0), -rBox(p + vec3(0.0, 0.20, 0.0), vec3(0.52,0.15,0.88), 0.015, 0.0));\n        vec2 upperLayer = opU( vec2(casing), vec2(  smin( smin( rBox(p + vec3(0.0, 0.336, 0.15), vec3(0.517,0.04,0.73), 0.015, 0.0), pl1 + deform(pl) * 0.5, .4), drop, .4))); \n        d = opU(d, vec2( upperLayer.x, 1.));\n\n        \n        //float plane = sdPlane(p, vec4(0, 1, 0, 1.5));        \n       // d = opU(d, vec2( plane, BLUEISH));\n   \n        // csg shaping device´s buttons and sync states\n        float btn01 = opIntersection( rBox(p + vec3(0.418, 0.315 + press, -0.74), vec3(0.10,0.02,0.131), 0.015, 0.0), -sdSphere(p + vec3(0.41, 0.205 + press, -0.74), .09, 0.0 ));\n        d = opU(d, vec2( btn01, 1.));\n\n        float btn02 = opIntersection( rBox(p + vec3(0.194, 0.315 + press1, -0.74), vec3(0.10,0.02,0.131), 0.015, 0.0), -sdSphere(p + vec3(0.19, 0.205 + press1, -0.74), .09, 0.0 ));\n        d = opU(d, vec2( btn02, 1.));\n        \n        float btn03 = opIntersection( rBox(p + vec3(-0.032, 0.315 + press2, -0.74), vec3(0.10,0.02,0.131), 0.015, 0.0), -sdSphere(p + vec3(-0.032, 0.205 + press2, -0.74), .09, 0.0 ));\n        d = opU(d, vec2( btn03, 1.));\n        \n        float btn04 = opIntersection( rBox(p + vec3(-0.258, 0.315 + press3, -0.74), vec3(0.10,0.02,0.131), 0.015, 0.0), -sdSphere(p + vec3(-0.258, 0.205 + press3, -0.74), .09, 0.0 ));\n        d = opU(d, vec2( btn04, 1.));\n        \n        \n        // sound-bar \n        float sndBar = opIntersection( rBox(p + vec3(-0.450, 0.35, -0.74), vec3(0.07,0.05,0.131), 0.015, 0.0), -sdCapsule(   p,vec3(0.46,-0.298,0.7), vec3(0.46,-0.298,0.8), 0.03  ));\n        float barCut = sdBox(p + vec3(-0.450, 0.30, -0.14), vec3(0.15, 0.05, 0.005 + press * 25.0));\n        d = opU(d, vec2( sndBar, 1.));\n        d = opU(d, vec2( opIntersection( sdCapsule(   p,vec3(0.46,-0.298,0.7), vec3(0.46,-0.298,0.8), 0.029  ), -barCut), 2. ));\n        \n\n        // wobble geoms transitions\n        float wobble=(fract(.1*(iTime-1.))>=0.9)?fract(-iTime)*sin(10.*iTime):0.;\n        float impulse = .1;\n        if(mod(iTime,20.)< 10.) impulse = .2;\n        vec3 q = p;\n        q.z += 0.05;\n\n        float t = 0.0 + iTime * 0.25;\n        float t1 = t * 3.141592 / 3.0;        \n        d = opU(d, vec2( sdSphere(q-vec3(0.0+0.3*sin(t1),0.1+0.1*sin(t1),-0.2+0.4*cos(t1)), impulse, wobble), BLUEISH));\n        \n        t = 1.0 + iTime * 0.25;\n        t1 = t * 3.141592 / 3.0;\n        d = opU(d, vec2( rBox(q-vec3(0.0+0.3*sin(t1),0.1+0.1*sin(t1),-0.2+0.4*cos(t1)), vec3(impulse * 0.45,impulse * 0.45,impulse * 0.45), 0.012, wobble), BLUEISH));\n       \n        t = 2.0 + iTime * 0.25;\n        t1 = t * 3.141592 / 3.0;\n        d = opU(d, vec2( sdSphere(q-vec3(0.0+0.3*sin(t1),0.1+0.1*sin(t1),-0.2+0.4*cos(t1)), impulse, wobble), BLUEISH));\n\n        t = 4.0 + iTime * 0.25;\n        t1 = t * 3.141592 / 3.0;\n        d = opU(d, vec2( sdSphere(q-vec3(0.0+0.3*sin(t1),0.1+0.1*sin(t1),-0.2+0.4*cos(t1)), impulse, wobble), BLUEISH));\n\n        t = 5.0 + iTime * 0.25;\n        t1 = t * 3.141592 / 3.0;\n        d = opU(d, vec2( sdTorus(q-vec3(0.0+0.3*sin(t1),0.1+0.1*sin(t1),-0.2+0.4*cos(t1)), vec2(impulse * 0.8, 0.05), wobble), BLUEISH));\n\n\n    }\n    \n    // plane\n    d = opU(d, vec2(p.y+.5, 0.));\n    return d;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching loop\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin;\n    for (int i=0; i<256; i++) {\n        vec3 p = ro + rd*t;\n        \n        vec2 h = map(p);\n        if (h.x<.001) return vec2(t,h.y);\n        \n        t += h.x;\n        if (t>tmax) break;\n    }\n    return vec2(-1);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// calculate normals https://iquilezles.org/articles/normalsSDF\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0);\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// set: simple backdrop\n//////////////////////////////////////////////////////////////////////////////////////\nvec3 sky(vec3 rd) {\n    return mix(vec3(0.89, 0.72, 0.33)-.5*rd.y, vec3(0.98, 0.91, 0.58)*.7+.3, clamp(exp(-17.*rd.y),0.,1.));\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching softshadows (https://www.shadertoy.com/view/lfX3DN)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=0.; t<tmax;) {\n        vec3 p = ro + rd*t;\n        \n        float h = map(p).x;\n        if (h<.001) return 0.;\n        \n        float ra = t/k;\n        res *= clamp((h+ra)/(2.*ra),0.,1.);\n        t += h;\n    }\n\n    return res;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// ambient occlusion\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat occlusion(vec3 p, vec3 n, float ra) {\n    float res = 0.;\n    const int N = 8;\n        \n    for (int i=0; i<N; i++) {\n        float h = ra * float(i)/float(N);\n        res += clamp(.5+.5*map(p + n*h).x / h,0.,1.);\n    }\n    res /= float(N);\n    \n    return res*res;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// rendering function\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 render(vec3 ro, vec3 rd) {\n    \n    vec3 col = sky(rd);\n    vec2 tm = intersect(ro, rd, 0., 16.);\n    \n    if (tm.x>0.) {\n        vec3 p = ro + rd*tm.x;\n        vec3 n = calcNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        // diffuse\n        float dif = clamp(dot(n, sunDir), 0., 1.);\n        // shadow\n        float sha = shadow(p+n*.002, sunDir, 8., 10.);\n        // back light\n        float bac = clamp(dot(n, -sunDir), 0., 1.);\n        // ambient occlusion\n        float occ = occlusion(p, n, 1.5)*(.5+.5*n.y);\n        // bounce light\n        float bou = .5-.5*n.y;\n        // sun specular\n        float spe = clamp(dot(r, sunDir), 0., 1.);\n        // fresnel\n        float fre = 1.+dot(rd, n);\n        // reflection\n        float ref = shadow(p+n*.002, r, 16., 16.);\n\n        vec3 lin = vec3(0);\n        \n        vec3 mat;\n        if (tm.y<.5) {\n            float ch = mod(floor(p.x)+floor(p.z),2.);\n            mat = vec3(0.85, 0.71, 0.31) + .07*ch;\n            lin += sunCol * dif*sha;\n        } else if (tm.y==1.) {\n            mat = vec3(0.85, 0.71, 0.31);\n            lin += sunCol * dif*sha;\n        } else if (tm.y==2.) {\n            mat = vec3(0.0,0.0,.95);\n            lin += sunCol * dif*sha;\n        } else if (tm.y==BLUEISH) {\n            mat = vec3(0.0,0.0,.95);\n            vec3 envRefl1 = texture(iChannel1, vec3(r.x, r.y, r.z)).rgb;\n            mat += 0.15 * envRefl1;\n            lin += sunCol * dif * (sha * 0.02);\n        }\n        \n        // sun gi\n        lin += mat*sunCol * occ*(.5+.5*bac)*bou;\n        // sky diffuse\n        lin += .5*vec3(.4,.6,1) * occ;\n\n        col = mat*lin;\n        \n        // reflectivity\n        float ks = .05+.95*pow(fre,5.);\n        // sun reflection\n        col += .2*sunCol*pow(spe,32.)*ref;\n        // sky reflection\n        col += vec3(.4,.6,1)*ref*ks;\n        \n        // fog\n        col = mix(col, vec3(0.98, 0.91, 0.58), 1.-exp(-tm.x*tm.x*tm.x*.0009));\n    }\n    \n    // sun glare\n    col += .3*sunCol*sunCol*pow(clamp(dot(rd, sunDir),0.,1.),5.);\n    return col;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// camera matrix\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n    vec3 v = cross(u, w); // up vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 23.5 + iTime*1.5;\n\n    float an = -.4*iTime;\n    vec3 ro = vec3( 3.0*cos(0.1*time + 12.0*mo.x),  0.5 + 3.0*mo.y, 3.7*sin(0.1*time + 12.0*mo.x) );\n    vec3 ta = vec3(0);\n    mat3 ca = setCamera(ro, ta);\n    \n    vec2 m = iMouse.z>0. ? iMouse.xy / iResolution.xy : vec2(.5,0);\n    \n    vec2 p = fragCoord / iResolution.xy;\n    vec3 fcol = vec3(0);\n  \n    // antialiasing\n    for (int m=0; m<AA; m++)\n        for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5;\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        vec3 rd = ca * normalize(vec3(p,2.2 + cos(iTime) * 0.5));\n   \n        vec3 col = render(ro, rd);\n        \n         // tonemapping\n        col = 1.3*col/(1.+.5*col);\n        // gamma correction\n        col = pow(col, vec3(.5545));\n                \n        fcol += col;\n    }\n    \n    fcol /= float(AA*AA);\n    \n    // contrast\n    fcol = fcol*0.7+.2*fcol*fcol*(3.-2.*fcol);\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    fcol *= .3+.7*pow(32. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    \n    fragColor = vec4(fcol,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define AA 3 \n#define MAX_RECURSION 8 \n#define BLUEISH 3.\n\n// store sampled frequence globally\nfloat beat = 0.0;\n// sun direction\nconst vec3 sunDir = normalize(vec3(1));\n// sun color\nconst vec3 sunCol = vec3(1,.8,.6)*2.3;\n\nfloat hash(in float n) { return fract(sin(n)*43758.5453123); }","name":"Common","description":"","type":"common"}]}