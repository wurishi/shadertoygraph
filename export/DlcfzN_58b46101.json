{"ver":"0.1","info":{"id":"DlcfzN","date":"1701003595","viewed":64,"name":"Volumetric Spherical Splats","username":"chronos","description":"Demonstrates a way to splat volumetric spheres of homogeneous density\n    by cheaply computing the analytical length of the ray segment intersecting\n    the sphere without calculating the hit positions.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","volumetric","splat","homogeneous","density","splatting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Volumetric Spherical Splats by Chronos\n    \n    Demonstrates a way to splat volumetric spheres of homogeneous density\n    by cheaply computing the analytical length of the ray segment intersecting\n    the sphere without calculating the hit positions (directly at least).\n    \n    The spheres are sorted using a simple bubble sort \n    of the sphere position projected onto the line\n    from the origin to the camera position.\n    This is why the spheres pop in front and behind when the spheres\n    change position. They are essentially splatted to 2D ellipses.\n    \n    The volumetric transmission should be correct whenever\n    the spheres do not overlap, however.\n    \n    The method for computing the length of the intersecting ray segment\n    is demonstrated here:\n\n    https://www.shadertoy.com/view/mlcfRr\n\n*/\n\nconst float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    C_linear = clamp(C_linear, 0., 1.);\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nfloat lengthSquared(vec3 v) { return dot(v,v); }\n\nfloat sphere_depth(vec3 pos, float radius, vec3 ro, vec3 rd)\n{\n    float d2 = lengthSquared(cross(pos-ro, rd));\n    float x2 = radius*radius - d2;\n    if(x2 < 0.) return 0.; \n    float depth = 2. * sqrt(x2);\n    return depth;\n}\n\nstruct Sphere\n{\n    vec3 pos;\n    vec3 color;\n    float density;\n    float radius;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n\n    float time = .75 * iTime;\n\n    float c = cos(time);\n    float s = sin(time);\n    vec3 ro = 15. * vec3(c, 0., s) + vec3(0,0,0);\n    float focal = 2.;\n    vec3 rd = normalize(vec3(uv, -focal));\n    rd.xz = mat2(s, -c, c, s) * rd.xz;\n    \n    vec3 color = sRGBdecode(texture(iChannel0, rd).rgb);\n    \n    vec3 green = vec3(0.05,.675,.3);\n    vec3 pink = vec3(.675, 0.05, .3);\n    vec3 purple = vec3(.3, 0.05, .675);\n    vec3 blue = vec3(0.05, .3, .675);\n    vec3 yellow = vec3(0.95, .7, .325);\n    \n    Sphere[5] spheres;\n    \n    spheres[0].pos = vec3(0,sin(iTime)*.5,0);\n    spheres[0].radius = 4.0;\n    spheres[0].density = 0.5;\n    spheres[0].color = pink;\n    \n    spheres[1].pos = 2.*vec3(cos(iTime)*5.75,0,1);\n    spheres[1].radius = 2.0;\n    spheres[1].density = 0.75;\n    spheres[1].color = yellow;\n\n    spheres[2].pos = vec3(cos(iTime)*5.75,sin(iTime*.5)*4.,2);\n    spheres[2].radius = 3.;\n    spheres[2].density = 0.25;\n    spheres[2].color = blue;\n    \n    spheres[3].pos = vec3(cos(iTime*2.)*5.75,sin(iTime*2.5)*4.,3);\n    spheres[3].radius = 1.5;\n    spheres[3].density = 0.7;\n    spheres[3].color = green;\n    \n    spheres[4].pos = vec3(sin(iTime*1.5)*5.75, .7*sin(iTime*1.5*PI)*4.,4);\n    spheres[4].radius = 1.;\n    spheres[4].density = 0.9;\n    spheres[4].color = purple;\n    \n    \n    // sorting\n    float z[5];\n    \n    int[5] order = int[5](0,1,2,3,4);\n    \n    // Sphere center projected onto line from origin to camera\n    for (int i = 0; i < 5; i++)\n        z[i] = dot(spheres[i].pos, normalize(ro));\n    \n    // Bubble sort :)\n    for (int i = 0; i < 4; i++)\n    for (int j = 4; j > i; j--)\n    {\n        int a = j-1, b = j;\n        \n        // Swap if lowest element is nearer camera, so we draw back to front\n        // (i.e higher value z from origin, kinda reversed z from camera )\n        if(z[order[a]] > z[order[b]])\n        {\n            order[a] ^= order[b];\n            order[b] ^= order[a];\n            order[a] ^= order[b];\n        }\n    }\n    \n    // Draw splats\n    for(int i = 0; i < 5; i++)\n    {\n        int j = order[i];\n        float depth = sphere_depth(spheres[j].pos, spheres[j].radius, ro, rd);\n        float transmission = exp(-spheres[j].density*depth);\n        color = mix(spheres[j].color, color, transmission);\n    }\n    \n    // Optional tonemapping\n    #if 0\n    color = tanh(color);\n    #endif\n    \n    color = sRGBencode(color);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}