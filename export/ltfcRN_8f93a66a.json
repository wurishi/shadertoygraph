{"ver":"0.1","info":{"id":"ltfcRN","date":"1503670450","viewed":99,"name":"water_hexagon_thing","username":"grachev","description":"Hi","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 1024;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.005;\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s,0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat hexprism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z-h.y, max((q.x*0.866025 + q.y*0.5), q.y) - h.x);\n}\n\nfloat sphere(vec3 p, float s) {\n    return length(p) - s;  \n}\n\nfloat displacement_water(vec3 p) {\n    float t = iTime / 120.0;\n    return (texture(iChannel0, p.xz / 128.0 + vec2(-t, t/1.5)).r - 0.5) * 0.15;\n}\n\nfloat displacement_bump(vec3 p) {\n    //p += vec3(p.y * length(p.xz), 0.0, 0.0);\n    float l = length(p.xz);\n    return sin(l + (-iTime) * 2.0) * 200.0 / (l * 80.0);\n}\n\nstruct hit {\n    int index;\n    float depth;\n};\n    \nfloat objects(vec3 point) {\n    vec3 c = vec3(40.0, 0.0, 40.0);\n    vec3 q = mod(point, c) - 0.5*c;\n    vec3 hp = (vec4(q, 1.0) * rotateX(45.0) * rotateY(-.3)).xyz + vec3(0.0, -.5, 1.0);\n    return hexprism(hp, vec2(5.0, 10.0));   \n}\n\nhit scene(vec3 point) {\n    float p = plane(point, vec4(0.0, 1.0, 0.0, 0.0)) + displacement_water(point);\n    //if(length(point.xz) > 1.0)\n    //    p = smin(p, plane(point, vec4(0.0, 1.0, 0.0, 1.0)) + displacement_bump(point) + displacement_water(point), 0.3);\n    float h = objects(point);\n    if(p < h) return hit(0, p);\n    else return hit(1, h);\n}\n\nhit scene_no_water(vec3 point) {\n    return hit(1, objects(point));\n}\n\nvec3 ray_direction(float fov, vec2 size, vec2 coord) {\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nhit march(vec3 eye, vec3 dir) {\n    float depth = MIN_DIST;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        hit dist = scene(eye + depth * dir);\n        if(dist.depth < EPSILON) return hit(dist.index, depth);\n        depth += dist.depth / 2.0;\n        if(depth >= MAX_DIST) return hit(0, MAX_DIST);\n    }\n    return hit(0, MAX_DIST);\n}\n\nhit march_no_water(vec3 eye, vec3 dir) {\n    float depth = MIN_DIST;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        hit dist = scene_no_water(eye + depth * dir);\n        if(dist.depth < EPSILON) return hit(dist.index, depth);\n        depth += dist.depth / 2.0;\n        if(depth >= MAX_DIST) return hit(1, MAX_DIST);\n    }\n    return hit(1, MAX_DIST);\n}\n\nvec3 estimate_normal(vec3 point) {\n    return normalize(vec3(\n        scene(point + vec3(EPSILON, .0, .0)).depth - scene(point - vec3(EPSILON, .0, .0)).depth,\n        scene(point + vec3(.0, EPSILON, .0)).depth - scene(point - vec3(.0, EPSILON, .0)).depth,\n        scene(point + vec3(.0, .0, EPSILON)).depth - scene(point - vec3(.0, .0, EPSILON)).depth\n    ));\n}\n\nvec3 estimate_normal_no_water(vec3 point) {\n    return normalize(vec3(\n        scene_no_water(point + vec3(EPSILON, .0, .0)).depth - scene_no_water(point - vec3(EPSILON, .0, .0)).depth,\n        scene_no_water(point + vec3(.0, EPSILON, .0)).depth - scene_no_water(point - vec3(.0, EPSILON, .0)).depth,\n        scene_no_water(point + vec3(.0, .0, EPSILON)).depth - scene_no_water(point - vec3(.0, .0, EPSILON)).depth\n    ));\n}\n\nvec3 shade_hexprism(vec3 normal) {\n    return vec3(0.0, 0.7, 0.85) * abs(normal.y);\n}\n\nvec4 shade_water(vec3 point, vec3 normal, vec3 dir) {\n    vec3 refraction = refract(dir, normal, 0.75);\n    vec3 reflection = reflect(dir, normal);\n    hit dist = march_no_water(point, reflection);\n    vec3 reflected_point = point + reflection * dist.depth;\n    vec3 reflected_point_normal = estimate_normal(reflected_point);\n    \n    hit dist_underwater = march_no_water(point, refraction);\n    vec3 underwater_point = point + refraction * dist_underwater.depth;\n    vec3 underwater_normal = estimate_normal_no_water(underwater_point);\n\n    vec4 shade;\n    \n    if(dist.depth > MAX_DIST - EPSILON) {\n        shade = texture(iChannel2, reflection);\n    } else if(dist.index == 1) {\n        shade = vec4(shade_hexprism(reflected_point_normal), 1.0);\n    }\n    float co = 1.32; float theta = acos(dot(dir, normal));\n    float R = co + (1.0 - co) * (1.0 - cos(theta) * 5.0);\n    if(dist_underwater.depth <= MAX_DIST - EPSILON && dist.index == 1)\n        shade = mix(shade, vec4(shade_hexprism(underwater_normal), 1.0), .2);\n    shade = mix(shade, vec4(0.0, 0.2, 0.7, 1.0), 0.1);\n    return shade;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 coord_normalised = coord / max(coord.x, coord.y);\n    vec3 dir = ray_direction(90.0, iResolution.xy, coord);\n    \n    vec3 eye = vec3(0.0, 13.0, 30.0);\n    eye.x = sin(iTime) * 20.0;\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 centre = vec3(0.0, 0.0, 0.0);\n    \n    vec3 f = normalize(eye - centre);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    mat3 la = mat3(s, u, f);\n    dir = la * dir;\n    \n    //eye = (vec4(eye, 1.0) * rotateY(iTime / 5.0)).xyz;\n    //dir = (vec4(dir, 1.0) * rotateX(-0.3) * rotateY(iTime / 5.0)).xyz;\n    hit dist = march(eye, dir);\n    vec3 point = eye + dir * dist.depth;\n    vec3 normal = estimate_normal(point);\n\n    if(dist.depth > MAX_DIST - EPSILON)\n        color = texture(iChannel2, dir);\n    else if(dist.index == 1)\n        color = vec4(shade_hexprism(normal), 1.0);\n    else\n        color = shade_water(point, normal, dir);\n}\n","name":"Image","description":"","type":"image"}]}