{"ver":"0.1","info":{"id":"flsyD4","date":"1649334936","viewed":66,"name":"DUPUY Rémy - Shadertoy project","username":"dupuyrem","description":"Realization of an atom for the dynamic 3D module project. \nUniversity of Grenoble (IUT2) in France.\n\n\n\n\n\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","project","lpmiaw","iut2ofgrenoble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 40.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n/* Fonctions de rotation avec vec3 : */  \n\n// Rotation autour de l'axe X\nvec3 rotateXvec3(in vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x,p.y*c-p.z*s, p.y*s+p.z*c);\n}\n\n// Rotation autour de l'axe Y\nvec3 rotateYvec3(in vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c-p.z*s,p.y, p.x*s+p.z*c);\n}\n\n// Rotation autour de l'axe Z\nvec3 rotateZvec3(in vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c-p.y*s, p.x*s+p.y*c, p.z);\n}\n\n// Rotation sur l'ensemble des axes\nvec3 rotatewithVec3(in vec3 p, in vec3 r){\n    return rotateXvec3(rotateYvec3(rotateZvec3(p,r.z),r.y),r.x);\n}\n\n\n\n\n// Définition de la struction d'un rayon \nstruct Ray {\n    vec3 o; // origine \n    vec3 d; // direction \n};\n\n// Définition d'une surface \nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface couleur\n};\n\n// Création d'une sphere (distance signée)\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n// Fonction qui prends en paramètre 2 surfaces. \n// Retourne la plus petite distance entre les deux surfaces.\n// Affiche mes deux surfaces à l'écran.\n// Donnée sur : https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.t < obj1.t) return obj2;\n  return obj1;\n}\n\n\n// Création d'une sphere électron: \n// p est l'origine de la shere\n// col est la couleur\n// offset représente le décalage de la shere par rapport au centre\n// rotation represente les 3 angles de rotation\n\nSurface sphereElectron(vec3 p, vec3 col, vec3 offset, vec3 rotation ) {\n   \n  //Définition de la nouvelle position du cercle + rotation par rapport à cette position\n  // Un électron est décalé par rapport au centre\n  vec3 c = rotatewithVec3((p),rotation)+offset - vec3(1, 1, 0); \n  \n  // Création de la sphere (plus petite car c'est un électron)\n  float d = sdSphere(c,0.2);\n  \n  return Surface(d,col); \n    \n}\n\n\n// Création d'une sphere proton: \n// p est l'origine de la shere\n// col est la couleur\n// offset représente le décalage de la shere par rapport au centre\n// rotation represente les 3 angles de rotation\n\nSurface sphereProton(vec3 p, vec3 col, vec3 offset, vec3 rotation ) {\n   \n  //Définition de la nouvelle position du cercle + rotation par rapport à cette position\n  // Un proton est proche du centre \n  vec3 c = rotatewithVec3((p),rotation)+offset; \n  \n  // Création de la sphere (plus grande)\n  float d = sdSphere(c,0.7);\n  \n  return Surface(d,col); \n    \n}\n\n\n// Fonction de génération du noyau de l'atome : \n// Renvoi une surface -> un sol qui contient tous mes protons\nSurface genererNoyau(vec3 p, Surface monSol){\n\n    // Création des couleurs : \n    vec3 colorBlue  = vec3(0.,0.,1.);\n    vec3 colorRed   = vec3(1.,0.,0.); \n    \n    \n    // Tableau de spheres centrales : \n    Surface mesSpheresCentrales[8];\n    \n    // Tableau des sols \n    Surface mesSols[8]; \n    \n    // Initialisation : On ajoute la première sphère au sol passé en paramètre\n    mesSpheresCentrales[0] = sphereProton(p,colorRed,vec3(0, 0, 0),vec3(0,0,0));\n    mesSols[0] = minWithColor(monSol,mesSpheresCentrales[0]);\n    \n    // Boucle de génération du noyau de l'atom\n    // Chaque sphère dispose de propriétées différentes\n    for(int i=1;i<8;i++) {\n       \n       mesSpheresCentrales[i] = sphereProton(p,colorBlue,vec3(1, 0, 0),vec3(iTime,0,iTime));\n       \n       if(i == 1){\n          mesSpheresCentrales[i] = sphereProton(p,colorBlue,vec3(1, 0, 0),vec3(iTime,0,iTime));\n       }\n       \n       if(i == 2){\n         mesSpheresCentrales[i] = sphereProton(p,colorRed,vec3(0, -1, 0),vec3(iTime,0,iTime));  \n       }\n       \n       if(i == 3){\n         mesSpheresCentrales[i] = sphereProton(p,colorBlue,vec3(-1, 0, 0),vec3(iTime,0,iTime));  \n       }\n       \n       if(i == 4){\n         mesSpheresCentrales[i] = sphereProton(p,colorBlue,vec3(-1, 0, 0),vec3(iTime,0,iTime));  \n       }\n       \n       if(i == 5){\n         mesSpheresCentrales[i] = sphereProton(p,colorBlue,vec3(0, 0, 1),vec3(iTime,0,iTime));  \n       }\n       \n       if(i == 6){\n         mesSpheresCentrales[i] = sphereProton(p,colorRed,vec3(0, 1, 0),vec3(iTime,0,iTime));  \n       }\n       \n       if(i == 7){\n         mesSpheresCentrales[i] = sphereProton(p,colorRed,vec3(0, 0, -1),vec3(iTime,0,iTime));  \n       }\n       \n       // A chaque passage dans la boucle, on créer un nouveau sol qui contient l'ancien sol et la sphère courante\n       mesSols[i] = minWithColor(mesSols[i-1],mesSpheresCentrales[i]); \n       \n       // Fin du tableau :\n       if(i == 7) {\n           return mesSols[i];\n       }\n    \n    }\n }\n \n \n// Fonction de génération des éléctrons de l'atome : \n// Renvoi une surface -> un sol qui contient tous mes électrons\nSurface genererElectrons(vec3 p, Surface monSol){\n\n    // Création des couleurs : \n    vec3 colorBlue  = vec3(0.,0.,1.);\n    vec3 colorGreen = vec3(0.,1.,0.); \n    vec3 colorRed   = vec3(1.,0.,0.); \n    vec3 colorWhite = vec3(1.,1.,1.); \n    vec3 colorPurple = vec3(1.,0.,1.); \n    vec3 colorAqua = vec3(0.,1.,1.); \n\n    \n     // Vecteurs de réglages des rotations\n    vec3 reglageRotation = vec3(3.,5,2);\n    float iTimeRapide = iTime*iTime*0.0002; \n    \n    // Tableau de spheres électron : \n    Surface mesSpheresElectrons[8];\n    \n    // Tableau des sols \n    Surface mesSols[8]; \n    \n    // Initialisation : On ajoute la première sphère au sol passé en paramètre\n    mesSpheresElectrons[0] = sphereElectron(p,colorWhite,vec3(2, 0.1, 2.),vec3(iTimeRapide,iTimeRapide,iTime)*reglageRotation*1.5);\n    mesSols[0] = minWithColor(monSol,mesSpheresElectrons[0]);\n    \n    // Boucle de génération des électrons de l'atom\n    // Chaque sphère dispose de propriétées différentes\n    for(int i=1;i<6;i++) {\n    \n        mesSpheresElectrons[i] = sphereElectron(p,colorGreen,vec3(2, 0.1, 2.),vec3(iTimeRapide,iTimeRapide,iTime)*reglageRotation*1.5);\n    \n         if(i == 1){\n           mesSpheresElectrons[i] = sphereElectron(p,colorGreen,vec3(2, 0.1, 2.),vec3(iTimeRapide,iTimeRapide,iTime)*reglageRotation*1.5); \n         }\n         \n          if(i == 2){\n           mesSpheresElectrons[i] = sphereElectron(p,colorRed,vec3(2, 0.1, 2.),vec3(iTime,iTime,iTime)*reglageRotation*1.2); \n         }\n         \n         if(i == 3){\n           mesSpheresElectrons[i] = sphereElectron(p,colorBlue,vec3(2, 0.1, 2.),vec3(iTime,iTimeRapide,iTime)*reglageRotation*1.25); \n         }\n         \n          if(i == 4){\n           mesSpheresElectrons[i] = sphereElectron(p,colorPurple,vec3(2, 0.1, 2.),vec3(iTime,iTimeRapide,iTime)*reglageRotation); \n         }\n         \n         if(i == 5){\n           mesSpheresElectrons[i] = sphereElectron(p,colorAqua,vec3(2, 0.1, 2.),vec3(iTime,iTime,iTime)*reglageRotation); \n         }\n        \n        \n         // A chaque passage dans la boucle, on créer un nouveau sol qui contient l'ancien sol et la sphère courante\n       mesSols[i] = minWithColor(mesSols[i-1],mesSpheresElectrons[i]); \n       \n       // Fin du tableau\n        if(i == 5){\n           return mesSols[i]; \n        }\n        \n    }\n    \n    \n    \n    \n}\n\n\n\n// Création du sol avec la couleur : \n// Donnée sur : https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 3.;\n  return Surface(d, col);\n}\n\n\n// Ma scene principale\nSurface scene(in vec3 p) {\n    vec3 t = p*10.;\n    \n    // Couleur du sol :\n    // Donnée sur : https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\n    vec3 floorColor = vec3(0.8 + 0.8*mod(floor(p.x) + p.z, 0.5));\n   \n       \n    // Construction du sol : \n    // Inclusion du sol en lui-même: \n    Surface monSol = sdFloor(p, floorColor);\n    \n    // Inclusion du noyau au sein du sol : \n    monSol = genererNoyau(p,monSol); \n    \n    // Inclusion des électrons au sein du sol : \n    Surface monSolAvecElectrons = genererElectrons(p,monSol); \n    \n    \n   return monSolAvecElectrons; \n}\n\n\n\n// Fonction du ray-tracing : \n// On calcule la distance à un objet. \n// au fur et à mesure que l'on avance le long de notre rayon.\n// Explication : Ai-je intercepté un objet ? Si oui -> quoi ? \nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    // Tant que l'on est pas à la fin de la distance MAX,\n    // On avance \n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0));\n}\n\n\n// Définition de la normale avec une surface et en un rayon r\n// Droit perpendiculaire à la tangente de ce point. \n// Permet de savoir dans quelle direction \"regarde\" l'objet. \nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\n// Génération d'un rayon qui passe par le point p \nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 10.;\n    float d = DP/2.;\n    vec3 ro = vec3(d*cos(6.0*m.x),DP/5.0,d*sin(6.0*m.x) );\n\n    // target point\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*cw);\n\n    return Ray(ro,rd);\n}\n\n// Définition de l'éclairage \nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(2.5,2.,2.5)); // position de la lumière\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.7);\n    float s = 5.;\n    \n    // coeficients diffus et spéculaires\n    // dot calcule le produit scalaire \n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff + ks*spec;\n}\n\n\n// Main image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*3.5-1.5; // réglage de la position de la caméra \n    \n    Ray r = camRay(uv);\n    Surface s = march(r);\n\n    // Gestion de la couleur de fond : \n    // Inspiré grâce au shadertoy https://www.shadertoy.com/view/XsX3zl de tomorrowevening\n    vec2 p  = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 c=vec3(0.5*cos(3.0*p.x)+0.5,0.5*cos(3.0*p.y)+0.5,cos(p.x+p.y));\n\tc *= 0.7;\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    fragColor = vec4(c,1.0); // rendu final avec la couleur\n}","name":"Image","description":"","type":"image"}]}