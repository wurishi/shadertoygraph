{"ver":"0.1","info":{"id":"lclBD7","date":"1723984973","viewed":55,"name":"effects in digital twins1","username":"letbonsaibe","description":"some effects can be used in  digital twins scene,  all fork or deep inspired by shader below. I leave some code comment or implement in easy-understanding way. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fui","digitaltwins"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define SMOOTH2(r,R) (1.0-smoothstep(R-0.01, R+0.01, r))\n#define ROT(p, a) (mat2(cos(a),-sin(a),sin(a),cos(a))*p)\n\n\n// learning material\n// fork1: https://www.shadertoy.com/view/4s2SRt  (radar)\n// fork2: https://www.shadertoy.com/view/4lKXWD (dash1)\n\n\n\n// from IQ https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat radar(vec2 uv, vec2 center, float radius) {\n \n    // steadily increasing angles for moving\n    float theta = fract(iTime * .25) * 2. * PI;\n    \n    vec2 p = uv - center;\n    float r = length(p);\n    \n   \n    if(r<radius)\n    {\n        vec2 p0 = center;\n        vec2 p1 = radius* vec2(cos(theta), sin(-theta)) + center;\n        float dist = sdSegment(uv, p0, p1);\n        \n        // angle from 0 to 2*PI\n        float angle = mod(atan( p.y , p.x) + theta, 2. *PI)  ;\n        // light range\n        float range = 0.5 * PI;\n        // the closer to the line, the stronger the color.\n        float intensity = clamp (range -  angle, 0.0, range) / range;\n       \n        return SMOOTH(dist*200., 1.) + 0.8*intensity;\n   \n    }\n    else return 0.0;\n}\n\n\nfloat flashingDot(vec2 uv, vec2 center, float radius, float frequency) {\n    float dist = sdCircle(uv-center, radius);\n    // from 0 to 1\n    float waveFunc = 0.5-0.5*cos(iTime * 2.0 * PI * frequency);\n    return waveFunc * SMOOTH2(dist,radius);\n\n}\n\nfloat waveCircle(vec2 uv, vec2 center, float waveCount, float speed) {\n    float dist = length(uv - center);\n    \n    float wave = sin(dist*PI*waveCount - iTime*speed);\n    return exp(wave*wave * -3. );  // light effect;\n}\n\nfloat waveCirlce2(vec2 uv, vec2 center, float startR, float endR, float speed) {\n    float dist = length(uv - center);\n    float waveR = startR + mod(iTime*speed, endR-startR);\n    \n    // big white circle - small white circle = light circle\n    return smoothstep(max(0.09,waveR-0.11),waveR,dist)-\n           SMOOTH2(waveR,dist);\n    \n}\n\n\n\nfloat dashRect(vec2 uv, vec2 center, vec2 wh, float dashed, float speed, float width) {\n    vec2 dist = abs(uv - center);\n\n    // draw rectangle\n    if (all(lessThan(dist, wh)) && any(greaterThan(dist, wh-width))) {\n        \n        vec2 pixel = uv;\n\n        float aspect = wh.y / wh.x;\n        // Positive if on the left side of a 45-degree line, negative otherwise\n        float dir = (dist.x * aspect > dist.y) ?\n        -sign(uv.x - center.x) : sign(uv.y - center.y);\n        float dash = step(dashed/2.0, mod(dir*(pixel.x + pixel.y) + iTime * speed, dashed));\n        return dash;\n    }\n\n    return 0.0;\n}\n\nfloat dashCircle(vec2 uv, vec2 center, float radius, float width, float gapAngle, float gapCount)\n{\n    vec2 pixel = uv - center;\n    float dist = length(pixel);\n    \n    \n    \n    float r = dist;\n    \n    \n    \n    float theta = 180.0*(atan(pixel.y,pixel.x)/PI);\n    float baseAngle = 180. / gapCount;\n    \n    float outerCircle = SMOOTH2(dist-width/2.0,radius);\n    float innerCircle = SMOOTH2(dist+width/2.0,radius);\n    \n    float gap = smoothstep(gapAngle, gapAngle+0.1, abs(mod(theta+gapAngle, baseAngle)-gapAngle));\n    float intensity =  mix( 0.2, 1.0, step(0., mod(theta, 90.0)-45.0) ) ;\n\n    return gap *  intensity * (outerCircle - innerCircle);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    \n    vec2 uv2 = uv * 1.5;\n    vec2 cells   = fract(uv2);\n    cells = (cells - 0.5)* 2.0;\n    vec2 cellIds = floor(uv2);\n    \n    \n    if (cellIds.x == 0.0 && cellIds.y == 0.0) {\n        col += radar(cells, vec2(0.0), 0.8);\n\n    } else if (cellIds.x == 1.0 && cellIds.y == 0.0) {\n        col += flashingDot(cells, vec2(0.0), 0.1, 3.);\n\n    } else if (cellIds.x == 0.0 && cellIds.y == -1.0) {\n        col += waveCircle(cells, vec2(0.0),  2., 5.);\n\n    } else if (cellIds.x == 1.0 && cellIds.y == -1.0) {\n        col += waveCirlce2(cells, vec2(.0), 0.8, 0.1, 0.2);\n    } else if (cellIds.x == -1.0 && cellIds.y == -1.0) {\n        col +=  dashRect(cells, vec2(0.0), vec2(0.8, 0.4), 1.0/(2.0 * 2.0), 1.0, 0.006) ;\n    } else if (cellIds.x == -1.0 && cellIds.y == 0.0) {\n        col += dashCircle(ROT(cells, cos(iTime)), vec2(0., 0.0), 0.7, 0.02, 4.0, 8.0) ;\n    }\n    \n     \n    \n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}