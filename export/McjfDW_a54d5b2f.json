{"ver":"0.1","info":{"id":"McjfDW","date":"1724954747","viewed":198,"name":"Pixelated fire","username":"lisyarus","description":"A pixelated fire based on a fractal white noise","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","fire","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Turn on FROZEN for a different color scheme\nconst bool FROZEN = false;\n\n// Fractal noise properties\nconst int FIRST_OCTAVE = 2;\nconst int OCTAVE_COUNT = 6;\nconst float POWER = 0.0;\n\n// Use smooth instead of pixelated noise\nconst bool SMOOTH = false;\n\n// Scrolling speed\nconst float SPEED = 250.0;\n\n// Distort the flames\nconst bool DISTORT = false;\n\n// Just random white noise, taken from https://thebookofshaders.com/11/\n// Note the floor(p): this function is constant on each \"pixel\" (i.e. 1x1 square)\nfloat baseNoise(vec2 p)\n{\n    return fract(sin(dot(floor(p), vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    float v00 = baseNoise(p + vec2(0.0, 0.0));\n    float v10 = baseNoise(p + vec2(1.0, 0.0));\n    float v01 = baseNoise(p + vec2(0.0, 1.0));\n    float v11 = baseNoise(p + vec2(1.0, 1.0));\n    \n    vec2 t = fract(p);\n    \n    return mix(mix(v00, v10, t.x), mix(v01, v11, t.x), t.y);\n}\n\n// Fractal noise built from the above base function\n// Lower values of POWER (e.g. -1) make larger (low-freq) octaves stand out more\n// Higher values of POWER (e.g. 1) prefer smaller (high-freq) octaves and make the noise more uniform\nfloat noise(vec2 p)\n{\n    if (DISTORT)\n    {\n        float n = smoothNoise(p / 200.0 + vec2(0.0, 0.5 * iTime));\n        n = n * n * (3.0 - 2.0 * n);\n        p.x += 50.0 * (2.0 * n - 1.0);\n    }\n\n    float value = 0.0;\n    float normalization = 0.0;\n    \n    for (int i = FIRST_OCTAVE; i < FIRST_OCTAVE + OCTAVE_COUNT; ++i)\n    {\n        float weight = pow(2.0, - float(i) * POWER);\n        float noiseValue;\n        if (SMOOTH)\n            noiseValue = smoothNoise(p / pow(2.0, float(i)));\n        else\n            noiseValue = baseNoise(p / pow(2.0, float(i)));\n            \n        value += weight * noiseValue;\n        normalization += weight;\n    }\n    \n    return value / float(normalization);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / vec2(iResolution.xy);\n    \n    // Subtract time to animate the noise\n    float n = noise(fragCoord - vec2(0.0, iTime * SPEED));\n    \n    // Subtract Y-coordinate to make the flames disappear towards the top\n    float a = n - uv.y * 0.7;\n\n    // Hard-coded color map with discrete steps\n    vec3 color = vec3(a < 0.125 ? 0.0 : 1.0, a < 0.25 ? 0.0 : 1.0, a < 0.375 ? 0.0 : 1.0);\n    if (FROZEN)\n        color = vec3(a < 0.375 ? 0.0 : 1.0, a < 0.25 ? 0.0 : 1.0, a < 0.125 ? 0.0 : 1.0);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}