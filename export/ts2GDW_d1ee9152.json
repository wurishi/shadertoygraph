{"ver":"0.1","info":{"id":"ts2GDW","date":"1548938755","viewed":324,"name":"Remix: Cook-Torrance ","username":"gest","description":"Original: https://www.shadertoy.com/view/XsXXDB","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["lighting","sphere","materials","plane","intersect","cooktorrance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float u_time;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\t\t//Нормаль в точке\n\tObject object;\t\t//Дополнительные параметры объекта (формируются картой расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n//Плоскость\nstruct Plane {\n\tvec3 center;\n\tvec3 normal;\n};\n//Сфера\nstruct Sphere {\n\tvec3 center;\n\tfloat radius;\n};\n\n//Источники света\nstruct Light {\n\tvec3 position;\n\tvec3 color;\n};\nLight light_0 = Light(vec3( 0., 15.,  0.), vec3(0.8,0.8,0.8));\nLight light_1 = Light(vec3(-4., 10., -4.), vec3(1.,1.,1.));\n//Материалы \nstruct Material {\n\tvec3  colorDiffuse;\t\t//Цвет\n\tfloat ambient;\t\t\t//Окружающий цвет (при отсутствии освещения)\n\tfloat roughness;\t\t//Шероховатость\n\tfloat fresnel;\t\t\t//Отражаемость\n\tfloat density;\t\t\t//Плотность\n\tfloat reflectivity;\t\t//Зеркальность\n\tfloat refractivity;\t\t//Прозрачность\n\tfloat indexRefractive;\t//Индекс преломления\n};\n\n//Плоскости\nMaterial material_1 = Material( vec3(0.8, 0.8, 0.8), 0.1, 1.0, 0.8, 1.0,   0.,   0.0,   1.);\n//Нижние матовые шарики \nMaterial material_2 = Material( vec3(0.8, 0.8, 0.2), 0.1, 0.1, 0.8, 0.95,  0.,   0.0,   1.);\n//Вертикальные отражающие шарики\nMaterial material_3 = Material( vec3(0.8, 0.8, 0.2), 0.1, 0.1, 0.8, 0.95,  0.95, 0.0,   1.); \n//Вертикальные прозрачные шарики\nMaterial material_4 = Material( vec3(0.8, 0.8, 0.2), 0.1, 0.9, 0.8, 0.15,  0.1,  0.5,   0.85); \n//Центральный шар\nMaterial material_5 = Material( vec3(0.0, 0.8, 0.8), 0.1, 0.1, 0.8, 0.5,   0.5,  0.5,   0.8);\n\n//Формирование материала поверхности в точке пересечения луча\nMaterial getMaterial(Ray ray) {\n\tMaterial material;\n\tif (ray.object.id>=79) {\n\t\tmaterial = material_5;\n\t} else if (ray.object.id>=54) {\n\t\tmaterial = material_4;\n\t\tfloat i1 = floor( (float(ray.object.id) - 54.) / 4. );\n\t\tfloat j1 = mod( (float(ray.object.id) - 54.), 4.);\n\t\tmaterial.roughness = 0.9 - j1 * 0.2;\n\t\tmaterial.density = 0.15 + i1 * 0.2;\n\t\tmaterial.refractivity = 1. - material.density;\n\t} else if (ray.object.id>=29) {\n\t\tmaterial = material_3;\n\t\tfloat i1 = floor( (float(ray.object.id) - 29.) / 4. );\n\t\tfloat j1 = mod( (float(ray.object.id) - 29.), 4.);\n\t\tmaterial.roughness = 0.1 + j1 * 0.2;\n\t\tmaterial.density = 0.15 + i1 * 0.2;\n\t\tmaterial.reflectivity = 1. - material.density;\n\t} else if (ray.object.id>=4) {\n\t\tmaterial = material_2;\n\t\tfloat i1 = floor( (float(ray.object.id) - 4.) / 4. );\n\t\tfloat j1 = mod( (float(ray.object.id) - 4.), 4.);\n\t\tmaterial.roughness = 0.1 + j1 * 0.2;\n\t\tmaterial.density = 0.95 - i1 * 0.2;\n\t} else if (ray.object.id==3) {\n\t\tmaterial = material_1;\n\t\tmaterial.colorDiffuse = vec3(0.35, 0.65, 0.95)*mod(floor(ray.position.x)+floor(ray.position.y),2.)+0.25;\n\t} else if (ray.object.id==2) {\n\t\tmaterial = material_1;\n\t\tmaterial.colorDiffuse = vec3(0.95, 0.35, 0.)*mod(floor(ray.position.y)+floor(ray.position.z),2.)+0.25;\n\t} else if (ray.object.id==1) {\n\t\tmaterial = material_1;\n\t\tmaterial.colorDiffuse = vec3(0.75)*mod(floor(ray.position.x)+floor(ray.position.z),2.)+0.25;\n\t}\n\treturn material;\n}\n\n//------------------------------------------------------------------------------------------\n//Пересечение луча со сферой\nfloat intersectSphere(in Ray ray, in Sphere sphere, out vec3 normal) {\n\tvec3 v = ray.origin-sphere.center;\n\tfloat b = dot(v,ray.direction);\n\tfloat c = dot(v,v) - sphere.radius*sphere.radius;\n\tfloat d = b*b-c;\n\tif (d <0.) return ray.far; //Луч не пересекает сферу\n\tfloat t1 = -b-sqrt(d);\n\tfloat t2 = -b+sqrt(d);\n\tif (t2<0.) return ray.far; //Сфера позади луча\n\tfloat dist = t1>0. ? t1 : t2;\n\tnormal = normalize(ray.origin + dist * ray.direction - sphere.center);\n\t//Инверсия нормали при нахождении луча внутри сферы\n\tnormal *= -sign(dot(ray.direction, normal));\n\treturn dist;\n}\n//Пересечение луча с плоскостью\nfloat intersectPlane(in Ray ray, in Plane plane, out vec3 normal) {\n\tfloat dpn = dot(ray.direction, plane.normal);\n\tif (abs(dpn) < ray.epsilon) return ray.far;\n\tfloat dist = -(dot(plane.normal, plane.center) + dot(plane.normal,ray.origin)) / dpn;\n\tif (dist < 0.) return ray.far;\n\tnormal = plane.normal;\n\t//Инверсия нормали при нахождении луча за плоскостью\n\tnormal *= -sign(dot(ray.direction, normal));\n\treturn dist;\n}\n//-----------------------------------------------------------------------------------------\n//Минимальное расстояние до элемента сцены\nvoid rayMarch( inout Ray ray ) {\n\t//Учитываем отступ луча (для отражения, преломления и тени)\n\tray.origin += ray.near * ray.direction;\n\t\n\t//Умолчания (нет пересечения)\n\tray.distance \t= ray.far;\n\tray.normal \t\t= vec3(0);\n\tray.hit \t\t= false;\n\tray.object.id \t= -1;\n\t\n\t\n\tfloat d;\n\tvec3 normal;\n\tfloat flagInside;\n\t\n\td = intersectPlane( ray, Plane(vec3(0.0, 0.0, 0.0), vec3(0.,1.,0.)), normal );\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal \t \t= normal;\n\t\tray.hit \t \t= true;\n\t\tray.object.id \t= 1;\n\t}\n\t\n\td = intersectPlane( ray, Plane(vec3(-8.0, 0.0, 0.0), vec3(-1.,0.,0.)), normal);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal \t \t= normal;\n\t\tray.hit \t \t= true;\n\t\tray.object.id \t= 2;\n\t}\n\t\n\t\n\td = intersectPlane( ray, Plane(vec3(0.0, 0.0, 8.0), vec3(0.,0.,1.)), normal);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal \t \t= normal;\n\t\tray.hit \t \t= true;\n\t\tray.object.id \t= 3;\n\t}\n\t\n\n\tvec3 p = vec3(-2.5, 0.5, -2.5);\n\tfor (int i=0; i<4; ++i) {\n\t\tfor (int j=0; j<4; ++j) {\n\t\t\tp.z = -2.5 + float(j)*1.25;\n\t\t\tp.x = -2.5 + float(i)*1.25;\n\t\t\td = intersectSphere( ray, Sphere(p, 0.5), normal);\n\t\t\tif (ray.distance > d) {\n\t\t\t\tray.distance \t= d;\n\t\t\t\tray.normal \t \t= normal;\n\t\t\t\tray.hit \t \t= true;\n\t\t\t\tray.object.id \t= 4 + i*4 + j;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tp = vec3(-2.5, 1.0, -4.0);\n\tfor (int i=0; i<4; ++i) {\n\t\t\n\t\tfor (int j=0; j<4; ++j) {\n\t\t\tp.y =  1.0 + float(j)*1.25;\n\t\t\tp.x = -2.5 + float(i)*1.25;\n\t\t\td = intersectSphere( ray, Sphere(p, 0.5), normal);\n\t\t\tif (ray.distance > d) {\n\t\t\t\tray.distance \t= d;\n\t\t\t\tray.normal \t \t= normal;\n\t\t\t\tray.hit \t \t= true;\n\t\t\t\tray.object.id \t= 29 + i*4 + j;\n\t\t\t}\n\t\t}\n\t}\n\n\tp = vec3(4.0, 1.0, 1.25);\n\tfor (int i=0; i<4; ++i) {\n\t\tfor (int j=0; j<4; ++j) {\n\t\t\tp.y = 1.0 + float(j)*1.25;\n\t\t\tp.z = 1.25 - float(i)*1.25;\n\t\t\td = intersectSphere( ray, Sphere(p, 0.5), normal);\n\t\t\tif (ray.distance > d) {\n\t\t\t\tray.distance \t= d;\n\t\t\t\tray.normal \t \t= normal;\n\t\t\t\tray.hit \t \t= true;\n\t\t\t\tray.object.id \t= 54 + i*4 + j;\n\t\t\t}\n\t\t}\n\t}\n\n\tp = vec3(0.0, 4.0, 0.0);\n\td = intersectSphere( ray, Sphere(p, 1.5), normal);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal \t \t= normal;\n\t\tray.hit \t \t= true;\n\t\tray.object.id \t= 79;\n\t}\n\t\n\t//Местонахождение луча\n\tray.position \t= ray.origin + ray.distance * ray.direction;\n}\n\nfloat hardShadow( Ray ray, Light light) {\n\tfloat shadow = 1.0;//Нет тени\n\t//Формируем луч к источнику света\n\tRay ray1 = ray;;\n\t{\n\t\tray1.origin \t= ray.position ;\n\t\tray1.direction \t= normalize(light.position - ray.position);\n\t\tray1.near\t\t= 0.01; //Отступ от поверхности\n\t\tray1.far\t\t= length(light.position - ray.position);\n\t}\n\trayMarch(ray1);\n\t\n\tif (ray1.hit) shadow = 0.2; //Есть тень\n\treturn shadow; \n}\n\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( Ray ray, Light lights[2], Material material ) {\n\tvec3 color = vec3(0);\n\t\n\tfor (int i=0; i<2; i++) {\n\t\tLight light = lights[i];\n\t\t\n\t\tfloat roughness = material.roughness;\n\t\tfloat F0 = material.fresnel;\n\t\tfloat K = material.density;\n\t\t//\n\t\tvec3 lightDirection = normalize(light.position - ray.position);\n\t\tvec3 h = normalize(-ray.direction + lightDirection);\n\t\tfloat NdotL = clamp( dot( ray.normal, lightDirection ),0.,1. );\n\t\tfloat NdotH = clamp( dot( ray.normal, h ),0.,1. );\n\t\tfloat NdotV = clamp( dot( ray.normal, -ray.direction ),0.,1. );\n\t\tfloat VdotH = clamp( dot( h, -ray.direction ),0.,1. );\n\t\tfloat rsq = roughness * roughness;\n\t\t\n\t\t// Geometric Attenuation\n\t\tfloat NH2   = 2. * NdotH / VdotH;\n\t\tfloat geo_b = (NH2 * NdotV );\n\t\tfloat geo_c = (NH2 * NdotL );\n\t\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\t\n\t\t// Roughness\n\t\t// Beckmann distribution function\n\t\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\t\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\t\tfloat rough = r1 * exp(r2);\n\t\t\n\t\t// Fresnel\t\t\t\n\t\tfloat fres = pow( 1.0 - VdotH, 5. );\n\t\tfres *= ( 1.0 - F0 );\n\t\tfres += F0;\n\t\t\n\t\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\t\t\n\t\tfloat sha = hardShadow(ray, light);\n\t\tcolor += NdotL * ( (1.-K)*spec * step(1., sha) + sha * K*material.colorDiffuse ) * light.color;// * exp(-0.001*length(light.position-ray.position));\n\t}\n\tcolor /= 2.;\n\t// ambiant\n\tcolor += material.ambient * material.colorDiffuse;\n\t\n\treturn color;\n}\n\n//Цвет отражений\nvec3 rayReflect(in Ray ray, in Light lights[2]) {\n\t//Цвет отражений\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * shadeCookTorrance(ray, lights, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t//Следующий луч\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t} else {\n\t\t\t//Цвет фона\n\t\t\tcolor += vec3(0.1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\n//Цвет преломлений\nvec3 rayRefract(in Ray ray, in Light lights[2]) {\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t//Достигли фигуры\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t//Луч преломления на границе\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t\t//Пересечение луча с границей 2 той же фигуры \n\t\t\trayMarch (ray);\n\t\t\t//Луч преломления на границе\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\n\t\t\n\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec3 u_mouse = iMouse.xyz;\n\n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = gl_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2.0 - 1.0;\n\n    light_0.position.z = 6.*sin(u_time*0.4);\n    light_1.position.x = 6.*cos(u_time*0.4);\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n        cam.origin  = vec3( 8.0*cos(u_time*0.2), 6.0, 8.0*sin(u_time*0.2) );\n\n        if( u_mouse.z>0.0 ) {\n            float hd = -mouse.x * 14.0 + PI;\n            float elv = mouse.y * PI * 0.4 - PI * 0.25;\n            cam.origin = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n            cam.origin = cam.origin * 8.0 + vec3(0.0, 6.0, 0.0);\n        }\n\n        cam.target  = vec3( 0.0, 2.5, 0. );\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far  \t= 100.;\n        ray.epsilon = 0.0001;\n        ray.steps \t= 1;\n    }\n    //Источники света\n    Light lights[2];\n    lights[0] = light_0;\n    lights[1] = light_1;\n\n    vec3 color = vec3(0.);\n    //Цвет отражений\n    color += rayReflect(ray, lights);\n    //Цвет преломлений\n    color += rayRefract(ray, lights);\n\n    //color = clamp(color,0.,1.);\n\n    GL_FragColor = vec4( color, 1 );\n}","name":"Image","description":"","type":"image"}]}