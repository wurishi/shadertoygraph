{"ver":"0.1","info":{"id":"wsc3WS","date":"1569186845","viewed":272,"name":"Reflection demo 1.0","username":"livvy","description":"Just trying out some really basic reflections with raymarching, phong shading, some basic sin/cos animation. It's not pretty but this took me some time to figure out. I had the formula for the phong shading model and some psudocode for the raymarcher. :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* Reflections demo 1.0\n*/\n\n//CONSTANTS\nconst float GAMMA = 2.2;\n\n// PRIMITIVES\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// SCENE\nvec2 map(vec3 p) {\n  vec3 p1 = p + vec3(-sin(iTime)*.5, 0.0, cos(iTime)*.5-1.3);\n  vec3 p2 = p + vec3(sin(iTime)*.5, 0.0, -cos(iTime)*.5-1.3);\n\n  float sphere1 = sdSphere(p1, 0.25);\n  float sphere2 = sdSphere(p2, 0.25);\n  \n  if (sphere1 < sphere2) {\n    return vec2(sphere1, 0);\n  } else {\n    return vec2(sphere2, 1);\n  }\n}\n\n\n// PHONG MATERIALS\n// Each material has an 'ID'.\n// Each function returns a particular phong component\nvec3 getAmbientColour(float m) {\n  switch(int(m)) {\n    case 0: return vec3(0.5, 0.0, 0.0);\n    case 1: return vec3(0.0, 0.0, 0.5);\n    default: vec3(0.0);\n  }\n}\n\nvec3 getDiffuseColour(float m) {\n    switch(int(m)) {\n      case 0: return vec3(1.0, 0.0, 0.0);\n      case 1: return vec3(0.0, 0.0, 1.0);\n      default: vec3(0.0);\n    }\n}\n\nvec3 getSpecularColour(float m) {\n    switch(int(m)) {\n      case 0: return vec3(1.0, 1.0, 1.0);\n      case 1: return vec3(1.0, 1.0, 1.0);\n      default: vec3(0.0);\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \n  // Calculate normalized 'uv' coordinates that run 0 to 1 but preserve aspect rati\n  //vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  //uv -= 0.5;\n  //uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  //uv = (gl_FragCoord.xy-v2Resolution.xy/2.) / v2Resolution.y;\n \n  // Ray origin (position of the eye/camera)\n  // The camera is moved along the Z-axis as our scene is at the origin by default\n  vec3 ro = vec3(0.0, 0.0, -2.0);\n  \n  \n  // Calulate ray direction\n  vec2 xy = gl_FragCoord.xy - iResolution.xy * .5;\n  float z = iResolution.y / tan(radians(45.0) * .5);\n  vec3 rd = normalize(vec3(xy,z));\n  \n  \n  // Set starting depth (this is the depth of the intersection plane)\n  float dep = 1.0;\n  bool hit = true;\n  float m;\n  // A higher number of iterations make for a more accurate raymarch at the expense\n  // of performance.\n  for (int i=0; i<96; i++)\n  {\n      // Get the current minimum distance to our scene from the ray origin)\n      vec2 o = map(ro + dep * rd);\n      float d = o.x;\n      m = o.y;\n    \n      // If we're suuuuueper close, finish marching\n      if (d < .001) break;\n    \n      // March forward the current minimum distance the the scene\n      dep += d;\n    \n      // If we go too far we're probably not going to hit the scene so we can stop.\n      // Setting the depth to 0 just helps us use bool() function to determine if we hit\n      // out scene. If it's anything other than 0, it's the depth we had to travel.\n      if (dep >= 100.0) {\n        hit=false;\n        break;\n      }\n  }\n \n\n  // Normal estimation\n  vec3 p = ro + (dep) * rd;\n  vec2 e = vec2(.001, 0.);\n  vec3 normal = normalize(vec3(\n      map(p+e.xyy).x - map(p-e.xyy).x,\n      map(p+e.yxy).x - map(p-e.yxy).x,\n      map(p+e.yyx).x - map(p-e.yyx).x\n  ));\n\n  // Phong time!\n  // Here, given an ambient lighting value, we'll calculate the colour value that we add based on\n  // the light position as well as diffuse, specular and alpha components.\n  const vec3 ambientLux = vec3(0.45);\n\n  \n  vec3 ka = getAmbientColour(m);\n  vec3 colour = ambientLux * ka;\n\n  // Take the ambient intensity and multiply by the ambient colour. This is a 'starting point'\n  // We shall add the diffuse and specular components on top, depending on p.\n  vec3 kd = getDiffuseColour(m);\n  vec3 ks = getSpecularColour(m);\n  float alpha = 600.0;\n  \n  // Now that we've set up the differnt phong component colours, we can actually calculate the\n  // diffuse and specular additions.\n  // L = Light direction vector\n  // V = 'View vector'\n  // R = 'reflection vector'\n  \n  \n  vec3 lightPos = vec3(0.1, 0.5, -0.5);\n  float lightInt = 0.6;\n  vec3 L = normalize(lightPos - p);\n  vec3 V = normalize(ro - p);\n  vec3 R = normalize(reflect(-L, normal));\n  \n  // Now we calculate some dot-products of the vectors above. Specifically:\n  // Dot-prod of light^normal\n  // Dor-prod of reflection^view\n  float dotLN = dot(L, normal);\n  float dotRV = dot(R, V);\n  \n  \n\n\n\n  // Now that we've set the colour of the object at first hit, we need to march again\n  // until we hit another object. We can then take the colour of that object and mix it\n  // with the first hit colour to get a 'reflection'\n\n  // Only do a second march if we hit the scene in the first\n  bool hit2=false;\n  if (bool(dep)) {\n    hit2 = true;\n    dep = 1.0;\n    for (int i=0; i<48; i++)\n    {\n      // We need to set the ray origin to equal R\n      vec2 o = map(p + dep * R);\n      float d = o.x;\n      m = o.y;\n   \n      // If we're suuuuueper close, finish marching\n      if (d < .001) break;\n\n      // March forward the current minimum distance the the scene\n      dep += d;\n\n      // If we go too far we're probably not going to hit the scene so we can stop.\n      // Setting the depth to 0 just helps us use bool() function to determine if we hit\n      // out scene. If it's anything other than 0, it's the depth we had to travel.\n      if (dep >= 100.0) {\n        hit2=false;\n        break;\n      }\n    }\n  }\n  \n  \n    \n  // If we hit another object again, go get the colour\n  if (hit2) {\n     kd += getDiffuseColour(m) * 3.0; \n  }\n  \n  // If the light is 'behind' the surface, we don't want to add any light\n  if (dotLN < 0.0) colour += vec3(0.0);\n  else if (dotRV < 0.0) colour += (lightInt * kd * dotLN);\n  else colour += lightInt * (kd * dotLN + ks * pow(dotRV, alpha));\n    \n  fragColor = vec4(pow(colour.rgb, vec3(1.0/GAMMA)), 1.0);\n\n  // If we hit the scene, draw colour, else black. At this point we would do lighting calculations\n  // and give what appears to be a '2D' object in our render some shadows.\n  if (bool(hit)) {\n      fragColor = vec4(colour, 1.0);\n  } else {\n      fragColor = vec4(vec3(0.0), 1.0);\n  }\n}","name":"Image","description":"","type":"image"}]}