{"ver":"0.1","info":{"id":"ttjSRc","date":"1566665430","viewed":131,"name":"noisy convolutions","username":"hexjay","description":"Yet another raymarching experiment based on Inigo Quilez's code.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\tYet another raymarching experiment based on IQ and @paulofalcao's code.\n*/\n\nconst int ITER = 20;\nconst float PI = 3.14159265;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.9 );\n\n\nvec2 r2(vec2 v, float a) \n{\n\tmat2 m = mat2 (\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t\t);\n\treturn m*v;\n}\n\nfloat ss(float mi,float ma,float a)\n{ // sineSignal (min,max,alpha)\n\treturn (sin(a)+1.)*(ma-mi)*0.5+mi;\n}\n\n\n//   /\n//---  Noise\n//   \\\n\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec2 p )\n{\n\tp*=3.;\n\tfloat f = 0.0;\n    f += 0.25000*noise( p ); p = m2*p*0.02;\n    f += 0.12500*noise( p ); p = m2*p*0.13;\n    f += 0.06250*noise( p ); p = m2*p*0.01;\n    f += 0.03125*noise( p ); p = m2*p*0.04;\n    f += 0.01500*noise( p );\n    return f/0.38375;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//    /\n// ---  Field\n//    \\\n\nfloat distanceField(in vec3 p) \n{\n  \tfloat s = 8.; // spacing\n  \tfloat d = cos(p.x*0.05);\n  \tfloat rs = 0.25 * iTime+ d; // rotating speed\n  \tvec2 pos; // yz\n  \n  \tfloat a = rs+d;  \n  \tpos = s*vec2( sin(a) , cos(a));\n\n  \tfloat r = 2.5;\n  \tfloat res;\n\t\n  \t// a simple cylinder would go like this :  length(p.yz+pos)-r  \n  \t// here is 4 cylinders with displacements :\n\n  \tfloat ssf =  ss(0.,1.,p.y*2.) * sin(p.x+iTime);\n  \tfloat w = fbm(p)*2.;\n\n  \tres = \n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\n  \ta = rs+PI*1.0+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res2 =\n\t  \t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\t\n\ta = rs+PI*0.50+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res3 =\n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\t\n  \ta = rs+PI*1.50+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res4 =\n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\n  \tres = min(res,res4);\n  \tres = min(res,res3);\n  \tres = min(res,res2);\n  \treturn res;\n}\n\nvec3 getColor(in vec3 p)\n{\n\tvec3 res = vec3(1.,0.2,0.) * 2.;\n  \tfloat m = mod(sin(p.x),2.);\n  \tfloat n = fbm(p);\n  \tfloat g = fbm(vec3(p.x*iTime*2000.,1.,1.))*2.;\n  \tres = res*n*m*(g*2.+1.);\n  \treturn res;\n}\n\n//    /\n// ---  Main\n//\t  \\\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \tvec3 bgColor = vec3 (0.1,0.0,0.0);\n\n  \tvec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  \tvec3 finalColor = vec3 (0.0);  \n  \n  \t//Camera animation\n  \tvec3 vuv=vec3(0,1,0);//Change camere up vector here\n  \tfloat s0 = ss(-15.,+15.,iTime*0.1);\n\t\n  \tvec3 prp=vec3(s0,0.,ss(3.,13.,iTime*0.13)); //Change camera path position here\n  \tvec3 vrp=vec3(sin(iTime*0.002)*2.,cos(iTime)*2.,0); //Change camere view here\n\n  \t//Camera setup\n  \tvec3 vpn=normalize(vrp-prp);\n  \tvec3 u=normalize(cross(vuv,vpn));\n  \tvec3 v=cross(vpn,u);\n  \tvec3 vcv=(prp+vpn);\n  \tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp=normalize(scrCoord-prp);\n\n  \t//Raymarching\n  \tconst vec3 e=vec3(0.1,0,0);\n  \tconst float maxd=30.0; //Max depth\n\n  \tfloat s= 0.1;\n  \tvec3 c,p,n;\n\n  \tfloat f=1.0;\n  \tfor(int i=0;i<  ITER ; i++)\n    {\n    \tif (abs(s)<.01||f>maxd) break;\n    \tf+=s;\n    \tp=prp+scp*f;\n    \ts=distanceField(p);\n  \t}\n\n  \tif (f<maxd)\n    {\n    \tc=getColor(p);\t// cylinder color\n    \tn=normalize(\n      \tvec3(s-distanceField(p-e.xyy),\n        \ts-distanceField(p-e.yxy),\n        \ts-distanceField(p-e.yyx)));\n    \tfloat b=dot(n,normalize(prp-p));\n\n    \tvec3 finalColor = vec3( b*c+pow(b,8.0))*(1.0-f*.02) ;  //simple phong LightPosition=CameraPosition\n\n\t\tfinalColor*=0.44;\n    \tfragColor = vec4( finalColor, 1.);\n  \t} else \n    { // background color\n    \tbgColor = \n\t  \tvec3(0.7,0.2,0.1);\n\t  \tfloat n = fbm(p);\n      \tbgColor = vec3(n)*bgColor*f/60.;\n\t  \tfragColor=vec4(bgColor,1.);\n  \t}\n}","name":"Image","description":"","type":"image"}]}