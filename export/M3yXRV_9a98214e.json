{"ver":"0.1","info":{"id":"M3yXRV","date":"1720174550","viewed":28,"name":"SunRise SunSet","username":"Toum","description":"Projet OPEN-GL\nSamuel M. - Tom P.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sunset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fonction principale\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // Initialisation\n    vec3 rayOrigin = vec3(0, 4, -8);           // Origine rayon\n    \n    float fov = 45.0; // champ de vision en degrés\n    vec3 rayDirection = getRayDirection(fragCoord, iResolution.xy, fov);\n\n    vec3 col = vec3(0);                 // Couleur du pixel\n\n    float t = 0.0; // Distance parcourue totale\n    float time = iTime;\n    \n    initializeStarList();\n    \n    // Elements de la scene\n    SceneElement elements[numElements];\n    elements[0] = SceneElement(SPHERE, vec3(100.0 * sin(time * vitesseLuneSoleil), 50.0 * cos(time * vitesseLuneSoleil), 50.0), 10.0, vec3(0.0), vec3(1.0, 0.8, 0.6), 0.0); // Soleil\n    elements[1] = SceneElement(SPHERE, vec3(100.0 * sin(time * vitesseLuneSoleil + 3.14), 50.0 * cos(time * vitesseLuneSoleil + 3.14), 50.0), 10.0, vec3(0.0), vec3(0.6, 0.8, 1.0), 0.0); // Lune\n    elements[2] = SceneElement(PLANE, vec3(0.0), 1.0, vec3(0, 1, 0), vec3(1.0, 0.0, 0.0), 0.0);\n    elements[3] = SceneElement(WATER, vec3(0.0), 0.0, vec3(0.0), vec3(0.25, 0.4, 1.0), 0.15);\n\n    SceneElement sun = elements[0];\n    SceneElement moon = elements[1];\n    \n    float hauteurSoleil = normalize(sun.position).y;\n    \n    float distanceMinSoleil = MAX_DIST;\n    float distanceMinLune = MAX_DIST;\n    \n    bool sendRay = true;\n    float percentColor = 1.0;\n    vec3 finalColor = vec3(0.);\n    int bounceRestant = 3;\n    \n    // Raymarching\n    while (sendRay) {\n        sendRay = false;  // Pas de bounce par defaut\n        \n        for (int i = 0; i < 100; i++) {\n            vec3 p = rayOrigin + rayDirection * t;     // Position du point le long du rayon\n\n            float d = map(p, time, elements, numElements);   // Distance a l'element le plus proche\n\n            t += d;                   // On avance dans le rayon\n\n            distanceMinSoleil = min(distanceMinSoleil, sdSphere(p - sun.position, sun.size));\n            distanceMinLune = min(distanceMinLune, sdSphere(p - moon.position, moon.size));\n\n            if (d < MIN_DIST) break;      // Arret si on touche un objet\n            if (t > MAX_DIST) break;      // Arret si on va trop loin\n        }\n\n        vec3 p = rayOrigin + rayDirection * t; // Position au niveau de l'intersection\n        \n       \n    \n        // Update couleur\n        sun.color = get_sunColor(p, hauteurSoleil);\n        elements[0].color = get_sunColor(p, hauteurSoleil);\n\n\n        // Si on a touché un objet\n        if (t < MAX_DIST) {\n            \n            SceneElement objHit;\n            for (int i = 0; i < numElements; i++) {\n                if (objectHit(p, elements[i], elements, time)) {\n                    objHit = elements[i];\n                    break;\n                }\n            }\n            \n        \n            vec3 normal = normalize(vec3(\n                map(p + vec3(MIN_DIST, 0, 0), time, elements, numElements) - map(p - vec3(MIN_DIST, 0, 0), time, elements, numElements),\n                map(p + vec3(0, MIN_DIST, 0), time, elements, numElements) - map(p - vec3(0, MIN_DIST, 0), time, elements, numElements),\n                map(p + vec3(0, 0, MIN_DIST), time, elements, numElements) - map(p - vec3(0, 0, MIN_DIST), time, elements, numElements)\n            ));\n\n\n            // -- SOLEIL / LUNE --\n\n            vec3 sunDir = normalize(sun.position - p);\n            vec3 moonDir = normalize(moon.position - p);\n\n\n            // -- CALCUL LUMIERE --\n\n            vec3 lightColor = calculateLight(p, normal, sunDir, sun.color) + \n                              calculateLight(p, normal, moonDir, moon.color);\n\n            col = lightColor;\n\n    \n            // -- COULEUR OBJET --\n\n            col *= objHit.color;\n\n\n            // -- COULEUR SPECIAL --\n        \n            // Pixels de Soleil\n            if (objectHit(p, sun, elements, time)) {\n                col = sun.color;\n            }\n\n            // Pixels de lune\n            if (objectHit(p, moon, elements, time)) {\n                float coeff = (8.0 + 1.0 * max(abs(dot(normal, rayDirection)), 0.0)) / 9.0;\n                col = moon.color * coeff;\n            }\n            \n            \n            // -- AJOUT A LA COULEUR FINALE --\n            \n            if (objHit.reflCoeff > 0.0 && bounceRestant > 0) {\n                finalColor += col * percentColor * (1.0 - objHit.reflCoeff);\n                percentColor *= objHit.reflCoeff;\n                \n                // Rayon reflechi\n                rayDirection = normalize(reflect(rayDirection, normal));\n                rayOrigin = p + rayDirection * 3.0 * MIN_DIST;\n                \n                // Reinitialisation variables\n                col = vec3(0);\n                t = 0.0;\n                distanceMinSoleil = MAX_DIST;\n                distanceMinLune = MAX_DIST;\n                bounceRestant -= 1;\n                \n                sendRay = true;\n            } else {\n                finalColor += col * percentColor;\n            }\n            \n        } else {  // COULEUR DE FOND\n\n            // -- FOND QUI CHANGE DE COULEUR --\n\n            col = get_backgroundColor(sun, moon, p, t, hauteurSoleil);\n            vec2 pos = vec2(p.x, p.y) / t;\n            col = get_starColor(pos, col);\n\n            // -- SHINE SUN / MOON --\n\n            // Effet shine du soleil\n            float sunMixCoeff = exp(-distanceMinSoleil / 5.0);\n            col = sunMixCoeff * sun.color + (1.0 - sunMixCoeff) * col;\n\n            // Effet shine de la lune\n            float moonMixCoeff = exp(-distanceMinLune / 3.0) - 0.1;\n            col = moonMixCoeff * moon.color + (1.0 - moonMixCoeff) * col;\n            \n            // -- AJOUT COULEUR --\n            finalColor += col * percentColor;\n        }\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_DIST 150.\n#define MIN_DIST 0.001\n\nconst float vitesseLuneSoleil = 0.2;\n\n// Types d'éléments de la scène\nconst int SPHERE = 0;\nconst int PLANE = 1;\nconst int WATER = 2;\n\nconst int numElements = 4;\n\n// Structure pour un élément de la scène\nstruct SceneElement {\n    int type;\n    vec3 position;\n    float size;\n    vec3 normal; // seulement utilisé pour les plans\n    vec3 color;\n    float reflCoeff;\n};\n\n\n// Etoiles\nfloat starSeed = 42.0;\nconst int numStars = 100;\nvec2 starList[numStars];\nbool starList_initialized = false;\nfloat starSize = 0.002;\n\n\n// Signed distance function for a sphere\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s; // distance to a sphere of radius s\n}\n\n\n// Signed distance function for a plane\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    // n doit etre normalise\n    return dot(p, n) + h;\n}\n\n\n// Pseudo-random function\nfloat random(float seed) {\n    return fract(sin(seed) * 43758.5453);\n}\n\n\n// Water surface distance function\nfloat sdWater(vec3 p, float t) {\n    float waveHeight = 0.2;\n    float waveLength = 2.0;\n    float speed = 2.0;\n    return p.y - (sin(p.x / waveLength + t * speed) + sin(p.z / waveLength + t * speed)) * waveHeight;\n}\n\n\n// Water surface distance function\nfloat sdWater2(vec3 p, float t) {\n    float waveHeight = 0.4;\n    float waveLength = 3.0;\n    float speed = 3.0;\n    return p.y - (cos(p.x / waveLength + t * speed) + cos(p.z / waveLength + t * speed)) * waveHeight;\n}\n\n\n// Scene distance function\nfloat map(vec3 p, float time, SceneElement elements[numElements], int numElements) {\n\n    // Initialisation de la distance min au point le plus loin\n    float minDist = MAX_DIST;\n    for (int i = 0; i < numElements; i++) {\n    \n        // On recupere la distance du point a l'element i\n        float dist;\n        SceneElement element = elements[i];\n        if (element.type == SPHERE) {\n            dist = sdSphere(p - element.position, element.size);\n        } else if (element.type == PLANE) {\n            dist = sdPlane(p, element.normal, element.size);\n        } else if (element.type == WATER) {\n            dist = min(sdWater(p, time) * sdWater2(p, time), sdWater(p, time));\n        }\n        \n        // On met en distance min si besoin\n        minDist = min(minDist, dist);\n    }\n    return minDist;\n\n}\n\n\n// Calcule les lumieres\nvec3 calculateLight(vec3 p, vec3 normal, vec3 lightDir, vec3 lightColor) {\n    float diff = max(dot(normal, lightDir), 0.0);\n    return diff * lightColor;\n}\n\n\n// Avoir la couleur du soleil en fonction de la hauteur\nvec3 get_sunColor(vec3 p, float hauteurSoleil) {\n    float hOffset = 0.6;\n    \n    float red = 1.0;\n    float green = 0.85 * min(max(hauteurSoleil + hOffset, 0.0), 1.0);\n    float blue = 0.7 * min(max(hauteurSoleil + hOffset, 0.0), 1.0);\n    \n    return vec3(red, green, blue);\n}\n\n\n// Couleur du fond en fonction de l'emplacement de la lune et du soleil\nvec3 get_backgroundColor(SceneElement sun, SceneElement moon, vec3 p, float t, float hauteurSoleil) {\n    float coefficient_tu_coco = 108.0;  // Offset dans l'exponentielle pour que le coucher / lever de soleil soit ok\n\n    // Distance custom a la lune / au soleil\n    float distX = moon.position.x - 2.0 * p.x / t;\n    float distY = moon.position.y - 2.0 * p.y / t;\n\n    float coeffX = min(exp(-abs(distX - coefficient_tu_coco) / 10.0), 0.4);\n    if (moon.position.x < 0.0) {\n        coeffX = min(exp(-abs(distX + coefficient_tu_coco) / 10.0), 0.4);\n    }\n\n    float coeffY = min(exp(-abs(distY - coefficient_tu_coco) / 10.0), 0.4);\n    if (moon.position.y < 0.0) {\n        coeffY = min(exp(-abs(distY - coefficient_tu_coco) / 10.0), 0.4);\n    }\n\n    float hOffset = 0.1;\n\n    float red = (coeffX + coeffY) * 0.5;\n    float green = 0.1 + 0.4 * (hauteurSoleil + hOffset);\n    float blue = 0.2 + 0.8 * (hauteurSoleil + hOffset);\n    \n    return vec3(red, green, blue); // Background color\n        \n}\n\n\n// Renvoie true si l'objet est touche\nbool objectHit (vec3 p, SceneElement obj, SceneElement elements[numElements], float time) {\n    float dist = MAX_DIST;\n    \n    if (obj.type == SPHERE) {\n        dist = sdSphere(p - obj.position, obj.size);\n    } else if (obj.type == PLANE) {\n        dist = sdPlane(p, obj.normal, obj.size);\n    } else if (obj.type == WATER) {\n        dist = min(sdWater(p, time) * sdWater2(p, time), sdWater(p, time));\n    }\n    \n    return dist == map(p, time, elements, numElements);\n}\n\n// Couleur de l'etoile\nvec3 get_starColor(vec2 p, vec3 skyColor) {\n    vec3 finalColor = skyColor;\n    float skyIntensity = max(max(skyColor.x, skyColor.y), skyColor.z);\n    \n    if (skyIntensity < 0.2) {\n        float starIntensity = (0.2 - skyIntensity) * 5.0; // Pour une plage de 0.0 a 1.0\n        \n        for (int i = 0; i < numStars; i++) {\n            if (length(starList[i] - p) < starSize) {\n                return vec3(starIntensity);\n            }\n        }\n    }\n    return finalColor;\n}\n\n\n// Initialise si besoin la liste des etoiles\nvoid initializeStarList() {\n    if (!starList_initialized) {\n        for (int i = 0; i < numStars; i++) {\n            starList[i] = vec2(1.0 - 2.0 * random(starSeed), random(starSeed * 2.0));\n            starSeed *= 1.23456;\n        }\n        \n        starList_initialized = true;\n    }\n}\n\n\nvec3 getRayDirection(vec2 fragCoord, vec2 resolution, float fov) {\n    // Normalisation des coordonnées de l'écran\n    vec2 uv = (fragCoord * 2.0 - resolution.xy) / resolution.y;\n\n    // Calcul de la direction du rayon en tenant compte du FOV\n    float aspectRatio = resolution.x / resolution.y;\n    float scale = tan(radians(fov * 0.5));\n    vec3 rayDir = normalize(vec3(uv * scale * aspectRatio, 0.65));\n    return rayDir;\n}\n\n\n","name":"Common","description":"","type":"common"}]}