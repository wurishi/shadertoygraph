{"ver":"0.1","info":{"id":"3tjcRy","date":"1594706977","viewed":94,"name":"ValueNoise Sample","username":"Johnblu","description":"value噪音的几种表现形式","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash21(vec2 p)\n{\n    p = vec2( dot(p,vec2(612.1,946.7)),\n              dot(p,vec2(235.5,-354.3)));\n    \n    float vertexValue = -1.0 + 2.0 * fract(sin(p.x + p.y)*(4558.5353));\n    //以下是以三角函数改变顶点伪随机量的方式让纹理动起来，但是会出现周期性\n    //还有种让纹理动起来的方式是用更高维度的噪音图，其中一个维度是时间维度\n    vertexValue = sin(vertexValue * 3.1415926 + iTime);\n    return vertexValue;\n}\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\t\n    //以下两个是前人提出的缓和曲线\n    //vec2 w = pf * pf * (3.0 - 2.0 * pf);\t//一阶导数连续\n    vec2 w = pf * pf * pf * (pf * pf * 6.0 - pf * 15.0 + 10.0);\t//二阶导数连续\n\n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x), \n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (vec2(fragCoord.x, fragCoord.y) / min(iResolution.x, iResolution.y));\n\tvec2 mouseUv = (vec2(iMouse.x, iMouse.y) / min(iResolution.x, iResolution.y));\n    \n    if(mouseUv.x < 1e-4 && mouseUv.y < 1e-4)\n    {\n        mouseUv = vec2(iResolution.x / iResolution.y * 0.5,0.5);\n    }\n    \n    vec2 divisionUv = uv;\n    uv = uv * (6.0);\n    float result = 0.0;\n    if(divisionUv.x < mouseUv.x && divisionUv.y > mouseUv.y)\n    {\n        result = value_noise(uv);\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x < mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * value_noise(uv);\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * value_noise(uv);\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * value_noise(uv);\t\tuv *= 2.0;\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x > mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    }\n\telse\n    {\n        result += 4.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n        \n        result = cos(result + uv.x * 0.1);\n    }\n    \n    fragColor = vec4(result,result,result,1);\n    float divisionLine = (1.0 - abs(mouseUv.x - divisionUv.x) * 400.0)\n        * (1.0 - abs(mouseUv.y - divisionUv.y) * 400.0);\n    divisionLine = clamp(divisionLine,0.0,1.0);\n    fragColor = mix(vec4(1,1,1,1),fragColor,divisionLine);\n}","name":"Image","description":"","type":"image"}]}