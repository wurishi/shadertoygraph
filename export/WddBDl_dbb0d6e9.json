{"ver":"0.1","info":{"id":"WddBDl","date":"1606272525","viewed":197,"name":"Truchas Tracer","username":"LiamHz","description":"My first path tracer :)","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    float EXPOSURE = 0.5;\n    col *= EXPOSURE;\n    col = ACESFilm(col);\n    col = LinearToSRGB(col);\n    fragColor = vec4(col, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n#define N_BOUNCES 8\n#define MIN_RAY_DIST 0.001\n#define MAX_RAY_DIST 10000.0\n#define NUM_RENDERS_PER_FRAME 4\n#define ENABLE_AA true\n#define ENABLE_RUSSIAN_ROULETTE true\n\n// Function to generate random numbers in a shader\nuint wang_hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state) {\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 2.0 * PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct MaterialInfo {\n    vec3 diffuse;\n    vec3 emissive;\n    vec3 specular;\n    float percentSpec;\n    float roughness;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    MaterialInfo mat;\n};\n\nstruct HitInfo {\n    bool didHit;\n    vec3 normal;\n    vec3 hitPoint;\n    MaterialInfo mat;\n};\n\nHitInfo sphereIntersect(vec3 rayOrigin, vec3 rayDir, Sphere sphere) {\n    vec3 oc = rayOrigin - sphere.pos;\n    float a = dot(rayDir, rayDir);\n    float half_b = dot(oc, rayDir);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n    float discriminant = half_b*half_b - a*c;\n\n    bool didHit = discriminant > 0.0 ? true : false;\n\n    // Find the nearest root in the acceptable range\n    float sqrtd = sqrt(discriminant);\n    float root = (-half_b - sqrtd) / a;\n    if (root < MIN_RAY_DIST || root > MAX_RAY_DIST) {\n        root = (-half_b + sqrtd) / a;\n        if (root < MIN_RAY_DIST || root > MAX_RAY_DIST) {\n            didHit = false;\n        }\n    }\n\n    vec3 hitPoint = rayOrigin + rayDir*root;\n    // Normal is the vector going from the center of the sphere to the hit point\n    vec3 normal = (hitPoint - sphere.pos) / sphere.radius;\n\n    return HitInfo(didHit, normal, hitPoint, sphere.mat);\n}\n\nvec3 scene(vec3 rayOrigin, vec3 rayDir, inout uint rngState) {\n    int nSpheres = 10;\n    Sphere spheres[16];\n\n    MaterialInfo metalYellow = MaterialInfo(vec3(0.9, 0.9, 0.5), vec3(0), vec3(0.9), 0.1, 0.2);\n    MaterialInfo metalMagenta = metalYellow;\n    MaterialInfo metalCyan  = metalYellow;\n    metalMagenta.diffuse = vec3(0.9, 0.5, 0.9);\n    metalMagenta.percentSpec = 0.3;\n    metalMagenta.roughness = 0.2;\n    metalCyan.diffuse  = vec3(0.5, 0.9, 0.9);\n\n    MaterialInfo matteWhite = MaterialInfo(vec3(1.0), vec3(0), vec3(0), 0.0, 0.0);\n    MaterialInfo matteRed   = matteWhite;\n    MaterialInfo matteGreen = matteWhite;\n    matteRed.diffuse   = vec3(1.0, 0.2, 0.2);\n    matteGreen.diffuse = vec3(0.2, 1.0, 0.2);\n\n    MaterialInfo lightSource = MaterialInfo(vec3(0), vec3(1.0, 0.9, 0.7), vec3(0), 0.0, 0.0);\n\n    // Light Sources\n    spheres[0] = Sphere(vec3(0, 18, 24), 10.0, lightSource);\n    spheres[1] = Sphere(vec3(0, 16, 6), 10.0, lightSource);\n\n    // Walls\n    spheres[2] = Sphere(vec3(-108, 0, 30), 100.0, matteRed);\n    spheres[3] = Sphere(vec3( 108, 0, 30), 100.0, matteGreen);\n    spheres[4] = Sphere(vec3(0, 0,  136), 100.0, matteWhite);\n    spheres[5] = Sphere(vec3(0, -103, 30), 100.0, matteWhite);\n    spheres[6] = Sphere(vec3(0,  125.5, 30), 100.0, matteWhite);\n\n    // Subjects\n    spheres[7] = Sphere(vec3(-6, -1.6, 24), 2.0, metalYellow);\n    spheres[8] = Sphere(vec3( 0, -1.6, 20), 2.0, metalMagenta);\n    spheres[9] = Sphere(vec3( 6, -1.6, 24), 2.0, metalCyan);\n\n    vec3 col = vec3(0);\n    vec3 throughput = vec3(1);\n\n    // Test for ray intersection against all spheres in scene\n    // Set the ray color to the closest hit object in the scene\n    // Note, without IBL, non-enclosed spaces will often appear\n    // dark as rays will quickly bounce out of the scene\n    for (int nBounce=0; nBounce <= N_BOUNCES; nBounce++) {\n        float closestHit = MAX_RAY_DIST;\n        HitInfo hitInfo;\n\n        for (int i=0; i<nSpheres; i++) {\n            HitInfo h = sphereIntersect(rayOrigin, rayDir, spheres[i]);\n            float rayDist = length(rayOrigin-h.hitPoint);\n            if (h.didHit && rayDist < closestHit && rayDist > MIN_RAY_DIST) {\n                closestHit = rayDist;\n                hitInfo = h;\n            }\n        }\n\n        // No objects hit\n        if (closestHit == MAX_RAY_DIST) {\n            break;\n        }\n\n        // Bounce ray\n        rayOrigin = hitInfo.hitPoint;\n\n        // Decide if ray will be diffuse or specular\n        bool isSpecRay = (RandomFloat01(rngState) < hitInfo.mat.percentSpec) ? true : false;\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        float specDirMix = hitInfo.mat.roughness * hitInfo.mat.roughness;\n        vec3 specRayDir = normalize(mix(reflect(rayDir, hitInfo.normal), diffuseRayDir, specDirMix));\n        rayDir = isSpecRay ? specRayDir: diffuseRayDir;\n\n        // Add emissive lighting\n        col += hitInfo.mat.emissive * throughput;\n\n\t\t// Propogate strength of light through bounces\n        throughput *= isSpecRay ? hitInfo.mat.specular : hitInfo.mat.diffuse;\n\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        if (ENABLE_RUSSIAN_ROULETTE) {                \n            float p = max(throughput.r, max(throughput.g, throughput.b));\n        \tif (RandomFloat01(rngState) > p)\n            \tbreak;\n\n        \t// Add the energy we 'lose' by randomly terminating paths\n        \tthroughput *= 1.0f / p;   \n        }\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Set random seed based on frag coord and frame number\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) *\\\n                    uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    // Set 2D coordinates to range from -1 to 1\n    // on the x-axis with the center as the origin\n    vec2 fc = fragCoord;\n    if (ENABLE_AA) {\n        // Subpixel antialiasing\n        vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5;\n        fc += jitter;\n    }\n    vec2 uv = (fc - 0.5*iResolution.xy)/iResolution.x;\n\n    // Origin of the rays\n    float fov = 90.0;\n    float camDist = 1.0 / tan(fov * 0.5 * PI / 180.0);\n    vec3 rayOrigin = vec3(0);\n\n    // Get the direction of the ray from the origin to a pixel\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, camDist));\n    vec3 sceneCol = vec3(0);\n    for (int i=0; i<NUM_RENDERS_PER_FRAME; i++) {\n        sceneCol += scene(rayOrigin, rayDir, rngState) / float(NUM_RENDERS_PER_FRAME);\n    }\n    \n    // Average the color of the frames together\n    vec3 lastFrameCol = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    vec3 col = mix(lastFrameCol, sceneCol, 1.0 / float(iFrame+1));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// SRGB\nvec3 LessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}","name":"Common","description":"","type":"common"}]}