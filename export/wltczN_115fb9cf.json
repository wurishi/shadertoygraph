{"ver":"0.1","info":{"id":"wltczN","date":"1608623346","viewed":80,"name":"flowing flower yingyang","username":"rrx","description":"colorful flower with a rotating yinynag","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["floweryinyang"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rot( in vec2 p, in float an )\n{\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat bump(float x)\n{\n    return smoothstep(-1., 0., x) - smoothstep(0., 1., x);\n}\n\nfloat smoothbump(float r, float dr, float d)\n{\n    return smoothstep(r-dr/2., r, d) - smoothstep(r, r+dr, d);\n}\n\nfloat circle(in vec2 uv, in vec2 uv0, in float r, in float w) \n{\n    return smoothbump(r, w, length(uv - uv0));\n}\n\nfloat unit(in float x) \n{\n    return clamp(0.,1.,x);\n}\n\nfloat yinyang(in vec2 uv, in vec2 uv0, in float dr) \n{  \n    // double circles enclosing\n    float t = 0.;//circle(uv, vec2(0.,0.), 1.+dr*2., dr)\n       // + circle(uv, vec2(0.,0.), 1.1, dr);\n        \n    // positions and distances of the circles\n    vec2 uv1 = uv - vec2(.5,0.);\n    vec2 uv2 = uv - vec2(-.5,0.);\n    float d0 = length(uv);\n    float d1 = length(uv1);\n    float d2 = length(uv2);\n   \n    // use atan to determine if we are in the top or bottom half of the circle\n    float a1 = atan(uv1.y, uv1.x);\n    \n    float d3 = 10.;\n    if (a1 < 0.) {\n        // trace the enclosing circle in the top half\n        d3 = d0;\n    } \n    // the tail\n    float t7 = -smoothstep(1.-dr,1.+dr, d3); \n    \n    // add and substract the two circles\n    float t5 = 0.;\n    float t6 = 0.;\n    if (a1 >=0.)\n    {\n        t5 = 1. - smoothstep(.5-dr, .5+dr, d1) ;\n    }\n    else\n    {\n        t6 = smoothstep(.5-dr, .5+dr, d2) - 1.;\n    }\n\n    // left eye\n    float t4 = smoothstep( .1 - dr, .1 + dr, d1);\n\n    // right eye\n    float t2 = 1. - smoothstep( .1 - dr, .1 + dr, d2);\n\n    float h = t + t2 + t4 + t5 + t6 + t7;\n    return h;\n}\n\nfloat petals(in vec2 uv, in vec2 uv0, in float dr)\n{\n    // double circles enclosing\n    float r0 = 1.;\n    float t = 0.;\n    \n    float c0 = 2.*smoothstep(r0,r0+dr, length(uv-uv0));\n    float t1 = 0.;\n    float t2 = 0.;\n    float t3 = 0.;\n    float t4 = 0.;\n    vec2 uv1 = vec2(1.,0.);\n    float alt = 1.;\n\n    float d = length(uv-uv0);\n    if (d > r0) // && d < r2) \n    {\n        float r = sqrt(.5*.5*2.);\n        float petals = 6.*6.;\n        for (float a=0.;a<petals;a+=1.) \n        {\n        \n            float b = mod(a,4.);\n            float c = circle(uv, uv1, r, dr);\n            float d = length(uv - uv1);\n            float step = 1. - smoothstep(r,r+dr,d);\n            {\n                t3 += b*step;\n            }\n            uv1 = rot(uv1, radians(360./petals));\n            alt *= 1.;\n        }\n    }\n    \n    float h = t + t1 + t2 + t3 + t4;\n    if (h > 10.)\n    {\n        return 1.;\n    }\n    else\n    {\n        return 0.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize aspect\n    vec2 R = iResolution.xy;\n    vec2 uvR = ( R - 2.*fragCoord ) / R.y;\n    \n    // rotate the frame\n    float z = 2.2;\n    //vec2 uv = rot(uvR*z,radians(45.));\n    vec2 uv = uvR*z;\n    vec2 uv1 = rot(uv, radians(iTime*5.));\n    \n    vec3 colx = 0.5 + 0.5*cos(iTime+uvR.xyx+vec3(0,2,4));\n    vec3 col0 = vec3(.0);\n    vec3 col1 = vec3(.5,.0,.0);\n    vec3 col2 = vec3(.0,.5, 0.);\n    vec3 col3 = vec3(.3,.1,.5);\n   \n    float dr = 20./R.x;    \n\n    vec2 uv0 = vec2(0.,0.);\n    float h1 = petals(uv, uv0, dr);\n    float h2 = petals(rot(uv,radians(360./6.)), uv0, dr);\n    float h3 = yinyang(uv1*1.04, uv0, dr);\n    \n    float r2 = 1.5;\n    float r1 = 0.9;\n    float t1 = 0.*circle(uv, uv0, r1, dr) + circle(uv, uv0, r2, dr);\n\n    vec3 col = colx*h2 + colx*h1 + colx*t1 + colx*h3;   \n    fragColor = vec4(col/2., 1.);\n}","name":"Image","description":"","type":"image"}]}