{"ver":"0.1","info":{"id":"7ttfDf","date":"1668785358","viewed":47,"name":"Mushrooms with SDF","username":"rcj9719","description":"Mushrooms made of sdf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mushrooom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// If precisions matters to you, the mushrooms are 2.5 units apart.\n// All constants used are [0.0, 0.25, 1.0]\n\n// There was one instance of iTime and one use of cos\n// Everything else is a call to the methods in common,\n// or very basic vector construction / operation\n//\n// My solution was ~20 lines total, including one helper function\n\nfloat sceneSDF(vec3 queryPos)\n{   \n    float plane = planeSDF(queryPos, 0.0);\n    \n    vec3 m1Pos = vec3(0.0, 0.0, 0.0);\n    vec3 m1QPos = bendPoint(queryPos, 0.8f * sin(iTime + 3.14));\n    m1Pos = vec3(0.0, 0.0, 0.0);\n    \n    vec3 m2Pos = vec3(2.5, 0.0, 0.0);\n    vec3 m2QPos = bendPoint(queryPos - m2Pos, 0.8f * sin(iTime));\n    m2Pos = vec3(0.0);\n    \n    vec3 m3Pos = vec3(-2.5, 0.0, 0.0);\n    vec3 m3QPos = bendPoint(queryPos - m3Pos, 0.8f * sin(iTime));\n    m3Pos = vec3(0.0);\n    \n    float mushroom = mushroomSDF(m1QPos, m1Pos, 1.0);\n    float mushroom2 = mushroomSDF(m2QPos, m2Pos, 1.0);\n    float mushroom3 = mushroomSDF(m3QPos, m3Pos, 1.0);\n    return smoothUnion(smoothUnion(smoothUnion(plane, mushroom, 0.1f), mushroom2, 0.1f), mushroom3, 0.1);\n}\n\nRay getRay(vec2 uv) {\n    Ray ray;\n    \n    float len = tan(3.14159 * 0.125) * distance(EYE, REF);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), REF - EYE));\n    vec3 V = normalize(cross(H, EYE - REF));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = REF + uv.x * H + uv.y * V;\n    vec3 dir = normalize(p - EYE);\n    \n    ray.origin = EYE;\n    ray.direction = dir;\n    return ray;\n}\n\nIntersection getRaymarchedIntersection(vec2 uv)\n{\n    Ray ray = getRay(uv);\n    Intersection intersection;\n    \n    vec3 queryPoint = ray.origin;\n    for (int i=0; i < MAX_RAY_STEPS; ++i)\n    {\n        float distanceToSurface = sceneSDF(queryPoint);\n        \n        if (distanceToSurface < EPSILON)\n        {\n            \n            intersection.position = queryPoint;\n            intersection.normal = vec3(0.0, 0.0, 1.0);\n            intersection.distance = length(queryPoint - ray.origin);\n            \n            return intersection;\n        }\n        \n        queryPoint = queryPoint + ray.direction * distanceToSurface;\n    }\n    \n    intersection.distance = -1.0;\n    return intersection;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getSceneColor(vec2 uv)\n{\n    Intersection intersection = getRaymarchedIntersection(uv);\n    \n    DirectionalLight lights[3];\n    vec3 backgroundColor = vec3(0.);\n    lights[0] = DirectionalLight(normalize(vec3(15.0, 15.0, 10.0)),\n                                 SUN_KEY_LIGHT);\n    lights[1] = DirectionalLight(vec3(0., 1., 0.),\n                                 SKY_FILL_LIGHT);\n    lights[2] = DirectionalLight(normalize(-vec3(15.0, 0.0, 10.0)),\n                                 SUN_AMBIENT_LIGHT);\n    \n    lights[0] = DirectionalLight(normalize(vec3(15.0, 15.0, 10.0)),\n                                 SUN_KEY_LIGHT);\n    lights[1] = DirectionalLight(vec3(0., 1., 0.),\n                                 SKY_FILL_LIGHT);\n    lights[2] = DirectionalLight(normalize(-vec3(15.0, 0.0, 10.0)),\n                                 SUN_AMBIENT_LIGHT);\n    backgroundColor = SUN_KEY_LIGHT;\n    \n    vec3 albedo = vec3(0.5);\n    vec3 n = estimateNormal(intersection.position);\n        \n    vec3 color = albedo *\n                 lights[0].color *\n                 max(0.0, dot(n, lights[0].dir));\n    \n    if (intersection.distance > 0.0)\n    { \n        for(int i = 1; i < 3; ++i) {\n            color += albedo *\n                     lights[i].color *\n                     max(0.0, dot(n, lights[i].dir));\n        }\n    }\n    else\n    {\n        color = vec3(0.5, 0.7, 0.9);\n    }\n        color = pow(color, vec3(1. / 2.2));\n        return color;\n}\n\n//Mushroom Model!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make symmetric [-1, 1]\n    uv = uv * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = getSceneColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Smooth combination and SDF geometry operators attributed to Inigo Quilez\n// https://iquilezles.org/ @iquilezles\n\nconst int MAX_RAY_STEPS = 128;\nconst float FOV = 45.0;\nconst float EPSILON = 1e-2;\n\nconst vec3 EYE = vec3(0.0, 2.5, 5.0);\nconst vec3 REF = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_RIGHT = vec3(-1.0, 0.0, 0.0);\nconst vec3 WORLD_FORWARD = vec3(0.0, 0.0, 1.0);\nconst vec3 LIGHT_DIR = vec3(0.6, 1.0, 0.4) * 1.5;\n\n// Want sunlight to be brighter than 100% to emulate\n// High Dynamic Range\n#define SUN_KEY_LIGHT vec3(0.6, 1.0, 0.4) * 1.5\n// Fill light is sky color, fills in shadows to not be black\n#define SKY_FILL_LIGHT vec3(0.7, 0.2, 0.7) * 0.2\n// Faking global illumination by having sunlight\n// bounce horizontally only, at a lower intensity\n#define SUN_AMBIENT_LIGHT vec3(0.6, 1.0, 0.4) * 0.2\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection \n{\n    vec3 position;\n    vec3 normal;\n    float distance;\n    int material_id;\n};\n\nstruct DirectionalLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\n\nfloat sphereSDF(vec3 query_position, vec3 position, float radius)\n{\n    return length(query_position - position) - radius;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 center)\n{\n  p -= center;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat planeSDF(vec3 queryPos, float height)\n{\n    return queryPos.y - height;\n}\n\n\nfloat capsuleSDF( vec3 queryPos, vec3 a, vec3 b, float r )\n{\n  vec3 pa = queryPos - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat smoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nvec3 bendPoint(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat hemisphereSDF(vec3 query_position, vec3 position, float radius)\n{\n    float sphere = sphereSDF(query_position, position, radius);\n    float box = sdBox(query_position, vec3(radius, radius, radius), position - vec3(0, radius, 0));\n    return smoothSubtraction(box, sphere, 0.1f);\n}\n\n\nfloat mushroomSDF(vec3 query_position, vec3 position, float radius)\n{\n    position.y += 1.0;\n    float hemi = hemisphereSDF(query_position, position, radius);\n    float capsule = capsuleSDF(query_position, position, position - vec3(0.0, 2.f, 0.0), radius * 0.3f);\n    return smoothUnion(capsule, hemi, 0.1f);\n    \n}","name":"Common","description":"","type":"common"}]}