{"ver":"0.1","info":{"id":"WsySzw","date":"1581561482","viewed":317,"name":"Procedural Planet","username":"lesleylai","description":"A Procedural Planet under construction","likes":6,"published":1,"flags":16,"usePreview":0,"tags":["procedural","raymarching","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ENABLE_WATER\n\n// Rotation of the planet\nmat3 planetRotation;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Material {\n    vec3 color;\n};\n    \nstruct HitRecord {\n    float distance;\n    vec3 position;\n    vec3 normal;\n    Material mat;\n};\n\nconst float waterLine = 0.84;\nconst float forestLine = 0.85;\nconst float snowLine = 0.9;\n\nconst Material forestMaterial = Material(vec3(0.05, 0.2, 0.05));\nconst Material dirtMaterial = Material(vec3(0.6, 0.46, 0.32));\nconst Material snowMaterial = Material(vec3(1.0, 1.0, 1.0));\nconst Material waterMaterial = Material(vec3(0.0, 0.15, 0.30));\n\nconst float waterRefractionIndex = 1.33;\n\nMaterial mixMaterials(Material x, Material y, float a) {\n\tvec3 color = mix(x.color, y.color, a);\n    return Material(color);\n}\n\n// Returns a point at distance units along the ray.\nvec3 getPoint(Ray ray, float t) {\n    return ray.origin + t * ray.direction;\n}\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n// Fractal Brownian Motion\nfloat fbm6(vec3 x) {\n    const int noise_octaves_count = 6;\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < noise_octaves_count; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat pow3(float f) {\n    return f * f * f;\n}\n\nfloat waterSdf(vec3 p, out Material material) {\n    float radius = waterLine + sin(p.x * 30. + iTime) / 400.0 + cos(p.y * 30. + p.z * 30.) / 400.0;\n    material = waterMaterial;\n    return length(p) - radius;\n}\n\nfloat terrainElevation(vec3 p) {\n    vec3 surfaceLocation = normalize(p);\n    float elevation = 1.0 - fbm6(surfaceLocation * 4.0);\n    return pow3(elevation) * 0.25 + 0.8;\n}\n\n// Signed distance function describing the terrain.\nfloat terrainSdf(vec3 p, out Material material) {\n    float elevation = terrainElevation(p);\n    \n    if (elevation < forestLine) {\n        material = forestMaterial;\n    } else if (elevation < snowLine) {\n        material = mixMaterials(forestMaterial, dirtMaterial, (elevation - forestLine) / (snowLine - forestLine));\n    } else {\n        material = snowMaterial;\n    }\n    \n    float radius = elevation;\n    return length(p) - radius;\n}\n\n\nconst vec3 eye = vec3(0.0, 0.0, 5.0);\n\nvec3 blinnPhong(vec3 pos, vec3 normal, vec3 eye, vec3 color) {\n    vec3 lightPos = vec3(0.0, 0.0, -5.0);\n    \n    // ambient\n    vec3 ambient = 0.4 * color;\n    // diffuse\n    vec3 lightDir = normalize(lightPos - pos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * color;\n    // specular\n    vec3 viewDir = normalize(eye - pos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n    vec3 specular = vec3(0.3) * spec; // assuming bright white light color\n    \n    return ambient + diffuse + specular;\n}\n\n\n// normal function from Graphics Codex\nvec3 terrianNormal(vec3 p) {\n    p = normalize(p);\n    const float e = 1e-2;\n    const vec3 u = vec3(e, 0, 0);\n    const vec3 v = vec3(0, e, 0);\n    const vec3 w = vec3(e, 0, e);\n    \n    Material mat;\n    \n    return normalize(vec3(\n        terrainSdf(p + u, mat) - terrainSdf(p - u, mat),\n        terrainSdf(p + v, mat) - terrainSdf(p - v, mat),\n        terrainSdf(p + w, mat) - terrainSdf(p - w, mat)));\n}\n\nvec3 waterNormal(vec3 p) {\n    p = normalize(p);\n    const float e = 1e-2;\n    const vec3 u = vec3(e, 0, 0);\n    const vec3 v = vec3(0, e, 0);\n    const vec3 w = vec3(e, 0, e);\n    \n    Material mat;\n    \n    return normalize(vec3(\n        waterSdf(p + u, mat) - waterSdf(p - u, mat),\n        waterSdf(p + v, mat) - waterSdf(p - v, mat),\n        waterSdf(p + w, mat) - waterSdf(p - w, mat)));\n}\n\n/*\n * Ray marching for the scene\n */\nconst int maxIteration = 50;\nconst float epsilon = 1e-3;\nconst float maxDist = 100.;\n\nbool traceTerrain(Ray ray, out HitRecord hitRecord) {\n    float t = 0.;\n    for (int i = 0; i < maxIteration; ++i) {\n        vec3 p = planetRotation * getPoint(ray, t);\n        Material mat;\n        float dist = terrainSdf(p, mat);\n        if (dist < epsilon) {\n            hitRecord = HitRecord(dist, p, terrianNormal(p), mat);\n\t\t\treturn true;\n        }\n        t += dist;\n        if (t >= maxDist) {\n            return false;\n        }\n    }\n    return false;\n}\n\nbool traceWater(Ray ray, out HitRecord hitRecord) {\n    float t = 0.;\n    for (int i = 0; i < maxIteration; ++i) {\n        vec3 p = planetRotation * getPoint(ray, t);\n        Material mat;\n        float dist = waterSdf(p, mat);\n        if (dist < epsilon) {\n            hitRecord = HitRecord(dist, p, waterNormal(p), mat);\n\t\t\treturn true;\n        }\n        t += dist;\n        if (t >= maxDist) {\n            return false;\n        }\n    }\n    return false;\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//#define ENABLE_WATER_REFRACTION\n\n// Get the final radiance from the scene\nvec3 sceneRadiance(Ray ray) {\n        \n    HitRecord terrianHit;\n    HitRecord waterHit;\n    if (traceTerrain(ray, terrianHit)) {\n        #ifdef ENABLE_WATER\n        if (traceWater(ray, waterHit) && terrainElevation(waterHit.position) < waterLine) {\n            vec3 waterColor = blinnPhong(waterHit.position, waterHit.normal, eye, waterHit.mat.color);\n            \n            #ifdef ENABLE_WATER_REFRACTION\n            vec3 I = normalize(waterHit.position - ray.origin);\n            vec3 R = refract(I, waterHit.normal, waterRefractionIndex);\n            Ray refracted = Ray(waterHit.position, R);\n            if (traceTerrain(refracted, terrianHit)) {\n                vec3 terrianColor =  blinnPhong(terrianHit.position, terrianHit.normal, eye, terrianHit.mat.color);\n                return mix(terrianColor, waterColor, 0.7);\n            }\n            #else\n            vec3 terrianColor = blinnPhong(terrianHit.position, terrianHit.normal, eye, terrianHit.mat.color);\n            return mix(terrianColor, waterColor, 0.7);\n            #endif\n            \n            return waterColor; //mix(terrianColor, waterColor, 0.7);\n        }\n        #endif\n        \n        // Above water\n        return blinnPhong(terrianHit.position, terrianHit.normal, eye, terrianHit.mat.color);\n    }\n    \n        \n    // Didn't hit anything\n    return vec3(0.0, 0.0, 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat yaw   = -((iMouse.x / iResolution.x) * 2.5 - 0.01 * iTime);\n\tfloat pitch = ((iMouse.y > 0.0 ? iMouse.y : iResolution.y * 0.3) / iResolution.y) * 2.5;\n \tplanetRotation =\n    \tmat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) *\n    \tmat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch));\n    \n    \n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    Ray ray = Ray(eye, normalize(dir));\n    \n    vec3 radiance = sceneRadiance(ray);\n    \n    \n    fragColor = vec4(linearToScreen(radiance), 1.0f);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float GAMMA = 2.2;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}","name":"Common","description":"","type":"common"}]}