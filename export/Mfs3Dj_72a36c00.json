{"ver":"0.1","info":{"id":"Mfs3Dj","date":"1703670645","viewed":49,"name":"hexagonal_tiling","username":"hissanova","description":"A naive construction of hexagonal tiling by translating a hexagonal region with fixed counts.\nI used almost the smae colours as in this shader.\nhttps://www.shadertoy.com/view/wltyz7","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tiling","practice","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int k_max = 10, l_max = 5;\nconst float D = 0.5*sqrt(3.);\nconst vec2 S = 2. * D * vec2(1., 0.);\nconst vec2 T = 2. * D * vec2(0.5, 0.5*sqrt(3.));\n\nstruct Line {\n    vec2 n;\n    float d;\n};\n\n\nLine[6] contour = Line[6](\n    Line(vec2(1., 0.), D),\n    Line(vec2(0.5, 0.5*sqrt(3.)), D),\n    Line(vec2(-0.5, 0.5*sqrt(3.)), D),\n    Line(vec2(-1., 0.), D),\n    Line(vec2(-0.5, -0.5*sqrt(3.)), D),\n    Line(vec2(0.5, -0.5*sqrt(3.)), D)\n);\n\nbool is_inside_hex(vec2 uv){\n    for (int i = 0; i < 6; i++){\n        if (dot(contour[i].n, uv) - contour[i].d > 0.) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n/*-- Colours --*/\nconst vec3 WHITE = vec3(1.0,1.0,1.0) - 0.05;\nconst vec3 BLACK = vec3(0.0,0.0,0.0) + 0.3;\nconst vec3 GREEN = vec3(0.0,0.5,0.5) - 0.05;\nconst vec3 ORANGE = vec3(0.75,0.5,0.0) + 0.05;\n\nvec3[3] cols = vec3[3](\n    GREEN,\n    ORANGE,\n    BLACK\n);\nfloat get_min_dist(vec2 uv){\n    float min_dist = 100.0;\n    float dist;\n    for (int i = 0; i < 6; i++){\n        dist = - dot(contour[i].n, uv) + contour[i].d;\n        min_dist = dist < min_dist?dist:min_dist;\n    }\n    return min_dist;\n}\n\nvec3 get_col(vec2 uv){\n    for (int i = -k_max; i < k_max; i++){\n        for (int j = -l_max; j < l_max; j++){\n            vec2 new_uv = uv + float(i)*S + float(j)*T;\n            if (is_inside_hex(new_uv)){\n                float dist = get_min_dist(new_uv);\n                float f = smoothstep(-0.2, -0.1, -dist);\n                return mix(cols[(i+2*j)%3], WHITE, f);\n            }\n        }\n    }\n    return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv = 10.*(uv - vec2(.5));\n    vec3 col;\n    \n    col = get_col(uv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}