{"ver":"0.1","info":{"id":"ddGcRy","date":"1696259697","viewed":50,"name":"tp image v2","username":"youyou47","description":"image\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["image"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Cylindre{\n    vec3 a,b;// \n    float r;// Radius\n    int i;// Texture Id\n\n};\nstruct Cylinder {\n    vec3 c;     // Center of the base\n    float r;    // Radius\n    float h;    // Height\n    int i;      // Texture Id\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Material(vec3(.8,.5,.4));\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col);\n    }\n    return Material(vec3(0));\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\nbool IntersectCylinder(Ray ray, Cylindre cyl, out Hit x)\n{\n    vec3 oc = ray.o - cyl.a;\n    vec3 ab = cyl.b - cyl.a;\n    \n    float ab2 = dot(ab, ab);\n    float aboc = dot(ab, oc);\n    float a = dot(ray.d, ray.d) - dot(ray.d, ab) * dot(ray.d, ab) / ab2;\n    float b = 2.0 * (dot(ray.d, oc) - dot(ray.d, ab) * dot(oc, ab) / ab2);\n    float c = dot(oc, oc) - dot(oc, ab) * dot(oc, ab) / ab2 - cyl.r * cyl.r;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant >= 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        \n        float t = min(t1, t2);\n        \n        if (t > 0.0)\n        {\n            vec3 p = ray.o + ray.d * t;\n            float h = dot(p - cyl.a, ab) / ab2;\n            \n            if (h >= 0.0 && h <= 1.0 )\n            {\n                vec3 n = normalize(p - (cyl.a + ab * h));\n                x = Hit(t, n, cyl.i);\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\nbool IntersectCylinder1(Ray ray, Cylinder cyl, out Hit x) {\n    float tmin = 1000.0;\n    vec3 normal;\n    vec3 ro = ray.o - cyl.c;\n    vec3 rd = ray.d;\n\n    // Intersection with the tube\n    float a = rd.x * rd.x + rd.y * rd.y;\n    float b = 2.0 * (rd.x * ro.x + rd.y * ro.y);\n    float c = ro.x * ro.x + ro.y * ro.y - cyl.r * cyl.r;\n\n    float det = b*b - 4.0*a*c;\n\n    if (det > 0.0) {\n        float sqrt_det = sqrt(det);\n        float t1 = (-b - sqrt_det) / (2.0 * a);\n        float t2 = (-b + sqrt_det) / (2.0 * a);\n\n        // Check if t1 is a valid intersection\n        float z1 = ro.z + t1 * rd.z;\n        if (t1 > 0.0 && z1 >= 0.0 && z1 <= cyl.h) {\n            tmin = t1;\n            normal = normalize(vec3(ro.x + t1 * rd.x, ro.y + t1 * rd.y, 0.0));\n        }\n\n        // Check if t2 is a valid intersection\n        float z2 = ro.z + t2 * rd.z;\n        if (t2 > 0.0 && z2 >= 0.0 && z2 <= cyl.h) {\n            if (t2 < tmin) {\n                tmin = t2;\n                normal = normalize(vec3(ro.x + t2 * rd.x, ro.y + t2 * rd.y, 0.0));\n            }\n        }\n    }\n\n    // Intersection with the caps\n    for (float sign = 1.0; sign >= -1.0; sign -= 2.0) {\n        float t = (sign * cyl.h - ro.z) / rd.z;\n        vec3 p = ro + t * rd;\n        if (t > 0.0 && dot(p, p) <= cyl.r * cyl.r) {\n            if (t < tmin) {\n                tmin = t;\n                normal = vec3(0.0, 0.0, sign);\n            }\n        }\n    }\n\n    if (tmin < 1000.0) {\n        x = Hit(tmin, normal, cyl.i);\n        return true;\n    }\n    return false;\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(0.,0.,1.),1.,1);\n    const Sphere sph2=Sphere(vec3(2.,0.,2.),1.,1);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    // Cylindre\n    const Cylindre cyl = Cylindre(vec3(5., 3., 0.), vec3(5., 3., 4.), 0.5, 1);\n    const Cylinder cyl2 = Cylinder(vec3(5., 0., 3.9), 1., 3.0, 1);  // Example cylinder\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if (IntersectCylinder(ray, cyl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if(IntersectCylinder1(ray, cyl2, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n)\n{\n    vec3 light=normalize(vec3(1,1,1));\n    \n    float diff=clamp(dot(n,light),0.,1.);\n    vec3 col=m.d*diff+vec3(.2,.2,.2);\n    return col;\n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx=Intersect(ray,x);\n    \n    if(idx)\n    {\n        vec3 p=Point(ray,x.t);\n        Material mat=Texture(p,x.i);\n        \n        return Color(mat,x.n);\n    }\n    else\n    {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}