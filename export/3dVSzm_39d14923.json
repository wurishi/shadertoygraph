{"ver":"0.1","info":{"id":"3dVSzm","date":"1573673009","viewed":1904,"name":"Sphere UV mapping","username":"darkeclipz","description":"Mapping a texture onto a sphere.\n\nhttps://en.wikipedia.org/wiki/UV_mapping","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["texture","uv","sphere","mapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2.\n#define R iResolution.xy\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\nvec2 map( in vec3 pos, float time )  \n{\n    float id = 0.;\n    float sphere = sdSphere(pos, 0.5);\n    float plane = pos.y + 0.5;\n    \n    if(plane < sphere) {\n    \tid = 1.;    \n    }\n    \n    float d = min(sphere, plane);\n    \n    return vec2(d, id);\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.00;\n    for( int i=0; i< 100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.001 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec2 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.01;\n    int i=0;\n    for( i=0; i<100; i++ )\n    {\n        float precis = 0.001 * t;\n        vec3 pos = ro + t*rd;\n\n        vec2 h = map( pos, time );\n        m = h.y;\n        if( h.x<precis )\n            break;\n        t += h.x;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec2(t, m);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime/4.;\n\n    vec3 col = vec3(0);\n    vec3 res = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*(U + vec2(aax, aay) / AA)-R)/R.y;\n        \n        vec3 ta = vec3(0,0,0);\n        vec3 ro = vec3(0, 1.0 + (-sin(time) * .5 + .5), -1);\n        ro.xz *= rot(time);\n        \n        vec3 ww = normalize( ta-ro );\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n        vec3 vv = normalize( cross(uu,ww) );\n\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n \n        vec3 col = vec3(0.0);\n\n        vec2 tm = castRay(ro, rd, time); \n\n        if( tm.x < 20. )\n        {\n            float t = tm.x;\n            float id = tm.y;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n            \n            vec3 mate = vec3(0.6); \n            \n            if(id < 0.5) { // sphere\n                \n            \tmate = vec3(.8); \n                \n                //calculate uv coordinates for the sphere:\n                // https://en.wikipedia.org/wiki/UV_mapping\n                \n                // posn is the normalized vector from P to the sphere center\n                // which in this example is at (0, 0, 0).\n                vec3 posn = normalize(pos);\n                float u = 0.5 + atan(posn.z, posn.x) / (2.*3.1415);\n                float v = 0.5 - asin(posn.y) / 3.1415;\n                \n                // trick from Fabrice to avoid the discontinuity at Greenwich.\n                vec2 uv = vec2(u,v),\n                     df = fwidth(uv);\n               \tif(df.x > 0.5) df.x = 0.;\n                \n                mate = textureLod(iChannel0, uv, log2(max(df.x, df.y)*1024.)).xyz;\n                \n                // reuse mate \n                nor += 0.05*length(mate);\n                 \n            }\n            else if(id < 1.5) { // floor\n                \n            \tmate = vec3(0.);   \n                float s = 12.;\n                float w = 0.05;\n                \n                if(fract(pos.x*s) < w) {\n                \tmate = vec3(.3);    \n                }\n                \n                if(fract(pos.z*s) < w) {\n                \tmate = vec3(.3);    \n                }\n            }\n\n            vec3  light1 = vec3( 0, 1, 1 );\n            vec3  light2 = vec3( 1, 3, 1 );\n\n            float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n            float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n            float amb = (0.7+0.3*nor.y);\n            float shadow = clamp(castShadow(pos + nor*.1, light1 - pos, time), 0., 1.);\n\n            vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*shadow;\n            brdf += 1.0*vec3(1.00,1.00,1.00)*key*shadow;\n            brdf += 1.0*vec3(0.40,0.40,0.40)*bac;\n\n            col = mate * brdf * exp(-0.6*t);\n        }\n\n        res += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow( res/(AA*AA), vec3(0.4545) );\n    \n    O = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}