{"ver":"0.1","info":{"id":"ldXyD4","date":"1488216368","viewed":209,"name":"Procedural Canvas Texture","username":"MichaelPohoreski","description":"INSTRUCTIONS: Drag the mouse ...\n* Left/Right = amount of noise to add. Left = zero noise, Right = max noise\n* Up/Down = amount of pattern to add or subtract.  Up = Add, Down = Subtract.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n Procedural Canvas Texture\n Copyleft {c} 2017 Michael Pohoreski aka Michaelangel007\n -- GitHub link coming soonish --\n\nDISCLAIMER:\n\n    You are free to use this code as you wish.\n\n    However, if you are going to copy/paste snippets of this code\n    on StackOverflow, StackExchange, Reddit, etc.\n    Please provide a link back to the original source\n    so that people can find updates and bugfixes.\n    Thanks!\n\n\nIntroduction:\n\nA cheap way to simulate a canvas texture procedurally.\n\nAlso see:\n\n Cross Hatch Patterns\n https://www.shadertoy.com/view/MdfyDH\n\n Boolean Floating Point Logic\n https://www.shadertoy.com/view/lsXyDH\n\nBase Pattern is:\n013213 Diagonal cross hatch\n    .X.X\n    ..X.\n    .X.X\n    X...\n\n*/\n\n#define VERSION 5\n\n// ====================\nfloat pattern_diamond3x3( vec2 p ) \n{\n    vec2 d = vec2( 4.0 ); // Divisor\n    vec2 r = mod( p,  d ); // q % d\n    vec2 i = floor( r );\n\n    int n = int( (4.0 * i.y) + i.x );\n    \n    if( ((i.y == 0.0) || (i.y == 2.0)) && i.x == 1.0 )\n        return 1.0;\n    else\n        if( (i.y == 1.0) && (i.x < 3.0) )\n            return 1.0;\n    return 0.0;\n}\n\n// ====================\nfloat pattern_x( vec2 p )\n{\n    vec2 d = vec2( 4.0 ); // Divisor\n    vec2 r = mod( p,  d ); // q % d\n    vec2 i = floor( r );\n\n    if( i.y == 0. )\n        return (i.x == 0.0) ? 1.0 : 0.0;\n\n    if( i.y == 1. || i.y == 3. )\n    {\n        if (i.x == 1.0) return 1.0;\n        if (i.x == 3.0) return 1.0;\n    }\n\n    if( i.y == 2. )\n        return (i.x == 2.0) ? 1.0 : 0.0;\n\n    return 0.;\n}\n\n// See:\n// WebGL Noise\n// https://www.shadertoy.com/view/XtX3D4\nconst vec2 RANDOM_K = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n    2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n);\nfloat random( vec2 p )\n{\n    return fract( cos( mod( 12345678., 256. * dot(p,RANDOM_K) ) ) );\n}\n\n// p   = Input Fragment Coordinate (NOT normalized)\n// p.x = 0 .. w-1\n// p.y = 0 .. h-1\n// ====================\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec2 dim = iResolution.xy;\n    vec2 s = p / dim;\n\n    bool m = (iMouse.z > 0.5);\n    vec2 mxy = iMouse.xy / dim;\n\n    float w = iResolution.x;\n    float h = iResolution.y;\n\n    float t = pattern_x( p );\n//    float t = 1.0 - pattern_diamond3x3( p );\n    \n    float x  = 0.90; // base intensity\n    float dx = m ? mxy.x : 0.25; // default to 25% mix\n    float dy = m ? mxy.y * 2.0 - 1.0 : 0.5; // [0.0 .. 1.0] -> [-0.5 .. +0.5]\n    float n  = random( s ) - 0.5; // [0.0, 1.0] -> [-0.5, +0.5]\n\n    vec3 base = vec3( x ); // Base Color\n    vec3 grey = vec3( t );\n    vec3 rand = vec3( n ) * dx;\n\n    // y = x + dx*t\n    vec3 color = vec3( 1.0, 0.0, 1.0 );\n\n#if VERSION == 1\n    color.rgb = grey;\n#endif\n#if VERSION == 2\n    color.rgb = base + grey;\n#endif\n#if VERSION == 3\n    color.rgb = base + dx*grey;\n#endif\n#if VERSION == 4\n    color.rgb = base + rand*dx*grey;\n#endif\n#if VERSION == 5 // Looks good, default: dx = 0.75\n    color.rgb = base + dy*(rand*dx + dx*grey);\n#endif\n#if VERSION == 6\n    color.rgb = base + mix( grey, rand, dx );\n#endif\n#if VERSION == 7 // Looks good, default: dx = 0.5, dy = 0.5;\n    // color = 0.5 + vec3( dy ); // Test Mouse Y\n    color.rgb = base + dy*mix( grey, rand, dx );\n#endif\n    \n    float statusW = 0.05; // 10%\n    float statusH = 0.05; // 10%\n    if( s.x < statusW  )\n    {\n        if( s.y < statusH )\n        {\n            // TODO: Print mouse.x, mouse.y\n        }\n        else\n            color = t * vec3( 1.0 - dy, dy, 0.5 * dy );\n    }\n    else\n    if( s.y < statusH )\n        color = rand * dx; // vec3( dx );\n        \n    fragColor.rgb = color;\n    fragColor.a   = 1.;\n}\n","name":"Image","description":"","type":"image"}]}