{"ver":"0.1","info":{"id":"mssXRB","date":"1669596688","viewed":219,"name":"Terrain and Erosion Test","username":"araesmojo","description":"Testing out using noise to create a landscape and then doing CFD to erode the landscape\nkey 'h' for heightmap\nkey 'p' for precipitation map\nkey 's' for slope map\nkey 'n' for normalized water velocity x,y and mass\nDefault is water abs( velocity ) and mass","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["noise","terrain","erosion","cfd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Gabriel Putnam, 2022\n// Common variables to change shader performance in Common\n// Heightmap, precipitation, and erosion / deposition calculated in Buffer A\n// Slope gradients calculated in Buffer B\n// Fluid dynamics properties calculated in Buffer C\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 HtPr = vec4( texture( iChannel0, fragCoord / iResolution.xy ) ) * 255.0;\n    vec4 VM   = vec4( texture( iChannel2, fragCoord / iResolution.xy ) );\n    \n    float ht = float( ( (int(HtPr.y) & 0xFF) << 8 ) | (int(HtPr.x) & 0xFF) ) / 65535.0;\n    vec4 displayColor;\n    \n    if( texelFetch( iChannel3, ivec2(72,0),0).x > 0.0 ){\n        // Heightmap and water mass (h key)\n        displayColor = vec4( ht, ht, ht, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(67,0),0).x > 0.0 ){\n        // Height change (c key)\n        float ht_chng = ( HtPr.w / 255.0 - 0.5 ) * 10.0 + 0.5;\n        displayColor = vec4( ht_chng, ht_chng, ht_chng, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(80,0),0).x > 0.0 ){\n        // Precipitation and water mass (p key)\n        //float pr = float( ( (int(HtPr.w) & 0xFF) << 8 ) | (int(HtPr.z) & 0xFF) ) / 65535.0;\n        float precip = HtPr.z / 255.0;\n        displayColor = vec4( precip, precip, VM.z, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(83,0),0).x > 0.0 ){\n        // Magnified slopes and water mass (s key)\n        vec4 Sl   = vec4( texture( iChannel1, fragCoord / iResolution.xy ) );\n        Sl -= 0.5;\n        float slx = Sl.x;\n        float sly = Sl.y;\n        slx = -( slx ) * 30.0 + 0.5;\n        sly = ( sly ) * 30.0 + 0.5;\n        float Slmag = length( Sl.xy ) * 50.0;\n        displayColor = vec4( slx, sly, 1.0, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(78,0),0).x > 0.0 ){\n        // Normalize water velocity x,y and mass (n key)\n        vec4 VM_n = normalize( VM );\n        displayColor = vec4( VM_n.xyz, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(85,0),0).x > 0.0 ){\n        // Water velocity magnitude (u key)\n        float Vmag = length( VM.xy * 2.0 - 1.0 );\n        fragColor = vec4( Vmag, Vmag, Vmag, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(65,0),0).x > 0.0 ){\n        // Water mass magnitude (a key)\n        displayColor = vec4( VM.z, VM.z, VM.z, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(86,0),0).x > 0.0 ){\n        // Water velocity and mass (default)\n        vec2 vXy_abs = abs( VM.xy * 2.0 - 1.0 );\n        displayColor = vec4( vXy_abs, VM.z, 1.0 );\n    } else if( texelFetch( iChannel3, ivec2(77,0),0).x > 0.0 ){\n        // Water mass and sediment mass (m key)\n        vec2 vXy_abs = abs( VM.xy * 2.0 - 1.0 );\n        displayColor = vec4( VM.w, 0.0, VM.z, 1.0 );\n    } else {\n        // Water velocity and mass (default)\n        vec2 vXy_abs = abs( VM.xy * 2.0 - 1.0 );\n        displayColor = vec4( vXy_abs, VM.z, 1.0 );\n    }\n    \n    if( ht < 0.5 ){\n        fragColor = 0.3 * displayColor + vec4( 0.0, 0.0, 0.5, 0.7 );\n    } else {\n        fragColor = displayColor;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Noise based on:\n// Simplex Noise - https://www.shadertoy.com/view/Msf3WH - Copyright Â© 2013 Inigo Quilez\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,hashVec0), dot(p,hashVec1) );\n\treturn -1.0 + 2.0*fract(sin(p)*hashSinSeed);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fBm( in vec2 uv, int oct ){\n    float output_fBm = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float mult = 0.5;\n    float normDiv = 0.0;\n    for( int i = 0; i < oct; i++ ){\n        output_fBm += mult*( noise( uv ) * 0.5 + 0.5 );\n        uv = m*uv;\n        normDiv += mult;\n        mult *= 0.5;\n    }\n    output_fBm /= normDiv;\n    output_fBm *= 1.7;\n    output_fBm -= 0.325;\n\n    return output_fBm;\n}\n\nfloat ridgedNoise( in vec2 p, float sharp ){\n    float n = noise( p );\n    n = abs(n);  // create creases\n    n = 1.0 - n; // invert so creases are at top\n    n = pow( n, sharp );   // sharpen creases\n    return n;\n}\n\nfloat fBmRidged( in vec2 uv, int oct, float sharp ){\n    float output_fBm = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float mult = 0.5;\n    float normDiv = 0.0;\n    for( int i = 0; i < oct; i++ ){\n        output_fBm += mult*ridgedNoise( uv, sharp );\n        uv = m*uv;\n        normDiv += mult;\n        mult *= 0.5;\n    }\n    output_fBm /= normDiv;\n    output_fBm *= 1.45;\n    output_fBm -= 0.326;\n    \n    if( output_fBm > 1.0 ){\n        output_fBm = 1.0;\n    }\n\n    return output_fBm;\n}\n\nfloat blend( float ratio, float dirVal, float invVal ){\n   return ratio * dirVal + ( 1.0 - ratio ) * invVal;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    // Only do this once\n    if( iFrame < 1 ){\n        vec2 uv_in = p*vec2(iResolution.x/iResolution.y,1.0);\n        \n        int filterHt       = 0;\n        int filterWt       = 0;\n        \n        float freqHt     = 1.5;\n        float freqCont   = freqHt * 0.5;\n        float freqPrecip = 3.0;\n        \n        // Calculate the continental paths\n        float offsetCont = 0.65;\n        \n        vec2 uv_cont = uv_in * freqCont + offsetCont;\n\n        float cont = fBmRidged( uv_cont, 2, 2.0 );\n\n        // Calculate the heightmap in this region\n        vec2 uv_ht = uv_in * freqHt;\n        float ht = fBm( uv_ht, 7 );\n        \n        // Add ridged mountains to the map\n        float htMt    = fBmRidged( uv_cont, 7, 2.0 );\n        float htOcean = ht + cont * htMt * 0.25;\n        float htLand  = blend( cont, htMt, ht );\n        ht            = blend( ht, htLand, htOcean );\n        if( filterHt == 1 ){\n            if( ht <= 0.95 ){\n                if( ht >= 0.05 ){\n                    ht = 0.5;\n                }\n            }\n        }\n        if( filterWt == 1 ){\n            if( ht <= 0.5 ){\n                ht = 0.5;\n            }\n        }\n        \n        // Calculate the temperature in this region\n        float pos_sph    = acos(p.y * 1.5 - 0.75) - 1.570796327;\n        //float pos_sph    = acos(p.y - 0.5 ) - 1.570796327;\n        float pos_sph_sq = pos_sph * pos_sph;\n        float temp_C     = (pos_sph_sq * (0.0645169619 * pos_sph_sq - 0.3618315901) + 0.8333333);// 120 C (-60 to +60 ) to 0-1 range\n        // Adjust the temp based on the height\n        temp_C          -= max((max(ht - 0.5, 0.0) * 1.083333333), 0.0);\n        \n        // Calculate the precipitation in this region\n        vec2 uv_pr = uv_in * freqPrecip;\n        float precip = fBm( uv_pr, 7 );\n        // Vary the precip based on the temp\n        precip = temp_C * ( 1.17818181f * temp_C + 0.01090909f ) * precip;\n        \n        // Use two channels each for height and precip to hold 65535 values\n        // Otherwise erosion is too granular.\n        int iht    = int( ht * 65535.0 + 0.5 );\n        float ht_0 = float( iht & 0xFF ) / 255.0;\n        float ht_1 = float( (iht >> 8) & 0xFF ) / 255.0;\n        \n        int iPr    = int( precip * 65535.0 + 0.5 );\n        float pr_0 = float( iPr & 0xFF ) / 255.0;\n        float pr_1 = float( (iPr >> 8) & 0xFF ) / 255.0;\n\n        fragColor = vec4( ht_0, ht_1, precip, 0.5 );\n    } else {\n        // Adjust heights based on erosion\n        vec4 HtPr      = vec4( texture( iChannel0, fragCoord / iResolution.xy ) );\n        vec2 Ht        = HtPr.xy * 255.0;\n        vec4 VM        = vec4( texture( iChannel1, p.xy ) );\n        vec2 mass      = pow( vec2( massBase, massBase ), ( VM.zw - massOffset ) );\n        float ht_water = h_mass * mass.x;\n        float ht_land  = float( ( (int(Ht.y) & 0xFF) << 8 ) | (int(Ht.x) & 0xFF) ) / 65535.0;\n        float ht_chng;\n        if( ht_land < 0.5 ){\n            ht_chng = 0.0;\n        //} else if( ht_land < 0.55 && ht_land > 0.5 ){\n        //    float scale_factor = (ht_land - 0.5) * 20.0;\n        //    ht_chng  = -0.5 * scale_factor * scale_factor * ht_water;\n        } else {\n            ht_chng  = -0.5  * ht_water;\n        }\n        // Sediment carrying capacity ~= Q * slope\n        float Vmag     = length( VM.xy * 2.0 - 1.0 );\n        float Qmag     = Vmag * ht_water;\n        vec2 Slope     = texture( iChannel2, p.xy ).xy - 0.5;\n        float Cc       = CCmult * mass.x * length( Slope );\n        //float ht_chng  = -eroRate * ( Cc - mass.y );\n        ht_land        += ht_chng;\n        \n        int iht    = int( ht_land * 65535.0 + 0.5 );\n        float ht_0 = float( iht & 0xFF ) / 255.0;\n        float ht_1 = float( (iht >> 8) & 0xFF ) / 255.0;\n        \n        fragColor = vec4( ht_0, ht_1, HtPr.z, HtPr.w + ht_chng );\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( iFrame < 1 ){\n        // If its the first frame, wait for the heightmaps to be calculated\n        fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    } else {\n        vec2 p = fragCoord.xy / iResolution.xy;\n        vec2 pixel = vec2(1.0,1.0)/iResolution.xy;\n        \n        // If we're beyond the first frame, then calculate the slopes for the height regions.\n        // First collect a + shape around the fragment location\n        vec4 HPSl_AB;\n        vec4 HPSl_BA;\n        vec4 HPSl_BB;\n        vec4 HPSl_CB;\n        vec4 HPSl_BC;\n        \n        // Collect the center value\n        HPSl_BB = texture( iChannel0, p.xy ) * 255.0;  // 0, 0 (the center pixel)\n        \n        if( fragCoord.x < 1.0 ){\n            // If left side of the screen\n            HPSl_AB = texture( iChannel0, p.xy ) * 255.0;  // -x, 0\n            HPSl_AB.xy = HPSl_BB.xy;\n            // Grab all the surrounding height, precip\n            HPSl_BA = texture( iChannel0, p.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HPSl_BC = texture( iChannel0, p.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n            HPSl_CB = texture( iChannel0, p.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n        } else if( fragCoord.x > iResolution.x - 1.0 ){\n            // If right side of the screen\n            HPSl_CB = texture( iChannel0, p.xy ) * 255.0;  // +x, 0\n            HPSl_CB.xy = HPSl_BB.xy;\n            // Grab all the surrounding height, precip\n            HPSl_AB = texture( iChannel0, p.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HPSl_BA = texture( iChannel0, p.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HPSl_BC = texture( iChannel0, p.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n        } else if( fragCoord.y < 1.0 ){\n            // If top of the screen\n            HPSl_BA = texture( iChannel0, p.xy ) * 255.0;                               //  0, -y\n            HPSl_BA.xy = HPSl_BB.xy;\n            // If any non-edge location, grab all the surrounding height, precip\n            HPSl_AB = texture( iChannel0, p.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HPSl_BC = texture( iChannel0, p.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n            HPSl_CB = texture( iChannel0, p.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n        } else if( fragCoord.y > iResolution.y - 1.0 ){\n            // If bottom of the screen\n            HPSl_BC = texture( iChannel0, p.xy ) * 255.0;                               //  0, +y\n            HPSl_BC.xy = HPSl_BB.xy;\n            // If any non-edge location, grab all the surrounding height, precip\n            HPSl_AB = texture( iChannel0, p.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HPSl_BA = texture( iChannel0, p.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HPSl_CB = texture( iChannel0, p.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n        } else {\n            // If any non-edge location, grab all the surrounding height, precip\n            HPSl_AB = texture( iChannel0, p.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HPSl_BA = texture( iChannel0, p.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HPSl_BC = texture( iChannel0, p.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n            HPSl_CB = texture( iChannel0, p.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n        }\n        \n        // Calculate the slopes\n        float ht_AB = float( ( (int(HPSl_AB.y) & 0xFF) << 8 ) | (int(HPSl_AB.x) & 0xFF) ) / 65535.0;\n        float ht_BA = float( ( (int(HPSl_BA.y) & 0xFF) << 8 ) | (int(HPSl_BA.x) & 0xFF) ) / 65535.0;\n        float ht_BC = float( ( (int(HPSl_BC.y) & 0xFF) << 8 ) | (int(HPSl_BC.x) & 0xFF) ) / 65535.0;\n        float ht_CB = float( ( (int(HPSl_CB.y) & 0xFF) << 8 ) | (int(HPSl_CB.x) & 0xFF) ) / 65535.0;\n        \n        \n        float dx_ht = -(ht_CB - ht_AB)/2.0+0.5;\n        float dy_ht = -(ht_BC - ht_BA)/2.0+0.5;\n        \n        // Assign the final outputs\n        fragColor = vec4( dx_ht, dy_ht, 1.0, 1.0 );\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( iFrame < 2 ){\n        // Initialize the velocity, and put all mass to zero\n        fragColor = vec4( 0.5,0.5,0.0,0.0 );\n    } else {\n        vec2 pos   = fragCoord/iResolution.xy;\n        vec2 pixel = vec2(1.0,1.0)/iResolution.xy;\n\n        // MASS change\n        // Cells arranged in 3x3 square A-C on each side\n        // + AC BC CC\n        // y AB BB CB\n        // - AA BA CA\n        //   -  x  +\n        // BB is current cell\n\n        // Find out the velocity and mass at each vertex\n        vec4[9] HtPr;\n        vec4[9] Sl;\n        vec4[9] VM;\n\n        if( fragCoord.x < 1.0 ){\n            // If left side of the screen\n            HtPr[1] = texture( iChannel0, pos.xy );  // -x, 0\n            if( fragCoord.y < 1.0 ){\n                // If left-top corner\n                HtPr[0] = texture( iChannel0, pos.xy ) * 255.0;  // -x, -y\n            } else if( fragCoord.y > iResolution.y - 1.0 ){\n                // If left-bottom corner\n                HtPr[2] = texture( iChannel0, pos.xy ) * 255.0;  // -x, +y\n            } else {\n                HtPr[0] = texture( iChannel0, pos.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // -x, -y\n                HtPr[2] = texture( iChannel0, pos.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // -x, +y\n            }\n            VM[0]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // -x, -y\n            VM[1]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // -x,  0\n            VM[2]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // -x, +y\n            HtPr[0].zw = vec2( 0.0, 0.0 );\n            HtPr[1].zw = vec2( 0.0, 0.0 );\n            HtPr[2].zw = vec2( 0.0, 0.0 );\n            Sl[0] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[1] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[2] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            // Grab all the surrounding height, precip, dx, dy\n            HtPr[3] = texture( iChannel0, pos.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HtPr[5] = texture( iChannel0, pos.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n            HtPr[6] = texture( iChannel0, pos.xy + vec2(  1.0, -1.0 ) * pixel ) * 255.0;  // +x, -y\n            HtPr[7] = texture( iChannel0, pos.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n            HtPr[8] = texture( iChannel0, pos.xy + vec2(  1.0,  1.0 ) * pixel ) * 255.0;  // +x, +y\n            // Grab all the surrounding dx, dy\n            Sl[3]   = texture( iChannel2, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            Sl[5]   = texture( iChannel2, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n            Sl[6]   = texture( iChannel2, pos.xy + vec2(  1.0, -1.0 ) * pixel );  // +x, -y\n            Sl[7]   = texture( iChannel2, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n            Sl[8]   = texture( iChannel2, pos.xy + vec2(  1.0,  1.0 ) * pixel );  // +x, +y\n            // Grab all the surrounding prior CFD conditions\n            VM[3]   = texture( iChannel1, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            VM[5]   = texture( iChannel1, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n            VM[6]   = texture( iChannel1, pos.xy + vec2(  1.0, -1.0 ) * pixel );  // +x, -y\n            VM[7]   = texture( iChannel1, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n            VM[8]   = texture( iChannel1, pos.xy + vec2(  1.0,  1.0 ) * pixel );  // +x, +y\n        } else if( fragCoord.x > iResolution.x - 1.0 ){\n            // If right side of the screen\n            HtPr[7] = texture( iChannel0, pos.xy );  // +x, 0\n            if( fragCoord.y < 1.0 ){\n                // If right-top corner\n                HtPr[6] = texture( iChannel0, pos.xy ) * 255.0;  // +x, -y\n            } else if( fragCoord.y > iResolution.y - 1.0 ){\n                // If right-bottom corner\n                HtPr[8] = texture( iChannel0, pos.xy ) * 255.0;  // +x, +y\n            } else {\n                HtPr[6] = texture( iChannel0, pos.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // +x, -y\n                HtPr[8] = texture( iChannel0, pos.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // +x, +y\n            }\n            VM[6]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // +x, -y\n            VM[7]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // +x,  0\n            VM[8]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // +x, +y\n            HtPr[6].zw = vec2( 0.0, 0.0 );\n            HtPr[7].zw = vec2( 0.0, 0.0 );\n            HtPr[8].zw = vec2( 0.0, 0.0 );\n            Sl[6] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[7] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[8] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            // Grab all the surrounding height, precip, dx, dy\n            HtPr[0] = texture( iChannel0, pos.xy + vec2( -1.0, -1.0 ) * pixel ) * 255.0;  // -x, -y\n            HtPr[1] = texture( iChannel0, pos.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HtPr[2] = texture( iChannel0, pos.xy + vec2( -1.0,  1.0 ) * pixel ) * 255.0;  // -x, +y\n            HtPr[3] = texture( iChannel0, pos.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HtPr[5] = texture( iChannel0, pos.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n            // Grab all the surrounding dx, dy\n            Sl[0] = texture( iChannel2, pos.xy + vec2( -1.0, -1.0 ) * pixel );  // -x, -y\n            Sl[1] = texture( iChannel2, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            Sl[2] = texture( iChannel2, pos.xy + vec2( -1.0,  1.0 ) * pixel );  // -x, +y\n            Sl[3] = texture( iChannel2, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            Sl[5] = texture( iChannel2, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n            // Grab all the surrounding prior CFD conditions\n            VM[0]   = texture( iChannel1, pos.xy + vec2( -1.0, -1.0 ) * pixel );  // -x, -y\n            VM[1]   = texture( iChannel1, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            VM[2]   = texture( iChannel1, pos.xy + vec2( -1.0,  1.0 ) * pixel );  // -x, +y\n            VM[3]   = texture( iChannel1, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            VM[5]   = texture( iChannel1, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n        } else if( fragCoord.y < 1.0 ){\n            // If top of the screen\n            HtPr[0] = texture( iChannel0, pos.xy + vec2(  -1.0, 0.0 ) * pixel ) * 255.0;  // -x, -y\n            HtPr[3] = texture( iChannel0, pos.xy ) * 255.0;                               //  0, -y\n            HtPr[6] = texture( iChannel0, pos.xy + vec2(  1.0, 0.0 ) * pixel ) * 255.0;   // +x, -y\n            VM[0]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // -x, -y\n            VM[3]   = vec4( 0.5, 0.5, 0.0, 1.0 );  //  0, -y\n            VM[6]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // +x, -y\n            HtPr[0].zw = vec2( 0.0, 0.0 );\n            HtPr[3].zw = vec2( 0.0, 0.0 );\n            HtPr[6].zw = vec2( 0.0, 0.0 );\n            Sl[0] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[3] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[6] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            // Grab all the surrounding height, precip, dx, dy\n            HtPr[1] = texture( iChannel0, pos.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HtPr[2] = texture( iChannel0, pos.xy + vec2( -1.0,  1.0 ) * pixel ) * 255.0;  // -x, +y\n            HtPr[5] = texture( iChannel0, pos.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n            HtPr[7] = texture( iChannel0, pos.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n            HtPr[8] = texture( iChannel0, pos.xy + vec2(  1.0,  1.0 ) * pixel ) * 255.0;  // +x, +y\n            // Grab all the surrounding dx, dy\n            Sl[1] = texture( iChannel2, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            Sl[2] = texture( iChannel2, pos.xy + vec2( -1.0,  1.0 ) * pixel );  // -x, +y\n            Sl[5] = texture( iChannel2, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n            Sl[7] = texture( iChannel2, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n            Sl[8] = texture( iChannel2, pos.xy + vec2(  1.0,  1.0 ) * pixel );  // +x, +y\n            //SlGrab all the surrounding prior CFD conditions\n            VM[1]   = texture( iChannel1, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            VM[2]   = texture( iChannel1, pos.xy + vec2( -1.0,  1.0 ) * pixel );  // -x, +y\n            VM[5]   = texture( iChannel1, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n            VM[7]   = texture( iChannel1, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n            VM[8]   = texture( iChannel1, pos.xy + vec2(  1.0,  1.0 ) * pixel );  // +x, +y\n        } else if( fragCoord.y > iResolution.y - 1.0 ){\n            // If bottom of the screen\n            HtPr[2] = texture( iChannel0, pos.xy + vec2( -1.0,  1.0 ) * pixel ) * 255.0;  // -x, +y\n            HtPr[5] = texture( iChannel0, pos.xy ) * 255.0;                               //  0, +y\n            HtPr[8] = texture( iChannel0, pos.xy + vec2(  1.0,  1.0 ) * pixel ) * 255.0;  // +x, +y\n            VM[2]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // -x, +y\n            VM[5]   = vec4( 0.5, 0.5, 0.0, 1.0 );  //  0, +y\n            VM[8]   = vec4( 0.5, 0.5, 0.0, 1.0 );  // +x, +y\n            HtPr[2].zw = vec2( 0.0, 0.0 );\n            HtPr[5].zw = vec2( 0.0, 0.0 );\n            HtPr[8].zw = vec2( 0.0, 0.0 );\n            Sl[2] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[5] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            Sl[8] = vec4( 0.5, 0.5, 0.0, 1.0 );\n            // Grab all the surrounding height, precip\n            HtPr[0] = texture( iChannel0, pos.xy + vec2( -1.0, -1.0 ) * pixel ) * 255.0;  // -x, -y\n            HtPr[1] = texture( iChannel0, pos.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HtPr[3] = texture( iChannel0, pos.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HtPr[6] = texture( iChannel0, pos.xy + vec2(  1.0, -1.0 ) * pixel ) * 255.0;  // +x, -y\n            HtPr[7] = texture( iChannel0, pos.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n            // Grab all the surrounding dx, dy\n            Sl[0] = texture( iChannel2, pos.xy + vec2( -1.0, -1.0 ) * pixel );  // -x, -y\n            Sl[1] = texture( iChannel2, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            Sl[3] = texture( iChannel2, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            Sl[6] = texture( iChannel2, pos.xy + vec2(  1.0, -1.0 ) * pixel );  // +x, -y\n            Sl[7] = texture( iChannel2, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n            // Grab all the surrounding prior CFD conditions\n            VM[0]   = texture( iChannel1, pos.xy + vec2( -1.0, -1.0 ) * pixel );  // -x, -y\n            VM[1]   = texture( iChannel1, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            VM[3]   = texture( iChannel1, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            VM[6]   = texture( iChannel1, pos.xy + vec2(  1.0, -1.0 ) * pixel );  // +x, -y\n            VM[7]   = texture( iChannel1, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n        } else {\n            // If any non-edge location, grab all the surrounding height, precip\n            HtPr[0] = texture( iChannel0, pos.xy + vec2( -1.0, -1.0 ) * pixel ) * 255.0;  // -x, -y\n            HtPr[1] = texture( iChannel0, pos.xy + vec2( -1.0,  0.0 ) * pixel ) * 255.0;  // -x, 0\n            HtPr[2] = texture( iChannel0, pos.xy + vec2( -1.0,  1.0 ) * pixel ) * 255.0;  // -x, +y\n            HtPr[3] = texture( iChannel0, pos.xy + vec2(  0.0, -1.0 ) * pixel ) * 255.0;  // 0, -y\n            HtPr[5] = texture( iChannel0, pos.xy + vec2(  0.0,  1.0 ) * pixel ) * 255.0;  // 0, +y\n            HtPr[6] = texture( iChannel0, pos.xy + vec2(  1.0, -1.0 ) * pixel ) * 255.0;  // +x, -y\n            HtPr[7] = texture( iChannel0, pos.xy + vec2(  1.0,  0.0 ) * pixel ) * 255.0;  // +x, 0\n            HtPr[8] = texture( iChannel0, pos.xy + vec2(  1.0,  1.0 ) * pixel ) * 255.0;  // +x, +y\n            // If any non-edge location, grab all the surrounding dx, dy\n            Sl[0] = texture( iChannel2, pos.xy + vec2( -1.0, -1.0 ) * pixel );  // -x, -y\n            Sl[1] = texture( iChannel2, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            Sl[2] = texture( iChannel2, pos.xy + vec2( -1.0,  1.0 ) * pixel );  // -x, +y\n            Sl[3] = texture( iChannel2, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            Sl[5] = texture( iChannel2, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n            Sl[6] = texture( iChannel2, pos.xy + vec2(  1.0, -1.0 ) * pixel );  // +x, -y\n            Sl[7] = texture( iChannel2, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n            Sl[8] = texture( iChannel2, pos.xy + vec2(  1.0,  1.0 ) * pixel );  // +x, +y\n            // If any non-edge location, grab all the surrounding prior CFD conditions\n            VM[0]   = texture( iChannel1, pos.xy + vec2( -1.0, -1.0 ) * pixel );  // -x, -y\n            VM[1]   = texture( iChannel1, pos.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n            VM[2]   = texture( iChannel1, pos.xy + vec2( -1.0,  1.0 ) * pixel );  // -x, +y\n            VM[3]   = texture( iChannel1, pos.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n            VM[5]   = texture( iChannel1, pos.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n            VM[6]   = texture( iChannel1, pos.xy + vec2(  1.0, -1.0 ) * pixel );  // +x, -y\n            VM[7]   = texture( iChannel1, pos.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n            VM[8]   = texture( iChannel1, pos.xy + vec2(  1.0,  1.0 ) * pixel );  // +x, +y\n        }\n        // Collect the center value\n        HtPr[4] = texture( iChannel0, pos.xy ) * 255.0;  // 0, 0 (the center pixel)\n        Sl[4]   = texture( iChannel2, pos.xy );  // 0, 0 (the center pixel)\n        VM[4]   = texture( iChannel1, pos.xy );  // 0, 0 (the center pixel)\n        \n        // Recompute the heights by combining two color channels\n        // Need 65535 values to have reasonable granularity\n        float ht[9];\n        ht[0] = float( ( (int(HtPr[0].y) & 0xFF) << 8 ) | (int(HtPr[0].x) & 0xFF) ) / 65535.0;\n        ht[1] = float( ( (int(HtPr[1].y) & 0xFF) << 8 ) | (int(HtPr[1].x) & 0xFF) ) / 65535.0;\n        ht[2] = float( ( (int(HtPr[2].y) & 0xFF) << 8 ) | (int(HtPr[2].x) & 0xFF) ) / 65535.0;\n        ht[3] = float( ( (int(HtPr[3].y) & 0xFF) << 8 ) | (int(HtPr[3].x) & 0xFF) ) / 65535.0;\n        ht[4] = float( ( (int(HtPr[4].y) & 0xFF) << 8 ) | (int(HtPr[4].x) & 0xFF) ) / 65535.0;\n        ht[5] = float( ( (int(HtPr[5].y) & 0xFF) << 8 ) | (int(HtPr[5].x) & 0xFF) ) / 65535.0;\n        ht[6] = float( ( (int(HtPr[6].y) & 0xFF) << 8 ) | (int(HtPr[6].x) & 0xFF) ) / 65535.0;\n        ht[0] = float( ( (int(HtPr[7].y) & 0xFF) << 8 ) | (int(HtPr[7].x) & 0xFF) ) / 65535.0;\n        ht[8] = float( ( (int(HtPr[8].y) & 0xFF) << 8 ) | (int(HtPr[8].x) & 0xFF) ) / 65535.0;\n        \n        // Extract the water and sediment mass and scale to full range\n        vec2 mass[9];\n        mass[0]   = pow( vec2( massBase, massBase), ( VM[0].zw - massOffset ) );  // -x, -y\n        mass[1]   = pow( vec2( massBase, massBase), ( VM[1].zw - massOffset ) );  // -x, 0\n        mass[2]   = pow( vec2( massBase, massBase), ( VM[2].zw - massOffset ) );  // -x, +y\n        mass[3]   = pow( vec2( massBase, massBase), ( VM[3].zw - massOffset ) );  // 0, -y\n        mass[4]   = pow( vec2( massBase, massBase), ( VM[4].zw - massOffset ) );  // 0, 0\n        mass[5]   = pow( vec2( massBase, massBase), ( VM[5].zw - massOffset ) );  // 0, +y\n        mass[6]   = pow( vec2( massBase, massBase), ( VM[6].zw - massOffset ) );  // +x, -y\n        mass[7]   = pow( vec2( massBase, massBase), ( VM[7].zw - massOffset ) );  // +x, 0\n        mass[8]   = pow( vec2( massBase, massBase), ( VM[8].zw - massOffset ) );  // +x, +y\n\n        // Calculate what the prior velocities were last iteration\n        VM[0].xy = VM[0].xy * 2.0 - 1.0;\n        VM[1].xy = VM[1].xy * 2.0 - 1.0;\n        VM[2].xy = VM[2].xy * 2.0 - 1.0;\n        VM[3].xy = VM[3].xy * 2.0 - 1.0;\n        VM[4].xy = VM[4].xy * 2.0 - 1.0;\n        VM[5].xy = VM[5].xy * 2.0 - 1.0;\n        VM[6].xy = VM[6].xy * 2.0 - 1.0;\n        VM[7].xy = VM[7].xy * 2.0 - 1.0;\n        VM[8].xy = VM[8].xy * 2.0 - 1.0;\n        \n        // Calculate the velocity magnitudes\n        float[9] Vmag;\n        Vmag[0] = length( VM[0].xy );\n        Vmag[1] = length( VM[1].xy );\n        Vmag[2] = length( VM[2].xy );\n        Vmag[3] = length( VM[3].xy );\n        Vmag[4] = length( VM[4].xy );\n        Vmag[5] = length( VM[5].xy );\n        Vmag[6] = length( VM[6].xy );\n        Vmag[7] = length( VM[7].xy );\n        Vmag[8] = length( VM[8].xy );\n        \n        // Adjust the slopes back to 0.5 to -.0.5\n        Sl[0].xy -= 0.5;  // -x, -y\n        Sl[1].xy -= 0.5;  // -x, 0\n        Sl[2].xy -= 0.5;  // -x, +y\n        Sl[3].xy -= 0.5;  // 0, -y\n        Sl[4].xy -= 0.5;  // 0, -y\n        Sl[5].xy -= 0.5;  // 0, +y\n        Sl[6].xy -= 0.5;  // +x, -y\n        Sl[7].xy -= 0.5;  // +x, 0\n        Sl[8].xy -= 0.5;  // +x, +y\n        \n        // Find all the slope magnitudes\n        float[9] Slmag;\n        Slmag[0] = length( Sl[0].xy );\n        Slmag[1] = length( Sl[1].xy );\n        Slmag[2] = length( Sl[2].xy );\n        Slmag[3] = length( Sl[3].xy );\n        Slmag[4] = length( Sl[4].xy );\n        Slmag[5] = length( Sl[5].xy );\n        Slmag[6] = length( Sl[6].xy );\n        Slmag[7] = length( Sl[7].xy );\n        Slmag[8] = length( Sl[8].xy );\n        \n        // Find the normal vector for friction\n        float vN[9];\n        vN[0] = cos( asin( Slmag[0] ) );\n        vN[1] = cos( asin( Slmag[1] ) );\n        vN[2] = cos( asin( Slmag[2] ) );\n        vN[3] = cos( asin( Slmag[3] ) );\n        vN[4] = cos( asin( Slmag[4] ) );\n        vN[5] = cos( asin( Slmag[5] ) );\n        vN[6] = cos( asin( Slmag[6] ) );\n        vN[7] = cos( asin( Slmag[7] ) );\n        vN[8] = cos( asin( Slmag[8] ) );\n        \n        // Adjust the mass of sediment\n        //float ht_water = h_mass * mass[4].x;\n        //float Vmag     = length( VM[4].xy );\n        //float Qmag     = Vmag * ht_water;\n        mass[0].y      = CCmult * mass[0].x * Slmag[0];\n        mass[1].y      = CCmult * mass[1].x * Slmag[1];\n        mass[2].y      = CCmult * mass[2].x * Slmag[2];\n        mass[3].y      = CCmult * mass[3].x * Slmag[3];\n        mass[4].y      = CCmult * mass[4].x * Slmag[4];\n        mass[5].y      = CCmult * mass[5].x * Slmag[5];\n        mass[6].y      = CCmult * mass[6].x * Slmag[6];\n        mass[7].y      = CCmult * mass[7].x * Slmag[7];\n        mass[8].y      = CCmult * mass[8].x * Slmag[8];\n        \n        // Diffuse the water from nearby cells\n        /*float htLW[9];\n        htLW[0] = HtPr[0].x + mass[0] * h_mass;\n        htLW[1] = HtPr[1].x + mass[1] * h_mass;\n        htLW[2] = HtPr[2].x + mass[2] * h_mass;\n        htLW[3] = HtPr[3].x + mass[3] * h_mass;\n        htLW[4] = HtPr[4].x + mass[4] * h_mass;\n        htLW[5] = HtPr[5].x + mass[5] * h_mass;\n        htLW[6] = HtPr[6].x + mass[6] * h_mass;\n        htLW[7] = HtPr[7].x + mass[7] * h_mass;\n        htLW[8] = HtPr[8].x + mass[8] * h_mass;*/\n        \n        // Adjust velocities based on relative height differences\n        \n        \n        // Adjust velocities based on acceleration in the travel direction\n        // mass * g * slope (dx or dy)\n        // HtPr[n].zw equivalent to sin(angle)\n        // vN[n] equivalent to cos(angle)\n        VM[0].xy += gdt * Sl[0].xy;\n        VM[1].xy += gdt * Sl[1].xy;\n        VM[2].xy += gdt * Sl[2].xy;\n        VM[3].xy += gdt * Sl[3].xy;\n        VM[4].xy += gdt * Sl[4].xy;\n        VM[5].xy += gdt * Sl[5].xy;\n        VM[6].xy += gdt * Sl[6].xy;\n        VM[7].xy += gdt * Sl[7].xy;\n        VM[8].xy += gdt * Sl[8].xy;\n        \n        float gdtmu = gdt * mu;\n        VM[0].xy *= ( 1.0 - gdtmu * vN[0] );\n        VM[1].xy *= ( 1.0 - gdtmu * vN[1] );\n        VM[2].xy *= ( 1.0 - gdtmu * vN[2] );\n        VM[3].xy *= ( 1.0 - gdtmu * vN[3] );\n        VM[4].xy *= ( 1.0 - gdtmu * vN[4] );\n        VM[5].xy *= ( 1.0 - gdtmu * vN[5] );\n        VM[6].xy *= ( 1.0 - gdtmu * vN[6] );\n        VM[7].xy *= ( 1.0 - gdtmu * vN[7] );\n        VM[8].xy *= ( 1.0 - gdtmu * vN[8] );\n\n        // Get rid of directions that can't interact\n        if( VM[0].x <= 0.0 ){ VM[0].x = 0.0; }\n        if( VM[0].y <= 0.0 ){ VM[0].y = 0.0; }\n        if( VM[1].x <= 0.0 ){ VM[1].x = 0.0; }\n        if( VM[2].x <= 0.0 ){ VM[2].x = 0.0; }\n        if( VM[2].y >= 0.0 ){ VM[2].y = 0.0; }\n\n        if( VM[3].y <= 0.0 ){ VM[3].y = 0.0; }\n        if( VM[5].y >= 0.0 ){ VM[5].y = 0.0; }\n\n        if( VM[6].x >= 0.0 ){ VM[6].x = 0.0; }\n        if( VM[6].y <= 0.0 ){ VM[6].y = 0.0; }\n        if( VM[7].x >= 0.0 ){ VM[7].x = 0.0; }\n        if( VM[8].x >= 0.0 ){ VM[8].x = 0.0; }\n        if( VM[8].y >= 0.0 ){ VM[8].y = 0.0; }\n\n        // Mass remaining center\n        mass[4] *= ( dx - abs( VM[4].x * dt ) ) / dx  * ( dy - abs( VM[4].y * dt ) ) / dy;\n\n        // Mass from edges\n        mass[0] *= VM[0].x * dtdx                    * VM[0].y * dtdy;\n        mass[1] *= VM[1].x * dtdx                    * ( dy - abs( VM[1].y * dt ) ) / dy;\n        mass[2] *= VM[2].x * dtdx                    * VM[2].y * dtdy * -1.0;\n        mass[3] *= ( dx - abs( VM[3].x * dt ) ) / dx * VM[3].y * dtdy;\n        mass[5] *= ( dx - abs( VM[5].x * dt ) ) / dx * VM[5].y * dtdy * -1.0;\n        mass[6] *= VM[6].x * dtdx * -1.0             * VM[6].y * dtdy;\n        mass[7] *= VM[7].x * dtdx * -1.0             * ( dy - abs( VM[7].y * dt ) ) / dy;\n        mass[8] *= VM[8].x * dtdx * -1.0             * VM[8].y * dtdy * -1.0;\n\n        // sum up the mass change from all border cells\n        vec2 mNew;\n        vec2 momNew;\n        vec2 vOut;\n        if( ht[4] >= 0.45 ){\n            mNew = mass[4];\n            // + mass in\n            mNew += mass[0] + mass[1] + mass[2];\n            mNew += mass[3] + mass[5];\n            mNew += mass[6] + mass[7] + mass[8];\n            if( mNew.x < massLimitLow ){ mNew.x = massLimitLow; }\n            if( mNew.x > massLimitHi ){ mNew.x = massLimitHi; }\n\n            // Add the contribution of precipitation\n            //float pr = float( ( (int(HtPr[4].w) & 0xFF) << 8 ) | (int(HtPr[4].z) & 0xFF) ) / 65535.0;\n            mNew.x += HtPr[4].z / 255.0 * dt;\n\n            // sum up the momentum change from all border cells\n            momNew = mass[4].x * VM[4].xy;\n\n            // + mom in\n            momNew = momNew + mass[0].x * VM[0].xy + mass[1].x * VM[1].xy + mass[2].x * VM[2].xy;\n            momNew = momNew + mass[3].x * VM[3].xy + mass[5].x * VM[5].xy;\n            momNew = momNew + mass[6].x * VM[6].xy + mass[7].x * VM[7].xy + mass[8].x * VM[8].xy;\n            //momNew = vec2( 0.0, 0.0 );\n            \n            // calculate the new cell velocity\n            vec2 vNew = momNew / mNew.x;\n            vOut = ( vNew + 1.0 ) / 2.0;\n        } else {\n            vOut = vec2( 0.5, 0.5 );\n            mNew.x = 0.09;\n        }\n\n        fragColor = vec4( vOut.xy,log( mNew.x )/lnMB+massOffset,log( mass[4].y )/lnMB+massOffset );\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Change these to change how the shader performs\n// Changes the height and precipitation maps\nvec2 hashVec0     = vec2(127.1,311.7);\nvec2 hashVec1     = vec2(269.5,183.3);\nfloat hashSinSeed = 43758.5453123;  // Valid out to ~5,000,000\n\nconst float massBase     = 128.0;  // ~0.09 min, ~11 max\nconst float massOffset   = 0.5;\nconst float massLimitLow = pow( massBase,-massOffset );\nconst float massLimitHi  = pow( massBase,1.0-massOffset );\nconst float lnMB       = log(massBase);\nconst float dx      = 1.0;\nconst float dy      = dx;\nconst float g       = 9.81;\nconst float area    = dx * dy;\nconst float h_mass  = 0.5 / 65535.0 / area;\n\nconst float mu      = 0.005;\n\nconst float CCmult  = 100.0;\nconst float eroRate = 0.4 / 65535.0 / area;\n\nconst float dt      = 0.2;\nconst float dtdx    = dt / dx;\nconst float dtdy    = dt / dy;\nconst float gdt     = g * dt;","name":"Common","description":"","type":"common"}]}