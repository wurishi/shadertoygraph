{"ver":"0.1","info":{"id":"lljBRz","date":"1517260015","viewed":79,"name":"RayMarching problems with twist","username":"demicuz","description":"Problems with non-rigid transformations.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Move the mouse to bend the cube\n// Green - how many steps it took to render a pixel\n\n// comment this line to see the correct image\n#define problem  \n\n// see lines 91-95\n\nprecision highp float;\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON  = 1e-4;\n\nconst float PI = atan(1.) * 4.;\n\nvec2 m;  // normalized mouse coords, assigned in mainImage\nvec3 light = normalize(vec3(-1., -2., -4.));\n\nmat3 rotateY(float angle) {\n    float c = cos(angle),\n          s = sin(angle);\n    \n    vec3 i = vec3(c, .0,  -s);\n    vec3 j = vec3(.0, 1., .0);\n    vec3 k = vec3(s, .0, c);\n    \n    return transpose(mat3(i, j, k));\n}\n\nmat3 rotateX(float angle) {\n    float c = cos(angle),\n          s = sin(angle);\n    \n    vec3 i = vec3(1., .0, .0),\n         j = vec3(.0,  c,  s),\n         k = vec3(.0, -s,  c);\n    \n    return transpose(mat3(i, j, k));\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat weirdBoxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size / 2.;\n    \n    float mx = max(max(d.x, d.y), d.z);\n    float mn = min(min(d.y, d.y), d.z);\n    \n    float inDist  = min(mx, 0.);\n    float outDist = length(min(d, .0));\n    \n    return inDist + outDist;\n}\n\nfloat sdBox(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size / 2.;\n    \n    float mx = max(max(d.x, d.y), d.z);\n    \n    float inDist  = min(mx, 0.);\n    float outDist = length(max(d, .0));\n    \n    return inDist + outDist;\n}\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(m.x*10.0*p.y);\n    float s = sin(m.x*10.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdBox(q, vec3(1.));\n}\n\n// t.x - radius\n// t.y - thickness\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdScene(vec3 p) {\n    p = rotateX(sin(iTime/2.) * PI / 2.) * p;\n    \n    float s = m.x;\n    \n    # ifdef problem\n    \treturn opTwist(p);\n    # else\n    \treturn opTwist(p) / max((m.x*10.), 1.);\n    # endif\n}\n\n\nvec3 getNormal(vec3 p) {\n    const float eps = 3.0 * EPSILON;\n    return normalize(vec3(\n        sdScene(vec3(p.x + eps, p.y, p.z)) - sdScene(vec3(p.x - eps, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + eps, p.z)) - sdScene(vec3(p.x, p.y - eps, p.z)),\n        sdScene(vec3(p.x, p.y, p.z + eps)) - sdScene(vec3(p.x, p.y, p.z - eps))\n    ));\n}\n\n\nvec2 march(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sdScene(eye + depth * dir);\n        \n        if (dist < EPSILON) {\n            return vec2(depth, i);\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) return vec2(end, i);\n    }\n    \n    return vec2(end, MAX_MARCHING_STEPS);\n}\n\n\n// fov - in degrees\nvec3 getRayDirection(float fov, vec2 resolution, vec2 fragCoord) {\n    fragCoord -= resolution / 2.;\n    \n    float y = resolution.y / 2.;\n    float z = y / tan(radians(fov / 2.));\n    \n    return normalize(vec3(fragCoord, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tm = iMouse.xy / iResolution.xy;\n    \n    vec3 eye = vec3(.0, .0, 4.);\n    vec3 viewDir = getRayDirection(45., iResolution.xy, fragCoord);\n    \n    vec2 marched = march(eye, viewDir, MIN_DIST, MAX_DIST);\n    float dist = marched.x;\n    float st_norm = marched.y / float(MAX_MARCHING_STEPS);\n    \n    vec3 col = vec3(.0);\n    \n    if (dist > MAX_DIST - EPSILON) { // didn't hit anything\n        col = vec3(.0, st_norm, .0);\n    } else {\n        vec3 n = getNormal(eye + dist * viewDir);\n        \n        float li = dot(n, -light); // light intensity\n        \n        col = vec3(max(.1, li), st_norm, .0);\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}