{"ver":"0.1","info":{"id":"ltSfWD","date":"1518659195","viewed":295,"name":"â™« InFX.2 - Arming a mine.","username":"patu","description":"Every pass needs a lot of work but it looks okeish already.\nalso, code needs cleanup. ","likes":16,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","dof","bloom","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\n\t\n\thttp://bit.ly/shadertoy-plugin\n    https://github.com/patuwwy/ShaderToy-Notifier\n\n\n*/\n\n\n/// fake DOF + Bloom\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 \n        buff = texture(iChannel0, uv),\n        mipm = textureLod(iChannel0, uv, 6.),\n        blur = textureLod(iChannel0, uv, 5.);\n    \n    float dof = buff.a;\n    \n\tfragColor = mix(buff, blur, clamp(dof, 0., 1.));\n    \n    vec4 bm = dot(mipm.rgb, W) >\n        dot(buff.rgb, W) ? mipm : buff;                      \n    \n    fragColor += pow(bm * dot(bm.rgb, W) * 2., vec4(3.1)) * .8;\n    \n    fragColor = pow(fragColor, vec4(1.2));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4d3Gzr","filepath":"https://soundcloud.com/onyx-recordings/operate-acid-ghost?si=44886198f5b9438d9fc5bb87cf7c4987&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/onyx-recordings/operate-acid-ghost?si=44886198f5b9438d9fc5bb87cf7c4987&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// volume smoothing\n\n#define ENABLED true\nconst float FALL = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if ( fragCoord.y < 10.) \n    {\n        float old = texture(iChannel1, uv).r;\n        float new;// previous frame\n    \tfloat current = clamp(\n            pow(\n                texelFetch(iChannel0, ivec2(uv), 0).r * 1.2,\n                1.\n            ), \n            0.,\n            1.\n    \t); \n    \n        if (current > old + .9) {\n            new = current;\n        } else {\n            new = old - FALL / fragCoord.y;\n            \n        }\n        \n        if (fragCoord.y == 9.) {\n            texelFetch(iChannel0, ivec2(uv), 0).r;\n        }\n        \n        fragColor = vec4(clamp(new, 0., 1.));\n    } else {\n        fragColor = vec4(iChannelTime[0]);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// main render\n// lot of code comes from http://mercury.sexy/hg_sdf\n\n\n#define getNormal getNormalHex\n\n#define FAR 500.\n#define INFINITY 1e32\n//#define time iChannelTime[1]\n#define mt iChannelTime[1]\n#define FOV 130.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n// globals\nfloat spikesHeight = 0.;\nfloat pattern;\nfloat patternHash;\nfloat time;\nfloat vol2;\n\nvec3 h, dpb;\nfloat part2Time;\nbool close = false;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// int hash\n#define kk 1103515245U\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*kk;\n    x = ((x>>8U)^x.yzx)*kk;\n    x = ((x>>8U)^x.yzx)*kk;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat vol = 0.;\n\nvec3 light = vec3(20., 40., 10.);        \nconst vec3 lightColour = normalize(vec3(0., .0, 1.)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 ballPos = vec3(0.);\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nvec3 discoBall(vec3 p) {\n    \n    p -= ballPos;\n    pR(p.xz, part2Time * .3 - min(1., part2Time) * vol * 1.5);\n    pR(p.yz, part2Time * .24 - min(1., part2Time) * vol * .5);\n    \n    dpb = p;\n    \n    float pxz = pModPolar(p.xz, 12. + vol2 * 20.);//ceil(vol2 * 10.));// * hash12(vec2(floor(part2Time * 3.55))) * min(part2Time, 30.));\n    float pyz = pModPolar(p.xy, 12.);\n    \n    return vec3(\n        fOpUnionColumns(\n            fBox(p, vec3(1., 10., 1.)), \n            fCone(p.zxy, 1., spikesHeight + vol + 15. *texelFetch(iChannel0, ivec2(pxz * pxz * .4,0.), 0).r), \n            8., 16.\n        ),\n        3.,\n        0.5\n    );\n\n}\n\nvec3 floorDF(vec3 p, vec2 r) {\n    return vec3(p.y + 15., 1., 0.);   \n}\n\nvec3 distanceFunction(vec3 p) {\n    vec3 op = p, obj = vec3(FAR, 0., 0.), fl = obj;\n\n    fl = opU2(\n        fl,\n        floorDF(p, vec2(0.))\n    );\n    \n    vec3 dBall = discoBall(op) ;\n    \n    return opU2(dBall, fl) - .02;\n}\n\n// \n//http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n//\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 200;\n\nvec3 trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.0025;\n    float functionSign = distanceFunction(o).x < 0. ? -1. : +1.;\n    vec3 mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = distanceFunction(d * t + o);\n        \n        float signedRadius = functionSign * mp.x * 1.;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        \tstepLength = signedRadius * omega * .4;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength * .8;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return vec3(INFINITY, 0., 0.);\n    \n    return vec3(candidate_t, mp.yz);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 28;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 0.;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = distanceFunction(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.4), 1.0);\n}\n\n#define EPSILON .01\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=distanceFunction(pos).x;\n\treturn normalize(\n        vec3(\n            distanceFunction(\n                pos+vec3(EPSILON,0,0)).x-d,\n                distanceFunction(pos+vec3(0,EPSILON,0)).x-d,\n                distanceFunction(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = distanceFunction(spos).x;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nfloat tri( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   vec3 lc = vec3(1., 0.5, 1.) * .5;\n   float sunSize = .5;\n   float sunAmount = max(dot(rd, lightDir), 0.4);\n   float v = pow(abs(1.2 - max(rd.y, 0.0)), 2.1);\n   vec3 sky = mix(vec3(.1, .2, .3), vec3(.3), v);\n   if (showSun == false) sunSize = .1;\n   sky += lc * sunAmount * sunAmount * 1. + lc * min(pow(sunAmount, 442.0)* sunSize, 0.2 * sunSize);\n   return clamp(sky, 0.0, 1.0);\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec3 obj) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp- sp; \n    float lDist = max(length(ld / 2.), 0.001); \n    ld /= lDist;\n\n    float atten = 1.0 / (1.0 + lDist * 0.025 + lDist * lDist * 0.02);\n    float diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 2.0);\n\n    //vec3 objCol = getObjectColor(sp, sn, obj);\n    sceneCol += (vec3(1.) * (diff + 1.2) * spec * 2.6) * atten;\n   \n    return sceneCol;\n}\n\nvoid calcGlobals()\n{\n    time = texelFetch(iChannel0, ivec2(0, 20), 0).r;\n\tspikesHeight = clamp(time, 4., 10.);\n    pattern = floor(time / (55. / 4.));\n    patternHash = hash12(vec2(pattern));\n    \n    part2Time = max(0., time - 55.);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    calcGlobals();\n    \n    ballPos.y += 25.;\n    \n    uv *= tan(radians (FOV) / 2.0) * .3;\n\t\n    light.z += 24.;\n    light += ballPos;\n    \n    light.xy += patternHash;\n    \n    vol = texelFetch(iChannel0, ivec2(160, 0), 0).r  * 1.; \n\tvol2 = texelFetch(iChannel0, ivec2(30., 9.), 0).r;\n    \n    h = hash(uvec3((max(31., vol) - 31.) / 4. * 60.));\n\t\n\n    \n    float \n        sk = sin(-time * .3 + patternHash * 10.) * 22.0, \n        ck = cos(-time * .3 + patternHash * 10.) * 22.0;    \n    \n    vec3 \n        vuv = vec3(0., 1., 0.),\n    \tro = vec3(0. + ck, 14. + patternHash * 20., 0.+ sk);\n    \n    ro += ballPos;\n    \n    vec3    vrp = vec3(0., 0., 0.) + ballPos;\n    //vrp.y = 0.;\n    vrp.x -= tri(vec2(ro.yz * .1)) * 3.;\n        \n    vec3\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n\t\n    vec3 tr = trace(ro, rd);    \n    \n    ro += rd * tr.x;\n    vec3 hit = ro;\n    vec3 oro = ro;\n    \n    vec3 skyns = Sky(rd, false, normalize(light));\n    vec3 otr = tr;\n    vec3 osn;\n    vec3 sn;\n    \n    vec3 sceneColor = vec3(0.);//sky;\n    \n    float dof = 1.;    \n    \n    if (tr.x < FAR) { \n        \n        sn = getNormal(ro);\n        osn = sn;\n        \n        sceneColor = saturate(doColor(ro, rd, sn, light, tr));\n\n        sceneColor *= getAO(ro, sn, 1.);\n        sceneColor *= softShadow(ro, light, 123.2);\n        \n        dof = tr.x / FAR * 2.;\n        \n        if (tr.y == 3.) {\n            rd = mix(rd, reflect(rd, sn), .45);\n\n\t\t\tvec3 oro2 = ro;\n            ro += rd * .01;\n            tr = trace(ro, rd); \n            \n            ro += rd * tr.x;\n            \n            if (tr.x < FAR) {\n                sn = getNormal(ro);\t\n                sceneColor += saturate(doColor(ro, rd, sn, light, tr));\n                sceneColor *= saturate(getAO(ro + sn * 1., sn, 3.));\n                \n                sceneColor += pow(abs(3.-min(1., length(oro * .06)) * 3.), 2.) * .2 * vec3(1., .5, 0.);\n                sceneColor += clamp(pow((abs(sin(dpb.y * .2 - iTime * 3.55 / 2.  - h.z))), 125.), 0., 1.);    \n            } \n            \n            ro = oro2;\n        } \n     \t\n        sceneColor += mix(vec3(1.), vec3(1., 0.5, 0.), vec3(fract(time * 3.55 / 4.))) * pow((abs(sin(length((hit - ballPos) * .05) - iTime * 3.55 / 2.- h.z))), 25.) * 1.;\n        sceneColor = mix(sceneColor, skyns, saturate(otr.x * 2.7 / FAR));\n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), dof );\n}\n","name":"Buffer B","description":"","type":"buffer"}]}