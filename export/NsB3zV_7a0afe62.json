{"ver":"0.1","info":{"id":"NsB3zV","date":"1617635087","viewed":281,"name":"N-Sided wireframe cylinder","username":"Hyeve","description":"A fun shader that renders a spinning, N-Sided wireframe cylinder! You can also change the rotation ellipses with squish and expand.\n\nCollab with @Tater\nSee their version: [url] https://www.shadertoy.com/view/NsB3zK[/url]","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["wireframe","nsided"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\n\nfloat lsdf(vec2 p, vec2 a, vec2 b ) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float points = 8.;\n    float height = 0.5;\n    float squish = 12.;  \n    float expand = 2.6;\n    float glow = 300.;\n    \n    \n    float bright = 0.;\n    \n    for(float i = 0.; i < points; i++)\n    {\n        vec2 point1 = vec2(sin((i/points + iTime / 4.) * 2. * pi) / expand, cos((i/points + iTime / 4.) * 2. * pi) / squish) + vec2(0., 0.3);\n        vec2 point10 = vec2(sin(((i - 1.)/points + iTime / 4.) * 2. * pi) / expand, cos(((i - 1.)/points + iTime / 4.) * 2. * pi) / squish) + vec2(0., 0.3); \n        vec2 point11 = vec2(sin(((i + 1.)/points + iTime / 4.) * 2. * pi) / expand, cos(((i + 1.)/points + iTime / 4.) * 2. * pi) / squish) + vec2(0., 0.3); \n        \n        vec2 point2 = point1 - vec2(0.,height);\n        vec2 point20 = point10 - vec2(0.,height);\n        vec2 point21 = point11 - vec2(0.,height);\n    \n        if((point1.x > point11.x || point1.x < point11.x && point1.x < point10.x) || points < 2.)\n        {       \n            bright += step(lsdf(uv, point1, point2), 0.009);\n            bright += abs(1.0 / (glow * lsdf(uv,point1,point2)));     \n        }\n        \n        bright += step(lsdf(uv, point1, point11), 0.009);\n        bright += abs(1.0 / (glow * lsdf(uv,point1,point10))); \n              \n        if(point2.x > point21.x || points < 2.)\n        {    \n            bright += step(lsdf(uv, point2, point21), 0.009);   \n            bright += abs(1.0 / (glow * lsdf(uv,point2,point21)));\n        }\n        \n    \n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(0.,bright,bright,1.);\n}","name":"Image","description":"","type":"image"}]}