{"ver":"0.1","info":{"id":"WtsyR8","date":"1591806798","viewed":163,"name":"Octahedralis III","username":"sl2c","description":"The three color channels are based on [url=https://arxiv.org/abs/2002.00239]Bachman-Segerman-Schleimer cohomology fractals[/url].  (A version where I got some numbers wrong I also ended up liking, so you might see it soon.)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circles","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \nfloat s = 0.4142135623730951; // silver ratio\n\nvoid octant1(inout vec3 z, inout vec3 coh, inout bool[3] fls) {\n    if (z.x < 0.0) {\n        z.x = -z.x;\n        coh[2]=-coh[2];\n        fls[2]=!fls[2];\n    }\n    if (z.y < 0.0) {\n        z.y = -z.y;\n        coh[1]=-coh[1];\n        fls[1]=!fls[1];\n    }\n    float r2 = dot(z,z);\n    if (r2 > 1.0) {\n        z /= r2;\n        coh[0]=-coh[0];\n        fls[0]=!fls[0];\n    }\n}\n\nvec3 color(vec3 z, bool fl) {\n    vec3 coh = vec3(0.0);\n    bool[3] fls = bool[](fl, fl, fl);\n    \n    float r2;\n    for(int i=0;i<40;i++) {\n        \n        octant1(z, coh, fls);\n        z -= vec3(s,s,0);\n        r2 = dot(z,z);\n        if (r2 < s * s) {\n            z *= s * s / r2;\n            fl = !fl;\n        }\n        z += vec3(s,s,0);\n        \n        \n        octant1(z, coh, fls);\n        \n        r2 = dot(z,z);\n        if (r2 < s*s) {\n            z *= s * s / r2;\n            coh[0]=-coh[0]-1.0; fls[0]=!fls[0];\n        }\n        z.y -= s + 1.0;\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n            coh[1]=-coh[1]-1.0; fls[1]=!fls[1];\n        }\n        z.y += s + 1.0;\n        \n        z.x -= s + 1.0;\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n            coh[2]=-coh[2]-1.0; fls[2]=!fls[2];\n        }\n        z.x += s + 1.0;\n        \n    }\n    octant1(z, coh, fls);\n    for (int j=0; j<3; j++) {\n        if (fls[j]) {\n            coh[j]=-coh[j];\n        }\n    }\n    coh = coh / (1.5 + abs(coh));\n    return 0.5 + coh * 0.45;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n    \n    float period = 4.2549485065150545;\n    float t = iTime * 0.5;\n    bool r = false;\n    \n    while (t > period * 0.5) {\n        t -= period;\n        float c = 0.766311365; float s = -0.64246936;\n        uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);\n        r = !r;\n    }\n    \n    vec3 z = vec3(uv,ds); z*=3.5;\n    z *= exp(-t); ds *= exp(-t);\n    \n    z += vec3(0.25262046414724887,-1.0187347727326157,0);\n\tz /= dot(z,z);\n    z += vec3(0.22732631827540598,0.4228686518338363,0);\n\n    fragColor = vec4(color(z,r),1.0);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"}]}