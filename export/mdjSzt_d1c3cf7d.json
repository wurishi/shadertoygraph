{"ver":"0.1","info":{"id":"mdjSzt","date":"1670758847","viewed":131,"name":"Fake cone light","username":"Chango","description":"Fake cone light","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fakeconelight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Work Here!\n#define OBJNUM 3\n\n#define MaxTraceDis 10.\n#define MaxTraceTime 80.\n#define TraceThre 0.01f\n#define NormalEpsilon 0.01f\n\n//Custom\n\nTraceInfo tt;\nfloat glowAcc;\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat SDFConeLight(vec3 p)\n{\n    float a = 60./180.*PI;\n    vec3 tip = vec3(0.,2.,0.);\n    p-=tip;\n    float len = length(p);\n    float re = 2.0/(len*len)* sdCone(p,vec2(sin(a),cos(a)),4.);\n    return re;\n}\n\n\n//Work Here!\nfloat GetObjSDF(int inx, vec3 p, in TraceInfo traceInfo)\n{\n\tswitch(inx)\n    {\n        //case 0: return SDFConeLight(p);\n        case 0: break;\n        case 1:\n        return -0.4*fbm2(p+iTime)+SDFSphere(p,vec3(sin(iTime),0.,0.),0.3);break;\n            case 2:return SDFBox(p,vec3(0.,-1.,0.),vec3(3.,0.1,3.));break;\n    }\n    return MAXFLOAT;\n}\n\nvec3 GetObjSDFNormal(int inx, vec3 p, in TraceInfo traceInfo);\n//Can optimize Here!\nvec3 GetObjNormal(int inx, vec3 p, in TraceInfo traceInfo)\n{\n\treturn GetObjSDFNormal(inx, p, traceInfo);\n}\n\n//Work Here!\nMaterial_PBR GetObjMaterial_PBR(int obj)\n{\n\tMaterial_PBR re;\n\tInit(re);\n\n\t//Work Here!\n    if(obj == 6)\n    {\n        re.albedo = vec3(1.,0.,0.);\n    }\n    \n\treturn re;\n}\n\n//Work Here!\nint GetObjRenderMode(int obj)\n{\n\tif(obj == 0)\n    {\n        return 0;\n    }\n}\n\n//Can Work Here!\nvoid ObjPreRender(inout int mode, inout Material_PBR mat, inout Ray ray, inout HitInfo minHit)\n{\n    int inx = minHit.obj;\n    /*\n    if(inx == 6)\n    {\n     minHit.P += minHit.N *1.1*fbm4(10.*minHit.P);\n    }\n    */\n}\n\n\n//Can Work Here!\nvoid ObjPostRender(inout vec3 result, inout int mode, inout Material_PBR mat, inout Ray ray, inout HitInfo minHit)\n{\n    int inx = minHit.obj;\n   \n   //if(inx)\n\n    //result = 1.0 - exp(-result);\n    result = pow(result,vec3(2.2));\n}\n//------------------------------------------------\nvec3 GetObjSDFNormal(int inx, vec3 p, in TraceInfo traceInfo)\n{\n //float eplisonScale = 1.;\n\t//float normalEpsilon = NormalEpsilon;\n    //return normalize(vec3(1.));\n    /*\n\treturn normalize(vec3(\n\t\tGetObjSDF(inx, vec3(p.x + NormalEpsilon*eplisonScale, p.y, p.z), traceInfo) - GetObjSDF(inx, vec3(p.x - NormalEpsilon*eplisonScale, p.y, p.z), traceInfo),\n\t\tGetObjSDF(inx, vec3(p.x, p.y + NormalEpsilon*eplisonScale, p.z), traceInfo) - GetObjSDF(inx, vec3(p.x, p.y - NormalEpsilon*eplisonScale, p.z), traceInfo),\n\t\tGetObjSDF(inx, vec3(p.x, p.y, p.z + NormalEpsilon*eplisonScale), traceInfo) - GetObjSDF(inx, vec3(p.x, p.y, p.z - NormalEpsilon*eplisonScale), traceInfo)\n\t\t));*/\n\n    float h = NormalEpsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*GetObjSDF(inx, p + k.xyy*h, traceInfo) + \n                      k.yyx*GetObjSDF(inx, p + k.yyx*h , traceInfo) + \n                      k.yxy*GetObjSDF( inx,p + k.yxy*h , traceInfo) + \n                      k.xxx*GetObjSDF(inx, p + k.xxx*h, traceInfo ) );\n}\n\n//Can Change Here\nvoid TraceScene(Ray ray, out HitInfo info)\n{\n\tfloat traceThre = TraceThre;\n    float minSDF = MAXFLOAT;\n\tInit(info);\n\n\tTraceInfo traceInfo;\n\tInit(traceInfo);\n\tvec3 oriPos = ray.pos;\n\n\tfloat objSDF[OBJNUM];\n\tint objInx = -1;\n\tfloat sdf = MAXFLOAT;\n\n\twhile (float(traceInfo.traceCount) <= MaxTraceTime)\n\t{\n\t\tobjInx = -1;\n\t\tsdf = MAXFLOAT;\n\n\t\tfor (int inx = 0; inx < OBJNUM; inx++)\n\t\t{\n\t\t\tobjSDF[inx] = GetObjSDF(inx, ray.pos, traceInfo);\n\t\t\tif (objSDF[inx] < sdf)\n\t\t\t{\n\t\t\t\tsdf = objSDF[inx];\n\t\t\t\tobjInx = inx;\n\t\t\t}\n\t\t}\n\n\n\t\tif(objInx == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n        \n        if(sdf<minSDF)\n        {\n            minSDF = sdf;\n        }\n\n\t\tif (sdf > MaxTraceDis)\n\t\t{\n\t\t\tbreak;\n\t\t}\n        float coneLight = SDFConeLight(ray.pos);\n        \n        glowAcc += 0.1*max(-coneLight,0.);\n\n\t\tif (sdf <= traceThre)\n\t\t{\n\t\t\tinfo.bHit = 1;\n\t\t\tinfo.obj = objInx;\n\t\t\tinfo.N = GetObjNormal(objInx, ray.pos, traceInfo);\n\t\t\tinfo.P = ray.pos;\n\t\t\tbreak;\n\t\t}\n\t\tray.pos += sdf * ray.dir;\n\t\tUpdate(traceInfo,sdf);\n\t\ttraceInfo.traceSum = length(ray.pos - oriPos);\n\t}\n}\n\nfloat GetPntlightAttenuation(vec3 pos, vec3 lightPos)\n{\n\tfloat d = length(pos - lightPos);\n\treturn saturate(1. / (d*d));\n\t//return 1 / (1 + 0.01*d + 0.005*d*d);\n}\n\nvec3 RenderSceneObj(Ray ray, inout HitInfo minHit, inout Material_PBR mat)\n{\n\tint mode = GetObjRenderMode(minHit.obj);\n\tObjPreRender(mode, mat, ray, minHit);\n\tvec3 result = vec3(0.);\n\t//###BLOCK ObjRender\n\t//Can Work Here!\n\tif(mode==0)\n\t{\n\t\tvec3 lightDirs[2];\n\t\tvec3 lightColors[2];\n        vec3 lightPos[2];\n        lightPos[0] = vec3(0.,1.,1.);\n        \n\t\tlightDirs[0] = normalize(minHit.P - lightPos[0]);\n\t\tlightColors[0] = 0.*vec3(0., 0., 1.) * GetPntlightAttenuation(minHit.P, lightPos[0]);\n\t\tlightDirs[1] = vec3(0.4255954, -0.7770073, -0.4638191);\n\t\tlightColors[1] = 1.*vec3(1, 1, 1);\n\t\tresult.rgb = 0.0 * mat.albedo * mat.ao;\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tresult.rgb += PBR_GGX(mat, minHit.N, -ray.dir, -lightDirs[i], lightColors[i]);\n\t\t}\n\t}\n\t//###BLOCK\n\tObjPostRender(result, mode, mat, ray, minHit);\n\treturn result;\n}\n\nvec3 GetSDFGameColor(in Ray ray, out HitInfo minHit, out Material_PBR mat)\n{\n\tInit(mat);\n\tvec3 re = vec3(0.);\n\t//---Trace\n\tInit(minHit);\n\tTraceScene(ray, minHit);\n\t//___Trace\n\nif (minHit.bHit == 1)\n{ \n\tmat = GetObjMaterial_PBR(minHit.obj);\n\t//if(mat.reflective<0.001)\n\t//{\n\tre = RenderSceneObj(ray, minHit, mat);\n\t//}\n\t//else if (mat.reflective<0.999)\n\t//{\n\t//\tre = lerp(RenderSceneObj(ray, minHit, mat),SceneRenderReflect(ray, minHit,mat),mat.reflective);\n\t//}\n\t//else\n\t//{\n\t//re = SceneRenderReflect(ray, minHit,mat);\n\t//}\n\t//re *= RenderSceneSDFShadow(minHit);\n}\nelse\n{\n\t//re = (@BackGroundColor);\n\t//re = GetEnvIrradiance_equirectangular(envBgTex, ray.dir, true);\n\t//re = stars(ray.pos, ray.dir);\n\tre = vec3(0.);\n}\n\n\treturn re;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Custom\n    glowAcc = 0.;\n    \n    HitInfo minHit;\n    Material_PBR mat;\n    \n    Ray ray;\n    vec2 rotCenter = vec2(0.);\n    vec2 eye = vec2(0.0, 10.0);\n    ray.pos = vec3(eye.x, 0.0, eye.y);\n    ray.dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 re = GetSDFGameColor(ray,minHit,mat);\n    \n    float rim = fract(0.1*iTime)<0.5 ? 0.:1.;\n    re += glowAcc*vec3(1.,0.,0.5)*mix(1.,saturate(dot(minHit.N,vec3(0.,1.,0.0))),rim);\n\n    //dither to smooth: https://www.shadertoy.com/view/NldfRl\n    //re += texelFetch(iChannel0, ivec2(fragCoord) & 1023, 0).rgb * vec3(1.0 / 256.0);\n    // Output to screen\n    fragColor = vec4(re,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAXFLOAT 3.402823e38f\n#define PI 3.1415926\n\nvec2 rotate(vec2 p, float a)\n{\n\tfloat c = cos(a), s = sin(a);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn m*p;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x,0.,1.);\n}\n    \nstruct Ray\n{\n\tvec3 pos;\n\tvec3 dir;\n};\n\nstruct HitInfo\n{\n\tint bHit;\n\tint obj;\n\tvec3 N;\n\tvec3 P;\n};\n\nstruct TraceInfo\n{\n\tint traceCount;\n\tfloat traceSum;\n\tfloat lastTrace;\n};\n\nvoid Init(out HitInfo re)\n{\n\tre.bHit = 0;\n\tre.obj = -1;\n\tre.N = vec3(0.);\n\tre.P = vec3(0.);\n}\n\nvoid Init(out TraceInfo re)\n{\n\tre.traceCount = 0;\n\tre.traceSum = 0.;\n\tre.lastTrace = MAXFLOAT;\n}\n\nvoid Update(inout TraceInfo traceInfo, float sdf)\n{\n\ttraceInfo.traceCount += 1;\n\ttraceInfo.lastTrace = sdf;\n}\n\nfloat SDFSphere(vec3 p, vec3 center, float radius)\n{\n\treturn length(p - center) - radius;\n}\n\nfloat SDFBox(vec2 p, vec2 center, vec2 bound)\n{\n\tvec2 q = abs(p - center) - bound;\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat SDFBox(vec3 p, vec3 center, vec3 bound)\n{\n\t//return SDFSphere(p, center, 1);\n\tvec3 q = abs(p - center) - bound;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nstruct Material_PBR\n{\n\tvec3 albedo;\n\tfloat metallic;\n\tfloat roughness;\n\tfloat ao;\n\tfloat reflective;\n\tvec2 reflect_ST;\n\tfloat alpha;\n};\n\nvoid Init(out Material_PBR mat)\n{\n\tmat.albedo = vec3(1.);\n\tmat.metallic = 0.;\n\tmat.roughness = 1.;\n\tmat.ao = 1.;\n\tmat.reflective = 0.;\n\tmat.reflect_ST = vec2(1.,0.);\n\tmat.alpha = 1.;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n\treturn F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n\tfloat r = (roughness + 1.0);\n\tfloat k = (r*r) / 8.0;\n\n\tfloat nom = NdotV;\n\tfloat denom = NdotV * (1.0 - k) + k;\n\n\treturn nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n\tfloat NdotV = max(dot(N, V), 0.0);\n\tfloat NdotL = max(dot(N, L), 0.0);\n\tfloat ggx2 = GeometrySchlickGGX(NdotV, roughness);\n\tfloat ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n\treturn ggx1 * ggx2;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n\tfloat a = roughness * roughness;\n\tfloat a2 = a * a;\n\tfloat NdotH = max(dot(N, H), 0.0);\n\tfloat NdotH2 = NdotH * NdotH;\n\n\tfloat nom = a2;\n\tfloat denom = (NdotH2 * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n\n\treturn nom / denom;\n}\n\nvec3 PBR_GGX(Material_PBR param, vec3 n, vec3 v, vec3 l, vec3 Li)\n{\n\tvec3 h = normalize(l + v);\n\n\t//Calculate F\n\tvec3 F0 = vec3(0.04);\n\tF0 = mix(F0, param.albedo, param.metallic);\n\tvec3 F = fresnelSchlick(max(dot(h, v), 0.0), F0);\n\n\t//Calculate diffuse\n\tvec3 kD = 1.0 - F;\n\tvec3 diffuse = (1.0 - param.metallic) * kD * param.albedo / PI;\n\n\t//Calculate specular\n\tfloat G = GeometrySmith(n, v, l, param.roughness);\n\tvec3 nominator;\n\tfloat NDF = DistributionGGX(n, h, param.roughness);\n\tnominator = NDF * G * F;\n\tfloat denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, l), 0.0) + 0.001;\n\tvec3 specular = nominator / denominator;\n\n    float diffuseRate = 1.0f;\n    float specularRate = 1.0f;\n\tvec3 Lo = diffuse * diffuseRate + specular * specularRate;\n\tLo *= Li * max(dot(n, l), 0.);\n\n\treturn Lo;\n}\n\nfloat iqhash(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise_computational(in vec3 x)\n{\n\t// The noise function returns a value in the range -1.0f -> 1.0f\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f * f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(iqhash(n + 0.0), iqhash(n + 1.0), f.x),\n\t\tmix(iqhash(n + 57.0), iqhash(n + 58.0), f.x), f.y),\n\t\tmix(mix(iqhash(n + 113.0), iqhash(n + 114.0), f.x),\n\t\t\tmix(iqhash(n + 170.0), iqhash(n + 171.0), f.x), f.y), f.z);\n}\n\n\nfloat noise(in vec3 x)\n{\n\t//return noise_texBase(x);\n\treturn noise_computational(x);\n}\n\nfloat fbm4(in vec3 p)\n{\n\tfloat n = 0.0;\n\tn += 1.000*noise(p*1.0);\n\tn += 0.500*noise(p*2.0); \n\tn += 0.250*noise(p*4.0);\n\tn += 0.125*noise(p*8.0);\n\treturn n;\n}\n\nfloat fbm2(in vec3 p)\n{\n\tfloat n = 0.0;\n\tn += 1.000*noise(p*1.0);\n\tn += 0.500*noise(p*2.0); \n\treturn n;\n}\n\nvec3 GetGridCenter_DownMode(vec3 p, vec3 grid, vec3 offset)\n{\n\tp -= offset;\n\tfloat dis = grid.y;\n\tfloat m = round(p.y / dis);\n\tfloat centerY = m * dis;\n\n\tvec2 grid2 = grid.xz;\n\tvec2 m1 = floor(p.xz / grid2);\n\tvec2 c = grid2 * (m1 + 0.5);\n\treturn vec3(c.x, centerY, c.y) + offset;\n}","name":"Common","description":"","type":"common"}]}