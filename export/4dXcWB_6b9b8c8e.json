{"ver":"0.1","info":{"id":"4dXcWB","date":"1489594048","viewed":175,"name":"Mellow rainbow blob","username":"bwestlin","description":"Raymarching adaptation of https://www.shadertoy.com/view/ldGSWV","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sound","sines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n#define ic0 iChannel0\n\nconst float EPS = 0.001;\nconst float MAX_ITER = 40.0;\nconst float MAX_T = 100.0;\n\nvec3 simple_camera(vec2 uv) {\n    vec3 forward = vec3(0.0, 0.0, -1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 side = vec3(1.0, 0.0, 0.0);\n    return normalize(forward + uv.x * side + uv.y * up);\n}\n\nfloat opU( float d1, float d2 ) {\n  return min(d1, d2);\n}\n\n// Smooth minimum : https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\n/*\n\tReturn the closest distance to any surface from point p.\n */\nfloat map(vec3 p) {\n    //float s1 = sdSphere(p - vec3(0.0, 0.0 + sin(iTime * 2.0), -3.0), 1.0);\n    float s1 = sdSphere(p - vec3(0.0, -0.5 + texture(ic0, vec2(.1, 0.)).x * 2. + sin(iTime * 2.0)/ 5., -3.0), 0.7 + texture(ic0, vec2(.4, 0.)).x);\n    float s2 = sdPlane(p - vec3(0.0, -1.0, 0.0), vec4(0.0, 1.0, 0.0, 1.0));\n    return smin(s1, s2, 4.0);\n}\n\n\nfloat intersect(vec3 origin, vec3 rayDir) \n{\n    float t = 0.0;\n    float dt = 0.1;\n    \n    for (float i = 0.0; i < MAX_ITER; i += 1.0) {\n        t += dt;\n        \n        dt = map(t * rayDir + origin);\n        if (abs(t) < EPS) {\n            break;\n        }\n        \n        if (t > MAX_T) {\n            t = 0.0;\n            break;\n        }\n\n    }\n\treturn t;\n}\n\n\n\nvec3 plasma(vec2 uv) {\n    float s1 = .5 + .5 * min(texture(ic0, vec2(.1, 0.) ).x * 1.5, 1.);\n    float s2 = .5 + .5 * min(texture(ic0, vec2(.4, 0.) ).x * 1.5, 1.);\n    float s3 = .5 + .5 * min(texture(ic0, vec2(.6, 0.) ).x * 1.5, 1.);\n    float s4 = .5 + .5 * min(texture(ic0, vec2(.9, 0.) ).x * 1.5, 1.);\n    \n    vec2 p1 = vec2(0., 0.);\n    vec2 p2 = vec2(0., 1.);\n    vec2 p3 = vec2(1., 1.0);\n    vec2 p4 = vec2(1., 0.);\n       \n    float c1 = .5 + .5 * sin(distance(uv, p1) * 10. * s1 + t + s1 / 4.);\n    float c2 = .5 + .5 * sin(distance(uv, p2) * 10. * s2 + t + s2 / 4.);\n    float c3 = .5 + .5 * sin(distance(uv, p3) * 10. * s3 + t + s3 / 4.);\n    float c4 = .5 + .5 * sin(distance(uv, p4) * 25. * s4 + t * 3. + s4 / 4.);\n           \n\treturn vec3(c1 + c4 * .33, c2 + c4 * .33, c3 + c4 * .33);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraOrigin = vec3(0.0);\n    vec3 rayDir = simple_camera(uv);\n        \n    vec3 color = vec3((uv.y - 0.5) * (1.5 + sin(t * .2) * .5), 0.0, uv.y);\n    \n    float t = intersect(cameraOrigin, rayDir);\n    \n    if (t > 0.0) {\n        // calculate intersection point\n        vec3 hit = cameraOrigin + t * rayDir;        \n        \n        // get the color of the pixel\n        //color = texture(iChannel0, hit.xy).xyz;\n        color = plasma(hit.xy / 7.);\n        \n        // fade with distance\n        color *= vec3(6.0 / (t*t));\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}