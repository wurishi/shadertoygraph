{"ver":"0.1","info":{"id":"XfsfzS","date":"1725381500","viewed":135,"name":"BasicPathTrace","username":"ukeyshima","description":"Basic implementation of path tracing","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec4 tex = texture( iChannel0, uv );\n  vec3 color = tex.xyz / tex.w;\n  color = pow(color, vec3(0.45454545454));\n  fragColor = vec4( color, 1 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// COMMON DEFINITIONS\n#define EPS 0.001\n#define FLOAT_MAX float(0xffffffffu)\n#define MOD(A, B) (A - B * floor(A / B))\n#define MIN2(A) (min(A.x, A.y))\n#define MIN3(A) (min(A.x, min(A.y, A.z)))\n#define CROSS(X, Y) vec3(X.y*Y.z - X.z*Y.y, X.z*Y.x - X.x*Y.z, X.x*Y.y - X.y*Y.x)\n#define SATURATE(A) clamp(A, 0.0, 1.0)\n#define PI (3.14159265359)\n#define TAU (6.28318530718)\n#define OO vec2(0.0, 0.0)\n#define IO vec2(1.0, 0.0)\n#define OI vec2(0.0, 1.0)\n#define II vec2(1.0, 1.0)\n#define JO vec2(-1.0, 0.0)\n#define OJ vec2(0.0, -1.0)\n#define JJ vec2(-1.0, -1.0)\n#define IJ vec2(1.0, -1.0)\n#define JI vec2(-1.0, 1.0)\n#define OOO vec3(0.0, 0.0, 0.0)\n#define IOO vec3(1.0, 0.0, 0.0)\n#define OIO vec3(0.0, 1.0, 0.0)\n#define OOI vec3(0.0, 0.0, 1.0)\n#define IOI vec3(1.0, 0.0, 1.0)\n#define IIO vec3(1.0, 1.0, 0.0)\n#define OII vec3(0.0, 1.0, 1.0)\n#define III vec3(1.0, 1.0, 1.0)\n#define JOO vec3(-1.0, 0.0, 0.0)\n#define OJO vec3(0.0, -1.0, 0.0)\n#define OOJ vec3(0.0, 0.0, -1.0)\n#define JJO vec3(-1.0, -1.0, 0.0)\n#define JOJ vec3(-1.0, 0.0, -1.0)\n#define OJJ vec3(0.0, -1.0, -1.0)\n#define JJJ vec3(-1.0, -1.0, -1.0)\n#define IJJ vec3(1.0, -1.0, -1.0)\n#define JIJ vec3(-1.0, 1.0, -1.0)\n#define JJI vec3(-1.0, -1.0, 1.0)\n#define IIJ vec3(1.0, 1.0, -1.0)\n#define IJI vec3(1.0, -1.0, 1.0)\n#define JII vec3(-1.0, 1.0, 1.0)\n#define IOJ vec3(1.0, 0.0, -1.0)\n#define JIO vec3(-1.0, 1.0, 0.0)\n#define IJO vec3(1.0, -1.0, 0.0)\n//TRANSFORMATIONS\nmat3 TransformBasis(vec3 y, vec3 z)\n{\n    vec3 x = normalize(CROSS(y, z));\n    y = CROSS(z, x);\n    return mat3(x, y, z);\n}\n//DISTANCE FUNCTIONS\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//INFO\nstruct Surface {\n    int surfaceId;\n    int materialId;\n    float distance;\n};\nstruct Material {\n    vec3 baseColor;\n    float roughness;\n    float emission;\n};\nSurface minSurface(Surface a, Surface b)\n{\n    if (a.distance < b.distance)\n    {\n        return a;\n    }\n    return b;\n}\nSurface maxSurface(Surface a, Surface b)\n{\n    if (a.distance > b.distance)\n    {\n        return a;\n    }\n    return b;\n}\n//HASH FUNCTIONS\nuvec4 Pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    v ^= v >> 16u;\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    return v;\n}\nvec4 Pcg01(uvec4 v) { return vec4(Pcg4d(v)) / FLOAT_MAX; }\nvec4 Pcg01(vec4 v) { return Pcg01(floatBitsToUint(v)); }\n//BRDF FUNCTIONS\nfloat DistributionGGX(float NdotH, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NdotH * NdotH * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return nom / denom;\n}\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    float nom = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return nom / denom;\n}\nfloat GeometrySmithGGX(float NdotV, float NdotL, float roughness) {\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\nvec3 FresnelSchlick(float VdotH, vec3 F0) {\n    // return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n    return F0 + (1.0 - F0) * exp2((-5.55473 * VdotH - 6.98316) * VdotH);\n}\nvec3 MicrofacetGGXBRDF(vec3 N, vec3 V, vec3 L, vec3 baseColor, float roughness) {\n    vec3 H = normalize(L + V);\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n    vec3 F0 = baseColor;\n    vec3 F = FresnelSchlick(VdotH, F0);\n\tfloat D = DistributionGGX(NdotH, roughness);\n\tfloat G = GeometrySmithGGX(NdotV, NdotL, roughness);\n    vec3 nominator = D * G * F;\n\tfloat denominator = 4.0 * NdotV * NdotL;\n\treturn nominator / denominator;\n}\nvec3 LambertBRDF(vec3 baseColor) {\n    return baseColor / PI;\n}\n//SAMPLING FUNCTIONS\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness, vec3 N)\n{\n    float a = roughness * roughness;\n    float Phi = 2.0 * PI * Xi.x;\n    float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);\n    vec3 H;\n    H.x = SinTheta * cos(Phi);\n    H.y = SinTheta * sin(Phi);\n    H.z = CosTheta;\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 TangentX = normalize( cross( UpVector, N ) );\n    vec3 TangentY = cross( N, TangentX );\n    return TangentX * H.x + TangentY * H.y + N * H.z;\n}\nvec3 ImportanceSampleLambert(vec2 Xi, vec3 N)\n{\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt(1.0 - Xi.x);\n    float sinTheta = sqrt(Xi.y);\n    vec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    vec3 up = abs(N.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = cross(up, N);\n    vec3 tangentY = cross(N, tangentX);\n    return tangentX * h.x + tangentY * h.y + N * h.z;\n}\nvec3 SampleSphere(vec2 xi)\n{\n\tfloat a = xi.x * PI * 2.0;\n\tfloat z = xi.y * 2.0 - 1.0;\n    float r = sqrt(1.0 - z * z);\n\treturn vec3(r * cos(a), r * sin(a), z);\n}\nvec3 SampleHemiSphere(vec2 xi, vec3 dir)\n{\n\tvec3 v = SampleSphere(xi);\n\treturn dot(dir, v) < 0.0 ? -v : v;\n}\n//PDF\nfloat GGXPDF(vec3 N, vec3 V, vec3 L, float roughness) {\n    vec3 H = normalize(L + V);\n    float NdotH = max(dot(N, H), 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n    float D = DistributionGGX(NdotH, roughness);\n    return D * NdotH / (4.0 * VdotH);\n}\nfloat LambertPDF(vec3 N, vec3 L) {\n    return dot(N, L) / PI;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int bounceLimit = 10;\nconst int marchingStep = 128;\nconst float dof = 3.0;\nconst Material[7] materials = Material[](\n    Material(vec3(0.0, 0.0, 0.0), 0.0, 0.0),\n    Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0),\n    Material(vec3(0.0, 1.0, 0.0), 1.0, 0.0),\n    Material(vec3(1.0, 0.0, 0.0), 1.0, 0.0),\n    Material(vec3(1.0, 0.8, 0.6), 0.2, 10.0),\n    Material(vec3(1.0, 1.0, 1.0), 0.25, 0.0),\n    Material(vec3(1.0, 1.0, 1.0), 0.15, 0.0)\n);\n\nSurface Map(vec3 p)\n{\n    Surface ceil = Surface(0, 1, sdBox(p - vec3(0.0, 100.0, 0.0), vec3(100.0, 1.0, 100.0)));\n    Surface floor = Surface(1, 1, sdBox(p + vec3(0.0, 100.0, 0.0), vec3(100.0, 1.0, 100.0)));\n    Surface backWall = Surface(2, 1, sdBox(p - vec3(0.0, 0.0, 99.0), vec3(99.0, 99.0, 1.0)));\n    Surface rightWall = Surface(3, 2, sdBox(p - vec3(99, 0.0, 0.0), vec3(1.0, 99.0, 99.0)));\n    Surface leftWall = Surface(4, 3, sdBox(p + vec3(99, 0.0, 0.0), vec3(1.0, 99.0, 99.0)));\n    Surface light = Surface(5, 4, sdBox(p - vec3(0.0, 99.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    Surface box = Surface(6, 5, sdBox(p - vec3(-40.0, -40.0, 10.0), vec3(30.0, 60.0, 30.0)));\n    Surface ball = Surface(7, 6, sdSphere(p - vec3(30.0, -70.0, -70.0), 30.0));\n    Surface s = minSurface(ceil, floor);\n    s = minSurface(s, backWall);\n    s = minSurface(s, rightWall);\n    s = minSurface(s, leftWall);\n    s = minSurface(s, light);\n    s = minSurface(s, box);\n    s = minSurface(s, ball);\n    return s;\n}\n\nvec3 GetGrad(vec3 p, float d){\n    vec2 e = vec2(EPS, 0.0);\n    return vec3(\n        Map(p + e.xyy).distance - d,\n        Map(p + e.yxy).distance - d,\n        Map(p + e.yyx).distance - d\n    ) / EPS;\n}\n\nvec3 GetNormal(vec3 p, float d)\n{\n    return normalize(GetGrad(p, d));\n}\n\nbool RayMarching(vec3 ro, vec3 rd, int stepCount, out vec3 rp, out Surface s)\n{\n    rp = ro;\n    float rl = 0.0;\n    for (int i = 0; i < stepCount; i++)\n    {\n        s = Map(rp);\n        float d = s.distance;\n        if (abs(d) < EPS){ return true; }\n        rl += d;\n        rp = ro + rd * rl;\n    }\n    return false;\n}\n\nvec3 PathTrace(vec3 ro, vec3 rd, vec3 color)\n{\n    vec3 acc = OOO;\n    vec3 weight = III;\n    for (int bounce = 0; bounce <= bounceLimit; bounce++)\n    {\n        vec3 hitPos;\n        Surface s;\n        bool hit = RayMarching(ro, rd, marchingStep, hitPos, s);\n        if(!hit) {\n            acc += color * clamp(weight, 0.0, 1.0);\n            break;\n        }\n        Material m = materials[s.materialId];\n        float d = s.distance;\n        float e = m.emission;\n        float r = m.roughness;\n        vec3 c = m.baseColor;\n        vec3 n = GetNormal(hitPos, d);\n        vec3 v = -rd;\n        vec2 rand = Pcg01(vec4(hitPos, float(bounce) + iTime)).xy;\n        ro = hitPos + n * EPS * 2.0;\n        \n        vec3 brdf;\n        float pdf;\n        if(r > 0.99) {\n            rd = ImportanceSampleLambert(rand, n);\n            brdf = LambertBRDF(c);\n            pdf = LambertPDF(n, rd);\n        }else{\n            rd = reflect(rd, ImportanceSampleGGX(rand, r, n));\n            if ( dot( rd, n ) < 0.0 ) { break; }\n            brdf = MicrofacetGGXBRDF(n, v, rd, c, r);\n            pdf = GGXPDF(n, v, rd, r);\n        }\n        \n        acc += e * clamp(weight, 0.0, 1.0);\n        weight *= brdf / pdf * max(dot(rd, n), 0.0);\n        if (dot(weight, weight) < EPS) { break; }\n    }\n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n    vec3 p = vec3((fragCoord * 2.0 - r) / min(r.x, r.y), 0.0);\n    vec2 theta = texture( iChannel0, vec2(0.0, 0.0)).xy;\n    vec3 cameraPos = -450.0 * vec3(sin(theta.x), sin(theta.y), cos(theta.x));\n    vec3 cameraDir = normalize(-cameraPos);\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraRight = CROSS(cameraUp, cameraDir);\n    cameraUp = CROSS(cameraDir, cameraRight);\n    vec3 ray = normalize(cameraRight * p.x + cameraUp * p.y + cameraDir * dof);\n    vec3 ro = cameraPos;\n    vec3 rd = ray;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    col = PathTrace(ro, rd, col);\n    col = SATURATE(col);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 r = iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \n    if(fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor = texture( iChannel1, uv );\n        if(iMouse.z > 0.5) {\n            vec2 mouseP = (iMouse.xy * 2.0 - r) / max(r.x, r.y);\n            vec2 theta =  mouseP * PI / 3.0;\n            fragColor = vec4(theta, 0.0, 0.0);\n        }\n    } else {\n        fragColor = texture( iChannel0, uv );\n        if ( iFrame > 1 && iMouse.z < 0.5 ) {\n            fragColor += texture( iChannel1, uv );\n        }\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}