{"ver":"0.1","info":{"id":"wtlcWr","date":"1591881091","viewed":352,"name":"Fluid Buffer 2D","username":"spalmer","description":"deconstructing a toy by wyatt, even further.  Made mouse control middle jet location instead of camera.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["fluid","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of https://shadertoy.com/view/WtscDn\n// deconstructing Volumetric Fluid by wyatt at https://shadertoy.com/view/ws2fDc\n\nSampler0\n    \nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n    Q = T0(u);\n    Q = sqrt(Q); // to quasi-sRGB gamut for display\n}\n\n/*    \n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\tvec3 mi = .5*R3D; // middle of 3d buffer volume\n\tvec3 p = vec3(0,0,-R.y/N);\n\tvec3 d = normalize(vec3((u-.5*R)/R.y,1));\n\t// camera control\n\tvec2 ra = iMouse.z>0.\n\t\t? 6.2*vec2(iMouse.x/R.x, iMouse.y/R.y)\n\t\t: vec2(.2*iTime, .05*iTime);\n\tp.zx *= rot(ra.x);\n\td.zx *= rot(ra.x);\n\tp.yz *= rot(ra.y);\n\td.yz *= rot(ra.y);\n\tQ = vec4(0);\n\tfor (int i = 0; i < 128; ++i) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m < .01) { \t\n            vec4 a = 25.*S0(p+mi);\n            float aa = length(a);\n            Q += 6e-3*(1.-exp(-aa))*abs(a);\n            p += d*(.1+exp(-.1*aa*aa));\n           //p = mod(p+mi,R3D)-mi;\n        } else p += d*m;        \n \t}\n\tQ = atan(Q)*.8; // wyatt's crazy tone map operator\n*/\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// cannot access uniforms or samplers from Common tab btw\n#define R iResolution.xy\n// 2D resolution\n#define R2D vec2(R)\n// does nothing in 2D\n#define d2(U) (U)\n\n#define T0(U) texture(iChannel0, d2(U)/R)\n#define T1(U) texture(iChannel1, d2(U)/R)\n\n#define A(U) T0(mod(U,R2D))\n// just defines a sampler function to access the channel easily\n#define Sampler0 vec4 S0(vec2 U) { return T0(U); }\n#define Sampler1 vec4 S1(vec2 U) { return T1(U); }\n\n#define Neighborhood vec4 \\\n  n = A(U+vec2(0,1)) \\\n, s = A(U-vec2(0,1)) \\\n, e = A(U+vec2(1,0)) \\\n, w = A(U-vec2(1,0));\n\n//#define Init  if (iFrame < 1)\n\n// I prefer not to wrap the entry points, it causes too much confusion\n//#define Main void mainImage(out vec4 Q, vec2 u)\n\n/*\n// TODO refactor F to common\n// the uniforms access in Common is fighting me every step of the way\nvoid F(sampler2D ch, vec2 r\n       , vec2 U, vec2 u, vec4 Q\n       , inout vec2 f, inout float m, inout float w, inout float n) \n{\n    // Advect\n    //vec4 a = S0(U+u-A(U+u).xy);\n    vec4 a = texture(ch, d2(U));\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xy);\n    // number of neighbors sampled\n    ++n;\n}\n*/\n\n//#define N 10. // was depth?\n// converts 2D buffer coordinate u to 2D coord\n//#define d2(u) vec2(mod(u,R/N))\n// converts 2D buffer coordinate from Main arg u to 2D coord U\n// it's silly to wrap this with a macro!\n//#define _2D  vec2 U = d2(u)\n//#define B(U) T1(mod(U,R2D))\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Sampler0\n    \nvoid F(vec2 U, vec2 u, vec4 Q, inout vec2 f, inout float m, inout float w, inout float n)\n{\n    // Advect\n    vec4 a = S0(U+u-A(U+u).xy);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xy);\n    // number of neighbors sampled\n    ++n;\n}\n\nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec2 U = d2(u);\n    Q = S0(U-A(U).xy);\n    vec2 f = vec2(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n\n    F(U,vec2(0, 1),Q,f,m,w,n);\n    F(U,vec2(0,-1),Q,f,m,w,n);\n    F(U,vec2( 1,0),Q,f,m,w,n);\n    F(U,vec2(-1,0),Q,f,m,w,n);\n\n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xy -= f;\n}\n\n// output channels seem to be velocity in xyz and pressure in w\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"Sampler0\n    \nvoid F(vec2 U, vec2 u, vec4 Q, inout vec2 f, inout float m, inout float w, inout float n)\n{\n    // Advect\n    vec4 a = S0(U+u-A(U+u).xy);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xy);\n    // number of neighbors sampled\n    ++n;\n}\n\nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec2 U = d2(u);\n    Q = S0(U-A(U).xy);\n    vec2 f = vec2(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n\n    F(U,vec2(0, 1),Q,f,m,w,n);\n    F(U,vec2(0,-1),Q,f,m,w,n);\n    F(U,vec2( 1,0),Q,f,m,w,n);\n    F(U,vec2(-1,0),Q,f,m,w,n);\n\n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xy -= f;\n}\n\n// output channels seem to be velocity in xyz and pressure in w\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"Sampler0\n    \nvoid F(vec2 U, vec2 u, vec4 Q, inout vec2 f, inout float m, inout float w, inout float n)\n{\n    // Advect\n    vec4 a = S0(U+u-A(U+u).xy);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xy);\n    // number of neighbors sampled\n    ++n;\n}\n\nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec2 U = d2(u);\n    Q = S0(U-A(U).xy);\n    vec2 f = vec2(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n\n\tF(U,vec2(0, 1),Q,f,m,w,n);\n\tF(U,vec2(0,-1),Q,f,m,w,n);\n\tF(U,vec2( 1,0),Q,f,m,w,n);\n\tF(U,vec2(-1,0),Q,f,m,w,n);\n\n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xy -= f;\n    vec2 M = iMouse.z > 0. ? d2(iMouse.xy) : .5*R2D;\n    if (length(U-M) < 4.) {\n\t\tQ.xy = vec2(0,-.2)*(.5+0.5*sin(.5*iTime));\n\t}\n    if (length(U-vec2(0.51,.1)*R2D) < 4.) {\n\t\tQ.xy = vec2(0,.4)*(.5+.8*sin(.2*iTime));\n\t}\n    if (length(U-vec2(0.5,.9)*R2D) < 4.) {\n\t\tQ.xy = vec2(0,-.4)*(.5+.8*sin(.4*iTime));\n\t}\n\tif (U.x<1.||U.y<1.||R2D.x-U.x<1.||R2D.y-U.y<1.) Q.xy *= 0.;\n}\n\n// output channels seem to be velocity in xyz and pressure in w\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"Sampler0\nSampler1\n    \nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec2 U = d2(u);\n    U -= S1(U).xy;\n    U -= S1(U).xy;\n    U -= S1(U).xy;\n    // look backward 3 iterations, tracing velocity field in reverse   \n    Q = S0(U); // advect color\n    // HEY BTW FIXME\n    // it's silly to have to model the jets in two different buffers\n    // this should be centralized to common somehow\n    // jets reverse direction btw\n    vec2 M = iMouse.z > 0. ? d2(iMouse.xy) : .5*R2D;\n    if (length(U-M) < 3.) {\n\t    Q = .5+.5*sin(.1*iTime*vec4(1,2,3,4));\n        //Q = vec4(.5, 0., 0., Q.w); //\n    }\n    if (length(U-vec2(0.51,.1)*R2D) < 3.) {\n    \tQ = .5+.5*sin(.1*iTime+vec4(4,3,2,1));\n    }\n    if (length(U-vec2(0.5,.9)*R2D) < 3.) {\n    \tQ = .5+.5*sin(.1*iTime-vec4(4,3,2,1));\n    }\n}\n\n// not 100% sure but think this buffer\n// represents the colors of the fluid\n// I believe I could ignore Buffer D \n// and just render the densities in Buffer C directly\n// but then it wouldn't have different colors of fluid!\n// right now I have it hacked to one red jet anyway.\n\n// output channels seem to be color in rgb and density/opacity in alpha\n\n","name":"Buffer D","description":"","type":"buffer"}]}