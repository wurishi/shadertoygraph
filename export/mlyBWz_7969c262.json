{"ver":"0.1","info":{"id":"mlyBWz","date":"1701975430","viewed":23,"name":"Dynamic Julia Sets","username":"noahsk","description":"A simple iterative shader of the Julia sets of the Mandelbrot set.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mandelbrot","shading","shader","iterate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Let's make a shader which pictures the julia sets \n    // of a certain path on the mandelbrot set!\n    \n    // First, let's get useable coordinates!\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = uv*4.0;\n    uv.y = uv.y * (iResolution.y/iResolution.x);\n    // All the code above is transition from numbered coordinates\n    // to simply a gradient from -8 to 8 on each axis! (with adjustment \n    // for aspect ratio). We will treat these like coordinates.\n\n    \n    // Now, we want to actually calculate the julia sets\n    \n    // This controls how detailed our fractal is\n    float iter = 30.0;\n    \n    // This controls how quickly the fractal changes over time\n    float speed = 1.0;\n    \n    // This is the vector which our mandelbrot sets will revolve around\n    // The x of this vector is the real component and the y of this vector\n    // is the imaginary component.\n    vec2 c = vec2(-0.5783, -0.5783);\n    \n    // We established earlier a map from each pixel to this graph of\n    // -8 to 8, now they will be the inputs to our function.\n    vec2 z = uv;\n    \n    // We allow our c to change with time (here I am using sinusoids to\n    // trace out a circle).\n    c.x = c.x + pow(cos(speed * iTime),1.0);\n    c.y = c.y + pow(sin(speed * iTime),1.0);\n    \n    // We now perform the Z_n^2 + c operation iter times and find whether\n    // or not each pixel's associated value on the graph is part of its julia set\n    // or if it diverges (everything with magnitude > 4 diverges so\n    // we will break when that occurs.)\n    float numiter = 0.0;\n    for (float i = 0.0; i < iter; i++) {\n     z = vec2(z.x * z.x - z.y * z.y, z.y * z.x * 2.0);\n     z = z + c;\n     numiter++;\n     \n         if (length(z) > 4.0) {\n           break;\n         } \n     \n     }\n     \n    // The above function gives us the result of numiter, measuring how many\n    // iterations it took for the input to reach a magnitude of 4. For any\n    // points within the set (magnitude < 4), we will handle those at the end.\n     \n     \n    // We could just color in the points within the set, but it is more interesting\n    // to also color the points which diverge differently based on how quickly they\n    // diverge, which is directly correspondent to numiter.\n    \n    // The following code turns numiter into a value between 0 and 1 and then\n    // matches that to a specific color.\n    \n    float t = numiter/iter;\n    vec3 r = vec3(length(z)/iter);\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 e = vec3(1.0);\n    vec3 d = vec3(0.2,0.3,0.3);\n    vec3 color = vec3(a + b * cos( 2.0 * 3.13159 * (e*t+d)));\n    \n    // This is an unnecessary (but in my opinion) cool effect, \n    // try messing with it! (if it confuses you, remove it!)\n    float edgenum = 20.0; float edgedetail = 0.1;\n    for (float k = 0.0; k < edgenum; k++) {\n      if (length(z) < 4.0+k*edgedetail) {\n       color = color*0.985;\n      }\n    }\n    \n    // Now, this final bit just shades the points within the set a bit darker than\n    // they would be otherwise. This is simply to promote contrast and make it\n    // easier to view the set itself.\n    \n    if (length(z) < 4.0) {\n     color = color*0.2 + vec3(0.0,0.0,0.0);\n    } \n    \n    // Now, all we do is return the colour we have assigned!\n    fragColor = vec4(color, 1.0); }","name":"Image","description":"","type":"image"}]}