{"ver":"0.1","info":{"id":"M3lfzf","date":"1728737833","viewed":86,"name":"Fractal Soundscape Visualizer ","username":"nilberlin","description":"Fractal Soundscape Visualizer | Hypnotische Fraktal-Musikvisualisierung reagiert auf Beats und erzeugt fesselnde, sich entwickelnde Muster. | Hypnotic fractal music visualizer responds to beats, creating captivating, evolving patterns.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["fractalvisualizermusicreactiveaudiovisualsgenerativeartshaderartelectronicmusicvisualfxcreativecodingdigitalart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Erweiterter Audio-reaktiver Julia-Fraktal-Shader mit dynamischen Flares und Farbwechseln\n#define MAX_ITER 200\n#define PI 3.14159265359\n\nfloat julia(vec2 z, vec2 c) {\n    float iterations = 0.0;\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if(length(z) > 4.0) {\n            iterations = float(i);\n            break;\n        }\n    }\n    return iterations / float(MAX_ITER);\n}\n\n// Funktion für dynamische Flares (Lichtstrahlen)\nfloat flare(vec2 uv, float time, float intensity) {\n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    float rays = sin(angle * 10.0 + time * 10.0) * 0.5 + 0.5;\n    float flare = pow(1.0 - radius, 2.0) * rays * intensity;\n    return flare;\n}\n\n// Funktion für chromatische Aberration\nvec3 chromaticAberration(vec2 uv, vec2 fragCoord) {\n    float chroma = 0.005;\n    vec3 chromaColor;\n    chromaColor.r = texture(iChannel0, fragCoord / iResolution.xy + vec2(chroma, 0.0)).r;\n    chromaColor.g = texture(iChannel0, fragCoord / iResolution.xy).g;\n    chromaColor.b = texture(iChannel0, fragCoord / iResolution.xy - vec2(chroma, 0.0)).b;\n    return chromaColor;\n}\n\n// Funktion für Vignettierung\nfloat vignette(vec2 uv) {\n    return smoothstep(1.0, 0.5, length(uv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalisierte Pixelkoordinaten (von 0 bis 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    float time = iTime;\n\n    // Zeit und Audio-Reaktivität\n    float t = time * 0.5;  // Erhöhte Geschwindigkeit\n    float bass = texture(iChannel0, vec2(0.05, 0.0)).x;\n    float mid = texture(iChannel0, vec2(0.5, 0.0)).x;\n    float treble = texture(iChannel0, vec2(0.95, 0.0)).x;\n\n    // Dynamische Rotation mit erhöhter Geschwindigkeit\n    float angle = t * 0.1 + bass * 2.0;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    p *= rot;\n\n    // Audio-reaktive Parameter mit höherer Dynamik\n    vec2 c = vec2(sin(t * 1.0) * 0.5 + bass * 0.5, cos(t * 1.2) * 0.5 + treble * 0.5);\n    float zoom = 1.2 + sin(t * 0.5) * 0.8 + mid * 2.0;\n\n    // Fraktal berechnen\n    float f = julia(p * zoom, c);\n\n    // Dynamischer Farbwechsel\n    vec3 color1 = vec3(sin(t * 0.7), cos(t * 0.9), sin(t * 1.1));\n    vec3 color2 = vec3(cos(t * 0.5), sin(t * 0.8), cos(t * 1.2));\n    vec3 color3 = vec3(sin(t * 1.3), cos(t * 0.6), sin(t * 0.4));\n    vec3 color4 = vec3(cos(t * 1.1), sin(t * 0.7), cos(t * 0.9));\n\n    // Sättigung der Farben erhöhen\n    color1 = pow(color1, vec3(2.0));\n    color2 = pow(color2, vec3(2.0));\n    color3 = pow(color3, vec3(2.0));\n    color4 = pow(color4, vec3(2.0));\n\n    vec3 col = mix(color1, color2, smoothstep(0.0, 0.33, f));\n    col = mix(col, color3, smoothstep(0.33, 0.66, f));\n    col = mix(col, color4, smoothstep(0.66, 1.0, f));\n\n    // Flare-Effekt mit erhöhter Dynamik hinzufügen\n    float flareIntensity = flare(p, time, bass + treble) * 0.7;\n    col += vec3(1.0, 0.8, 0.6) * flareIntensity;\n\n    // Audio-reaktive Überlagerungen mit höherer Intensität\n    float d = length(p);\n    col += vec3(0.8, 0.2, 1.0) * smoothstep(0.5, -0.5, abs(d - bass * 1.5));\n    col += vec3(0.2, 1.0, 0.8) * smoothstep(0.4, -0.6, abs(d - mid * 0.8));\n    col += vec3(1.0, 1.0, 0.2) * smoothstep(0.3, -0.7, abs(d - treble * 0.6));\n\n    // Glüheffekt mit erhöhter Pulsation\n    float glow = pow(f, 3.0) * (1.0 + sin(t * 5.0)) * 0.7;\n    col += vec3(1.0, 0.9, 0.7) * glow;\n\n    // Vignette-Effekt\n    col *= vignette(p);\n\n    // Chromatische Aberration\n    vec3 chromaColor = chromaticAberration(p, fragCoord);\n    col = mix(col, chromaColor, 0.3);\n\n    // Gamma-Korrektur\n    col = pow(col, vec3(0.8));\n\n    // Ausgabe\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}