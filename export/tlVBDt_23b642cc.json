{"ver":"0.1","info":{"id":"tlVBDt","date":"1615680231","viewed":203,"name":"dungeon stroll (vlllll)","username":"valalalalala","description":"Three brave adventures walk into a dungeon... This was fun and came together pretty quickly. \n\nTorches and stuff would be nice, but stopping here for now. ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["animation","character","walking"],"hasliked":0,"parentid":"3lGyzz","parentname":"simple marcher (vlllll)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"dungeon stroll\"                                          // //\n     //                                                            //  //\n    //  Three brave adventures walk into a dungeon... This was    //   //\n   //  fun and came together pretty quickly. Torches and stuff   //    //\n  //  would be nice, but stopping here for now.                 //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// scene settings\n\nconst vec3 BLUE = vec3( .7, .7, .9 );\nconst vec3 YLLO = vec3( .9, .9, .8 );\n\nconst vec3 COLOR_AUBERGINE = vec3( .8, .1, .8 );\nconst vec3 COLOR_SALLOW = vec3( .8, .8, .5 );\nconst vec3 COLOR_DARK_BROWN = vec3( .8, .6, .2 );\nconst vec3 COLOR_STEEL = vec3( 1.1 );\nconst vec3 COLOR_TOMATO = vec3( 1.8, .6, .6 );\nconst vec3 COLOR_GOLD = vec3( 1., .8, .1 );\nconst vec3 COLOR_NY_PINK = vec3( 1., .6, .6 );\nconst vec3 COLOR_DEEP_MOSS_GREEN = vec3( .4, .7, .4 );\nconst vec3 COLOR_HUNTER_BROWN = vec3( .6, .3, .1 );\nconst vec3 COLOR_DUNGEON_GRAY = vec3( .35, .35, .4 );\n\n#define WALK\n#define ADVENTURE\n\n////////////////////////////////////////////////////////////////\n// scene definition\n\nvec2 minnow( vec2 current, float candidate, float value ) {\n    return current.x < candidate ? current : vec2( candidate, value );\n}\n\nvec2 minnow( vec2 current, vec2 candidate ) {\n    return current.x < candidate.x ? current : candidate;\n}\n\nvec2 wizard( float time, vec3 p ) {\n    if( dot( p, p ) > .92 ) {\n        return vec2( sdCappedCylinder( p - vec3(.0,.43,.0), .28, .48 ), 30. );\n    }\n\n    #ifdef WALK\n        p.y += time * .015;\n        float itime = ( 1. - time );\n    #endif\n\n    vec2 d = vec2( 1e33, -1. );\n    vec3 og = p;\n    vec3 q = p;\n    \n    /////////////////////\n    // body\n    \n    #ifdef WALK\n        q.yz *= rotate2d(-.02 * time );\n    #endif\n    \n    //d = minnow( d, fCone( q, .14, .5 ) - .008, 10. );\n    d = minnow( d, fCone( q, .1, .48 ) - .02, 10. );\n    \n    /////////////////////\n    // head\n    \n    #ifdef WALK\n        float headBop = .003;\n        q.xy *= rotate2d( time * 2. * headBop - headBop );\n    #endif\n    \n    d = minnow( d, fSphere( q - vec3( .0, .6, .0 ), .08 ), 11. );\n    \n    /////////////////////\n    // hat\n    \n    vec3 hatAt = -vec3(.0,.7,.0);\n    q += hatAt;\n    #ifdef WALK\n        vec2 hatOff = vec2( -.13, .01 );\n        q.yz -= hatOff;\n        q.yz *= rotate2d( .07 * time  );\n        q.yz += hatOff;\n    #endif\n    d = minnow( d, fCone( q, .06, .2 ) - .006, 10. );\n\n    /////////////////////\n    // staff\n    vec3 staffAt = -vec3( -.2, .3, .08 );\n    q = p + staffAt;\n    #ifdef WALK\n        q.y -= .15;\n        q.yz *= rotate2d( .07 * time - .035  );   \n        q.y += .15;\n    #endif\n    d = minnow( d, sdCappedCylinder( q, .013, .3 ), 12. );\n    \n    /////////////////////\n\n    return d;\n}\n\nvec2 tank( float time, vec3 p ) {\n    // bounding\n    if ( dot( p, p ) > .7 ) {\n        return vec2( sdCappedCylinder( p - vec3(.0,.28,.0), .44, .38 ), 30. );\n    }\n    \n    #ifdef WALK\n        p.y += time * .020;\n        float itime = ( 1. - time );\n        float angleF = 1.4;\n        float rightAngle = angleF * .22 * time  - .07;\n        float leftAngle  = angleF * .22 * itime - .07;\n    #endif\n\n    vec3 og = p;\n    vec3 q = p;\n    vec2 d = vec2( 1e33, -1. );\n   \n    /////////////////////\n    // head\n    \n    q = p;\n    #ifdef WALK\n        float headPivot = .02;\n        q.xz *= rotate2d( time * headPivot * 2. - headPivot );\n    #endif\n    float helmet = sdCappedCylinder( q - vec3( +.0, .6, -.05 ), .1, .1 );\n    helmet = max( helmet, -sdQuadBlob( q - vec3( +.0, .58, .0 ), .05 ) );\n    d = minnow( d, helmet, 20. );\n    \n    d = minnow( d, sdCappedCylinder( q - vec3( +.0, .6, -.05 ), .09, .069 ), 21. );\n    \n    /////////////////////\n    // body\n    \n    d = minnow( d, sdCappedCylinder( p - vec3( -.0, .32, .0 ), .2, .16 ), 20. ); \n    \n    #ifdef WALK\n        // note: this will change the rotation for the limbs too...\n        float torsoPivot = -.07;\n        p.xz *= rotate2d( time * torsoPivot * 2. - torsoPivot );\n    #endif\n    \n    /////////////////////\n    // right leg\n    \n    vec3 rightLegAt = -vec3( -.1, .08, -.05 );\n    rightLegAt = -vec3( -.1, .08, -.03 );\n    #ifdef WALK\n        float legAngleDampening = .8;\n        q = p + rightLegAt;\n        q.y += rightLegAt.y;\n        q.yz *= rotate2d( rightAngle * legAngleDampening );\n        q.y -= rightLegAt.y;\n        d = minnow( d, sdCappedCylinder( q, .07, .08 ), 20. );\n    #else    \n        d = minnow( d, sdCappedCylinder( p + rightLegAt, .07, .08 ), 20. ); // right leg\n    #endif\n\n    /////////////////////\n    // left leg\n    \n    vec3 leftLegAt = rightLegAt;\n    leftLegAt.x = -leftLegAt.x;\n    #ifdef WALK\n        q = p + leftLegAt;\n        q.y += leftLegAt.y;\n        q.yz *= rotate2d( leftAngle * legAngleDampening );\n        q.y -= leftLegAt.y;\n        d = minnow( d, sdCappedCylinder( q, .07, .08 ), 20. );\n    #else \n        d = minnow( d, sdCappedCylinder( p + leftLegAt, .07, .08 ), 20. ); // left leg\n    #endif\n   \n    /////////////////////\n    // right arm\n    \n    vec3 rightArmAt = -vec3( -.23, .36, -.05 );\n    #ifdef WALK\n        q = p + rightArmAt;\n        q.y -= .1;\n        q.yz *= rotate2d( leftAngle );\n        q.y += .1;\n        d = minnow( d, sdCappedCylinder( q, .07, .14 ), 20. ); \n    #else    \n        d = minnow( d, sdCappedCylinder( p + rightArmAt, .07, .14 ), 20. ); \n    #endif\n\n    /////////////////////\n    // left arm\n    \n    vec3 leftArmAt = rightArmAt;\n    leftArmAt.x = -leftArmAt.x;\n    #ifdef WALK\n        q = p + leftArmAt;\n        q.y -= .1;\n        q.yz *= rotate2d( rightAngle );\n        q.y += .1;\n        d = minnow( d, sdCappedCylinder( q, .07, .14 ), 20. ); \n    #else      \n        d = minnow( d, sdCappedCylinder( p + leftArmAt, .07, .14 ), 20. ); \n    #endif\n\n    #ifdef WALK\n        vec3 shieldAt = -vec3( -.05, -.1, -.05 );\n        vec3 shieldAt2 = shieldAt;\n        shieldAt2.x += .1;\n\n        float shield = fSphere( q + shieldAt, .2 ); \n        shield = max( shield, -sdBox( q + shieldAt2, .23 ) );\n        d = minnow( d, shield, 22. );\n    #else   \n        float shield = fSphere( p - vec3( .18, .24, -.05 ), .2 ); \n        shield = max( shield, -sdBox( p - vec3( .08, .24, -.05 ), .23 ) );\n        d = minnow( d, shield, 22. );\n    #endif\n\n    /////////////////////\n    \n    return d;\n}\n\nvec2 archer( float time, vec3 p ) {\n    // bounding\n    if ( dot( p, p ) > .6 ) {\n        return vec2( sdCappedCylinder( p - vec3(.0,.35,.0), .2, .35 ), 30. );\n    }\n    \n    #ifdef WALK\n        p.y += time * .022;\n        float itime = ( 1. - time );\n        float angleF = .8;\n        float rightAngle = angleF * .22 * time  - .1;\n        float leftAngle  = angleF * .22 * itime - .1;\n    #endif\n\n    vec2 d = vec2( 1e33, -1. );\n    \n    /////////////////////\n    // legs\n    \n    vec3 q;\n    vec3 og = p;\n    \n    float legHeight = .23;\n    float legInAngle = .02;\n    float legGirth = .027;\n\n    vec3 rightLegAt = -vec3( -.03, -legHeight -.02, .0 );\n    #ifdef WALK\n        q = p - rightLegAt;\n        q.yz *= rotate2d( leftAngle );\n        q.xy *= rotate2d(-legInAngle);\n        q.y = -q.y;\n        q.x += rightLegAt.x * 2.;\n        float rightLeg = fCone( q, legGirth, legHeight ) - .005;  \n    #else\n        q = p;\n        q.y = -q.y;\n        q += rightLegAt;\n        float rightLeg = fCone( q, legGirth, legHeight ) - .005;  \n    #endif\n    d = minnow( d, rightLeg, 30. );\n    \n    /////////////////////\n    // left leg\n\n    vec3 leftLegAt = rightLegAt;\n    leftLegAt.x = -leftLegAt.x;\n    \n    #ifdef WALK\n        q = p - leftLegAt;\n        q.yz *= rotate2d( rightAngle );\n        q.xy *= rotate2d( legInAngle);\n\n        q.y = -q.y;\n        q.x += leftLegAt.x * 2.;\n        float leftLeg = fCone( q, legGirth, legHeight ) - .005;  \n    #else\n        q = p;\n        q.y = -q.y;\n        q += leftLegAt;\n        float leftLeg = fCone( q, legGirth, legHeight ) - .005;\n    #endif\n    d = minnow( d, leftLeg, 30. );\n\n    /////////////////////\n    // skirt\n    \n    float skirtWidth = .1;\n    vec3 skirtAt = -vec3( .0, .22, .01 );\n    q = p + skirtAt;\n    \n    #ifdef WALK\n        float sashay = -.01;\n        q.y += skirtAt.y;\n        q.xy *= rotate2d( time * sashay * 2. - sashay );\n        q.yz *= rotate2d( -.01 - time * .01);\n        q.y -= skirtAt.y;\n    #endif\n    \n    d = minnow( d, fCone( q , skirtWidth, .15 ) - .01, 31. ); \n    \n    /////////////////////\n    // head & cap\n    \n    vec3 hh = p;\n    #ifdef WALK\n        float headPivot = -.07;\n        hh.xz *= rotate2d( time * headPivot * 2. - headPivot );\n    #endif\n    \n    d = minnow( d, fSphere( hh - vec3( .0, .5, .0 ), .06 ), 30. ); // head\n    \n    vec3 capAt = -vec3( -.022, -.53, .0 );\n    q = hh - capAt;\n    q.xy *= rotate2d( .12 );\n    q.yz *= rotate2d( .05 );\n    d = minnow( d, fCone( q, .03, .1 ) - .02, 31. ); // cap\n    \n    /////////////////////\n    // top\n    \n    #ifdef WALK\n        // note: this will change the rotation for the arms and bow too...\n        float torsoPivot = .07;\n        p.xz *= rotate2d( time * torsoPivot * 2. - torsoPivot );\n    #endif\n        \n    q = p;\n    q.y /= .82;\n    d = minnow( d, fSphere( q - vec3( .0, .46, .015 ), .06 ), 31. ); // top\n    \n    /////////////////////\n    // arms\n    \n    float armLength = .16;\n    float armGirth = .01;\n    float armPad = .002;\n    \n    vec3 rightArmAt = -vec3( +.06, -.39, .0 );\n    float rightArmOutAngle = .1;\n    \n    q = p - rightArmAt;\n    q.xy *= rotate2d( rightArmOutAngle );\n    #ifdef WALK\n        q.yz *= rotate2d( rightAngle );\n    #endif\n    q.y = -q.y;\n    d = minnow( d, fCone( q, armGirth, armLength ) - armPad, 30. ); // right arm\n    \n    vec3 leftArmAt = rightArmAt; \n    float leftArmOutAngle = .15;\n    \n    leftArmAt.x *= -1.;\n    q = p - leftArmAt;\n    q.xy *= rotate2d( -leftArmOutAngle );\n    #ifdef WALK\n        q.yz *= rotate2d( leftAngle );\n    #endif\n    q.y = -q.y;\n    d = minnow( d, fCone( q, armGirth, armLength ) - armPad, 30. ); // left arm\n    \n    /////////////////////\n    // bow\n    // note: currently bow follows torso, not arm....\n    \n    vec3 bowAt = vec3( .03, .33, .0 );\n    \n#if 0\n    q = p - bowAt;\n    q.xy *= rotate2d( .04 );\n    q = q.xzy;\n    \n    float bow = sdCappedCylinder( q, .2, .01 );\n    bow = max( bow, -sdCappedCylinder( q + vec3( .02, .0, .0 ), .21, .02 ) );\n    d = minnow( d, bow, 32. ); // bow\n    \n    // string\n    d = minnow( d, vec2( sdVerticalCapsule( q.yzx - vec3( .0, -.18, .09 ), .36, .001 ), 33. ) );\n#else\n    q = q.yxz;\n    q.y += .01;\n    \n    float bowSize = .18;\n    float bow = sdCappedCylinder( q, bowSize, .01 );\n    bow = max( bow, -sdCappedCylinder( q + vec3( .02, .0, .0 ), bowSize + .01, .02 ) );\n    d = minnow( d, bow, 32. ); // bow\n    \n    // string\n    d = minnow( d, vec2( sdVerticalCapsule( q.yzx - vec3( .0, -.16, .08 ), .32, .001 ), 33. ) );\n#endif    \n    \n    return d;\n}\n\n\nfloat tunnel( float f, vec2 q, vec2 size  ) {\n    q.xy = abs( q.xy ) - size  * f ;\n    max( q.x, q.y );\n    return max( q.x, q.y );\n}\n\nvec2 dungeon( float time, vec3 p ) {\n    float d = 1e33;\n    \n    float far = 33.;\n    if( dot( p,p ) > far * far ) return vec2(far,40.);\n    \n    vec3 offset = vec3( .0, .0, mod( time, 66. ) );\n    \n    vec3 np = 1.7 * p + offset;\n    float f = 1. + stoner( np,  .2 );\n\n    vec3 q = p - vec3( .0, .5, .0 );\n    q.z += .2 * offset.z;\n\n    d = min( d, tunnel( f, q.xy, vec2( 1.15, .8 ) ) );\n    d = min( d, tunnel( f, q.zy, vec2( .8, .8 ) ) ); // bit wack...\n    d = -d;\n   \n    return vec2( d, 40. );\n}\n\nvec3 characterPosition( float time, float x ) {\n    time *= .11; // lateral movement is slower...\n    float o = .2;\n    x += o * cos( time );\n    return vec3( x, .0, o * sin( time ) );\n}\n\nvec2 characterShowcase( float time, vec3 p ) {\n    vec2 d = vec2( 1e33, -1. );\n        \n    float tWizard = MAP_11_01( cos( time * 10. + 0. ) );\n    float tTank   = MAP_11_01( cos( time *  5. + 1. ) );\n    float tArcher = MAP_11_01( cos( time * 14. + 2. ) );\n    \n    float xWizard = .6 + .2 * abs( cos( tWizard ) );\n\n    p.y += .5;\n    d = minnow( d, wizard( tWizard, p + characterPosition( tWizard, .6 ) ) );\n    d = minnow( d, tank(   tTank,   p - characterPosition( tTank, .0 ) ) );\n    d = minnow( d, archer( tArcher, p - characterPosition( tArcher, .6 ) ) );\n    p.y -= .5;\n  \n    return d;\n}\n\nvec2 map( vec3 p ) {\n    float time = iTime * 1.; // change to like .2 for slowmo;\n    vec2 d = characterShowcase( time, p );\n  \n    #ifdef ADVENTURE\n        d = minnow( d, dungeon( time, p ) );\n    #endif\n    return d;\n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 colorLookup( int code ) {\n    switch( code ) {\n        case 10: return COLOR_AUBERGINE;\n        case 11: return COLOR_SALLOW;\n        case 12: return COLOR_DARK_BROWN;\n        case 20: return COLOR_STEEL;\n        case 21: return COLOR_TOMATO;\n        case 22: return COLOR_GOLD;\n        case 30: return COLOR_NY_PINK;\n        case 31: return COLOR_DEEP_MOSS_GREEN;\n        case 32: return COLOR_HUNTER_BROWN;\n        case 40: return COLOR_DUNGEON_GRAY;\n    }\n    return vec3( 1. );\n}\n\nvec3 colorLookup( float code ) {\n    return colorLookup( int( code ) );\n}\n\nvec3 colorHit( vec3 eye, vec3 direction, vec2 d ) {\n    //return vec3( .0 ); // silhouette test \n    \n    vec3 p = eye + direction * d.x;\n    vec3 n = mapNormal( p, d.x );\n    \n    float light = max( .2, pow( MAP_11_01( n.y ), 2. ) );\n    vec3 color = colorLookup( int( d.y ) );\n        \n    if ( d.y == 20. || d.y == 22. ) {\n        vec2 other = march( p + n * MARCH.y * 3., n );\n        float hit = step( other.x, MARCH.z * .1 );\n        // reflective armor is fun!\n        color = mix( color, colorLookup( other.y ) * .7, .6 * hit );\n    } else {\n        vec3 toLight = vec3(.0,1.,.0 );\n        vec2 other = march( p + n * MARCH.y * 3., toLight );\n        float hit = step( other.x, MARCH.z );\n        if ( other.y != d.y ) {\n            // self collision is annoying...\n            light *= mix( 1., .7, hit );\n        }\n    }\n\n    return light * color;\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    uv = abs( uv );\n    return uv.x * COLOR_TOMATO + uv.y * COLOR_GOLD;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = boilerPlateMain( fragCoord, iMouse, iResolution, iTime );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////\n// cool hack for forward declarations https://www.shadertoy.com/view/WldSRj\n#ifndef HW_PERFORMANCE\n#define _SHADERTOY_TAB_COMMON\n#endif\n\n////////////////////////////////////////////////////////////////\n// camera settings\n\n#define CAMERA_DISTANCE 1.\n#define CAMERA_ZOOM     1.\n\n////////////////////////////////////////////////////////////////\n// try to hide the boilerplate a little\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\nconst float ZED = .0;\nconst float PI  = 3.141592653589793;\nconst float TAU = 6.283185307179586;\n\n///////////////////////////////////////////////////////////////////\n// ray marching\n\nconst vec3 MARCH = vec3( .0, .001, 88. );\n\n#define NX1 map( p - MARCH.yxx * d ).x\n#define NX2 map( p - MARCH.xyx * d ).x\n#define NX3 map( p - MARCH.xxy * d ).x\n\nvec2 map( vec3 p );\n#ifdef _SHADERTOY_TAB_COMMON\nvec2 map( vec3 p ) { return vec2( 33.44 ); }\n#endif\n\nvec2 march( vec3 eye, vec3 direction ) { \n    vec2 total = vec2(.0), now;\n    vec3 current = eye;\n    for( int i = 0 ; i < int( MARCH.z ) ; i++ ) {\n        total.x += ( now = map( current ) ).x;\n        total.y = now.y;\n        if ( abs( now.x ) < MARCH.y || total.x > MARCH.z ) break;\n        current += now.x * direction;\n    }\n    return total + MARCH.z * step( MARCH.z, total );\n}\n\nvec3 mapNormal( vec3 p, float d ) {\n    return normalize( map( p ).x - vec3( NX1, NX2, NX3 ) );\n}\n\n////////////////////////////////////////////////////////////////\n// miscellanous mess\n\n#define FROM_SCREEN(uv,R)  ( ( 2. * (uv) - (R).xy ) / (R).y )\n#define MAP_11_01(v)       ( (v) * .5 + .5 )\n\n#define MAX3(v)    max( (v).x, max( (v).y, (v).z ) )\n#define SUM3(v)    ( (v).x + (v).y + (v).z )\n\nvec2 trig( float a ) {\n    return vec2( cos( a  * TAU ), sin( a * TAU ) );\n}\n\n////////////////////////////////////////////////////////////////\n// rotation \n\nmat2 rotate2d( float angle ) {\n    vec2 t = trig( angle );\n    return mat2( t.x, -t.y, t.y, t.x ); //c-ssc\n}\n\n////////////////////////////////////////////////////////////////\n// signed distance fields\n// https://iquilezles.org/articles/distfunctions\n// https://www.shadertoy.com/view/Xds3zN\n// https://mercury.sexy/hg_sdf/\n\nfloat sdBox( vec3 p, float s ) {\n    return MAX3( (abs( p ) - vec3( s ) ) );\n}\n\nfloat sdQuadBlob( vec3 p, float s ) {\n    return dot( p, p ) / SUM3( abs( p ) ) - s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat fSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - height);\n    return d;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fConeOG(vec3 p, float radius, float height) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 tip = q - vec2(0, height);\n    vec2 mantleDir = normalize(vec2(height, radius));\n    float mantle = dot(tip, mantleDir);\n    float d = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n    \n    // distance to tip\n    if ((q.y > height) && (projected < .0)) {\n        d = max(d, length(tip));\n    }\n    \n    // distance to base ring\n    if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n        d = max(d, length(q - vec2(radius, .0)));\n    }\n    return d;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdVerticalCapsuleCone( vec3 p, float h, float r ) {\n  float q = clamp( p.y, 0.0, h );\n  p.y -= q;\n  r *= 1. - q / h; \n  float d = length( p ) - r;\n  d = max( d, -p.y ); \n  return d;\n}\n\nfloat fCone(vec3 p, float radius, float height) {\n    //return sdVerticalCapsuleCone( p, height, radius );\n    return fConeOG( p, radius, height );\n}\n\n////////////////////////////////////////////////////////////////\n// hash and noise\n\nvec2 hash2( in vec2 uv ) {\n    vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( vec2( q.x * q.y, q.y * q.z ) );\n}\n\nfloat hash( in vec2 uv ) {\n    vec2 q = hash2( uv );\n    return fract( q.x + q.y );\n}\n\nfloat hash( in vec3 p ) {\n    p = fract( p * vec3( 19.191, 53.733, 73.761 ) );\n    p += dot( p, p + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( ( p.x +  p.y ) * p.z );\n}\n\n// from iq's https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n////////////////////////////////////////////////////////////////\n// stone making: from my https://www.shadertoy.com/view/Wl3fzf\n\nvec4 fbm( vec3 p, vec3 weights, vec3 scales ) {\n    vec4 n = vec4(\n        noise( p * scales.x ),\n        noise( p * scales.y ),\n        noise( p * scales.z ),\n        .0\n    );\n    n.w = dot( n.xyz, weights );\n    return n;\n}\n\nfloat everyOtherRow( in float value, in float row ) {\n    return mod( value + .5 * step( 1., mod( row, 2. ) ), 1. );\n}\n\nfloat noisyInset( in vec2 p, in vec2 scale, in vec2 inOut ) {\n    vec2 s = scale * p;\n    vec2 f = fract( s );\n    vec2 i = s - f;\n    \n    float h = hash( i.xy );\n    \n    if ( h > .5 ) {\n        f.x = everyOtherRow( f.x, i.y );\n    }\n    \n    f.xy -= .5;\n    f.xy *= rotate2d( TAU * h );\n    f.xy += .5;\n        \n    vec2 q = min( f, 1. -f );\n    return smoothstep( inOut.x, inOut.y, min( q.x,q.y ) );\n}\n\nfloat stoner( vec3 p, float displacement ) {\n    vec4 theF = fbm( p + 0.33, vec3( .10, .03, .01 ), vec3( 3., 9., 23. ) );\n    float f = theF.w;\n    float a = f * .5 + .5;\n\n    vec2 brickSize = 3.5 * vec2( .6, .6 )  + f * 2.; \n    vec2 brickGap  = 1.2 * vec2( .1, .01 ) + f * .2;\n   \n    displacement *= .8 + f * 3.3;\n    return displacement * ( .2 * noisyInset( p.xy, brickSize, brickGap ) + a * 2.2 );\n}\n\n////////////////////////////////////////////////////////////////\n// basic camera controls\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec3 cameraEye( float viewDistance, vec4 mouse, vec3 resolution, float time ) {\n    vec2 ms = mouse.z > -.0 ? mouse.xy / resolution.xy : vec2( time *.1, .0 );\n    vec2 t = viewDistance * trig( ms.x );\n    #if 0\n    float ey = viewDistance * sin( (ms.y*2.-1.) * TAU * .5 );\n    #else\n    // better for grounded scenes...\n    float ey = viewDistance * sin( ms.y  * 1.01 + .1 ); \n    #endif\n    return vec3( t.x, ey, t.y );\n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 colorHit( vec3 eye, vec3 direction, vec2 d );\nvec3 colorMiss( in vec2 uv );\n#ifdef _SHADERTOY_TAB_COMMON\nvec3 colorHit( vec3 eye, vec3 direction, vec2 d ) { return vec3( 1. ); }\nvec3 colorMiss( in vec2 uv ) { return vec3( .0 ); }\n#endif\n\nvec4 boilerPlateMain( in vec2 fragCoord, vec4 mouse, vec3 resolution, float time ) {\n    vec2 uv = FROM_SCREEN( fragCoord, resolution );\n\n    ////////////////////////////////////////////////////////////////\n\n    vec3 eye = cameraEye( CAMERA_DISTANCE, mouse, resolution, time );\n    vec3 b = vec3( ZED );\n    vec3 ab = normalize( makeCamera( eye, b, .0 ) * vec3( uv, CAMERA_ZOOM ) );\n    \n    ////////////////////////////////////////////////////////////////\n\n    vec2 d = march( eye, ab );\n    float hit = step( d.x, MARCH.z * .95);\n\n    vec3 color = mix( colorMiss( uv ), colorHit( eye, ab, d ), hit );\n    //color = mix( color, vec3( .22, .11, .4 ), pow( d / MARCH.z, .33 ) * hit );\n\n    ////////////////////////////////////////////////////////////////\n    \n    return vec4( color, 1. );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}