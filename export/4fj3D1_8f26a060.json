{"ver":"0.1","info":{"id":"4fj3D1","date":"1704181714","viewed":34,"name":"R-Engine","username":"Absolute","description":"ver. 0.0.1:\nDevelopment Started.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","engine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct SphereOBJ\n{\n    vec3 center;\n    float radius;\n};\n\nfloat getRayCollision(vec3 p, SphereOBJ[2] spheres)\n{\n    float minDistance = 1e6; // Set a large initial value\n    for (int i = 0; i < spheres.length(); i++)\n    {\n        float distance = length(p - spheres[i].center) - spheres[i].radius;\n        minDistance = min(minDistance, distance);\n    }\n    return minDistance;\n}\n\nvoid screenToWorld(float screenX, float screenY, float screenWidth, float screenHeight, float cameraDistance, out vec3 worldPos)\n{\n    float ndcX = (2.0 * screenX / screenWidth) - 1.0;\n    float ndcY = 1.0 - (2.0 * screenY / screenHeight);\n    float perspectiveFactor = cameraDistance / sqrt(1.0 + ndcX * ndcX + ndcY * ndcY);\n\n    worldPos.x = ndcX * perspectiveFactor;\n    worldPos.y = ndcY * perspectiveFactor;\n    worldPos.z = -cameraDistance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 cam = vec3(0.0, 0.0, -2.0); // Fix the camera position\n    float fov = .2; // Doesn't support degrees!!!\n    float t = 0.0;\n    float ctr = 0.03;\n    float ratio = iResolution.x / iResolution.y;\n\n    SphereOBJ[2] spheres; // Define an array of spheres\n    spheres[0].radius = 1.0;\n\n    // Incorporate the mouse position into world space for the first sphere\n    screenToWorld(iMouse.x, iMouse.y, iResolution.x, iResolution.y, -cam.z, spheres[0].center);\n    spheres[0].center.z = 10.;\n    spheres[1].radius = 0.5;\n    spheres[1].center = vec3((sin(iTime) + 1.0) / 2.0 + 2.0, 0.0, 10.0);\n\n    vec3 rayDir = normalize(vec3(uv * fov, 1.0));\n\n    int ilitLimit = 100; // Iteration limit. Increases viewing distance in tight spaces at the cost of performance\n    for (int i = 0; i < ilitLimit; i++)\n    {\n        vec3 p = cam + rayDir * t;\n        float d = getRayCollision(p, spheres);\n        t += d;\n\n        if (d < 0.001 || t > 1000.0)\n            break;\n    }\n\n    fragColor = vec4(vec3(t * ctr), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}