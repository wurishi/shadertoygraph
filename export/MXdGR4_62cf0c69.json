{"ver":"0.1","info":{"id":"MXdGR4","date":"1716205104","viewed":367,"name":"Pudi","username":"panna_pudi","description":"🍮","likes":32,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","raymarching","sdf","model","pudding"],"hasliked":0,"parentid":"7lGGDt","parentname":"Pudi (wip)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pudi by Pudi\n// Email: krems.pudi@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define AA 2.0\n\nconst uint BODY = 1u;\nconst uint PLATE = 2u;\nconst uint ICING = 3u;\nconst uint TOPPING = 4u;\nconst uint STRAWBERRY = 5u;\n\nvoid mouth(in vec3 p, inout Hit res, uint type) {\n    switch (type) {\n    case 0u: {\n        vec3 pm = p + vec3(0., 0.38, 0.38);\n        // float tooth = sd_cone(pm * vec3(1., -1., 1.) + vec3(0.2, 0.15, 0.0) +\n        //                           vec3(-0.13, 0.0, 0.09),\n        //                       vec2(0.2, 0.1), 0.05);\n\n        vec4 umuer = sdBezier(pm + vec3(-0.02, -0.18, 0.089999974),\n                              vec3(0.01, -0.12, 0.55), vec3(0.06, 0.19, 0.),\n                              vec3(0.01, 0.01, -0.04));\n        umuer.x -= 0.06 + (1. - umuer.y) * 0.04;\n        umuer += noise(umuer.yzx * 100.) * 0.01 * pow(umuer.y, 3.);\n\n        float noiseier = noise(umuer.yzx * 900.) * 0.0003;\n\n        float exterrior =\n            sd_ellipsoid(pm, vec3(0.19000003, 0.24000011, 0.24000005));\n        exterrior = length(pm - vec3(0., -0.03, 0.)) - 0.24;\n        exterrior = smax(exterrior, -(p.y + 0.424), 0.01);\n\n        vec4 tongue = sdBezier(pm * vec3(.7, 1., 1.) + vec3(0.0, 0.0, -0.03),\n                               vec3(0.0, -0.1, 0.1), vec3(0.01, 0.20, -0.00),\n                               vec3(0.03, 0.04, -0.18));\n        tongue.x += -0.18 * (1. - tongue.y) - 0.033 * pow(tongue.y, 2.);\n        float bending_plane =\n            max((pm.y + 0.0438), (length(pm + vec3(0., 0., -0.2)) - .373));\n        tongue.x = max(tongue.x, -(p.y + 0.45));\n        // tongue.x = smin(tongue.x, bending_plane, 0.057);\n        // tongue += noiseier; // * pow(umuer.y, 3);\n\n        exterrior = smax(exterrior, -umuer.x, 0.08);\n        // tongue = max(tongue, exterrior);\n\n        res.t = max(res.t, -exterrior);\n        // res = smin(res, tongue.x, 0.03);\n        res = hit_min(res, Hit(tongue.x, pm, 7u));\n        // res = min(res, tooth); // fake\n        break;\n    };\n    case 1u: {\n        float wiggl = cos(iTime * 11. + PI) * 0.01;\n        vec3 pb = vec3(abs(p.x), p.yz);\n        pb += vec3(0., 0.23 + wiggl, 0.5);\n        pb = erot(pb, vec3(0.0, 0.0, 1.0), -PI / 4.);\n        pb = abs(pb) - vec3(0.1, 0.01, 0.0001);\n        float box = length(max(pb, vec3(0.)));\n        res = hit_min(res, Hit(box, pb, 6u));\n        break;\n    };\n    }\n}\n\nfloat topping(vec3 p) {\n    float ring = sd_torus(p + vec3(0., 0.34, 0.0), vec2(0.38, 0.1));\n\n    vec3 q = erot(p, normalize(vec3(-0.2, 1., 0.1)), 3.);\n    float arg = q.x * q.z * 100. + iTime;\n    float bumps = cos(q.y * 100.);\n    bumps = bumps * 0.5 + 0.5;\n    bumps *= 0.01;\n    ring += bumps;\n\n    p = erot(p, vec3(0., 1., 0.), p.y * 3.);\n    float rect = sd_rect(p.xz, vec2(0.5));\n\n    p = erot(p, vec3(0., 1., 0.), PI / 4.);\n    float neigh = sd_rect(p.xz, vec2(0.4));\n\n    float res = opSU(rect, neigh, 0.1);\n    res += p.y + 0.2;\n    res = -opSU(-res * 0.5, -sd_sphere(p, 0.5), 0.1);\n    res = smin(ring, res, 0.01);\n\n    return res;\n}\n\nfloat sd_strawberry(vec3 p) {\n    float d = 1e9;\n    d = length(p) - 1.;\n    d = sd_egg(p, 1., 0.2, 0.1);\n    d = blend(d, -(p.z - -0.37), 15.1);\n    d = blend(d, -sd_sphere(p - vec3(0., -0.11, -0.3), 0.5), 3.);\n\n    return d;\n}\n\nvec3 RO = vec3(0.), RD = vec3(0.);\nHit map(vec3 p) {\n    float t = iTime;\n    float wiggl = cos(t * 11. + PI) * 0.01;\n    float wiggle = cos((p.y + t) * 11.) * 0.01;\n    float wigglee = cos((p.y + t + 0.05) * 11.) * 0.02;\n\n    Hit res = default_hit();\n\n    // body base\n    float bod;\n    {\n        vec3 pa = vec3(0.0, -0.4, 0.0);\n        float body =\n            sd_capped_cone(p, pa, vec3(0., -0.01 + wigglee, 0.), 0.4, 0.3).z -\n            0.1;\n        body = body + wiggle * smoothstep(-0., -0.5, p.y) *\n                          smoothstep(0.2, .5, abs(p.x));\n        res = hit_min(res, Hit(body, p - pa, BODY));\n        bod = body;\n    }\n\n    vec2 bbox_bottom = ibox(RO - vec3(0., -0.4, 0.), RD, vec3(.8, 0.4, 0.8));\n    if (bbox_bottom.x > 0. || bbox_bottom.y > 0.) {\n\n        // plate\n        {\n            vec3 pa = p - vec3(0., -0.14, 0.);\n            vec2 q = vec2(length(pa.xz) - .2, -pa.y);\n            float plate = sd_joint2d(q, .8, 1.1, 0.02);\n            res = hit_min(res, Hit(plate, pa, PLATE));\n        }\n\n        // { mouth(p, res, uint(step(0.5, mod(t * 0.6, 1.)))); }\n        // { mouth(p, res, uint(step(0.5, 0))); }\n        // { mouth(p, res, 1); }\n    }\n\n    vec2 bbox_up = ibox(RO - vec3(0., 0.2, 0.), RD, vec3(.5, 0.4, 0.7));\n    if (bbox_up.x > 0. || bbox_up.y > 0.) {\n        float top = 1e9;\n        vec3 ptop;\n        {\n            vec3 pi = p + vec3(0., 0.12 + wiggl, 0.0);\n            float d = length(pi.xz);\n            float ang = atan(pi.z, pi.x) + PI / 2.;\n            float off = PI / 4. + 0.0, range = 0.1;\n            float amplifier = 1. - (smoothstep(-range, 0.5, ang + off) -\n                                    smoothstep(-0.4, range, ang - off));\n            vec3 dripping = sd_capped_cone(pi, vec3(0., 0., 0.0),\n                                           vec3(0.0, 0.14, 0.0), 0.4, 0.303) +\n                            0.011 * (1. - amplifier);\n            dripping.z += -0.113;\n            float waveFactor = (d > 1. ? 0. : .5);\n            float wave = sin(ang * 20. * waveFactor) * .067 +\n                         sin(ang * 40. * waveFactor + .7) * 0.038 +\n                         sin(ang * 25. * waveFactor + 0.6) * 0.027;\n            wave *= amplifier * 0.6 * smoothstep(-0.35, 0.6, length(p.xz));\n\n            vec3 icingWave = vec3(0, 0, pi.y - (wave + .03));\n            vec3 icing = carve(dripping, icingWave, .2);\n\n            top = min(top, icing.z);\n            ptop = pi;\n        }\n\n        {\n            vec3 po = p - vec3(0., 0.2 - wiggle, 0.);\n            vec4 ahoge =\n                sdBezier(po, vec3(0., -0.09, 0.), vec3(-0.03, 0.08, -0.01),\n                         vec3(-0.08, 0.01 - wigglee * 0.4, 0.));\n            ahoge.x -= 0.027 * ahoge.y + (1. - ahoge.y) * 0.008;\n            top = smin(top, ahoge.x + 0.003, 0.035);\n        }\n        res = hit_min(res, Hit(top, ptop, ICING));\n        {\n            vec3 po = p;\n            po.y += wiggl;\n            vec3 pt = vec3(abs(po.x), po.yz) + vec3(-0.20, -0.20, 0.14);\n            float scale = .22;\n            float topping = topping(pt / scale) * scale;\n            // res = smin(res, topping, 0.03);\n            res = hit_min(res, Hit(topping, pt, TOPPING));\n\n            pt -= vec3(0., -0.02, 0.01);\n            pt.yz *= rot(0.2);\n            pt.yx *= rot(-0.3);\n            float s = 0.09;\n            float strawberry = sd_strawberry(pt / s) * s;\n            res = hit_min(res, Hit(strawberry, pt, STRAWBERRY));\n        }\n    }\n\n    return res;\n}\n\nHit trace(in vec3 ro, in vec3 rd) {\n    vec2 bbox = ibox(ro, rd, vec3(.80, .8, 0.8));\n    if (bbox.x < 0. && bbox.y < 0.) {\n        return default_hit();\n    }\n    RO = ro, RD = rd;\n    float t = bbox.x;\n    for (int i = min(0, iFrame); i < 100; ++i) {\n        vec3 p = ro + rd * t;\n        Hit d = map(p);\n        if (abs(d.t) < 0.0001) {\n            return Hit(t, d.pos, d.id);\n        }\n        t += d.t;\n        if (t > bbox.y) {\n            break;\n        }\n    }\n    return default_hit();\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.0001);\n    return normalize(map(p).t - vec3(map(k[0]).t, map(k[1]).t, map(k[2]).t));\n}\n\nmat3 get_cam(vec3 eye, vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(vec3(0., 1., 0.), zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for (int i = min(1, iFrame + 1); i <= steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight * (d - map(p + n * d).t);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float w) {\n    float res = 1.0;\n    float t = mint;\n    for (int i = min(0, iFrame); i < 25 && t < maxt; i++) {\n        float h = map(ro + t * rd).t;\n        res = min(res, h / (w * t));\n        t += clamp(h, 0.005, 0.50);\n        if (res < -1.0 || t > maxt)\n            break;\n    }\n    res = max(res, -1.0);\n    return 0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res);\n}\n\n// https://www.shadertoy.com/view/dltGWl\nvec3 lighting(int type, vec3 nor, vec3 ldir, vec3 rd, vec3 lcol, vec3 albedo,\n              vec3 sscolor, vec3 ssradius, float roughness, float ior) {\n    float ndl = dot(nor, ldir);\n    float pndl = clamp(ndl, 0., 1.);\n    float nndl = clamp(-ndl, 0., 1.);\n\n    // subsurface scattering\n    vec3 sss = .2 * exp(-3. * (nndl + pndl) / (ssradius + .001));\n\n    vec3 h = normalize(ldir - rd); // half vector\n    float ndh = dot(nor, h);       // N⋅H\n\n    // ggx / Trowbridge and Reitz specular model approximation\n    float g = ndh * ndh * (roughness * roughness - 1.) + 1.;\n    float ggx = roughness * roughness / (PI * g * g);\n\n    float fre = 1. + dot(rd, nor);\n    float f0 = (ior - 1.) / (ior + 1.);\n    f0 = f0 * f0;\n    float refl = f0 + (1. - f0) * (1. - roughness) * (1. - roughness) *\n                          pow(fre, 5.); // reflectivity\n\n    pndl = mix(pndl * 0.5 + 0.5, max(pndl, 0.), 0.35);\n    return lcol *\n           (pndl * (albedo + refl * ggx) + albedo * sscolor * ssradius * sss);\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy - .5)\n            * vec2(iResolution.x / iResolution.y, 1.);\n   \n    vec3 ro = vec3(0., .4, -3);\n    vec3 lo = ro + vec3(0, 0, 1);\n\n    vec2 m = vec2(0., 0.);\n    if (iMouse.z > 0.) {\n        m = (iMouse.xy/iResolution.xy - .5)\n            * vec2(iResolution.x / iResolution.y, 1.);\n   \n        m.x += m.x * PI * 0.5;\n        m.y += m.y * PI * 0.7;\n    }\n    m.x = clamp(m.x, -PI / 3., PI / 3.);\n    m.y = clamp(m.y, -PI / 4., 0.2);\n    ro.xz *= rot(-m.x);\n    ro.zy *= rot(m.y);\n\n    float focal_dist = 1.6;\n    mat3 cmat = get_cam(ro, vec3(0., -0.15, 0.));\n    vec3 rd = normalize(cmat * vec3(uv, focal_dist));\n\n    vec3 col = vec3(.13);\n    vec4 emit = vec4(vec3(0.), 1e9);\n    Hit hit = trace(ro, rd);\n    vec3 nplane = vec3(0, 1., 0.);\n    float plane = -(dot(ro, nplane) + 0.53) / dot(rd, nplane);\n    if (plane < hit.t && plane > 0.) {\n        hit = Hit(plane, ro + rd * plane, 0u);\n    }\n    if (hit.t < 1e9) {\n        vec3 pos = ro + rd * hit.t;\n        vec3 nor = get_norm(pos);\n        float shad = dot(nor, normalize(vec3(1., 1., -1.)));\n        vec3 albedo = vec3(1.);\n\n        vec3 lpos = vec3(1.1, -0.12, -1.4);\n        lpos = vec3(2., 1., -2.6);\n        vec3 ldir = normalize(lpos - pos);\n\n        float rou = 1.3, ior = 1.5;\n        if (hit.id == BODY) {\n            albedo = vec3(1., 0.7, 0.1) * 1.5;\n            rou = 0.3;\n            ior = 1.3;\n\n            float wiggl = cos(iTime * 11. + PI) * 0.01;\n\n            vec2 p = hit.pos.xy;\n            vec2 pp =\n                vec2(abs(p.x), p.y - 0.2) - vec2(0.13, 0.08) + vec2(0., wiggl);\n            vec2 ppr = pp;\n            if (p.x > 0.) {\n                pp.x *= -1.;\n            }\n\n            float t = easeInBack(stepNoise(iTime * .5, 2.));\n            float shift = t * -0.022;\n\n            vec2 blp = vec2(-pp.y, pp.x) - vec2(0.07, -0.02) - vec2(shift, 0.);\n            blp *= rot(-0.4);\n            float blink = sd_joint2d(blp, 0.041, 0.4, 0.018);\n\n            vec3 brown = vec3(0.04, 0.015, 0.01) * 1.2;\n            float eye = sd_egg2d(pp + vec2(0., -shift), 0.05, 0.07);\n            eye = blend(eye, -(pp.y + 0.1), 29.);\n            eye = blend(eye, -blink, 80.);\n            col = mix(col, brown, step(eye, 0.));\n            emit.rgb = mix(emit.rgb, brown, AAstep(eye));\n            emit.w = min(emit.w, eye);\n\n            vec2 bp = ppr - vec2(0.03, 0.02) + vec2(0., -shift);\n            bp *= rot(1.1);\n            float brows = sd_line(bp, 0.023, 0.019);\n            brows = blend(brows, -(bp.x + 0.01), 250.);\n            brows = blend(brows, eye, -200.);\n            brows = blend(brows, -blink, 100.);\n            emit.rgb = mix(emit.rgb, brown, AAstep(brows));\n            emit.w = min(emit.w, brows);\n\n            float downlight =\n                sd_egg2d(pp - vec2(0., -0.04 + shift), 0.030, 0.02);\n            downlight = blend(downlight, eye + 0.01, 330.);\n            col = mix(col, brown * 3.0, step(downlight, 0.));\n            emit.rgb = mix(emit.rgb, brown * 3.0, AAstep(downlight));\n\n            float highlight = sd_sphere(pp - vec2(-0.02, 0.02), 0.01);\n            highlight = blend(highlight, eye + 0.005, 250.);\n            emit.rgb = mix(emit.rgb, brown * 10.0, AAstep(highlight));\n\n            vec2 sp = p - vec2(-0.02, 0.15 - wiggl);\n            sp *= rot(-0.40);\n            float smirk = sd_joint2d(sp.yx, 0.04, -0.40, 0.01);\n            sp = vec2(abs(p.x), p.y) - vec2(0.10, 0.151) + vec2(0., wiggl);\n            sp *= rot(-2.05);\n            float sides = sd_joint2d(sp, .07, 0.41, 0.01);\n            smirk = smin(smirk, sides, 0.0002);\n            emit.rgb = mix(emit.rgb, brown, AAstep(smirk));\n            emit.w = min(emit.w, smirk);\n\n            vec2 pb = vec2(abs(p.x) - 0.13, p.y - 0.02) - vec2(0.11, 0.17) +\n                      vec2(0., wiggl);\n            pb *= vec2(0.6, 1.);\n            float blush = sd_sphere(pb, 0.03);\n            albedo = mix(albedo, vec3(0.8, 0.2, 0.2),\n                         smoothstep(0.11, -0.15, blush));\n        }\n        if (hit.id == PLATE) {\n            albedo = vec3(1.);\n        }\n        if (hit.id == ICING) {\n            albedo = vec3(0.04, 0.015, 0.01) * 1.3;\n            rou = 0.02;\n            ior = 0.3;\n        }\n        if (hit.id == TOPPING) {\n            albedo = vec3(1.3);\n        }\n        if (hit.id == STRAWBERRY) {\n            albedo = vec3(0.9, 0.0, 0.0);\n        }\n        vec3 ssr = vec3(1., 0.9, 0.6);\n        col = lighting(1, nor, ldir, rd, vec3(1.), albedo, albedo * 0.75, ssr,\n                       rou, ior);\n\n        col *= ambientOcclusion(pos, nor);\n\n        float shadow =\n            softshadow(pos + nor * 0.01, normalize(lpos - pos), 0.01, 0.35, 0.40);\n        col *= smoothstep(-0.5, 1.0, shadow);\n    }\n    if (hit.id == 0u) {\n        float wiggl = cos(iTime * 11. + PI) * 0.01;\n        col = vec3(.4, 0.7, 0.2);\n        col *= smoothstep(0.5, 1.2, length(hit.pos.xz));\n        col *= smoothstep(\n            -0.5, 1.5,\n            clamp(length(hit.pos.xz - vec2(-0.5, 0.36) - wiggl) - 0.24, 0.2,\n                  1.));\n    }\n\n    vec3 background = vec3(1.15, .8, .36) * .9;\n    col = mix(col, background, smoothstep(4., 12., hit.t));\n\n    // col = ACESFilm(col);\n    col = color2agx(col);\n    // col = smoothstep(0., 1., col);\n\n    if (emit.w < 1e9 && hit.pos.z < 0.) {\n        col = mix(col, emit.rgb, step(emit.w, 0.));\n    }\n    \n    // vignette\n    vec2 in_uv = fragCoord / iResolution.xy;\n    col *= smoothstep(-0.02, .01,\n                      in_uv.x * in_uv.y * (1. - in_uv.x) * (1. - in_uv.y));\n   \n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 O,vec2 C){\n    float px=1./AA,i,j;vec4 cl2,cl;\n    if(AA==1.){render(cl,C);O=cl;return;}\n    for(i=0.;i<AA +min(iTime,0.0);i++){for(j=0.;j<AA;j++){\n    vec2 C2 = vec2(C.x+px*i,C.y+px*j);\n    render(cl2,C2);cl+=cl2;\n    }}cl/=AA*AA;O=cl;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\nfloat AAstep(float thre, float val) {\n    return smoothstep(-.5, .5, (val - thre) / min(0.03, fwidth(val - thre)));\n}\nfloat AAstep(float val) {\n    return AAstep(val, 0.);\n}\n\nstruct Hit {\n    float t;\n    vec3 pos;\n    uint id;\n};\n\nHit default_hit() { return Hit(1e9, vec3(0.), 999u); }\n\nHit hit_min(Hit a, Hit b) {\n    if (a.t < b.t) {\n        return a;\n    }\n    return b;\n}\nHit hit_max(Hit a, Hit b) {\n    if (a.t > b.t) {\n        return a;\n    }\n    return b;\n}\n\nmat2 rot(float x) {\n    float c = cos(x), s = sin(x);\n    return mat2(c, -s, s, c);\n}\n\nvec3 erot(vec3 p, vec3 d, float ro) {\n    return mix(dot(p, d) * d, p, cos(ro)) + cross(p, d) * sin(ro);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\n// float smin(float a, float b, float k) { return smax(a, b, -k); }\nfloat smax(float a, float b, float k) {\n    k *= 1.4;\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * h / (6.0 * k * k);\n}\n\nvec3 carve(in vec3 p1, in vec3 p2) {\n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\nvec3 carve(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z > -p2.z ? p1.xy : p2.xy, -smin(-p1.z, p2.z, k));\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash31(vec3 p3) {\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(hash31(fuv + vec3(0, 0, 0)), hash31(fuv + vec3(0, 1, 0)),\n                      hash31(fuv + vec3(1, 0, 0)), hash31(fuv + vec3(1, 1, 0)));\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(hash31(fuv + vec3(0, 0, 1)), hash31(fuv + vec3(0, 1, 1)),\n                      hash31(fuv + vec3(1, 0, 1)), hash31(fuv + vec3(1, 1, 1)));\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// https://www.shadertoy.com/view/md2GWW\nfloat stepNoise(float x, float n) {\n    float i = floor(x);\n    float s = 0.1;\n    float u = smoothstep(0.5 - s, 0.5 + s, fract(x));\n    return mix(floor(hash11(i) * n), floor(hash11(i + 1.) * n),\n               u); // from 0. to n - 1.\n}\n\nfloat easeInBack(float x) {\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nvec2 ibox(in vec3 ro, in vec3 rd, vec3 boxsize) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxsize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0)\n        return vec2(-1.0);\n    return vec2(tN, tF);\n}\n\nfloat sd_sphere(vec3 p, float r) { return length(p) - r; }\nfloat sd_sphere(vec2 p, float r) { return length(p) - r; }\n\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nfloat sd_rect(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat sd_cone(vec3 p, vec2 c, float h) {\n    float q = length(p.xz);\n    return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nfloat sd_torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat opSU(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                 vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nvec3 sd_capped_cone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n    float rba = rb - ra;\n    float baba = dot(b - a, b - a);\n    float papa = dot(p - a, p - a);\n    float paba = dot(p - a, b - a) / baba;\n    float x = sqrt(papa - paba * paba * baba);\n    float cax = max(0.0, x - ((paba < 0.5) ? ra : rb));\n    float cay = abs(paba - 0.5) - 0.5;\n    float k = rba * rba + baba;\n    float f = clamp((rba * (x - ra) + paba * baba) / k, 0.0, 1.0);\n    float cbx = x - ra - f * rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n\n    float px = atan(p.x, p.z) * paba;\n    float py = atan(p.y, p.x) * rba;\n\n    return vec3(px, py,\n                s * sqrt(min(cax * cax + cay * cay * baba,\n                             cbx * cbx + cby * cby * baba)));\n}\n\nfloat sd_joint2d(in vec2 p, in float l, in float a, float w) {\n    // if perfectly straight\n    if (abs(a) < 0.001) {\n        p.y -= clamp(p.y, 0.0, l);\n        return length(p);\n    }\n\n    // parameters\n    vec2 sc = vec2(sin(a), cos(a));\n    float ra = 0.5 * l / a;\n\n    // recenter\n    p.x -= ra;\n\n    // reflect\n    vec2 q = p - 2.0 * sc * max(0.0, dot(sc, p));\n\n    // distance\n    float u = abs(ra) - length(q);\n    float d = (q.y < 0.0) ? length(q + vec2(ra, 0.0)) : abs(u);\n\n    return d - w;\n}\n\nfloat sd_ellipsoid(vec3 p, vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sd_line(vec2 p, float r, float l) {\n    l = max(0., l);\n    p.y -= clamp(p.y, -l, l);\n    return length(p) - r;\n}\n\nfloat sd_egg2d(in vec2 p, in float ra, in float rb) {\n    const float k = sqrt(3.0);\n\n    p.x = abs(p.x);\n\n    float r = ra - rb;\n\n    return ((p.y < 0.0)             ? length(vec2(p.x, p.y)) - r\n            : (k * (p.x + r) < p.y) ? length(vec2(p.x, p.y - k * r))\n                                    : length(vec2(p.x + r, p.y)) - 2.0 * r) -\n           rb;\n}\n\nfloat sd_egg(in vec3 p, in float ra, in float rb, float o) {\n    vec2 q = vec2(length(p.xz) - o, p.y);\n    return sd_egg2d(q, ra, rb);\n}\n\nfloat blend(float a, float b, float k) {\n    return log(exp(a * k) + exp(b * k)) / k;\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// { dist, t, y (above the plane of the curve, x (away from curve in the plane\n// of the curve))\nfloat det(vec2 a, vec2 b) { return a.x * b.y - b.x * a.y; }\nvec4 sdBezier(vec3 p, vec3 va, vec3 vb, vec3 vc) {\n    vec3 w = normalize(cross(vc - vb, va - vb));\n    vec3 u = normalize(vc - vb);\n    vec3 v = cross(w, u);\n\n    vec2 m = vec2(dot(va - vb, u), dot(va - vb, v));\n    vec2 n = vec2(dot(vc - vb, u), dot(vc - vb, v));\n    vec3 q = vec3(dot(p - vb, u), dot(p - vb, v), dot(p - vb, w));\n\n    float mn = det(m, n);\n    float mq = det(m, q.xy);\n    float nq = det(n, q.xy);\n\n    vec2 g = (nq + mq + mn) * n + (nq + mq - mn) * m;\n    float f = (nq - mq + mn) * (nq - mq + mn) + 4.0 * mq * nq;\n    vec2 z = 0.5 * f * vec2(-g.y, g.x) / dot(g, g);\n    // float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)/mn, 0.0 ,1.0 );\n    float t = clamp(0.5 + 0.5 * (det(z - q.xy, m + n)) / mn, 0.0, 1.0);\n    vec2 cp = m * (1.0 - t) * (1.0 - t) + n * t * t - q.xy;\n\n    float d2 = dot(cp, cp);\n    return vec4(sqrt(d2 + q.z * q.z), t, q.z, -sign(f) * sqrt(d2));\n}\n\n// Agx from https://www.shadertoy.com/view/cd3XWr\n#define AGX_LOOK 2\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n    vec3 x2 = x * x;\n    vec3 x4 = x2 * x2;\n\n    return +15.5 * x4 * x2 - 40.14 * x4 * x + 31.96 * x4 - 6.868 * x2 * x +\n           0.4298 * x2 + 0.1191 * x - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n    const mat3 agx_mat =\n        mat3(0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n             0.0784335999999992, 0.878468636469772, 0.0784336,\n             0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n\n    const float min_ev = -12.47393f;\n    const float max_ev = 4.026069f;\n\n    // Input transform\n    val = agx_mat * val;\n\n    // Log2 space encoding\n    val = clamp(log2(val), min_ev, max_ev);\n    val = (val - min_ev) / (max_ev - min_ev);\n\n    // Apply sigmoid function approximation\n    val = agxDefaultContrastApprox(val);\n\n    return val;\n}\n\nvec3 agxEotf(vec3 val) {\n    const mat3 agx_mat_inv =\n        mat3(1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n             -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n             -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n\n    // Undo input transform\n    val = agx_mat_inv * val;\n\n    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n    // val = pow(val, vec3(2.2));\n\n    return val;\n}\n\nvec3 agxLook(vec3 val) {\n    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n    float luma = dot(val, lw);\n\n    // Default\n    vec3 offset = vec3(0.0);\n    vec3 slope = vec3(1.0);\n    vec3 power = vec3(1.0);\n    float sat = 1.0;\n\n#if AGX_LOOK == 1\n    // Golden\n    slope = vec3(1.0, 0.9, 0.5);\n    power = vec3(0.8);\n    sat = 0.8;\n#elif AGX_LOOK == 2\n    // Punchy\n    slope = vec3(1.0);\n    power = vec3(1.35, 1.35, 1.35);\n    sat = 1.4;\n#endif\n\n    // ASC CDL\n    val = pow(val * slope + offset, power);\n    return luma + sat * (val - luma);\n}\n\n// <-\n\nvec4 toLinear(vec4 sRGB) {\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055)) / vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB / vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 color2agx(vec3 col) {\n    // col = toLinear(vec4(col, 1.0)).rgb;\n\n    col = agx(col);\n    col = agxLook(col);\n    col = agxEotf(col);\n\n    return col;\n}\n","name":"Common","description":"","type":"common"}]}