{"ver":"0.1","info":{"id":"7tdfWS","date":"1663671424","viewed":148,"name":"Sphere slicing 0","username":"OstrichDog","description":"Sphere sliced in parts, separated by an arbitrary distance.\nThe important function is sdObject.\nIt seems to work decently, any suggestions are appreciated.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 camPos = vec3(0., 2., -5.);\nfloat screenDist = 1.;\nfloat minDist = 0.01;\nfloat maxDist = 100.;\n\nvec3 lightPos = vec3(2., 3., -4.);\n\nint maxSteps = 2500;\nfloat distanceHit = 0.01;\n\nvec4 obj = vec4(0., -1., -1., 1.);\nfloat planeX = 4.;\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    float dist = length(p) - r;\n\n    return (dist);\n}\n\nfloat sdCyl(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdObject(vec3 p) {\n    p += obj.xyz;\n    int ndiv = 2+int(floor(iTime/2.));\n    float cylH = abs(sin(iTime/10.))/2.;//float(ndiv);\n    p.y = abs(p.y);\n    \n \n    float initH = -mod(float(ndiv),2.)*(obj.w/float(ndiv)+cylH)\n                    -mod(float(ndiv+1),2.)*cylH/2.;\n    float totH=initH;\n    \n    float i=0.;\n    while(true) {\n        \n        if (p.y < totH + cylH)\n            return max(max(totH+cylH-p.y,p.y-totH), sdCyl(p, sqrt(pow(obj.w,2.)-pow(totH-i*cylH,2.))))/(0.25*i+1.);\n        totH += cylH;\n        \n        if (p.y < totH + 2.*obj.w/float(ndiv))\n            return sdSphere(vec3(p.x,p.y-i*cylH+ mod(float(ndiv+1),2.)*initH,p.z), obj.w);\n        totH += 2.*obj.w/float(ndiv);\n        \n        i++;\n        if (i>float(ndiv)/2.-0.001)\n            break;\n    }\n    \n    return sdSphere(p, obj.w);\n}\n\nfloat sdPlane(vec3 p, vec3 n, vec3 shift) {\n    n = normalize(n);\n    return dot(p - shift, n);\n}\n\nfloat smoothMin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0) / k;\n\treturn min(a, b) - h*h*k*(1.0 / 4.0);\n}\n\nfloat getDist(vec3 p) {\n    float distObj = sdObject(p);\n    float distPlaneY = sdPlane(p, vec3(0, 1, 0), vec3(0, -2, 0));\n    float distPlaneZ = sdPlane(p, vec3(1, .2, -1), vec3(0, 0, 15));\n    float distPlaneX = sdPlane(p, vec3(-1., .2, -1), vec3(0, 0, 15));\n    \n    float d = min(distObj, \n        smoothMin(distPlaneY, smoothMin(distPlaneZ, distPlaneX, 2.), 2.));\n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd, float startDist) {\n    float dist = startDist;\n    for (int i=0; i<maxSteps; i++){\n        float newDist = getDist(ro + rd*dist);\n        dist += newDist;\n        if (abs(newDist) <= distanceHit || dist >= maxDist) break;\n    }\n    return dist;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0.);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    //return n/e.x;\n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    float dif = dot(n, l);\n    \n    float dist = march(p+n*distanceHit*1.5, l, 0.);\n    float shadow = clamp(dist / length(lightPos - p), 0., 1.);\n    \n    return dif * shadow;\n}\n\nvec3 getColor(vec3 p) {\n    float cosb = dot(normalize(p.xz-obj.xz), vec2(cos(iTime*8.), sin(iTime*8.)));\n    float b = acos(cosb) / 3.14;\n\n    vec3 colObj =  vec3(.4,.3,.6);\n    vec3 colPlaneY =  vec3(0., 1., 1.);\n    vec3 colPlaneZ =  vec3(1., 1., 0.);\n    vec3 colPlaneX =  vec3(1., 0., 1.);\n    \n    float distObject = sdObject(p);\n    float distPlaneY = sdPlane(p, vec3(0, 1, 0), vec3(0, -2, 0));\n    float distPlaneZ = sdPlane(p, vec3(1, .2, -1), vec3(0, 0, 15));\n    float distPlaneX = sdPlane(p, vec3(-1., .2, -1), vec3(0, 0, 15));\n    \n    vec3 finalColor;\n    if (distObject <= distanceHit)\n        finalColor = colObj;\n    else\n        finalColor =\n            (1.-clamp(distPlaneY, 0., 1.)) * colPlaneY +\n            (1.-clamp(distPlaneZ, 0., 1.)) * colPlaneZ +\n            (1.-clamp(distPlaneX, 0., 1.)) * colPlaneX;\n            \n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv.x, uv.y, screenDist));\n    rd.yz *= rot(6.28 - 0.15);\n\n    float dist = march(ro, rd, minDist);\n    \n    vec3 p = ro + rd * dist;\n\n    float dif = light(p);\n    col = getColor(p) * dif;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}