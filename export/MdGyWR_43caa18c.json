{"ver":"0.1","info":{"id":"MdGyWR","date":"1521579395","viewed":284,"name":"viewport (MM3 ver.)","username":"Telperion","description":"\"viewport.frag\"\nModster Mash 3 version, 2018-03-18\n\nCast the source image to multiple \"screens\", as if in a surveillance simulation.\nfullscreen this binch tbqh","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["screen","lens","tv","vignette","watch","viewport","view","surveillance","dystopia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI (3.14152965359) \n\n\nfloat gray( vec3 c ) {\n  return 0.299 * c.x + 0.587 * c.y + 0.114 * c.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    // Controllables\n    float borderOfLife  = 1.0;  \t\t\t// 0.0 no border, 2.0 black screen, 1.0 just right\n    float colorPower    = 0.6;  \t\t\t// 0.0 no additional color, 1.0 really glo'd up\n    float scrollTween   = iTime;  \t\t\t// what it says on the box\n    float zoomDist      = 10.0;  \t\t\t// 1.0 good base for \"just center\", increase to distort further & add repetitions\n    float zoomToCenter  = 0.8;  \t\t\t// 0.1 good base for \"just center\", increase to 1.0 for full effect but stay within [0.1, 1.0] pls!\n\n    // Really kinda constant...\n    float portParam     = 7.0;\n    float singularity   = 0.6;   \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Loop and cast to Â±1 square\n    // Input coordinates shrink to accommodate zoomToCenter\n    uv = mod((uv - 0.5) * zoomToCenter + 0.5, 1.0);\n    uv = (2.0*uv-1.0) * singularity;\n\n    // This distortion gets most of its look from mapping a circle of the source to a square\n    // Find the angle and distance of this point from the center of the image\n    float quadrature = atan(uv.y, uv.x);\n    float fromRadius = sqrt(uv.x*uv.x + uv.y*uv.y);\n    \n    // Does the horizontal direction dominate?\n    // If so, prepare to vertical flip the source coordinates\n    bool hDom = false;\n    if (abs(uv.x) > abs(uv.y))\n    {\n        hDom = true;\n    }\n    float signer = float(uv.y + uv.x > 0.0) * 2.0 - 1.0;\n    \n    // Continue out from the circle perimeter to the square\n    vec2 pq;\n    if (hDom)\n    {\n        pq.x = fromRadius;\n        pq.y = fromRadius * tan(quadrature);\n    }\n    else\n    {\n        pq.y = fromRadius ;\n        pq.x = fromRadius / tan(quadrature);\n    }\n    pq = pq * signer;\n    \n    // Gracefully ease back from outer distortion to inner sanity\n    float reps = portParam + zoomDist;\n    float ease = pow(fromRadius, 2.0);\n    vec2 mn = uv;\n    \n    vec2 uvView = pq*ease + mn*(1.0-ease)*reps;\n    \n    \n    // Normalize back to [0, 1]\n    vec2 uvScroll = uvView + vec2(0.5, 0.5 + scrollTween);\n    uvView = mod(uvScroll, 1.0);\n    \n    // Scramble overlay colors using a generator ring and single-to-double index calculation\n    float reps2 = 12.0;\n    float scrambler = sqrt(12.0);\n    vec2 uvIndex = floor(uvScroll);\n    float indexView = scrambler * (uvIndex.x*reps2 + uvIndex.y);\n    vec3 col = vec3(mod(0.5+indexView/11.0,1.0), mod(indexView/5.0,1.0), mod(indexView/7.0,1.0));\n    \n    // Finally dereference the texture\n    vec4 tex = texture(iChannel0, uvView);\n    \n    // Output to screen\n    col = col / max(max(col.x, col.y), col.z);\n    vec3 colBlend = 1.0 - (1.0 - col*colorPower)*(1.0 - tex.xyz);\n    float borderSetter = pow(abs(2.0*uvView.x-1.0), 6.0) + pow(abs(2.0*uvView.y-1.0), 6.0);\n    fragColor = vec4(colBlend * clamp(1.0-borderSetter*borderOfLife,0.0,1.0),1.0);\n\n}","name":"Image","description":"","type":"image"}]}