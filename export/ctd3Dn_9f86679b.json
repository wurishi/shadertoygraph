{"ver":"0.1","info":{"id":"ctd3Dn","date":"1686822445","viewed":35,"name":"normal perlin noisy","username":"kyokuto","description":"perlin noisy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    //return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));输入点二维哈希函数生成一维随机值\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\n//原始perlin噪声\nfloat perlin_noise(vec2 p)\n{\n//根据当前坐标返回一个生成的噪声值\n    vec2 pi = floor(p);//向下取整\n    vec2 pf = p - pi;//得到坐标小数部分\n    \n    vec2 w = pf * pf * (3.0 - 2.0 * pf);//缓和曲线将其缓和\n    //hash22用于生成四个点的梯度向量，同时与距离向量点乘\n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)),\n                   w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), \n                   w.x),\n               w.y);\n}\n\nfloat noise_sum(vec2 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * perlin_noise(p); p = 2.0 * p;\n    f += 0.5000 * perlin_noise(p); p = 2.0 * p;\n    f += 0.2500 * perlin_noise(p); p = 2.0 * p;\n    f += 0.1250 * perlin_noise(p); p = 2.0 * p;\n    f += 0.0625 * perlin_noise(p); p = 2.0 * p;\n\n   return f;\n}\n\nfloat noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(perlin_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(perlin_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(perlin_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(perlin_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(perlin_noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\nfloat noise_sum_abs_sin(vec2 p)\n{\n    float f = noise_sum_abs(p);\n    f = sin(f * 1.5 + p.x * 7.0);\n    \n    return f * f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1,1,1)*(0.5+0.5*noise_sum_abs_sin(uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}