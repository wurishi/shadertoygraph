{"ver":"0.1","info":{"id":"NdcXDM","date":"1633261421","viewed":151,"name":"The Artifact Generator","username":"shyuriken","description":"from one Tri Prism with FOLD","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Processed by 'GLSL Shader Shrinker' (Shrunk by 292 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat luminance(vec3 col) { return dot(col, vec3(.2126729, .7151522, .072175)); }\n\nvec3 FXAA(sampler2D tex, vec2 uv) {\n\tconst vec3 e = vec3(-1, 1, 0);\n\tvec2 offuv = uv;\n\tvec3 colnw = texture(tex, uv + e.xy / iResolution.xy).rgb,\n\t     coln = texture(tex, uv + e.zy / iResolution.xy).rgb,\n\t     colne = texture(tex, uv + e.yy / iResolution.xy).rgb,\n\t     colw = texture(tex, uv + e.xz / iResolution.xy).rgb,\n\t     colm = texture(tex, uv + e.zz / iResolution.xy).rgb,\n\t     cole = texture(tex, uv + e.yz / iResolution.xy).rgb,\n\t     colsw = texture(tex, uv + e.xx / iResolution.xy).rgb,\n\t     cols = texture(tex, uv + e.zx / iResolution.xy).rgb,\n\t     colse = texture(tex, uv + e.yx / iResolution.xy).rgb;\n\tfloat ish,\n\t      lnw = luminance(colnw),\n\t      ln = luminance(coln),\n\t      lne = luminance(colne),\n\t      lw = luminance(colw),\n\t      lm = luminance(colm),\n\t      le = luminance(cole),\n\t      lsw = luminance(colsw),\n\t      ls = luminance(cols),\n\t      lse = luminance(colse),\n\t      maxl = max(ln, max(ls, max(lw, max(le, lm)))),\n\t      diff = maxl - min(ln, min(ls, min(lw, min(le, lm))));\n\tif (diff < max(.0833, .166 * maxl)) return colm;\n\tfloat filterfactor = 0.;\n\tfilterfactor += 2. * (ln + lw + ls + le) + lnw + lne + lsw + lse;\n\tfilterfactor /= 12.;\n\tfilterfactor = clamp(abs(filterfactor - lm) / diff, 0., 1.);\n\tfloat blend = smoothstep(0., 1., filterfactor);\n\tblend *= blend;\n\tish = step(2. * (le + lw - 2. * lm) + (lne + lnw - 2. * ln) + (lse + lsw - 2. * ls), 2. * (ln + ls - 2. * lm) + (lne + lse - 2. * le) + (lnw + lsw - 2. * lw));\n\tfloat psoff = ish >= 1. ? 1. / iResolution.y : 1. / iResolution.x;\n\tif (abs(ish >= 1. ? ln : le - lm) < abs(ish >= 1. ? ls : lw - lm)) psoff = -psoff;\n\tif (ish >= 1.) offuv.y += psoff * blend;\n\telse offuv.x += psoff * blend;\n\n\treturn vec3(textureLod(tex, offuv, 0.).rgb);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) { fragColor = vec4(FXAA(iChannel0, fragCoord / iResolution.xy), 1); }","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Processed by 'GLSL Shader Shrinker' (Shrunk by 8,357 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat pTriPrism(float h, float r, vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h, max(q.x * .866025 + p.y * .5, -p.y) - r * .5);\n}\n\nvec3 mTwist(float k, vec3 p) {\n\tfloat c = cos(k * p.z),\n\t      s = sin(k * p.z);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nfloat sabs(float p) { return sqrt(p * p + 1e-2); }\n\nvec3 mFold(vec3 sw, vec3 t, vec3 p) {\n\tfloat h, a,\n\t      n = sw.x,\n\t      r = sw.y;\n\tbool s = sw.z > 0.;\n\th = floor(log2(n));\n\ta = 6.2832 * exp2(h) / n;\n\tfor (int i = 0; i < int(h) + 2; i++) {\n\t\tvec2 v = normalize(vec2(-cos(a), sin(a)));\n\t\tfloat g = dot(p.xz, v);\n\t\tp.xz -= (g - ((r > 0.) ? sabs(g) : abs(g))) * v;\n\t\ta *= .5;\n\t}\n\n\tp.xz -= clamp(p.xz, s ? -t.xz : t.xz, t.xz);\n\treturn p;\n}\n\nfloat oThicken(float thickness, float d) { return d - thickness; }\n\nfloat sdf(vec3 p0) {\n\tfloat d1;\n\t{\n\t\tvec3 p1 = mFold(vec3(16.0*sin(iTime*0.01), 1, 1), vec3(0, 0, 1), p0);\n\t\t{\n\t\t\tvec3 p2 = mFold(vec3(6.0*sin(iTime*0.01), 1, 1), vec3(0, 0, 4), p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mFold(vec3(24.0*cos(iTime*0.01), 1, 0), vec3(0, 0, 2), p2);\n\t\t\t\t{ d1 = pTriPrism(1., 1., mTwist(.68*cos(iTime*0.01), p3)); }\n\t\t\t}\n\t\t}\n\t}\n\treturn oThicken(.1, d1);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (h < .001) break;\n\t\tt += h;\n\t\tif (t > 50.) break;\n\t}\n\n\tif (t > 50.) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat t,\n\t      fi = 10. * iMouse.x / iResolution.x,\n\t      th = 10. * iMouse.y / iResolution.y;\n\tvec3 ro = vec3(5. * cos(fi) * sin(th), 12.0,  10. * cos(th)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tt = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(1);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.18) * vec3(4, 4, 4) * sun_dif * sun_sha;\n\t\tcol += vec3(.18) * vec3(.5, .8, .9) * sky_dif * occ;\n\t\tcol += vec3(.18) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}