{"ver":"0.1","info":{"id":"4XB3Wh","date":"1708394934","viewed":110,"name":"Perfect Pixels","username":"kdh68grn3c","description":"Render a moving, scaled sprite without \"pixel wobble\"","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pixels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int SPRITE_SIZE = 32;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.45, 0.40, 0.35);\n\nconst vec2 ANCHOR = vec2(80., 80.);\nconst float ANCHOR_RADIUS = 70.0;\nconst float ROT_SPEED = 0.25;\n\nconst float SCALE = 6.5;\nconst float SCALE_SPEED = 0.25;\nconst float SCALE_MAG = 0.00;\n\nvec3 sprite0(int x, int y) {\n    if (x < 0 || SPRITE_SIZE <= x || y < 0 || SPRITE_SIZE <= y) {\n        // check for out-of-bounds pixels\n        return vec3(1., 0., 1.);\n    } else {\n        if (x % 2 == y % 2) {\n            return vec3(1., 1., 1.);\n        } else {\n            return vec3(0., 0., 0.);\n        }\n    }\n}\n\nvec3 sprite_naive(vec2 p, float size) {\n    float scale = float(SPRITE_SIZE) / size;\n    int x = int(p.x * scale);\n    int y = int(p.y * scale);\n    vec3 col = sprite0(clamp(x, 0, SPRITE_SIZE-1), clamp(y, 0, SPRITE_SIZE-1));\n    return col;\n}\n\nvec3 sprite_no_wobble(vec2 a, vec2 p, float size) {\n    int ix = int(a.x);\n    int iy = int(a.y);\n    float rx = a.x - float(ix);\n    float ry = a.y - float(iy);\n    float px = p.x - 0.5 + rx;\n    float py = p.y - 0.5 + ry;\n\n    float scale = float(SPRITE_SIZE) / size;\n    int x = int(px * scale);\n    int y = int(py * scale);\n    vec3 col = sprite0(clamp(x, 0, SPRITE_SIZE-1), clamp(y, 0, SPRITE_SIZE-1));\n\n    if (px <= 0. || py <= 0. || x < 0 || SPRITE_SIZE <= x || y < 0 || SPRITE_SIZE <= y) {\n        // alpha blend unncessary border pixels with BACKGROUND\n        return mix(col, BACKGROUND_COLOR, 0.75);\n    } else {\n        return col; // solid\n    }\n}\n\n//---- TEXT\n// String declarations\nmakeStr(printOn)      _N _A _I _V _E _end\nmakeStr(printOff)     _N _O __ _W _O _B _B _L _E _end\n//---- TEXT\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 outCol;\n    \n    bool DISABLE_WOBBLE = int(floor(iTime / 2.0)) % 2 == 0;\n\n    vec2 anchor = ANCHOR + ANCHOR_RADIUS * vec2(sin(ROT_SPEED*iTime), cos(ROT_SPEED*iTime));\n    float size = SCALE * float(SPRITE_SIZE) * (1.0 + SCALE_MAG*sin(SCALE_SPEED*iTime));\n\n    vec2 p = fragCoord - anchor;\n    \n    if (0. <= p.x && p.x < size && 0. <= p.y && p.y < size) {\n        vec3 col;\n        if (DISABLE_WOBBLE) {\n            col = sprite_no_wobble(anchor, p, size);\n        } else {\n            col = sprite_naive(p, size);\n        };\n        outCol = col;\n    } else {\n        outCol = BACKGROUND_COLOR;\n    }\n    \n    \n    //---- TEXT\n    vec2 uv = fragCoord / iResolution.y;\n    const float font_size = 12.;\n    uv *= font_size;        // Scale font with font_size\n    uv.y -= font_size - 1.; // Start drawing from the top\n    if (DISABLE_WOBBLE) {\n        outCol += vec3(0.35, 1., 0.35) * printOff(uv);\n    } else {\n        outCol += vec3(1., 0.35, 0.35) * printOn(uv);\n    }\n    //---- TEXT\n    \n    fragColor = vec4(outCol, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//---- TEXT https://www.shadertoy.com/view/dsGXDt\n\n/*   ### How to use this shader ? ###\n   \n   = Setup =\n   0. Copy the content of the Common Tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n   \n   = Declare String =\n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printAnother) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n   \n   = Print String =\n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printAnother(uv);\n   \n   Note that by default a character has a height of 1 (which is full height if \n   the coordinates are normalized). You are responsible for scaling/offsetting \n   the uvs to control the text placement before calling the function.\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _EXC _QUOT ... (see Common)\n   \n   \n   ### Javascript string generator helper ###\n   \n   To make things even easier, I've made a tiny javascript helper function that you\n   can use to convert strings to the right _F _o _r _m _a _t !\n   (I've written it in the comments of this shader)\n   \n   \n   ### Special functions ###\n   \n   _dig(i)       : write a specific digit [i ranges between 0-9]\n   _dec(i, prec) : write a floating point number [prec: number of decimals to print]\n   _ch(i)        : Write an uppercase character [i ranges between 0-25]\n   \n   To use these special functions, you need to pass additional parameters into makeStr:\n   \n   \"makeStr1i\" allows you to pass 1 int parameter named \"i\" :\n   \n   makeStr1i(test) _dig(i) _end\n   test(uv, 5);\n   \n   \"makeStr1f\" allows you to pass 1 float parameter named \"i\":\n   \n   makeStr1f(test) _dec(i, 3) _end\n   test(uv, 5.);\n   \n   You can also create your own makeStr with any parameter type! (see below)\n   \n   \n   ### Help me optimize it! ###\n   \n   The _dec() function is only for debug purposes, I've never used it in a published shader.\n   It's *very* intensive and can have rounding issues (ie 21.999 when the float is 22.), \n   however it's done with a pretty naive approach so if you can come up with a better one\n   I'd be glad! The function is defined at the very end of this tab.\n*/\n\n/// SETTINGS ///\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel0\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n\n/// SPECIAL FUNCTIONS ///\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n\n/// SPECIAL CHARACTERS ///\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n\n/// CHARACTER DEFINITIONS ///\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).r * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    (0 _DOT ); // Print a dot\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}","name":"Common","description":"","type":"common"}]}