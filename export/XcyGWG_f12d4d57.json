{"ver":"0.1","info":{"id":"XcyGWG","date":"1713193472","viewed":69,"name":"Distance to ellipse","username":"lgc","description":"SDF of ellipse. Using Newton's method.\nref: https://www.shadertoy.com/view/stB3zw","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","ellipse","newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 p, m;\n\n/*\nf(u) = (a*cos(u)-x0)^2+(b*sin(u)-y0)^2\ndf/du = (a^2-b^2)*sin(u)*cos(u) - a*x0*sin(u) + b*y0*cos(u) = 0\nfinding root using newton's method\n*/\nfloat ellipse(vec2 ab) {\n    vec2 p = abs(p);\n    if(ab.x<ab.y) ab = ab.yx, p = p.yx;\n    float a = ab.x, b = ab.y, cc = a*a-b*b;\n    float A = p[0]*a/cc, B = p[1]*b/cc, t = 1.0;\n    for(int i = 0; i < 7; i++) {\n        float S = sin(t), C = cos(t);\n        t -= (S*C-S*A+C*B)/(C*C*2.0-1.0-C*A-S*B);\n    }\n    vec2 p0 = vec2(cos(t),sin(t))*ab, p1 = p/ab;\n    return length(p-p0)*sign(dot(p1,p1)-1.0);\n}\n\n/*\ntrig-free version\nt = tan(u/2), cos(u) = (1-t^2)/(1+t^2), sin(u) = (2t)/(1+t^2)\nh(t) = b*y0*t^4 + 2(a*x0+a^2-b^2)*t^3 + 2(a*x0-a^2+b^2)*t - b*y0 = 0\n*/\nfloat ellipse2(vec2 ab) {\n    vec2 p = abs(p);\n    if(ab.x<ab.y) ab = ab.yx, p = p.yx;\n    float x0 = p.x, y0 = p.y, a = ab.x, b = ab.y;\n    float A = a * x0, B = b * y0, C = a * a - b * b;\n    float a4 = B, a3 = 2.0 * (A + C), a1 = 2.0 * (A - C), a0 = -B;\n    float t = 1.0;\n    for(int i = 0; i < 10; i++) {\n        float t2 = t * t, t3 = t2 * t, a32 = a3 * t2, a43 = a4 * t3;\n        t -= ((a43 + a32 + a1) * t + a0) / (a43 * 4.0 + a32 * 3.0 + a1);\n    }\n    float t2 = t * t;\n    float x = a * (1.0 - t2) / (1.0 + t2), y = b * (2.0 * t) / (1.0 + t2);\n    float d = length(p - vec2(x, y));\n    return x0 > x || y0 > y ? d : -d;\n}\n\nvec4 visualize(float d) {\n    // return vec4(smoothstep(0.01, -0.01, d));\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)));\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = min(iResolution.x,iResolution.y) / 2.0;\n    p = (fragCoord*2.0-iResolution.xy) / w;\n    m = abs(iMouse.xy*2.0-iResolution.xy) / w;\n    float d = ellipse2(m);\n\tfragColor = visualize(d);\n}","name":"Image","description":"","type":"image"}]}