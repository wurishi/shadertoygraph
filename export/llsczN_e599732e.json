{"ver":"0.1","info":{"id":"llsczN","date":"1503918924","viewed":93,"name":"Compass rose","username":"Ultraviolet","description":"In case you get lost.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rose","compass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415972\n\n\n// Sky parameters\nvec3 sunDir = normalize(vec3(1.0));\nvec3 sunColor = vec3(1.0);\n\nvec3 skyColor = vec3(.42, .62, .83);\n\n\n//vec3 col0 = vec3(0.9, 0.5, 0.5);\n//vec3 col1 = vec3(0.5, 0.5, 0.9);\n\n\nvec3 col0 = vec3(0.9);\nvec3 col1 = vec3(0.1);\n\n\nvec3 getSky(in vec3 rd)\n{\n    return pow(texture(iChannel0, rd).xyz, vec3(1.0/0.45));\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(skyColor, vec3(.32, .32, .32), v);\n\tsky = sky + sunColor * sunAmount * sunAmount * .25;\n\tsky = sky + sunColor * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvec4 renderCompass( in vec3 ro, in vec3 rd)\n{    \n    float dd = 0.25;\n    \n    vec3 c = vec3(0.0, dd, 0.0);\n    \n    float nb = 4.0;\n    \n    float t = 10000.0;\n    vec3 col = vec3(0.0);\n    vec3 n = vec3(0.0);\n    \n    vec3 pos;\n    \n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n    c *= 0.85;\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            t = t_;\n        }\n    }\n    \n        \n    \n    \n    c /= 0.85;\n    ro *= vec3(1.0, -1.0, 1.0);\n    rd *= vec3(1.0, -1.0, 1.0);\n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    \n    for(float alpha = 0.0; alpha < 2.0*M_PI; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    \n    \n    c *= 0.85;\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,-dd*sin(alpha)+cos(alpha)));\n        \n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)-pos.z*sin(alpha)>0.0 && +pos.x*sin(alpha)+pos.z*cos(alpha)>0.0 && pos.y>0.0)\n        {\n            col = col1;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    for(float alpha = M_PI*0.25; alpha < 2.0*M_PI+M_PI*0.25; alpha += 2.0*M_PI/nb)\n    {\n        vec3 n0 = normalize(vec3( dd*cos(alpha) + sin(alpha), 1.0,dd*sin(alpha)-cos(alpha)));\n\n        float t_ = dot(c - ro, n0)/dot(rd, n0);\n        if(t_< 0.0 || t_>t)\n            continue;\n\n        pos = ro+t_*rd;\n        if(pos.x*cos(alpha)+pos.z*sin(alpha)>0.0 && -pos.x*sin(alpha)+pos.z*cos(alpha)<0.0 && pos.y>0.0)\n        {\n            col = col0;\n            n = n0;\n            //n = n0*vec3(1.0, -1.0, 1.0);\n            t = t_;\n        }\n    }\n    \n    if(t>5.0)\n    \treturn vec4(0.0);\n    \n    return vec4(mix(col, getSky(reflect(rd, n)), 0.1), 1.0);\n}\n\n\nfloat angle(vec2 p)\n{\n    return atan(p.y, p.x);\n}\n\nfloat angle(vec2 p0, vec2 p1)\n{\n    float a =  angle(p1) - angle(p0);\n    \n    //*\n    if(a < -M_PI)\n        a += 2.0 * M_PI;\n    \n    if(a > M_PI)\n        a -= 2.0 * M_PI;\n//*/\n    \n    return a;\n}\n\nvec4 renderN( in vec3 ro, in vec3 rd)\n{\n    float t = -ro.y / rd.y;\n    \n    if(t < 0.0)\n    \treturn vec4(0.0);\n    \n    vec2 p = (ro+rd*t).xz;\n    float xx = 0.7;\n    \n    vec2 pt[10] = vec2[](\n        vec2(0.0, 0.0),\n    \tvec2(1.0, 0.0),\n    \tvec2(1.0, 2.0-xx),\n    \tvec2(2.0, 0.0),\n    \tvec2(3.0 ,0.0),\n    \tvec2(3.0, 3.0),\n    \tvec2(2.0, 3.0),\n    \tvec2(2.0, 1.0+xx),\n    \tvec2(1.0, 3.0),\n        vec2(0.0, 3.0));\n    \n    for(int k = 0; k<pt.length(); ++k)\n        pt[k] = (pt[k].yx - vec2(1.5)) / 6.0 + vec2(1.3, 0.0);\n    \n    float winding = 0.0;\n    for(int k = 0; k<pt.length(); ++k)\n    \twinding += angle(pt[k]-p, pt[(k+1)%pt.length()]-p);\n    \n    if(abs(winding) > 0.5)\n    \treturn vec4(0.0, 0.0, 0.0, 1.0);\n    return vec4(0.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{\n\tvec3 col;\n    vec4 res;\n    \n    // background sky\n    col = getSky(rd);\n    \n    res = renderN(ro, rd);\n    col = col*(1.0-res.w) + res.xyz*res.w;\n    \n    res = renderCompass(ro, rd);\n    col = col*(1.0-res.w) + res.xyz*res.w;\n    \n    return  col;\n}\n\nvec3 postEffects(vec3 col, vec2 uv)\n{\n\t// Gamma correction\n\tcol = pow(col, vec3(0.45));\n\t\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera & ray\n    float phi = m.x * M_PI * 2.0;\n    float psi = M_PI-(m.y) * M_PI;\n    \n    if(iMouse.x<0.5)\n    {\n        psi = -M_PI * 0.3;\n        phi = iDate.w;\n    }\n    \n    vec3 ro = 2.0*vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n\tvec3 ta = vec3(0.0);\n    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    \n    vec3 col = render( ro, rd);\n    \n\tcol = postEffects(col, fragCoord/iResolution.xy);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}