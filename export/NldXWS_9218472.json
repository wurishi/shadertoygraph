{"ver":"0.1","info":{"id":"NldXWS","date":"1645550122","viewed":89,"name":"red-line","username":"avaer","description":"Just a smooth red line","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["line","red"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat circleFactor(vec2 p, vec2 center, float radius, float decay) {\n  vec2 p2 = p - center;\n  if (length(p2) <= radius) {\n    return 1.;\n  } /* else {\n    return 0.;\n  } */\n  p2 = normalize(p2) * radius;\n  p2 += center;\n  return max(1. - length(p2 - p) / decay, 0.);\n}\nfloat flatten(vec3 c) {\n  return (c.r + c.g + c.b)/3.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    const float coreWidth = 0.04;\n    const float decayWidth = 0.04;\n    // const float fullWidth = coreWidth +\n    float currentX = iTime;\n    float f;\n    if (uv.x < 0.5 && uv.x < currentX) {\n        if (uv.y <= 0.5) {\n          f = 0.5 - coreWidth/2. - uv.y;\n        } else {\n          f = uv.y - (0.5 + coreWidth/2.);\n        }\n    } else {\n      f = 1.;\n    }\n    float a = (1.-min(max(f, 0.), 1.)/decayWidth);\n    a = min(max(a, 0.), 1.);\n    \n    // base color\n    vec3 hsv = vec3(uv.x, 1., 1.);\n    // add inner core\n    float yDiff = abs(uv.y - 0.5);\n    const float innerSize = 0.02;\n    if (yDiff >= innerSize) {\n      hsv.z *= pow(uv.x*2., 0.3);\n    }\n    // cool down over time\n    float cooldown = min(max(2.0 - currentX + uv.x*2., 0.), 1.);\n    hsv.z *= cooldown;\n    \n    vec3 rgb = hsv2rgb(hsv);\n    \n    vec3 col = rgb;\n    \n    vec2 tuv = uv; // vec2(uv.y, uv.x);\n    vec3 tc = texture(iChannel0, tuv * 10.).rgb;\n    float tv = flatten(tc);\n    if (yDiff >= innerSize) {\n      col += tv;\n    } else {\n      col += tv * (1. - cooldown) * 0.5;\n    }\n    col *= a;\n    \n    float currentXClamp = min(currentX, 0.5);\n    col += circleFactor(uv, vec2(currentXClamp, 0.5), 0.06, 0.04);\n\n    // Output to screen\n    fragColor = vec4(col, a);\n}\n\n/*\n\ngShaderToy.SetTexture(0, {\n  mSrc: 'https://webaverse.github.io/assets/land-textures/Vol_38_5_Base_Color.png',\n  mType: 'texture',\n  mID: 1,\n  mSampler: {\n    filter: 'mipmap',\n    wrap: 'repeat',\n    vflip: 'true',\n    srgb: 'false',\n    internal: 'byte',\n  },\n});\n\n*/","name":"Image","description":"","type":"image"}]}