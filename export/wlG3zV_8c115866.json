{"ver":"0.1","info":{"id":"wlG3zV","date":"1579642412","viewed":185,"name":"star in a star in a star in a ..","username":"julianlumia","description":":)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nconst float PI = 3.14159265;\n\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  return (p.y+p.z)*0.735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\n return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\n\nvec2 GetDist(vec3 p) {\n vec2 d;\n d.x =p.y +10.;\n for(int i=0; i<5; i++)\n {\n  p = abs(p);\n // p = rotate( normalize( vec3(2. ,0.,2. ) ), sin(59.*0.2)*100.)*p;\n   p = rotate( normalize( vec3(1.3 ,-.1,2. ) ), sin(59.*0.2)*80.)*p;\n  vec2 dbox = vec2(sdOctahedron( p- vec3(-0.,0,abs(sin(p.z-iTime)*2.)),1.),1.);\n  if( dbox.x < d.x)\n  {\n   g1 +=3./(0.6+pow(abs(dbox.x),10.));\n   d = condmin( d,dbox);\n  }\t\n }\n return d ;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);  \nfor (int i=0; i<64; i++) \n {   \n  h = GetDist(ro + t.x * rd);   \n  if(h.x<0.001||abs(t.x)>70.) break;\n  t.x+=h.x *.6;\n  t.y=h.y;\n }\n if(t.x>70.) \n t.x=.0;\nreturn t;\n}\n\n\nvec3 GetNormal(vec3 p){\n vec2 d = GetDist(p);\n vec2 e = vec2(0.001,0);\n vec3 n = d.x - vec3(\n GetDist(p-e.xyy).x,\n GetDist(p-e.yxy).x,\n GetDist(p-e.yyx).x);\n return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime),cos(iTime),0.);\n vec3 l = normalize(lightPos-p);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*.001*1., l);\n if (d.x<length(lightPos-p)) dif *= .01;\n return dif;       \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 col = vec3(0);  \n vec3 ro = vec3(-3, -10., 1.);\n ro.yz *= Rot(-m.y*3.14+1.);\n ro.xz *= Rot(-m.x*6.2831);\n ro.xy *= Rot(cos(iTime*0.1)*3.14+2.);\n //ro.xz *= Rot((cos(iTime*0.1))*3.2831-0.1);   \n vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n vec2 d = RayMarch(ro, rd);   \n float t =d.x *1.;   \n if(t>0.){\n vec3 p = ro + rd *t;\n vec3 baseColor = vec3(1.,1.,0.);\n if(d.y==1.) baseColor=vec3(sin(p.z+iTime)+1.,1.,1.);\n float dif = GetLight (p); \n col = vec3(dif);  \n col+=baseColor; \n float fog = 1. / (1. + t * t * .004);\n col *= vec3(fog);   \n }\n vec3 sky = vec3(1., 1., 1.);\n col = mix(sky, col, 0.84/(d.x/100.*.9+1.)); \n col *=g1*vec3(.001);\n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}