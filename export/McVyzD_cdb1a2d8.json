{"ver":"0.1","info":{"id":"McVyzD","date":"1731592380","viewed":28,"name":"Torus 3D - Curve 2 flow","username":"Fred_The_Red","description":"Iterating torus homeomorphisms","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dynamicsonthetorus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Torus 3D - Curve 1 flow\" by Fred_The_Red. https://shadertoy.com/view/Mccczl\n// 2024-11-11 15:20:22\n\n\n// Définitions des rayons du tore\n#define R1 2.0    // Rayon principal\n#define R2 0.6    // Rayon du cercle de section\n\n// Fonction de distance pour un tore ; t contient les rayons\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// Fonction de raymarching pour déterminer le point du tore\n// vu depuis r0 dans la direction rd\nfloat march(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * dist;\n        float d = sdTorus(p, vec2(R1, R2)); // Utilisation des rayons définis\n        if (d < 0.001) return dist;\n        dist += d;\n        if (dist > 100.0) break;\n    }\n    return dist;\n}\n\n// Calcul de la normale en un point, pour le shading\nvec3 calculateNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sdTorus(p + e.xyy, vec2(R1, R2)) - sdTorus(p - e.xyy, vec2(R1, R2)),\n        sdTorus(p + e.yxy, vec2(R1, R2)) - sdTorus(p - e.yxy, vec2(R1, R2)),\n        sdTorus(p + e.yyx, vec2(R1, R2)) - sdTorus(p - e.yyx, vec2(R1, R2))\n    ));\n}\n\n// Fonction pour calculer les coordonnées UV pour le mappage de texture sur un tore\n//vec2 calculateUV(vec3 p) {\n//    float u = atan(p.z, p.x) / (2.0 * 3.141592) + 0.5;  // Coordonnée U basée sur l'angle autour de l'axe Y\n    //float v = p.y / R2 * 0.5 + 0.5;                     // Coordonnée V basée sur la position verticale\n//    return vec2(u, v);\n//}\n\n// Fonction pour calculer les coordonnées UV pour le mappage de texture sur un tore\nvec2 calculateUV(vec3 p) {\n    // Calcul de la coordonnée U : tour principal du tore autour de l'axe Y\n    float u = atan(p.z, p.x) / (2.0 * 3.141592) + 0.5;\n\n    // Coordonnée V : tour interne du cercle de section du tore\n    // Projection de p dans le plan XZ pour calculer sa distance au centre du tore\n    float distXZ = length(vec2(p.x, p.z));\n    float v = atan(p.y, distXZ - R1) / (2.0 * 3.141592) + 0.5;\n\n    return vec2(u, v);\n}\n\n// Fonction principale\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    // Calcul des angles de rotation basés sur la position de la souris\n    float rotX;\n    float rotY;    \n    if (vec2(iMouse.x, iMouse.y) == vec2(0.))\n        {rotX = 0.4; rotY=0.;}\n    else{\n        rotX = (iMouse.y / iResolution.y - 0.5) * 3.141592; // Rotation en X selon la position verticale de la souris\n        rotY = (iMouse.x / iResolution.x - 0.5) * 3.141592; // Rotation en Y selon la position horizontale de la souris\n        }\n\n    // Paramètres de la caméra initiale\n    vec3 camPos = vec3(0.0, 0.0, 4.0); // Distance initiale de la caméra\n\n    // Appliquer les rotations à la caméra pour la faire tourner autour de l'origine\n    mat3 rotationMatrix = rotationX(rotX) * rotationY(rotY);\n    camPos = rotationMatrix * camPos;\n\n    // Définir le vecteur de direction (du rayon) pour pointer vers l'origine\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotationMatrix * vec3(uv, -0.7*zoom));\n\n\n\n    // Paramètres de la lumière\n    vec3 lightPos = vec3(2.0, 3.0, 2.0);\n    vec3 lightColor = vec3(1.0, 0.9, 0.8);\n    vec3 ambientLight = vec3(0.3, 0.3, 0.4); // Lumière ambiante\n\n    // Calcul de la distance et de la couleur\n    float d = march(ro, rd);\n    vec3 color = vec3(0.0);\n    \n    if (d < 10.0) {\n        vec3 p = ro + rd * d;\n        vec3 normal = calculateNormal(p);\n\n        // Éclairage Lambertien\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        // Coordonnées de texture\n        vec2 uvTorus = calculateUV(p);\n\n        // Échantillonnage de la texture 2D\n        //vec3 texColor = texture(iChannel0, uvTorus).rgb;\n        vec2 newPos = f(uvTorus, iTime*SPEED);\n        vec4 texColor = initialImage(newPos);\n        // Additional fixed vertical curve\n        if(displayVerticalCurve)\n            {texColor += verticalCurve(uvTorus, verticalCurveWidth, green);}\n        // Additional fixed horizontal curve\n        if(displayHorizontalCurve)\n            {texColor += horizontalCurve(uvTorus, curveWidth, red);}\n\n\n        // Application de la couleur texturée avec l’éclairage direct et la lumière ambiante\n        color = texColor.xyz * (diff * lightColor + ambientLight);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415\n#define nb_flows 2\n#define SPEED 0.5\n#define curveWidth 0.005\n#define verticalCurveWidth 0.001\n#define iteratedCurveWidth 0.01\n#define displayVerticalCurve true\n#define displayHorizontalCurve true\n#define zoom 1.\n\nvec3 red = vec3 (1., 0., 0.);\nvec3 green = vec3 (0., 1., 0.);\nvec3 blue = vec3 (0., 0.7, 1.);\nvec3 grey = vec3 (0.3);\n\n\nfloat distance1(float x)\n{\nreturn (x < 0.5 ? x : (1.-x));\n}\n\nfloat distance2(vec2 pos)\n{\nreturn distance1(pos.x)*distance1(pos.x) + distance1(pos.y)*distance1(pos.y);\n}\n\nvec2 flow1(vec2 pos,float t)\n{\n    vec2 flow;\n    flow = vec2(pos.x, mod(pos.y + t*sin(2.*PI*pos.x), 1.));\n    // Rotation :\n    //flow = vec2(mod(pos.x+t, 1.), mod(pos.y+0.9*t, 1.));\n    // Rotation avec point d'arrêt : NON\n    //float alpha = 0.41421356237;\n    //float d = distance2(pos);\n    //flow = vec2(mod(pos.x+d*t, 1.), mod(pos.y+d*alpha*t, 1.));    \n    return flow;\n}\n\nvec2 flow2(vec2 pos,float t)\n{\n    return vec2(mod(pos.x + t*sin(2.*PI*pos.y), 1.), pos.y);\n}\n\n// Time t isotopy\nvec2 f(vec2 pos, float t)\n{\nt = t * SPEED;\nif(nb_flows == 1){pos = flow1(pos, -t);}\nelse{\n    float n = floor(t);\n    float tt = t - n;\n    bool even = (mod(n, 2.) == 0.);\n    // Last flow\n    if(even){pos=flow1(pos, -tt);}else{pos = flow2(pos, -tt);};\n    \n    // Iterations\n    while(n>0.)\n        {\n        if(even){pos = flow2(pos, -1.);}\n        else{pos = flow1(pos, -1.);}\n        even = !even;\n        n -= 1.;\n        };\n    }\n    return pos;\n}\n\n\n// Matrice de rotation autour de l'axe Y\nmat3 rotationY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\n// Matrice de rotation autour de l'axe X\nmat3 rotationX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n\n\nvec3 sdfRectangle(vec2 uv, float width, float height, vec2 center, vec3 color) {\n    float x = uv.x - center.x;\n    float y = uv.y - center.y;\n    float d = max(abs(x)-width, abs(y)-height);\n    \n    //return d > 0. ? vec3(0.) : vec3(1., 0., 0.);\n    return d > 0. ? vec3(0.) : color;\n}\n\nvec3 sdfSquare(vec2 uv, float size, vec2 center, vec3 color)\n{return sdfRectangle(uv, size, size, center, color);}\n\n// Two squares\nvec4 initialImage1(vec2 pos)\n{\nvec4 square1 = vec4(sdfSquare(pos, 0.25, vec2(0.25, 0.25), red), 0.);\nvec4 square2 = vec4(sdfSquare(pos, 0.25, vec2(0.75, 0.75), red), 0.);\nreturn square1 + square2;\n}\n\n// Chessboard\n#define width 10.\nvec4 initialImage1b(vec2 pos)\n{\nbool test1 = (mod(pos.x*width, 1.)<=0.5) && (mod(pos.y*width, 1.)<=0.5); \nbool test2 = (mod(pos.x*width, 1.)>=0.5) && (mod(pos.y*width, 1.)>=0.5); \nif(test1 || test2){return vec4(1.,0.,0., 0.);}\nelse{return vec4(0.);}\n}\n\n\n// Horizontal curve\nvec4 horizontalCurve(vec2 pos, float width_, vec3 color)\n{\nvec4 curve = vec4(sdfRectangle(pos, 1., width_, vec2(0.5, 0.75), color), 0.);\nreturn curve;\n}\n\n\n// Vertical curve\nvec4 verticalCurve(vec2 pos, float width_, vec3 color)\n{\nvec4 curve = vec4(sdfRectangle(pos, width_, 1., vec2(0.75, 0.), color), 0.);\nreturn curve;\n}\n\n// Initial image\nvec4 initialImage(vec2 pos)\n{\n//vec4 image = initialImage1b(pos);\nvec4 image = horizontalCurve(pos, iteratedCurveWidth, red);\nreturn (image.x <= 0.01)&&(image.y <= 0.01)&&(image.z <= 0.01) ?\nvec4(grey, 0.) : image;\n}\n\n","name":"Common","description":"","type":"common"}]}