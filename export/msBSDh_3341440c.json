{"ver":"0.1","info":{"id":"msBSDh","date":"1671800958","viewed":161,"name":"Coriolis FPS","username":"Amirk","description":"The floor is rotating! Walk and feel how the Coriolis \"force\" makes you walk in circles. Luckily, you have friction in your feet so you do not get repelled by centrifugal force. You can shoot a light orb which \"feels centrifugal forces\" too.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["coriolis","rotatingframe","centrifugal","referenceframe","inertialframe"],"hasliked":0,"parentid":"7sKBzz","parentname":"Relativistic Space Drive"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMove with arrow keys (or WASD).\nShoot a an orb with SPACE bar.\n\nA lot of vec4's could be ordinary vec3's. \nI adjusted this from a relativistic raymarcher where fourvectors were necessary.\n*/\n\n#define MAX_ITER 500.\n#define MAX_DIST 20.\n#define SURF .0001\n\n\nvec4 fourvel = vec4(0,0,0,1);\nvec4 position =vec4(0);\nvec4 boost=vec4(0,0,0,0);\nvec3 orientation=vec3(1,0,0);\n\n\nvec3 SIZE= vec3(.1); \n\n//retardation effect ON/OFF:\nbool RETARD = false ;\n//ray origin in the moving coords.\nvec4 RO, rd;\nvec2 m;\nmat4 TransformMatrix;\nfloat fireOn=0.;\n\nvec3 col = vec3(0);\nfloat vv;\n\nfloat halo=0.;\n\n\nvec3 color( float s){\n    return vec3(1) - vec3(1.,1.,0)*smoothstep(.0,1., s)-\n            vec3(0.,.6,.6)*smoothstep(0.,1., -s);\n}\n\nvoid updateVel(){\n    // Fetch the fourvelocity from the Buffer A\n    boost= texelFetch( iChannel0, ivec2(0,5), 0);\n    orientation=texelFetch( iChannel0, ivec2(0,6), 0).xyz;\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n    \n    fireOn=texelFetch(iChannel3, ivec2(32, 0), 0).x;\n}\n\nvoid updatePos(){\n    // Fetch the fourposition from the Buffer B\n    \n    position =texelFetch( iChannel0, ivec2(0,1), 0 )+vec4(0,0,.1,t);\n  \n}\n\nvec4 getObjectPos(float time){\n    vec4 pos=texelFetch( iChannel0, ivec2(1,1), 0);\n    if(pos.w==1.)//pos.w is an indicator of having released the orb\n        return pos +vec4(0,0,.1,t);\n    else return vec4(1000);    \n\n}\n\n/*\nfloat sdAxes(vec4 p , float rad){\n\n    p.xyz=fract(p.xyz)-.5; //this creates the grid of reference cubes    \n    return  min(length(p.yz)-rad,length(p.xy)-rad); //length(p.xyz)-rad;  \n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float outer= min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - (h+vec2(-.05,.05));\n    float inner= min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    return max(outer,-inner);\n}\n*/\n\n\n\nfloat sdObject(vec4 p){\n    \n    vec4 center= getObjectPos(p.w);\n    \n    float radius= .01;\n    \n    vec3 displ=p.xyz-center.xyz;\n        \n    float dist=length(displ)-radius;\n    \n    halo+=.001/(dist*dist);\n    \n    return dist;  \n}\n\n\n\nfloat sdFloor(vec4 p){\n    return abs(p.y+.004*abs(texture(iChannel2,p.xz).r)+.35);\n    \n}\n\n\nfloat sdPole(vec4 q){\n\n    return length(q.xz)-.04;\n}\n\nfloat getDist(vec4 q){\n    float dist= sdFloor(q); //sdAxes(q,.05);\n    \n    dist= min(dist, sdPole(q));\n    dist= min(dist, sdObject(q));\n   // dist= min(dist, sdGun(q));\n\n    return dist;\n    \n}\n\n\n\nint getMaterial(vec4 p){    \n    \n      if(sdObject(p)<.0005){ col=vec3(.3,.1,.3); return 1;}\n      else if(sdPole(p)<.0005){ col=vec3(.05); return 2;}\n      else{\n          p.xz=fract(p.xz*2.)-.5;\n          col= vec3(.5)*texture(iChannel2,p.xz).r;\n          \n          return 3;\n      }\n   \n}\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n\n    //the w-component determines how we look into past/future/present.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\n\n\nmat4 getTransform(){\n    \n    return Galilei(-fourvel.xyz);\n}\n\n\n\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\n\n\n\nfloat dfRocketBody(vec3 p)\n{\n        \n    vec3 p2 = p;\n   \n    angularRepeat(PI*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, (rot(PI*-.125)*( p2.xz+vec2(-.7,0))).y);\n    d = max(d, (rot(PI*-.25*.75)*(p2.xz+vec2(-0.95,0))).y);\n    d = max(d, (rot(PI*-.125*.5)*( p2.xz+vec2(-0.4,0))).y);\n    d = max(d, (rot(PI*.125*.25)*( p2.xz+vec2(+0.2,0))).y);\n    d = max(d, (rot(PI*.125*.8)*( p2.xz+vec2(.5,0))).y);\n    \n    d = max(d,-.8-p.x);\n    \n    d -= .5;\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p)\n{\n    \n    p.yz*=rot(t*(1.+100.*fireOn));\n    vec3 pFins = p;\n    angularRepeat(PI*.25,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.2)*.9 ,.0,.0);\n    pFins.xz*=rot(-PI*.25);\n    float scale = .8-pFins.z*.1;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat Jet(vec3 p)\n{\n    float d= length(p.yz);\n    if(p.x>0.2)d=20.;\n    \n    return d-p.x*.05;\n}\n\nfloat df(vec3 p)\n{           \n    \n    p.xz*=rot(PI);\n    p.xy*=rot(fireOn*(.2+ .05*sin(1000.*t)) );\n\n        \n    float proxy = mBox(p,vec3(4.5,.8,.8));\n    if (proxy>1.)\n    \treturn proxy;\n    float dRocketBody=   dfRocketBody(p);\n    float dRocketFins=   dfRocketFins(p);\n    float dJet=  Jet(p);\n        \n    return min(dRocketBody,dRocketFins);\n}\n\nvec3 nf(vec3 p)\n{\n    \n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx),df(p+e.xyx),df(p+e.xxy)));\n}\n\n\nvoid rocket (inout vec3 color, in vec3 pos, in vec3 dir) {\n    \n        \n    float dist,tdist = .0;\n    \n    for (int i=0; i<100; i++)\n    {\n     \tdist  = df(pos);\n       \tpos  += dist*dir;\n        tdist+=dist;\n        if (dist<0.00001||dist>7.0)break;\n    }\n    \n    vec3 normal = nf(pos);\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    \n    \n    pos.xz*=rot(PI);\n       \n        \n    vec3 materialColor = vec3(0);\n    vec3 blueColor = vec3(.1,.4,.9);\n    \n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos);\n    float dRocket = min(dRocketBody, dRocketFins);\n       \n    \n    float r = dot(pos.yz,pos.yz);\n   \n    \n    if (dRocketBody<dRocketFins)\n    {\n    \n        if (pos.x<-.85)\n            if (pos.x<-1.2)\n                materialColor = blueColor + vec3(0.03 / r);\n            else\n                materialColor = vec3(.7,.1,.7);\n            else\n            {\n                if (pos.x>1.0)\n                    materialColor = vec3 (.7,.1,.7) ;\n                else\n                    materialColor = vec3(.6);\n            }\n    }\n    else\n    {\n        materialColor = vec3(.7,.1,.7);\n        if (length (pos - 0.1 * vec3(0.0, normal.yz)) > length (pos)) { \n\n            materialColor -= vec3(.9,.3,1.5) * min(0.2, pos.x + 1.3) / r;\n        }\n    }   \n    \n    if (dist<.1){\n    float dif=dot(normal, vec3(-4,4,4))*.3;\n    color = ao*materialColor*dif;\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(sign(iMouse.z)<1.)\n         m = vec2(0);\n    else{\n        m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    } \n    \n    updateVel();\n    //coordinate transform:  \n    //TransformMatrix=getTransform();\n    updatePos();\n    \n    //ray's spacetime origin represented in \"stationary coordinates\":\n    RO=position;\n    float zoom= 1.;\n    \n    \n    orientation.y+=m.y*PI;\n    orientation.xz*=rot(-(m.x)*PI);\n        \n    \n    \n    vec4 lookAt;\n    if(RETARD) //what we actually see as light reaches our eyes:\n        lookAt = vec4(normalize(orientation), -1);\n    else //the \"instantaneous geometry\" of spacetime/coordinates: \n        lookAt = vec4(normalize(orientation), 0);\n        \n    \n      \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n   \n    \n    //ray direction from moving coords to stationary coords:\n    rd= ray;//*TransformMatrix; \n    \n    //adding the rocket on top\n    vec3 r_color = vec3 (0);\n    vec3 cam=vec3(-3 ,1.5,.5 ); \n    \n   // cam.xz*=rot(atan(orientation.z,orientation.x)); \n\n    rocket (r_color, cam, getRayDir(uv, vec4(1,0,0,0), zoom).xyz);\n    \n    if (length (r_color) > 0.0) {\n        fragColor.xyz = r_color;\n    }else{ \n    \n   \n    \n    //RAYMARCH IN SPACETIME calculated in stationary coordinates:\n    vec4 p=RO;          \n    \n    float d= RayMarch(p, rd, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*rd;\n          \n          int mat=getMaterial(p);\n\n          vec3 n= getNormal(p);\n          rd.xyz= reflect(rd.xyz,n);\n          float fresnel= pow(1.+ dot(n, rd.xyz),5.);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.3+.5;\n          col/=d*.1;\n          col*=dif*dif; \n          if(mat==3){\n              rd.xz*=rot(-t*length(omega));\n              col=mix(col,texture(iChannel1, rd.xyz).rgb,.3*fresnel);\n              }\n          else if(mat==2){\n              p=p+rd*SURF*5.;\n              float d2= RayMarch(p,rd,1.);\n              if(d2<MAX_DIST){\n                  p= p+ d2*rd;\n          \n                  int mat=getMaterial(p);\n                  vec3 n= vec3(0,-1,0);\n\n                  float dif= dot(n, normalize(vec3(-3,2,1)))*.3+.5;\n                  col/=(d2+d)*.1;\n                  col*=dif*dif;\n                  }\n                  else{\n                      rd.xz*=rot(-t*length(omega));\n                      col=.5*texture(iChannel1, rd.xyz).rgb;\n                  }\n          }\n      \n    }else{\n        rd.xz*=rot(-t*length(omega));\n        col=.5*texture(iChannel1,rd.xyz).rgb;\n    \n    }    \n\n    fragColor = vec4(col,1.0)+halo*halo*vec4(.4,.2,1,1);\n    \n   }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst vec3 omega= vec3(0,1,0);\n\n//t is the proper time in rockets moving frame \n#define t float(iFrame)*dt\n#define PI 3.14159265359\n\nconst float c=5.;\n\nconst float dt = .002; //stepsize \n\n\nmat4 Galilei(vec3 v){\n\n    return transpose(mat4(1.,     0  ,      0,      0,\n                 0,     1. ,      0,      0,\n                 0,     0 ,      1.,       0,\n                 -v.x, -v.y,  -v.z,       1)); \n                 \n                 /* float beta= length(v)/c;\n     float gamma = pow(1.-beta*beta,-.5);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n                 (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c,   gamma);  \n                 */\n}\n\nmat4 RotGenerator(vec3 axis){\n\n    return transpose(mat4(0 ,  -axis.z, axis.y,  0,\n                 axis.z     ,  0,  - axis.x,  0, \n                 -axis.y,   axis.x,  0,  0, \n                 0     ,  0,      0,  0 ));\n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec3 pal( in float x, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*x+d) );\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\nconst int KEY_SPACE  = 32;\n\nvec2 m;\n\n\n\nvec3 handleKeyboard() { \n\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    vec3 acceleration=(left + up + right + down);\n    \n    return acceleration*10.;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   if(sign(iMouse.z)<1.)\n         m = vec2(0);\n    else{\n        m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    } \n                                           \n    if(iFrame<10){\n            fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n\n            if(ivec2(fragCoord)==ivec2(0,0)){                 \n                 fragColor= vec4(0,0,0,1);          \n            }else if(ivec2(fragCoord)==ivec2(0,1)){\n            fragColor= vec4(0,0,0,1);\n            }\n            else if(ivec2(fragCoord)==ivec2(0,5)){\n            fragColor= vec4(0);\n            }else if(ivec2(fragCoord)==ivec2(0,6)){\n            fragColor= vec4(1,0,0,0);\n            }\n                      \n        }\n    else{\n        \n        if(int(fragCoord.x)==0){\n             //coordinates of the boost are in rockect coordinates\n            vec3  boost=vec3(0);\n            vec3 orientation=vec3(-1,0,0);\n\n            boost += handleKeyboard();      \n\n            orientation = texelFetch(iChannel0, ivec2(0, 6), 0).rgb;\n\n            boost.xz*=rot(atan(orientation.z,orientation.x)); \n\n            vec4 position = texelFetch(iChannel0, ivec2(0,1), 0);\n\n            vec4 fourvel=texelFetch(iChannel0, ivec2(0), 0);\n            vec3 vel=fourvel.xyz;     \n\n            //add coriolis contribution:       \n           // boost+= -2.*cross(omega,vel)-cross(omega,cross(omega,position.xyz));\n            boost+= -2.*cross(omega,vel);\n\n            vel+=boost*dt;\n\n            vel*=.99;\n\n\n            position.xyz+=vel*dt;\n\n            //orientation is for the rockets alignment\n            orientation =normalize(orientation+(vel-orientation)*.05);\n\n\n            fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n\n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 fragColor= vec4(vel,0);          \n            }else if(ivec2(fragCoord)==ivec2(0,1)){\n                fragColor= position;\n            }\n            else if(ivec2(fragCoord)==ivec2(0,5)){\n                fragColor= vec4(boost,floor(length(boost)));\n            }else if(ivec2(fragCoord)==ivec2(0,6))\n                 fragColor= vec4(orientation,0);\n\n        }\n        else if(int(fragCoord.x)==1){\n        \n            vec4 bulletPos = texelFetch(iChannel0, ivec2(1,1), 0);\n\n            vec4 bulletVel=texelFetch(iChannel0, ivec2(1,0), 0);\n            \n            //add coriolis contribution:       \n           // boost+= -2.*cross(omega,vel)-cross(omega,cross(omega,position.xyz));\n            vec3 boost = -2.*cross(omega,bulletVel.xyz)-cross(omega,cross(omega,bulletPos.xyz));\n\n            bulletVel.xyz +=boost*dt;\n\n            bulletPos.xyz+=bulletVel.xyz*dt;\n\n            if(texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x >0.){\n                vec4 orientation=texelFetch(iChannel0, ivec2(0,6), 0);\n                orientation.xy*=rot((m.y)*PI);\n                orientation.xz*=rot(-(m.x)*PI);\n                \n\n                if(ivec2(fragCoord)==ivec2(1,0)){\n                    vec4 vel=texelFetch(iChannel0, ivec2(0,0), 0)+orientation;\n                    fragColor= vel;          \n                }else if(ivec2(fragCoord)==ivec2(1,1)){\n                    vec4 pos=texelFetch(iChannel0, ivec2(0,1), 0)+.2*orientation;\n                    fragColor= pos;\n                }\n            }else{  \n                if(ivec2(fragCoord)==ivec2(1,0)){\n                     fragColor= bulletVel;          \n                }else if(ivec2(fragCoord)==ivec2(1,1)){\n                    fragColor= bulletPos;\n                }    \n            }                        \n            \n        }\n        \n     }\n}","name":"Buffer A","description":"","type":"buffer"}]}