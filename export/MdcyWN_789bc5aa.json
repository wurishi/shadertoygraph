{"ver":"0.1","info":{"id":"MdcyWN","date":"1518866742","viewed":381,"name":"Volumetric_2","username":"balkhan","description":" This started out as something completely different. ","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FUDGE .25\n\nvec3\tcam(vec2 u);\nvoid\tscene(vec3 p);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nvoid rotate(inout vec2 v, float angle);\n\nfloat\ttnear, tfar, step_dist;\nvec3\th;\nvec3 _ColorOne = vec3(.5, .82, .7);\nvec3 _ColorTwo = vec3(.15, .72, .7);\n\nstruct Ray\n{\n\tvec3\to;\n\tvec3\td;\n};\n\nbool\tIntersect_Cylinder(Ray r, out float tnear,\nout float tfar)\n{\n    bool hit;\n    hit = false;\n    vec3 v = vec3(+1.,0.,0.); //objdir, only need to define it on one axis, it simplifie the caps finding\n    vec3 va = r.d - dot(r.d, v) * v;\n\tvec3 pp = r.o ; //objpos\n    vec3 vc = pp - dot(pp, v) * v;\n\tfloat aa = dot(va, va);\n\tfloat bb = -2.0f * dot(va, vc);\n    float rad = 1.;\n\tfloat cc = dot(vc, vc) - rad * rad;\n\tcc = bb * bb - 4.0f * aa * cc;\n\tif (cc < 0.0f)\n    {\n        return hit = false;\n    }\n\tcc = sqrt(cc);\n\ttnear = min((bb + cc) / (2.0f * aa), (bb - cc) / (2.0f * aa));\n    tfar = max((bb + cc) / (2.0f * aa), (bb - cc) / (2.0f * aa));\n    \n\t// check for hit\n\tif ((tnear > tfar) || ( (r.d.x)*tnear > 1.06125 ) )\n\t\thit = false;\n\telse if ( tfar*(r.d.x) > 1.)\n\t\thit = true;\n    if ( (r.d.x)*tnear == 1.06125 || (r.d.x)*tfar == 1. ) // caps of the cylinder\n\t    hit == true;\n\treturn hit;\n}\n\n// taken from : https://www.shadertoy.com/view/4lscW8\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\n/*\n**\tLeon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define\tPI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n**\tend mod polar\n*/\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    h = vec3(0.);\n\tvec2 R = iResolution.xy, u = (f.xy-R.xy*.5) / R.yy;\n    o = vec4(0.);\n    vec3\tpos = vec3(9.0,-.0,-3.*exp(-iTime));\n    vec3\tcm = cameraLookAt(vec3(10.0,.0,.0), pos, vec3(.0,1.,.0), u, 1.);\n    vec2\tdist = vec2(0.);\n    vec3\tp;\n    float\tii = 0.;\n    Ray eyeray;\n    eyeray.o = pos;\n    eyeray.d = cm;\n    bool hit = Intersect_Cylinder(eyeray, tnear, tfar );\n    vec3\tpnear = eyeray.o + tnear * eyeray.d;\n\tvec3\tpfar  = eyeray.o + tfar  * eyeray.d;\n    eyeray.d = normalize(pfar-pnear);\n\teyeray.o += tnear * eyeray.d;\n    \n    if (hit == true)\n    {\n\t    for (float i = 0.; i < 400.; i++)\n\t    {\n\t        p = dist.y * eyeray.d + eyeray.o;\n\t    \tdist.x = step_dist + sin(iTime*.125)*.5/abs(tnear-tfar);\n            scene(p);\n\t        dist.y += dist.x * FUDGE;\n\t    }\n    }\n    o.w = 1.;\n\to.xyz = vec3(.25, .25, .5+.25*floor(sin(u.x*50.)*cos(u.y*50.) ) ); // background checker\n    if (true == hit) // disable this condition to have the background in transparency\n        o.xyz = vec3(0.);\n    o.xyz += h*((hit == false) ? .0 : 1.);\n    o = mix(o, 1.-o, 0.5+sin(iTime*.25)*.5);\n    o = o * o * (3. - 2. * o); // contrast++\n}\n\nvoid\tscene(vec3 ap)\n{\n    ap.x += 3.+iTime*10.;\n    ap.y += sin(iTime*.25+ap.x*.01)*sin(iTime*-.5+( (ap.x*10.)/10.)*.125)*6.;\n    ap.z += sin(iTime*.25+ap.x*.01)*cos(iTime*-.5+( (ap.x*10.)/10.)*.125)*6.;\n    float\tdensity = \n\t\t-\n\t\t(\n\t\t\t-length(length( (length(ap.zy)-1.)-2.)-6.)*1.1+\n\t\t\t+\n            1.\n            *\n            (\n            .25*length(texture(iChannel0, (ap*.125)+vec3(-iTime*.05,.0,.0)  ).xyz)\n            +\n            .5*length(texture(iChannel0, (ap*.0625)+vec3(-iTime*.05,.0,.0)  ).xyz)\n            +\n            .75*length(texture(iChannel0, (ap*.03)+vec3(-iTime*.05,.0,.0)  ).xyz)\n            )\n\t\t)\n        ;\n    float\td = min(abs(density)*.3+.0, 5.0);\n    step_dist = d;\n    // Can't remember where I took the base formula\n    float\tT = .125;\n    {\n        float\tbrightness = exp(.3*d);\n\t\th.xyz +=\n\t\t\t\t1./400.-\n            \t(1./400. )*(1./max(.0001251,density*density+.000051/max(.0001, d*d) ) )\n                *\n\t\t\t\tvec3(mix(_ColorOne.xyz, 1.-_ColorTwo.xyz, clamp(density, -1., 1.)) )\n\t\t\t\t*\n\t\t\t\tT\n\t\t\t\t*\n\t\t\t\tbrightness;\n    }\n}\n\nvec3\tcam(vec2 u)\n{\n    vec3\tret;\n    \n    vec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n    ret = normalize(forw * 1. + right * u.x + up * u.y);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max( ret, abs(p.z)+.5*abs(p.x) );\n    return ret;\n}\n","name":"Image","description":"","type":"image"}]}