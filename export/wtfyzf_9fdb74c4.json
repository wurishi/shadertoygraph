{"ver":"0.1","info":{"id":"wtfyzf","date":"1593609568","viewed":244,"name":"Isles","username":"yonatan","description":"Noiseless, 1/2 octave stepped fbm worked out better than I expected.\n\nOriginally written for https://pagedout.institute/","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// feel free to reuse\n\nmat2 rot2d(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));} // Angle => 2D rotation matrix\n\nfloat terrain_height(vec2 position) { // https://iquilezles.org/articles/fbm\n  float height=0., amplitude=.8, n;\n  for(int i = 0; i < 20; i++) { // Sum up 20 layers\n    n = sin(position.x) * cos(position.y); n = n * n * n; // Simple base pattern, no noise\n    height += n * amplitude; // Accumulate value at current amplitude\n    position *= rot2d(float(i*i)); // Rotate (phase-shift?) by a hash of the current iteration\n    position *= 1.4; // Scale (increase frequency by ~1/2 an octave)\n    amplitude *= .66; // Reduce amplitude\n  }\n  return height;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime*.1;\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x,iResolution.y);\n  vec3 p, water_tint = vec3(1), ray_origin = vec3(-cos(time*.5)*4.,1.,time), // Camera position\n       ray_direction = normalize(vec3(uv.x, uv.y - .7 + cos(time) * .5, 1.7));\n  ray_direction.xy *= rot2d(sin(time*.5)*.5); // Camera orientation and field of view\n  float distance = 0., ray_length = 0.;\n  for(int i = 0; i < 75; i++) { // Raymarching loop\n    p = ray_origin + ray_direction * ray_length; // Get current ray position\n    if(distance<.1 && p.y<0.) { // If we're close to the surface check p.y for a water hit\n      ray_origin.y = -ray_origin.y; ray_direction.y = -ray_direction.y; // Reflect ray\n      water_tint = vec3(.78, .85, .8); // Make water greener and darker\n    } else { // Not underwater - march\n      distance = p.y-terrain_height(p.xz); // Real distance is hard to calculate so use p's\n                                   // height above the terrain, and since that's obviously\n      ray_length += distance * .6; // wrong - only march .6 of the way and hope for the best.\n    }\n    if(ray_length > 20.) break; // We are far away (in the sky)\n  }\n  vec2 h = vec2(.0001, 0); // From https://iquilezles.org/articles/normalsSDF\n  vec3 surface_normal = normalize(vec3(terrain_height(p.xz-h.xy) - terrain_height(p.xz+h.xy),\n                               2.*h.x, terrain_height(p.xz-h.yx) - terrain_height(p.xz+h.yx)));\n  vec3 terrain_color = vec3(.9, .7, .6) * (surface_normal.z * .5 + .5); // Terrain, backlit\n  vec3 sky_color = mix(vec3(1.2,1.,.9),vec3(.4,.5,.6),abs(ray_direction.y)); // Sunny horizon\n  if(ray_length > 20.) { // Reuse terrain_height() FBM to paint some clouds\n    vec2 cloud_uv = ray_direction.xz / ray_direction.y + time;\n    sky_color *= 1. - min(0., terrain_height(cloud_uv) * ray_direction.y);\n  }\n  vec3 color = mix(terrain_color, sky_color, min(1., ray_length / 20.)); // Mountains-sky fade\n  color *= water_tint; // Water color\n  fragColor = vec4(pow(color, vec3(.4545)), 1); // Gamma correction\n}","name":"Image","description":"","type":"image"}]}