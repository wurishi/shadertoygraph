{"ver":"0.1","info":{"id":"M3SGDc","date":"1711969451","viewed":87,"name":"3D SHADOW LIGHT RAYTRACER","username":"Samuix","description":"animated 3D red sphere, LIGHT SOURCE,  BLUR RAYCASTING, SHADOW CASTING, RAYTRACING, DEPTH FIELD, etc..","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","shadow","light","sphere","animated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\n      vec3\t   cameraPos;\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\n      vec3     spherePos;\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\n      vec3     lightPos;\n\n// Tracing parameters\nconst int      PIXEL_SAMPLING_SIZE      = 20;\nconst int      MAX_NB_BOUNCES           = 5;\nconst int\t   TIME_SAMPLING_SIZE       = 5;\nconst float    TIME_SAMPLING_OFFSET_MAX = 0.075;\n\n//##############################################################################################\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        \n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n        // As we found the value of t, we can insert it into equation (1) to find\n        // the position of the first intersection point encountered along the ray.\n        intersecPt = rayPos + t * rayDir;\n\n        // Then, we can use the property of a sphere that the infinite line along the\n        // normal vector to a point on the sphere is passing through the center of the\n        // sphere.\n        // Then, we need to reverse the vector direction if the intersection point is\n        // seen from inside the sphere.\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    // As we found the value of t, we can insert it into equation (1) to find\n    // the position of the first intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    \n    // NOTE: The normal to be returned has to be pointing 'towards' the rayPos position.\n    //       So, the angle between the ray direction and the normal must > 90°, so the\n    //       dot-product should be negative.\n    //       This can be expressed by taking the 'sign' of den\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    // Compute camera focal length for a height on image plane going in [-1,1] range\n    //\n    //        \n    //                     -1\n    //                  /|  \n    //                 / |\n    //                /  |\n    //               /   |\n    //              /). .|. . . . . . fovY (vertical angle field of view expressed in degrees)\n    //             /  )  |\n    //            +---)--|-----> cz\n    //            |\\  )  |           î\n    //            | \\)   |           |\n    //            v  \\   |           |\n    //           cy   \\  |           | h\n    //                 \\ |           |\n    //                  \\|           |\n    //                     1         v\n    //                         \n    //            <------>\n    //              focal length\n    //\n    //    We have that:\n    //\n    //        tan((2*Pi/180)*cameraFovY/2) = h / focal\n    //    <=> focal = h / tan(radians(cameraFovY/2))\n    //    <=> focal = 1 / tan(radians(cameraFovY/2))\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    // Compute camera three main axis (X,Y,Z) expressed in world space\n    //\n    //  NOTES: - First, we compute the Z camera unit vector that goes from the camera position\n    //           and look toward the camera target.\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n\n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    //         - Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n\n    vec3 cy = normalize(cross( cz, cx));\n\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n\t// We can now find the ray properties:\n    //   - The ray start position is the camera position\n    //   - The ray direction can be decomposed into 3 sub-vectors:\n    //      *            dy = (-pt.y) * cy   because pt vertical axis is going in opposite\n    //                                       direction than cy, and pt.y is in range [-1,1],\n    //                                       which matches the range spanned by vertical\n    //                                       positions (in camera space) on the image plane\n    //                                       located at the focal length distance along cz.\n    //\n    //      * similarly: dx =    pt.x * cx   NOTE: pt.x and horizontal positions (in camera\n    //                                             space) shares the same range (taking into\n    //                                             account the image ratio. Said differently,\n    //                                             image & camera have the same ratio).\n    //      * and:       dz =   focal * cz\n    //\n    //     which brings that: rayDir = pt.x * cx - pt.y * cy + focal * cz\n    //\n    //   - Finally, the ray direction is normalized because it makes it more practical later on.\n\n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n\n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t// Move the surface point a little outward\n    \t\t\t\t\t\t\t\t\t\t// (along its normal) to ensure it is a bit\n    \t\t\t\t\t\t\t\t\t\t// above the surface.\n\n\t// the direction of the ray is just the unit-vector going\n    // from the surface point towards the light source\n    vec3  shadowRayDir   = L;\n    \n    // Now, test all geometry for intersection with the 'shadow' ray\n    //\n    // NOTE: We could optimize a bit the code because here we are not interested in finding\n    //       which object is intersecting.\n    //       We only want to know if there is at least one object along the path, plus if\n    //       the nearest intersection (from the surface point of view) is in-between the\n    //       surface and the light source, because if it is 'after' the source, then the\n    //       surface point is being lit by the light source.\n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 unusedInt, unusedVec1, unusedVec2);\n\n    // It allows to have shadows that are not totally black.\n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n\n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    lightPos  = vec3(8, 10, -12) + vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    cameraPos  = vec3(6,  4, -5);\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n//----------------------------------------------------------------------------------------------\n\nstruct ShadeInfo\n{\n    vec3  shadedCol;\n    float Ks;\n};\n    \n//----------------------------------------------------------------------------------------------\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    \n    int nbBounces = 0;\n    do\n    {\n        // Test ray-objetcs intersections and find the nearest one\n        // (with its associated intersection point and normal at the object surface)\n        int  objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n\n        // We did not hit any object, so we have the sky color (here: black)\n        if (distI <= 0.0)\n        {\n\t        infos[nbBounces].shadedCol = skyCol;\n    \t    infos[nbBounces].Ks        = 0.0;\n            break;\n        }\n\n        // Apply the shading to the points that are on the object surface and seen by the camera\n\n        // unit-vector going from the surface point toward the light and\n        // length of the segment between the two points\n        vec3 L = lightPos - intersecI;\n        float Ldist = length(L);\n        L = L / Ldist;\n\n        // unit-vector of the reflection direction of the light at the surface point\n        vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n\n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n\n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n\n        // Find the factor of light attenuation that results\n        // from the intersection point being visible from the light source or in shadow.\n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n\n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n        vec3 phongCol = computePhongShading(objectCol, objectMat,\n                                            shadowFactor, normalI, L, R, V);\n\n        // Store the information we gathered for that surface point\n        infos[nbBounces].shadedCol = phongCol;\n        infos[nbBounces].Ks        = objectMat.Ks;\n\n        // Avoid looping if the object is not specular at all\n        if (objectMat.Ks == 0.0)\n            break;\n        \n        // Bounce from the surface towards the reflected direction of the ray\n        \n        vec3 Rs = 2.0 * dot(normalI, V) * normalI - V;\t// unit-vector of the reflection direction\n        \t\t\t\t\t\t\t\t\t\t\t\t// of ray at the surface point\n        rayPos = intersecI + 0.0001 * normalI;\n        rayDir = Rs;\n        \n        nbBounces++;\n    }\n    while (nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    for (int i = nbBounces-1 ; i >= 0 ; i--)\n        resCol = infos[i].shadedCol + infos[i].Ks * resCol;\n        \n    return resCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// De facto \"noise\" function, modified to supply two random values each in [0,1] range\n// Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2( vec2 location, vec2 delta )\n{\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location +      delta            , c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        );\n}\n\n//##############################################################################################\n//##############################################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Set the time used for the animation\n    float time = iTime;\n \n    vec3 resCol = vec3(0);\n    for (int i = 0 ; i < PIXEL_SAMPLING_SIZE ; i++)\n    {\n        vec2 uv = fragCoord.xy;\n\n        for (int t = 0 ; t < TIME_SAMPLING_SIZE ; t++)\n\t    {\n            // set a non-constant delta (depending on i) so that each sample has a different noise result\n            vec2 q = vec2(float(i), float(i*t));\n\n            // apply a noise function to get an offset in [-0.5,0.5] range for u & v coordinates, and [0,1] for time\n            // Add a depency on the time sampling index to the noise in order to have a different noise for each pixel sample\n            vec2 n = noise2( fragCoord.xy + vec2(t) , q );\n\n            if (PIXEL_SAMPLING_SIZE > 1)\n            {\n                vec2 offset = vec2(n.x, n.y) - vec2(0.5, 0.5);\n\n                uv += offset;\n            }\n        \n\t        if (TIME_SAMPLING_SIZE <= 1)\n    \t        n.x = 0.;\n        \n    \t    // Animate scene objects\n        \tAnimateScene(time - TIME_SAMPLING_OFFSET_MAX * n.x);\n\n            resCol += RaytraceAtPixelCoord(uv);\n        }\n    }\n    \n    resCol /= float(PIXEL_SAMPLING_SIZE*TIME_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol, 1);\n}","name":"Image","description":"","type":"image"}]}