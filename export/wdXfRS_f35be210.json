{"ver":"0.1","info":{"id":"wdXfRS","date":"1589195782","viewed":417,"name":"atmosphere single scattering","username":"w450468524","description":"Atmosphere single scattering effect in alien world maybe\nmouse to rotate camera","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(col.xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float MAX = 1000000000.0;\n\nvec2 rayIntersectSphere( vec3 eye, vec3 dir, float r ) {\n\tfloat b = dot(eye, dir);\n    float ac = dot(eye, eye) - r * r;\n    float delta = b * b - ac;\n    if(delta < 0.0)\n        return vec2(MAX, -MAX);\n    delta = sqrt(delta);\n    return vec2(-b - delta, -b + delta);\n}\n\n/////////////////////////////////////\n// generate ray of a fragment\nconst float PI = 3.1415926535897932;\nconst float fov = PI / 2.0;\nconst float near = 1000.0;\n\n//////////////////////////////////////\n// Rayleigh phase function\nconst float rayleighConstant = 0.05968310365946075091333141126469; // 3/(16*PI)\nfloat phaseRayleigh(float cosViewLight)\n{\n    return (1.0 + cosViewLight * cosViewLight) * rayleighConstant;\n}\n\n//////////////////////////////////////\n// Mie phase function\nfloat phaseMie(float cosViewLight, float g)\n{\n    float cc = cosViewLight * cosViewLight;\n    float gg = g * g;\n    float mieConstant = 3.0 *(1.0 - gg)/(8.0*PI*(2.0 + gg));\n    return mieConstant* (1.0 + cc) / pow((1.0 + gg - 2.0 * g*cosViewLight), 1.5);\n}\n\n/////////////////////////////////////////////////////////////////////\n// all these factors should be adjust together to get correct effects\nconst float g_earthRadius=100.0;\nconst float g_atmosphereRadius = g_earthRadius + 100.0;\n\n// scattering coefficients\nconst vec3 betaMie = vec3(21.0);\n// const vec3 betaRayleigh = vec3(3.8, 13.5, 33.1);\nconst vec3 betaRayleigh = vec3(13.8, 1.5, 2.1);\nconst float Hr = 3.0;\nconst float Hm = 0.5;\n\nconst float sunIntensity = 10.0;\nvec3 sunDir = normalize(vec3(0.0, 1.0, 0.3));\n\nvec3 scatteringFactor(vec3 p, float H, vec3 beta0)\n{\n    return exp(-(length(p) - g_earthRadius)/H) * beta0;\n}\n\nconst int opticalSampleNumber = 8;\n\nvec3 opticalDepth(vec3 nearPos, vec3 farPos, float H)\n{\n    float sum = 0.0;\n    vec3 deltaDir = (farPos - nearPos) / float(opticalSampleNumber);\n    vec3 p = nearPos;\n    for (int i =0; i < opticalSampleNumber; i++)\n    {\n        float height = length(p) - g_earthRadius;\n        if(height < 0.0)\n            return vec3(-1.0);\n        sum = sum + exp(-(height)/H);\n        p += deltaDir;\n    }\n\n    return vec3(sum) * length(deltaDir);\n}\n\nconst int maxStepNumber = 64;\nvec4 integration(vec3 posNear, vec3 posFar, vec3 dir)\n{\n    float cosViewLight = dot(dir, sunDir);\n    \n    vec3 ret = vec3(0.0);\n    vec3 deltaDir = (posFar - posNear)/float(maxStepNumber);\n    \n    float sampleDist = length(posNear - posFar) / float(maxStepNumber);\n    vec3 p = posNear;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    \n    float densityR = 0.0;\n    float densityM = 0.0;\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    \n    for(int i = 0; i < maxStepNumber; i++)\n    {\n        float height = length(p) - g_earthRadius;\n        if(height < 0.0)\n            break;\n        densityR = exp(-height/Hr)* sampleDist;\n        densityM = exp(-height/Hm)* sampleDist;\n        opticalDepthR += densityR;\n        opticalDepthM += densityM;\n        \n        vec2 intersect = rayIntersectSphere(p, sunDir, g_atmosphereRadius);\n\n        vec3 lightPosNear = p;\n        vec3 lightPosFar = p + sunDir * intersect.y;\n        \n        float sum = 0.0;\n        vec3 opticalLightDepthR = vec3(0.0);\n        vec3 opticalLightDepthM = vec3(0.0);\n        \n        vec3 deltaLightDir = (lightPosFar - lightPosNear) / float(opticalSampleNumber);\n        float lightStepLength = length(deltaLightDir);\n        \n        vec3 lightPos = lightPosNear;\n        int j =0;\n        \n        // accumulate attenuation\n        for (; j < opticalSampleNumber; j++)\n        {\n            float height = length(lightPos) - g_earthRadius;\n            opticalLightDepthM = opticalLightDepthM + exp(-(height)/Hm) * lightStepLength;\n            opticalLightDepthR = opticalLightDepthR + exp(-(height)/Hr) * lightStepLength;\n            lightPos += deltaLightDir;\n        }\n        vec3 odR = opticalLightDepthR + opticalDepthR;\n        vec3 odM = opticalLightDepthM + opticalDepthM;\n        vec3 att = odR * betaRayleigh + 1.1 * odM * betaMie;\n\n        sumR += exp(-att) * densityR;\n        sumM += exp(-att) * densityM;\n        p += deltaDir;\n    }\n    \n    // multiply attenuation with phase and scattering coefficients\n    ret = sumR * phaseRayleigh(cosViewLight) * betaRayleigh + sumM * phaseMie(cosViewLight, 0.78) * betaMie * 1.1;\n    \n    return vec4(ret * sunIntensity * vec3(1.0, 0.9, 0.9), 1.0);\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float viewMode = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    if (texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r != 0.0)\n    {\n        if (viewMode == 0.0)\n            viewMode = 1.0;\n        else\n            viewMode = 0.0;\n    }\n    \n    float angle = (iTime * 0.5) * PI;\n    \n    sunDir = normalize(vec3(cos(angle), 0, sin(angle)));\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0;\n    if (iMouse.xy==vec2(0))\n        mouse = vec2(1.1, 1.2);\n    float cosPhi = cos(mouse.y * 0.5 * PI);\n    float sinPhi = sin(mouse.y * 0.5 * PI);\n    float cameraDist = g_earthRadius * 1.5;\n    vec3 camPos = vec3(sinPhi * cos(mouse.x * PI), cosPhi, sinPhi * sin(mouse.x * PI)) * cameraDist;\n    vec3 front = normalize(vec3(0, 0, 0) - camPos);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    // restore aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(uv.x * right + uv.y * up + front);\n    vec3 eye = camPos;\n    \n    vec2 resOutter = rayIntersectSphere(eye, rayDir, g_atmosphereRadius);\n    if (resOutter.x > resOutter.y)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    vec2 resInner = rayIntersectSphere(eye, rayDir, g_earthRadius);\n    \n    //float value = 0.0;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    float nearDist = max(resOutter.x, 0.0);\n    float farDist = min(resOutter.y, resInner.x);\n\n    if(resInner.x <= resInner.y && resInner.x >= 0.0)\n        farDist = resInner.x;\n    //value = farDist - nearDist;\n    color = integration(eye + rayDir * nearDist, eye + rayDir * farDist, rayDir);\n    \n    fragColor = vec4(pow(color.xyz, vec3(1.0/2.2)), viewMode);\n}","name":"Buffer A","description":"","type":"buffer"}]}