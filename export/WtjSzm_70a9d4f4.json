{"ver":"0.1","info":{"id":"WtjSzm","date":"1565431283","viewed":603,"name":"Bayer maxtrix dithering explorer","username":"104","description":"More explorations of ordered dithering. Notice that little is achieved by increasing the bayer matrix past 8x8.","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["orderedbayerdithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat load(int i) {\n    return texelFetch(iChannel1, ivec2(i,0), 0).x;\n}\nfloat tobw(float a) {\n    return step(.6,a);\n}\n// Generic algorithm to desaturate images used in most game engines\nfloat togray(vec3 color)\n{\n\treturn dot(vec3(0.299, 0.587, 0.114), color);\n}\n\n// generate a nice pattern with low & high freqs.\nfloat tex(vec2 p, vec2 R) {\n    float chan = load(0);\n    if (chan == 0.) {\n        // a 2D gradient.\n        float ret = pow(clamp(p.x,0.,1.) * p.y,.5);\n        return ret;\n    }\n    if (chan == 1.) {\n        // another gradient\n        float ret = pow(clamp(p.x,0.,1.) * p.y * (sin(length(p)*9.)*.5+.5),.5);\n        return ret;\n    }\n    if (chan == 2.) {\n        // hard objects on soft gradient.\n        float ret = clamp(p.x,0.,1.) * p.y * .5;\n        p.x *= 2.;\n        vec2 p1 =-abs(p-.5)+.15;\n        float sq1 = sign(p1.x+p1.y);\n        vec2 p2 =-abs(p-.5)+.1;\n        sq1 -= sign(p2.x+p2.y);\n        ret = max(sq1,ret);\n        \n        sq1 = -sign(length(p-vec2(1.4,.5))-.3);\n        float sq2 = sign(length(p-vec2(1.4,.5))-.2);\n        ret = max(sq1+sq2,ret);\n        \n        return clamp(ret,0.,1.);\n    }\n    if (chan == 3.) {\n        // a soft circle.\n        p -= .5;\n        return 1.-smoothstep(.0,.2,length(p)-.1);\n    }\n    if (chan == 5.) {\n        // a real video.\n        return togray(texture(iChannel2, p).rgb);\n    }\n    \n    // an animation with both high freq & low freq content.\n    float t = iTime*.05;\n    p.x *= R.x / R.y;\n    p*=.5;\n\n    p.x += t;\n    p.y += t*.333;\n    \n    float ret = (sin(p.x * 20.) * .5 + .5) + (sin(p.y * 20.) * .5 + .5);\n    ret /= 2.;\n    \n    float span = .5;\n    vec2 c = mod(p, span) - span*.5;\n    ret = max(ret, 1.-step(.0, length(c)-span*.3));\n\n    span *= .7;\n    c = mod(p - vec2(0,t), span) - span*.5;\n    ret = min(ret, step(.0,length(c)-span*.3));\n    return ret;\n}\n\nvoid gray( out vec4 o, in vec2 fragCoord, vec2 R )\n{\n    o = vec4(tex(fragCoord.xy / R.xy, R));\n}\n\nvoid nodither( out vec4 o, in vec2 fragCoord, vec2 R )\n{\n    o = vec4(tobw(tex(fragCoord.xy / R.xy, R)));\n}\n\nvoid bayer1(out vec4 o, in vec2 fragCoord, vec2 R) {\n    const int dim = 2;\n    const float kern[dim*dim] = float[dim*dim]\n(0.,   0.5, 0.75, 0.25);    \n    ivec2 idx = ivec2(fragCoord)% dim;\n\n    float a = tex(fragCoord/R, R);\n    a += kern[idx.x + (idx.y * dim)]-.5;\n    float b = tobw(a);\n    o = vec4(b);\n}\n\nvoid bayer2(out vec4 o, in vec2 fragCoord, vec2 R) {\n    const int dim = 4;\n    const float kern[dim*dim] = float[dim*dim]\n        (0.     ,0.5    ,0.125  ,0.625,\n 0.75   ,0.25   ,0.875  ,0.375,\n 0.1875 ,0.6875 ,0.0625 ,0.5625,\n 0.9375 ,0.4375 ,0.8125 ,0.3125);\n    \n    ivec2 idx = ivec2(fragCoord)% dim;\n\n    float a = tex(fragCoord/R, R);\n    a += kern[idx.x + (idx.y * dim)]-.5;\n    float b = tobw(a);\n    o = vec4(b);\n}\nvoid bayer4(out vec4 o, in vec2 fragCoord, vec2 R) {\n    const int dim = 8;\n    const float kern[dim*dim] = float[dim*dim]\n (0.       ,0.5      ,0.125    ,0.625    ,0.03125  ,0.53125  ,0.15625  ,0.65625 ,\n 0.75     ,0.25     ,0.875    ,0.375    ,0.78125  ,0.28125  ,0.90625  ,0.40625 ,\n 0.1875   ,0.6875   ,0.0625   ,0.5625   ,0.21875  ,0.71875  ,0.09375  ,0.59375 ,\n 0.9375   ,0.4375   ,0.8125   ,0.3125   ,0.96875  ,0.46875  ,0.84375  ,0.34375 ,\n 0.046875 ,0.546875 ,0.171875 ,0.671875 ,0.015625 ,0.515625 ,0.140625 ,0.640625,\n 0.796875 ,0.296875 ,0.921875 ,0.421875 ,0.765625 ,0.265625 ,0.890625 ,0.390625,\n 0.234375 ,0.734375 ,0.109375 ,0.609375 ,0.203125 ,0.703125 ,0.078125 ,0.578125,\n 0.984375 ,0.484375 ,0.859375 ,0.359375 ,0.953125 ,0.453125 ,0.828125 ,0.328125)    ;\n    ivec2 idx = ivec2(fragCoord)% dim;\n    float a = tex(fragCoord/R, R);\n    a += kern[idx.x + (idx.y * dim)]-.5;\n    float b = tobw(a);\n    o = vec4(b);\n}\n\nvoid bayer8(out vec4 o, in vec2 fragCoord, vec2 R) {\n    const int dim = 16;\n    const float kern[dim*dim] = float[dim*dim]\n( 0., 128.,  32., 160.,   8., 136.,  40., 168.,   2., 130.,  34., 162.,  10., 138., 42., 170.,\n192.,  64., 224.,  96., 200.,  72., 232., 104., 194.,  66., 226.,  98., 202.,  74., 234., 106.,\n 48., 176.,  16., 144.,  56., 184.,  24., 152.,  50., 178.,  18., 146.,  58., 186., 26., 154.,\n240., 112., 208.,  80., 248., 120., 216.,  88., 242., 114., 210.,  82., 250., 122., 218.,  90.,\n 12., 140.,  44., 172.,   4., 132.,  36., 164.,  14., 142.,  46., 174.,   6., 134., 38., 166.,\n204.,  76., 236., 108., 196.,  68., 228., 100., 206.,  78., 238., 110., 198.,  70., 230., 102.,\n 60., 188.,  28., 156.,  52., 180.,  20., 148.,  62., 190.,  30., 158.,  54., 182., 22., 150.,\n252., 124., 220.,  92., 244., 116., 212.,  84., 254., 126., 222.,  94., 246., 118., 214.,  86.,\n  3., 131.,  35., 163.,  11., 139.,  43., 171.,   1., 129.,  33., 161.,   9., 137., 41., 169.,\n195.,  67., 227.,  99., 203.,  75., 235., 107., 193.,  65., 225.,  97., 201.,  73., 233., 105.,\n 51., 179.,  19., 147.,  59., 187.,  27., 155.,  49., 177.,  17., 145.,  57., 185., 25., 153.,\n243., 115., 211.,  83., 251., 123., 219.,  91., 241., 113., 209.,  81., 249., 121., 217.,  89.,\n 15., 143.,  47., 175.,   7., 135.,  39., 167.,  13., 141.,  45., 173.,   5., 133., 37., 165.,\n207.,  79., 239., 111., 199.,  71., 231., 103., 205.,  77., 237., 109., 197.,  69., 229., 101.,\n 63., 191.,  31., 159.,  55., 183.,  23., 151.,  61., 189.,  29., 157.,  53., 181., 21., 149.,\n255., 127., 223.,  95., 247., 119., 215.,  87., 253., 125., 221.,  93., 245., 117., 213.,  85.);\n        ivec2 idx = ivec2(fragCoord)% dim;\n    float a = tex(fragCoord/R, R);\n    a += (kern[idx.x + (idx.y * dim)]/256.)-.5;\n    float b = tobw(a);\n    o = vec4(b);\n}\n\n\n#define C(c) U.x-=.5; O+= char(U,64+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    float halfLineW = 2.;\n    vec2 R = iResolution.xy * .5;\n    vec2 window = mod(fragCoord, iResolution.xy*.5);\n    vec2 uv = window / iResolution.y;\n    uv.x -= .6;\n    uv.y -= .4;\n    vec2 U = uv*12.;\n    vec4 O = vec4(0);\n    if (fragCoord.x <= iResolution.x * .5 - halfLineW) {\n        if (fragCoord.y <= iResolution.y * .5 - halfLineW) {\n            // BOTTOM LEFT\n    \t\tbayer4(o, window, R);\n    \t\t//C(2);C(1);C(25);C(5);C(18); // \"BAYER\"\n            C(-8);C(24+32);C(-8);// 8x8\n        } else if (fragCoord.y <= iResolution.y * .5 + halfLineW) {\n        \to = vec4(1,0,0,0);\n        } else {\n            // TOP LEFT\n\t    \tgray(o, window, R);\n    \t\tC(7);C(18);C(1);C(25); // GRAY\n\t    \t//bayer1(o, window, R);\n    \t\t//C(-14);C(24+32);C(-14);// 2x2\n        }\n    }\n    else if (fragCoord.x <= iResolution.x * .5 + halfLineW) {\n        \to = vec4(1,0,0,0);\n    } else {\n        if (fragCoord.y <= iResolution.y * .5 - halfLineW) {\n            // BOTTOM RIGHT\n\t    \tbayer8(o, window, R);\n    \t\tC(-15);C(-10);C(24+32);C(-15);C(-10);// 16x16\n        } else if (fragCoord.y <= iResolution.y * .5 + halfLineW) {\n        \to = vec4(1,0,0,0);\n        } else {\n            // TOP RIGHT\n\t    \tbayer2(o, window, R);\n    \t\tC(-12);C(24+32);C(-12);// 8x8\n        }\n    }\n    \n    o = mix(o, vec4(.9,0,0,0), O.x);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this is just used to keep track of which \"tv channel\" you're watching\n\n// 0 = tv channel\n// 1 = previous mouse state\n\nfloat load(int i) {\n    return texelFetch(iChannel0, ivec2(i,0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 C = ivec2(fragCoord);\n    int i = C.x + (int(iChannelResolution[0].x) * C.y);\n    \n    if (i == 0) {\n        float prevClickState = load(1);\n        if (prevClickState != iMouse.z && iMouse.z <= 0.) {\n            // mouse clicked state has changed; change tv channels.\n        \tfloat prev = load(0);\n            fragColor.x = float((int(prev) + 1) % 6);\n            return;\n        }\n    }\n    \n    if (i == 1) { // save mouse state\n        fragColor.x = iMouse.z;\n        return;\n    }\n    fragColor.x = load(i);\n}\n    \n","name":"Buffer A","description":"","type":"buffer"}]}