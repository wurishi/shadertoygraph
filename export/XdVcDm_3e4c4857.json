{"ver":"0.1","info":{"id":"XdVcDm","date":"1522335175","viewed":308,"name":"Water Sphere - Refraction","username":"nawafuji","description":"tested reflection & refraction props using cubemap","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n/*\nfloat distanceToNearestSurface(vec3 p){\n  return length(p) - 1.0;\n}\n*/\n\nconst float eta = 0.66;\nconst float etaR = 0.65;\nconst float etaG = 0.67;\nconst float etaB = 0.69;\n\nconst float fresnelPower = 5.0;\nconst float F = ((1.0-eta)*(1.0-eta))/((1.0+eta)*(1.0+eta));\n\nfloat fog(vec3 p, vec3 e){\n    bool useFogCoordinate = true;\n    float fdepth;\n    if(useFogCoordinate)\n        fdepth = length(p-e);\n    else\n        fdepth = abs(p.z);\n        \n    float fog;\n    float density = 0.02;\n    fog = exp(-density * fdepth);\n    return clamp(fog, 0.0, 1.0);\n}\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(0.0) - p) - 2.0;\n}\n\nfloat plane(vec3 p){\n    float s = -1.0;\n    float d = abs(p.z - s);\n    return max(d,0.0);\n}\n\nfloat distanceToNearestSurface(vec3 p){\n\n    float dist = 10.0;\n   //\tvec3 q = vec3(mod(p.x, dist) - dist/2.0, p.yz);\n//    return min(min(cube(q), sphere(q)),plane(q));\n    //return min(cube(q), sphere(q));\n    //return plane(p);\n    //return cube(p)/sphere(p);\n\t//return max(-sphere(p),cube(p));\n    return sphere(p);\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\nvec2 computeSphereTexCoord(vec3 p){\n    float longitude = acos(dot(vec2(0,-1), normalize(p.xz)));\n    if(p.x > 0.0)\n        longitude = 2.0*PI - longitude;\n    longitude /= 2.0*PI;\n    \n    float latitude = acos(dot(vec2(1,0), normalize(p.yz)));\n    latitude /= PI;\n    \n    return vec2(longitude, latitude);\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e){\n\n    \n    vec3 lightVector = normalize(l-p);\n    vec3 eyeVector = normalize(e-p);\n    vec3 halfVector = normalize(lightVector + eyeVector);\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(ambient + diffuse + specular, vec3(1.0));\n}\n\nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  float dist = 0.0;\n  for(int i = 0; i < 20; i++){\n    float nearest = distanceToNearestSurface(p + dir*dist);\n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = p+dir*dist;\n                //vec3 light = vec3(100.0,\n                  //          30.0,\n                    //        50.0);\n        vec3 light = vec3(100.0*sin(iTime),\n                            30.0*cos(iTime),\n                            50.0*(1.5+cos(iTime)));\n        vec3 normal = computeSurfaceNormal(hit);\n        vec3 pixelColor = computeLambert(hit, normal, light, p);\n        vec2 texcoord = computeSphereTexCoord(hit);\n        \n        float ratio = F+(1.0-F)*pow((1.0-dot(-dir,normal)),fresnelPower);\n        \n        \n        //vec3 refract = refract(dir,normal,eta);\n        vec3 refractR = refract(dir, normal, etaR);\n        vec3 refractG = refract(dir, normal, etaG);\n        vec3 refractB = refract(dir, normal, etaB);\n        \n        vec3 reflect = reflect(dir,normal);\n        \n        //vec3 refractColor = vec3(texture(iChannel3, refract)); \n        vec3 refractColor;\n        refractColor.r = vec3(texture(iChannel3, refractR)).r; \n        refractColor.g = vec3(texture(iChannel3, refractG)).g; \n        refractColor.b = vec3(texture(iChannel3, refractB)).b;\n        vec3 reflectColor = vec3(texture(iChannel3, reflect));\n        \n        vec3 color = mix(refractColor, reflectColor, ratio);\n        return color;\n\t\t//vec4 texColor = texture(iChannel3, normal);\n    \t\n        //return mix(vec3(0.1), pixelColor.xyz, fog(hit, p));\n        //return mix(vec3(0,0,0), texColor.xyz, pixelColor.x);\n    } \n    dist += nearest;\n  }\n  //return vec3(0.0);\n    return vec3(texture(iChannel3, dir));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 cameraPosition = vec3( cameraDistance*sin(iTime), 0.0, cameraDistance*cos(iTime));\n\t//vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0,-1.0*cos(iTime));\n\n    vec2 mouseUV = vec2(0.5,0.5);\n    if(iMouse.z>0.0)  \n        mouseUV = 2.0*iMouse.xy/iResolution.xy-1.0;\n  \n    \n    float d = 10.0;\n    float z = d*cos(mouseUV.y*PI/2.0);\n    vec3 cameraPosition = vec3(sin(mouseUV.x*PI/2.0) * z, d*sin(mouseUV.y*PI/2.0), cos(mouseUV.x*PI/2.0)*z);\n\tvec3 cameraDirection = -normalize(cameraPosition);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    float fovy = fovx * iResolution.y/iResolution.x;\n\tfloat ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// generate the ray for this pixel\n\tvec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n\tvec3 nright = normalize(cross(cameraUp, cameraDirection));\n    cameraUp = normalize(cross(nright, cameraDirection));\n\tvec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n\tvec3 rayDirection = normalize(pixel - cameraPosition);\n\n\tvec3 pixelColour = intersectsWithWorld(cameraPosition, rayDirection);\n            \n\n    fragColor = vec4(pixelColour, 1.0);\n}\n\n\n/** \n\n\tthe screenshot is here:\n    https://www.dropbox.com/s/ya2hhxvz1ixqipv/localShadertoysTextures.jpg?dl=0\n\n\trun fiddler (http://www.telerik.com/fiddler)\n    enable HTTPS ( & decrypt ) in fiddler options\n    go to tab shown on screenshot (autoresponder) and set options\n    add rule, then enter url to capture\n    in this example: https://www.shadertoy.com/presets/tex00.jpg\n    (first in textures set)\n\tand\n    enter url for redirect to ( could be file://... or /usr/user/...\n    \n    in this example \n    http://ogario.wpload.com/skins/amiga.png\n\n\n    image dimensions must be power of 2.\n    load image (thumbnail won't be changed) into channel\n    use iChannel as always\n\n    FB Post: \n    https://www.facebook.com/photo.php?fbid=10153170819997409&set=o.163777690435874&type=3&pnref=story\n**/\n\n","name":"Image","description":"","type":"image"}]}