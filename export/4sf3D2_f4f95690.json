{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Noise with derivatives by Morgan McGuire, @morgan3d, http://casual-effects.com\n//\n// Based on iq's Elevated https://www.shadertoy.com/view/MdX3Rr\n// See: https://iquilezles.org/articles/morenoise for part of the\n// derivation\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Any (relatively) cheap 2D hash function.  This is the underlying noise\n// function.  This particular ad hoc one appears to have better periodicity properties\n// than the \"magic\" constant in the original demo. \nfloat hash(vec2 p) {return fract(sin(p.x * 1e2 + p.y) * 1e5 + sin(p.y * 1e3) * 1e3 + sin(p.x * 735. + p.y * 11.1) * 1.5e2); }\n\n\n// GLSL smootherstep [smthrstp] from http://graphicscodex.com for reference\nfloat smootherstep(float start, float end, float t) {\n   t = max(0.0, min(1.0, (t - start) / (end - start)));\n   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n\n// Returns three values on [-1, +1]: \n// vec3(d noise(x,y) / dx, d noise(x, y) / dy, noise(x,y));\n//\n// This noise function can be combined in octaves to produce derivatives at multiple \n// scales as well.\nvec3 noised(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(p);\n    float b = hash(p + vec2(1.0, 0.0));\n    float c = hash(p + vec2(0.0, 1.0));\n    float d = hash(p + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values. This is the underlying\n\t// \"noise\" function that is being differentiated.\n\t//\n\t// return vec3(mix(\n\t//               mix(a, b, smootherstep(0.0, 1.0, f.x)),\n\t//\t\t         mix(c, d, smootherstep(0.0, 1.0, f.x)),\n\t//\t\t\t     smootherstep(0.0, 1.0, f.y)));\n\t\t\t\n\t// Inigo's version with the derivatives, expanded and refactored.  This stores the bilinear\n\t// [smoothstep weighted] interpolated value noise in z and the derivatives in x and y. \n\n    // Definition of smootherstep on a unit interval, applied in two dimensions simultaneously.\t\n\tvec2 v = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\t\n\tfloat noiseValue = \n\t    // Inigo's smoothstep approximation of smootherstep, which is slightly blurrier and \n\t\t// less expensive, but doesn't match the function being differentiated below:\n\t    // mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n\n\t\t// Full smootherstep version:\n\t \tmix(mix(a, b, v.x), mix(c, d, v.x), v.y);\n\t\n\t// Definition of smoothstep, which appears as a common subexpression below in the derivative terms.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn vec3((30.0 * f * f * (f * (f - 2.0) + 1.0)) * \n\t\t\t\t(vec2(b, c) + (a - b - c + d) * u.yx - a),\n\t\t\t\tnoiseValue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat a = iTime * 0.08;\n\tmat2 M = mat2(cos(a), sin(a), -sin(a), cos(a));\n\tvec3 value = noised(100.0 * (1.0 + sin(iTime * 0.3)) * M * (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y));\n\t\n\tif (mod(iTime, 15.0) < 5.0) {\n\t\t// Raw (dz/dx, dz/dy, z)\n\t\tfragColor = vec4(value * 0.5 + 0.5, 1.0);\n\t} else {\n\t\tvec3 normal = normalize(vec3(value.xy, 1.0));\n\t\tif (mod(iTime, 15.0) < 10.0) {\n\t\t\tfragColor = vec4(normal * 0.5 + 0.5, 1.0);\n\t\t} else {\n\t\t\t// Visualize shading\n\t\t\tfragColor = vec4(vec3(1.0) * dot(vec3(M * vec2(0.0, 1.0), 0.5), normal) * 0.5 + 0.5, 1.0);\n\t\t}\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sf3D2","date":"1379204059","viewed":910,"name":"Noise with Derivatives","username":"morgan3d","description":"Explanation of one of iq's noise functions (based on Elevated https://www.shadertoy.com/view/MdX3Rr)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise","derivative"],"hasliked":0,"parentid":"","parentname":""}}