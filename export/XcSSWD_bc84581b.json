{"ver":"0.1","info":{"id":"XcSSWD","date":"1706308032","viewed":96,"name":"perlin noise from texture","username":"sepia_sempervirens","description":"My own implementation of Perlin noise, using a white-noise texture as the pseudorandom input.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int OCTAVES = 4;\n\n//////////////////\n\nconst float TAU = 6.283185307179586476925;\nconst float TEXTURE_SIZE = 256.;\nconst float TEXEL_SIZE = 1. / TEXTURE_SIZE;\n\nconst float MOVEMENT_ANGLE = 0.65;\nconst float SIN_MOV_ANGLE = sin(MOVEMENT_ANGLE);\nconst float COS_MOV_ANGLE = cos(MOVEMENT_ANGLE);\nconst mat2 ROTATE = mat2(\n    COS_MOV_ANGLE, -SIN_MOV_ANGLE,\n    SIN_MOV_ANGLE,  COS_MOV_ANGLE\n);\nconst mat2 ROTATE_BACK = mat2(\n     COS_MOV_ANGLE, SIN_MOV_ANGLE,\n    -SIN_MOV_ANGLE, COS_MOV_ANGLE\n);\n\nvec2 uvTransform( vec2 uv ) {\n    uv = ROTATE * uv;\n    uv.x += iTime / 3.;\n    uv.y += 0.17 * cos(iTime / 1.5);\n    uv = ROTATE_BACK * uv;\n    uv /= 50.;\n    return uv;\n}\n\nfloat interpolateSquare( mat2 vals, vec2 weight ) {\n    vec2 linearWeight = vec2(\n        smoothstep(0., 1., weight.x),\n        smoothstep(0., 1., weight.y)\n    );\n    float left  = mix(vals[0][0], vals[1][0], linearWeight.y);\n    float right = mix(vals[0][1], vals[1][1], linearWeight.y);\n    return mix(left, right, linearWeight.x);\n}\n\nfloat gradientDotAt( vec2 latticePoint, vec2 offset )\n{\n    latticePoint = mod(latticePoint, TEXTURE_SIZE);\n    float gradientAngle = texelFetch(iChannel0, ivec2(latticePoint), 0).r * TAU;\n    vec2 gradient = vec2(cos(gradientAngle), sin(gradientAngle));\n    return dot(gradient, offset);\n}\n\nfloat noiseAt( vec2 uv ) {\n    uv /= TEXEL_SIZE;\n\n    vec2 latticePoint = floor(uv);\n    vec2 offset = fract(uv);\n    mat2 dots;\n    for (int x = 0; x < 2; x++) {\n        for (int y = 0; y < 2; y++) { \n            vec2 which = vec2(x, y);\n            dots[y][x] = gradientDotAt(latticePoint + which, offset - which);\n        }\n    }\n    \n    return interpolateSquare( dots, offset );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / min(iResolution.x, iResolution.y);\n    uv = uvTransform(uv);\n    \n    float col = 0.5;\n    float amplitude = 0.5;\n    float frequency = 1.;\n    for (int i = 0; i < OCTAVES; i++) {\n        col += amplitude * noiseAt(uv * frequency);\n        amplitude *= 0.5;\n        frequency *= 2.;\n    }\n\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}