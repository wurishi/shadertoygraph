{"ver":"0.1","info":{"id":"3t2Szh","date":"1565046397","viewed":523,"name":"Realistic eyeball","username":"rjd","description":"First shadertoy! Attempt at making a realistic eyeball. I timeboxed myself on this one.\n\nThings I would improve if I had more time:\n  - Softer blend from the eyeball to the iris\n  - Better veins","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["eye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415927;\nconst float epsilon = 0.0001;\nconst float intersect_distance = 0.001;\n\nconst vec3 light_color = vec3(3.0);\nconst vec3 ambient_color = vec3(0.3, 0.3, 0.3);\n\n// General helpers\n\nfloat Random(vec2 v)\n{\n    return fract(sin(dot(v, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Noise(vec2 st) \n{\n\t// https://www.shadertoy.com/view/4dS3Wd\n    \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = Random(i + vec2(0.0, 0.0));\n    float b = Random(i + vec2(1.0, 0.0));\n    float c = Random(i + vec2(0.0, 1.0));\n    float d = Random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat Fbm(vec2 x, int octaves)\n{\n    float f = 0.0;\n    float w = 1.0;\n\n    for (int i = 0; i < 256; ++i)\n    {\n        if (i >= octaves)\n            break;\n        \n        f += w * Noise(x);\n\n        x *= 2.0;\n        w *= 0.5;\n    }\n\n    return f;\n}\n\nfloat RidgedFbm(vec2 x, int octaves)\n{\n    float f = 0.0;\n    float w = 1.0;\n\n    for (int i = 0; i < 256; ++i)\n    {\n        if (i >= octaves)\n            break;\n        \n        f += w * abs(Noise(x) * 2.0 - 1.0);\n\n        x *= 2.0;\n        w *= 0.5;\n    }\n\n    return f;\n}\n\nfloat Saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\n// Shape distance functions\n\nfloat Sphere(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nfloat Plane(vec3 p)\n{\n    return p.y;\n}\n\n// Combine operators\n\nfloat Union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat Intersection(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat Difference(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat SmoothUnion(float d1, float d2, float k) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat SmoothIntersection(float d1, float d2, float k) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat SmoothDifference(float d1, float d2, float k) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h); \n}\n\n// Coordinate modifiers\n\nfloat Repeat(float v, float interval)\n{\n    return mod(v + interval * 0.5, interval) - interval * 0.5;\n}\n\n// Scene distance function \n\nfloat Scene(vec3 p, int ignore_material, out int material)\n{\n    p.x = Repeat(p.x, 4.0);\n    \n    float cornea_scale = 1.6;\n    \n    float eyeball = Sphere(p);\n    float iris = Sphere(p * cornea_scale - vec3(0.0, 0.0, 2.3)) / cornea_scale;\n    float cornea = Sphere(p * cornea_scale - vec3(0.0, 0.0, 0.68)) / cornea_scale;\n\n    if (ignore_material != 2 && cornea < eyeball)\n    {\n        material = 2;\n        return cornea;\n    }\n                            \n    if (eyeball > -iris)\n    {\n        material = 0;\n        return eyeball;\n    }\n    else\n    {\n        material = 1;\n        return -iris;\n    }\n}\n\nfloat FindIntersection(vec3 ro, vec3 rd, float tmax, int ignore_material, out int material)\n{\n    float t = 0.0;\n    \n    const int max_steps = 128;\n    \n    for (int i = 0; i < max_steps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n        float dist = Scene(p, ignore_material, material);\n        \n        t += dist;\n        \n        if (dist < intersect_distance)\n            return t;\n        \n        if (t > tmax)\n            return tmax;\n    }\n    \n\treturn tmax;\n}\n\nvec3 CalculateNormal(vec3 p)\n{\n    const vec2 h = vec2(epsilon, 0);\n    \n    int dummy = 0;\n    \n    float dsdx = Scene(p+h.xyy, -1, dummy) - Scene(p-h.xyy, -1, dummy);\n    float dsdy = Scene(p+h.yxy, -1, dummy) - Scene(p-h.yxy, -1, dummy);\n    float dsdz = Scene(p+h.yyx, -1, dummy) - Scene(p-h.yyx, -1, dummy);\n    \n    return normalize(vec3(dsdx, dsdy, dsdz));\n}\n\nvoid CalculateMaterialProperties(vec3 p, float time, int material, out vec3 normal, out vec3 color, out float roughness, out float metallic)\n{\n    p.x = Repeat(p.x, 4.0);\n    \n    normal = vec3(0.0, 0.0, 0.0);\n    metallic = 0.0;\n\n    // Eye axis is z\n\n    float theta = atan(p.y / p.x);\n    float phi = acos(p.z / length(p));\n\n    if (material == 0)\n    {\n        // Sclera \n        \n        // Go from pink at the back to white at the front\n        \n        const vec3 color_back = vec3(0.8, 0.1, 0.1);\n        const vec3 color_front = vec3(0.7, 0.7, 0.7);\n        \n        float frontness = Saturate((p.z + 1.0) * 0.5);\n        float backness = 1.0 - frontness;\n        \n        color = mix(color_back, color_front, smoothstep(0.4, 1.0, frontness));\n        \n        // Add veins using ridged noise but fade off near the front\n        \n        float f = Saturate(1.0 - RidgedFbm(vec2(theta * 5.0, phi * 3.0) * 3.0, 3));\n        float veins = pow(f, 4.0) * smoothstep(0.0, 0.3, backness);\n        \n        color = mix(color, vec3(0.8, 0.0, 0.0), veins);\n        roughness = 0.2;\n        normal = normalize(cross(p, vec3(0.0, 1.0, 0.0))) * Fbm(vec2(theta, phi) * 50.0, 4) * 0.1;\n        \n        return;\n    }\n    \n    if (material == 1)\n    {\n        float pupil_radius = 0.06 + Fbm(vec2((time + 7.534) * 0.2, 0.0), 4) * 0.05;\n        \n        float r = length(p.xy); // Radius in the xy-plane\n                \n        if (r < pupil_radius)\n        {\n            // Pupil\n            \n            color = vec3(0.01);\n            roughness = 0.4;\n            return;\n        }\n        else\n        {\n            const float iris_radius = 0.35;\n            \n            const vec3 iris_middle = vec3(0.3, 0.3, 0.5) * 1.5;\n            const vec3 iris_inner = vec3(0.2, 0.15, 0.1) * 1.5;\n            const vec3 iris_outer = vec3(0.2, 0.2, 0.3) * 0.5;\n            \n            // Iris\n            \n            float q = Saturate((r - pupil_radius) / (iris_radius - pupil_radius));\n            float f = abs(Fbm(vec2(r * 8.0, theta * 10.0), 4));\n            float ridge = f * f;\n            \n            float inner = smoothstep(0.1, 0.7, q);\n            float outer = smoothstep(0.8, 1.05, q);\n            \n            color = iris_middle;\n            color = mix(color, iris_outer, outer);\n            color = mix(iris_inner, color, inner);\n            color = color * mix(0.4, 1.0, ridge);\n            \n            roughness = 0.2;\n            normal = normalize(vec3(-p.y, p.x, 0)) * f * 0.5;\n        }\n        \n        return;\n    }\n    \n    if (material == 2)\n    {\n        // Cornea\n        \n        color = vec3(0.0, 0.0, 0.0);\n        roughness = 0.1;\n        \n        return;\n    }\n}\n\n// Lighting\n\nvec3 F(vec3 f0, float vdoth, float roughness)\n{\n    // Schlick Fresnel approximation with roughness\n    //\n\t// https://seblagarde.wordpress.com/2011/08/17/hello-world/\n\n\treturn f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(1.0 - Saturate(vdoth), 5.0);\n}\n\nvec3 F(vec3 f0, float vdoth)\n{\n\t// Schlick Fresnel approximation\n\t//\n\t// F(v, h) = f₀ + (1 - f₀) * (1 - v·h)⁵\n\n\treturn f0 + (vec3(1) - f0) * pow(1.0 - vdoth, 5.0);\n}\n\nfloat V(float alpha, float ndotl, float ndotv)\n{\n\t// Height-correlated Smith GGX from \"Understanding the Masking-Shadowing function\n\t// in microfacet-based BRDFs\" by Eric Heitz\n\t//\n\t// http://jcgt.org/published/0003/02/03/paper.pdf\n\t//\n\t// G = 1 / (1 + Λ(v) + Λ(l)) \n\t//\n\t// Λ(x) = (1 / 2) (sqrt(α² + (1 - α²)(n·x²)) / n·x) - 1)\n\t//\n\t// Expanding out:\n\t//\n\t// G = 2 / (sqrt(α² + (1 - α²)(n·v²)) / n·v) + sqrt(α² + (1 - α²)(n·l²)) / n·l))  \n\t// G = 2 n·l n·v / (n·l sqrt(α² + (1 - α²)(n·v²))) + n·v sqrt(α² + (1 - α²)(n·l²))))\n\t//\n\t// Again, we can reformulate into the visibility function by dividing by the brdf \n\t// denominator:\n\t//\n\t// V = 1 / (2 (n·l sqrt(α² + (1 - α²)(n·v²))) + n·v sqrt(α² + (1 - α²)(n·l²)))))\n\n\tfloat aa = alpha * alpha;\n\tfloat V0 = ndotl * sqrt(aa + (1.0 - aa) * (ndotv * ndotv));\n\tfloat V1 = ndotv * sqrt(aa + (1.0 - aa) * (ndotl * ndotl));\n\n\tfloat step = ndotl * ndotv;\n\n\treturn step > 0.0 ? 0.5 / (V0 + V1) : 0.0;\n}\n\nfloat D(float alpha, float ndoth)\n{\n\t// Smith GGX normal distribution\n\t//\n\t// D(h) = α² / (π ((α² - 1) (n·h)² + 1)²)\n\n\tfloat aa = alpha * alpha;\n\tfloat q = (aa - 1.0) * ndoth * ndoth + 1.0;\n\n\treturn aa / (pi * q * q);\n}\n\nvec3 CalculateDirectLighting(vec3 n, vec3 v, vec3 l, vec3 cd, vec3 cs, float roughness, float shadow)\n{\n\t// Calculate pixel lighting constants\n\n    vec3 r = reflect(-v, n);\n\n\tfloat ndotl = Saturate(dot(n, l));\n\tfloat ndotv = Saturate(dot(n, v));\n\n\t// Direct lighting\n\t//\n\t// This is a combination of a microfacet specular layer with a Lambert diffuse layer\n\t// at the bottom. For energy-conservation purposes, only the light that the specular\n\t// layer transmits can be used for layers below.\n\t//\n\t// This can be extended to multiple specular layers pretty easily, but I don't need\n\t// to do so at the moment.\n\t//\n\t// Microfacet brdf based on Cook-Torrance\n\t//\n\t// v = ωo\n\t// l = ωi\n\t// h = normalize(l + v)\n\t//\n\t// f(l, v, n) = F(v, h) G(l, v, h) D(h) / (4 n·l n·v)\n\t//\n\t// For the Fresnel term, we'll use Schlicks approximation:\n\t//\n\t// F(v, h) = f₀ + (1 - f₀) * (1 - v·h)⁵\n\t//\n\t// For the visibility term, we have to match the normal distribution function for energy\n\t// conservation purposes, so we'll use the Smith non-correlated term:\n\t//\n\t// G(l, v, h) = G₁(n, l) G₁(n, v)\n\t//\n\t// Where:\n\t//\n\t// G₁(n, x) = (2 n·x) / (n·x + sqrt(1 + α²(1 - (n·x)²)))\n\t//\n\t// For the normal distribution term, I'm using GGX\n\t//\n\t// D(h) = α² / (π ((α² - 1) (n·h)² + 1)²)\n\t//\n\t// Looking at the terms on the top of the geometry factor, they cancel out with those\n\t// on the bottom, so we can use the visibility formulation from the RAD paper:\n\t//\n\t// f(l, v, n) = F(v, h) V(l, v, h) D(h)\n\n\tvec3 h = normalize(l + v);\n\n\tfloat vdoth = Saturate(dot(v, h));\n\tfloat ndoth = Saturate(dot(n, h));\n\n\tvec3 ks = F(cs, vdoth);\n\tvec3 kd = (vec3(1) - ks) * cd;\n\n\tfloat alpha = roughness * roughness;\n\n\tvec3 brdf = vec3(0);\n\n\tbrdf += cd / pi;\n\tbrdf += ks * V(alpha, ndotl, ndotv) * D(alpha, ndoth);\n\n\treturn brdf * ndotl * light_color * shadow;\n}\n\nvec3 CalculateIndirectLighting(vec3 n, vec3 v, vec3 cd, vec3 cs, float roughness, float occlusion)\n{\n    float ndotv = Saturate(dot(n, v));\n\n\t// Indirect lighting\n\t//\n\t// https://learnopengl.com/PBR/IBL/Diffuse-irradiance\n\n\tvec3 ks = F(cs, ndotv, roughness);\n\tvec3 kd = (vec3(1.0) - ks) * cd;\n\n    vec3 r = reflect(-v, n);\n    \n    vec3 rough_env = texture(iChannel1, r).rgb * 2.0;\n    vec3 gloss_env = texture(iChannel0, r).rgb * 2.0;\n    \n    vec3 lighting = vec3(0);\n    \n    // For diffuse lighting, the pi factor is cancelled out by the integral of the constant\n    // radiance over the hemisphere.\n\n    lighting += kd * ambient_color;\n    \n    // For specular, the ambient color is constant\n    \n    lighting += ks * mix(gloss_env, rough_env, roughness);\n\n\treturn lighting * occlusion;\n}\n\nvec3 CalculateRadianceNoCornea(vec3 ro, vec3 rd, float time)\n{  \n    int material = 0;\n    int ignore = 2; // cornea\n    \n    float tmax = 50.0;\n    float thit = FindIntersection(ro, rd, tmax, ignore, material);\n    \n    if (thit >= tmax)\n        return texture(iChannel1, rd).rgb;\n        \n   \tvec3 p = ro + rd * thit;\n    \n    // Calculate material properties\n\n    vec3 color;\n    vec3 normal;\n    float roughness;\n    float metallic;\n    \n    CalculateMaterialProperties(p, time, material, normal, color, roughness, metallic);\n    \n\tvec3 cs = mix(vec3(0.04), color, metallic);\n\tvec3 cd = mix(color, vec3(0), metallic);\n\n    // Calculate lighting vectors\n    \n    vec3 n = normalize(CalculateNormal(p) + normal); // Hacky normal perturbation\n    vec3 l = normalize(vec3(+1, +1, +1));\n    vec3 v = -rd;\n\n    vec3 radiance = vec3(0.0);\n    \n    // Indirect\n\n    float occlusion = 1.0;\n    \n    radiance += CalculateIndirectLighting(n, v, cd, cs, roughness, occlusion);\n    \n    // Direct\n    \n    int dummy;\n    float shadow = FindIntersection(p + n * 0.01, l, tmax, -1, dummy) < tmax ? 0.0 : 1.0; \n    \n    radiance += CalculateDirectLighting(n, v, l, cd, cs, roughness, shadow);\n    \n    // Sum\n    \n    return radiance;\n}\n\nfloat CalculateShadow(vec3 p, vec3 n, vec3 l)\n{\n    float tmax = 3.0;\n    int dummy;\n    return FindIntersection(p + n * 0.01, l, tmax, -1, dummy) < tmax ? 0.0 : 1.0; \n}\n\nvec3 CalculateRadiance(vec3 ro, vec3 rd, float time)\n{  \n    int material = 0;\n    \n    float tmax = 50.0;\n    float thit = FindIntersection(ro, rd, tmax, -1, material);\n    \n    if (thit >= tmax)\n        return texture(iChannel1, rd).rgb;\n        \n   \tvec3 p = ro + rd * thit;\n    \n    // Calculate material properties\n\n    vec3 color;\n    vec3 normal;\n    float roughness;\n    float metallic;\n    \n    CalculateMaterialProperties(p, time, material, normal, color, roughness, metallic);\n    \n\tvec3 cs = mix(vec3(0.04), color, metallic);\n\tvec3 cd = mix(color, vec3(0), metallic);\n\n    // Calculate lighting vectors\n    \n    vec3 n = normalize(CalculateNormal(p) + normal); // Hacky normal perturbation\n    vec3 v = -rd;\n    \n    // Indirect\n\n    float occlusion = 1.0;\n    \n    vec3 indirect = CalculateIndirectLighting(n, v, cd, cs, roughness, occlusion);\n    \n    // Direct\n    \n    vec3 l0 = normalize(vec3(+1, +1, +1));\n    vec3 l1 = normalize(vec3(-1, +1, +1));\n\n    vec3 direct = vec3(0.0);\n    direct += CalculateDirectLighting(n, v, l0, cd, cs, roughness, CalculateShadow(p, n, l0));\n    direct += CalculateDirectLighting(n, v, l1, cd, cs, roughness, CalculateShadow(p, n, l1));\n    \n    // Sum\n    \n    vec3 radiance = indirect + direct;\n    \n    if (material == 2)\n    {\n        // We hit the cornea - refract and add in the iris contribution\n        \n        float eta = 0.6;\n        \n        radiance += CalculateRadianceNoCornea(p - n * 0.01, refract(-v, n, eta), time); \n    }\n        \n    return radiance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera settings\n    \n    float range = 5.0;\n    float speed = 0.1;\n    float theta = (Fbm(vec2(iTime * speed, 0.0), 5) - 1.0) * 1.8;\n    float phi = (Fbm(vec2(0.0, iTime * 0.1), 5) - 1.0) * 0.5;\n    \n    vec3 focus = vec3(0, 0, 0);\n    \n    // Align camera to point at the focus\n    \n    vec3 offset = vec3(sin(theta), sin(phi), cos(theta));\n    \n    vec3 w = focus + offset * range;\n    vec3 z = normalize(-offset);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n\tvec3 y = cross(z, x);\n    \n    // Generate ray\n    \n    const int max_samples = 2;\n\n    vec3 color = vec3(0);\n        \n    for (int n = 0; n < max_samples; ++n)\n    {\n        for (int m = 0; m < max_samples; ++m)\n        {\n            vec2 o = vec2(float(m),float(n)) / float(max_samples) - 0.5;\n            vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n\n            vec3 ro = w;\n            vec3 rd = normalize(p.x * x + p.y * y + 3.0 * z);\n            \n            color += CalculateRadiance(ro, rd, iTime);\n        }\n    }\n    \n    color /= float(max_samples * max_samples);\n    \n    fragColor = vec4(pow(color, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}