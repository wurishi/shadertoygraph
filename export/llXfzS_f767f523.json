{"ver":"0.1","info":{"id":"llXfzS","date":"1512338360","viewed":421,"name":"dithering, CGSE answer: edgecase","username":"hornet","description":"Fixes clamping issue of triangular dithering near 0,1, by interpolating to a uniform distibution.\nFull explanation  here:\nhttps://computergraphics.stackexchange.com/questions/5904/whats-a-proper-way-to-clamp-dither-noise/5952#5952","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["dither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n    fragColor = texture( iChannel0, ssuv );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//notes\n// yellow: signal\n// red:    error\n// blue:   variance\n// \n#define SHOW_VARIANCE\n#define SHOW_PREQUANTIZED_NOISE\n#define ANIMATE\n//#define SHOW_MINMAX\n\n#define NUM_SAMPLES 1024\n\n\n//note: lerp to 1LSB uniform dither, correct result\n#define FIX_EDGECASES\n\n//note: test linearly modulating dither, incorrect result\n#if defined( FIX_EDGECASES )\n//#define RESCALE_DITHER\n#endif\n\n//note: test compressing input signal; incorrect result\n#if !defined( FIX_EDGECASES )\n//#define RESCALE_SIGNAL\n#endif\n\n\n\n//note: uniform pdf rand [0;1[\nvec2 hash22n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4307, p.y * p.x * 97.5901));\n}\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\nfloat remap( float v, float a, float b )\n{\n    return(v-a)/(b-a);\n}\n\nfloat dither( float v, vec2 seed )\n{\n    #if defined( ANIMATE )\n    vec3 rnd = hash32n(seed + fract(iTime) );\n    #else\n    vec3 rnd = hash32n(seed);\n    #endif\n    \n    float dither = (rnd.x + rnd.y - 1.0); //note: symmetric, triangular dither, [-1;1[\n    //float dither = (rnd2.x-0.5); //note: uniform symmetric dither, [-0.5;0.5[\n    //float dither = (2.0*rnd2.x-1.0); //note: uniform symmetric dither, [-1;1[\n\n    #if defined(FIX_EDGECASES)\n    float sizt_lo = clamp(remap(v, 0.0,     0.5/7.0), 0.0, 1.0 ); //note: adjust dither at low end...  optimizes to min(1.0, 14.0*v)\n    float sizt_hi = clamp(remap(v, 1.0, 1.0-0.5/7.0), 0.0, 1.0 ); //note: adjust dither at high end... optimizes to 14.0-14.0*v\n        \n    #if defined(RESCALE_DITHER)\n    dither *= 0.5 + 0.5 * min(sizt_lo, sizt_hi); //note: INCORRECT output, modulate dither... close but no cigar\n    #else\n\n    float t = min(sizt_lo, sizt_hi);\n    \n    //dither = mix( rnd.z-0.5, rnd.x+rnd.y-1.0, t ); //note: wrong\n    //dither = mix( rnd.x-0.5, rnd.x+rnd.y-1.0, t ); //note: correct\n   \t//dither = rnd.x-0.5 + t*(rnd.y-0.5); //note: mix reduced\n    //dither = (t<1.0) ? rnd.x - 0.5 : rnd.x+rnd.y-1.0;\n    dither = (v<0.5/7.0 || v>(1.0-0.5/7.0) ) ? rnd.x - 0.5 : rnd.x+rnd.y-1.0; //note: threshold to norm... which... appears to work perfectly?!?\n    \n    \n    //dither = mix( dithernorm,\n    //              dithertri,\n    //              min(sizt_lo, sizt_hi) ); //note: CORRECT output \n    #endif\n    \n    //note: (very) empirical dither-offset, incorrect result\n    //dither = dither + 0.5*pow(sizt_lo,0.25) - 0.5; \n    //dither = dither - 0.5*pow(sizt_hi,0.22) + 0.5;\n    #endif //FIX_EDGECASES\n\n    #if defined( RESCALE_SIGNAL )\n    v = remap(v, 0.5/7.0, 6.5/7.0 ); //note: INCORRECT output\n    #endif\n    \n    return v + dither / 7.0;\n}\n\nfloat calc_output_tri( float ci, vec2 seed )\n{\n    ci = dither( ci, seed );\n    \n    // quantize to 3 bit\n    float c = floor(ci * 7.0 + 0.5) / 7.0; //note: round\n    c = clamp( c, 0.0, 1.0 );\n    \n    return c;\n}\n\nfloat calc_output( float ci, vec2 seed )\n{\n    return calc_output_tri(ci,seed);\n}\n\nfloat testpattern( vec2 p )\n{\n    return p.x * 1.5 - 0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n  \n    float ci = testpattern( uv ); // create input color\n\n    float dx = dFdx( ci );\n    vec3 cx = vec3(ci-dx, ci, ci+dx);\n    \n    float signal = ci;\n    \n    vec3 signal_quant = floor(cx*7.0+0.5)/7.0;\n    \n    float dithersignal = calc_output( ci, fragCoord );\n\n    float vmin =  100000.0;\n    float vmax = -100000.0;\n    float avg = 0.0;\n    const float w = (1.0/float(NUM_SAMPLES));\n    for( int i=0;i<NUM_SAMPLES;++i)\n    {\n        vec2 seed = uv + vec2(3.0,7.0)*float(i);\n        float v = calc_output( ci, seed );\n        avg += w*v;\n        vmin = min( vmin, v );\n        vmax = max( vmax, v );\n    }    \n\n    #if defined( SHOW_VARIANCE)\n    //TODO: calc variance inline ^\n    float var = 0.0;\n    for( int i=0;i<NUM_SAMPLES;++i)\n    {\n        vec2 seed = fragCoord + vec2(7.0,11.0)*float(i);\n        float v = calc_output( ci, seed );\n\n        float diff = v-avg;\n        var += diff * diff;\n    }\n    var /= float(NUM_SAMPLES-1);\n    #endif\n    \n    //====\n    \n \t//note: y-lines at 0, 1\n    if ( abs(signal-0.0)<0.00125 ||\n         abs(signal-1.0)<0.00125 )\n    {\n        fragColor=vec4(vec3(0.25),1); return;\n    }\n    \n    if ( uv.y > 0.8333 )\n    {\n        fragColor = vec4(vec3(signal),1); return;\n    }\n    else if ( uv.y > 0.6667 )\n    {\n        fragColor = vec4(vec3(avg),1); return;\n        \n    }\n    else if ( uv.y > 0.5 )\n    {\n        fragColor = vec4(vec3(dithersignal),1); return;\n    }\n    else\n    {\n        vec2 luv = uv/0.4 - 0.1;\n        \n        vec3 c = vec3(0.0);\n        \n        //TODO: grid\n        if ( abs(luv.y-0.0)<dFdy(luv.y) ||\n             abs(luv.y-1.0)<dFdy(luv.y) ||\n             abs(luv.y-0.5)<0.5*dFdy(luv.y) )\n            c += 0.25;\n     \n        //note: lines at values we can't exceed (+0.5-0.5)\n        if ( abs(luv.y-0.0+1.0/14.0)<0.5*dFdy(luv.y) ||\n             abs(luv.y-1.0-1.0/14.0)<0.5*dFdy(luv.y) )\n            c += 0.125;\n\n        //note: lines where changing to norm\n        if ( abs(signal-0.0-1.0/14.0)<0.5*dFdx(signal) ||\n             abs(signal-1.0+1.0/14.0)<0.5*dFdx(signal) )\n            c += 0.06125;\n\n     \n        //pure signal, undithered, unquantized\n\t\tfloat cs = step(abs(luv.y-signal), 0.0025);\n        c += vec3(0.5, 0.5, 0.5) * cs; \n        \n        //quantized\n        float cq = ((signal_quant.x-luv.y)<dFdy(luv.y) && (luv.y-signal_quant.z < dFdy(luv.y))) ? 1.0 : 0.0;\n        c += vec3(64.0/255.0, 32.0/255.0, 16.0/255.0) * cq;\n        \n        //average of dithered signal\n        float ca = step(abs(luv.y-avg), 0.0025);\n        c += vec3(255.0/255.0, 211.0/255.0, 0.0) * ca;\n\n        #if defined( SHOW_VARIANCE )\n        var *= 150.0; //random scaling for vis\n        float cv = step(abs(luv.y-var), 0.005);\n        c += vec3(0.0,128.0/255.0, 1.0) * cv;\n        #endif\n\n        \n        //note: error of avg\n        float diff = avg-signal;\n        diff *= 10.0;\n        float err = diff*0.5+0.5;\n        float ce = step(abs(luv.y-err), 0.0025);\n        c += vec3(1.0,0.0,0.0) * ce;\n        \n        \n        //dithered, quantized signal\n        //float cd = step(abs(luv.y-dithersignal), 0.005);\n        //c += vec3(1,0,0) * cd;                    \n\n        #if defined( SHOW_MINMAX )\n        float cmx = step(abs(luv.y-vmin), 0.0025);\n        float cmn = step(abs(luv.y-vmax), 0.0025);\n        c += vec3(0.0, 0.5, 1.0) * cmn;\n        c += vec3(1.0, 0.0, 0.5) * cmx;\n        #endif //SHOW_MINMAX\n\n        //accumulated dithered, quantized\n\t\t#if defined( SHOW_PREQUANTIZED_NOISE )\n        {\n            const int NUM_RND_AVG = 16;\n            float avgdither=0.0;\n            for(int i=0;i<NUM_RND_AVG;++i)\n            {\n                vec2 seed = fragCoord + vec2(81.0,89.0)*float(i);\n                float s = dither( ci, seed );\n                float g = step(abs(luv.y-s), 0.025);\n                avgdither += (1.0/float(NUM_RND_AVG)) * g;\n            }\n            c += avgdither;\n        }\n        #endif\n        \n        fragColor = vec4(vec3(c),1);\n        return;\n    }\n    \n\tfragColor = vec4(0);\n}\n\n//yes, I am aware how inappropriate it is for me to not dither the output...\n","name":"Buffer A","description":"","type":"buffer"}]}