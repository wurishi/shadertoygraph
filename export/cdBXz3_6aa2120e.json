{"ver":"0.1","info":{"id":"cdBXz3","date":"1670592904","viewed":146,"name":"Xmas Ornament","username":"noobcsf","description":"Playing around with SDFs","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cute","christmas","cartoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nvec3 rot_x(vec3 p, float a) { float c = cos(a); float s = sin(a); return vec3(p.x, c * p.y - s * p.z, c * p.z + s * p.y); }\n\nvec3 rot_y(vec3 p, float a) { float c = cos(a); float s = sin(a); return vec3(c * p.x + s * p.z, p.y, c * p.z - s * p.x); }\n\nvec3 rot_z(vec3 p, float a) { float c = cos(a); float s = sin(a); return vec3(c * p.x + s * p.y, c * p.y - s * p.x, p.z); }\n\nvec3 rot(vec3 p,vec3 euler) { return rot_y(rot_x(rot_z(p, euler.z), euler.x), euler.y); }\n\nfloat saturate(float value) { return max(0., min(value, 1.)); }\n\nvec4 eye_shape(vec2 uv, float blur, float id)\n{\n  uv.y -=0.05;\n\n  float blink = min((cos(iTime * 3. + id*37.) * 0.5 + 0.5)*20., 1.);\n  float eye = length(uv) - .1;\n  float ring = length(uv) - .07;\n  float inner = length(uv) - .04;\n  vec2 uv2 = uv;\n  uv2.x *= 0.5;\n  uv2.y = -abs(uv2.y);\n  float eye2 = length(uv2-vec2(0., -0.2*blink)) - .1;\n\n  uv2 = uv;\n  uv2.x = abs(uv2.x);\n  uv2.x *= 0.4;\n  uv2.y *= 1.5;\n  uv2.y += uv2.x*uv2.x*100.;\n  uv2.x -= (uv2.x*uv2.x)*0.01;\n  uv2.y -= 0.035;\n  float eye_white = length(uv2) - .01;\n\n  float eyeMask = smoothstep(blur, -blur, eye);\n  float eyeMask2 = smoothstep(blur, -blur, eye2);\n  float ringMask = smoothstep(blur, -blur, ring);\n  float innerMask = smoothstep(blur, -blur, inner);\n  float eye_whiteMask = smoothstep(blur, -blur, eye_white);\n  vec3 iris = vec3(221./255.,133./255.,37./255.);\n  iris += iris*0.15 + (uv.y)/0.7*2.;\n\n  eyeMask *= 1.-eyeMask2;\n\n  vec3 color = vec3(1.);\n  color = mix(color, iris, ringMask);\n  color -= mix(color, vec3(0.), 1.-innerMask);\n  color = mix(color, vec3(1.), eye_whiteMask);\n\n  float shade = min(1. , (-eye/0.12/0.2)*0.5 + 0.6);\n  shade *= (uv.y)/0.25+ 0.9;\n  color *=vec3(1) * shade;\n\n    return vec4(color, eyeMask);\n}\n\nvec4 body(vec2 uv, vec3 color,  float radius, float blur, float id)\n{\n  uv *= 1.0+(cos(iTime*4. + id)*0.5+0.5)*0.02;\n\n  vec2 uvEye = uv - vec2(0., 0.24);\n  vec4 eye_color = eye_shape(uvEye, blur, id);\n\n  uv.x = abs(uv.x) * (1. + smoothstep(0.5, 0.0, uv.y)*0.2);\n  uv.x *= uv.x * 2.0;\n  uv.x += 0.1;\n  uv.y -= 0.2;\n  uv.y *= 0.7;\n\n  float gradient_y = uv.y;\n  float body = length(uv) - radius;\n  float bodyMask = smoothstep(blur, -blur, body);\n  float bodyShape = smoothstep(-.0 , 0.4, -body/ radius);\n\n  vec3 finalColor = color;\n  float gradient = min(1.,(0.5 + smoothstep(-0.1, 0.2, gradient_y)));\n  finalColor = color* bodyMask * gradient + 0.3*(1.-bodyShape)*bodyMask;\n  finalColor = mix(finalColor, eye_color.rgb, eye_color.w);\n  return vec4(finalColor, bodyMask);\n}\n\nvec4 starLayer2(vec2 uv)\n{\n  uv *= 10.;\n  uv *= 0.5;\n  vec2 lv = ((fract(uv)-0.5)/0.5);\n  vec2 id = ceil(uv);\n\n  float randomValue = (cos(id.y*6217.)*cos(id.x*7919.72))*0.5 + 0.5;\n  float randomValueColor = (cos(id.x*6234217.123)*cos(id.y*79.72))*0.5 + 0.5;\n  vec2 random = (sin(id.yx*6217.71234891)*cos(id*92398713478901.7834))*0.5 + 0.5;\n\n  float sz = mix(0.5, 1., randomValue);\n  vec2 mv = vec2(\n    mix(-sz,sz, random.x)/4.,\n    mix(-sz,sz, random.y)/4.\n  );\n  lv *= sz;\n  lv += mv;\n\n  float time = cos(iTime*2.+ randomValue*2357.)*1.;\n  float len = abs(lv.x) * abs(lv.y);\n  float len2 = length(lv.xy);\n  vec3 col = vec3(1.);\n  len = 1.-len * 50.0;\n  len2 = 1.-len2;\n  col += smoothstep(0.5, 1.0, len2)*(1.-abs(cos(time*0.5)*0.5));\n  len *= saturate(len2);\n  len -= (1. - abs(cos(time)*0.3));\n  float starShape = smoothstep(-0.1, 0.1, len);\n  len = smoothstep(0.1, 2.0, len);\n  len = saturate(len/0.01);\n\n  vec3 star1 = vec3(2., 0.5, 0.5)*1.5;\n  vec3 star2 = vec3(0.5, 0.5, 2.)*1.5;\n  vec3 star = mix(star1, star2, randomValueColor);\n\n  col = (star + len) * starShape;\n  return vec4(col, starShape);\n}\n\nvec4 stars(vec2 uv, float uvY)\n{\n  float y = uv.y;\n  vec4 s = vec4(0.);\n  uv*= 2.0;\n  vec4 sl = starLayer2(uv);\n  s = mix(s, sl, sl.w);\n\n  uv*= 1.5;\n  uv+=vec2(12.2);\n  sl = starLayer2(uv);\n  s = mix(sl, s, s.w);\n\n  vec3 color = vec3(0);\n  vec3 sky1 = vec3(7./255., 19./255., 44./255.);\n  vec3 sky2 = vec3(115./255., 172./255., 199./255.);\n  vec3 sky = mix(sky2, sky1, uvY);\n\n  color = s.rgb;\n  color = mix(sky*1.5, color, uvY - 0.3);\n  return vec4(color, 1.);\n}\n\nfloat square(vec2 uv, float sY, float eY, float top, float bottom)\n{\n  uv.x = abs(uv.x);\n\n  float m = 0.001;\n  float h = mix(bottom, top, (uv.y-sY)/(eY-sY));\n\n  float k = smoothstep(-m, m, uv.y - sY);\n  k *= smoothstep(m, -m, uv.y - eY);\n  k *= smoothstep(m, -m, uv.x - h);\n\n  return k;\n}\nmat2 rot(float a)\n{\n  return mat2(cos(a), - sin(a), sin(a), cos(a));\n}\n\nfloat tree(vec2 uv)\n{\n  float f = square(uv, -0.1, 0.15, 0.10, 0.10);\n  uv.y-= 0.16;\n  f += square(uv, -0.1, 0.35, 0.18, 0.35);\n  uv.y-= 0.35;\n  uv = rot(0.01 + cos(iTime)*0.1) * uv;\n  f += square(uv, -0.05, 0.25, 0.15, 0.3);\n  uv.y-= 0.25;\n  uv = rot(0.01 + cos(iTime)*0.1) * uv;\n  f += square(uv, -0.05, 0.45, 0.0, 0.25);\n  return f;\n}\n\nvec4 flr(vec2 uv)\n{\n  uv.y -=0.15;\n  vec3 color;\n  vec3 fg_color = vec3(32./255., 56./255., 103./255.);\n  float l = 1.;\n  uv.y += uv.x*uv.x*0.1;\n  l = smoothstep(0.0, 0.001, -uv.y);\n  color.rg = uv;\n  color = fg_color;\n\n  vec2 lv = rot(-0.12 + cos(iTime*2.)*0.01 ) * (uv + vec2(-0.55, 0.));\n  lv.y +=0.2;\n  lv*=1.7;\n  l += tree(lv);\n\n  lv = rot(0.12 + cos(iTime*2. + 23.)*0.1 ) * (uv + vec2(0.55, 0.));\n  lv*=1.8;\n  l += tree(lv);\n  l = saturate(l);\n\n  color *= 1. - uv.y*0.9;\n  return vec4(color, l);\n}\n\nvec4 draw_snaliens(vec2 uv, vec2 normalizedUV)\n{\n  vec4 col = vec4(0);\n  uv.y+=0.4;\n  float blur = 0.001;\n\n  vec3 c1 = vec3(155./255.,197./255.,52./255.);\n  vec3 c2 = vec3(201./255.,45./255.,75./255.);\n  vec3 c3 = vec3(81./255.,169./255.,221./255.);\n\n  vec4 b1 = body(uv, c1, 0.2, blur, 1.);\n  vec2 uv2 = rot(0.4) * (uv + vec2(0.2, 0.));\n  vec4 b2 = body(uv2, c2, 0.2, blur,2.);\n  uv2 = rot(-0.4) * (uv + vec2(-0.2, 0.));\n  vec4 b3 = body(uv2, c3, 0.2, blur,3.);\n\n  col = stars(uv, normalizedUV.y);\n  col = mix(col, b2, b2.w);\n  col = mix(col, b3, b3.w);\n  col = mix(col, b1, b1.w);\n\n  vec4 flr = flr(uv);\n  col = mix(col, flr, flr.w);\n  return col;\n}\n\nvec4 combine(vec4 a, vec4 b) {\n  return a.z < b.z ? a : b;\n}\n\nvec4 intersect(vec4 a, vec4 b) {\n  return a.z > b.z ? a : b;\n}\n\nvec4 sub(vec4 a, vec4 b) {\n  b.z *= -1.;\n  return intersect(a, b);\n}\n\nvec3 box( vec3 p, vec3 b , float s)\n{\n  vec3 q = abs(p) - b;\n  return vec3(p.x, p.y, length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - s);\n}\n\nvec3 sphere(vec3 p, vec3 c, float r) {\n    p -= c;\n    return vec3(atan(p.x, -p.z) * r, atan(length(p.xz), -p.y) * r, length(p) - r);\n}\n\nvec4 bg(vec3 p) {\n  vec3 op = p;\n  float len = length(p.xy)*0.1;\n  p = rot(p, vec3(0.,  0., iTime * 0.2 + len));\n  p.y += iTime;\n  vec3 p2 = ceil(p);\n  vec3 p1 = fract(p*1.0);\n  p1 -= 0.5;\n  p1=rot_z(p1, -iTime + p2.z);\n  p1.x += cos(p2.y+ iTime)*0.1;\n  p1.y += sin(iTime + p2.z)*0.1;\n  p1.xy = abs(p1.xy);\n  p1=rot_z(p1, PI/1.5);\n  p1.x = abs(p1.x);\n  p1= rot_z(p1, PI/1.5);\n  p1.y = abs(p1.y);\n  p1= rot_z(p1, PI/1.5);\n  p1=rot_y(p1, iTime);\n\n\n  vec3 s = box(p1, vec3(0.2, 0.05, 0.03), 0.1);\n  vec4 res = vec4(s, 2.0);\n  vec3 mask = box(op + vec3(0.0, 0.0, 1.0), vec3(9.0, 9.0, 3.0), 0.);\n  res = sub(res, vec4(mask, 2.0));\n  res.z*=0.9;\n  return res;\n}\n\nvec4 obj(vec3 p) {\n   return combine(vec4(sphere(p, vec3(0), 0.5), 1.0),\n   vec4(sphere(p, vec3(0, 0.5, 0), 0.1), 0.0));\n}\n\nvec4 scene(vec3 p) {\n  vec3 p2 = p;\n  p2.x += cos(-iTime)*0.5;\n  p2.y += sin(iTime)*0.5;\n  p2.z += sin(iTime)*0.3;\n  p2 = rot(p2, vec3(cos(iTime)*0.3,cos(iTime)*0.3, cos(iTime*1.2)*0.3));\n  vec4 o = obj(p2);\n  vec4 b = bg(p);\n return combine(o,b);\n}\n\n\nvec3 normal(vec3 p) {\n  const vec2 step = vec2(0.001, 0.0);\n  float x = scene(p + step.xyy).z - scene(p - step.xyy).z;\n  float y = scene(p + step.yxy).z - scene(p - step.yxy).z;\n  float z = scene(p + step.yyx).z - scene(p - step.yyx).z;\n  return normalize(vec3(x,y,z));\n}\n\nvec3 light(vec3 norm, vec3 view)\n{\n  float viewRim = 1.0 - smoothstep(0.2, 1.5, dot(normalize(norm), -normalize(view)));\n  float a = dot(norm, normalize(vec3(1.1, 1.3, -2)));\n\n  float rim2 = smoothstep(-0.8, 1.0, a);\n  float rim = max(viewRim, rim2);\n  float rim3 = smoothstep(0.9, 1.0, a);\n\n  rim += saturate(rim3);\n  rim3 = pow(rim3, 5.0);\n  return vec3(rim, rim3, viewRim);\n}\n\nvec4 mats(vec3 p, vec4 v, vec3 normal, vec3 view, float d, vec2 s_uv) {\n  vec2 uv = v.xy;\n  float mat = v.w;\n\n  float bumps = cos(uv.x*200.)+sin(uv.y*200.);\n  vec4 ambient_color = vec4(0.86, 0.20, 0.20, 1.0);\n  bumps *= 0.2;\n  bumps = abs(bumps);\n  vec4 bg_color = ambient_color * (1.0 - length(s_uv)*0.8);\n\n  vec4 color = vec4(0.);\n  vec3 rim = vec3(0.);\n  if(mat <= 0.1) {\n    rim = light(normal+bumps, view);\n    color =  vec4(vec3(0.83, 0.68, 0.21), 1.0);\n  } else if (mat <= 1.1) {\n    rim = light(normal+bumps, view);\n    vec2 uv2 = uv;\n    uv *= 1.2;\n    uv.y -= 0.9;\n    uv2.y *= 0.5;\n    uv2.y += 0.5;\n    color = draw_snaliens(uv, uv2);\n  } else if (mat <= 2.1) {\n    rim = light(normal, view);\n    color =  vec4(vec3(1), 1.0);\n  }\n\n  float ambientLight = 1.0 - pow(rim.z, 20.)*0.3;\n  vec4 mainColor = mix(vec4(0.), color + rim.y*0.2 + rim.x * 0.01, rim.x);\n  vec4 objColor =  mix(ambient_color, mainColor + ambient_color*0.05,ambientLight);\n  float fog = pow(smoothstep(15.0, 1.0, d), 1.5);\n  return mix(bg_color, objColor, fog);\n}\n\nvec4 march(vec3 ro, vec3 rd, vec2 uv) {\n  const float STEPS = 60.;\n  const float MIN_DIST = 0.0001;\n  const float MAX_DIST = 15.0;\n\n  float d = 0.0;\n  for(float i = 0.; i < STEPS && d < MAX_DIST; ++i)\n  {\n    vec3 p = ro + d * rd;\n    vec4 s = scene(p);\n    float nD = s.z;\n    d += nD;\n    if(nD < MIN_DIST) return mats(p, s, normal(p), rd, d, uv);\n  }\n\n  return vec4(0.86, 0.20, 0.20, 1.0) * (1.0 - length(uv)*0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 cFrag = gl_FragCoord.xy;\n  vec2 uv = cFrag / iResolution.x;\n  uv.x -= 0.5;\n  uv.y -= 0.5 * iResolution.y/iResolution.x;\n  uv *= cos(iTime*0.25)*0.25 + 1.5;\n\n  vec3 t = vec3(0.);\n  vec3 p = vec3(0.,0., -3.5);\n  vec3 v = normalize(t - p);\n  vec3 r = -cross(v, vec3(0.0, 1.0, 0.0));\n  vec3 u = cross(v, r);\n  v = normalize(v) + r*uv.x + u*uv.y;\n  fragColor = march(p, normalize(v), uv);\n}\n","name":"Image","description":"","type":"image"}]}