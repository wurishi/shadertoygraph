{"ver":"0.1","info":{"id":"NtBSWz","date":"1627572421","viewed":933,"name":"Voxel-Ray Voxel Ray Tracer","username":"ENDESGA","description":"use the mouse to orbit\n\na voxel raytracer using a ray locked to the voxel grid. As if the camera is in voxel space too. Doesn't need 'l = abs(1./dir);'","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["3d","raytracing","voxel","voxeltraversal"],"hasliked":0,"parentid":"stjXzW","parentname":"voxel traversal 3D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define TEXTURE(coords) texture(iChannel0, coords/2000.)\n//#define TEXTURE(coords) texelFetch(Sampler0, ivec2(coords), 0)\n\n#define TWOPI 6.28318530718\n#define PI 3.14159265359\n\nconst ivec3 lowerCorner = ivec3(-1);\nconst ivec3 size = ivec3(4, 4, 4);\nconst int[] blocks = int[size.x*size.y*size.z](\n    1,1,1,1,\n    1,1,1,1,\n    1,1,1,1,\n    1,1,1,1,\n    \n    1,0,0,1,\n    0,0,0,0,\n    0,0,0,0,\n    0,1,1,1,\n    \n    0,0,0,1,\n    0,0,0,0,\n    0,0,0,0,\n    0,0,1,1,\n    \n    0,0,0,1,\n    0,0,0,1,\n    0,0,0,1,\n    1,1,1,1\n);\n\nmat3 rotation(float x, float y) {\n    return mat3(\n        1, 0, 0, \n        0, cos(x), sin(x),\n        0, -sin(x), cos(x)\n    ) * mat3(\n        cos(y), 0, -sin(y),\n        0, 1, 0,\n        sin(y), 0, cos(y)\n    );\n}\n\nint getBlock(ivec3 p) {\n    p -= lowerCorner;\n    if (\n        any(greaterThan(ivec3(0), p))||\n        any(greaterThanEqual(p, size)))\n        return 0;\n    else {\n        return blocks[\n            p.z + \n            p.x * size.x + \n            p.y * size.x * size.y];\n    }\n}\n\n// if you make this 0, then it'll use voxel-rays that are the size of the voxels\n#define VOXEL_DETAIL 4\n\nivec2 Traverse(ivec3 start, vec3 dir, out ivec3 pos) {\n    \n    //\n    \n    int x1 = int(start.x), y1 = int(start.y), z1 = int(start.z);\n    int x2 = int(dir.x * 2048.) + x1, y2 = int(dir.y * 2048.) + y1, z2 = int(dir.z * 2048.) + z1;\n    \n    int xd = (x2 - x1), yd = (y2 - y1), zd = (z2 - z1);\n    int xp = (x1 << 16) + 0x8000, yp = (y1 << 16) + 0x8000, zp = (z1 << 16) + 0x8000;\n    int xpr = xp, ypr = yp, zpr = zp;\n\t\n    int a = max(abs(xd), max(abs(yd), abs(zd))); // a must not = 0\n\tint xs = ((xd << 16) / a), ys = ((yd << 16) / a), zs = ((zd << 16) / a);\n    \n    int hit = 0;\n    int block = 0;\n\n\twhile (a-- >= 0) {\n    \n        \n        \n        pos = ivec3(((xpr + xs) >> 16), ((ypr + ys) >> 16), ((zpr + zs) >> 16));\n                \n                // Uncomment to show you can check sub-voxels\n        block = //getBlock(((pos + ivec3(-1,0,0)) >> 2)) +\n                //getBlock(((pos + ivec3(1,0,0) ) >> 2)) +\n                //getBlock(((pos + ivec3(0,-1,0)) >> 2)) +\n                //getBlock(((pos + ivec3(0,1,0) ) >> 2)) +\n                //getBlock(((pos + ivec3(0,0,-1)) >> 2)) +\n                //getBlock(((pos + ivec3(0,0,1) ) >> 2)) +\n                getBlock((pos >> 2));\n        if (block > 0) {\n            if (hit > 0) return ivec2(block, 1);\n        \n            hit++;\n            \n            xp -= xs;\n            yp -= ys;\n            zp -= zs;\n            \n            xs >>= 1;\n            ys >>= 1;\n            zs >>= 1;\n        }\n        \n        xpr = xp;\n        ypr = yp;\n        zpr = zp;\n        \n        //xs >>= 1;\n        //ys >>= 1;\n        //zs >>= 1;\n        \n\t\txp += xs >> 3;\n\t\typ += ys >> 3;\n        zp += zs >> 3;\n\t};\n    \n    return ivec2(block, 1);\n    \n    //\n    \n    return ivec2(0);\n}\n\nvec4 colorAt(ivec3 ro, vec3 rd, ivec3 center, out float depth) {\n    ro -= center;\n    vec3 col = vec3(0);\n    ivec3 pos;\n    ivec2 traversed = Traverse(ro, rd, pos);\n    int block = traversed.x;\n    \n    if (block != 0) {\n        vec4 texCol = vec4(1.0);\n        col = mix(col, texCol.rgb, texCol.a);\n        return vec4(((col / pow(length(vec3(pos-ro)),2.)) * 29.0) + vec3(0.25), 1); // also has depth to camera\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    if (iMouse.xy == vec2(0))\n        m = vec2(0.5,0.5);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord - iResolution.xy * .5)/iResolution.xx)*4.;\n    float near = 1.;\n    mat3 rotation = rotation(PI * (m.y - .5), -TWOPI * (m.x-.5));\n    vec3 rd = normalize(vec3(uv, near) * rotation);\n    ivec3 ro = ivec3(vec3(0) - vec3(0, 0, 1)*rotation* 14.);\n    float depth;\n    vec3 col = colorAt(ro, rd, ivec3(0), depth).rgb;\n    \n    // Output to screen\n    fragColor = vec4(((col*col)+col)*.5,1.0);\n}","name":"Image","description":"","type":"image"}]}