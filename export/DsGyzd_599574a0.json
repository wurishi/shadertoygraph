{"ver":"0.1","info":{"id":"DsGyzd","date":"1696450333","viewed":33,"name":"04. Dodge","username":"Ladus","description":"Inktober 2023 Day 4. The red dot tries to dodge all the white spheres. It sometimes teleports :(","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dodge","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash12 By Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// The rest is by me~\nvec2 normalizeScreenSpace(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 1.-(iResolution.y/iResolution.x);\n    return uv;\n}\n\nvec2 Noise(vec2 s) {\n    return vec2(hash12(s),hash12(s+vec2(3.245,2.144)));\n}\n\nvec2 GetNeighborVector(vec2 offset, vec2 li) {\n    vec2 wI = li + offset;\n    vec2 wRandomVector = Noise(wI);\n    return wI + wRandomVector;\n}\n\nfloat distanceFromNeighbor(vec2 neighbor, vec2 li, vec2 l) {\n    vec2 wLs = GetNeighborVector(neighbor, li);\n    return 1.-distance(l, wLs);\n}\n\n\nfloat Spheres(vec2 s) {\n\n    s.y -= iTime*0.4;\n\n    vec2 l = s * 1.;\n    vec2 li = floor(s*1.);\n    \n    vec2 randomVector = Noise(li);\n    vec2 ls = li + randomVector;\n    \n    float distanceFromCenter = 1.-distance(l, ls);\n    float result = distanceFromCenter;\n    \n    float distanceFromN = distanceFromNeighbor(vec2(0., 1.), li, l);\n    result = max(result, distanceFromN);\n    float distanceFromNE = distanceFromNeighbor(vec2(1., 1.), li, l);\n    result = max(result, distanceFromNE);\n    float distanceFromE = distanceFromNeighbor(vec2(1., 0.), li, l);\n    result = max(result, distanceFromE);\n    float distanceFromES = distanceFromNeighbor(vec2(1., -1.), li, l);\n    result = max(result, distanceFromES);\n    float distanceFromS = distanceFromNeighbor(vec2(0., -1.), li, l);\n    result = max(result, distanceFromS);\n    float distanceFromSW = distanceFromNeighbor(vec2(-1., -1.), li, l);\n    result = max(result, distanceFromSW);\n    float distanceFromW = distanceFromNeighbor(vec2(-1., 0.), li, l);\n    result = max(result, distanceFromW);\n    float distanceFromNW = distanceFromNeighbor(vec2(-1., 1.), li, l);\n    result = max(result, distanceFromNW);\n\n    return pow(result,2.);\n}\n\nvec2 getLocationAlongVector(vec2 a, vec2 b, float percentageOnVector){\n    float d = distance(a,b);\n    vec2 direction = normalize(b-a);\n    return a+(direction*d*percentageOnVector);\n}\n\nvec2 getLowestPointBetween(vec2 a, vec2 b) {\n    float lowestPoint = 1.;\n    vec2 lowestLocation = a;\n    for(float i = 0.; i < 1.; i += 0.005) {\n        vec2 iterationLocation = getLocationAlongVector(a, b, i);\n        \n        float gradientValue = Spheres(iterationLocation);\n        if(gradientValue < lowestPoint) {\n            lowestPoint = gradientValue;\n            lowestLocation = iterationLocation;\n        }\n    }\n    return lowestLocation;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = normalizeScreenSpace(fragCoord);\n        \n    vec2 a = vec2(-0.3, 0.25);\n    vec2 b = vec2(1.3, 0.25);\n    \n    float distanceFromLowestPoint = step(0.98,1.-distance(getLowestPointBetween(a, b), s));\n    \n    float spheres = Spheres(s);\n    float sphereSize = 1.-0.7;\n    float background = smoothstep(sphereSize,sphereSize + 0.01, spheres);\n    \n    vec3 spheresColor = vec3(background,background,background);\n    vec3 dodgerColor = vec3(distanceFromLowestPoint,0.,0.);\n    \n    // Output to screen\n    fragColor = vec4(spheresColor+dodgerColor,1.0);\n}","name":"Image","description":"","type":"image"}]}