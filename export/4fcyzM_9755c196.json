{"ver":"0.1","info":{"id":"4fcyzM","date":"1730372335","viewed":20,"name":"Bolas Girando","username":"JoaoLucasMBC","description":"Project 2 for the Computer Graphics Course @ Insper","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["compgraf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random(vec2 st)\n{\n    vec2 val = vec2(dot(st.xy,vec2(12.9898,78.233)));\n    return fract(sin(val)*43758.5453123);\n}\n\nfloat noise(vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float u00 = dot(random(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n    float u10 = dot(random(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n    float u11 = dot(random(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n    float u01 = dot(random(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n    \n    // Fator para interpolação, usando interpolação de hermite\n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float utop = mix(u00, u10, u.x);\n    float ubottom = mix(u01, u11, u.x);\n    \n    float ufinal = mix(utop, ubottom, u.y);\n    \n    return ufinal;\n}\n\nvec3 getColor(vec2 cellPos) \n{\n    // Funcao feita com apoio do ChatGPT\n    \n    // Gera duas cores para fazer uma interpolação e transição suave\n    float r1 = fract(sin(dot(cellPos + floor(iTime * 0.3), vec2(12.9898, 78.233))) * 43758.5453);\n    float g1 = fract(sin(dot(cellPos + floor(iTime * 0.3), vec2(24.5467, 34.897))) * 43758.5453);\n    float b1 = fract(sin(dot(cellPos + floor(iTime * 0.3), vec2(45.233, 89.123))) * 43758.5453);\n    \n    float r2 = fract(sin(dot(cellPos + floor(iTime * 0.3) + 1.0, vec2(12.9898, 78.233))) * 43758.5453);\n    float g2 = fract(sin(dot(cellPos + floor(iTime * 0.3) + 1.0, vec2(24.5467, 34.897))) * 43758.5453);\n    float b2 = fract(sin(dot(cellPos + floor(iTime * 0.3) + 1.0, vec2(45.233, 89.123))) * 43758.5453);\n    \n    // Mix das cores\n    float blend = fract(iTime * 0.3);\n    vec3 color1 = vec3(r1, g1, b1);\n    vec3 color2 = vec3(r2, g2, b2);\n    vec3 blendedColor = mix(color1, color2, blend);\n\n    return blendedColor;\n}\n\n\nfloat circle(vec2 uv, vec2 center, vec2 cellPos, float r, float k)\n{\n    // ideia: user uma fração do noise por pixel para dar uma deformada em cada bolinha\n    float deformationX = noise(cellPos + uv * 3.0 + vec2(0.0, iTime * 0.5)) * 0.4;\n    float deformationY = noise(cellPos + uv * 3.0 + vec2(iTime * 0.5, 0.0)) * 0.4;\n\n    uv.x += deformationX;\n    uv.y += deformationY;\n\n    return 1.0 - smoothstep(r, r + k, length(uv + center));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord / iResolution.xy;\n\n    // Tamanho do grid\n    float gridSizeX = 5.0;\n    float gridSizeY = 5.0;\n\n    // Aspect ratio para alinhar as cells\n    float aspect = iResolution.x / iResolution.y;\n\n    // Tamanho de cada cell de acordo com o grid\n    vec2 cellSize = vec2(1.0 / gridSizeX, 1.0 / gridSizeY);\n\n    // Posição na celula\n    vec2 cellPos = floor(st / cellSize);\n    vec2 uv = fract(st / cellSize) - 0.5;\n    uv.x *= aspect; // Correção com aspect\n\n    // Para ajustar o raio das bolinhas\n    float circleRadius = min(cellSize.x, cellSize.y) * 0.8;\n\n    float timeOffset = noise(cellPos + vec2(2.0, 2.0)) * 5.0;\n\n    vec3 finalColor = vec3(0.0);\n\n    for (int j = 0; j < 3; j++) {\n        // Noise para as posicoes de cada bola\n        float nsx = noise(cellPos + float(j) * vec2(12.9898, 78.233)) * 2.0 - 1.0;\n        float nsy = noise(cellPos + float(j) * vec2(45.233, 25.89)) * 2.0 - 1.0;\n\n        vec2 center = vec2(\n            sin(nsx * iTime * 1.2 + timeOffset) * 0.25,\n            cos(nsy * iTime * 1.2 + timeOffset) * 0.25  \n        );\n\n        // Gera o circulo atual\n        float c = circle(uv, center, cellPos, circleRadius, 2.0 / iResolution.y);\n\n        // Gera a cor do circulo\n        vec3 color = getColor(cellPos + float(j) * 0.1);\n        \n        // Incrementa a saída\n        finalColor += color * c;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}