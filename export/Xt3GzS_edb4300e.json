{"ver":"0.1","info":{"id":"Xt3GzS","date":"1469866863","viewed":297,"name":"World Sphere","username":"kig","description":"Visual prototyping for a VR demo","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","csg","prototyping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float AA_SIZE = 2.0;\n\nconst int RAY_STEPS = 60;\nconst float THRESHOLD = 0.001;\nconst float MAX_DISTANCE = 100.0;\n\n\nstruct material {\n    vec3 transmit;\n    vec3 emission;\n};\n    \nstruct csgHit {\n    float closest;\n    vec3 closestNormal;\n    float furthest;\n    vec3 furthestNormal;\n    material mat;\n};\n\nvec2 phaseVec(float t){\n    float phase = t*0.7/3.14159;\n    float pt = fract(phase);\n    phase = mod(floor(phase), 3.0);\n    return vec2(phase, pt);\n}\n\nfloat lightPhase(float t) {\n    vec2 phase = phaseVec(t);\n    float f = 0.0;\n    if (phase.x == 2.0 && phase.y > 0.5) {\n        f = pow(2.0 * (phase.y - 0.5), 2.5);\n    }\n    if (phase.x == 0.0 && phase.y < 0.5) {\n        f = pow(2.0*(0.5-phase.y), 1.5);\n    }\n    return f;\n}\n\nvec3 bgLight() {\n    return normalize(vec3(\n        0.0,\n        -lightPhase(iTime)-0.1, \n        1.0\n    ));\n}\n\n#define TEXTURE_NOISE 1\n#ifdef TEXTURE_NOISE\n\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// Old map\nfloat map( in vec3 p )\n{\n\tvec3 q = p + 0.2*vec3(-1.0, 1.0, 2.2)*iTime;\n\tfloat f;\n    f = 0.500*noise( q ); q = q*2.0;\n    f += 0.25*noise( q ); q = q*2.0;\n    f += 0.125*noise( q ); q = q*2.0;\n    //f += 0.0625*noise( q ); q = q*2.0;\n    //f += 0.03125*noise( q ); q = q*2.0;\n    //f += 0.015625*noise( q );\n\treturn f;\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 sun = lightPhase(iTime) * vec3(1.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight());\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.2, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.7);\n\tbgCol += vec3(0.2, 0.8, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += lightPhase(iTime) * vec3(0.5, 0.8, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight().y)*128.0));\n    bgCol += vec3(1.2,0.4,0.9) * ((1.0-pow(abs(bgDiff), 0.6)));// * 1.0 * map(-nml) * map(-nml*nml.y));\n\n    vec2 phase = phaseVec(iTime);\n    float cloudF = max(0.0, phase.x - 1.0);\n    if (phase.x == 1.0 && phase.y > 0.5) {\n        cloudF = pow(2.0*(phase.y - 0.5), 2.5);\n    }\n    if (phase.x == 0.0 && phase.y < 0.5) {\n        cloudF = pow(2.0*(0.5-phase.y), 2.0);\n    }\n\n    float cloudFac = pow(max(0.0, bgDiff), 0.8)*1.0;\n    float ufCloudCover = cloudF * 0.5;\n    float cc = pow(ufCloudCover, 1.25) * 1.5;\n    float cloud = 0.0;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*1.03/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*3.0/nml.y)))) * 0.3;\n    bgCol *= 1.0+cloudFac*cloud;\n\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n    \n\n\n// Old scene, keep this!\nfloat scene(vec3 p, float phase, float pt)\n{\n    float f = min(1.0, phase + pow(2.0 * abs(pt - 0.5), 3.0));\n\treturn pow(map(p/20.0), 3.0)*-min(pow(0.05*length(p.xz), 7.0), f*120.0)+7.0+p.y*p.y;\n}\n\n#else \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\n// By NIMITZ  (twitter: @stormoid)\n// good god that dudes a genius...\n\nfloat tri( float x ){ \n  return abs( fract(x) - .5 );\n}\n\nvec3 tri3( vec3 p ){\n \n  return vec3( \n      tri( p.z + tri( p.y * 1. ) ), \n      tri( p.z + tri( p.x * 1. ) ), \n      tri( p.y + tri( p.x * 1. ) )\n  );\n\n}\n                                 \nfloat triNoise3D( vec3 p, float spd, float time){\n  \n\tfloat z  = 1.4;\n\tfloat rz =  0.;\n\tvec3  bp =   p;\n\n\tfor( float i = 0.; i <= 3.; i++ ){\n   \n    vec3 dg = tri3( bp * 2. );\n    p += ( dg + time * .1 * spd );\n\n    bp *= 1.8;\n\t\tz  *= 1.5;\n\t\tp  *= 1.2; \n      \n    float t = tri( p.z + tri( p.x + tri( p.y )));\n    rz += t / z;\n    bp += 0.14;\n\n\t}\n\n\treturn rz;\n\n}\n\nfloat map( in vec3 p, in vec3 offset )\n{\n\tfloat f;\n    vec3 q = (p + offset);\n    f = 1.75 * triNoise3D( 0.05 * q, 1.0, 0. );\n\treturn f;\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 sun = lightPhase(iTime) * vec3(1.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight());\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.2, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.7);\n\tbgCol += vec3(0.2, 0.8, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += lightPhase(iTime) * vec3(0.5, 0.8, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight().y)*128.0));\n    bgCol += vec3(1.2,0.4,0.9) * ((1.0-pow(abs(bgDiff), 0.6)));// * 1.0 * map(-nml) * map(-nml*nml.y));\n\n    vec2 phase = phaseVec(iTime);\n    float cloudF = max(0.0, phase.x - 1.0);\n    if (phase.x == 1.0 && phase.y > 0.5) {\n        cloudF = pow(2.0*(phase.y - 0.5), 2.5);\n    }\n    if (phase.x == 0.0 && phase.y < 0.5) {\n        cloudF = pow(2.0*(0.5-phase.y), 2.0);\n    }\n\n    float cloudFac = pow(max(0.0, bgDiff), 0.8)*1.0;\n\n    float ufCloudCover = cloudF * 0.5;\n    float cc = pow(ufCloudCover, 1.25) * 1.5;\n\n    float cloud = 0.0;\n    vec3 offset = 0.2*vec3(-1.0, 1.0, 2.2)*iTime;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml/nml.y, offset)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*1.03/nml.y, offset)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*3.0/nml.y, offset)))) * 0.3;\n    bgCol *= 1.0+cloudFac*cloud;\n\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat scene(vec3 p, float phase, float pt)\n{\n    float f = min(1.0, phase + pow(2.0 * abs(pt - 0.5), 3.0));\n    p.x = abs(p.x);\n\treturn pow(map(p/20.0, vec3(9.5)), 3.0)*-f*19.0+9.0+p.y*p.y;\n}\n\n#endif\n    \nfloat sphereDet(vec3 ray, vec3 dir, vec3 center, float radius, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\ncsgHit sphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, material m)\n{\n\tfloat b;\n\tfloat d = sphereDet(ray, dir, center, radius, b); // 7\n\tif (d < 0.0) { // 1\n        return csgHit(closestHit, vec3(0.0), closestHit, vec3(0.0), m);\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\n    vec3 nmlNear = center - (ray+dir*t);\n    vec3 nmlFar = (ray+dir*(t+2.0*sqrt(d))) - center;\n    return csgHit(t, nmlNear, t + 2.0*sqrt(d), nmlFar, m);\n}\n\n\nfloat triangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, float closestHit, material m, inout vec3 nml, inout material dst, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\t\n\tif (u < 0.0 || u > 1.0 || v < 0.0 || u+v > 1.0) {\n\t\treturn closestHit;\n\t}\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\t\n    if (t > closestHit || t <= 0.00001 || (a > -0.00001 && a < 0.00001)) {\n        return closestHit;\n    }\n    \n    nml = normalize(cross(e1, e2));\n    if (dot(nml, d) < 0.0) {\n        nml = -nml;\n    }\n    dst = m;\n\tuv = vec2(u,v);\n\n    return t;\n}\n\n\nfloat plane(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tfloat pd = dot(pnml, rd);\n\tfloat dist = dot(pnml, p-rp) / pd;\n\tif (abs(pd) > 0.00001 && dist > 0.0 && dist < closestHit) {\n\t\tnml = pnml;\n\t\tif (pd < 0.0) nml = -nml;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\nfloat disk(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float r1, float r2, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tvec3 tmp;\n    material tmpMat;\n\tfloat dist = plane(rp, rd, p, pnml, closestHit, m, tmp, tmpMat);\n\tfloat len = length(rp + dist*rd - p);\n\tif (dist < closestHit && len >= r1 && len <= r2) {\n\t\tnml = tmp;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\n// from http://stackoverflow.com/questions/4078401/trying-to-optimize-line-vs-cylinder-intersection\nfloat cylinder(vec3 ro, vec3 rd, vec3 cp, vec3 cd, float r, float h, float closestHit, material m, inout vec3 nml, inout material dst) {\n\n    vec3 rc = ro - cp;\n    vec3 n = cross(rd, cd);\n\n    float len = length(n);\n\n    // Parallel? (?)\n    if(len < 0.00001 && len > -0.00001) {\n        return closestHit;\n    }\n\n    n = normalize(n);\n\n    float d = abs(dot(rc, n));\n\n    if (d > r) return closestHit;\n\n    vec3 o = cross(rc, cd);\n    float t = -dot(o, n) / len;\n    o = normalize(cross(n, cd));\n    float s = abs( sqrt(r*r-d*d) / dot(rd, o) );\n    float inD = t-s;\n    float outD = t+s;\n    float lambda = outD;\n\n    if (inD < -0.00001) {\n        if(outD < -0.00001) {\n            return closestHit;\n        }\n    } else if (outD < -0.00001 || inD < outD) {\n        lambda = inD;\n    }\n\n    vec3 hbF = (ro + rd*max(inD, outD)) - cp;\n    vec3 hb = (ro + rd*lambda) - cp;\n\tfloat md = h*h+r*r;\n\n    closestHit = disk(ro, rd, cp + cd * h, cd, 0.0, r, closestHit, m, nml, dst);\n    closestHit = disk(ro, rd, cp - cd * h, cd, 0.0, r, closestHit, m, nml, dst);\n\n\tif (\n        (dot(hb, hb) < md || dot(hbF, hbF) < md) &&\n\t\t(dot(hb, hb) < md && lambda < closestHit)\n    ) \n   \t{\n        float scale = dot(hb, cd);\n        nml = -normalize(hb - cd*scale);\n        dst = m;\n\n        closestHit = lambda;\n    }\n\n    return closestHit;\n}\n\n\n// iq's box ray tracing function\n// returns t and normal\nfloat iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, float closestHit, material mat, inout vec3 nml, inout material dst) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0 || tN > closestHit) return closestHit;\n\n\tnml = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnml = (txi * vec4(nml,0.0)).xyz;\n    dst = mat;\n\n\treturn tN;\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( vec3 v )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t v.x, v.y, v.z, 1.0 );\n}\n\nmat4 inv( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\nvec3 normal(vec3 p, float phase, float pt, float d)\n{\n\tfloat e = 0.3;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p, phase, pt) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p, phase, pt) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p, phase, pt) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nfloat raymarchScene(in vec3 ro, in vec3 rd, vec2 phase, float closestHit, inout vec3 nml, inout material m) {\n    vec3 p = ro;\n    for (int i=0; i<RAY_STEPS; i++) {\n        float dist = scene(p, phase.x, phase.y);\n        if (dist < THRESHOLD) {\n            nml = normal(p, phase.x, phase.y, dist);\n            m = material(vec3(1.0), vec3(0.0));\n            return length(ro - p);\n        }\n        if (dist > MAX_DISTANCE) {\n            return closestHit;\n        }\n        p += dist * rd;\n    }\n    return closestHit;\n}\n\nfloat rtScene(inout vec3 ro, inout vec3 rd, inout vec3 nml, inout material m) {\n    float closestHit = 1e5;\n    float t = iTime * 1.12346;\n    material red, blue, white;\n\n    vec2 phase = phaseVec(iTime);\n\n    red.transmit = vec3(0.9, 0.7, 0.6);\n    red.emission = vec3(0.0);\n\n    blue.transmit = vec3(0.9);\n    blue.emission = 1.5*vec3(0.8, 0.3, 0.1);\n\n    white.transmit = vec3(0.95);\n    white.emission = vec3(0.0);\n    \n    vec2 uv = vec2(0);\n    \n    float f = 0.5 - 0.5*cos(phase.y * 3.14159 * 2.0 + 3.14159);\n\n    vec3 spherePos = mix(vec3(0.0, 3.0, -4.0), vec3(0.0), f);\n    spherePos.y = 3.0 * pow(1.0-f, 2.0);\n    spherePos.x = 3.0 * sin(iTime)*pow(abs(0.25-f)-0.25, 1.0);\n\n    float r = clamp(0.0, 1.0, 1.0 - 0.5*abs(length(spherePos) - 3.0));\n    \n    csgHit bigSphere = sphere(ro, rd, vec3(0.0, 0.0, 0.0), 3.0, closestHit, red);\n    csgHit smallSphere = sphere(ro, rd, spherePos, 1.0, closestHit, red);\n\n    if (bigSphere.closest < smallSphere.closest || bigSphere.closest > smallSphere.furthest) {\n        if (bigSphere.closest > 0.0 && bigSphere.closest < closestHit) {\n\t        closestHit = bigSphere.closest;\n            m = bigSphere.mat;\n            nml = bigSphere.closestNormal;\n        }\n    } else if (smallSphere.furthest < bigSphere.furthest) {\n        if (smallSphere.furthest > 0.0 && smallSphere.furthest < closestHit) {\n\t        closestHit = smallSphere.furthest;\n            m = smallSphere.mat;\n            nml = smallSphere.furthestNormal;\n        }\n    }\n    \n    closestHit = disk(ro, rd, normalize(spherePos)*(3.15+2.0*(abs(r-0.5))), normalize(spherePos), r*1.3, r*1.6, closestHit, blue, nml, m);\n    closestHit = disk(ro, rd, normalize(spherePos)*3.0, normalize(spherePos), r*2.85, r*3.5, closestHit, blue, nml, m);\n\n    closestHit = cylinder(ro, rd, vec3(0.0, 7.0, -4.0), vec3(0.0, 1.0, 0.0), 1.0, 3.0, closestHit, red, nml, m); \n\n    if (phase.x == 0.0) {\n        mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime*4.0 );\n        mat4 tra = translate( spherePos );\n        mat4 txi = tra * rot; \n        mat4 txx = inverse( txi );\n        vec3 rad = vec3(0.5, 0.5, 0.5);\n\n        closestHit = iBox(ro, rd, txx, txi, rad, closestHit, red, nml, m);\n    } else {\n\t\n        csgHit smallSphere2 = sphere(ro, rd, spherePos, 0.5, closestHit, red);\n\n        if (smallSphere2.closest > 0.0 && smallSphere2.closest < closestHit) {\n            closestHit = 0.0;\n            if (phase.x == 1.0) {\n                float d = (dot(rd, smallSphere2.closestNormal));\n                m.transmit = vec3(1.0 - pow(d,0.5));\n                m.emission = vec3(pow(d,0.5));\n\n                ro += (smallSphere2.closest) * rd;\n                rd = normalize(refract(rd, smallSphere.closestNormal, 1.5));\n                ro += ((smallSphere2.furthest-smallSphere2.closest)*1.201) * rd;\n            } else {\n                float d = (dot(rd, smallSphere2.closestNormal));\n                m.transmit = max(vec3(0.0), vec3(1.0 - pow(d*1.82,2.0)));\n                m.emission = vec3(2.0,1.3,1.0) * (1.0-m.transmit);\n\n                ro += (smallSphere2.furthest) * rd;\n                rd = normalize(d*d * -(ro-spherePos) + rd);\n            }\n            nml = vec3(0.0);\n        }\n    }\n\n    if (closestHit >= 1e5) {\n        closestHit = raymarchScene(ro, rd, phase, closestHit, nml, m);\n        if (closestHit < 1e5) {\n            ro += closestHit * rd;\n            rd = normalize(reflect(rd, nml));\n            ro += rd * THRESHOLD * 600.0;\n\t        nml = cross(vec3(1.0), rd);\n        }\n    }\n\n    \n    return closestHit;\n}\n\n\nvec3 trace(vec2 xy) {\n    vec2 uv = 1.0 - 2.0 * xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 1.6, -8.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float xAngle = iMouse.x > 0.0 ? 8.0*(iMouse.x/iResolution.x - 0.5) : 0.0;\n    float yAngle = iMouse.y > 0.0 ? -2.0*(iMouse.y/iResolution.y - 0.5) : 0.0;\n    mat4 rotX = rotationAxisAngle(vec3(0.0, 1.0, 0.0), xAngle);\n    mat4 rotY = rotationAxisAngle(vec3(1.0, 0.0, 0.0), yAngle);\n    ro = (rotX * rotY * vec4(ro, 1.0)).xyz;\n    rd = (rotX * rotY * vec4(rd, 0.0)).xyz;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 nml = vec3(1.0);\n    material m;\n    vec3 transmit = vec3(1.0);\n    float fog = 0.0;\n    vec3 fogColor = vec3(0.25, 0.3, 0.4);\n\n    for (int i = 0; i < 6; i++) {\n\t    float closestHit = rtScene(ro, rd, nml, m);\n\t    if (closestHit < 1e5) {\n            fog += closestHit;\n            ro += rd * closestHit;\n            if (length(nml) > 0.0) {\n                nml = normalize(nml);\n                rd = reflect(rd, nml);\n            }\n            col += transmit * m.emission;\n            transmit *= m.transmit;\n            ro += rd * 0.001;\n        } else {\n            fog = i == 0 ? 0.0 : fog;\n            col += transmit * 0.2 * shadeBg(rd, xy);\n            break;\n        }\n    }\n    return mix(col, fogColor, min(1.0, pow(fog * 0.002, 0.6)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = vec3(0.0);\n    for (float x=0.0; x<AA_SIZE; x++) {\n        for (float y=0.0; y<AA_SIZE; y++) {\n\t\t    col += trace(fragCoord.xy + vec2(x/AA_SIZE, y/AA_SIZE));\n        }\n    }\n\tfragColor = vec4(col / (AA_SIZE*AA_SIZE), 1.0);\n}","name":"Image","description":"","type":"image"}]}