{"ver":"0.1","info":{"id":"wllXz7","date":"1570115975","viewed":76,"name":"Ray Marching test yeah","username":"killereks","description":"testing ray marching ;/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float opUnion(float d1, float d2){\n\treturn min(d1,d2);\n}\nfloat opSub(float d1, float d2){\n\treturn max(-d1, d2);\n}\nfloat opInter(float d1, float d2){\n\treturn max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat lerp(float a, float b, float t){\n\treturn a + (b - a) * t;\n}\n\nfloat DE(vec3 pos) {\n    int Iterations = 128;\n    float Bailout = 3.0f;\n    float Power = 1.0f * iTime * 0.5;\n    \n    if (Power > 10.0) Power += 10.0;\n    \n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 1.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat GetDistance(vec3 pos){\n    //return DE(pos);\n    float planeFrequency = 0.01 * iTime; // 0.5\n    \n\tvec3 spherePos = vec3(0.0,0.0,-1.0 * iTime * iTime * iTime - 50.0);\n    float sphereRadius = sin(iTime) * sin(iTime) * 5.0 + 2.0;\n    spherePos.y -= sphereRadius;\n    \n    vec3 sphere2Pos = vec3(cos(iTime) * 3.0,-10.5,-1.0 * iTime * iTime * iTime - 50.0);\n    float sphere2Radius = 5.0;\n    \n    float angle = pos.x + pos.y + pos.z;\n    float offset = sin(angle * iTime) * 0.1;\n    \n    float sphereDist = length(pos - spherePos) - sphereRadius + offset;\n    float sphere2Dist = length(pos - sphere2Pos) - sphere2Radius;\n    \n    float planeAngle = pos.x - pos.z + iTime + cos(pos.x);\n    float planeDist = 5.0 - pos.y - cos(planeAngle * planeFrequency) * 2.0 + cos(pos.x + pos.y) * 2.0;\n    \n    float smallestDist = opSmoothSub(sphereDist, sphere2Dist, 1.0);\n    smallestDist = opUnion(smallestDist, planeDist);\n    \n    //return smallestDist;\n    \n    // infinite amount of spheres\n    float spacing = 20.0;// * iTime;//15.0;\n    \n    pos = mod(pos,spacing) - vec3(spacing * 0.5);\n    return length(pos) - 4.0;\n    \n}\n\nfloat RayMarchShadow(vec3 rayOrigin, vec3 rayDir){\n    float total_distance = 0.0;\n    int number_of_steps = 256;\n    float minimum_hit_distance = 0.001;\n    float maximum_trace_distance = 1000.0;\n    \n    for (int i = 0; i < number_of_steps; i++){\n    \tvec3 curPos = rayOrigin + rayDir * total_distance;\n        \n        float dist = GetDistance(curPos);\n        \n        if (dist < minimum_hit_distance || total_distance > maximum_trace_distance){\n        \tbreak;\n        }\n        \n        total_distance += dist;\n    }\n    return total_distance;\n}\n\nvec3 Normal(vec3 pos){\n\tfloat smallStep = 0.001;\n    \n    float x = GetDistance(pos + vec3(smallStep,0,0)) - GetDistance(pos - vec3(smallStep,0,0));\n    float y = GetDistance(pos + vec3(0,smallStep,0)) - GetDistance(pos - vec3(0,smallStep,0));\n    float z = GetDistance(pos + vec3(0,0,smallStep)) - GetDistance(pos - vec3(0,0,smallStep));\n    \n    return normalize(vec3(x,y,z));\n}\n\nfloat CalculateLight(vec3 pos, vec3 cameraRayDir){\n    vec3 lightPos = vec3(0.0, -10.0, 10.0);\n\tvec3 normal = Normal(pos);\n    \n    vec3 dirToLight = normalize(lightPos - pos);\n    float distToLight = length(dirToLight);\n    \n    float intensity = max(0.0,dot(dirToLight, normal))/(distToLight * distToLight + 1.0) * 2.0;\n    \n    // specular light\n    intensity += min(0.5,max(0.0,pow(dot(cameraRayDir, normal), 8.0)));\n    \n    //float intensity = dot(vec3(cos(iTime),sin(iTime),0.0),normal);\n    //return intensity;\n    \n    // calculate if we should cast a shadow\n    vec3 newPos = pos + normal * 0.3;\n    float newDist = RayMarchShadow(newPos, dirToLight);\n    \n    // we hit something\n    if (newDist < length(lightPos - newPos)){\n    \tintensity *= 0.1;\n    }\n    \n    return intensity;\n}\n\nvec3 RayMarch(vec3 rayOrigin, vec3 rayDir){    \n\tfloat total_distance = 0.0;\n    int number_of_steps = 512;\n    float minimum_hit_distance = 0.001;\n    float maximum_trace_distance = 1000.0;\n    bool glow = true;\n    \n    float minAllTime = maximum_trace_distance;\n    \n    for (int i = 0; i < number_of_steps; i++){\n    \tvec3 curPos = rayOrigin + rayDir * total_distance;\n        \n        float dist = GetDistance(curPos);\n        \n        minAllTime = min(minAllTime, dist);\n        \n        if (dist < minimum_hit_distance){\n            return vec3(0.6,0.2,0.5) * CalculateLight(curPos, rayDir);\n        \t//return vec3(1.0,1.0,1.0) * CalculateLight(curPos);\n            \n            //return vec3(cos(curPos.x),sin(curPos.y),tan(curPos.z)) * CalculateLight(curPos);\n        }\n        else if (total_distance > maximum_trace_distance){\n        \tbreak;\n        }\n        total_distance += dist;\n    }\n    if (glow){\n    \treturn vec3(0.0,0.0,0.0) + vec3(0.56,0.27,0.68)/minAllTime / 100.0;\n    }\n    return vec3(0.0);\n}\n\nvec3 EachPixel(vec3 cameraPos, vec2 pos){\n    float FOV = 2.0; // 1.57\n    if (iTime > 10.0){\n    \tFOV -= (iTime - 10.0);\n    }\n    FOV = min(FOV,2.5);\n    FOV = max(FOV, 0.2);\n    \n\tfloat Px = (2.0 * ((pos.x + 0.5) / iResolution.x) - 1.0) * tan(FOV * 0.5);\n    float Py = (1.0 - 2.0 * ((pos.y + 0.5) / iResolution.y)) * tan(FOV * 0.5);\n    \n    return RayMarch(cameraPos, vec3(Px, Py, -1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 cameraPos = vec3(0.0,-7.5, 15.0);\n    \n    cameraPos = vec3(0.0,0.0,1.0);\n    cameraPos.x = min(1.0, iTime * 0.1);\n    \n    //cameraPos.z = sin(iTime) * 2.0 + 10.0;\n    //cameraPos.y = -sin(iTime) * sin(iTime) * 1.0;\n    //cameraPos.z = 15.0;\n    //cameraPos.z = sin(iTime);\n    \n    // recently used\n    //cameraPos.z = -iTime * iTime * iTime;\n    //cameraPos.y = -cos(iTime * 0.5) * cos(iTime * 0.5) * 40.0 - 0.0;\n    \n    \n    //cameraPos.x = sin(cameraPos.z * 0.2 * 8.0 + 8.0;\n    \n    vec3 col = EachPixel(cameraPos, fragCoord);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}