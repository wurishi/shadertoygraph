{"ver":"0.1","info":{"id":"WtlXzl","date":"1563931827","viewed":87,"name":"Shitty Cornell","username":"Caparrini","description":"Shitty Cornell box","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cornell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// -------------------------------------------------------------------------\n// Struct definitions and scene setup\n// -------------------------------------------------------------------------\n\n// Camera parameters\nvec3 lower_left_corner = vec3(-1.0, -1.0, -1.0);\nvec3 horizontal = vec3(2, 0, 0);\nvec3 vertical = vec3(0, 2, 0);\nvec3 origin = vec3(0, 0, 0);\n\n// Ray struct\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float mint;\n    float maxt;\n};\n\n// Scene\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n    \nSphere glowSphere = Sphere(vec3(0,0,0), 0.1,vec3(1,1,1));\n    \nconst int NUM_SPHERES = 6;\nconst Sphere spheres[NUM_SPHERES] = Sphere[NUM_SPHERES](  \n    Sphere(vec3(0.0, -10000.5, -1.0), 10000.,vec3(1,1,1)),\n    Sphere(vec3(0.0, 10000.5, -1.0), 10000.,vec3(1,1,1)),\n    Sphere(vec3(-10000.5, 0, -1.0), 10000.,vec3(1,0.2,0.2)),\n    Sphere(vec3(10000.5, 0, -1.0), 10000.,vec3(0.2,1,0.2)),\n    Sphere(vec3(0.0, 0.0, -10001.0), 10000.,vec3(1,1,1)),\n    Sphere(vec3(0, -.35, -.7), 0.15,vec3(.5,.85,1))\n);    \n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\n\n// Hit record information\nstruct HitRecord\n{\n    float t;\n    vec3 P;\n    vec3 N;\n    vec3 col;\n};\n    \n\n// -------------------------------------------------------------------------\n// Camera code\n// -------------------------------------------------------------------------\n\nRay computeCameraRay(vec2 uv)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    Ray r;\n    r.origin = origin;\n    r.direction = lower_left_corner * vec3(aspectRatio, 1.0, 1.0) +\n          uv.x * horizontal * aspectRatio +\n          uv.y * vertical;\n    r.mint = 0.0;\n    r.maxt = 1e20;\n    return r;\n}\n\nRay computeLightRay(HitRecord hit)\n{\n    Ray r;\n    r.origin = hit.P;\n    \n    vec3 distToLight = (glowSphere.center - hit.P) - glowSphere.radius * glowSphere.radius;\n        \n    r.direction = normalize(distToLight);\n    r.mint = 0.0;\n    r.maxt = length(distToLight);\n    return r;\n}\n\n// -------------------------------------------------------------------------\n// Animation\n// -------------------------------------------------------------------------\n\nvoid animateSphere(Sphere s)\n{\n    glowSphere.center = vec3(sin(iTime/2.)/3., sin(iTime/3.)*.1+.1,sin(iTime)*.15 -.5);\n}\n\n// -------------------------------------------------------------------------\n// Light\n// -------------------------------------------------------------------------\n\nbool shadowDetect(Ray r, Sphere s)\n{        \n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0)\n    \treturn false;\n    \n    \n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) \n        return true;\n\n    return false;\n}\n\n\nfloat computeLightInt(HitRecord hit)\n{\n    Ray r = computeLightRay(hit);\n\tvec3 distToLight = (glowSphere.center - hit.P) - glowSphere.radius * glowSphere.radius;\n    float dotL = dot(hit.N, r.direction);\n    \n    float intensity = (1.0/ length(distToLight)) * .3;\n    \n    \n    if(shadowDetect(r,spheres[5]))\n       {\n           intensity *= 0.00;\n       }\n    \n    return intensity * dotL;\n}\n\n\n// -------------------------------------------------------------------------\n// Intersection code\n// -------------------------------------------------------------------------\n\n\n\nbool hitSphere(Ray r, Sphere s, out HitRecord hit)\n{        \n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;\n    }\n    \n    // first possible intersection\n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.origin + t * r.direction;\n        hit.N = normalize(hit.P - s.center);\n        \n        hit.col = s.color * computeLightInt(hit);\n           \n        return true;\n    }\n\n    // second possible intersection\n    t = (-b + sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.origin + t * r.direction;\n        hit.N = normalize(hit.P - s.center);\n        return true;\n    }\n\n    return false;\n}\n\n// intersect against all spheres and return the first hit\nbool hitSpheres(Ray r, Sphere spheres[NUM_SPHERES], out HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (hitSphere(r, spheres[i], hit)) {\n            \n            hitSomething = true;\n            // if we hit a sphere we update maxt on the ray to only find\n            // intersections that are even closer\n            r.maxt = hit.t;\n        }\n    }\n    \n    \n    return hitSomething;\n}\n\n\n// -------------------------------------------------------------------------\n// Core integrator\n// -------------------------------------------------------------------------\n    \n\nvec3 traceRay(Ray r)\n{\n    \n    HitRecord hit;\n    \n    if (hitSpheres(r, spheres, hit))\n    {\n        return hit.col;\n        \n    }\n    \n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 traceRayGlow(Ray r)\n{\n    \n    HitRecord hit;\n    \n    if (hitSphere(r, glowSphere, hit))\n    {\n        return vec3(1,1,1);\n        \n    }\n    \n    return vec3(0.0,0.0,0.0);\n}\n\n\n// -------------------------------------------------------------------------\n// Main image computation\n// -------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    animateSphere(glowSphere);\n    \n    // Compute ray for pixel\n    Ray r = computeCameraRay(uv);\n\n    // Pixel Color\n    vec3 diffuse = traceRay(r);\n    vec3 emission = traceRayGlow(r);\n    vec3 ambient = vec3(0.01,0.005,0.07);\n    vec3 baseCol = diffuse + emission + ambient;\n    \n    vec3 finalCol = pow(baseCol, vec3(0.8,0.8,0.8) );\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}