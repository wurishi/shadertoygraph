{"ver":"0.1","info":{"id":"ftXXWj","date":"1626501643","viewed":206,"name":"hueshifter reborn","username":"ufffd","description":"recreating an old video I made in after effects, but better https://www.youtube.com/watch?v=CXXmZiVXCxY","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["hsv","difference"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://creativecommons.org/licenses/by-sa/4.0/\n// hueshifter but better https://www.youtube.com/watch?v=CXXmZiVXCxY\n\n#define SWAY 0.02\n#define BLURSTRENGTH 1.0\n#define CHROMA_SHIFT false\n#define SCANLINES false\n#define BLURSAMPLES 50\n\nconst int LOD = 1,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(BLURSAMPLES) * .2;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = BLURSAMPLES/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(BLURSAMPLES)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 swayuv = uv * 1.0 + sin(iTime * 0.5) * SWAY + (iMouse.xy/iResolution.xy - vec2(0.5)) * 0.03;\n    vec3 col = texture(iChannel0,uv).rgb;\n    vec3 blur = blur(iChannel0,swayuv, 1./iChannelResolution[0].xy ).rgb;\n    blur *= BLURSTRENGTH;\n    if (SCANLINES) {\n        col += blur * sin(iTime * 0.5 + distance(uv,vec2(0.5)) * 80000000. * sin(iTime) * abs(uv.x - 0.5)) * sin(uv.y * 100.0 + iTime * 10.);\n    }\n    if (CHROMA_SHIFT) {\n        swayuv.x += 0.01;\n        col.r *= texture(iChannel0,swayuv).r;\n        swayuv.x -= 0.02;\n        col.b *= texture(iChannel0,swayuv).b;\n    }\n    col = max(col,blur);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RING_WIDTH 0.01\n\n#define PI 3.14159265359\n#define HOLES true\n#define HOLE_WOBBLE_SPEED 0.2\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= 1.77777777778;\n    uv.x -= 0.39;\n    uv -= 0.5;\n\n    vec3 col = vec3(0.0);\n\n    float dist = distance(uv,vec2(0.0));\n    float base_ang = atan(uv.y,uv.x) / (2.0 * PI);\n    for (float i=1.0; i>0.1;i-=0.1){\n        if (dist < sin(i * iTime) * 0.1 + i * 0.39) {\n            if (HOLES) {\n                vec2 offset_center = vec2(0.0, i * i * 0.02 * (sin(iTime * HOLE_WOBBLE_SPEED) + 1.0));\n                offset_center = rotate(offset_center,PI * 2.0 * (i * iTime) - iTime);\n                float dist_offset = distance(uv + offset_center,vec2(0.0));\n                // dist_offset = 1.0;\n                if (dist_offset < sin(i * iTime) * 0.1 + i * 0.4 - RING_WIDTH * i * (sin(iTime * i) + 1.0)) {\n                    continue;\n                }\n            }\n            float ang = mod(base_ang + sin(1.0 - dist * 20.0) * 0.03 + iTime * i * 0.3,1.0);\n            vec3 newcol = hsv2rgb(vec3(ang, 1.0, 1.0));\n            col = abs(col - newcol);\n            col = (col + newcol) / 2.0;\n        }\n    }\n    col = rgb2hsv(col);\n    col.r += mod(iTime * 0.1, 1.0);\n    col.g = (col.g + 1.0 - dist) / 2.0;\n    if (col.b > 0.1) col.b = 1.0;\n    col = hsv2rgb(col);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}