{"ver":"0.1","info":{"id":"cstfD7","date":"1697247763","viewed":101,"name":"Precise Graphing Enhanced","username":"Carandiru","description":"additional enhancements to \"precise graphing\", see notes for more detail.\n\nA small graphing tool that does multisampling. Press 1 for mouse control.","likes":2,"published":3,"flags":16,"usePreview":0,"tags":["2d","graphing","subpixel"],"hasliked":0,"parentid":"4dS3WG","parentname":"Precise Graphing"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// enhanced precision with bluenoise anti-aliasing \n// with corrected (r,g,b) luminance integrated with time for a pixel (r,g,b) leds\n// -----------------------------------------------------------------\n// subpixel rendering experiment\n// modify TEMPORAL_INTERVAL from 1.0 to inf\n// to change the \"spread\" of the integration split between the r,g,b leds\n// lower will be more \"red\", higher will be more \"blue\"\n// ~10.0 seems to be about even\n\n#define TEMPORAL_INTERVAL 10.0\n#define SUBPIXEL_JITTER_SLOWNESS 0.5  // increase to 10, 100, 1000 to see subpixel movement at a lower pace so\n                                      // that the differences are visible, default is 0.5f (2x time)\n                                      // which blurs the jitter over time with a simple bluenoise animation\n                                      \n\n/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tA small graphing tool that does multisampling.\n\t\n\t\t- noise based sampling\n\t\t- antialiasing\n\t\t- subpixel rendering\n\n\tWorks perfectly with functions that have discontinueties or changes rapidly.\n\n\tUsage:\n\n\t\t1. set the quality, \n\t\tthe more quality the more samples are taken\n\t\tmore samples = better result\n\n\t\t2. optionally set the plot smoothness, \n\t\tthis defines the size of the area that is sampled\n\t\tmore smoothness = the plot is basically blurred\n\n\t\t3. define your function in float f(float x)\n\t\tthe default function cycles over 7 other functions\n\n*/\n\n#define quality 10\n#define smoothness min(2.0,float(quality)*.125)\n#define grid\n#define subpixel\n//#define reverseLCD\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\nfloat f4(float x) // interference\n{\n\tx=x*200.0;\n\treturn sin(x)+sin(x*.99); \n}\n\nfloat f3(float x) // undefined at x = 0\n{\n\treturn 1.0/x; \n}\n\nfloat f2(float x) //unstable\n{\n\tx = pow(4.0,x);\n\treturn sin(x*10.0);\n}\n\nfloat f1(float x) // undefined at x = 0\n{\n\treturn sin(1.0/x);\n}\n\nfloat f5(float x) // sawtooth wave\n{\n\treturn mod(x,1.0);\n}\n\nfloat f6(float x) //animated\n{\n\treturn sin(x*4.0+iTime) + sin(x*3.0+iTime);\n}\n\nfloat f7(float x)\n{\n\tx = pow(4.0,x);\n\treturn sin(x*10.0);\n}\n\nfloat f(float x)\n{\n\tfloat t = mod(iTime*.5,7.0);\n\tif (t<1.0)\n\t{\n\t\treturn f1(x);\n\t}\n\telse if (t<2.0)\n\t{\n\t\treturn f2(x);\n\t}\n\telse if (t<3.0)\n\t{\n\t\treturn f3(x);\n\t}\n\telse if (t<4.0)\n\t{\n\t\treturn f4(x);\n\t}\n\telse if (t<5.0)\n\t{\n\t\treturn f5(x);\n\t}\n\telse \n\t{\n\t\treturn f6(x);\n\t}\n}\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*164437.36831)*13217.321); //decent hash for noise generation\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mode = texture(iChannel0, vec2(49.5 / 256.0, 1.0)).x;\n                            \n\tvec2 uv = fragCoord.xy;\n    \n    if (mode > .1)\n\t\tuv = (fragCoord.xy - iMouse.xy + iResolution.xy*.5);\n        \n    uv = uv/iResolution.xy-.5;\n\tuv.x = uv.x*iResolution.x/iResolution.y;\n\tuv*=2.0;\n    \n    // equal scaling required for both ([1.0], 2.0, 3.0, 4.0) [pixel, uv]:\n\tfloat pixel = 1.0/iResolution.y;\n\tuv*=1.0; \n\t\t\n\tvec3 c = vec3(.0);\n\tfloat bn = textureLod(iChannel1, (fragCoord + vec2(iTime, iTime*iResolution.x)/SUBPIXEL_JITTER_SLOWNESS)/1024.0f, 0.0f).r;\n    \n\tfor (float fi=.0; fi<1.0; fi += 1.0/float(quality))\n\t{\n\t\t#ifdef subpixel\n        const vec3 _subpixel[3] = vec3[3] ( vec3(1, 0, 0),\n                                            vec3(0, 1, 0),\n                                            vec3(0, 0, 1) );\n\t\tfor (int i=0; i<3; i++)\n\t\t{\n\t\t\tfloat x = (uv.x + hash(uv.y*41.0+fi)*pixel*float(smoothness)*.3333 + float(i)*pixel*.3333);\n\t\t\tfloat y = (uv.y + hash(uv.x*41.0+fi)*pixel*float(smoothness));\n\t\t\n\t\t\tfloat s0 = f(x-(0.5f+bn)*pixel);\n\t\t\tfloat s1 = f(x+(0.5f+bn)*pixel);\n\t\t\t\n\t\t\tif (s0-pixel <= y && y < s1+pixel || s1-pixel <= y && y < s0+pixel)\n\t\t\t{\n                #ifdef reverseLCD\n                int led = 2-i;\n                #else\n                int led = i;\n                #endif\n                \n                float instaneous_luminance = 1.0f / (1.0f + pow(dot(_subpixel[led], LUMA) * ( smoothstep(-iTimeDelta * 1.5f, iTimeDelta * 1.5f, fract(iTime) - 0.5f) ), TEMPORAL_INTERVAL));\n\t\t\t\t\n\t\t\t\tc[led] += instaneous_luminance;\n\t\t\t}\n\t\t}\n\t\t#else \n\t\tfloat x = uv.x + hash(uv.y*41.0+fi)*pixel*float(smoothness);\n\t\tfloat y = uv.y + hash(uv.x*41.0+fi)*pixel*float(smoothness);\n\t\t\n\t\tfloat s0 = f(x-pixel);\n\t\tfloat s1 = f(x+pixel);\n\t\t\t\n\t\tif (s0-pixel <= y && y < s1+pixel || s1-pixel <= y && y < s0+pixel)\n\t\t{\n\t\t\tc += vec3(1.0);\n\t\t}\n\t\t#endif\n\t}\n\t\n\tc/=float(quality);\n\t\n\t#ifdef grid\n\tc += max(.0,1.0-abs(mod(uv.x+.5,1.0)-.5)/pixel*0.5)*.1/(.5+abs(uv.x)*.5);\n\tc += max(.0,1.0-abs(mod(uv.y+.5,1.0)-.5)/pixel*0.5)*.1/(.5+abs(uv.y)*.5);\n\t#endif\n\t\n\tfragColor = vec4(pow(c,vec3(.6)),1.0);\n}","name":"Image","description":"","type":"image"}]}