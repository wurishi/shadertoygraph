{"ver":"0.1","info":{"id":"DdtyRr","date":"1694701630","viewed":92,"name":"Cellular Noise Moving Cell","username":"granitoale","description":"An example on cellular noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","random","cell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.y += noise(iTime*0.3);\n    uv.x += noise(iTime*0.3+1.);\n    \n    //Making the grid\n    float scale = 3.;\n    uv *= vec2(scale);\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    float md = 1.;\n    vec2 pp = vec2(0.);\n    \n    for(int y = -1; y <= 1; y++){\n        for(int x = -1; x <= 1; x++){\n        \n            vec2 ne = vec2(float(x),float(y));\n            \n            vec2 point = random2(iuv+ne);\n            point.x+=noise(point.x*iTime*5.)*.5;\n            point.y+=noise(point.y*iTime*5.)*.5;\n            \n            float dist = distance(point+ne,fuv);\n            if(dist < md){\n                md = min(md,dist);\n                pp = point;\n            }\n            \n            \n        }\n    }\n    \n    vec2 gp = random2(vec2(123.43,124.45));\n    gp.x=noise(gp.x*iTime*2.);\n    gp.y=noise(gp.y*(iTime+2.)*2.);\n    if(distance(gp,fragCoord/iResolution.xy)*(scale+1.) < md){\n        md = min(md,distance(gp,fragCoord/iResolution.xy)*(scale+1.));\n        pp = gp;\n    }\n    \n    md *= gradientNoise(uv)+.2;\n    \n    vec3 col = vec3(smoothstep(0.+vnoise(uv+iTime)/6.,0.9,md));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*--------------------------------------------------------\nValue Noise by Inigo Quilez\n--------------------------------------------------------*/\nfloat hash( in ivec2 p ){\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n    // 1D hash by Hugo Elias\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\nfloat vnoise( in vec2 p ){\n    ivec2 i = ivec2(floor(p));\n    vec2 f = fract(p);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);   \n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n}\nfloat valueNoise(vec2 uv){\n    float f = vnoise(uv);\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*vnoise( uv ); uv = m*uv;\n    f += 0.2500*vnoise( uv ); uv = m*uv;\n    f += 0.1250*vnoise( uv ); uv = m*uv;\n    f += 0.0625*vnoise( uv ); uv = m*uv;\n    f = .5+.5*f;\n    return f;\n}\n/*--------------------------------------------------------\nGradient Noise by Inigo Quilez\n--------------------------------------------------------*/\nvec2 grad(ivec2 z){\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n  \n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) : gr;\n                         \n}\nfloat gnoise(vec2 xy){\n    ivec2 i = ivec2(floor(xy));\n    vec2 f = fract(xy);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat gradientNoise(vec2 uv){\n    float f = gnoise(uv);\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*gnoise( uv ); uv = m*uv;\n    f += 0.2500*gnoise( uv ); uv = m*uv;\n    f += 0.1250*gnoise( uv ); uv = m*uv;\n    f += 0.0625*gnoise( uv ); uv = m*uv;\n    f = .5+.5*f;\n    return f;\n}\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nfloat random (float x) {\n    return fract(sin(x)*1e4);\n}\nfloat noise(float x){\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    float n = mix(random(i),random(i+1.),u);\n    return n;\n}\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);  \n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}","name":"Common","description":"","type":"common"}]}