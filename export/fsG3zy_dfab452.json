{"ver":"0.1","info":{"id":"fsG3zy","date":"1631723017","viewed":170,"name":"Belts & Gears","username":"kastorp","description":"applying extrusion on the 2D SDF  stored in buffer A","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["arc","extrusion","polyline"],"hasliked":0,"parentid":"7dyGDh","parentname":"Rounded Polyline "},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Belts & Gears by kastorp\n\n//---------------------------------\n#define mmin(da,db) (da.x<db.x?da:db)\n#define R iResolution\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nvec3 map(in vec3 p)\n{\n    vec3 d = vec3(p.z+.25 ,-1,0);\n    \n    vec2 c =p.xy/9. + vec2(.5); \n    vec4 m =  texture(iChannel0,c);   \n    if(any(greaterThan(c,R.xy)) || any(lessThan(c,vec2(0)))) m= vec4(.2);\n    d=mmin(d,vec3(opExtrussion( p -vec3(0,0,.1), m.x*4., 0.2 ),m.w,m.z));\n    d=mmin(d,vec3(opExtrussion( p, m.y*4., 0.4 ),m.w,m.z));\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.002;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.1);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,3.0,6.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.0),-2.0));\n\n        float t = 5.0;\n        float  h;\n        for( int i=0; i<80; i++ )\n        {\n            vec3 p = ro + t*rd;\n             h = map(p).x;\n            if( abs(h)<0.001 || t>15.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<15.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(.5,0.4,0.5));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos , lig, 0.001, 1.0, 32.0 );\n            vec3 alb= map(pos -nor*.02);\n            col = vec3(0.01) + dif*(.05 + .95*sha)*(alb.y<0.?vec3(0.1,.3,.5): vec3(alb.y,1.-alb.y,.5 + alb.z*.5)) *(.7 + alb.z*.3);\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//essentially a copy of https://www.shadertoy.com/view/7dyGDh\n\n#define R iResolution\n#define mmin(da,db) (da.x<db.x?da:db)\n#define plotBelt( func) { vec3 fn =func; ldist+= (fn.x<=0.? fn.y*fn.z : fn.z); if(tdist==0. && fn.x<0.) tdist =ldist; distB=mmin(distB,vec3(fn.x,.5, step(.15,mod(iTime-tdist, .31))));  }\n#define plotGear(sw,pos, func) {float fn = func; distG=mmin(distG,vec3(fn,sw?.1:.9,(sw? angle(pos,vec2(sin(-iTime/r),cos(-iTime/r))): angle(pos,vec2(sin(iTime/r),cos(iTime/r))))/2./PI )); }\n\n\n#define PI 3.1415\nconst int N= 8; //number of nodes \n//#define RANDOM //randomize nodes\n\n//------------------------------------\n\n// line/line intersection (Iapafoto)\nvec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {\n    float d = n0.x*n1.y-n0.y*n1.x; \n    if(d==0.) return vec2(0);\n    vec2 p = (p0-p1)/d;\n    return vec2(p.y*n1.x-p.x*n1.y, p.y*n0.x-p.x*n0.y); \n}\n\n// line/circle intersection\nvec2 intersect(vec2 p0, vec2 n, vec2 center, float r) {\n    vec2 c=p0-center;\n    float b= dot(n,c),\n          d = sqrt(b*b +r*r - dot(c,c));\n     return vec2( -b+d,-b-d);    \n}\n//angle between normals\nfloat angle(in vec2  p,in  vec2 n){\n    vec2 c= p *mat2(n.x,n.y,-n.y,n.x);\n    float a= atan(c.y,c.x);\n    if(a<0.)  a= 2.*PI +a;  \n    return a;\n}\n\n//based on Iq SDF function\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{   \n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    if (scb.y*p.x>scb.x*p.y) {\n        vec2  b = scb*(ra+rb), a=scb*(ra-rb),pa=p-a, ba = b-a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h );\n    }\n    return abs( length(p)-ra) -rb;\n}\n\n// arc with normals as parameters\n//type=0: ordered arc, =1: always shorter, -1= always longer\nvec3 sdArcExt( in vec2 p, in vec2 na, in vec2 nb, in float ra,in float rb,bool swap)\n{  \n    if(swap) {vec2 temp=na;na=nb;nb=temp;}\n    float an =  angle(p ,na),at=angle(nb,na) ;      \n    vec2 ta =  normalize(na+nb) *mat2(0,1,-1,0) *sign(na.x*nb.y - na.y*nb.x),  \n         tb =  na *mat2(ta.x,ta.y,-ta.y,ta.x); \n    if(tb.x<0.) tb.x=-tb.x;\n    return vec3(sdArc(p,ta,tb,ra,rb),(swap? 1.-  an /at : an / at), at*ra );\n}\n\nvec3 sdSegmentExt( in vec2 p, in vec2 a, in vec2 b , in float tk)\n{\n    vec2 n=normalize(b-a), l= vec2(length(b-a)*.5,tk);\n    p=(p-a)*mat2(n.x,n.y,-n.y,n.x) -vec2(l.x,0);\n    vec2 d = abs(p)-l;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0),p.x/l.x/2.+.5,l.x*2.);\n}\n\n//segment-arc-segment\nvec4 roundCorner( vec2 a, vec2 b, vec2 c, float r)\n{   \n    //segment ab\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    //parallel ab on c side\n    vec2 a1 = a + pab;\n    \n    //segment bc\n    vec2 nbc= normalize(c-b),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-c,tbc));\n    //parallel bc on a side\n    vec2 b1 = b + pbc;  \n    \n    //intersection\n    vec2 d = a1 + intersect(a1,nab,b1,nbc).x*nab;  //center of inscribed circle\n           \n    //arc-segment intersection\n    vec2 e = d  - pab;  //intersection arc, segment ab\n    vec2 f = d  - pbc;  //intersection arc, segment cb\n    \n    float de= distance(e,b),df=distance(f,b);\n    return vec4(de,df,d);             \n}\n\n//segment-arc-arc-segment\nvec4 roundCorner2( vec2 a, vec2 b, vec2 c, float r){\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    vec2 d = b + pab;\n    vec2 nbc= normalize(b-c),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-c,tbc));\n    vec2 b1 = b -  pbc,\n         e = b1  + nbc*  intersect(b1,nbc,d,2.*r).y;      \n    return vec4( d ,  e);\n}   \n\n//segment-arc-arc-arc-segment\nvec4 roundCorner3( vec2 a, vec2 b, vec2 c, float r){\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    vec2 a1 = b - pab,\n         e = a1  + nab*  intersect(a1,nab,b,2.*r).y; \n    vec2 nbc= normalize(b-c),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-b,tbc));\n    vec2 c1 = b -  pbc,\n         f = c1  + nbc*  intersect(c1,nbc,b,2.*r).y;     \n    return vec4( e ,  f);\n}  \n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 getK(int i){\n        float s= float(i*i)/float(N*N) +.05;\n#ifdef RANDOM        \n        vec2 k =hash21(float(i))*.8-.4;\n#else        \n        const vec2[8] KK = vec2[8](vec2(.4,.4), vec2(0,0), vec2(-.3,.4), vec2(-.4,0),vec2(-.3,-.3), vec2(0,-.4), vec2(0.2,0.), vec2(.3,-.4)) ;  \n        vec2 k= KK[i];\n#endif        \n        k.x*=R.x/R.y;\n        //k +=vec2(sin(iTime*(s-.3) +s  +5.),cos(iTime*(s-.3)+s +5.))*.07 ;\n        return k;\n}\n//----------------------------------------------------------------\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-R.xy*.5 + U)/R.xy *1.7;\n     \n        \n    float r =iMouse.z>0.? iMouse.y/R.y *.07 +.04 : .08,\n          tk=iMouse.z>0.? iMouse.x/R.x *.02 : .01;\n\n    vec3 distB=vec3(1e5,0,0) ,distG=vec3(1e5,0,0);\n    float tdist=0.,ldist=0.; //SDF distance, cumulated path distance, local path distance\n    \n    for(int i=min(iFrame,0);i<N;i++)\n    {\n        //b = node, a and c = polyline mid points\n        vec2 b=getK((i+1)%N), a=(getK(i)+b)/2., c=(getK((i+2)%N)+b)/2.;\n       \n        //control point:\n         //col = mix(vec3(0),col,smoothstep(0.,.002,-tk+ length(p-b)));\n                 \n        // try to use 1 arc\n        vec4 v = roundCorner(a,b,c, r);      \n        if( i==4 && v.x<distance(a,b) && v.y < distance(c,b)) {\n            //ok is compatible, draw it                        \n            vec2 nab=normalize(b-a),\n                 ncb=normalize(c-b),\n                 e= b - v.x*nab,\n                 f= b + v.y*ncb,\n                 d=v.zw;\n                 \n            bool swap =nab.x*ncb.y>nab.y*ncb.x ;\n            plotGear(swap, p-d, tk-r  + length(p-d));\n            plotBelt( sdSegmentExt(p,a,e,tk));                      \n            plotBelt( sdArcExt(p-d,normalize(e-d),normalize(f-d),r,tk,!swap));           \n            plotBelt(sdSegmentExt(p,f,c,tk));            \n        } else {\n            // try to use 2 arcs \n            //vec2 b=kj, a=(ki+b)/2., c=(km+b)/2.;            \n            //if(  distance(c,b)<distance(a,b)) {a=(ki+b)/2.; c=(km+b)/2.;}\n            \n            vec4 v2 = roundCorner2(  a,b,c,  r);\n            vec2 nab=normalize(b-a),\n                 nbc=normalize(b-c),\n                 a1=v2.xy,\n                 c1=v2.zw,\n                 f=(a1+c1)/2.,\n                 a2=b,\n                 c2=b+ intersect(b,nbc,c1,vec2(nbc.y,-nbc.x)).x*nbc;\n                 \n            if( distance(b,c)>distance(b,c2) ){\n                bool swap = nab.x*nbc.y>nab.y*nbc.x;\n                plotGear(!swap, p-a1, tk-r  + length(p-a1));\n                plotGear(swap, p-c1, tk-r  + length(p-c1));                \n                plotBelt(  sdSegmentExt(p,a,a2,tk));                                         \n                plotBelt( sdArcExt(p-a1,normalize(a2-a1),normalize(f-a1),r,tk,swap));\n                plotBelt( sdArcExt(p-c1,normalize(f-c1),normalize(c2-c1),r,tk,!swap));\n                plotBelt( sdSegmentExt(p,c2,c,tk));\n       \n            }else{\n                // try to use 3 arcs\n                //vec2 b=kj, a=(ki+b)/2., c=(km+b)/2.;\n                vec4 v2 = roundCorner3(  a,b,c,r);\n                vec2 nab=normalize(b-a),\n                     nbc=normalize(b-c),\n                     e = v2.xy,\n                     f = v2.zw,                \n                     a1=(e+b)/2.,\n                     c1=(f+b)/2.,\n                     a2= b+ intersect(b,nab,e,vec2(nab.y,-nab.x)).x*nab,\n                     c2= b+ intersect(b,nbc,f,vec2(nbc.y,-nbc.x)).x*nbc;       \n\n                  if(distance(a,b)>distance(b,a2) && distance(b,c)>distance(b,c2)){\n                    //ok is compatible, draw it \n                    bool swap = nab.x*nbc.y>nab.y*nbc.x;\n\n                    plotGear(swap, p-e, tk-r + length(p-e));\n                    plotGear(swap, p-f, tk-r  + length(p-f));\n                    plotGear(!swap,  p-b, tk-r  + length(p-b));\n                    plotBelt( sdSegmentExt(p,a,a2,tk));                               \n                    plotBelt( sdArcExt(p-e,normalize(a2-e),normalize(a1-e),r,tk,!swap));\n                    plotBelt( sdArcExt(p-b,normalize(a1-b),normalize(c1-b),r,tk,swap));                               \n                    plotBelt( sdArcExt(p-f,normalize(c1-f),normalize(c2-f),r,tk,!swap));\n                    plotBelt( sdSegmentExt(p,c2,c,tk));                \n                  }else{\n                    //segments too short - skip rounding\n                    plotBelt( sdSegmentExt(p,a,b,tk));\n                    plotBelt( sdSegmentExt(p,b,c,tk));\n                  }\n              }\n        }\n    }\n       \n    // Output to screen\n    O = vec4(distB.x,distG.x,mmin(distB,distG).zy);\n} \n\n","name":"Buffer A","description":"","type":"buffer"}]}