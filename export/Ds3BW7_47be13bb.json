{"ver":"0.1","info":{"id":"Ds3BW7","date":"1697211512","viewed":55,"name":"Horseshoe Edge Point","username":"sagieL","description":"Analytic solution to find an edge of the horseshoe SDF. Can be used to connect other SDFs to this shape seamlessly.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","distance","edge","connect","horseshoe"],"hasliked":0,"parentid":"WlSGW1","parentname":"Horseshoe - distance 2D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Sagie Levy.\n// Thanks to IQ for the original shape.\n\n#define PI_2 1.57079632679\n#define PI 3.14\n\nfloat sdHorseshoe( in vec2 p, in float angle, in float r, in float len, float thickness )\n{    \n    p.x = abs(p.x);\n    float l = length(p);\n    \n    // This is to make sure that the edge doesn't turn to a slope when len < 0.\n    if (len < 0.) {\n        angle -= len / r;\n        len = 0.0;\n    }\n    \n    vec2 c = vec2(cos(angle),sin(angle));\n    \n    mat2 mat = mat2(-c.x, c.y, c.y, c.x);\n\n    p = mat * p;\n    p = vec2((p.y > 0.0 || p.x > 0.0) ? p.x : l * sign(-c.x),\n               (p.x > 0.0) ? p.y : l);\n    p = vec2(p.x - len, abs(p.y - r) - thickness);\n\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nvec2 horseshoeEdgePoint(in float angle, in float r, in float len)\n{\n    // TODO: This is an attempt to fix negative len values.\n    if (len < 0.) {\n        angle -= len / r;\n        len = 0.0;\n    }\n    \n    vec2 c = vec2(cos(angle), sin(angle));\n    mat2 rot = mat2(-c.x, c.y, c.y, c.x);\n    \n    vec2 edgePointLocal = vec2(len, r);\n    vec2 edgePointRotated = rot * edgePointLocal;\n    \n    //if (edgePointRotated.x < 0.) { edgePointRotated.x = 0.; edgePointRotated.y = -r;}\n     \n    return edgePointRotated;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float angle = PI * 0.83333;\n    float len = 0.7 * cos(iTime*0.5);\n    float th = 0.15;\n    \n    const float r = 1.5;\n    float rOffset = 0.8;\n    float centerYOffset = 1.1547 * r;\n    \n\n    \n    // Horseshoes.\n    float d = sdHorseshoe(p-vec2(0.0,centerYOffset), angle, r, len, th);\n    d = min(d, sdHorseshoe(p-vec2(0.0,centerYOffset), angle, r + rOffset, len, th));\n    \n    // Edge points.\n    vec2 edgePointSDF = horseshoeEdgePoint(angle, r, len);\n    vec2 edgePoint2SDF = horseshoeEdgePoint(angle, r + rOffset, len);\n\n    //p.x = abs(p.x); // Uncomment to mirror edge points to both edges.\n\n    // Circle visualization the points on the edges.\n    float edgePoint = distance(p-vec2(0.0,centerYOffset), edgePointSDF) - 0.1;\n    edgePoint = min(edgePoint, distance(p-vec2(0.0,centerYOffset), edgePoint2SDF) - 0.1);\n    edgePoint = smoothstep(0., 0.01, -edgePoint);\n        \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    col = mix (col ,vec3(1., 0, 0), edgePoint);\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}