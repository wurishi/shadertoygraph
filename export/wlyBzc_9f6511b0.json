{"ver":"0.1","info":{"id":"wlyBzc","date":"1615296115","viewed":161,"name":"Haru86_Quaternion Juria","username":"Haru86_","description":"Haru86_Quaternion Juria","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.x * b.y + a.y * b.x - a.z * b.w + a.w * b.z,\n        a.x * b.z + a.y * b.w + a.z * b.x - a.w * b.y,\n        a.x * b.w - a.y * b.z + a.z * b.y + a.w * b.x\n    );\n}\n\nvec2 pmod(vec2 p,float n)\n{\n    float a=(2.0*PI)/n;\n    float t=atan(p.x,p.y)-PI/n;\n    t=mod(t,a)-PI/n;\n    return vec2(0.75*length(p)*cos(t),0.75*length(p)*sin(t));\n}\n\n//\n\n#define ITERATIONS 16\nfloat deQuaternionJuliaSet(vec4 p, vec4 c) {\n    vec4 z = p;\n    vec4 dz = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 pz, pdz;\n    float r = 0.0, dr = 1.0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        pz = z;\n        z = qmul(pz, pz) + c;\n        pdz = dz;\n        dz = 2.0 * qmul(pz, pdz);\n        r = length(z);\n        dr = length(dz);\n        if (r > 4.0) break;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat de(vec3 p) {\n    return deQuaternionJuliaSet(vec4(p, 0.0), vec4(-1.0, 0.2, 0.0, 0.0));\n}\n\nfloat Cube(vec3 p,vec3 s)\n{\n    p=abs(p);\n    return length(max(p-s,0.0));\n}\n\nfloat sdCross(vec3 p,float s)\n{\n    p=abs(p);\n    float dxy=max(p.x,p.y);\n    float dyz=max(p.y,p.z);\n    float dzx=max(p.z,p.x);\n    return min(dxy,min(dyz,dzx))-s;\n}\n\nfloat menger(vec3 pos)\n{\n    float d=Cube(pos,vec3(0.95));\n    \n        //!!!!!!!!!!!!!!  1.0-4.0\n            float s=3.;\n\n        //!!!!!!!!!!!!!!!! 1.0-2.0\n        float scale=1.0;\n\n        for(int h=0;h<3;h++)\n        {\n            //!!!!!!!!!1.0-2.0\n            float k=2.; \n\n            pos=mod(pos*s,k)-k*0.5;\n            //pos.xz=pf(p.xz,4.0);\n            pos=1.0-scale*abs(pos);\n            s*=scale;\n             //!!!!!!!!!!!!!!!!! 0.5-1.0\n            d=max(d,sdCross(pos,\n            .7)/s);  \n\n        }\n\n    return d;\n}\n\n\nfloat map(vec3 p)\n{\n    \n    vec3 pos=p;\n    float d=length(pos)-0.45;\n    d=1000.0;\n    pos.xy*=rot(PI/2.0);\n    float j=2.0;\n    pos.x=mod(pos.x,j)-j*0.5;\n    pos.x=abs(pos.x);\n    float d1=de(pos);\n    \n    \n    ////////////////////////////////////////////\n   \n   vec3 pos2=p;\n   pos2.xy*=rot(PI/2.0);\n \n    for(int i=0;i<6;i++)\n    {\n         float cvalue=1.5;\n       vec3 c=vec3(\n            (rand(vec2(float(i),0.321)))*cvalue,\n            (rand(vec2(float(i),0.654)))*cvalue,\n            (rand(vec2(float(i),0.987)))*cvalue\n        );\n       pos2.z=abs(pos2.z)-c.x;\n       pos2=abs(pos2)-c.y;\n       \n       \n        vec3 b=vec3(\n            (rand(vec2(float(i),0.321)))*4.0*PI-2.0*PI,\n            (rand(vec2(float(i),0.654)))*4.0*PI-2.0*PI,\n            (rand(vec2(float(i),0.987)))*4.0*PI-2.0*PI\n        );\n        pos2.xy*=rot(b.x);\n        pos2.xz*=rot(b.y);\n        pos2.yz*=rot(b.z);\n        \n      \n        \n    }\n      pos2.z=abs(pos2.z)-1.;\n    float s=0.2;\n    pos2=abs(pos2)-10.0*s;\n    pos2=abs(pos2)-2.0*s;\n    pos2=abs(pos2)-3.0*s;\n    pos2=abs(pos2)-6.0*s;\n   \n    float d2=menger(pos2);\n\n   return min(d1,d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)\n    /min(iResolution.x,iResolution.y);\n    \n    vec3 col=vec3(0.0);\n    \n    \n   \n   float radius=.9;\n   float speed=-.25;\n    vec3 ta=vec3(0.);\n    vec3 ro=vec3(cos(iTime*speed)*radius,sin(iTime*0.5)*0.25,sin(iTime*speed)*radius);\n    \n    vec3 cDir=normalize(ta-ro);\n    vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n    vec3 cUp=cross(cDir,cSide);\n    float depth=1.;\n    vec3 rd=vec3(uv.x*cSide+uv.y*cUp+cDir*depth);\n    \n    float d,t,acc=0.0;\n    for(int i=0;i<128;i++)\n    {\n        d=map(ro+rd*t);\n        if(d<0.001||t>100.0)break;\n        t+=d*0.75;\n        acc+=exp(-3.0*d);\n    }\n    \n    //vec3(exp(-2.5*t))+\n    col=vec3(1.,0.5,0.5)*acc*0.03;\n    col+=vec3(1.,.5,0.5)*acc*exp(-6.*t);\n   \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}