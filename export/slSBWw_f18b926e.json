{"ver":"0.1","info":{"id":"slSBWw","date":"1652282946","viewed":88,"name":"Achtung, die Kurve! - Curve Feve","username":"tomansion","description":"        Green player : left: [E]    right: [R]\n        Red player : Use  [<-] and [ ->]\n        Use [space bar] to reset the game\n\nAchtung, die Kurve! - Curve Fever\nOriginal game : https://achtungdiekurve.net/\n\nHave fun !","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["simple","game","tron","curves","snake","keyboard","buffer","multiplayer","achtungdiekurve","curvefever","hitbox","twoplayer","versus"],"hasliked":0,"parentid":"flBfWw","parentname":"Kurve 4"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================\n// Achtung, die Kurve! - Curve Fever\n// Made for a school project\n\n// Original game : https://achtungdiekurve.net/\n\n// By Tom Mansion and Leandre Becq\n// =================================\n\n\n\n// Game rendering.\n\nconst ivec2 txSnake1PosDir = ivec2(0,0);\nconst ivec2 txSnake2PosDir = ivec2(1,0);\nconst ivec2 txScores       = ivec2(2,0);\n\nconst float ballRadius = 0.02;\n\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nint PrintInt( in vec2 uv, in int value )\n{\n    const int maxDigits = 3;\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n    \n    vec3 inColor = texture(iChannel2, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(inColor, 1.);\n    \n    // Display a white ball on the snakes head\n    {\n        vec2  snake1PosDir   = texelFetch( iChannel0, txSnake1PosDir, 0 ).xy;\n        vec2  snake2PosDir   = texelFetch( iChannel0, txSnake2PosDir, 0 ).xy;\n\n        float f1 = length( uv - snake1PosDir ) - ballRadius;\n        if (f1 < 0.) fragColor = vec4(1.0,1.0,1.0,1.0);\n\n        float f2 = length( uv - snake2PosDir ) - ballRadius;\n        if (f2 < 0.) fragColor = vec4(1.0,1.0,1.0,1.0);\n     }\n     \n     // Scores\n    {\n        vec2  scores         = texelFetch( iChannel0, txScores, 0 ).xy;\n        vec4 snake1Col = vec4(1., 0.1, 0.1, 1.0);\n        vec4 snake2Col = vec4(0.1, 1., 0.1, 1.0);\n    \n        float f1 = float(PrintInt( (uv-vec2(-1.5,0.8))*10.0, int(scores[0]) ));\n        fragColor = mix( fragColor, snake1Col, f1 );\n        \n        float f2 = float(PrintInt( (uv-vec2(1.2,0.8))*10.0, int(scores[1]) ));\n        fragColor = mix( fragColor, snake2Col, f2 );\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gameplay computation.\n//\n// storage register/texel addresses\n// txSnakePosDir : (x, y, a[-pi; pi])\nconst ivec2 txSnake1PosDir = ivec2(0,0);\nconst ivec2 txSnake2PosDir = ivec2(1,0);\nconst ivec2 txScores       = ivec2(2,0);\nconst ivec2 txState        = ivec2(3,0);\n\n// States :\n//  0.0 : In game, waiting for game over\n//  1.0 : Game over, waiting for space bar\n// -2.0 : Pending game data reset, after bar space was pressed\n// -1.0 : Pending buffer reset, after game data was reset\n\n// Scores : \n// [0] : player 1 score\n// [1] : player 2 score\n//----------------\n\nconst float ballRadius = 0.02;\n\nconst float borderSize = 0.95;\nconst float borderThickness = 0.01;\nconst float lowColorCeil = 0.9;\n\nconst float gameSpeed =  3.0;\nconst float playerSpeed =  10.0;\nconst float turnSpeed = 1.;\n\nconst int KEY_SPACE = 32;\nconst int KEY_PLAYER_1_LEFT  = 37;\nconst int KEY_PLAYER_1_RIGHT = 39;\nconst int KEY_PLAYER_2_LEFT  = 69;\nconst int KEY_PLAYER_2_RIGHT = 82;\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\n\n// Utils ------------------------------\n\nvec2 alphaToVec(float a) {\n    return vec2(cos(a), sin(a));\n}\n\nbool isInBoard(vec2 snakePos)\n{\n    if (abs(snakePos.x) < borderSize - borderThickness / 2. - ballRadius &&\n        abs(snakePos.y) < borderSize - borderThickness / 2. - ballRadius) return true;\n    \n    return false;\n}\n\nbool isWall(vec2 uv) {\n  // Given uv.y : [-1; 1]\n  // Target coord.y: [0; 1]\n  vec2 fragCoord = (uv * iResolution.y) / 2. + iResolution.xy / 2.;\n  \n  // get previous color\n  vec3 lastColor = texture(iChannel2, fragCoord /  iResolution.xy).rgb;\n  return (lastColor.x > lowColorCeil || lastColor.y > lowColorCeil || lastColor.z > lowColorCeil);\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n \n    // don't compute gameplay outside of the data area\n    if( fragCoord.x > 14.0 || fragCoord.y > 14.0 ) discard;\n    \n    //---------------------------------------------------------------------------------   \n\t// load game state\n\t//---------------------------------------------------------------------------------\n    vec3  snake1PosDir = loadValue( txSnake1PosDir ).xyz;\n    vec3  snake2PosDir = loadValue( txSnake2PosDir ).xyz;\n    vec2  scores = texelFetch( iChannel0, txScores, 0 ).xy;\n    float state = texelFetch( iChannel0, txState, 0 ).x;\n\n    //float paddlePos = loadValue( txPaddlePos ).x;\n    \n    //---------------------------------------------------------------------------------\n    // reset\n\t//---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -2.0;\n\t\n    if( state == -2.0 )\n    {\n        state = .0;\n        // Default pos and  dir\n        snake1PosDir = vec3(-0.5, -0.5, 0.);\n        snake2PosDir = vec3(0.5, 0.5, 3.14);\n    }\n\n    //---------------------------------------------------------------------------------\n    // do game\n    //---------------------------------------------------------------------------------\n\n    // game over (or won), wait for space key press to resume\n    if( state == 1.0 )\n    {\n        float pressSpace = texelFetch( iChannel1, ivec2(KEY_SPACE,0.0), 0 ).x;\n        if( pressSpace > 0.5) state = -2.0;\n    }\n    \n    // if game mode (not game over), play game\n    else if( state == 0.0 ) \n\t{\n        \n        //-------------------\n        // snake movement\n\t\t//-------------------\n        \n        // Left and right\n        float player1MoveLeft  = texelFetch( iChannel1, ivec2(KEY_PLAYER_1_LEFT,0), 0 ).x;\n        float player1MoveRight = texelFetch( iChannel1, ivec2(KEY_PLAYER_1_RIGHT,0), 0 ).x;\n        \n        float player2MoveLeft  = texelFetch( iChannel1, ivec2(KEY_PLAYER_2_LEFT,0), 0 ).x;\n        float player2MoveRight = texelFetch( iChannel1, ivec2(KEY_PLAYER_2_RIGHT,0), 0 ).x;\n        \n        snake1PosDir.z += (player1MoveLeft - player1MoveRight) * gameSpeed * iTimeDelta * turnSpeed; \n        snake2PosDir.z += (player2MoveLeft - player2MoveRight) * gameSpeed * iTimeDelta * turnSpeed; \n        \n        // Forward\n        float dis = 0.01 * gameSpeed * iTimeDelta * playerSpeed;\n                \n        vec2 lastPos1 = snake1PosDir.xy;\n        vec2 lastPos2 = snake2PosDir.xy;\n        \n        vec2 mvmntDelta1 = dis * alphaToVec(snake1PosDir.z);\n        vec2 mvmntDelta2 = dis * alphaToVec(snake2PosDir.z);\n        vec2 mvmntDeltaHitbox1 = (dis + ballRadius) * alphaToVec(snake1PosDir.z);\n        vec2 mvmntDeltaHitbox2 = (dis + ballRadius) * alphaToVec(snake2PosDir.z);\n        \n        snake1PosDir.xy += mvmntDelta1;\n        snake2PosDir.xy += mvmntDelta2;\n              \n        //-------------------\n        // Detect fail\n\t\t//-------------------\n \n            // If last pixel is in first circle\n           //  if (length( uv - lastPos ) > ballRadius) {\n            //     // Calculate coord of next pixel\n            //     vec2 projection = uv + mvmntDelta;\n            //     // if next pixel is out of first circle\n            //     if (length( projection - lastPos) > ballRadius && isWall(projection)) {\n            //        state = 1.0; // game over\n            //     }\n            // }\n            // TODO : can be better\n            \n        if (isWall(snake1PosDir.xy + mvmntDeltaHitbox1) || !isInBoard(snake1PosDir.xy) ) {\n            state = 1.0;  // game over\n            scores[1] += 1.;\n        }\n\n        if (isWall(snake2PosDir.xy + mvmntDeltaHitbox2) || !isInBoard(snake2PosDir.xy) ) {\n            state = 1.0;  // game over\n            scores[0] += 1.;\n        }\n        \n    }\n    \n\t//---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n \n    storeValue( txSnake1PosDir, vec4(snake1PosDir, 0.),    fragColor, ipx );\n    storeValue( txSnake2PosDir, vec4(snake2PosDir, 0.),    fragColor, ipx );\n    storeValue( txScores,      vec4(scores,0.0,0.0),       fragColor, ipx );\n    storeValue( txState,      vec4(state,0.0,0.0,0.0),     fragColor, ipx );\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Draw snake and borders from the last render\n\n// storage register/texel addresses\nconst ivec2 txSnake1PosDir = ivec2(0,0);\nconst ivec2 txSnake2PosDir = ivec2(1,0);\nconst ivec2 txState        = ivec2(3,0);\n\n//----------------\n\nconst float ballRadius = 0.02;\n\nconst float borderSize = 0.95;\nconst float borderThickness = 0.01;\n\nconst float lowColorCeil = 0.9;\nconst float holeCeil = 1.9;\n\n//=================================================================================================\n// distance functions\n//=================================================================================================\n\nbool square(vec2 uv, vec2 center, float size, float thickness )\n{\n    if (abs(uv.x) < center.x + size - thickness / 2. && abs(uv.y) < center.y + size - thickness / 2.) return false;\n    if (abs(uv.x) > center.x + size + thickness / 2. || abs(uv.y) > center.y + size + thickness / 2.) return false;\n    \n    return true;\n}\n\n\n//=================================================================================================\n// utility\n//=================================================================================================\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\n//=================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    //------------------------\n    // load game state\n    //------------------------\n    vec2  snake1PosDir   = texelFetch( iChannel0, txSnake1PosDir, 0 ).xy;\n    vec2  snake2PosDir   = texelFetch( iChannel0, txSnake2PosDir, 0 ).xy;\n    float state          = texelFetch( iChannel0, txState, 0 ).x;\n    \n    \t\n    if( state == -2.0 )\n    {\n        // Reset board\n        fragColor = vec4(0.0, 0.0, 0.0, 1);\n        ivec2 ipx = ivec2(fragCoord-0.5);\n        return;\n    }\n\n    \n    //------------------------\n    // draw\n    //------------------------\n    vec3 col = vec3(0.0); \n    vec3 snake1Col = vec3(1., 0.1, 0.1);\n    vec3 snake2Col = vec3(0.1, 1., 0.1);\n    \n    // ball \n    {\n        float f1 = length( uv - snake1PosDir ) - ballRadius;\n        float rand1 = abs(sin((iDate.z + iTime) * 3.2)) + abs(sin(iTime * 2.4)) + abs((sin(iTime * 0.5))) / 3. ;\n        if (rand1 < holeCeil && f1 < 0.) col = snake1Col;\n        \n        float f2 = length( uv - snake2PosDir ) - ballRadius;\n        float rand2 = abs(sin((iDate.z / 2. + iTime) * 3.2)) + abs(sin(iTime * 2.4)) + abs((sin(iTime * 0.5))) / 3. ;\n        if (rand2 < holeCeil && f2 < 0.) col = snake2Col;\n     }\n    \n    // borders\n    {\n        if (square(uv, vec2(0., 0.), borderSize, borderThickness)) col = vec3(1.,1.,1.);\n    }\n    \n   \n    // display previous color if not black\n    vec3 lastColor = texture(iChannel2, fragCoord / iResolution.xy).rgb;\n    if (lastColor.x < lowColorCeil && lastColor.y < lowColorCeil  && lastColor.z < lowColorCeil ) fragColor = vec4(col, 1);\n    else fragColor = vec4(lastColor, 1);\n}","name":"Buffer B","description":"","type":"buffer"}]}