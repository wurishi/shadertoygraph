{"ver":"0.1","info":{"id":"MltfzX","date":"1540513370","viewed":271,"name":"Mandelbrot hypersphere","username":"tiusic","description":"An attempt to visualize a hyperspherical slice through the Mandelbrot set and Julia sets. Controls:\nzc   - Zoom in/out\nwasd - Rotate the projected sphere\nqe   - Grow/shrink the hypersphere","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["fractal","julia","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFun fact: The Mandelbrot set and Julia sets are different slices through the\nsame 4D structure. They both iterate f(z)=z^2+c, but Mandelbrot varies c, and\nJulia varies z0 (the initial value of z in the iteration). In other words, if\nc=x+yi and z0=z+wi, then the Mandelbrot set is the slice through the structure\nmade by the (x, y, 0, 0) plane, and the Julia sets are the (cx, cy, z, w)\nplanes (different plots of the Julia set will use different c, but hold it\nconstant). I wanted to come up with a different slice of that 4D shape.\n\nThis shader is an attempt to visualize a hyperspherical slice through that\nobject. Each frame is a spherical slice that is stereographically projected onto\nthe plane, and the 4th dimension is animated slowly over time. Specifically I'm\nanimating z (the real component of z0) then using the sphere x^2+y^2+w^2=1-z^2.\n\nControls:\nzc   - Zoom in/out\nwasd - Rotate the projected sphere\nqe   - Grow/shrink the hypersphere\n*/\n\nconst int samp = 4;   // anti-aliasing samples.\nconst int itr = 100;  // 100 to 1000 is good, depending on your machine.\nconst float bail = 1e9;\nconst float timeScale = 0.01;\nconst float clrScale = 0.1;\nconst vec3 clrPeriod = vec3(1.3, 1.1, 1.0);\nconst vec3 clrPhase = vec3(-0.2, 0.0, 0.2);\n\nvec4 quatConv(vec4 q) {\n    return vec4(q.x, -q.yzw);\n}\n\nvec4 quatMul(vec4 p, vec4 q) {\n    return vec4(p.x * q.x - p.y * q.y - p.z * q.z - p.w * q.w,\n                p.x * q.y + p.y * q.x + p.z * q.w - p.w * q.z,\n                p.x * q.z - p.y * q.w + p.z * q.x + p.w * q.y,\n                p.x * q.w + p.y * q.z - p.z * q.y + p.w * q.x);\n}\n\nvec3 quatRot(vec3 p, vec4 q) {\n    return quatMul(q, quatMul(vec4(0, p), quatConv(q))).yzw;\n}\n\nvec4 data(vec2 p) { return texture(iChannel0, p / iResolution.xy); }\nfloat getZoom() { return 10.0 * exp(data(vec2(0.5, 0.5)).x); }\nfloat getRad() { return exp(data(vec2(0.5, 0.5)).y); }\nvec3 rotate(vec3 p) { return quatRot(p, data(vec2(0.5, 1.5))); }\n\nfloat dist(vec4 p) {\n    vec2 z = p.zw;\n    for (int i = 0; i < itr; ++i) {\n        if (length(z) > bail) {\n            return max(0.0, float(i) - log2(log2(dot(z, z))));\n        }\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + p.xy;\n    }\n    return -1.0;\n}\n\nvec4 proj(vec2 uv) {\n    // return vec4(uv, 0, 0);  // Standard Mandelbrot.\n    float w = 2.0 * fract(timeScale * iTime) - 1.0;\n    float r = sqrt(1.0 - w * w);\n    float d = dot(uv, uv);\n    return vec4(rotate(vec3(2.0 * uv, d - 1.0)) * r / (d + 1.0), w).xywz * getRad();\n}\n\nvec2 screen(vec2 pix) {\n    float size = min(iResolution.x, iResolution.y);\n    return getZoom() * (pix - 0.5 * iResolution.xy) / size;\n}\n\nvec3 clr(float d) {\n    if (d < 0.0) return vec3(0.0, 0.0, 0.0);\n    float e = log(1.0 + d * clrScale);\n    return 0.5 - 0.5 * cos(6.28318 * (clrPeriod * e + clrPhase));\n}\n\nvec3 fractal(vec2 pix) { return clr(dist(proj(screen(pix)))); }\n\nvoid mainImage(out vec4 fragColor, vec2 pix) {\n    vec3 c = vec3(0, 0, 0);\n    for (int i = 0; i < samp; ++i) {\n        for (int j = 0; j < samp; ++j) {\n            c += fractal(pix + vec2(i, j) / float(samp));\n        }\n    }\n    fragColor = vec4(c / float(samp * samp), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float zoomSpeed = 0.01;\nfloat growSpeed = 0.001;\nfloat rotSpeed = 0.01;\nint zoomInKey = 90;\nint zoomOutKey = 67;\nint growKey = 69;\nint shrinkKey = 81;\nint leftKey = 65;\nint rightKey = 68;\nint downKey = 83;\nint upKey = 87;\n\nvec4 quatMul(vec4 p, vec4 q) {\n    return vec4(p.x * q.x - p.y * q.y - p.z * q.z - p.w * q.w,\n                p.x * q.y + p.y * q.x + p.z * q.w - p.w * q.z,\n                p.x * q.z - p.y * q.w + p.z * q.x + p.w * q.y,\n                p.x * q.w + p.y * q.z - p.z * q.y + p.w * q.x);\n}\n\nvec4 quat(float rot, vec3 axis) {\n    rot *= 0.5;\n    return vec4(cos(rot), axis * sin(rot));\n}\n\nbool key(int ascii) {\n    vec2 uv = vec2((float(ascii) + 0.5) / 256.0, 0.5 / 3.0);\n    return texture(iChannel1, uv).x > 0.5;\n}\n\nvec4 controls(vec4 v) {\n    if (key(zoomInKey)) v.x -= zoomSpeed;\n    if (key(zoomOutKey)) v.x += zoomSpeed;\n    if (key(growKey)) v.y -= growSpeed;\n    if (key(shrinkKey)) v.y += growSpeed;\n    return v;\n}\n\nvec4 rotation(vec4 v, float s) {\n    if (key(leftKey)) v = quatMul(v, quat(s, vec3(0, 1, 0)));\n    if (key(rightKey)) v = quatMul(v, quat(-s, vec3(0, 1, 0)));\n    if (key(downKey))  v = quatMul(v, quat(-s, vec3(1, 0, 0)));\n    if (key(upKey)) v = quatMul(v, quat(s, vec3(1, 0, 0)));\n    float l = length(v);\n    if (l < 1e-9) return vec4(0, 0, 0, 1);\n    return v / l;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    if (fragCoord.x > 0.8 || fragCoord.y > 1.8) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        vec4 prev = texture(iChannel0, fragCoord / iResolution.xy);\n        if (fragCoord.y < 0.8) {\n        \tfragColor = controls(prev);\n        } else {\n        \tvec4 cp = texture(iChannel0, (fragCoord - vec2(0, 1)) / iResolution.xy);\n            fragColor = rotation(prev, rotSpeed * clamp(exp(0.3 * cp.x), 0.0, 1.0));\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}