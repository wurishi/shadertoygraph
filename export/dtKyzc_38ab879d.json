{"ver":"0.1","info":{"id":"dtKyzc","date":"1700513190","viewed":41,"name":"Sphere Tracing Estimator","username":"xiaoyxue","description":"Sphere Tracing Estimator","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\nconst float EPSILON = 0.01;\nconst int MAX_STEPS = 255;\nconst float MAX_DIST = 100.0;\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nvec3 c;\n\nstruct SdfSurface{\n    float sd;\n    vec3 c;\n};\n\n//anticlockwise\nvec3 rotateX(vec3 point, float theta){\n    mat3 rotationMatrix = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(theta), sin(theta),\n        0.0, sin(theta), -cos(theta)\n    );\n    return rotationMatrix * point;\n}\n\n\nvec3 rotateY(vec3 point, float theta){\n    mat3 rotationMatrix = mat3(\n        cos(theta), 0.0, sin(theta),\n        0.0, 1.0, 0.0,\n        -sin(theta), 0.0, cos(theta)\n    );\n    return rotationMatrix * point;\n}\n\n\nvec3 rotateZ(vec3 point, float theta){\n    mat3 rotationMatrix = mat3(\n        cos(theta), sin(theta), 0.0,\n        -sin(theta), cos(theta), 0.0,\n        0.0, 0.0, 1.0\n    );\n    return rotationMatrix * point;\n}\n\nvec3 translate(vec3 point, vec3 translation){\n    return point + translation;\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat torusSDF(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sphereSDF(vec3 p, float s){\n    return length(p) - s;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sdfUnion(float a, float b){\n    return min(a, b);\n}\n\n\nfloat SDF(vec3 p){\n    //return heartSurfaceSDF(p);\n    return sdfUnion((sdOctahedron(rotateY(p, radians(iTime*50.0f)), 1.0f)),\n            sdfUnion(torusSDF(translate(rotateX(p, radians(iTime*50.0f)), vec3(-3.0,0,0)), vec2(1.0, 0.25)),\n                    sdLink(rotateZ(translate(p, vec3(3.f, 0, 0)), radians(iTime*50.0f)), 0.5, 0.5, 0.25)));\n}\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = SDF(p);\n    return normalize(vec3(\n        SDF(p + deltax) - d,\n        SDF(p + deltay) - d,\n        SDF(p + deltaz) - d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec3 lighting(vec3 p, vec3 n){\n    float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n    float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n    float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 64.0);\n    return diffuse * vec3(0.75f, 0.35f, 0.35f) + specular * vec3(0.8f) + rim * vec3(0.5f);\n}\n\n\n\nSdfSurface sphereTracing(vec3 p, vec3 dir, float maxDist){\n    SdfSurface result;\n    float dist = 0.0;\n    float nearest = 0.0;\n    bool flag = false;\n    for(int i = 0; i < MAX_STEPS; i++){\n        nearest = SDF(p + dir * dist);\n        if(nearest < EPSILON || dist > maxDist){\n            vec3 hit = p + dir * dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0*cos(iTime), 50.0*cos(iTime));\n            vec3 col = computeLambert(hit, computeSurfaceNormal(hit), light);\n            result.c = lighting(p + dir * dist, computeSurfaceNormal(p + dir * dist));\n            result.sd = dist;\n            flag = true;\n            break;\n        }\n        dist += nearest;\n    }\n    if(!flag){\n        result.sd = MAX_DIST * 1.0;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x), 0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 backgroundColor = vec3(0.735, 1, 1);\n\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy); \n    \n    vec3 cameraPosition = vec3(0.0, 0, 12.0);\n    float r = 10.f;\n    vec2 camUV = uv * 2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright * camUV.x * ulen + cameraUp * camUV.y * vlen;\n    float phi = float(iTime)* 20.0;\n    vec3 cameraPos = rotateY(cameraPosition, radians(phi));\n    vec3 pixelPos = rotateY(pixel, radians(phi));\n    vec3 rayDir = normalize(pixelPos - cameraPos);\n    SdfSurface result = sphereTracing(cameraPos, rayDir, MAX_DIST);\n    if(result.sd >= MAX_DIST){\n        c = backgroundColor;\n    }\n    else{\n        c = result.c;\n    }\n    fragColor = vec4(c, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}