{"ver":"0.1","info":{"id":"Nd2Gzm","date":"1634655463","viewed":301,"name":"ðŸ˜± Nightmare Farm ðŸ˜±","username":"rmmcal","description":"(2020-2021) \n\nEvery nightmare ends... in some time...\n","likes":16,"published":1,"flags":40,"usePreview":0,"tags":["farm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n/////        ....ðŸ˜± Nightmare Farm ðŸ˜±....         ////////// \n/////////////////////////////////////////////////////////////\n// ------------------------------------------------------- //\n// Created by Rodrigo Cal (twitter: @rmmcal)               //\n// Created: 2020     Published: 2021                       //\n// - https://www.shadertoy.com/view/Nd2Gzm                 // \n// ------------------------------------------------------- //\n/////////////////////////////////////////////////////////////\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nvec3 hsv2rgb(float v){\n\treturn abs(fract(v + vec3(3, 2, 1) / 3.) - .5) * 6. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n\n    float r  = min( iResolution.y,iResolution.x);\n\n    vec4 c;\n    float f = 0.0; \n    for (int i = 0; i < 4; i++)\n    {\n        f += .2; \n        c += texture(iChannel0,uv + vec2(cos(f),sin(f))*0.01 );\n    }\n    \n    c /= 4.;\n\n    float w = clamp( (iTime-130.0)*0.1,0.,1.);\n    float w2 = clamp( (iTime-275.0)*0.1,0.,1.);\n  \n    vec4 tvo2 = texture(iChannel1,fract(abs(uv-.5)*50./(1.+w*10.)))*w; \n    vec4 tvo = texture(iChannel1,fract(.5+abs(uv-.5)*10./(1.+w*10.)))*w; \n\n    float b = (1.-length(tvo.yz)*w*1.)*.3;\n    float b1 = b+tvo2.w*.1+.9;\n\n    float ftvo = length(hash(tvo.ww)*10.);\n    c = mix(c, b1*texture(iChannel0,uv+tvo.yz*w*0.01 +  tvo.ww*0.005 - tvo2.ww*0.002),w );\n    c.rgb += hsv2rgb(length(hash(tvo2.ww)*10.))*0.01;\n    c.rgb = mix(c.rgb, hsv2rgb(length(hash(tvo.ww)*10.))*1000., w2*pow(abs(tvo.x),1.5)*.002*cos(iTime*ftvo*.5+ftvo));\n    c = mix(c, vec4(0.), smoothstep(.03,-.06,((tvo.x)))*w  );\n    \n\n    fragColor = c;\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nvec2 hash2( vec2 p ){\n    return hash(p);\n}\n\n//https://www.shadertoy.com/view/ldl3W8\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n  vec3 m = vec3( 8.0 );\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n         if( d < m.x ){\n            m = vec3( d, o );\n         }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, m.y+m.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n    fragColor = voronoi(fragCoord*20.*aspectRatio/iResolution.xy);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI =3.14159265359;\nconst float PI2 = 2.*PI;\nconst float PI3 = 3.*PI;\nconst float PIH =.5*PI;\nconst float PIHh = PIH+PIH*.5;\n\n\n#define animFrame(t, arr, len, vout) {                 \\\n  vout = arr[0].xyzw;                                  \\\n  for(int i = 0; i < len-1; i++){                      \\\n    vec4 a1 = arr[i  ];                                \\\n    vec4 a2 = arr[i+1];                                \\\n    float t1 = clamp((t-a1.w)/(a2.w-a1.w), 0., 1.);    \\\n    if (t1 <= 0.) break;                               \\\n    vout = mix(a1, a2, smoothstep(0., 1., t1));        \\\n  }}\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt(abs( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor)) );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat it;\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nvec2 hash2( vec2 p ){\n    return hash(p);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    return texture(iChannel0,fract(x*.08)); \n  \n}\n\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n\nvec3 hsv2rgb(float v){\n\treturn abs(fract(v + vec3(3, 2, 1) / 3.) - .5) * 6. - 1.;\n}\n\nstruct Hit{\n    vec3 p;               \n\tfloat distanceRadius; \n    int id;       \t\t  \n    vec3 c;\n    float h;\n    bool r;\n    vec3 pt;\n    vec3 pd;\n    float shi;\n};\n\nstruct RayHit{\n    vec3 uv; \n\tvec3 pos;    \n\tvec3 dir;\n    vec3 clo; \n    vec3 nor; \n    vec3 refl;\n    vec3 refr;  \n    Hit hit;  \n    float distanceTotal; \n    float minDistance; \n    float maxDistance; \n    float minDistanceAcc;   \n    float maxDistanceAcc;   \n    int count;\n    float countProx;\n    vec3 glo;\n    vec3 ce;\n    float refc;\n};\n\n\nHit hit(int id, vec3 p,  vec3 c, bool r,vec3 pt,vec3 pd, float distanceRadius )\n{\n    Hit hit;\n    hit.id =  id;\n    hit.p  =  p;\n    hit.c  =  c;\n    hit.r  =  r;\n    hit.pt =  pt;\n    hit.pd =  pd;\n    \n    hit.distanceRadius = distanceRadius;\n    return hit;\n}\n\nHit hit(int id, vec3 p,  vec3 c, bool r, float distanceRadius )\n{\n    Hit hit;\n    hit.id =  id;\n    hit.p  =  p;\n    hit.c  =  c;\n    hit.r  =  r;\n    hit.distanceRadius = distanceRadius;\n    return hit;\n}\nHit hit(int id, vec3 p,  vec3 c, float distanceRadius )\n{\n    Hit hit;\n    hit.id =  id;\n    hit.p  =  p;\n    hit.c  =  c;\n    hit.distanceRadius = distanceRadius;\n    return hit;\n}    \nHit hit(int id, vec3 p, float distanceRadius )\n{\n    Hit hit;\n    hit.id =  id;\n    hit.p  =  p;\n    hit.distanceRadius = distanceRadius;\n    return hit;\n}    \n\nHit join(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius < hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;\n    \n}\n\nHit intercept(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius > hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;    \n}\n\nHit sub(Hit hit1, Hit hit2)\n{\n    float d = max(hit1.distanceRadius,-hit2.distanceRadius);\n    Hit h = hit(hit1.id, hit2.p,d );\n    return h;\n}\n\nvec2 rotate(vec2 v, float angle){\n    float c = cos(angle); \n    float s = sin(angle); \n    return mat2(c, -s, s, c) * v;\n}\n\nfloat loop2(float f, float p){\n\treturn abs(fract(iTime*f+p)*2.-1.)*2.-1.;\n}\n\nfloat sphere(vec3 p, vec3 t, float radius){\n    return length(p-t)-radius; //length(s)\n}\n\nfloat box(vec3 p, vec3 t, vec3 s) { \n    return length(max(abs(p-t)-s,0.0)); \n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat hex(vec2 p) {\n    p = abs(p);\n\tp.x *= 0.57735*2.0;\n\tp.y += mod(floor(p.x), 2.0)*0.5;\n\tp = abs((mod(p, 1.0) - 0.5));\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);\n}\n\nvoid mapTerrain(vec3 p, inout Hit h){\n\n    vec3 p1 = p*1.0; \n    //p1.y += cos(dot(p,p)*.1+cos(p.x+iTime)+cos(p.y*.7+iTime))*.5;\n\n    vec4 vo;\n    vo = (voronoi(p.xy*.1)) ;\n    vec4 vo3 = voronoi(((p.xy))*.05);      \n \n    float u;\n    u = (1.-smoothstep( 0.00, 0.17, vo.x)) ;\n    \n    float ut;\n    ut = 0.0;\n    ut = (cos(cos(vo.y*1.) +cos(vo.z*1.)))*2.4;\n\n    float th = 1.1;//(+1.-(smoothstep(2.0,0.,vo3.w))*1.);\n    ut += max(0.2, -.3+(cos(p.y*.15)+cos(p.x*.2)) *th  );\n\n    p1.z += ut;\n    //h = join(h, hit(1, p1,-p.z+ut));\n    //h = join(h, hit(3, p1,-p.z+ut-u*1.1));\n    p1 *=1.;\n    ivec2 ikp = ivec2(p1);\n    vec2 kp =  vec2(ivec2(ikp));\n    \n    int ic = (ikp.x+ikp.y)%2==0? 4: 2;\n    int ic2 = (ikp.x+ikp.y)%2==0? 3: 0;\n     \n    h = join(h, hit(1, p1,-p1.z));\n    vec4 vo2 = (voronoi(p.xy*0.5)) ;\n \n    p1 = p;\n    vec3 zt = vec3(kp + vec2(0.5,.5),-ut+0.2);\n    float zy = +(-p1.z+ut)*cos(p1.z*2.)*0.1;\n    \n    h = join(h, hit(6, p1,  sdCapsule(p1,zt-vec3(cos(p1.x+p1.y*p1.z*cos(p1.x)*10.)*.3,0.,0.), zt-vec3(.0,.0,.9)*u*vo3.w, .2 )));\n\n}\nHit mapDistance(vec3 p){\n   \n    float t = it*1.;\n   \n    vec3 po = p;\n    Hit h; h.distanceRadius = 1000.;\n    \n    mapTerrain(p,h);\n   \n    float w= clamp((abs(cos(cos(p.x)+cos(p.y)+it*1.))*.1 + (it-110.0)*0.05),    0., 3. );\n  \n    h = join(h, hit(2, p,-p.z- w + 1.));\n   \n    /**/\n    vec3 p1 = p;\n    h = join(h, hit(11, p1, box(p1, vec3(170.,250.,0.), vec3(1.,1.,2.) )));\n    h = join(h, hit(11, p1, box(p1, vec3(173.,250.,0.), vec3(1.,1.,3.) )));\n    h = join(h, hit(11, p1, box(p1, vec3(176.,249.,0.), vec3(1.,1.,.8) )));\n    h = join(h, hit(11, p1, box(p1, vec3(180.,250.,1.0), vec3(3.,3.,0.4) )));\n    h = join(h, hit(8,  p1, box(p1, vec3(195.,250.,1.0), vec3(8.,8.,0.4) )));\n\n    // h = join(h, hit(11, p1, box(p1, vec3(190.,220.,0.), vec3(1.,1.,2.) )));\n\n    /**/\n    float k = 3.;\n    vec3 ps = p-vec3(195.-k,210.+k,0.);\n\tfloat r = length(ps.xy)/5.;\n    ps*=.0;\n\tfloat a = atan(ps.x, ps.z);\n\tfloat v = sin(10.*((r)-0.02*a-.3)) ;\n\tv = sin(-t*4.0+ 10.*3.1415*(r-a/(10.*3.1415)) )*.1+1.6 ;\n     \n    vec3 pb = p1 - vec3(180.,240.,0.);// +vec3(-10,10,iTime);\n    pb = p1 - vec3(180.,240.,0.) +vec3(-10,10,40.-t);\n\n    vec3 ph = pb * 2.;\n    ph.xy = rotate( ph.xy,  -45.  );\n    float fh = smoothstep(0.,.2, hex((vec2(atan(ph.x,ph.y),atan(ph.x,ph.z)))*7.)); \n\n    h = join(h, hit(5, pb, -fh*0.1+ -5. *((1.-fh) * max(0.05,-.5+t*.05+cos(iTime*2.)*0.1) +1.)+(length(pb)) ));\n     \n    pb = p1 - vec3(240.,270.,0.);\n    ph = pb * 2.;\n    ph.xy = rotate( ph.xy,  -45.  );\n    //fh = smoothstep(0.,.2, hex((vec2(atan(ph.x,ph.y),atan(ph.x,ph.z)))*7.)); \n\n    Hit dome = hit(7, pb,  cos(iTime*3.) -8.  +length(pb  ));\n    dome.shi = .9;\n    h = join(h, dome);\n \n    vec3 portalDest = vec3(320.0,280.0,-5.); \n    vec3 portalOri =vec3(200.,210.,-4.);\n    // portalOri =vec3(200.,200.,-5.);\n    // 200.0,200.0,-5.\n    vec3 pt = p-portalOri;\n    float s = 3.;\n    t*=.5;\n\n    h = join(h, hit(7, pt*0.1, vec3(0), true, -0.05+udTriangle(vec3(cos(t*.2),cos(t),cos(t*.3))*s, vec3(cos(t*1.2),cos(t*.1),cos(t*.4))*s , vec3(cos(t*.7),cos(t*.9),cos(t*1.5))*s, pt) ));\n    //h = join(h, hit(7, pt*0.1, vec3(0), true, -0.05+length(pt) ));\n\n    pt = p-vec3(200.,200.,-3.0)-vec3(-0.0,10.,0.);//-vec3(-9.5,5.,0.);//(vec3(191.0,215.0,-4.);// pt-vec3(-9.5,5.,0.);\n    Hit portal = hit(7, pt*0.1, vec3(0), false, -vec3(200.,200.,0.),vec3(0.,0.,0.0), -0.05+\n         -1.5+pow(+iTime*.05,3.)+length(pt+0.1*cos(cos(pt*2.)+pt*3.+fract(iTime*1.)*PI*2.0)));\n    \n    portal.shi = .99;\n    float tk = iTime*4.;\n    h = join(h, portal);\n     \n    pt = p-  vec3(0.,10.,-3.0);\n  \n    float b1 = box(pt, vec3(0.,0.,0.0), vec3(4.,1.,0.4) );\n    float b2 = box(pt, vec3(0.,2.,0.0), vec3(1.,1.,0.3) );\n    float b3 = -2.0+length(pt);\n    \n    b1 =  -.1+abs(sdRoundBox( pt, vec3(3.,3.,1.5), .0 ));\n    b2 =  sdRoundBox( pt-vec3(0.,1.,0.0), vec3(1.,3.,1.3), .1 );\n\n    //b1 = sdRoundBox(pt,  vec3(+fract(iTime)*10.,.9,0.01), 1.1);\n\n    h = join(h, hit(12, pt, max(b1,-b2)));\n    //h = join(h, hit(10, pt, abs(b2)));\n    //h = join(h, hit(10, pt, -.1+abs(b1   )));\n    //h = join(h, hit(10, pt, -.01+abs( max(b1,-b2)   )));\n    //h = sub(h, hit(10, pt, -.1+abs(b1   )));\n    // h.h = ut;\n    \n    /**/\n    return h;\n}\n\nvec3 close3d(RayHit h){ \n    vec2 f = vec2(1.,0.);\n    vec3 d = normalize(h.dir);\n    vec3 p = h.pos;\n\tfloat dx = mapDistance(p - d * f.xyx).distanceRadius ;\n\tfloat dy = mapDistance(p - d * f.yxx).distanceRadius ;\n\tfloat dz = mapDistance(p - d * f.yyx).distanceRadius ;\n\treturn (vec3(dx, dy, dz)) * (h.distanceTotal > 100. ? 0.:1.) ;\n}\n\n// Calculate vector normal to pos\nvec3 normal3d(RayHit h)\n{\n  vec3 pos = h.pos;\n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  float ref;\n  nor.x = mapDistance(pos+eps.xyy).distanceRadius - mapDistance(pos-eps.xyy).distanceRadius;\n  nor.y = mapDistance(pos+eps.yxy).distanceRadius - mapDistance(pos-eps.yxy).distanceRadius;\n  nor.z = mapDistance(pos+eps.yyx).distanceRadius - mapDistance(pos-eps.yyx).distanceRadius;\n  return -normalize(nor);\n}\n\nRayHit raymarching(inout RayHit ray)\n{\n    RayHit nohit;\n    ray.ce = vec3(1.0);\n    ray.uv = ray.dir;\n    ray.minDistance =  1000.;\n    ray.maxDistance = -1000.;\n    \n    //ray\n    for (int i = 0; i < 80; i++)\n    {        \n      \tHit hit = mapDistance(ray.pos);\n        ray.hit = hit;\n        ray.distanceTotal\t+= hit.distanceRadius;           \n        ray.pos \t\t\t+= hit.distanceRadius * ray.dir; \n        ray.count++;\n        ray.countProx += 1.0/ (hit.distanceRadius*1000.0);\n        ray.minDistance = min(ray.minDistance, hit.distanceRadius);\n        ray.maxDistance = max(ray.maxDistance, hit.distanceRadius);\n        //ray.minDistanceAcc += 1.0/ (hit.minDistance*1000.0);\n        ray.minDistanceAcc += hit.shi/(ray.minDistance *3000.0*(1.-hit.shi));\n        ray.maxDistanceAcc += 1.0/(ray.maxDistance *20.0);\n        \n        ray.distanceTotal\t= ray.distanceTotal\t*(1.-hit.shi);\n        \n        ray.glo += 0.;//vec3(.5,0.4,1.)*(min(1./1., max(0.1,hit.distanceRadius))/25.)/ max(0.4, (ray.pos.z-ray.pos.z-20.)*.2);\n\n        if (hit.distanceRadius < .01) {\n             if (hit.r){\n                ray.minDistance =  1000.;\n                ray.maxDistance = -1000.;\n                ray.minDistanceAcc = .0;\n                ray.maxDistanceAcc = .0;\n    \n                ray.refc+=1.;\n               ray.pos -= .02 * ray.dir;\n               ray.dir = -reflect( normal3d(ray), -ray.dir);\n             }\n             else if (hit.pt != vec3(0.))\n             {\n                ray.minDistance =  1000.;\n                ray.maxDistance = -1000.;\n                ray.minDistanceAcc = .0;\n                ray.maxDistanceAcc = .0;\n    \n                vec3 norm = normal3d(ray);\n               ray.ce *= (norm.y)*.5+.5;\n               ray.pos += hit.pt;\n               //ray.dir = hit.pd;\n               //ray.dir = hit.pd;\n               ray.distanceTotal\t= 0.;           // total\n               ray.dir += -norm *.1;  \n               ray.dir.yz = rotate(ray.dir.yz, hit.pd.x);\n               ray.dir.xy = rotate(ray.dir.xy, hit.pd.z);\n               ray.dir.xz = rotate(ray.dir.xz, hit.pd.y);\n               //ray.minDistanceAcc +=10.1;\n               ray.dir = normalize(hit.pd + ray.dir);\n               //ray.dir = ( -normal3d(ray) );\n\n\n             }\n             else\n              break;\n        }\n        if (hit.distanceRadius > 10.) {\n            nohit.distanceTotal = ray.distanceTotal-25.+ 50.*cos(fract(dot(ray.pos,vec3(3321.32315,7.332,0.42597)))); \n            ray = nohit;  \n            ray.hit = nohit.hit;  \n            break;\n        }\t\n    }\n    if (ray.pos.x != 0.){\n        ray.clo = close3d(ray);\n        ray.nor = normal3d(ray);\n        ray.refl = reflect(ray.dir, ray.nor );\n    }\n    \n    return ray;\n}\n\n\nvec3 getColor(inout RayHit r){\n    vec3 p = r.hit.p;\n    float nf = fract(dot(p.xy,vec2(32.44326,1792.33224)));\n    vec3 col = vec3(1.);\n    vec4 vo =  voronoi(r.hit.p.xy*.1);\n    vec2 n = floor(r.hit.p.xy*.1);\n    float t = cos(iTime*.5);      \n    vec4 vo2 = voronoi((cos(p.xy))*1.1);      \n    vec4 vo3 = voronoi(((p.xy))*.05);      \n    switch(r.hit.id)\n    {\n        case 0: \n\t\t\tcol = vec3(0.,0.7,0.9)-min(0.,t); \n       \t\tbreak;\n        case 1: \n            col *= vec3(.1,0.6,0.1)*.8 + vo.w*.3*t;\n\t\t\tcol +=  vo.w*vec3(.8,0.3,0.0)*(1.-smoothstep( 0.04, 0.07, vo2.x ));\n\t\t\tcol.r +=  vo.w*(1.-smoothstep( 0.04, 0.07, vo2.y ));\n       \t\tcol.g += nf*.4;\n            \n            p *= 2.;\n            col.b += (1.-step(.2,vo3.w))*(1.-abs(cos(p.x+cos(p.y)+cos(p.x))));\n            col.rg *= (1.-col.b)*.5+.5;\n            \n            col.rgb += (1.-step(.2,fract(vo3.w*23.237)))*(cos(p.x*10.)*0.3);\n            \n            break;\n        case 2: \n\t\t\tcol *= vec3(.1,0.1,0.6); \n       \t\tbreak;\n        case 3: \n\t\t\tcol *= vec3(0.0,0.6,.6); \n       \t\tbreak;\n        case 4: \n\t\t\tcol +=  vec3(cos(r.hit.p.z*100.))*.2;\n\t\t\tcol *= vec3(.7,.1,0.2); // face\n            break;\n        case 5:\n\t\t\tcol *= vec3(1.); \n            p *= 2.;\n            p.xy = rotate( p.xy,  -45.  );\n            col *= smoothstep(0.,.2, hex((vec2(atan(p.x,p.y),atan(p.x,p.z)))*7.)); \n            break;\n        case 6:\n\t\t\tcol *= vec3(.18,.15,0.1);\n            break;\n        case 7:\n\t\t\tcol.rg *= vec2(15.,2.); \n            col.b += 3.*(p.z+4.); \n            col *= .4 + pow(abs(fract(iTime*0.2)*2.0-1.0),3.);\n            col *= smoothstep(0.,.2, hex((p.xz+vec2(0.,0.))*.5)); \n            r.nor = vec3(0.,0.,-1.);\n            \n            break;\n        case 8: \n\t\t\tcol *= vec3(.34,.27,0.72);\n            break;\n        case 9: \n\t\t\tcol *= vec3(.5,.34,0.28); \n            break;\n        case 10: \n\t\t\tcol *= vec3(.6,.7,0.3);\n            break;\n        case 11: \n\t\t\tcol *= vec3(1.0+cos(floor(p.z*40.0))+cos(p.x*10.0),.2,0.1); \n            break;\n        case 12: \n            col = vec3(0.5+ (cos(p.x)*.4+cos(p.y)*.4) +1.*cos(p.z)); \n            r.nor = vec3(0.,0.,0.);\n            col += texture(iChannel1,-p.xz*.3+.5+vec2(p.y*.8,0)).rgb;\n            break;\n            \n    }\n    col.rgb += nf*.1;\n    \n    r.minDistanceAcc = r.minDistanceAcc*clamp( 1. - iTime*.02, 0., 1.);\n    col.rgb += r.minDistanceAcc * (1.-r.refc);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n    \n    RayHit r;\n    r.pos = vec3(200.0,200.0,-5.);\n    r.pos.x += min(2., pow(iTime*.05,5.))*iTime+iTime*0.2;\n    r.dir = vec3(p.xy*1.,1.);\n\n    r.dir.yz = rotate(r.dir.yz,(iMouse.y)/200.0-.5+2.);\n    r.dir.xy = rotate(r.dir.xy,(iMouse.x)/200.0-.5);\n \n    /////////////////////\n    float speed =1.;\n    float totalTime = 170.;\n    \n    totalTime /= speed;\n    it = fract((iTime+0.)/totalTime)*totalTime;\n    \n    it *= speed;\n \n    vec4 animPos[16];  // keyframes positions\n\n    animPos[0] = vec4(200.0,200.0,-5.,00.0);\n    animPos[1] = vec4(210.0,200.0,-5.,10.0);\n    animPos[2] = vec4(205.0,200.0,-5.,28.0);\n    animPos[3] = vec4(200.0,210.0,-5.,28.2);\n    animPos[4] = vec4(203.0,200.0,-5.,29.0);\n    animPos[5] = vec4(220.0,200.0,-5.,40.0);\n    animPos[6] = vec4(250.0,200.0,-5.,41.0);\n    animPos[7] = vec4(250.0,230.0,-5.,41.01);\n    animPos[8] = vec4(324.0,280.0,-6.,50.0);\n    animPos[9] = vec4(700.0+iTime,400.0,-5.,70.0);\n    animPos[10] = vec4(0.0,30.0,   -5.,80.0);\n    animPos[11] = vec4(0.0,30.0,   -5.,90.0);\n    animPos[11] = vec4(0.0,30.0,   -5.,102.0);\n    animPos[12] = vec4(0.0,10.0,   -3.,104.0);\n    animPos[13] = vec4(0.0,8.0,   -3.,105.0);\n    animPos[14] = vec4(0.0,30.0,   -3.,163.0);\n    animPos[15] = vec4(0.0,330.0,   -3.,170.0);\n    \n    vec4 animDir[15];  // keyframes orientation\n    animDir[0] = vec4(0.5,+00.0,-00.15,00.0);\n    animDir[1] = vec4(0.5,+00.0,-00.15,28.0);\n    animDir[2] = vec4(0.6,+00.0,-00.15,30.0);\n    animDir[3] = vec4(0.55,+00.1,-00.20,31.0);\n    animDir[4] = vec4(0.5,-00.2,-00.05,40.0);\n    animDir[5] = vec4(0.5,+00.0,-00.15,41.0);\n    animDir[6] = vec4(0.5,+00.,00.3,48.00);\n    animDir[7] = vec4(0.5,+01.2,-00.75,54.00);\n    animDir[8] = vec4(0.5,+cos(iTime*0.5)*.3,-00.15,58.01);\n    animDir[9] = vec4(0.5+cos(iTime*0.5)*.04,+00.0+cos(iTime*0.05)*.08,-00.15+cos(iTime*0.05),88.01);\n    animDir[10] = vec4(0.5,+00.1,-01.1,98.01);\n    animDir[11] = vec4(0.5,+00.0,-01.0,104.01);\n    animDir[12] = vec4(0.5,+00.0,-00.05,105.01);\n    animDir[13] = vec4(0.5,+00.0,-00.05,140.01);\n    animDir[14] = vec4(0.5,+00.0,-01.0,143.01);\n        \n    int LEN_POS = animPos.length();\n    int LEN_DIR = animDir.length();\n    \n    vec4 pos = animPos[0].xyzw;\n    vec4 dir = animDir[0].xyzw;\n\n    animFrame(it, animPos, LEN_POS, pos);\n    animFrame(it, animDir, LEN_DIR, dir);\n\n    r.pos = pos.xyz;\n    r.dir = vec3(p.xy*1.,1.);\n\n    r.dir.yz = rotate(r.dir.yz, dir.x*PI );\n    r.dir.xy = rotate(r.dir.xy, dir.z*PI);\n    r.dir.xz = rotate(r.dir.xz, dir.y*PI);\n\n    vec3 dire = r.dir;\n    /////////////////////\n \n    raymarching(r);\n    \n    vec3 pr = r.hit.p;\n    float nf = fract(dot(pr.xy,vec2(32.44326,1792.33224)));\n   \n    vec3 col = getColor(r);\n    col = vec3(col)*normalize(r.nor+.8);\n    \n    col = mix(col, vec3(0.,0.7,0.9), clamp(r.distanceTotal*0.01,  0., 1. ));\n\n    float dis = 1.;\n\tfor (int i = 0; i < 10; i++)\n\t{\n        float f = pow(dis, .5)+.2;\n        vec2 st =  f * (vec2(dire.x,uv.y) * vec2(1., .05) + vec2(-.2* iTime + 0.5*(dire.x-uv.y) , .2* iTime)  );\n        vec4 tc = texture(iChannel3, st * .5);\n        f = (tc.x +.7);\n        f = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.0, 1.);\n        vec3 bri = vec3(.25);\n        col += bri*f * (1.-clamp( (iTime-105.0), 0., 1. ));\n        dis += 3.5;\n\t}\n\n    col = mix(col, vec3(0.), (smoothstep(0., 1.0, 1.-(.9-length(p)) )) );\n    float o = (max(.23,2.4-iTime*0.1) );\n    col = mix(col, vec3(0.), (smoothstep(0., .005, abs (p.y)-o)) );\n\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat soundRange(float time, float s1, float e1, float s2, float e2 ){\n    return smoothstep(s1, e1, time) * smoothstep(e2, s2, time);\n}\nvec2 mainSound( int samp, float time )\n{\n    vec2 r;\n    float t = abs(fract((time+10.0)*122.4)*3.141592*2.);\n    float t2 = abs(fract((time+10.0)*721.3)*3.141592*2.);\n    \n    float f = max(0., floor(time));\n    r = vec2( sin(f*6.2831*(time+0.+(abs(cos(t)+cos(t2))))) * exp((time-f)*-3.)  );\n    \n    \n    float timef = max(0., time*2.5);\n    float f2 = max(0., fract(timef*.4217)*450.0);\n    r +=  smoothstep(10.0, 30.0, time) * vec2( sin(6.2831*(f2*timef+(abs(cos(t)+cos(t2))))) * exp((0., fract(timef)*-3.))  );\n    \n    timef = max(0., time*4.0);\n    f2 = max(0., fract(timef*.4217)*1450.0);\n    \n    r += soundRange(time, 20.0,  30.0,  50.0,  60.0) * vec2( sin(6.2831 * (f2 * cos(timef*3.2)+(abs(cos(t)+cos(t2))))) * exp((0., fract(timef)*-3.))  );\n    r += soundRange(time, 23.0,  30.0,  30.0,  31.0) * vec2(  sin(6.2831*440.0 * cos(time*10.0)) );\n    r += soundRange(time, 27.0,  30.0,  30.0,  31.0) * vec2(  sin(6.2831*440.0 * cos(time*20.0)) );\n    r += soundRange(time, 95.0, 102.0, 160.0, 170.0) * vec2(  sin(6.2831*440.0*cos(fract(time)*100.0*cos(fract(time)*0.3)))*.4 );\n\n    // return (r);\n    return clamp(r,-1.0,1.0);\n}","name":"Sound","description":"","type":"sound"}]}