{"ver":"0.1","info":{"id":"4XsXWS","date":"1724850735","viewed":21,"name":"Gyroid funnee","username":"MonadoMaster0","description":"Just some gyroids, enjoy!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gyroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// quadratic polynomial\nfloat smin( float a, float b, float k )\n{\n    k *= 4.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 q = abs(p)-s;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdLineSegment( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat Gyroid(vec3 p) {\n    return abs(dot(sin(p*2.0),cos(p.zxy*0.5))-1.4)/10.0;\n}\n\nfloat tnoise(float x) {\n    float f = smoothstep(0.0,1.0,fract(x));\n    float n1 = hash21(floor(vec2(x,1)));\n    float n2 = hash21(floor(vec2(x+1.0,1)));\n    return mix(n1,n2,f);\n}\n\nfloat map(vec3 p) {\n    float val = 0.0;\n    \n    vec3 t = p;\n    t.xz *= rot(iTime*0.1);\n    t.yz *= rot(iTime*0.1);\n    val = sdBox(t,vec3(0.8));\n    t.z+=iTime*0.3;\n    /*vec3 gp = p;\n    p.x+=iTime*0.1;\n    p.z += tnoise(iTime+p.x*2.0);\n    p.y += fbm2(p.xz*0.2,1);*/\n    \n    //val = p.y-0.1;\n    float gyro = Gyroid(t*10.0);\n    vec3 sm = sNoise(t*5.0);\n    float smoi = dot(sin(sm),cos(sm.yzx))/10.;\n    float noi = noised(p*4.).x;\n    float qq = smoothstep(0.0,1.0,gyro);\n    val = max(val, qq);\n    \n    return val;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    float zoom = 0.2;//*sin(iTime*0.5);\n    \n    //Initialization\n    vec3 ro = vec3(0,0,zoom-3.0);\n    vec2 av = vec2(length(uv),sin(atan(uv.x,uv.y))*0.5);\n    vec3 rd = normalize(vec3(uv,zoom+1.0));\n    float t = 0.0;\n    \n    //Raymarching\n    int i;\n    vec3 p;\n    for (i=0;i++<80;) {\n        p = ro + rd * t;\n        //Current distance\n        float d = map(p);\n        //Total distance travelled\n        t += d;\n        //Limits\n        if (t>80. || d<0.001) break;\n        //if (d<0.001) break;\n    }\n    \n    //lighting\n    vec3 lo = normalize(vec3(0,0,-3));\n    vec3 norm = calcNormal(p);\n    //vec3 norm = normalize(noised(p*4.0).yzw);\n    float light = dot(norm*1.0, lo);\n    \n    float tr = (float(i)/80.*1.0+t*0.01);\n    //col += (float(i)/80.*1.0+t*0.01);\n    col += light;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nmat2 rot(float t) {\n    float c=cos(t),s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat cFloor(float n, float m) {\n    return (n-mod(n,m))/m;\n}\n\nvec2 cFloor(vec2 n, float m) {\n    return (n-mod(n,m))/m;\n}\n\nvec3 cFloor(vec3 n, float m) {\n    return (n-mod(n,m))/m;\n}\n\nvec2 hash2(vec2 p) {\n    float s = dot(p, vec2(716.837,433.103));\n    float d = dot(p, vec2(261.293,102.063));\n\n    return -1.0+2.0*fract(sin(vec2(s,d))*(47546.9294));\n}\n\nvec3 hash31(vec3 p) {\n    float s = dot(p, vec3(716.837,433.103, 482.093));\n    float d = dot(p, vec3(261.293,102.063, 27.842));\n    float f = dot(p, vec3(78.872,546.111, 35.956));\n\n    return -1.0+2.0*fract(sin(vec3(s,d,f))*(47546.9294));\n}\n\nfloat hash21(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat grassLayer(vec2 p, float gs, float scale) {\n    float h = (hash21(cFloor(p,gs))*0.5+0.5);\n    scale *= 0.1;\n    scale+= 0.9;\n    return h<scale?0.0:h;\n}\n\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 g = fract(p);\n    vec2 u =g*g*(3.0-2.0*g);\n    float r = 0.5;\n    \n    float a = dot((hash2(i+vec2(0.0,0.0))),g-vec2(0.0,0.0)),\n          b = dot((hash2(i+vec2(1.0,0.0))),g-vec2(1.0,0.0)),\n          c = dot((hash2(i+vec2(0.0,1.0))),g-vec2(0.0,1.0)),\n          d = dot((hash2(i+vec2(1.0,1.0))),g-vec2(1.0,1.0));\n    float bot = mix(a,b,u.x),\n          top = mix(c,d,u.x);\n    return mix(mix(a,b,u.x),\n               mix(c,d,u.x),u.y);\n    //return d;\n}\n\nfloat fbm2(vec2 p, int oct) {\n    \n    float brightness = 0.5;\n    \n    float val = 0.0;\n    float amp = 0.5;\n    float freq = 3.0;\n\n    float back = 0.0;\n    \n    //val+=amp*noise(p*freq);\n    for (int i=0;i<oct;i++) {\n        //p.x+=iTime*back;\n        val+=amp*noise2(p*freq+float(i)*freq);\n        back*=0.5;\n        freq*=2.0;\n        amp*=0.5;\n        \n    }\n    return val+brightness;\n}\n\nvec3 sNoise(vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    vec3 u = smoothstep(0.0,1.0,f);\n    \n    return mix(hash31(i),hash31(i+1.0),u);\n}\n\n vec4 noised( in vec3 x )\n {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash31( p+vec3(0,0,0) ).x;\n    float b = hash31( p+vec3(1,0,0) ).x;\n    float c = hash31( p+vec3(0,1,0) ).x;\n    float d = hash31( p+vec3(1,1,0) ).x;\n    float e = hash31( p+vec3(0,0,1) ).x;\n    float f = hash31( p+vec3(1,0,1) ).x;\n    float g = hash31( p+vec3(0,1,1) ).x;\n    float h = hash31( p+vec3(1,1,1) ).x;\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                 2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                 k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                 k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}","name":"Common","description":"","type":"common"}]}