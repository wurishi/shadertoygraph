{"ver":"0.1","info":{"id":"XtBcDK","date":"1510103480","viewed":98,"name":"How raymarching works. ","username":"Zunze","description":"Red point is the camera location, a blue ray is casted to locate the intersecting surface. \nClick & move the mouse to see the calculus done during the progression along the blue in a ray marching algorithm in 2D.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereDF(in vec2 pos, in vec2 center, in float radius)\n{\n    float l = length(center - pos) - radius ;\n    return l;\n}\n\nfloat cubeDF(in vec2 pos, in vec2 center, in vec2 dim, in float r)\n{\n  return length(max(abs(pos-center)-dim,0.0))-r;\n}  \n\nfloat distanceToLine(in vec2 pos, in vec2 a, in vec2 b)\n{\n    return abs((b.y-a.y)*pos.x - (b.x-a.x)*pos.y + b.x*a.y - b.y*a.x) / distance(a,b) ;\n}\n\nvec4 renderImplicitSurface2D(float d, float isovalue, float scale, float linespace)\n{\n    /// Background color, rescale the color to avoid to dark image\n    float dd = abs((scale*d)) ;\n    \n    /// Compute when we need to draw a line. \n    float pd = abs(d);\n    float dfact = mod(pd, linespace+0.05)  ;\n    dfact = abs(dfact-linespace) ;\n    float line = 1.0 ; \n    if( dfact < 0.01 )\n    {\n    \tline = abs(dfact)/ 0.01;\n    }\n    /// Generate the field color blended with the line\n    vec4 fragColor = line * dd  * vec4(0.9,0.9,0.7,1.0); \n    \n    /// Render the implicit surface in red. \n    if( d > isovalue-0.005 && d < isovalue+0.005 )\n    {\n        float dd = (abs(d)-isovalue) / 0.005   ; \n        fragColor = (1.0-dd) * vec4(1.0,0.3,0.0,1.0) + dd * fragColor;\n    }\n    return fragColor ; \n}\n\nfloat distanceFieldAt(in vec2 correctPos)\n{    \n    float s1 = sphereDF(correctPos, vec2(-0.1,0.0), 0.3) ; \n    float s2 = sphereDF(correctPos, vec2(-0.4,0.05), 0.2) ; \n    float s3 = cubeDF(correctPos, vec2(0.0,0.0), vec2(0.2,0.05), 0.01); \n    float s4 = cubeDF(correctPos, vec2(0.8,0.0), vec2(0.02,0.6), 0.05); \n    \n    return min(max(-s2, min(s1,s3)), s4);\n}\n\nvec4 getCircle(in vec2 evalPos, in vec2 center, in float radius, in vec4 color)\n{\n    float d = distance(evalPos, center) - radius ; \n    \n    /// Center. \n    if( d < -radius+0.01 )\n    {\n    \t//color.w = 1.0-(abs(d) / 0.02);\n        return color ; \n    }\n    \n    if( d < 0.005 && d > -0.005 )\n    {\n    \t//color.w = 1.0 - ( abs(d) / 0.01);\n        return color ; \n    }\n    if( d < 0.012 && d > -0.012 )\n    {\n        color = vec4(0,0,0,1.0);\n    \tcolor.w = 1.0-(abs(d) / 0.02);\n        return color ; \n    }\n        \n    return vec4(1,1,1,0) ; \n}\n\nvec4 getLine(in vec2 evalPos, in vec2 a, in vec2 b, in vec4 color)\n{\n\tfloat d = distanceToLine(evalPos, a, b);\n    if(d < 0.01 && evalPos.x > -1.0)\n    {\n    \t//color.w = \n        return color;\n    }\n    return vec4(1.0,1.0,1.0,0.0);\n}\n\n\n/// cette fonction est appelée automatiquement pour chaque pixel de l'image. \n/// input: fragCoord est la position en pixel du pixel \n/// output: fragColor est la couleur de sortie du pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rescale=3.0;\n    /// Normalisation des coordonnées du fragment pour travailler dans \n    /// un interval [-1, 1]\n    float aspectRatio = iResolution.x / iResolution.y ; \n    vec2 posNormalized = (fragCoord / iResolution.xy) - 0.5 ;\n    vec2 correctPos = vec2(posNormalized.x, posNormalized.y/aspectRatio) * rescale ;    \n    vec2 mousePos = ( iMouse.xy / iResolution.xy ) - 0.5 ;\n    mousePos = vec2(mousePos.x, mousePos.y/aspectRatio) * rescale ; \n    \n    float d = distanceFieldAt(correctPos);\n    fragColor = renderImplicitSurface2D(d, -0.0, 5.0, 0.05) ; \n    \n    vec2 cameraPos = vec2(-1,0.0) ;\n    if( distance(cameraPos, correctPos) < 0.02 )\n    {\n    \tfragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n\n    float f = abs(distanceFieldAt(mousePos));\n     \n    vec4 l1 = getLine(correctPos, cameraPos, mousePos, vec4(0.0,0.0,1.0,1.0));\n    fragColor = (1.0-l1.w)*fragColor + (l1.w * l1) ; \n    \n    vec2 p0 = cameraPos ;\n    vec2 dir = normalize(mousePos - cameraPos) ; \n    vec2 p = p0;\n    for(int i=0;i<20;i++)\n    {\n        if(p.x > mousePos.x){\n            i=20;\n        \tbreak;\n        }\n        float cd = distanceFieldAt(p);\n        if(cd < 0.01){\n\t    \tvec4 c1 = getCircle(correctPos, p, cd, vec4(1.0,1.0,0.0,1.0)) ; \n    \t\tfragColor = (1.0-c1.w)*fragColor + (c1.w * c1) ; \n        \tbreak;\n        }\n        \n        \n        vec4 c1 = getCircle(correctPos, p, cd, vec4(0.0,0.0,1.0,1.0)) ; \n    \tfragColor = (1.0-c1.w)*fragColor + (c1.w * c1) ; \n \n    \tp = p + dir*cd ;  \n    }\n}","name":"Image","description":"","type":"image"}]}