{"ver":"0.1","info":{"id":"dtsfWX","date":"1693549268","viewed":152,"name":"folds on folds","username":"vivavolt","description":"desc","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Rosas\" by Elsio. https://shadertoy.com/view/mtlBR7\n// 2023-09-01 06:20:57\n\n#define res iResolution.xy\n#define rot(a) mat2 (cos(a), sin(a), -sin(a), cos(a))\n#define PI atan(.0, -1.)\n#define T iTime * .1\n\nfloat map(vec2 p){\n    p *= .04 * sin(T);\n    \n    float i, f, \n          s = .5,\n          t = 2.;\n          \n    while(i++ < 4.) {\n        t += s * (2.*cos(p.x * 1.) + sin(1. * p.y));\n        p *= rot(T);\n        p += t * 3.;\n        s *= 0.8;\n    }\n    return t;\n}\n\n\nvoid mainImage(out vec4 O, vec2 u){\n    vec2 uv = vec2(3, 2) * (u - .5 * res) / res.y;\n    \n    vec3 cw, cu, cv, rd, ba;\n    vec3 ro, ta;\n\n    ro = vec3(420., 970., 500.);\n    ta = vec3(0);\n    \n    ba = ta - ro;\n    cw = normalize(ba);\n    cu = cross(cw, vec3(0, 1, 0));\n    cv = normalize(cross(cu, ba));\n\n    rd = normalize(\n        uv.x * cu + uv.y * cv + 2.* normalize(cw)\n    );\n    \n    ro.xz *= rot(T);\n    rd.xz *= rot(T);\n\n    vec3 p;\n    float h, i, t, s;\n    while(i++ < 200.) {\n        p = ro + t * rd;\n        s = map(p.xz);\n        h =  p.y - s * 100.;\n\n        if(h < .1 * t) break;\n        t += h * .02;\n    }\n    \n    float d =  1. - exp(-.0000049 * t * t) * 3.;\n    //O = vec4(colormap(d), 1.);\n    vec3 c = colormap(d);\n    O = vec4(c, 1.);\n    O = 1. -vec4(pow(O.xyz,vec3(1./2.2)),1.0);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 color(float f){\n    vec3 white = vec3(1);\n    vec3 pink = vec3(255, 168, 210) / 256.;\n    vec3 black = vec3(0);\n\n    vec3 col = mix(\n        mix(white, pink, f * 2.), \n        mix(pink, black, (f - .5) * 2.), \n        f * .8\n    );\n\n    return col;\n}\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), map_range_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), map_range_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), map_range_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), map_range_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), map_range_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), map_range_clamp(x, 0.6, 1.0, 0.0, 1.0));\n    \n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n    \n    return c;\n}\n\n// applying fast white noise  https://shadertoy.com/view/DtfBRM\n// some limitations: - I don't manage cells border ( should visit neighbors )\n//                   - no seed coherence when the density varies in time\n\n#define iH3(f)  uhash3( floatBitsToUint(f) ) // FabriceN version https://www.shadertoy.com/view/NtjyWw\n#define iH32(f) iH3(f).xy\n\n\nvec3 uhash3( uvec3 x ) {         // iq version https://shadertoy.com/view/XlXcW4\n    const uint k = 1103515245U;  // GLIB C version\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)/float(0xffffffffU);\n}\n\n\nvec3 palette(float d) {\n    vec3 neonGreen = vec3(1.2, 1.0, 0.4); // Neon Green\n    vec3 darkerGreen = vec3(0.1, 0.3, 0.1); // Darker Green\n    return mix(neonGreen, darkerGreen, d);\n}\n","name":"Common","description":"","type":"common"}]}