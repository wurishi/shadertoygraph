{"ver":"0.1","info":{"id":"WlG3Rw","date":"1605783049","viewed":160,"name":"Hex Grid Example","username":"KJK","description":"I finally figured out how to make a hex grid. Hold down mouse to see associated skewed grid.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hexgrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TAU = 6.283185307;\nconst vec2 UP = vec2(.0, 1.);\n\nvec2 polar(float angle) {\n    return vec2(cos(angle), sin(angle));\n}\n\nconst mat2 hexToUv = mat2(\n    1., .0,\n    .5, .866 // = cos(TAU/6), sin(TAU/6)\n);\n\nconst mat2 uvToHex = mat2(\n    1., .0,\n    -.577, 1.155\n); // = inverse(hexToUv)\n\nvec3 cubeCoords(vec2 h) {\n    return vec3(1., 1., .0) * h.x + vec3(1., .0, 1.) * h.y;\n}\n\nfloat hexDist(vec2 h) {\n    vec3 c = abs(cubeCoords(h));\n    return max(c.x, max(c.y, c.z));\n}\n\nfloat hexEdgeDist(vec2 uv) {\n    uv = abs(uv);\n    return max(\n        dot(uv, polar(.0)),\n        max(\n            dot(uv, polar(TAU / 6.0)),\n            dot(uv, polar(TAU / 3.0))\n        )\n    );\n}\n\n// This is probably seriously over complicated.\nvec2 uvToHexCoord(vec2 uv) {\n    // Convert to skewed coordinates\n    vec2 skew = uvToHex * uv;\n    vec2 coord = floor(skew);\n    \n    // Currently, the boundaries between coords is a skewed grid rather than a true hex grid.\n    // We need to jump to a neighboring cell if we're closer to it's center than our own.\n    \n    // Calculate offset of uv from hex center.\n    vec2 center = hexToUv * (coord + .5);\n    vec2 offset = uv - center;\n\n    // Determine which edges of the skewed grid square are closest by looking at height above the cell's diagonals.\n    // If heights above diagonals have like signs, then a horizontal edge is closest.\n    // If not, a vertical edge is closest.\n    float leftDiagH = dot(offset, polar(TAU / 12.));\n    float rightDiagH = dot(offset, polar(TAU / 3.));\n    float sgn = leftDiagH * rightDiagH;\n    \n    // Determine which way to move along the right or upper-right hex axis.\n    // Measure offset along hex's right and upper-right normals.\n    float rComp = offset.x;\n    float urComp = dot(offset, polar(TAU / 6.));\n    \n    // Jump along the nearest edge.\n    vec2 jump = sgn > .0 ? vec2(.0, floor(urComp + .5)) : vec2(floor(rComp + .5), .0);\n    coord += jump;\n    \n    return coord;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5);\n    uv *=0.025;\n    \n    uv += polar(TAU/12.);\n    \n    vec3 col = vec3(.0);\n    \n    vec2 coord = uvToHexCoord(uv);\n    \n    float colorPeriod = 2.0;\n    if (hexDist(coord) > 4.5) \n        col += vec3(1., .0, .0);\n    else \n        col += vec3(0.0, mod(coord, colorPeriod) / (colorPeriod - 1.0));\n    \n    vec2 center = hexToUv * (coord+.5);\n    vec2 offset = uv - center;\n    \n    float edgeDist = hexEdgeDist(offset);\n    col += vec3(smoothstep(1. - .1, 1., edgeDist * 2.0));\n    \n    float r = length(offset);\n    col += 1. - smoothstep(.125 - .025, .125 + .025, r);\n    \n    // Draw skew grid\n    if (iMouse.z > .0) {\n        vec2 suv = uvToHex * uv;\n        vec2 sCenter = floor(suv) + .5;\n        vec2 sOffset = suv - sCenter;\n        vec2 aso = abs(sOffset);\n        float d = max(aso.x, aso.y);\n        col += smoothstep(1. - .1, 1., d * 2.);\n    }\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}