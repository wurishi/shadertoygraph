{"ver":"0.1","info":{"id":"dtcBzs","date":"1701470658","viewed":51,"name":"Kaleidoscope dream","username":"Malte_H","description":"A kaleidoscope shader gone out of hand","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["surrealkaleidoscopecolors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.x / iResolution.y;\n    float pixelSize = 1.0 / iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    float streaks = Rand(uv.y + iTime).x;\n    uv.x += streaks * pixelSize;\n    \n    vec4 R = texture(iChannel0, ScaleFromOrigin(uv, vec2(0.5, 0.5), 0.99) + vec2(pixelSize, 0.0));\n    vec4 G = texture(iChannel0, uv);\n    vec4 B = texture(iChannel0, ScaleFromOrigin(uv, vec2(0.5, 0.5), 1.01) - vec2(pixelSize, 0.0));\n    \n    float letterbox = step(abs(uv.y * 2.0 - 1.0), 0.9);\n    \n    fragColor = Saturation(vec4(R.r, G.g, B.b, 1.0), 1.5) * letterbox;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TAU 6.28318530718\n\nvec2 Rotate2D(vec2 source, float angle)\n{\n    mat2 RotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n\n    return RotationMatrix * source;\n}\n\nvec2 Rand(float index)\n{\n    float X = fract(sin(fract(index * 1754.121643)) * 326.821332);\n    float Y = fract(sin(fract(index * 912.631643)) * 726.428332);\n    \n    return vec2(X, Y);\n}\n\nvec2 ScaleFromOrigin(vec2 source, vec2 offset, float scale)\n{\n    return (source - offset) * scale + offset;\n}\n\nvec4 Remap(vec4 IN)\n{\n    return 1.0 - (1.0/(IN+1.0));\n}\n\nvec4 Saturation(vec4 IN, float amount)\n{\n    float BnW = dot(IN, vec4(0.30, 0.59, 0.11, 0.0));\n    return mix(vec4(BnW), IN, amount);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int CORNERS = 6;\n    const float SPEED = 0.1;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centerUV = uv * 2.0 - 1.0;\n    centerUV.x *= aspect;\n    vec2 centerUVRaw = centerUV;\n    // centerUV *= 10.0;\n    \n    vec2 circleUV = vec2((atan(centerUV.y, centerUV.x) + PI) / TAU, length(centerUV));\n    float rotationOffset = sin(iTime * SPEED * 0.5) - cos(circleUV.y - iTime) * 0.1;\n    circleUV.x += rotationOffset;\n    circleUV.x = floor(circleUV.x * float(CORNERS)) / float(CORNERS);\n    \n    float rotAmount = (circleUV.x + 1.0 / float(CORNERS * 2) - rotationOffset) * TAU;\n    centerUV = Rotate2D(centerUV, rotAmount);\n    vec2 rotatedUVRaw = centerUV;\n    centerUV.x = abs(mod(centerUV.x, 1.0) * 2.0 - 1.0);\n    centerUV.y = abs(centerUV.y);\n    \n    vec2 UVGrid = fract(rotatedUVRaw * 2.0) * 2.0 - 1.0;\n    \n    vec4 tex = texture(iChannel0, centerUV + iTime * 0.1);\n    vec4 tex2 = texture(iChannel1, centerUV - iTime * 0.26);\n    tex *= tex2;\n    tex *=3.0;\n    tex = pow(tex, vec4(2.0));\n    tex *= 2.0;\n    float grid = 1.0 - min(length(centerUV.x * 2.0), length(centerUV.y * 2.0));  \n    float succ = pow(sin(rotatedUVRaw.x + iTime * 4.0 + rotAmount), 5.0);\n    \n    float tile = floor(rotatedUVRaw.y * 2.0) + floor(rotatedUVRaw.x * 2.0);\n    vec2 eyeOffset = vec2(0.0, 0.7);\n    float eyeBase = step(max(length(UVGrid + eyeOffset), length(UVGrid - eyeOffset)), 0.9);\n    float eyeBall = step(0.2, length(UVGrid + (Rand(floor(iTime + tile * 0.32)) * 2.0 - 1.0) * 0.1));\n    \n    float mainEye = smoothstep(0.55, 0.54, max(length((centerUVRaw + eyeOffset * 0.5) * (sin(iTime * 0.2) * 0.1 + 1.0)), length((centerUVRaw - eyeOffset * 0.5) * (sin(iTime * 0.2) * 0.1 + 1.0))));\n    mainEye *= smoothstep(0.14, 0.16, length(centerUVRaw));\n    float finalEye = eyeBase * (1.0 - length(UVGrid * 2.0)) * eyeBall + mainEye;\n    finalEye = clamp(finalEye, 0.0, 1.0);\n    finalEye *= 10.0;\n    \n    // Output to screen\n    // fragColor = vec4(centerUV, 0.0, 1.0); \n    fragColor = tex + circleUV.y * 0.1 + (pow(grid, 5.0) + pow(max(grid - 0.01, 0.0), 15.0) * 2.0 + max(succ, 0.0) * 0.5) * circleUV.y * vec4(0.9, 0.5, 0.2, 1.0) * 2.0 + finalEye; //vec4(fract(centerUV.x + iTime));\n    fragColor = Remap(fragColor * 2.0);\n    // fragColor = vec4( * 0.5 + finalEye);\n}","name":"Buffer A","description":"","type":"buffer"}]}