{"ver":"0.1","info":{"id":"ctV3zc","date":"1684370847","viewed":93,"name":"Frustum clipping","username":"jozxyqk","description":"Renders a projection frustum, generates some random lines and clips them to the frustum.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["frustum","clipping","linesegment","clipspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pyarelal Knowles 2023\n\n\n#if 1\n\n// Long winded function with lots of comments to clip a line segment in 4D clip space.\n// This is an adaption of various sources and probably the same Larry57's below, but with time\n// taken for me to understand each step of the way and try to describe it.\n// See: https://www.heuristic42.com/27/rendering/spaces/clip_space/\n// Values for the six planes are stored in \"low\" (negative) and \"high\" (positive) vec3s.\nbool clipLineSegment(inout vec4 p0, inout vec4 p1)\n{\n    // Early behind the viewer rejection\n    if(p0.w < 1e-6 && p1.w < 1e-6)\n        return false;\n        \n    // Cohen-Sutherland outcodes for early rejection\n    bvec3 p0Low = lessThan(p0.xyz, vec3(-p0.w));\n    bvec3 p0High = greaterThan(p0.xyz, vec3(p0.w));\n    bvec3 p1Low = lessThan(p1.xyz, vec3(-p1.w));\n    bvec3 p1High = greaterThan(p1.xyz, vec3(p1.w));\n    #if 1\n    if(any(bvec3(uvec3(p0Low) & uvec3(p1Low))) || any(bvec3(uvec3(p0High) & uvec3(p1High))))\n        return false;  // Both points are on the outside of a clipping plane\n    if(all(not(bvec3(uvec3(p0Low) | uvec3(p1Low)))) && all(not(bvec3(uvec3(p0High) | uvec3(p1High)))))\n        return true;  // Both points are inside all planes\n    #endif\n\n    // Direction vector in clip space\n    vec4 d = p1 - p0;\n    \n    // Find t for the -x, -y, -z clip plane intersections.\n    // In clip space, this is when e.g. x == -w. Substituting the line equation,\n    // find p0.x + d.x * t = -(p0.w + d.w * t) but for all x, y, z.\n    vec3 tLow = -(p0.xyz + p0.w) / (d.w + d.xyz);\n    \n    // Find t for the +x, +y, +z clip plane intersections.\n    // In clip space, this is when e.g. x == w.  Substituting the line equation,\n    // find p0.x + d.x * t = p0.w + d.w * t but for all x, y, z.\n    vec3 tHigh = (p0.xyz - p0.w) / (d.w - d.xyz);\n    \n    // The above values are only valid for each axis when the direction vector is not near parallel, i.e. near a divide by zero\n    bvec3 tLowValid = greaterThan(abs(d.w + d.xyz), vec3(1e-6));\n    bvec3 tHighValid = greaterThan(abs(d.w - d.xyz), vec3(1e-6));\n    \n    // For each intersection, is it a lower or upper bound on the line segment.\n    // Note that x and y axes may have two lower or two upper bounds\n    // due to the nature of the perspective projection inverting at w=0.\n    // If this were not the case, we could simply sort the two values for each axis.\n    // Lower bounds are when the ray direction matches the plane normal (facing the origin).\n    // Uppwer bounds are when the ray direction is opposite the plane normal.\n    // E.g. the normal for the plane at x = -w, or x + w = 0 is trivially (1, 0, 0, 1).\n    // Then the sign of dot(normal, d), or d.x + d.w, answers if d moving in this direction.\n    bvec3 tLowUpper = lessThan(d.xyz + d.w, vec3(0));\n    bvec3 tHighUpper = greaterThan(d.xyz - d.w, vec3(0));\n    \n    // This cannot work due to the description above\n    #if 0\n    vec3 t0v = min(tLow, tHigh);\n    vec3 t1v = max(tLow, tHigh);\n    float t0 = max(0.0, max(max(t0v.x, t0v.y), t0v.z));\n    float t1 = min(1.0, min(min(t1v.x, t1v.y), t1v.z));\n    #endif\n    \n    // Initial t values, covering the whole segment\n    float t0 = 0.0;\n    float t1 = 1.0;\n    \n    // Clip t0 and t1 for each plane\n    for (int i = 0; i < 3; i++) {\n        if (tLowValid[i]) {\n            if (!tLowUpper[i])\n                t0 = max(t0, tLow[i]);\n            else\n                t1 = min(t1, tLow[i]);\n        }\n\n        if (tHighValid[i]) {\n            if (!tHighUpper[i])\n                t0 = max(t0, tHigh[i]);\n            else\n                t1 = min(t1, tHigh[i]);\n        }\n    }\n\n    // Check if the line enters and exits the clipping planes of one axis before another\n    if(t0 >= t1)\n        return false;\n\n    // If any clipping was performed, t0 and t1 will have changed\n    vec4 p0t = p0;\n    vec4 p1t = p1;\n    #if 1\n    p0 = t0 > 0.0 ? mix(p0t, p1t, t0) : p0;\n    p1 = t1 < 1.0 ? mix(p0t, p1t, t1) : p1;\n    #else\n    p0 = mix(p0t, p1t, t0);\n    p1 = mix(p0t, p1t, t1);\n    #endif\n    return true;\n}\n\n#else\n\n// https://gist.github.com/Larry57/a8a66824b4b299a26fbe64ef5de6f53e\nbool clip(float q, float p, inout float _t0, inout float _t1) {\n    if(abs(p) < 1e-6 && q < 0.0)\n        return false;\n\n    float r = q / p;\n\n    if(p < 0.0) {\n        if(r > _t1) return false;\n        if(r > _t0) _t0 = r;\n    }\n    else {\n        if(r < _t0) return false;\n        if(r < _t1) _t1 = r;\n    }\n\n    return true;\n}\n\n// https://gist.github.com/Larry57/a8a66824b4b299a26fbe64ef5de6f53e\n// but this is a good read: https://chaosinmotion.com/2016/05/22/3d-clipping-in-homogeneous-coordinates/comment-page-1/\n// interestingly, there is a comment from the gist author there. small world\nbool clipLineSegment(inout vec4 p0, inout vec4 p1)\n{\n    if(p0.w < 0.0 && p1.w < 0.0)\n        return false;\n\n    float _t0 = 0.0;\n    float _t1 = 1.0;\n\n    vec4 delta = p1 - p0;\n\n    if(!clip(p0.w - p0.x, -delta.w + delta.x, _t0, _t1)) return false;\n    if(!clip(p0.w + p0.x, -delta.w - delta.x, _t0, _t1)) return false;\n\n    if(!clip(p0.w - p0.y, -delta.w + delta.y, _t0, _t1)) return false;\n    if(!clip(p0.w + p0.y, -delta.w - delta.y, _t0, _t1)) return false;\n\n    if(!clip(p0.w - p0.z, -delta.w + delta.z, _t0, _t1)) return false;\n    if(!clip(p0.w + p0.z, -delta.w - delta.z, _t0, _t1)) return false;\n\n    if(_t1 < 1.0)\n        p1 = p0 + _t1 * delta;\n\n    if (_t0 > 0.0)\n        p0 = p0 + _t0 * delta;\n\n    return true;\n}\n\n#endif\n\n// https://www.shadertoy.com/view/ctKGzc\nfloat rayLineSegmentDistance(vec3 r0, vec3 rd, vec3 l0, vec3 l1)\n{\n    vec3 ld = l1 - l0;\n    vec3 od = l0 - r0;\n    float rr = dot(rd, rd);\n    float ll = dot(ld, ld);\n    float rl = dot(rd, ld);\n    float denom = rl * rl - rr * ll;\n    float ro = dot(rd, od);\n    float lo = dot(ld, od);\n    float t = -(rl * ro - lo * rr) / denom;\n    t = clamp(t, 0.0, 1.0);\n    vec3 lc = l0 + ld * t;\n    float s = dot(lc - r0, rd) / dot(rd, rd);\n    s = max(s, 0.0);\n    vec3 rc = r0 + rd * s;\n    t = dot(rc - l0, ld) / dot(ld, ld);\n    t = clamp(t, 0.0, 1.0);\n    lc = l0 + ld * t;\n    return length(rc - lc);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Projection\n    vec3 rayPosition = vec3(0.0);\n    vec2 center = fragCoord.xy - iResolution.xy * 0.5;\n    vec3 rayTarget = vec3((center / iResolution.y) * 1.0, 2.0f);\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // Camera\n    vec3 orbitPos = vec3(0.0, 0.0, 1.0);\n    mat3 camera = rotateY(iMouse.x * 0.01) * rotateX(iMouse.y * 0.01);\n    vec3 osDir = camera * rayDir;\n    vec3 osPos = -camera * orbitPos;\n    \n    // Frustum\n    mat4 projection = mat4(\n        1.18703675, 0, 0, 0,\n        0, -1.73205066, 0, 0,\n        0, 0, -1.4, -1,\n        0, 0, -0.1, 0);\n    \n    mat4 projectionInv = inverse(projection);\n    \n    // For drawing the frustum\n    vec4 lines[] = vec4[](\n        vec4(-1, -1, -1, 1), vec4(-1,  1, -1, 1),\n        vec4( 1,  1, -1, 1), vec4(-1,  1, -1, 1),\n        vec4( 1,  1, -1, 1), vec4( 1, -1, -1, 1),\n        vec4(-1, -1, -1, 1), vec4( 1, -1, -1, 1),\n        vec4(-1, -1,  1, 1), vec4(-1,  1,  1, 1),\n        vec4( 1,  1,  1, 1), vec4(-1,  1,  1, 1),\n        vec4( 1,  1,  1, 1), vec4( 1, -1,  1, 1),\n        vec4(-1, -1,  1, 1), vec4( 1, -1,  1, 1),\n        vec4(-1, -1, -1, 1), vec4(-1, -1,  1, 1),\n        vec4(-1,  1, -1, 1), vec4(-1,  1,  1, 1),\n        vec4( 1,  1, -1, 1), vec4( 1,  1,  1, 1),\n        vec4( 1, -1, -1, 1), vec4( 1, -1,  1, 1)\n    );\n    \n    // Frustum\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 12; ++i)\n    {\n        vec4 a = projectionInv * lines[i * 2 + 0];\n        vec4 b = projectionInv * lines[i * 2 + 1];\n        float d = rayLineSegmentDistance(osPos, osDir, a.xyz / a.w, b.xyz / b.w);\n        col += vec3(1.0) * clamp(1.0 - d * 500.0, 0.0, 1.0);\n    }\n    \n    // Clip random lines\n    for(float x = 1.0; x < 6.0; x += 1.0)\n    {\n        vec3 a = vec3(\n            sin(x * 13.0 + iTime * (x / 9.0)),\n            sin(x * 17.0 + iTime * (x / 8.0)),\n            sin(x * 7.0 + iTime * (x / 7.0)) - 1.0) * 0.2;\n        vec3 b = vec3(\n            sin(x * 23.0 + iTime * (x / 6.0)),\n            sin(x * 5.0 + iTime * (x / 5.0)),\n            sin(x * 31.0 + iTime * (x / 4.0)) - 1.0) * 0.2;\n        float d = rayLineSegmentDistance(osPos, osDir, a, b);\n        vec3 segCol = vec3(0.8, 0.3, 0.2) * 1.1;\n        vec3 clipCol = vec3(0.3, 0.8, 0.4);\n        col += segCol * clamp(1.0 - d * 500.0, 0.0, 1.0);\n        \n        // Bigger dot at the start of the line\n        col += segCol * clamp(1.0 - 200.0 * length(a - osPos - osDir * dot(a - osPos, osDir)), 0.0, 1.0);\n        \n        vec4 ca = projection * vec4(a, 1.0);\n        vec4 cb = projection * vec4(b, 1.0);\n        if(clipLineSegment(ca, cb))\n        {\n            ca = projectionInv * ca;\n            cb = projectionInv * cb;\n            d = rayLineSegmentDistance(osPos, osDir, ca.xyz / ca.w, cb.xyz / cb.w);\n            col += (clipCol /*- segCol*/) * clamp(1.0 - d * 500.0, 0.0, 1.0);\n        }\n    }\n    \n    // Output to screen\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}