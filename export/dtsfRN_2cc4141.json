{"ver":"0.1","info":{"id":"dtsfRN","date":"1692737259","viewed":195,"name":"Physics Girl St.","username":"nr4","description":"PC4k-Intro as released in the On Track PC4k intro compo at the Chaos Communication Camp.\nhttps://www.pouet.net/prod.php?which=94890","likes":8,"published":1,"flags":96,"usePreview":1,"tags":["intro","4k","demoscene","4kintro","team210","madtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsdGD4","filepath":"https://soundcloud.com/user-843867424/physics-girl-st?si=d789e7047e374141a53e0f5258b47a16&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/user-843867424/physics-girl-st?si=d789e7047e374141a53e0f5258b47a16&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ontrack-4k\n// Copyright (C) 2023  Alexander Kraus <nr4@z10.info>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ontrack-4k\n// Copyright (C) 2023  Alexander Kraus <nr4@z10.info>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nmat2 MM;\nconst vec3 c = vec3(1,0,-1);\nconst float pi = 3.14159;\nfloat tj,\n    dt,\n    bpm = 65.,\n    spb,\n    nbeats,\n    scale,\n    stepTime,\n    hardBeats,\n    expandRings,\n    sineExpandRings,\n    ringHeight,\n    colorEscalation,\n    glowEscalation,\n    colorCandyNess,\n    flashBackground,\n    e,\n    time;\nvec3 lpos1, \n    lpos2, \n    lpos3, \n    scatter;\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// float->float hash function\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// vec2->float hash function\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst mat3 Msrgb = mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041\n), M1 = mat3(\n    0.8189330101, 0.0329845436, 0.0482003018,\n    0.3618667424, 0.9293118715, 0.2643662691,\n    -0.1288597137, 0.0361456387, 0.6338517070\n), M2 = mat3(\n    0.2104542553, 1.9779984951, 0.0259040371,\n    0.7936177850, -2.4285922050, 0.7827717662,\n    -0.0040720468, 0.4505937099, -0.8086757660\n);\n\n// Convert rgb to xyz (sRGB) - compare http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\nvec3 rgb2xyz_srgb(vec3 rgb) {\n    return Msrgb * rgb;\n}\n\n// Convert xyz to rgb (sRGB) - compare http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\nvec3 xyz2rgb_srgb(vec3 xyz) {\n    return inverse(Msrgb) * xyz;\n}\n\n// Convert xyz to oklab - compare https://bottosson.github.io/posts/oklab/\nvec3 xyz2oklab(vec3 xyz) {\n    return M2 * pow(M1 * xyz, c.xxx/3.);\n}\n\n// Convert oklab to xyz - compare https://bottosson.github.io/posts/oklab/\nvec3 oklab2xyz(vec3 lab) {\n    return inverse(M1) * pow(inverse(M2) * lab, 3.*c.xxx);\n}\n\n// Convert oklab to oklch - compare https://bottosson.github.io/posts/oklab/\nvec3 oklab2oklch(vec3 lab) {\n    return vec3(lab.x, length(lab.yz), atan(lab.z, lab.y));\n}\n\n// Convert oklch to oklab - compare https://bottosson.github.io/posts/oklab/\nvec3 oklch2oklab(vec3 lch) {\n    return vec3(lch.x, lch.y * vec2(cos(lch.z), sin(lch.z)));\n}\n\nconst int COLOR_COUNT = 8;\nvec3 gradientColors[] = vec3[](\n        c.yyy,\n        vec3(0.02,0.16,0.24),\n        vec3(0.03,0.32,0.44),\n        vec3(0.47,0.68,0.73),\n        vec3(0.67,0.16,0.12),\n        vec3(0.96,0.52,0.00),\n        vec3(0.99,0.78,0.31),\n        vec3(1.00,0.92,0.80)\n);\n\nvec3 weightedOklabLinearGradientOklab(float amount) {\n    amount = fract(amount);\n    // First rescale amount to match the distance in the color space.\n    float colorspaceDistances[COLOR_COUNT],\n        steps[COLOR_COUNT];\n    float totalColorspaceDistance = 0.;\n    for(int i=0; i<COLOR_COUNT; ++i) {\n        vec3 c1 = (xyz2oklab(rgb2xyz_srgb(gradientColors[(i+1) % COLOR_COUNT]))),\n            c2 = (xyz2oklab(rgb2xyz_srgb(gradientColors[i])));\n        //colorspaceDistances[i] = abs(c1.x-c2.x) + length(c1.yz-c2.yz);\n        colorspaceDistances[i] = length(c1 - c2);\n        totalColorspaceDistance += colorspaceDistances[i];\n    }\n    \n    // Normalize weights\n    float currentStep = 0.;\n    for(int i=0; i<COLOR_COUNT; ++i) {\n        colorspaceDistances[i] /= totalColorspaceDistance;\n        steps[i] = currentStep;\n        currentStep += colorspaceDistances[i];\n    }\n    \n    // Determine color mixing\n    for(int i=0; i<COLOR_COUNT; ++i) {\n        if(amount < steps[(i + 1) % COLOR_COUNT]) {\n            return xyz2rgb_srgb(oklab2xyz((\n                mix(\n                    (xyz2oklab(rgb2xyz_srgb(gradientColors[i % COLOR_COUNT]))),\n                    (xyz2oklab(rgb2xyz_srgb(gradientColors[(i+1) % COLOR_COUNT]))),\n                    (amount-steps[i % COLOR_COUNT])/(steps[(i+1) % COLOR_COUNT] - steps[i % COLOR_COUNT])\n                )\n            )));\n        }\n    }\n    \n    return xyz2rgb_srgb(oklab2xyz((\n        mix(\n            (xyz2oklab(rgb2xyz_srgb(gradientColors[COLOR_COUNT - 1]))),\n            (xyz2oklab(rgb2xyz_srgb(gradientColors[0]))),\n            abs(amount-steps[COLOR_COUNT - 1])/abs(1.-steps[COLOR_COUNT - 1])\n        )\n    )));\n}\n\nvoid dmin(inout vec4 d, float x, float y, float z, float w)\n{\n\tif( x < d.x ) d = vec4(x, y, z, w);\n}\n\n// Method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n    float u = hash11( 78.233 + seed),\n        v = hash11( 10.873 + seed),\n        a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// From https://iquilezles.org/articles/distfunctions; written by iq.\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)), \n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nvec4 map(vec3 p,bool flag)\n{\n    p.xy *= MM;\n\n    vec4 d = vec4(1),\n        q;\n    \n    // point lights\n    float re = min(length(p-lpos1), length(p-lpos2)) - .003;\n    dmin(d, re, 1.,0.,.8);\n    if(flag) scatter += max(-(re-.7),0.) * .49 * weightedOklabLinearGradientOklab(.6);\n    \n    // Outer Silo\n    float pxs = 1.2;\n    float x = mod(p.x, pxs)-.5*pxs,\n        xj = p.x - x;\n    float db = sdTorus(vec3(p.y, x, p.z), vec2(6., .5*pxs));\n    dmin(d, db, 0., 0., 0.);\n    if(flag) scatter += max(-(db-1.1),0.) * .26 * flashBackground * .5 * c.xxx * step(.5, hash12(vec2(xj, tj) + .5));\n\n    p.y += (.4 + .4 * step(29., time) * step(time, 59.) ) * time;\n        \n    // Silo\n    float ps = (.1 + .9 * ringHeight) * (.05 + .95 * hash11(tj + .1));\n    float y = mod(p.y, ps)-.5*ps,\n        yj = p.y - y+13.3;\n        \n    float da = sdTorus(vec3(p.x, y, p.z), vec2(1. + expandRings * hash12(vec2(yj, tj) + .2) + 2. * sineExpandRings * lfnoise(vec2(yj, tj) + .2), .5*ps));\n    da = min(da, sdTorus(vec3(p.x, y-ps, p.z), vec2(1. + expandRings * hash12(vec2(yj + ps, tj) + .2)  + 2. * sineExpandRings * lfnoise(vec2(yj + ps, tj) + .2), .5*ps)));\n    da = min(da, sdTorus(vec3(p.x, y+ps, p.z), vec2(1. + expandRings * hash12(vec2(yj - ps, tj) + .2)  + 2. * sineExpandRings * lfnoise(vec2(yj - ps, tj) + .2), .5*ps)));\n    float c1 = colorEscalation * step(hash12(vec2(yj, tj) + .1),.2 + .8 * colorCandyNess) * hash12(vec2(yj, tj) + .4);\n    dmin(d, da, 0., 0., c1);\n    if(flag) scatter += max(-(da-1.1),0.) * .26 * glowEscalation * .5 * mix(weightedOklabLinearGradientOklab(c1), c.yyy, 1.-scale) * scale;\n    \n    // Center of silo\n    float dc = length(p.xz) - .03;\n    dmin(d, dc, 1., 0., .8);\n    if(flag) scatter += max(-(dc-.7),0.) * .49 * weightedOklabLinearGradientOklab(.6);\n    \n\treturn d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(0, .001);\n\treturn normalize(map(p,false).x-vec3(map(p - e.yxx,false).x, map(p - e.xyx,false).x, map(p - e.xxy,false).x));\n}\n\n// From gltracy https://www.shadertoy.com/view/lsXSz7\nvec3 radiance(\n    vec3 n,\t\t// macro surface normal\n    vec3 l,\t\t// direction from vertex to light\n    vec3 v,\t\t// direction from vertex to view\n    // matt\n    float m\t// roughness\n) {\n    vec3 cdiff = vec3(.8);\n    vec3 cspec = vec3(.7);\n    vec3 clight = vec3(.7, .65, .8);\n\n    // half vector\n    vec3 h = normalize( l + v );\n\n    // dot\n    float dot_n_h = max( dot( n, h ), .01 );\n    float dot_n_v = max( dot( n, v ), .01 );\n    float dot_n_l = max( dot( n, l ), .1 );\n    float dot_h_v = max( dot( h, v ), .01 ); // dot_h_v == dot_h_l\n\n    // Geometric Term\n    // Cook-Torrance\n    //          2 * ( N dot H )( N dot L )    2 * ( N dot H )( N dot V )\n    // min( 1, ----------------------------, ---------------------------- )\n    //                 ( H dot V )                   ( H dot V )\n    float g = 2. * dot_n_h / dot_h_v;\n    float G = min( min( dot_n_v, dot_n_l ) * g, 1. );\n\n    // Normal Distribution Function ( cancel 1 / pi )\n     // Beckmann distribution\n    //         ( N dot H )^2 - 1\n    //  exp( ----------------------- )\n    //         ( N dot H )^2 * m^2\n    // --------------------------------\n    //         ( N dot H )^4 * m^2\n    float sq_nh   = dot_n_h * dot_n_h;\n    float sq_nh_m = sq_nh * ( m * m );\n    float D = exp( ( sq_nh - 1. ) / sq_nh_m ) / ( sq_nh * sq_nh_m );\n\n    // Specular Fresnel Term : Schlick approximation\n    // F0 + ( 1 - F0 ) * ( 1 - ( H dot V ) )^5\n    vec3 Fspec = cspec + ( 1.  - cspec ) * pow( 1. - dot_h_v, 5. );\n\n    // Diffuse Fresnel Term : violates reciprocity...\n    // F0 + ( 1 - F0 ) * ( 1 - ( N dot L ) )^5\n    vec3 Fdiff = cspec + ( 1.  - cspec ) * pow( 1. - dot_n_l, 5. );\n\n    // Cook-Torrance BRDF\n    //          D * F * G\n    // ---------------------------\n    //  4 * ( N dot V )( N dot L )\n    vec3 brdf_spec = Fspec * D * G / ( dot_n_v * dot_n_l * 4. );\n\n    // Lambertian BRDF ( cancel 1 / pi )\n    vec3 brdf_diff = cdiff * ( 1. - Fdiff );\n\n    // Punctual Light Source ( cancel pi )\n    return ( brdf_spec + brdf_diff ) * clight * dot_n_l;\n}\n\n// The MADtracer, originally written by Virgill/Alcatraz.\n// https://www.shadertoy.com/view/ttlXRf\n// I made some modifications to include cook-torrance illumination. \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = iTime;\n    e = .05 * time;\n    MM = mat2(cos(e), -sin(e), sin(e), cos(e));\n    \n    lpos1 = vec3(0); \n    lpos2=vec3(0); \n    lpos3=vec3(0,1,0); \n    scatter =vec3(0);\n\n    spb = 60. / bpm;\n    dt = mod(time, spb);\n    tj = time - dt;\n    bool a = int(round(tj/spb)) % 4 == 3;\n    \n    if(a) {\n        time -= .375 * spb;\n        dt = mod(time, spb);\n        tj = time - dt;\n    }\n\n    stepTime = mod(time+.5*spb, spb)-.5*spb;\n    nbeats = tj / spb;\n    scale = smoothstep(0., .05 * spb, stepTime)*smoothstep(.7*spb, 0., stepTime);\n    hardBeats = round((time-mod(time, spb))/spb);\n\n    if(time > 73.) {\n        tj = mod(73., spb);\n        scale = 0.;\n        nbeats = tj / spb;\n    }\n\n    if(a) time += .375 * spb;\n\n    float sa = 6.;\n    colorEscalation = smoothstep(sa, 1.5*sa, nbeats) * (1. - smoothstep(12. *sa, 12.5*sa, nbeats));\n    glowEscalation = smoothstep(2.*sa, 2.5*sa, nbeats);\n    colorCandyNess = smoothstep(3.*sa, 3.5*sa, nbeats);\n    ringHeight = smoothstep(4.*sa, 4.5*sa, nbeats) * (1. - smoothstep(10.*sa, 10.5*sa, nbeats));\n    sineExpandRings = smoothstep(5.*sa, 5.5*sa, nbeats) * (1. - smoothstep(9.*sa, 9.5*sa, nbeats));\n    expandRings = smoothstep(6.*sa, 6.5*sa, nbeats) * (1. - smoothstep(8.*sa, 8.5*sa, nbeats));\n    flashBackground = smoothstep(7.*sa, 7.5*sa, nbeats);\n    \n    fragColor = c.yyyx;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// borders :(\n\tif(uv.y>.11 && uv.y<.89)\n\t{\n        // camera\n\t\tvec3 ro1 = vec3(0, 0, -5.), rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\n\t\tfloat t1 = 0., t2 = 0.,t3=0., seed = 0.;\n\n//***************************************************************************************************\n// Cast ray\n//***************************************************************************************************     \n  \n        lpos1 = - 4.*c.yyx+.3*vec3(1.*cos(time), .3*sin(time), .5+sin(.5*time));\t\t\t\t// position point light 1 \n        lpos2 = - 4.*c.yyx+.3*vec3(1.2*cos(.3*time), .4*sin(.4*time), .5+sin(.2*time));   \t// position point light 2\n       \n        seed=hash12(uv + 13.)+fract(float(iFrame)*1.e-3) + 137.;\n\n\t\tvec3 scol=vec3(0);\n        vec4 m1, m2, m3;\n        vec3 ro2,rd2,nor1, nor2,pos1,pos2,pos3;\n        \n        float roughness = .2;\n\t    \n\t\tfor( int i = 0; i < 250; i++ )\n\t\t{\n            // every iteration a new seed\n            seed=32.+seed*fract(seed);\n           \t\n            // raymarch 1st pass\n           \tpos1 = ro1+rd1*t1;\t\t\n        \tm1 = map(pos1,true);\n\t\t\tt1+=0.2*(m1.x); \t// the smaller the factor, the thicker the media\n\t\t\t\n            if (m1.x<.001)\t\t// hit\n              \tbreak;\n          \n\t\t\t// Raymarch direct light \n            lpos3 = vec3(0.,1.,0.);\n            lpos3 = mix(lpos3,hashHs(lpos3,seed),.15); \t// add randomness\n        \tpos2=pos1+lpos3*t2;\t\t\t\t\t\t\t// calculate ray direction\n            m2 = map(pos2,false);\n            t2+=m2.x;\n        }\n        \n        if(m1.x < .001) {\n            nor1 = normal(pos1); \n        \n            // cook torrance\n            scol += 5.e1 * weightedOklabLinearGradientOklab(m1.w) * (.3 + .1 * radiance(nor1, normalize(lpos1-pos1), normalize(ro1-pos1), roughness));\n            scol += 5.e1 * weightedOklabLinearGradientOklab(m1.w) * (.3 + .1 * radiance(nor1, normalize(lpos2-pos1), normalize(ro1-pos1), roughness));\n        }\n\n\t  \tnor1 = normal(pos1);\n\n        // bounce        \n        m1.y=clamp(m1.y,0.,1.);\n\t\tt2=0.;\n       \tfor( int i = 1; i < 100 ; i++ )\n      \t{\n            // every iteration a new seed\n            seed=32.+seed*fract(seed);            \n\t\t\trd2 = mix(reflect(rd1,nor1),hashHs(nor1,seed),m1.y);\t// reflect depending on material\t\n            pos2 = pos1+ rd2*t2;\n\t\t\tm2 = map(pos2,false); \n            t2+=.2*m2.x;\n            scol += .4 * c.xxx*step(1., m2.y);\n        }\n        \n        if (m2.x<.001) {\n            nor2 = normal(pos2);\n            \n            scol += 5.e1 * weightedOklabLinearGradientOklab(m2.w) * (.3 + .1* radiance(nor2, normalize(lpos1-pos2), normalize(ro1-pos2), .5* roughness));\n            scol += 5.e1 * weightedOklabLinearGradientOklab(m2.w) * (.3 + .1* radiance(nor2, normalize(lpos2-pos2), normalize(ro1-pos2), .5* roughness));\n        }\n\n\t\tfragColor = vec4((.003*scol+0.02*scatter+1.*texture(iChannel0, uv).xyz), 0.)*.8; // with blur\n        fragColor = clamp(fragColor,0.,1.);\n        fragColor.rgb *= smoothstep(0., 2., time) * smoothstep(76., 74., time);\n\t}\n}\n","name":"Buffer A","description":"","type":"buffer"}]}