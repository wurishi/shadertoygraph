{"ver":"0.1","info":{"id":"slXSW2","date":"1626537281","viewed":98,"name":"Function graph renderer","username":"HalbFettKaese","description":"renders the graph of an arbitrary function","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["graph","function"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 zoomCenter = vec2(0, 0);\n\nfloat plottedFunction(float x) {\n    return cos(x) * x;\n}\n\n\nvec4 getData(int id) {\n    vec2 p = vec2(\n    mod(float(id), iResolution.x),\n    id/int(iResolution.x)\n    );\n    p += 0.5;\n    p /= iResolution.xy;\n    return texture(iChannel0, p);\n}\n\nfloat zoom() {\n    return exp((getData(0).r - 0.3) * 20. );\n}\n\nfloat drawFunction(vec2 uv) {\n    float pixelSize = zoom()/iResolution.x;\n    float x_0 = uv.x - pixelSize;\n    float y_0 = plottedFunction(x_0);\n    float x_1 = uv.x;\n    float y_1 = plottedFunction(x_1);\n    float x_2 = uv.x + pixelSize;\n    float y_2 = plottedFunction(x_2);\n    return max(\n        lineSegment(uv, vec2(x_0, y_0), vec2(x_1, y_1), pixelSize),\n        lineSegment(uv, vec2(x_1, y_1), vec2(x_2, y_2), pixelSize)\n    );\n}\n\nfloat drawGrid(vec2 uv) {\n    float zoom = zoom();\n    float pixelSize = zoom/iResolution.x;\n    float a = log(zoom * .8)/log(10.);\n    float gridSize1 = pow(10., floor(a));\n    float gridSize2 = gridSize1/10.;\n    vec2 moduv1 = mod(uv + gridSize1 * 0.5, gridSize1) - gridSize1 * 0.5;\n    vec2 moduv2 = mod(uv + gridSize2 * 0.5, gridSize2) - gridSize2 * 0.5;\n    float b = 1.;\n    float dark = 0.5;\n    float light = dark * smoothstep(1., 0., pow(fract(a),.8));\n    // Main axes (black)\n    b = min(b, 1. - smoothstep(pixelSize, 0., abs(uv.x)));\n    b = min(b, 1. - smoothstep(pixelSize, 0., abs(uv.y)));\n    // Large grid (dark gray)\n    b = min(b, 1. - dark * smoothstep(pixelSize, 0., abs(moduv1.x)));\n    b = min(b, 1. - dark * smoothstep(pixelSize, 0., abs(moduv1.y)));\n    // Small grid (light gray)\n    b = min(b, 1. - light * smoothstep(pixelSize, 0., abs(moduv2.x)));\n    b = min(b, 1. - light * smoothstep(pixelSize, 0., abs(moduv2.y)));\n    return b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * (1. - 0.5))/iResolution.xx;\n    uv *= zoom();\n    uv += zoomCenter;\n    // Draw grid/axes\n    vec3 col = vec3(drawGrid(uv));\n    // Draw function\n    col = mix(col, vec3(1, 0, 0), drawFunction(uv));\n    // Draw size buttons\n    vec2 m = vec2(0);\n    if (iMouse.z > 0.)\n        m = iMouse.xy/iResolution.xx;\n    vec4 drawnSizeBox = drawSizeBox(fragCoord/iResolution.xx, m, 1./iResolution.x);\n    col = mix(col, drawnSizeBox.rgb, drawnSizeBox.a);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define infty 80.\n\nconst vec2 smallSizeStart = vec2(0, 0);\nconst vec2 smallSizeEnd = vec2(0.1, 0.1);\nconst vec2 largeSizeStart = vec2(0, 0.1);\nconst vec2 largeSizeEnd = vec2(0.1, 0.2);\n\nfloat dLine(vec2 p, vec2 ab) {\n    float len = length(ab);\n    ab /= len;\n    vec2 projectedPoint = ab * clamp(dot(p, ab), 0., len);\n    return distance(\n                        projectedPoint, \n                        p\n                    );\n}\n\n\nfloat lineSegment(vec2 uv, vec2 startPos, vec2 endPos, float thickness) {\n    uv -= startPos;\n    endPos -= startPos;\n    \n    return smoothstep(thickness, 0., abs(dLine(uv, endPos))\n                );\n}\n\nfloat rect(vec2 p, vec2 start, vec2 end, float blur) {\n    return smoothstep(0., blur, p.x - start.x)\n    * smoothstep(-blur/2., blur/2., p.y - start.y)\n    * smoothstep(-blur/2., blur/2., end.x - p.x)\n    * smoothstep(-blur/2., blur/2., end.y - p.y);\n}\n\nfloat roundedRect(vec2 p, vec2 start, vec2 end, float r, float blur) {\n    vec2 p2 = clamp(p, start + r, end - r);\n    \n    return smoothstep(blur/2., -blur/2., distance(p, p2) - r);\n}\n\nfloat sizeBox(vec2 p, out bool success, float blur) {\n    success = false;\n    if (rect(p, smallSizeStart, smallSizeEnd, blur) > 0.5) {\n        success = true;\n        return -1.;\n    }\n    if (rect(p, largeSizeStart, largeSizeEnd, blur) > 0.5) {\n        success = true;\n        return 1.;\n    }\n    \n    return 0.;\n}\n\nvec4 drawSizeBox(vec2 uv, vec2 m, float blur) {\n    bool success;\n    float drawn = sizeBox(uv, success, blur);\n    float selected = sizeBox(m, success, blur);\n    vec4 col = vec4(0);\n    // smaller size button background\n    float rect1 = roundedRect(uv, smallSizeStart, smallSizeEnd, 0.01, blur);\n    col.a = rect1;\n    col.rgb = mix(col.rgb, vec3(0.5), \n        rect1\n    );\n    // smaller size button foreground\n    col.rgb = mix(col.rgb, vec3(0.95), \n        roundedRect(uv, smallSizeStart + 0.005, smallSizeEnd - 0.005, 0.01, blur)\n    );\n    // larger size button background\n    rect1 = roundedRect(uv, largeSizeStart, largeSizeEnd, 0.01, blur);\n    col.a += rect1;\n    col.rgb = mix(col.rgb, vec3(0.5), \n        rect1\n    );\n    // larger size button foreground\n    col.rgb = mix(col.rgb, vec3(0.95), \n        roundedRect(uv, largeSizeStart + 0.005, largeSizeEnd - 0.005, 0.01, blur)\n    );\n    // draw -\n    col.rgb *= mix(1., 0.3, rect(uv - smallSizeStart, vec2(0.02, 0.04), vec2(0.08, 0.06), blur));\n    // draw +\n    col.rgb *= min(\n        mix(1., 0.3, rect(uv- largeSizeStart, vec2(0.02, 0.04), vec2(0.08, 0.06), blur)),\n        mix(1., 0.3, rect(uv- largeSizeStart, vec2(0.04, 0.02), vec2(0.06, 0.08), blur))\n    );\n    // Make darker when clicked\n    if (success && drawn == selected)\n        col.rgb *= 0.8;\n    return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n* Reads the pixel with the given id\n*/\nvec4 getData(int id) {\n    vec2 p = vec2(\n    mod(float(id), iResolution.x),\n    id/int(iResolution.x)\n    );\n    p += 0.5;\n    p /= iResolution.xy;\n    return texture(iChannel0, p);\n}\n\n/*\n* Returns whether the pixel at a given coordinate corresponds to the matching id\n*/\nbool isPixel(vec2 fragCoord, int id) {\n    vec2 p = vec2(\n    mod(float(id), iResolution.x),\n    float(id/int(iResolution.x))\n    );\n    return fragCoord == p + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xx;\n    \n    \n    \n    bool success;\n    float sizeDiff = sizeBox(m, success, 1./iResolution.x);\n    fragColor = texture(iChannel0, uv);\n    fragColor.a = 1.;\n    if (isPixel(fragCoord, 0)) {\n        // Set starting zoom\n        if (getData(0).r < 1./255.) {\n            fragColor.r = 120./255.;\n        } else \n        // change zoom according to buttons\n        if (success && iMouse.z > 0.) {\n            fragColor.r -= sizeDiff*1./255.;\n            fragColor.r = max(fragColor.r, 1./255.);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}