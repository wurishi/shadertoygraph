{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Visualization of osculating circle based on eiffie's 36-step solution:\n// https://www.shadertoy.com/view/MlXGRl\n\nvec2 map(float t){\n    if (mod(iTime, 30.0) < 15.0) \n        //from iq's shader https://www.shadertoy.com/view/Xlf3zl\n        return 0.85*cos( t + vec2(0.0,1.0) )*(0.6+0.4*cos(t*7.0+vec2(0.0,1.0)));\n    else\n        // some Lissajous curve - note eieffie's thing still works good.\n        return 0.7*vec2(cos(3.*t), sin(2.*t));\n}\n\n// compute the osculating circle of a parametric curve with a 3-tap central\n// difference method.\n//\n// http://en.wikipedia.org/wiki/Osculating_circle\nvec3 ocircle(float t) {\n    \n    // h is a small step size\n    const float h = 1e-1;\n    \n    // circle is centered at intersection of perpendicular bisectors of segments ab, bc\n    vec2 a = map(t-h);\n    vec2 b = map(t);\n    vec2 c = map(t+h);  \n    \n\n    // normals of perpendicular bisector of segment ab, bc\n\tvec2 nab = b-a;\n\tvec2 nbc = c-b;\n\t\n    // homogeneous line equations of of perpendicular bisectors\n\tvec3 l1 = vec3(nab, -dot(nab, 0.5*(a+b)));\n\tvec3 l2 = vec3(nbc, -dot(nbc, 0.5*(b+c)));\n\t\n    // cross product of homogeneous lines gives point of intersection\n\tvec3 p = cross(l1, l2);\n    \n    // project to cartesian coords by perspective division\n\tvec2 ctr = p.xy/p.z;\n\t\t\n\treturn vec3(ctr, length(a-ctr));\n\n}\n\nfloat circle(vec2 p, vec3 c) {\n    float d = abs(length(p-c.xy)-c.z);\n    return smoothstep(0.0,0.01,d);\n}\n\nfloat Tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    vec2 p1=map(0.0),p2;\n\tfloat t=0.0,d=length(p-p1),d1=d;\n\tfor(int i=0;i<35;i++){\n\t\tt+=max(0.41*d1,0.03);\n\t\tp2=map(t);\n\t\td1=length(p-p2);\n\t\td=min(d,Tube(p-p1,p2-p1));\n\t\tp1=p2;\n\t}\n    \n    float eiffie_d = d;\n\n    // draw osculating circle in red\n    t = 0.1*iTime;\n\n    d = circle(p, ocircle(t));\n    vec3 col = vec3(1.,d,d);\n\n    \n    // draw curve in blue\n\td=smoothstep(0.0,0.01,eiffie_d);\n    col = mix(vec3(d,d,1), col, d);\n        \n    // draw current position in purple\n    d = smoothstep(0.0,0.01,length(p-map(t))-.01);\n    col = mix(vec3(1,d,1),col,d);\n    \n    \n\tfragColor = vec4(col,1.0);\n    \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llX3Rs","date":"1424283273","viewed":405,"name":"Parametric - osculating circle","username":"mattz","description":"When I think of curvature, I think of osculating circles. Not sure if it would be useful for the challenge at hand (since it requires 3 taps) but it is pretty to visualize. See http://en.wikipedia.org/wiki/Osculating_circle","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["playing","parametric"],"hasliked":0,"parentid":"","parentname":""}}