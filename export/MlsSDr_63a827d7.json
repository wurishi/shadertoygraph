{"ver":"0.1","info":{"id":"MlsSDr","date":"1436047334","viewed":176,"name":"mls","username":"vydd","description":"Click and drag to apply the transformation manually.\n\nMoving least squares: http://faculty.cs.tamu.edu/schaefer/research/mls.pdf\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define POINTS 9\n\nmat2 A[POINTS];\nvec2 p[POINTS];\nvec2 q[POINTS];\nvec2 pcaret[POINTS];\nvec2 qcaret[POINTS];\nfloat w[POINTS];\nfloat wsum;\n\nvec2 v;\nvec2 pstar;\nvec2 qstar;\n\nvec2 f;\n\nvoid initPoints() {\n  p[0] = vec2(0.3, 0.3);\n  p[1] = vec2(0.7, 0.3);\n  p[2] = vec2(0.3, 0.7);\n  p[3] = vec2(0.7, 0.7);\n\n  q[0] = vec2(0.3, 0.3);\n  q[1] = vec2(0.7, 0.3);\n  q[2] = vec2(0.3, 0.7);\n  q[3] = vec2(0.7, 0.7);\n\n  p[5] = vec2(0.3, 0.3);\n  p[6] = vec2(0.7, 0.3);\n  p[7] = vec2(0.3, 0.7);\n  p[8] = vec2(0.7, 0.7);\n\n  q[5] = vec2(0.3, 0.3);\n  q[6] = vec2(0.7, 0.3);\n  q[7] = vec2(0.3, 0.7);\n  q[8] = vec2(0.7, 0.7);\n\n  p[4] = vec2(0.5, 0.5);\n  if (iMouse.z <= 0.0) {\n  \tq[4] = vec2(0.5 - cos(iTime)/2.0, 0.5 - sin(iTime)/2.0);\n                \n  } else {\n  \tq[4] = vec2(1.0 - iMouse.x / iResolution.x, 1.0 - iMouse.y / iResolution.y);\n  }\n\n}\n\nvec2 ortho(vec2 v) {\n  return vec2(-v.y, v.x);\n}\n\nvoid calcWeights() {\n  wsum = 0.0;\n  for (int i = 0; i < POINTS; i++) {\n    w[i] = 1.0 / pow(distance(p[i], v), 2.0);\n    wsum += w[i];\n  }\n}\n\nvoid calcPStar() {\n  pstar = vec2(0.0, 0.0);\n  for (int i = 0; i < POINTS; i++) {\n    pstar += w[i] * p[i];\n  }\n  pstar /= wsum;\n}\n\nvoid calcQStar() {\n  qstar = vec2(0.0, 0.0);\n  for (int i = 0; i < POINTS; i++) {\n    qstar += w[i] * q[i];\n  }\n  qstar /= wsum;\n}\n\nvoid calcPCaret() {\n  for (int i = 0; i < POINTS; i++) {\n    pcaret[i] = p[i] - pstar;\n  }\n}\n\nvoid calcQCaret() {\n  for (int i = 0; i < POINTS; i++) {\n    qcaret[i] = q[i] - qstar;\n  }\n}\n\nvoid calcA() {\n  for (int i = 0; i < POINTS; i++) {\n    mat2 leftM = mat2(pcaret[i], vec2(pcaret[i].y, -pcaret[i].x));\n    mat2 rightM = mat2(v - pstar, -ortho(v-pstar));\n\n    A[i] = leftM * rightM * w[i];\n  }\n}\n\nvoid calcF() {\n  f = vec2(0.0, 0.0);\n  for (int i = 0; i < POINTS; i++) {\n    f += qcaret[i] * A[i];\n  }\n  f = distance(v, pstar) * normalize(f) + qstar;\n}\n\nvoid shade() {\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tv = fragCoord.xy / iResolution.xy;\n\tinitPoints();\n  \tcalcWeights();\n \tcalcPStar();\n \tcalcQStar();\n  \tcalcPCaret();\n  \tcalcQCaret();\n  \tcalcA();\n  \tcalcF();\n\n  \tvec4 col = texture(iChannel0, f);\n  \tfragColor = col;\n}","name":"","description":"","type":"image"}]}