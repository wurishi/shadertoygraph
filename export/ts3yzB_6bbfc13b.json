{"ver":"0.1","info":{"id":"ts3yzB","date":"1601152945","viewed":253,"name":"Roundabout symmetry","username":"sylvain69780","description":"opRepRoundabout and opRepRoundaboutWithID domain repetition functions ","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["function","rotation","symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Roundabout symetry\n    ------------------\n    \n    This is a naive naming for the well known Polar domain repetition operator.\n    \n    Later I found many variations of the same function, IQ's one is very neat.\n    \n    Related references\n    \n    Distance functions - IQ\n    https://iquilezles.org/articles/distfunctions\n    \n    Live Coding \"Sphere Gears\" - Part 1 - IQ\n    https://youtu.be/sl9x19EnKng?t=1745\n    \n    HG SDF in WebGL - Mercury library ported on Shadertoy - tomkh\n    https://shadertoy.com/view/Xs3GRB\n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n    https://www.youtube.com/watch?v=2dzJZx0yngg    \n    \n    Rotational symmetry - IQ\n    https://www.shadertoy.com/view/XtSczV\n\n*/\n\n\n#define PI 3.14159265\n#define TAU 6.283185\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define iFont iChannel3\n\n// https://www.shadertoy.com/view/WssSRf\n\n// Get coordinates of a character 'ord' in the font texture\nfloat Character(vec2 uv, int ord)\n{\n    vec2 cc = trunc(vec2(ord % 16, 15 - ord / 16))/16.\n        + fract(uv) / 16.;\n    \n    return texture(iFont, cc).x;\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// This is Mercury function\n// Mercury's hg_sdf library.\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n// This is an owned function , this one returns also an id\n\nvec4 opRepRoundaboutWithID(vec3 p,float radius,float sectors) {\n    float angle = TAU/sectors;\n    // When there is an even number of sectors\n    float at=atan(p.z,p.x); \n    // there is a split of the sector at the opposite side because of the atan function\n    if ( mod(sectors,2.) == 0. && at < -PI+angle*.5) at = at+TAU; // manage atan discontinuity split \n    float sector = round((at)/angle); // thanks to IQ video https://youtu.be/sl9x19EnKng?t=1745\n    p.xz *= Rot(-angle*sector);\n    p.x -= radius;\n    if ( sector < 0.0 ) sector+=sectors;\n    return vec4(p,sector);\n}\n\n// simple function if you have all objets identical (no need to manage an ID)\nvec3 opRepRoundabout(vec3 p,float radius,float sectors) {\n    float angle = TAU/sectors;\n    float sector = round(atan(p.z,p.x)/angle); // thanks to IQ video https://youtu.be/sl9x19EnKng?t=1745\n    p.xz *= Rot(-angle*sector);\n    p.x -= radius;\n    return p;\n}\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\nvec4 sdRepBox(vec3 p) {\n    float clones = 1.+9.*2.*abs(fract(.025*iTime)-.5);\n    float clones2 = floor(clones);\n    clones2 += smoothstep(.45,.55,fract(clones));\n    vec4 r=opRepRoundaboutWithID(p,1.5,clones2);\n    vec3 q=r.xyz;\n    // texture coordinates\n    vec2 uv= q.zy;\n    if ( q.x < 0.0 ) uv.x=-uv.x;\n    float id=r.w;\n    return vec4(sdBox(q, vec3(.2)),id,uv);\n}\n\nvec4 GetDistAndMat(vec3 p) {\n    vec4 model = sdRepBox(p);\n    return model;\n}\n\nfloat GetDist(vec3 p) {\n        \n    vec4 model = GetDistAndMat(p);\n    return model.x;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, inout vec3 gc) {\n\tfloat dO=0.;\n    \n    vec4 dS;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDistAndMat(p);\n        // Ripped from Shaw\n        float at = .05 / (1. + dS.x * dS.x * 12.);\n        vec3 gcc = vec3(1., .5, 0.);\n        float gid=fract(10.0+dS.y/3.0)*3.1;\n        if ( gid >= 2.0 ) {\n            gcc = vec3(1., .1, 0.);\n        } else if ( gid >= 1.0 ) {\n            gcc = vec3(.1, 1.0, 0.);\n        } else if ( gid >= 0.0 ) {\n            gcc = vec3(.0, 0.0, 1.);\n        }\n        gc += gcc * at;       \n        dO += dS.x;\n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n        \n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14);\n    ro.xz *= Rot(-m.x*6.2831+iTime*.5);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 gc=vec3(0);\n    float d = RayMarch(ro, rd, gc);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        // get UV for texture\n        vec4 cube = GetDistAndMat(p);\n        if ( abs(cube.z) < .19 && abs(cube.w) < .19 ) col+=Character(cube.zw*2.5+.5,48+int(cube.y));\n    \tcol += dif*.2;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    col += gc;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}