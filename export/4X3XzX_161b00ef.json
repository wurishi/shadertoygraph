{"ver":"0.1","info":{"id":"4X3XzX","date":"1729470416","viewed":68,"name":"particle clustering single pass","username":"capslpop","description":"tying to do single pass simulation. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["cluster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getMin(vec2 pos, Cell c)\n{\n    float a = 99.0;\n    if (c.p0.mass >= 1u)\n    {\n        a = distance(c.p0.pos, pos);\n    }\n\n    float b = 99.0;\n    if (c.p1.mass >= 1u)\n    {\n        b = distance(c.p1.pos, pos);\n    }    \n    \n    float d = 99.0;\n    if (c.p2.mass >= 1u)\n    {\n        d = distance(c.p2.pos, pos);\n    }\n    \n    float e = 99.0;\n    if (c.p3.mass >= 1u)\n    {\n        e = distance(c.p3.pos, pos);\n    }\n    \n    float minDist = min(a, min(b, min(d, e)));\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord / resScale;    \n    \n    float minDist = 999.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 pos_ = floor(pos) + vec2(i, j);\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), pos_);\n        \n        float m = getMin(pos, c_);\n        if (m < minDist)\n        {\n            minDist = m;\n        }\n    }\n    \n    fragColor = vec4(0.6 - minDist) * vec4(0.427,0.471,0.792,0.0) * 10.0 * (1.0 / unpackCell(texelFetch(iChannel0, ivec2(fragCoord / resScale), 0), fragCoord).mass);\n    /*\n    if (unpackCell(texelFetch(iChannel0, ivec2(fragCoord / resScale), 0), fragCoord).mass > 4.0)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n    } else\n    {\n        fragColor = vec4(unpackCell(texelFetch(iChannel0, ivec2(fragCoord / resScale), 0), fragCoord).mass) / 4.0;\n    }\n    */\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float G(vec2 d) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(d), 0.0);\n    vec2 k = min(max(0.75 - d*d, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nfloat L(vec2 d)\n{\n    return max(0.393 - length(d)*0.25, 0.0);\n}\n\nvec4 textureFetchBilinear(sampler2D tex, vec2 texCoords, int lod) {\n    // Get the texture size at the given LOD\n    ivec2 texSize = textureSize(tex, lod);\n\n    // Convert normalized texture coordinates to texel coordinates\n    vec2 texelPos = texCoords * vec2(texSize);\n\n    // Get the four surrounding texels\n    ivec2 texelCoords00 = ivec2(floor(texelPos));\n    ivec2 texelCoords10 = texelCoords00 + ivec2(1, 0);\n    ivec2 texelCoords01 = texelCoords00 + ivec2(0, 1);\n    ivec2 texelCoords11 = texelCoords00 + ivec2(1, 1);\n\n    // Fetch the texels\n    vec4 texel00 = texelFetch(tex, texelCoords00, lod);\n    vec4 texel10 = texelFetch(tex, texelCoords10, lod);\n    vec4 texel01 = texelFetch(tex, texelCoords01, lod);\n    vec4 texel11 = texelFetch(tex, texelCoords11, lod);\n\n    // Calculate the interpolation factors\n    vec2 frac = texelPos - vec2(texelCoords00);\n\n    // Perform bilinear interpolation\n    vec4 mixX0 = mix(texel00, texel10, frac.x);\n    vec4 mixX1 = mix(texel01, texel11, frac.x);\n    vec4 mixY = mix(mixX0, mixX1, frac.y);\n\n    return mixY;\n}\n\nvoid G2P2G(Particle p, inout Cell c, vec2 pos)\n{\n    // if there is no mass no need to compute particle\n    if (p.mass == 0u)\n        return;\n\n    // G2P\n    float density = 0.0; //texture(iChannel0, p.pos/iResolution.xy).w;\n    vec2 vel = vec2(0.0); // Initialize velocity\n    mat2x2 C = mat2x2(0.0); // Initialize deformation gradient\n    \n    // Iterate over surrounding grid nodes\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 pos_ = floor(p.pos) + vec2(i, j);\n\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), vec2(pos_));\n        \n        vec2 dpos = (p.pos - 0.5) - pos_;\n        float weight = G(dpos);\n        \n        vel += weight * c_.vel;\n        C += outerProduct(weight * c_.vel, -dpos);\n        density += weight * c_.mass;\n    }\n\n    //float try = packSnorm32x4(vec4(vel, 0.0, 0.0));\n    //\n    //vel = unpackSnorm32x4(try).xy;\n    //\n    //\n    //\n    //float info = packUnorm32x4(vec4(density / 4.0));\n    //\n    //density = unpackUnorm32x4(info).x * 4.0;\n    \n    p.pos += dt * vel;\n    \n    // P2G    \n    float pressure = 1.0 * (density - 1.0);\n    \n    mat2 stress = mat2(-pressure);\n    \n    mat2 affine = stress + density * C * 1.0; // + float(p.mass) * C * 1.0;\n    \n    // Only update the current cell\n    \n    vec2 dpos = vec2((p.pos - 0.5) - pos);\n    float weight = G(dpos);\n    \n    c.mass += weight * float(p.mass);\n    c.vel += weight * (affine * dpos + float(p.mass) * vel);\n    \n    Clusterize(c, p, pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos)\n{\n    pos = floor(pos);\n    \n    Cell c = Cell(Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), Particle(0u, vec2(pos)), vec2(0.0), 0.0, 0);\n    \n    // Compute force and velocity on each particle\n    range(i, -1, 1) range(j, -1, 1) \n    {\n        vec2 pos_ = pos + vec2(i, j);\n        Cell c_ = unpackCell(texelFetch(iChannel0, ivec2(pos_), 0), pos_);\n        \n        G2P2G(c_.p0, c, pos);\n        G2P2G(c_.p1, c, pos);\n        G2P2G(c_.p2, c, pos);\n        G2P2G(c_.p3, c, pos);\n    }\n    \n    // Normalize the velocity of the grid node\n    if (c.mass > 0.0) \n    {\n        c.vel /= c.mass;\n    }\n    \n    //c.vel += normalize(vec2(iResolution.xy/(2.0 * resScale)) - pos) * 0.01 * dt;\n    \n    c.vel -= vec2(0.0, 0.005) * dt; // gravity\n    \n    // Split particles\n    SplitParticles(c, iTime);\n    \n    if (distance(pos, vec2(iMouse.xy/resScale)) < 3.0 && iMouse.z > 1.0) {\n        c.p0.mass = 1u;\n        c.p0.pos = pos + vec2(0.25);\n        c.p1.mass = 1u;\n        c.p1.pos = pos + vec2(0.75, 0.25);\n        c.p2.mass = 1u;\n        c.p2.pos = pos + vec2(0.25, 0.75);\n        c.p3.mass = 1u;\n        c.p3.pos = pos + vec2(0.75);\n        \n        c.vel = pos - vec2(iMouse.xy/resScale);\n    }\n    \n    float vel = length(c.vel);\n    c.vel /= (vel > 1.0) ? vel : 1.0;\n    \n    if (pos.y <= 4.0)\n        c.vel.y = 0.0;\n    if (pos.x <= 4.0)\n        c.vel.x = 0.0;\n    if (pos.x >= (iResolution.x/resScale) - 4.0)\n        c.vel.x = -1.0;\n    \n    fragColor = packCell(c, pos);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define range(i,a,b) for(int i = a; i <= b; i++)\n#define resScale 4.0\n#define dt 1.0\n\nuint helperPackUnorm32x4(uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nuvec4 helperUnpackUnorm32x4(uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packUnorm32x4(  vec4  a) \n{ \nreturn uintBitsToFloat(helperPackUnorm32x4(uvec4(round(clamp(a, 0., 1.)*255.)))); \n}\n\nvec4  unpackUnorm32x4(float a) \n{ \nreturn vec4(helperUnpackUnorm32x4(floatBitsToUint(a))) / 255.; \n}\n\nfloat packSnorm32x4(  vec4  a) \n{ \nreturn uintBitsToFloat(helperPackUnorm32x4(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); \n}\n\nvec4  unpackSnorm32x4(float a) \n{ \nreturn clamp((vec4(helperUnpackUnorm32x4(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); \n}\n\nuint helperPackUnorm32x8(uvec4 a, uvec4 b) \n{\n    return uint( \n            (a.x << 28) |\n            (a.y << 24) |\n            (a.z << 20) |\n            (a.w << 16) | \n            (b.x << 12) |\n            (b.y << 8 ) |\n            (b.z << 4 ) |\n            (b.w << 0 ) \n        ); \n}\n\nstruct uvec4x2\n{\n    uvec4 a;\n    uvec4 b;\n};\n\nuvec4x2 helperUnpackUnorm32x8(uint a) \n{\n    return uvec4x2(  \n            uvec4(\n                (a & 0xF0000000u) >> 28,\n                (a & 0x0F000000u) >> 24,\n                (a & 0x00F00000u) >> 20,\n                (a & 0x000F0000u) >> 16\n            ),\n            uvec4(\n                (a & 0x0000F000u) >> 12,\n                (a & 0x00000F00u) >> 8 ,\n                (a & 0x000000F0u) >> 4 ,\n                (a & 0x0000000Fu) >> 0\n            )\n        ); \n}\n\nfloat packUnorm32x8(vec4 a, vec4 b)\n{\n    return uintBitsToFloat(helperPackUnorm32x8(\n            uvec4(round(clamp(a, 0.0, 1.0)*15.0)), \n            uvec4(round(clamp(b, 0.0, 1.0)*15.0))\n        ));\n}\n\nmat2x4 unpackUnorm32x8(float a)\n{\n    mat2x4 m;\n    \n    uvec4x2 um = helperUnpackUnorm32x8(floatBitsToUint(a));\n    \n    m[0] = vec4(um.a) / 15.0;\n    m[1] = vec4(um.b) / 15.0;\n    \n    return m;\n}\n\nfloat packSnorm32x8(vec4 a, vec4 b)\n{\n    return uintBitsToFloat(helperPackUnorm32x8(\n            uvec4(round(clamp(a, -1.0, 1.0)*7.5 + 7.5)), \n            uvec4(round(clamp(b, -1.0, 1.0)*7.5 + 7.5))\n        ));\n}\n\nmat2x4 unpackSnorm32x8(float a)\n{\n    mat2x4 m;\n    \n    uvec4x2 um = helperUnpackUnorm32x8(floatBitsToUint(a));\n    \n    m[0] = (vec4(um.a) - 7.5) / 7.5;\n    m[1] = (vec4(um.b) - 7.5) / 7.5;\n    \n    return m;\n}\n\nstruct Particle \n{\n    uint mass; // move this to main cell struct??\n    vec2 pos;\n};\n\nstruct Cell \n{\n    Particle p0;\n    Particle p1;\n    Particle p2;\n    Particle p3;\n    \n    vec2 vel;\n    float mass;\n    \n    int count; // number of particles already clustered\n};\n\nvec4 packCell(Cell c, vec2 pos)\n{\n    vec4 info;\n    info.x = uintBitsToFloat(helperPackUnorm32x4(uvec4(c.p0.mass, c.p1.mass, c.p2.mass, c.p3.mass)));\n    info.y = packUnorm32x8(vec4(c.p0.pos - pos, c.p1.pos - pos), vec4(c.p2.pos - pos, c.p3.pos - pos));\n    info.z = packSnorm32x4(vec4(c.vel, 0.0, 0.0));\n    info.w = c.mass;\n\n    return info;\n}\n\nCell unpackCell(vec4 info, vec2 pos)\n{\n    Cell c;\n    \n    uvec4 x = helperUnpackUnorm32x4(floatBitsToUint(info.x));\n    c.p0.mass = x.x;\n    c.p1.mass = x.y;\n    c.p2.mass = x.z;\n    c.p3.mass = x.w;\n    \n    mat2x4 y = unpackUnorm32x8(info.y);\n    c.p0.pos = y[0].xy + pos;\n    c.p1.pos = y[0].zw + pos;\n    c.p2.pos = y[1].xy + pos;\n    c.p3.pos = y[1].zw + pos;\n    \n    vec4 z = unpackSnorm32x4(info.z);\n    c.vel = z.xy; // packet baced on max velocity based on dt\n    \n    c.mass = info.w;\n    \n    return c;\n}\n\nvoid Clusterize(inout Cell c, Particle p, vec2 pos) \n{\n    if (!all(equal(floor(p.pos), floor(pos))) || p.mass == 0u) {\n        return;\n    }\n    \n    if (c.count <= 3) {\n        switch (c.count) {\n        case 0:\n            c.p0.pos = p.pos;\n            c.p0.mass = p.mass;\n            break;\n        case 1:\n            c.p1.pos = p.pos;\n            c.p1.mass = p.mass;\n            break;\n        case 2:\n            c.p2.pos = p.pos;\n            c.p2.mass = p.mass;\n            break;\n        case 3:\n            c.p3.pos = p.pos;\n            c.p3.mass = p.mass;\n            break;\n        }\n        c.count++;\n        return;\n    }\n    \n    float a = distance(c.p0.pos, p.pos);\n    float b = distance(c.p1.pos, p.pos);\n    float d = distance(c.p2.pos, p.pos);\n    float e = distance(c.p3.pos, p.pos);\n    float minDist = min(a, min(b, min(d, e)));\n    \n    if (minDist == a) \n    {\n        c.p0.pos = (c.p0.pos * float(c.p0.mass) + p.pos * float(p.mass)) / float(c.p0.mass + p.mass);\n        c.p0.mass += p.mass;\n    } \n    else if (minDist == b) \n    {\n        c.p1.pos = (c.p1.pos * float(c.p1.mass) + p.pos * float(p.mass)) / float(c.p1.mass + p.mass);\n        c.p1.mass += p.mass;\n    } \n    else if (minDist == d) \n    {\n        c.p2.pos = (c.p2.pos * float(c.p2.mass) + p.pos * float(p.mass)) / float(c.p2.mass + p.mass);\n        c.p2.mass += p.mass;\n    } \n    else if (minDist == e) \n    {\n        c.p3.pos = (c.p3.pos * float(c.p3.mass) + p.pos * float(p.mass)) / float(c.p3.mass + p.mass);\n        c.p3.mass += p.mass;\n    }\n}\n\nvoid SplitParticle(inout Particle a, inout Particle b) \n{    \n    a.pos = a.pos;\n    b.pos = b.pos + 0.8;\n    \n    uint newMass = a.mass / 2u;\n    a.mass -= newMass;\n    b.mass = newMass;\n}\n\nvoid SplitParticles(inout Cell c, float seed)\n{\n    switch(int(fract(sin(seed + c.p1.pos.x + c.p0.pos.y))*2.99))\n    {\n        case 0:\n        if (c.p0.mass == 0u)\n        {\n            SplitParticle(c.p1, c.p0);\n        }\n        if (c.p1.mass == 0u)\n        {\n            SplitParticle(c.p2, c.p1);\n        }\n        if (c.p2.mass == 0u)\n        {\n            SplitParticle(c.p3, c.p2);\n        }\n        if (c.p3.mass == 0u)\n        {\n            SplitParticle(c.p0, c.p3);\n        }\n    break;\n        case 1:\n        if (c.p0.mass == 0u)\n        {\n            SplitParticle(c.p2, c.p0);\n        }\n        if (c.p1.mass == 0u)\n        {\n            SplitParticle(c.p3, c.p1);\n        }\n        if (c.p2.mass == 0u)\n        {\n            SplitParticle(c.p0, c.p2);\n        }\n        if (c.p3.mass == 0u)\n        {\n            SplitParticle(c.p1, c.p3);\n        }\n    break;\n        case 2:\n        if (c.p0.mass == 0u)\n        {\n            SplitParticle(c.p3, c.p0);\n        }\n        if (c.p1.mass == 0u)\n        {\n            SplitParticle(c.p0, c.p1);\n        }\n        if (c.p2.mass == 0u)\n        {\n            SplitParticle(c.p1, c.p2);\n        }\n        if (c.p3.mass == 0u)\n        {\n            SplitParticle(c.p2, c.p3);\n        }\n    break;\n    }   \n}\n","name":"Common","description":"","type":"common"}]}