{"ver":"0.1","info":{"id":"4lBfzt","date":"1516795979","viewed":285,"name":"Volumetric Machine","username":"PrzemyslawZaworski","description":"Just simple shader which I use for debug purposes.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","abstract","map","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime\n\nvoid r(inout vec2 p) \n{\n\tfloat a = mod(atan(p.y, p.x) + .1963495,.39269908) - .1963495;\n\tp = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat c(vec3 p, vec3 a, vec3 b, float r)\n{  \n\treturn length(((b - a)*clamp(dot(p - a, b - a) / dot(b - a, b - a),0.,1.) + a) - p) -r ;\n}\n\nfloat map (vec3 p)\n{\n\tp.y = mod(p.y + 1., 2.) - 1.;\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(.7,10.);\n\tfloat a = min(max(d.x,d.y),0.0) + length(max(d,0.)); \n    a=min(a,length(vec2(length(p.xz)-1.2,p.y))-.35);\n    r(p.xz);\n    float b = c(p,vec3(.6,3,0),vec3(.6,-3,0),.2);\n    a=max(a,-b);\n    p=vec3(cos(T)*p.x-sin(T)*p.z,p.y,sin(T)*p.x+cos(T)*p.z);\n    r(p.xz);    \n    float g = c(p,vec3(2,-.5,0),vec3(2,.5,0),.2);\n    float e = c(p,vec3(2,-.5,0),vec3(1,-.5,0),.2);\n    float f = c(p,vec3(2,.5,0),vec3(1,.5,0),.2);\n    return min(a,min(min(g,e),f));\n}\n\nvec4 raymarch (vec3 p, vec3 rd)\n{\n    for (int i=0;i<128;i++)\n    {\n      float t = map (p);\n      if (t<0.001)  return vec4(pow(1.-float(i)/float(128),2.));         \n      p+=t*rd;\n    }\n    return vec4(1.0-(pow(length(rd.x),2.)*2.),0,0,1);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n\tvec2 uv = (2. * f.xy - iResolution.xy) / iResolution.y;\n\to = raymarch(vec3 (0,T,-5.),normalize(vec3(uv,2.)));\n}","name":"Image","description":"","type":"image"}]}