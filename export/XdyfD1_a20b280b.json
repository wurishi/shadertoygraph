{"ver":"0.1","info":{"id":"XdyfD1","date":"1528786843","viewed":119,"name":"SphereTracing and caleidoscope","username":"lucastakejame","description":"trying to implement sphere tracing algorithm with SDF geometry","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","spheretrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using right hand coordinate system\n\n#define M_PI 3.1415\n#define MAX_D 4.\n#define MAX_IT 100\n#define COS60 0.86602540378\n#define DT 0.025\n#define EPS .01\n\nconst vec3 gLight = vec3(1., 1., 1.);\nvec2 gMuv;\n\n// repeat figure inside window width\nfloat repeat( float x, float width)\n{       \n   \treturn -width/2. + mod(x+width/2., width);\n}\n\nfloat max3(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// quaternion multiplication\nvec4 quatMult(vec4 a, vec4 b)\n{\n\treturn vec4(a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w ,(a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z) ,(a.x*b.z-a.y*b.w+a.z*b.x+a.w*b.y) ,(a.x*b.w+a.y*b.z-a.z*b.y+a.w*b.x) );\n}\n\nvec3 rotAroundAxis(vec3 p, float rad, vec3 axis)\n{\n    float halfCos = cos(rad/2.);\n    float halfSin = sin(rad/2.);\n\n    vec4 rotQuat = vec4(halfCos, halfSin*axis.x, halfSin*axis.y, halfSin*axis.z);\n    vec4 invRotQuat = vec4(halfCos, -halfSin*axis.x, -halfSin*axis.y, -halfSin*axis.z);\n\n    return quatMult(quatMult(rotQuat, vec4(0., p)), invRotQuat).yzw;\n}\n\n\n// if b is smaller than a, changes 'color' to targetColor\nvoid changeColorWhenMin(out float a, float b, out vec4 color, vec4 targetColor)\n{\n    if(b < a)\n    {\n        a = b;\n        color = targetColor;\n    }\n        \n}\n\n// Implicit surfaces\n\n// radius 1, placed at origin\nfloat fSphere(vec3 p)\n{\n\treturn length(p) - 1.;\n}\n\nfloat fCylinder(vec3 p, vec2 c)\n{\n    vec2 d = vec2(length(p.xy)-c.x, abs(p.z) - abs(c.y));\n    return length(\n        max(d, 0.)) + max3(min(d, 0.).xyy);\n}\n\nfloat fBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n\treturn length(\n        max(d, 0.)) + max3(min(d, 0.));\n}\n\nfloat fFloor(vec3 p, float level)\n{\n    return p.z - level;//+0.5*(sin(p.x - iTime)+sin(p.y + iTime));\n}\n\nfloat fScene(vec3 p, out vec4 color)\n{\n    float dist = distance(p, vec3(0.));\n    \n    float ret;\n    \n    float xAxis = fBox(p - vec3(1.,0.,0.), vec3(1., .1, .1));\n    float yAxis = fBox(p - vec3(0.,1.,0.), vec3(.1, 1., .1));\n    float zAxis = fBox(p - vec3(0.,0.,1.), vec3(.1, .1, 1.));\n    \n    float ground = fFloor(p, -2.);\n    float sphere = fSphere(p-vec3(2.,3.,3.)); \n    float spheres = fSphere(\n        \t\t\tvec3(\n                    \trepeat(p.x , .5),\n                    \trepeat(p.y , .5),\n                    \tp.z + (5./(1.+dist))*1.*sin(length(p) + iTime*5.))\n    \t\t\t\t);\n   \tfloat cylinder = fCylinder(p, vec2(1.,1.));\n    float box = fBox(p, vec3(1., .1, .6));\n    \n    \n    // testing quaternion rotation\n    float orb0 = fSphere(p - rotAroundAxis(5.*sin(iTime*0.3)*vec3(2.,0.,0.) + vec3(0.,0.,2.), (1./1.3)*iTime, normalize(vec3(0.,0.,1.))));\n    float orb1 = fSphere(p - rotAroundAxis(5.*sin(iTime*0.4)*vec3(2.,0.,0.) + vec3(0.,0.,2.), (1./1.1)*iTime, normalize(vec3(0.,0.,1.))));\n    float orb2 = fSphere(p - rotAroundAxis(5.*sin(iTime*0.7)*vec3(2.,0.,0.) + vec3(0.,0.,2.), (1./0.7)*iTime, normalize(vec3(0.,0.,1.))));\n    float orb3 = fSphere(p - rotAroundAxis(5.*sin(iTime*1.1)*vec3(2.,0.,0.) + vec3(0.,0.,2.), (1./0.4)*iTime, normalize(vec3(0.,0.,1.))));\n    float orb4 = fSphere(p - rotAroundAxis(5.*sin(iTime*1.3)*vec3(2.,0.,0.) + vec3(0.,0.,2.), (1./0.3)*iTime, normalize(vec3(0.,0.,1.))));\n    \n    ret = 9999999.;\n    \n    //changeColorWhenMin(ret, xAxis, color, vec4(1.,0.,0.,1.));\n    //changeColorWhenMin(ret, yAxis, color, vec4(0.,1.,0.,1.));\n    //changeColorWhenMin(ret, zAxis, color, vec4(0.,0.,1.,1.));\n    //changeColorWhenMin(ret, ground, color, vec4(1.,1.,1.,1.));\n    changeColorWhenMin(ret, spheres, color, mix(.5, 1.5, p.z)*vec4(1.,1.,1.,1.));\n    changeColorWhenMin(ret, orb0, color, 3.*vec4(1.0,0.5,0.7,1.0));\n    changeColorWhenMin(ret, orb1, color, 3.*vec4(1.0,0.0,0.2,1.0));\n    changeColorWhenMin(ret, orb2, color, 3.*vec4(1.0,0.0,0.7,1.0));\n    changeColorWhenMin(ret, orb3, color, 3.*vec4(1.0,0.0,0.0,1.0));\n    changeColorWhenMin(ret, orb4, color, 3.*vec4(1.0,0.7,0.2,1.0));\n\n    return ret;\n}\n\n// Used to calculate gradient\nfloat fScene(vec3 p)\n{\n    vec4 color;\n\treturn fScene(p, color);\n}\n\n\n\nvec3 grad(vec3 p)\n{\n    return normalize( vec3(\n    \tfScene(p + vec3(EPS, 0., 0.)) - fScene(p - vec3(EPS, 0., 0.)),\n    \tfScene(p + vec3(0., EPS, 0.)) - fScene(p - vec3(0., EPS, 0.)),\n    \tfScene(p + vec3(0., 0., EPS)) - fScene(p - vec3(0., 0., EPS))\n    ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    gMuv = iMouse.xy/iResolution.y;\n    \n   \tbool caleidoscope = true;\n    \n\t// caleidoscope effect\n    if(caleidoscope)\n    {\n        vec2 center = iResolution.xy/2.;\n        vec2 cart = fragCoord - center;\n\n        vec2 polar = vec2 (atan(cart.y, cart.x), length(cart) );\n\n        polar.x +=  \n            3.1415\n            + sin(polar.y/10. + iTime*5.)*polar.y/2000.\n            *sin(polar.y/100.)\n            + sin(8.5*polar.y/iResolution.y)*(polar.y)/iResolution.y\n            ; // angle offset\n        \n        polar.y = polar.y + -60.*smoothstep(0.,iResolution.y/2., polar.y);\n\n        float val = 6.283/7.;\n\n        polar.x = mod(polar.x , val);\n\n        fragCoord = center\n            + vec2(cos(polar.x)*polar.y,\n                   sin(polar.x)*polar.y);\n\t}\n    \n    float ratio = iResolution.x/iResolution.y;\n \tvec2 uv = fragCoord/iResolution.y;\n    \n    // camera angles looking at origin\n    float yaw = M_PI*gMuv.x;//mod(iTime,2.*M_PI);\n    float pitch = .6+1.*M_PI*gMuv.y/5.;\n    \n    \n    // ray origin\n    float arm = 15.;// + 5.*sin(iTime);\n\tvec3 ro = vec3(arm*cos(yaw)*cos(pitch), arm*sin(yaw), arm*sin(pitch));\n    \n    \n    // screen plane offset, perpendicular do ro - origin\n    vec3 rp = ro + normalize(-ro)*COS60;\n    \n    vec3 screenU = vec3(-1.*sin(yaw), 1.*cos(yaw), 0.);\n    vec3 screenV = vec3(-1.*sin(pitch)*cos(yaw), -1.*sin(pitch)*sin(yaw), 1.*cos(pitch));\n    \n    \n    // pixel position in world location\n    vec3 pxpos = rp\n        \t\t+ screenU*(uv.x - ratio/2.)\n        \t\t+ screenV*(uv.y - .5);    \n  \n    vec3 rd = normalize(pxpos - ro);\n    \n    vec3 col; \n    \n    float d = 0.;\n    \n//    for(float d = 0.; d < MAX_D;)\n    for( int i = 0; i < MAX_IT; i++)\n    {\n        vec3 p = ro + rd*d;\n        vec4 baseColor;\n        float dist = fScene(p, baseColor);\n        if(dist < EPS)\n        {\n            // normal\n            vec3 n = grad(p);\n            // light intensity\n            float li = dot(normalize(gLight-p+vec3(0.,0.,1.)*10.), n);\n            float dist = distance(p, vec3(0.));\n            \n            //col = li*vec3(d*1./MAX_D)*abs(cos(iTime+dist/50.+vec3(0,2,4)));\n            col = li*baseColor.xyz;\n            \n            break;\n        }\n        else\n        {\n            col = vec3( 0.);\n        }\n        // use distance to closest surface as step\n        d = d + dist;\n        //d = d + DT; // mais completo, sem artefato\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}