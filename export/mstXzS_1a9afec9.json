{"ver":"0.1","info":{"id":"mstXzS","date":"1680046740","viewed":59,"name":"perlin + domainwarp clouds","username":"lainga2","description":"starting from https://www.shadertoy.com/view/lt2BRm, kind of looks like vortices in the wake :)\n\nI want to turn a bitmap (for cloud/no cloud) into something that looks cloudy at small scale. I'm not sure how to translate the bitmap into an SDF yet.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// perlin edge method from https://www.shadertoy.com/view/lt2BRm\n// perlin noise from https://www.shadertoy.com/view/XdcXzH\n// fbm domain warp from iq's article and https://www.shadertoy.com/view/4s23zz\n#define _PerlinPrecision 8.0\n#define _PerlinOctaves 8.0\n#define _PerlinSeed 0.0\n\n// if you want to see squares instead of an ellipsoid\n#define SQUARES\n\n// if you HATE pixels comment this out\n#define PIXELATED\n\n//\n// the big trick here is the quasi-sawtooth makes it look like a cloud is advancing (sharp rising edge)\n// and then leaving a trail of vortices in its wake (slow falling edge).\n//\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\n\nfloat inter(float a, float b, float x)\n{\n    return a*(1.0-x) + b*x; // Linear interpolation\n}\n\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\t\t\t\t\t// Final heightmap value\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta----b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|    |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc----d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*(-1.0+2.0*perlin( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*perlin( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*perlin( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*perlin( p ));\n    return f/0.9375;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2( fbm4(p+vec2(1.0)), fbm4(p+vec2(6.2)) );\n}\n\n// this is direct from iq's article.\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat rect(vec2 p, vec2 sz, vec2 pos) {\n    vec2 c = abs(p - pos) - sz;\n    float od = length(max(c, 0.));\n    float id = min(max(c.x, c.y), 0.);\n    \n    return od + id;\n}\n\n// 4 terms of taylor series for sawtooth\nfloat tri(float x) {\n    return .5 + (\n          sin(x) \n        - sin(2. * x) * .500\n        + sin(3. * x) * .333\n        - sin(4. * x) * .250\n    ) / 3.14159;\n}\n\n\nconst float m = .001;\nconst float join = 0.15;\nconst float ofs = 0.15;\n\n\nconst vec4 bg_col = vec4(140.,194.,175.,256.)/256.;\nconst vec4 fg_col = vec4(242.,251.,232.,256.)/256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    p *= 5.;\n#ifdef PIXELATED\n    p = round(p*64.)/64.;\n#endif\n    \n    // the denser the cloud, the less jaggedness and domain warping, and more spillover outside the\n    // original areas\n    float tb = tri(-p.x + 0.5 * iTime);\n    float bulge = 0.7 + 0.3 * tb;\n    \n    // warp the domain\n    float w = 0.1 + tb;\n    p = p + 0.4 * w * fbm4_2(p);\n    \n    // get SDF\n\n#ifdef SQUARES\n    float r = 1.;\n    for (int i = 0; i < 7; i++){\n        float d = rect(p, vec2(.55), vec2(float(i-3), float((i % 3 - 1))));   \n        r = opSmoothUnion(r, d * bulge, join);\n    }\n#else\n    float r = .2 * sqrt(p.x*p.x*.2 + p.y*p.y);\n#endif\n    \n    // make edges\n    float noise_scale = tb * 3.;\n    float num_layers = 8.;\n    float t = iTime*.05;\n    float v = 0.;\n    \n    for (float i = 0.; i < num_layers; i++) {\n        float h = noise_scale*perlin(p+vec2(i)+t)+r;\n        if (h < 0.4) { v += 1./num_layers; }\n    }\n    \n    // Output to screen\n    fragColor = mix(bg_col, fg_col, v);\n}","name":"Image","description":"","type":"image"}]}