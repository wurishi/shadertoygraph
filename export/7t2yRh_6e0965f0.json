{"ver":"0.1","info":{"id":"7t2yRh","date":"1658878345","viewed":167,"name":"Complex trippy shit #1","username":"bencbartlett","description":"Complex functions go brrrr","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["complexmath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define ii vec2(0.0, 1.0)\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_abs(z) length(z)\n#define cx_conj(z) vec2(z.x, -z.y)\n#define cx_arg(z) atan(z.y, z.x)\n#define cx_sin(z) vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y))\n#define cx_cos(z) vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y))\n#define cx_exp(z) vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y))\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Complex math library ==========================\nvec2 cx_pow(vec2 z, float n) {\n    float angle = cx_arg(z);\n    float r = length(z);\n    float re = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(re, im);\n}\nvec2 cx_log(vec2 z) {\n    float rpart = sqrt((z.x*z.x)+(z.y*z.y));\n    float ipart = atan(z.y,z.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\nvec4 domainColoring (vec2 z, vec2 gridSpacing, float saturation, float gridStrength, float magStrength, float linePower) {\n    // Adapted from https://github.com/rreusser/glsl-domain-coloring\n    float carg = cx_arg(z);\n    float cmod = cx_abs(z);\n\n    float rebrt = pow((fract(z.x / gridSpacing.x) - 0.5) * 2.0, 2.);\n    float imbrt = pow((fract(z.y / gridSpacing.y) - 0.5) * 2.0, 2.);\n\n    float grid = 1.0 - (1.0 - rebrt) * (1.0 - imbrt);\n    grid = pow(abs(grid), linePower);\n\n    float circ = (fract(log2(cmod)) - 0.5) * 2.0;\n    circ = pow(abs(circ), linePower) * magStrength;\n\n    vec3 rgb = hsv2rgb(vec3(carg * 0.5 / PI, saturation, 0.5 + 0.5 * saturation - gridStrength * grid));\n    rgb *= (1.0 - circ);\n    rgb += circ * vec3(1.0);\n    return vec4(rgb, 1.0);\n}\n// =============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.8 * (2. * fragCoord/iResolution.xy - 1.);\n    uv *= vec2(16./9., 1.);\n    uv = vec2(-uv[1] - .2, uv[0]);\n    \n    // Function is log(1/4 + iz^-3) + 2 exp(it)\n    vec2 fz = cx_log(vec2(.25, 0.0) + cx_pow(uv, -3.)) + 2. * cx_exp(iTime * ii);\n    \n    float refz = fz[0];\n    float imfz = fz[1];\n    float argfz = cx_arg(fz) / (2.*PI);\n    float absfz = cx_abs(fz);\n    \n    //float map = sin(refz + imfz) - log(absfz);\n    //float a=2.;\n    //map = pow(absfz, a) / (pow(absfz, a) + 1.);\n    \n    fragColor = domainColoring(fz, vec2(1.0, 1.), 0.9, 1., 1., 1.);\n}","name":"Image","description":"","type":"image"}]}