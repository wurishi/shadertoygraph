{"ver":"0.1","info":{"id":"4tcyzX","date":"1533349094","viewed":197,"name":"Heat Conduction Simulation","username":"archibate","description":"Black-body (i.e. Planck's law) colored.\nClick mouse to create more heat!\nheat conduction follows the equation:\ndu/dt=-k:nabla::square:u\nwhere u stands for the temprature (@ghost).","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","heat","physics","blackbody"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/MslSDl\nvec3 blackbody(float _t)\n{\n    // See: http://en.wikipedia.org/wiki/Planckian_locus\n    //      under \"Approximation\"\n    \n    float u = (0.860117757 + 1.54118254e-4*_t + 1.28641212e-7*_t*_t)\n        / (1.0 + 8.42420235e-4*_t + 7.08145163e-7*_t*_t);\n    \n    float v = (0.317398726 + 4.22806245e-5*_t + 4.20481691e-8*_t*_t)\n        / (1.0 - 2.89741816e-5*_t + 1.61456053e-7*_t*_t);\n    \n    // http://en.wikipedia.org/wiki/CIE_1960_color_space\n    // -> http://en.wikipedia.org/wiki/XYZ_color_space\n    \n    float x = 3.0 * u / (2.0 * u - 8.0 * v + 4.0);\n    float y = 2.0 * v / (2.0 * u - 8.0 * v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = (Y/y) * x;\n    float Z = (Y/y) * z;\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 XYZtosRGB = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n    \n    vec3 RGB = vec3(X,Y,Z) * XYZtosRGB;\n    return RGB * pow(0.0004*_t, 4.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    float c = texture(iChannel0, U/iResolution.xy).r;\n    //O = vec4(c);\n    O.rgb = blackbody(4000.*c);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define K .2\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    #define T(u) texture(iChannel0, (u)/iResolution.xy)\n\t#define a(o,f) T(U o vec3(1,1,0).f).r\n    O = T(U);\n    float A = a(+,xz) + a(-,xz) + a(+,zy) + a(-,zy);\n    for (int i = 0; i < 50; i++) // using 50*K can leads to some unameable wrong\n    \tO.r += K*(-4.*O.r + A);\n    \n    if (iFrame < 5)\n        O = texture(iChannel1, U / iResolution.xy);\n    \n    if (iMouse.w >= .5)\n        O.r += .1*exp(-.01 * pow(distance(U, iMouse.xy),2.));\n}","name":"Buffer A","description":"","type":"buffer"}]}