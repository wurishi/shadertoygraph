{"ver":"0.1","info":{"id":"flGyDR","date":"1670097771","viewed":170,"name":"Recursive box projection","username":"geoffroy","description":"I am proud to present to you my first fractal :)\nThis is a recursive projection of a 3d box on each faces\nI hope you enjoy it :) ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sdf","projection","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a)  mat2(cos(a),-sin(a), sin(a),cos(a))\n#define MAXDIST 80.\n\nfloat sdBox( vec3 p, vec3 b ) \n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.12;\n}\n\nfloat map(vec3 p) \n{\n    return sdBox(p, vec3(1.));\n}\n\nfloat tick(float phase, float period)\n{\n    float p = abs(2.*(fract((phase+iTime)*1./period)-0.5));\n    return 1.-smoothstep(0.4, 0.6, p);\n}\n\nvec3 calcNormal(in vec3 p) \n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid transform(inout vec3 p)\n{\n    p += vec3(0, 0, 3);\n    p.xz *= rot(3.1416 * 0.45 + iTime*0.2);\n    p.yz *= rot(3.1416 * tick(0.0, 10.0) + iTime*0.2);\n}\n\nvec4 rm(vec2 uv, float f) \n{\n    float scale = 0.25 + 0.2 * tick(2.5, 10.0);\n    vec3 ro = vec3(0, 0, 3);                           // ray origin\n    vec3 screen = vec3(uv, 2.);\n    vec3 rd = normalize(screen - ro); \n    vec4 o;\n    \n    // March the distance field until a surface is hit.\n    float h, t = 1.;\n    int i = 0;\n    float first = 0.;\n    float min = 99.;\n    for (; i < 256; i++) {\n        vec3 p = ro + rd * t;\n        transform(p);\n        h = map(p);\n        if (i==0) first = h;\n        t += h;\n        if (h < min) min = h;\n        if (h < 0.01) break;\n        if (t > MAXDIST) break;\n    }\n    \n    if (t > MAXDIST) {\n        float thk = f*0.00042;\n        if (min < thk) {\n            o = vec4(vec2(0.0), vec2(1.-smoothstep(0.0, f*0.5, abs(min-f*0.5)), 1.0));\n        }\n    }\n    else {\n    \n        vec3 p = ro + rd * t;\n        float j = 1.;\n        transform(p);\n        vec3 n = calcNormal(p);\n        vec3 na = abs(n);\n        float edge = na.x*na.y + na.y*na.z + na.x*na.z;\n        edge *= j;\n        float e = smoothstep(0.0, 0.6, (edge));\n        uv = (p.xy*scale) * n.z;\n        uv += (p.xz*scale) * n.y;\n        uv += (p.yz*scale) * n.x;\n        o = vec4(uv, vec2(e, 1.-step(0.01, e)));        \n    } \n    return o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float o = 0.0;\n  for (int i = 0; i < 4; i++) {\n    vec2 uv = (2.0*fragCoord.xy+vec2(i%2,i/2) - iResolution.xy ) / iResolution.y;\n    uv *= 0.3;\n    float f = 0.2;\n    float excl = 1.0;\n \n    for (int i=0; i<8; i++, f+=.05) {\n        vec4 r = rm(uv, f);\n        uv = r.xy;\n        o += r.z * excl;\n        excl *= r.w;\n    }\n  }\n  //fragColor = vec4(vec3(tick(4.)), 0.0);\n  o /= 4.0;\n  o /= (1.0+o);\n  o = pow(o,0.4545);\n  fragColor = vec4(vec3(o), 0.0);   \n}","name":"Image","description":"","type":"image"}]}