{"ver":"0.1","info":{"id":"Mtlczl","date":"1506076346","viewed":322,"name":"Water Effect 2D","username":"Draedrus","description":"Water goes from icy to ebullition 3..2..1\n\nWater effect, play with your mouse and temp values :)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float epsx = 0.3/iResolution.x;\n    float epsy = 0.3/iResolution.y;\n    fragColor = texture(iChannel0, uv+vec2(-epsx, -epsy));\n    fragColor += texture(iChannel0, uv+vec2(epsx, -epsy));\n    fragColor += texture(iChannel0, uv+vec2(-epsx, epsy));\n    fragColor += texture(iChannel0, uv+vec2(epsx, epsy));\n    fragColor *= 0.25;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define WATER_HEIGHT_PERCENT 0.7\n#define WATER_BELOW_HEIGHT_PERCENT 0.2\n#define WATER_SURFACE_THICKNESS 0.01\n#define WATER_AMP 0.015\n#define WATER_FREQ 20.0\n#define WATER_SPEED 4.0\n#define WATER_REFR_STRENGTH 0.1\n#define nTIME iTime\n#define TIME speed*iTime\n\n#define WATER_COLOR_HOT vec3(0.4, 1.2, 2.0)\n#define WATER_COLOR_ICE vec3(4.0, 4.0, 4.0)\nvec3 LApex = vec3(0.1, 2.0, 0.0);\nvec3 LTarget = vec3(0.5, 0.0, 0.0);\nfloat LAperture = 30.0;\n\nfloat temp = 0.0;\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nvec2 hash2D(vec2 uv)\n{\n    return vec2(\n        sin(hash(uv.xy)*12.32042304),\n        cos(hash(uv.yx)*12.302849234832)\n        );\n}\n\nfloat voronoi(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash(fl+p);\n            //h += 0.5-0.5*sin(iTime*0.8+h);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            //res = min(res, d);\n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    //return sqrt(res);\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat SchlickFresnel(float n1, float n2, float cosO)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    float cosO5 = cosO*cosO*cosO*cosO*cosO;\n    return R0+(1.0-R0)*cosO5;\n}\n\nfloat surface(float _x, float _a, float _f, vec2 _t)\n{\n    float F = _f;\n    float A = _a;\n    float iSine = 0.0;\n    for(int i = 0; i < 6; i++)\n    {\n        float s = sin(_x*F+_t.x);\n    \tiSine += 1.0*A*pow(abs(s), 1.00)+A*abs(s)\n            // ebullition\n            +4.0*A*cos(_x*F*0.5+_t.y);\n        F*=1.9;\n        A*=0.8;\n    }\n    return max(0.0, 1.0-iSine)-1.0;\n}\n\nvec3 mainWater(in vec2 uv, in vec2 muv, float FTemp)\n{   \n    float amp = min(0.02, WATER_AMP*FTemp*0.5);\n    float freq = WATER_FREQ*FTemp;\n    float speed = WATER_SPEED*FTemp;\n    \n    LApex = vec3(muv, 0.0);\n    \n    // bubbles\n    vec2 vdir = vec2(TIME*speed, 0.0);\n    vec2 vuv = uv*freq+(vdir+vec2(sin(uv.x+nTIME), -TIME*speed))*FTemp;\n    float v = voronoi(vuv);\n    vec2 nearestBP = vec2(0.0, 0.0)+(max(0.0, (1.0-pow(v+0.9, 8.0))));\n    \n    float surf = surface(uv.x, amp, freq, vec2(TIME, TIME*speed));\n    float surfx = surface(uv.x+0.0001, amp, freq, vec2(TIME, TIME*speed));\n    \n    vec2 N = normalize(vec2(-(surfx-surf), 0.0001));\n    \n    float HPF = max(0.0, uv.y+surf-WATER_HEIGHT_PERCENT);\n    HPF /= max(WATER_SURFACE_THICKNESS, HPF);\n    HPF = min(1.0, HPF+max(0.0, uv.y)/WATER_HEIGHT_PERCENT*WATER_BELOW_HEIGHT_PERCENT);\n \n    float height = mix(0.0, 1.0, HPF);\n    \n    float ebullition = max(0.0, FTemp-0.1);\n    \n    height = max(height, ebullition*clamp(nearestBP.y, 0.0, WATER_HEIGHT_PERCENT));\n    \n    vec2 offset = texture(iChannel1, uv+TIME*0.01).rg*(1.0-HPF)*WATER_REFR_STRENGTH*ebullition;\n    \n    \n    // cone computations\n    float halfAperture = LAperture/2.0;\n    \n    vec3 LtoP = normalize(vec3(uv+offset*0.5, 0.0)-LApex);\n    vec3 Ldir = normalize(LTarget-LApex);\n    float extinction = height;//length(vec3(uv, 0.0)-LApex)/length(LTarget-LApex);\n    float inCone = max(0.0,\n                       1.0-min(1.0,\n                               acos(dot(LtoP, Ldir)\n                                   )\n                               / radians(halfAperture)\n                              )\n                       \n                       );//?0.0:1.0;\n    \n    inCone = clamp(inCone, 0.0, 0.5)*(1.0/0.5);\n    \n    float LIntensity = mix(FTemp, 1.0, height) * extinction;\n    \n    // colouring\n    \n    vec3 bgcolor = texture(iChannel0, uv+offset).rgb;\n    vec3 wcolor = mix(WATER_COLOR_ICE,\n                      WATER_COLOR_HOT,\n                      1.0-(pow(1.0-FTemp, 5.0)));\n    \n    \n    // blending depth\n    wcolor = mix(vec3(0.0), wcolor, height);\n\n    float fracture = 1.0-texture(iChannel2, uv).b;\n    wcolor = mix(wcolor*0.6, wcolor, min(1.0, 2.0*fracture*(1.0-ebullition)));\n    \n    // lighting\n    wcolor += inCone*LIntensity;\n    bgcolor += inCone*LIntensity;\n    \n    return mix(wcolor, bgcolor, height);\n}\n\nbool inBox(vec2 pt, vec4 box)\n{\n    return pt.x>box.x && pt.x<box.x+(box.z-box.x)\n        && pt.y<(1.0-box.y) && pt.y>(1.0-(box.y+(box.w-box.y)));\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec2 mck = iMouse.zw / iResolution.xy;\n    \n    vec4 box = vec4(0.05, 0.05, 0.1, 0.4);\n    bool indicator = inBox(uv, box);\n    \n    //float FTemp = min(1.0, max(0.0, temp+20.0)/100.0);\n    float FTemp = texture(iChannel3, vec2(0.0, 0.0)).r;\n    if(iTime<1.0)\n    {\n        FTemp = 0.35;\n    }\n    \n    if(inBox(mck, box))\n    {\n        muv = vec2(0.5,0.5);\n    }\n    vec3 color = mainWater(uv, muv, FTemp);\n    if(indicator)\n    {\n        vec3 gauge_color = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), FTemp);\n        vec3 gauge_glass_color = vec3(1.0);\n        float startY = 0.1;\n        float width = 0.02;\n        float inner = 0.003;\n        float height = 0.275;\n        \n        vec3 bubble = vec3(0.075, 1.0-0.375, width);\n        vec4 tube = vec4(0.065, startY, 0.065+width, startY+height);\n        vec4 innertube = vec4(0.065+inner, startY+inner,\n                              0.065+width-inner, startY+height-inner);\n        \n        float UVHIndicator = height+width/2.0;\n        float UVY = uv.y;\n        float topIndicator = 1.0-startY-UVHIndicator;\n        float percentUV = (UVY-topIndicator)/UVHIndicator;\n            ///(height-2.0*inner);\n        \n        if(FTemp>percentUV && (inBox(uv, innertube)\n                               || length(bubble.xy-uv)<=(bubble.z-inner)\n                              ))\n        {\n            color = mix(color, gauge_color, 0.45);\n        }\n        \n        if(length(bubble.xy-uv)<=bubble.z\n          || inBox(uv, tube))\n        {\n            color = mix(color,\n                        gauge_glass_color,\n                        1.0-Fresnel_Schlick(1.0, 1.1,\n                                        min(1.0, uv.x))\n                       );\n        }\n        if(inBox(uv, vec4(0.065+3.0*inner, startY+2.0*inner,\n                          0.065+width-2.0*inner, startY+height-2.0*inner))\n          || length(bubble.xy+vec2(0.004, 0.0)-uv)<=bubble.z*0.4\n          )\n        {\n            color = vec3(1.0);\n        }\n               \n        //color = vec3(percentUV);\n    }\n    if(fragCoord.x<1.0 && fragCoord.y<1.0)\n    {\n        if(inBox(mck, box))\n        {\n            float percent = ((1.0-mck.y)-box.y)/(box.w-box.y);\n            FTemp = 1.0-percent;\n        }\n        fragColor = vec4(FTemp);\n    }\n    else\n    {\n\t\tfragColor = vec4(color/(1.0+color),1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}