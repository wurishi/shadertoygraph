{"ver":"0.1","info":{"id":"Mt2BWy","date":"1517089871","viewed":88,"name":"Mandelbrot Shader WIP","username":"Alazorth","description":"go to https://www.shadertoy.com/view/MlSfDK\n\nfor the improved version.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//FRAGMENT SHADER\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define RE_START -2.\n//or float x = 2.0;\n//or float x - float(2);\n#define RE_END    1.\n#define IM_START -1.\n#define IM_END    1.\n#define MAX_ITER 359\n//const int MAX_ITER = 359;\n\n//fragCoord is current pixel\n//main loops the entire program every pixel\n\nvec2 simpleComplex(vec2 xy) {\n    vec2 result;\n    result.x = (RE_START + (xy.x/iResolution.x) * float(RE_END - RE_START));\n\tresult.y = (IM_START + (xy.y/iResolution.y) * float(IM_END - IM_START));\n\treturn result;        \n}\n\n//GLSL doesn't support while loops on old versions for some reason... ¯\\_(ツ)_/¯\nint fMbrot(vec2 c) {\n\tvec2 zed;\n    zed.x = 0.0;\n    zed.y = 0.0;    \n    int n = 0;\n    int i = 0;\n    //https://www.varsitytutors.com/hotmath/hotmath_help/topics/absolute-value-complex-number\n    for ( i; i < MAX_ITER; i++) {\n        if (sqrt(pow(zed.x,2.0) + pow(zed.y,2.0)) <= 2.0){  \n        \t//zed = zed*zed + c;\n        \tzed = vec2 (pow(zed.x,2.0)-pow(zed.y,2.0),2.0 *zed.x * zed.y);\n    \t\tzed.x = (zed.x + c.x);\n    \t\tzed.y = (zed.y + c.y);    \n\t\t\t//http://mathworld.wolfram.com/ComplexAddition.html        \n\t\t\tn+=1;\n        }\n        else {\n        \treturn n;\n            break;\n        }\n    }\n    return i;\n}\n    \n\nint wMbrot(vec2 c) { \n    vec2 zed;\n    zed.x = 0.0;\n    zed.y = 0.0;    \n    int n = 0;\n    //https://www.varsitytutors.com/hotmath/hotmath_help/topics/absolute-value-complex-number\n    while (sqrt(pow(zed.x,2.0) + pow(zed.y,2.0)) <= 2.0 && n < MAX_ITER) { \n        //zed = zed*zed + c;\n        zed = vec2 (pow(zed.x,2.0)-pow(zed.y,2.0),2.0 *zed.x * zed.y);\n    \tzed.x = (zed.x + c.x);\n    \tzed.y = (zed.y + c.y);    \n\t\t//http://mathworld.wolfram.com/ComplexAddition.html        \n\t\tn+=1;\n    }\n    return n;\n}\n\nvec4 nmap(float n) {\n\tvec3 colmap;\n    if (float(n) <= float(MAX_ITER)) {\n        float quotient = float(n) / float(MAX_ITER);\n        float color =  fract(quotient); //clamp(quotient,0.,1.);\n        \tif (quotient > 0.) {\n        \t// Close to the mandelbrot set the color changes from green to white \n \t\t\t\tcolmap = vec3(color,1.,color);\n        \t}\n        \telse {\n                colmap = vec3(0.5,color,0.5);\n            }\n    }\n    return vec4(colmap,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.,0.,0.,1.);\n\t\n    vec2 reim = simpleComplex(fragCoord.xy);\n    int n = fMbrot(reim);\n    \n    \n    \n    \n    // vec2 uv = fragCoord.xy/iResolution.xy;\n\t// float aspect = iResolution.y/iResolution.x;\n\t// vec2 p = uv*2.-1.; // transform uv range(0-1) to be centered and normalized(-1-1)\n    // p.y*=aspect;\n    // int n = mbrot(p*2.); // *2. is the zoom value to create a variable for controlled by GUI\n    //float B = float(n)*8./float(MAX_ITER); \n\t//float B = float(n)/float(MAX_ITER);\n\t//vec4 color = hue2rgb(B);\n    float fn = float (n);\n    vec4 preColor = nmap(fn);\n    fragColor = preColor;\n    \n        \n                \n    \n    //fragColor = color;\n}","name":"Image","description":"","type":"image"}]}