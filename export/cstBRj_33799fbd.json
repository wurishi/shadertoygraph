{"ver":"0.1","info":{"id":"cstBRj","date":"1697424381","viewed":105,"name":"Black Hole with Disk","username":"sking36","description":"Ray-tracing a black hole with disk","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["blackhole","twistedray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = 0.7*texture(iChannel0, uv).rgb;\n    color += 0.3*texture(iChannel1, uv).rgb; //add bloom\n\n    float exposure=1.0;\n\n    color = vec3(1.0) - exp(-color * exposure);\n    \n    //gamma correction\n    color=pow(color, vec3(1.0/2.2));\n\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPSILON 1e-3\n#define MAX_FLOAT 3.402823466e+38\n#define MAX_RECURSION 50\n#define PI 3.1415926535897932384626433832795\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time)\n{\n    g_seed = float(base_hash(floatBitsToUint(frag_coord))) / float(0xffffffffU) + time;\n}\n\nfloat rand1(inout float seed)\n{\n    uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n    return float(n) / float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed)\n{\n    uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed)\n{\n    uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec2 random_in_unit_disk(inout float seed)\n{\n    vec2 h = rand2(seed) * vec2(1., 6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n    return r * vec2(sin(phi), cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed)\n{\n    vec3 h = rand3(seed) * vec3(2., 6.28318530718, 1.) - vec3(1, 0, 0);\n    float phi = h.y;\n    float r = pow(h.z, 1. / 3.);\n    return r * vec3(sqrt(1. - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);\n}\n\n// Gaussian blur\nconst float rad = 10.;\nconst float dev = 0.3;\n\nfloat gau(float x) {return (0.398942280401/dev)*exp(-x*x/(dev*dev)/2.0);}\n\nvec3 checker_board(vec3 direction){\n    float scale=50.0;\n    float x=round(direction.x/direction.z*scale);\n    float y=round(direction.y/direction.z*scale);\n    if(mod(x+y, 2.) == 1.0){\n        return vec3(1.0);\n    }else{\n        return vec3(0.0);\n    }\n}\n\n// Camera\nstruct camera{\n    vec3 lookfrom;\n    vec3 lookat;\n    vec3  vup;\n    float vfov;\n    float aspect_ratio;\n    float aperture;\n    float focus_dist;\n};\n\nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nray get_ray(camera cam, vec2 uv){\n    vec3 w = normalize(cam.lookfrom - cam.lookat);\n    vec3 u = normalize(cross(cam.vup, w));\n    vec3 v = cross(w, u);\n\n    float theta = radians(cam.vfov);\n    float h = tan(theta/2.0);\n    float viewport_height = 2.0 * h;\n    float viewport_width = cam.aspect_ratio * viewport_height;\n\n    vec3 origin = cam.lookfrom;\n    vec3 horizontal = cam.focus_dist*viewport_width * u;\n    vec3 vertical = cam.focus_dist*viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal/2.0 - vertical/2.0 - cam.focus_dist*w;\n    \n    // float lens_radius = cam.aperture / 2.0;\n    // vec2 rd = lens_radius * random_in_unit_disk(g_seed);\n    // vec3 offset = u * rd.x + v * rd.y;\n    // return ray(origin+offset, lower_left_corner + uv.x*horizontal + uv.y*vertical - origin-offset);\n\n    //not consider the aperture\n    return ray(origin, (lower_left_corner + uv.x*horizontal + uv.y*vertical) - origin);\n}\n\n//defined for global usage\ncamera cam;\n\nvoid init_cam(float aspect_ratio){\n    vec3 lookfrom=vec3(0.1,0.1,0.1);\n    vec3 lookat=vec3(0,0,335000.);\n    vec3 vup=vec3(0,1.,0.);\n    cam=camera(lookfrom, lookat, vup, 30.0, aspect_ratio,0.0001,10.0);\n}\n\n//Black hole\n#define SPEED_OF_LIGHT  299792458.0\n#define G               6.6743e-11    //gravitational constant\n#define M               1.9891e30     //base mass for a back hole\n\nstruct black_hole{\n    vec3 center;\n    float radius;\n    float mass;\n};\n\nstruct disk{\n    vec3 center;\n    vec3 normal;\n    float wavelength;\n    float radius;\n    float thickness;\n    float speed;\n    black_hole bh;\n};\n\n//case with one black hole\n//case with one black hole\ndisk d1;\nblack_hole bh1;\n\nvoid init_black_hole(){\n    bh1=black_hole( vec3(0.0,0.0,250000.), 2.0*G*M/SPEED_OF_LIGHT/SPEED_OF_LIGHT, M);\n    d1 = disk(vec3(0.0,0.0,250000.), normalize(vec3(-0.3,1,-0.2)), 600., 20.0*G*M/SPEED_OF_LIGHT/SPEED_OF_LIGHT, 20., 2000.,bh1);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//the main part for the black hole\n//==================================================\n// Stars texture from Kali\n// https://www.shadertoy.com/view/XlfGRj\n#define iterations 14\n#define formuparam 0.53\n#define volsteps 20\n#define stepsize 0.1\n#define zoom   0.5\n#define tile   0.850\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nvec3 kali_stars(vec3 from, vec3 dir)\n{\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n    return mix(vec3(length(v)),v,saturation)*.01;\n}\n//==================================================\n\n#define HAS_GRAVITY     true\n\nvec3 get_color_on_disk(disk d1, vec3 p_to_d, float e_v, vec3 dir) {\n\n    float grav_factor = 1.0/ (SPEED_OF_LIGHT / (SPEED_OF_LIGHT - e_v));\n    //float speed = 1. + d1.speed*dot(dir, cross(d1.normal, p_to_d)) / 15000000.; // tuned, not physical, also assumes flat spinning speed\n\n    float speed = 1.0/ (SPEED_OF_LIGHT / (SPEED_OF_LIGHT + 10.0* d1.speed*dot(dir, cross(d1.normal, p_to_d)))); // more physical\n\n    speed = pow(speed, 1.5);\n\n    float factor = grav_factor*speed;\n\n    float seed = float(int(length(p_to_d)) / 100);\n\n    vec3 rand_band = random_in_unit_sphere(seed);\n    float rand_band_brightness = 2.*(length(rand_band) -0.5);\n    seed = float(int(length(p_to_d)) / 1000);\n    rand_band = random_in_unit_sphere(seed);\n    rand_band_brightness += 0.75*(length(rand_band) - 0.5);\n    seed = float(int(length(p_to_d)) / 4000);\n    rand_band = random_in_unit_sphere(seed);\n    rand_band_brightness += 1.5*(length(rand_band) - 0.7);\n\n    factor *= rand_band_brightness;\n\n    float heat_factor = pow(d1.radius/length(p_to_d),2.);\n    factor *= heat_factor;\n\n    vec3 return_color = vec3(3.*factor,1.2* factor,0.3* factor);\n\n    float translucent_odds = pow(length(p_to_d)/d1.radius,5.);\n    seed = iTime;\n    if (mod(rand1(seed), 1.0) < translucent_odds) {\n        return vec3(0);\n    }\n    translucent_odds = (pow(3.,0.5) - length(return_color)) /pow(3.,0.5);\n    if (mod(rand1(seed), 1.0) < translucent_odds) {\n        return vec3(0);\n    }\n\n    //return 2.*vec3(length(rand_band) - 0.5);\n\n    return return_color;\n}\n\nbool ray_march(inout ray r, float step_size, int max_iter, black_hole bh1, disk d1, out vec3 hit_loc, out int iters, out vec3 hit_color)\n{    \n    iters = 1;\n\n    vec3 p=r.origin;\n\n    while(iters<max_iter){\n        vec3 velocity=r.direction*SPEED_OF_LIGHT; \n        vec3 p_to_b=bh1.center-p;\n        vec3 p_to_d=d1.center-p;\n\n        float step_factor = 1.;\n\n        if (length(p_to_b)>2.*335000.) { // twice as far away as the camera\n            return false;\n        }\n\n    \n        if(length(p_to_b)<bh1.radius * 5.){\n            step_factor *= 0.5;\n            if(length(p_to_b)<bh1.radius * 2.){\n                step_factor *= 0.5;\n            }\n        }\n\n        else if(length(p_to_b)>bh1.radius * 10. && length(p_to_d)>d1.radius){\n            step_factor *=5.0 * length(p_to_b) / bh1.radius;\n        }\n\n\n        if(HAS_GRAVITY){\n            float acceleration_scalar = 2.0*G*bh1.mass/dot(p_to_b,p_to_b) * step_factor;\n            vec3 acceleration=p_to_b*(acceleration_scalar/length(p_to_b));\n            velocity+=acceleration*step_size;\n            velocity=normalize(velocity)*SPEED_OF_LIGHT;\n            r.direction=normalize(velocity);\n        }\n\n        p+=velocity*step_size * step_factor;\n        \n        if(length(p_to_b)<bh1.radius){\n            hit_loc = p;\n            hit_color = vec3(0,0,0);\n            return true;\n        }\n\n        if(length(cross(p_to_d, d1.normal))<d1.radius && abs(dot(p_to_d, d1.normal)) < d1.thickness){\n            hit_loc = p;\n            hit_color = get_color_on_disk(d1, p_to_d, sqrt(4.0*G*bh1.mass/sqrt(dot(p_to_b,p_to_b))), r.direction);\n            float too_dim = 0.000;\n            if (hit_color.x > too_dim && hit_color.y > too_dim && hit_color.z > too_dim) {\n                return true;\n            }\n        }\n        iters++;\n    }\n\n    return false;\n}\n\nvec3 ray_color(ray r,int depth) {\n    vec3 hit_loc; int iters;\n    vec3 hit_color = vec3(0,0,0);\n    bool hit=ray_march(r,0.0000001, 3500,bh1,d1, hit_loc,iters, hit_color);\n    if(hit){return hit_color;}\n    //the background\n    vec3 unit_direction = normalize(r.direction);\n    //return checker_board(unit_direction);\n    vec3 bg_color=kali_stars(r.origin,unit_direction);\n    //reverse gamma correction\n    bg_color=pow(bg_color, vec3(2.2));\n    return bg_color;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect_ratio=iResolution.x/iResolution.y;\n    const int max_depth = 50;\n\n    vec2 dxy=vec2(1.0/iResolution.x,1.0/iResolution.y);\n    init_rand(uv,iTime);\n    init_cam(aspect_ratio);\n    init_black_hole();\n\n    ray r = get_ray(cam, uv+rand2(g_seed)*dxy);\n    vec3 pixel_color = ray_color(r,max_depth);\n    pixel_color+=vec3(texture(iChannel1, uv));\n    fragColor = vec4(pixel_color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//accumulation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 new_data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if(iFrame==0){\n        fragColor=new_data;\n    }else{\n        vec4 old_data = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        vec3 accum_color=old_data.xyz*float(iFrame-1)+new_data.xyz;\n        fragColor = vec4(accum_color/float(iFrame),1.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//gaussian blur x-pass\nvoid mainImage(out vec4 color, in vec2 coord) {\n    \n    vec4 sum = vec4(0.);\n    \n    for(float i=-rad;i<=rad;i++){\n        vec4 color=texelFetch(iChannel0, ivec2(coord)+ivec2(i,0), 0);\n        sum += gau(i)*color;\n    }\n    \n    color = vec4(sum.rgb/sum.a,1.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//gaussian blur y-pass\nvoid mainImage(out vec4 color, in vec2 coord) {\n    \n    vec4 sum = vec4(0.);\n    \n    for(float i=-rad;i<=rad;i++){\n        vec4 color=texelFetch(iChannel0, ivec2(coord)+ivec2(0,i), 0);\n        sum += gau(i)*color;\n    }\n    \n    color = vec4(sum.rgb/sum.a,1.);\n}","name":"Buffer D","description":"","type":"buffer"}]}