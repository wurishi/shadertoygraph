{"ver":"0.1","info":{"id":"fdjSRR","date":"1619548898","viewed":66,"name":"Shadow Path","username":"Drysmall","description":"A narrow path full of shadow","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["cis561finalproject"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float findKernel(in float x, in float sigma){\n\treturn 0.4 * exp(-0.5*x*x / (sigma*sigma)) / sigma;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float kernels[11];\n    vec3 outputColor = vec3(0.);\n    float Z = 0.;\n\n    for (int j = 0; j <= 5; j++){\n        kernels[5+j] = findKernel(float(j), 20.);\n        kernels[5-j] = findKernel(float(j), 20.);\n    }\n    for (int j = 0; j < 11; j++){\n        Z += kernels[j];\n    }\n    for (int i = -5; i <= 5; i++){\n        for (int j = -5; j <= 5; j++){\n            outputColor += kernels[5+j] * kernels[5+i] * texture(iChannel0,\n                            (fragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 originalColor = texture(iChannel0, uv);\n    float vignette = smoothstep(1.4, 0., length((2. * uv) - vec2(1.)));\n\n    fragColor = mix(vec4(0.0, 0.0, 0.1, 1.0), vec4(mix(originalColor.rgb,\n                outputColor / (Z*Z), originalColor.a), 1.), vignette);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Intersection{\n    float t;\n    vec3 color;\n    vec3 position;\n    int objectIdx;\n};\n\nvec3 rotateAroundY(vec3 p, float a){\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane(vec3 pos, vec4 nor){\n  return dot(pos, nor.xyz) + nor.w;\n}\n\nvec2 planeUV(vec3 origin, vec3 nor, vec3 pos){\n    vec3 u = normalize(cross(vec3(0., 1., 0.), nor));\n    vec3 v = normalize(cross(nor, u));\n    return vec2(dot(pos - origin, u), dot(pos - origin, v));\n}\n\nfloat box(vec3 pos, vec3 b){\n  return length(max(abs(pos) - b, 0.0));\n}\n\nfloat sphere(vec3 pos, float radius, vec3 c){\n    return distance(pos, c) - radius;\n}\n\nfloat worleyNoise(vec2 uv) {\n    float result = 1.;\n    uv = uv * 0.3;\n\n    for(int x = -1; x < 2; x++) {\n        for(int y = -1; y < 2; y++) {\n            vec2 pos = floor(uv) + vec2(x, y);\n\t\t\tpos = 0.3 * sin(iTime + 5. * fract(sin(vec2(dot(pos, vec2(300., 300.)),\n                  dot(pos, vec2(100., 100.))))));\n            result = min(result, length(vec2(x, y) + pos - fract(uv)));\n        }\n    }\n    \n    return result;\n}\n\nconst int RAY_STEPS = 256;\nconst float FOVY = 3.141569 * 0.25;\nconst float OCCLUSION_DISTANCE = 0.15;\nconst float K_VALUE = 2.;\nconst float FOCAL_LENGTH = 28.0;\nconst float FOCAL_RANGE = 14.0;\n\nconst vec3 a = vec3(0.1, 0.3, 0.3);\nconst vec3 b = vec3(0.3, 0.5, 0.7);\nconst vec3 c = vec3(0.95, 0.95, 0.6);\nconst vec3 d = vec3(0.35, 0.5, 0.55);\n\nvec3 cosineColor(float t){\n    return a + b * cos(7. * (t * c + d));\n}\n\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.5))\n#define FLOOR_ID 0\n\n#define BODY_SDF box(pos + vec3(0., -1.5, -48. * (sin(0.5 * iTime)+1.)), vec3(1., 2., 1.))\n#define BODY_ID 1\n\n#define NECK_SDF box(pos + vec3(0., -4., -48. * (sin(0.5*iTime)+1.)), vec3(0.5, 0.8, 0.5))\n#define NECK_ID 2\n\n#define LEFTHAND_SDF box(pos + vec3(2., -2.5, -48. * (sin(0.5*iTime)+1.)), vec3(1., 0.3, 0.3))\n#define LEFTHAND_ID 3\n\n#define RIGHTHAND_SDF box(pos + vec3(-2., -2.5, -48. * (sin(0.5*iTime)+1.)), vec3(1., 0.3, 0.3))\n#define RIGHTHAND_ID 4\n\n#define LEFTLEG_SDF box(pos + vec3(-0.6, 1., -48. * (sin(0.5*iTime)+1.)), vec3(0.3, 1.5, 0.3))\n#define LEFTLEG_ID 5\n\n#define RIGHTLEG_SDF box(pos + vec3(0.6, 1., -48. * (sin(0.5*iTime)+1.)), vec3(0.3, 1.5, 0.3))\n#define RIGHTLEG_ID 6\n\n#define HEAD_SDF sphere(pos, 1.5, vec3(0., 5.5, 48. * (sin(0.5*iTime)+1.)))\n#define HEAD_ID 7\n\n#define LEFTWALL_SDF plane(pos + vec3(5.,0.,0.), vec4(1., 0., 0., 5.))\n#define LEFTWALL_ID 8\n\n#define RIGHTWALL_SDF plane(pos + vec3(-5.,0.,0.), vec4(-1.0, 0., 0., 5.))\n#define RIGHTWALL_ID 9\n\n#define FLOOR2_SDF plane(pos + vec3(0., 0., -100.), vec4(0.0, 0.87, -0.5, 2.5))\n#define FLOOR2_ID 10\n\n#define BACKWALL_SDF plane(pos + vec3(0., 0., -120.), vec4(0., 0., -1., 2.5))\n#define BACKWALL_ID 11\n\nfloat mySceneT(vec3 pos){\n    float t = FLOOR_SDF;\n    \n    t = min(t, BODY_SDF);\n    t = min(t, NECK_SDF);\n    t = min(t, LEFTHAND_SDF);\n    t = min(t, RIGHTHAND_SDF);\n    t = min(t, LEFTLEG_SDF);\n    t = min(t, RIGHTLEG_SDF);\n    t = min(t, HEAD_SDF);\n    t = min(t, LEFTWALL_SDF);\n    t = min(t, RIGHTWALL_SDF);\n    t = min(t, FLOOR2_SDF);\n    t = min(t, BACKWALL_SDF);\n    \n    return t;\n}\n\nvec3 computeNormal(vec3 pos){\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(mySceneT(pos + epsilon.yxx) - mySceneT(pos - epsilon.yxx),\n                          mySceneT(pos + epsilon.xyx) - mySceneT(pos - epsilon.xyx),\n                          mySceneT(pos + epsilon.xxy) - mySceneT(pos - epsilon.xxy)));\n}\n\nvoid myScene(vec3 pos, out float t, out int obj){\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    float tempT;\n\n    if ((tempT = BODY_SDF) < t){\n        t = tempT;\n        obj = BODY_ID;\n    }\n    if ((tempT = NECK_SDF) < t){\n        t = tempT;\n        obj = NECK_ID;\n    }\n    if ((tempT = LEFTHAND_SDF) < t){\n        t = tempT;\n        obj = LEFTHAND_ID;\n    }\n    if ((tempT = RIGHTHAND_SDF) < t){\n        t = tempT;\n        obj = RIGHTHAND_ID;\n    }\n    if ((tempT = LEFTLEG_SDF) < t){\n        t = tempT;\n        obj = LEFTLEG_ID;\n    }\n    if ((tempT = RIGHTLEG_SDF) < t){\n        t = tempT;\n        obj = RIGHTLEG_ID;\n    }\n    if ((tempT = HEAD_SDF) < t){\n        t = tempT;\n        obj = HEAD_ID;\n    }\n    if ((tempT = LEFTWALL_SDF) < t){\n        t = tempT;\n        obj = LEFTWALL_ID;\n    }\n    if ((tempT = RIGHTWALL_SDF) < t){\n        t = tempT;\n        obj = RIGHTWALL_ID;\n    }\n    if ((tempT = FLOOR2_SDF) < t){\n        t = tempT;\n        obj = FLOOR2_ID;\n    }\n    if ((tempT = BACKWALL_SDF) < t){\n        t = tempT;\n        obj = BACKWALL_ID;\n    }\n}\n\nvoid rayMarch(vec3 origin, vec3 dir, out float t, out int objHit){\n    t = 0.001;\n    \n    for (int i = 0; i < RAY_STEPS; i++){\n        float m;\n        vec3 pos = origin + t * dir;\n        \n        myScene(pos, m, objHit);\n        if (m < 0.01){\n            return;\n        }\n        t += m;\n    }\n    \n    t = -1.;\n    objHit = -1;\n}\n\nfloat myShadow(vec3 pos){\n    float t = BODY_SDF;\n    t = min(t, NECK_SDF);\n    t = min(t, LEFTHAND_SDF);\n    t = min(t, RIGHTHAND_SDF);\n    t = min(t, LEFTLEG_SDF);\n    t = min(t, RIGHTLEG_SDF);\n    t = min(t, HEAD_SDF);\n\n    return t;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float t_exp, float k){\n    float result = 1.;\n    float t = t_exp;\n    \n    for (int i = 0; i < RAY_STEPS; i++){\n        float m = myShadow(origin + t * dir);\n        \n        if (m < 0.0001){\n            return 0.;\n        }\n        \n        result = min(result, k * m / t);\n        t += m;\n    }\n\n    return result;\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 nor, float k){\n    float total_ambientOcclusion = 0.;\n    \n    for (float i = 0.; i < 5.; i++) {\n        total_ambientOcclusion += 1. / pow(2., i) * (i * OCCLUSION_DISTANCE\n                               - myShadow(pos + nor * i * OCCLUSION_DISTANCE));\n    }\n    \n    return 1. - k * total_ambientOcclusion;\n}\n\nfloat subsurface(vec3 lightDir, vec3 nor, vec3 view, float thickness){\n    float emittingLight = pow(clamp(dot(view, -lightDir-nor), 0., 1.), 0.) * 1.5;\n    float attenuation = max(0., dot(nor, lightDir) + dot(view, -lightDir));\n    return attenuation * (emittingLight + 0.5) * thickness;\n}\n\nvec3 computeMaterials(int objHit, vec3 pos, vec3 nor, vec3 lightVec, vec3 view, float thickness){\n    float lambert = dot(-lightVec, nor);\n    vec3 light = vec3(0.95, 0.95, 0.6);\n    float subsurfaceCoeff = subsurface(-lightVec, nor, view, thickness);\n    \n    switch (objHit){\n        case BODY_ID:\n        return vec3(1., 0., 0.) * lambert + subsurfaceCoeff * light;\n        break;\n        case NECK_ID:\n        return vec3(0.5, 0.5, 0.5) * lambert + subsurfaceCoeff * light;\n        break;\n        case LEFTHAND_ID:\n        return vec3(1., 0., 0.) * lambert + subsurfaceCoeff * light;\n        break;\n        case RIGHTHAND_ID:\n        return vec3(1., 0., 0.) * lambert + subsurfaceCoeff * light;\n        break;\n        case LEFTLEG_ID:\n        return vec3(1., 0., 0.) * lambert + subsurfaceCoeff * light;\n        break;\n        case RIGHTLEG_ID:\n        return vec3(1., 0., 0.) * lambert + subsurfaceCoeff * light;\n        break;\n        case HEAD_ID:\n        return vec3(0.5, 0.5, 0.5) * lambert + subsurfaceCoeff * light;\n        break;\n        case FLOOR_ID:\n        return cosineColor(0.1 + worleyNoise(planeUV(vec3(0.), vec3(0., 1., 1.), pos))) * lambert *\n               softShadow(-lightVec, pos, 1.0, 8.0) * light;\n        break;\n        case LEFTWALL_ID:\n        return 4. * vec3(1., 1., 1.) * lambert * softShadow(-lightVec, pos, 1.0, 10.0) * light;\n        break;\n        case RIGHTWALL_ID:\n        return 4. * vec3(1., 1., 1.) * lambert * softShadow(-lightVec, pos, 1.0, 10.0) * light;\n        break;\n        case FLOOR2_ID:\n        return 1.5 * vec3(1., 1., 1.) * lambert * softShadow(-lightVec, pos, 1.0, 8.0) * light;\n        break;\n        case BACKWALL_ID:\n        return 2.5 * vec3(1., 1., 1.) * lambert * softShadow(-lightVec, pos, 1.0, 8.0) * light;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n}\n\nIntersection sdf(vec3 dir, vec3 eye){\n    float t;\n    int objHit;\n    \n    rayMarch(eye, dir, t, objHit);\n\n    vec3 m_intersection  = eye + t * dir;\n    vec3 nor = computeNormal(m_intersection);\n    vec3 lightPos = vec3(0., 50., 80.* sin(iTime));\n    vec3 lightDir = normalize(m_intersection  - lightPos);\n    float intensity = 2.;\n    \n    vec3 color = intensity * computeMaterials(objHit, m_intersection , nor, lightDir,\n                 normalize(eye - m_intersection), ambientOcclusion(m_intersection, -nor, K_VALUE));\n\n    return Intersection(t, color, m_intersection, objHit);\n}\n\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc){\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    return normalize(ref + ndc.x * H + ndc.y * V - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 1, -30);\n    vec3 ref = vec3(0, -4, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    Intersection m_intersection = sdf(rayDir, eye);\n    \n    float distAlongCamZ = abs(dot(normalize(ref - eye), m_intersection.position-eye));\n    float realtimeFOCAL_LENGTH = FOCAL_LENGTH + 12. * sin(iTime);\n \n    fragColor = vec4(m_intersection.color,\n                pow(min(1., abs(distAlongCamZ - realtimeFOCAL_LENGTH) / FOCAL_RANGE), 0.5));\n}","name":"Buffer A","description":"","type":"buffer"}]}