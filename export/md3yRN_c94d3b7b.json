{"ver":"0.1","info":{"id":"md3yRN","date":"1694777115","viewed":48,"name":"Harmonic Interpolation","username":"chronos","description":"Harmonic interpolation based on the paper:\nHarmonic Interpolation, Bezier Curves and Trigonometric Interpolation\nby A. Hardy and W.-H. Steeb","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["curve","antialiased","interpolation","smooth","drawing","segment","harmonic","anti","aliased"],"hasliked":0,"parentid":"ctBfWR","parentname":"Smooth Curve Drawing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Based on the paper:\n    Harmonic Interpolation, Bezier Curves and Trigonometric Interpolation\n    by A. Hardy and W.-H. Steeb\n    http://www.znaturforsch.com/aa/v59a/s59a0591.pdf\n*/\n\n\n#define PI 3.14159265359\n\nconst int N = 4; // Number of control points\n\nfloat segment_sdf(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    \n    vec2 proj = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.) * ab + a;\n    \n    return distance(p, proj);\n}\n\n// eqn (16)\nfloat harmonic_sigma(float t, float n)\n{\n    float denom = n * sin(PI * t);\n    return abs(denom) > 1e-6 ? sin(PI * n * t) / denom: 1.;\n}\n\n// eqn (16)\nfloat harmonic_sigma_k(float t, float n, float k)\n{\n    return harmonic_sigma(t - k/n, n);\n}\n\n// eqn (24)\nfloat harmonic_xi(float t, float n)\n{\n    float denom = n * sin(PI * t);\n    return abs(denom) > 1e-6 ? sin(PI * t * (n - 1.)) / denom : (n-1.)/n;\n}\n\n// eqn (24) and (25)\nfloat harmonic_xi_k(float t, float n, float k)\n{\n    return (cos(PI * ( n * t - k)) / n) + harmonic_xi(t - k/n, n);\n}\n\n// eqn (25)\nvec2 harmonic_even(vec2[N] control_points, float t)\n{\n    vec2 result = vec2(0);\n    for(int k = 0; k < N; k++)\n        result += control_points[int(k)] * harmonic_xi_k(t, float(N), float(k));\n    return result;\n}\n\n// eqn (21)\nvec2 harmonic_odd(vec2[N] control_points, float t)\n{\n    vec2 result = vec2(0);\n    for(int k = 0; k < N; k++)\n        result += control_points[int(k)] * harmonic_sigma_k(t, float(N), float(k));\n    return result;\n}\n\n\n// If you need the general version, it would look something like this,\n// with appropriate changes to the harmonic even and harmonic odd functions.\nvec2 harmonic_interpolate(vec2[N] control_points, float t)\n{\n    return N % 2 == 0 ? \n        harmonic_even(control_points, t) :\n        harmonic_odd(control_points, t)  ;\n}\n\nfloat get_segment_alpha(vec2 p1, vec2 p2, vec2 p)\n{\n    float pix_size = 2. / iResolution.y;\n    float d = segment_sdf(p1, p2, p);\n    const float r = 0.01;\n    float alpha = smoothstep(r + 1.75*pix_size, r, d);\n    return alpha;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Mouse = length(iMouse.xy) < 10. ? (.5+.33*vec2(cos(iTime), sin(iTime)))*iResolution.xy : iMouse.xy;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*Mouse-iResolution.xy)/iResolution.y;\n\n    float pix_size = 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 a, b, c, d, p = uv;\n    a = vec2(-1.,0);\n    b = vec2(0,.5);\n    c = vec2(1.,0);\n    d = mouse;\n    \n    float num_segments = 100.;\n    float dt = 1./float(num_segments);\n    \n    float alpha = 0.;\n\n    // draw segments\n    vec2 control_points[N] = vec2[N](a, b, c, d);\n    for(float i = 0.; i < num_segments; i++)\n    {\n        float t = float(i) / num_segments;\n        vec2 p1 = harmonic_interpolate(control_points, t);\n        vec2 p2 = harmonic_interpolate(control_points, t+dt);\n        float new_alpha_ha = get_segment_alpha(p1, p2, p);\n        alpha = max(alpha, new_alpha_ha);\n    }\n    \n    vec3 segment_color = 2. * vec3(0.3,0.4,0.5);\n    color = mix(color, segment_color, alpha);\n\n    // draw dots\n    color = mix(color, vec3(1,0,0), smoothstep(pix_size, 0., distance(uv, a) - 0.015));\n    color = mix(color, vec3(0,0,1), smoothstep(pix_size, 0., distance(uv, b) - 0.015));\n    color = mix(color, vec3(0,1,0), smoothstep(pix_size, 0., distance(uv, c) - 0.015));\n    color = mix(color, vec3(1,1,1), smoothstep(pix_size, 0., distance(uv, d) - 0.015));\n\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}