{"ver":"0.1","info":{"id":"MtSfRK","date":"1516454352","viewed":5293,"name":"FixingPixelArtFast","username":"TimothyLottes","description":"CRT scalar optimized","likes":34,"published":1,"flags":0,"usePreview":1,"tags":["crt","scalar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//_____________________________/\\_______________________________\n//==============================================================\n//                      SETUP FOR CRTS\n//--------------------------------------------------------------\n// Example of integrating\n// What to do before including header (below)\n//==============================================================\n#define CRTS_DEBUG 1\n#define CRTS_GPU 1\n#define CRTS_GLSL 1\n//--------------------------------------------------------------\n//#define CRTS_2_TAP 1\n//--------------------------------------------------------------\n#define CRTS_TONE 1\n#define CRTS_CONTRAST 0\n#define CRTS_SATURATION 0\n//--------------------------------------------------------------\n#define CRTS_WARP 1\n//--------------------------------------------------------------\n// Try different masks\n//#define CRTS_MASK_GRILLE 1\n//#define CRTS_MASK_GRILLE_LITE 1\n//#define CRTS_MASK_NONE 1\n#define CRTS_MASK_SHADOW 1\n//--------------------------------------------------------------\n// Since shadertoy doesn't have sRGB textures\n// And we need linear input into shader\n// Don't do this in your code\nfloat FromSrgb1(float c){\n return (c<=0.04045)?c*(1.0/12.92):\n  pow(c*(1.0/1.055)+(0.055/1.055),2.4);}\n//--------------------------------------------------------------\nvec3 FromSrgb(vec3 c){return vec3(\n FromSrgb1(c.r),FromSrgb1(c.g),FromSrgb1(c.b));}\n//--------------------------------------------------------------\n// Scanline thinness\n//  0.50 = fused scanlines\n//  0.70 = recommended default\n//  1.00 = thinner scanlines (too thin)\n#define INPUT_THIN 0.70\n//--------------------------------------------------------------\n// Horizonal scan blur\n//  -3.0 = pixely\n//  -2.5 = default\n//  -2.0 = smooth\n//  -1.0 = too blurry\n#define INPUT_BLUR -2.5\n//--------------------------------------------------------------\n// Shadow mask effect, ranges from,\n//  0.25 = large amount of mask (not recommended, too dark)\n//  0.50 = recommended default\n//  1.00 = no shadow mask\n#define INPUT_MASK 0.5\n//--------------------------------------------------------------\n#define INPUT_X 128.0\n#define INPUT_Y 72.0\n//--------------------------------------------------------------\n// Setup the function which returns input image color\nvec3 CrtsFetch(vec2 uv){\n // For shadertoy, scale to get native texels in the image\n uv*=vec2(INPUT_X,INPUT_Y)/iChannelResolution[0].xy;\n // Move towards intersting parts\n uv+=vec2(0.5,0.5);\n // Non-shadertoy case would not have the color conversion\n return FromSrgb(texture(iChannel0,uv.xy,-16.0).rgb);}\n\n\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n//_______________________BEGIN_HEADER___________________________\n\n\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//\n//      [CRTS] PUBLIC DOMAIN CRT-STYLED SCALAR - 20180120b\n//\n//                      by Timothy Lottes\n//\n//\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                         WHAT'S NEW\n//\n//--------------------------------------------------------------\n// Evolution of prior shadertoy example\n//--------------------------------------------------------------\n// This one is semi-optimized\n//  - Less texture fetches\n//  - Didn't get to instruction level optimization\n//  - Could likely use texture fetch to generate phosphor mask\n//--------------------------------------------------------------\n// Added options to disable unused features\n//--------------------------------------------------------------\n// Added in exposure matching\n//  - Given scan-line effect and mask always darkens image\n//  - Uses generalized tonemapper to boost mid-level\n//  - Note this can compress highlights\n//  - And won't get back peak brightness\n//  - But best option if one doesn't want as much darkening\n//--------------------------------------------------------------\n// Includes option saturation and contrast controls\n//--------------------------------------------------------------\n// Added in subtractive aperture grille\n//  - This is a bit brighter than prior\n//--------------------------------------------------------------\n// Make sure input to this filter is already low-resolution\n//  - This is not designed to work on titles doing the following\n//     - Rendering to hi-res with nearest sampling\n//--------------------------------------------------------------\n// Added a fast and more pixely option for 2 tap/pixel\n//--------------------------------------------------------------\n// Improved the vignette when WARP is enabled\n//--------------------------------------------------------------\n// Didn't test HLSL or CPU options\n//  - Will incorportate patches if they are broken\n//  - But out of time to try them myself\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//          LICENSE = UNLICENSE (aka PUBLIC DOMAIN)\n//\n//--------------------------------------------------------------\n// This is free and unencumbered software released into the \n// public domain.\n//--------------------------------------------------------------\n// Anyone is free to copy, modify, publish, use, compile, sell, \n// or distribute this software, either in source code form or as\n// a compiled binary, for any purpose, commercial or \n// non-commercial, and by any means.\n//--------------------------------------------------------------\n// In jurisdictions that recognize copyright laws, the author or\n// authors of this software dedicate any and all copyright \n// interest in the software to the public domain. We make this\n// dedication for the benefit of the public at large and to the\n// detriment of our heirs and successors. We intend this \n// dedication to be an overt act of relinquishment in perpetuity\n// of all present and future rights to this software under \n// copyright law.\n//--------------------------------------------------------------\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\n// KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR \n// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT \n// OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n// DEALINGS IN THE SOFTWARE.\n//--------------------------------------------------------------\n// For more information, please refer to \n// <http://unlicense.org/>\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                           DEFINES\n//\n//--------------------------------------------------------------\n// CRTS_CPU - CPU code\n// CRTS_GPU - GPU code\n//--------------------------------------------------------------\n// CRTS_GLSL - GLSL\n// CRTS_HLSL - HLSL (not tested yet)\n//--------------------------------------------------------------\n// CRTS_DEBUG - Define to see on/off split screen\n//--------------------------------------------------------------\n// CRTS_WARP - Apply screen warp\n//--------------------------------------------------------------\n// CRTS_2_TAP - Faster very pixely 2-tap filter (off is 8)\n//--------------------------------------------------------------\n// CRTS_MASK_GRILLE      - Aperture grille (aka Trinitron)\n// CRTS_MASK_GRILLE_LITE - Brighter (subtractive channels)\n// CRTS_MASK_NONE        - No mask\n// CRTS_MASK_SHADOW      - Horizontally stretched shadow mask\n//--------------------------------------------------------------\n// CRTS_TONE       - Normalize mid-level and process color\n// CRTS_CONTRAST   - Process color - enable contrast control\n// CRTS_SATURATION - Process color - enable saturation control\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                          CPU CODE\n//\n//--------------------------------------------------------------\n// TODO: Actually test the CPU code ...\n//==============================================================\n#ifdef CRTS_CPU\n//_____________________________/\\_______________________________\n//==============================================================\n//                         PORTABILITY\n//==============================================================\n #ifndef CrtsPow\n  #define CrtsPow powf\n #endif\n//--------------------------------------------------------------\n #ifndef CRTS_RESTRICT\n  #define CRTS_RESTRICT _restrict\n #endif\n//--------------------------------------------------------------\n #ifndef CRTS_STATIC\n  #define CRTS_STATIC static\n #endif\n//_____________________________/\\_______________________________\n//==============================================================\n//              TONAL CONTROL CONSTANT GENERATION\n//--------------------------------------------------------------\n// Make sure to use same CRTS_MASK_* defines on CPU and GPU!!!!!\n//==============================================================\n CRTS_STATIC void CrtsTone(\n // Output 4 float array.\n float *CRTS_RESTRICT dst,\n // Increase contrast, ranges from,\n //  1.0 = no change\n //  2.0 = very strong contrast (over 2.0 for even more)\n float contrast,\n // Increase saturation, ranges from,\n //  0.0 = no change\n //  1.0 = increased contrast (over 1.0 for even more)\n float saturation,\n // Inputs shared between CrtsTone() and CrtsFilter()\n float thin,\n float mask){\n//--------------------------------------------------------------\n  #ifdef CRTS_MASK_NONE\n   mask=1.0f;\n  #endif\n//--------------------------------------------------------------\n  #ifdef CRTS_MASK_GRILLE_LITE\n   // Normal R mask is {1.0,mask,mask}\n   // LITE   R mask is {mask,1.0,1.0}\n   mask=0.5f+mask*0.5f;\n  #endif\n//--------------------------------------------------------------\n  float midOut=0.18f/((1.5f-thin)*(0.5f*mask+0.5f));\n   float pMidIn=CrtsPow(0.18f,contrast);\n   dst[0]= contrast;\n   dst[1]=((-pMidIn)+midOut)/((1.0f-pMidIn)*midOut);\n   dst[2]=((-pMidIn)*midOut+pMidIn)/(midOut*(-pMidIn)+midOut);\n   dst[3]=contrast+saturation;}\n#endif\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                          GPU CODE\n//\n//==============================================================\n#ifdef CRTS_GPU\n//_____________________________/\\_______________________________\n//==============================================================\n//                         PORTABILITY\n//==============================================================\n #ifdef CRTS_GLSL\n  #define CrtsF1 float\n  #define CrtsF2 vec2\n  #define CrtsF3 vec3\n  #define CrtsF4 vec4\n  #define CrtsFractF1 fract\n  #define CrtsRcpF1(x) (1.0/(x))\n  #define CrtsSatF1(x) clamp((x),0.0,1.0)\n//--------------------------------------------------------------\n  CrtsF1 CrtsMax3F1(CrtsF1 a,CrtsF1 b,CrtsF1 c){\n   return max(a,max(b,c));}\n #endif\n//==============================================================\n #ifdef CRTS_HLSL\n  #define CrtsF1 float\n  #define CrtsF2 float2\n  #define CrtsF3 float3\n  #define CrtsF4 float4\n  #define CrtsFractF1 frac\n  #define CrtsRcpF1(x) (1.0/(x))\n  #define CrtsSatF1(x) saturate(x)\n//--------------------------------------------------------------\n  CrtsF1 CrtsMax3F1(CrtsF1 a,CrtsF1 b,CrtsF1 c){\n   return max(a,max(b,c));}\n #endif\n//_____________________________/\\_______________________________\n//==============================================================\n//              TONAL CONTROL CONSTANT GENERATION\n//--------------------------------------------------------------\n// This is in here for rapid prototyping\n// Please use the CPU code and pass in as constants\n//==============================================================\n CrtsF4 CrtsTone(\n CrtsF1 contrast,\n CrtsF1 saturation,\n CrtsF1 thin,\n CrtsF1 mask){\n//--------------------------------------------------------------\n  #ifdef CRTS_MASK_NONE\n   mask=1.0;\n  #endif\n//--------------------------------------------------------------\n  #ifdef CRTS_MASK_GRILLE_LITE\n   // Normal R mask is {1.0,mask,mask}\n   // LITE   R mask is {mask,1.0,1.0}\n   mask=0.5+mask*0.5;\n  #endif\n//--------------------------------------------------------------\n  CrtsF4 ret;\n  CrtsF1 midOut=0.18/((1.5-thin)*(0.5*mask+0.5));\n  CrtsF1 pMidIn=pow(0.18,contrast);\n  ret.x=contrast;\n  ret.y=((-pMidIn)+midOut)/((1.0-pMidIn)*midOut);\n  ret.z=((-pMidIn)*midOut+pMidIn)/(midOut*(-pMidIn)+midOut);\n  ret.w=contrast+saturation;\n  return ret;}\n//_____________________________/\\_______________________________\n//==============================================================\n//                            MASK\n//--------------------------------------------------------------\n// Letting LCD/OLED pixel elements function like CRT phosphors\n// So \"phosphor\" resolution scales with display resolution\n//--------------------------------------------------------------\n// Not applying any warp to the mask (want high frequency)\n// Real aperture grille has a mask which gets wider on ends\n// Not attempting to be \"real\" but instead look the best\n//--------------------------------------------------------------\n// Shadow mask is stretched horizontally\n//  RRGGBB\n//  GBBRRG\n//  RRGGBB\n// This tends to look better on LCDs than vertical\n// Also 2 pixel width is required to get triad centered\n//--------------------------------------------------------------\n// The LITE version of the Aperture Grille is brighter\n// Uses {dark,1.0,1.0} for R channel\n// Non LITE version uses {1.0,dark,dark}\n//--------------------------------------------------------------\n// 'pos' - This is 'fragCoord.xy'\n//         Pixel {0,0} should be {0.5,0.5}\n//         Pixel {1,1} should be {1.5,1.5} \n//--------------------------------------------------------------\n// 'dark' - Exposure of of masked channel\n//          0.0=fully off, 1.0=no effect\n//==============================================================\n CrtsF3 CrtsMask(CrtsF2 pos,CrtsF1 dark){\n  #ifdef CRTS_MASK_GRILLE\n   CrtsF3 m=CrtsF3(dark,dark,dark);\n   CrtsF1 x=CrtsFractF1(pos.x*(1.0/3.0));\n   if(x<(1.0/3.0))m.r=1.0;\n   else if(x<(2.0/3.0))m.g=1.0;\n   else m.b=1.0;\n   return m;\n  #endif\n//--------------------------------------------------------------\n  #ifdef CRTS_MASK_GRILLE_LITE\n   CrtsF3 m=CrtsF3(1.0,1.0,1.0);\n   CrtsF1 x=CrtsFractF1(pos.x*(1.0/3.0));\n   if(x<(1.0/3.0))m.r=dark;\n   else if(x<(2.0/3.0))m.g=dark;\n   else m.b=dark;\n   return m;\n  #endif\n//--------------------------------------------------------------\n  #ifdef CRTS_MASK_NONE\n   return CrtsF3(1.0,1.0,1.0);\n  #endif\n//--------------------------------------------------------------\n  #ifdef CRTS_MASK_SHADOW\n   pos.x+=pos.y*3.0;\n   CrtsF3 m=CrtsF3(dark,dark,dark);\n   CrtsF1 x=CrtsFractF1(pos.x*(1.0/6.0));\n   if(x<(1.0/3.0))m.r=1.0;\n   else if(x<(2.0/3.0))m.g=1.0;\n   else m.b=1.0;\n   return m;\n  #endif\n }\n//_____________________________/\\_______________________________\n//==============================================================\n//                        FILTER ENTRY\n//--------------------------------------------------------------\n// Input must be linear\n// Output color is linear\n//--------------------------------------------------------------\n// Must have fetch function setup: CrtsF3 CrtsFetch(CrtsF2 uv)\n//  - The 'uv' range is {0.0 to 1.0} for input texture\n//  - Output of this must be linear color\n//--------------------------------------------------------------\n// SCANLINE MATH & AUTO-EXPOSURE NOTES\n// ===================================\n// Each output line has contribution from at most 2 scanlines\n// Scanlines are shaped by a windowed cosine function\n// This shape blends together well with only 2 lines of overlap\n//--------------------------------------------------------------\n// Base scanline intensity is as follows\n// which leaves output intensity range from {0 to 1.0}\n// --------\n// thin := range {thick 0.5 to thin 1.0}\n// off  := range {0.0 to <1.0}, \n//         sub-pixel offset between two scanlines\n//  --------\n//  a0=cos(min(0.5,     off *thin)*2pi)*0.5+0.5;\n//  a1=cos(min(0.5,(1.0-off)*thin)*2pi)*0.5+0.5;\n//--------------------------------------------------------------\n// This leads to a image darkening factor of roughly: \n//  {(1.5-thin)/1.0}\n// This is further reduced by the mask: \n//  {1.0/2.0+mask*1.0/2.0}\n// Reciprocal of combined effect is used for auto-exposure\n//  to scale up the mid-level in the tonemapper\n//==============================================================\n CrtsF3 CrtsFilter(\n//--------------------------------------------------------------\n  // SV_POSITION, fragCoord.xy\n  CrtsF2 ipos,\n//--------------------------------------------------------------\n  // inputSize / outputSize (in pixels)\n  CrtsF2 inputSizeDivOutputSize,     \n//--------------------------------------------------------------\n  // 0.5 * inputSize (in pixels)\n  CrtsF2 halfInputSize,\n//--------------------------------------------------------------\n  // 1.0 / inputSize (in pixels)\n  CrtsF2 rcpInputSize,\n//--------------------------------------------------------------\n  // 1.0 / outputSize (in pixels)\n  CrtsF2 rcpOutputSize,\n//--------------------------------------------------------------\n  // 2.0 / outputSize (in pixels)\n  CrtsF2 twoDivOutputSize,   \n//--------------------------------------------------------------\n  // inputSize.y\n  CrtsF1 inputHeight,\n//--------------------------------------------------------------\n  // Warp scanlines but not phosphor mask\n  //  0.0 = no warp\n  //  1.0/64.0 = light warping\n  //  1.0/32.0 = more warping\n  // Want x and y warping to be different (based on aspect)\n  CrtsF2 warp,\n//--------------------------------------------------------------\n  // Scanline thinness\n  //  0.50 = fused scanlines\n  //  0.70 = recommended default\n  //  1.00 = thinner scanlines (too thin)\n  // Shared with CrtsTone() function\n  CrtsF1 thin,\n//--------------------------------------------------------------\n  // Horizonal scan blur\n  //  -3.0 = pixely\n  //  -2.5 = default\n  //  -2.0 = smooth\n  //  -1.0 = too blurry\n  CrtsF1 blur,\n//--------------------------------------------------------------\n  // Shadow mask effect, ranges from,\n  //  0.25 = large amount of mask (not recommended, too dark)\n  //  0.50 = recommended default\n  //  1.00 = no shadow mask\n  // Shared with CrtsTone() function\n  CrtsF1 mask,\n//--------------------------------------------------------------\n  // Tonal curve parameters generated by CrtsTone()\n  CrtsF4 tone\n//--------------------------------------------------------------\n ){\n//--------------------------------------------------------------\n  #ifdef CRTS_DEBUG\n   CrtsF2 uv=ipos*rcpOutputSize;\n   // Show second half processed, and first half un-processed\n   if(uv.x<0.5){\n    // Force nearest to get squares\n    uv*=1.0/rcpInputSize;\n    uv=floor(uv)+CrtsF2(0.5,0.5);\n    uv*=rcpInputSize;\n    CrtsF3 color=CrtsFetch(uv);\n    return color;}\n  #endif\n//--------------------------------------------------------------\n  // Optional apply warp\n  CrtsF2 pos;\n  #ifdef CRTS_WARP\n   // Convert to {-1 to 1} range\n   pos=ipos*twoDivOutputSize-CrtsF2(1.0,1.0);\n   // Distort pushes image outside {-1 to 1} range\n   pos*=CrtsF2(\n    1.0+(pos.y*pos.y)*warp.x,\n    1.0+(pos.x*pos.x)*warp.y);\n   // TODO: Vignette needs optimization\n   CrtsF1 vin=1.0-(\n    (1.0-CrtsSatF1(pos.x*pos.x))*(1.0-CrtsSatF1(pos.y*pos.y)));\n   vin=CrtsSatF1((-vin)*inputHeight+inputHeight);\n   // Leave in {0 to inputSize}\n   pos=pos*halfInputSize+halfInputSize;     \n  #else\n   pos=ipos*inputSizeDivOutputSize;\n  #endif\n//--------------------------------------------------------------\n  // Snap to center of first scanline\n  CrtsF1 y0=floor(pos.y-0.5)+0.5;\n  #ifdef CRTS_2_TAP\n   // Using Inigo's \"Improved Texture Interpolation\"\n   // https://iquilezles.org/articles/texture\n   pos.x+=0.5;\n   CrtsF1 xi=floor(pos.x);\n   CrtsF1 xf=pos.x-xi;\n   xf=xf*xf*xf*(xf*(xf*6.0-15.0)+10.0);  \n   CrtsF1 x0=xi+xf-0.5;\n   CrtsF2 p=CrtsF2(x0*rcpInputSize.x,y0*rcpInputSize.y);     \n   // Coordinate adjusted bilinear fetch from 2 nearest scanlines\n   CrtsF3 colA=CrtsFetch(p);\n   p.y+=rcpInputSize.y;\n   CrtsF3 colB=CrtsFetch(p);\n  #else\n   // Snap to center of one of four pixels\n   CrtsF1 x0=floor(pos.x-1.5)+0.5;\n   // Inital UV position\n   CrtsF2 p=CrtsF2(x0*rcpInputSize.x,y0*rcpInputSize.y);     \n   // Fetch 4 nearest texels from 2 nearest scanlines\n   CrtsF3 colA0=CrtsFetch(p);\n   p.x+=rcpInputSize.x;\n   CrtsF3 colA1=CrtsFetch(p);\n   p.x+=rcpInputSize.x;\n   CrtsF3 colA2=CrtsFetch(p);\n   p.x+=rcpInputSize.x;\n   CrtsF3 colA3=CrtsFetch(p);\n   p.y+=rcpInputSize.y;\n   CrtsF3 colB3=CrtsFetch(p);\n   p.x-=rcpInputSize.x;\n   CrtsF3 colB2=CrtsFetch(p);\n   p.x-=rcpInputSize.x;\n   CrtsF3 colB1=CrtsFetch(p);\n   p.x-=rcpInputSize.x;\n   CrtsF3 colB0=CrtsFetch(p);\n  #endif\n//--------------------------------------------------------------\n  // Vertical filter\n  // Scanline intensity is using sine wave\n  // Easy filter window and integral used later in exposure\n  CrtsF1 off=pos.y-y0;\n  CrtsF1 pi2=6.28318530717958;\n  CrtsF1 hlf=0.5;\n  CrtsF1 scanA=cos(min(0.5,  off *thin     )*pi2)*hlf+hlf;\n  CrtsF1 scanB=cos(min(0.5,(-off)*thin+thin)*pi2)*hlf+hlf;\n//--------------------------------------------------------------\n  #ifdef CRTS_2_TAP\n   #ifdef CRTS_WARP\n    // Get rid of wrong pixels on edge\n    scanA*=vin;\n    scanB*=vin;\n   #endif\n   // Apply vertical filter\n   CrtsF3 color=(colA*scanA)+(colB*scanB);\n  #else\n   // Horizontal kernel is simple gaussian filter\n   CrtsF1 off0=pos.x-x0;\n   CrtsF1 off1=off0-1.0;\n   CrtsF1 off2=off0-2.0;\n   CrtsF1 off3=off0-3.0;\n   CrtsF1 pix0=exp2(blur*off0*off0);\n   CrtsF1 pix1=exp2(blur*off1*off1);\n   CrtsF1 pix2=exp2(blur*off2*off2);\n   CrtsF1 pix3=exp2(blur*off3*off3);\n   CrtsF1 pixT=CrtsRcpF1(pix0+pix1+pix2+pix3);\n   #ifdef CRTS_WARP\n    // Get rid of wrong pixels on edge\n    pixT*=vin;\n   #endif\n   scanA*=pixT;\n   scanB*=pixT;\n   // Apply horizontal and vertical filters\n   CrtsF3 color=\n    (colA0*pix0+colA1*pix1+colA2*pix2+colA3*pix3)*scanA +\n    (colB0*pix0+colB1*pix1+colB2*pix2+colB3*pix3)*scanB;\n  #endif\n//--------------------------------------------------------------\n  // Apply phosphor mask          \n  color*=CrtsMask(ipos,mask);\n//--------------------------------------------------------------\n  // Optional color processing\n  #ifdef CRTS_TONE\n   // Tonal control, start by protecting from /0\n   CrtsF1 peak=max(1.0/(256.0*65536.0),\n    CrtsMax3F1(color.r,color.g,color.b));\n   // Compute the ratios of {R,G,B}\n   CrtsF3 ratio=color*CrtsRcpF1(peak);\n   // Apply tonal curve to peak value\n   #ifdef CRTS_CONTRAST\n    peak=pow(peak,tone.x);\n   #endif\n   peak=peak*CrtsRcpF1(peak*tone.y+tone.z);\n   // Apply saturation\n   #ifdef CRTS_SATURATION\n    ratio=pow(ratio,CrtsF3(tone.w,tone.w,tone.w));\n   #endif\n   // Reconstruct color\n   return ratio*peak;\n #else\n  return color;\n #endif\n//--------------------------------------------------------------\n }\n#endif\n\n\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n//________________________END_HEADER____________________________\n\n\n//_____________________________/\\_______________________________\n//==============================================================\n//                    USE HEADER IN SHADER\n//--------------------------------------------------------------\n// Example of integrating\n// What to do after including header\n//==============================================================\n// Convert from linear to sRGB\n// Since shader toy output is not linear\nfloat ToSrgb1(float c){\n return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n//--------------------------------------------------------------\nvec3 ToSrgb(vec3 c){return vec3(\n ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n//--------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n fragColor.rgb=CrtsFilter(\n  fragCoord.xy,\n  vec2(INPUT_X,INPUT_Y)/iResolution.xy,\n  vec2(INPUT_X,INPUT_Y)*vec2(0.5,0.5),\n  1.0/vec2(INPUT_X,INPUT_Y),\n  1.0/iResolution.xy,\n  2.0/iResolution.xy,\n  INPUT_Y,\n  vec2(1.0/48.0,1.0/24.0),\n  INPUT_THIN,\n  INPUT_BLUR,\n  INPUT_MASK,\n  CrtsTone(1.0,0.0,INPUT_THIN,INPUT_MASK));\n // Shadertoy outputs non-linear color   \n fragColor.rgb=ToSrgb(fragColor.rgb);}","name":"Image","description":"","type":"image"}]}