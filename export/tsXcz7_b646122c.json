{"ver":"0.1","info":{"id":"tsXcz7","date":"1584399526","viewed":251,"name":"Foreign Planets","username":"rainaininn","description":"Implicit Surface\nBased off of the the \"Elevated coast\" project created by user guil https://www.shadertoy.com/view/4l23Rh","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["terrain","sea","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time -iTime\n\nfloat dh = 0.;\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\nfloat random(float x) {\n    return fract(sin(x) * 10000.);\n}\n\nfloat noise(in vec2 p){\n    return random(p.x + p.y * 10000.);\n}\n\nvec2 sw(vec2 p) { \n    return vec2(floor(p.x), floor(p.y)); \n}\n\nvec2 se(vec2 p) { \n    return vec2(ceil(p.x), floor(p.y));\n}\n\nvec2 nw(vec2 p) { \n    return vec2(floor(p.x), ceil(p.y)); \n}\n\nvec2 ne(vec2 p) {\n    return vec2(ceil(p.x), ceil(p.y));\n}\n\nfloat smoothNoise(vec2 p) {\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n        \n}\n\nvec3 noised(in vec2 p){//noise with derivatives\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\n\nfloat fbmabs( vec2 p ) { //S.Guillitte \n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(smoothNoise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;\n       \n\t}\n\treturn 1.-r*.5;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(smoothNoise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*(r-.2*iTime/(.1-f));\n\t}\n\treturn r/4.+.5;\n}\n\nfloat terrainIq( in vec2 x )//from IQ's Elevated : https://www.shadertoy.com/view/MdX3Rr\n{\n\tvec2  p = x;\n    float a = 0.0;\n    float b = 1.2;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn .3*a+.5;\n}\n\nfloat rocks(vec2 p){\n   return terrainIq(p);\n   //return fbmabs(p)*.5+.5;   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-rocks(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.3);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .25, //shading on mountain\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.01, 0.2);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 55.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nfloat Band(float t, float start,float end,float blur){\n    float step1 = smoothstep(start-blur,start+blur,t);\n    float step2 = smoothstep(end+blur,end-blur,t);\n    return step1*step2;\n}\n\nfloat Rectangle(vec2 uv,float left,float right,float bottom, float top, float blur){\n    float band1 = Band(uv.x,left,right,blur);\n    float band2 = Band(uv.y,bottom,top,blur);\n    return band1*band2;\n}\n\nvec3 light = vec3(-0.7, -0.2, .1);\nvec3 light_color = vec3(2.8,2.8,2.8);\n\nvec3 sphere = vec3(0, 0, 2); //3rd element means how into the screen it is\nvec3 sphere1 = vec3(0, 0, 3);\nfloat sphere_size = 0.4;\nvec3 sphere_color = vec3(1, 1, 1);\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\t//radius = radius * radius;\n\tfloat dt = dot(rdir, sp - rpos);\n\tif (dt < 0.0) {\n\t\treturn -1.0;\n\t}\n\tvec3 tmp = rpos - sp;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius) {\n\t\treturn -1.0;\n\t}\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 x = fragCoord.xy;\n\tvec3 a = vec3(max((fract(dot(sin(x),x))-.994)*80.,-.4));\n\t\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n    //vec3 col = vec3(0.,1.,0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 2.0, -2.+.3*time);\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n    \n    float t = march(ro, rd);\n    \n    //Added planet 1\n    vec3 point; \n\tvec3 normal;\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n    \n\tvec3 ray = vec3(uv.x+1., uv.y+.42, 1.0); //position\n\tray = normalize(ray);\n\tfragColor = vec4(0.5);\n\t\n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n\t\n\tif (dist > 0.0) {\n\t\tvec3 tmp = normalize(light - sphere);\n\t\tfloat u = atan(normal.z, normal.x) / 3.1415*2.0 + iTime / 5.0;\n\t\tfloat v = asin(normal.y) / 3.1415*2.0 + 0.5;\n\t\tfragColor.xyz = vec3(dot(tmp, normal)) * light_color * sphere_color * texture(iChannel0, vec2(u, v)).xyz;\n\t} \n    \n    // Planet 2\n    vec3 ray1 = vec3(uv.x-1.4, uv.y+.6, 1.0); //position\n    ray1 = normalize(ray1);\n    float dist1 = raySphere(vec3(0.0,0.,0.0), ray1, sphere1, sphere_size, point, normal);\n\n    if (dist1 > 0.0) {\n        vec3 tmp = normalize(light - sphere1);\n        float u = atan(normal.z, normal.x) / 3.1415*2.0 - iTime / 2.0;\n        float v = asin(normal.y) / 3.1415*2.0 + 0.5;\n        fragColor.xyz = vec3(dot(tmp, normal)) * light_color * sphere_color * texture(iChannel1, vec2(u, v)).xyz;\n    }\n    \n    if(t > -0.001 )\n    {\n        vec3 pos = ro + t * rd;\n        \n        float k=rocks(pos.xz)*2.2;\n        \n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li),0.1)/2.;\n        if(dh<0.&&dh>-.03)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<-0.02){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n            col1+=vec3(0.9,0.2,.05)*dh*0.4;\n        \tcol1 += pow(max(dot(li, nor), 0.0), 4.0)*vec3(.9);\n            \n        } \n\t    col = -0.4+col1;\n        \n\t}\n    else //sky\n    \tcol = a;\n    \n    float mask;\n    vec2 uv1 = fragCoord.xy/iResolution.xy;\n    uv1 -= .5;\n    uv1.x *= iResolution.x/iResolution.y;\n\n    mask = Rectangle(uv1,-.05,.05,-.05,.023,.06);\n    vec4 col2 = vec4(2.3,1.6,1.0,1.)*mask; \n\n   \tfragColor = vec4(fragColor.xyz,0.0) + col2 + vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}