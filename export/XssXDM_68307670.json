{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n\t@vec4 uniform =iDate\n;\n:m time iDate .w ;\n:m mtime iTime ;\n\n:m circle ( p r )\n\tp length r -\n;\n:m box ( p d )\n\t( p abs d - 0 max length )\n\tp abs d - =t\n\t\tt \\max 0 min\n\t\tt 0 max length\n\t+\n;\n:m roundbox ( p r d )\n\t p d box r -\n;\n\n: arc ( p:vec2 d:vec3 -> float )\n\t\tp [ -1 1 ] * cart->polar [ pi 2 / d .z ] - polar-norm\n\t\t[\n\t\t\td .x dup tau eps - - 0 1 clamp inf * +\n\t\t\td .y\n\t\t]\n\tbox\n;\n\n:m intersect \\max ;\n:m union \\min ;\n:m subtract \\{ neg max } ;\n\n:m repeat! ( p c ) p c mod .5 c * - ;\n:m repeat ( f p c ) p c repeat! dup p swap - *f ;\n:m scale ( f p s ) p s / *f s length * ;\n:m rotate ( f p a ) p a rotate-2d *f ;\n\n: distance-field ( p:vec2 -> vec4 )\n\ttime 60 mod floor 60 / =secondpos\n\ttime 60 / floor 60 mod 60 / secondpos 60 / + =minutepos\n\ttime 60 / 60 / floor 12 mod 12 / minutepos 60 / + =hourpos\n\n\t[\n\t\t[ p [ secondpos tau * .05 .5 ] arc 1 0 0 ]\n\t\t[ p [ minutepos tau * .05 .35 ] arc 0 1 0 ]\n\t\t[ p [ hourpos tau * .05 .2 ] arc 0 0 1 ]\n\t] { .x } amin\n;\n\n:m texture ( d p )\n\tp distance-field .yzw =mat\n\t[ d neg 200 * 0 1 clamp mat * ]\n;\n\niResolution frag->position =p\n[ p { distance-field .x } gradient p texture 1 ] =fragColor\n*/\n\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan((p).y, (p).x), length(p));\n}\nvec2 polar_norm(vec2 p) {\n\treturn vec2(mod(((p).x) + 6.28318, 6.28318), (p).y);\n}\nfloat arc(vec2 p, vec3 d) {\n\tvec2 t = (abs(polar_norm((cart_polar((p) * (vec2(-1.0, 1.0)))) - (vec2(1.570795, (d).z))))) - (vec2(((d).x) + ((clamp(((d).x) - 6.28317, 0.0, 1.0)) * 10000000.0), (d).y));\n\treturn (min(max((t).x, (t).y), 0.0)) + (length(max(t, 0.0)));\n}\nvec4 distance_field(vec2 p) {\n\tfloat secondpos = (floor(mod((iDate).w, 60.0))) / 60.0;\n\tfloat minutepos = ((mod(floor(((iDate).w) / 60.0), 60.0)) / 60.0) + ((secondpos) / 60.0);\n\tfloat hourpos = ((mod(floor((((iDate).w) / 60.0) / 60.0), 12.0)) / 12.0) + ((minutepos) / 60.0);\n\tvec4 macro_temp_6_a = vec4(arc(p, vec3((secondpos) * 6.28318, 0.05, 0.5)), 1.0, 0.0, 0.0);\n\tvec4 macro_temp_6_b = vec4(arc(p, vec3((minutepos) * 6.28318, 0.05, 0.35)), 0.0, 1.0, 0.0);\n\tfloat m = min((macro_temp_6_a).x, (macro_temp_6_b).x);\n\tmacro_temp_6_a = (((macro_temp_6_a).x) == (m)) ? (macro_temp_6_a) : (macro_temp_6_b);\n\tmacro_temp_6_b = vec4(arc(p, vec3((hourpos) * 6.28318, 0.05, 0.2)), 0.0, 0.0, 1.0);\n\tm = min((macro_temp_6_a).x, (macro_temp_6_b).x);\n\treturn (((macro_temp_6_a).x) == (m)) ? (macro_temp_6_a) : (macro_temp_6_b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (((((fragCoord).xy) / ((iResolution).xy)) * 2.0) - 1.0) * (vec2(1.0, ((iResolution).y) / ((iResolution).x)));\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 mat = (distance_field(p)).yzw;\n\tfragColor = vec4(vec3((clamp((- (((distance_field(p)).x) / (abs(length((vec2(((distance_field((p) + (h))).x) - ((distance_field((p) - (h))).x), ((distance_field((p) + ((h).yx))).x) - ((distance_field((p) - ((h).yx))).x))) / (2.0 * ((h).x))))))) * 200.0, 0.0, 1.0)) * (mat)), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssXDM","date":"1402368175","viewed":322,"name":"Daeclock 2","username":"daeken","description":"Another quick clock in Shaderforth","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["clock","shaderforth"],"hasliked":0,"parentid":"","parentname":""}}