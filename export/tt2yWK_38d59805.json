{"ver":"0.1","info":{"id":"tt2yWK","date":"1595420735","viewed":63,"name":"SimpleScene","username":"fayolle","description":"Simple CSG scene","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n// ----------------- code simple scene\nfloat sdDiff(float f1, float f2)\n{\n    return min(f1, -f2);\n}\n\nfloat cylinderX(in vec3 p, in vec3 c, float r)\n{\n    float dy, dz;\n    dy = p.y - c.y;\n    dz = p.z - c.z;\n    return r - sqrt(dy * dy + dz * dz);\n}\n\nfloat cylinderY(in vec3 p, in vec3 c, float r)\n{\n    float dx, dz;\n    dx = p.x - c.x;\n    dz = p.z - c.z;\n    return r - sqrt(dx * dx + dz * dz);\n}\n\nfloat cylinderZ(in vec3 p, in vec3 c, float r)\n{\n    float dx, dy;\n    dx = p.x - c.x;\n    dy = p.y - c.y;\n    return r - sqrt(dx * dx + dy * dy);\n}\n\n// unit cube centered at origin\nfloat cube(in vec3 p)\n{\n    vec3 pl = p + 0.5;\n    vec3 pr = 0.5 - p;\n    return min(min(min(pl.x, pr.x), min(pl.y, pr.y)), min(pl.z, pr.z));\n}\n\nfloat scene(in vec3 p)\n{\n    float cu = cube(p);\n    float cx = cylinderX(p, vec3(0.0, 0.0, 0.0), 0.25);\n    float cy = cylinderY(p, vec3(0.0, 0.0, 0.0), 0.25);\n    float cz = cylinderZ(p, vec3(0.0, 0.0, 0.0), 0.25);\n    return sdDiff(sdDiff(sdDiff(cu, cx), cy), cz);\n}\n\n// ----------------- end of code simple scene\n\n//------------------------------------------------------------------\n\nfloat map(in vec3 p)\n{\n    return -scene(p);\n}\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n    float res = -1.0;\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for (int i = 0; i < 70 && t < tmax; i++)\n    {\n        float h = map(ro + rd * t);\n        if (abs(h) < (0.0001 * t))\n        {\n            res = t;\n            break;\n        }\n        t += h;\n    }\n\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy) +\n                     e.yyx * map(pos + e.yyx) +\n                     e.yxy * map(pos + e.yxy) +\n                     e.xxx * map(pos + e.xxx));\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y, 0.0) * 0.3;\n    float t = castRay(ro, rd);\n\n    if (t != -1.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        col = 0.2 + 0.18 * sin(vec3(0.0, 0.5, 1.0));\n\n        vec3 lig = normalize(vec3(-0.5, 0.4, -0.6));\n        vec3 hal = normalize(lig - rd);\n        float amb = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.2, 0.2, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n                    dif *\n                    (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n        vec3 lin = vec3(0.0);\n        lin += 3.80 * dif * vec3(1.30, 1.00, 0.70);\n        lin += 0.55 * amb * vec3(0.40, 0.60, 1.15);\n        lin += 0.85 * dom * vec3(0.40, 0.60, 1.30);\n        lin += 0.55 * bac * vec3(0.25, 0.25, 0.25);\n        lin += 0.25 * fre * vec3(1.00, 1.00, 1.00);\n        col = col * lin;\n        col += 7.00 * spe * vec3(1.10, 0.90, 0.70);\n\n        col = mix(col, vec3(0.7, 0.7, 0.9), 1.0 - exp(-0.0001 * t * t * t));\n    }\n    else\n    {\n        col = vec3(1.0, 1.0, 1.0);\n    }\n\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 15.0 + iTime * 1.5;\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro = ta + vec3(2.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 2.5 * sin(0.1 * time + 6.0 * mo.x));\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 tot = vec3(0.0);\n#if AA > 1\n    for (int m = 0; m < AA; m++)\n        for (int n = 0; n < AA; n++)\n        {\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif\n\n            vec3 rd = ca * normalize(vec3(p, 2.5));\n            vec3 col = render(ro, rd);\n            col = pow(col, vec3(0.4545));\n            tot += col;\n#if AA > 1\n        }\n    tot /= float(AA * AA);\n#endif\n\n    fragColor = vec4(tot, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}