{"ver":"0.1","info":{"id":"wlySWd","date":"1603687750","viewed":87,"name":"Waves and Interference","username":"hhhzzzsss","description":"Ray-marched render of waves","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384\n\nvoid sinFunc3D(vec3 p, float freq, float amp, float phase, out float f, out vec3 df) {\n    float m = length(p.xz);\n    f = p.y-cos(freq*(m-phase))*amp*min(1.0, 5./m);\n    df.y = 1.0;\n    if (m == 0.0) {\n        df.x = 0.0;\n        df.z = 0.0;\n    }\n    else {\n        df.x = p.x/m;\n        df.z = p.z/m;\n        df.xz *= freq*sin(freq*(m-phase))*amp*min(1.0, 5./m);\n    }\n}\n\nfloat map(vec3 p) {\n    vec3 p1 = p-vec3(-5.0*PI,0.0,0.0);\n    vec3 p2 = p-vec3(5.0*PI,0.0,0.0);\n    float f1, f2;\n    vec3 df1, df2;\n    sinFunc3D(p1, 1.0, 2.0, 10.0*iTime, f1, df1);\n    sinFunc3D(p2, 1.0, 2.0, 10.0*iTime, f2, df2);\n    return (f1+f2)/length(df1+df2)/1.5;\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 e = vec2(0.0, 0.001);\n    vec3 n;\n    n.x = map(p+e.yxx) - map(p-e.yxx);\n    n.y = map(p+e.xyx) - map(p-e.xyx);\n    n.z = map(p+e.xxy) - map(p-e.xxy);\n    return normalize(n);\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n    float t = 0.001;\n    for (int i=0; i<1000; i++) {\n        float h = map(ro+t*rd);\n        if (abs(h)<0.0001*t)\n            return t;\n        t += 1.0*h;\n        if (t>1024.0) return -1.0;\n    }\n}\n\nfloat softShadow(vec3 ro, vec3 rd) {\n    float sha = 1.0;\n    float t = 0.01;\n    for (int i=0; i<256; i++) {\n    \tfloat h = map(ro+t*rd);\n        sha = min(sha, 2.0*h/t);\n        t += 1.0*clamp(h,0.02,0.20);\n        if (t>16.0) break;\n    }\n    sha = clamp(sha, 0.0, 1.0);\n    return sha*sha*(3.0-2.0*sha);\n}\n\nmat2 rotMat(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nfloat fresnel(vec3 inc, vec3 nor, float ior) {\n    float cosi = clamp(-1., 1., dot(inc, nor));\n    float n1, n2;\n    if (cosi < 0.0) {\n        n1 = 1.;\n        n2 = ior;\n        cosi = -cosi;\n    }\n    else {\n        n1 = ior;\n        n2 = 1.;\n    }\n    float sint = n1/n2 * sqrt(max(0., 1.-cosi*cosi));\n    if (sint>=1.0) {\n        return 1.0;\n    }\n    else {\n        float cost = sqrt(max(0., 1.-sint*sint));\n        float Rs = ((n1 * cosi) - (n2 * cost)) / ((n1 * cosi) + (n2 * cost));\n        float Rp = ((n2 * cosi) - (n1 * cost)) / ((n2 * cosi) + (n1 * cost));\n        return (Rs * Rs + Rp * Rp) / 2.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0,20.0,-20.0);\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.zy = rotMat(-0.8) * rd.zy;\n    \n    vec3 lig = normalize(vec3(0.5, 1.0, -0.5));\n    \n    float t = trace(ro,rd);\n    \n    vec3 skyCol = vec3(0.9,1.0,1.2);\n    float waterDepth = 2.0;\n    vec3 col;\n    if (t>=0.0) {\n    \tvec3 pos = ro + t*rd;\n    \tvec3 nor = getNorm(pos);\n        //float lig1 = max(dot(nor,lig),0.0);// * softShadow(pos,lig);\n        //float sky = 0.5 + 0.5*nor.y;\n        float spec = max(0.0, dot(reflect(rd, nor), lig));\n        float refl = fresnel(rd, nor, 1.33);\n        float refr = 1.0-refl;\n        vec3 refVec = refract(rd, nor, 1.0/1.33);\n        vec2 refFloorPos = refVec.xz / refVec.y * (pos.y+waterDepth) + pos.xz;\n        \n        //just to make sure floor doesn't clip into water surface. There will be obvious artifacts if it does.\n        if (pos.y+waterDepth<0.0) refFloorPos = vec2(0.0);\n        \n        spec = pow(spec, 50.0);\n        //col = vec3(0.0);\n        //col += vec3(0.6,0.6,0.5) * lig1;\n        //col += vec3(0.15,0.2,0.3) * sky;\n        //col *= vec3(0.2,0.26,0.3);\n        col += 1.0*texture(iChannel0, refFloorPos*0.03).xyz*0.9;\n        col += vec3(spec);\n        col *= refr;\n        col += refl*skyCol;\n    }\n    else {\n        col = skyCol;\n    }\n    \n    col = pow(col,vec3(0.45));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}