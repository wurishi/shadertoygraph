{"ver":"0.1","info":{"id":"dlf3zr","date":"1671274733","viewed":180,"name":"Magic Random Walk","username":"Amarcoli","description":"A random walk that never intersects itself but also magically never gets stuck!  Uses a winding-number method to avoid taking turns that will lead it into dead-ends.","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["random","walk","avoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// A magic random walk that never crosses itself, but also never gets stuck!  The walk will always\n// avoid taking a turn that would lead it down a dead-end, no matter how 'large' the trap might be.\n// Rather than trying to use a backtracking routine, the path uses winding number to determine whether\n// or not a turn would lead it to a closed loop or not.\n\n// First observation is that the walk can only get stuck when it reaches a wall.  It must turn either\n// right or left.  One direction will result in the walk getting stuck in the loop caused by the path\n// itself, the other will lead it to freedom.  By comparing the winding of the head of the walk to the\n// winding of the path, we can determine if the loop is on the left or right side of the path, and \n// choose the opposite direction.  The winding of the wall will always be within +/- 1 full turn, just\n// due to topological constraints.\n\n// The path is stored as a list in Buffer A, NOT a screen-space buffer. It is important to store the\n// path as a list rather than screen space to allow the path to go off-screen, as well as to grow\n// larger than the screen! This poses a challenge to render the path however, since we can only use\n// gather-style operations.  Buffer C implements the path \"rendering\", which converts the list representation\n// to a temporary screen-space representation.  The screen space representation is used for a lookup\n// by Buffer A to calculate the next move, and is also used to render the scene.\n\n// Buffer C uses an important optimization to enable rendering of the entire list for a reasonable cost.\n// Naive implementation would have each pixel scan the entire list to see if *any* segment in the list\n// overlaps the pixel, but this is very expensive.  The path can reach 512*512 segments in length!\n// However, neighboring segments in the list are adjacent in screen-space, so we can use this info to\n// skip ahead by large number of steps.  For each segment we test, we calculate manhattan distance to\n// that segment, and skip ahead by that many elements in the list.  This gives a very significant \n// speedup, and allows us to render very large paths!\n\n// First buffer contains the path encoded as a sequence of coordinates\n// Second buffer calculates camera position (feel bad using an entire buffer!)\n// Third buffer bakes path into screen-space buffer for first buffer logic and main image rendering\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 cameraOffset = texture(iChannel2, vec2(0.5, 0.5) / iResolution.xy).zw;\n \n    vec2 uv = (fragCoord / 3.0 + cameraOffset + iResolution.xy / 3.0) / iResolution.xy;\n    \n    vec2 uvXP = uv + vec2(+1.0, 0.0) / iResolution.xy / 3.0;\n    vec2 uvXN = uv + vec2(-1.0, 0.0) / iResolution.xy / 3.0;\n    vec2 uvYP = uv + vec2(0.0, +1.0) / iResolution.xy / 3.0;\n    vec2 uvYN = uv + vec2(0.0, -1.0) / iResolution.xy / 3.0;\n    vec2 uvYN2 = uv + vec2(-1.0, +2.0) / iResolution.xy / 3.0;\n    \n    vec4 result = texture(iChannel0, uv);\n    \n    vec4 resultXP = texture(iChannel0, uvXP);\n    vec4 resultXN = texture(iChannel0, uvXN);\n    vec4 resultYP = texture(iChannel0, uvYP);\n    vec4 resultYN = texture(iChannel0, uvYN);\n    vec4 resultYN2 = texture(iChannel0, uvYN2);\n    \n    bool shouldDraw = abs(result.b - resultXP.b) < 1.5 &&\n                      abs(result.b - resultXN.b) < 1.5 &&\n                      abs(result.b - resultYP.b) < 1.5 &&\n                      abs(result.b - resultYN.b) < 1.5;\n                      \n    bool isBlack = resultXP.b > 0.5 ||\n                   resultXN.b > 0.5 ||\n                   resultYP.b > 0.5 ||\n                   resultYN.b > 0.5 ||\n                   resultYN2.b > 0.5;\n    \n    \n    fragColor = vec4(abs(result.gggg)) / vec4(64.0, 512.0, 8.0, 1.0);\n    \n    //Visualize number of steps taken by Buffer C to calculate path\n    //return;\n    \n    if(!shouldDraw || result.b < 0.5) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        fragColor += 0.85 - 0.01 * vec4(pow(abs(result.g), 0.8));\n        if(isBlack) fragColor = vec4(0.0);\n        \n        fragColor -= vec4(8.0) / pow(3.0 + resultYN2.a, 2.8);\n        \n        fragColor += rand(round(fragCoord / 3.0 + texture(iChannel2, vec2(0.5, 0.5) / iResolution.xy).xy)) * 0.05;\n    } else {\n        float glow = (1.0 - clamp(result.b / 100.0, 0.0, 1.0)) * 0.75 +\n                     (1.0 - clamp(result.b / 9900.0, 0.0, 1.0)) * 0.25 +\n                     0.15;\n        float hue = clamp(fract((result.b - float(iFrame)) / 900.0), 0.0, 1.0);\n        \n        fragColor = vec4(hsv2rgb(vec3(hue, clamp(0.5 - glow, 0.0, 1.0), clamp(glow + 0.4, 0.0, 1.0))), 1.0);\n    }\n    \n    //fragColor += 0.85 - 0.01 * vec4(pow(abs(result.g), 0.8));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//Channels\n//RG=position\n//B=winding\n//A=hasbeeninit\n\nvec4 getWallAt(vec2 cell, int historyCount, vec4 localHistory[STEP_COUNT]) {\n    for(int i=0; i<historyCount; i++) {\n        if(floor(localHistory[i].xy) == floor(cell)) {\n            return localHistory[i].zwww;\n        }\n    }\n    \n    vec2 centerCell = floor(iResolution.xy / 2.0) + vec2(0.5, 0.5);\n    return texture(iChannel1, (cell + centerCell) / iResolution.xy);\n}\n\nbool tryAddChoice(vec2 posDelta, \n                  float winding, \n                  float turn,\n            inout int numChoices, \n            inout vec3 choices[3],\n            inout int historyCount,\n            inout vec4 localHistory[STEP_COUNT]) {\n    float newWinding = winding + turn;\n    vec2 dir = vec2(cos(newWinding * PI * 0.5), sin(newWinding * PI * 0.5));\n    vec2 norm = vec2(-dir.y, dir.x);\n    \n    vec4 nextCell = getWallAt(posDelta + dir, historyCount, localHistory);\n    if(nextCell.g > 0.0) {\n        //Trivial reject, space ahead is filled\n        return false;\n    }\n    \n    for(int j=-1; j<=1; j++) {\n        vec4 leftCell = getWallAt(posDelta + norm + dir * float(j), historyCount, localHistory);\n        if((leftCell.g > 0.0) &&\n           ((leftCell.r - newWinding) > 3.5)) {\n            return false;   \n        }\n        \n        vec4 rightCell = getWallAt(posDelta - norm + dir * float(j), historyCount, localHistory);\n        if((rightCell.g > 0.0) &&\n           ((rightCell.r - newWinding) < -3.5)) {\n            return false;   \n        }\n    }\n    \n    choices[numChoices] = vec3(dir, turn);\n    numChoices++;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec2 segmentPos = color.xy;\n    float winding = color.b;\n    float hasInit = color.a;\n    \n    float index = uv2Index(fragCoord);\n    bool isRelevant = fragCoord.x < SQUARE && fragCoord.y < SQUARE;\n    bool isHead = fragCoord.x < float(STEP_COUNT) && fragCoord.y < 1.0;\n    \n    if (hasInit == 0.0) {\n      if (isRelevant) {\n          segmentPos = vec2(-1, 0) * uv2Index(fragCoord) + vec2(0.5, 0.5);\n          hasInit = 1.0;\n          winding = 0.0;\n      } else {\n          segmentPos = vec2(0.0, 0.0);\n          hasInit = 0.1;\n          winding = 0.0;\n      }\n    } else if(isRelevant) {\n      if(isHead) {\n          int steps = STEP_COUNT - int(fragCoord.x);\n          \n          color = texture(iChannel0, vec2(0.5, 0.5)/iResolution.xy);\n          segmentPos = color.xy;\n          winding = color.b;\n          hasInit = color.a;\n          \n          vec2 originalPos = segmentPos;\n          \n          vec3 choices[3];\n          vec4 localHistory[STEP_COUNT];\n          int historyCount = 0;\n          \n          for(int i=0; i<steps; i++) {\n              vec2 dir = vec2(cos(winding * PI * 0.5), sin(winding * PI * 0.5));\n              segmentPos += dir;\n\n              int numChoices = 0;\n\n              tryAddChoice(segmentPos - originalPos, winding, 1.0, numChoices, choices, historyCount, localHistory); \n              tryAddChoice(segmentPos - originalPos, winding, 0.0, numChoices, choices, historyCount, localHistory);\n              tryAddChoice(segmentPos - originalPos, winding, -1.0, numChoices, choices, historyCount, localHistory);\n\n              float seed = sin(float(iFrame)) + cos(float(i));\n              float r = rand(vec2(seed, seed * 3.0));\n\n              r *= float(numChoices);\n\n              vec3 choice = choices[int(r)];\n\n              winding += choice.z;\n              \n              localHistory[historyCount] = vec4(segmentPos - originalPos, winding, hasInit);\n              historyCount++;\n          }\n      } else {\n          float nextIndex = uv2Index(fragCoord) - float(STEP_COUNT);\n          vec2 nextUv = index2Uv(nextIndex);\n          \n          vec4 nextColor = texture(iChannel0, nextUv/iResolution.xy);\n          segmentPos = nextColor.xy;\n          winding = nextColor.z;\n      }\n    }\n    \n    \n    fragColor = vec4(segmentPos, winding, hasInit);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 cameraPos = texture(iChannel1, fragCoord / iResolution.xy).xy;\n    vec2 headPos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xy;\n    \n    for(int i=0; i<STEP_COUNT; i++) {\n    cameraPos = mix(cameraPos, headPos, 0.01);\n    }\n    \n    fragColor = vec4(cameraPos, cameraPos - headPos);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 headPosition = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xy;\n    vec2 localCell = floor(fragCoord) - floor(iResolution.xy / 2.0) + headPosition;\n\n    float approxMinDist = 10000.0;\n\n    float spawned = min(SQUARE*SQUARE, float(iFrame * STEP_COUNT));\n    float steps = 0.0;\n    for(float i=0.0; i<spawned;) {\n        vec2 uv = index2Uv(i);\n        \n        vec4 color = texture(iChannel0, uv / iResolution.xy);\n        steps++;\n        \n        vec2 segmentPos = color.xy;\n        vec2 delta = segmentPos - localCell;\n        \n        float manhattenDist = abs(delta.x) + abs(delta.y);\n        \n        if (manhattenDist < 0.8) {\n            float winding = color.b;\n            fragColor = vec4(winding, steps, i, 0.0);\n            return;\n        } else {\n            //Neighboring points in the list are adjacent to each other, and so IF there is a\n            //point at fragCoord it must be at LEAST manhatten distance indices away, we can\n            //skip lots of points as an optimization!\n            i += max(1.0, floor(manhattenDist));\n        }\n        \n        approxMinDist = min(approxMinDist, sqrt(dot(delta, delta)));\n    }\n    \n    fragColor = vec4(0.0, -steps, 0.0, approxMinDist);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SQUARE 256.0\n#define PI 3.141592653589793238462643383279\n\n//Keep at 1 for now, higher values not working!\n#define STEP_COUNT 1\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 index2Uv(float index) {\n    return vec2(fract(index / SQUARE) * SQUARE + 0.5,\n                floor(index / SQUARE) + 0.5);\n}\n\nfloat uv2Index(vec2 uv) {\n    return floor(uv.x) + \n           floor(uv.y) * SQUARE;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Common","description":"","type":"common"}]}