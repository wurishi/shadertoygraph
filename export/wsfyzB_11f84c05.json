{"ver":"0.1","info":{"id":"wsfyzB","date":"1585167026","viewed":210,"name":"Exponential Regression","username":"harry7557558","description":"Fitting the number of COVID-19 daily reported cases in four countries using regression. Click and drag to read the value.\n\nAny idea about how can I make the compilation faster?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["leastsquare","coronavirus","covid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// COVID-19 daily reported cases since Mar.1\n// Data source: https://www.worldometers.info/coronavirus/\n#define N 26\nint US[N] = int[N](75,100,124,158,221,319,435,541,704,994,1301,1697,2247,2943,3680,4663,6411,9259,13789,19383,24207,33566,43734,54856,68211,85435);  // US\nint IT[N] = int[N](1701,2036,2502,3089,3858,4636,5883,7375,9172,10149,12462,15113,17660,21157,24747,27980,31506,35713,41035,47021,53578,59138,63927,69176,74386,80589);  // IT\nint ES[N] = int[N](84,120,165,228,282,401,525,674,1231,1695,2277,3146,5232,6391,7988,9942,11826,14769,18077,21571,25496,28768,35136,42058,49515,57786);  // ES\nint DE[N] = int[N](130,165,203,262,545,670,800,1040,1224,1565,1966,2745,3675,4599,5813,7272,9367,12327,15320,19848,22364,24873,29056,32991,37323,43938);  // DE\n//int FR[N] = int[N](130,191,212,285,423,653,949,1209,1412,1784,2281,2876,3661,4499,5423,6633,7730,9134,10995,12612,14459,16018,19856,22304,25233,29155);  // FR\n//int GB[N] = int[N](36,39,51,87,116,164,209,278,321,383,460,590,798,1140,1391,1543,1950,2626,3269,3983,5018,5683,6650,8077,9529,11658);  // UK\n\n\n\n/*================================ Fitting Code ================================*/\n\n// linear and quadratic regression\n#define LinearReg float m=1.0/(s*sx2-sx*sx); a=m*(s*sxy-sx*sy), b=m*(sx2*sy-sx*sxy);\n#define QuadReg float r0=sx2*s-sx*sx,r1=sx3*s-sx*sx2,r2=sx3*sx-sx2*sx2,r21=sx4*sx-sx2*sx3,m=1.0/(sx4*r0-sx3*r1+sx2*r2); a=(sx2y*r0-sxy*r1+sy*r2)*m, b=-(sx2y*r1-sxy*(sx4*s-sx2*sx2)+sy*r21)*m, c=(sx2y*r2-sxy*r21+sy*(sx4*sx2-sx3*sx3))*m;\n\n//#define Z min(0,iFrame)\n#define Z 0\n\n// Method 1: y = exp(ax+b), minimum Σ [ln(y)-(ax+b)]²\nvoid fitLinear(in int[N] Y, out float a, out float b){\n\tfloat s = float(N), sx = .5*s*(s-1.), sx2 = sx*(2.*s-1.)/3.,\n        sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat y = log(float(Y[i]));\n\t\tsy += y, sxy += float(i)*y;\n\t}\n\tLinearReg\n}\n\n// Method 2: y = exp(ax+b), minimum Σ y·[ln(y)-(ax+b)]²\nvoid fitLinear_S(in int[N] Y, out float a, out float b){\n\tfloat s = 0., sx = 0., sx2 = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), ey = float(Y[i]), y = log(ey);\n\t\tsx2 += x*x*ey, sx += x*ey, s += ey, sxy += x*y*ey, sy += y*ey;\n\t}\n\tLinearReg\n}\n\n// Method 3: y = exp(ax²+bx+c), minimum Σ [ln(y)-(ax²+bx+c)]²\nvoid fitQuadratic(in int[N] Y, out float a, out float b, out float c){\n\tfloat s=float(N), sx=.5*s*(s-1.), sx2=sx*(2.*s-1.)/3., sx3=sx*sx, sx4=.2*sx2*(s*(s-1.)*3.-1.),\n        sx2y = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), y = log(float(Y[i]));\n\t\tsx2y += x*x*y, sxy += x*y, sy += y;\n\t}\n    QuadReg\n}\n\n// Method 4: y = exp(ax²+bx+c), minimum Σ y·[ln(y)-(ax²+bx+c)]²\nvoid fitQuadratic_S(in int[N] Y, out float a, out float b, out float c){\n\tfloat s = 0., sx = 0., sx2 = 0., sx3 = 0., sx4 = 0., sx2y = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), e = float(Y[i]), y = log(e), x2 = x*x;\n\t\tsx4 += x2*x2*e, sx3 += x2*x*e, sx2 += x2*e, sx += x*e, s += e;\n\t\tsx2y += x2*y*e, sxy += x*y*e, sy += y*e;\n\t}\n    QuadReg\n}\n\n// Method 4 should work best, but I don't think it can\n// be used for prediction because quadratic functions don't converge\n\n\n\n/*================================ Visualizing Code ================================*/\n\n#define res iResolution.xy\n#define Clamp(x) clamp(x,0.,1.)\n#define length2(p) dot(p,p)\n#define S sqrt(res.x*res.y)\n\n#define W 30.\n#define H 100000.\n#define SW (W/res.x)\n#define SH (res.y/H)\n\nvoid drawData(in int[N] K, vec3 bcol, vec2 p, inout vec3 col){\n    float a, b, c;\n    float x = p.x*SW, y, dy, sd;\n    // linear regression for log\n    fitLinear(K, a, b);\n    y = exp(a*x+b)*SH, dy = a*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, bcol, 0.02*(1.-Clamp(sd-.010*S)));\n    // weighted linear regression for log\n    fitLinear_S(K, a, b);\n    y = exp(a*x+b)*SH, dy = a*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, mix(bcol,vec3(1.2),0.2), 0.2*(1.-Clamp(sd-.006*S)));\n    // quadratic regression for log\n    fitQuadratic(K, a, b, c);\n    y = exp((a*x+b)*x+c)*SH, dy = (2.*a*x+b)*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, bcol, 0.04*(1.-Clamp(sd-.008*S)));\n    // weighted quadratic regression for log\n    fitQuadratic_S(K, a, b, c);\n    y = exp((a*x+b)*x+c)*SH, dy = (2.*a*x+b)*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, mix(bcol,vec3(1.5),0.2), 0.8*(1.-Clamp(sd-.0045*S)));\n    // data points\n    sd = 1e8;\n    for (int i=0; i<N; i++){\n        vec2 q = vec2(i,K[i])*res/vec2(W,H);\n        sd = min(sd,length2(p-q));\n    }\n    col = mix(bcol, col, Clamp(sqrt(sd)-.008*S));\n}\n\n// distance to fitted curve\nfloat dist(in int[N] K, vec2 p) {\n    float a,b,c; fitQuadratic_S(K,a,b,c);\n    float x=p.x*SW, y=exp((a*x+b)*x+c)*SH, dy=(2.*a*x+b)*SW*y;\n    return y>res.y?res.y:abs(y-p.y)/sqrt(dy*dy+1.0);\n}\n\n#define _(c) T+=u.x<.0||u.x>1.||u.y<0.||u.y>1.?vec4(0):textureGrad(iChannel0,u/16.+fract(vec2(c,15-(c)/16)/16.),dFdx(u/16.),dFdy(u/16.));u.x-=.5;\nfloat text(vec2 p, int d, int n) {\n    vec4 T = vec4(0);\n    vec2 u = p-vec2(0,.5); _(77)_(97)_(114)_(46)_(d/10+48)_(d%10+48);\n    u = p+vec2(0,.5); _(n/10000+48)_(46)_(n/1000%10+48)_(n/100%10+48)_(107)_(32);\n    return T.w==0.?-1.:T.x;\n}\n\n#define pad 0.1\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 p = (1.0+2.*pad)*(coord-0.5*res);\n    vec3 col = max(abs(p.x)-.5*res.x,abs(p.y)-.5*res.y)>0. ? vec3(0.9) : vec3(1.0);\n    p+=0.5*res;\n    if (iMouse.z>0.) {\n        // initial and current mouse position\n        vec2 mp = (1.+2.*pad)*iMouse.zw-pad*res;\n        vec2 ms = (1.+2.*pad)*iMouse.xy-pad*res;\n        // find the curve that is closest to the initial mouse position\n        int K[N]; float d, md=1e9;\n        if ((d=dist(US,mp))<md){md=d; K=US;}\n        if ((d=dist(IT,mp))<md){md=d; K=IT;}\n        if ((d=dist(ES,mp))<md){md=d; K=ES;}\n        if ((d=dist(DE,mp))<md){md=d; K=DE;}\n        // visualize that curve\n        drawData(K,vec3(1,.5,0),p,col);  // fitting curve\n        col = mix(vec3(1,0,1),col,Clamp(abs(ms.x-p.x)-0.0005*S));  // vertical line\n        float a,b,c; fitQuadratic_S(K,a,b,c);  // curve params\n        vec2 I; I.x=ms.x, I.y=exp((a*SW*I.x+b)*I.x*SW+c)*SH;  // value point\n        col = mix(vec3(1,0,0),col,Clamp(length(I-p)-0.01*S));  // render value point\n        if (I.x>0.&&I.x<res.x&&I.y>0.&&I.y<res.y){  // render text\n            vec2 T = I-vec2(-5,10);\n            float c = text(25.*(p-I)/S+vec2(-.3,.2), int(W*I.x/res.x)+1, int(I.y/SH));\n            if (c>=0.) col = mix(mix(col,vec3(.8),0.7),vec3(0),c);\n        }\n    }\n    else {\n    \tdrawData(DE,vec3(.84,.0,.0),p,col);\n    \tdrawData(ES,vec3(.78,.37,.0),p,col);\n    \tdrawData(IT,vec3(.0,.55,.25),p,col);\n    \tdrawData(US,vec3(.25,.25,.4),p,col);\n    }\n    color = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}