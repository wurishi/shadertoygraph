{"ver":"0.1","info":{"id":"Mcl3Wn","date":"1703443057","viewed":42,"name":"Sine bud","username":"ChunderFPV","description":"It's easier & less glitchy to make these shapes using other means, but I wanted to do it with polar transformed sine waves.  It's similar to a rhombic dodeca.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","wave","flower","sine","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define A(v) mat2(cos(m.v+radians(vec4(0, -90, 90, 0))))         // rotate\n#define W(v) length(vec3(p.v-abs(sin(p.x+vec2(0, pi_2))), 0))    // wave\n#define T(v) vec3(atan(v.x, v.y), length(v.xy), sqrt(abs(v.z)))  // polar transform\n#define S(v) length(abs(p)-v)-.07 // spheres\n#define K min(W(yz), W(zy))  // quick double wave\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float pi = 3.1416,\n          pi2 = pi*2.,\n          pi_2 = pi/2.,\n          t = iTime/5.,\n          s = 1., d = 0., i = d;\n    \n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-.5*R)/R.y*4.;\n    \n    vec3 o = vec3(0, 0, -40), // cam\n         u = normalize(vec3((U-.5*R)/R.y, 10)),\n         a = vec3(1, 0, 0),\n         c = vec3(0, 1, 2)*length(u.xy), \n         k = c, p, q;\n    \n    if (iMouse.z < 1.) m = -vec2(t-pi_2/2., .6);\n    mat2 v = A(y), h = A(x); // pitch & yaw\n    \n    for (; i++< 200.;) // raymarch\n    {\n        p = o+u*d;\n        p.yz *= v;\n        p.xz *= h;\n        p.xyz = abs(p.xyz) - cos(t+pi)*.5-.5; // clone\n        s = min(s, min(min( \n            S(a.xyy), // axis spheres\n            S(a.yxy)), \n            S(a.yyx)));\n        q = p;\n        p = T(q);     k.x = K;\n        p = T(q.yzx); k.y = K;\n        p = T(q.zxy); k.z = K;\n        s = min(s, min(k.z, min(k.x, k.y)));\n        if (s < .001 || d > 100.) break;\n        d += s*.3;\n    }\n    c += max(cos(d*pi2) - s*sqrt(d)-k, 0.);\n    \n    C = vec4(c + c.brg + c*c, 1);\n}","name":"Image","description":"","type":"image"}]}