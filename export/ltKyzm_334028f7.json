{"ver":"0.1","info":{"id":"ltKyzm","date":"1538425193","viewed":821,"name":"Another raytracer","username":"dust","description":"*Finally* writing a normal analytic raytracer and working my way through PBR specular reflection/refraction.\nTap spacebar to restart the renderer, arrow keys + left shift/control to move.\nMost settings in Buffer A, starting camera position in Buffer D.","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["procedural","raytracing","reflection","analytical","pbr","ggx","transmission","smith"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRIGHTEN 1.0f\n#define TONEMAPP\nvec4 HDR(vec4 rgba) \n{\n    vec4 hdr = max(vec4(0.0f), rgba - vec4(0.004f));\n    return (hdr * (vec4(6.2f) * hdr + vec4(0.5f))) / \n           (hdr * (vec4(6.2f) * hdr + vec4(1.7f)) + vec4(0.06f));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Output filtered pixel color, optionally tonemap\n    // with Hejl and Burgess-Dawson HDR\n    vec4 rgba = texture(iChannel0, uv);\n    #ifdef TONEMAPP\n    \tfragColor = HDR((rgba / rgba.a) * BRIGHTEN);\n    #else\n    \tfragColor = (rgba / rgba.a) * BRIGHTEN;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Small #define for the circular constant [pi]\n#define PI 3.14159f\n#define HALF_PI (PI / 2.0f)\n\n// Shading settings, switch on/off for different effects\n// Vary index-of-refraction across specular surfaces\n#define VARIANT_IOR\n\n// Define dielectric/conductor-specific values for static IOR\n#define FIXED_DIELECTRIC_IOR 1.33f\n#define FIXED_CONDUCTOR_IOR vec2(1.5f, 1.1f)\n\n// Define dielectric/conductor-specific roughnesses\n#define DIELECTRIC_ROUGHNESS 0.048f\n#define CONDUCTOR_ROUGHNESS 0.1f\n\n// Adjustable color function for conductors\n#define MIRRS_RGB mod(vec3(abs(sin(surfOri.z / surfOri.x)), \\\n        \t                   abs(sin(tan(cos(surfOri.x) / surfOri.z))), \\\n        \t                   0.0f), vec3(1.0f))\n\n// Render mirrorlike surfaces in grayscale\n//#define GRAYSCALE_MIRRS\n\n// Epsilon value, useful for smoothing over FP imprecision\n#define EPSILON 0.0001\n\n// Float/integer converter\n#define UINT_MAX 4294967296.0f\nuint fToUint(float f)\n{\n    return uint(f * UINT_MAX);\n}\n\n// Integer/float converter\nfloat iToFloat(uint i)\n{\n    return float(i) * (1.0f / UINT_MAX);\n}\n\n// 32-bit Xorshift PRNG\nuint xorshiftPermu1D(inout uint permuVal)\n{\n    permuVal ^= (permuVal << 7);\n    permuVal ^= (permuVal >> 17);\n    permuVal ^= (permuVal << 5);\n    return permuVal;\n}\n\n// Hashes the given Xorshift seed to reduce correlation between\n// random values generated with closely spaced raw indices (like values\n// in the sequence [0,1,2...])\n// Index remixing implemented with the Wang hash found over here:\n// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint xorshiftNdx(uint rawNdx)\n{\n    // Remix/hash the given index\n    rawNdx = (rawNdx ^ 61U) ^ (rawNdx >> 16U);\n    rawNdx *= 9U;\n    rawNdx = rawNdx ^ rawNdx >> 4U;\n    rawNdx *= 0x27d4eb2dU;\n    rawNdx = rawNdx ^ (rawNdx >> 15U);\n\n    // Return the transformed index\n    return rawNdx;\n}\n\n// Small function returning the local space\n// defined by a given normal (i.e. the space\n// where a given normal vector is parallel \n// with the local y-axis)\nmat3x3 normlSpace(vec3 normal)\n{\n    // Generate a basis-x direction\n    // Different functions will be more/less appropriate\n    // depending on the normal's x/y-tendency\n    vec3 absNormal = abs(normal);\n    vec3 basisX = vec3(0.0);\n    if (absNormal.x >= absNormal.y)\n    {\n        basisX = vec3(normal.z, 0.0f, normal.x * -1.0f);\n    }\n    else\n    {\n        basisX = vec3(0.0f, normal.z, normal.y * -1.0f);\n    }\n\n    // Build the normal-space from the normal vector and the x-basis we generated before,\n    // then return the result\n    return mat3x3(normalize(basisX),\n                  normal,\n                  normalize(cross(normal, basisX)));    \n}\n\n// Sphere intersection function\n// Returns intersection position in [0].xyz,\n// instance origin in [1].xyz, intersection\n// status (valid/invalid) in [1].w, and \n// intersection distance in [0].w; also local \n// normal in [2].xyz\nmat3x4 SphIsect(vec3 ro,\n                vec3 rd,\n                float radius,\n                vec3 ori,\n                bool refraction)\n{    \n    vec3 rayOri = ro;\n    ro -= ori;\n    float b = 2.0f * dot(rd, ro);\n    float c = dot(ro, ro) - (radius * radius);\n    float dsc = (b * b) - \n        \t\t(4.0f * c); // Assumes normalized ray direction\n    // Evaluate [t] for the given discriminant\n    float invB = -1.0f * b;\n    float t = invB / 2.0f; // Assume [dsc] is zero by default        \n    if (dsc > 0.0f)\n    {\n        float dscRt = sqrt(dsc);\n        float q = -0.5f * (b + sign(b) * dscRt);\n        vec2 tt = vec2(q, c / q);\n        if (!refraction) { t = min(tt.x, tt.y); }\n    \telse { t = max(tt.x, tt.y); }\n    }\n        \n    // We have [t], an instance origin, and an intersection status;\n    // return appropriately here\n    vec3 isectPos = rayOri + rd * t;\n\treturn mat3x4(vec4(isectPos, t),\n                  vec4(ori, t >= 0.0f && dsc >= 0.0f),\n                  vec4(normalize(isectPos - ori), 0.0f));\n}\n\n// Planar intersection function\n// Returns intersection position in [0].xyz,\n// instance origin in [1].xyz, intersection \n// status (valid/invalid) in [1].w, and\n// intersection distance in [0].w\n// Also returns plane normal in [2].xyz\nmat3x4 PlaneIsect(vec3 norml,\n                  float offs,\n                  vec3 ro,\n                  vec3 rd)\n{\n    vec3 srcNorml = norml;\n    norml *= -1.0f; // This intersection algorithm renders planes upside-down, idk why...\n    float proj = dot(norml, rd);\n    // Synthesize planar origin\n    vec3 ori = norml * offs; // Normal is in global space\n        \n    // Find the vector connecting the planar origin to the\n    // ray origin, then find it's projection onto\n    // the local normal\n    // (scales distances to account for varying collinearity \n    // between [rd] and [norml])\n    vec3 rP = (ori - ro);\n    float rPProj = dot(rP, norml);\n        \n    // Total distance will equal the ratio of [rpProj] and [proj];\n    // generate that value and use it to find the intersection\n    // position before returning to the callsite\n    float t = rPProj / proj;\n    return mat3x4(vec4(ro + rd * t, t),\n                  vec4(ori, t >= 0.0f && proj > EPSILON),\n                  vec4(srcNorml, 0.0f));\n}\n\n// Bounding-box intersection function\n// Returns closest intersection in [0], furthest\n// intersection in [1], intersection status\n// (valid/invalid) in [w]\n// Intersection math reduced from:\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\nmat2x4 BoxIsect(vec3 ro,\n                vec3 rd,\n                vec3 scale, // Scale on x/y/z\n                vec3 ori)\n{\n    // Synthesize box boundaries from the given origin + scale\n    scale *= 0.5f;\n    mat2x3 bounds = mat2x3(ori - scale,\n                           ori + scale);\n    // Evaluate per-axis distances to each plane in the box\n    mat2x3 vecT = mat2x3((bounds[0] - ro) / rd,\n                      \t (bounds[1] - ro) / rd); // Maybe possible to optimize this down to matrix division...\n    // Keep near distances in [0], far distances in [1]\n\tvecT = mat2x3(min(vecT[0], vecT[1]),\n                  max(vecT[0], vecT[1]));\n    // Evaluate scalar min/max distances for the given ray\n    vec2 sT = vec2(max(max(vecT[0].x, vecT[0].y), vecT[0].z),\n                   min(min(vecT[1].x, vecT[1].y), vecT[1].z));\n    sT = vec2(min(sT.x, sT.y), max(sT.x, sT.y)); // Keep near distance in [x], far distance in [y]\n    // Return min/max distances + intersection status\n    bool isect = (vecT[0].x < vecT[1].y && vecT[0].y < vecT[1].x &&\n                  vecT[0].z < sT.y && sT.x < vecT[1].z);\n    return mat2x4(ro + (rd * sT.x), isect,\n                  ro + (rd * sT.y), isect);\n}\n\n// Ray/scene tracing interface\n// Returns surface origin in [0].xyz, surface\n// type (polyhedron/sphere/plane) in [0].w,\n// analytic normal in [1].xyz, and near ray \n// distance in [2].w; also intersection point \n// in [0].xyz and intersection status \n// ([1] :: valid, [0] :: invalid) in [1].w\n#define GROUND_SRF 0u\n#define REFRAC_SRF 1u\n#define MIRROR_SRF 2u\n#define LIGHTT_SRF 3u\n#define MAX_FIG_DIST 65536.0f\n#define SPH_RAD 0.25f\n#define SCENE_WIDTH 10.0f\n#define SCENE_HEIGHT 1.0f\n#define SCENE_ELEV -0.75f\n#define LI_ORI vec3(0.0f, 14.0f, 0.0f)\n#define LI_RAD 8.0f\nmat3x4 Trace(vec3 rd,\n             vec3 ro,\n             bool refraction)\n{    \n    // Trace the scene bounding-box\n    const vec3 bbO = vec3(0.0f, \n                          SCENE_ELEV, \n                          0.0f);\n    const vec3 bbS = vec3(SCENE_WIDTH, \n                          SCENE_HEIGHT, \n   \t\t                  SCENE_WIDTH);\n    mat2x4 bb = BoxIsect(ro,\n                         rd,\n                         bbS,\n                         bbO);\n    // Search for the closest sphere along [rd]\n    // ...but only for rays that intersect the bounding-box\n    // Otherwise return plane/light intersections\n    uint surfType = GROUND_SRF;\n    mat3x4 nearSrf = PlaneIsect(vec3(0.0f, 1.0f, 0.0f),\n               \t\t  \t  \t\t1.0f,\n               \t\t  \t  \t\tro,\n               \t\t  \t  \t\trd);\n    if (bool(bb[0].w))\n    {\n        float minDist = MAX_FIG_DIST;\n        float bdist = EPSILON;\n        float queryLen = length(bb[1].xyz - bb[0].xyz);\n    \twhile (bdist < queryLen)\n    \t{\n        \t// Construct a query-ray through the cells intersecting with [rd]\n           \tvec3 srchRay = bb[0].xyz + (rd * bdist);\n            // Find the query-ray's distance from the cell origin in modular space, then add that\n            // back into [xz] to extract the grid-relative position of the nearest cell\n            srchRay.xz += vec2(0.5f) - mod(srchRay.xz, vec2(1.0f));\n            vec3 nearSphO = vec3(srchRay.x,\n                        \t\t SCENE_ELEV,\n                        \t\t srchRay.z);\n            mat3x4 nearSph = SphIsect(ro,\n            \t                      rd,\n                                  \t  SPH_RAD,\n                                  \t  nearSphO,\n                                  \t  refraction);\n            vec3 surfDir = normalize(nearSph[0].xyz - ro);\n        \tif (nearSph[0].w < minDist &&\n            \tbool(nearSph[1].w) &&\n            \tdot(rd, surfDir) > 0.0f) \n            {\n            \t// Update the nearest surface + minimum distance\n            \tnearSrf = nearSph;\n            \tminDist = nearSph[0].w;\n            \n            \t// Update intersected surface type\n                uvec2 uSphO = uvec2(abs(nearSphO.xz));\n            \tsurfType = ((uSphO.x + uSphO.y) % 2u) + 1u;\n            }\n            \n            // Walk through to the next grid-cell\n            // Try to avoid skipping geometry by minimizing step size at grazing angles\n            vec3 oD = nearSphO - srchRay;\n        \tbdist += max(dot(rd, oD), 0.25f);\n    \t}   \n    }\n    \n    // Test rays against the light\n    mat3x4 li =\tSphIsect(ro,\n                         rd,\n                         LI_RAD,\n                         LI_ORI,\n                         false);\n    if ((!bool(nearSrf[1].w) ||\n         (li[0].w < nearSrf[0].w && surfType == GROUND_SRF)) &&\n        bool(li[1].w))\n    {\n    \tnearSrf = li;\n        surfType = LIGHTT_SRF;\n    }\n    \n    // Return intersection info for shading\n    return mat3x4(vec4(nearSrf[1].xyz, surfType),\n              \t  vec4(nearSrf[0].xyz, nearSrf[1].w),\n              \t  vec4(nearSrf[2].xyz, nearSrf[0].w));\n}\n\n// Evaluate Oren-Nayar reflectance for the given\n// directions + surface\nvec3 DiffBXDF(mat3x3 dirs, // Input direction in [0], local normal in [1],\n               \t\t\t   // output direction in [2]\n              vec4 surf) // RGB color in [rgb], roughness in [w]\n{\n    // Generate the basis Lambert BRDF\n    vec3 lambert = surf.rgb / PI;\n\n    // Calculate the squared variance (will be needed later)\n    float variSqr = surf.w * surf.w;\n\n    // Generate Oren-Nayar parameter values\n    float a = 1.0f - (variSqr / (2.0f * (variSqr + 0.33f)));\n    float b = (0.45 * variSqr) / (variSqr + 0.09f);\n    vec2 cosines = vec2(dot(dirs[1], dirs[0]),\n                        dot(dirs[1], dirs[2])); // Cosines of [theta] for each direction are just [n.l] and [n.v]\n    vec2 sines = sqrt(vec2(1.0f) - (cosines * cosines)); // Sines of [theta] for each direction are derivable from cosines\n    \n    // Sneaky function to find the difference between cosines of [phi], \n    // borrowed from iq:\n    // https://www.shadertoy.com/view/ldBGz3\n    float cosPhiSection = dot(dirs[2] - dirs[1] * cosines.y,\n                              dirs[1] - dirs[1] * cosines.x);\n\n    // Evaluate the Oren-Nayar microfacet contribution for the local surface\n    float orenNayar = a + (b * max(0.0, cosPhiSection)) * \n    \t\t\t\t  (sines.x * sines.y) / \n        \t\t\t  max(cosines.x, cosines.y);\n\n    // Generate the BRDF by applying the microfacet contribution to the basis Lambert reflectance\n    // function, then return the result\n    return lambert * orenNayar;\n}\n\n// Generate a diffuse direction (xyz) + PDF (w) for the given surface\nvec4 DiffDir(vec3 norml,\n             mat3x3 normSpace,\n             inout uint randVal) // Mutable Xorshift value\n{\n\t// Generate random sample values\n    vec2 uv = vec2(iToFloat(xorshiftPermu1D(randVal)),\n                   iToFloat(xorshiftPermu1D(randVal)));\n\n    // Malley's method requires us to send points onto\n    // a disc and then offset them along the up-vector,\n    // so place [uv] on the unit disc before we do\n    // anything else\n\n    // Map generated random values onto a unit square\n    // centered at the origin (occupying the domain\n    // [-1.0f...1.0f]^2)\n    uv = (uv * 2.0f) - vec2(1.0f);\n\n    // This is a mapping between incompatible spaces\n    // (specifically, a square fold over a disc), so\n    // applying the mapping to the centre of the\n    // projection will send input points to infinity;\n    // avoid that by branching here (assumes the\n    // centre of the projection is at [0.0f.xx])\n    if (!all(bvec2(uv == vec2(0.0f))))\n    {\n        // We know the mapping won't send [uv] to infinity, so\n        // we can safely map points from [-1.0f...1.0f]^2 onto\n        // the disc without generating any artifacts\n\n        // Infer radial distance from the larger absolute value between\n        // [uv.x] and [uv.y], then re-apply the sign of the original\n        // axis\n        vec2 absUV = abs(uv);\n        float r = max(absUV.x, absUV.y) *\n                  sign(uv[int(absUV.x < absUV.y)]);\n\n        // Construct [theta]\n        float uvRatio = uv[int(absUV.x > absUV.y)] / uv[int(absUV.y > absUV.x)]; // Take varying UV ratios depending on the value of [r]\n        vec3 coeffs = vec3(-1.0f, 1.0f, (r == uv.y));\n        float theta = (((PI / 2.0f) * coeffs.z) - ((PI / 4.0f) * uvRatio)) * coeffs[int(coeffs.z)]; // Generalized [theta] definition\n\n        // Construct a scaled polar coordinate carrying the\n        // generated [u, v] sampling values, then return it\n        uv = vec2(sin(theta), \n                  cos(theta)) * r;\n    }\n\n    // We've placed [uv] on the unit disc (+ used a square mapping\n    // technique to preserve uniformity between samples), so now\n    // we can complete Malley's method by setting our output [y]\n    // direction to the vertical distance from each initial disc\n    // sample to the surface of the unit hemisphere\n    vec2 uvSqr = uv * uv;\n    vec3 wi = normalize(vec3(uv.x,\n                          \t sqrt(1.0f - (uvSqr.x + uvSqr.y)),\n                          \t uv.y)); // Normalized cosine-weighted diffuse direction\n    return vec4(wi,\n                dot(vec3(0.0f, 1.0f, 0.0f), wi) / PI); // Probability density for hemisphere sampling with Malley's method\n}\n\n// Evaluate the GGX microfacet distribution function for\n// the given half-vector + roughness + input direction\n// Assumes strictly isotropic roughness\nfloat GGX(mat2x3 dirs, // half-vector is in [0], local normal is in [1]\n          float vari)\n{\n    float cTheta = dot(dirs[0], dirs[1]);\n    cTheta *= cTheta;\n    float denom = ((vari - 1.0f) * cTheta) + 1.0f;\n    if (vari == 0.0f) { return 1.0f; } // Return a unit distribution (zero occlusion) for \n    \t\t\t\t\t\t\t\t   // perfectly smooth surfaces\n    return vari / (PI * (denom * denom));\n}\n\n// Evaluate the Smith masking/shadowing function for the\n// given directions + surface roughness\n// Assumes strictly isotropic roughness\nfloat Smith(mat3x3 dirs, // Input vector in [0], half-vector\n            \t\t   \t // in [1], output vector in [2]\n            float vari)\n{\n    vec2 cThetaIO = vec2(dot(dirs[1], dirs[0]),\n                         dot(dirs[1], dirs[2]));\n    vec2 sThetaIO = sqrt(vec2(1.0f) - (cThetaIO * cThetaIO));\n    vec2 tThetaIO = abs(sThetaIO / cThetaIO);\n    vec2 phiIO = vec2(atan(dirs[0].y / dirs[0].x),\n                      atan(dirs[2].y / dirs[2].x));\n    vec2 cPhiIO = cos(phiIO);\n    cPhiIO *= cPhiIO; // We only use squared cos(phi), no reason to preserve the non-squared version\n    vec2 sPhiIO = (vec2(1.0f) - cPhiIO); // No reason to take the root here since we square again later anyway...\n    if (isinf(tThetaIO.x) || isinf(tThetaIO.y)) { return 0.0f; } // Try to avoid infinities; assume very shallow microfacet\n    \t\t\t\t\t\t\t\t\t  \t\t\t\t\t\t // angles (given by the half-vector) are occluded\n    vec2 tThetaIOSqr = tThetaIO * tThetaIO;\n    vec2 lamAlph = sqrt((cPhiIO * vari) + \n                        (sPhiIO * vari)); // Valid for isotropic distributions, but probably overcomplicated; would\n    \t\t\t\t\t\t\t\t\t  // like to find/derive a cleaner strictly-isotropic alternative if possible\n    lamAlph *= lamAlph * tThetaIOSqr;\n    vec2 lamIO = (sqrt(vec2(1.0f) + lamAlph) - vec2(1.0f)) * 0.5f;\n    // Avert [NaN]s and infinities here\n    if (isinf(lamIO.x) || isinf(lamIO.y) ||\n        isnan(lamIO.x) || isnan(lamIO.y)) { return 1.0f; }\n    else { return 1.0f / (1.0f + lamIO.x + lamIO.y); }\n}\n\n// PDF for normals sampled from GGX with Smith masking/shadowing\n// Taken from \n// Physically Based Rendering - From Theory to Implementation\n// (Pharr, Jakob, Humphreys)\nfloat GGXSmithPDF(mat4x3 dirs,\n                  float vari) // Input direction in [0], half-vector in [1],\n    \t\t\t\t\t\t  // output direction in [2], macrosurface normal \n    \t\t\t\t\t\t  // in [3]\n{\n    vec2 cThetas = abs(vec2(dot(dirs[1], dirs[2]),\n                        \tdot(dirs[3], dirs[2])));           \n    return GGX(mat2x3(dirs[1],\n                   \t  dirs[3]), \n               vari) * \n           Smith(mat3x3(dirs[0],\n                \t  \tdirs[1],\n                 \t    dirs[2]),\n                 vari) * \n           cThetas.x / \n           cThetas.y;\n}\n\n// Evaluate GGX/Smith PBR reflection for the given surface\nvec3 MirrBXDF(mat4x3 dirs, // Input direction in [0], half-vector in [1],\n               \t\t\t   // output direction in [2], macrosurface normal in [3] \n              vec4 surf, // Reflective surface color in [rgb], squared roughness in [a]\n              float fres) // Fresnel coefficient for the surface (scalar, spectral Fresnel is too messy and prone to dispersion)\n{\n    // Evaluate cosine terms\n    float cosTerm = dot(dirs[3], dirs[0]);\n    cosTerm *= dot(dirs[3], dirs[2]);\n    if (cosTerm == 0.0f) { return vec3(0.0f); } // Avert divisions by zero \n    \n    // Compute the PBR specular BRDF\n    return ((GGX(mat2x3(dirs[1], \n                        dirs[3]), \n                 surf.a) * // Distribution term [D] \n             Smith(mat3x3(dirs[0], \n                          dirs[1], \n                          dirs[2]), \n                   surf.a) * // Masking/shadowing term [G]\n             fres) / // Fresnel term [F]\n            abs(4.0f * cosTerm)) * // Reflection attenuation\n        \tsurf.rgb; // Surface tint\n}\n\n// Small utility function returning whether two rays lie in the same hemisphere\nbool SameHemi(vec3 wi, vec3 wo, vec3 norml)\n{\n    return (sign(dot(norml, wo)) == sign(dot(norml, wi)));\n}\n\n// Accept a GGX microfacet normal + a roughness + an outgoing direction, then synthesize a matching \n// reflective direction (xyz) and an appropriate PDF (w)\nvec4 MirrDir(vec3 microNorml,\n             vec3 norml,\n             float vari,\n             vec3 wo,\n             out vec3 hV)\n{\n    vec3 wi = reflect(wo, microNorml);\n    vec3 h = normalize(wo + wi);\n    hV = h; // Export the generated half-vector (needed for BXDF evaluation)\n    if (!SameHemi(wi, wo * -1.0f, norml)) { return vec4(wi, 0.0f); } // Reflective rays cannot refract through the surface; return zero probability for those here\n    return vec4(wi,\n                GGXSmithPDF(mat4x3(wi,\n                                   h,\n                                   wo,\n                                   norml),\n                            vari) / // Evaluate generalized probability density for GGX/Smith microfacet reflection\n                (4.0f * dot(wo, h))); // Scale appropriately for microfacet reflection\n}\n\n// Evaluate GGX/Smith PBR transmission for the given surface\n// Follows Walter et al., at: \n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\nvec3 RefrBXDF(mat4x3 dirs, // Input direction in [0], half-vector in [1], \n                 \t\t   // output direction in [2], macrosurface normal in [3]\n              vec4 surf, // Surface color in [rgb], roughness in [a]\n              float fres, // Fresnel coefficient for the local surface\n              float etaRatio) // Ratio of of incident/transmittant indices-of-refraction\n{    \n    // Walter et al.'s method expects [h] above the surface, conditionally invert it here\n    if (dirs[1].y < 0.0f) { dirs[1] *= -1.0f; }\n    \n    // Cache cosines relative to [h]\n\tvec2 hCosines = vec2(dot(dirs[0],\n                             dirs[1]), \n                         dot(dirs[2],\n                             dirs[1]));\n    // Avert divisions by zero\n    if (hCosines.x == 0.0f || hCosines.y == 0.0f) { return vec3(0.0f); }\n    \n    // Evaluate the denominator for the LHS of the transmission function\n    float invEtaRatio = 1.0f / etaRatio;\n    float denom = ((invEtaRatio * hCosines.y) + (etaRatio * hCosines.x));\n    denom *= denom;\n    \n    // Compute the LHS\n    float lhs = (GGX(mat2x3(dirs[1],\n                    \t    dirs[3]),\n                     surf.a) * // Distribution term [D]\n        \t     Smith(mat3x3(dirs[0],\n                              dirs[1],\n                              dirs[2]),\n                       surf.a) * // Masking/shadowing term [G]\n                 (1.0f - fres) * // Fresnel term [F]\n        \t     (etaRatio * etaRatio)) / \n        \t     denom;\n    \n    // Cache cosines relative to the macrosurface normal\n    vec2 nCosines = vec2(dot(dirs[0],\n                             dirs[3]),\n                         dot(dirs[2],\n                             dirs[3]));\n    \n    // Avert divisions by zero (for macrosurface normals this time)\n    if (nCosines.x == 0.0f || nCosines.y == 0.0f) { return vec3(0.0f); }\n    \n    // Compute the RHS\n    hCosines = abs(hCosines);\n    nCosines = abs(nCosines);\n    float rhs = (hCosines.x * hCosines.y) / (nCosines.x * nCosines.y);\n        \n    // Evaluate + return the full BTDF\n    return abs(lhs * rhs) * // Microfacet attenuation\n           surf.rgb; // Transmissive color (T)\n}\n\n// Accept a GGX/Smith microfacet normal, then synthesize a matching refractive direction (xyz)\n// and an appropriate PDF (w)\nvec4 RefrDir(vec3 microNorml,\n             vec3 norml,\n             vec3 wo,\n             float etaRatio,\n             float vari,\n             out vec3 hV)\n{    \n    vec3 wi = refract(wo, microNorml, etaRatio);\n    vec3 h = normalize(wo + (wi * etaRatio));\n    hV = h; // Export the generated half-vector (needed for BXDF evaluation)\n    if (SameHemi(wi, wo * -1.0f, norml)) { return vec4(wi, 0.0f); } // Refractive rays cannot reflect from the surface; return zero probability for those here    \n    float wiDH = dot(wi, h);\n    float pdfDenom = dot(wo, h) + (etaRatio * wiDH);\n    pdfDenom *= pdfDenom;\n    etaRatio *= etaRatio;\n\treturn vec4(wi, GGXSmithPDF(mat4x3(wi,\n                                   \t   h,\n                                   \t   wo,\n                                   \t   norml),\n                            vari) * // Evaluate generalized probability density for GGX/Smith microfacet incidence\n                \t\t\tabs(etaRatio * wiDH / pdfDenom)); // Scale appropriately for microfacet transmission\n}\n\n// GGX sampling function from\n// https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/\n// + minor optimizations\nvec3 GGXMicroNorml(float vari,\n                   inout uint randVal)\n{\n\tvec2 uv = vec2(iToFloat(xorshiftPermu1D(randVal)),\n                   iToFloat(xorshiftPermu1D(randVal)) * PI * 2.0f); // [phi] can be sampled uniformly\n    uv.x = sqrt((1.0f - uv.x) / \n                (uv.x * (vari - 1.0f) + 1.0f)); // Avoid [acos] here since we'll need the cosine when we change coordinates\n    // Change to Cartesian coordinates, then return\n    float sTheta = sqrt(1.0f - (uv.x * uv.x));\n    float cPhi = cos(uv.y);\n    float sPhi = sin(uv.y);\n    return normalize(vec3(sTheta * cPhi,\n                \t\t  uv.x,\n                \t\t  sTheta * sPhi));\n}\n\n// Evaluate the Fresnel coefficient for the given incoming/outgoing spectral refraction/extinction\n// indices + outgoing angle-of-incidence\n// Would like to use the direct maths implementation from PBR, but it's very expensive and\n// easy to fluff up; this approximation was found in\n// http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\nfloat FresMirr(vec2 etaKap, // Surface indices of refraction (x) and extinction (y)\n               mat2x3 dirs) // Output direction in [0], local normal in [1]\n{\n    float cTheta = dot(dirs[1], dirs[0]);\n    float etaMin1 = etaKap.x - 1.0f;\n    etaMin1 *= etaMin1;\n    float etaPlu1 = etaKap.x + 1.0f;\n    etaPlu1 *= etaPlu1;\n    etaKap *= vec2(1.0f, etaKap.y);\n\treturn (etaMin1 + ((4.0f * etaKap.x) * pow(1.0f - cTheta, 5.0f)) + etaKap.y) / (etaPlu1 + etaKap.y);    \n}\n\n// Evaluate the Fresnel coefficient for the given incoming/outgoing spectral IORs\n// + incoming angle-of-incidence\n// Uses the dielectric Fresnel function from \n// Physically Based Rendering (Pharr, Jakob, Humphreys), page 518\n// Spectral Fresnel coefficient returned in [rgb], incoming/outgoing [eta] ratio\n// returned in [a]\nvec2 Dielectric(vec2 etaIO, // Incoming/outgoing indices of refraction\n               \t\t\t    // Vectorized indices are possible, but cause significant\n               \t\t\t    // dispersion that I'd rather avoid here\n              \tmat2x3 dirs) // Output direction in [0], local normal in [1]\n{    \n    // Evaluate cosines of the incoming/outgoing ray directions\n    // Incoming cosine is derivable from Snell's law,\n    // https://en.wikipedia.org/wiki/Snell's_law\n    float cosI = abs(dot(dirs[0], dirs[1])); // Outgoing cosine is a trivial dot-product\n    float sinI = sqrt(max(1.0f - (cosI * cosI), 0.0f));\n    float etaRatio = etaIO.x / etaIO.y; // Ratio of sines is equivalent to ratios of [eta] (Snell's Law)\n    float sinT = etaRatio * sinI;\n    float cosT = sqrt(max(1.0f - (sinT * sinT), 0.0f));\n    \n    // Compute reflectance for parallel polarized light\n    float rhoPar = ((etaIO.y * cosI) - (etaIO.x * cosT)) / \n        \t\t   ((etaIO.y * cosI) + (etaIO.x * cosT));\n    \n    // Compute reflectance for orthogonal polarized light\n    float rhoOrt = ((etaIO.x * cosI) - (etaIO.y * cosT)) / \n        \t\t   ((etaIO.x * cosI) + (etaIO.y * cosT));\n    return vec2(((rhoPar * rhoPar) +\n            \t(rhoOrt * rhoOrt)) * 0.5f,\n                etaRatio);\n}\n\n// Material interface; ellipses are procedural/conductive, spheres are procedural/dielectric,\n// ground plane is even white diffuse\n// Reflected/refracted ray direction is in [0], local reflectance is in [1], \n// updated position is in [2]\n// A generic large number, used to minimize contributions for impossible rays (with [pdf == 0.0f])\n#define OMEGA 1000000.0f\nmat3x3 Material(mat2x3 ray, // Outgoing ray properties in global space\n                vec3 surfOri, // Surface origin in global space\n                vec3 isectPos, // Intersection position in global space\n                vec3 norml, // Local macrosurface normal\n                inout uint randVal, // Mutable Xorshift value\n                out bool sphEntered, // Output value, stores whether or not a ray refracted into a sphere during\n                \t\t\t\t\t // specular interaction\n                bool sphExit, // Whether or not the current ray is exiting a sphere (decides which [eta]-ratio\n               \t\t\t      // to use during refraction/reflection)\n                uint surfType) // Whether the local surface is a box, a sphere, or the ground plane\n{\n    // Push intersecting rays back outside the local surfac\n    isectPos -= norml * EPSILON;\n    \n    // Cache the surface's local transformation space\n    mat3x3 normSpace = normlSpace(norml);\n        \n    // Resolve surface materials\n    if (surfType == MIRROR_SRF)\n    {\n        // Derive tint + fresnel from surface origins\n        #ifndef GRAYSCALE_MIRRS\n        \tvec3 rgb = MIRRS_RGB;\n        #else\n        \tvec3 rgb = vec3(1.0f);\n        #endif\n        #ifdef VARIANT_IOR\n        \t// Plausible minimum/maximum values from\n        \t// https://refractiveindex.info/\n        \tvec2 etaKappa = vec2(0.3f + (fract(abs(sin(surfOri.x + surfOri.z * 3.0f))) * 2.0f),\n                 \t\t\t\t 1.0f + (fract(abs(cos(surfOri.x + surfOri.z * 3.0f))) * 5.0f));\n        #else\n        \tvec2 etaKappa = FIXED_CONDUCTOR_IOR;\n        #endif\n       \t\n        // Cache squared roughness here\n        float vari = CONDUCTOR_ROUGHNESS * CONDUCTOR_ROUGHNESS;\n        \n        // Generate a GGX microsurface normal\n        vec3 muNorml = GGXMicroNorml(vari,\n                                     randVal);\n        muNorml = normSpace * muNorml;\n        // Compute reflection\n        vec3 h = vec3(0.0f);\n        vec4 wi = MirrDir(muNorml,\n                          norml,\n                          vari,\n                          ray[1],\n                          h);\n        if (wi.w == 0.0f) { wi.w = OMEGA; } // Minimize contribution from impossible rays\n        float fres = FresMirr(etaKappa,\n                              mat2x3(wi.xyz,\n                                     muNorml));\n        return mat3x3(wi.xyz,\n                      MirrBXDF(mat4x3(wi.xyz,\n                               \t\t  h,\n                               \t\t  ray[1],\n                                  \t  norml),\n                               vec4(rgb, vari),\n                               fres) / wi.w * abs(dot(norml, wi.xyz)),\n                      isectPos);\n    }\n    else if (surfType == REFRAC_SRF)\n    {\n        // Derive index-of-refraction from surface origins\n        #ifdef VARIANT_IOR\n        \tfloat eta = 1.0f + fract(abs(sin(surfOri.x + surfOri.z))) + 0.1f;\n        #else\n        \tfloat eta = FIXED_DIELECTRIC_IOR;\n        #endif\n        vec3 rgb = vec3(1.0f); // Fixed dielectric color for contrast with conductors\n        \n        // Cache squared roughness here\n        float vari = DIELECTRIC_ROUGHNESS * DIELECTRIC_ROUGHNESS;\n        \n        // Generate a GGX microsurface normal\n        vec3 muNorml = GGXMicroNorml(vari,\n                                     randVal);\n        muNorml = normSpace * muNorml;\n                \n        // Evaluate the Fresnel coefficient for the current surface\n        vec2 etaIO = vec2(1.0f, eta);\n        if (sphExit) { etaIO.xy = etaIO.yx; }\n        vec2 fres = Dielectric(etaIO,\n                               mat2x3(ray[1],\n                                      muNorml));\n        \n        // We don't want to simultaneously trace reflection/refraction rays away from the sphere,\n        // so randomly choose between each subpath here\n        bool refr = (iToFloat(xorshiftPermu1D(randVal)) > fres.x);\n        sphEntered = refr && !sphExit; // Update refraction status; zero for exiting rays since they'll be incident with\n        \t\t\t\t\t\t\t   // vacuum in the next frame instead of the current surface\n        uint sel = uint(refr); // Cast refraction status to [int] for conditional vector/matrix accesses\n        \n        // Flip normals for exiting refraction rays\n        if (sphExit) { norml *= -1.0f; muNorml *= -1.0f; }\n        \n        // Compute refraction/reflection\n        mat2x4 bsdf; // Ray direction in [0], attenuation in [1]\n        float pdf = 1.0f; // Probability for the chosen ray direction\n        if (refr)\n        {            \n        \t// Generate a refraction direction\n            vec3 h = vec3(0.0f);\n        \tbsdf[0] = RefrDir(muNorml,\n                              norml,\n                          \t  ray[1],\n                          \t  fres.y,\n                              vari,\n                              h);\n            if (bsdf[0].w == 0.0f) { bsdf[0].w = OMEGA; } // Minimize contribution from impossible rays\n            \n            // Scale PDF to match refractive chance\n            bsdf[0] *= vec4(vec3(1.0f), 1.0f - fres.x);\n\n            // Evaluate the surface BTDF\n        \tbsdf[1].rgb = RefrBXDF(mat4x3(bsdf[0].xyz,\n                                          h,\n                                          ray[1],\n                                          norml),\n                                   vec4(rgb, vari),\n                                   fres.x,\n                                   fres.y) / bsdf[0].w;\n        }\n        else\n        {            \n            // Generate a reflection direction\n            vec3 h = vec3(0.0f);\n        \tbsdf[0] = MirrDir(muNorml,\n                              norml,\n                              vari,\n                              ray[1],\n                              h);\n            if (bsdf[0].w == 0.0f) { bsdf[0].w = OMEGA; } // Minimize contribution from impossible rays\n            \n            // Scale PDF to match reflective chance\n            bsdf[0] *= vec4(vec3(1.0f), fres.x);\n            \n        \t// Cache information for the reflection ray\n        \tbsdf[1].rgb = MirrBXDF(mat4x3(bsdf[0].xyz,\n                                          h,\n                                          ray[1],\n                                          norml),\n                                   vec4(rgb, vari),\n                                   fres.x) / bsdf[0].w;\n        }\n        \n        // Displace output rays just past the sphere's radius\n        if (sphExit) { isectPos -= (2.0f * norml * EPSILON); }\n                               \n        // Return everything so we can calculate the next bounce :)\n        return mat3x3(bsdf[0].xyz,\n                      bsdf[1].rgb * abs(dot(norml, bsdf[0].xyz)),\n                      isectPos);\n    }\n    else\n    {\n        // Process intersections with the ground plane\n        vec4 wi = DiffDir(norml,\n                          normSpace,\n                          randVal);\n        wi.xyz = normSpace * wi.xyz;\n        return mat3x3(wi.xyz,\n                      DiffBXDF(mat3x3(wi.xyz,\n                                      norml,\n                                      ray[1]),\n                               vec4(vec3(0.8f), HALF_PI)) / wi.w * abs(dot(norml, wi.xyz)),\n                      isectPos);\n    }\n}\n\n// Vectorized version of the Blackman-Harris filter function\nfloat BlackmanHarris(vec2 sampleXY)\n{\n    // Transform sample coordinates to absolute pixel distances\n    sampleXY = abs(sampleXY - vec2(MAX_SPP_PER_AXIS));\n    \n    // Blackman-Harris alpha parameters\n    // Parameter values taken from:\n    // https://en.wikipedia.org/wiki/Window_function#Blackmanï¿½Harris_window\n    const vec2 alph0 = vec2(0.35875f);\n    const vec2 alph1 = vec2(0.48829f);\n    const vec2 alph2 = vec2(0.14128f);\n    const vec2 alph3 = vec2(0.01168f);\n\n    // Core Blackman-Harris filter function\n    vec2 ratio = vec2((PI * sampleXY)) / float(MAX_SPP - 1);\n    vec2 filtv = alph0 - (alph1 * cos(2.0f * ratio)) +\n                   \t   \t (alph2 * cos(4.0f * ratio)) -\n                   \t   \t (alph3 * cos(6.0f * ratio));\n    return (filtv.x * filtv.y);\n}\n\n// Small function for AA ray jitter\nvec2 AAJitter(inout uint randVal)\n{\n    const float range = float(MAX_SPP_PER_AXIS);\n    return (vec2(iToFloat(xorshiftPermu1D(randVal)),\n                 iToFloat(xorshiftPermu1D(randVal))) * range) - \n           vec2(range * 0.5f);\n}\n\n// Ray generator for a perspective pinhole camera\nvec4 RayDir(vec2 pixPos,\n            vec2 viewSizes,\n            inout uint randVal,\n            int frameCtr)\n{\n    viewSizes *= float(MAX_SPP_PER_AXIS);\n    pixPos *= float(MAX_SPP_PER_AXIS);\n    vec2 sampleXY = vec2(frameCtr % MAX_SPP_PER_AXIS,\n                   \t\t frameCtr / MAX_SPP_PER_AXIS); // Offset the current ray within the sampling grid\n    sampleXY += AAJitter(randVal); // Jitter the given offset\n    pixPos += sampleXY; // Apply offset to the scaled pixel position\n    vec3 dir = vec3(pixPos - (viewSizes / 2.0),\n                \tviewSizes.y / tan(1.62 / 2.0)); // Generate ray direction\n    return vec4(normalize(dir), // Normalize\n                BlackmanHarris(sampleXY)); // Generate filter value\n}\n\n// Trace the scene, output filtered colors, repeat\n#define LI_BRIGHTNESS 2048.0f\n#define MAX_NUM_BOUNCES 7\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // The player isn't going to move anywhere, so just stop casting rays after [MAX_SPP] instead\n    // of clearing the sampling buffer or w/e\n    if (iFrame > MAX_SPP)\n    {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n        return;\n    }\n    \n    // Initialise the Xorshift instance for the current pixel\n    uvec2 iFragCoord = uvec2(fragCoord * iResolution.xy);\n    uint fragNdx = iFragCoord.x + (iFragCoord.y * uint(iResolution.y));\n    uint randVal = xorshiftNdx(fragNdx + uint(iFrame));\n    \n    // Cache frame count + refresh status\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 frameInfo = texture(iChannel1, uv);\n    \n    // Compact ray definition with [ro] in [0] and\n    // [rd] in [1]\n    vec4 rdFilt = RayDir(fragCoord, \n                         iResolution.xy,\n                         randVal,\n                         int(frameInfo.x));\n    vec3 camPos = texture(iChannel2, uv).xyz; // Take camera position from buffer D\n    mat2x3 ray = mat2x3(camPos, \n                        rdFilt.xyz);\n    vec3 rgb = vec3(1.0f);\n    bool refraction = false;\n    for (int bounceCtr = 0; bounceCtr != MAX_NUM_BOUNCES; bounceCtr += 1)\n    {\n        // Gather intersection info for [ray]\n        mat3x4 isect = Trace(ray[1],\n                             ray[0],\n                             refraction);\n        // Integrate material contributions and bounce [ray] on valid\n        // intersections\n        bool liSect = (uint(isect[0].w) == LIGHTT_SRF);\n        if (bool(isect[1].w) && !liSect)\n        {\n            mat3x3 matInfo = Material(ray,\n                                      isect[0].xyz,\n                                      isect[1].xyz,\n                                      isect[2].xyz,\n                                      randVal,\n                                      refraction,\n                                      refraction,\n                                      uint(isect[0].w));\n            rgb *= matInfo[1]; // Update attenuation\n            ray[0] = matInfo[2]; // Update ay origin\n            ray[1] = matInfo[0]; // Update ray direction\n        }\n        else if (bool(isect[1].w) && liSect)\n        {\n            // Highlight paths that intersect the light, then break\n            // Actual light surface is locked to 100% brightness\n            if (bounceCtr > 0) { rgb *= LI_BRIGHTNESS / (4.0f * PI * (isect[2].w * isect[2].w)); }\n            break;\n        }\n        else\n        {\n            // Break out early + darken shading for non-intersecting/escaped rays\n            rgb = vec3(0.0f);\n        \tbreak;    \n        }\n    }\n    \n    // Output filtered pixel color\n    // Zero existing colors if the user refreshed the shader\n    vec4 currPx = texture(iChannel0, uv) * (1.0f - frameInfo.w); \n    fragColor = vec4(currPx.rgb + (rgb * rdFilt.a),\n                     currPx.a + rdFilt.a);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Maximum samples-per-pixel (relevant for anti-aliasing)\n#define MAX_SPP 16384\n\n// Maximum sample count along each axis of the per-pixel sampling grid\n#define MAX_SPP_PER_AXIS 128\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define SPACE_KEY 0x20\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Check movement/refresh status\n    bool mov = (dot(texture(iChannel2, fragCoord / iResolution.xy).rgb, vec3(1.0f)) != 0.0f);\n    bool refresh = bool(texture(iChannel1, vec2((float(SPACE_KEY) + 0.5f) / 256.0f, 0.25f)).x);\n    bool singleSPP = mov || refresh;\n    if (singleSPP)\n    {\n        // Zero frame-counter when the user moves/refreshes, pass movement/refresh-status\n        // along to the integrator\n        fragColor = vec4(vec3(0.0f), singleSPP);\n    }\n    else\n    {\n        // Increment frame-counter by [1] by default, pass refresh-status along to the integrator\n    \tfragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).rgb + vec3(1.0f), singleSPP);        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define LEFT_KEY 0x25\n#define FWD_KEY 0x26\n#define RIGHT_KEY 0x27\n#define BACK_KEY 0x28\n#define LCTRL_KEY 0x11\n#define LSHIFT_KEY 0x10\n#define SPEED 0.25f\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Check for movement keypresses, cache velocities\n    mat2x3 dP = mat2x3(texture(iChannel0, vec2((float(RIGHT_KEY) + 0.5f) / 256.0f, 0.25f)).x,\n                       texture(iChannel0, vec2((float(LSHIFT_KEY) + 0.5f) / 256.0f, 0.25f)).x,\n                       texture(iChannel0, vec2((float(FWD_KEY) + 0.5f) / 256.0f, 0.25f)).x,\n                       texture(iChannel0, vec2((float(LEFT_KEY) + 0.5f) / 256.0f, 0.25f)).x,\n                       texture(iChannel0, vec2((float(LCTRL_KEY) + 0.5f) / 256.0f, 0.25f)).x,\n                       texture(iChannel0, vec2((float(BACK_KEY) + 0.5f) / 256.0f, 0.25f)).x); \n    dP *= SPEED;\n    \n    // Output movement deltas in [xyz]\n    fragColor = vec4(dP[0] - dP[1],1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define INIT_CAM_POS vec3(0.0f, 0.0f, -7.0f)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Extract current camera positon\n    vec3 camP = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    \n    // Apply movement deltas\n    camP += texture(iChannel1, fragCoord / iResolution.xy).xyz;\n    \n    // Output current camera position\n    if (iFrame != 0) { fragColor = vec4(camP, 1.0f); }\n    else { fragColor = vec4(INIT_CAM_POS,1.0); }\n}","name":"Buffer D","description":"","type":"buffer"}]}