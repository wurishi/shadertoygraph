{"ver":"0.1","info":{"id":"3dlyRN","date":"1584520804","viewed":6676,"name":"singularity space","username":"latel88","description":"singularity space","likes":71,"published":1,"flags":32,"usePreview":1,"tags":["raymarch","box","multipass","lot","culling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float calcUV ( const in vec2 uv, const in float m )\n{\t\n\tfloat vig = (0.0 + 1.0 * 16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));\n\t\n\treturn max( m, 1.0 - pow( vig, 0.175 ) );\n\n}\n\nvec2 getDistortion ( const in vec2 coord )\n{\n   \treturn restoreCheckerboardBuffer( iChannel0, coord, iResolution.xy ).ba;\n    \n}\n\nfloat getDepth ( const in vec2 coord )\n{\n    return restoreCheckerboardBuffer( iChannel0, coord, iResolution.xy ).g;\n    \n}\n\nvec3 getColor ( const in vec2 coord )\n{\n    float col = restoreCheckerboardBuffer( iChannel0, coord, iResolution.xy ).r;\n    \n    return vec3(col / 1.5, col / 1.75, col);  \n    \n}\n\nvec3 blur ( const in int count, const in float radius, const in vec2 uv )\n{\n    if (count <= 1)\n    {\n        return getColor( uv );\n\n    }\n\n\tfloat f = float(count);\n\t\n    vec3 color =  vec3(0.0);\n\tfloat totalw = 0.0;\n\t\n\tfor (int x = 0, len = max( 0, count - 1 ); x < len; x++)\n\t{\n\t\tvec2 p = uv;\n\t\tfloat fi1 = float(x) / f;\n\t\tfloat dir = fi1 * CIRCLE;\n\n\t\tp += vec2(sin( dir ), cos( dir )) * radius;\n\n        vec2 u = p * iResolution.xy;\n        \n        if (hasInResolution( u, iResolution.xy ))\n        {\n            color += getColor( u );\n            totalw += 1.0;\n\n        }\n\n\n\t}\n\n\treturn color / totalw;\n\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    vec2 coord = fragCoord;\n    \n    vec2 uv = coord.xy / resolution.xy;\n    \n    vec2 distortion = getDistortion( coord );\n        \n    #ifdef EFFECT\n        float vig = clamp( calcUV( uv, 0.125 ), 0.0, 1.0 );\n        vec2 u = uv;\n\n        u.xy += distortion * 0.0125;\n        \n        float par = max( vig, max( getDepth( coord ), max( abs( distortion.x ), abs( distortion.y ) ) ) );\n\n    \tvec3 color = blur( int(ceil( mix( 0.0, 50.0, clamp( par, 0.0, 1.0 ) ) )),  0.0125 * par, u );\n    #else\n        vec3 color = getColor( uv * iResolution.xy );\n    \n    #endif\n    \n    if (distortion.x != 0.0 || distortion.y != 0.0)\n    {\n        Singularity singularity = getSingularity(iTime);\n\n        color += (1.0 - singularity.radius / SINGULARITY_RADIUS) * vec3(0.75, 0.75, 1.0);\n    }\n\n    #ifdef DEBUG_LIST\n        fragColor = texture(iChannel1, uv);\n\n    #else\n    \tfragColor = vec4(color, 0.0);\n   \t#endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 getForce ( const in sampler2D buffer, const in int index, const in int length, const in vec2 resolution )\n{\n    int i = index + 1;\n    vec3 force = texelFetch( buffer, ivec2(modI( float(i), resolution.x ), floor( float(i) / resolution.x )), 0 ).rgb;\n    \n    return force;\n    \n}\n\nvec4 computeForce ( const in int index, const in int count )\n{\n   \tEntity entity = getEntity( iChannel0, index, count,  iResolution.xy  );\n   \tvec3 force = getForce( iChannel0, index, count, iResolution.xy );\n    Singularity singularity = getSingularity( iTime );\n    \n    float dist = length( entity.position - singularity.position );\n    float delta = getFrameTime( iTimeDelta );\n    \n    if (dist < singularity.radius)\n    {\n        float impact = mix( 0.000, 0.005, dist / singularity.radius) * max( 0.0, singularity.force );\n        vec3 add = (singularity.position - entity.position) * impact;\n        \n        force += add * delta;\n        \n    }\n    \n    force -= force * 0.02 * delta;\n    \n    return vec4(force, 0.0);\n    \n}\n\nvec4 computeEntity ( const in int index, const in int count )\n{\n   \tEntity entity = getEntity( iChannel0, index, count,  iResolution.xy  );\n   \tvec3 force = getForce( iChannel0, index, count, iResolution.xy );\n    \n    vec3 pos = entity.position;\n    float rotate = entity.rotate;\n    float delta = getFrameTime( iTimeDelta );\n    \n    pos += force * delta;\n    rotate += (force.x + force.y + force.z) * delta * (sign( hash( float(index) * 0.233 ) ) * 1.5);\n    \n    return vec4(pos, rotate);\n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    int compute_point = int(fragCoord.y) * int(iResolution.x) + int(fragCoord.x);\n    \n    if (compute_point == 0)\n    {\n        fragColor = vec4(iResolution.xy, 0.0, 0.0);\n        \n    }\n    else\n    {\n        vec3 resolution = texelFetch( iChannel0, ivec2(0), 0 ).rgb;\n        \n        compute_point -= 1;\n        \n        if (resolution.x == iResolution.x && resolution.y == iResolution.y)\n        {\n            int count = EntityCount;\n            \n            if (compute_point < count)\n            {\n                fragColor = computeForce( compute_point, count );\n\n            }\n            else if (compute_point < count * 2)\n            {\n                fragColor = computeEntity( compute_point - count, count );\n\n            }\n            else\n            {\n            \tfragColor = vec4(0.0);\n                \n            }\n            \n        }\n        else\n        {\n            fragColor = vec4(0.0);\n            \n        }\n        \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define DEBUG_CULLING\n//#define DEBUG_LOOP\n//#define DEBUG_LIST\n#define EFFECT\n\n#define FOV 0.5\n#define ENTITY_MAX 5000\n#define MARCH_STEP 100\n#define MARCH_DISTANCE 20.0\n\n#define SINGULARITY_RADIUS 6.667\n\n#define QUATER 0.7853981633974483\n#define HALF 1.5707963267948966\n#define PI 3.141592653589793\n#define CIRCLE 6.283185307179586\n\n#define TS max( 1.0, sqrt( (iResolution.x * iResolution.y * 4.0) / float(ENTITY_MAX) ) )\n#define TileSize (TS - mod(TS, 2.0))\n#define listResolution (iResolution.xy - mod( iResolution.xy, vec2(TileSize) ))\n#define EntityCount int(min( float(ENTITY_MAX), (listResolution.x / TileSize) * (listResolution.y / TileSize) * 4.0 ))\n\n#define hasInResolution(pos,rez) all(bvec2(all(greaterThanEqual(ivec2(pos),ivec2(0.0))),bvec2(all(lessThan(ivec2(pos),ivec2(rez))))))\n\nstruct Camera {\n\tvec3 position;\n\tvec2 direction;//pitch yaw\n\tfloat fov;\n\n};\n\nstruct Entity {\n\tvec3 position;\n    float rotate;\n    float radius;\n    \n};\n    \nstruct Singularity\n{\n   \tvec3 position;\n    float radius;\n    float force;\n    \n};\nstruct Project {\n    vec2 uv;\n    float radius;\n    \n};\n\nconst vec2 checkerOffset[4] = vec2[4](\n\tvec2( 0, 0),\n    vec2(-1, 0),\n    vec2( 0, 1),\n    vec2( 0,-1)\n);\n\nvec2 getAspect ( const in vec2 resolution )\n{\n    return resolution.xy / min( resolution.x, resolution.y );\n    \n}\n\nfloat getFrameTime ( const in float delta )\n{\n  \treturn delta * 100.0 / 2.0;\n    \n}\n\nfloat hash ( const in float p )\n{\n    return (fract( sin( p ) * CIRCLE ) - 0.5) / 0.5;\n    \n}\n  \nfloat hashAbs ( const in float p )\n{\n    return fract( sin( p ) * CIRCLE );\n    \n}\n\nfloat modI ( const in float a, const in float b )\n{\n    float m = a - floor( (a + 0.5) / b ) * b;\n    \n    return floor( m + 0.5 );\n    \n}\n\nfloat atan2 ( const in float y, const in float x )\n{\n    return x == 0.0 ? sign( y ) * PI / 2.0 : atan( y, x );\n    \n}\n\nvec3 rotate ( vec3 pos, vec3 axis,float theta )\n{\n    axis = normalize( axis );\n    \n    vec3 v = cross( pos, axis );\n    vec3 u = cross( axis, v );\n    \n    return u * cos( theta ) + v * sin( theta ) + axis * dot( pos, axis );   \n    \n}\n\nvec2 restoreCheckerCoord ( const in vec2 coord )\n{\n\treturn vec2(floor(coord.x) * 2.0 + mod(coord.y, 2.0), coord.y);\n\n}\n\nvec4 getCheckerPixel ( const in sampler2D tex, const in vec2 coord, const in vec2 rez, inout float div )\n{\n    vec2 cd = vec2(coord * vec2(0.5, 1.0));\n\n\tif (hasInResolution( cd, rez ))\n\t{\n\t\tdiv++;\n\n\t\treturn texelFetch( tex, ivec2(cd), 0 );\n\n\t}\n\n\treturn vec4(0.0);\n\n}\n\nvec4 restoreCheckerboardBuffer ( const in sampler2D tex, const in vec2 coord, const in vec2 rez )\n{\n\tfloat ch = step( mod( coord.x + coord.y, 2.0 ), 0.5 );\n\tfloat div = 0.0;\n\tvec4 a = getCheckerPixel( tex, coord + vec2(1, 0) * ch, rez, div );\n\tvec4 b = getCheckerPixel( tex, coord + vec2(0, 1) * ch, rez, div );\n\tvec4 c = getCheckerPixel( tex, coord - vec2(1, 0) * ch, rez, div );\n\tvec4 d = getCheckerPixel( tex, coord - vec2(0, 1) * ch, rez, div );\n\n\treturn (a + b + c + d) / 4.0;\n\t\n}\n\n//Copy to https://www.shadertoy.com/view/MdlGz4\nvec3 yawPitchToDirection ( const in vec2 dir, const in vec2 uv , const in float fov )\n{\n\tfloat xCos = cos( dir.x );\n\tfloat xSin = sin( dir.x );\n\tfloat yCos = cos( dir.y );\n\tfloat ySin = sin( dir.y );\n\t\n\tfloat gggxd = uv.x - 0.5;\n\tfloat ggyd = uv.y - 0.5;\n\tfloat ggzd = fov;\n\t\n\tfloat gggzd = ggzd * yCos + ggyd * ySin;\n\t\n\treturn normalize( vec3(\n\t\tgggzd * xCos - gggxd * xSin,\n\t\tggyd * yCos - ggzd * ySin,\n\t\tgggxd * xCos + gggzd * xSin\n\t\t\n\t) );\n\n}\n\n//Copy to https://www.shadertoy.com/view/MscSRr\nProject projectSphere ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in vec3 so, const in float sr, const in float fov )\n{\n\tvec3 vel = so - ro;\n\n\tfloat cx = dot( vel, rdX );\n\tfloat cy = dot( vel, rdY );\n\tfloat cz = dot( vel, rdZ );\n\t\n\tfloat dz = dot( vel, rdZ );\n\n    return Project(\n\t\tvec2(\n            (cx / cz),\n\t\t\t(cy / cz)\n            \n        ) * fov,\n\t\t(sr * distance(vec2(1.0), vec2(0.0)) / dz) * fov\n\t\t\n\t);\n\n}\n\nCamera createCamera ( const in vec4 mouse, const in float time )\n{\n    float t = time / 10.0;\n    vec3 pos = vec3((MARCH_DISTANCE / 2.0) + (MARCH_DISTANCE / 4.0) * sin( t ), MARCH_DISTANCE / 4.0, (MARCH_DISTANCE / 2.0) + (MARCH_DISTANCE / 4.0) * cos( t ));\n    vec2 dir = vec2( atan2( pos.z - (MARCH_DISTANCE / 2.0), pos.x - (MARCH_DISTANCE / 2.0) ), -HALF - QUATER + 0.1);\n    \n    return Camera( pos, dir, FOV );\n    \n}\n\nEntity getEntity ( const in sampler2D buffer, const in int index, const in int length, const in vec2 resolution )\n{\n    int i = length + index + 1;\n    vec4 entity = texelFetch( buffer, ivec2(modI( float(i), resolution.x ), floor( float(i) / resolution.x )), 0  );\n    vec3 pos = entity.rgb;\n    float rotate = entity.a;\n    float scale = 0.325 + hashAbs( float(index) * 0.87965 * float(index) ) * 0.125;\n\n    if (pos.x == 0.0 && pos.y == 0.0 && pos.z == 0.0)\n    {\n        pos = vec3(\n            hashAbs( float(index) * 0.012345 ) * MARCH_DISTANCE,\n           \thashAbs( float(index) * 0.023154 ) * MARCH_DISTANCE,\n            hashAbs( float(index) * 0.035312 ) * MARCH_DISTANCE\n\n        );\n        \n        rotate = hashAbs( float(index) * 0.045131 );\n\n    }\n    \n    pos = mod( pos, vec3(MARCH_DISTANCE) );\n    \n    return Entity( pos, rotate, scale );\n    \n}\n\nSingularity getSingularity ( const in float time )\n{\n    float speed = 2.0;\n    float radius = SINGULARITY_RADIUS;\n    \n    int index = int(floor( time / speed ));\n    \n   \tvec3 pos = vec3(\n        radius / 2.0 + hashAbs( float(index + 5) * 0.151 ) * (MARCH_DISTANCE - radius),\n        radius / 2.0 + hashAbs( float(index + 5) * 0.781 ) * (MARCH_DISTANCE - radius),\n        radius / 2.0 + hashAbs( float(index + 5) * 0.914 ) * (MARCH_DISTANCE - radius)\n    \n    );\n    \n    float force = cos( mod( time, speed ) / speed * PI );\n    \n    radius *= max( 0.0, sin( force * PI / 2.0 ) );\n    \n    return Singularity( pos, radius, force );\n    \n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool hasAABB ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in int index, const in int count, const in float fov, const in vec2 AABB_size, const in vec2 AABB_center )\n{\n    Entity entity = getEntity( iChannel0, index, count, iResolution.xy );\n    \n    if (length( entity.position - ro ) > 1.75)\n    {\n        Project proj = projectSphere( rdX, rdY, rdZ, ro, entity.position, entity.radius, fov );\n\n        vec2 so = proj.uv;\n        float sr = proj.radius;\n        vec2 bo = AABB_center;\n        vec2 br = AABB_size;\n\n        vec2 vDelta = max( vec2(0.0), abs( bo - so ) - br );\n\n        return dot( vDelta, vDelta ) <= sr * sr;\n        \n    }\n    \n    return false;\n    \n}\n\nvec4 compute ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in float fov, const in vec2 resolution, const in vec2 coord )\n{\n    vec2 tile = vec2(TileSize);\n    ivec2 tile_resolution = ivec2(listResolution / tile);\n    \n    vec2 fix = iResolution.xy / min( iResolution.x, iResolution.y );\n\n\tivec2 AABB_coord = ivec2(coord) / tile_resolution;\n    vec2 AABB_size = 1.0 / tile * fix;\n\tvec2 AABB_center = vec2(AABB_coord) * AABB_size + AABB_size / 2.0 - fix * 0.5;\n    \n    ivec2 tile_start_coord = AABB_coord * tile_resolution;\n    ivec2 tile_end_coord =  (AABB_coord + 1) * tile_resolution;\n    \n    ivec2 tile_fix_resolution = tile_end_coord - tile_start_coord;\n    ivec2 tile_coord = ivec2(coord) - tile_start_coord;\n    \n  \tint index = tile_coord.y * tile_fix_resolution.x + tile_coord.x;\n\tint count = EntityCount;\n    int entity_index = index * 4;\n\n    return vec4(\n        entity_index + 0 < count && hasAABB( rdX, rdY, rdZ, ro, entity_index + 0, count, fov, AABB_size, AABB_center ) ? 1 : 0,\n        entity_index + 1 < count && hasAABB( rdX, rdY, rdZ, ro, entity_index + 1, count, fov, AABB_size, AABB_center ) ? 1 : 0,\n        entity_index + 2 < count && hasAABB( rdX, rdY, rdZ, ro, entity_index + 2, count, fov, AABB_size, AABB_center ) ? 1 : 0,\n        entity_index + 3 < count && hasAABB( rdX, rdY, rdZ, ro, entity_index + 3, count, fov, AABB_size, AABB_center ) ? 1 : 0\n    );\n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = listResolution;\n    vec2 coord = fragCoord;\n    \n    if (coord.x < resolution.x && coord.y < resolution.y)\n    {\n    \tCamera cam = createCamera( iMouse, iTime );\n    \tvec3 rdZ = yawPitchToDirection( cam.direction, vec2(0.5), 1.0 );\n        vec3 rdY = yawPitchToDirection( vec2(cam.direction.x, cam.direction.y - HALF), vec2(0.5), 1.0 );\n        vec3 rdX = normalize( cross( rdZ, rdY ) );\n\n        fragColor = compute( rdX, rdY, rdZ, cam.position, cam.fov, resolution, coord );\n        \n    }\n    else\n    {\n        fragColor = vec4(0.0);\n        \n    }\n\t\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const vec3 sun_direction = vec3(0.0, 1.0, 0.0);\n\nfloat op ( const in float x1, const in float x2 )\n{\n    return x1 < x2 ? x1 : x2;\n    \n}\n\nbool boundingSphere ( const in vec3 rd, const in vec3 ro, const in vec3 so, const in float sr )\n{\n    return length( cross( rd, so - ro ) ) < sr;\n    \n}\n\nfloat diffuse ( vec3 light, vec3 normal, float power )\n{\n\treturn 1.0 - (1.0 - clamp( dot( normal, light ), 0.0, 1.0 )) * power;\n\n}\nfloat phong ( const in vec3 rd, const in vec3 ld, const in vec3 normal, const in float fresnel, const in float roughness, const in float metallic )\n{\n\tvec4 parametes = vec4(0.1, fresnel, roughness, metallic);\n\tvec3 n = normal;\n\tvec3 invLight = ld;\n\tvec3 invEye = rd;\n\tvec3 halfLE = normalize( invLight - invEye );\n\n\tfloat rough = parametes.z;\n\tfloat alpha2 = pow( rough, 4.0 );\n\tfloat D = alpha2 / (PI * pow( dot( n, halfLE ) * dot( n, halfLE ) * (alpha2 - 1.0) + 1.0, 2.0 ));\n\tfloat fre = parametes.y + (1.0 - parametes.y) * pow( clamp( dot( invEye, halfLE ), 0.0, 1.0 ), 5.0 );\n\tfloat nv = clamp( dot( invEye, n ), 0.0, 1.0 );\n\tfloat nl = clamp( dot( invLight, n ), 0.0, 1.0 );\n\tfloat G = 1.0 / (nv + sqrt( alpha2 + (1.0 - alpha2) * nv * nv) ) / (nl + sqrt( alpha2 + (1.0 - alpha2) * nl * nl ));\n\tfloat specular = D * fre * G;\n\tfloat diffuse = (1.0 - fre) * clamp( dot( n, invLight ), 0.0, 1.0 ) / PI;\n\tfloat meta = parametes.w;\n\n\treturn clamp( mix( diffuse, specular, meta ), 0.0, 1.0 );\n\n}\n\n//Copy to https://www.shadertoy.com/view/Xds3zN\nfloat udSphere ( const vec3 p, const float r )\n{\n\treturn length( p ) - r;\n    \n}\nfloat udRoundBox ( const vec3 p, const vec3 b, const float r )\n{\n\treturn length( max( abs( p ) - b, 0.0 ) ) - r;\n    \n}\n\nfloat mapRock ( const in Entity entity, const in int index, const in vec3 pos )\n{    \n    float h = 1e15;\n\n    vec3 p = rotate(\n        pos - entity.position,\n        vec3(\n            hash( float(index) * 0.12345 ),\n            hash( float(index) * 0.54321 ),\n            hash( float(index) * 0.23154 )\n        ),\n        entity.rotate\n\n    );\n\n    h = op( h, udRoundBox( p, vec3( entity.radius * 0.5 ), 0.025 ) );\n    \n    return h;\n    \n}\n\nvec3 getNormalRock ( const in Entity entity, const in int index, const in vec3 pos )\n{\n    vec2 e = vec2(0.001, 0.0);\n    \n    return normalize( 0.000001 + mapRock( entity, index, pos ) - vec3(mapRock( entity, index, pos - e.xyy ), mapRock( entity, index, pos - e.yxy ), mapRock( entity, index, pos - e.yyx )) );\n    \n}\n\nfloat mapSingularity ( const in Singularity singularity, const in vec3 pos )\n{    \n    float h = 1e15;\n\n    h = op( h, udSphere( pos - singularity.position, singularity.radius ) );\n\n    return h;\n    \n}\n\nvec3 getNormalSingularity ( const in Singularity singularity, const in vec3 pos )\n{\n    vec2 e = vec2(0.001, 0.0);\n    \n    return normalize( 0.000001 + mapSingularity( singularity, pos ) - vec3(mapSingularity( singularity, pos - e.xyy ), mapSingularity( singularity, pos - e.yxy ), mapSingularity( singularity, pos - e.yyx )) );\n    \n}\n\nbool march ( const in vec3 rd, const in vec3 ro, const in int index, const in Entity entity, const in int count, const in vec3 background, inout float dist, inout float depth, inout vec3 color )\n{\n    vec3 pos = ro;\n    float d = 1e10;\n    \n   \tfor (int i = 0; i < MARCH_STEP; i++)\n    {\n        float dst = length( ro - pos );\n        \n        if (dst > dist)\n        {\n            return false;\n            \n        }\n\n        d = op( d, mapRock( entity, index, pos ) );\n\n        if (d > 0.0001)\n        {\n            pos += rd * d;\n\n            continue;\n\n        }\n\n        vec3 normal = getNormalRock( entity, index, pos );\n\n        Singularity singularity = getSingularity( iTime );\n\n        vec3 material = vec3(1.0, 0.75, 1.0);\n\n        vec3 dir = normalize( singularity.position - pos );\n        float radius = SINGULARITY_RADIUS * 1.25 * (0.5 + sin( abs( singularity.force ) * PI ) * 0.5);\n        float power = (1.0 - min( 1.0, length( singularity.position - pos ) / radius )) * (1.0 - abs( singularity.force ));\n\n        vec3 sun_light = phong( rd, sun_direction, normal, material.x, material.y, material.z ) * vec3(0.5, 0.5, 0.75);\n        vec3 sin_light = phong( rd, dir, normal, material.x, material.y, material.z ) * diffuse( dir, normal, 1.0 ) * power * vec3(0.75, 0.75, 1.0);\n\n        depth = min( 1.0, dst / MARCH_DISTANCE );\n        color = mix( sun_light * 0.25 + sin_light * 25.0, background, depth );\n        dist = dst;\n\n        return true;\n\n\n    }\n    \n    return false;\n}\n\nbool marchRock ( const in vec3 rd, const in vec3 ro, const in int index, const in int count, const in vec3 background, inout float dist, inout float depth, inout vec3 color )\n{\n   \tEntity entity = getEntity( iChannel0, index, count, iResolution.xy );\n\n    return dist > length( ro - entity.position ) - entity.radius / 2.0 && boundingSphere( rd, ro, entity.position, entity.radius ) && march( rd, ro, index, entity, count, background, dist, depth, color );\n    \n}\n\nvoid marchSingularity ( const in vec3 rd, const in vec3 ro, const in float dist, inout vec3 color, inout vec2 distortion )\n{  \n    Singularity singularity = getSingularity( iTime );\n    \n    if (\n        singularity.radius <= 0.0 ||\n        !boundingSphere( rd, ro, singularity.position, singularity.radius )\n        \n    )\n    {\n        return;\n        \n    }\n    \n    vec3 pos = ro;\n    float d = 1e10;\n    \n   \tfor (int i = 0; i < MARCH_STEP; i++)\n    {\n        float dst = length( ro - pos );\n        \n        if (dst < dist)\n        {\n            d = op( d, mapSingularity( singularity, pos ) );\n\n            if (d > 0.0001)\n            {\n                pos += rd * d;\n\n                continue;\n\n            }\n\n            float radius = singularity.radius;\n            vec3 normal = getNormalSingularity( singularity, pos );\n            vec3 p = pos + normal;\n            \n            distortion = (cross( p, singularity.position ).xz - cross( singularity.position, p ).xz) * (1.0 - singularity.radius / SINGULARITY_RADIUS);\n            \n        }\n        \n        break;\n        \n    }\n    \n}\n\nvec4 rendering ( const in vec3 rd, const in vec3 ro, const in vec2 uv, const in vec2 resolution )\n{\n    vec3 background = mix( vec3(0.0), vec3(0.25, 0.25, 0.375), dot( rd, sun_direction ) );\n    float depth = -1.0;\n    vec3 color = background;\n    vec2 distortion = vec2(0.0);\n    \n    vec2 tile = vec2(TileSize);\n    \n\tivec2 AABB_coord = ivec2(floor(uv * resolution) / floor(resolution / tile));\n    \n    vec2 tile_resolution = vec2(ivec2(listResolution / tile));\n    \n    ivec2 tile_start_coord = ivec2(vec2(AABB_coord) * tile_resolution);\n    ivec2 tile_end_coord =  ivec2(vec2(AABB_coord + 1) * tile_resolution);\n    \n    ivec2 tile_fix_resolution = tile_end_coord - tile_start_coord;\n    \n    int add = 0;\n    \n    float dist = MARCH_DISTANCE;\n    int count = EntityCount;\n\n    for (int index = 0, len = int(tile_resolution.x * tile_resolution.y); index < len; index++)\n    {\n        ivec2 tile_coord = ivec2(\n           modI( float(index), float(tile_fix_resolution.x) ),\n           index / tile_fix_resolution.x\n            \n        );\n        \n        vec4 pixel = texelFetch( iChannel1, tile_start_coord + tile_coord, 0 );\n        \n        int i = index * 4;\n\n        pixel.r == 1.0 && marchRock( rd, ro, i + 0, count, background, dist, depth, color );\n        pixel.g == 1.0 && marchRock( rd, ro, i + 1, count, background, dist, depth, color );\n        pixel.b == 1.0 && marchRock( rd, ro, i + 2, count, background, dist, depth, color );\n        pixel.a == 1.0 && marchRock( rd, ro, i + 3, count, background, dist, depth, color );\n\n    }\n    \n    marchSingularity( rd, ro, dist, color, distortion );\n    \n    #ifdef DEBUG_LOOP\n        color += vec3(float(end - start) / float(count), 0.0, 0.0);\n    #endif\n    \n    #ifdef DEBUG_CULLING\n        color += vec3(float(add) / 25.0, 0.0, 0.0);\n\n    #endif\n    \n    if (depth > 0.0)\n    {\n    \tdepth = (depth < 0.25 ? (1.0 - depth / 0.25) : (depth - 0.25) * 0.25);\n        \n    }\n    \n    return vec4(color.b, depth, distortion.rg);\n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    vec2 coord = fragCoord;\n    \n    if (coord.x <= floor(resolution.x / 2.0))\n    {\n    \tvec2 uv = restoreCheckerCoord( coord ) / resolution;\n        Camera cam = createCamera( iMouse, iTime );\n        vec3 rd = yawPitchToDirection( cam.direction, (uv - 0.5) * getAspect( resolution.xy ) + 0.5, cam.fov );\n\n        fragColor = rendering( rd, cam.position, uv, resolution );\n        \n    }\n    else\n    {\n        discard;\n        \n    }\n\n}","name":"Buffer C","description":"","type":"buffer"}]}