{"ver":"0.1","info":{"id":"msG3D1","date":"1678478363","viewed":58,"name":"Falling sand testing","username":"Peace","description":"Falling sand test. (Not finished)","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["fallingsand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord);\n    vec4 ui = get(iChannel0, icoord);\n    vec3 sim = CELLS[int(get(iChannel1, ivec2(fragCoord / float(PIXEL_SIZE))).r)].color;\n    fragColor = vec4(ui.a > 0.0 ? ui.rgb : sim, 1.0);\n    //fragColor.rgb = get(iChannel2, ivec2(fragCoord / float(PIXEL_SIZE))).rgb / 8.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drawing GUI\n\nvec4 col = vec4(0);\nvec2 coord = vec2(0);\nivec2 icoord = ivec2(0);\nivec2 res = ivec2(0);\n\nbool rect(int x, int y, int w, int h)\n{\n    return isPointInsideRect(icoord.x, icoord.y, x, y, w, h);\n}\n\nvoid drawInventory(int offset, int size) // returns inventory UI box\n{\n    for(int i = 0; i < CELLS.length(); ++i)\n    {\n        if (rect(offset, res.y - (i + 1) * (size + offset), size, size))\n            col = vec4(CELLS[i].color, 1.0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0);\n    coord = fragCoord;\n    icoord = ivec2(fragCoord);\n    res = ivec2(iResolution.xy);\n    \n    const int inventory_offset = 4;\n    const int inventory_size = 32;\n    \n    // Draw inventory\n    drawInventory(inventory_offset, inventory_size);\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Configurations\nconst int PIXEL_SIZE = 4;\nconst int BRUSH_SIZE = 16;\nconst float SPEED = 1.;\n\n// Cell Types\nconst int EMPTY = 0;\nconst int SAND = 1;\nconst int WATER = 2;\nconst int SOLID = 3;\nconst int STEAM = 4;\nstruct Cell\n{\n    int id;\n    vec3 color;\n    float density;\n};\nconst Cell CELLS[] = Cell[](\n    Cell(EMPTY, vec3(0), 1.222),\n    Cell(SAND, vec3(1.0, 0.7, 0.6), 1400.0),\n    Cell(WATER, vec3(0.3, 0.7, 1.0), 1000.0),\n    Cell(SOLID, vec3(0.3, 0.3, 0.4), 10000.0),\n    Cell(STEAM, vec3(0.8), 1.5)\n);\n// Directions\nconst int HERE = 0;\nconst int UP_LEFT = 1;\nconst int UP = 2;\nconst int UP_RIGHT = 3;\nconst int LEFT = 4;\nconst int RIGHT = 5;\nconst int DOWN_LEFT = 6;\nconst int DOWN = 7;\nconst int DOWN_RIGHT = 8;\nconst ivec2 DIRS[] = ivec2[](ivec2(0, 0), ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1), ivec2(-1, 0), ivec2(1, 0), ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1));\n\n\n// Key Codes\nconst int KEY_SPACE = 32;\nconst int KEY_TAB = 9;\n\n// Functions\nvec4 get(sampler2D tex, ivec2 coord)\n{\n    return texelFetch(tex, coord, 0);\n}\n\nbool isPointInsideRect(int px, int py, int x, int y, int w, int h)\n{\n    return px >= x && py >= y && px < x + w && py < y + h;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}  ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Simulation buffer: Updates cell direction vectors\n\n\nivec2 icoord = ivec2(0);\nint curr = EMPTY;\n\nint getCell(ivec2 coord)\n{\n    if (!isPointInsideRect(icoord.x + coord.x, icoord.y + coord.y, 0, 0, int(iResolution.x), int(iResolution.y)))\n        return SOLID;\n    return int(texelFetch(iChannel0, icoord + coord, 0).r);\n}\n\nint invDir(int dir)\n{\n    switch(dir)\n    {\n    case UP_LEFT: return DOWN_RIGHT;\n    case UP: return DOWN;\n    case UP_RIGHT: return DOWN_LEFT;\n    case LEFT: return RIGHT;\n    case RIGHT: return LEFT;\n    case DOWN_LEFT: return UP_RIGHT;\n    case DOWN: return UP;\n    case DOWN_RIGHT: return UP_LEFT;\n    }\n    return HERE;\n}\n\nint move(int cell, int dir)\n{\n    //if (curr == cell && getCell(DIRS[dir]) == EMPTY)\n    //    return dir;\n    //if (curr == EMPTY && getCell(-DIRS[dir]) == cell)\n    //    return invDir(dir);\n    //return HERE;\n    // curr = EMPTY  cell = WATER, DIR = EMPTY\n    if (curr == cell && CELLS[getCell(DIRS[dir])].density < CELLS[cell].density)\n        return dir;\n    if (curr != cell && CELLS[curr].density < CELLS[getCell(-DIRS[dir])].density)\n        return invDir(dir);\n    return HERE;\n}\n\nint fall(int cell)\n{\n    return move(cell, DOWN);\n}\n\nint roll(int cell)\n{\n    int dir = rand(vec2(icoord) + iTime) > 0.5 ? DOWN_RIGHT : DOWN_LEFT;\n    int mov = move(cell, dir);\n    if (mov == 0) \n        mov = move(cell, dir == DOWN_RIGHT ? DOWN_LEFT : DOWN_RIGHT);\n    return mov;\n}\n\nint flow(int cell)\n{\n    int dir = rand(vec2(icoord) + vec2(31519.251, 21591.6) + iTime) > 0.5 ? RIGHT : LEFT;\n    int mov = move(cell, dir);\n    if (mov == 0) \n        mov = move(cell, dir == RIGHT ? LEFT : RIGHT);\n    return mov;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    icoord = ivec2(fragCoord);\n    curr = getCell(ivec2(0));\n    \n    int dir = 0;\n    if (dir == 0) dir = fall(SAND);\n    if (dir == 0) dir = fall(WATER);\n    if (dir == 0) dir = roll(SAND);\n    if (dir == 0) dir = flow(WATER);\n    \n    fragColor = vec4(dir, curr, 0.0, 0.0);      \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Simulation buffer: Updates cell types based on direction vectors\n\n#define PI 3.14159265\n\nivec2 icoord = ivec2(0);\n\nbool insideBrush(int radius)\n{\n    ivec2 d = ivec2(iMouse.xy / float(PIXEL_SIZE)) - icoord;\n    return iMouse.z > 0.0 && d.x * d.x + d.y * d.y < int(float(radius * radius) / float(PIXEL_SIZE * PIXEL_SIZE));\n}\n\nbool isKeyPressed(int key)\n{\n    return get(iChannel2, ivec2(key, 0)).r > 0.0;\n}\n\nbool sim(ivec2 dir, inout vec4 fragColor)\n{\n    ivec2 c = DIRS[int(get(iChannel0, icoord + dir).r)];\n    if (c == -dir)\n    {\n        fragColor.r = get(iChannel0, icoord + dir).g;\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    icoord = ivec2(fragCoord);\n    \n    // If not initialized, initialize all cells to EMPTY\n    if (fragColor.a == 0.0)\n    {\n        fragColor = vec4(EMPTY, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Draw cells using a brush\n    if (insideBrush(BRUSH_SIZE))\n    {\n        fragColor.r = float(isKeyPressed(KEY_TAB) ? SOLID : SAND);\n        return;\n    }\n    \n    fragColor = get(iChannel1, icoord);\n    \n    if (iFrame % int(1.0 / SPEED) != 0) return;\n    if (isKeyPressed(KEY_SPACE)) return;\n    \n    const ivec3 f = ivec3(0, 1, -1);\n    const ivec2 DIRS[] = ivec2[](ivec2(0, 1), ivec2(0, -1), ivec2(1, 1), ivec2(-1, -1), ivec2(-1, 1), ivec2(1, -1), ivec2(1, 0), ivec2(-1, 0));\n    for(int i = 0; i < DIRS.length(); ++i)\n        if (sim(DIRS[i], fragColor)) \n            break;\n}\n","name":"Buffer C","description":"","type":"buffer"}]}