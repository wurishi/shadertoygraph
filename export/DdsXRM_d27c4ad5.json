{"ver":"0.1","info":{"id":"DdsXRM","date":"1668643548","viewed":32,"name":"Spheretastic","username":"toekey","description":"Glass Sphere, Lambertian Sphere, and a Point Light, ray traced.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 intersectSphere(vec3 sphereOrigin, float sphereRadius, vec3 rayOrigin, vec3 rayDirection)\n{\n    float a, b, c, discriminant, t, d;\n    a = dot(rayDirection, rayDirection);\n    b = 2.0*(dot(rayOrigin, rayDirection) \n        - dot(sphereOrigin, rayDirection));\n    c = dot(rayOrigin, rayOrigin)\n        + dot(sphereOrigin, sphereOrigin)\n        - 2.0*dot(sphereOrigin, rayOrigin)\n        - sphereRadius * sphereRadius;\n        \n    discriminant = b*b-4.0*a*c;\n    if (discriminant >= 0.0) {\n        d = sqrt(discriminant);\n        return vec2(-d-b, d-b)/(2.0*a);\n    } else {\n        return vec2(-1.0, -1.0);\n    }\n}\n\nvec3 calculateRefraction(float n1, float n2, vec3 u, vec3 z)\n{\n    float theta1 = acos(dot(u,z));\n    float theta2 = asin(n1/n2*sin(theta1));\n    vec3 w = u - dot(u,z)*z;\n    w = normalize(w);\n    return cos(theta2)*z + sin(theta2) * w;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 coord = vec3(fragCoord/iResolution.xy * 2.0 - 1.0, 3.0);\n    coord.x = coord.x*iResolution.x/iResolution.y;\n\n    vec3 rayOrigin = vec3(0.0, 0.0, 5.0);\n    vec3 rayDirection = coord - rayOrigin;\n    \n    vec3 sphereOrigin_g = vec3(0.0, 0.0, 0.0);\n    float sphereRadius_g = 1.0;\n    float n1 = 1.0, n2 = 1.33;\n    \n    float f_sphere = 3.14/3.0;\n    vec3 sphereOrigin = vec3(2.0*sin(f_sphere*iTime), 1.0,-6.0);\n    float sphereRadius = 1.5;\n    \n    float f_light = 3.14/2.0;\n    vec3 lightOrigin = 3.0 * vec3(6.0*sin(f_light*iTime), 4.0, 6.0*cos(f_light*iTime));\n    //vec3 lightOrigin = 3.0 * vec3(5.0, 4.0, 3.0);\n    vec3 lightColor = 400.0 * vec3(1.0, 1.0, 1.0);\n    vec3 lightDirection;\n    float lightDistance;\n    \n    vec3 normal, intersection, brightness;\n    \n    float t, t_g;\n    t = intersectSphere(sphereOrigin, sphereRadius, rayOrigin, rayDirection).x;\n    t_g = intersectSphere(sphereOrigin_g, sphereRadius_g, rayOrigin, rayDirection).x;\n    \n\n    // Output to screen\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((t >= 0.0) && (t < t_g || t_g < 0.0)) {\n        intersection = rayOrigin + rayDirection * t;\n        normal = normalize(intersection - sphereOrigin);\n        lightDirection = lightOrigin - intersection;\n        lightDistance = sqrt(dot(lightDirection, lightDirection));\n        brightness = lightColor/(lightDistance*lightDistance)*dot(normalize(lightDirection), normal);\n        fragColor = vec4(brightness, 1.0);\n    } else if (t_g >= 0.0) {\n        intersection = rayOrigin + rayDirection * t_g;\n        normal = normalize(sphereOrigin_g - intersection);\n        rayDirection = calculateRefraction(n1, n2, normalize(rayDirection), normal);\n        t_g = intersectSphere(sphereOrigin_g, sphereRadius_g, intersection, rayDirection).y;\n        intersection = intersection + rayDirection * t_g;\n        normal = normalize(intersection - sphereOrigin_g);\n        rayDirection = calculateRefraction(n2, n1, normalize(rayDirection), normal);\n        t = intersectSphere(sphereOrigin, sphereRadius, intersection, rayDirection).x;\n        if (t >= 0.0) {\n            intersection = intersection + rayDirection * t;\n            normal = normalize(intersection - sphereOrigin);\n            lightDirection = lightOrigin - intersection;\n            lightDistance = sqrt(dot(lightDirection, lightDirection));\n            brightness = lightColor/(lightDistance*lightDistance)*dot(normalize(lightDirection), normal);\n            fragColor = vec4(brightness, 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}