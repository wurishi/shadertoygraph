{"ver":"0.1","info":{"id":"msKXDc","date":"1682100109","viewed":50,"name":"distorted mandelbrot ","username":"shader314159","description":"Distorted mandelbrot, where z = f(z,c) is a general quadratic in z and c.  \nArrow keys pan, Z/X zoom in and out. ","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["fractal","mandelbrot","orbit"],"hasliked":0,"parentid":"clSXDy","parentname":"orbit path mapper"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_iterations 400\n\n#define HALFPI (3.14159/2.0)\n\n\nvec2 map1(vec2 m, vec2 z, vec2 c)  // standard mandelbrot\n{ \n    return vec2(z.x*z.x - z.y*z.y + c.x, 2.0*z.x*z.y + c.y);\n}\n\nvec2 map2(vec2 m, vec2 z, vec2 c)  // weird rectilinear thing\n{\n    return vec2(z.x*z.x + z.y*z.y + c.x, 2.0*z.x*z.y + c.y);\n}\n\nvec2 map3(vec2 m, vec2 z, vec2 c)  // alternate mandelbrot\n{\n        return -1.0*vec2(z.x*z.x - z.y*z.y + c.x, 2.0*z.x*z.y + c.y);\n}\n\nvec2 map4(vec2 m, vec2 z, vec2 c)  // variant alternate mandelbrot\n{\n        return -0.9*vec2(z.x*z.x - z.y*z.y + c.x, 2.0*z.x*z.y + c.y);\n}\n\n\nvec2 map5(vec2 m, vec2 z, vec2 c)  // another alternate mandelbrot\n{\n        return vec2(z.x*z.x - z.y*z.y + 1.5*c.x, 2.0*z.x*z.y + 1.5*c.y);\n}\n\n\nvec2 mapN(vec2 m, vec2 z, vec2 c)  // generalized quadratic mapping\n{\n    float t = iMouse.x*0.1 + iTime*0.01-10.0;\n     mat2 MZx = mat2(sin(t*0.8+HALFPI), sin(t*0.72), sin(t*0.86), sin(t*0.81-HALFPI)); \n     mat2 MCx = mat2(sin(t*0.91), sin(t*0.79), sin(t*0.98), sin(t*0.74)); \n     mat2 MMx = mat2(sin(t*0.85), sin(t*0.82), sin(t*0.77), sin(t*0.87)); \n     vec2 VZx = vec2(sin(t*0.90),sin(t*0.99));\n     vec2 VCx = vec2(sin(t*0.68+HALFPI),sin(t*0.95));\n\n     mat2 MZy = mat2(sin(t*0.7), sin(t*0.84+HALFPI), sin(t*0.75+HALFPI), sin(t*0.94)); \n     mat2 MCy = mat2(sin(t*0.67), sin(t*0.97), sin(t*0.93), sin(t*0.69)); \n     mat2 MMy = mat2(sin(t*0.71), sin(t*0.78), sin(t*0.89), sin(t*0.73)); \n     vec2 VZy = vec2(sin(t*0.92),sin(t*0.88));\n     vec2 VCy = vec2(sin(t*0.96),sin(t*0.76+HALFPI));\n\n    float x = dot(z,MZx*z) + dot(c,MCx*c) + dot(z,MMx*c) + dot(VZx,z) + dot(VCx,c); \n    float y = dot(z,MZy*z) + dot(c,MCy*c) + dot(z,MMy*c) + dot(VZy,z) + dot(VCy,c); \n    return vec2(x,y);    \n}\n\n\nvec2 map(vec2 m, vec2 z, vec2 c)\n{\n    return mapN(m,z,c);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat calctrap(vec2 z) {\n\tvec2 uv = iMouse.xy / iResolution.xy;\n    uv = 2.0*uv-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.3;\n    \n    uv = vec2(0.0,0.0);\n    \n    float point = length(z-uv)/3.0;\n\t\n    return point;\n}\n\nfloat sdfLineSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    float d2 = dot(ab,ab);\n    if (d2 < 0.0001) {\n        return distance(p,a);\n    }\n    \n    float t = max(0.0, min(1.0, dot(p-a,b-a) / d2));\n    vec2 q = a + t * (b-a);\n    return distance(p,q);\n}\n\nvec2 complexFromScreen(vec2 p) {\n\tvec2 uv = p / iResolution.xy;\n    uv = 2.0*uv-1.0;\n    float zoom = pow(2.0, texelFetch( iChannel0, ivec2(0,0), 0 ).z);\n//    uv *= (1.0 + texelFetch( iChannel0, ivec2(0,0), 0 ).z); \n    uv *= zoom;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.3;\n    uv += texelFetch( iChannel0, ivec2(0,0), 0 ).xy;  // offset\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = pow(2.0, texelFetch( iChannel0, ivec2(0,0), 0 ).z);\n\n    vec2 m = complexFromScreen(iMouse.xy);\n    vec2 p = complexFromScreen(fragCoord.xy);\n\n    fragColor = vec4(0., 0., 0., 1.0); // black background\n\n    // compute the orbit, with trap at the origin.\n    vec2 z = p;\n    vec2 c = p;\n    float n = 0.0;\n    float trap = 100.0;\n    for (int i = 0; i < NUM_iterations; ++i) {\n        z = map(m, z,c);\n        \n        trap = min(trap, calctrap(z));\n\n        // n is how long our series stayed nearby\n        if (length(z) < 4.0) {\n          n = n + 1.0;\n        }\n    }\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if (n < 400.0) {\n        // smaller n means faster escape time\n        float g = mod(n,10.0)/20.0;  \n        fragColor = vec4(g,g,g,1.0);\n    }\n    \n\n    // if our orbit came close to origin, color it accordingly.\n    if (trap < 0.01) {\n        fragColor = vec4(hsv2rgb(vec3(1.0/(1.0+trap*1000.0) - 0.3,1.0,1.0)),1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// using widgets and prints from https://www.shadertoy.com/view/MdKGRw\n\n\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_LOWER_X = 88;\nconst int KEY_LOWER_Z = 90;\n\nvec2 handleKeyboardOffset(float zoom, vec2 offset) {\n    float velocity = pow(2.0, zoom) * 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    offset += (left + up + right + down) * velocity;\n    \n    return offset;\n}\n\nfloat handleKeyboardZoom(float zoom) {\n    float zoom_velocity = 0.1; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    float zoom_out = texelFetch(iChannel1, ivec2(KEY_LOWER_X, 0), 0).x;\n    float zoom_in = texelFetch(iChannel1, ivec2(KEY_LOWER_Z, 0), 0).x;\n\n    zoom += (zoom_in - zoom_out) * zoom_velocity;\n    \n    return zoom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    float zoom = texelFetch( iChannel0, ivec2(0, 0), 0).z;\n    \n    offset = handleKeyboardOffset(zoom, offset);\n    zoom = handleKeyboardZoom(zoom);\n//    zoom = 0.0;\n    \n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, zoom, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}