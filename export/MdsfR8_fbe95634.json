{"ver":"0.1","info":{"id":"MdsfR8","date":"1494937361","viewed":98,"name":"Pruebas_03","username":"ps","description":"raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq https://iquilezles.org/articles/rmshadows\n// iluminación de iq https://iquilezles.org/articles/outdoorslighting\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// la base del codigo paret de esta https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define PI 3.14159265359\n\n// define el terreno (signed distanced function) dada unas coordenadas x y z devuelve si ha colisionado o no\nfloat terrainSDF (vec2 posxz){\n    float x=posxz.x;\n    float  z=posxz.y;\n    return 3.2 + 0.1*sin(20.0*x)*cos(20.0*z);\n}\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n    return terrainSDF(posxz);\n}\n// \nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 pos;\n    float t = tmin;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n         pos = ro + t*rd;\n\t\tfloat h = pos.y - scene( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec2  eps = vec2( 0.0001 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 makeFog(in vec3 realColor, vec3 fogColor, float distancia, float fogDensity){\n    float theE = 2.718281828459045235360;\n\tfloat res = 1.0/(pow(theE,((distancia*fogDensity)*(distancia*fogDensity)*(distancia*fogDensity))));\n    return mix(fogColor,realColor,res);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 nor, vec3 ro) {\n \n    /*vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n  //  vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(10.0 * sin(iTime),  2.0,10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;*/\n    vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n   // vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(ro.x+10.0 * sin(iTime),\n                          ro.y+2.0,\n                          ro.z+10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;\n}\n\nfloat fogAngleFixer(vec3 angle){\n\treturn clamp(-angle.y*2.0+0.1,0.0,1.0);   \n}\nvec3 getBackground(vec3 angle){\n    float heigh = clamp(angle.y*2.0+0.2,0.0,1.0);\n    return vec3(0.3*(1.0-heigh),0.5*heigh*0.5+0.5,1.0*heigh/2.0+0.5);\n}\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n    float fogDensity = 0.1;\n    fogDensity*=fogAngleFixer(rd);\n    vec3 fogColor = vec3(1.0,1.0,1.0);\n    //return vec4(fogDensity);\n \n\tfloat t = intersect( ro, rd, tmin, tmax );\n    if (t>tmax){\n\n        //draw background\n        col = getBackground(rd);// colorBackground;\n        t = -1.0;\n        col = makeFog(col, fogColor, tmax, fogDensity);\n    \n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        vec3 matGround=colorGround;\n        vec3 nor = calcNormal( pos, t );\n      //   return vec4 (nor,1. );\n        vec3 ref = reflect( rd, nor );\n\n        vec3 K_a = vec3(0.5, 0.5, 0.5);\n        vec3 K_d = vec3(0.7, 0.2, 0.2);\n        vec3 K_s = vec3(0.2, 0.2, 0.2);\n        float shininess = 1.0;\n\n        vec3 p=pos;\n        vec3 eye=ro;\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye, nor,ro);\n        //return vec4(color,1.0);\n\t\tcol = makeFog(color, fogColor, t*3.0, fogDensity);\n        \n    }\n\treturn vec4(col,t);\n}\n\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\t//vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    //vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n   \n    vec2  m = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\ndir.xz = rot2D(dir.xz, 180. * m.x);\n    \n    vec3 ro = vec3(0.0, 4.8, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,dir); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}