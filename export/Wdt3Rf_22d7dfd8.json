{"ver":"0.1","info":{"id":"Wdt3Rf","date":"1569000970","viewed":498,"name":"bluenoise Animation","username":"Carandiru","description":"original shader: https://www.shadertoy.com/view/XtGBDc\nexperimentally animating blue noise to verify fft spectrum.\nwith nearest sampling and attempting linear sampling.\nfft now is showing result of last 4 frames averaged over time.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["fft","bluenoise","jitter","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// experimental animation of blue noise\n// animation is judged by the fft output\n// fft output is the result of the animation, taking the last\n// 4 frames into account to give a fairer assesment of the\n// animations destruction to the blue noise properties \n\n// good for checking your blue noise animation\n// that it is still blue noise w/o any significant dc components\n// added (see bufferA)\n// example showing this animation is no good\n\n// *challenge* is to make animation of blue noise with fft output\n// that looks the same or similar to the fft result of non-animated \n// blue noise.\n\n// ################################################## //\n// Buffer A - section ANIMATED BLUE NOISE BEGIN / END //\n// ################################################## //\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\t[...]\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n        \n        vec3 cb = col;\n        col *= vec3(0.005, 0.0, 6.0);// * 8e-3;\n\n        // Compress dynamic range.\n        col.rgb *= 6.0;\n        col.rgb = 1.5 * col.rgb / (1.0 + col.rgb);\n        col = mix(cb, col, 0.5f);\n    }\t\n    else\n#endif\n    {\n        col = pow(textureLod(iChannel0, q, 0.).rgb, vec3(1.0/2.2));\n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// experimental animation of blue noise\n// animation is judged by the fft output\n// fft output is the result of the animation, taking the last\n// 4 frames into account to give a fairer assesment of the\n// animations destruction to the blue noise properties \n\n// good for checking your blue noise animation\n// that it is still blue noise w/o any significant dc components\n// added (see bufferA)\n// example showing this animation is no good\n\n// *challenge* is to make animation of blue noise with fft output\n// that looks the same or similar to the fft result of non-animated \n// blue noise.\n\n// From Dave Hoskins: https://www.shadertoy.com/view/4djSRW.\nfloat hash(vec3 p3){\n    p3 = fract(p3 * 0.1031);\n    p3 += dot(p3,p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// From iq: https://www.shadertoy.com/view/4sfGzS.\nfloat noise(vec3 x){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hash(i+vec3(0, 0, 0)), \n                       hash(i+vec3(1, 0, 0)),f.x),\n                   mix(hash(i+vec3(0, 1, 0)), \n                       hash(i+vec3(1, 1, 0)),f.x),f.y),\n               mix(mix(hash(i+vec3(0, 0, 1)), \n                       hash(i+vec3(1, 0, 1)),f.x),\n                   mix(hash(i+vec3(0, 1, 1)), \n                       hash(i+vec3(1, 1, 1)),f.x),f.y),f.z);\n}\n\n\nvec3 to_iso(vec3 v)\n{\n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    return iso;\n}\n\nfloat bluenoise(vec2 x, vec2 dir) {\n    vec2 i = floor(dir);\n    vec2 f = fract(dir);\n    f = f*f*(3.0-2.0*f);\n\t\n    return textureLod(iChannel0, (x.xy + (i.xy + f.xy))/iChannelResolution[0].xy, 0.0f).r;\n}\n\n\nfloat grain_source(vec3 x){\n    //x.xy *= (iMouse.xy / iResolution.xy) * 2.0f - 1.0f;\n    vec2 direction = vec2(cos(x.z),sin(x.z)) * length(128.0f * 0.25f);\n    float center = bluenoise(x.xy, direction.xy);\n\n\n    \n\treturn center;\n}\n\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n\nfloat singlewave(float x, float t)\n{\n  \tfloat X = ( x - t * t );\n\treturn( -cos(X) * exp(-X * X) );\n}\nfloat multiwave(float x, float t)\n{\n\treturn( singlewave(t, x) );\n}\n\n// ################################################################ //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    if (fragCoord.y > SIZE)\n        p*=0.75;\n    \n\n    p *= globalScale;\n    \n    // #### ANIMATED BLUE NOISE BEGIN ### //\n        vec2 x = fragCoord;\n    // Alternatively use iTime here instead and change the grain_rate\n    // parameter to correspond to frames-per-second.\n    float t = (float(iTime));\n   \n    float bn = textureLod(iChannel0, x/iChannelResolution[0].xy, 0.0).r;\n    \n    bn = fract(bn + t);\n    \n    float O = 2.0f * abs(bn - 0.5f);\n    \n    //const float grain_rate = 1.0f/33.3f * 2501.618f;\n    \n    //float O = grain_source(vec3(x, (grain_rate*t)));\n\n    //O = smoothstep(0.0f, 1.0f, O);\n\n    \n    /*\n    float scale = 4.0f;\n    float frequency = 0.0625f;\n    float timer = sin(iTime);\n\tvec2 uv = fragCoord;  \n\n    vec2 jitter = mix(-1.0f, 1.0f, bool(iFrame & 1)) * scale\n                   \n     * vec2(cos(multiwave(frequency, timer)), -sin(multiwave(frequency, timer)));\n    \n    float v;\n   \tv = texture(iChannel0, (uv + jitter) / 1024.0f).x;\n    \n    // show w/o linear interpolation\n    if ( int(iTime) % 16 > 8 ) {\n    \tv = texelFetch(iChannel0, ivec2(uv + jitter) & 1023, 0).x;// proper blue noise\n    }\n    */\n    // #### ANIMATED BLUE NOISE END ### //\n    \n    fragColor = vec4(vec3(O),1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define INV_TEMPORAL_FRAMES_HALF (1.0f / 2.0f)\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.25)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 temporal_noise = texelFetch(iChannel1, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;\n    temporal_noise += texelFetch(iChannel0, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;    \n    \n    fragColor = temporal_noise;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec4 temporal_noise = texelFetch(iChannel1, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;\n    temporal_noise += texelFetch(iChannel0, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;    \n    \n    fragColor = temporal_noise;\n}","name":"Buffer D","description":"","type":"buffer"}]}