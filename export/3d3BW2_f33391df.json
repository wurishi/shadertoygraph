{"ver":"0.1","info":{"id":"3d3BW2","date":"1606055791","viewed":126,"name":"A Snowman for Christmas","username":"Dombass","description":"hacked together a snowman for christmas","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["christmas","snow","winter","snowman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 a, vec3 b, float r) {\n    return length(max(abs(a)-b, 0.)) - r;\n}\n\n\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat fl2(vec3 p, float scene)\n{\n    float direction = noise(p+vec3(1.,iTime*0.75,1.0));\n    float height = 0.1; //dont bend! ascend! by going above about 0.3\n    float f = (scene + direction*height);\n \tfloat a = abs(f);\n    return min(10.-f, a);\n}\n\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance,\n             in float b, \n             in vec3 fogColor) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*b );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat r(float n){return fract(sin(n) * 43758.5453123);}\nfloat r(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat ns(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(r(fl), r(fl + 1.0), fc);\n}\n\t\nfloat ns(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(r(b), r(b + d.yx), f.x), mix(r(b + d.xy), r(b + d.yy), f.x), f.y);\n}\n\n\n\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat tree(in vec3 p) {\n\tfloat top = sdCone(p, vec2(1., 0.2), 3.);\n    p.y += 2.;\n    float mid = sdCone(p, vec2(0.9, 0.4), 4.);\n    p.y += 2.;\n    float bottom = sdCone(p, vec2(0.8, 0.5), 6.);\n    p.y += 4.;\n    float trunk = sdCone(p, vec2(0.3), 6.);\n    \n    return min(trunk, min(bottom, min(mid, top)));\n}\n\nvec4 forest(in vec3 p, float snowFactor) {\n\tfloat result = 1.;\n    p.z += 30.;\n    p.x -= 70.;\n    \n    vec3 base = vec3(0.3, 0.5, 0.2);\n    vec3 snow = vec3(0.7, 0.7, 0.9);\n    base = mix(base, snow, snowFactor);\n    \n    float amount = noise(p*4.);\n    vec3 col = mix(base, snow, amount);\n    \n    float c = 5.0;\n    for (int i = 0; i < 4; i++) {       \n    \tfloat q = mod(p.x+0.5*c,c)-0.5*c;\n    \tresult = min(result, tree(vec3(q, p.y, p.z)));\n        p.z += 25.0; \n    }\n    \n    return vec4(col, result);\n}\n\nvec4 snowman(in vec3 pos) {\n\tfloat bottom = sphereSDF(pos, 3.5);\n    pos.y -= 4.;\n    pos.x -= 0.25;\n    float mid = sphereSDF(pos, 2.5);\n    pos.y -= 3.;\n    pos.x += 0.5;\n    float top = sphereSDF(pos, 2.);\n    return vec4(1., 1., 1., min(bottom, min(mid, top)));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nvec4 carrot(in vec3 pos) {\n\tvec3 col = vec3(1.0, 0.5, 0.2);\n    pos.y -= 7.;\n    pos.z -= 2.;\n    mat4 rot = rotationX(-3.14/2.);\n    vec4 temp = vec4(pos, 1.);\n    temp *= rot;\n    pos = temp.xyz;\n    \n    float shape = sdRoundCone(pos, 0.3, .1, 1.);\n    return vec4(col, shape);\n}\n\nvec4 eyes(in vec3 pos) {\n\tvec3 col = vec3(0.);\n    pos.y -= 8.;\n    pos.z -= 1.4;\n    pos.x -= 0.5;\n    float leftEye = sphereSDF(pos, 0.2);\n    \n    pos.x += 1.2;\n    pos.z -= 0.15;\n    float rightEye = sphereSDF(pos, 0.2);\n    float shape = min(leftEye, rightEye);\n    return vec4(col, shape);\n}\n\nvec4 compose(in vec4 x, in vec4 y) {\n    if (x.w < y.w) return x;\n    return y;\n}\n\nvec4 environment(in vec3 pos) {\n    float snowFactor = 0.5 + sin(iTime*0.1)*0.5;\n    float amount = noise(pos*2.);\n    vec3 base = vec3(.4, 0.4, 0.2);\n    vec3 snow = vec3(0.7, 0.7, 0.9);\n    base = mix(base, snow, snowFactor);\n    vec3 col = mix(base, snow, amount);\n    pos.y -= amount*0.1;\n\tpos.y += 2.;\n    vec4 ground = vec4(col, sdPlane(pos, vec3(0., 1., 0.), 1.));\n    pos.y += amount*0.1;\n    pos.y -= 15.;\n    pos.x -= 10.;\n    vec4 f = forest(pos, snowFactor);\n    return compose(f, ground);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nvec4 snowfall(in vec3 p) {\n\tvec3 col = vec3(1.);\n    p.y += iTime;\n    p.x += sin(iTime+p.y+p.z)*0.5;\n    p.z -= 15.;\n    float c = 4.;\n    float shape = 1.;\n    for (int i = 0; i < 1; i++) {\n    \tfloat qx = mod(p.x,c)-c*0.5;\n        float snowrep= mix(0.8, 10., p.y/iResolution.y);//4.+sin(iTime)*0.6;\n        float qz = mod(p.z, snowrep)-(snowrep*0.5);\n        \n        float snowrep2=smoothstep(1., 4., p.y);\n        float qy = mod(p.y, snowrep2)-(snowrep2*0.5);\n    \tshape = min(shape, sphereSDF(vec3(qx, qy, qz), 0.0000001));\n\t\tp.z += 15.;    \n        p.x += sin(iTime+p.y+p.z)*0.5;\n        c -= 0.5;\n    }\n    return vec4(col, shape);\n}\n\nvec4 scene(in vec3 pos) {\n    mat4 rot = rotationY(sin(iTime*0.1)*0.75);\n    vec4 temp = vec4(pos, 1.);\n    temp *= rot;\n    pos = temp.xyz;\n    vec4 snowman = snowman(pos);\n    vec4 environment = environment(pos);\n    vec4 carrot = carrot(pos);\n    vec4 eyes = eyes(pos);\n    vec4 face = compose(eyes, carrot);\n    vec4 snowboi = compose(face, snowman);\n    vec4 finalScene = compose(snowboi, compose(snowfall(pos), environment));\n    //vec4 finalScene = compose(snowboi, environment);\n    return finalScene;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ).w + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ).w + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ).w + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ).w );\n}\n\nconst float MAX = 100.; \n\nvec4 RayMarch(vec3 eye, vec3 dir) {    \n    float depth = 0.0;\n    const int limit = int(MAX);\n    vec4 s;\n    float dist;\n    for (int i = 0; i < limit; i++) {\n        s = scene(eye + depth * dir);\n        dist = s.w;\n        \n        if (dist < 0.01) \n        {\n            return vec4(s.xyz, depth);\n        }\n        //else if (depth > 450.) return vec4(0.1, 0.1, 0.2, MAX);\n            \n        depth += dist;\n        \n    }\n    \n    return vec4(0.1, 0.1, 0.2, MAX);\n}\n\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<4; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).w;\n        res = min( res, 4.0*h/t );\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\n\nfloat ssao( in vec2 pixel, in vec4 rayHit,in vec3 eye)\n{\n    const int samples = 8;\n    vec3 lights[samples];\n    lights[0] = vec3(1.);\n    lights[1] = vec3(1., 1., 0.);\n    lights[2] = vec3(0., 1., 0.);\n    lights[3] = vec3(0., 1., 1.);\n    lights[4] = vec3(0., 0., 1.);\n    lights[5] = vec3(1., 0., 1.);\n    lights[6] = vec3(1., 0., 0.);\n    lights[7] = vec3(0.);\n    \n    float ao = 0.0;\n    \n    float noiseSample = ns(pixel);\n\tfor( int i=0; i<samples; i++ )\n\t{\n        vec2 off = vec2(noiseSample*float((i+1)*2));\n        vec3 rayDir = rayDirection(90., iResolution.xy, pixel+off); \n        \n    \tvec3 normal = calcNormal(eye + rayHit.w*rayDir);\n    \tfloat occ = clamp( dot( normal, lights[i] ), 0.2, 1. );\n        ao += occ;\n\t}\n    // average down the occlusion\t\n    return ao/float(samples);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0., 10., 30.);\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);    \n    vec4 dist = RayMarch(eye, rayDir);\n    vec3 lig = vec3(1.);\n    float dif = ssao(fragCoord, dist, eye)*calcSoftshadow(eye + dist.w*rayDir, lig, 0.001, 3.);\n    vec3 mate = dist.xyz;\n    vec3 lig1Colour = vec3(0.8, 0.8, 1.);\n    float falloff = (1.0-dist.w/MAX);\n    vec3 col = mix(vec3(0.1),  mate*dif*lig1Colour, 1.);\n    vec3 fogged = applyFog(col, dist.w, 0.04, vec3(0.0,0.1,0.2));\n    fragColor = vec4(fogged, 1.);\n}","name":"Image","description":"","type":"image"}]}