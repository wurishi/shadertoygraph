{"ver":"0.1","info":{"id":"Xtd3Wl","date":"1472438052","viewed":252,"name":"Reference Perlin Noise","username":"nlguillemot","description":"it's just plain Perlin Noise. I tried to write it based on the descriptions in Ken Perlin's papers. Not sure if 100% correct. Designed to help understand Perlin Noise without considering optimizations. Left click and drag to move around and zoom","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// WebGL doesn't support a % b...\nint imod(int a, int b){ return a - a / b * b; }\nivec3 imod3(ivec3 a, ivec3 b) { return a - a / b * b; }\n\n// pseudo-random numbers for the locations of the integer lattice\n// initialized by init_P()\nint Ptab[512];\n\n// sets the permutation table according to the reference numbers by Ken Perlin\nvoid init_P()\n{\n    // macro just short-hand to set the array values\n    // WebGL's GLSL lacks a good way to initialize arrays...\n    #define SP(index,val) Ptab[index] = val;\n    SP(  0,151)SP(  1,160)SP(  2,137)SP(  3, 91)SP(  4, 90)SP(  5, 15)SP(  6,131)SP(  7, 13)\n    SP(  8,201)SP(  9, 95)SP( 10, 96)SP( 11, 53)SP( 12,194)SP( 13,233)SP( 14,  7)SP( 15,225)\n    SP( 16,140)SP( 17, 36)SP( 18,103)SP( 19, 30)SP( 20, 69)SP( 21,142)SP( 22,  8)SP( 23, 99)\n    SP( 24, 37)SP( 25,240)SP( 26, 21)SP( 27, 10)SP( 28, 23)SP( 29,190)SP( 30,  6)SP( 31,148)\n    SP( 32,247)SP( 33,120)SP( 34,234)SP( 35, 75)SP( 36,  0)SP( 37, 26)SP( 38,197)SP( 39, 62)\n    SP( 40, 94)SP( 41,252)SP( 42,219)SP( 43,203)SP( 44,117)SP( 45, 35)SP( 46, 11)SP( 47, 32)\n    SP( 48, 57)SP( 49,177)SP( 50, 33)SP( 51, 88)SP( 52,237)SP( 53,149)SP( 54, 56)SP( 55, 87)\n    SP( 56,174)SP( 57, 20)SP( 58,125)SP( 59,136)SP( 60,171)SP( 61,168)SP( 62, 68)SP( 63,175)\n    SP( 64, 74)SP( 65,165)SP( 66, 71)SP( 67,134)SP( 68,139)SP( 69, 48)SP( 70, 27)SP( 71,166)\n    SP( 72, 77)SP( 73,146)SP( 74,158)SP( 75,231)SP( 76, 83)SP( 77,111)SP( 78,229)SP( 79,122)\n    SP( 80, 60)SP( 81,211)SP( 82,133)SP( 83,230)SP( 84,220)SP( 85,105)SP( 86, 92)SP( 87, 41)\n    SP( 88, 55)SP( 89, 46)SP( 90,245)SP( 91, 40)SP( 92,244)SP( 93,102)SP( 94,143)SP( 95, 54)\n    SP( 96, 65)SP( 97, 25)SP( 98, 63)SP( 99,161)SP(100,  1)SP(101,216)SP(102, 80)SP(103, 73)\n    SP(104,209)SP(105, 76)SP(106,132)SP(107,187)SP(108,208)SP(109, 89)SP(110, 18)SP(111,169)\n    SP(112,200)SP(113,196)SP(114,135)SP(115,130)SP(116,116)SP(117,188)SP(118,159)SP(119, 86)\n    SP(120,164)SP(121,100)SP(122,109)SP(123,198)SP(124,173)SP(125,186)SP(126,  3)SP(127, 64)\n    SP(128, 52)SP(129,217)SP(130,226)SP(131,250)SP(132,124)SP(133,123)SP(134,  5)SP(135,202)\n    SP(136, 38)SP(137,147)SP(138,118)SP(139,126)SP(140,255)SP(141, 82)SP(142, 85)SP(143,212)\n    SP(144,207)SP(145,206)SP(146, 59)SP(147,227)SP(148, 47)SP(149, 16)SP(150, 58)SP(151, 17)\n    SP(152,182)SP(153,189)SP(154, 28)SP(155, 42)SP(156,223)SP(157,183)SP(158,170)SP(159,213)\n    SP(160,119)SP(161,248)SP(162,152)SP(163,  2)SP(164, 44)SP(165,154)SP(166,163)SP(167, 70)\n    SP(168,221)SP(169,153)SP(170,101)SP(171,155)SP(172,167)SP(173, 43)SP(174,172)SP(175,  9)\n    SP(176,129)SP(177, 22)SP(178, 39)SP(179,253)SP(180, 19)SP(181, 98)SP(182,108)SP(183,110)\n    SP(184, 79)SP(185,113)SP(186,224)SP(187,232)SP(188,178)SP(189,185)SP(190,112)SP(191,104)\n    SP(192,218)SP(193,246)SP(194, 97)SP(195,228)SP(196,251)SP(197, 34)SP(198,242)SP(199,193)\n    SP(200,238)SP(201,210)SP(202,144)SP(203, 12)SP(204,191)SP(205,179)SP(206,162)SP(207,241)\n    SP(208, 81)SP(209, 51)SP(210,145)SP(211,235)SP(212,249)SP(213, 14)SP(214,239)SP(215,107)\n    SP(216, 49)SP(217,192)SP(218,214)SP(219, 31)SP(220,181)SP(221,199)SP(222,106)SP(223,157)\n    SP(224,184)SP(225, 84)SP(226,204)SP(227,176)SP(228,115)SP(229,121)SP(230, 50)SP(231, 45)\n    SP(232,127)SP(233,  4)SP(234,150)SP(235,254)SP(236,138)SP(237,236)SP(238,205)SP(239, 93)\n    SP(240,222)SP(241,114)SP(242, 67)SP(243, 29)SP(244, 24)SP(245, 72)SP(246,243)SP(247,141)\n    SP(248,128)SP(249,195)SP(250, 78)SP(251, 66)SP(252,215)SP(253, 61)SP(254,156)SP(255,180)\n    SP(256,151)SP(257,160)SP(258,137)SP(259, 91)SP(260, 90)SP(261, 15)SP(262,131)SP(263, 13)\n    SP(264,201)SP(265, 95)SP(266, 96)SP(267, 53)SP(268,194)SP(269,233)SP(270,  7)SP(271,225)\n    SP(272,140)SP(273, 36)SP(274,103)SP(275, 30)SP(276, 69)SP(277,142)SP(278,  8)SP(279, 99)\n    SP(280, 37)SP(281,240)SP(282, 21)SP(283, 10)SP(284, 23)SP(285,190)SP(286,  6)SP(287,148)\n    SP(288,247)SP(289,120)SP(290,234)SP(291, 75)SP(292,  0)SP(293, 26)SP(294,197)SP(295, 62)\n    SP(296, 94)SP(297,252)SP(298,219)SP(299,203)SP(300,117)SP(301, 35)SP(302, 11)SP(303, 32)\n    SP(304, 57)SP(305,177)SP(306, 33)SP(307, 88)SP(308,237)SP(309,149)SP(310, 56)SP(311, 87)\n    SP(312,174)SP(313, 20)SP(314,125)SP(315,136)SP(316,171)SP(317,168)SP(318, 68)SP(319,175)\n    SP(320, 74)SP(321,165)SP(322, 71)SP(323,134)SP(324,139)SP(325, 48)SP(326, 27)SP(327,166)\n    SP(328, 77)SP(329,146)SP(330,158)SP(331,231)SP(332, 83)SP(333,111)SP(334,229)SP(335,122)\n    SP(336, 60)SP(337,211)SP(338,133)SP(339,230)SP(340,220)SP(341,105)SP(342, 92)SP(343, 41)\n    SP(344, 55)SP(345, 46)SP(346,245)SP(347, 40)SP(348,244)SP(349,102)SP(350,143)SP(351, 54)\n    SP(352, 65)SP(353, 25)SP(354, 63)SP(355,161)SP(356,  1)SP(357,216)SP(358, 80)SP(359, 73)\n    SP(360,209)SP(361, 76)SP(362,132)SP(363,187)SP(364,208)SP(365, 89)SP(366, 18)SP(367,169)\n    SP(368,200)SP(369,196)SP(370,135)SP(371,130)SP(372,116)SP(373,188)SP(374,159)SP(375, 86)\n    SP(376,164)SP(377,100)SP(378,109)SP(379,198)SP(380,173)SP(381,186)SP(382,  3)SP(383, 64)\n    SP(384, 52)SP(385,217)SP(386,226)SP(387,250)SP(388,124)SP(389,123)SP(390,  5)SP(391,202)\n    SP(392, 38)SP(393,147)SP(394,118)SP(395,126)SP(396,255)SP(397, 82)SP(398, 85)SP(399,212)\n    SP(400,207)SP(401,206)SP(402, 59)SP(403,227)SP(404, 47)SP(405, 16)SP(406, 58)SP(407, 17)\n    SP(408,182)SP(409,189)SP(410, 28)SP(411, 42)SP(412,223)SP(413,183)SP(414,170)SP(415,213)\n    SP(416,119)SP(417,248)SP(418,152)SP(419,  2)SP(420, 44)SP(421,154)SP(422,163)SP(423, 70)\n    SP(424,221)SP(425,153)SP(426,101)SP(427,155)SP(428,167)SP(429, 43)SP(430,172)SP(431,  9)\n    SP(432,129)SP(433, 22)SP(434, 39)SP(435,253)SP(436, 19)SP(437, 98)SP(438,108)SP(439,110)\n    SP(440, 79)SP(441,113)SP(442,224)SP(443,232)SP(444,178)SP(445,185)SP(446,112)SP(447,104)\n    SP(448,218)SP(449,246)SP(450, 97)SP(451,228)SP(452,251)SP(453, 34)SP(454,242)SP(455,193)\n    SP(456,238)SP(457,210)SP(458,144)SP(459, 12)SP(460,191)SP(461,179)SP(462,162)SP(463,241)\n    SP(464, 81)SP(465, 51)SP(466,145)SP(467,235)SP(468,249)SP(469, 14)SP(470,239)SP(471,107)\n    SP(472, 49)SP(473,192)SP(474,214)SP(475, 31)SP(476,181)SP(477,199)SP(478,106)SP(479,157)\n    SP(480,184)SP(481, 84)SP(482,204)SP(483,176)SP(484,115)SP(485,121)SP(486, 50)SP(487, 45)\n    SP(488,127)SP(489,  4)SP(490,150)SP(491,254)SP(492,138)SP(493,236)SP(494,205)SP(495, 93)\n    SP(496,222)SP(497,114)SP(498, 67)SP(499, 29)SP(500, 24)SP(501, 72)SP(502,243)SP(503,141)\n    SP(504,128)SP(505,195)SP(506, 78)SP(507, 66)SP(508,215)SP(509, 61)SP(510,156)SP(511,180)\n    #undef SP\n}\n\n// lookup an entry in the permutation table\n// This function is required because of WebGL weirdness.\n// WebGL's GLSL doesn't allow indexing arrays with non-constant values EXCEPT for array indices\n// ... so I have to redundantly loop until I reach the right index. -_-\nint P(int i)\n{\n    for (int x = 0; x < 512; x++)\n    {\n        if (x == i)\n            return Ptab[x];\n    }\n    return 0;\n}\n\n// lookup table for gradients\nvec3 G(int i)\n{\n    if (i == 0x0) return vec3(+1,+1,+0);\n    if (i == 0x1) return vec3(-1,+1,+0);\n    if (i == 0x2) return vec3(+1,-1,+0);\n    if (i == 0x3) return vec3(-1,-1,+0);\n    if (i == 0x4) return vec3(+1,+0,+1);\n    if (i == 0x5) return vec3(-1,+0,+1);\n    if (i == 0x6) return vec3(+1,+0,-1);\n    if (i == 0x7) return vec3(-1,+0,-1);\n    if (i == 0x8) return vec3(+0,+1,+1);\n    if (i == 0x9) return vec3(+0,-1,+1);\n    if (i == 0xA) return vec3(+0,+1,-1);\n    if (i == 0xB) return vec3(+0,-1,-1);\n    if (i == 0xC) return vec3(+1,+1,+0);\n    if (i == 0xD) return vec3(-1,+1,+0);\n    if (i == 0xE) return vec3(+0,-1,+1);\n    if (i == 0xF) return vec3(+0,-1,-1);\n    return vec3(0,0,0);\n}\n\n// get [a,b,c,d] at point [x,y,z] of the lattice\n// [a,b,c,d] represents a linear equation:\n//  * [a,b,c] is the gradient (the slope of the linear equation)\n//  * d is the value of the linear equation (with slope [a,b,c]) at [x,y,z]\n// lattice_ip is the xyz coordinate of the integer lattice whose linear equation is being evaluated\n// sample_t is the fraction inside the lattice grid where to sample the linear equation\nvec4 H(ivec3 lattice_ip, vec3 sample_t)\n{\n    // the lattice repeats at every 256, so mod it.\n    // this prevents out-of-bounds access to the lattice pseudorandom values.\n    lattice_ip = imod3(lattice_ip, ivec3(256));\n    \n    // compute successive hashes to decorrelate indices\n    int i = P(P(P(lattice_ip.x) + lattice_ip.y) + lattice_ip.z);\n    // mod to prevent out-of-bounds access to gradient table\n    i = imod(i, 16);\n    \n    // grab a random gradient from the gradient table\n    vec3 g = G(i);\n    // compute dot product of gradient and fractional part of point\n    // this is the value of the linear equation with gradient [a,b,c] at this point\n    // (think of it as evaluating good old \"y = mx\", but m is the gradient and x is t)\n    float d = dot(g, sample_t);\n    \n    // combine the results and return them\n    return vec4(g, d);\n}\n\n\nfloat Noise(vec3 p)\n{     \n    // the noise function will be evaluated at the 8 corners of the integer lattice\n    // after evaluating it at the 8 corners, they will be interpolated at the current point.\n    // Here, the coordinates of the minimum and maximum corners of the current lattice grid region are computed\n    ivec3 minp = ivec3(floor(p));\n    ivec3 maxp = ivec3(ceil(p));\n    \n    // t is the fraction of the lattice for the current point\n    // the gradients at the corners of the lattice will be interpolated at this offset.\n    vec3 t = fract(p);\n    \n    // evaluate the lattice at all 8 corners\n    // the paramter \"t\" is inverted when evaluating at the opposite corner,\n    // since this makes the gradient interpolated towards the inside the lattice's cube\n    // this is important, since we're evaluating \"t\" to sample inside the cube.\n    vec4 h000 = H(ivec3(minp.x, minp.y, minp.z), t - vec3(0,0,0));\n    vec4 h001 = H(ivec3(minp.x, minp.y, maxp.z), t - vec3(0,0,1));\n    vec4 h010 = H(ivec3(minp.x, maxp.y, minp.z), t - vec3(0,1,0));\n    vec4 h011 = H(ivec3(minp.x, maxp.y, maxp.z), t - vec3(0,1,1));\n    vec4 h100 = H(ivec3(maxp.x, minp.y, minp.z), t - vec3(1,0,0));\n    vec4 h101 = H(ivec3(maxp.x, minp.y, maxp.z), t - vec3(1,0,1));\n    vec4 h110 = H(ivec3(maxp.x, maxp.y, minp.z), t - vec3(1,1,0));\n    vec4 h111 = H(ivec3(maxp.x, maxp.y, maxp.z), t - vec3(1,1,1));\n        \n    // rather than linear interpolation,\n    // the interpolation method is a degree 5 polynomial:\n    // 6 * t^5 - 15 * t^4 + 10 * t^3\n    // this ensures continuity at the vertices of the lattice.\n    t = 6.0*t*t*t*t*t - 15.0*t*t*t*t + 10.0*t*t*t;\n    \n    // Interpolate the lattice corners in X Y and Z\n    // First interpolate in x (flattening a cube into a square)\n    // then interpolate in y (flattening a square into a line)\n    // then interpolate in z (giving a single point)\n    float x00 = mix(h000.w, h100.w, t.x);\n    float x01 = mix(h001.w, h101.w, t.x);\n    float x10 = mix(h010.w, h110.w, t.x);\n    float x11 = mix(h011.w, h111.w, t.x);\n    float y0 = mix(x00, x10, t.y);\n    float y1 = mix(x01, x11, t.y);\n    float z = mix(y0, y1, t.z);\n    \n    return z;\n}\n\n#define OCTAVES 3\nfloat Fbm (vec3 p) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 1.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * Noise(p * frequency);\n        p *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize the permutation table\n    init_P();\n    \n    // determine sample position from inputs\n    vec3 p = vec3((fragCoord + iMouse.xy * vec2(1,10.0)) / ((iResolution.x-iMouse.x)/20.0), iTime);\n    \n    // compute the noise!\n    float noise = Fbm(p);\n    \n    noise = clamp((noise+1.0) / 2.0, 0.0, 1.0);\n    \n    // darken (for asthetic purposes)\n    // noise *= noise;\n    \n    // gamma correct\n    //noise = pow(noise, 1.0/2.2);\n    \n    // output color\n    fragColor = vec4(vec3(noise), 1.0);\n}","name":"Image","description":"","type":"image"}]}