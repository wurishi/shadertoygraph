{"ver":"0.1","info":{"id":"4lVcRR","date":"1534861223","viewed":132,"name":"Pinky","username":"rs_creative","description":"Raymarching play with lighting.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fun","specular","pink"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3 mapP( vec3 p )\n{\n    //p.xyz += 1.000*sin(  2.0*p.yzx )*grow.x;\n    //p.xyz += 0.500*sin(  4.0*p.yzx )*grow.y;\n    //p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    //p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\n\nvec2 rotate(vec2 pos, float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, s, -s, c) * pos;\n}\n\nfloat sphere( vec3 pos, float r )\n{\n  return length(pos) - r;\n}\n\nfloat plane (vec3 pos)\n{\n    return pos.y;\n}\n\nfloat box(vec3 pos, vec3 size, float radius)\n{\n    return length(max(abs(pos) - size, 0.0)) - radius;\n}\n\nfloat map(vec3 pos) \n{\n    vec3 planePos = pos + vec3(1.2, 3.0, + 0.5);\n    \n    float planeDist = plane(planePos);\n    \n    vec3 spherePos = pos + vec3((sin(iTime)) * 3.0,  -2.0, + 0.5);\n    spherePos.y += sin(iTime) * 0.4;\n    \n    \n    vec3 boxPos = mapP(pos) + vec3(-1.8, -3.5, + 0.5);\n    \n    spherePos.xz = rotate(spherePos.xz, iTime);\n    spherePos.xy = rotate(spherePos.xy, iTime * 2. );\n\n    \n    float sphere = sphere(spherePos, 1.9);\n    \n    // Rotate the shapes\n    boxPos.xz = rotate(boxPos.xz, iTime);\n    boxPos.xy = rotate(boxPos.xy, iTime * 2. );\n    boxPos.x += sin(iTime) * 0.6;\n    \n    float box1 = box(boxPos, vec3(1.2), 1.0);\n    \n    float d = min(box1, planeDist);\n    d = min(d, sphere);\n    return d;\n}\n\nvec3 albedo(vec3 pos)\n{\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n        ));\n}\n\nvec3 lightDirection = normalize(vec3(1.0, 0.6, 1.0));\n\nfloat diffuse(vec3 normal) {\n    return max(dot(normal, lightDirection), 0.0);\n}\n\nfloat specular(vec3 normal, vec3 dir) \n{\n    vec3 h = normalize(normal - dir);\n    return pow(max(dot(h, normal), 0.0), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;    \n    uv.x *= (iResolution.x / iResolution.y);\n   \t\n    \n    vec3 pos = vec3(0.0, 2.7, -8.0);\n    \n    \n    vec3 dir = normalize(vec3(uv, 1.0));    \n    vec3 color = vec3(1.0);\n        \n    for (int i = 0; i < 64; i ++ ) \n    {\n        float d = map(pos);\n        if (d < 0.1)\n        {\n            // Intersection\n            float lightDistance1 = sphere(pos + vec3(0.0, -2.0, 1.0), 0.0);\n            vec3 normal = computeNormal(pos);\n            float diff = diffuse(normal);\n            float spec = specular(normal, dir);\n            color =  (diff + spec) * 5.0 / (lightDistance1) * vec3(0.7, 0.1, 0.3) * albedo(pos);\n            break;\n        }\n        pos += d * dir;\n        color = vec3(1.0);\n    }\n    \n    float fogFactor = exp(-pos.z * 0.09);\n    \n    color = mix(vec3(0.0), color, fogFactor);\n    \n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}