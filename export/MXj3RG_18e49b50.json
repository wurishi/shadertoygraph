{"ver":"0.1","info":{"id":"MXj3RG","date":"1708594606","viewed":36,"name":"Illuminated circle","username":"Renae","description":"I wanted to make a volumetric sphere without raycast and raymarching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["light","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 circle(vec2 uv, vec2 p, float r) {\n    if (length(p - uv) < r) {\n        return vec3(1.0);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates\n    float coof = iResolution.x / iResolution.y;\n    vec2 uv = ((fragCoord - 0.5 * iResolution.xy) / iResolution.xy) * 2.0;\n    uv.x *= coof;\n\n    // Normalized mouse coordinates \n    vec2 mp = ((iMouse.xy - 0.5 * iResolution.xy) / iResolution.xy) * 2.0;\n    mp.x *= coof;\n\n    float r = 0.5;\n    vec2 pos = vec2(0.0);\n    vec3 circleColor = circle(uv, pos, r);\n\n    // Normal\n    float z = sqrt(r * r - uv.x * uv.x - uv.y * uv.y);\n    vec3 n = vec3(uv.x, uv.y, z) / length(vec3(2.0 * uv.x, 2.0 * uv.y, 2.0 * z));\n\n    // Direction light\n    vec3 d = normalize(vec3(mp.xy,0.5));    \n    vec3 bd = -d;    \n\n  \n    float l = dot(n, d);\n    float bl = dot(n, bd);\n    \n    l = (abs(l) + l)*.5;\n    bl = (abs(bl) + bl)*.005;\n    \n    float gamma = 2.2;\n    vec3 G = pow(circleColor*(l+bl),vec3(1.0/gamma));\n\n    fragColor = vec4(G, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}