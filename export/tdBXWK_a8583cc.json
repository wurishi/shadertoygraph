{"ver":"0.1","info":{"id":"tdBXWK","date":"1554924823","viewed":399,"name":"fbm mountain","username":"ankd","description":"What is the cause of this distortion... -> This problem is solved, Thanks!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14150265359;\n\n// hash() and noise() is from Inigo Quilez \"Noise - value - 3D\"\n// https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 p){\n    float res = 0.;\n    vec3 q = p;\n    float amp = 1.0;//\n    for(int i=0;i<5;i++){\n\t\tfloat fi = float(i);\n        res += amp*noise(q);\n        amp *= 0.5;//\n        q*=2.0;\n    }\n    return res;\n}\n\nfloat sdPlane(in vec3 p, in float h){\n    return p.y - h;\n}\nvec2 map(in vec3 p){\n    float h = fbm(vec3(p.x, 0., p.z));\n    return vec2(sdPlane(p, h), 0.);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD = 0.0;\n    float maxD = 10.0;\n    float thr = 0.00001;// 0.001 -> 0.00001\n    \n    float d=minD, m=0.0;\n    for(int i=0;i<64;i++){\n        vec3 pos = ro+rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<thr || maxD<tmp.x) break;\n        d += tmp.x*0.5;// d+=tmp.x; -> d+=tmp.x*0.5;\n        m = tmp.y;\n    }\n    if(maxD<d) m=-1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 eps = vec2(1.0, -1.0)*0.001;\n    return normalize(vec3(\n    \teps.xyy*map(p+eps.xyy).x +\n    \teps.yxy*map(p+eps.yxy).x +\n    \teps.yyx*map(p+eps.yyx).x +\n    \teps.xxx*map(p+eps.xxx).x \n    ));\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x, m=res.y;\n    \n    vec3 pos = ro + rd*d;\n    vec3 nor = calcNormal(pos);\n    \n    vec3 lightDir = vec3(1.0);\n    \n    vec3 col = clamp(vec3(dot(lightDir, nor)), 0.0, 1.0);\n\tcol *= vec3(0.3, 0.15, 0.02)*noise(pos);\n    \n    //col = mix(col, vec3(1.0), clamp(d/10.0, 0., 1.0));\n    col = mix(col, vec3(1.0), 1.0-exp(-0.03*d*d));// use gaussian\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    vec3 eye = vec3(0., 2.0+0.1*sin(iTime), -iTime);\n    vec3 dir = normalize(vec3(p, -1.0));\n    float an = -PI*0.1;\n    dir.yz *= mat2(cos(an), -sin(an), sin(an), cos(an));\n    \n    vec3 col = render(eye, dir);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}