{"ver":"0.1","info":{"id":"td3czX","date":"1601387986","viewed":52,"name":"Phong Shading RT","username":"suriya_dakshina","description":"Phong shading with ambient lighting, emission and reflections","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//[09/29/2020]Suriya Dakshina Murthy - Phong Shading using Ray Tracing\n\n//float infinity = 1.0 / 0.0;\n\n//=======================================================================================\nvec3 ShadePixelOrig (in vec3 albedo, in vec3 normal, in vec3 hitPos, in vec3 rayDir)\n{\n\treturn albedo;\n}\n\n//=======================================================================================\nbool RayIntersectAABox  (in vec3 boxMin, in vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    vec3 boxCenter = (boxMin+boxMax)*0.5;\n\tvec3 roo = rayPos - boxCenter;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (time.x > maxTime)\n        return false;\n\n    // if time invalid or we hit from inside, bail out\n    if (time.y < time.x || time.x < 0.0)\n        return false;\n\n    // calculate surface normal\n    hitPos = rayPos + rayDir * time.x;\n    vec3 hitPosRelative = hitPos - boxCenter;\n    vec3 hitPosRelativeAbs = abs(hitPosRelative);\n    vec3 distToEdge = abs(hitPosRelativeAbs - rad);\n\n    float closestDist = 1000.0;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        if (distToEdge[axis] < closestDist)\n        {\n            closestDist = distToEdge[axis];\n            normal = vec3(0.0);\n            if (hitPosRelative[axis] < 0.0)\n                normal[axis] = -1.0;\n            else\n                normal[axis] = 1.0;\n        }\n    }\n\n    // store the collision time as the new max time\n    maxTime = time.x;\n    return true;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    if (sphere.w <= 0.0)\n        return false;\n\n\t//get the vector from the center of the sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n        return false;\n\n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (collisionTime > maxTime)\n        return false;\n\n    // store the collision time as the new max time\n    maxTime = collisionTime;\n\n\t//compute the point of intersection\n\thitPos = rayPos + rayDir * collisionTime;\n\n   \t// calculate the normal\n\tnormal = hitPos - sphere.xyz;\n\tnormal = normalize(normal);\n\n\treturn true;\n}\n\nbool Trace(in vec3 rayPos, in vec3 rayDir, inout float maxRayHitTime, inout vec3 hitPos, inout vec3 normal, inout vec3 albedo) //just trace to find occlusions without shading\n{\n    bool hit = false;\n\n\t// green box\n    if (RayIntersectAABox(vec3(0.4,-0.3,-0.5), vec3(1.4,0.3,0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.1, 0.9, 0.1);\n    }\n\n    // red sphere\n    if (RayIntersectSphere(vec4(-0.4, 0.4, 0.5, 0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.9, 0.1, 0.1);\n    }\n\n    // blue sphere\n    if (RayIntersectSphere(vec4(-0.8, 0.4, -0.75, 0.25), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.1, 0.1, 0.9);\n    }\n    \n    //grey floor\n    if (RayIntersectAABox(vec3(-2.0,-0.5,-2.0), vec3(2.0,-0.4,2.0), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.9, 0.9, 0.9);\n    }\n\n    if (!hit)\n\t\treturn false;\n\n    return true; //true if hit something\n}\n\n//added by Suriya\n//light class\nstruct pointLight\n{\n    vec3 position;\n    vec3 intensity;\n    vec3 direction;\n};\n\n//material defaults\nfloat specExp = 25.0;\nfloat kd = 0.8;\nfloat ks = 0.2;\nfloat ka = 0.005;\n\nvec3 ShadePixel (in vec3 albedo, in vec3 normal, in vec3 hitPos, in vec3 rayDir, in bool emission, inout bool isShadowPoint)\n{\n    //harcoding light\n    pointLight lights[2]; // #update number of lights\n    \n    //point light\n    lights[0].position = vec3(5.0,5.0,-5.0);\n    lights[0].intensity = vec3(1.0);\n    lights[0].direction = vec3(0.0); //direction zero for point lights, we calculate later\n\n    //directional light\n    lights[1].position = vec3(0.0); //position zero for directional lights\n    lights[1].intensity = vec3(1.0);\n    lights[1].direction = vec3(-5.0,5.0,-2.0);\n    vec3 lightPos, lightInt, lightDir;\n    vec3 lightAmt = vec3(0), specColor = vec3(0);\n    vec3 hitColor;\n    \n   \t//diffuse\n    for(int i=0;i<2;i++) // #update number of lights\n    {\n        //reading light\n        lightPos = lights[i].position;\n        lightInt = lights[i].intensity;\n        lightDir = lights[i].direction;\n\n        float bias = 0.0001;\n        vec3 shadowPointOrigin = (dot(rayDir, normal)<0.0f)?\n            hitPos+normal*bias:hitPos-normal*bias;\n        if(lightDir==vec3(0.0))\n            lightDir = lightPos - hitPos;\n        float lightDistance2 = dot(lightDir, lightDir);\n        lightDir = normalize(lightDir);\n        float LdotN = max(0.0f, dot(lightDir, normal));\n\n        float tNearShadow = 1000.0; //very high value\n        vec3 hitPos2;\n    \tvec3 normal2;\n    \tvec3 albedo2;\n        bool inShadow = Trace(shadowPointOrigin, lightDir, tNearShadow, hitPos2, normal2, albedo2)\n            && tNearShadow*tNearShadow<lightDistance2; //check if shadow\n        isShadowPoint = isShadowPoint || !inShadow; //know if this point is always in shadow\n\n        lightAmt+=(1.0 - float(inShadow))*lightInt*LdotN;\n        vec3 refDir = -lightDir - 2.0*dot(-lightDir,normal)*normal; //reflection direction for spec\n        specColor+= pow(max(0.0f,-dot(refDir,rayDir)),specExp)*lightInt;\n\n    }\n    //phong shading\n    hitColor = float(emission)*vec3(1.0) + ka*albedo + lightAmt*albedo*kd + specColor*ks; //diffuse + specular\n    return hitColor;\n}\n\n//Ref. - https://www.scratchapixel.com/\nvoid fresnel(in vec3 I, in vec3 N, in float ior, inout float kr) \n{ \n    float cosi = clamp(-1.0, 1.0, dot(I, N)); \n    float etai = 1.0, etat = ior; \n    if (cosi > 0.0) \n    {  \n        //swap(etai, etat);\n        float tmp = etai;\n        etai = etat;\n        etat = tmp;\n    } \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.f, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        kr = 1.0; \n    } \n    else { \n        float cost = sqrt(max(0.f, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        kr = (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n}\n\nvec3 GetReflection (in vec3 refPos, in vec3 refDir, in vec3 rayDir, in vec3 normal, in vec3 hitPos, in vec3 albedo, in vec3 rayPos)\n{\n   \n    float maxHit = 1000.0;\n    vec3 hitPos2;\n    vec3 normal2;\n    vec3 albedo2;\n    bool isShadePoint;\n    if(Trace(refPos, refDir, maxHit, hitPos2, normal2, albedo2))\n        return ShadePixel(albedo2, normal2, hitPos2, refDir, false, isShadePoint);\n        \n    return texture(iChannel0, refDir).rgb; //env mapped reflection\n}\n\nvec3 GetRefectionFresnel(in vec3 rayPos, in vec3 rayDir, \n                    in vec3 normal, in vec3 hitPos)\n{\n    float kr; \n    float ior=1.5;\n    fresnel(rayDir, normal, ior, kr); \n    vec3 reflDir = reflect(rayDir, normal); \n    vec3 reflRayOrig = (dot(reflDir, normal) < 0.0) ? \n        hitPos + normal * 0.001 : \n        hitPos - normal * 0.001;\n    vec3 reflectionColor = texture(iChannel0, reflDir).rgb;\n    \n    float maxHitRefl = 1000.0;\n    vec3 hitPosRefl;\n    vec3 normalRefl;\n    vec3 albedoRefl;\n    bool isShadePointRefl;\n    if(Trace(reflRayOrig, reflDir, maxHitRefl, hitPosRefl, normalRefl, albedoRefl))\n        reflectionColor = ShadePixel(albedoRefl, normalRefl, hitPosRefl, reflDir, false, isShadePointRefl)*kr;\n\n\treturn reflectionColor;\n}\n\nvec3 GetRefraction (in vec3 rayPos, in vec3 rayDir, \n                    in vec3 normal, in vec3 hitPos)\n{\n    float ior = 1.1; //glass ior=1.5\n    vec3 reflDir = normalize(reflect(rayDir, normal)); \n    vec3 refrDir = normalize(refract(rayDir, normal, ior)); \n    vec3 reflRayOrig = (dot(reflDir, normal) < 0.0) ? \n        hitPos - normal * 0.001 : \n    \thitPos + normal * 0.001; \n    vec3 refrRayOrig = (dot(refrDir, normal) < 0.0) ? \n        hitPos - normal * 0.001 : \n    \thitPos + normal * 0.001;\n    \n    vec3 reflectionColor = texture(iChannel0, reflDir).rgb;\n    vec3 refractionColor = texture(iChannel0, refrDir).rgb;\n    \n    float maxHitRefl = 1000.0;\n    vec3 hitPosRefl;\n    vec3 normalRefl;\n    vec3 albedoRefl;\n    bool isShadePointRefl;\n    if(Trace(reflRayOrig, reflDir, maxHitRefl, hitPosRefl, normalRefl, albedoRefl))\n        reflectionColor = ShadePixel(albedoRefl, normalRefl, hitPosRefl, reflDir, false, isShadePointRefl);\n    \n    float maxHitRefr = 1000.0;\n    vec3 hitPosRefr;\n    vec3 normalRefr;\n    vec3 albedoRefr;\n    bool isShadePointRefr;\n    if(Trace(refrRayOrig, refrDir, maxHitRefr, hitPosRefr, normalRefr, albedoRefr))\n        refractionColor = ShadePixel(albedoRefr, normalRefr, hitPosRefr, refrDir, false, isShadePointRefr);\n\n    float kr; \n    fresnel(normalize(rayDir), normal, ior, kr); \n    return (reflectionColor * kr + refractionColor * (1.0 - kr));\n}\n\nvec3 RayTracePixelColor(in vec3 albedo, in vec3 normal, in vec3 hitPos, in vec3 rayDir, \n                        in bool emission, in vec3 rayPos, \n                        in bool reflection, in bool refraction, in float maxRayHitTime)\n{\n    \n    vec3 additiveColor = vec3(0.0);\n    vec3 ret = vec3(0.0);\n    bool isShadePoint = false;\n    \n    //refraction\n    if(refraction==true)\n    {\n        ret += GetRefraction(rayPos, rayDir, normal, hitPos);\n        return ret;\n    }\n    \n    //phong component\n    additiveColor+=ShadePixel(albedo, normal, hitPos, rayDir, emission, isShadePoint);\n    \n    //reflection \n    if(reflection==true)//&& isShadePoint)\n    {\n        //ray based reflection\n        vec3 I = normalize(hitPos - rayPos);\n        vec3 R = reflect(I, normalize(normal));\n        ret += GetReflection(hitPos, R, rayDir, normal, hitPos, albedo, rayPos)*0.1;\n        \n        //fresnel reflection\n        //ret+= GetRefectionFresnel(rayPos, rayDir, normal, hitPos);\n    } \n    \n    return additiveColor + ret;\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor)\n{\n    float maxRayHitTime = 1000.0;\n    bool hit = false;\n    vec3 hitPos;\n    vec3 normal;\n    vec3 albedo;\n    bool emission = false; //to enable emissive lighting, change below after hit\n    bool reflection = false;\n    bool refraction = false;\n\n\t// green box\n    if (RayIntersectAABox(vec3(0.4,-0.3,-0.5), vec3(1.4,0.3,0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.1, 0.9, 0.1);\n        emission = false;\n        reflection = false;\n        refraction =  false;\n    }\n\n    // red sphere\n    if (RayIntersectSphere(vec4(-0.4, 0.4, 0.5, 0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.9, 0.1, 0.1);\n        emission = false;\n        reflection = true;\n        refraction = false;\n    }\n\n    // blue sphere\n    if (RayIntersectSphere(vec4(-0.8, 0.4, -0.75, 0.25), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.1, 0.1, 0.9);\n        emission = false;\n        reflection = false;\n        refraction = true;\n    }\n\n    // grey floor to show shadows\n    if (RayIntersectAABox(vec3(-2.0,-0.5,-2.0), vec3(2.0,-0.4,2.0), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        albedo = vec3(0.9, 0.9, 0.9);\n        emission = false;\n        reflection = false;\n        refraction = false;\n    }\n\n    if (!hit)\n\t\treturn;\n\n    pixelColor = RayTracePixelColor(albedo, normal, hitPos, rayDir, \n                                    emission, rayPos, reflection, refraction, \n                                    maxRayHitTime);\n\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //----- camera setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 0.0;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) : 0.0;\n\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\n\t// if the mouse button is down do orbit camera\n\tif( iMouse.z > 0.0 ) {\n\t\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\n\t\trayPos = cameraPos;\n\t}\n\t// else handle the case of the mouse button not being down\n\telse {\n\t\trayPos = vec3(0.0,3.0,-3.0);\n\t\tvec3 f = normalize(cameraAt - rayPos);\n\t\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\t\tvec3 u = normalize(cross(l,f));\n\n\t\trayTarget = (f * cameraDistance)\n\t\t\t\t  + (l * percent.x * cameraViewWidth)\n\t\t          + (u * percent.y * cameraViewHeight);\n\t}\n\n\t//----- ray trace\n\tvec3 rayDir = normalize(rayTarget);\n\n    // initialze ray color to the cube map\n    vec3 pixelColor = texture(iChannel0, rayDir).rgb;\n\n    // ray trace\n\tTraceRay(rayPos, rayDir, pixelColor);\n\n    // output sRGB corrected pixel\n    pixelColor = pow(pixelColor, vec3(1.0/2.2));\n\tfragColor = vec4(pixelColor, 1.0);\n}\n\n/*\n\nAdd:\n* point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n* ambient lighting\n* emissive lighting\n* environment mapped reflections\n\n* One other feature to make it unique / show off your stuff. Some ideas:\n * shadows\n * Normal or bump mapping\n * ray based reflections\n * anti aliasing\n * lens effects\n * post processing effects\n * warping geometry, more complex geometry\n * animating the camera, lights or geometry.\n * refraction or transparency\n * anything else you can think of\n\n*/\n","name":"Image","description":"","type":"image"}]}