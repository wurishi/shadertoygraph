{"ver":"0.1","info":{"id":"wsdBzf","date":"1606168696","viewed":203,"name":"Incremental Quasi-random","username":"olano","description":"Compare different direct and incremental quasirandom sampling strategies on either a square or disk.\nClick labels in window to change between options.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["halton","fibonacci","quasirandom","r2","sobol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comparison of incremental vs. direct computation of a few\n// quasi-random sequences. \n\n//////////////////////////////////////////////////////////////////////\n// Number and speed of points\n\n// max number of points to show\nconst uint MaxPoints = 128u;\n\n// points update rate\nconst float PointsPerSec = 10.;\n\n//////////////////////////////////////////////////////////////////////\n// quasirandom generation\n\n// generic mapping from [0,1) x [0,1) to disk as (xdir, ydir, rsquared)\nvec3 MapDisk(vec2 p) {\n    float angle = 6.2831853072 * p.y;\n    return vec3(cos(angle), sin(angle), p.x);\n}\n\n// generic mapping from [0,1) x [0,1) to disk as (x,y)\n// Using Elliptical Arc mapping as described by Lambers:\n// http://www.jcgt.org/published/0005/02/01/\nvec2 MapEllipDisk(vec2 p) {\n    vec2 v = 2.0 * p - 1.0;\n    return v * sqrt(1. - 0.5 * v.yx * v.yx);\n}\n\n////////\n// R2 Fibonacci points in a square or disk as described by\n//   Roberts, The Unreasonable Effectiveness of Quasirandom Sequences\n//   http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nconst vec2 r2consts = vec2(0.569840296, 0.754877669);\n\n// direct R2 point in [0,1) x [0,1)\nvec2 DirectR2(uint index) {\n    return fract(r2consts * float(index));\n}\n\n// incremental R2 point in [0,1) x [0,1)\nvec2 NextR2(vec2 prev) {\n    return fract(prev + r2consts);\n}\n\n// incremental R2 disk angle, rotate by 2*pi*r2.y\n// since rotation wraps, don't need frac or sin/cos evaluation each time\nmat2 r2rot = mat2(0.0306425008, 0.999530408, -0.999530408, 0.0306425008);\n\n// direct R2 point in disk: (xdir,ydir,rsquared)\nvec3 DirectDiskR2(uint index) {\n    return MapDisk(DirectR2(index));\n}\n\n// incremental R2 point in disk (xdir,ydir,rsquared)\nvec3 NextDiskR2(vec3 prev) {\n    vec3 result;\n    result.xy = prev.xy * r2rot;\n    result.z = fract(prev.z + r2consts.x);\n    return result;\n}\n\n////////\n// Halton, using base 2 and 3\n\n// direct evaluation of Halton point in [0,1)x[0,1) by index\nvec2 DirectHalton(uint index) {\n    uvec2 base = uvec2(2,3);\t// base to use for each dimension\n    uvec2 value = uvec2(index); // digits not processed yet\n    uvec2 result = uvec2(0);    // digits processed so far\n    uvec2 scale = uvec2(1);     // scale for all digits processed\n\n    // loop as long as there are digits left\n    while (value != uvec2(0)) {\n        uvec2 next = value/base; // next value without least significant digit\n        result = result*base + (value-next*base); // add digit to result\n        scale *= base;          // record that we had another digit\n        value = next;           // update current value\n    }\n\n    // rescale to final position\n    return vec2(result)/vec2(scale);\n}\n\n// incremental update for Halton sequence from Halton & Smith, \n// Algorithm 247: Radical-inverse quasi-random point sequence, CACM v7n12, 1964\nvec2 NextHalton(vec2 prev) {\n    vec2 base = vec2(2,3), step = 1./base;\n    \n    // Mathematically, want >=1, but can cause infinite loop due to float errors\n    // comparison value should be somewhere in the range 1-1/MaxPoints < value < 1\n    while(prev.x + step.x > 0.99999)\n        step.x /= base.x;\n    while(prev.y + step.y > 0.99999)\n        step.y /= base.y;\n    \n    return prev + step * base + step - 1.;\n}\n\n////////\n// Sobol using Joe and Kuo dimensions 1 and 2\n\n// 32-bit Sobol numbers for dimension 2\nuint SobolNumber[] = uint[](\n\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n);\n\n// Version of SobolNumber for Grey-code order\n// SobolGrey[n] is SobolNumber[0] ^ SobolNumber[1] ^ ... ^ SobolNumber[n]\nuint SobolGrey[] = uint[](\n\t0x80000000u, 0x40000000u, 0xe0000000u, 0x10000000u,\n\t0x98000000u, 0x54000000u, 0xfe000000u, 0x01000000u,\n\t0x81800000u, 0x41400000u, 0xe1e00000u, 0x11100000u,\n\t0x99980000u, 0x55540000u, 0xfffe0000u, 0x00010000u,\n\t0x80018000u, 0x40014000u, 0xe001e000u, 0x10011000u,\n\t0x98019800u, 0x54015400u, 0xfe01fe00u, 0x01010100u,\n\t0x81818180u, 0x41414140u, 0xe1e1e1e0u, 0x11111110u,\n\t0x99999998u, 0x55555554u, 0xfffffffeu, 0x00000001u\n);\n    \n// direct evaluation of Sobol dimensions 1 and 2 from index\nvec2 DirectSobol(uint index) {\n\tuvec2 result = uvec2(bitfieldReverse(index),0);\n    for(int i=0; i < SobolNumber.length() && index > 0u; ++i, index >>= 1u)\n        result.y ^= (index & 1u) * SobolNumber[i];\n    return vec2(result>>8u) / vec2(0x1000000);\n}\n\n// incremental evaluation of Sobol dimensions 1 and 2\nvec2 NextSobol(inout uvec2 prev, uint index) {\n    prev.x = bitfieldReverse(index);\n    prev.y ^= SobolGrey[findLSB(index)];\n    return vec2(prev>>8u) / vec2(0x1000000);\n}\n\n////////\n// Owen scrambled Sobol using Joe and Kuo dimensions 1 and 2\n\n// 32-bit bit-reversed Sobol numbers for dimensions 2 and 3\nuint OwenNumber[] = uint[](\n\t0x00000001u, 0x00000003u, 0x00000005u, 0x0000000fu,\n\t0x00000011u, 0x00000033u, 0x00000055u, 0x000000ffu,\n\t0x00000101u, 0x00000303u, 0x00000505u, 0x00000f0fu,\n\t0x00001111u, 0x00003333u, 0x00005555u, 0x0000ffffu,\n\t0x00010001u, 0x00030003u, 0x00050005u, 0x000f000fu,\n\t0x00110011u, 0x00330033u, 0x00550055u, 0x00ff00ffu,\n\t0x01010101u, 0x03030303u, 0x05050505u, 0x0f0f0f0fu,\n\t0x11111111u, 0x33333333u, 0x55555555u, 0xffffffffu\n);\n\n// 32-bit bit-reversed Grey-code Sobol numbers for dimensions 2 and 3\nuint OwenGrey[] = uint[](\n\t0x00000001u, 0x00000002u, 0x00000007u, 0x00000008u,\n\t0x00000019u, 0x0000002au, 0x0000007fu, 0x00000080u,\n\t0x00000181u, 0x00000282u, 0x00000787u, 0x00000888u,\n\t0x00001999u, 0x00002aaau, 0x00007fffu, 0x00008000u,\n\t0x00018001u, 0x00028002u, 0x00078007u, 0x00088008u,\n\t0x00198019u, 0x002a802au, 0x007f807fu, 0x00808080u,\n\t0x01818181u, 0x02828282u, 0x07878787u, 0x08888888u,\n\t0x19999999u, 0x2aaaaaaau, 0x7fffffffu, 0x80000000u\n);\n\n// random Owen scrambling seed, would be different per pixel\n// these are literally just two random 32-bit numbers\nuvec2 OwenSeed = uvec2(0x49d61ead, 0x1ead1c86);\n\n// Owen scrambling function from \n// https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\nuvec2 Owen(uvec2 x, uvec2 seed) {\n    x ^= x * 0x3d20adeau;\n    x += seed;\n    x *= (seed >> 16u) | 1u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n    return x;\n}\n\nvec2 DirectOwen(uint index) {\n\tuvec2 result = uvec2(index,0);\n    for(int i=0; i < OwenNumber.length() && index > 0u; ++i, index >>= 1u)\n        result.y ^= (index & 1u) * OwenNumber[i];\n    result = bitfieldReverse(Owen(result, OwenSeed));\n    \n    return vec2(result>>8u) / vec2(0x1000000);\n}\n\nvec2 NextOwen(inout uvec2 prev, uint index) {\n    // find least significant 1, GPU should be able to do this in one instruction\n    int GreyBit = findLSB(index);\n    prev.x = index;\n    prev.y ^= OwenGrey[GreyBit];\n    \n    uvec2 result = bitfieldReverse(Owen(prev, OwenSeed));    \n    return vec2(result>>8u) / vec2(0x1000000);\n}\n\n////////\n// Random using PCG2D\nvec2 DirectRand(uint index) {\n    uvec2 v = index * uvec2(391234230u, 3332033867u) + uvec2(1196435762u, 3519870697u);\n    v = v ^ (v>>16u);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    return vec2(v >> 16u) / float(0x10000);\n}\n\nvec2 NextRand(vec2 prev, uint index) {\n    return DirectRand(index);\n}\n\n//////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint count = uint(PointsPerSec*iTime) % MaxPoints;\n    vec2 cursor  = TextSize*fragCoord/iResolution.y - vec2(0,TextSize.y-1.5);\n    printUInt(cursor, count);\n    \n    // fetch current settings from state texture\n    SEQ   = int(texelFetch(iChannel0, SEQ_PIX  , 0).r);\n    GEN   = int(texelFetch(iChannel0, GEN_PIX  , 0).r);\n    SHAPE = int(texelFetch(iChannel0, SHAPE_PIX, 0).r);\n    \n    // Normalized pixel coordinates\n    vec2 uv;\n    uv.x = 2. * (fragCoord.x - iResolution.x) / iResolution.y + 1.;\n    uv.y = 2. * fragCoord.y / iResolution.y - 1.;\n    \n    // dull red inside area of interest\n    vec3 col = vec3(0);\n    switch(SHAPE) {\n    case SQUARE:\n        col = max(abs(uv.x),abs(uv.y)) < 1.0 ? vec3(0.5,0,0) : vec3(0);\n        break;\n    case RADIALDISK:\n    case ELLIPDISK:\n        col = dot(uv,uv) < 1.0 ? vec3(0.5,0,0) : vec3(0);\n        break;\n    }\n\n    // incremental state for sequences\n    vec2 loc;\n    vec3 dir;\n    uvec2 prev = uvec2(0);\n\n\t// loop over number of points to display this frame\n    for(uint i=0u; i < count; ++i) {\n        \n        // direct computation of position from index\n        if (GEN == DIRECT || i==0u) {\n            switch(SEQ) {\n                case R2\t\t: loc = DirectR2(i); break;\n                case HALTON\t: loc = DirectHalton(i); break;\n                case SOBOL\t: loc = DirectSobol(i); break;\n                case OWEN\t: loc = DirectOwen(i); break;\n                case RANDOM\t: loc = DirectRand(i); break;\n            }\n            if (SHAPE == ELLIPDISK) dir.xy = MapEllipDisk(loc);\n            if (SHAPE == RADIALDISK) dir = MapDisk(loc);\n        }\n        // incremental updates from previous values\n        else {\n            switch(ShapeSeq(SHAPE, SEQ)) {\n                case ShapeSeq(SQUARE,     R2): \n                    loc = NextR2(loc);\n                    break;\n                case ShapeSeq(RADIALDISK, R2):\n                    dir = NextDiskR2(dir);\n                    break;\n                case ShapeSeq(ELLIPDISK,  R2):\n                    loc = NextR2(loc);\n                    dir.xy = MapEllipDisk(loc);\n                    break;\n                    \n                case ShapeSeq(SQUARE,     HALTON):\n                    loc = NextHalton(loc);\n                    break;\n                case ShapeSeq(RADIALDISK, HALTON): \n                \tloc = NextHalton(loc); \n                \tdir = MapDisk(loc);\n                \tbreak;\n                case ShapeSeq(ELLIPDISK,  HALTON)    :\n                    loc = NextHalton(loc);\n                    dir.xy = MapEllipDisk(loc);\n                    break;\n                    \n                case ShapeSeq(SQUARE    , SOBOL):\n                    loc = NextSobol(prev, i); \n                    break;\n                case ShapeSeq(RADIALDISK, SOBOL): \n                \tloc = NextSobol(prev, i); \n                \tdir = MapDisk(loc);\n                \tbreak;\n                case ShapeSeq(ELLIPDISK,  SOBOL)    :\n                    loc = NextSobol(prev, i);\n                    dir.xy = MapEllipDisk(loc);\n                    break;\n                    \n                case ShapeSeq(SQUARE    , OWEN):\n                    loc = NextOwen(prev, i); \n                    break;\n                case ShapeSeq(RADIALDISK, OWEN): \n                \tloc = NextOwen(prev, i); \n                \tdir = MapDisk(loc);\n                \tbreak;\n                case ShapeSeq(ELLIPDISK,  OWEN)    :\n                    loc = NextOwen(prev, i);\n                    dir.xy = MapEllipDisk(loc);\n                    break;\n                    \n                case ShapeSeq(SQUARE    , RANDOM):\n                    loc = NextRand(loc, i); \n                    break;\n                case ShapeSeq(RADIALDISK, RANDOM): \n                \tloc = NextRand(loc, i); \n                \tdir = MapDisk(loc);\n                \tbreak;\n                case ShapeSeq(ELLIPDISK,  RANDOM)    :\n                    loc = NextRand(loc, i);\n                    dir.xy = MapEllipDisk(loc);\n                    break;\n            }\n        }\n        \n        // draw point at current sample position\n        vec2 pos = vec2(0);\n        switch(SHAPE) {\n            case SQUARE:     pos = 2. * loc - 1.; break;\n            case ELLIPDISK:  pos = dir.xy; break;\n            case RADIALDISK: pos = dir.xy * sqrt(dir.z); break;\n        }\n        col = mix(col, vec3(1), smoothstep(0.05, 0.04, distance(pos,uv)));\n    }\n    \n    // Output to screen with text overlay\n    vec4 text = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    text = mix(text, vec4(1), draw_char(iChannel1));\n    \n    fragColor = vec4(mix(col, text.rgb, text.a), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// size and offset for text\nconst vec2 TextSize = vec2(15,20);\n\n// quasi-random sampling mode\n#define R2\t\t\t0\n#define HALTON\t\t1\n#define SOBOL\t\t2\n#define OWEN\t\t3\n#define RANDOM      4\n#define SEQ_COUNT\t5\nivec2 SEQ_PIX = ivec2(0,3);\nint SEQ;\n\n// generation method\n#define DIRECT\t\t0\n#define INCREMENTAL 1\n#define GEN_COUNT\t2\nivec2 GEN_PIX = ivec2(0,2);\nint GEN;\n\n// shape mode\n#define SQUARE\t\t0\n#define RADIALDISK\t1\n#define ELLIPDISK\t2\n#define SHAPE_COUNT\t3\nivec2 SHAPE_PIX = ivec2(0,1);\nint SHAPE;\n\n// combined index for shape & quasirandom method\n#define ShapeSeq(shape, seq) ((shape) * SEQ_COUNT + (seq))\n\n//////////////////////////////////////////////////////////////////////\n// print functions based on Fabrice Neyret's https://www.shadertoy.com/view/llySRh\nint char_id = -1; vec2 char_pos; \nvec2 char(vec2 p, int c) {\n    if (p.x>.25 && p.x<.75 && p.y>.1 && p.y<.85)\n        char_id = c, char_pos = p;\n    p.x -= 0.5;\n    return p;\n}\nfloat draw_char(sampler2D tex) {\n    int c = char_id; vec2 p = char_pos;\n    if (c < 0) return 0.;\n    return textureGrad(tex, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dFdx(p/16.),dFdy(p/16.) ).x;\n}\n\nvec2 printUInt(vec2 p, uint n) {\n    uint rev=0u, digits=0u;\n    // reverse digits\n    for(uint fwd=n; fwd > 0u; fwd/=10u, ++digits)\n        rev = 10u * rev + fwd % 10u;\n    digits = max(1u,digits);\n    \n    // can now print left to right\n    for(uint i=0u; i < digits; ++i, rev = rev/10u)\n        p = char(p, int(48u + rev % 10u));\n    \n    return p;\n}\n\n//////////////////////////////////////////////////////////////////////\n// standard GLSL functions not in GLES2\n\n// reverse bits in 32-bit integer\nuint bitfieldReverse(uint x) {\n    x = ((x & 0x55555555u) << 1u) | ((x & 0xAAAAAAAAu) >> 1u);\n    x = ((x & 0x33333333u) << 2u) | ((x & 0xCCCCCCCCu) >> 2u);\n    x = ((x & 0x0F0F0F0Fu) << 4u) | ((x & 0xF0F0F0F0u) >> 4u);\n    x = ((x & 0x00FF00FFu) << 8u) | ((x & 0xFF00FF00u) >> 8u);\n    return (x << 16u) | (x >> 16u);\n}\nuvec2 bitfieldReverse(uvec2 v) {\n    return uvec2(bitfieldReverse(v.x), bitfieldReverse(v.y));\n}\n\n// find first bit set in 32-bit integer\nint findLSB(uint x) {\n    uint b = 0u;\n    if ((x & 0xffffu) == 0u) { b += 16u; x >>= 16u; }\n    if ((x & 0x00ffu) == 0u) { b +=  8u; x >>=  8u; }\n    if ((x & 0x000fu) == 0u) { b +=  4u; x >>=  4u; }\n    if ((x & 0x0003u) == 0u) { b +=  2u; x >>=  2u; }\n    if ((x & 0x0001u) == 0u) { b +=  1u; }\n    return b == 0u ? -1 : int(b);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// state management and printing for controls, \n// state in fragcoord=0 row\n\n// mode prints were generated in git bash on windows with a command like:\n// for i in $(echo -n \"Sobol(2,3)\" | od -td1 | cut -d' ' -f2-); do printf 'p = char(p,%3d);\\n' $i ; done\nvec2 printSHAPE(vec2 p) {\n    switch(SHAPE) {\n    case SQUARE:\n        p = char(p, 83);\n        p = char(p,113);\n        p = char(p,117);\n        p = char(p, 97);\n        p = char(p,114);\n        p = char(p,101);\n        break;\n    case RADIALDISK:\n        p = char(p, 82);\n        p = char(p, 97);\n        p = char(p,100);\n        p = char(p,105);\n        p = char(p, 97);\n        p = char(p,108);\n        p = char(p, 32);\n        p = char(p, 83);\n        p = char(p,116);\n        p = char(p,114);\n        p = char(p,101);\n        p = char(p,116);\n        p = char(p, 99);\n        p = char(p,104);\n        p = char(p, 32);\n        p = char(p, 68);\n        p = char(p,105);\n        p = char(p,115);\n        p = char(p,107);\n        break;\n    case ELLIPDISK:\n        p = char(p, 69);\n        p = char(p,108);\n        p = char(p,108);\n        p = char(p,105);\n        p = char(p,112);\n        p = char(p,116);\n        p = char(p,105);\n        p = char(p, 99);\n        p = char(p, 97);\n        p = char(p,108);\n        p = char(p, 32);\n        p = char(p, 65);\n        p = char(p,114);\n        p = char(p, 99);\n        p = char(p, 32);\n        p = char(p, 68);\n        p = char(p,105);\n        p = char(p,115);\n        p = char(p,107);\n        break;\n    }\n    return p;\n}\n\nvec2 printGEN(vec2 p) {\n    switch(GEN) {\n    case DIRECT:\n        p = char(p, 68);\n        p = char(p,105);\n        p = char(p,114);\n        p = char(p,101);\n        p = char(p, 99);\n        p = char(p,116);\n        break;\n    case INCREMENTAL:\n        p = char(p, 73);\n        p = char(p,110);\n        p = char(p, 99);\n        p = char(p,114);\n        p = char(p,101);\n        p = char(p,109);\n        p = char(p,101);\n        p = char(p,110);\n        p = char(p,116);\n        p = char(p, 97);\n        p = char(p,108);\n        break;\n    }\n    return p;\n}\n\nvec2 printSEQ(vec2 p) {\n    switch (SEQ) {\n    case R2:\n        p = char(p, 82);\n        p = char(p, 50);\n        break;\n    case HALTON:\n        p = char(p, 72);\n        p = char(p, 97);\n        p = char(p,108);\n        p = char(p,116);\n        p = char(p,111);\n        p = char(p,110);\n        p = char(p, 40);\n        p = char(p, 50);\n        p = char(p, 44);\n        p = char(p, 51);\n        p = char(p, 41);\n        break;\n    case SOBOL:\n        p = char(p, 83);\n        p = char(p,111);\n        p = char(p, 98);\n        p = char(p,111);\n        p = char(p,108);\n        p = char(p, 40);\n        p = char(p, 49);\n        p = char(p, 44);\n        p = char(p, 50);\n        p = char(p, 41);\n        break;\n    case OWEN:\n        p = char(p, 79);\n        p = char(p,119);\n        p = char(p,101);\n        p = char(p,110);\n        p = char(p, 40);\n        p = char(p, 49);\n        p = char(p, 44);\n        p = char(p, 50);\n        p = char(p, 41);\n        break;\n    case RANDOM:\n        p = char(p, 82);\n        p = char(p, 97);\n        p = char(p,110);\n        p = char(p,100);\n        p = char(p,111);\n        p = char(p,109);\n        p = char(p, 40);\n        p = char(p, 80);\n        p = char(p, 67);\n        p = char(p, 71);\n        p = char(p, 50);\n        p = char(p, 68);\n        p = char(p, 41);\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fetch current settings from state texture\n    SEQ   = int(texelFetch(iChannel0, SEQ_PIX  , 0).r);\n    GEN   = int(texelFetch(iChannel0, GEN_PIX  , 0).r);\n    SHAPE = int(texelFetch(iChannel0, SHAPE_PIX, 0).r);\n\n    // update state on mouse down in appropriate line\n    ivec2 iCoord = ivec2(fragCoord);\n\tint line = int(TextSize.y*iMouse.y/iResolution.y);\n    if (iMouse.z > 0. && iMouse.w > 0.) {\n        if (iCoord == SEQ_PIX   && line == SEQ_PIX.y  ) SEQ   = (SEQ   + 1) % SEQ_COUNT;\n        if (iCoord == GEN_PIX   && line == GEN_PIX.y  ) GEN   = (GEN   + 1) % GEN_COUNT;\n        if (iCoord == SHAPE_PIX && line == SHAPE_PIX.y) SHAPE = (SHAPE + 1) % SHAPE_COUNT;\n    }\n    \n    // print current settings\n    vec2 cursor  = TextSize*fragCoord/iResolution.y;\n    printSEQ  (cursor - vec2(SEQ_PIX));\n    printGEN  (cursor - vec2(GEN_PIX));\n    printSHAPE(cursor - vec2(SHAPE_PIX));\n\n    // Output to screen\n    fragColor = vec4(draw_char(iChannel1));\n    \n    // save out state\n    if (iCoord == SEQ_PIX  ) fragColor = vec4(SEQ  ,0,0,0);\n    if (iCoord == GEN_PIX  ) fragColor = vec4(GEN  ,0,0,0);\n    if (iCoord == SHAPE_PIX) fragColor = vec4(SHAPE,0,0,0);\n}","name":"Buffer A","description":"","type":"buffer"}]}