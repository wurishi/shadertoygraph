{"ver":"0.1","info":{"id":"4lcXzs","date":"1481073117","viewed":125,"name":"rotating sliced rectangle","username":"zproxy","description":"from https://www.shadertoy.com/view/MldXzf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\n\nvec3 bary(in vec3 a, in vec3 b, in vec3 c, in vec3 p)\n{\n    // The cross product of two vectors has a magnitude\n    // equal to twice the area of the triangle formed by \n    // the two vectors.\n    vec3 n = cross(b - a, c - a);    \n\tfloat area = dot(n, n);\n\t\n\tif(abs(area) < 0.0001) return vec3(0);\n\t\n\tvec3 v0 = a - p;\n\tvec3 v1 = b - p;\n\tvec3 v2 = c - p;\n\t\n\tvec3 asub = vec3(dot(cross(v1, v2), n),\n\t\t\t\t\t dot(cross(v2, v0), n),\n\t\t\t\t\t dot(cross(v0, v1), n));\n    \n\treturn asub / vec3(area);\n}\n\nbool test(in vec2 a, in vec2 b, in vec2 c, in vec2 p)\n{\n    vec3 v = bary(vec3(a.x, 0., a.y),\n                  vec3(b.x, 0., b.y),\n                  vec3(c.x, 0., c.y),\n                  vec3(p.x, 0., p.y));\n    \n    return v.x > 0. && v.y > 0. && v.z > 0.;\n}\n\n\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec2 a0 = vec2( 1.73,  -1.05);\n    vec2 b0 = vec2(0.45,  .65);\n    vec2 c0 = vec2( .25, -.55);\n\n    vec2 mc = (p.zx    / b.xy * 2. - 1.) ;\n\n    bool t0 = test(a0, b0, c0, mc);\n    \n    \n\tvec3 d = abs( p ) - b;\n\t\n    float filler = min( \n        \n        max( d.x, max( d.y, d.z ) )\n        \n        , 0.0 ) + length( max( d, 0.0 ) );\n    \n    \n    //if (p.y > 0.0)\n    //    return 200.0;\n    \n    return filler;\n    return t0 ? filler: 0.0 ;\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, float rot )\n{        \n    vec3 q = abs( p );\n    \n     return max(\n        // creates some type of symmetry\n        q.y - 0.5, \n     \n        // vertical line\n        p.x * cos(rot) + p.z * sin(rot)   \n     );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    // shadertoy should have time slider.\n    \n    p = p * localToWorld;\n    \n    \n    \n    \n    \n    \n      \n    float rot1deg =   20. * iTime;\n    \n    // align our triangle so we need to move union on x axis only.\n    //float rot1deg =   -25.;\n    \n    //float rot1deg =   -20.;\n    //float rot1deg =   -40.;\n    \n    float rot1 =   2.0 * MATH_PI / 360.0 * ( rot1deg);\n    \n    //float rot2a = mod(0.0 + 20. * iTime, 360.);\n    \n    // lets make our triangle slim. \n    float rot2a = 50.;\n\n    //float rot2a = (0.0 + 20. * iTime) % 360.;\n\n    float rot2 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    //float rot22 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    \n    \n    // one angle of a triangle cannot exceed 180 ever\n    \n    if (rot2a > 180.0)\n    \treturn 0.0;\n    \n    \n    float offset1 = sin(iTime) * 0.9 - 0.25;\n\n    \n    // can we move the objects?\n    \n    p += vec3(\n        \n        // up\n        0.0 ,\n              // back\n              -1.0,\n              \n              // right\n              0.0 );\n    \n    \n    \n    \n        float slice0 = TriPrism(  p + vec3(\n        \n        // up\n        1.0 * cos(rot1 + MATH_PI),\n              // back\n              -0.0,\n              \n              // right\n              1.0 * sin(rot1 + MATH_PI) \n        ), rot1 + MATH_PI);\n    \n    \n    float slice1 = TriPrism(  p + vec3(\n        \n        // up\n        1.0 * cos(rot1),\n              // back\n              -0.0,\n              \n              // right\n              1.0 * sin(rot1) \n        ), rot1);\n\n    \n    \n    \n    float slice = min(slice1,slice0)                    ;\n    \n    \n \n    \n     \n    \n    return \n                           \n                           // min means union\n                           // min\n                           \n                           // max means intersect\n                           \n                            max\n                           (slice,\n               Box(  p + vec3(0,0.5,0), vec3(\n                   \n                   // height\n                   1.5, \n                   \n                   //depth\n                   0.05, \n                   \n                   // width\n                   2.0)   )\n               );\n    \n    //return 2.0;\n    \n    // all green\n    return 0.5;\n    \n    // all black\n    return 0.0;\n    \n    \n    // ring\n    float a = Cylinder( p, 0.3, 0.1 );\n    \n    \n    //return Union(ret, a);\n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 15.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 150; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n        steps += 0.03;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    // have comera zoom in and out to reveal boundaries\n\tvec3 rayOrigin \t= vec3( 0.0, -0.0, -3.5 + 0.1 *sin( iTime * 2.0) );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    \n    float phi = 0.25 * MATH_PI + 10.0 * mo.x;    \n    //float phi = 0.25 * MATH_PI; \n    \n    // look straight at it. no mouse\n    //float phi = 0.5 * MATH_PI;    \n\n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    //mat3 localToWorld = rotX * rotY;    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tvec2 result = CastRay( rayOrigin, rayDir, localToWorld );\n    \n    if ( result.x > 0.0 )\n    {\n      color = vec3(result.y*2.0, result.y*0.3, result.y*0.2);\n    }\n    else\n    {\n      color = vec3(0.0, result.y*abs(sin(iTime*1.8)),0.0);\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}