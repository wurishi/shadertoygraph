{"ver":"0.1","info":{"id":"cdjXRG","date":"1670453522","viewed":90,"name":"Segment-Segment Intersection","username":"Envy24","description":".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bezier","intersection","linear","segment"],"hasliked":0,"parentid":"mdBSDm","parentname":"Line-Line Intersection __"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UNIT                      (  2.0 / iResolution.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n// Pseudo-scalar vector multiplication\n//float cross_2d(vec2 L, vec2 R) { return L.x*R.y - L.y*R.x; }\nfloat cross_2d(vec2 L, vec2 R) { return determinant(mat2(L, R)); }\nvec2 segment_segment_intersection(vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    /* Variant 1: *\n    float a = P1.x - P0.x, // A.x\n          b = P3.x - P2.x, // B.x\n          \n          c = P1.y - P0.y, // A.y\n          d = P3.y - P2.y, // B.y\n          \n          e = P2.x - P0.x, // C.x\n          f = P2.y - P0.y; // C.y        \n    return vec2(\n        (e*d-b*f)/(a*d-b*c),\n        (c*e-a*f)/(a*d-c*b) );\n        \n    /* Variant 2: *\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / (A.x*B.y-A.y*B.x);\n    return vec2(\n        (B.y*C.x-B.x*C.y)*inv,\n        (A.y*C.x-A.x*C.y)*inv);\n        \n    /* Variant 3: */\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / cross_2d(A, B);\n    return vec2(\n        cross_2d(C, B)*inv,\n        cross_2d(C, A)*inv);\n}\n\nmat2 rotz(float rad)\n{\n    vec2 cs = vec2(cos(rad), sin(rad));\n    mat2 M = mat2( // row order\n         cs.x, -cs.y,\n         cs.y,  cs.x);\n    return transpose(M); // column order\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), true);\n    \n    vec3 color = vec3(1);\n    \n    float T = iTime;\n    vec2 P0=rotz(-T*0.5)*vec2(-0.75, -0.55), P1=rotz(-T*0.5)*vec2(0.75, 0.75)+vec2(sin(T))*0.5,\n         P2=rotz(T*0.25)*vec2(-0.1, -0.75), P3=rotz(T*0.25)*vec2(0.1, 0.75)-vec2(sin(T))*0.5;\n    \n    color = mix( color, vec3(1,0,0), SMAA(segmentSDF_L2(NDC, P0, P1, 0.)) );\n    color = mix( color, vec3(0,1,0), SMAA(segmentSDF_L2(NDC, P2, P3, 0.)) );\n    \n    // Corresponding t values:                   t.y = 0   1\n    //                                   t.x = 0   1\n    vec2 roots = segment_segment_intersection(P0, P1, P2, P3);\n    if (roots.x >= 0. && roots.x <= 1. && roots.y >= 0. && roots.y <= 1.) {\n        color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, P0+(P1-P0)*roots.x, 0.02)) );\n        color = mix( color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, P2+(P3-P2)*roots.y, 0.01)) );\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}