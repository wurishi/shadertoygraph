{"ver":"0.1","info":{"id":"mtf3WN","date":"1671756656","viewed":167,"name":"System additivity checker","username":"Envy24","description":"Read Image tab header.\n\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["linear","system","response","graphs","dsp","additivity"],"hasliked":0,"parentid":"ctfGz7","parentname":"System Response Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n   n = f(t) - discrete function of time,\n   Blue - input signal x(n),\n   Red - system response y(n) to signal x(n) = x1(n) + x2(n),\n   Purple - sum of system responses y1(n), y2(n) to signals x1(n), x2(n).\n\n   If system is not additive, then you see both red and purple samples,\n   otherwise only purple samples.\n   \n   Additivity property (T[] - transformation): \n       y(n) = T[x(n)] = T[x1(n) + x2(n)] = T[x1(n)] + T[x2(n)].\n*/\n\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define ORIGIN                    ( vec2(0, 0) )\n#define SCENE_SCALE               ( 15.0 )\n#define UNIT                      ( 2.0*SCENE_SCALE / R.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n                           \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nfloat step_(float n) { return n < 0. ? 0. : 1.; } // step signal\nfloat unit(float n) { return n == 0. ? 1. : 0.; } // unit impulse\n\n#define MIN (-21.)\n#define MAX (20.)\n#define T (iTime * 0.1)\n\n//#define LOOP(T) ( loop_continuous(MIN, MAX, T) )\n//#define LOOP(T) ( loop_discrete(MIN, MAX, T) )\n#define LOOP(T) ( (40.*T) )\n//#define LOOP(T) ( 0. ) // off loop\n\nfloat x1(float n)\n{\n    n -= LOOP(T);\n    return sin(0.15*n) * 4.;\n}\nfloat x2(float n)\n{\n    n -= LOOP(T);\n    return tan(sin(sin(n)));\n}\nfloat x(float n) { return x1(n) + x2(n); }\n\n/* Non additive system. */\nfloat y1(float n) { return (0.1*x1(n) + (x1(n + 1.)*x1(n-1.)) / clamp(x1(n), 4., 6.))*sign(x1(n)); }\nfloat y2(float n) { return (0.1*x2(n) + (x2(n + 1.)*x2(n-1.)) / clamp(x2(n), 4., 6.))*sign(x2(n)); }\nfloat y(float n) { return (0.1*x(n) + (x(n + 1.)*x(n-1.)) / clamp(x(n), 4., 6.))*sign(x(n)); }\n/* Additive system. *\nfloat y1(float n) { return x1(n*n - 2.*n + 1.); }\nfloat y2(float n) { return x2(n*n - 2.*n + 1.); }\nfloat y(float n) { return x(n*n - 2.*n + 1.); }\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    float vert_offset = 7.,  // offset relative to y = 0 line\n          vert_shift = -0.,  // shifts plot up or down\n          x_offs = vert_offset + vert_shift,\n          y_offs = vert_shift - vert_offset;\n\n    vec3 X_col = vec3(0,0,1), Y_col = vec3(1,0,0), Z_col = vec3(1,0,1), color = vec3(1.);\n    /* Common stuff */\n         color -= x_axis(vec2(NDC.x, NDC.y - x_offs)); \n         color -= x_axis(vec2(NDC.x, NDC.y - y_offs));\n         color -= y_axis(NDC);\n         //color = mix(color, vec3(0,.5,0), vertical_line(NDC, MIN));\n         //color = mix(color, vec3(0,.5,0), vertical_line(NDC, MAX));\n         //color = mix(color, vec3(0,0,.5), vertical_line(NDC, LOOP(T)));\n\n    /* Variant 1. *\n    float n = round(NDC.x), X = x(n) + x_offs, Y = y(n) + y_offs;\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(n, X), 2.5*UNIT)));\n         color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(n, Y), 2.5*UNIT)));\n    /* Variant 2. *\n    float n = floor(NDC.x), X = x(n) + x_offs, Y = y(n) + y_offs;\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(NDC.x, X), UNIT)));\n         color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(NDC.x, Y), UNIT)));\n    /* Variant 3. */\n    float n = round(NDC.x), X = x(n) + x_offs, Y = y(n) + y_offs, Z = y1(n) + y2(n) + y_offs;\n         color = mix(color, X_col, SMAA(segmentSDF_L2(NDC, vec2(n, x_offs), vec2(n, X), UNIT*0.25)));\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(n, X), 2.5*UNIT)));\n         \n         color = mix(color, Y_col, SMAA(segmentSDF_L2(NDC, vec2(n, y_offs), vec2(n, Y), UNIT*0.25)));\n         color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(n, Y), 2.5*UNIT)));\n         \n         color = mix(color, Z_col, SMAA(segmentSDF_L2(NDC, vec2(n, y_offs), vec2(n, Z), UNIT*0.25)));\n         color = mix(color, Z_col, SMAA(diskSDF_L2(NDC, vec2(n, Z), 2.5*UNIT)));\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float loop_continuous(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return (min + fract(T) * range);\n}\nfloat loop_discrete(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return round(min + fract(T) * range);\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}","name":"Common","description":"","type":"common"}]}