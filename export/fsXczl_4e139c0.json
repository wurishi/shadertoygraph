{"ver":"0.1","info":{"id":"fsXczl","date":"1642500043","viewed":194,"name":"Reflection-Celestial Spheres 2.0","username":"PGRacer","description":"WASD/shift/space and mouse look to move.\nAdded reflection and some additional iridescent color to my previous Celestial Spheres.\nGetting between the tetrad of spheres will probably slow things down A LOT if it isn't slow already.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","reflection","sdf","reflections"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////\n// IMAGE SHADER //\n//////////////////\n\n// COLUMN PARAMETERS\n#define COLUMN_OUTER_WIDTH   0.25\n#define COLUMN_INNER_WIDTH   0.05\n#define COLUMN_STACK_SIZE    7.0\n#define COLUMN_BASE_HEIGHT   0.125\n#define COLUMN_BASE_RADIUS   0.35\n#define COLUMN_BASE_ROUNDING 0.01\n#define COLUMN_SPHERE_RADIUS 0.35\n#define COLUMN_TWIST         TAU * 0.25 / COLUMN_OUTER_WIDTH\n#define COLUMN_HEIGHT        COLUMN_STACK_SIZE * COLUMN_OUTER_WIDTH + COLUMN_BASE_HEIGHT\n\n// PLATFORM PARAMETERS\n#define PLATFORM_RADIUS 3.0\n#define PLATFORM_THICKNESS 0.1\n#define PLATFORM_ROUNDING 0.1\n\n// MATERIAL IDS\nconst int MAT_WEAVE = 0;\nconst int MAT_TILE = 1;\nconst int MAT_METAL = 2;\nconst int MAT_STARS = 3;\nconst int MAT_WOOD = 4;\nconst int MAT_ROCK = 5;\nconst int MAT_STONE = 6;\nconst int MAT_MIRROR = 7;\n\nSDFSample ColumnBlock(vec3 p)\n{\n    vec3 pBlock = p;\n    \n    vec3 pBlock1 = Twist(pBlock, COLUMN_TWIST);\n    pBlock1 = RepeatRange(pBlock1, vec3(COLUMN_OUTER_WIDTH), vec3(2.0, 1.0, 2.0));\n    SDFSample s1 = Box(pBlock1, vec3(COLUMN_INNER_WIDTH, COLUMN_OUTER_WIDTH, COLUMN_INNER_WIDTH));\n    \n    vec3 pBlock2 = Twist(pBlock, -COLUMN_TWIST);\n    pBlock2 = RepeatRange(pBlock2, vec3(COLUMN_OUTER_WIDTH), vec3(2.0, 1.0, 2.0));\n    SDFSample s2 = Box(pBlock2, vec3(COLUMN_INNER_WIDTH, COLUMN_OUTER_WIDTH, COLUMN_INNER_WIDTH));    \n    \n    SDFSample sColumnBlock = Union(s1, s2);\n    sColumnBlock.m = MAT_WOOD;\n    sColumnBlock.f = 5.0;\n    sColumnBlock.d *= 0.7;\n    \n    return sColumnBlock;\n}\n\nSDFSample Column(vec3 p, SDFSample sPrev)\n{\n    SDFSample sBounds = Box(p - UP * 0.1, vec3(COLUMN_BASE_RADIUS * 2.0, COLUMN_HEIGHT + COLUMN_SPHERE_RADIUS * 2.0, COLUMN_BASE_RADIUS * 2.0));\n    if (sBounds.d > sPrev.d)\n    {\n        return sPrev;\n    }    \n    \n    vec3 pColumnBlocks = RepeatRange(p, vec3(COLUMN_OUTER_WIDTH + COLUMN_INNER_WIDTH, COLUMN_OUTER_WIDTH, COLUMN_OUTER_WIDTH + COLUMN_INNER_WIDTH), vec3(1.0, COLUMN_STACK_SIZE, 1.0));\n    SDFSample sColumnBlocks = ColumnBlock(pColumnBlocks);\n    \n    vec3 pCylinder1 = p - DOWN * (COLUMN_STACK_SIZE * 0.5 * COLUMN_OUTER_WIDTH + COLUMN_BASE_HEIGHT * 0.5);\n    SDFSample sCylinder1 = Cylinder(pCylinder1, COLUMN_BASE_HEIGHT, COLUMN_BASE_RADIUS);\n    sCylinder1.d -= COLUMN_BASE_ROUNDING;\n    sCylinder1.m = MAT_WOOD;\n    \n    SDFSample sCylinder2 = Cylinder(p, COLUMN_OUTER_WIDTH * COLUMN_STACK_SIZE, COLUMN_OUTER_WIDTH * 0.2);\n    sCylinder2.m = MAT_METAL;\n    \n    vec3 pTorus = p - UP * (COLUMN_OUTER_WIDTH * COLUMN_STACK_SIZE * 0.5 - COLUMN_OUTER_WIDTH * 0.5);\n    SDFSample sTorus = Torus(pTorus, COLUMN_OUTER_WIDTH, COLUMN_INNER_WIDTH);\n    sTorus.m = MAT_WOOD;\n    sTorus.f = 5.0;\n    \n    vec3 pSphere = RotateY(iTime) * p - UP * ((COLUMN_OUTER_WIDTH * COLUMN_STACK_SIZE + COLUMN_SPHERE_RADIUS) * 0.5);\n    SDFSample sSphere =  Sphere(pSphere,  COLUMN_SPHERE_RADIUS);\n    sSphere.m = MAT_MIRROR;\n    sSphere.f = 3.0;\n    \n    SDFSample sCylinders = Union(sCylinder1, sCylinder2);\n    sCylinders.f = 4.0;\n    \n    SDFSample sColumn = Union(sCylinders, sSphere);\n    \n    sColumn = Union(sColumn, sColumnBlocks);\n    sColumn = Union(sColumn, sTorus);\n\n    return sColumn;\n}\n\n#define R_BASE 0.577350\n#define H_TOP 0.8164966\n\nSDFSample Spheres(vec3 p)\n{\n    mat3 rot = Rotate3(iTime * R_BASE * 2.0, normalize(vec3(0.0, 1.0, ROOT3)));\n    \n    vec3 pSphere1 = rot * (RotateY(2.0 * TAU / 3.0) * p - FORWARD * R_BASE);\n    SDFSample sSphere1 = Sphere(pSphere1, 0.5);\n    \n    vec3 pSphere2 = rot * (RotateY(TAU / 3.0) * p - FORWARD * R_BASE);\n    SDFSample sSphere2 = Sphere(pSphere2, 0.5);\n    \n    vec3 pSphere3 = rot * (p - FORWARD * R_BASE);\n    SDFSample sSphere3 = Sphere(pSphere3, 0.5);\n    \n    vec3 pSphere4 = RotateY(iTime) * p - UP * H_TOP;\n    SDFSample sSphere4 = Sphere(pSphere4, 0.5);\n    \n    SDFSample sSpheres = Union(sSphere1, sSphere2);\n    sSpheres = Union(sSpheres, sSphere3);\n    sSpheres = Union(sSpheres, sSphere4);\n    \n    sSpheres.m = MAT_MIRROR;\n    sSpheres.f = 3.0;\n    \n    return sSpheres;\n}\n\nSDFSample Platform(vec3 p)\n{\n    vec3 pPlatform = p - DOWN * (PLATFORM_THICKNESS * 0.5 + PLATFORM_ROUNDING);\n    SDFSample sCylinder = Cylinder(pPlatform, PLATFORM_THICKNESS, PLATFORM_RADIUS);\n    sCylinder.m = MAT_MIRROR;\n    sCylinder.f = 2.0;\n    \n    SDFSample sRim = Torus(pPlatform - UP * PLATFORM_THICKNESS, PLATFORM_RADIUS, PLATFORM_THICKNESS * 0.1);\n    SDFSample sHoop = Hoop(pPlatform, PLATFORM_THICKNESS, PLATFORM_RADIUS + 0.05, PLATFORM_RADIUS);\n    sHoop.m = MAT_WOOD;\n    sHoop = SmoothUnion(sHoop, sRim, 0.1);\n    \n    vec3 pTorus = p - UP * 0.25;\n    SDFSample sTorus = Torus(pTorus, R_BASE, 0.5);\n    sTorus.m = MAT_METAL;\n    \n    SDFSample sHole = Cylinder(p, 1.0, R_BASE + 0.5);\n    SDFSample sPlug = Cylinder(p - DOWN * (0.5 * PLATFORM_THICKNESS + PLATFORM_ROUNDING), PLATFORM_THICKNESS + PLATFORM_ROUNDING * 2.0, R_BASE + 0.5);\n    sPlug.m = MAT_WOOD;\n    sPlug.d -= PLATFORM_ROUNDING;\n        \n    SDFSample sPlatform = Union(sCylinder, sHoop);\n    sPlatform.d -= PLATFORM_ROUNDING;\n    \n    \n    sPlatform = Difference(sPlatform, sHole, 0.0);\n    sPlatform = Union(sPlatform, sPlug);\n    sPlatform = Difference(sPlatform, sTorus, 0.0);\n    \n    return sPlatform;\n}\n\nSDFSample Scene(vec3 p)\n{\n    SDFSample sPlatform = Platform(p);\n    \n    vec3 pColumns = RepeatRange(p, vec3(3.25, 6.0, 3.25), vec3(2.0, 1.0, 2.0));\n    SDFSample sColumns = Column(pColumns - UP * (COLUMN_STACK_SIZE * COLUMN_OUTER_WIDTH * 0.5 + COLUMN_BASE_HEIGHT + COLUMN_BASE_ROUNDING), sPlatform);\n    \n    vec3 pSpheres = RotateY(iTime) * p - UP * 0.25;\n    SDFSample sSpheres = Spheres(pSpheres);\n    \n    SDFSample sScene = sPlatform; \n    sScene = Union(sScene, sColumns);\n    sScene = Union(sScene, sSpheres);\n    \n    return sScene;\n}\n\nvec3 GetNormal(SDFSample s)\n{\n\tvec2 e = vec2(NORMAL_CHECK_OFFSET, 0);\n    \n\tvec3 n = Scene(s.pW).d - vec3(\n\t\tScene(s.pW - e.xyy).d,\n\t\tScene(s.pW - e.yxy).d,\n\t\tScene(s.pW - e.yyx).d\n\t\t);\n\treturn normalize(n);\n}\n\nfloat GetAO(SDFSample s, vec3 n)\n{\n    float stepSize = AMBIENT_OCCLUSION_STEP_SIZE;\n    float t = stepSize;\n\n    float ac = 0.0;\n\n    for(float i = 0.0; i < AMBIENT_OCCLUSION_STEP_COUNT; i++) {\n        float d = Scene(s.pW + n * t).d;\n        ac += t - d;\n        t += stepSize;\n    }\n    return 1.0 - ac / 2.0;\n}\n\nfloat GetShadows(vec3 ro, vec3 rd, float tMax)\n{\n    float res = 1.0;\n    float t = SHADOW_CORRECTION;\n    for( int i=0; i<50; i++ )\n    {\n        float h = Scene(ro + rd * t).d;\n        res = min( res, tMax*h/t );\n        t += h;clamp( h, 0.005, 0.5 );\n        if( res<0.005 || t>tMax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nSDFSample SampleScene(vec3 origin, vec3 rayDir, out float distFromOrigin, out bool hit, out bool outline)\n{\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    vec3 p;\n    float prevDist = MAX_DIST;\n    SDFSample s;\n    \n    distFromOrigin = 0.0;\n    hit = false;\n    outline = false;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = origin + rayDir * distFromOrigin;\n\t\ts = Scene(p);\n\t\tdistFromOrigin += s.d;\n        \n        if (s.d < outlineWidth * pow(distFromOrigin, OUTLINE_DIST_COMP))\n\t\t{\n\t\t\toutline = true;\n\t\t}\n        \n        if (distFromOrigin >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (s.d < SURFACE_DISTANCE_TOLERANCE)\n\t\t{\n            hit = true;\n\t\t\toutline = false;\n            s.pW = p;\n\t\t\tbreak;\n\t\t}\n        \n        if (outline && prevDist < s.d)\n        {\n            hit = false;\n            break;\n        }\n        \n        prevDist = s.d;\n    }\n    \n    return s;\n}\n\nvec3 GetLight(SDFSample s, LightSource ls, MaterialSample mat, float ao, vec3 normal)\n{\n    vec3 lightDir = normalize(s.pW - ls.pos);\n\n    float lightDist = distance(s.pW, ls.pos);\n    float shadowValue = GetShadows(s.pW, -lightDir, lightDist);\n\n    float attenuation = 1.0 / (pow(lightDist, 2.0));\n    float light = ls.str * attenuation;\n\n    float scalar = dot(-lightDir, normal);\n    scalar = clamp(scalar, 0.0, 1.0);\n    float specular = mat.metallic * pow(scalar, 64.0);\n    light += specular;\n     \n    light *= scalar;\n    light *= shadowValue;\n    light += ao * ls.str * attenuation;   \n        \n    return light * ls.col;\n}\n\nvec2 GetRegionalCoord(vec2 uv, vec3 region)\n{\n    return (fract(uv) + region.xy) / region.z;\n}\n\nvec3 GetTriPlanarTexture(vec3 p, vec3 normal, sampler2D sampler, vec3 region)\n{\n    vec3 texXY = texture(sampler, GetRegionalCoord(p.xy * 0.5 + 0.5, region)).rgb;\n    vec3 texXZ = texture(sampler, GetRegionalCoord(p.xz * 0.5 + 0.5, region)).rgb;\n    vec3 texYZ = texture(sampler, GetRegionalCoord(p.yz * 0.5 + 0.5, region)).rgb; \n        \n    normal = abs(normal);\n    normal = pow(normal, vec3(0.00001));\n    normal /= SumComponents(normal);\n    \n    vec3 tex = texXY * normal.z + texXZ * normal.y + texYZ * normal.x;\n    \n    return tex;\n}\n\nMaterialSample GetSurfaceColor(SDFSample s, vec3 rayDir, vec3 normal)\n{\n    MaterialSample ms;\n    vec3 p = s.pO * s.f;\n    ms.reflectivity = 0.0;\n\n    switch(s.m)\n    {\n        case MAT_WEAVE:\n            ms.col = GetTriPlanarTexture(p, normal, iChannel1, vec3(0.0, 0.0, 4.0));\n            ms.metallic = 0.0;\n            break;\n        case MAT_TILE:\n            ms.col = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 0.0, 4.0));\n            ms.metallic = ms.col.r - (ms.col.g + ms.col.b) / 2.0;\n            break;\n        case MAT_METAL:\n            ms.col = GetTriPlanarTexture(p, normal, iChannel1, vec3(0.0, 1.0, 4.0));\n            ms.metallic = 1.0 - (ms.col.r - (ms.col.g + ms.col.b) / 2.0);\n            ms.smoothness = 1.0;\n            break;\n        case MAT_STARS:\n            ms.col = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 1.0, 4.0));\n            break;\n        case MAT_WOOD:\n            ms.col = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 0.0, 2.0));\n            break;\n        case MAT_ROCK:\n            ms.col = GetTriPlanarTexture(p, normal, iChannel1, vec3(0.0, 1.0, 2.0));\n            break;\n        case MAT_STONE:\n            ms.col = GetTriPlanarTexture(p, normal, iChannel1, vec3(1.0, 1.0, 2.0));\n            break;\n        case MAT_MIRROR:\n            float distFromOrigin = 0.0;\n            ms.col = 0.2 + 0.4 * pow(vec3(GetTriPlanarTexture(p, normal, iChannel2, vec3(0.0, 0.0, 1.0)).r), vec3(4.0));\n            vec3 localNormal = normalize(s.pO + vec3(1.0));\n            vec3 iridescent = vec3(NSin(localNormal.r), NSin(localNormal.g), NSin(localNormal.b));\n            ms.col += pow(iridescent, vec3(8.0));\n            float scalar = clamp(dot(-rayDir, normal), 0.0, 1.0);\n            ms.metallic = 3.0 - 2.5 * (1.0 - scalar);\n            ms.reflectivity = 0.05 + 0.95 * (1.0 - scalar);\n            break;\n    }\n\n    return ms;\n}\n\nvec3 ColorCorrection(vec3 color)\n{\n    if (COLOR_BIT_DEPTH < 8.0)\n    {\n        float colorsPerChannel = pow(2.0, COLOR_BIT_DEPTH);\n        color = floor(color * colorsPerChannel) / colorsPerChannel;\n    }\n    \n    color = (color - vec3(0.5)) * CONTRAST + vec3(0.5);\n    color = pow(color / 255.0, vec3(1.0 / GAMMA)) * 255.0;\n    color = mix(vec3(AvgComponentLength(color)), color, SATURATION);\n    color = mix(color, vec3(1.0) - color, NEGATIVE);\n    color *= TINT;\n\n    return color;\n}\n\nvec3 GetBackground(vec3 rayDir)\n{\n    vec3 r3 = N33(floor(rayDir * iResolution.y * 0.5) / iResolution.y * 2.0);\n    float r1 = pow(N31(r3), 20.0);\n    float stars = smoothstep(0.95, 0.995, r1);\n    \n    vec3 v = vec3(NSin(iTime * 0.2496 + rayDir.r), NSin(iTime * 0.354 + rayDir.g), NSin(iTime * 0.4289 + rayDir.b));\n    v *= 0.2;\n    \n    v += mix(vec3(stars), r3 * stars, 0.66);\n    \n    return v;\n}\n\nvec3 Render(vec3 camPos, vec3 camDir)\n{\n    // Do raymarching\n    float distFromOrigin = 0.0;\n    bool hit;\n\tbool outline;\n    \n    vec3 rayOrigin = camPos;\n    vec3 rayDir = camDir;\n        \n    // Light Sources\n    LightSource ls1 = LightSource(RotateY(TIME * 0.6289) * vec3(8.0, 8.0, -12.0), YELLOW, 100.0);\n    LightSource ls2 = LightSource(RotateY(TIME * 1.4023) * vec3(8.0, 8.0, -12.0), TURQUOISE, 100.0);\n    LightSource ls3 = LightSource(RotateY(TIME) * vec3(8.0, 8.0, -12.0), FUCHSIA, 100.0);\n    \n    SDFSample s;\n    vec3 finalColor;\n    vec3 bgColor;\n    float mainDistRatio = -1.0;\n    int hitCount = 0;\n    float reflectionStrength = 1.0;\n    MaterialSample m;\n    \n    do {\n        distFromOrigin = 0.0;\n        hit = false;\n        outline = false;\n        \n        bgColor = GetBackground(RotateY(iTime * 0.1) * rayDir);\n        s = SampleScene(rayOrigin, rayDir, distFromOrigin, hit, outline);\n        \n        vec3 color = BLACK;\n        \n        float distRatio = distFromOrigin / MAX_DIST;\n        mainDistRatio = mainDistRatio < 0.0 ? distRatio : mainDistRatio;\n        vec3 normal = GetNormal(s);\n    \n        // Apply color to pixel\n        if (hit)\n        {\n            m = GetSurfaceColor(s, rayDir, normal);\n            color = m.col * reflectionStrength * (1.0 - m.reflectivity);\n            reflectionStrength *= m.reflectivity;\n            float ao = GetAO(s, normal);\n            \n            vec3 light = GetLight(s, ls1, m, ao, normal);\n            light += GetLight(s, ls2, m, ao, normal);\n            light += GetLight(s, ls3, m, ao, normal);\n            \n            color *= light;\n        }\n        else if (outline)\n        {\n            color = vec3(0.0);\n        }\n        else\n        {\n            color = bgColor;\n        }\n        \n        finalColor += color;\n        \n        rayDir = reflect(rayDir, normal);\n        rayOrigin = s.pW + normal * SURFACE_DISTANCE_TOLERANCE * 1.05;\n        hitCount++;\n    }\n    while (m.reflectivity > 0.0 && hit && !outline && hitCount < MAX_RAY_HITS);\n    \n    // Saturate and apply distance fade\n    finalColor = clamp(finalColor, vec3(0.0), vec3(1.0));\n    finalColor = mix(finalColor, bgColor, pow(mainDistRatio, FADE_ATTENUATION));\n    \n    return finalColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alter resolution for old-school look\n    fragCoord *= RESOLUTION_RATIO;\n    fragCoord = floor(fragCoord) / RESOLUTION_RATIO;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Split-screen stereoscopy\n#ifdef STEREO_ENABLED\n    bool leftEye = uv.x >= 0.5;\n    uv.x = fract(uv.x * 2.0);\n    uv.x *= 0.5;\n    uv -= vec2(0.25, 0.5);\n#else\n    uv -= vec2(0.5);\n#endif\n\n    // Vignette\n    float uvLength = length(uv);\n    uvLength = uvLength * 1.33333 - .25;\n    float vignette = smoothstep(0.99, 0.001, uvLength);\n    \n    // Aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    // Camera Stuff\n    vec3 camPos = textureLod(iChannel0, vec2(0.5, 0.5)/iResolution.xy, 0.0).xyz;\n\n    // Camera look direction\n    vec3 camRot = textureLod(iChannel0, vec2(1.5, 0.5)/iResolution.xy, 0.0).xyz;\n    mat3x3 yawMat = Rotate3(camRot.x, UP);\n    mat3x3 pitchMat = Rotate3(camRot.y, RIGHT);\n    mat3x3 rollMat = Rotate3(camRot.z, FORWARD);\n    mat3x3 rotMat = yawMat * pitchMat * rollMat;\n    vec3 camDir = rotMat * normalize(vec3(uv.x, uv.y, 1.0));\n    \n#ifdef STEREO_ENABLED\n    // Stereo eye-positioning\n    camPos += rotMat * ((leftEye ? LEFT : RIGHT) * INTERPUPILARY_DISTANCE * 0.5);\n#endif\n    \n    // Render the scene\n    vec3 color = Render(camPos, camDir);\n    \n    // Apply color correction\n    color = ColorCorrection(color);\n    \n#ifdef SCAN_LINES_ENABLED\n    if (mod(fragCoord.y * RESOLUTION_RATIO, 2.0) < 1.0) color = BLACK;\n#endif\n          \n    // Fade scene in at start\n    color *= smoothstep(FADE_IN_DELAY, FADE_IN_DELAY + FADE_IN_LENGTH, iTime);\n    color *= vignette;\n        \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////\n// COMMON FUNCTIONS AND VALUES //\n/////////////////////////////////\n\n// RAYMARCHING\n#define MAX_STEPS 2000\n#define MAX_DIST 10.0\n#define SURFACE_DISTANCE_TOLERANCE 0.0001\n#define NORMAL_CHECK_OFFSET 0.0001\n#define MAX_RAY_HITS 20\n\n// TIMING\n#define TIME iTime * 1.0\n\n// OUTLINE\n#define OUTLINE_WIDTH 3.0\n#define OUTLINE_DIST_COMP 0.7 // 0.0 lines shrink linearly with distance, 0.5 - lines stay same world-width at all distances, 1.0 - lines stay same screen width at distance \n\n// LIGHTING\n#define FADE_ATTENUATION 10.0\n#define AMBIENT_OCCLUSION_STEP_SIZE 0.006\n#define AMBIENT_OCCLUSION_STEP_COUNT 20.0\n#define AMBIENT_OCCLUSION_ATTENUATION 1.0\n#define SHADOW_CORRECTION 0.001\n\n// SCENE START\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n\n// COMMON CONSTANTS\n#define TAU 6.283185\n#define PI  TAU / 2.0\n#define ROOT2 1.414213\n#define ROOT3 1.732050\n\n// AXIAL VECTORS\n#define FORWARD vec3(0.0, 0.0, 1.0)\n#define BACKWARD vec3(0.0, 0.0, -1.0)\n#define LEFT vec3(-1.0, 0.0, 0.0)\n#define RIGHT vec3(1.0, 0.0, 0.0)\n#define UP vec3(0.0, 1.0, 0.0)\n#define DOWN vec3(0.0, -1.0, 0.0)\n\n// COLORS\n#define BLACK vec3(0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define BROWN vec3(0.5, 0.2, 0.0)\n#define DARK_GREY vec3(0.25, 0.25, 0.25)\n#define FUCHSIA vec3(1.0, 0.0, 1.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define LIGHT_GREY vec3(0.75, 0.75, 0.75)\n#define MEDIUM_GREY vec3(0.5, 0.5, 0.5)\n#define ORANGE vec3(1.0, 0.5, 0.0)\n#define PINK vec3(1.0, 0.5, 0.5)\n#define RED vec3(1.0, 0.0, 0.0)\n#define TURQUOISE vec3(0.0, 1.0, 1.0)\n#define WHITE vec3(1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\n\n// COLOR CORRECTION\n#define COLOR_BIT_DEPTH 8.0\n#define GAMMA 1.0\n#define CONTRAST 1.0\n#define SATURATION 1.0\n#define NEGATIVE 0.0\n#define TINT WHITE\n\n// RENDERING OPTIONS\n//#define STEREO_ENABLED // Comment/Uncomment to disable/enable. Use cross-eye method to view.\n#define INTERPUPILARY_DISTANCE 0.064\n//#define SCAN_LINES_ENABLED // Comment/Uncomment to disable/enable.\n#define RESOLUTION_RATIO 1.0 // 0.0 will result in divide-by-zero, magnitude 1.0+ will have no effect.  negative values will shift pixels (-1,-1).\n\n// INPUT KEYS\n#define KEY_SHIFT   16\n#define KEY_CONTROL 17\n#define KEY_SPACE   32\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_A       65\n#define KEY_B       66\n#define KEY_C       67\n#define KEY_D       68\n#define KEY_E       69\n#define KEY_F       70\n#define KEY_G       71\n#define KEY_H       72\n#define KEY_I       73\n#define KEY_J       74\n#define KEY_K       75\n#define KEY_L       76\n#define KEY_M       77\n#define KEY_N       78\n#define KEY_O       79\n#define KEY_P       80\n#define KEY_Q       81\n#define KEY_R       82\n#define KEY_S       83\n#define KEY_T       84\n#define KEY_U       85\n#define KEY_V       86\n#define KEY_W       87\n#define KEY_X       88\n#define KEY_Y       89\n#define KEY_Z       90\n#define KEY_0       48\n#define KEY_1       49\n#define KEY_2       50\n#define KEY_3       51\n#define KEY_4       52\n#define KEY_5       53\n#define KEY_6       54\n#define KEY_7       55\n#define KEY_8       56\n#define KEY_9       57\n\n// MOUSE BUTTON INPUT\nbool IsNewClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y < 1.0;\n}\n\nbool IsPersistentClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y > 0.0;\n}\n\nbool IsNewRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y > 0.0;\n}\n\nbool IsPersistentRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y < 1.0;\n}\n\n// KEYBOARD INPUT\nbool ReadKey(sampler2D sampler, int key, bool toggle)\n{\n\treturn textureLod(sampler, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x > 0.0;\n}\n\n// MATRICES\nmat2x2 Rotate2(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nmat3x3 Rotate3(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n\t\tt * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n\t\tt * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n\t);\n}\n\nmat3 RotateX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\n\nmat3 RotateY(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 RotateZ(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, s, 0.0,\n\t\t-s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n}\n\n// USEFUL MATH STUFF\nfloat SumComponents(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\nfloat SumComponentLength(vec3 v)\n{\n    return SumComponents(abs(v));\n}\n\nfloat AvgComponents(vec3 v)\n{\n    return (v.x + v.y + v.z) / 3.0;\n}\n\nfloat AvgComponentLength(vec3 v)\n{\n    return AvgComponents(abs(v));\n}\n\nfloat ComponentVariance(vec3 v)\n{\n    float mean = AvgComponentLength(v);\n    vec3 sqDiff = vec3(mean) - v * v;\n    float sum = SumComponents(sqDiff);\n    return sum / 3.0;\n}\n\nfloat NSin(float value)\n{\n    return sin(value) * 0.5 + 0.5;\n}\n\nfloat NCos(float value)\n{\n    return cos(value) * 0.5 + 0.5;\n}\n\nfloat SFract(float v)\n{\n    if (v >= 0.0)\n    {\n        return v - floor(v);\n    }\n    return -(v - ceil(v));\n}\n\nvec2 SFract(vec2 v)\n{\n    return vec2(SFract(v.x), SFract(v.y));\n}\n\nvec3 SFract(vec3 v)\n{\n    return vec3(SFract(v.xy), SFract(v.z));\n}\n\nfloat SMod(float v, float x)\n{\n    return x == 0.0 ? v : SFract(v / x) * x;\n}\n\nvec2 SMod(vec2 v, vec2 x)\n{\n    return vec2(SMod(v.x, x.x), SMod(v.y, x.y));\n}\n\nvec3 SMod(vec3 v, vec3 x)\n{\n    return vec3(SMod(v.xy, x.xy), SMod(v.z, x.z));\n}\n\nvec3 FlipX(vec3 p)\n{\n    return vec3(-p.x, p.y, p.z);\n}\n\nvec3 FlipY(vec3 p)\n{\n    return vec3(p.x, -p.y, p.z);\n}\n\nvec3 FlipZ(vec3 p)\n{\n    return vec3(p.x, p.y, -p.z);\n}\n\nvec3 AbsX(vec3 p)\n{\n    return vec3(abs(p.x), p.y, p.z);\n}\n\nvec3 AbsY(vec3 p)\n{\n    return vec3(p.x, abs(p.y), p.z);\n}\n\nvec3 AbsZ(vec3 p)\n{\n    return vec3(p.x, p.y, abs(p.z));\n}\n\nvec3 AbsXY(vec3 p)\n{\n    return vec3(abs(p.x), abs(p.y), p.z);\n}\n\nvec3 AbsXZ(vec3 p)\n{\n    return vec3(abs(p.x), p.y, abs(p.z));\n}\n\nvec3 AbsYZ(vec3 p)\n{\n    return vec3(p.x, abs(p.y), abs(p.z));\n}\n\nvec3 NegateX(vec3 p)\n{\n    return vec3(-abs(p.x), p.y, p.z);\n}\n\nvec3 NegateY(vec3 p)\n{\n    return vec3(p.x, -abs(p.y), p.z);\n}\n\nvec3 NegateZ(vec3 p)\n{\n    return vec3(p.x, p.y, -abs(p.z));\n}\n\n// STRUCTS\nstruct MaterialSample\n{\n    vec3 col;\n    float metallic;\n    float smoothness;\n    float reflectivity;\n};\n\nstruct SDFSample\n{\n    float d;\n    vec3 pW;\n    vec3 pO;\n    int m;\n    float f;\n};\n\nstruct LightSource\n{\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\n// COMBINATIONS\nSDFSample Union(SDFSample d1, SDFSample d2)\n{\n    if (d1.d < d2.d) return d1; return d2;\n}\n\nSDFSample SmoothUnion(SDFSample s1, SDFSample s2, float smoothing)\n{\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / smoothing, 0.0, 1.0);\n    float dMix = mix(s2.d, s1.d, h) - smoothing * h * (1.0 - h);\n    return SDFSample(dMix, s1.pW, s1.pO, s1.m, s1.f);\n}\n\nSDFSample Difference(SDFSample s1, SDFSample s2, float c)\n{\n    float clearance = s2.d - c;\n    return SDFSample(s1.d > -clearance ? s1.d : -clearance, s1.pW, s1.pO,  s1.m, s1.f);\n}\n\nSDFSample SmoothDifference(SDFSample s1, SDFSample s2, float smoothing) {\n    float h = max(smoothing - abs(-s2.d - s1.d), 0.0);\n    return SDFSample(max(s1.d, -s2.d) + h * h  *0.25 / smoothing, s1.pW, s1.pO, s1.m, s1.f);\n}\n\nSDFSample Intersection(SDFSample s1, SDFSample s2)\n{\n    return SDFSample(s1.d > s2.d ? s1.d : s2.d, s1.pW, s1.pO, s1.m, s1.f);\n}\n\nSDFSample SmoothIntersection(SDFSample s1, SDFSample s2, float smoothing)\n{\n    float h = clamp(0.5 - 0.5 * (s2.d - s1.d) / smoothing, 0.0, 1.0);\n    float dMix = mix(s2.d, s1.d, h) + smoothing * h * (1.0 - h);\n    return SDFSample(dMix, s1.pW, s1.pO, s1.m, s1.f);\n}\n\n// DISTORTIONS\nvec3 Twist(vec3 p, float twist)\n{\n    float c = cos(twist * p.y);\n    float s = sin(twist * p.y);\n    mat2  m = mat2(c, -s ,s, c);\n    vec2 pT = m*p.xz;\n    vec3  q = vec3(pT.x, p.y, pT.y);\n    return q;\n}\n\nvec3 Bend(vec3 p, float bend)\n{\n    float c = cos(bend * p.x);\n    float s = sin(bend * p.x);\n    mat2  m = mat2(c, -s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec4 Elongate(vec3 p, vec3 h)\n{   \n    // Usage: dist = min(dist, w.w+DistFunc(w.xyz, ... ) );\n    // Where w is the output of this function\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat Layer(float d, float h)\n{\n    return abs(d) - h;\n}\n\n// Slicing\nfloat SliceXZ(vec3 p, float d)\n{\n    return max(abs(p.y), d);\n}\n\nfloat SliceXY(vec3 p, float d)\n{\n    return max(abs(p.z), d);\n}\n\nfloat SliceYZ(vec3 p, float d)\n{\n    return max(abs(p.x), d);\n}\n\n// Repetitions\nvec3 RepeatRange(in vec3 p, in vec3 c, in vec3 l)\n{\n    p -= c * 0.5 * (1.0 - mod(l, 2.0));\n    return p - c * (clamp(round(p / c), ceil(-l * 0.5), ceil(l * 0.5) - vec3(1.0)));\n}\n\nvec3 RepeatInfinite(in vec3 p, in vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat Extrusion(vec3 p, float d, float h)\n{\n    vec2 w = vec2(d, abs(p.y) - h * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 2D PRIMITIVES\nvec2 Circle(vec3 p, float r)\n{\n    return vec2(length(vec2(p.x, p.z)) - r, 0.0);\n}\n\nfloat Star5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// 3D PRIMITIVES - Mostly adapted from https://iquilezles.org/articles/distfunctions\nSDFSample SquareColumn(vec3 p, vec2 d)\n{\n    vec3 pO = abs(p);\n    return SDFSample(max(pO.x - d.x / 2.0, pO.z - d.y / 2.0), p, pO, 0, 1.0);\n}\n\nSDFSample Sphere(vec3 p, float r)\n{\n\treturn SDFSample(length(p) - r, p, p, 0, 1.0);\n}\n\nSDFSample Box(vec3 p, vec3 dimensions)\n{\n    vec3 pO = abs(p);\n\treturn SDFSample(length(max(abs(pO) - (0.5 * dimensions), 0.0)), p, pO, 0, 1.0);\n}\n\nSDFSample Disk(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, p, 0, 1.0);\n}\n\nSDFSample Capsule(vec3 p, float h, float r)\n{\n\tvec3 a = vec3(0.0, h * 0.5, 0.0);\n\tvec3 b = vec3(0.0, -h * 0.5, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n    \n\treturn SDFSample(length(p - c) - r, p, p, 0, 1.0);\n}\n\nSDFSample Cylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);\n    return SDFSample(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), p, p, 0, 1.0);\n}\n\nSDFSample Tube(vec3 p, float h, float r, float t)\n{\n    float dHoop = abs(Circle(p, r).x) - t;\n    return SDFSample(Extrusion(p, dHoop, h), p, p, 0, 1.0);\n}\n\nSDFSample Torus(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, p, 0, 1.0);\n}\n\nSDFSample Hoop(vec3 p, float h, float rO, float rI)\n{\n    SDFSample c1 = Cylinder(p, h, rO);\n    SDFSample c2 = Capsule(p, h, rI);\n\treturn Difference(c1, c2, 0.0);\n}\n\nSDFSample Gyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    vec3 pO = p * repetition;\n    float avgRepetition = AvgComponentLength(repetition);\n    return SDFSample(abs(dot(sin(pO * bias.x), cos(pO.zxy * bias.y))) / avgRepetition - width, p, pO, 0, 1.0);\n}\n\nSDFSample BoxFrame(vec3 p, vec3 b, float e)\n{\n    vec3 pO = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n    float minimum = min(min(\n        length(max(vec3(pO.x,q.y,q.z),0.0))+min(max(pO.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,pO.y,q.z),0.0))+min(max(q.x,max(pO.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,pO.z),0.0))+min(max(q.x,max(q.y,pO.z)),0.0));\n      \n    return SDFSample(minimum, p, pO, 0, 1.0);\n}\n\nSDFSample Plane(vec3 p)\n{\n    vec3 pO = AbsY(p);\n    return SDFSample(pO.y, p, pO, 0, 1.0);\n}\n\nSDFSample InfiniteCone(vec3 p, float angle)\n{\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec2 q = vec2(length(p.xz), -p.y);\n    float d = length(q - c * max(dot(q, c), 0.0));\n    return SDFSample(d * ((q.x * c.y - q.y * c.x < 0.0) ? -1.0 : 1.0), p, p, 0, 1.0);\n}\n\nSDFSample CappedCone(vec3 p, float h, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return SDFSample(s * sqrt(min(dot(ca, ca), dot(cb, cb)) ), p, p, 0, 1.0);\n}\n\n// NOISE\nfloat N21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat N31(vec3 p)\n{\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 154.7569))) * 43758.5453);\n}\n\nvec3 N33(vec3 p)\n{\n    vec4 a = fract(p.xyzx * vec4(1278.67, 3134.61, 298.647, 134.489));\n    a += dot(a, a + 318.978);\n    return fract(vec3(a.x * a.y, a.y * a.z, a.z * a.w)) * 0.5;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////\n// INPUT SHADER //\n//////////////////\n\n// CAMERA PARAMETERS\n#define INIT_CAM_POS vec3(-1.0, 2.5, -3.0)\n#define INIT_CAM_YAW -0.35\n#define INIT_CAM_PITCH -0.45\n#define INIT_CAM_ROLL 0.0\n#define ROTATION_SPEED 8.0\n#define BASE_MOVE_SPEED 2.0\n#define MOVE_ACCELERATION 1.01\n\n// UPDATE AND RECORD INPUT\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if (int(fragCoord.y) == 0 )\n    {\n        if (int(fragCoord.x) <= 1)\n        {\n            // CAMERA CONTROLS\n            vec4 camPos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy, -100.0);\n            vec4 camRot = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0).xy;\n            \n            float yawAngle = camRot.x - ROTATION_SPEED * mousePosData.x / iResolution.x;\n            float pitchAngle = clamp(camRot.y + ROTATION_SPEED * mousePosData.y / iResolution.y, -PI / 2.0, PI / 2.0);\n            float rollAngle = camRot.z;\n\n            //if (ReadKey(iChannel1, KEY_Q, false))\n            //{\n            //    rollAngle -= ROTATION_SPEED * iTimeDelta;\n            //}\n\n            //if (ReadKey(iChannel1, KEY_E, false))\n            //{\n            //    rollAngle += ROTATION_SPEED * iTimeDelta;\n            //}\n            \n            if (camRot.w == 0.0 || ReadKey(iChannel1, KEY_F, false))\n            {\n                yawAngle = INIT_CAM_YAW;\n                pitchAngle = INIT_CAM_PITCH;\n                rollAngle = INIT_CAM_ROLL;\n            }\n            \n            if (int(fragCoord.x) == 0)\n            {\n                // CAMERA POSITION\n                vec3 moveDir = vec3(0.0);\n                \n                mat3x3 yawMat = Rotate3(yawAngle, UP);\n                mat3x3 pitchMat = Rotate3(pitchAngle, RIGHT);\n                mat3x3 rollMat = Rotate3(rollAngle, FORWARD);\n                mat3x3 rotMat = yawMat * pitchMat * rollMat;\n                \n                float moveSpeed = camPos.w;\n                \n                if (camRot.w == 0.0 || ReadKey(iChannel1, KEY_F, false))\n                {\n                    // SET INIT MOVE SPEED\n                    moveSpeed = BASE_MOVE_SPEED;\n                }\n                \n                // ACCELERATE/DECELERATE\n                if (ReadKey(iChannel1, KEY_UP, false))\n                {\n                    moveSpeed *= MOVE_ACCELERATION;\n                }\n                if (ReadKey(iChannel1, KEY_DOWN, false))\n                {\n                    moveSpeed /= MOVE_ACCELERATION;\n                }\n                \n                // MOVEMENT\n                if (ReadKey(iChannel1, KEY_W, false))\n                {\n                    moveDir += rotMat * FORWARD;\n                }\n                if (ReadKey(iChannel1, KEY_S, false))\n                {\n                    moveDir += rotMat * BACKWARD;;\n                }\n                if (ReadKey(iChannel1, KEY_A, false))\n                {\n                    moveDir += rotMat * LEFT;\n                }\n                if (ReadKey(iChannel1, KEY_D, false))\n                {\n                    moveDir += rotMat * RIGHT;\n                }\n                if (ReadKey(iChannel1, KEY_SPACE, false))\n                {\n                    moveDir += rotMat * UP;\n                }\n                if (ReadKey(iChannel1, KEY_SHIFT, false))\n                {\n                    moveDir += rotMat * DOWN;\n                }            \n\n                vec3 movement = vec3(0.0);\n                if (length(moveDir) > 0.0)\n                {\n                    movement = normalize(moveDir) * iTimeDelta * moveSpeed;\n                }\n\n                if (camRot.w == 0.0 || ReadKey(iChannel1, KEY_F, false))\n                {\n                    // ADD INIT POSITION\n                    camPos.xyz = INIT_CAM_POS;\n                    movement = vec3(0.0);\n                }\n                \n                fragColor = vec4(camPos.xyz + movement, moveSpeed);\n            }\n            else\n            {                \n                // CAMERA ROTATION\n                fragColor = vec4(yawAngle, pitchAngle, rollAngle, 1.0); // w value 1.0 means no longer first frame\n            }\n        }\n        else if (int(fragCoord.x) == 2)\n        {\n            // MOUSE CLICK\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);            \n            fragColor = vec4(iMouse.z, mouseClickData.x, IsNewClick(mouseClickData.xy) || IsPersistentClick(mouseClickData.xy) ? iMouse.xy : vec2(0.0));\n        }\n        else if (int(fragCoord.x) == 3)\n        {\n            // MOUSE MOVEMENT\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);\n            vec4 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mouseDelta = IsPersistentClick(mouseClickData.zw) ? iMouse.xy - mouseClickData.zw : vec2(0.0);\n            vec2 mouseCumulative = mousePosData.zw + mouseDelta;\n            fragColor = vec4(mouseDelta, mouseCumulative);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Pack textures into atlas\n// 2 3\n// 0 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= 2.0;\n    \n    if (uv.x > 1.0)\n    {\n        if (uv.y >= 1.0)\n        {\n            fragColor = texture(iChannel3, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel1, uv);\n        }\n    }\n    else\n    {\n        if (uv.y >= 1.0)\n        {\n            \n            fragColor = texture(iChannel2, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, uv);\n        } \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Pack textures into atlas\n// 2 3\n// 0 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= 2.0;\n    \n    if (uv.x > 1.0)\n    {\n        if (uv.y >= 1.0)\n        {\n            fragColor = texture(iChannel3, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel1, uv);\n        }\n    }\n    else\n    {\n        if (uv.y >= 1.0)\n        {\n            \n            fragColor = texture(iChannel2, uv);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, uv);\n        } \n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}