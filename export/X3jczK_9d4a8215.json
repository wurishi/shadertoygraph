{"ver":"0.1","info":{"id":"X3jczK","date":"1727449002","viewed":28,"name":"capodimonte","username":"natepiano","description":"the tile from our hotel room in the Grand Hotel Capodimonte - spiced up a bit","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float groutWidth = 0.01;\nfloat center = 0.5;\nfloat initialTiles = 1.;\nfloat maxTiles = 6.;\nfloat densityStart = 30.;\nfloat densityDuration = 10.;\n\nvec3 bgColor = vec3(0.0, 0.0, 0.5);\nvec3 white = vec3(1.0);\nvec3 groutColor = vec3(0.3);\n\nfloat fadeInDuration = 5.0;\nfloat startGrout = 0.;\nfloat startWhite = 10.;\nfloat startBg = 20.;\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float width) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float l = length(ba);\n    vec2 dir = ba / l;\n    \n    // Project pa onto dir to get distance along line\n    float t = dot(pa, dir);\n    \n    // Check if we're between start and end of segment\n    if (t < 0.0 || t > l) return 0.0;\n    \n    // Calculate perpendicular distance from point to line\n    vec2 n = vec2(-dir.y, dir.x); // Normal to line\n    float d = abs(dot(pa, n)); // Distance to line\n    \n    // Check if we're within the line width\n    return step(d, width / 2.0);\n}\n\nfloat capodimonteTile(in vec2 uv) {\n\n    // there is symetry around the y-axis\n    vec2 tile = vec2(abs(uv.x), uv.y);\n    \n    // although there are more symmetries, I don't yet know how to exploit them\n    float top = center - groutWidth;\n    float unit = top * 2. / 12.;\n    float halfUnit = unit / 2.;\n    \n    // draw the tile manually       \n    float a1 = lineSegment(tile, vec2(halfUnit, -top + unit), vec2(unit * 3.5, -top + unit), unit);\n    float a2 = lineSegment(tile, vec2(unit, -top + unit), vec2(unit, -top + unit * 7.5), unit);\n    float a3 = lineSegment(tile, vec2(halfUnit, -top + unit * 7.0), vec2(unit * 3.5, -top + unit * 7.0), unit);\n    \n    float b1 = lineSegment(tile, vec2(halfUnit, -top + unit * 9.), vec2(unit * 3.5, -top + unit * 9.), unit);\n    float b2 = lineSegment(tile, vec2(unit, top - unit*3.5), vec2(unit, top), unit);\n    \n    float c1 = lineSegment(tile, vec2(unit * 5., -top), vec2(unit * 5., -top + halfUnit + unit * 3.), unit);\n    float c2 = lineSegment(tile, vec2(unit * 2.5,  -top + unit * 3.), vec2(unit * 5.5, -top + unit * 3.), unit);\n\n    \n    float d1 = lineSegment(tile, vec2(unit*2.5, -top + unit*5.0), vec2(unit * 5.5, -top + unit*5.0), unit);\n    float d2 = lineSegment(tile, vec2(unit * 5., -unit * 1.5), vec2(unit * 5., top - halfUnit), unit);\n    float d3 = lineSegment(tile, vec2(unit*2.5, top - unit), vec2(unit * 5.5, top - unit), unit);\n    \n    float d = max(max(max(max(max(max(a1, a2), a3), b1), b2), c1), c2);\n    d = max(max(max(d,d1),d2),d3);\n    \n    \n    return d;\n\n}\n\nvec2 flipAlternateRows(vec2 uv) {\n\n    // Get the Y integer coordinate (row number)\n    float rowNumber = floor(uv.y);\n    // Use mod to determine if the row number is even or odd\n    bool even = mod(rowNumber, 2.0) == 0.;\n    if (even) uv = vec2(uv.x, -uv.y);\n    return uv;\n    \n}\n\nfloat interpolateAfter(float startTime, float duration) {\n    // ensures that it's 0 until we reach start time and then creates values from 0 to 1\n    return clamp((iTime - startTime) / duration, 0.0, 1.0);\n}\n\nvec2 prepUV(vec2 uv) {\n\n    \n    float scaleFactor = interpolateAfter(densityStart, densityDuration);\n\n    // number of tiles\n    uv *= mix(initialTiles, maxTiles, scaleFactor);\n    // the pattern requires every other row to be flipped\n    uv = flipAlternateRows(uv);\n    \n    // fractionalize for the number of tiles we want\n    uv = fract(uv) - center;\n    \n    return uv;\n    \n}\n\n\n// Helper function for smooth transition\nvec3 fadeIn(vec3 fromColor, vec3 toColor, float startTime, float duration) {\n    float t = interpolateAfter(startTime, duration);\n    \n    // the smoothstep will cause mix to interpolate fromColor to toColor over the duration\n    return mix(fromColor, toColor, smoothstep(0.0, 1.0, t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - center * iResolution.xy)/iResolution.y;\n    \n    vec3 replaceGrout = hypnotic(uv, (iTime - startGrout) * 1.5);\n    vec3 replaceBg = hypnotic(uv, (iTime - startBg));\n    vec3 replaceWhite = hypnotic(uv, (iTime - startWhite) / 2.);\n\n\n    uv = prepUV(uv);\n        \n    \n    // init color with background\n    vec3 col = bgColor;\n   \n    float pattern = capodimonteTile(uv);\n    col = mix(col, vec3(1.0), pattern);\n    \n    // border on all sides for the grout\n    vec2 borderUV = abs(uv);\n    if (max(borderUV.x, borderUV.y) > center - groutWidth) col = groutColor;\n    \n    // Apply smooth color transitions\n    if (col == white) col = fadeIn(white, replaceWhite, startWhite, fadeInDuration);\n    if (col == bgColor) col = fadeIn(bgColor, replaceBg, startBg, fadeInDuration);\n    if (col == groutColor) col = fadeIn(groutColor, replaceGrout, startGrout, fadeInDuration);\n \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// New function for the additional pattern\n\nvec3 palette( float t) {\n  vec3 a = vec3(0.5, 0.5, 0.5);\n  vec3 b = vec3(0.5, 0.5, 0.5);\n  vec3 c = vec3(1.0, 1.0, 1.0);\n  vec3 d = vec3(0.263, 0.416, 0.557);\n  return a + b*cos( 6.28318 * (c*t +d) );\n}\n\nfloat oscillate(float time, float minValue, float maxValue, float frequency) {\n    // Calculate the range of our oscillation\n    float range = maxValue - minValue;\n    \n    // Use sine function, phase-shifted to start at the lowest point\n    float normalized = 0.5 + 0.5 * sin(time * frequency - 3.14159 * 0.5);\n    \n    // Scale to our desired range and shift to our minimum value\n    return minValue + normalized * range;\n}\n\nvec3 hypnotic(in vec2 uv, float iTime) {\n// original coordinates before we fract them below\n  vec2 uv0 = uv;\n  \n  vec3 finalColor = vec3(0.0);\n  \n  float offset = 1000.;\n  \n  for (float i = 0.0; i < 4.0; i++) {\n  \n\n      // once again center each fraction at it's own local 0.0\n      //uv = fract(uv * iTime * 0.01 ) - 0.5;\n      \n      // control frequency of complexity change\n      float compfreq = oscillate(iTime, .05, 0.5, .01);\n\n      // from simple to complex over time driven by compfreq\n      float complexity = oscillate(iTime, 0.00001, 2., compfreq);\n   \n      uv = fract(uv * complexity ) - 0.5;\n      \n      // local distance within each fract\n      // float d = length(uv);\n      // this time add the exponential function of the length of the global distance\n      float d = length(uv) + exp(-length(uv0));\n      \n\n      // uv0 gets the original coordinates rather than the fractional ones\n      // using its length here allows different color schemes in each fract  \n      vec3 col = palette(length(uv0) + i *.1 + iTime*.1);\n\n      // sdf - signed distance function - takes a position as space as input and\n      // returns distance from that position to a given shape\n      // signed because outside it's positive and inside it's negative\n      d = sin(d * 8. + iTime) / 8.;\n      d = abs(d);\n\n      // d = smoothstep(0.0,0.1, d);\n\n      // inverse makes it glow some - oscillate how much it glows\n      float glowify = oscillate(iTime, 0.5, 3.5, 1.);\n      // d = 0.01/d;\n      d = pow(0.01 / d, glowify);\n  \n      finalColor += col * d;\n      \n  }\n  \n  return finalColor;\n\n}\n\n","name":"Common","description":"","type":"common"}]}