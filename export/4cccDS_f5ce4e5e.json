{"ver":"0.1","info":{"id":"4cccDS","date":"1731081497","viewed":43,"name":"doom like render","username":"coco1001coco","description":"a simple raycast","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"XfcczX","parentname":"simple raycast in 2d"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLOCK_SIZE 12\n#define PI 3.14\n\nconst int thick = 1;\n\nint level[] = int[](\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0\n);\n\nivec2 level_size = ivec2(13,10);\n\nvec2 pos;\n\nvec2 start_pos;\n\nfloat cul_time = 0.0;\n\nvoid move_to(float current_time, float time, vec2 pos_end) {\n    if (cul_time > current_time) {\n        return;\n    } else if (cul_time+time < current_time) {\n        pos = pos_end;\n        start_pos = pos_end;\n        cul_time += time;\n        return;\n    }\n    \n    float tDelta = current_time - cul_time;\n    \n    pos = start_pos*((time - tDelta)/time)  + pos_end*((tDelta)/time);\n    \n    start_pos = pos_end;\n    cul_time += time;\n}\n\nbool is_out_level(ivec2 pos) {\n    return pos.x < 0 || pos.y < 0 || pos.x >= level_size.x || pos.y >= level_size.y;\n}\n\nbool is_block(ivec2 pos) {\n    if (is_out_level(pos)) {\n        return false;\n    }\n    if (level[pos.x+(pos.y*level_size.x)]==1) {\n        return true;\n    }\n    return false;\n}\n\nbool tolerate(int x) {\n    return x%BLOCK_SIZE < thick || x%BLOCK_SIZE > BLOCK_SIZE - thick;\n}\n\nstruct Ray {\n    bool hit;\n    bool side;\n    float dist;\n};\n\nRay raycast(vec2 coef, vec2 original_pos, vec2 pos) {\n    coef = normalize(coef);\n    vec2 coef_direction = sign(coef);\n    \n    ivec2 ray = ivec2(original_pos/float(BLOCK_SIZE));\n    \n    vec2 tDelta = abs(vec2(length(coef)) / coef);\n    \n    vec2 map = original_pos/float(BLOCK_SIZE);\n    \n    vec2 sideDist;\n    if (coef_direction.x < 0.0){\n        sideDist.x = (map.x - float(ray.x)) * tDelta.x;\n    } else {\n        sideDist.x = (float(ray.x) + 1.0 - map.x) * tDelta.x;\n    }\n    \n    if (coef_direction.y < 0.0) {\n        sideDist.y = (map.y - float(ray.y)) * tDelta.y;\n    } else {\n        sideDist.y = (float(ray.y) + 1.0 - map.y) * tDelta.y;\n    }\n    \n    bool side = false;\n    while (!is_out_level(ray)) {\n        if (is_block(ray)) {\n            float perpWallDist;\n            if (side) {\n                perpWallDist = (sideDist.y - tDelta.y);\n            } else {\n                perpWallDist = (sideDist.x - tDelta.x);\n            }\n            return Ray(true, side, perpWallDist);\n        }\n        if (sideDist.x<sideDist.y) {\n            sideDist.x += tDelta.x;\n            ray.x += int(coef_direction.x);\n            side = false;\n        } else {\n            sideDist.y += tDelta.y;\n            ray.y += int(coef_direction.y);\n            side = true;\n        }\n    }\n    return Ray(false, false, 0.0);\n}\n\nbool raycast_dot(vec2 coef, vec2 original_pos, vec2 pos) {\n    coef = normalize(coef);\n    vec2 coef_direction = sign(coef);\n    \n    ivec2 ray = ivec2(original_pos/float(BLOCK_SIZE));\n    \n    vec2 tDelta = abs(vec2(length(coef)) / coef);\n    \n    vec2 map = original_pos/float(BLOCK_SIZE);\n    \n    vec2 sideDist;\n    if (coef_direction.x < 0.0){\n        sideDist.x = (map.x - float(ray.x)) * tDelta.x;\n    } else {\n        sideDist.x = (float(ray.x) + 1.0 - map.x) * tDelta.x;\n    }\n    \n    if (coef_direction.y < 0.0) {\n        sideDist.y = (map.y - float(ray.y)) * tDelta.y;\n    } else {\n        sideDist.y = (float(ray.y) + 1.0 - map.y) * tDelta.y;\n    }\n\n    while (!is_out_level(ray)) {\n        if (distance(vec2(ray*BLOCK_SIZE), pos) < 5.0) {\n            return true;\n        }\n        if (is_block(ray)) {\n            return false;\n        }\n        if (sideDist.x<sideDist.y) {\n            sideDist.x += tDelta.x;\n            ray.x += int(coef_direction.x);\n        } else {\n            sideDist.y += tDelta.y;\n            ray.y += int(coef_direction.y);\n        }\n    }\n    return false;\n}\n\nbool on_line(vec2 original_pos, vec2 pos) {\n    // vec2 original_pos = iResolution.xy/2.0;\n    // vec2 original_pos = vec2(0.0,0.0);\n    // vec2 coef = vec2(max(iMouse.x, original_pos.x)/min(iMouse.x, original_pos.x), max(iMouse.y, original_pos.y)/min(iMouse.y, original_pos.y));\n    \n    // original_pos = vec2(ivec2(original_pos/float(BLOCK_SIZE))*BLOCK_SIZE);\n    vec2 coef = normalize(iMouse.xy-original_pos);\n    coef *= 2.0;\n    vec2 i_pos = original_pos;\n    for (int i= 0; i<1000; i++) {\n        if (distance(i_pos, pos) < 3.0) {\n            return true;\n        }\n        if (is_block(ivec2(i_pos)/BLOCK_SIZE)) {\n            return false;\n        }\n        i_pos+= coef;\n        if (i_pos.x < 0.0 || i_pos.y < 0.0 || i_pos.x > iResolution.x || i_pos.y > iResolution.y) {\n            return false;\n        }\n    }\n    return false;\n}\n\nvec3 get_color_case(ivec2 pos) {\n    if (is_block(pos/BLOCK_SIZE)) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    return vec3(1.0, 1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    pos = vec2(ivec2(6,5)*BLOCK_SIZE);\n    start_pos = pos;\n    float current_time = iTime;\n    current_time = mod(current_time, 5.0 + 5.0 + 10.0 + 10.0 + 10.0);\n    move_to(current_time, 5.0, vec2(ivec2(10,3)*BLOCK_SIZE));\n    move_to(current_time, 5.0, vec2(ivec2(6,0)*BLOCK_SIZE));\n    move_to(current_time, 10.0, vec2(ivec2(0)*BLOCK_SIZE));\n    move_to(current_time, 10.0, vec2(ivec2(0,6)*BLOCK_SIZE));\n    move_to(current_time, 10.0, vec2(ivec2(6,5)*BLOCK_SIZE));\n    \n    vec2 p =normalize(iMouse.xy-pos);\n    float angle = -atan(p.x, p.y)+PI/2.0;\n    \n    vec3 col = vec3(1.0);\n    \n    float h = 500.0;\n    float pix = 500.0;\n    \n    if (fragCoord.x < 150.0 && fragCoord.y < 150.0) {\n    \n        col = get_color_case(ivec2(fragCoord));\n    \n        if (tolerate(ivec2(fragCoord).x) || tolerate(ivec2(fragCoord).y)) {\n            col = vec3(0.0, 0.0, 0.0);\n        }\n    \n        if (raycast_dot(vec2(cos(angle),sin(angle)),pos, fragCoord)) {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n    \n        if (on_line(pos, fragCoord)) {\n            col = vec3(0.0, 0.0, 1.0);;\n        }\n    } else {\n        float fov = 0.9;\n        float dir = angle+(uv.x*fov)-fov/2.0;\n        Ray r = raycast(vec2(cos(dir),sin(dir)), pos, fragCoord);\n        if (r.hit) {\n            float lineHeight = h / r.dist;\n            if ((uv.y * pix) > (-lineHeight / 2.0 + h / 2.0) && (uv.y * pix) < (lineHeight / 2.0 + h / 2.0)) {\n                if (r.side) {\n                    col = vec3(0.0,1.0,0.0);\n                } else {\n                    col = vec3(0.0,0.0,1.0);\n                }\n            }\n        }\n        \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}