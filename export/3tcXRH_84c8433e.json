{"ver":"0.1","info":{"id":"3tcXRH","date":"1580346267","viewed":94,"name":"RayMarchSpheres","username":"JackSolace","description":"Simple Sphere marched Spheres. Based on blog post by Michael Walczyk linked below. Highly recommended read.\n\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray","distancefunction","sphere","diffuse","march","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Jan 2020\n//Basic Raymarch of two spheres\n//Based on the blog post by Michael Walczyk http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\n\n//Simplest light source\nstruct PointLight {\n    vec3 position;\n    vec4 color;\n};\n\n\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\nfloat map_the_world(in vec3 p)\n{\n    float sphere_0 = distance_from_sphere(p, vec3(-2.0,0.0,0.0), 1.0);\n    float sphere_1 = distance_from_sphere(p, vec3(2.0,1.0,0.0), 2.0);\n\n    \n    return min(sphere_0,sphere_1);\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ) );  \n}\n\n\n//Get the Diffuse color (Basic light effect)\nvec4 calculateDiffuse(in vec3 normal, in vec3 toLight, in PointLight light) {\n    return light.color * max(0.0,dot(normal,toLight));\n}\n\n//Main Loop\nvec4 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 32; //set bounds on runtime\n    const float MINIMUM_HIT_DISTANCE = 0.001; // front culling\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0; //back culling\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        //March one step\n        vec3 current_position = ro + total_distance_traveled * rd;\n\n        //Get distance to nearest surface\n        float distance_to_closest = map_the_world(current_position);\n\n        //Check if we are on/in a surface\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {//if we are calculate the color of the surface\n            //get normal\n            vec3 normal = calculate_normal(current_position);\n            //set the light\n            PointLight light = PointLight(vec3(3.0,-2.0,0.0), vec4(1.0,0.0,0.0,1.0));\n            vec3 direction_to_light = normalize(current_position - light.position);\n\t\t\t//calculate diffuse\n            return calculateDiffuse(normal, direction_to_light, light);\n        }\n\t\t\n        //exit condition\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec4(0.5,0.5,0.5,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv.x *= (iResolution.x/iResolution.y);\n\n    vec3 camera_position = vec3(0.0, 0.0, -5.0);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv.x,uv.y, 1.0);\n\n    fragColor = ray_march(ro, rd);\n}","name":"Image","description":"","type":"image"}]}