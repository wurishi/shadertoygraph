{"ver":"0.1","info":{"id":"4cdBWB","date":"1733535014","viewed":122,"name":"Rainbow lightcone","username":"Txoka","description":"Based on https://www.youtube.com/watch?v=24GfgNtnjXc","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float pos = length(uv);\n    \n    vec4 col = texture(iChannel0, vec2(pos, 0.0));\n    \n    float bayerVal = texture(iChannel1, fragCoord.xy/iChannelResolution[1].xy).r;\n\n    float dither = ( bayerVal - 0.5) / 255.;\n    \n    col.rgb += dither;\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float refractiveIndexOfWater(float lambda) {\n    float l2 = lambda*lambda;\n    float l4 = l2*l2;\n    return 1.333 + 0.002/l2 + 0.0005/l4;\n}\n\nfloat alpha_of_h(float h, float n) {\n    return -2.0*asin(h) + 4.0*asin(h/n);\n}\n\nfloat dalpha_dh(float h, float n) {\n    float denom1 = sqrt(1.0 - h*h);\n    float denom2 = sqrt(1.0 - (h*h/(n*n)));\n    return -2.0/denom1 + 4.0/(n*denom2);\n}\n\nfloat fresnelReflection(float n1, float n2, float theta_i) {\n    float sint_t = (n1/n2)*sin(theta_i);\n    if(abs(sint_t) > 1.0) return 1.0; // Total Internal Reflection\n    \n    float theta_t = asin(sint_t);\n    float cos_i = cos(theta_i);\n    float cos_t = cos(theta_t);\n    float Rs = ((n1*cos_i - n2*cos_t)/(n1*cos_i + n2*cos_t));\n    Rs = Rs*Rs;\n    float Rp = ((n2*cos_i - n1*cos_t)/(n2*cos_i + n1*cos_t));\n    Rp = Rp*Rp;\n    return 0.5*(Rs+Rp);\n}\n\n// Newton's method solver for α(h)=α\n// h_range: [low, high] to search\nfloat solve_for_h(float alpha, float n, float h_guess, float low, float high) {\n    float h = h_guess;\n    for(int i=0; i<32; i++){\n        float f = alpha_of_h(h,n) - alpha;\n        float df = dalpha_dh(h,n);\n        float h_new = h - f/df;\n        // Clamp to range just in case\n        h_new = clamp(h_new, low, high);\n        if(abs(h_new - h) < 1e-6) {\n            h = h_new;\n            break;\n        }\n        h = h_new;\n    }\n    // Check if the solution is valid (alpha_of_h close to alpha)\n    float check = alpha_of_h(h, n);\n    if(abs(check - alpha) < 1e-4) {\n        return h;\n    }\n    return 9999.0; // Invalid solution indicator\n}\n\n// Shamelesly stolen from https://www.shadertoy.com/view/stSXzm\nfloat xFit_1931(float lambda_nano)\n{\n    float t1 = (lambda_nano-442.0)*((lambda_nano<442.0)?0.0624:0.0374),\n          t2 = (lambda_nano-599.8)*((lambda_nano<599.8)?0.0264:0.0323),\n          t3 = (lambda_nano-501.1)*((lambda_nano<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931(float lambda_nano)\n{\n    float t1 = (lambda_nano-568.8)*((lambda_nano<568.8)?0.0213:0.0247),\n          t2 = (lambda_nano-530.9)*((lambda_nano<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931(float lambda_nano)\n{\n    float t1 = (lambda_nano-437.0)*((lambda_nano<437.0)?0.0845:0.0278),\n          t2 = (lambda_nano-459.0)*((lambda_nano<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\nvec3 xyzFit_1931(float lambda_nano) {\n    return vec3( xFit_1931(lambda_nano), yFit_1931(lambda_nano), zFit_1931(lambda_nano) );\n}\n\nvec3 wl2rgb2(float lambda)\n{\n    vec3 XYZ = xyzFit_1931(lambda);\n\tvec3 RGB = XYZ * mat3( 3.240479, -1.537150, -0.498535,\n                          -0.969256 , 1.875991,  0.041556,\n                           0.055648, -0.204043,  1.057311);\n    return RGB;\n}\n// End of shameless steal\n\nvec3 wl2rgb1(float w, float gamma) {\n    vec3 c = vec3(0);\n    if (w >= 380. && w < 440.) {\n        c.r = (440. - w) / 60.;\n        c.b = 1.;\n    } else if (w >= 440. && w < 490.) {\n        c.g = (w - 440.) / 50.;\n        c.b = 1.;\n    } else if (w >= 490. && w < 510.) {\n        c.g = 1.;\n        c.b = (510. - w) / 20.;\n    } else if (w >= 510. && w < 580.) {\n        c.r = (w - 510.) / 70.;\n        c.g = 1.;\n    } else if (w >= 580. && w < 645.) {\n        c.r = 1.;\n        c.g = (645. - w) / 65.;\n    } else if (w >= 645. && w < 781.) {\n        c.r = 1.;\n    }\n\n    float factor = 0.;\n    if (w >= 380. && w < 420.) factor = 0.3 + 0.0175 * (w - 380.);\n    else if (w >= 420. && w < 701.) factor = 1.;\n    else if (w >= 701. && w < 781.) factor = 0.3 + 0.00875 * (780. - w);\n\n    // Apply gamma correction\n    if (c.r > 0.) c.r = pow(c.r * factor, gamma);\n    if (c.g > 0.) c.g = pow(c.g * factor, gamma);\n    if (c.b > 0.) c.b = pow(c.b * factor, gamma);\n\n    // Normalize to ensure white light integration\n    vec3 whiteBalance = vec3(0.438, 0.676, 0.939); // Normalization factors for R, G, B\n    c *= whiteBalance;\n\n    return c;\n}\n\n// Try to find up to two solutions for given alpha\nvoid find_h_solutions(float alpha, float n, out float h1, out float h2) {\n    h1 = 9999.0;\n    h2 = 9999.0;\n    // try positive range\n    float hp = solve_for_h(alpha, n, 0.93, 0.86, 0.9999);\n    if(hp != 9999.0) h1 = hp;\n\n    // try negative range\n    float hn = solve_for_h(alpha, n, 0.43, 0., 0.86);\n    if(hn != 9999.0) {\n        if(h1 == 9999.0) {\n            h1 = hn;\n        } else {\n            h2 = hn;\n        }\n    }\n}\n\nfloat intensityFromH(float h, float n) {\n    float i = asin(h);\n    float r = asin(h/n);\n\n    // Fresnel at entry (air->water)\n    float R_in = fresnelReflection(1.0, n, i);\n    float T_in = 1.0 - R_in;\n\n    // Internal reflection (water->air)\n    float R_int = fresnelReflection(n, 1.0, r);\n\n    // Exit interface (water->air)\n    float R_out = fresnelReflection(n, 1.0, r);\n    float T_out = 1.0 - R_out;\n\n    float d_alpha_d_h_val = dalpha_dh(h, n);\n    float d_h_d_alpha = 1.0 / (abs(d_alpha_d_h_val) + 1e-3);\n\n    float I_alpha = T_in * R_int * T_out * d_h_d_alpha;\n    return I_alpha;\n}\n\nfloat intensityAtAngle(float alpha, float lambda) {\n    float n = refractiveIndexOfWater(lambda);\n    float h1,h2;\n    find_h_solutions(alpha, n, h1, h2);\n\n    float I_total = 0.0;\n    if(h1 != 9999.0) I_total += intensityFromH(h1, n);\n    if(h2 != 9999.0) I_total += intensityFromH(h2, n);\n\n    return I_total;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Read the stored resolution from iChannel0 (we store it in texel [0, 0])\n    ivec2 texCoord = ivec2(0, 4);\n    vec4 prevResolutionData = texelFetch(iChannel0, texCoord, 0);\n    vec2 prevResolution = prevResolutionData.xy;\n\n    // Compare with the current resolution\n    bool resolutionChanged = any(notEqual(prevResolution, iResolution.xy));\n\n    // Normalize the X coordinate\n    float x = fragCoord.x / iResolution.x;\n\n    // Compute angle in radians\n    float angle = x * 41.5 * PI / 180.;\n\n    // Initialize the output color\n    fragColor = vec4(0.0);\n\n    if (iFrame == 0 || resolutionChanged) {\n        // Run computation on the first frame or when resolution changes\n        if(int(fragCoord.y) == 0){\n            int SAMPLE_COUNT = 8192*4;\n            float lambdaStart = 0.38;\n            float lambdaEnd = 0.740;\n            vec3 accumColor = vec3(0.0);\n\n            // Base uniform samples for wavelength\n            for (int i = 0; i < SAMPLE_COUNT; i++) {\n                float t = float(i) / float(SAMPLE_COUNT - 1);\n                float lambda = mix(lambdaStart, lambdaEnd, t);\n\n                float I = intensityAtAngle(angle, lambda);\n                \n                #if WavelengthToRGBMethod == 0\n                vec3 rgb = wl2rgb1(lambda * 1000.0, gamma);\n                #else\n                vec3 rgb = wl2rgb2(lambda * 1000.0);\n                #endif\n                accumColor += rgb * I;\n            }\n\n            float scale = 2.5 / float(SAMPLE_COUNT);\n            vec3 col = accumColor * scale;\n            col = pow(col, vec3(1.0 / gamma));\n\n            // Output the computed color\n            fragColor = vec4(col, 1.0);\n        }\n        // Store the current resolution in texel [0, 0] of iChannel0 for future frames\n        if (all(equal(texCoord,ivec2(fragCoord)))) {\n            fragColor = vec4(iResolution.xy, 0.0, 1.0);\n        }\n    } else {\n        // Reuse the previous result\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = atan(1.)*4.;\nconst float gamma = 2.;\n#define iR iResolution.xy\n\n\n// Wavelength To RGB method (0 / 1), pretty sure 1 is better\n#define WavelengthToRGBMethod 1","name":"Common","description":"","type":"common"}]}