{"ver":"0.1","info":{"id":"WdBfRc","date":"1590536493","viewed":114,"name":"Gradient Tester","username":"cheasify","description":"for testing gradient ideas. Like rgbBezier which works like a bezier curve but uses red blue and green instead of points in space. And genBezier which takes an arbitrary list of colors and gives a gradient between them.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//bezier curves use binomial theorem to make a parametric function that smoothly weights different points\n//Check this out if you want to learn more http://pomax.github.io/bezierinfo/#preface \n//or check out a desmos implementation of bezier curves I made https://www.desmos.com/calculator/rsn9uvfiqx\n\n\n#define COLORNUM 4\n#define PI 3.14159265358978\n\nvec3 rgbBezier(float x){//x 0 to 1\n    //bezier 1=((1-x)+x)^3=(1-x)^2+(1-x)x+x^2 use these values as weights for colors \n    float r=pow(1.0-x,2.0);\n    float g=pow(x,2.0);\n    float b=2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\n\nvec3 twoBezier(float x, vec3 color1,vec3 color2){\n\treturn (1.-x)*color1+x*color2;\n}\n\n\n//factorial \nint fact(int n){\n    int tot=1;\n    for(int i=2;i<=n;i++){\n    \ttot*=i;\n    }\n    return tot;\n}\n//slow but alternative is difficult given the limitations\nint binCoef(int n,int k){return fact(n)/(fact(k)*fact(n-k));}\n\n//you can change the rate that x changes while maintaining some of the nice properties\n//like constant brightness and smooth transitioning\n//need to keep output range the same or you will get weird stuff\n//this means f(0)=0 and f(1) need to map to same thing if you want to preserve order\nfloat f(float x){\n\treturn x; //no change\n    //return 4.0*x*(1.0-x);//1st is in middle and moves to other as it goes out from there\n    //return pow(sin(PI*x/2.0),2.0);//hmm smoother?\n    //return pow(sin(PI*x/2.0),1.0/4.0);//weighted to end\n    //return 2.0-2.0/(x+1.0);\n}\n\n\n\n\n//colors is an ordered list of colors that genBezier will smoothly move between\n//it will not go exactly through the color because that is not how bezier curves work except at end points\nvec3 genBezier(float x,vec3 colors[COLORNUM]){\n    x=f(x);\n\tfloat n=float(COLORNUM-1);\n\tvec3 total=vec3(0);//initialize color\n    for(int i=0;i<COLORNUM;i++){//go through colors\n        float k=float(i);\n        //binomial theorem\n    \ttotal+=colors[int(k)]*vec3(pow(1.0-x,n-k)*pow(x,k)*float(binCoef(COLORNUM-1,int(k))));\n    }\n    return total;\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos=fragCoord.xy/iResolution.xy;\n    \n    vec3 c0=vec3(66, 90, 245)/255.0;\t\n    vec3 c1=vec3(19, 194, 87)/255.0;\n    vec3 c2=vec3(122, 52, 235)/255.0;\n    vec3 c3=vec3(235, 52, 116)/255.0;\n    vec3 c4=vec3(235, 146, 52)/255.0;\n    \n    \n    //fragColor=vec4(rgbBezier(pos.x),1);\n    \n    //To make a gradient change the COLORNUM at top and put that many colors in the array below\n    //the array is ordered so when x=0 it will return the first color and when x=1 it will return the last\n    //want to add a sharpness parameter so you can get closer the actual colors in between\n    \n    \n    vec3[] colors= vec3[] (c0,c1,c2,c3); \n    fragColor=vec4(genBezier(pos.x,colors),1);\n    //fragColor=vec4(twoBezier(pos.x,c0,c1),1);\n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}