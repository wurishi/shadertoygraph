{"ver":"0.1","info":{"id":"sdfSW8","date":"1618539600","viewed":52,"name":"SH Rebuild Light Direction","username":"Yon","description":"SH Rebuild Light Direction","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//SH rebuild AHD\n\n//This Shader include:\n//1: Monte Carlo Sample caculate SH coefficient\n//2: Cacualte Main Direction from most of light \n//   from SH coefficient\n\n\n//https://www.ppsloan.org/publications/StupidSH36.pdf\n//http://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n#define PI 3.14159\n#define MAX 10000.\n#define BANDS 3\n#define COEFF 9\n\n#define sampleCount 64\n\n#define Radiance3 vec3\n#define Irradiance3 vec3\n#define Vector3 vec3\n#define Color3 vec3\n\nstruct SHSample { \n    vec3 sph; \n    vec3 vec; \n    float[9] coeff;\n}; \n\nstruct ray{\n    vec3 ori;\n    vec3 dir;\n};\n\nstruct Light {\n    vec3 dir;\n    vec3 radiance;\n};\n\nstruct Pixel{\n    float z;\n    vec3 color;\n};\n\n// SHSample samples[1024];\nfloat result[9];\nmat3 camMat;\n// The actual lights\nconst int NUM_LIGHTS = 2;\nLight lightArray[NUM_LIGHTS];\n\n\nfloat rnd(float seed) { return fract(sin(seed)*43758.5453123); }\nfloat lerp(float a,float b,float t){return (1.-t)*a + t*b;}\nvec3 lerp(vec3 a,vec3 b,float t){return (1.-t)*a + t*b;}\nfloat luminiance(vec3 c){return 0.2125*c.x+0.7154*c.y+0.0721*c.z;}\nvec3 SphereRand( uint seed )\n{\n    float a = (float((seed*0x73493U)&0xfffffU)/float(0x100000))*2. - 1.;\n    float b = 6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float cosa = sqrt(1.-a*a);\n    return vec3(cosa*cos(b),a,cosa*sin(b));\n}\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n\n\nvec3 envir(vec3 vec){\n    vec3 color = vec3(max(dot(lightArray[0].dir,vec),0.));\n    color += vec3(max(5.*dot(lightArray[1].dir,vec)-4.,0.));\n    return color;\n}\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \n// SH caculate from dir vector\nfloat SH( in int l, in int m, in vec3 s ) \n{ \n    vec3 n = s.zxy;\n    \n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n    if( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    //----------------------------------------------------------\n    if( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n\n    return 0.0;\n}\n\n/* In a real application, this step would be precomputed (per frame or per scene)\n   for each SH probe */\t\nvoid computeSHLightProbe() {\n    //Monte Carlo Sample\n    for(int i;i<=sampleCount;i++){\n\n            SHSample samples;\n            samples.vec = SphereRand(uint(i+int(iTime * 0.2)));\n\n            // precompute all SH coefficients for this sample \n            for(int l=0; l<BANDS; ++l) { \n                for(int m=-l; m<=l; ++m) { \n                    int index = l*(l+1)+m; \n                    samples.coeff[index] = SH(l,m,samples.vec); \n                    result[index] += luminiance(envir(samples.vec)) * samples.coeff[index]; \n                } \n            } \n    }\n    \n    const float weight = 4.0*PI; \n    float factor = weight / float(sampleCount); \n    for(int i=0; i<COEFF; ++i) { \n        result[i] = result[i] * factor; \n    } \n}\n\n//draw sphere,return hit pos\nfloat hit_sphere(vec3 center, float radius, ray r){\n    vec3 oc = r.ori - center;\n    float a = dot(r.dir,r.dir);\n    float b = 2.*dot(oc,r.dir);\n    float c = dot(oc,oc)- radius*radius;\n    float discriminant = b*b - 4.*a*c;\n    if (discriminant < 0.) {\n        return -1.0;\n        } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nvec3 draw(ray r){\n    float t;\n    Pixel pixel;\n    pixel.z = MAX;\n    vec3 cen_pos = vec3(3.,0.,0.);\n    vec3 cen_pos_02 = vec3(-3.,0.,0.);\n    vec3 cen_pos_03 = vec3(0.,0.,0.);\n\n\n    //draw sh simulated\n    t = hit_sphere(cen_pos_02,1.,r);\n    if(t<pixel.z){\n        if (t > 0.0 ) {\n            float color;\n            vec3 N = normalize (r.ori + r.dir*t - cen_pos_02);\n            for(int l=0; l<BANDS; ++l) { \n                for(int m=-l; m<=l; ++m) { \n                    int index = l*(l+1)+m; \n                    color += SH(l,m,N)*result[index];\n                }\n            } \n            pixel.color = vec3(color);\n            pixel.z = t;\n        }   \n    }\n\n    //draw the origin light \n    t = hit_sphere(cen_pos,1.,r);\n    if(t<pixel.z){\n        //模拟我们需要进行球谐模拟的环境球\n        if (t > 0.0) {\n            vec3 N = normalize (r.ori + r.dir*t - cen_pos);\n            pixel.color = envir(N);\n            pixel.z = t;\n        }   \n    }\n\n    //draw light dir rebuild\n    t = hit_sphere(cen_pos_03,1.,r);\n    if(t<pixel.z){\n        if (t > 0.0) {\n            vec3 N = normalize (r.ori + r.dir*t - cen_pos_03);\n            vec3 dir = normalize(vec3(-result[1],result[2],-result[3]));\n\n            pixel.color = vec3(max(5.*dot(dir,N)-4.,0.));\n            pixel.z = t;\n        }   \n    }\n\n    //BackGround\n    vec3 dir = normalize(r.dir);\n    t = MAX-1.;\n    float y = dir.y;\n    if(t<pixel.z){\n        if(y>0.){\n            pixel.color = lerp(vec3(1.,1.,1.),vec3(0.4,0.6,1.),y);\n            }else{\n            y = pow(-y,0.2);\n            pixel.color = lerp(vec3(1.,1.,1.),vec3(0.02,0.12,0.3),y);\n        }\n    }\n    return pixel.color;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    lightArray[0] = Light(normalize(vec3(cos(iTime * 0.2 + 2.0),1,0.1)), 1.0 * vec3(0.75,0.75,0.75));\n\tlightArray[1] = Light(normalize(vec3(1,cos(iTime),sin(iTime))), 1.2 * vec3(0.75,0.6,0));\n\n    computeSHLightProbe();\n\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n\n    // Mouse\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    // Camera position\n    float dist = 6.;\n    vec3 ro = vec3(dist * cos(iTime * 0.1 + 6.0 * mo.x), 2.0 + mo.y * 4.0, dist * sin(iTime * 0.1 + 6.0 * mo.x));\n    \n    // Rotate the camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    // Compute the ray\n    camMat = setCamera(ro, target, 0.0);\n    vec3 rd = camMat * normalize(vec3(p.xy, 1.5));\n    \n    ray r;\n    r.ori = ro;\n    r.dir = rd;\n    \n    vec3 color = draw(r);\n    color = pow(color,vec3(1.,1.1,1.));\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}