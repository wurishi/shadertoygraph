{"ver":"0.1","info":{"id":"7lK3RV","date":"1638028814","viewed":92,"name":"Timer / Loading progress circle ","username":"jaggotswag","description":"Do you ever see those circles that reveal themselves like a fan moving clockwise or counter-clockwise? I've successfully recreated this kind of effect. It's a simple shader. Hope you learn something new!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circle","progress","timer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// render a timer-like circle.\n\nfloat PI = 3.14;\n\nfloat dist(vec2 a, vec2 b){\n\treturn sqrt(\n\t\t\t(b.x-a.x) * (b.x-a.x) + \n\t\t\t(b.y-a.y) * (b.y-a.y)\n\t\t);\n}\n\nvec2 divide(vec2 a, vec2 b){\n    return vec2(a.x/b.x, a.y/b.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    // Modify these variables\n    vec2 center = vec2(0.5f, 0.5f);\n    float radius = 0.4f;\n    float maxSeconds = 5.0f;\n    bool circle = true; // should it be drawn as a circle or as a rectangle?\n    \n    //You probably shouldn't change these.\n    float seconds = iTime;\n    vec2 Tex = divide(fragCoord, iResolution.xy);\n    \n                                        //this comparison sign controls the direction, \n                                        //the negative sign controls whether it's increasing or decreasing\n\tif(-atan(center.x-Tex.x, center.y-Tex.y) > -( (seconds/maxSeconds) *2.0f*PI - PI) && (!circle || dist(Tex, center) <= radius)){\n\t\tfragColor = vec4(0.8f, 0.4f, 0.0f, 1.0f);\n\t}else{\n\t\tfragColor = vec4(0.0f); // empty, so you can draw objects behind it and they will show up as long as the circle isn't covering those objects.\n\t}\n}","name":"Image","description":"","type":"image"}]}