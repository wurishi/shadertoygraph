{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Well first I had an idea, but that didn't work out, so I ended up with some spheres.\n import some post processing, optimise, add some shades and voila.\n\n You can rotate the camera with the mouse.... there is some lens distorsion going on\n and truckloads of fake ambient occlusion...\n\n It should also run fast even on fulscreen.\n\n 10/06/2013:\n - published\n 14/06/2013:\n - saved one square root, thanks iq!\n - removed unused code\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nvec3 cc(vec3 color, float factor,float factor2) //a wierd color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.y = cosa*vo.y - sina*vo.z;\n\tv.z = sina*vo.y + cosa*vo.z;\n\treturn v;\n}\n\nfloat dist(vec3 p)\n{\n\tp.x+=iTime;\n\tvec3 p2 = p;\n\tp2.z+=iTime*.5;\n\tp.z-=iTime*.5;\n\t\n\t//p & mp first set of spheres\n\t//p2 & mp2 seconds set of spheres\n\t\n\tfloat e = 0.0;\n\tvec2 mp = mod(p.xz+vec2(2.0-e*.5,1.0),vec2(4.0-e,2.0))-vec2(2.0-e*.5,1.0);\n\tvec2 mp2 = mod(p2.xz+vec2(4.0-e*.5,2.0),vec2(4.0-e,2.0))-vec2(2.0-e*.5,1.0);\n\t//vec2 dp = p.xz-mp;\n\t\n\tp.xz = mp;\n\tp.y+=2.0;\n\t\n\tvec3 a = vec3(mp,p.y);\n\tvec3 b = vec3(mp2,p.y);\n\n\treturn sqrt(min(dot(a,a),dot(b,b)))-1.0;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 plane(vec3 p, vec3 d, float y) //returns the intersection with a predefined plane\n{\n\t//http://en.wikipedia.org/wiki/Line-plane_intersection\n\tvec3 n = vec3(.0,1.0,.0);\n\tvec3 p0 = -n*y;\n\tfloat f=dot(p0-p,n)/dot(n,d);\n \treturn p+d*f;\n}\n\nvec3 light; //global variable that holds light direction\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\t//lights\n\t\n\tlight = normalize(vec3(.1,1.0,-0.1));\n\t\n\t//camera\n\t\n\tvec3 p = vec3(.0,2.0,-4.0);\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.5;\n\td = normalize(d);\n\td = rotate_x(d,sin(iTime*.3)*.01+2.4-mouse.y*7.0);\n\td = rotate_y(d,sin(iTime*.7)*.01+1.0-mouse.x*7.0);\n\t\n\tp=plane(p,d,1.0); //optimisation there is only geometry below y=1.0;\n\t\n\t//background...\n\t\n\tvec3 sky = texture(iChannel0,d).xyz;\n\t\n\t//floor needs some shading first...\n\t\n\tvec3 p2 = plane(p,d,3.0);\n\tfloat shadow = dist(p2);\n\tshadow = min(1.0,shadow);\n\tif (d.y<.0)\n\tsky*=mix(1.0,shadow,1.0/(length(p2)*.01+1.0));\n\tvec3 color = sky;\n\t\n\t//and action!\n\t\n\tif (d.y<0.0) //optimisation there is no geometry below camera\n\tfor (int i=0; i<30; i++) //30 step raymarch\n\t{\n\t\tfloat dd = dist(p);\n\t\tp+=d*dd;\n\t\t\n\t\tif (abs(p.y+1.0)>2.0) //optimisation, only trace the necesarry area.\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (dd<.03)\n\t\t{\n\t\t\tcolor = vec3(1.0,.2,.2);\n\t\t\tvec3 n = normal(p,.01);\n\t\t\tvec3 r = reflect(d,n);\n\t\t\tfloat occlusiond = dist(p+n)*.5+.5;\n\t\t\tfloat occlusions = dist(p+r)*.5+.5;\n\t\t\tfloat fresnel = pow(dot(d,r)*.5+.5,2.0);\n\n\t\t\tcolor *= dot(n,light)*.5+.5*occlusiond;\n\t\t\tcolor += texture(iChannel1,r).xyz*fresnel*occlusions;\n\t\t\tcolor = mix (sky,color,1.0/(pow(length(p),2.0)*.00001+1.0));\n\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//post\n\t\n\tcolor -= hash(color.xy+uv.xy)*.02;\n\tcolor *= vec3(.4,.5,.8)*2.0;\n\tcolor -= length(uv)*.15;\n\tcolor =cc(color,.4,.5);\n\t\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4slGDN","date":"1370891739","viewed":1317,"name":"Red Sphere Invasion","username":"mu6k","description":" You can rotate the camera with the mouse.... there is some lens distorsion going on\n and truckloads of fake ambient occlusion...","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lens","sphere"],"hasliked":0,"parentid":"","parentname":""}}