{"ver":"0.1","info":{"id":"432BzD","date":"1729330109","viewed":48,"name":"Basic ray marcher azerty","username":"silly_goose","description":"boop","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 roundMerge(vec4 item1, vec4 item2, float radius) {\n    vec2 intersection = vec2(item1.w - radius, item2.w - radius);\n    intersection = min(intersection, 0.0);\n    float insideDistance = -length(intersection);\n    float simpleUnion = min(item1.w, item2.w);\n    float outsideDistance = max(simpleUnion, radius);\n    vec3 intersectionColor = mix(item1.xyz, item2.xyz, item1.w - item2.w + 0.5);\n    vec3 outputColor = item1.w < item2.w ? item1.xyz : item2.xyz;\n    \n    if (outsideDistance > item1.w && outsideDistance > item2.w) {\n        outputColor = intersectionColor;\n    }\n    \n    return  vec4(outputColor, insideDistance + outsideDistance);\n}\n\n//vec4 sdfSmoothUnion(vec4[5] items, float radius) {\n    \n//}\n\nvec4 sdfIntersection(vec4[5] items) {\n    int farItemID = 0;\n    for (int i = 0; i < items.length(); i++) {\n        if (items[i].w > items[farItemID].w) {\n            farItemID = i;\n        }\n    }\n    return items[farItemID];\n}\n\nvec4 sdfManyUnion(vec4[5] items) {\n    int closestItemID = 0;\n    for (int i = 0; i < items.length(); i++) {\n        if (items[i].w < items[closestItemID].w) {\n            closestItemID = i;\n        }\n    }\n    return items[closestItemID];\n}\n\nvec4 sdfUnion(vec4 item1, vec4 item2) {\n    vec4 item;\n    item = item1.w > item2.w ? item2 : item1;\n    return item;\n}\n\nvec3 repeat(vec3 p, float c) {\n    return mod(p,c)-0.5*c;\n}\n\nvec4 sphereSDF(vec3 color, vec3 p) {\n    return vec4(color, length(p) - 1.0);\n}\n\n\nvec4 sceneSDF(vec3 p) {\n    p = repeat(p + vec3(0.0, 0.0, 0.0), 12.0);\n    vec4 scene = vec4(0.0, 0.0, 0.0, 0.0);\n\n    \n    vec4[5] sceneItems;\n    \n    sceneItems[0] = sphereSDF(\n        // color\n        vec3(sin(iTime) + 1.0, cos(iTime) + 1.0, normalize(iTime) + 1.0), \n        // position\n        vec3(p.x + sin(iTime) * 3.5, p.y + cos(iTime) * 3.5, p.z));\n\n    sceneItems[1] = sphereSDF(\n        // color\n        vec3(sin(iTime * 1.1) + 1.0, cos(iTime * 1.2) + 1.0, normalize(iTime * 1.5) + 1.3), \n        // position\n        vec3(p.x + sin(iTime * 1.5) * 3.5, p.y + cos(iTime * 1.5) * 3.5, p.z));\n        \n    sceneItems[2] = sphereSDF(\n        // color\n        vec3(sin(iTime * 1.5) + 1.0, cos(iTime * 1.6) + 1.0, normalize(iTime * 1.5) + 1.7), \n        // position\n        vec3(p.x + sin(iTime * 2.0) * 3.5, p.y + cos(iTime * 2.0) * 3.5, p.z));\n\n    //scene = sdfIntersection(sceneItems);\n    \n    \n    scene = sdfUnion(sdfUnion(roundMerge(sceneItems[0], sceneItems[1], 0.5), roundMerge(sceneItems[1], sceneItems[2], 0.5)), sdfUnion(roundMerge(sceneItems[0], sceneItems[2], 0.5), roundMerge(sceneItems[1], sceneItems[2], 0.5)));\n    \n    \n    \n    return scene;\n}\n\n\n\nvec3 calculateNormal(vec3 rd) {\n    vec3 normal = normalize(vec3(sceneSDF(vec3(rd.x + 0.01, rd.yz)).w - sceneSDF(vec3(rd.x - 0.01, rd.yz)).w,\n                                 sceneSDF(vec3(rd.x, rd.y + 0.01, rd.z)).w - sceneSDF(vec3(rd.x, rd.y - 0.01, rd.z)).w,\n                                 sceneSDF(vec3(rd.xy, rd.z + 0.01)).w - sceneSDF(vec3(rd.xy, rd.z - 0.01)).w));\n    return normal;\n}\n\nvec3 calculateAmbient() {\n    vec3 ambientLight = vec3(0.3);\n    return ambientLight;\n}\n\nvec3 calculateDiffuse(vec3 ro, vec3 rd, vec3 currentPosition, vec3 normal, vec3[1] lightSources) {\n    vec3 relativeLightSourcePos = normalize(lightSources[0].xyz - currentPosition);\n    vec3 diffuse;\n    diffuse += max(0.0, dot(normal, relativeLightSourcePos));\n    return diffuse;\n}\n\nfloat calculateSpecular(vec3 ro, vec3 rd, vec3 currentPosition, vec3 normal, vec3[1] lightSources) {\n    vec3 relativeLightSourcePos = normalize(lightSources[0].xyz - currentPosition);\n    vec3 reflectDir = reflect(relativeLightSourcePos, normal);\n    float specular = pow(max(dot(rd, reflectDir), 0.0), 16.0);\n    return specular;\n}\n\nvec3 calculateLighting(vec3 ro, vec3 rd, vec3 currentPosition, vec3[1] lightSources) {\n\n    vec3 outputColor = sceneSDF(currentPosition).xyz;\n\n    vec3 normal = calculateNormal(currentPosition);\n    \n    vec3 ambient = calculateAmbient();\n    vec3 diffuse = calculateDiffuse(ro, rd, currentPosition, normal, lightSources);\n    float specular = calculateSpecular(ro, rd, currentPosition, normal, lightSources);\n    \n    outputColor = outputColor * (ambient + diffuse + (0.5 * specular));\n    return outputColor;\n}\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    \n    vec3[1] lightSources;\n    lightSources[0] = vec3(cos(iTime) * 4.0, 4.0, -2.0);\n    float depth = 0.0;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec3 currentPosition = ro + depth * rd;\n        float dist = sceneSDF(ro + depth * rd).w;\n        \n        if (dist < 0.01) {\n            return calculateLighting(ro, rd, currentPosition, lightSources);\n        }\n        depth += min(dist, 2.5);\n        if (depth >= 100.0) {\n            break;\n        }\n    }\n    return vec3(0.7);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Move origin to the center of the screen\n    vec2 uvCenter = uv - 0.5;\n    // Fix aspect ratio\n    uvCenter.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(5.0, 5.0, -5.0);\n    vec3 cameraDir = normalize(vec3(uvCenter, 1));\n\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    \n\n  \n    \n    \n    \n    \n\n        col = rayMarch(cameraPos, cameraDir);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}