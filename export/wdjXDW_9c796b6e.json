{"ver":"0.1","info":{"id":"wdjXDW","date":"1553876190","viewed":464,"name":"CSG Sculpture","username":"fizzer","description":"Features a method of raytracing a CSG model composed of one additive group and one subtractive group (this means there is no need for a stack when evaluating the CSG graph).","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor /= fragColor.a;\n    \n    fragColor.rgb = smoothstep(0., 1., fragColor.rgb + .05);\n    \n    // Gamma and Dither\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1./2.2)) +\n        texelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).rrr / 100.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nuvec2 rstate;\n\n// Tiny Encryption Algorithm for random numbers: \nuvec2 encrypt(uvec2 v)\n{\n    uint k[4], sum = 0U, delta = 0x9e3779b9U;\n    k[0] = 0xA341316CU;\n    k[1] = 0xC8013EA4U;\n    k[2] = 0xAD90777DU;\n    k[3] = 0x7E95761EU;\n    for(uint i = 0U; i < 4U; ++i)\n    {\n        sum += delta;\n        v.x += ((v.y << 4) + k[0]) ^ (v.y + sum) ^ ((v.y >> 5) + k[1]);\n        v.y += ((v.x << 4) + k[2]) ^ (v.x + sum) ^ ((v.x >> 5) + k[3]);\n    }\n\n    return v;\n}\n\nfloat rand()\n{\n    rstate = encrypt(rstate);\n    return float(rstate.x & 0xfffffU) / float(1U << 20U);\n}\n\n// Box surface normal.\nvec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)\n{\n    rp = rp - (p0 + p1) / 2.;\n    vec3 arp = abs(rp) / (p1 - p0);\n    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp);\n}\n\n// Ray-box intersection interval.\nvec2 box(vec3 ro, vec3 rd)\n{\n    ro = (-sign(rd) - ro) / rd,\n    rd = ro + sign(rd) / rd * 2.;\n    return vec2(max(ro.x, max(ro.y, ro.z)), min(rd.x, min(rd.y, rd.z)));\n}\n\nvec2 intersectPrimitive(vec3 ro, vec3 rd, mat4 m, out vec3 n1, out vec3 n2)\n{\n    ro = (m * vec4(ro, 1.)).xyz;\n    rd = mat3(m) * rd;\n    vec2 is = box(ro, rd);\n    m = inverse((m));\n    m = inverse(transpose(m));\n    n1 = normalize(mat3(m) * boxNormal(ro + rd * is.x, vec3(-1), vec3(+1)));\n    n2 = normalize(mat3(m) * boxNormal(ro + rd * is.y, vec3(-1), vec3(+1)));\n    return is;\n}\n\nconst int num_add=20, num_sub=20;\n\nmat4 genPrim(int i)\n{\n    vec4 v = vec4(cos(float(i)),cos(float(i) * 122.),\n                  cos(float(i) * 3.), .3 + cos(float(i) * 20.) * .2);\n    \n    mat4 m = mat4(1. / v.w);\n    float ax = .4 + cos(float(i));\n    float az = .4 + cos(float(i));\n\n    if(i < num_add)\n        ax = az = 2.;\n\n    //ax=az=0.;\n    m *= mat4(1., 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1);\n\n    m *= mat4(1, 0, 0, 0,\n            0, cos(ax), sin(ax), 0,\n            0, -sin(ax), cos(ax), 0,\n            0, 0, 0, 1) * .4;\n\n    m *= mat4(cos(az), sin(az), 0, 0,\n            -sin(az), cos(az), 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1);\n\n    m *= mat4(1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            v.x, v.y, v.z, 1);\n\n    return m;\n}\n\n\nfloat trace(vec3 ro, vec3 rd, out vec3 n)\n{\n    float mint = 1e4;\n\n    int num_intervals = 0;\n    vec2 intervals[num_add + num_sub];\n    mat2x3 hitNormals[num_add + num_sub];\n\n    // Process the additive primitives first.\n    for(int i = 0; i < num_add; ++i)\n    {\n        vec3 n1, n2;\n        mat4 co = genPrim(i);\n        vec2 is = intersectPrimitive(ro, rd, co, n1, n2);\n\n        if(is.x < is.y)\n        {\n            intervals[num_intervals] = is;\n            hitNormals[num_intervals] = mat2x3(n1, n2);\n            num_intervals += 1;\n        }\n    }\n\n    // Clip the additive primitive intersection intervals by\n    // the subtractive primitive intersection intervals.\n    for(int i = 0; i < num_sub; ++i)\n    {\n        vec3 n1, n2;\n        mat4 co = genPrim(i + num_add);\n        vec2 is = intersectPrimitive(ro, rd, co, n1, n2);\n        mat2x3 hn = mat2x3(n1, n2);\n        if(is.x < is.y)\n        {\n            // Visit each interval and clip it, producing a second\n            // interval if the interval is clipped in the middle.\n            int num_intervals2 = num_intervals;\n            for(int j = 0; j < num_intervals2; ++j)\n            {\n                mat2x3 hn2 = hitNormals[j];\n                vec2 iv = intervals[j];\n                if(iv.x <= is.y && iv.y >= is.x)\n                {\n                    vec2 iv2;\n\n                    hitNormals[j][0] = iv.x < is.y ? hitNormals[j][0] : hn[1];\n                    intervals[j].x = min(iv.x, is.y);\n\n                    hitNormals[j][1] = hn[0];\n                    intervals[j].y = is.x;\n\n                    iv2.x = is.y;\n                    iv2.y = max(iv.y, is.x);\n\n                    if(intervals[j].x >= intervals[j].y)\n                    {\n                        hitNormals[j][0] = hn[1];\n                        hitNormals[j][1] = iv.y > is.x ? hn2[1] : hn[0];\n                        intervals[j] = iv2;\n                    }\n                    else if(iv2.x < iv2.y && num_intervals < intervals.length())\n                    {\n                        hitNormals[num_intervals][0] = hn[1];\n                        hitNormals[num_intervals][1] = iv.y > is.x ? hn2[1] : hn[0];\n                        intervals[num_intervals] = iv2;\n                        num_intervals += 1;\n                    }\n                }\n            }   \n        }\n    }\n\n    // Floor.\n    if((-13. -ro.y) / rd.y > 0.)\n    {\n        mint = (-13. - ro.y) / rd.y;\n        n = vec3(0, 1, 0);\n    }\n\n    // Find the nearest solid intersection point.\n    for(int i = 0; i < num_intervals; ++i)\n    {\n        vec2 is = intervals[i];\n        if(is.x > 0. && is.x < is.y && is.x < mint)\n        {\n            mint = is.x;\n            n = hitNormals[i][0];\n        }\n    }\n\n    return mint;\n}\n\n// Lambert BRDF sampling-function.\n// http://amietia.com/lambertnotangent.html\nvec3 lambertNoTangent(in vec3 normal, in vec2 uv)\n{\n    float theta = 6.283185 * uv.x;\n    uv.y = 2.0 * uv.y - 1.0;\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n    return normalize(normal + spherePoint);\n}\n\nvec3 sampleRay(vec3 ro, vec3 rd)\n{\n    vec3 energy = vec3(0);\n    vec3 spectrum = vec3(1.);\n    \n    vec3 rp = ro, oro = ro, firstrp = rp;\n    \n    for(int i = 0; i < 4; ++i)\n    {\n        vec3 n, p0, p1;\n        float res = trace(ro, rd, n);\n        rp = ro + rd * res;\n\n        // Save primary ray hit for background fade.\n        if(i == 0)\n            firstrp = rp;         \n\n        if(res < 0. || res > 1e3)\n        {\n            energy+=min(vec3(max(.2,rd.y)*3.)*spectrum,1.5);\n            break;\n        }\n\n        // Inner surfaces detected by facingness.\n        bool inside = false;       \n        if(dot(rd, n) > 0.)\n        {\n            inside = true;\n            n = -n;\n        }\n\n        // Fresnel\n        float fr = mix(0.1, 0.5, pow(clamp(1. - dot(-rd, n), 0., 1.), 3.)) / 2.;\n        if(rp.y < -2.999)\n            fr = 0.;\n        \n        if(rand() > fr)\n        {\n            // Diffuse\n            vec3 lrd = lambertNoTangent(n, vec2(rand(), rand()));\n\n            spectrum/= 3.14159;\n\n            if(inside)\n                spectrum *= .8;\n            else if(rp.y>-2.999)\n                spectrum *= mix(.7,1.,step(.5,fract(rp.y*10.5)))*.9;\n\n            ro = rp + n * 1e-4;\n            rd = lrd;\n        }\n        else\n        {\n            // Specular\n            spectrum *= .8;\n\n            ro = rp + n * 1e-4;\n            rd = reflect(rd,n);\n        }\n\n    }\n\n    return mix(vec3(.6), energy, 1. - smoothstep(20., 180., distance(firstrp, oro)));\n}\n\nvec2 disc(vec2 uv)\n{\n    float a = uv.x * acos(-1.) * 2.;\n    float r = sqrt(uv.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\nvec2 polygon(vec2 uv, float n)\n{\n    float s = 1. / n;\n    float b = 2. / n * acos(-1.);\n    float a = b * floor(uv.y * n);\n    uv = vec2(uv.x, mod(uv.y, s) / s);\n\n    if (uv.x + uv.y > 1.)\n        uv = vec2(1) - uv;\n\n    uv = vec2(uv.x, 0) + vec2(cos(b), sin(b)) * uv.y;\n\n    return uv * mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec2 cone(vec2 v)\n{\n    return disc(vec2(v.x, 1. - sqrt(1. - v.y)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rstate = uvec2(fragCoord.xy) + uint(iFrame) * 4096U;\n    vec2 t = (fragCoord.xy / iResolution.xy * 2. - 1.) * 1.3;\n    t.y *= iResolution.y / iResolution.x;\n\n    // Slight blur / AA\n    t.xy = t.xy + cone(vec2(rand(), rand())) / 512.;\n    \n    if(iFrame == 0 || iMouse.z > 0.)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\n    if(length(max(abs(t) - .65, 0.)) < .05)\n    {\n        // Primary ray\n        vec3 ro = vec3(0., -.2, 13.);\n        vec3 rd = normalize(vec3(t.xy, -2.8));\n\n        {\n            float an = -5.4;\n            rd.xz *= mat2(cos(an), sin(an), sin(an), -cos(an));\n            ro.xz *= mat2(cos(an), sin(an), sin(an), -cos(an));\n        }\n        \n        // Accumulate\n        fragColor.rgb += sampleRay(ro, rd);\n    }\n    else\n    {\n        fragColor.rgb += vec3(0);\n    }\n\n    fragColor.a += 1.;\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}