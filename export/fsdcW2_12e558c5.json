{"ver":"0.1","info":{"id":"fsdcW2","date":"1673126861","viewed":57,"name":"Text editor","username":"rucksack","description":"Very simple text editor with CRT effect.\nEditor logic in buffer A, text rendering in buffer B, CRT effect in image buffer.\nLetters are rendered weirdly on some GPUs, please let me know if you see why this happens.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["text","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CRT effect in this buffer.\n// Editor state in buffer A,\n// text rendering in buffer B.\n\nconst float curvature = 5.;\nconst float vignetteWidth = 70.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Curvature (offset by square of distance from center)\n    vec2 curve = uv * 2. - 1.;\n    float offset = length(curve) / curvature;\n    curve += curve * offset * offset;\n    curve = curve * 0.5 + 0.5;\n\n    // Use curved UVs to fetch texture\n    vec3 col = texture(iChannel0, curve).rgb;\n\n    // Use inverted, centered UV coords to create a vignette gradient of a certain width;\n    vec2 vignette = vignetteWidth / iResolution.xy;\n    curve = curve * 2. - 1.;\n    vignette = smoothstep(vec2(0), vignette, 1. - abs(curve));\n    curve = curve * 0.5 + 0.5;\n    \n    // Scanlines (use original UV)\n    vec3 scan = vec3(\n        col.r * (.1 + .3*sin(uv.y * iResolution.y + 40.)),\n        col.g * (.1 + .2*cos(uv.y * iResolution.y)),\n        col.b * (.1 + .4*sin(uv.y * iResolution.y - 70.)));\n    col += scan;    \n    \n    // Apply vignette\n    col = col * vignette.x * vignette.y;\n    \n    // Gamma correction\n    col = pow(col, vec3(1.5));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Keyboard texture has values at coordinates\n// (i, c) where c is\n//     |-> 0 for keys held\n//     |-> 1 for keys just pressed\n//     |-> 2 for toggles\n\n#define KEYPRESS(key) (texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.)\n\nconst int BACKSPACE = 8;\nconst int SHIFT = 16;\n\nconst int cols = 16;\n\nconst ivec2 statepos = ivec2(0);\n\n\n// Registers keypresses\n// TODO repeat keys on \nint keypress() {\n    // Only register in sensible ASCII range\n    for (int i = 32; i < 128; i++) {\n        // Keypress!\n        if (KEYPRESS(i)) {\n            if (i > 64 && i <= 90) {\n                // Uppercase letters are the only ones we get!\n                // Uppercase only if shift is held\n                return i + 32 * int(texelFetch(iChannel1, ivec2(SHIFT, 0), 0).x <= 0.); \n            }\n            return i;\n        }\n    }\n    return -1 + (BACKSPACE+1) * int(KEYPRESS(BACKSPACE));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        if (ivec2(fragCoord) == statepos) {\n            // Initialize\n            fragColor = vec4(1, 0, 0, 0);\n        } else {\n            fragColor = vec4(0);\n        }\n        return;\n    }\n    fragColor = vec4(0,0,0,1);\n    vec4 state = texelFetch(iChannel0, statepos, 0);\n    ivec2 xy = ivec2(state.xy);\n    // Erased version of position:\n    // (note that the % operator did not work as expected here)\n    ivec2 xyback = xy;\n    xyback.y -= int(xy.x == 0 && xy.y > 0);\n    if (!(xy.x == 1 && xy.y == 0)) xyback.x = xy.x > 0 ? xy.x - 1 : cols - 1;\n    int key = keypress();\n    if (ivec2(fragCoord) == statepos && key > 0) {\n        // Update coordinate\n        if (key == BACKSPACE) {\n            // Erase\n            xy = xyback;\n        } else {\n            // Proceed\n            xy.y += int(xy.x == cols-1);\n            xy.x = (xy.x + 1) % cols;\n        }\n        fragColor = vec4(vec2(xy), state.z, min(1., state.w + .2));\n    } else if (ivec2(fragCoord) == statepos && key <= 0) {\n        fragColor = vec4(state.xyz, max(state.w - .05, 0.));\n    // Test for position behind marker in case of backspace\n    // -> otherwise, erasing won't function on last letter :)))\n    } else if (ivec2(fragCoord) == xyback && key == BACKSPACE) {\n        // Erase letter\n        fragColor.r = 0.;\n    } else if (ivec2(fragCoord) == xy && key > 0) {\n        // Store letter\n        fragColor.r = float(key);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Uncomment this to show internal state\n// #define SHOW_INTERNAL\n\nconst vec2 cdim = vec2(48., 64);\nconst int cols = 16;\n\nivec2 font_lookup(in int char) {\n    if (char >= 32 && char <= 126) {\n        return ivec2(char % 16, 15 - char / 16);\n    }\n    return ivec2(0, 13); // Space if unknown\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Offset based on width of text\n    fragCoord.x -= (iResolution.x - float(cols) * cdim.x) / 2.;\n    // TODO similar in y dir (and clamp there)\n    \n    // Determine position in texture A\n    ivec2 idx = ivec2(fragCoord.x / cdim.x, (iResolution.y - fragCoord.y) / cdim.y);\n    // Wrap around since state is at (0, 0)\n    if (idx.x < cols && idx.x >= 0)\n        idx = ivec2((idx.x + 1) % cols, idx.x == cols - 1 ? idx.y + 1 : idx.y);\n    // Find character\n    int char = int(texelFetch(iChannel0, idx, 0).r);\n    \n    // Render background\n    vec3 col = vec3(0);\n    // Blend in an effect based on key spam rate\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    // Use sqrt to pronounce effect at low values\n    col = min(1., sqrt(state.w)) * vec3(0.1, 0.2, 0.5);\n\n\n    // Render letter\n    if (fragCoord.x >= 0. && char > 0) {\n        ivec2 font_idx = font_lookup(char);\n        // Because we reduce the width of the letters slightly\n        float edge = (cdim.y - cdim.x) / 2.;\n        ivec2 font_offset = ivec2(mod(vec2(fragCoord.x + edge, fragCoord.y), cdim));\n        col += vec3(texelFetch(iChannel1, font_idx * 64 + font_offset, 0).r);\n    }\n    // For testing coordinates\n    // col = exp(.3*float(idx.x + idx.y)) * vec3(0.1);\n    \n\n    // Output to screen\n#ifdef SHOW_INTERNAL\n    fragColor = vec4(col + texture(iChannel0, uv*.1).rgb / 128. ,1.0);\n#else\n    fragColor = vec4(col, 1.0);\n#endif\n}","name":"Buffer B","description":"","type":"buffer"}]}