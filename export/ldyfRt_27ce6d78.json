{"ver":"0.1","info":{"id":"ldyfRt","date":"1529939332","viewed":162,"name":"Prototyping terrain","username":"vchizhov","description":"A test using a 3d fbm + a torus. THe coloring is based on altitude only.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","terrain","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 sunDir = normalize(vec3(-0.6f, 0.4f, 0.6f));\n\n// hash and noise by iq\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n\nfloat torus(in vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 pos, int layers, float AM, float FM)\n{\n    float sum = 0.0f;\n    float amplitude = 1.0f;\n    for(int i=0;i<layers;++i)\n    {\n        sum += amplitude*noise(pos);\n        amplitude *= AM;\n        pos *= FM;\n    }\n    return sum;\n}\n\nfloat field(in vec3 pos)\n{\n    float torusContr = torus((pos-vec3(5.0f, 5.0f, 5.0f)).xzy,vec2(3.0,0.6))<0.0? 1.0 : 0.0;\n    float noiseContr = 2.0*fbm(0.4*pos, 3, 0.5, 4.0) - 2.6 + 1.0f-pos.y*pos.y/40.0f;\n    // use max(torusContr,noiseContr) to remove erosion\n    return torusContr + noiseContr; \n}\n\nvec3 getNormal(in vec3 pos)\n{\n    float h = 0.01f;\n    float center = field(pos);\n    float dx = field(pos+vec3(h, 0.0, 0.0)) - center;\n    float dy = field(pos+vec3(0.0, h, 0.0)) - center;\n    float dz = field(pos+vec3(0.0, 0.0, h)) - center;\n    return normalize(vec3(dx/h,dy/h,dz/h));\n}\n\nfloat findIntersection(in vec3 ro, in vec3 rd)\n{\n    float tmin=0.0f;\n    float tmax = 100.0f;\n    float delta = 0.1f;\n    float sum = 0.0f;\n    float t = tmin;\n    \n    //bounding box\n    float ax = 0.0f;\n    float bx = 10.0f;\n    float ay = 0.0f;\n    float by = 10.0f;\n    float az = 0.0f;\n    float bz = 10.0f;\n    for(;t<tmax;t+=delta)\n    {\n        vec3 pos = ro + t*rd;\n        if(pos.y<ay || pos.y>by|| pos.x>bx || pos.x<ax || pos.z<az || pos.z>bz) continue;\n        else\n        {\n            if(field(pos)>0.0f) return t;\n        }\n    }\n    return -1.0f;\n}\n\nvec3 render(in vec3 o, in vec3 rd)\n{\n    float t = findIntersection(o,rd);\n    if(t<0.0f) return vec3(0.0f);\n    vec3 pos = o+t*rd;\n    return vec3(pos.y/10.0f);\n    /*\n    vec3 pos = o+t*rd;\n    vec3 lightDir = vec3(0.0f, 1.0f, 0.0f);\n \treturn mix(vec3(1.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f), max(0.0f, dot(getNormal(pos), lightDir)));\n\t*/\n}\n\n#define PI 3.14159265359f\nvec3 render(vec2 ndc, float aspectRatio)\n{\n\t// camera horizontal field of view\n    // 120 degrees fov\n    const float fov = 2.0f*PI / 3.0f;\n    const float scaleX = tan(fov / 2.0f);\n    // camera origin\n    float speed=0.7f;\n    vec3 target = vec3(5.0f,5.0f, 5.0f);\n    float dist = 10.0f;\n    vec3 o = target + vec3(dist*cos(iTime*speed), dist, dist*sin(iTime*speed));\n    \n    vec3 forward = normalize(target-o);\n    vec3 right = normalize(cross(vec3(0.0f, 1.0f, 0.0f), forward));\n    vec3 up = cross(forward, right);\n\t// camera up vector\n    up = up*scaleX*aspectRatio;\n\t// ray direction\n    vec3 rd = normalize(forward + ndc.x*right + ndc.y*up);\n    return render(o, rd);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ndc = 2.0f*fragCoord.xy / iResolution.xy-1.0f;\n    //vec3 col = render(ndc, iResolution.y/iResolution.x);\n    // approximate gamma correction\n    //col = sqrt(col);\n    float aspectRatio = iResolution.y/iResolution.x;\n    vec3 col = render(ndc,aspectRatio);\n\tfragColor = vec4(col,1.0f);\n}","name":"Image","description":"","type":"image"}]}