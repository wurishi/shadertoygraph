{"ver":"0.1","info":{"id":"dtd3R7","date":"1682946100","viewed":681,"name":"Volumetric Pathtracing using RM","username":"Poisson","description":"A shader that renders a volumetric tiny planet, a csg cloud with noise, and a fluffy menger sponge fractal using raymarching  / delta tracking.","likes":43,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","raymarching","raytracer","ray","volume","volumetric","fog","raymarcher","scattering","pathtracing","pathtracer","bvh","path","scatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ACES tonemapping\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec4 data = texture(iChannel0, p/RENDER_RES); // numbers of renders\n    vec3 col = data.rgb/data.a;\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    col = ACES(col); // tonemapping\n    \n    // vignette\n    col *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n       \n    // output\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DENSITY .4 // volume density, between 0 and 1\n#define STEP_SIZE .25 // raymarching step size\n\nconst vec3 sunDir = normalize(vec3(1.5,.5,1)); // sun direction\nconst vec3 sunCol = vec3(2,1.2,.8); // sun color\n\n// vec2 to float hash\nfloat hash(vec2 x) {\n\tfloat n = dot(x,vec2(127.1,311.7));\n\treturn fract(sin(n)*4568.7564);\n}\n\nfloat seed; // randoms seed\n\n// float hash\nfloat hash(void) {return fract(sin(seed+=.1)*4568.7564);}\n\n// random 3d vector\nvec3 uniformVector() {\n    float a = hash()*6.2831853;\n    float x = hash()*2.-1.;\n    float z = hash();\n    \n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(a),cos(a)),x);\n}\n\n// 3d noise function\nfloat noise(vec3 x) {\n    vec3 p = floor(x+.5);\n    vec3 f = fract(x+.5);\n    f = f*f*(3.-2.*f);\n    \n    x = p + f - .5;\n    return textureLod(iChannel1, x/iChannelResolution[1], 0.).r;\n}\n\n// fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    f += .0625*noise(8.*p);\n    return f;\n}\n\n// ray box intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 ra) {\n    vec3 m = 1./rd;\n    vec3 n = -m*ro;\n    vec3 k = abs(m)*ra;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\t\n\tif(tN>tF || tF<0.) return vec2(-1);\n    \n    return vec2(tN, tF);\n}\n\n// sphere sdf\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\n// box sdf\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// menger sponge sdf\nfloat sdMenger(vec3 p) {\n    vec3 q = abs(p);\n    float d = max(q.x,max(q.y,q.z))-1.;\n    \n    float s = 1.;\n    for (int i=0; i<2; i++) {\n        vec3 a = mod(p*s,2.) - 1.;\n        vec3 r = 1.-3.*abs(a);\n             r = abs(r);\n        \n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        \n        float c = min(da,min(db,dc));\n        \n        s *= 3.;\n        d = max(d, (c-1.)/s);\n    }\n    \n    return d;\n}\n\n// union of two sdf\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n// scene sdf\n// return distance and material index\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10);\n    \n    // menger sponge\n    d = opU(d, vec2(sdMenger(p-vec3(-2.2,0,0)), 0));\n    // cube sphere boolean\n    d = opU(d, vec2(max(sdBox(p,vec3(.9)), \n                        -sdSphere(p,1.)) + .3*fbm(p*6.)-.15, \n                        1));\n    // kind of planet cube\n    d = opU(d, vec2(sdBox(p-vec3(2.2,0,0),vec3(1) - .1*step(.45,fbm(p*3.))) - .1*fbm(p*5.), 2));\n    \n    // volumetric density\n    d.x = max(d.x, DENSITY - hash());\n\n    return d;\n}\n\n// raymarching function\n// return intersection distance and material index\nvec2 intersect(vec3 ro, vec3 rd) {\n    // bounding volume\n    vec2 bound = boxIntersect(ro, rd, vec3(3.3,1.1,1.1));\n    float tmin = max(0.,bound.x);\n    float tmax = bound.y;\n    if (tmax<0.) return vec2(-1);\n    \n    float t = tmin; // distance travelled\n    vec2 res = vec2(-1); // result\n    \n    for (int i=0; i<256; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        \n        vec2 h = map(p); // scene distance and material id\n        res = vec2(t,h.y);\n        if (h.x<0. || t>tmax) break; // hit or miss\n        t += h.x*STEP_SIZE; // march\n    }\n    if (t>tmax) res.x = -1.; // miss the objects\n    \n    return res;\n}\n\n// cheap sky\nvec3 skybox(vec3 rd) {\n    vec3 col = mix(vec3(.3,.6,1), vec3(.3,.6,1)*vec3(.3,.6,1)*.2, .5+.5*rd.y);\n    col = mix(col, vec3(1,.9,.7)*.6, clamp(exp(-rd.y*8.-.5),0.,1.));\n    col = mix(col, col*.25, clamp(exp(-rd.y*8.-1.),0.,1.));\n    \n    return 1.5*col;\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 ord = rd; // original ray direction\n    \n    vec3 col = vec3(1); // color mask\n    vec3 acc = vec3(0); // color accumulation\n        \n    for (int i=0; i<12; i++) { // 12 bounce of GI\n        vec2 tm = intersect(ro, rd); // distance and material index\n        if (tm.x<0.) { // we miss the objects\n            acc += col*skybox(rd);\n            break;\n        }\n        vec3 p = ro + rd*tm.x; // hit point\n\n        ro = p; // new ray origin\n        rd = uniformVector(); // new ray direction, simple isotropic scattering\n        \n        // materials\n        if (tm.y<.5) // pink\n            col *= .9*vec3(1,.3,.6);\n        else if (tm.y<1.5) // cloud\n            col *= .8;\n        else if (tm.y<2.5) // planet\n            col *= .85*mix(vec3(1,.5,.2), vec3(.2,.6,1), step(.45,fbm(p*3.)));\n                \n        // sun light\n        if (intersect(p, sunDir).x<0.)\n            acc += col*sunCol;\n    }\n    // sun glare\n    float sun = pow(clamp(dot(ord, sunDir), 0., 1.), 32.);\n    acc += .4*sunCol*sunCol * sun;\n       \n     // output\n    return acc;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n    vec3 v = cross(u, w); // up vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5*iResolution.xy)/iResolution.y;\n\n    float an = -mo.x*3.141592+.9; // camera xz rotation\n    vec3 ro = 6.5*vec3(cos(an),.8+1.2*mo.y,sin(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 tot = vec3(0);\n    for (int i=0; i<SPP; i++) {\n        // init randoms seed\n        seed = float(i)+iTime + hash(fragCoord/iResolution.xy);\n                \n        vec2 off = vec2(hash(), hash()) - .5; // AA offset\n        // normalized pixel coordinates\n        vec2 p = (fragCoord*RENDER_RES+off - .5*iResolution.xy) / iResolution.y;\n        \n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n        vec3 col = render(ro, rd); // render\n                \n        tot += col;\n    }\n    tot /= float(SPP);\n    \n    // accnumulation\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(tot,1) + data*step(iMouse.z,0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SPP 1 // samples per frame\n#define RENDER_RES 1. // render size, try 2","name":"Common","description":"","type":"common"}]}