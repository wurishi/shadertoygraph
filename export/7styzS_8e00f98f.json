{"ver":"0.1","info":{"id":"7styzS","date":"1654296155","viewed":68,"name":"Sphere ray marching1","username":"CHN","description":"Controls\n->Movement: Arrow keys\n->Camera rotate: Mouse movement while a mouse button is pressed","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_MARCHING_STEPS = 150;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nconst float precis = 0.00005;\n\nconst float PI = 3.14159265;\n\nconst float earthRadius = 3.;\nconst float cloudRadius = 3.5;\n\nvec3 norm;\nfloat depth;\nint type;\nfloat currentHeight;\nvec3 dir;\nvec2 cloudRotation;\n\nvec2 sdFbm( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 5;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        n = smax(n,d-0.1*s,0.3*s);\n        d = smin(n,d      ,0.3*s);\n        q = m*q;\n        s = 0.315*s;\n\n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n}\n\n\n//from : https://www.shadertoy.com/view/WslGWl\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat fbmCloud(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nconst vec2 h = vec2(0.0001, 0);\n\n#define calcNormal(p, f) normalize(vec3(f(p+h.xyy) - f(p-h.xyy), f(p+h.yxy) - f(p-h.yxy), f(p+h.yyx) - f(p-h.yyx)))\n\nfloat map(vec3 pos) {\n\n    float f = MAX_DIST;\n    \n    float sphereSDF = sdSphere(pos, earthRadius);\n    vec3 sphPos = pos + dir * sphereSDF;\n    vec2 fbm = sdFbm(sphPos, depth * precis, 0.01);\n    \n    float x = sphereSDF + fbm.x + .01;\n    \n    if(x < f)\n    {\n        if(sphereSDF < .0)\n        {  \n            f = sphereSDF;\n            type = 2;\n            currentHeight = fbm.y;\n        }\n        else\n        {\n            f = x;\n            type = 1;\n            currentHeight = fbm.y;\n        }\n    }\n    \n    return f;\n}\n\nfloat cloudMap(vec3 pos) {\n\n    float f = MAX_DIST;\n    \n    float sphereSDF = sdSphere(pos, cloudRadius);    \n    vec3 sphPos = sphereSDF * dir + pos;\n    mat4 cloudMaskRotMat = rotationMatrix(vec3(0., -1., 0.), cloudRotation.x * 50.);\n    sphPos = apply_rot(cloudMaskRotMat, sphPos);\n    \n    float y = asin(sphPos.y / length(sphPos)) / PI;\n    \n    if(abs(y) > 0.3)\n    {\n        return f;\n    }\n    \n    float fbm = fbmCloud(sphPos);\n    \n    float x = sphereSDF + fbm - 0.15;\n        \n    if(x < f)\n    {\n        f = x;\n        currentHeight = x;\n    }\n    \n    return f;\n}\n\nfloat raycaster(vec3 pos, vec3 dir) {\n    depth = MIN_DIST;\n    vec4 color;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(pos + depth * dir);\n        if (dist < EPSILON) {\n            norm = calcNormal(pos + depth * dir, map);\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            type = -1;\n            return depth;\n        }\n    }\n\n    return depth;\n}\n\nfloat cloudRaycaster(vec3 pos, vec3 dir) {\n    depth = MIN_DIST;\n    vec4 color;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = cloudMap(pos + depth * dir);\n        if (dist < EPSILON) {\n            norm = calcNormal(pos + depth * dir, cloudMap);\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return depth;\n        }\n    }\n\n    return depth;\n}\n   \nvec3 rayDirection(float fieldOfView, vec3 camRot, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    vec3 dir = vec3(xy, -z);\n    dir = apply_rot(rotationMatrix(vec3(1,0,0), camRot.x), dir);\n    dir = apply_rot(rotationMatrix(vec3(0,1,0), camRot.y), dir);\n    dir = apply_rot(rotationMatrix(vec3(0,0,1), camRot.z), dir);\n    return normalize(dir);\n}\n\nvec2 sphericalMapping(vec3 sphPos, float r)\n{\n    vec2 uv;\n    \n    uv.x = .5 + atan(sphPos.x / sphPos.z) / PI / 2.;\n    uv.y = .5 + asin(sphPos.y / length(sphPos)) / PI / 2.;\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    loadAll(iChannel0);\n\tdir = rayDirection(60.0, rot.xyz, iResolution.xy, fragCoord);\n    float dist = raycaster(pos.xyz, dir);\n    vec3 newPos = dist * dir + pos.xyz;\n    vec4 color = vec4(0.);\n    \n    float sphereSDF = sdSphere(newPos.xyz, earthRadius);\n    vec3 sphPos = newPos.xyz + dir * sphereSDF;\n    vec2 uv = sphericalMapping(sphPos, earthRadius);\n        \n    vec4 waterColor = vec4(dot(-dir, norm));\n    waterColor *= vec4(0., 0.3, .8, 1.) * texture(iChannel2, uv * 4. + vec2(iTime * .015, iTime * .015)).x;\n    waterColor -= vec4(currentHeight * 2.);\n    waterColor += vec4(.3 - pow(max(currentHeight, 0.), .4));\n    \n    vec4 groundColor = vec4(dot(-dir, norm));\n    groundColor *= texture(iChannel2, uv * 8.);\n    float grass = texture(iChannel3, uv * 8.).x;\n    groundColor += grass * vec4(-.3, .1, -.3, 1.) * (1. - min(pow(-currentHeight, 1.6) * 10., 1.));\n    \n    float waterBlend = min(pow(-currentHeight * 15., 8.) * 4., 1.);   \n    vec4 groundColorWaterBlended = groundColor * waterBlend + (1. - waterBlend) * waterColor;\n    \n    if(type == 1)\n    {\n        color = groundColorWaterBlended;\n    }\n    else if(type == 2)\n    {\n        color = waterColor;\n    }\n    \n    cloudRotation = vec2(iTime * .02, .0);\n    float cloudDist = cloudRaycaster(pos.xyz, dir);\n    vec3 cloudPos = cloudDist * dir + pos.xyz;\n    \n    float cloudSphereSDF = sdSphere(cloudPos.xyz, cloudRadius);\n    vec3 cloudSphPos = cloudPos.xyz + dir * cloudSphereSDF;\n    vec2 cloudUV = sphericalMapping(cloudSphPos, cloudRadius);\n\n    float cloudColorMask = texture(iChannel3, cloudUV * 2. + cloudRotation * 1.64).x;\n    cloudColorMask = pow(max(cloudColorMask-.4, 0.), 1.1);\n    vec4 cloudColor = vec4(dot(-dir, norm));\n    color = cloudColorMask * cloudColor + (type == -1 ? 0.: 1.) * (1. - cloudColorMask) * groundColorWaterBlended;\n    \n    fragColor = pow(color, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_W 87\n\n#define KEY_J 74\n#define KEY_L 76\n#define KEY_K 75\n#define KEY_O 79\n\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_Z 90\n#define KEY_X 88\n\n#define varRow 0\n#define var(name, column, row) ivec2 name = ivec2(column, row)\n\nvar(_pos, 0, varRow);\nvar(_rot, 1, varRow);\nvar(_oldMousePos, 2, varRow);\nvar(_itrCount, 3, varRow);\n\nvec4 pos, rot, oldMousePos, rayPos, itrCount;\n\nvec4 load(sampler2D buffer, in ivec2 coord)\n{\n\treturn texelFetch(buffer, coord, 0);\n}\n\nvoid loadAll(sampler2D buffer)\n{\n\tpos = load(buffer, _pos);\n    rot = load(buffer, _rot);\n    itrCount = load(buffer, _itrCount);\n}\n\nvec4 save(in ivec2 valCoord, in vec4 value, in ivec2 coord)\n{\n\tif(coord == valCoord)\n    {\n    \treturn value;\n    }\n    \n    return vec4(0.);\n}\n\nvec4 saveAll(in vec2 fCoord)\n{\n    ivec2 coord = ivec2(fCoord);\n    \n    vec4 saveVal = vec4(0.);\n      \n    saveVal += save(_pos, pos, coord);\n    saveVal += save(_rot, rot, coord);\n    saveVal += save(_oldMousePos, oldMousePos, coord);\n    saveVal += save(_itrCount, itrCount, coord);\n    \n    return saveVal;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 apply_rot(mat4 r, vec3 p)\n{\n    return (r*vec4(p, 1.)).xyz;\n}\n\nfloat saturate(float s)\n{\n\treturn clamp(s,0.0,1.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat hash1(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// from: https://www.shadertoy.com/view/WslGWl\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash1(n +   0.0), hash1(n +   1.0), f.x),\n                        mix(hash1(n +  57.0), hash1(n +  58.0), f.x), f.y),\n                    mix(mix(hash1(n + 113.0), hash1(n + 114.0), f.x),\n                        mix(hash1(n + 170.0), hash1(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float getKeyState(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x * 0.1;\n}\n\nvoid writeDefaults()\n{\n    pos = vec4(0., 0., 15., 0);\n\trot = vec4(0, 0, 0, 0);\n    itrCount.x = 14.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    loadAll(iChannel0);\n    oldMousePos = load(iChannel0, _oldMousePos);\n    \n    vec3 posDif;\n    \n    posDif.x = -getKeyState(KEY_LEFT) + getKeyState(KEY_RIGHT);\n    posDif.y = -getKeyState(KEY_N) + getKeyState(KEY_M);\n    posDif.z = -getKeyState(KEY_UP) + getKeyState(KEY_DOWN);\n    \n    posDif = apply_rot(rotationMatrix(vec3(0,1,0), rot.y) * rotationMatrix(vec3(1,0,0), rot.x), posDif);\n    \n    pos.xyz += posDif * 0.5; \n    \n    itrCount.x += -getKeyState(KEY_Z) * 1.5 + getKeyState(KEY_X) * 1.5;\n    \n    if(iFrame == 0)\n    {\n        writeDefaults();\n    \toldMousePos.xyz = iMouse.xyz;\n    }\n    \n    if (oldMousePos.z > 0. && iMouse.z > 0.) {\n    \trot.xy += vec2((-iMouse.y + oldMousePos.y) * 0.05, \n                   \t\t(iMouse.x - oldMousePos.x) * 0.1);  \n    }\n    \n   \toldMousePos.xyz = iMouse.xyz;\n    \n\tfragColor = saveAll(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}