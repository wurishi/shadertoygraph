{"ver":"0.1","info":{"id":"DtKcDh","date":"1700179465","viewed":57,"name":"Unit 1 Final Submission","username":"akbenkov","description":"SDF 3D objects with metallic material, with postprocess animated depth of field, Gaussian blur and bloom effects.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["abertay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0, 0, 0);\n    vec4 col = texture(iChannel1, uv);\n    //color = col.rgb;\n    mat3 kernel = mat3(0.0);\n    float sigma = 17.0;\n    float sum = 0.0;\n    for (int x = 0; x < 11; ++x) {\n        for (int y = 0; y < 11; ++y) {\n            kernel[x][y] = (1.0 / (2.0*3.14159*pow(sigma, 2.0))) / exp((pow(float(x), 2.0) + pow(float(y), 2.0)) / (2.0*pow(sigma, 2.0)));\n            sum += kernel[x][y];\n        }\n    }\n\n//    kernel[0] = vec3(0.110654, 0.111339, 0.110654);\n   // kernel[1] = vec3(0.111339, 0.112027, 0.111339);\n //   kernel[2] = vec3(0.110654, 0.111339, 0.110654);\n  //  sum = 0.110654 + 0.111339 + 0.110654 + 0.111339 + 0.112027 + 0.111339 + 0.110654 + 0.111339 + 0.110654;\n\n    float threshold = 0.1;\n    for (int x = -5; x < 6; ++x) {\n        for (int y = -5; y < 6; ++y) {\n            vec4 col_n = texture(iChannel0, vec2(uv.x + (float(x)/float(iResolution.x)), uv.y + (float(y)/float(iResolution.y))));\n            float l = 0.21 * col_n.r + 0.72 * col_n.g + 0.07 * col_n.b;\n            //0.21 * col_n.r > threshold || 0.72 * col_n.g > threshold || 0.07 * col_n.b > threshold\n            if (l > threshold) {\n                color += (col_n.rgb)*kernel[5 + x][5 + y];\n            }\n\n\n        }\n    }\n    color = color * (1.0 / sum);\n    color += col.rgb;\n    fragColor.rgb = color;\n   \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float PI = 3.14159;\nconst float TWO_PI = 2.0 * 3.14159;\n\nconst int AO_SAMPLES = 256;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\nconst float SHADOW_HARDNESS = 20.0;\nconst float FOCAL_LENGTH = 16.0;\nconst float FOCAL_RANGE = 16.0;\n\nconst vec3 MAIN_LIGHT_DIR = normalize(vec3(1.0, 0.2, -0.4));\n//------------------------------------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat random1(vec2 p) {\n  return fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nfloat random1( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nfloat interpNoise3D1(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = mySmootherStep(llb, lrb, pFract.x);\n  float lerpXHB = mySmootherStep(ulb, urb, pFract.x);\n  float lerpXLF = mySmootherStep(llf, lrf, pFract.x);\n  float lerpXHF = mySmootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = mySmootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = mySmootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return mySmootherStep(lerpYB, lerpYF, pFract.z);\n}\n\n\nfloat fbm(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 32.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise3D1(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float amt) {\n    return vec3(cos(amt) * p.x - sin(amt) * p.y, sin(amt) * p.x + cos(amt) * p.y, p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 0.0,10.0), HALF_PI / 2.0);\n    \n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nvec3 smax( vec3 a, vec3 b, float k )\n{\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat infCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\n\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//helix spiral from comments of https://www.shadertoy.com/view/tlXSWM\nfloat spiral(vec3 q)\n{   \n\tfloat l = length(q.xz) - 2.2;\n\tfloat d = mod(atan(q.z,q.x)-q.y * 2.2, 4.0*HALF_PI) - 3.14159;\n\treturn length(vec2(l, d)) - 1.15;\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opCheapBend( in vec3 p )\n{\n    const float k = 0.6; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n//ultimately ended up using opTwist and opTwist2 (to have varying levels of curve/twist)\nvec3 opTwist( in vec3 p )\n{\n    const float k = 1.7; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz, p.y);\n    q = vec3(q.x, p.y, q.y );\n    //q = p;\n    return q;\n}\n\nvec3 opTwist2( in vec3 p )\n{\n    const float k = 1.9; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz, p.y);\n    q = vec3(q.x, p.y, q.y );\n    //q = p;\n    return q;\n}\n\nvec3 axTwist( in vec3 p )\n{\n    const float k = 0.9; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    \n    vec3 q = vec3(p.x*s + p.z*c - 0.2, k*p.y, p.z*s - p.x*c);\n    return q;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat coneTwist3( in vec3 p )\n{\n    //Translate(-X, 0, Z) * Rotate(Y, -45) * Twist(Y axis) * Rotate(Z, <45) * Basic Cone\n\n    vec3 q = p + vec3(-0.4, -0.9, 2.5);\n    q = rotateY(q, -PI * 0.14);\n    q = opTwist(q);// - vec3(0., 1., 0.);\n    q = rotateZ(q, PI * 0.17);\n    //return sdCone(q, vec3(0.0,-1.5,0.0), vec3(0.0,1.1,0.0), 0.25, 0.0 );\n    return infCone(q, vec2(0.173, 0.985)); \n    //return capsule(q, 2., 0.1);\n    //return sdCappedCylinder(q, 0.6, 0.2);\n}\n\nfloat coneTwist4( in vec3 p )\n{\n    //Translate(-X, 0, Z) * Rotate(Y, -45) * Twist(Y axis) * Rotate(Z, <45) * Basic Cone\n\n    //vec3 q = p + vec3(4., -6.6, 5.1);\n    vec3 q = p + vec3(-0.4, 0.9, -0.2);\n    \n    //was experimenting - this wqs originally meant to be another twisty cone but i liked the look\n    //of the resulting shape better\n    q = rotateX(q, PI * 0.013); \n    \n    q = rotateY(q, -PI * 0.95);\n    q = opTwist2(q);// - vec3(0., 1., 0.);\n    q = rotateZ(q, PI * 0.12);\n    \n    \n    \n    //return sdCone(q, vec3(0.0,-1.5,0.0), vec3(0.0,1.1,0.0), 0.25, 0.0 );\n    //return infCone(q, vec2(sin(PI * 0.04), cos(PI * 0.04))); \n    return sdCone(q, vec3(0.0,-1.5,0.0), vec3(0.0,6.1,0.0), 0.75, 0.0 );\n    //return capsule(q, 2., 0.1);\n    //return sdCappedCylinder(q, 0.6, 0.2);\n}\n\nfloat torusTwist(in vec3 p) \n{\n    vec3 q = p;\n    //q = axTwist(q) - vec3(0., 1., 0.);\n    q = opTwist(q);\n    return torus(q, vec2(0.5,0.2));\n}\n\n//adapted from snail shader: https://www.shadertoy.com/view/ld3Gz2\nfloat spiral2( in vec3 p ) \n{\n    const float sc = 1.0/3.0;\n    p -= vec3(0.05,0.12,-0.09);    \n\n    p *= sc;\n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n \n             \n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float np = (log(   r)/b-t)/(TWO_PI);\n    float nm = (log(0.11)/b-t)/(TWO_PI);\n    float n = min(np,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + TWO_PI*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n    \n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, torus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d/sc;\n}\n\n\n\n\n// Version that just returns the t value, for surface normal computation\nfloat sceneMap3D(vec3 pos)\n{\n    float t = coneTwist3(pos - vec3(4., 0., 4.));\n    t = min(t, coneTwist4(pos - vec3(0., 0., 4.)));\n    //float t = spiral2(pos);\n    //float t = torusTwist(pos - vec3(3., 0., 3.));\n    t = min(t, sphere(pos - vec3(0.1, 0., 0.1), 0.5, vec3(4.5, 0.89, 3.0)));\n    //t = min(t, sphere(pos, 2.0, vec3(-8.0, 0.0, 4.0)));\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    //t = min(t, sdCone(pos + vec3(-8.0, 0.0, 4.0), vec2(0.5, 0.86), 5.0));\n    //t = min(t, coneTwist(pos + vec3(0.0, 3.0, 0.0)));\n    return t;\n}\n\n// Version that returns t value and the ID of the object hit\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = coneTwist3(pos - vec3(4., 0., 4.));\n    //t = spiral2(pos);\n    //t = torusTwist(pos - vec3(3., 0., 3.));\n    float t2;\n    obj = 0; // 0 is first tentacle\n    if((t2 =  coneTwist4(pos - vec3(0., 0., 4.))) < t) {\n        t = t2;\n        obj = 1; // 1 is second tentacle/green thingy\n    }\n    if((t2 = sphere(pos - vec3(0.1, 0., 0.1), 0.5, vec3(4.5, 0.89, 3.0))) < t) {\n        t = t2;\n        obj = 2; // 2 is sphere\n    }\n\n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 3; // 3 is floor\n    }\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) { \n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n//250, 200, 158\nvec3 skyColor(vec3 dir) {\n    float t = smoothstep(0.0, 1.0, dir.y);\n    t = clamp(0.0, 1.0, t + fbm(dir / 2.0, 4.0) * 0.9);\n    t = fbm((dir / 8.0), 6.0); //+ abs(cos(iTime *0.2));\n    t = smoothstep(0.0, 1.0, t);\n    vec3 cloudGrad = mix(vec3(180.0, 109.0, 84.0) / 255.0, vec3(173.0, 193.0, 198.0) / 255.0, t);\n    vec3 cloudGrad2 = mix(vec3(250.0, 200.0, 158.0) / 255.0, vec3(173.0, 193.0, 198.0) / 255.0, t);\n    vec3 dawnGradient = mix(vec3(253.0, 96.0, 81.0) / 255.0, vec3(255.0, 229.0, 119.0) / 255.0, t);\n    vec3 duskGradient = mix(vec3(48.0, 24.0, 96.0) / 255.0, vec3(144.0, 96.0, 144.0) / 255.0, t);\n    //t = max(0.0, dot(dir, MAIN_LIGHT_DIR*abs(2.0*sin(0.3*iTime * HALF_PI / 4.0))));\n    //return mix(duskGradient, dawnGradient, t);\n    //vec3 col1 = mix(duskGradient, dawnGradient, t*abs(cos(0.1*iTime * HALF_PI / 4.0)));\n    //vec3 col2 = mix(cloudGrad, cloudGrad2, t);\n    //return mix(cloudGrad, cloudGrad2, t);\n    t = max(0.0, dot(dir, MAIN_LIGHT_DIR));\n    vec3 col1 = mix(duskGradient, dawnGradient, t);\n    vec3 col2 = mix(cloudGrad, cloudGrad2, t);\n    return mix(col2, col1, t);\n    //return max(col1 * abs(sin(iTime)), col2*abs(cos(iTime*20.0)));\n}\n\n\n\n//used specular reflection code from https://www.shadertoy.com/view/4l3GDM\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0:\n        // first tentacle\n        vec3 l = normalize(MAIN_LIGHT_DIR);\n        vec3 v = normalize(d);\n        float f = dot(l, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r = reflect(l, n);\n        return vec3(1.,1.,1.) * 0.83 * f * pow(max(0.0, dot(r, v)), 2.0) + vec3(0.955,0.775,0.24)*0.95;\n        break;\n        case 1:\n        // second tentacle\n        //return vec3(0.67, 1.0, 0.67);\n        vec3 l1 = normalize(MAIN_LIGHT_DIR);\n        vec3 v1 = normalize(d);\n        float f1 = dot(l1, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r1 = reflect(l1, n);\n        return vec3(1.,1.,1.) * 0.95 * f1 * pow(max(0.0, dot(r1, v1)), 8.0) + vec3(0.67, 1.0, 0.67)*0.95;\n        break;\n        case 2:\n        vec3 l2 = normalize(MAIN_LIGHT_DIR);\n        vec3 v2 = normalize(d);\n        float f2 = dot(l2, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r2 = reflect(l2, n);\n        return vec3(1.,1.,1.) * 0.95 * f2 * pow(max(0.0, dot(r2, v2)), 84.0) + vec3(1.,1.,1.)*0.75;\n        break;\n        case 3:\n        // Floor\n        //float t = floor(mod((sin(p.x) + sin(p.z)) * 0.5, 2.0));\n        //return mix(vec3(0.7, 0.4, 0.2), vec3(1.0), t);\n        vec3 l3 = normalize(MAIN_LIGHT_DIR);\n        vec3 v3 = normalize(d);\n        float f3 = dot(l3, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r3 = reflect(l3, n);\n        return vec3(1.,1.,1.) * 0.95 * f3 * pow(max(0.0, dot(r3, v3)), 4.0) + vec3(1.,1.,1.)*0.75;\n        break;\n        case -1:\n        // Background\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    if(t == -1.0) {\n        return Intersection(t, skyColor(dir), vec3(eye + 1000.0 * dir), -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n\n    float fresnel = 1.0 - max(0.0, dot(normalize(eye - isect), nor));\n    fresnel = 0.75 + 0.75 * fresnel;\n    \n    vec3 lightDir = rotateY(normalize(MAIN_LIGHT_DIR), sin(iTime * 0.2));\n    \n    vec3 sdfColor = mix(material, skyColor(reflect(dir, nor)) * material, fresnel) * shadow(lightDir, isect, 0.1);\n    \n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    // Stratified sampled 4x4 anti-aliasing\n    Intersection aaIsects[16];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.25) {\n        for(float j = 0.0; j < 1.0; j += 0.25) {\n            raycast(uv2 + (vec2(i, j) + random2(vec2(i, j))) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye);\n        }\n    }\n\n    /*\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 16; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.0625;\n    fragColor = vec4(avgColor, 1.0);\n    */\n    \n    \n    /*\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5) ;\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 16; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.0625;\n  \n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    float fogT = smoothstep(50.0, 100.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n    */\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH * cos(iTime)*0.3) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5) ;\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 16; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.0625;\n  \n    //fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    //float fogT = smoothstep(50.0, 100.0, distance(aaIsects[0].p, eye));\n    //fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n    fragColor = vec4(avgColor, dofZ);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    float sigma = 5.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n\n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n    \n    \n    \n    float vignette = smoothstep(3.95, 0.0, length((2.0 * uv) - vec2(1.0)));\n    fragColor = mix(vec4(0.0, 0.0, 0.1, 1.0), fragColor, vignette);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}