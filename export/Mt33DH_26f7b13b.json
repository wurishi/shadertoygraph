{"ver":"0.1","info":{"id":"Mt33DH","date":"1469278310","viewed":3994,"name":"rain water ripple","username":"zguerrero","description":"water ripple effect, you can click an drag to interact with the water.","likes":57,"published":1,"flags":48,"usePreview":0,"tags":["water","fluid","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Render final image, compute some lighting using normals generated in previews buffers\n\nfloat rotSpeed = 0.05;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 buff = texture(iChannel0, uv)*2.0-1.0;\n    float z = sqrt(1.0 - clamp(dot(vec2(buff.x,buff.y), vec2(buff.x,buff.y)),0.0, 1.0));\n    vec3 n = normalize(vec3(buff.x, buff.y, z));\n    \n    vec3 lightDir = vec3(sin(iTime*rotSpeed),cos(iTime*rotSpeed),0.0);\n    \n    float l = max(0.0, dot(n, lightDir));\n    float fresnel = 1.0 - dot(vec3(0.0,0.0,1.0), n);\n    vec4 refl = texture(iChannel2, reflect(n, lightDir));\n    \n    vec4 tex = texture(iChannel1, vec2(uv.x*(iResolution.x/iResolution.y), uv.y) + n.xy);\n    \n    fragColor = tex*0.5 + vec4((fresnel + l)*5.0)*refl + refl*0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Generate water ripple and normal\n\nfloat nsize = 5.0;\nfloat nstrenght = 1.0;\nfloat turbInfluence = 0.025;\nfloat rippleSpeed = 10.0;\nfloat rippleFreq = 20.0;\nfloat size = 0.8;\nfloat dropSpeed = 1.0;\nfloat dropSize = 0.7;\nfloat pi = 3.14159265359;\n\nfloat hash(float n)\n{\n   return fract(sin(dot(vec2(n,n) ,vec2(12.9898,78.233))) * 43758.5453);  \n} \n\nfloat brush(vec2 uv, float tile)\n{            \n    uv *= tile;\n    float mouseRipple;\n\n    if(iMouse.z > 0.5)\n    {     \n        vec2 mPos = iMouse.xy/iResolution.xy;\n        mPos.x *= iResolution.x/iResolution.y; \n\t\tmPos *= tile;\n        \n        float l = 1.0 - length(uv - mPos);\n        \n        mouseRipple = smoothstep(size, 1.0, l);\n    }\n    else\n    {\n    \tmouseRipple = 0.0; \n    }\n     \n    float dropRipple;\n    \n    const int iter = 10;\n    for (int i = 0; i < iter; i++)\n    {\n        float ifloat = float(i)+1.0;\n        float phase = (ifloat/float(iter))*dropSpeed;\n        float t = iTime*dropSpeed + phase;\n        float rX = hash(floor(t)+ifloat);\n\t\tfloat rY = hash(floor(t)*0.5+ifloat);\n        \n        vec2 rPos = vec2(rX,rY)*tile; \n        rPos.x *= iResolution.x/iResolution.y; \n        float rl = 1.0 - length(uv - rPos);\n        float fTime = fract(t);\n        float rRipple = sin(rl*rippleFreq + fTime*rippleSpeed)*0.5+0.5;\n        float rB = smoothstep((1.0 - fTime)*dropSize, 1.0, rl);\n        dropRipple += rB*rRipple*(1.0 - fTime);\n    }\n    \n\treturn dropRipple + mouseRipple;\n}\n    \nvec3 calculateNormals(vec2 uv, float tile)\n{\n    float offsetX = nsize/iResolution.x;\n    float offsetY = nsize/iResolution.y;\n\tvec2 ovX = vec2(0.0, offsetX);\n\tvec2 ovY = vec2(0.0, offsetY);\n    \n\tfloat X = (brush(uv - ovX.yx, tile) - brush(uv + ovX.yx, tile)) * nstrenght;\n    float Y = (brush(uv - ovY.xy, tile) - brush(uv + ovY.xy, tile)) * nstrenght;\n    float Z = brush(uv, tile);\n    \n\treturn vec3(X,Y,Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uvR = uv;\n    uvR.x *= ratio;\n    \n    vec4 tex = mix(vec4(0.0,0.0,1.0,0.0), texture(iChannel0, uv)*2.0-1.0, turbInfluence);\n    \n    \n    //Mask border to avoid artefacts\n    //Normaly would use repeat texture mode for this, but it seams not possible with buffer textures\n    float maskX = sin(uv.x*pi);\n    float maskY = sin(uv.y*pi);\n    float mask = smoothstep(0.3, 0.0, maskX*maskY);\n    \n    vec3 n = vec3(0.0,0.0,0.0);\n    \n    n = calculateNormals(uvR, 2.0); \n    \n    fragColor = mix(vec4(vec3(tex.x + n.x,tex.y + n.y,0.0)*0.5+0.5, n.z), vec4(0.5,0.5,1.0,0.0), mask);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Fluid Effect Buffer, use normals generated in bufferA to simulate some fake fluid diffusion effect\n\nfloat sampleDistance = 10.0;\nfloat diffusion = -1.0;\nfloat turbulence = 0.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    \n    vec4 baseColor = texture(iChannel0, uv)*2.0-1.0;\n    \n    vec2 sDist = sampleDistance/iResolution.xy;\n    \n    vec4 newColor = texture(iChannel1, uv);\n    vec2 turb = (texture(iChannel3, uv).xy*2.0-1.0)*turbulence;\n\n    vec4 newColor1 = texture(iChannel1, uv + vec2(1.0,0.0)*sDist);\n    vec4 newColor2 = texture(iChannel1, uv + vec2(-1.0,0.0)*sDist);\n    vec4 newColor3 = texture(iChannel1, uv + vec2(0.0,1.0)*sDist);\n    vec4 newColor4 = texture(iChannel1, uv + vec2(0.0,-1.0)*sDist);\n    \n    vec4 newColor5 = texture(iChannel1, uv + vec2(1.0,1.0)*sDist);\n    vec4 newColor6 = texture(iChannel1, uv + vec2(-1.0,1.0)*sDist);\n    vec4 newColor7 = texture(iChannel1, uv + vec2(1.0,-1.0)*sDist);\n    vec4 newColor8 = texture(iChannel1, uv + vec2(-1.0,-1.0)*sDist);\n     \n    vec2 t = newColor1.xy * 2.0 - 1.0;\n    t += newColor2.xy * 2.0 - 1.0;\n    t += newColor3.xy * 2.0 - 1.0;\n    t += newColor4.xy * 2.0 - 1.0;\n    \n    t += newColor5.xy * 2.0 - 1.0;\n    t += newColor6.xy * 2.0 - 1.0;\n    t += newColor7.xy * 2.0 - 1.0;\n    t += newColor8.xy * 2.0 - 1.0;\n    \n    t /= 8.0;\n\n    vec2 dir = vec2(t+turb)*diffusion*iTimeDelta;\n    \n    vec4 res = texture(iChannel1, uv + dir);\n    \n    baseColor = baseColor*0.5+0.5;\n    \n    if(iFrame < 10 || texture(iChannel2, vec2(32.5/256.0, 0.5) ).x > 0.5)\n    {\n    \tfragColor =  baseColor;\n    }\n    else\n    {\n    \tfragColor = mix(res, baseColor, baseColor.a);\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Turbulence Buffer\n//Just noise generated from sinus functions\n\nvec2 speed = vec2(5.0,-2.0);\nfloat v = 30.0;\nfloat dist = 0.3;\nfloat random1 = 1.0;\nfloat random2 = 2.0;\n\nfloat hash(float n)\n{\n   return fract(sin(dot(vec2(n,n) ,vec2(12.9898,78.233))) * 43758.5453);  \n}  \n\nvec2 turbulence(vec2 uv)\n{\n    vec2 turb;\n    turb.x = sin(uv.x);\n    turb.y = cos(uv.y);\n    \n    for(int i = 0; i < 10; i++)\n    {\n        float ifloat = 1.0 + float(i);\n        float ifloat1 = ifloat + random1;\n        float ifloat2 = ifloat + random2; \n        \n        float r1 = hash(ifloat1)*2.0-1.0;\n        float r2 = hash(ifloat2)*2.0-1.0;\n        \n        vec2 turb2;\n        turb2.x = sin(uv.x*(1.0 + r1*v) + turb.y*dist*ifloat + iTime*speed.x*r2);\n        turb2.y = cos(uv.y*(1.0 + r1*v) + turb.x*dist*ifloat + iTime*speed.y*r2);\n        \n        turb.x = mix(turb.x, turb2.x, 0.5);\n        turb.y = mix(turb.y, turb2.y, 0.5);\n    }\n    \n    return turb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= ratio;\n    \n    vec4 buff = texture(iChannel0, fragCoord.xy/iResolution.xy)*2.0-1.0;\n    vec2 turb = turbulence(uv+buff.xy*0.1)*0.5+0.5;\n    \n    fragColor = vec4(turb.x, turb.y, 0.0, 0.0);\n      \n}","name":"Buf C","description":"","type":"buffer"}]}