{"ver":"0.1","info":{"id":"MsscR4","date":"1487514607","viewed":286,"name":"[TDF] TokyoDemoFesTessellation","username":"soma_arc","description":"Tokyo Demo Fest 2017 Combined Graphics compo 2nd place.\nTDF tessellation (tiling) rendered with GLSL.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","tiling","tessellation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported.\n*/\n\n#define SAMPLE_NUM 100.\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst vec3 YELLOW = vec3(237, 221, 49) / 255.;\nconst vec3 BLUE = vec3(63, 249, 252) / 255.;\nconst vec3 PINK = vec3(255, 76, 223) / 255.;\nconst vec3 GREEN = vec3(64, 249, 83) / 255.;\nconst vec3 GRAY = vec3(0.9);\nconst vec3 WHITE = vec3(1);\nconst mat2 LINE_ROTATE = mat2(cos(3.1415926535/4.), -sin(3.1415926535/4.), \n                               sin(3.1415926535/4.), cos(3.1415926535/4.));\n\nvec3 col1, col2, col3, col4;\n\nvec3 stripe(const vec2 position){\n    vec2 p = LINE_ROTATE * position;\n    return (mod(floor(p.y / 1.), 3.) == 1.||\n       \t\tmod(floor(p.x / 1.), 3.) == 1.)\n        ? GRAY : WHITE;\n}\n\nvec3 T(const float gridSize, vec2 position){\n    vec3 backCol = stripe(position);\n    \n    position += vec2(gridSize * 5., 0);\n    const vec2 gridNum = vec2(2, 4);\n    vec2 rectSize = gridSize * gridNum;\n        \n    vec2 rectIndex = floor(position/ rectSize);\n    vec2 gridIndex = floor(mod(position, rectSize) / gridSize);\n\t\t\n\tbool revX = mod(rectIndex.x, 2.) == 1.;\n \tbool revY = mod(rectIndex.y, 2.) == 1.;\n   \n    if(revX){\n        col1 = YELLOW;\n    \tcol2 = PINK;\n    \tcol3 = GREEN;\n    \tcol4 = BLUE;\n    }else{\n        col1 = GREEN;\n    \tcol2 = BLUE;\n    \tcol3 = PINK;\n    \tcol4 = YELLOW;        \n    }\n    \n    if(revY){\n    \tvec3 tmp = col1;\n        col1 = col2;\n        col2 = tmp;\n        \n        tmp = col3;\n        col3 = col4;\n        col4 = tmp;\n    }\n\n    if(gridIndex.x == 1.){\n        return col1;\n    }else if(gridIndex.y == gridNum.y-1.){\n    \treturn revX ? col1 : col4;\n    }else if(gridIndex.y == 0.){\n        return revX ? col3 : col1;\n    }else{\n        return backCol;\n    }\n}\n\nvec3 D(float gridSize, vec2 position){\n    const vec2 gridNum = vec2(6, 4);\n    vec2 rectSize = gridSize * gridNum;\n        \n    vec2 rectIndex = floor(position/ rectSize);\n    vec2 gridIndex = floor(mod(position, rectSize) / gridSize);\n    vec2 gridPos = mod(mod(position, rectSize), gridSize);\n\t\t\n\n    bool revY = mod(rectIndex.y, 2.) == 1.;\n        \n    col1 = YELLOW;\n    col2 = PINK;\n    col3 = GREEN;\n    col4 = BLUE;\n    vec3 backCol = stripe(position);\n        \n    if(revY){\n        vec3 tmp = col1;\n        col1 = col2;\n        col2 = tmp;\n            \n        tmp = col3;\n        col3 = col4;\n        col4 = tmp;\n    }\n        \n    if(gridIndex.x == 0.){\n        return col1;\n    }else if(gridIndex.x == 1.){\n        return (gridIndex.y == 0. ||\n           \t\tgridIndex.y == 3.)?\n            col1 : backCol;\n    }else if(gridIndex.x == 2.){\n        if(gridIndex.y == 0.){\n            return (gridPos.y > gridPos.x) ? col1 : col3;\n        }else if(gridIndex.y == 1. &&\n                 gridPos.y < gridPos.x){\n            return col1;\n        }else if(gridIndex.y == 2. &&\n                 gridPos.y > gridSize -gridPos.x){\n            return col1;\n        }else if(gridIndex.y == 3.){\n            return (gridPos.y > gridSize -gridPos.x)?\n               \t\t col4 :col1;\n        }else{\n        \treturn backCol;\n        }\n    }else if(gridIndex.x == 3.){\n        if(gridIndex.y == 0.){\n            return (gridPos.y > gridPos.x)?\n                col3: backCol;\n        }else if(gridIndex.y == 1.){\n            return (gridPos.y < gridPos.x) ?\n                col3 : col1;\n        }else if(gridIndex.y == 2.){\n            return (gridPos.y > gridSize -gridPos.x)?\n                col4 : col1;\n        }else if(gridIndex.y == 3.){\n            return (gridPos.y < gridSize -gridPos.x)?\n                col4 : backCol;\n        }else{\n        \treturn backCol;\n        }\n    }else if(gridIndex.x == 4.){\n        if(gridIndex.y == 1.)\n            return col3;\n        else if(gridIndex.y == 2.)\n            return col4;\n        else{\n        \treturn backCol;\n        }\n    }else if(gridIndex.x == 5.){\n        return (gridIndex.y <= 1.) ?\n\t            col3 : col4;\n    }else{\n        return backCol;\n    }\n}\n\nvec3 F(const float gridSize, vec2 position){\n    vec3 backCol = stripe(position);\n\n    position += vec2(gridSize * 0., gridSize * 5.);\n    const vec2 gridNum = vec2(4, 5);\n    vec2 rectSize = gridSize * gridNum;\n        \n    vec2 rectIndex = floor(position/ rectSize);\n    vec2 gridIndex = floor(mod(position, rectSize) / gridSize);\n\t\t\n    bool rev = mod(rectIndex.x + rectIndex.y, 2.) == 1.;\n    bool revY = mod(rectIndex.y, 2.) == 1.;\n\tbool revX = mod(rectIndex.x, 2.) == 1.;\n\n    \n    col1 = GREEN;\n    col2 = BLUE;\n    \n    if(revX){\n    \tcol1 = PINK;\n        col2 = YELLOW;\n    }\n    \n    if(revY){\n        vec3 tmp = col1;\n        col1 = col2;\n        col2 = tmp;\n    }\n        \n    if(gridIndex.x == 0.){\n        return col1;\n    }else if(gridIndex.x == 3.){\n        return col2;\n    }else if(gridIndex.y == 0.){\n        return rev ? col2 : col1;\n    }else if(gridIndex.y == 4.){\n        return rev ? col1 : col2;\n    }else if(gridIndex.y == 2.){\n        if(gridIndex.x == 1.)\n            return col1;\n        else if(gridIndex.x == 2.)\n            return col2;\n    }else{\n        return backCol;\n    }\n}\n\nvec3 T2D(float gridSize, vec2 position){\n    vec2 gridIndex = floor(mod(position, gridSize * vec2(2, 4)) / gridSize);\n    return (gridIndex.y == 0.)?\n        T(gridSize, position):stripe(position);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    vec3 sum = vec3(0);\n    const float gridSize = 4.;\n\tfloat gridNum = floor(ratio * 96.5 * 2. / gridSize);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        \n        position = position * 96.5;\n        position.x += 10.;\n        vec2 gridIndex = floor(position / gridSize) + gridNum / 2.;\n       \t\n        if(gridIndex.x < 14.){\n        \tsum += T(gridSize, position); \n        }else if(gridIndex.x == 14.){\n            sum += T2D(gridSize, position);\n        }else if(gridIndex.x < 14. + 19.){\n        \tsum += D(gridSize, position);\n        }else{\n            sum += F(gridSize, position);\n        }\n        \n    }\n    fragColor = vec4((sum/SAMPLE_NUM), 1.);\n}","name":"Image","description":"","type":"image"}]}