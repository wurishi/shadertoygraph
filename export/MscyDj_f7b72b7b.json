{"ver":"0.1","info":{"id":"MscyDj","date":"1520233007","viewed":107,"name":"raymarch 06plane","username":"yxo","description":"this is from youtube video about raymarching\n\"WebGL Paris 2015 - Raymarching en Live Coding\"","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 pos, float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c) * pos;\n}\n\nfloat plane(vec3 pos){\n    return pos.y+sin(pos.z*.25+iTime)*cos(pos.x*.25+iTime*2.)*2.;\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size){\n    return length(max(abs(pos)-size, .0));\n}\n\nfloat roundedBox(vec3 pos, vec3 size, float radius){\n    //pos.x += sin(iTime)*4.;\n    return length(max(abs(pos)-size, .0)) - radius;\n}\n\nfloat map(vec3 pos){\n    float planeDist = plane(pos);\n    \n    pos.xy = rotate(pos.xy, sin(iTime)*pos.z*0.02);\n    //pos.yz = rotate(pos.yz, sin(iTime)*pos.x*0.01);\n    //pos.x = abs(pos.x);\n    pos = mod(pos + 10., 20.) - 10.;\n    \n    pos.xy = rotate(pos.xy, iTime);\n    pos.xz = rotate(pos.xz, iTime*0.7);\n    \n    return min(planeDist, roundedBox(pos, vec3(2.), 3.));    \n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(.01, .0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n        ));\n}\n\nvec3 albedo(vec3 pos){\n    pos += .5;\n    \n    //return fract(pos.x) * fract(pos.y) * vec3(1.);\n    \n    float f = smoothstep(.34, .35, fract((pos.x*.3)+sin(pos.z)*.4))*fract((pos.z*.8)+cos(pos.x*.3)*.5);\n    \n    return f * vec3(1.);\n}\n\nvec3 lightDirection = normalize(vec3(1.,.6,-1.));\n\nfloat diffuse(vec3 normal){\n    return max(dot(normal, lightDirection), .0);\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    return pow(max(dot(h, normal), .0), 100.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime;\n    vec3 camAnim = vec3(sin(time*.5)*2., cos(time*.4)*1.+4.,2.);\n    vec3 pos = vec3(.0, 5., -31.);\n    pos += camAnim;\n    \n    vec3 dir = normalize(vec3(uv, 1.));\n    //dir.xz *= mat2(cos(time), -sin(time), sin(time), cos(time));\n    \n    vec3 col = vec3(.0);\n    \n    for(int i; i<32; ++i){\n        float d = map(pos);\n        if (d<.01){\n            \n            vec3 norm = computeNormal(pos);\n            float diff = diffuse(norm);\n            float spec = specular(norm, dir);\n            \n            float lightDist = sphere(pos, 20.);\n            vec3 lightCol = vec3(.2,.4,.9);\n            \n            col = (diff+spec) * 20./(lightDist*lightDist)*lightCol*albedo(pos);\n            //col = (diff+spec) * lightCol*albedo(pos);\n        }\n        pos += d*dir;\n        \n    }\n    \n    //vec3 norm = computeNormal(pos);\n    //fragColor = vec4(norm,1.0);\n    //float c = diffuse(computeNormal(pos));\n    //float c = specular(computeNormal(pos), dir);\n    \n    float fogFactor = exp(-pos.z * .03);\n    col = mix(vec3(0.8,0.9,1.0), col, fogFactor);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}