{"ver":"0.1","info":{"id":"4cXBRN","date":"1723484719","viewed":29,"name":"a crystal thing","username":"BigAssLettuce","description":"a","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAXITER 64\nvec3 pc[4] = vec3[](\nvec3(0.5, 0.5, 0.5),\nvec3(0.5, 0.5, 0.5),\nvec3(1., 1., 1.0),\nvec3(0, 0.33, 0.67)\n);\nconst vec3 BoxSize = vec3(0.5,0.5,0.5);\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 randomUnitVector(int seed) {\n    // Convert seed to a floating-point value\n    float floatSeed = float(seed);\n\n    // Generate two random numbers using the seed\n    float theta = fract(sin(floatSeed) * 43758.5453123) * 2.0 * 3.141592653589793;\n    float z = fract(cos(floatSeed) * 23421.631234) * 2.0 - 1.0;\n\n    // Calculate the radius based on z to ensure a unit vector\n    float r = sqrt(1.0 - z * z);\n\n    // Convert spherical coordinates to Cartesian coordinates\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n\n    return vec3(x, y, z);\n}\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    float oneMinusCos = 1.0 - cosAngle;\n\n    return mat3(\n        cosAngle + axis.x * axis.x * oneMinusCos,\n        axis.x * axis.y * oneMinusCos - axis.z * sinAngle,\n        axis.x * axis.z * oneMinusCos + axis.y * sinAngle,\n\n        axis.y * axis.x * oneMinusCos + axis.z * sinAngle,\n        cosAngle + axis.y * axis.y * oneMinusCos,\n        axis.y * axis.z * oneMinusCos - axis.x * sinAngle,\n\n        axis.z * axis.x * oneMinusCos - axis.y * sinAngle,\n        axis.z * axis.y * oneMinusCos + axis.x * sinAngle,\n        cosAngle + axis.z * axis.z * oneMinusCos\n    );\n}\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\nfloat sdfWireframe(float d, float thickness) {\n    return smoothstep(-thickness, thickness, d);\n}\nfloat interpolate(float a, float b, float tolerance) {\n    // Calculate the absolute difference between the two values\n    float diff = abs(a - b);\n    \n    // Use smoothstep to interpolate between 0 and 1 based on the difference\n    // The tolerance defines the range where interpolation transitions from 0 to 1\n    return smoothstep(0.0, tolerance, diff);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat sdBox( vec3 p, vec3 b,vec3 t )\n{\n  vec3 q = abs(p-t) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#define CubeN 5\nfloat SceneDist(vec3 p,out vec3 fColor) {\n\n\nvec3 finalColor = vec3(0);\nfloat d = 0.;\nbool WithinWire = true;\nfor (int i = 0; i < CubeN; i++) {\n    vec3 randAngle = randomUnitVector(i);\n    mat3 rot = rotationMatrix(randAngle,iTime*0.25+0.142*float(i));\n    //rot*=rot;\n    vec3 rp = rot*p;\n    float di = sdBox(rp,BoxSize,vec3(0));\n    \n    vec3 color = palette(float(i)/float(CubeN),pc[0],pc[1],pc[2],pc[3]);\n    if (d == 0.)\n    {\n    d=di;\n    finalColor = color;\n    }\n    else {\n    float blendFactor = smoothstep(-0.0001, 0.0001, di - d);\n    finalColor = mix(finalColor,\n    color\n    ,blendFactor);\n    d=max(d,di);\n    }\n    \n}\n    fColor = finalColor;\n    return d;\n}\nvec3 RayGen(vec3 CamPos,vec3 LookAt, vec3 upVector, float fov,vec2 NDC) {\n\nfloat fovRadians = radians(fov);\nvec3 forward = normalize(LookAt - CamPos);\n    vec3 right = normalize(cross(forward, upVector));\n    vec3 up = cross(right, forward);\n    \n    vec3 rayDirection = normalize(forward + NDC.x * right * tan(fovRadians * 0.5) + NDC.y * up * tan(fovRadians * 0.5));\nreturn rayDirection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy *2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    const float CameraY = 1.;\n    const float CameraDistance = 1.5;\n    vec2 MouseProgress = iMouse.xy/float(iResolution.xy);\n      vec3 CameraPos = vec3(cos(MouseProgress.x*2.*PI)*CameraDistance,\n      cos(MouseProgress.y*PI*2.)*CameraY,\n      sin(MouseProgress.x*2.*PI)*CameraDistance);\n    \n    vec3 rayDir = RayGen(CameraPos,vec3(0),vec3(0,1,0),70.,uv);\n    \n    float rayDist = 0.;\n    vec3 rayOrigin = CameraPos;\n    // Output to screen\n    fragColor = vec4(vec3(0.),1.0);\n    \n    float closestEver = 10000000.;\n    bool hit = false;\n    for (int i = 0; i < MAXITER;i++) {\n    vec3 color;\n    float sDist = SceneDist(rayOrigin + rayDir*rayDist,color);\n    closestEver = min(closestEver,sDist);\n    if (sDist <= 0.001) \n    {\n    fragColor = vec4(color,1.);\n    hit = true;\n    break;\n    }\n    rayDist += sDist;\n    }\n    if (!hit){\n    float glow = 1.-closestEver;\n    vec3 pc2[4] = vec3[](\nvec3(0.5, 0.5, 0.5),\nvec3(0.5, 0.5, 0.5),\nvec3(2., 1., 0.0),\nvec3(0.5, 0.2, 0.25)\n);\n    float fGlow = glow;\n    for (int i = 0; i < 2;i++){\n        fGlow *= fGlow;\n        }\n    vec3 color = palette(fract(iTime*0.25),pc2[0],pc2[1],pc2[2],pc2[3]);\n    color = mix(color,vec3(1.),min(1.,fGlow*fGlow*fGlow));\n    fragColor = vec4(color*fGlow,1);\n\n    }\n}\n","name":"Image","description":"","type":"image"}]}