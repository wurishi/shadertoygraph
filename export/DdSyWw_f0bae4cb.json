{"ver":"0.1","info":{"id":"DdSyWw","date":"1687744599","viewed":43,"name":"Scrolling Growing Circles","username":"BrandonS","description":"Smooth scrolling circles that grow and shrink in rings.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"ddjyRz","parentname":"Art from chaos"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nprecision highp float;\n#define PI 3.141592654\n\n//     \\[(\\d+\\.\\d+)\\s+(\\d+\\.\\d+)\\s+(\\d+\\.\\d+)\\] - Regex expression to replace gradient format\n//     vec3($1, $2, $3)    -- Replace with\n// ^ this is outdated, use the script in the shaders repo on github.\nfloat remap(float x, float min1,float min2, float max1, float max2){\n    float remapped = min2 + (x - min1) * (max2 - min2) / (max1 - min1);\n    return remapped;\n}\n//float \n// cosine based palette, 4 vec3 params\n/*\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*(t*0.1)+d) );\n}\n*/\n\nvec3 palette( in float t, in vec3[4] colors )\n{\n    float speed = 0.4;\n    return colors[0] + colors[1]*cos( 6.28318*(colors[2]*(t*speed)+colors[3]) );\n}\n\nvec3[] g1 = vec3[](\n    vec3(0.469, 0.823, 0.948), \n    vec3(-0.962, 0.928, 0.849), \n    vec3(-1.232, -3.142, -0.072), \n    vec3(3.549, 2.004, 3.243)\n);\n\nvec3[] g2 = vec3[](\n    vec3(0.469, 0.823, 0.326), \n    vec3(0.550, 0.928, 0.849), \n    vec3(1.535, 0.850, 0.026), \n    vec3(3.549, 2.004, 3.243)\n);\nvec3[] blackWhite = vec3[](\nvec3(0.500, 0.500, 0.500),\n         vec3(0.500, 0.500, 0.500),\n         vec3(1.000, 1.000, 1.000),\n         vec3(-0.000, 0.000, 0.000)\n);\nvec3[] blueRed = vec3[](\nvec3(0.500, 0.500, 0.500),\n         vec3(1.000, 1.000, 1.000),\n         vec3(1.000, 1.000, 1.000),\n         vec3(-0.500, 0.000, 0.000)\n);\nvec3[] blueMagentaOrange = vec3[](\nvec3(0.938, 0.328, 0.718),\n         vec3(0.659, 0.438, 0.328),\n         vec3(0.388, 0.388, 0.296),\n         vec3(2.538, 2.478, 0.168)\n\n);\n\nfloat noise1d(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = ((fragCoord / iResolution.xy)*2.0-1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 uv0 = uv;\n    \n    //TODO: Show one fract uv*1, then wait a bit and show 2, then 4, then 8, and maybe do something cool\n    // to hang out in 8 for awhile then pong around from there with a bias toward decreasing consistently\n    // rather than rapidly jumping to giant numbers\n    \n    uv.x = fract(uv.x+abs(uv.y-iTime/2.))-0.5;\n    uv.y = fract(uv.y*2.) -0.5;\n    //            *step(1.,mod(iTime,4.))\n    float d = length(uv);\n    \n    float circle = 0.;\n    //circle = sin(d*9.0 * (((cos((((iTime+31.5)*0.1)))*10.)/2.) + 5.2) )/9.0;\n    circle = sin(d*9.0 * (((cos((((iTime+31.5/2.)*0.2))) *10.)/2.) + 5.2) )/9.0; \n    \n    \n    \n    circle = abs(circle);\n    circle = smoothstep(0.0,0.05,circle);\n\n    \n    vec3 color = palette(uv0.x+iTime, blueMagentaOrange);\n    //vec3 color = palette(uv0.x+iTime, blueRed);\n    \n    \n    color *= 0.4/circle;\n    fragColor =  vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}