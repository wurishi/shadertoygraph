{"ver":"0.1","info":{"id":"st3XWj","date":"1648807076","viewed":70,"name":"cortexA233's first SDF","username":"cortexA233","description":"SDF ray tracing training.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float epsilon = 0.0001;\nconst float maxRayDistance = 10.;\nconst int maxStep = 222;\n\n\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nvec3 BackGround(){\n    return vec3(0.3);\n}\n\n\nvec2 SDFBall(vec3 rayPos, vec3 ballPos, float ID){\n    float radius = 0.5;\n    \n    float distanceRayToBallSurface = length(rayPos - ballPos) - radius;   \n    \n    vec3 p = rayPos - ballPos;\n    vec3 d = abs(p) - 0.2;\n    return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), ID);\n    \n    return vec2(distanceRayToBallSurface, ID);\n}\n\n\nvec2 CloserItem(vec2 item1, vec2 item2){\n    return item1.x < item2.x ? item1 : item2;\n}\n\n\nvec2 MapWorld(vec3 curRayPos){\n    vec2 ball_1 = SDFBall(curRayPos, vec3(-0.7, 0, 0), 1.);\n    vec2 ball_2 = SDFBall(curRayPos, vec3(0.4, 0.2, 0.5), 2.);\n    return CloserItem(ball_1, ball_2);\n}\n\n\nvec2 CheckRayHit(in vec3 eyePos, in vec3 rayDir){\n    float distance = 1.;\n    float currentRayDistance = 0.;\n    float finalRayLength = -1.;\n    float finalID = -1.;\n\n    for(int i = 0; i < maxStep; ++i){\n        if(distance < epsilon) break;\n        if(currentRayDistance > maxRayDistance) break;\n\n        vec3 curRayPos = eyePos + rayDir * currentRayDistance;\n        \n        vec2 mapResult = MapWorld(curRayPos);\n        float mapDistance = mapResult.x;\n        float mapID = mapResult.y;\n\n        finalID = mapID;\n        \n        currentRayDistance += mapDistance;\n    }\n\n    if(currentRayDistance <= maxRayDistance){\n        finalRayLength = currentRayDistance;\n    }else{\n        finalRayLength = -1.;\n        finalID = -1.;\n    }\n\n    return vec2(finalRayLength, finalID);\n}\n\nvec3 GetSurfaceNormal(vec3 pos){\n    vec3 changeX = vec3(0.001, 0., 0.);\n    vec3 changeY = vec3(0., 0.001, 0.);\n    vec3 changeZ = vec3(0., 0., 0.001);\n\n    float normalX = MapWorld(pos + changeX).x - MapWorld(pos - changeX).x;\n    float normalY = MapWorld(pos + changeY).x - MapWorld(pos - changeY).x;\n    float normalZ = MapWorld(pos + changeZ).x - MapWorld(pos - changeZ).x;\n\n    return normalize(vec3(normalX, normalY, normalZ));\n}\n\n\nvec3 BallColor(vec3 hitPos, vec3 normal, vec3 color){\n    vec3 lightPos = vec3(1., 4., 1.);\n    vec3 lightDir = hitPos - lightPos;\n\n    float diff = max(0., dot(lightDir, normal));\n\n    vec3 resultColor = color * diff + vec3(0.6549, 0.8, 0.0118);\n    return resultColor;\n}\n\n\nvec3 WorldColor(vec2 rayHitInfo, vec3 eyePos, vec3 rayDir){\n    vec3 resultColor = BackGround();\n    if(rayHitInfo.y < 0.){\n        return resultColor;\n    }\n    vec3 hitPos = eyePos + rayHitInfo.x * rayDir;\n    vec3 normal = GetSurfaceNormal(hitPos);\n\n    if(rayHitInfo.y == 1. || rayHitInfo.y == 2.){\n        resultColor = BallColor(hitPos, normal, vec3(float(rayHitInfo.y), 1, 0));\n    }\n    return resultColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    vec3 eyePos = vec3(0. + sin(iTime), 0. + sin(iTime), 2. + sin(iTime));\n    vec3 lookAtPos = vec3(0);\n\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix(eyePos, lookAtPos, 0.); \n\n    vec3 rayComeOutDir = normalize(eyeTransformationMatrix * vec3(p.xy, 2.));\n\n    vec2 rayHitInfo = CheckRayHit(eyePos, rayComeOutDir);\n\n    vec3 color = WorldColor(rayHitInfo, eyePos, rayComeOutDir);\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}