{"ver":"0.1","info":{"id":"WtS3DG","date":"1647489997","viewed":944,"name":"SPPM Demo","username":"larrylan","description":"A porting from Hachisuka's demo of Stochastic Progressive Photon Mapping without acceleration structures.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["montecarlo","spectral","progressive","photon","photonmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tconst float gamma = 2.2;\n\tconst float exposure = 1.0;\n\n\tfloat TotalPhotonNum = float(PhotonNum) * float(iFrame + 1);\n\tvec3 QueryFlux = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n\tQueryFlux /= InitialRadius * InitialRadius * 3.141592 * TotalPhotonNum;\n\tfragColor = vec4(pow(vec3(1.0) - exp(-QueryFlux * exposure), vec3(1.0 / gamma)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const bool FullSpectrum = true;\nconst bool DOF = true;\nconst bool MotionBlur = true;\nconst bool Glossy = true;\n\nconst float FocalLength = 210.0;\nconst float ApertureSize = 7.0;\nconst float MotionSize = 10.0;\nconst float Glossiness = 0.5;\n\nconst float InitialRadius = 0.618374;\nconst float Alpha = 0.7;\n\nconst int MaxPathLength = 4;\nconst int MaxRngUsage = 12;\nconst int PhotonNum = 8192;\n\n\n\nfloat Halton_sequence(const int base, const int index)\n{\n\tint i = index;\n\tfloat result = 0.0;\n\tfloat inv_base = 1.0 / float(base);\n\tfloat scale = 1.0;\n\twhile (i > 0)\n\t{\n\t\tscale *= inv_base;\n\t\tresult += float(i % base) * scale;\n\t\ti = i / base;\n\t}\n\treturn result;\n}\n\n\n\n// WCMYRGBXYZ using Gaussians fitting\nconst float White = 1.0;\n\nconst vec4 Cyan0 = vec4(0.0, 0.424537460743542, 0.0866503554583976, 0.560757618949125);\nconst vec4 Cyan1 = vec4(0.0, 0.246400896854156, 0.0795161416808855, 0.216116362841135);\nconst vec4 Cyan2 = vec4(1.0, 0.067666394964209, 0.2698588575757230, 0.890716186803857);\n\nconst vec4 Magenta0 = vec4(0.0, 0.092393363155047, -0.030670840714796, 0.425200104381996);\nconst vec4 Magenta1 = vec4(0.0, 0.174734179228986, 0.0690508593874629, 0.983929883263911);\nconst vec4 Magenta2 = vec4(1.0, 0.613995338323662, 0.0794711389383399, 1.003105061865860);\n\nconst vec4 Yellow0 = vec4(0.0, 0.369673263739623, -0.071355497310236, 0.503666150930812);\nconst vec4 Yellow1 = vec4(0.0, 0.558410218684172,  0.151858057162275, 0.878349029651678);\nconst vec4 Yellow2 = vec4(1.0, 0.587945864428471,  0.101005427723483, 0.109960421083442);\n\nconst vec4 Red0 = vec4(0.0, 0.574803873802654, 0.0349961565910619, 0.670478585641923);\nconst vec4 Red1 = vec4(0.0, 0.042753652345675, -0.076576978780864, 0.070884754752968);\nconst vec4 Red2 = vec4(1.0, 0.669048230499984, 0.0587027396330119, 0.957999219817480);\n\nconst vec4 Green0 = vec4(0.0, 0.305242141596798,  0.0337596436768638, 0.424248514020785);\nconst vec4 Green1 = vec4(0.0, 0.476992126451749, -0.0541085157876399, 0.815789194891182);\nconst vec4 Green2 = vec4(1.0, 0.365833471799225, -0.0583175076362409, 0.792406519710127);\n\nconst vec4 Blue0 = vec4(0.0, 0.144760614900738, 0.0848347582999023, 0.993361426917213);\nconst vec4 Blue1 = vec4(0.0, 0.600421286424602, -0.060880809655396, 0.0744873773945442);\nconst vec4 Blue2 = vec4(1.0, 0.231505955455338, -0.029894351908322, 0.339396172335299);\n\n\n\n// CIE response curves using Gaussians fitting\nconst vec4 CIEX0 = vec4(0.26714125, 0.173056848724526, -0.0517890668554628, 0.369341509681465);\nconst vec4 CIEX1 = vec4(0.0, 0.510852785928701, 0.636521548441552, -0.324530476950362);\nconst vec4 CIEX2 = vec4(1.0622, 0.547302197035226, 0.0899535691555178, 1.10399973088081);\n\nconst vec4 CIEY0 = vec4(0.2671425, 0.86798560108836, 0.150307921271593, -0.354744089805774);\nconst vec4 CIEY1 = vec4(0, 0.10539332389757, 0.168752691961971, -0.289650515359526);\nconst vec4 CIEY2 = vec4(1.0002, 0.445956775505726, 0.0920541376951253, 0.814888040084084);\n\nconst vec4 CIEZ0 = vec4(0.26714375, 0.174251742295476, -0.0569218355789753, 1.72408897831517);\nconst vec4 CIEZ1 = vec4(0.0, 0.0542544622978704, 0.0457454482464726, -0.442679263574661);\nconst vec4 CIEZ2 = vec4(1.7826, 0.711309229610584, 0.285040831286585, -0.407629686738774);\n\n\n\nfloat Gaussian(const float x0, const float s, const float w, const float x)\n{\n\treturn w * exp( -(x - x0) * (x - x0) / (2.0 * s * s + 1.0e-20) );\n}\n\n\n\nfloat GaussianMixture(const float lambda, const vec4 Data0, const vec4 Data1, const vec4 Data2)\n{\n\tfloat t = (lambda - 0.380) / (0.780 - 0.380);\n\tfloat g0 = Gaussian(Data0.y, Data0.z, Data0.w, t);\n\tfloat g1 = Gaussian(Data1.y, Data1.z, Data1.w, t);\n\tfloat g2 = Gaussian(Data2.y, Data2.z, Data2.w, t);\n\n\treturn min(max(g0 + g1 + g2 + Data0.x, Data1.x), Data2.x);\n}\n\n\n\nfloat RGB2Spectrum(const vec3 rgb, const float lambda)\n{\n\tfloat r2g = rgb.r - rgb.g;\n\tfloat g2b = rgb.g - rgb.b;\n\tfloat b2r = rgb.b - rgb.r;\n\n\tif ((rgb.r <= rgb.g) && (rgb.r <= rgb.b))\n\t{\n\t\tif (rgb.g <= rgb.b)\n\t\t{\n\t\t\treturn rgb.r * White - (r2g * GaussianMixture(lambda, Cyan0, Cyan1, Cyan2) + g2b * GaussianMixture(lambda, Blue0, Blue1, Blue2));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn rgb.r * White + (b2r * GaussianMixture(lambda, Cyan0, Cyan1, Cyan2) + g2b * GaussianMixture(lambda, Green0, Green1, Green2));\n\t\t}\n\t}\n\telse if ((rgb.g <= rgb.r) && (rgb.g <= rgb.b))\n\t{\n\t\tif (rgb.b <= rgb.r)\n\t\t{\n\t\t\treturn rgb.g * White - (g2b * GaussianMixture(lambda, Magenta0, Magenta1, Magenta2) + b2r * GaussianMixture(lambda, Red0, Red1, Red2));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn rgb.g * White + (r2g * GaussianMixture(lambda, Magenta0, Magenta1, Magenta2) + b2r * GaussianMixture(lambda, Blue0, Blue1, Blue2));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (rgb.r <= rgb.g)\n\t\t{\n\t\t\treturn rgb.b * White - (b2r * GaussianMixture(lambda, Yellow0, Yellow1, Yellow2) + r2g * GaussianMixture(lambda, Green0, Green1, Green2));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn rgb.b * White + (g2b * GaussianMixture(lambda, Yellow0, Yellow1, Yellow2) + r2g *GaussianMixture(lambda, Red0, Red1, Red2));\n\t\t}\n\t}\n}\n\n\n\nvec3 Spectrum2RGB(const float lambda)\n{\n\tfloat x = GaussianMixture(lambda, CIEX0, CIEX1, CIEX2);\n\tfloat y = GaussianMixture(lambda, CIEY0, CIEY1, CIEY2);\n\tfloat z = GaussianMixture(lambda, CIEZ0, CIEZ1, CIEZ2);\n\n\t// E to D65\n\t// 0.26713798 is for mapping spectrum 1.0 into rgb (1.0, 1.0, 1.0)\n\tx = x * 0.9504700 / 0.26713798;\n\ty = y * 1.0000000 / 0.26713798;\n\tz = z * 1.0888300 / 0.26713798;\n\n\t// sRGB (D65)\n\tvec3 rgb;\n\trgb.r = (x * ( 3.2404542) + y * (-1.5371385) + z * (-0.4985314));\n\trgb.g = (x * (-0.9692660) + y * ( 1.8760108) + z * ( 0.0415560));\n\trgb.b = (x * ( 0.0556434) + y * (-0.2040259) + z * ( 1.0572252));\n\n\treturn rgb;\n}\n\n\n\nfloat GPURnd(inout vec4 n)\n{\n\t// from http://gpgpu.org/forums/viewtopic.php?t=2591&sid=17051481b9f78fb49fba5b98a5e0f1f3\n\t// https://en.wikipedia.org/wiki/Lehmer_random_number_generator\n\t// let q_i = m_i / a_i and r_i = m_i % a_i, where m_i should be prime and a_i must be a primitve root of m_i\n\t// due to the precision of float, m < 2^22 and a_i â‰ˆ m^0.5 are suggested\n\tconst vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\n\tconst vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\n\tconst vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\n\tconst vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\n\n\t// the following lines could simply be \"n = mod(n * a, m);\", if there's no precision loss\n\tn = a * mod(n, q) - floor(n / q) * r;\n\tn += step(vec4(0.0), -n) * m;\n\n\treturn fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\n}\n\n\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\nstruct Sphere\n{\n\tvec3 c;\n\tfloat r;\n\tvec3 col;\n\tint f;\n};\nstruct Intersection\n{\n\tfloat t;\n\tSphere sphere;\n};\n\n\n\nvec3 tangent(const vec3 n)\n{\n\tvec3 t = n;\n\tvec3 a = abs(n);\n\n\tif ((a.x < a.y) && (a.x < a.z))\n\t{\n\t\tt.x = 1.0;\n\t}\n\telse if (a.y < a.z)\n\t{\n\t\tt.y = 1.0;\n\t}\n\telse\n\t{\n\t\tt.z = 1.0;\n\t}\n\n\treturn normalize(cross(t, n));\n}\n\n\n\nvec3 along(const vec3 v, const vec3 n)\n{\n\tvec3 t = tangent(n);\n\tvec3 s = cross(t, n);\n\n\treturn (v.x * t + v.y * n + v.z * s);\n}\n\n\n\nvec3 glossy_normal(const vec3 n, const float g, inout vec4 rndv)\n{\n\tfloat rnd1 = GPURnd(rndv);\n\tfloat rnd2 = GPURnd(rndv);\n\n\tfloat temp1 = 2.0 * 3.141592 * rnd1;\n\tfloat temp2 = sqrt(1.0 - pow(rnd2, 2.0 / (g + 1.0)));\n\tvec3 v = vec3(sin(temp1) * temp2, pow(rnd2, 1.0 / (g + 1.0)), cos(temp1) * temp2);\n\n\treturn normalize(along(v, n));\n}\n\n\n\nvoid sphere_intersect(const Sphere sphere, const Ray ray, inout Intersection isect)\n{\n\tvec3 rs = ray.org - sphere.c;\n\tfloat B = dot(rs, ray.dir);\n\tfloat C = dot(rs, rs) - (sphere.r * sphere.r);\n\tfloat D = B * B - C;\n\n\tif (D > 0.0)\n\t{\n\t\tD = sqrt(D);\n\t\tfloat t0 = -B - D;\n\t\tfloat t1 = -B + D;\n\t\tif ( (t0 > 0.0) && (t0 < isect.t) )\n\t\t{\n\t\t\tisect.t = t0;\n\t\t\tisect.sphere = sphere;\n\t\t}\n\t\telse if ( (t1 > 0.0) && (t1 < isect.t) )\n\t\t{\n\t\t\tisect.t = t1;\n\t\t\tisect.sphere = sphere;\n\t\t}\n\t}\n}\n\n\n\nSphere sphere[9];\nvoid Intersect(const Ray ray, inout Intersection isect)\n{\n\tsphere_intersect(sphere[0], ray, isect);\n\tsphere_intersect(sphere[1], ray, isect);\n\tsphere_intersect(sphere[2], ray, isect);\n\tsphere_intersect(sphere[3], ray, isect);\n\tsphere_intersect(sphere[4], ray, isect);\n\tsphere_intersect(sphere[5], ray, isect);\n\tsphere_intersect(sphere[6], ray, isect);\n\tsphere_intersect(sphere[7], ray, isect);\n\tsphere_intersect(sphere[8], ray, isect);\n}\n\n\n\nvoid Trace(const vec2 BufInfo, const vec2 PixelIndex, const vec4 RngState, const int UseEyeRays, const int PathLength, const float Time, const float Wavelength, inout vec3 Position, inout vec3 Direction, inout vec3 Contribution)\n{\n\t// scene definition\n\t// walls\n\tsphere[0].c   = vec3( 1.0e5+1.0,40.8,81.6);\n\tsphere[0].r   = 1.0e5;\n\tsphere[0].col = vec3(0.75, 0.25, 0.25);//vec3(0.75);//\n\tsphere[0].f   = 0;\n\n\tsphere[1].c   = vec3(-1.0e5+99.0,40.8,81.6);\n\tsphere[1].r   = 1.0e5;\n\tsphere[1].col = vec3(0.25, 0.25, 0.75);//vec3(0.75);//\n\tsphere[1].f   = 0;\n\n\tsphere[2].c   = vec3(50.0,40.8, 1.0e5);\n\tsphere[2].r   = 1.0e5;\n\tsphere[2].col = vec3(0.75);\n\tsphere[2].f   = 0;\n\n\tsphere[3].c   = vec3(50.0,40.8,-1.0e5+170.0);\n\tsphere[3].r   = 1.0e5;\n\tsphere[3].col = vec3(0.0);\n\tsphere[3].f   = 0;\n\n\tsphere[4].c   = vec3(50.0, 1.0e5, 81.6);\n\tsphere[4].r   = 1.0e5;\n\tsphere[4].col = vec3(0.75);\n\tsphere[4].f   = 0;\n\n\tsphere[5].c   = vec3(50.0, -1.0e5+81.6, 81.6);\n\tsphere[5].r   = 1.0e5;\n\tsphere[5].col = vec3(0.75);\n\tsphere[5].f   = 0;\n\n\t// spheres\n\tsphere[6].c   = vec3(27, 15.5, 88.0);\n\tsphere[6].r   = 15.5;\n\tsphere[6].col = vec3(0.999);\n\tsphere[6].f   = 1;\n\n\tsphere[7].c   = vec3(73, 15.5, 88.0);\n\tsphere[7].r   = 15.5;\n\tsphere[7].col = vec3(0.999);\n\tsphere[7].f   = 2;\n\n\t// motion blur\n\tfloat offset = MotionSize * (sin(Time * 3.141592 * 2.0) + 1.0) / 2.0;\n\tif (!MotionBlur) offset = 0.0;\n\tsphere[8].c   = vec3(50.0, 15.5 + offset, 48.0);\n\tsphere[8].r   = 15.5;\n\tsphere[8].col = vec3(0.75);\n\tsphere[8].f   = 0;\n\n\tvec4 rndv = RngState;\n\tvec2 rnd = vec2(0.0);\n\n\tRay r;\n\tif (UseEyeRays == 0)\n\t{\n\t\t// photon rays\n\t\t// point light source\n\t\tr.org = vec3(50.0, 55.0, 68.0);\n\n\t\t// generate random direction\n\t\trnd.x = GPURnd(rndv);\n\t\trnd.y = GPURnd(rndv);\n\t\trnd.x = 2.0 * 3.141592 * rnd.x;\n\t\trnd.y = 2.0 * acos(sqrt(1.0 - rnd.y));\n\t\tr.dir.x = sin(rnd.x) * sin(rnd.y);\n\t\tr.dir.y = cos(rnd.y);\n\t\tr.dir.z = cos(rnd.x) * sin(rnd.y);\n\t}\n\telse\n\t{\n\t\t// eye rays\n\t\t// pinhole camera\n\t\tconst float FilmSize = 0.5135;\n\t\tconst vec3 pinhole = vec3(50.0, 48.0, 295.6);\n\t\tconst float AspectRatio = 1.0;\n\n\t\tvec3 camd = normalize(vec3(0.0, -0.042612, -1.0));\n\n\t\tvec3 cx = vec3(AspectRatio * FilmSize, 0.0, 0.0);\n\t\tvec3 cy = normalize(cross(cx, camd)) * FilmSize;\n\n\t\tvec3 d = cx * 0.5 * (PixelIndex.x * 2.0 - 1.0 + (GPURnd(rndv) - 0.5) / BufInfo.x) + 0.5 * cy * (PixelIndex.y * 2.0 - 1.0 + (GPURnd(rndv) - 0.5) / BufInfo.y) + camd;\n\t\tr.dir = normalize(d);\n\t\tr.org = pinhole + r.dir * 140.0;\n\n\t\t// thin lens model with a circular aperture\n\t\tif (DOF)\n\t\t{\n\t\t\tvec3 f = pinhole + r.dir * FocalLength;\n\t\t\tfloat radius = sqrt(GPURnd(rndv)) * ApertureSize;\n\t\t\tfloat theta = 2.0 * 3.141592 * GPURnd(rndv);\n\t\t\tvec3 lens = pinhole + radius * (cx * cos(theta) + cy * sin(theta));\n\t\t\tr.dir = normalize(f - lens);\n\t\t\tr.org = lens + r.dir * 140.0;\n\t\t}\n\t}\n\n\tvec3 col = vec3(1.0, 1.0, 1.0);\n\tvec3 nrm = vec3(0.0, 0.0, 0.0);\n\tvec3 pos = vec3(0.0, 0.0, 0.0);\n\tconst float eps = 0.01;\n\n\tIntersection i;\n\tvec3 prev_col;\n\tint brdf = -1;\n\n\ti.t = 1.0e+30;\n\tIntersect(r, i);\n\tif (i.t != 1.0e+30)\n\t{\n\t\tbrdf = i.sphere.f;\n\t\tprev_col = i.sphere.col.rgb;\n\n\t\tpos = r.org + r.dir * i.t;\n\t\tnrm = normalize(pos - i.sphere.c);\n\t}\n\n\tfor (int j = 1; j <= PathLength; j++)\n\t{\n\t\tbool total = false;\n\n\t\tif (brdf == 0)\n\t\t{\n\t\t\t// Lambertian\n\t\t\t// eye ray stops at Lambertian\n\t\t\tif (UseEyeRays != 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trnd.x = GPURnd(rndv);\n\t\t\trnd.y = GPURnd(rndv);\n\n\t\t\trnd.x = 2.0 * 3.141592 * rnd.x;\n\t\t\trnd.y = sqrt(rnd.y);\n\t\t\tvec3 v = vec3(sin(rnd.x) * rnd.y, sqrt(1.0 - rnd.y * rnd.y), cos(rnd.x) * rnd.y);\n\n\t\t\tnrm = faceforward(nrm, r.dir, nrm);\n\t\t\tr.org = pos + eps * nrm;\n\t\t\tr.dir = along(v, nrm);\n\t\t}\n\t\telse if (brdf == 1)\n\t\t{\n\t\t\t// specular reflection\n\t\t\tnrm = faceforward(nrm, r.dir, nrm);\n\t\t\tif (Glossy)\n\t\t\t{\n\t\t\t\t// note that direct illumination on glossy surface is ignored in this demo\n\t\t\t\t// which should be separetely added to the final result\n\t\t\t\tnrm = glossy_normal(nrm, 1.0 / pow((1.0 - Glossiness) * 0.5, 2.71828), rndv);\n\t\t\t}\n\n\t\t\tr.org = pos + eps * nrm;\n\t\t\tr.dir = reflect(r.dir, nrm);\n\t\t}\n\t\telse if (brdf == 2)\n\t\t{\n\t\t\t// specular refraction\n\t\t\tfloat ln = dot(nrm, r.dir);\n\t\t\tfloat eta = 1.5220;\n\n\t\t\t// Cauchy's equation (Hard crown glass K5 with exaggerated abberation)\n\t\t\tif (FullSpectrum) eta += -0.15 + 10.0 * 0.00459 / (Wavelength * Wavelength);\n\n\t\t\tfloat R0 = ((eta - 1.0) * (eta - 1.0)) / ((eta + 1.0) * (eta + 1.0));\n\n\t\t\tif (ln < 0.0)\n\t\t\t{\n\t\t\t\t// in\n\t\t\t\tfloat c = 1.0 + ln;\n\t\t\t\tfloat Re = R0 + (1.0 - R0) * c * c * c * c * c;\n\t\t\t\tfloat P = (Re + 1.0) / 2.0;\n\n\t\t\t\tif (GPURnd(rndv) < P)\n\t\t\t\t{\n\t\t\t\t\tprev_col *= Re / P;\n\t\t\t\t\tr.org = pos + eps * nrm;\n\t\t\t\t\tr.dir = reflect(r.dir, nrm);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprev_col *= (1.0 - Re) / (1.0 - P);\n\t\t\t\t\tr.org = pos - eps * nrm;\n\t\t\t\t\tr.dir = refract(r.dir, nrm, 1.0 / eta);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// out\n\t\t\t\tfloat cos2t = 1.0 - eta * eta * (1.0 - ln * ln);\n\t\t\t\tif (cos2t < 0.0)\n\t\t\t\t{\n\t\t\t\t\tr.org = pos - eps * nrm;\n\t\t\t\t\tr.dir = reflect(r.dir, -nrm);\n\t\t\t\t\ttotal = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfloat c = 1.0 - ln;\n\t\t\t\t\tfloat Re = R0 + (1.0 - R0) * c * c * c * c * c;\n\t\t\t\t\tfloat P = (Re + 1.0) / 2.0;\n\n\t\t\t\t\tif (GPURnd(rndv) < P)\n\t\t\t\t\t{\n\t\t\t\t\t\tprev_col *= Re / P;\n\t\t\t\t\t\tr.org = pos - eps * nrm;\n\t\t\t\t\t\tr.dir = reflect(r.dir, -nrm);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev_col *= (1.0 - Re) / (1.0 - P);\n\t\t\t\t\t\tr.org = pos + eps * nrm;\n\t\t\t\t\t\tr.dir = refract(r.dir, -nrm, eta);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti.t = 1.0e+30;\n\t\tIntersect(r, i);\n\t\tif (i.t != 1.0e+30)\n\t\t{\n\t\t\tbrdf = i.sphere.f;\n\n\t\t\tif (FullSpectrum)\n\t\t\t{\n\t\t\t\tcol *= RGB2Spectrum(prev_col, Wavelength);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcol *= prev_col;\n\t\t\t}\n\t\t\tpos = r.org + r.dir * i.t;\n\t\t\tnrm = normalize(pos - i.sphere.c);\n\n\t\t\tprev_col = i.sphere.col.rgb;\n\t\t}\n\t}\n\n\tif (UseEyeRays != 0)\n\t{\n\t\t// eye ray tracing\n\t\tif (FullSpectrum)\n\t\t{\n\t\t\tcol *= RGB2Spectrum(prev_col, Wavelength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcol *= prev_col;\n\t\t}\n\t\tnrm = faceforward(nrm, r.dir, nrm);\n\t}\n\telse\n\t{\n\t\t// photon tracing\n\t\tcol *= vec3(5000.0) * (4.0 * 3.141592) * float(MaxPathLength);\n\t\tnrm = r.dir;\n\t}\n\n\tPosition  = pos;\n\tDirection = nrm;\n\tContribution = col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec4 RngState = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\tif (iFrame == 0)\n\t{\n\t\t// integer hash from https://www.shadertoy.com/view/XlXcW4\n\t\tconst uint k = 1103515245u;\n\t\tuvec4 x = uvec4(fragCoord, fragCoord + 1.0);\n\t\tx = ((x >> 8u) ^ x.yzwx) * k;\n\t\tx = ((x >> 8u) ^ x.yzwx) * k;\n\t\tx = ((x >> 8u) ^ x.yzwx) * k;\n\t\tx = ((x >> 8u) ^ x.yzwx) * k;\n\t\tRngState = vec4(x % 4000000u + 1u);\n\t}\n\n\tfor (int i = 0; i < MaxRngUsage * 2; i++) GPURnd(RngState);\n\n\tfragColor = RngState;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tint Width = int(iResolution.x) / 3;\n\tivec2 PhotonId = ivec2(fragCoord) / ivec2(3, 1);\n\n\tif (PhotonId.x >= Width || Width * PhotonId.y + PhotonId.x >= PhotonNum) return;\n\n\tvec2 BufInfo = vec2(0.0);\n\tvec2 PixelIndex = vec2(0.0);\n\tvec4 RngState = texelFetch(iChannel0, PhotonId, 0);\n\tint PathLength = iFrame % MaxPathLength;\n\tint UseEyeRays = 0;\n\tfloat Time = Halton_sequence(2, iFrame / MaxPathLength);\n\tfloat Wavelength = Halton_sequence(3, iFrame / MaxPathLength) * (0.780 - 0.380) + 0.380;\n\n\tvec3 PhotonPosition;\n\tvec3 PhotonDirection;\n\tvec3 PhotonFlux;\n\n\tTrace(BufInfo, PixelIndex, RngState, UseEyeRays, PathLength, Time, Wavelength, PhotonPosition, PhotonDirection, PhotonFlux);\n\n\tvec3[] results = vec3[](PhotonPosition, PhotonDirection, PhotonFlux);\n\tfragColor.rgb = results[int(fragCoord.x) % 3];\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 BufInfo = vec2(min(iResolution.x, iResolution.y));\n\tvec2 PixelIndex = (fragCoord - iResolution.xy * 0.5) / BufInfo + 0.5;\n\n\tif (floor(PixelIndex) != vec2(0.0))\n\t{\n\t\tfragColor.rgb = vec3(0.0);\n\t\treturn;\n\t}\n\n\tvec4 RngState = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\tint PathLength = MaxPathLength;\n\tint UseEyeRays = 1;\n\tfloat Time = Halton_sequence(2, iFrame / MaxPathLength);\n\tfloat Wavelength = Halton_sequence(3, iFrame / MaxPathLength) * (0.780 - 0.380) + 0.380;\n\n\tvec3 QueryPosition;\n\tvec3 QueryDirection;\n\tvec3 QueryReflectance;\n\n\tfor (int i = 0; i < MaxRngUsage; i++) GPURnd(RngState);\n\tTrace(BufInfo, PixelIndex, RngState, UseEyeRays, PathLength, Time, Wavelength, QueryPosition, QueryDirection, QueryReflectance);\n\n\tvec3 Flux = vec3(0.0);\n\t// refer to Appendix C in Adaptive Progressive Photon Mapping\n\tfloat Iteration = float(iFrame / MaxPathLength + 1);\n\tfloat QueryRadius = InitialRadius * pow(Iteration, (Alpha - 1.0) / 2.0);\n\n\tint Width = int(iResolution.x) / 3;\n\tint RowNum = (PhotonNum - 1) / Width + 1;\n\tfor (int i = 0; i < RowNum; i++)\n\t{\n\t\tint ColNum = min(Width, PhotonNum - i * Width);\n\t\tfor (int j = 0; j < ColNum; j++)\n\t\t{\n\t\t\tvec3 PhotonPosition = texelFetch(iChannel1, ivec2(j * 3, i), 0).rgb;\n\t\t\tvec3 PhotonDirection = texelFetch(iChannel1, ivec2(j * 3 + 1, i), 0).rgb;\n\t\t\tvec3 PhotonFlux = texelFetch(iChannel1, ivec2(j * 3 + 2, i), 0).rgb;\n\t\t\tfloat weight0 = step(0.0, QueryRadius - distance(QueryPosition, PhotonPosition));\n\t\t\tfloat weight1 = step(0.0, -dot(QueryDirection, PhotonDirection) - 0.001);\n\t\t\tFlux += PhotonFlux * weight0 * weight1;\n\t\t}\n\t}\n\n\t// BRDF (Lambertian)\n\tFlux = Flux * (QueryReflectance / 3.141592);\n\tif (FullSpectrum) Flux = Spectrum2RGB(Wavelength) * Flux.r;\n\n\t// progressive refinement\n\tFlux *= pow(Iteration, 1.0 - Alpha);\n\tif(iFrame > 0) Flux += texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n\n\tfragColor.rgb = Flux;\n}","name":"Buffer C","description":"","type":"buffer"}]}