{"ver":"0.1","info":{"id":"3tjGz1","date":"1558578812","viewed":162,"name":"Wave Tracing","username":"JohnShadow","description":"A 3d waves bouncing off a vertical plain and a sphere.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wave","simulation","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\nfloat sdYPlain(in vec3 p)\n{\n    return p.y + 2.0;\n}\nfloat opTwist(in vec3 p, float twist, float sc)\n{\n    float c = cos(twist*p.y);\n    float s = sin(twist*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdOctahedron(q, sc);\n}\nvec3 reflplain(vec3 p, vec4 n)\n{\n    vec3 ac = (n.xyz * n.w);\n\tif(dot(p, ac) >= 0.0)\n\t\t return vec3(0);\n\tvec3 a = p - ac;\n\tfloat dist = dot(a, n.xyz);\n\tvec3 pp = p + (n.xyz - 2.0*dist*n.xyz);\n\treturn pp;\n}\nvec3 reflsphere(vec3 p, vec4 n)\n{\n\tvec3 a = p - n.xyz;\n\tfloat dist = length(a);\n   \treturn p - (a * (n.w/dist));\n}\nvec3 refltriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 n = -normalize(cross(b - a, c - a)); \n\tfloat dist = dot(p - a, n);\n    if(dist >= 0.0)\n\t\t return p;\n\tvec3 pp = p + (n - dist*n);\n\tif (dot(n, cross(b - a, a - pp)) > 0.0 && \n    dot(n, cross(c - b, b - pp)) > 0.0 && \n    dot(n, cross(a - c, c - pp)) > 0.0)\n\t\treturn p + (n - 2.0*dist*n);\n\treturn vec3(0);\n}\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat sphere(vec3 x, vec3 c, float r)\n{\n    return abs(length(x-c)-r);             // sphere DE\n}\n#define PI_2 1.57079632679\n#define PI 3.14159265359\nfloat wave(vec3 p, vec3 location)\n{\n    p = p - location;\n    return 1.0/(dot(p, p) + 1.0);\n}\nvec3 reflections(vec3 p, vec4 n)\n{\n\tvec3 final = vec3(0);\n    vec3 rp = vec3(0);\n\tfloat dt = iTimeDelta * 0.1;\n\trp = reflsphere(p, vec4(0.0, -2.0, 5.0, 1.0));\n    final += vec3(0.1, 0.1, 0.8) * wave(rp, vec3(0,0,dt));\n    rp = reflplain(p, vec4(0.0, 0.0, 1.0, 1.0));\n    final += vec3(0.1, 0.8, 0.1) * wave(rp, vec3(0,0,dt));\n    float cdt = 5.0 * cos(iTime * 0.5);\n    rp = refltriangle(p, vec3(-2.5, -2.5, cdt), vec3(0, 2.5, cdt), vec3(2.5, -2.5, cdt));\n    final += vec3(0.1, 0.4, 0.4) * wave(rp, vec3(0,0,dt));\n    final += vec3(0.3333, 0.3333, 0.3333) * wave(p, vec3(0,0,dt));\n    return final;\n}\nfloat rplain(vec3 p, vec4 n)\n{\n    return abs(dot(p,n.xyz) + n.w);\n}\nvec4 map(vec3 position)\n{\n    vec3 sp = position - vec3(3.14159265359, 0, 0);\n    vec3 color = reflections(position, vec4(0,1,0, 2.0));\n    float r = sdYPlain(position);\n    float s = sphere(position, vec3(0, -2., 5.0), 1.0);\n\tfloat o = sdOctahedron(position, 0.2);\n    float d = -cos(iTime * 2.0);\n    float dt = 5.0 * cos(iTime * 0.5);\n    float t = udTriangle(position, vec3(-2.5, -2.5, dt), vec3(0, 2.5, dt), vec3(2.5, -2.5, dt));\n    float a = rplain(position, vec4(0.0, 0.0, 1.0, 0.0));\n    if(d < 0.0)\n    \treturn vec4(color, min(min(min(s, r), o), t));\n    else\n\t\treturn vec4(color, min(min(min(min(s, r), o), a), t));\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.0001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0)).w - map(p - vec3(eps, 0, 0)).w,\n \t  map(p + vec3(0, eps, 0)).w - map(p - vec3(0, eps, 0)).w,\n\t  map(p + vec3(0, 0, eps)).w - map(p - vec3(0, 0, eps)).w\n \t)\n );\n}\nvec4 march(vec3 pos, vec3 dir)\n{\n    vec4 cd = vec4(0), fd = vec4(0);\n    for(int i = 0; i < 1000; ++i)\n    {\n        cd = map(pos + dir * fd.w);\n        fd += cd * vec4(0.01, 0.01, 0.01, 1.0);\n        if(fd.w > 100.0)\n            return vec4(0);\n        if(cd.w < 0.0001)\n            return fd;\n    }\n    return vec4(0);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(30.0, 10.0, 30.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec4 l = march(eye, worldDir);\n    vec3 n = vec3(0);\n    vec3 c = vec3(0);\n    if(l.w != 0.0)\n    {\n        vec3 p = eye + worldDir * (l.w - 0.005);\n    \tn = normal(p);\n    \tc = l.xyz;\n    }\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}