{"ver":"0.1","info":{"id":"cdffDl","date":"1689262186","viewed":119,"name":"travel to gameworld","username":"boytoy","description":"transformations be welcome","likes":1,"published":1,"flags":2,"usePreview":0,"tags":["forkme"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"chessboard for testing transform\" by boytoy. https://shadertoy.com/view/dsffz4\n// 2023-07-13 15:02:46\n\nvec2 linear_transformation(vec2 uv){\n    float t = 0.1*cos(iTime);\n    float c = cos(t); float s = sin(t);\n    \n    // og rotation matric\n    mat2 counter_clockwise = mat2(\n        c,  s,\n        s, -c   );\n\n    //return 3.*counter_clockwise * uv - vec2(0.,1.);\n    //return uv.x * vec2(c,s) + uv.y * vec2(s,-c);\n    //return uv.x * vec2(c,s) + uv.y * vec2(-s,c);\n    //return uv.x * vec2(c,s) + uv.y * vec2(c,-s);  // <- transformaciones curiosas\n    //return vec2(uv.x,0.) + vec2(0.,uv.y*(2.+cos(iTime)));\n    if(max(abs(uv.x),abs(uv.y)) > 0.8){return uv;}\n    return vec2(uv.x - 0.03*fbm(vec2(2.*uv.y,fract(2.*iTime))),uv.y);\n    \n}\n\nconst vec2 pixels = vec2(160.,144.)/2.;   // <---------------- modifícame para más resolución\n\nconst float quantization = pow(2.,2.);\nconst vec3 quant = vec3(quantization);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // origen en el centro, eje y abarca [-1,1]\n    vec2 uv = 2.*(fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    uv = (floor(pixels*uv)+0.5)/pixels;\n    \n    vec2 st = 1.1*linear_transformation(uv); // aplicamos transformación de uv aquí.\n    vec2 coordenadas_cuadro = st;\n    coordenadas_cuadro = coordenadas_cuadro + 1.;\n    coordenadas_cuadro /= 2.;\n    \n    // patrón de ajedrez\n    vec3 color = texture(iChannel0,coordenadas_cuadro).rgb;\n    \n    color = (floor(quant*color) + 0.5)/quant;\n    \n    float luma = dot(vec3(0.2126,0.7152,0.0722),color);\n    \n    color = vec3(luma) * vec3(0.412,0.973,0.608);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n    if(max(abs(st.x),abs(st.y)) > 1.){fragColor.rgb = vec3(0.);}\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6.\nfloat fbm (in vec2 st) {\n    // parameters\n    float gain       = .9; // between 0 and 1\n    float lacunarity = 2.5; // greater than 1\n    \n    // Loop of octaves\n    // Initial values\n    float value     = 0.0;\n    float frequency = 0.;\n    float amplitude = 1.;\n    for (float i = 0.; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= lacunarity;\n        st = st.x * vec2(0.,1.) + st.y * vec2(-1., 0.);\n        amplitude *= gain;\n    }\n    \n    if(OCTAVES>1.){value /= 1.-pow(gain,OCTAVES-1.);value *= 1.-gain;}\n    \n    return value;\n}\n","name":"Common","description":"","type":"common"}]}