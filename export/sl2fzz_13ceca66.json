{"ver":"0.1","info":{"id":"sl2fzz","date":"1651742656","viewed":72,"name":"Line cuting","username":"YUIT","description":"Simple area cut","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Line cut area and marking algorithm\n * 1. Generate random line, each line with different slope and no vertical line\n * 2. Offset line make it to get maximum number of cut regions(do not intersect with the points that has been intersected by other line)\n * 3. \n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 bufA = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    vec3 tex = texture(iChannel0, uv+((bufA.z+1.6)*bufA.xy*0.09*sin(iTime))).rgb;\n    \n    vec3 col = vec3(tex);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// From https://www.shadertoy.com/view/Xt3cDn\n#if 1\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n//Faster than \"full\" xxHash and good quality\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n#else\n//XXHash32 based (https://github.com/Cyan4973/xxHash)\n//Slower, higher quality\nuint baseHash(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n#endif\n\n//---------------------2D input---------------------\n\nfloat hash12(uvec2 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nconst uint lineNum = 3u;\nfloat line_slopes[lineNum] = float[](\n    1.2, 8.354, -5.87\n);\n\nfloat line_offset[lineNum] = float[](\n    0.1, 0.2, -.4\n);\n\nconst uint numRegions = (lineNum*lineNum+2u+lineNum)/2u;\nvec2 offset_vectors[numRegions];\n\n\nuint intersectionBitfield = 0x0u;\nfloat intersect = 0.;\n\nfloat LineEq(vec2 p, float k, float b)\n{\n    float val = p.x*k+b-p.y;\n    return val<0.?-1.:(val>0.?1.:0.);\n}\n\nvoid CutRegion(float line, uint i)\n{\n    // point in line\n    if (line == 0.) return;\n    uint mask = 0x1u << i;\n    intersectionBitfield |= mask & (line>0.?0xffffffffu:0u);\n}\n\nvoid GenerateLine(vec2 p)\n{\n    for (uint i = 0u; i < lineNum; i++){\n        CutRegion(LineEq(p, line_slopes[i], line_offset[i]), i);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    GenerateLine(uv-.5);\n    vec3 col = vec3(0.);\n    float val = 0.;\n    fragColor = vec4(vec3(0.3),1.);\n    for (uint i = 0u; i < numRegions; i++){\n        if (intersectionBitfield == i){\n            val = float(i)/float(numRegions);\n            offset_vectors[i] = normalize(hash22(uvec2(vec2(31.*(float(i)+2.1), 52.*(float(i)+12.)))));\n            fragColor = vec4(offset_vectors[i], val, 1.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}