{"ver":"0.1","info":{"id":"wtBBz3","date":"1660643302","viewed":191,"name":"Simple Particle Field","username":"resontone","description":"Simple Particle Field","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265359;\n\n\n//UNUSED\nfloat line(vec2 uv, float width, float blur)\n{\n    float left = -width*0.5;\n    float right = width*0.5;\n    return(smoothstep(left - blur, left, uv.x)- smoothstep(right, right+blur, uv.x));\n}\n\nfloat snoise(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat snoise(vec3 co){\n    return fract(sin(dot(co.xyz, vec3(12.9898,78.233, 289.0))) * 43758.5453);\n}\n\n\n//UNUSED\nfloat circle(vec2 uv, vec2 centre, float diam, float blur)\n{\n    return(1. - smoothstep(diam-blur,diam+blur, length(uv-centre) ));\n}\n\nvec3 glowPoint(vec2 uv, vec3 colorFallOffRates)\n{\n    float dist = length(uv);\n    return(1./(dist*colorFallOffRates));\n}\n\n\nmat4 standardProjectionMatrix(float aspect_width_to_height, float fov_angle, float near_clip,\n                              float far_clip)\n{\n    float d = 1./tan(fov_angle*0.5);\n    \n    return(mat4(d/aspect_width_to_height, 0., 0., 0.,\n                0., d, 0., 0.,\n                0., 0., (near_clip + far_clip)/(near_clip-far_clip), 2.*(near_clip*far_clip)/(near_clip-far_clip),\n                0., 0., -1., 0.));\n}\n\n//Not used\nmat4 obliqueProjectionMatrix(float aspect_width_to_height, float fov_angle, float near_clip,\n                              float far_clip)\n{\n    float d = 1./tan(fov_angle*0.5);\n    \n    return(mat4(d/aspect_width_to_height, 0., 0., 0.,\n                0., d, 0., 0.,\n                0., 0., (near_clip + far_clip)/(near_clip-far_clip), 2.*(near_clip*far_clip)/(near_clip-far_clip),\n                0., 0., -1., 0.));\n}\n\n\nvec2 dotgridID(vec2 uv, float scale)\n{\n    return(floor((uv+.5)*scale));\n}\n\nvec3 dotgridID(vec3 uv, float xy_spacing, float z_spacing)\n{\n    return(vec3(floor((uv.xy+.5)*xy_spacing), floor(uv.z*z_spacing)));\n}\n\n\nfloat dotgrid(vec2 uv, float dot_radius, float blur, float scale)\n{\n    \n    return(smoothstep(dot_radius + blur, dot_radius - blur, length(-0.5+fract((uv+.5)*scale))));\n}\n\n\n\n\nfloat particlegrid(vec3 uv, float dot_radius, float blur, float xy_scale, float z_spacing, float starfield_noise)\n{\n    vec3 id = dotgridID(uv, xy_scale, z_spacing);\n    \n    vec2 center_offset = vec2(0.5, 0.5)+ starfield_noise*vec2(snoise(id+1.2), snoise(id-0.01))-0.5; \n    float star_scale = 1.;//snoise(id + 0.1)+1.; \n    \n    vec2 position = fract((uv.xy + 0.5 + center_offset.xy)*xy_scale);\n\n    float col = smoothstep(dot_radius*star_scale + blur, dot_radius*star_scale - blur, length(-0.5+position));\n    //col = pow((length(-0.5+position)*50.), -1.5);\n       \n    return(col);\n}\n\n\n\nvec4 image( vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    \n    float near_clip = 20.;\n    float far_clip = 500.;/// - iTime;\n    float view_z_range = far_clip-near_clip;\n    \n\tmat4 projection_matrix = standardProjectionMatrix(1., PI/2., near_clip, far_clip);\n    \n    mat4 inverse_mat = inverse(projection_matrix);\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n\n    \n    \n    float alpha = 0.01;\n    \n\n    float radius = 0.125;\n    \n\tfloat tempRadius = 0.;\n    \n   \n    vec4 camera = vec4(iTime*10., iTime*0.4, 0., 1.);\n   \n    int total_layers = 64;\n    \n    \n    float layer_z_period = \tview_z_range/float(total_layers);\n    float dots = 0.125;\n    \n    float start_z = near_clip;\n    \n    \n    vec4 uvz = vec4(uv,start_z- camera.z, 1.);\n   \n    for(int i = 0; i < total_layers; i++)\n    {\n        camera.x += 10.;\n        camera.y += 100.;\n        \n        \n        vec4 tfuv = inverse_mat*uvz;\n        float w = tfuv.w;\n   \t\ttfuv *= tfuv.w;;\n        \n        tfuv.xy -=  camera.xy;\n\n        if(uvz.z > near_clip && uvz.z < far_clip)\n        {\n\n            \n            vec2 id = dotgridID(tfuv.xy, dots);\n            \n\n            \n            float onOffNoise = snoise(id + id.x*20. -id.y*40.);\n            \n            if(onOffNoise >= 0.95)\n            {\n                float freq = snoise(id + id.x*2. -id.y*4.)*0.5;\n                float phase = snoise(id + id.x*6. -id.y*4.);\n                float amplitude = 2.*snoise(id + id.x*16. -id.y*4.);\n                \n                float alpha = exp(-2.*(uvz.z-near_clip)/view_z_range);\n\n                if(uvz.z < near_clip*2.)\n                {\n                    alpha *= (uvz.z-near_clip)/near_clip;\n                }\n\n\n                \n                float noise = snoise(uv);\n                float threshold = 0.05;\n                noise = clamp((noise-1. + threshold)/threshold, 0., 1.);\n\n                float starfield_noise = 0.0;\n                \n                vec3 pgUV = vec3(tfuv.xy,uvz.z+camera.z);\n                pgUV.y += amplitude*sin(iTime*freq*PI + phase*PI);\n                \n        \t\tcol = max(col, 2.*alpha*vec3(1., \n                        1., \n                        1.)*particlegrid(pgUV, 0.1+0.05 *onOffNoise, 0.1+0.1*onOffNoise, dots, layer_z_period,\n                                    starfield_noise));   \n            }\n        }\n        \n        uvz.z += layer_z_period;\n\n    }\n\n   \n    // Output to screen\n    return (vec4(col,1.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float displacement = image(fragCoord).x;\n    \n    \n    vec2 diplacedUV = uv + displacement*0.1;\n    \n    \n    // Output to screen\n    fragColor = 1.3*texture(iChannel1, diplacedUV)*displacement*displacement*displacement*displacement * vec4(0.0125, 0.5, 1., 1.);\n}","name":"Image","description":"","type":"image"}]}