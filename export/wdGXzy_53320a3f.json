{"ver":"0.1","info":{"id":"wdGXzy","date":"1574280672","viewed":581,"name":"Alien Plain","username":"fizzer","description":"The surface of an alien world or something, maybe.\nThis shader pre-computes the heightfield into one face of the cubemap buffer, allowing it to be complex without affecting raystepping speed.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["alien","heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The surface of an alien world or something, maybe.\n// This shader pre-computes the heightfield into one face of the cubemap buffer, allowing it to be complex without affecting raystepping speed.\n// Two cubemap faces are used: One for computing the heightmap and colourmap, and another for blending\n// neighbouring maps together in order to smoothen out the seams that occur where the map repeats.\n\nvec3 mapCoord(vec2 uv)\n{\n    uv = (fract(uv / 4.) - .5) * 2.;\n    return vec3(1., -uv.yx * vec2(1, 1) * (1. - 1. / 1024.));\n}\n\nfloat heightField(vec2 uv)\n{\n    return mix(.73, 1., textureLod(iChannel0, mapCoord(uv), 0.).r);\n}\n\nvec3 heightFieldColour(vec2 uv)\n{\n    return textureLod(iChannel0, mapCoord(uv), 0.).gba;\n}\n\nvec3 heightFieldNormal(vec2 uv)\n{\n    vec2 e = vec2(1. / 512., 0);\n    float h0 = heightField(uv);\n    float h1 = heightField(uv + e.xy);\n    float h2 = heightField(uv + e.yx);\n    float h3 = heightField(uv - e.xy);\n    float h4 = heightField(uv - e.yx);\n    return normalize(cross(vec3(0, h2 - h4, e.x * 2.), vec3(e.x * 2., h1 - h3, 0)));\n}\n\nfloat fbm(vec2 p)\n{\n    float x = 0.;\n    for(int i = 0; i < 6; ++i)\n    {\n\t\tx += textureLod(iChannel3, p / 50. * exp2(float(i)), 0.).r / exp2(float(i + 1));\n    }\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = vec4(0);\n    \n    vec3 ro = vec3(1. + iTime / 10. - 1., 2., -iTime / 9. + 2.);\n    vec3 rd = vec3(uv, -1.9);\n    \n    rd = rotX(-.6) * rd;\n    \n    float rd_scale = 1. / (2048. * 2. *  length(rd.xz));\n    rd *= rd_scale;\n\n    float t0 = (1. - ro.y) / rd.y - 1.;\n    float tm, t1, hm, h1;\n    float t_cloud = (.8 - ro.y) / rd.y;\n    \n    vec2 cloud_uv = ro.xz + t_cloud * rd.xz;\n\n    if(t0 > 0.)\n    {       \n        float h0 = heightField(ro.xz + rd.xz * t0);\n        \n        bool hit = false;\n        \n    \tfor(int i = 0; i < 100; ++i)\n        {\n            t1 = t0 + 1. + t0 / 500.;\n        \th1 = heightField(ro.xz + rd.xz * t1);\n            vec2 n = vec2(h1 - h0, -(t1 - t0));\n            tm = dot(vec2(t0, h0) - vec2(0, ro.y), n) / dot(vec2(1., rd.y), n);\n            if(tm >= t0 && tm <= t1)\n            {\n                hm = mix(h0, h1, (tm - t0) / (t1 - t0));\n                if(ro.y + rd.y * tm < hm + 1e-5)\n                {\n                    hit = true;\n                    break;\n                }\n            }\n            h0 = h1;\n            t0 = t1;\n        }\n        \n        if(!hit)\n        {\n            tm = (t0 + t1) / 2.;\n            hm = (h0 + h1) / 2.;\n        }\n     \n        vec2 uv = ro.xz + rd.xz * tm;\n        \n        rd = normalize(rd);\n        \n        vec3 n = heightFieldNormal(uv);\n        vec3 r = reflect(rd, n);\n        float fr = mix(.07, .75, pow(clamp(1. - dot(-rd, n), 0., 1.), 4.)) * (1. - smoothstep(0.55, 1.2, hm));\n        \n        vec3 c = heightFieldColour(uv);\n        \n        fragColor.rgb = c * textureLod(iChannel1, n, 7.5).rgb * smoothstep(0.73, 1., hm) * (1. - fr);\n        fragColor.rgb += textureLod(iChannel1, r, 5.).rgb * fr * .55;\n    }\n    \n    fragColor.rgb += pow(fbm(cloud_uv + iTime / 9. * vec2(-1, 0)), .8) * smoothstep(-300., 300., -(t_cloud - tm)) / 15.;\n    \n    fragColor.rgb += pow(max(0., uv.y), 2.) / 15. * vec3(.7, 1., .8);\n    \n    fragColor.rgb -= dot(fragColor.rgb, vec3(1. / 3.)) * .3;\n    fragColor.rgb *= 1.1;\n    \n    fragColor.rgb *= 1. - uv.x * uv.x * uv.x * uv.x / 20. - uv.y * uv.y * uv.y * uv.y / 5.5;\n    \n    fragColor.rgb /= (fragColor.rgb + .4) / 1.8;\n    \n    // Gamma correction.\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n    \n    // Dither.\n    fragColor.rgb += texelFetch(iChannel2, ivec2(fragCoord.xy) & 1023, 0).rgb / 100.;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\nvec3 mapCoord(vec2 uv)\n{\n\tuv = (fract((uv + 1.) / 2.) - .5) * 2.;\n    return vec3(-1., -uv.yx * vec2(1, 1));\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Project ray direction on to the unit cube.\n    vec3 absRayDir = abs(rayDir);\n    rayDir /= max(absRayDir.x, max(absRayDir.y, absRayDir.z));\n    \n    // Get the index of the current face being rendered.\n    \n    int faceIndex = 0;\n\n    if(absRayDir.y > absRayDir.x && absRayDir.y > absRayDir.z)\n    {\n        faceIndex = 2;\n    }\n    else if(absRayDir.z > absRayDir.x && absRayDir.z > absRayDir.y)\n    {\n        faceIndex = 4;\n    }\n\n    if(rayDir[faceIndex / 2] > 0.)\n        faceIndex |= 1;\n\n    fragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy / 1024.;\n\n    const float overlap = .1;\n\n    if(faceIndex == 0)\n    {\n\n       uv *= 1. + overlap;\n        \n        vec2 ouv = uv;\n\n        // Calculate a height map.\n\n        //uv = abs(uv - .5) * 1.5;\n\n        for(int i = 0; i < 120; ++i)\n        {\n            uv -= sin(uv.yx * 16. + iTime / 3.) * .007 + .01;\n            uv.x -= .001;\n        }\n\n        uv = fract(uv * 5.5) - .5;\n\n        fragColor.r = (1. - smoothstep(-.1, .7, length(uv)-.1));\n\n        fragColor.r += texture(iChannel0, uv).r * .1;\n        fragColor.r += texture(iChannel0, uv * 2.).r * .05;\n\n        fragColor.r += texture(iChannel0, ouv * 2.).r * .005;\n        fragColor.r += texture(iChannel0, ouv * 3.).r * .01;\n\n        fragColor.r *= sin(ouv.x * 3.1416 * 2. + 1. * sin(ouv.y * 3.14159 * 2. - iTime / 2.))*.7 + .75;\n\n        fragColor.r += textureLod(iChannel1, ouv * 2. - vec2(1,0)*iTime / 70. + .5, 0.).r * .2;\n        fragColor.r -= textureLod(iChannel1, ouv * 2. - vec2(1,0)*iTime / 100., 0.).r * .08;\n\n        float z = textureLod(iChannel0, ouv / 4., 0.).r * 6.;\n\n        fragColor.r += pow(max(0., 1. - fragColor.r), 5.) *\n                textureLod(iChannel1, ouv * 2. - vec2(1,0)*iTime / 70. + .5, 0.).r * .1 * (.5 + .5 * cos(z + iTime * 15.));\n\n        fragColor.r = clamp(fragColor.r*.9, 0., 1.);\n\n        // Calculate colour.\n\n        fragColor.gba = textureLod(iChannel2, uv / 7., 1.).rgb * mix(vec3(1), textureLod(iChannel2, uv * 2., 1.).bgr, .5);\n    }\n    else if(faceIndex == 1)\n    {\n\n        fragColor = vec4(0);\n\n        float wsum = 0.;\n                \n        for(int y = -1; y <= +1; ++y)\n            for(int x = -1; x <= +1; ++x)\n            {\n                vec2 uv2 = uv * 2. - 1. + vec2(x, y) * 2.;\n                float mask = 1. - smoothstep(0., overlap, length(max(abs(uv2)-vec2(1.), 0.)));\n        \t\tfragColor += textureLod(iChannel3, mapCoord(uv2 * 1. / (1. + overlap * 2.)), 0.) * mask;\n                wsum += mask;\n            }\n        \n        fragColor /= wsum;\n\n    }\n}","name":"Cube A","description":"","type":"cubemap"}]}