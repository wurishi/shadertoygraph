{"ver":"0.1","info":{"id":"MsGcWG","date":"1523110545","viewed":195,"name":"2d maxwell equations","username":"unnick","description":"an implementation of the 2d maxwell equations. ","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv)*5.0+0.5;\n    \n    vec4 params = texture(iChannel1, uv);\n    fragColor /= params.x+1.0;\n    fragColor = mix(fragColor, vec4(0.0, 0.75, 1.0, 0.0), atan(1.0/(params.z)-1.0) / 3.141592);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this buffer implements the 2d maxwell equations.\n//equations taken from https://pdfs.semanticscholar.org/aea1/2b8ce72c60acaac8072302cf7016c30866cd.pdf\n\n#define rand(v) fract( sin( dot( v, vec2(12.9898,78.233 )) ) * 43758.5453 )\n#define TAU 6.283\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  if (iTime < 2.0) {\n    //starting conditions\n    vec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    pos -= vec2(0.0, 0.0);\n    pos *= 1.5;\n    fragColor = vec4(\n      0.0,\n      sin(pos.x*2.0*TAU)*exp(-pow(length(pos), 2.0)*10.0),\n      sin(pos.x*2.0*TAU)*exp(-pow(length(pos), 2.0)*10.0),\n      0.0\n    );\n    return;\n  }\n    \n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 d = vec3(1.0/iResolution.xy, 0.0);\n    \n  //integration\n  vec4 cur = texture(iChannel0, uv);\n  //derivative computation.\n  //i use a more complex 5 point stencil instead of the usual 3 or 2 point stencil\n  //because i can do less averaging to avoid blowup later.\n  vec4 dx =\n      (texture(iChannel0, uv + d.xz) - texture(iChannel0, uv - d.xz)) * 8.0\n      - (texture(iChannel0, uv + d.xz*2.0) - texture(iChannel0, uv - d.xz*2.0));\n  vec4 dy = \n      (texture(iChannel0, uv + d.zy) - texture(iChannel0, uv - d.zy)) * 8.0\n      - (texture(iChannel0, uv + d.zy*2.0) - texture(iChannel0, uv - d.zy*2.0));\n  dx /= 12.0;\n  dy /= 12.0;\n    \n  vec4 params = texture(iChannel1, uv);\n  \n  cur.x += (dy.z - cur.x * params.x) / params.y * 0.2;\n  cur.y -= (dx.z + cur.y * params.x)            * 0.2;\n  cur.z += (dy.x - dx.y            ) / params.z * 0.2;\n    \n  //slight averaging (to avoid blowup)\n  for(int y = -1; y <= 1; y++) {\n    for(int x = -1; x <= 1; x++) {\n      cur += texture(iChannel0, uv + d.xy * vec2(x, y)) * 0.018;\n    }\n  }\n  cur /= 1.0 + 9.0*0.018;\n    \n  //click handling\n  if(iMouse.z > 0.5) {\n    vec2 pos = (fragCoord.xy - iMouse.xy) / min(iResolution.x, iResolution.y) * 2.0;\n    if (texture(iChannel2, vec2(32.0/256.0, 0.0)).r < 0.5) {\n      cur.x += sin(pos.x*TAU/2.0*5.0)*max(1.0-abs(length(pos)*5.0), 0.0)*0.1;\n      cur.y += sin(pos.y*TAU/2.0*5.0)*max(1.0-abs(length(pos)*5.0), 0.0)*0.1;\n    } else {\n      cur.z += max(1.0-abs(length(pos)*5.0), 0.0)*0.1;\n    }\n  }\n  if(iMouse.w > 0.5) {\n    vec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    vec2 mpos = (iMouse.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n  }\n    \n  //cur *= max(2.0-length(cur), 1.0)/75.0+74.0/75.0;\n  fragColor = clamp(cur, -100.0, 100.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this buffer defines the parameters for the maxwell equations.\n\n//uncomment these to add them to the simulation.\n#define WAVEGUIDE\n#define WALLS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    fragColor = vec4(0.0, 1.0, 1.0, 0.0);\n    \n    #ifdef WALLS\n    fragColor.x = (fragCoord.x<20.0||fragCoord.x>iResolution.x-20.0)?5.0:0.0;\n    #endif\n    \n    #ifdef WAVEGUIDE\n    fragColor.z= 1.0/(min(pow(abs(pos.y)*2.0, 3.0)+1.0, 2.0));\n    #endif\n}","name":"Buf B","description":"","type":"buffer"}]}