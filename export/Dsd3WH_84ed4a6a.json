{"ver":"0.1","info":{"id":"Dsd3WH","date":"1677209871","viewed":87,"name":"Lighthouse on an island","username":"ianertson","description":"Use the mouse to look around :)","likes":5,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","raymarch","sdf","water","lighthouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 getAvg(vec2 uv) {\n    vec2 tex = 1.0 / R.xy;\n    vec3 center = getColor(uv);\n    vec3 right = getColor(uv + (vec2(1, 0)*tex));\n    vec3 left = getColor(uv + (vec2(-1, 0)*tex));\n    vec3 up = getColor(uv + (vec2(0, 1)*tex));\n    vec3 down = getColor(uv + (vec2(0, -1)*tex));\n    \n    return (center + right + left + up + down) / 5.0;\n}\n\nvec3 getBloom(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv) * (f+0.5) * 4.;\n    vec2 dy = dFdy(uv) * (f+0.5) * 4.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    vec3 c = getAvg(uv);\n    \n    return max(a+(luma(a)*0.3), max(b+(luma(b)*0.3), c+(luma(c)*0.1)));\n}\n\nvec3 getSmooth(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv) * (f+0.5) * 6.;\n    vec2 dy = dFdy(uv) * (f+0.5) * 6.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    vec3 c = getAvg(uv);\n    \n    return mix(mix(a, b, 0.5), c, 0.5);\n}\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    col = mix(col, getSmooth(uv, noiseEst), noiseEst*0.9);\n    col = mix(col, getSmooth(uv, depth+(depth*depth)), clamp(depth+(depth*depth), 0.0, 1.0));\n    \n    float lm = luma(col);\n    \n    col = mix(col, getBloom(uv, lm), lm*0.5);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (var < dist) { data.id = id_; dist = var; }\n#define TEXTURE_SIGNATURE in vec2 uv, inout Material m\n\n#define EST_NORM_FOR(TEXFUNC, UV, N, M, COMPFUNC, RADI, Z, CLR, MIX, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = RADI;\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), M)),\\\n        Z\\\n    )), MIX);\\\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(0.1, dot(wn, n))));\n}\n\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material {\n    float rough;\n    float spec;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    Material m;\n    bool skipWater;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, NEW_MATERIAL, true)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: {\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.001, distance(light.p, p)));\n        } break;\n        case LIGHT_DIR: {\n            vec3 ld = normalize(light.d);\n            vec3 sd = normalize(light.p - p);\n            float cone = dot(sd, ld);\n            const float cutoff = 0.89;\n            return (light.c * NdotL  * light.s * smoothstep(cutoff, 1.0, cone));\n           /* return light.c * light.s * smoothstep(0.8, 1.0, dot(\n                normalize(light.p - p),\n                normalize(light.d)\n            ));*/\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, round(adot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, round(adot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, round(adot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define GROUND_LEVEL 10.\n#define SIZE vec3(8.0, 0.0, 8.0)\n#define CENTER vec3(SIZE.x/2., 0, SIZE.z/2.)\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_CUBE 2\n#define ID_WATER 3\n#define ID_LIGHT_HOUSE 4\n#define ID_LIGHT_HOUSE_BODY 5\n#define ID_LIGHT_HOUSE_HOUSE 6\n#define ID_LIGHT_HOUSE_ROOF 7\n#define ID_LIGHT_HOUSE_RAILING 8\n\nvec3 noise(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p + (seed * 256.0))/256.0, 0.0).xyz;\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV \n    return n / div;\n}\n\n\nvec3 noise(in vec2 p, in float seed, vec2 lod) {\n    return textureLod(iChannel3, (p + (seed * 256.0))/256.0, lod.x).xyz;\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq, vec2 lod) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV \n    return n / div;\n}\n\nvec3 snoiseX(vec2 p, float seed) {\n    return textureLod(iChannel3, (vec2(p.x, p.y) + seed) /256., 0.0).xyz;\n}\n\nvec3 snoise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = smoothstep(0.0, 1.0, fract(p));\n    \n    #define GET(UV) snoiseX(UV, seed)  //textureLod(iChannel3,  UV / 256., 0.0).xyz\n    \n    vec3 a = GET(id);\n    vec3 b = GET(id+vec2(1., 0));\n    vec3 c = GET(id+vec2(0, 1.));\n    vec3 d = GET(id+vec2(1., 1.));\n    \n    vec3 ab = mix(a, b, lv.x);\n    vec3 cd = mix(c, d, lv.x);\n    vec3 n = mix(ab, cd, lv.y);\n    \n    #undef GET\n    \n    return n;\n}\n\nvec3 snoise6(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * snoise(p * freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\n\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);   \n    return e + i;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat coneSDF(in vec3 p, in vec3 a, in vec3 b, in float t) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float l = length(pa - ba * h) - t;\n    \n    l += (cdot(p, b)/M_PI);\n    \n    return l;\n}\n\nfloat getIsland(in vec3 p, float mi, float ma) {\n    return smoothstep(10.0 + mi, 24.0 + ma, distance(p.xz, CENTER.xz));\n}\n\nfloat groundSDF(in vec3 p) {\n    if (p.y >= 8.) return p.y;\n    float w = snoise6(p.xz, 1.23125, 0.1).r;\n    float area = getIsland(p, (w*4.), (w*8.));\n    float innerArea = smoothstep(0. + (w*4.), 20.0 + (w*10.), distance(p.xz, CENTER.xz));\n    float h = 0.0;\n    \n   \n    \n    //w = w * 3.;\n   // w = w*area*4.;\n    \n  //  h += w;\n    h -= area*9.;\n    h += w*6.1*max(0.0, 1.0 - (area*0.8))*innerArea;\n    \n    h += pow(w, 2.) * 10. * max(0.0, 1.0 - (area*0.5)) * smoothstep(2., 16.0, max(0.0, p.z));\n    \n    return p.y - h;\n}\n\n\n\nfloat waterSDF(in vec3 p) {\n    if (p.y >= 6.) return p.y;\n    float time = T*0.3;\n    \n    vec2 shift = vec2(cos(time), sin(time)) * 2.;\n\n    vec3 lf = snoise6(p.xz + (shift*2.), 0.23125, 0.1);\n    \n    shift += 0.5 - lf.xz;\n    shift += vec2(sin((time*0.5)+(lf.x*2.)), cos((time*0.5)+(lf.y*2.)))*3.;\n    time += (lf.x+lf.y)*2.;\n    \n    vec3 hf = snoise6(p.xz + (shift*0.5), 1.19281, 0.22);\n    \n    shift += (0.5 - hf.xz)*1.6;\n    \n    vec3 mixer = snoise6(p.xz + (shift*2.), 0.38211, 0.1);\n    \n    float mx = mix(mixer.x, mixer.y, 0.5+(0.5*sin(time+lf.z)));\n    float my = mix(mixer.y, mixer.z, 0.5+(0.5*cos(time+lf.y)));\n    \n    //noise21(p.xz, 3.97124, 0.1);\n    float island = getIsland(p, 0., 0.);\n    \n    float h = mix((lf.x+lf.y)/2., (hf.x+hf.y)/2., mx);\n    \n    h -= (pow(mix(lf.z, lf.y, my), 2.0));\n    \n    h *= island;\n    \n    h *= 3.0;\n    \n    return p.y - h;\n}\n\nfloat lightHouseSDF(in vec3 p, inout int id) {\n    float h = 12.5;\n    float t = 3.0;\n    id = ID_LIGHT_HOUSE;\n    float dist = FAR;\n    \n    t -= smoothstep(h*0.9, 1.6, distance(vec3(0, p.y, 0), vec3(0, h, 0)));\n    float body = cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), t)-0.1;\n    float inside = cylSDF(p, vec3(0, 0, 0), vec3(0, h*0.9, 0), t*0.9)-0.1;\n    float door = cylSDF(p - vec3(0, 0, -t), vec3(0, 0, 0), vec3(0, h/5.3, 0.0), t*0.2);\n    \n    body = max(body, - door);\n    body = max(body, -inside);\n\n    \n    \n    float railingT = t*1.29;\n    float railing = cylSDF(p - vec3(0, h, 0), vec3(0, 0, 0), vec3(0, 1., 0), railingT);\n    float railingInside = cylSDF(p - vec3(0, h+0.1, 0), vec3(0, 0, 0), vec3(0, 1., 0), railingT*0.9);\n    railing = max(railing, -railingInside);\n \n    \n //   body = min(body, railing);\n    \n    vec3 topHouseSize = vec3(1, 1.5, 1);\n    float topHouse = boxSDF(p - vec3(0, h + topHouseSize.y, 0), topHouseSize);\n    float lightHole = sphereSDF(p -  vec3(0, h + (topHouseSize.y/2.)+(topHouseSize.x), 0), topHouseSize.x + (0.25*max(0.0, max(abs(p.x), abs(p.z)))));\n    topHouse -= 0.09;\n    topHouse = max(topHouse, -lightHole);\n    \n    float railingTop = cylSDF(p - vec3(0, h+0.5+topHouseSize.y+0.1, 0), vec3(0, 0, 0), vec3(0, 1., 0), railingT);\n    float railingTopInside = cylSDF(p - vec3(0, (h+topHouseSize.y+0.1)-0.5, 0), vec3(0, 0, 0), vec3(0, 1., 0), railingT*0.9);\n    railingTop = max(railingTop, -railingTopInside);\n    \n    float roof = coneSDF(p - vec3(0, h+topHouseSize.y+2., 0), vec3(0, 0, 0), vec3(0, 4, 0), t*1.3);\n    roof = mix(roof, FAR, float(p.y < (h+topHouseSize.y+1.)));\n    \n    if (body < dist) { dist = body; id = ID_LIGHT_HOUSE_BODY; }\n    if (roof < dist) { dist = roof; id = ID_LIGHT_HOUSE_ROOF; }\n    if (railing < dist) { dist = railing; id = ID_LIGHT_HOUSE_RAILING; }\n    if (railingTop < dist) { dist = railingTop; id = ID_LIGHT_HOUSE_RAILING; }\n    if (topHouse < dist) { dist = topHouse; id = ID_LIGHT_HOUSE_HOUSE; }\n    /*\n    body = min(body, roof);\n    \n    body = min(body, railingTop);\n    \n    body = min(body, topHouse);*/\n    \n    return dist;\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n    p.y -= GROUND_LEVEL;\n    float dist = FAR;\n    \n    if (!data.skipWater) {\n        float water = waterSDF(p);\n        data.id = ID_WATER;\n        return water;\n    }\n    \n    float ground = groundSDF(p);\n   // float water = waterSDF(p);\n   // float cube = cubeSDF(p - (CENTER + vec3(0, 1, 0)), vec3(1.0));\n    int housePart = 0;\n    float lightHouse = lightHouseSDF(p - CENTER, housePart);\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(lightHouse, housePart);\n  //  SAMPLE(cube, ID_CUBE);\n  //  SAMPLE(water, ID_WATER);\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = dist;\n    \n    float f = data.id == ID_WATER ? 0.1 : 0.001;\n    vec2 e = vec2(f, 0.0);\n    \n    data.n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    \n    data.uv = boxUv(data.p, data.n);\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    if (near >= far) return 1.0;\n    \n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= min(abs(far), FAR)) return 1.0;\n    }\n    \n    return clamp(abs(dist) / (0.02+abs(near)), 0.0, 0.77);\n}\n\n//#define DEBUG_TEXTURE grassTexture\n\nvec3 grassTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    vec3 reg = noise(uv, 0.032195, 1.9);\n    vec3 reg2 = noise(uv, 1.938154, 1.5);\n    vec3 lf = noise(uv*0.5, 0.444512, 0.4);\n    vec3 lf2 = noise(uv*0.4, 0.333211, 0.1);\n    vec3 lf3 = abs(normalize(reflect(lf2, lf)));\n    \n    vec3 reg_grass = noise(uv, 1.098815, 0.9);\n    vec3 reg_mud = noise(uv, 0.9111222, 2.0);\n    vec3 reg_rock = noise(uv, 2.0091823, 0.5);\n    \n    float grassReg = reg_grass.x;\n    float mudReg = reg_mud.x;\n    float rockReg = reg_rock.x;\n    \n    mudReg *= max(pow(lf2.x, 2.0), mudReg*max(mudReg*0.9, clamp(abs(grassReg - rockReg)*16., 0.0, 1.0)));\n   \n    rockReg = max(pow(lf2.z, 2.0), rockReg - (grassReg*0.3));\n    rockReg = mix(rockReg, (abs(rockReg - grassReg) + abs(mudReg - grassReg))/2., 0.2);\n    grassReg = max(pow(lf2.y, 2.0), grassReg - (rockReg*0.3));\n    \n    mudReg = pow(mudReg, 2.0);\n    rockReg = pow(rockReg, 2.0);\n    \n    mudReg += clamp(pow(abs(rockReg - grassReg), 3.0), 0.0, 1.0);\n    \n    \n    vec3 alt1 = noise(uv, 0.293155, 32.0);\n    vec3 alt2 = noise(uv, 0.893823, 32.0);\n    vec3 alt3 = abs(reflect(alt1, alt2));\n    \n    \n    vec3 grass1 = rgb(98, 101, 72)*vec3(0.9, 0.9, 0.5);\n    vec3 grass2 = rgb(76, 80, 56);\n    vec3 grass3 = rgb(41, 42, 37);\n    \n    vec3 rock1 = rgb(125, 114, 99);\n    vec3 rock2 = rgb(144, 131, 115);\n    vec3 rock3 = rgb(92, 81, 69);\n    \n    vec3 mud1 = rgb(70, 54, 41);\n    vec3 mud2 = rgb(110, 85, 61);\n    vec3 mud3 = rgb(67, 55, 45);\n    \n    vec3 grass = mix(mix(grass1, grass2, alt1.x), grass3, alt1.y) * grassReg;\n    vec3 rock = mix(mix(rock1, rock2, alt1.z), rock3, alt2.x) * rockReg;\n    vec3 mud = mix(mix(mud1, mud2, alt2.y), mud3, alt2.z) * mudReg;\n    \n    col += grass;\n    col += clamp(rock*3., 0.0, 1.0);\n    col += mud;\n    \n    col += clamp(pow(rockReg, 3.0)*10., 0.0, 1.0)*lf2.x*lf2.y;\n    \n    vec3 grain = textureLod(iChannel3, uv*0.09, 0.0).xyz;\n    \n    col += grain.x*mix(abs(lf2.x-lf2.z)*abs(lf2.y-lf2.x), rockReg, clamp(0.5+(rockReg*0.5), 0.0, 1.0));\n    col = mix(col, grain.x*grass1, grain.x*grassReg*alt1.x);\n    \n    float left = abs(reg_grass.y - reg_mud.z);\n    float right = abs(reg_mud.y - reg_rock.y);\n    \n    float crack = abs(left - right);\n    crack = pow(smoothstep(0.06, 0.03, crack), 2.0) * lf2.x*rockReg*2.;\n    \n    col = mix(col, mix(rgb(16, 18, 22)*mud1, vec3(0.99), (lf2.z+lf2.y)/2.), crack*crack);\n    col += crack*abs(rockReg-mudReg);\n    col = mix(col, mix(mud1, mud3*mud2, grain.y*reg_mud.y), 0.6*clamp(pow(smoothstep(0.5, 0.1, abs(grassReg-mudReg)), 3.0), 0.0, 1.0));\n    \n    col = mix(col, max(vec3(0.0), grass-grain.y), lf3.y*reg_grass.y);\n    \n    \n    m.spec = clamp(((crack*rockReg) + ((grain.z * grassReg) * 0.4) + (pow(rockReg, 4.0)*16.))/2., mudReg*alt3.x, 1.0);\n    \n    return col;\n}\n\nvec3 brickTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 4.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    \n    vec3 hf = noise(uv, 3.281139, 32.0);\n    vec3 lf = noise(uv, 2.000123, 5.0);\n    vec3 tf = noise(id, 0.029181, 16.);\n    \n    vec3 c1 = rgb(142, 91, 67);\n    vec3 c2 = rgb(71, 41, 42);\n    vec3 c3 = rgb(107, 59, 48);\n    \n    vec3 c4 = rgb(156, 146, 125); // grid\n   \n    float t = max(hf.x*0.3*hf.y, 0.04 + (0.5 - (lf.x+lf.y)/2.));\n    float g = max(0.0, 1.0 - ceil(min(lv.x + hf.y*0.04, lv.y+hf.x*0.04)-t));\n    float g2 = max(0.0, 1.0 - round(min(lv.x + hf.y*0.04, lv.y+hf.x*0.04)+t*6.));\n    \n   \n    g *= clamp(2.0*((pow(lf.y, 4.0)+pow(hf.x, 4.0))), 0.0, 1.0);\n    g = max(0.0, g - hf.z*0.2);\n    \n    g2 *= clamp(2.0*((pow(lf.z, 4.0)+pow(hf.y, 4.0))), 0.0, 1.0);\n    g2 = max(0.0, g2 - hf.x*0.2);\n    \n    col += c4*(g2*(tf.x+lf.x))/2.;\n    \n    col += (c1*c1) * tf.x;\n    col += (c2*c2) * tf.y;\n    col += (c3*c3) * tf.z;\n    \n    col += c4 * g;\n    \n    col += c1 * hf.x*hf.y*hf.z;\n    col += (c2*c2) * lf.y;\n    col += (c3*c3) * lf.z;\n    \n    col *= (hf.x+hf.y+hf.z+lf.y)/3.5;\n    \n    vec3 grit = textureLod(iChannel3, uv*5., 0.0).rgb;\n    \n    float gritf = pow(grit.x, 4.0);\n    col += (c1 * gritf) * max(0.0, 1.0 -(lf.z*0.6));\n    \n    m.spec = (gritf+g2+g)/2.;\n    \n    return col;\n}\n\nvec3 cobbleTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 4.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    \n    vec3 hf = noise(uv, 1.92815, 32.0);\n    vec3 lf = noise(uv, 0.11122, 5.0);\n    \n    vec3 c1 = rgb(145, 142, 132);\n    vec3 c2 = rgb(171, 167, 162);\n    vec3 c3 = rgb(91, 91, 91);\n    vec3 c4 = rgb(28, 28, 30);\n    \n    col += c1 * hf.x;\n    col += c2 * hf.y;\n    col = mix(col, c3, hf.z);\n    \n    float cracks1 = abs(lf.y - lf.z);\n    cracks1 = smoothstep(0.05, 0.002, cracks1);\n    \n    float t = 0.04*0.9+(0.2*((cracks1-hf.y*0.3)+hf.z*0.6));\n    float g = max(0.0, 1.0 - ceil(min(lv.x+0.01, lv.y)-t));\n    g *= (pow(hf.z, 3.0) * (0.5 + (pow(lf.z, 3.)*0.5)));\n\n    \n    float cracks2 = abs(lf.x - lf.y);\n    cracks2 = smoothstep(0.05, 0.002, cracks2);\n    \n    \n    col = mix(col, c4, cracks2);\n    col = mix(col, c4, clamp(g*6., 0.0, 1.0));\n    \n    lv = lv * 2.0 - 1.0;\n    \n    col += max(0.0, 1.0-length(lv-(g+cracks2*2.)))*((hf.y+lf.y)/2.);\n    \n    col += pow(abs(cracks1 - cracks2), 8.0) * hf.z;\n    \n    return col;\n}\n\nvec3 metalTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(135, 124, 122);\n    vec3 c2 = rgb(105, 91, 94);\n    vec3 c3 = rgb(205, 206, 202);\n    vec3 c4 = rgb(125, 125, 121);\n    \n    vec3 ax = noise(uv, 5.11123, 8.6);\n    vec3 ay = noise(uv, 4.44421, 32.6);\n    vec3 az = noise(uv, 1.53229, 64.6);\n    \n    col = mix(col, c1, ax.x);\n    col = mix(col, c2, ay.y);\n    col = mix(col, c3, az.z);\n    \n    float pat = (abs(ax.y - ay.x) + abs(ay.z - az.y)) / 2.;\n    pat = clamp(smoothstep(0.16, -0.2, pat), 0.0, 1.0);\n    \n    col = mix(col, c4*c4*c4, clamp(pat*2., 0.0, 1.0));\n    \n    uv *= 1.6;\n    float swirl = cos((ay.x)+(((uv.x + cos(uv.y*1.6)) - sin(uv.y*1.6+(ay.y*0.1)))*10.)*(TAU+az.x));\n    \n    col = mix(col, c3*c3, swirl);\n    \n    col *= (0.5+(fract(ax.x + ax.y + ax.z + ay.x + ay.y + ay.z + az.x + az.y + az.z)*0.5));\n    col *= vec3(0.89, 0.88, 0.89);\n    col += 0.5;\n    col /= M_PI;\n    \n    m.spec = clamp(swirl*3., 0.5, 1.0);\n    m.rough = (pat+swirl)/2.0;\n  \n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.p.xz*4.;//data.uv*4.;\n    vec3 col = vec3(0.0);\n    \n    col = grassTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(grassTexture, uv, data.n, data.m, luma, 0.02, 0.2, col, 1.0, bump);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoLightHouseBody(inout Data data) {\n    vec2 uv = data.uv*0.8;\n    vec3 col = cobbleTexture(uv, data.m);\n    \n    vec3 red = rgb(174, 37, 40);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(cobbleTexture, uv, data.n, data.m, luma, 0.02, 0.2, col, 1.0, bump);\n    data.n = bump;\n    \n    float stripes = ceil(fract(data.p.y*0.4)-0.2) * smoothstep(0.0, 8.0, max(0.0, data.p.y-GROUND_LEVEL));\n    \n    \n    col = mix(col, red, stripes*0.9);\n    return col;\n}\n\nvec3 getAlbedoLightHouseRoof(inout Data data) {\n    vec2 uv = data.uv*0.8;\n    vec3 col = cobbleTexture(uv, data.m);\n    \n    vec3 red = rgb(174, 37, 40);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(cobbleTexture, uv, data.n, data.m, luma, 0.02, 0.2, col, 1.0, bump);\n    data.n = bump;\n\n    return col;\n}\n\nvec3 getAlbedoLightHouseRailing(inout Data data) {\n    vec2 uv = data.uv*0.8;\n    vec3 col = metalTexture(uv, data.m);\n    \n    vec3 red = rgb(174, 37, 40);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(metalTexture, uv, data.n, data.m, luma, 0.02, 0.2, col, 1.0, bump);\n    data.n = bump;\n\n    return col;\n}\n\nvec3 getAlbedoLightHouseHouse(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = brickTexture(uv, data.m);\n    \n    vec3 red = rgb(174, 37, 40);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(brickTexture, uv, data.n, data.m, luma, 0.02, 0.2, col, 1.0, bump);\n    data.n = bump;\n\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_LIGHT_HOUSE_BODY: return getAlbedoLightHouseBody(data); break;\n        case ID_LIGHT_HOUSE_ROOF: return getAlbedoLightHouseRoof(data); break;\n        case ID_LIGHT_HOUSE_RAILING: return getAlbedoLightHouseRailing(data); break;\n        case ID_LIGHT_HOUSE_HOUSE: return getAlbedoLightHouseHouse(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    vec2 uv = rd.xz / rd.y;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    col = mix(vec3(0.2, 0.59, 0.9), pow(vec3(0.2, 0.59, 0.9), vec3(3.0)), clamp(dotup*1.6, 0.0, 1.0));\n    \n    float time = T * 0.1;\n    \n    vec3 reg = noise(uv + vec2(sin(time), cos(time)), 0.029831, 0.6);\n    \n    \n    vec2 shift = vec2(cos(time + (0.8*pow(reg.x, 2.0))), sin(time + (0.8*pow(reg.z, 2.0))));\n    \n    vec3 lf = noise(uv + (shift*3.), 0.98721, 1.);\n    \n    shift += vec2(cos((lf.x*6.) - (time*0.2)), sin(lf.y*6.))*0.01;\n    \n    vec3 hf = noise(uv - (shift*0.5), 1.11123, 16.0);\n    \n    shift += (0.5 - hf.xy) * 2.;\n    \n    vec3 mixer = noise(uv + (0.5 - shift), 0.182719, 0.5);\n    \n    \n    float clouds = mix(lf.x, hf.x, mixer.x);\n    clouds = mix(clouds, reg.y, mixer.z * (0.5+(0.5*cos(time*3.))));\n    \n    clouds = pow(clouds, 2.0);\n    clouds = mix(clouds, 0.0, clamp(pow(reg.y, 2.5)*2., 0.0, 1.0));\n    clouds *= clamp(dotup*6., 0.0, 1.0);\n    col += clouds;\n    \n    col += (light.c * light.s * pow(VdotL, 16.0)) / 2.;\n    \n    return col;\n}\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p));\n        \n        \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 2\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float dist) {\n    vec3 col = vec3(0.0);\n    \n    dist = FAR;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    vec3 ldir = normalize(vec3(cos(T), mix(0.3, 1.6, (0.5+(0.5*cos(T)))), sin(T)));\n    \n    \n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 1.6, -3), vec3(0.0), vec3(0.97, 0.79, 0.69), 1.0, LIGHT_AMBIENT);\n    lights[1] = Light(CENTER + vec3(0, 25.0, 0) + (vec3(ldir.x, 0, ldir.z)), ldir, vec3(0.97, 0.79, 0.69), 10.0, LIGHT_DIR);\n\n    if (march(data, ro, rd)) {\n        dist = min(dist, data.d);\n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd);\n           \n        }\n    } else {\n        col += getSky(ro, rd, lights[0]);\n    }\n    \n    vec3 waterCol = vec3(0.0);\n    \n    Data waterData = NEW_DATA;\n    waterData.skipWater = false;\n    \n    if (march(waterData, ro, rd) && waterData.d < data.d-NEAR) {\n        dist = min(dist, waterData.d);\n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            waterCol += forEachLight(waterData, light, ro, rd);\n        }\n        \n        vec3 ref = reflect(rd, waterData.n);\n        float diff = abs(waterData.d - data.d) /FAR;\n        diff = smoothstep(0.0, 1.0, diff);\n        \n        \n      //  return vec3(diff);\n        col /= (1.0+(0.9*(diff*FAR)));\n        col +=  waterCol*getSky(waterData.p+(waterData.n*NEAR*2.0), ref, lights[0]);\n\n    }\n    \n    float depth = dist / FAR;\n    col += smoothstep(0.05, 1.0, (depth*depth)) * max(0.0, 1.0 - clamp(dotup*2., 0.0, 1.0));\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -SIZE.z*3.9);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    if ((abs(m.x) > 0.001 || abs(m.y) > 0.001) && m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n       // ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(T*0.25);\n        \n    //    rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(T*0.25);\n    }\n    \n    ro += CENTER;\n    ro.y += GROUND_LEVEL + 5.;\n    ro.y = max(GROUND_LEVEL + 1.0, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec4 m = iMouse;\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float dist = FAR;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ma);\n    #else\n    col += render(data, ro, rd, dist);\n    #endif\n    \n    col += (col*col*luma(col));\n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, dist/FAR);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}