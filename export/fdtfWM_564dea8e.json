{"ver":"0.1","info":{"id":"fdtfWM","date":"1656595363","viewed":505,"name":"example: using quaternions","username":"jt","description":"An example using quaternions for rotation.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["quaternion","rotation","formula","euler","quaternions","rodrigues"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/fdtfWM\n// example: using quaternions (2022 by jt)\n// NOTE: See rotation-function comments for connection to Euler Rodrigues / Rodrigues Rotation Formula.\n\n// Variants:\n// https://www.shadertoy.com/view/fsdBDM example: using dual quaternions\n// https://www.shadertoy.com/view/7dcBDj example: using rodrigues vectors\n\n// tags: quaternion, rotation, quaternions, euler, rodrigues, formula\n\n// https://en.wikipedia.org/wiki/Quaternion\n\n// NOTE: using vec4 here would be more concise - but when quaternions have their own type,\n//       the type-checking done by the glsl compiler can be used to detect errors\n//       caused by accidentally confusing vec4 with quaternions\n//       (e.g. accidentally multiplying a quaternion with an axis-angle, both stored in vec4).\n//       Also in mathematical notation usually the real part is written first, followed by the imaginary part:\n//       w + xi + yj + zk while the vec4 constructor expects x, y, z, w.\n//       When defining a quaternion type the mathematical order can be chosen.\n//       Last but not least using an own type for quaternions allows to overload functions, like norm\n//       (this becomes increasingly valuable when introducing more systems,\n//        like complex numbers, dual numbers, dual quaternions...)\n\nstruct quat\n{\n    float s;\n    vec3 v;\n};\n\n// NOTE: https://en.wikipedia.org/wiki/Quaternion#Quaternions_and_the_space_geometry\n// NOTE: The cross-product of the vector-parts of any quaternions p, q can be expressed by (pq - qp)/2\n//       (the scalar part of this expression always evaluates to zero)\n//       (the expression pq - qp is apparently called \"commutator\")\n// NOTE: The dot-product of all four components of quaternions p, q can be expressed by (pq* + qp*)/2\n//       (where * denotes the quaternion conjugate, i.e. negation of the vector-part)\n// NOTE: This is straight forward but cumbersome to check - use e.g. Maxima:\n//       % quaternion-multiplication (in component form)\n//       a_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*a_2 - b_1*b_2 - c_1*c_2 - d_1*d_2;\n//       b_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*b_2 + b_1*a_2 + c_1*d_2 - d_1*c_2;\n//       c_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*c_2 - b_1*d_2 + c_1*a_2 + d_1*b_2;\n//       d_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) :=a_1 * d_2 + b_1 * c_2 - c_1 * b_2 + d_1 * a_2;\n//       % evaluate squared norm |q|^2 = qq* = a^2 + b^2 + c^2 + d^2\n//       a_3(a,b,c,d,a,-b,-c,-d);b_3(a,b,c,d,a,-b,-c,-d);c_3(a,b,c,d,a,-b,-c,-d);d_3(a,b,c,d,a,-b,-c,-d);\n//       % evaluate (pq - qp)\n//       a_3(a,b,c,d,A,B,C,D)-a_3(A,B,C,D,a,b,c,d);b_3(a,b,c,d,A,B,C,D)-b_3(A,B,C,D,a,b,c,d);c_3(a,b,c,d,A,B,C,D)-c_3(A,B,C,D,a,b,c,d);d_3(a,b,c,d,A,B,C,D)-d_3(A,B,C,D,a,b,c,d);\n//       % evaluate (pq* + qp*)\n//       a_3(a,b,c,d,A,-B,-C,-D)+a_3(A,B,C,D,a,-b,-c,-d);b_3(a,b,c,d,A,-B,-C,-D)+b_3(A,B,C,D,a,-b,-c,-d);c_3(a,b,c,d,A,-B,-C,-D)+c_3(A,B,C,D,a,-b,-c,-d);d_3(a,b,c,d,A,-B,-C,-D)+d_3(A,B,C,D,a,-b,-c,-d);\n\nquat conjugate(quat q)\n{\n    return quat(q.s,-q.v);\n}\n\nfloat norm_squared(quat q)\n{\n    return q.s * q.s + dot(q.v, q.v);\n}\n\nfloat norm(quat q)\n{\n    return sqrt(norm_squared(q));\n}\n\nquat mul(float s, quat q)\n{\n    return quat(s * q.s, s * q.v);\n}\n\nquat div(quat q, float s)\n{\n    return quat(q.s / s, q.v / s);\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat normalify(quat q) // NOTE: can't reuse function name normalize here\n{\n    return div(q, norm(q));\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\n//quat inverse(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat invert(quat q) // NOTE: can't reuse function name inverse here\n{\n    return div(conjugate(q), norm_squared(q));\n}\n\nquat neg(quat q)\n{\n    return quat(-q.s,-q.v);\n}\n\nquat add(quat a, quat b)\n{\n    return quat(a.s + b.s, a.v + b.v);\n}\n\nquat sub(quat a, quat b)\n{\n    return quat(a.s - b.s, a.v - b.v);\n}\n\nquat mul(quat a, quat b)\n{\n    return quat(a.s * b.s - dot(a.v, b.v), a.s * b.v + b.s * a.v + cross(a.v, b.v));\n}\n\nquat div(quat a, quat b)\n{\n    return mul(a, invert(b));\n}\n\nquat angle_axis(float angle, vec3 axis)\n{\n    return quat(cos(angle / 2.0), normalize(axis) * sin(angle / 2.0)); // NOTE: normalize can be omitted in case of unit-vector\n}\n\nquat axis_angle(vec3 axis, float angle)\n{\n    return quat(cos(angle / 2.0), normalize(axis) * sin(angle / 2.0)); // NOTE: normalize can be omitted in case of unit-vector\n}\n\n// Also this looks interesting: http://number-none.com/product/Understanding Slerp, Then Not Using It/\n// \"[...] there are 3 basic properties we often want when interpolating rotations:\n//  commutativity, constant velocity, and minimal torque.\n//  Unfortunately, it seems impossible to get all three at once.\"\n//  Three methods of rotation interpolation:\n//  quaternion SLERP: NOT commutative, constant velocity, torque-minimal\n//  normalized quaternion linear interpolation: commutative, NOT constant velocity, torque-minimal\n//  log-quaternion linear interpolation: commutative, constant velocity, NOT torque-minimal\"\n// Quaternion SLERP adapted from https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/index.htm\nquat slerp(quat qa, quat qb, float t) // NOTE: qa, qb must be unit!\n{\n    // Calculate angle between them.\n    float cosHalfTheta = qa.s * qb.s + dot(qa.v, qb.v);\n    // Unfortunately every rotation can be represented by two quaternions: (++++) or (----)\n    if (cosHalfTheta < 0.0) // avoid taking the longer way: choose one representation\n    {\n        qb = neg(qb); // NOTE: source appears to be missing a minus-sign applied to the z component!\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    // if qa = qb or qa = -qb then theta = 0 and we can return qa\n    if (abs(cosHalfTheta) >= 1.0) // greater-sign necessary for numerical stability\n        return qa;\n\n    // Calculate temporary values.\n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta); // NOTE: we checked above that |cosHalfTheta| < 1\n    // if theta = pi then result is not fully defined\n    // we could rotate around any axis normal to qa or qb\n    if (abs(sinHalfTheta) < 0.001/*some epsilon*/)\n        return add(mul(0.5, qa), mul(0.5, qb));\n\n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    return add(mul(ratioA, qa), mul(ratioB, qb));\n}\n\n/*\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula#Vector_formulation\n    //return p + 2.0 * cross(q.v, cross(q.v, p)) + 2.0 * cross(q.v, q.s * p); // cross-product is distributive\n    //return p + 2.0 * cross(q.v, q.s * p) + 2.0 * cross(q.v, cross(q.v, p)); // vector addition is commutative\n    //return p + 2.0 * q.s * cross(q.v, p) + 2.0 * cross(q.v, cross(q.v, p)); // scalar can be factored-out\n    // translate variable names\n    vec3 x = p;\n    float a = q.s;\n    vec3 omega = q.v;\n    return x + 2.0 * a * cross(omega, x) + 2.0 * cross(omega, cross(omega, x)); // Euler Rodrigues' Formula\n}\n*/\n/*\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula#Statement\n    // translate variable names\n    vec3 v = p;\n    float c = q.s;\n    float s = length(q.v);\n    vec3 k = q.v / s;\n    //return v + 2.0 * cross(s*k, cross(s*k, v) + c * v); // distribute cross-product...\n    //return v + 2.0 * cross(s*k, cross(s*k, v)) + 2.0 * cross(s*k, c * v); // factor-out scalar...\n    //return v + 2.0 * s*s*cross(k, cross(k, v)) + 2.0 * s*c*cross(k, v); // rewrite perpendicular component...\n    // NOTE: apply identity cross(k, cross(k, v)) == dot(v, k) * k - v, the perpendicular component of v with respect to k\n    //return v + 2.0 * s*s*(dot(v, k) * k - v) + 2.0 * s*c*cross(k, v); // swap terms...\n    //return v + 2.0 * s*c*cross(k, v) + 2.0 * s*s*(dot(v, k) * k - v); // distribute product...\n    //return v - 2.0 * s*s*v + 2.0 * s*c*cross(k, v) + 2.0 * s*s*(dot(v, k) * k); // factor-out...\n    //return (1.0 - 2.0 * s*s)*v + 2.0 * s*c*cross(k, v) + 2.0 * s*s*(dot(v, k) * k); // apply trigonometric identities...\n    // NOTE: trigonometric identities\n    // (sin phi)^2 == (1 - cos(2 phi)) / 2\n    // (sin phi)(cos phi) == (sin(2 phi)) / 2\n    // NOTE: this changes the angle by factor two, which cancels-out the half in the angle-axis quaternion definition!\n    //       unfortunately this \"glue-code\" works only for half the angles (reset the timer when comparing both versions!)\n    float S = sin(2.0 * asin(s));\n    float C = cos(2.0 * acos(c));\n    //return (1.0 - (1.0 - C))*v + S*cross(k, v) + (1.0 - C)*(dot(v, k) * k); // cleanup...\n    return C*v + S*cross(k, v) + (1.0 - C)*(dot(v, k) * k); // Rodrigues' Rotation Formula\n}\n*/\n// Rodrigues' Rotation Formula: can be used to rotate a point around an axis. However to combine rotations use quaternions!\nvec3 rotate(float angle, vec3 axis, vec3 point) // NOTE: axis must be unit!\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return c * point + s * cross(axis, point) + (1.0 - c) * (dot(point, axis) * axis); // Rodrigues' Rotation Formula\n}\n\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return mul(mul(q, quat(0.0, p)), invert(q)).v; // NOTE: in case of unit-quaternion reciprocal can be replaced by conjugate\n}\n/*\nvec3 rotate(vec3 p, quat q) // NOTE: using overload with swapped arguments for inverse rotation - is this practical or just confusing?\n{\n    return mul(mul(reciprocal(q), quat(0.0, p)), q).v; // NOTE: in case of unit-quaternion reciprocal can be replaced by conjugate\n    // return 2.0 * (cross(q.v, p) * q.s + dot(q.v, p) * q.v) + (q.s * q.s - dot(q.v, q.v)) * p; // NOTE: multiplying-out & simplifying gives this equation after several steps - a different way to write the Rodrigues' Formula\n}\n*/\n\n// source: https://www.xarg.org/proof/quaternion-from-two-vectors/\nquat rotate_between(vec3 u, vec3 v)\n{\n    float d = dot(u, v);\n    vec3 w = cross(u, v);\n\n    return normalify(quat(d + sqrt(d * d + dot(w, w)), w));\n}\n\nmat3 quat_to_mat3(quat q)\n{\n    return\n        mat3\n        (\n            rotate(q, vec3(1,0,0)),\n            rotate(q, vec3(0,1,0)),\n            rotate(q, vec3(0,0,1))\n        );\n}\n\nmat4 quat_to_mat4(quat q)\n{\n    return\n        mat4\n        (\n            vec4(rotate(q, vec3(1,0,0)), 0.0),\n            vec4(rotate(q, vec3(0,1,0)), 0.0),\n            vec4(rotate(q, vec3(0,0,1)), 0.0),\n            vec4(0.0,    0.0,    0.0,    1.0)\n        );\n}\n\n\nmat4 make_proj_mat(float focal_length)\n{\n    return\n        mat4\n        (\n            vec4(focal_length, 0.0, 0.0, 0.0),\n            vec4(0.0, focal_length, 0.0, 0.0),\n            vec4(0.0, 0.0, 0.0, 1.0),\n            vec4(0.0, 0.0, 0.0, 0.0)\n        );\n}\n\n\n#define pi 3.1415926\n\nvec2 project(mat4 projection, vec3 v)\n{\n    vec4 w = projection * vec4(v, 1.0);\n    return vec2(w) / w.w;\n}\n\nquat yaw_pitch_roll(float Yaw, float Pitch, float Roll)\n{\n    return\n        mul\n        (\n            angle_axis(Pitch, vec3(1,0,0)),\n            mul\n            (\n                angle_axis(Yaw, vec3(0,1,0)),\n                angle_axis(Roll, vec3(0,0,1))\n            )\n        );\n}\n\nquat get_camera_rotation()\n{\n    float Pitch = 0.05 * 2.0 * pi * iTime;\n    float Yaw = 0.2 * 2.0 * pi * iTime;\n    float Roll = 0.3 * 2.0 * pi * iTime;\n\n    return yaw_pitch_roll(Yaw, Pitch, Roll);\n}\n\nvec3 get_camera_position()\n{\n    return vec3(0.5 * cos(0.3 * 2.0 * pi * iTime), 0.5 * sin(0.2 * 2.0 * pi * iTime), 1.0);\n}\n\nfloat draw_line(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\nfloat draw_quad(vec2 A, vec2 B, vec2 C, vec2 D, vec2 p)\n{\n    return min(min(draw_line(A, B, p), draw_line(B, C, p)), min(draw_line(C, D, p), draw_line(D, A, p)));\n}\n/*\nfloat draw_diagonals(vec2 A, vec2 B, vec2 C, vec2 D, vec2 p)\n{\n    return min(draw_line(A, C, p), draw_line(B, D, p));\n}\n\nfloat spot(float s, vec2 q, vec2 p)\n{\n    vec2 a = vec2( s, s);\n    vec2 b = vec2(-s, s);\n    return draw_diagonals(q - a, q - b, q + a, q + b, p);\n}\n*/\nfloat draw_cube(mat4 projection, quat camera_rotation, vec3 camera_translation, vec3 cube_position, float cube_size, vec2 p)\n{\n    vec3 v000 = cube_position + vec3(-1,-1,-1) * cube_size;\n    vec3 v001 = cube_position + vec3(-1,-1,+1) * cube_size;\n    vec3 v010 = cube_position + vec3(-1,+1,-1) * cube_size;\n    vec3 v011 = cube_position + vec3(-1,+1,+1) * cube_size;\n    vec3 v100 = cube_position + vec3(+1,-1,-1) * cube_size;\n    vec3 v101 = cube_position + vec3(+1,-1,+1) * cube_size;\n    vec3 v110 = cube_position + vec3(+1,+1,-1) * cube_size;\n    vec3 v111 = cube_position + vec3(+1,+1,+1) * cube_size;\n\n    vec2 V000 = project(projection, rotate(camera_rotation, v000) + camera_translation);\n    vec2 V001 = project(projection, rotate(camera_rotation, v001) + camera_translation);\n    vec2 V010 = project(projection, rotate(camera_rotation, v010) + camera_translation);\n    vec2 V011 = project(projection, rotate(camera_rotation, v011) + camera_translation);\n    vec2 V100 = project(projection, rotate(camera_rotation, v100) + camera_translation);\n    vec2 V101 = project(projection, rotate(camera_rotation, v101) + camera_translation);\n    vec2 V110 = project(projection, rotate(camera_rotation, v110) + camera_translation);\n    vec2 V111 = project(projection, rotate(camera_rotation, v111) + camera_translation);\n\n    return\n        min\n        (\n            min\n            (\n                draw_quad(V000, V001, V011, V010, p),\n                draw_quad(V100, V101, V111, V110, p)\n            ),\n            min\n            (\n                min(draw_line(V000, V100, p), draw_line(V001, V101, p)),\n                min(draw_line(V011, V111, p), draw_line(V010, V110, p))\n            )\n        );\n    /*\n    return\n        min\n        (\n            min\n            (\n                min(spot(0.02, V000, p), spot(0.02, V001, p)),\n                min(spot(0.02, V010, p), spot(0.02, V011, p))\n            ),\n            min\n            (\n                min(spot(0.02, V100, p), spot(0.02, V101, p)),\n                min(spot(0.02, V110, p), spot(0.02, V111, p))\n            )\n        );\n        */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 projection = make_proj_mat(1.0/*focal length*/);\n    //mat4 projection = make_proj_mat(1.0 + 0.5 * cos(iTime)/*focal length*/);\n    //o = projection * view * model * i\n\n    quat camera_rotation = get_camera_rotation();\n    vec3 camera_position = get_camera_position();\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float o = 1.0;\n    o = min(o, draw_cube(projection, camera_rotation, camera_position, vec3(0,0,0)/*cube_position*/, 0.25/*cube_size*/, p));\n\n    vec3 col = vec3(0.0);\n    //col = max(col, mix(vec3(1.0), vec3(0.0), smoothstep(0.00, 0.01, o)));\n    col = max(col, mix(vec3(1.0), vec3(0.0), smoothstep(0.00, 5./iResolution.y, o)));\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}