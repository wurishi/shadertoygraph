{"ver":"0.1","info":{"id":"4ccGD2","date":"1712118140","viewed":81,"name":"A1 Kaleidoscope effect","username":"raphaeleg","description":"-----\npurely for self-learning purposes\nFollowing the tutorial: https://www.shadertoy.com/view/mtyGWy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sdf","repetition","code"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D signed distance functions\nfloat sdfCircle(vec2 p, float radius) { \n    // float d = length(uv);\n    // d-=0.5; // d = radius.\n    return length(p) - radius;\n    // sin because positive outside shape, negative inside, 0 at boundary\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 palette(float t) { \n    vec3 a = vec3(0.5,0.5,0.5); \n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    return a+b*cos(6.28318*(c*t+d));\n}\n\n// Display a color on screen\nvec4 v1_0() {\n    // Black\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\nvec4 v1_1(in vec2 fragCoord) {\n    // red gradient along x\n    vec2 uv = fragCoord / iResolution.xy; // REPLACED IN 2.1\n    return vec4(uv.x, 0.0, 0.0, 1.0);\n}\nvec4 v1_2(in vec2 fragCoord) {\n    // blue gradient along x\n    vec2 uv = fragCoord / iResolution.xy; // REPLACED IN 2.1\n    return vec4(0.0, 0.0, uv.x, 1.0);\n}\nvec4 v1_3(in vec2 fragCoord) {\n    // green gradient along y\n    vec2 uv = fragCoord / iResolution.xy; // REPLACED IN 2.1\n    return vec4(0.0, uv.y, 0.0, 1.0);\n}\n// Display traditional UV map\nvec4 v2_0(in vec2 fragCoord) {\n    // #traditional uv map: gradient from 0~1\n    vec2 uv = fragCoord / iResolution.xy; // REPLACED IN 2.1\n    return vec4(uv, 0.0, 1.0);\n}\nvec4 v2_1(in vec2 fragCoord) {\n    // #traditional uv map: gradient from -1~1\n    // #with the original 0~1, the ccenter is (0.5,0.5) -> make the center (0,0) by shifting 0.5\n    // #now the corners are from -0.5~0.5, to make it 1, *2\n    // uv = (uv - 0.5) * 2.0; \n    \n    // #To clean this up,\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0; // REPLACED IN 3.1\n    return vec4(uv, 0.0, 1.0);\n}\n// Display a circle\nvec4 v3_0(in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0; // REPLACED IN 3.1\n    float radius = 0.5;\n    // #length() = distance between point and origin\n    float d = sdfCircle(uv, radius);\n    // float d = sdBox(uv, vec2(0.5, 0.5));\n    // #applying this on red channel -> 0/neg at center, 1 out of radius\n    return vec4(d, 0.0, 0.0, 1.0);\n}\nvec4 v3_1(in vec2 fragCoord) {\n    // #to keep square aspect ratio\n    // uv.x *= iResolution.x / iResolution.y; // to clean this up,\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    // #something interesting:\n    // vec2 uv = (fragCoord * 2.0 - iResolution.x) / iResolution.y;\n    // vec2 uv = (fragCoord * 2.0 - iResolution.x) / iResolution.x;\n    float radius = 0.5;\n    float d = sdfCircle(uv, radius);\n    return vec4(d, d, d, 1.0);\n}\nvec4 v3_2(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float radius = 0.5;\n    float d = sdfCircle(uv, radius);\n    d = abs(d); // #if we want the inner part not filled\n    return vec4(d, d, d, 1.0);\n}\nvec4 v3_3(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float radius = 0.5;\n    float d = sdfCircle(uv, radius);\n    d = abs(d);\n    // #if we want to see sharper edge. use step\n    // #step = (2 states, 0 if below threshold, 1 otherwise)\n    // #step can be considered width of outline of circle\n    d = step(0.1,d); // rim.\n    // d = step(radius,d); // full circle\n    return vec4(d, d, d, 1.0);\n}\nvec4 v3_4(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float radius = 0.5;\n    float d = sdfCircle(uv, radius);\n    d = abs(d);\n    // smoothstep = gradient in between two values\n    d = smoothstep(0.0, 0.1, d); // small smooth ring\n    return vec4(d, d, d, 1.0);\n}\n// Display a oscillating animation with varying glow colors\nvec4 v4_0(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    float freq = 8.0; // multiplying this value before sin = stretches space and higher intensity\n    d = sin(d*freq)/freq; // instead of length(uv) - radius, osillate\n    d = abs(d);\n    d = smoothstep(0.0,0.1,d);\n    return vec4(d, d, d, 1.0);\n}\nvec4 v4_1(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    float freq = 8.0;\n    d = sin(d*freq + iTime)/freq; // offset value by iTime before sin\n    d = abs(d);\n    d = smoothstep(0.0,0.1,d);\n    return vec4(d, d, d, 1.0);\n}\nvec4 v4_2(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    float freq = 8.0;\n    d = sin(d*freq + iTime)/freq;\n    d = abs(d);\n    d = 0.02/d; // to get a pleasant glow effect\n    return vec4(d, d, d, 1.0);\n}\nvec4 v4_3(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    float freq = 8.0;\n    d = sin(d*freq + iTime)/freq;\n    d = abs(d);\n    d = 0.02/d;\n   \n    vec3 col = vec3(1.0,0.0,0.0); // #tints everything to red\n    col *= d;\n    return vec4(col, 1.0);\n}\nvec4 v4_4(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    float freq = 8.0;\n    d = sin(d*freq + iTime)/freq;\n    d = abs(d);\n    d = 0.02/d;\n    \n    vec3 col = vec3(1.0,2.0,3.0); // blue has bighest value -> glows more\n    col *= d;\n    return vec4(col, 1.0);\n}\nvec4 v4_5(in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    \n    float freq = 8.0;\n    vec3 col = palette(d+iTime);\n    \n    d = sin(d*freq + iTime)/freq; // using palette and passing d, iTime for more dynamic\n    d = abs(d);\n    d = 0.02/d;\n    \n    col *= d;\n    return vec4(col, 1.0);\n}\n// Display a repeating image\nvec4 v5_0(in vec2 fragCoord) {\n    vec2 globalUv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    // fract() returns fractional part of input, extracting digits only in decimal point\n    //vec2 localUv = fract(globalUv);\n    // we center it with *2.0-0.5\n    vec2 localUv = globalUv;\n    localUv = fract(localUv * 2.0) - 0.5;\n    \n    float d = length(localUv);\n    float freq = 8.0;\n    vec3 col = palette(d+iTime);\n    \n    d = sin(d*freq + iTime)/freq; \n    d = abs(d);\n    d = 0.02/d;\n    \n    col *= d;\n    return vec4(col, 1.0);\n}\nvec4 v5_1(in vec2 fragCoord) {\n    vec2 globalUv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 localUv = globalUv;\n    localUv = fract(localUv * 2.0) - 0.5;\n    \n    vec3 finalCol = vec3(0.0); // separating col into finalcol for better tracking\n    \n    float d = length(localUv);\n    float freq = 8.0;\n    // we want the color palette to move across the screen and not relative to each circle\n    vec3 col = palette(length(globalUv)+iTime);\n    \n    d = sin(d*freq + iTime)/freq; \n    d = abs(d);\n    d = 0.02/d;\n    \n    finalCol += col * d;\n    return vec4(finalCol, 1.0);\n}\n// Fractal effect and coloring\nvec4 v6_0(in vec2 fragCoord) {\n    vec2 globalUv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 localUv = globalUv;\n    vec3 finalCol = vec3(0.0);\n    \n    // each iteration involves scaling and repeating the space + adds resultings color together\n    for (float i = 0.0; i < 3.0; i++) {\n        localUv = fract(localUv * 2.0) - 0.5;\n        float d = length(localUv);\n        float f = 0.3;\n        vec3 col = palette(length(globalUv)+iTime*f);\n        \n        float a = 8.0;\n        \n        d = sin(d*a + iTime)/a; // reduce frequency of time\n        d = abs(d);\n        d = 0.02/d;\n\n        finalCol += col * d;\n    }\n    \n    return vec4(finalCol, 1.0);\n}\nvec4 v6_1(in vec2 fragCoord) {\n    vec2 globalUv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 localUv = globalUv;\n    vec3 finalCol = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        localUv = fract(localUv * 1.5) - 0.5; // break symmetry with decimal number\n        float d = length(localUv);\n        float f = 0.3;\n        vec3 col = palette(length(globalUv)+iTime*f);\n        \n        float a = 8.0;\n        \n        d = sin(d*a + iTime)/a;\n        d = abs(d);\n        d = 0.02/d;\n\n        finalCol += col * d;\n    }\n    \n    return vec4(finalCol, 1.0);\n}\nvec4 v6_2(in vec2 fragCoord) {\n    vec2 globalUv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 localUv = globalUv;\n    vec3 finalCol = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) { // more details\n        localUv = fract(localUv * 1.5) - 0.5;\n        // does a smooth transition that blends with the other effects\n        float d = length(localUv) * exp(-length(globalUv));\n        float f = 0.3;\n        vec3 col = palette(length(globalUv) + i*f + iTime*f); // further variation with i\n        \n        float a = 8.0;\n        \n        d = sin(d*a + iTime)/a;\n        d = abs(d);\n        d = 0.01/d; // make it less bright\n\n        finalCol += col * d;\n    }\n    \n    return vec4(finalCol, 1.0);\n}\nvec4 v6_3(in vec2 fragCoord) {\n    vec2 globalUv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 localUv = globalUv;\n    vec3 finalCol = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        localUv = fract(localUv * 1.5) - 0.5;\n        float d = length(localUv) * exp(-length(globalUv));\n        float f = 0.3;\n        vec3 col = palette(length(globalUv) + i*f + iTime*f);\n        \n        float a = 8.0;\n        \n        d = sin(d*a + iTime)/a;\n        d = abs(d);\n        d = pow(0.01/d, 1.2); // gamma color filtering, accentuate dark background\n\n        finalCol += col * d;\n    }\n    \n    return vec4(finalCol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = v6_3(fragCoord);\n}","name":"Image","description":"","type":"image"}]}