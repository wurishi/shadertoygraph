{"ver":"0.1","info":{"id":"Xf2yR3","date":"1722712799","viewed":132,"name":"Oxidation","username":"Elsio","description":"\nModifiquei um pouquinho o shader do mestre Shane","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","voxel","cell","shane","traversal"],"hasliked":0,"parentid":"csKyzd","parentname":"Subdivided Voxel Raymarching"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define normal(p) normalize(map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)))\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define t iTime * 3.\n#define FAR 140.\n\nfloat gcd, id;\nvec3 gD;\n\nvec2 path(float z) {\n    float a = sin(z * .3);\n    float b = cos(z * .2);\n    return .1 * vec2(5, 7) * vec2(a, b) +\n           .2 * vec2(7, 6) * vec2(b, a);\n}\n\nfloat box(vec3 p, vec3 b, float sf) {\n    p = abs(p) - b + sf;\n    return length(max(p, 0.)) - sf;\n}\n\n\nvec3 Dir(vec3 p){\n    vec3 d = abs(p);\n    return step(d.yzx, d.xyz) * step(d.zxy, d.xyz) * sign(p);\n}\n\n\n\n\nbool tunel(vec3 p, float g) {\n    p.xy -= path(p.z);\n    return \n        // not tunnel\n        max(\n             2.5 - length(p.xy), // tunnel \n             texture(iChannel0, p / 300.) .x - .55) < 0. // cubemap\n        \n        // not tunel for frame \n        && (g == 1.? true: cos(p.x) > .0) ;\n}\n\nfloat gCD(vec3 p){\n    vec3 g = (sign(gD) * .5 - p) / gD;\n    return max(min(min(g.x, g.y), g.z), 0.) + .0015;\n}\n\nfloat map(vec3 p) {\n    vec3 k = floor(p) + .5,\n         q = fract(p) - .5,\n         d = Dir(q);\n\n    //return gCD(q) - .001;\n    gcd = gCD(q);\n    \n    // walls\n    // bool c1 = cos(k.y) > .9 || cos(k.x) > .94 || cos(k.z) > .94;\n    \n    bool c1 = step( // same as above\n                  cos(k), vec3(.92, .94, .8)) != vec3(1),\n         \n         // metalic blocks\n         c2 = step(cos(k), vec3(.02)) == vec3(0),\n         c3 = k.x > .5;\n         \n         \n    float none = 1e5, \n          barra = none,\n          bloco = tunel(k, 1.) && c1 // tunnel in the wall\n                      ? box(q, vec3(.5), .05)\n                      : none;\n    \n    // frames in the frame\n    barra = tunel(k, 2.)\n              ? tunel(k + d, 2.) // if neig\n                  ? min( box(q, abs(d) + .08, .05), // node + frame\n                         barra) \n                  : box(q, vec3(.11), .07) // only node\n              : none;\n    \n    id = step(barra, bloco) + (c2? 1.: 0.);\n    \n    return min(barra, bloco);\n}\n\n\n\nfloat march(vec3 ro) {\n    vec3 p;\n    float i, s, d;\n    while(i++ < 128.) {\n        p = ro + d * gD;\n        s = min(map(p), gcd);\n        if(abs(s) < .001 || d > FAR) break;\n        d += s;\n    }\n    return min(d, FAR);\n}\n\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k) {\n    const int maxIterationsShad = 48;\n    ro += n * .0015;\n    vec3 rd = lp - ro;\n    float shade = 1.;\n    float d = 0.;\n    float end = max(length(rd), .0001);\n    rd /= end;\n    \n    gD = rd;\n    \n    for(int i = min(iFrame, 0); i < maxIterationsShad;i ++) {\n        float p = map(ro + rd * d);\n        shade = min(shade, k * p / d);\n        d += clamp(min(p * .9, gcd), .02, .25);\n        \n        if(d < 0. || d > end) break;\n    }\n    return max(shade, 0.);\n}\n\n\n\n\n// shane\nvec4 tex3D(sampler2D tex, vec3 p, vec3 n) {\n    n = max(n * n - .2, .001);\n    n /= dot(n, vec3(1));\n    vec3 tx = texture(tex, p.zy).xyz;\n    vec3 ty = texture(tex, p.xz).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return (mat3(tx * tx, ty * ty, tz * tz) * n).xyzz;\n}\n\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//                                                          -- shane\n\nfloat D_GGX(vec3 n, vec3 v, vec3 l) {\n    float roughness = .4;\n    vec3 h = normalize(v + l);\n    float NoH = clamp(dot(n, h), .001, 1.);\n    float alpha = pow(roughness, 4.);\n    float b = (NoH * NoH * (alpha - 1.) + 1.);\n    return alpha /(3.14 * b * b);\n}\n\n\n// shane\nfloat G_Smith(vec3 n, vec3 v, float NoL) {\n    float roughness = .4;\n    float k = .12 * roughness * roughness +  .25 * roughness + .12;\n    \n    float NoV = clamp(dot(n, v), .001, 1.); \n    float gl = NoL / (NoL + (1. - NoL) * k);\n    float gv = NoV / (NoV * (1. - k) + k);\n    return gl * gv / (4. * NoV);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n         u = (u - r * .5) / r.y;\n         \n    vec3 ro, eye, L, \n         fw, ri, up, D, p, N, col, e, cor;\n    \n    float FOV = .9, \n          d;\n    \n    ro  = vec3(0, 0, t);\n    eye = ro + vec3(0, 0, 1);\n    L   = ro + vec3(0, .5, 2);\n    \n    eye.xy += path(eye.z);\n    ro.xy  += path(ro.z);\n    L.xy   += path(L.z);\n    \n    fw = normalize(eye - ro),\n    ri = normalize(vec3(fw.z, 0., - fw.x)),\n    up = cross(fw, ri),\n    D = normalize(u.x * ri + u.y * up + fw / FOV),\n    e = vec3(.01, 0, 0);\n    \n    if(length(iMouse.xy) > 40.) {\n        D.xz *= rot(iMouse.x / r.x * 3.14 * 2. - 3.14);\n        D.yz *= rot(iMouse.y / r.y * 3.14 - 3.14 * .5);\n    }\n    \n    else{\n        D.xz *= rot(cos(t * .03));\n        D.yz *= rot(sin(t * .03));\n    }\n    \n    gD = D;\n    \n    d = march(ro);\n    \n    if(d < FAR) {\n        float id = id;\n        vec3  p = ro + d * D,\n              N = normal(p), \n              ld = L - p,\n              col;\n        \n        float shad = softShadow(p, L, N, 8.),\n              lDist = max(length(ld), .0001),\n              atten = 30. / (30. + lDist * lDist),\n              ambience = smoothstep(- 1., 1., N.y) * .5,\n              BRDF = clamp(dot(N, ld / lDist), .001, 1.);\n        \n        if(id > 0.) {\n            o = .3 * vec4(8, 7, 6, 0) * tex3D(iChannel1, p / 9., N);\n            BRDF = G_Smith(N, -D, BRDF) * 3.14;\n            if(mod(p.z, 18.*3.14) > 9.*3.14) \n                BRDF = D_GGX(N, -D, ld / lDist) * 2.;\n        } \n        else \n            o = 2. * tex3D(iChannel1, p / 3., N) + .3;\n        \n        o *= (ambience + BRDF * shad) * atten;\n    }\n    o = sqrt(o);\n}","name":"Image","description":"","type":"image"}]}