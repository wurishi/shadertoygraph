{"ver":"0.1","info":{"id":"XcjSRW","date":"1706099411","viewed":57,"name":"star not goog","username":"zhy437488627","description":"simple","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 规范化坐标（从 0 到 1）\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 adjustedUV = uv * 2.0 - 1.0;\n    //uv = uv * 2.0 - 1.0; // 将 uv 映射到 -1 到 1 的范围\n    //uv.x *= iResolution.x / iResolution.y; // 纠正宽高比\n    adjustedUV.x *= iResolution.x / iResolution.y;\n\n    // 生成背景色\n    vec3 backgroundColor = vec3(0.02, 0.02, 0.05); // 深蓝色的夜空\n\n    // 初始化颜色\n    vec3 color = backgroundColor;\n\n    // 星星的参数\n    float time = iTime * .9; // 时间参数，用于控制闪烁\n    float starDensity = 0.21; // 星星的密度\n    float moveSpeed = -0.003;\n    // 生成星星\n    for (int i = 0; i < 100; i++) {\n        // 随机位置\n        float a = fract(sin(float(i) * 123.456) * 7654.321 + time * moveSpeed);\n        float b = fract(cos(float(i) * 345.678) * 1234.567);\n        vec2 starPos = vec2(a, b) * 2.0 - 1.0;\n        starPos.x *= iResolution.x / iResolution.y;\n\n        // 计算星星与当前像素的距离\n        float dist = length(adjustedUV - starPos);\n        float randomSize = fract(sin(float(i) * 543.210) * 1234.567);\n\n        // 根据距离计算星星大小\n        float size = (randomSize * 0.0002) / (dist * dist);\n\n        // 决定哪些星星会闪烁\n        bool twinklingStar = fract(sin(float(i) * 12.345) * 5432.1) > 0.8;\n\n        // 如果星星是闪烁的，则添加闪烁效果\n        if (twinklingStar) {\n            size *= (0.2 + sin(time + float(i)) * 0.8);\n        }\n        vec3 starColor = fract(sin(float(i) * 54.321)) > 0.2 ? vec3(1.0, 1.0, 1.0) : vec3(0.2, 1.0, 0.9);\n\n        // 添加星星颜色（白色）\n        color += vec3(size) * starDensity * starColor;\n    }\n\n    // 输出最终颜色\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}