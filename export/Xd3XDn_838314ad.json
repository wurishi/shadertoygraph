{"ver":"0.1","info":{"id":"Xd3XDn","date":"1458761415","viewed":203,"name":"methane","username":"samuelotherion","description":"this is really old and far away of beeing finished. if i had more time maybe i would make something useful of it. now its just for inspiration. u can try to get that thing behind the moving wall or something like that. but u can only touch balls u can c. ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","simulation","springs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define F\t\t\tfloat\n#define V2\t\t\tvec2\n#define V3    \t\tvec3\n#define V4    \t\tvec4\n#define PX( p )\t\ttexture( iChannel0, p )\n\n#define T\t\t\tiTime\n#define R\t\t\tiResolution.xy\n\n#define Ri  ( 1. / R )\n#define A   ( V2( R.x * Ri.y, 1 ) )\n\nV2\n    I,\n    N;\n\nV4\n    O;\n\nvoid\n    paint( ) {\n  \n\n        O = 41. * PX( N );\n        \n        O += 26. * ( PX( Ri * V2( I.x - 1., I.y ) ) + PX( Ri * V2( I.x + 1., I.y ) ) + PX( Ri * V2( I.x, I.y - 1. ) ) + PX( Ri * V2( I.x, I.y + 1. ) ) );\n        O += 16. * ( PX( Ri * V2( I.x - 1., I.y - 1. ) ) + PX( Ri * V2( I.x - 1., I.y + 1. ) ) + PX( Ri * V2( I.x + 1., I.y - 1. ) ) + PX( Ri * V2( I.x + 1., I.y + 1. ) ) );\n        O += 7. * ( PX( Ri * V2( I.x - 2., I.y ) ) + PX( Ri * V2( I.x + 2., I.y ) ) + PX( Ri * V2( I.x, I.y - 2. ) ) + PX( Ri * V2( I.x, I.y + 2. ) ) );\n        O += 4. * ( PX( Ri * V2( I.x - 2., I.y - 1. ) ) + PX( Ri * V2( I.x - 2., I.y + 1. ) ) + PX( Ri * V2( I.x - 1., I.y - 2. ) ) + PX( Ri * V2( I.x - 1., I.y + 2. ) ) + \n                   \tPX( Ri * V2( I.x + 1., I.y - 2. ) ) + PX( Ri * V2( I.x + 1., I.y + 2. ) ) + PX( Ri * V2( I.x + 2., I.y - 1. ) ) + PX( Ri * V2( I.x + 2., I.y + 1. ) ) );\n        O += 1. * ( PX( Ri * V2( I.x - 2., I.y - 2. ) ) + PX( Ri * V2( I.x - 2., I.y + 2. ) ) + PX( Ri * V2( I.x + 2., I.y - 2. ) ) + PX( Ri * V2( I.x + 2., I.y + 2. ) ) );\n        \n        O /= 273.;\n\n//        O = PX( N );        \n    }\n        \nvoid\n    mainImage( out V4 o, V2 i ) {\n        \n\n        N = Ri * ( I = i );\n\n        paint( );\n\n        o = O;\n\t}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define F\t\t\tfloat\n#define V2\t\t\tvec2\n#define V3    \t\tvec3\n#define V4    \t\tvec4\n#define R\t\t\tiResolution.xy\n#define Ri\t\t\t1. / R\n#define A         \tV2( R.x * Ri.y, 1 )\n#define T\t\t\tiTime\n#define PX( p )\t\ttexture( iChannel0, p )\n#define CHK\t\t\tif( any( greaterThan( I, vec2( CNT, 9 ) ) ) ) discard;\n\n#define PCNT\t\t5.\n#define SCNT\t\t10.\n#define DT\t\t\t1e-0 / 60.\n#define _0\t\t\tV4( 0 )\n#define _1\t\t\tV4( 1 )\n#define X\t\t\tV3( -1, 0, 1 )\n#define DAMP\t\t16.\n#define G\t\t\tV3( 0, -10, 0 )\n\n#define IDSKY       0\n#define IDPLANE     1\n#define IDBALL      2\n#define IDSPRING    3\n#define IDLIGHT     4\n\nconst F\n    CNT = 1. + ( SCNT < PCNT ? PCNT : SCNT );\n\nV2\n    I,\n    N,\n    J;\n\nV3\n    P;\n\nV4\n    O = _0;\n\nbool\n    eq( F a, F b ) {\n     \n        return floor( a + .1 ) == floor( b + .1 );\n    }\n\nvoid\n    poke( V2 p, V4 v ) {\n     \n        if( floor( p ) == floor( I ) ) \n            \n            O = v;\n    }\n\nvoid\n    poke( F x, F y, V4 v ) {\n        \n        poke( V2( x, y ), v );\n    }\n\nV4\n    peek( V2 p ) {\n        \n        return PX( Ri * ( .5 + p ) );\n    }\n\nV4\n    peek( F x, F y ) {\n        \n        return peek( floor( .1 + V2( x, y ) ) );\n    }\n\nbool\n    mouseClicked( ) {\n        \n        return 0. < iMouse.z;\n    }\n\nvoid\n    init( ) {\n        \n        CHK\n\n        poke( 0., 0., _0 );\n        poke( 0., 1., _0 );\n        poke( 0., 2., _0 );\n        poke( 0., 3., _0 );\n        poke( 0., 4., _0 );\n        poke( 0., 5., _0 );\n        \n        F\n            k1 = 3e2,\n            k2 = 2e2;\n        F\n            h = sqrt( .75 ),\n            m = sqrt( 2. / 3. ),\n            d = h - m;\n        \n        //                 k   l   f  t \n        poke(  1., 0., V4( k1, 1., 1, 2 ) );\n        poke(  2., 0., V4( k1, 1., 2, 3 ) );\n        poke(  3., 0., V4( k1, 1., 3, 1 ) );\n        poke(  4., 0., V4( k1, 1., 1, 4 ) );\n        poke(  5., 0., V4( k1, 1., 2, 4 ) );\n        poke(  6., 0., V4( k1, 1., 3, 4 ) );\n        poke(  7., 0., V4( k2, 3. / 4. * m, 1, 5 ) );\n        poke(  8., 0., V4( k2, 3. / 4. * m, 2, 5 ) );\n        poke(  9., 0., V4( k2, 3. / 4. * m, 3, 5 ) );\n        poke( 10., 0., V4( k2, 3. / 4. * m, 4, 5 ) );\n        \n        //                    rx   ry             rz             m\n        poke( 1., 1., V4( V3( -.5, 1.5,           -1.         ), 1. ) );\n        poke( 2., 1., V4( V3(  .5, 1.5,           -1.         ), 1. ) );\n        poke( 3., 1., V4( V3(  .0, 1.5,           h - 1.      ), 1. ) );\n        poke( 4., 1., V4( V3(  .0, 1.5 + m,       h / 3. - 1. ), 1. ) );\n        poke( 5., 1., V4( V3(  .0, 1.5 + .25 * m, h / 3. - 1. ), .25 ) );\n        \n        //            velocity \n        poke( 1., 2., _0 );\n        poke( 2., 2., _0 );\n        poke( 3., 2., _0 );\n        poke( 4., 2., _0 );\n        poke( 5., 2., _0 );\n\n        //            acceleration\n        poke( 1., 3., _0 );\n        poke( 2., 3., _0 );\n        poke( 3., 3., _0 );\n        poke( 4., 3., _0 );\n        poke( 5., 3., _0 );\n        \n\t\t//                i0 i1 i2 i3\n        poke( 1., 4., V4( 1, 3, 4,  7 ) );\n        poke( 2., 4., V4( 1, 2, 5,  8 ) );\n        poke( 3., 4., V4( 2, 3, 6,  9 ) );        \n        poke( 4., 4., V4( 4, 5, 6, 10 ) );        \n        poke( 5., 4., V4( 7, 8, 9, 10 ) );        \n\n        poke( 1., 5., -_1 );\n        poke( 2., 5., -_1 );\n        poke( 3., 5., -_1 );  \n        poke( 4., 5., -_1 );\n        poke( 5., 5., -_1 );\n        \n        poke(  0., 6., V4( .5, 0,0,0 ) );\n        poke(  1., 6., X.yyyz );\n        poke(  2., 6., X.yyzy );\n        poke(  3., 6., X.yyzz );\n        poke(  4., 6., X.yzyy );\n        poke(  5., 6., X.yzyz );\n        poke(  6., 6., X.yzzy );\n        poke(  7., 6., X.yzzz );\n        poke(  8., 6., X.zyyy );\n        poke(  9., 6., X.zyyz );\n        poke( 10., 6., X.zyzy );\n        \n        poke(  0., 7., X.zyzz );\n        poke(  1., 7., X.zzyy );\n        poke(  2., 7., X.zzyz );\n        poke(  3., 7., X.zzzy );\n        poke(  4., 7., X.zzzz );\n        poke(  5., 7., X.zyzy );\n        poke(  6., 7., X.zzyy );\n        poke(  7., 7., X.zzzy );\n        poke(  8., 7., X.zyyz );\n        poke(  9., 7., X.zyyz );\n        poke( 10., 7., X.zyyy );\n}\n\nV4\n    acc( F x, F id ) {\n        \n        if( id < 0. ) \n            \n            return _0;\n        \n        V4\n            s  = peek( id, 0. );\n\n        F\n            f = eq( s.z, x ) ? s.z : s.a,\n            t = eq( s.z, x ) ? s.a : s.z;\n        V4\n            p1 = peek( f, 1. );\n        \n        if( p1.a < 0. )\n            \n            return _0;\n        \n        V4\n            p2 = peek( t, 1. ),\n            v  = peek( f, 2. );\n        \n        V3\n            r  = p2.xyz - p1.xyz;\n        \n        F\n            d2 = dot( r, r ),\n            d = sqrt( d2 );\n        V3\n            a   = ( s.x * ( d - s.y ) / ( p1.a * d ) - DAMP * dot( v.xyz, r ) / d2 ) * r;\n        \n        return V4( a + G, 0 );\n    }\n\n\nvoid\n    sim( ) {\n        \n        CHK\n\n\t\tconst F\n            period = 3.;            \n            \n        V4\n            bV = peek( 0., 0. );\n        \n        F\n            burst = floor( bV.x + .1 );\n        \n        if( .0 < I.x && I.x < 1. ) {\n            \n            \n            if( I == V2( .5 ) ) {\n                \n                bV.x = floor( mod( burst + 1.1, period ) );\n                \n                poke( 0., 0., bV );\n\n                return;\n            }\n            \n            for( int i = 1; i <= int( period ); ++i ) {\n                \n                F\n                    fi = F( i );\n                \n                if( fi == floor( I.y ) ) {\n\n                    poke( 0., fi, floor( fi - .9 ) == burst ? V4( 1 ) : V4( 0 ) );\n\n                    return;\n                }\n            }\n        }\n            \n        if( 1. < I.x && I.x < PCNT + 1. ) {\n            \n                V2\n                    i = floor( I );\n\n            if( 1. <= I.y && I.y < 3. && i.y == burst ) {\n\n                F\n                    p = -1.;\n                \n                V4\n                    rm = peek( i.x, 1. );\n\n                V4\n                    gm = peek( i );\n\n                V3\n                    g = gm.xyz;\n                \n                F\n                    m   = rm.a,\n                    rad = .2 * pow( m, 1. / 3. );\n\n                if( 0. < m ) {\n\n                    V3\n                        dgdt = peek( i.x, i.y + 1. ).xyz,\n                        dg   = dgdt * DT,\n                        gn   = g + dg;\n\n                    if( i.y == 1. ) {\n\n                        if( gn.y < rad - 1. && dg.y < 0. ) {\n\n//                            gn.y = rad - 1.;\n                            dg.y = ( 2. * ( rad - 1. - g.y ) - dg.y ) * .95;\n                        }\n                    }\n                    else {\n\n                        if( rm.y < rad - 1. ) {\n\n                            dg.y = abs( dg.y );\n                        }\n                    }\n                    \n                    gn = g + dg;\n                    O  = V4( gn, m );\n                }            \n                else\n\n                    O = gm;\n\n                return;            \n            }\n\n            if( 3. <= I.y && I.y < 4. && burst == 0. ) {\n\n                V2\n                    i = floor( I );\n\n                V4\n                    k = peek( i.x, 4. );\n\n                O = acc( I.x, k.r ) +\n                    acc( I.x, k.g ) +\n                    acc( I.x, k.b ) +\n                    acc( I.x, k.a );\n\n                    k = peek( i.x, 5. );\n\n                O += acc( I.x, k.r ) +\n                     acc( I.x, k.g ) +\n                     acc( I.x, k.b ) +\n                     acc( I.x, k.a );\n\n                return;\n            }\n        }        \n        O = PX( N );\n    }\n\nvoid\n    hitBall( V3 e, V3 r, V3 p, F rad, inout F l, inout V3 h, inout int i, inout int m, int mm ) {\n\n        V3\n            d = e - p;\n\n        F\n            ab = dot( r, d ),\n            bb = dot( d, d ),\n            ds = ( rad * rad - bb ) + ab * ab;\n\n        if( 0. <= ds ) {\n\n            F\n                ln = ( -ab - sqrt( ds ) );\n\n            if( l < ln || ln < 0.)\n\n                return;\n\n            m = mm;\n            i = IDBALL;\n            l = ln;\n            h = e + l * r;\n        }\n    }\n\nvoid\n    hitBalls( V3 e, V3 r, inout F l, inout V3 h, inout int i, inout int m ) {\n        \n        int\n            pcnt = int( PCNT );\n        \n        V2\n            pc = V2( 1.5 );\n        \n        for( int j = 0; j < 1000; ++j ) {\n            \n            if( pcnt <= j )\n                \n                break;\n            \n            V4\n                pt = PX( Ri * pc );\n            \n            hitBall( e, r, pt.xyz, .2 * pow( pt.a, 1. / 3. ), l, h, i, m, j + 1 );\n            \n            ++pc.x;\n        }\n    }\n\nint\n    picked( inout V3 h ) {\n        \n\t\tint\n            i = IDSKY,\n            m = -1;\n        \n        V3\n            e = V3( 0, 0, 2 ),\n            r = normalize( V3( ( 2. * iMouse.xy * Ri - 1. ) * A, 0 ) - e );\n        \n        F\n            l = 1e5;\n        \n        V3\n            n;\n        \n        hitBalls( e, r, l, h, i, m );\n         \n        return m;\n    }\n\nvoid\n    wrtRam( F f, F h ) {\n        \n        if( 12. < I.x || I.y < 6. || 8. < I.y )\n            \n            return;        \n\n        const V2\n            mem = V2( 0, 6 );\n        \n        V2\n            sw    = V2( 11., 2. ) * V2( iMouse.x * Ri.x, ( h - R.y + iMouse.y ) / h ),\n            swId  = floor( sw ),\n            swVal = fract( sw );\n        \n        V4\n            v = peek( mem + swId );\n        \n        F\n            sel = floor( 4. * swVal.y );\n        \n        if( sel < 2. ) {\n            \n            if( sel < 1. ) {\n                \n                v.r = swVal.x;\n            }\n            else {\n                \n                v.g = swVal.x;\n            }\n        }\n        else {\n            \n            if( sel < 3. ) {\n                \n                v.b = swVal.x;\n            }\n            else {\n\n                v.a = swVal.x;\n            }\n        }\n        \n        poke( mem + swId, v );\n    }\n\nvoid\n    set( ) {\n        \n        V3\n            h;\n        \n        int\n            i = picked( h );\n        \n        if( i < 0 ) {\n            \n            init( );\n         \n            return;\n        }\n        \n        V4\n            px = peek( F( i ), 1. );\n\n        poke( F( i ), 1., V4( h.x, h.y, px.z, px.a ) ); \n    }\n\nvoid\n    run( ) {\n        \n        if( iFrame < 1 )\n            \n            init( );\n            \n        else {\n            \n        \tsim( );\n            \n            if( mouseClicked( ) ) {\n                \n                F\n                    menuFct = peek( 10., 7. ).w,\n                    menuHgt = ( .1 + .9 * menuFct ) * R.y;\n                \n                if( iMouse.y < R.y - menuHgt )\n                    \n                \tset( );\n                \n                else\n             \n                    //poke( 10., 7., V4( peek( 10., 7. ).rgb, iMouse.x * Ri.x ) );\n                    wrtRam( menuFct, menuHgt );\n            }\n        }\n        \n    }\n\nvoid\n    mainImage( out V4 o, V2 i ) {\n     \n        J = i;\n        \n        P = V3( ( 2. * ( N = Ri * ( I = i ) ) - 1. ) * A, 0. );\n\n        run( );\n\n        poke(  10., 6., V4( .5 + .5 * sin( T ), .5 + .5 * cos( T ), .5 + .5 * sin( 1.5 * T ),  .5 + .5 * cos( 1.5 * T ) ) );\n\n        o = O;        \n\t}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define F\t\t\tfloat\n#define V2\t\t\tvec2\n#define V3    \t\tvec3\n#define V4    \t\tvec4\n#define PX( p )\t\ttexture( iChannel0, p )\n#define PXB( p )\ttexture( iChannel1, p )\n#define lt( a, b )\tall( lessThan( a, b ) )\n#define eq( a, b )\tall( equal( a, b ) )\n#define st( a, b )\tall( greaterThan( a, b ) )\n\n#define T\t\t\tiTime\n#define R\t\t\tiResolution.xy\n#define X\t\t\tV3( -1, 0, 1 )\n\n#define IDSKY       0\n#define IDPLANE     1\n#define IDBALL      2\n#define IDSPRING    3\n#define IDLIGHT     4\n\n#define HASHSCALE1  443.8975\n#define HASHSCALE3  vec3( 443.897, 441.423, 437.195 )\n\nbool\n    equ( V2 a, V2 b ) {\n     \n        return floor( a + .1 ) == floor( b + .1 );\n    }\n\n//V2\n#define\tRi  ( 1. / R )\n#define A  ( V2( R.x * Ri.y, 1 ) )\n\nconst V4\n    C = V4( 0, 1, .5, 1.5 );\n\nconst F\n    PCNT = 5.,\n    SCNT = 10.,\n    CNT  = 1. + max( PCNT, SCNT ),\n\tCONT = .5;\n\n// zoom display is 50% of height \n// Z  = 50. / 100. / 5. * R.y,\n//float \n#define    Z  ( .05 * R.y )\n#define    Zi ( 1. / Z )\n\n//Ram size\nconst V2\n    RSZ = V2( CNT, 8. );\n\n//menu size\n//V2\n//#define    MSZ ( V2( R.x, .3 * R.y ) )\n    \nF\n    hash11( F p ) {\n        \n        V3\n            p3  = fract( V3( p ) * HASHSCALE1 );\n    \n        p3 += dot( p3, p3.yzx + 19.19 );\n    \n        return fract( ( p3.x + p3.y ) * p3.z );\n}\n\nF\n    hash13( V3 p ) {\n        \n        p  = fract( p  * HASHSCALE1 );\n    \n        p += dot( p, p.yzx + 19.19 );\n        \n        return fract( ( p.x + p.y ) * p.z);\n}\n\nV3\n    hash31( float p ) {\n        \n        V3\n            p3 = fract( V3( p ) * HASHSCALE3 );\n        \n        p3 += dot( p3, p3.yzx + 19.19 );\n        \n        return fract( V3( ( p3.x + p3.y ) * p3.z, ( p3.x + p3.z ) * p3.y, ( p3.y + p3.z ) * p3.x ) );\n}\n\nV3\n    hash32( V2 p ) {\n        \n        V3\n            p3 = fract( V3( p.xyx ) * HASHSCALE3 );\n        \n        p3 += dot( p3, p3.yxz + 19.19 );\n        \n        return fract( V3( ( p3.x + p3.y ) * p3.z, ( p3.x + p3.z ) * p3.y, ( p3.y + p3.z ) * p3.x ) );\n}\n\nV3\n    hash33( V3 p ) {\n        \n        p = fract( p * HASHSCALE3 );\n    \n        p += dot( p, p.yxz + 19.19 );\n        \n        return fract( V3( ( p.x + p.y ) * p.z, ( p.x + p.z ) * p.y, ( p.y + p.z ) * p.x ) );\n}\n\nV3\n    lgt;\n//    lgt = V3( sin( sin( T ) ), 1. - cos( sin( T ) ), 1. );\n//    lgt = V3( .95 * cos( .4 * T ), .95 * sin( .5 * T ), 1. + 1.95 * sin( .6 * T ) );\n\n//V4\n//    dcl = V4( .9, .7, .5, 1. ),\n//    acl = V4( .2, .4, .6, 1. );\n//#define    dcl  ( V4( .8 + .2 * sin( .4 * T ), .8 + .2 * sin( .2 * T ), .8 + .2 * sin( .1 * T ), 1. ) )\n#define    acl  ( .25 * ( 1. + sin( .083 * T ) ) * V4( 1 ) )\n\nV2\n    I,\n    N;\n\nV3\n    P;\n\nV4\n    O = C.xxxy;\n\nmat3\n    aprj( V3 v ) {\n        \n        return mat3( 1,0,0, 0,1,0, 0,0,1 ) - mat3( v * v.x, v * v.y, v * v.z ) / dot( v, v );\n    }\n\nvoid\n    paintRam( F t ) {\n        \n        if( lt( Z * RSZ, I ) ) \n            \n            return;\n\n        V4\n            p = PX( N * Zi ),\n            o;\n\n        V2\n            q = mod( I * Zi, C.yy );\n        \n        float\n            s = 1. * Zi;\n\n        \n        \n\n        if( q.x < s || q.y < s )\n            \n            o = C.xxxx;\n        \n        else\n\n            if( ( 1. - q.x ) < s || ( 1. - q.y ) < s )\n                \n                o = C.yyyy;\n\n            else\n                \n                if( q.y < .5 )\n                    \n                    o = .5 + CONT * V4( ( ( q.x < .25 ? p.r : 0. ) + ( .25 <= q.x && q.x < .5 ? p.g : 0. ) + ( .5 <= q.x && q.x < .75 ? p.b : 0. ) + ( .75 <= q.x ? p.a : 0. ) ) * C.yyy, 1 );\n                \n                else\n                    \n                    o = .5 + CONT * PX( N * Zi );\n                \n\t\tO.rgb = mix( O.rgb, o.rgb, t );\n    }\n\nbool\n    paintMenu( ) {\n        \n        V2\n            MSZ = V2( R.x, .3 * R.y );\n        \n        MSZ.y = ( .9 * PX( Ri * V2( 10.5, 7.5 ) ).w + .1 ) * R.y;\n        \n        if( I.y < R.y - MSZ.y )\n            \n            return false;\n        \n        V2\n            sw    = V2( 11., 2. ) * V2( I.x - .5, I.y - .5 - R.y + MSZ.y ) / MSZ,\n            swId  = floor( sw ),\n            swVal = fract( sw );\n        \n        V4\n            val = PX( Ri * V2( swId.x + .5, 6.5 + swId.y ) );\n        \n        F\n            sel = floor( 4. * ( sw - swId ).y ),\n            v   = 0.;\n        \n        V3\n            col = X.yyy;\n        \n        if( sel < 2. ) {\n            \n            if( sel < 1. ) {\n                \n                v   = val.r;\n                col = X.zyy;\n            }\n            else {\n                \n                v   = val.g;\n                col = X.yzy;\n            }\n        }\n        else {\n            \n            if( sel < 3. ) {\n                \n                v   = val.b;\n                col = X.yyz;\n            }\n            else {\n\n                v   = val.a;\n                col = X.yyy;\n            }\n        }\n        \n        O = V4( mix( .3 * V3( ( 1. - 8. * ( swVal.x - .5 ) * ( swVal.x - .5 ) ) * col ), .75 *( .5 * X.zzz + col ), exp( 200. * ( 1.2 * ( swVal.x - .1 ) - v ) * ( v - 1.2 * ( swVal.x - .1 ) ) ) ), 1 );\n        \n        return true;\n    }\n\nvoid\n    hitBall( V3 e, V3 r, V3 p, F rad, inout F l, inout V3 h, inout V3 n, inout int i ) {\n\n        V3\n            d = e - p;\n\n        F\n            ab = dot( r, d ),\n            bb = dot( d, d ),\n            ds = ( rad * rad - bb ) + ab * ab;\n\n        if( 0. <= ds ) {\n\n            F\n                ln = -ab - sqrt( ds );\n\n            if( l < ln || ln < 0.)\n\n                return;\n\n            i = IDBALL;\n            l = ln;\n            h = e + l * r;\n            n = normalize( h - p );\n        }\n    }\n\nvoid\n    renderBalls( V3 e, V3 r, inout F l, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n        V2\n            pc = V2( 1.5 );\n        \n        for( int j = 0; j < int( PCNT ); ++j ) {\n            \n            V4\n                pt = PX( Ri * pc );\n            \n            hitBall( e, r, pt.xyz, .2 * pow( pt.a, 1. / 3. ), l, h, n, i );\n            \n            if( ( i == IDBALL ) && s )\n                \n                return;                \n\n            ++pc.x;\n        }\n    }\n\nvoid\n    hitSpring( V3 e, V3 r, V3 p0, V3 p1, F rad, inout F l, inout V3 h, inout V3 n, inout int i ) {\n\n        mat3\n            q = aprj( p1 - p0 );\n        \n        V3\n            a   = e - p0,\n            qa  = q * a;\n        \n        F\n            qaa = dot( a, qa ),\n            qsa = dot( r, qa ),\n            qss = dot( r, q * r ),\n            ds  = qsa * qsa - qss * ( qaa - rad * rad );\n        \n        if( ds < 0. )\n            \n            return;\n        \n        F\n            am  = ( -qsa - sqrt( ds ) ) / qss;\n        \n        if( l < am || am < 0.)\n            \n            return;\n        \n        F\n            ht = dot( a + am * r, ( p1 - p0 ) / dot( p1 - p0, p1 - p0 ) );\n        \n        if( ht < 0. || 1. < ht )\n            \n            return;\n\n        i  = IDSPRING;\n        l  = am;\n        h  = e + am * r;\n        n  = vec3( normalize( q * ( a + am * r ) ) );\n    }\n\nvoid\n    renderSprings( V3 e, V3 r, inout F l, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n        V2\n            sc = V2( 1.5, .5 );\n       \n        for( int j = 0; j < int( SCNT ); ++j ) {\n\n            V4\n                sp = PX( Ri * sc ),\n                pf = PX( Ri * V2( sp.z + .5, 1.5 ) ),\n                pt = PX( Ri * V2( sp.a + .5, 1.5 ) );\n            \n            F\n                d = .095 * ( 1. + sin( .1 * T ) ) / max( 1., 1. + ( distance( pf, pt ) - sp.y ) );\n            \n            hitSpring( e, r, pf.xyz, pt.xyz, d, l, h, n, i );\n            \n            if( ( i == IDSPRING ) && s )\n                \n                return;                \n            \n            ++sc.x;\n        }\n    }\n\nvoid\n    hitPlane( V3 e, V3 r, V3 p, V3 n0, inout F l, inout V3 h, inout V3 n, inout int i ) {\n\n        V3\n            d = p - e;\n        \n        F\n            ln = dot( d, n0 ) / dot( r, n0 );\n\n        if( l < ln || ln <= 0.01 )\n            \n            return;\n\n        l  = ln;\n        i  = IDPLANE;\n        h  = e + l * r;\n        n  = n0;\n    }\n\nvoid\n    renderPlanes( V3 e, V3 r, inout F l, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n        \n        if( ( i == IDPLANE ) && s )\n            \n            return;\n\n        hitPlane( e, r, V3( 0.,  -1., 0. ), V3( 0., +1., 0. ), l, h, n, i );\n//\t\thitPlane( e, r, 10. * PX( Ri * V2( 1.5, 6.5 ) ).a * ( PX( Ri * V2( 1.5, 6.5 ) ).rgb - .5 ), V3( 0, 1, 0 ), l, h, n, i );\n            \n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n\t\thitPlane( e, r, V3( 0., +1.,  0. ), V3( 0., -1., 0. ), l, h, n, i );\n\n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n//        hitPlane( e, r, V3( 0.,  0., -1.5 ), V3( sin( 6.283 * sin( .1 * T ) ), 0., cos( 6.283 * sin( .1 * T ) ) ), l, h, n, i );\n          hitPlane( e, r, V3( 0.,  0., -3.5 + 3. * sin( .1 * T ) + .1 * sin( 12.1 * T ) ), V3( sin( .5 * sin( 2.1 * T ) ), 0., cos( .5 * sin( 2.1 * T ) ) ), l, h, n, i );\n//        hitPlane( e, r, V3( 0.,  0., -1.5 ), V3( 0, 0, 1 ), l, h, n, i );\n\n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n        hitPlane( e, r, V3( -1.,  0., 0. ), V3( 1., 0., 0. ), l, h, n, i );\n\n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n        hitPlane( e, r, V3( +1.,  0., 0. ), V3( -1., 0., 0. ), l, h, n, i );\n    }\n\nvoid\n    rayTrc( V3 e, V3 r, inout F d, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n        renderSprings( e, r, d, h, n, i, s );\n        \n        if( ( i == IDSPRING ) && s )\n            \n            return;\n            \n        renderBalls( e, r, d, h, n, i, s );\n            \n        if( ( i == IDBALL ) && s )\n            \n            return;\n            \n        renderPlanes( e, r, d, h, n, i, s );\n            \n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n        int\n            ilt = IDSKY;\n        \n        hitBall( e, r, lgt, .1, d, h, n, ilt );\n        \n        i = ( ilt == IDBALL ) ? IDLIGHT : i;\n    }\n\nvoid\n    paintWorld( ) {\n        \n\tV4\n        dcl  = V4( .8 + .2 * sin( .4 * T ), .8 + .2 * sin( .2 * T ), .8 + .2 * sin( .1 * T ), 1. );\n    \n    dcl.rgb *=  ( .975 + .05 *hash31( T ) );\n        \n        lgt =\n            sin( .1 * T ) < -.5 \n            \t? V3( sin( sin( T ) ), 1. - cos( sin( T ) ), 1. ) :\n    \t\t\tV3( .95 * cos( .4 * T ), .95 * sin( .5 * T ), 1. + 1.95 * sin( .6 * T ) );\n\n        V3\n            e = V3( 0, 0, 2. + .1 * hash11( fract( T * T ) ) ),\n            r = normalize( P - e );\n        \n        F\n            l = 1e5;\n        \n        V3\n            h,\n            n;\n        \n        int\n            i = IDSKY;\n        \n        bool\n            fstBrk = false;\n        \n        rayTrc( e, r, l, h, n, i, fstBrk );\n\n        if( i == IDSKY ) {\n            \n\t        O +=  V4( .1, .2, .3, 1. );\n            \n            return;\n        }\n        \n        if( i == IDLIGHT ) {\n                \n            O += 1.3 * dcl;\n\n            return;\n        }\n        \n        n = ( n + .1 - .2 * hash13( h ) );\n\n        r = lgt - h;\n\n        if( dot( r, n ) <= 0. ) {\n            \n            O += V4( .5 * clamp( dot( normalize( ( 2. * C.xxy - h ) ), n ), 0., 1. ) * acl.rgb, 1. );\n\n            return;\n        }\n\n        F\n            ln = distance( lgt, h );\n        \n        r /= ln;\n        \n        V3\n            htmp = h,\n            ntmp = n;\n\n\t\tint\n            ilt = IDLIGHT;\n        \n        e = htmp;\n        \n        fstBrk = true;\n        \n        rayTrc( e, r, ln, h, n, ilt, fstBrk );\n\n        if( ilt != IDLIGHT ) {\n            \n            if( i == IDBALL || i == IDSPRING || i == IDPLANE )\n            \n            \tO += V4( .5 * clamp( dot( ( normalize( 2. * C.xxy - htmp ) ), ntmp ), 0., 1. ) * acl.rgb, 1. );\n            \n            return;\n        }\n        \n        O += V4( clamp( dot( ( lgt - htmp ) / ln, ntmp ), 0., 1. ) * dcl.rgb + .5 * clamp( dot( normalize( 2. * C.xxy - htmp ), ntmp ), 0., 1. ) * acl.rgb, 1. );\n    }\n\nvoid\n    paint( ) {\n        \n//\t\tif( paintMenu( ) )\n            \n//            return;\n\n        F\n            t = PX( Ri * V2( .5, 6.5 ) ).r;\n        \n        if( lt( I, RSZ * Z ) ) {\n            \n//        \tif( .9 < t )\n                \n//\t            paintRam( t );\n            \n//            else\n                \n                if( t < .1 )\n                \n                \tpaintWorld( );\n                \n                else {\n                    \n                    paintWorld( );\n//                    paintRam( t );\n                }\n        }\n        else\n            \n            paintWorld( );\n        \n    }\n\nvoid\n    mainImage( out V4 o, V2 i ) {\n        \n        \n        P = V3( ( 2. * ( N = Ri * ( I = i ) ) - 1. ) * A, 0. );\n\n/*        if( .5 < mod( F( iFrame ), 3. ) ) {\n        \n        \to = PXB( N );\n            \n            return;\n        }\n*/        \n        paint( );\n\n        o = O;\n//        o = .15 * O + .85 * PXB( N );\n\t}","name":"Buffer B","description":"","type":"buffer"}]}