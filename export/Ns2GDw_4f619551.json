{"ver":"0.1","info":{"id":"Ns2GDw","date":"1617493680","viewed":83,"name":"Wavy Fun","username":"JennySchub","description":"a little wavy fun","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","waves","hsv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define count 6\n#define freqVar .3\n#define freq 5.\n#define wobble .5\n#define shiftspeed 2.\nfloat x;\nvec2 uv;\nfloat wave(float amp, float size){\n    return (1.-smoothstep(\n        abs(amp*sin(\n            sin(iTime)*amp+freqVar*x*(sin(iTime)+freq)+iTime*shiftspeed\n        )*sin(iTime*wobble) - uv.y),\n        0.,\n        0.1*size\n    ));\n}\n\nfloat psin(float x){\n    return (sin(x)+1.)*.5;\n}\n\n// is this the most efficient? no. Did I figure it out myself? yeah :D\nvec3 hsv2rgb(vec3 hsv){\n    return hsv.z*((1.-hsv.y) + hsv.y * vec3(\n        max(0.,min(1.,1.5-abs(6.*(hsv.x-0.-1./6.)))),\n        max(0.,min(1.,1.5-abs(6.*(hsv.x-1./3.-1./6.)))),\n        max(0.,min(1.,1.5-abs(6.*(hsv.x-2./3.-1./6.))))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n       \n    uv-=.5;\n    uv*=2.;\n\n    x = uv.x * 5.;\n\n              \n\n\n    vec3 b = vec3(0.);\n    for(int i=1; i<count+1; i++){\n        //b+=wave(muls[i].x)*muls[i].y;\n        float mul= 1./float(i);\n        float add = float(i)*.2;\n\n        float size = psin(iTime+float(i))+.2;\n        float gmul = i==count/2?-2.:1.;\n\n        float p=.2*float(i)/float(count);\n        vec3 color = hsv2rgb(vec3(p+fract(iTime*.1),1.,1.));\n\n        b += color*(gmul* psin((sin(iTime)*float(i)*3.)*wave(mul, size)) * psin(iTime*(1.+add)+add));\n    }\n\n\n    // Output to screen\n    fragColor = vec4(b,1.0);\n}","name":"Image","description":"","type":"image"}]}