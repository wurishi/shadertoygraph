{"ver":"0.1","info":{"id":"ssdfz8","date":"1656104798","viewed":88,"name":"Numeric Cubic SDF With L2 Metric","username":"Envy24","description":"Numeric Cubic Curve SDF With L2 Metric of P(t)=P0*(1-t)^3+P1t(1-t)^2+P2t^2(1-t)+P3t^3.\nhttps://www.desmos.com/calculator/n33iipw8xo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cube","space","cubic","newton","metric","raphson","root","vieta","l2"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define INITIALLY_FAR               9e30\n\nfloat L2(vec2 B, vec2 E)\n{\n    return length(E - B);\n}\n\n#define Y(x) (s*x*x*x+n*x*x+m*x+k)\n/* Slower version *\nfloat cubicSDF_L2(\n    vec2 NDC,\n    float s,\n    float n,\n    float m,\n    float k)\n{\n    float coef[6] = float[6](\n        3.*s*s,\n        5.*n*s,\n        2.*(2.*m*s+n*n),\n        3.*(k*s-NDC.y*s+n*m),\n        2.*k*n-2.*NDC.y*n+m*m+1.,\n        m*k-NDC.y*m-NDC.x\n    );\n\n    float minSqDist = INITIALLY_FAR;\n    \n    const float N = 10.0;\n    float x_min = findQuinticRootNewtonRaphson(-1000.0, coef);\n    float x_max = findQuinticRootNewtonRaphson(1000.0, coef);\n    float dx = (x_max - x_min) / N;\n\n    for (float i = 0.; i < N; i += 1.0)\n    {\n        float x = findQuinticRootNewtonRaphson(\n            x_min + dx * i,\n            coef);\n\n        vec2 diff = vec2(x, Y(x)) - NDC;\n\n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n    \n    float R = sinOSC(0.0, 0.5, iTime); // thickness;\n    return sqrt(minSqDist) - R;\n}\n/* Slightly faster version */\nfloat cubicSDF_L2(\n    vec2 NDC,\n    float s,\n    float n,\n    float m,\n    float k)\n{\n    float coef[6] = float[6](\n        3.*s*s,\n        5.*n*s,\n        2.*(2.*m*s+n*n),\n        3.*(k*s-NDC.y*s+n*m),\n        2.*k*n-2.*NDC.y*n+m*m+1.,\n        m*k-NDC.y*m-NDC.x\n    );\n    \n    /* This division lets rewrite \n            ax^5+bx^4+cx^3+dx^2+ex+f = f+x(e+x(d+x(c+x(b+x*a))))\n        as   x^5+Ax^4+Bx^3+Cx^2+Dx+E = E+x(D+x(C+x(B+x(A+x))))      -1 mult op */\n    float invA=1.0/  coef[0];\n    coef[0] = 1.0;\n    coef[1] *= invA;\n    coef[2] *= invA;\n    coef[3] *= invA;\n    coef[4] *= invA;\n    coef[5] *= invA;\n\n    float minSqDist = INITIALLY_FAR;\n    \n    const float N = 10.0;\n    float x_min = findQuinticRootNewtonRaphson_(-1000.0, coef);\n    float x_max = findQuinticRootNewtonRaphson_(1000.0, coef);\n    float dx = (x_max - x_min) / N;\n\n    for (float i = 0.; i < N; i += 1.0)\n    {\n        float x = findQuinticRootNewtonRaphson_(\n            x_min + dx * i,\n            coef);\n\n        vec2 diff = vec2(x, Y(x)) - NDC;\n\n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n    \n    float R = sinOSC(0.0, 0.5, iTime); // thickness;\n    return sqrt(minSqDist) - R;\n}\n/* Slightly faster */\n\n/* IQ coloring scheme */\nvec3 colorize_field(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n    \n    // Add interleaved \"lines\".\n\tcolor *= 0.7 + 0.2 * cos(30.0 * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(dist)));\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    float s,\n    float n,\n    float m,\n    float k,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * 2.75 :\n            rotateAroundZ(vec2(1, 0), iTime * 0.25) * 1.5;\n            //vec2(0);\n\n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(cubicSDF_L2(M, s, n, m, k));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float s = sinOSC(-4.0, 4.0, iTime * 0.2);\n    float n = sinOSC(-4.0, 4.0, iTime * 0.4);\n    float m = sinOSC(-4.0, 4.0, iTime * 0.8);\n    float k = sinOSC(-2.0, 2.0, iTime * 0.9);\n\n    vec2 NDC = TO_CENTERED_NDC(SC) * 2.75;\n    float minDist = cubicSDF_L2(NDC, s, n, m, k);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, s, n, m, k, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat findQuinticRootNewtonRaphson(\n    float x,\n    float c[6])\n{\n    const float tolerance = 1e-7; /* Desired precision */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small value */\n    float deriv = c[4] + x * (2.*c[3] + x * (3.*c[2] + x * (4.*c[1] + x * 5.*c[0])));\n    bool quit = abs(deriv) <= EPSILON;\n    \n    for (int i = 0; (i < 15) && (quit == false); ++i)\n    {\n        float f = (c[5] + x * (c[4] + x * (c[3] + x * (c[2] + x * (c[1] + x * c[0])))));\n        x -= f / deriv;          \n        deriv = c[4] + x * (2.*c[3] + x * (3.*c[2] + x * (4.*c[1] + x * 5.*c[0])));\n        quit = (abs(f) <= tolerance) || (abs(deriv) <= EPSILON);\n    }\n\n    return x;\n}\n\nfloat findQuinticRootNewtonRaphson_(\n    float x,\n    float c[6])\n{\n    const float tolerance = 1e-7; /* Desired precision */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small value */\n    float deriv = c[4] + x * (2.*c[3] + x * (3.*c[2] + x * (4.*c[1] + x * 5.)));\n    bool quit = abs(deriv) <= EPSILON;\n    \n    for (int i = 0; (i < 15) && (quit == false); ++i)\n    {\n        float f = (c[5] + x * (c[4] + x * (c[3] + x * (c[2] + x * (c[1] + x)))));\n        x -= f / deriv;          \n        deriv = c[4] + x * (2.*c[3] + x * (3.*c[2] + x * (4.*c[1] + x * 5.)));\n        quit = (abs(f) <= tolerance) || (abs(deriv) <= EPSILON);\n    }\n\n    return x;\n}","name":"Common","description":"","type":"common"}]}