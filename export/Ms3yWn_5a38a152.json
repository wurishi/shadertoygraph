{"ver":"0.1","info":{"id":"Ms3yWn","date":"1518406796","viewed":766,"name":"mip based alchemy ao","username":"Jodie","description":"fast, smooth alchemy ao using mipped depth, only 3 samples per pixel, no loops","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["ao","ambientocclusion","alchemyy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 up=normalize(vec3(0,1,0));\n\n// just to add texture to the rocks\nvec3 boxmap( sampler2D s, vec3 p, vec3 n ){\n    \n    mat3 t = mat3(\n        texture( s, p.yz ).rgb,\n        texture( s, p.zx ).rgb,\n        texture( s, p.xy ).rgb\n    );\n    n=abs(n);\n    return t*n / dot(n,vec3(1));\n}\n\nvec3 hemisphereSample_uniform(float u, float v) {\n     float phi = v * 2.0 * 3.141592654;\n     float cosTheta = 1.0 - u;\n     float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n     return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\n// https://www.shadertoy.com/view/4djSDy\nfloat solidAngleOcclusion(float nl, float cosAngle){\n    \n    //brute force montecarlo\n    /*\n    float foo=0.;\n    float bar=0.;\n    for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n        vec3 rand = hemisphereSample_uniform(float(i)/100.,float(j)/100.);\n        vec3 l = vec3(sqrt(1.-nl*nl),0,nl);\n        if(dot(rand,l)>cosAngle)\n        foo+=dot(rand,vec3(0,0,1));\n        bar+=dot(rand,vec3(0,0,1));\n    }}\n    return foo/bar;*/\n    // double cos(theta)\n    // 2.*x*x-1.;\n    // half cos(theta)\n    // sqrt(x + 1.)/sqrt(2.)\n    // if angle of whole cone\n    //float rh2 = .5*(-x - 1.) + 1.;\n    \n    // fast approx\n    // curve matched using turingbot\n    // size 23 rms 0.000002\n    return  (0.674753+((0.821827*cosAngle*(0.600465+0.43519*cosAngle+nl)+0.495457)*(-0.340972+nl)))*(1.0-cosAngle);\n\n    \n    float rh2 = 1. - cosAngle*cosAngle;\n    float res = nl*rh2;\n    float h2 = 1./rh2;\n    float k2 = 1.0 - h2*nl*nl;\n    \n    if( k2 > 0.0 ) {\n        res = (nl * acos(-nl*sqrt( (h2-1.0)/(1.0-nl*nl) )) - sqrt(k2*(h2-1.0)))\n            *rh2 + atan( sqrt(k2/(h2-1.0)));\n        res /= 3.141593;\n    }\n    return res;\n}\n\nfloat hemisphereOcclusion(float nl){\n    return nl * .5 + .5;\n}\n\nvec3 toViewSpace(const vec2 p){\n\treturn vec3(p, texture(iChannel0,p).x * .2);\n}\n\nvec3 toViewSpaceLOD(const vec2 p, const float lod){\n\treturn vec3(p, texture(iChannel0,p,lod).x * .2);\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormalLod(const float lod, const vec2 uv){\n    \n    vec2 om = exp2(lod) / iResolution.xy *0.5;\n    vec3 L0 = toViewSpaceLOD(uv+vec2(-1,-1)*om,lod);\n    vec3 L1 = toViewSpaceLOD(uv+vec2( 1,-1)*om,lod);\n    vec3 L2 = toViewSpaceLOD(uv+vec2(-1, 1)*om,lod);\n    vec3 L3 = toViewSpaceLOD(uv+vec2( 1, 1)*om,lod);\n    \n    return normalize( cross(\n        L0 - L3,\n        L1 - L2\n    ));\n}\n\nfloat getHorizonFancy(const float lod, const vec2 uv, const vec3 p, vec3 L){\n    vec2 om = exp2(lod) / iResolution.xy *0.5;\n            \n    vec3 L0 = (toViewSpaceLOD(uv+vec2(-1,-1)*om,lod)-p);\n    vec3 L1 = (toViewSpaceLOD(uv+vec2( 1,-1)*om,lod)-p);\n    vec3 L2 = (toViewSpaceLOD(uv+vec2(-1, 1)*om,lod)-p);\n    vec3 L3 = (toViewSpaceLOD(uv+vec2( 1, 1)*om,lod)-p);\n    \n    L=normalize(normalize(cross(L0-L3,L1-L2))+up);\n    \n    float cosHorizonAngle = clamp((\n        dotNorm(L0,L)+\n        dotNorm(L1,L)+\n        dotNorm(L2,L)+\n        dotNorm(L3,L)\n    )/4.,0.,1.);\n    \n    //cosHorizonAngle=max(\n    //    cosHorizonAngle,\n    //    dotNorm(cross(up,cross(L,up)),L)\n    //);\n    \n    return cosHorizonAngle;\n}\n\nfloat getHorizon(float lod, const vec2 uv, const vec3 p, vec3 L){\n    vec2 om = exp2(lod) / iResolution.xy * .5;\n    vec3 o = toViewSpaceLOD(uv,lod)-p;\n    o.xy+=om;\n    float rlength = inversesqrt(dot(o,o));\n    // integral of l_x*sin(x)*o_x+l_y*cos(x)*o_y+ l_z*o_z from 0 to 2pi\n    \n    float cosHorizonAngle = clamp(L.z*o.z*rlength,0.,1.);\n    \n    //cosHorizonAngle=max(\n     //   cosHorizonAngle,\n     //   dotNorm(cross(up,cross(L,up)),L)\n    //);\n    \n    return cosHorizonAngle;\n}\n//#define getHorizon getHorizonFancy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 p = toViewSpace(uv);\n    vec3 N = getNormalLod(0.,uv);\n    vec3 L = normalize(getNormalLod(5.,uv)+up);\n    float NdotL = dot(N,L);\n\n    fragColor.rgb = vec3(\n        solidAngleOcclusion(NdotL, max3(\n            getHorizon(2.,uv,p,L),// small detail ao\n            getHorizon(3.,uv,p,L),// medium detail ao\n            getHorizon(4.,uv,p,L) // large detail ao\n        ))\n    );\n    \n    // ground lighting\n    //fragColor.rgb=min(vec3(hemisphereOcclusion(dot(N,up))),fragColor.rgb);\n    \n    // add texture to stones\n    //fragColor.rgb *= srgbToLinear(boxmap(iChannel1,p,N))*2.;\n    \n    fragColor.rgb = linearToSrgb(fragColor.rgb);\n    \n    // debug\n    //fragColor.rgb = L*.5+.5;\n    //fragColor.rgb = vec3(solidAngleOcclusion(uv.x*2.-1.,uv.y));\n    //if(fragColor.r<0.)fragColor.rgb=vec3(1,0,0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define max3(a,b,c) max(max(a,b),c)\n#define max4(a,b,c,d) max(max3(a,b,c),d)\n#define min3(a,b,c) min(min(a,b),c)\n#define min4(a,b,c,d) min(min3(a,b,c),d)\n\nfloat dotNorm(const vec3 v, const vec3 n) {\n\treturn dot(v, n) * inversesqrt(dot(v, v));\n}\n\nfloat dotNorm2(const vec3 v1, const vec3 v2) { \n\treturn dot(v1, v2) * inversesqrt( dot(v1, v1) * dot(v2, v2) );\n}\n\n// curve matched using turingbot\nvec3 srgbToLinear(const vec3 x){\n    return 0.315206*x*((2.10545+x)*(0.0231872+x));\n}\n// curve matched using turingbot\nvec3 linearToSrgb(const vec3 x){\n    return 1.14374*(-0.126893*x+sqrt(x));\n}","name":"Common","description":"","type":"common"}]}