{"ver":"0.1","info":{"id":"7tXXzB","date":"1626343818","viewed":149,"name":"SILVERALL","username":"Awayko_Wakee","description":"// Birth and extinction of a litho-organic structure //","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","fbm","antialiasing","landscape","reflections","silver","gyroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Silverall\"\n// 2021\n// by Awayko Wakee\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define antialias\n\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n// from https://www.shadertoy.com/view/XdVSRV\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n// https://iquilezles.org/articles/fbmsdf\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n// https://iquilezles.org/articles/fbmsdf\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n// https://iquilezles.org/articles/fbmsdf\nfloat sdFbm( vec3 p, float d )\n{\n   float s = 1.;\n   for( int i=0; i<4; i++ )\n   {\n       // evaluate new octave\n       float n = s*sdBase(p);\n\t\n       // add\n       n = smax(n,d-0.1*s,0.4*s);\n       d = smin(n,d      ,0.4*s);\n\t\n       // prepare next octave\n       p = mat3( 0.00, 1.60, 1.20,\n                -1.60, 0.72,-0.96,\n                -1.20,-0.96, 1.28 )*p;\n       s = 0.5*s;\n   }\n   return d;\n}\n\n// MAP\nfloat map(vec3 p) {\n    \n    float t = iTime;\n    vec3 pGrnd = p;\n    vec3 pCam = p;\n\n    p.xy *= Rot(p.z*sin(iTime*.1)*.01);\n    p.xz *= Rot(sin(iTime*.05)*.5);\n    p.z -= iTime*.2;\n    p.y += sin(iTime*.23);\n\n    // PLANE\n    p += vec3(0,-2,0);\n    float plane = dot(p, normalize(vec3(0,1,0)));\n    plane -= sin(p.x*.71+iTime*.63) + sin(p.x*.26+iTime*.27) +\n             cos(p.z*.33+iTime*.19) + sin(p.z*.31+iTime*.11);\n    plane -= smoothstep(-3.,3.,sin(1.2*p.x)+sin(1.23*p.y)+cos(1.13*p.z));\n    \n    // GYROID\n    //thanks to https://www.shadertoy.com/user/BigWIngs\n    //for the great gyroid tutorial https://www.youtube.com/watch?v=-adHIyjIYgk&t=1518s\n    \n    float bias = 1.8;\n    float thickness = 0.3; \n    float scale = 2.;\n    p *= scale;\n    \n    float g = abs(dot(sin(p*.39),cos(p.zxy*.63))-bias)/scale-thickness;   \n    \n    // combining cutting PLANE and GYROID\n    float d = opSmoothIntersection(plane, g, .3);\n\n    // substracting SPHERE around camera\n    float r = .5;\n    float camSph = sdSphere(pCam-vec3(0,0,3), r);\n    camSph -= smoothstep(-1.3,1.3,sin(.5*p.x)+sin(.8*p.y)+cos(.23*p.z));   \n    d = opSmoothSubtraction( -d, -camSph, .9);\n    \n    // adding NOISE to the GYROID surface\n    d = sdFbm(p, d);\n    \n    // GROUND\n    pGrnd.y += 4.5;\n    float ground = dot(pGrnd+vec3(0,1,0), normalize(vec3(0,1,0)));\n    ground -= sin(pGrnd.x*.23+iTime*.2)*.45 + cos(pGrnd.z*.31+iTime*.3)*.8;\n\n    d = opSmoothUnion(d, ground, 0.5);\n    \n    return d;\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\t\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = map(p);\n        if(dS<SURF_DIST) break;\n        \n        dO += dS;\n        if(abs(dO)>MAX_DIST) break;\n    }\n    if(abs(dO)>MAX_DIST) dO=-1.;\n    \n    return dO;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat calcAO( in vec3 p, in vec3 n){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map(p+h*n);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec4 render(vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    // CAMERA\n    vec3 ro = vec3(0, 0, 3);\n    vec3 lookAt = vec3(cos(iTime*.1)*10.,sin(iTime*.2)*1.5-1.,0);//\n    vec3 rd = GetRayDir(uv, ro, lookAt, .8);\n    \n    // SKY\n    vec3 col = texture(iChannel0, rd).rgb;\n    col = mix( col, vec3(0.2, 0.2, .2), exp(-4.0*max(rd.y,0.)) );\n    \n    // RAYMARCHING\n    float d = castRay(ro, rd);\n    \n    if(d > 0.0) {\n        vec3 p = ro + rd * d;\n        vec3 n = calcNormal(p);\n        vec3 r = reflect(rd, n);\n\n        // REFLECTION\n        vec3 ref = texture(iChannel0, r).rgb;\n        \n        // LIGHTING\n        vec3  lDir = normalize(vec3(-.1,.4,.3));\n        float dif = clamp(dot(n, lDir),0.,1.);\n        float sunSha = step(castRay(p+n*0.01, lDir),0.);\n        float skyDif = clamp(.5+.5*dot(n, vec3(0,1,0)),0.,1.);\n        \n        col *= ref;\n        col *= 20. * dif * sunSha;\n        col *= calcAO(p,n);\n        col += ref * vec3(.7) * skyDif;        \n    }\n\n    // FOG\n    col = mix( col, vec3(.2), 1.-exp( -0.0001*d*d*d ) );\n    \n    // COMPRESS        \n    col = 1.35*col/(1.0+col);   \n        \n    // GAMMA\n    col = pow( col, vec3(0.4545) );    \n    \n    // OUTPUT\n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// ANTIALIASING from https://www.shadertoy.com/view/XdVSRV\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n    \n   \n}","name":"Image","description":"","type":"image"}]}