{"ver":"0.1","info":{"id":"XfdcWH","date":"1730636411","viewed":95,"name":"Perlin Cave","username":"MUSHRUM","description":"Perlin cave infinite journey","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","perlinnoise","proceduralworldgeneration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n} \n\nfloat map (vec3 p) {\n    vec3 q = p;\n    //q = applyRotation(q,vec3(0.,iTime/30.,0.));\n    //q += normalize(q)*(sin(iTime)-1.)*10.-25.;\n    //q = mod(q,10.)-5.;\n    //q = applyRotation(q,vec3(-iTime,0.,0.));\n    //return sdTorus(q,vec2 (0.25,0.15));\n    q.z += iTime*30.;\n    q = applyRotation(q,vec3(0.,0.,iTime/10.));\n    return noise(q*.003)*1. + noise(q*.02)*2.-.5 + noise(q*.1)*2.-1. +noise(q*0.8)*0.05;\n}\n\nfloat mapn (vec3 p){\n    return map(p);\n}\n\nvec3 normal(in vec3 pos) {\n    vec3 eps = vec3(0.001,0.0,0.0);\n    vec3 nor = vec3(\n        mapn(pos + eps.xyy) - mapn(pos - eps.xyy), \n        mapn(pos + eps.yxy) - mapn(pos - eps.yxy), \n        mapn(pos + eps.yyx) - mapn(pos - eps.yyx)\n    );\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0,0.0,-10.);\n    vec3 rd = normalize(vec3 (uv.x,uv.y,.5));\n    float t = 0.;\n    vec3 p = ro;\n    //float str = 1.;\n    for (int i = 0; i < 800; i++){\n         p = ro + rd * t;\n         float d = map(p);\n         if (i==0) d = max(map(p),40.);\n         t+=d;\n         if(d<t*0.002) break;\n         //if(d<0.01 && noise(round(p))>0.9){ro = reflect(-ro,normal(p));}\n    }\n    //col = vec3 (dot(normal(p),vec3(0.0,1.0,0.0))/2.+0.5) / (t*0.25);\n    //col += vec3(1,atan(rd.x,rd.z)/3.14+0.3,atan(rd.y,rd.z)/3.14+0.3) * 1.+t*.004-;\n    vec3 lghtsrc = vec3 (.0,1.,.0);\n    col = vec3 (length(p-ro)/20.,1.-length(p-ro)/20.,1.*noise(p/5.))*t*0.0003;\n    col += 0.8*vec3 (0.,dot(normal(p),lghtsrc)/2.+0.5,dot(normal(p),lghtsrc)/2.+0.5);\n    fragColor = vec4 (col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0,  0.0,  0.0,\n        0.0,  c,    -s,\n        0.0,  s,    c\n    );\n}\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c,   0.0,  s,\n        0.0, 1.0,  0.0,\n        -s,  0.0,  c\n    );\n}\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c,   -s,  0.0,\n        s,    c,  0.0,\n        0.0,  0.0, 1.0\n    );\n}\n\nvec3 applyRotation(vec3 p, vec3 eulerAngles) {\n    mat3 rotX = rotateX(eulerAngles.x);\n    mat3 rotY = rotateY(eulerAngles.y);\n    mat3 rotZ = rotateZ(eulerAngles.z);\n    return rotZ * rotY * rotX * p;\n}\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n","name":"Common","description":"","type":"common"}]}