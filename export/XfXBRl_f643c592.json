{"ver":"0.1","info":{"id":"XfXBRl","date":"1724153321","viewed":23,"name":"HLSH Sandbox","username":"mxcop","description":"Reading radiance data from hemispherical linear spherical harmonics!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Minimized version of \"https://www.shadertoy.com/view/lt2GRD\" for personal experimentation :D */\n/* Paper about HLSH: <https://www.ppsloan.org/publications/hemilightTR.pdf> */\n/* Shadertoy showcasing HLSH and comparing it against other methods: <https://www.shadertoy.com/view/lcVSDh> */\n\n// https://iquilezles.org/articles/intersectors\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat map(in vec3 p)\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 4.5;\n    \n\tfor( int i=0; i<1; i++ )\n    {\n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        b += iTime * 2.0;\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calc_normal(in vec3 pos, in float t, in float px)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, in float px)\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\n\tfloat t = dis.x;\n\tfor(int i=0; i<128; i++)\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    if( t<dis.y )\n    {\n        res = t;\n    }\n\n    return res;\n}\n\n/* Ray sphere intersection test (return -1.0 if miss) */\nfloat ray_sphere(in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float r) {\n    vec3 ce = ro - sphere_pos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax) return t;\n    }\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*1.5);\n\n    /* Animate camera */\n    vec3 eye = vec3(0.0, 1.0, 2.0);\n    vec2 rot = 6.2831 * (vec2(0.6 + iTime * 0.1, sin(iTime * 0.5) * 0.06) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    /* Camera matrix */\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));   \n\n    vec3 col = vec3(0.0);\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n\n    /* Trace the sphere */\n    float t = raycast(ro, rd, px);\n    if (t > tmin) {\n        vec3 spos = ro + rd * t;\n        vec3 n = calc_normal(spos, t, px);\n        \n        col = HLSH_Eval(grace2, n);\n    } else {\n        col = HLSH_Eval(grace2, rd);\n    }\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 sphere_pos = vec3(0.0, 1.0, 0.0);\nfloat sphere_radius = 1.0;\n\nconst float PI = 3.14159265359;\n\nstruct HLSHRGB {\n    vec3 Ca;\n    vec3 cx;\n    vec3 cy;\n    vec3 cz;\n};\n\nconst HLSHRGB grace2 = HLSHRGB(\n    vec3(0.2, 0.1, 0.3),\n    vec3(-0.3, 0.5, 0.2),\n    vec3(0.3, -0.4, 0.0),\n    vec3(0.1, -0.2, 0.4)\n);\n \nvec3 HLSH_Eval(HLSHRGB hlsh, vec3 N) {\n    return hlsh.Ca + hlsh.cx * N.x + hlsh.cy * N.y + hlsh.cz * N.z;\n}\n\n","name":"Common","description":"","type":"common"}]}