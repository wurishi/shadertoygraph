{"ver":"0.1","info":{"id":"3lcSz7","date":"1594079925","viewed":190,"name":"Quantum Blorble","username":"trevorleake","description":"Pretty. But also hairy.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","messy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAGIC_BOX_ITERS = 9;\nconst float MAGIC_BOX_MAGIC = 1.;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise(vec3 p){\n    \n    float t = iTime/3.;\n    vec3 np = normalize(p);\n    \n    // kind of bi-planar mapping\n    float a = texture(iChannel0,t/20.+np.xy).x;      \n    float b = texture(iChannel0,t/20.+.77+np.yz).x;\n    \n    a = mix(a,.5,abs(np.x));\n    b = mix(b,.5,abs(np.z));\n    \n    float noise = a+b-.4;    \n    noise = mix(noise,.9,abs(np.y)/2.);\n        \n    return noise;\n}\n\nfloat map(vec3 p){\n    \n    // spheres\n    float d = (-1.*length(p)+3.)+1.5*noise(p) + magicBox(p/2.1)/8. * 2.;    \n    d = min(d, (length(p)-2.1) + noise(p) + magicBox(p)/9.)*.3;\n    \n    // links\n    float m = 1.; float s = .0;    \n//    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);          \n//    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );    \n//    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );    \n//    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );    \n//    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );\n    \n    return d;\n}\n\nfloat color( vec3 p){\n   return 0.; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(1.*uv.x,1.*uv.y,1.));\n    \n    // Color    \n    vec3 color = vec3(0);    \n    const int rayCount = 1024;\n    \n    // Raymarching\n    float t = 0.;\n    for (int r = 1; r <= rayCount; r++)\n    {\n        // Ray Position\n        vec3 p = vec3(0,0,-3.) + ray * t;        \n        \n        // Rotation \n       \tp = rotateY(p, iMouse.x/iResolution.x * 2.* 3.14);  \n        p = rotateY(p,iTime/15.);\n        \n        // Deformation \n    \tfloat mask = max(0.,(1.-length(p/3.)));\n    \tp = rotateY(p, mask*sin(iTime/10.)*.2);        \n        p.y += sin(iTime+p.z*3.)*mask*.2;\n        p *= 1.+(sin(iTime/2.)*mask*.1);\n\n        // distance\n        float d =  map(p);   \n        \n        //color\n        if(d<0.01 || r == rayCount )\n        {                 \n            \n            float iter = float(r) / float(rayCount);\n            float ao = (1.-iter);\n            ao*=ao;\n            ao = 1.-ao;\n                        \n            float mask = max(0.,(1.-length(p/2.)));            \n            mask *= abs(sin(iTime*-1.5+length(p)+p.x)-.2);            \n            color += 2.*vec3(.1,1.,.8) * max(0.,(noise(p)*4.-2.6)) * mask;            \n            color += vec3(.1,.5,.6) * ao * 6.;            \n            color += vec3(.5,.1,.4)*(t/8.);\n                       \n            color *= 2.2 + (sin(iTime/3.)*.3 + .55);\n            color -= 1.;\n                        \n            break;          \n        }\n        \n        // march along ray\n        t +=  d *.5;        \n    }\n    \n    // vignetting effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx; \n    float vig = uv.x*uv.y * 20.0;    \n    vig = pow(vig, 0.25);        \n    color *= vig;\n    \n    //color adjustement\n    color.y *= 1.1;\n    color.x *= 2.4;\n    \n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}