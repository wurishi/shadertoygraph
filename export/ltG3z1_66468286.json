{"ver":"0.1","info":{"id":"ltG3z1","date":"1473120231","viewed":3426,"name":"strandbeest leg","username":"marius","description":"Theo Jansen's strandbeest linkage visualization for one basic leg\n","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visualizing Theo Jansen's Strandbeest basic leg linkage\n// http://www.strandbeest.com/\n//\n// See http://www.strandbeest.com/beests_leg.php for names & values.\n\nconst float SCALE = 100.0;\n\nconst float a = 38.0 / SCALE;\nconst float b = 41.5 / SCALE;\nconst float c = 39.3 / SCALE;\nconst float d = 40.1 / SCALE;\nconst float e = 55.8 / SCALE;\nconst float f = 39.4 / SCALE;\nconst float g = 36.7 / SCALE;\nconst float h = 65.7 / SCALE;\nconst float i = 49.0 / SCALE;\nconst float j = 50.0 / SCALE;\nconst float k = 61.9 / SCALE;\nconst float l = 7.8  / SCALE;\nconst float m = 15.0 / SCALE;\n\n// distance from point x to line segment ab\nfloat dist2seg(vec2 a, vec2 b, vec2 x) {\n  vec2 lineDir = b - a;\n  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\n  vec2 dirToA = a - x;\n  float d = abs(dot(normalize(perpDir), dirToA));\n  float d1 = dot(x - a, x - a);\n  float d2 = dot(x - b, x - b);\n  float sl = dot(a - b, a - b);\n  if (d1 < sl && d2 < sl) return d;\n  return 1.0;\n}\n\n// intersect point between two 2d circles, x,y,r\n// which as {-1, 1} to select the one you want\nvec2 intersect(vec3 c0, vec3 c1, float which) {\n    vec2 dxy = vec2(c1.xy - c0.xy);\n    float d = length(dxy);\n    float a = (c0.z*c0.z - c1.z*c1.z + d*d)/(2.*d);\n    vec2 p2 = c0.xy + (a / d)*dxy;\n    float h = sqrt(c0.z*c0.z - a*a);\n    vec2 rxy = vec2(-dxy.y * (h/d), dxy.x * (h/d));\n    return p2 + which * rxy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = vec2(1.) - 2. * uv;  // [-1..1]\n    uv.x *= iResolution.x/iResolution.y;  // fix up aspect\n    \n    // default drawing thickness and color\n    float thick = .005;\n    vec3 color = vec3(.5);\n    \n    vec2 crank = vec2(0, 0);          // crank axle\n    vec2 axle = crank - vec2(a, -l);  // main axle\n    vec2 pedal = crank + vec2(m*cos(iTime), -m*sin(iTime));\n\n    float dp = length(uv - pedal);\n    float da = length(uv - axle);\n\n    // draw circles\n    float delta = length(uv - pedal);    \n    delta = min(delta, abs(length(uv - crank) - m));\n    delta = min(delta, abs(dp - j));\n    delta = min(delta, abs(dp - k));\n    delta = min(delta, abs(da - b));\n    delta = min(delta, abs(da - c));\n    delta = min(delta, abs(da - d));\n    \n    // draw \"frame\"\n    float ds = dist2seg(vec2(0, l), axle, uv);\n    ds = min(ds, dist2seg(vec2(0, l), crank, uv));\n    ds = min(ds, length(uv - vec2(0, l)));\n    if (ds < .015) {\n        delta = ds;\n        thick = .015;\n    }\n    \n    // compute linkage points\n    vec2 P1 = intersect(vec3(pedal, j), vec3(axle, b), 1.0);  // bej\n    vec2 P2 = intersect(vec3(pedal, k), vec3(axle, c), -1.0);  // cgik\n    vec2 P3 = intersect(vec3(P1, e), vec3(axle, d), 1.0);  // edf\n    vec2 P4 = intersect(vec3(P2, g), vec3(P3, f), -1.0); // fgh\n    vec2 P5 = intersect(vec3(P2, i), vec3(P4, h), -1.0);  // hi\n    \n    // draw blue links\n    ds = dist2seg(pedal, crank, uv);\n    ds = min(ds, dist2seg(P1, axle, uv));\n    ds = min(ds, dist2seg(P3, axle, uv));\n    ds = min(ds, dist2seg(P1, P3, uv));\n    ds = min(ds, dist2seg(P2, P4, uv));\n    ds = min(ds, dist2seg(P2, P5, uv));\n    ds = min(ds, dist2seg(P4, P5, uv));\n    if (ds < 0.015) {\n        color = vec3(0,0,1);\n        delta = ds;\n        thick = 0.015;\n    }\n    \n    // draw crank axle knob\n    ds = length(uv - crank);\n    if (ds < 0.015) {\n        color = vec3(0,0,1);\n        delta = ds * .5;\n        thick = 0.015;\n    }\n\n    // draw green links\n    ds = dist2seg(pedal, P1, uv);\n    ds = min(ds, dist2seg(pedal, P2, uv));\n    ds = min(ds, dist2seg(P2, axle, uv));\n    ds = min(ds, dist2seg(P3, P4, uv));\n    if (ds < 0.015) {\n        color = vec3(0,1,0);\n        delta = ds;\n        thick = .015;\n    }\n     \n    // draw red joints\n    ds = length(uv - P1);\n    ds = min(ds, length(uv - P2));\n    ds = min(ds, length(uv - P3));    \n    ds = min(ds, length(uv - P4));    \n    ds = min(ds, length(uv - pedal));\n    ds = min(ds, length(uv - axle));\n    ds = min(ds, length(uv - P5));\n    if (ds < .015) {\n        color = vec3(1,0,0);\n        delta = ds * .5;\n        thick = 0.015;\n    }\n\n   if (delta < thick) {\n      // close enough to something; draw color \n\t  fragColor = vec4(color * vec3(1. - delta / thick), 1.0);\n    } else {\n      // draw decaying foot path\n      fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This is the backbuffer. Exactly same as frontbuffer, but only drawing the\n// foot with slow decay.\n\nconst float SCALE = 100.0;\n\nconst float a = 38.0 / SCALE;\nconst float b = 41.5 / SCALE;\nconst float c = 39.3 / SCALE;\nconst float d = 40.1 / SCALE;\nconst float e = 55.8 / SCALE;\nconst float f = 39.4 / SCALE;\nconst float g = 36.7 / SCALE;\nconst float h = 65.7 / SCALE;\nconst float i = 49.0 / SCALE;\nconst float j = 50.0 / SCALE;\nconst float k = 61.9 / SCALE;\nconst float l = 7.8  / SCALE;\nconst float m = 15.0 / SCALE;\n\n// distance from point x to line segment ab\nfloat dist2seg(vec2 a, vec2 b, vec2 x) {\n  vec2 lineDir = b - a;\n  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\n  vec2 dirToA = a - x;\n  float d = abs(dot(normalize(perpDir), dirToA));\n  float d1 = dot(x - a, x - a);\n  float d2 = dot(x - b, x - b);\n  float sl = dot(a - b, a - b);\n  if (d1 < sl && d2 < sl) return d;\n  return 1.0;\n}\n\n// intersect point between two 2d circles, x,y,r\n// which as {-1, 1} to select the one you want\nvec2 intersect(vec3 c0, vec3 c1, float which) {\n    vec2 dxy = vec2(c1.xy - c0.xy);\n    float d = length(dxy);\n    float a = (c0.z*c0.z - c1.z*c1.z + d*d)/(2.*d);\n    vec2 p2 = c0.xy + (a / d)*dxy;\n    float h = sqrt(c0.z*c0.z - a*a);\n    vec2 rxy = vec2(-dxy.y * (h/d), dxy.x * (h/d));\n    return p2 + which * rxy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = vec2(1.) - 2. * uv;  // [-1..1]\n    uv.x *= iResolution.x/iResolution.y;  // fix up aspect\n    \n    // default drawing thickness and color\n    float thick = .005;\n    vec3 color = vec3(.5);\n    \n    vec2 crank = vec2(0, 0);          // crank axle\n    vec2 axle = crank - vec2(a, -l);  // main axle\n    vec2 pedal = crank + vec2(m*cos(iTime), -m*sin(iTime));\n\n\tfloat delta = 1.0;\n    \n    // compute linkage points\n    vec2 P1 = intersect(vec3(pedal, j), vec3(axle, b), 1.0);  // bej\n    vec2 P2 = intersect(vec3(pedal, k), vec3(axle, c), -1.0);  // cgik\n    vec2 P3 = intersect(vec3(P1, e), vec3(axle, d), 1.0);  // edf\n    vec2 P4 = intersect(vec3(P2, g), vec3(P3, f), -1.0); // fgh\n    vec2 P5 = intersect(vec3(P2, i), vec3(P4, h), -1.0);  // hi\n    \n    // draw red foot\n    float ds = length(uv - P5);\n    if (ds < .015) {\n        color = vec3(1,0,0);\n        delta = ds * .5;\n        thick = 0.015;\n    }\n\n    // draw pixel if close enough to anything\n    if (delta < thick) {\n\t  fragColor = vec4(color * vec3(1. - delta / thick), 1.0);\n    } else {\n      // decay foot path\n      fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).xyz * .995, 1.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}