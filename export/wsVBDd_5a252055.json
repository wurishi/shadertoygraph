{"ver":"0.1","info":{"id":"wsVBDd","date":"1608287450","viewed":311,"name":"SDF Spheres","username":"Elgoms","description":"Metaballs test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Sun {vec3 pos; vec3 col;};\nvec3[] colors =  vec3[](vec3(0.5, 0.4, 1.), vec3(0.6, 0.6, 0.6), vec3(0.5, 0.5, 0.5));\nfloat opUnion(float d1, float d2) { return min( d1, d2); }\nfloat opIntersection(float d1, float d2) { return max( d1, d2); }\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\nfloat opDifference(float distA, float distB) { return max(distA, -distB); }\nvec3  opRepetition(vec3 pos, vec3 frq) { return mod(pos, frq) - 0.5 * frq; } \n\nmat3 CreateCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nfloat opBlend(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat BoxSDF(vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\n\nfloat PlaneSDF( vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat SphereSDF(vec3 p, float s) {\n    return length(p) - s;\n}\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 MapScene(vec3 pos)\n{\n    float t = iTime * 2.;\n    vec2  a = vec2(farPlane, 0), b = a, c = a;\n    \n    float p0 =  SphereSDF(pos + 2. * vec3(0., 0., cos(t*.9)), 1.);\n    p0 = opBlend(p0, SphereSDF(pos + 2. * vec3(cos(t*.9), 0., 0.), 1.), 0.5);\n    p0 = opBlend(p0, SphereSDF(pos + 2. * vec3(0., cos(t*.9), 0.), 1.), 0.5);\n    b  = vec2(p0, 0);\n   // MIN(a, b);\n    float p1= BoxSDF(opRepetition(pos, vec3(.35,0,.35)), vec3(3., 3., 0.012));\n    p1 = opUnion(p1, BoxSDF(opRepetition(pos, vec3(.35,0,.35)), vec3(.012, 3., 3.)));\n\tb  = vec2(opIntersection(p0, p1), 0); \n    MIN(a, b);\n    \n    float p2= PlaneSDF(pos, vec4(0.0, 1.0, 0.0, 2.7));\n    c = vec2(p2, 2);\n\treturn MIN(a, c);\n}\n\nvec3 CalculateNormal(vec3 p) {\n\n    return normalize(vec3(MapScene(vec3(p.x + epsilon, p.y, p.z)).x - MapScene(vec3(p.x - epsilon, p.y, p.z)).x,\n        MapScene(vec3(p.x, p.y + epsilon, p.z)).x - MapScene(vec3(p.x, p.y - epsilon, p.z)).x,\n        MapScene(vec3(p.x, p.y, p.z  + epsilon)).x - MapScene(vec3(p.x, p.y, p.z - epsilon)).x));\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = nearPlane;\n    vec2 res = vec2(farPlane, 0);\n    int i = 0;\n    \n    for (; i < maxSteps; ++i)\n    {\n\t    res = MapScene(ro + rd * t);\n        if ((res.x < epsilon))\n            break;\n        t += res.x;\n    }\n    \n    return vec2(t, res.y); //rayLength, currentLength, colorId\n}\n\nvec3 CalculateDiffuseLighting(vec3 normal, Sun sun, int colId)\n{\n    float ambientStrength = 0.1;\n    vec3 ambientLight = ambientStrength * sun.col;\n    float diffuse = max(dot(normal, normalize(sun.pos)), 0.0); //normalize light pos -> directional light\n    vec3 diffuseLighting = (diffuse + ambientLight) * sun.col * colors[colId];\n    \n    return diffuseLighting;\n}\n\nvec3 CalculateSpecular(vec3 normal, Sun sun, vec3 pos, vec3 viewVector, int colId)\n{\n    vec3 lightVec = normalize(sun.pos);\n    vec3 reflectVec = reflect(lightVec, normal);\n    \n    float specular = pow(max(dot(viewVector, reflectVec), 0.), 16.);\n    \n    vec3 specularLighting = specularStrength * specular * sun.col;\n    \n    return specularLighting;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    Sun sun, sun2;\n    sun.pos = vec3(sin(iTime * .35) * (4. + sin(iTime)), 4.,0.);\n    sun.col = vec3(1., 1., 1.);\n    sun2.pos = vec3(-2., -2., -1.);\n    sun2.col = vec3(1., 0.53, 0.);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // uv coordinates\n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // uv coordinates with aspect ratio applied.\n    \n    vec3 pos, nor;\n    vec2 res; // raymarching result\n    \n    \n    vec3 ro = vec3(0., 2.5, 5.);\n    vec3 ta = vec3(0);\n    mat3 ca = CreateCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    res = CastRay(ro, rd);\n    pos = ro + rd * res.x;   \n    nor = CalculateNormal(pos);\n    \n    if(res.x > farPlane)\n    {\n\t\treturn;\n    }\n    \n    vec4 diffuseLighting1, diffuseLighting2, specularLighting;\n    \n    diffuseLighting1 = vec4(CalculateDiffuseLighting(nor, sun, int(res.y)), 1.0);\n    //diffuseLighting2 = vec4(CalculateDiffuseLighting(nor, sun2, int(res.y)), 1.0);\n    specularLighting = vec4(CalculateSpecular(nor, sun, pos, rd, int(res.y)), 1.0);\n    \n    fragColor = diffuseLighting1 + specularLighting;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float specularStrength = 0.5;\nconst float nearPlane =   0.1;\t\nconst float farPlane  =  50.0;\t\nconst float epsilon       = 0.001;\t\nconst int   maxSteps      =    64;\t\n","name":"Common","description":"","type":"common"}]}