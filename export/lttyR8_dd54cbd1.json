{"ver":"0.1","info":{"id":"lttyR8","date":"1531578720","viewed":346,"name":"hexagon tiling","username":"Daedelus","description":"Description in comments -->","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hexagontiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\nI wanted to raymarch complex 3D cables on a floor, \n\nRemembering Shane's awesome shader: \nhttps://www.shadertoy.com/view/4lSBzm \n\nI figured I learn about truchet tiling in hexagons. \nFirst step already took all day to figure out properly :) wish me luck! \n\nHexagon tiling with edge distance, local UVs\nand cell index. Code focussed on creating hexgaon tiling with edge length of 1.0.\n**/\nfloat h1(float v){return fract(sin(v * 3177.31113) * 7115.2727131);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\tuv *= 2.0;\n    vec2 orig_uv = uv;\n    \n    /** Subdivide 2D space in tiling hexagons **/\n    // hegagon border distance\n    // hexagon aspect ratio\n    uv.x *= sqrt(4.0/3.0);\n    \n    // this is how big cells should be so the hexagon corners are ON a circle of radius 1\n    // (as opposed to cells that are 1 unit wide, meaning a circle of radius 1 fits snugly in the hexagon)\n    const float onCircleAdjust = 0.5 / sqrt(0.75);\n    \n    // adjust so our hexagons have an oncircle of radius 1 \n    uv *= onCircleAdjust;\n    // and align with the center of the screen\n    uv.x -= 0.5;\n    \n    // track horizontal tiling\n    float cx = floor(uv.x);\n    // stagger columns\n    uv.y += mod(floor(uv.x), 2.0) * 0.5;\n    // track vertical tiling\n    float cy = floor(uv.y);\n    // get tile-local uv\n    vec2 st = fract(uv) - 0.5;\n    // get hexagon distance\n    uv = abs(st);\n    float s = max(uv.x * 1.5 + uv.y, uv.y + uv.y);\n    // if s > 1.0 it actually belongs to the adjacent hexagon\n    if(s > 1.0)\n    {\n        // this part is just to adjust tile ID for the\n        // adjacent hexagons overlapping this tile\n        \n        // vertical tiling is different per column\n        float o = -sign(mod(cx,2.0)-0.5);\n        if(st.y * o > 0.0)\n        {\n            cy += o;\n        }\n        \n        // horizontal tiling is pretty straight forward\n        cx += sign(st.x);\n        \n        // adjsut local UVs as well so they are now fully hexagon local\n\t\tst.x -= sign(st.x);\n        st.y -= sign(st.y) * 0.5;\n    }\n    // hexagon distance accros tile boundaries\n    s = abs(s - 1.0);\n    // invert the aspect ratio and size correction of the local uvs\n    st.x *= sqrt(0.75);\n    st /= onCircleAdjust;\n    \n    // test a circle of sqrt(0.75) to be appropritate hexagon in-circle\n    float shape = smoothstep(0.0, 4.0 / iResolution.y, abs(length(st) - sqrt(0.75)));\n    \n    // visualize random value from cell Id, circle shape and edge distance\n    fragColor = vec4(shape, h1(cx + h1(cy)), s, 1);\n}","name":"Image","description":"","type":"image"}]}