{"ver":"0.1","info":{"id":"tljGzD","date":"1558733160","viewed":392,"name":"Munker Illusion","username":"blevin","description":"These spheres are all the same color.\nA Shadertoy version of a Munker illusion, as investigated by Prof David Novick:\nhttp://www.cs.utep.edu/novick/colors/explanation/","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["illusionperception"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A Shadertoy version of a Munker illusion, as investigated by Prof David Novick:\n// http://www.cs.utep.edu/novick/colors/explanation/\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// cosine palette from: iq, https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 pal_1(in float t)\n{\n  return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n    \nstruct Ray {\n    vec3 r0;\n    vec3 rd;\n};    \nstruct Material {\n    vec3 c;\n};\nstruct Hit {\n    float dist;\n    vec3 normal;\n    Material material;\n    int id;\n};    \nstruct Sphere {\n    int id;\n    vec3 s0;\n    float sr;\n    Material material;\n};\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\nHit traceSphere(Ray r, Sphere s)\n{\n    float dist = raySphereIntersect(r.r0, r.rd, s.s0, s.sr);    \n    if (dist > 0.0) {\n        vec3 p = r.r0 + r.rd * dist;\n        vec3 n = normalize(p-s.s0);\n        return Hit(dist, n, s.material, s.id);\n    }\n    return Hit(-1.0, vec3(0.0), s.material, -1);\n}\n\nvec3\npos(int id)\n{\n    // TODO return a whole sphere not just center\n    float fx = 2.0;\n    float fy = 2.0;\n    float fz = 2.0;\n    float num = 3.0;\n    float t = (iTime*0.05+float(id)/num) * 3.14159 * 2.0;\n    return vec3(\n        sin(fx*t) * 2.5,\n        cos(fy*t) * 1.5,\n        sin(fz*t) * 1.5 + 9.0);\n}\n\nHit trace(Ray r)\n{\n    // TODO should be a loop\n    Sphere s1 = Sphere(0, pos(0), 0.7, Material(vec3(0.8, 0.7, 0.6)) );\n    Sphere s2 = Sphere(1, pos(1), 0.7, Material(vec3(0.8, 0.7, 0.6)) );\n    Sphere s3 = Sphere(2, pos(2), 0.7, Material(vec3(0.8, 0.7, 0.6)) );\n    Hit h1 = traceSphere(r,s1);\n    Hit h2 = traceSphere(r,s2);\n    Hit h3 = traceSphere(r,s3);\n    \n    // Find closest ray hit\n    Hit h;\n    h.dist = -1.0;\n    h = h1;\n    if ((h2.dist > 0.0 && h2.dist < h.dist) || (h.dist < 0.0)) h = h2;\n    if ((h3.dist > 0.0 && h3.dist < h.dist) || (h.dist < 0.0)) h = h3;\n    \n    // Shade hit\n    if (h.dist > 0.0) {\n        h.material.c = vec3(0.0);\n        float direct = dot(h.normal, normalize(vec3(0.5, 0.5, -1)));\n        vec3 albedo = pal_1(0.9);\n        h.material.c += albedo * direct;\n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (0..1)\n    vec2 ndc = fragCoord/iResolution.xy;\n    \n    const float fov_x_deg = 60.0;\n    const float screen_distance = 1.0/tan(radians(fov_x_deg/2.0));\n    \n    // \"Screen\" space coordinates (-1..+1 in max dimension)\n    vec2 sp = 2.0*(fragCoord-iResolution.xy/2.0)/max(iResolution.x, iResolution.y);\n    \n    // Left-handed camera ray: +X right, +Y up, +Z into scene\n    Ray cr;\n    cr.r0 = vec3(0.0);\n    cr.rd = vec3(sp.x, sp.y, screen_distance);\n\n    // Sample radiance\n    vec3 c = vec3(0.0);\n    Hit h = trace(cr);\n    if (h.dist >= 0.0) {\n        c += h.material.c;\n    } else {\n        //c += vec3(abs(sp.x), abs(sp.y), 0.0);\n    }\n    \n    // Comp stripes\n    if (true) {\n        float x = ( sp.y) * 70.0;\n        int n = int(mod(x, 4.0));\n        vec3 c2 = c;\n        if (h.id == -1 || (h.id == n || h.id == n+1)) {\n          c2 = pal_1(float(n)*0.25 + iTime*0.2);\n        }\n\t\tfloat on = 5.0;\n        float off = 3.0;\n        float cycle_time = mod(iTime, on+off);\n        if (cycle_time < on) {\n            c = c2;\n        } else {\n          c = mix(c, c2, cos((cycle_time-on)/off*3.14159*2.0)*0.5+0.5);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(c.x, c.y, c.z, 1.0);\n}","name":"Image","description":"","type":"image"}]}