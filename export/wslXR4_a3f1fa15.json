{"ver":"0.1","info":{"id":"wslXR4","date":"1550762769","viewed":90,"name":"my first sdf","username":"petka","description":"My first SDF","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ray","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nshape_sdf get_dist(vec3 p)\n{\n    shape_sdf cur;\n\n    cur = difference_sdf(\n        shape_sdf(box_sdf(p, vec3(0., 1., 6.), 2.), vec3(1., 0., 0.))\n        ,\n        shape_sdf(circle_sdf(p, vec3(0., 1., 6.),  1.3), vec3(0., 1., 0.))\n    );\n\n    cur = union_sdf(\n        cur,\n        shape_sdf(surface_sdf(p, vec3(0., 1., 0.), - 1.), vec3(0., 0., 1.))\n    );\n\n    return cur;\n}\n\nshape_sdf ray_march(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n\tshape_sdf dO;\n\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        dO = get_dist(ro + rd * dist);\n        dist += dO.dist;\n        if (dO.dist < SURF_DIST)\n            break;\n        if (dist > MAX_DIST)\n        {\n            dO.color = vec3(1.);\n            break;\n        }\n    }\n    dO.dist = dist;\n    return dO;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(SURF_DIST, 0.);\n    return normalize(get_dist(p).dist - vec3(get_dist(p-e.xyy).dist, get_dist(p-e.yxy).dist, get_dist(p-e.yyx).dist));\n}\n\nfloat get_light(vec3 p, vec3 lightPos)\n{\n    vec3 l = normalize(lightPos - p);\n    vec3 n = get_normal(p);\n    float d = ray_march(p + n * SURF_DIST * 2., l).dist;\n    float dif = clamp(dot(n, l), 0., 1.);\n    if (d < length(lightPos - p)) dif *= .1;\n    return dif;\n}\n\nvec4 Scene(vec3 ro, vec3 rd)\n{\n    shape_sdf d = ray_march(ro, rd);\n    vec3 p = ro + rd * d.dist;\n#if 1\n    float dif = get_light(p, vec3(0., 5., 6.) + 5. * vec3(sin(iTime), 0., cos(iTime)));\n    return vec4(d.color * dif, 1.);\n#else\n    return vec4(d.color, 1.);\n#endif\n}\n\n#define EYE .4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 ro = vec3(0., 1., 0.);\n    vec3 uv = Stereo(iResolution.xy, fragCoord.xy);\n\n    uv.xy = fisheye(uv.xy);\n\n    ro.x = uv.z * EYE;\n    ro.y += .5 * sin(.25 * iTime);\n\n    uv.xy *= 1. + .5 * sin(.125 * iTime);\n\n    fragColor = Scene(ro, normalize(vec3(uv.xy, 1)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct shape_sdf { float dist; vec3 color; };\n\n\nfloat circle_sdf(vec3 p, vec3 pos, float size)\n{\n    return length(p - pos) - size;\n}\n\nfloat box_sdf(vec3 p, vec3 pos, float size)\n{\n    p = abs(p - pos);\n    return max(p.x, max(p.y, p.z)) - size * .5;\n}\n\nfloat surface_sdf(vec3 p, vec3 orientation, float dist)\n{\n    return dot(p, orientation) - dist;\n}\n\nshape_sdf intersect_sdf(shape_sdf A, shape_sdf B) { if (A.dist > B.dist) return A; return B; }\nshape_sdf union_sdf(shape_sdf A, shape_sdf B) { if (A.dist < B.dist) return A; return B; }\nshape_sdf difference_sdf(shape_sdf A, shape_sdf B) { B.dist = - B.dist; return intersect_sdf(A, B); }\n\nvec3 Stereo(vec2 res, vec2 p)\n{\n    vec3 uv;\n    uv = vec3(2. * p / res - vec2(1.), -1.);\n    res.x *= .5;\n    res /= res.x;\n    if (uv.x < 0.)\n    {\n        uv.x += 1.;\n        uv.z *= -1.;\n    }\n    uv.x = uv.x * 2. - 1.;\n    uv.xy *= res;\n    return uv;\n}\n\nvec2 fisheye(vec2 uv)\n{\n    float d = length(uv);\n    float r = atan(d, sqrt(1. - d * d)) / 3.14159;\n    float phi = atan(uv.y, uv.x);\n    return 2. * r * vec2(cos(phi), sin(phi));\n}\n\n","name":"Common","description":"","type":"common"}]}