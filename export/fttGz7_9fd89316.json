{"ver":"0.1","info":{"id":"fttGz7","date":"1636034971","viewed":557,"name":"Interactive Hilbert CA","username":"Carandiru","description":"use keyboard arrow keys to manipulate the bits / rule the CA is influenced by.\nleft/right - select bit\nup/down - set/clear selected bit\nmouse click & pan - zoomish","likes":14,"published":3,"flags":48,"usePreview":0,"tags":["noise","pixel","automata","cellular","hilbert"],"hasliked":0,"parentid":"ssVXWd","parentname":"hilbert CA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/fttGz7#\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// ** use keyboard arrow keys to manipulate the bits / rule the CA uses.\n// ** left/right - select bit\n// ** up/down - set/clear selected bit\n// ** mouse click & pan - zoomish\n\n// viridis palette function port //             \n#define fma(a,b,c) (a*b+c)\n\nvec3 viridis(float t) \n{\n\tconst vec3 _c0 = vec3( 0.2777273272234177, 0.005407344544966578, 0.3340998053353061 );\n\tconst vec3 _c1 = vec3( 0.1050930431085774, 1.404613529898575, 1.384590162594685 );\n\tconst vec3 _c2 = vec3( -0.3308618287255563, 0.214847559468213, 0.09509516302823659 );\n\tconst vec3 _c3 = vec3( -4.634230498983486, -5.799100973351585, -19.33244095627987 );\n\tconst vec3 _c4 = vec3( 6.228269936347081, 14.17993336680509, 56.69055260068105 );\n\tconst vec3 _c5 = vec3( 4.776384997670288, -13.74514537774601, -65.35303263337234 );  \n    const vec3 _c6 = vec3( -5.435455855934631, 4.645852612178535, 26.3124352495832 );  \n\n\tvec3 xmT = vec3(t);\n    \n    vec3 x;\n\n    // c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))))\n    x = fma(xmT, _c6, _c5);\n    x = fma(x, xmT, _c4);\n    x = fma(x, xmT, _c3);\n    x = fma(x, xmT, _c2);\n    x = fma(x, xmT, _c1);\n    x = fma(x, xmT, _c0);\n\n    return(x);\n}\n\nvec3 RGBToOKLAB(in vec3 rgb)\n{\n\tconst mat3 kCONEtoLMS = mat3(                \n         0.4122214708f,  0.2119034982f,  0.0883024619f,\n         0.5363325363f,  0.6806995451f,  0.2817188376f,\n         0.0514459929f,  0.1073969566f,  0.6299787005f);\n\n\treturn( pow(kCONEtoLMS*rgb, vec3(1.0f/3.0f)) );\n}\n\nvec3 OKLABToRGB(in vec3 oklab)\n{\n\tconst mat3 kLMStoCONE = mat3(\n         4.0767416621f, -1.2684380046f, -0.0041960863f,\n        -3.3077115913f,  2.6097574011f, -0.7034186147f,\n         0.2309699292f, -0.3413193965f,  1.7076147010f);\n\n\treturn(kLMStoCONE*(oklab*oklab*oklab));\n}\n\nvec2 rndC(in vec2 pixel) // good function, works with any texture sampling that uses interpolation\n{\n    pixel = pixel + 0.5f;\n    vec2 ipixel = floor( pixel );\n    vec2 fpixel = fract( pixel );\n    \n\tpixel = ipixel + fpixel*fpixel*(3.0f-2.0f*fpixel); \n \n\treturn(pixel - 0.5f);  // returns in same unit as input, pixels\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     \n    vec4 h = textureLod(iChannel0, rndC(fragCoord)/iResolution.xy, 0.0f);\n    \n\n    float hs = smoothstep(0.0f, 4.0f, (h.x+h.y+h.z+h.w));\n    //hs = hs * hs;\n   \n    hs = hs + textureLod(iChannel2, fragCoord.xy / 1024.0f, 0.0f).r * (17.0f/255.0f);\n    vec3 color;\n    color = RGBToOKLAB(viridis(hs));\n    color = color + (h.x * abs(hs - h.x) + hs) * color * 0.05f;\n    color = OKLABToRGB(color);\n   \n    float overlay = textureLod(iChannel1, uv, 0.0f).r;\n    \n    color += overlay;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/fttGz7#\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n\nuint width()\n{\n    uint mini = uint(min(iResolution.x, iResolution.y));\n    \n    --mini;\n    mini |= (mini >> 1u);\n    mini |= (mini >> 2u);\n    mini |= (mini >> 4u);\n    mini |= (mini >> 8u);\n    mini |= (mini >> 16u);\n    ++mini;\n    \n    return max(1u, mini);\n}\n\nfloat hilbert1D(in uvec2 Position, in uint w){   \n    \n    uint Index = 0u;\n    \n    for(uint CurLevel = (w>>1u); CurLevel > 0u; CurLevel >>= 1u){\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel*CurLevel*((3u*Region.x)^Region.y);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(w-1u) - Position;\n            }\n            Position.xy=Position.yx;\n        }\n    }\n    return (float(Index)/float(w*w));\n}\n\nvec2 hilbert2D(in uint Index, in uint w){   \n    \n    uvec2 Position = uvec2(0u);\n    \n    for(uint CurLevel = 1u; CurLevel < w; CurLevel <<= 1){\n        uvec2 Region;\n        Region.x = 1u & (Index >> 1u);\n        Region.y = 1u & (Index ^ Region.x);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(CurLevel-1u) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n        Position += CurLevel * Region;\n        Index >>= 2u;\n    }\n    return vec2(Position);\n}\n\nvoid unpack_rule(out float rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = float(bool(r & (1u << 7u)));\n    rule[1] = float(bool(r & (1u << 6u)));\n    rule[2] = float(bool(r & (1u << 5u)));\n    rule[3] = float(bool(r & (1u << 4u)));\n    rule[4] = float(bool(r & (1u << 3u)));\n    rule[5] = float(bool(r & (1u << 2u)));\n    rule[6] = float(bool(r & (1u << 1u)));\n    rule[7] = float(bool(r & (1u << 0u)));\n}\n\nconst vec4 balance = vec4(0.249999f, 0.24999f, 0.2499f, 0.249f);\n\nfloat state(in float rule[directions], in vec3 s)\n{\n    uint d = 0u;\n    \n    d |= uint(bool(round(s.x))) << 2u;\n    d |= uint(bool(round(s.y))) << 1u;\n    d |= uint(bool(round(s.z))) << 0u;\n    \n    return rule[7u - d];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 rr = textureLod(iChannel2, uv, 0.0f).ba;\n    \n    uint frame = uint(rr.x * convert_length);\n    \n    if (frame < 2u) {\n        fragColor = textureLod(iChannel1, fragCoord/1024.0f, 0.0f);\n        return;\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float rule[directions];\n    unpack_rule(rule, rr.y);\n    \n    mat3 nn;\n\n    // tl\n    nn[0].x = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1,-1)).r;\n    // t\n    nn[0].y = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0,-1)).r;\n    // tr\n    nn[0].z = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1,-1)).r;\n       \n    // l\n    nn[1].x = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 0)).r;\n    // c\n    nn[1].y = textureLod(iChannel0, uv, 0.0f).r;\n    // r\n    nn[1].z = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0, 1)).r;\n        \n    // bl    \n    nn[2].x = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 1)).r;\n    // b\n    nn[2].y = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0, 1)).r;\n    // br\n    nn[2].z = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1, 1)).r;\n    \n    vec3 row = vec3(state(rule, nn[0]), state(rule, nn[1]), state(rule, nn[2]));\n        \n    mat3 nna;\n    \n    /*\n    nna[0] = row.xyz;\n    nna[1] = row.zxy;\n    nna[2] = row.yzx;\n    */\n    \n    \n    nna[0] = cross(row, nn[0]);\n    nna[1] = cross(row, nn[1]);\n    nna[2] = cross(row, nn[2]);\n    \n    \n    nna = nna * (2.0f * GOLDEN_RATIO_ZERO) + nn * (GOLDEN_RATIO_ZERO);\n    \n    bool moused = bool((iMouse.z * iTimeDelta) >= 0.5f);\n    uint w = width() << uint(moused);\n    \n    float d = float(frame + 1u);\n    vec2 htl = hilbert2D(uint(nna[0].x * d), w);\n    vec2 ht  = hilbert2D(uint(nna[0].y * d), w);\n    vec2 htr = hilbert2D(uint(nna[0].z * d), w);\n    vec2 hl  = hilbert2D(uint(nna[1].x * d), w);\n    vec2 hr  = hilbert2D(uint(nna[1].z * d), w);\n    vec2 hbl = hilbert2D(uint(nna[2].x * d), w);\n    vec2 hb  = hilbert2D(uint(nna[2].y * d), w);\n    vec2 hbr = hilbert2D(uint(nna[2].z * d), w);\n    \n    vec2 dir =    htl  // vec2(-1, -1) \n                + ht   // vec2( 0, -1) \n                + htr  // vec2( 1, -1) \n                + hl   // vec2(-1,  0) \n                + hr   // vec2( 1,  0) \n                + hbl  // vec2(-1,  1) \n                + hb   // vec2( 0,  1) \n                + hbr; // vec2( 1,  1);\n    \n    \n    vec2 mouse = iMouse.xy * float(moused) * 10.0f;\n    \n    float h;\n      \n    h = hilbert1D(uvec2(fragCoord.xy + mouse + dir), w);\n       \n   // h = bellcurve(h);\n   // h = smoothstep(0.9998f, 1.0f, h);\n        \n    mat4 hm;\n    hm[0] = textureLod(iChannel0, uv, 0.0f);\n    hm[1] = textureLod(iChannel0, uv, 1.0f);\n    hm[2] = textureLod(iChannel0, uv, 2.0f);\n    hm[3] = textureLod(iChannel0, uv, 3.0f);\n    \n    hm = transpose(hm);\n       \n    vec4 bhm = vec4(dot(balance, hm[0]), \n                    dot(balance, hm[1]),\n                    dot(balance, hm[2]),\n                    dot(balance, hm[3]));\n    \n    h = h + dot(balance, bhm) * balance.x;\n    \n    mat4 hn = transpose(mat4(nna));\n    \n    vec4 bhn = vec4(dot(balance, hn[0]), \n                    dot(balance, hn[1]),\n                    dot(balance, hn[2]),\n                    dot(balance, hn[3]));\n                    \n    vec3 n = mix(bhm.xyz, bhn.xyz, 0.4999f);\n    \n    fragColor = vec4(h, n);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/fttGz7#\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define PI (3.141592654f)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define directions (8)\n#define convert_length 4.294967295e9f\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(PI / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}\n\nvec4 bellcurve(vec4 x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(PI / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/fttGz7#\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nint rule[directions] = int[directions]( 0, 1, 1, 0, 1, 1, 1, 0 );\n\nfloat pack_rule()\n{\n    int r = 0;\n    r = (rule[0] << 7) | \n        (rule[1] << 6) |\n        (rule[2] << 5) |\n        (rule[3] << 4) |\n        (rule[4] << 3) |\n        (rule[5] << 2) |\n        (rule[6] << 1) |\n        (rule[7] << 0);\n        \n    return(float(uint(r)) / 255.0f);\n\n}\n\nvoid unpack_rule(out int rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = int(bool(r & (1u << 7u)));\n    rule[1] = int(bool(r & (1u << 6u)));\n    rule[2] = int(bool(r & (1u << 5u)));\n    rule[3] = int(bool(r & (1u << 4u)));\n    rule[4] = int(bool(r & (1u << 3u)));\n    rule[5] = int(bool(r & (1u << 2u)));\n    rule[6] = int(bool(r & (1u << 1u)));\n    rule[7] = int(bool(r & (1u << 0u)));\n}\n\n// Original text shader taken from https://www.shadertoy.com/view/MstBzN by Rafbeam\nconst int CHARS[41] = int[](\n    0x00000000, \n    0x00E8FE31, \n    0x01E8FA3E, \n    0x00F8420F, \n    0x01E8C63E,\n    \n    0x01F87A1F, \n    0x01F87A10, \n    0x00F84E2F, \n    0x0118FE31, \n    0x00421084,\n    \n    0x01F0862F, \n    0x01197251, \n    0x0108421F, \n    0x01BAD6B1, \n    0x011CD671,\n    \n    0x00E8C62E, \n    0x01E8FA10, \n    0x00E8D66E, \n    0x01E8FA31,\n    0x00F8383E,\n    \n    0x0000001F, \n    0x0118C62E, \n    0x0118C544, \n    0x0118C6AA, \n    0x01151151,\n    \n    0x0118A884, \n    0x01F9113F, \n    0x00ECD66E, \n    0x0046509F, \n    0x00E8991F, \n    \n    0x00E89A2E, \n    0x00232BE2, \n    0x01F8383E, \n    0x00F87E3E, \n    0x01F11108, \n    \n    0x00E8BA2E, \n    0x00F8FC3E, \n    0x00000004, \n    0x00000088, \n    0x00421004, \n    0x00E11004\n);\n\nfloat character(float color, float background, int character, vec2 position, float size, vec2 uv)\n{\n    if((uv.x > position.x && uv.x < position.x + size) && (uv.y > position.y && uv.y < position.y + size))\n    {\n        ivec2 pixel = ivec2(ceil((uv.x-position.x)/size*5.0)-1.0, ceil((1.0-(uv.y-position.y)/size)*5.0)-1.0);\n        int bit_index = pixel.y*5 + pixel.x;\n        int bit = (CHARS[character] >> (24 - bit_index))&1;\n        if(bit > 0)\n            return color;\n    }\n    return background;\n}\n\n#define EOL 0\n#define _ 0,\n#define A 1,\n#define B 2,\n#define C 3,\n#define D 4,\n#define E 5,\n#define F 6,\n#define G 7,\n#define H 8,\n#define I 9,\n#define J 10,\n#define K 11,\n#define L 12,\n#define M 13,\n#define N 14,\n#define O 15,\n#define P 16,\n#define Q 17,\n#define R 18,\n#define S 19,\n#define T 20,\n#define U 21,\n#define V 22,\n#define W 23,\n#define X 24,\n#define Y 25,\n#define Z 26,\n\n#define DOT 37,\n#define COMMA 38,\n#define BANG 39,\n#define QUESTION 40,\n\n#define EOL1 0\n#define EOL2 EOL1,EOL1\n#define EOL3 EOL2,EOL1\n#define EOL4 EOL3,EOL1\n#define EOL5 EOL4,EOL1\n#define EOL6 EOL5,EOL1\n#define EOL7 EOL6,EOL1\n#define EOL8 EOL7,EOL1\n#define EOL9 EOL8,EOL1\n#define EOL10 EOL9,EOL1\n#define EOL11 EOL10,EOL1\n#define EOL12 EOL11,EOL1\n#define EOL13 EOL12,EOL1\n#define EOL14 EOL13,EOL1\n#define EOL15 EOL14,EOL1\n#define EOL16 EOL15,EOL1\n#define EOL17 EOL16,EOL1\n#define EOL18 EOL17,EOL1\n#define EOL19 EOL18,EOL1\n#define EOL20 EOL19,EOL1\n#define EOL21 EOL20,EOL1\n#define EOL22 EOL21,EOL1\n#define EOL23 EOL22,EOL1\n#define EOL24 EOL23,EOL1\n#define EOL25 EOL24,EOL1\n#define EOL26 EOL25,EOL1\n#define EOL27 EOL26,EOL1\n#define EOL28 EOL27,EOL1\n#define EOL29 EOL28,EOL1\n#define EOL30 EOL29,EOL1\n\n#define LEN0 EOL30\n#define LEN1 EOL29\n#define LEN2 EOL28\n#define LEN3 EOL27\n#define LEN4 EOL26\n#define LEN5 EOL25\n#define LEN6 EOL24\n#define LEN7 EOL23\n#define LEN8 EOL22\n#define LEN9 EOL21\n#define LEN10 EOL20\n#define LEN11 EOL19\n#define LEN12 EOL18\n#define LEN13 EOL17\n#define LEN14 EOL16\n#define LEN15 EOL15\n#define LEN16 EOL14\n#define LEN17 EOL13\n#define LEN18 EOL12\n#define LEN19 EOL11\n#define LEN20 EOL10\n#define LEN21 EOL9\n#define LEN22 EOL8\n#define LEN23 EOL7\n#define LEN24 EOL6\n#define LEN25 EOL5\n#define LEN26 EOL4\n#define LEN27 EOL3\n#define LEN28 EOL2\n#define LEN29 EOL1\n#define LEN30 EOL0\n\nvec2 uv = vec2(0);\nfloat text_color = float(0.0);\nconst float TEXT_COLOR = float(0.95);\nconst float TEXT_SIZE = 0.03;\nconst float TEXT_SIZE2 = 0.03 + 0.04/5.0;\nvec2 TEXT_POSITION = vec2(0.0);\n\nvoid text(int LINE[directions*2]) {\n \tfor(int i = 0; i < (directions*2); i++)\n        text_color = character(TEXT_COLOR, text_color, LINE[i], vec2(0,1) + TEXT_POSITION*vec2(1,-1) + vec2(TEXT_SIZE2 * float(i), 0.), TEXT_SIZE, uv);\n}\n\n#define TEXT(x,y) text(int[](x y));\n#define TEXT2(x) text(x);\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 10) {\n        fragColor = vec4(vec2(0), float(uint(iFrame)) / convert_length, pack_rule());\n        return;\n    }\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 last = textureLod(iChannel0, uv, 0.0f).gb;\n    uint frame = uint(last.y * convert_length);\n        \n    int bit = int( last.x * 7.0f );\n    \n    bit = max(0, bit - int(texelFetch( iChannel1, ivec2(KEY_LEFT,1),0 ).x)); // press\n    bit = min(directions - 1, bit + int(texelFetch( iChannel1, ivec2(KEY_RIGHT,1),0 ).x)); // press\n    \n    // selector\n    TEXT_POSITION = vec2(0.195f, 0.9925f);\n    {\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        binary[bit * 2] = 20;\n\n        TEXT2(binary);\n        \n        text_color *= 1.0f - max(sin(iTime * 9.0f), 0.0f);\n    }\n    \n    float frame_next = 0.0f;\n    \n    // digits\n    TEXT_POSITION = vec2(0.195f, 0.97f);\n    {\n        float r = textureLod(iChannel0, uv, 0.0f).a;\n        unpack_rule(rule, r);\n        \n        int dir = 0, reset = 0;\n        dir = int(texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x);\n        //reset |= dir & ~rule[bit];\n        rule[bit] |= dir;\n                \n        dir = int(texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x);\n        //reset |= dir & rule[bit];\n        rule[bit] &= ~dir;\n        \n        if (0 == reset) {\n        \n            bool moused = bool((iMouse.z * iTimeDelta) >= 0.5f);\n            frame_next = float(frame) + float(!moused) * (1.0f + iTimeDelta);\n            \n        }\n        \n        const int select[2] = int[2]( 15, 9 );\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        for (int n = 0 ; n < directions ; ++n) {\n            binary[n+n] = select[rule[n]];\n        }\n\n        TEXT2(binary);\n    }\n    \n    fragColor = vec4(text_color, float(bit) / 7.0f, frame_next / convert_length,\n                     pack_rule());\n}","name":"Buffer B","description":"","type":"buffer"}]}