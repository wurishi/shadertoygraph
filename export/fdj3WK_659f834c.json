{"ver":"0.1","info":{"id":"fdj3WK","date":"1617983221","viewed":50,"name":"assig1","username":"sofien","description":"proj","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["assig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//time variable declaration\nfloat time ;\n//pi declaration\nconst float pi = 3.1415926535897932384626433832795;\n// value Material declaration\nstruct Material {\n  vec3 color      ;\n  float roughness ;\n  vec3 emession ;\n  float metalness ;\n};\n\n// value Value declaration\nstruct Value\n{\n   float d ;\n   int matid;\n};\n\n\n\n//primitive 1\nValue sdPlane( vec3 p, vec3 n, float h , int matid )\n{\n  // n must be normalized\n  return Value ((dot(p,n) + h),matid);\n}\n\n//primitive 2\nValue sdBox( vec3 p, vec3 b , int matid)\n{\n  vec3 q = abs(p) - b;\n  return  Value ((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)),matid);\n} \n\n//primitive 3\nValue sdLink( vec3 p, float le, float r1, float r2 ,int matid )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return Value ((length(vec2(length(q.xy)-r1,q.z)) - r2),matid);\n}\n\n//primitive 4\nValue sdSphere( vec3 p, float r, int matid)\n{\n  return Value ((length(p)-r),matid);\n}\n\n//primitive 5\nValue sdTorus( vec3 p, vec2 t , int matid)\n{ \n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Value ((length(q)-t.y),matid);\n}\n \n//primitive 6 \nValue sdCylinder( vec3 p, vec3 c , int matid )\n{\n  return Value ((length(p.xz-c.xy)-c.z),matid);\n}\n\n//primitive 7\nValue sdVerticalCapsule( vec3 p, float h, float r, int matid )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return Value (length( p ) - r , matid);\n}\n\nValue sdOctahedron( vec3 p, float s , int matid)\n{\n  p = abs(p);\n  return Value (((p.x+p.y+p.z-s)*0.57735027),matid);\n}\n\n//union operation\nValue uni(Value A,Value B)\n{ \n  if (A.d<B.d) return A ;\n  return B ;\n}\n\n// intersect operation \nValue intersct(Value A ,Value B)\n{ \n  if (A.d>B.d) return A ;\n  return B ;\n}\n\n//substruct operation\nValue difer(Value A ,Value B)\n{\n  if (-A.d>B.d) return Value(-A.d,A.matid) ;\n  return B ;\n}\n\n// distance function\n\nValue sdf(in vec3 p)\n{  // float ti = time ;\n    p-=vec3(0,0,1);\n    float ti = sin(time);\n    \n    //initialize plane\n    Value D = sdPlane( p, vec3(0.09,0.0,0.09) , 2.6 , 2 );\n    \n    \n    //initialize prim1\n    Value prim1 = sdBox( p, vec3(1.2,0.09,1.0*ti) , 3) ;\n    Value prim7 = sdBox( p+vec3(0.2,0.01,0.1), vec3(0.2,0.3*ti,2.0) , 3) ;\n    Value prim8 = sdLink( p+vec3(-1.,-0.8,-3.8*ti), 0.08*ti, 0.5, 0.2*ti, 2 );\n    Value prim9 = sdSphere( p+vec3(-3.8,-0.9,-7.2*ti), 0.6, 1) ;\n    Value prim10 = sdVerticalCapsule( p+vec3(-2.5*ti,0.0,-8.8), 1.9,  0.3, 4 );\n    Value prim11 = sdTorus( p+vec3(6.0,-1.4*ti,-14.1), vec2(0.4*ti,1.2) , 3) ;\n    Value prim12 = sdOctahedron( p+vec3(1.9*ti,-2.,-15.), 1.5 , 2);\n    Value prim13 = sdTorus( p+vec3(-3.0,-1.4*ti,-14.1), vec2(0.4,1.5*ti) , 3) ;\n    Value prim14 = sdOctahedron( p+vec3(-3.0,-1.4*ti,-14.1), 2.8 , 2);\n    Value k= uni(prim14,prim13);\n    //initialize prim2\n    Value prim2 = sdLink( p, 0.1, 0.8, 0.42, 2 );\n    //initialize prim3\n    Value prim3 = sdSphere( p, 1., 4) ;\n    //initialize prim4\n    Value prim4 = sdTorus( p+vec3(1.9,2.0,1.1), vec2(0.6*ti,1.2) , 1) ;\n    //initialize prim5\n    Value prim5 = sdCylinder( p+vec3(1.0,1.0,4.0*ti), vec3(1.4,0.4*ti,0.2) , 1 ) ;\n    //initialize prim6\n    Value prim6 = sdVerticalCapsule( p, 1.9*ti,  0.3, 4 );\n    Value op1 = difer (prim1,prim2)  ;\n    Value op2 = uni (prim3,prim4)  ;\n    Value op3 = uni(prim5,prim6)  ;\n    Value op4 = intersct (prim5,prim6) ;\n    \n    D = uni (D,op1)  ;\n    D = uni (D,op2)  ;\n    D = uni (D,op3)  ;\n    D = uni (D,op4)  ;\n    D = uni (D,prim7) ;\n    D = uni (D,prim8) ;\n    D = uni (D,prim9) ;\n    D = uni (D,prim10) ;\n    D = uni (D,prim11) ;\n    D = uni (D,prim12) ;\n    D = uni(D,k);\n    \n   // D = uni\n  return  Value(min(p.y+1., D.d), D.matid) ;\n}\n\n// struct Ray declaration\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\n// struct TraceResult declaration\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\n    int mid ;\n};                  \n\n// struct SpheretraceDesc declaration\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\n\n\n//table of Material\nconst Material[5] matr = Material[5](Material(vec3(1.1,1.6,2.1), 10.0, vec3(0.1,0.1,0.1), 0.03),\n                                 Material(vec3(2.1,1.3,0.6), 20.0, vec3(0.2,0.1,0.2), 0.7),\n                                 Material(vec3(0.7,2.7,1.5), 30.0, vec3(0.2,0.3,0.3), 0.8),\n                                 Material(vec3(1.,0.0,1.0), 40.0, vec3(0.4,0.3,0.8), 0.9),\n                                 Material(vec3(1.1,1.4,1.6), 50.0, vec3(0.2,0.2,0.2), 0.06));\n\n\n\n // function initializeRay declaration\n /*Ray initializeRay(int matid)\n {\n   Material m = matr[matid] ;\n   return Ray (m.color,m.roughness,m.emession,m.metalness) ;\n }*/\n\n// sphere_trace \nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0,1);\n    Value dis ;\n    \n    int i = 0; do\n    {\n      dis = sdf(ray.P+ret.T*ray.V);\n        ret.mid=dis.matid ;\n        ret.T+=dis.d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\tdis.d\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(dis.d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n// normal function\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3((sdf(p+vec3(eps,0,0))).d,(sdf(p+vec3(0,eps,0))).d,(sdf(p+vec3(0,0,eps))).d);\n    vec3 minu = vec3((sdf(p-vec3(eps,0,0))).d,(sdf(p-vec3(0,eps,0))).d,(sdf(p-vec3(0,0,eps))).d);\n    return normalize(plus-minu);\n}\n//missColor function\nvec4 missColor(Ray ray)\n{\nreturn vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\nreturn vec4(1.,0.,0.,1.);\n}\n//hitColor function\nvec4 hitColor(Ray ray,float t, int Mid)\n{\n    Material mt = matr[Mid] ;\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    vec3[2] lightsPos = vec3[2](vec3(10.*sin(iTime),5.,10.*cos(iTime)),vec3(7.5,5.5,4.5));\n    \n    //vec3 lightPos1=vec3(5.,5.,5.);\n   // vec3 lightPos2=vec3(9.5,9.5,9.5);\n    for (int i =0;i<2;i++)\n    {\n    vec3 v = -ray.V;\n    vec3 l = normalize(lightsPos[i]-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = mt.color;\n    \n    //specular\n    vec3 toLight = normalize(lightsPos[i] - p);\n    vec3 toEye = -ray.V;\n    vec3 k_s = vec3(mt.metalness);\n    \n    vec3 h = normalize(toLight+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),100.);\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta;\n    \n    return vec4(col,1.);\n    }\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-15.5,0.,4.);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+vec3(EyeStartPosition.x,EyeStartPosition.y*cos(iTime),EyeStartPosition.z*sin(iTime));\t // camera position\n   // eye += vec3((0.5*sin(0.5*iTime) + 0.5*cos(0.5*iTime)), 0, 0);\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime ;\n // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n    \n    SphereTraceDesc params = SphereTraceDesc(0.006, 1000);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T,result.mid);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;\n    fragColor.w = result.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n\n}","name":"Image","description":"","type":"image"}]}