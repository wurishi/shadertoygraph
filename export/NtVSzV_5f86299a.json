{"ver":"0.1","info":{"id":"NtVSzV","date":"1641062341","viewed":263,"name":"Shadows and AO","username":"PGRacer","description":"Added shadows and ambient occlusion to my raymarcher.  Fun little scene to show it off.\n\nWASD ~ move\nspace/shift ~ up/down\nQ/E ~ tilt\n1-9 ~ select move speed\nF ~ realign camera.","likes":18,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","shadows","blending","ambientocclusion"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////\n// IMAGE SHADER //\n//////////////////\n\n// Define Objects Here\nfloat GetDist(vec3 p)\n{\n    vec3 pBox = Rot3(PI, UP) * (p - vec3(-1.0, -0.0, 0.0));\n    float dBox = Box(pBox, vec3(0.25, 2.0, 2.0));\n    \n    vec3 pFrame1 = Rot3(PI, UP) * (p - vec3(-1.0, -0.75, 0.0));\n    float dFrame1 = BoxFrame(pFrame1, vec3(0.2, 0.3, 1.05), 0.001) - 0.025;\n    \n    vec3 pFrame2 = Rot3(PI, UP) * (p - vec3(-1.0, 0.30, 0.0));\n    float dFrame2 = BoxFrame(pFrame2, vec3(0.2, 0.74, 1.05), 0.001) - 0.025;\n    \n    vec3 pTorus1 = Rot3(TIME, FORWARD) * (p - UP * 0.25);\n    float dTorus1 = Torus(pTorus1, 0.5, 0.1);\n    \n    vec3 pSphere1 = p - vec3(0.0, 0.25 + sin(TIME), 0.0);\n    float dSphere1 = Sphere(pSphere1, 0.2);\n    \n    vec3 pSphere2 = p - vec3(cos(TIME), 0.25, 0.0);\n    float dSphere2 = Sphere(pSphere2, 0.2);\n    \n    vec3 pCylinder = Rot3(PI / 2.0, FORWARD) * (p - vec3(1.3, -0.75, 0.0));\n    float dCylinder = Cylinder(pCylinder, 1.0, 0.2);\n    \n    vec3 pCone = p - vec3(1.3, 0.05, 0.0);\n    float dCone = Cone(pCone, vec2(0.5), 0.25);\n    \n    vec3 pTorus2 = Rot3(TIME * 8.0, UP) * (p - RIGHT * 1.3) - vec3(0.2, -0.68, 0.0);\n    float dTorus2 = Torus(pTorus2, 0.5, 0.1);\n    \n    vec3 pTorus3 = Rot3(-TIME * 8.0, UP) * (p - RIGHT * 1.3) - vec3(0.2, -0.48, 0.0);\n    float dTorus3 = Torus(pTorus3, 0.5, 0.1);\n    \n    vec3 pPlatform = Rot3(PI / 2.0, FORWARD) * (p - DOWN);\n    float dPlatform = Cylinder(pPlatform, 0.000001, 4.0) - 0.025;\n    \n    float platformBlend = SmoothAdd(dPlatform, dCylinder, .5);\n    platformBlend = SmoothAdd(platformBlend, dCone, 0.5);\n    platformBlend = SmoothAdd(platformBlend, dSphere1, 1.5);\n    \n    dBox = max(dBox, -(dSphere2 - 0.2));\n    \n    float dist = min(dBox, dFrame1);\n    dist = min(dist, dFrame2);\n    dist = min(dist, dTorus1);\n    dist = min(dist, dSphere2);\n    dist = min(dist, platformBlend);\n    dist = min(dist, dTorus2);\n    dist = min(dist, dTorus3);\n    \n    return dist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 e = vec2(NRM_CHECK_OFFSET, 0);\n    \n\tvec3 n = GetDist(p) - vec3(\n\t\tGetDist(p - e.xyy),\n\t\tGetDist(p - e.yxy),\n\t\tGetDist(p - e.yyx)\n\t\t);\n\treturn normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = AO_REACH;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = GetDist(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return (1.0 - smoothstep(-AO_ATTENUATION, AO_ATTENUATION, oc)) * (1.0 - AMBIENT_MIN) + AMBIENT_MIN;\n}\n\nbool LightMarch(vec3 surfPos, vec3 lightPos)\n{\n    float dO = 0.0;\n    vec3 rayDir = normalize(lightPos - surfPos);\n    float lightDist = distance(surfPos, lightPos);\n    float ao;\n    \n    while (dO < lightDist)\n\t{\n        vec3 p = surfPos + rayDir * dO;\n        float d = GetDist(p);\n        dO += d;\n        \n        if (d <= SURF_DIST)\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Keep outline width same in full screen\n    float outlineWidth = OL_WIDTH / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    float vignette = smoothstep(0.9, 0.001, length(uv));\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    // Camera Stuff\n    vec3 camPos = textureLod(iChannel0, vec2(0.5, 0.5)/iResolution.xy, 0.0).xyz;\n    vec3 camRot = textureLod(iChannel0, vec2(1.5, 0.5)/iResolution.xy, 0.0).xyz;\n    \n    mat3x3 yawMat = Rot3(camRot.x, UP);\n    mat3x3 pitchMat = Rot3(camRot.y, RIGHT);\n    mat3x3 rollMat = Rot3(camRot.z, FORWARD);\n    mat3x3 rotMat = yawMat * pitchMat * rollMat;\n    vec3 camDir = rotMat * normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Do raymarching\n    float dO = 0.0;\n\tvec3 p;\n\tbool hit = false;\n\tbool outline = false;\n    float prevDist = MAX_DIST * MAX_DIST;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tp = camPos + camDir * dO;\n\t\tfloat d = GetDist(p);\n\t\tdO += d;\n\n\t\tif (!outline && d < outlineWidth * pow(dO, OL_DIST_COMP))\n\t\t{\n\t\t\toutline = true;\n\t\t}\n\n\t\tif (dO > MAX_DIST)\n\t\t{\n            outline = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d < SURF_DIST)\n\t\t{\n            hit = true;\n            outline = false;\n\t\t\tbreak;\n\t\t}\n        \n        // If at any point we've gotten within the thickness of our outline and \n        // then we get further away from a hit we break out and draw the outline\n        if (outline && prevDist < d)\n        {\n            break;\n        }\n        \n        prevDist = d;\n\t}\n    \n    vec3 col = vec3(1.0);\n    vec3 bgCol = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), smoothstep(-1.0, -.25, -abs(camDir.y)));\n    \n    \n    if (hit)\n    {\n        vec3 normal = GetNormal(p);\n        float ao = ambientOcclusion(p, normal);\n        vec3 absNormal = abs(normal);\n        \n        vec3 lightPos = vec3(5.0, 5.0 + nsin(TIME * 0.25) * 3.0, 5.0);\n        lightPos = Rot3(TIME * 0.623, UP) * lightPos; \n        bool shadowed = LightMarch(p + normal * SURF_DIST * 1.01, lightPos);\n        \n        vec3 lightDir = normalize(p - lightPos);\n        float lightDist = distance(p, lightPos);\n        float attenuation = 1.0 / (pow(lightDist, 2.0));\n        float lightIntensity = LIGHT_POWER * attenuation;\n        float ambientRatio = AMBIENT_MIN;\n        float ambientIntensity = lightIntensity * ambientRatio;\n        \n        float scalar = dot(-lightDir, normal);\n        scalar = clamp(0.0, 1.0, scalar);\n        float directIntensity = mix(ambientIntensity, lightIntensity, scalar);\n        \n        float distRatio = dO / MAX_DIST;\n        col = mix(shadowed ? col * ambientIntensity : col * directIntensity, bgCol, distRatio);\n        \n        col *= ao;\n        col = mix(bgCol, col, smoothstep(MAX_DIST, 0.0, dO));\n    }\n    else if (outline)\n    {\n        col = vec3(0.0);\n        col = mix(bgCol, col, smoothstep(MAX_DIST, 0.0, dO));\n    }\n    else\n    {\n        col = bgCol;\n    }\n    \n    // Fade scene in at start\n    col *= smoothstep(FADE_IN_DELAY, FADE_IN_DELAY + FADE_IN_LENGTH, iTime);\n    //col *= vignette;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////\n// COMMON FUNCTIONS AND VALUES //\n/////////////////////////////////\n\n// RAYMARCHING\n#define MAX_STEPS 500\n#define MAX_DIST 20.0\n#define SURF_DIST 0.0001\n#define NRM_CHECK_OFFSET 0.000001\n\n// OUTLINE\n#define OL_WIDTH 5.0\n#define OL_DIST_COMP 0.7 // 0.0 lines shrink linearly with distance, 0.5 - lines stay same world-width at all distances, 1.0 - lines stay same screen width at distance \n\n// LIGHTING\n#define COLOR_SEPARATION 1.0\n#define LIGHT_POWER 100.0\n#define AO_REACH 0.015\n#define AMBIENT_MIN 0.25\n#define AO_ATTENUATION 4.0\n\n// TIMING\n#define TIME iTime * 1.0\n\n// SCENE START\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n\n// COMMON CONSTANTS\n#define PI 3.141592\n\n// VECTORS\n#define FORWARD vec3(0.0, 0.0, 1.0)\n#define BACKWARD vec3(0.0, 0.0, -1.0)\n#define LEFT vec3(-1.0, 0.0, 0.0)\n#define RIGHT vec3(1.0, 0.0, 0.0)\n#define UP vec3(0.0, 1.0, 0.0)\n#define DOWN vec3(0.0, -1.0, 0.0)\n\n// MOUSE BUTTON INPUT\nbool IsNewClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y < 1.0;\n}\n\nbool IsPersistentClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y > 0.0;\n}\n\nbool IsNewRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y > 0.0;\n}\n\nbool IsPersistentRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y < 1.0;\n}\n\n// KEYBOARD INPUT\nbool ReadKey(sampler2D sampler, int key, bool toggle)\n{\n\treturn textureLod(sampler, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x > 0.0;\n}\n\n// MATRICES\nmat2x2 Rot2(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nmat3x3 Rot3(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n\t\tt * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n\t\tt * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n\t);\n}\n\nmat4 Rot4(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4\n    (\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n        0.0,                                0.0,                                0.0,                                1.0\n    );\n}\n\n// USEFUL MATH STUFF\nfloat AvgComponentLength(vec3 v)\n{\n    return (abs(v.x) + abs(v.y) + abs(v.z)) / 3.0;\n}\n\nfloat SmoothAdd(float a, float b, float smoothing)\n{\n    float h = clamp((b - a) / smoothing + 0.5, 0.0, 1.0);\n    float m = h * (1.0 - h) * smoothing;\n    return h * a + (1.0 - h) * b - m * 0.5;\n}\n\nfloat SmoothSubtract(float a, float b, float smoothing)\n{\n    return SmoothAdd(a, -b, -smoothing);\n}\n\nfloat nsin(float value)\n{\n    return sin(value) * 0.5 + 0.5;\n}\n\nfloat ncos(float value)\n{\n    return cos(value) * 0.5 + 0.5;\n}\n\nfloat sfract(float v)\n{\n    if (v >= 0.0)\n    {\n        return v - floor(v);\n    }\n    return -(v - ceil(v));\n}\n\nvec2 sfract(vec2 v)\n{\n    return vec2(sfract(v.x), sfract(v.y));\n}\n\nvec3 sfract(vec3 v)\n{\n    return vec3(sfract(v.xy), sfract(v.z));\n}\n\nfloat smod(float v, float x)\n{\n    return x == 0.0 ? v : sfract(v / x) * x;\n}\n\nvec2 smod(vec2 v, vec2 x)\n{\n    return vec2(smod(v.x, x.x), smod(v.y, x.y));\n}\n\nvec3 smod(vec3 v, vec3 x)\n{\n    return vec3(smod(v.xy, x.xy), smod(v.z, x.z));\n}\n\n// PRIMITIVES\nfloat Sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat Torus(vec3 p, float w, float r)\n{\n\treturn length(vec2(length(p.xz) - w, p.y)) - r;\n}\n\nfloat Disk(vec3 p, float w, float r)\n{\n\treturn length(vec2(length(p.xz) - w, p.y)) - r;\n}\n    \nfloat CappedTorus(in vec3 p, in float angle, in float ra, in float rb)\n{\n    vec2 c = vec2(sin(angle),cos(angle));\n    \n    p.x = abs(p.x);\n    float k = (c.y*p.x>c.x*p.y) ? dot(p.xy,c) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat Capsule(vec3 p, float len, float rad)\n{\n\tvec3 a = vec3(len * 0.5, 0.0, 0.0);\n\tvec3 b = vec3(-len * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - rad;\n}\n\nfloat Cylinder(vec3 p, float l, float r)\n{\n\tvec3 a = vec3(l * 0.5, 0.0, 0.0);\n\tvec3 b = vec3(-l * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0));\n\tfloat i = min(max(x, y), 0.0);\n\n\treturn e + i;\n}\n\nfloat Gyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    p *= repetition;\n    float avgRepetition = AvgComponentLength(repetition);\n    return abs(dot(sin(p * bias.x), cos(p.zxy * bias.y))) / avgRepetition - width;\n}\n\nfloat Box(vec3 p, vec3 dimensions)\n{\n\treturn length(max(abs(p) - (0.5 * dimensions), 0.0));\n}\n\nfloat BoxFrame(vec3 p, vec3 b, float e)\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat Link(vec3 p, float le, float r1, float r2)\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le / 2.0,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat Plane(vec3 p)\n{\n    return abs(p.y);\n}\n\nfloat Cone(vec3 p, vec2 c, float h)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////\n// INPUT SHADER //\n//////////////////\n\n//\n#define INIT_CAM_POS vec3(1.75, 0.75, -2.5)\n#define INIT_CAM_YAW .58\n#define INIT_CAM_PITCH (-PI / 10.0)\n#define INIT_CAM_ROLL 0.0\n\n// SPEEDS\n#define ROTATION_SPEED 4.0\n#define BASE_MOVE_SPEED 2.0\n\n// INPUT KEYS\n#define KEY_SHIFT 16\n#define KEY_CONTROL 17\n#define KEY_SPACE 32\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n\n// UPDATE AND RECORD INPUT\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if (int(fragCoord.y) == 0 )\n    {\n        if (int(fragCoord.x) <= 1)\n        {\n            // CAMERA CONTROLS\n            vec4 camPos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy, -100.0);\n            vec4 camRot = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0).xy;\n            \n            float yawAngle = camRot.x - ROTATION_SPEED * mousePosData.x / iResolution.x;\n            float pitchAngle = clamp(camRot.y + ROTATION_SPEED * mousePosData.y / iResolution.y, -PI / 2.0, PI / 2.0);\n            float rollAngle = camRot.z;\n\n            if (ReadKey(iChannel1, KEY_Q, false))\n            {\n                rollAngle -= ROTATION_SPEED * iTimeDelta;\n            }\n\n            if (ReadKey(iChannel1, KEY_E, false))\n            {\n                rollAngle += ROTATION_SPEED * iTimeDelta;\n            }\n            \n            if (camRot.w == 0.0)\n            {\n                // ADD INIT ANGLES\n                yawAngle += INIT_CAM_YAW;\n                pitchAngle += INIT_CAM_PITCH;\n                rollAngle += INIT_CAM_ROLL;\n            }\n            \n            if (ReadKey(iChannel1, KEY_F, false))\n            {\n                rollAngle = 0.0;\n            }\n            \n            if (int(fragCoord.x) == 0)\n            {\n                // CAMERA POSITION\n                vec3 moveDir = vec3(0.0);\n                \n                mat3x3 yawMat = Rot3(yawAngle, UP);\n                mat3x3 pitchMat = Rot3(pitchAngle, RIGHT);\n                mat3x3 rollMat = Rot3(rollAngle, FORWARD);\n                mat3x3 rotMat = yawMat * pitchMat * rollMat;\n                \n                float moveSpeed = camPos.w;\n                \n                if (camRot.w == 0.0)\n                {\n                    // SET INIT MOVE SPEED\n                    moveSpeed = BASE_MOVE_SPEED;\n                }\n                \n                for (int i = KEY_1; i <= KEY_9; i++)\n                {\n                    if (ReadKey(iChannel1, i, false))\n                    {\n                        moveSpeed = float(i - KEY_0) * BASE_MOVE_SPEED;\n                        break;\n                    }\n                }\n\n                if (ReadKey(iChannel1, KEY_W, false))\n                {\n                    moveDir += rotMat * FORWARD;\n                }\n                if (ReadKey(iChannel1, KEY_S, false))\n                {\n                    moveDir += rotMat * BACKWARD;;\n                }\n                if (ReadKey(iChannel1, KEY_A, false))\n                {\n                    moveDir += rotMat * LEFT;\n                }\n                if (ReadKey(iChannel1, KEY_D, false))\n                {\n                    moveDir += rotMat * RIGHT;\n                }\n                if (ReadKey(iChannel1, KEY_SPACE, false))\n                {\n                    moveDir += rotMat * UP;\n                }\n                if (ReadKey(iChannel1, KEY_SHIFT, false))\n                {\n                    moveDir += rotMat * DOWN;\n                }            \n\n                vec3 movement = vec3(0.0);\n                if (length(moveDir) > 0.0)\n                {\n                    movement = normalize(moveDir) * iTimeDelta * moveSpeed;\n                }\n\n                if (camRot.w == 0.0)\n                {\n                    // ADD INIT POSITION\n                    movement += INIT_CAM_POS;\n                }\n                \n                fragColor = vec4(camPos.xyz + movement, moveSpeed);\n            }\n            else\n            {                \n                // CAMERA ROTATION\n                fragColor = vec4(yawAngle, pitchAngle, rollAngle, 1.0); // w value 1.0 means no longer first frame\n            }\n        }\n        else if (int(fragCoord.x) == 2)\n        {\n            // MOUSE CLICK\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);            \n            fragColor = vec4(iMouse.z, mouseClickData.x, IsNewClick(mouseClickData.xy) || IsPersistentClick(mouseClickData.xy) ? iMouse.xy : vec2(0.0));\n        }\n        else if (int(fragCoord.x) == 3)\n        {\n            // MOUSE MOVEMENT\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);\n            vec4 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mouseDelta = IsPersistentClick(mouseClickData.zw) ? iMouse.xy - mouseClickData.zw : vec2(0.0);\n            vec2 mouseCumulative = mousePosData.zw + mouseDelta;\n            fragColor = vec4(mouseDelta, mouseCumulative);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}