{"ver":"0.1","info":{"id":"XcG3RG","date":"1712872172","viewed":57,"name":"3d math group ","username":"Vladdosattack","description":"varaksin ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["vladislav"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int n=10;\nvec3 colAr[n] = vec3[n](vec3(0.0, 0.0 , 1.0),vec3(.0, .5, 0.0),vec3(0., 5.0, 0.0), vec3(0.0, 0.5, 0.0), vec3(0.0, .2, .0), vec3(.0, .8, 0.0), vec3(0.52,0.52,0.52), vec3(0.0, 1.0 , 1.0), vec3(0.0, 0.0 , 1.0),vec3(1.0, .5, 0.0));\nvec3 BackColor = vec3(1.0,1.0, 1.);\n\n\n\nint inds[n + 1] = int[n + 1](0, 4, 8, 12, 16, 20, 24, 28, 31, 36, 39);\n\nconst int m = 39;\nvec3 polygons[m], normal;\n\nvoid initPolygons(out vec3 polygons[m], in float time)\n{\n    // низ  куба\n    polygons[0] = vec3(0.2 + 0.2 * cos(time), 0.2 + 0.152 * sin(time), 0.0);//a\n    polygons[1] = vec3(0.0 + 0.2 * cos(time), 0.0 + 0.152 * sin(time), 0.6);//b\n    polygons[2] = vec3(0.5 + 0.2 * cos(time), 0.0 + 0.152 * sin(time), 0.6);//c\n    polygons[3] = vec3(0.7 + 0.2 * cos(time), 0.2 + 0.152 * sin(time), 0.0);//d\n    \n    // правая сторона куба\n    polygons[4] = vec3(0.5 + 0.2 * cos(time), 0.0 + 0.152 * sin(time), 0.6);//c\n    polygons[5] = vec3(0.7 + 0.2 * cos(time), 0.2 + 0.152 * sin(time), 0.0);//d\n    polygons[6] = vec3(.8 + 0.2 * cos(time), 0.6 + 0.152 * sin(time), 0.0);//e\n    polygons[7] = vec3(0.6 + 0.2 * cos(time), 0.4 + 0.152 * sin(time), 0.6);//f\n  \n    //задняя сторона куба\n    polygons[8] = vec3(0.2 + 0.2 * cos(time), 0.2 + 0.152 * sin(time), 0.0);//a\n    polygons[9] = vec3(0.7 + 0.2 * cos(time), 0.2 + 0.152 * sin(time), 0.0);//d\n    polygons[10] = vec3(.8 + 0.2 * cos(time), 0.6 + 0.152 * sin(time), 0.0);//e\n    polygons[11] = vec3(0.3 + 0.2 * cos(time), 0.6 +  0.152 * sin(time), 0.0);//h\n    \n    //левая боковая сторона  куба\n    polygons[12] = vec3(0.2 + 0.2 * cos(time), 0.2 + 0.152 * sin(time), 0.0);//a\n    polygons[13] = vec3(0.0 + 0.2 * cos(time), 0.0 + 0.152 * sin(time), 0.6);//b\n    polygons[14] = vec3(0.1 + 0.2 * cos(time), 0.4 + 0.152 * sin(time), 0.6);//g\n    polygons[15] = vec3(0.3 + 0.2 * cos(time), 0.6 +  0.152 * sin(time), 0.0);//h\n    \n    //лицевая сторона  куба\n    polygons[16] = vec3(0.0 + 0.2 * cos(time), 0.0 + 0.152 * sin(time), 0.6);//b\n    polygons[17] = vec3(0.5 + 0.2 * cos(time), 0.0 + 0.152 * sin(time), 0.6);//c\n    polygons[18] = vec3(0.6  + 0.2 * cos(time), 0.4 + 0.152 * sin(time), 0.6);//f\n    polygons[19] = vec3(0.1 + 0.2 * cos(time), 0.4 + 0.152 * sin(time), 0.6);//g\n    \n    //верхняя сторона  куба\n    polygons[20] = vec3(0.1 + 0.2 * cos(time), 0.4 + 0.152 * sin(time), 0.6);//g\n    polygons[21] = vec3(0.6 + 0.2 * cos(time), 0.4 + 0.152 * sin(time), 0.6);//f\n    polygons[22] = vec3(.8 + 0.2 * cos(time), 0.6 + 0.152 * sin(time), 0.0);//e\n    polygons[23] = vec3(0.3 + 0.2 * cos(time), 0.6 +  0.152 * sin(time), 0.0);//h\n    \n    // квадрат секущий\n    polygons[24] = vec3(0.2 - 0.2 * cos(time), 0.4 + 0.2 * sin(time), 0.0- 0.9 * sin(time));//a\n    polygons[25] = vec3(0.0 - 0.2 * cos(time), 0.2 + 0.2 * sin(time), 0.6- 0.9 * sin(time));//b\n    polygons[26] = vec3(0.7 - 0.2 * cos(time), 0.2 + 0.2 * sin(time), 0.6- 0.9 * sin(time));//c\n    polygons[27] = vec3(0.9 - 0.2 * cos(time), 0.4 + 0.2 * sin(time), 0.0- 0.9 * sin(time));//d\n    \n    polygons[28] = vec3(0.3 + 0.1 * sin(5.0 * time), 0.37 - 0.1 * sin(5.0 * time), 0.35);//b\n    polygons[29] = vec3(0.4 + 0.1 * sin(5.0*time), 0.5 -  0.1 * sin(5.0*time), 0.05);//s\n    polygons[30] = vec3(0.2 + 0.1 * sin(5.0*time), 0.6 - 0.1 * sin(5.0*time), 0.15);//c\n    \n    polygons[31] = vec3(0. - 0.24 * sin(time), 0.1 + 0.24 * sin(time), 0.2+ 0.24 * sin(time));//b\n    polygons[32] = vec3(0.3 - 0.24 * sin(time), 0. +  0.24 * sin(time), 0.2+ 0.24 * sin(time));//s\n    polygons[33] = vec3(0.4 - 0.24 * sin(time), 0.2 + 0.24 * sin(time), 0.2+ 0.24 * sin(time));//c\n    polygons[34] = vec3(0.2 - 0.24 * sin(time), 0.4 + 0.24 * sin(time), 0.2+ 0.24 * sin(time));//c\n    polygons[35] = vec3(0.1 - 0.24 * sin(time), 0.3 + 0.24 * sin(time), 0.2+ 0.24 * sin(time));//c\n    \n    polygons[36] = vec3(0.3 + 0.1 * cos(5.0 * time), 0.37 - 0.1 * sin(5.0 * time), 0.35);//b\n    polygons[37] = vec3(0.4 + 0.1 * cos(5.0*time), 0.5 -  0.1 * sin(5.0*time), 0.05);//s\n    polygons[38] = vec3(0.2 + 0.1 * cos(5.0*time), 0.6 - 0.1 * sin(5.0*time), 0.15);//c\n    \n}\n\nbool inPolygon( in vec2 vector, in int num)\n{  \n    int size = inds[num + 1] - inds[num], start = inds[num], i;\n    vec2 a;\n    vec2 b;\n    // смотрим на знак 3-й координаты векторного произведения для всех сторон, кроме последней, так как у нее будет другая формула\n    for(i = start; i < size + start - 1; i++)\n    {\n        a = vec2(polygons[i + 1].x - polygons[i].x, polygons[i + 1].y - polygons[i].y);\n        b = vec2(vector.x - polygons[i].x, vector.y - polygons[i].y);\n        if ( a.x * b.y - b.x * a.y  < 0.0) \n            { return false; }\n    }\n   //смотрим на знак векторного произведения последней стороны\n   a = vec2(polygons[start].x - polygons[i].x, polygons[start].y - polygons[i].y);\n   b = vec2(vector.x - polygons[i].x, vector.y - polygons[i].y);\n   if ( a.x * b.y - b.x * a.y  < 0.0) \n            { return false; }\n   \n   return true;   \n}\nfloat get_z(int i, vec3 polygons[m], float x, float y)\n{\n         float z, D, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;\n         x1 = polygons[inds[i]].x;\n         x2 = polygons[inds[i] + 1].x;\n         x3 = polygons[inds[i] + 2].x;\n         x4 = polygons[inds[i] + 3].x;\n         y1 = polygons[inds[i]].y;\n         y2 = polygons[inds[i] + 1].y;\n         y3 = polygons[inds[i] + 2].y;\n         y4 = polygons[inds[i] + 3].y;\n         z1 = polygons[inds[i]].z;\n         z2 = polygons[inds[i] + 1].z;\n         z3 = polygons[inds[i] + 2].z;\n         z4 = polygons[inds[i] + 3].z;\n         \n         normal = cross(vec3(x2-x1, y2-y1, z2-z1), vec3(x4-x1,y4-y1,z4-z1)); \n         D = -normal.x * x1 - normal.y * y1 - normal.z * z1;\n         z = (-normal.x * x - normal.y * y - D)/ normal.z; \n         return z;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     vec2 uv = fragCoord/iResolution.xy-0.2; // нормализация координат, деление покомпонентное!\n     initPolygons(polygons, iTime);\n     vec3 col = BackColor;\n     float maxZ = -100.0, x = uv.x, y = uv.y, z = maxZ;\n\n     for(int i = 0; i < n; i++)\n     \n     {// расчет цвета col, через поиск фигур, которые накрывают точку uv и выбор ближайшей из них\n         if (inPolygon(uv, i))\n         {\n             z = get_z(i, polygons, x, y);\n             if (z >= maxZ)\n             {\n                 col = colAr[i];\n                 maxZ = z;\n             }\n          }\n     }\n     fragColor = vec4(col, 1.0); // вывод ответа\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}