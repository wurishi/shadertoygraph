{"ver":"0.1","info":{"id":"tslyRf","date":"1585539026","viewed":344,"name":"Infinite Supernova","username":"sevanetrebchenko","description":"This is my thought process with understanding and implementing Fractal Brownian Motion! ","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["fbm","space","supernova"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Original idea published by kubiak - this shader is my rendition. Thank you!\n * https://www.shadertoy.com/view/Wsy3zm <------ Original shader\n */\n\n// Readability\n#define globalTime iTime * 0.4\n#define viewportResolution iResolution\n\n/*************************************************************************************************************\n * Returns a rotation matrix that rotates an object by 'angle' degrees counter-clockwise.                    *                                                                                                  \n*************************************************************************************************************/\nmat2 Rotate2D(float angle) {\n  return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\n/*************************************************************************************************************\n * Returns the color value at 'position' coordinate in the provided texture.\t\t\t                     *                                                                                                  \n*************************************************************************************************************/\nfloat TextureCoordinate(vec2 position) {\n   /*\n\t* By how much to zoom the texture in. A higher zooming factor will give way to more of the detail of the \n\t* texture being lost, and will ultimately give way to a smoother, less rippled surface. If using a highly\n\t* detailed texture (with lots of changes in texture colors on a very small scale, i.e. noisy textures), \n\t* decreasing the zoom factor will cause more bright spots to be visible.\n\t*/\n    float zoomingFactor = 180.0;\n    \n    /*\n\t* The last parameter to texture is the LOD (level of detail), which dictates which mipmap texture level \n\t* to use for the texture coordinate sampling. A higher LOD results in a lower quality texture. In this \n\t* case, the maximum quality texture is used.\n\t*/\n    float levelOfDetail = 0.0;\n    \n   \t// Get the texture coordinates from the provided channel at the given zoom factor set above. \n    return texture(iChannel0, position / zoomingFactor, 0.0).x;\n}\n\n/*************************************************************************************************************\n * Fractal Brownian Motion (fbm) function\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *\n * Resources used:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *\n *\t- https://thebookofshaders.com/13/\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *\n *\t- https://iquilezles.org/articles/fbm\t\t\t\t\t\t\t\t\t\t\t\t\t *\n *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *\n *\tFunction aims to mimic fractal noise by increasing the frequencies of textures within a given space and  *\n *\tdecreasing the brightness and subsequent impact of each sub-texture on the overall color of the pixel.   *\n *\tSumming up the contributions of the several scaled textures gives the appearance of randomness and noise.*\n*************************************************************************************************************/\nfloat FBM(vec2 uv) {\n    // Represents the number of levels sub-textures present in each texture (fractal power)\n    #define fractalDimension 5\n    \n   /*\n\t* Represents the number of sub-textures present one one edge of the texture at the next fractal power. \n\t* If you look at one instance of the texture, there will be (innerPower ^ 2) sub-textures contained \n\t* within.  \n\t*\n\t* This effect is easier to see by decreasing zoomingFactor (in textureCoordinate function above) to 1.0, \n\t* the fractalDimension (above) to 2, and using a more recognizable texture (iChannel1) to see the effect \n\t* that changing this number has.\n\t*/\t\n    float innerPower = 2.0;\n    \n    float noiseValue = 0.0;     // Final noise to return at this pixel\n    float brightness = 2.0;      // Starting brightness of the first fractal power. \n                                 // Subsequent powers will have lower brightness contributions.\n    float dampeningFactor = 2.0; // How much of an impact subsequent fractal powers have on the result\n    \n   /*\n    * This value influences what range of colors become brighter than others. This color range is only \n    * valid between 0.0 and 1.0. At 0.0, colors in the original texture are inversed - those that are closest\n    * to white show up black (inverse). At 1.0, colors stay the same. \n    *\n    * Having a color offset within [0.0, 1.0] shifts the range of colors' darkness that become bright white \n    * spots in the output.\n    */\n    float offset = 0.5;\n    \n   /*\n\t* This changes how clear the difference between two opposite brightness pixels are. The higher this \n\t* number is, the clearer the difference is.\n\t*/\n    float difference = 2.0;\n \n\tfor (int i = 0; i < fractalDimension; ++i) {\n        \n       /*\n\t\t* At this stage we get the color at the texture coordinate and apply the color manipulation that was\n\t\t* specified above. \n\t\t*\n\t\t* Note that the absolute value of the fbm function is used. This is to create a turbulent effect by\n\t\t* creating sharp changes in the resulting noise where it would otherwise have little effect.\n\t\t*/\n\t\tnoiseValue += abs((TextureCoordinate(uv) - offset) * difference) / brightness;\n        \n       /* \n\t\t* Wave amplitude increases so that fractals at a higher power (smaller textures) have a lesser \n        * impact on the resulting noise at the provided uv coordinate.\n\t\t*/\n\t\tbrightness *= dampeningFactor;\n        \n        // Go one fractal power deeper\n\t\tuv *= innerPower;\n\t}\n    \n\treturn noiseValue;\n}\n\n/*************************************************************************************************************\n * Generates noise at the provided UV coordinates by overlapping multiple copies of the same texture.        *                                                                                                  \n*************************************************************************************************************/\nfloat Turbulence(vec2 uv) {\n    float activityLevel = 3.0; // How fast the tendrils of electricity move around\n    \n   /*\n\t* A basis is created with two calls to turbulence with texture offsets. These two values move the \n\t* texture in perpendicular directions and added to the original UV coordinates to create the illusion \n\t* of movement. The values are added to create more randomness in the generated noise. \n\t*\n\t* The first basis shifts the textures along each diagonal.\n\t* The second basis shifts the textures along the x axis.\n\t* The third basis shifts the textures along the y axis.\n\t*/\n\tvec2 noiseBasisDiag = vec2(FBM(uv - globalTime * activityLevel), FBM(uv + globalTime * activityLevel));\n    // vec2 noiseBasisX = vec2(FBM(vec2(uv.x - globalTime * activityLevel, 0.0)), \n    //\t\t\t\t\t\t   FBM(vec2(uv.x + globalTime * activityLevel, 0.0)));\n    // vec2 noiseBasisY = vec2(FBM(vec2(0.0, uv.y - globalTime * activityLevel)), \n    //\t\t\t\t\t\t   FBM(vec2(0.0, uv.y + globalTime * activityLevel)));\n    \n    // The resulting vector is offset randomly by the calculated turbulence bases\n    uv += noiseBasisDiag;\n\t// uv -= noiseBasisX;\n    // uv += noiseBasisY;\n    \n\t// Final call to turbulence rotates the entire screen, though this effect is most visible towards the edge\n\tfloat rotationSpeed = 2.0;\n    return FBM(uv * Rotate2D(globalTime * rotationSpeed));\n}\n\n/*************************************************************************************************************\n * The goal of this function was to create a circle without using sin/cos waves to                           *                                                                                           \n*************************************************************************************************************/\nfloat Ring(vec2 uv) {\n\tfloat circleRadius = sqrt(length(uv));\n    \n   /*\n\t* Note: this is easier to visualize if the function is graphed. \n\t* Function: y = abs(mod(x, 2.4) - 2.4 / 2) * 7.0 + 0.2\n\t*\n\t* It is easy to approximate this function with a simple cosine/sine wave, such as the one below:\n\t* \ty = 4.3 * cos(2.625 * x) + 4.3\n\t* However, as these functions reach their peaks, the resulting values will result in the peak white \n\t* lasting for longer than desired and giving a thicker ring. A linear up and down gives more flexibility.\n\t* \n\t* - Range:\n\t* \t\tThe range specifies the distance between circles. A higher range moves the circle further away\n\t* \t\tfrom the center.\n\t* - Function Slope:\n\t* \t\tThe function slope specifies how quickly the peak (white) color is reached and how quickly it \n\t* \t\tfalls back to normal. The higher the slope, the quicker it will be reached, and the thinner the\n\t* \t\twhite portion of the circle will be\n\t* - Offset:\n\t* \t\tOffsets the function up, reducing how much of the function can be visible in the peak color. \n\t* \t\tThe higher this number is, the thinner the ring of the circle will be.\n\t*/\n    \n\tfloat range = 2.3;\n    float functionSlope = 15.0; \n    float offset = 0.5;\n    \n\treturn abs(mod(circleRadius, range) - range / 2.) * functionSlope + offset;\n}\n\n/*************************************************************************************************************\n * SHADER MAIN                                                                                               *\n*************************************************************************************************************/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   /*\n    * Get the pixel UV coordinates in a range from [0 to 1] on both x and y, center (0, 0) at the center of \n    * the display, and normalize UV coordinates to cover the entire range of the native display resolution.\n    */\n    vec2 uv = vec2(fragCoord / viewportResolution.xy) - 0.5;\n    uv /= vec2(viewportResolution.y / viewportResolution.x, 1.0);\n    \n    float distanceFromCenter = length(uv); // Distance away from the center the normalized uv coordinate is \n    float radius = 0.4;\t\t\t\t\t   // Maximum radius of the effect\n    float alpha = 1.0;\t\t\t\t\t   // Alpha starting value (full brightness)\n    float alphaFalloffSpeed = 0.08;\t\t   // How quickly alpha values fade to 0.0\n    \n   /*\n\t* If the distance of the UV coordinate is further than the desired radius, decrease the alpha to \n\t* fade the effect out to black along the edges.\n\t*/\n    if(distanceFromCenter > radius) {\n        alpha = max(0.0, 1.0 - (distanceFromCenter - radius) / alphaFalloffSpeed);\n    }\n    \n    // If the alpha at the current uv coordinate is 0.0, discard it and draw nothing.\n    if (alpha == 0.0) {\n        discard;\n    }\n    \n   /*\n\t* UV Coordinates are zoomed out so that more textures can be visible at one time (since textures are\n\t* wrapped by repetition). This slows down the speed of the turbulence and gives more precise control\n\t* over the effect.\n\t*/\n    float zoom = 4.0;\n\tvec2 uvZoomed = uv * zoom;\n    \n    // Get the cumulative contributions of the fractal at this uv coordinate.\n\tfloat fractalColor = Turbulence(uvZoomed);\n    \n    // Scale the color of the current uv coordinate based on the distance it is away from the ring.\n\tfractalColor *= Ring(uvZoomed);\n\t\n    // The closer the coordinate is to the ring, the brighter the color will be (fractalColor approaches 0).\n\tvec3 col = normalize(vec3(0.721,0.311,0.165)) / fractalColor;\n    col *= alpha;\n    \n    // FINAL COLOR\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}