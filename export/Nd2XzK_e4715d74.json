{"ver":"0.1","info":{"id":"Nd2XzK","date":"1621258632","viewed":391,"name":"Migration","username":"skaplun","description":"Original animation - https://twitter.com/owendeery/status/1390031346115006464\nEdge detection  was taken here: https://www.shadertoy.com/view/ldsSWr","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","sdf","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// just a edges here\n\n#define STEP .1\n\nconst mat3 scharrKernelX = mat3( 3.0,  10.0,  3.0,\n\t\t\t\t\t\t\t\t 0.0,   0.0,  0.0,\n\t\t\t\t\t\t\t\t-3.0, -10.0, -3.0);\n\nconst mat3 scharrKernelY = mat3(3.0, 0.0, -3.0,\n\t\t\t\t\t\t\t\t10.0, 0.0, -10.0,\n\t\t\t\t\t\t\t\t3.0, 0.0, -3.0);\n\nfloat convolve(mat3 kernel, mat3 image) {\n\tfloat result = 0.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tresult += kernel[i][j]*image[i][j];\n\t\t}\n\t}\n\treturn result;\n}\n\nfloat edge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY){\n\tmat3 image = mat3(length(texture(iChannel0,center + vec2(-stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,-stepy)).rgb));\n \tvec2 result;\n\tresult.x = convolve(kernelX, image);\n\tresult.y = convolve(kernelY, image);\n\t\n    return smoothstep(.05, .075, length(result)) * .33;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv.xy);\n    fragColor = color;\n\tfragColor = mix(fragColor, vec4(0.), edge(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tscharrKernelX, scharrKernelY));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPS 1e-4\n#define PHI  1.618034     // root of x^2 = x+1, golden ratio \n#define PHI2 1.324717957  // root of x^3 = x+1, generalization of golden ratio\n#define hash2(X)  fract( dot( X, 1./ vec2( PHI2, PHI2*PHI2 ) ) )\n\nstruct Ray{vec3 origin, direction;};\nstruct Sphere{vec3 origin; float rad;};\nstruct Bird{Sphere boundingSphere; float id;};\n\n// some globals\nfloat TIME;\nconst vec3 ORANGE = vec3(1.,.6,.3);\nconst vec3 BLUE = vec3(.4,.9,1.);\nconst int BIRDS_COUNT = 14;\nBird birds[BIRDS_COUNT] = Bird[BIRDS_COUNT](\n    Bird(Sphere(vec3( 0., 1., 6.), 3.), 3.),\n    Bird(Sphere(vec3( 3., -2., 0.), 2.), 2.),\n    Bird(Sphere(vec3(23., 4., 3.), 2.), 1.),\n    Bird(Sphere(vec3(-6., 2., -2.), 2.), 11.),\n    Bird(Sphere(vec3( -8., .5, 5.), 3.), 18.),\n    Bird(Sphere(vec3( 3., -3., 4.), 2.), 26.),\n    Bird(Sphere(vec3(-3., 1., 6.), 2.), 33.),\n    Bird(Sphere(vec3(-6., 0., 8.), 2.), 35.),\n\n    Bird(Sphere(vec3( -22.5, 1., 6.), 2.), 42.),\n    Bird(Sphere(vec3( -26.5, -2., 0.), 2.), 57.),\n    Bird(Sphere(vec3( -22., 4., 3.), 2.), 62.),\n    Bird(Sphere(vec3( -20., 2., -2.), 2.), 67.),\n    Bird(Sphere(vec3( 24., .5, 5.), 3.), 73.),\n    Bird(Sphere(vec3( -21.5, -3., 4.), 2.), 81.)\n);\n\nvec3 caches[BIRDS_COUNT];\nvec3 caches2[BIRDS_COUNT];\nvec2 cashes3[BIRDS_COUNT];\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.direction, inray.direction);\n    float b = dot(oc, inray.direction);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    return discriminant > 0.;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n//by iq\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n  return dot(p,n) + h;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n\nvec2 min2(vec2 a, vec2 b){\n    return (a.x <= b.x) ? a : b;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 bg(vec2 guv){\n    vec3 res = mix(ORANGE, BLUE, pow(guv.y, 1. + noised(vec2(guv.x * 2., iTime)).x));\n    \n    for(float i=-1.; i<2.; i++){\n        float amp = 3. + i * .5;\n        float hoff = iTime * (7. + abs(i) * 3.);\n        \n        float a = i * .25;\n        vec2 scale = vec2(3. + 2. * abs(i), 100. + 100. * abs(i));\n        vec2 uv = (guv * mat2(cos(a), -sin(a), sin(a), cos(a)))\n                * scale;\n        uv += vec2(hoff, sin(uv.x * amp - hoff) * amp);\n        \n        float h = hash2(floor(uv));\n        float c = hash2(floor(uv) * (121.3 + i * 32.));\n        \n        float mixVal = step(distance(.5, h), .0025);\n        mixVal *= step(1. - guv.x, min(TIME - .75, 1.) * 2.)\n                * step(min(TIME - 3., 1.) * 2., 1. - guv.x);\n        \n        res = mix(res, mix(ORANGE * (.9 + i*.1), BLUE * (.9 + i*.1), c), mixVal);\n    }\n    return res;\n}\n\nfloat bird(const in Bird bird, vec3 p, float angV, float angH, float speed){\n    {\n        vec3 pos = p - bird.boundingSphere.origin;\n        pos.xy *= mat2(cos(angV), -sin(angV), sin(angV), cos(angV));\n        pos.yz *= mat2(cos(angH * 2.), -sin(angH * 2.), sin(angH * 2.), cos(angH * 2.));\n        pos.xz *= mat2(cos(angH), -sin(angH), sin(angH), cos(angH));\n    \n        pos = vec3(pos.xy, abs(pos.z));\n        float res = length(pos) - bird.boundingSphere.rad;\n        float rad = bird.boundingSphere.rad;\n        \n        res = max(res, sdPlane(pos, normalize(vec3(0., 1., .5)), -rad * .125));\n        res = max(res, sdPlane(pos, normalize(vec3(0., -1., 1.)), -rad * .125));\n        res = max(res, sdPlane(pos - vec3(rad * .5, 0., 0.), normalize(vec3(1., 1., 1.5)), -rad * .15));\n        res = max(res, sdPlane(pos + vec3(rad * .5, 0., 0.), normalize(vec3(-.5, -1.5, 1.5)), 0.));\n        \n        { // wings\n            vec3 wpos = pos;\n            wpos.z -= rad * .2;\n            float a = sin(TIME * .75 * speed) * .5;\n            wpos.yz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            wpos.z += rad * .2;\n            \n            float wing = sdPlane(wpos, normalize(vec3(0., 1., 0.)), -rad * .035);\n            wing = max(wing, sdPlane(wpos, normalize(vec3(0., -1., 0.)), rad * .01));\n            wing = max(wing, sdPlane(wpos, normalize(vec3(-1., 0., -.5)), rad * .05));\n            wing = max(wing, sdPlane(pos, normalize(vec3(1., 0., 1.25)), -rad * .44));\n            wing = max(wing, sdPlane(pos, normalize(vec3(0., 0., -1.)), rad * .2));\n            res = min(wing, res);\n        }\n        \n        return res;\n    }\n}\n\nvec2 world(vec3 pos, const in Ray ray){\n    vec2 res = vec2(MAX_FLOAT);\n    for(int i=min(iFrame,0); i<BIRDS_COUNT; i++){\n        vec3 noise = caches[i];\n        vec3 noise2 = caches2[i];\n        vec2 h = cashes3[i];\n\n        Bird curb = birds[i];\n\n        float vrange = h.y;\n        float hspeed = .5 + (.5 * smoothstep(-.25, .25, h.x) + pow(noise.y, 2.)*.1);\n        curb.boundingSphere.origin.x += TIME * hspeed * 100. - 150.;\n        curb.boundingSphere.origin.y += noise.x * 40. * vrange;\n        curb.boundingSphere.origin.z += noise2.x * 25.;\n        \n        if(sphere_hit(curb.boundingSphere, ray))\n            res = min2(res, vec2(bird(curb, pos, -noise.z * vrange * .4, -noise2.z * .4, noise.z * 5.), i));\n    }\n    return res;\n}\n\nconst int MAX_MARCHING_STEPS = 64;\nvec2 march(const in Ray ray, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = world(ray.origin + depth * ray.direction, ray);\n        if (dist.x < EPS)\n            return vec2(depth, dist.y);\n        depth += dist.x;\n        if (depth >= end)\n            break;\n    }\n    return vec2(-1.);\n}\n\nvec3 calculateNormals(vec3 pos, const in Ray ray){\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;\n    return normalize( e.xyy*world( pos + e.xyy, ray ).x + \n\t\t\t\t\t  e.yyx*world( pos + e.yyx, ray ).x + \n\t\t\t\t\t  e.yxy*world( pos + e.yxy, ray ).x + \n\t\t\t\t\t  e.xxx*world( pos + e.xxx, ray ).x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    TIME = mod(iTime, 5.);\n    for(int i=min(iFrame,0); i<BIRDS_COUNT; i++){\n        caches[i] = noised(vec2(birds[i].id, TIME));\n        caches2[i] = noised(vec2(birds[i].id + 47., TIME));\n        cashes3[i] = 1. - hash(vec2(birds[i].id, 21.));\n    }\n    \n    fragColor = vec4(bg(fragCoord.xy/iResolution.xy), 1.);\n    \n    vec3 lookAt = vec3(TIME * 100. - 150., 0., 0.);\n    vec3 eye = vec3(clamp(lookAt.x, 0., 100.), 0., 75.);\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, lookAt, vec3(0., 1., 0.)) * viewDir;\n\n    Ray r = Ray(eye, worldDir);\n    \n    vec2 hit = march(r, 0., 1000.);\n    if(hit.x >= 0.) {\n        vec3 nrm = calculateNormals(r.origin + r.direction * hit.x, r);\n        float d = dot(nrm, vec3(0., 1., 0.));\n        float v = (hit.y/float(BIRDS_COUNT) - .5);\n        fragColor.rgb = mix(vec3(.8), hsv2rgb(vec3(.55 + v * .05, .5 + v * .25, .6 + v * .25)), step(d, 0.));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}