{"ver":"0.1","info":{"id":"wlKfD3","date":"1615909219","viewed":119,"name":"Raymarching wave equation","username":"szkow","description":"can i render a solution to the wave equation in real time? tune in to find out\n\nTurns out I totally can, but there's tearing I don't quite know how to deal with.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\n// Solution to wave equation on [0,2] x [0,3]\nfloat wave_sol(float t, float x, float y)\n{\n    //return sin(x*y) + sin(t);\n\n    float term1 = 4.0 * cos(sqrt(13.0)*PI*t) * sin(PI * x / 2.0) * sin(PI * y / 3.0);\n    float term2 = 4.0/27.0*cos(sqrt(85.0)*PI*t)*sin(3.0*PI*x/2.0)*sin(PI*y/3.0);\n    float term3 = 4.0/27.0*cos(3.0*sqrt(5.0)*PI*t)*sin(PI*x/2.0)*sin(PI*y);\n    float term4 = 4.0/729.0*cos(3.0*sqrt(13.0)*PI*t)*sin(3.0*PI*x/2.0)*sin(PI*y);\n    float sum = 576.0 / PI/PI/PI/PI/PI/PI * (term1 + term2 + term3 + term4);\n    return sum;\n}\n\nvec2 grad_wave_sol(float t, float x, float y)\n{\n    //return vec2(x*cos(x*y), y*cos(x*y));\n    \n    float u_x = cos(PI*x/2.0)*(0.156662*sin(PI*y/3.0)-0.1333339*sin(PI*y)) + cos(3.0*PI*x/2.0)*(-0.300704*sin(PI*y/3.0) - 0.00192963*sin(PI*y));\n    float u_y = cos(PI*y/3.0)*(0.104441*sin(PI*x/2.0) - 0.0668231*sin(3.0*PI*x/2.0)) + cos(PI*y)*(-0.2666778*sin(PI*x/2.0)-0.00128642*sin(3.0*PI*x/2.0));\n    return vec2(u_x, u_y);\n}\n\n// SDF from pt to (x, y, u(t, x, y))\nconst float surf_thickness = 0.01;\nfloat euclideanDist(vec3 pt, float t, float x, float y)\n{\n    float u = wave_sol(t, x, y);\n    float dist = length(pt - vec3(x, y, u));\n    return dist;\n}\n\n// Does gradient descent on euclideanDist to find minimum distance estimate\nfloat sdf(float t, vec3 v)\n{\n    vec3 box = vec3(2,3,10);\n    vec3 q = abs(v - vec3(1,1.5,5)) - box;\n    float box_sdf = length(max(q,0.0)) + min(max(q.x, max(q.y,q.z)),0.0);\n    if (box_sdf > 0.0) return box_sdf + 0.1;\n    vec2 z = v.xy;\n    vec2 dz = vec2(1.0, 1.0);\n    \n    // Gradient descent\n    for (int i = 0; dot(dz, dz) > 1e-4; i++)\n    {\n        vec2 grad_dist = -2.0 * (v.xy - z) + 2.0 * grad_wave_sol(t, z.x, z.y) * (v.z - wave_sol(t, z.x, z.y));\n        dz = 0.01 * grad_dist;\n        z -= dz;\n    }\n    \n    // Now, z should be the point which minimized euclideanDist\n    return 0.25 * (euclideanDist(v, t, z.x, z.y) - surf_thickness);\n}\n\nstruct rayData\n{\n    bool hit;\n    vec3 endpoint;\n    int iter;\n};\n\nrayData rayMarch(vec3 start, vec3 ray, int n_iter)\n{\n    rayData dat;\n    \n    float last_dist = 9999999.0;\n    vec3 cur_pt = start;\n    for (int i = 0; i < n_iter; i++)\n    {\n        float dist = sdf(iTime / 10.0, cur_pt);\n        if (dist < 1e-4) // Early break if we converge\n        {\n            dat.hit = true;\n            dat.endpoint = cur_pt;\n            dat.iter = i;\n            return dat;            \n        }\n        \n        cur_pt += 0.99 * dist * ray;\n        last_dist = dist;\n    }\n    \n    dat.hit = false;\n    dat.endpoint = cur_pt;\n    dat.iter = n_iter;\n    \n    return dat;\n}\n\nconst float camera_radius = 10.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime / 5.0;\n    mat4 view_transform = mat4(cos(t), sin(t), 0, 0, -sin(t), cos(t), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); \n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    vec4 ray = view_transform * vec4(uv.x, 1, uv.y, 1);\n    vec4 start = view_transform * vec4(1, -10.0, 0.0, 1);\n    \n    rayData dat = rayMarch(start.xyz, normalize(ray.xyz), 250);\n    \n    vec3 hit_col = vec3(0, 0, 1) + (dat.endpoint.z + 3.5)/3.5 * vec3(1, 0, 0);\n    vec3 miss_col = vec3(1, 1, 1) * 0.3;\n    \n    hit_col = hit_col - vec3(0.01) * float(dat.iter);\n       \n    \n    \n    // Output to screen\n    fragColor = vec4(dat.hit ? hit_col : miss_col, 1);\n}\n","name":"Image","description":"","type":"image"}]}