{"ver":"0.1","info":{"id":"DlBGz1","date":"1672811349","viewed":60,"name":"Worley Rotation","username":"sofia_ma","description":"Worley noise with a constantly oscillating distance metric","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["worleynoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UINT_MAX 4294967295.0\n#define PI 3.1415926535\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nconst float F = 0.5*(sqrt(3.0) - 1.0);\nconst float G = 0.5*(1.0 - 1.0/sqrt(3.0));\n\nfloat interp(float lo, float hi, float t) {\n    return lo + (hi - lo)*t;\n}\n\nfloat perlin_noise(vec2 coords) {\n    // Find the simplex that the coordinates are located in\n    vec2 f = floor(coords);\n    ivec2 i = ivec2(f);\n    vec2 f_coords = fract(coords);\n\n    // Generate random 2D vectors for each corner of the cube\n    vec2 corner1 = vec2(pcg3d(uvec3(0, i.x, i.y)).xy) / UINT_MAX;\n    vec2 corner2 = vec2(pcg3d(uvec3(0, i.x + 1, i.y)).xy) / UINT_MAX;\n    vec2 corner3 = vec2(pcg3d(uvec3(0, i.x, i.y + 1)).xy) / UINT_MAX;\n    vec2 corner4 = vec2(pcg3d(uvec3(0, i.x + 1, i.y + 1)).xy) / UINT_MAX;\n\n    // Interpolate between the corner vectors using dot products\n    float t1 = dot(f_coords - vec2(0.0, 0.0), corner1);\n    float t2 = dot(f_coords - vec2(1.0, 0.0), corner2);\n    float t3 = dot(f_coords - vec2(0.0, 1.0), corner3);\n    float t4 = dot(f_coords - vec2(1.0, 1.0), corner4);\n\n    // Return the interpolated value\n    float ix1 = interp(t1, t2, f_coords.x);\n    float ix2 = interp(t3, t4, f_coords.x);\n    return interp(ix1, ix2, f_coords.y);\n}\n\n\nfloat angle_noise(vec2 x) {\n    return perlin_noise(x) * PI + PI;\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nstruct sworley_out {\n    uint hash;\n    vec2 center;\n    float distance;\n};\n\nfloat to_01(float f) {\n    return 0.5 + (f * f - 0.5) * 0.7;\n}\n\nsworley_out get_sworley(ivec2 cell, vec2 base, float angle) {\n    uvec3 hash = pcg3d(uvec3(cell.x, cell.y, 0));\n    vec2 center = vec2(cell) + vec2(float(hash.x) / UINT_MAX, float(hash.y) / UINT_MAX);\n    //float angle = angle_noise(base);\n    float distance = (0.0 + 1.0*to_01(cos(angle)))*(center.x - base.x)*(center.x - base.x)\n        + (0.0 + 1.0*to_01(sin(angle)))*(center.y - base.y)*(center.y - base.y);\n    return sworley_out(hash.z, center, distance);\n}\n\nsworley_out merge_sworley(sworley_out a, sworley_out b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nsworley_out sworley(vec2 coords, float angle) {\n    ivec2 base = ivec2(floor(coords));\n    sworley_out o = get_sworley(base, coords, angle);\n    o = merge_sworley(o, get_sworley(base + ivec2(-1, -1), coords, angle));\n    o = merge_sworley(o, get_sworley(base + ivec2(0, -1), coords, angle));\n    o = merge_sworley(o, get_sworley(base + ivec2(1, -1), coords, angle));\n    o = merge_sworley(o, get_sworley(base + ivec2(-1, 0), coords, angle));\n    o = merge_sworley(o, get_sworley(base + ivec2(1, 0), coords, angle));\n    o = merge_sworley(o, get_sworley(base + ivec2(-1, 1), coords, angle));\n    o = merge_sworley(o, get_sworley(base + ivec2(0, 1), coords, angle));\n    o = merge_sworley(o, get_sworley(base + ivec2(1, 1), coords, angle));\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    sworley_out cell = sworley(20.0 * uv * vec2(aspect, 1.0), iTime);\n    float color = (float(cell.hash) / UINT_MAX) * 2.0 * PI;\n\n    // Output to screen\n    fragColor = vec4(hsv2rgb(vec3(color, 1.0, float(true))), 1.0);\n}","name":"Image","description":"","type":"image"}]}