{"ver":"0.1","info":{"id":"tslfWH","date":"1588192737","viewed":160,"name":"Original--Mandelbox--mandelbulb","username":"jorge2017a1","description":"Original--Mandelbox--mandelbulb","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["originalmandelboxmandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightdir = normalize(vec3(-1., 1, -0.5));\n\nconst float detail = .00002;\nfloat det = 0.;\n\nfloat de2(vec3 p) {\n    vec3 op = p;\n    p = abs(1.0 - mod(p, 2.));\n    float r = 0., power = 8., dr = 1.;\n    vec3 z = p;\n    \n    for (int i = 0; i < 7; i++) {\n        op = -1.0 + 2.0 * fract(0.5 * op + 0.5);\n        float r2 = dot(op, op);\n        r = length(z);\n\n\n        if (r > 1.616) break;\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return (.5 * log(r) * r / dr);\n}\n\nfloat de1(vec3 p) {\n    float s = 1.;\n    float d = 0.;\n    vec3 r,q;\n        r = p;\n      q = r;\n    \n    for (int j = 0; j < 6; j++) {\n\t   \n        r = abs(mod(q * s + 1.5, 2.) - 1.);\t\n        r = max(r, r.yzx);\n        //r = max(r = abs(mod(q * s + 1., 2.) - 1.), r.yzx);\n\t    \n        d = max(d, (.3 - length(r *0.985) * .3) / s);\n\t    \n\ts *= 2.1;\n    }\n    return d;\n}\n\n\nfloat map(vec3 p) {\n    return min(de1(p), de2(p));;\n}\n\nvec3 normal( in vec3 p) {\n    //vec2 e = vec2(0.005, -0.005);\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat shadow( in vec3 ro, in vec3 rd){\n\tfloat res = .0;\n    \tfloat t = 0.05;\n\tfloat h;\t\n    \tfor (int i = 0; i < 4; i++)\n\t{\n\t\th = map( ro + rd*t );\n\t\tres = min(6.0*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\nfloat calcAO(const vec3 pos,const vec3 nor) {\n    float aodet = detail * 80.;\n    float totao = 0.0;\n    float sca = 10.0;\n    \n    for (int aoi = 0; aoi < 5; aoi++) {\n        float hr = aodet + aodet * float(aoi * aoi);\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos);\n        totao += -(dd - hr) * sca;\n        sca *= 0.75;\n    }\n    //return clamp(1.0 - 5.0 * totao, 0.0, 1.0);\n    return clamp(1.0 - 4.0 * totao, 0.0, 1.0);\n}\n\n\nfloat kset(vec3 p) {\n\t    p = abs(.5 - fract(p * 80.));\n    float es, l = es = 0.;\n    for (int i = 0; i < 13; i++) {\n        float pl = l;\n        l = length(p);\n        p = abs(p) / dot(p, p) - .5;\n        es += exp(-1. / abs(l - pl));\n    }\n    return es;\n}\n\nvec3 light( in vec3 p, in vec3 dir) {\n\n    vec3 n = normal(p);\n    float sh = min(5., shadow(p, lightdir));\n\n    float ao = calcAO(p, n);\n\n    float diff = max(0., dot(lightdir, -n)) * sh * 1.3;\n    float amb = max(0.2, dot(dir, -n)) * .4;\n    vec3 r = reflect(lightdir, n);\n    float spec = pow(max(0., dot(dir, -r)) * sh, 10.) * (.5 + ao * .5);\n    float k = kset(p) * .18;\n    vec3 col = mix(vec3(k * 1.1, k * k * 1.3, k * k * k), vec3(k), .45) * 2.;\n    col = col * ao * (amb * vec3(.9, .85, 1.) + diff * vec3(1., .9, .9)) + spec * vec3(1, .9, .5) * .7;\n    return col;\n}\n\n\n\n\nvec3 raymarch( in vec3 from, in vec3 dir) {\n    vec3 color, pos;\n    float t = 0.;\n    float td = 0.;\n    float d = 0.;\n    for (int i = 0; i < 128; i++) {\n        pos = from + t * dir;\n        float precis = 0.001 * t;\n        d = map(from + dir * t);\n\tdet=detail*(1.+t*55.);\n   \n        if (d < 0.0002) break;\n\t        t += d;\n    }\n    vec3 backg = vec3(.4,0.5,0.8);\n    //vec3 backg = vec3(.5);\n\n    color = light(pos - det * dir * 1.5, dir);\n    color *= vec3(1., .75, .8) * .9;\n    color = mix(color, backg, 1.0 - exp(-1.3 * pow(t, 1.3)));\n\n    return color;\n}\n\nvec3 camPath(float time) {\n    vec2 p = 600.0 * vec2(cos(1.4 + 0.37 * time),cos(3.2 + 0.31 * time));\n    return vec3(p.x, 0.0, p.y);\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\nvec3 postprocess(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(0.67));\n    \n\t//#define CONTRAST 1.4\n    #define CONTRAST 1.6\n    \n\t#define SATURATION 1.4\n\t#define BRIGHTNESS 1.2\n    \n    \n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t//rgb = clamp(rgb+hash(xy*time)*.1, 0.0, 1.0);\n\treturn rgb;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n    float t = iTime * 0.5;\n    vec2 s = uv * vec2(1.75, 1.0);\n\n\n    vec3 campos = camPath(t * 0.001);\n    vec3 camtar = camPath(t + 2.0);\n    //float roll = 15.0*sin(t*.5+.4);\n\t\n    float roll = 0.4 * cos(0.4 * t);\n    vec3 cw = normalize(camtar - campos);\n    vec3 cp = vec3(sin(roll), cos(roll), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(s.x * cu + s.y * cv + .6 * cw);\n\n    vec3 col = raymarch(campos, rd);\n\tcol = postprocess(col,s);\n    fragColor  = vec4(col, 0.0);\n\n\n}","name":"Image","description":"","type":"image"}]}