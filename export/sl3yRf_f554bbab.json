{"ver":"0.1","info":{"id":"sl3yRf","date":"1660221973","viewed":106,"name":"Romberg-Richardson Integration","username":"Envy24","description":"Comparison for trapezoid rule and Richardson's extrapolation (Romberg integration in general case).\n\nGreen curve - f(x)\nBlue curve - exact definite integral of f(x),\nRed curve - numeric definite integral of f(x) by trapezoid or Romberg rules.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["numerical","integral","integration","extrapolation","trapezoid","rule","definite","richardson","romberg"],"hasliked":0,"parentid":"7dVfD1","parentname":"Plotter template_"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Redefine this macroses for your function.\n#define integ(x)         ( -cos(x) + 1. )  // analytic definite integral form a to b of func(x) (by default a = 0 = const).\n#define func(x)          ( sin(x) )\n#define deriv(x)         ( cos(x) )\n#define num_of_intervals   6.0\n\n// Static\n//#define RULE(a, b, n) integrate_trapezoid((a), (b), (n)*2.)\n//#define RULE(a, b, n) RombergRichardson((a), (b), (n))\n\n// Dynamic compare Romberg vs. Trapezoid.\n#define RULE(a, b, n) ( fract(iTime*0.25) < 0.5 ? integrate_trapezoid((a), (b), (n)*2.) : RombergRichardson((a), (b), (n)) )\n\n/*\n    [a, b] - closed interval,\n    n - number of subintervals.\n*/\nfloat integrate_trapezoid(float a, float b, float n)\n{\n    float dx = (b-a)/n, sum = 0.5*(func(a) + func(b));   \n    \n    for (float i = 1.0; i < n; i+=1.) { sum += func(a + i * dx); }   \n    \n    return sum * dx;\n}\n\n/**\nfloat RombergRichardson(float a, float b, float n)\n{\n    float I0 = integrate_trapezoid(a, b, n);\n    float I1 = integrate_trapezoid(a, b, n * 2.);\n    \n    return I1 + (I1 - I0) / 3.;\n}\n/**\nfloat RombergRichardson(float a, float b, float n)\n{\n    float I0 = integrate_trapezoid(a, b, n);\n    float I1 = integrate_trapezoid(a, b, n * 2.);\n    float I2 = integrate_trapezoid(a, b, n * 4.);\n\n    float i0 = (4.* I1 - I0) / 3.;\n    float i1 = (4.* I2 - I1) / 3.;\n    \n    return (16.*i1 - i0) / 15.;\n}\n/**\nfloat RombergRichardson(float a, float b, float n)\n{\n    float I0 = integrate_trapezoid(a, b, n);\n    float I1 = integrate_trapezoid(a, b, n * 2.);\n    float I2 = integrate_trapezoid(a, b, n * 4.);\n    float I3 = integrate_trapezoid(a, b, n * 8.);\n\n    float i0 = (4.* I1 - I0) / 3.;\n    float i1 = (4.* I2 - I1) / 3.;\n    float i2 = (4.* I3 - I2) / 3.;\n    \n    float Il = (16.*i1 - i0) / 15.;\n    float Im = (16.*i2 - i1) / 15.;\n    \n    return (64.*Im - Il) / 63.;\n}\n/* General case *\nfloat RombergRichardson(float a, float b, float n)\n{\n    const int max_size = 8; // affects to precision\n    float I[max_size]; \n    \n    float power = 1.;\n    for (int i = 0; i < max_size; ++i)\n    {\n        I[i] = integrate_trapezoid(a, b, n * power);\n        power *= 2.;\n    }\n\n    int e = max_size - 1;\n    float m = 4., denom = 1. / 3.;\n    while (e > 1)\n    {      \n        for (int i = 0; i < e; ++i)\n        {\n            I[i] = (m * I[i+1] - I[i]) * denom;\n        }\n        \n        m *= 4.; denom = 1./ (m - 1.);\n        \n        --e;\n    }\n\n    return (m*I[1] - I[0])*denom;\n}\n/**/\n/* Slightly optimized versions.*/\nfloat RombergRichardson(float a, float b, float n)\n{\n    float dx0 = (b-a)/n,    I0 = 0.0,\n          dx1 = dx0 * 0.5,  I1 = 0.0,\n          C = 0.5*(func(a) + func(b));\n    \n    for (float i = 1.0; i < n; i+=1.) { I0 += func(a + i * dx0); }\n    // Skip (don't recalculate) values that already accumulated in I0.\n    for (float i = 1.0, N = 2.*n; i < N; i+=2.) { I1 += func(a + i * dx1); }\n    // Take into account skipped values.\n    I1 += I0;\n    // Take into account f(a) and f(b).\n    I0 += C;   I1 += C;\n    I0 *= dx0; I1 *= dx1;\n    \n    return (4.* I1 - I0) / 3.;\n}\n/**\nfloat RombergRichardson(float a, float b, float n)\n{\n    float dx0 = (b-a)/n,    I0 = 0.0,\n          dx1 = dx0 * 0.5,  I1 = 0.0,\n          dx2 = dx0 * 0.25, I2 = 0.0,\n          C = 0.5*(func(a) + func(b));\n    \n    for (float i = 1.0; i < n; i+=1.)           { I0 += func(a + i * dx0); }\n    for (float i = 1.0, N = 2.*n; i < N; i+=2.) { I1 += func(a + i * dx1); }\n    for (float i = 1.0, N = 4.*n; i < N; i+=2.) { I2 += func(a + i * dx2); }\n      \n               I1 += I0;  I2 += I1;\n    I0 += C;   I1 += C,   I2 += C;\n    I0 *= dx0; I1 *= dx1; I2 *= dx2;\n    \n    float i0 = (4.* I1 - I0) / 3., i1 = (4.* I2 - I1) / 3.;\n    \n    return (16.*i1 - i0) / 15.;\n}\n/**\nfloat RombergRichardson(float a, float b, float n)\n{\n    float dx0 = (b-a)/n,     I0 = 0.0,\n          dx1 = dx0 * 0.5,   I1 = 0.0,\n          dx2 = dx0 * 0.25,  I2 = 0.0,\n          dx3 = dx0 * 0.125, I3 = 0.0,\n          C = 0.5*(func(a) + func(b));\n    \n    for (float i = 1.0; i < n; i+=1.)           { I0 += func(a + i * dx0); }\n    for (float i = 1.0, N = 2.*n; i < N; i+=2.) { I1 += func(a + i * dx1); }\n    for (float i = 1.0, N = 4.*n; i < N; i+=2.) { I2 += func(a + i * dx2); }\n    for (float i = 1.0, N = 8.*n; i < N; i+=2.) { I3 += func(a + i * dx3); }\n      \n               I1 += I0;  I2 += I1;  I3 += I2; \n    I0 += C;   I1 += C;   I2 += C;   I3 += C;\n    I0 *= dx0; I1 *= dx1; I2 *= dx2; I3 *= dx3;\n    \n    float i0 = (4.* I1 - I0) / 3.,  i1 = (4.* I2 - I1) / 3., i2 = (4.* I3 - I2) / 3.,\n          Il = (16.*i1 - i0) / 15., Im = (16.*i1 - i0) / 15.;\n    \n    return (64.*Im - Il) / 63.;\n}\n/* Slightly optimized general case *\nfloat RombergRichardson(float a, float b, float n)\n{\n    const int max_size = 8; // affects to precision\n    float I[max_size];\n    float dx = (b-a)/n, C = 0.5*(func(a) + func(b)), power = 1.;\n        \n    for (float i = 1.0; i < n; i+=1.) { I[0] += func(a + i * dx); }\n    for (int i = 1; i < max_size; ++i)\n    {\n        power *= 2.; dx *= 0.5; I[i] = 0.0;\n        \n        for (float j = 1.0, N = power*n; j < N; j+=2.) { I[i] += func(a + j * dx); }\n    }\n    dx = (b-a)/n;\n    \n    for (int i = 0, e = max_size - 1; i < e; ++i) { I[i+1] += I[i]; I[i] += C; I[i] *= dx; dx *= 0.5; }    \n    I[max_size - 1] += C; I[max_size - 1] *= dx;\n\n    int e = max_size - 1;\n    float m = 4., denom = 1. / 3.;\n    while (e > 1)\n    {      \n        for (int i = 0; i < e; ++i)\n        {\n            I[i] = (m * I[i+1] - I[i]) * denom;\n        }\n        \n        m *= 4.; denom = 1./ (m - 1.); --e;\n    }\n\n    return (m*I[1] - I[0])*denom;\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 3.0\n#define YSCALE 1.0\n#define OFFSET vec2(1.5, 0.25)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n            \n         NDC.x *= 2.0;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n         color.rg -= draw_func(NDC, YSCALE*integ(NDC.x), YSCALE*func(NDC.x));\n         \n         /* \"All\" values of definite integral */\n         float n = num_of_intervals, a = 0.,  b = NDC.x,\n               y = RULE(a, b, n), yn = RULE(a, b+1./n, n);\n         color.gb -= draw_func(NDC, YSCALE*y, YSCALE*((yn-y)/(1./n)));\n    \n    /* One value of definite integral (trapezoid rule). */\n    a= 0., b=sinOSC(0.0, 18.0, iTime*0.25);\n    float dx = (b-a)/n, radius = UNIT;\n    for (float i = 0.; i <= n; i+=1.)\n    {\n        float x = a+i * dx, y = YSCALE*func(x), yn = YSCALE*func(x + dx);\n        \n        color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(x, y), radius)));\n        color = mix(color, vec3(1, 0, 1), SM(segmentSDF_L2(NDC, vec2(x, 0.), vec2(x, y))));\n        color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(x, 0.), radius)));\n        \n        if (i < n) // Not last point?\n        {\n            color = mix(color, vec3(1, 0, 1), SM(segmentSDF_L2(NDC, vec2(x, y), vec2(x+dx, yn))));\n        }\n    }\n    color = mix(color, vec3(0, 0, 1), SM(diskSDF_L2(NDC, vec2(b, YSCALE*RULE(a, b, n)), radius*1.2)));\n    /**/\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}