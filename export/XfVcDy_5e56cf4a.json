{"ver":"0.1","info":{"id":"XfVcDy","date":"1732676073","viewed":76,"name":"Oscillating Web","username":"prasound","description":"An array of coupled oscillators shaped as a drum and driven by an external force. Simulation and rendering are done in 4d, as the math is the same, so the web can oscillate along the 4th dimension.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["4d","oscillator","drum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0: Drum Oscillator.\n//  Feel free to use in your experiments.\n//\n// Raytraces the mesh defined by iChannel0 coords.\n\nstruct RT { float dist; vec4 norm; int oid; };\n\nconst RT RT_INF = RT(INF,vec4(0),0);\n\nvec4 ballCoords(ivec2 qr) {\n    return qr2xy(qr) + qrData(iChannel0, 0, qr);\n}\nfloat sphereDist(vec4 ro, vec4 rd, vec4 ce, float ra) {\n    vec4 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    if(h<0.) return INF;\n    return -b - sqrt(h);\n}\n\nRT sphereRT(vec4 ro, vec4 rd, vec4 ce, float ra) {\n    float t = sphereDist(ro, rd, ce, ra);\n    if (t == INF) return RT_INF;\n    vec4 n = normalize(ro + rd*t - ce);\n    return RT(t, n, +1);\n}\n\nRT cylinderRT(vec4 ro, vec4 rd, vec4 a, vec4 b, float ra) {\n    vec4  ba = b  - a;\n    vec4  oc = ro - a;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return RT_INF;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba )\n        return RT(t, (oc+t*rd - ba*y/baba)/ra, -1);\n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n        return RT(t, ba*sign(y)/sqrt(baba), -1);\n    return RT_INF;\n}\n\nRT boundingBoxRT(vec4 ro, vec4 rd) {\n    vec4 a = vec4(0,0,1,0)*(DMAX+SR);\n    float r = float(GS)+DMAX+SR;\n    return cylinderRT(ro, rd, -a, a, r);\n}\n\nRT sceneRT(vec4 ro, vec4 rd) {\n    RT res = RT_INF;\n    \n    if (boundingBoxRT(ro, rd).dist == INF)\n        return RT_INF;\n   \n    // https://www.redblobgames.com/grids/hexagons\n    for (int q = -GS; q <= GS; q++)\n    for (int r = -GS; r <= GS; r++) {\n        ivec2 qr = ivec2(q,r); // q+r+s=0\n        if (qrDist(qr) > GS) continue;\n        \n        // This sphere encloses all 6 neighbors.\n        // If it's missed, it saves 4 texture lookups.\n        if (sphereDist(ro, rd, qr2xy(qr), 1.+SR+DMAX) == INF)\n            continue;\n        \n        vec4 ce = ballCoords(qr);\n        RT hit = sphereRT(ro, rd, ce, SR);\n        if (hit.dist < res.dist) res = hit;\n            \n        for (int i = 0; i < 3; i++) {\n            ivec2 qr2 = qr + QR6[i];\n            if (qrDist(qr2) > GS) continue;\n            vec4 ce2 = ballCoords(qr2);\n            RT hit = cylinderRT(ro, rd, ce, ce2, CR);\n            if (hit.dist < res.dist) res = hit;\n        }\n    }\n    \n    return res;\n}\n\nmat2 rot2(float phi) {\n    float c = cos(phi), s = sin(phi);\n    return mat2(c, -s, s, c);\n}\n\nvec3 background(vec4 rd) {\n    return texture(iChannel1, rd.xyz).rgb;\n}\n\nvec3 render(vec4 ro, vec4 rd, mat4 wm) {\n    RT hit = sceneRT(ro*wm, rd*wm);\n    if (hit.dist == INF)\n        return 0.3*background(rd);\n\n    vec4 n = hit.norm*inverse(wm);\n    vec4 p = ro + rd*hit.dist;\n    vec4 ref = reflect(rd, n);\n    vec3 col = hit.oid > 0 ? vec3(0.6,1.0,0.3) : vec3(0.3);\n    \n    return col*background(ref);\n}\n\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 mo = iMouse.xy/iResolution.xy - 0.5;\n    vec3 ro = float(GS)*vec3(0,0,2);\n    ro.xz *= rot2(-iTime*0.3);\n    vec3 ta = vec3(0,0,0); // target\n    mat3 ca = setCamera(ro, ta);\n    \n    mat4 wm = mat4(1);\n    for (int i = 0; i < 4; i++) {\n        wm[i].xy *= rot2(-iTime*0.1);\n        wm[i].xz *= rot2(-mo.x*PI*2.);\n    }\n    \n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec3 rd = ca * normalize(vec3(p,1)); // ray direction\n    vec3 col = render(vec4(ro,0), vec4(rd,0), wm);\n\n    col = 2.1*col/(1.+1.5*col); // tonemapping\n    col = pow(col, vec3(.4545)); // gamma correction\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    col *= .3+.7*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Updates mass coords per Newton's 2nd law of motion.\n//\n// iChannel0[q,r] = displacement from the original\n//     position qr2xy(q,r). It's used to compute\n//     tension between neighbors.\n//\n// iChannel0[q+GS21,r] = the previous frame for\n//     computing the acceleration in F=ma.\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    // https://www.redblobgames.com/grids/hexagons\n    int q = int(p.x-0.5)-GS, r = int(p.y-0.5)-GS;\n\n    // 2 frames only: current, previous.\n    if (r > GS || q > GS + GS21)\n        return;\n    // Copy frame: previous <- current.\n    if (q > GS) {\n        o = qrData(iChannel0, 0, ivec2(q-GS21,r));\n        return;\n    }\n    \n    vec4 r0 = qrData(iChannel0, 0, ivec2(q,r));\n    vec4 force; // Optional: add the gravity vector here.\n    \n    for (int i = 0; i < 6; i++) {\n        ivec2 dqr = QR6[i];\n        // qrData outside the boundary returns 0, i.e. fixed masses.\n        vec4 r1 = qrData(iChannel0, 0, ivec2(q,r) + dqr) + qr2xy(dqr);\n        force += TENSION*(r1-r0); // https://en.wikipedia.org/wiki/Hooke%27s_law\n    }\n    \n    // w'' = T/m\n    vec4 r0_prev = qrData(iChannel0, 1, ivec2(q,r));\n    o = 2.*r0 - r0_prev;\n    o += force/MASS * (DT*DT);\n    \n    // A ball in the middle is driven by a sine wave.\n    // Use the 4th coordinate to make it oscillate in 4d.\n    if (q==0 && r==0)\n        o = vec4(0,0,1,0)*sin(float(iFrame*2)*DT);\n \n    // Set a reasonable boundary box to speed up rendering.\n    // It also prevents runaway numerical errors.\n    o = clamp(o,vec4(-DMAX),vec4(DMAX));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\nconst float SQ3 = sqrt(3.);\nconst float INF = 1e10;\nconst int GS = 6; // Radius of the mesh.\nconst int GS21 = GS*2+1; // One frame: GS21 x GS21.\nconst float DT = 1./float(GS);\nconst float SR = 0.2; // sphere radius\nconst float CR = 0.05; // capsule radius\nconst float MASS = 0.75;\nconst float TENSION = 1.0;\n\n// Limits the motion of masses to |qr2xy(qrs)| <= DMAX.\n// Large values make motion more realistic.\n// Small values speed up rendering.\nconst float DMAX = 3.0;\n\n// https://www.redblobgames.com/grids/hexagons\nconst ivec2[] QR6 = ivec2[6](\n    ivec2(+1,-1), ivec2(0,+1), ivec2(-1,0),\n    ivec2(-1,+1), ivec2(0,-1), ivec2(+1,0));\n\nint qrDist(ivec2 qr) {\n    int q = qr.x, r = qr.y, s = -q-r;\n    return max(abs(q),max(abs(r),abs(s)));\n}\n\n// (q,r,s) -> (x,y)\nvec4 qr2xy(ivec2 qr) {\n    const mat2 basis = mat2(1, 0, .5, 1.5/SQ3);\n    return vec4(basis*vec2(qr), 0, 0);\n}\n\n// (q,r,s) -> offset from qr2xy(q,r)\nvec4 qrData(sampler2D ch0, int frame, ivec2 qr) {\n    if (qrDist(qr) > GS) return vec4(0);\n    ivec2 txy = qr + GS + frame*ivec2(GS21,0);\n    return texelFetch(ch0, txy, 0);\n}\n","name":"Common","description":"","type":"common"}]}