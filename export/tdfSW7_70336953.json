{"ver":"0.1","info":{"id":"tdfSW7","date":"1551394619","viewed":236,"name":"[TWITCH] The seal","username":"Flopine","description":"The result of the 8th twitch live session! Again heavily inspired by Zelda... I promise this will be the last time! ... or maybe not :P \nHere is the link to the stream: https://www.twitch.tv/videos/388255723","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","zelda","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI 3.141592\n#define time iTime\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat rand (float x)\n{return fract(sin(x)*154845.4845);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b), 0.5 *(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat moda (inout vec2 p, float rep)\n{\n  float per = 2.*PI/rep;\n  float a = atan(p.y,p.x);\n  float l = length(p);\n  float id = floor(a/per);\n  a = mod(a,per)-per*0.5;\n  p = vec2(cos(a),sin(a))*l;\n  if (abs(id) >= rep/2.) id = abs(id);\n  return id;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat cylH (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(max(q.x,max(q.y,q.z)),0.) + length(max(q, 0.));\n}\n\nfloat id;\nfloat tentacles (vec3 p)\n{\n  p.y += 4.;\n  id = moda(p.xz, 7.);\n  float offset = mix (0.,1.+sin(p.y*0.5+time)*0.5, smoothstep(5.,1.,p.y));\n  p.x -= offset;\n  return cylH(p.xzy, 0.3+p.y*0.06, 5.);\n}\n\nfloat gem (vec3 p)\n{\n  p.y -= 1.5;\n  float pedestral = stmin(box(p,vec3(1., 0.5, 1.)), od(p,0.8), 0.5, 5.);\n  p.xz *= rot(time);\n  float o1 = od(vec3(p.x,p.y-4.5+sin(time)*0.2,p.z), 0.9);\n  return stmin(pedestral, o1, 1.2, 4.);\n}\n\nfloat seal (vec3 p)\n{\n  p *= 1.3;\n  p.y -= 9.;\n  p.x = abs(p.x);\n  p.x -= 5.;\n\n  vec3 pp = p;\n  p.x += p.y * p.y * 0.12;\n  float sticks = box(p, vec3(.9-p.y*0.18,4., 0.15));\n  \n  p = pp;\n  p.xy *= rot(PI/9.);\n  p.x -= 4.;\n  p.y -= 1.8;\n  float b1 = box(vec3(p.x-p.y*0.7, p.y , p.z), vec3(4., 1.+p.x*0.1, 0.15)); \n\n  p = pp;\n  p.x -= 2.5;\n  p.y += 0.6;\n  float b2 = box(vec3(p.x-p.y*0.7, p.y , p.z), vec3(2.8, .8+p.x*0.1, 0.15)); \n\n  p = pp;\n  p.x -= 1.;\n  p.y += 3.;\n  p.xy *= rot(-PI/10.);\n  float b3 = box(vec3(p.x-p.y*0.7, p.y , p.z), vec3(2., .6+p.x*0.1, 0.15)); \n\n  return min(b3,min(b2,min(sticks, b1)))/1.3;\n}\n\nint mat;\nfloat SDF (vec3 p)\n{\n  p.y += sin(time)*0.2;\n  p.xz *= rot(time*0.2);\n  float s = seal(p);\n  float t = tentacles(p);\n  float g = gem(p);\n  float d = min(s,stmin(t,g, 0.2, 2.));\n  \n  if (d == s) mat = 1;\n  if (d == t) mat = 2;\n  if (d == g) mat = 3;\n\n  return d;\n}\n\nvec3 get_cam(vec3 ro, vec3 tar, vec2 uv, float fov)\n{\n  vec3 forward = normalize(tar-ro);\n  vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n  vec3  up = normalize(cross(forward, left));\n  return normalize(forward * fov + left*uv.x + up * uv.y);\n}\n\nvec3 get_norm (vec3 p)\n{\n  vec2 eps = vec2(0.001,0.);\n  return normalize(vec3(SDF(p+eps.xyy) - SDF(p-eps.xyy),\n                      SDF(p+eps.yxy) - SDF(p-eps.yxy),\n                      SDF(p+eps.yyx) - SDF(p-eps.yyx)\n                      )\n                );\n}\n\nfloat dir_light(vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5 + 0.5;}\n\nfloat spec_light (vec3 rd, vec3 n, vec3 lpos, float spec_pow)\n{\n  vec3 h = normalize(lpos-rd);\n  return pow(max(dot(n,h),0.), spec_pow);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(2.,-6.,-22.), p = ro;\n  vec3 tar = vec3(0.,1. ,0.);\n  vec3 rd = get_cam(ro, tar, uv,1.);\n  vec3 col = vec3(0.);\n  float shad = 0.;\n  bool hit = false;\n\n  for (float i=0.; i<ITER; i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      hit = true;\n      break;\n    }\n\n    p+= d*rd*0.8;\n  }\n\n  if (hit)\n  {\n    vec3 n = get_norm(p);\n    vec3 keypos = vec3(2., 2., -3.);\n    vec3 rimpos = vec3(0., -1., 4.);\n    \n    float fre = pow(clamp(1.-dot(n, -rd),0.,1.), 5.); \n    float keylight = dir_light(n, keypos);\n    float rimlight = dir_light(n, rimpos);\n\n    if (mat == 1) \n    {\n      vec3 albedo = vec3(.8,0.8,1.);\n        col += albedo * keylight * vec3(0.9,0.9, 0.8);\n        col += albedo * rimlight*vec3(0.5,0.6, 0.8);\n        col += spec_light(rd, n, keypos, 2.)*keylight;\n    }\n    if (mat == 2) \n    {\n      vec3 albedo = vec3(rand(floor(id*7.))*.9,1.,rand(floor(id*7.))*.5);\n      col += albedo * keylight * vec3(0.9,0.9, 0.8);\n      col += albedo * rimlight*vec3(0.5,0.6, 0.8);\n      col += spec_light(rd, n, keypos, 2.)*keylight;\n      col /= 2.;\n    }\n\n    if (mat == 3)\n    {\n      vec3 albedo = vec3(1.,0.9,0.1);\n      col += albedo * keylight * vec3(0.9,0.9, 0.8);\n      col += albedo * spec_light(rd, n, keypos, 5.)*0.3;\n      col += albedo * vec3(0.8,0.4,0.1) * spec_light(rd, n, keypos, 18.)*10.;\n      col += fre*vec3(1.,0.8,0.);\n      col /= 2.;\n    } \n  }\n  float t = length(ro-p);\n  col *= 1.-shad;\n    \n  // suggested by LJ: thank youuuuuuuu <3\n  float texnoise = texNoise(uv+vec2(sin(time*0.05), time*0.05)).r; \n  col = pow(mix(col, vec3(0.9,0.8,1.-length(uv)*0.5), 1.-exp(-0.0005*t*t) +texnoise),vec3(0.8));\n  \n  fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}