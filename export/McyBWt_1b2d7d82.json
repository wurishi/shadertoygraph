{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Constants - adjusted for new effects\n#define FAR 80.\n#define WATER_LEVEL -8.5  // Lowered water level\n#define WATER_CLARITY 0.95\n#define ICE_TRANSPARENCY 0.85  // Higher value for more see-through ice\n#define GLOBAL_REFLECTIVITY 0.9  // Increased overall reflectivity\n\n// Existing rotation matrix\nmat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Enhanced hash functions for better noise\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n// New function for icicle generation\nfloat icicle(vec3 p) {\n    vec3 q = vec3(fract(p.x*2.)-0.5, p.y, fract(p.z*2.)-0.5);\n    float h = hash(floor(vec3(p.x*2., 0, p.z*2.)));\n    float len = 2.5 + h*2.0; // Variable length icicles\n    float d = length(q.xz) - 0.1 - 0.1*max(0., -q.y); // Conical shape\n    float tip = q.y + len;\n    return max(d, tip);\n}\n\n// Modified object drawing for clearer crystalline structure\nfloat drawObject(in vec3 p){\n    p = fract(p)-.5;\n    return dot(p, p) + 0.1*abs(p.x*p.y*p.z); // Reduced noise for more transparency\n}\n\n// Modified cellular tile routine\nfloat cellTile(in vec3 p){\n    vec4 d;\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n    \n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*2.66;\n}\n\nvec2 path(in float z){ \n    return vec2(20.*sin(z * .04), 4.*cos(z * .09) + 3.*(sin(z*.025) - 1.)); \n}\n\n// Enhanced surface function for more translucent ice\nfloat surfFunc(in vec3 p){\n    float c = cellTile(p/8.); // Increased scale for larger crystal patterns\n    return mix(c, cos(c*6.283*2.)*.5 + .5, .4) + \n           0.05*sin(p.x*4.)*sin(p.y*4.)*sin(p.z*4.); // Reduced noise\n}\n\n// Modified water movement\nfloat waterFlow(vec3 p) {\n    float flowSpeed = 2.0;\n    float flowScale = 0.06;\n    return sin(p.z * 0.5 + iTime * flowSpeed) * flowScale + \n           cos(p.x * 0.25 + iTime * flowSpeed * 0.7) * flowScale;\n}\n\n// Smooth min/max functions\nfloat smin(float a, float b, float s){\n    float h = clamp(0.5 + 0.5*(b-a)/s, 0., 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\nfloat smax(float a, float b, float s){\n    float h = clamp(0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// Enhanced main distance function with icicles\nfloat map(vec3 p){\n    float sf = surfFunc(p);\n    \n    // Ice cave structure\n    float cav = dot(cos(p*3.14159265/8.), sin(p.yzx*3.14159265/8.)) + 2.25;\n    \n    p.xy -= path(p.z);\n    \n    float tun = 1.6 - length(p.xy*vec2(1, .4));\n    tun = smax(tun, 1.-cav, 2.) + .75 + (.5-sf);\n    \n    // Add icicles\n    float ici = icicle(p + vec3(0, 15, 0));\n    \n    // Ground and water surface\n    float gr = p.y + 7. - cav*.5 + (.5-sf)*.5;\n    float water = p.y - WATER_LEVEL + waterFlow(p);\n    float rf = p.y - 15.;\n    \n    // Combine all elements\n    float cave = smax(smin(tun, gr, .15), rf, 1.);\n    cave = min(cave, ici); // Add icicles to the scene\n    return min(cave, water);\n}\n\n// Enhanced ray marching\nfloat trace(in vec3 ro, in vec3 rd){\n    float t = 0., h;\n    for(int i=0; i<128; i++){\n        h = map(ro+rd*t);\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break;\n        t += h*.8;\n    }\n    return min(t, FAR);\n}\n\nvec3 normal(in vec3 p){\n    vec2 e = vec2(-1., 1.)*0.001;   \n    return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n                    e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy));\n}\n\n// Enhanced ice color with more transparency and reflections\nvec3 iceColor(vec3 p, vec3 n, vec3 rd, float depth) {\n    vec3 baseIce = vec3(0.8, 0.9, 1.0);\n    vec3 deepIce = vec3(0.4, 0.5, 0.7);\n    \n    float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 4.0) * GLOBAL_REFLECTIVITY;\n    \n    vec3 ice = mix(baseIce, deepIce, smoothstep(0., FAR*0.5, depth) * ICE_TRANSPARENCY);\n    \n    float crystal = pow(max(dot(n, normalize(vec3(1,2,3))), 0.0), 32.0);\n    \n    // Enhanced reflections\n    vec3 reflection = reflect(rd, n);\n    float reflectionStrength = fresnel * GLOBAL_REFLECTIVITY;\n    \n    return mix(ice, vec3(1), crystal) + reflectionStrength * vec3(0.5);\n}\n\n// Enhanced water color with better reflections\nvec3 waterColor(vec3 p, vec3 n, vec3 rd) {\n    vec3 waterBase = vec3(0.1, 0.2, 0.3) * WATER_CLARITY;\n    float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 3.0) * GLOBAL_REFLECTIVITY;\n    \n    float flow = waterFlow(p * 2.0) * 0.5 + 0.5;\n    float caustics = sin(p.x*4.0 + p.z*4.0 + iTime*2.0) * 0.5 + 0.5;\n    caustics *= sin(p.x*2.0 - p.z*3.0 + iTime*1.5) * 0.5 + 0.5;\n    \n    vec3 waterColor = mix(waterBase, vec3(0.3, 0.5, 0.7) * WATER_CLARITY, flow);\n    waterColor += caustics * vec3(0.1, 0.2, 0.3) * WATER_CLARITY;\n    \n    // Enhanced reflections\n    vec3 reflection = reflect(rd, n);\n    float reflectionStrength = fresnel * GLOBAL_REFLECTIVITY;\n    \n    return waterColor + reflectionStrength * vec3(0.6);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0, iTime*8.);\n    vec3 lookAt = ro + vec3(0, 0, .5);\n    \n    ro.xy += path(ro.z);\n    lookAt.xy += path(lookAt.z);\n\n    float FOV = 3.14159265/2.5;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x));\n    vec3 up = cross(forward, right);\n\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    rd.xy = rot2(path(lookAt.z).x/64.)*rd.xy;\n    \n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n    \n    float t = trace(ro, rd);\n    vec3 sp = ro + rd*t;\n    vec3 n = normal(sp);\n    \n    vec3 col;\n    if(t < FAR) {\n        if(sp.y < WATER_LEVEL + waterFlow(sp)) {\n            col = waterColor(sp, n, rd);\n        } else {\n            col = iceColor(sp, n, rd, t);\n        }\n        \n        float diff = max(dot(n, normalize(lp-sp)), 0.0);\n        float spec = pow(max(dot(reflect(-normalize(lp-sp), n), -rd), 0.0), 32.0);\n        \n        col *= 0.5 + 0.5*diff;\n        col += vec3(0.4)*spec * GLOBAL_REFLECTIVITY;\n    } else {\n        col = vec3(0.15, 0.25, 0.35);\n    }\n    \n    // Enhanced fog with better depth perception\n    col = mix(col, vec3(0.15, 0.25, 0.35), 1.0 - exp(-0.01*t*t));\n    \n    // Enhanced vignette\n    vec2 q = fragCoord/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McyBWt","date":"1734561598","viewed":76,"name":"Ice Cave Chance","username":"Chance","description":"ice cave","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["ice"],"hasliked":0,"parentid":"","parentname":""}}