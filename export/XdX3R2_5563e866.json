{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//http://web.engr.oregonstate.edu/~zhange/images/tenflddesn.pdf\n//and maybe some other sources\n\n//pick one of these:\n//#define ADVECT_VECTOR\n#define ADVECT_TENSOR\n\n//pick one of these:\n#define INTEGRATE_EULER\n//#define INTEGRATE_RK4\n\n#define MAX_ITERATIONS\t100\n\nconst vec3 greyscale = vec3(.3, .6, .1);\nconst float dt = .1;\n\nvec2 calcGradient(vec2 p) {\n\tvec2 dxy = vec2(1.) / iResolution.xy;\n\tvec2 dx = vec2(dxy.x, 0.);\n\tvec2 dy = vec2(0., dxy.y);\n\t//3x3 greyscale intensity window\n\tfloat i00 = dot(texture(iChannel0, p - dxy).rgb, greyscale);\n\tfloat i10 = dot(texture(iChannel0, p - dy).rgb, greyscale);\n\tfloat i20 = dot(texture(iChannel0, p - dy + dx).rgb, greyscale);\n\tfloat i01 = dot(texture(iChannel0, p - dx).rgb, greyscale);\n\tfloat i11 = dot(texture(iChannel0, p).rgb, greyscale);\n\tfloat i21 = dot(texture(iChannel0, p + dx).rgb, greyscale);\n\tfloat i02 = dot(texture(iChannel0, p - dx + dy).rgb, greyscale);\n\tfloat i12 = dot(texture(iChannel0, p + dy).rgb, greyscale);\n\tfloat i22 = dot(texture(iChannel0, p + dxy).rgb, greyscale);\n\t//Scharr filter\n\tvec2 g;\n\tg.x = 3. * i02 + 10. * i12 + 3. * i22\n\t\t\t - 3. * i00 - 10. * i10 - 3. * i20;\n\tg.y = 3. * i20 + 10. * i21 + 3. * i22\n\t\t\t - 3. * i00 - 10. * i01 - 3. * i02;\n\t\n\tg.y = -g.y;\n\treturn g;\n}\n\n//http://www.math.harvard.edu/archive/21b_fall_04/exhibits/2dmatrices/index.html\nvec2 eigen(mat2 structure, out vec2 eig1) {\n\tfloat tr = structure[0].x + structure[1].y;\n\tfloat det = structure[0].x * structure[1].y - structure[0].y * structure[1].x;\n\tfloat gap = sqrt(tr * tr - 4. * det);\n\tvec2 lambda = .5 * vec2(tr + gap, tr - gap);\n\tif (structure[0].y == 0. && structure[1].x == 0.) {\n\t\teig1 = vec2(1., 0.);\n\t} else if (structure[0].y == 0.) {\n\t\teig1 = vec2(structure[1].x, lambda.x - structure[0].x);\n\t} else {\n\t\teig1 = vec2(lambda.x - structure[1].y, structure[0].y);\n\t}\n\treturn lambda;\n}\n\nvec2 calcMovement(vec2 np, vec2 lastdp) {\n#ifdef ADVECT_VECTOR\n\t// Gradient-based <=> Vector Induced Edge Field\n\tvec2 grad = calcGradient(np);\n\tgrad = vec2(-grad.x, -grad.y);\n\tvec2 dp = grad;\n#endif\n\n#ifdef ADVECT_TENSOR\n\t// Structure Matrix <=> Tensor Induced Edge Field\n\t//http://en.wikipedia.org/wiki/Structure_tensor\n\tvec2 f = calcGradient(np);\n\tmat2 structure = mat2(f.x * f.x, f.x * f.y, f.x * f.y, f.y * f.y);\n\tvec2 eig1;\n\tvec2 lambda = eigen(structure, eig1);\n\tvec2 dp = eig1;\n#endif\n\t\n\t//dp = normalize(dp);\n\tif (dot(dp, lastdp) < 1.) dp = -dp;\n\treturn dp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 dxy = vec2(1.) / iResolution.xy;\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t//color at point\n\tvec3 pointColor = texture(iChannel0, p).rgb;\n\t//backward trace\n\tvec3 resultColor = pointColor;\n\tvec3 lastPointColor = pointColor;\n\t//float avgWeight = 1.;\n\tvec2 np = p;\n\tvec2 lastdp = vec2(0.);\n\tfloat colorInfluence = 0.;\n\tfor (int i = 0; i < MAX_ITERATIONS; ++i) {\n\t\tif (mod(floor(np * iResolution.xy), 4.) == vec2(0.)) {\n\t\t\tcolorInfluence = 1.;\n\t\t}\n\t\t\n#ifdef INTEGRATE_EULER\n\t\tvec2 dp = calcMovement(np, lastdp);\n\t\tnp += dt * dp * dxy;\n#endif\n\t\t\n#ifdef INTEGRATE_RK4\n\t\tvec2 dp1 = calcMovement(np, lastdp);\n\t\tvec2 dp2 = calcMovement(np + .5 * dt * dp1, lastdp);\n\t\tvec2 dp3 = calcMovement(np + .5 * dt * dp2, lastdp);\n\t\tvec2 dp4 = calcMovement(np + dt * dp3, lastdp);\n\t\tvec2 dp = (dp1 + 2. * dp2 + 2. * dp3 + dp4) * (1. / 6.);\n\t\tnp += dt * dp * dxy;\n#endif\n\t\t\n\t\tlastdp = dp;\n\t\t\n\t\t//resultColor += texture(iChannel0, np).rgb;\n\t\t//avgWeight += 1.;\n\t}\n\t//resultColor /= avgWeight;\n\n\t//last color\n\tresultColor = texture(iChannel0, np).rgb;\n\t\n\tresultColor *= colorInfluence;\n\t\n\t//cell shade while we're here?\n\t\n\t/* color by distance travelled? * /\n\tvec2 delta = np - p;\n\tfloat l = dot(delta,delta);\n\tresultColor.r = 1. / (1. + 1000000. * l);\n\tresultColor.gb = vec2(0.);\n\t/**/\n\t\n\tvec2 delta = (np - p) * iResolution.xy;\n\tfloat deltaLenSq = dot(delta, delta);\n\tif (deltaLenSq < 2.) {\n\t\tfragColor = vec4(0.);\n\t} else {\n\t\tfragColor = vec4(resultColor, 1.);\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":true,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdX3R2","date":"1374282650","viewed":331,"name":"Image Flow","username":"thenumbernine","description":"camera image flow visualization ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cameraimageflow"],"hasliked":0,"parentid":"","parentname":""}}