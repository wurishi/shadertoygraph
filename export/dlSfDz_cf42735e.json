{"ver":"0.1","info":{"id":"dlSfDz","date":"1694027010","viewed":9,"name":"cuboid ","username":"tomcat7479","description":"使用R^3中的矩形的SDF函数结合phong光照模型实现的三维矩形","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","cuboidsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    R^3中长方体的sdf函数(和R^2的一致，可以看成直接推广)\n    Cuboid: 长方体\n     Cubic: 立方体\n*/\n\n#define min_iter_distance 0.1\n#define max_iter_distance 20.0\n#define iter_count 150\n#define iter_precision 1e-4\n#define N 3\n\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\n\nfloat sdfCuboid(vec3 p, vec3 cuboid_center, vec3 edge) {\n    p -= cuboid_center;\n    vec3 q = abs(p) - edge / 2.0;\n    return min(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), p.y + edge.z);\n}\n\n\nvec3 calNormal(vec3 p, vec3 cuboid_center, vec3 edge) {\n    const float h = 1e-4;\n    const vec2 k = vec2(1.0, -1.0);\n    vec3 part1 = k.xyy * sdfCuboid(p + k.xyy * h, cuboid_center, edge);\n    vec3 part2 = k.yyx * sdfCuboid(p + k.yyx * h, cuboid_center, edge);\n    vec3 part3 = k.yxy * sdfCuboid(p + k.yxy * h, cuboid_center, edge);\n    vec3 part4 = k.xxx * sdfCuboid(p + k.xxx * h, cuboid_center, edge);\n    return normalize(part1 + part2 + part3 + part4);\n}\n\n\nfloat rayMarching(vec3 ray_o, vec3 ray_d, vec3 cuboid_center, vec3 edge) {\n    float t = min_iter_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ray_o + t * ray_d;\n        float d = sdfCuboid(p, cuboid_center, edge);\n        if (d < iter_precision) {\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\n\nvec3 render(vec2 uv) {\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(1.0 + 3.0 * sin(iTime), 4.0 ,1.0 + cos(iTime));\n    vec3 cuboid_color = vec3(0.22, 0.88, 0.68);\n    float ambient_strength = 0.31;\n    float diffuse_strength = 0.91;\n    float specular_strength = 0.88;\n    float specular_lightness = 80.0;\n\n    vec3 cuboid_center = vec3(0.0, 0.0, -0.8);\n    vec3 edge = vec3(1.0, 0.8, 0.6);\n    \n    vec3 ray_o = vec3(0.5 + 3.0 * sin(iTime), 1.0, 1.0 + 0.5 * cos(iTime));\n    vec3 ray_d = normalize(vec3(uv, 0.0) - ray_o);\n    float t = rayMarching(ray_o, ray_d, cuboid_center, edge);\n\n    vec3 color = vec3(0.0);\n    if (t < max_iter_distance) {\n        vec3 p = ray_o + t * ray_d;\n        vec3 n = normalize(calNormal(p, cuboid_center, edge));\n        \n        vec3 ambient = light_color * cuboid_color * ambient_strength;\n\n        float dif_cos = clamp(dot(n, normalize(light_pos - p)), 0.0, 1.0);\n        vec3 diffuse = light_color * dif_cos * diffuse_strength;\n\n        vec3 refL = reflect(light_pos - p, n);\n        float spec_cos = clamp(dot(normalize(refL), normalize(ray_d)), 0.0, 1.0);\n        vec3 specular = light_color * pow(spec_cos, specular_lightness) * specular_strength;\n\n        color = ambient + specular + diffuse;\n        \n        color *= 0.8 + 0.2 * sin(150.0 * t);\n    }\n    return color;\n}\n\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = vec2(float(i), float(j)) / float(N);\n            offset = 2.0 * (offset - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    return color / float(N * N);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}