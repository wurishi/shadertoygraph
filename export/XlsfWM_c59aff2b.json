{"ver":"0.1","info":{"id":"XlsfWM","date":"1512160657","viewed":893,"name":"Rayleigh-Benard Convection","username":"riouxld","description":"Wait 20 sec\nBy buoyancy Hot(Red) tend to rise over Cold(Blue). (can change to bernard cell by commenting #define)\nLeftClick add source\nC toogle between source hot/cold\nSpacebar reset keep sources\n1 vel\n2 pres\n3 div\n4 vort","likes":21,"published":1,"flags":48,"usePreview":0,"tags":["simulation","fluid","advection","multipass","navierstokes","jacobi","multistep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rayleigh-Benard Convection\n// http://www.sciencedirect.com/science/article/pii/S1631072108000314\n\n// Dissipation due to poor time-stepping and bad iterative poisson-solver\n// Would love to do better but my computer do not take well the use\n// of large kernel like https://www.shadertoy.com/view/MlByW3\n\n// press\n// 1 - show velocity field\n// 2 - show pressure field\n// 3 - show divergence field\n// 4 - show vorticity field\n// left click - add cold source\n// spacebar - reset field keep sources\n// toogle\n// c - change source to hot, c again to cold....\n\n\n\n\n//macro\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetHeat(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).z\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).w\n#define GetDivergence(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).y\n#define GetVorticity(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).z\n\n\nfloat isKeyPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x;\n}\n\n// COLORMAP https://www.shadertoy.com/view/4dXXDX\n\nfloat segment(float edge0, float edge1, float x)\n{\n    return step(edge0,x) * (1.0-step(edge1,x));\n}\n\n\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\n\nvec3 ice(float t)\n{\n   return vec3(t, t, 1.0);\n}\n\nvec3 fire(float t)\n{\n    return mix( mix(vec3(1,1,1), vec3(1,1,0), t),\n                mix(vec3(1,1,0), vec3(1,0,0), t*t), t);\n}\n\nvec3 ice_and_fire(float t)\n{\n    return segment(0.0,0.5,t) * ice(2.0*(t-0.0)) +\n           segment(0.5,1.0,t) * fire(2.0*(t-0.5));\n}\n\n\n\n// for testing purpose, https://www.shadertoy.com/view/4dlczB\nvec3 blackbody(float t)\n{\n\tfloat Temp = t*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    // no-flow inside obstacle\n    float stateij = GetState(0,0);   \n    \n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0.25);\n        return;\n    }\n    \n    // show field\n    vec2 vit = GetVelocity(0,0); \n    float pres = GetPressure(0,0); \n    float heat = GetHeat(0,0); \n    float div = GetDivergence(0,0);\n    float vort = GetVorticity(0,0);\n    \n\n    if ( isKeyPressed(KEY_ONE)!=0.0 )\n    {\n        fragColor =vec4(hot(1.5*length(vit)),1);\n        return;\n    }\n    if ( isKeyPressed(KEY_TWO)!=0.0 )\n    {\n        fragColor =vec4(1.0-hot(0.0005*(pres+800.0)),1);\n        return;\n    }\n    if ( isKeyPressed(KEY_THREE)!=0.0 )\n    {\n        fragColor =vec4(1.0-hot(0.1*(div+5.0)),1);\n        return;\n    }\n    if ( isKeyPressed(KEY_FOUR)!=0.0 )\n    {\n        fragColor =vec4(1.0-hot(0.1*(vort+5.0)),1);\n        return;\n    }\n\n    fragColor = vec4(ice_and_fire(clamp(heat+0.5,0.01,0.99)),1);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set initial condition / reset / obstacle / advection / buoyancy\n\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetVorticity(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).z\n#define GetHeat(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).z\n\n#define GetVelocityUV(XY) texture( iChannel3, vec2(XY)).xy\n#define GetHeatUV(XY) texture( iChannel3, vec2(XY)).z\n\nfloat isKeyPressed(int key, int type)\n{\n\treturn texelFetch( iChannel1, ivec2(key, type), 0 ).x;\n}\n\nvec2 Euler(vec2 posUV){\n    vec2 AspectRatio = iResolution.xy/iResolution.y;\n    return dt*GetVelocityUV(posUV)/AspectRatio;\n}\n\nvec2 Runge(vec2 posUV){\n    vec2 AspectRatio = iResolution.xy/iResolution.y;\n    vec2 k1 = GetVelocityUV(posUV)/AspectRatio;\n    vec2 k2 = GetVelocityUV(posUV-0.5*k1*dt)/AspectRatio;\n    vec2 k3 = GetVelocityUV(posUV-0.5*k2*dt)/AspectRatio;\n    vec2 k4 = GetVelocityUV(posUV-k3*dt)/AspectRatio;\n    return dt/6.*(k1+2.0*k2+2.0*k3+k4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    \n    // initial condition\n    #ifdef PERTURBATION\n    float pert = sin(150.0*uvCoord.x);\n    #else\n    float pert = 0.0;\n    #endif\n    if (iFrame==0) {\n        fragColor = vec4(0);\n\t\t#ifdef TURBULENT\n        if((uvCoord.y <= 0.5+0.01*pert && uvCoord.y >= 0.25+0.01*pert)||\n          (uvCoord.y >= 0.75+0.01*pert))\n        {\n            fragColor = vec4(0,0,maxHeat,0);\n        }\n        if((uvCoord.y <= 0.75+0.01*pert && uvCoord.y >= 0.5+0.01*pert)||\n          (uvCoord.y <= 0.25+0.01*pert))\n        {\n            fragColor = vec4(0,0,-maxHeat,0);\n        }\n        \n        \n        if(ijCoord.x ==  int(iResolution.x)-1 || ijCoord.x == 0)\n        {\n            fragColor = vec4(0,0,0,1);\n        }\n        if(ijCoord.y <= plateWidth)\n        {\n            fragColor = vec4(0,0,obsHeat*maxHeat+pert,1);\n        }\n        if(ijCoord.y >=  int(iResolution.y)-1-plateWidth)\n        {\n            fragColor = vec4(0,0,-obsHeat*maxHeat+pert,1);\n        }\n        #endif\n        #ifdef BERNARDCELL\n        if(ijCoord.x ==  int(iResolution.x)-1 || ijCoord.x == 0)\n        {\n            fragColor = vec4(0,0,0,1);\n        }\n        if(ijCoord.y <= plateWidth)\n        {\n            fragColor = vec4(0,0,obsHeat,1);\n        }\n        if(ijCoord.y >=  int(iResolution.y)-1-plateWidth)\n        {\n            fragColor = vec4(0,0,-obsHeat,1);\n        }\n        #endif\n        return;\n    }\n    \n    // add sources with mouse\n    float c = obsHeat;\n    if ( isKeyPressed(KEY_C, 2)!=0.0 )\n    {\n        c = -obsHeat;\n    }\n    float obs = length((fragCoord.xy - iMouse.xy) / iResolution.y); \n    if(iMouse.w > 0.0 && obs < radiusObs) {\n        fragColor = vec4(0,0,c*maxHeat,1);\n        return;\n    }\n\n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,GetHeat(0,0),stateij);\n        return;\n    }\n    \n    // restet simulation keep obstacles\n    if ( isKeyPressed(KEY_SPACE,0)!=0.0 )\n    {\n        fragColor = vec4(0,0,0,stateij);\n        #ifdef TURBULENT\n        if((uvCoord.y <= 0.5+0.005*pert && uvCoord.y >= 0.25+0.005*pert)||\n          (uvCoord.y >= 0.75+0.005*pert))\n        {\n            fragColor = vec4(0,0,maxHeat,stateij);\n        }\n        if((uvCoord.y <= 0.75+0.005*pert && uvCoord.y >= 0.5+0.005*+pert)||\n          (uvCoord.y <= 0.25+0.005*pert))\n        {\n            fragColor = vec4(0,0,-maxHeat,stateij);\n        }\n        \n        \n        if(ijCoord.x ==  int(iResolution.x)-1 || ijCoord.x == 0)\n        {\n            fragColor = vec4(0,0,0,stateij);\n        }\n        if(ijCoord.y <= plateWidth)\n        {\n            fragColor = vec4(0,0,maxHeat+5.*abs(pert),stateij);\n        }\n        if(ijCoord.y >=  int(iResolution.y)-1-plateWidth)\n        {\n            fragColor = vec4(0,0,-maxHeat+5.*abs(pert),stateij);\n        }\n        #endif\n        #ifdef BERNARDCELL\n        if(ijCoord.x ==  int(iResolution.x)-1 || ijCoord.x == 0)\n        {\n            fragColor = vec4(0,0,0,1);\n        }\n        if(ijCoord.y <= plateWidth)\n        {\n            fragColor = vec4(0,0,maxHeat,stateij);\n        }\n        if(ijCoord.y >=  int(iResolution.y)-1-plateWidth)\n        {\n            fragColor = vec4(0,0,-maxHeat,stateij);\n        }\n        #endif\n        return;\n    }\n    \n    // advect via semi-lagrangian method\n    vec2 posUV =fragCoord/iResolution.xy;\n    #ifdef EULER\n    vec2 posAdvUV = posUV-Euler(posUV);\n    #endif\n    #ifdef RUNGE\n    vec2 posAdvUV = posUV-Runge(posUV);\n    #endif\n    vec2 vitAdv = GetVelocityUV(posAdvUV);\n    float heatAdv = GetHeatUV(posAdvUV);\n\n    \n    // vorticity confinement\n    //to compute density finite difference approximaton\n    \n    float vortij = GetVorticity(0,0); \n    float vortip1j = GetVorticity(1,0); \n    float vortim1j = GetVorticity(-1,0); \n    float vortijp1 = GetVorticity(0,1); \n    float vortijm1 = GetVorticity(0,-1);\n    \n    vec3 gradVort = vec3(vortip1j-vortim1j,vortijp1-vortijm1,0.0);\n    vec3 psi = gradVort / (length(gradVort) + 1e-8);\n    vec2 fv = cross(psi,vec3(0.0,0.0,vortij)).xy;\n    \n    vitAdv += epsilon*dt*dx*fv;\n    \n    // add buoyancy\n    vitAdv += dt*vec2(0.0,GetHeat(0,0));\n    \n    fragColor = vec4(vitAdv, heatAdv, 0); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// solve for diffusion\n\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n#define GetHeat(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).z\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    float stateip1j = GetState(1,0);\n    float stateim1j = GetState(-1,0);\n    float stateijp1 = GetState(0,1);\n    float stateijm1 = GetState(0,-1);    \n\n    vec2 vitij = GetVelocity(0,0); \n    float heatij = GetHeat(0,0); \n    \n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,heatij,0);\n        return;\n    }\n    \n    //to compute velocity finite difference approximaton\n    vec2 vitip1j = mix(GetVelocity(1,0),-vitij, stateip1j);\n    vec2 vitim1j = mix(GetVelocity(-1,0),-vitij, stateim1j);\n    vec2 vitijp1 = mix(GetVelocity(0,1),-vitij, stateijp1);\n    vec2 vitijm1 = mix(GetVelocity(0,-1),-vitij, stateijm1);\n    \n    //to compute density finite difference approximaton\n    float heatip1j = mix(GetHeat(1,0),2.0*GetHeat(1,0)-heatij, stateip1j);\n    float heatim1j = mix(GetHeat(-1,0),2.0*GetHeat(-1,0)-heatij, stateim1j);\n    float heatijp1 = mix(GetHeat(0,1),2.0*GetHeat(0,1)-heatij, stateijp1);\n    float heatijm1 = mix(GetHeat(0,-1),2.0*GetHeat(0,-1)-heatij, stateijm1);\n   \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    float coef = dt*coefMomentum/dxPow;\n    vec2 vitaux = (vitij+coef*(vitip1j+vitim1j+vitijp1+vitijm1))/(1.0+4.0*coef);\n \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    coef = dt*coefEnergy/(dxPow);\n    float heatDiff = (heatij+coef*(heatip1j+heatim1j+heatijp1+heatijm1))/(1.0+4.0*coef);\n \n    fragColor = vec4(vitaux,heatDiff,0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// solve for pressure\n\n\n//macro\n\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).w\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    float stateip1j = GetState(1,0);\n    float stateim1j = GetState(-1,0);\n    float stateijp1 = GetState(0,1);\n    float stateijm1 = GetState(0,-1);    \n\n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    //to compute velocity finite difference approximaton\n    vec2 vitauxij = GetVelocity(0,0); \n    vec2 vitauxip1j = mix(GetVelocity(1,0),-vitauxij, stateip1j);\n    vec2 vitauxim1j = mix(GetVelocity(-1,0),-vitauxij, stateim1j);\n    vec2 vitauxijp1 = mix(GetVelocity(0,1),-vitauxij, stateijp1);\n    vec2 vitauxijm1 = mix(GetVelocity(0,-1),-vitauxij, stateijm1);\n    \n    //to compute pressure finite difference approximaton\n    float presij = GetPressure(0,0); \n    float presip1j = mix(GetPressure(1,0),presij,stateip1j);\n    float presim1j = mix(GetPressure(-1,0),presij,stateim1j);\n    float presijp1 = mix(GetPressure(0,1),presij,stateijp1);\n    float presijm1 = mix(GetPressure(0,-1),presij,stateijm1);\n    \n    \n    \n    \n    // compute velocity divergence\n    float div = 0.5*(vitauxip1j.x-vitauxim1j.x+vitauxijp1.y-vitauxijm1.y)/dx;\n    float vort = 0.5*(vitauxijp1.y-vitauxim1j.y + vitauxijp1.x-vitauxijm1.x)/dx;\n    // should use more than 1 iteration...\n    // compute pressure (auxiliary) via jacobi iteration... \n    float presDiff = 0.25*((presip1j+presim1j)+(presijp1+presijm1)-dxPow*div/(coefMomentum*dt));\n        \n    fragColor = vec4(presDiff, div, vort,0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// project for incompressibility\n\n\n//macro\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetHeat(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).z\n\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n#define GetDivergence(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).y\n\nfloat pres(float coef, ivec2 ijCoord,int i, int j){\n    \n    \n    float stateip1j = GetState(i+1,j);\n    float stateim1j = GetState(i-1,j);\n    float stateijp1 = GetState(i,j+1);\n    float stateijm1 = GetState(i,j-1);    \n    \n    \n    float div = GetDivergence(i,j); \n    float presij = GetPressure(i,j); \n    \n    \n    float presip1j = mix(GetPressure(i+1,j),presij,stateip1j);\n    float presim1j = mix(GetPressure(i-1,j),presij,stateim1j);\n    float presijp1 = mix(GetPressure(i,j+1),presij,stateijp1);\n    float presijm1 = mix(GetPressure(i,j-1),presij,stateijm1);\n    \n// set outer boundary conditions\n    if(ijCoord.x >=  int(iResolution.x)-1)\n    {\n        presip1j = presij;\n    }\n    if(ijCoord.x <= 0)\n    {\n        presim1j = -presij;\n    }\n    if(ijCoord.y >=  int(iResolution.y)-1)\n    {\n        presijp1 = presij;\n    }\n    \n    if(ijCoord.y <= 0)\n    {\n        presijm1 = presij;\n    }\n    \n    return 0.25*((presip1j+presim1j)+(presijp1+presijm1)-coef*div);\n}\n\n\n\nfloat pres2(float coef, ivec2 ijCoord,int i, int j){\n    float div = GetDivergence(i,j); \n    float presij = pres(coef, ijCoord, i,j);\n    float presip1j = pres(coef, ijCoord, i+1,j);\n    float presim1j = pres(coef, ijCoord, i-1,j);\n    float presijp1 = pres(coef, ijCoord, i,j+1);\n    float presijm1 = pres(coef, ijCoord, i,j-1);\n    \n\n\n    return 0.25*((presip1j+presim1j)+(presijp1+presijm1)-coef*div);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    float coef = dxPow/(coefMomentum*dt);\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    float stateip1j = GetState(1,0);\n    float stateim1j = GetState(-1,0);\n    float stateijp1 = GetState(0,1);\n    float stateijm1 = GetState(0,-1);    \n\n    vec2 vitauxij = GetVelocity(0,0); \n    float heat = GetHeat(0,0);\n    \n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,heat,0);\n        return;\n    }\n    \n    //to compute pressure finite difference approximaton\n    float presij = pres2(coef, ijCoord, 0,0);\n    float presip1j = pres(coef, ijCoord, 1,0);\n    float presim1j = pres(coef, ijCoord, -1,0);\n    float presijp1 = pres(coef, ijCoord, 0,1);\n    float presijm1 = pres(coef, ijCoord, 0,-1);\n    \n    \n    //compute gradiant of pressure\n    vec2 presGrad = 0.5*vec2(presip1j-presim1j, presijp1-presijm1)/dx;\n    \n    //projection (helmholtz-hodge) to obtain divergence free\n    vec2 vit = vitauxij-dt*coefMomentum*presGrad;\n    \n    \n    \n    fragColor = vec4(vit, heat, presij);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// press\n// 1 - show velocity field\n// 2 - show pressure field\n// 3 - show divergence field\n// 4 - show vorticity field\n// left click - add cold source\n// spacebar - reset field keep sources\n// toogle\n// c - change source to hot, c again to cold....\n\n\n// start with perturbation, accelerate the start\n#define PERTURBATION\n\n// Choose for different simulation \n//#define BERNARDCELL\n#define TURBULENT\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// radius of obstacle \n#define radiusObs 0.01\n//#define radiusObs 0.03\n//#define radiusObs 0.05\n\n\n\n\n#ifdef BERNARDCELL\nconst float epsilon = 0.0;\n// simulation parameters\nconst float dt = 1.0/100.0; //time-stepping (small add a lot of shock/ lose incompressibility)\n\n//The Rayleigh number is defined as the product of the Grashof number, \n//which describes the relationship between buoyancy and viscosity within a \n//fluid, and the Prandtl number, which describes the relationship between \n//momentum diffusivity and thermal diffusivity.\nconst float rayleigh = pow(10.0,10.0); // low  - heat transfer is primarily in the form of conduction. \n\t\t\t\t\t\t\t\t\t   // really high - heat transfer is primarily in the form of convection.\nconst float prandtl = pow(10.0,0.0);   // really low - thermal diffusivity dominates the behavior.\n\t\t\t\t\t\t\t\t\t   //high - momentum diffusivity dominates the behavior.\n\nconst float coefMomentum = sqrt(prandtl/rayleigh);\nconst float coefEnergy = 1.0/sqrt(prandtl*rayleigh);\n    \nconst float maxHeat = 1.; //2.0*maxHeat max adim heat value\n\nconst float obsHeat = 0.5;\nconst int plateWidth = 160; // add width to plate above and bellow\n\n#endif\n#ifdef TURBULENT\nconst float epsilon = 1.0;\nconst float dt = 1.0/1000.0; //time-stepping (small add a lot of shock/ lose incompressibility)\n\n//The Rayleigh number is defined as the product of the Grashof number, \n//which describes the relationship between buoyancy and viscosity within a \n//fluid, and the Prandtl number, which describes the relationship between \n//momentum diffusivity and thermal diffusivity.\nconst float rayleigh = pow(10.0,10.0); // low  - heat transfer is primarily in the form of conduction. \n\t\t\t\t\t\t\t\t\t   // really high - heat transfer is primarily in the form of convection.\nconst float prandtl = pow(10.0,-1.);   // really low - thermal diffusivity dominates the behavior.\n\t\t\t\t\t\t\t\t\t   //high - momentum diffusivity dominates the behavior.\n\nconst float coefMomentum = sqrt(prandtl/rayleigh);\nconst float coefEnergy = 1.0/sqrt(prandtl*rayleigh);\n    \nconst float maxHeat = 1.0; //2.0*maxHeat max adim heat value\n\nconst float obsHeat = 10.;\n\nconst int plateWidth = 10; // add width to plate above and bellow\n#endif\n\n\n\n\nconst int KEY_ONE  = 49;\nconst int KEY_TWO  = 50;\nconst int KEY_THREE  = 51;\nconst int KEY_FOUR  = 52;\nconst int KEY_FIVE  = 53;\n\nconst int KEY_SPACE  = 32;\nconst int KEY_C  = 67;\n","name":"Common","description":"","type":"common"}]}