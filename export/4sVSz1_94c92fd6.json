{"ver":"0.1","info":{"id":"4sVSz1","date":"1463020452","viewed":564,"name":"lattice boltzman investigation","username":"ghidra","description":"all credit goes to: ndel lbm2 from https://www.shadertoy.com/view/4dK3zG\nI've wanted to play with a lbm, use ndel made a great working example. I wanted to try and advect an image with the velocities from the simulation.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["test","wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fancy function to compute a color from the velocity\nvec4 computeColor(float normal_value)\n{\n    vec3 color;\n    if(normal_value<0.0) normal_value = 0.0;\n    if(normal_value>1.0) normal_value = 1.0;\n    float v1 = 1.0/7.0;\n    float v2 = 2.0/7.0;\n    float v3 = 3.0/7.0;\n    float v4 = 4.0/7.0;\n    float v5 = 5.0/7.0;\n    float v6 = 6.0/7.0;\n    //compute color\n    if(normal_value<v1)\n    {\n      float c = normal_value/v1;\n      color.x = 70.*(1.-c);\n      color.y = 70.*(1.-c);\n      color.z = 219.*(1.-c) + 91.*c;\n    }\n    else if(normal_value<v2)\n    {\n      float c = (normal_value-v1)/(v2-v1);\n      color.x = 0.;\n      color.y = 255.*c;\n      color.z = 91.*(1.-c) + 255.*c;\n    }\n    else if(normal_value<v3)\n    {\n      float c = (normal_value-v2)/(v3-v2);\n      color.x =  0.*c;\n      color.y = 255.*(1.-c) + 128.*c;\n      color.z = 255.*(1.-c) + 0.*c;\n    }\n    else if(normal_value<v4)\n    {\n      float c = (normal_value-v3)/(v4-v3);\n      color.x = 255.*c;\n      color.y = 128.*(1.-c) + 255.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v5)\n    {\n      float c = (normal_value-v4)/(v5-v4);\n      color.x = 255.*(1.-c) + 255.*c;\n      color.y = 255.*(1.-c) + 96.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v6)\n    {\n      float c = (normal_value-v5)/(v6-v5);\n      color.x = 255.*(1.-c) + 107.*c;\n      color.y = 96.*(1.-c);\n      color.z = 0.;\n    }\n    else\n    {\n      float c = (normal_value-v6)/(1.-v6);\n      color.x = 107.*(1.-c) + 223.*c;\n      color.y = 77.*c;\n      color.z = 77.*c;\n    }\n    return vec4(color.r/255.0,color.g/255.0,color.b/255.0,1.0);\n}\n#define B\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec3 m = texture(iChannel0, fragCoord.xy / iResolution.xy ).xyz;\n    #ifdef A\n    vec2 dir = vec2(m.yz);\n    float mag = length(dir);\n\n    dir=(normalize(dir));\n    dir-=vec2(0.5,0.5);\n    vec3 col = vec3(dir,mag);//vec3(dir.x-.5)*(1.-float(m.x>0.5));\n    fragColor=vec4(col,1.0);\n    #else\n    fragColor=vec4(m,1.0);\n    #endif\n    \n}\n\nvoid mainImage_V( out vec4 fragColor, in vec2 fragCoord )\n{\n    //only one pixel out of 4 stores the moments\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    vec3 m = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).xyz;\n    //vec3 d = texture(iChannel0, (vec2(2*ix,2*iy)+0.5)/iResolution.xy).xyz;\n    float solid = m.x;\n    float vx  = m.y;\n    float vy  = m.z;\n    float U = sqrt(vx*vx+vy*vy);\n    //fragColor = vec4(vec3(vy*10.0),1.0);\n    fragColor = computeColor(U/0.2);\n    if(solid > 0.5)\n        fragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ALL CREDIT TO NDEL https://www.shadertoy.com/view/4dK3zG\n\n//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n#define solid(x,y) texture(iChannel0, (vec2(2*x+1,2*y+1)+0.5)/iResolution.xy).r;\n\n//channel velocity\n#define VEL 0.1\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //relaxation time\n    float w = 1.95;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //4 texels per voxel\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    float solid=solid(ix,iy);\n    f0 = f0(ix,iy);\n    \n    vec2 center = iResolution.xy/2.0;\n    vec2 dir = normalize(fragCoord.xy-center);\n    \n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        \n        vx = VEL*dir.x;\n        vy = VEL*dir.y;\n        \n        //vx  = VEL*(1.0+0.1*fragCoord.y/iResolution.y);\n        //vy  = 0.0;\n        \n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        f0 = 4./9. *rho*(1. + sq_term);\n        f1 = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        f2 = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        f3 = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        f4 = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        f5 = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f6 = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f7 = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        f8 = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //add a small disk near the entrance\n        if( distance(vec2(50.0,LatSizeY/2),vec2(ix,iy)) < 10.0 )\n            solid = 1.0;\n        else\n            solid = 0.0;\n        \n        for(int i=0; i<1028; i++)\n        {\n        \thighp float px = rand(vec2(0.23,0.44)*float(i));\n            highp float py = rand(vec2(0.81,0.19)*float(i));\n            if( distance(vec2(px,py)*iResolution.xy,vec2(ix,iy)) < 1.0 )\n            \tsolid = 1.0;\n            \n        }\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        //velocity cap for stability\n        float norm = sqrt(vx*vx+vy*vy);\n        if(norm>0.2)\n        {\n            vx *= 0.2/norm;\n            vy *= 0.2/norm;\n        }\n        if(ix==0||ix==LatSizeX-1 || iy==0 || iy==LatSizeY-1)//boundary condition\n        {\n            rho = 1.0;\n            \n            \n        \tvx = VEL*dir.x;\n        \tvy = VEL*dir.y;\n            //vx = VEL;\n            //vy = 0.0;\n            w = 1.0;\n        }\n        if( iMouse.w>0.01 && distance(iMouse.xy/2.0,vec2(ix,iy)) < 2.0)\n            solid = 1.0;\n        if( solid>0.5 )\n        {\n            rho = 1.0;\n            vx  = 0.0;\n            vy  = 0.0;\n            w = 1.0;\n        }\n\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        float f0eq = 4./9. *rho*(1. + sq_term);\n        float f1eq = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f2eq = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f3eq = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f4eq = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f5eq = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f6eq = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f7eq = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        float f8eq = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = (1.-w) * f0 + w * f0eq;\n        f1 = (1.-w) * f1 + w * f1eq;\n        f2 = (1.-w) * f2 + w * f2eq;\n        f3 = (1.-w) * f3 + w * f3eq;\n        f4 = (1.-w) * f4 + w * f4eq;\n        f5 = (1.-w) * f5 + w * f5eq;\n        f6 = (1.-w) * f6 + w * f6eq;\n        f7 = (1.-w) * f7 + w * f7eq;\n        f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(solid,vx,vy);\n\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//ALL CREDIT TO NDEL https://www.shadertoy.com/view/4dK3zG\n\n//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n#define solid(x,y) texture(iChannel0, (vec2(2*x+1,2*y+1)+0.5)/iResolution.xy).r;\n\n//channel velocity\n#define VEL 0.1\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //relaxation time\n    float w = 1.95;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //4 texels per voxel\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    float solid=solid(ix,iy);\n    f0 = f0(ix,iy);\n    \n    vec2 center = iResolution.xy/2.0;\n    vec2 dir = normalize(fragCoord.xy-center);\n    \n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        \n        vx = VEL*dir.x;\n        vy = VEL*dir.y;\n        \n        //vx  = VEL*(1.0+0.1*fragCoord.y/iResolution.y);\n        //vy  = 0.0;\n        \n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        f0 = 4./9. *rho*(1. + sq_term);\n        f1 = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        f2 = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        f3 = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        f4 = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        f5 = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f6 = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f7 = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        f8 = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //add a small disk near the entrance\n        if( distance(vec2(50.0,LatSizeY/2),vec2(ix,iy)) < 10.0 )\n            solid = 1.0;\n        else\n            solid = 0.0;\n        \n        for(int i=0; i<1028; i++)\n        {\n        \thighp float px = rand(vec2(0.23,0.44)*float(i));\n            highp float py = rand(vec2(0.81,0.19)*float(i));\n            if( distance(vec2(px,py)*iResolution.xy,vec2(ix,iy)) < 1.0 )\n            \tsolid = 1.0;\n            \n        }\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        //velocity cap for stability\n        float norm = sqrt(vx*vx+vy*vy);\n        if(norm>0.2)\n        {\n            vx *= 0.2/norm;\n            vy *= 0.2/norm;\n        }\n        if(ix==0||ix==LatSizeX-1 || iy==0 || iy==LatSizeY-1)//boundary condition\n        {\n            rho = 1.0;\n            \n            \n        \tvx = VEL*dir.x;\n        \tvy = VEL*dir.y;\n            //vx = VEL;\n            //vy = 0.0;\n            w = 1.0;\n        }\n        if( iMouse.w>0.01 && distance(iMouse.xy/2.0,vec2(ix,iy)) < 2.0)\n            solid = 1.0;\n        if( solid>0.5 )\n        {\n            rho = 1.0;\n            vx  = 0.0;\n            vy  = 0.0;\n            w = 1.0;\n        }\n\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        float f0eq = 4./9. *rho*(1. + sq_term);\n        float f1eq = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f2eq = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f3eq = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f4eq = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f5eq = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f6eq = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f7eq = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        float f8eq = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = (1.-w) * f0 + w * f0eq;\n        f1 = (1.-w) * f1 + w * f1eq;\n        f2 = (1.-w) * f2 + w * f2eq;\n        f3 = (1.-w) * f3 + w * f3eq;\n        f4 = (1.-w) * f4 + w * f4eq;\n        f5 = (1.-w) * f5 + w * f5eq;\n        f6 = (1.-w) * f6 + w * f6eq;\n        f7 = (1.-w) * f7 + w * f7eq;\n        f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(solid,vx,vy);\n\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Uncomment IMG define to use the image in channel2 \n\n#define VEL 0.025\n//#define IMG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = vec2(fragCoord.xy / iResolution.xy);\n    if( iFrame==0) //initialisation\n    {\n        #ifdef IMG\n        \tvec3 im = texture(iChannel2, u ).xyz;\n        \tfragColor = vec4(im,1.0);\n        #else\n        \tfragColor = vec4(u,0.0,1.0);\n        #endif\n    }\n    else\n    {\n        int ix = int(floor(fragCoord.x/2.0));\n    \tint iy = int(floor(fragCoord.y/2.0));\n    \tvec2 sam = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).yz;\n        float solid = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).x;\n        \n        //vec2 sam = texture(iChannel0, u ).yz;\n        \n        vec2 dir=(normalize(sam));\n        //dir -= vec2(0.5,0.5);\n        \n        vec3 col = texture(iChannel1, u-((dir*length(sam))*VEL) ).xyz;\n        if(solid>0.5)\n            #ifdef IMG\n            \tcol=texture(iChannel2, u ).xyz;\n        \t#else\n                col=vec3(u,0.0);\n        \t#endif\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Uncomment IMG define to use the image in channel2 \n\n#define VEL 0.025\n//#define IMG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = vec2(fragCoord.xy / iResolution.xy);\n    if( iFrame==0) //initialisation\n    {\n        #ifdef IMG\n        \tvec3 im = texture(iChannel2, u ).xyz;\n        \tfragColor = vec4(im,1.0);\n        #else\n        \tfragColor = vec4(u,0.0,1.0);\n        #endif\n    }\n    else\n    {\n        int ix = int(floor(fragCoord.x/2.0));\n    \tint iy = int(floor(fragCoord.y/2.0));\n    \tvec2 sam = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).yz;\n        float solid = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).x;\n        \n        //vec2 sam = texture(iChannel0, u ).yz;\n        \n        vec2 dir=(normalize(sam));\n        //dir -= vec2(0.5,0.5);\n        \n        vec3 col = texture(iChannel1, u-((dir*length(sam))*VEL) ).xyz;\n        if(solid>0.5)\n            #ifdef IMG\n            \tcol=texture(iChannel2, u ).xyz;\n        \t#else\n                col=vec3(u,0.0);\n        \t#endif\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Buf D","description":"","type":"buffer"}]}