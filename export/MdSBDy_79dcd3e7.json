{"ver":"0.1","info":{"id":"MdSBDy","date":"1502215604","viewed":219,"name":"AO Scene Test","username":"yumcyawiz","description":".","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat DF(vec3 p) {\n    float d = sdSphere(p - vec3(2, sin(iTime) + 1.0, 0), 1.0);\n    d = min(d, sdSphere(p - vec3(-2, sin(iTime) + 1.0, 0), 1.0));\n    d = min(d, sdSphere(p - vec3(0, -10001, 0), 10000.0));\n    d = min(d, sdSphere(p - vec3(-10005, 0, 0), 10000.0));\n    d = min(d, sdSphere(p - vec3(10005, 0, 0), 10000.0));\n    d = min(d, sdSphere(p - vec3(0, 0, 10005), 10000.0));\n    d = min(d, sdSphere(p - vec3(0, 10005, 0), 10000.0));\n    return d;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        DF(p + vec3(eps, 0, 0)) - DF(p + vec3(-eps, 0, 0)),\n        DF(p + vec3(0, eps, 0)) - DF(p + vec3(0, -eps, 0)),\n        DF(p + vec3(0, 0, eps)) - DF(p + vec3(0, 0, -eps))\n    ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n};\nconst int maxSteps = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float t = 0.1;\n    for(int i = 0; i < maxSteps; i++) {\n        vec3 p = from + t*rayDir;\n        float d = DF(p);\n        if(d < 0.01) {\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            break;\n        }\n        t += d;\n    }\n    return Ray(hit, hitPos, hitNormal, steps, t);\n}\n\n\nfloat detailedAO(vec3 hitPos, vec3 hitNormal, float k) {\n    float ao = 0.0;\n    for(int i = 1; i <= 5; i++) {\n        float d1 = float(i)/float(5) * k;\n        vec3 p = hitPos + d1*hitNormal;\n        ao += 1.0/pow(2.0, float(i)) * (d1 - DF(p));\n    }\n    return 1.0 - clamp(ao, 0.0, 1.0);\n}\nfloat detailedAO2(vec3 hitPos, float k) {\n    float ao = 0.0;\n    vec3 p = hitPos;\n    for(int i = 1; i <= 5; i++) {\n        p += calcNormal(p) * k;\n        ao += 1.0/pow(2.0, float(i)) * (distance(hitPos, p) - DF(p));\n    }\n    return 1.0 - clamp(ao, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 camPos = vec3(0, 1, -5);\n    vec3 camFront = vec3(0, 0, 1);\n    vec3 camRight = cross(vec3(0, 1, 0), camFront);\n    vec3 camUp = cross(camFront, camRight);\n    vec3 rayDir = normalize(1.5*camFront + uv.x*camRight + uv.y*camUp);\n    \n    Ray tr = trace(camPos, rayDir);\n    vec3 color = vec3(0);\n    if(tr.hit) {\n        float sAO = 1.0 - float(tr.steps)/float(maxSteps);\n        float dAO = detailedAO(tr.hitPos, tr.hitNormal, 1.0);\n        float dAO2 = detailedAO2(tr.hitPos, 0.3);\n        if(fragCoord.x < iResolution.x/2.0) {\n        \tcolor = sAO * vec3(1);\n        }\n        else {\n            color = dAO * vec3(1);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}