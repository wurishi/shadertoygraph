{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// CONFIGURATION\n\n// function sampling range\nvec2 xRange = vec2(-3.14, 3.14);\n// if true, shader will attempt scaling the plot on the Y axis automatically; if false, yRange is used\nconst bool autoYScaling = true;\n// drawn range of the Y axis\nvec2 yRange = vec2(-3.0, 3.0);\n// if true, plot can be padded using the mouse\nconst bool mousePadding = false;\n\n// colours\nconst vec3 background = vec3(1.0, 1.0, 1.0);\nconst vec3 functionHot = vec3(1.0, 0.0, 0.0);\nconst vec3 functionCold = vec3(0.0, 0.0, 1.0);\nconst vec3 axes = vec3(0.0, 0.0, 0.0);\n\n// function plot line thickness in pixels\nconst float thickness = 1.9;\n// function plot-following dot thickness in pixels\nconst float dotThickness = 4.5;\n\n// function to sample\nfloat f(float x)\n{\n\treturn sin(x);\n\treturn 0.5 * x;\n\t//return 0.75 * x * x - 2.0;\n}\n\n\n\n// IMPLEMENTATION\n\n// @return\tA vec2 containing a min (.x) and max (.y) values of the function computed via linear sampling.\nvec2 autoscale()\n{\n\tconst int xRes = 100;\t// FIXME: how to make this rely on iResolution.x?\n\tvec2 range = vec2(0.0);\n\tfloat x, y;\n\tfor (int i = 0; i < xRes; ++i)\n\t{\n\t\tx = xRange.x + (xRange.y - xRange.x) * (float(i) / float(xRes - 1));\n\t\ty = f(x);\n\t\trange.x = min(y, range.x);\n\t\trange.y = max(y, range.y);\n\t}\n\t// expand the range by a bit pixels for improved readability\n\treturn range * vec2(1.05);\n}\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real)\n{\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real)\n{\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius)\n{\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 actualYRange = (autoYScaling) ? autoscale() : yRange;\n\t\n\t// allow padding the plot with the mouse\n\tif (mousePadding)\n\t{\n\t\txRange -= 5.0 * (iMouse.xx / (iResolution.x) - 0.5);\n\t\tactualYRange -= 5.0 * (iMouse.yy / (iResolution.y) - 0.5);\n\t}\n\t\n\tfloat x = xRange.x + (xRange.y - xRange.x) * (fragCoord.x / iResolution.x);\n\tfloat y = f(x);\n\t\n\tfloat actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n\t\n\t// plot dot :)\n\tfloat dotX = xRange.x + fract(iTime) * (xRange.y - xRange.x);\n\t// function heat\n\tfloat heat = (x - dotX) / (xRange.y - xRange.x);\n\tif (heat < 0.0)\n\t\theat += 1.0;\n\tvec3 funcColour = mix(functionCold, functionHot, heat);\n\t// plot colour\n\tfloat distY = abs(y - actualY);\n\tvec4 plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n\t// plot dot, continued\n\tfloat distX = abs(x - dotX);\n\tfloat dist = sqrt(distY * distY + distX * distX);\n\t// composition\n\tplot = mix(plot, vec4(functionHot, 1.0), coverage(realYToPixels(dist), dotThickness));\n\t\n\t// axis colour\n\tvec4 xAxis = vec4(axes, coverage(realXToPixels(abs(x)), thickness));\n\tvec4 yAxis = vec4(axes, coverage(realYToPixels(abs(actualY)), thickness));\n\tvec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(vec4(1.0), foreground, foreground.a);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d23Rm","date":"1385319115","viewed":2114,"name":"2D function plotter","username":"inequation","description":"A 2D function plotter doodle. A dot follows the plot, \"heatening\" it.\n\nChange the mousePadding variable to use the mouse to pad the plot.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","function","plotter"],"hasliked":0,"parentid":"","parentname":""}}