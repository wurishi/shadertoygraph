{"ver":"0.1","info":{"id":"lXfXWS","date":"1709951269","viewed":66,"name":"Rift portal test (cage deform)","username":"DenZ33","description":"Anomaly Rift in space-time\n\nCan be used for 3d games (portals, distortion, etc) at postprocessing stage\nAnother world or dimension can be rendered inside rift using mask\nCage mesh can be projected from 3d world","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["deform","space","portal","rift","dimensions","anomaly"],"hasliked":0,"parentid":"MXfSzs","parentname":"Rift test"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nbool PointInTriangleBarycentric(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    mat3 Barycentric = inverse(\n        mat3(\n    \t\tTriangle[0], 1.0f,\n        \tTriangle[1], 1.0f,\n        \tTriangle[2], 1.0f\n    \t)\n    );\n\n    vec3 Weights = Barycentric * vec3( Point, 1.0f);\n\n    if(\n        all( greaterThanEqual( Weights, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nfloat minimum_distance(vec2 v, vec2 w, vec2 p) {\n  // Return minimum distance between line segment vw and point p\n  float l2 = pow(length(v - w),2.);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  // We clamp t from [0,1] to handle points outside the segment vw.\n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n\nfloat posOnLine(vec2 v, vec2 w, vec2 p) {\n  float l2 = pow(length(v - w),2.);\n  if (l2 == 0.0) return 0.;\n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  return t;\n}\n\n\nvec4 genSegment(vec2 p0, vec2 p1, vec2 p, float k){\n    float tt = posOnLine(p0, p1, p);\n    vec2 pl = mix(p0,p1,tt);\n    return vec4(distance(pl,p), tt, pl);\n}\n\n\nvec2 getPoint(float fi){\n    return vec2(0.5+sin(fi*0.3+iTime*1.0)*0.12, fi/20.+0.0);\n}\n\n\nvec3 wDisplacement(vec2 pos){\n    vec2 accdelta = vec2(0.0,0.0);\n    float accw = 0.0;\n    float mask = 0.0;\n    \n    //deform\n    for(int i = 0; i < 16; i++){\n        float fi = float(i);\n        float fi1 = float(i+1);\n        \n        float kk = 8.0 - abs(fi-8.0);\n        kk = pow(kk/8.0,2.);\n        \n        vec2 restPos = getPoint(fi);\n        vec2 restPos1 = getPoint(fi1);\n        \n        vec2 restNorm = restPos - restPos1;\n        restNorm = normalize(vec2(-restNorm.y,restNorm.x));\n        \n        vec4 segm = genSegment(restPos, restPos1, pos, 0.0);\n        \n        vec2 dirVect =  normalize(pos - segm.zw);\n        \n        float rwidth = (sin(iTime*0.25)*0.25+0.25)*kk;\n        \n        vec2 deltaPos = vec2(0.0,0.0) + dirVect * rwidth;\n \n        float restW = 1.0/segm.x;\n        restW = pow(restW, 2.0);\n        \n        accw += restW;\n        accdelta += deltaPos*restW;\n    }\n    \n    vec2 transformDelta = accdelta/(accw+0.0); \n    \n    //mask\n    for(int i = 0; i < 16; i++){\n        float fi = float(i);\n        float fi1 = float(i+1);\n        \n        vec2 restPos1 = getPoint(fi);\n        vec2 restPos2 = getPoint(fi1);\n        \n        //float lineCap0 = i == 0 ? 0.0 : 1.0;\n        //float lineCap1 = i == 15? 0.0 : 1.0;\n      \n        //float A = restPos2.y - restPos1.y;\n        //float B = restPos1.x - restPos2.x;\n        //float C = restPos2.x*restPos1.y - restPos1.x*restPos2.y;\n        \n        vec2 newPos = pos - transformDelta;\n        \n        //float pp = posOnLine(restPos1,restPos2,newPos);\n        //float pp2 = posOnLine(restPos1,restPos2,pos);\n        \n        vec2 triangle[3];\n        triangle[0] = restPos1;\n        triangle[1] = restPos2;\n        triangle[2] = restPos1-transformDelta;\n        \n        bool tst = PointInTriangleBarycentric(triangle, newPos);\n        triangle[0] = restPos2-transformDelta;\n        \n        tst =  tst || PointInTriangleBarycentric(triangle, newPos);\n        \n        //float D1 = A*pos.x + B*pos.y + C;\n        //float D2 = A*newPos.x + B*newPos.y + C;\n\n        //if(D1*D2 < 0. && (pp > 0.0 && pp < 1.0 || pp2 > 0.0 && pp2 < 1.0)){\n        //    mark = 1.0;\n        //}\n        if(tst){\n            mask = 1.0;\n        }\n    }\n    \n    \n    return vec3(transformDelta, mask);\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*vec2(iResolution.x/iResolution.y,1.0);\n    vec3 displacement = wDisplacement(uv);\n    \n    vec2 newUV = (uv) - displacement.xy;\n    \n\n    vec3 col = texture(iChannel0,newUV).rgb;\n    \n    if(displacement.z > 0.){\n        //col = vec3(0.0); //inside rift\n        col = texture(iChannel1,uv).rgb;\n    }\n    \n    \n    \n    //edge & points\n    float mdist = 10.; // distance to edge\n    \n    for(int i = 0; i <16; i++){\n        float fi = float(i);\n        float fi1 = float(i+1);\n\n        vec2 restPos = getPoint(fi);\n        vec2 restPos1 = getPoint(fi1);\n        \n        float d = distance(newUV, restPos);\n        float d2 = distance(uv, restPos);\n        \n        float t = posOnLine(restPos, restPos1, newUV);\n        \n        float d3 = distance(newUV, mix(restPos, restPos1, t)); \n        mdist = min(mdist, d3);\n        \n        //if(d < 0.005)  col = vec3(0.0,1.0,0.0);\n        if(d2 < 0.005)  col = vec3(1.0,0.0,0.0);\n        //if(d3 < 0.005) col=vec3(d3*200.);\n    }\n    \n    //edge\n    float factor = 1.0-clamp(mdist*10.0/(sin(iTime*0.25)*0.125+0.125), 0.0,1.0);\n    vec3 border = vec3(sin(factor*100.))*factor;\n    \n    col = mix(col, border,factor);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}