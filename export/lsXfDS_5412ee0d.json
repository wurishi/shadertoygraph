{"ver":"0.1","info":{"id":"lsXfDS","date":"1498189269","viewed":154,"name":"Is this 4D?","username":"VoidChicken","description":"An attempt to do 4D projection. Probably messed up.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["projection","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 proj4(vec4 V) {\n    vec4 L = vec4(0,0,0,sqrt(2.));\n    vec4 nv = normalize(V-L);\n    return (L+nv*(2./nv.w)).xyz;\n}\nfloat FOV = 100.; //60 degrees FOV\nconst float pi = acos(-1.);\nvec2 project( vec3 p ) {\n    float RAD = FOV/360.*pi;\n    float DVN = p.z;\n    return p.xy/((tan(RAD/2.))*DVN)+.5;\n}\nfloat line ( vec2 p, vec2 a, vec2 b, float r ) {\n\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 ac = abs( pa - ba*h );\n    return ac.x+ac.y - r;\n    \n}\nfloat lp(vec2 p, vec2 a, vec2 b) {\n\tfloat xP = (p.x-min(a.x,b.x));\n    float xFP = xP/abs(a.x-b.x);\n    float yP = (p.y-min(a.y,b.y));\n    float yFP = yP/abs(a.y-b.y);\n    return xFP>yFP?xP:yP;\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nmat3 rmx(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n              );\n}\nmat4 rm(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, 0.,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,         0.,\n              0.,                                 0.                               ,           0.,                      1.    );\n}\nvec4 shpe[16];\nvec3 poly[16];\nvec2 proj[16];\nvoid polyShape() {\n\tshpe[0]=vec4(-1, -1, -1,0);\n    shpe[1]=vec4(1, -1, -1,0);\n    shpe[2]=vec4(1, 1, -1,0);\n    shpe[3]=vec4(-1,1,-1,0);  \n\tshpe[4]=vec4(-1, -1, 1,0);\n    shpe[5]=vec4(1, -1, 1,0);\n    shpe[6]=vec4(1, 1, 1,0);\n    shpe[7]=vec4(-1,1,1,0);   \n\tshpe[8]=vec4(-1, -1, -1,1);\n    shpe[9]=vec4(1, -1, -1,1);\n    shpe[10]=vec4(1, 1, -1,1);\n    shpe[11]=vec4(-1,1,-1,1);  \n\tshpe[12]=vec4(-1, -1, 1,1);\n    shpe[13]=vec4(1, -1, 1,1);\n    shpe[14]=vec4(1, 1, 1,1);\n    shpe[15]=vec4(-1,1,1,1);    \n    for (int x = 0; x < 16; x++) {\n        vec4 point = shpe[x]*rm(vec3(0,1,0),iTime);\n        poly[x]=proj4(point);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    polyShape();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float df = 5000000.;\n    for (int i = 0; i < 16; i++) {\n    \tproj[i]=project(poly[i]+vec3(0,0,55));    \n    }\n    float lv = 0.;\n    int pt = 0;\n    for (int i = 0; i < 16; i++) {\n        /*for (int n = 0; n < 8; n++) {\n        vec2 nv =  proj[n];\n     \t  \n    \t\tdf=min(df,line(uv, proj[i],nv, .002)); \n        \tlv=lp(uv,proj[i],nv);\n    \t}*/\n        float ndf = length(proj[i]-uv)-1./10000.;\n        if (ndf<df)pt=i;\n        df=min(ndf,df);\n    }\n\n    vec3 c = vec3(0);\n    if (df<.02) {\n     \tvec3 ct = hsv2rgb(vec3(lv,1,1));\n        c=(pt<8?vec3(1,0,0):vec3(0,1,1));//pow(1.-df/.02,15.)*ct;\n        c-=1.-pow(1.-df/.02,5.);\n    }\n    \n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}