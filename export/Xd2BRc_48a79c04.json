{"ver":"0.1","info":{"id":"Xd2BRc","date":"1501474146","viewed":1268,"name":"Candle Flame","username":"scarletshark","description":"This is a quick port of one of my Unity3D cg shaders for WebGL.  I was shooting for a mix between realism and a 2D stylized look, inspired by the amazing flame animations from Zelda: Breath of the Wild.  Also added background lighting for some mood.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","flame","fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Procedural Candle Flame by scarletshark - www.barr.codes\n\nconst float pi = 3.14;\nconst float flameEdgeWidth = 0.1;\nconst float flameThinningFactor = 6.0;\nconst float flameRampCenter = 0.15;\nconst float flameBrightness = 2.25;\nconst float bgVignetteSize = 1.3;\nconst float bgJitterSpeed = 0.15;\nconst float bgJitterPower = 0.16;\nconst vec2 center = vec2(0.5, 0.5);\nconst vec2 bgOffset = vec2(0, -0.1);\nconst vec4 flameEdgeColor = vec4(0, 0.8, 1, 1);\n\nconst vec4[2] bgColors = vec4[2]\n(\n\tvec4(0, 0, 0.05,1),\n    vec4(0.35, 0.21, 0.15, 1)\n);\n\nconst float[2] flameNoiseScales = float[2]\n( \n\t9.25,\n\t8.0\n);\n\nconst vec2[2] flameNoiseSpeeds = vec2[2]\n( \n\tvec2(-0.06, -0.27),\n\tvec2(-0.03, -0.21)\n);\n\nconst vec4[3] flameRampColors = vec4[3]\n(\n    vec4(0.4, 0.4, 1, 1),\n    vec4(1, 0.25, 0.05, 1),\n    vec4(1, 1, 0.8, 1)\n);\n    \nfloat circularVignette(in vec2 screenUV, in vec2 offset, in float scale)\n{\n    return 1.0 - (length(screenUV - offset - center) / 0.5) / scale;\n}\n\nfloat circularVignette(in vec2 screenUV) \n{ \n    return circularVignette(screenUV, vec2(0, 0), 1.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenUV = fragCoord.xy / iResolution.xy;\n    vec2 flameUV1 = screenUV / flameNoiseScales[0] + iTime * flameNoiseSpeeds[0];\n    vec2 flameUV2 = screenUV / flameNoiseScales[1] + iTime * flameNoiseSpeeds[1] + center;\n    float bgJitterTime = iTime * bgJitterSpeed;\n    \n    // bg motion jitter\n    vec2 bgJitter = vec2(\n        texture(iChannel0, vec2(bgJitterTime, 0)).r - 0.5, \n        texture(iChannel0, vec2(0, bgJitterTime)).r - 0.5\n    );\n    \n    // bg scale jitter\n    float bgScale = 1.0 + bgJitterPower / 2.0 - (bgJitter.x + 0.5) * bgJitterPower;\n    \n    // background light\n    vec4 bgColor = mix(\n        bgColors[0], \n        bgColors[1], \n        circularVignette(\n            screenUV, \n            bgJitter * bgJitterPower + bgOffset,\n            bgScale * bgVignetteSize\n        )\n    );\n\n    // flame motion\n    float fade = texture(iChannel0, flameUV1).r * texture(iChannel0, flameUV2).r;\n    \n    // adding some fill into the bottom of the flame before fading the edges\n    fade = clamp(fade + (1.0 - screenUV.y) * 0.8, 0.0, 1.0);\n\n    // thin the flame on the lateral edges\n    if (abs(screenUV.x - 0.5) > 0.5 / flameThinningFactor)\n    {\n        // no need to continue math outside the lateral edges\n        fragColor = bgColor;\n        return;\n    }\n    else\n    {\n    \tfade *= cos((screenUV.x - 0.5) * pi * flameThinningFactor);\n    }\n    \n    // create ovular shape of flame\n    if (screenUV.y < 0.5)\n    {\n\t\tfade *= circularVignette(screenUV);   \n    }\n    else\n    {\n\t\tfade *= 1.0 - abs(screenUV.x - center.x) / 0.5;\n    }\n    \n    vec4 flameColor;\n    float rampCenter = flameRampCenter + bgJitter.x * 0.1;\n    \n    // 3-color ramp\n    if (screenUV.y < rampCenter)\n    {\n        flameColor = mix(flameRampColors[0], flameRampColors[1], screenUV.y / rampCenter);\n    }\n    else\n    {\n        flameColor = mix(flameRampColors[1], flameRampColors[2], (screenUV.y - rampCenter) / (1.0 - rampCenter));\n    }\n    \n    // vertical flame death\n    float clampVal = screenUV.y;\n    \n    // edge fade & edge coloring\n    if (fade < clampVal)\n    {\n        fragColor = bgColor;\n        return;\n    }\n    else if (fade < clampVal + flameEdgeWidth)\n    {\n        fade = (fade - clampVal) / flameEdgeWidth;\n        flameColor = mix(flameEdgeColor, flameColor, fade);\n    }\n    else\n    {\n\t\tfade = 1.0;\n    }\n\n    flameColor *= flameBrightness * fade;\n    flameColor.a = fade;\n\tfragColor = bgColor + flameColor;\n}","name":"Image","description":"","type":"image"}]}