{"ver":"0.1","info":{"id":"dsKSDt","date":"1681821904","viewed":40,"name":"Cheops pyramid's logistic ","username":"letiushev","description":"Impressionist sculpture about my thoughts on how pyramids were transported. You can use mouse and WASD buttons to explore around. Please, hit \"like\" button if you enjoy it!","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["raycast","camera","postprocess","buffer","lesson"],"hasliked":0,"parentid":"DdtXWj","parentname":"blinn phong stuff no recurs refr"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-10.5,5,4.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\n\n// Intersection functions -------------------------------------\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, colors[5],false);\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.mat, s.textured);  // mat and text of sphere\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t,plane.mat, plane.textured); // mat and text of plane\n}\n\n// MÃ¶ller-Tomborne triangle intersection\nTraceResult intersectTriangle(Ray ray, Triangle trg) \n{\n    vec3 ab = trg.b - trg.a; // edges of tr\n    vec3 ac = trg.c - trg.a; // edges of tr\n    vec3 ap = ray.p0 - trg.a; // ray - first vertex\n    \n    vec3 f = cross(ray.v, ac); // cross prod of dir of ray and edge\n    vec3 g = cross(ap, ab); // cross prod ap and ab need for term2\n    \n    float term1 = 1. / dot(f, ab); // inverse of projec f to ab to comp t u v\n    \n    vec3 term2 = vec3(dot(g, ac), dot(f, ap), dot(g, ray.v)); // x y z comp to comp t u v \n    \n    vec3 result = term1 * term2; // final res\n    \n    // extract intersec params from res\n    float t = result.x;\n    float u = result.y;\n    float v = result.z;   \n        \n    // if outside triangle default val\n    if(u<0. || u>1. || v<0. || v+u>1.)\n    {\n        return TraceResult(vec3(0), ray.tmax, colors[5],false);\n    }\n    else // if inside calc inters p by ray dir* scal t + ray origin\n    {\n        vec3 p = ray.p0 + t * ray.v;\n        vec3 result = normalize(p - vec3(t, u, v)); // normalize final vec\n        return TraceResult(result, t, trg.mat, trg.textured); // mat and text of tr\n    }\n}\n// End of intersection functions ---------------------------------\n\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax,colors[5],false);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < trianglesNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n//https://medium.com/shader-coding-in-unity-from-a-to-z/light-in-computer-graphics-2-3b2a5b04ac6d\nvec3 blinnPhongBRDF(vec3 albedo, float shininess, vec3 n, vec3 v, vec3 l)\n{ //                  base color,   specul comp,    normal,view dir, light dir\n    vec3 h = normalize(v + l); // halfway vec btw view and light\n    float ndotl = max(dot(n, l), 0.0); // cos btw norm and light\n    float ndoth = max(dot(n, h), 0.0); // cos btw norm and halfway vec\n    float vdoth = max(dot(v, h), 0.0); // cos btw view and halfway vec\n\n    vec3 diffuse = albedo / pi; // comp diffuse term\n    vec3 specularColor = albedo; // comp spec color\n    float specularValue = (shininess + 2.0) * pow(ndoth, shininess) / (2.0 * pi); // spec term prod of norm fact pow of cos btw norm and halfway\n    vec3 specular = specularColor * specularValue; //final spec comp\n\n    return (diffuse + specular) * ndotl; // return fin res * angle btw norm and light dir\n}\n\n// Reflection\n// https://www.programmersought.com/article/44373992591/\nvec3 reflectRay(vec3 incident, vec3 normal) \n{ //                incoming ray, normal\n    return incident - 2.0 * dot(incident, normal) * normal; // dor prod incom and norm * 2 and substr from incoming to get the refl vec\n}\n\n// Refraction\nvec3 refractRay(vec3 incident, vec3 normal, float ior) \n{               // incom light,     n,      ior of mat \n    float ior1 = 1.0; // ior air\n    float ior2 = ior;\n\n    float cosIncident = dot(-incident, normal); // cos of incom to norm, \n    float eta = ior1 / ior2; //ratio of ior\n    float k = 1.0 - eta * eta * (1.0 - cosIncident * cosIncident); // total internal or not/ comp refracted or not\n    if (k < 0.0) // no refracted ray\n    { \n        return vec3(0, 0, 0); // total internal reflection\n    } // else calculate refracted ray dir\n    return eta * incident + (eta * cosIncident - sqrt(k)) * normal;\n}\n\n\nvec4 hitColor(Ray ray, TraceResult tr)\n{\n    vec3 col = vec3(0, 0, 0); // final accumul color\n    vec3 throughput = vec3(1.0); // accum the contribution of each bounce\n\n    // recursion for refl and refr each iter = bounce\n    for (int bounceCount = 0; bounceCount < MAX_BOUNCES; ++bounceCount)\n    {\n        // get material prop at intersec pts\n        Material mat = tr.mat;\n\n        vec3 p = ray.p0 + ray.v * tr.t; // intersec pts\n        vec3 n = tr.n; // surf norm unit vec\n\n        // First light source pos\n        vec3 lightPos1 = vec3(10., 10., 10.);\n        // Second light source pos\n        vec3 lightPos2 = vec3(40., 10., 15.);\n\n        vec3 l1 = lightPos1 - p; // direction vec from p to l1\n        float lightDist1 = length(l1); // dist btw intersec pts and l1\n        l1 /= lightDist1; // norm the vec\n\n        // Shadow ray for the first light source\n        Ray shadowray1 = Ray(p + 0.001 * n, ray.tmin, l1, lightDist1);\n        //  origin of shad ray avoid self intersec, min dist to check intersec, dir, max dist to check intersec\n        TraceResult res1 = raycast(shadowray1);//check for intersec btw p and light source\n        \n        // Shadow ray for the second light source\n        vec3 l2 = lightPos2 - p;\n        float lightDist2 = length(l2);\n        l2 /= lightDist2;\n        Ray shadowray2 = Ray(p + 0.001 * n, 0.001, l2, lightDist2);\n        TraceResult res2 = raycast(shadowray2);\n        \n        // intersec pts material propert\n        float metallic = mat.metalness;\n        float roughness = mat.roughness;\n        float shininess = mat.shininess; \n        vec3 albedo = mat.color;\n        \n        // check if p in shadow or illum by both light and calc shading based on brdf\n        if (res1.t == shadowray1.tmax && res2.t == shadowray2.tmax)\n        { \n            vec3 v = -ray.v; // view vec \n            vec3 ambientLight = vec3(0.4); // to make scene a bit lighter\n            //shading calculation to account for both light sources\n            col += throughput * (blinnPhongBRDF(albedo, shininess, n, v, l1) + blinnPhongBRDF(albedo, shininess, n, v, l2) *2.+ambientLight);\n            // calc shading by sum both lights using brdf at each light \n        }\n        \n        // emission as light producer. is diffuce and dot norm and ray dir\n        vec3 emission = mat.emission;\n        col += throughput * emission * max(dot(n, -ray.v), 0.0);\n        \n        // texture implementation\n        if (tr.textured) // if intersec pts mat has texture\n        {\n            vec3 textureColor = texture(iChannel3, p.xy).rgb; // get color\n            col += throughput * textureColor; // text col is prop modulated by thr\n        }\n        \n        // refract impl\n        if (mat.ior > 1.)\n        {\n            vec3 refrDir = normalize(refractRay(ray.v, n, mat.ior)); // refr direction\n            // Spawn refraction ray\n            ray = Ray(p + 0.001 * n, 0.001, refrDir, maxT);\n            //tr = raycast(ray);\n        }\n        else // when reflective mat\n        {\n            // Reflection implementation\n            vec3 reflDir = reflectRay(ray.v, n); // refl directon calc\n            ray = Ray(p + 0.001 * n, 0.001, reflDir, maxT); // new refl ray creation, slightly offset avoid self inters\n            //tr = raycast(ray);\n        }\n        tr = raycast(ray); // perform raycast with new ray\n\n        if (tr.t >= ray.tmax) // if inters dist >= max tracing dist, if true no valid intersec \n        {\n            break;\n        }\n    }\n\n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of spheres\n    float rotateRadius = 10.;\n    float rotateSpeed = 0.5;\n    spheres[0] = Sphere(vec3(rotateRadius*sin(iTime*rotateSpeed)+5., 1, rotateRadius*cos(iTime*rotateSpeed)+1.), 1.f, colors[6],false);\n    spheres[1] = Sphere(vec3(11,1,2.7), 1.f, colors[2],false);\n    spheres[2] = Sphere(vec3(1.5,1,4.5), 1.f, colors[1],true);\n    spheres[3] = Sphere(vec3(1.5,1,-1.5), 1.f, colors[4],false);\n    \n    // Description of plane\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), colors[1],false);\n    \n    // Description of tetrahedron\n    vec3 top = vec3(4,8,2);\n    vec3 apnt = vec3(1,2,5);\n    vec3 bpnt = vec3(12,2,3);\n    vec3 cpnt = vec3(1,2,-2);\n    triangles[0] = Triangle(apnt, top, bpnt, colors[0],false); \n    triangles[1] = Triangle(apnt, top, cpnt, colors[0],false);\n    triangles[2] = Triangle(bpnt, top, cpnt, colors[0],false);\n    triangles[3] = Triangle(apnt, bpnt, cpnt, colors[0],false);\n    \n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax <= result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result);\n\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\nconst int MAX_BOUNCES = 6;\n\nstruct Material {\n    vec3 color; // [0,1/pi]\n    float roughness; // [0,~7]\n    vec3 emission; // [0, inf]\n    float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    float shininess;\n    float ior; // Index of refraction\n};\n\n// ref: https://www.shadertoy.com/view/td3BD8\n// macros def\n#define LIGHTSRC(r,g,b)    Material(vec3(0,0,0)   , 1.      , vec3(r,g,b), 0.  , 0.0, 1.0)\n#define METALLIC(r,g,b,m,s)  Material(vec3(r,g,b)/pi, float(m), vec3(0,0,0), 0.9 , float(s), 1.0)\n#define NONMETAL(r,g,b,m,s)  Material(vec3(r,g,b)/pi, float(m), vec3(0,0,0), 0.02, float(s), 1.0)\n#define TRANSPARENT(r,g,b,m,s,ior) Material(vec3(r,g,b)/pi, float(m), vec3(0,0,0), 0.02, float(s), ior)\n#define NOMATERIAL(r,g,b)  Material(vec3(0,0,0), 0., vec3(0,0,0), 0., 0.0, 1.0)\n\nconst Material colors[] = Material[](\n    METALLIC(.6,.4,.1,0.05,50.0),\n    NONMETAL(.2,.01,1,.02,20.0),\n    NONMETAL(.1,1,.5,.05,10.0),\n    NONMETAL(3,3,1,0.3,5.0),\n    LIGHTSRC(80,80,80),\n    NOMATERIAL(0.,  0., 0.),\n    TRANSPARENT(.15,.01,1,.02,20.5, 10.42)\n);\n\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    Material mat;\n    bool textured;\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    Material mat;\n    bool textured;\n};\n\nstruct Triangle\n{\n    vec3 a,b,c;\n    Material mat;\n    bool textured;\n};\n\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    Material mat;\n    bool textured;\n};\n\nconst int spheresNo = 4;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int trianglesNo = 4;\nTriangle triangles[trianglesNo];\n\nconst float maxT = 1000.0;","name":"Common","description":"","type":"common"}]}