{"ver":"0.1","info":{"id":"tlX3W4","date":"1556312687","viewed":119,"name":"short shader study","username":"Machia","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tcompressed shader study\n\n\treference from\n\thttp://glslsandbox.com/e#54303.0\n*/\n\n//マッピング（立体配置）\nfloat map(vec3 p) {\n\tfloat t = length(mod(p, 2.0) - 1.0) - 0.35;\n\treturn t;\n}\n\n//法線を取得する（ことで立体的な絵になる）\nvec3 getN(vec3 p) {\n\tfloat t = map(p);\n\tvec2 d = vec2(0.001, 0.0);\n    \n\treturn normalize(vec3(\n\t\tt - map(p + d.xyy),\n\t\tt - map(p + d.yxy),\n\t\tt - map(p + d.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy ) / min(iResolution.x , iResolution.y);\n    \n    //レイを飛ばす方向\n\tvec3 dir = normalize(vec3(uv, 1.0));\n    float x_po,y_po;\n    //調査ポジションの定義\n    \n    if( uv.x*uv.x + uv.y*uv.y >0.45){\n        x_po = -1.;\n        y_po = -0.;\n    }else{\n        x_po = 1.0;\n        y_po = 0.0;\n    }\n    if( (uv.x*uv.x + uv.y*uv.y)>1.0){\n        x_po =0.0;\n        y_po = 1.0;\n    }\n    \n    if(uv.x*uv.x + uv.y*uv.y>2.0){\n        x_po = 2.0;\n        y_po = -2.0;\n    }\n    \n    \n    vec3 pos = vec3(y_po*cos(iTime) ,x_po*sin(iTime) , iTime);\n\n    //変数定義\n\tfloat t= 0.0;\n    \n    int mx =75;//int(floor(20.*(sin(iTime)+1.) ) );\n    \n    //レイを飛ばして調査する\n\tfor(int i = 0 ; i < 25+mx; i++ ) {\n        //マップしてる図形に対しレイを飛ばし、\n        //その分距離を進める\n\t\tt += map(dir * t + pos);\n\t}\n    \n    //計算を終了した時点のレイの位置を定義する\n    vec3 ip = dir * t + pos;\n    \n    //法線定義\n\tvec3 L = normalize(vec3(1,2,3));\n\tvec3 N = getN(ip);\n    \n    // Output to screen\n    \n    //dot(L,N):法線とライトの座標との内積を求める\n    //dir*0.1:色を抑えてる（このままだとRGBがキツい）\n    fragColor = vec4(dot(L, N)*0.75 + x_po*3.*dir * 0.2, 1.0);\n}","name":"Image","description":"","type":"image"}]}