{"ver":"0.1","info":{"id":"3lSSDh","date":"1581962372","viewed":174,"name":"blur + posterize","username":"ttyy","description":"single pass blur + posterize\n\nmouse y adjusts blur\nmouse x controls posterize portion","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["posterize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int NUM_COLORS = 10;\n\nfloat srand(vec2 a)\n{\n\treturn sin(dot(a,vec2(1233.224,1743.335)));\n}\n\nfloat rand(inout float r)\n{\n\tr=fract(3712.65*r+0.61432);\n\treturn (r-0.5)*2.0;\n}\n\nvec4 rand_blur(sampler2D tex, vec2 resolution, vec2 uv, float pxRadius, int nIter)\n{\n\tfloat radius\t= pxRadius / resolution.y;\n    float r \t\t= srand(uv);\n    vec4 c \t\t\t= vec4(0.);\n\tfor(int i=0;i<nIter;i++)\n\t{\n        vec2 dir = vec2( rand(r), rand(r) );\n\t\tc += texture(tex,uv+dir*radius)/float(nIter);\n\t}\n    return c;\n}\n\nvec4 box_blur(sampler2D tex, vec2 resolution, vec2 uv, vec2 size)\n{\n    vec4 c = vec4(0.);\n    for (float y=-2.; y<=2.; y+=1.){\n        for (float x=-2.; x<=2.; x+=1.){\n            \n            vec2 bb;\n            bb.x = x * size.x + .5 * sign(x);\t// texel edges to hw interpolate\n            bb.y = y * size.y + .5 * sign(y);\n            bb /= resolution;\n            c += texture(tex, uv + bb);\n        }\n    }\n    c /= 25.;\n    return c;\n}\n\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n} \n\nvec3 RGBToHSV( vec3 RGB ){\n    \n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = RGB.g < RGB.b ? vec4(RGB.b, RGB.g, k.w, k.z) : vec4(RGB.gb, k.xy);\n    vec4 q = RGB.r < p.x   ? vec4(p.x, p.y, p.w, RGB.r) : vec4(RGB.r, p.yzx);\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSVToRGB( vec3 HSV ){\n    \n    vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(HSV.xxx + k.xyz) * 6.0 - k.www);\n    return HSV.z * lerp(k.xxx, clamp(p - k.xxx, 0.0, 1.0), HSV.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // box blur\n    \n    vec2 spread = vec2(iMouse.y / iResolution.y) * 5.;\n    vec3 c = box_blur(iChannel0, iResolution.xy, uv, spread).rgb;\n    \n\t// posterize    \n    \n    float vx_offset = .5;\n    if (iMouse.z > 0.){\n        vx_offset = iMouse.x / iResolution.x;\n    }\n    if(uv.x < vx_offset)\n    {\n   \t \tc \t\t\t\t= RGBToHSV(c);\n    \tfloat cutColor \t= 2. / float(NUM_COLORS);\n    \tvec2 tc \t\t= cutColor * (floor(c.gb/cutColor) + vec2(0.25,.5));\n    \tc \t\t\t\t= HSVToRGB(vec3(c.r,tc));\n        \n    }\n    \n    // line\n    \n    c *= smoothstep( .001, .0012, length(uv.x-vx_offset)); \n    \n    fragColor = vec4(c, 1.0);\n   \n}","name":"Image","description":"","type":"image"}]}