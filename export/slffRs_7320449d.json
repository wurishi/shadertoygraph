{"ver":"0.1","info":{"id":"slffRs","date":"1651305389","viewed":99,"name":"Trying to understand Segment Tr.","username":"AntonioNoack","description":"source: https://www.shadertoy.com/view/WdVyDW\nadded: typical raymarching on the left","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric GuÃ©rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 120;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat smoothen(float s){\n    return 1.0/(1.0+s*s);\n}\n\nfloat smin(float a, float b){\n    return min(a,b)+2.0*smoothen((a-b)*0.01);\n}\n\nfloat map(vec3 p){\n    float I = sphere(p-vec3(-radius / 2.0, 0, 0), radius);\n    I = smin(I,sphere(p-vec3(radius / 2.0, 0, 0), radius));\n    I = smin(I,sphere(p-vec3(radius / 3.0, radius, 0), radius));\n    return (I - T);\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\nfloat raycast(vec3 ro, vec3 rd, out bool h, out int s){\n    h = false;\n    float t = ra;\n    for(s=0;s<StepsMax && t < rb;s++){\n       float dist = map(ro+rd*t);\n       if(abs(dist)<0.1){\n           h = true;\n           return t;\n       }\n       t += dist;\n    }\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, -v / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = -v / lipschitzSeg;\n        \n        // No further than the segment length                     \n        // But at least, Epsilon\n        step = clamp(step, Epsilon, candidate);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    float sep0 = sep-0.33;\n    float sep1 = sep+0.33;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep0) {\n        t = raycast(ro, rd, hit, s); \n    } else if (pixel.x < sep1) {\n        t = SphereTracing(ro, rd, hit, s); \n    } else {// Segment tracing on the right\n        t = SegmentTracing(ro, rd, hit, s);\n    }\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }\n    // lines\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep0)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep1)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}