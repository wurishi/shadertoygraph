{"ver":"0.1","info":{"id":"lX3Szr","date":"1718503323","viewed":114,"name":"Pixel Art Procedural Earth","username":"ArchaicVirus","description":"Same as my procedural earth 2 shader, but pixelized by modding fragCoords","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raycast","clouds","sphere","space","pixelart","psuedo3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n    return fract(sin(n) * 53738.14534123);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n\n    return mix(\n        mix(hash(ip.x + ip.y * 57.0), hash(ip.x + 1.0 + ip.y * 57.0), u.x),\n        mix(hash(ip.x + (ip.y + 1.0) * 57.0), hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0), u.x),\n        u.y\n    );\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec3 colorBanding(float n) {\n    vec3 color = vec3(0);\n    if (n > 0.95) return vec3(0.0, 0.1, 0.5);\n    else if (n > 0.85) color = vec3(0.0, 0.3, 0.7);\n    else if (n > 0.75) color = vec3(0.0, 0.5, 0.8);\n    else if (n > 0.65) color = vec3(0.0, 0.7, 0.7);\n    else if (n > 0.55) color = vec3(0.8, 0.6, 0.4);\n    else if (n > 0.45) color = vec3(0.0, 0.6, 0.0);\n    else color = vec3(0.4, 0.6, 0.1);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float pixelSize = 5.0;\n    vec2 uv = (floor(fragCoord / pixelSize) * pixelSize - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro_planet = vec3(0.0, 0.0, 2.4);\n    vec3 ro_clouds = vec3(0.0, 0.0, 2.3);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t_planet = sphere(ro_planet, rd, 1.0);\n    float t_clouds = sphere(ro_clouds, rd, 1.0);\n    if (t_clouds < 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        vec3 pos = ro_planet + t_planet * rd;\n        pos = rotate(pos, iTime*0.5);\n        vec3 norm = normalize(pos);\n        float noiseValue = layeredNoise(norm * 3.1415, 1.0, 1.0, 0.5, 8);\n        vec4 color = vec4(colorBanding(noiseValue), 1.0);\n        \n        if (t_planet < 0.0) {\n            color = vec4(0.0);\n        }\n        \n        vec3 pos2 = ro_clouds + t_clouds * rd;\n        pos2 = rotate(pos2, iTime);\n        vec3 norm2 = normalize(pos2);\n        float noiseValue2 = layeredNoise(norm2 * 3.55275, 1.0, 1.0, 0.5, 8) * 0.75;\n        float noiseValueFinal = pow(noiseValue2, 1.05) - 1.0;\n        vec4 color2 = vec4(vec3(noiseValueFinal), min(noiseValue2 - 0.5, 0.1));\n        \n        fragColor = mix(color, color2 + vec4(0.0, 0.22, 0.75, 1.0), noiseValue2) + color;\n    }\n}","name":"Image","description":"","type":"image"}]}