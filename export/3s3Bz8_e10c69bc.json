{"ver":"0.1","info":{"id":"3s3Bz8","date":"1604345158","viewed":100,"name":"It's Saturn","username":"vtgco","description":"It's Saturn","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat i = floor( p );\n    float f = fract( p );\n    \n    //from https://www.shadertoy.com/view/3sVczG\n    float u = f*f*(3.0-2.0*f);\n\t\n\treturn mix(rand(i),rand(i+1.),u);\n}\n\n// -----------------------------------------------\n\n\n//SDF functions from https://iquilezles.org/articles/distfunctions\n\nfloat sdfSphere(vec3 p, float r) { return length(p) - r; }\n\nfloat onion( in float d, in float h ) { return abs(d)-h; }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//from https://www.shadertoy.com/view/wdKyD3\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n// -----------------------------------------------\n\nconst vec3 SPHERE_DARK = vec3(188., 108., 37.)/255.;\nconst vec3 SPHERE_LIGHT = vec3(221., 161., 94.)/255.;\nconst vec3 RING_COLOR = vec3(128., 108., 80.)/50.;\n\nconst vec3 PLANET_CENTER = vec3(0.,0.,-8.);\n\n\nvec3 spaceship(float t) {\n    const float spaceship_dist = 2.25;\n   \n    vec3 loc = vec3(spaceship_dist*cos(t), 0., spaceship_dist*sin(t));\n    //loc = rotate_x(loc, -3. + t * -0.05);\n    loc += PLANET_CENTER;\n   \n    return loc;\n}\n\nvec4 map_and_color(vec3 q) {\n    vec3 col = vec3(0.);\n    float map_val = 1000.;\n    \n    float spaceship_sphere = sdfSphere(q - spaceship(iTime), 0.1);\n    if (map_val > spaceship_sphere) {\n    \tmap_val = spaceship_sphere;\n        col = vec3(0.5,0.5,0.5);\n    }\n    \n    vec3 p = q;\n    p -= PLANET_CENTER;\n    \n    p = rotate_x(p, -.3 + iTime * -0.05);\n   \n    \n    float sphere = sdfSphere(p, 1.);\n    if (map_val > sphere) {\n        float col_displacement = 0.1*(noise(20.*atan(p.z, p.x)+25.*p.y + iTime) - 0.5);\n        col = mix(SPHERE_DARK, SPHERE_LIGHT, fract(p.y*5. + col_displacement));\n    \tmap_val = sphere;\n        \n        col += (float(sdHexPrism(p.zxy + 0.2*col_displacement, vec2(0.14, 20.)) - 0.06 <= 0.)) * vec3(0.,0.,0.5);\n    }\n  \n    \n    float max_ring_r = 2.;\n\tfloat ring = sdCappedCylinder(p, vec2(max_ring_r,0.001));\n    \n    float ring_r = 1.25;\n    ring = opSubtraction(sdCylinder(p, vec3(0.,0.,ring_r)), ring);\n    \n    //CUT RANDOM GAPS INTO THE RINGS\n    /*float gap = 0.;\n    while(ring_r < max_ring_r) { \n        gap = rand(ring_r+1.) * 0.05;\n        ring = opSubtraction(onion(sdCylinder(p, vec3(0.,0.,ring_r)), gap), ring);\n        ring_r += rand(ring_r+1.) * 0.3;\n        \n    }*/\n    \n    if (map_val > ring) {\n    \tmap_val = ring;\n        col = RING_COLOR;\n        col *= smoothstep(0., 1., noise(length(p)*20.));\n    }\n    \n    \n    return vec4(col, map_val);\n}\n\n\nfloat map(vec3 p) {\n    return map_and_color(p).w;\n}\n\n\n//from https://www.shadertoy.com/view/wdKyD3\nvec3 normalAtPoint(vec3 p) {\n    const float eps = 0.0001; // or some other value\n    const vec2  h   = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nfloat raymarch(vec3 start, vec3 dir) {\n    float t = 0.;\n    for (int i = 0; i <= 50; i++) {\n        vec3 curr_point = start + t*dir;\n        float map_val = map(curr_point);\n        \n        if (map_val < 0.01) {\n            return t;\n        } else {\n        \tt += map_val;\n        }\n        \n        if (t >= 50.) {\n            return -1.;\n        }\n    }\n    \n    return -1.;\n}\n\nfloat shadow(vec3 start, vec3 dir, float t_min, float t_max) {\n    float t = t_min;\n    while (t < t_max) {\n        vec3 curr_point = start + t*dir;\n        float map_val = map(curr_point);\n        \n        if (map_val < 0.01) {\n            return 0.;\n        } else {\n        \tt += map_val;\n        }\n    }\n    \n    return 1.;\n}\n\n//from https://www.shadertoy.com/view/wdKyD3\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += 0.95*h;//slightly less for not-quite-SDFs\n    }\n    return res;\n}\n\nvec3 CAMERA = vec3(0.,0.,3.);\n const vec3 LIGHT = normalize(vec3(1., 0., 3.));\nconst vec3 LIGHT_COLOR = vec3(1.);\n\nvec3 render(vec3 p) {\n    vec3 col = vec3(0.);\n    vec3 normal = normalAtPoint(p);\n    vec3 diffuse_color = map_and_color(p).xyz;\n \t \n   \t//directional lighting\n    float LdotN = clamp(dot(normal, LIGHT), 0., 1.);\n    float shadow = softshadow(p, LIGHT, 0.02, 20., 17.);\n    col = diffuse_color * LdotN * LIGHT_COLOR * clamp(0.3, 1., shadow);\n    \n    \n    //point light from spaceship\n    vec3 spaceship_light = normalize(spaceship(iTime) - p);\n    float LdotN_spaceship = clamp(dot(normal, spaceship_light), 0., 1.);\n    float shadow_spaceship = softshadow(p, spaceship_light, 1., 50., 17.);\n    col += diffuse_color * LdotN_spaceship * LIGHT_COLOR * clamp(0.3, 1., shadow_spaceship);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec3 col = vec3(0.);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(uv, 0.);\n     \n    \n    vec3 dir = normalize(pix - CAMERA);\n    \n    float t = raymarch(CAMERA, dir);\n    vec3 p = CAMERA + dir*t;\n    \n    if (t > 0.) {\n        col = render(p);    \n        \n    } else { //ADD STARS\n        float randAtPoint = rand((uv.x+rand(uv.y))*(rand(uv.x)+uv.y));\n        col = smoothstep(0., 1., (randAtPoint - 0.99)*100.) * vec3(1.); // * abs(sin(iTime+10.*rand(randAtPoint))); /*TWINKLING*/\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}