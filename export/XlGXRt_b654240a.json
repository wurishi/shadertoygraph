{"ver":"0.1","info":{"id":"XlGXRt","date":"1485360869","viewed":650,"name":"Basic : Karlsruhe metric voronoi","username":"Gijs","description":"inspired by a /r/math post. Imagine you live in a city in which you can only walk on the paths illustrated by the white lines and you want to go to the nearest store. The areas around the shops now illustrate which is most nearby. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","karlsruhe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Pi  = 3.14159265359;\nconst float Tau = 6.28318530718;\n\nvec3 rainbow(float t){\n    return sin((t+vec3(0,.33,.66))*6.28)*.5+.5;\n}\n\nvec2 Scale(vec2 p){\n    return (p*2.-iResolution.xy)/iResolution.y;\n}\n\nfloat getAngle(vec2 p){\n    return atan(-p.y,-p.x)+Pi;//0 and Tau at (1,0), never negative\n}\n\nfloat Karlsruhe_Metric(vec2 p1,vec2 p2){//input is cartesian\n    //to polar\n    float r1 = length(p1);\n    float r2 = length(p2);\n    float a1 = getAngle(p1);\n    float a2 = getAngle(p2);\n  \t\n    float delta_a = abs(a1-a2);//angular difference\n          delta_a = min(delta_a,Tau-delta_a);//might have calculated the wrong segment\n    \n    if(delta_a<=2.){\n        return min(r1,r2)*delta_a+abs(r1-r2);\n    }else{\n    \treturn r1+r2;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = Scale(fragCoord.xy);\n    \n    float PointEpsilon = 10./iResolution.y;\n    float LineEpsilon  = 5./iResolution.y;\n    \n    float dis   = 1e20;\n    vec3  color = vec3(0);\n    vec2  vp    = vec2(0);\n    \n    for(float i=1.;i<11.;i++){\n        vec2 nvp = vec2(cos(iTime*i*.01+i),sin(iTime*i*0.05+i))*vec2(iResolution.x/iResolution.y,1);\n   \t \tfloat ndis = Karlsruhe_Metric(nvp,p);\n        if(ndis<dis){\n            dis = ndis;\n            color = rainbow(i/10.);\n            vp = nvp;\n        }\n    }\n    \n    float circlesdis = abs(mod(length(p),.2)-.1);\n    color = mix(vec3(1),color,smoothstep(0.,LineEpsilon,circlesdis));\n    \n    float linesdis = abs(mod(getAngle(p),Tau/10.)-Tau/20.);\n    color = mix(vec3(1),color,smoothstep(0.,LineEpsilon,linesdis));\n    \n    float pointdis = distance(p,vp);\n    color = mix(vec3(1),color,smoothstep(0.,PointEpsilon,pointdis));\n    \n\tfragColor = vec4(color/(dis*2.+1.),1);\n}","name":"Image","description":"","type":"image"}]}