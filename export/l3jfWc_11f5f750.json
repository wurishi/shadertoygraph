{"ver":"0.1","info":{"id":"l3jfWc","date":"1731356196","viewed":38,"name":"CG-Lab-2","username":"Wesdmond","description":"3D game on shaders; homework for CG course","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["gd2023","cg2024"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Поверхность земли с шумом\nfloat ground(vec3 p) {\n    float hillHeight = perlinNoise(p.xz * 0.2) * 0.6;\n    return p.y + hillHeight;\n}\n\n// Корпус танка (куб)\nfloat tankBodySDF(vec3 p, vec3 pos, vec3 size) {\n    vec3 tankPos = p - pos;\n    return length(max(abs(tankPos) - size, 0.0));\n}\n\n// Башня танка (сфера)\nfloat tankTurretSDF(vec3 p, vec3 pos, float radius) {\n    vec3 turretPos = p - pos;\n    //turretPos.xz = mat2(cos(turretRotation), -sin(turretRotation), sin(turretRotation), cos(turretRotation)) * turretPos.xz;\n    return length(turretPos) - radius;\n}\n\n// Движение снаряда\nfloat bulletSDF(vec3 p, vec3 pos) {\n    if (shotTime < 0.0) return 1000.0; // Если не выстрелено, возвращаем большое расстояние\n\n    // Расчет позиции снаряда с течением времени\n    return length(p - pos) - defaultProjectile.radius;\n}\n\nfloat craterSDF(vec3 p, vec3 pos, float radius) {\n    return length(p - pos) - defaultProjectile.explosionRadius;\n}\n\n// Пушка танка (куб)\nfloat tankGunSDF(vec3 p, vec3 turretCenter, vec3 pos, vec3 size, float yaw, float pitch) {\n    vec3 gunPos = p - turretCenter;\n\n    // Применение поворота башни\n    gunPos.xz = mat2(cos(yaw), -sin(yaw), sin(yaw), cos(yaw)) * gunPos.xz;\n\n    // Применение наклона пушки\n    gunPos.yz = mat2(cos(pitch), -sin(pitch), sin(pitch), cos(pitch)) * gunPos.yz;\n\n    // Возвращаем пушку обратно на смещенную позицию\n    gunPos -= pos;\n\n    return length(max(abs(gunPos) - size, 0.0));\n}\n\n\n// Дистанционное поле для всей сцены\nfloat map(vec3 p, out int surfaceType) {\n    float dGround = ground(p);\n    float dPlayerTankBody = tankBodySDF(p, player.body.position, player.body.size);\n    float dPlayerTurret = tankTurretSDF(p, player.turret.position, player.turret.size);\n    float dPlayerGun = tankGunSDF(p, player.turret.position, player.turret.gun.position, player.turret.gun.size, -turretYaw, gunPitch);\n    float dBullet = bulletSDF(p, bulletPos);\n    float dEnemyTankBody = tankBodySDF(p, enemy.body.position, enemy.body.size);\n    float dEnemyTurret = tankTurretSDF(p, enemy.turret.position, enemy.turret.size);\n    float dEnemyGun = tankGunSDF(p, enemy.turret.position, enemy.turret.gun.position, enemy.turret.gun.size, PI, 0.);\n    float dCraters[CRATER_MAX_COUNT];\n    float dMinCrater = 100000000.0;\n    for (int i = 0; i < cratersCount; i++) {\n        dCraters[i] = craterSDF(p, cratersPos[i], defaultProjectile.explosionRadius);\n        dMinCrater = min(dMinCrater, dCraters[i]);\n    }\n    dGround = opSmoothSubtraction(dMinCrater, dGround, 0.5);\n    float dPlayerTank = min(dPlayerTankBody, min(dPlayerTurret, dPlayerGun)); // Находим ближайшее расстояние к танку игрока\n    float dEnemyTank  = min(dEnemyTankBody, min(dEnemyTurret, dEnemyGun));    // Находим ближайшее расстояние к танку противника\n\n    float minDist = min(dEnemyTank, min(dPlayerTank, min(dGround, dBullet)));\n\n    if      (minDist == dGround) surfaceType = 0; // Земля\n    else if (minDist == dPlayerTankBody) surfaceType = 1; // Корпус танка игрока\n    else if (minDist == dPlayerTurret)   surfaceType = 2; // Башня игрока\n    else if (minDist == dPlayerGun)      surfaceType = 3; // Пушка игрока\n    else if (minDist == dBullet)         surfaceType = 4; // Снаряд\n    else if (minDist == dEnemyTankBody)  surfaceType = 5; // Корпус красного танка\n    else if (minDist == dEnemyTurret)    surfaceType = 6; // Башня красного танка\n    else if (minDist == dEnemyGun)       surfaceType = 7; // Пушка красного танка\n    else if (minDist == dMinCrater)      surfaceType = 8; // Кратер\n    \n    return minDist;\n}\n\n// Вычисление нормали к поверхности с помощью градиента\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    int ignore;\n    return normalize(vec3(\n        map(p + e.xyy, ignore) - map(p - e.xyy, ignore),\n        map(p + e.yxy, ignore) - map(p - e.yxy, ignore),\n        map(p + e.yyx, ignore) - map(p - e.yyx, ignore)\n    ));\n}\n\n// Функция для освещения\nfloat lighting(vec3 p, vec3 lightDir) {\n    vec3 normal = calcNormal(p);\n    return max(dot(normal, lightDir), 0.0);\n}\n\n\n// Ray Marching для сцены\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    vec3 p;\n    int surfaceType;\n    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));\n    for (int i = 0; i < 350; i++) {\n        p = ro + rd * dist;\n        float d = map(p, surfaceType);\n\n        if (d < 0.005) {\n            #ifdef LIGHT\n                float shade = lighting(p, lightDir);\n            #else\n                float shade = 1.0;\n            #endif\n\n            // Цвет в зависимости от типа поверхности\n            if (surfaceType == 1) return player.body.color * shade; // Корпус танка\n            if (surfaceType == 2) return player.turret.color * shade; // Башня танка\n            if (surfaceType == 3) return player.turret.gun.color * shade; // Пушка\n            if (surfaceType == 4) return player.turret.gun.projectile.color + (sin(iTime * 10.) + 1.) / 2.; // Снаряд\n            \n            if (surfaceType == 5) return enemy.body.color * shade;\n            if (surfaceType == 6) return enemy.turret.color * shade;\n            if (surfaceType == 7) return enemy.turret.gun.color * shade;\n            if (surfaceType == 8) return enemy.turret.gun.color * shade;\n            return FLOOR_COLOR * shade; // Земля\n        }\n\n        dist += max(d, 0.005);\n        if (dist > 20.0) break;\n    }\n    return SKY_COLOR - 0.5 * rd.y; // Небо\n}\n\n// Основная функция\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    parseBufferA(iChannel0);\n\n    // Настройка камеры\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Камера вокруг точки (танка)\n    vec3 ro = vec3(4.5 * cos(cameraYaw-PI/2.), 2.0 + cameraPitch, 4.5 * sin(cameraYaw-PI/2.));\n    vec3 ta = vec3(0.0, 0.1, 0.0);\n    vec3 forward = normalize(ta - ro);\n    vec3 right = normalize(cross(ta, -ro));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 color = rayMarch(ro, rd);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// GLOBAL SETTINGS\n#define SKY_COLOR vec3(0.5, 0.8, 1.0)\n#define LIGHT\n//#define BALLISTIC_ROUNDS\n#define EXPLOSION_ROUNDS\n#define CRATER_MAX_COUNT 1\n\n//// TODO\n// #define RAIN\n// #define MULTIPLE_ROUNDS\n#define AUTOAIM\n#define PLAYER_MOVEMENT\n\n// FLOOR\n#define FLOOR_COLOR vec3(0.2, 0.7, 0.3)\n#define PIXEL_FLOOR\n#define NON-FLAT_FLOOR\n\n// CONSTANTS\n#define PI 3.14159265359\n\n// BUFFER_A COORDINATS MAP\n#define TURRET_CASE            ivec2(0, 0)\n#define BULLET_POS_CASE        ivec2(1, 0)\n#define BULLET_VELOCITY_CASE   ivec2(1, 1)\n#define CAMERA_ANGLE_CASE      ivec2(3, 0)\n#define BOOM_CRATER_ARRAY_CASE ivec2(4, 0)   \n#define JAVELIN_CASE           ivec2(5, 0)\n\nfloat turretYaw = 0.0; // Угол поворота башни\nfloat gunPitch = 0.0;   // Угол подъёма пушки башни\n\n// Позиция и скорость снаряда\nvec3  bulletPos = vec3(0.0);\nvec3  bulletVelocity = vec3(0.0);\nfloat shotTime = -1.0; // Время последнего выстрела\nfloat javelinStartDistance = 0.0;\n\n// Данные камеры\nfloat cameraYaw = 0.0;\nfloat cameraPitch = 0.0;\nvec2  lastMousePos = vec2(0.0, 0.0);\n\n// Данные кратеров\nint cratersCount = 0;\nvec3 cratersPos[CRATER_MAX_COUNT];\n\nvoid getTurretData(sampler2D channel) {\n    turretYaw = texelFetch(channel, TURRET_CASE, 0).x;\n    gunPitch   = texelFetch(channel, TURRET_CASE, 0).y;\n}\nvoid getBulletData(sampler2D channel) {\n    bulletPos      = texelFetch(channel, BULLET_POS_CASE, 0).xyz;\n    bulletVelocity = texelFetch(channel, BULLET_VELOCITY_CASE, 0).xyz;\n    shotTime       = texelFetch(channel, BULLET_VELOCITY_CASE, 0).a;\n    javelinStartDistance = texelFetch(channel, BULLET_VELOCITY_CASE, 0).x;\n}\n\nvoid getCameraData(sampler2D channel) {\n    cameraYaw      = texelFetch(channel, CAMERA_ANGLE_CASE, 0).x;\n    cameraPitch    = texelFetch(channel, CAMERA_ANGLE_CASE, 0).y;\n    lastMousePos   = texelFetch(channel, CAMERA_ANGLE_CASE, 0).zw;\n}\n\nvoid getCratersData(sampler2D channel) {\n    cratersCount   =  int(texelFetch(channel, BOOM_CRATER_ARRAY_CASE, 0).x);\n    for (int i = 0; i < cratersCount; i++) {\n        cratersPos[i] = texelFetch(channel, BOOM_CRATER_ARRAY_CASE+ivec2(0, i+1), 0).xyz;\n    }\n}\n\nvoid parseBufferA(sampler2D channel) {\n    getTurretData(channel);\n    getBulletData(channel);\n    getCameraData(channel);\n    \n    #ifdef EXPLOSION_ROUNDS\n        getCratersData(channel);\n    #endif\n}\n\n// MATH FUNCS\nint modInt(int a, int b) {\n    return a - (a/b)*b;\n}\n// Хэш-функция для генерации шума\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453123) * 2.0 - 1.0;\n}\n\n// Перлин-шум для земли\nfloat perlinNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float a = dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n    float b = dot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n    float c = dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n    float d = dot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\nfloat angleToPI(float angle) {\n    return angle * PI / 180.0;\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// TANKS\nstruct turretProjectile {\n    vec3 color;\n    float radius;\n    float startingSpeed;\n    float maxSpeed;\n    float gravity;\n    float explosionRadius;\n};\nstruct tankGun {\n    vec3 color;\n    vec3 position;\n    vec3 size;\n    turretProjectile projectile;\n};\nstruct tankTurret {\n    vec3 color;\n    vec3 position;\n    float size;\n    float rotationSpeed;\n    vec3 maxAngles;\n    tankGun gun;\n};\nstruct tankBody {\n    vec3 color;\n    vec3 position;\n    vec3 size;\n};\nstruct tank {\n    uint teamID;\n    float speed;\n    tankTurret turret;\n    tankBody body;\n};\nvec3 javelinStartVelocity = vec3(0.0, 5.0, 0.0);\nconst turretProjectile defaultProjectile = turretProjectile(vec3(1.0,0.0,0.0), 0.1, 1.0, 1.0, 2.0, 0.5);\nconst tankGun blueTeamGun                = tankGun(vec3(0.5,0.5,1.0), vec3(0.0, 0.05, 0.25), vec3(0.05, 0.05, 0.25), defaultProjectile);\nconst tankTurret blueTeamTurret          = tankTurret(vec3(0.5,0.5,1.0), vec3(0.0, 0.25, 0.0), 0.15, 0.05, vec3(90.0, 90.0, 10.0), blueTeamGun);\nconst tankBody blueTeamTankBody          = tankBody(vec3(0.0,0.0,1.0), vec3(0.0, 0.1, 0.0), vec3(0.2, 0.1, 0.3));\nconst tank blueTeamTank                  = tank(1u, 1.0, blueTeamTurret, blueTeamTankBody);\n\nconst tankGun redTeamGun                 = tankGun(vec3(1.0,0.0,0.5), vec3(0.0, 0.05, 0.25), vec3(0.05, 0.05, 0.25), defaultProjectile);\nconst tankTurret redTeamTurret           = tankTurret(vec3(1.0,0.0,0.5), vec3(0.0, 0.25, 10.0), 0.15, 0.05, vec3(90.0, 30.0, 10.0), redTeamGun);\nconst tankBody redTeamTankBody           = tankBody(vec3(1.0,0.0,0.0), vec3(0.0, 0.1, 10.0), vec3(0.2, 0.1, 0.3));\nconst tank redTeamTank                   = tank(1u, 1.0, redTeamTurret, redTeamTankBody);\n\nconst tank player                        = blueTeamTank;\nconst tank enemy                         = redTeamTank;\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// INPUT CONSTANTS\n//// ARROWS\n    const int KEY_LEFT  = 37; \n    const int KEY_UP    = 38;\n    const int KEY_RIGHT = 39;\n    const int KEY_DOWN  = 40;\n\n//// WASD\n    const int KEY_W = 87;\n    const int KEY_A = 65;\n    const int KEY_S = 83;\n    const int KEY_D = 68;\n    \n////SPACE\n    const int SPACE_KEY = 32;\n\n// Функция для инициализации снаряда (выстрел)\nvoid fireBullet() {\n    vec3 gunBasePos = player.turret.position; // Позиция центра башни\n    //vec3 gunTipOffset = vec3(0.0, 0.0, 0.6); // Смещение к кончику пушки\n    vec3 gunTipOffset =  vec3(0.0, 0.0, player.turret.gun.size.z + defaultProjectile.radius);\n    // Создание матрицы для комбинированного вращения башни и наклона пушки\n    mat3 rotationMatrix = mat3(\n        cos(-turretYaw), 0.0, sin(-turretYaw),\n        0.0, 1.0, 0.0,\n        -sin(-turretYaw), 0.0, cos(-turretYaw)\n    ) * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(-gunPitch), -sin(-gunPitch),\n        0.0, sin(-gunPitch), cos(-gunPitch)\n    );\n    bulletPos = gunBasePos + rotationMatrix * (gunTipOffset + player.turret.gun.position);\n    // Установка начальной скорости в направлении пушки\n    bulletVelocity = normalize(rotationMatrix * gunTipOffset) * defaultProjectile.startingSpeed; // Скорость снаряда\n    #ifdef AUTOAIM\n        bulletVelocity += javelinStartVelocity;\n    #endif\n    shotTime = iTime; // Установка времени выстрела\n}\n\n// Обработка вращения башни\nvoid updateTurretRotation() {\n    float input_var;\n    input_var = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r\n              + texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r;\n    input_var = clamp(input_var, -1.0f, 1.0f); \n    float maxYawAngle = angleToPI(player.turret.maxAngles.x);\n    turretYaw = clamp(turretYaw + blueTeamTurret.rotationSpeed * input_var, -maxYawAngle, maxYawAngle);\n    \n    input_var = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r\n              + texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n    input_var = clamp(input_var, -1.0f, 1.0f);\n    gunPitch = clamp(gunPitch + blueTeamTurret.rotationSpeed * input_var, -angleToPI(player.turret.maxAngles.y), angleToPI(player.turret.maxAngles.z));\n}\n\nvoid handleFire() {\n    if (texelFetch(iChannel1, ivec2(SPACE_KEY, 1), 0).r == 1.)\n        fireBullet();\n}\n\nvoid updateCameraAngle() {\n    if (iMouse.w > 0.0) {lastMousePos = iMouse.xy;}\n    // Управление камерой с помощью мыши\n    if (iMouse.z > 0.0) {\n        vec2 mouseDelta = (iMouse.xy - lastMousePos) / 100.0;\n        cameraYaw += mouseDelta.x; // Горизонтальный угол\n        cameraPitch = clamp(cameraPitch + mouseDelta.y, -PI/6., PI/2.); // Вертикальный угол\n        lastMousePos = iMouse.xy;\n    }\n}\n\nvoid updateInputData() {\n    updateTurretRotation();\n    handleFire();\n    updateCameraAngle();\n}\n\nbool checkProjectileCollision() {\n    vec3 bulletCurrentPos = bulletPos;\n    if (bulletCurrentPos.y < 0.0) {\n        #ifdef EXPLOSION_ROUNDS\n            cratersPos[modInt(cratersCount++, CRATER_MAX_COUNT)] = bulletCurrentPos;\n            cratersCount = min(cratersCount, CRATER_MAX_COUNT);\n        #endif\n        return true;\n    }\n    float minDist = distance(bulletCurrentPos, enemy.body.position);\n    minDist = min(minDist, distance(bulletCurrentPos, enemy.turret.position));\n    minDist = min(minDist, distance(bulletCurrentPos, enemy.turret.position + enemy.turret.gun.position));\n\n    return (minDist < 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    parseBufferA(iChannel0);\n    \n    if (shotTime > 0.0) {\n        float gTime = (iTime - shotTime);\n        #ifdef BALLISTIC_ROUNDS\n            vec3 acceleration = vec3(0.0, defaultProjectile.gravity, 0.0);\n            bulletVelocity -= acceleration * iTimeDelta * vec3(0.0, 1.0, 0.0) * gTime;\n            //min(defaultProjectile.gravity, defaultProjectile.maxSpeed)\n        #endif\n        // make javelin fall\n        #ifdef AUTOAIM\n            vec3 targetPos = enemy.body.position;\n            vec3 javelinDirection = normalize(bulletPos - targetPos);\n            if (gTime < 0.01) {\n                javelinStartDistance = distance(bulletPos, targetPos);\n            }\n            float javelinCurDistance = distance(bulletPos, targetPos);\n            bulletVelocity = bulletVelocity - javelinDirection * gTime * 0.1;\n            //bulletVelocity = max(bulletVelocity - javelinDirection * gTime, bulletVelocity - javelinDirection);\n        #endif\n        \n        bulletPos = bulletVelocity;\n        if (checkProjectileCollision()) shotTime = -1.0;\n    }\n    updateInputData();\n\n    if (ivec2(fragCoord) == TURRET_CASE)\n        fragColor = vec4(turretYaw, gunPitch,0.0,1.0);\n    else if (ivec2(fragCoord) == BULLET_POS_CASE) {\n        fragColor = vec4(bulletPos, 1.0);\n    }\n    else if (ivec2(fragCoord) == BULLET_VELOCITY_CASE) {\n        fragColor = vec4(bulletVelocity, shotTime);\n    }\n    else if (ivec2(fragCoord) == CAMERA_ANGLE_CASE) {\n        fragColor = vec4(cameraYaw, cameraPitch, lastMousePos);\n    }\n    if (ivec2(fragCoord) == JAVELIN_CASE) {\n        fragColor = vec4(javelinStartDistance, 0.0, 0.0, 0.0);\n    }\n    \n    #ifdef EXPLOSION_ROUNDS\n    else {\n        if (ivec2(fragCoord) == BOOM_CRATER_ARRAY_CASE)\n            fragColor = vec4(cratersCount,0.0,0.0,0.0);\n        for (int i = 0; i < cratersCount; i++) {\n            if (ivec2(fragCoord) == BOOM_CRATER_ARRAY_CASE+ivec2(0, i+1)) {\n                fragColor = vec4(cratersPos[i], 0.0);\n            }\n        }\n    }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}