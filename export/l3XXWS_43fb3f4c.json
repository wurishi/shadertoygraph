{"ver":"0.1","info":{"id":"l3XXWS","date":"1709910799","viewed":72,"name":"Diffuse point light shader scene","username":"vlk65536","description":"- Diffuse lighting\n- Multiple objects and light sources\n- Perspective projection calculated from camera's \"root\" (tip of frustrum)\n- Lighting effects to visualise point sources","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"XXfSDB","parentname":"multiple + perspective"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct light {\n    // Direction\n    vec3 d;\n    // Colour\n    vec3 c;\n};\n\nstruct light_point {\n    // Position\n    vec3 P;\n    // Colour\n    vec3 c;\n};\n\nstruct sphere {\n    // Position\n    vec3 P;\n    // Radius\n    float r;\n};\n\nstruct camera {\n    // Position (of root)\n    vec3 P;\n    \n    // Rotation\n    vec3 rot; // Yaw Pitch Roll\n    \n    // Shortest distance from root of camera\n    // to plane of camera\n    float dist;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // TODO: implement \n    camera cam = camera(vec3(0.0,.2*sin(2.1*iTime),0.), vec3(0.), 2.);\n    //cam.dist*vec3(sin(cam.rot.y),0.,cos(cam.rot.y));\n    //vec3(sin(cam.rot.y),0,cos(cam.rot.y));\n    //vec3(cos(cam.rot.y),0,-sin(cam.rot.y));\n    \n    \n    // 3D point on screen\n    vec3 P = vec3(uv,0.0) + cam.P;\n    // Direction camera is looking in\n    vec3 O = vec3(0.0,0.0,-2.) + cam.P;\n    vec3 v = normalize(P-O);\n    \n    // Represent spheres\n    const int b_c = 3; // Amount of spheres\n    sphere balls[b_c] = sphere[b_c](\n        sphere(vec3(cos(iTime*2.0), 0.0, 6.0+sin(iTime*2.0)), 0.2),\n        sphere(vec3(sin(iTime),0.0,.3), 0.2),\n        sphere(vec3(0.5,0.0,2.0+sin(iTime)), 0.2)\n    );\n    float depths[b_c];\n    vec3 sf_n[b_c];\n    vec3 sf_P[b_c];\n       \n    // Array of lights (light(position, colour))\n    light_point lights[] = light_point[](\n        light_point(vec3(0.,0.0,3.0+0.5*sin(iTime/2.)), vec3(1.0,0.0,0.0)),\n        light_point(vec3(cos(iTime),.2,4.), vec3(0.,1.0,1.0)),\n        light_point(balls[0].P + vec3(cos(iTime*4.),1.,sin(iTime*4.)), vec3(0.,1.0,0.0)),\n        light_point(vec3(0.,0.,.2), vec3(1.,0.,1.0))\n    );\n    \n    // Construct ray P+Î»v and intersect with sphere. Solve for lambda\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    // Track whether current fragment hit an object or not\n    bool touch = false;\n    \n    for (int i = 0 ; i<balls.length() ; i++) {\n        sphere ball = balls[i];\n\n        // Calculate value inside square root when calculating lambda\n        float A = dot(v,v);\n        float B = 2.*dot(P-ball.P, v);\n        float C = dot(P-ball.P, P-ball.P) - ball.r*ball.r;\n        float val = B*B-4.*A*C;\n        float lambda = (-B-sqrt(val))/(2.*A); \n        if (val < 0.0 || lambda < 0.0) {\n            depths[i] = 2147483648.;\n            continue;\n        }\n        touch = true;\n        \n        depths[i] = dot(lambda*v,lambda*v);\n        sf_P[i] = P + lambda*v;\n\n        // Find the normal of the sphere at the intersection\n        sf_n[i] = normalize(P+lambda*v-ball.P);\n    }\n    \n    \n    int b_i=0; // Index of closest fragment to camera (depth testing)\n    for (int i = 0; i<balls.length() ; i++) {\n        if (depths[i] < depths[b_i]) {\n            b_i=i;\n        }\n    }\n\n    if (!touch) {\n        // TODO: Spherical mapping\n        col = texture(iChannel0, vec2(atan(v.y*5.),asin(v.x)*5.)/(3.1415)).rgb;\n    }\n    for (int i=0; i<lights.length();i++) {\n        // Find the sine of the angle between the normal and light direction\n        vec3 d = lights[i].P-sf_P[b_i];\n        lights[i].P -= P;\n        \n        // Squared distance to light source\n        float ld = dot(lights[i].P,lights[i].P);\n        \n        // Find angle between view dir and light dir\n        // TODO: lights occupy the same angular space regardless of distance to source\n        float th = acos(dot(normalize(lights[i].P), v));\n\n        float a = dot(sf_n[b_i],normalize(d));\n\n        // Apply colour \n        col += lights[i].c*max(0.0,a);\n        if (!touch || ld < dot(sf_P[b_i],sf_P[b_i])) {\n            col += (lights[i].c*exp(-th*th*1000.0)+1./(10000.*th*th))/(0.05*ld);\n        }\n        \n    }\n   \n    \n    // Gamma correction\n    col = 2.*(1./(1.+exp(-col))-0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nvec3 sphere(vec2 p, vec2 ss, vec3 o, float r) {\n    \n}\n*/","name":"Image","description":"","type":"image"}]}