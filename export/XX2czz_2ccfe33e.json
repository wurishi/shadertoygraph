{"ver":"0.1","info":{"id":"XX2czz","date":"1726863870","viewed":33,"name":"BackPeDEL Retro-reflection","username":"jamiep","description":"A retro-reflective BRDF test-bed, based on \"BRDF Measurements and Analysis of Retroreflective Materials\" by Belcour et. al.\n\nI call this \"BackPeDEL\" based on the authors' names..","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["retroreflection","retroreflective","backpedal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////////\n// Retro-reflective BRDF, \"BackPeDEL\"\n// based on \n//  \"BRDF Measurements and Analysis of Retroreflective Materials\"\n//  Belcour, Pacanowski, Delahaie, Laville-Geay, and Eupherte, INRIA (2014)\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Top:    retro-reflective BRDF\n// Bottom: Lambert, for comparison\n\n// mouse up   -> high roughness\n// mouse down -> low roughness\n\n// VIEW_MODE:\n// ------------------------------\n// 0: eval with adjustable directional light:\n//       - mouse left  -> front illumination (i.e. from behind camera), \n//       - mouse right -> side illumination)\n\n// 1: furnace test (cosine sampling)\n\n\n#define VIEW_MODE 0\n\n#define NDF_MODE 0\n// 0: Beckmann\n// 1: GGX\n\n#define BRDF_MODE 0\n// 0: Retro-reflective conductor\n// 1: Standard conductor\n\n\n/////////////////////////////////////////////////////////\n// Beckmann microfacet model\n/////////////////////////////////////////////////////////\n\n#if NDF_MODE == 0\n\nfloat D_beckmann(in vec3 mL, float r)\n{\n    float t2 = tanTheta2(mL);\n    float c2 = cosTheta2(mL);\n    float r2 = r*r;\n    float epsilon = 1.0e-9;\n    float exponent = t2 / max(r2, epsilon);\n    float D = exp(-exponent) / max(PI*r2*c2*c2, epsilon);\n    return D;\n}\n\nfloat G1_beckmann(in vec3 Vl, in vec3 mL, float r)\n{\n    float tanThetaAbs = abs(tanTheta(Vl));\n    float epsilon = 1.0e-6;\n    if (tanThetaAbs < epsilon) return 1.0;\n    float a = 1.0 / (max(r, epsilon) * tanThetaAbs); \n    if (a >= 1.6) return 1.0;\n    float aSqr = a*a;\n    return (3.535*a + 2.181*aSqr) / (1.0 + 2.276*a + 2.577*aSqr);\n}\n\nfloat G2_beckmann(in vec3 V, in vec3 L, in vec3 m, float r)\n{\n    return G1_beckmann(V, m, r) * G1_beckmann(L, m, r);\n}\n\n#endif\n\n/////////////////////////////////////////////////////////\n// GGX microfacet model\n/////////////////////////////////////////////////////////\n\n#if NDF_MODE == 1\n\nfloat D_ggx(in vec3 mL, float r)\n{\n    float ax = max(r, DENOM_TOLERANCE);\n    float ay = max(r, DENOM_TOLERANCE);\n    float Ddenom = PI * ax * ay * sqr(sqr(mL.x/ax) + sqr(mL.y/ay) + sqr(mL.z));\n    return 1.0 / max(Ddenom, DENOM_TOLERANCE);\n}\n\nfloat ggx_lambda(in vec3 w, float r)\n{\n    if (abs(w.z) < FLT_EPSILON) return 0.0;\n    return (-1.0 + sqrt(1.0 + (sqr(r*w.x) + sqr(r*w.y))/sqr(w.z))) / 2.0;\n}\n\nfloat G2_ggx(in vec3 V, in vec3 L, in vec3 m, float r)\n{\n    return 1.0 / (1.0 + ggx_lambda(V, r) + ggx_lambda(L, r));\n}\n\n#endif\n\n\nvec3 Schlick(vec3 F0, float mu)\n{\n    return F0 + pow(1.0 - mu, 5.0)*(vec3(1.0) - F0);\n}\n\nvec3 FresnelConductorF82(float mu, vec3 F0, vec3 F82)\n{\n    const float mu_bar = 1.0/7.0;\n    const float denom = mu_bar * pow(1.0 - mu_bar, 6.0);\n    vec3 Fschlick_bar = Schlick(F0, mu_bar);\n    vec3 Fschlick     = Schlick(F0, mu);\n    return Fschlick - mu * pow(1.0 - mu, 6.0) * (vec3(1.0) - F82) * Fschlick_bar / denom;\n}\n\nstruct ShaderParams\n{\n    float base_weight;\n    vec3 base_color;\n    float specular_roughness;\n    vec3 specular_color;\n};\n\nvec3 brdf_backpedle(in vec3 V, in vec3 L, in ShaderParams params)\n{\n   vec3 H = normalize(V + L);\n   vec3 Vp = vec3(-V.x, -V.y, V.z);\n   \n#if BRDF_MODE == 0\n   vec3 b = normalize(Vp + L); // use this \"back vector\" instead of H, in D and F\n#else\n   vec3 b = H;\n#endif\n\n   // Fresnel\n   vec3 F0  = params.base_weight * params.base_color;\n   vec3 F82 = params.specular_color;\n   vec3 F = FresnelConductorF82(abs(dot(V, b)), F0, F82);\n   \n   // NDF\n   float r = params.specular_roughness;\n#if NDF_MODE == 0\n   float D = D_beckmann(b, r);\n#elif NDF_MODE == 1\n    float D = D_ggx(b, r);\n#endif\n   \n   // Shadowing-masking term\n#if NDF_MODE == 0\n   float G2 = G2_beckmann(V, L, H, r);\n#elif NDF_MODE == 1\n   float G2 = G2_ggx(V, L, H, r);\n#endif\n   \n   // Jacobian\n   float J = 1.0 / max(4.0*abs(V.z)*abs(L.z), DENOM_TOLERANCE);\n   \n   return J *  F * G2 * D;\n}\n\nvec3 brdf_lambert(in ShaderParams params)\n{\n    vec3 albedo = params.base_weight * params.base_color;\n    return albedo/PI;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    uv = 2.0 * uv - vec2(aspect, 1.0);\n    \n    ShaderParams params;\n    params.base_weight = 1.0;\n    params.specular_roughness = iMouse.y / iResolution.y;\n    params.specular_color = vec3(1.0);\n    \n    // background color\n    vec3 background_col = (VIEW_MODE == 0) ? vec3(0.0) : vec3(0.5);\n    vec3 col;\n\n    float r = dot(uv, uv);\n    if (r < 1.0)\n    {\n        float z = sqrt(1.0 - dot(uv, uv)); // sphere geometry\n        vec3 N = normalize(vec3(uv, z));   // sphere geometry\n        vec3 V = vec3(0.0, 0.0, 1.0);      // ortho camera\n       \n        Basis basis = makeBasis(N);\n        vec3 Vl = worldToLocal(V, basis);\n\n#if VIEW_MODE == 0\n        //////////////////////////////////////////\n        // BRDF evaluation\n        //////////////////////////////////////////\n       \n        params.base_color = vec3(1.0, 0.5, 0.1);\n        \n        float LightIntensity = 3.0;\n        float LightAngle = PI * iMouse.x / iResolution.x;\n        vec3 L = vec3(sin(LightAngle), 0.0, cos(LightAngle));\n        vec3 Ll = worldToLocal(L, basis);\n\n        float NdotL = dot(L, N);\n        float visibility = NdotL > 0.0 ? 1.0 : 0.0;  \n        \n        vec3 f;\n        bool is_top = uv.y >= 0.0;\n        if (is_top)\n            f = brdf_backpedle(Vl, Ll, params);\n        else \n            f = brdf_lambert(params);\n\n        col = visibility * f * abs(NdotL) * LightIntensity;\n\n#elif VIEW_MODE == 1\n        //////////////////////////////////////////\n        // furnace test\n        //////////////////////////////////////////\n\n        params.base_color = vec3(1.0);\n\n        uint rndSeed = uint(fragCoord.x + fragCoord.y*iResolution.x);\n        xorshift(rndSeed);\n        rndSeed ^= uint(iFrame);\n\n        vec3 albedo = vec3(0.0);\n        const uint Nsamples = 256u;\n        for (uint n=0u; n<Nsamples; n++)\n        {\n            float Lpdf;\n            vec3 Ll = sampleHemisphereCosineWeighted(rndSeed, Lpdf);\n            float NdotL = Ll.z;\n            if (NdotL < 0.0)\n                continue;\n\n            vec3 f;\n            bool is_top = uv.y >= 0.0;\n            if (is_top)\n                f = brdf_backpedle(Vl, Ll, params);\n            else \n                f = brdf_lambert(params);\n                \n            albedo += background_col * f * abs(NdotL) / Lpdf;\n        }\n        \n        albedo /= float(Nsamples);\n        col = albedo;\n\n#endif\n    }\n    else\n        col = background_col;\n    \n    // tone mapping\n    fragColor = vec4(tonemap(col), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//////////////////////////////////////////////////////\n// useful constants\n//////////////////////////////////////////////////////\n\n\nconst float PI                    = 3.141592653589793;\nconst float PI2                   = 6.283185307179586;\nconst float PI_HALF               = 1.5707963267948966;\nconst float RECIPROCAL_PI         = 0.3183098861837907;\nconst float RECIPROCAL_PI2        = 0.15915494309189535;\n\n// tolerances\nconst float HUGE_DIST             = 1.0e20;\nconst float RAY_OFFSET            = 1.0e-4;\nconst float DENOM_TOLERANCE       = 1.0e-10;\nconst float RADIANCE_EPSILON      = 1.0e-12;\nconst float TRANSMITTANCE_EPSILON = 1.0e-4;\nconst float THROUGHPUT_EPSILON    = 1.0e-6;\nconst float PDF_EPSILON           = 1.0e-6;\nconst float IOR_EPSILON           = 1.0e-5;\nconst float FLT_EPSILON           = 1.1920929e-7;\n\n\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nvoid xorshift(inout uint seed)\n{\n    // https://en.wikipedia.org/wiki/Xorshift\n    seed ^= seed << 13u;\n    seed ^= seed >> 17u;\n    seed ^= seed << 5u;\n}\n\nfloat rand(inout uint seed)\n{\n    seed = pcg(seed);\n    const float uint_range = 1.0 / float(0xFFFFFFFFU);\n    return float(seed - 1U) * uint_range;\n}\n\n// Do cosine-weighted sampling of hemisphere\nvec3 sampleHemisphereCosineWeighted(inout uint rndSeed, inout float pdf)\n{\n    float r = sqrt(rand(rndSeed));\n    float theta = 2.0 * PI * rand(rndSeed);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    float z = sqrt(max(0.0, 1.0 - x*x - y*y));\n    pdf = max(PDF_EPSILON, abs(z) / PI);\n    return vec3(x, y, z);\n}\n\nvec3 tonemap(vec3 c)\n{\n    // http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    vec3 x = max(vec3(0.0),c-vec3(0.004));\n    return (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\n/////////////////////////////////////////////////////\n// utils\n/////////////////////////////////////////////////////\n\nvec3 safe_normalize(in vec3 N)\n{\n    float l = length(N);\n    return N/max(l, DENOM_TOLERANCE);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sqr(float x)              { return x*x; }\nfloat cosTheta2(in vec3 nLocal) { return nLocal.z*nLocal.z; }\nfloat cosTheta(in vec3 nLocal)  { return nLocal.z; }\nfloat sinTheta2(in vec3 nLocal) { return 1.0 - cosTheta2(nLocal); }\nfloat sinTheta(in vec3 nLocal)  { return sqrt(max(0.0, sinTheta2(nLocal))); }\nfloat tanTheta2(in vec3 nLocal) { float ct2 = cosTheta2(nLocal); return max(0.0, 1.0 - ct2) / max(ct2, DENOM_TOLERANCE); }\nfloat tanTheta(in vec3 nLocal)  { return sqrt(max(0.0, tanTheta2(nLocal))); }\n\nstruct Basis\n{\n    // right-handed coordinate system\n    vec3 nW; // aligned with the z-axis in local space\n    vec3 tW; // aligned with the x-axis in local space\n    vec3 bW; // aligned with the y-axis in local space\n};\n\nvec3 normalToTangent(in vec3 N)\n{\n    vec3 T;\n    if (abs(N.z) < abs(N.x))\n        T = vec3(N.z, 0.0, -N.x);\n    else\n        T = vec3(0.0, N.z, -N.y);\n    T = safe_normalize(T);\n    return T;\n}\n\nBasis makeBasis(in vec3 nW)\n{\n    Basis basis;\n    basis.nW = safe_normalize(nW);\n    basis.tW = normalToTangent(nW);\n    basis.bW = cross(basis.nW, basis.tW);\n    return basis;\n}\n\nvec3 worldToLocal(in vec3 vWorld, in Basis basis)\n{\n    return vec3( dot(vWorld, basis.tW),\n                 dot(vWorld, basis.bW),\n                 dot(vWorld, basis.nW) );\n}\n","name":"Common","description":"","type":"common"}]}