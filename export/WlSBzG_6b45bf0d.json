{"ver":"0.1","info":{"id":"WlSBzG","date":"1599157843","viewed":133,"name":" PBR stream sample","username":"Shcherbakov","description":"Семпл по PBR со второго стрима.\nStream: https://www.youtube.com/watch?v=AkJjbn1erPU","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FAR_INF = 1e10;\n\nfloat spheres_raycast(vec3 origin, vec3 dir, vec3 spherePos) {\n    vec3 sphereToCam = origin - spherePos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - 0.35 * 0.35;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nbool sphere_params(vec3 origin, vec3 dir, vec3 spherePos, inout float dist, out vec3 interPos, out vec3 interNorm) {\n    float d = spheres_raycast(origin, dir, spherePos);\n    if (d < dist) {\n        dist = d;\n        interPos = origin + dist * dir;\n        interNorm = normalize(interPos - spherePos);   \n        return true;\n    }\n    return false;\n}\n\nvec3 fresnel(vec3 F0, float cosTheta)\n{\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat ndfGGX(float cosLh, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (3.14 * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k)\n{\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaGGX(float cosLi, float cosLo, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -10);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1));\n    \n    float interDist = FAR_INF;\n    vec3 worldPos;\n    vec3 normal;\n    int halfCols = 4;\n    int halfRows = 2;\n    vec3 sphereColor = vec3(0, 0.5, 0.5);\n    vec3 lighting;\n    const float LIGHT_RAD = 8.0;\n    vec3 lightPos = vec3(LIGHT_RAD * sin(iTime), 0, LIGHT_RAD * cos(iTime));\n    float roughness;\n    float metalness;\n    for (int x = -halfCols; x <= halfCols; ++x) {\n        for (int y = -halfRows; y <= halfRows; ++y) {\n            if (sphere_params(cameraPos, viewVec, vec3(x, y, 0), interDist, worldPos, normal)) {\n                roughness = float(x + halfCols) / float(halfCols * 2 + 2) + 1e-5;\n                metalness = float(y + halfRows) / float(halfRows * 2 + 2) + 1e-5;\n            }\n        }\n    }\n    if (interDist < FAR_INF) {\n        sphereColor = texture(iChannel1, normal).rgb * vec3(0.1, 0.5, 0.5);\n        \n        const float F_DI = 0.04;\n        vec3 N = normal;\n        vec3 V = -viewVec;\n        vec3 toLight = lightPos - worldPos;\n        float atten = 1.0 / length(toLight);\n        vec3 L = toLight * atten;\n        atten *= 25.0;\n        vec3 H = normalize(V + L);\n        vec3 R = reflect(V, N);\n        vec3 F0 = mix(vec3(F_DI), sphereColor, metalness);\n        float NoV = max(dot(N, V), 0.0);\n        float NoL = max(dot(N, L), 0.0);\n        float HoL = max(dot(L, H), 0.0);\n        float NoH = max(dot(N, H), 0.0);\n        \n        vec3 F = fresnel(F0, HoL);\n        float D = ndfGGX(NoH, roughness);\n        float G = gaGGX(NoL, NoV, roughness);\n        \n        vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n        vec3 specularBRDF = F * D * G / max(1e-5, 4.0 * NoL * NoV);\n        vec3 diffuseBRDF = kd * sphereColor;\n        \n        lighting = (specularBRDF + diffuseBRDF) * NoL * atten;\n        \n        F = fresnel(F0, NoV);\n        kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n        vec3 ambDiffuse = textureLod(iChannel0, R, 10.0).rgb;\n        vec3 ambSpecular = textureLod(iChannel0, R, roughness * 10.0).rgb * 0.2;\n        lighting += ambDiffuse * kd * sphereColor + ambSpecular;\n    } else {\n        vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \tvec3 viewVec = normalize(vec3(uv, 1));\n        lighting = texture(iChannel0, viewVec).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(lighting,1.0);\n}","name":"Image","description":"","type":"image"}]}