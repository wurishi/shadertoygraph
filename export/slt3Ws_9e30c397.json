{"ver":"0.1","info":{"id":"slt3Ws","date":"1636994356","viewed":117,"name":"Whose Lollipop","username":"LuncyTB","description":"Simple twice sampled ray stepping scene.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"7tdGWl","parentname":"sdf learn"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright (c) 2021 LuncyTB. All rights reserved.\n */\n\n#define MAX_DIS 100.0\n#define MAX_STEP 64\n#define MIN_DIS 0.01\n\nvec3 sun = normalize(vec3(-3., -8., 4.));\nvec3 sunCol = vec3(1., .97, .92) * 1.2;\n\nstruct mater\n{\n    vec3 col;\n    float smoth;\n    float metlc; // Not supported\n    vec3 emiss; // Not supported\n};\n\nstruct idf\n{\n    float f;\n    int id;\n};\n\nfloat sdSphere(in vec3 pos, in float r)\n{\n    return length(pos) - r;\n}\n\nfloat sdDnut(in vec3 pos, in float r, in float r2)\n{\n    return length(vec2(length(pos.xz) - r, pos.y)) - r2;\n}\n\nfloat sdClind(in vec3 pos, in float r, in float h)\n{\n    float l = length(pos.xz);\n    float t = abs(pos.y);\n    if (t < h)\n    {\n        if (l > r)\n        {\n            return l - r;\n        }\n        else\n        {\n            return max(l - r, t - h);\n        }\n    }\n    else\n    {\n        if (l > r)\n        {\n            return length(vec2(l - r, t - h));\n        }\n        else\n        {\n            return t - h;\n        }\n    }\n}\n\nfloat mmin(in float a, in float b)\n{\n    float lerp = a > b ? pow(4.0, b - a) / 2. : 1. - pow(4.0, a - b) / 2.;\n    return min(a, b);\n}\n\nidf idmin(in idf a, in idf b)\n{\n    idf c;\n    if (a.f < b.f) c = a;\n    else c = b;\n    return c;\n}\n\nfloat scene(in vec3 pos)\n{\n    float d = MAX_DIS;\n    \n    d = mmin(sdSphere(pos - vec3(-.2, -.4, 3.), 1.), d);\n    d = mmin(sdDnut(pos - vec3(-1., -0.7, 4.), 1.9, 0.2), d);\n    d = mmin(sdSphere(pos - vec3(0.4, 0.4, 2.), 0.3), d);\n    d = mmin(sdClind(pos - vec3(1.5, -0.2, 2.4), 0.4, 0.6), d);\n    d = mmin(sdClind(pos - vec3(0.4, 0.05, 2.), 0.1, 0.6), d);\n    \n    return d;\n}\n\nidf getId(in vec3 pos)\n{\n    idf d = idf(MAX_DIS, 0);\n    \n    d = idmin(idf(sdSphere(pos - vec3(-.2, -.4, 3.), 1.), 2), d);\n    d = idmin(idf(sdDnut(pos - vec3(-1., -0.7, 4.), 1.9, 0.2), 1), d);\n    d = idmin(idf(sdSphere(pos - vec3(0.4, 0.4, 2.), 0.3), 1), d);\n    d = idmin(idf(sdClind(pos - vec3(1.5, -0.2, 2.4), 0.4, 0.6), 2), d);\n    d = idmin(idf(sdClind(pos - vec3(0.4, 0.05, 2.), 0.1, 0.6), 3), d);\n\n    return d;\n}\n\nfloat rayMarch(in vec3 org, in vec3 dir, in float min_dis, in int steps)\n{\n    float d = min_dis * 3.;\n    for (int i = 0; i < steps; i++)\n    {\n        float space = scene(org + dir * d);\n        d += space;\n        if (space < min_dis) break;\n    }\n    return d;\n}\n\nvec3 calNormal(in vec3 pos)\n{\n    vec2 e = vec2(MIN_DIS, 0.);\n    return normalize(\n        scene(pos) - vec3(scene(pos - e.xyy), scene(pos - e.yxy), scene(pos - e.yyx))\n        );\n}\n\nfloat random(float n) {\n    return fract(iTime * 0.23781 + sin(n) * 1000000.);\n}\n\nvec3 rand3(vec3 pos)\n{\n    return normalize(vec3(random(pos.x + cos(pos.z) + sin(pos.y)) - 0.5, \n        random(pos.y + cos(pos.x) + sin(pos.z)) - 0.5, \n        random(pos.z + cos(pos.y) + sin(pos.x)) - 0.5));\n}\n\nfloat calSun(in vec3 pos, in int sam)\n{\n    vec3 sm4[4];\n    sm4[0] = vec3(0.3, 1.5, 0.771);\n    sm4[1] = vec3(-4.31, 2.13, 0.423);\n    sm4[2] = vec3(9.74, 0.6491, -3.771);\n    sm4[3] = vec3(4.8191, -7.342, 0.123);\n\n    float d = 0.0;\n\n    for (int si = 0; si < sam; si += 1) {\n        float z = rayMarch(pos, -sun + rand3(pos + sm4[si]) * 0.1, MIN_DIS * 4., MAX_STEP / 4);\n        if (z < MAX_DIS)\n            d += 0.0;\n        else d += 1.0;\n    }\n\n    return d / float(sam);\n}\n\nvec3 _sky(vec3 ray, vec3 sun) {\n    float _r = atan(ray.x, ray.z);\n    float _u = atan(ray.y, length(ray.xz));\n    float split = clamp(0.5 + 1.5 * pow(abs(_u), 0.8) * sign(_u), 0.0, 1.0);\n    vec2 guv = ray.xz / ray.y * 2.0;\n    vec3 ground = mix(vec3(0.25, 0.31, 0.3), vec3(0.6, 0.58, 0.56),\n        clamp(pow(abs(4.0 * (fract(guv.x) - 0.5) * (fract(guv.y) - 0.5)), 0.1), 0.0, 1.0));\n    return mix(ground * sun, vec3(0.4, 0.5, 0.7), split);\n    return mix(vec3(pow(abs(cos(_r * 5.3)), 0.5) * 0.5 + 0.5, pow(abs(sin(_u * 5.3)), 0.4) * 0.5 + 0.5, 1.0), vec3(0.7), 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mater ms[10];\n    ms[1] = mater(vec3(1., 0.6, 0.4), 0.3, 0.1, vec3(0.));\n    ms[2] = mater(vec3(0.4, 0.6, 0.97), 0.98, 0.1, vec3(0.));\n    ms[3] = mater(vec3(0.98, 0.87, 0.71), 0.7, 0.1, vec3(0.));\n\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(uv, 0.7));\n    vec3 eye = vec3(0.0, cos(iTime), 0.0);\n    \n    \n    float z = rayMarch(eye, ray, MIN_DIS, MAX_STEP);\n    vec3 col;\n    \n    if (z >= MAX_DIS) col = texture(iChannel0, ray).xyz;\n    // if (z >= MAX_DIS) col = _sky(ray, sunCol);\n    else\n    {\n        \n        vec3 normal = calNormal(eye + ray * z);\n        int mid = getId(eye + ray * z).id;\n        vec3 pos = eye + ray * z;\n\n        col = max(0., dot(sun, -normal)) * sunCol * ms[mid].col * calSun(eye + ray * z, 4);\n\n        vec3 sm4[4];\n        sm4[0] = vec3(0.3, 1.5, 0.771);\n        sm4[1] = vec3(-4.31, 2.13, 0.423);\n        sm4[2] = vec3(9.74, 0.6491, -3.771);\n        sm4[3] = vec3(4.8191, -7.342, 0.123);\n\n        vec3 rcol = vec3(0.0);\n        for (int smi = 0; smi < 4; smi += 1) {\n            vec3 ref = reflect(ray, normal + (1. - ms[mid].smoth) * rand3(pos + sm4[smi]));\n            float z2 = rayMarch(pos, ref, MIN_DIS * 2., MAX_STEP / 2);\n        \n            if (z2 >= MAX_DIS / 2.) rcol += texture(iChannel0, ref).xyz * ms[mid].col;\n            // if (z2 >= MAX_DIS / 2.) rcol += _sky(ref, sunCol) * ms[mid].col;\n            else\n            {\n                vec3 normal2 = calNormal(pos + ref * z2);\n                int mid2 = getId(pos + ref * z2).id;\n                vec3 ref2 = reflect(ref, normal2 + (1. - ms[mid2].smoth) * rand3(pos + ref * z2));\n                rcol += max(0., dot(sun, -normal2)) * sunCol * ms[mid2].col * ms[mid].col * 0.5;\n                rcol += texture(iChannel0, ref2).xyz * ms[mid2].col * ms[mid].col * 0.5;\n                // rcol += _sky(ref2, sunCol) * ms[mid2].col * ms[mid].col * 0.5;\n            }\n        }\n        \n        col += rcol / 4.0;\n        \n    }\n    \n    col.r = pow(col.r, 1.5);\n    col.g = pow(col.g, 1.3);\n    col.b = pow(col.b, 1.3);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}