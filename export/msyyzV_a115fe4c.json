{"ver":"0.1","info":{"id":"msyyzV","date":"1696329537","viewed":89,"name":"Zoomable Stars Skysphere","username":"sdfgeoff","description":"An interesting thing about stars is that the light from this is paralllel because they are so far away. This means that if you zoom in on them ... they stay the same angular size. This makes it hard to generate skyboxes of stars where the camera can zoom.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["basic","sky"],"hasliked":0,"parentid":"ctjXWD","parentname":"Sphere World Background"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nI'm building a semi-realistic space game and discovered that a skybox looks terrible\nwhen you are using a telescope with a lens angle of 1 degree. You just\ncan't get enough resolution out of a skybox. So how to render stars in such a way\nthat you can zoom in on them?\n\nAn interesting thing about stars is that the light is paralllel because they are\nso far away. This means that (almost) no matter how far you zoom in on \nthem ... they stay the same angular size.\n\nHere's my attempt to render this. By scaling the stars as you zoom,\nyou can keep the brightness constant. There are two interesting effects\nI noticed:\n - As you zoom out you see more stars at the same brightness, so the scene\n   gets visually lighter. This is the opposite to \"normal\" where a bright object\n   occupies more of the scene as you zoom in. I correct for this by tweaking\n   the camera's exposure which has the nice property of seeing\n   more stars as you zoom in. \n   The same applies to higher resolution screens. A higher resolution screen\n   has more pixels with fewer lit.\n - Mostly you don't have to worry about the stars aliasing as they stay the same size\n   on screen.\n \nPlacing stars randomly on a sphere is hard, so I did a weird clamped-voroni\nthing. It works, but there are a few edge cases (you get some very small cells which\ncan cause flickering).\nIf anyone has ideas about how to place stars on a sphere I am totally\nkeen to hear it. I wonder if a skybox grid would be better? \n\nI was hoping for more stars. I was hoping for whole galaxies I could zoom in on, but\nthis approach doesn't work for that yet due to the voroni grid. I think some\nother space-partitioning approach could work - or you could possibly fade between voroni\nsizes as you zoom.\n\n - sdfgeoff\n*/\n\nconst float PI = 3.14159;\n\nconst float MAJOR_LINES = 6.0;\nconst float MAJOR_LINE_WIDTH = MAJOR_LINES * 0.002;\nconst float MINOR_LINES = MAJOR_LINES * 5.0;\nconst float MINOR_LINE_WIDTH = MINOR_LINES * 0.001;\nconst float MAJOR_LINE_INTENSITY = 0.2;\nconst float MINOR_LINE_INTENSITY = 0.1;\n\n// How many stars in the sky?\n// This defines the density of the voroni grid. Higher numbers are more stars\n// but also more likely to be flickering between malformed cells\nconst float STAR_DENSITY = 70.0;\n\n// How large should a star be?\nconst float STAR_RADIUS = 0.15;\n\n// Higher = fewer bright stars\nconst float STAR_GAMMA = 20.0;\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n\nfloat sphere_lines(float angle, float elevation) {\n    float lines = 0.0;\n    lines += clamp((abs(fract(elevation / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) /  MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) / MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(elevation / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) /  MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) / MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    return lines;\n}\n\n\n\n/// Returns the distance to the cell point\nvec4 voroni(vec3 position) {\n    vec4 min_dist = vec4(100.0, 0.0, 0.0, 0.0);\n    float sphereRadius = length(position);\n\n    for (float i=-1.0; i<=1.0; i+=1.0) {\n        for (float j=-1.0; j<=1.0; j+=1.0) {\n            for (float k=-1.0; k<=1.0; k+=1.0) {\n                \n                vec3 this_cell_id = floor(position) + 0.5 + vec3(i, j, k);\n                vec3 this_cell_offset = hash33(this_cell_id);\n                vec3 this_cell_point = this_cell_id + this_cell_offset * 2.0 - 1.0;\n                \n                // Clamp to sphere\n                float moveRatio = sphereRadius / length(this_cell_point);\n    \n                this_cell_point = this_cell_point * moveRatio ;\n\n\n                vec3 offset_vec = position - this_cell_point;\n                float dist_to_this_cell_point = length(offset_vec);\n                if (dist_to_this_cell_point < min_dist.x) {\n                    min_dist = vec4(\n                        dist_to_this_cell_point,\n                        this_cell_offset\n                    );\n                }\n                \n            }\n        }\n    }\n    return min_dist;\n}\n\nvec3 stars(vec3 rayDirection, float scalefac, float lens) {\n    vec4 data = voroni(rayDirection);\n    float dist = data.x * iResolution.y * STAR_RADIUS;\n    float radius = max(1.0 - dist / scalefac / lens, 0.0);\n    \n    float intensity = pow(radius, 4.0); // Falloff - bright in center\n    intensity *= pow(data.y, STAR_GAMMA); // more dim stars than bright ones\n    \n    return intensity * mix(\n        vec3(0.8, 0.5, 0.0),\n        vec3(0.4, 0.4, 0.8),\n        pow(data.z, 2.0) // more red stars than blue ones\n    ) * 4.0;\n}\n\n\n\nvec3 world_background(vec3 rayDirection, float lens) {\n    vec3 col = vec3(0.0);\n    col += stars(rayDirection * STAR_DENSITY, STAR_DENSITY, lens);\n    \n    // Increase Exposure as zoom in\n    col *= (0.3 / lens);\n\n    float r2 = dot(rayDirection.xy, rayDirection.xy);\n    float elevation = acos(rayDirection.z / sqrt(r2 + rayDirection.z * rayDirection.z));\n    float angle = atan(rayDirection.y, rayDirection.x);\n    \n    float lines = sphere_lines(angle, elevation);\n\n    return col + lines;\n}\n\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n\tfloat hA = angle * 0.5;\n\tfloat s = sin(hA);\n\tfloat c = cos(hA);\n\treturn vec4(axis*s, c);\n}\n\nvec4 QuatMul(vec4 q, vec4 r)\n{\n\tvec4 nq;\n\tnq.x = q.w * r.x + q.x * r.w + q.y * r.z - q.z * r.y;\n\tnq.y = q.w * r.y - q.x * r.z + q.y * r.w + q.z * r.x;\n\tnq.z = q.w * r.z + q.z * r.w - q.y * r.x + q.x * r.y;\n\tnq.w = q.w * r.w - q.x * r.x - q.y * r.y - q.z * r.z;\n\treturn nq;\n}\n\nmat4 QuatToMat(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat4(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),0.,2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),0.,2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy),0.,0.,0.,0.,1.);\n}\n\nmat3 QuatToMat3(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat3(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy));\n}\n\nmat4 createCameraRotationMatrix(vec2 vSUV)\n{\n\tvec4 u = QuatFromAxisAngle(vec3(0., 0., 1.), vSUV.x);\n\tvec4 v = QuatFromAxisAngle(QuatToMat3(u) * vec3(1., 0., 0.), vSUV.y);\n\treturn QuatToMat(QuatMul(u,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Render our geometry\n    vec2 vSphericalUV = (iMouse.xy / iResolution.xy) * 4.0;\n    vSphericalUV.y = clamp(vSphericalUV.y,0.,PI);              //Clamp to avoid upside down camera.\n    mat4 camera_transform = createCameraRotationMatrix(vSphericalUV);\n    \n    vec3 start_point = camera_transform[3].xyz;\n    \n    float LENS = sin(iTime) * 0.3 + 0.31;\n\n    vec3 direction = normalize(vec3(uv * LENS, 1.0));\n    direction = (camera_transform * vec4(direction, 0.0)).xyz;\n\n    // Output to screen\n    fragColor = vec4(world_background(direction, LENS),1.0);\n}","name":"Image","description":"","type":"image"}]}