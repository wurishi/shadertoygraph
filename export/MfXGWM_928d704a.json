{"ver":"0.1","info":{"id":"MfXGWM","date":"1703111042","viewed":55,"name":"Solar Maze","username":"brunorealities","description":"Solar Mazeâ€™ is a spiral, fractal-inspired shader generating a labyrinth of golden light. It utilizes raymarching and iterative algorithms to create an endlessly complex pattern.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","spiral","labyrinth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Inspired and based on my learnings of Kishimisu tutorials about shader art coding\n\n\n//Palette\n\nvec3 pal(in float t) {\n    vec3 a =  vec3(0.706,0.549,0.275);// Updated color 1\n    vec3 b = vec3(0.686,0.812,0.851); // Updated color 2\n    vec3 c = vec3(0.910,0.549,0.188); // Updated color 3\n    vec3 d = vec3(0.631,0.659,0.667);  // Updated color 4\n  \n \n    // Return the color by applying a cosine function to create smooth transitions between colors\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n\n//Rotation\nmat2 rot2D(float angle)\n{\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn mat2(c,-s,s,c);\n}\n//from Inigo Quilez 3D SDF Functions\nfloat smin(float a, float b, float k) {\nfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\nreturn mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\nvec3 q = abs(p) - b;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n//Distance to the scene\nfloat map(vec3 p)\n{\np.z -= iTime * .4;\n\np.xy = (fract(p.xy) - .5);\np.z = mod(p.z, .25) - .15;\n\nfloat octa = sdOctahedron(p, .15);\n\nreturn octa;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Normalized pixel coordinates (from 0 to 1)\nvec2 uv = (fragCoord *2. - iResolution.xy)/iResolution.y;\nvec2 m = (iMouse.xy * 2. - iResolution.xy)/iResolution.y;\n//initialization\n\nvec3 ro = vec3(0.0,0.,-3.);   //ray origin\nvec3 rd = normalize(vec3(uv,1.));      //ray direction\nvec3 col = vec3(0.);\nfloat t = 0.; //distance travelled\n\n //Vertical camera rotation\n//ro.yz *= rot2D(-m.y);\n//rd.yz *= rot2D(-m.y);\n\n//Horizontal camera rotation\n//ro.xz *= rot2D(-m.x);\n//rd.xz *= rot2D(-m.x);\n\n//Mouse is not clicked, default motion\nif(iMouse.z < 0.) m = vec2(cos(iTime * .2), sin(iTime *.2));\n\n//ray marching\nint i; \nfor(int i = 0; i < 80; i++)\n{\n\n   vec3 p = ro + rd * t; //position along the ray\n   \n   p.xy *= rot2D(t*.44 * m.x * .1);\n   \n   p.y += sin(t*(m.y * 1.)*.5)*.45; //distortion\n   \n float d = map(p); //current distance to the scene\n t += d; //\"march\" the ray\n\n if(d < 0.001 || t > 100.)break; //early stop\n\n}\n\n\ncol = pal(t * 0.02 + float(i)*.005);  //color based on distance\n//col = vec3(t * 0.4);\n\nfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}