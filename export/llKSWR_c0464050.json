{"ver":"0.1","info":{"id":"llKSWR","date":"1485046652","viewed":577,"name":"PrototypeTerrain","username":"jjcoolkl","description":"Simple procedural canyon with faked thermal erosion.  Work in progress.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["procedural","wip","canyon","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nPress space to restart.\n*/\n\nvec3 GetWorldSize()\n{\n    return vec3( iResolution.xy / 64.0, 1.0 );\n}\n\n#define ZOOM 8.0\n#define H_FOV_RADIANS 0.5785\n#define FIXED_STEPS 128.0\n#define BINARY_STEPS 32.0\n\n// Trace ray to get intersection point\nvec2 TraceRay( vec3 v3Start, vec3 v3End )\n{    \n    float iBelow = FIXED_STEPS;\n    \n    vec3 delta = (v3End - v3Start) / FIXED_STEPS;\n    for( float i = 0.0; i < FIXED_STEPS; ++i )\n    {\n        vec3 pos = v3Start + i * delta;\n        vec4 v4Curr = texture( iChannel0, pos.xy );\n        if( v4Curr.x + v4Curr.y > pos.z )\n        {\n            iBelow = min( iBelow, i );\n        }\n    }\n    \n    vec3 v3Min = v3Start + iBelow * delta;\n    vec3 v3Max = v3Min - delta;\n    for( float i = 0.0; i < BINARY_STEPS; ++i )\n    {\n        vec3 v3Center = (v3Min + v3Max) * 0.5;\n        vec4 v4Curr = texture( iChannel0, v3Center.xy );\n        (v4Curr.x + v4Curr.y) > v3Center.z ? v3Min = v3Center : v3Max = v3Center;\n    }\n    \n    return v3Min.xy;\n}\n\n\n// Camera management\nvec3 GetCameraPos()\n{\n    vec2 v2Mouse = vec2( iMouse.xy / iResolution.xy ) * 10.0;\n    vec3 v3Pos = vec3(\n        sin(v2Mouse.x + iTime*.1), \n        cos(v2Mouse.x + iTime*.1), 1.0 );\n    \n    return normalize( v3Pos ) * ZOOM;\n}\nvec3 GetLookDir( vec3 v3CameraPos, vec2 fragCoord )\n{\n    float fScale = tan( H_FOV_RADIANS );\n    float fAspectRatio = iResolution.x / iResolution.y;\n\tvec2 v2Screen = (2.0 * (fragCoord.xy / iResolution.xy) - 1.0) * vec2(fAspectRatio, 1.0) * fScale;\n   \n    vec3 v3Up = vec3(0.0, 0.0, 1.0);\n    vec3 v3Look = normalize( -v3CameraPos );\n    vec3 v3Left = cross( v3Up, v3Look );\n    v3Up = cross( v3Look, v3Left );\n    \n    v3Look += v3Left * v2Screen.x + v3Up * v2Screen.y;\n\treturn normalize( v3Look );\n}\n\n// Lighting\nvec3 Light(vec2 v2Loc)\n{  \n    vec3 v3LightDir = normalize( vec3(.5,.5,.5) );\n    vec3 v3Normal = normalize( vec3( texture( iChannel1, v2Loc ).xy * 2.0 - 1.0, 1.0) );\n    \n    float fDot = dot( v3Normal, v3LightDir );\n    vec3 ambient = vec3(.2,.2,.2);\n    vec3 light = vec3(.5,.5,.5) * clamp( fDot, 0.0, 1.0 );\n    \n    return ambient + light;\n}\n\nvoid mainImage( out vec4 outColor, in vec2 inPixel )\n{\n    vec3 v3WorldSize = GetWorldSize();\n    vec2 v2WorldMin = -v3WorldSize.xy * 0.5;\n    vec2 v2WorldMax = -v2WorldMin;\n    \n    vec3 v3Camera = GetCameraPos();\n    vec3 v3LookDir = GetLookDir( v3Camera, inPixel);\n    \n    outColor = vec4( .3,.3,.3, 1.0 );\n    \n    vec3 v3A = v3Camera + v3LookDir * (2.0-v3Camera.z) / v3LookDir.z;\n    vec3 v3B = v3Camera + v3LookDir * (0.0-v3Camera.z) / v3LookDir.z;\n    \n    //Trace in normalized coordinates\n    vec3 v3TraceA = vec3( v3A.xy / v3WorldSize.xy + vec2(0.5,0.5), v3A.z );\n    vec3 v3TraceB = vec3( v3B.xy / v3WorldSize.xy + vec2(0.5,0.5), v3B.z );\n    vec2 v2Pos = TraceRay( v3TraceA, v3TraceB );\n    \n    if( v2Pos.x > 0.0 && v2Pos.x < 1.0 )\n    if( v2Pos.y > 0.0 && v2Pos.y < 1.0 )\n    {\n        vec3 v3Light = Light( v2Pos );\n        outColor.xyz = v3Light;\n    \t//vec4 groundColor =  texture( iChannel0, v2Pos ).xxxw;\n        //float fGround = 1.0;\n    \t//outColor = outColor * (1.0 - fGround) + groundColor * fGround;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nvec3 GetWorldSize()\n{\n    return vec3( iResolution.xy / 64.0, 1.0 );\n}\n\n\n//BEGIN\n// Noise from iq: https://www.shadertoy.com/view/4dlGDN\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// polynomial smooth min (k = 0.1);\n//From https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//END\n\nfloat Smoothstep( float fX )\n{\n    fX = clamp(fX, 0.0, 1.0);\n    return fX*fX*(3.0 - 2.0*fX);\n}\n\nfloat Turbulence( vec2 uv, vec2 v2Scale, vec2 v2Height )\n{\n    float fRet = 0.0;\n    for( int i = 0; i < 16; ++i )\n    {\n        fRet += noise( uv * v2Scale.x ) * v2Height.x;\n        \n        v2Scale.x *= v2Scale.y;\n        v2Height.x *= v2Height.y;\n    }\n    \n    return fRet;\n}\n\nfloat GetHeight( vec2 uv )\n{\n    float fBaseHeight = 0.1;\n    float fFissureHeight = .8;\n    \n    float fCanyonWall;\n    {\n        float fOffX = GetWorldSize().x * 0.5;\n        \n        float fT0 = Turbulence( uv, vec2(1.0, 2.0), vec2(.5, .5 ) );\n        float fT1 = Turbulence( uv + vec2(34234,0), vec2(1.0, 2.0), vec2(.5, .5 ) );\n        \n        vec2 uv2 = uv + vec2(fT0, fT1);\n        float fTower = smin( .2 + noise( uv2 * 1.5 ) * 1.0, 1.0, 0.2) * .9;\n        \n    \tfloat fX = abs( uv.x - fOffX ) + fT0;\n    \tfCanyonWall = smin( fTower, Smoothstep( fX * .5 - 1.0 ), -.1 );\n    \tfCanyonWall = pow( fCanyonWall, 7.0 );\n    \tfCanyonWall = fCanyonWall + fFissureHeight;\n        \n        fCanyonWall += noise( uv / 2.0 ) * 0.5;\n    }\n    \n    float fFissure = 5.0;\n    {\n        float fT = Turbulence( uv, vec2(.5,2.0), vec2(1.0,.5) );\n        float fOffX = fT + uv.x - GetWorldSize().x * 0.5;\n        float fX = abs( fOffX );\n    \tfFissure = smin( pow( fX * .4 + 0.6, 2.0), fX * 1.2, .1 );\n    \tfFissure = pow( fFissure, 4.0 );\n        fFissure = fFissure * (fFissureHeight - fBaseHeight);\n    }\n    \n    float fHeight = smin( fCanyonWall, fFissure, .5 ); \n    \n    //fHeight += noise( uv * 50.0 ) * 0.01;\n    \n    return fHeight;\n}\n\n\n//-----------------------------------------------\n//-----------------------------------------------\nvec2 CalculateThermalErosion(vec2 uv)\n{\n    vec2 delta = vec2(1,1) / iResolution.xy;\n    \n    //9-grid\n    // 00 | 10 | 20\n    // ---+----+---\n    // 01 | 11 | 21\n    // ---+----+---\n    // 02 | 12 | 22\n    \n    #define EDGE_DELTA .01\n    #define CORNER_DELTA (EDGE_DELTA * sqrt(2.0))\n    #define OFFSET(X) vec2(.0085 * (noise(X*10.0)*.5 + .5),0.0)\n    \n    vec2 uv_00 = uv + delta * vec2(-1,-1);\n    vec2 uv_10 = uv + delta * vec2(-1, 0);\n    vec2 uv_20 = uv + delta * vec2(-1, 1);\n    \n    vec2 uv_01 = uv + delta * vec2( 0,-1);\n    vec2 uv_11 = uv + delta * vec2( 0, 0);\n    vec2 uv_21 = uv + delta * vec2( 0, 1);\n    \n    vec2 uv_02 = uv + delta * vec2( 1,-1);\n    vec2 uv_12 = uv + delta * vec2( 1, 0);\n    vec2 uv_22 = uv + delta * vec2( 1, 1);\n    \n    vec2 v2_00 = texture( iChannel0, uv_00 ).xy - OFFSET(uv_00);\n    vec2 v2_10 = texture( iChannel0, uv_10 ).xy;\n    vec2 v2_20 = texture( iChannel0, uv_20 ).xy + OFFSET(uv_20);\n    \n    vec2 v2_01 = texture( iChannel0, uv_01 ).xy - OFFSET(uv_01);\n    vec2 v2_11 = texture( iChannel0, uv_11 ).xy;\n    vec2 v2_21 = texture( iChannel0, uv_21 ).xy + OFFSET(uv_21);\n    \n    vec2 v2_02 = texture( iChannel0, uv_02 ).xy - OFFSET(uv_02);\n    vec2 v2_12 = texture( iChannel0, uv_12 ).xy;\n    vec2 v2_22 = texture( iChannel0, uv_22 ).xy + OFFSET(uv_22);\n    \n    float flow = 0.0;\n    \n    float fCenterHeight = v2_11.x + v2_11.y;\n    //Edges\n    float diff_10 = (v2_10.x + v2_10.y ) - fCenterHeight;\n    float diff_01 = (v2_01.x + v2_01.y ) - fCenterHeight;\n    float diff_21 = (v2_21.x + v2_21.y ) - fCenterHeight;\n    float diff_12 = (v2_12.x + v2_12.y ) - fCenterHeight;\n    \n\tdiff_10 = min( diff_10, diff_10 > 0.0 ? v2_10.y : v2_11.y );\n    diff_01 = min( diff_01, diff_01 > 0.0 ? v2_01.y : v2_11.y );\n    diff_21 = min( diff_21, diff_21 > 0.0 ? v2_21.y : v2_11.y );\n    diff_12 = min( diff_12, diff_12 > 0.0 ? v2_12.y : v2_11.y );\n    \n    flow += abs(diff_10) > EDGE_DELTA ? diff_10 * 0.5 : 0.0; \n    flow += abs(diff_01) > EDGE_DELTA ? diff_01 * 0.5 : 0.0;\n    flow += abs(diff_21) > EDGE_DELTA ? diff_21 * 0.5 : 0.0;\n    flow += abs(diff_12) > EDGE_DELTA ? diff_12 * 0.5 : 0.0;\n    \n    //Corners\n    float diff_00 = (v2_00.x + v2_00.y) - fCenterHeight;\n    float diff_20 = (v2_20.x + v2_20.y) - fCenterHeight;\n    float diff_02 = (v2_02.x + v2_02.y) - fCenterHeight;\n    float diff_22 = (v2_22.x + v2_22.y) - fCenterHeight;\n    \n    diff_00 = min( diff_00, diff_00 > 0.0 ? v2_00.y : v2_11.y );\n    diff_20 = min( diff_20, diff_20 > 0.0 ? v2_20.y : v2_11.y );\n    diff_02 = min( diff_02, diff_02 > 0.0 ? v2_02.y : v2_11.y );\n    diff_22 = min( diff_22, diff_22 > 0.0 ? v2_22.y : v2_11.y );\n    \n    flow += abs(diff_00) > CORNER_DELTA ? diff_00 * 0.5 : 0.0;\n    flow += abs(diff_20) > CORNER_DELTA ? diff_20 * 0.5 : 0.0;\n    flow += abs(diff_02) > CORNER_DELTA ? diff_02 * 0.5 : 0.0;\n    flow += abs(diff_22) > CORNER_DELTA ? diff_22 * 0.5 : 0.0;\n    \n    float fS = v2_11.y + flow * 0.25;\n    \n    return vec2( v2_11.x, max(0.0,fS) );\n}\n\n\n//-----------------------------------------------\n//-----------------------------------------------\nconst float KEY_SPACE = 32.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel3, vec2(key,0.25) ).x > .5;\n}\n//-----------------------------------------------\n//----------------------------------------------- \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = vec4( 0.0,0.0,0.0,0.0 );\n    \n    if( iTime <= 1.0 || keyIsDown(KEY_SPACE) )\n    {\n        vec3 v3WorldSize = GetWorldSize();\n        \n    \tfragColor.x = clamp( GetHeight(uv*v3WorldSize.xy), 0.0, 5.0 );\n        fragColor.y = .03;\n    }else{\n        \n        fragColor.xy = CalculateThermalErosion( uv );\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nvec3 GetWorldSize()\n{\n    return vec3( iResolution.xy / 64.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 delta = vec2(1,1) / iResolution.xy;\n    \n    vec3 v3WorldSize = GetWorldSize();\n    \n    vec4 fHeight_00 = texture( iChannel0, vec2(uv.x + delta.x, uv.y) );\n    vec4 fHeight_01 = texture( iChannel0, vec2(uv.x - delta.x,uv.y) );\n    \n    vec4 fHeight_10 = texture( iChannel0, vec2(uv.x, uv.y + delta.y) );\n    vec4 fHeight_11 = texture( iChannel0, vec2(uv.x,uv.y - delta.y) );\n    \n    vec3 v3Tangent;\n    v3Tangent.x = 1.0 / v3WorldSize.x;\n    v3Tangent.y = 0.0;\n    v3Tangent.z = (fHeight_00.x + fHeight_00.y) - (fHeight_01.x + fHeight_01.y);\n    \n    vec3 v3BiTangent;\n    v3BiTangent.x = 0.0;\n    v3BiTangent.y = 1.0 / v3WorldSize.y;\n    v3BiTangent.z = (fHeight_10.x + fHeight_10.y) - (fHeight_11.x + fHeight_11.y);\n    \n    vec3 v3Normal = cross( v3Tangent, v3BiTangent );\n    v3Normal.x /= v3Normal.z;\n    v3Normal.y /= v3Normal.z;\n    \n    fragColor = vec4(v3Normal.xy * 0.5 + 0.5,1.0,1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}