{"ver":"0.1","info":{"id":"4ltcWj","date":"1534136432","viewed":140,"name":"gridline","username":"PetriJ","description":"grid","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool drawLine(vec2 uv, float lineWidth, float linePos) {\n    return (uv.x > linePos - lineWidth && uv.x < linePos + lineWidth) || (uv.y > linePos - lineWidth && uv.y < linePos + lineWidth);\n}\n\nfloat drawAngledLine(const vec2 uv, const float steepness, const float lineWidth) {\n    float col = clamp(0.0f, 1.0f, -abs(steepness*uv.x) + lineWidth);\n    return max(float(col), clamp(0.0f, 1.0f, -abs(steepness*uv.y) + lineWidth));\n}\n\nfloat drawRepeatingLine(const vec2 uv, const float frequency, const float lineWidth) {\n    float col = clamp(0.0f, 1.0f, cos(uv.x * frequency) * lineWidth - (lineWidth - 1.0f));\n    return max(col, clamp(0.0f, 1.0f, cos(uv.y * frequency) * lineWidth - (lineWidth - 1.0f)));\n}\n\nfloat drawSphere(vec2 uv, vec3 sphereCenter, float radius) {\n    vec3 rayOrigin = vec3(0.0f, 0.0f, 0.0f);\n    vec3 rayDirection = normalize(vec3(uv, 1.0f));\n    float t = dot(sphereCenter - rayOrigin, rayDirection);\n    vec3 p = rayOrigin + rayDirection * t;\n    float y = length(sphereCenter - p);\n    if(y<radius) {\n    \tfloat x = sqrt(radius*radius - y*y);\n    \tfloat t1 = t - x;\n        vec3 t1p = rayOrigin + rayDirection * t1;\n        vec3 sphereToOrigin = normalize(rayOrigin - sphereCenter);\n        vec3 normal = normalize(t1p - sphereCenter);\n        return dot(normal, sphereToOrigin);\n    }\n    return -2.0f;\n}\n\nfloat areaOfTriangle(vec2 p1, vec2 p2, vec2 p3) {\n    vec2 vA = p2 - p1;\n    vec2 vB = p3 - p1;\n    float t = dot(normalize(vA), vB);\n    vec2 p4 = p1 + (vA * t);\n    float height = length(p3 - p4);\n    return (1.0f/2.0f) * height * length(vA);\n}\n\nbool triangleHitTest(vec2 uv, vec2 p1, vec2 p2, vec2 p3) {\n    //check a quick bounding box hit.\n    float maxX = max(p1.x, max(p2.x, p3.x));\n    float minX = min(p1.x, min(p2.x, p3.x));\n    float maxY = max(p1.y, max(p2.y, p3.y));\n    float minY = min(p1.y, min(p2.y, p3.y));\n    if (uv.x < minX || uv.x > maxX || uv.y < minY || uv.y > maxY) {\n        return false;\n    }\n    \n    //calculate area of the input triangle.\n    float At = areaOfTriangle(p1, p2, p3);\n    \n    //calculate areas from hit point\n    float A1 = areaOfTriangle(uv, p1, p2);\n    float A2 = areaOfTriangle(uv, p2, p3);\n    float A3 = areaOfTriangle(uv, p1, p3);\n    float Act = A1 + A2 + A3;\n    \n    //float treshold = 0.005f;\n    if (At >= Act) {\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - vec2(0.5f) * iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.4f);\n    \n    const float steepness = 450.0f;\n    const float lineWidth = 1.8f;\n    col = min(col, vec3(1.0f, 0.7f - drawAngledLine(uv, steepness, lineWidth), 1.0f));\n    \n    float frequency = 100.0f;\n    col = min(col, vec3((1.3f - drawRepeatingLine(uv, frequency, 2.0f))));\n    \n    float radius = 1.5f;\n    float sphere2 = drawSphere(uv, vec3(8.0f, 3.0f, 12.0f), radius);\n    if (sphere2 != -2.0f) {\n        col = vec3(sphere2);\n    }\n    float sphere = drawSphere(uv, vec3(0.0f, 0.0f, 4.0f), radius);\n    if (sphere != -2.0f) {\n        col = vec3(sphere);\n    }\n    \n    //if (triangleHitTest(uv, vec2(0.2f, 0.2f), vec2(-0.2f, -0.2f), vec2(0.2f, -0.2f))) {\n    //    col = vec3(1.0f);\n    //}\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}