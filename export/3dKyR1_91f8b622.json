{"ver":"0.1","info":{"id":"3dKyR1","date":"1602851269","viewed":73,"name":"Rolling Cubes","username":"nanase","description":"Rolling Cubes.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(float h, float s, float v) {\n\tvec3 a = fract(h + vec3(0.0, 2.0, 1.0)/3.0) * 6.0 - 3.0;\n\ta = clamp(abs(a) - 1.0, 0.0, 1.0) - 1.0;\n\ta = a*s + 1.0;\n\treturn a*v;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 onRep(vec3 p, float interval) {\n\treturn mod(p, interval) - interval * 0.5;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nfloat box(vec3 p, float s) {\n    p = abs(p) - s;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat plane(vec3 p) {\n    float d = p.y;\n    return d;\n}\n\nfloat sdFloor(vec3 p) {\n    return dot(p, vec3(0., 1., 0.)) + 0.28;\n}\n\nfloat boxZ(vec3 p, float speed, float size, float repx, float repz) {\n    p.z -= (iTime - 1.) * speed;\n    p.z = onRep(p, repz).z;\n    p.x = onRep(p, repx).x;\n\n    p.y += 0.2 - size;\n\n    p = rotate(p, iTime * speed, vec3(-0.5,0.0,0.0));\n    return box(p, size);\n}\n\nfloat boxX(vec3 p, float speed, float size, float repx, float repz) {\n    p.x -= iTime * speed;\n    p.x = onRep(p, repx).x;\n    p.z = onRep(p, repz).z;\n    p.y += 0.2 - size;\n\n    p = rotate(p, iTime * speed, vec3(0.0,0.0,0.5)); \n    return box(p, size);\n}\n\nfloat myBoxZ1(vec3 p) {\n    return boxZ(vec3(p.x + .5, p.y, p.z), 5., 0.1, 5., 2.);\n}\nfloat myBoxZ2(vec3 p) {\n    return boxZ(vec3(p.x+1.5, p.y, p.z), 4., 0.2, 5., 2.);\n}\nfloat myBoxZ3(vec3 p) {\n    return boxZ(vec3(p.x+2.5, p.y, p.z), 3., 0.25, 5., 2.);\n}\nfloat myBoxZ4(vec3 p) {\n    return boxZ(vec3(p.x+3.5, p.y, p.z), 2., 0.3, 5., 2.);\n}\nfloat myBoxZ5(vec3 p) {\n    return boxZ(vec3(p.x+4.5, p.y, p.z), 1.8, 0.4, 5., 2.);\n}\nfloat myBox4(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z), 5., 0.1, 2., 8.);\n}\nfloat myBox5(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z-2.), 4., 0.2, 2., 8.);\n}\nfloat myBox6(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z-4.), 3., 0.25, 2., 8.);\n}\nfloat myBox7(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z-6.), 2., 0.3, 2., 8.);\n}\n\nfloat sceneDist(vec3 p) {\n    float ret = sdFloor(p);\n    // z\n    ret = min(ret, myBoxZ1(p));\n    ret = min(ret, myBoxZ2(p));\n    ret = min(ret, myBoxZ3(p));\n    ret = min(ret, myBoxZ4(p));\n    ret = min(ret, myBoxZ5(p));\n\n    return ret;\n}\n\nconst float EPS = 0.0001;\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n\t\tsceneDist(p + vec3(EPS,0.,0.)) - sceneDist(p + vec3(-EPS,0.,0.)),\n\t\tsceneDist(p + vec3(0.,EPS,0.)) - sceneDist(p + vec3(0.,-EPS,0.)),\n\t\tsceneDist(p + vec3(0.,0.,EPS)) - sceneDist(p + vec3(0.,0.,-EPS))\n\t));\n}\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nmat3 camera(vec3 ro, vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nfloat genShadow(vec3 ro, vec3 rd) {\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for (int i = 0; i<20; i++) {\n        h = sceneDist(ro + rd * c);\n        if(h < 0.001) {\n            return shadowCoef;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float screenZ = 1.5;\n    vec3 rd = normalize(vec3(uv, screenZ));\n\n    // Camera\n    vec3 ta = vec3(-1.5, -0.5, -1.);\n    vec3 ro = vec3(1., 2.5, 2.);\n    if (mod(iTime, 50.) < 10.) {\n        ro *= mod(iTime, 50.);\n    } else if (mod(iTime, 50.) < 20.) {\n        ro = vec3(-1., 0.5, 1.5);\n        ro.x *= mod(iTime, 50.) - 9.;\n        ro.y *= mod(iTime, 50.) - 10.;\n    } else if (mod(iTime, 50.) < 30.) {\n        ro = vec3(0.1, 5., 0.5);\n        ro.x += 2.;\n        ro.zy *= mod(iTime, 50.) - 18.;\n        ro.xy /= 2.;\n    } else if (mod(iTime, 50.) < 40.) {\n        ro = vec3(2., 0.5, 2.5);\n        ro.xy *= mod(iTime, 50.) - 30.;\n    } else {\n        ro = vec3(-5., 0.5, 2.5);\n        ro.z *= mod(iTime, 50.) - 40.;\n    }\n    rd = camera(ro, ta) * normalize(vec3(uv, screenZ));\n\n    float d = 0.0;\n    vec3 col = vec3(0.);\n\n    vec3 light = normalize(lightDir + vec3(0., 2., 1.));\n    float shadow = 1.0;\n\n    for(int i=0; i<99; i++) {\n        vec3 rp = ro + rd * d;\n        float dist = sceneDist(rp);\n\n        if (abs(dist) < 0.0001) {\n            vec3 normal = getNormal(rp);\n\n            // light\n            vec3 halfLE = normalize(light - rd);\n            float diff = clamp(dot(light, normal), 0.1, 1.0);\n            float spec = pow(clamp(dot(halfLE, normal), 0.0, 1.0), 50.0);\n\n            shadow = genShadow(rp + normal * 0.001, light);\n\n            float u = 1.0 - floor(mod(rp.x, 2.0));\n            float v = 1.0 - floor(mod(rp.z, 2.0));\n\n            if((u == 1.0 && v < 1.0) || (u < 1.0 && v == 1.0)) {\n                diff *= 0.7;\n            }\n\n            col = vec3(0.89);\n            col = col * diff + vec3(spec);\n\n            if(myBoxZ1(rp) < 0.001) {\n                col.rgb -= mod(iTime, 1.) * 0.5;\n            }\n            else if(myBoxZ2(rp) < 0.001) {\n                col.r += 0.5;\n            }\n            else if(myBoxZ3(rp) < 0.001) {\n                col.g += 0.5;\n            }\n            else if(myBoxZ4(rp) < 0.001) {\n                col.b += 0.5;\n            }\n            else if(myBoxZ5(rp) < 0.001) {\n                col.rgb += 0.5;\n            }\n\n            break;\n        }\n\n        d += dist;\n    }\n\n    fragColor = vec4(col * max(0.5, shadow), 1.);\n}","name":"Image","description":"","type":"image"}]}