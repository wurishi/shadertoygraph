{"ver":"0.1","info":{"id":"4cd3D7","date":"1711883330","viewed":70,"name":"Test de calendos","username":"necroborg","description":"-","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\nconst float TAU = 6.2831853071;\n\nconst float CYLINDER_HEIGHT = 0.15;\nconst float CYLINDER_RADIUS = 1.2;\nconst float LINE_THICKNESS = 0.01;\n\nconst float MARCHING_HIT = 0.001;\n\n// Camera roll yaw and pitch\n#define ROLL (iTime / 5.)\n#define YAW  0.\n#define PITCH ((iMouse.y / iResolution.y) * 1.5)\n\nconst int MAX_SUBCATS = 6;\nvec3 colors[MAX_SUBCATS];\nfloat percentiles[] = float[MAX_SUBCATS](0.35, 0.6, 0.8, 0.9, 0.95, 1.);\nfloat selectedShift[] = float[MAX_SUBCATS](0.0, 0.0, CYLINDER_RADIUS / 4., 0., 0., 0.);\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n// Function from Iñigo Quiles\n// www.iquilezles.org/www/articles/functions/functions.htm\nfloat parabola(float x, float k) {\n  return pow(4.0 * x * (1.0 - x), k);\n}\n\nvec3 colorForPercentile(float percentile) {\n  for (int i = 0; i < MAX_SUBCATS; i++) {\n    if (percentiles[i] > percentile) return colors[i];\n  }\n  return vec3(0.);\n}\n\nfloat selectedShiftForPercentile(float percentile) {\n  for (int i = 0; i < MAX_SUBCATS; i++) {\n    if (percentiles[i] > percentile) return selectedShift[i];\n  }\n  return 0.;\n}\n\nvec2 boundsForPercentile(float percentile) {\n  for (int i = 0; i < MAX_SUBCATS; i++) {\n    if (percentiles[i] > percentile) return vec2(i == 0 ? 0. : percentiles[i - 1], percentiles[i]);\n  }\n  return vec2(0., 0.0001); // At least it won't crash\n}\n\nvec2 polarToCartesian(float r, float a) {\n  return r * vec2(cos(TAU * a), sin(TAU * a));\n}\n\nfloat distToClosestBorder(float r, float angle, vec2 uv) {\n  float percentile = mod(angle, 1.);\n  vec2 percentileRange = boundsForPercentile(percentile);\n\n  vec2 startPoint = polarToCartesian(r, percentileRange.x);\n  vec2 endPoint = polarToCartesian(r, percentileRange.y);\n  float distToClosestBorder = min(distance(startPoint, uv), distance(endPoint, uv));\n  return distToClosestBorder;\n}\n\n// Polar is r = x ; angle = y\n// Piece is x = minAngle ; y = maxAngle ; z = minRadius ; w = maxRadius\nfloat distToPiece(vec2 polar, vec4 piece, float radiusShift) {\n//  vec2 xy = polarToCartesian(polar.x - radiusShift, polar.y);\n  return 0.;\n}\n\n// Return\n// [ distance, 0, 0,\n//   norm.x, norm.y, norm.z\n//   color.r, color.g, color.b ]\nmat3 scene(vec3 p) {\n  p.yz *= rot(PITCH);\n  p.xy *= rot(ROLL);\n//  p.yz *= rot(YAW);\n\n  float r = length(p.xy);\n  float angle = atan(p.y, p.x) / TAU;\n  float percentile = mod(angle, 1.);\n\n  float zdist = abs(p.z) - CYLINDER_HEIGHT / 2.;\n  float radius = length(p.xy) - CYLINDER_RADIUS;\n  float xydist = radius < 0. ? -radius - CYLINDER_RADIUS / 1.5 : radius;\n\n  float dist = max(zdist, xydist);\n  if (dist > MARCHING_HIT) {\n    float distToClosestBorder = 200.;\n    if (abs(zdist) < 0.001)\n      distToClosestBorder = 0.8 * min(abs(radius), abs(xydist));\n    else if (abs(xydist) < 0.001)\n      distToClosestBorder = 0.8 * abs(zdist);\n    float prop = max(parabola(0.5 + distToClosestBorder / LINE_THICKNESS, 1.), 0.);\n    vec3 color = mix(vec3(0.), vec3(1.), prop);\n    return mat3(dist, 0., 0.,\n                0., 0., 0.,\n                color);\n  } else {\n    vec3 color = colorForPercentile(percentile);\n    float distToClosestBorder = distToClosestBorder(r, angle, p.xy);\n    if (abs(zdist) < 0.001) distToClosestBorder = min(distToClosestBorder, 0.8 * min(abs(radius), abs(xydist)));\n    if (abs(xydist) < 0.001) distToClosestBorder = min(distToClosestBorder, 0.8 * abs(zdist));\n    float prop = max(parabola(0.5 + distToClosestBorder / LINE_THICKNESS, 1.), 0.);\n    color = mix(color, vec3(1.), prop);\n    vec3 norm = zdist > -0.001 ? vec3(0., 0., 1.) :\n                radius > 0. ? vec3(p.x, p.y, 0.) : vec3(-p.x, -p.y, 0.);\n    return mat3(dist, 0., 0,\n                normalize(norm.xyz),\n                color);\n  }\n}\n\nvoid init() {\n  colors[0] = vec3(0.8, 0.7, 0.3);\n  colors[1] = vec3(0.1, 0.6, 0.7);\n  colors[2] = vec3(0.4, 0.8, 0.1);\n  colors[3] = vec3(0.0, 0.2, 0.9);\n  colors[4] = vec3(0.9, 0.4, 0.2);\n  colors[5] = vec3(0.4, 0.2, 0.7);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  init();\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n  vec3 ro = vec3(0., 0., -5);\n  vec3 rd = normalize(vec3(uv, 1.));\n//  vec3 ldir = normalize(vec3(sin(t), cos(t), 5.));\n  vec3 ldir = normalize(vec3(-0.25, 25, 5.));\n  vec3 p = ro;\n  int i = 0;\n  fragColor = vec4(0., 0., 0., 1.);\n  for (i = 0; i < 150; i++) {\n    mat3 dc = scene(p);\n    float d = dc[0][0];\n    if (d < MARCHING_HIT || dc[2][0] > 0.) {\n      vec3 norm = dc[1];\n            \n      vec3 h = -normalize(rd + ldir);\n      float blinnPhong = dot(h, norm);\n\n      float spec = pow(clamp(blinnPhong, 0., 1.), 50.);\n      float diff = dot(norm, -ldir);\n\n      fragColor = vec4(dc[2] + vec3(diff) + vec3(spec), 1.);\n      //fragColor = vec4(vec3(dc.xyz), 1.);\n      if (d < MARCHING_HIT) return;\n    } else if (p.z > 2.) break;\n    p += d * rd;\n  }\n}\n","name":"Image","description":"","type":"image"}]}