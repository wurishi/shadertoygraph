{"ver":"0.1","info":{"id":"lssfD7","date":"1496571683","viewed":1561,"name":"Lambert Reflectance w/o Tangents","username":"fizzer","description":"Demonstrates a method I discovered of sampling  the Lambert BRDF (cosine-weight distribution for ray reflection) in world space without the use of tangent vectors. Full article is here: http://amietia.com/lambertnotangent.html","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","lambert","lambertianreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The method of generating a cosine-weighted ray distribution.\n// METHOD 0 = Without using tangent vectors (http://amietia.com/lambertnotangent.html)\n// METHOD 1 = Using tangent vectors, based on PBRT (http://pbrt.org/).\n// METHOD 2 = Using tangnet vectors, based on https://www.shadertoy.com/view/MsdGzl\n#define METHOD\t0\n\n// The number of ambient occlusion samples to take.\n#define SAMPLES 16\n\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, ro - org);\n    float c = dot(ro - org, ro - org) - rad * rad;\n    float desc = b * b - 4.0 * a * c;\n    if (desc < 0.0)\n        return vec2(1.0, 0.0);\n\n    return vec2((-b - sqrt(desc)) / (2.0 * a), (-b + sqrt(desc)) / (2.0 * a));\n}\n\nvec4 spheres[3];\n\nfloat intersectScene(vec3 ro, vec3 rd, inout vec3 N)\n{\n    float t=(-1.0 - ro.y)/rd.y;\n\n    if(t<0.0)\n        t=1e4;\n    else\n        N=vec3(0.0,1.0,0.0);\n\n    for(int i=0;i<3;++i)\n    {\n        vec2 is=intersectSphere(ro, rd, spheres[i].xyz, spheres[i].w);\n        if(is.x>0.0&&is.x<is.y&&is.x<t)\n        {\n            t=is.x;\n            N=normalize(ro+rd*t-spheres[i].xyz);\n        }\n    }\n\n    return t;\n}\n\nvec3 lambertNoTangent(in vec3 normal, in vec2 uv)\n{\n    float theta = 6.283185 * uv.x;\n\n    uv.y = 2.0 * uv.y - 1.0;\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n    return normalize(normal + spherePoint);\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3)\n{\n    if(abs(v1.x) > abs(v1.y))\n    {\n        float invLen = 1.0 / length(v1.xz);\n        v2 = vec3(-v1.z * invLen, 0.0, v1.x * invLen);\n    }\n    else\n    {\n        float invLen = 1.0 / length(v1.yz);\n        v2 = vec3(0.0, v1.z * invLen, -v1.y * invLen);\n    }\n    v3 = cross(v1, v2);\n}\n\nvec3 lambert(vec3 normal, vec2 uv)\n{\n    float theta = 6.283185 * uv.x;\n    float r = sqrt(uv.y);\n\n    vec3 s, t;\n    CoordinateSystem(normal, s, t);\n\n    return s * cos(theta) * r + t * sin(theta) * r + normal * sqrt(1.0 - uv.y);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n\n// From https://www.shadertoy.com/view/MsdGzl, by iq\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n\n    // compute basis from normal\n    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n    // (link provided by nimitz)\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return  sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0] = vec4(0,.0,0,1);\n    spheres[1] = vec4(1.3,-.7,0,.3);\n    spheres[2] = vec4(0,-.7,.8,.5);\n\n    vec2 t = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    t.y/=iResolution.x/iResolution.y;\n    float sa = hash( dot( fragCoord.xy, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) );\n\n    float an=2.5;\n\n    fragColor.rgb=vec3(0);\n\n    float refl=1.;\n    float i=0.;\n\n    vec3 ro=vec3(0.,0.,4.);\n    vec3 rd=normalize(vec3(t.xy,-1.5));\n\n    rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n    ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n    vec3 N=vec3(0);\n\n    i=intersectScene(ro, rd, N);\n\n    N=normalize(N);\n\n    if (i>1e3)\n    {\n        fragColor.rgb=vec3(1);\n        return;\n    }\n\n    ro+=rd*(i-1e-3);\n\n    const int S=SAMPLES;\n    for(int j=0;j<S;++j)\n    {\n        float seed=76.2 + 73.1*float(j) + sa;\n        \n#if METHOD==0\n        float u = hash( 78.233 + seed);\n        float v = hash( 10.873 + seed);\n        rd=lambertNoTangent(N, vec2(u, v));\n#elif METHOD==1\n        float u = hash( 78.233 + seed);\n        float v = hash( 10.873 + seed);\n        rd=lambert(N, vec2(u, v));\n#elif METHOD==2\n        rd = cosineDirection(seed, N);\n#endif\n        \n        vec3 N2;\n        i=intersectScene(ro, rd, N2);\n\n        if (i>1e3)\n            fragColor.rgb+=vec3(.8);\n    }\n\n    fragColor.rgb/=float(S);\n}\n","name":"Image","description":"","type":"image"}]}