{"ver":"0.1","info":{"id":"wsX3D7","date":"1643007871","viewed":139,"name":"Perlin Noise 3D","username":"eoviya","description":"no desc :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float modValue = 512.0;\n\n// 两种随机数生成算法必须混合使用。\n// permute 负责将值通过二次函数的方式分布成比较大的值\n// 然后通过 shift 方法，乘以一个分数，然后取值的小数部分，再将区间缩放到 [-1, 1]。\n// 通过 permute 的值获取的间隔都比较大，shift 只保留小数就可以得到看起来非常随机的效果。\n\n// 随机数生成算法 1\nfloat permuteX(float x)\n{\n    float t = ((x * 67.0) + 71.0) * x;\n\treturn mod(t, modValue);\n}\n\nfloat permuteY(float x)\n{\n    float t = ((x * 73.0) + 83.0) * x;\n\treturn mod(t, modValue);\n}\n\nfloat permuteZ(float x)\n{\n    float t = ((x * 103.0) + 109.0) * x;\n\treturn mod(t, modValue);\n}\n\n// 随机数生成算法 2\nfloat shiftX(float value)\n{\n    return fract(value * (1.0 / 73.0)) * 2.0 - 1.0;\n}\n\nfloat shiftY(float value)\n{\n    return fract(value * (1.0 / 69.0)) * 2.0 - 1.0;\n}\n\nfloat shiftZ(float value)\n{\n    return fract(value * (1.0 / 89.0)) * 2.0 - 1.0;\n}\n\nfloat taylorInvSqrt(float r)\n{\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat smoothmix(float x, float y, float t)\n{\n\tt = t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n    return y * t + x * (1.0f - t);\n}\n\n// c: 坐标, xy=uv，z=时间\nfloat perlinNoise(vec3 c)\n{\n    // 取整数和小数部\n    vec3 ci = floor(c.xyz);\n    vec3 cr = fract(c.xyz);\n    \n    // 整数部分求余，以在 0 - modvalue 范围内周期重复。\n    vec3 i000 = ci;\n    vec3 i001 = ci + vec3(0.0f, 0.0f, 1.0f);\n    vec3 i010 = ci + vec3(0.0f, 1.0f, 0.0f);\n    vec3 i011 = ci + vec3(0.0f, 1.0f, 1.0f);\n    vec3 i100 = ci + vec3(1.0f, 0.0f, 0.0f);\n    vec3 i101 = ci + vec3(1.0f, 0.0f, 1.0f);\n    vec3 i110 = ci + vec3(1.0f, 1.0f, 0.0f);\n    vec3 i111 = ci + vec3(1.0f, 1.0f, 1.0f);\n    \n    // 计算8个晶格方向的整数\n    i000 = mod(i000, modValue);\n    i001 = mod(i001, modValue);\n    i010 = mod(i010, modValue);\n    i011 = mod(i011, modValue);\n    i100 = mod(i100, modValue);\n    i101 = mod(i101, modValue);\n    i110 = mod(i110, modValue);\n    i111 = mod(i111, modValue);\n    \n    // 生成随机值。\n    float rX000 = permuteX(permuteX(permuteX(i000.x) + i000.y) + i000.z);\n    float rX001 = permuteX(permuteX(permuteX(i001.x) + i001.y) + i001.z);\n    float rX010 = permuteX(permuteX(permuteX(i010.x) + i010.y) + i010.z);\n    float rX011 = permuteX(permuteX(permuteX(i011.x) + i011.y) + i011.z);\n    float rX100 = permuteX(permuteX(permuteX(i100.x) + i100.y) + i100.z);\n    float rX101 = permuteX(permuteX(permuteX(i101.x) + i101.y) + i101.z);\n    float rX110 = permuteX(permuteX(permuteX(i110.x) + i110.y) + i110.z);\n    float rX111 = permuteX(permuteX(permuteX(i111.x) + i111.y) + i111.z);\n    \n    float rY000 = permuteY(permuteY(permuteY(i000.x) + i000.y) + i000.z);\n    float rY001 = permuteY(permuteY(permuteY(i001.x) + i001.y) + i001.z);\n    float rY010 = permuteY(permuteY(permuteY(i010.x) + i010.y) + i010.z);\n    float rY011 = permuteY(permuteY(permuteY(i011.x) + i011.y) + i011.z);\n    float rY100 = permuteY(permuteY(permuteY(i100.x) + i100.y) + i100.z);\n    float rY101 = permuteY(permuteY(permuteY(i101.x) + i101.y) + i101.z);\n    float rY110 = permuteY(permuteY(permuteY(i110.x) + i110.y) + i110.z);\n    float rY111 = permuteY(permuteY(permuteY(i111.x) + i111.y) + i111.z);\n    \n    float rZ000 = permuteZ(permuteZ(permuteZ(i000.x) + i000.y) + i000.z);\n    float rZ001 = permuteZ(permuteZ(permuteZ(i001.x) + i001.y) + i001.z);\n    float rZ010 = permuteZ(permuteZ(permuteZ(i010.x) + i010.y) + i010.z);\n    float rZ011 = permuteZ(permuteZ(permuteZ(i011.x) + i011.y) + i011.z);\n    float rZ100 = permuteZ(permuteZ(permuteZ(i100.x) + i100.y) + i100.z);\n    float rZ101 = permuteZ(permuteZ(permuteZ(i101.x) + i101.y) + i101.z);\n    float rZ110 = permuteZ(permuteZ(permuteZ(i110.x) + i110.y) + i110.z);\n    float rZ111 = permuteZ(permuteZ(permuteZ(i111.x) + i111.y) + i111.z);\n    \n    float x000 = shiftX(rX000);\n    float x001 = shiftX(rX001);\n    float x010 = shiftX(rX010);\n    float x011 = shiftX(rX011);\n    float x100 = shiftX(rX100);\n    float x101 = shiftX(rX101);\n    float x110 = shiftX(rX110);\n    float x111 = shiftX(rX111);\n    \n    float y000 = shiftY(rY000);\n    float y001 = shiftY(rY001);\n    float y010 = shiftY(rY010);\n    float y011 = shiftY(rY011);\n    float y100 = shiftY(rY100);\n    float y101 = shiftY(rY101);\n    float y110 = shiftY(rY110);\n    float y111 = shiftY(rY111);\n    \n    float z000 = shiftZ(rZ000);\n    float z001 = shiftZ(rZ001);\n    float z010 = shiftZ(rZ010);\n    float z011 = shiftZ(rZ011);\n    float z100 = shiftZ(rZ100);\n    float z101 = shiftZ(rZ101);\n    float z110 = shiftZ(rZ110);\n    float z111 = shiftZ(rZ111);\n    \n    // 生成晶格的8个梯度方向\n\tvec3 g000 = vec3(x000, y000, z000);\n\tvec3 g001 = vec3(x001, y001, z001);\n\tvec3 g010 = vec3(x010, y010, z010);\n\tvec3 g011 = vec3(x011, y011, z011);\n\tvec3 g100 = vec3(x100, y100, z100);\n\tvec3 g101 = vec3(x101, y101, z101);\n\tvec3 g110 = vec3(x110, y110, z110);\n\tvec3 g111 = vec3(x111, y111, z111);\n     \n    // 梯度向量归一化\n    float n000 = taylorInvSqrt(dot(g000, g000));\n    float n001 = taylorInvSqrt(dot(g001, g001));\n    float n010 = taylorInvSqrt(dot(g010, g010));\n    float n011 = taylorInvSqrt(dot(g011, g011));\n    float n100 = taylorInvSqrt(dot(g100, g100));\n    float n101 = taylorInvSqrt(dot(g101, g101));\n    float n110 = taylorInvSqrt(dot(g110, g110));\n    float n111 = taylorInvSqrt(dot(g111, g111));\n    \n    g000 *= n000;\n    g001 *= n001;\n    g010 *= n010;\n    g011 *= n011;\n    g100 *= n100;\n    g101 *= n101;\n    g110 *= n110;\n    g111 *= n111;\n    \n    // 求出每个晶格的最终随机值。\n    // 随机值 = 梯度值和晶格向量的小数部的点积\n    float f000 = dot(g000, cr);\n    float f001 = dot(g001, cr - vec3(0.0f, 0.0f, 1.0f));\n    float f010 = dot(g010, cr - vec3(0.0f, 1.0f, 0.0f));\n    float f011 = dot(g011, cr - vec3(0.0f, 1.0f, 1.0f));\n    float f100 = dot(g100, cr - vec3(1.0f, 0.0f, 0.0f));\n    float f101 = dot(g101, cr - vec3(1.0f, 0.0f, 1.0f));\n    float f110 = dot(g110, cr - vec3(1.0f, 1.0f, 0.0f));\n    float f111 = dot(g111, cr - vec3(1.0f, 1.0f, 1.0f));\n    \n    // 通过插值求最终灰度值。\n    float fadeX0 = smoothmix(f000, f100, cr.x);\n    float fadeX1 = smoothmix(f010, f110, cr.x);\n    float fadeX2 = smoothmix(f001, f101, cr.x);\n    float fadeX3 = smoothmix(f011, f111, cr.x);\n    float fadeY0 = smoothmix(fadeX0, fadeX1, cr.y);\n    float fadeY1 = smoothmix(fadeX2, fadeX3, cr.y);\n    float fadeZ0 = smoothmix(fadeY0, fadeY1, cr.z);\n    \n    return fadeZ0 * 2.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    float uvScale = 15.0f;\n    vec2 coord = uv * uvScale;\n    \n    float val = perlinNoise(vec3(coord, iTime));\n    val = (val + 1.0) * 0.5f;\n    vec3 color = vec3(val);\n    \n\tfragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}