{"ver":"0.1","info":{"id":"M3GXRG","date":"1720090607","viewed":61,"name":"attempt at emissive surface","username":"akr51","description":"Anyone know? I tried making a light direction of the hit point of the octahedron: dlp = ro + rd * mapoct(hp); for use in the lighting, line 187. It has an annoying wavelike texture on the plane surface","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["illumination","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ITR 100\n#define MAX 122.0\n#define ESP 0.001\n\n\n\nmat2 rt(float t)\n{\n\n\n\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n\n}\n\n\nfloat glw(float d, float r, float i)\n{\n\n\n\n    return pow(r / max(d, 0.0001), i);\n\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat octahedron( vec3 p, float s)\n{\n  \n \n  \n  p = abs(p);\n  \n  return (p.x + p.y + p.z - s) * 0.57735027;\n\n}\n\n\n\nfloat mapplane(vec3 sp)\n{\n\n    return sp.y + 2.7;\n\n}\n\n\n\nfloat mapoct(vec3 sp)\n{\n\n    vec3 spc = sp;\n    spc.y -= 0.5;\n    spc.z += cos(iTime) * 0.6;\n    spc.x += sin(iTime) * 0.6;\n   \n    spc.zy *= rt(iTime);\n    spc.yz *= rt(iTime * 0.5);\n    spc.xz *= rt(iTime * 0.25);\n   \n    \n    float d = octahedron(spc, 0.1);\n   \n    \n    return d;\n        \n\n}\n\n\n\nfloat mrch(vec3 ro, vec3 rd, inout float gl)\n{\n\n\n    float d0 = 0.0;\n    \n    for (int i = 0; i < ITR; ++i)\n    {\n    \n        vec3 sp = ro + rd * d0;\n        float ds = mapoct(sp);\n        gl += glw(ds, 0.09, 1.6) * 2. * min(mapplane(sp), ds);\n        \n        ds = min(mapplane(sp), ds);\n        d0 += ds;\n        \n        \n        if (d0 > MAX || abs(ds) < ESP) break;\n        \n    \n    }\n    \n    \n    return d0;\n\n\n}\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n\n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n\n    \n\n}\n\n\n\n\nvec3 nml(vec3 p)\n{\n\n\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(mapplane(p) - vec3(mapplane(p - d.xyy), mapplane(p - d.yxy), mapplane(p - d.yyx)));\n    \n}\n\n\n\n\nfloat illuminate(vec3 sp, vec3 lp, float gl)\n{\n\n\n\n      vec3 l = normalize(lp - sp);\n      vec3 n = nml(sp);\n      float df = clamp(dot(n, l), 0.0, 1.0);\n      float dummy = 0.0;\n      float d = mrch(sp + n * 0.02, l, dummy);\n      \n      \n      return pow(gl * df * 15.0, 2.0);\n\n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    \n    \n    vec2 rr = iResolution.xy, uv = (u + u - rr) / rr.y;\n    vec3 ro = vec3(0.0, 0.2, -5.0);\n    vec3 fx = vec3(0.0, 0.01, 0.0);\n    vec3 rd = dir(uv, ro, fx);\n    \n    float gl = 0.0;\n    float d0 = mrch(ro, rd, gl);\n    \n    vec3 cl = vec3(0.0);\n    \n    \n    if (d0 < MAX)\n    {\n    \n    \n    \n        vec3 hp = ro + rd * d0;\n        float oct = mapoct(hp);\n        vec3 dlp = vec3(0.0);\n        \n        if (oct < MAX)\n        {\n        \n            dlp = ro + rd * oct;\n           // dlp *= -1.0;\n        \n        }\n        \n        \n        cl += illuminate(hp, dlp, gl) * vec3(2.7, 0.6, 0.76);\n    \n    } \n    \n    cl += gl;\n    \n    c_out = vec4(cl, 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}