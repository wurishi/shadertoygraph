{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"music","id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by inigo quilez - iq/2013 \n//   original at https://www.shadertoy.com/view/Msl3Rr\n// Modified by Morgan McGuire 2013 (http://graphicscodex.com)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n               -0.80,  0.36, -0.48,\n               -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p ) {\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n\n\nfloat dbox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat freqs[4];\n\nfloat height(in vec3 pos) {\n\tvec2 fpos = fract( pos.xz ); \n\tvec2 ipos = floor( pos.xz );\n\t\t\n    float f = 0.0;\t\n\tfloat id = hash( ipos.x + ipos.y*57.0 );\n\tf  = freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 );\n\tf += freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 );\n\tf += freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 );\n\tf += freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 );\n\tf = pow( clamp( f*0.75, 0.0, 1.0 ), 2.0 );\n    return 0.5 + 3.0*f;\n}\n\nvec3 map( in vec3 pos ) {\n\n\tvec2 fpos = fract( pos.xz ); \n\tvec2 ipos = floor( pos.xz );\n\t\t\n    float f = 0.0;\t\n\tfloat id = hash( ipos.x + ipos.y*57.0 );\n\tf  = freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 );\n\tf += freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 );\n\tf += freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 );\n\tf += freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 );\n\tf = pow( clamp( f*0.75, 0.0, 1.0 ), 2.0 );\n    float h = 0.5 + 3.0*f;\n\tfloat dis = dbox( vec3(fpos.x-0.5,pos.y-0.5*h,fpos.y-0.5), vec3(0.3,h*0.5,0.3), 0.15 );\n\n    return vec3( dis,id, f );\n}\n\n\nconst float surface = 0.01;\n\nvec3 trace( in vec3 ro, in vec3 rd, in float startf, in float maxd )\n{ \n    float s = surface*2.0;\n    float t = startf;\n\n    float sid = -1.0;\n\tfloat alt = 0.0;\n    for( int i = 0; i < 256; ++i ) {\n\t\tif( s>=surface && t<=maxd ) {\n\t\t\ts = max(s, 0.05);\n\t\t\tt += 0.1 * s;\n\t\t\tvec3 res = map( ro + rd*t );\n\t\t\ts   = res.x;\n\t\t\tsid = res.y;\n\t\t\talt = res.z;\n\t\t}\n    }\n    if( (t > maxd)&& (s > surface * 2.0) ) sid = -1.0;\n    return vec3( t, sid, alt );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float dt = 0.02;\n    float t = mint;\n\tro += rd * 0.4;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += max( 0.05, dt );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(surface*0.5,0.0,0.0);\n\tvec3 nor;\n\tfloat f = map(pos-eps.xyy).x;\n\tnor.x = map(pos+eps.xyy).x - f;\n\tnor.y = map(pos+eps.yxy).x - f;\n\tnor.z = map(pos+eps.yyx).x - f;\n\treturn normalize(nor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    xy.x *= iResolution.x/iResolution.y;\n\t\n    float time = 5.0 + 0.2*iTime + 20.0*iMouse.x/iResolution.x;\n\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n    // camera\t\n\tvec3 ro = vec3( 8.5*cos(0.2+.33*time), 5.0+2.0*cos(0.1*time), 8.5*sin(0.1+0.37*time) );\n\tvec3 ta = vec3( -2.5+3.0*cos(1.2+.41*time), 0.0, 2.0+3.0*sin(2.0+0.38*time) );\n\tfloat roll = 0.2*sin(0.1*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.75*cw );\n\t\n    // image\n    vec3 col = vec3( 0.0 );\n\t\n    vec3 res = trace( ro, rd, 0.025, 40.0 );\n    float t = res.x;\n    float sid = res.y;\n\n\n\tvec3 light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n    vec3 lpos = vec3(0.0) + 6.0*light1;\n\t\n    if (sid>-0.5)\n    {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos);\n\t    \n\t  \n    // lighting\n    vec3  ldif = pos - lpos;\n    float llen = length( ldif );\n    ldif /= llen;\n\tfloat con = dot(-light1,ldif);\n\tfloat occ = mix( clamp( pos.y/4.0, 0.0, 1.0 ), 1.0, max(0.0,nor.y) );\n\tfloat sha =  softshadow( pos, -ldif, 0.01, 5.0, 32.0 );;\n\t\t\n    float bb = smoothstep( 0.5, 0.8, con );\n    float lkey = clamp( dot(nor,-ldif), 0.0, 1.0 );\n\tvec3  lkat = vec3(1.0);\n          lkat *= vec3(bb*bb*0.6+0.4*bb,bb*0.5+0.5*bb*bb,bb).zyx;\n          lkat /= 1.0+0.25*llen*llen;\t\t\n\t\t  lkat *= 25.0;\n          lkat *= sha;\n    float lbac = clamp( 0.1 + 0.9*dot( light2, nor ), 0.0, 1.0 );\n          lbac *= smoothstep( 0.0, 0.8, con );\n\t\t  lbac /= 1.0+0.2*llen*llen;\t\t\n\t\t  lbac *= 4.0;\n\tfloat lamb = 1.0 - 0.5*nor.y;\n          lamb *= 1.0-smoothstep( 10.0, 25.0, length(pos.xz) );\n\t\t  lamb *= 0.25 + 0.75*smoothstep( 0.0, 0.8, con );\n\t\t  lamb *= 0.25;\n\t\t\n    vec3 lin  = 1.0*vec3(0.20,0.05,0.02)*lamb*occ;\n         lin += 1.0*vec3(1.60,0.70,0.30)*lkey*lkat*(0.5+0.5*occ);\n         lin += 1.0*vec3(0.70,0.20,0.08)*lbac*occ;\n         lin *= vec3(1.3,1.1,1.0);\n\n\t\t\n    // material\t\n\tcol = 0.5 + 0.5*vec3( cos(0.0+6.2831*sid),\t\t\n                          cos(0.4+6.2831*sid),\n                          cos(0.8+6.2831*sid) );\n    float ff = fbm( 10.0*vec3(pos.x,4.0*res.z-pos.y,pos.z)*vec3(1.0,0.1,1.0) );\t\n    col *= 0.2 + 0.8*ff;\n\t\t\n\tcol = col*lin;\n\n    vec3 spe = vec3(1.0)*occ*lkat*pow( clamp(dot( reflect(rd,nor), -ldif  ),0.0,1.0), 4.0 );\n\tcol += (0.5+0.5*ff)*0.5*spe*vec3(1.0,0.9,0.7);\n    }\n\n\t\n\tcol = sqrt( col );\n\t\n\n    // vigneting\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xsl3DB","date":"1378660422","viewed":1196,"name":"Cubescape 1.1","username":"morgan3d","description":"This is just a tuning of iq's original at https://www.shadertoy.com/view/Msl3Rr to fix some of the missed intersections and self-shadowing at fullscreen.  Glossy highlights still reveal the ray-marching but I haven't found a better distance estimator.\n","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","music","wood"],"hasliked":0,"parentid":"","parentname":""}}