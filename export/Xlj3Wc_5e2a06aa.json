{"ver":"0.1","info":{"id":"Xlj3Wc","date":"1433167387","viewed":204,"name":"My first raymarching (Anastad..)","username":"anastadunbar","description":"I've never done raymarching before, just 2D shaders. http://www.letsdive.in/2014/05/18/glsl---raymarching/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","test","noob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI=3.1415926535897932384;\n\n//float get_distance(vec3 point) {\n//  return /*SPHERE*/ (length(point)) - /*RADIUS*/ 1.;\n//}\n\nfloat get_distance(vec3 point) {\n  float bump = 0.0;\n  if ( length(point) < 1. + 1.) {\n    bump = 0.03 * texture(iChannel0, point.xy).r;\n  }\n  return length(point) - 1. + bump;\n}\n\n\nfloat raymarch(vec3 ray_origin, vec3 ray_direction) {\n  float d = 0.0;\n\n  for (float i = 0.; i < 70.; i++) {\n    vec3 new_point = ray_origin + ray_direction*d;\n    float s = get_distance(new_point);\n    if (s < 0.001) return d;\n    d += s;\n    if (d > 70.) return 300.;\n  }\n  return 300.;\n}\n\nvec3 get_normal(vec3 point) {\n  float d0 = get_distance(point);\n  float dX = get_distance(point - vec3(0.001, 0.0, 0.0));\n  float dY = get_distance(point - vec3(0.0, 0.001, 0.0));\n  float dZ = get_distance(point - vec3(0.0, 0.0, 0.001));\n  return normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 suv = ((2.0 * gl_FragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 colors = vec3(0.);\n    vec3 eye_pos = vec3(iMouse.x/iResolution.x-0.5, iMouse.y/iResolution.y-0.5, sin(time)-3.0);\n    vec3 forward = vec3(0.0, 0.0, 1.0);\n    vec3 light = vec3(cos(time), sin(time), -3.0);\n    \n    //Shooting rays to detect around the scene\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, forward);\n    //vec3 ray_dir = normalize(up * suv.y + right*suv.x + forward);\n    vec4 scene = vec4(0.1);\n//...\nvec3 ray_dir = normalize(up * suv.y + right *suv.x + forward);\n\nfloat d = raymarch(eye_pos, ray_dir);\nif (d < 300.) {\n  vec3 point = (eye_pos+ray_dir*d);\n  vec3 point_normal = get_normal(point);\n  vec3 light_dir = -normalize(light-point);\n  float dotp_diffuse = max(0.0, dot(light_dir, point_normal))+0.05;\n    scene = vec4(dotp_diffuse*vec4(2.,1.2,1.,1.));\n}\n//...\n    /*\n    float d = raymarch(eye_pos, ray_dir);\n    float scene = 0.;\n\tif (d < 300.) {\n\tscene = 1.0;\n\t} else {\n\tscene = 0.0;\n\t}\n    */\n    \n\tfragColor = vec4(scene.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}