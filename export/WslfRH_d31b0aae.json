{"ver":"0.1","info":{"id":"WslfRH","date":"1587692969","viewed":123,"name":"Ray Marching - Subsurface","username":"lukedan","description":"Subsurface scattering.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["subsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int numAOSamples = 5;\nconst float deltaAO = 0.4f;\n\nfloat ambientOcculusion(vec3 pt, vec3 n) {\n\tn *= deltaAO;\n\tfloat mul = 1.0f, tot = 0.0f;\n\tfor (int i = 0; i < numAOSamples; ++i) {\n\t\tpt += n;\n\t\ttot += mul * (float(i) * deltaAO - cornellBoxScene(pt).t);\n\t\tmul *= 0.5f;\n\t}\n\treturn tot;\n}\n\n\nconst int maximumShadowSteps = 100;\nconst float\n\tsoftShadowThreshold = 0.0001f,\n\tsoftShadowMinValue = 0.1f,\n\tsoftShadowMaxValue = 0.99f;\n\nfloat softShadow(vec3 p, vec3 light, float k) {\n\tvec3 diff = light - p;\n\tfloat dist = length(diff);\n\tdiff /= dist;\n\tfloat maxVal = softShadowMaxValue * dist, res = 1.0f, t = softShadowMinValue;\n\tfor (int i = 0; i < maximumShadowSteps && t < maxVal; ++i) {\n\t\tfloat sdf = cornellBoxScene(p + diff * t).t;\n\t\tif (sdf < softShadowThreshold) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tres = min(res, sdf * k / t);\n\t\tt += sdf;\n\t}\n\treturn res;\n}\n\n\nfloat subsurface(\n\tvec3 light, vec3 normal, vec3 view, float thin,\n\tfloat distortion, float glow, float scale\n) {\n\tvec3 scatterDir = light + normal * distortion;\n\tfloat lightReachingEye = pow(clamp(dot(view, -scatterDir), 0.0f, 1.0f), glow) * scale;\n\tfloat attenuation = 1.0f;\n\t/*attenuation = max(0.0f, dot(normal, light) + dot(view, -light));*/\n\treturn lightReachingEye;\n\treturn attenuation * lightReachingEye * thin;\n}\n\nvec3 material(vec3 pt, vec3 norm, vec3 cam, vec3 light, vec3 lightColor, int object, out float subsurfaceScatter) {\n\tsubsurfaceScatter = 0.0f;\n\tvec3 diff = light - pt;\n\tvec3 color = vec3(0.0f, 0.0f, 0.0f);\n\tswitch (object) {\n\tcase cornellBoxFloor:\n\tcase cornellBoxCeilingWall:\n\tcase cornellBoxBackWall:\n\t\tcolor = vec3(0.85f, 0.81f, 0.78f);\n\t\tbreak;\n\tcase cornellBoxLongCube:\n\tcase cornellBoxShortCube:\n\t\t{\n\t\t\tcolor = vec3(0.85f, 0.81f, 0.78f);\n#ifdef SUBSURFACE\n\t\t\tfloat thickness = ambientOcculusion(pt, -norm);\n\t\t\tsubsurfaceScatter = subsurface(\n\t\t\t\tnormalize(light - pt), norm, normalize(cam - pt), thickness, 0.2f, 10.0f, 0.1f\n\t\t\t);\n#endif\n\t\t\tbreak;\n\t\t}\n\tcase cornellBoxRedWall:\n\t\tcolor = vec3(0.63f, 0.065f, 0.05f);\n\t\tbreak;\n\tcase cornellBoxGreenWall:\n\t\tcolor = vec3(0.14f, 0.45f, 0.091f);\n\t\tbreak;\n\t}\n\treturn color * lightColor * (dot(normalize(diff), norm) / dot(diff, diff));\n}\n\n\n#ifdef SUBSURFACE\nconst vec3 lightPos = vec3(2.0f, 1.0f, 11.0f);\n#else\nconst vec3 lightPos = vec3(0.0f, 7.45f, 0.0f);\n#endif\nconst vec3 lightColor = vec3(17.0f, 12.0f, 4.0f) * 4.0f;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tCamera camera;\n\tcamera.position = vec3(0.0f, 5.5f, -30.0f);\n\tcamera.front = vec3(0.0f, 2.5f, 0.0f) - camera.position;\n\tcamera.refUp = vec3(0.0f, 1.0f, 0.0f);\n\tcamera.fovY = 19.5f * (3.14159f / 180.0f);\n\tcamera.aspectXOverY = iResolution.x / iResolution.y;\n\tinitializeCamera(camera);\n\n\tRay ray = getCameraRay(camera, fragCoord / iResolution.xy);\n\tIntersection isect = rayMarch(ray);\n\n\tvec3 point = ray.pos + isect.t * ray.dir;\n\tvec3 norm = normal(point);\n\t/*fragColor = vec4(float(isect.object) / 5.0f, 0.0f, 0.0f, 1.0f);*/\n\t/*fragColor = vec4(normal(point), 1.0f);*/\n\tfloat subsurfaceScatter;\n\tvec3 color = material(\n\t\tpoint, norm, camera.position, lightPos, lightColor, isect.object, subsurfaceScatter\n\t);\n\tcolor *= 1.0f - ambientOcculusion(point, norm);\n\tcolor *= softShadow(point, lightPos, 7.0f);\n\tcolor += subsurfaceScatter * lightColor;\n\t/*color = vec3(subsurfaceScatter);*/\n\tfragColor = vec4(color, isect.t);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float sdfSphere(vec3 pt, vec3 c, float r) {\n\treturn length(pt - c) - r;\n}\nfloat sdfPlane(vec3 pt, vec3 plane, vec3 n) {\n\treturn dot(pt - plane, n);\n}\nfloat sdfBox(vec3 pt, vec3 center, vec3 extents, mat3 rot) {\n\tpt = abs(rot * (pt - center));\n\tif (pt.x < extents.x && pt.y < extents.y && pt.z < extents.z) {\n\t\tvec3 innerDist3 = pt - extents;\n\t\treturn max(max(innerDist3.x, innerDist3.y), innerDist3.z);\n\t} else {\n\t\tvec3 outerDist3 = pt - min(pt, extents);\n\t\treturn length(outerDist3);\n\t}\n}\n\n\nstruct Ray {\n\tvec3 pos, dir;\n};\n\nstruct Camera {\n\tvec3\n\t\tposition,\n\t\t// normal vectors\n\t\tup, right,\n\t\t// used to compute rays, -1 for left/top border and 1 for right/bottom\n\t\thorizontal, vertical,\n\t\t// everything below are needed by initializeCamera(), including fovY and stuff\n\t\tfront, refUp;\n\tfloat fovY, aspectXOverY;\n};\n\nvoid initializeCamera(inout Camera cam) {\n\tcam.front = normalize(cam.front);\n\n\tcam.right = normalize(cross(cam.front, cam.refUp));\n\tcam.up = cross(cam.right, cam.front);\n\n\tfloat vertLen = tan(0.5f * cam.fovY);\n\tcam.vertical = cam.up * vertLen;\n\tcam.horizontal = cam.right * vertLen * cam.aspectXOverY;\n}\n\n// screenPos in [0, 1]^2\nRay getCameraRay(Camera cam, vec2 screenPos) {\n\tscreenPos = screenPos * 2.0f - 1.0f;\n\tRay result;\n\tresult.pos = cam.position;\n\tresult.dir = cam.front + cam.horizontal * screenPos.x + cam.vertical * screenPos.y;\n\treturn result;\n}\n\n\nstruct Intersection {\n\tint object;\n\tfloat t;\n};\n\nbool updateIntersection(inout Intersection isect, float t, int obj) {\n\tif (t < isect.t) {\n\t\tisect.t = t;\n\t\tisect.object = obj;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n#define SUBSURFACE\n\nconst int\n\tcornellBoxFloor = 0,\n\tcornellBoxRedWall = 1,\n\tcornellBoxGreenWall = 2,\n\tcornellBoxBackWall = 3,\n\tcornellBoxCeilingWall = 4,\n\tcornellBoxLongCube = 5,\n\tcornellBoxShortCube = 6;\nconst mat3\n\tcornellBoxLongCubeRot = mat3(\n\t\t0.89f, 0.0f, 0.46f,\n\t\t0.0f, 1.0f, 0.0f,\n\t\t-0.46f, 0.0f, 0.89f\n\t),\n\tcornellBoxShortCubeRot = mat3(\n\t\t0.95f, 0.0f, -0.30f,\n\t\t0.0f, 1.0f, 0.0f,\n\t\t0.30f, 0.0f, 0.95f\n\t);\n\nIntersection cornellBoxScene(vec3 pt) {\n\tIntersection result;\n\n\t// objects near the light cause strips to appear for soft shadows\n\tresult.t = sdfPlane(pt, vec3(0.0f, -2.5f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n\tresult.object = cornellBoxFloor;\n\tupdateIntersection(result, sdfPlane(pt, vec3(5.0f, 2.5f, 0.0f), vec3(-1.0f, 0.0f, 0.0f)), cornellBoxRedWall);\n\tupdateIntersection(result, sdfPlane(pt, vec3(-5.0f, 2.5f, 0.0f), vec3(1.0f, 0.0f, 0.0f)), cornellBoxGreenWall);\n#ifdef SUBSURFACE\n\tupdateIntersection(result, sdfPlane(pt, vec3(0.0f, 7.5f, 0.0f), vec3(0.0f, -1.0f, 0.0f)), cornellBoxCeilingWall);\n#else\n\tupdateIntersection(result, sdfPlane(pt, vec3(0.0f, 2.5f, 5.0f), vec3(0.0f, 0.0f, -1.0f)), cornellBoxBackWall);\n#endif\n\tupdateIntersection(\n\t\tresult, sdfBox(pt, vec3(2.0f, 0.0f, 3.0f), vec3(1.5f, 3.0f, 1.5f), cornellBoxLongCubeRot),\n\t\tcornellBoxLongCube\n\t);\n\tupdateIntersection(\n\t\tresult, sdfBox(pt, vec3(-2.0f, -1.0f, 0.75f), vec3(1.5f, 1.5f, 1.5f), cornellBoxShortCubeRot),\n\t\tcornellBoxShortCube\n\t);\n\n\treturn result;\n}\n\n\nconst int maxRayMarchingSteps = 100;\nconst float rayMarchingEps = 0.01f;\n\nIntersection rayMarch(Ray ray) {\n\tfloat totalT = 0.0f;\n\tfor (int i = 0; i < maxRayMarchingSteps; ++i) {\n\t\tIntersection isect = cornellBoxScene(ray.pos);\n\t\tif (isect.t < rayMarchingEps) {\n\t\t\tisect.t += totalT;\n\t\t\treturn isect;\n\t\t}\n\t\ttotalT += isect.t;\n\t\tray.pos += ray.dir * isect.t;\n\t}\n\tIntersection result;\n\tresult.object = -1;\n\treturn result;\n}\n\nconst float normalDelta = 0.01f;\n\nvec3 normal(vec3 pt) {\n\treturn normalize(vec3(\n\t\tcornellBoxScene(vec3(pt.x + normalDelta, pt.y, pt.z)).t -\n\t\tcornellBoxScene(vec3(pt.x - normalDelta, pt.y, pt.z)).t,\n\t\tcornellBoxScene(vec3(pt.x, pt.y + normalDelta, pt.z)).t -\n\t\tcornellBoxScene(vec3(pt.x, pt.y - normalDelta, pt.z)).t,\n\t\tcornellBoxScene(vec3(pt.x, pt.y, pt.z + normalDelta)).t -\n\t\tcornellBoxScene(vec3(pt.x, pt.y, pt.z - normalDelta)).t\n\t));\n}\n\n","name":"Common","description":"","type":"common"}]}