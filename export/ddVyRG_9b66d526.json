{"ver":"0.1","info":{"id":"ddVyRG","date":"1696274259","viewed":104,"name":"Spinning illusion","username":"Envy24","description":"Try to look at different centers.\nClick to restart rendering (for switching to fullscreen and back).\n","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["illusion","spinning"],"hasliked":0,"parentid":"mdKyRG","parentname":"Smooth vesica SDF (composite)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    O = texelFetch(iChannel0, ivec2(SC), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n\n#define SCENE_SCALE               ( 2.0 )\n#define AA_UNIT                   ( (SCENE_SCALE*2.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n/* Vesica SDF */\nfloat circleSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\nfloat intersect_sdf(float dl, float dr) { return max(dl, dr); }\nfloat vesicaSDF(vec2 NDC, vec2 C, float rad, float r)\n{\n    // Inverse rotation column major matrix.\n    mat2 inv = mat2(cos(rad), -sin(rad), sin(rad), cos(rad));\n    // Apply inverse translation and rotation.\n    NDC = inv * (NDC - C);\n    \n    float dl = circleSDF(NDC, vec2(-0.25,0), r),\n          dr = circleSDF(NDC, vec2( 0.25,0), r);\n    return opSmoothIntersection(dl, dr, 0.037);\n}\n/* !Vesica SDF */\n\nvec3 angular_color(vec2 NDC)\n{     \n    const float pi = 3.1415926535897932;\n    const float inv_pi = 0.3183098861837906;\n    float rad = (atan(NDC.y, NDC.x) + pi) * inv_pi * 20.;\n    int c = int(rad);\n    return (c & 1) == 0 ? vec3(0) : vec3(1);\n}\n\nvec3 draw_shape(vec2 NDC, vec3 color, vec2 C)\n{\n    NDC -= C;\n    \n    vec3 colors[2] = vec3[2]( vec3(0.145, 0.263, 0.537), vec3(0.624, 0.627, 0.024) );\n\n    float vr = 0.3, cr = 1., m = .697;\n    float rs[5] = float[5]( \n        0.3, 0.28, 0.269, 0.2635, 0.2605);\n        \n    for (int i = 0; i < 5; ++i)\n    {\n        float rad = (i & 1) == 1 ? 9. * TO_RAD : 0.;\n        mat2 inv = mat2(cos(rad), -sin(rad), sin(rad), cos(rad));\n        vec2 ndc = inv * NDC;\n        float cd = circleSDF(ndc, vec2(0), cr);    \n        color = mix(color, angular_color(ndc), SMAA(cd));\n\n        /**/\n        for (float idx = 0.; idx < 40.; idx += 1.)\n        {\n            rad = 9. * TO_RAD * idx;\n            inv = mat2(cos(rad), -sin(rad), sin(rad), cos(rad));\n\n            vec2 c = inv * vec2(0, cr-vr*.5);    \n            float vd = vesicaSDF(ndc, c, -rad, rs[i]);\n            color = mix(color, colors[int(idx)&1], SMAA(vd));\n        }\n        /**/\n               \n        cr *= m;\n        vr = cr * .3;\n    }\n    \n    return mix(color, vec3(0), SMAA(circleSDF(NDC, vec2(0), 0.16)));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    if (iFrame != 0 && !(iMouse.z > 0.)) { O = texelFetch(iChannel0, ivec2(SC), 0); return; }\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n    \n    vec3 color = draw_shape(NDC, vec3(0), vec2(0));\n         \n         /**/\n         color = draw_shape(NDC, color, vec2(-2, 0));\n         color = draw_shape(NDC, color, vec2(2, 0));\n         color = draw_shape(NDC, color, vec2(1));\n         color = draw_shape(NDC, color, vec2(-1));\n         color = draw_shape(NDC, color, vec2(-1, 1));\n         color = draw_shape(NDC, color, vec2(1, -1));\n         \n         /* More parts */\n         color = draw_shape(NDC, color, vec2(0, 2));\n         color = draw_shape(NDC, color, vec2(0, -2));\n         color = draw_shape(NDC, color, vec2(-4, 0));\n         color = draw_shape(NDC, color, vec2(4, 0));\n\n         color = draw_shape(NDC, color, vec2(-2, 2));\n         color = draw_shape(NDC, color, vec2(2, 2));\n         color = draw_shape(NDC, color, vec2(-2, -2));\n         color = draw_shape(NDC, color, vec2(2, -2));\n\n         color = draw_shape(NDC, color, vec2(-3, 1));\n         color = draw_shape(NDC, color, vec2(3, -1));\n         color = draw_shape(NDC, color, vec2(-3, -1));\n         color = draw_shape(NDC, color, vec2(3, 1));\n         /**/\n\n    O = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}