{"ver":"0.1","info":{"id":"NsKSDc","date":"1635425809","viewed":328,"name":"Truncated Pyramid SDF","username":"TheTurk","description":"Distance function (exact) for a truncated pyramid with a rectangular base. \nOther 3D distance functions:\n[url]https://www.shadertoy.com/playlist/73lfR7[/url]","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","distancefield","sdf","distance","frustum","pyramid","primitive","truncated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pyramid(vec3 position, float halfWidth1, float halfDepth1, float halfWidth2, float halfDepth2, float halfHeight) {\n    position.xz = abs(position.xz);\n    vec3 d1 = vec3(max(position.x - halfWidth1, 0.0), position.y + halfHeight, max(position.z - halfDepth1, 0.0));\n    vec3 d2 = vec3(max(position.x - halfWidth2, 0.0), position.y - halfHeight, max(position.z - halfDepth2, 0.0));\n    vec3 e = vec3(halfWidth1 - halfWidth2, 2.0 * halfHeight, halfDepth1 - halfDepth2);\n    vec3 n1 = vec3(0.0, e.zy);\n    float k1 = dot(n1, n1);\n    float h1 = dot(position - vec3(halfWidth1, -halfHeight, halfDepth1), n1) / k1;\n    vec3 n2 = vec3(k1, e.y * e.x, -e.z * e.x);\n    float m1 = dot(position - vec3(halfWidth1, -halfHeight, halfDepth1), n2) / dot(n2, n2);\n    vec3 d3 = position - clamp(position - n1 * h1 - n2 * max(m1, 0.0), vec3(0.0, -halfHeight, 0.0), vec3(max(halfWidth1, halfWidth2), halfHeight, max(halfDepth1, halfDepth2)));\n    vec3 n3 = vec3(e.yx, 0.0);\n    float k2 = dot(n3, n3);\n    float h2 = dot(position - vec3(halfWidth1, -halfHeight, halfDepth1), n3) / k2;\n    vec3 n4 = vec3(-e.x * e.z, e.y * e.z, k2);\n    float m2 = dot(position - vec3(halfWidth1, -halfHeight, halfDepth1), n4) / dot(n4, n4);    \n    vec3 d4 = position - clamp(position - n3 * h2 - n4 * max(m2, 0.0), vec3(0.0, -halfHeight, 0.0), vec3(max(halfWidth1, halfWidth2), halfHeight, max(halfDepth1, halfDepth2)));\n    float d = sqrt(min(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)), dot(d4, d4)));\n    return max(max(h1, h2), abs(position.y) - halfHeight) < 0.0 ? -d : d;\n}\n\n// square base\nfloat pyramid(vec3 position, float halfWidth1, float halfWidth2, float halfHeight) {\n    position.xz = abs(position.xz);\n    if (position.x > position.z) {\n        position.xz = position.zx;\n    } \n    vec3 d1 = vec3(max(position.x - halfWidth1, 0.0), position.y + halfHeight, max(position.z - halfWidth1, 0.0));\n    vec3 d2 = vec3(max(position.x - halfWidth2, 0.0), position.y - halfHeight, max(position.z - halfWidth2, 0.0));\n    vec3 e = vec3(halfWidth1 - halfWidth2, 2.0 * halfHeight, halfWidth1 - halfWidth2);\n    vec3 n1 = vec3(0.0, e.zy);\n    float k = dot(n1, n1);\n    float h = dot(position - vec3(halfWidth1, -halfHeight, halfWidth1), n1) / k;\n    vec3 n2 = vec3(k, e.y * e.x, -e.z * e.x);\n    float m = dot(position - vec3(halfWidth1, -halfHeight, halfWidth1), n2) / dot(n2, n2);\n    vec3 d3 = position - clamp(position - n1 * h - n2 * max(m, 0.0), vec3(0.0, -halfHeight, 0.0), vec3(max(halfWidth1, halfWidth2), halfHeight, max(halfWidth1, halfWidth2)));\n    float d = sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)));\n    return max(h, abs(position.y) - halfHeight) < 0.0 ? -d : d;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nfloat sdf(in vec3 position) { \n    float cornerRadius = 0.01;\n    float halfWidth1 = 0.35; \n    float halfDepth1 = 0.35;\n    float halfWidth2 = 0.2;\n    float halfDepth2 = 0.2;\n    float halfHeight = 0.25;\n    float d = pyramid(position, halfWidth1, halfDepth1, halfWidth2, halfDepth2, halfHeight);\n    d -= cornerRadius;\n    return d;\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.5 * (iTime - 6.0);\n\tvec3 rayOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}