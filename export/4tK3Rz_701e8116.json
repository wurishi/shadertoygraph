{"ver":"0.1","info":{"id":"4tK3Rz","date":"1472790067","viewed":686,"name":"Pathtracing Kali","username":"zackpudil","description":"First Path tracer.  Most code ripped off Fractal cave by iq. Single light ray, only 2 bounces for weaker light. ","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["fractal","pathtracing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    if(iFrame > 0) {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n        col = pow(col, vec3(1.0/2.2));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float frame() { return float(iFrame); }\nvec3 key = vec3(-0.5, 0.5, -0.5);\n\nfloat hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    \n    return -log(res)/k;\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec3 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    \n    vec3 x = texture(s, p.yz).rgb;\n    vec3 y = texture(s, p.xz).rgb;\n    vec3 z = texture(s, p.xy).rgb;\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 texbump(sampler2D s, vec3 p, vec3 n, float e) {\n    vec3 gs = vec3(0.21, 0.72, 0.07);\n    vec2 h = vec2(e, 0.0);\n    \n    float re = dot(gs, texcube(s, p, n));\n    mat3 m = mat3(\n        texcube(s, p - h.xyy, n),\n        texcube(s, p - h.yxy, n),\n        texcube(s, p - h.yyx, n)\n\t);\n    \n    vec3 g = (gs*m - re)/e;\n    g -= n*dot(g, n);\n    \n    return g;\n}\n\nfloat de(vec3 p) {\n    vec4 q = vec4(p, 1);\n\tq.xz = mod(q.xz + 1.0, 2.0) - 1.0;\n\n    for(int i = 0; i < 15; i++) {\n        q.xyz = abs(q.xyz);\n        q /= clamp(dot(q.xyz, q.xyz), 0.4, 1.0);\n        q = 1.7*q - vec4(0.5, 1.0, 0.4, 0.0);\n    }\n\t\n    return min(length(q.xyz)/q.w, min(p.y + 1.0, -p.y + 1.0));\n}\n\nfloat trace(vec3 ro, vec3 rd, bool pr, float m) {\n    float res = pr ? -1.0 : 1.0;\n    float t = 0.001;\n    \n    for(int i = 0; i < 100; i++) {\n        float d = de(ro + rd*t);\n        if(abs(d) < 0.0001 || t >= m) break;\n        t += d;\n    }\n    \n    if(t < m) res = pr ? t : 0.0;\n    return res;\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx)\n\t));\n    \n    return n;\n}\n\nvec3 hemi(float s, vec3 p) {\n    vec3 ww = vec3(1.0 + p.z - p.xy*p.xy, -p.x*p.y)/(1.0 + p.z);\n    vec3 uu = vec3(ww.xz, -p.x);\n    vec3 vv = vec3(ww.zy, -p.y);\n    \n    float u = hash(s + 69.454);\n    float v = 6.28138*hash(s + 84.33);\n    \n    return sqrt(u)*(sin(v)*uu + cos(v)*vv) + sqrt(1.0 - u)*p;\n}\n\nvec3 render(vec3 ro, vec3 rd, float sa) {\n    vec3 col = vec3(0.0);\n    \n    for(float b = 0.0; b < 3.0; b++) {\n        float t = trace(ro, rd, true, 50.0);\n        \n        if(t < 0.0) break;\n        \n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n            \n\n        vec3 lig = normalize(key - pos);\n        float dis = length(key - pos);\n    \tfloat att = 1.0/(1.0 + 1.34*dis + 2.1*dis*dis);\n\n        float dif = clamp(dot(lig, nor), 0.0, 1.0);\n        \n        vec3 iCol = texcube(iChannel1, 2.0*pos, nor);\n        col += dif*att*2.0*iCol;\n        if(dif > 0.0001)\n       \t\tcol *= trace(pos + nor*0.01, lig, false, dis);\n        \n        ro = pos;\n        rd = normalize(hemi(sa + 39.0*frame() + 88.34*b, nor));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sa = hash(dot(fragCoord, vec2(12.232, 72.123)) + 1212.0*frame());\n    vec2 of = -0.5 + vec2(hash(sa + 23.343), hash(sa + 94.23));\n    \n    vec2 p = (-iResolution.xy + 2.0*(fragCoord + of))/iResolution.y;\n    \n    vec3 col = vec3(0);\n    if(iFrame > 0) col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    vec3 ro = vec3(-0.4, -0.75, -1);\n    vec3 rd = normalize(vec3(p, 1.97));\n    \n    col += render(ro, rd, sa);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}