{"ver":"0.1","info":{"id":"ftjXWh","date":"1627554155","viewed":141,"name":"3D Mandelbrot Set by Gera","username":"geranyan","description":"3D Mandelbrot Set by Gera","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sph(in vec3 pos, in vec3 cen, in float r) {\n\treturn length(pos - cen) - r; \n}\n\nfloat plane(in vec3 pos, in float r) {\n\n\treturn pos.y - (-r);\n}\nfloat mnd(in vec3 pos) {\n    vec3 z = pos;\n    float dr = 2.0;\n    float r = 0.0;\n    \n    for(int i = 0; i < 200; i++) {\n        \n        r = length(z);\n        \n        if (r >= 2.0 ) {\n            break;\n        }\n        \n        float power = 9.0; //abs(6.0 *sin(iTime * 0.1)) + 2.0;\n        \n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        \n        dr = pow(r, power - 1.0 ) * power * dr + 1.0;\n        \n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        \n        z = zr * vec3(sin(theta) * cos(phi),\n                      sin(phi) * sin(theta),\n                      cos(theta));\n        z += pos;\n    }\n    \n    return 0.5 * log(r) * r / dr;\n}\n\nvec2 mmin(in vec2 a, in vec2 b) {\n\t\n\treturn abs(a.x) < abs(b.x) ? a: b;\n}\n\nvec2 map(in vec3 pos) {\n    \n    vec2 d1 = vec2(mnd(pos), 1.0);\n    \n    vec2 d2 = vec2(sph(pos, vec3(0.0), 700.0), 2.0);\n    \n    return mmin(d1, d2);\n}\n\nvec3 normal(in vec3 pos)\n{\n\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n        \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n  \n    return normalize(vec3(grad_x, grad_y, grad_z));\n}\n\n\nvec2 rayMarch(in vec3 ro, in vec3 rd) \n{\n\n    float t = 0.0; \n    float d = 0.0; \n    \n    for(int i = 0; i < 200; i++){\n    \n    \tvec2 pos = map(ro + t* rd); \n        \n        if(pos.x < 0.001){\n        \t\n        \tpos.x = t; \n           \t\n            return pos;\n        } \n        \n        if(pos.x > 1000.0){\n        \tbreak;\n        }\n        \n        t += pos.x;\n    }\n    \n    return vec2(-1.0);\n\n}\n\nfloat diffuse_light(in vec3 pos, in vec3 cen){\n    \n\tvec3 nor = normal(pos);\n    vec3 dir_to_light = normalize(cen-pos);\n    float diff_intens = dot(nor, dir_to_light);\n    \n    return diff_intens;\n\n}\n\nfloat phong_light(in vec3 pos, in vec3 cen, in vec3 ro, in float k){\n\t\n    float specPower = k;\n    vec3 n = normal(pos);\n    vec3 l = normalize(cen-pos);\n    vec3 v = normalize(ro-pos);\n    vec3 r = reflect(-v, n);\n    float phong_light = pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    return phong_light;\n\n}\n\n\nfloat shadow(vec3 pos, vec3 lightpos){\n\tvec3 rd = normalize(lightpos-pos);\n    float res = 1.0;\n    float t = 0.0;\n    \n    for (float i = 0.0; i < 100.0; i++)\n    {\n\t\tvec2 h = map(pos + rd * t);\n        res = min(res, 200.0 * h.x / t);\n        t += h.x;\n        \n        if ((res < 0.0001 || t > 320.0)) break;\n        \n    }\n    \n    return clamp(res, 0.0, 1.0);\n    \n}\n\nvec3 mnd2D(in vec2 C){\n    vec2 z = vec2(0.0 , 0.0);\n    float n = .0;\n    while (length(z) <= abs(20.0 * sin(iTime*0.5))+1.0 && n < abs(20.0 * sin(iTime*0.5))+1.0){\n        z = vec2(z.x * z.x -  z.y * z.y,  2.0 * z.x * z.y) + C;\n        n += 1.0;\n    }\n    return vec3(n / (abs(20.0 * sin(iTime*0.1))+1.0));\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/5.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    \n    vec2 h = rayMarch(ro, rd);\n    vec3 col = vec3(1.0,1.0,1.0);\n    vec3 pos = ro + h.x * rd;\n    if (h.y == 1.0) {\n        \n        //col *= phong_light(pos, vec3(50.0*sin(iTime), 200.0, cos(iTime)), ro, 20.5) * vec3(1.0,1.0,1.0);\n        //col *= diffuse_light(pos, vec3(50.0*sin(iTime), 200.0, cos(iTime))) * vec3(1.3, 1.3, 1.3);\n        col *= calcAO(pos, normal(pos)) * vec3(1.9);\n        \n        return col;\n    }\n    else if (h.y == 2.0){\n    \n    \n       \n        vec3 n_pos = normalize(pos);\n        vec2 C =  vec2(-n_pos.x - n_pos.z -n_pos.y + sin(iTime * 0.5),-n_pos.x - n_pos.z +n_pos.y + cos(iTime * 0.5));\n        col *= vec3(1.0) - mnd2D(C);\n    \n        //col *= diffuse_light(pos, vec3(50.0, 200.0, 1.0)) * vec3(0.2, 0.2, 0.1);\n        //col *= shadow(pos, vec3(50.0*sin(iTime), 200.0, cos(iTime)));\n        return col;\n        \n    }\n    \n    return vec3(0.0);\n    \n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float an = iTime * 0.1;//10.0 * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(1.0*cos(an)*1.5, 1.3*sin(iTime*0.05), 1.0*sin(an) * 1.5);\n    vec3 ta = vec3(0.0); // target for camera\n\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu, ww));\n\n\n\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);\n    vec3 col = render(ro, rd); \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}