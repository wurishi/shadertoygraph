{"ver":"0.1","info":{"id":"XdKBWt","date":"1531045257","viewed":326,"name":"李明杰V14","username":"leneer","description":"l","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["l"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n// **************************************************************************\n// INLINE MACROS\n\n// **************************************************************************\n// DEFINES\n\n// **************************************************************************\n// GLOBALS\n\nfloat g_time        = 0.;\nvec4  g_debugcolor  = vec4(0.);\n\nfloat g_cellsize    = 1.;\n\n// **************************************************************************\n// MATH UTILITIES\n\n// Approximating a dialectric fresnel effect by using the schlick approximation\n// http://en.wikipedia.org/wiki/Schlick's_approximation. Returns a vec3 in case\n// I want to approximate a different index of reflection for each channel to\n// get a chromatic effect.\nvec3 fresnel(vec3 I, vec3 N, float eta)\n{\n    // assume that the surrounding environment is air on both sides of the \n    // dialectric\n    float ro = (1. - eta) / (1. + eta);\n    ro *= ro;\n    \n    float fterm = pow(1. - dot(-I, N), 5.);  \n    return vec3(ro + ( 1. - ro ) * fterm); \n}\n\n// Periodic saw tooth function that repeats with a period of \n// 4 and ranges from [-1, 1].  \n// The function starts out at 0 for x=0,\n//  raises to 1 for x=1,\n//  drops to 0 for x=2,\n//  continues to -1 for x=3,\n//  and then rises back to 0 for x=4\n// to complete the period\n\nfloat sawtooth( float x )\n{\n    float xmod = mod(x+3.0, 4.);\n    return abs(xmod-2.0) - 1.0;\n}\n\n// Step function that starts at y =0 at x=0, then smoothsteps\n// up to y=1 at x=0 using a sin.  Then smoothsteps to y=2 at x=2\n// and so on.\nfloat sinstep( float x )\n{\n    return (sin(TWO_PI * x-PI) + (TWO_PI * x - PI) + PI)/TWO_PI;\n}\n\n// Step function that starts at y =0 at x=0, then smoothsteps\n// up to y=1 at x=0 using a smoothstep.  Then smoothsteps to y=0 at x=2.\n// Repeats with a period of 4.\nfloat periodicsmoothstep( float x )\n{\n    float mx = mod(x, 4.);\n    return smoothstep(0., .2, mx) - smoothstep(2., 2.2, mx);\n}\n\n// *************************************************************************\n// INTERSECTION MATH\n\n// Intersection test against an infinitely tall horizontal box of square\n// dimension.  Provide the square dimension as a half length. Tries to \n// anti-alias using a smoothstep across \"edge\" cases.\n\n// out params are two hit results for the 2 planes of the column\n\n//   plane{1,2}r.x = alpha of hit (used for anti-aliasing)\n//   plane{1,2}r.y = t such that ray_origin + t*ray_direction = intersection point\n//   plane{1,2}r.zw = x and z coordinates of normal\n\n// In most cases, one of the plane hit results will have an alpha of 0.\n\nvoid\nintersect_tower(vec3 ro, vec3 rd, \n                float hd,\n                out vec4 plane1r, \n                out vec4 plane2r)\n{    \n    // quick way to intersect against 2 planes at once\n    // based on the incoming ray direction.  Then decide\n    // intersection based on if the intersection is bounded\n    // within the half length.\n    \n    vec2 pn = -sign(rd.xz);\n    vec2 po = vec2(hd) * pn;\n    vec2 ddn = -rd.xz * pn;\n    \n    vec2 t = (pn * (ro.xz - po))/ddn;\n    vec2 ip = ro.zx + rd.zx * t;\n    \n    //vec2 fw = clamp(2. * fwidth(abs(ip)).xy, .05, 1.);\n    vec2 fw = vec2(.05);\n    vec2 amask = smoothstep(vec2(hd) + fw, vec2(hd), abs(ip));    \n    \n    // Best to recognize \"corner\" case and treat this as\n    // two semi-transparent plane edges overlapping.      \n    plane1r = vec4(amask.x, t.x, vec2(pn.x, 0.)); \n    plane2r = vec4(amask.y, t.y, vec2(0., pn.y));    \n    \n}\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct CameraInfo\n{\n    vec3 camera_origin;\n    vec3 ray_look_direction;\n    vec2 image_plane_uv;\n};\n\n// Define a macro for struct initialization so as you add properties, you \n// can update the initializer right here and don't have to find all of your\n// references through out your code.\n#define INIT_CAMERA_INFO() SurfaceInfo(vec3(0.) /* camera_origin */, vec3(0.) /* ray_look_direction */, vec2(0.) /* image_plane_uv */)\n\n// **************************************************************************\n// SETUP WORLD\n\nvoid setup_globals()\n{\n    // Way to globally control playback rate.\n    g_time = iTime;\n}\n\nCameraInfo setup_camera(vec2 fragCoord)\n{\n    \n    vec3 camera_origin    = vec3(0.0, 0., 0.0);\n        \n    float xang = .1 * g_time;\n    float yang = (PI_OVER_TWO - .1) * sinstep(sawtooth(.05 * g_time + 4. ) );\n\n    vec3 bot_camera_points_at = 10. * vec3(cos(xang) * cos(yang), sin(yang), sin(xang) * cos(yang));\n    vec2 uang = vec2( TWO_PI, PI ) * ((iMouse.xy / iResolution.xy) - .5);\n    vec3 user_camera_points_at = 10. * vec3(cos(uang.x) * cos(uang.y), sin(uang.y), sin(uang.x) * cos(uang.y));\n\n    vec3 camera_points_at = mix( bot_camera_points_at, user_camera_points_at, step(10., iMouse.y));\n    \n    // aspect_ratio := View Width / View Height\n    // inv_aspect_ratio := View Height / View Width\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 image_plane_uv = fragCoord.xy / iResolution.xy - .5;\n\n    // multiply by the inverse aspect ratio so that we don't have squashing\n    // along the vertical axis.  This means that the image_plane_uv will be \n    // in the range ([-1,1], [-1/AspectRatio, 1/AspectRatio])\n    image_plane_uv.y *= inv_aspect_ratio;\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene through a pin-hole camera.  Assume the \n    // camera is trying to orient its roll as close to true up \n    // (along the positive y-axis) as possible.  This math breaks down if the \n    // camera is looking along the absolute y-axis.\n    vec3 iu = vec3(0., 1., 0.);\n\n    // Find the orthonormal basis of our camera.  iz is the normalized eye\n    // direction along the z axis (where we're looking).  ix is the direction to\n    // the right of  the camera.  iy is the upward facing direction of our\n    // camera.  Note that iy is not necessrily (0, 1., 0.) since the camera \n    // could be tilted based on our look_at variable.\n    vec3 iz = normalize( camera_points_at - camera_origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel\n    vec3 ray_look_direction = normalize( image_plane_uv.x * ix + image_plane_uv.y * iy + .8 * iz );\n\n    return CameraInfo(camera_origin, ray_look_direction, image_plane_uv);\n\n}\n\n// **************************************************************************\n// SHADE WORLD\n\nvec3 tower_lightcolor(vec2 coords)\n{\n    return mix( texture(iChannel0, (10./iChannelResolution[0].xy) * coords).rgb,\n                texture(iChannel1, (10./iChannelResolution[1].xy) * coords).rgb,\n                periodicsmoothstep( .05 * g_time - .005 * (coords.x + coords.y) - 1.));\n}\n\nvec3 tower_lightpos(vec2 cell_coords, vec3 tower_color)\n{\n    // no movement in center column\n    float mask = step(REALLY_SMALL_NUMBER, abs(dot(cell_coords, vec2(1.))));\n    vec3 light_color = mask * tower_color;\n    return vec3(0., mod(5. * g_time + 200. * tower_color.r, 110.) - 100., 0.);\n\n    // return vec3(0., mod(5. * g_time + 10. * (cell_coords.x + 4. * cell_coords.y), 110.) - 100., 0.);\n    // return vec3(0., mod(10. * g_time + 2. * cell_coords.x, 200.) - 100., 0.);\n}\n\nfloat tower_rotoffset(vec2 coords)\n{\n    return texture(iChannel2, (10./iChannelResolution[2].xy) * coords).r;\n}\n\nvec3 \nneighbor_light( vec3 hp, vec3 n, vec3 neighbor_cell_coord)\n{\n   vec3 neighbor_color = tower_lightcolor(neighbor_cell_coord.xz);\n   vec3 light_pos = tower_lightpos(neighbor_cell_coord.xz, neighbor_color);\n   light_pos += g_cellsize * vec3(neighbor_cell_coord.x + .5, 0., neighbor_cell_coord.z + .5);\n   vec3 l = hp - light_pos;        \n   float llen = length(l);\n   return neighbor_color * max(0., dot(-normalize(l), n)) * pow(1./llen, .3);\n}\n\n// Query 4 neighbors for their diffuse irradiance selected based on facing normal\nvec3 \nneighbors_diffuse( vec3 hp, vec3 n, vec3 cell_coord )\n{\n\n    vec3 rs = sign(n);\n    vec3 bounce = vec3(0.);\n    bounce += neighbor_light(hp, n, cell_coord + vec3(0.,   0., rs.z));\n    bounce += neighbor_light(hp, n, cell_coord + vec3(rs.x, 0., rs.z));\n    bounce += neighbor_light(hp, n, cell_coord + vec3(rs.x, 0., 0.));\n\n    // TODO: debranch\n    if (abs(n.z) > abs(n.x)) {\n        bounce += neighbor_light(hp, n, cell_coord + vec3(-rs.x, 0., rs.z));\n    } \n    else\n    {\n        bounce += neighbor_light(hp, n, cell_coord + vec3(rs.x, 0., -rs.z));\n    }\n    \n    return bounce;\n}\n\nvoid shade_tower_side(vec3 rro, \n                      vec3 rrd, \n                      mat3 rrt, \n                      vec3 lcol,\n                      float hd,\n                      vec3 cell_coords,\n                      vec4 pr, \n                      inout vec4 scene_col)\n{\n    if (pr.x > .05)\n    {\n    vec3 hp = rro + rrd * pr.y;\n    hp.y = -abs(hp.y);\n\n    vec3 lpos = tower_lightpos(cell_coords.xz, lcol);\n    float fo = max(0., 1. - .08 * length(lpos - hp)); fo *= fo;\n    vec3 n = vec3(pr.z, 0., pr.w); \n    vec3 l = normalize(hp - lpos);\n    vec3 r = refract(rrd, n, .5);\n    vec3 fr = fresnel(rrd, n, .3);\n\n    // glow\n    float glow = 15. * (1. - fr.r) * smoothstep(.1, .0, abs(hp.y - lpos.y)) + .08 * fo;        \n\n    // ambient\n    float amb = .05 + .1 * pow(smoothstep(.0, .1, min(abs(hp.x),abs(hp.z))), 4.);        \n\n    // transmissive\n    float trans = 20. * fo * (1. - fr.r) * pow(max(0., dot(l, -r)), 2.);\n\n    // diffuse \n    float diff = 10.8 * fo * max(0., abs(dot(l, n)));\n\n    // depth\n    vec2 pn = -sign(rrd.xz);\n    vec2 ddn = rrd.xz * pn;\n    vec2 po = hd * -pn;\n    vec2 t = -(pn * (hp.xz - po))/ddn;\n    float depth = max(0., min(t.x, t.y));\n\n    // depth glow\n    float depth_glow = .5 * min(3., .5 * depth);\n\n    // neighbors bounce \n    vec3 ghp = g_cellsize * vec3(cell_coords.x + .5, 0., cell_coords.z + .5) + rrt * hp;\n    vec3 gn  = rrt * n;\n    vec3 neighbors = 1.5 * neighbors_diffuse(ghp, gn, cell_coords);\n\n    // darken with depth\n    float darken = exp(-.2 * pr.y);\n    float alpha = pr.x * mix(.2, 1., .2 * depth);\n\n    // add it all up\n    scene_col.rgb += (1. - scene_col.a) * alpha * darken * (neighbors + lcol * (depth_glow + trans + diff + glow + amb));\n\n    // depth attenuated opacity\n    scene_col.a += (1. - scene_col.a) * alpha;\n    }\n\n}\n\nvec4 shade_cell(vec3 ray_origin,\n                vec3 ray_direction,\n                vec3 cell_coords)\n{\n\n    vec3 lcol = tower_lightcolor(cell_coords.xz);\n    float ang = .5 * g_time + 180. * tower_rotoffset(cell_coords.xz);\n\n    float ca = cos(ang); float sa = sin(ang);\n    mat3 rt = mat3(ca, 0., sa, 0., 1., 0.,-sa, 0., ca);\n    mat3 rrt = mat3(ca, 0., -sa, 0., 1., 0.,sa, 0., ca);    \n    \n    vec3 rro = rt * ray_origin;\n    vec3 rrd = rt * ray_direction;\n    \n    float hd = .1;\n    vec4 p1r = vec4(0.), p2r = vec4(0.);\n    intersect_tower(rro, rrd, hd, p1r, p2r);\n    vec4 result = vec4(0.);\n    \n    shade_tower_side(rro, rrd, rrt, lcol, hd, cell_coords, p1r, result);\n    shade_tower_side(rro, rrd, rrt, lcol, hd, cell_coords, p2r, result);\n    \n    return result;\n}\n\n// **************************************************************************\n// MARCHING\n\n// simplified dda marching along the x and z direction.  Ignore crossing the \n// y plane\n\n// References for DDA marching:\n// original tutorial:  http://lodev.org/cgtutor/raycasting.html\n// initial shadertoy reference by fb39ca4: https://www.shadertoy.com/view/4dX3zl\n// optimization by iq: https://www.shadertoy.com/view/4dfGzs\nfloat dda_march( vec3 ro, vec3 rd,\n                 float maxdist,\n                 out vec4 scene_rgba )\n{\n \n    vec3 cell_coord = floor(ro/g_cellsize); cell_coord.y = 0.;\n    vec3 rs = sign(rd);\n    \n    vec2 deltaDist = g_cellsize/rd.xz;\n    vec2 sideDist = ((cell_coord.xz - ro.xz)/g_cellsize + 0.5 + rs.xz*0.5) * deltaDist;    \n\n    float res = 0.0;\n    vec3 mm = vec3(0.0);\n    \n    scene_rgba = vec4(0.);\n    \n    float t = 0.;\n    \n    vec3 pos = ro;\n    vec3 cell_pos = mod(ro, g_cellsize) - .5 * g_cellsize;\n    \n    for( int i=0; i<32; i++ ) \n    {\n        //if (scene_rgba.a > .95 || t >= maxdist) { break; }\n\n        // DDA march along the xz boundaries, ignoring the y plane boundaries\n        mm.xz = step(sideDist.xy, sideDist.yx);\n\n        vec3 normal = vec3(0.); \n        normal.xz = mm.xz * rs.xz;\n        cell_coord += mm * rs * vec3(1., 0., 1.);\n        \n        vec3 ddn = rd * -rs;\n        vec3 po = .5 * g_cellsize * rs;\n        vec3 plane_t = (rs * (cell_pos - po))/ddn;\n        float cell_extent = min(plane_t.x, plane_t.z);        \n        pos += cell_extent * rd;\n        \n        cell_pos = pos - g_cellsize * cell_coord - .5 * g_cellsize;\n\n        vec4 cell_res = shade_cell(cell_pos, rd, cell_coord);\n\n        t = length(pos - ro);\n\n        // composite\n        scene_rgba.rgb += cell_res.rgb * cell_res.a * exp(-.05 * t + 1.);\n        scene_rgba.a += (1. - scene_rgba.a) * cell_res.a;\n\n        sideDist += mm.xz * rs.xz * deltaDist;  \n    }    \n    \n    return t;\n}\n\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // ----------------------------------\n    // SETUP GLOBALS\n\n    setup_globals();\n\n    // ----------------------------------\n    // SETUP CAMERA\n\n    CameraInfo camera = setup_camera(fragCoord);\n\n    // ----------------------------------\n    // SHADING \n\n    vec4 scene_rgba = vec4(0.);\n\n    dda_march(camera.camera_origin, camera.ray_look_direction, 100., scene_rgba);\n\n    // ----------------------------------\n    // POST\n    \n    // gamma correct\n    scene_rgba.rgb = pow(scene_rgba.rgb, vec3(.5));\n    \n    // saturate\n    scene_rgba.rgb = clamp(mix( vec3(dot(vec3(.2125, .7154, .0721), scene_rgba.rgb)), \n                                scene_rgba.rgb, \n                                1.5), 0.0, 1.0);\n    \n    // Debug color - great debugging tool.      \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scene_rgba.rgb;\n    }\n\n\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}]}