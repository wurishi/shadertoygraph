{"ver":"0.1","info":{"id":"wsB3Wh","date":"1548715835","viewed":405,"name":"tengo calor!!","username":"bitnenfer","description":"We are going through a heat wave in Chile and I wanted to make something that looked like some fresh cold water.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HIT_NONE -1.\n#define HIT_WATER 0.\n#define HIT_OPAQUE 1.\n#define MAX_DIST 10.\n#define EPSILON .001\n#define MIN_DIST EPSILON\n#define RAYMARCH_STEPS 400\n\nconst float uRefraction = 1.33;\nconst float uWaveAmp = 0.051;\nconst float uWaveFreq = 0.1;\nfloat uWaterHeight = 0.75;\nconst float uWaterWidth = 0.988;\nconst float uShape = 1.0;\n\n\nmat2 Rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat Box(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat Sphere(vec3 p, float radius) {\n    return length(p) - radius;\n} \n\nfloat GetNoise(vec3 p) {\n    float time = iTime * 0.005;\n    vec4 noise = texture(iChannel0, (p.xz * 0.01 + time));\n    noise += texture(iChannel0, (p.xz * 0.09+ time));\n    noise += texture(iChannel0, (p.xz * 0.1+ time));\n    float wave = (0.05 * (uWaveAmp * 4.0)) * sin((uWaveFreq * 90.0) * (p.x + p.z *0.5) + iTime * 2.0);\n    wave *= sin(time + p.x * cos(time + p.z)) * 3.0;\n    return wave + length(noise * 0.1) * uWaveAmp;\n}\n\nvec2 GetWater(vec3 p) {    \n    float wave = GetNoise(p);\n    float water = mix(Sphere(p - wave, uWaterWidth * uWaterHeight), Box(p + vec3(0.0, 0.2, 0.0), vec3(uWaterWidth, uWaterHeight + wave, uWaterWidth)), uShape);\n    float block = Box(p + vec3(0.0, -0.85, 0.0), vec3(uWaterWidth + 0.02, 3.0, uWaterWidth + 0.02));\n    \n    water = max(water, block);\n    \n    return vec2(water - 0.015, HIT_WATER);\n}\n\nvec2 GetOpaque(vec3 p) {\n    float balls = Sphere(p + vec3(-0.1, -0.0, 0.0), 0.2);\n    \n    balls = min(balls, Sphere(p + vec3(0.4, -0.1, 0.0), 0.3));\n    \n    balls = min(balls, Box(p + vec3(0.0, 0.17, 0.0), vec3(40.0, 1.0, 40.0)*vec3(1.0, 0.03, 1.0)));\n    \n    balls = min(balls, Box(p + vec3(0.0, 0.0, 0.4), vec3(0.2, 1.3, 0.1)));\n    balls = min(balls, Box(p + vec3(0.4, 0.0, -0.4), vec3(0.1, 1.0, 0.1)));\n        \n    float block = Box(p + vec3(0.0, -0.85, 0.0), vec3(uWaterWidth + 0.02, 1.01, uWaterWidth + 0.02));\n  \n    balls = max(balls, block);\n    \n    //balls = min(balls, p.y + 0.15);\n  \n    return vec2(balls, HIT_OPAQUE);\n}\n\nvec2 MinScene(vec2 a, vec2 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\n\nvec2 GetOpaqueScene(vec3 p) {\n    vec2 balls = GetOpaque(p);\n    return balls;\n}\n\nvec2 GetTransparentScene(vec3 p) {\n    vec2 water = GetWater(p);\n    return water;\n}\n\nvec2 GetScene(vec3 p) {\n    vec2 transparent = GetTransparentScene(p);\n    vec2 opaque = GetOpaqueScene(p);\n    vec2 scene = MinScene(transparent, opaque);\n    \n    return scene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(GetScene(p).x - vec3(\n        GetScene(p - e.yxx).x,\n        GetScene(p - e.xyx).x,\n        GetScene(p - e.xxy).x\n    ));\n}\n\nvec3 GetOpaqueNormal(vec3 p) {\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(GetOpaqueScene(p).x - vec3(\n        GetOpaqueScene(p - e.yxx).x,\n        GetOpaqueScene(p - e.xyx).x,\n        GetOpaqueScene(p - e.xxy).x\n    ));\n}\n\nvec2 RayMarchAll(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < RAYMARCH_STEPS; ++i) {\n        vec2 scene = GetScene(ro + rd * t);\n        if (scene.x < MIN_DIST) {\n            return vec2(t, scene.y);\n        }\n        t += scene.x * 0.5;\n        if (t > MAX_DIST) break;\n    }\n    \n    return vec2(MAX_DIST, HIT_NONE);\n}\n\nvec2 RayMarchOpaque(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < RAYMARCH_STEPS; ++i) {\n        vec2 scene = GetOpaqueScene(ro + rd * t);\n        if (scene.x < MIN_DIST) {\n            return vec2(t, scene.y);\n        }\n        t += scene.x;\n        if (t > MAX_DIST) break;\n    }\n    \n    return vec2(MAX_DIST, HIT_NONE);\n}\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = 3.14 * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(float NdotV, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float a)\n{\n    float g1 = GeometryGGX(NdotL, a);\n    float g2 = GeometryGGX(NdotV, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 ShadePBR(vec3 n, vec3 v, vec3 l, vec3 albedo, float roughness, float metallic, out vec3 BRDF, float shadow)\n{\n    vec3 F0 = mix(vec3(0.04), albedo, metallic);\n    vec3 h = normalize(v + l);\n    roughness = roughness * roughness;\n    float NdotL = max(0.0, dot(n, l));\n    float NdotV = max(0.0, dot(n, v));\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n    vec3 Kd = (1.0 - F) * (1.0 - metallic);\n    vec3 radiance = vec3(5.0, 4.0, 3.0);\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, .01) * shadow;\n    \n    BRDF = specularBRDF;\n    \n    return (albedo * 0.08) + ((Kd * albedo / 3.14 + specularBRDF) * radiance * (NdotL * shadow));\n}\n\nfloat Shadow(vec3 P, vec3 N, vec3 L, float noise) {\n    \n    float t = 0.01;\n    vec3 rd = L;\n    vec3 ro = P;\n\tfloat shadowContrib = 1.0;\n    for (int i = 0; i < 30; i++)\n    {\n    \tvec2 scene = GetOpaqueScene(ro + rd * t);\n        shadowContrib = min(shadowContrib, 2.*scene.x / t);\n        t += clamp(scene.x, 0.02, 0.1);\n        if (scene.x < EPSILON || t > 0.9) break;\n    }\n    \n    return clamp(shadowContrib, 0.0, 1.0);\n}\n\nvec3 ShadeOpaque(vec3 P, vec3 N, vec3 V, vec3 L) {\n    vec3 P2 = P * 2.0;\n    vec3 brdfRef;\n    vec3 shade = ShadePBR(N, V, L, vec3(1.0, 0.5, 0.2), 0.4, 0.0, brdfRef, Shadow(P, N, L, 0.0));\n    float checker = mod(floor(P2.x) + floor(P2.y) + floor(P2.z), 2.0);\n    float NdotL = max(0.6, dot(N, L));\n    \n    return mix(shade, shade * 0.8, checker);\n}\n\nvec3 ShadeOpaqueInWater(vec3 P, vec3 N, vec3 V, vec3 L) {\n    float noise = GetNoise(P);\n    vec3 P2 = P * 2.0;\n    vec3 brdfRef;\n    vec3 shade = ShadePBR(normalize(0.2 * P + N), V, L, mix(vec3(0.1, 0.2, 0.3), vec3(1.0, 0.5, 0.2), pow((P.y + 0.14) / uWaterHeight, 2.0)), 1.0, 0.0, brdfRef, Shadow(P, N, L, noise * 1.0));\n    float checker = mod(floor(P2.x) + floor(P2.y) + floor(P2.z), 2.0);\n    \n    shade *= 2.0;\n    shade = mix(shade, shade * 0.8, checker);\n    \n    \n    vec2 scene = RayMarchAll(P + N * 0.1, N);\n    vec3 p = (P + N * 0.1) + N * scene.x;\n    \n    shade = mix(shade, shade * 8.2, noise * 7.0);\n    return shade ;\n}\n\nvec3 ShadeTransparent(vec3 P, vec3 N, vec3 V, vec3 L) {\n    vec3 brdfRef;\n    vec3 shade = ShadePBR(N, V, L, vec3(0.0, 0.0, 0.0), 0.09, 0.0, brdfRef, 1.0);\n    \n    vec3 rd = normalize(reflect(-V, N));\n    vec3 ro = P + rd * 0.01;\n    vec2 scene = RayMarchOpaque(ro, rd);\n    if (scene.y > HIT_NONE) {\n        vec3 p = ro + rd * scene.x;\n        vec3 n = GetOpaqueNormal(p);\n        vec3 v = normalize(-rd);\n        vec3 opaque = ShadeOpaque(p, n, v, L);\n        return opaque * 0.5;\n    }\n    return brdfRef;\n}\n\nvec3 GetColor(vec3 ro, vec3 rd, vec3 lightDir, out float dist)\n{\n    vec3 water = vec3(0.0);\n    vec3 color = vec3(0.0);\n    vec2 scene = RayMarchAll(ro, rd);\n\tvec3 V = -normalize(rd);\n\n    dist = scene.x;\n    \n    if (scene.y > HIT_NONE) {\n        vec3 p = ro + rd * dist;\n        vec3 n = GetNormal(p);\n        if (scene.y == HIT_WATER) {\n            water = ShadeTransparent(p, n, V, lightDir);\n            rd = normalize(refract(rd, n, 1.0 / uRefraction));\n            ro = p;\n            scene = RayMarchOpaque(ro, rd);\n            p = ro + rd * scene.x;\n            n = GetOpaqueNormal(p);\n            dist = scene.x;\n            color = ShadeOpaqueInWater(p, n, V, lightDir) + water;\n        } else {\n            color = ShadeOpaque(p, n, V, lightDir);\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 lightDir = normalize(vec3(0.2, 0.1, -0.2));\n    vec3 color = vec3(.0);\n\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * ar;\n    vec3 ro = vec3(uv.x, uv.y + 1.5, -4.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.85, 3.0));\n    \n    float mx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14;\n    float my = (iMouse.y / iResolution.y * 2.0 - 1.0);\n                \n    uWaterHeight += clamp(my, -0.3, 0.8);\n        \n    ro.xz *= Rotate(mx);\n    rd.xz *= Rotate(mx);\n    \n    vec2 scene = RayMarchAll(ro, rd);\n    float dist = scene.x;\n    \n\tcolor = GetColor(ro, rd, lightDir, dist);\n    \n    color *= 1.0 - (dist / MAX_DIST);\n    \n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}