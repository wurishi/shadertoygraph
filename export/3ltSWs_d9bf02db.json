{"ver":"0.1","info":{"id":"3ltSWs","date":"1581962228","viewed":381,"name":"approx of min/max","username":"FabriceNeyret2","description":"max() = Lâˆž norm. can be approx by L_big.\n-> many applications:\n- derivable -> ease analytical calculations and many iterative algorithms\n- like sRGB <-> flat color space, allows to replace op by + . Eg, MIPmap: https://shadertoy.com/results?query=minmax","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["optimization","min","smoothmin","max","smoothmax"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(v)  smoothstep(2./R.y,0., v)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R;\n\n    float p = 15., // choose carefully: largest that doesn't cause overflow\n         x1 = U.x, x2 = U.x + iTime/6.,\n#if 0    // better for testing max possible p (artifacts near y=0 ).\n         v0 = .5+.5*cos(6.28*x1),\n         v1 = .5+.5*cos(6.28*x2),\n#else\n         v0 = .5+.3*cos(6.28*x1)     + .2*sin(6.28*x1*2.7),\n         v1 = .5+.2*cos(6.28*x2*1.3) - .3*sin(6.28*x2*3.1),\n#endif\n          m = pow( pow(v0,-p) + pow(v1,-p), -1./p), // approx min\n          M = pow( pow(v0, p) + pow(v1, p),  1./p); // approx Max\n         // quite like to_sRGB( Sum_i{ from_sRGB( C[i] ) } )\n    \n    O = S( U.y- vec4(m,M,0,0) );                    // draw yellow:pseudo-min, green:pseudo-max\n    \n    O = mix( O, vec4(1,0,0,0), S( abs(U.y-v0) ) );  // draw curves\n    O = mix( O, vec4(1,0,0,0), S( abs(U.y-v1) ) );\n}","name":"Image","description":"","type":"image"}]}