{"ver":"0.1","info":{"id":"cls3DM","date":"1671858165","viewed":51,"name":"Neptune and Moons (Not Accurate)","username":"Ferlox32","description":"Shader including raymarching and bumpmaps representing Neptune and a few of it's moons, scaled-up and sped-up to enchance the viewing experience. I tried to represent the disparity in orbits and sizes of the moons, taking a different equation for each.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bump","bumpmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Martijn Steinrucken\n//\n// https://twitter.com/the_artofcode?lang=en\n// https://www.youtube.com/TheArtOfCodeIsCool \n//\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n// https://www.youtube.com/watch?v=Ff0jJyyiVyw\n// https://www.youtube.com/watch?v=AfKGMUDWfuE\n// https://www.youtube.com/watch?v=Vmb7VGBVZJA\n//\n// https://michaelwalczyk.com/blog-ray-marching.html\n// https://www.lcg.ufrj.br/cwdc/13-webgl/shaderToy.mp4\n//\n// A very simple ray marching implementation,\n// with a few SDF functions: sphere, torus, box, cylinder.\n// Boolean operations are also available: \n// union, intersection, difference and blend.\n// \n// The beauty of the method is that there are no more polygons or vertices, \n// but objects are just scalar fields, given by Signed Distance Functions (SDFs).\n//\n// Paulo Roma\n// 17/07/2022\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n\n\n\n\n// Rotation matrix.\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 Rot3(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\nfloat ndot(in vec2 a, in vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat SolD = 0.0;\nvec3 CoordCentrais = vec3(0, 1, 8);\n\n// SDF of a torus at the origin given its two radius.\nfloat dTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n\n    return length(vec2(x, p.y)) - r.y;\n}\n\n// SDF of a box at the origin given its size (width, height and depth).\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\n// SDF of a sphere, given its center and radius.\nfloat dSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\n// SDF of a cylinder given a segment and a radius.\nfloat dCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n\n    vec3 c = a + t * ab;\n\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n\n    return e + i;\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n    if(3.0 * p.x < m)\n        q = p.xyz;\n    else if(3.0 * p.y < m)\n        q = p.yzx;\n    else if(3.0 * p.z < m)\n        q = p.zxy;\n    else\n        return m * 0.57735027;\n\n    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n    return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\nfloat sdDeathStar(in vec3 p2, in float ra, float rb, in float d) {\n  // sampling independent computations (only depend on shape)\n    float a = (ra * ra - rb * rb + d * d) / (2.0 * d);\n    float b = sqrt(max(ra * ra - a * a, 0.0));\n\n  // sampling dependant computations\n    vec2 p = vec2(p2.x, length(p2.yz));\n    if(p.x * b - p.y * a > d * max(b - p.y, 0.0))\n        return length(p - vec2(a, b));\n    else\n        return max((length(p) - ra), -(length(p - vec2(d, 0)) - rb));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n  // sampling independent computations (only depend on shape)\n    vec3 ba = b - a;\n    float l2 = dot(ba, ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr * rr;\n    float il2 = 1.0 / l2;\n\n  // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa, ba);\n    float z = y - l2;\n    float x2 = dot2(pa * l2 - ba * y);\n    float y2 = y * y * l2;\n    float z2 = z * z * l2;\n\n  // single square root!\n    float k = sign(rr) * rr * rr * x2;\n    if(sign(z) * a2 * z2 > k)\n        return sqrt(x2 + z2) * il2 - r2;\n    if(sign(y) * a2 * y2 < k)\n        return sqrt(x2 + y2) * il2 - r1;\n    return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;\n}\n\n// B + A\nfloat unionSDF(float sda, float sdb) {\n    return min(sda, sdb);\n}\n\n// B * A\nfloat intersectionSDF(float sda, float sdb) {\n    return max(sda, sdb);\n}\n\n// B - A\nfloat differenceSDF(float sda, float sdb) {\n    return max(-sda, sdb);\n}\n\n// Blend A and B\nfloat blendSDF(float sda, float sdb, float k) {\n    float h = clamp(0.5 + 0.5 * (sdb - sda) / k, 0.0, 1.0);\n    return mix(sdb, sda, h) - k * h * (1.0 - h);\n}\n\nfloat getDistBodies(vec3 orig, vec3 dest) {\n    return pow(pow(orig.x - dest.x, 2.0) + pow(orig.y - dest.y, 2.0) + pow(orig.z - dest.z, 2.0), 0.5);\n}\n\n// Scene SDF: signed distance function.\nfloat r1 = 0.04;\nfloat r2 = 0.08;\nfloat tamanho1 = 1.0;\nfloat tamanho2 = 0.08;\nfloat tamanho3 = 0.08;\n\n\nfloat getDist(vec3 p) {\n\nif(cos(iTime) > sin(iTime)) {\n        r1 = 0.08;\n        r2 = 0.04;\n    } else {\n        r1 = 0.04;\n        r2 = 0.08;\n}\n    \n\n    vec3 sol = p - CoordCentrais;\n    mat2 Tsol = -Rot(PI / 4.0);\n    sol.xz *= Rot(iTime * PI / 6.0);\n    sol.xz *= Tsol;\n    sol.xy *= Tsol;\n\n    vec3 anjo = p - vec3(-9, 2, 15);\n    anjo.xz *= Rot(iTime / 3.0);\n    anjo.y += sin(iTime) / 3.0;\n\n    vec3 luaAnjo = p - vec3(-9, 3, 15);\n    luaAnjo.xz += vec2(sin(iTime) / 1.2, -cos(iTime) / 1.2);\n    luaAnjo.y += sin(iTime) / 3.0;\n    luaAnjo.y += pow(sin(iTime), 2.0) / 3.5;\n    luaAnjo.xz *= Rot(-iTime / 3.0);\n\n    vec3 planeta1 = p - CoordCentrais;\n    vec3 Tplaneta1 = vec3(sin(iTime / 3.0) * 2.1, 0, -cos(iTime / 3.0) * 2.1);\n    vec2 Tlua1 = vec2(sin(iTime) * 0.8, cos(iTime) * 0.5);\n    planeta1.xz -= Tplaneta1.xz;\n    \n    vec3 planeta4 = p - CoordCentrais;\n    vec3 Tplaneta4 = vec3(sin(iTime / 6.0) * 3., 15, -cos(iTime / 6.0) * 3.);\n    planeta4.xz -= Tplaneta4.xz;\n    \n    vec3 planeta5 = p - CoordCentrais;\n    vec3 Tplaneta5 = vec3(sin(iTime / 2.2) * 1.3, 15, -cos(iTime / 2.2) * 8.);\n    planeta5.xz -= Tplaneta5.xz;\n    \n    vec3 planeta6 = p - CoordCentrais;\n    vec3 Tplaneta6 = vec3(sin(iTime / 7.0) * 9., -15, -cos(iTime / 7.0) * 9.);\n    planeta6.xz -= Tplaneta6.xz;\n    \n    vec3 planeta7 = p - CoordCentrais;\n    vec3 Tplaneta7 = vec3(sin(iTime / 6.0) * 3., -15, -cos(iTime / 6.0) * 3.);\n    planeta7.xz -= Tplaneta7.xz;\n\n    vec3 lua1 = p - CoordCentrais - Tplaneta1;\n    lua1.xz += Tlua1;\n\n    vec3 lua2 = (p - CoordCentrais) - Tplaneta1;\n    lua2.xy -= vec2(sin(iTime * 1.5) * 0.6, -cos(iTime * 1.5) * 1.3);\n\n    vec3 lua3 = (p - CoordCentrais) - Tplaneta1;\n    lua3.yz += Tlua1;\n    lua3.xz += Tlua1;\n\n    vec3 planeta2 = p - CoordCentrais;\n    vec3 Tplaneta2 = vec3(sin(iTime / 2.0) * 2.5, cos(iTime / 2.0) * 1.8, 0) * 1.4;\n    planeta2.xy += Tplaneta2.xy;\n    // nave += Tplaneta2;\n    vec2 Tlua2 = vec2(sin(iTime * 1.3) * 0.8, cos(iTime * 1.3) * 1.3);\n\n    vec3 lua4 = p - CoordCentrais + Tplaneta2;\n    lua4.xz -= Tlua2;\n\n    vec3 lua5 = (p - CoordCentrais) + Tplaneta2;\n    lua5.xy += Tlua2;\n\n    vec3 lua6 = (p - CoordCentrais) + Tplaneta2;\n    lua6.yz += vec2(sin(iTime) * 0.8, -cos(iTime) * 0.5);\n    lua6.xz += Tlua2;\n\n    vec3 aro1 = p - CoordCentrais + Tplaneta2;\n    aro1.xz *= 0.2;\n\n    vec3 planeta3 = p - CoordCentrais;\n    vec3 Tplaneta3 = vec3(0, sin(iTime / 4.0) * 2.1, cos(iTime / 4.0) * 1.8) * 1.7;\n    vec3 Tplaneta3_2 = vec3(sin(iTime / 4.0) * 2.1, 0, cos(iTime / 4.0) * 1.8) * 1.7;\n    vec2 Tlua3 = vec2(sin(iTime * 1.3) * 0.6, cos(iTime * 1.3) * 1.3);\n    planeta3.yz += Tplaneta3.yz;\n    planeta3.xz += Tplaneta3_2.xz;\n\n    vec3 lua7 = p - CoordCentrais + Tplaneta3 + Tplaneta3_2;\n    lua7.xz += Tlua3;\n\n    vec3 lua8 = (p - CoordCentrais) + Tplaneta3 + Tplaneta3_2;\n    lua8.xy += Tlua3;\n    vec3 lua9 = (p - CoordCentrais) + Tplaneta3 + Tplaneta3_2;\n    lua9.yz += Tlua3;\n    lua9.xz += Tlua3;\n\n\n    vec3 fakesun = p - CoordCentrais;\n    vec3 navep1p2 = p - CoordCentrais - Tplaneta1;\n    vec3 navep3sol = (p - CoordCentrais);\n    vec3 navel7l9 = p - CoordCentrais + Tplaneta3 + Tplaneta3_2 + vec3(Tlua3.x, 0, Tlua3.y);\n    vec3 navel9l1 = p - CoordCentrais + Tplaneta3 + Tplaneta3_2 + vec3(Tlua3.x, 0, Tlua3.y) + vec3(0, Tlua3.x, Tlua3.y);\n    navep1p2.xyz += ((sin(iTime) + 1.0) / 2.0) * (-planeta1 + planeta2);\n    navep3sol += ((sin(iTime) + 1.0) / 2.0) * (-fakesun + planeta3);\n    navel7l9 += ((sin(iTime) + 1.0) / 2.0) * (-lua7 + lua9);\n    navel9l1 += ((sin(iTime) + 1.0) / 2.0) * (-lua9 + lua1);\n\n    float dSol = dSphere(sol, vec4(0, 0, 0, 1.3));\n    float dToro = dTorus(fakesun, vec2(tamanho1, 0.05));\n    float dPlaneta1 = dSphere(planeta1, vec4(0, 0, 0, tamanho2));\n    \n    float dPlaneta4 = dSphere(planeta4, vec4(0, 0, 0, tamanho2));\n    float dPlaneta5 = dSphere(planeta7, vec4(0, 0, 0, tamanho2/1.5));\n    float dPlaneta6 = dSphere(planeta6, vec4(0, 0, 0, tamanho2/1.25));\n    float dPlaneta7 = dSphere(planeta5, vec4(0, 0, 0, tamanho2/2.));\n\n    float dLua1 = dSphere(lua1, vec4(0, 0, 0, tamanho3));\n    float dLua2 = dSphere(lua2, vec4(0, 0, 0, tamanho3));\n    float dLua3 = dSphere(lua3, vec4(0, 0, 0, tamanho3));\n    float dPlaneta2 = dSphere(planeta2, vec4(0, 0, 0, tamanho2));\n    float dLua4 = dSphere(lua4, vec4(0, 0, 0, tamanho3));\n    float dLua5 = dSphere(lua5, vec4(0, 0, 0, tamanho3));\n    float dLua6 = dSphere(lua6, vec4(0, 0, 0, tamanho3));\n    float dAro1 = dTorus(aro1, vec2(tamanho2 * 0.35, 0.015));\n    float dPlaneta3 = dSphere(planeta3, vec4(0, 0, 0, tamanho2));\n    float dLua7 = dSphere(lua7, vec4(0, 0, 0, tamanho3));\n    float dLua8 = dSphere(lua8, vec4(0, 0, 0, tamanho3));\n    float dLua9 = dSphere(lua9, vec4(0, 0, 0, tamanho3));\n    float dnavep1p2 = sdRoundCone(navep1p2, vec3(0), normalize(planeta1 - planeta2) / 4.5, r1, r2);\n    float dnavep3sol = sdRoundCone(navep3sol, vec3(0), normalize(fakesun - planeta3) / 6.0, r1, r2);\n    float dnavel7l9 = sdRoundCone(navel7l9, vec3(0), normalize(lua7 - lua9) / 15.0, r1 / 1.5, r2 / 1.5);\n    float dnavel9l1 = sdRoundCone(navel9l1, vec3(0), normalize(lua9 - lua1) / 15.0, r1 / 2.0, r2 / 2.0);\n    float dAnjo = sdOctahedron(anjo, 1.0);\n    float dLuaAnjo = sdOctahedron(luaAnjo, tamanho2 / 1.5);\n\n    // float dasteroide1 = \n    //float dcaixa = dBox(caixa,vec3(2,1,1.5));\n\n    float d = min(differenceSDF(dToro, dSol), dPlaneta1);\n    // float d = min(planeDist,differenceSDF(dTunel,dSol));\n    // d = min(d, dTunel);\n    d = min(d, dPlaneta1);\n    \n    d = min(d, dPlaneta4);\n    d = min(d, dPlaneta5);\n    d = min(d, dPlaneta6);\n    d = min(d, dPlaneta7);\n    \n    d = min(d, dPlaneta2);\n    d = min(d, dPlaneta3);\n    //d = min(d, dLua1);\n    //d = min(d, dLua2);\n    //d = min(d, dLua3);\n    //d = min(d, dLua4);\n    //d = min(d, dLua5);\n    //d = min(d, dLua6);\n    //d = min(d, dLua7);\n    //d = min(d, dLua8);\n    //d = min(d, dLua9);\n    d = min(d, dAro1);\n    SolD = dSol;\n    return d;\n}\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST)\n            break;\n    }\n    return dO;\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary â€” should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(0.001, 0);\n\n    vec3 n = vec3(getDist(p + e.xyy), getDist(p + e.yxy), getDist(p + e.yyx)) -\n        vec3(getDist(p - e.xyy), getDist(p - e.yxy), getDist(p - e.yyx));\n\n    return normalize(n);\n}\n\n// Phong illumination model, given a point and camera position.\nfloat getLight(vec3 p, vec3 ro) {\n    float angle = iTime * PI/16.; // orbit angle based on time\n    vec3 lightPos;\n    lightPos.x = 10.0 * cos(angle);\n    lightPos.y = 0.0;\n    lightPos.z = 10.0 * sin(angle);\n    //vec3(0, 3, 1);\n\n    // lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l, n);\n\n    // ambient component\n    float amb = 0.1;\n    // ambient reflection coefficient\n    float ka = 1.0;\n\n    // diffuse component - apply Lambert's cosine law\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    // diffuse reflection coefficient\n    float kd = 0.8;\n\n    // specular component\n    float shininess = 100.;\n    vec3 v = normalize(ro - p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec, shininess);\n    // specular reflection coefficient\n    float ks = 1.0;\n\n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    float d = rayMarch(p + 2. * n * SURF_DIST, l);\n\n    // cast a ray to the light\n    if(d < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n\n    // ambient + diffuse + specular components\n    return ka * amb + kd * dif + ks * spec;\n}\n\nvec2 getUV(vec3 p)\n{\n    // calculate the cylindrical coordinates of the point\n    float r = length(p.xz);\n    float theta = atan(p.x, p.z);\n    float y = p.y;\n    \n    // map the cylindrical coordinates to a 2D UV coordinate\n    vec2 uv;\n    uv.x = theta / (2.0 * PI) + 0.5; // map theta to [0, 1]\n    uv.y = y;\n    \n    return uv;\n}\n\nvec3 fbm (vec2 uv1, vec2 uv2, vec2 uv3) {\n    vec3 rgb = vec3(0., 0., 0.);\n\tfor (int i = 0; i < 5; i++) {\n        float lod = 5.0 - float(i) -1.0;\n        rgb.r += 0.56 * textureLod(iChannel3, uv1, lod).r;\n        rgb.g += 0.56 * textureLod(iChannel3, uv2, lod).r;\n        rgb.b += 0.56 * textureLod(iChannel3, uv3, lod).r;\n    }\n   return 1.-pow(rgb, vec3(10.0));\n}\n\nvec3 getLightPosition(float radius)\n{\n    float angle = iTime * PI/16.; // orbit angle based on time\n    vec3 lightPos;\n    lightPos.x = radius * cos(angle);\n    lightPos.y = 0.0;\n    lightPos.z = radius * sin(angle);\n    return lightPos;\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera position\n    vec3 ro = vec3(0, 2, 0);\n\n    // projection plane z = 1\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    // Rotate camera down about the x-axis\n    rd.yz *= Rot(PI * 10. / 180.);\n\n    float d = rayMarch(ro, rd);\n\n    // point hit by the ray\n    vec3 p = ro + rd * d;\n\n    // illumination at point p\n    float light_intensity = getLight(p, ro);\n\n    // dark grey\n    // vec3 background_color = vec3(.2, .2, .2);\n    vec3 background_color = vec3(20) / 255.;\n\n    // Antique White color #FAEBD7\n    vec3 surface_color = vec3(250, 235, 215) / 255.;\n    //vec3 surface_color = texture(iChannel1, getNormal(p).xy).xyz;\n\n    // pixel color\n    vec3 color;\n    \n    \n    vec3 planeta1 = p - CoordCentrais;\n    vec3 Tplaneta1 = vec3(sin(iTime / 3.0) * 2.1, 0, -cos(iTime / 3.0) * 2.1);\n    planeta1.xz -= Tplaneta1.xz;\n    \n    vec3 planeta4 = p - CoordCentrais;\n    vec3 Tplaneta4 = vec3(sin(iTime / 6.0) * 3., 15, -cos(iTime / 6.0) * 3.);\n    planeta4.xz -= Tplaneta4.xz;\n    \n    vec3 planeta5 = p - CoordCentrais;\n    vec3 Tplaneta5 = vec3(sin(iTime / 2.2) * 1.3, 15, -cos(iTime / 2.2) * 8.);\n    planeta5.xz -= Tplaneta5.xz;\n    \n    vec3 planeta6 = p - CoordCentrais;\n    vec3 Tplaneta6 = vec3(sin(iTime / 7.0) * 9., -15, -cos(iTime / 7.0) * 9.);\n    planeta6.xz -= Tplaneta6.xz;\n    \n    vec3 planeta7 = p - CoordCentrais;\n    vec3 Tplaneta7 = vec3(sin(iTime / 6.0) * 3., -15, -cos(iTime / 6.0) * 3.);\n    planeta7.xz -= Tplaneta7.xz;\n    \n    vec3 planeta2 = p-CoordCentrais;\n    vec3 Tplaneta2 = vec3(sin(iTime / 2.0) * 2.5, cos(iTime / 2.0) * 1.8, 0) * 1.4;\n    planeta2.xy += Tplaneta2.xy;\n    vec3 planeta3 = p - CoordCentrais;\n    vec3 Tplaneta3 = vec3(0, sin(iTime / 4.0) * 2.1, cos(iTime / 4.0) * 1.8) * 1.7;\n    vec3 Tplaneta3_2 = vec3(sin(iTime / 4.0) * 2.1, 0, cos(iTime / 4.0) * 1.8) * 1.7;\n    planeta3.yz += Tplaneta3.yz;\n    planeta3.xz += Tplaneta3_2.xz;\n    vec2 Tlua3 = vec2(sin(iTime * 1.3) * 0.6, cos(iTime * 1.3) * 1.3);\n    vec3 lua1 = p - CoordCentrais - Tplaneta1;\n    lua1.xz += vec2(sin(iTime) * 0.8, cos(iTime) * 0.5);\n    vec3 lua7 = p - CoordCentrais + Tplaneta3 + Tplaneta3_2;\n    lua7.xz += Tlua3;\n    vec3 lua9 = (p - CoordCentrais) + Tplaneta3 + Tplaneta3_2;\n    lua9.yz += Tlua3;\n    lua9.xz += Tlua3;\n    vec3 fakesun = p - CoordCentrais;\n    \n    \n    vec3 diffuseOver;\n    \n    if((distance(p, planeta1+p) < (tamanho2+0.01) || distance(p, planeta4+p) < (tamanho2+0.01) || distance(p, planeta5+p) < (tamanho2/1.5+0.01) || distance(p, planeta6+p) < (tamanho2/1.25+0.01) || distance(p, planeta7+p) < (tamanho2/2.+0.01)) && d < MAX_DIST) {\n        //globalColor=vec3(0,0.5,1);\n        vec3 n = getNormal(p);\n        p -= CoordCentrais;\n        p.xz -= Tplaneta1.xz;\n        //p.xz *= Rot(iTime * PI / 6.0);\n        // calculate the light position\n        vec3 lightPos = getLightPosition(10.0); // orbit radius of 5 units\n\n        // calculate the lighting for the surface\n        vec3 surfaceToLight = normalize(lightPos - p) * light_intensity;\n        float diffuse = max(dot(surfaceToLight, n), 0.0);\n        vec3 diffuseColor = diffuse * vec3(255,255,255)/255.;\n        \n        color = texture(iChannel1, p.xy).xyz * diffuseColor * vec3(light_intensity);\n        diffuseOver = diffuseColor;\n    } else\n    if(distance(p, planeta2+p) < (tamanho2+0.01) && d < MAX_DIST) {\n        //globalColor=vec3(0,0.5,1);\n        vec3 n = getNormal(p);\n        p -= CoordCentrais;\n        p.xy += Tplaneta2.xy;\n        //p.xz *= Rot(iTime * PI / 6.0);\n        vec3 lightPos = getLightPosition(10.0); // orbit radius of 5 units\n\n        // calculate the lighting for the surface\n        vec3 surfaceToLight = normalize(lightPos - p) * light_intensity;\n        float diffuse = max(dot(surfaceToLight, n), 0.0);\n        vec3 diffuseColor = diffuse * vec3(255,255,255)/255.;\n        \n        color = texture(iChannel1, p.xy).xyz * diffuseColor * vec3(light_intensity);\n        diffuseOver = diffuseColor;\n    } else\n    if(distance(p, planeta3+p) < (tamanho2+0.01) && d < MAX_DIST) {\n        //globalColor=vec3(0,0.5,1);\n        vec3 n = getNormal(p);\n        p -= CoordCentrais;\n        p.yz += Tplaneta3.yz;\n        p.xz += Tplaneta3_2.xz;\n        //p.xz *= Rot(iTime * PI / 6.0);\n        vec3 lightPos = getLightPosition(10.0); // orbit radius of 5 units\n\n        // calculate the lighting for the surface\n        vec3 surfaceToLight = normalize(lightPos - p) * light_intensity;\n        float diffuse = max(dot(surfaceToLight, n), 0.0);\n        vec3 diffuseColor = diffuse * vec3(255,255,255)/255.;\n        \n        color = texture(iChannel1, p.xy).xyz * diffuseColor * vec3(light_intensity);\n        diffuseOver = diffuseColor;\n    } else\n    if(distance(p, vec3(0, 1, 8)) < 0.985 && d < MAX_DIST) {\n        p -= vec3(0, 1, 8);\n        p.xz *= Rot(iTime * PI / 6.0);\n\n        //color = texture(iChannel2, p.xz).xyz;\n        color = vec3(0) * vec3(light_intensity);\n    } else\n    if(getDist(p) == SolD) {\n\n        vec3 n = getNormal(p);\n        p -= vec3(0, 1, 8);\n        p.xz *= Rot(iTime * PI / 6.0);\n        \n        // calculate the light position\n        vec3 lightPos = getLightPosition(10.0); // orbit radius of 5 units\n\n        // calculate the lighting for the surface\n        vec3 surfaceToLight = normalize(lightPos - p) * light_intensity;\n        float diffuse = max(dot(surfaceToLight, n), 0.0);\n        vec3 diffuseColor = diffuse * vec3(255,255,255)/255.;\n\n        vec3 colXZ = vec3(29, 65, 224)/255.;\n        vec3 colYZ = vec3(29, 65, 224)/255.;\n        vec3 colXY = vec3(9, 13, 36)/255.;\n        //vec3 colXZ = texture(iChannel1, p.xz).xyz;\n        //vec3 colYZ = texture(iChannel1, p.yz).xyz;\n        //vec3 colXY = texture(iChannel1, p.xy).xyz;\n        \n        // calculate a bump map offset by sampling the bump map texture\n        vec2 bumpUV = getUV(p); // get the UV coordinates for the bump map\n        vec3 bump = texture(iChannel2, bumpUV).rgb;\n        bump = bump * 2.0 - 1.0; // remap the bump value from [0, 1] to [-1, 1]\n    \n        // perturb the normal vector using the bump map offset\n        n += bump * 0.7; // bumpScale is a scalar value that controls the strength of the bump map effect\n        \n        n = abs(n);\n\n        n *= pow(n, vec3(1));\n        n /= n.x + n.y + n.z;\n        \n        surface_color = colYZ * n.x + colXZ * n.y + colXY * n.z;\n        //surface_color*=vec3(88.)/255.;\n        color = surface_color * diffuseColor * vec3(light_intensity);\n        diffuseOver = diffuseColor;\n    }\n    else \n    {\n        if(d < MAX_DIST) \n        // modulate surface color by the light intensity\n            color = surface_color * light_intensity * diffuseOver;\n        else{\n            //color = background_color * diffuseOver;\n            vec3 rgb = fbm(uv, uv + vec2(0.8, 0.1), uv + vec2(0.3, 0.6));\n\n\n            vec3 col1 = vec3(rgb.r, rgb.r*0.8, rgb.r*0.8);\n            vec3 col2 = vec3(rgb.g*0.9, rgb.g, rgb.g*0.9);\n            vec3 col3 = vec3(rgb.b*0.8, rgb.b*0.8, rgb.b);\n\n            vec3 finalColor = max(col1, max(col2, col3));\n\n            vec2 pixel = 1.0 / iResolution.xy;\n            vec2 first = step(pixel, uv);\n            uv  = step(fract(uv), pixel);\n            color = mix(finalColor, vec3(0.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y);\n            \n        }\n    }\n    // output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}