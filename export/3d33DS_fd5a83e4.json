{"ver":"0.1","info":{"id":"3d33DS","date":"1569168061","viewed":94,"name":"my-balls","username":"pqnet","description":"balls. My first experiment on raymarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nhighp vec4 sphere(vec3 center, float radius, vec3 test) {\n    vec3 normal = normalize(test-center);\n    float dist = length(test - center) - radius;\n    return vec4(normal,dist);\n}\n\nhighp vec4 opUnion(vec4 fst, vec4 snd, float smoothness) {\n    return mix(fst,snd,smoothstep(-smoothness, smoothness, fst.w - snd.w));\n}\n\nhighp vec4 opIntersect(vec4 fst, vec4 snd, float smoothness) {\n    return mix(fst,snd,smoothstep(-smoothness, smoothness, snd.w - fst.w));\n}\n\nhighp vec4 opSubtract(vec4 fst, vec4 snd, float smoothness) {\n    return mix(fst,-snd,smoothstep(-smoothness, smoothness,-snd.w - fst.w));\n}\n\nhighp vec4 opUnion(vec4 fst, vec4 snd) {\n    return mix(fst,snd,step(0., fst.w - snd.w));\n}\n// map: the distance from p to the closest point in the scene\nhighp vec4 map(highp vec3 p) {\n    vec3 center = vec3(0.5);\n    vec3 q = fract(p);\n    float radius = 0.2;\n    vec4 smallSphere = sphere(center + vec3(0.,0.,-1.2 * radius), radius, q);\n    return opUnion(\n        opSubtract (\n            sphere(center, radius, q),\n        \tsmallSphere,\n            0.04\n    \t),\n        opUnion(\n            sphere(center + vec3(radius/4., 0.05,-0.05), radius/4.,q),\n            sphere(center + vec3(-radius/4., 0.05,-0.05), radius/4.,q)\n        )\n    )\n        ;\n}\n\n\n\nlowp vec3 color(highp vec3 p) {\n    //vec3 q = mod(floor(p),5.);\n    //return clamp(q/10.0 + q.yzx / 20.0 + q/30.0 + q.zxy / 14.0,0.,1.);\n    vec3 q = mod(floor(p),3.);\n    //return vec3(0.00);\n    return clamp(q /2.0,0.,1.);\n}\n\n// o: origin, r: ray direction\nhighp vec4 trace(highp vec3 o, highp vec3 r) {\n\tfloat t = 1.;\n    vec3 norm = vec3(0.);\n    for (int i = 0; i < 256; i++ ) {\n        vec3 p = o + r * t;\n        vec4 normd = map(p);\n        norm = normd.xyz;\n        float d = normd.w;\n        if(abs(d)<.0001 || t>20.) break;        \n\n        t += d * 0.5;\n    }\n    return vec4(norm,t);\n}\n\nvec3 phongShading(vec3 position, vec3 normal, vec3 camera, vec3 light) {\n    // ambient light\n    vec3 ia = vec3(1,1,1);\n    vec3 id = vec3(1,1,1);\n    vec3 is = vec3(1,1,1);\n    //material\n    vec3 color = color(position);\n    vec2 txtCoord = vec2(\n        2.0 *atan(normal.x,normal.y)/ M_PI + 0.5,\n        3.0 *\n            acos(1.0 * normal.z) // -1 <> 0 <> 1 -> pi <> pi/2 <> 0\n            / M_PI);\n    float ka = 0.1;\n    float kd = 0.4 * (1.1 + 0.9 * texture(iChannel0,txtCoord).x);\n    float ks = 1.6 * (1.1 - texture(iChannel0,txtCoord).x);\n    float alpha = 30.;\n    \n    vec3 lightDir = normalize(light - position);\n    vec3 viewer = normalize(camera - position);\n    float dist = distance(camera, position);\n    // return vec3(1.0 - dist);\n    vec3 refl = normalize(2.0 * dot(lightDir, normal)  * normal - lightDir);\n    float normalDot = clamp(dot(lightDir,normal), 0., 1.);\n    float reflDot = pow(clamp(dot(refl,viewer), 0., 1.),alpha);\n\tvec3 col =\n        ka * ia * (color + vec3(0.1))/1.1 +\n        kd * normalDot * id * (color+vec3(0.05))/1.05 +\n        ks * step(0.,normalDot) * reflDot * is * (0.4  * color+vec3(1.6))/2.;\n    return col *step(dist, 20.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y * 2.;\n    //fragColor = vec4(1) * step(1.,length(uv));\n    \n    highp vec3 r = normalize(vec3(uv,2.));\n    float the = iTime * 0.2;\n    mat2 rot = mat2(cos(the), -sin(the), sin(the), cos(the));\n    r.yz*= rot * rot ;\n    r.xz*= rot;\n    vec3 o = vec3(0.,0.,iTime);\n    vec4 normt = trace(o,r);\n  \tfloat t = normt.w;\n    vec3 norm = normt.xyz;\n    vec3 lightPos = vec3(o.x,rot *o.yz );\n\tvec3 col = phongShading(\n        o + r * t,\n        norm,\n        o,\n        lightPos\n        );\n    \n    float sunlight = 1.001 * pow(clamp(dot(normalize(lightPos - o),r),0.,1.),55.);\n    col += (vec3(1) - col) * vec3(sunlight);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}