{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#ifdef GL_ES\nprecision highp float;\n#else\nprecision highp float;\n#endif\n\n// -------------------------------\n// 1) Global Constants\n// -------------------------------\nconst int   MAX_STEPS       = 200;    // RM max steps\nconst float MAX_DIST        = 100.0;  // RM max distance\nconst float MIN_DIST        = 0.0010; // RM min distance\nconst float LINE_THICKNESS  = 0.005;  // Thickness of the wireframe lines\nconst float cubeSize = 1.5;           // Size of cubes\nconst float SPACING         = 5.0;    // Distance between cube centers\nconst float aberrationOffset = 0.025; // CA offset\nconst float startRadius= 0.125;       // CA start radius\nconst float endRadius = 1.0;          // CA end radius\nconst float distortionStrength = 0.1; // Lens distorsion strength\nconst int   AA = 1;                   // AA samples\nconst float fallOff = 0.09;           // Light control\nmat3 R;\n\n// -------------------------------\n// 2) Rotation Matrices\n// -------------------------------\nmat3 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0,  0.0,  0.0,\n        0.0,    c,   s,\n        0.0,   -s,   c\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n         c,  0.0, -s,\n         0.0, 1.0,  0.0,\n         s,  0.0,   c\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n          c,   s,  0.0,\n         -s,   c,  0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// -------------------------------\n// 3) Distance to a 3D Line Segment\n// -------------------------------\n/*\nfloat distToSegment(vec3 p, vec3 A, vec3 B)\n{\n    vec3 pa = p - A;\n    vec3 ba = B - A;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 closest = A + ba * t;\n    return length(p - closest);\n} */\n\n// -------------------------------\n// 4) SDF for a Single Wireframe Cube\n// -------------------------------\n\nfloat sdfWireCube(vec3 p) // highly optimized (waldeck)\n{\n    vec3 a = vec3(0.5*cubeSize);\n    vec3 q = abs(p);\n    vec3 r = q - a;\n    vec3 s = step(q, a); \n    r *= r;\n    s *= r;\n    return sqrt(dot(r,vec3(1.0)) - max(max(s.x,s.y),s.z)) - LINE_THICKNESS;\n}\n\n// -------------------------------\n// 5) Scene SDF with Infinite Repetition and Rotation\n// -------------------------------\nfloat mapScene(vec3 p)\n{    \n    // Rotate the point\n    vec3 rotatedP = R * p;\n    \n    // Apply infinite repetition using mod\n    vec3 grid = vec3(SPACING);\n    vec3 p_mod = mod(rotatedP + grid * 0.5, grid) - grid * 0.5;\n    \n    // Compute distance to the wireframe cube at the repeated position\n    float d = sdfWireCube(p_mod);\n    \n    return d;\n}\n\n// -------------------------------\n// 6) Raymarch Function\n// -------------------------------\nfloat raymarch(vec3 ro, vec3 rd, out vec3 hitPos)\n{\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        \n        if(d < MIN_DIST)\n        {\n            hitPos = p;\n            return t; // Hit detected\n        }\n        \n        // Dynamic step size\n        t += d * 0.9; // Multiplier less than 1 to prevent overshooting\n        \n        if(t > MAX_DIST)\n            break;\n    }\n    \n    hitPos = ro + rd * t;\n    return t; // No hit\n}\n\n// -------------------------------\n// 7) Normal Calculation (Optional for Shading)\n// -------------------------------\nvec3 getNormal(vec3 p)\n{\n    float e = 0.001;\n    float d = mapScene(p);\n    \n    float dx = mapScene(p + vec3(e, 0.0, 0.0)) - d;\n    float dy = mapScene(p + vec3(0.0, e, 0.0)) - d;\n    float dz = mapScene(p + vec3(0.0, 0.0, e)) - d;\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\n// -------------------------------\n// 8) Lens Distortion Function\n// -------------------------------\nvec2 lensDistortion(vec2 uv, float k)\n{\n    // Distance from the center\n    float r = length(uv);\n    \n    // Apply barrel distortion\n    float theta = atan(uv.y, uv.x);\n    float rd = r * (1.0 + k * pow(r, 2.0));\n    \n    // Reconstruct distorted coordinates\n    vec2 distortedUV = rd * vec2(cos(theta), sin(theta));\n    return distortedUV;\n}\n\n// -------------------------------\n// 9) Chromatic Aberration Function (Enhanced with Radial Scaling)\n// -------------------------------\nvec3 chromaticAberration(vec2 uv, float baseOffset)\n{\n    // Calculate the radial distance from the center\n    float r = length(uv);\n    \n    // Maximum possible radius with uv normalized to [-1, 1]\n    float maxRadius = sqrt(2.0);\n    \n    // Define at what normalized radius the aberration starts and ends\n    // float startRadius = 0.125; // Starts increasing at 50% of max radius\n    // float endRadius = 1.0;   // Fully applies at max radius\n    \n    // Calculate the scaling factor using smoothstep for smooth transition\n    float factor = smoothstep(startRadius, endRadius, r / maxRadius);\n    \n    // Adjust the base offset based on the scaling factor\n    float offset = baseOffset * factor;\n    \n    // Define offsets for each color channel based on the adjusted offset\n    vec2 offsetR = vec2(offset, 0.0);  // Red shifted right\n    vec2 offsetB = vec2(-offset, 0.0); // Blue shifted left\n    \n    // Shifted UV coordinates for red and blue channels\n    vec2 uvR = uv + offsetR;\n    vec2 uvB = uv + offsetB;\n    \n    // Ray directions for each channel\n    vec3 rdR = normalize(vec3(uvR.x, uvR.y, -1.0));\n    vec3 rdG = normalize(vec3(uv.x, uv.y, -1.0));\n    vec3 rdB = normalize(vec3(uvB.x, uvB.y, -1.0));\n    \n    // Ray origin\n    vec3 ro = vec3(0.0, 0.0, 20.0);\n    \n    // Raymarching for Red Channel\n    vec3 hitPosR;\n    float tR = raymarch(ro, rdR, hitPosR);\n    vec3 colorR = vec3(0.0);\n    if(tR < MAX_DIST)\n    {\n        float fadeR = exp(-fallOff * tR);\n        vec3 N = getNormal(hitPosR);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        // float diffuse = max(dot(N, lightDir), 0.0);\n        colorR = vec3(1.0) * fadeR;\n    }\n    \n    // Raymarching for Green Channel\n    vec3 hitPosG;\n    float tG = raymarch(ro, rdG, hitPosG);\n    vec3 colorG = vec3(0.0);\n    if(tG < MAX_DIST)\n    {\n        float fadeG = exp(-fallOff * tG);\n        vec3 N = getNormal(hitPosG);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        // float diffuse = max(dot(N, lightDir), 0.0);\n        colorG = vec3(1.0) * fadeG;\n    }\n    \n    // Raymarching for Blue Channel\n    vec3 hitPosB;\n    float tB = raymarch(ro, rdB, hitPosB);\n    vec3 colorB = vec3(0.0);\n    if(tB < MAX_DIST)\n    {\n        float fadeB = exp(-fallOff * tB);\n        vec3 N = getNormal(hitPosB);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        // float diffuse = max(dot(N, lightDir), 0.0);\n        colorB = vec3(1.0) * fadeB;\n    }\n    \n    // Combine the color channels\n    return vec3(colorR.r, colorG.g, colorB.b);\n}\n\n// -------------------------------\n// A) Compute Camera Basis Vectors\n// -------------------------------\nvec3 computeCameraForward(vec3 pos, vec3 target)\n{\n    return normalize(target - pos);\n}\n\nvec3 computeCameraRight(vec3 forward, vec3 up)\n{\n    return normalize(cross(forward, up));\n}\n\nvec3 computeCameraUp(vec3 right, vec3 forward)\n{\n    return cross(right, forward);\n}\n\n// -------------------------------\n// 10) Main Image Function with Lens Distortion and Chromatic Aberration\n// -------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 accumulatedColor = vec3(0.0);\n\n    // Apply rotation based on mouse input\n    // Convert mouse coordinates to rotation angles (radians)\n    float angleZ = (iMouse.x / iResolution.x-0.5) * 3.14159;  // Rotate around Y-axis\n    float angleX = (iMouse.y / iResolution.y) * 3.14159;  // Rotate around X-axis\n    \n    // Create rotation matrices with negative angles for inverse rotation\n    mat3 Rx = rotateX(angleX);   // Negative for inverse rotation\n    mat3 Rz = rotateZ(-angleZ);  // Negative for inverse rotation\n    R  = Rz * Rx;                // Combined rotation\n\n    for(int y = 0; y < AA; y++)\n    {\n        for(int x = 0; x < AA; x++)\n        {\n            // Jitter UV coordinates within the pixel\n            vec2 jitter = vec2(float(x), float(y)) / float(AA);\n            vec2 uv = (fragCoord + jitter - 0.5 * iResolution.xy) / iResolution.y;\n\n            // Apply lens distortion\n            uv = lensDistortion(uv, distortionStrength);\n\n            // Apply chromatic aberration\n            vec3 color = chromaticAberration(uv, aberrationOffset);\n\n            accumulatedColor += color;\n        }\n    }\n\n    // Average the accumulated color\n    accumulatedColor /= float(AA * AA);;\n\n    fragColor = vec4(accumulatedColor, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XXtyDM","date":"1735173956","viewed":141,"name":"Wireframe cube grid","username":"waldeck","description":"Implements a raymarchng rendering of an infinite grid of wireframe cubes. Also implements lens distortion and chromatic aberration. Drag the mouse to rotate the scene.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","chromaticaberration","wireframe","cubes","lensdistorsion"],"hasliked":0,"parentid":"","parentname":""}}