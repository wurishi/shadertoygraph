{"ver":"0.1","info":{"id":"4tSXR3","date":"1445190766","viewed":304,"name":"aberration+distortion","username":"zazabe","description":"https://github.com/evanw/oculus-rift-webgl/blob/master/distortion.html","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["vr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n// Values that were scattered throughout the Oculus world demo\nconst vec4 HmdWarpParam = vec4(1.0, 0.22, 0.24, 0.0); // For the 7-inch device\nconst vec4 ChromAbParam = vec4(0.996, -0.004, 1.014, 0.0);\nconst float HMD_HResolution = 1280.0;\nconst float HMD_VResolution = 800.0;\nconst float HMD_HScreenSize = 0.14976;\nconst float HMD_VScreenSize = HMD_HScreenSize / (HMD_HResolution / HMD_VResolution);\nconst float HMD_InterpupillaryDistance = 0.064;\nconst float HMD_LensSeparationDistance = 0.0635;\nconst float HMD_EyeToScreenDistance = 0.041;\nconst float lensOffset = HMD_LensSeparationDistance * 0.5;\nconst float lensShift = HMD_HScreenSize * 0.25 - lensOffset;\nconst float Distortion_XCenterOffset = 4.0 * lensShift / HMD_HScreenSize;\nconst float DistortionFitX = -1.0;\nconst float DistortionFitY = 0.0;\nconst float stereoAspect = 0.5 * HMD_HResolution / HMD_VResolution;\nconst float dx = DistortionFitX - Distortion_XCenterOffset;\nconst float dy = DistortionFitY / stereoAspect;\nconst float fitRadiusSquared = dx * dx + dy * dy;\nconst float Distortion_Scale =\n  HmdWarpParam.x +\n  HmdWarpParam.y * fitRadiusSquared +\n  HmdWarpParam.z * fitRadiusSquared * fitRadiusSquared +\n  HmdWarpParam.w * fitRadiusSquared * fitRadiusSquared * fitRadiusSquared;\n// This samples from a single unwarped [0,0]x[1,1] box containing two views\n// side-by-side that have been rendered using normal perspective projection.\n// The left eye takes up [0,0]x[0.5,1] and the right eye takes up [0.5,0]x[1,1].\nvec4 sample(vec2 point, vec2 ScreenCenter) {\n  if (clamp(point, ScreenCenter - vec2(0.25, 0.5), ScreenCenter + vec2(0.25, 0.5)) != point) return vec4(0.0);\n  vec2 checkerboard = fract(point * vec2(4.0, 2.0)) - 0.5;\n  return vec4(checkerboard.x * checkerboard.y < 0.0 ? 0.25 : 1.0);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n  vec2 oTexCoord = fragCoord.xy / iResolution.xy;\n    \n  // Compute the viewport size\n  bool isRight = oTexCoord.x > 0.5;\n  float x = isRight ? 0.5 : 0.0;\n  float y = 0.0;\n  float w = 0.5;\n  float h = 1.0;\n  // Set up values for the shader\n  float XCenterOffset = isRight ? -Distortion_XCenterOffset : Distortion_XCenterOffset;\n  vec2 LensCenter = vec2(x + (w + XCenterOffset * 0.5) * 0.5, y + h * 0.5);\n  vec2 ScreenCenter = vec2(x + w * 0.5, y + h * 0.5);\n  float scaleFactor = 1.0 / Distortion_Scale;\n  vec2 Scale = vec2(w * 0.5 * scaleFactor, h * 0.5 * scaleFactor * stereoAspect);\n  vec2 ScaleIn = vec2(2.0 / w, 2.0 / h / stereoAspect);\n  // Compute the warp\n  vec2 theta = (oTexCoord - LensCenter) * ScaleIn; // Scales to [-1, 1]\n  float rSq = theta.x * theta.x + theta.y * theta.y;\n  vec2 theta1 = theta * (\n    HmdWarpParam.x +\n    HmdWarpParam.y * rSq +\n    HmdWarpParam.z * rSq * rSq +\n    HmdWarpParam.w * rSq * rSq * rSq);\n  // Compute chromatic aberration\n  vec2 thetaRed = theta1 * (ChromAbParam.x + ChromAbParam.y * rSq);\n  vec2 thetaBlue = theta1 * (ChromAbParam.z + ChromAbParam.w * rSq);\n  vec2 tcRed = LensCenter + Scale * thetaRed;\n  vec2 tcGreen = LensCenter + Scale * theta1;\n  vec2 tcBlue = LensCenter + Scale * thetaBlue;\n  // Apply chromatic aberration\n  fragColor = vec4(\n    sample(tcRed, ScreenCenter).r,\n    sample(tcGreen, ScreenCenter).g,\n    sample(tcBlue, ScreenCenter).b,\n    1.0);\n  // Visualize the unwarped data\n  // fragColor = sample(oTexCoord, ScreenCenter);\n}","name":"","description":"","type":"image"}]}