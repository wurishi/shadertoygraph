{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float SPHERE_DISTANCE = 12.0;\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// the backbone of any noise, or really any chaotic/natural/random looking\n// shader. hash basically maps an input value n to a random location in [0..1]\n// this function does have a period of TWO_PI but because the scaling factor\n// is so large there's significant differences between e.g. hash(0) and hash(TWO_PI)\n// the float data-type is not precise enough to be able to show the pattern even\n// in minute scales\n// and we're sampling with n ranging in the hundreds and thousands - it's basically\n// a reproducable random\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\n// some random noise function that i can't really parse\n// most noise functions are basically chaotic but\n// still continuous mappings whose behavior is complex enough\n// that humans can't see the pattern\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat floorMap( in vec3 pos ) {\n    return pos.z + 10.0 + 60.0 * noise(pos / 12.0);\n    // return 0.04 * noise(pos / 3.0);\n}\n\nfloat ceilMap( in vec3 pos ) {\n    return -pos.z + 30.0 + 30.0 * noise(pos / 12.0);\n    // return 1000.0;\n}\n\nfloat map( in vec3 pos ) {\n    return min(floorMap(pos), ceilMap(pos));\n}\n\nvec3 normal( in vec3 pos, in float t) {\n    float e = 0.001 * t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 camPos( float t ) {\n    float angle = iMouse.x / iResolution.x * 6.2831;\n    mat3 rotMatrix = rotationMatrix( vec3(0, 0.0, 1.0), angle);\n    return rotMatrix * vec3(60.0, 20.0, 0.0);\n}\n\nbool raycast( in vec3 rO, in vec3 rD, out float t ) {\n    bool hit = false;\n    for(int i = 0; i < 200; i++) {\n        float dist = map(rO + t * rD);\n        if(dist < 0.0) { // move outward in the normal's direction\n            vec3 norm = normal(rO+t*rD, t);\n            \n        }\n        if(dist < 0.01) {\n            hit = true;\n            break;\n        }\n        t += max(0.1, dist * 0.25);\n    }\n    \n\treturn hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fovX = radians(60.0),\n          fovY = fovX * iResolution.y / iResolution.x;\n\tvec2 xy = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    vec3 camPosition = camPos(iTime);\n    vec3 camTarget = vec3(0.0, 0.0, iMouse.y / iResolution.y * 250.0 - 125.0);\n    vec3 up = vec3(0.0, .0, 1.0);\n    \n    vec3 camDirection = normalize(camTarget - camPosition),\n         camRight = cross(camDirection, up),\n    \t camUp = cross(camRight, camDirection);\n    \n    vec3 rO = camPosition;\n    \n    float angleX = -mix(0.0, fovX, xy.x);\n    float angleY = -mix(0.0, fovY, xy.y);\n    mat3 rotAroundUp = rotationMatrix(camUp, angleX);\n    // rotate camDirection to the correct X angle\n    vec3 rD = rotAroundUp * camDirection;\n    vec3 rotatedCamRight = rotAroundUp * camRight;\n    mat3 rotAroundRight = rotationMatrix(rotatedCamRight, angleY);\n    rD = rotAroundRight * rD;\n    \n    float t = 0.0;\n\tbool hit = raycast( rO, rD, t);\n    \n    vec3 dif1Dir = normalize(vec3(1.0, -1.0, 1.0));\n    vec3 ambientLight = vec3(0.2, 0.17, 0.14);\n    \n    vec3 fogColor = vec3(0.38, 0.40, 0.45);\n    float fogFactor = exp(-t / 200.0);\n    \n    vec3 col = vec3(0.0);\n    \n    if( hit ) {\n        vec3 norm = normal( rO + t*rD, t );\n        float dif1Comp = clamp(dot(dif1Dir, norm), 0.0, 1.0);\n        float shadowFactor = 0.0; //accumulateShadowFactor( rO + t*rD, dif1Dir);\n        \n    \tcol = ambientLight;\n        col += vec3(0.7, 0.75, 0.79) * dif1Comp * (1.0 - shadowFactor);\n        col = mix(col, fogColor, 1.0 - fogFactor);\n        \n        // col = vec3(clamp(abs(map(rO+t*rD)) * 100.0, 0.0, 1.0));\n    } else {\n        col = fogColor;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldSSzd","date":"1414883294","viewed":252,"name":"Granuland","username":"hellochar","description":"Adding some noise to a simple floor and ceiling","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing"],"hasliked":0,"parentid":"","parentname":""}}