{"ver":"0.1","info":{"id":"lcjGDD","date":"1704252232","viewed":44,"name":"Complex function visualizer","username":"megaleo","description":"Simple complex function visualizer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 f(vec2 z)\n{\n    return cx_log(cx_div((z + vec2(1.0, 0.0)), (z - vec2(1.0, 0.0))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized and centralized pixel coordinates\n    float aspect_ratio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.x;\n    uv -= vec2(0.5, 0.5 * aspect_ratio);\n\n    vec2 fz = f(iTime*uv);\n    vec2 fzPolar = cx_to_polar(fz);\n    vec3 col = hsb2rgb(vec3(fzPolar.y / (2.0*PI), 1.0, tanh(fzPolar.x)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex Number math by julesb\n// https://github.com/julesb/glsl-util\n// Additions by Johan Karlsson (DonKarlssonSan) & me\n\n#define PI 3.1415926539\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x, -a.y)\n#define cx_arg(a) atan(a.y, a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n#define cx_exp(a) exp(a.x) * vec2(cos(a.y), sin(a.y))\n\nvec2 cx_sqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = sqrt((a.x*a.x)+(a.y*a.y));\n    float ipart = atan(a.y,a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) {\n    return a + cx_div(vec2(1.0,0.0), a);\n}\n\nvec2 cx_z_squared_plus_c(vec2 z, vec2 c) {\n    return cx_mul(z, z) + c;\n}\n\nvec2 cx_sin_of_one_over_z(vec2 z) {\n    return cx_sin(cx_div(vec2(1.0,0.0), z));\n}\n\nvec2 cx_to_polar(vec2 a) {\n    float phi = atan(a.y, a.x);\n    float r = length(a);\n    return vec2(r, phi); \n}\n    \n// Complex power\n// Let z = r(cos θ + i sin θ)\n// Then z^n = r^n (cos nθ + i sin nθ)\nvec2 cx_pow(vec2 a, float n) {\n    float angle = atan(a.y, a.x);\n    float r = length(a);\n    float real = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(real, im);\n}\n\n/////////////////\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"}]}