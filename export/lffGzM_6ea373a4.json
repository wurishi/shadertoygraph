{"ver":"0.1","info":{"id":"lffGzM","date":"1716546244","viewed":41,"name":"2D Honeycomb Wythoff Construct","username":"hissanova","description":"2d honeycomb using wythoff construction.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\nconst float target_h = 2.0;//+ pow(t,1.5);\nconst float line_width = target_h * 0.01;\n\nconst vec2 n = - vec2(.5, .5 * sqrt(3.0));\n\nstruct Line{\n    vec2 normal;\n    float dist;\n};\n\nconst Line[3] LINES = Line[3](\n    Line(vec2(1.0, 0.0), 0.0),\n    Line(vec2(0.0, 1.0), 0.0),\n    Line(n, -0.25)\n);\n\nfloat distance_to(Line l, vec2 p){\n    vec2 slide = l.dist * l.normal;\n    return dot(p - slide, l.normal);\n}\n\nfloat[3] calc_dists(vec2 p, Line[3] lines){\n    float[3] dists;\n    for (int i=0; i<3; i++){\n        dists[i] = distance_to(lines[i], p);\n    }\n    return dists;\n}\n\nvec2 reflection_in(Line l, vec2 p){\n    vec2 slide = l.dist * l.normal;\n    return reflect(p - slide, l.normal) + slide;\n}\n\nfloat get_mix_level(float dist){\n    return smoothstep(0.0, line_width, dist);\n}\n\nstruct ReflectionResults{\n    float[3] dists;\n    int num_flips;\n};\n\nconst int MAX_ITER = 50;\nReflectionResults to_fund_region(vec2 uv){\n    int num_flips = 0;\n    float[3] dists = calc_dists(uv, LINES);\n    bool any_neg = any(bvec3(dists[0]<0., dists[1]<0.,dists[2]<0.));    \n    while (num_flips < MAX_ITER && any_neg) {\n        for (int i=0; i<3;i++){\n            if (dists[i] < 0.0){\n                uv = reflection_in(LINES[i], uv);\n                num_flips++;\n                break;\n            }\n        }\n        dists = calc_dists(uv, LINES);\n        any_neg = any(bvec3(dists[0]<0., dists[1]<0.,dists[2]<0.));\n    }\n    return ReflectionResults(dists, num_flips);\n}\n\n//const vec3 COL_ODD = vec3(1.0, 0.55, 0.2);\nconst vec3 COL_ODD = vec3(0.2, 0.8, 1.0);\nconst vec3 COL_EVEN = vec3(0.8, 0.9, 0.2);\n//const vec3 COL_LINE = vec3(0.2, 0.8, 1.0);\nconst vec3 COL_LINE = vec3(0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    /*--Scaling the coordinates.--*/\n    vec2 uv =  target_h * (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    ReflectionResults ref_res = to_fund_region(uv);\n    float[3] dists = ref_res.dists;\n    // fundamental triangles background\n    float min_dist = min(min(abs(dists[0]), abs(dists[1])), abs(dists[2]));\n    vec3 col_in = COL_ODD, col_out = COL_EVEN;\n    if (ref_res.num_flips % 2 == 0){\n        col_in = COL_EVEN;\n        col_out = COL_ODD;}\n    col = mix(col_out, col_in, smoothstep(-0.01, 0.01, min_dist));\n    // Switching between three different wythoff's construction line segments\n    float t = .25 * iTime;\n    float mixture = sin(PI/2.*fract(t))*sin(PI/2.*fract(t));\n    int ind = int(t) % 3;\n    float f1, f2;\n    if (ind == 0){\n        f1 = get_mix_level(dists[0]);\n        f2 = get_mix_level(dists[1]);\n    } else if (ind ==1) {\n        f1 = get_mix_level(dists[1]);\n        f2 = get_mix_level(dists[2]);\n    } else {\n        f1 = get_mix_level(dists[2]);\n        f2 = get_mix_level(dists[0]);\n    }\n    col = mix(COL_LINE, col, mix(f1, f2, mixture));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}