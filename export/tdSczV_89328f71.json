{"ver":"0.1","info":{"id":"tdSczV","date":"1627149175","viewed":157,"name":"Magmalbrot","username":"spalmer","description":"A mandelbrot island somewhere in black body radiator fractal hell","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["fractal","mandelbrot","mandelbrot","fire","blackbody","boltzmann","planck","magma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Magmalbrot by spalmer\n// an experiment in fire palette black body radiator Planck law stuff\n// made a (poor) Mandelbrot \"island\" using iq's brot distance estimator\n// this is just the bloom, dirt mask, and lens flare\n// see Buffer D for image, Buffer C for camera\n\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec2 dx = dFdx(u), dy = dFdy(u);\n    o = vec4(0);\n    o = texelFetch(iChannel0, ivec2(u), 0);\n    u /= iResolution.xy;\n//    o = texture(iChannel0, u);\n    const float tau = 2.*acos(-1.);\n    // could use DotBloom kerning stuff instead of texture for dirt mask\n    float dm = texture(iChannel1, u * 2. * vec2(iResolution.z,1) + .3).x; // simple dirt mask\n    dm = pow(max(dm - .25, 0.) * 1.33, 4.);\n    float vm = pow(max(0., 1. - u.x * u.y * (1.-u.x) * (1.-u.y) * 16.), 4.); // for masking vignette\n    vec2 u2 = .5 + (u-.5) * 3.; // scaled smaller\n    u2 = clamp(u2, 0., 1.);\n    float vm2 = pow(max(0., u2.x * u2.y * (1.-u2.x) * (1.-u2.y) * 16.), 2.); // for masking vignette\n    dm *= vm; // vignette keep glare away from center of view\n    dm = mix(dm, 1., .05); //  allow some bloom everywhere\n    // this bloom accumulation filter actually sucks, has many visible artifacts, but looks better than sampling the mips\n    for (float x = 1.; x > 0.; x -= .02)\n    {\n        vec2 w = sin((vec2(0,.25) + x) * 5. * tau) * sqrt(x) * .375; // Vogel disc like spinny thing\n        //exp2(4.*x) - 1.\n        o += dm * max(textureLod(iChannel0, u + w, 0.) / (32.+96.*x) - .01, 0.); // strange gaussianish blur for bloom\n    }\n    // image based \"lens flares\" - not so good yet\n//    o += max(textureLod(iChannel0, 1.-u, 1.)*.11-.25, 0.) / (1. + 35. * distance(u, vec2(.5)));\n//    o += .2*vm2 * max(textureLod(iChannel0, u2, 2.)*.15-.15, 0.) / (1. + 3. * distance(u, vec2(.5))); // zoomed out, smaller\n//    o += .2*vm2 * max(textureLod(iChannel0, 1.-u2, 2.)*.15-.15, 0.) / (1. + 3. * distance(u, vec2(.5))); // zoomed out, smaller\n//    o += .3*max(textureLod(iChannel0, .25+.5*u, 2.)*.15-.15, 0.) / (1. + 3. * distance(u, vec2(.5))); // zoomed in, enlarged... weird!\n    // TODO textureGrad for aniso bloom bokeh?\n//    o += .3  * textureLod(iChannel0, u, 1.);\n//    o += .25 * textureLod(iChannel0, u, 2.);\n//    o += .2  * textureLod(iChannel0, u, 3.);\n//    o += .15 * textureLod(iChannel0, u, 4.);\n//    o += 1. * textureGrad(iChannel0, u, vec2(1./iResolution.x,0), vec2(0,1./iResolution.y));\n//    o += 1. * textureGrad(iChannel0, u, vec2(16./iResolution.x,0), vec2(16./iResolution.x,0));\n//    o += .4 * textureGrad(iChannel0, u, vec2(2./iResolution.x,0), vec2(0,1./iResolution.y));\n//    o += .2 * textureGrad(iChannel0, u, vec2(4./iResolution.x,0), vec2(0,1./iResolution.y));\n//    o += .1 * textureGrad(iChannel0, u, vec2(8./iResolution.x,0), vec2(0,1./iResolution.y));\n//    o += .3 * textureGrad(iChannel0, u, 1.* dx, dy); //vec2(.4,0), vec2(0,1));\n//    c *= .2; // white point exposure so we can see more of the spectrum\n\t// otherwise not much tone mapping going on, just letting colors blow out\n    //c = pow(c, vec3(1./2.2));\n    o = 1.35 * o / (o + .067); // HACK Reinhard tonemap + sRGB gamut conversion\n//    o = vec4(u2, .5, 1);\n}\n\n// TODO chromatic aberration?","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// from Debug Camera https://shadertoy.com/view/WlVGDh\n// BufferC controls the state, mostly the camera location+direction\n// but wound up needing old mouse state and, for smoothing,\n// the desired facing direction.\n\n#define BufferC   iChannel2  // also the shader fragColor output\n#define Keyboard  iChannel3\n\nconst float moverate = .5; // actually very slow.\nconst float turnratemouse = .02; // since mouse can't go outside window, must be pretty fast\nconst float turnratekbd = 2.6;\n\n\nvec3 desiredDirection() \n{\n    return loadValue(BufferC, slotDesiredForward).xyz;\n}\n\nvec4 oldMouse() \n{\n    return loadValue(BufferC, slotMouseOld);\n}\n\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = loadValue(Keyboard, vk).x; // read keyboard key state from texture\n    return step(.5, s); // test if down\n}\n\nconst int\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://en.wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90 // but Image tab is using it for showing depth FIXME\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_COMMA = 188 //188 JS, 44 ASCII\n, KEY_X     = 88 // used by Image tab; should keys move to Common tab?\n, KEY_LEFT  = 37 // arrow keys for lookaround\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40 // I suppose you could bind them instead of WASD if you really prefer, but then must use mouse to look\n#if 0 // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0 // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE\n, KEY_DW    = KEY_C  // anything but control!\n;\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition(BufferC);\n    float\n      fw = key(KEY_FW)\n    , bw = key(KEY_BW)\n    , lf = key(KEY_LF)\n    , rt = key(KEY_RT)\n    , up = key(KEY_UW)\n    , dn = key(KEY_DW);\n    //if (asleep(iMouse.xy)) fw = .5; // automate forward in thumbnails\n    vec3 camfwd = cameraDirection(BufferC);\n    mat3 camori = cameraMatrix(camfwd);\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 4.0; // shift key for speed boost\n    campos += camori * cammove;\n    const float camradius = .04;\n//    campos += sdfnormal(campos) * -min(sdf(campos) - camradius, .0); // collision with sdf\n    return campos;\n}\n\nvec3 cameraSteering(bool shift)\n{\n    vec3 desiredRot = desiredDirection();\n    vec4 oMouse = oldMouse();\n    bool lmb = iMouse.z >= 0.;\n    bool olmb = oMouse.z >= 0.;\n    float shiftmod = shift ? .5 : 1.; // shift actually slows rotation down\n    vec2 orbit = vec2(0);\n    if (asleep(iMouse.xy)) {\n    \t//orbit = vec2(.05*iTimeDelta, 0);   // attract mode slow spin\n\t} else {\n    \tif (lmb && olmb) {\n\t        vec2 m = iMouse.xy - oMouse.xy;\n    \t    orbit += m * turnratemouse * shiftmod;\n    \t} \n    \t{\n    \t\tfloat aL = key(KEY_LEFT), aR = key(KEY_RIGHT), aU = key(KEY_UP), aD = key(KEY_DOWN);\n\t        vec2 m = vec2(aR - aL, aU - aD);\n    \t    orbit += m * iTimeDelta * turnratekbd * shiftmod;\n        }\n    }\n    if (dot(orbit,orbit) != 0.) {\n        rot(desiredRot.xz, cossin(orbit.x));\n        vec2 vr = vec2(1.,desiredRot.y);\n        rot(vr, cossin(-orbit.y));\n        desiredRot.xz *= max(1e-1f, vr.x); // do not flip signs here!\n        desiredRot.y = vr.y;\n  \t\tdesiredRot = normalize(desiredRot);\n    }\n    return desiredRot;\n}\n\n// smoothing filter\nvec3 cameraSmoothing()\n{\n    vec3 camfwd = cameraDirection(BufferC);\n    vec3 desiredFwd = desiredDirection();\n    camfwd = normalize(mix(desiredFwd, camfwd, exp2(-64.*iTimeDelta)));\n    return camfwd;\n}\n\n// implements a debugging fly camera using keyboard WASD + mouse + C/space\n// stores camera position,aim,etc. into c as a \n// color coded vector suitable for output to buffer\nvoid debugFlyCamera(out vec4 c, vec2 p)\n{    \n    ivec2 ip = ivec2(p);\n\t// ignore most pixels - otherwise using an entire buffer is really bad\n    if (!(ip.y == 0 && ip.x < slotCount)) return;\n    c = loadValue(BufferC, ip.x); // passthru by default\n    bool shift = key(KEY_SHIFT) > .5;\n    bool init = iFrame < 3; //iFrame == 0; // thumbnail issues\n    switch (slotid(ip)) {\n      case slotCameraPosition: {\n \t    c.xyz = init ? vec3(9,6,-8) : cameraMovement(shift);            \n        break;\n      }\n      case slotCameraForward: {\n        c.xyz = init ? vec3(0,0.,1.) : cameraSmoothing();\n        break;\n      }\n      case slotDesiredForward: {\n        c.xyz = init ? normalize(vec3(-.8,-.8,.6)) : cameraSteering(shift);\n        break;\n      }\n      case slotMouseOld: {\n        c = iMouse;\n        break;\n      }\n      default:\n        break;\n    }\n}\n    // 4 inefficient pixels shouldn't be a huge deal\n\n// in this case we output into Buffer C\nvoid mainImage(out vec4 c, vec2 p)\n{\n//    if (p.y >= 1. || int(p.x) >= slotCount) discard;\n    debugFlyCamera(c, p);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// buffer mapping logic, could wrap to subsequent rows\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n// channel allocations can't be done in Common,\n// as the defines for the iChannel# samplers have not yet been set.\n// but we can allocate the slots within BufferC at least.\n\nconst int slotCameraPosition = 0;\nconst int slotCameraForward  = 1;\nconst int slotDesiredForward = 2;\nconst int slotMouseOld       = 3; // iMouse from prior frame\nconst int slotCount          = 4;\n\nconst float pi = 3.141592;\n\nvec2 cossin(float r)\n{\n    return sin(r + vec2(.5*pi, 0));\n}\n\n// cheap rotation transform on p by s=(cos(a),sin(a))\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n} // then can rot(q.xz, cossin(a))\n// as matrix\n//mat2 mrot(vec2 s)\n//{\n//    return mat2(s.x, s.y, -s.y, s.x);\n//} // then can q.xz = mrot(cossin(a)) * q.xz;\n// idk yet which I will wind up using\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\n// not much like what I started with in https://shadertoy.com/view/ls3fDr, slightly reversed \nmat3 cameraMatrix(vec3 camFwd)\n{\n    const vec3 camUp = vec3(0, 1, 0); // hard-coded :( HACK\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(camUp, w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then I just transform by pw = MC * pv;\n// I think I should transpose it, as view matrix instead!\n// then it'd be pw = pv * MV;\n\n// refactored to Common; complicated by BufferC isn't available there directly!\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraDirection(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraForward).xyz;\n}\n\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\n\nbool asleep(vec2 mouse) // in shadertoy.com shader browser thumbnail? \n{\n    return dot(mouse, mouse) <= 2.;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// So much work left to do\n// still ugly as ... well, Hades!\n// TODO fix the 'brot rendering\n// TODO better atmospherics\n// TODO heat distortion fx\n\n#define BufferC   iChannel2\n#define Keyboard  iChannel3\n\n\n// using https://academo.org/demos/wavelength-to-colour-relationship/\n// I've mapped out sRGB to wavelength in nm nanometers for the RGB primaries,\n// too bad I could not find them listed anywhere directly.\n// for sRGB, everything from 645 to 697 maps to (255,0,0),  510 maps to (0,255,0),  440 maps to (0,0,255)\n// 580 is yellow; cyan is 490 nm, blue-ray laser at 405 is violet\n// 380 is magenta (not corresponding to a physical wavelength at all; outside visible spectrum),\n// Wikipedia says human eyes respond to light from 390 to 700 nm in wavelength\nconst vec3 wavelength_srgb = vec3(670., 510., 440.);  // in nm\n\n#if 0\n// compute StefanBoltzmann constant a\n\tdouble k = 1.3806485279e-23; // J / K\n\tdouble c = 299792458; // speed of light, m/s\n\tdouble h = 6.62607004081e-34; // J*s // 0.000000056703669437859474; // \n\tconst double a_ = 2*pi*pi*pi*pi*pi*k*k*k*k/15/c/c/h/h/h; // says 5.6703669437859474e-08, which would make b_ = 0.01543130982666, a little smaller\n\tconst double b_ = pow(a, .25); //  = 1/64.8033.. // if so, then for the above a, b would be 0.01543131394699777831325512576138 W/m^2/K\n#endif\n\n// see https://en.wikipedia.org/wiki/Stefan%E2%80%93Boltzmann_law\n// compute total power emitted by ideal black body at given temperature in degrees Kelvin\n// across all wavelengths per unit time per unit surface area\nfloat StefanBoltzmannLaw(float T) // T in K\n{\n #if 0\n    // these numbers will get REALLY big\n\tconst float a = 5.6703669e-8; //5.670373e-8; // = 2*pi^5*k^4/15/c^2/h^3, in W/m^2/K^4\n\treturn a * pow(T, 4.);\n #else\n    // move the scale prior to the pow, making the numbers involved smaller.\n\tconst float b = .0154313098; //.0154313139; // = a^(1/4)\n\treturn pow(b * T, 4.);\n #endif // both work\n} // returns units W/m^2\n\nfloat blackbody_lum(float tempK)\n{\n\treturn StefanBoltzmannLaw(.025921318 * tempK); // approximation - FIXME what was the small coefficient for?\n}\n\n// Planckian locus from temperature in degrees Kelvin\n\n// wavelength should be in nanometers (nm), temperature in Kelvin (K)\nfloat PlanckLawFromWavelength(float wavelength, float tempK)\n{\n\twavelength *= 1e-9f; // nm to m\n\t//const float pi = 3.141592...;\n\t//const float c = 299792458; // m/s , or one planck length per planck time\n\t//const float h = 6.62607004081e-34; // J*s planck constant\n\t//const float k = 1.3806485279e-23; // J/K Boltzmann constant\n\tconst float c1 = 3.74177175e-16; //float(2*pi*h*c*c); \n\tconst float c2 = 1.438777013e-2; //float(h*c/k); \n\tfloat r = c1 * pow(wavelength, -5.) \n\t\t/ (exp(c2 / wavelength / tempK) - 1.);\n\treturn r * 1e-9; // convert result to usable range; units must be tiny because results are astronomical. FIXME\n\t// seriously, even this is ridiculous.  \n} // result is in W/m^3, or with the * 1e-9f factor, isn't it W/mm^3 or W/m^2/nm ?  W = J/s, so result is J/s/mm^3; I suppose we could divide out time to account for framerate, but that would hardly affect the result.\n\n\nvec3 BlackBody_Planck_RGB(float tempK)\n{\n\tvec3 c = vec3(PlanckLawFromWavelength(wavelength_srgb.x, tempK)\n\t\t\t\t, PlanckLawFromWavelength(wavelength_srgb.y, tempK)\n\t\t\t\t, PlanckLawFromWavelength(wavelength_srgb.z, tempK));\n\tconst float fudge = .105; //.13; //.08; //\n\treturn c / StefanBoltzmannLaw(fudge * tempK);\n}\t// FIXME the low range is still too dark\n\n// complete HACK fire palette, comes off remarkably good,\n// from ddsol's Bring the Heat https://shadertoy.com/view/4sfBWj\nvec3 FirePaletteBtH(float l) // l is some luminosity/temperature value from 0 to 1\n{\n\t// FIXME hmm now it doesn't look as good as it did in its own toy, maybe it's my gamma; correcting for it doesn't help much\n    return pow(vec3(l), vec3(1.5,3.,6.)*2.2);\n}\n// think it's missing Boltzmann factor and the arg isn't in Kelvin, otherwise it's kind of cool!\n// TODO I believe I can do something with it, but I want to convert it to exp2 first.\n\nvec3 FirePalette(float l)\n{\n//\treturn FirePaletteBtH(mix(l, 1.2, .5));\n//    return vec3(l);\n    // the atmospherics can use fewer mandelbrot iterations \n    // than the high lod distance, and the further \"terrain\"\n    // can also use fewer iterations.\n    float k = mix(500., 5000., l);\n    // now that we have the final temperature in kelvin, \n    // accumulated all along the ray, convert to color.\n    return BlackBody_Planck_RGB(k) * .3; // FIXME SO bright; even hacked down it's pretty bright\n//    vec2 f = fract(q*5. + iTime * .01) - .5;\n//    float k = mix(500., 6000., sqrt(.5) - length(f)); //dot(f,f));\n//    vec3 c = BlackBody_Planck_RGB(k);\n}\n\n// mandelbulb originally from https://shadertoy.com/view/3ttSWf\n// is now 2D!!! so it's a mandelbrot with adjustable exponent\n// and a fractional estimator\nfloat dmandelbulb2(vec2 pos)\n{\n    pos.x -= .5; // center within bound disc\n    // FIXME ideally would have a smoothing mix zone\n    // in fact TODO may as well abstract out the LOD disc\n    if (dot(pos,pos) >= 3.5*3.5) return length(pos)-1.7; // LOD sphere approx when query far away\n    //pos *= 1.3; // fit into unit disc\n    vec2 z = pos;\n\tfloat dr = 1.;\n\tfloat r;\n    r = length(z);\n\t// gives Power - 1 rotated mandelbrot sets! Unsure why off by one etc. but hey.\n    const float Power = 2.; //4.; //7.; // get Power - 1 \"bulbs\" but powers below 2 are not interesting; need at least 2 to get a mandelbrot set at all.\n\tfor (int i = 0; i < 12; ++i) {\n\t\tdr = pow(r, Power - 1.)*Power*dr + 1.; // some way to approximate distance, I don't understand yet\t\n\t\tfloat theta = atan(z.y, z.x);\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, Power);\n\t\ttheta = theta * Power;\n\t\t// convert back to cartesian coordinates to recompute r? agh\n\t\tz = zr * vec2(cos(theta), sin(theta));\n\t\tz += pos;\n        r = length(z);\n\t\tif (r > 1.5) break;\t\t\n\t}\n\treturn .7 * log(r) * r / dr; // - .002; // there is no \"inside\" gradient, just zeroes there, so can't poof or anything.\n    // / 1.3\n}\n\n// FIXME maybe using mandelbulb as a heightfield just isn't good enough, this looks terrible\nfloat hScene(vec3 p)\n{\n    float s = 2.;\n    // some wavy motion\n    p.xz += .02 * sin(1.4*iTime + dot(p.xz, vec2(18.,0.)));\n    p.xz += .04 * sin(1.4*iTime + dot(p.xz, vec2(8.,4.)));\n    float d = dmandelbulb2(p.xz/s/4.);\n    float e = clamp(1. - d * 2.1, 0., 1.);\n    float h = -1. +  //0. - //\n        pow(e, 2./1.); // TODO reshape curve\n    return s * h;\n}\n\nfloat dScene(vec3 p)\n{\n    float h = hScene(p);\n    return p.y - h; // simply make it a height field\n}\n/*\nvec3 nScene(vec3 p)\n{\n    float e = .01;\n    return normalize(vec3(dScene(p + vec3(e,0,0))\n                        , dScene(p + vec3(0,e,0))\n                        , dScene(p + vec3(0,0,e)))\n                        - dScene(p + vec3(0,0,0)));\n}\n*/\nfloat marchScene(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for (uint i = 160u; i-- != 0u; ) {\n        vec3 p = ro + rd * t;\n        float d = dScene(p);\n        if (abs(d) < 1e-4 * t) break;\n        t += .7*d;\n    }\n    return t;\n}\n\n// super hacky \"hotness\", ignore the mess\nfloat marchAtmo(vec3 ro, vec3 rd, float d)\n{\n    //d = max(d, 0.); // just in case!\n    vec3 hitp = ro + rd * d;\n    //vec3 n = nScene(hitp);\n    float h = hitp.y; //hScene(hitp);\n    //h = max(-10., h);\n    //if (d >= 1e5) { n = vec3(0,1,0); h = 0.; }\n    //float nl = n.y; //dot(n, vec3(0,1,0));\n    //float l = clamp(nl, 0., 1.);\n    //l = pow(l, 8.);\n    float u = 1. - exp2(-.04*d); //dScene\n    float v = clamp(-.4*h, 0., 1.); //1. - exp2(-.5*h); //dScene\n    v = pow(v, .5);\n    u *= pow(max(0., .5 - .5*rd.y), 1.5);\n    u = clamp(u, 0., 1.);\n    v = clamp(v, 0., 1.);\n    //l = clamp(l, 0., 1.);\n    //return v; //l; //u; //\n    //return mix(u, mix(v, l, .2), .65);\n    //float a = 0., x = 1.;\n    //for (float t = .1; t < d; t *= 1.01) {\n    //    float b = .5, y = .5;\n    //    a += b * x;\n    //    x *= (1.-y);\n    //}\n    return mix(v, 1., u);\n    //return v; //clamp(1. - exp2(-.04 * d)/* + 1. - exp2(-1e-2 * h)*/, 0., 1.);\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, out float d)\n{\n    d = marchScene(ro, rd);\n    if (!(d >= 0.)) d = 1e5;\n    // then go back and iterate over it in fixed steps \n    // to avoid uneven sampling of atmospherics\n    float a = marchAtmo(ro, rd, d);\n    return FirePalette(a);\n}\n\nvoid ViewRay(vec2 p, out vec3 ro, out vec3 rd, out vec3 vd)\n{\n    vec2 R = iResolution.xy;\n    vec2 q = StoQ(p, R);\n    vec3 camera_pos = cameraPosition(BufferC);\n    vec3 camera_dir = cameraDirection(BufferC);\n    mat3 M = cameraMatrix(camera_dir);\n    const float hfovy = pi/6.;\n    vd = normalize(vec3(q, 1./sin(hfovy)));\n    ro = camera_pos, rd = normalize(M * vd);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy\n    , q = (p+p-r)/r.y;\n    vec3 ro, rd, vd;\n    ViewRay(p, ro, rd, vd);\n    float d;\n    vec3 c = RenderScene(ro, rd, d);\n    // all tone mapping done in Image tab\n    // to save time, could compute luminance and store in alpha\n    // or could store distance in alpha for other FX in Image tab\n    o = vec4(c, 1); // store as linear gamma HDR\n}\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}