{"ver":"0.1","info":{"id":"ttycDd","date":"1611972680","viewed":82,"name":"Genuary 2021 – 04 – Symmetry","username":"endymion","description":"Genuary 2021 – 04 – Small Areas of Symmetry\n\nIn my personal rendering, I'm using a simpler, more noisy video I took at the beach, which creates results more like I like them: https://vimeo.com/506353609","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","video","fbm","glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.14159265359\n\n/**\n * Utils\n */\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n/**\n * Rotate coordinate system from the center by angle\n * @src https://thebookofshaders.com/08/\n * @param coordinates {vec2}\n * @param angle {float} - angle in radians (360 degrees = 2 * PI)\n * @return {vec2}\n */\nvec2 rotate2d(vec2 coordinate, float angle){\n    coordinate -= 0.5; // Move coordinate to center \n    coordinate = mat2(\n        cos(angle),\n        -sin(angle),\n        sin(angle),\n        cos(angle)\n    ) * coordinate; // Rotate coordinate\n    coordinate += 0.5; // Reset coordinate from center \n    return coordinate;\n}\n\n/**\n * Rotate tile pattern\n * @src https://thebookofshaders.com/09/\n * @param coordinate {vec2} - normalized (0-1, 0-1) coordinate\n * @return {vec2}\n */\nvec2 rotateTilePattern(vec2 coordinate){\n\n    //  Scale the coordinate system by 2x2\n    coordinate *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(coordinate.x,2.0));\n    index += step(1., mod(coordinate.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    coordinate = fract(coordinate);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        coordinate = rotate2d(coordinate, PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        coordinate = rotate2d(coordinate, PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        coordinate = rotate2d(coordinate, PI);\n    }\n\n    return coordinate;\n}\n\n/**\n* RGB to HSB\n* All components are in the range [0…1], including hue.\n* @src https://stackoverflow.com/a/17897228\n*/\nvec3 rgb2hsb(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n/**\n* HSB to RGB\n* All components are in the range [0…1], including hue.\n* @src https://stackoverflow.com/a/17897228\n*/\nvec3 hsb2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/**\n * @main\n * Genuary 03 - Something human\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalization\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = rotateTilePattern(uv);\n    \n    // Loading texture\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    // Changing colors based on time\n    color = rgb2hsb(color);\n    color = mix(\n        vec3(0.716, color.yz),\n        vec3(0.991, color.yz),\n        sin(color.r * (map(iTime * 30., 0. , 1000., -100., 100.) * uv.x * uv.y))\n    ); \n    \n    // Output\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}