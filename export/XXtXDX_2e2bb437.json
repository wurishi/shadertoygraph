{"ver":"0.1","info":{"id":"XXtXDX","date":"1719693286","viewed":90,"name":"invfibogaz","username":"pb","description":"borrowed the inverse spherical fibonacci mapping logic from iq's https://www.shadertoy.com/view/lltBWB and shoved it through a volumetric raymarch.  interesting result.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n//formula for creating colors;\n#define H(h)  (  cos( h/4. + vec3(10,2,3) )*.8 + .2 )\n\n#define R iResolution\n\n//https://www.shadertoy.com/view/lltBWB iq - planetfall\n//inverse Fibonacci thingy\nvec4 inverseSF( in vec3 p, const in float n )\n{\n    const float PI = 3.14159265359;\n\tconst float PHI = 1.61803398875;\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<8; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U) {\n  \n    O = vec4(0);\n    \n    vec3 c=vec3(0), rd = normalize( vec3(U-.5*R.xy, R.y))*8.;\n    \n    float sc,dotp,totdist=0., t=iTime;\n    \n    for (float i=0.; i<9.; i++) {\n        \n        vec3 p = vec3( rd*totdist);\n        \n        p = ROT(p.xyz+vec3(0,0,-2.4) , normalize( vec3(sin(t/5.),cos(t/3.),0)  ),t);\n        sc = 1.;  //scale factor\n        \n//https://www.shadertoy.com/view/lltBWB iq - planetfall\n//iq's logic for estimating distance \n        float lp = length(p);\n        float dmin = lp-.8;\n        vec3 w = p.xyz/lp;\n        vec4 fibo = inverseSF(w, 700.);\n        float hh = 1.0 - smoothstep(0.06,0.1,length(fibo.xyz-w));\n        dmin -= 0.06*hh;\n        vec4 color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\n// end  \n\n        float stepsize = dmin;\n        totdist += stepsize/7.;            \n        \n        c += color.xyz * exp(-i*i*1e-2) + .3*H( log(length(fibo)) )*exp(-i*dmin);\n    }\n    \n    c *= c;\n    c = 1. - exp(-c);\n    O = ( vec4(c,0) );\n               \n}        \n        \n   ","name":"Image","description":"","type":"image"}]}