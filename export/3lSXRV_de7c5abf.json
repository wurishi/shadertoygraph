{"ver":"0.1","info":{"id":"3lSXRV","date":"1567070781","viewed":109,"name":"dusty room","username":"skaplun","description":"!!NEED HELP!!\nI have a compile error on Microsoft Edge. It claims 'Loop index cannot be initialized or compared with non-constant expression' in line 107","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON MIN_FLOAT\n#define MAX_MARCHING_STEPS 128\n#define TAU 6.28318530717958647\n#define AMBIENT .2\n\nconst vec3 roomSize = vec3(5., 3., 6.);\nconst vec3 windowPos = vec3(5., 1.5, -2.);\nconst float windowSize = 1.1;\nvec3 lightDir;\n\nfloat scene(vec3 p){\n    return -cubeSDF(p, roomSize);\n}\n\nfloat march(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection);\n        if (dist < MIN_FLOAT) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 norm(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec4 fanPattern(vec2 uv){\n\tuv -= windowPos.zy;\n    float a = fract(iTime * .2 + atan(uv.y, uv.x) / TAU + .5);\n    int colorIndex = int(fract(a + .1)/.25);\n    a = mod(a, .25) * 4.;\n    \n    float dst = length(uv);\n    vec3 color = vec3(1., 1., 1. + fbm1x(iTime, iTime));\n    /*\n    switch (colorIndex){\n    \tcase 0:\n        \tcolor = vec3(1., 0., 0.);\n        \tbreak;\n        case 1:\n        \tcolor = vec3(0., 1., 0.);\n        \tbreak;\n        case 2:\n        \tcolor = vec3(0., 0., 1.);\n        \tbreak;\n        case 3:\n        \tcolor = vec3(1., 1., 0.);\n        \tbreak;\n        default:\n        \tbreak;\n    }\n\t*/\n\ta = fract(a - dst * .3);\n    color *= smoothstep(.25, .3, distance(a, .5));\n\tcolor *= smoothstep(windowSize * .2, windowSize * .25, dst);\n\t\n    float cutoff = smoothstep(windowSize, windowSize * .975, dst);\n    \n    return vec4(color, cutoff);\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(120., iResolution.xy, fragCoord);\n    vec3 origin = vec3(-2., 1., 3.);\n    mat4 viewToWorld = viewMatrix(origin, vec3(-.5, 0., 0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray r = Ray(origin, dir);\n    \n    vec3 finalColor = vec3(0.);\n    \n    float dist = march(r.origin, r.dir, MIN_DIST, MAX_DIST);\n    if (dist < MAX_DIST - MIN_FLOAT) {\n        vec3 p = (r.origin + dist * r.dir);\n        vec3 n = norm(p);\n        finalColor = abs(n);\n        float t = length(p - origin);\n        finalColor = mix(finalColor, vec3(.05), 1.-exp(-.025*t*t));\n        \n        if(dot(n, vec3(-1., 0., 0.)) == 1.){\n        \tvec4 fan = fanPattern(p.zy);\n            finalColor = mix(finalColor, fan.rgb, fan.a);\n        }else{\n            HitRecord rec;\n        \tif(plane_hit(Ray(p, -lightDir), Plane(vec3(5., 0., 0.), vec3(1., 0., 0.)), rec, MIN_FLOAT, MAX_FLOAT)){\n            \tvec4 fan = fanPattern(rec.ptnt[0].zy);\n            \tfinalColor = mix(finalColor, fan.rgb, fan.a);\n            }\n        }\n    }\n    \n    //return finalColor;\n\t\n    float first, second;\n    if(cyl_hit(r, Cylinder(windowPos, lightDir, windowSize * .9), first, second)){\n        float steps = 200.;\n        if(first < dist){\n        \tfloat stepSize = (second - first)/steps;\n            for(float i = first; i <= second; i += stepSize){\n            \tvec3 p = r.origin + r.dir * i;\n                HitRecord rec;\n                if(plane_hit(Ray(p, -lightDir), Plane(vec3(5., 0., 0.), vec3(1., 0., 0.)), rec, MIN_FLOAT, MAX_FLOAT)){\n                    vec4 fan = fanPattern(rec.ptnt[0].zy);\n                    finalColor += fan.rgb * fan.a * (2./steps) * (noise(vec4(p, iTime), iChannel0) * .5);\n                }\n            }\n        }\n    }\n    \n    return finalColor;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tlightDir = normalize(vec3(-5., -3., -2. - 2. * sin(iTime)));\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Box{ vec3 origin; float size; };\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{vec2 dist;vec3 ptnt[2];vec3 nrm[2];};\nstruct Plane{ vec3 origin; vec3 normal;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nfloat cubeSDF(vec3 p, vec3 s) {\n    vec3 d = abs(p) - s;\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nbool plane_hit(in Ray inray, in Plane plane, out HitRecord rec, in float t_min, in float t_max) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        if(t >= t_min && t < t_max){\n\t\t\trec.dist[0] = t;\n            rec.ptnt[0] = inray.origin + inray.dir * rec.dist[0];\n            return true;\n        }\n    }\n    return false;\n}\n\nstruct Cylinder{\n\tvec3 base, axis;\n    float radius; \n};\n\nbool cyl_hit(in Ray ray, in Cylinder cyl, out float first, out float second){\n    bool     hit;        /* True if ray intersects cyl   */\n    vec3   RC = ray.origin - cyl.base;     /* Ray base to cylinder base    */\n    float      d;      /* Shortest distance between    */\n                    /*   the ray and the cylinder   */\n    float      t, s;       /* Distances along the ray  */\n    vec3   n, D, O;\n    float      ln;\n\tconst   float  pinf = MAX_FLOAT;    /* Positive infinity        */\n \n    n = cross(ray.dir, cyl.axis);\n \t\n    ln = length(n);\n    if (ln == 0. ) {    /* ray parallel to cyl  */\n        d    = dot(RC, cyl.axis);\n        D = RC - d * cyl.axis;\n        d    = length(D);\n        first  = -pinf;\n        second =  pinf;\n        return (d <= cyl.radius);       /* true if ray is in cyl*/\n    }\n    n = normalize(n);\n \n    d    = abs(dot(RC, n));      /* shortest distance    */\n    hit  = (d <= cyl.radius);\n    if  (hit) {             /* if ray hits cylinder */\n        O = cross(RC, cyl.axis);\n        t = -dot(O, n) / ln;\n        O = cross(n, cyl.axis);\n        O = normalize(O);\n        s = abs(sqrt(cyl.radius*cyl.radius - d*d) / dot(ray.dir, O));\n        first  = t - s;           /* entering distance    */\n        second = t + s;           /* exiting  distance    */\n    }\n \n    return (hit);\n}\n\nconst vec2 zOffset = vec2(37.0,17.0);\nconst vec2 wOffset = vec2(59.0,83.0);\nvec4 tex(vec2 uv, sampler2D tex)\t// Emulate a single texture fetch into the precalculated texture\n{\n    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.\n    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.\n    float r = textureLod( tex, (uv+0.5)/256.0, 0.0 ).r;\n    float g = textureLod( tex, (uv+0.5 + zOffset)/256.0, 0.0 ).r;\n    float b = textureLod( tex, (uv+0.5 + wOffset)/256.0, 0.0 ).r;\n    float a = textureLod( tex, (uv+0.5 + zOffset + wOffset)/256.0, 0.0 ).r;\n    \n    return vec4(r, g, b, a);\n}\n\nfloat noise( in vec4 x, sampler2D t )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n\tvec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;\n    \n   \tvec4 s = tex(uv, t);\n\treturn mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}","name":"Common","description":"","type":"common"}]}