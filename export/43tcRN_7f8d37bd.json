{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const float UV_ORIGIN = 0.5;\nconst float PI = 3.14;\nconst float SQRT3 = 1.73;\nconst float X_SCALE = (1. / SQRT3);\n\n// rotation from https://www.shadertoy.com/view/3lVGWt\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float sine = sin(angle), cosine = cos(angle);\n    return mat2( cosine, -sine, \n                 sine,    cosine );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Establish the origin of the texture \n    vec2 uv = (fragCoord - UV_ORIGIN * iResolution.xy) / iResolution.y;\n    // scale x\n    uv.x /= X_SCALE;\n    // rotate\n    uv *= rotationMatrix(45.);\n    // restore ratio\n    uv.y *= iResolution.x/iResolution.y;\n    // zoom\n    uv /= 3.;\n    // center\n    uv += UV_ORIGIN;\n    \n    // do some color processing\n    vec4 color = texture(iChannel0, uv);\n    float mass = 0.;\n    if (color.a == 2.) {\n        mass = color.g;\n    }\n    else {\n        mass = color.b;\n    }\n    \n    fragColor = vec4(vec3(1.0-.5*mass), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// MIT License\n// Copyright (c) 2024 Martín (Funca) Bárez\n\n// channel has 4 values, r, g, b, alpha\n// boundary_mass, crystal_mass, diffusive_mass, and attached/boundary\n// none=0, boundary=1, attached=2\n#define boundary_mass r\n#define crystal_mass g\n#define diffusive_mass b\n#define boundary a == 1.0\n#define attached a == 2.0\n\n#define p_rho 0.64\n#define p_beta 1.6\n#define p_alpha 0.21\n#define p_theta 0.0205\n#define p_kappa 0.07\n#define p_mu 0.015\n#define p_upsilon 0.00005\n#define p_sigma 0.0\n\nvoid bind(inout vec4 cell) {\n    cell.a = 1.0;\n}\n\nvoid attach(inout vec4 cell) {\n    cell.crystal_mass = cell.boundary_mass + cell.crystal_mass;\n    cell.boundary_mass = 0.0;\n    cell.a = 2.0;\n}\n\nvoid get_neighbours(out vec4 neighbours[6], in vec2 fragCoord) {\n    const vec2 xy[6] = vec2[6](vec2(0., 1.), vec2(0., -1.), vec2(1., 0.),\n                               vec2(-1., 0.), vec2(-1., -1.), vec2(1., 1.));\n    for (int i = 0; i < 6; i++) {\n        vec2 offset =\n            (xy[i] + fragCoord.xy) / iResolution.xy;  // Scale the offset down\n        neighbours[i] = texture(iChannel0, offset);   // Apply offset and sample\n    }\n}\n\nvoid update_boundaries(inout vec4 cell, in vec4 neighbours[6]) {\n    if (!(cell.attached)) {\n        int attached_neighbours = 0;\n        for (int i = 0; i < 6; i++) {\n            attached_neighbours += neighbours[i].attached ? 1 : 0;\n        }\n        if (attached_neighbours >= 1) {\n            bind(cell);\n        }\n    }\n}\n\nvoid melting(inout vec4 cell) {\n    if (cell.boundary) {\n        cell.diffusive_mass +=\n            p_mu * cell.boundary_mass + p_upsilon * cell.crystal_mass;\n        cell.boundary_mass = (1.0 - p_mu) * cell.boundary_mass;\n        cell.crystal_mass = (1.0 - p_upsilon) * cell.crystal_mass;\n    }\n}\n\nvoid noise() {}\n\nvoid diffusion(inout vec4 cell, in vec4 neighbours[6]) {\n    float next = cell.diffusive_mass;\n    if (!(cell.attached)) {\n        for (int i = 0; i < 6; i++) {\n            if (neighbours[i].attached) {\n                next += cell.diffusive_mass;\n            } else {\n                next += neighbours[i].diffusive_mass;\n            }\n        }\n        cell.diffusive_mass = next / 7.0;\n    }\n}\n\nvoid freezing(inout vec4 cell) {\n    if (cell.boundary) {\n        cell.boundary_mass += (1.0 - p_kappa) * cell.diffusive_mass;\n        cell.crystal_mass += p_kappa * cell.diffusive_mass;\n        cell.diffusive_mass = 0.0;\n    }\n}\n\nvoid attachment(inout vec4 cell, in vec4 neighbours[6]) {\n    if (cell.boundary) {\n        int attached_neighbours = 0;\n        for (int i = 0; i < 6; i++) {\n            attached_neighbours += neighbours[i].attached ? 1 : 0;\n        }\n        if (attached_neighbours <= 2) {\n            if (cell.boundary_mass >= p_beta) {\n                attach(cell);\n            }\n        } else if (attached_neighbours == 3) {\n            if (cell.boundary_mass >= 1.0) {\n                attach(cell);\n            } else {\n                float summed = cell.diffusive_mass;\n                for (int i = 0; i < 6; i++) {\n                    summed += neighbours[i].diffusive_mass;\n                }\n                if (summed < p_theta && cell.boundary_mass >= p_alpha) {\n                    attach(cell);\n                }\n            }\n        } else if (attached_neighbours >= 4) {\n            attach(cell);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 cell = texture(iChannel0, uv);\n    vec4 neighbours[6];\n    get_neighbours(neighbours, fragCoord);\n\n    update_boundaries(cell, neighbours);\n    melting(cell);\n    noise();\n    diffusion(cell, neighbours);\n    freezing(cell);\n    attachment(cell, neighbours);\n\n    if (iFrame == 0) {\n        cell.boundary_mass = 0.0;\n        cell.crystal_mass = 0.0;\n        cell.diffusive_mass = p_rho;\n        cell.a = 0.0;\n        if (fragCoord.xy == iResolution.xy / 2.0 - .5) {\n            cell.crystal_mass = 1.0;\n            attach(cell);\n        }\n    }\n\n    fragColor = cell;\n}\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"43tcRN","date":"1734802778","viewed":90,"name":"snowflake_generator","username":"martinbarez","description":"A cellular automata that generates snow crystals.\n\nGravner, J., Griffeath, D. (2008). Modeling snow crystal growth II: A mesoscopic lattice map with plausible dynamics.\n\nMore info at https://github.com/martinbarez/snowflake","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","snowflake"],"hasliked":0,"parentid":"","parentname":""}}