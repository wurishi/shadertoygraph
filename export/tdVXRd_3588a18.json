{"ver":"0.1","info":{"id":"tdVXRd","date":"1575152476","viewed":368,"name":"[delete]2D BSpline","username":"delete","description":"2d bspline, quadratic bspline, cubic bspline, bezier spline, quadratic analytical bezier spline, cardinal cubic curve, lagrange interpolation","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["bspline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\n\n/*\nenable quadratic bezier spline\n1 based on cubic polynomial\n2 based on barycentric coordinate\n*/\n//#define BEZIERANALYTIC 1\n\n#ifndef BEZIERANALYTIC\n\t/*\n\t0 cardinal cubic\n\t1 lagrange interpolation\n\t2 bezier spline\n\t3 Bspline quadratic\n\t4 Bspline cubic\n\t*/\n\t#define CURVETYPE 3\n\tconst int controlPointIndex=2;\t\n\t#if 0\n\tconst int P_COUNT=4;\n\tfloat Py[P_COUNT]=float[](0.,2.,1.,2.);\n\tfloat Px[P_COUNT]=float[](1.,1.,3.,3.);\n\t#else\n\tconst int P_COUNT=7;\n\tfloat Py[P_COUNT]=float[](0.,1.,2.,1.,2.,1.,0.);\n\tfloat Px[P_COUNT]=float[](1.,0.,1.,2.,3.,4.,3.);\n\t#endif\n\t\n#else\n\tconst int controlPointIndex=1;\n\tconst int P_COUNT=3;\n\tfloat Py[P_COUNT]=float[](0.,2.,0.);\n\tfloat Px[P_COUNT]=float[](1.,3.,3.);\n#endif \n\n\nvec2 barycentricCoord(vec2 v,vec2 v1,vec2 v2){return inverse(mat2(v1,v2))*v;}\n\nint fact(int n){\n    int res=1;\n    while(n>1){res*=n;--n;}\n    return res;\n}\nint C(int n,int k){return fact(n)/(fact(n-k)*fact(k));}\nvec3 checkboard(vec2 uv){\n\tuv=floor(uv);\n    return vec3(mod(uv.x+uv.y,2.))-0.8;\n}\n\nfloat lineSDF(vec2 p,vec2 p1,vec2 p2){\n\tvec2 v1=p-p1;\n    vec2 v2=p2-p1;\n    vec2 projv1ATv2=dot(v1,v2)*v2/dot(v2,v2);\n    vec2 k=projv1ATv2/v2;\n    \n    if(k.x<0.||k.y<0.)return length(v1);\n    if(k.x>1.||k.y>1.)return length(p-p2);\n\tfloat d=length(v1-projv1ATv2);\n    return d;\n}\nfloat unionSDF(float d1,float d2){return min(d1,d2);}\nfloat CardinalCubic(vec2 xy){\n    float k=3.*sin(iTime*2.);    //0 catmull rom spline\n\tfloat s=(1.-k)/2.;    //scale factor\n\tmat4 B=mat4(0,1,0,0,\n    \t\t-s,0,s,0,\n    \t\t2.*s,s-3.,3.-2.*s,-s,\n    \t\t-s,2.-s,s-2.,s);\n    B=transpose(B);\n    int i=2;\n    float d=100.;\n    const int segments=20;\n    vec2 a,b;\n    a=vec2(Px[1],Py[1]);\n    for(int i=2;i<P_COUNT-1;++i){     \n    \tvec4 py=vec4(Py[i-2],Py[i-1],Py[i],Py[i+1]);\n    \tvec4 px=vec4(Px[i-2],Px[i-1],Px[i],Px[i+1]);   \t\n    \tvec4 ay=B*py;\n    \tvec4 ax=B*px;\n    \tfor(int j=1;j<=segments;++j){\n    \t\tfloat t=float(j)/float(segments);\n    \t    vec4 u=vec4(1.,t,t*t,t*t*t);\n    \t    b=vec2(dot(u,ax),dot(u,ay));\n            d=unionSDF(d,lineSDF(xy,a,b));\n    \t\ta=b;\n        }\n    }\n    return d;\n}\n\nfloat LagrangeInterpolation(vec2 xy){\n    const float interval=0.1;\n    const int pointNum=int(float(P_COUNT-1)/interval)+1;\n    vec2 A,B;\n    A=vec2(Px[0],Py[0]);\n    float d=100.;\n    for(int k=1;k<pointNum;++k){\n        B=vec2(0.);\n        float t=float(k)*interval;\n    \tfor(int i=0;i<P_COUNT;++i){\n    \t    float b=1.;\n    \t    for(int j=0;j<P_COUNT;++j){\n    \t    \tif(i==j)continue;\n    \t    \tb*=(t-float(j))/float(i-j);\n    \t    }\n    \t    B+=b*vec2(Px[i],Py[i]);\n    \t}\n        d=unionSDF(d,lineSDF(xy,A,B));\n        A=B;\n    }\n    return d;\n}\n\nfloat BezierSpline(vec2 xy){  \n    float c[P_COUNT];\n    int hn=P_COUNT/2;\n    for(int i=0;i<=hn;++i){\n    \tc[i]=float(C(P_COUNT-1,i));\n        c[P_COUNT-1-i]=c[i];\n    }\n    const int pointNum=40;\n    vec2 A,B;\n    A=vec2(Px[0],Py[0]);\n    float d=length(xy-A);\n    for(int k=1;k<=pointNum;++k){\n    \tfloat t=float(k)/float(pointNum);\n        B=vec2(0.);\n        for(int i=0;i<P_COUNT;++i){\n        \tB+=c[i]*pow(t,float(i))*pow(1.-t,float(P_COUNT-1-i))*vec2(Px[i],Py[i]);\n        }\n        d=unionSDF(d,lineSDF(xy,A,B));\n        A=B;\n    }\n    return d;\n}\n\nvec3 cubicRoot(float a,float b,float c,float d){\n\tvec3 res;\n    float p=(a*c-b*b/3.)/(a*a);\n    float q=(2.*b*b*b/27.-a*b*c/3.+a*a*d)/(a*a*a);\n    float der=(p*p*p/27.+q*q/4.);\n    if(der<0.){\n        //Trigonometric solution\n        for(int i=0;i<3;++i){\n        \tres[i]=2.*sqrt(-p/3.)*cos(1./3.*acos(3.*q/(2.*p)*sqrt(-3./p))-float(i)*2.*3.141592653/3.)-b/(3.*a);\n        }\n    }else if(der>0.){\n        //Cardano's method, only the real root, the other two complex roots can be computed by muliply (1+-sqrt(3))/2\n        float temp=sqrt(der);\n        vec2 z=-q/2.+vec2(temp,-temp);\n    \tz=sign(z)*pow(abs(z),vec2(1./3.));\n        res=vec3(z.x+z.y-b/(3.*a)); \n    }else{\n\t\tres=vec3(1,-0.5,-0.5)*3.*q/p-b/(3.*a); \n    }\n\treturn res;\n}\n\n\nfloat BezierSplineQuadAnalytic1(vec2 xy){\n\tfloat d=100.;\n    vec2 A=vec2(Px[2],Py[2])-2.*vec2(Px[1],Py[1])+vec2(Px[0],Py[0]);\n    vec2 B=(vec2(Px[1],Py[1])-vec2(Px[0],Py[0]));\n\tvec2 p=vec2(Px[0],Py[0])-xy;\n    vec3 a=clamp(cubicRoot(dot(A,A),3.*dot(A,B),dot(A,p)+2.*dot(B,B),dot(B,p)),0.,1.);\n    for(int i=0;i<3;++i){\n    \td=unionSDF(d,length(a[i]*a[i]*A+2.*B*a[i]+p));\n    }    \n    return d;\n}\nfloat BezierSplineQuadAnalytic2(vec2 xy){\n    vec2 p0=vec2(Px[0],Py[0]),p1=vec2(Px[1],Py[1]),p2=vec2(Px[2],Py[2]);\n\tvec2 v1=p1-p0,v2=p2-p0;\n    vec2 uv=barycentricCoord(xy-p0,2.*v1,v2-2.*v1);\n    return uv.x*uv.x-uv.y;\n}\n\n\n//uniform quad Bspline\nfloat BsplineQuad(vec2 xy){\n    float d=100.;\n    const int kk=3;\n    const int num0=5;\n    const int num1=num0*kk+1;\n    \n    float b[num1];\n    b[0]=0.;\n    int hn=(num1+1)/2;\n    for(int j=0;j<hn;++j){\n        float t=float(j)/float(num0);\n        float tt=fract(t);\n        if(t<1.){\n        \tb[j]=tt*tt*0.5;\n        }\n        else if(t>=1.&&t<2.){\n        \tb[j]=-tt*tt+tt+0.5;\n        }\n        b[num1-1-j]=b[j];\n    }\n    vec2 A,B;\n\tfor(int k=0;k<kk;++k){\n    \tA+=b[(kk-1-k)*num0]*vec2(Px[k],Py[k]);\n    }\n    for(int i=0;i<P_COUNT-kk+1;++i){\n        for(int j=1;j<=num0;++j){\n            B=vec2(0.);\n            for(int k=0;k<kk;++k){\n            \tB+=b[(kk-1-k)*num0+j]*vec2(Px[k+i],Py[k+i]);\n            }\n            d=unionSDF(d,lineSDF(xy,A,B));\n            A=B;\n        }\n    }\n\treturn d;\n}\n\n//uniform\nfloat BsplineCubic(vec2 xy){\n\tfloat d=100.; \n    const int kk=4;\n    const int num0=10;\n    const int num1=num0*kk+1;\n    \n    float b[num1];\n    b[0]=0.;\n    int hn=(num1+1)/2;\n    for(int j=0;j<hn;++j){\n        float t=float(j)/float(num0);\n        float tt=fract(t);\n        if(t<1.){\n        \tb[j]=tt*tt*tt/6.;\n        }\n        else if(t>=1.&&t<2.){\n        \tb[j]=(3.*tt*(tt*(1.-tt)+1.)+1.)/6.;\n        }\n        else if(t>=2.&&t<3.){\n        \tb[j]=(2.*tt*tt*(tt-2.)+4.)/6.;\n        }\n        b[num1-1-j]=b[j];\n    }  \n    vec2 A,B;\n\tfor(int k=0;k<kk;++k){\n    \tA+=b[(kk-1-k)*num0]*vec2(Px[k],Py[k]);\n    }\n    for(int i=0;i<P_COUNT-kk+1;++i){\n        for(int j=1;j<=num0;++j){\n            B=vec2(0.);\n            for(int k=0;k<kk;++k){\n            \tB+=b[(kk-1-k)*num0+j]*vec2(Px[k+i],Py[k+i]);\n            }\n            d=unionSDF(d,lineSDF(xy,A,B));\n            A=B;\n        }\n    }\n\treturn d;\n}\n\n\n\n\nfloat func(vec2 xy){\n    float f=xy.y-xy.x;\n    \n    #ifdef BEZIERANALYTIC\n    switch(BEZIERANALYTIC){\n        case 1:\n    \treturn BezierSplineQuadAnalytic1(xy);\n        case 2:\n        return BezierSplineQuadAnalytic2(xy);\n    }\n    #else\n    switch(CURVETYPE){\n    \tcase 0:\n        f=CardinalCubic(xy);\n        \tbreak;\n        case 1:\n        f=LagrangeInterpolation(xy);\n        \tbreak;\n        case 2:\n        f=BezierSpline(xy);\n        \tbreak;\n        case 3:\n        f=BsplineQuad(xy);\n        \tbreak;\n        case 4:\n        f=BsplineCubic(xy);\n        \tbreak;\n    }   \n    #endif\n    return f;\n}\n\nvec2 funcGrad(vec2 uv){\n    vec2 h=vec2(0.01,0);\n    return vec2(func(uv+h)-func(uv-h),func(uv+h.yx)-func(uv-h.yx))/(2.*h.x);\n}\n\nfloat pointSDF(vec2 uv){\n\tfloat d=100.;\n    for(int i=0;i<P_COUNT;++i){\n    \td=unionSDF(d,length(uv-vec2(Px[i],Py[i])));\n    }\n\treturn d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y*=iResolution.y/iResolution.x;\n    uv*=7.;\n    uv.x-=1.5;\n    uv.y-=1.0;\n    \n    vec2 mo=iMouse.xy/iResolution.xy;\n    mo.y*=iResolution.y/iResolution.x;\n    mo*=7.;\n    mo.x-=1.5;\n    mo.y-=1.0;\n    mo.x-=Px[controlPointIndex];\n    mo.y-=Py[controlPointIndex];\n    \n\n\tvec3 bgColor=checkboard(uv);\n    if(abs(uv.x)<.02||abs(uv.y)<.02)bgColor=vec3(0.0,0.3,.1);\n    vec3 col=bgColor;\n    \n    Py[controlPointIndex]+=mix(sin(iTime)*1.5,mo.y,step(1.,iMouse.z));\n    Px[controlPointIndex]+=mix(0.,mo.x,step(1.,iMouse.z));\n    //plot\n    float f=(func(uv))/length(funcGrad(uv));\n    //float f=abs(func(uv));\n    float e=0.01;\n   \tcol=mix(vec3(0.9),col,smoothstep(0.01,0.02,f));\n    f=sign(f)*clamp((sin(f*100.)*0.5-0.5)*(1.-f)+1.,0.,1.);\n    if(f>0.)col=mix(vec3(0.4),col,f);\n    else col=mix(vec3(0.8,0.5,0.),col,f);\n    \n    //show points\n    float d=smoothstep(0.03,0.04,pointSDF(uv));\n    col=mix(vec3(1.0,0.7,0.0),col,d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}