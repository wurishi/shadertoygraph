{"ver":"0.1","info":{"id":"tlfGWX","date":"1558017485","viewed":141,"name":"Newton-Raphson & Mollweide","username":"tpfto","description":"[url=https://en.wikipedia.org/wiki/Mollweide_projection]Mollweide projection[/url] of the Newton-Raphson fractal on the [url=https://en.wikipedia.org/wiki/Riemann_sphere]Riemann sphere[/url].","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","complex","mollweide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mollweide-projected Newton-Raphson fractal\n\n// some constants\n#define PI 3.14159265359\n\n// from Fabrice Neyret, \n#define cis(a) vec2( cos(a), sin(a) )\n#define cmul(A, B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A, B) cmul( A, cinv(B) )\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// exponentiation using binary powering\nvec2 cpow( in vec2 z, in int n )\n{\n    if (n == 0) return vec2(1.0, 0.0);\n    if (n == 1) return z;\n    \n    if (n < 0) z = cinv(z);\n    n = abs(n);\n    \n    vec2 w = vec2(1.0, 0.0);\n    \n    for(int k = 0; k < 11; k++) { // should cover up to n == 1000\n        \n        if ((n & 1) == 1) w = cmul(w, z);\n\n        z = cmul(z, z);        \n        n >>= 1;\n\n        if (n < 2) break;\n    }\n        \n    return cmul(z, w);\n}\n\n// Newton-Raphson fractal for z^n - 1\nvec3 NewtonFractal(int n, vec2 z) {\n    \n    vec2 ld = vec2(0.0);\n    float k = 0.0;\n    \n    for(int i = 0; i < 20; i++) {\n        ld = cdiv(cpow(z, n) - vec2(1.0, 0.0), float(n) * cpow(z, n - 1));\n        if (dot(ld, ld) < 0.001) break;\n        z = z - ld;\n        k += 1.0;\n    }\n    \n    // multiplier highlights the positions of the roots\n    return pow((k + 0.1)/20.0, 0.18) * smooth_dlmf(0.1 + 0.5 * atan(z.y, z.x)/PI);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= 2.3;\n    \n        vec3 col = vec3(0.0);\n        \n        float ee = 1.0 - length(uv/vec2(2.0, 1.0));\n        if ( ee > 0.0)\n        {\n            float s2 = sqrt((1.0 - uv.y) * (1.0 + uv.y)), as = 2.0 * (uv.y * s2 + asin(uv.y));\n            vec2 zz = sqrt((PI + as)/(PI - as)) * cis(0.2 * iTime - 0.5 * PI * uv.x/s2); // Mollweide variable\n        \n            col = NewtonFractal(4, zz);\n        }\n\n        col = mix(vec3(0.19, 0.28, 0.23), col, smoothstep(0.0, 4.0/iResolution.y, ee));\n        fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}