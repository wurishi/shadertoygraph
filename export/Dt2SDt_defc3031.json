{"ver":"0.1","info":{"id":"Dt2SDt","date":"1676811290","viewed":118,"name":"Basic Verlet 02 - size variation","username":"curiouspers","description":"first attempt in Basic Verlet integration\nadded size variation","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["2d","save","state","integration","verlet","saving"],"hasliked":0,"parentid":"Dt2XDV","parentname":"Basic Verlet 01 Save State Test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tutorial - https://youtu.be/lS_qeBy3aQI?t=135\n// things to try:\n// optimize\n// save and load size and color from texture, Common:51, BufferA:134\n// make linked chains\n\n\n// This function returns where in iChannel0, the position of ball \"v\" is.\nvec2 BallVarPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\nVerletObject getData(int i){\n    vec4 xy1 = texture(iChannel0, BallVarPos(i));\n    //vec4 xy1 = texture(iChannel0, vec2(float(i*int(PPO))+0.01,   0.0));\n    //vec4 xy2 = texture(iChannel0, vec2(float(i*int(PPO)+1), 0.0));\n    \n    \n    vec2 position = xy1.xy;\n    vec2 positionOld = xy1.zw;\n    vec2 acceleration = vec2(0.,0.);//xy2.xy;\n    //os[i] = VerletObject(position, positionOld, acceleration);\n    return VerletObject(position, positionOld, acceleration);\n}\nfloat Length(vec2 p, float k) {\n    p = abs(p);\n    return pow(pow(p.x,k)+pow(p.y,k), 1./k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    \n    fragColor = vec4(0,0,0,1);\n    //fragColor = vec4(Hash1(fragCoord.x/1.),0,0,1);\n    //return;\n        \n        // buffer A\n        fragColor.xyz  = texture(iChannel0, vec2(uv.x,uv.y/5.)).xyz;\n        vec2 center = vec2(0.5, 0.5*iResolution.y/iResolution.x);\n        float cd = length(uv-center);\n        fragColor.rgb += vec3(0.118,0.118,0.118)*smoothstep(0.0,0.003,cd-cR);\n        \n        // save a lot of time\n        if (CONSTRAIT_BOX==0 && cd>cR) return;\n        \n//#define DRAW 1==1\n//    if (DRAW && iFrame>-1){\n        // draw all spheres\n        for(int i = 0; i < COUNT; i++){\n\n            //vec2 p = getData(i).position; \n            //vec2 p = texture(iChannel0, BallVarPos(i)).xy; // 1.5 times faster\n            vec2 p = A(ivec2(i,0.)).xy; // a bit more faster\n            vec4 d2 = A(ivec2(i,sizeYpos)); \n            \n            \n            //if (p == vec2(0.,0.))                p = vec2(-0.1);\n            //float dist = length(uv-p); // wow this is 3 times slower\n            vec2 d = uv-p;\n            float dist2 = dot(d,d);\n            //float r = getSize(i);\n            float r = i < 1 ? BIGBALLRADIUS : d2.w;\n            \n// this is quite expensive            \n//            fragColor.rgb = mix(fragColor.rgb,(.6+.4*cos(vec3(11,22,44)+ vec3(i)/float(COUNT)*6.28)),  smoothstep(0.0002,.0,length(uv-p)-r));\n            \n            if (dist2 < r*r){\n//            this below is fastest\n                 fragColor.rgb = d2.xyz;\n                 //fragColor.rgb = (.6+.4*cos(vec3(11,22,44)+ vec3(i)/float(COUNT)*6.28));\n \n//              this below is a lot slower\n//                fragColor.rgb = .5+vec3(Hash21(vec2(i*20,i*43)), Hash21(vec2(i*56,i*65)), Hash21(vec2(i*654,i*63)));\n//                 this is a bit slower\n//                fragColor.rgb = vec3(mod(float(i) / 3.0, 1.0),\n//                            mod(float(i) / 5.0, 1.0),\n//                            mod(float(i) / 7.0, 1.0));\n                //fragColor.rgb *= dot(vec2(-0.2,.2),d)*30.+1.-dist2*(remap(r, minR, maxR, 9500., 1200.));\n                // this is ok shading cost\n                //fragColor.rgb *= dot(vec2(-0.2,.2),d/r)+1.0-sqrt(dist2)/(r*2.);//remap(sin(r*r/dist2), 0., 10., 0., 1.);//+(2.*r*r/dist2-10.);\n                //vec2 dr = d/r;\n                //fragColor.rgb *= dot(vec2(-0.2,.2),dr)+1.2-dot(dr,dr)*0.7;//remap(sin(r*r/dist2), 0., 10., 0., 1.);//+(2.*r*r/dist2-10.);\n                // this is fastest\n                fragColor.rgb *= 1.0-dist2/(r*r*2.);\n                //fragColor*= (i == 0) ? 55. : 1.;\n            }\n        }\n        fragColor.rgb *= 0.9;\n///    }\n        \n        \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://youtu.be/lS_qeBy3aQI?t=135\n// https://www.shadertoy.com/view/XdtSWn\n// things to try:\n// optimize\n// make linked chains\n\n// found much more stable implementation https://www.shadertoy.com/view/7dSyWR\n#define M iMouse\n#define Res iResolution.xy\n#define G 0.98\n\n\n\nVerletObject UpdatePosition(int i, float dt, vec2 center){        \n\n    if (i==0) return os[i];\n    vec2 gravity = (M.z>0.?G*( M.xy/Res.y-Res.xy/Res.y*.5):vec2(0,-G))*float(SUBSTEPS*SUBSTEPS);\n        float r = getSize(i);\n        \n        //constraint\n        vec2 pos = os[i].position;\n        if (CONSTRAIT_BOX > 0) {\n            float vh = 0.5/iResolution.x*iResolution.y;\n            pos.x = pos.x < center.x-0.5+r ? center.x-0.5+r : pos.x;\n            pos.x = pos.x > center.x+0.5-r ? center.x+0.5-r : pos.x;\n            pos.y = pos.y < center.y-vh+r ? center.y-vh+r: pos.y;\n            pos.y = pos.y > center.y+vh-r ? center.y+vh-r : pos.y;\n            \n            os[i].position = pos;\n        } else {\n            vec2 fromCenter = os[i].position - center;\n            float dist = length(fromCenter);\n            if (dist > cR - r){\n                vec2 n = fromCenter / dist;\n                //os[i].position = center + n * (dist-r); // very bouncy\n                os[i].position = center + n * (cR-r);\n            }\n        }\n        \n        // verlet integration\n        os[i].acceleration += gravity;\n        vec2 velocity = os[i].position - os[i].positionOld;\n        velocity *= DRAG;\n        float l = length(velocity);\n        if (l > MAX_VELOCITY)\n            velocity = velocity / l * MAX_VELOCITY;\n            \n            \n        os[i].positionOld = os[i].position;\n        os[i].position = os[i].position + velocity + os[i].acceleration * (dt * dt);\n        os[i].acceleration = vec2(0.);\n        \n        \n    return os[i];\n}\n\nfloat rand(vec2 p) {\n    p = fract(p*vec2(123.423, 234.522));\n    p += dot(p,p+234.234);\n    return fract(p.x*p.y);\n}\n\n// This function returns where in iChannel0, the position of ball \"v\" is.\nvec2 BallVarPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\n\n// Given a position in iChannel0, return which ball position is stored there.\nint BallNum(vec2 xy) {\n  xy *= iChannelResolution[0].xy;\n  xy = floor(xy);\n  return int(xy.x + xy.y * iChannelResolution[0].x);\n}\nVerletObject getData(int i){\n    vec4 xy1 = texture(iChannel0, BallVarPos(i));\n    //vec4 xy1 = texture(iChannel0, vec2(float(i*int(PPO))+0.01,   0.0));\n    //vec4 xy2 = texture(iChannel0, vec2(float(i*int(PPO)+1), 0.0));\n    \n    \n    vec2 position = xy1.xy;\n    vec2 positionOld = xy1.zw;\n    vec2 acceleration = vec2(0.,0.);//xy2.xy;\n    os[i] = VerletObject(position, positionOld, acceleration);\n    return os[i];\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float sInterval = 1./R/3.;\n    int T = int(iTime*sInterval);\n    float fid = fragCoord.x/PPO;\n    int id = int(floor(fid));\n    id = BallNum(uv);\n    /*\n    if (id == 0)\n    fragColor.rgb = vec3(1,0,0);\n    else if (id == 2)\n    fragColor.rgb = vec3(0,1,0);\n    else\n    discard;\n    return;\n    */\n    \n    \n    // TODO: HERE !!! should be constraints\n        vec2 center = vec2(0.5, 0.5*iResolution.y/iResolution.x);\n        //float cd = length(uv-center);\n        //fragColor = vec4(0);\n        //fragColor.r = smoothstep(-0.0,0.01,cd-cR);\n        //if (cd > cR)\n//            fragColor.r = 1.;\n        //return;\n        \n    \n    // save calculations\n    if ((id < 0 || id >= int(COUNT) || (SPAWN_TYPE == 1 && id >= T)) &&\n        !(fragCoord.y == sizeYpos && fragCoord.x < float(COUNT))) discard;\n        \n        \n    // save size\n    if (fragCoord.y == sizeYpos && fragCoord.x < float(COUNT)) {\n        if (iFrame < 1){\n            vec3 col = (.6+.4*cos(vec3(11,22,44)+ vec3(fragCoord.x)/float(COUNT)*6.28));\n            if (fragCoord.x < 1.) col = vec3(1);\n            float size = mix(minR,maxR,Hash1(float(fragCoord.x)));             \n            fragColor = vec4(col.r,col.b,col.g, size);\n        }else\n            //fragColor = texture(iChannel0, fragCoord);//vec4(Hash21(fragCoord),0,0,1);\n            fragColor = A(ivec2(fragCoord));\n        return;\n    }\n    \n    vec2 pos, posOld, acceleration;\n    VerletObject o;\n    float r = getSize(id);\n    for(int j = SUBSTEPS ; j > 0; j--){\n        o = getData(id);\n        o = UpdatePosition(id, iTimeDelta/float(SUBSTEPS), center);\n    }\n    pos = o.position;\n    posOld = o.positionOld;\n    acceleration = o.acceleration;\n\n// interactive big ball \n    vec2 bigBall = center;\n    bigBall.x = center.x+sin(iTime*2.)*0.26;\n    bigBall.y = center.y+cos(iTime*3.)*0.26;\n    if (iMouse.z > 0.)\n        bigBall = iMouse.xy/iResolution.x;\n    if (id == 0){\n        os[id].position = bigBall;\n        pos = bigBall;\n    }\n    \n\n// solve collisions\n       \n    for(int j = SUBSTEPS ; j > 0; j--){\n        for(int i = 0 ; i < int(COUNT) && (SPAWN_TYPE == 0 || id < T); i++){\n            if (id == i || id == 0) continue;\n            VerletObject o = getData(i);\n\n            vec2 p = o.position;\n            vec2 pOld = o.positionOld;\n            vec2 acc = o.acceleration;\n            \n            // fix stuck objects\n            //if (abs(dot(p,pos))<0.1)\n              //  pos -= vec2(R);\n\n            vec2 col_axis = pos-p;\n            //float dist = length(col_axis);\n            float dist2 = dot(col_axis,col_axis);\n            float r2 = getSize(i);\n            if (dist2 < (r+r2)*(r+r2)) {\n                float dist = sqrt(dist2);\n                vec2 n = col_axis / dist;\n                float delta = (r+r2) - dist;\n                pos += 1.f * delta * n * (1./float(SUBSTEPS));\n              //p   -= 0.5f * delta * n; // we can't change second object position, cause we only ouput 1 pixel at a time\n            }\n        }\n    }\n\n    \n    // If this is the first frame, initialize position and speed to something random.\n    if (iFrame < 1) {\n        pos = vec2(rand(uv), rand(uv));\n        posOld = pos + vec2((rand(uv + vec2(0.1))-0.5) ,\n                         (rand(uv + vec2(0.2))-0.5))/3000.;\n        \n        // spawn all at once\n        pos = center-vec2(rand(uv*321.), rand(uv*46.645))*cR*1.4+0.5*cR*1.4;\n        posOld = pos+vec2(0.,0.0001*rand(uv));//+vec2(rand(uv*321.), rand(uv*46.645))*0.01;\n        if (fragCoord.x < 1.)\n            pos = vec2(0.1);\n    } else\n    if (SPAWN_TYPE == 1 && id == T-1) {\n        // spawn consecutevely\n        pos = center+vec2(0,cR-maxR);\n        posOld = pos-vec2(sin(iTime*2.), cos(iTime*2.))*.05;\n    }\n    \n    // Store position and oldPos in the output (which is also iChannel0).\n    fragColor = vec4(pos,posOld);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n#define LOWRES 1\n\n#if LOWRES\n    #define COUNT 50\n    #define maxR 0.042\n    #define minR 0.012\n    #define R maxR\n    #define MAX_VELOCITY 0.025    // pixels of data per object \n#else\n    #define COUNT 1000\n    #define maxR 0.004\n    #define minR 0.01\n    #define R minR\n    #define MAX_VELOCITY 0.005    // pixels of data per object \n#endif\n#define SUBSTEPS 8\n#define CONSTRAIT_BOX 0\n\n#define SPAWN_TYPE 1\n#define cR 0.27  // constraint radius\n#define PPO 10.    // pixels of data per object \n#define DRAG 0.999\n\n#define BIGBALLRADIUS 0.05\n\nstruct VerletObject{\n    vec2 position;\n    vec2 positionOld;\n    vec2 acceleration;\n} os[int(COUNT)];\n\nfloat remap(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.423, 234.522));\n    p += dot(p,p+234.234);\n    return fract(p.x*p.y);\n}\n//float hash1( ivec2 p ) { float n = dot(vec2(p),vec2(127.1,311.7)); return fract(sin(n)*43758.5453); }\n\nfloat Hash1(float p) {\n    //return fract(fract(p*123.423)*fract(p*10.363)+fract(p*74.45782));\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n    //return hash1(ivec2(p,p*134.346));\n}\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\nivec2 i2xy(int i) {return ivec2(i%4,i/4);}\nint xy2i(ivec2 v) {return (v.x+v.y*4);}\n\n#define sizeYpos 10.5\n// texel fetch is a bit faster than recompute\n#define getSize(i) i < 1 ? BIGBALLRADIUS : A(ivec2(float(i), sizeYpos)).w\n//#define getSize(i) i < 1 ? BIGBALLRADIUS : max(minR,min(maxR,Hash1(float(i))/50.))\n//#define getSize(i) i < 1 ? BIGBALLRADIUS : R\n\n//#define getData2(i) i < 1 ? vec4(1,1,1,BIGBALLRADIUS) : A(ivec2(i,sizeYpos))\n","name":"Common","description":"","type":"common"}]}