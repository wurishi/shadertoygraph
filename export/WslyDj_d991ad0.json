{"ver":"0.1","info":{"id":"WslyDj","date":"1585604691","viewed":895,"name":"[twitch] Virtual Meadow","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/VirtualMeadow.glsl","likes":52,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sss","repeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/VirtualMeadow.glsl\n*/\n\nfloat time=0.0;\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat herb(vec3 p, float s) {\n  \n  p /= s;\n  \n  p.y+=3.0;\n  p.z += abs(p.x)*0.3;\n  float d = box(p, vec3(sin((p.y*0.7+3.0)*0.5),6.0,0.2));\n  \n  return d*s*0.7;\n}\n\nfloat rnd2(vec2 uv) {\n  return fract(dot(sin(uv*427.512+uv.yx*652.477),vec2(417.884)));\n  \n}\n\nfloat field(vec3 p, float repeat) {\n    \n  vec2 gridid = floor(p.xz/repeat-0.5);\n  float id = rnd2(gridid);\n  p.xz = (fract(p.xz/repeat-0.5)-0.5)*repeat;\n  \n  p.xz *= rot(id*6.3);\n  \n  return herb(p, 0.5 + rnd2(gridid+3.7)*0.8);\n  \n}\n\nfloat ground = 0.0;\nfloat grass(vec3 p) {\n  \n  ground = (texture(iChannel0, p.xz*0.0002).x-0.1)*30.0;\n  p.y += ground;\n  \n  p.xz += sin(p.zx*vec2(0.08,0.05) + p.y*0.1 + time*3.0 + dot(sin(time*0.3+p.xz*0.004),vec2(3,4)))*0.5*max(0.0,-p.y);\n  \n  float d = field(p,7.0);\n  p.xz *= rot(0.3);\n  p.x+=45.7;\n  d = min(d, field(p,5.0));\n  p.xz *= rot(0.9);\n  p.x-=13.9;\n  d = min(d, field(p,4.0));\n    \n  d=min(d, -p.y);\n  \n  return d;\n}\n\nfloat mistelement(vec3 p, float repeat) {\n  \n  p.z += time*10.0+sin(time*0.5-p.z*0.01)*10.0;\n  p.xyz += sin(p.zxy*vec3(0.09,0.08,0.1) + vec3(1,0.7,0.5)*time)*5.0;\n  \n  \n  p = (fract(p/repeat-0.5)-0.5)*repeat;\n  \n  float d=length(p)-0.2;\n  \n  return d*0.8;  \n}\n\nfloat mist(vec3 p) {\n  vec3 bp=p;\n  float d=mistelement(p,35.0);\n  p.xz *= rot(0.2);\n  p.yz *= rot(0.4);\n  d=min(d, mistelement(p+vec3(18.25),31.0));\n  //p.xz *= rot(0.2);\n  //d=min(d, mistelement(p-vec3(18.25),13));\n    \n  d += max(0.0,-(30.0+bp.y)*0.5);\n  \n  return d;\n}\n\nfloat bari = 0.0;\nfloat bar1(vec3 p, float repeat) {\n  \n  \n  p.xz = (fract(p.xz/repeat-0.5)-0.5)*repeat;\n  \n  p.y += 30.0;\n  vec3 bp=p;\n  \n  p.y = abs(p.y)-5.0;\n    \n  float d = box(p, vec3(0.2,3.0,25.0));\n  \n  bp.y -= 10.0;\n  bp.z = abs(bp.z)-10.0;\n  bp.z = abs(bp.z)-5.0;\n  d = min(d, box(bp, vec3(0.5,20.0,2.0)));\n  \n  return d;\n}\n\nfloat bar(vec3 p) {\n  float d=bar1(p, 200.0);\n  p.xz *= rot(-1.0);\n  d=min(d, bar1(p, 230.0));\n  \n  return d;\n}\n\nfloat mimi = 0.0;\nfloat map(vec3 p) {\n  \n  float d = grass(p);\n  float mi = mist(p);\n  mimi+=0.01/(0.1+abs(mi));\n  d=min(d, mi);\n  \n  bari = bar(p);\n  d=min(d, bari);\n  \n  return d;\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n  time = mod(iTime, 300.0);\n\n  vec3 s=vec3(0,-60,-120.0 - sin(time)*30.0);\n  vec3 t=vec3(0,-20,0);\n  \n  s.xz *= rot(time*0.3);\n\n  float adv = time*40.0;\n  s.z += adv;\n  t.z += adv;\n  \n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(sin(time*0.2)*0.3,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  float fov = 1.0;\n  vec3 r=normalize(cx*uv.x + cy*uv.y + fov*cz);\n  \n  vec3 p=s;\n  for(int i=0; i<70; ++i) {\n    float d=map(p);\n    if(d<0.001) break;\n    if(d>400.0) break;\n    p+=r*d;\n  }\n  \n  vec3 l=normalize(-vec3(1,1.3,2));\n  \n  // copy the values before the light stepping\n  float factor = ground;\n  float mimi2=mimi;\n  float bari2=bari;\n  \n  float sub = 0.0;\n  float steps=20.0;\n  for(float i=1.0; i<steps; ++i) {\n    float dist = i*5.0/steps;\n    sub += sss(p,l,dist);\n  }\n  sub *= 2.0/steps;\n  sub *= clamp(-(p.y+ground)*0.1+0.3,0.0,1.0);\n  float fog = 1.0-clamp(length(p-s)/400.0,0.0,1.0);\n  \n  float grass = texture(iChannel0, p.xz*0.0005).x;\n  vec3 diff = vec3(0.7,0.9,0.4-grass*0.7);\n  if(bari2<0.01) diff=vec3(1.0,0.8,0.6);\n    \n  vec3 col=vec3(0);\n  col += sub * diff;\n  col *= fog;\n  \n  col += vec3(1,0.9,0.5) * mimi2;\n  \n  vec3 sky = mix(max(vec3(0),vec3(0.5,.6,1.0)+r.y*2.0), vec3(0.9,.7,0.1)*3.0, pow(max(0.0,dot(r,l)),10.0));\n  col += pow(1.0-fog, 3.0)*sky;\n  \n  col = smoothstep(0.0,1.0,col);\n  col = pow(col, vec3(0.4545));\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}