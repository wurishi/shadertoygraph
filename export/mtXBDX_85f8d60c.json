{"ver":"0.1","info":{"id":"mtXBDX","date":"1693516229","viewed":53,"name":"Luggen learning about noise","username":"Luggen","description":"Practicing various noise techniques.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Settings\n//\n#define GRID              0\n#define GRID_COLOR        v3(0.0f, 0.0f, 1.0f)\n\n// NOTE(Luggen): Simplex noise work in progress.\n#define RANDOM_1D         0\n#define RANDOM_2D         0\n#define VALUE_NOISE       0\n#define GRADIENT_NOISE    0\n#define SIMPLEX_NOISE     0\n#define VORONOI           0\n#define AM_FM             0\n#define MULTI_AM_FM       0\n#define FBM_1D            0\n#define FBM_2D            0\n#define FBM_2D_TURBULENCE 0\n#define FBM_2D_RIDGE      0\n#define FBM_2D_WARPING    1\n\n// Main\n//\nvoid mainImage(out v4 fragColor, in v2 fragCoord)\n{\n\tv3 result = v3(0.0f);\n#if RANDOM_1D\n\t\n\tv2 P = fragCoord / iResolution.xy;\n\tv3 R = v3(Random (P.x + (iTime * 0.000001f)),\n\t\t\t  Random2(P.xx + (iTime * 0.000001f)));\n\t\n\tresult = SmoothStep(0.01f, 0.0f, Max(v3(P.y) - R, 0.0f));\n\t\n#elif RANDOM_2D\n\t\n\tv2 P   = fragCoord / iResolution.xy;\n\tresult = v3(Random (P + (iTime * 0.000001f)),\n\t\t\t\tRandom2(P + (iTime * 0.000001f)));\n\t\n#elif VALUE_NOISE\n\t\n\tv2  P = fragCoord / iResolution.y;\n    f32 cellWidth = 0.02f;\n\tf32 v = Noise(P, cellWidth);\n\t\n\tresult = v3(v);\n\t\n#elif GRADIENT_NOISE\n\t\n\tv2  P = fragCoord / iResolution.y;\n    f32 cellWidth = 0.02f;\n\tf32 v = MulAdd(GradNoise(P, cellWidth), 0.5f, 0.5f);\n\t\n\tresult = v3(v);\n\t\n#elif SIMPLEX_NOISE\n\t\n\tv2  P = fragCoord / iResolution.y;\n\t\n\tf32 cellWidth = 0.02f;\n\tv2  gridP     = P / cellWidth;\n\tv2  cellID    = Floor(gridP);\n\t\n\t// Skewed coordinates\n\tf32 a = (PI / 3.0f) - (PI / 4.0f);\n\tv2  A = v2(Cos(a), Sin(a));\n\t\n    gridP = (A * gridP.x) + v2(0.0f, gridP.y * A.x);\n\t\n    cellID      = Floor(gridP);\n\tv2  cellP   = Frac(gridP);\n\tv3  T       = v3(0.0f);\n\tf32 triArea = A.y * 4.0f;\n\tv2  id0     = cellID;\n\tv2  id1;\n\tv2  id2;\n\tv2  AP;\n\tv2  BP;\n\tv2  CP;\n\tif (cellP.x > cellP.y)\n\t{\n\t\tv2 A = v2(0.0f, 0.0f); // x\n\t\tv2 B = v2(1.0f, 0.0f); // y\n\t\tv2 C = v2(1.0f, 1.0f); // z\n\t\t\n\t\tAP = cellP - A;\n\t\tBP = cellP - B;\n\t\tCP = cellP - C;\n\t\t\n\t\tT.x = Cross2D(BP, CP) / triArea;\n\t\tT.y = Cross2D(CP, AP) / triArea;\n\t\t\n\t\tid1 = id0 + B;\n\t\tid2 = id0 + C;\n\t}\n\telse\n\t{\n\t\tv2 A = v2(0.0f, 0.0f); // x\n\t\tv2 B = v2(0.0f, 1.0f); // y\n\t\tv2 C = v2(1.0f, 1.0f); // z\n\t\t\n\t\tAP = cellP - A;\n\t\tBP = cellP - B;\n\t\tCP = cellP - C;\n\t\t\n\t\tT.x = Cross2D(CP, BP) / triArea;\n\t\tT.y = Cross2D(AP, CP) / triArea;\n\t\t\n\t\tid1 = id0 + B;\n\t\tid2 = id0 + C;\n\t}\n\tT.z = 1.0f - T.x - T.y;\n\t\n\tf32 r0 = Dot(SRandom2(id0), AP);\n\tf32 r1 = Dot(SRandom2(id1), BP);\n\tf32 r2 = Dot(SRandom2(id2), CP);\n\t\n\tT = SmoothT(T);\n    \n\tf32 n  = (r0 * T.x) + (r1 * T.y) + (r2 * T.z);\n    result = v3(MulAdd(n, 0.5f, 0.5f));\n\n#elif VORONOI\n\t\n\tv2  P = fragCoord / iResolution.y;\n\t\n\tf32 cellWidth = 0.1f;\n\tv2  gridP = P / cellWidth;\n\ti2  id    = i2(Floor(gridP));\n\t\n\tf32 minDistance = INF;\n\tf32 t = iTime * 0.1f;\n\tfor (s32 y = -1; y <= 1; ++y)\n\t{\n\t\tfor (s32 x = -1; x <= 1; ++x)\n\t\t{\n\t\t\tv2  curID   = v2(id + i2(x, y));\n            v2  cellP   = v2(GradNoise(curID + t, 0.1f), GradNoise(curID - t - 0.33f, 0.1f));\n\t\t\tv2  pointP  = curID + cellP + 0.5f;\n\t\t\tminDistance = Min(minDistance, Distance(gridP, pointP));\n\t\t}\n\t}\n\t\n\tresult = v3(minDistance);\n\t\n#elif AM_FM\n\t\n\tv2 P = fragCoord / iResolution.xy;\n\tP.y  = MulAdd(P.y, 2.0f, -1.0f);\n\t\n\tf32 t  = iTime * 0.2f;\n\tf32 t0 = Abs(MulAdd(Frac(t), 8.0f, -4.0f));\n\tf32 t1 = SmoothT(Clamp01(t0 - 1.4f));\n\tf32 t2 = SmoothT(Clamp01(t0 - 2.0f));\n\t\n\tf32 freq = 1.0f + (t1 * 5.0f);\n\tf32 amp  = 0.5f + (t2 * 0.4f);\n\t\n\tf32 f = Sin(P.x * freq * TAU) * amp;\n\t\n\tf32 w = Lerp(Lerp(0.01f, 0.1f, t1), 0.01f, Abs(f));\n\tf32 d = SmoothStep(w, 0.0f, Abs(P.y - f));\n\t\n\tresult = v3(d);\n\t\n#elif MULTI_AM_FM\n\t\n\tv2 P = fragCoord / iResolution.xy;\n\t\n\tP.y = MulAdd(P.y, 2.0f, -1.0f);\n\t\n\tf32 sum = 0.0f;\n\tfor (s32 i = 0; i < 4; ++i)\n\t{\n\t\tf32 freq = Lerp(2.0f, 10.0f, Random(i));\n\t\tf32 amp  = Lerp(0.1f, 0.3f,  Random(i + 10));\n\t\tf32 t    = iTime * Lerp(-0.1f, 0.1f, Random(i + 30));\n\t\t\n\t\tsum += amp * Sin((P.x + t) * freq * TAU);\n\t}\n\t\n\tf32 w = Lerp(0.04f, 0.01f, Abs(sum));\n\tf32 d = SmoothStep(w, 0.0f, Abs(P.y - sum));\n\t\n\tresult = v3(d);\n\t\n#elif FBM_1D\n\t\n\tv2  P = fragCoord / iResolution.xy;\n\t\n\tf32 amp  = 0.5f;\n\tf32 lac  = 3.0f;\n\tf32 gain = 0.5f;\n\t\n\tf32 cellWidth = 0.5f;\n\t\n    s32 numOctaves = 6;\n\tf32 curP = P.x;\n\tf32 sum  = 0.0f;\n\tfor (s32 i = 0; i < numOctaves; ++i)\n\t{\n\t\tsum  += Noise(curP, cellWidth) * amp;\n\t\tcurP *= lac;\n\t\tamp  *= gain;\n\t}\n\t\n\tf32 d = SmoothStep(0.01f, 0.0f, P.y - sum);\n\t\n\tresult = v3(d);\n\t\n#elif FBM_2D\n\t\n\tv2  P = fragCoord / iResolution.y;\n\t\n\tf32 amp  = 0.5f;\n\tf32 lac  = 3.0f;\n\tf32 gain = 0.5f;\n\t\n\tf32 cellWidth  = 0.5f;\n    s32 numOctaves = 5;\n\t\n\tv2  curP = P;\n\tf32 sum  = 0.0f;\n\tfor (s32 i = 0; i < numOctaves; ++i)\n\t{\n\t\tsum  += Noise(curP, cellWidth) * amp;\n\t\tcurP *= lac;\n\t\tamp  *= gain;\n\t}\n\tresult = v3(sum);\n\t\n#elif FBM_2D_TURBULENCE\n\t\n\tv2  P = fragCoord / iResolution.y;\n\t\n\tf32 amp  = 0.5f;\n\tf32 lac  = 2.0f;\n\tf32 gain = 0.5f;\n\t\n\tf32 cellWidth  = 0.1f;\n\ts32 numOctaves = 4;\n\t\n\tf32 sum  = 0.0f;\n\tv2  curP = P;\n\tfor (s32 i = 0; i < numOctaves; ++i)\n\t{\n\t\tsum  += SNoise(curP, cellWidth) * amp;\n\t\tcurP *= lac;\n\t\tamp  *= gain;\n\t}\n\tresult = v3(Abs(sum));\n\t\n#elif FBM_2D_RIDGE\n\t\n\tv2  P = fragCoord / iResolution.y;\n\t\n\tf32 amp  = 0.5f;\n\tf32 lac  = 2.0f;\n\tf32 gain = 0.5f;\n\t\n\tf32 cellWidth  = 0.1f;\n\ts32 numOctaves = 4;\n\t\n\tf32 sum  = 0.0f;\n\tv2  curP = P;\n\tv2  R    = Normalize(v2(1.0f, 0.2f));\n\tm2  M    = m2(R.x, R.y, -R.y, R.x);\n\tfor (s32 i = 0; i < numOctaves; ++i)\n\t{\n\t\tsum  += SNoise(curP, cellWidth) * amp;\n\t\tcurP  = (M * curP) * lac;\n\t\tamp  *= gain;\n\t}\n\tresult = v3(1.0f - Abs(sum));\n\t\n#elif FBM_2D_WARPING\n\t\n\ts32 numOct = 8;\n\tf32 cellWidth  = 0.6f;\n\tf32 dist   = 5.0f;\n\t\n\tv2  P    = fragCoord / iResolution.y;\n    v2  R    = v2(0.7071f);\n    v2  T    = iTime * R * 0.02f;\n\tv2  curP = v2(0.0f);\n\tfor (s32 i = 0; i < 2; ++i)\n\t{\n\t\tf32 offset = f32(i + 1);\n\t\tv2  A      = P + curP;\n\t\tv2  B      = A + (T * offset);\n\t\tT          = -T;\n\t\t\n        curP = v2(FBM(A, cellWidth, numOct, R), FBM(B, cellWidth, numOct, R)) * dist;\n\t}\n\tf32 v  = FBM(P + curP, cellWidth, numOct, R);\n\tresult = v3(v);\n\t\n#endif\n\tfragColor = v4(result, 1.0f);\n#if GRID & (VALUE_NOISE | GRADIENT_NOISE | VORONOI | FBM_2D | FBM_2D_TURBULENCE | FBM_2D_RIDGE | FBM_2D_WARPING) & !(RANDOM_1D | RANDOM_2D | AM_FM | MULTI_AM_FM | FBM_1D)\n    fragColor.xyz = Lerp(fragColor.xyz, GRID_COLOR, Grid(P, cellWidth, 0.005f / cellWidth));\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// API override\n//\n#define u32 uint\n#define s32 int\n#define f32 float\n#define v2  vec2\n#define v3  vec3\n#define v4  vec4\n#define m2  mat2\n#define m3  mat3\n#define m4  mat4\n#define i2  ivec2\n#define i3  ivec3\n\n#define Cos        cos\n#define Sin        sin\n#define ATan       atan\n#define Abs        abs\n#define Sign       sign\n#define Min        min\n#define Max        max\n#define Clamp      clamp\n#define Frac       fract\n#define Floor      floor\n#define Ceil       ceil\n#define Exp        exp\n#define Lerp       mix\n#define SmoothStep smoothstep\n#define Dot        dot\n#define Cross      cross\n#define Normalize  normalize\n#define Length     length\n#define SquareRoot sqrt\n#define Distance   distance\n#define Reflect    reflect\n#define Power      pow\n#define Sample     texture\n#define Load       texelFetch\n\n// Math utility\n//\n#define PI  3.14159265359f\n#define TAU 6.28318530718f\n#define INF 1000000.0f\n\n#define Clamp01(value) clamp(value, 0.0f, 1.0f)\n\n#define MulAdd(value, mul, add) (((value) * (mul)) + (add))\n\nm2 Rotation(v2 X)\n{\n\treturn m2( X.x, X.y,\n\t\t\t  -X.y, X.x);\n}\n\nf32 SmoothT(f32 t)\n{\n\treturn t * t * (3.0f - (2.0f * t));\n}\n\nv2 SmoothT(v2 t)\n{\n\treturn t * t * (3.0f - (2.0f * t));\n}\n\nv3 SmoothT(v3 t)\n{\n\treturn t * t * (3.0f - (2.0f * t));\n}\n\nf32 Cross2D(v2 A, v2 B)\n{\n\treturn (A.x * B.y) - (A.y * B.x);\n}\n\n// RNG\n//\nf32 RNGSin11(f32 id)\n{\n\treturn Frac(Sin(id) * 475830.0f);\n}\n\nf32 RNGSin21(v2 id)\n{\n\treturn Frac(Sin(Dot(id, v2(145.246634f, 207.0234f))) * 4824.0f);\n}\n\nv2 RNGSin22(v2 id)\n{\n\treturn Frac(v2(Sin(Dot(id, v2(198.39802f, 302.9475f))) * 4824.0f,\n\t\t\t\t   Cos(Dot(id, v2(-236.346f, 729.8347f))) * 4824.0f));\n}\n\nf32 Random(f32 id)\n{\n\treturn RNGSin11(id);\n}\n\nf32 Random(s32 id)\n{\n\treturn RNGSin11(f32(id));\n}\n\nf32 Random(v2 id)\n{\n\treturn RNGSin21(id);\n}\n\nf32 Random(i2 id)\n{\n\treturn RNGSin21(v2(id));\n}\n\nv2 Random2(v2 id)\n{\n\treturn RNGSin22(id);\n}\n\nv2 Random2(i2 id)\n{\n\treturn RNGSin22(v2(id));\n}\n\nv2 SRandom2(v2 id)\n{\n\treturn MulAdd(Random2(id), 2.0f, -1.0f);\n}\n\n// Noise\n//\nf32 Noise(f32 P, f32 cellWidth)\n{\n\tf32 gridP = P / cellWidth;\n\tf32 id0   = Floor(gridP);\n\tf32 id1   = id0 + 1.0f;\n\tf32 t     = SmoothT(gridP - id0);\n\t// d---c\n\t// |   |\n\t// a---b\n\tf32 a = Random(id0);\n\tf32 b = Random(id1);\n\t\n\treturn Lerp(a, b, t);\n}\n\nf32 Noise(v2 P, f32 cellWidth)\n{\n\tv2 gridP = P / cellWidth;\n\tv2 id0   = Floor(gridP);\n\tv2 id1   = id0 + 1.0f;\n\tv2 T     = SmoothT(gridP - id0);\n\t// d---c\n\t// |   |\n\t// a---b\n\tf32 a = Random(id0);\n\tf32 b = Random(v2(id1.x, id0.y));\n\tf32 c = Random(id1);\n\tf32 d = Random(v2(id0.x, id1.y));\n\t\n\treturn Lerp(Lerp(a, b, T.x), Lerp(d, c, T.x), T.y);\n}\n\n// Signed noise\nf32 SNoise(v2 P, f32 cellWidth)\n{\n\treturn MulAdd(Noise(P, cellWidth), 2.0f, -1.0f);\n}\n\n// Signed gradient noise\nf32 GradNoise(v2 P, f32 cellWidth)\n{\n\tv2 gridP = P / cellWidth;\n\tv2 id0   = Floor(gridP);\n\tv2 id1   = id0 + 1.0f;\n\tv2 T     = gridP - id0;\n\t// d---c\n\t// |   |\n\t// a---b\n\tv2 A = SRandom2(id0);\n\tv2 B = SRandom2(v2(id1.x, id0.y));\n\tv2 C = SRandom2(id1);\n\tv2 D = SRandom2(v2(id0.x, id1.y));\n\t\n\tf32 a = Dot(A, T);\n\tf32 b = Dot(B, T - v2(1.0f, 0.0f));\n\tf32 c = Dot(C, T - 1.0f);\n\tf32 d = Dot(D, T - v2(0.0f, 1.0f));\n    \n    T = SmoothT(T);\n\treturn Lerp(Lerp(a, b, T.x), Lerp(d, c, T.x), T.y);\n}\n\nf32 FBM(v2 P, f32 cellWidth, s32 numOctaves)\n{\n\tf32 amp  = 0.5f;\n\tf32 sum  = 0.0f;\n\tfor (s32 i = 0; i < numOctaves; ++i)\n\t{\n\t\tsum += Noise(P, cellWidth) * amp;\n\t\tP   *= 2.0f;\n\t\tamp *= 0.5f;\n\t}\n\treturn sum;\n}\n\n// With Rotation\nf32 FBM(v2 P, f32 cellWidth, s32 numOctaves, v2 R)\n{\n\tm2  M    = m2(R.x, R.y, -R.y, R.x);\n\tf32 amp  = 0.5f;\n\tf32 sum  = 0.0f;\n\tfor (s32 i = 0; i < numOctaves; ++i)\n\t{\n\t\tsum += Noise(P, cellWidth) * amp;\n\t\tP    = (M * P) * 2.0f;\n\t\tamp *= 0.5f;\n\t}\n\treturn sum;\n}\n\nf32 Grid(v2 P, f32 cellWidth, f32 lineExtent)\n{\n\tv2 gridP = P / cellWidth;\n\tv2 cellP = Abs(MulAdd(Frac(gridP), 2.0f, -1.0f));\n\t\n\treturn SmoothStep(lineExtent, 0.0f, 1.0f - Max(cellP.x, cellP.y));\n}\n","name":"Common","description":"","type":"common"}]}