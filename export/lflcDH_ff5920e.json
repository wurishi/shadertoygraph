{"ver":"0.1","info":{"id":"lflcDH","date":"1721378231","viewed":72,"name":"HW9_Pink Islands","username":"EurekaChen","description":"Pink Islands","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Material Ground(vec3 p)\n{\n    vec3 aCol = (vec3(.55,0.05,0.15)  + mod(floor(p.y  * 20.),2.)) * sqrt(10. * (p.y + 0.5));\n    vec3 dCol = vec3(0.1);\n    vec3 sCol = vec3(0);\n    float a = 1.;\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial Sea(vec3 p)\n{\n    vec3 aCol = vec3(.9,0.4,0.7);\n    vec3 dCol = vec3(0.2);\n    vec3 sCol = vec3(0);\n    float a = 1.;\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial Bubble(vec3 color) {\n  vec3 aCol = color;\n  vec3 dCol = 0.6 * vec3(0.9, 0.3, 0.7);\n  vec3 sCol = 0.6 * vec3(1., 1., 1.);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial Tower(vec3 p, vec3 pos)\n{\n    float x = random(pos.xz);\n    vec3 aCol = vec3(1., 0.6, 0.) + (0.3 * mod(floor(p.y * 12.), 4.) );\n    if(x > 0.66) aCol = vec3(1., 0., 1.) + (0.3 * mod(floor(p.y * 12.), 4.) );\n    else if(x > 0.33) aCol = vec3(.3, .1, .2) + (0.3 * mod(floor(p.y * 12.), 4.) );\n    \n    vec3 dCol = vec3(0.1);\n    vec3 sCol = vec3(0.0);\n    float a = 2.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nSurface scene1(vec3 p)\n{\n    float base = clamp(p.y - 0.15 + 0.6 * noise(p.xz) + 0.12 * pow(length(p), 1.2), -2.0, 2.0);\n    Surface co = Surface(1, base, Ground(p));\n    \n    // bubbles\t\n    for( int i=0; i<12; i++ )\n    {\n        float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 0.5 ) / 40.;\n        float px = 1.5 * sin(float(i)*321.55+4.1);\n        float py = 2. * sin(float(i)*235.54+4.4)*0.5 + mod(0.5*iTime*(0.2+1.2*siz),3.)  - 1. - 2. * siz;\n        float pz = clamp(1.5 * sin(float(i)*837.43+6.7), -sqrt(2.25 - px * px), sqrt(2.25 - px * px));\n\n        // bubble size, position and color\n        float rad = 0.1 + 0.5*siz;\n        vec3  pos = vec3(px, py, pz);\n        Surface bubble = Surface(2, sdSphere(p - pos, rad), Bubble(1.2 * mix(vec3(0.2,0.3,0.94), vec3(0.95,0.5,0.1), 0.5+0.5*sin(float(i)*164.2+1.9))));\n        co = opUnion(co, bubble);\n    }\n    \n    // towers\n    \n    for( int i=0; i<10; i++ )\n    {\n        float height = (sin(float(i)*651.74+5.0)*0.15 + 0.55);\n        float rad = sin(float(i)*843.13+5.0)*0.5 + 1.;\n        float px = 1.5 * sin(float(i)*123.44+7.3);\n        float pz = clamp(1.5 * sin(float(i)*731.28+9.7), -sqrt(2.25 - px * px), sqrt(2.25 - px * px));\n        \n        vec3 pos = vec3(px, height , pz);\n        Surface tower =Surface(4, sdCone(p - pos, vec2(0.2, 0.8), height), Tower(p, pos));\n        co = opUnion(co, tower);\n    }\n\n    //co = opUnion(co, Surface(2, sdSphere(p, .5), Bubble(vec3(0.))));\n    \n    co = opUnion(co, Surface(3, p.y + 0.08 * sin(iTime / 3.0), Sea(p)));\n    return co;\n}\n\nSurface scene2(vec3 p)\n{\n    float base = clamp(p.y - 0.15 + 0.6 * noise(p.xz) + 0.12 * pow(length(p), 1.2), -2.0, 2.0);\n    Surface co = Surface(1, base, Ground(p));\n    \n    // towers\n    \n    for( int i=0; i<10; i++ )\n    {\n        float height = (sin(float(i)*651.74+5.0)*0.15 + 0.55);\n        float rad = sin(float(i)*843.13+5.0)*0.5 + 1.;\n        float px = 1.5 * sin(float(i)*123.44+7.3);\n        float pz = clamp(1.5 * sin(float(i)*731.28+9.7), -sqrt(2.25 - px * px), sqrt(2.25 - px * px));\n        \n        vec3 pos = vec3(px, height , pz);\n        Surface tower =Surface(4, sdCone(p - pos, vec2(0.2, 0.8), height), Tower(p, pos));\n        co = opUnion(co, tower);\n    }\n\n    //co = opUnion(co, Surface(2, sdSphere(p, .5), Bubble(vec3(0.))));\n    \n    co = opUnion(co, Surface(3, p.y + 0.08 * sin(iTime / 3.0), Sea(p)));\n    return co;\n}\n\nvec3 calcNormal1(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene1(p + e.xyy).sd +\n      e.yyx * scene1(p + e.yyx).sd +\n      e.yxy * scene1(p + e.yxy).sd +\n      e.xxx * scene1(p + e.xxx).sd);\n}\n\nvec3 calcNormal2(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene2(p + e.xyy).sd +\n      e.yyx * scene2(p + e.yyx).sd +\n      e.yxy * scene2(p + e.yxy).sd +\n      e.xxx * scene2(p + e.xxx).sd);\n}\n\nSurface rayMarch1(vec3 ro, vec3 rd)\n{\n    float depth = 0.0;\n    Surface co;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = scene1(p);\n        depth += 0.6 * abs(co.sd);\n        if (abs(co.sd) < PRECISION || depth > MAX_DIST) break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nSurface rayMarch2(vec3 ro, vec3 rd)\n{\n    float depth = 0.0;\n    Surface co;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = scene2(p);\n        depth += 0.6 * abs(co.sd);\n        if (abs(co.sd) < PRECISION || depth > MAX_DIST) break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 lp = vec3(0.);\n    vec3 ro = vec3(1.5 * cos(-iTime / 4.), 0.5 * sin(iTime / 8.) + 1.5, 1.5 * sin(-iTime / 4.));\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n    \n    Surface co = rayMarch1(ro, rd);\n    vec3 p = ro + rd * co.sd;\n    vec3 normal = calcNormal1(p);\n    \n    vec3 lightPosition = 4. * vec3(cos(iTime / 4.), 5., sin(iTime / 4.));\n    vec3 lightDirection = normalize(p - lightPosition);\n    float lightIntensity = 0.9;\n\n    col = phong(lightDirection, lightIntensity, normal, rd, co); \n    \n    if (co.id == 2)\n    {\n        Surface co1 = rayMarch2(ro, rd);\n        vec3 p1 = ro + rd * co.sd;\n        vec3 normal1 = calcNormal2(p1);\n        vec3 refrCol = phong(lightDirection, lightIntensity, normal1, rd, co1);\n        col = mix(col, refrCol, 0.6);\n    }\n    \n    if (co.id == 3)\n    {\n        vec3 reflRD = reflect(rd, normal);\n        vec3 reflRO = p + 1.1 * PRECISION * normal; // move origin a little bit away\n        Surface reflCO = rayMarch1(reflRO, reflRD);\n        vec3 reflP = reflRO + reflRD * reflCO.sd;\n        vec3 reflNormal = calcNormal1(reflP);\n        reflCO.sd += co.sd;\n        vec3 reflCol = phong(lightDirection, lightIntensity, reflNormal, reflRD, reflCO);\n        col = mix(col, reflCol, 0.4);\n    }\n\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int MAX_MARCHING_STEPS = 40;\n\nconst float PRECISION = 1e-3;\nconst float MAX_DIST = 10.0;\n\nfloat rand(in float seed, in float minn, in float maxx)\n{\n    return fract(sin(seed * 614.357) * 865.39) * (maxx - minn) + minn;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        8.5453123);\n}\n\n// noise ref: https://www.shadertoy.com/view/tldSRj\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*1111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;                      \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n// end ref\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\n\nstruct Material {\n  vec3 ambientColor;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  float alpha;\n};\n\nstruct Surface {\n  int id;\n  float sd;\n  Material mat;\n};\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 *(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k *h *(1.0 - h);\n}\n\nSurface opUnion(Surface obj1, Surface obj2)\n{\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface opUnionS(Surface obj1, Surface obj2)\n{\n    if(obj1.sd < obj2.sd)\n        return Surface(obj1.id, smin(obj1.sd, obj2.sd, 0.1), obj1.mat);\n    else\n        return Surface(obj2.id, smin(obj1.sd, obj2.sd, 0.1), obj2.mat);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint)\n{\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co)\n{\n    vec3 bgColor = vec3(0.8, 0.95, 1.);\n    if (co.sd > MAX_DIST) return bgColor;\n    \n    vec3 ambient = co.mat.ambientColor;\n\n    float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n    vec3 diffuse = co.mat.diffuseColor * dotLN;\n\n\n    float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n    vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n    vec3 col = lightIntensity * (ambient + diffuse + specular);\n  \n    col = mix(col, bgColor, 1.0 - exp(-0.002 * co.sd * co.sd * co.sd));\n    return col;\n\n}\n\n//  Function from Iñigo Quiles\n//  ref: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n","name":"Common","description":"","type":"common"}]}