{"ver":"0.1","info":{"id":"lsfcDs","date":"1490832974","viewed":289,"name":"hot plasma tunnel","username":"balkhan","description":"A cool little tunnel featuring nice ARTefacts. ","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","nolights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Shape deformations\n//#define LESS_ARTIFACTS // 2 next defines Only works with this defined\n //#define NO_DOORS\n //#define SQUARE\n//#define BOULDERS\n#define ROTATE\n\n//#define SHOW_SUBSTRACTOR\n\n// Colors Modes (only one enabled at a time)\n#define BLACKBODY\n//#define GRIDS\n// #define GEODESIC // sub-mode of GRID\n//#define SINUSITE\n//#define HEATWAVES\n\nfloat\tt;\t\t// time\nfloat\ta;\t\t// angle used both for camera path and distance estimator\nfloat\tg;\t\t// used for coloring\nfloat\tst;\t\t// sin(t)\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\n#define\t\tFWD_SPEED\t-7.\t// the speed at wich the tunnel travel towards you\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\n\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nfloat\tde_0(vec3 p)\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\n\n    #ifdef ROTATE\n    // rotate x and y based on z and time\n\trotate(pr.xy, (a)*.15) ;\n\t#endif\n    \n    // take the fractional part of the ray (p), \n    // and offset it to get a range from [0.,1.] to [-.5, .5]\n    // this is a space partitioning trick I saw on \"Data Transfer\" by srtuss : https://www.shadertoy.com/view/MdXGDr\n\tpr.xyz = fract(pr.xyz);\n\tpr -= .5;\n    \n    // magic numbers : .666 == 2/3, 2.09 == 2*(3.14/3), 4.18 == 4*(3.14/3)\n    // dephasing is needed in order to get the lattice\n    pr.y *= sin(t*1.+0.00+p.z+p.y-p.x);\n    pr.x *= sin(t*1.+2.09+p.z+p.y-p.x);\n    pr.z *= sin(t*1.+4.18+p.z+p.y-p.x);\n\n    mind = min(mind, (length(pr.xyz)-.3025));\n\treturn (mind * abs(sin(t*.05)) );\n}\n\nfloat\tde_1(vec3 p) // substractor\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\n\n    #ifndef\tLESS_ARTIFACTS\n    pr.x/=max(.01,-fract(p.z*.01)+.5+sin( (pr.y)*.3675-.5+(sin(pr.z*.25))*.3)-.5)*9.;\n    #else\n        #ifdef NO_DOORS\n\t    pr.x/=max(.15,( length(sin(p.z*.25) + p.y*.5))-.5);\n\t\t#else\n    \t #ifndef SQUARE\n         pr.x/=max(.052,-fract(p.z*.01)+.5+sin( (pr.y)*.3675-.5+(sin(pr.z*.25))*.3)-.5)*9.;\n    \t #else\n    \t pr.x/= (fract( abs(pr.y)*.06125-.9+(sin(pr.z*.5))*.1)-.5);\n    \t#endif\n     #endif\n    #endif\n    #ifdef BOULDERS\n    pr.x*=sin(p.y)-sin(p.z*2.)*.5;\n    #endif\n\tvec2\tq;\n    \n\tq = vec2(length(pr.yx) - 3., 0. );\n\n    q.y = rot(q.xy, vec2(-1., 0.)).x;\n\n\tmind = length(q) - 3.;\n\n\treturn mind;\n}\n\nfloat\tde_2(vec3 p)\n{\n    #ifdef SHOW_SUBSTRACTOR\n    return (20.-de_1(p));\n    #else\n    return (de_0(p)-de_1(p)*.125);\n    #endif\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    a = ( .8*(p.y*.015 + p.x*.015 + p.z *.15)  + t*3.);\n\n\trotate(p.yx, ( (a*10.)*exp(-t))*.75) ;\t// the starting spiral in the tunnel\n\tp.y += 4.;\n\tmind = de_2(p);\n\t\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp =    vec3(0.0, 0.0, 0.0);\n    vec2\ts =    vec2(0.0, 0.0);\n    vec3\tdirr = dir;\t\t\t\t\t\t// temporary variable for rotation\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tdirr = dir;\n    \trotate(dirr.zx, .05*dist.y*st );\n    \tp = pos + dirr * dist.y;\n        #ifdef GRIDS\n        g = p.z*p.y*p.x*.001;\n        g -= (step(sin(5.*p.z-1.57), .5) * step(sin(5.*p.x-1.57) , .5) \n             + step(sin(20.*p.z-1.57), .5) * step(sin(20.*p.x-1.57) , .5)); \t    \n        #endif\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 30.)\n        {\n            break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    g = 0.;\n    t  = iTime*.5;\n    st = sin(t);\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y; // Thanks Fabrice\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, t*FWD_SPEED);\n\n    vec2\tinter = (march(pos, dir));\n\n    #ifdef\tBLACKBODY\n    o.xyz = blackbody( ( 15.-inter.y+.051*inter.x ) * 75. );\n    return ;\n    #endif\n    #ifdef\tSINUSITE\n    o.xyz = inter.y*.05*vec3(abs(sin(dir.x*3.14+t+1.04)), abs(sin(dir.y*3.14+t+2.09)), abs(sin(dir.z*3.14+t+3.14)));\n    return ;\n    #endif\n    #ifdef\tGEODESIC\n\tfloat\tg = (pos+dir*inter.y).y;\n    #endif\n    #ifdef\tGRIDS\n   \to.xyz = vec3(abs(sin(t+1.32+1.04*g)), abs(sin(t+1.32+2.09*g)), abs(sin(t+1.32+3.14*g)))*inter.x*.005;\n    return ;\n\t#endif\n    #ifdef\tHEATWAVES\n    o.xyz = vec3(abs(sin(t+1.04+(15.-inter.y*.05) )), abs(sin(t+2.09+(15.-inter.y*.05) )), abs(sin(t+3.14+(15.-inter.y*.05) )));\n    return ;\n    #endif\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}