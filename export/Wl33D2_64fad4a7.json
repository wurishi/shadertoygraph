{"ver":"0.1","info":{"id":"Wl33D2","date":"1577557105","viewed":334,"name":"2D Pixel-Based Lighting Test","username":"Tara","description":"Move the light by holding the left mouse button and dragging the cursor.\n\n2020.01.16: Added trails\n\nTODO:\n- Fix aspect ratio issues.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d","ray","lighting","tracing","indirect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float gamma = 2.2;\n\nvec3 to_linear_space(vec3 color, float gamma)\n{\n\treturn(pow(color, vec3(gamma)));  \n}\n\nfloat to_linear_space(float color, float gamma)\n{\n\treturn(pow(color, gamma));  \n}\n\nvec3 to_srgb_space(vec3 color, float gamma)\n{\n\treturn(pow(color, vec3(1.0 / gamma)));\n}\n\nfloat to_srgb_space(float color, float gamma)\n{\n\treturn(pow(color, 1.0 / gamma));\n}\n\nfloat get_height(vec2 uv)\n{\n    vec3 albedo_srgb = texture(iChannel0, uv).rgb;\n\n        \n    vec3 target_color_min = vec3(104, 84, 85) / 255.0;\n    vec3 target_color_max = vec3(158, 142, 142) / 255.0;\n    \n    albedo_srgb = max(target_color_min, albedo_srgb);\n    albedo_srgb = min(target_color_max, albedo_srgb);\n    \n    vec3 fragColor;\n  \t\n    fragColor.rgb = (albedo_srgb - target_color_min) / (target_color_max - target_color_min);\n\n    vec3 range = target_color_max - target_color_min;\n    \n    float height = (fragColor.r * range.r + \n                    fragColor.g * range.g + \n                    fragColor.b * range.b) / (range.r + range.g + range.b);\n    \n    height *= 4.0;\n    height += texture(iChannel0, uv).r;\n    \n    height /= 3.0;\n    \n    return(height);        \n}\n\nvec3 calculate_lighting(vec2 uv, vec3 n_normal, vec3 linear_albedo, vec2 light_uv)\n{\n    vec3 pixel_to_mouse = vec3(light_uv - uv, 0.01);\n    //pixel_to_mouse.x *= 2.0;\n    vec3 n_pixel_to_mouse = normalize(pixel_to_mouse);\n    float light_falloff = dot(pixel_to_mouse, pixel_to_mouse) * 5000.0;\n    float diffuse = max(dot(n_pixel_to_mouse, n_normal), 0.0) * 10.0;\n    \n    vec3 h = (n_pixel_to_mouse + vec3(0.0, 0.0, 1.0)) * 0.5;\n    float specular = pow(max(dot(n_normal, h), 0.0), 16.0) * 1000.0;\n\n    vec3 light = (linear_albedo * diffuse + specular) / light_falloff;\n    //light = linear_albedo * diffuse + specular;\n    \n    //fragColor.rgb = vec3(specular);\n    //fragColor.rgb = vec3(specular / light_falloff);\n   // fragColor.rgb = vec3(diffuse);\n    \n    return(light);\n}\n\nmat2 get_random_rotation_matrix(vec2 texture_space_ssao_radius)\n{\n\t//float random_number = hash(gl_FragCoord.xy + hash_offset, vec2(3.0, 19.0), 7.0);\n\t\n\t// Slower than using a hash, but looks less noisy and repetitive.\n\tfloat random_number = textureLod(iChannel3, gl_FragCoord.xy / iChannelResolution[3].xy, 0.0).r;\n\n\t// Calculate a random angle in a 180 degree range (not 360 degrees, because we do paired sampling).\n\tconst float pi = 3.1415926535897932384626433832795;\n\n\tfloat random_angle = random_number * pi;\t// Calculate a random angle in a 180 range. Only 180 because this leads to better performance than rotating a higher angle (due to caching).\n\t\n\t// Angle scaled by kernel radius (so small kernels don't get rotated much):\n\t//random_angle *= min(1.0, texture_space_ssao_radius.x * 10.0);\n\t\n\tfloat cs = cos(random_angle);\n\tfloat sn = sin(random_angle);\n\t\n\tmat2 rotation_matrix = mat2(cs * texture_space_ssao_radius.x, sn * texture_space_ssao_radius.y,\n\t\t\t\t\t\t\t   -sn * texture_space_ssao_radius.x, cs * texture_space_ssao_radius.y);\n\n\treturn(rotation_matrix);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_unscaled = fragCoord/iResolution.xy;\n    vec2 uv = uv_unscaled;\n\tuv.x *= iResolution.x / iResolution.y;\n\t//uv_unscaled.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n\tmouse_uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 albedo = texture(iChannel0, uv).rgb;\n    vec3 linear_albedo = to_linear_space(albedo, gamma);\n    fragColor = vec4(pow(texture(iChannel0, uv).b, 2.0));\n    //fragColor -= vec4(pow(texture(iChannel0, uv).g, 4.0)) * 0.25;\n    \n    float offset = 0.0002;\n    float left_height = pow(texture(iChannel0, uv + vec2(-offset, 0.0)).b, 2.0);\n    float right_height = pow(texture(iChannel0, uv + vec2(offset, 0.0)).b, 2.0);\n    \n    float top_height = pow(texture(iChannel0, uv + vec2(0.0, offset)).b, 2.0);\n    float bottom_height = pow(texture(iChannel0, uv + vec2(0.0, -offset)).b, 2.0);\n    \n    left_height = get_height(uv + vec2(-offset, 0.0));\n    right_height = get_height(uv + vec2(offset, 0.0));\n    \n    top_height = get_height(uv + vec2(0.0, offset));\n    bottom_height = get_height(uv + vec2(0.0, -offset));\n    \n    \n    \n    const float normal_strength = 0.2;\n    vec3 normal;\n    normal.x = left_height - right_height;\n    normal.y = top_height - bottom_height;\n    normal.z = (1.0 - dot(normal.xy, normal.xy)) * normal_strength;\n    vec3 n_normal = normalize(normal);\n    fragColor = vec4(normal, 0.0);\n    \n    //fragColor.rgb = calculate_lighting(uv, n_normal, linear_albedo, mouse_uv);\n    fragColor.rgb = vec3(0.0);\n       \n        \n    //fragColor.rgb = calculate_lighting(uv, n_normal, linear_albedo, vec2(0.1, 0.1));\n    \n    \n    mat2 rotation_matrix = get_random_rotation_matrix(vec2(1.0));\n    \n    const int radius = 16;\n    const float scale = 1.0 / float(radius) * 0.2;\n    const float max_distance = float(radius) * scale;\n    for(int x=-radius; x<=radius; ++x)\n    for(int y=-radius; y<=radius; ++y)\n    {\n        /*\n        if(abs(x) + abs(y) > radius)\n        {\n            continue;\n        }\n        */\n        \n        vec2 offset = vec2(x, y) * scale;\n        \n        offset = offset * rotation_matrix;\n            \n        \n        vec2 sample_uv = uv_unscaled + offset;\n        vec2 light_uv = sample_uv / DOWNSAMPLING_FACTOR;\n\t\t//light_uv.x *= iResolution.x / iResolution.y;\n            \n    \n    /*\n    const int samples = 200;\n    for(int i=0; i<samples; ++i)\n    {\n        float radius =  float(i) / 200.0;\n        float x = sin(float(i) * 4.5) * radius;\n        float y = cos(float(i) * 4.5) * radius;\n        vec2 sample_uv = uv + vec2(x, y);\n        */\n        \n        //vec3 light = get_light(iChannel1, sample_uv);\n        vec3 light = texture(iChannel1, light_uv).rgb;\n        if(light.r + light.g + light.b > 0.1)\n        {\n           //\toffset.x *= iResolution.x / iResolution.y;\n            \n            float fade = 1.0 / (length(offset) / max_distance);\n            fade = pow(fade, 0.1);\n            \n            vec2 sample_uv2 = sample_uv;\n            sample_uv2.x *= iResolution.x / iResolution.y;\n    \t\tfragColor.rgb += fade * light * calculate_lighting(uv, n_normal, linear_albedo, sample_uv2);\n        }\n    }\n\n    fragColor.rgb = to_srgb_space(fragColor.rgb, gamma);\n    //fragColor.rgb = vec3(get_light(uv));\n    //fragColor.rgb = texture(iChannel2, uv_unscaled).rgb;\n    \n    /*\n    //fragColor = vec4(pow(texture(iChannel0, uv).r * texture(iChannel0, uv).g * texture(iChannel0, uv).b * 6.9, 2.0));\n    \n        \n    vec3 target_color = vec3(147, 128, 129) / 255.0;\n    vec3 target_color_min = vec3(104, 84, 85) / 255.0;\n    vec3 target_color_max = vec3(158, 142, 142) / 255.0;\n    fragColor.rgb = pow(vec3(0.9) - (texture(iChannel0, uv).rgb - target_color), vec3(5.0));\n    \n    \n    vec3 albedo_srgb = texture(iChannel0, uv).rgb;\n    \n    //albedo_srgb = max(target_color_min, albedo_srgb);\n    //albedo_srgb = min(target_color_max, albedo_srgb);\n    \n    if(albedo_srgb.r > target_color_min.r && albedo_srgb.r < target_color_max.r &&\n       albedo_srgb.g > target_color_min.g && albedo_srgb.g < target_color_max.g &&\n       albedo_srgb.b > target_color_min.b && albedo_srgb.b < target_color_max.b)\n    {\n        //fragColor.rgb = vec3(1.0, 0.0, 0.0);\n        //fragColor.rgb = (albedo_srgb - target_color_min) / (target_color_max - target_color_min);\n    \tfragColor.rgb = (albedo_srgb - target_color_min) / (target_color_max - target_color_min);\n    \t//fragColor.rgb = vec3(fragColor.r + \n        //                     fragColor.g + \n        //                     fragColor.b) / 3.0;\n        \n        vec3 range = target_color_max - target_color_min;\n        fragColor.rgb = vec3(fragColor.r * range.r + \n                             fragColor.g * range.g + \n                             fragColor.b * range.b) / (range.r + range.g + range.b);\n        \n        //fragColor.rgb = fragColor.bbb;\n        \n        fragColor.rgb = pow(fragColor.rgb, vec3(0.25));\n    }\n    else\n    {\n        fragColor.rgb = vec3(0.0, 0.0, 0.0);\n    }\n    */\n    \n    //fragColor.rgb = vec3(fragColor.r + fragColor.g + fragColor.b) / 3.0;\n    //fragColor = texture(iChannel0, uv).rgba;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_original = fragCoord/iResolution.xy;\n    vec2 uv = uv_original;\n\t//uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= DOWNSAMPLING_FACTOR;\n    if(uv.x > 1.0 || uv.y > 1.0)\n    {\n    \tdiscard;\n    }\n    \n    \n    //uv.x -= 0.3;\n    \n    \n    \n    //fragColor.rgb = get_light(iChannel0, uv);\n    \n    vec3 albedo_srgb = texture(iChannel0, uv).rgb;\n    \n    albedo_srgb += texture(iChannel0, uv + vec2(0.005, 0.0)).rgb;\n    albedo_srgb += texture(iChannel0, uv - vec2(0.005, 0.0)).rgb;\n    albedo_srgb += texture(iChannel0, uv + vec2(0.0, 0.005)).rgb;\n    albedo_srgb += texture(iChannel0, uv - vec2(0.0, 0.005)).rgb;\n    albedo_srgb /= 5.0;\n        \n    fragColor.rgb = albedo_srgb;\n    \n    float mask = 1.0;\n    \n    /*\n    // Cut out the green background:\n    //if(fragColor.r < 0.3 && fragColor.g > 0.4 && fragColor.b < 0.3)\n    if(max(fragColor.r - 0.3, 0.0) + max(fragColor.g - 0.4, 0.0) + max(fragColor.b - 0.3, 0.0) < 0.3)\n    {\n        mask = 0.0;\n    \tfragColor = vec4(0.0);\n    }\n    */\n    \n    float val = max(fragColor.r - 0.3, 0.0) + max(fragColor.g - 0.4, 0.0) + max(fragColor.b - 0.3, 0.0);\n\tmask = pow(smoothstep(0.3, 0.8, val), 6.0);\n    \n    fragColor.r = 0.0;\n    \n        \n    fragColor.rgb = fragColor.grb;\n    fragColor.r = 0.55 + 0.5 * sin(fragColor.r * 5.0);\n    fragColor.g = 0.35 + 0.5 * sin(fragColor.r * 15.0 + 46.167);\n    fragColor.b = 0.3 + 0.5 * sin(fragColor.r * 10.0 + 13.13);\n    \n    //fragColor.g *= 0.85;\n    fragColor.g *= 0.85;\n    \n    fragColor.rgb = fragColor.bgr;\n    //\n    \n    //fragColor.g += 0.5 * -sin(fragColor.r * 5.0) * 0.1;\n   // fragColor.b += 0.5 * -sin(fragColor.g * 20.0) * 0.5;\n   // fragColor.r += 0.5 * -sin(fragColor.b * 12.0);\n    \n    //fragColor.rgb = fragColor.rbb;\n    \n    fragColor.rgb = max(fragColor.rgb, vec3(0.0));\n    fragColor.rgb = pow(fragColor.gbr, vec3(20.0)) * 100.0;\n    \n    //fragColor.g *= 0.25;\n   // fragColor.r *= 1.5;\n    \n    fragColor.rgb *= mask;\n    \n    \n    \n    fragColor.rgb = clamp(fragColor.rgb * 10.0, vec3(0.0), vec3(10.0));\n    \n    \n    \n    // Add ligh at cursor:\n    vec2 mouse_uv = iMouse.xy / iResolution.xy / DOWNSAMPLING_FACTOR;\n\t//uv_original.x /= iResolution.x / iResolution.y;\n    if(distance(mouse_uv, uv_original) < 0.01)\n    {\n    \tfragColor.rgb = vec3(uv, 1.0);\n    }\n    \n    //fragColor.rgb = texture(iChannel0, uv * 0.05).rrr * 0.1;\n    \n    \n    /*\n    if(uv.x > 0.9)\n    {\n    \tfragColor = vec4(0.0);\n    }\n    */\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Defines how much to downsample the light texture for better performance.\nconst float DOWNSAMPLING_FACTOR = 4.0;\n\nvec3 get_light(sampler2D tex, vec2 uv)\n{\n    vec3 albedo_srgb = texture(tex, uv).rgb;\n\n    \n    //return(pow(max(albedo_srgb - vec3(0.0, 0.8, 0.0), vec3(0.0)), vec3(2.0))) * 3.0;\n        \n    vec3 target_color_min = vec3(104, 84, 85) / 255.0;\n    vec3 target_color_max = vec3(158, 142, 142) / 255.0;\n    \n    albedo_srgb = max(target_color_min, albedo_srgb);\n    albedo_srgb = min(target_color_max, albedo_srgb);\n    \n    vec3 fragColor;\n  \t\n    fragColor.rgb = (albedo_srgb - target_color_min) / (target_color_max - target_color_min);\n\n    vec3 range = target_color_max - target_color_min;\n    \n    float height = (fragColor.r * range.r + \n                    fragColor.g * range.g + \n                    fragColor.b * range.b) / (range.r + range.g + range.b);\n    \n    float brightness = clamp(pow(0.5 - abs(0.5 - uv.y), 1.0) - 0.48, 0.0, 1.0) * 1000.0;\n    \n    brightness = (clamp(pow(1.0 - height - 0.01, 100.0), 0.0, 1.0)) * 100.0;\n    \n    return(vec3(0.01 + max(sin(uv.x * 20.0 + 0.5), 0.0),\n                0.01 + max(cos(uv.x * 0.5 + 1.0), 0.0),\n                0.01 + max(sin((uv.x - 6.1) * 4.0), 0.0)) * brightness);\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 old_color = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    vec3 new_color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.rgb = mix(old_color, new_color, 0.2);\n    fragColor.a = 1.0;\n}","name":"Buf B","description":"","type":"buffer"}]}