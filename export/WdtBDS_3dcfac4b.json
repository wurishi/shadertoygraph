{"ver":"0.1","info":{"id":"WdtBDS","date":"1605910637","viewed":210,"name":"Rusty ball - Having fun with PBR","username":"jaszunio15","description":"I was experimenting with the lighting that comes only from cubemap. Enjoy :)\nCoding timelapse: [url]https://youtu.be/dVKr2FVISmA[/url]\n\nUnity-like camera movement: mouse click + WASDQE\nG - enable grid\n\nLicense: CC BY 3.0\nJan Mróz (jaszunio15)","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","sdf","lighting","camera","cubemap","ball","reflections","pbr","rust"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n\n#define CAMERA_FOV 1.6\n\nvec3 uvToCastPlane(vec2 uv)\n{\n \treturn vec3(uv.x, uv.y, CAMERA_FOV);   \n}\n\nfloat sphereSDF(vec3 coord, vec3 sphereCenter, float radius)\n{\n \treturn distance(coord, sphereCenter) - radius;\n}\n\nfloat objectSDF(vec3 coord)\n{\n\tfloat obj = sphereSDF(coord, vec3(0.0), 1.0);\n    return obj;\n}\n\nvec3 objectNormal(vec3 coord)\n{\n \treturn normalize(coord);   \n}\n\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n \tfor (int i = 0; i < 50; i++)\n    {\n     \tfloat sdf = objectSDF(rayOrigin);\n        rayOrigin += sdf * rayDirection * 0.8;\n    }\n    \n    return rayOrigin;\n}\n\nstruct SurfaceData\n{\n    vec3 albedo;\n    float specular;\n    float gloss;\n    vec3 position;\n    vec3 normal;\n};\n    \nstruct LightData\n{\n \tvec3 direction;\n    vec3 color;\n    float attenuation;\n};\n    \nLightData getDirectionalLight()\n{\n \tLightData ld;\n    ld.direction = normalize(vec3(1.0, 1.0, 1.0));\n    ld.color = vec3(1.0, 0.9, 0.8);\n    ld.attenuation = 0.5;\n    \n    return ld;\n}\n\nvec3 calculateReflection(SurfaceData surface, vec3 viewDirection)\n{\n    vec3 reflectionVec = reflect(-viewDirection, surface.normal);\n \tvec3 reflectionColor = convertToLinear(textureLod(iChannel1, reflectionVec, mix(7.0, 0.0, sqrt(surface.gloss))).rgb);\n    \n    vec3 color = reflectionColor * sqrt(surface.specular);\n    return color;\n}\n\nvec3 calculateAmbientLight(SurfaceData surface, vec3 viewDirection)\n{\n    vec3 ambientColor;\n \tvec3 ambientEnvironment = convertToLinear(textureLod(iChannel1, surface.normal, 8.0).rgb);\n    \n    vec3 reflectionVec = reflect(-viewDirection, surface.normal);\n    vec3 fresnelAmbientColor = convertToLinear(textureLod(iChannel1, reflectionVec, 7.0).rgb);\n    float fresnelAmbientStrength = (1.0 - surface.specular) * pow(1.0 - dot(viewDirection, surface.normal), 3.0);\n    fresnelAmbientStrength = max(0.0, fresnelAmbientStrength * 0.7);\n    ambientColor = ambientEnvironment * surface.albedo + fresnelAmbientStrength * fresnelAmbientColor;\n    \n    return ambientColor;\n}\n\nvec3 noise3D(vec3 coord)\n{\n\treturn texture(iChannel2, coord).rgb;   \n}\n\nvec3 layeredNoise3D(vec3 coord, float numberOfLayers, float sizeMod, float alphaMod)\n{\n    vec3 sum = vec3(0.0);\n    float maxValue = 0.0;\n    float alpha = 1.0;\n    for (float i = 0.0; i < numberOfLayers; i++)\n    {\n     \tvec3 noiseValue = noise3D(coord) * alpha;\n        maxValue += alpha;\n        alpha *= alphaMod;\n        coord *= sizeMod + 0.2123123;\n      \tsum += noiseValue;\n\n    }\n    \n    return sum / maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    \n    //mat3\n    mat3 rotation = rotationMatrixY(iTime * 0.2);\n    //mat3 rotation = rotationMatrixY(0.0);\n    \n    \n    //Getting camera properties from buffer A\n    vec3 cameraPosition = getCameraPositionFromBufferA(iChannel0);\n    mat3 cameraRotation = getCameraRotationFromBufferA(iChannel0, iResolution.xy);\n                            \n\t//Creating ray\n    vec3 rayOrigin = rotation * cameraPosition;\n    vec3 rayDirection = normalize(rotation * cameraRotation * uvToCastPlane(uv));\n    \n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection);\n    float sdf = objectSDF(hitPoint);\n    \n    vec4 col = vec4(0.0);\n    \n    bool isObject = sdf < 0.01;\n    if (isObject)\n    {\n        SurfaceData sd;\n        sd.albedo = vec3(0.9);\n        sd.specular = 0.5;\n        sd.gloss = 0.4;\n        sd.position = hitPoint;\n        sd.normal = objectNormal(hitPoint);\n\n        \n        // modify specular\n        vec3 noise = layeredNoise3D(hitPoint * 0.07, 7.0, 2.2, 0.7);\n        sd.specular = noise.r;\n        sd.specular *= sd.specular;\n        sd.specular = smoothstep(0.18, 0.85, sd.specular);\n        sd.gloss = sd.specular;\n        \n                \n        // modify normal\n        sd.normal = normalize(sd.normal + (noise3D(hitPoint * 4.0) - 0.5) * 0.1 * sd.specular);\n        \n        // albedo\n        float rust = layeredNoise3D(hitPoint * vec3(1.0, 0.3, 1.0) * 3.0 + noise.g * 0.1, 7.0, 1.4, 0.9).r * pow((1.0 - sd.specular), 3.0);\n        rust = smoothstep(0.1, 0.8, rust);\n        rust = mix(rust, pow(1.0 - sd.specular, 4.0), 0.3);\n        sd.albedo = mix(sd.albedo, vec3(0.4, 0.2, 0.1), sqrt(rust));\n        sd.albedo = mix(sd.albedo, vec3(0.0, 0.0, 0.0), pow(1.0 - sd.specular, 10.0) * 0.5);\n        \n        LightData directionalLight = getDirectionalLight();\n        \n        vec3 viewDirection = normalize(-rayDirection);\n        \n        \n        col.rgb += calculateReflection(sd, viewDirection);\n        col.rgb += calculateAmbientLight(sd, viewDirection);\n        //col.rgb = vec3(viewDirection);\n    }\n    else\n    {\n        col.rgb += convertToLinear(texture(iChannel1, rayDirection).rgb);\n    }\n    \n    //Adding grid to the final image\n    bool gridVisibility = isGridVisible(iChannel0);\n    if (gridVisibility)\n    {\n        vec4 grid = getGrid(rayOrigin, rayDirection) * 0.1 + 0.1;\n     \tcol.rgb += convertToLinear(grid.rgb);\n    }\n    \n    \n    fragColor.rgb = convertToGamma(col.rgb);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_G 71\n#define KEY_SHIFT 16\n\n#define GET_KEY(k) (texture(iChannel0, vec2(float(k) / 256.0, 0.1) ).x)\n#define GET_TOGGLE(k) (texture(iChannel0, vec2(float(k) / 256.0, 0.9) ).x)\n#define PI 3.1419\n\n#define MOVE_SPEED 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1) //Camera start position and rotation\n    {\n     \tif (fragCoord.x <= 2.0)\n        {\n            if (fragCoord.x < 1.0)\n            {\n\t\t\t\tfragColor = vec4(0.0, 0.0, -1.9, 1.0);\n            }\n            else fragColor = vec4(1.0);\n        }\n    }\n    else if (fragCoord.y < 1.0 && fragCoord.x <= 2.0)\n    {\n        vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n        \n        if (iMouse.x < 1.0 && iMouse.y < 1.0) mousePos = vec2(0.0); \n\n        float yaw = mousePos.x * PI * 4.0;\n        float pitch = mousePos.y * PI;\n\n        //Same matrix construction as in common tab\n        mat3 cameraRotation = mat3(cos(yaw), 0.0, -sin(yaw),\n                                0.0, 1.0, 0.0,\n                                sin(yaw), 0.0, cos(yaw)) *\n            \t\t\t\tmat3(1.0, 0.0, 0.0,\n                                  0.0, cos(pitch), -sin(pitch),\n                                  0.0, sin(pitch), cos(pitch));\n                            \n\n        vec3 forward = cameraRotation * vec3(0, 0, 1);\n        vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n        vec3 up = normalize(cross(forward, right));\n\n        float keyW = GET_KEY(KEY_W);\n        float keyA = GET_KEY(KEY_A);\n        float keyS = GET_KEY(KEY_S);\n        float keyD = GET_KEY(KEY_D);\n        float keyQ = GET_KEY(KEY_Q);\n        float keyE = GET_KEY(KEY_E);\n        float toggleG = GET_TOGGLE(KEY_G);\n        float keyShift = GET_KEY(KEY_SHIFT);\n        \n        if (fragCoord.x < 1.0)\n        {\n            float speedBoost = (1.0 + keyShift * 3.0);\n            vec3 cameraPos = texture(iChannel1, vec2(0.0, 0.0)).xyz;\n            cameraPos += forward * (keyW - keyS) * iTimeDelta * MOVE_SPEED * speedBoost;\n            cameraPos += right * (keyD - keyA) * iTimeDelta * MOVE_SPEED * speedBoost;\n            cameraPos += up * (keyE - keyQ) * iTimeDelta * MOVE_SPEED * speedBoost;\n            fragColor = vec4(cameraPos, toggleG);\n        }\n        else\n        {\n            vec2 cameraRotation = vec2(yaw, pitch);\n            fragColor = vec4(cameraRotation, 0.0, 0.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BASE_WIDTH 0.006\n#define AXIS_WIDTH 0.05\n\nvec3 getCameraPositionFromBufferA(sampler2D bufferA)\n{\n \treturn texture(bufferA, vec2(0.0, 0.0)).xyz;\n}\n\nmat3 getCameraRotationFromBufferA(sampler2D bufferA, vec2 resolution)\n{\n \t\n    vec2 cameraAngle = texture(bufferA, vec2(1.2, 0.0) / resolution.xy).xy;\n    \n    mat3 cameraRotation = mat3(cos(cameraAngle.x), 0.0, -sin(cameraAngle.x),\n                                0.0, 1.0, 0.0,\n                                sin(cameraAngle.x), 0.0, cos(cameraAngle.x)) *\n        \t\t\t\t  mat3(1.0, 0.0, 0.0,\n                                  0.0, cos(cameraAngle.y), -sin(cameraAngle.y),\n                                  0.0, sin(cameraAngle.y), cos(cameraAngle.y));\n    \n    return cameraRotation;\n}\n\nbool isGridVisible(sampler2D bufferA)\n{\n\treturn (1.0 - texture(bufferA, vec2(0.0, 0.0)).w) > 0.5;\n}\n\nmat3 rotationMatrixY(float angle)\n{\n \tfloat c = cos(angle), s = sin(angle);\n    \n    return mat3x3(c, 0.0, s, \n                  0.0, 1.0, 0.0, \n                  -s, 0.0, c);\n}\n\n//xy - plane uv, z - visibility, w - distance\nvec4 castXZPlane(vec3 rayOrigin, vec3 rayDirection)\n{\n    float mul = 1.0;\n    if (rayOrigin.y < 0.0) mul = -1.0;\n    \n    vec3 castRayOrigin = rayOrigin;\n \tfloat distToPlane = abs(castRayOrigin.y);\n    vec3 castRayDirection = rayDirection / rayDirection.y;\n    castRayDirection *= distToPlane;\n    \n    castRayOrigin -= mul * castRayDirection;\n    \n    return vec4((castRayOrigin).xz, (dot(rayDirection * mul, castRayDirection) < 0.0 ? 1.0 : 0.0), length(castRayDirection));\n}\n\nfloat planeToLines(vec4 plane)\n{\n \tvec2 uv = fract(plane.xy + 0.5);\n    float width = BASE_WIDTH * (plane.w);\n    float fade = smoothstep(100.0, -20.0, plane.w);\n\treturn min((smoothstep(width, 0.0, abs(uv.x - 0.5)) + smoothstep(width, 0.0, abs(uv.y - 0.5))) * plane.z, 1.0) * fade;\n}\n\n//x - x axis, y - y axis\nvec2 planeToAxis(vec4 plane)\n{\n \tfloat width = AXIS_WIDTH * (plane.w);\n    float fade = smoothstep(100.0, -20.0, plane.w);\n    float xAxis = smoothstep(width, 0.0, abs(plane.x)) * smoothstep(0.0, 0.01, plane.y);\n    float yAxis = smoothstep(width, 0.0, abs(plane.y)) * smoothstep(0.0, 0.01, plane.x);\n    return vec2(xAxis, yAxis) * plane.z * fade;\n}\n\nvec4 getGrid(vec3 rayOrigin, vec3 rayDirection)\n{\n    vec4 xzPlane = castXZPlane(rayOrigin.zyx, rayDirection.zyx);\n    float xzLines = planeToLines(xzPlane);\n    vec2 xzAxis = planeToAxis(xzPlane);\n    \n    vec4 xyPlane = castXZPlane(rayOrigin.yzx, rayDirection.yzx);\n    float xyLines = planeToLines(xyPlane);\n    vec2 xyAxis = planeToAxis(xyPlane);\n    \n    vec4 yzPlane = castXZPlane(rayOrigin.zxy, rayDirection.zxy);\n    float yzLines = planeToLines(yzPlane);\n    vec2 yzAxis = planeToAxis(yzPlane);\n\n    vec4 grid = vec4(0.0);\n    \n    grid += xzLines + vec4(xzAxis.x, 0.0, xzAxis.y, 0.0);\n    grid += xyLines + vec4(xyAxis.x, xyAxis.y, 0.0, 0.0);\n    grid += yzLines + vec4(0.0, yzAxis.x, yzAxis.y, 0.0);\n    \n    return grid;\n}\n\n\nvec3 convertToLinear(vec3 color)\n{\n    return pow(color, vec3(2.2));\n}\n\nvec3 convertToGamma(vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n","name":"Common","description":"","type":"common"}]}