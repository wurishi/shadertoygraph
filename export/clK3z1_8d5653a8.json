{"ver":"0.1","info":{"id":"clK3z1","date":"1683577865","viewed":66,"name":"MCG: Bouncing ball","username":"tale3d","description":"Lecture on computer graphics physics. This is a very simple example of Explicit Euler Integrator with faked air drag, but should provide an example of how this works. ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //retrieving the position from the buffer\n    vec2 pos = texture(iChannel0, uv).xy;\n \n    //default colour is white\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    //draw the circle\n    float dist = length(c - pos);\n    if (dist < RADIUS)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RADIUS 0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n   \n    //in this example we store the position and velocity for EVERY pixel in the buffer\n    //not quite scalable, but allows for easy prototyping\n    vec4 pv = texture(iChannel0, uv);\n    //the position is the first two channels of the colour\n    vec2 position = pv.xy;\n    //the velocity is the last two channels of the colour\n    vec2 velocity = pv.zw;\n    \n    //in frame 0 initialise the position and velocity\n    if (iTime == 0.0)\n    {\n        position = vec2(RADIUS-1.0, 0.5-RADIUS);\n        velocity = vec2(1.0, 0.0);\n    }\n    \n    //iTimeDelta is a shadertoy variable that returns time delta\n    float dt = iTimeDelta;\n    \n    //apply physics here\n    vec2 position_new = position + dt*velocity;\n    vec2 velocity_new = velocity + dt*vec2(0., -10);\n    \n    //check for collision detection and resolve\n    if (position_new.y < RADIUS-1.0) \n    {\n       //the floor\n        position_new.y = RADIUS-1.0;\n        velocity_new.y = -velocity_new.y;\n        \n        //fake air drag\n        velocity_new*=0.8;\n    }\n    \n    if (position_new.x > aspect_ratio-RADIUS)\n    {\n        //right wall\n        position_new.x = aspect_ratio-RADIUS;\n        velocity_new.x = -velocity_new.x;\n        velocity_new*=0.8;\n    }\n\n    if (position_new.x < -aspect_ratio+RADIUS)\n    {\n        //left wall\n        position_new.x = -aspect_ratio+RADIUS;\n        velocity_new.x = -velocity_new.x;\n        velocity_new*=0.8;\n    }\n    \n    // Store position and speed in the output (which is also iChannel0).\n    fragColor = vec4(position_new, velocity_new);\n}","name":"Buffer A","description":"","type":"buffer"}]}