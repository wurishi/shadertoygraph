{"ver":"0.1","info":{"id":"Mc2Bzt","date":"1725653637","viewed":113,"name":"Spiral Flag","username":"incre_ment","description":"More daily coding","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","mesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);   \n   float tt = fract(.3*iTime);\n     \n   float scale =20.;\n   uv *= scale;  \n   vec2 cellID = round(uv);\n   uv = fract(uv +.5) - .5;\n   \n   float nS = 2.;\n   float minVal = 1E20;\n   float nCheck = 1.;\n   for (float i = -nCheck; i <= nCheck; i++)\n     for(float j = -nCheck; j <= nCheck; j++){ \n       vec2 uvCenter = (cellID + vec2(i,j)) / scale;\n       float xCutoff = .7;\n       float yCutOff = xCutoff/(iResolution.x/iResolution.y);\n       if (abs(uvCenter.x) < xCutoff && abs(uvCenter.y) < yCutOff){\n         float centerDelta = TAU*(tt - 2.*length(uvCenter))+ atan(uvCenter.y,uvCenter.x) + PI ;\n         // centerDelta = PI/2.;\n\n         float meshDim = clamp(.35 + .35*sin(centerDelta),0.,.5); \n         \n         vec2 p1 = uvCenter + vec2(-meshDim/scale,meshDim/scale);\n         vec2 p2 = uvCenter + vec2(-meshDim/scale,-meshDim/scale);\n         vec2 p3 = uvCenter + vec2(meshDim/scale,-meshDim/scale);\n         vec2 p4 = uvCenter + vec2(meshDim/scale,meshDim/scale);      \n         \n         float v1delta = TAU*(tt - 2.*length(p1)) + atan(p1.y,p1.x) + PI ;\n         float v2delta = TAU*(tt - 2.*length(p2)) + atan(p2.y,p2.x) + PI ;\n         float v3delta = TAU*(tt - 2.*length(p3)) + atan(p3.y,p3.x) + PI ;\n         float v4delta = TAU*(tt - 2.*length(p4)) + atan(p4.y,p4.x) + PI ;\n\n         vec2[4] verts; \n         float r = .5;\n         verts[0] = vec2(i,j) + vec2(-meshDim,meshDim) + vec2(r*cos(v1delta),r*sin(v1delta));\n         verts[1] = vec2(i,j) + vec2(-meshDim,-meshDim)+ vec2(r*cos(v2delta),r*sin(v2delta));\n         verts[2] = vec2(i,j) + vec2(meshDim, -meshDim)+ vec2(r*cos(v3delta),r*sin(v3delta));\n         verts[3] = vec2(i,j) + vec2(meshDim, meshDim) + vec2(r*cos(v4delta),r*sin(v4delta));\n         float poly = sdPolygon(verts, uv);\n         minVal = min(poly, minVal);\n       }\n     }\n     \n   \n     col += .035/abs(minVal);\n     fragColor = vec4(col,1.0);\n   \n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int N = 4;\n\n// SDF from IQ\nfloat sdPolygon( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n","name":"Common","description":"","type":"common"}]}