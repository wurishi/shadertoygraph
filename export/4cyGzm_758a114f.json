{"ver":"0.1","info":{"id":"4cyGzm","date":"1712528888","viewed":133,"name":"Terrainmarching_01","username":"Creatorbyte","description":"I made this shader to learn more about raymarching and noise/FBM functions. I was inspired by IQ's video, \"Painting a Landscape with Maths\" which I am working through as a guide to learn more about these techniques. This shader has some remaining issues.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* This shader was written by me (Creatorbyte) to learn about raymarching and noise/FBM functions\n* It has some lingering bugs and artifacts that I am working to fix before I continue to add to the shader.\n*/\n\nuniform vec2 screen_size;\nuniform sampler2D g_Texture0;\nuniform vec3 g_Screen;\nuniform float g_Time;\n\n// Color palette\nvec3 pal(float t) {\n    vec3 b = vec3(0.45);\n    vec3 c = vec3(0.35);\n    return b + c*cos(6.28318*(t*vec3(1)+vec3(0.7,0.39, 0.2)));\n}\n\n// Smooth minimum function\nfloat smin(float a, float b, float k){\n\tfloat h = max(k - abs(a - b), 0.0) / k;\n\treturn min(a, b) - h * h * h * k * (1.0/6.0);\n}\n\nvec3 rotate3D(in vec3 p, vec3 axis, float angle){\n\treturn mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nvec2 rotate2D(in vec2 p, in float angle) {\n    // Rotation matrix components\n\tfloat s = sin(angle);\n    float c = cos(angle);\n\n    // Manually apply the rotation to the components of p\n    float xNew = p.x * c - p.y * s;\n    float yNew = p.x * s + p.y * c;\n\n    return vec2(xNew, yNew);\n}\n\n//Typical pseudo-random hash (white noise)\nfloat hash1(vec2 p)\n{\n    return fract(sin(p.x*0.129898 + p.y*0.78233) * 43758.5453);\n}\n\n//vec2 version of the hash function\nvec2 hash2(vec2 p)\n{\n    return fract(sin(p * mat2(vec2(0.129898, 0.81314), vec2(0.78233,  0.15926))) * 43758.5453);\n}\n\n//vec2 unit-vector version of the hash function\nvec2 hash2_norm(vec2 p)\n{\n    //Returns a random normalized direction vector\n    return normalize(hash2(p) - 0.5);\n}\n\n//Standard value noise\nfloat value_noise(vec2 p)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Sub-cell (fractional) coordinates\n    vec2 sub = p - cell; // equivalent to fract(p)\n    //Cubic interpolation (use sub for linear interpolation)\n    vec2 cube = sub*sub*(3.-2.*sub);\n    //Offset vector\n    const vec2 off = vec2(0,1); \n\n    //Sample cell corners and interpolate between them.\n    return mix( mix(hash1(cell+off.xx), hash1(cell+off.yx), cube.x),\n                mix(hash1(cell+off.xy), hash1(cell+off.yy), cube.x), cube.y);\n}\n\n//Fractal Brownian-Motion\nfloat fbm2( in vec2 x, in int numOctaves)\n{   \n    \n    float persistence = 0.5; // commonly used value for \"terrain\" shapes\n    float lacunarity = 2.0;\n    \n    float freq = 0.5;\n    float amp = 1.0;\n    \n    float signal = 0.0;\n    for(int i=0; i<numOctaves; i++)\n    {\n        // add the noise to the total signal\n        signal += amp*value_noise(freq*x);\n        \n        // scale the signal by a set amount each octave\n        freq *= lacunarity;\n        amp *= persistence;\n        \n        x = rotate2D(x, 0.1627); // rotate the space for the next octave's signal\n    }\n    \n    return signal;\n}\n\n\n// SDF \"Terrain\"\nfloat sdf_Terrain(vec3 p, int octaves, float h_scale){\n    // The distace to the floor is always just the y component of the ray\n    // Add noise as an offset to make something like terrain\n    return p.y + (1.0/h_scale) * fbm2(vec2(h_scale * p.x, h_scale * p.z), octaves);\n}\n\n// Distance from camera (ray origin) to scene\nfloat scene(vec3 p){\n\treturn sdf_Terrain(p, 5, 0.250);\n}\n\n//Simple raymarch function\nvec4 raymarch(vec3 pos, vec3 dir)\n{\n\tfloat d = 0.0; //Total distance\n\tint Iterations = 50;\n\tfor(int i = 0; i < Iterations; i++) //March Iterations\n\t{\n\t\tfloat step_d = scene(pos + dir * d); //Compute distance to scene\n\t\td += step_d; //March the ray by adding step_d to total distance\n\t\tif (step_d < 0.001 || d > 100.0) break; //Stop at intersection or max distance\n\t}\n\treturn vec4(pos + dir * d, d); //Return intersection position and distance\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspectRatio = iResolution.x/iResolution.y;// Calculate the aspect ratio (g_Screen.x/g_Screen.y)\n\n\t// Calculate UVs and Scale Clip Space\n\tvec2 uv = fragCoord/iResolution.xy; //calculate UVs\n\tuv = uv - 0.5; // Adjust clip space to put (0,0) at center of screen\n\tuv = uv * 2.0; // Scale clip space\n\tuv.x *= aspectRatio; // Adjust for aspect ratio\n\t//uv.y *= -1.0; // Flip Y coordinates. Necessary for GODOT engine\n\t\n\t// Initialize variables for ray marching\n\tvec3 ro = vec3(0.0, 0.0, iTime * 0.75 + 5.0); // Ray origin, with forward Z movement.\n\t\n\tfloat FOV_Scale = 1.0;\n\tvec3 rd = normalize(vec3(uv * FOV_Scale, 1.0)); // Ray direction\n    \n    rd = rotate3D(rd, vec3(0.0, 1.0, 0.0), sin(iTime * 0.1)); // Rotate the observer yaw over time\n    \n\tvec3 col = vec3(0.0); // the color to output for each pixel/ray\n\t\n\t// Raymarching\n\tvec4 p = raymarch(ro, rd); // p.xyz = Position along the ray distance from origin where intersect happens\n\tfloat d = p.w; // p.w = Total distance traveled\n\t\n\t// Coloring\n\tfloat depthScale = 0.01;\n\tvec3 ZBuffer = vec3(d * depthScale); // Color based on distance (Z-Depth Buffer)\n\tvec3 ZBuffer_Invert = vec3(1.0) - ZBuffer;\n\t\n\tcol = pal(p.y * 0.1 + 0.4);\n\tcol *= ZBuffer_Invert * 2.0;\n\t\n\t// Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}