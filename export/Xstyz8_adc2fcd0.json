{"ver":"0.1","info":{"id":"Xstyz8","date":"1517955355","viewed":142,"name":"spindle of death","username":"fivertrial","description":"Finished","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define Epsilon 0.0001\n\n// rotation\nvec2 r(vec2 v, float y){\n    return cos(y)*v + sin(y)*vec2(-v.y, v.x);\n}\n\nfloat sdSphere(vec3 p, float s){\n  return length(p)-s;\n}\n\n//Torus - signed - exact\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 smin(vec2 a, vec2 b){\n\tif(a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\nvec2 map( vec3 p ){  \n    //p.xy = r(p.xy, PI*0.5);\n    //p.xz = r(p.xz, PI*0.5);\n    float dt = max(0.0, fract(iTime*0.5)*4.0-3.0) + floor(iTime*0.5);\n    p.yz = r(p.yz, dt*PI*0.5);\n    vec3 q = p;\n    q.xy = r(q.xy, PI*0.5);\n    vec2 d = vec2(100.0, 10.0);\n    for (int i = 0; i < 8; i++){\n    \tq.yz = r(q.yz, PI/8.0*float(i));\n        d = smin(d, vec2(sdTorus(q, vec2(6.0, 0.05)), 0.0));\n    }\n    for (int i = 0; i < 8; i++){\n        float t = PI*iTime*1.25 + 0.125*PI*float(i);\n\t\tq = p;\n        q.xz = r(q.xz, 0.125*PI*float(i));\n        q.yz -= 6.0 * vec2(cos(t), sin(t));\n    \td = smin(d, vec2(sdSphere(q, 0.35), 1.0));\n    }\n    return d;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 colorize(float index){\n    // Black\n    if (index == 0.0)\n        return vec3(0.1, 0.1, 0.1);\n    // Light yellow\n    if (index == 1.0)\n        return vec3(1.0,1.0,0.9);\n    // Brown\n    if (index == 2.0)\n        return vec3(0.54, 0.27, 0.075);\n    // Green\n    if (index == 3.0)\n        return vec3(0.5, 0.8, 0.6);\n    // Dark yellow\n    if (index == 4.0)\n        return vec3(0.3, 0.3, 0);\n    // Red\n    if (index == 5.0)\n        return vec3(1.0, 0.2, 0.3);\n    // Pink\n    if (index == 6.0)\n        return vec3(1.0, 0.78, 0.8);\n    // White\n    if (index == 9.0)\n        return vec3(0.95, 0.95, 0.95);\n    \n    return vec3(index / 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3((fragCoord.xy / iResolution.xy - 0.5), 10.0);\n    //float vignette = 1.0 - length(q.xy);\n    p.x *= iResolution.x / iResolution.y;\n    p.xy *= 15.0;\n    p.z += 20.0;\n    //q.y -= 0.25;\n    vec3 q = vec3(0.0, 0.0, -1.0);\n    fragColor = vec4(1.0, 0.5, 0.0, 1.0);\n    q = normalize(q);\n    //q.xz = r(q.xz, u_Time * 0.1);\n    //p.y += 1.25;\n    //p.x -= 1.3;\n    //p.z -= 0.5;\n\n    float t = 0.0;\n    // d.x: distance; d.y: colorize\n    vec2 d = vec2(0.0);\n    const float maxSteps = 256.0;\n    // Ray Marching\n    for (float tt = 0.0; tt < maxSteps; ++tt){\n        d = map(p + q*t);\n        t += d.x*0.45;\n        if(!(t<=50.0) || d.x <= Epsilon)\n            break;\n    }\n\n    vec3 fog = vec3(0.7, 0.75, 0.8);\n    vec3 color = fog;\n\n    vec3 ldir = normalize(vec3(1.0, 0.75, -1.0));\n    vec3 hit = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    float fao = 1.0;\n    // inside view distance\n    if (t <= 50.0){\n        hit = p + q*t;\n\n        vec3 light = colorize(d.y);\n        // rim\n        color = min(vec3(1.0), light);\n    }\n    // contrast\n    color = smoothstep(0.0, 1.0, color); \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}