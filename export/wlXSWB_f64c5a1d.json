{"ver":"0.1","info":{"id":"wlXSWB","date":"1576591957","viewed":233,"name":"Ray Marching Test - Aethersong","username":"Aethersong","description":"Raymarching test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ray","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References\n// Ray-Marching, SDFs: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// Perspective Matrix (info on fov calculation): https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n// Ray-Marching, Shadows: https://www.shadertoy.com/view/MdBfRK\n// SDFs: https://iquilezles.org/articles/distfunctions\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nstruct SceneOutput{\n float dist;\n vec3 color;\n};\n\n// Sphere Signed Distance Function\nfloat SphereSDF(vec3 samplePoint, vec3 spherePos, float radius){\n  return length(samplePoint - spherePos) - radius;\n}\n\nfloat CubeSDF(vec3 samplePoint, vec3 cubeCenter, vec3 halfWidths){\n\tvec3 d = abs(samplePoint - cubeCenter) - halfWidths;\n    \n    // Assuming SamplePoint is inside the cube, how far is it from the surface?\n    // Result will be negative or zero\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming SamplePoint is outside the cube, how far is it from the surface?\n    // Result will be positive or zero\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat RoundedCubeSDF(vec3 p, vec3 cubeCenter, vec3 halfWidths, float radius){\n\tvec3 d = abs(p - cubeCenter) - halfWidths;\n    return length(max(d, 0.0)) - radius + min(max(d.x,max(d.y,d.z)), 0.0);\n}\n\n\n// Scene Signed Distance Function\nSceneOutput SceneSDF(vec3 samplePoint){\n    SceneOutput sceneOut;\n    sceneOut.dist = MAX_DIST;\n    sceneOut.color = vec3(0.0, 0.0, 0.0);\n\tfloat sdfDist = MAX_DIST;\n    \n    // Sphere 1\n    sdfDist = SphereSDF(samplePoint, vec3(0.0, 2.0 + sin(iTime * 0.7) * 2.0, 0.0), 1.0);\n    \n    if(sdfDist < sceneOut.dist){\n        sceneOut.dist = sdfDist;\n        sceneOut.color = vec3(1.0, 0.0, 0.0);\n        \n    }\n    \n    // Sphere 2\n    sdfDist = SphereSDF(samplePoint, vec3(4.0, 2.0, 4.0), 0.25);\n    \n    if(sdfDist < sceneOut.dist){\n        sceneOut.dist = sdfDist;\n        sceneOut.color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Cube 1\n    sdfDist = RoundedCubeSDF(samplePoint, vec3(-3.0, 1.0, 2.0), vec3(0.5, 1.0, 0.75), 0.5);\n    if(sdfDist < sceneOut.dist){\n        sceneOut.dist = sdfDist;\n        sceneOut.color = vec3(0.5, 0.5, 1.0);\n    }\n    \n    // Cube 2, Floor\n    sdfDist = CubeSDF(samplePoint, vec3(0.0, -1.0, 0.0), vec3(10.0, 0.05, 10.0));\n    if(sdfDist < sceneOut.dist){\n        sceneOut.dist = sdfDist;\n        sceneOut.color = vec3(1.0, 1.0, 1.0);\n    }\n    \n\n    return sceneOut;\n}\n\n// Shortest distance from eyepoint to the scene surfance along marching direction.\n// eye: the eye point, acting as the origin of the ray\n// marchingDir: the normalized direction to march ray\n// start: the starting distanc away from the eye\n// end: the max distance away from the eye to march before stopping\nSceneOutput ShortestDistanceToSurface(vec3 eye, vec3 marchingDir, float start, float end){\n    float depth = start;\n    SceneOutput sceneOut;\n    for(int i =0; i < MAX_MARCHING_STEPS; i++){\n      \tsceneOut = SceneSDF(eye + depth * marchingDir);\n        if(sceneOut.dist < EPSILON){\n            sceneOut.dist = depth;\n            return sceneOut;\n        }\n        depth += sceneOut.dist;\n        if(depth >= end){\n         sceneOut.dist = end;\n         sceneOut.color = vec3(0.0, 0.0, 0.0);\n         return sceneOut;   \n        }\n    }\n    sceneOut.dist = end;\n    sceneOut.color = vec3(0.0, 0.0, 0.0);\n    return sceneOut;  \n}\n\nfloat ShadowMarch(vec3 pos, vec3 light){\n\tvec3 ray = normalize(light - pos);\t\t// to Light vector\n\tfloat e = length(light - pos);\t\t\t// distance from pos to light\n\tfloat t = 0.02;\t\t\t\t\t\t\t// distance moved from pos(start away from surface)\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n    \tfloat h = SceneSDF(pos+ray*t).dist;\n        if(h < EPSILON){\n        \treturn 0.0;\t// hit something, shadow   \n        }\n        if(t>= e){\n        \tbreak;\t\t// returned to light, no hit   \n        }\n        \n        t += h;\t\t\t// ray march forward\n    }\n    \n    return 1.0;\t\t\t// Didnt hit anything, lit\n}\n\n// Estimate Normal through Gradient\nvec3 EstimateNormal(vec3 p) {\n    float sceneDist = SceneSDF(p).dist;\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneDist,\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneDist,\n        SceneSDF(vec3(p.x, p.y, p.z + EPSILON)).dist - sceneDist));\n}\n\n// Return the normalized direction to march in from the eye point for a single pixel.\n// fov: field of view in degrees\n// size: resolution of the output image\n// fragCoord: the x,y coordinate of the pixel in the output image\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord){\n    // FoV Calculation from Perspective Proj Matrix?\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) * 0.5);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 LookAtRH(vec3 eye, vec3 target, vec3 up){\n    // Based on gluLookAt man page\n    vec3 f = normalize(target - eye); \t\t// Forward Orientation\n    vec3 s = normalize(cross(f, up)); \t\t// Right Orientation\n    vec3 u = cross(s, f);\t\t\t\t\t// Up Orientation\n    \n    // Create View Matrix from Camera Orientation Vectors\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// fragCoord: input variable that contains the window relative coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 dir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(20.0 * cos(iTime * 0.5), 5.0, 20.0 * sin(iTime * 0.5));\n    mat4 viewMtx = LookAtRH(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 viewDir = (viewMtx * vec4(dir, 0.0)).xyz;\n    SceneOutput sceneOutput= ShortestDistanceToSurface(eye, viewDir, MIN_DIST, MAX_DIST);\n    float dist = sceneOutput.dist;\n    \n    if(dist > MAX_DIST - EPSILON){\n    \t// Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    // Position and Normal\n    vec3 p = eye + dist * viewDir;    // Position\n    vec3 N = EstimateNormal(p);       // Normal\n    vec3 toEye = normalize(eye - p);  // To Eye(View)\n    \n    // Object Properties\n    vec3 objectColor = sceneOutput.color;\n    vec3 objectSpecColor = vec3(1.0, 1.0, 1.0) * 0.5;\n    float materialShininess = 16.0;\n    \n    // Light 1\n    float ambientStrength = 0.2;\n    vec3 lightColor = vec3(1.0, 1.0, 1.0) * 0.8;\n    vec3 lightPos = vec3(0.0, 12.0, 6.0);\n    vec3 L = normalize(lightPos - p);  // to Light Vector\n    \n    // Light 1 Calculation\n    float shadow = ShadowMarch(p, lightPos);\n    vec3 ambient = ambientStrength * lightColor * objectColor; // Ambient\n    \n    float dotLN = max(0.0, dot(N, L));\n    vec3 diffuse = dotLN * lightColor * objectColor; // Diffuse\n    \n    vec3 R = normalize(reflect(-L,N)); // Reflection  \n    float dotRV = max(0.0, dot(toEye, R));\n    float specularStrength = pow(dotRV, materialShininess);\n    vec3 specular = specularStrength * objectSpecColor * lightColor;\n\n    \n    fragColor = vec4(ambient + (diffuse + specular) * shadow, 1.0);\n}","name":"Image","description":"","type":"image"}]}