{"ver":"0.1","info":{"id":"NsyXz3","date":"1635009825","viewed":206,"name":"Disk crowd","username":"kastorp","description":".\n","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","flocking"],"hasliked":0,"parentid":"ssK3z1","parentname":"Worm Soup"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Disk Crowd by Kastorp\n//--------------------------------------\n\nGETTERS\nvec2 mmin( vec2 a, vec2 b) {return a.x<b.x?a:b;}\nvec2 hit;\nfloat map(vec3 p,bool bb){\n\n    hit=vec2( sPlane(p,vec3(0,1,0),0.0),0.);     \n    float d =  p.y-1.;    \n    if( d>.1&&bb) hit=mmin(hit,vec2(  d,3.));\n    else {\n        \n        float z=3.*RADIUS;\n        ivec4 nb = getClosest(ivec2(p.xz*z +size/2.)); \n        for(int i=0;i<3;i++){\n            \n            //if(bb &&i>1 ) break;\n            vec2 pos0 = getParticle(nb[i]).xy/z -size/z/2.;        \n            vec3 pos= vec3(pos0.x,.4,pos0.y);\n            float sh=dot(sign(vec2(i2xy(nb[i]).xy- N/2)),vec2(.5,1.))+2.5;\n\n            d= sh>3.?sSphere(p -pos,.4):\n               sh>2.?smin(sTorus(p -pos-vec3(0,-.2,0),vec2(.25,.17)),sTorus(p -pos-vec3(0,0,0),vec2(.25,.12)),.05):\n               sh>1.?sSub(-.05+sBox(p -pos-vec3(0,.5,0),vec3(.16)),-.05+sBox(p -pos,vec3(.32)),.05):\n               smin(-.03+opExtrussion(p-vec3(0,.4,0),length(p.xz-pos.xz)-.37,.35),-.03+opExtrussion(p-vec3(0,.2,0.),length(p.xz-pos.xz)-.2,.8),.05);\n            hit=mmin(hit,vec2( d,sh));\n        }\n    }\n    return hit.x;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\tfloat d = .0;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p,true);\n\t\tif (abs(h) < .0015)\n\t\t\tbreak;\n\t\td += h;\n        if(d>500.) break;\n\t}\n    return d;\n}\n\nvec3 normal(vec3 p, float t) {\n\tfloat h = .002 * t;\n\tvec3 n = vec3(0);    \n\tfor (int i = ZERO; i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h,false);\n\t}\n\treturn normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{  \n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ,true);\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );  \n}\n\n//bugged, need to evaluate secondary shape\nfloat ao(vec3 p, vec3 n, float h) {return map(p + h * n,false) / h;}\n\nvec3 lights(vec3 p,vec3 dif, vec3 rd, float d) {    \n\tvec3  ld = normalize(vec3(2.,7.,2.) - p), \n          n = normal(p, d),\n          pp= p+.001*n;    \n    dif *= max(0., .5 + .5 * dot(ld, n));\t\n\tfloat ao =.1 + .9 * dot(vec3(ao(p, n, .05), ao(p, n, .15), ao(p, n, .3)), vec3(.2, .3, .5)),\t      \n\t      spe = pow(max(0.,dot(reflect(rd,n),ld)),40.),\n\t      fre = pow(abs(.7+dot(rd,n)),3.),\n          sh=softshadow(pp, ld,.01,5.4,25.);   \n\treturn mix(.7, 1., fre) * ((dif*sh *.9+.1)* ao + spe) * vec3(1.);//* exp(-smoothstep(25.,26.,d ));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t  \n\tvec3 ro =vec3(cos(iMouse.x/R.x*3.14)*2., iMouse.z>0.? 2.1+iMouse.y/R.y*20.:8. , sin(iMouse.x/R.x*3.14)*2.);\t\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n    vec3 rd = rayDir(ro, vec3(0,1,0), uv);\n        \n    float d=march(ro,rd);     \n    vec3 p=ro+rd*d; \n    vec3 col= hit.y>3.?vec3(1,0,0):\n              hit.y>2.?vec3(1,1,0): \n              hit.y>1.?vec3(0,.4,0): \n              hit.y>0.?vec3(0,0,1): \n              vec3(1);    \n         col=lights(p, col,rd, d) ;\n   \n\tfragColor = vec4(pow(col, vec3(.75)), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//configurable settings:\n#define NP 900. //number of particles,  must be <=  (R.x)^2\n#define NGH 150 // number of ghosts scanned each frame\n#define dt 3. // time interval;  \n#define R iResolution\n#define RADIUS (5. *min(1.,R.x/640.  ))//average dist\n#define MAXSIZE 400. //max grid size\n//-----------------------\n#define ZERO  min(iFrame,0)\n#define N ivec2(int(sqrt(NP)),int(sqrt(NP)))\n#define size min(vec2(MAXSIZE*R.x/R.y,MAXSIZE),vec2(R.xy))\n#define ZOOM (R.y/size.y)\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n//------------------------\nconst int tot_n = N.x*N.y;\nivec2 i2xy(int id) {return ivec2(id%N.x, id/N.x);}\nint xy2i(ivec2 p){ return p.x + p.y*N.x;}\n\n//------GETTERS----------\n#define GETTERS \\\nivec4 getClosest(ivec2 p){ return floatBitsToInt(texel(iChannel2, p));} \\\nivec4 getNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nbool ghost; \\\nvec4 getParticle(int id){ vec4 p= texel(iChannel0, i2xy(id));ghost=min(p.x,p.y)<0.;return vec4(abs(p.xy),p.zw); }\n\n//--Iq SDF----------------\nfloat sPlane( vec3 p, vec3 n, float h ){ return dot(p,n) + h; }\nfloat sBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat sSphere( in vec3 p,  float ra ) { return length(p)-ra;}\nfloat sCone( vec3 p, vec2 c, float h ){ float q = length(p.xz);return max(dot(c.xy,vec2(q,p.y)),-h-p.y);}\nfloat opExtrussion( in vec3 p, in float sdf, in float h ) { vec2 w = vec2( sdf, abs(p.y) - h );return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\nfloat sTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat smin( float d1, float d2, float k ){float h = max(k-abs(d1-d2),0.0);return min(d1, d2) - h*h*0.25/k;}\nfloat sSub( float d1, float d2, float k ){ float h = max(k-abs(-d1-d2),0.0);return max(-d1, d2) + h*h*0.25/k;}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle physics\n\nGETTERS\n\nint cid;\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0);\n    \n   \tvec4 p1 = getParticle(pid);\n    float d = distance(p1.xy,p0.xy);       \n    float fd =   0.8/(1.+d/RADIUS) - 4.*exp(-d/RADIUS);   \n    vec2 flocking_force =(p1.zw - p0.zw)/(1.+7.*d/RADIUS);   \n    vec2 interaction = normalize(p1.xy-p0.xy)* min(0.01,fd);\n    return flocking_force*0.1 +  interaction*0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x >= N.x || p.y >= N.y) discard;\n    else\n    {\n        pos = floor(pos); \n        //this pixel value\n        U = texel(iChannel0, pos);\n        U.xy=abs(U.xy);\n        int id = xy2i(p);\n        cid = id;\n        \n        //initialize\n        if(iFrame<10 || U==vec4(0))\n        {\n            U.xy = size*vec2(p)/vec2(N);\n\t\t\tU.zw = vec2(0);\n      \t\treturn;\n        }\n           \t\t \t  \n        //flocking force \n        ivec4 cp = getNeighbor(id);  \n        vec2 F = (Fv(U, cp.x) +Fv(U, cp.y) + Fv(U, cp.z) +Fv(U, cp.w));\n        U.zw += (0.5*F)*dt;\n        \n        //random force field\n         U.zw +=((p.y<1)  ? .005 :.002  )*dt* ( -2. * texture(iChannel3, 0.6*U.xy/size).xy + 1.);\n        \n        //position\n        U.xy += U.zw*dt;\n        \n        //border conditions      \n        if(size.x - U.x < RADIUS*2.) { U.z = -abs(U.z); U.x = size.x - RADIUS*2.;}\n        if(U.x < RADIUS*2.) {U.z = abs(U.z);U.x = RADIUS*2.;}\n        if(size.y - U.y < RADIUS*2.) {U.w = -abs(U.w); U.y = size.y - RADIUS*2.;}\n        if(U.y < RADIUS*2.) {U.w = abs(U.w); U.y = RADIUS*2.;}             \n        U.xy =fract(U.xy/size)*size;  \n        \n        //track ghosts\n        bool ghost=true;\n        ivec4 nb = getClosest(ivec2(U.xy));\n        for(int i = 0; i<4; i++)if(nb[i]==id) {ghost=false; break;}\n        if(ghost) U.xy=-U.xy;        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particle neighbors \n\nGETTERS\n\n//sorting closest 4 particles\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y)){ if(d.x > dtemp) {d.x = dtemp;u.x = utemp; }}\n    else if(dx.x < -abs(dx.y)) { if(d.y > dtemp) {d.y = dtemp;u.y = utemp;}}\n    else if(dx.y > abs(dx.x)){ if(d.z > dtemp) {d.z = dtemp;u.z = utemp;} }\n    else if(d.w > dtemp) {d.w = dtemp;u.w = utemp;}\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = 0; j < 4; j++) sort(nb[j]);\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);     \n    u = ivec4(-1); d = vec4(1e10);    \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < NGH; i++)\n    {\n        //sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort  \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id);\n        if(ghost) sort(id); //random sort \n    }\n    \n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)sort(nc[i]); \n    \n    ivec4 nb = getNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n        ivec4 nbb = getNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++) sortneighbor(nbb[j]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))u = ivec4(0);\n\n    U = intBitsToFloat(u);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position (from Michael0884)\n\nGETTERS\n\nivec2 cross_distribution(int i) { return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nfloat particleDistance(int id, vec2 p){ return distance(getParticle(id).xy, p);}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp) { d = vec4(dtemp, d.xyz);u = ivec4(utemp, u.xyz); }\n    else if(d.y > dtemp && dtemp > d.x) { d.yzw = vec3(dtemp, d.yz); u.yzw = ivec3(utemp, u.yz);}\n    else if(d.z > dtemp && dtemp > d.y){d.zw = vec2(dtemp, d.z); u.zw = ivec2(utemp, u.z);}\n    else if(d.w > dtemp && dtemp > d.z){d.w = dtemp;u.w = utemp;}\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = getClosest(p);\n    for(int j = ZERO; j < 4; j++) sort(nb[j]);\n}\n\nvoid sortPart(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = ZERO; j < 4; j++)sort(nb[j]);\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;   \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen   \n    ivec2 p = ivec2(pos);     \n    u = ivec4(-1); d = vec4(1e10);    \n    sortpos(p); \n    \n    for(int i = ZERO; i < 16; i++)\n    {\n        ivec2 p2 =p+cross_distribution(i);        \n        sortpos(p2); \n    }\n\n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n        \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}