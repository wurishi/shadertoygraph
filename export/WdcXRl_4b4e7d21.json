{"ver":"0.1","info":{"id":"WdcXRl","date":"1572735530","viewed":390,"name":"Art of reflections","username":"jaszunio15","description":"I was learning how to create depth of field effect. Just a static image. \nUse SPACE to reset. You can play with parameters in Common tab.\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)\n","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["reflection","raymarch","dof","balls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 col = vec4(buffer.rgb / buffer.a, 1.0);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float terrainHeight(vec3 point)\n{\n \tfloat height = sin(point.x * HEIGHT_DIFF_DENSITY);\n    height += cos(point.z * HEIGHT_DIFF_DENSITY);\n    \n    return height * HEIGHT_DIFFERENCE;\n}\n\nfloat objectSDF(vec3 point)\n{\n    point.y += terrainHeight(point);\n    \n \tfloat plane = planeSDF(point);\n    float sphereGrid = sphereGridSDF(point, 0.2);\n    \n    return addObjects(plane, sphereGrid);\n}\n\n\nvec3 lensPlanePoint(vec2 fragCoord)\n{\n    vec2 shift = hash21(float(iFrame)) + hash22(fragCoord * 0.01 + float(iFrame) * 0.01) * 0.1;\n\n    return vec3(shift.x, shift.y, 0.0) * LENS_SIZE;\n}\n\nvec3 targetPlanePoint(vec2 fragCoord)\n{\n    vec2 shift = hash21(float(iFrame + 20)) + hash22(fragCoord * 0.01 + float(iFrame + 15) * 0.01) * 0.1;\n \tvec2 uv = (2.0 * (fragCoord + shift) - iResolution.xy) / iResolution.x;   \n    return vec3(uv.x, uv.y, 1.0) * FOCUS_PLANE_DISTANCE;  \n}\n\nvec3 normalSDF(vec3 point)\n{\n\tfloat rootSDF = objectSDF(point);\n    vec3 normal = vec3(0.0);\n    \n    normal.x = objectSDF(point + vec3(1.0, 0.0, 0.0) * EPS) - rootSDF;\n    normal.y = objectSDF(point + vec3(0.0, 1.0, 0.0) * EPS) - rootSDF;\n    normal.z = objectSDF(point + vec3(0.0, 0.0, 1.0) * EPS) - rootSDF;\n    \n    return normalize(normal);\n}\n\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n \trayDirection = normalize(rayDirection);\n    \n    for (int i = 0; i < RAYMARCH_ITERATIONS; i++)\n    {\n\t\tfloat sdf = objectSDF(rayOrigin);\n        rayOrigin += rayDirection * sdf * 0.9;\n    }\n    \n    return rayOrigin;\n}\n\nfloat shadowMarch(vec3 surfacePoint, vec3 lightDirection)\n{\n    vec3 point = surfacePoint + normalSDF(surfacePoint) * 0.001;\n    float maxDot = -999.0;\n    float sdf = 0.0;\n \tfor (int i = 0; i < SHADOWMARCH_ITERATIONS; i++)\n    {\n     \tsdf = objectSDF(point);\n        vec3 normal = normalSDF(point);\n        vec2 toPoint = vec2(0.0, distance(surfacePoint, point));\n        vec2 toSurface = toPoint + vec2(sdf, 0.0);\n        maxDot = max(maxDot, clamp(dot(normalize(toPoint), normalize(toSurface)), 0.0, 1.0));\n      \n        \n        point += lightDirection * sdf * 0.9;\n    }\n    \n    float shadow = smoothstep(0.00, 0.03, 1.0 - maxDot);\n    if (sdf < 0.01) shadow = 0.0;\n    return shadow;\n}\n\nfloat calculateFog(vec3 cameraCenter, vec3 hitPoint)\n{\n \treturn smoothstep(FOG_DISTANCE, 0.0, distance(cameraCenter, hitPoint));   \n}\n\nfloat calculateLight(vec3 hitPoint, vec3 rayDirection, vec3 lightDirection)\n{\n \tvec3 normal = normalSDF(hitPoint);\n    rayDirection = normalize(rayDirection);\n    \n    float diffuse = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    vec3 halfWay = normalize(-rayDirection + lightDirection);\n    float specular = pow(clamp(dot(normal, halfWay), 0.0, 1.0), 256.0);\n    float shadow = shadowMarch(hitPoint, lightDirection);\n    \n    return (diffuse * (1.0 - SPECULAR_LIGHT) + specular * SPECULAR_LIGHT) * shadow;\n}\n\nvec4 calculateSky(vec3 rayDirection)\n{\n \trayDirection = normalize(rayDirection);\n    float bottomTop = smoothstep(-1.0, 1.0, rayDirection.y);\n    vec4 col = mix(BOTTOM_SKY_COLOR, TOP_SKY_COLOR, bottomTop);\n    float sun = pow(clamp(dot(rayDirection, LIGHT_DIRECTION), 0.0, 1.0), 32.0);\n    \n    return col + sun;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraCenter = CAMERA_CENTER;\n    vec3 cameraAngles = CAMERA_ANGLES;\n    \n    cameraCenter.y -= terrainHeight(cameraCenter);\n    mat3x3 cameraRotation = rotationMatrix(cameraAngles);\n    \n    vec3 rayOrigin = lensPlanePoint(fragCoord) * cameraRotation - cameraCenter;\n    vec3 rayDirection = targetPlanePoint(fragCoord) * cameraRotation - rayOrigin;\n    \n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection);\n    vec3 firstHitPoint = hitPoint;\n    vec3 firstRayDirection = rayDirection;\n    \n    float light = sqrt(calculateLight(hitPoint, rayDirection, LIGHT_DIRECTION));\n \tfloat fog = calculateFog(cameraCenter, hitPoint);\n    vec4 sky = calculateSky(rayDirection);\n    vec4 col = vec4(light);\n \t\n   \n    //reflections\n    float reflectionStrength = REFLECTION_STRENGTH;\n    for (int i = 0; i < REFLECTION_ITERATIONS; i++)\n    {\n        vec3 normal = normalSDF(hitPoint);\n        rayDirection = normalize(reflect(normalize(rayDirection), normal) + (hash31(float(iFrame) * 0.01) - 0.5) * REFLECTION_RANDOMIZE);\n        vec3 previousHitPoint = hitPoint;\n        hitPoint = rayMarch(hitPoint + normal * 0.01, rayDirection);\n\n        float reflectionLight = sqrt(calculateLight(hitPoint, rayDirection, LIGHT_DIRECTION));\n        float reflectionFog = calculateFog(previousHitPoint, hitPoint);\n        vec4 reflectionSky = calculateSky(rayDirection);\n        vec4 reflectionCol = mix(reflectionSky, vec4(reflectionLight), reflectionFog);\n        \n        col = mix(col, reflectionCol, reflectionStrength);\n        reflectionStrength *= REFLECTION_STRENGTH;\n    }\n    col += 0.2;\n    \n    col = mix(sky, col, fog);\n    vec4 buffer = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    buffer.rgb += col.rgb;\n    buffer.a += 1.0;\n    \n    fragColor = buffer;\n    \n    if (texture(iChannel1, RESET_KEY).r > 0.5) fragColor = vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Depth of field settings\n#define FOCUS_PLANE_DISTANCE 10.0\n#define LENS_SIZE 0.34\n\n//Quality settings\n#define RAYMARCH_ITERATIONS 120\n#define SHADOWMARCH_ITERATIONS 30\n\n//reflection settings\n#define REFLECTION_ITERATIONS 4\n#define REFLECTION_STRENGTH 0.62\n//#define\tREFLECTION_RANDOMIZE 1.0 //for diffused reflections. \n#define\tREFLECTION_RANDOMIZE 0.6\n#define SPECULAR_LIGHT 0.9\n\n//Light settings\n#define LIGHT_DIRECTION (normalize(vec3(2.0, 1.4, 1.0)))\n#define FOG_DISTANCE 200.0\n#define BOTTOM_SKY_COLOR vec4(0.75, 0.75, 0.9, 1.0)\n#define TOP_SKY_COLOR vec4(1.0, 1.0, 1.1, 1.0)\n\n//Camera settings\n#define CAMERA_CENTER vec3(2.0, 2.5, 0.0)\n#define CAMERA_ANGLES vec3(-0.2, 0.7, 0.0)\n\n//Input settings\n#define RESET_KEY vec2(0.126, 0.0)\n\n//Ball rendering settings\n#define MIN_BALL_SIZE 0.05\n#define MAX_BALL_SIZE 0.5\n#define BALL_SIZE_DISTRIBUTION 1.5\n#define HEIGHT_DIFFERENCE 2.0\n#define HEIGHT_DIFF_DENSITY 0.1\n\n#define EPS 0.0001\n\nfloat hash12(vec2 x)\n{\n\treturn fract(sin(dot(x, vec2(43.25, 53.411))) * 4245.5111);\n}\n\nvec2 hash22(vec2 x)\n{\n\treturn fract(sin(x * mat2x2(43.25, 53.411, 39.41142, 45.48321)) * 4245.5111);\n}\n\n\nvec2 hash21(float x)\n{\n    x *= 0.1691;\n    float dist = sqrt(fract(fract(fract(x * 32.52011) * 532.25141) * 33.141151)) * 0.5;\n    float angle = fract(fract(fract(x * 33.52011) * 60.3141) * 31.121251) * 6.28;\n    return 0.5 +  vec2(dist, 0.0) * mat2x2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nvec3 hash31(float x)\n{\n \treturn fract(sin(x * vec3(32.838412,42.291,43152.214192)) * 5419.2871);\n}\n\nfloat sphereSDF(vec3 point, float radius)\n{\n \treturn length(point) - radius;   \n}\n\nfloat sphereGridSDF(vec3 point, float radius)\n{\n    vec3 rootPoint = floor(point);\n    radius = mix(MIN_BALL_SIZE, MAX_BALL_SIZE, pow(hash12(rootPoint.xz), BALL_SIZE_DISTRIBUTION));\n    rootPoint.y = radius;\n    \n    rootPoint += vec3(0.5, 0.0, 0.5);\n    vec2 shift = (hash22(rootPoint.xz) * 2.0 - 1.0) * (1.0 - radius * 2.0);\n    rootPoint.xz += shift * 0.5;\n    \n    return sphereSDF(point - (rootPoint), radius);\n}\n\nfloat planeSDF(vec3 point)\n{\n \treturn point.y;   \n}\n\nfloat addObjects(float o1, float o2)\n{\n \treturn min(o1, o2);   \n}\n\nmat3x3 rotationMatrix(vec3 angle)\n{\n \treturn mat3x3(cos(angle.z), sin(angle.z), 0.0,\n                 -sin(angle.z), cos(angle.x), 0.0,\n                 0.0, 0.0, 1.0)\n    \n    \t\t* mat3x3(1.0, 0.0, 0.0,\n                    0.0, cos(angle.x), sin(angle.x),\n                     0.0, -sin(angle.x), cos(angle.x))\n        \n        \t* mat3x3(cos(angle.y), 0.0, sin(angle.y),\n                    0.0, 1.0, 0.0,\n                    -sin(angle.y), 0.0, cos(angle.y));\n}\n\n","name":"Common","description":"","type":"common"}]}