{"ver":"0.1","info":{"id":"WsS3Wd","date":"1550232531","viewed":184,"name":"Dancing Box","username":"uynet","description":"Lets dancing","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nfloat time;\n\nstruct Ray{\n  vec3 orig;\n  vec3 dist;\n};\n\nRay march(Ray ray , float dist){\n  Ray nextRay;\n  nextRay.orig = ray.orig + ray.dist * dist;\n  nextRay.dist = normalize(ray.dist);\n  return nextRay;\n}\n\nvec3 rotX(vec3 v, float a) {\n  a *= 3.141592 / 180.;\n  float c = cos(a);\n  float s = sin(a);\n  return vec3(\n      v.x,\n      v.y * c - v.z * s,\n      v.z * c + v.y * s\n      );\n}\nvec3 rotY(vec3 v, float a) {\n  a *= 3.141592 / 180.;\n  float c = cos(a);\n  float s = sin(a);\n  return vec3(\n      v.x* c - v.z * s,\n      v.y ,\n      v.z * c + v.x * s\n      );\n}\nvec3 rotZ(vec3 v, float a) {\n  a *= 3.141592 / 180.;\n  float c = cos(a);\n  float s = sin(a);\n  return vec3(\n      v.x* c - v.y * s,\n      v.y* c + v.x * s,\n      v.z\n      );\n}\nfloat displacement(vec3 p){\n  float a = 50.;\n  float b = time*0.07;\n  return step(sin(a*p.x + b)*sin(a*p.y + b)*sin(a*p.z + b),0.5);\n}\n\nfloat sdSphere(vec3 p , float r){\n  return length(p)-r;\n}\nfloat sdBox( vec3 p, float b )\n{\n  float a = time;\n  vec3 r = rotZ(rotX(p,a),a*0.6);\n  vec3 q = rotY(r,r.y*600.*sin(time*0.06));\n  /*\n  float c = a*.7;\n  q.y = p.y*cos(c) +-p.z*sin(c);\n  q.z = p.y*sin(c) + p.z*cos(c);\n  */\n  float po = pow(sin(time*0.12),7.)*0.03-0.02;\n  vec3 d = abs(q) - vec3(b-po,po*1.6+1.8*b,b-po);\n  float d1 = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n  float d2 = 0.03*sin(time*0.02)*displacement(q);\n  return d1;\n}\n\nvec3 normalSphere(vec3 p , float t){\n  vec3 n;\n  float eps = 0.00001;\n  vec3 dx = vec3(eps,0,0);\n  vec3 dy = vec3(0,eps,0);\n  vec3 dz = vec3(0,0,eps);\n  n.x = sdSphere(p+dx,t)-sdSphere(p,t);\n  n.y = sdSphere(p+dy,t)-sdSphere(p,t);\n  n.z = sdSphere(p+dz,t)-sdSphere(p,t);\n  n = normalize(n);\n  return n;\n}\n\n\nvec3 normalBox(vec3 p , float t){\n  vec3 n;\n  float eps = 0.001;\n  vec3 dx = vec3(eps,0,0);\n  vec3 dy = vec3(0,eps,0);\n  vec3 dz = vec3(0,0,eps);\n\n  n.x = sdBox(p+dx,t)-sdBox(p-dx,t);\n  n.y = sdBox(p+dy,t)-sdBox(p-dy,t);\n  n.z = sdBox(p+dz,t)-sdBox(p-dz,t);\n  n = normalize(n);\n  return n;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec3 q = p;\n  float a = 1.;\n  q.y = p.y*cos(a) - p.z*sin(a);\n  q.z = p.y*sin(a) + p.z*cos(a);\n  //q.z = p.x*sin(a) + p.y*cos(a);\n  vec2 s = vec2(length(q.xz)-t.x,q.y);\n  return length(s)-t.y;\n}\n\nvec3 normalTorus(vec3 p , vec2 t){\n  vec3 n;\n  float eps = 0.001;\n  vec3 dx = vec3(eps,0,0);\n  vec3 dy = vec3(0,eps,0);\n  vec3 dz = vec3(0,0,eps);\n  n.x = sdTorus(p+dx,t)-sdTorus(p,t);\n  n.y = sdTorus(p+dy,t)-sdTorus(p,t);\n  n.z = sdTorus(p+dz,t)-sdTorus(p,t);\n  n = normalize(n);\n  return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec4 BG = vec4(178./256. , 178./256. , 0.5 ,1);\n    vec2 uv = fragCoord.xy/iResolution.x;\n    uv -= 0.5;\n    time = iTime*60.;\n  fragColor = BG;\n  Ray ray;\n  ray.orig = vec3(0,0,1);\n  ray.dist = normalize(vec3(uv ,- 1));\n\n  float eps = 0.0001;\n  float eps2 = 0.05;\n  int count = 0;\n\n  vec3 light = normalize(vec3(1));\n  vec3 o = vec3(0.,-0.3,-0.2);//center of spere\n  float r = 0.08;\n  float d;\n\n  bool isNearest = false;\n  float nearestDest = d;\n\n  while(count++<150){\n    //d = sdSphere(ray.orig-o,r);\n    d = sdBox(ray.orig-o,r);\n    if(d < nearestDest)nearestDest = d;\n    if(d>5.){\n      if(isNearest){\n        vec3 n = normalBox(ray.orig-o,r);\n        n = normalize(n);\n        float t = iTime;\n        vec3 c1 = vec3(0.);\n        c1=  vec3(sin(t),cos((t-PI/4.)*2.),cos(t));\n        float dif = max(dot(n,light),0.);\n        vec3 c3 = vec3(dif)*c1;\n        //gl_FragColor = vec4(mix(vec4(1),BG, clamp(nearestDest*30.,0.,1.)));\n      }\n      break;\n    }\n    if(d<eps2)isNearest = true;\n    if(d<eps){\n      //vec3 n = normalTorus(ray.orig,t);\n      vec3 n = normalBox(ray.orig-o,r);\n      n = normalize(n);\n      float t = time*0.03;\n      float dif = max(dot(n,light),0.);\n      vec3 c1 = vec3(.93,.20,.50);\n      vec3 c2 = vec3(.20,.10,.33);\n      fragColor = vec4(mix(c1,c2,dif),1);\n      break;\n    }\n    ray = march(ray,d);\n  }\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float PI = 3.14159265;\nfloat sq(float t){\n    t = fract(t);\n\tif(t < 0.5)return 0.0;\n    return 1.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat kick(float t){\n     float f = 4.0 *exp(-8.0*t) ;\n    return  sin(f*440.0*t)*exp(-3.0*t) ;\n}\nfloat bass(float t){\n    float f = 1.8;\n    float a = t-0.0;\n    if(a>0.0) return 0.0;\n\treturn sin(f*440.0*t);\n}\nfloat sqbass(float t){\n    float f = 2.6;\n    float a = t-0.0;\n    if(a>0.0) return 0.0;\n\treturn sq(f*440.0*t);\n}\n\n\nfloat hihat(float t){\n\treturn rand(vec2(t)) * exp(-12.0*t);\n}\n\nfloat hihat2(float t){\n\treturn rand(vec2(t)) * exp(-22.0*t);\n}\nfloat compresser(float i , float thr){\n    if(i > thr){\n        float d = i - thr;\n       float r = i / thr ;\n        i *= (r-d);\n    }\n     return i;\n}\nvec2 mainSound( in int samp, float time )\n{\n    float BPM = 137.5;\n    float a =BPM / 60.0;\n    float t = fract(time * a)/a;\n    float t2 =  fract(time * a-0.5)/a;\n    float t4 =  fract(time * a * 4.0)/a /4.0;\n   \n    float o = 0.0;\n    o += kick(t)*0.7;\n    o += bass(t2-0.25)*0.80; \n    //o += sqbass(t2-0.25)*0.80; \n    float his = 0.0;\n    his += hihat2(t) * 0.3;\n    his += hihat(t2) * 0.5;\n    his += hihat2(t4) * 0.2;\n    his *= 0.8;\n    o += his;\n    o = compresser(o , 0.7);\n    o *= 1.0/0.7;\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2(o);\n}\n\n\n","name":"Sound","description":"","type":"sound"}]}