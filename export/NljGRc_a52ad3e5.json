{"ver":"0.1","info":{"id":"NljGRc","date":"1624390287","viewed":186,"name":"Soft Shadows - Andrew","username":"andrew741","description":"Soft shadow and ray tracing. The soft shadows are create using an area light which uses a fibonacci sphere to find uniform points on the outside of the sphere to sample the shadows. The size fo the area light changes based on a sign wave.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","softshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\nfloat RayPlane(vec3 ro, vec3 dir, vec3 p, vec2 s)\n{\n    // front or back\n    float depth = (p.z - ro.z) / dir.z;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.xy + dir.xy * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n    /*\n    // left or right\n    float depth = (p.x - ro.x) / dir.x;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.yz + dir.yz * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n    */\n    // top or bottom\n    /*\n    float depth = (p.y - ro.y) / dir.y;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.xz + dir.xz * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n    */\n}\n\n\nfloat AreaLight(vec3 p, float r, int samples, vec3 ro)\n{\n    // fidning the goldan ratio\n    const float pi = 3.14159;\n    const float phi = pi * (3. - sqrt(5.));\n\n    float x;\n    float y;\n    float z;\n    float yR;\n    float theta;\n    \n    float unHit = 0.;\n    // generating the points on the sphere\n    for (int i = 0; i < samples; i++)\n    {\n        y = 1. - (float(i) / float(samples - 1)) * 2.;\n        yR = sqrt(1. - y * y);\n        theta = phi * float(i);\n\n        x = cos(theta) * yR;\n        z = sin(theta) * yR;\n        // adding the points to the list\n        vec3 pos = vec3(x, y, z) * r + p;\n        vec3 dif = pos - ro;\n        float lp = length(dif);\n        vec3 dir = dif / lp;\n        float rs1 = RaySphere(ro, dir, vec3(0, 0, 6), 2.).x;\n        float rs2 = RaySphere(ro, dir, vec3(0, -20, 0), 20.).x;\n        float rp3 = RayPlane(ro, dir, vec3(1.6, 0.25, 0), vec2(1., 1.));\n        unHit += min(min(rs1, rs2), rp3) > lp ? 1. : 0.;\n    }\n    return unHit / float(samples);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.4, 1));\n    vec3 ro = vec3(-1, 2, -6);\n\n    vec3 col = vec3(0.3, 0.3, rd.y * 0.5 + 0.5);\n\n    vec2 rs1 = RaySphere(ro, rd, vec3(0, 0, 6), 2.);\n    vec2 rs2 = RaySphere(ro, rd, vec3(0, -20, 0), 20.);\n    float rp3 = RayPlane(ro, rd, vec3(1.6, 0.25, 0), vec2(1., 1.));\n    \n    vec2 rs;\n    if (rs1.x < rs2.x && rs1.x < rp3) rs = rs1;\n    else if (rp3 < rs2.x) rs = vec2(rp3, 0.);\n    else rs = rs2;\n    \n    if (rs.x < 500.)\n    {\n        col = vec3(0.8, 0.2, 0.2);\n        float shadow = AreaLight(vec3(sin(iTime * 6.), 4, cos(iTime * 6.) + 6.), sin(iTime) + 1., 750, ro + rd * rs.x - rd * 0.01);\n        col *= shadow * 0.7 + 0.3;\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}