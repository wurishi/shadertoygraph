{"ver":"0.1","info":{"id":"DlSGDh","date":"1673274794","viewed":126,"name":"Plexus Cubes Light","username":"trasnodalua","description":"Lots of particles\n\nCredits to @The_ArtOfCode for the idea!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["particles","universe","plexus"],"hasliked":0,"parentid":"ctj3Wz","parentname":"Plexus Cubes (WIP)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat n21(vec2 i) {\n//dot size and movement\n    //i += fract(i * vec2(223.64, 823.12));\n    i += fract(i * vec2(0.001, 0.1));\n    //i += dot(i, i + 23.14);\n    i += dot(i, i/5.0);\n    return fract(i.x * i.y);\n}\n\nvec2 n22(vec2 i) {\n    float x = n21(i);\n    //return vec2(x, n21(i+x));\n    return vec2(x, n21(i+x));\n}\n\nfloat quads = 0.8;//0.4 line effect, 2.5 mirror effect, 1.1, 0.75\nvec2 getPoint (vec2 id, vec2 offset) {\n//return offset + sin(n22(id + offset) * iTime * 1.0) * 04;\n    float speedLightSpots = 1.7; //divide by higher unumber go avoid movement\n\treturn sin(n22(id + offset) * iTime * speedLightSpots) * quads;\n}\n\nfloat layer (vec2 uv) {\n    float m = 0.0;\n    float t = iTime * 1.0;\n   \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv) - 0.5;\n    \n    vec2 p[9];\n    int i = 0;\n    for (float y = -1.0; y <= 1.0; y++) {\n        for (float x = -1.0; x <= 1.0; x++) {\n        \tp[i++] = getPoint(id, vec2(x,y));\n        }\n    }\n    \n    for (int i = 0; i < 9; i++) {\n    \t//m += drawLine(gv, p[4], p[i]);\n        float sparkle = 0.20 / pow(length(gv - p[i]), 0.8) * 0.02;\n        //change later values for sparkle intensity and duration\n        m += sparkle * abs((sin(t + fract(p[i].x) * 1.8) * 5.4 + 0.1));\n    }\n    \n    //m += drawLine(gv, p[1], p[3]);\n    //m += drawLine(gv, p[1], p[5]);\n    //m += drawLine(gv, p[7], p[3]);\n    //m += drawLine(gv, p[7], p[5]);\n     \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.6 * iResolution.xy) / iResolution.y;\n    //vec3 c = sin(iTime * 2.0 * vec3(.234, .324,.768)) * 0.4 + 0.6;\n    //vec3 c = sin(iTime * 2.0 * vec3(.234, .324,.768)) * 0.4 + 0.1;\n    vec3 c = vec3(1.);\n    vec3 col = vec3(0);\n    float fft = texelFetch(iChannel0, ivec2(76.0, 0.), 0).x / 2.0 + 0.5;\n    //c.y += (uv.y + 0.5);\n    //col += pow(-uv.y + 0.5, 5.0) * fft * c;\n    col += pow(uv.y, 3.0) * fft * c;\n    \n    float m = 0.0;\n    float x = abs(sin(iTime * 0.5));\n    float y = abs(cos(iTime * 0.2));\n    \n    //mat2 rotMat = mat2(x, y, -y, x);\n    //uv *= rotMat/5.;\n    \n    for (float i = 0.0; i <= 1.0; i+= 1.0/2.0) {\n        float z = fract(i + iTime * 0.05);\n        float gridSize = 2.50;\n        float size = mix(15.0, .1, z) * gridSize;\n        float fade = smoothstep(0.0, 1.0,  z) * smoothstep(1.0, 0.9, z);\n        m += layer((size * uv) + i * 1.0 ) * fade;\n    }\n    \n    col += m * c;\n    // Debug\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}