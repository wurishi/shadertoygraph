{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Created by sebastien durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// --------------------------------------------------------\n\n// In classical raytracing, the scene is projected to a 2D plane orthogonal to the viewing direction.\n// In 4D raytracing, the scene is projected to a hyperplane (a 3D space) orthogonal to the viewing direction.\n// The cube in the center of the picture is this hyperplane.\n\n// As in classical raytracing, voxel color is not what is at this location of space\n// but what the observer see when looking through this location of space (far sky or close teserac)\n// As in classical raytracing the pixel/voxel represent the first object intersect by the ray\n\n// A transparence is added to voxels to make the inside of the vision cube visible because\n// in 4D world retina may see all voxels at a time (including inside ones)\n\n// If we cut the cube by a 2D plane we obtain a full picture shaded and understandable \n// see : https://www.shadertoy.com/view/4sjGWw or https://www.shadertoy.com/view/Md2XDV\n\n// The four axis here are the 4 axis of the 4D world, they are orthogonal to eachothers.\n\n// --------------------------------------------------------\n\n\n//#define STEREO \n//#define WITH_SHADOW\n\n\n#define STEP_W 120\n#define RAYMARCHING_ITER 32\n#define DENSITY 1.\n#define SWITCH_OBJECT_TEMPO .12\n#define R_BOUNDING_SPHERE .6\n\nconst vec3  COLOR1 = vec3(.2,.9,1), COLOR2 = vec3(1,.3,.5),  // Colors for w coord\n    \t\tCOLOR_BACK = vec3(.22,.26,.28);    \n\nconst vec2 EPS = vec2(.001, 0.);\n\nconst vec3 \n\tvamb = .8*vec3(.1,.11,.13),\n\tvbac = .4*vec3(.15,.15,.15),\n\tvdif =  1.1*vec3(1.,.9,.7),\n\tvcol1 = vec3(.05,.08,.1);\n\nvec4 vlight = normalize(vec4(-.6, .7, .5, .5));\nfloat Step;\n    \nfloat hash(in float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n \n\n// - Shapes --------------------------------------------------------------\n\nfloat sdPlane(in vec4 p) {\n\treturn p.y;\n}\n\n// 3-sphere\nfloat sdSphere(in vec4 p, in float s) {\n    return length(p)-s;\n}\n\n// tesseract (4d hypercube)\nfloat sdBox(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  return min(max(d.x,max(d.y,max(d.z,d.w))),0.) + length(max(d,0.));\n}\n\nfloat udRoundBox(in vec4 p,in vec4 b,in float r) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// http://eusebeia.dyndns.org/4d/cubinder\nfloat sdCubicalCylinder(in vec4 p, in vec3 rh1h2) {\n\tvec3 d = abs(vec3(length(p.xz), p.y, p.w)) - rh1h2;\n\treturn min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n}\n\n// http://eusebeia.dyndns.org/4d/duocylinder\nfloat sdDuoCylinder(in vec4 p, in vec2 r1r2) {\n  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdCapsule(in vec4 p,in vec4 a,in vec4 b,in float r ){\n\tvec4 pa = p - a, ba = b - a;\n\treturn length( pa - ba*clamp(dot(pa,ba)/dot(ba,ba), 0., 1.) ) - r;\n}\n\n//----------------------------------------------------------------------\nfloat map(in vec4 p) {\n    // The object\n\tfloat d;\n    \t if (Step == 0.) d = sdCubicalCylinder(p, vec3(.325,.4,.3));\n    else if (Step == 2.) d = sdDuoCylinder(p, vec2(.325,.45));\n    else if (Step == 3.) d = sdBox(p, vec4(.2,.25,.35,.35));\n    //else sdSphere(p,.45)\n    else    \t     \t d = max(sdCubicalCylinder(p, vec3(.35,.24,.3)),-sdDuoCylinder(p, vec2(.225,.55)));\n    // The 4 Axes\n\td = min(d, min(min(min(length(p.xyz),\n\t\t\t\t\t\t   length(p.wxy)),\n\t\t\t\t\t\t   length(p.zwx)),\n\t\t\t\t\t\t   length(p.yzw)) - .025);\n   // d = min(d, abs(-pos.x)-.02); // add this for nice effect !  :-)\n    return d;\n}\n\nfloat softshadow(in vec4 ro, in vec4 rd, in float mint) {\n\tfloat h, t=mint, res=1.;\n    for (int i=0; i<16; i++ ) {\n        h = map(ro+rd*t);\n        if ((h)<.1) break;\n        res = min(res, 7.*h/t);\n        t += 0.04;\n    }\n    return clamp(res-.6, 0., 1.);\n}\n\nfloat castRay(in vec4 ro, in vec4 rd, in float mint, in float maxt) {\n\tfloat h=.02, t=mint;\n    for (int i=0; i<RAYMARCHING_ITER; i++) {\n\t\tif(abs(h)<.01||t>=maxt) break;\t\t\n        t += h = map(ro+rd*t);   \n    }\n    return t;\n}\n\nvec4 render(in vec4 rd, in vec4 p) { \n\tfloat d = map(p);\n\tvec4 nor = normalize(vec4(\n\t\tmap((p+EPS.xyyy)),  // map(pos-e.xyyy).x,\n\t\tmap((p+EPS.yxyy)),  // map(pos-e.yxyy).x,\n\t\tmap((p+EPS.yyxy)),  // map(pos-e.yyxy).x,\n\t\tmap((p+EPS.yyyx)))-d);// map(pos-e.yyyx).x\n\tvec3 col = mix(COLOR1, COLOR2, clamp(1.5*(p.w+.3),0.,1.));\n\tfloat amb = clamp( 0.8+0.3*nor.y, 0., 1.),\n\t\t  dif = clamp( dot( nor, vlight ), 0., 1.),\n\t\t  fre = clamp(.6+dot(nor,rd),0.,1.);\n\tfre *= fre;\n#ifdef WITH_SHADOW    \n\tif(dif>.02) dif *= softshadow(p, vlight, .025); \n#endif    \n\treturn vec4(col*(amb*vamb + dif*vdif) + 0.2*fre*(0.5+0.5*col), 1. );\n}\n\n// - return vector perpendicular to the 3 others\nvec4 cross4D(in vec4 u, in vec4 v, in vec4 w) {\n    float a=v.x*w.y-v.y*w.x, b=v.x*w.z-v.z*w.x, c=v.x*w.w-v.w*w.x,\n          d=v.y*w.z-v.z*w.y, e=v.y*w.w-v.w*w.y, f=v.z*w.w-v.w*w.z;\n    return vec4( u.y*f - u.z*e + u.w*d,\n                -u.x*f + u.z*c - u.w*b,\n                 u.x*e - u.y*c + u.w*a,\n                -u.x*d + u.y*b - u.z*a);\n}\n\n// - define base for camera in a 4D space\nmat4 cam4D(in vec4 from, in vec4 to, in vec4 up, in vec4 over) {\n    vec4 d = normalize(to-from),\n         u = normalize(cross4D(up,over, d)),\n         v = normalize(cross4D(over, d, u));\n    return mat4(u,v, cross4D(d,u,v), d);\n}\n\nbool intersectSphere(in vec4 ro, in vec4 rd, in float r, out float dmin, out float dmax) {\n\tfloat b = dot(rd,ro),\n\t\t  d = b*b - dot(ro,ro) + r*r;\n\tif (d < 0.) return false;\n    float edge = sqrt(d);\n\tdmin = -edge -b;\n\tdmax =  edge -b;\n\treturn dmin > 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    Step = mod(floor(SWITCH_OBJECT_TEMPO*(4.+iTime)), 4.);\n        \n\tvec2 mo = iMouse.xy/iResolution.xy,\n\t\t q = fragCoord.xy/iResolution.xy;\n\n    float hs = hash(4.+floor(10.+.2*iTime)),\n\t\t  time = .6*(17.+iTime*hs + 10.2*hash(hs));\n\n\tfloat a = 10.+time*1.3, b = 10.+time*2.1, c = 10.+time*4.1,\n\t\t  c1 = cos(a), s1 = sin(a),\n\t\t  c2 = cos(b), s2 = sin(b),\n          c3 = cos(c), s3 = sin(c);\n    \n\t// Rotation matrix of the object\n    mat4 Rot4 = mat4(c2,  s2*s3,   0, -s2*c3,   \n                \t  0,  c1*c3, -s1,  c1*s3,\n                \t  0,  c3*s1,  c1,  s1*s3,\n                \t s2, -c2*s3,   0,  c2*c3);\n    \n\t// Pos of the eye\n\tvec4 lookat = vec4(0),\n\t\t ro = vec4(3.2*sin(6.*mo.x)*cos(3.*mo.y), 3.2*sin(3.*mo.y), 3.2*cos(6.*mo.x), 0);\n\n// - Volumetric Render ------------------------------------------------ \n\tvec2 uv = vec2(-1. + 2.*fragCoord.xy / iResolution.xy);\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tmat4 base = cam4D(ro, lookat, vec4(1,0,0,0), vec4(0,0,0,1));\n    \n#ifdef STEREO\n\tfloat isCyan =mod(fragCoord.x + mod(fragCoord.y, 2.0),2.0);\n    ro += 1.5*uv.x*base[0]*(isCyan==1. ? 1.:-1.);\n#endif\n         \n\tvec4 rdw = base[2];\n\n\t//-----------------------------------\n\tconst int nbStep = /*(iMouse.w >= 0.) ? STEP_W/2 :*/ STEP_W;\n\tconst float detail = 1.2/float(nbStep),\n\t\t\t\tdensity = DENSITY/float(nbStep);\n\t\t\n\tvec4 p = lookat + base[0]*uv.x + base[1]*uv.y - float(nbStep/2)*detail*rdw;\n    vec3 cback = COLOR_BACK * pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);\n    vec4 col, cSum = vec4(0);\n\n    // This is equivalent to rotate the object (but we do it only one time)\n    p*=Rot4;  rdw*=Rot4; \n\n\tfloat dmin, dmax;\n    if (intersectSphere(p, rdw, R_BOUNDING_SPHERE, dmin, dmax)) {\n\t\tvec4 rd, dw = detail*rdw;\n\t\tfloat t;\n    \n        ro*=Rot4;\n    \tvlight *= Rot4;\n        \n        // Volume ray tracing\n\t\tp += dmin*rdw; //  go close to the sphere\n        int iend = int((dmax-dmin)/detail);\n        \n        for (int i=0; i<STEP_W; i++) {\n            if (i>iend) break;\n            rd = normalize(p-ro);\n            t = castRay(ro,rd,2.5,5.);\n            if(t<5.) {\n                col = render(rd, ro+t*rd);\n                col.a *= density;\n                col.rgb *= col.a; // pre-multiply alpha\n                cSum += col*(1. - cSum.a);\t\n              //  if (cSum.a > .98) break; // exit early if opaque\n            }\n            p += dw; \n        }\n        #ifdef WITH_SHADOW\n        \tcSum = mix(vec4(cback,1),8.2*cSum,cSum.a*1.6);\n        #else\n        \tcSum = mix(vec4(cback,1),5.*cSum,cSum.a*1.4);\n        #endif\n    } else {\n        cSum = vec4(cback,1);\n    }\n    \n#ifdef STEREO\n   \tfloat g = (cSum.r+cSum.g+cSum.b)*.33;\n   \tcSum = (isCyan==1.) ? vec4(0,g,g,1.) : vec4(g,0,0,1.);\n#endif\n        \n    float x = mod(5.+10.*SWITCH_OBJECT_TEMPO*(4.+iTime),10.)-5.,\n    \t  flash =  1.+10.*exp(-abs(x)*20.);\n\tfragColor = flash * cSum;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tX3Rn","date":"1417620339","viewed":863,"name":"4D Ghost","username":"iapafoto","description":"Rewriting 4D objects viewer (still trying to find a good way to represent 4D objects)\n[Mouse available]","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["4d","tesseract","duocylinder","cubicalcylinder"],"hasliked":0,"parentid":"","parentname":""}}