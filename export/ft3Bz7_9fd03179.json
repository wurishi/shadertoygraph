{"ver":"0.1","info":{"id":"ft3Bz7","date":"1662786993","viewed":180,"name":"visualizing lerps","username":"Carandiru","description":"lerp usage, morphing / interpolating between a sin or cos wave.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["mix","lerp","visual"],"hasliked":0,"parentid":"tsGyRD","parentname":"negatives"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// lerp usage, morphing / interpolating between a sin or cos wave.\n\nconst vec3 lerp3 = vec3(1,.2,.376);\nconst vec3 lerp2 = vec3(1,.682,.376);\n\nfloat line(float width, float offset, float magnitude) {\n    float mid = 0.5f + offset;\n    return (smoothstep(mid - width, mid - width + 0.01f, magnitude) - \n            smoothstep(mid + width, mid + width + 0.01f, magnitude));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 color = vec3(0);\n    \n    vec2 samp = textureLod(iChannel0, uv, 0.0f).rg;\n    \n    float c3 = uv.y + samp.x, c2 = uv.y + samp.y;\n    \n    color += lerp3 * line(0.05f, 0.5f, c3);\t\t\t// red = mix\n    color += lerp2 * line(0.05f, 0.5f, c2);\t\t// blue = smoothstep\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat target[2], current[2], last[2];\n\nfloat get(uint index)\n{\n    return(current[index]);\n}\nvoid reset(uint index, float all_)\n{\n    target[index] = current[index] = last[index] = all_;\n}\nvoid set(uint index, float target_)\n{\n    last[index] = current[index];\n    current[index] = target[index];\n    target[index] = target_;\n}\nvoid lerp(uint index, float t)\n{\n    current[index] = mix(last[index], target[index], t);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 samp = textureLod(iChannel0, uv, 0.0f).rg;\n    \n    current[0] = samp.x;\n    current[1] = samp.y;\n    \n    uv = uv * iTime; \t\t\t\t\t\t\t  \n     \n    float t3 = 0.0f;\t\t   \n    float t2 = 0.0f;\n    \n    if (mod(iTime, 4.0f) > 2.0f) {\n        t3 = cos(uv.x + iTime * 0.5f) * 0.5f + 0.5f;\n        t2 = sin(uv.x + iTime * 0.5f) * 0.5f + 0.5f;\n    }\n    else {\n        t3 = sin(uv.x + iTime * 0.5f) * 0.5f + 0.5f;\n        t2 = cos(uv.x + iTime * 0.5f) * 0.5f + 0.5f;\n    }\n    \n    set(0u, t3);\n    set(1u, t2);\n    \n    lerp(0u, iTimeDelta);\n    lerp(1u, iTimeDelta);\n    \n    if (iFrame < 10) {\n        reset(0u, t3);\n        reset(1u, t2);\n    }\n    \n    fragColor = vec4(get(0u), get(1u), 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}