{"ver":"0.1","info":{"id":"4tByDV","date":"1510118263","viewed":291,"name":"Sun burning a Planet","username":"twenkid","description":"Playing with Przemyslaw Zaworski's: https://www.shadertoy.com/view/llscW7 (Thanks!) Added the Sun (the planet may be hidden), planet's \"dance\", \"heating\" patterns, rotation of the planet over Z, parameters, comments. (...) Version 1.0, 8-11-2017","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["burn","sun","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A study/play, based on: \n//https://www.shadertoy.com/view/llscW7\n//Author: Przemyslaw Zaworski, 12.09.2017, version 1.1\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Extended by Todor Arnaudov, who has added:\n// The Sun (by changing the background gradient),\n// Planet's trajectory with some matrices multiplications,\n// \"Burning\" of the \"surface\"; mouse Y now rotates the planet also over the Z axis.\n// The grid is turned off.\n//\n// The \"burn\" pattern could be better synchronized to adjust the interaction, such as:\n// turning red-black exactly on the sides that are turned to the sun and when the planet is approaching it etc.\n//\n// Currently it is \"some changes/play\" with formulas in two variants.\n//\n// Future work: more sync, black background with stars, bump-mapped planet?, clouds?, comets?, asteroids?, moon?,\n// ... correctly rotating around the sun/the planet?\n// ... a watermellon pattern?\n//\n// Version 1.0, 8-11-2017\n\n\n// Comment to hide the planet\n#define PLANET 1;\n\n// Increase for a huge sun, covering the whole screen. 0.1 - 0.3 for a small one, going dark\nconst float sunSize = 0.95; //1.13; //1.39; \n\n\nfloat generate_map = 50.0;\n\nconst int ssaa=4;\n\nmat2 rotation(float x)\n{\n    return mat2(cos(x),-sin(x),sin(x),cos(x));\n}\n\nfloat noise (vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat perlin_a (vec3 n)\n{\n    vec3 x = floor(n * 64.0) * 0.015625;\n    vec3 k = vec3(0.015625, 0.0, 0.0);\n    float a = noise(x);\n    float b = noise(x + k.xyy);\n    float c = noise(x + k.yxy);\n    float d = noise(x + k.xxy);\n    vec3 p = (n - x) * 64.0;\n    float u = mix(a, b, p.x);\n    float v = mix(c, d, p.x);\n    return mix(u,v,p.y);\n}\n\nfloat perlin_b (vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z * 64.0) * 0.015625);\n    vec3 dd = vec3(0.015625, 0.0, 0.0);\n    vec3 p = (n - base) *  64.0;\n    float front = perlin_a(base + dd.yyy);\n    float back = perlin_a(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.1;\n    for (int i = 0; i < 5; i++)\n    {\n        t += perlin_b(n * a) * b;\n        a *= 0.5;\n        b *= 2.0;\n    }\n    return t;\n}\n\nvec3 heightmap (vec3 n)\n{\n\treturn vec3(fbm((5.0 * n) + fbm((5.0 * n) * 3.0 - 1000.0) * 0.05),0,0);\n}\n\nvec3 grid(vec2 p)\n{\n    return vec3(1.0)*smoothstep(0.99,1.0,max(sin((p.x)*32.0),sin((p.y)*32.0)));\n}\n\nfloat sphere(vec3 ro, vec3 rd)\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro)-1.0;\n    float h = b*b-c;\n    return (h<0.0)?-1.0:-b-sqrt(h);\n}\n\nvec3 atlas(vec2 uv)\n{    \n \tfloat color = clamp(vec4(vec3((heightmap(vec3(uv*5.0,generate_map)*0.02)-1.0)),1.0).r,0.0,1.0);\n    return \n    color<0.10 ? vec3(0.77,0.90,0.98):\n    color<0.20 ? vec3(0.82,0.92,0.99):\n    color<0.30 ? vec3(0.91,0.97,0.99):\n    color<0.55 ? vec3(0.62,0.75,0.59):\n    color<0.65 ? vec3(0.86,0.90,0.68):\n    color<0.75 ? vec3(0.99,0.99,0.63):\n    color<0.85 ? vec3(0.99,0.83,0.59):\n    color<0.95 ? vec3(0.98,0.71,0.49):     \n    color<0.99 ? vec3(0.98,0.57,0.47):              \n    vec3(0.79,0.48,0.43); \n}\n\n//ro - ray origin, rd - ray direction, p - polar(spherical) coordinates? over the planet\nvec3 raycast (vec3 ro, vec3 rd, vec2 p)\n{\n    float pattern=abs(cos(iTime/5.0));\n#ifdef PLANET\n    float t = sphere(ro,rd);\n    if (t > 0.0)\n    {\n    \tvec3 d = ro+rd*t;\n        p=vec2(acos(d.y/length(d)), atan(d.z,d.x));  \n                \n        //vec3 ret =  (atlas(p).xyz+grid(p*3.0));\n        vec3 ret =  (atlas(p).xyz); //no grid\n        //ret+=(1.0, 0.0, 0.0);\n        ret+= (vec3(max(min(abs(d.z), abs(d.y))/2., sin(d.z))+abs(sin(iTime/5.0)*2.), -max(d.z, d.y)/2.0, abs(sin(d.z))))/2.; //red ball\n        ret-=vec3(d.y, abs(sin(d.z)), abs(sin(d.y))*2.);\n        float dark = abs(min(cos(iTime), sin(iTime/2.0)))*(dot(ro,rd)*sin(iTime))/6.;\n        //ret-=vec3(min(max(dark, sin(d.z+d.y)), max(cos(d.y), sin(d.z))), dark, dark)*3.;\n        float red = min(max(dark, sin(d.z+d.y)), max(cos(d.y), sin(d.z)));\n        \n        \n        if (pattern>0.5) ret-=vec3(red, red/2., sin(red))*3.;\n        else ret-=abs(vec3(abs(sin(iTime+644533.)/3.), max(abs(sin(d.z)), sin(ro.z)), acos(d.z/length(d))));\n            \n        return ret;\n        \n        //return (atlas(p).xyz+grid(p*3.0));        \n        //return (atlas(p).xyz-grid(p*3.0));    //-grid -->black\n    } \n#endif    \n    //return 1.7-vec3(length(p));\n    return sunSize+0.3*sin(iTime)-vec3(0., max(length(p)-0.5, 0.0)*fbm(rd), length(p)+0.5); // -- red ball\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 c = vec3(0.0);\n    float slow = 4.0; //speed of planet cycling\n    \n\tfor (int m=0;m<ssaa;m++)\n\t{\n\t\tfor (int n=0;n<ssaa;n++)\n\t\t{\n\t\t\tvec2 offset = vec2(float(m),float(n))/float(ssaa)-0.5;\n\t\t\tvec2 p = (fragCoord.xy+offset.xy)/iResolution.xy-0.5;\t\n            p.x*=iResolution.x/iResolution.y;\n            vec2 m = iMouse.xy / iResolution.xy-0.5;\n            m.x *= iResolution.x/iResolution.y;\n            p*= 1.5;\n            vec3 ro = vec3(0.0,0.0,2.4);\n            vec3 rd = normalize(vec3(p,-1.5));\n            mat2 rx = rotation(iTime*0.4+m.x*5.0);\n            ro.xz *= rx; rd.xz *= rx;  \n            //+ mouse Y, vertical rotation\n            mat2 ry = rotation(iTime*0.4+m.y*5.0);\n            ro.yz *=-ry; rd.yz *= -ry;\n            \n            /*\n            mat2 zoom = mat2(vec2(1.0+abs(sin(iTime)), 0),\n                             vec2(0.0, 1.0+vec2(1.0+abs(cos(iTime))))\n                                  );\n            */\n          /*  mat2 zoom = mat2(vec2(1.0+abs(sin(iTime)), 0),\n                             vec2(0.0, 1.0+vec2(1.0+abs(sin(iTime))))\n                                  );\n   */\n            mat2 zoom = mat2(vec2(0.7 + abs(sin(iTime/slow)), 0),\n                             vec2(0.0, 0.7+abs(sin(iTime/slow)))\n                                  );\n            \n             mat3 zoom3 = mat3(vec3(1.0+abs(sin(iTime)), 0, 0),\n                             vec3(0.0, 1.0+abs(sin(iTime)), 0.0),\n                             vec3(0.0, 0.0, 1.0+abs(sin(iTime)))\n                                  );\n            zoom*=zoom*zoom;\n            ro*=zoom3;\n            ro.yz*=zoom;\n            //ro.yz*=zoom;\n                                  \n            \n\t\t\tc+=raycast(ro,rd,p);\n\t\t}\n\t}\n\tc=c/float(ssaa*ssaa);    //gradient - angles, black\n\tfragColor = vec4(c, 1.0);\n} ","name":"Image","description":"","type":"image"}]}