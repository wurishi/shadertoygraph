{"ver":"0.1","info":{"id":"DdfBDs","date":"1689267189","viewed":327,"name":"Bubbles with depth of field blur","username":"kaiavintr","description":"Simple bubbles with no physics simulation.\n\nDepth of field needs to be shallow to match the environment map. You can reduce the blur by setting APERTURE to a lower value.\n\nYou can also increase BUBBLE_DENSITY and MAX_BUBBLE_COUNT to (e.g.) 21 and 2000.","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","reflection","dof","bubbles","hdr","environment","thinfilm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Copyright (C) 2023 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader. You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact the copyright holder with questions or requests regarding\n    licensing, via @KaiaVintr on Twitter or via a comment on this shader.\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/Bubbles\n    \n*/\n\n\nconst vec3 EXTRA_LIGHT_COLOR = vec3(0.9, 0.9, 1);\nconst vec3 EXTRA_LIGHT_DIR = normalize(vec3(1, 3, -2));\n\n#define IR 1.5\n#define R0 0.04\n\n\n#define CUBIC(t, C0, C1, C2, C3) (C0 + (C1 + (C2 + C3*t)*t)*t)\n\n\nvec3 SRGB_TO_LINEAR(vec3 C) {\n    return ((0.30530*C + 0.68217)*C + 0.012523)*C;\n}\n\nvec3 LINEAR_TO_SRGB(vec3 C) {\n    return mix(12.92*C, 1.055*pow(C, vec3(1./2.4)) - 0.055, step(0.0031308, C));\n}\n\n#define SR(C, R, T) smoothstep(C-(R), C+(R), T)\n\nvec3 get_env_extra_light(vec3 V, float r) {\n    if (V.y < 0.) return vec3(0);\n    \n    r /= V.y;\n    \n    float mask;\n    \n    {\n        vec2 p = V.zx / V.y;\n    \n        {\n            vec2 d = vec2(0.06, -1.75) - p;\n            p += 0.25*d * smoothstep(-0.04 ,0., -dot(d, d));\n        }\n\n        float x_left = -0.2845 - 0.0075*p.y;\n        float x_right = 0.28 - 0.005*p.y;\n        \n        float f_left = SR(x_left, r, p.x);\n        float f_split_y = SR(-2.45, 2.*r + 0.1, p.y);\n\n        mask = (f_left - SR(x_right, r, p.x)) * (f_split_y - SR(2.04, 2.*r, p.y));\n        \n        float x_left2 = -0.01132 - 0.014*p.y;\n        float x_right2 = -0.029 - 0.0775*p.y;\n        float r4 = r+0.02;\n        \n        float f_inner_x = SR(x_left2, r4, p.x);\n\n        mask -= (f_inner_x - SR(x_right2, r4, p.x)) * (f_split_y - SR(-1.38, r + 0.05, p.y));\n\n        mask += (f_left - f_inner_x) * (SR(-2.7, 2.*r + 1., p.y) - f_split_y);\n    }\n    \n    if (mask < 0.001) {\n        return vec3(0);\n    } else {\n        float m = dot(V, EXTRA_LIGHT_DIR);\n        float m2 = m*m;\n\n        return mask * (m + (4. + 8.*m2)*m2)*(0.25*EXTRA_LIGHT_COLOR);\n    }\n}\n\nvec3 get_env(vec3 V, float lod_texture, float extra_light_blur) {\n    vec3 c = vec3(0);\n    \n    #if BLACK_BACKGROUND==0\n    c = SRGB_TO_LINEAR(textureLod(iChannel0, V, lod_texture).rgb);\n    #endif\n    \n    return c + get_env_extra_light(V, extra_light_blur);\n}\n\nvec3 transmittance_inner(float c1, float c2, float thickness) {\n    float t1 = 1. / (c1 - c2*cos(4.*PI*IR/620. * thickness));\n    float t2 = 1. / (c1 - c2*cos(4.*PI*IR/580. * thickness));\n    float t3 = 1. / (c1 - c2*cos(4.*PI*IR/540. * thickness));\n    float t4 = 1. / (c1 - c2*cos(4.*PI*IR/500. * thickness));\n    float t5 = 1. / (c1 - c2*cos(4.*PI*IR/460. * thickness));\n\n    float t_rA = 1.1196612*t1 + 0.52973197*t2 + -0.51260775*t3 + -0.35341358*t4 + 0.21662929*t5;\n    float t_gA = -0.10079911*t1 + 0.21283443*t2 + 0.7714012*t3 + 0.30916634*t4 + -0.19268395*t5;\n    float t_bA = 0.03927381*t1 + -0.04024949*t2 + -0.33072285*t3 + -0.25987153*t4 + 1.59140413*t5;\n\n    float t_rB = -0.00048259*t1 + 0.00007486*t2 + 0.00062571*t3 + 0.00029579*t4 + -0.00029626*t5;\n    float t_gB = 0.00007922*t1 + -0.00000462*t2 + -0.00033332*t3 + -0.00011758*t4 + 0.00026071*t5;\n    float t_bB = 0.00005101*t1 + 0.00012158*t2 + 0.00071228*t3 + 0.00032246*t4 + -0.00171112*t5;\n    \n    return thickness*vec3(-0.00020077, 0.00010688, 0.00046554) + (c1-c2)*(vec3(t_rA, t_gA, t_bA) + thickness*vec3(t_rB, t_gB, t_bB));\n}\n\nvec3 transmittance_part1(float a) {\n    float x = 1. - a;\n    \n    float R = R0 + (0.28213775 + (-1.8155226 + (6.22109309 + (-7.98235569 + 4.25102573*x)*x)*x)*x)*(x*x);\n\n    return vec3(1. + R*R, 2.*R, sqrt(1. - 1./(1.5*1.5) * (1. - a*a)));\n}\n\nvec3 transmittance_part2(vec3 part1, float thickness) {\n    return clamp(transmittance_inner(part1.r, part1.g, part1.b*thickness), 0., 1.);\n}\n\nfloat gyroid(vec3 p) {\n    return dot(sin(p), cos(p.yzx));\n}\n\nvec3 gyroid3d(vec3 p) {\n    vec3 a = sin(p) * cos(p.yzx);\n    \n    return a.yxx + a.zzy;\n}\n\nfloat get_extra_light_radius(vec3 pix, vec3 V, mat3 camera) {\n    float ry = 1./V.y;\n    \n    vec4 d = vec4(camera[0].zx - ry * camera[0].y * V.zx,\n                  camera[1].zx - ry * camera[1].y * V.zx);\n\n    return sqrt(dot(d, d) / (dot(pix.xy, pix.xy) + pix.z*pix.z) + 0.02*0.02);\n}\n\nvoid sample_edge_reflect(int max_count, float scale, float b_center, vec3 U, vec3 V, float texture_lod, float extra_light_blur, out vec3 c_front, out vec3 c_back) {\n    float kernel_size = 3. * scale;\n    \n    float mint = b_center - 0.5*kernel_size;\n    float maxt = b_center + 0.5*kernel_size;\n    \n    int count = max_count + min(0, iFrame) - 1;\n    \n    if (maxt > 0.9999995) {\n        maxt = 0.9999995;\n        count += 1;\n    }\n    \n    float b_inc = (1./float(max_count)) * (maxt-mint);\n    float b = b_inc + mint;\n    float u = (b - b_center)/kernel_size + 0.5;\n    float u_inc = b_inc/kernel_size;\n\n    float total_w = 0.;\n    vec3 c1 = vec3(0);\n    vec3 c2 = vec3(0);\n    \n    for (int i = 0; i < count; i++) {\n        float p = 2.*b*b - 1.;\n        float q = sqrt(1. - p*p);\n        \n        float w = u - u*u;\n\n        vec3 R = p*V - q*U;\n        \n        c1 += w * get_env(R, texture_lod, extra_light_blur);\n\n        R = p*V + q*U;\n\n        c2 += w * get_env(R, texture_lod, extra_light_blur);\n        \n        total_w += w;\n        \n        b += b_inc;\n        u += u_inc;\n    }\n    \n    float n = 1./total_w;\n    \n    c_front = n * c1;\n    c_back = n * c2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 V;\n    float pix_scale, bg_extra_light_r, brightness, focus_distance;\n    \n    {\n        vec3 V0 = vec3(fragCoord.xy - 0.5*iResolution.xy, VIEW_ANGLE_FACTOR*iResolution.y);\n        \n        pix_scale = 1./length(V0);\n    \n        mat3 camera = make_camera(iMouse, iResolution);\n\n        V = camera * pix_scale * V0;\n    \n        bg_extra_light_r = get_extra_light_radius(V0, V, camera);\n        \n        brightness = 1. - 0.5*max(0., (camera * vec3(0,0,1)).y);\n        \n        focus_distance = get_focus_distance(camera*vec3(0,0,1));\n    }\n    \n    uvec4 idset = floatBitsToUint(texelFetch(iChannel1, ivec2(floor(fragCoord)) >> BLOCK_SHIFT, 0));\n    \n    uint visit_count;\n    \n    if ((idset.w & 0x80000000u) == 0u) {\n        uvec4 c = idset | (idset >> 1);\n        \n        c |= c >> 2;\n        c |= c >> 4;\n        c |= c >> 8;\n        \n        c = (c & 1u) + ((c >> 16) & 1u);\n        \n        visit_count = c.x + c.y + c.z + c.w;\n    } else {\n        visit_count = uint(min(MAX_BUBBLE_COUNT, int(7u + (((idset.w >> 16) - idset.w) & 0x7fffu))));\n    }\n    \n    uint id_lower_bound = uint(max(0, int(floor(TIME / BUBBLE_ID_TIME_INCREMENT)) - (MAX_BUBBLE_COUNT + 1)));\n    \n    float dist1=1e20, dist2=1e20, dist3=1e20;\n    vec3 color1=vec3(0), transm1=vec3(1);\n    vec3 color2=vec3(0), transm2=vec3(1);\n    vec3 color3=vec3(0), transm3=vec3(1);\n    \n    float extra_light_blur_base = 0.03 * max(450. / iResolution.y, 1.);\n    \n    for (uint i = 0u; i < visit_count; i++) {\n        uint id;\n        \n        if (i < 7u || (idset.w & 0x80000000u) == 0u) {\n            if (i < 4u) {\n                id = i <= 1u ? idset.x : idset.y;\n            } else {\n                id = i <= 5u ? idset.z : idset.w;\n            }\n            \n            id = (i & 1u) == 0u ? id : (id >> 16);\n        } else {\n            id = idset.w + i - 6u;\n        }\n        \n        id = (id & 0x7fffu) + id_lower_bound;\n        \n        float fid = float(id);\n        \n        float offset_t = -TIME + BUBBLE_ID_TIME_INCREMENT*fid;\n        \n        float x = PATH_CENTER.x + SPEED_X*offset_t;\n        \n        float radius = get_radius(fid);\n        \n        uint hash;\n        vec3 center = vec3(x, get_bubble_center_yz(offset_t, id, hash));\n\n        float proj = dot(V, center);\n        \n        float pop_dist = PATH_CENTER.x + 0.5*DISTANCE_MAX - 1.25*DISTANCE_MAX*HASH_EXTRACT_FULL(hash);\n        \n        if (x > pop_dist && proj > 0. && proj < DISTANCE_MAX && dot(center, center) > radius*radius) {\n            vec3 U = center - proj*V;\n\n            float dist_from_center = length(U);\n\n            U /= dist_from_center;\n            \n            float conf = APERTURE * APERTURE_REFERENCE * abs(proj - focus_distance) / proj;\n            \n            float blur_amount = iResolution.y * conf;\n\n            blur_amount = sqrt(1. + blur_amount*blur_amount);\n            \n            float blur_scale = pix_scale * proj * blur_amount;\n\n            float pix_dist_blurred = (dist_from_center - radius) / blur_scale;\n                \n            if (pix_dist_blurred < 0.75) {\n                vec3 W = V;\n                \n                if (pix_dist_blurred > -0.75) {\n                    float shift = blur_scale * CUBIC(pix_dist_blurred, -0.27758603, -0.56839415, -0.1731804, 0.1215896);\n                    \n                    W = normalize(center - (dist_from_center + shift) * U);\n\n                    proj = dot(W, center);\n                    \n                    vec3 W0 = normalize(center);\n                    \n                    if (dot(W,V) < dot(W0,V)) {\n                        W = W0;\n                        proj = dot(W, center);\n                    }\n                    \n                    U = center - proj*W;\n\n                    dist_from_center = length(U);\n\n                    U /= dist_from_center;\n                }\n                \n                float this_dist = proj - sqrt(proj*proj -  dot(center, center) + radius*radius);\n\n                if (this_dist > 0.) {\n                    vec3 refl_front, refl_back, refl3, t_front, t_back;\n                    float lod_base;\n                    \n                    {\n                        vec3 N_front, N_back;\n                        float a;\n                        \n                        {\n                            float b;\n                            \n                            {\n                                float rr = 1./radius;\n\n                                b = dist_from_center * rr;\n                                a = sqrt(1. - b*b);\n                                \n                                lod_base = 2. * rr * pix_scale * proj / sqrt(1. - b*b);\n                            }\n\n                            N_front = -a*W - b*U;\n                            N_back = a*W - b*U;\n                            \n                            float p = b*b - a*a; // = 2*b*b - 1 = 1 - 2*a*a\n                            float q = 2.*a*b; // = sqrt(1 - p*p)\n                            \n                            refl_front = p*W - q*U;\n                            refl_back = p*W + q*U;\n                            \n                            float p3 = p*p - q*q;\n                            float q3 = 2.*p*q;\n                            \n                            refl3 = p3*W +  q3*U;\n                        }\n                        \n                        {\n                            float thickness_front, thickness_back;\n                            \n                            {\n                                vec4 h = HASH_EXTRACT_VEC4(hash); // low value already used\n                                \n                                float thickness = 50. + 700.*min(1., (x - pop_dist) / DISTANCE_MAX)*h.y;\n                                \n                                float thickness_vary = thickness*(0.1 + 0.5*h.z);\n                                \n                                thickness_front = thickness + thickness_vary*pow(-radius*N_front.y + 2. + radius, 0.5);\n                                thickness_back = thickness + thickness_vary*pow(-radius*N_back.y + 2. + radius, 0.5);\n                            }\n\n                            float ripple_scale = 1. - smoothstep(0.0, 0.01, conf);\n                            \n                            if (ripple_scale > 0.) {\n                                vec3 offsetF = radius*N_front;\n                                vec3 offsetB = radius*N_back;\n                                \n                                {\n                                    vec3 tmp = 0.7*TIME + vec3(3., 2., 1.);\n                                    \n                                    offsetF += 0.1 * gyroid3d(2.*offsetF + tmp);\n                                    offsetB += 0.1 * gyroid3d(2.*offsetB + tmp);\n                                }\n                                \n                                {\n                                    vec3 tmp = 1.1*TIME + vec3(3., 1., 7.);\n                                    \n                                    offsetF += 0.2 * gyroid3d(5.*offsetF + tmp);\n                                    offsetB += 0.2 * gyroid3d(5.*offsetB + tmp);\n                                }\n                                \n                                {\n                                    vec3 tmp = 1.8*TIME + vec3(1.5, 5., 0.4);\n                                    float s = 0.5*ripple_scale;\n                                    \n                                    offsetF += s * gyroid3d(11.*offsetF + tmp);\n                                    offsetB += s * gyroid3d(11.*offsetB + tmp);\n                                }\n                                \n                                {\n                                    vec3 tmp = 0.01*TIME + vec3(2., 1.7, 2.5);\n                                    \n                                    thickness_front *= 1. + 0.02*ripple_scale*gyroid(1.7*offsetF + tmp);\n                                    thickness_back *= 1. + 0.02*ripple_scale*gyroid(1.7*offsetB + tmp);\n                                }\n                            }\n                            \n                            {\n                                vec3 part1 = transmittance_part1(a);\n                                \n                                t_front = transmittance_part2(part1, thickness_front);\n                                t_back = transmittance_part2(part1, thickness_back);\n                            }\n                        }\n                    }\n                    \n                    vec3 env_front, env_back, env3;\n                    \n                    {\n                        float lod = lod_base * blur_amount;\n                        \n                        float texture_lod = log2(lod) + 8.;\n                        float extra_light_blur = sqrt(lod*lod + extra_light_blur_base*extra_light_blur_base);\n\n                        float scaled_conf = iResolution.y * conf;\n\n                        if (scaled_conf * scaled_conf > 1.) {\n                            env_front = get_env(refl_front, texture_lod, extra_light_blur);\n                            env_back = get_env(refl_back, texture_lod, extra_light_blur);\n                        } else {\n                            float lod_min = lod_base * scaled_conf;\n                            float texture_lod_min = log2(lod_min) + 8.;\n                            float extra_light_blur_min = sqrt(lod_min*lod_min + extra_light_blur_base*extra_light_blur_base);\n                            \n                            float rr = 1. / radius;\n                            float b = dist_from_center * rr;\n                            \n                            float d = b*b;\n                \n                            sample_edge_reflect(1 + int(clamp(ceil(5.*d), 1., 5.)),\n                                pix_scale * proj * rr,  b, U, W, \n                                max(texture_lod_min, texture_lod - 2.5 * d),\n                                max(extra_light_blur_min, extra_light_blur / (1. + 2.*d)),\n                                env_front, env_back\n                                );\n                        }\n                        \n                        env3 = get_env(refl3, texture_lod + 1., 2.*extra_light_blur);\n                    }\n                    \n                    float coverage = smoothstep(-0.75, 0.75, -pix_dist_blurred);\n                    \n                    vec3 this_color = coverage * mix(\n                            env_front, \n                            (1.-t_back)*mix(env3, env_back, 0.5*(t_front + t_back)),\n                            t_front);\n                    \n                    vec3 this_transmit = 1. - coverage + coverage*t_front*t_back;\n                    \n                    if (this_dist < dist2) {\n                        color3 = color2 + transm2*color3;\n                        transm3 = transm2*transm3;\n                        dist3 = dist2;\n                        \n                        if (this_dist < dist1) {\n                            color2 = color1;\n                            transm2 = transm1;\n                            dist2 = dist1;\n                            color1 = this_color;\n                            transm1 = this_transmit;\n                            dist1 = this_dist;\n                        } else {\n                            color2 = this_color;\n                            transm2 = this_transmit;\n                            dist2 = this_dist;\n                        }\n                    } else {\n                        color3 = this_dist < dist3 ? this_color + this_transmit*color3 : color3 + transm3*this_color;\n                        transm3 =  this_transmit*transm3;\n                        dist3 = min(this_dist, dist3);\n                    }\n                }\n            }\n        }\n    }\n    \n    vec3 background = get_env(V, 0., bg_extra_light_r);\n    \n    vec3 color = transm1*(transm2*(transm3*background + color3) + color2) + color1;\n    \n    // Can multiply by brightness at the end (using implicit clamping) because I'm not doing proper HDR-compatible anti-aliasing of the edges.\n    fragColor = vec4(LINEAR_TO_SRGB(brightness*color), 1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (C) 2023 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader. You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact the copyright holder with questions or requests regarding\n    licensing, via DM to @KaiaVintr on Twitter or via a comment on this shader.\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/Bubbles\n    \n*/\n\n\n// Set this to 1 to use only the extra \"HDR\" light, not the environment map texture\n#define BLACK_BACKGROUND 0\n\n#define BUBBLE_DENSITY 11\n\n// For default SPEED_X and PATH_CENTER values, this should be >= ~10*BUBBLE_DENSITY to avoid weird clipping.\n// Large values are slow (if bubble density is also high)\n// Values > 16000 or so will probably cause problems (but will be very slow anyway).\n#define MAX_BUBBLE_COUNT 1000\n\n// Normalized so 1 approximately matches the environment map's blur\n// Changing this value will probably make it look less realistic\n// Set to zero to disable depth of field blur completely\n#define APERTURE 1.\n\n// Probably shouldn't be 0 (unless you don't mind if hash(0)=0)\n#define HASH_SEED 0xfb1d484bu\n\n// Bubble radius range\n#define RADIUS_MIN 0.5\n#define RADIUS_MAX 7.\n\n// cycle through different radii in the range, with this cycle length\n#define RADIUS_CYCLE_LENGTH 10.\n\n// Speed of the bubbles in the x direction \n#define SPEED_X 10.\n\n// Determines the far clip plane for the bubbles\n#define DISTANCE_MAX 1000.\n\n// Offset of the overall path of the bubbles.\n// Some parts of the code assume PATH_CENTER.x is 0\n// (no reason for it not to be 0, since it's an infinite cylinder aligned with the x-axis)\n#define PATH_CENTER vec3(0., 30., 3.)\n\n#define YZ_SCATTER_RADIUS 50.\n#define YZ_MOVEMENT_RADIUS 40.\n\n\n// Parameters determining how the \"auto-focus\" works\n\n// Size of the bounding cylinder used to determine range of visible bubbles\n#define FOCUS_CYL_RADIUS 90.\n\n// Fraction of distance to edge of bounding cylinder to focus on\n#define FOCUS_FRACTION 0.4\n\n// Bounds on the focus distance\n#define FOCUS_MIN 50.\n#define FOCUS_MAX 150.\n\n\n\n// 1 / tan(0.5*vertical_fov)\n#define VIEW_ANGLE_FACTOR 1.78\n\n#define BLOCK_SIZE 8.\n#define BLOCK_SHIFT 3\n\n// Aperture value roughly matching the background, used to define APERTURE=1\n#define APERTURE_REFERENCE 0.01\n\n\n#define TIME iTime\n\n\n#define BUBBLE_ID_TIME_INCREMENT (1./float(BUBBLE_DENSITY))\n\n#define PI 3.14159265358979\n\n\n\n/*\n  Derived by improving a basic LCG hash by trial and error.\n  Turns out to be similar to the fmix32() function from MurmurHash3, which is also used by\n  CityHash (and sometimes also called splitmix32).\n  \n  Unfortunately, fmix32 was not tested in the Jarzynski & Olano paper supplement, but I ran\n  the TestU01 BigCrush suite on it, using what I *think* is the same methodology, and it failed\n  52 \"tests\" (i.e. it had that many statistics outside the p-value range considered acceptable)\n  vs. 30 for PCG, 33 for ESGTSA, and 22 for xxHash32.\n  \n  My non-optimized version (using 0xadb4a92du, using >> 16 in all three places, adding the\n  constant 0xfb1d484bu) fails 68 tests, which means it's still substantially better than the cheap\n  1->1 hashes they tested other than PCG, ESGTSA, and xxHash32.\n  \n  Apparently some people have searched for other multipliers, and found some that work better when\n  the function is used for a seekable random number generator, but when I tested them they seemed\n  to perform worse than plain fmix32 with the Jarzynski & Olano methodology.\n  \n  This construction appears to be very slightly faster than PCG, but it will depend heavily on the\n    particular GPU and how the code gets optimized.\n  If you can omit the initial \"h ^= h >> 16\" (e.g. if you don't have any high bits set, or you have\n    already mixed the high bits into the low bits somehow) then it's faster by a more substantial margin.\n  I was speculating that the variable-size shift used by PCG might be slow on some GPUs but I have no\n    evidence for this (there's probably no reason it should be slow if it's implemented properly\n    in hardware, aside from the impact of introducing an extra data dependency into the pipeline).\n  \n  Anyway, I will choose between using fmix32 and PCG in future shaders, but I think this non-optimized\n  function is fine for making bubbles.\n  \n  UPDATE: I found a better way to test these functions visually, which revealed the weakness in this \n    function and in fmix32. No longer convinced that # of BigCrush failures is the best way to evaluate\n    these functions, since it indicated that xxHash32 is better than PCG, when actually it's worse (for\n    this type of application). I should write a blog article or something.\n    \n  UPDATE2: Ok, xxHash32 seems better than PCG overall, but worse in certain tests.\n    MurmurHash3 also looks bad on some of my visual tests.\n\n\n*/\n\nuint hash_fn1(uint h) {\n\n    // Unnecessary in this shader, since only low bits are used in input\n    // Using += instead of ^= seemed to improve output when low and high bits are identical, but it makes\n    //   performance on the TestU01 tests substantially worse.\n    //h ^= h >> 16; \n    \n    // 0xadb4a92d is one of the multipliers from the Steele & Vigna 2021 paper\n    // fmix32() does not add a constant (but modifying it to add a constant did not degrade performance significantly)\n    h = h*0xadb4a92du + HASH_SEED;\n    \n    // If you skip this step, the following multiplication will do nothing structurally to improve the output,\n    //   since it will be equivalent to a single multiply and add\n    // fmix32() uses 13 here.\n    h ^= h >> 16;\n    \n    // I don't know if there is any reason to use a different multiplier here, but I noticed that some\n    //      combinations of different multipliers interact and produce worse results\n    h = h*0xadb4a92du;\n    \n    // If performance is a priority, you may be able to skip this step.\n    return h ^ (h >> 16);\n}\n\n// Used only as a random number generator, for generating more bits from a previously computed hash.\n// I am only calling it once, so cycle length is not a concern.\n// Not recommended as a general-purpose random number generator.\n// Basic MCG, but mixing high bits to low bits to improve output.\nuint hash_fn2(uint h) {\n    // I don't know if there is any reason to use a different multiplier here.\n    // I don't know if adding a constant would help, other than for input 0 (which is not a concern here).\n    // I might use 0x8eae2659u instead in the future, since it gave better results when tested visually \n    //   (when used as a standalone hash function) although it will still perform terribly on TestU01 tests.\n    h = h*0xadb4a92du;\n    \n    // This step noticeably improves the quality of the output, but may make the code unsuitable for\n    //      use as a general-purpose random number generator by causing short cycles for some starting values.\n    // May not be necessary if performance is a priority.\n    return h ^ (h >> 16);\n}\n\n#define HASH_EXTRACT_VEC4(H) (1./255. * vec4(uvec4((H), (H)>>8, (H)>>16, (H)>>24) & 0xffu))\n#define HASH_EXTRACT_LOW(H) (1./255. * float((H) & 0xffu))\n#define HASH_EXTRACT_FULL(H) (0.00000000023283 * float(H))\n\nvec2 get_bubble_center_yz(float t, uint obj, out uint hash) {\n    uint h = hash_fn1(obj);\n    \n    vec4 g = HASH_EXTRACT_VEC4(h);\n    \n    h = hash_fn2(h);\n    \n    float s = HASH_EXTRACT_LOW(h);\n    \n    float f =  pow(1.5 + g.x + sin((1. + 2.*s)*t), 0.5);\n    float u = 1.*s + 0.1*t + (0.3*g.y)*(t + f);\n    \n    hash = h;\n    \n    // The constant (\"scatter\") offset is distributed over a square, not a circle, but I think it looks better that way.\n    return PATH_CENTER.yz + (2. * YZ_SCATTER_RADIUS)*g.zw - YZ_SCATTER_RADIUS + YZ_MOVEMENT_RADIUS*vec2(sin(u), cos(u));\n}\n\nmat3 make_camera(vec4 mouse4, vec3 resolution) {\n    vec2 mouse = mouse4.x == 0. && mouse4.y == 0. || mouse4.x > resolution.x || mouse4.y > resolution.y\n            ? vec2(0.835, 0.6)*resolution.xy\n            : mouse4.xy;\n\n    mouse = 2. * (mouse.xy / resolution.xy - 0.5);\n    \n    float xz = PI * mouse.x;\n    float yz = 0.5*PI * min(mouse.y, 0.999);\n    \n    float cos_yz = cos(yz);\n    \n    // (normalize is for precision loss only)\n    vec3 dir_z = normalize(vec3(sin(xz)*cos_yz, sin(yz), cos(xz)*cos_yz));\n    vec3 dir_x = normalize(cross(vec3(0, 1, 0), dir_z));\n\n    return mat3(dir_x, normalize(cross(dir_z, dir_x)), dir_z);\n}\n\nvec2 cyl_intersection(vec2 V) {\n    float t0 = dot(V, PATH_CENTER.yz);\n    float v_scale_sq = 1. / dot(V, V);\n    \n    float t = t0 * v_scale_sq;\n    \n    float disc = FOCUS_CYL_RADIUS*FOCUS_CYL_RADIUS + t*t0 - dot(PATH_CENTER.yz, PATH_CENTER.yz);\n    \n    // if no intersection, return distance to closest approach\n    float b = sqrt(max(disc, 0.) * v_scale_sq);\n    \n    return vec2(t - b, t + b);\n}\n\nfloat get_focus_distance(vec3 V) {\n    vec2 d = max(cyl_intersection(V.yz), 0.);\n    \n    return abs(V.x) < 0.001 ? FOCUS_MAX : clamp(mix(d.x, d.y, FOCUS_FRACTION), FOCUS_MIN, FOCUS_MAX);\n}\n\nfloat get_radius(float fid) {\n    // The \"- 0.629\" makes the cycle slightly longer than RADIUS_CYCLE_LENGTH, so that the fract() parts of the numbers are more varied, and more sizes are visited\n    return mix(RADIUS_MIN, RADIUS_MAX, fract(((RADIUS_CYCLE_LENGTH - 0.629)/(RADIUS_CYCLE_LENGTH*RADIUS_CYCLE_LENGTH))*fid));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Copyright (C) 2023 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader. You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact the copyright holder with questions or requests regarding\n    licensing, via DM to @KaiaVintr on Twitter or via a comment on this shader.\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/Bubbles\n    \n*/\n\n\n#define MAX3(A, B, C) max(max(A, B), C)\n#define MAX6(A, B, C, D, E, F) max(MAX3(A, B, C), MAX3(D, E, F))\n\n#define MIN3(A, B, C) min(min(A, B), C)\n#define MIN6(A, B, C, D, E, F) min(MIN3(A, B, C), MIN3(D, E, F))\n\n\nvec2 plane_bound(vec3 orig, vec3 direction, float radius, vec3 N) {\n    float a = -dot(orig, N);\n    float b = dot(direction, N);\n    \n    if (abs(b) > 0.00001) {\n        float t = (a - radius*sqrt(1. - b*b)) / b;\n\n        return b > 0. ? vec2(t, 1e20) : vec2(-1e20, t);\n    } else {\n        return vec2(-1e10, 1e20);\n    }\n}\n\nuvec4 id_range_for_frustum(vec2 corner, mat3 camera) {\n    float pixel_z = VIEW_ANGLE_FACTOR*iResolution.y;\n    \n    vec3 neighborhood_V;\n    float pix_scale, neighborhood_radius;\n    \n    {\n        vec2 a = corner + 0.5;\n        vec2 b = corner + (BLOCK_SIZE - 0.5);\n        \n        vec2 c = step(0., a*b) * min(a*a, b*b);\n        \n        pix_scale = 1. / sqrt(c.x + c.y + pixel_z*pixel_z);\n        \n        neighborhood_radius = sqrt(2.) * 7.5 * pix_scale;\n\n        neighborhood_V = camera * normalize(vec3(corner + 8., pixel_z));\n    }\n    \n    vec3 N_left = normalize(vec3(pixel_z, 0, -corner.x));\n    vec3 N_right = normalize(vec3(-pixel_z, 0, corner.x + BLOCK_SIZE));\n    vec3 N_bottom = normalize(vec3(0, pixel_z, -corner.y));\n    vec3 N_top = normalize(vec3(0, -pixel_z, corner.y + BLOCK_SIZE));\n    \n    vec3 cyl_origin = PATH_CENTER * camera;\n    vec3 cyl_direction = vec3(1,0,0) * camera;\n    \n    vec2 xrange;\n    \n    {\n        // The \"3\" is a fudge factor for depth of field blur and anti-aliasing that might not be necessary.\n        float cyl_radius = YZ_SCATTER_RADIUS + YZ_MOVEMENT_RADIUS + RADIUS_MAX + 3.;\n        vec3 N_z = vec3(0,0,1);\n        \n        vec2 bound0 = plane_bound(cyl_origin, cyl_direction, cyl_radius, N_z);\n        vec2 bound1 = plane_bound(cyl_origin, cyl_direction, cyl_radius, N_left);\n        vec2 bound2 = plane_bound(cyl_origin, cyl_direction, cyl_radius, N_right);\n        vec2 bound3 = plane_bound(cyl_origin, cyl_direction, cyl_radius, N_bottom);\n        vec2 bound4 = plane_bound(cyl_origin, cyl_direction, cyl_radius, N_top);\n        vec2 bound5 = plane_bound(cyl_origin - vec3(0,0,DISTANCE_MAX), cyl_direction, cyl_radius, -N_z);\n        \n        xrange = vec2(MAX6(bound0.x, bound1.x, bound2.x, bound3.x, bound4.x, bound5.x),\n                      MIN6(bound0.y, bound1.y, bound2.y, bound3.y, bound4.y, bound5.y));\n    }\n    \n    xrange.r -= RADIUS_MAX;\n    xrange.g += RADIUS_MAX;\n    \n    uint start_id, end_id;\n    \n    {\n        float x_scale = 1. / (SPEED_X * BUBBLE_ID_TIME_INCREMENT);\n        float offset = x_scale*PATH_CENTER.x - TIME / BUBBLE_ID_TIME_INCREMENT;\n        \n        start_id = uint(max(1, int(ceil(x_scale*xrange.r - offset))));\n\n        end_id = uint(max(int(start_id), int(floor(x_scale*xrange.g - offset))));\n    }\n    \n    uint count = end_id - start_id + 1u;\n    \n    vec3 center_ray = camera*vec3(0,0,1);\n    \n    bool reversed = center_ray.x < 0.;\n    \n    if (count > uint(MAX_BUBBLE_COUNT)) {\n        if (reversed) start_id = end_id - uint((MAX_BUBBLE_COUNT - 1));\n        count = uint(MAX_BUBBLE_COUNT);\n    }\n    \n    float focus_distance = get_focus_distance(center_ray);\n\n    uint id_lower_bound = uint(max(0, int(floor(TIME / BUBBLE_ID_TIME_INCREMENT)) - (MAX_BUBBLE_COUNT + 1)));\n    \n    uint id_max = 0u;\n    uvec4 idset = uvec4(0);\n    \n    for (uint i = 0u; i < count; i++) {\n        uint id = reversed ? end_id - i : i + start_id;\n    \n        float fid = float(id);\n        \n        float offset_t = BUBBLE_ID_TIME_INCREMENT*fid - TIME;\n        \n        float x = PATH_CENTER.x + SPEED_X*offset_t;\n\n        float radius = get_radius(fid);\n        \n        uint h;\n        vec3 C = vec3(x, get_bubble_center_yz(offset_t, id, h));\n        \n        float len_c = length(C);\n        \n        float proj_min = dot(neighborhood_V, C) - len_c*neighborhood_radius;\n        float proj_max = dot(neighborhood_V, C) + len_c*neighborhood_radius;\n        \n        \n        float s_max = iResolution.y * (APERTURE * APERTURE_REFERENCE) / proj_min * max(proj_max - focus_distance, focus_distance - proj_min);\n        \n        float margin = -(radius + 0.75 * pix_scale * sqrt(1. + s_max*s_max) * proj_max);\n        \n        C = C * camera;\n        \n        if (C.z >= 0. && C.z <= DISTANCE_MAX\n                    && dot(C, N_left) > margin\n                    && dot(C, N_right) > margin\n                    && dot(C, N_bottom) > margin\n                    && dot(C, N_top) > margin\n                    ) {\n            id -= id_lower_bound;\n            \n            if ((idset.x & 0xffffu) == 0u) {\n                idset = (idset >> 16) | uvec4(idset.yzw << 16, id << 16);\n            } else {\n                id_max = id;\n            }\n        }\n    }\n    \n    if ((idset.w & 0xffff0000u) != 0u) {\n        if (idset.y == 0u) idset = uvec4(idset.zw, 0, 0);\n        if (idset.x == 0u) idset = uvec4(idset.yzw, 0);\n        if ((idset.x & 0xffffu) == 0u) idset = (idset >> 16) | uvec4(idset.yzw << 16, 0);\n        \n        if (id_max != 0u) {\n            uint second_last = idset.w & 0xffffu;\n            \n            idset.w = (reversed ? (id_max | (second_last << 16)) \n                    : (second_last | (id_max << 16))) | 0x80000000u;\n        }\n    }\n    \n    return idset;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 corner = floor(fragCoord) * BLOCK_SIZE;\n    \n    if (corner.x < iResolution.x && corner.y < iResolution.y) {\n        fragColor = uintBitsToFloat(id_range_for_frustum(corner - 0.5*iResolution.xy, make_camera(iMouse, iResolution)));\n    } else {\n        fragColor = vec4(0);\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}