{"ver":"0.1","info":{"id":"dsl3Rj","date":"1666456741","viewed":54,"name":"Fork path traci akin 526","username":"akin","description":"toying around..\ncamera oddly acts as a orbit camera. it is the end goal, not what I thought would happen","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["toy"],"hasliked":0,"parentid":"tllGW7","parentname":"path tracing fubar"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415926538\n#define TAO (2.0*PI)\n#define FAR 1000.0\n#define ITERATIONS 64\n#define EPSILON 0.0001\n\n// mult, multiplier of step, this can be used to manipulate sdf calculations\nstruct Ray\n{\n    float time;\n    vec3 origin;\n    vec3 dir;\n    float mult;\n    float distance;\n    float length;\n};\n    \nstruct Result\n{\n    float time;\n    float distance;\n    float traveled;\n    vec3 position;\n};\n    \nstruct Point\n{\n    float time;\n    vec3 point;\n};\n\nfloat sceneDistance(in float time, in vec3 point)\n{\n    float dist = FAR;\n    float sphereSize = 0.4;\n    dist = 1.0;\n    \n    point = fract(point);\n    \n    float smot = 0.2;\n    float value = 1.0; //plane(vec4(1.0, 0.0, 0.0, 0.0), point);\n    add(value, octahedron(vec3(0.0, 0.0, 0.0), 0.5, point));\n    add(value, torus(vec3(0.0, 0.0, 0.0), vec2(1.5, 0.3), point));\n    smoothAdd(value, sphere(vec3(0.0 + sin(time) * dist, 0.0, 0.0 + cos(time) * dist), sphereSize, point), smot);\n    smoothAdd(value, sphere(vec3(0.0 + sin(time + PI) * dist, 0.0, 0.0 + cos(time + PI) * dist), sphereSize, point), smot);\n    \n    smoothAdd(value, sphere(vec3(0.0, 0.0 + cos(time) * dist, 0.0 + sin(time) * dist), sphereSize, point), smot);\n    smoothAdd(value, sphere(vec3(0.0, 0.0 + cos(time + PI) * dist, 0.0 + sin(time + PI) * dist), sphereSize, point), smot);\n    \n    return value;\n}\n\nvec3 sceneNormal(in float time, in vec3 point) {\n    return normalize(vec3(\n        sceneDistance(time, vec3(point.x + EPSILON, point.y, point.z)) - sceneDistance(time, vec3(point.x - EPSILON, point.y, point.z)),\n        sceneDistance(time, vec3(point.x, point.y + EPSILON, point.z)) - sceneDistance(time, vec3(point.x, point.y - EPSILON, point.z)),\n        sceneDistance(time, vec3(point.x, point.y, point.z  + EPSILON)) - sceneDistance(time, vec3(point.x, point.y, point.z - EPSILON))\n    ));\n}\n\nvoid sceneMaterial(\n    in float time, in vec3 point, \n    out vec3 transparency, out vec3 refraction, out vec3 opaque) {\n    \n    opaque = vec3(1.0, 1.0, 1.0);\n    refraction = vec3(0.1, 0.1, 0.1);\n    transparency = vec3(0.0, 0.0, 0.0);\n}\n\nvec3 background(in vec3 dir)\n{\n    dir = normalize(dir);\n    return texture(iChannel1, dir).xyz;\n}\n\nvec3 backgroundUnfocus(in vec3 dir)\n{\n    dir = normalize(dir);\n    return texture(iChannel2, dir).xyz;\n}\n\n// Origin, origin of ray\n// Dir, direction of ray\n// mult, multiplier of step, this can be used to manipulate sdf calculations\nvoid trace(const in Ray ray, out Result result)\n{\n    result.time = ray.time;\n    result.traveled = 0.0;\n    result.distance = FAR;\n    \n    for(int i = 0 ; i < ITERATIONS ; ++i)\n    {\n        vec3 point = ray.origin + ray.dir * result.traveled;\n        float d = sceneDistance(ray.time, point);\n        \n        result.distance = d;\n        result.traveled += d * ray.mult;\n    }\n    \n    result.position = ray.origin + ray.dir * result.traveled;\n}\n\nfloat traceOut(in vec3 origin, in vec3 dir, in float mult, in float time, out float traveled)\n{\n    traveled = 0.0;\n    float closest = FAR;\n    for(int i = 0 ; i < ITERATIONS ; ++i)\n    {\n        vec3 point = origin + dir * traveled;\n        \n        float d = sceneDistance(time, point);\n        closest = min(d, closest);\n        \n        traveled += d * mult;\n    }\n    return closest;\n}\n\nfloat traceFreq(in float freq, in vec3 origin, in vec3 dir, in float time)\n{\n    return 0.0;\n}\n\nfloat traceRed(in vec3 origin, in vec3 dir, in float time)\n{\n    return 0.0;\n}\n\nfloat traceGreen(in vec3 origin, in vec3 dir, in float time)\n{\n    return 0.0;\n}\n\nfloat traceBlue(in vec3 origin, in vec3 dir, in float time)\n{\n    return 0.0;\n}\n\nvec3 render(const in Ray ray)\n{\n    // Render pipeline\n    vec3 color = background(ray.dir);\n    \n    // Render\n    Result result;\n    trace(ray, result);\n    \n    if(result.distance < 0.1)\n    {\n        // Something there.\n        vec3 normal = sceneNormal(ray.time, result.position);\n        vec3 transparency;\n        vec3 refraction;\n        vec3 opaque;\n        \n        sceneMaterial(ray.time, result.position, transparency, refraction, opaque);\n        // TODO\n        // use transparency\n        // refraction\n        // opaque\n        // to create reality!.. or well.. \n        // this is a bit complicated, as I need to separate the 3 colors\n        // all the colors can go different directions (chromatic aberration)\n        // though, light comes from everywhere, basically ALL light comes from spheremap, not ray.\n        \n        vec3 reflectionDirection = reflect(ray.dir, normal);\n        vec3 refractionDirection = refract(ray.dir, normal , 0.5);\n        \n        // Opaque?\n        {\n            vec3 colorReflection = backgroundUnfocus(reflectionDirection);\n            vec3 colorRefraction = background(refractionDirection);\n        \n            // refraction vs reflection calculation\n            float blot = smoothstep(0.4,0.1,(dot(normal , ray.dir) + 1.0) * 0.75);\n\n            vec3 opaque = mix(colorReflection, colorRefraction, blot);\n\n            // Blend opaque and previous\n            //color = mix(color, opaque, smoothstep(0.1, 0.01, result.distance));\n            color = opaque;\n        }\n        // color = vec3(result.traveled * 0.2, result.traveled * 0.2, result.traveled * 0.2);\n        \n        color = color * (5.0 / (result.traveled * result.traveled));\n    }\n    // Render transparent(TODO)\n    // Render UI(TODO)\n    \n    return color;\n}\n\nvoid gammaCorrect(inout vec3 color)\n{\n    const float gamma = 2.2;\n    color = vec3(pow(color, vec3(1.0/gamma)));\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// https://iquilezles.org/articles/distfunctions\n// https://www.youtube.com/watch?v=yxNnRSefK94\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray;\n    ray.time = iTime;\n    ray.mult = 1.0;\n    \n    vec2 m = vec2(0.0); // Default OpenGL camera: Look down -z axis\n    m += 3.0 * iMouse.xy / iResolution.xy;\n    \n    mat4 camera = mat4(1.0);\n    // TODO fix camera\n    //camera *= translationMatrix(in vec3 trans);\n    vec2 position = (fragCoord/iResolution.xy * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n    \n    //camera = camera * translationMatrix(vec3(0.0, 0.0, -3.0));\n    //camera = camera * rotationMatrix(vec3(0.0, 1.0, 1.0), ray.time);\n    \n    camera = camera * rotationMatrix(vec3(0.0, 1.0, 0.0), m.x);\n    camera = camera * rotationMatrix(vec3(-1.0, 0.0, 0.0), m.y);\n    \n    ray.dir = ((vec4(normalize(vec3(position, 1.0)), 1.0) * camera).xyz);\n    ray.origin = (vec4(0.0, 0.0, -3.0, 1.0) * camera).xyz;\n    \n    vec3 color = render(ray);\n    \n    gammaCorrect(color);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat4 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix(in vec3 trans)\n{\n    return mat4(1.0, 0.0, 0.0, trans.x,\n                0.0, 1.0, 0.0, trans.y,\n                0.0, 0.0, 1.0, trans.z,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nfloat plane(in vec4 normal , in vec3 point)\n{\n  // normal must be normalized\n  return dot(point,normal.xyz) + normal.w;\n}\n\nfloat octahedron( in vec3 position, in float size, in vec3 point)\n{\n    point = abs(position - point);\n    return (point.x+point.y+point.z-size)*0.57735027;\n}\n\nfloat torus(in vec3 position, in vec2 size, in vec3 point)\n{\n    point = position - point;\n    vec2 q = vec2(length(point.xz)-size.x,point.y);\n    return length(q)-size.y;\n}\n\nfloat sphere(in vec3 position, in float size, in vec3 point)\n{\n    return length(position - point) - size;\n}\n\nfloat sdintersect(float distA, float distB) \n{\n    return max(distA, distB);\n}\n\nfloat sdunion(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat sddifference(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\nvoid add(inout float result, in float value) \n{\n    result = min(result, value);\n}\n\n// https://iquilezles.org/articles/smin\nvoid smoothAdd( inout float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    d1 = mix( d2, d1, h ) - k*h*(1.0-h); \n}\n","name":"Common","description":"","type":"common"}]}