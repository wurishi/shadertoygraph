{"ver":"0.1","info":{"id":"slt3RN","date":"1635821936","viewed":112,"name":"Raymarching - Transformations","username":"HashSlasher","description":"This is an example of domain transformations on signed distance functions. This project was made by Colsen Stiles.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Programmed by Colsen Stiles\n// This is ana example of a simple cube after it undergoes a combination of simple transformations, all\n// rendered using raymarching.\n\n\n// Set important variables for ray calculation\n#define MAX_STEPS 1000\n#define MAX_DIST 10000.\n#define SURF_DIST 0.01\n#define PI 3.14159\n\n\n// This function is a modulo operator used to repeat space. Here it is formatted to be easier to work with\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// This is a modified modulo operator to repeat space, but each repetition is mirrored\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0) * 2. - 1.;\n\treturn c;\n}\n\n// This is a modified modulo operator wich repeats space and rotates it around an axis\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2. * PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions / 2.)) c = abs(c);\n\treturn c;\n}\n\n// This funtion rotates and repeats space but mirrors each repetition\nfloat pModPolarMirror(inout vec2 p, float repetitions) {\n\tfloat angle = 2. * PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n    a *= mod(c, 2.0) * 2. - 1.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions / 2.)) c = abs(c);\n\treturn c;\n}\n\n// This function mirrors space\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Return a quaternion from an angle axis rotation\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\n// Inverse of a quaternion\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n\n// Convert point into a quaternion (which is essential a 4-d vector)\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\n// Quaternion mulitplication function, multiplies 2 quaternions\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\n// Rotate function, rotates a vector p around an axis v by a radians\nvec3 rotate(in vec3 p, in vec3 v, in float a)\n{\n    vec4 q = quat(v, a);\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\n\n\n// Signed distance function for a sphere\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    float dist = length(p - c) - r;\n    \n    return dist;\n}\n\n\n// Signed distance function for a box with dimensions defined by vector v\nfloat sdBox(vec3 p, vec3 b)\n{   \n    vec3 q = abs(p) - b;\n    return length( max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n\n// Signed distance function for a box, but the only difference is the domain of this function (point p)\n// undergoes many sequential transformations. The result is the monster in the preview window.\nfloat sdTransformedBox(vec3 p, vec3 b)\n{\n    \n    // Here we rotate, translate, mirror, and repeat the domain. These transformations on the domain\n    // directly affect the output, which changes the object that is rendered to the screen.\n    p -= vec3(3, 2, 10);\n    \n    p = rotate(p, normalize(vec3(0, 1, 0)), iTime/8.);\n    p = rotate(p, normalize(vec3(1, 0, 0)), iTime/8.);\n    \n    float amt = sin(iTime) * 9.;\n    \n    pModMirror1(p.z, 25. + amt);\n    pModMirror1(p.y, 25. + amt);\n    pModMirror1(p.x, 25. + amt);\n    \n    p = rotate(p, normalize(vec3(0, 1, 0)), iTime * 2.);\n    p = rotate(p, normalize(vec3(0, 0, 1)), 2. + iTime/2.);\n    \n    pModPolar(p.xz, 2. + 1.);\n    pMirror(p.z, 0.);\n    \n    p = rotate(p, normalize(vec3(0, 0, 1)), iTime * 1.);\n    \n    pModPolarMirror(p.yx, 8.);\n    \n    p.y -= 3.;\n    \n    p = rotate(p, normalize(vec3(0, 1, 0)), 2. + iTime/3.);\n    p = rotate(p, normalize(vec3(0, 0, 1)), 2. + iTime/2.);\n    p = rotate(p, normalize(vec3(1, 0, 0)), 2. + iTime/1.);\n    \n    // Below this comment, the function is identical to the simple box distance function\n    vec3 q = abs(p) - b;\n    return length( max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n    \n}\n\n\n// Signed distance function for a capsule\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    p.z -= 5.;\n    p.z = mod(p.z + 1., 2.) - 1.;\n    p.x += 2.;\n    p.x = mod(p.x + 1., 2.) - 1.;\n    p.y -= 2.;\n    \n    p = rotate(p, normalize(vec3(1,1,1)), iTime * 0.5);\n    \n    \n    vec3 aToB = b - a;\n    vec3 aToP = p - a;\n    \n    float t = dot(aToB, aToP) / dot(aToB, aToB);\n    \n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t * aToB;\n    \n    float dist = length(p - c) - r;\n    \n    return dist;\n}\n\n\n// This function returns the distance to the closest object to point p, which drives raymarcher algorithm\n// It's a master signed distance function representing the signed distance to the whole scene\n// It is comprised of multiple signed distance functions\nfloat GetDist(vec3 p)\n{       \n    // Simple sphere\n    float sphereDist = sdSphere(p, vec3(0,3,4), 2.);\n    \n    // Simple flat plane\n    float planeDist = p.y;\n    \n    // Cube with lots of transformations!\n    float cubeDist = sdTransformedBox(p, vec3(1.5));\n    \n    // The final distance is simply the minimum of the distances of each object\n    float d = min(min(sphereDist, planeDist), cubeDist);\n    \n    return d;\n}\n\n\n// This function casts a ray by allowing it to travel small distances at a time\n// Uses signed distance functons to know how far to travel, and to approximate collision detection\nfloat RayMarch(vec3 ro, vec3 rd, out bool hit) {\n\n    // Initialize distance to zero\n    float dist = 0.;\n    \n    // Initialize hit bool\n    hit = false;\n    \n    // Step ray forward until it intersects, it goes too far, or uses too many iterations\n    // Ray is considered intersecting if it is within a small distance to a surface\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dist;\n        float dS = GetDist(p);\n        dist += dS;\n        if(abs(dS) < SURF_DIST)\n        {\n            hit = true;\n            break;\n        }\n        else if(dist > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    return dist;\n}\n\n\n// Calculate the surface normal based on the signed distance function\nvec3 GetNormal(vec3 p)\n{\n     float d = GetDist(p);\n     vec2 e = vec2(0.01, 0);\n     vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n     return normalize(n);\n}\n\n\n// Use surface normal to shade the surface according to direction of light and\n// cast a ray toward the light source to see if this point is in shadow or not\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(3, 10, -8);\n    \n    vec3 lightDir = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, lightDir), 0., 1.);\n    \n    bool hit = false;\n    float distToLight = RayMarch(p + n * SURF_DIST * 2., lightDir, hit);\n    if(distToLight < length(lightPos-p))\n    {\n        dif = 0.;\n    }\n    \n    return mix(dif, 0.6, 0.2);\n}\n\n\n// This function is called by the graphics pipeline for each pixel, its output is the pixel color\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    // Initialize camera / rays\n    vec3 ro = vec3(0, 6, -2);\n    \n    // Determines field of view\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.4));\n    rd = rotate(rd, vec3(1,0,0), -(iMouse.y / iResolution.y - 0.5) * 6.);\n    rd = rotate(rd, vec3(0,1,0), (iMouse.x / iResolution.x - 0.5) * 3.);\n    \n    // Hit or not?\n    bool hit = false;\n    \n    // Shoot rays and return distance\n    float d = RayMarch(ro, rd, hit);\n    \n    // Initialize point, light brightness, and normal direction\n    vec3 p;\n    float dif;\n    vec3 normal;\n    \n    // If raycast hits do diffuse lighting calculations, otherwise make this pixel dark\n    if(hit)\n    {\n        p = ro + rd * d;\n        \n        dif = GetLight(p);\n    }\n    else\n    {\n        dif = 0.;\n        normal = vec3(0);\n    }\n    \n    col = vec3(dif);\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}