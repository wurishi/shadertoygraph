{"ver":"0.1","info":{"id":"7s2SRm","date":"1619959811","viewed":130,"name":"Superposition314","username":"Domain314","description":"My personal interpretation of a \"Superposition\": Vibration between two states.\n\nOnly watchable @50+fps\n\nIf no music => check for iChannel0 (audio must be loaded) => pause => set back time => start again\n\nYou can disable the colour, at the top of the code.","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","dark","superposition","audioresponsive","meditaion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4lfXz2","filepath":"https://soundcloud.com/ultimae/aes-dana-alep-offset","previewfilepath":"https://soundcloud.com/ultimae/aes-dana-alep-offset","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// Colour switch:\n//  0 = !Colour, 1 = Colour\n#define COLOUR_CON 1\n\n// Smooth HSV: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot (float i) {\n    float s = sin(i), c = cos(i);\n    return mat2(c, -s, s, c);\n}\n\nfloat Box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat Sphere(vec3 p, vec4 s) {\n    return length(p-s.xyz)-s.w;\n}\n\nfloat MainBox(vec3 p, vec2 fft) {\n    vec3 bp = p;\n    bp.xz *= Rot(iTime*fft.x);\n    vec3 sp = p;\n      \n    float boxDist = Box(bp, vec3(1.5));\n    float sphereDist = Sphere(sp, vec4(0, 0, 0, 2.));\n    \n    return mix(sphereDist, boxDist, sin(fft.y*5.)*1.5);\n}\n\nfloat SphereGroup(vec3 p, float _fft2) {\n    float fft2 = _fft2*0.4;\n    vec3 sp = p + vec3(0, 0.5, 0);\n    sp.xz *= Rot(iTime*0.2);\n    //sp.yz *= Rot(fft2);\n    \n    float sphereDist2 = Sphere(sp, vec4(3.+fft2, 0, 3.+fft2, 0.8));    \n    float sphereDist = Sphere(sp, vec4(-3.-fft2, 0, 3.+fft2, 0.8));    \n    float d = min(sphereDist2, sphereDist);     \n    sphereDist = Sphere(sp, vec4(3.+fft2, 0, -3.-fft2, 0.8));    \n    d = min(d, sphereDist); \n    sphereDist = Sphere(sp, vec4(-3.-fft2, 0, -3.-fft2, 0.8));    \n    d = min(d, sphereDist); \n    return d;\n}\n\nfloat Cross(vec3 p, float fft) {\n    vec3 bp = p-vec3(0, 1.9, 0);\n    bp.xz *= Rot(-iTime*fft);\n    \n    float box = Box(bp, vec3(1.*fft, 0.1, 1.*fft));    \n    float boxE = Box(bp-vec3(1, 0, 1), vec3(0.9*fft, 0.25, 0.8*fft));\n    box = max(-boxE, box);\n    boxE = Box(bp-vec3(-1, 0, -1), vec3(0.9*fft, 0.25, 0.8*fft));\n    box = max(-boxE, box);\n    boxE = Box(bp-vec3(-1, 0, 1), vec3(0.9*fft, 0.25, 0.8*fft));\n    box = max(-boxE, box);\n    boxE = Box(bp-vec3(1, 0, -1), vec3(0.9*fft, 0.25, 0.8*fft));\n    return max(-boxE, box);\n}\n\nfloat GetDist(vec3 p) {   \n    //float planeDist= p.y+2.;\n    \n    float fft = texelFetch(iChannel0, ivec2(1., 0), 0).x;\n    float fft2 = texelFetch(iChannel0, ivec2(1., 1), 0).x;\n        \n    //float d = min(planeDist, );\n    float d = min(MainBox(p, vec2(fft, fft2)), SphereGroup(p, fft2));   \n    d = min(d, Cross(p, fft));\n    \n    return d;\n}\n\nfloat GetDistP(vec3 p) {   \n    float planeDist= p.y+2.;\n       \n    float d = planeDist;\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }    \n    return dO;\n}\n\nfloat RayMarchP(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDistP(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy), \n        GetDist(p-e.yxy), \n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLightP(vec3 p) {\n    vec3 lightPos = vec3(-4., 6., -4.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarchP(p+n*SURF_DIST*2., l);\n    if (d < length(lightPos-p)) dif *=.5;\n    return dif;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(-4., 6., -4.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if (d < length(lightPos-p)) dif *=.5;\n    return dif;\n}\n\nvec3 cam(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0, 1., 0), f));\n    vec3 u = cross(f,r);\n    vec3 c = p+f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    return normalize(i-p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy + vec2(0.92, -0.1);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(1., 4., -5.);\n    \n    // For cam-movement with the mouse, delete following 2 lines and uncomment the 2 lines after. \n    //ro.yz *= Rot(0.1);\n    //ro.xz *= Rot(-0.9*6.2831);    \n    ro.yz *= Rot(-m.y);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = cam(uv, ro, vec3(0,0,0), .7);    \n    \n    float d = RayMarch(ro, rd);    \n    vec3 p = vec3(0.);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n    \tcol = vec3(dif);\n    }\n    \n    float fft = texelFetch(iChannel0, ivec2(1., 0), 0).x;\n    float fft2 = texelFetch(iChannel0, ivec2(1., 1), 0).x;\n    vec3 hsl = vec3(fft2*0.5+.4, 1., 1.);\n    vec3 rgb = hsv2rgb_smooth(hsl);\n    \n    if (COLOUR_CON == 1) col*=rgb;\n    //col = col*rgb;    \n    col = pow(col, vec3(.6));\n    \n    d = RayMarchP(ro, rd);    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLightP(p);\n    \tcol += vec3(dif);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}