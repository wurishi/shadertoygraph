{"ver":"0.1","info":{"id":"Xt3GDX","date":"1471894730","viewed":717,"name":"018 monte carlo path tracer","username":"kakaxizhhgjh","description":"My first try on monte carlo path tracing. Thanks very much for Evan Wallace's demo.\nI'm totally a new learner, so any error in my shader or render quality improvements, please let me know.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["pathtracer","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\t\t{ vec3 o, d; };\nstruct Hit\t\t{ float t; vec3 n, c; };\nstruct Sphere\t{ float r; vec3 p, c; };\nstruct Box\t\t{ vec3 bmin, bmax; };\n\nconst float PI   = 3.141692;\nconst float EPS  = 1e-4;\nconst float TMAX = 1e2;\nconst int   ITER = 4;\nconst Hit   MISS = Hit(TMAX, vec3(0), vec3(0));\n\nfloat rand(vec2 scale, float t) {\n    return fract(sin(dot(gl_FragCoord.xy / iResolution.y + t, scale)) * 43758.5453 + t);\n}\n\nvec3 cosineWeightedRay(vec3 n, float t) {\n    float u = rand(vec2(12.9898, 78.233), t);\n    float v = rand(vec2(63.7264, 10.873), t);\n    float phi = 2.0 * PI * u;\n    float stheta  = sqrt(v);\n    vec3 x = abs(n.x) < 0.5 ? vec3(1, 0, 0) : vec3(0, 1, 0);\n    vec3 z = normalize(cross(x, n));\n    x = cross(n, z);\n    return mat3(x, n, z) * vec3(stheta * cos(phi), sqrt(1.0 - v), stheta * sin(phi));\n}\n\nvec3 uniformRay(float t) {\n    float u = rand(vec2(12.9898, 78.233), t);\n    float v = rand(vec2(63.7264, 10.873), t);\n    float phi = 2.0 * PI * u;\n    float ctheta = 1.0 - 2.0 * v;\n    float stheta = sqrt(1.0 - ctheta * ctheta);\n    return vec3(stheta * cos(phi), ctheta, stheta * sin(phi));\n}\n\nHit intersect(Ray r, Box b) {\n    vec3 tmin = (b.bmin - r.o) / r.d;\n    vec3 tmax = (b.bmax - r.o) / r.d;\n    vec3 t1 = min(tmin, tmax);\n    vec3 t2 = max(tmin, tmax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar  = min(min(t2.x, t2.y), t2.z);\n    if(tNear > tFar) return MISS;\n    vec3 n, c = vec3(0.75);\n    vec3 p = r.o + tFar * r.d;\n    if(p.x < b.bmin.x + EPS) { n = vec3(1, 0, 0); c = vec3(1, 0.3, 0.1); }\n    else if(p.x > b.bmax.x - EPS) { n = vec3(-1, 0, 0); c = vec3(0.3, 1, 0.1); }\n    else if(p.y < b.bmin.y + EPS) n = vec3(0,  1, 0);\n    else if(p.y > b.bmax.y - EPS) n = vec3(0, -1, 0);\n    else if(p.z < b.bmin.z + EPS) n = vec3(0,  0, 1);\n    else n = vec3(0, 0, -1);\n    return Hit(tFar, n, c);\n}\n\nHit intersect(Ray r, Sphere s) {\n    vec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if(det < EPS) return MISS;\n    det = sqrt(det);\n    float t = b - det;\n    if(t < EPS) return MISS;\n    return Hit(t, (r.o + t * r.d - s.p) / s.r, s.c);\n}\n\nBox box = Box(vec3(-1), vec3(1));\nSphere spheres[4];\n\nHit intersect(Ray r) {\n    spheres[0] = Sphere(0.25, vec3(0, -0.75, 0), vec3(0.75));\n    spheres[1] = Sphere(0.25, vec3(0, -0.25, 0), vec3(0.75));\n    spheres[2] = Sphere(0.25, vec3(0,  0.25, 0), vec3(0.75));\n    spheres[3] = Sphere(0.25, vec3(0,  0.75, 0), vec3(0.75));\n    Hit hit = MISS;\n    Hit tmp = intersect(r, box);\n    if(tmp.t < hit.t) hit = tmp;\n    for(int i = 0; i < 4; ++i) {\n        tmp = intersect(r, spheres[i]);\n        if(tmp.t < hit.t) hit = tmp;\n    }\n    return hit;\n}\n\nvec3 lpos = vec3(0.4, 0.5, -0.6);\nvec3 lcolor = vec3(0.5);\nfloat lsize = 0.1;\n\nvec3 shadow(Ray r, float len) {\n    for(int i = 0; i < 4; ++i) if(intersect(r, spheres[i]).t < len) return vec3(0);\n    return lcolor;\n}\n\nvec3 radiance(Ray r) {\n    vec3 color = vec3(0);\n    vec3 mask = vec3(1);\n    vec3 lp = lpos + uniformRay(iTime) * lsize;\n    for(int i = 0; i < ITER; ++i) {\n        Hit hit = intersect(r);\n        if(hit.t == TMAX) break;\n        vec3 p = r.o + hit.t * r.d;\n        vec3 l = normalize(lp - p);\n        mask *= hit.c;\n        color += mask * max(0.0, dot(hit.n, l)) * shadow(Ray(p + l * EPS, l), length(lp - p));\n        r = Ray(p, cosineWeightedRay(hit.n, iTime + float(i)));\n    }\n    return color;\n}\n\nmat3 getCamera(vec3 ro) {\n    vec3 z = normalize(ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    return mat3(x, cross(z, x), z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y * vec2(3.0, 1.0);\n    vec3 ro = vec3(sin(mo.x), mo.y, cos(mo.x)) * 2.0;\n    vec3 rd = getCamera(ro) * normalize(vec3(uv, -2));\n    fragColor = vec4(pow(radiance(Ray(ro, rd)), vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}