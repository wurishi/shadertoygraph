{"ver":"0.1","info":{"id":"tljczd","date":"1595176782","viewed":111,"name":"strange elephant ","username":"CyanMARgh","description":"Этот шейдер - анимированное представление фигурки перед печатью. (по аналогии с simple ufo)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","figure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos = vec3(0., .6, -5.5);\nfloat softShadow = 10.;\nfloat depthmax = 40.; \nconst float eps = 1e-4;\nvec3 backcol = vec3(1.,1.,1.)*1.;\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n//SDF operations\n//colored\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//uncolored\nfloat un(float d1, float d2){\n    return d1<d2?d1:d2;\n}\nfloat dif(float d1, float d2){\n    d2*=-1.;\n    return d1>d2?d1:d2;\n}\nfloat smix( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//additioanal operations\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//SDF\nfloat sphere(vec3 pos){\n    return length(pos);\n}\nfloat plane(vec3 n, vec3 pos){\n    return dot(pos, n);\n}\nfloat capsule(vec3 a, vec3 b, float r1, float r2, vec3 p){\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\t\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                           return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat box(vec3 b, vec3 p){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylinder(vec3 a, vec3 b, float r, vec3 p){\n    p-=a;b-=a;\n    float k = dot(b,p)/dot(b,b);\n    float d1 = length(b*k-p)-r;\n    if(k>0.&&k<1.){\n        return d1;\n    }else{\n        float d2 = (abs(k-.5)-.5)*length(b);\n        if(d1>0.){            \n            return sqrt(d1*d1+d2*d2); \n        }else{\n            return d2;\n        }\n    }\n}\n//color functions\nvec3 checkerboard(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return vec3(1.)*((d.x+d.y+d.z)%2==0?1.:.8);\n}\n//scene SDF\nvec4 map(vec3 p){\n    //\"room\"\n    vec4 d0 = vec4(.9,.9,1.,plane(vec3(0.,1.,0.),p)+1.5);\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(0.,0.,-1.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(1.,0.,0.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,box(vec3(1.,1.,1.),p-vec3(0.,-2.,0.))));\n    d0.xyz *= checkerboard(p);\n\n    p+=vec3(.0,.1,.0);\n    \n    \n    vec4 body = vec4(1.,.7,.2,sphere(p-vec3(.0,-.25,0.))-.7);\n    //head\n    {\n        vec3 p_=p;\n        p_.yz*=ro(-.75);\n\t\tp_.z=abs(p_.z);    \n\t    p_.zy*=ro(.8);\n        p_.z=abs(p_.z);    \n\t    p_.zy*=ro(.4);\n        p_.z=abs(p_.z);    \n\t    p_.zy*=ro(.2);\n\t\tvec4 head = vec4(.8,.9,.3,capsule( vec3(0.,0.,0.), vec3(0.,1.2,0.), .4, .15,p_   ));\n    \tbody = cmix(body, head, .2);\n    }\n    //legs\n    {\n        vec3 p_=p;\n    \tp_.xz=abs(p_.xz);    \n\t    p_.xz*=ro(0.8);\n    \tvec4 leg = vec4(.7,.4,.1, sphere(p_-vec3(.0,-.9,.5))-.3);\n\t    body = cmix(body, leg, .05);\n    }\n    //eye\n\t{\n        vec3 p_=p;\n\t\tp_.x=abs(p_.x);    \n\t    p_.zx*=ro(1.3);\n\n        vec4 lid = vec4(.7,.4,.1, cylinder(vec3(0.,-.2,0.),vec3(0.,-.2,-.6),.3,p_));\n        body = cmix(body, lid, .4);\n        vec4 eye = vec4(1.,1.,1.,sphere(p_-vec3(0.,-.2,-.5))-.35);\n\t\teye = cun(eye, vec4(.2,.2,1.,sphere(p_-vec3(0.,-.2,-.56))-.3));\n\t\teye = cun(eye, vec4(.2,.2,.2,sphere(p_-vec3(0.,-.2,-.615))-.25));\n\n        body = cun(body,eye);\n    }\n    //nose\n    {\n        vec4 nose = vec4(.7,.4,.1, capsule(vec3(0.,.1,-.4),vec3(0.,-.8,-.8),.2,.1,p));\n        vec3 p_ = p;\n        p_.x=abs(p_.x);\n        vec4 tusk = vec4(.8,.8,.8, capsule(vec3(0.,-.1,-.4),vec3(.3,-.6,-.8),.1,.06,p_));\n        \n        body = cmix(body, nose,.1);\n        body = cun(body, tusk);\n    }\n    //cut\n    body = cdif(body, vec4(.8,.6,.1, plane(vec3(0.,1.,0.),p)+.9));\n\td0=cun(d0,body);\n    \n    return d0;\n}\n//normal vector by point\nvec3 norm(vec3 pos){\n    const vec2 e = vec2(eps,0.);\n    float d = map(pos).w;\n    return normalize(vec3(\n        map(pos + e.xyy).w-d,\n        map(pos + e.yxy).w-d,\n        map(pos + e.yyx).w-d\n    ));\n}\n\n//color and length of ray\nvec4 rayCast(vec3 eye, vec3 dir){\n    vec3 pos; float depth=0.,dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n        depth += dist;\n        if (dist < eps){\n            break;\n        }else if(depth>depthmax){\n            depth = depthmax+eps;\n            break;\n        }\n    }\n    rc.w=depth;\n    return rc;\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += clamp(h,0.02,2.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\n\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    //direction calculation\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float angle = (1.2+cos(iTime*.4))*.6;\n    eye.xz*=ro(angle);\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.xz*=ro(angle);\n\n    //raymarching\n    vec4 rc = rayCast(eye, dir);\n    float depth = rc.w;\n\n    vec3 pos = eye+dir*depth;\n    vec3 n = norm(pos);\n    pos+=eps*n;\n    \n    vec3 col = rc.xyz;\n    vec3 lighting = vec3(.25);\n\n    if (depth < depthmax){\n\n        // adding 3 point lights and one directional light\n        lighting += getLight(pos, vec3(6., 8., 0.), n, vec3(1.,.9,.9), 15.,false);\n        lighting += getLight(pos, vec3(6., 8., -10.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(-10., 10., -2.), n, vec3(1.,1.,1.), 30.,false);\n        lighting += getLight(pos, vec3(2., 13., -10.), n, vec3(1.,.9,.9), 120.,true);\n        \n        //lighting -= getOcc(pos, n);\n\t\tcol *= lighting;\n    }else{\n        col=backcol;\n    }\n    \n    //compositing color, lighting and fog\n    fragColor = vec4(1.5*log(1.+ col)*exp(-0.003*depth), 1.0);\n}","name":"Image","description":"","type":"image"}]}