{"ver":"0.1","info":{"id":"XXG3WR","date":"1717474739","viewed":28,"name":"Competing Interests","username":"lawa1215","description":"This is just a little experiment using three competing \"species\" each with different required neighbors and different replication rates.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["alife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    /*\n\t\tHere we read the data from Buffer A through iChannel0.\n\t\tThe first parameter of texture is the texture,\n\t\tthe second parameter is where in the texture we sample from.\n\t*/\n    vec4 color = texture(iChannel0, uv);\n    \n    /*\n\t\tAnd here the final color is returned!\n\t\tCheck out the 'Buf A' tab for the rest of the code.\n\t*/\n\tfragColor = vec4(color.xyz, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"highp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float scale = 2.0;\n    vec2 uv = (fragCoord.xy / (iResolution.xy));\n    \n    vec3 color = vec3(0.0);\n\n\n    float r_neighbors = 0.0;\n    float b_neighbors = 0.0;\n    float g_neighbors = 0.0;\n    \n    const float steps = 8.0;\n    \n    for(float i = -steps; i <= steps; i += 1.0)\n    {\n        for( float j = -steps; j <= steps; j += 1.0)\n        {\n        \tvec2 offset = vec2(i, j) / (iResolution.xy);\t\t // Scale the offset down\n        \tvec4 lookup = texture(iChannel0, uv + offset); // Apply offset and sample\n        \tr_neighbors += lookup.x;\t\t\t\t\t\t\t // Accumulate the result\n            b_neighbors += lookup.z;\n            g_neighbors += lookup.y;\n        }\n    }\n\n    \n\n    float r_cell = texture(iChannel0, uv).x;\n    float b_cell = texture(iChannel0, uv).z;\n    float g_cell = texture(iChannel0, uv).y;\n    \n\n    if (r_neighbors > b_neighbors && b_neighbors < g_neighbors && b_neighbors > 1. * steps) {\n        color = vec3(0.0,1.0,0.0);\n    }\n    else if (r_neighbors > g_neighbors && g_neighbors < b_neighbors && g_neighbors > 1. * steps) {\n        color = vec3(1.0,0.0,0.0);\n    }\n    else if (g_neighbors > r_neighbors && r_neighbors > b_neighbors && r_neighbors > 0.5 * steps) {\n        color = vec3(0.0,0.0,1.0);\n    }\n    else if (g_neighbors > 2.*steps && b_neighbors > 1. * steps * g_neighbors) {\n        color = vec3(0.0,1.0,0.0);\n    }\n    /*else if (g_neighbors < steps / 1. && b_neighbors < steps / 1. && r_neighbors > b_neighbors && b_neighbors > g_neighbors){\n        color = vec3(0.0,1.0,0.0);\n    }*/\n    else {\n        color = vec3(0.0,0.0,1.0);\n    //    color = vec3(rand(fragCoord),1.0,rand(vec2(rand(fragCoord))));\n    }\n    /*\n\t\tIn order to get any interesting behaviour, we need a non-uniform\n\t\tstarting-conditions. One simple way to do this is to feed\n\t\ta noise texture into the buffer for the first frame.\n\t\tWhen the condition fails, the previous frame will hold the noise texture ( iChannel1 ),\n\t\tand the Game of Life can begin!\n\t*/\n    if(iTime < 1.0) { // can also use iFrame == 0, but seems less reliable.\n        color = texture(iChannel1, fragCoord.xy / iResolution.xx).xyz;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}