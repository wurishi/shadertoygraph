{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n \n Clouds are awesome! And also horribly hard to render. Well, hard is not the right\n word for it, computationally expensive is a much more accurate term.\n You can use the mouse to look around.\n\n This shader is based on what I did in my older shader,\n\n https://www.shadertoy.com/view/4sl3Dn \n\n But there is a huge difference, the domain is limited to small sphere there, \n there are rays that never need to evaluate the volumetric renderinc functions. \n For obvious reasons it's much faster.\n\n Here I have basically the same code, just a bit different setup. The volumetric\n functions are evaluated after tracing an infinite plane. When the ray hits the\n surface of that infinite plane the raymarcher takes N iterations to render the\n cloud. For each iteration another M iterations are used to determine the illumination.\n\n The density function is evaluated N*M times per pixel. This is the computationally\n expensive part because the density funtion is the product of a 4d noise function\n and a 2d noise function.\n\n There are a few rendering artifacts when the quality is reduced. However I managed to\n find a good configuration. With 17 steps the artifacts aren't visible anymore and\n it turns out that even 3 illum steps produces decent results. This reduces the \n amount of times the density function needs to be evaluated to 51.\n\n Feel free to play around with the parameters. \n Definitely check out wind_speed, morph_speed nad density_modifier.\n \n 30/05/2013:\n - published\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define quality 17 // nr of steps taken to evaluate the density\n#define illum_quality 3 // nr of steps for illumination\n#define noise_use_smoothstep //different interpolation for noise functions\n\n#define wind_speed 0.1\n#define morph_speed 0.12\n\n#define density_modifier 0.00\n#define density_osc_amp 0.04\n#define density_osc_freq 0.07\n\n#define const_light_color vec3(2.8,2.3,0.7)\n#define const_dark_color vec3(.5,.55,.7)\n#define const_sky_color vec3(0.2,0.46,0.8)\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat hashmix(vec4 p0, vec4 p1, vec4 interp)\n{\n\tfloat v0 = hashmix(p0.xyz+vec3(p0.w*17.0,0.0,0.0),p1.xyz+vec3(p0.w*17.0,0.0,0.0),interp.xyz);\n\tfloat v1 = hashmix(p0.xyz+vec3(p1.w*17.0,0.0,0.0),p1.xyz+vec3(p1.w*17.0,0.0,0.0),interp.xyz);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec4(0.0),vec4(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[3]);\n}\n\nfloat noise(float p) // 1D noise\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nfloat noise(vec2 p) // 2D noise\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nfloat noise(vec4 p) // 4D noise\n{\n\tvec4 pm = mod(p,1.0);\n\tvec4 pd = p-pm;\n\treturn hashmix(pd,(pd+vec4(1.0,1.0,1.0,1.0)), pm);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.y = cosa*vo.y - sina*vo.z;\n\tv.z = sina*vo.y + cosa*vo.z;\n\treturn v;\n}\n\t\nvec3 cc(vec3 color, float factor,float factor2) //a wierd color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvec3 plane(vec3 p, vec3 d) //returns the intersection with a predefined plane\n{\n\t//http://en.wikipedia.org/wiki/Line-plane_intersection\n\tvec3 n = vec3(.0,1.0,.0);\n\tvec3 p0 = n*4.8;\n\tfloat f=dot(p0-p,n)/dot(n,d);\n\tif (f>.0)\n \treturn p+d*f;\n\telse\n\t\treturn vec3(.0,.0,.0);\n}\n\nvec3 ldir = normalize(vec3(-1.0,-1.0,-1.0)); //light direction\nfloat time = .0; //global time\n\nfloat density(vec3 p) //density function for the cloud\n{\n\tif (p.y>15.0) return 0.0; //no clouds above y=15.0\n\tp.x+=time*float(wind_speed);\n\tvec4 xp = vec4(p*0.4,time*morph_speed+noise(p));\n\tfloat nv=pow(pow((noise(xp*2.0)*.5+noise(xp.zx*0.9)*.5),2.0)*2.1,\t2.);\n\tnv = max(0.1,nv); //negative density is illegal.\n\tnv = min(0.6,nv); //high density is ugly for clouds\n\treturn nv;\n}\n\nfloat illumination(vec3 p,float density_coef)\n{\n\tvec3 l = ldir;\n\tfloat il = 1.0;\n\tfloat ill = 1.0;\n\t\n\tfloat illum_q_coef = 10.0/float(illum_quality);\n\t\t\n\tfor(int i=0; i<int(illum_quality); i++) //illumination\n\t{\n\t\til-=density(p-l*hash(p.xy+vec2(il,p.z))*0.5)*density_coef*illum_q_coef;\n\t\tp-=l*illum_q_coef;\n\t\t\n\t\tif (il <= 0.0)\n\t\t{\n\t\t\til=0.0;\n\t\t\tbreak; //light can't reach this point in the cloud\n\t\t}\n\t\tif (il == ill)\n\t\t{\n\t\t\tbreak; //we already know the amount of light that reaches this point\n\t\t\t//(well not exactly but it increases performance A LOT)\n\t\t}\n\t\till = il;\n\t}\n\t\n\treturn il;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\ttime = iTime+385.0; //i want the sun visible in the screenshot\n\t\n\tvec3 p = vec3(.0,.0,.0); //ray position\n\tvec3 d = vec3(uv,1.0);\n\td.z-=length(d)*.2;\n\t\n\td = rotate_x(d,-1.19-1.0*mouse.y);\n\td = rotate_y(d,1.5+-7.0*mouse.x);\n\t\n\td = normalize(d); //ray direction\n\t\n\tfloat acc = .0;\n\t\n\tp = plane(p,d);\n\t\n\tfloat illum_acc = 0.0;\n\tfloat dense_acc = 0.0;\n\tfloat density_coef =0.13+float(density_modifier)\n\t\t+sin(iTime*float(density_osc_freq))*float(density_osc_amp);\n\tfloat quality_coef = 20.0/float(quality);\n\t\n\tfor (int i=0; i<quality; i++)\n\t{\n\t\tp+=d*quality_coef*.5;\n\t\t\n\t\tfloat nv = density(p+d*hash(uv+vec2(iTime,dense_acc))*0.25)*density_coef*quality_coef;\n\t\t//evaluate the density function\n\t\t\n\t\tvec3 sp = p;\n\t\tdense_acc+=nv;\n\t\t\n\t\tif (dense_acc>1.0)\n\t\t{\n\t\t\tdense_acc=1.0; //break condition: following steps do not contribute \n\t\t\tbreak; //to the color because it's occluded by the gas\n\t\t}\n\t\t\n\t\tfloat il = illumination(p,density_coef);\n\t\t\n\t\tillum_acc+=max(0.0,nv*il*(1.0-dense_acc)); \n\t\t//nv - alpha of current point\n\t\t//il - illumination of current point\n\t\t//1.0-dense_acc - how much is visible of this point\n\t}\n\n\td=normalize(d);\n\t\n\t//color mixing follows\n\t\n\tvec3 illum_color = const_light_color*illum_acc*0.50;\n\t\n\tfloat sun = dot(d,-ldir); sun=.5*sun+.501; sun = pow(sun,400.0);\n\tsun += (pow(dot(d,-ldir)*.5+.5,44.0))*.2;\n\tvec3 sky_color = const_sky_color*(1.1-d.y*.3)*1.1;\n\t\n\tvec3 dense_color = mix(illum_color,const_dark_color,.6)*1.4; //color of the dark part of the cloud\n\t\n\tsky_color=sky_color*(1.0-uv.y*0.2)+vec3(.9,.9,.9)*sun;\n\n\tvec3 color = mix(sky_color,(dense_color+illum_color*0.33)*1.0,smoothstep(0.0,1.0,dense_acc)); color-=length(uv)*0.2;\n\n\tcolor+=hash(color.xy+uv)*0.01; //kill all color banding\n\tcolor =cc(color,0.42,0.45);\n\t\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdX3W4","date":"1369943012","viewed":3334,"name":"More Clouds","username":"mu6k","description":"Clouds are awesome! And also horribly hard to render. Well, hard is not the right word for it, computationally expensive is a much more accurate term. You can use the mouse to look around.","likes":53,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","cloud","volumetric"],"hasliked":0,"parentid":"","parentname":""}}