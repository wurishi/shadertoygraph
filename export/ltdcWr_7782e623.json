{"ver":"0.1","info":{"id":"ltdcWr","date":"1532371318","viewed":255,"name":"Dolly Zoom","username":"belfry","description":"Dolly zoom example.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","fbm","sheep","dollyzoom","vertigoeffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DOLLY_ZOOM_ENABLED 1\n\nvec2 rotate(float angle, vec2 v) {\n    return mat2x2(cos(angle), -sin(angle), sin(angle), cos(angle)) * v;\n}\n\nvec3 rotate3(vec3 euler, vec3 v) {\n    v.xy = rotate(euler.z, v.xy);\n    v.xz = rotate(-euler.y, v.xz);\n    v.yz = rotate(euler.x, v.yz);\n    return v;\n}\n\nfloat basicSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sphere(vec3 p, vec3 pos, float radius) {\n    return basicSphere(p - pos, radius);\n}\n\nfloat basicBox(vec3 p, vec3 extent) {\n    vec3 a = abs(p) - extent;\n    return max(a.x, max(a.y, a.z));\t// max norm\n}\n\nfloat box(vec3 p, vec3 pos, vec3 extent, vec3 rot) {\n    return basicBox(rotate3(rot, p - pos), extent);\n}\n\nfloat basicDiamond(vec3 p, vec3 extent) {\n    vec3 q = abs(p) / extent;\n    return q.x + q.y + q.z - 1.;\t// manhatten distance\n}\n\nfloat diamond(vec3 p, vec3 pos, vec3 extent, vec3 rot) {\n    return basicDiamond(rotate3(rot, p - pos), extent);\n}\n\nfloat sheep(vec3 p, vec3 pos, vec3 rot) {\n    vec3 q = rotate3(rot, p - pos);\n    float neck = box(q, vec3(0.8,.66,.0), vec3(0.3, 0.6, 0.3), vec3(0., .775, -0.7));\n    float head = basicDiamond(q - vec3(1.5,1.2,.0), vec3(1., 0.6, 0.6));\n    float body = basicSphere(q - vec3(0., -0.45, 0.), 1.);\n    body = smin(body, sphere(q, vec3(-0.75, -0.57, 0.), 1.15), 0.1);\n    body = smin(body, sphere(q, vec3(-1.5, -0.45, 0.), 1.), 0.1);\n    float leftEar = diamond(q, vec3(.95,1.6,.4), vec3(.4, .5, 0.25), vec3(0.9, 0.3, 0.3));\n    float rightEar = diamond(q, vec3(.95,1.6,-.4), vec3(.4, .5, 0.25), vec3(-0.9, 0.3, 0.3));\n    float leg = box(abs(q - vec3(-.75, -1.3, 0.)), vec3(1.1, 0., 0.5), vec3(0.15, 1., 0.15), vec3(0.));\n    float tail = sphere(q, vec3(-2.3, -0.15, 0.), .3);\n    return smin(tail, smin(leg, min(rightEar, min(leftEar, smin(body, smin(neck, head, 0.5), 0.15))), 0.2), 0.1);\n}\n\nvec3 vnoise(vec3 p, float s) {\n    vec3 q = floor(p / s) * s;\n    vec3 i = (p - q) / s;\n    i = smoothstep(vec3(0.), vec3(1.), i);\n    vec2 eps = vec2(s, 0.);\n    vec3 lbf = hash33(q);\n    vec3 lbb = hash33(q + eps.yyx);\n    vec3 luf = hash33(q + eps.yxy);\n    vec3 lub = hash33(q + eps.yxx);\n    vec3 rbf = hash33(q + eps.xyy);\n    vec3 rbb = hash33(q + eps.xyx);\n    vec3 ruf = hash33(q + eps.xxy);\n    vec3 rub = hash33(q + eps.xxx);\n    vec3 BF = mix(lbf, rbf, i.x);\n    vec3 BB = mix(lbb, rbb, i.x);\n    vec3 UF = mix(luf, ruf, i.x);\n    vec3 UB = mix(lub, rub, i.x);\n    vec3 F = mix(BF, UF, i.y);\n    vec3 B = mix(BB, UB, i.y);\n    return mix(F, B, i.z);\n}\n\nvec3 fbm(vec3 p, float a) {\n    float t = 0.;\n    vec3 n = vec3(0.);\n    for (float s = 1.; s > a; s *= .5) {\n        n += vnoise(p, s) * s;\n        t += s;\n    }\n    return n / t;\n}\n\nfloat sdf(vec3 p, out int id) {\n\tfloat bg = max(sphere((mod(p, 2.)) - 1., vec3(0.), .8), -basicBox(p, vec3(14.)));\n    float s = sheep(p, vec3(0., 0., -10.), vec3(0., -0.2, 0.));\n    id = s < bg ? 1 : 0;\n    return min(bg, s);\n}\n\nvec3 gradient(vec3 p, float dist) {\n    vec2 eps = vec2(0.005, 0.);\n    int id;\n    float dx = sdf(p + eps.xyy, id) - dist;\n    float dy = sdf(p + eps.yxy, id) - dist;\n    float dz = sdf(p + eps.yyx, id) - dist;\n    return normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 camPos = vec3(0., 0., 2.);\t\t// start position of camera\n    vec3 objPos = vec3(0., 0., -10.);\t// start position of object we are focusing on\n    float fov = radians(60.);\t// start fov\n\n    /*\n\t *\tDolly Zoom Computation\n     *\n     *       /|\n     *      / |\n     *     /  |\n\t *    /   |x\n     *   /|   |\n     *  / |w  |\n     * /__|___|\n     *  d\n     *    z\n     *\n     * x: Size of object.\n     * z: Distance of object to camera\n     * d: Distance of projection plane to camera\n     * w: Size of projected object on projection plane\n     *\n     * Observation: x/z = w/d\n     * x and w are constant!\n     * Hence: w = d * x/z\n     * Update z and compute new d: d' = w * z'/x     =>     d' = d / z * z'\n     * Note: Multiplication and division of x cancels out, therefore we don't need it at all!\n\t * In other words we may assume x = 1\n\t */    \n    float z = length(camPos - objPos);\t// start distance from object we are focusing on\n    float d = 1./tan(.5 * fov);\t// start projection plane distance from eye\n    float width = d / z;\t// size of projected object on projection plane\n    \n    camPos += vec3(0., 0., 8. * sin(iTime));\t// updated camera position\n    z = length(camPos - objPos);\t// new distance from object we are focusing on\n    #if DOLLY_ZOOM_ENABLED == 1\n    d = width * z;\t// new projection plane distance\n    #endif\n    \n    vec3 dir = normalize(vec3(uv * 2. - 1., -d));\n    dir.x *= iResolution.x / iResolution.y;\n    vec3 camRot = vec3(0., 0., 0.);\n    dir = rotate3(-camRot, dir);\n    float dist;\n    float t = 0.;\n    float i = 0.;\n    vec3 p;\n    bool hit = false;\n    float stepSize = .3;\n    int id;\n    for (; i < 100.; i++) {\n        p = camPos + dir * t;\n        dist = sdf(p, id);\n        t += dist * stepSize;\n        if (abs(dist) < 0.01) {\n            hit = true;\n            break;\n        }\n    }\n    if (hit) {\n        vec3 normal = gradient(p, dist);\n        if (id == 1)\n            normal = normalize(normal + fbm(p, 0.01) - 0.5);\n        vec3 lighting = vec3(0.2);\n\t\tvec3 lightDir = vec3(1.);\n        float diffuse = max(0., dot(lightDir, normal)) * 0.6;\n        vec3 col = lighting + diffuse;\n        if (id == 0)\n            col *= vec3(0.5, 0.5, 1.);\n        fragColor = vec4(col, 1.);\n    } else {\n    \tfragColor = vec4(0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//----------------------------------------------------------------------------------------\n//----------------  taken from: https://www.shadertoy.com/view/4djSRW  -------------------\n//----------------------------------------------------------------------------------------\n\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n//---------  taken from: https://iquilezles.org/articles/smin  -----------\n//----------------------------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//----------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------","name":"Common","description":"","type":"common"}]}