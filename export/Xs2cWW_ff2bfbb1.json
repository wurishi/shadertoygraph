{"ver":"0.1","info":{"id":"Xs2cWW","date":"1493238612","viewed":287,"name":"Audio Experiment","username":"KylBlz","description":"Wait a minute for the song to start up and the special effects to kick in!\nShadertoy is broken on some platforms; if you see black patches to the left and right, un-comment \"#define GLITCH\" in Buffer B, line 3.","likes":4,"published":1,"flags":112,"usePreview":0,"tags":["beat","experiment","audio","effects","special"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tbuffer A smooths audio signal\n\tbuffer B renders height map, does beat detection\n\tbuffer C does 3D rendering\n\tbuffer D is for controls\n*/\n\n//this applies the Begin Again effect on bass punches\n\n#define steps 32\n#define d vec2(.6/iResolution.x, -.6/iResolution.x)\n#define tex(a, b) .25*(textureLod(a, b+d, 0.)+textureLod(a, b-d, 0.)+textureLod(a, b+d.yx, 0.)+textureLod(a, b-d.yx, 0.))\n\nvec3 smudge(in sampler2D iChannel, in vec2 uv, in vec2 dirlen) {\n    vec3 col = textureLod(iChannel,uv,0.).rgb, smpcol = col, o = col;\n    vec2 smp = uv, dir = normalize(dirlen)/iResolution.xx;\n    float len = length(dirlen), brightest = 0.;\n    if (len < .001) return col;\n    for (int i = 0; i < steps; i++) {\n        smp += dir;\n        smpcol = tex(iChannel, smp).rgb;\n        float brightness = length(smpcol);\n        if (float(i)/iResolution.x > len) break;\n        if (brightness > brightest && brightness > sqrt(float(i)/float(steps)*4.)) {\n            brightest = brightness;\n            col = smpcol;\n        }\n    }\n    return (length(o) < length(col))? col: o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float sfxfade = min(1.,iTime*iTime*.0004),\n          bassHit = sfxfade * textureLod(iChannel1, vec2(.995,0.), 0.).r;\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(smudge(iChannel0, uv, vec2(0.,-.04)*bassHit), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXXRr","filepath":"https://soundcloud.com/pro-dropped/pendulum-vault-dropped-4","previewfilepath":"https://soundcloud.com/pro-dropped/pendulum-vault-dropped-4","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//smooth audio stream\n\n#define tex(a,b) textureLod(a,b,0.)\n#define gSmp(a,b) (k7[a]*tex(iChannel,uv-px*b*vec2(1.,0.)))\n\nfloat[] k7 = float[](.010805, .074929, .238727, .351078);\nvec4 gaussian7sample(in sampler2D iChannel, in vec2 uv, in float px) {\n    return gSmp(0,3.)+gSmp(1,2.)+gSmp(2,1.)+gSmp(3,0.)+gSmp(2,1.)+gSmp(1,2.)+gSmp(0,3.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float fft = gaussian7sample(iChannel0, vec2(uv.x,0.), 1./iChannelResolution[0].x).x;\n    fragColor = vec4(fft);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//height map\n//if you cant get the full data from buffer A\n//#define GLITCH\n\n//Thanks Fabrice\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): tex( iChannel3, U/16. + fract( floor(vec2(c, 15.999-float(c/16))) / 16.))\n#define initMsg vec4 T = vec4(0)\n#define endMsg return length(T.yz)==0. ? 0. : T.x\n\n#define tex(a,b) textureLod(a,b,0.)\n#define gSmp(a,b) (k7[a]*tex(iChannel,uv-px*b*vec2(1.,0.)))\n\nfloat msg_and(vec2 U) { initMsg; C(83);C(111);C(117);C(110);C(100); endMsg; }\n\nfloat[] k7 = float[](.010805, .074929, .238727, .351078);\nvec4 gaussian7sample(in sampler2D iChannel, in vec2 uv, in float px) {\n    return gSmp(0,3.)+gSmp(1,2.)+gSmp(2,1.)+gSmp(3,0.)+gSmp(2,1.)+gSmp(1,2.)+gSmp(0,3.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 px = 1./iResolution.xy, uv = fragCoord.xy * px;\n    if (iFrame < 10) {\n        //render the \"Sound\" message\n        fragColor = vec4(1.25*(uv.y*3.+.3)*msg_and(uv*vec2(8.,6.)+vec2(.8,-.2)));\n        return;\n    }\n    if (uv.y < px.y) {\n        float fft = 0.;\n#ifdef GLITCH\n        //detect bass punch\n        if (uv.x > .99) fft = step(.99, tex(iChannel0, vec2(0.)).x);\n\t\t//detect hi hat and snare\n        else if (uv.x > .98) fft = step(.28, tex(iChannel1, vec2(.25, px.y)).x - tex(iChannel0, vec2(.25, 0.)).x + (uv.x*.2));\n#else\n        //detect bass punch\n        if (uv.x > .99) fft = step(.95, tex(iChannel0, vec2(.01, 0.)).x);\n\t\t//detect hi hat and snare\n        else if (uv.x > .98) fft = step(.4, tex(iChannel1, vec2(.94, px.y)).x - tex(iChannel0, vec2(.94, 0.)).x + (uv.x*.2));\n#endif\n        else fft = gaussian7sample(iChannel0, vec2(uv.x, 0.), px.x).x + (uv.x*.2);\n        //smooth audio data\n        fragColor = vec4(clamp((tex(iChannel1, uv+vec2(0., px.y)).r + fft)*.5, 0., 1.));\n    } else {\n        //advance tape-like storage\n        fragColor = tex(iChannel1, uv-vec2(0., px.y));\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//rendering\n\n//new stuff:\n//plannar parallax occlusion mapping\n//\tgeneralized for any orientation\n//\tinterpolation step at end\n//quadratic intersection\n//in-place CSG functions\n\n// 3 .'.  '.'\n// 4 ::   ::\n//#define MSAA\t\t3\n#define GAMMA\t\t1.\n#define EXPOSURE\t1.\n\n//some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) texture(a,b)\n#define texComp(a,b,c) vec3max((tex(a, b).rgb * c))\n\n//segment functions\n#define valid(a) (a.t.y < zfar)\n#define overlap(a, b) ((a.t.y > b.t.x) && (a.t.x < b.t.y))\n#define contains(a, b) ((a.t.x > b.t.x) && (a.t.y < b.t.y))\n#define minT(a) (a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x\n\nconst float\teps = .0001, ieps = .9999,\n\t\t\tzfar = 1000., sml = .001, isml = .999,\n\t\t\tpi_rcp = .3183098, pi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732051;\n\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5),\n\t\t\tROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\n//Absorb, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 a, e; vec2 s, u; float r, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, distance material\nstruct hit { vec3 l, n; float d; mat m; };\n//Origin, Direction, Color, current material\nstruct ray { vec3 o, d, c; mat m; };\n//location, coefficients c[0]*L^2+c[1].xxy*L.xxy+c[1].yzz*L.yzz++c[2]+c[3].w, orientation, Material, id\nstruct qdr { vec3 l; mat4 c; mat3 o; mat m; int d; };\n//center, size, orientation Material, id\nstruct box { vec3 c, s; mat3 o; mat m; int d; };\n//center Location, Radius, Material, id\nstruct sph { vec3 l; float r; mat m; int d; };\n//Location, Normal, Info(size x,y,'depth'), Material, id\nstruct pln { vec3 l; mat3 o; mat m; int d; };\n\nconst mat nullMat = mat(v30, v30, v20, v20, 0., 0., 0);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, zfar, nullMat);\nconst vec2 nullT = vec2(zfar, 0.);\n\n////////////////////// Materials\nconst mat\n//conductor\n\t_air = mat(vec3(.99), vec3(.99), vec2(.01), vec2(.1), 1.0003, 0., 0),\n//emissive\n\t_wht_e = mat(vec3(2.), vec3(2.), vec2(2.), vec2(.2), -1., -1., 30),\n//dynamic materials\n\t_cmap = mat(v30, v30, v20, v20, -1., 0., 40),\n\t_chr = mat(v30, v30, v20, v20, -1., 0., 41),\n\t_dbg = mat(v30, v30, v20, v20, -1., 0., 99);\n\n////////////////////// Primitives\nsph sph0 = sph(v30, 30., _cmap, 21),\n\tlit0 = sph(v30, .1, _dbg, 22);\npln pln0 = pln(vec3(0., -1., 0.), mat3(vec3(0.,0.,-1.),vec3(0.,1.,0.),vec3(1.,0.,0.)), _chr, 11);\nqdr qdr0 = qdr(v31, mat4(v41, v41, v40, -v41), mat3(1.), _chr, 31);\n\n////////////////////// some tools\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(101.7, 683.11));\n    return fract(sin(h)*467.709);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle); vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x);  o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n\tif (n.z < -ieps) {\n\t\tf = vec3(0., -1., 0.);\n\t\tr = vec3(-1., 0., 0.);\n\t} else {\n\t\tfloat a = 1. / (1. + n.z);\n\t\tfloat b = -n.x*n.y*a;\n\t\tf = vec3(1. - n.x*n.x*a, b, -n.x);\n\t\tr = vec3(b, 1. - n.y*n.y*a, -n.y);\n\t}\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end), theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nvec3 spectrum(float x) {\n    x = x * 2.1 - 0.555;\n    vec4 v = vec4(clamp(x, -.6, 0.6), clamp(x, 0.05, 1.05), clamp(x, 0.65, 1.55), clamp(x, 1.16, 1.55));\n    v += vec4(0.0, -0.55, -1.1, -1.35);\n    v *= vec4(0.8, 1.0, 1.1, 2.5);\n    v = (cos(v * v * pi * 4.) * 0.5 + 0.5);\n    v.r += v.a * 0.5;\n    return v.rgb;\n}\nvec3 norm3(sampler2D iChannel, in vec3 comp, in vec3 px, in vec2 uv) {\n\tfloat s01 = texComp(iChannel, uv + px.xy, comp), s21 = texComp(iChannel, uv + px.zy, comp),\n\t\ts10 = texComp(iChannel, uv + px.yx, comp), s12 = texComp(iChannel, uv + px.yz, comp);\n\tvec3 va = normalize(vec3(px.xy*4., s21 - s01)),\n\t\tvb = normalize(vec3(px.yx*4., s12 - s10));\n\treturn cross(va, vb);\n}\n\n////////////////////// Dynamic material implementation\nmat cmap(in ray r, inout hit h) {\n\treturn mat(\n\t\tv30,\n\t\ttex(iChannel2, r.d).rgb,\n\t\tv20, v20, //gloss and subsurface not implemented yet\n\t\t_cmap.r, 0., _cmap.d);\n}\nmat chr(in ray r, inout hit h) {\n    float y = h.l.y*.95+1.9;\n    vec3 c = tex(iChannel2, reflect(r.d, pln0.o[1]*.8 + h.n*.2)).rgb,\n         s = spectrum(y)*(.5+y);\n\treturn mat(\n\t\tv30,\n\t\ts*c+s*vec3(.4,.2,.8)+(s.r*s.b)*.333,\n\t\tv20, v20,\n\t\t_chr.r, 0., _chr.d);\n}\n\nvoid lt(inout seg o, in seg s) {\n    if (o.t.x < s.t.x && o.t.y > 0.) return;\n    if (s.t.y > 0.) { o = s; return; }\n    o = nullSeg;\n}\nvec3 nSphere(in vec3 l, in sph s) {\n\treturn (l - s.l) / s.r;\n}\nseg tSphere(in ray r, in sph s) {\n\tvec3 oc = r.o - s.l;\n\tfloat c = dot(oc, oc) - s.r * s.r, b = -dot(oc, r.d), h = b*b - c;\n\tif (h < 0.) return nullSeg;\n\th = sqrt(h);\n\treturn seg(vec2(b-h, b+h), ivec2(s.d, -s.d));\n}\nseg tPlane(in ray r, in pln p) {\n\tfloat t = dot(p.o[1], p.l - r.o) / dot(p.o[1], r.d);\n\treturn seg(vec2(t, t + eps), ivec2(p.d, -p.d));\n}\n\n////////////////////// Segment operators upgraded to work in-place\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n} \n////////////////////// Hit functions\nvoid lt(inout hit o, in hit h) {\n\tif (h.d < o.d) o = h;\n} \nhit traceSphere(in ray r, in sph s) {\n\tseg g = tSphere(r, s);\n\tfloat d = minT(g.t);\n\tvec3 l = r.o + r.d * d;\n\treturn hit(l, nSphere(l, s), d, s.m);\n}\nhit tracePlane(in ray r, in pln p) {\n\tseg s = tPlane(r, p);\n\tfloat d = minT(s.t);\n\treturn hit(r.o + r.d * d, p.o[1], d, p.m);\n}\nhit tracePlanePOM(in ray r, in pln p, in sampler2D heightMap, in vec3 comp, in float scale, in float heightScale) {\n    hit h = tracePlane(r, p);\n    //bail if no intersection\n\tif (h.d >= zfar) return h;\n    vec3 l = v30, uvw = l, ro = h.l - p.l;\n\tfloat depth = 0., height = 0., ld = 0., mar = 0.,\n        //a balance between distance and viewing angle with respect to max steps\n\t\ts = max(distance(r.o, h.l)*.03, .03 / abs(dot(r.d, h.n)));\n\t//start ray marching\n\tfor (int i = 0; i < 32; i++) {\n\t\tmar += s;\n\t\tl = ro + r.d*mar;\n\t\t//project onto surface tangent, normal, bitangent\n\t\tuvw = vec3(dot(l, p.o[0]), dot(l, p.o[1]), dot(l, p.o[2]));\n        depth = abs(uvw.y);\n\t\theight = heightScale - texComp(heightMap, fract(uvw.xz*scale), comp) * heightScale;\n\t\t//exit if ray falls below height map\n        if (depth > height) break;\n        ld = height - depth;\n\t}\n\t//lerp intersection to smooth\n\tfloat cd = depth - height,\n        //estimate at what point during the step we crossed\n        lerp = 1. - clamp(ld / (ld + cd), 0., 1.);\n\tmar -= s*lerp;\n\tl = ro + r.d*mar;\n    //update hit info\n\th.l = l + p.l;\n\th.d += mar;\n\t//get normal, somehow get heightMap resolution..\n\tvec3 px = 2. / iResolution.yyy * vec3(-1., 0., 1.);\n\tuvw = vec3(dot(l, p.o[0]), dot(l, p.o[1]), dot(l, p.o[2]));\n\t//inverse rotate normal so plane orientation works\n\th.n = norm3(heightMap, comp, px, fract(uvw.xz*scale)).rbg * vec3(-1., 1., -1.) * inverse(p.o);\n\treturn h;\n}\n\n//updates dynamic materials (ghetto, find better solution)\nvoid updateMaterials(inout hit h, in ray r) {\n\tif (h.m.d < 40) return;\n\telse if (h.m.d == _chr.d) h.m = chr(r, h);\n\telse if (h.m.d == _cmap.d) h.m = cmap(r, h);\n}\n\n//calculates where the ray intersects\nhit traceScene(in ray r) {\n\thit ret = nullHit, h = nullHit;\n    //sort by number of pixels that will be seen to reduce work\n\tlt(ret, tracePlanePOM(r, pln0, iChannel0, vec3(1., 0., 0.), .03, 2.));\n\tlt(ret, traceSphere(r, sph0));\n    return ret;\n}\n\n//here we go\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.y *= iResolution.y / iResolution.x;\n    //interact with music\n    float sfxfade = min(1.,iTime*iTime*.0004),\n          bassHit = sfxfade * tex(iChannel0, vec2(.995,0.)).r,\n          drum = sfxfade * tex(iChannel0, vec2(.985,0.)).r,\n          ambience = tex(iChannel0, vec2(.975,0.)).r,\n          rnd = hash12(uv.yy*eps*iTime),\n          treble = clamp(1. + drum * rnd, 0., 2.);\n\t//get input\n\tvec3 l = tex(iChannel1, POS / iResolution.xy).xyz,\n\t\to = tex(iChannel1, ROT / iResolution.xy).xyz,\n\t\td = rotateXY(normalize(vec3(uv, 1.-bassHit*.1)), o.xy + vec2(0.,treble*treble*.01));\n\t//update objects\n    qdr0.c[1].xyz = .5+.5*sin(iTime + vec3(0.,pi2*.333,pi2*.666));\n\tlit0.l = l + rotateXY(vec3(0., 0., 1.), o.xy) * 2.;\n\tsph0.l.xz = l.xz;\n\t//begin tracing\n\thit res;\n\t//final color\n\tvec3 final = v30;\n#ifndef MSAA\n\tray r = ray(l, d, _air.a, _air);\n#else\n    //orthonormal basis for tangent and bitanget\n\tvec3 uu = v30, vv = v30;\n\tfloat px = 1. / iResolution.y;\n\tbasis(d, uu, vv);\n\tuu *= px;\n\tvv *= px;\n#if MSAA == 3\n\tif (fract(fragCoord.x*.5 + eps) < sml) uu *= -1.;\n\tvec3[] offsets = vec3[](d + uu*s60, d - uu*s60 + vv, d - uu*s60 - vv);\n#elif MSAA == 4\n\tvec3[] offsets = vec3[](d + uu, d - uu, d + vv, d - vv);\n#endif\n\t//bounce around a few times\n\tfor (int i = 0; i < MSAA; i++) {\n\t\t//start the ray at the camera in starting material\n\t\tray r = ray(l, normalize(d + offsets[i]), _air.a, _air);\n#endif\n\t\t//trace scene\n\t\tres = traceScene(r);\n\t\t//update dynamic materials\n\t\tupdateMaterials(res, r);\n\t\t//add colors\n\t\tfinal += r.c * res.m.e;\n#ifdef MSAA\n\t}\n\tfinal /= float(MSAA);\n#endif\n    float fragDepth = res.d,\n          eye = sfxfade*clamp(pow(dot(uv, uv), 2.)*(1.-bassHit), 0., 1.);\n\tfinal = pow(final*EXPOSURE+clamp(treble-1.5, 0., 1.), vec3(GAMMA+eye*5.));\n\tif (res.m.d == _cmap.d) fragDepth = sph0.r*2.;\n\tfragColor = vec4(final, fragDepth+eye*5.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n#define MAX_ACCELERATION      16.\n#define MAX_VELOCITY          4.\n#define FRICTION              2.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n#define tex(a,b) textureLod(a,b,0.)\n\n//half pi\nconst float pi_5 = 1.5707963;\n\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(-1.6, 3., -6., 0.),\n    \t   INIT_VEL = vec4(0., -99., 99., 0.),\n    \t   INIT_ROT = vec4(-.2, pi_5, 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        tex(iChannel1, KEY_D).x - tex(iChannel1, KEY_A).x + tex(iChannel1, KEY_RIGHT).x - tex(iChannel1, KEY_LEFT).x,\n        tex(iChannel1, KEY_SPACE).x - tex(iChannel1, KEY_SHIFT).x,\n        tex(iChannel1, KEY_W).x - tex(iChannel1, KEY_S).x + tex(iChannel1, KEY_UP).x - tex(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return tex(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = tex(iChannel0, vec2(q, 0.));\n    \n    //set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_MOU;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    }\n    \n    if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n        value.y = mouse.x - mouse.z + rot.y;\n        value.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        //limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        //collision detection?\n        if (value.y < -1.99) value.y = -1.99;\n    }\n    \n    fragColor = vec4(value);\n    return;\n}","name":"Buffer D","description":"","type":"buffer"}]}