{"ver":"0.1","info":{"id":"llKXWm","date":"1484693013","viewed":216,"name":"Normalized Phong","username":"sakib","description":"First shot at an energy-conserving BRDF. Feedback welcome.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["phong","normalized","energy","conserving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/********************************************************************\nNormalized Phong Shading\n\nSee : https://seblagarde.wordpress.com/2011/08/17/hello-world/\n\nAuthor : Sakib Saikia 1/17/2017\n********************************************************************/\n\n#define PI 3.141592\n\nvec3 spherePos = vec3(0.0,0.0,0.0);\nfloat sphereRadius = 1.0;\nvec3 albedo = vec3(1.0,0.0,0.0);\nvec3 lightDir = vec3(1.0,1.0,-1.0);\nvec3 ambient = vec3(0.02);\nvec3 spec = vec3(0.03);\nfloat gloss = 150.0;\nvec3 gamma = vec3(2.2);\n\n//------------------------------------------------------------------------\n// Camera rotation\n//------------------------------------------------------------------------\nvec3 getEyePos()\n{\n    float theta = 0.2 * iTime;\n    return 2.0 * vec3(sin(theta), 0.0, -cos(theta));\n}\n\n//------------------------------------------------------------------------\n// Construct inverse LookAt matrix. Convert from view space to world space\n// eyePos \t- eye/camera position in World Space\n// v \t\t- LookAt position in world space\n//------------------------------------------------------------------------\nmat3 invLookAt(vec3 eyePos, vec3 v)\n{\n    vec3 worldUpDir = vec3(0.0,1.0,0.0);\n    vec3 viewLookDir = normalize(v - eyePos);\n    vec3 viewRightDir = normalize(cross(worldUpDir, viewLookDir));\n    vec3 viewUpDir = normalize(cross(viewLookDir, viewRightDir));\n    \n    return mat3(viewRightDir, viewUpDir, viewLookDir);\n}\n\n//------------------------------------------------------------------------\n// Sphere ray trace\n// p - ray trace origin in world space\n// d - ray direction in world space\n// o - sphere origin in world space\n// r - sphere radius\n// See : http://www.cs.virginia.edu/~gfx/Courses/2008/AdvancedGraphics/lectures/lecture07_implicit.pdf\n//------------------------------------------------------------------------\nfloat rayTrace(vec3 p, vec3 d, vec3 o, float r)\n{\n    vec3 op = p - o;\n    \n    float a = 1.0;\n    float b = 2.0 * dot(d, op);\n    float c = dot(op, op) - r * r;\n    \n    float t = b*b - 4.0*a*c;\n    if(t >= 0.0)\n    {\n        return (-b - sqrt(t))/(2.0 * a);\n    }\n    else\n    {\n        return -1.0;\n    }\n    \n}\n\n//------------------------------------------------------------------------\n// Tonemap operator\n// See : https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n//------------------------------------------------------------------------\nvec3 TonemapACES( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // NDC\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Inverse View matrix\n    vec3 eye = getEyePos();\n    mat3 viewMat = invLookAt(eye, spherePos); \n    \n    // Ray direction in world space\n    vec3 rayDir = viewMat * normalize(vec3(p.xy, 0.75));\n    \n    // Background color (cubemap)\n    vec3 pixelColor = pow(texture(iChannel0, -rayDir).rgb, gamma);\n    \n    // Ray trace!\n    float t = rayTrace(eye, rayDir, spherePos, sphereRadius);\n    \n    if(t > 0.0)\n    {\n        vec3 pos = eye + t * rayDir;\n        vec3 n = normalize(pos - spherePos);\n        vec3 l = normalize(lightDir);\n        vec3 v = normalize(eye);\n        vec3 r = reflect(-l, n);\n        \n        // New Albedo to make sure albedo + spec <= 1.0\n        vec3 new_albedo = (vec3(1.0) - spec) * albedo;\n        \n        // -- Ambient \n        pixelColor = new_albedo * ambient;\n        \n        // -- Diffuse \n    \tpixelColor += new_albedo * max(dot(n, l), 0.0);\n        \n        // -- Specular\n        float phong_norm_factor = 0.5 * (gloss + 1.0);\n        pixelColor += spec * phong_norm_factor * pow(clamp(dot(r,v), 0.0, 1.0), gloss);\n    }\n    \n    // Tonemap\n    pixelColor = TonemapACES(pixelColor);\n        \n    // Gamma correction\n    pixelColor = pow(pixelColor,1.0/gamma);\n    \n    fragColor = vec4(pixelColor,1.0);\n}","name":"Image","description":"","type":"image"}]}