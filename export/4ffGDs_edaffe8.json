{"ver":"0.1","info":{"id":"4ffGDs","date":"1703660651","viewed":33,"name":"Fork Ball Mergi SilverOfMo 615","username":"SilverOfMoon","description":"It's a playable game! Click where you want the new ball to fall. Balls with same size will merge and grow bigger. Can you get \"the huge purple ball\"?\nIf you lose, reset the timeline to restart.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["game","simulation","physics"],"hasliked":0,"parentid":"Wl3BDl","parentname":"Ball Merging Game"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getBallData1(int idx)\n{\n    return texture(iChannel0, vec2(float(idx) + 0.5,0.5)/iResolution.xy);\n}\n\nvec4 getBallData2(int idx)\n{\n    return texture(iChannel0, vec2(float(idx) + 0.5,1.5)/iResolution.xy);\n}\n\nvec2 screenToWorld(vec2 screen)\n{\n    screen /= iResolution.y;\n    screen *= WORLD_HEIGHT;\n    screen.x -= (iResolution.x / iResolution.y * WORLD_HEIGHT * 0.5 - 0.5);\n    return screen;\n}\n\nvec4 getData(int pos)\n{\n    return texture(iChannel0, vec2(float(pos) + 0.5,2.5)/iResolution.xy);\n}\n\nbool isPreview(){\n    return iResolution.x < PREVIEW_RESOLUTION_THRESHOLD ? true : false;\n}\n\nvoid drawBallSingle(vec2 ballPos, float ballRadius, vec3 ballColor, vec2 worldPos, inout vec4 fragColor)\n{\n    float dist = distance(worldPos, ballPos) - ballRadius - DRAW_BALL_BORDER;\n    ballColor *= ((1.0 - smoothstep(- DRAW_BALL_BORDER_2 - DRAW_BALL_BORDER, - DRAW_BALL_BORDER_2, dist)) * (1.0 - DRAW_BALL_DARKEN_FACTOR) + DRAW_BALL_DARKEN_FACTOR);\n    fragColor.xyz = mix(ballColor, fragColor.xyz, smoothstep(- DRAW_BALL_BORDER, 0.0, dist));\n}\n\nvoid drawBallDouble(vec4 data1, vec4 data2, vec2 worldPos, inout vec4 fragColor)\n{\n    float born = data2.y / BALL_BORN_TIME;\n    vec2 pos1 = data1.xy + data2.zw * born * born;\n    vec2 pos2 = data1.xy - data2.zw * born * born;\n    float t = mix(0.5, 1.0, born);\n    float ballRadius = getBallRadius(data2.x - born);\n    float dist1 = min(0.0, (distance(worldPos, pos1) - ballRadius - DRAW_BALL_BORDER) * t);\n    float dist2 = min(0.0, (distance(worldPos, pos2) - ballRadius - DRAW_BALL_BORDER) * t);\n    float dist = dist1 + dist2;\n    vec3 ballColor = getBallColor(data2.x - born);\n    ballColor *= ((1.0 - smoothstep(- DRAW_BALL_BORDER_2 - DRAW_BALL_BORDER, - DRAW_BALL_BORDER_2, dist)) * (1.0 - DRAW_BALL_DARKEN_FACTOR) + DRAW_BALL_DARKEN_FACTOR);\n    fragColor.xyz = mix(ballColor, fragColor.xyz, smoothstep(- DRAW_BALL_BORDER, 0.0, dist));\n}\n\nvoid drawBall(int idx, vec2 worldPos, inout vec4 fragColor)\n{\n    vec4 data1 = getBallData1(idx);\n    vec4 data2 = getBallData2(idx);\n    if (data2.x != 0.0){\n        float bornTime = data2.y;\n        if (bornTime > 0.0){\n            drawBallDouble(data1, data2, worldPos, fragColor);\n        }\n        else{\n            float ballRadius = getBallRadius(data2.x);\n            drawBallSingle(mix(data1.xy, vec2(ballRadius + DRAW_BALL_PREVIEWER_SPACE, WORLD_HEIGHT - ballRadius - DRAW_BALL_PREVIEWER_SPACE), -data2.y / BALL_BORN_TIME), ballRadius, getBallColor(data2.x), worldPos, fragColor);\n        }\n    }\n}\n\nvoid drawBackground(vec2 worldPos, inout vec4 fragColor)\n{\n    if (worldPos.x > 0.0 && worldPos.x < 1.0){\n        fragColor.xyz = BG_COLOR;\n    }\n}\n\nvoid drawBorder(vec2 worldPos, inout vec4 fragColor)\n{\n    if (worldPos.x < 0.0 || worldPos.x > 1.0){\n        fragColor.xyz = vec3(0.0);\n    }\n}\n\nvoid drawNewBallPreview(vec2 worldPos, inout vec4 fragColor)\n{\n    float coolDown = getData(BALL_COOLDOWN_DATA_POS).x;\n    float ballSize = getData(NEXT_BALL_DATA_POS).x;\n    float ballRadius = getBallRadius(ballSize);\n    if (float(iFrame) >= coolDown){\n        drawBallSingle(vec2(ballRadius + DRAW_BALL_PREVIEWER_SPACE, WORLD_HEIGHT - ballRadius - DRAW_BALL_PREVIEWER_SPACE), ballRadius, getBallColor(ballSize), worldPos, fragColor);\n    }\n}\n\nvoid drawDangerLine(vec2 worldPos, inout vec4 fragColor){\n    float danger = getData(DANGER_DATA_POS).x;\n    if (worldPos.x > 0.0 && worldPos.x < 1.0 && abs(worldPos.y - DANGER_HEIGHT) < 0.005){\n        fragColor.xyz = mix(fragColor.xyz, vec3(1.0, 0.0, 0.0), max(0.0, danger - DANGER_1) / (DANGER_2 - DANGER_1));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 world = screenToWorld(fragCoord.xy);\n    \n    drawBackground(world, fragColor);\n    \n    for (int idx = 0; idx < MAX_BALLS; idx++){\n        drawBall(idx, world, fragColor);\n    }\n    \n    if (!isPreview()){\n        drawNewBallPreview(world, fragColor);\n    }\n    \n    drawBorder(world, fragColor);\n    \n    drawDangerLine(world, fragColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int MAX_BALLS = 64;\nconst float MAX_BALL_SIZE = 11.0;\nconst int MOUSE_DATA_POS = 0;\nconst int NEXT_BALL_DATA_POS = 1;\nconst int BALL_COUNTER_DATA_POS = 2;\nconst int BALL_COOLDOWN_DATA_POS = 3;\nconst int DANGER_DATA_POS = 4;\nconst int NEW_BALL_COOLDOWN = 30;\nconst float BALL_BORN_TIME = 15.0;\nconst float WORLD_HEIGHT = 1.5;\nconst float DANGER_HEIGHT = 1.3;\nconst float DANGER_1 = 30.0;\nconst float DANGER_2 = 150.0;\nconst float DELTA = 0.0025;\nconst vec2 GRAVITY = vec2(0.0, -0.2);\nconst float FORCE_FACTOR = 200.0;\nconst float DRAG_FACTOR = 1.0;\nconst float DRAG_DISTANCE = 0.01;\nconst float DRAW_BALL_BORDER = 0.005;\nconst float DRAW_BALL_BORDER_2 = 0.01;\nconst float DRAW_BALL_DARKEN_FACTOR = 0.5;\nconst float DRAW_BALL_PREVIEWER_SPACE = 0.02;\nconst vec3 BG_COLOR = vec3(0.9,0.8,0.4);\nconst float PREVIEW_RESOLUTION_THRESHOLD = 512.0;\n\nfloat forceFunc(float x, float v)\n{\n    return -step(0.0, -x) * x * FORCE_FACTOR - step(-DRAG_DISTANCE, -x) * v * DRAG_FACTOR;\n}\n\nfloat getBallMass(float ballSize)\n{\n    return 2.0 + ballSize * 0.25;\n}\n\nfloat getBallRadius(float ballSize)\n{\n    return 0.02 + ballSize * (10.0 + ballSize) * 0.00125;\n}\n\nvec3 getBallColor(float ballSize)\n{\n    float c = mod((ballSize - 1.0) * 2.0, 11.0);\n    return vec3(clamp(abs(c-6.0)*0.5-1.0,0.0,1.0),clamp(2.0-abs(c-4.0)*0.5,0.0,1.0),clamp(2.0-abs(c-8.0)*0.5,0.0,1.0));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//x, y, vx, vy\nvec4 getBallData1(int idx)\n{\n    return texture(iChannel0, vec2(float(idx) + 0.5,0.5)/iResolution.xy);\n}\n\n//ball size, born time\nvec4 getBallData2(int idx)\n{\n    return texture(iChannel0, vec2(float(idx) + 0.5,1.5)/iResolution.xy);\n}\n\nvec2 screenToWorld(vec2 screen)\n{\n    screen /= iResolution.y;\n    screen *= WORLD_HEIGHT;\n    screen.x -= (iResolution.x / iResolution.y * WORLD_HEIGHT * 0.5 - 0.5);\n    return screen;\n}\n\nvec4 getData(int pos)\n{\n    return texture(iChannel0, vec2(float(pos) + 0.5,2.5)/iResolution.xy);\n}\n\nvoid setData(int i, int j, inout vec4 fragColor, int pos, vec4 data)\n{\n    if (i == pos && j == 2){\n        fragColor = data;\n    }\n}\n\nbool isPreview(){\n    return iResolution.x < PREVIEW_RESOLUTION_THRESHOLD ? true : false;\n}\n\nvoid calcGRAVITY(int idx, vec4 data1, vec4 data2, inout vec2 force)\n{\n    force += getBallMass(data2.x) * GRAVITY;\n}\n\nvoid calcBorder(int idx, vec4 data1, vec4 data2, inout vec2 force)\n{\n    force.y += forceFunc(data1.y - getBallRadius(data2.x), data1.w);\n    force.x += forceFunc(data1.x - getBallRadius(data2.x), data1.z);\n    force.x -= forceFunc(1.0 - data1.x - getBallRadius(data2.x), -data1.z);\n}\n\nvoid calcOtherBall(vec4 data1, vec4 data2, vec4 otherData1, vec4 otherData2, bool flag, inout vec2 force, inout vec3 merge)\n{\n    vec2 offset = data1.xy - otherData1.xy;\n    float dist = length(offset);\n    vec2 norm = offset / dist;\n    float x = dist - getBallRadius(data2.x) - getBallRadius(otherData2.x);\n    float v = dot(data1.zw - otherData1.zw, norm);\n    float f = forceFunc(x, v);\n    force += f * norm;\n    if (x <= 0.0 && data2.x == otherData2.x && data2.x < MAX_BALL_SIZE && data2.y == 0.0 && otherData2.y == 0.0 && merge.z == 0.0){\n        if (flag){\n            merge = vec3((data1.xy + otherData1.xy) * 0.5, 1.0);\n        }\n        else{\n            merge = vec3((data1.xy + otherData1.xy) * 0.5, -1.0);\n        }\n    }\n}\n\nvoid updateBall(int i, int j, inout vec4 fragColor)\n{\n    vec4 data1 = getBallData1(i);\n    vec4 data2 = getBallData2(i);\n    \n    vec2 force = vec2(0.0, 0.0);\n    vec3 merge = vec3(0.0, 0.0, 0.0);\n    bool danger = false;\n    for (int otherIdx = 0; otherIdx < MAX_BALLS; otherIdx++){\n        vec4 otherData1 = getBallData1(otherIdx);\n        vec4 otherData2 = getBallData2(otherIdx);\n        if (otherData2.x != 0.0 && otherIdx != i){\n            calcOtherBall(data1, data2, otherData1, otherData2, otherIdx < i, force, merge);\n        }\n        if (otherData1.y + getBallRadius(otherData2.x) > DANGER_HEIGHT){\n            danger = true;\n        }\n    }\n    \n    if (danger && !isPreview()){\n        float danger = getData(DANGER_DATA_POS).x;\n        setData(i, j, fragColor, DANGER_DATA_POS, vec4(danger +1.0, 0.0, 0.0, 0.0));\n    }\n    else{\n        setData(i, j, fragColor, DANGER_DATA_POS, vec4(0.0, 0.0, 0.0, 0.0));\n    }\n    \n    if (i >= 0 && i < MAX_BALLS && j == 0){\n        calcGRAVITY(i, fragColor, data2, force);\n        calcBorder(i, fragColor, data2, force);\n        fragColor.xy += (fragColor.zw * DELTA);\n        fragColor.zw += force / getBallMass(data2.x);\n        if (merge.z == 1.0){\n            fragColor.xy = merge.xy;\n            fragColor.zw = vec2(0.0, 0.0);\n        }\n        if (merge.z == -1.0){\n            //nothing\n        }\n    }\n    \n    if (i >= 0 && i < MAX_BALLS && j == 1){\n        if (fragColor.y < 0.0){\n            fragColor.y += 1.0;\n        }\n        if (fragColor.y > 0.0){\n            fragColor.y -= 1.0;\n        }\n        if (merge.z == 1.0){\n            fragColor.x = data2.x + 1.0;\n            fragColor.y = BALL_BORN_TIME;\n            fragColor.zw = merge.xy - data1.xy;\n        }\n        if (merge.z == -1.0){\n            fragColor.x = 0.0;\n        }\n    }\n}\n\nvoid newBall(int i, int j, inout vec4 fragColor, float ballSize, vec2 position, vec2 velocity)\n{\n    for (int idx = 0; idx < MAX_BALLS; idx++){\n        vec4 data2 = getBallData2(idx);\n        if (data2.x == 0.0){\n            if (i == idx && j == 0){\n                fragColor = vec4(position.x, position.y, velocity.x, velocity.y);\n            }\n            if (i == idx && j == 1){\n                fragColor = vec4(ballSize, -BALL_BORN_TIME, 0.0, 0.0);\n            }\n            break;\n        }\n    }\n}\n\nvoid updateMouse(int i, int j, inout vec4 fragColor)\n{\n    if (iMouse.z > 0.5){\n        setData(i, j, fragColor, MOUSE_DATA_POS, vec4(1.0, 0.0, 0.0, 0.0));\n        if (getData(MOUSE_DATA_POS).x == 0.0){\n            vec2 mousePos = screenToWorld(iMouse.xy);\n            float coolDown = getData(BALL_COOLDOWN_DATA_POS).x;\n            if (mousePos.x > 0.0 && mousePos.x < 1.0 && float(iFrame) >= coolDown){\n                float ballSize = getData(NEXT_BALL_DATA_POS).x;\n                float ballRadius = getBallRadius(ballSize);\n                newBall(i, j, fragColor, ballSize, vec2(clamp(mousePos.x, ballRadius, 1.0-ballRadius), WORLD_HEIGHT - ballRadius), vec2(0.0));\n                float ballCounter = getData(BALL_COUNTER_DATA_POS).x;\n                ballCounter++;\n                setData(i, j, fragColor, BALL_COUNTER_DATA_POS, vec4(ballCounter,0.0,0.0,0.0));\n                if (ballCounter <= 4.0){\n                    setData(i, j, fragColor, NEXT_BALL_DATA_POS, vec4(ballCounter,0.0,0.0,0.0));\n                }\n                else{\n                    setData(i, j, fragColor, NEXT_BALL_DATA_POS, vec4(mod(float(iFrame) ,5.0)+1.0,0.0,0.0,0.0));\n                }\n                setData(i, j, fragColor, BALL_COOLDOWN_DATA_POS, vec4(float(iFrame + NEW_BALL_COOLDOWN),0.0,0.0,0.0));\n            }\n        }\n    }\n    else\n    {\n        setData(i, j, fragColor, MOUSE_DATA_POS, vec4(0.0, 0.0, 0.0, 0.0));\n    }\n}\n\nvoid reset(int i, int j, inout vec4 fragColor){\n    fragColor = vec4(0.0);\n    setData(i, j, fragColor, NEXT_BALL_DATA_POS, vec4(1.0, 0.0, 0.0, 0.0));\n    setData(i, j, fragColor, BALL_COUNTER_DATA_POS, vec4(0.0, 0.0, 0.0, 0.0));\n    setData(i, j, fragColor, BALL_COOLDOWN_DATA_POS, vec4(-float(NEW_BALL_COOLDOWN),0.0,0.0,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // default : copy last frame's value\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    //\n    int i = int(floor(fragCoord.x));\n    int j = int(floor(fragCoord.y));\n    //\n    if (iFrame == 0){\n        reset(i, j, fragColor);\n    }\n    else{\n        if (isPreview()){\n            if (mod(float(iFrame), 3600.0) == 1.0){\n                reset(i, j, fragColor);\n                return;\n            }\n            if (mod(float(iFrame), 15.0) == 1.0){\n                newBall(i, j, fragColor, mod(float(iFrame), 4.0) + 1.0, vec2(mod(float(iFrame), 7.0) * 0.1 + 0.2, WORLD_HEIGHT), vec2(0.0));\n            }\n        }\n        float danger = getData(DANGER_DATA_POS).x;\n        if (danger >= DANGER_2){\n            return;\n        }\n        updateBall(i, j, fragColor);\n        updateMouse(i, j, fragColor);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}