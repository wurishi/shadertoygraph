{"ver":"0.1","info":{"id":"NstGDX","date":"1630757047","viewed":70,"name":"Quadratic Curve SDF","username":"Cryru","description":"A quadratic curve\noriginal by demofox","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","curve","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nInfo on curves:\nhttp://research.microsoft.com/en-us/um/people/cloop/LoopBlinn05.pdf\nhttp://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nhttp://www.pouet.net/topic.php?which=9119&page=1\nhttp://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html\n\nThe top link is where this technique comes from.\n\nThanks also to other bezier curve shadertoys:\nhttps://www.shadertoy.com/view/XsX3zf\nhttps://www.shadertoy.com/view/lts3Df\n*/\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 color = vec3(1.0,1.0,1.0);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - vec2(0.25,0.5);\n    mouse.x *= aspectRatio;\n    vec2 A = vec2(0.0,0.0);\n    vec2 B = length(iMouse.xy) > 0.0 ? mouse : vec2(-0.3,0.2);\n    vec2 C = vec2(1.0,0.0);  \n \n    // Compute vectors        \n    vec2 v0 = C - A;\n    vec2 v1 = B - A;\n    vec2 v2 = percent - A;\n\n    // Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n\t// Compute barycentric coordinates\n\tfloat invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\tfloat u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\tfloat v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // use the blinn and loop method\n    float w = (1.0 - u - v);\n    vec2 textureCoord = u * vec2(0.0,0.0) + v * vec2(0.5,0.0) + w * vec2(1.0,1.0);\n        \n\t// use the sign of the result to decide between grey or black\n    float insideOutside = sign(textureCoord.x * textureCoord.x - textureCoord.y) < 0.0 ? 0.5 : 1.0;\n    color = vec3(insideOutside * 0.5);\n    \n    // if it's outside the triangle, lighten it a bit\n    color += ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0)) ? 0.0 : 1.0;\n\n\tfragColor = vec4(clamp(color,0.0,1.0),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}