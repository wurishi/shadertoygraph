{"ver":"0.1","info":{"id":"MXKXWW","date":"1719975405","viewed":69,"name":"Autómata celular","username":"moloxe","description":"Adaptación de un pequeño experimento:\n- https://moloxe.io/blog/autmatas-celulares-en-glsl/","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["cellular","automaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float gap = 13.7;\nconst float radius = 5.0;\nconst float PI = 3.14159265;\n\nvec3 getState(vec2 p) {\n    if(iFrame < 10) {\n        vec4 data = texture(\n            iChannel0,\n            p\n        );\n        return data.rgb;\n    }\n    vec4 data = texture(\n        iChannel1,\n        p\n    );\n    return data.rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 n = vec3(0.0);\n    for(float r = 1.0; r <= radius; r++) {\n        float points = 16.0 * r;\n        for(float p = 0.0; p < points; p++) {\n            float k = fragCoord.x + r * cos(2.0 * PI * p / points);\n            float l = fragCoord.y + r * sin(2.0 * PI * p / points);\n            n += getState(vec2(k, l) / iResolution.xy) / r;\n        }\n    }\n    \n    vec2 pos = 2.0 * fragCoord / iResolution.xy - 1.0;\n    pos.x *= iResolution.x / iResolution.y;\n    vec2 circle = vec2(cos(iTime) * 0.6, sin(iTime) * 0.6);\n    float circleDist = length(pos - circle);\n    \n    if(circleDist < 0.1) {\n        fragColor = vec4(1.0);\n    } else {\n        vec3 live = getState(uv);\n        live.r += -pow((n.r) / 2.0 - gap, 2.0) + gap;\n        live.g += -pow((n.r + n.g) / 3.0 - gap, 2.0) + gap;\n        live.b += -pow((n.r + n.g + n.b) / 4.0 - gap, 2.0) + gap;\n        live = step(1.0, live);\n        fragColor = vec4(live, 1.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}