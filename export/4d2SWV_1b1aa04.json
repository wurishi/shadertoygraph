{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//\tCreative Commons CC0 1.0 Universal (CC-0) \n//\t\n//\tAnalytic shadows from spherical occluders and a spherical light.\n//\t\n//\tIt breaks if the light and occluder intersect, but I think all other cases are handled correctly.\n//\t\n//\t~bj.2014\n//\t\n\n#define POST_TONEMAP\n#define POST_DITHER\n#define POST_VIGNETTE\n\nconst float PI = 3.1415927;\nconst int nSpheres\t= 8;\nconst float camDist\t= 32.0;\n\nstruct sphere { vec3 o; float r; int id; };\nstruct ray { vec3 o, d; float t; sphere s; };\n\nvec2 hash(float n) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\nfloat hash(vec2 p) { return fract(1e4*sin(17.0*p.x+p.y*0.1)*(0.1+abs(sin(p.y*13.0+p.x)))); }\n\nfloat shadow(vec3 P, vec3 lightPos, float lightRad, vec3 occluderPos, float occluderRad)\n{\n\tfloat radA = lightRad;\n\tfloat radB = occluderRad;\n\t\n\tvec3 vecA = lightPos - P;\n\tvec3 vecB = occluderPos - P;\n\t\n\tfloat dstA = sqrt(dot(vecA, vecA));\n\tfloat dstB = sqrt(dot(vecB, vecB));\n\t\n\tif (dstA - radA / 2.0 < dstB - radB) return 1.0;\n\t\n\tfloat sinA = radA / dstA;\n\tfloat sinB = radB / dstB;\n\t\n\tfloat cosA = sqrt(1.0 - sinA * sinA);\n\tfloat cosB = sqrt(1.0 - sinB * sinB);\n\t\n\tif (cosA * dstA < cosB * dstB) return 1.0;\n\t\n\tvec3 dirA = vecA / dstA;\n\tvec3 dirB = vecB / dstB;\n\t\n\tfloat cosG = dot(dirA, dirB);\n\t\n\tif (cosG < cosA * cosB - sinA * sinB) return 1.0;\n\t\n\tfloat sinG = length(cross(dirA, dirB));\n\t\n\tfloat cscA = dstA / radA;\n\tfloat cscB = dstB / radB;\n\t\n\tfloat cosTheta = clamp((cosB - cosA * cosG) * cscA / sinG, -1.0, 1.0);\n\tfloat cosPhi = clamp((cosA - cosB * cosG) * cscB / sinG, -1.0, 1.0);\n\t\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tfloat sinPhi = sqrt(1.0 - cosPhi * cosPhi);\n\t\n\tfloat theta = acos(cosTheta);\n\tfloat phi = acos(cosPhi);\n\t\n\tfloat unoccluded = theta - cosTheta * sinTheta \n\t\t\t\t\t + (phi - cosPhi * sinPhi)\n\t\t\t\t\t * cosG * sinB * sinB / (sinA * sinA);\n\t\n\treturn 1.0 - unoccluded / PI;\n}\n\nfloat diffuse(vec3 P, vec3 N, vec3 lightPos, float lightRad)\n{\t// based on Seb Lagarde's Siggraph 2014 stuff - https://seblagarde.wordpress.com/\n\tvec3 vec = lightPos - P;\n\tfloat dst = sqrt(dot(vec, vec));\n\tvec3 dir = vec / dst;\n\t\n\tfloat cosA = dot(N, dir);\n\tfloat sinB = lightRad / dst;\n\t\n\tif (abs(cosA / sinB) > 1.0) return cosA;\n\t\n\tfloat sinA = length(cross(N, dir));\n\tfloat cotA = cosA / sinA;\n\t\n\tfloat cosB = sqrt(1.0 - sinB * sinB);\n\tfloat cotB = cosB / sinB;\n\t\n\tfloat x = sqrt(1.0 - cotA * cotA * cotB * cotB) * sinA;\n\t\n\treturn (acos(-cotA * cotB) * cosA - x * cotB + atan(x / cotB) / (sinB * sinB)) / PI;\n}\n\nfloat aoFromSphere(vec3 s, float r, vec3 p, vec3 n)\n{\t// iq's sphere ao - https://iquilezles.org/articles/sphereao\n\tvec3 dir = s - p;\n\tfloat lenSq = dot(dir, dir);\n\tdir *= inversesqrt(lenSq);\n\treturn 1.0 - max(dot(n, dir) * (r*r / lenSq), 0.0);\n}\n\nvec3 shade(ray r, sphere s[nSpheres], vec3 lightPos, float lightRad)\n{\n\tif (r.s.id == -2) return vec3(8.0);\n\t\n\tvec3 P = r.o + r.d * r.t;\n\tvec3 N = vec3(0.0,1.0,0.0);\n\tvec3 C = vec3(1.0,1.0,1.0);\n\t\n\tfloat sh = 1.0;\n\tfloat ao = 1.0;\n\n\tif (r.s.id == -1)\n\t{\n        float x = min(abs(fract(0.2*P.x) - 0.5), abs(fract(0.2*P.z) - 0.5));\n        C *= mix(1.0, (0.4+0.5*smoothstep(0.0, 0.5/r.t, x-0.04)), exp(-0.005*r.t));\n\t\tfor (int i = 0; i < nSpheres; i++)\n\t\t{\n\t\t\tsh *= shadow(P, lightPos, lightRad, s[i].o, s[i].r);\n\t\t\tao *= aoFromSphere(s[i].o, s[i].r, P, N);\n\t\t}\n\t}\n\telse\n\t{\n\t\tN = normalize(P - r.s.o);\n\t\tao *= N.y * 0.5 + 0.5;\n\n\t\tfor (int i = 0; i < nSpheres; i++)\n\t\t{\n\t\t\tif (i != r.s.id)\n\t\t\t{\n\t\t\t\tsh *= shadow(P, lightPos, lightRad, s[i].o, s[i].r);\n\t\t\t\tao *= aoFromSphere(s[i].o, s[i].r, P, N);\n\t\t\t}\n\t\t}\n\n\t\tsh *= max(0.0, diffuse(P, N, lightPos, lightRad));\n\t\t\n\t\tvec2 uv = hash(123.456 * float(r.s.id) / float(nSpheres));\n\t\tC = texture(iChannel0, 1.0 - uv).xyz * 0.5 + 0.25;\n\t}\n\n\tC *= sh * 0.95 + 0.05;\n\tC *= mix(ao, 1.0, sh);\n\t\n\treturn C;\n}\n\nvoid intersect(inout ray r, sphere s)\n{\n\tvec3 o = r.o - s.o;\n\t\n\tfloat b = dot(r.d, o);\n\tfloat c = dot(o, o) - s.r*s.r;\n\tfloat d = b*b - c;\n\t\n\tif (d < 0.0) return;\n\t\n\tfloat t = -b - sqrt(d);\n\tif (t <= 0.0 || t > r.t ) return;\n\t\n\tr.t = t;\n\tr.s = s;\n}\n\nvec3 trace(vec3 ro, vec3 rd)\n{\n\tray r = ray(ro, rd, 4000.0, sphere(vec3(0.0,0.0,0.0), 4000.0, -1));\n\tif (r.d.y < 0.0) r.t = min(r.t, -ro.y / rd.y);\n\t\n\tfloat time = iTime + 90.0;\n\tfloat d = 0.0;\n\tsphere s[nSpheres];\n\t\n\tfor (int i = 0; i < nSpheres; i++) \n\t{\n\t\tfloat f = float(i) / float(nSpheres);\n\t\tvec2 h = hash(f + 0.5);\n\t\tfloat rad = h.x * 1.5 + 0.5;\n\t\tvec3 pos =  vec3(cos(time * f * 0.1), 0.0, sin(time * f * 0.1)) * (d + rad);\n\t\tpos.y += rad + (sin(time * (1.0 - f) * 0.2) * 0.1 + 0.1) * d;\n\t\ts[i] = sphere(pos, rad, i);\n\t\tintersect(r, s[i]);\n\t\td += rad * 2.0;\n\t}\n\t\n\tfloat lightRad = cos(iTime*0.25) * 20.0 + 21.0;\n\tvec3 lightPos = vec3(sin(iTime*0.1) * 24.0 + 12.0, d * 0.25 + lightRad + 5.0, -4.0);\n\tintersect(r, sphere(lightPos, lightRad, -2));\n\t\n\treturn shade(r, s, lightPos, lightRad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy - iResolution.xy;\n\tuv /= max(iResolution.x, iResolution.y);\n\t\n\tvec2 m = vec2(2.3,1.3);\n\tif (iMouse.xy != vec2(0.0))\n\t\tm = vec2(2.0 * PI, 0.4) * iMouse.xy / iResolution.xy + vec2(-PI / 2.0, 1.0);\n\t\n\tvec3 ro = vec3(sin(m.y)*cos(m.x), cos(m.y), sin(m.y)*sin(m.x)) * camDist;\n\tmat3 r = mat3(normalize(cross(-ro,vec3(0.0,1.0,0.0))), 0.0,1.0,0.0, -normalize(ro));\n\tr[1] = cross(r[0],r[2]);\n\tvec3 rd = normalize(r * vec3(uv,1.0));\n\t\n\tvec3 C = trace(ro, rd);\n\t\n\t#ifdef POST_TONEMAP\n\t// tonemapping by Jim Hejl and Richard Burgess-Dawson\n\tfloat exposure = 1.4;\n\tC = max(vec3(0.0,0.0,0.0), C * exposure - 0.004);\n\tC = (C * (6.2 * C + 0.5)) / (C * (6.2 * C + 1.7) + 0.06);\n\t#endif\n\t\n\t#ifdef POST_DITHER\n\tC += hash(uv) * 0.02 - 0.01;\n\t#endif\n\t\n\t#ifdef POST_VIGNETTE\n\tC *= sqrt(1.0 - dot(uv, uv) * 0.25);\n\t#endif\n\t\n\tfragColor= vec4(C, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2SWV","date":"1416091637","viewed":422,"name":"Soft Sphere Shadows","username":"ben","description":"Trying to get correct shadows from spherical lights/occluders. I'm sure someone with an actual education could do it much more elegantly, but I'm pleased with this.\n\nI still have no idea what I'm doing though. Yaaaay!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["lighting","shadows","analytic"],"hasliked":0,"parentid":"","parentname":""}}