{"ver":"0.1","info":{"id":"7lXyzX","date":"1648407825","viewed":125,"name":"Paranormal spaces (Twitch)","username":"rimina","description":"Some lighting & indoor space modeling from my Twitch live coding stream 6th of March 2022.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","glow","ambienocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n//Huge thanks to the live coding community, I've learned so much from you!\n\n\n\n//float fft = texture(texFFTIntegrated, 0.5).r;\n\nconst float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 60;\n\nstruct Material{\n  vec3 l;\n  vec3 s;\n  float shiny;\n};\n\nMaterial M;\n\nvec3 glow = vec3(0.0);\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nvoid rot(inout vec2 p, float a){\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat cubescape(vec3 p){\n    vec3 pp = p;\n    float s = length(pp)-2.5;\n\n    pp = p;\n    for(int i = 0; i < 5; ++i){\n        pp = abs(pp)-vec3(0.7, 0.4, 0.8);\n        rot(pp.xy, iTime*0.5);\n        rot(pp.xz, iTime/*+fft*4.0*/);\n        rot(pp.yx, iTime*0.5/*+fft*2.0*/);\n    }\n\n    glow += vec3(0.2, 0.4, 0.5)*0.01 / (abs(s)+0.01);\n\n    return min(s, box(pp, vec3(0.2, 5.0, 0.2)));\n}\n\nfloat scene(vec3 p){\n    vec3 pp = p;\n\n    float room = -box(pp, vec3(20.0, 8.0, 20.0));\n\n    pp = abs(pp)-vec3(8.0, 5.0, 6.0);\n\n    float pilars = box(pp-vec3(5.0, 1.0, 0.0), vec3(10.0, 2.0, 0.5));\n    pilars = min(pilars, box(pp-vec3(0.0, 0.0, 5.0), vec3(0.5, 3.0, 8.0)));\n\n    pp = p;\n\n    float center = cubescape(pp);\n\n\n    M.l = vec3(0.4);\n    M.s = vec3(0.35, 0.3, 0.3);\n    M.shiny = 10.0;\n\n    if(center < room && center < pilars){\n        M.l = vec3(0.75, 0.9, 1.0);\n        M.s = vec3(2.0);\n        M.shiny = 2.0;\n    }\n\n    return min(min(center, pilars), room);\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = E;\n    vec3 p = ro;\n\n    for(int i = 0; i < STEPS; ++i){\n        float d = scene(p);\n        t += d;\n        p = ro + rd * t;\n\n        if(d < E || t > FAR){\n            break;\n        }\n    }\n\n    return t;\n}\n\nvec3 normals(vec3 p){\n    vec3 e = vec3(E, 0.0, 0.0);\n    return normalize(vec3(\n        scene(p+e.xyy) - scene(p-e.xyy),\n        scene(p+e.yxy) - scene(p-e.yxy),\n        scene(p+e.yyx) - scene(p-e.yyx)\n    ));\n}\n\n//Method for ambient occlusion or shadows,\n//found it from Pouet size coding thread\n//I think it was dechiper's method originally\n//I may have modified it over time as it's been\n//on my toolbox for years now.\nfloat AO(float e, vec3 p, vec3 n){\n\n    float o = 1.0;\n    for(float i = 0.0; i < 6.0; ++i){\n        o -= (i*e - scene(p+n*i*e))/exp2(i);\n    }\n\n    return max(min(o, 1.0), 0.0);\n}\n\nvec3 shade(vec3 p, vec3 rd, vec3 ld, Material mat){\n    vec3 n = normals(p);\n\n    float lambertian = max(dot(n, ld), 0.0);\n    float a = max(dot(reflect(rd, ld), n), 0.0);\n    float specular = pow(a, mat.shiny);\n\n    float ao = (AO(0.5, p, n) + AO(0.1, p, n))*0.8;\n\n    return (mat.l*lambertian*0.8 + mat.s*specular*0.4)*ao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0 + 2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(15.0*cos(iTime*0.1), 1.0, 15.0*sin(iTime*0.1));\n    vec3 rt = vec3(0.0, 1.0, 0.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x,y,z) * vec3(q, 1.0/radians(50.0)));\n\n    vec3 col = vec3(1.0);\n    float t = march(ro, rd);\n    vec3 p = ro + rd * t;\n    Material mat = M;\n    vec3 g = glow;\n\n    vec3 lo = vec3(0.0, 0.0, 0.0);\n    vec3 ld = normalize(lo-p);\n\n\n    if(t < FAR){\n        col = shade(p, rd, ld, mat);\n    }\n    col += glow;\n    \n    //In the original shader there is some motion blurr\n    //vec3 prev = texture(texPreviousFrame, uv).rgb;\n    //col = mix(col, prev, 0.6);\n\n    col = smoothstep(-0.2, 1.2, col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}