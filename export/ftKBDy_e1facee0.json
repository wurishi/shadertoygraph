{"ver":"0.1","info":{"id":"ftKBDy","date":"1665287260","viewed":64,"name":"Reparametrized sin path","username":"Envy24","description":"Purple - reparametrized sine.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sin","cos","arclength","reparametrization"],"hasliked":0,"parentid":"NtVBWy","parentname":"Sin arclength reparametrization"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = TEX0(TO_TEX_COORDS(SC));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )   \n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define TO_TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define UNIT                      (  10.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define SCENE_SCALE                 1.5\n#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n\n/* Approximation by Gauss-Legendre quadrature.\n   https://www.shadertoy.com/view/st3yzs\n   https://keisan.casio.com/exec/system/1329114617 */\nfloat arclength(float t)\n{\n    const float xs[5] = float[5](\n        -0.9061798459386639927976,\n        -0.5384693101056830910363,\n        0.,\n        0.5384693101056830910363,\n        0.9061798459386639927976  );\n    const float ws[5] = float[5](\n        0.2369268850561890875143,\n        0.4786286704993664680413,\n        0.5688888888888888888889,\n        0.4786286704993664680413,\n        0.2369268850561890875143 );\n    \n    float a = 0., b = t;\n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0; i < 5; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += sqrt(0.53+cos(x)*cos(x))*ws[i];\n              //I += sqrt(0.53+sin(x)*sin(x))*ws[i];\n              //I += sqrt(1.+cos(x)*cos(x))*ws[i];\n              //I += sqrt(1.+sin(x)*sin(x))*ws[i];\n              \n              //I += (sqrt(0.53+sin(x)*sin(x))*ws[i] + sqrt(0.53+cos(x)*cos(x))*ws[i]) * 0.5;\n    }\n\n    return I * mean;\n}\n/* Bisection method for finding t relative to s */\nfloat reparametrize(float s)\n{\n    /* If in arclength used 1. *\n    s = mod(s, 3.82*2.);\n    s = s > 3.82 ? s - 3.82*2. : s;\n    s = s < -3.82 ? s + 3.82*2. : s;\n    /* If in arclength used 0.53. */\n    s = mod(s, TAU);\n    s = s > PI ? s - TAU : s;\n    s = s < -PI ? s + TAU : s;\n    /**/\n\n    const float tolerance = 1e-7; /* Desired precision */\n    float T[2] = float[2](-PI, PI);\n    float F[2] = float[2](\n        arclength(T[0]),\n        arclength(T[1]));\n    \n    float l = 0.5;\n    \n    for (int i = 0; (i < 16) && (abs(l-s) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float t = (T[0] + T[1]) * 0.5;\n              l = arclength(t);\n\n        int w_idx = int(l>s);\n        \n        F[w_idx] = l; T[w_idx] = t;\n    }\n\n    return sin((T[0] + T[1]) * 0.5);\n}\n/**/\n\n/* tail = 1, 1e-1, 1e-2, ... */\nvec3 trail(vec3 color, float tail)\n{\n    return color * (1.-tail) + tail;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * SCENE_SCALE;\n\n    vec3 color = trail(TEX0(TO_TEX_COORDS(SC)).rgb, 0.01);\n\n    float t = iTime, m = 0.64;    \n    color = mix( color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, vec2(cos(t), sin(t)), 0.1*UNIT)) );\n    color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, vec2(reparametrize(t+PI*0.5), reparametrize(t)), 0.1*UNIT)) );\n    color = mix( color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, vec2(m*tan(cos(t)), m*tan(sin(t))), 0.1*UNIT)) );\n    \n    O = \n        iFrame == 0 ?\n            vec4(1) :\n            vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}