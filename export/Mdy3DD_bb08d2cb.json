{"ver":"0.1","info":{"id":"Mdy3DD","date":"1454499872","viewed":673,"name":"Simplex noise - pixel artifacts","username":"raRaRa","description":"Potential fix for the pixel artifacts in the array an texture-less Simplex noise algorithm. They often show up when the input coordinates hit integers. The right side of the green line shows the original code, with the bug and the left side shows the fix.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","pixel","simplex","bug","artifact","artifacts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\n// I managed to find the root of the pixel artifact problem after porting the code to JavaScript.\n// The main culprit is this line: g = step(x0.yzx, x0.xyz);\n// The right side of the green line shows the original code with the bug, and the left side shows the fix.\n// - JÃ³n Trausti (icewolfy@gmail.com)\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v, bool showBug)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g;\n    \n    if (showBug) {\n        g = step(x0.yzx, x0.xyz);\n    }\n    else {\n        // Old fix to show where the problem lies:\n        // g = vec3(1.0, 1.0, 1.0);\n        // if (x0.x < x0.y)\n        //     g.x = 0.0;\n        // if (x0.y < x0.z)\n        //     g.y = 0.0;\n        // if (x0.z <= x0.x) // <-- The fix is to have less-or-equal here. TODO: Optimize!\n        //     g.z = 0.0;\n        \n        // Suggested fix from iq:\n        // g.z = (x0.z == x0.x) ? 0.0 : g.z;\n    \n        // Suggested fix from Stefan Gustavson\n        g = step(x0.yzz, x0.xyx);\n        g.z = 1.0-g.z; // Ugly fix\n    }\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n      + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\n    return 42.0 * dot( m*m*m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                     dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(vec2(fragCoord.x, fragCoord.y)) / iResolution.xx;\n    vec2 pos = uv * 40.0;\n\tfloat mousePosX = iMouse.x / iResolution.x;\n    float noise = 0.0;\n    \n    // Default the green line on the center of the screen\n    if (mousePosX <= 0.0 || mousePosX > 1.0) {\n        mousePosX = 0.5;\n    }\n    \n    if (uv.x > mousePosX) {\n        // Show the bug\n    \tnoise = snoise(vec3(pos, 1.0), true);\n    }\n    else {\n        // Show the fix\n        noise = snoise(vec3(pos, 1.0), false);\n    }\n    \n    // Draw green vertical line on the mouse x coordinate\n    if (uv.x >= mousePosX - 0.001 && uv.x <= mousePosX + 0.001) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n    else {\n    \tfragColor = vec4(vec3(noise), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}