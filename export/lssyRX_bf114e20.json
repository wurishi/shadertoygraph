{"ver":"0.1","info":{"id":"lssyRX","date":"1489185995","viewed":185,"name":"Graphing4Dummies","username":"mgrant8164","description":"Drag cursor (mouse button held down) left/right to adjust viewport rotation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["graphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//unused at this point\n//#define VIEWRAD 15.0\n\n//Super Sampling Enabled?\n//#define SS\n//Super Sampling Level [1-...] (applied if enabled)\n#define SSA 1\n\n//screen/viewport field of view (as %)\n#define FOV vec2(100.,100.)/100.\n//distance from viewport to target\n#define VIEWDIST 20.0\n//number of iterations to complete of newton's method (zero approx)\n#define NEWT_N 100\n\n//color z multiplier (implementation & function dependant)\n#define CMULT .25\n\n//graphing function definitions\n//F_f : function to graph\n//F_df: derivative (with dx and dy) of function to graph\n/***Test Case 1***/\n/*\n#define F_f  sin(iTime)*(-sin(y-x)+cos(x+y))\n#define F_df sin(iTime)*(-cos(y-x)*(dy-dx)-sin(x+y)*(dx+dy))\n//*/\n/***Test Case 2***/\n/*\n#define F_f  x*x+y*y\n#define F_df x*dx+y*dy\n//*/\n/***Test Case 3 (?)***/\n/*\n#define F_f  sqrt(abs(x-y))/10.\n#define F_df 1./sqrt(abs(x-y))*abs(dx-dy)/10.\n//*/\n/***Test Case 4***/\n//*\n#define F_f  sin(sqrt(x*x+y*y)-iTime*4.)\n#define F_df cos(sqrt(x*x+y*y)-iTime*4.)/(2.*sqrt(x*x+y*y))*(2.*x*dx+2.*y*dy)\n//*/\n/***Test Case 5***/\n/*\n#define F_f sin(x*x+y*y)-cos(x*y)\n#define F_df cos(x*x+y*y)*(2.*x*dx+2.*y*dy)+sin(x*y)*(dx+dy)\n//*/\n\n//constants definitions\n#define PI  3.14159265359\n#define TAU 6.28318530718\n\nvec2 va = vec2(0.,PI/4.);\n\nvec2 soff;\nvec3 target = vec3(0.,0.,0.);\nvec3 vpp;\nvec3 vpr;\n\n//pixel\nvec3 ray = vec3(0.);\n\n\n//unused at this moment\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//returns a color based upon the specified z value\nvec4 getc(float z) {\n    float dpc = max(min(z*CMULT,1.),-1.)/2.+0.5;\n    return vec4(dpc,1.-dpc,0.,1.);\n    //return vec4(vec3(1.-dpc-.3),1.);\n}\n\n//returns f(x,y)\nfloat f(vec2 inp) {\n    float x = inp.x;\n    float y = inp.y;\n    return F_f;\n}\n//returns f'(x,y), given dx and dy\nfloat df(vec2 inp, vec2 dinp) {\n    float x = inp.x;\n    float y = inp.y;\n    float dx = dinp.x;\n    float dy = dinp.y;\n    return F_df;\n}\n//returns g(t), the value of raycasted f(x,y)\nfloat g(float t) {\n    return t*ray.z+vpp.z-f(ray.xy*t+vpp.xy);\n}\n//returns g'(t), needed for newton's method\nfloat dg(float t) {\n    return ray.z-df(t*ray.xy+vpp.xy,ray.xy);\n}\n\n//calculates (hopefully) the first zero of g(t), yields t\nfloat gzero() {\n    float cx = length(vpp.xy);\n    float cy = g(cx); //current yield\n    for(int s = 0; s < 1000; s++) {\n        cx += .1;\n        float ccy = g(cx);\n        if(sign(cy) != sign(ccy)) break;\n        cy = ccy;\n    }\n    cx -= .1;\n    for(int i = 0; i < NEWT_N; i++) {\n        cx = cx - g(cx)/dg(cx);\n    }\n    return cx;\n}//*/\n/*\nfloat gzero() {\n    float cx = length(vpp.xy);\n    float cg;\n    float px = cx - 1.;\n    float pg = g(cx);\n    for(int i = 0; i < NEWT_N; i++) {\n        float cg = g(cx);\n        cx = cx - cg*((cx-px)/(cg-pg));\n        px = cx;\n        pg = cg;\n    }\n    return cx;\n}//*/\n\n\nvec4 mainimg(in vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    //regulate viewport and FOV settings <1., >=1.>\n    vec2 cod = (fragCoord.xy - soff)/min(soff.x,soff.y)*FOV;\n    //rotate viewport aim vector and normalize to get pixel x offset vector\n    //vec3 vox = normalize(vec3(vpr.y, -vpr.x, 0.));\n    vec3 vox = normalize(cross(vpr, vec3(0.0,0.0,1.0)));\n    //rotate viewport aim vector and normalize to get pixel y offset vector\n    //vec3 voy = normalize(vec3(vpr.xy*vpr.z,length(vpr.xy)));\n    vec3 voy = normalize(cross(vpr, vec3(-vpr.y,vpr.x,0.0)));\n    \n    //set pxp to the 3d position of current pixel, 1. away from vp origin\n    vec3 pxp = normalize(vpp)*(length(vpp)-1.);\n    //add pixel x offest to position\n    pxp += vox * cod.x;\n    //add pixel y offset to position\n    pxp += voy * cod.y;\n    \n    //calculate vp origin to pixel location vector (for direction)\n    //no need to normalize, this is done next\n    ray = pxp - vpp;\n    //make ray a normalized vec2 with a slope as z\n    //these become t (vec2 multiplier) and z (float multiplier)\n    ray = ray/length(ray.xy);\n    \n    //calculate zero using newton's method\n    float cx = gzero();\n    \n    //intersection as x and y coords relative to vp origin, and z as pixel depth\n    vec3 intc = vec3(ray.xy*cx,g(cx));\n    //float depth = distance(intc);\n    \n    //absolute intersection position\n    vec3 abp = vec3(vpp.xy+cx*ray.xy,0.);\n    abp.z = f(abp.xy);\n    \n    //finally, set the color as a function of the z (=height=f(intersection))\n    //of the final intersection point\n    //fragColor = getc(abp.z);\n    //fragColor = getc(df(abp.xy,));\n    \n    /*Deprecated beyond this point, for now*/\n    \n    //if(length(abp.xy - target.xy) < VIEWRAD) {\n    if(cx>0.) {\n        fragColor = getc(abp.z);\n    } else {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n    return fragColor;\n}\n\nvoid perframe(vec2 fragCoord) {\n\t//center screen coordinates\n    soff = iResolution.xy * 0.5;\n    //target for viewport to point at\n    target = vec3(0.,0.,0.);\n    //set screen x rotation to mouse position (percentage * 2pi)\n    va.x = iMouse.x/iResolution.x*TAU;\n    va.y = iMouse.y/iResolution.y*PI/1.5-PI/2.;\n    //calculate final viewport position from rotation and distance from target\n    vpp = vec3(sin(va.y)*vec2(cos(va.x),sin(va.x)),cos(va.y))*VIEWDIST;\n    //direction vector from viewport to target\n    //vpr = normalize(target-vpp);\n    //vpp = vec3(0.0, 0.0, 0.0);\n    vpr = normalize(vec3( sin(va.y) * vec2(cos(va.x), sin(va.x)), cos(va.y) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    perframe(fragCoord);\n    #ifdef SS\n    fragColor = vec4(0.);\n    for(float x = 0.; x < 1.; x += 1./float(SSA)) {\n        for(float y = 0.; y < 1.; y += 1./float(SSA)) {\n        \tfragColor += mainimg(fragColor, fragCoord+vec2(x,y));\n    \t}\n    }\n    fragColor /= float(SSA*SSA);\n    #else\n    fragColor = mainimg(fragColor, fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}