{"ver":"0.1","info":{"id":"4ltGRn","date":"1467658361","viewed":473,"name":"Spiky tunnel","username":"Blackorange","description":"Part of demo made for edison 2016,","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","tunnel","triangle","distort","spikes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define pi 3.1416\n#define time iTime\nfloat fpos; \n\nconst int iterations = 128;\n\nvec3 mid_light;\n \n\nmat3 rotz(float t){\n     return mat3( cos(t),  -sin(t), 0,\n       \t          sin(t),   cos(t), 0,\n\t\t  \t\t  0,        0 ,     1);\n}\nmat3 roty(float t){\n    return  mat3( cos(t),  0,  sin(t),\n     \t    \t  0,       1,  0,\n           \t      -sin(t), 0,  cos(t)); \n\n}\n\nmat3 rotx(float t){\n     return mat3( 1, 0 ,      0,\n            \t  0, cos(t), -sin(t),\n\t   \t  \t      0, sin(t),  cos(t));\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ) {\n  vec2 i = floor( p );\n  vec2 f = fract( p );\t\n  vec2 u = f*f*(3.0-2.0*f);\n  return -1.0+2.0*mix( mix( rand( i + vec2(0.0,0.0) ), \n\t\t\t    rand( i + vec2(1.0,0.0) ), u.x),\n\t\t       mix( rand( i + vec2(0.0,1.0) ), \n\t\t\t    rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat trianglewave(float t, float a){\n      float q = t / a;\n      return 2. * abs( 2.*(q - floor(q + 0.5))) - 1.;\n}\nfloat mapFunc(vec3 p){\n\n  p.y +=  0.2 * noise(p.xz + time);\n  float amp = 0.2;\n\n  if (time < 20.) {\n    amp *= clamp(20. - time, 0., 1.);\n    p.y = p.y + trianglewave(p.z, 0.7) * amp + trianglewave(p.x, 0.7) * amp ;\n  }\n\n  return 2. + p.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/ k;\n}\nfloat mapSphere(vec3 p, float r){\n  p.z -= time * 3.;\n  p.z = mod(p.z, 20.) - 2.5;\n  mid_light = p;\n  return length(p)-r;\n}\nfloat map(vec3 p){\n  p.z += time;\n  p.xy += 0.5 * sin(p.z + time);\n\n  float s = mapSphere(p,0.7);\n  p.xy = (rotz(p.z * 0.3) * p).xy;\n  float third = 2. * pi / 3.;\n  float f = mapFunc(p);\n  p = rotz(third) * p; \n  float f1 = mapFunc(p);\n  p = rotz(third) * p; \n  float f2 = mapFunc(p);\n\n  float k = 2.;\n  return min(smin(smin(f, f1, k), f2, k), s);\n}\n\nfloat trace(vec3 origin, vec3 ray, vec3 misc){\n    \n  float t = 0.0;\n  for(int i = 0; i < iterations; i++){\n    vec3 point = origin + ray * t;\n    float dist = map(point);\n    t += dist * 0.5;\n  }\n  return t;\n}\n\n\nvec3 nor(vec3 p, float prec){\n  vec2 e = vec2(prec,0.);\n\n  vec3 n;\n  n.x = map(p+e.xyy) - map(p-e.xyy); \n  n.y = map(p+e.yxy) - map(p-e.yxy); \n  n.z = map(p+e.yyx) - map(p-e.yyx);  \n  return normalize(n);\n\n}\n\n\nvec3 Shade(vec3 p, vec3 n,  vec3 o, vec3 color)\n{\n  vec3 lp = vec3(0,0,1);\n  vec3 s = lp - p;\n    \n  float l = .2;  \n  l += .8 * max(dot(n, normalize(s)), 0.);\n  l += .85 * pow(max(dot(normalize(o - p), reflect(-normalize(s), n)), 0.), 7.);\n  return color * l ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 res = \tiResolution.xy / iResolution.y;\n    vec2 fpos = fragCoord / iResolution.xy;\n\tvec3 pos = vec3(fpos.xy, 1.);\n    pos.x *= res.x / res.y;\n     mat3 rotmat = rotx(-pi/12.);\n    \n     pos =  rotmat * pos;\n     vec3 ray = normalize(vec3(pos.xy - res / 2.,0.5));\n   \n     vec3 origin =  vec3(0.0, 0.0, -3.);\n     origin =  rotmat * origin;\n     float t = trace(origin,ray, vec3(0.5,1.,0.) );\n\n     vec3 p = origin + t * ray;\n     float fog = 1.0 / (1.0 + t * t * 0.0025);\n\t\n    vec3 color = vec3(.3,.5,1.);\n    float e = 0.01;\n    \n    vec3 fc = Shade(p,nor(p,e), origin, color);\n    \n    fragColor = vec4(fc,1.) * fog;\n}\n","name":"Image","description":"","type":"image"}]}