{"ver":"0.1","info":{"id":"ftSyDc","date":"1650859190","viewed":89,"name":"infinite bouncing colorful balls","username":"mwolak","description":"Bouncing colorful balls","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 opU(vec2 d1, vec2 d2) {\n    return (d1.x<d2.x) ? d1 : d2;\n\n}\n\nfloat hash3i(ivec3 p){\n    int retval = 2342391;\n    retval += p.x;\n    retval *= retval;\n    retval %= 1048583;\n    retval += p.y;\n    retval *= retval;\n    retval %= 1048583;\n    retval += p.z;\n    retval *= retval;\n    retval %= 1048583;\n    retval *= retval;\n    retval %= 1048583;\n    float rv = float(retval);\n    return rv/1048583.0;\n}\n\n\nfloat sphere_sd(in vec3 p, in vec3 center, float r) {\n    return length(p - center) - r;\n}\n\nfloat bounce(in float t) {\n    float x = fract(t);\n    return x*(1.0 - x);\n}\n\nvec2 world_sdf(in vec3 p){\n    float randy = 0.2*hash3i(ivec3(int(floor(p.x)),int(floor(p.z)),1));\n    float randx = 0.05*hash3i(ivec3(int(floor(p.x)),int(floor(p.z)),2));\n    float randz = 0.05*hash3i(ivec3(int(floor(p.x)),int(floor(p.z)),3));\n    vec2 retval = vec2(p.y + 0.1, 1.0);\n    retval = opU(retval,vec2(sphere_sd(vec3(fract(p.x + randx),p.y - bounce(iTime + randx*6.28 + randy*6.28 + randz*6.28),fract(p.z + randz)),vec3(0.5,-0.01,0.5), 0.1), 3.0 + randz));\n    return retval;//opU(retval,vec2(sphere_sd(p,vec3(-0.1,0.1,-0.1),0.06),2));\n}\n\n\nvec3 background(in vec3 dir){\n    return vec3(0.0,0.0,0.3);\n}\n\nvec3 calc_unit_normal(in vec3 p) {\n    const vec3 small_step = vec3(0.001,0.0,0.0);\n    \n    float partial_x = world_sdf(p + small_step.xyy).x - world_sdf(p - small_step.xyy).x;\n    float partial_y = world_sdf(p + small_step.yxy).x - world_sdf(p - small_step.yxy).x;\n    float partial_z = world_sdf(p + small_step.yyx).x - world_sdf(p - small_step.yyx).x;\n    \n    vec3 normal = vec3(partial_x,partial_y,partial_z); // don't worry about dividing by delta, since we normalize anyway\n    return normalize(normal);\n}\n\nvec2 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 512;\n    const float MIN_HIT_DIST = 0.001;\n    const float MAX_TRACE_DIST = 1000.0;\n    vec3 curr_pos = ro;\n    vec2 sdf = vec2(0.0);\n    for (int i = 0; i < NUMBER_OF_STEPS;i++){\n        vec3 curr_pos = ro + total_distance_traveled*rd;\n        sdf = world_sdf(curr_pos);\n        float distance_to_closest = sdf.x;\n        if (distance_to_closest < MIN_HIT_DIST*total_distance_traveled) {\n            return vec2(total_distance_traveled, sdf.y);\n        }\n        if(total_distance_traveled > MAX_TRACE_DIST){\n            return vec2(-1.0, 0.0);\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec2(-2, 0.0);\n\n}\n\n\nvec3 shade_point(in vec3 p,in vec3 rd, in float matID) {\n    vec3 normal = calc_unit_normal(p);\n    vec3 light_pos = vec3(7.0,10.0,-10.0);\n    vec3 direction_to_light = normalize(light_pos - p);\n    vec3 base_mat = vec3(0.0);\n    vec3 refl_dir = rd -2.0*dot(rd, normal)*normal;\n     vec3 bright_light = vec3(8.0,8.0,7.0);\n     vec3 diffuse = max(0.0,dot(normal,direction_to_light))*bright_light;\n     vec3 specular = pow(max(0.0,dot(refl_dir,direction_to_light)),100.0)*bright_light;\n     vec3 ambient = vec3(0.4,0.5,0.6);\n     vec2 shadow_ray = ray_march(p, direction_to_light);\n     vec3 col = vec3(0.0);\n     if(shadow_ray.x > 0.0) {\n         diffuse *= 0.0;\n         specular *= 0.0;\n     }\n    if (matID == 1.0) {\n        base_mat = vec3(0.1,0.1,0.1);\n        diffuse *= base_mat;\n        ambient *= base_mat;\n        col += diffuse + ambient +  specular;\n    } else if (matID == 2.0){\n        base_mat = vec3(0.01,0.2,0.01);\n        diffuse *= base_mat;\n        ambient *= base_mat;\n        col += diffuse + ambient +  specular;\n    }\n    else if (matID >= 3.0) {\n        int rz = int(10000.0*fract(matID));\n        float r = hash3i(ivec3(rz,4,1));\n        float g = hash3i(ivec3(rz,1,2));\n        float b = hash3i(ivec3(rz,0,1));\n        base_mat = vec3(0.2*r,0.2*g,0.2*b);\n        ambient *= base_mat;\n        diffuse *= base_mat;\n        col += diffuse + ambient +  specular;\n        \n    }\n    else {\n        base_mat = vec3(0.0,0.0,0.03);\n        diffuse *= 0.0;\n        specular *= 0.0;\n        ambient *= base_mat;\n        col += diffuse + ambient +  specular;\n    }\n  \n    \n    \n\n    return pow(col,vec3(0.5));\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy  - vec2(0.5,0.5);\n    float ar = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5,0.5))*vec2(ar,1.0);\n    vec3 camera_position = vec3(0.0,0.02,-0.5);\n    vec3 ro = camera_position;\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    vec2 rm_res = ray_march(ro,rd);\n    vec3 shaded_color = shade_point(ro + rm_res.x*rd,rd, rm_res.y);\n\n    // Output to screen\n    fragColor = vec4(shaded_color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}