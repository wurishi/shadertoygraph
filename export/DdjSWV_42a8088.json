{"ver":"0.1","info":{"id":"DdjSWV","date":"1670917364","viewed":59,"name":"normal scene","username":"lambwww","description":"一个普通的场景，待更新","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["scene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct sphere{vec3 center;float radius;};\nstruct ray{vec3 start;vec3 dir;};\nstruct material{float d;float id;vec3 color;};\nvec3 ambient()\n{\n    float k=0.2;\n    vec3 ambCol=vec3(0.3,0.1,0.1);\n    return ambCol*k;\n}\nfloat diffuse(vec3 light,vec3 normal)\n{\n    float k=0.2;\n    float halfLamb=dot(light,normal)*0.5+0.5;\n    return halfLamb;\n}\n//场景图，并且根据不同的id赋不同的颜色值\nmaterial map(vec3 p){\n    material mat;\n    mat.color=vec3(1,1,1);\n    vec3 center=vec3(0,0, 4); \n    float sphere1=length(p-center)-1.0;\n    float sphere2=length(p-center-vec3(3,0,0))-1.;\n    float plane=p.y+2.;\n    if(sphere1<=0.001)\n    {\n        mat.id=0.;\n        mat.color=vec3(1,0.5,0.5);\n    }\n    if(sphere2<=0.001)\n    {\n        mat.id=1.;\n    }\n    if(plane<=0.001)\n    {\n        mat.id=2.;\n        mat.color= vec3(1,1,0);\n    }\n    mat.d=min(sphere1,min(sphere2,plane));\n    return mat;\n}\n//利用曲面的梯度求法线，就是对xyz分量求偏导\nvec3 GetNormal(vec3 p){\n    float d = map(p).d;\n    vec2 e = vec2(0.001,0.0);\n    float  fdx = d-map(p-e.xyy).d;\n    float fdy = d-map(p-e.yxy).d;\n    float fdz = d-map(p-e.yyx).d;\n    return normalize(vec3(fdx,fdy,fdz));\n}\n//求光线到球表面的距离，使用光线无限接近\nmaterial rayMatch(vec3 rayS,vec3 rayD)\n{\n    material mat;\n    float d=0.;\n    for(int i=0;i<250;i++)//之前循环次数少了，有的地方没找到\n    {\n        vec3 p=rayS+rayD*d;\n        mat=map(p);\n        float tempD=mat.d;\n        if(tempD<=0.001 || tempD>=40.) //太近代表找到了，太远代表看不见\n            break;\n        d+=tempD;\n    }\n    mat.d=d;\n    return mat;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv初始化\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    //生成视线\n    ray viewRay;\n    viewRay.start=vec3(0,0,-3);\n    viewRay.dir=normalize(vec3(uv,1));//光线向量，要限制在【0，1】中间\n    //生成球体，这里主要是球体的简单信息\n    sphere mys;\n    mys.center=vec3(0, 0, 4);\n    mys.radius=1.;\n    //求眼睛到球体的距离，如果在距离内代表可以被看见，就进行着色\n    material mat=rayMatch(viewRay.start,viewRay.dir);\n    if(mat.d<=40.)\n    {\n        //光线起点到球表面的最小距离\n        float d=rayMatch(viewRay.start,viewRay.dir).d;\n        //球表面的点\n        vec3 p=viewRay.start+viewRay.dir*d;\n        //表面那个点对应的法线\n        vec3 normal = GetNormal(p);\n        //生成光线\n        ray light;\n        light.start=vec3(-5,8,2);\n        light.dir=normalize(light.start-p);\n        //diffuse\n        float diffuse = dot(normal,light.dir);\n        vec3 color = vec3(1,1,1);\n        //shadow\n        //让p点也就是物体表面的点沿着光线方向，计算下一个最近物体的距离，如果在范围内，就投射阴影（加深那一个点的颜色\n        p=p+normal*0.002;\n        float d0 = rayMatch(p,light.dir).d;\n        if(d0<=40.0) diffuse*=0.1;\n        \n        color=diffuse*color*mat.color;\n        \n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n        fragColor = vec4(0.1, 0.2, 0.4, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}