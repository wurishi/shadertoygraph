{"ver":"0.1","info":{"id":"fs2fRt","date":"1646864383","viewed":167,"name":"UkraineHeart","username":"pelleman","description":"A heart for Ukraine.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ukraineheart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Thanks to miloyip for heart shader code from\n// https://www.shadertoy.com/view/XtXGR8\n// Thanks to quizcanners for colors from shader\n// https://www.shadertoy.com/view/7sBBRV\n\n// With love to the people of Ukraine. Slava Ukraini!\n\nfloat f(vec3 p) {\n    \n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\n// Bisection solver for y\nfloat h(float x, float z) {\n    float a = 0.0, b = 0.75, y = 0.5;\n    for (int i = 0; i < 16; i++) {\n        if (f(vec3(x, y, z)) <= 0.0)\n            a = y;\n        else\n            b = y;\n        y = (a + b) * 0.5;\n    }\n    return y;\n}\n\n// Analytical gradient\n// (-2 x z^3+6 x (-1.+x^2+2.25 y^2+z^2)^2) \n// (-0.225 y z^3+13.5 y (-1.+x^2+2.25 y^2+z^2)^2)\n// (z (-3 x^2 z-0.3375 y^2 z+6 (-1.+x^2+2.25 y^2+z^2)^2))\nvec3 normal(vec2 p) {\n    vec3 v = vec3(p.x, h(p.x, p.y), p.y);\n    vec3 vv = v * v;\n    vec3 vvv = vv * v;\n    float a = -1.0 + dot(vv, vec3(1, 2.25, 1));\n   \ta *= a;\n    \n  \treturn normalize(vec3(\n        -2.0 * v.x * vvv.z +  6.0 * v.x * a,\n      -0.225 * v.y * vvv.z + 13.5 * v.y * a,\n      v.z * (-3.0 * vv.x * v.z - 0.3375 * vv.y * v.z + 6.0 * a)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n\tvec3 p = vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x), 0);\n    \n    float s = sin(iTime * 3.5);\n    s *= s;\n    s *= s;\n    s *= 0.075;\n    vec3 tp = p * vec3(1.0 + sin(s-0.05), 1.0 - sin(s-0.05), 0.0) * 1.75;\n    \n    vec3 c;\n    if (f(tp.xzy) <= 0.0) {\n        vec3 n = normal(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 8.0);\n        float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        if(uv.y>0.045 + (s*0.1)) {\n            c = diffuse * vec3(0.,0.34,0.71) + specular * vec3(0.4) + rim * vec3(0.5);\n        } else {\n            c = diffuse * vec3(1., 0.84, 0.) + specular * vec3(0.4) + rim * vec3(0.5);        \n        }\n    }\n\telse\n        c = vec3(1.0, 1.0, 1.0) * (1.0 - 0.25 * length(p*0.5));\n    \n\tfragColor = vec4(c, 1);\n}","name":"Image","description":"","type":"image"}]}