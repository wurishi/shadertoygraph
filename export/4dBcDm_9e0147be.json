{"ver":"0.1","info":{"id":"4dBcDm","date":"1492559787","viewed":175,"name":"learning ray marching / sdfs","username":"rytone","description":"probably bad","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCH_STEPS 512\n#define PI 3.14159265359\n#define DEG_TO_RAD PI / 180.0\n#define EPSILON 0.0001\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n// polynomial smooth min from https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// gets distance from the ray position (pos) to some surface defined by this function\n// if the returned value is negative, then the ray has intersected with the surface.\nfloat sd(vec3 pos) {\n    float dist1 = length(pos - vec3(sin(iTime) - 0.5, 0.6 + sin(iTime * 2.0) / 2.0, sin(iTime * 1.1))) - 0.5;\n    float dist2 = length(pos - vec3(sin(iTime * 1.8) + 0.5, 0.6 - sin(iTime * 3.0) / 2.0, cos(iTime * 2.7))) - 0.5;\n    \n    float sDist = smin(dist1, dist2, 1.4);\n    \n    float surface = length(max(abs(pos - vec3(0.0, -3.0, 0.0))-2.0,0.0));\n    \n    float dist = smin(sDist, surface, 2.0);\n    \n    return dist;\n}\n\n// marching function\nfloat march(vec3 origin, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = origin + dir * depth;\n        float dist = sd(p);\n        if (dist < EPSILON) {\n            // intersection\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            // too far!\n            return end;\n        }\n    }\n    return end;\n}\n\n// get ray direction\nvec3 ray_dir(float fov, vec2 size, vec2 pos) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// copy pasted math\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float far = 50.0;\n    \n    vec3 eye = vec3(cos(iTime) * 8.0, 3.0, sin(iTime) * 8.0);\n    vec3 look =  ray_dir(40.0, iResolution.xy, fragCoord.xy);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    look = viewToWorld * look;\n    \n    float depth = march(eye, look, 0.0, far);\n    \n    if (depth == far) {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    } else {\n        vec3 lightPos = vec3(3.0, 5.0, 3.0);\n        vec3 hitPos = eye + look.xyz * depth;\n        vec3 lightDir = normalize(hitPos - lightPos);\n        \n        float shadowVal = 0.0;\n        for (int i = 0; i <= 16; i++) {\n            float lightDepth = march(lightPos, lightDir + (vec3(random(vec3(iTime, fragCoord)), random(vec3(iTime + float(i), fragCoord)), random(vec3(iTime - float(i), fragCoord))) - 0.5) * 0.0001, 0.0, far);\n        \tvec3 lightHitPos = lightPos + lightDir * lightDepth;\n            if (length(hitPos - lightHitPos) > 0.001) {\n            \tshadowVal += 0.5;\n        \t}\n        }\n        shadowVal /= 16.0;\n        shadowVal = 1.0 - shadowVal;\n        \n        // object color\n        vec3 col = vec3(0.9, 0.9, 0.9);\n        \n        fragColor = vec4(col * shadowVal, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}