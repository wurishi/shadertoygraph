{"ver":"0.1","info":{"id":"l3fSRM","date":"1709246002","viewed":272,"name":"Bripolis","username":"Aurcereal","description":"Inspired by shadertoy.com/user/yasuo","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat t;\nfloat invertEnable;\n\nfloat insideBrick;\nfloat redEnable = 0.;\nfloat blueEnable = 0.;\n\nfloat blueShaderToggle = 0.;\n\n#define PALLETESWITCH 0\n\n//some red on inner rings either alternating or randomly scattered\n\nfloat sbBox(vec2 p, vec2 dim)\n{\n    p = abs(p) - dim*.5;\n    return step(p.x, 0.) * step(p.y, 0.);\n}\n\nfloat sdBox(vec2 p, vec2 dim)\n{\n    p = abs(p) - dim*.5;\n    float s = sqrt(p.x*max(p.x,0.) + p.y*max(p.y,0.));\n    return step(s, 0.) * max(p.x,p.y) + s;\n}\n\nfloat sbTruncet(vec2 p, float repSize, float cEnable)\n{\n    //\n    float thickness = .015;\n    float radius = repSize*.5;\n    float k = 8.0;\n    \n    //\n    vec2 lp = p;\n    lp = mod(lp + repSize*.5, repSize) - repSize*.5;\n    vec2 id = p - lp;\n    \n    float rnd = hash21(id+0.001);\n    float swap = step(rnd, 0.5)*2.-1.;\n    \n    //lp.x *= swap;\n    \n    //\n    vec2 cp = lp;\n    cp = abs(cp);\n    cp -= repSize*.25;\n    float bc = step(hash21(2.*id+0.01), 0.3+1.0) * cEnable*btwn(length(cp), repSize*.055, repSize*.08);\n    \n    //\n    lp -= repSize*.5;\n    \n    //\n    return saturate(\n            step(abs(hypLength(lp, k) - radius), thickness*.5) + \n            step(abs(hypLength(lp + repSize, k) - radius), thickness*.5) +\n            bc\n            );\n}\n\nfloat sbTruncets(vec2 p)\n{\n    p = rot(-.2) * p;\n\n    float repSize = .48;\n    float tt = t*.1;\n    \n    float bSmall = sbTruncet(p-tt, repSize*.5, 0.) + \n                   sbTruncet((p-tt)*vec2(-1.,1.) + repSize*.5*.5, repSize*.5, 0.);\n                   \n    float bLarge = sbTruncet(p +tt, repSize, 0.) + \n                   sbTruncet((p+tt)*vec2(-1.,1.) + repSize*.5, repSize, 0.);\n                   \n    p = toPolar(p).yx - vec2(0., 1.0);\n    p.x *= 1.1;\n                   \n    float bOther = sbTruncet(p, repSize*.5, 0.) + \n                   sbTruncet(p*vec2(-1.,1.), repSize*.5, 0.);\n                   \n    bSmall = saturate(bSmall);\n    bLarge = saturate(bLarge);\n                   \n    float b = max(bSmall*.2, bLarge*.7);\n    \n    return b;\n}\n\nfloat sbVoxelRing(vec2 p, float radius, float repSize, float outlineSize, float widthBound, float frequency, float xOff, float tOff, float inverterMult, float voxelEnable, float inverterEnable)\n{\n    p = vec2(mod(atan(p.y, p.x)+xOff, TAU), length(p) - radius);\n    \n    //\n    float repTime = 2.4;\n    \n    //\n    vec2 lp = p;\n    lp = mod(lp+repSize*.5, repSize)-repSize*.5;\n    vec2 id = p - lp;\n    \n    float sizeMult = 0.7;\n    float allowCell = step(hash21(id+0.001 + t - mod(t+tOff, repTime)), frequency) * step(abs(id.y), widthBound*.5)\n                        * step(abs(id.x-PI), PI*.97);\n                        //step(mod(id.x, TAU/4.), TAU/8.);\n                        \n    float currentAllow = allowCell;\n    float futureAllow = step(hash21(id+0.001 + t +repTime- mod(t+tOff, repTime)), frequency) * step(abs(id.y), widthBound*.5);\n    float mt = mod(t+tOff, repTime)/repTime;\n    sizeMult = currentAllow + (futureAllow-currentAllow)*pow(smoothstep(0.7, 1.0, mt), 2.);\n    \n    lp /= sizeMult;\n    float inCell = step(abs(lp.x), repSize*.5)*step(abs(lp.y),repSize*.5);\n    float sbSquare = saturate(\n                        (step(repSize*.5 - outlineSize, abs(lp.x)) + step(repSize*.5 - outlineSize, abs(lp.y))) *\n                        inCell\n                        );\n    \n    //PLUS\n    vec2 pp = abs(lp);\n    float plusLength = repSize*.5;\n    float plusThick = repSize*.12;\n    float sbPlus = saturate(\n                       step(pp.x, plusLength*.5) * step(pp.y, plusThick*.5) + \n                       step(pp.x, plusThick*.5) * step(pp.y, plusLength*.5)\n                    );\n                    \n    //MULT\n    vec2 mp = rot(PI*.25) * lp;\n    mp = abs(mp);\n    float sbMult = saturate(\n                       step(mp.x, plusLength*.5) * step(mp.y, plusThick*.5) + \n                       step(mp.x, plusThick*.5) * step(mp.y, plusLength*.5)\n                    );\n    \n    //SUB\n    vec2 sp = pp;\n    float sbSub = step(sp.x, plusLength*.5) * step(sp.y, plusThick*.5);\n    \n    //DIV\n    vec2 divp = abs(lp);\n    float sbDiv = saturate(\n                    step(pp.x, plusLength*.5) * step(pp.y, plusThick*.5) + \n                    step(length(divp - vec2(0., plusLength*.43)), plusLength*.15)\n                );\n                \n    //MUX\n    float opRand = hash21(id+0.001);// + t - mod(t+tOff, 2.4));\n    float sbOp = btwn(opRand, 0., .25) * sbPlus + \n                 btwn(opRand, .25, .5) * sbMult + \n                 btwn(opRand, .5, .75) * sbSub +\n                 btwn(opRand, .75, 1.) * sbDiv;\n    \n    float b = pow(sizeMult,1./2.)*voxelEnable*saturate(sbSquare+sbOp)* step(abs(id.x-PI), PI*.97);//*allowCell; sorry jank :(\n    insideBrick = max(insideBrick, voxelEnable*inCell*allowCell);\n    \n    redEnable = max(redEnable, (1.-blueShaderToggle*.3)*voxelEnable*saturate(sbSquare+sbOp)* step(abs(id.x-PI), PI*.97)*step(hash21(5.*id+0.001), 0.2+0.15*blueShaderToggle));\n    blueEnable = max(blueEnable, voxelEnable*saturate(sbSquare+sbOp)*redEnable*.4*step(hash21(id*7.+.001), 0.4));\n    \n    //\n    float circCount = 8.;\n    float partSize = TAU/circCount;\n    vec2 cp = p; float cpo = cp.x;\n    cp.x = mod(cp.x, partSize*2.) - partSize;\n    float cpID = cpo - cp.x;\n    float cpAlt = step(abs(mod((cpID-partSize*.5)/partSize, 2.) - 1.), .5)*2.-1.;\n    float circSub = step(length(cp), .3*.5*partSize);\n    \n    //\n    float ditherSize = 0.12;\n    vec2 dp = mod(p+ditherSize*.5-.0*t, ditherSize) - ditherSize*.5; \n    vec2 did = p - dp;\n    float trailOff = 1.4*t*inverterMult;\n    did.x -= 1.4*t*1.*inverterMult; did.x /= PI;\n    float trailLocation = mod(did.x,1.); //location in trail\n    float flpCol = step(abs(mod(did.x - trailLocation,2.)-1.), .5)*2.-1.;\n    float boxSize = ditherSize*pow(trailLocation,1.); //1 in pow and mult t to 2\n    float inv = inverterEnable*(1.-circSub)*sbBox(dp, vec2(boxSize)) * step(abs(p.y), widthBound*.6);\n    invertEnable = max(invertEnable, inv);\n    \n    redEnable = max(redEnable, smoothstep(0.5, 1.2, trailLocation)*inv);\n    blueEnable = max(blueEnable, smoothstep(0.5, 1.2, trailLocation)*inv*((sin(t)*flpCol)*.5+.5));\n    \n    //\n    float circTrailLoc = mod((cpID - trailOff)/PI, 1.);\n    float bounce = smoothstep(1.0, 0.98, circTrailLoc) * smoothstep(0.9, 0.98, circTrailLoc);\n    cp /= 1.+.1*bounce;\n    float o = mod(atan(cp.y, cp.x), TAU);\n    float lo = mod(o + t * cpAlt, TAU/3.) - TAU/6.;\n    float addCirc = step(length(cp), .17*.5*partSize) +\n                    step(lo, 0.) * btwn(length(cp), .19*.5*partSize, .23*.5*partSize);\n                    \n    float circRed = 0.3*smoothstep(1.0, 0.98, circTrailLoc) * smoothstep(0.75, 0.98, circTrailLoc);\n    redEnable = max(redEnable, circRed*addCirc*inverterEnable);\n                    \n    //addCirc = 0.;\n    //circ = 0.;\n                    \n    \n    b = saturate(b + inverterEnable*addCirc);\n    \n    return b;// + inv * (1.-2.*b);\n}\n\nfloat sbRectRing(vec2 p, inout float disallow, float radius, float dimMult, float count, float outlineMult, float off, float red, float redMoveMult, float sr)\n{\n\n    //\n    vec2 dim = vec2(0.05, 0.1)*dimMult;\n    float outlineSize = 0.01;//*outlineMult;\n    float disallowSize = 0.003;\n    \n    //\n    float partSize = TAU/count;\n    \n    //\n    vec2 lp = p;\n    lp = toPolar(lp); lp.y += off; float otheta = lp.y;\n    lp.y = mod(lp.y, partSize) - partSize*.5;\n    float thetaID = otheta - lp.y;\n    lp = toCartesian(lp);\n    \n    lp = rot(partSize) * lp;\n    float bSide1 = sbBox(lp - vec2(radius, 0.), dim.yx) - sbBox(lp - vec2(radius, 0.), dim.yx-outlineSize);\n    bSide1 *= (1.-disallow);\n    disallow = max(disallow, sbBox(lp - vec2(radius, 0.), dim.yx+disallowSize));\n    \n    lp = rot(-partSize) * lp;\n    float bMain = sbBox(lp - vec2(radius, 0.), dim.yx) - sbBox(lp - vec2(radius, 0.), dim.yx-outlineSize);\n    bMain *= (1.-disallow);\n    disallow = max(disallow, sbBox(lp - vec2(radius, 0.), dim.yx+disallowSize));\n    \n    lp = rot(-partSize) * lp;\n    float bSide2 = sbBox(lp - vec2(radius, 0.), dim.yx) - sbBox(lp - vec2(radius, 0.), dim.yx-outlineSize);\n    bSide2 *= (1.-disallow);\n    disallow = max(disallow, sbBox(lp - vec2(radius, 0.), dim.yx+disallowSize));\n    \n    //\n    lp = rot(partSize) * lp;\n    \n    float repTime = 1.2; //2\n    float ct = t - mod(t, repTime);\n    float mt = mod(t, repTime)/repTime;\n    vec2 id = vec2(radius+0.2, thetaID);\n    \n    float canRed = 1.;\n    \n    #if 1\n    float stripeCount = 3.;\n    float stripeFrac = 0.5;\n    float stripeSmoothness = 0.15;\n    //\n    float stripeSize = TAU/stripeCount;\n    float thetaPos = thetaID - off;\n    thetaPos = mod(thetaPos + .5*t*redMoveMult, stripeSize)/stripeSize - .5;\n    thetaPos = abs(thetaPos) - stripeFrac*.5;\n    canRed *= smoothstep(stripeSmoothness*.5, -stripeSmoothness*.5, thetaPos);\n    #elif 0\n    thetaID = (floor((thetaID/partSize-.5)/2.)*2.+.5)*partSize;\n    thetaID += ct*partSize/repTime;\n    canRed *= step(abs(mod((thetaID - partSize*.5)/partSize,3.)-1.),.5);\n    canRed *= smoothstep(0.05, 0.25, mt) * smoothstep(0.9, 0.45, mt); //would make it more moving so future appears while past is still here and past disappeares in future always a red thing\n    canRed *= step(0.17, length(p));\n    #elif 0\n    thetaID = (floor((thetaID/partSize-.5)/2.)*2.+.5)*partSize;\n    thetaID += ct*partSize/repTime;\n    float canRedPresent = step(abs(mod((thetaID - partSize*.5)/partSize,3.)-1.),.5);    \n    float canRedFuture = step(abs(mod((thetaID - partSize*.5)/partSize+1.,3.)-1.),.5);\n    canRed = canRedFuture * smoothstep(0.45, 0.65, mt) + canRedPresent * smoothstep(0.9, 0.45, mt); //would make it more moving so future appears while past is still here and past disappeares in future always a red thing\n    canRed *= step(0.17, length(p));\n    #elif 0\n    canRed *= step(hash21(vec2(radius+0.2, thetaID)+ct), 0.3);\n    canRed *= smoothstep(0.05, 0.25, mt) * smoothstep(0.9, 0.45, mt); //.15 begin\n    ////canRed *= smoothstep(0.18, 0.3, radius);\n    #endif\n    blueEnable = max(blueEnable, .5*(.2*0.*bMain+0.6*bMain*smoothstep(0.18+.2, .3+.1, sr)));\n    \n    redEnable = max(redEnable, red*canRed*bMain*(1.-blueShaderToggle*.3));\n    \n    return bMain;\n    \n}\n\nfloat sbRectRings(vec2 p)\n{\n    p *= 0.7-.05;\n\n    float disallow = 0.;\n    float rt = 0.1*t;\n\n    return sbRectRing(p, disallow, 0.2, 1.0, 28.,     1.2, rt, 0., 0., .2) + \n           sbRectRing(p, disallow, 0.25, 1., 40.,     1.1,-rt, 1., 1., .25) + \n           sbRectRing(p, disallow, 0.28, 1.4, 20.,    1.,  rt, 1., 1., .3) + \n           sbRectRing(p, disallow, 0.325+.03, 1., 36.,1., -rt, 1., 1., .4) + \n           sbRectRing(p, disallow, 0.356, 1.7, 25.,   1.,  rt, 1., 1., .55);\n}\n\nfloat sbEye(vec2 p)\n{\n    /*\n    p *= 2.7;\n    float d1 = sdEye(p);\n    float d2 = sdEye2(p);\n    float d = mix(d1, d2, sin(2.*t)*.5+.5);\n    return step(d, 0.) + step(0.02, d) * step(d,0.06);*/\n\n    p *= 2.1;\n\n    vec2 dim = vec2(0.2, 0.5);\n    float gap = 0.08;\n    float outline = 0.04;\n    \n    float bInner = sbBox(p, dim);\n    \n    float bOuterCut = sbBox(p, dim+gap);\n    float bOuterAdd = sbBox(p, dim+gap+outline);\n    float bOuter = bOuterAdd*(1.-bOuterCut);\n    \n    float b = saturate(bInner + bOuter);\n    \n    float bKillOther = sbBox(p, dim+gap+outline)*(1.-b);\n    \n    return saturate(bInner + bOuter) - bKillOther;\n}\n\nfloat sbLine(vec2 p, vec2 start, vec2 end, float thickness)\n{\n    p -= start;\n    \n    vec2 fo = normalize(end-start);\n    vec2 up = mat2x2(0.0, 1.0, -1.0, 0.0) * fo;\n    \n    p = vec2(dot(p, fo), dot(p, up));\n    p.x /= length(end-start);\n    \n    p.x = abs(p.x-0.5);\n    \n    return step(p.x, 0.5) * step(abs(p.y), thickness*.5);\n}\n\nfloat sbCLK(vec2 p, float radius, float period, float lo, float hi, float thickness, float xOff, float bridge) //tangling double CLK?\n{\n    p = vec2(mod(atan(p.y, p.x) + xOff, 6.283), length(p) - radius);\n\n    //\n    p.x = mod(p.x, period) - period*.5;\n    \n    float b = saturate(\n            sbLine(p, vec2(-period*.5, lo-thickness*.5), vec2(-period*.5, hi+thickness*.5), thickness)*bridge + \n            sbLine(p, vec2(period*.5, lo-thickness*.5), vec2(period*.5, hi+thickness*.5), thickness)*bridge + \n            \n            sbLine(p, vec2(-period*.5, lo), vec2(thickness*.5, lo), thickness) + \n            sbLine(p, vec2(0., lo), vec2(0., hi), thickness)*bridge + \n            sbLine(p, vec2(-thickness*.5, hi), vec2(period*.5, hi), thickness)\n        );\n        \n    return b;\n}\n\nfloat sbCLKs(vec2 p)\n{\n    float clk1 = sbCLK(p, 1.45, 0.6, -.1, .1, 0.02, -t*.1, 0.);\n    float clk2 = sbCLK(p, 1.45, 0.15*.5, -.06, .06, 0.02*.7, 0.15+t*.1, 1.);\n\n    p *= 0.35;\n\n    float clk1inner = 0.*sbCLK(p, 0.1, 0.6, -.1, .1, 0.02*.5, t*.1, 0.);\n    float clk2inner = 0.*sbCLK(p*.4, 0.0, 0.15, -.06, .06, 0.01, 0.15-t*.1, 1.);\n    \n    return saturate(clk1+clk2+clk1inner+clk2inner);\n}\n\nfloat sampleVignette(vec2 p)\n{\n    vec2 rp = p;\n    p = abs(p);\n    vec2 corner = vec2(iResolution.x/iResolution.y, 1.);\n    p = corner - p;\n    float d = min(p.x, p.y);\n    \n    float ss = smoothstep(1.3, 1.5, length(rp)); //smoothstep(0.1, -.1, d)\n    float lightnessMult = 1.+.8*floor(3.*ss)/3.;\n    \n    return lightnessMult;\n}\n\nfloat sbMain(vec2 p)\n{\n\n    float ring1 = sbVoxelRing(p, 1., 0.07, .005, .3, .3, t*.2, 0., 1., 0., 1.);\n    float ring2 = sbVoxelRing(p*(.5-.05), 1., 0.08, 0.008, .4, .4,1.+t*.2, 1.2, -1., 1., 0.);\n    \n    float bCLK = sbCLKs(p);\n    \n    float bEye = sbEye(p);\n    \n    float bRectRings = sbRectRings(p);\n    \n    float exists = saturate(max(ring1+ring2+bCLK+bEye+bRectRings, \n        (1.-insideBrick)*sampleVignette(p)*.19*sbTruncets(p)*step(0.625, length(p))));\n    \n    //\n    float o = mod(atan(p.y, p.x), TAU);\n    float r = length(p);\n    float lr = mod(r-t*2., 8.0);\n    float llr = mod(lr, 0.5);\n    \n    float lrid = lr - llr;\n    float allowPulse = step(lrid, 1.0);\n    \n    float inv = step(abs(llr-.125) + .00*step(mod(o, TAU/16.), TAU/32.), 0.125) * allowPulse * step(0.6, r);\n    inv = 0.;\n    inv = inv + invertEnable*(1.-2.*inv);\n    \n    return exists + inv * (1. - 2.*exists);\n    \n}\n\nfloat render(vec2 fragCoord)\n{\n    t = iTime;\n       \n    vec2 p = ((fragCoord/iResolution.xy)*2.0-1.0)*vec2(iResolution.x/iResolution.y, 1.);\n    p *= 1.4;\n\n    float exists = sbMain(p);\n    \n    return exists;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       \n    vec2 V = vec2(.5, 0.);\n    float b = render(fragCoord) + render(fragCoord+V.xy) + render(fragCoord+V.yx) + render(fragCoord+V.xx);\n    b *= .25;\n\n    fragColor = vec4(vec3(b), 1.0);\n    #if PALLETESWITCH\n    fragColor.rgb = mix(fragColor.rgb, mix(vec3(0.224,0.922,0.969), vec3(.18,.06,1.),1.4*blueEnable*blueShaderToggle), redEnable);\n    #else\n    fragColor.rgb = mix(fragColor.rgb, mix(vec3(1.,0.,0.), vec3(0.,0.,1.),blueEnable*blueShaderToggle), redEnable);\n    #endif\n    //fragColor.rgb = fragColor.rgb*sqrt(fragColor.rgb);\n\n       \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592\n#define TAU 6.283\n\n//Hash functions from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p)\n{\n    p -= mod(p, 0.01);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31flr(vec3 p3)\n{\n    p3 = p3 - mod(p3, .1);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//\n\n//\nfloat saturate(float f) { return clamp(f, 0.,1.); }\n\n//\nfloat btwn(float f, float lo, float hi) { return step(lo, f) * step(f, hi); }\n\n//\nvec2 toPolar(vec2 cart)\n{\n    return vec2(length(cart), mod(atan(cart.y, cart.x), TAU));\n}\n\nvec2 toCartesian(vec2 polar)\n{\n    return polar.x * vec2(cos(polar.y), sin(polar.y));\n}\n\nmat2x2 rot(float o) { return mat2x2(cos(o), sin(o), -sin(o), cos(o)); }\n\nfloat hypLength(vec2 v, float k) { return pow(pow(v.x, k) + pow(v.y, k), 1./k); }","name":"Common","description":"","type":"common"}]}