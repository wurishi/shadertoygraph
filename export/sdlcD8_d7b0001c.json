{"ver":"0.1","info":{"id":"sdlcD8","date":"1642042199","viewed":250,"name":"SDF Marching","username":"JuanDeager","description":"DfS\nsike\nSDF","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON (1e-4)\n\n// thanks to jb for this\nfloat de( vec3 p ){\n    p = p.xzy;\n    vec3 cSize = vec3(1., 1., 1.3);\n    float scale = 1.;\n    for( int i=0; i < 12; i++ ){\n        p = 2.0*clamp(p, -cSize, cSize) - p;\n        float r2 = dot(p,p+sin(p.z*.3));\n        float k = max((2.)/(r2), .027);\n        p *= k;  scale *= k;\n    }\n    float l = length(p.xy);\n    float rxy = l - 4.0;\n    float n = l * p.z;\n    rxy = max(rxy, -(n) / 4.);\n    return (rxy) / abs(scale);\n}\n  \nfloat sdSphere(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    return distance(pos, spherePos) - sphereRadius;\n}\n\nfloat sdXZPlane(vec3 pos, float planeHeight)\n{\n    return pos.y - planeHeight;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (a - b) / k, 0., 1.);\n    return mix(a, b, h) - k * h * (1. - h);\n}\n\nbool epsilonEquals(float a, float b, float e)\n{\n    return abs(a - b) < e;\n}\n\n// tonemapping function\nvec3 aces_approx(vec3 v)\n{\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return smin(\n        sdSphere(p, vec3(-1, 0, -3), 0.5),\n        smin(\n            sdSphere(p, vec3(1.+ cos(iTime), 0., -3.), 0.5),\n            sdXZPlane(p, -1.5), 1.\n        ),\n        1.\n    );\n    //return de(p);\n}\n\nvec3 getNormal(vec3 pos, float origDist)\n{\n    float xDiff = sceneSDF(pos + vec3(EPSILON, 0, 0));\n    float yDiff = sceneSDF(pos + vec3(0, EPSILON, 0));\n    float zDiff = sceneSDF(pos + vec3(0, 0, EPSILON));\n    return normalize(vec3(xDiff, yDiff, zDiff) - origDist);\n}\n\nstruct RayHit\n{\n    float t;\n    vec3 albedo;\n    vec3 normal;\n};\n\nRayHit rayMarch(vec3 origin, vec3 direction)\n{\n    RayHit hit;\n    hit.t = -1.0;\n    \n    vec3 curPos = origin;\n    float nextDist = 0.0;\n    for (int i = 0; i < 250; i++)\n    {\n        curPos += nextDist * direction;\n        nextDist = sceneSDF(curPos);\n        \n        if (nextDist < EPSILON)\n        {\n            hit.t = distance(origin, curPos);\n            hit.normal = getNormal(curPos, nextDist);\n            //hit.albedo = hit.normal * .5 + .5;\n            hit.albedo = vec3(1.0);\n            break;\n        }\n    }\n    \n    return hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.y / iResolution.x;\n    uv.y *= aspect;\n    \n    //vec3 origin = vec3(sin(iTime)/500., 2, 0.01);\n    vec3 origin = vec3(0.);\n    vec3 dir = normalize(vec3(uv, -1.0));\n\n    RayHit hit = rayMarch(origin, dir);\n    \n    vec3 color = vec3(0.0);\n    color = dir * .5 + .5;\n    if (hit.t >= 0.0)\n    {\n        vec3 lightP = vec3(0, 2.+cos(iTime)/4., -3.0 + sin(iTime));\n        float lightI = 3.0;\n        vec3 hitP = origin + dir * hit.t;\n        vec3 lightDir = lightP - hitP;\n        \n        vec3 shadowDir = lightDir;\n        vec3 shadowOrigin = hitP + hit.normal * .005;\n        RayHit shadowHit = rayMarch(shadowOrigin, shadowDir);\n        \n        if (shadowHit.t <= 0.0 || shadowHit.t >= distance(shadowOrigin, lightP))\n        {\n            float lightDis = length(lightDir);\n            color = hit.albedo * max(dot(normalize(lightDir), hit.normal), 0.0);\n            color *= lightI / (lightDis * lightDis);\n            //color = hit.normal * .5 + .5;\n        }\n        else // shadowed\n        {\n            color = vec3(0.);\n        }\n        color += vec3(.05); // ambient lighting\n    }\n    else // sky hit\n    {\n        vec3 horizon = vec3(.4, .3, .4);\n        vec3 sky = vec3(.2, .5, .8);\n        color = mix(horizon, sky, smoothstep(0., .1, dir.y));\n    }\n\n    // tonemapping\n    color = aces_approx(color);\n    \n    // gamma correct output\n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}