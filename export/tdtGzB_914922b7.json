{"ver":"0.1","info":{"id":"tdtGzB","date":"1568814940","viewed":198,"name":"Happy Birthday Poulet Vert!","username":"Flopine","description":"A cute green chicken dancing for his birthday <3 Made for one of the most helpful and supportive friend I have in my research lab :) Kind of my mentor regarding my phD and the awesome artist behind my profile pic <3","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","chicken","party"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// JOYEUX ANNIVERSAIRE DOCTEUR SOHIER :D \n\n#define PI 3.141592\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat sphere (vec3 p, float r)\n{return length(p)-r;}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat body (vec3 p)\n{\n   p.xy *= rot(-PI/2.);\n   p.x -= sin(p.y*1.2);\n   return cyl(p.xzy,0.8+p.y*0.4,3.); \n}\n\nfloat eyes (vec3 p)\n{\n    p.z = abs(p.z)-.45;\n    p.xy += vec2(0.8,-0.9);\n    return sphere(p, 0.2);\n}\n\nfloat paws (vec3 p)\n{\n    p.z = abs(p.z)-0.5;\n    p.xy += vec2(-1.5,2.5);\n    float c1 = cyl(p.xzy, 0.1, 0.5);\n    p.xy += vec2(0.5,0.4);\n    float c2 = cyl(p.yzx, 0.05+p.x*0.2, .5);\n    return min(c2,c1);\n}\n\nfloat mohawk (vec3 p)\n{\n    p.xy += vec2(1.5,-1.5);\n    float d = 1e10;\n    float r = 0.5;\n    for (int i=0; i<3; i++)\n    {\n        r -= 0.1;\n        p.x -= 0.3;\n        d = min(d, sphere(p,r));\n    }\n    return d;\n}\n\nint mat;\nvec4 SDF (vec3 p)\n{\n    float anim = 2.*PI*(floor(iTime)+pow(fract(iTime),3.));\n    p.y -= clamp(cos(anim),0.,1.);\n    p.xz *= rot(anim/4.);\n    p.yz *= rot(anim/2.); \n    float m = mohawk(p);\n    float pa = paws(p);\n    float e = eyes(p);\n    float b = body(p);\n\n    float d = min(m,min(pa,min(e,b)));\n \n    if (d == m) mat = 1;\n    if (d == e) mat = 2;   \n    if (d == b) mat = 3;\n    if (d == pa) mat = 4;\n    \n    return vec4(d, p); \n}\n\nfloat background (vec2 uv)\n{\n    float r = 0.4 - abs(uv.x - uv.y)*0.1;\n    uv = fract(uv*5.)-0.5;\n    return smoothstep(r+0.03,r,length(uv));\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = palette(uv.x+uv.y, \n                       vec3(0.5),\n                       vec3(0.5),\n                      vec3(0.5),\n                      vec3(0.,0.3+iTime*0.5,0.7))\n        \t\t*background(uv)*0.6;\n    vec3 ro = vec3(0.001,0.001,-7.); vec3 p = ro;\n   \tvec3 rd = normalize(vec3(uv,1.));\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p).x;\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p+= d*rd*.8;\n    }\n    \n    if (hit)\n    {\n        if (mat == 4) col = vec3(0.5,0.3,0.);\n        if (mat == 3) col = vec3(-SDF(p).y,0.75,0.1);\n        if (mat == 2) col = vec3(step(length(SDF(p).yw),1.05));\n        if (mat == 1) col = vec3(0.9,0.,0.1);\n        col *= 1.-shad;\n    }\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}