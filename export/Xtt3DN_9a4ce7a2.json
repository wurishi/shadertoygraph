{"ver":"0.1","info":{"id":"Xtt3DN","date":"1469347576","viewed":255,"name":"The Inverse World","username":"soma_arc","description":"Inverse 3D kissing Schottky Orbit-spheres\nhttps://www.shadertoy.com/view/MtjXDh","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","kleiniangroup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\nvec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));\nvec3 rotate(vec3 p, float angle){\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,\n                ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,\n                ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);\n  return m * p;\n}\n\nconst vec3 SPHERE_POS1 = vec3(300, 300, 0);\nconst vec3 SPHERE_POS2 = vec3(300, -300, 0);\nconst vec3 SPHERE_POS3 = vec3(-300, 300, 0);\nconst vec3 SPHERE_POS4 = vec3(-300, -300, 0);\nconst vec3 SPHERE_POS5 = vec3(0, 0, 424.26);\nconst vec3 SPHERE_POS6 = vec3(0, 0, -424.26);\nconst float SPHERE_R = 300.;\nconst float SPHERE_R2 = SPHERE_R * SPHERE_R;\n\nvec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nfloat loopNum = 0.;\nfloat kleinSphereR = 125.;\n//float kleinSphereR = 300.;\n//float kleinSphereR = 400.;\nconst int MAX_KLEIN_ITARATION = 30;\nfloat distKlein(vec3 pos){\n  pos = rotate(pos, radians(iTime * 30.));\n  loopNum = 0.;\n  float dr = 1.;\n  bool loopEnd = true;\n  for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n    loopEnd = true;\n    if(distance(pos, SPHERE_POS1) < SPHERE_R){\n      vec3 diff = (pos - SPHERE_POS1);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS2) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS2);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS3) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS3);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS4) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS4);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS5) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS5);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS6) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS6);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }\n    if(loopEnd == true) break;\n  }\n  \n  float f = (length(pos) - 80. ) / abs(dr) * 0.08;\n  dr *= (300. * 300.) / dot(pos, pos);\n  pos = sphereInvert(pos, vec3(0), 300.);\n  return min(f,(length(pos) - kleinSphereR) / abs(dr) * 0.08);\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc(vec3 p){\n  return distKlein(p);\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                        distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                        distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.01);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  vec3 v = lightPos - p;\n  float dot = dot(n, normalize(v));\n  float r = length(v);\n  return (dot > 0.) ?\n    (lightPower * (dot / (PI_4 * r * r))) * diffuseColor\n    : LIGHTING_FACT * diffuseColor;\n}\n\nconst vec3 lightPos = vec3(150, -250, 400);\nconst vec3 lightPos2 = vec3(0., -300., 0);\nconst vec3 lightPower = vec3(400000.);\n\nconst int MAX_MARCHING_LOOP = 1000;\nvec2 march(const vec3 origin, const  vec3 ray, const float threshold){\n  vec3 rayPos = origin;\n  float dist;\n  float rayLength = 0.;\n  for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n    dist = distFunc(rayPos);\n    rayLength += dist;\n    rayPos = origin + ray * rayLength ;\n    if(dist < threshold) break;\n  }\n  return vec2(dist, rayLength);\n}\n\nconst vec3 BLACK = vec3(0);\nvec3 calcColor(vec3 eye, vec3 ray){\n  vec3 l = BLACK;\n  float coeff = 1.;\n  vec2 result = march(eye, ray, 0.03);\n  vec3 intersection = eye + ray * result.y;\n  vec3 matColor = vec3(0);\n  vec3 normal = getNormal(intersection);\n  if(result.x < 0.03){\n    matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));\n    l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    l += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower);\n  }\n  return l;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 eye = vec3(150 , -250., 400 );\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  const vec2 coordOffset = vec2(0.5);\n  vec3 ray = calcRay(eye, target, up, fov,\n                     iResolution.x, iResolution.y,\n                     gl_FragCoord.xy + coordOffset);\n\n  fragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n}","name":"Image","description":"","type":"image"}]}