{"ver":"0.1","info":{"id":"Wsf3z2","date":"1546822799","viewed":666,"name":"First Gen Pokeballs","username":"bitnenfer","description":"I've added all  the first gen pokeballs. To view them you can just use the mouse Y coordinate to scroll through them.\nIt has Poke Ball, Safari Ball, Great Ball, Ultra Ball and Master Ball.","likes":23,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","pokeball","pbr","pokemon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/morenoise\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n//https://iquilezles.org/articles/morenoise\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n    float f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n    float f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values      \n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n    return vec4( a, d );\n}\n\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Hit\n{\n    float dist;\n    Material material;\n};\n\nstruct DirLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\n#define EPSILON 0.001\n#define MAX_DIST 10.0\n#define MIN_DIST EPSILON\n#define PI 3.14159265359\n\nmat2 rot(float r) { \n    return mat2(\n        cos(r), sin(r),\n        -sin(r), cos(r)\n    );\n}\n\nfloat sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdfBox(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat pokeBallTop(vec3 p)\n{\n    float s = sdfSphere(p, 0.5);\n    float b = sdfBox(p + vec3(0.0, 0.47, 0.0), vec3(0.6, 0.5, 0.6));\n    return max(s, -b);\n}\n\nfloat pokeBallBottom(vec3 p)\n{\n    float s = sdfSphere(p, 0.5);\n    float b = sdfBox(p + vec3(0.0, -0.47, 0.0), vec3(0.6, 0.5, 0.6));\n    return max(s, -b);\n}\n\nfloat pokeBallButtonCutout(vec3 p)\n{\n    p.z += 0.5;\n    p.yz *= rot(3.14/2.0);\n    float cy = sdCappedCylinder(p, vec2(0.13));\n    return cy;\n}\n\nfloat btnDist = 0.0;\nfloat pokeBallButton(vec3 p)\n{\n    vec3 p0 = p;\n    p0.z += 0.47;\n    p0.yz *= rot(3.14/2.0);\n    float cy0 = sdCappedCylinder(p0, vec2(0.1, 0.01));\n\n    vec3 p1 = p;\n    p1.z += 0.49;\n    p1.yz *= rot(3.14/2.0);\n    float cy1 = sdCappedCylinder(p1, vec2(0.06, 0.01));\n    \n    float c = sdfSphere(p + vec3(0.0, 0.0, 0.585), 0.1);\n    \n    float d = min(cy0, max(cy1, -c));\n    btnDist = 0.01 / (d * d);\n    return d;\n}\n\n\nMaterial mixMaterial(Material a, Material b, float s)\n{\n    return Material(\n        mix(a.albedo, b.albedo, s),\n        mix(a.roughness, b.roughness, s),\n        mix(a.metallic, b.metallic, s)\n    );\n}\n\nHit minHit(Hit a, Hit b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nHit interHit(Hit a, Hit b)\n{\n    if (a.dist > b.dist) return a;\n    return b;\n}\n\nfloat noise = 0.0;\nfloat noise2 = 0.0;\nfloat noise3 = 0.0;\nfloat noise4 = 0.0;\nfloat ballRot = 0.0;\nfloat ballOffset = 0.0;\nfloat wave = 0.0;\n\nHit pokeBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    float noiseDist = 1.0 - clamp((p.y * 2.8), 0.0, 1.0);\n    float noiseDist2 = 1.0 - clamp(((1.0 - normalize(p).y) * 0.6), 0.0, 1.0);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(1.0, 0.01, 0.01), 0.6, 0.7), \n        Material(vec3(0.7, 0.8, 1.0), 0.0, 1.0),\n        noiseDist * clamp(1.0 - pow(noise-0.01, 2.5), 0.0, 1.0)\n    ));\n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.0),\n        Material(vec3(0.0), 0.1, 1.0),\n        pow((1.0 - noise3) * pow(noiseDist2, 1.5), 1.0 - noiseDist2)\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.6, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise3\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(15.0, 1.0, 1.0) * 0.5 + abs(wave), 0.1, 0.1));\n    \n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nHit safariBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    float noiseDist2 = 1.0 - clamp(((1.0 - normalize(p).y) * 0.6), 0.0, 1.0);\n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        mixMaterial(\n            Material(vec3(0.2, 1.9, 0.2), 0.6, 0.7), \n            Material(vec3(0.0, 0.1, 0.0), 0.6, 0.7),\n            noise4\n        ),\n        Material(vec3(0.2, 0.2, 0.0), 0.6, 0.7),\n        pow(noise2, 10.0) * .5\n    ));\n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.0),\n        Material(vec3(0.0), 0.1, 1.0),\n        pow((1.0 - noise3) * pow(noiseDist2, 1.5), 1.0 - noiseDist2)\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(1.0), 0.1, 0.1));\n\n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nHit ultraBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    float noiseDist = 1.0 - clamp((p.y * 2.5), 0.0, 1.0);\n    float topI = sdfBox(p + vec3(0.25, -0.53, 0.0), vec3(0.1, 0.5, 0.5));\n    \n    topI = min(topI, sdfBox(p + vec3(-0.25, -0.53, 0.0), vec3(0.1, 0.5, 0.5)));\n    topI = min(topI, sdfBox(p + vec3(0.0, -0.53, 0.0), vec3(0.2, 0.5, 0.15)));\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(0.0, 0.0, 0.0), 1.0, 1.), \n        Material(vec3(1.0), 0.1, 1.0),\n        pow(1.0 - noise, 4.0) * noiseDist\n    ));\n    \n    Hit topIHit = Hit(topI, mixMaterial(\n        Material(vec3(1.0, 1.0, 0.0), 0.1, 0.0),\n        topHit.material,\n        pow(noise2, 40.5)\n    ));\n    \n    Hit topHitI = interHit(topHit, topIHit);\n    topHitI.material = topIHit.material;\n    \n    topHit = minHit(topHit, topHitI);\n    \n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.9, 0.1),\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.1),\n        1.0 - noise2\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(1.0), 0.1, 0.1));\n\n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\n//btnDist = 0.01 / (d * d);\nfloat gbRustContrib = 0.0;\nHit greatBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    \n    vec3 p1 = p; \n    vec3 p2 = p; \n    p1.xy *= rot(3.14 / 6.5);\n    p2.xy *= rot(-3.14 / 6.5);\n    \n    float topI = length(vec3(p1.x * 3.0, p1.y * 1.7, p1.z * 1.1) + vec3(0.25, -0.4, 0.0)) - 0.5;\n    \n    topI = min(topI, length(vec3(p2.x * 3.0, p2.y * 1.7, p2.z * 1.1) + vec3(-0.25, -0.4, 0.0)) - 0.5);\n    \n    gbRustContrib = 0.01 / (topI * 0.5);\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(0.001, 0.001, 2.2), 0.6, 0.7), \n        Material(vec3(1.0), 0.1, 1.0),\n        1.0 - (noise2 * pow(noise, 0.1))\n    ));\n    \n    Hit topIHit = Hit(topI, \n        Material(vec3(1.0, 0.0, 0.0), 0.2, 0.8));\n        \n    topHit = minHit(topHit, topIHit);\n    \n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.0),\n        Material(vec3(0.7, 0.8, 1.0), 0.9, 0.0),\n        1.0 - noise2\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(1.0), 0.1, 0.1));\n    \n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nfloat mbRustContrib0 = 0.0;\nHit masterBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    float noiseDist2 = 1.0 - clamp(((1.0 - normalize(p).y) * 0.6), 0.0, 1.0);\n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    p1.xy *= rot(3.14 / 4.0);\n    float topI = length(vec3(p1.x, p1.y * 1.6, p1.z ) + vec3(0.0, -0.6, 0.05)) - 0.28;\n    p2.xy *= rot(-3.14 / 4.0);\n    \n    topI = min(topI, length(vec3(p2.x, p2.y * 1.6, p2.z ) + vec3(0.0, -0.6, 0.05)) - 0.28);\n    \n    mbRustContrib0 = 0.01 / (topI * 0.5);\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(0.1, 0.2, 1.0), 0.1, 1.0), \n        Material(vec3(0.5, 0.0, 1.0), 0.9, 0.0),\n        pow(clamp((pow(noise2, 0.05) * pow(noise, 0.3)), 0.0, 1.0), 20.5)\n    ));\n    \n    Hit topIHit = Hit(topI, Material(vec3(1.3, 0.1, 0.5), 0.1 + noise4 * 0.3, 0.9));\n    \n    topHit = minHit(topHit, topIHit);\n    \n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.6, 0.0),\n        Material(vec3(0.0, 0.0, 0.0), 0.1, 1.0),\n        pow((noise3) * pow(noiseDist2, 1.5), 1.0 - noiseDist2)\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(15.0, 1.0, 1.0) * 0.5 + abs(wave), 0.1, 0.1));\n    \n    vec3 P = p + vec3(0.0, -0.15, 0.3);\n    P *= 1.5;\n    vec3 P0 = vec3(P.x * 2.0, P.y, P.z) + vec3(0.31, 0.0, 0.0);\n    vec3 P1 = vec3(P.x * 2.0, P.y, P.z) - vec3(0.31, 0.0, 0.0);\n    vec3 mP0 = P0;\n    vec3 mP1 = P0 + vec3(-.205, -0.18, 0.0);\n    vec3 mP2 = P1;\n    vec3 mP3 = P1  + vec3(.205, -0.18, 0.0);\n    \n    mP0.yx *= rot(PI /7.0);\n    mP1.yx *= rot(-PI / 3.);\n\n    mP2.yx *= rot(-PI /7.0);\n    mP3.yx *= rot(PI / 3.);\n\n    float M = sdfBox(mP0, vec3(0.05, 0.3, 0.4));\n    M = min(M, sdfBox(mP1, vec3(0.05, 0.15, 0.4)));\n    \n    M = min(M, sdfBox(mP2, vec3(0.05, 0.3, 0.4)));\n    M = min(M, sdfBox(mP3, vec3(0.05, 0.15, 0.4)));\n    \n    M = max(M, -sdfBox(P + vec3(0.0, 0.25, 0.0), vec3(0.5, 0.25, 0.5)));\n    \n    Hit hitM = Hit(M, Material(vec3(1.0), 0.1, 0.2));\n    \n    Hit BM = interHit(hitM, topHit);\n    \n    BM.material = hitM.material;\n    \n    topHit = minHit(topHit, BM);\n    \n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nfloat ballID = .0;\nHit scene(vec3 p)\n{\n    Hit scene = Hit(p.y + 0.5, Material(vec3(0.0), 0.9, 0.0));\n    \n    p.x += ballOffset;\n    p.zx *= rot(0.4);\n    p.xy *= rot(ballRot);\n    \n    if (ballID == 1.0)\n        scene = minHit(scene, greatBall(p));\n    else if (ballID == 2.0)\n        scene = minHit(scene, safariBall(p));\n    else if (ballID == 3.0)\n        scene = minHit(scene, ultraBall(p));\n    else if (ballID == 4.0)\n        scene = minHit(scene, masterBall(p));\n    else\n        scene = minHit(scene, pokeBall(p));\n   \n    \n    return scene;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(scene(p).dist - vec3(\n        scene(p - e.yxx).dist,\n        scene(p - e.xyx).dist,\n        scene(p - e.xxy).dist\n    ));\n}\n\nHit raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 200; ++i)\n    {\n        vec3 p = ro + rd * t;\n        Hit d = scene(p);\n        if (d.dist < EPSILON)\n        {\n            vec3 cp = p;\n            cp.x += ballOffset;\n            cp.zx *=rot(0.4);\n            cp.xy *= rot(ballRot);\n            noise3 = clamp(length(fbmd(vec3(cp.x * 4.0, cp.y, cp.z * 4.0) * 0.5)), 0.0, 1.0);\n            float noiseDist = clamp((cp.y * 15.5 * noise3), 0.0, 1.0);\n            noise = noiseDist * noise3;\n            noise2 = clamp(length(fbmd(cp) * 1.2), 0.0, 1.0);\n            if (ballID == 1.0)\n            {\n                noise2 = clamp(1.0 - (noise2 * gbRustContrib * 0.5), 0.5, 1.0) * noise2;\n            }\n            else if (ballID == 2.0)\n            {\n                noise4 = clamp(length(fbmd(cp * 0.8)), 0.0, 1.0);\n                noise2 = clamp(length(noise2 * fbmd(cp)), 0.0, 1.0);\n            }\n            else if (ballID == 4.0)\n            {\n                noise4 = clamp(pow(length(fbmd(cp) * 0.9), 30.0), 0.0, 1.0);\n                noise2 = clamp(1.0 - (noise2 * mbRustContrib0 * 1.), 0.4, 1.0);\n            }\n            d = scene(p);\n            return Hit(t, d.material);\n        }\n        t += d.dist * .7;\n        if (t > MAX_DIST) break;\n    }\n    return Hit(MAX_DIST, Material(vec3(0.0), 0.0, 0.0));\n}\n\nfloat NormalDistributionFunction_GGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = PI * (denom * denom);\n    return a2 / denom;\n}\n\nfloat Geometry_GGX(vec3 n, vec3 v, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    float NdotV = max(0.0, dot(n, v));\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat Geometry_Smith(vec3 n, vec3 v, vec3 l, float a)\n{\n    float g1 = Geometry_GGX(n, l, a);\n    float g2 = Geometry_GGX(n, v, a);\n    return g1 * g2;\n}\n\nvec3 Fresnel_Schlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 PBR(vec3 n, vec3 v, DirLight l, in Material material)\n{\n    vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n    vec3 h = normalize(v + l.dir);\n    float roughness = material.roughness * material.roughness;\n    float D = NormalDistributionFunction_GGXTR(n, h, roughness);\n    vec3 F = Fresnel_Schlick(v, h, F0);\n    float G = Geometry_Smith(n, v, l.dir, roughness);\n    float NdotL = max(0.0, dot(n, l.dir));\n    float NdotV = max(0.0, dot(n, v));\n    vec3 Kd = (1.0 - F) * (1.0 - material.metallic);\n    vec3 radiance = l.color;\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, EPSILON);\n    \n    return (material.albedo * 0.03) + ((Kd * material.albedo / PI + specularBRDF) * radiance * NdotL);\n}\n\nfloat opShadow(in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    Material material;\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = scene( ro + rd * t).dist;\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.002, 0.010 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat opAO(in vec3 p, in vec3 n)\n{\n    float value = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 3; ++i)\n    {\n        float stepSize = 0.05;\n        float dist = scene(p + n * stepSize).dist;\n        value += (stepSize - dist) * s;\n        s *=0.8;\n    }\n    value = value;\n    return clamp(sqrt((0.8 - value) * sqrt(1.0)), -1.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    wave = sin(iTime * 3.0);\n    ballRot = 0.3 + sin(iTime * 10.0 + sin(iTime * 2.1) * PI) * 0.2;\n    ballOffset = ballRot * 0.3;\n    DirLight lights[3];\n\n    lights[0] = DirLight(normalize(vec3(0.3, 0.4, -0.6)), vec3(2.0, 2.0, 3.4));\n    lights[1] = DirLight(normalize(vec3(-0.9, 0.2, -0.6)), vec3(2.9, 2.6, 2.0));\n    lights[2] = DirLight(normalize(vec3(0.9, 0.6, -0.6)), vec3(0.3, 4.6, 2.0));\n\n    vec3 color = vec3(1.0);\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * ar;\n    vec3 ro = vec3(EPSILON, EPSILON, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float mx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14;\n    float my = -(iMouse.y / iResolution.y * 2.0 - 1.0) * 3.14;\n    \n    ballID = floor((iMouse.y / iResolution.y) * 5.0);\n\n    if (iMouse.z <= 0.0)\n    {\n        //ro.xz *= rot(iTime * 0.5);\n        //rd.xz *= rot(iTime * 0.5);\n    }\n    else\n    {\n        ro.xz *= rot(mx);\n        rd.xz *= rot(mx);\n    }\n\n    Hit hit = raymarch(ro, rd);\n\n    if (hit.dist < MAX_DIST)\n    {\n        vec3 p = ro + rd * hit.dist;\n        vec3 n = norm(p);\n        vec3 v = normalize(-rd);\n        color = vec3(0.01, 0.01, 0.02);\n\n        for (int i = 0; i < 3; ++i)\n        {\n            color += PBR(n, v, lights[i], hit.material);\n\n            vec3 d = lights[i].dir;\n            vec3 o = p + d * 0.1;\n\n            color *= 0.5 + opShadow(o, d, 0.0, 10.5) * 0.5;\n\n        }\n\n        color *= pow(opAO(p, n), 5.0);\n\n    }\n    \n    color = mix(color, vec3(0.01, 0.01, 0.02), clamp(pow(hit.dist / 10.0, 2.3), 0.0, 1.0));\n\n    color += vec3(0.4, 0.01,0.01) * btnDist * abs(wave);\n    \n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}