{"ver":"0.1","info":{"id":"WdG3R3","date":"1573155912","viewed":80,"name":"Torsion_pendulum_clock_detailed","username":"Caramoule","description":"A torsion pendulum clock made only of primitives and displayed with ray tracing.\n\nUncomment the line 514 and comment the line 513 to call a simplified version of the object with pendulums and clock hands animation. Or check my other Shadertoy clock.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","clock","implicit","surface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs - Base code by Eric Galin\n// Etienne LUQUIN\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.0;\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R)\n{\n  float u = clamp(x/R,0.0,1.0);\n  float v = (1.0-u*u);\n  return v*v*v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Segment Skeleton\n// p : point origine\n// a : point a\n// b : point b\n// e : energy associated to skeleton\n// R : radius thickness\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    vec3 u = normalize(b - a);\n    float distFinal = 0.0;\n    \n    if (dot(u, (p - a)) < 0.0)\n    {\n        distFinal = distance(p, a);\n    }\n    else if (dot(u, (p - b)) > 0.0)\n    {\n        distFinal = distance(p, b); \n    }\n    else\n    {\n        float distPA = distance(p, a);\n        float L = dot((p - a), u);\n        distFinal = sqrt( (distPA * distPA) - (L * L) );\n    }\n    return e * falloff(distFinal, R);\n}\n\n// Disk Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat disk(vec3 p, vec3 c, vec3 dir, float ray, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n                  \n    if(L < ray)\n    {\n      distFinal = abs(HP);   \n    }\n    else\n    {\n      distFinal = sqrt( ((L - ray) * (L - ray)) + (HP * HP) );\n    }\n    \n    return e * falloff(distFinal, R);\n}\n\n// Tore Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat tore(vec3 p, vec3 c, vec3 dir, float ray, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n                  \n    distFinal = sqrt( ((L - ray) * (L - ray)) + (HP * HP) ); \n    \n    return e * falloff(distFinal, R);\n}\n\n// Cylinder Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// h : float height of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat cylinder(vec3 p, vec3 c, vec3 dir, float ray, float h, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n    float hMax = max(0.0, abs(HP) - h);           \n    \n    if(L < ray)\n    {\n      distFinal = hMax;\n    }\n    else\n    {\n      distFinal = sqrt( (L - ray) * (L - ray) + hMax * hMax );\n    }\n     return e * falloff(distFinal, R);\n}\n\n// Sphere Skeleton\n// p : point origine\n// c : point center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat sphere(vec3 p, vec3 c, float ray, float e, float R)\n{\n  return e * falloff(max(0.0, distance(p, c) - ray), R);\n}\n\n// Bubble Skeleton\n// p : point origine\n// c : point center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat bubble(vec3 p, vec3 c, float ray, float e, float R)\n{\n  float distFinal = 0.0;\n  float distCP = distance(p, c);\n    \n  if(distCP < ray)\n  {\n  \tdistFinal = ray;  \n  }\n  else\n  {\n    distFinal = distCP - ray;\n  }\n  return e * falloff(distFinal, R);\n}\n\n// Box Skeleton\n// p : point origine\n// a : point corner of skeleton\n// dir : orientation of the skeleton not implemented yet\n// h : float height\n// w : float width\n// d : float depth\n// e : energy associated to skeleton\n// R : radius thickness\nfloat box(vec3 p, vec3 a, vec3 dir, float w, float h, float d, float e, float R)\n{\n  // ne prend pas enore en compte l'orientation et les valeurs negatives\n  vec3 u = normalize(dir);\n  float distFinal = 0.0;\n\n  float maxAx = a.x + w;\n  float maxAy = a.y + h;\n  float maxAz = a.z + d;    \n    \n  if(p.x < a.x)\n    distFinal += (a.x - p.x) * (a.x - p.x);\n  else if(p.x > maxAx)\n    distFinal += (maxAx - p.x) * (maxAx - p.x);\n      \n  if(p.y < a.y)\n    distFinal += (a.y - p.y) * (a.y - p.y);\n  else if(p.y > maxAy)\n    distFinal += (maxAy - p.y) * (maxAy - p.y);\n      \n  if(p.z < a.z)\n    distFinal += (a.z - p.z) * (a.z - p.z);\n  else if(p.z > maxAz)\n    distFinal += (maxAz - p.z) * (maxAz - p.z);\n    \n  return e * falloff(distFinal, R);\n}\n\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Difference\n// a,b : field function of the sub-trees\nfloat Diff(float a,float b)\n{\n    return min(a, 2.0 * T - b);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n   return min(a,b);\n}\n\n\n// Complex objects creation\n\n// Modelisation de la base horloge\nfloat Base(vec3 p, bool simplified)\n{\n  float baseCy1 = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 12.0, 0.5, 1.0, 2.0);\n  float baseDi1 = disk(p, vec3(0.0, 1.5, 0.0), vec3(0.0, 1.0, 0.0), 11.0, 1.0, 1.5);\n  float base = Blend(baseCy1, baseDi1);\n      \n  float baseDi2 = disk(p, vec3(0.0, 2.5, 0.0), vec3(0.0, 1.0, 0.0), 10.0, 1.0, 1.5);\n  base = Blend(base, baseDi2);\n    \n  float basePillar3 = cylinder(p, vec3(-3.0, 5.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 2.5, 1.0, 1.0); \n  base = Blend(base, basePillar3);\n   \n  if(!simplified)\n  {\n \t  float basePillar1 = disk(p, vec3(3.0, 3.1, 5.5), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 0.3);\n \t  base = Blend(base, basePillar1);\n      \n      float basePillar2 = disk(p, vec3(3.0, 3.1, -5.5), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 0.3);\n      base = Blend(base, basePillar2);\n\n      float holeTo1 = tore(p, vec3(0.0, 3.0, 0.0), vec3(0.0, 1.0, 0.0), 9.0, 1.0, 0.5);\n      base = Diff(base, holeTo1);\n\n      float holeCy1 = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 10.0, 1.0, 1.0, 1.0);\n      base = Diff(base, holeCy1);\n  }\n  \n  return base;\n}\n\n// Modelisation du mechanisme derriere le cadran\nfloat Battery(vec3 p, bool simplified)\n{\n  float pillarCy1 = cylinder(p, vec3(3.0, 8.0, 5.5), vec3(0.0, 1.0, 0.0), 0.3, 6.0, 1.0, 1.0);\n  float pillarCy2 = cylinder(p, vec3(3.0, 8.0, -5.5), vec3(0.0, 1.0, 0.0), 0.3, 6.0, 1.0, 1.0);\n  float battery = Union(pillarCy1, pillarCy2);  \n        \n  float batteryBox1 = box(p, vec3(-3.0, 14.0, -6.2), vec3(0.0, 1.0, 0.0), 7.0, 0.5, 12.4, 1.0, 0.2);\n  battery = Union(battery, batteryBox1);\n    \n  float batteryBox2 = box(p, vec3(-3.0, 14.5, -3.5), vec3(0.0, 1.0, 0.0), 5.2, 7.0, 7.0, 1.0, 0.2);\n  battery = Blend(battery, batteryBox2);\n    \n  float pillarCy3 = cylinder(p, vec3(-3.0, 17.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 5.0, 1.0, 1.0); \n  battery = Blend(battery, pillarCy3);\n    \n  if(!simplified)\n  {\n      float holeBox3 = box(rotateY(p, 10.0), vec3(-5.0, 13.0, -8.2), vec3(0.0, 1.0, 0.0), 6.0, 2.0, 3.0, 1.0, 0.1);\n  \t  battery = Diff(battery, holeBox3);\n      \n      float holeBox4 = box(rotateY(p, -10.0), vec3(-5.0, 13.0, 5.2), vec3(0.0, 1.0, 0.0), 6.0, 2.0, 3.0, 1.0, 0.1);\n  \t  battery = Diff(battery, holeBox4);\n  }\n    \n  float holeBox1 = box(p, vec3(3.0, 13.0, -4.0), vec3(0.0, 1.0, 0.0), 8.0, 2.0, 8.0, 1.0, 0.2);\n  battery = Diff(battery, holeBox1);\n    \n  return battery;\n}\n\n// Modelisation du cadran \t\nfloat Dial(vec3 p, bool simplified)\n{\t\n  float dial = disk(p, vec3(3.0, 18.0, 0.0), vec3(1.0, 0.0, 0.0), 5.0, 1.0, 1.5);\n  float holeCy1 = cylinder(p, vec3(4.7, 18.0, 0.0), vec3(1.0, 0.0, 0.0), 4.3, 1.0, 1.0, 1.0);\n  dial = Diff(dial, holeCy1);\n  \n  float midSeg1 = segment(p, vec3(3.0, 18.0, 0.0), vec3(3.7, 18.0, 0.0), 1.0, 0.5);\n  dial = Union(dial, midSeg1);\n    \n  if(!simplified)\n  {\n      float twelve = segment(p, vec3(3.2, 21.5, 0.6), vec3(3.2, 22.0, 0.6), 1.0, 0.3);\n      twelve = Union(twelve, segment(p, vec3(3.2, 21.5, 0.2), vec3(3.2, 22.0, 0.2), 1.0, 0.3));\n      twelve = Union(twelve, segment(p, vec3(3.2, 21.5, -0.3), vec3(3.2, 22.0, -0.7), 1.0, 0.3));\n      twelve = Union(twelve, segment(p, vec3(3.2, 22.0, -0.3), vec3(3.2, 21.5, -0.7), 1.0, 0.3));\n      dial = Union(dial, twelve);\n\n      float three = segment(p, vec3(3.2, 17.75, 3.5), vec3(3.2, 18.25, 3.5), 1.0, 0.3);\n      three = Union(three, segment(p, vec3(3.2, 17.75, 3.9), vec3(3.2, 18.25, 3.9), 1.0, 0.3));\n      three = Union(three, segment(p, vec3(3.2, 17.75, 4.3), vec3(3.2, 18.25, 4.3), 1.0, 0.3));\n      dial = Union(dial, three);\n\n      float six = segment(p, vec3(3.2, 14.5, -0.7), vec3(3.2, 14.0, -0.4), 1.0, 0.3);\n      six = Union(six, segment(p, vec3(3.2, 14.0, -0.4), vec3(3.2, 14.5, -0.1), 1.0, 0.3));\n      six = Union(six, segment(p, vec3(3.2, 14.5, 0.3), vec3(3.2, 14.0, 0.3), 1.0, 0.3));\n      dial = Union(dial, six);\n\n      float nine = segment(p, vec3(3.2, 17.75, -3.9), vec3(3.2, 18.25, -3.5), 1.0, 0.3);\n      nine = Union(nine, segment(p, vec3(3.2, 17.75, -3.5), vec3(3.2, 18.25, -3.9), 1.0, 0.3));\n      nine = Union(nine, segment(p, vec3(3.2, 17.75, -4.3), vec3(3.2, 18.25, -4.3), 1.0, 0.3));\n      dial = Union(dial, nine);\n  }   \n    \n  return dial;\n}\n\n// Modelisation de l'engrenage qui tourne\nfloat Clockwork(vec3 p, float t, bool simplified)\n{\n  float clockwork = cylinder(p, vec3(-3.0, 10.0, 0.0), vec3(0.0, 1.0, 0.0), 0.2, 3.0, 1.0, 1.0); \n  \n  if(!simplified)\n  {\n      float t1 = t + M_PI/2.0;\n      float t2 = t + M_PI;\n      float t3 = t + (3.0 * M_PI)/2.0;\n\n      float holeSeg1 = segment(p, vec3(cos(t) - 3.0, 12.0, -sin(t)), \n                                    vec3(cos(t1) - 3.0, 8.0, -sin(t1)), 1.0, 1.4); \n      clockwork = Diff(clockwork, holeSeg1);\n\n      float holeSeg2 = segment(p, vec3(cos(t2) - 3.0, 12.0, -sin(t2)), \n                                    vec3(cos(t3) - 3.0, 8.0, -sin(t3)), 1.0, 1.4); \n      clockwork = Diff(clockwork, holeSeg2);\n  }\n    \n  return clockwork;\n}\n\n// Modelisation des aiguilles qui tournent\nfloat HandMoving(vec3 p, float t)\n{\n  float t1 = t / 12.0;\n  \n  float hands = segment(p, vec3(3.4, 18.0, 0.0), \n                        vec3(3.4, cos(t) * 3.0 + 18.0,  sin(t) * 3.0),\n                        1.0, 0.2);\n  hands = Union(hands, segment(p, vec3(3.7, 18.0, 0.0), \n                        vec3(3.8, cos(t1) * 2.0 + 18.0,  sin(t1) * 2.0),\n                        1.0, 0.2));\n  return hands;\n}\n\n// Modelisation des pendules qui tournent\nfloat PendulumMoving(vec3 p, float t)\n{\n  float t1 = t + M_PI/2.0;\n  float t2 = t + M_PI;\n  float t3 = t + (3.0 * M_PI)/2.0;\n    \n  float ball1 = sphere(p, vec3(cos(t) * 3.0 - 3.0, 6.0, sin(t) * 3.0), 1.2, 1.0, 1.0);\n  float ball2 = sphere(p, vec3(cos(t1) * 3.0 - 3.0, 6.0, sin(t1) * 3.0), 1.2, 1.0, 1.0);\n  float pendulums = Union(ball1, ball2);\n    \n  float ball3 = sphere(p, vec3(cos(t2) * 3.0 - 3.0, 6.0, sin(t2) * 3.0), 1.2, 1.0, 1.0);\n  pendulums = Union(pendulums, ball3);\n    \n  float ball4 = sphere(p, vec3(cos(t3) * 3.0 - 3.0, 6.0, sin(t3) * 3.0), 1.2, 1.0, 1.0);\n  pendulums = Union(pendulums, ball4);\n    \n  float attachSeg1 = segment(p, vec3(cos(t) * 3.0 - 3.0, 6.0, sin(t) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg1);\n    \n  float attachSeg2 = segment(p, vec3(cos(t1) * 3.0 - 3.0, 6.0, sin(t1) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg2);\n    \n  float attachSeg3 = segment(p, vec3(cos(t2) * 3.0 - 3.0, 6.0, sin(t2) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg3);\n    \n  float attachSeg4 = segment(p, vec3(cos(t3) * 3.0 - 3.0, 6.0, sin(t3) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3);  \n  pendulums = Blend(pendulums, attachSeg4);\n    \n  return pendulums;\n}\n \nfloat Object_complex(vec3 p)\n{\n  float t = iTime;\n    \n  // base horloge\n  float base = Base(p, false);\n    \n  // arriere du cadran\n  float battery = Battery(p, false);\n  float finalObj = Union(base, battery);\n\n  // cadran\n  float dial = Dial(p, false);\n  finalObj = Union(finalObj, dial);\n \n  // engrenage\n  float clockwork = Clockwork(p, t, false);\n  finalObj = Union(finalObj, clockwork);\n    \n  // aiguilles\n  float hands = HandMoving(p, t);\n  finalObj = Union(finalObj, hands);\n   \n  // pendules\n  float pendulums = PendulumMoving(p, t);\n  finalObj = Blend(finalObj, pendulums);\n    \n  return finalObj;  \n}\n\nfloat Object_simplified(vec3 p)\n{\n  float t = iTime;  \n  \n  // base horloge\n  float base = Base(p, true);\n    \n  // arriere du cadran\n  float battery = Battery(p, true);\n  float finalObj = Union(base, battery);\n\n  // cadran\n  float dial = Dial(p, true);\n  finalObj = Union(finalObj, dial);\n \n  // mecanisme\n  float clockwork = Clockwork(p, t, true);\n  finalObj = Union(finalObj, clockwork);\n    \n  // aiguilles\n  float hands = HandMoving(p, t);\n  finalObj = Union(finalObj, hands);\n   \n  // pendules\n  float pendulums = PendulumMoving(p, t);\n  finalObj = Blend(finalObj, pendulums);\n    \n  return finalObj;\n}\n    \n// Potential field of the object\n// p : point\nfloat Object(vec3 p)\n{\n  p.z=-p.z;\n    \n  // utilisation de mes fonctions\n  //float v = segment(p, vec3(0.0, 0.0, 0.0), vec3(3.0, 0.0, 3.0), 1.0, 4.0);\n  //float v = disk(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 1.0, 1.0);\n  //float v = tore(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 1.0, 1.0);\n  //float v = sphere(p, vec3(0.0, 0.0, 0.0), 3.0, 1.0, 1.0);\n  //float v = bubble(p, vec3(0.0, 0.0, 0.0), 3.0, 1.0, 1.0);\n  //float v = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 5.0, 1.0, 1.0);\n  //float v = box(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 5.0, 4.0, 1.0, 1.0);\n    \n  float finalObj = Object_complex(p);\n  //float finalObj = Object_simplified(p);\n\n  return finalObj - T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = Object(p);\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  return mix(vec3(0.4, 0.3, 0.75), vec3(0.75, 0.85, 1.0), d.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*Background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  //vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n  vec3 ro = vec3(0.0, 10.0, 30);\n  \n  // position camera base\n  ro = rotateY(ro, 90.0);\n  rd = rotateY(rd, 90.0);\n  ro = rotateZ(ro, -0.2);\n  rd = rotateZ(rd, -0.2);\n  \n  vec2 mouse = iMouse.xy / iResolution.xy;\n  ro = rotateY(ro, -mouse.x * 5.0);\n  rd = rotateY(rd, -mouse.x * 5.0);\n  ro = rotateZ(ro, -mouse.y * 5.0);\n  rd = rotateZ(rd, -mouse.y * 5.0);\n   \n    \n  //float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n    \n    \n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = Background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}