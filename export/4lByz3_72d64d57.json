{"ver":"0.1","info":{"id":"4lByz3","date":"1509412614","viewed":78,"name":"Mandelbrot - Tarea 1","username":"Benrod","description":"Tarea 1.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265358979323846264;\nconst float threshold = 200000.0;\nconst float color_scale = 2.0;\nconst int max_colors = 50;\nconst float inverse_max_colors = 1.0 / float(max_colors);\n\n#define cx_mul(a) vec2(a.x*a.x-a.y*a.y, a.x*a.y + a.y*a.x)\n\nvec4 color_ramp(int i) {\n    // Running the index through cos creates a continous ramp.\n    float normalized_mod = mod(float(i), float(max_colors)) * inverse_max_colors;\n\tfloat normalized_cos = (cos(normalized_mod * 2.0 * PI) + 1.0) * 0.5;\n    i = int(float(max_colors) * normalized_cos);\n\n    float factor = float(i) / float(max_colors);\n    float inverse_factor = 1.0 - factor;\n    // An arbritrary ramp of colors\n    return vec4(sqrt(sqrt(factor)), factor, inverse_factor * 0.5, 1.0);\n}\n\nvec4 color_from_ramp(int i, float f) {\n\tvec4 first = color_ramp(i);\n\tvec4 second = color_ramp(i + 1);\n    return first * (1.0 - f) + second * f;\n}\n\nvec4 color_from_iteration(vec2 z, int i) {\n    // Continuous coloring\n    float s = float(i) + log2(log(threshold)) - log2(log(length(z)));\n    s *= color_scale;\n    int first = int(floor(s));\n    return color_from_ramp(first, s - float(first));\n}\n\n\nvoid mainImage( out vec4 f, in vec2 pixel_xy )\n{\n    float n = 0.;\n    \n    // Lugar de acercamiento de la vista\n    vec2 focus = vec2(-.745, .186);\n    vec2 c = focus + 3. * (pixel_xy / iResolution.y - .5) * pow(.01, 1. + cos(.2 * iTime)), \n         z = c * n;\n    int iteraciones_de_borde = 128;\n    \n    int final_i;\n    for (int i = 0; i < iteraciones_de_borde; i++) {\n        final_i = i;\n\n        if (length(z) >= threshold) {\n            break;\n        }\n\n        // z^P + c, P = 2  gives us  z^2 + c\n        z = cx_mul(z) + c;\n    }\n    // Generacion de la representaci√≥n de Mandelbrot en la dimension de colores RGBA\n    f = color_from_iteration(z, final_i);\n}","name":"Image","description":"","type":"image"}]}