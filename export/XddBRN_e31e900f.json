{"ver":"0.1","info":{"id":"XddBRN","date":"1524506178","viewed":221,"name":"MyPlane","username":"jpechevarria","description":"Projection of a plane.\nCamera Rotation.\nIntersection line vs Sphere, and lighting.\nReflection.\nCube Mapping.\nAnti Aliasing\nCamera positioning","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractal","reflection","antialiasing","cubemapping","geometry","3dprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159;\n\n// PARAMENTROS\nconst float ANTIALIASING_LEVEL = 4.0;\n\n// DEFINICION DEL PLANO    \nconst vec3 P = vec3 ( 0.0, -10.0, 20.0 );\nconst vec3 N = vec3 ( 0.0, 1.0, 0.0 );\nconst vec3 PX = vec3(1.0,0.0,0.0);\nconst vec3 PY = vec3(0.0,0.0,1.0);\n\nvec4 planeColor(vec2 uv) {\n    // v1 : return texture 1\n    //return texture(iChannel0,(1.0/20.0)*uv);\n    \n    // v2: RAYAS EN Z (Y DEL PLANO)\n    //return vec4( clamp( sign( sin(3.0*uv.x) ) , 0.0, 1.0) );\n\n    // v3: RAYAS EN X ( X DEL PLANO)\n    //return vec4( clamp( sign( sin(1.0*uv.y) ) , 0.0, 1.0) );\n\n\t// v4.1: RECUADROS (MOD + SIGN + CLAMP)\n    /*\n\tfloat frec = 1.0 / 20.0;\n    float val1 = clamp(sign(mod(frec*uv.x,2.0)-1.0),0.0,1.0);\n    float val2 = clamp(sign(mod(frec*uv.y,2.0)-1.0),0.0,1.0);\n    float col = mod(val1 + val2,2.0);\n    return vec4( vec3( col ), 1.0 );\n\t//*/\n    \n    // V4.2 RECUADROS (SIN)\n    /*\n    float col = clamp( sign( sin(uv.x)*sin(uv.y) ) , 0.0, 1.0);\n    return vec4( vec3( col ), 1.0 );\n\t//*/\n    \n    // V5: COPACABANA\n    //float t = 0.0; //iTime\n    //float xt = (0.2*uv.x) + 0.5 * sin(0.5*(uv.y-5.0*t));\n    \n    //vec4 col = vec4( vec3( trunc(mod(xt,2.0)) ), 1.0);\n    //return col;\n\n    // V6: MANDELBROT\n    float val = mandelbrot(uv / 50.0, iTime);\n    return vec4( vec3 ( val ) , 1.0);\n\n}\n\nbool plotSphere(\n    \t\tfloat K, vec3 E, vec3 V, vec3 C, float r, out vec4 fragColor\n    \t\t, float minDist\n               )\n{\n    vec3 ix = E + minDist * V;\n    vec3 ixN =  ix - C;\n\n    vec3 refl = reflect(V,ixN);\n\n    float light;\n    light = dot ( normalize(ixN), normalize(vec3(1.0,1.0,-1.0)) );\n\n    light = clamp(light,0.5,1.0);\n    light = pow(light,2.0);\n    light *= 2.0;\n    light += 0.25;\n\n    K = intersectLinePlane(ix, refl, P, N);\n    vec4 baseColor = vec4(vec3(light),1.0);\n    if ( K > 0.0 && K < 30.0 )\n    {\n        vec3 I = ix + K * refl;\n        I = I - P;\n        vec2 proj = vec2 ( dot(I,PX) , dot(I,PY) );\n\n        baseColor = planeColor(proj);\n\n    }\n    else {\n        if ( normalize(refl).y > 0.995 )\n        {\n            baseColor = vec4(0.0,1.0,0.0,1.0);\n        }\n        else\n        {\n            baseColor = texture(iChannel1,refl);\n        }\n    }\n    baseColor *= light;\n    fragColor = baseColor;\n    \n    \n    return true;\n}\n\nvec4 mainImageSample( vec2 fragCoord, vec2 resolution )\n{\n    // TRACK BALL CODE - BEGIN -------------\n    \n    // SHOW STATUS\n    /*if ( fragCoord.y / resolution.y < 0.1 )\n    {\n        return texture(iChannel2, fragCoord.xy / resolution.xy);\n    }*/\n\tvec2 squareId = vec2(5.0,0.0);\n    vec2 squareCoord = (squareId + 0.5) * side / iResolution.xy;\n    vec4 angle = texture(iChannel2, squareCoord);\n    // END -------------\n    \n\t//return texture(iChannel0,fragCoord/resolution.xy);\n\n    vec4 fragColor;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/resolution.xy;\n    uv -= 0.5;\n    //uv.x -= 0.5 * (resolution.x/resolution.y);\n    uv.x *= iResolution.x / iResolution.y;\n    //uv.y *= resolution.y / resolution.x;\n    vec2 pxPrec = vec2(1.0) / resolution.xx;\n\n    // CAMARA - OJO (EYE) / ARRIBA (UP)\n    vec3 E, UP;\n    E = vec3 ( 0.0, 0.0 , -20.0 );\n    UP = vec3 ( 0.0, 1.0, 0.0 );\n    \n    // DESDE ARRIBA DEL CENTRO DEL PLANO\n    //E = P + vec3( 0.0, 20.0, 0.0);\n    //UP = vec3( 0.0, 0.0, 1.0);\n\n    // DIRECCION FIJA DESDE EL EYE\n    ///*\n    vec3 DIR = vec3 ( 0.0, 0.0, 1.0 );\n    \n    // MUEVE LA CAMARA Y APUNTA HACIA P\n    ///*\n    float angleY, angleX;\n    float radius = 100.0;\n    \n    angleY = angle.r; //(iMouse.x / iResolution.x) * 2.0 * pi;\n    angleX = pi / 12.0; //(iMouse.y / iResolution.y) * 0.5 * pi;\n    \n    float deltaX = sin(angleY) * cos(angleX);\n    float deltaZ = cos(angleY) * cos(angleX);\n    float deltaY = sin(angleX);\n    vec3 pos = vec3(deltaX,deltaY,deltaZ);\n    pos = normalize(pos);\n    \n    E = P + radius * pos;\n    DIR = -pos;\n    DIR = normalize(DIR);\n\n    vec2 basedir = normalize(-vec2(deltaX,deltaZ));\n    basedir *= cos(0.5 * pi - angleX);\n    float uph = sin(0.5 * pi - angleX);\n    \n    UP = vec3( basedir.x, uph, basedir.y);\n    \n    UP = normalize(UP);\n    \n    mat4 rmY, rmZ;\n    \n    // INCLINA LA CAMARA\n    /*\n    rmZ = rotationMatrix_Z(-pi/8.0);\n    UP = (vec4(UP,1.0) * rmZ).xyz;\n    //*/\n    \n    // VARIA LA CAMARA\n    /*\n\t//float rotAngleZ = sin(iTime/2.0); \n    float rotAngleY = iTime/2.0;\n\n    rmY = rotationMatrix_Y(rotAngleY);\n    DIR = (vec4(DIR,1.0) * rmY).xyz; \n    UP = (vec4(UP,1.0) * rmY).xyz;\n    //*/\n\n\tvec3 RIGHT = -cross(DIR,UP);\n    RIGHT = normalize(RIGHT);\n    vec3 V = RIGHT * uv.x + UP * uv.y + DIR * 1.0;\n    //*/\n    \n    float K = intersectLinePlane(E, V, P, N);\n\n    // ----------------------------------------\n    // PLANO\n    // ----------------------------------------\n\tif ( K > 0.0 /*&& K <= 300.0*/ ) {\n    \t\n        vec4 light = clamp(vec4( vec3(1.0-(K/1000.0)), 1.0 ), 0.3, 1.0);\n            \n        vec3 I = E + K * V;\n        I = I - P;\n        \n        vec2 proj = vec2 ( dot(I,PX) , dot(I,PY) );\n        \n        float value = sin(4.0*proj.x);// + sin(4.0*I.y);\n        value = clamp(sign(value),0.0,1.0);\n        \n        //fragColor *= value;\n        \n        fragColor = planeColor(proj);\n        fragColor *= light; //sqrt(light);\n        \n        ///* EJES X e Y DEL PLANO\n        float prec = pxPrec.x;\n        if ( abs(proj.x) < 10.0 * pxPrec.x / (1.0/K) )\n        {\n            fragColor = vec4(0.0,0.0,1.0,1.0);\n        }\n        else if ( abs(proj.y) < 10.0 * pxPrec.y / (1.0/K))\n        {\n            fragColor = vec4(1.0,0.0,0.0,1.0);\n        }\n        \n    }\n    else {\n        // CIELO (SKY) - CUBE MAP\n        fragColor = texture(iChannel1,V);\n    }\n    \n    \n    float minZ = 1e20;\n    float r = 10.0 ;\n    vec3 C;\n    \n    float lado = 0.0; \n    \n    for ( float i = 0.0 ; i < 0.1 ; i += 1.0 )\n    {\n\t    for ( float j = 0.0 ; j < 0.1 ; j += 1.0 )\n    \t{\n            // ----------------------------------------\n            // ESFERA\n            // ----------------------------------------\n\n            C = P + vec3(i * 3.0 * r,r,j * 3.0 * r);\n            \n            // CUADRATIC BOUNCE\n            float H = 50.0;\n            float raizH = sqrt(H);\n            float dosraizH = 2.0*raizH;\n            \n            float time = 20.0*iTime;\n            float yVar = H - pow(mod(time,dosraizH)-raizH,2.0);\n\t\t\t\n            //BOUNCE DECAY\n            float p = time/dosraizH;\n            float s = p; //trunc(time/dosraizH);\n            float decay = pow(0.5,s);\n            yVar *= decay;\n            \n            C.y += yVar;\n\n            float IP1, IP2;\n            bool intersect;\n            intersect = intersectLineSphere(E,V,C,r, IP1, IP2);\n\n            float minDist = min(IP1,IP2);\n\n            if ( intersect && (minDist < K && K > 0.0 || K < 0.0 ) && minDist < minZ)\n            {\n                minZ = minDist;\n                vec4 sphereColor;\n                bool plot = plotSphere(K, E, V, C, r, sphereColor, minDist);\n                if ( plot )\n                    fragColor = sphereColor;\n            }\n        }\n    }\n    /*\n    // ----------------------------------------\n    // ESFERA 2\n    // ----------------------------------------\n    r = 5.0 ;\n    C = P + vec3(0.0,r,0.0) + vec3(3.0*r,0.0,0.0); // + vec3(8.0 * cos(iTime), 2.0 , 8.0 * sin(iTime));\n    \n    intersect = intersectLineSphere(E,V,C,r, IP);\n    \n    minDist = min(IP[0],IP[1]);\n    \n    if ( intersect && (minDist < K && K > 0.0 || K < 0.0 ) && minDist < minZ )\n    {\n        minZ = minDist;\n        vec4 sphereColor;\n\t\tbool plot = plotSphere(K, E, V, C, r, sphereColor, minDist);\n        if ( plot )\n            fragColor = sphereColor;\n    }\n    // ----------------------------------------\n    // ESFERA 3\n    // ----------------------------------------\n    r = 5.0 ;\n    C = P + vec3(0.0,r,0.0) + vec3(-3.0*r,0.0,0.0); // + vec3(8.0 * cos(iTime), 2.0 , 8.0 * sin(iTime));\n    \n    intersect = intersectLineSphere(E,V,C,r, IP);\n    \n    minDist = min(IP[0],IP[1]);\n    \n    if ( intersect && (minDist < K && K > 0.0 || K < 0.0 ) && minDist < minZ )\n    {\n        minZ = minDist;\n        vec4 sphereColor;\n\t\tbool plot = plotSphere(K, E, V, C, r, sphereColor, minDist);\n        if ( plot )\n            fragColor = sphereColor;\n    }\n*/\n\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    bool antiAliasing = true;\n\tfloat level = ANTIALIASING_LEVEL;\n    \n    if ( ! antiAliasing )\n    {\n\t\t// COMMON   \n    \tfragColor = mainImageSample(fragCoord, iResolution.xy);\n    }\n    else\n    {\n        // ANTI-ALIASING\n        vec2 newResolution = iResolution.xy * level;\n        vec2 newCoord = fragCoord * level;\n\t\tvec4 sumColor = vec4(0.0);\n        \n        for ( float i = 0.0 ; i < 4.0 ; i+=1.0 )\n        {\n            for ( float j = 0.0 ; j < 4.0 ; j+=1.0 )\n            {\n        \t\tsumColor += mainImageSample(newCoord + vec2(i,j), newResolution);\n            }\n        }\n\n        fragColor = sumColor / (level*level);\n    }\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float side = 20.0;\n\nstruct Complex {\n    float u;\n    float v;\n};\n\nstruct Quaternion {\n    float t;\n    float x;\n    float y;\n    float z;\n};\n\nstruct Sphere\n{\n\tvec3 C;\n    float r;\n}\n;\nmat4 rotationMatrix_X(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(\n        1.0\t\t, 0.0\t\t, 0.0\t, 0.0 ,\n        0.0\t\t, c\t\t\t, -s\t, 0.0 ,\n        0.0\t\t, s\t\t\t, c\t\t, 0.0 ,\n        0.0\t\t, 0.0\t\t, 0.0\t, 1.0 );\n}\n\nmat4 rotationMatrix_Y(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(\n        c\t\t, 0.0\t\t, s\t\t, 0.0 ,\n        0.0\t\t, 1.0\t\t, 0.0\t, 0.0 ,\n        -s\t\t, 0.0\t\t, c\t\t, 0.0 ,\n        0.0\t\t, 0.0\t\t, 0.0\t, 1.0 );\n}\n\nmat4 rotationMatrix_Z(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(\n        c\t\t, -s\t\t, 0.0\t, 0.0 ,\n        s\t\t, c\t\t\t, 0.0\t, 0.0 ,\n        0.0\t\t, 0.0\t\t, 1.0\t, 0.0 ,\n        0.0\t\t, 0.0\t\t, 0.0\t, 1.0 );\n}\n\nbool intersectLineSphere(vec3 E, vec3 V, vec3 C, float r, out float salida1, out float salida2)\n{\n\t//E = (a,b,x)\n\t//V = (c,d,y)\n\t//C = (e,f,z)\n\n    //A\t= k^2 * ( c^2 + d^2 + y^2)\n\t//B\t= k * 2 * ( c * ( a - e ) + d * (b - f) + y * ( x - z) )\n\t//C\t= a^2 + e^2 - 2*a*e + b^2+ f^2 - 2 * b * f + x^2 + z^2 - 2 * x * z - r^2\n\t\n\tfloat a = E.x, b = E.y, x = E.z;\n    float c = V.x, d = V.y, y = V.z;\n    float e = C.x, f = C.y, z = C.z;\n    \n    float Ax = c*c + d*d + y*y;\n    float Bx = 2.0 * ( c * ( a - e ) + d * (b - f) + y * ( x - z) );\n    float Cx = a*a + e*e - 2.0*a*e + b*b+ f*f - 2.0 * b * f + x*x + z*z - 2.0 * x * z - r*r;\n    \n    float det = Bx*Bx - 4.0 * Ax * Cx;\n    \n    float x1 = ( -Bx + sqrt(det) ) / ( 2.0 * Ax );\n    float x2 = ( -Bx - sqrt(det) ) / ( 2.0 * Ax );\n    \n    /*\n\tsalida[0] = x1;\n    salida[1] = x2;\n\t*/\n    salida1 = x1;\n    salida2 = x2;\n    \n    //if ( isnan(x1) ) return false;\n    if ( x2 < 0.0 ) return false;\n\n    return true;\n}\n\nfloat intersectLinePlane(vec3 E, vec3 V, vec3 P, vec3 N)\n{\n    return dot ( N , P - E )\t/ dot ( N, V );\n}\n\nvec2 c_mult(vec2 a, vec2 b) {\n  return vec2(a.x * b.x - a.y * b.y,\n              a.x * b.y + a.y * b.x);\n}\n\nfloat mandelbrot(vec2 c , float time)\n{\n    vec2 z = vec2(0.0, 1.9 * sin(time));\n    float L = 2.0;\n    float Lsqr = L * L;\n    int depth = 100;\n    int i = 0;\n    for ( i = 0 ; i < depth ; i ++ )\n    {\n        if ( dot(z,z) < Lsqr )\n        {\n        \tz = c_mult(z,z) + c;\n        }\n        else break;\n        \n    }\n    float val = 0.0;\n    float l = length(z);\n    if ( l < L )\n    {\n        val = 0.0;\n    }\n    else\n    {\n        val =  1.0 - pow(float(i)/float(depth),0.333);\n    }\n\treturn val;\n}\n\nvec2 c_conjugate(vec2 c) {\n    return vec2(c.x, -c.y);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 getSquareId (vec2 coord)\n{\n    return trunc(coord/side);\n}\n\nvec2 squareCoord(vec2 squareId) {\n    return squareId * side;\n}\n\nbool inSquare(vec2 coord, vec2 squareId)\n{\n    vec2 squareBase = squareCoord(squareId);\n    vec2 squareDest = squareBase + side;\n    if ( coord.x - squareBase.x < side ) {\n        if ( coord.y - squareBase.y < side) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvec2 moveToSquare(vec2 coord, vec2 squareId){\n    vec2 newcoord = coord + (squareId - getSquareId(coord)) * side;\n    return newcoord;\n}\n\nvec4 colorAtSquare(vec2 squareId) {\n    vec2 newCoord = squareCoord(squareId);\n    newCoord += 0.5 * side;\n    newCoord /= iResolution.xy;\n    return texture(iChannel0, newCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if ( inSquare(fragCoord, vec2(0.0,0.0) ) )\n    {\n\t\tvec4 colAnt = texture(iChannel0, uv);\n\t\tvec4 newCol;\n        if ( iMouse.z >= 0.0 || iMouse.w >= 0.0 ) \n        {\n            if ( colAnt.r < 0.5 && colAnt.g < 0.5 )\n            {\n        \t\tnewCol = vec4(1.0,0.0,0.0,1.0);\n            }\n            else if ( colAnt.r > 0.5 && colAnt.g < 0.5 )\n            {\n                newCol = vec4(1.0,1.0,0.0,1.0);\n            }\n            else\n            {\n                newCol = colAnt;\n\t\t\t}\n            \n            fragColor = newCol;\n        }\n        else {\n            if ( colAnt.r > 0.5 && colAnt.g > 0.5 )\n            {\n                newCol = vec4(0.0,1.0,0.0,1.0);\n            }\n            else if ( colAnt.r < 0.5 && colAnt.g > 0.5 ) {\n                newCol = vec4(0.0,0.0,0.0,1.0);\n            }\n            fragColor = newCol;\n        }\n        \n    }\n    else if ( inSquare(fragCoord, vec2(1.0,0.0) ) )\n    {\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    }\n    else if ( inSquare(fragCoord, vec2(2.0,0.0) ) )\n    {\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n    else if ( inSquare (fragCoord, vec2(3.0, 0.0)) )\n    {\n        // aumenta el color anterior\n\t\tfragColor = texture(iChannel0, uv);\n        vec4 colAntClick = colorAtSquare(vec2(0.0,0.0));\n        if ( colAntClick.r < 0.5 && colAntClick.g > 0.5 )\n        {\n\t\t\tvec4 colAnt = texture(iChannel0, uv);\n\t\t\tfloat var = colorAtSquare(vec2(4.0,0.0)).r;\n            \n            fragColor = clamp(colAnt + vec4(var),0.0,1.0);\n            fragColor = mod(fragColor,1.00000);\n        }\n        // Setea el valor del mouse y la distancia\n        //fragColor = vec4(\n    }\n    else if ( inSquare (fragCoord, vec2(4.0, 0.0)) )\n    {\n        vec4 colAntClick = colorAtSquare(vec2(0.0,0.0));\n        // CONTINUA APRETADO\n\t\tif ( colAntClick.r > 0.5 && colAntClick.g > 0.5 \n            && iMouse.z >= 0.0 || iMouse.w >= 0.0)\n        {\n            float varX = (iMouse.x - iMouse.z) / iResolution.x ;\n            //float dist = length(v);\n            fragColor = vec4(varX, 0.0, 0.0, 1.0);\n        }\n        else\n        {\n            fragColor = texture(iChannel0,uv);\n        }\n    }\n    else if ( inSquare (fragCoord, vec2(5.0, 0.0)) )\n    {\n        vec4 colAntClick = colorAtSquare(vec2(0.0,0.0));\n        if ( colAntClick.r < 0.5 && colAntClick.g > 0.5 )\n        {\n\t\t\tvec4 colAnt = texture(iChannel0, uv);\n\t\t\tfloat var = colorAtSquare(vec2(4.0,0.0)).r;\n            \n            fragColor = colAnt + vec4(var);\n            //fragColor = clamp(fragColor,0.0,1.0);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, uv);\n        }\n    }\n    // NUEVO\n    else if ( inSquare (fragCoord, vec2(6.0, 0.0)) )\n    {\n        if ( iMouse.z >= 0.0 && iMouse.z <= 20.0 && iMouse.w >= 0.0 && iMouse.w <= 20.0 )\n        {\n            fragColor = vec4(1.0,1.0,0.0,1.0);\n        }\n        else if ( iMouse.z >= 0.0 && iMouse.z <= 20.0 )\n        {\n            fragColor = vec4(1.0,0.0,0.0,1.0);\n        }\n        else if ( iMouse.w >= 0.0 && iMouse.w <= 20.0 )\n        {\n            fragColor = vec4(0.0,1.0,0.0,1.0);\n        }\n        /*else if ( iMouse.z > 0.0 || iMouse.w > 0.0 )\n        {\n            fragColor = vec4(1.0);\n        }*/\n        else {\n            fragColor = vec4(0.0);\n        }\n        //fragColor = vec4(abs(iMouse.z)/iResolution.x);\n\t\t\n    }\n    else if ( inSquare (fragCoord, vec2(7.0, 0.0)) )\n    {\n        \n    }\n    \n    else \n        fragColor = vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}