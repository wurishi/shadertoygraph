{"ver":"0.1","info":{"id":"ts23Rh","date":"1548187950","viewed":482,"name":"3D objects","username":"yashgugale","description":"3D distance fuctions.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3ddistancefunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Plane:\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n\n// Torus:\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// Ellipsoid:\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\n\n// Capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// Round Cone:\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n///////////////////////////////////////////////////////////////////////\n// Union, Subtraction, Intersection:\n//Union:\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n// Subtraction:\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Intersection:\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n// Round box:\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\n// Sphere:\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    \n    float an = sin(iTime);\n\n    // opUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opUnion(d1,d2);\n    d = min( d, dt );\n  \t}\n\n    // opSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSubtraction(d1,d2);\n    d = min( d, dt );\n    }\n\n    // opIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opIntersection(d1,d2);\n    d = min( d, dt );\n    }\n    \n\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    //vec3 sphere = vec3(uv, 0.3);\n    //float d1 = sdSphere(sphere, 0.4);\n    //float r = length( uv )*1.9;\n    \n    //vec3 col = mix( vec3(0.6, 0.0, 0.5), vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec3 tot = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n\n    }\n    tot /= float(AA*AA);\n\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}