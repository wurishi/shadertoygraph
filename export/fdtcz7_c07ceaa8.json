{"ver":"0.1","info":{"id":"fdtcz7","date":"1653208927","viewed":180,"name":"Blue Planet","username":"Rrrrichard","description":"The main fbm color generation code is based on https://www.shadertoy.com/view/tltXWM#, which is absolutely a great work. Check it out!\n\n2-hour shader challenge of Zhehao Li on 2022/05/22","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fbm","planet","procedual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ===========================================================\n// 2-hour shader challenge of Zhehao Li on 2022/05/22\n//\n// Reference: https://www.shadertoy.com/view/tltXWM#\n// The main fbm color generation code belongs to above reference\n// ===========================================================\n\n\n// ============== noise part =================\n// Based on https://www.shadertoy.com/view/tltXWM#\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n#define PI 3.141592653\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\n// fbm code from: https://iquilezles.org/articles/fbm/\nfloat fbm( vec3 x)\n{   \n    float H = 1.0;\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 0.6;\n    float t = 0.0;\n    for( int i=0; i<NUM_NOISE_OCTAVES; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        f += 0.;\n        a *= G;\n    }\n    return t;\n}\n\nfloat fbm2(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nvec3 fbmColorSimple(vec3 point)\n{\n    return vec3(0.0);\n}\n\nvec3 fbmColor(vec3 point)\n{\n    vec3 sphere = vec3(0, 1., 6);\n    vec3 r_to_c = point - sphere;\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n    float alpha = PI / 3.;\n    mat3 rot2 = mat3(\n      cos(alpha), sin(alpha ),0 ,\t                \n      -sin(alpha), cos(alpha ),0,\t\n      0, 0, 1\n    );\n    r_to_c =  rot2 * rot * r_to_c; \n    point = sphere + r_to_c; \n    \n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n    \n    // calculate fbm noise (3 steps)\n    q = vec3(fbm(point + 0.025*iTime), fbm(point), fbm(point));\n    r = vec3(fbm(point + 1.0*q + 0.05*iTime), fbm(point + q), fbm(point + q));\n    v = fbm(point + 5.0*r + iTime*0.005);\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top = vec3(1.0, 1.0, 1.0);\n    vec3 col_bot = vec3(0.0, 0.0, 0.0);\n    vec3 col_mid1 = vec3(0.1, 0.4, 0.0);\n    vec3 col_mid2 = vec3(0.3, 0.5, 0.6); //vec3(0.4, 0.4, 0.6);\n    vec3 col_mid3 = vec3(0.2, 0.4, 0.9);\n    \n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    return color; \n}\n//===============================================\n\n//================= Ray Marching Part ===============\n\n#define MAX_STEPS 100\n#define MAX_DIST 1e10\n#define EPS .01\n\n\nfloat GetSceneDistance(vec3 point)\n{\n    vec4 sphere = vec4(0, 1., 6, 1.); // (xyz, radius)\n  \n    float sphere_dist = length(point - sphere.xyz)-sphere.w;\n    float d = sphere_dist; \n    \n    return d; \n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_dir)\n{\n    float d = 0.; \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * d;\n        float ds = GetSceneDistance(p); \n        d += ds; \n        if(d > MAX_DIST || ds < EPS) \n            break;  // hit object or out of scene\n    }\n    return d; \n}\n\nvec3 GetNormal(vec3 point)\n{\n    float d = GetSceneDistance(point); \n    vec2 e = vec2(0.01, 0); \n    vec3 n = d - vec3(\n        GetSceneDistance(point - e.xyy),\n        GetSceneDistance(point - e.yxy),\n        GetSceneDistance(point - e.yyx)\n    );\n    \n    return normalize(n); \n}\n\nfloat GetLight(vec3 point)\n{    \n    //point = rot * point; \n    vec3 light_pos = vec3(3, 5, -1); \n     \n    vec3 to_light = normalize(light_pos - point); \n    vec3 normal = GetNormal(point); \n    \n    float intensity = 0.8;\n    float diffuse = intensity * clamp(dot(to_light, normal), 0., 1.); \n    \n    float ambient = 0.01;\n    float d = RayMarch(point+normal*2.*EPS, to_light);\n    \n    if (d < length(light_pos - point))\n        diffuse *= 0.6;\n    \n    return diffuse + ambient;\n}\n\n// =============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.x;\n\n    // Time varying pixel color\n    vec3 ray_origin = vec3(0, 1, 0);\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.));\n   \n    float d = RayMarch(ray_origin, ray_dir);\n    \n    vec3 point = ray_origin + d * ray_dir; \n    \n    float diffuse_light = GetLight(point); \n    \n    vec3 col = fbmColor(point) * (diffuse_light);\n    \n    col = pow(col, vec3(0.4545)); // Gamma correction\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}