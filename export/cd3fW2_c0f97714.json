{"ver":"0.1","info":{"id":"cd3fW2","date":"1698228157","viewed":59,"name":"Refactored_TP_project","username":"JulieM","description":"the project for m1if02","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["graded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Shape{\n    vec3 c;// Center\n    vec3 d;// Dimensions\n    mat3 r;// Rotation matrix\n    int t;// Shape type\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    vec3 s;// Speculaire\n    vec3 a;// Ambiant\n    float rc;// Reflection rate\n};\n\nstruct InfiniteLight\n{\n    vec3 d;// Direction\n    vec3 c;// Colour\n};\n\nfloat oclDist;//the local occlusion distance\n\n\n//Movements for the shapes\nShape translation(Shape S, vec3 d)\n{\n    S.c = S.c+d;\n    return S;\n}\nShape homotetie(Shape S, vec3 d)\n{\n    S.c = S.c*d;\n    return S;\n}\nShape homotetie(Shape S, float d)\n{\n    S.c = S.c*d;\n    return S;\n}\nShape rotation(Shape S, float t, int d)\n{\n    mat3 rotMat = mat3(1.);\n    float c = cos(t);\n    float s = sin(t);\n    if(d==0)\n        rotMat = mat3(1.,0.,0.,0.,c,-s,0.,s,c);\n    if(d==1)\n        rotMat = mat3(c,0.,s,0.,1.,0.,-s,0.,c);\n    if(d==2)\n        rotMat = mat3(c,-s,0.,s,c,0.,0.,0.,1.);\n    S.r = rotMat*S.r;\n    return S;\n}\n\n\n\n\n// All the material functions\nMaterial Uniform(){\n    return Material(vec3(.8,.5,.4), vec3(0.), vec3(0.),0.2);\n}\n\nMaterial Mirror() {\n    return Material(vec3(1.), vec3(0.), vec3(0.),1.);\n}\n\nvec4 hash4(vec3 p)\n{\n    vec4 q = vec4( dot(p,vec3(267.9,126.1,311.7)), \n\t\t\t\t   dot(p,vec3(934.7,269.5,173.3)), \n\t\t\t\t   dot(p,vec3(361.9,429.2,371.9)),\n                   dot(p,vec3(124.3,267.7,736.5)) );\n\treturn fract(sin(q)*23638.5483);\n}\n\n\nfloat VoronoiNoise(vec3 p)\n{\n\tfloat k = 50.0;\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int z=-2; z<=2; z++ )\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec3  g = vec3(x, y, z);\n\t\tvec4  o = hash4(i + g);\n\t\tvec3  d = g - f + o.xyz;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.w*w,w);\n    }\n\t\n    return abs(a.x/a.y);\n}\n\nfloat Checkers(in vec3 p, float c)\n{\n    // Filter kernel\n    vec3 w=fwidth(c*p)+.001;\n    // Box box filter\n    vec3 i=2.*(abs(fract((c*p-.5*w)*.5)-.5)-abs(fract((c*p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return .5-.5*i.x*i.y*i.z;\n}\n\nvec3 TypeCheckers(in vec3 p, float c)\n{\n    // Filter kernel\n    vec3 w=fwidth(c*p)+.001;\n    // Box box filter\n    vec3 i=2.*(abs(fract((c*p-.5*w)*.5)-.5)-abs(fract((c*p+.5*w)*.5)-.5))/w;\n    vec3 j = 2.*mod(floor(p),2.)-vec3(1.);\n    // xor pattern\n    float t = i.x*i.y*i.z;\n    float s = j.x*j.y*j.z;\n    return vec3(clamp((t-s)/2.,0.,1.),clamp((s-t)/2.,0.,1.),0.);\n}\n\nfloat ConcentricPoint(in vec3 p, float c)\n{\n    float i = mod(floor(length(p)/c),2.);\n    // concentric pattern\n    return i;\n}\n\n\n\n\n\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Uniform();\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(p,1.);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col,vec3(0.),vec3(0.),0.);\n    }\n    else if(i==3)\n    {\n        // compute checkboard\n        vec3 f=TypeCheckers(p,1.);\n        vec3 col1=vec3(.5,.6,.8)*f.x;\n        vec3 col2=vec3(.9,.9,.9)*f.y;\n        return Material(col1,col2,vec3(0.),0.);\n    }\n    else if(i==2)\n    {\n        // compute concentric\n        float f=ConcentricPoint(p,0.5);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col,vec3(0.),vec3(0.),0.);\n    }\n    else if(i==4)\n    {\n        return Mirror();\n    }\n    else if(i==5)\n    {\n        float f = VoronoiNoise(10.*p);\n        vec3 col = vec3(.7,.4,.3)+.2*f;\n        return Material(col,.75*col,vec3(0.),0.);\n    }\n    return Material(vec3(0.),vec3(0.),vec3(0.),0.);\n}\n\n\n\n//Intersections\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,pl.n,pl.i);\n        return true;\n    }\n    return false;\n}\n\n// Unit Shapes Intersections\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectUnitSphere(Ray ray,out Hit x)\n{\n    vec3 oc=ray.o;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-1.;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p),0);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Cylinder intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectUnitCylinder(Ray ray,out Hit x)\n{\n    vec3 normal;\n    float tmin=1000.;\n    \n    float aboc = dot(vec3(0.,0.,1.), ray.o);\n    float rab = dot(ray.d, vec3(0.,0.,1.));\n    \n    float a = dot(ray.d, ray.d) - rab * rab;\n    float b = 2.0 * (dot(ray.d, ray.o) - rab * aboc);\n    float c = dot(ray.o, ray.o) - aboc * aboc - 1.;\n    \n    float discriminant = b*b - 4.*a*c;\n    \n    //Body of the cylinder\n    if (discriminant >= 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        float h;\n        \n        if (t1 > 0.)\n        {\n            vec3 p = Point(ray,t1);\n            h = dot(p, vec3(0.,0.,1.));\n\n            if (h >= -.5 && h <= .5 )\n            {\n                normal = normalize(p-(vec3(0.,0.,1.)*h));\n                x = Hit(t1, normal, 0);\n                tmin = t1;\n            }\n        }\n        if (t2 > 0. && t2<t1)\n        {\n            vec3 p = Point(ray,t2);\n            h = dot(p, vec3(0.,0.,1.));\n            \n            if (h >= -.5 && h <= .5 )\n            {\n                normal = normalize(p-(vec3(0.,0.,1.)*h));\n                x = Hit(t2, normal, 0);\n                tmin = t2;\n            }\n        }\n        \n        float t3=-dot(ray.o-vec3(0.,0.,-.5),vec3(0.,0.,1.))/dot(ray.d,vec3(0.,0.,1.));\n        if(t3<tmin && t3>0.)\n            if(length(vec3(0.,0.,-.5)-Point(ray,t3))<1.)\n            {\n                x=Hit(t3,vec3(0.,0.,-1.),0);\n                tmin=t3;\n            }\n        \n        float t4=-dot(ray.o-vec3(0.,0.,.5),vec3(0.,0.,1.))/dot(ray.d,vec3(0.,0.,1.));\n        if(t4<tmin && t4>0.)\n            if(length(vec3(0.,0.,.5)-Point(ray,t4))<1.)\n            {\n                x=Hit(t4,vec3(0.,0.,1.),0);\n                tmin=t4;\n            }\n            \n        if(tmin<1000.)\n            return true;\n    }\n    return false;\n}\n\n// Box intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectFace(Ray ray,vec3 n,out Hit x)\n{\n    float t=-dot(ray.o-n,n)/dot(ray.d,n);\n    if(t>0.)\n    {\n        vec3 hit = Point(ray,t);\n        if(abs(hit.x)<.50001 && abs(hit.y)<.50001 && abs(hit.z)<.50001)\n        {\n            x=Hit(t,normalize(n),0);\n            return true;\n        }\n    }\n    return false;\n}\nbool IntersectUnitBox(Ray ray,out Hit x2)\n{\n    Hit x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectFace(ray,vec3(0.,0.,.5),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectFace(ray,vec3(0.,0.,-.5),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectFace(ray,vec3(0.,.5,0.),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectFace(ray,vec3(0.,-.5,0.),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectFace(ray,vec3(.5,0.,0.),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectFace(ray,vec3(-.5,0.,0.),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if (ret) x2=x;\n    return ret;\n}\n\n//Shapes Intersection\n\nmat3 scaleMat(vec3 scale)\n{\n    return mat3(scale.x,0.,0.,0.,scale.y,0.,0.,0.,scale.z);\n}\n\nbool IntersectSphere(Ray ray,Shape sph,out Hit x)\n{\n    mat3 A = sph.r*mat3(sph.d.x);\n    mat3 A_1 = inverse(A);\n    \n    Ray ray2 = Ray(A_1*(ray.o-sph.c),normalize(A_1*ray.d));\n    \n    if (IntersectUnitSphere(ray2,x))\n    {\n    \n        x = Hit(x.t/length(A_1*ray.d),normalize(A*x.n),x.i);\n        x.i = sph.i;\n        return true;\n    }\n    return false;\n}\n\nbool IntersectEllipsoid(Ray ray,Shape ell,out Hit x)\n{\n    mat3 A = ell.r*scaleMat(ell.d);\n    mat3 A_1 = inverse(A);\n    \n    Ray ray2 = Ray(A_1*(ray.o-ell.c),normalize(A_1*ray.d));\n    \n    if (IntersectUnitSphere(ray2,x))\n    {\n    \n        x = Hit(x.t/length(A_1*ray.d),normalize(A*x.n),x.i);\n        x.i = ell.i;\n        return true;\n    }\n    return false;\n}\n\nbool IntersectBox(Ray ray,Shape box,out Hit x)\n{\n    mat3 A = box.r*scaleMat(box.d);\n    mat3 A_1 = inverse(A);\n    \n    Ray ray2 = Ray(A_1*(ray.o-box.c),normalize(A_1*ray.d));\n    \n    if (IntersectUnitBox(ray2,x))\n    {\n    \n        x = Hit(x.t/length(A_1*ray.d),normalize(A*x.n),x.i);\n        x.i = box.i;\n        return true;\n    }\n    return false;\n}\n\nbool IntersectCylinder(Ray ray,Shape cyl,out Hit x)\n{\n    mat3 A = cyl.r*scaleMat(cyl.d);\n    mat3 A_1 = inverse(A);\n    \n    Ray ray2 = Ray(A_1*(ray.o-cyl.c),normalize(A_1*ray.d));\n    \n    if (IntersectUnitCylinder(ray2,x))\n    {\n    \n        x = Hit(x.t/length(A_1*ray.d),normalize(A*x.n),x.i);\n        x.i = cyl.i;\n        return true;\n    }\n    return false;\n}\n\nbool IntersectCapsule(Ray ray,Shape cap,out Hit x2)\n{\n    Hit x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectCylinder(ray,cap,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    vec3 end = (cap.d.z/2.)*cap.r*vec3(0.,0.,1.);\n    if(IntersectEllipsoid(ray, Shape(cap.c+end,vec3(cap.d.x,cap.d.y,min(cap.d.x,cap.d.y)),cap.r,cap.t,cap.i), current) && current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoid(ray, Shape(cap.c-end,vec3(cap.d.x,cap.d.y,min(cap.d.x,cap.d.y)),cap.r,cap.t,cap.i), current) && current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if (ret) x2=x;\n    x2.i = cap.i;\n    return ret;\n}\n\nbool IntersectShape(Ray ray, Shape shp, out Hit hit)\n{\n    if (shp.t==0)\n        return IntersectSphere(ray,shp,hit);\n    if (shp.t==1)\n        return IntersectEllipsoid(ray,shp,hit);\n    if (shp.t==2)\n        return IntersectBox(ray,shp,hit);\n    if (shp.t==3)\n        return IntersectCylinder(ray,shp,hit);\n    if (shp.t==4)\n        return IntersectCapsule(ray,shp,hit);\n    \n}\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,-0.1),3);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    \n    const int l = 5;\n    \n    Shape[l] shapes;\n    shapes[0] = Shape(vec3(3.,3.,2.),vec3(1.1,.9,2.7),mat3(1.),1,2);\n    shapes[0] = rotation(shapes[0],.57,0);\n    shapes[0] = rotation(shapes[0],-.57,2);\n    shapes[1] = Shape(vec3(3.,-3.,2.),vec3(1.1,1.1,4.2),mat3(1.),2,4);\n    shapes[2] = Shape(vec3(0.,0.,2.),vec3(1.1),mat3(1.),0,1);\n    shapes[3] = Shape(vec3(-3.,3.,2.),vec3(1.1),mat3(1.),3,5);\n    shapes[3] = rotation(shapes[3],1.7,1);\n    shapes[4] = Shape(vec3(-3.,-3.,2.),vec3(1.1,1.1,2.4),mat3(1.),4,1);\n    \n    \n    for(int i = 0; i<l; i++)\n    {\n        if(IntersectShape(ray,shapes[i],current)&&current.t<x.t){\n            x=current;\n            ret=true;\n        }\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m, vec3 p, vec3 n, vec3 v, InfiniteLight[3] lights)\n{\n    vec3 sum = vec3(0.);\n    float diffd,diffs,weight;\n    Hit x;\n    for(int i = 0; i<3; i++)\n    {\n        if(!Intersect(Ray(p+.01*n,lights[i].d),x))\n            {\n                diffd = clamp(dot(n,lights[i].d),0.,1.);\n                vec3 r = reflect(lights[i].d,n);\n                diffs = pow(clamp(dot(v,r),0.,1.),28.);\n                \n                sum = sum + lights[i].c*(m.d*diffd + m.s*diffs)/3.;\n            }\n    }\n    return sum;\n}\n\n\nconst int reflN = 3;\nfloat influence[reflN];\nvec3 colours[reflN];\n\nbool ShadeOne(Ray ray, bool idx, Hit x, InfiniteLight[3] lights, int i)\n{\n    \n    if(idx)\n    {\n        \n        vec3 p=Point(ray,x.t);\n        Material mat=Texture(p,x.i);\n        \n        colours[i] = Color(mat,p,x.n,ray.d,lights);\n        if (mat.rc>0.)\n        {\n            influence[i]=mat.rc;\n            return true;\n        }\n    }\n    else\n    {\n        colours[i] = Background(ray.d);\n    }\n    return false;\n}\n\n// Rendering\nvec3 Shade(Ray ray, bool ocl)\n{\n    // Define all the light sources\n    InfiniteLight light_l[3]; \n    light_l[0] = InfiniteLight(normalize(vec3(1,0,1)),vec3(3.,0.,0.));\n    light_l[1] = InfiniteLight(normalize(vec3(1,1,1)),vec3(0.,3.,0.));\n    light_l[2] = InfiniteLight(normalize(vec3(1,-1,1)),vec3(0.,0.,3.));\n    // Intersect contains all the geo detection\n    \n    Hit x,x1;\n    Ray ray2=ray;\n    int i = 1;\n    \n    bool idx=Intersect(ray,x);\n    x1 = x;\n    vec3 p=Point(ray,x.t);\n    vec3 p1 = p;\n    bool ref=ShadeOne(ray,idx,x,light_l,0);\n    while(ref && i<reflN)\n    {\n        ray2 = Ray(p1+.001*x1.n,normalize(reflect(ray2.d,x1.n)));\n        idx=Intersect(ray2,x1);\n        p1=Point(ray2,x1.t);\n        ref=ShadeOne(ray2,idx,x1,light_l,i);\n        i++;\n    }\n    i--;\n    \n    if (ocl && idx)\n    {\n        int total = 100, oclusion = 0;\n        for(int i = 0; i<100; i++)\n        {\n            vec3 d = Hemisphere(i,x.n);\n            if(Intersect(Ray(p+0.01*x.n,d),x1))\n            {\n                if(x1.t<2.)\n                    oclusion++;\n            }\n        }\n        colours[0] = colours[0]*(1.-float(oclusion)/float(total));\n    }\n    while(i>0)\n    {\n        colours[i-1]=colours[i]*influence[i-1]+colours[i-1]*(1.-influence[i-1]);\n        i--;\n    }\n    \n    return colours[0];\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd),false);\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}