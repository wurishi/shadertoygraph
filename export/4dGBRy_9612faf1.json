{"ver":"0.1","info":{"id":"4dGBRy","date":"1529224428","viewed":1315,"name":"4d raytracer","username":"GrayVoid","description":"This is a basic raytracer that operates in four dimensional space.\n\nLighting, reflections, etc, all is calculated in 4d.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","reflections","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright 2018, GrayVoid\n\nstruct Sphere{\n    vec4 pos;\n    float radius;\n    vec3 color;\n};\n    \nstruct Plane{\n    vec4 pos;\n    vec4 n;\n};\n    \nstruct RayHit{\n    vec3 color;\n    vec4 n;\n    float dist;\n};\n    \nstruct Viewer{\n    vec4 pos;\n    vec4 right;\n    vec4 up;\n    vec4 forward;\n};\n    \nstruct Ray{\n    vec4 start;\n    vec4 dir;\n};\n    \nfloat maxDistance = 100000.0;\n\nfloat fogDist = 50.0;\nvec3 fogColor = vec3(0.0, 0.0, 0.0);\n\nvec3 applyFog(in vec3 col, float dist){\n    float fogBlend = clamp(dist/fogDist, 0.0, 1.0);\n    return mix(col, fogColor, fogBlend);    \n}\n\nRayHit mixRayHits(in RayHit a, in RayHit b, float factor){\n    return RayHit(\n        mix(a.color, b.color, factor),\n        mix(a.n, b.n, factor),\n        mix(a.dist, b.dist, factor)\n    );\n}\n\nRayHit selectClosest(in RayHit a, in RayHit b){\n    float mixFactor = float(b.dist < a.dist);\n    RayHit result = RayHit(\n        mix(a.color, b.color, mixFactor),\n        mix(a.n, b.n, mixFactor),\n        min(a.dist, b.dist)\n    );\n    return result;\n}\n\n\nvec3 sceneColor(in vec4 point){\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 colorPos = fract(point.xyz);// - vec3(0.5, 0.5, 0.5));\n    color.xyz = step(vec3(0.5), colorPos);\n    return color;\n}\n\nRayHit rayVsPlane(in Ray ray, in Plane plane){\n    RayHit result = RayHit(vec3(0.0, 0.0, 0.0), -ray.dir, maxDistance);\n    RayHit defaultResult = result;\n    \n    float planeDot = dot(ray.dir, -plane.n);\n    float normalDist = dot(ray.start - plane.pos, plane.n);\n    float t = normalDist / planeDot;\n    result.dist = t;\n    result.n = plane.n;\n    result.color = sceneColor(ray.start + ray.dir * t);//vec3(1.0, 1.0, 1.0);\n    //return result;\n    return mixRayHits(defaultResult, result, float(\n        (planeDot > 0.0) && (t > 0.0)\n    ));\n\t    \n    \n    return result;\n}\n\nRayHit rayVsSphere(in Ray ray, in Sphere sphere){\n    RayHit defaultResult = RayHit(fogColor, -ray.dir, maxDistance);\n    \n    //pythogorean solution\n    vec4 sphereDiff = sphere.pos - ray.start;\n    float sphereDist = dot(sphereDiff, ray.dir);\n    float spherePerpDist = sqrt(dot(sphereDiff, sphereDiff) - sphereDist * sphereDist);\n    \n    float dt2 = sphere.radius * sphere.radius - spherePerpDist * spherePerpDist;\n    float dt = sqrt(dt2);\n    \n    float t = sphereDist - dt;//no need for t2, as we haven no refractions\n    vec4 hitPos = ray.start + ray.dir * t;\n    vec4 sphereNormal = clamp(normalize(hitPos - sphere.pos), -1.0, 1.0);\n    RayHit sphereHit = RayHit(\n        sphere.color,\n        //sphereNormal.xyz * 0.5 + 0.5,\n        //clamp(sphereNormal.xyz * 0.5 + 0.5, 0.0, 1.0),\n        sphereNormal,\n        t\n    );\n    //sphereHit.color = sphereHit.n.xyz * 0.5 + 0.5;\n    return mixRayHits(\n        defaultResult, sphereHit, float((spherePerpDist < sphere.radius) && (t > 0.0))\n    );\n    \n    \n    //return result;\n}\n\nRay makeRay(in vec2 fragCoord, in Viewer viewer){\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    Ray result = Ray(\n        viewer.pos,\n        viewer.forward + viewer.right * uv.x + viewer.up * uv.y\n    );\n    result.dir = normalize(result.dir);\n    return result;\n}\n\nconst int numMovingSpheres = 3;\n\nstruct Orbit{\n    float period;\n    float radius;\n    vec4 origin;\n    vec4 xVec;\n    vec4 yVec;\n};\n    \nstruct SphereConfig{\n    Orbit orbit;\n    vec3 color;\n    float radius;\n};\n\nconst float pi = 3.14159265359;\n//const float epsilon = 0.0001;\n\nvec4 getOrbitPos(in Orbit orbit){\n    \n    float angle = fract(iTime/orbit.period) * pi * 2.0;\n    \n    return orbit.origin \n        + cos(angle) * orbit.radius * orbit.xVec \n        + sin(angle) * orbit.radius * orbit.yVec;\n        \n}\n\nstruct SceneConfig{\n    Orbit sunOrbit;\n    SphereConfig spheres[numMovingSpheres];\n    //Orbit orbits[numMovingSpheres];\n};\n    \nconst vec4 zero4 = vec4(0.0, 0.0, 0.0, 0.0);\n    \nSceneConfig sceneConfig = SceneConfig(\n    Orbit(15.0, 1.0, vec4(0.0, 5.0, 0.0, 0.0), vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0)),\n    SphereConfig[numMovingSpheres](\n    \tSphereConfig(Orbit(3.0, 1.0, zero4, vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0)), \n                     vec3(0.25, 1.0, 0.25), 0.25),\n    \tSphereConfig(Orbit(5.0, 1.5, zero4, vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0)), \n                     vec3(0.25, 0.25, 1.0), 0.25),\n    \tSphereConfig(Orbit(7.0, 2.0, zero4, vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0)), \n                     vec3(1.0, 0.25, 0.25), 0.5)\n    )\n);\n\nstruct Scene{\n    vec4 sunPos;\n    Plane plane;\n    Sphere mainSphere;\n    Sphere spheres[numMovingSpheres];\n};\n\nScene makeScene(in SceneConfig sceneConfig){\n    Scene scene;\n    scene.plane = Plane(vec4(0.0, -1.7, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0));\n    scene.mainSphere = Sphere(vec4(0.0, 0.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0)); \n    \n    for(int i = 0; i < numMovingSpheres; i++){\n        vec4 pos = getOrbitPos(sceneConfig.spheres[i].orbit);\n        scene.spheres[i].pos = pos;\n        scene.spheres[i].color = sceneConfig.spheres[i].color;\n        scene.spheres[i].radius = sceneConfig.spheres[i].radius;\n    }\n    scene.sunPos = getOrbitPos(sceneConfig.sunOrbit);\n    return scene;\n}\n\n\nRayHit rayCastBase(in Ray ray, in Scene scene){\n    RayHit result = RayHit(fogColor, -ray.dir, maxDistance);\n    result = selectClosest(result, rayVsPlane(ray, scene.plane));\n    result = selectClosest(result, rayVsSphere(ray, scene.mainSphere));\n    for(int i = 0; i < numMovingSpheres; i++){\n    \tresult = selectClosest(result, rayVsSphere(ray, scene.spheres[i]));\n    }\n    return result;\n}\n\nfloat getLightFactor(in vec4 lightPos, in vec4 worldPos, in vec4 worldNormal, in Scene scene){\n    vec4 diff = lightPos - worldPos;\n    float lightDist = length(diff);\n    vec4 lightDir = normalize(diff);\n    float lightDot = clamp(dot(lightDir, worldNormal), 0.0, 1.0);\n    \n    //shadow\n    Ray lightRay = Ray(scene.sunPos, -lightDir);\n    RayHit lightHit = rayCastBase(lightRay, scene);    \n    \n    const float shadowBias = 0.01;\n    \n    return lightDot * float((lightHit.dist + shadowBias) > lightDist);\n}\n\nconst int maxSurfaceHits = 4;\n\n\nvec3 rayCastScene(in Ray originalRay, in Scene scene){\n    const vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n    vec3 finalColor = vec3(0.0);\n    \n    Ray curRay = originalRay;\n    float baseFogDist = 0.0;\n  \tfloat subRayMultiplier = 1.0;\n    \n    for (int i = 0; i < maxSurfaceHits; i++){    \n    \tRayHit curHit = rayCastBase(curRay, scene);\n\n    \tfloat rayDot = clamp(dot(-curRay.dir, curHit.n), 0.0, 1.0);\n   \t\tfloat fresnSimple = 1.0 - rayDot;\n    \tfresnSimple = mix(0.1, 1.0, fresnSimple * fresnSimple);\n        //fresnSimple = 0.5;    \n    \n    \tvec3 baseColor = curHit.color;\n    \tvec4 worldPos = curHit.dist * curRay.dir + curRay.start;\n    \tvec4 worldNormal = curHit.n;\n    \n    \tfloat lightFactor = getLightFactor(scene.sunPos, worldPos, worldNormal, scene);\n        \n        vec3 curFinalColor = vec3(0.0);\n        curFinalColor += baseColor * ambientColor;\n        curFinalColor += baseColor * lightFactor;\n        curFinalColor = applyFog(curFinalColor, curHit.dist + baseFogDist);\n            \n        finalColor = mix(finalColor, curFinalColor, subRayMultiplier);\n    \t//finalColor += addedLight * subRayMultiplier;\n        \n    \tconst float bounceBias = 0.001;\n    \tvec4 reflected = reflect(curRay.dir, curHit.n);\n    \tvec4 curPos = curRay.start + curRay.dir * curHit.dist;\n    \tRay nextRay = Ray(curPos + reflected * bounceBias, reflected);            \n        baseFogDist += curHit.dist + bounceBias;\n        \n        subRayMultiplier *= fresnSimple;\n        curRay = nextRay;\n        //break;\n    }\n    \n    return finalColor;\n    //return applyFog(finalColor, curHit.dist);\n}\n\nvec4 getCurViewerPosition(){\n    const float timePeriod = 30.0;\n    \n    const int numPositions = 7;\n    vec4 positions[numPositions] = vec4[numPositions](\n        vec4(-3.0, 1.0, -3.0, 0.0),\n        vec4(3.0, 1.0, -3.0, 0.0),\n        vec4(3.0, 1.0, -3.0, -3.0),\n        vec4(3.0, 1.0, 0.0, -3.0),\n        vec4(0.0, 1.0, 0.0, -3.0),\n        vec4(0.0, 0.0, 0.0, -3.0),\n        vec4(-3.0, 1.0, -3.0, 0.0)\n    );\n    \n    float lerpScale = 4.0;\n    \n    float fracPeriod = fract(iTime/timePeriod);\n    float curPosFloat = fracPeriod * float(numPositions);\n    int curPos = int(floor(curPosFloat)) % numPositions;\n    float curLerp = fract(curPosFloat);\n    curLerp = clamp(curLerp * lerpScale, 0.0, 1.0);\n    int nextPos = (curPos + 1) % numPositions;\n    return mix(positions[curPos], positions[nextPos], curLerp);\n    \n}\n\nvec4 planeProjectNormalize(vec4 v, vec4 n){\n    return normalize(v - n *dot(v, n));\n}\n\nViewer makeViewer(){\n    vec4 target = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    Viewer result = Viewer(\n        vec4(0.0, 0.0, -3.0, 0.0),\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0)\n    );\n    \n    result.pos = getCurViewerPosition();\n    result.forward = normalize(target - result.pos);\n    result.up = planeProjectNormalize(result.up, result.forward);\n    result.right = planeProjectNormalize(result.right, result.forward);\n    result.right = planeProjectNormalize(result.right, result.up);\n    return result;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    Scene scene = makeScene(sceneConfig);\n    Viewer viewer = makeViewer();\n        \n    Ray ray = makeRay(fragCoord, viewer);\n\n    vec3 col = rayCastScene(ray, scene);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}