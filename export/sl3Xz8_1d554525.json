{"ver":"0.1","info":{"id":"sl3Xz8","date":"1638686814","viewed":225,"name":"yonatan's spooky towers","username":"darrellprograms","description":"Exploring and making notes on one of @zozuar's twigl shaders. I made the towers grow over time hoping to get a clearer idea of how the fractal ray marching works, but I find it quite visually appealing.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","test","de"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Original code (line breaks added):\n// float i,s,e,m;vec3 d,w,q,p;d=FC.rgb/r.y-1.;\n// for(w+=4.;i++<2e2;e=clamp(length(p)/s-m/s,w.y-m,.2)+i/1e6)\n// {i>1e2?d/=d,o:o+=exp(-e*5e3);s=2.;p=w+=d*e;p.xz*=rotate2D(t*.2);\n// p-=q=round(p);p.y=w.y-(m=fsnoise(q.zx)*4.);for(int j;j++<9;p.y-=m)\n// s/=e=min(dot(p,p),.4)+.1,p=abs(p)/e-.2;}o*=e/20.;\n//\n// Twitter: https://twitter.com/zozuar/status/1467319312067219456\n// twigl: bit.ly/3Gjl1OR\n//\n// seems to descend through @gaziya5 https://twitter.com/gaziya5/status/1360236394929561607\n// from @pabloandrioli's shadertoy.com/view/4lX3Rj\n//\n// it is based on kaliset fractals\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n// http://www.fractalforums.com/3d-fractal-generation/kaliset-3d-fractal-used-as-coloring-and-bump-mapping-for-de-systems/\n//\n// ...with the ray marching method of Distance Estimation (DE)\n// https://inst.eecs.berkeley.edu/~cs184/sp12/assignments/Archive/HW6/Fractal%20Renderer.htm friendly intro\n// http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/ guide with examples\n//\n// ray marching is a form of ray casting which uses variable step sizes based on how open the space is, which saves steps\n// while preserving accuracy and enables various effects\n//\n// here the ray does something like zeno's paradox approaching the surface without touching it\n\n//\n// I've done a little rearranging and replacing constants with named variables, but I mostly wanted to just open this up and\n// comment it to understand what's happening, without making it too hard to see how each piece relates to the original\n// ultra-compact twigl code\n//\n// I think it's hard to understand code without changing it\n// suggestion: start by finding where to restore the original behavior, then see what interesting differences you can cause\n//\n\n\n//from the twigl library https://github.com/doxas/twigl\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fsnoise(vec2 c){ //fast smooth noise\n    return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//myclamp fixes a bug in the original, which depends on clamp() working this way\n//clamp() has undefined behavior if minval > maxval\n// but this will always clamp to maxval if minval > maxval\nfloat myclamp(float x, float minval, float maxval){\n    return min(max(x,minval),maxval);\n    //return max(min(x,maxval),minval); // debug code for producing unwanted results of clamp() on some platforms\n    //return clamp(x, minval, maxval); // original calculation with undefined behavior\n}\n\nvec3 render(vec2 uv){\n    float i, //iterator\n     s, //scale factor\n     e, //ray marching step size / distance estimate\n     m; // height of tower (affects shape)\n    vec3 d, //direction of ray\n     w, //position of tip of ray\n     q, //tile of ray tip\n     p; //position of ray tip within tile\n    d=vec3(uv,0)-1.0; //set ray direction\n    //d/=length(d); //seems like the direction vector should be normalized, but you can't have it all in ultrashort code\n    vec3 o;\n    \n    bool original=false; //make this true to see the original behavior of @zozuar's code\n    bool badpixel=false; //for debugging tests\n    \n    float tallest= original ? 4. : .4+iTime*0.1; //I like the look when the towers grow, it doesn't have to be a static scene\n    float rotspeed= original ? .2 : .01; //it's easier to study when it's slow\n    float mainloops=200.;\n    int iterations= original ? 9 : 14 ; //nicer with a bit higher number\n    \n    if(original) w+=tallest; //move ray starting position up and away from the center of rotation to fly around\n    else w=vec3(0.,tallest,0.); //move up with tower growth, but sit at the xz origin and pivot to look around\n    while(i<mainloops){\n        i+=1.;\n        if(i>mainloops/2.){ //when halfway through fixed-length ray marching loop, switch to shadows\n            d=vec3(1.,1.,1.);\n            //d/=length(d);\n        }else{\n            o+=exp(-e*5000.); //the larger the step size, the less brightness is added, and a fixed number of steps is taken\n            //the ray is marched to more distant objects through more unimpeded long steps\n        }\n        s=2.0; //initialize the scale factor for this loop\n        w+=d*e; //advance ray\n        p=w; //start dividing position into tile coordinates, and position within tile\n        p.xz*=rotate2D(iTime*rotspeed); //rotate the world, not the camera\n        q=round(p); p-=q; //get the tile and position within tile\n        m=abs(fsnoise(q.zx))*tallest;//height / shapeseed of towers from smooth noise function\n        //\n        //here's where the magic happens: the fractal math to calculate a distance estimate to\n        // the geometry and use it to produce the next ray marching step distance\n        //\n        if(1==0){ //convenience branch for quickly trying modified behavior\n            //branch to mess with\n            //iterations= 9; //convenience assignment, doesn't need to be in the loop\n            p.y=w.y-m; //comment out for repeating vertical tiles\n            p=abs(p);\n            for(int j; j<iterations; j++){\n                const float a=.4, b=.2; //these seem to be arbitrary tuning factors under .5 and .25\n                e=min(length(p)*length(p),a)+(.5-a);\n                //e=.5; //boxes lol\n                //e=.48; //boxes of boxes\n                //e=.6; //broken\n                s/=e; p/=e;\n                p=abs(p - vec3(b,m+b,b));\n            }\n            e=(length(p)-m)/s;\n            e=myclamp(e,w.y-m,.2)+i/1e6;\n        }else{\n            //branch to keep original behavior\n            p.y=w.y-m;\n            for(int j; j++<iterations; p.y-=m){\n                s/=e=min(dot(p,p),.4)+.1; //e is getting used as a temporary variable\n                //e is always between .1 and .5, so scale factor s will be increased 2X to 10X per iteration\n                p=abs(p)/e-.2; //the magnitude of p is likewise increased, but then it is reduced\n            }\n            e=myclamp((length(p)/s)-(m/s),w.y-m,.2)+i/1e6;\n        }\n        //notes:\n        //e is back to its main purpose as step size\n        //if(e<0.) badpixel=true; // debugging: it'll be green if e ever goes negative\n    }\n    if(!original){ //debugging code, enabling or disabling shouldn't change anything unless the soften shadows is uncommented\n        if(e<0.1){ //e should either be negligible or slightly over .2 without doing this\n            e=0.;\n            e=.1; //soften shadows\n        }else{\n            e=.2;\n        }\n    }\n    //e=.2; // uncomment to deactivate shadows\n    o*=e/20.+ (original ? .0 : .001) ; //intensity correction and shadow rendering, based on shadow ray final step size (did the ray hit anything?)\n    if(o.r>1.0){ //badcolor debugging code (helped to figure out the clamp bug)\n        o=vec3(1.,0.,0.);\n    }\n    if(o.r<0.0){\n        o=vec3(0.,0.,1.);\n    }\n    if(badpixel){\n        o=vec3(0.,1.,0.);\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int aa=0; //anti-aliasing through super-sampling, will average aa^2 samples, if 2 or more\n    //because there's a lot of fine detail and edges, it looks a lot nicer with anti-aliasing\n    if(aa<2){\n        vec2 uv = fragCoord/iResolution.xy;\n        vec3 o=render(uv);\n        // Output to screen\n        fragColor = vec4(o,1.0);\n    }else{\n        vec3 osum;\n        for(int i=0; i<aa; i++){\n            for(int j=0; j<aa; j++){\n                vec2 uv = (fragCoord+vec2(i,j)/float(aa))/iResolution.xy;\n                osum+=render(uv);\n            }\n        }\n        // Output to screen\n        fragColor = vec4(osum/float(aa*aa),1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}