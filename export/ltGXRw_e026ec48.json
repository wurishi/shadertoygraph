{"ver":"0.1","info":{"id":"ltGXRw","date":"1483514817","viewed":137,"name":"dotnet-bot","username":"krwq","description":"base model which I used to render in the console window","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["dotnetbotkrwq"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on jlfwong's tutorial https://www.shadertoy.com/view/llt3R4\n// some functions stolen from iq\n\n#define pi 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n  return length(p.xz-c.xy) - c.z;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  n = normalize(n);\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sdCone(vec3 p, vec2 c) {\n    c = normalize(c);\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d2, d1);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opU(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nmat3 rotx(float angle) {\n    return mat3(1.,          0.,         0.,\n                0.,  cos(angle), -sin(angle),\n                0.,  sin(angle),  cos(angle));\n}\n\nmat3 roty(float angle) {\n    return mat3( cos(angle), 0., sin(angle),\n                 0,          1., 0.,\n                -sin(angle), 0., cos(angle));\n}\n\nmat3 rotz(float angle) {\n    return mat3( cos(angle), sin(angle), 0.,\n                -sin(angle), cos(angle), 0.,\n                         0.,         0., 1.);\n}\n\nfloat helmet(vec3 p) {\n    float ret = sdSphere(p, 1.);\n    ret = opS(ret, sdBox(p + vec3(0., -.25, -.8), vec3(1.2, 0.3, 0.55)));\n    ret = opU(ret, sdBox(rotz(0.25 * pi) * (p + vec3(0., 0.15, -.7)), vec3(.2, .2, .2)));\n    ret = opU(ret, sdSphere(p, 0.9));\n    return ret;\n}\n\nfloat antenna(vec3 p) {\n    float ret = sdCylinder(p, vec3(0., 0., .05));\n    ret = opS(ret, sdPlane(p, vec4(0., 1., 0., .1)));\n    ret = opS(ret, sdPlane(p, vec4(0., -1., 0., .2)));\n    ret = opU(ret, sdSphere(p - vec3(0., .2, 0.), .1));\n    \n    return ret;\n}\n\nfloat head(vec3 p) {\n    float r = 0.8;\n    float ret = helmet(p / r) * r;\n    ret = opU(ret, antenna(rotx(2. * pi / 20.) * roty(2. * pi / 20.) * (p - vec3(0., r, 0.))));\n    \n    // eyes\n    ret = opU(ret, sdSphere(p + vec3(.3, -.2, -.58), 0.11));\n    ret = opU(ret, sdSphere(p + vec3(-.3, -.2, -.58), 0.11));\n    \n    return ret;\n}\n\nfloat leg(vec3 p) {\n    //(p.y > -1.5 && p.y < 0.) ? \n    float ret = sdCylinder(p, vec3(0., 0., .1));\n    ret = opS(ret, sdPlane(p, vec4(0., -1., 0., 0.)));\n    ret = opS(ret, sdPlane(p, vec4(0., 1., 0., 1.5)));\n    \n    vec3 shoeP = rotz(.5 * pi) * (p + vec3(0., 1.5, -.1));\n    float shoe = sdCylinder(shoeP, vec3(0., 0., .35));\n    shoe = opS(shoe, sdPlane(shoeP, vec4(0., 1., 0., .15)));\n    shoe = opS(shoe, sdPlane(shoeP, vec4(0., -1., 0., .15)));\n    shoe = opS(shoe, sdPlane(shoeP, vec4(0., 0., 1., .2)));\n    ret = opU(ret, shoe);\n    \n    vec3 shoeTopP =  rotx(-0.5 * pi) * (p + vec3(0., 1.5, -.03));\n    float shoeTop = udRoundBox(shoeTopP, vec3(.15, .15, .3), 0.1);//sdCone(shoeTopP, vec2(2., 1.2));\n    \n    float fullShoe = opU(shoe, shoeTop);\n    \n    ret = opU(ret, sdTorus(p + vec3(.0, 1.06, 0.), vec2(.1, .07)));\n    ret = opU(ret, fullShoe);\n    ret = opS(ret, sdPlane(p, vec4(0., 1., 0., 1.5)));\n    \n    \n    \n    return ret;\n}\n\nfloat hand(vec3 p) {\n    p = p + vec3(.0, 0.8, 0.);\n    float ret = sdTorus(p, vec2(.1, .07));\n    \n    ret = opU(ret, sdCylinder(p, vec3(0., 0., .08)));\n    p = p + vec3(0., 0.3, 0.);\n    ret = opS(ret, sdPlane(p, vec4(0., 1., 0., 0.)));\n    ret = opU(ret, sdSphere(p, 0.12));\n    \n    p = rotz(0.1 * pi * sin(2. * pi * iTime / 3.)) * rotx(- .4 * pi + 0.2 * pi * sin(2. * pi * iTime / 5.)) * p;\n    float seg = opU(ret, sdCylinder(p, vec3(0., 0., .08)));\n    seg = opS(seg, sdPlane(p, vec4(0., -1., 0., 0.)));\n    p = p + vec3(0., 0.5, 0.);\n    seg = opS(seg, sdPlane(p, vec4(0., 1., 0., 0.)));\n    ret = opU(ret, seg);\n    \n    p = rotz(0.6 * pi) * p;\n    p = p + vec3(-0.15, 0., 0.);\n    p = rotx( 0.3 * pi * sin(2. * pi * iTime / 13.)) * p;\n    float palm = sdCylinder(p, vec3(0., 0., 0.2));\n    palm = opS(palm, sdPlane(p, vec4(0., .1, 0., .008)));\n    palm = opS(palm, sdPlane(p, vec4(0., -.1, 0., .008)));\n    ret = opU(ret, palm);\n    //ret = opU(ret, sdSphere(p, 0.15));\n    \n    return ret;\n}\n\nfloat map(vec3 p) {\n    float slowDown = 0.5;\n    p = rotx(sin(2. * pi * iTime / 7. * slowDown) * 0.5) * p;\n    p = roty(sin(2. * pi * iTime / 4. * slowDown) * .5 * pi + 0.5 * pi) * p;\n    //p = rotx(.5) * p;\n    //p = roty(pi * 0.5) * p;\n    \n    float ret = head(p);\n    \n    vec3 q1 = rotz(-0.4) * vec3(abs(p.x), p.y, p.z);\n    float legs = leg(q1);\n    ret = opU(ret, legs);\n    \n    vec3 q2 = rotz(1.5 * pi + .1 * pi * sin(2. * pi * iTime / 4.5)) * vec3(abs(p.x), p.y * (p.x > 0. ? -1. : 1.), p.z);\n    float hands = hand(q2);\n    ret = opU(ret, hands);\n    \n    return ret;\n}\n\nvec3 normal(in vec3 pos) {\n    /*float eps = 0.001;\n    return normalize(vec3(map(pos + vec3(eps,   0,   0)).x - map(pos - vec3(eps,   0,   0)).x,\n                          map(pos + vec3(  0, eps,   0)).x - map(pos - vec3(  0, eps,   0)).x,\n                          map(pos + vec3(  0,   0, eps)).x - map(pos - vec3(  0,   0, eps)).x));/* */\n    vec2 e = vec2(1.0,-1.0) * EPSILON * 0.1;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n                      e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  \n                      e.xxx*map( pos + e.xxx ));/* */\n\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(ro + depth * rd);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat cartoonEffect(float c, float n) {\n    return floor(c * n) / n;\n}\n\nvec3 render(vec2 fragCoord) {\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float eyez = 8.0;\n    vec3 eye = vec3(0.0, -0.1, eyez);\n    float dist = rayMarch(eye, dir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n\t\treturn vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 n = normal(eye + dir * dist);\n    vec3 color = vec3(1., 0., 0.);\n    return vec3(0.75 * dot(n, -dir) * color  * pow(eyez / dist, 3.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 c = fragCoord;\n    vec3 color = render(c);\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}