{"ver":"0.1","info":{"id":"clyBRV","date":"1702256745","viewed":31,"name":"Random Winding Field","username":"chronos","description":"Not much to see here :)\nTake a unit length line segment with normal n. Compute the cosine of the angle between the query point and the pole, then divide by the perimeter of the circle with radius from the pole to the query point. Sum to get the windingnum","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["random","number","field","area","falloff","projected","winding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat circle_perimeter(float r)    { return 2. * PI * r    ; }\nfloat sphere_surface_area(float r) { return 4. * PI * r * r; }  // for 3D\n\nfloat pole_2d(vec2 p, vec2 n, vec2 q)\n{\n    vec2 v = (p - q); // view/vector\n    \n    //float radius_squared = dot(v,v); // This would be for 3D ( surface of sphere )\n    float radius = length(v); //sqrt(radius_squared);\n    float cosine_term = dot(n, v) / radius;\n    \n    float projected_area = cosine_term / circle_perimeter(radius);\n    return projected_area;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    float winding_number = 0.;\n    \n    vec2 q = uv;      // Query point\n    \n    const int N = 80;\n    \n    for(int i = 0; i < N; i++)\n    {\n        vec2 p = -.9 + 1.8 * texelFetch(iChannel0, ivec2(i, 0), 0).rg; // \"Pole\"-point\n        p *= vec2(iResolution.x/iResolution.y, 1.);\n        \n        vec2 v = (p - q); // \"view\"/vector\n\n        float phase = texelFetch(iChannel0, ivec2(i, 1), 0).b;\n        float freq = -1. + 2. * texelFetch(iChannel0, ivec2(i, 1), 0).g;\n\n        float t = 2. * iTime * freq + phase;\n        vec2 n = normalize(vec2(cos(t),sin(t))); // can be scaled to incorporate area weighting using un-normalized 'normal'\n\n        winding_number += pole_2d(p, n, q);\n    }\n    \n    color = mix(vec3(0,1,0), vec3(0,0,1), 0.5*(1.+tanh(winding_number)));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}