{"ver":"0.1","info":{"id":"wld3Ws","date":"1578020650","viewed":107,"name":"Seabed","username":"tono","description":"seabed","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// i posted the shader in shadertoy and neort\n\nconst float PI = acos(-1.);\nconst float PI2 = PI * 2.;\n\n\nmat2 rot(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p , float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n//-----------------------------------------------------------\n\n\n//https://www.youtube.com/watch?v=aNR4n0i2ZlM&feature=youtu.be\nfloat sdHeart(vec3 p , float s )\n{\n    p.y /= 1.5;\n    s = s + pow( (0.5 + 0.5 *sin(2.*PI * iTime + p.y*4.) ) * 0.6 ,4.);\n    p.x =  p.y - abs(p.x) * sqrt((20. - abs(p.x)) / 15.);\n    p.y *= 1.2;\n    \n    return length(p) - s;\n}\n\n//https://qiita.com/kaneta1992/items/21149c78159bd27e0860\nvec2 pmod(vec2 p , float r)\n{\n    float a = atan(p.x,p.y) + PI/r;\n    float n = PI2 / r;\n    a = floor(a/n) * n;\n    return p * rot(-a);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 heart = p;\n    vec3 sep = vec3(.7);\n    heart.xz = pmod(heart.xz , 16.);\n    \n    heart.y -= iTime;\n    heart.xyz = sin(heart.xyz*sep);\n    heart.xz *= rot(iTime);\n    \n    vec3 sp = p;\n    sp.xz  = sin(sp.xz + heart.zx * heart.y * heart.xz);\n    sp.xz *= rot(sp.y*heart.y + iTime);\n    float s = sdHeart(heart,0.4 );\n    float pl = p.y + .25;\n    float sb = sdBox(sp,vec3(.1,3.,.1));\n    sp.y-= 2.;\n    sp.y = sin(sp.y-iTime);\n    float sb2 = sdSphere(sp,.3);\n    float sb3 = sdBox(sp,vec3(0.3));\n    sb2 = mix(sb2,sb3,clamp(sin(iTime + heart.y *6.),0.,1.));\n    sb = smin(sb,sb2,0.5);\n    \n    float id = (pl > s)?0.:1.;\n    float mm = sminCubic(sminCubic(s,pl,1.9),sb,0.6);\n    return vec2(mm,id);\n}\n\nvec3 marching(vec3 ro,vec3 rd)\n{\n    float depth = 0.;\n    float cyc = 0.;\n    float id = -1.;\n    for(int i = 0; i < 100 ; i++)\n    {\n        vec3 rp = ro + rd * depth;\n        vec2 d = map(rp);\n        \n        if(d.x < 0.001 * (depth * 6.) )\n        {\n            id = d.y;\n            cyc = float(i);\n            break;\n        }\n        if(d.x > 20.){break;}\n        depth += d.x;\n    }\n    depth = (depth > 20.)?-1.:depth;\n    return vec3(depth,id,cyc);\n}\n\n//http://sayachang-bot.hateblo.jp/entry/2019/08/16/215059\nvec3 calcNormal(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n\treturn normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nfloat eq(float a, float b)\n{\n    return 1. - abs(sign(a - b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p.y = -p.y;\n    \n    vec3 f = vec3(1.,0.,0.) * sin(iTime/5. ) * 3.;\n\tvec3 co = vec3(0.,7.5,-55.) + f;\n    \n    co.xz *= rot(iTime/100.);\n    \n    vec3 target = vec3(0.,-50.,0.) + f;\n    \n    target.xy *= rot(iTime/5.);\n    target.z += cos(iTime/10.);\n    \n    vec3 cd = normalize(target - co);\n    vec3 cu = vec3(0.,1.,0.);\n    vec3 cs = normalize(cross(cu , cd));\n    cu = normalize(cross(cs , cd));\n    \n    float fov = (1.-  dot(p,p)/3.);\n    vec3 rd = normalize(vec3(cs * p.x + p.y * cu + fov * cd));\n    \n    vec3 d = marching(co,rd);\n    float rl = (dot(vec3(0.,1.,0.),rd)+1.);\n    float cl = clamp(dot(vec3(0.,1.,0.),cd),0.,1.);\n    vec3 skyColor = vec3(0.05,.4,.2) * rl*cl + cl*rl/2.;\n    vec3 color = skyColor;\n\n    if(d .x> 0.){\n        vec3 N = calcNormal(co + rd * d);\n        float ao = (d.z/100.)*2.;\n        float id = d.y;\n        vec3 sun_dir=normalize(vec3(.8,.4,.2));\n        vec3 mate = eq(id,0.) * vec3(.6,0.,0.) +\n            \t\t \t\t   eq(id,1.) * vec3(0.18);\n        float diff = clamp(dot(N,sun_dir),0.,1.);\n        float shd = step(marching(co + rd *d.x + N* 0.001 , sun_dir).x, 0.);\n      //  float sss = marching(co + rd * d.x * 0.01, sun_dir).x;\n        float sky = (0.5 + 0.5 * dot(N,vec3(0.,1.,0.)),0.,1.);\n        float gro = clamp(0.5 + 0.5 * dot(N , vec3(0.,-1.,0.)),0.,1.);\n        \n        color=mate*vec3(7.,4.5,3.)*diff*shd;\n        color=mate*vec3(.9,.4,.8)*sky;\n       \tcolor+=mate*vec3(.6,.3,.2)*gro;\n       // color += abs(1./sss);\n        color = mix(color,skyColor,ao);\n    }\n    color = pow(color , vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}