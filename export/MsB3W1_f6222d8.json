{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Raymarch Edge Detection by HLorenzi!\n// Detects whether a ray that comes too close to a surface goes away.\n\n#define EDGE_WIDTH 0.5\n#define RAYMARCH_ITERATIONS 40\n\n// The traditional method to finding raymarching edges\n// Of course, mine has a different purpose (to outline in cartoonish style)\n//#define TRADITIONAL\n\n\n\n\n// This should prevent lines from getting thicker when close to the camera\n// But it didn't work. Ugh.\n//#define PERSPECTIVE_FIX\n\n\n\n\n\n// Distance functions by iquilezles.org\nfloat fSubtraction(float a, float b) {return max(-a,b);}\nfloat fIntersection(float d1, float d2) {return max(d1,d2);}\nvoid fUnion(inout float d1, float d2) {d1 = min(d1,d2);}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r;}\n\nfloat distf(vec3 p)\n{\n\tfloat d = 100000.0;\n\t\n\tfUnion(d, pRoundBox(vec3(0,0,10) + p, vec3(11,11,1), 1.0));\n\tfUnion(d, pRoundBox(vec3(0,0,-2) + p, vec3(5,5,12), 1.0));\n\tfUnion(d, pSphere(vec3(10,10,0) + p, 8.0));\n\tfUnion(d, pTorus(vec3(-10,-12,0) + p, vec2(9,5)));\n\tfUnion(d, pCapsule(p, vec3(-15,15,10), vec3(15,-15,-5), 1.5));\n\tfUnion(d, -pSphere(p, 80.0));\n\t\n\treturn d;\n}\n\n\nvec4 raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfloat lastDistEval = 1e10;\n#ifdef TRADITIONAL\n\tfloat edge = 1.0;\n#else\n\tfloat edge = 0.0;\n#endif\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos);\n\t\t\n#ifdef TRADITIONAL\n\t\tif (distEval < minDist) {\n\t\t\tif (i > RAYMARCH_ITERATIONS - 5) edge = 0.0;\n\t\t\t// Probably should put a break here, but it's not working with GL ES...\n\t\t}\n#else\n\t#ifdef PERSPECTIVE_FIX\n\t\t// Could not figure out the math :P\n\t\tif (lastDistEval < (EDGE_WIDTH / dist) * 20.0 && distEval > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t}\n\t#else\n\t\tif (lastDistEval < EDGE_WIDTH && distEval > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t\t// Also should put a break here, but it's not working with GL ES...\n\t\t}\n\t#endif\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n#endif\n\t\t\n\t\tdist += distEval;\n\t\tif (distEval < lastDistEval) lastDistEval = distEval;\n\t}\n\t\n\treturn vec4(dist, 0.0, edge, 0);\n}\n\nvec4 getPixel(vec3 from, vec3 increment)\n{\n\tvec4 c = raymarch(from, increment);\n\treturn mix(vec4(1,1,1,1),vec4(0,0,0,1),c.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// pixel position\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= -iResolution.x/iResolution.y;\n\t\n\t// mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif (iMouse.x == 0.0 && iMouse.y == 0.0) {\n\t\tm = vec2(iTime * 0.06 + 2.86, 0.38);\t\n\t}\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-1.5);\n\n\t// camera position\n\tfloat dist = 50.0;\n\tvec3 ta = vec3(0,0,0);\n\tvec3 ro = vec3(cos(m.x) * cos(m.y) * dist, sin(m.x) * cos(m.y) * dist, sin(m.y) * dist);\n\t\n\t// camera direction\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t// calculate color\n\tvec4 col = getPixel(ro, rd);\n\tfragColor = col;\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsB3W1","date":"1386974403","viewed":6195,"name":"Raymarch Edge Detection","username":"HLorenzi","description":"Raymarch edge detection by checking whether a ray that comes too close to a surface goes away. Will use this in another shader...!","likes":80,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","cartoon","detection","edge","detect","outline","contour","drawing"],"hasliked":0,"parentid":"","parentname":""}}