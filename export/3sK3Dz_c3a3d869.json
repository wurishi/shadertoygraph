{"ver":"0.1","info":{"id":"3sK3Dz","date":"1570029803","viewed":539,"name":"Hallucination","username":"nebbul","description":"A way to move RGB texture samples around in a circle, offset from eachother\n\nwarning! you might feel drunk while watching it in fullscreen","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["chromatic","drunk","hallucination","abberation","dream","confusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Strength 0.003f\n#define Speed 0.6f\n\n#define NoiseTiling 8.0f\n#define NoiseSpeed 0.5f\n\n#define PulseSpeed 2.0f\n#define PulseMin 1.0f\n#define PulseMax 2.0f\n\n#define M_PI 3.1415926535897932384626433832795\n\n//===============================================================================================\n// IQ GRADIENT NOISE FROM HERE: https://www.shadertoy.com/view/4dffRH\n//===============================================================================================\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n//===============================================================================================\n\nvec2 Rotate2dVector(vec2 v, vec2 a) {\n\treturn vec2(a.x*v.x - a.y*v.y, a.y*v.x + a.x*v.y);\n}\n\nfloat Pulse(float t, float noise) {\n    float p = (sin(t * PulseSpeed)+1.)/2.;\n    return (p * (PulseMax - PulseMin) + PulseMin) * noise;\n}\n\nvec2 GetVector(vec2 v, float rad, float noise) {\n    vec2 angle = vec2(cos(rad),sin(rad)); // how much to rotate vector, rotate as a circle\n    angle *= Pulse(rad, noise); // scale the vector by time (this makes a \"flower\" pattern)\n    vec2 v_rot = Rotate2dVector(v, angle);\n    return v_rot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // define the UVs, make them square by using the same iRes dimension\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n    float mixer = 1.;\n    //mixer = 1.-smoothstep(0.,1., (sin(iTime)+2.)/2.-1.)*2.; // uncomment this to animate the effect\n    float shift_amount = mixer * Strength;\n    \n    // rotate the angle of each channel by this amount [radians]\n    // since there are 3 channels, the vector should be rotated 120 degrees per channel eg. 0,120,240\n    float div = M_PI * 2. / 3.;\n    float t = iTime * Speed;\n    float i = mod(div + (t*2.), M_PI*2.0);\n    float j = mod((div * 2.) + (t*2.), M_PI*2.0);\n    float k = mod((div * 3.) + (t*2.), M_PI*2.0);\n    \n   \tvec2 vec = vec2(1.,0.); // initial vector, this is to be rotated like the dial of a clock\n\n    // generate some noise to scale vector\n    vec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y * NoiseTiling;\n    vec4 n = noised(vec3(p.x, p.y, iTime * NoiseSpeed));\n    n.x = (n.x + 1.) / 2.; // normalize 0-1\n    //n.x = pow(n.x, 1.5);\n\n    vec2 v_r = GetVector(vec, i, n.x);\n    vec2 v_g = GetVector(vec, j, n.x);\n    vec2 v_b = GetVector(vec, k, n.x);\n\n    vec2 r_shift = v_r * shift_amount;\n    vec2 g_shift = v_g * shift_amount;\n    vec2 b_shift = v_b * shift_amount;\n\t\n    vec3 clr;\n    clr.r = texture(iChannel0, uv + vec2(r_shift.x, r_shift.y)).r;\n    clr.g = texture(iChannel0, uv + vec2(g_shift.x, g_shift.y)).g;\n   \tclr.b = texture(iChannel0, uv + vec2(b_shift.x, b_shift.y)).b;\n    \n    fragColor = vec4(clr,1.0);   \n}","name":"Image","description":"","type":"image"}]}