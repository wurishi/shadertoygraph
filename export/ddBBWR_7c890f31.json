{"ver":"0.1","info":{"id":"ddBBWR","date":"1699023683","viewed":28,"name":"Symplectic Billiards Phasespace","username":"FLander","description":"This shader computes the periods of all symplectic orbit on a polygon where each pixel corresponds to an initial value of a trajectory.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["geometry","billiards","symplectic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPS = 10e-6;\nconst float INFINITY = 10e10;\n// uniform vec2 VERTICESZERO[100];\n// uniform vec2 DIRECTIONSZERO[100];\n// uniform int nVerticesZero;\n\n// uniform vec2 VERTICESONE[100];\n// uniform vec2 DIRECTIONSONE[100];\n// uniform int nVerticesZero;\n\nconst int width = 500;\nconst int height = 500;\nconst int ITERATIONS = 1000;\n\n\n\n// Quad1\nconst int nVerticesZero = 4;\nconst vec2[nVerticesZero + 1] VERTICESZERO = vec2[](\n    vec2( 0.0, 0.0),\n    vec2( 3.0, 0.0),\n    vec2( 1.0, 2.0),\n    vec2( 0.0, 1.0),\n    vec2( 0.0, 0.0)\n);\n\n// Quad2\nconst int nVerticesOne = 4;\nconst vec2[nVerticesOne+1] VERTICESONE = vec2[](\n    vec2( 0.0, 0.0),\n    vec2( 3.0, 0.0),\n    vec2( 1.0, 2.0),\n    vec2( 0.0, 1.0),\n    vec2( 0.0, 0.0)\n);\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\n// Triangle\nconst int nVerticesZero = 3;\nconst vec2[nVerticesZero + 1] VERTICESZERO = vec2[](\n    vec2( 1.0, 0.0),\n    vec2( 0.0, 1.0),\n    vec2( 0.0, -1.0),\n    vec2( 1.0, 0.0)\n);\n\n// Square\n// Quad2\nconst int nVerticesOne = 4;\nconst vec2[nVerticesOne+1] VERTICESONE = vec2[](\n    vec2( 1.0, 0.0),\n    vec2( 0.0, 1.0),\n    vec2( -1.0, 0.0),\n    vec2( 0.0, -1.0),\n    vec2( 1.0, 0.0)\n);\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n*/\n\n/*\n// Quad1\nconst int nVerticesZero = 6;\nconst vec2[nVerticesZero + 1] VERTICESZERO = vec2[](\n    vec2( 1.0, 0.0),\n    vec2( 0.5, 0.866),\n    vec2(-0.5, 0.866),\n    vec2(-1.0, 0.0),\n    vec2(-0.5, -0.866),\n    vec2( 0.5, -0.866),\n    vec2( 1.0, 0.0)\n);\n\n// Quad2\nconst int nVerticesOne = 6;\nconst vec2[nVerticesOne+1] VERTICESONE = vec2[](\n    vec2( 1.0, 0.0),\n    vec2( 0.5, 0.866),\n    vec2(-0.5, 0.866),\n    vec2(-1.0, 0.0),\n    vec2(-0.5, -0.866),\n    vec2( 0.5, -0.866),\n    vec2( 1.0, 0.0)\n);\n*/\nfloat det(vec2 v, vec2 w){\n    return (v.x * w.y) - (v.y * w.x);\n}\n\nvec2 lineIntersection(vec2 p0, vec2 v0, vec2 p1, vec2 v1) {\n\tvec2 deltaP = p0 - p1;\n\tif (abs(det(normalize(v0), normalize(v1))) < EPS) return vec2(INFINITY);\n\tvec2 t = 1.0 / (v1.x * v0.y - v0.x * v1.y) * vec2(dot(deltaP, vec2(v1.y, -v1.x)), dot(deltaP, vec2(v0.y, -v0.x)));\n\treturn t; // Returns t0 and t1 which both describe the intersecting point p0 + t0*dir0 = p1 + t1*dir1\n}\n\n\nfloat firstIntersectionZero(vec2 p, vec2 dir) {\n\tfloat minDist = INFINITY;\n\tint minIndex = int(INFINITY);\n\tfloat res = 0.0;\n\tfor (int i = 0; i < nVerticesZero; i++)\n\t{\n\t\tvec2 t = lineIntersection(p, dir, VERTICESZERO[i], VERTICESZERO[i+1] - VERTICESZERO[i]);\n\t\tif (EPS < t.x && t.x < minDist &&  EPS < t.y && t.y < 1.0 - EPS) {\n\t\t\t//std::cout << \"At direction \" << i << \" = (\" << directions[i].x << \", \" << directions[i].y << \"), we have t = \" << t.x << \", \" << t.y << \", \" << length(directions[i]) << std::endl;\n\t\t\tminDist = t.x;\n\t\t\tminIndex = i;\n\t\t\tres = float(i) + t.y;\n\t\t}\n\t}\n\treturn res; // Returns the distance from p, i.e. the intersection is at p + minDist*dir\n}\n\nfloat firstIntersectionOne(vec2 p, vec2 dir) {\n\tfloat minDist = INFINITY;\n\tint minIndex =  int(INFINITY);\n\tfloat res = 0.0;\n\tfor (int i = 0; i < nVerticesOne; i++)\n\t{\n\t\tvec2 t = lineIntersection(p, dir, VERTICESONE[i], VERTICESONE[i+1] - VERTICESONE[i]);\n\t\tif (EPS < t.x && t.x < minDist &&  EPS < t.y && t.y < 1.0 - EPS) {\n\t\t\t//std::cout << \"At direction \" << i << \" = (\" << directions[i].x << \", \" << directions[i].y << \"), we have t = \" << t.x << \", \" << t.y << \", \" << length(directions[i]) << std::endl;\n\t\t\tminDist = t.x;\n\t\t\tminIndex = i;\n\t\t\tres = float(i) + t.y;\n\t\t}\n\t}\n\treturn res; // Returns the distance from p, i.e. the intersection is at p + minDist*dir\n}\n \nvec2 direction_on_zero(float t){\n    // Returns the direction of the edge on which t lies on VERTICESZERO. We interpret t by \n    //t = mod(t,float(nVerticesZero)); \n    int index = int(t);\n    return VERTICESZERO[index+1] - VERTICESZERO[index]; //We should definetly precompute the (normalized?) directions beforehand...\n}\nvec2 direction_on_one(float t){\n    // Returns the direction of the edge on which t lies on VERTICESZERO. We interpret t by \n    //t = mod(t,float(nVerticesOne)); \n    int index = int(t);\n    return VERTICESONE[index+1] - VERTICESONE[index]; //We should definetly precompute the (normalized?) directions beforehand...\n}\n\nvec2 PosOnZeroAt(float t){\n    //t = mod(t,float(nVerticesZero)); \n    int i = int(t);\n    return VERTICESZERO[i] + (t - floor(t))*(VERTICESZERO[i+1] - VERTICESZERO[i]);\n}\n\nvec2 PosOnOneAt(float t){\n    //t = mod(t,float(nVerticesOne)); \n    int i = int(t);\n    return VERTICESONE[i] + (t - floor(t))*(VERTICESONE[i+1] - VERTICESONE[i]);\n}\n\nint IterateSymplecticBilliards(vec2 t, int n_iter){\n    // int counter = 0;\n    vec2 nextPos = t;\n    for(int counter = 0; counter < n_iter; counter += 2){\n        \n        // First iteration\n        vec2 dirX = VERTICESZERO[int(floor(nextPos.x))+1] - VERTICESZERO[int(floor(nextPos.x))];\n        vec2 dirY = VERTICESONE[int(floor(nextPos.y)) + 1] - VERTICESONE[int(floor(nextPos.y))];\n        float signf = det(dirX, dirY);\n        if (abs(signf) <  10e-5) return int(INFINITY);\n        vec2 inwardDirY = sign(signf) * dirY;\n        if (sign(signf) == 0.0) return  int(INFINITY);\n        float z = firstIntersectionZero(PosOnZeroAt(nextPos.x), inwardDirY);\n        nextPos.x = nextPos.y;\n        nextPos.y = z;\n        \n        // Second iteration\n        dirX = VERTICESONE[int(floor(nextPos.x))+1] - VERTICESONE[int(floor(nextPos.x))];\n        dirY = VERTICESZERO[int(floor(nextPos.y)) + 1] - VERTICESZERO[int(floor(nextPos.y))];\n        signf = det(dirX, dirY);\n        if (abs(signf) <  10e-5) return  int(INFINITY);\n        inwardDirY = sign(signf) * dirY;\n        if (sign(signf) == 0.0) return  int(INFINITY);\n        z = firstIntersectionOne(PosOnOneAt(nextPos.x),inwardDirY);\n        nextPos.x = nextPos.y;\n        nextPos.y = z;\n        \n        // If periodic quit\n        if(length(t - nextPos) < 0.0001){\n           return counter+2;\n       }\n    }\n    return n_iter;\n}\n\nvec2 pixelToWorld(in vec2 px) {\n    return 2.0 * (px/vec2(iResolution.x)\n        - vec2(0.5, 0.5 * iResolution.y / iResolution.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = vec2((fragCoord.x/iResolution.x) * float(nVerticesZero), (fragCoord.y/iResolution.y) * float(nVerticesOne));\n    int period = IterateSymplecticBilliards(vec2(pos.x, pos.y), ITERATIONS);\n    float scale = float(period)/float(36);\n\tif(period < ITERATIONS)\n    {\n        fragColor = scale*vec4(0.0,0.5,1.0, 1.0);\n    }  else{\n        fragColor = vec4(0.01,0.0,0.0, 1.0);\n    } \n}","name":"Image","description":"","type":"image"}]}