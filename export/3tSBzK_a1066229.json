{"ver":"0.1","info":{"id":"3tSBzK","date":"1599441942","viewed":366,"name":"Candyball","username":"j91000","description":"A simple raymarching engine with phong shading.\nBased on the articles at :https://iquilezles.org/www/index.htm","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//render settings\n#define STEPSHRINK 2.3 //increase this value to deal with distance field domain distortion artifacts\n#define MAXSTEPS 5000\n#define CAMDIST 35.\n#define TARGET vec3(0,0,0);\n#define CAMSTRT vec2(-pi/4.,0.)\n\n#define HITDIST 1.e-1\n#define MAXDIST 1000.\n\n//misc\n#define pi atan(1.0) * 4.0\n#define ZERO min(iFrame,0)\n#define PLANEH -20.\n\n//light and shadow\n#define AMBIENT 0.05 \n#define SUNLIGHT vec3(.7,.6,.5)*3.\n#define SHADQUAL .2\n#define SHADSMOOTH 20.\n#define SPECULARPOWER 5.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 1.85\n#define AOSTEPS 5\n#define AOPOW 1.\n\n\nstruct CastResult\n{\n    vec3 ori;\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\n    \nstruct DirLight\n{\n  \tvec3 dir; //light direction vector\n    vec3 col; //light color*intensity\n};\nstruct MapResult\n{\n    float dist;//distance to scene\n    vec3 color;//surface material color\n    bool volume;//false for the floor, controls coloration in primaryRay()\n};\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n\n//signed distance/material for the floor\nMapResult sdPlane(vec3 pos){\n    return MapResult(pos.y-PLANEH,vec3(.2-length(pos.xz/400.)),false);\n}\n//signed distance/material for the warped ball.\nMapResult sdVBall(vec3 pos){\n    pos=pos*Rotate(sin(iTime/6.)*2.,iTime/5.,0.);\n    pos=pos*Rotate(length(pos.xz)/30.*pi,0.,0.);\n    pos.y+=sin(iTime)*pow(abs(pos.x*pos.z),.6)*sin(length(pos.xz)/30.*pi)/2.;\n    pos.xz*=0.6;//sin(iTime);\n    return MapResult((length(pos)-9.),vec3(.2,.05,.05),true);\n}\n\nMapResult sdUnion(MapResult a,MapResult b){\n    if(a.dist<b.dist){return a;}\n    return b;\n}\n//calculate the distance to scene/ material properties of closest object\nMapResult map(vec3 pos){\n    MapResult plane=sdPlane(pos);\n    MapResult result=sdVBall(pos);\n    result=sdUnion(result,plane);\n    return result;\n}\n//same as map, but throw away everything but distance\nfloat distToScene(vec3 pos){\n return map(pos).dist;   \n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*distToScene(pos+0.00005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=0.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*sampleDist-distToScene(pos+normal*sampleDist*itC);\n        occlusion+=1./pow(2.,itC)*term;\n    }\n    return 1.-clamp(AOPOW*occlusion/sampleDist,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*2.;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        MapResult localState=map(rayPos);\n        float dts=localState.dist;\t//calculate distance to scene\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));//if close to a surfce, cast a penumbra\n        rayPos-=sun.dir*dts/STEPSHRINK*SHADQUAL;//march\n    }\n    result=hit ? 0.:result; //if you registered a hit, then no light for you!\n    return result; //otherwise return the darkest penumbra you encountered\n}\n\nCastResult primaryRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    MapResult localState;\n    for(int steps=ZERO;steps<MAXSTEPS&&hit==false&&length(rayPos-rayOri)<MAXDIST;steps++){\n        localState=map(rayPos);//calculate distance to scene\n        float dts=localState.dist;\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=rayVec*dts/STEPSHRINK;//march the ray\n    }\n    vec3 norm=calcNorm(rayPos);\n    //these lines just modulate the coloring of the ball based\n    //on the surface characteristics reported by ambientOcclusion()\n    vec3 surfCol=localState.color;\n    if(localState.volume){//if not hitting the floor\n    float aO=ambientOcclusion(rayPos,norm,-2.);\n    float thresh=.6;\n    surfCol*=pow(vec3(1.-(aO-thresh)/1.),vec3(2.,4.,4.));\n    }\n    //now set the material to 0. if we never hit anything\n    surfCol=(length(rayPos-rayOri)>=MAXDIST)? vec3(.0): surfCol;\n    return CastResult(rayOri,rayPos,norm,surfCol);\n}\n\n\n//calculate the light hitting this castResult from sun and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    float difLight=max(0.,(-dot(hit.norm,sun.dir)));\n    #ifdef SPECULARPOWER //if SPECULARPOWER is commented out, lighting is diffuse only\n    float specLight=SPECULARPOWER*\n        pow(max(0.,dot(reflect(sun.dir,hit.norm),normalize(hit.ori-hit.pos))),200.);\n    vec3 sunLight=(difLight+specLight)*sun.col*occlusion(hit,sun);\n    #else\n    vec3 sunLight=(difLight)*sun.col*occlusion(hit,sun);\n    #endif\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm,AODIST));\n    return (sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=(length(iMouse.xy)>0.)? iMouse.xy/iResolution.xy-.5:CAMSTRT;\n    float mouseTheta=mousePos.x*2.*pi;\n    float mouseH=mousePos.y*60.+19.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=TARGET;\n    \n//set up lighting\n    DirLight sun;\n    sun.dir=normalize(vec3(1,-3,0.))*Rotate(vec3(10./5.,0,0));\n    sun.col=SUNLIGHT;\n    \n//set up camera ray\n//\n//in the middle of the screen, uv.xy ==(0,0),\n//so the rotation matrix that rotates (0,0,1) to normalize(camTarget-camPos)\n//will point our rays towards camTarget\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    \n    \n    \n    vec3 rayOri=camPos;\n\n    CastResult cRay=primaryRay(rayOri,rayVec);\n    \n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n    vec3 finalC=inBounds?lightOn(cRay,sun)*cRay.surf:vec3(0.);\n    finalC=pow(finalC,vec3(1./2.2));//GAMMA CORRECT\n    fragColor = vec4(finalC,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}