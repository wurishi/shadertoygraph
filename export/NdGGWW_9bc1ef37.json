{"ver":"0.1","info":{"id":"NdGGWW","date":"1631522512","viewed":110,"name":"project stochastics round 4","username":"Dusty","description":"exploring what it can do .. a skysphere with \"realistic\" clouds keyed by time of day (seconds) - I guess everyone in a timezone sees more or less the same thing when viewing at the same time","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------------------\n// project stochastics round 4\n//\n// continuing goal: \n//\n//   approximate an ideal noise function,\n//   that reveals no visual correlations,\n//   when sampled at regular intervals,\n//   everywhere!\n//\n//   efficiency is still of only secondary consideration\n//\n// continual refinement\n//\n// riffle() and shuffle(), as a \"stochastics api\", are possibly set in stone now\n//\n// in some disciplines, shuffle() would be named hash(), but I'm not leaving the \n// shuffling roots of this, because it really is shuffling all the way down.\n//\n\nuint riffle(in uint h)                  { h *= 0xCC2BFE9Du; h ^= (h >> 16); return h; }\n\n // the default key used for the final riffle round\nconst uint defkey = 0x8675309u;\n\n// shuffles using 1 to 4 shuffle keys\nuint shuffle(in uint h, in uint k)      { return riffle( riffle(h + k) + defkey ); }\nuint shuffle(in uint h, in uvec2 k)     { return shuffle( riffle(h + k.y), k.x ); }\nuint shuffle(in uint h, in uvec3 k)     { return shuffle( riffle(h + k.z), k.xy ); }\nuint shuffle(in uint h, in uvec4 k)     { return shuffle( riffle(h + k.w), k.xyz ); }\n\n// of course simple accessors for floating point keys\nuint shuffle(in uint h, in float k)     { return shuffle( h, floatBitsToUint(k) ); }\nuint shuffle(in uint h, in vec2 k)      { return shuffle( h, floatBitsToUint(k) ); }\nuint shuffle(in uint h, in vec3 k)      { return shuffle( h, floatBitsToUint(k) ); }\nuint shuffle(in uint h, in vec4 k)      { return shuffle( h, floatBitsToUint(k) ); }\n\n// generating a uniform scaler between 0.0 <= x < 1.0    (1.0 is unachievium as it should be)\nfloat pointnoise(in uint h, in float k)  { return exp2(-32.0) * float(shuffle(h,k)); }\nfloat pointnoise(in uint h, in vec2 k)  { return exp2(-32.0) * float(shuffle(h,k)); }\nfloat pointnoise(in uint h, in vec3 k)  { return exp2(-32.0) * float(shuffle(h,k)); }\nfloat pointnoise(in uint h, in vec4 k)  { return exp2(-32.0) * float(shuffle(h,k)); }\n\n// below this point is still just some testing shit\n\nconst float artin = 0.37395581361920228805;\nconst float phi   = 1.61803398874989484820;\nconst float pi    = 3.14159265358979323846;\n\n// cell noise, cosine interpolated, tentative\nfloat cellnoise(in uint h, in vec4 k)\n{\n  vec4 i = floor(k), f = (0.5 - 0.5*cos(pi*fract(k)));\n  return mix(mix(mix(mix(pointnoise(h, i + vec4(0,0,0,0)), \n                         pointnoise(h, i + vec4(0,0,0,1)), f.w),\n                     mix(pointnoise(h, i + vec4(0,0,1,0)), \n                         pointnoise(h, i + vec4(0,0,1,1)), f.w), f.z),\n                 mix(mix(pointnoise(h, i + vec4(0,1,0,0)), \n                         pointnoise(h, i + vec4(0,1,0,1)), f.w),\n                     mix(pointnoise(h, i + vec4(0,1,1,0)), \n                         pointnoise(h, i + vec4(0,1,1,1)), f.w), f.z), f.y),\n             mix(mix(mix(pointnoise(h, i + vec4(1,0,0,0)), \n                         pointnoise(h, i + vec4(1,0,0,1)), f.w),\n                     mix(pointnoise(h, i + vec4(1,0,1,0)), \n                         pointnoise(h, i + vec4(1,0,1,1)), f.w), f.z),\n                 mix(mix(pointnoise(h, i + vec4(1,1,0,0)), \n                         pointnoise(h, i + vec4(1,1,0,1)), f.w),\n                     mix(pointnoise(h, i + vec4(1,1,1,0)), \n                         pointnoise(h, i + vec4(1,1,1,1)), f.w), f.z), f.y), f.x);  \n}\n\n// quick and dirty 3D rotation by angle (a) around axis of rotation (u)\n#define ROT(a, u) mat3( vec3( cos(a) + u.x*u.x*(1.0-cos(a)),     u.y*u.x*(1.0-cos(a)) + u.z*sin(a), u.z*u.x*(1.0-cos(a)) - u.y*sin(a)), \\\n                        vec3( u.x*u.y*(1.0-cos(a)) - u.z*sin(a), cos(a) + u.y*u.y*(1.0-cos(a)),     u.z*u.y*(1.0-cos(a)) + u.x*sin(a)), \\\n                        vec3( u.x*u.z*(1.0-cos(a)) + u.y*sin(a), u.y*u.z*(1.0-cos(a)) - u.x*sin(a), cos(a) + u.z*u.z*(1.0-cos(a))) )\n\n// brownish really (artin bad for brown good for efficiency)\nfloat brownnoise(in uint h, in vec4 k, in int steps)\n{\n  float c = 0.6667 * cellnoise(h, k); \n  for(int i = 1; i < steps; i++)\n    {\n      k.xyz *= ROT(3.88322207745, normalize(vec3(2.0, 3.0, 5.0)));\n      c += 0.5 * (cellnoise(h + uint(i), k *= artin) - c);\n    }\n  return c;\n}\n\n// the opposite of smooth\n#define rough(x)    (0.5 - sin(asin(1.0 - 2.0 * x) / 3.0))\n\n// generate some \"realistic\" looking cloudy sky\nvec3 skysphere(in float radius, in vec3 ray, in float t)\n{\n  vec3 key = radius * normalize(ray) * vec3(1,pi,1);\n\n  float c = rough(brownnoise(0u, vec4(key.xyz, t), 6));  \n  for(int i=1; i<6; i++)\n     c = max(c, rough(brownnoise(uint(i), vec4(key.xyz, t += (1.0/6.0)), 6))); \n  c = max(c - 0.6, 0.0); c *= 2.5; c += 1.0; c *= 0.5;\n  return vec3(c*c,c,sqrt(c));\n}\n\n// \"I need a distraction and an eyeball.\" - Hawkeye\nvec3 cameraRay(in vec3 up, in vec3 position, in vec3 lookat)\n{\n  vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / (0.5 * (iResolution.x + iResolution.y));\n  vec3 zaxis = normalize(lookat - position);\n  vec3 xaxis = normalize(cross(up, zaxis));\n  mat3 cam = mat3(xaxis, normalize(cross(zaxis, xaxis)), zaxis);\n  return cam * vec3(uv, 1.0);\n}\n\nvec3 lookat(in float t)\n{\n  return vec3( sin(0.04 * t), 0.0, cos(0.04 * t) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 ray = cameraRay(vec3(0,1,0), vec3(0), lookat(iDate.w));\n  fragColor = vec4(skysphere(128.0, ray, pi * iDate.w), 1);\n}","name":"Image","description":"","type":"image"}]}