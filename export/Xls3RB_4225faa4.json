{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define REFRACTION_INDEX 0.75\n#define PI 3.14159265\n//-----------------------------\n#define time iTime\n#define EPSILON .001\n\nconst int MAX_ITER = 230;\nbool bShadow        = true;\nbool transparentObject = true;    \nvec3 lightDir       = normalize(vec3(1.46, -0.37, 1.42)); \n\nvec3 camPos = vec3(15.0, -25.0, 200.0);\nvec3 camDir = vec3(0.0, 0.0, -1.0);\nvec3 camUp  = vec3(0.0, 1.0, 0.0);\nvec3 colSky = vec3(1.);\nstruct mat\n{\n  float typeMat;        // Ñ‚Ð¸Ð¿ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð° \n  float koffReflecr;    // ÐºÐ¾ÑÑ„Ñ„Ð¸Ñ†Ð¸ÐµÐ½Ñ‚ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ ÑÑ†ÐµÐ½Ñ‹\n  bool  speculat;       // Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑ‚Ð°\n  bool  transparent;    // Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¹ Ð¾Ð±ÑŠÐµÐºÑ‚\n  vec4  color;          // Ñ†Ð²ÐµÑ‚ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\n     \n};\nmat materialMy = mat(0.0, 0.0, false, false, vec4(1.));\n\n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir);\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor);\nvec4 transparency(in vec3 posOnRay, in vec3 rayDir,in vec3 normal,  inout vec4 color);\n//----------------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//----------------------------------------------------\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n//--------------------------------------------------\nfloat capsuleZ(vec3 p, float r, float h)\n{\n    p.z -= clamp(p.z, 0.0, h);\n    return length(p) - r;\n}\n//----------------------------------------------------\nfloat pRoundBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n//----------------------------------------------------\nfloat zCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------\nfloat yCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n//----------------------------------------------------\nfloat dSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------\nfloat pTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//--------------------------------------------------\nfloat yCone( in vec3 p, in vec2 h, in float plane )\n{\n\n    p.y = - p.y;\n    vec2 c = normalize( h );\n    float q = length(p.xz);\n    float t = max( dot(c,vec2(q,p.y)), -(p.y +  h.x) );\n\n  //  t = max(t, -(-p.y - plane));\n    return t;\n}\n//--------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n//------------------------------------------\nvec2 rot(vec2 p,float r){\n  vec2 ret;\n  ret.x=p.x*cos(r)-p.y*sin(r);\n  ret.y=p.x*sin(r)+p.y*cos(r);\n  return ret;\n}\n//------------------------------------------\nvec2 rotsim(vec2 p,float s)\n{\n  vec2 ret=p;\n  ret=rot(p,-PI/(s*2.0));\n  ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n  return ret;\n}\n//------------------------------------------\nvec2 rotate(vec2 v, float a) \n{\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n//-------------------------------------------\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) \n{\n   float sh = 1.0;\n   float t = mint;\n   float h = 0.0;\n   for (int i = 0; i < 10; i++) {\n      if(t > maxt)\n         continue;\n      h = renderFunction(ro+rd*t);\n      sh = min(sh, k*h/t);\n      t += h;\n   }\n   return sh;\n}\n//---------------------------------------------\n// ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ð° Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\nfloat distMat(inout float curDist, float dist, in float typeMat, in float typeRafl, bool typeSpecular, bool typeTransp )\n{\n   float res = curDist;\n   if (dist < curDist) \n   {\n      materialMy.typeMat     = typeMat;\n      materialMy.koffReflecr = typeRafl;\n      materialMy.speculat    = typeSpecular;\n      materialMy.transparent = typeTransp;\n      res                    = dist;\n     return res;\n   }\n   return curDist;\n}\n//--------------------------------------------------\nfloat noise( in vec2 x) \n{\n   vec2 f = fract(x);\n   vec2 uv = floor(x) + f.xy*f.xy*(3.0-2.0*f.xy);\n   return -1.0 + 2.0*texture( iChannel1, (uv+0.5)/256.0, -100.0 ).x;\n}\n//--------------------------------------------------\n// ÐžÐ±ÑŠÐµÐºÑ‚Ñ‹\n//--------------------------------------------------Ð—ÐµÐ¼Ð»Ñ\nfloat land(in vec3 p)\n{\n    p.y = -p.y;\n    float h = 4.33 + 2.*cos(.1*length(p))-(1.6-1.6*cos(p.x * 0.25)*cos(p.z  * 0.18))+.006*noise(p.zx*35.); // very regular patern + a little bit of noise\n    float d = (p.y - h);\n    return d;\n}\n//--------------------------------------------------Ð˜Ð³Ð»Ñƒ\nfloat igloo(in vec3 p)\n{\n   \n   vec3 pos = p;\n   pos.xz=rotsim(pos.xz,12.);\n   pos.yz=rotsim(pos.yz,12.);    \n   pos.z-= 19.6; \n   float iglu = pRoundBox(pos,vec3(2.1, 2.3, 1.) , .3);\n  //Ð’Ñ…Ð¾Ð´\n   pos = p;\n   pos.xy=rotsim(pos.xy,8.);\n   pos.z-= 21.85; \n   iglu = min(iglu, pRoundBox(pos,vec3(1.0, 9., 5.) , .5));\n   iglu = max(iglu, -dSphere(p * vec3(1., 1., -0.5) + vec3(0., -0.5, 10.26), 8.));\n\n//   iglu = max(iglu, -zCylinder(p + vec3(0., -15., 0.), vec2 (36., 10)));   \n return iglu;\n}\n//---------------------------------------------------ÐŸÐ»Ð°Ñ‰\nfloat coat(in vec3 p)\n{\n  float d = 1.0;\n  float of = 0.008;// *noise(p.xy * 34.);\n   d = yCone( p * vec3(0.84, 1., 0.86) , vec2(16., 5.) + of, 4.5 );\n  // ÐšÐ°Ð¿ÑŽÑˆÐ¾Ð½\n   float hood = dSphere(p * vec3(0.6, 0.54, 0.7)  + vec3(0., -.34, 0.), 2.5 + of);\n   hood = max(hood, -dSphere(p * vec3(.6, .56, -0.28) + vec3(0., -0.56, 1.4), 2.));\n  // Ð ÑƒÐºÐ¸ hands\n  p.x = abs(p.x);  \n     p.xy = rotate(p.xy, -0.61); \n  float hands = (capsuleY( p + vec3(1.22, -7.18, 0.), 1.1 + of,4.6 ));  \n  d = smin( d, hands, 0.5); // Ð ÑƒÐºÐ¸\n  d = min(d, hood);         // ÐšÐ°Ð¿ÑŽÑˆÐ¾Ð½  \n  return d;    \n}\n//---------------------------------------------------ÐžÐ¿ÑƒÑˆÐºÐ°\nfloat edge(in vec3 p)\n{\n  float d = 1.0;\n  vec3 pos = p;\n  float of = 0.1;// *noise(pos.xz * 56.);\n  pos.x = abs(pos.x);  \n     pos.xy = rotate(pos.xy, -0.61); \n //ÐžÐ¿ÑƒÑˆÐºÐ°\n d =  pTorus(pos + vec3(1.24, -11.5, 0.),  vec2(1., 0.9) + of);\n d = min(d, pTorus(p + vec3(0., -15.38, 0.), vec2(5.97, 0.9)) + of);\n d = min(d, pTorus(p + vec3(0., -5.55, 0.),  vec2(2.5, 0.9)) + of);\n pos = p;\n pos.x = abs(pos.x); \n    pos.yz = rotate(pos.yz, 0.36); \n d = smin(d, capsuleY( pos + vec3(-0.6, -6., -0.14), 0.65  + of,9.5 ), 0.5);\n pos = p;\n    pos.yz = rotate(pos.yz, 1.57);   \n d = smin(d,  pTorus(pos  * vec3(1., 1.14, 0.88) + vec3(-0.28, -3.13, 0.68),  vec2(3.28, 0.9) + of), 0.5);  \n \n return d;\n}\n//---------------------------------------------------ÐžÐ±ÑƒÐ²ÑŒ  \nfloat shoes(in vec3 p)\n{\n  float d = 1.0;\n  vec3 pAbs = p;\n  pAbs.x = abs(pAbs.x); \n  d = capsuleY( pAbs + vec3(-1., -13.8, 0.), 1. ,4.5 ); \n  d = smin(d, dSphere(pAbs * vec3(1.2, 1.86, 0.9) + vec3(-1., -34.6, -1.1), 1.45),0.5);    \n\n  return d;  \n}\n//---------------------------------------------------Ð“Ð¾Ð»Ð¾Ð²Ð°\nfloat head(in vec3 p)\n{\n  float d = 1.0;  \n  vec3 pAbs = p;\n  pAbs.x= abs(pAbs.x);\n  d = dSphere(p  + vec3(0., -0.36, 0.), 3.5);\n  d = smin(d, capsuleZ(p  + vec3(0., -1.08, -3.88),0.5, 0.2), 0.5);\n  d = max(d, -dSphere(pAbs * vec3(0.5, 2., 1.) + vec3(-0.72, -0.16, -3.), 0.74));\n  \n  return d;    \n}\n//---------------------------------------------------\nfloat myObject(in vec3 p)\n{\n\n   float d =  1.0;\n   materialMy.typeMat = 0.0;\n   materialMy.koffReflecr = 0.;\n   materialMy.speculat    = false; \n   materialMy.transparent = false;\n\n   vec3 p1  = p;\n   vec3 pos = p1;\n   float l = land(p + vec3(0.0, -4.58, 0.0));// Ð—ÐµÐ¼Ð»Ñ\n   l = max(l, -zCylinder(p + vec3(12., -2.5, 10), vec2 (21.0, 5.0)));\n   d =  distMat(d,  l,  3.0, 0.0, true, false); \n\n    //----------------------\n if(transparentObject)\n {// Ð˜Ð³Ð»Ñƒ\n   pos += vec3( 12., 1.6, 10.);\n   float iglu = igloo(pos);\n   d = distMat(d,   iglu,  2.0, 0.0, true, true);  \n   d = smin( d, iglu, 0.5);\n }\n\n\n//----------------------\n//Ð§ÐµÐ»Ð¾Ð²ÐµÐº\n  pos = p1;\n  pos += vec3(-18.4, 16., -10.4);\n  float men = coat(pos);\n  d = distMat(d, men,  4.0, 0.0, false, false);   \n  d = distMat(d, edge(pos),  3.0, 0.0, false, false);     \n//  float sh = shoes(pos);\n//  d = distMat(d, sh,  1.0, 0.0, false, false);  \n//  d = smin( d, sh, 0.5); \n  d = distMat(d, head(pos),  6.0, 0.0, false, false);  \n  vec3 pAbs = pos;\n  pAbs.x= abs(pAbs.x);  \n  float eye = dSphere(pAbs * vec3(0.75, 1., 1.) + vec3(-1., -0.12, -3.), 0.4);  \n  d = distMat(d, eye,  13.0, 0.0, false, false); \n  float mouth = pTorus(pos.yzx   + vec3(-1.35, -2.84, 0.),  vec2(0.88, 0.22));\n  d = distMat(d, mouth,  7.0, 0.0, false, false); \n //----------------------\n\nreturn d; \n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nfloat renderFunction(in vec3 pos)\n{\n    return  myObject(pos);    \n}\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n  const float e = 0.0001;\n \n  vec3 n = vec3((renderFunction(vec3(p.x - e,p.y,p.z)) - renderFunction(vec3(p.x+ e,p.y,p.z))),\n                (renderFunction(vec3(p.x,p.y - e,p.z)) - renderFunction(vec3(p.x,p.y+ e,p.z))),\n                (renderFunction(vec3(p.x,p.y,p.z - e)) - renderFunction(vec3(p.x,p.y,p.z+ e))));\n  return normalize( n );\n}\n//----------------------------------------------------------------------\nvec3 Sky(vec3 pos)\n{\n   vec3 color = vec3(1.);\n   float v,t=v=.0005;\n   for (float s=.0; s<2.; s+=.05) \n   {\n     vec3 p = pos;\n       p =  p * t + vec3(0.01, 0.2,fract(s+floor(time *20.)* 0.0001));\n\n     for (int i=0; i<8; i++) \n         p=abs(p )/dot(p,p)- 0.8; \n      v += dot(p,p)*t;\n   }\n   color = vec3(v * cos(time * .3), v *sin(time * 1.5), v * 3.0);\n   return color;\n \n}\n//----------------------------------------------------------------------\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor)\n{\n\n  vec4 color = vec4(1.);\n  vec3 hitPos = ro + rd * dist;\n  vec3 lightPos1 = normalize(lightDir);  \n  normal = normalize(getNormal(hitPos));  \n  float diffuse = max(0.0, dot(normal, -lightPos1)) * 0.5 + 0.5;\n \n  float specular = 0.0;   \n  if(materialMy.speculat)\n  { \n      if (dot(normal, -lightPos1) < 0.0) \n         specular = 0.0;\n      else \n         specular = pow(max(0.0, dot(reflect(-lightPos1, normal), normalize(ro - hitPos))), 5.0);\n   }\n   colSky = Sky(hitPos) * sin(time * 0.1 ); // Ð¦Ð²ÐµÑ‚ Ð½ÐµÐ±Ð°\n   if(colSky.b < 0.5 )colSky.b = 0.5;\n//----------------------------------\n   if (materialMy.typeMat == 0.0) // Ð¦Ð²ÐµÑ‚ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ\n  {\n     color =  texture(iChannel0, -hitPos.xyz);//vec4(colSky, 1.0);\n         color.rgb += colSky;\n     diffuse = 1.0;\n   } \n   else if (materialMy.typeMat == 1.0) // Ð¦Ð²ÐµÑ‚ ÑÐ°Ð¿Ð¾Ð³\n      color = vec4(0.68, 0.67, 0.21, 1.); \n   else if (materialMy.typeMat == 2.0) // Ð¦Ð²ÐµÑ‚ Ð¸Ð³Ð»Ñƒ\n   {\n      color = vec4(0.47, 0.82, 1., 0.4);\n         color.rgb += colSky;\n   }\n  \n   else if(materialMy.typeMat == 3.0) // Ð¦Ð²ÐµÑ‚ ÑÐ½ÐµÐ³Ð°\n   {\n      color =   vec4(1.); \n         color.rgb += colSky;\n   }\n   else if(materialMy.typeMat == 4.0)  // Ð¦Ð²ÐµÑ‚ Ð¾Ð´ÐµÐ¶Ð´Ñ‹\n   {\n      color = vec4(0.45, 1., 0.95, 1.);\n         color.rgb += colSky;      \n   } \n   else if(materialMy.typeMat == 6.0)  // Ð¦Ð²ÐµÑ‚ Ð³Ð¾Ð»Ð¾Ð²Ñ‹\n      color =  vec4(1.0, 0.96, 0.86, 1.);  \n   else if(materialMy.typeMat == 7.0)  // Ð¦Ð²ÐµÑ‚ Ð³Ð¾Ð»Ð¾Ð²Ñ‹\n      color =  vec4(1.0, 0.3, 0.0, 1.);       \n   else      \n    color = vec4(0.5); \n    ro = hitPos;\n  vec4 finalColor = (vec4( color.rgb * diffuse, color.a) + specular) ;\n  return finalColor ;\n}\n//-------------------------------------------------Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ†Ð²ÐµÑ‚ ÑÑ†ÐµÐ½Ñ‹ Ñ Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¼ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð¼\nvec4 transparency(in vec3 posOnRay, in vec3 rayDir, in vec3 normal,  inout vec4 color)\n{ \n  float path = 1.0; \n  vec3 nrd = normalize(refract(rayDir, -normal, REFRACTION_INDEX));\n  if (nrd.x == 0.0 && nrd.y == 0.0 && nrd.z == 0.0) \n         nrd = normalize(reflect(rayDir, normal));\n  transparentObject = false;\n  vec3 newRo = posOnRay + nrd * 0.2;      \n  path = render(newRo, nrd); \n  vec4 color1 = getColorPixel(newRo, nrd, normal, path, materialMy.typeMat);       \n  float sh = 1.0;\n  if(bShadow)\n        sh = softshadow(newRo, lightDir, 0.2, 20.0, 7.0); \n  color1 *= sh;\n  color = mix(color1,color,color.a);  \n  return color;\n}\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\n    float maxDist = 250.;\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n    float d = renderFunction(posOnRay + t*rayDir); \n    if (abs(d) <EPSILON || t > maxDist) \n         break;\n    t += d;\n  }\n   return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n  pos.x *= iResolution.x / iResolution.y;\n    // pos.x        = -pos.x;\n  pos = - pos;  \n  vec3 camSide  = cross(camDir, camUp);\n//  vec3 rayDir   = normalize(camSide*pos.x + camUp*pos.y + camDir);\nvec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + 4.*camDir);\n  vec4 color    = vec4(1.0);\n  vec3 normal   = vec3(1.0);\n  vec4 result_color = vec4(0.5);\n//------------------------------\n   float t = time* 0.3;\n   float angle = sin(5. + 0.8 *t);\n\n    vec3 ro = vec3(camPos.x * sin(-angle),camPos.y, camPos.z* cos(-angle));\n   \n  vec3 posOnRay = ro;//camPos;\n  float path = 0.;\n  float sh  = 1.0;\n  //--------------------------- \n     transparentObject = true;\n     path =  render(posOnRay, rayDir);  \n\n     color = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n     if(materialMy.transparent && color.a < 1.0) // ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹\n          transparency(posOnRay, rayDir, normal,color);\n     if(bShadow) \n          sh = softshadow(posOnRay, lightDir, 0.2, 20.0, 7.0); \n     color *= sh;\n     fragColor =  color;\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xls3RB","date":"1423212607","viewed":234,"name":"night in the north","username":"Lio","description":"Just exeperimental :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","transparency","refract"],"hasliked":0,"parentid":"","parentname":""}}