{"ver":"0.1","info":{"id":"3stfWn","date":"1605115446","viewed":218,"name":"Desert Jfig 2020","username":"ThibaultTricard","description":"Shadertoy implementation of Procedural Phasor Noise used as bump to reproduce the surface of a desert.\nThis work is based uppon the shader Rolling hills by David Hoskins : https://www.shadertoy.com/view/Xsf3zX .\n\n\n\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["jfigcontest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define JFIGW 32u\n#define JFIGH 18u\n\n#define storm true\n\n#define logo true\n\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\n\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 c  = texture(iChannel0, uv);\n    \n   \n    \n    float n =1.0;\n    if(storm)\n    for(int i = 0; i < 20; i++){\n        vec2 v = vec2(-1.0 + float(i)/10.0 ,1.0);\n        v = normalize(v);\n    \tfloat n1  = texture(iChannel1, uv * iResolution.xy/120.0 + v * iTime*10.0).x;\n    \n    \tif(n1 < 0.9){\n        \tn1 =1.0;\n    \t}\n        n = n * n1;\n    }\n    \n    c = c*n;\n    \n    vec4 jfigcolor = vec4(1.0);\n    \n    vec2 coord = fragCoord/iResolution.xy*vec2(JFIGW, JFIGH);\n    int sandstep = 60;\n    if(jfig(uint(coord.x), uint(coord.y) )&& logo){\n        float jfig_noise = 0.0;\n        vec2 shift = vec2(630,42);\n        for(int i = 0; i < sandstep; i++){\n        \t\n    \t\tfloat n1  = texture(iChannel2, uv* iResolution.xy/120.0 + float(i) * shift).x *0.1;\n\t\t\t\n            n1 = n1 * max( ( (5.0 - iTime + fragCoord.x/ iResolution.x *6.0) * float(i) / 5.0 ) ,0.0);\n            \n            if(n1 >0.2){\n            \tjfig_noise += 1.0; \n            }\n    \t\t\n        \n    \t}\n        float fact = min(jfig_noise/float(sandstep),1.0);\n        if(fact >0.1){\n         \tc = jfigcolor;\n        }\n    }\n    fragColor = vec4(c);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int   MaxInt = 2147483647; // 2^31 - 1\nvec3  Vup = vec3(0.0,0.0,1.0) ;\n\n#define M_PI   3.1415926535897932385\n\nfloat  _a            = 4.0;\nfloat  _F_0          = 10.0;\nfloat  _base_F       = 0.05;\nfloat  _omega_0      = -0.4;\nfloat  _omega_w      = 0.0;\nfloat  _K            = 1.0;\nint    Seed          = 63;\n\nconst int ImpPerKernel  = 15;\n\nuniform sampler3D _o;\nuniform sampler3D _ratio;\nuniform sampler3D _oB;\n\n//-----------------------------------------------------------------------------\n\nint hash_linear(ivec4 ijkl)\n{\n  return (ijkl.x + (ijkl.y << 10) + (ijkl.z << 20));\n}\n\n//-----------------------------------------------------------------------------\n\nint hash(ivec2 ij)\n{\n  return hash_linear( ij.xyxy );\n}\n\nint hash3(ivec3 ijk)\n{\n  return hash_linear( ijk.xyzx );\n}\n\nconst int MaxHash = MaxInt;\n\n//-----------------------------------------------------------------------------\n\nfloat drand(int r, out int _r)\n{\n  _r = r * 3039177861;\n  return float(_r & MaxInt) / float(MaxInt);\n}\n\n//-----------------------------------------------------------------------------\n\nconst float truncate = 0.05;\n\nfloat kernelRadius(float ka)\n{\n  return (sqrt( - log( truncate ) / M_PI ) / float(ka));\n}\n\n// -----------------------------------------------------\n\nfloat current_sum_cos = 0.0;\nfloat current_sum_sin = 0.0;\n\n// -----------------------------------------------------\n\nfloat gaussian(vec2 uv, float K, float a)\n{\n  // gaussian\n  float lsq = dot(uv, uv);\n  float e = exp(-M_PI * (a*a) * lsq);\n  float g = (K * e);\n  return g;\n}\n\nvec2 gabor(vec2 uv, float f0, float o0, float K, float a,float ph)\n{\n  // gaussian\n  float lsq = dot(uv, uv);\n  float e = exp(-M_PI * (a*a) * lsq);\n  float g = (K * e);\n  // sinewave\n  vec2  dir = vec2(cos(o0), sin(o0));\n  float s = sin(2.0 * M_PI * f0 * dot(uv, dir) + ph);\n  return vec2(s * g, g);\n}\n\n//-----------------------------------------------------------------------------\n \nfloat sampleCellSrf(\n  ivec3 ijk, vec3 uvw,\n  vec3  wu, vec3 wv, vec3  wn,\n  float base_f, float f0, float o0, float ow, float K, float a, float kr)\n{  \n\n  // init random number generator \n  int   h = 1 + hash3(ijk);\n  int rnd = Seed + h;\n  \n  float s = 0.0;\n    \n  vec3  cellsz = vec3(2.0*kr);\n  \n  int   N = ImpPerKernel;\n  for (int nIter = 0; nIter < N; nIter++) {\n    \n    float rx = drand(rnd, rnd);\n    float ry = drand(rnd, rnd);\n    float rz = drand(rnd, rnd);\n\n    vec3 ctr3 = vec3(rx, ry, rz);\n\n    // project\n    vec3   v = (uvw - ctr3) * cellsz;  \n    vec3 cuv =  (vec3(ijk) + ctr3) *cellsz;\n    vec2   d = vec2(dot(v, wu), dot(v, wv));\n    vec2   k = vec2(0.0,0.0);\n\n    vec3  wctr     = (vec3(ijk) + ctr3);\n    vec2  plane_uv = vec2(dot(wctr, wu), dot(wctr, wv)) * cellsz.xy;\n\n    // randomize orientation?\n    // float o = atan(plane_uv.y,plane_uv.x);\n    float o;\n    if (true) {\n      float ur = drand(rnd, rnd);\n      float o1 = o0 - ow;\n      float o2 = o0 + ow;\n      o = o1 + ur * (o2 - o1);\n    }\n    \n    if (dot(v, v) < kr*kr*2.0) {\n\n      // compute phase\n      vec2  dir      = vec2(cos(o), sin(o));\n      // frequency and phase shift due to angle\n      float freq_o = f0 * dir.x;\n      float ph_o   = dir.y * d.y * 2.0 * M_PI * f0;\n      float phase  = mod( - plane_uv.x * 2.0 * M_PI * base_f, 2.0 * M_PI);\n      // tweak phase to match main sine frequency\n      // sin(2.0 * M_PI * f * x + ph)\n      phase   += ph_o + 2.0 * M_PI * (freq_o - base_f) * d.x;\n\n      float  z = max(0.0, 1.0 - abs(dot(v, wn) / kr));\n\n      // k        = z * gabor(d, freq_o, 0.0, K, a, ph_o);\n\n      float  i = z * gaussian(d,K,a);\n      current_sum_cos += i * cos(phase);\n      current_sum_sin += i * sin(phase);\n\n    }\n\n    s += k.x;\n  }\n  return s;\n}\n\n// ---------------------------------------------------------------\n\nfloat squaredWave(float x,float r){\n  if(mod(x,2.0*M_PI) > r*2.0*M_PI)\n  {\n    return 1.0 ;\n  }\n  else\n  {\n    return -1.0;\n  }\n}\n\nfloat sandwave(float phi){\n    \n    float t = mod(phi/(2.0*M_PI) +1.0,1.0);\n    t= t*3.0;\n    if(t <= 2.0){\n        return -pow(t/2.0, 3.0);\n    }else{\n        return -pow(1.0-(t-2.0),3.0);\n    }\n    \n}\n\n\n// ---------------------------------------------------------------\n\n\n\nfloat makeNoiseSrf(vec3 tuv,vec3 wu, vec3 wv,vec3 nrm, float profile)\n{\n  current_sum_sin = 0.0;\n  current_sum_cos = 0.0;\n\n  vec3  uvw = tuv * 10.0;\n\n  float v = 0.0;\n  {\n\n    // sparse convolution\n    float kr = kernelRadius(_a);\n\n    vec3  cellsz = vec3(2.0*kr);\n    vec3  _ijk   = uvw / cellsz;\n    ivec3 ijk    = ivec3(round(_ijk));\n    vec3  fijk   = _ijk - vec3(ijk);\n\n    \n    ivec3 nd = ivec3(0);\n    nd.x = (fijk.x > 0.5) ? 1 : -1;\n    nd.y = (fijk.y > 0.5) ? 1 : -1;\n    nd.z = (fijk.z > 0.5) ? 1 : -1;\n\n    for (int k = 0; k < 2; k++) {\n      for (int j = 0; j < 2; j++) {\n        for (int i = 0; i < 2; i++) {\n          v += sampleCellSrf(\n            ijk + ivec3(i, j, k)*nd, fijk - vec3(i, j, k)*vec3(nd), \n            wu, wv, nrm, \n            _base_F,\n            _F_0, _omega_0, _omega_w, _K, _a, kr);\n        }\n      }\n    }\n  }\n\n  float x = dot(uvw, wu);\n\n  \n\n  float intens =  length(vec2(current_sum_sin,current_sum_cos));\n  float phase  = atan(current_sum_sin,current_sum_cos);  \n  intens = min(intens*2.0,1.0);\n    \n  float sand = sandwave(x*2.0*M_PI*_base_F + phase);\n  return intens* sand;\n  float saw =2.0*fract((x*2.0*M_PI*_base_F + phase)/(2.0*M_PI));\n  return saw;\n   \n\n}\n\n// ---------------------------------------------------------------\n\nfloat noiseSrf(vec3 point, vec3 normal, float profile)\n{\n  vec3 tuv = point;\n  vec3 nrm = normalize(normal);\n\n  vec3 wu = normalize(cross(nrm, Vup));\n  vec3 wv = cross(wu, nrm);\n\n  // make noise\n  return makeNoiseSrf(tuv, wu, wv, nrm, profile);\n}\n\n// ---------------------------------------------------------------\n\nfloat gnoise(vec3 pt,vec3 nrm, float profile)\n{\n  float n = 0.0;\n  n += noiseSrf(pt,nrm, profile);\n  return n;\n} \n\n\n/* Beware Neyret2 is watching you ! */","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Rolling hills. By David Hoskins, November 2013.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// https://www.shadertoy.com/view/Xsf3zX\n\n// v.2.00 Uses eiffie's 'Circle of Confusion' function\n//\t\t  for blurred ray marching into the grass.\n// v.1.02 Camera aberrations.\n// v.1.01 Added better grass, with wind movement.\n\n#define dunes true\n\n#define stripes true\n\n#define fog true\n\n#define color true\n\n#define MOD2 vec2(3.07965, 7.4235)\nfloat PI  = 4.0*atan(1.0);\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\nvec3 cameraPos;\nvec3 sunColour = vec3(1.0, .75, .6);\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\nfloat gTime = 0.0;\n\n//--------------------------------------------------------------------------\n// Noise functions...\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) / MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n//--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n//--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    if(dunes){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n    }\n    return 0.0;\n}\n\n\n//--------------------------------------------------------------------------\nvec2 Terrain( in vec2 p)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.003;\n\tfloat w = 50.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.62;\n\t\tpos *= 2.5;\n\t}\n\n\treturn vec2(f, type);\n}\n\n//--------------------------------------------------------------------------\nvec2 Map(in vec3 p)\n{\n\tvec2 h = Terrain(p.xz);\n    return vec2(p.y - h.x, h.y);\n}\n\n//--------------------------------------------------------------------------\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\n    if(color)\n    return clamp(sky, 0.0, 1.0);\n    \n    return vec3(0.0,0.0,0.0);\n    \n}\n\n\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n    if(fog){\n    float fogAmount = clamp(dis*dis* 0.0000100, 0.0, 1.0);\n    \n    \n\treturn mix( rgb, GetSky(dir), fogAmount );\n    }\n    else{\n    return rgb;\n    }\n}\n\n\n//--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)/(b-a),0.,1.);\n}\n\n\n//--------------------------------------------------------------------------\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,normal);\n    if(color){\n\t\tmat = mat * sunColour*(max(h, 0.0)+.2);\n    }else{\n    \tmat = mat * vec3(1.0)*(max(h, 0.0)+.2);\n    }\n}\n\n//--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type, float i)\n{\n\tvec3 mat;\n\tif (type == 0.0)\n\t{\n\t\tfloat grain = (texture(iChannel0,pos.xz/2.5).x)*0.2 + 0.8;\n        \n        \n        mat = vec3(237.0/255.0,201.0/255.0,175.0/255.0) * grain;\n        if(!color){\n         mat =vec3(0.5,0.5,0.5);   \n        }\n\t\t\n        float s = length(mat);\n        \n        s= s*(1.0-(i/(dis*dis) *180.0));\n        mat = mat*s;\n\t\tDoLighting(mat, pos, normal,dir, dis);\n\t}\n\tmat = ApplyFog(mat, dis, dir);\n\treturn mat;\n}\n\n//--------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n\tfloat halfwayT = 0.0;\n\tfor (int n = 0; n < 5; n++)\n\t{\n\t\thalfwayT = (oldT + t ) * .5;\n\t\tif (Map(rO + halfwayT*rD).x < .05)\n\t\t{\n\t\t\tt = halfwayT;\n\t\t}else\n\t\t{\n\t\t\toldT = halfwayT;\n\t\t}\n\t}\n\treturn t;\n}\n\n//--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\n{\n    float t = 5.;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.;\n\tvec2 h = vec2(1.0, 1.0);\n\tbool hit = false;\n\tfor( int j=0; j < 70; j++ )\n\t{\n\t    vec3 p = rO + t*rD;\n\t\th = Map(p); \n\n\t\tif( h.x < 0.05)\n\t\t{\n\t\t\thit = true;\n            break;\n\t\t}\n\t        \n\t\tdelta = h.x + (t*0.03);\n\t\toldT = t;\n\t\tt += delta;\n\t}\n    type = h.y;\n    resT = BinarySubdivision(rO, rD, t, oldT);\n\treturn hit;\n}\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\n\treturn vec3(p.x+55.0,  20.0+sin(t*.3)*6.5, -94.0+p.y);\n} \n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\n\trgb = pow(rgb, vec3(0.45));\n\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\nvec4 bump(vec3 norm, vec3 pos, float d){\n    if(stripes){\n    \n    vec3 v1 = vec3(-norm.y,norm.x,norm.z) ;\n    v1 = normalize(v1);\n\tvec3 v2 = cross(norm, v1);\n    v2 = normalize(v2);\n\t\n\tfloat eps = 0.001;\n    float bumpstrength = 0.003/(d*0.1);\n    float h = (gnoise(pos,norm,0.0));\n    vec4 res = vec4(vec3(0),h);\n\t h = h * bumpstrength;\n    float h1 = (gnoise(pos+v1*eps,norm,0.0)) *bumpstrength;\n\tfloat h2 = (gnoise(pos+v2*eps,norm,0.0)) *bumpstrength;\n    \n    _a            = 40.0;\n\t_F_0          = 60.0;\n\tSeed = 130;\n    bumpstrength = bumpstrength / 15.0;\n\th += (gnoise(pos,norm,0.0)) * bumpstrength;\n    h1 += (gnoise(pos+v1*eps,norm,0.0)) *bumpstrength;\n\th2 += (gnoise(pos+v2*eps,norm,0.0)) *bumpstrength;\n    \n    vec3 p1 = pos + norm*h;\n    vec3 p2 = pos + v1 +norm*h1/eps;\n    vec3 p3 = pos + v2 + norm*h2/eps;\n    \n\tvec3 d1 = p1-p2;\n    \n\tvec3 d2 = p3-p1;\n    \n    vec3 b = normalize(cross(d2,d1));\n\tres.xyz = b;\n    \n    return res;\n    }else{\n        return vec4(norm,0);\n    }\n}\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = 0.91*300.0;\n\tfloat gTime = iTime* 0.05;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\tvec3 camTar;\n\t\n    \n\tcameraPos = CameraPath(gTime + 0.0);\n    cameraPos.x -= 0.0;\n\tcamTar\t = CameraPath(gTime + .009);\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x  +3.0;\n\tcamTar.y = cameraPos.y -3.5;\n\t\n\tfloat roll =0.0;\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\n\tvec3 col;\n\tfloat distance;\n\tfloat type;\n\tif( !Scene(cameraPos, dir, distance, type) )\n\t{\n\t\t// Missed scene, now just get the sky...\n\t\tcol = GetSky(dir);\n\t}\n\telse\n\t{\n\t\t// Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * dir;\n\t\t// Get normal from sampling the high definition height map\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\n\t\tvec2 p = vec2(0.1, 0.0);\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\n\t\tnor = cross(v2, v3);\n\t\tnor  = normalize(nor);\n        \n        vec4 b =bump(nor,pos*1.0e-2,distance);\n\t\tnor = b.xyz;\n\t\t// Get the colour using all available data...\n\t\tcol = TerrainColour(pos, dir, nor, distance, type,b.a);\n\t}\n\t\n\tfloat bri = dot(cw, sunLight)*.75;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8 * 0.2;\n\n\t\t// glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t// glare2 is the yellow ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t// glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.1;\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*0.0;\n\t}\n\tcol = PostEffects(col, xy);\t\n\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------","name":"Buffer A","description":"","type":"buffer"}]}