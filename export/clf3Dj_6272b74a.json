{"ver":"0.1","info":{"id":"clf3Dj","date":"1672410778","viewed":222,"name":"Simple Ray-Traching","username":"jynwang","description":"Simple Ray-Traching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytraching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float MaxCameraLookOffset = 5.;\nvec3 CameraPositionWS = vec3(0, 0, 14);\nvec3 CameraLookAtPointWS = vec3(0, 0, 0);\nvec3 CameraUp = vec3(0, 1, 0);\n\nfloat Aspect = 16. / 9.;\nfloat Fov = 70.;\nfloat Near = 2.;\nfloat Far = 10.;\n\nmat3 TBNWorld = mat3(vec3(1., 0., 0.), vec3(0., 1., 0.), vec3(0., 0., 1.));\n\n/*\n根据鼠标位置调整镜头\n*/\nvoid MoveCamera()\n{\n\n   vec2 mouseOffset = iMouse.xy / iResolution.xy;\n   mouseOffset -= 0.5;\n    \n   CameraLookAtPointWS.xy += mouseOffset * MaxCameraLookOffset;\n\n}\n\n/*\n构建射线\n*/\nRay CreateRay(vec2 uv)\n{\n    Ray ray;\n    \n    MoveCamera();\n     \n    vec3 k = normalize(CameraLookAtPointWS - CameraPositionWS);\n    vec3 i = normalize(cross(k, CameraUp));\n    vec3 j = normalize(cross(i, k));\n    \n    mat3 tbnCamera = mat3(i, j, k);\n    mat3 verseCamera = inverse(tbnCamera);\n    \n    float nearPlaneHeight = Near * tan(DegreeToRad(Fov) / 2.);\n    float nearPlaneWidth = nearPlaneHeight * Aspect;\n    \n    uv.xy -= 0.5;\n    vec3 pixelPositionVS = vec3(nearPlaneWidth * uv.x, nearPlaneHeight * uv.y, Near);\n    vec3 viewDirVS = normalize(pixelPositionVS);\n    \n    vec3 viewDirWS = normalize(verseCamera * viewDirVS);\n    \n    ray.origin = CameraPositionWS;\n    ray.direction = viewDirWS;\n    \n    return ray;\n}\n\n/*\n创建球体\n*/\nint sphereCount = 0;\nvoid CreateSphere(vec3 position, float radius, Material material) \n{\n    if (sphereCount >= MaxSpheresCount) \n    {\n        return;\n    }\n    \n    ++sphereCount;\n    \n    Sphere sphere = Sphere(position, radius, material);\n    Spheres[sphereCount - 1] = sphere;\n}\n\n/*\n创建平面\n*/\nint planeCount = 0;\nvoid CreatePlane(vec3 position, vec3 normal, Material material) \n{\n    if (planeCount >= MaxPlanesCount) \n    {\n        return;\n    }\n    \n    ++planeCount;\n    \n    Plane plane = Plane(position, normal, material);\n    Planes[planeCount - 1] = plane;\n}\n\n/*\n创建点光\n*/\nint lightCount = 0;\nvoid CreateLight(vec3 position, vec3 color, float intensity)\n{\n\n    if (lightCount >= MaxLightsCount) \n    {\n        return;\n    }\n    \n    ++lightCount;\n    PointLight light = PointLight(position, color, intensity);\n    Lights[lightCount] = light;\n}\n/*\n创建材质\n*/\nMaterial CreateMaterial(vec3 baseColor, float roughness, float kReflect, float kTransmit)\n{\n    return Material(baseColor, roughness, kReflect, kTransmit);\n}\n\n/*\n创建世界\n*/\nvoid CreateWorld()\n{\n    // 创建地板                               baseColor,  roughness, reflect, transmit\n    Material floorPlaneMat = CreateMaterial(OffWhite.rgb,    0.,       0.05,      0.);\n    CreatePlane(vec3(0, -3, 0), vec3(0, 1, 0), floorPlaneMat);\n    // top                                  baseColor,  roughness, reflect, transmit\n    Material topPlaneMat = CreateMaterial(OffWhite.rgb,    0.,       0.01,      0.);\n    CreatePlane(vec3(0, 3, 0), vec3(0, 1, 0), topPlaneMat);\n    // back                                 baseColor,  roughness, reflect, transmit\n    Material backPlaneMat = CreateMaterial(OffWhite.rgb,    0.8,       1.,      0.);\n    CreatePlane(vec3(0, 0, -8), vec3(0, 0, 1), backPlaneMat);\n    // left                                 baseColor,  roughness, reflect, transmit\n    Material leftPlaneMat = CreateMaterial(Red.rgb,       0.8,       0.,      0.);\n    CreatePlane(vec3(-5, 0, 0), vec3(1, 0, 0), leftPlaneMat);\n    // right                                 baseColor,  roughness, reflect, transmit\n    Material rightPlaneMat = CreateMaterial(Green.rgb,       0.8,       0.,      0.);\n    CreatePlane(vec3(5, 0, 0), vec3(1, 0, 0), rightPlaneMat);\n     // forward                               baseColor,  roughness, reflect, transmit\n    Material forwardPlaneMat = CreateMaterial(Yellow.rgb,       0.8,       0.,      0.);\n    CreatePlane(vec3(0, 0, CameraPositionWS.z + 2.), vec3(0, 0, 1), forwardPlaneMat);\n    \n    \n    // 创建球体                             baseColor,  roughness, reflect, transmit\n    Material sphereCyanMat = CreateMaterial(Cyan.rgb,      0.7,       1.0,       0.);\n    CreateSphere(vec3(-3, -1.8, -1.5), 1.2, sphereCyanMat);\n     // 创建球体                             baseColor,  roughness, reflect, transmit\n    Material sphereWhiteMat = CreateMaterial(White.rgb,      1.,       0.1,       1.);\n    CreateSphere(vec3(2, -1.8, 2), 1.2, sphereWhiteMat);\n     // 创建球体                             baseColor,  roughness, reflect, transmit\n    Material sphereBlueMat = CreateMaterial(Cyan.rgb,      0.5,       0.0,       0.);\n    CreateSphere(vec3(-3.8, 0.5, 2), 1.2, sphereBlueMat);\n    \n    // 创建灯光\n    CreateLight(vec3(0, 3, 0), White.rgb, 12.0);\n    \n}\n\n/*\n射线与球体求交\n*/\nfloat RaycastSphere(Ray ray, Sphere sphere)\n{\n    float r = sphere.radius;\n    vec3 p = sphere.position;\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n    \n    float c = r * r - dot(o, o) + 2.0 * dot(o, p) - dot(p, p);\n    float b = -2.0 * (dot(o, d) - dot(p, d)); \n    float a = -1.0; \n    \n    float q = b * b - 4.0 * a * c;\n    \n    if(q < 0.0) \n    {\n        return -1.0;\n    }\n    \n    q = sqrt(q);\n    \n    float t1 = (-b - q) / (2.0 * a);\n    float t2 = (-b + q) / (2.0 * a);\n    \n    return t1 < t2 ? t1 : t2;\n}\n\n/*\n射线与平面求教\n*/\nfloat RaycastPlane(Ray ray, Plane plane) { \n    float d = -dot(plane.position, plane.normal);\n    float denominator = dot(plane.normal, ray.direction);\n    if (denominator == 0.0) {\n        return -1.0;\n    }\n    return -(dot(plane.normal, ray.origin) + d) / denominator;\n}\n\n\n/*\n  对场景内所有物体进行光线求交\n  这里没有进行z排序\n*/\nRayIntersect Raycast(Ray ray)\n{\n    vec3 intersectionPoint;\n    vec3 intersectionNormal;\n    Material material;\n    \n    float t = -1.0;\n    bool hitSphere = false;\n    bool hitPlane = false;\n    \n    Sphere nearestSphere;\n    for(int i = 0; i < MaxSpheresCount; ++i)\n    {\n    \n        float temp = RaycastSphere(ray, Spheres[i]);\n        \n        if ((t == -1.0 || temp < t) && temp >= 0.0) \n        {\n            t = temp;\n            nearestSphere = Spheres[i];\n            hitSphere = true;\n        }\n    }\n    \n    if (hitSphere)\n    {\n        intersectionPoint = ray.origin + ray.direction*t;\n        intersectionNormal = normalize(intersectionPoint - nearestSphere.position); \n        material = nearestSphere.material;\n    } else \n    {\n        Plane nearestPlane;\n         for(int i = 0; i < MaxPlanesCount; ++i) \n         {\n            float temp = RaycastPlane(ray, Planes[i]);\n            if ((t == -1.0 || temp < t) && temp >= 0.0) {\n                t = temp;\n                nearestPlane = Planes[i];\n                hitPlane = true;\n            }\n        }\n        \n        if(hitPlane) {\n            intersectionPoint = ray.origin + ray.direction * t;\n            intersectionNormal = nearestPlane.normal;\n            material = nearestPlane.material;\n        }\n    }\n    \n    \n    return RayIntersect(hitSphere || hitPlane, intersectionPoint, intersectionNormal, material);\n}\n\n/*\n计算阴影\n*/\nbool RaycastShadow(vec3 hitPosition, PointLight light) {\n    vec3 direction = normalize(light.position - hitPosition);\n    Ray shadowRay = Ray(hitPosition + direction * EPSILON, direction);\n    RayIntersect rayIntersect = Raycast(shadowRay);\n    return !rayIntersect.valid || length(rayIntersect.point - hitPosition) + ShadowBias < length(hitPosition - light.position);\n}\n\n\n/*\nBlinn-Phong着色\n*/\nvec3 BlinnPhongShading(Material material, vec3 hitPosition, vec3 normal) {\n\n    vec3 color = AmbientLight * material.baseColor;\n    \n    for(int i = 0; i < MaxLightsCount; ++i) \n    {\n        \n        PointLight light = Lights[i];\n\n        \n        if (RaycastShadow(hitPosition, light)) {\n        \n            continue;\n        }\n\n        float lightIntensity = CalculateLightIntensity(light, hitPosition);\n        vec3 lightColor = light.color * lightIntensity;\n        \n        vec3 L = normalize(light.position - hitPosition);\n        vec3 V = normalize(CameraPositionWS - hitPosition);\n        vec3 H = normalize(L + V);\n        \n        vec3 diffuse = lightColor * material.baseColor * max(dot(normal, L) * 0.5 + 0.5, 0.0);\n        vec3 specular = lightColor * pow(max(dot(normal, H), 0.0), 1.0 / (material.roughness + EPSILON)); // pow(max(dot(R,V),0.0),material.shininess);\n        color += diffuse + specular;\n    }\n    \n    return color;\n}\n\n\n/*\n光线追踪着色\n*/\nvec3 RayTraceShading(Ray ray)\n{\n    \n    \n    RayIntersect[MAX_BOUCE] intersectionStack;\n    \n    int counter = 0;\n    RayIntersect rayIntersect = Raycast(ray);\n    \n    while (rayIntersect.valid && counter < MAX_BOUCE) \n    {\n         intersectionStack[counter] = rayIntersect;\n         ++counter;\n        \n         if (rayIntersect.material.kReflect > 0.0) \n         {\n          \n            vec3 reflectionDirection = normalize(reflect(ray.direction, rayIntersect.normal));\n            // 向前反射一点点距离，避免跟原来的物体又相交\n            Ray reflectionRay = Ray(rayIntersect.point + reflectionDirection * EPSILON, reflectionDirection);\n            rayIntersect = Raycast(reflectionRay);\n         \n         \n         } else {\n         \n             break;\n         }\n        \n       \n    }\n    \n    vec3 color = vec3(0, 0, 0);\n   \n    \n    for(int i = counter - 1; i >= 0; i--) {\n    \n        rayIntersect = intersectionStack[i];\n        \n        Material material = rayIntersect.material;\n        \n        vec3 localColor = BlinnPhongShading(material, rayIntersect.point, rayIntersect.normal);\n        \n        vec3 reflectColor = color;\n        \n        color = localColor * (1. -  material.kReflect)  + material.kReflect * reflectColor;\n       \n    }\n   \n    return color;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return min((x*(a*x+b))/(x*(c*x+d)+e), 1.0);\n}\n\n/*\n程序入口\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   CreateWorld();\n   \n   vec2 pixelSize = 1.0 / iResolution.xy;\n   \n   vec2 uv = (fragCoord.xy + vec2(0.5, 0.5)) * pixelSize;\n   \n#if MSAA\n   vec3 color = vec3(0, 0, 0);\n   float msaaCount = 0.0;\n   \n   for(int i = 0; i < MSAA; ++i) \n   {\n   \n       msaaCount++;\n       Ray ray = CreateRay(uv.xy + MSAA_AREA[i] * pixelSize);\n       color += RayTraceShading(ray);\n  }\n   \n   color /= msaaCount;\n#else\n   \n   Ray ray = CreateRay(uv.xy);\n   vec3 color = RayTraceShading(ray);\n   \n#endif\n   // fragColor = vec4(ACESFilm(color), 1.0);\n   \n  \n   \n   fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n\n#define PI 3.141592653\n#define MAX_BOUCE 5\n#define EPSILON 0.001\n#define ShadowBias 0.001\n#define MSAA 0\n\nvec2[] MSAA_AREA = vec2[16]\n(\n    // msaa 4 = 2x2\n    vec2(-0.5, 0.5), // 0\n    vec2(-0.5, -0.5), // 1\n    vec2(0.5, -0.5), // 2\n    vec2(0.5, 0.5), // 3\n    \n    // msaa 16 = 4x4\n    vec2(-0.5, 1.0), // 4\n    vec2(-1.0, 0.5), // 5\n    vec2(-1.0, 1.0), // 6\n    \n    vec2(0.5, 1.0), // 7\n    vec2(1.0, 0.5), // 8\n    vec2(1.0, 1.0), // 9\n    \n    vec2(-0.5, -1.0), // 10\n    vec2(-1.0, -0.5), // 11\n    vec2(-1.0, -1.0), // 12\n    \n    vec2(0.5, -1.0), // 13\n    vec2(1.0, -0.5), // 14\n    vec2(1.0, -1.0) // 15\n    \n);\n\n\nfloat DegreeToRad(float degree) \n{\n    return degree * PI / 180.0;\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n/*\n材质\n*/\nstruct Material\n{\n    vec3 baseColor;\n    float roughness;\n    float kReflect;\n    float kTransmit;\n};\n\n\n\nstruct RayIntersect\n{\n    bool valid;\n    vec3 point;\n    vec3 normal;\n    Material material;\n};\n\n\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material material;\n};\n\n\nstruct Plane\n{\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\n\nstruct PointLight\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\n\n\n\nconst int MaxPlanesCount = 6;\nconst int MaxSpheresCount = 3;\nconst int MaxLightsCount = 2;\n\n\n\nvec3 AmbientLight = vec3(0.2, 0.2, 0.2);\nPointLight Lights[MaxLightsCount];\n\n\n\n\n\nPlane Planes[MaxPlanesCount];\nSphere Spheres[MaxSpheresCount];\n\n\nvec4 Black = vec4(0., 0., 0., 1.0);\nvec4 White = vec4(1., 1., 1., 1.0);\nvec4 OffWhite = vec4(242.0 / 255.0, 245.0 / 255.0, 216.0 / 255.0, 1.0);\nvec4 Red = vec4(1.f, 0.0f, 0.0f, 1.f);\nvec4 Green = vec4(0.0f, 1.f, 0.0f, 1.f);\nvec4 Blue = vec4(0.0f, 0.0f, 1.f, 1.f);\nvec4 Yellow = vec4(1.f, 0.9215686f, 0.01568628f, 1.f);\nvec4 Cyan = vec4(0.0f, 1.f, 1.f, 1.f);\nvec4 Magenta = vec4(1.f, 0.0f, 1.f, 1.f);\nvec4 Gray = vec4(0.5f, 0.5f, 0.5f, 1.f);\nvec4 Clear = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n\nfloat CalculateLightIntensity(PointLight light, vec3 positionWS) \n{\n    float d = length(light.position - positionWS);\n    return light.intensity / (d * d);\n}\n","name":"Common","description":"","type":"common"}]}