{"ver":"0.1","info":{"id":"ddGcz1","date":"1700236400","viewed":65,"name":"Eroded Terrain Noise 3D","username":"CollinInMySternum","description":"3D Eroded Terrain Noise , a modification of Clay John's \"Eroded Terrain Noise\"  : https://www.shadertoy.com/view/MtGcWh\nScene and rendering taken by an IQ noise shader.\n\nOriginal comments or copyright disclaimers may be removed. Please check the original.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define erosionscale 4.0f\n\n\n//3D MODIFICATION OF \"ERODED TERRAIN NOISE\" By clayjohn : https://www.shadertoy.com/view/MtGcWh\n//I Would recommend starting there for an understanding of the code, the changes were minor, but\n//I felt like making this available.\n\n//ORIGINAL COPYRIGHT DISCLAIMER\n\n//Copyright 2020 Clay John\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software \n//and associated documentation files (the \"Software\"), to deal in the Software without restriction, \n//including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n//and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do \n//so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all copies or \n//substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT \n//NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \n//WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n//GRADIENT 3D NOISE DERIVATIVES SCENE/PREVIEW BY IQ : https://www.shadertoy.com/view/4dffRH\n\n\n// From https://www.shadertoy.com/view/4djSRW\n// Name : Hash without Sine\n// Author : Dave_Hoskins\n// License : MIT\n// Why not normal hash? Because terrible for planets, and that is what I am using this for.\nvec3 hash3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return 1.0 - 2.0 * fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n// From https://www.shadertoy.com/view/4dffRH\n// Name : iq\n// License : MIT\n// Modified to remove the different settings, and use sineless hash.\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    \n    // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n    vec3 du = 6.0*f*(1.0-f);    \n    \n    // gradients\n    vec3 ga = hash3( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash3( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash3( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash3( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash3( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash3( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash3( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash3( i+vec3(1.0,1.0,1.0) );\n\n    // projections\n    float va = dot( ga, f-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, f-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, f-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, f-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, f-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, f-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, f-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, f-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n\n// code modified from https://www.shadertoy.com/view/4tB3RR\n// Name : Gavoronoise 3d\n// Author : guil\n// License : // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec4 erosion(in vec3 p, in vec3 dir)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float f = 4.*PI;//frequency\n    vec4 va;\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=1; i++) \n\tfor (int j=-2; j<=1; j++) \n    for (int k=-2; k<=1; k++)    \n\t{\t\t\n        vec3 o = vec3(i, j, k);\n        vec3 h = hash3((ip - o))*.5;\n        vec3 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        float mag = dot(pp, dir);\n        va += vec4(cos(mag*f),-sin(mag*f)*(pp+dir))*w;\n\t}    \n    return va/wt;\n}\n\n\n//Modified to have erosionscale and it to be 3D\nfloat mountain(vec3 p, vec3 nor) {\n\n    vec4 n = vec4(0.0);\n    float nf = 1.0;\n    float na = 0.6;\n    for (int i=0;i<3;i++) {\n       n+= noised(p*nf)*na*vec4(1.0, nf, nf, nf);\n       na *= 0.5;\n       nf *= 2.0;\n    }\n    \n    //take the curl of the normal to get the gradient facing down the slope\n    vec3 dir = cross(n.yzw, nor);\n    \n    //Now we compute another fbm type noise\n    // erosion is a type of noise with a strong directionality\n    //we pass in the direction based on the slope of the terrain\n    //erosion also returns the slope. we add that to a running total\n    //so that the direction of successive layers are based on the\n    //past layers\n    vec4 h = vec4(0.0);\n    float a = 0.7*(smoothstep(0.3, 0.5,n.x*0.5+0.5)); //smooth the valleys\n    float f = 1.0;\n    for (int i=0;i<5;i++) {\n        h+= erosion(p*erosionscale*f, dir+cross(h.yzw, normalize(p)))*a*vec4(1.0, f, f, f);\n        a*=0.6;\n        f*=2.0;\n    }\n    //remap height to [0,1] and add erosion\n    //looks best when erosion amount is small\n    //not sure about adding the normals together, but it looks okay\n    return (smoothstep(-1.0, 1.0, n.x)+h.x*0.05);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n        f = mountain(4.0f*pos, nor);\n\n\t\t\n\t\tf *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}