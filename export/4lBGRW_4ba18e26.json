{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define NUM_SPHERES 5\n#define NUM_PARALLELS 1\n#define SMALL_NUM 0.0001\n#define PI 3.14159265359\n#define maximumBounces 3\n\nvec4 ambientLight = vec4(0.1, 0.1, 0.1, 0.2);\n\nstruct Material {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    float reflectiveness;\n};\n    \nMaterial mirror;\n\n\n    \n\n   \n\nstruct ParallelLight {\n    vec3 direction;\n    vec4 color;\n};\n    \nParallelLight parallels[NUM_PARALLELS];\n\nParallelLight parallelLight(vec3 direction, vec4 color) {\n    ParallelLight light;\n    light.direction = normalize(direction);\n    light.color = color;\n    return light;\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    int numberOfHits;\n    vec4 reflectance;\n    vec4 color;\n    float distance;\n};\n    \nRay ray(vec3 origin, vec3 direction, int numberOfHits, vec4 color, float distance) {\n\tRay r;\n    r.origin = origin;\n    r.direction = direction;\n    r.numberOfHits = numberOfHits;\n    r.color = color;\n    r.reflectance = vec4(1.0);\n    r.distance = distance;\n    return r;\n}\n\n//By default return eye location;\nRay ray() {\n    \n    return ray(vec3(0.0, 0.0, 0.0), \n               vec3(0.0, 0.0, 1.0), \n               0, \n               vec4(0.0, 0.0, 0.0, 1.0), \n               0.0);\n}\n    \nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec4 color;\n};\n    \n\nSphere spheres[NUM_SPHERES];\n\nSphere sphere(vec3 location, float radius, vec4 color) { \n    Sphere s;\n    s.center = location;\n    s.radius = radius;\n    s.color = color;\n    return s;\n}\n\nvec3 triangle[3];\nvec4 triangleColor;\n\nvoid setupScene() { \n    \n    mirror.ambient = 0.0; \n\tmirror.diffuse = 0.0;\n\tmirror.specular = 0.1;\n\tmirror.shininess = 32.0;\n\tmirror.reflectiveness = 0.9;\n    \n    mat3 rotation = mat3(cos(iTime/4.0) , sin(iTime/4.0), 0.0, \n                         sin(iTime/4.0), - cos(iTime/4.0), 0.0, \n                          0.0, 0.0, 1.0);\n    spheres[0] = sphere(vec3(0.0, 0.0, 14) \n                        + rotation * vec3(1.0, -0.5, 0.33)\n                        ,\n                        0.75, \n                        vec4(0.9, 0.2, 0.3, 1.0));\n    spheres[1] = sphere(vec3( 1.0, 0.0, 11.0)+ vec3(1.0, 2.0, 4.0) * rotation, \n                        1.5, \n                        vec4(0.67));\n    spheres[2] = sphere(vec3(3.0, -2.0, 22.0) + vec3(1.0) * rotation, \n                        1.0,  \n                        vec4(0.125, 0.25, 0.55, 1.0));\n    spheres[3] = sphere(vec3(-1.0, 0.0, 25.0) + vec3(0.5, 2.0, 0.2) * rotation, \n                        1.5, \n                        vec4(0.125, 0.33, 0.7, 1.0));\n    spheres[4] = sphere(vec3(1.0, 0.0, 19.0) \n                        + rotation * vec3(1.0, -1.0, 0.50), \n                        1.0, \n                        vec4(0.55, 0.25, 0.76, 1.0));\n   \n    triangle[0] = rotation * vec3(0.0, 0.0, 25.0 );\n    triangle[1] = rotation * vec3(2.0, 1.0, 29.0 );\n    triangle[2] = rotation * vec3(2.0, 0.0, 20.0 );\n    triangleColor = vec4(0.4, 0.3, 0.7, 1.0);\n \n    parallels[0] = parallelLight(normalize(vec3(11.0, -1.0, 0.0)  * cos(iTime/100.0) \n                                 + vec3(1.0, 1.0, 0.0) * sin(iTime / 100.0) + vec3(1.0))\n        \t\t\t  , vec4(2.0, 1.5, 1.0, 1.0)); \n                         \n}\n\nvec4 calculateLambertianTerm(vec4 current, vec3 normal, vec3 direction, vec4 materialColor) { \n    vec4 color = vec4(0.0); //dot(-1.0 * normal, direction) * materialColor;  \n    for (int i = 0; i < NUM_PARALLELS; i++) {\n        float lambertian =  dot(-1.0 * normal,parallels[i].direction);\n        if (lambertian > 0.0){\n        \tcolor += lambertian\n            \t* materialColor \n                * parallels[i].color \n                / float(NUM_PARALLELS);\n        }\n    }\n   \n    color =  color;\n    return color;  \n}\n\nvec4 calculateSpecularTerm(vec4 current, vec3 normal, vec3 direction, vec4 materialColor) {   \n    vec4 color = vec4(0.0); //dot(-1.0 * normal, direction) * materialColor;  \n    for (int i = 0; i < NUM_PARALLELS; i++) {\n        float specular =  dot(- normal,parallels[i].direction);\n        if (specular > 0.0){\n            specular = pow(specular, 16.0);\n        \tcolor += specular\n            \t* materialColor * parallels[i].color / float(NUM_PARALLELS);\n        }\n    }\n    return color; \n    \n}\n\nvoid reflectRay(out Ray r, Ray inRay, vec4 materialColor, vec3 normal, float t, vec3 intersection) {\n    r = inRay;\n    vec3 reflection = normalize(reflect(inRay.direction, normal));\n\tvec4 specular = calculateSpecularTerm(inRay.color, reflection, inRay.direction, materialColor);\n    vec4 lambert = calculateLambertianTerm(inRay.color, normal, inRay.direction, materialColor);\n    r.color = inRay.color +  inRay.reflectance  * (lambert/1.5  + specular/2.0);\n        \n    r.origin = intersection;\n    r.direction = reflection;\n    r.reflectance = inRay.reflectance * materialColor / 3.0 * (float(inRay.numberOfHits) + 1.0);\n    r.numberOfHits++;\n    r.distance = t;  \n    \n}\n\nfloat intersect(out Ray result, Ray r, Sphere s) { \n    float a = dot(r.direction, r.direction);\n    float c = dot(r.origin, r.origin)\n        \t  + dot(s.center, s.center) \n        \t  - 2.0 * dot(r.origin, s.center) \n        \t  - s.radius * s.radius;\n    float b = 2.0 * (dot(r.direction, r.origin) \n              - dot(s.center, r.direction)); \n    float det = b * b - 4.0 * a * c;\n    float t = 0.0;\n    if (det >= 0.0) { \n        float t2 = -b - sqrt(det);\n    \tfloat t1 = -b + sqrt(det);\n        \n    \tif (t2 > 0.0) { \n        \tt = t2 / (2.0 * a);\n    \t} else if (t1 > 0.0) {      \n        \tt = t1 / (2.0 * a);\n        \n    \t}  \n        vec3 intersection = t * r.direction + r.origin;\n        vec3 normal = normalize(intersection - s.center);\n        reflectRay(result, r, s.color, normal , t, intersection); \n    }; \n     \n    return t;\n}\n\nfloat intersect(out Ray result, Ray r, vec3 triangle[3]) {\n    \n    float distance = 0.0;\n    vec3 u = triangle[1] - triangle[0];\n    vec3 v = triangle[2] - triangle[0];\n    vec3 normal = cross(u, v);\n   \n    if (length(normal) < 0.01) return 0.0; // Degenerate triangles \n    normal = normalize(normal);\n    vec3 w0 = r.origin - triangle[0] ;\n    float a = -dot(normal, w0);\n    float b = dot(normal, r.direction);\n    \n    if (abs(b) < SMALL_NUM) return 0.0;\n    distance = a / b;\n    if (distance < 0.0) return 0.0;\n        \n    vec3 planeIntersection = distance * r.direction + r.origin;\n    vec3 w = planeIntersection - triangle[0];\n    float udotu = dot(u, u);\n    float vdotv = dot(v, v);\n    float udotv = dot(u, v);\n    float wdotu = dot(w, u);\n    float wdotv = dot(w, v);\n    float denominator = udotv * udotv - udotu * vdotv;\n    float s = (udotv * wdotv - vdotv * wdotu) / denominator;\n    if (s < 0.0) return 0.0;\n    \n    float t = (udotv * wdotu - udotu * wdotv) / denominator;\n    if (t < 0.0 || s + t > 1.0) return 0.0;\n                    \n \n    if (dot(normal, r.direction) > 0.0) \n        normal = -normal;\n\n   \n    reflectRay(result, r, triangleColor, normal, distance, planeIntersection);\n    \n    return distance;\n\n}\n\nRay castRay(Ray defaultRay) {\n    \n    Ray visible = defaultRay;\n    int lastSphereBounced = -1;\n    bool triangleBounced = false;\n    for (int j=0; j < maximumBounces; j++) {\n  \t\tRay temp = visible;\n\t\tfloat closest = 1000.0;\n        for (int i = 0; i < NUM_SPHERES; i++) {\n            if (i == lastSphereBounced) continue;\n            Ray sphereRay = visible;\n            float t = intersect(sphereRay, visible, spheres[i]);\n            if (t > 0.0) {  \n               if (t < closest) {\n                   closest = t; \n                   triangleBounced = false;\n                   temp = sphereRay;\n                   lastSphereBounced = i;\n                } \n            }\n        }\n        if (!triangleBounced) {\n            Ray triangleRay = visible;\n            float t = intersect(triangleRay, visible, triangle);\n            if ( t < closest && t > 0.0) {\n            \ttriangleBounced = true;\n            \tlastSphereBounced = -1;\n                temp = triangleRay;\n                \n            } else {\n             \ttriangleBounced = false;   \n            }\n            \n        }\n        if (visible.numberOfHits < temp.numberOfHits) {\n            visible = temp;\n        }\n    }\n    return visible;\n}\n\nvec4 castAntiAliasingRay(vec2 uv) { \n    vec4 color = vec4(0.0);\n    for (int x = 0; x < 3; x ++) {\n        for (int y = 0; y < 3; y++) { \n      \t\tfloat xFloat = float(x) / 2.0 - 0.5 ;\n            float yFloat = float(y) / 2.0 - 0.5;\n        \tRay defaultRay = ray(vec3(0.0, 0.0, 0.0), \n                                 normalize(vec3(uv.x + xFloat / iResolution.x,                                    \n                                           uv.y + yFloat / iResolution.y, \n                                           1.0)), \n                                0, \n                                vec4(0.0, 0.0, 0.0, 1.0), \n                                0.0);\n            Ray result = castRay(defaultRay);\n            color += result.color / 9.0;\n        } \n    }  \n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupScene();\n\tvec2 uv = fragCoord.xy / iResolution.xy / 2.0 ;\n    uv.y = (uv.y - 0.25) * iResolution.y/iResolution.x  ;\n    uv.x = uv.x - 0.25 ;\n    fragColor =castAntiAliasingRay(uv);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4lBGRW","date":"1427081014","viewed":322,"name":"WIP: Readable Raytracer","username":"Hewpiedawg","description":"Added a triangle. And triangle intersections. Next: shadows.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","tracer"],"hasliked":0,"parentid":"","parentname":""}}