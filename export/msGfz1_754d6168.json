{"ver":"0.1","info":{"id":"msGfz1","date":"1697931118","viewed":51,"name":"Game of life on a monitor","username":"im_elie_","description":"2023 - Théo GOUREAU (MIT License)\n\nSchool project realized at TELECOM Nancy and supervised by Dr. Camille SCHRECK.\n\nSwitch between PoVs: C, V, B, N\nMove the camera: Z/W, Q/A, S, D, SHIFT, SPACE\nSwitch on/off the lights: I, O, K, L\nSwitch effects: UP, DOWN","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raycasting","texture","celshading","gameoflife","tncy","graphisme"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Game of life on a monitor\n    2023 - Théo GOUREAU\n    \n    School project realized at TELECOM Nancy and supervised by Dr. Camille SCHRECK.\n*/\n\n/* Apply filters/modes/effects on the image\n    Active mode is shown on the [0, 20[*[0, 20[ pixels\n    Modes description:\n         0. Base image\n        \n         1. Base image      + object borders\n         2. Toon-shading\n         3. Toon-shading    + object borders\n         4. Base image                          + 9 bits sample\n         5. Base image      + object borders    + 9 bits sample\n         6. Toon-shading                        + 9 bits sample\n         7. Toon-shading    + object borders    + 9 bits sample\n        \n         8. Base image\n        \n         9. Object borders\n        10. Base image      + negative\n        11. Base image      + blur 60/10\n        12. Base image      + blur 20/20\n        13. Base image      + sharp 4\n        14. Base image      + sharp 8\n        15. Color borders 4\n        15. Color borders 8\n        \n        17. Base image\n        18. Base image\n        19. Base image      + Mise en abyme\n        \n        NB: 9 bits is just like 8 bits but with 3 bits for the blue (RRRGGGBBB instead of RRRGGGBB)\n    \n    Some modes are more than post-production e.g. toon shading or object borders.\n*/\n\n/********** ********** **********\n **********  FILTERS   **********\n ********** ********** **********/\nstruct Filter {\n   float a;\n   float b;\n   float c;\n   float d;\n   float e;\n   float f;\n   float g;\n   float h;\n   float i;\n};\n\n// Apply a 9*9 filter to a pixel\nvec4 applyFilter(Filter f, vec2 fragCoord, vec4 fragColor) {\n    return vec4(\n        f.a * texture(iChannel0, (fragCoord+vec2(-1.,-1.))/iResolution.xy).rgb\n            + f.b * texture(iChannel0, (fragCoord+vec2(0.,-1.))/iResolution.xy).rgb\n            + f.c * texture(iChannel0, (fragCoord+vec2(1.,-1.))/iResolution.xy).rgb\n            + f.d * texture(iChannel0, (fragCoord+vec2(-1.,0.))/iResolution.xy).rgb\n            + f.e * fragColor.rgb\n            + f.f * texture(iChannel0, (fragCoord+vec2(1.,0.))/iResolution.xy).rgb\n            + f.g * texture(iChannel0, (fragCoord+vec2(-1.,1.))/iResolution.xy).rgb\n            + f.h * texture(iChannel0, (fragCoord+vec2(0.,1.))/iResolution.xy).rgb\n            + f.i * texture(iChannel0, (fragCoord+vec2(1.,1.))/iResolution.xy).rgb,\n        fragColor.a\n        );\n}\n\n// 9*9 filters collection\n#define SHARP_4 Filter(0.,-1.,0.,-1.,5.,-1.,0.,-1.,0.)\n#define SHARP_8 Filter(-1.,-1.,-1.,-1.,9.,-1.,-1.,-1.,-1.)\n#define VERTI_SOBEL Filter(-1.,-2.,-1.,0.,0.,0.,1.,2.,1.)\n#define HORIZ_SOBEL Filter(1.,0.,-1.,2.,0.,-2.,1.,0.,-1.)\n#define AVG_4_20 Filter(0.,.2,0.,.2,.2,.2,0.,.2,0.)\n#define AVG_4_60 Filter(0.,.1,0.,.1,.6,.1,0.,.1,0.)\n\n/********** ********** **********\n **********    LUT     **********\n ********** ********** **********/\n \n// Sample the color on 9 bits\nvec4 sample9Bits(vec4 fragColor) {\n    return vec4(\n        float(int(8.*fragColor.r))/8.,\n        float(int(8.*fragColor.g))/8.,\n        float(int(8.*fragColor.b))/8.,\n        fragColor.a\n    );\n}\n \n/********** ********** **********\n **********    MAIN    **********\n ********** ********** **********/\n \n#define OFF vec4(0.,0.,0.,1.)\n#define ON vec4(1.,1.,1., 1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int MODE = int(texelFetch(iChannel1, modeCoordPixels, 0).x);\n    if (fragCoord.x < 20. && fragCoord.y < 20.) {\n        // Show mode\n        fragColor = OFF;\n            if (fragCoord.x > 2. && fragCoord.x < 5. && fragCoord.y > 2. && fragCoord.y < 17.)\n            { // whole vertical\n                if (MODE >= 10)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 8. && fragCoord.x < 11. && fragCoord.y > 14. && fragCoord.y < 17.)\n            { // top top left\n                if (MODE % 10 == 0 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 7 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 8. && fragCoord.x < 11. && fragCoord.y > 11. && fragCoord.y < 14.)\n            { // top left\n                if (MODE % 10 == 0 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 8. && fragCoord.x < 11. && fragCoord.y > 8. && fragCoord.y < 11.)\n            { // middle left\n                if (MODE % 10 == 0 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 8. && fragCoord.x < 11. && fragCoord.y > 5. && fragCoord.y < 8.)\n            { // bottom left\n                if (MODE % 10 == 0 || MODE % 10 == 2 || MODE % 10 == 6 || MODE % 10 == 8)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 8. && fragCoord.x < 11. && fragCoord.y > 2. && fragCoord.y < 5.)\n            { // bottom bottom left\n                if (MODE % 10 == 0 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 11. && fragCoord.x < 14. && fragCoord.y > 14. && fragCoord.y < 17.)\n            { // top top middle\n                if (MODE % 10 == 0 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 7 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            }else if (fragCoord.x > 11. && fragCoord.x < 14. && fragCoord.y > 8. && fragCoord.y < 11.)\n            { // middle middle\n                if (MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            }else if (fragCoord.x > 11. && fragCoord.x < 14. && fragCoord.y > 2. && fragCoord.y < 5.)\n            { // bottom bottom middle\n                if (MODE % 10 == 0 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 5  || MODE % 10 == 6 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 14. && fragCoord.x < 17. && fragCoord.y > 14. && fragCoord.y < 17.)\n            { // top top right\n                if (MODE % 10 == 0 || MODE % 10 == 1 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 7 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 14. && fragCoord.x < 17. && fragCoord.y > 11. && fragCoord.y < 14.)\n            { // top right\n                if (MODE % 10 == 0 || MODE % 10 == 1 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 7 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 14. && fragCoord.x < 17. && fragCoord.y > 8. && fragCoord.y < 11.)\n            { // middle right\n                if (MODE % 10 == 0 || MODE % 10 == 1 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 7 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 14. && fragCoord.x < 17. && fragCoord.y > 5. && fragCoord.y < 8.)\n            { // bottom right\n                if (MODE % 10 == 0 || MODE % 10 == 1 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 7 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            } else if (fragCoord.x > 14. && fragCoord.x < 17. && fragCoord.y > 2. && fragCoord.y < 5.)\n            { // bottom bottom right\n                if (MODE % 10 == 0 || MODE % 10 == 1 || MODE % 10 == 2 || MODE % 10 == 3 || MODE % 10 == 4 || MODE % 10 == 5 || MODE % 10 == 6 || MODE % 10 == 7 || MODE % 10 == 8 || MODE % 10 == 9)\n                {\n                    fragColor = ON;\n                }\n            }\n    } else {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        if (MODE == 1 || MODE == 3 || MODE == 5 || MODE == 7) { // OBJECT BORDERS\n            float d = texture(iChannel0, (fragCoord+vec2(0.,-1.))/iResolution.xy).a;\n            float l = texture(iChannel0, (fragCoord+vec2(-1.,0.))/iResolution.xy).a;\n            if (fragColor.a != d ||fragColor.a != l)\n            {\n                fragColor = vec4(0.05, 0.05, 0.05, fragColor.a);\n            }\n        }\n        if (MODE == 4 || MODE == 5 || MODE == 6 || MODE == 7) { // SAMPLE 8 BITS\n            float d = texture(iChannel0, (fragCoord+vec2(0.,-1.))/iResolution.xy).a;\n            float l = texture(iChannel0, (fragCoord+vec2(-1.,0.))/iResolution.xy).a;\n            fragColor = sample9Bits(fragColor);\n        }\n        // Some other filters because why not\n        if (MODE == 9) { // OBJECT BORDERS ONLY\n            float d = texture(iChannel0, (fragCoord+vec2(0.,-1.))/iResolution.xy).a;\n            float l = texture(iChannel0, (fragCoord+vec2(-1.,0.))/iResolution.xy).a;\n            if (fragColor.a != d ||fragColor.a != l)\n            {\n                fragColor = ON;\n            } else {\n                fragColor = OFF;\n            }\n        } else if (MODE == 10) { // NEGATIVE\n            fragColor = vec4(1.,1.,1.,1.)-fragColor;\n        } else if (MODE == 11) { // BLUR MODE 1\n            fragColor = applyFilter(AVG_4_60, fragCoord, fragColor);\n        } else if (MODE == 12) { // BLUR MODE 2\n            fragColor = applyFilter(AVG_4_20, fragCoord, fragColor);\n        } else if (MODE == 13) { // SHARP MODE 1\n            fragColor = applyFilter(SHARP_4, fragCoord, fragColor);\n        } else if (MODE == 14) { // SHARP MODE 2\n            fragColor = applyFilter(SHARP_8, fragCoord, fragColor);\n        } else if (MODE == 15) { // COLOR BORDERS\n            fragColor = length(applyFilter(SHARP_4, fragCoord, fragColor)-fragColor)*ON;\n        } else if (MODE == 16) { // COLOR BORDERS\n            fragColor = length(applyFilter(SHARP_8, fragCoord, fragColor)-fragColor)*ON;\n        }\n    }\n    fragColor.a = 1.;\n}\n/*\nThe MIT License (MIT)\n\nCopyright © 2023 Théo GOUREAU\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and\nassociated documentation files (the “Software”), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial\nportions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT\nLIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/********** ********** **********\n **********    CONST   **********\n ********** ********** **********/\n \n// Config\n#define LOOK_AT_XYZ vec3(0., 0., 0.)\n#define CAMERA_APERTURE 50.\n#define SENSITIVITY_LAT 0.02\n#define SENSITIVITY_LON 0.05\n#define SENSITIVITY_RAD 0.2\n#define DEFAULTCOLOR vec4(0., 0., 0., -1.)\n#define time 0.5*iTime\n\n// Values\n#define EPSILON 0.001\n#define PI 3.141592653589793\n#define COPERNIC vec3(1., 2.718281828459045, 3.141592653589793)\n\n// Persistence\nconst ivec2 cameraCoordPixels = ivec2(31, 1);\nconst ivec2 lightsCoordPixels = ivec2(31, 2);\nconst ivec2 modeCoordPixels = ivec2(31, 3);\n\n// Game of life\n#define GOL_SIZE 60\n#define GOL_FREQ 4\n\n/********** ********** **********\n **********   STRUCTS  **********\n ********** ********** **********/\n \n// Camera (will be initialized with camera())\nstruct Camera {\n    vec3 obs;\n    vec3 view;\n    vec3 up;\n    vec3 horiz;\n    float h;\n    float w;\n    float z;\n};\n\n// Ray\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n// Light\nstruct Light {\n   vec3 center;\n   vec4 color;\n   int lightUID; // cf. Sphere::lightUID\n};\n\n// Intersection\nstruct Intersection {\n    bool intersects;        // Either there is an intersection (other attributes are non-deterministic if this is false)\n    vec3 intersectionPoint; // The intersection point\n    vec3 normalDirection;   // The normalized normal vector to the intersection surface\n    float distanceToCamera; // The distance to ray.origin\n    vec2 colorUv;           // (might not be implemented) Coordinates for the texture on the object\n};\n\n// Color\nstruct Texture {\n    bool isSimpleColor;\n    vec4 simpleColor;\n    int iChannelIndex;\n    float scale;\n};\n\n// 3D objects\n#define SPHERE 0\nstruct Sphere {\n   vec3 center;\n   float r;\n   int lightUID; // Used to check if the sphere is a light and to avoid shading itself\n};\n\n#define PLANE 1\nstruct Plane {\n    vec3 vertex;\n    vec3 normal;\n};\n\n#define CYLINDER 2\nstruct Cylinder {\n    vec3 origin;\n    vec3 dir;\n    float r;\n    float h;\n};\n\n#define RECTANGLE 3\nstruct Rectangle {\n    Plane p;\n    float w;\n    float h;\n    vec3 copernic;\n    bool normalizeUv;\n};\n\n#define DISK 4\nstruct Disk {\n    Plane p;\n    float r;\n};\n\nstruct Object {\n    int type;\n    int index;\n    Texture textureColor;\n    int id; // Used to find the borders between objects\n};\n\n/********** ********** **********\n **********  FUNCTIONS **********\n ********** ********** **********/\n \n // Initialize the camera\n Camera camera(in vec3 obs, in vec3 lookAt, in float aperture, in vec3 iResolution) {\n    Camera camera;\n    camera.obs = obs;\n    camera.view = normalize(lookAt - obs);\n    camera.horiz = normalize(cross(vec3(0., 0., 1.), camera.view));\n    camera.up = normalize(cross(camera.view, camera.horiz));\n    camera.h = iResolution.y;\n    camera.w = iResolution.x;\n    camera.z = camera.h/2./tan(radians(aperture)/2.);\n    return camera;\n}\n\n// Initialize the ray\nRay launch(in Camera camera, in vec2 XY) {\n   Ray ray;\n   ray.origin = camera.obs;\n   ray.dir = camera.z*camera.view+(XY.x-camera.w/2.)*camera.horiz+(XY.y-camera.h/2.)*camera.up;\n   return ray;\n}\n\n// Create a null intersection\nIntersection intersectionEmpty() {\n    return Intersection(\n        false,\n        vec3(0., 0., 0.),\n        vec3(0., 0., 0.),\n        -1.,\n        vec2(0., 0.)\n    );\n}\n\n// Returns the nearest intersection if it exists\nIntersection bestIntersection(Intersection i1, Intersection i2) {\n    if (i1.intersects || i2.intersects)\n    {\n        if (!i2.intersects)\n        {\n            return i1;\n        } else if (!i1.intersects) {\n            return i2;\n        } else if (i1.distanceToCamera <= i2.distanceToCamera) {\n            return i1;\n        } else {\n            return i2;\n        }\n    } else {\n        return intersectionEmpty();\n    }\n}\n\n// Create a Texture object that is a simple color\nTexture TextureSimpleColor(float r, float g, float b) {\n    Texture t;\n    t.isSimpleColor = true;\n    t.simpleColor = vec4(r, g, b, 1.);\n    return t;\n}\n\n// Create a Texture object that is from a iChannel (default scale: 1.)\nTexture TextureTexturedColor(int iChannelIndex) {\n    Texture t;\n    t.isSimpleColor = false;\n    t.iChannelIndex = iChannelIndex;\n    t.scale = 1.;\n    return t;\n}\n\n// Create a Texture object that is from a iChannel\nTexture TextureTexturedColor(int iChannelIndex, float scale) {\n    Texture t;\n    t.isSimpleColor = false;\n    t.iChannelIndex = iChannelIndex;\n    t.scale = scale;\n    return t;\n}\n\n// Cel-sahding sampling (cf. https://fr.wikipedia.org/wiki/Ombrage_de_cellulo%C3%AFd#Seuillage_des_ombres)\nfloat sampleFactor(float f) {\n    if (f > .6)\n    {\n        return .8;\n    } else if (f > .4) {\n        return .6;\n    } else if (f > .2) {\n        return .4;\n    } else {\n        return .2;\n    }\n}\n\n/********** ********** **********\n ********** INTERSECT  **********\n ********** ********** **********/\n/*\n    @interface\n    |void intersect_type(in Ray ray, in Type obj, out Intersection intersection);\n    |@Params(in)\n    ||Ray ray: the Ray to check the intersection with\n    ||Type obj: the object to check the intersection with\n    |@Params(out)\n    ||Intersection intersection: data about the intersection\n*/\n\nvoid intersect_sphere(in Ray ray, in Sphere sphere, out Intersection intersection) {\n    intersection = intersectionEmpty();\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.*dot(ray.dir, ray.origin-sphere.center);\n    float c = dot(ray.origin-sphere.center, ray.origin-sphere.center)-pow(sphere.r, 2.);\n    float D = pow(b, 2.)-4.*a*c;\n    if (D < 0.) {\n        intersection.intersects = false;\n    } else if (D == 0.) { \n        float t = -b/2./a;\n        if (t > 0.) {\n            intersection.distanceToCamera = t;\n            intersection.intersects = true;\n        } else {\n            intersection.intersects = false;\n        }\n    } else if (D > 0.) { \n        float t1 = (-b-sqrt(D))/2./a;\n        float t2 = (-b+sqrt(D))/2./a;\n        if (t1 > 0.)\n        {\n            intersection.distanceToCamera = t1;\n            intersection.intersects = true;\n        } else if (t2 > 0.) {\n            intersection.distanceToCamera = t2;\n            intersection.intersects = true;\n        }\n    }\n    if (intersection.intersects)\n    {\n        intersection.intersectionPoint = ray.origin + intersection.distanceToCamera*ray.dir;\n        intersection.normalDirection = normalize(intersection.intersectionPoint - sphere.center);\n        intersection.colorUv = vec2(\n            acos(dot(intersection.normalDirection, vec3(0., 0., 1.)))*sphere.r,\n            acos(dot(intersection.normalDirection, vec3(0., 1., 0.)))*sphere.r\n        );\n    }\n}\n\nvoid intersect_plane(in Ray ray, in Plane plane, out Intersection intersection) {\n    intersection = intersectionEmpty();\n    float denominator = dot(ray.dir, plane.normal);\n    if (denominator != 0.)\n    {\n        float numerator = dot(plane.vertex - ray.origin, plane.normal);\n        if (numerator/denominator >= 0.)\n        {\n            intersection.intersects = true;\n            intersection.distanceToCamera = numerator/denominator;\n            intersection.intersectionPoint = ray.origin + intersection.distanceToCamera*ray.dir;\n            intersection.normalDirection = normalize(plane.normal);\n            vec3 axe1 = COPERNIC - plane.vertex;\n            vec3 axe2 = cross(axe1, plane.normal);\n            intersection.colorUv = vec2(\n                dot(intersection.intersectionPoint - plane.vertex, axe1),\n                dot(intersection.intersectionPoint - plane.vertex, axe2)\n            );\n        }\n    }\n}\n\nvoid intersect_cylinder(in Ray ray, in Cylinder cylinder, out Intersection intersection) {\n    intersection = intersectionEmpty();\n    vec3 dc = normalize(cylinder.dir);\n    vec3 A = ray.origin-cylinder.origin-dot(dc, ray.origin-cylinder.origin)*dc;\n    vec3 B = ray.dir-dot(dc, ray.dir)*dc;\n    float a = dot(B, B);\n    float b = 2.*dot(A, B);\n    float c = dot(A, A)-pow(cylinder.r, 2.);\n    float D = pow(b, 2.)-4.*a*c;\n    if (D < 0.) {\n        intersection.intersects = false;\n    } else if (D == 0.) { \n        float t = -b/2./a;\n        if (t > 0.) {\n            intersection.distanceToCamera = t;\n            intersection.intersects = true;\n        } else {\n            intersection.intersects = false;\n        }\n    } else if (D > 0.) {\n        intersection.distanceToCamera = (-b-sqrt(D))/2./a;\n        intersection.intersects = true;\n        intersection.intersectionPoint = ray.origin + intersection.distanceToCamera*ray.dir;\n        intersection.normalDirection = normalize(intersection.intersectionPoint - dot(intersection.intersectionPoint, cylinder.dir)*cylinder.dir);\n        intersection.colorUv = vec2(\n            acos(dot(intersection.normalDirection, normalize(cross(cylinder.dir, COPERNIC))))*cylinder.r,\n            dot(intersection.intersectionPoint, cylinder.dir)\n);\n        if (\n            length(dot(intersection.intersectionPoint-cylinder.origin, dc)*dc) > cylinder.h\n            || intersection.distanceToCamera < 0.\n        ) {\n            intersection = intersectionEmpty();\n        }\n        if (!intersection.intersects)\n        {\n            intersection.distanceToCamera = (-b+sqrt(D))/2./a;\n            intersection.intersects = true;\n            intersection.intersectionPoint = ray.origin + intersection.distanceToCamera*ray.dir;\n            intersection.normalDirection = normalize(intersection.intersectionPoint - dot(intersection.intersectionPoint, cylinder.dir)*cylinder.dir);\n            intersection.colorUv = vec2(\n                acos(dot(intersection.normalDirection, normalize(cross(cylinder.dir, COPERNIC))))*cylinder.r,\n                dot(intersection.intersectionPoint, cylinder.dir)\n            );\n            if (\n                length(dot(intersection.intersectionPoint-cylinder.origin, dc)*dc) > cylinder.h\n                || intersection.distanceToCamera < 0.\n            ) {\n                intersection = intersectionEmpty();\n            }\n        }\n    }\n}\n\nvoid intersect_rectangle(in Ray ray, in Rectangle rectangle, out Intersection intersection) {\n    intersect_plane(ray, rectangle.p, intersection);\n    if (intersection.intersects)\n    {\n        float x = dot(intersection.intersectionPoint - rectangle.p.vertex, normalize(rectangle.copernic));\n        float y = dot(intersection.intersectionPoint - rectangle.p.vertex, cross(normalize(rectangle.copernic), normalize(rectangle.p.normal)));\n        if (x < 0. || x > rectangle.w || y < 0. || y > rectangle.h)\n        {\n            intersection = intersectionEmpty();\n        } else if (rectangle.normalizeUv) {\n            vec3 axe1 = rectangle.copernic;\n            vec3 axe2 = cross(rectangle.copernic, rectangle.p.normal);\n            intersection.colorUv = vec2(\n                dot(intersection.intersectionPoint - rectangle.p.vertex, axe1)/rectangle.w,\n                dot(intersection.intersectionPoint - rectangle.p.vertex, axe2)/rectangle.h\n            );\n        }\n    }\n}\n\nvoid intersect_disk(in Ray ray, in Disk disk, out Intersection intersection) {\n    intersect_plane(ray, disk.p, intersection);\n    if (intersection.intersects)\n    {\n        if (length(intersection.intersectionPoint - disk.p.vertex) > disk.r)\n        {\n            intersection = intersectionEmpty();\n        }\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Keyboard handler\n    Move:\n        W/Z   -> Move forward\n        S     -> Move backward\n        D     -> Move right\n        A/Q   -> Move left\n        SPACE -> Move up\n        SHIFT -> Move down\n    Light:\n        I     -> Turn the big lamp on\n        O     -> Turn the big lamp off\n        K     -> Turn the desk lamp on\n        L     -> Turn the desk lamp off\n    Predefined PoV:\n        C     -> [HOME] Global point of view + both lamps\n        V     -> Game of life                + no lamp\n        B     -> Look at the moon            + desk lamp only\n        N     -> Check into the bin          + big lamp only\n*/\n\n/********** ********** **********\n **********    CONST   **********\n ********** ********** **********/\n// Control\n#define MV_FORWARD1 KEY_W\n#define MV_FORWARD2 KEY_Z\n#define MV_BACKWARD KEY_S\n#define MV_RIGHT KEY_D\n#define MV_LEFT1 KEY_A\n#define MV_LEFT2 KEY_Q\n#define MV_UP KEY_SPACE\n#define MV_DOWN KEY_SHIFT\n#define DESK_LIGHT_OFF KEY_K\n#define DESK_LIGHT_ON KEY_L\n#define BIG_LIGHT_OFF KEY_I\n#define BIG_LIGHT_ON KEY_O\n#define MODE_UP KEY_UP\n#define MODE_DOWN KEY_DOWN\nconst int KEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_I = 73, KEY_K = 75, KEY_L = 76, KEY_N = 78,\n    KEY_O = 79, KEY_Q = 81, KEY_S = 83, KEY_V = 86, KEY_W = 87, KEY_Z = 90, KEY_SHIFT = 16, KEY_SPACE = 32,\n    KEY_UP = 38, KEY_DOWN = 40;\n\n// Predefined PoV\n/*\n    0 -- [Home] Global point of view\n    1 -- Game of life\n    2 -- Look at the moon\n    3 -- Check into the bin\n*/\n#define POV_0_KEY KEY_C\n#define CAM_LAT_PI 0.43\n#define CAM_LON_PI 1.11\n#define CAM_RAD 40.\n#define START_LIGHT vec4(1., 1., 0., 1.)\n\n#define POV_1_KEY KEY_V\n#define POV_1_CAM_LAT_PI 0.4\n#define POV_1_CAM_LON_PI 0.9\n#define POV_1_CAM_RAD 12.\n#define POV_1_LIGHTS vec4(0., 0., 0., 1.)\n\n#define POV_2_KEY KEY_B\n#define POV_2_CAM_LAT_PI 0.55\n#define POV_2_CAM_LON_PI 1.9\n#define POV_2_CAM_RAD 28.\n#define POV_2_LIGHTS vec4(1., 0., 0., 1.)\n\n#define POV_3_KEY KEY_N\n#define POV_3_CAM_LAT_PI 0.15\n#define POV_3_CAM_LON_PI 1.2\n#define POV_3_CAM_RAD 55.\n#define POV_3_LIGHTS vec4(0., 1., 0., 1.)\n\n/********** ********** **********\n **********  FUNCTIONS **********\n ********** ********** **********/\n \n// Returns the value of a the key code\nfloat is_key_down(int code) {\n    return texelFetch(iChannel0, ivec2(code, 0), 0).x;\n}\n\n// Get the value of this buffer at position re\nvec4 loadValue(ivec2 re) {\n    return texelFetch(iChannel1, re, 0 );\n}\n\n/********** ********** **********\n **********    MAIN    **********\n ********** ********** **********/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Keyboard handle\n    if (int(fragCoord.x) == cameraCoordPixels.x && int(fragCoord.y) == cameraCoordPixels.y)\n    {\n        if (iFrame <= 1)\n        {\n            // Start value\n            fragColor = vec4(CAM_LAT_PI*PI, CAM_LON_PI*PI, CAM_RAD, 1.);\n        } else {\n            // Previous state value\n            fragColor = loadValue(cameraCoordPixels);\n        }\n        // Update values\n        fragColor.x -= SENSITIVITY_LAT * (is_key_down(MV_UP) - is_key_down(MV_DOWN));\n        fragColor.y += SENSITIVITY_LON * (is_key_down(MV_RIGHT) - max(is_key_down(MV_LEFT1), is_key_down(MV_LEFT2)));\n        fragColor.z -= SENSITIVITY_RAD * (max(is_key_down(MV_FORWARD1), is_key_down(MV_FORWARD2)) - is_key_down(MV_BACKWARD));\n        // Keep values in domain\n        fragColor.x = min(max(fragColor.x, 0.1), PI-0.1);\n        fragColor.z = min(max(fragColor.z, 0.01), 55.);\n        // Predefined PoV\n        if (is_key_down(POV_3_KEY) > .1)\n        {\n            fragColor = vec4(POV_3_CAM_LAT_PI*PI, POV_3_CAM_LON_PI*PI, POV_3_CAM_RAD, 1.);\n        }\n        if (is_key_down(POV_2_KEY) > .1)\n        {\n            fragColor = vec4(POV_2_CAM_LAT_PI*PI, POV_2_CAM_LON_PI*PI, POV_2_CAM_RAD, 1.);\n        }\n        if (is_key_down(POV_1_KEY) > .1)\n        {\n            fragColor = vec4(POV_1_CAM_LAT_PI*PI, POV_1_CAM_LON_PI*PI, POV_1_CAM_RAD, 1.);\n        }\n        if (is_key_down(POV_0_KEY) > .1)\n        {\n            fragColor = vec4(CAM_LAT_PI*PI, CAM_LON_PI*PI, CAM_RAD, 1.);\n        }\n    }\n    if (int(fragCoord.x) == lightsCoordPixels.x && int(fragCoord.y) == lightsCoordPixels.y)\n    {\n        if (iFrame <= 1)\n        {\n            // Start value\n            fragColor = START_LIGHT;\n        } else {\n            // Previous state value\n            fragColor = loadValue(lightsCoordPixels);\n        }\n        // Update values\n        if (is_key_down(DESK_LIGHT_ON) > .1)\n        {\n            fragColor.x = 1.;\n        }\n        if (is_key_down(DESK_LIGHT_OFF) > .1)\n        {\n            fragColor.x = 0.;\n        }\n        if (is_key_down(BIG_LIGHT_ON) > .1)\n        {\n            fragColor.y = 1.;\n        }\n        if (is_key_down(BIG_LIGHT_OFF) > .1)\n        {\n            fragColor.y = 0.;\n        }\n        // Predefined PoV\n        if (is_key_down(POV_3_KEY) > .1)\n        {\n            fragColor = POV_3_LIGHTS;\n        }\n        if (is_key_down(POV_2_KEY) > .1)\n        {\n            fragColor = POV_2_LIGHTS;\n        }\n        if (is_key_down(POV_1_KEY) > .1)\n        {\n            fragColor = POV_1_LIGHTS;\n        }\n        if (is_key_down(POV_0_KEY) > .1)\n        {\n            fragColor = START_LIGHT;\n        }\n    }\n    if (int(fragCoord.x) == modeCoordPixels.x && int(fragCoord.y) == modeCoordPixels.y)\n    {\n        if (iFrame <= 1)\n        {\n            // Start value\n            fragColor = vec4(2.,0.,0.,0.);\n        } else {\n            // Previous state value\n            fragColor = loadValue(modeCoordPixels);\n        }\n        // Update values\n        if (is_key_down(MODE_UP) > .1)\n        {\n            fragColor.x += 1.;\n        }\n        if (is_key_down(MODE_DOWN) > .1)\n        {\n            fragColor.x -= 1.;\n        }\n        fragColor.x = min(max(fragColor.x, 0.), 19.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Game of life handler\n    cf. https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n*/\n\n/********** ********** **********\n **********    CONST   **********\n ********** ********** **********/\n\n// The live/die rules (must be floats)\n#define minBirth 3.\n#define maxBirth 3.\n#define minLive  2.\n#define maxLive  3.\n\n// The generation method in [three, canon, pentadecathlon, allInOne]\n#define GENE allInOne \n\n/********** ********** **********\n ********** GENERATION **********\n ********** ********** **********/\n/*\n    @interface\n    |bool shapeName(ivec2 re);\n    |@Params(in)\n    ||ivec2 re: the coordinates of a cell\n    |@Params(out)\n    ||bool __res__: the cell of coordinates re is part of the shape\n*/\n\n// Periodic 3 cells blinker\nbool three(ivec2 re) {\n    return \n           (re.x == 12 && re.y == 45)\n        || (re.x == 13 && re.y == 45)\n        || (re.x == 14 && re.y == 45);\n}\n\n// A single Gosper's glider canon\nbool canon(ivec2 re) {\n    return \n           (re.x == 11 && re.y == 35)\n        || (re.x == 11 && re.y == 34)\n        || (re.x == 12 && re.y == 35)\n        || (re.x == 12 && re.y == 34)\n        || (re.x == 21 && re.y == 35)\n        || (re.x == 21 && re.y == 34)\n        || (re.x == 21 && re.y == 33)\n        || (re.x == 22 && re.y == 36)\n        || (re.x == 22 && re.y == 32)\n        || (re.x == 23 && re.y == 37)\n        || (re.x == 23 && re.y == 31)\n        || (re.x == 24 && re.y == 37)\n        || (re.x == 24 && re.y == 31)\n        || (re.x == 25 && re.y == 34)\n        || (re.x == 26 && re.y == 36)\n        || (re.x == 26 && re.y == 32)\n        || (re.x == 27 && re.y == 35)\n        || (re.x == 27 && re.y == 34)\n        || (re.x == 27 && re.y == 33)\n        || (re.x == 28 && re.y == 34)\n        || (re.x == 31 && re.y == 37)\n        || (re.x == 31 && re.y == 36)\n        || (re.x == 31 && re.y == 35)\n        || (re.x == 32 && re.y == 37)\n        || (re.x == 32 && re.y == 36)\n        || (re.x == 32 && re.y == 35)\n        || (re.x == 33 && re.y == 38)\n        || (re.x == 33 && re.y == 34)\n        || (re.x == 35 && re.y == 39)\n        || (re.x == 35 && re.y == 38)\n        || (re.x == 35 && re.y == 34)\n        || (re.x == 35 && re.y == 33)\n        || (re.x == 45 && re.y == 37)\n        || (re.x == 45 && re.y == 36)\n        || (re.x == 46 && re.y == 37)\n        || (re.x == 46 && re.y == 36);\n}\n\n// A pentadecathlon (perdiodic)\nbool pentadecathlon(ivec2 re) {\n    return \n           (re.x == 16 && re.y == 15)\n        || (re.x == 16 && re.y == 16)\n        || (re.x == 16 && re.y == 17)\n        || (re.x == 17 && re.y == 15)\n        || (re.x == 17 && re.y == 17)\n        || (re.x == 18 && re.y == 15)\n        || (re.x == 18 && re.y == 16)\n        || (re.x == 18 && re.y == 17)\n        || (re.x == 19 && re.y == 15)\n        || (re.x == 19 && re.y == 16)\n        || (re.x == 19 && re.y == 17)\n        || (re.x == 20 && re.y == 15)\n        || (re.x == 20 && re.y == 16)\n        || (re.x == 20 && re.y == 17)\n        || (re.x == 21 && re.y == 15)\n        || (re.x == 21 && re.y == 16)\n        || (re.x == 21 && re.y == 17)\n        || (re.x == 22 && re.y == 15)\n        || (re.x == 22 && re.y == 17)\n        || (re.x == 23 && re.y == 15)\n        || (re.x == 23 && re.y == 16)\n        || (re.x == 23 && re.y == 17);\n}\n\n// The three previous shapes in one picture\nbool allInOne(ivec2 re) {\n    return three(re) || canon(re) || pentadecathlon(re);\n}\n\n/********** ********** **********\n ********** FUNCTIONS  **********\n ********** ********** **********/\n \n// Get the value at re with an offset. Handles zero-padding at borders.\nvec4 loadValue( ivec2 re, int offset ) {\n    if (re.x < 0 || re.x >= GOL_SIZE || re.y < 0 || re.y >= GOL_SIZE)\n    {\n        return vec4(1., 1., 1., 1.);\n    }\n    return texelFetch(iChannel1, re+ivec2(offset, 0), 0 );\n}\n\n// Returns the amount of alive neighbors\nfloat sumNeighbors( ivec2 re, int offset ) {\n    return 8. -\n        (  loadValue(re+ivec2(-1, -1), offset).x\n        +  loadValue(re+ivec2( 0, -1), offset).x\n        +  loadValue(re+ivec2( 1, -1), offset).x\n        +  loadValue(re+ivec2(-1,  0), offset).x\n        +  loadValue(re+ivec2( 1,  0), offset).x\n        +  loadValue(re+ivec2(-1,  1), offset).x\n        +  loadValue(re+ivec2( 0,  1), offset).x\n        +  loadValue(re+ivec2( 1,  1), offset).x);\n}\n\n// Returns the next state of a given cell\nvec4 move( ivec2 re, int offset, vec4 current ) {\n    float n = sumNeighbors(re, offset);\n    if (current.x < 0.5) { // currently alive\n        if (n >= minLive && n <= maxLive) {\n            return vec4(0., 0., 0., 1.); // alive\n        } else {\n            return vec4(1., 1., 1., 1.); // dead\n        }\n    } else { // currently dead\n        if (n >= minBirth && n <= maxBirth) {\n            return vec4(0., 0., 0., 1.); // alive\n        } else {\n            return vec4(1., 1., 1., 1.); // dead\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 re = ivec2(fragCoord);\n    if (iFrame == 0 // First frame\n        && re.x >= 0 && re.x < GOL_SIZE // Buffer 1\n        && re.y >= 0 && re.y < GOL_SIZE)\n    {\n        // Generate the first state\n        if (GENE(re))\n        {\n            fragColor = vec4(0., 0., 0., 1.);\n        } else {\n            fragColor = vec4(1., 1., 1., 1.);\n        }\n    } else {\n        if (re.x >= 0 && re.x < GOL_SIZE // Buffer 1\n            && re.y >= 0 && re.y < GOL_SIZE)\n        {\n            if (iFrame % GOL_FREQ == 0)\n            {\n                // Compute the next state\n                fragColor = move( re-ivec2(0, 0), GOL_SIZE, loadValue( re+ivec2(0, 0), GOL_SIZE ) );\n            } else {\n                // Stay still\n                fragColor = loadValue( re-ivec2(0, 0), 0 );\n            }\n        } else if (re.x >= GOL_SIZE && re.x < 2*GOL_SIZE // Buffer 2\n            && re.y >= 0 && re.y < GOL_SIZE)\n        {\n            if (iFrame % GOL_FREQ == GOL_FREQ/2)\n            {\n                // Compute the next state\n                fragColor = move( re-ivec2(GOL_SIZE, 0), 0, loadValue( re-ivec2(GOL_SIZE, 0), 0 ) );\n            } else {\n                // Stay still\n                fragColor = loadValue( re-ivec2(GOL_SIZE, 0), GOL_SIZE );\n            }\n        } else {\n            fragColor = vec4(0., 0., 0., 1.);\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/* The actual scene without effects\n*/\n\n/********** ********** **********\n **********  FUNCTIONS **********\n ********** ********** **********/\n\n// Compute the Camera xyz from its polar coordinates stored in buffer A\nvec3 cameraXYZ() {\n    vec3 latLonRad = texelFetch(iChannel1, cameraCoordPixels, 0).xyz;\n    return latLonRad.z*vec3(\n        sin(latLonRad.x)*sin(latLonRad.y),\n        sin(latLonRad.x)*cos(latLonRad.y),\n        cos(latLonRad.x)\n    );\n}\n\n// Get the state of a cell (game of life)\nvec4 loadGolValue( vec2 uv ) {\n    ivec2 re = ivec2(int(float(GOL_SIZE)*uv.x), int(float(GOL_SIZE)*uv.y));\n    if (iFrame % GOL_FREQ < GOL_FREQ/2) {\n        return texelFetch(iChannel0, re, 0 );\n    } else {\n        return texelFetch(iChannel0, re+ivec2(GOL_SIZE, 0), 0 );\n    }\n}\n\n// Compute the actual color from a Texture (simple color + actual texture)\nvec4 actualColor(Texture t, vec2 uv) {\n    if (t.isSimpleColor)\n    {\n        return t.simpleColor;\n    }\n    if (t.iChannelIndex == 0)\n    {\n        return loadGolValue(uv);\n    } else if (t.iChannelIndex == 1)\n    {\n        return texture(iChannel1, t.scale*uv);\n    } else if (t.iChannelIndex == 2)\n    {\n        return texture(iChannel2, 10.*t.scale*vec2(1.-uv.x,uv.y));\n    } else if (t.iChannelIndex == 3)\n    {\n        return texture(iChannel3, t.scale*uv);\n    } else\n    {\n        return vec4(0., 0., 0., 1.);\n    } \n}\n\n/********** ********** **********\n **********    MAIN    **********\n ********** ********** **********/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // UPDATE GOL\n    loadGolValue(fragCoord/iResolution.y);\n    // GET MODE\n    int MODE = int(texelFetch(iChannel1, modeCoordPixels, 0).x);\n    // DEFAULT COLOR\n    fragColor = DEFAULTCOLOR;\n    // LOAD LIGTHS STATE\n    vec2 lightsState = texelFetch(iChannel1, lightsCoordPixels, 0).xy;\n    // CAMERA INIT\n    Camera camera = camera(\n        cameraXYZ(),\n        LOOK_AT_XYZ,\n        CAMERA_APERTURE,\n        iResolution\n    );\n    // DATA INIT\n    Sphere[] spheres = Sphere[](\n        Sphere(vec3(8.,3.,0.),.9,-1),\n        Sphere(vec3(8.,3.,5.),.3,-1),\n        Sphere(vec3(5.,0,6.7),.55,int(2.*lightsState.x)-1),\n        Sphere(vec3(2.1,-2.51,0.4),0.04,2),\n        Sphere(vec3(1000., -cos(iTime/50.)*800., 500.),30.,3),\n        Sphere(vec3(-26.,9.,-10.),1.9,-1),\n        Sphere(vec3(-26.,9.,5.),.7,-1),\n        Sphere(vec3(-17.,0.,12.),1.0,int(5.*lightsState.y)-1)\n    );\n    Plane[] planes = Plane[](\n        Plane(vec3(0.,0.,-20.),vec3(0.,0.,1.))\n    );\n    Cylinder[] cylinders = Cylinder[](\n        Cylinder(vec3(9.,4.,-5.),vec3(0.,0.,1.),.5,5.),\n        Cylinder(vec3(9.,4.,-5.),vec3(0.,0.,1.),.5-EPSILON,5.),\n        Cylinder(vec3(-9.,4.,-5.),vec3(0.,0.,1.),.5,5.),\n        Cylinder(vec3(-9.,4.,-5.),vec3(0.,0.,1.),.5-EPSILON,5.),\n        Cylinder(vec3(9.,-4.,-5.),vec3(0.,0.,1.),.5,5.),\n        Cylinder(vec3(9.,-4.,-5.),vec3(0.,0.,1.),.5-EPSILON,5.),\n        Cylinder(vec3(-9.,-4.,-5.),vec3(0.,0.,1.),.5,5.),\n        Cylinder(vec3(-9.,-4.,-5.),vec3(0.,0.,1.),.5-EPSILON,5.),\n        Cylinder(vec3(8.,3.,2.5),vec3(0.,0.,1.),.2,2.5),\n        Cylinder(vec3(8.,3.,2.5),vec3(0.,0.,1.),.2-EPSILON,2.4),\n        Cylinder(vec3(6.6,1.6,6.4),vec3(1.,1.,-1.),.2,2.45),\n        Cylinder(vec3(6.6,1.6,6.4),vec3(1.,1.,-1.),.2-EPSILON,2.45),\n        Cylinder(vec3(5.,0.,7.5),vec3(0.,0.,1.),.4,.5),\n        Cylinder(vec3(5.,0.,7.5),vec3(0.,0.,1.),.4-EPSILON,.5),\n        Cylinder(vec3(-11.,-1,-8.),vec3(0.,0.,1.),1.5,2.),\n        Cylinder(vec3(-11.,-1,-8.),vec3(0.,0.,1.),1.5-EPSILON,2.),\n        Cylinder(vec3(-26.,9.,-2.5),vec3(0.,0.,1.),.4,7.5),\n        Cylinder(vec3(-26.,9.,-2.5),vec3(0.,0.,1.),.4-EPSILON,7.5),\n        Cylinder(vec3(-21.5,4.5,9.5),vec3(-1.,1.,-1.),.4,7.5),\n        Cylinder(vec3(-21.5,4.5,9.5),vec3(-1.,1.,-1.),.4-EPSILON,7.5),\n        Cylinder(vec3(-17.,0.,13.5),vec3(0.,0.,1.),.8,1.),\n        Cylinder(vec3(-17.,0.,13.5),vec3(0.,0.,1.),.8-EPSILON,1.)\n    );\n    Rectangle[] rectangles = Rectangle[](\n        Rectangle(Plane(vec3(-10.,5.,0.),vec3(0.,0.,1.)),20.,10.,vec3(1.,0.,0.),false),\n        Rectangle(Plane(vec3(10.,5.,-1.),vec3(0.,0.,-1.)),20.,10.,vec3(-1.,0.,0.),false),\n        Rectangle(Plane(vec3(-10.,5.,-1.),vec3(0.,1.,0.)),20.,1.,vec3(1.,0.,0.),false),\n        Rectangle(Plane(vec3(10.,-5.,-1.),vec3(0.,-1.,0.)),20.,1.,vec3(-1.,0.,0.),false),\n        Rectangle(Plane(vec3(10.,-5.,0.),vec3(1.,0.,0.)),10.,1.,vec3(0.,1.,0.),false),\n        Rectangle(Plane(vec3(-10.,5.,0.),vec3(-1.,0.,0.)),10.,1.,vec3(0.,-1.,0.),false),\n        Rectangle(Plane(vec3(-2.5,2.5,5.),vec3(0.,0.,1.)),5.,5.,vec3(1.,0.,0.),false),\n        Rectangle(Plane(vec3(-2.45,2.45,4.95),vec3(0.,0.,1.)),4.9,4.9,vec3(1.,0.,0.),false),\n        Rectangle(Plane(vec3(-2.5,2.5,0.),vec3(0.,1.,0.)),5.,5.,vec3(1.,0.,0.),false),\n        Rectangle(Plane(vec3(-2.45,2.45,0.),vec3(0.,1.,0.)),4.9,4.95,vec3(1.,0.,0.),false),\n        Rectangle(Plane(vec3(2.5,-2.5,5.),vec3(1.,0.,0.)),5.,5.,vec3(0.,1.,0.),false),\n        Rectangle(Plane(vec3(2.45,-2.45,4.95),vec3(1.,0.,0.)),4.9,4.95,vec3(0.,1.,0.),false),\n        Rectangle(Plane(vec3(-2.5,2.5,5.),vec3(-1.,0.,0.)),5.,5.,vec3(0.,-1.,0.),false),\n        Rectangle(Plane(vec3(-2.45,2.45,4.95),vec3(-1.,0.,0.)),4.9,4.95,vec3(0.,-1.,0.),false),\n        Rectangle(Plane(vec3(-2.45,-2.45,0.05),vec3(0.,1.,0.)),4.9,4.9,vec3(1.,0.,0.),true),\n        Rectangle(Plane(vec3(2.5,-2.5,.6),vec3(0.,-1.,0.)),.6,3.8,vec3(-1.,0.,0.),false),\n        Rectangle(Plane(vec3(-1.9,-2.5,.6),vec3(0.,-1.,0.)),.6,3.8,vec3(-1.,0.,0.),false),\n        Rectangle(Plane(vec3(2.5,-2.5,0.),vec3(0.,-1.,0.)),5.,.6,vec3(-1.,0.,0.),false),\n        Rectangle(Plane(vec3(2.5,-2.5,4.4),vec3(0.,-1.,0.)),5.,.6,vec3(-1.,0.,0.),false),\n        Rectangle(Plane(vec3(30.,20.,80.),vec3(-1.,-1.,0.)),52.,14.1421356237,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(20.,30.,80.),vec3(0.,-1.,0.)),100.,90.,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,-80.,80.),vec3(-1.,0.,0.)),60.,100.,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,-80.,0.),vec3(-1.,0.,0.)),20.,100.,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,15.,20.),vec3(-1.,0.,0.)),20.,5.,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,-80.,20.),vec3(-1.,0.,0.)),20.,75.,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,20.,20.),vec3(-1.,-1.,0.)),2.,14.1421356237,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,20.,22.),vec3(-1.,-1.,0.)),2.,14.1421356237,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,20.,24.),vec3(-1.,-1.,0.)),2.,14.1421356237,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,20.,26.),vec3(-1.,-1.,0.)),2.,14.1421356237,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,20.,28.),vec3(-1.,-1.,0.)),2.,14.1421356237,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,20.,18.),vec3(-1.,-1.,0.)),28.,14.1421356237,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,-80.,-20.),vec3(0.,1.,0.)),100.,100.,vec3(0.,0.,1.),false),\n        Rectangle(Plane(vec3(-70.,-70.,-20.),vec3(1.,0.,0.)),100.,100.,vec3(0.,0.,1.),false),\n        Rectangle(Plane(vec3(-70.,-80.,10.),vec3(1.,0.,0.)),70.,10.,vec3(0.,0.,1.),false),\n        Rectangle(Plane(vec3(30.,30.,80.),vec3(0.,0.,-1.)),100.,110.,vec3(-1.,0.,0.),false),\n        Rectangle(Plane(vec3(30.,4.5,20.),vec3(-1.,0.,0.)),20.,1.,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,5.5,9.5),vec3(-1.,0.,0.)),1.,9.5,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(30.,-5.,9.5),vec3(-1.,0.,0.)),1.,9.5,vec3(0.,0.,-1.),false),\n        Rectangle(Plane(vec3(-70.,30.,-10.),vec3(0.,0.,1.)),100.,110.,vec3(1.,0.,0.),false)\n    );\n    Disk[] disks = Disk[](\n        Disk(Plane(vec3(-11.,-1.,-9.9),vec3(0.,0.,1.)),1.5),\n        Disk(Plane(vec3(-17.,0,14.5),vec3(0.,0.,1.)),.8),\n        Disk(Plane(vec3(-17.,0,14.5-EPSILON),vec3(0.,0.,1.)),.8),\n        Disk(Plane(vec3(5.,0,8.),vec3(0.,0.,1.)),.4),\n        Disk(Plane(vec3(5.,0,8.-EPSILON),vec3(0.,0.,1.)),.4)\n    );\n    // DATA ENUMERATION\n    Object[] objects = Object[](\n        Object(PLANE, 0, TextureSimpleColor(0., 0., 0.),0), // Ground\n        Object(RECTANGLE, 0, TextureSimpleColor(.59, .32, .17),100), // Desk\n        Object(RECTANGLE, 1, TextureSimpleColor(.59, .32, .17),101), // Desk\n        Object(RECTANGLE, 2, TextureSimpleColor(.59, .32, .17),102), // Desk\n        Object(RECTANGLE, 3, TextureSimpleColor(.59, .32, .17),103), // Desk\n        Object(RECTANGLE, 4, TextureSimpleColor(.59, .32, .17),104), // Desk\n        Object(RECTANGLE, 5, TextureSimpleColor(.59, .32, .17),105), // Desk\n        Object(CYLINDER, 0, TextureSimpleColor(.7, .7, .7),106), // Desk leg\n        Object(CYLINDER, 1, TextureSimpleColor(.7, .7, .7),107), // Desk leg (autoshadow)\n        Object(CYLINDER, 2, TextureSimpleColor(.7, .7, .7),108), // Desk leg\n        Object(CYLINDER, 3, TextureSimpleColor(.7, .7, .7),109), // Desk leg (autoshadow)\n        Object(CYLINDER, 4, TextureSimpleColor(.7, .7, .7),110), // Desk leg\n        Object(CYLINDER, 5, TextureSimpleColor(.7, .7, .7),111), // Desk leg (autoshadow)\n        Object(CYLINDER, 6, TextureSimpleColor(.7, .7, .7),112), // Desk leg\n        Object(CYLINDER, 7, TextureSimpleColor(.7, .7, .7),113), // Desk leg (autoshadow)\n        Object(RECTANGLE, 6, TextureSimpleColor(.96, .96, .86),200), // Monitor out\n        Object(RECTANGLE, 7, TextureSimpleColor(1., 0., 0.),201), // Monitor in\n        Object(RECTANGLE, 8, TextureSimpleColor(.96, .96, .86),202), // Monitor out\n        Object(RECTANGLE, 9, TextureSimpleColor(1., 0., 0.),203), // Monitor in\n        Object(RECTANGLE, 10, TextureSimpleColor(.96, .96, .86),204), // Monitor out\n        Object(RECTANGLE, 11, TextureSimpleColor(1., 0., 0.),205), // Monitor in\n        Object(RECTANGLE, 12, TextureSimpleColor(.96, .96, .86),206), // Monitor out\n        Object(RECTANGLE, 13, TextureSimpleColor(1., 0., 0.),207), // Monitor in\n        Object(RECTANGLE, 14, TextureTexturedColor(MODE/19*2, .1),208), // Display\n        Object(RECTANGLE, 15, TextureSimpleColor(.96, .96, .86),209), // Monitor out\n        Object(RECTANGLE, 16, TextureSimpleColor(.96, .96, .86),209), // Monitor out\n        Object(RECTANGLE, 17, TextureSimpleColor(.96, .96, .86),209), // Monitor out\n        Object(RECTANGLE, 18, TextureSimpleColor(.96, .96, .86),209), // Monitor out\n        Object(SPHERE, 0, TextureSimpleColor(.7, .7, .7),300), // Desk lamp\n        Object(SPHERE, 1, TextureSimpleColor(.7, .7, .7),301), // Desk lamp\n        Object(SPHERE, 2, TextureSimpleColor(1., 0.83, 0.7),303), // Desk lamp light bulb\n        Object(CYLINDER, 8, TextureSimpleColor(.7, .7, .7),304), // Desk lamp\n        Object(CYLINDER, 9, TextureSimpleColor(.7, .7, .7),305), // Desk lamp (autoshadow)\n        Object(CYLINDER, 10, TextureSimpleColor(.7, .7, .7),306), // Desk lamp\n        Object(CYLINDER, 11, TextureSimpleColor(.7, .7, .7),307), // Desk lamp (autoshadow)\n        Object(CYLINDER, 12, TextureSimpleColor(.7, .7, .7),308), // Desk lamp\n        Object(CYLINDER, 13, TextureSimpleColor(.7, .7, .7),309), // Desk lamp (autoshadow)\n        Object(DISK, 3, TextureSimpleColor(.7, .7, .7),310), // Desk lamp\n        Object(DISK, 4, TextureSimpleColor(.7, .7, .7),311), // Desk lamp\n        Object(SPHERE, 3, TextureSimpleColor(.5, 0., 0.),310), // Monitor led\n        Object(RECTANGLE, 19, TextureSimpleColor(.52, .80, .92),400), // Wall SOUTH-WEST\n        Object(RECTANGLE, 20, TextureSimpleColor(.52, .80, .92),401), // Wall WEST\n        Object(RECTANGLE, 21, TextureSimpleColor(.52, .80, .92),402), // Wall SOUTH\n        Object(RECTANGLE, 22, TextureSimpleColor(.52, .80, .92),402), // Wall SOUTH\n        Object(RECTANGLE, 23, TextureSimpleColor(.52, .80, .92),402), // Wall SOUTH\n        Object(RECTANGLE, 24, TextureSimpleColor(.52, .80, .92),402), // Wall SOUTH\n        Object(RECTANGLE, 29, TextureSimpleColor(1., .35, .37),406), // Wall flag\n        Object(RECTANGLE, 28, TextureSimpleColor(1., .79, .23),406), // Wall flag\n        Object(RECTANGLE, 27, TextureSimpleColor(.54, .79, .15),406), // Wall flag\n        Object(RECTANGLE, 26, TextureSimpleColor(.1, .51, .77),406), // Wall flag\n        Object(RECTANGLE, 25, TextureSimpleColor(.42, .3, .58),406), // Wall flag\n        Object(RECTANGLE, 30, TextureSimpleColor(.52, .80, .92),411), // Wall SOUTH-WEST\n        Object(RECTANGLE, 31, TextureSimpleColor(.52, .80, .92),412), // Wall EAST\n        Object(RECTANGLE, 32, TextureSimpleColor(.52, .80, .92),413), // Wall NORTH\n        Object(RECTANGLE, 33, TextureSimpleColor(.52, .80, .92),413), // Wall NORTH\n        Object(RECTANGLE, 34, TextureSimpleColor(.52, .80, .92),500), // Ceiling\n        Object(RECTANGLE, 35, TextureSimpleColor(.52, .80, .92),402), // Window\n        Object(RECTANGLE, 36, TextureSimpleColor(.52, .80, .92),402), // Window\n        Object(RECTANGLE, 37, TextureSimpleColor(.52, .80, .92),402), // Window\n        Object(RECTANGLE, 38, TextureSimpleColor(.92, .64, .53),501), // Floor\n        Object(SPHERE, 4, TextureTexturedColor(3, .02),600), // Moon\n        Object(CYLINDER, 14, TextureSimpleColor(.7, .7, .7),700), // Bin\n        Object(CYLINDER, 15, TextureSimpleColor(.7, .7, .7),701), // Bin (autoshadow)\n        Object(DISK, 0, TextureSimpleColor(.7, .7, .7),702), // Bin\n        Object(SPHERE, 5, TextureSimpleColor(.7, .7, .7),800), // Big lamp\n        Object(SPHERE, 6, TextureSimpleColor(.7, .7, .7),801), // Big lamp\n        Object(SPHERE, 7, TextureSimpleColor(1.0, 0.83, 0.70),803), // Big lamp light bulb\n        Object(CYLINDER, 16, TextureSimpleColor(.7, .7, .7),804), // Big lamp\n        Object(CYLINDER, 17, TextureSimpleColor(.7, .7, .7),805), // Big lamp (autoshadow)\n        Object(CYLINDER, 18, TextureSimpleColor(.7, .7, .7),806), // Big lamp\n        Object(CYLINDER, 19, TextureSimpleColor(.7, .7, .7),807), // Big lamp (autoshadow)\n        Object(CYLINDER, 20, TextureSimpleColor(.7, .7, .7),808), // Big lamp\n        Object(CYLINDER, 21, TextureSimpleColor(.7, .7, .7),809), // Big lamp (autoshadow)\n        Object(DISK, 1, TextureSimpleColor(.7, .7, .7),810), // Big lamp\n        Object(DISK, 2, TextureSimpleColor(.7, .7, .7),811) // Big lamp\n    );\n    // LIGHTS\n    Light[] lights = Light[](\n        Light( // Monitor\n            vec3(0., 0., 2.5),\n            vec4(1., 1., 1., 1.),\n            0\n        ),\n        Light( // Desk lamp light bulb\n            vec3(5., 0., 6.7),\n            lightsState.x*vec4(0.4, 0.33, 0.28, 1.),\n            1\n        ),\n        Light( // Big lamp light bulb\n            vec3(-17., 0., 12.),\n            lightsState.y*vec4(0.8, 0.66, 0.56, 1.),\n            4\n        ),\n        Light( // Monitor led\n            vec3(2.1, -2.51, 0.4),\n            vec4(.15, 0., 0., 1.),\n            2\n        ),\n        Light( // Moon\n            vec3(1000., -cos(iTime/50.)*800., 500.),\n            vec4(.17, 0.16, 0.14, 1.),\n            3\n        )\n    );\n    // RAY INIT\n    Ray ray = launch(camera, fragCoord);\n    // COMPUTE\n    Intersection intersection;\n    // Find the closest object (oBest) and its intersection (intersectionBest)\n    Intersection intersectionBest = intersectionEmpty();\n    int oBest = -1;\n    for (int o = 0; o < objects.length(); o++)\n    {\n        // For each object, check if the camera ray intersects\n        if (objects[o].type == SPHERE)\n        {\n            intersect_sphere(ray, spheres[objects[o].index], intersection);\n        } else if (objects[o].type == PLANE) {\n            intersect_plane(ray, planes[objects[o].index], intersection);\n        } else if (objects[o].type == CYLINDER) {\n            intersect_cylinder(ray, cylinders[objects[o].index], intersection);\n        } else if (objects[o].type == RECTANGLE) {\n            intersect_rectangle(ray, rectangles[objects[o].index], intersection);\n        } else if (objects[o].type == DISK) {\n            intersect_disk(ray, disks[objects[o].index], intersection);\n        }\n        // If there is an intersection, check if it's better than the previous one\n        if (\n            intersection.intersects\n            &&  (\n                    intersectionBest.distanceToCamera < 0.\n                    || intersection.distanceToCamera < intersectionBest.distanceToCamera\n                )\n            )\n        {\n            intersectionBest = intersection;\n            oBest = o;\n        }\n    }\n    // Find the color of the pixel\n    if (oBest >= 0)\n    {\n        if (objects[oBest].type == SPHERE && spheres[objects[oBest].index].lightUID >= 0)\n        {\n            // If it's a light sphere, it get's the light color\n            float facteur;\n            if (MODE == 2 || MODE == 3 || MODE == 6 || MODE == 7)\n            {\n                facteur = sampleFactor(dot(intersectionBest.normalDirection, -normalize(ray.dir)));\n            } else {\n                facteur = max(0., dot(intersectionBest.normalDirection, -normalize(ray.dir)));\n            }\n            fragColor = min(\n                facteur*actualColor(objects[oBest].textureColor, intersectionBest.colorUv),\n                vec4(1., 1., 1., 1.)\n            );\n        } else {\n            // Compute all the lights that reach the object\n            fragColor = DEFAULTCOLOR;\n            for (int l = 0; l < lights.length(); l++)\n            {\n                vec3 toLight = normalize(lights[l].center - intersectionBest.intersectionPoint);\n                bool intersectsAny = false;\n                // Search for shadow\n                for (int o = 0; o < objects.length(); o++)\n                {\n                    if (\n                        /*\n                            Check that the object is not shading itself and if it's a light, not shading its light source\n                            o != oBest && (o's type == SPHERE => o's lightUID != l's lightUID)\n                            o != oBest && (o's type != SPHERE || o's lightUID != l's lightUID)\n                        */\n                        o != oBest\n                        && (\n                            objects[o].type != SPHERE\n                            || spheres[objects[o].index].lightUID != lights[l].lightUID\n                        )\n                    )\n                    {\n                        Ray rayIntersection = Ray(intersectionBest.intersectionPoint, toLight);\n                        if (objects[o].type == SPHERE)\n                        {\n                            intersect_sphere(rayIntersection, spheres[objects[o].index], intersection);\n                        } else if (objects[o].type == PLANE) {\n                            intersect_plane(rayIntersection, planes[objects[o].index], intersection);\n                        } else if (objects[o].type == CYLINDER) {\n                            intersect_cylinder(rayIntersection, cylinders[objects[o].index], intersection);\n                        } else if (objects[o].type == RECTANGLE) {\n                            intersect_rectangle(rayIntersection, rectangles[objects[o].index], intersection);\n                        } else if (objects[o].type == DISK) {\n                            intersect_disk(rayIntersection, disks[objects[o].index], intersection);\n                        }\n                        if (intersection.intersects)\n                        {\n                            // Check that the found shader is actually between the light and the object\n                            vec3 lightObj = intersectionBest.intersectionPoint - lights[l].center;\n                            vec3 lightOpaque = intersection.intersectionPoint - lights[l].center;\n                            if (dot(lightObj, lightOpaque) > 0.)\n                            {\n                                intersectsAny = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (!intersectsAny)\n                {\n                    // If no shader is found, the light is applied to the pixel\n                    float facteur;\n                    if (MODE == 2 || MODE == 3 || MODE == 6 || MODE == 7)\n                    {\n                        // Toon shading\n                        facteur = sampleFactor(dot(intersectionBest.normalDirection, toLight));\n                    } else {\n                        facteur = max(0., dot(intersectionBest.normalDirection, toLight));\n                    }\n                    fragColor += facteur*lights[l].color*actualColor(objects[oBest].textureColor, intersectionBest.colorUv);\n                }\n            }\n            fragColor = min(fragColor, vec4(1., 1., 1., 1.));\n        }\n    }\n    // Passes the id of the object in alpha layer so the post-production can find borders between objects\n    fragColor.a = float(objects[oBest].id);\n}","name":"Buffer D","description":"","type":"buffer"}]}