{"ver":"0.1","info":{"id":"3l3SD4","date":"1581161686","viewed":263,"name":"Reign in Data","username":"shau","description":"Back end of a network switch","likes":33,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n\tvec3 pc = vec4(dof(iChannel0, U/R, texture(iChannel0, U/R).w), 1.).xyz;\n    C = vec4(pow(pc*.2,vec3(1./2.2)), 1.); //dark gamma correction\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define EPS .005\n#define FAR 20.\n#define ZERO (min(iFrame,0))\n#define PI 3.141592\n#define T iTime\n\n#define NP1 vec3( 5.0,  -2.0, 0.5)\n#define NP2 vec3( 0.0,  -2.0, 0.5)\n#define NP3 vec3(-5.0,  -2.0, 0.5)\n#define NP4 vec3(-10.0, -2.0, 0.5)\n\n#define SOCKET 1.0\n#define BACK 2.0\n#define FRONT 3.0\n#define CABLE 4.0\n#define LIGHT1 5.0\n#define LIGHT2 6.0\n#define LIGHT3 7.0\n#define LIGHT4 8.0\n\nfloat lightOn(vec3 n)\n{\n    float x = length(n.xy);\n    return step(sin(x+T*x) + cos(x*0.3-T*x*3.7), 0.0);    \n}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//SDF functions IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;   \n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat smax(float a, float b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n\tfloat s = step(a.x, b.x);\n    return s*a + (1.0 - s)*b;\n}\n\nfloat dfSocket(vec3 p)\n{\n    float ctr = sdRoundBox(p, vec3(1.3, 0.8, 2.0), 0.2);\n    ctr = smax(ctr, -sdBox(p, vec3(1.1, 0.6, 3.0)), 0.2);\n    ctr = min(ctr, sdBox(p - vec3(0.0, 0.0, -1.0), vec3(1.1, 0.6, 0.1)));\n    ctr = max(ctr, -sdCapsule(p, vec3(0.0, 0.0, 2.0), vec3(0.0, 0.0, -2.0), 0.5));\n    return ctr;\n}\n\nfloat dfCable(vec3 p)\n{\n    float dy = p.z + 2.0;\n    p.y -= min(0.0, dy*-dy*0.06);\n    float cbl = sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, -10.0), 0.4 + n3D(p*2.0)*0.1);\n    return cbl;\n}\n\nvec4 map(vec3 p) {\n    \n    float m = sdBox(p - vec3(0.0, 0.0, 2.0), vec3(20.0, 10.0, 1.0));\n    //m = max(m, -sdBox(p - vec3(0.0, 0.0, -1.0), vec3(14.0, 4.0, 1.6)));\n    float f = sdBox(p - vec3(0.0, -5.0, 0.0), vec3(20.0, 1.0, 10.0));\n    \n    //light distance\n    float l1 = sdSphere(p - NP1, 0.4);\n    float l2 = sdSphere(p - NP2, 0.4);\n    float l3 = sdSphere(p - NP3, 0.4);\n    float l4 = sdSphere(p - NP4, 0.4);\n    //lights on/off\n    float lo = min(l1 + FAR*lightOn(NP1), \n               min(l2 + FAR*lightOn(NP2), \n               min(l3 + FAR*lightOn(NP3), \n                   l4 + FAR*lightOn(NP4))));\n    \n    p.x = abs(p.x);\n    \n    float cbl = dfCable(p - vec3(2.0, 0.0, 0.0));\n    cbl = min(cbl, dfCable(p - vec3(6.2, 0.0, 0.0)));\n    float skt = dfSocket(p - vec3(2.0, 0.0, 0.0));\n    skt = min(skt, dfSocket(p - vec3(6.2, 0.0, 0.0)));\n    \n    vec2 n = near(vec2(skt, SOCKET), vec2(cbl, CABLE));\n    n = near(n, vec2(m, BACK));\n    n = near(n, vec2(f, FRONT));\n    n = near(n, vec2(l1, LIGHT1));\n    n = near(n, vec2(l2, LIGHT2));\n    n = near(n, vec2(l3, LIGHT3));\n    n = near(n, vec2(l4, LIGHT4));\n    \n    return vec4(n, lo, skt);\n}\n\nfloat shadowMap(vec3 p) {\n    \n    float t = sdBox(p - vec3(0.0, 0.0, 2.0), vec3(20.0, 10.0, 1.0));\n    t = min(t, sdBox(p - vec3(0.0, -5.0, 0.0), vec3(20.0, 1.0, 10.0)));\n    \n    p.x = abs(p.x);\n    \n    t = min(t, dfCable(p - vec3(2.0, 0.0, 0.0)));\n    t = min(t, dfCable(p - vec3(6.2, 0.0, 0.0)));\n    t = min(t, dfSocket(p - vec3(2.0, 0.0, 0.0)));\n    t = min(t, dfSocket(p - vec3(6.2, 0.0, 0.0)));\n    \n    return t;\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 12.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//IQ - https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for (int i = ZERO; i<32; i++) {\n\t\tfloat h = shadowMap(ro + rd * t);\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10.0 * d / max(0.0, t-y));\n        ph = h;        \n        t += h;\n        if (res < EPS || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nfloat vMarch(vec3 ro, vec3 rd, inout vec3 gc)\n{\n    float t = 0.1;\n    for (int i=ZERO; i<100; i++)\n    {\n        vec3 p = ro + rd*t;\n        vec4 ns = map(p);\n        \n        if (ns.x != ns.w)\n        {\n            break;\n        }\n        \n        gc += vec3(0,1,0) / (1.0 + ns.z*ns.z*80.0);\n        \n        t += max(0.01, ns.x);\n    }\n    return t;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 gc)\n{\n    float t = 0.0, id = 0.0;\n    for (int i=ZERO; i<100; i++) \n    {\n        vec3 p = ro + rd*t;\n        vec4 ns = map(p);\n        if (ns.x<EPS) \n        {\n            id = ns.y;\n            break;\n        }\n        \n        gc += vec3(0,1,0) / (1.0 + ns.z*ns.z*300.);\n        t += ns.x*0.6;\n        \n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 renderLight(\n    vec3 p, \n    vec3 n, \n    vec3 rd, \n    vec3 lp, \n    vec3 sc, \n    vec3 lc, \n    float lg, \n    float am,\n    float fa)\n{\n    \n    if (lg>0.0) return sc;\n    \n    vec3 ld = normalize(lp - p);\n    float dif = max(0.05, dot(ld, n)),\n          lt = length(lp - p),\n          attn = 1.0 / (1.0 + lt*lt*am),\n          sh = shadow(p + n*EPS, ld, 0.0, lt),\n          spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 6.0),\n          fres = pow(clamp(dot(n, rd) + 1.0, 0.0, 1.0), 4.0)*fa;\n    \n    vec3 pc = sc*max(0.05, dot(ld, n))*lc; \n    pc += lc*(spec+fres);\n    return pc*attn*sh;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 rd, float id)\n{    \n    vec3 pc = vec3(0),\n         sc = vec3(0),\n         lp = vec3(10.0, 20.0, -5.0);\n\n    float lg = 0.0, fa = 0.0;\n    if (id==CABLE) \n    {\n        sc = vec3(0.0, 0.0, 0.2);\n    }    \n    else if (id==SOCKET) \n    {\n        fa = 1.0;\n    }    \n    else if (id==BACK) \n    {\n        sc = vec3(0.01);\n    }    \n    else if (id==FRONT) \n    {\n        sc = vec3(0.01);\n    }    \n    else if (id==LIGHT1) \n    {\n        float lo = 1.0 - lightOn(NP1);\n        sc = vec3(0.0, lo, 0.0);\n        lg = lo;\n        fa = 1.0;\n    }  \n    else if (id==LIGHT2) \n    {\n        float lo = 1.0 - lightOn(NP2);\n        sc = vec3(0.0, lo, 0.0);\n        lg = lo;\n        fa = 1.0;\n    }  \n    else if (id==LIGHT3) \n    {\n        float lo = 1.0 - lightOn(NP3);\n        sc = vec3(0.0, lo, 0.0);\n        lg = lo;\n        fa = 1.0;\n    }  \n    else if (id==LIGHT4) \n    {\n        float lo = 1.0 - lightOn(NP4);\n        sc = vec3(0.0, lo, 0.0);\n        lg = lo;\n        fa = 1.0;\n    }  \n    \n    pc = renderLight(p, n, rd, lp, sc, vec3(1), lg, 0.005, fa);\n    pc += renderLight(p, n, rd, NP1, sc, vec3(0,1,0), lg, 0.1, fa) \n        * (1.0 - lightOn(NP1));\n    pc += renderLight(p, n, rd, NP2, sc, vec3(0,1,0), lg, 0.1, fa) \n        * (1.0 - lightOn(NP2));\n    pc += renderLight(p, n, rd, NP3, sc, vec3(0,1,0), lg, 0.1, fa) \n        * (1.0 - lightOn(NP3));\n    pc += renderLight(p, n, rd, NP4, sc, vec3(0,1,0), lg, 0.1, fa) \n        * (1.0 - lightOn(NP4));\n    \n    pc *= AO(p, n);\n        \n    return pc;\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0),\n         gc = vec3(0),\n         la = vec3(0.0, -1.0, 0.0),\n         ro = vec3(0.0, 3.0+sin(T*0.14), -7.0 - sin(T*0.07)*1.0);\n    \n    ro.xz *= rot(sin(T*0.09)*0.2);\n    vec3 rd = camera(U, ro, la, 1.4);\n    \n    vec2 ns = march(ro, rd, gc);\n    float dof = 0.0;\n    \n    if (ns.x>0.0)\n    {\n        vec3 p = ro + rd*ns.x;\n        dof = length((la - p)*1.6 / FAR);\n        vec3 n = normal(p);\n        pc = shade(p, n, rd, ns.y);\n        \n        if (ns.y == SOCKET) \n        {\n            vec3 sgc = vec3(0), rrd = refract(rd, n, 0.2);\n            float vt = vMarch(p, rrd, sgc);\n            vec3 ep = p + rrd*(vt+0.1);\n            vec2 rns = march(ep, rd, gc);\n            if (rns.x>0.0)\n            {\n                vec3 rp = ep + rd*rns.x;\n                vec3 rn = normal(rp);\n                pc += shade(rp, rn, rd, rns.y)*0.6;\n            }\n            pc += sgc;\n        }\n    }\n    \n    pc += gc;\n    \n    C = vec4(pc, dof);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n","name":"Common","description":"","type":"common"}]}