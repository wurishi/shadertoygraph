{"ver":"0.1","info":{"id":"lfjXzd","date":"1707153616","viewed":277,"name":"Orb of the winds","username":"Toiture","description":"RayMarched orb with volumetrics inside","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sunD normalize(vec3(1.,1.,0.)) \nfloat noise(vec3 p) {\n    return texture(iChannel0, p).r;\n} \nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a); \n    float oc=1.0-c; \n    vec3 as=axis*s; \n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis); \n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c); \n    return p*oc+q; \n}\n\nfloat fbm(vec3 p) {\n\n    float sum = 0. ;\n\n    vec3 p2 = p;\n\n    p.xz /=2.;\n\n    p/=4.;\n\n    //p+=sin(iTime)*5.*0.05*vec3(1.,0.5,2.) ;\n\n    p.x*=abs(sin(p.y*6.));\n\n    \n\n    sum = noise(p) ;\n\n    sum+=noise(p*2.)*0.5;\n\n    sum+=noise(p*4.)*0.25;\n\n    sum+=noise(p*8.)*0.125;\n\n    sum/=1.+0.5+0.25+0.125;\n\n    \n\n    sum*=smoothstep(1.,0.5,length(p2)/0.9) ;\n\n    \n\n    return smoothstep(0.3,0.8,sum)*20. ;\n\n} \nvec4 vol(vec3 ro, vec3 rd, float dI) {\n    float t = 1. ;\n    vec3 l = vec3(0.);\n    \n    float steps = 10. ;\n    float stepL = dI/steps;\n    \n    float d = 0. ;\n    for(float i = 0. ; i < steps ; i++) {\n        vec3 p = ro+rd*d;\n        \n        float dE = fbm(p) ;\n        float local = exp(-dE*stepL) ;\n        \n        if(dE > 0.){\n            //https://www.shadertoy.com/view/XslGRr\n            float dif = clamp((dE-fbm(p+sunD*0.4))*0.5,0.,1.);\n            dif+=clamp((dE-fbm(p+sunD*0.05))*2.,0.,1.);\n            dif*=phase(0.5,-0.2,dot(rd,sunD));\n            \n            l+=t*(dif-dif*local) /dE;\n        } \n        \n        t*=local;\n        d+=stepL ;\n    } \n    \n    return vec4(l, t) ;\n} \n\n//https://iquilezles.org/articles/ \nfloat sdCappedCylinder( vec3 p, float h, float r )\n\n{\n\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\n}\nfloat sdf(vec3 p) {\n    float orb = abs(length(p-vec3(0.))-1.)-0.01 ;\n    float dark = abs(length(p-vec3(0.))-0.3);\n    \n    float s = sdCappedCylinder(p+vec3(0.,2.15,0.), 1.,1.1)-0.1;\n    \n    float sX = smoothstep(0.3, 0.6,max(sin(p.x*5.*3.1415), 0.))*0.02;\n    s-=sX;\n    float sZ = smoothstep(0.3, 0.6,max(sin(p.z*5.*3.1415), 0.))*0.02;\n\n    s-=sZ;\n    return min(min(dark,orb),s) ;\n} \nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d = 0. ;\n    for(int i = 0 ; i<255 ;i++) {\n        vec3 p = ro+rd*d;\n        float ds = sdf(p) ;\n        d+=ds ;\n        if(ds<0.001 || d >= 20.)break ;\n    } \n    return d ;\n} \nvec3 calcNormal(vec3 p) { \n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon \n    \n    return normalize( \n      e.xyy * sdf(p+e.xyy) + \n      e.yyx * sdf(p+e.yyx) + \n      e.yxy * sdf(p+e.yxy) + \n      e.xxx * sdf(p+e.xxx)) ; \n}\nstruct mate {\n    vec3 a ;\n    float ref ;\n    bool isRefract;\n} ;\n//color and properties\nmate volProp(vec3 p){\n    vec3 col = vec3(1.);\n    float r = 0. ;\n    bool isRe = false ;\n    \n    if(p.y <-0.94){\n        float sX = smoothstep(0.3, 0.6,max(sin(p.x*5.*3.1415), 0.));\n\n        float sZ = smoothstep(0.3, 0.6,max(sin(p.z*5.*3.1415), 0.));\n        \n        vec4 addCol = mix(vec4(vec3(0.5,0.5,0.3)*0.5, 0.4),vec4(0.45,0.45,0.35,0.2),texture(iChannel0,p/2.+vec3(5.53,8.35,45.467)).r);\n        vec3 baseCol = mix(vec3(0.1,0.1,0.2)*0.5,vec3(0.2,0.25,0.3),texture(iChannel0,p/vec3(3.,1.,3.)).r);\n        \n        col = mix(baseCol, addCol.rgb, clamp(sX+sZ,0.,1.));\n        r = mix(0.1, addCol.a,clamp(sX+sZ,0.,1.));\n        //isRe=true;\n    } else {\n        isRe = true ;\n        r = 0.3 ;\n    } \n    if(length(p) <0.4) { \n        col = vec3(0.);\n        isRe = false ;\n    } \n    \n    return mate(col, r, isRe) ;\n} \nvec3 bkgColor(vec3 rd) {\n    vec3 cb = texture(iChannel1, rd).rgb;\n    cb = vec3(dot(cb, vec3(0.2,0.3,0.5))) ;\n    cb = smoothstep(0.,1.,cb)*vec3(0.6,0.8,1.);\n    cb*=smoothstep(0.,0.8,rd.y+0.5)*0.7+0.3;\n    \n    float sun = 0.1/(length(rd-sunD)/0.5);\n    return cb+sun;\n} \nfloat AO(vec3 p, vec3 normal) {\n    p+=normal*0.3; \n    return exp(-(0.3-sdf(p))*2.) ; \n} \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y ;\n    \n    vec3 ro = vec3(0.,1.8,4.);\n    ro.x = sin(iTime*0.5)*5.;\n    ro.z = cos(iTime*0.5)*5.;\n    \n    vec3 rd = normalize(vec3(uv-vec2(0.,0.4),-1.));\n    rd.x/=1.05;\n    vec3 roSp =-ro;\n    float angle = acos(dot(normalize(vec2(0.,-1.)),normalize(roSp.xz))) ;\n    rd*=rotAxis(vec3(0.,1.,0.),angle*sign(ro.x));\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n   \n    col = bkgColor(rd) ;\n    \n    //account for 3d\n    float d = rayMarch(ro, rd) ;\n    if(d<20.){ // surface intersection\n        vec3 p = ro+rd*d;\n        vec3 n = calcNormal(p) ;\n        mate a = volProp(p) ;\n        \n        col = a.a;\n        \n        //diffuse light \n        //vec3 sunD = normalize(vec3(1.,1.,0.));\n        float dif = clamp(dot(n, sunD)*0.5+0.5, 0.,1.) ;\n        float spec = pow(clamp(dot(reflect(rd, n), sunD),0.,1.),50.); \n        vec3 difCol = a.a*(dif+spec)*AO(p, n)+vec3(0.04,0.05,0.07);\n        //shadows\n\n        float sD = rayMarch(p+n*0.02, sunD) ;\n\n        float sha = sD < 20.? 0.:1.;\n        \n        col = difCol*sha ;\n        //reflections \n        vec3 refRd = reflect(rd, n) ;\n        vec3 refCol = bkgColor(refRd) ;\n        \n        //refraction \n        float mult = 1. ;\n        vec3 ro2 = p-n*0.05;\n        vec3 rRd = refract(rd, n, 1./1.33);\n        //rRd = rd ;\n        if(dot(rRd, rRd) == 0.)rRd = reflect(rd, n) ;\n        float d2 = rayMarch(ro2, rRd) ;\n        vec3 p2 = ro2+rRd*d2*0.99;\n        vec3 n2 = calcNormal(p2) ;\n        mate a2 = volProp(p2) ;\n        float beer = exp(-d2*0.1) ;\n        vec4 c = vol(ro2, rRd, d2) ;\n        if(a.isRefract){\n            float dif2 = clamp(dot(n2,sunD)*0.5+0.5,0.,1.);\n            col = a2.a*dif2*beer;\n            \n            //calculate volumetric\n            col = mix(c.rgb,col,c.a);\n            \n        } \n        vec3 rd3 = refract(rRd,-n2,1.33);\n        if(dot(rd3, rd3) == 0.)rd3 = reflect(rRd, n2) ;\n        if(a2.isRefract && a.isRefract){\n            col = bkgColor(rd3)*beer;\n            col = mix(c.rgb,col,c.a);\n        } \n        float fresnel = 1.+dot(rd, n) ;\n        fresnel =pow(fresnel, 5.)*10.;\n        col = mix(col, refCol,clamp(a.ref+fresnel*a.ref, 0.,1.));\n\n        \n    } \n    \n    //vec4 c = vol(ro, rd, 10.);\n    //col = mix(c.rgb,col,c.a);\n    col+=(rand(col, 63.252)*2.-1.)*0.01;\n    col*=smoothstep(1.,0.2,length(uv));\n    \n    col = pow(col, vec3(0.8));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float plaIntersection(vec3 ro, vec3 rd, vec3 normal,float shift )\n{\n    float dis = dot(normal,rd);\n    if (-dis > 0.001){ \n        float t = dot(vec3(shift)-ro,normal)/dis ; \n        return t ;\n    } \n    else return -1. ;\n} \nfloat rand(vec3 c, float seed) {\n    return fract(sin(dot(c, vec3(3.2774))*52.482)*83.263*seed);\n} \nfloat HG( float g, float sundotrd) {\n\n\tfloat gg = g * g;\treturn (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);}\n\nfloat phase(float f, float b, float costh) {\n\n    return mix(HG(f, costh),HG(b,costh ),0.5 ); \n\n} ","name":"Common","description":"","type":"common"}]}