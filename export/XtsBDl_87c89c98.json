{"ver":"0.1","info":{"id":"XtsBDl","date":"1527979922","viewed":258,"name":"attempt at raymarched noise/fog","username":"MacSlow","description":"It has some volumetric quality, but no where near proper clouds. There's no lighting or scattering of any kind. But I expected cloud-like shapes to emerge from the fbm/noise.\nI'm glad for any hints about what's wrong with my ray-marching the volume field.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","fbm","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// raymarched noise/fog - playground for learning about volumetric clouds\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 128;\nconst float STEP_SIZE = .0125;\nconst float FAR = 1.5;\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Result {\n    float dist;\n    float density;\n};\n\nconst Result nullResult = Result (.0, .0);\n\nmat2 r2d (in float a) { float r = radians (a); float c = cos (r); float s = sin (r); return mat2(vec2(c, s), vec2(-s, c));}\n//float hash (float f) { return fract (sin (f) * 4.5453); }\nfloat hash (float f) { return fract (sin (f)*45843.349); }\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    v = v * v * (3. - 2. * v);\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n    return mix (mix (mix (a, b, v.x),\n                     mix (c, d, v.x),\n                     v.y),\n                mix (mix (e, f, v.x),\n                     mix (g, h, v.x),\n                     v.y),\n                v.z);\n}\n\nmat3 rotZ (float degree)\n{\n\tfloat r = radians (degree);\n    float c = cos (r);\n    float s = sin (r);\n    mat3 m = mat3 (vec3 ( c,  s, .0),\n                   vec3 (-s,  c, .0),\n                   vec3 (.0, .0, .0));\n    return m;\n}\n\nfloat fbm (vec3 p)\n{\n\tmat3 m1 = rotZ (1.1);\n\tmat3 m2 = rotZ (-1.2);\n\tmat3 m3 = rotZ (.9);\n\n    float result = .0;\n    result = .5 * noise3d (p); p *= m1 * 2.02;\n    result += .25 * noise3d (p); p *= m2 * 2.03;\n    result += .125 * noise3d (p); p *= m3 * 2.04;\n    result += .0625 * noise3d (p); p *= m3 * 2.05;\n    result += .01325 * noise3d (p);\n    result /= (.5 + .25 + .125 + .0625 + .01325);\n\n    return result;\n}\n\nResult march (in Ray ray, in bool typeToggle)\n{\n    float max_density = .0;\n    float density = .0;\n    Result res = nullResult;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ray.ro + res.dist*ray.rd;\n        p.xy *= r2d (2.*iTime);\n        p.yz *= r2d (-3.*iTime);\n        p.zx *= r2d (4.*iTime);\n        if (typeToggle) {\n        \tdensity = .75*noise3d (7.*p);\n        } else {\n        \tdensity = .75*fbm (7.*p);\n        }\n        max_density = max_density < density ? density : max_density;\n        if (max_density > 1. || res.dist > FAR) break;\n        res.dist += STEP_SIZE;\n    }\n\n    res.density = max_density;\n    return res;\n}\n\nRay camera (in vec3 ro, in vec3 aim, in float zoom, in vec2 uv)\n{\n\tvec3 forward = normalize (aim - ro);\n\tvec3 worldUp = vec3 (.0, 1., .0);\n\tvec3 right = normalize (cross (forward, worldUp));\n\tvec3 up = normalize (cross (right, forward));\n\tvec3 center = normalize (ro + forward*zoom);\n\n    return Ray (ro, normalize ((center + uv.x*right + uv.y*up) - ro));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = .0125*iTime;\n    vec3 ro = vec3 (.25*cos (t), sin (t), .25*sin (t));\n    vec3 lookAt = vec3 (.0);\n    float zoom = 1.;\n    Ray ray = camera (ro, lookAt, zoom, uv);\n    Result res;\n    if (uv.x < .0) {\n    \tres = march (ray, false);\n    } else {\n        res = march (ray, false);\n    }\n    vec3 col = mix (vec3(.0), vec3(1., .95, .9), res.density*res.density);\n\n    col = col / (1. + col);\n    col = .3*col + .7*sqrt (col);\n\n\tfragColor = vec4 (col, 1.);\n}","name":"Image","description":"","type":"image"}]}