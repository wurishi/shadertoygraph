{"ver":"0.1","info":{"id":"wstXz7","date":"1571724341","viewed":99,"name":"Spheres pooping spheres","username":"theepicsnail","description":"Me learning lighting things and screwing around with normals. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max_steps 100\n#define eps 0.001\n\nmat2x2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2x2(c,-s,s,c);\n}\nvec3 rotX(vec3 ro, float a) { ro.yz = rot(a)*ro.yz; return ro;}\nvec3 rotY(vec3 ro, float a) { ro.xz = rot(a)*ro.xz; return ro;}\nvec3 rotZ(vec3 ro, float a) { ro.xy = rot(a)*ro.xy; return ro;}\n\n\nfloat sphere(vec3 p, float r) {\n    \n    return length(p) - r;\n}\n\nfloat sub(float a, float b) {\n    return max(a,-b);\n}\n\nfloat add(float a, float b) {\n    return min(a,b);\n}\n\nvec3 recenter(vec3 p, vec3 nc) {\n    return p-nc;\n}\n\nfloat plane(vec3 p) {\n    return p.y;\n}\nfloat sdf(vec3 ro) {\n    float d = 100000.0;\n    \n    float x = sin(iTime);\n    \n    float main = sphere(recenter(ro, vec3(0,1.5,0)), .5);\n    \n    vec3 sc = vec3(0, 1.5-fract(iTime*.25)*1.,0);\n    d= add(d,sub(main, sphere(recenter(ro, sc), .30)));\n    d= add(d,sphere(recenter(ro, sc-vec3(0,1,0)), .25));\n        \n    float sec = sphere(recenter(ro, sc), .25);\n    \n    d = add(d, sec);\n    \n    d = add(d, plane(ro));\n    \n    d = add(d,\n            plane(\n                rotX(recenter(ro, vec3(0,0,1)), -1.5)\n            )\n            );\n    d = add(d,\n            plane(\n                rotZ(recenter(ro, vec3(1,0,0)), 1.5)\n            )\n            );\n    d = add(d,\n            plane(\n                rotZ(recenter(ro, vec3(-1,0,0)), -1.5)\n            )\n            );\n    return d;\n}\n\nvec2 render(vec3 ro, vec3 rd) {\n    float total_distance = 0.;\n    for(int i = 0 ; i < max_steps ; i++) {\n        float d = sdf(ro + total_distance*rd);\n        \n        if(d<eps)\n            return vec2(1, total_distance);\n        \n       \ttotal_distance += d;\n    }\n    \n    return vec2(0, total_distance);\n}\n\nfloat rand(vec2 co){\n    co = floor(co*10.);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)*2.-1.;\n}\n\nvec3 est_normal(vec3 p) {\n    return normalize(vec3(\n       sdf(p+vec3(eps,0,0))-sdf(p-vec3(eps,0,0)),\n       sdf(p+vec3(0,eps,0))-sdf(p-vec3(0,eps,0)),\n       sdf(p+vec3(0,0,eps))-sdf(p-vec3(0,0,eps))\n    )) + vec3(rand(p.yz), rand(p.xz), rand(p.yz))*.1;\n}\n\n\nfloat lighting(vec3 ro, vec3 lightPos) {\n    vec3 n = est_normal(ro);\n    vec3 rd = normalize(lightPos-ro);\n    \n    vec2 r = render(ro+n*eps*2., rd);\n    float brightness = .5;\n    if(r.y > length(lightPos - ro))\n        brightness = 1.;\n    return dot(n,rd) * brightness;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n \n    vec3 cam = vec3(0,.5,-1.5);\n    //cam.x += muv.x*.5;\n    //cam.y += muv.y;\n    //cam.xz *= rot;\n    \n    vec3 lookat = vec3(0,1,0);\n    \n    vec3 f = normalize(lookat-cam);\n    vec3 r = cross(f,vec3(0,1,0));\n    vec3 u = cross(r,f);\n    \t\n    vec3 i = cam + uv.x*r + uv.y*u + f*.7;\n        \n    vec3 ro = cam;\n    vec3 rd = normalize(i-cam);\n    \n    //fragColor.rgb = fract(abs(i-cam)*10.);\n    //return;\n    \n    vec2 result = render(ro, rd);\n    \n    vec3 hitpos = ro+rd*result.y;\n    //if(result.x<1.) return;\n\n    float l = 0.;\n    \n    vec3 lpos = vec3(.5,.6,0);\n    lpos.xz *= rot(iTime*.7);\n    fragColor = vec4(0,0,0,1);\n\tfragColor.rgb += lighting(hitpos, lpos) * vec3(1,0,0);\n    lpos.xz *= rot(2.);\n\tfragColor.rgb += lighting(hitpos, lpos) * vec3(0,1,0);\n    lpos.xz *= rot(2.);\n\tfragColor.rgb += lighting(hitpos, lpos) * vec3(0,0,1);\n    \n    \n    \n\t//fragColor.rg =uv;\n    //fragColor.b=0.;\n    // Output to screen\n    // * est_normal(hitpos)\n}","name":"Image","description":"","type":"image"}]}