{"ver":"0.1","info":{"id":"7t2XDm","date":"1627880569","viewed":67,"name":"Ray Marching Attempt 2 w/ Shadow","username":"falconXYZ","description":"ray marcher attempt 2\n\nI added soft shadows\n\nIf anyone knows how to fix the weird black dot at the center of the spheres without increasing the QUALITY constant by a lot please let me know","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray","marching","casting"],"hasliked":0,"parentid":"NlBXzD","parentname":"Ray Marcher attempt 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define QUALITY 0.0001\n#define MAX_DISTANCE 100.0\n\n\n\nfloat map(vec3 pos) {\n    float sphere = distance(pos,vec3(0.)) - 1.;\n    \n    float sphere2 = distance(pos,vec3(2. * cos(iTime),0.5 * cos(iTime),1.*sin(iTime))) - .125;\n    \n    pos += 0.125*(0.5*cos(iTime)+1.0)*sin(pos.x+2.*iTime) + 1.;\n    pos += 0.125*sin(pos.z+iTime) + 1.;\n    float plane = pos.y + 1.;\n    \n    return min(min(sphere,sphere2),plane);\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3( map(p-e.xyy) , map(p-e.yxy) , map(p-e.yyx) );\n    return normalize(n);\n}\n\nvec3 diffuseLighting(vec3 pos,vec3 lightPos,vec3 Color, float power) {\n    vec3 light = normalize(lightPos - pos);\n    vec3 normal = getNormal(pos);\n    \n    float diffuse = clamp(dot(normal, light),0.0,1.0);\n    \n    vec3 ro = pos + normal * QUALITY * 2.;\n    vec3 rd = light;\n    float dO = 0.;\n    float res = 1.0;\n    float k = 20.0;\n    \n    for(int i=0; i<MAX_STEPS/2; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = map(p);\n        res = min( res, k*dS/dO );\n        dO += dS;\n        if(dO>MAX_DISTANCE || dS<QUALITY) break;\n    }\n    \n    vec3 dif = diffuse * Color * power; \n    \n    if(dO<length(lightPos-pos)) dif *= .1;\n    else dif *= res;\n    \n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.;\n    uv.y *= 0.5;\n    \n    vec3 rayOrigin = vec3(0,0,-3);\n    vec3 rayDirection = normalize(vec3(uv,1.0));\n    \n    float distanceFromOrigin = 0.0;\n    \n    vec3 diffuseWhite;\n    vec3 diffuseRed;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 rayPosition = rayOrigin + (rayDirection * distanceFromOrigin);\n        \n        float map = map(rayPosition);\n        \n        distanceFromOrigin += map;\n        \n        if (map < QUALITY || distanceFromOrigin > MAX_DISTANCE) {\n        \n            break;\n            }\n        diffuseRed = diffuseLighting(rayPosition,vec3(5.0 * sin(iTime),2,5.0 * cos(iTime)), vec3(1,0,0), 1.0);\n        diffuseWhite = diffuseLighting(rayPosition,vec3(0,1,-5),vec3(1,1,1), 0.2);\n    }\n    vec3 diffuse = diffuseRed + diffuseWhite;\n    diffuse /= 2.0;\n    distanceFromOrigin/=4.0;\n    fragColor = vec4(diffuse,1.0);\n}","name":"Image","description":"","type":"image"}]}