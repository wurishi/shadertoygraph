{"ver":"0.1","info":{"id":"wsVXDh","date":"1573971234","viewed":86,"name":"don - Perlin Noise 2D","username":"koktszfung","description":"Simple Perlin Noise","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n *\t2D Perlin Noise\n */\n\n// 0 = Controlled by iTime\n// 1 = Controlled by iMouse\n#define MOUSE 0\n\n/* board size for periodic boundary condition */\nconst int NUM_SAMPLE_X = 800;\nconst int NUM_SAMPLE_Y = 800;\n\n/* choices of gradient vector */\nconst float[8] GRAD_I = float[](-2.,-2., 2., 2.,-1., 1.,-1., 1.);\nconst float[8] GRAD_J = float[](-1., 1.,-1., 1.,-2.,-2., 2., 2.);\n\n\n\n/* smooth function */\nfloat fade(float x) {\n    return 6. * pow(x, 5.) - 15. * pow(x, 4.) + 10. * pow(x, 3.);\n}\n\n/* linear interpolation */\nfloat lerp(float x, float a, float b) {\n    return (1. - x) * a + x * b;\n}\n\n/* get random float [0, 1] from noise map (less artifacts) */\nfloat rand(int i, int j, int seed) {\n    // use channel0 for noise map\n\tint u = int(texelFetch(iChannel0, ivec2(i, j), 0).x * float(NUM_SAMPLE_Y));\n    int v = int(texelFetch(iChannel0, ivec2(j, i), 0).x * float(NUM_SAMPLE_X));\n    u = (u + seed) % int(iChannelResolution[0].y);\n    v = (v + seed) % int(iChannelResolution[0].x);\n    return texelFetch(iChannel0, ivec2(u, v), 0).x;\n}\n\n/* get random float [0, 1] from hash function by Xor https://www.shadertoy.com/view/4l2GzW (more artifact) */\n/*float rand(int i, int j, int seed) {\n    float n = float(i * int(iResolution.x) + j + seed);\n \treturn fract(cos(n*89.42)*343.42);\n}*/\n\n/* colormap by mattz https://www.shadertoy.com/view/WlfXRN*/\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n\n\n/* calculate perlin noise at current position */\nfloat noise(int num_row, int num_col, int seed, vec2 fragCoord) {\n    /* indices for current cell */\n    int i = int(fragCoord.y) * num_row / NUM_SAMPLE_Y ;\n    int j = int(fragCoord.x) * num_col / NUM_SAMPLE_X ;\n    \n    /* adjacent indices with periodic boundary condition */\n    int[4] ADJ_I = int[](i % num_row, i % num_row, (i + 1) % num_row, (i + 1) % num_row);\n    int[4] ADJ_J = int[](j % num_col, (j + 1) % num_col, j % num_col, (j + 1) % num_col);\n    \n    /* random integers by scaling rand of [0, 1] to [0, number of gradient vectors - 1] */\n    int num_grad = GRAD_I.length();\n    int r0 = int(rand(ADJ_I[0], ADJ_J[0], seed) * float(num_grad));\n\tint r1 = int(rand(ADJ_I[1], ADJ_J[1], seed) * float(num_grad));\n\tint r2 = int(rand(ADJ_I[2], ADJ_J[2], seed) * float(num_grad));\n\tint r3 = int(rand(ADJ_I[3], ADJ_J[3], seed) * float(num_grad));\n    if (r0 == num_grad) r0--;\n\tif (r1 == num_grad) r1--;\n\tif (r2 == num_grad) r2--;\n\tif (r3 == num_grad) r3--;\n    \n    /* (u, v) = displacement from (-1, -1) corner of current cell = (y, x) - floor((y, x)) */\n    float u = fragCoord.y * float(num_row) / float(NUM_SAMPLE_Y) - float(i);\n    float v = fragCoord.x * float(num_col) / float(NUM_SAMPLE_X) - float(j);\n\t\n    /* ((u, v) - corner pos) dot (gradient at corner) */\n    float n0 = (u)*GRAD_I[r0] + (v)*GRAD_J[r0];\n    float n1 = (u)*GRAD_I[r1] + (v - 1.)*GRAD_J[r1];\n    float n2 = (u - 1.)*GRAD_I[r2] + (v)*GRAD_J[r2];\n    float n3 = (u - 1.)*GRAD_I[r3] + (v - 1.)*GRAD_J[r3];\n    \n    /* interpolation */\n    float n01 = lerp(fade(v), n0, n1);\n    float n23 = lerp(fade(v), n2, n3);\n\n    /* rescale noise to [0, 1] */\n    return (lerp(fade(u), n01, n23) + 1.) * .5;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    #if MOUSE == 0\n    \tfloat scrollSpeed = 100.;\n    \tfragCoord.x += iTime * scrollSpeed;\n    #endif\n    #if MOUSE == 1\n    \tfragCoord += iResolution.xy - iMouse.xy;\n    #endif\n    \n    int seed = 0;\n    \n    float[4] noises;\n    noises[0] = noise(10, 10, seed, fragCoord) * .5;\n    noises[1] = noise(20, 20, seed, fragCoord) * .25;\n    noises[2] = noise(40, 40, seed, fragCoord) * .125;\n    noises[3] = noise(80, 80, seed, fragCoord) * .0625;\n    \n    float sum = 0.;\n    for (int i = 0; i < noises.length(); i++) {\n        sum += noises[i];\n    }\n    fragColor.rgb = viridis(sum);\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}