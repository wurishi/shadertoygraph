{"ver":"0.1","info":{"id":"McXcRn","date":"1720691008","viewed":39,"name":"InfiniteStairs v1","username":"benjik42","description":"My goal is to fake an infinite stairs . In addition  I want to add a character walking/jumping on stairs.\nDon't hesitate to comment my code and what I can do next !","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["stairsinfinity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\n//Rotate function\nvec2 rotate(vec2 uv, float th){\n    return mat2(cos(th),sin(th),-sin(th),cos(th))*uv + vec2(0,0);\n\n}\n//Rotate world\nvec2 rotatew(vec2 uv, float th){\n    return mat2(cos(th),sin(th),-sin(th),cos(th))*uv + vec2(.5,2.7);\n\n}\n//Helix\n\nfloat sdHelix( in vec3 p, float fr, float r1, float r2, float rot )\n{\n   \n    \n    vec2 rotated = rotate(p.xz,radians(rot));\n    p.x = rotated.y  ;\n    p.z = rotated.x ;\n    \n    rotated = rotatew(p.xy,radians(0.0));\n    p.x = rotated.y  ;\n    p.y = rotated.x ;\n   \n    \n    \n    vec2  nline = vec2(fr, 6.283185*r1 );\n    vec2  pline = vec2(nline.y, -nline.x);\n    float repeat = nline.x*nline.y;\n\n    vec2  pc = vec2(p.x,r1*atan(p.y,p.z));              // to cylindrical\n\n    vec2  pp = vec2( dot(pc,pline),                     // project to line\n                     dot(pc,nline));\n    \n    pp.x = round(pp.x/repeat)*repeat;                   // repeat in x\n\n    vec2 qc = (nline*pp.y+pline*pp.x)/dot(nline,nline); // un project to cylindrical\n    qc.y /= r1;\n    \n    vec3 q = vec3(qc.x, sin(qc.y)*r1, cos(qc.y)*r1 );   // to cartesian\n        \n    return length(p-q)-r2;\n}\n\nfloat map( in vec3 pos , in float rot)\n{\n    float fr = 18.0;//Hauteur\n    float r1 = 2.79;//Largeur\n    float r2 = 0.1;//Diametre\n\n    return sdHelix(pos + vec3(0,-8.7,0.5),fr,r1,r2,rot) - 0.0001;\n}\n\n\n\n//Cylinder\nfloat sdCappedCylinder( vec3 p, float h, float r, bool world,float rot )\n{\n    if(world)\n    {\n      p.x += -3.0;\n      vec2 rotated = rotatew(p.xz,radians(rot));\n      p.x = rotated.y  ;\n      p.z = rotated.x ;\n    }\n    else\n    {\n        \n      vec2 rotated = rotate(p.xz,radians(rot));\n      p.x = rotated.y ;\n      p.z = rotated.x ;\n\n    }\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Square\nfloat sdf_box(vec3 p, float s, vec3 offset,float rot)\n{\n    vec2 rotated = rotate(p.xz,radians(rot));\n    p.x = rotated.x ;\n    p.z = rotated.y ;\n    \n    vec3 q = abs(p- offset-vec3(0,-1,-2.5))-s+vec3(0,.5,-1);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Merge object\nfloat sdScene(vec3 p) {\n  float boxRight = sdf_box(p, 1.,vec3(0,-2,0),0.0);\n  float cylinder_in = sdCappedCylinder(p+vec3(0,-4.0,0), 8.0, .8,false,0.0);\n  float cylinder_out = sdCappedCylinder(p, 10.0, 3.0,false,0.0);\n  float ramp = sdCappedCylinder(p+vec3(2.8,1.0,0),2.,.1, true,0.0);\n  \n  float ramp02 = map(p,iTime*50.0);\n  \n  float angle = 0.0;\n  for(int i=0; i<= 13; i++)\n  {\n      \n      ramp = min( ramp, sdCappedCylinder(p+vec3(2.8,1.0- float(i),0),2.,.1, true,-angle+iTime*50.0));\n      boxRight = min(boxRight,sdf_box(p, 1.,vec3(1.0,-1.0+float(i),0.0),-angle+iTime*50.0));\n      \n      angle +=20.0;\n      \n  }\n  return min(ramp02,min(ramp,min(cylinder_in,max(boxRight,cylinder_out))));\n}\n\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    vec3 background_col = vec3(1.0);\n    \n    \n    \n    vec3 col = vec3(0);\n    vec3 ray_origin = vec3(0,5,10);\n    \n  \n  \n    vec3 ray_direction = normalize(vec3(uv,-1));\n    \n    float depth = MIN_DIST;\n    for(int i=0 ; i<MAX_MARCHING_STEP; i++)\n    {\n        vec3 p = ray_origin + depth*ray_direction;\n        float obj = sdScene(p);\n        depth += obj;\n        if(obj<0.0001 || depth> MAX_DIST) break;\n    }\n    \n    if(depth > MAX_DIST)\n    {\n        col = background_col;\n    }\n    else\n    {\n        vec3 p = ray_origin + depth*ray_direction;\n        vec3 light_origin = vec3(2, 2, 7);\n        vec3 normal = calcNormal(p);\n        \n        vec3 light_direction = normalize(light_origin-p);\n        \n        float diff = clamp(dot(light_direction, normal),0.3,1.0);\n        \n        \n        col = diff * vec3(1, 0.58, 0.29)+ background_col*0.1;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}