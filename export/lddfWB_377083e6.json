{"ver":"0.1","info":{"id":"lddfWB","date":"1526640792","viewed":103,"name":"columnz","username":"spenot","description":"columns","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","columns"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COLUMN_SPACING 4.0\n#define COLUMN_RADIUS 0.4\n#define COLUMN_WAIST_RADIUS 0.25\n#define COLUMN_CURVE_HEIGHT 0.95\n#define COLUMN_CURVE_POWER 5.0\n\nfloat column(vec3 rayPosition, vec3 position, float radius, float waistRadius, float curveHeight, float power) {\n    return distance(rayPosition.xz, position.xz) - (waistRadius + pow(min(abs(rayPosition.y), curveHeight) / curveHeight, power) * (radius - waistRadius));\n}\n\nfloat scene(vec3 rayPosition) {\n    float sceneDistance = 1.0 / 0.0;\n    \n    vec3 columnPosition = vec3(0.0, 0.0, 0.0);\n    vec3 modRayPosition = vec3(mod(rayPosition.x, COLUMN_SPACING)-0.5*COLUMN_SPACING, rayPosition.y, mod(rayPosition.z, COLUMN_SPACING)-0.5*COLUMN_SPACING);\n    float columnDistance = column(modRayPosition, columnPosition, COLUMN_RADIUS, COLUMN_WAIST_RADIUS, COLUMN_CURVE_HEIGHT, COLUMN_CURVE_POWER);\n    sceneDistance = min(sceneDistance, columnDistance);\n    \n    float containerDistance = -column(rayPosition, vec3(0.0, 0.0, 5.0), 15.0, 15.0, 1.0, 2.0);\n    sceneDistance = min(sceneDistance, containerDistance);\n    \n    float floorDistance = distance(rayPosition.y, -1.0);\n    sceneDistance = min(sceneDistance, floorDistance);\n    \n    float ceilingDistance = distance(rayPosition.y, 1.0);\n    sceneDistance = min(sceneDistance, ceilingDistance);\n    \n    return sceneDistance;\n}\n\nvec3 surfaceNormal(vec3 p) { // ray position\n    float e = 0.0001;\n    return normalize(vec3(scene(vec3(p.x+e, p.y, p.z)) - scene(vec3(p.x-e, p.y, p.z)),\n                          scene(vec3(p.x, p.y+e, p.z)) - scene(vec3(p.x, p.y-e, p.z)),\n                          scene(vec3(p.x, p.y, p.z+e)) - scene(vec3(p.x, p.y, p.z-e))));\n}\n\nfloat shadow(vec3 rayPosition, vec3 lightPosition, vec3 surfaceNormal) {\n    const int maxSteps = 256;\n    \n    vec3 rayDirection = normalize(lightPosition - rayPosition);\n    float distanceLeft = distance(lightPosition, rayPosition);\n    \n    rayPosition += rayDirection * 0.2;\n    \n    for (int i = 0; i < maxSteps; ++i) {\n        float distance = scene(rayPosition);\n        if (distance < 0.001) {\n            return 0.5;\n        }\n        rayPosition += rayDirection * distance;\n        distanceLeft -= distance;\n        if (distanceLeft <= 0.0) {\n            break;\n        }\n    }\n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int maxSteps = 512;\n    \n\tvec2 screenPosition = fragCoord / iResolution.xy - vec2(0.5);\n\tscreenPosition.x *= iResolution.x / iResolution.y;\n    \n    const float cameraDistance = 1.0;\n    \n//    vec3 rayPosition = vec3(0.0);\n    vec3 rayPosition = vec3(sin(iTime/8.0)*10.0, 0.0, 0.0);\n//    vec3 rayPosition = vec3(0.0, 0.0, sin(iTime/8.0)*9.0);\n    \n    vec3 rayDirection = normalize(vec3(screenPosition, cameraDistance));\n    \n    const vec3 backgroundColor = vec3(0.0, 1.0, 0.0);//vec3(1.0, 0.01, 0.35);\n    \n//    vec3 lightPosition = vec3(7.0, 0.3, 0.0);\n    vec3 lightPosition = vec3(sin(iTime/2.0)*8.2, 0.3, 5.0 + cos(iTime/2.0)*8.2);\n    \n    vec3 color = backgroundColor;\n    \n    for (int i = 0; i < maxSteps; ++i) {\n        float sceneDistance = scene(rayPosition);\n        if (sceneDistance < 0.001) {\n            vec3 surfaceNormal = surfaceNormal(rayPosition);\n\t\t    vec3 lightDirection = normalize(lightPosition - rayPosition);\n            vec3 shadowColor = vec3(shadow(rayPosition, lightPosition, surfaceNormal));\n            float distanceShadow = distance(rayPosition, lightPosition)/35.0;\n            color = vec3(0.0 + 1.0 * dot(surfaceNormal, lightDirection));\n            color *= shadowColor;\n            color *= 1.0 - distanceShadow;\n            \n//            color = rayPosition;\n//            color = vec3(rayPosition.x / 5.0);\n//            color = vec3(rayPosition.z / 15.0);\n//            color = vec3(mod(rayPosition.x, SPACING) / SPACING);\n//            color = vec3(float(i) / float(maxSteps));\n//            color = vec3(distance(vec3(0.0), rayPosition) / 15.0);\n            \n            break;\n        }\n        rayPosition += rayDirection * sceneDistance;\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}