{"ver":"0.1","info":{"id":"lllyWH","date":"1504726668","viewed":157,"name":"Permute","username":"otah007","description":"Permutes the vector [1, 2, 3, 4] which all lie in a single volume inside 4D space. Then transforms that volume to the origin, removes the (now redundant) w component and renders in 3D, producing a truncated octahedron.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR_CLIPPING_PLANE 20.0\n#define MAX_STEPS 100\n#define EPSILON 0.15\n#define AXIS_EPSILON 0.05\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530717958647692\n\n#define ORTHOGONAL false\t\t// Perspective or orthogonal rendering\n#define RENDER_AXES false\t\t// Render the axes\n#define REPEAT 2.0\n#define RENDER_3D false\t\t\t// Render the permutations of [1, 2, 3] in 2D\n#define RENDER_4D true\t\t\t// Render the permutations of [1, 2, 3, 4] in 3D\n#define FLASH true\t\t\t\t// Flash the vertices in sequence\n#define FLASH_DURATION 0.1\t\t// Flash duration, if enabled\n\nvec3 rotateX_3D(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = vec.x;\n    v.y = (vec.y * cos(angle)) - (vec.z * sin(angle));\n    v.z = (vec.y * sin(angle)) + (vec.z * cos(angle));\n    return v;\n}\n\nvec3 rotateY_3D(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = (vec.x * cos(angle)) + (vec.z * sin(angle));\n    v.y = vec.y;\n    v.z = (-vec.x * sin(angle)) + (vec.z * cos(angle));\n    return v;\n}\n\nvec3 rotateZ_3D(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = (vec.x * cos(angle)) - (vec.y * sin(angle));\n    v.y = (vec.x * sin(angle)) + (vec.y * cos(angle));\n    v.z = vec.z;\n    return v;\n}\n\nvec3 rotate3D(vec3 vec)\n{\n    mat3 m_xz, m_xy;\n    \n    float s2 = sqrt(2.0);\n    float s3 = sqrt(3.0);\n    float s2_4 = s2 * 0.5;\n    float s2_3 = s2 / s3;\n    float s1_3 = 1.0 / s3;\n    \n    m_xz[0] = vec3(s2_4, 0.0, -s2_4);\t\t// Rotate in XZ plane by PI / 4 rads\n    m_xz[1] = vec3(0.0, 1.0, 0.0);\n    m_xz[2] = vec3(s2_4, 0.0, s2_4);\n    \n    m_xy[0] = vec3(s1_3, s2_3, 0.0);\t\t// Rotate in XZ plane by arcsin(sqrt(2/3)) rads\n    m_xy[1] = vec3(-s2_3, s1_3, 0.0);\n    m_xy[2] = vec3(0.0, 0.0, 1.0);\n    \n    return m_xy * m_xz * vec;\n}\n\nvec4 rotate4D(vec4 vec)\n{\n    float s2 = sqrt(2.0);\n    float s3 = sqrt(3.0);\n    float s2_4 = s2 * 0.5;\n    float s2_3 = s2 / s3;\n    float s1_3 = 1.0 / s3;\n    float s3_4 = s3 * 0.5;\n    \n    mat4 m_yz, m_yw, m_zw;\n    \n    m_yz = mat4(s2_4, 0.0, 0.0, s2_4,\t\t// Rotate in YZ plane by PI / 4 rads\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                -s2_4, 0.0, 0.0, s2_4);\n    \n    m_yw = mat4(1.0, 0.0, 0.0, 0.0,\t\t\t// Rotate in YW plane by arcsin(sqrt(1/3)) rads\n                0.0, s2_3, 0.0, s1_3,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, -s1_3, 0.0, s2_3);\n    \n    m_zw = mat4(1.0, 0.0, 0.0, 0.0,\t\t\t// Rotate in ZW plane by PI / 6 rads\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, s3_4, 0.5,\n                0.0, 0.0, -0.5, s3_4);\n    \n    return m_zw * m_yw * m_yz * vec;\n}\n\nconst int n = 6;\nvec3 points[6];\n\nconst int m = 24;\nvec4 p[24];\n\nvec2 march_points(vec3 origin)\t\t// Raymarch 3D/2D points\n{\n    float d = FAR_CLIPPING_PLANE;\n    int t = 0;\n    \n    for (int i = 0; i < n; ++i)\n    {\t\n        float x = d;\n        d = min(d, length(origin - points[i]));\n        \n        if (x != d)\n            t = i;\n    }\n    \n    return vec2(d, t);\n}\n\nvec2 march_p(vec3 origin)\t\t\t// Raymarch 4D/3D points\n{\n    float d = FAR_CLIPPING_PLANE;\n    int t = 0;\n    \n    for (int i = 0; i < m; ++i)\n    {\n        float x = d;\n        d = min(d, length(origin - p[i].xyz));\n        \n        if (x != d)\n            t = i;\n    }\n    \n    return vec2(d, t);\n}\n\nfloat march_axes(vec3 origin)\t\t// Raymarch axes\n{\n    float d = FAR_CLIPPING_PLANE;\n    \n    d = min(d, length(mod(origin - 0.5 * vec3(0.0, 0.0, REPEAT), vec3(0.0, 0.0, REPEAT)) - 0.5 * vec3(0.0, 0.0, REPEAT)));\n    d = min(d, length(mod(origin - 0.5 * vec3(0.0, REPEAT, 0.0), vec3(0.0, REPEAT, 0.0)) - 0.5 * vec3(0.0, REPEAT, 0.0)));\n    d = min(d, length(mod(origin - 0.5 * vec3(REPEAT, 0.0, 0.0), vec3(REPEAT, 0.0, 0.0)) - 0.5 * vec3(REPEAT, 0.0, 0.0)));\n    //d = min(d, length(origin));\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set up camera\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 direction = normalize(vec3(uv, 2.5));\n    if (ORTHOGONAL)\n    \tdirection = vec3(0.0, 0.0, 1.0);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse.x = mouse.x * 2.0 - 1.0;\n    mouse.y = mouse.y * 2.0 - 1.0;\n    \n    vec3 cameraOrigin = vec3(0.0, 0.0, -15.0);\n    if (ORTHOGONAL)\n    \tcameraOrigin = vec3(0.0, 0.0, -15.0) + vec3(uv * 5.0, 0.0);\n    cameraOrigin = rotateX_3D(cameraOrigin, mouse.y * TWO_PI * 0.5);\n    cameraOrigin = rotateY_3D(cameraOrigin, mouse.x * TWO_PI);\n    direction = rotateX_3D(direction, mouse.y * TWO_PI * 0.5);\n    direction = rotateY_3D(direction, mouse.x * TWO_PI);\n    \n    // 3D points, permutations of [1, 2, 3]\n    points[0] = vec3(1.0, 2.0, 3.0);\n    points[1] = vec3(1.0, 3.0, 2.0);\n    points[2] = vec3(2.0, 1.0, 3.0);\n    points[3] = vec3(2.0, 3.0, 1.0);\n    points[4] = vec3(3.0, 1.0, 2.0);\n    points[5] = vec3(3.0, 2.0, 1.0);\n    \n    // 4D points, permutations of [1, 2, 3, 4]\n    p[0] = vec4(1.0, 2.0, 3.0, 4.0);\n    p[1] = vec4(1.0, 2.0, 4.0, 3.0);\n    p[2] = vec4(1.0, 3.0, 2.0, 4.0);\n    p[3] = vec4(1.0, 3.0, 4.0, 2.0);\n    p[4] = vec4(1.0, 4.0, 2.0, 3.0);\n    p[5] = vec4(1.0, 4.0, 3.0, 2.0);\n    p[6] = vec4(2.0, 1.0, 3.0, 4.0);\n    p[7] = vec4(2.0, 1.0, 4.0, 3.0);\n    p[8] = vec4(2.0, 3.0, 1.0, 4.0);\n    p[9] = vec4(2.0, 3.0, 4.0, 1.0);\n    p[10] = vec4(2.0, 4.0, 1.0, 3.0);\n    p[11] = vec4(2.0, 4.0, 3.0, 1.0);\n    p[12] = vec4(3.0, 1.0, 2.0, 4.0);\n    p[13] = vec4(3.0, 1.0, 4.0, 2.0);\n    p[14] = vec4(3.0, 2.0, 1.0, 4.0);\n    p[15] = vec4(3.0, 2.0, 4.0, 1.0);\n    p[16] = vec4(3.0, 4.0, 1.0, 2.0);\n    p[17] = vec4(3.0, 4.0, 2.0, 1.0);\n    p[18] = vec4(4.0, 1.0, 2.0, 3.0);\n    p[19] = vec4(4.0, 1.0, 3.0, 2.0);\n    p[20] = vec4(4.0, 2.0, 1.0, 3.0);\n    p[21] = vec4(4.0, 2.0, 3.0, 1.0);\n    p[22] = vec4(4.0, 3.0, 1.0, 2.0);\n    p[23] = vec4(4.0, 3.0, 2.0, 1.0);\n    \n    vec3 origin = cameraOrigin;\n    vec3 colour = vec3(1.0, 1.0, 1.0);\n\n    if (RENDER_3D)\t\t// Render 3D into 2D\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            points[i] = rotate3D(points[i]);\n            points[i].y = 0.0;\n        }\n\n        for (int i = 0; i < MAX_STEPS; ++i)\n        {\n            vec2 d = march_points(origin);\n            origin += direction * d.x * 0.9;\n\n            if (length(origin) > FAR_CLIPPING_PLANE)\n                break;\n\n            if (d.x < EPSILON)\n            {\n                if (int(floor(mod(iTime / FLASH_DURATION, float(n)))) == int(d.y) && FLASH)\n                    colour = vec3(0.0, 0.0, 1.0);\n                else\n                \tcolour = vec3(0.0, 1.0, 0.0);\n                \n                break;\n            }\n        }\n    }\n    \n    if (RENDER_4D)\t\t// Render 4D into 3D\n    {\n        for (int i = 0; i < m; ++i)\n        {\n            p[i] = rotate4D(p[i]);\n            p[i].w = 0.0;\n        }\n        \n        origin = cameraOrigin;\n\n        for (int i = 0; i < MAX_STEPS; ++i)\n        {\n            vec2 d = march_p(origin);\n            origin += direction * d.x * 0.9;\n\n            if (length(origin) > FAR_CLIPPING_PLANE)\n                break;\n\n            if (d.x < EPSILON)\n            {\n                if (int(floor(mod(iTime / FLASH_DURATION, float(m)))) == int(d.y) && FLASH)\n                    colour = vec3(0.0, 0.0, 1.0);\n                else\n                \tcolour = vec3(0.0, 0.0, 0.0);\n                \n                break;\n            }\n        }\n    }\n    \n    if (RENDER_AXES)\t// Render axes\n    {\n        origin = cameraOrigin;\n        \n        for (int i = 0; i < MAX_STEPS; ++i)\n        {\n            float d = march_axes(origin);\n            origin += direction * d * 0.99;\n\n            if (length(origin) > FAR_CLIPPING_PLANE)\n                break;\n\n            if (d < AXIS_EPSILON)\n            {\n                colour = vec3(1.0, 0.0, 0.0);\n                break;\n            }\n        }\n    }\n    \n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}