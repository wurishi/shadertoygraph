{"ver":"0.1","info":{"id":"sl3Xz7","date":"1638861964","viewed":267,"name":"Desert earthquake","username":"kastorp","description":"A jorge2017a1  cactus there!\n\n","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","polygon","extrusion"],"hasliked":0,"parentid":"stcSR4","parentname":"Vorocrash (pt.2)"},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Desert Earthquake by kastorp\n//------------------------------------------------------------------------------\nGETTERS\n\nvec3 _ruv;\n\n\nfloat map2d(in vec2 uv) {   \n    float d=1e5;     \n    ivec4 nb = getCClosest( uv); \n    for(int i=0;i<4;i++){ \n        int x = nb[i];\n        vec3[MP] poly ;   //xy=coords, z=polygon id\n        vec4 pData= texelFetch(iChannel0,ivec2(x,0),0); // x=size, yz=center, w=rotation\n        for(int i=0;i<int(pData.x);i++) poly[i]=texelFetch(iChannel0,ivec2(x,i+1),0).xyz;\n\n        // Draw poly \n         float d0= sdPolygon(uv-pData.yz,poly,int(pData.x+.5));\n         if(d>d0) {d=d0;  _ruv= vec3(uv-pData.yz + getCenter(int(pData.w+.5)),d0);}\n    }    \n    return d;\n}\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) { //@blackle\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat xt( in vec3 p, in float sdf, in float h ){//@iq\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat scene(vec3 p){\n    if(p.z>0.1 && length(p)>1.5) return min(p.z,length(p));\n    else {\n        float m = map2d(p.xy+size*.5);\n        float d = xt(p +vec3(0,0,5.), m ,5.);\n        if (m < 0.) // only draw cactus when inside cell\n            d = min(d,cactus(vec3(_ruv.x,p.z,_ruv.y)*15.+vec3(2,-2,4))/15.);\n        return d;\n    }\n}\n\nvec3 norm(vec3 p) {//@blackle\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    \n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-6.,0,0);\n    \n    float yrot =.8;\n    float zrot = 3.14 +iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot =.4+ .7*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 70 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-4;\n        p+=dist*cam;\n        if (distance(p,init)>15. ||hit) break;\n    }\n    vec3 n = norm(p);    \n    float h=p.z;\n    vec3 ruv=_ruv;\n    n= (abs(ruv.y)>.2 || abs(h)>.02) ? doBumpMap( iChannel3, vec3(ruv.xy,h)*.25, n, 0.01):n;\n    vec3 r = reflect(cam,n);\n\n    float rd = (abs(ruv.y)>.2 || abs(h)>.02)?1.: (abs(ruv.y)>.18)?2.: abs(ruv.y)<.01&& fract(ruv.x)<.3 ?2.: .2;\n    vec3 col =  (h>.02 ?vec3(0,.3,0): rd* texture(iChannel3,ruv.xy*.03,0.).rgb ) ;\n    \n    float spec = length(sin(r*.6 +.5))/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    bool sh=false;\n    if(hit){\n        vec3 ld= normalize(vec3(1));\n        p+=n*.02;\n        for (int i = 0; i < 40 && !sh; i++) {\n            float dist = scene(p);\n            sh = dist*dist < 1e-4;\n            p+=dist*ld;\n            if (dist>3.||sh) break;\n        }\n    }\n    \n    col=col* spec*(sh?.4:1.);// + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.; //@blackle\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//#define REDUCE 1e-8//remove redundant vertexes\n#define POLDIR 1 //1=counterclockwise, 0= clockwise\nfloat cross2d(vec3 a, vec3 b) {return cross(vec3(a.xy,0.),vec3(b.xy,0.)).z;  }\nfloat dot2d(vec2 a){return dot(a,a);}\nfloat dot2d(vec3 a){return dot(a.xy,a.xy);}\n\n\n//Oneshade polygon clipping algorithm https://www.shadertoy.com/view/sdXGz7\nint clipPoly(vec3 clipA , vec3 clipB,in vec3[MP] poly, int num, inout vec3[MP] clipped)\n{\n    vec2 clipTan = clipB.xy - clipA.xy;          // Clip tangent\n    vec2 clipPerp = vec2(-clipTan.y, clipTan.x); // Clip normal\n\n    int nClip = 0;                   // Number of vertices in the clipped polygon\n\n    for (int v=1; v < num + 1; v++) {\n        vec2 e1 = poly[v - 1].xy - clipA.xy, e2 = poly[v % num].xy - clipA.xy;\n        float dot1 = dot(e1, clipPerp), dot2 = dot(e2, clipPerp);\n        if (dot1 >= 0.0) {\n            clipped[nClip] =  poly[v - 1];\n            nClip++;\n        }\n\n        if ((dot1 >= 0.0) != (dot2 >= 0.0)) {\n            // Relative to clipping line\n            vec2 rel1 = vec2(dot(e1, clipTan), dot1);\n            vec2 rel2 = vec2(dot(e2, clipTan), dot2);\n\n            // Solve for zero and transform back to world space\n            float zero = rel1.x - rel1.y / (rel2.y - rel1.y) * (rel2.x - rel1.x);\n            float det = clipTan.x * clipPerp.y - clipTan.y * clipPerp.x;\n            vec2 clipPos = vec2(clipPerp.y, -clipPerp.x) * zero / det + clipA.xy;\n            \n            // Add to clipped vertices\n            clipped[nClip] = vec3(clipPos,\n                dot2d(clipPos-clipA.xy)<.0001?clipA.z:\n                dot2d(clipPos-clipB.xy)<.0001?clipB.z:0.\n                );\n            nClip++;\n        }\n    }\n    return nClip;\n\n}\n\nint intersectPoly(in vec3[MP] poly, int nPoly,in vec3[MP] clipping, int nClipping,  inout vec3[MP] clipped)\n{\n    int nClip = nPoly;   \n    for(int i=0;i< nClipping;i++)\n    nClip =clipPoly(  clipping[(i+1-POLDIR)%nClipping],  clipping[(i+POLDIR)%nClipping],  clipped,  nClip ,  clipped);    \n    return nClip;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n\n ivec2 ui=ivec2(U);\n if(ui.x>=NP || ui.y>MP) discard;\n \n\n    vec3[MP] poly ;   //original polygon\n    int sPoly=4; \n    poly[0]=vec3(9,-5,2);\n    poly[1]=vec3(-9,-5,2);\n    poly[2]=vec3(-9,5,2);\n    poly[3]=vec3(9,5,2);\n\n    vec2 c= getCenter(ui.x);\n    \n    \n    for(int x =-1;x<2;x++)for(int y =-1;y<2;y++){\n        vec2 c2= getCenter(ui.x +x+y*17);\n        vec2 a = (c+c2)*.5 - (c2-c).yx*vec2(-.1,.1);\n        vec2 b = (c+c2)*.5 + (c2-c).yx*vec2(-.1,.1);\n        if((x!=0 || y!=0 )&& abs(c2.x)<8.5 && abs(c2.y)<4.5) sPoly=clipPoly(  vec3(a,0),  vec3(b,0),  poly,  sPoly ,  poly);\n    }\n    if(sPoly>0){\n        vec2 b=c;\n        \n        //crack:\n        float r= 0.,d=1.; // no rotation or scaling\n        vec2 ct= b+size*.5;\n        ct.y+=sign(b.y)*(1.-cos(iTime))*.1 *(1.-exp(-abs(b.y))); //horizontal crack\n        ct.x+=sign(b.x)*(1.-cos(iTime))*.4 *(1.-exp(-abs(b.x))) ; //vertical crack\n\n\n        if(ui.y==0)  O=vec4(sPoly,ct,ui.x);\n        else {\n           vec2 v = poly[ui.y-1].xy;      \n           v= (v-b)*d *mat2(cos(r),sin(r),-sin(r),cos(r));\n           O=vec4(v,poly[ui.y-1].z,0);\n        }\n    }else O=vec4(0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MP 8 //maximum polygon size (adjust as needed)\n#define NP 153\n#define LOD 8\n#define R iResolution\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ZERO  min(iFrame,0)\n#define size vec2(18.,18.*R.y/R.x)\n#define NGH NP\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Drawing utilities\nvoid drawPoint(inout vec3 pixel, in float unit, in vec2 p, in vec2 pos, in float sz, in vec3 color) {\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, length(p - pos) - sz));\n}\n\nvoid drawLine(inout vec3 pixel, in float unit, in vec2 p, in vec2 a, in vec2 b, in float thickness, in bool inf, in vec3 color) {\n    vec2 pa = p - a, ba = b - a;\n    float proj = dot(pa, ba) / dot(ba, ba);\n    if (!inf) proj = clamp(proj, 0.0, 1.0);\n    float d = length(pa - ba * proj) - thickness;\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, d));\n}\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(sampler2D  ch, inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 sz, in int char) {\n    p = (p - pos) / sz + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(ch, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\nvoid drawChars(sampler2D  ch, inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 sz, int nChars, int[8] chars) {   \n    for(int i=0;i<nChars;i++) drawChar( ch,color,charColor,  p, pos+vec2(i,0)*sz*.5, sz, chars[i]);\n}\n\n\n//Iq SDF\nfloat sdPolygon( in vec2 p, in vec3[MP] v ,int num)\n{\n    \n    float d = dot(p-v[0].xy,p-v[0].xy);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        vec2 e = v[j].xy - v[i].xy;\n        vec2 w =    p - v[i].xy;\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 cond = bvec3( p.y>=v[i].y,  p.y <v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }  \n    return s*sqrt(d);\n}\n\n//Shane stuff\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n// Texture bump mapping. \nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(0.001, 0);  \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.    \n}\n//-------------------------\n\n//https://www.shadertoy.com/view/3llyRl by Jorge2017a1\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdVerticalCapsuleXZ( vec3 p, float h, float r , float offset)\n{\n  p.y -= clamp( p.y, 0.0, h );\n  float d1= length( p ) - r;  \n  d1+=abs(sin(atan(p.x/p.z)*8.0)*(offset*(h-abs(p.y))));\n  return d1;\n}\nfloat sdCactusXZ(vec3 p, float w, float h, float offset)\n{\n    float d1 = sdEllipsoid(p,vec3(w,h,w));\n\td1+=abs(sin(atan(p.x/p.z)*8.0)*(offset*(h-abs(p.y))));\n    return d1;\n}\n\nfloat sdCactusXY(vec3 p, float w, float h, float offset)\n{\n    float d1 = sdEllipsoid(p,vec3(h,w,w));\n\td1+=abs(sin(atan(p.z/p.y)*8.0)*(offset*(h-abs(p.x))));\n    return d1;\n}\n\nfloat Arm(vec3 p)\n{\n\tfloat a1 = sdCactusXY(p-vec3(1.4,0.2,0.0),0.35,1.0,0.0125);\n\tfloat a2 = sdCactusXZ(p-vec3(2.1,1.0,0.0),0.35,1.0,0.0125);   \n    return  min(a1, a2) ;\n}\n\nfloat cactus(vec3 p)\n{\n    \n    vec3 p2=p;\n    \n    float res2= sdVerticalCapsuleXZ(  p-vec3(0.0,-2.0,0.0), 6.0, 0.75 ,0.01226);\n    // arms\n \tres2 = min(Arm(p),res2);    \n    //vec3 p2 = p;\n    p2.x = -p2.x;\n \tres2 = min(Arm(p2-vec3(0.0,0.7,0.0)),res2);\n\n    return res2;\n}\n//----------------------------\n\n\n\nivec2 i2xy(int id) {return ivec2(id, 0);}\nint xy2i(ivec2 p){ return p.x ;}\n\n#define GETTERS \\\nivec4 getBNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nvec4 getAParticle(int id){ vec4 p= texel(iChannel0, i2xy(id)); return vec4(p.yz,p.xw); } \\\nivec4 getCClosest(vec2 p){ return floatBitsToInt(texel(iChannel2, p *vec2(LOD)));} \n//ivec2 p2c(vec2 p){ return ivec2(p);} \\\n//vec2 c2p(ivec2 c){ return vec2(c);} \\\n\nvec2 getCenter(int x){\n    float hd=.7;\n    vec2 c0= vec2(-8+(x%17),-4 + (x/17));\n    vec2 c= c0+ (hash22(c0)-.5)*hd;\n    return c;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particle neighbors \n\nGETTERS\n\n//sorting closest 4 particles\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getAParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y)){ if(d.x > dtemp) {d.x = dtemp;u.x = utemp; }}\n    else if(dx.x < -abs(dx.y)) { if(d.y > dtemp) {d.y = dtemp;u.y = utemp;}}\n    else if(dx.y > abs(dx.x)){ if(d.z > dtemp) {d.z = dtemp;u.z = utemp;} }\n    else if(d.w > dtemp) {d.w = dtemp;u.w = utemp;}\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getBNeighbor(id);\n    for(int j = 0; j < 4; j++) sort(nb[j]);\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n    if(p.x > NP || p.y>1) discard;\n    \n    int id = xy2i(p);     \n    u = ivec4(-1); d = vec4(1e10);    \n    tid = id;\n    pos = getAParticle(id).xy;\n    \n    //sortneighbor(id); \n     \n    for(int i = 0; i < NGH; i++)\n    {\n        int id=(iFrame*NGH+i) % NP;\n        vec4 pp= getAParticle(id);\n        sort(id); \n    }\n    /*\n    ivec4 nc = getCClosest(ivec2(pos)); for(int i = ZERO; i < 4; i++)sort(nc[i]); \n    \n    ivec4 nb = getBNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n        ivec4 nbb = getBNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++) sortneighbor(nbb[j]); \n    }\n    */\n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(NP))))u = ivec4(0);\n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position (from Michael0884)\n\nGETTERS\n\nvec2 cross_distribution(int i) { return vec2((1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 ));}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nfloat particleDistance(int id, vec2 p){ return distance(getAParticle(id).xy, p);}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.w > dtemp){\n        if(d.x > dtemp) { d = vec4(dtemp, d.xyz);u = ivec4(utemp, u.xyz); }\n        else if(d.y > dtemp && dtemp > d.x) { d.yzw = vec3(dtemp, d.yz); u.yzw = ivec3(utemp, u.yz);}\n        else if(d.z > dtemp && dtemp > d.y){d.zw = vec2(dtemp, d.z); u.zw = ivec2(utemp, u.z);}\n        else if(d.w > dtemp && dtemp > d.z){d.w = dtemp;u.w = utemp;}\n    }\n}\n\nvoid sortpos(vec2 p)\n{\n    ivec4 nb = getCClosest(p);\n    for(int j = ZERO; j < 4; j++) sort(nb[j]);\n}\n\nvoid sortPart(int id)\n{\n    ivec4 nb = getBNeighbor(id);\n    for(int j = ZERO; j < 4; j++)sort(nb[j]);\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord /vec2(LOD);   \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen   \n    vec2 p = vec2(pos);     \n    u = ivec4(-1); d = vec4(1e10); \n    \n    sortpos(p); \n    \n    for(int i = ZERO; i < 20; i++)\n    {\n        vec2 p2 =p+cross_distribution(i);        \n        sortpos(p2); \n    }\n    \n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}