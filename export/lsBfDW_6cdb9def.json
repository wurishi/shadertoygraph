{"ver":"0.1","info":{"id":"lsBfDW","date":"1500401799","viewed":113,"name":"Spiraling","username":"zaiyugi","description":"Spiraling down","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.141592\n#define STEPS 150\n\nvec3 light_p = vec3(0.0, 0.0, 0.0);\nvec3 light_n = normalize(vec3(0.0, -1.0, 0.0));\nvec3 light_C = vec3(0.9, 1.0, 0.9);\n\nfloat rad2deg = 180.0 / M_PI;\nfloat deg2rad = M_PI / 180.0;\n\nfloat g_Epsilon = 0.002;\n\nvec3 rotate(in vec3 p, float t)\n{\n    float theta = t * deg2rad;\n\tmat3 mtx = mat3(\n   \t\tcos(theta), -sin(theta), 0.0,\n    \tsin(theta), cos(theta), 0.0,\n    \t0.0, 0.0, 1.0\n\t);\n    return p * mtx;\n}\n\nfloat sdf(vec3 p)\n{\n    p = rotate(p, 30.0 * p.z * 0.075);\n\tvec3 q;\n    q.x = mod(p.x, 5.0) - 2.5;\n    q.y = mod(p.y, 5.0) - 2.5;\n    q.z = mod(p.z, 0.3) - 0.15;\n    \n\treturn length(q) - 0.8;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = g_Epsilon;\n\treturn normalize(vec3(\n\t\tsdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n\t\tsdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n\t\tsdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))\n\t));\n}\n\nfloat shadow(vec3 r0, vec3 rd, float maxt, float k)\n{\n\tfloat t = g_Epsilon;\n\tfloat res = 1.0;\n    vec3 p;\n\tfor( int i = 0; i < 100; ++i )\n\t{\n\t\tif( t >= maxt )\n\t\t\tbreak;\n\n        p = rd*t + r0;\n\t\tfloat h = sdf(p);\n\t\tif(h < g_Epsilon*0.1)\n\t\t\treturn 0.0;\n\t\tres = min( res, k * h / t );\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nfloat light(vec3 p)\n{\n\tvec3 ro = light_p;\n\tvec3 rd = normalize(p - ro);\n\n\tfloat shadowFactor = 0.0;\n\t//if( acos(dot(rd, light_n)) * rad2deg < 45.0 )\n\t\tshadowFactor = shadow( p, -rd, length(p - ro), 5.0 );\n\t    \n\treturn shadowFactor;\n}\n\nvec3 raymarch(vec3 r0, vec3 rd)\n{\n\tvec3 color = vec3(0.0, 0.05, 0.1);\n\tfloat t = 0.0;\n                \n\tvec3 p; int j = 0;\n\tfor(int i = 0; i < STEPS; ++i)\n\t{\n\t\tp = rd * t + r0;\n\t\tfloat d = sdf(p);\n\t\tif(d < g_Epsilon)\n\t\t{\n\t\t\tj = i;\n            break;\n\t\t}\n\t\tt += d;\n\t}\n    \n    float sf = light(p);\n    \n    color = vec3(1.0, 0.5, 0.0);\n    \n    // Blinn-Phong shading\n    // Diffuse\n\tvec3 N = getNormal(p);\n\tvec3 toLgt = normalize(light_p - p);\n\tfloat Id = dot( N, toLgt );\n\tcolor = color * Id;\n    \n    // Specular\n    vec3 H = normalize(toLgt + -rd);\n\tfloat Is = pow( dot(H, N), 60.0 );\n\tcolor += vec3(1.0) * Is;\n\tcolor = clamp(color, 0.0, 1.0);\n    \n\tfloat b = 0.015;\n\tfloat fogStrength = 1.0 - exp(-t * b);\n\n    color = mix(color, vec3(0.1, 0.9, 1.0), fogStrength);\n    color *= sf;\n\t\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p_uv = fragCoord.xy / iResolution.xy;\n\t\n    float aspect_ratio = float(iResolution.x) / float(iResolution.y);\n    p_uv = p_uv * 2.0 - 1.0;\n    \n    float angle = -0.05 * iTime * 2.0 * M_PI;\n    float focal_length = 1.0 / tan( 75.0 / 2.0 * deg2rad );\n    \n    light_p = vec3(0.0, 0.0, iTime + 20.0);\n    light_n = vec3(0.0, 0.0, 1.0);\n    \n    vec3 eye = vec3(2.5 * cos(angle), 2.5 * sin(angle), iTime);\n    vec3 focus = vec3(eye.xy, iTime + 1.0);\n    vec3 view = normalize(focus - eye);\n    vec3 up = -normalize(vec3(eye.xy, 0.0));\n    vec3 right = cross(up, view);\n\n    vec3 rd = normalize(view * focal_length + up * p_uv.y + right * p_uv.x * aspect_ratio);\n    vec3 color = raymarch(eye, rd);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}