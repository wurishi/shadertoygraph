{"ver":"0.1","info":{"id":"4fXGDr","date":"1702937963","viewed":39,"name":"2D Shockwave Test (RS)","username":"roey_shap","description":"Test!\nForked my own previous ripple attempt with a limiter on ring width.\nWarning! Haphazardly made! Not trying to be super efficient or accurate.\nDrag mouse for different shockwave shapes!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shockwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define WHITE vec3(1.0)\n\n#define MINCHUNKY 1.0\n#define MAXCHUNKY 8.0\n\n#define PI 3.1415926535\n\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\n\nmat2 rotationMatrix(float angle) \n{\n    mat2 rotationMatrix;\n    float sinOf = sin(angle);\n    float cosOf = cos(angle);\n    rotationMatrix[0] = vec2(sinOf, cosOf);\n    rotationMatrix[1] = vec2(-cosOf, sinOf);\n    \n    return rotationMatrix;\n}\n\n\nfloat dist(vec2 position){\n    position *= rotationMatrix(iTime);\n\n    float mappedMouse = map(0.1, 0.9, iMouse.x / iResolution.x, MINCHUNKY, MAXCHUNKY);\n    //float mappedTime = map(-1.0, 1.0, sin(iTime), 1.1, 5.9);\n    float n = clamp(mappedMouse, MINCHUNKY, MAXCHUNKY);\n    float x1 = pow(abs(position.x), n);\n    float x2 = pow(abs(position.y), n);\n   \n    return pow(x1 + x2, 1.0/float(n));\n}\n\n\n\nfloat floorTo(float val, float snap)\n{\n    return floor(val / snap) * snap;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float smallerAxis = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / smallerAxis;\n    \n    vec2 rippleCenter = vec2(0.0, 0.0);\n//    float rippleWidth = 0.125;\n//    float rippleDistortionFrequency = 1.75;\n//    float rippleDistortionExaggeration = 1.5;\n    float rippleDurationBase = 0.7;\n    float rippleDurationWait = 1.5;\n    float rippleTotalDuration = rippleDurationBase + rippleDurationWait;\n    float frequency = 1.95;\n    float waveOutputFreq = 1.5;\n    \n    vec2 deltaFromCenter = uv - rippleCenter;\n    vec2 dirFromCenter = normalize(deltaFromCenter);\n    \n    float currentRippleTime = iTime - floorTo(iTime, rippleTotalDuration);\n    float remainingRippleTime = rippleTotalDuration - currentRippleTime;\n    float amplitude = 0.0;\n    float deltaWithTime = dist(deltaFromCenter) + remainingRippleTime;\n    float eps = 0.1;\n    if (deltaWithTime <= rippleDurationBase + eps && deltaWithTime >= rippleDurationBase - eps)\n    {\n        float lengthInfluence = map(rippleDurationBase, 0.0, currentRippleTime, 0.7, 0.5) * 1.0;\n        amplitude = sin(frequency * (((-deltaWithTime * lengthInfluence) + (currentRippleTime)) * (2.0 * PI * waveOutputFreq) / rippleDurationBase));\n        amplitude *= (2.0 * remainingRippleTime) / (1.0 + (10.0 * lengthInfluence) + (dist(deltaFromCenter)));\n    }\n    \n    vec2 offsetUV = uv + (dirFromCenter * amplitude);\n    \n    vec3 col = texture(iChannel0, offsetUV).rgb;\n    float clampLitude = clamp(amplitude * 3.0, -0.5, 1.0); // best variable name ever\n    col = mix(col, WHITE, clampLitude);  //1.0 - currentRippleTime / rippleTotalDuration\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}