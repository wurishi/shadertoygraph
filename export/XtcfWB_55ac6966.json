{"ver":"0.1","info":{"id":"XtcfWB","date":"1541242765","viewed":160,"name":"try refraction","username":"cailuming","description":"simple refraction , but still some problems that I connot solve ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITER 128\n#define PI 3.1415926\nfloat sh = 0.;\nstruct Ray {\n   vec3 o;\n   vec3 d;\n};\n\nmat2 rot2D(float arc){\n   float s = sin(arc);    \n   float c = cos(arc);    \n   return mat2(c,s,-s,c);\n}\n\nvec3 getCol(float v){\n  float r = cos((v-0.75)*PI);\n  float g = cos((v-0.55)*PI);  \n  float b = cos((v-0.25)*PI);\n  \n  return vec3(r,g,b);  \n}\n\nvec3 ground(vec3 p ,vec3 c){\n  p-=c;\n  return vec3(p.y+2.-exp(p.z*0.01),3,0);  \n}\n \nvec3 sphere(vec3 p ,vec3 c){\n   p-=c;\n    \n   float d = length(p);\n   float r = 1.; \n   return vec3(d-r,0,d<r+0.01?1:0);  \n}\n\nvec3 box(vec3 p ,vec3 c){\n   p-=c;\n    \n   p=abs(p); \n    \n   float r = 1.01; \n   float d = max(p.z,max(p.x,p.y))-r;\n   \n   return vec3(d,1,d<r+0.01?1:0);  \n}\n\nvec3 obj1(vec3 p ,vec3 c){\n  p-=c;\n  \n  float s = sin(p.x*6.+iTime*7.)*sin(p.y*6.)*sin(p.z*6.)*0.05;  \n  return vec3(length(p)-1.+s,2,0);  \n}\n\nvoid cmp(inout vec3 a,vec3 b){\n    a = a.x<b.x?a:b;\n}\n//\n\nvec3 map(vec3 p){\n   vec3 ref = vec3(1000.0);\n \n   cmp(ref,sphere(p,vec3(-3,0,0)));\n   cmp(ref,box(p,vec3(0,0,5)));\n   \n   cmp(ref,obj1(p,vec3(3,sh*2.,0.)));\n   \n   cmp(ref,ground(p,vec3(0)));\n      \n   return ref; \n}\n\nvec3 grad(vec3 p){\n   vec2 e = vec2(1,0)*0.001;\n   float m = map(p).x;\n   \n   return -normalize(vec3(m-map(p+e.xyy).x,m-map(p+e.yxy).x,m-map(p+e.yyx).x));\n}\n\n \nfloat shadow(vec3 p,vec3 ld){\n  vec3 o =p;\n  vec3 d = ld;\n  vec3 np = vec3(0);\n  vec3 ret = vec3(0);\n  float t =0.1;  \n  \n  float m =100.0;\n  for (int i=0;i<32;i++){\n\n      np=o+t*d;\n      ret = map(np);\n      m = min(m,ret.x*15./t); \n      if(ret.x<=0.000||t>=32.){\n            \n           return smoothstep(0.,1.,m);\n      }\n       \n      t+=ret.x;\n   }\n}\n\nvoid shading(inout Ray r,inout vec3 col,vec3 p,vec3 lp,float depth,float id,float isin,float bt){\n   vec3 n = grad(p);\n   vec3 ld =  normalize(lp-p);\n   vec3 rd = reflect(r.d,n); \n   float nl = smoothstep(0.,1.0,dot(ld,n)); \n   float hv = dot(normalize(-r.d+ld),n);\n   float rv = 0.4+0.6*pow((1.-hv),5.);\n   nl+=pow(nl,50000.)*5.;\n   \n    \n   if(id==0.){\n      col+=getCol(0.2)*(nl+rv)/bt;\n      \n   }else if(id==1.){\n      \n      col+=getCol(0.6)*(nl+rv)/(bt*depth);\n      \n   }else if(id==2.){\n      \n      col+=getCol(0.95)*(nl+rv)/bt;\n      \n   }else if(id==3.){\n      vec2 muv = mod(floor(p.xz),2.); \n      float v = (muv.x>0. && muv.y>0.)?0.5:1.;\n      col+=getCol(.21)*(nl+1.)*v;\n      \n   }  \n    \n   float s=shadow(p,ld);\n   \n   s = smoothstep(-0.6,1.,s);\n    \n   col/=depth*0.22;\n   \n   col*=s;\n   \n   if(id==0.||id==1.){\n        if(isin==1.){\n            rd = refract(r.d,n,0.6); \n   \n        }else{\n            rd = refract(r.d,n,1.5); \n                \n        }\n        \n    } \n     \n    r.o = p;\n    r.d = rd;\n     \n}\n\nvoid rayTrace(Ray r,vec3 lp,inout vec3 col){\n   float t   = 0.;\n   float bt  = 0.; \n   \n   vec3  ret = vec3(0);\n   vec3  p = vec3(0);\n    \n   for (int i=0;i<MAXITER;i++){\n      p=r.o+t*r.d;\n       \n      ret = map(p);\n       \n       if(t>=64.||bt>=8.){\n          \n         return;\n      }\n      if(ret.x<=0.0005){\n         bt++; \n         shading(r,col,p,lp,t,ret.y,ret.z,bt);\n             \n      }else{\n         t+=ret.x;\n      } \n   }\n   \n}\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n   vec3 look  = normalize(tar-eye);\n   vec3 right = normalize(cross(vec3(0,1,0),look)); \n   vec3 up    = normalize(cross(look,right));\n   \n   r.o = eye;\n   r.d = normalize(uv.x*right+uv.y*up+look);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 tuv = fragCoord/iResolution.xy;\n    vec2 cuv = tuv-vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n    sh =texture(iChannel0,vec2(0.5,0.0)).x;\n    sh = smoothstep(0.,1.,sh);\n    cuv.x*=as;\n    \n    Ray r;\n    vec3 eye = vec3(0,1.0,-9);\n    vec3 tar = vec3(0,0,1);\n    eye.xz*=rot2D(iTime*0.3);   \n  \n    vec3 lp  = vec3(40.*cos(iTime),50,40.*sin(iTime));\n    vec3 col = vec3(0);\n    \n    setCamera(r,eye,tar,cuv);\n    rayTrace(r,lp,col);\n    \n    col = smoothstep(0.,1.,col); \n     \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}