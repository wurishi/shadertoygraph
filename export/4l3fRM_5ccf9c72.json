{"ver":"0.1","info":{"id":"4l3fRM","date":"1538946130","viewed":229,"name":"Cubicus","username":"Cheburum","description":"Please, draw cubes","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["raycast","cube","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtfGzn","filepath":"https://soundcloud.com/aurelievial/patten-1-2","previewfilepath":"https://soundcloud.com/aurelievial/patten-1-2","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 eye = vec3(0.0,0.0,-3.0);\nconst vec3 center = vec3(0.0,0.0,-5.0);\n\nconst float M_PI = 3.14159265358979;\nconst float CO_PLANE_TRESHOLD = 0.01;\nconst float LENGTH_THRESHOLD = 0.04;\nconst int MAX_CUBE = 5;\n\nconst vec3 cube_verts[8] = vec3[8](\n    vec3(-0.5,-0.5,-0.5),\n    vec3(0.5,-0.5,-0.5),\n    vec3(0.5,0.5,-0.5),\n    vec3(-0.5,0.5,-0.5),\n    vec3(-0.5,-0.5,0.5),\n    vec3(0.5,-0.5,0.5),\n    vec3(0.5,0.5,0.5),\n    vec3(-0.5,0.5,0.5)\n);\n\nconst vec3 move_cube = vec3(-0.5,-0.5,5.0);\n\nconst int cube_edges[24] = int[24](\n    0,1,\n    1,2,\n    2,3,\n    3,0,\n    4,5,\n    5,6,\n    6,7,\n    7,4,\n    0,4,\n    1,5,\n    2,6,\n    3,7\n);\n\n\n\nvec3 get_rayDirection(vec2 uv){\n    vec3 start = vec3(uv,0.0)+eye;\n    vec3 delta = start-center;\n    delta.x*=iResolution.x/iResolution.y;\n    delta = normalize(delta);\n    return delta;\n}\nfloat soundEffect(float x){\n    float forced=clamp(iTime/5.0,0.3,2.0);\n    return texture( iChannel0, vec2(x, 0.3) ).x*forced;\n}\n\n\n\nvec3 intersectCubes(vec3 start, vec3 dir){\n    float cos_time = cos(iTime);\n    float sin_time = sin(iTime);\n    \n    mat3 rotation = mat3(\n        cos_time, -sin_time, 0.0,\n        sin_time, cos_time, 0.0,\n        0.0,0.0,1.0\n        );\n    \n    \n    vec3 col = vec3(0.0);\n    \n    \n    for(int cube_id=0; cube_id<MAX_CUBE; ++cube_id){\n        \n        float sound_eff = soundEffect(float(cube_id)/float(MAX_CUBE));\n    \tvec3 cube_motion = vec3(0.0,0.0,sin_time-sound_eff*4.0);\n        \n        \n        vec3 cube_position = vec3(-float(MAX_CUBE/2)+float(cube_id)*1.5,0.0,0.0)\n            +move_cube+cube_motion;\n        for(int i=0; i<int(cos(iTime+sound_eff+float(cube_id))*6.0+6.5);++i){\n            vec3 first_vert = cube_verts[cube_edges[i*2]]*rotation + cube_position;\n            vec3 second_vert = cube_verts[cube_edges[i*2+1]]*rotation + cube_position;\n\n            vec3 line_dir = second_vert-first_vert;\n            vec3 look_line_dir = first_vert - start;\n\n            vec3 line_look_cross = cross(dir,line_dir);\n\n            float dot_pr = dot(look_line_dir, line_look_cross);\n            \n            float normed = dot_pr/CO_PLANE_TRESHOLD/(length(look_line_dir)*length(line_look_cross))*0.5+0.5;\n            \n\n            if(abs(dot_pr)<=CO_PLANE_TRESHOLD)\n            {\n                \n                float s = dot(cross(look_line_dir, line_dir),line_look_cross) / dot(line_look_cross,line_look_cross);\n\n                    vec3 intersection = start + s * dir;\n                \tvec3 inter_vert_1 = intersection - first_vert;\n                \tvec3 inter_vert_2 = intersection - second_vert;\n                    float l_eq = dot(inter_vert_1,inter_vert_1) + dot(inter_vert_2,inter_vert_2);\n                    float r_eq = dot(line_dir,line_dir)+LENGTH_THRESHOLD;\n                    if(l_eq<=r_eq)\n                        col=mix(col,vec3(sound_eff),pow(1.0-abs(normed-0.5),2.0));\n            }\n                \n        }\n    }\n    return col;\n}\n/*\nvec3 intersectCubes_opt(vec3 start, vec3 dir){\n    float cos_time = cos(iTime);\n    float sin_time = sin(iTime);\n    \n    mat3 rotation = mat3(\n        cos_time, -sin_time, 0.0,\n        sin_time, cos_time, 0.0,\n        0.0,0.0,1.0\n        );\n    \n    \n    vec3 col = vec3(0.0);\n    \n    \n    for(int cube_id=0; cube_id<MAX_CUBE; ++cube_id){\n        \n        float sound_eff = soundEffect(float(cube_id)/float(MAX_CUBE));\n    \tvec3 cube_motion = vec3(0.0,0.0,sin_time-sound_eff*4.0);\n        \n        \n        vec3 cube_position = vec3(-float(MAX_CUBE/2)+float(cube_id)*1.5,0.0,0.0)\n            +move_cube+cube_motion;\n        for(int i=0; i<int(cos(iTime+sound_eff+float(cube_id))*6.0+6.5);++i){\n            vec3 first_vert = cube_verts[cube_edges[i*2]]*rotation + cube_position;\n            vec3 second_vert = cube_verts[cube_edges[i*2+1]]*rotation + cube_position;\n            \n            vec3 vec_to_first = first_vert-start;\n            vec3 vec_to_second = second_vert-start;\n            \n            float dist_to_first = length(vec_to_first);\n            float dist_to_second = length(vec_to_second);\n            \n            vec3 dir_to_first = vec_to_first/dist_to_first;\n            vec3 dir_to_second = vec_to_second/dist_to_second;\n            \n            vec3 dir_diff_first = dir - dir_to_first;\n            vec3 dir_diff_second = dir - dir_to_second;\n            \n            float dot_first = dot(dir_diff_first,dir_diff_first);\n            float dot_second = dot(dir_diff_second,dir_diff_second);\n            \n            if(dot_first<=0.001)\n                col = mix(col, vec3(1.0),1.0/dot_first*0.001);\n            \n            if(dot_second<=0.001)\n                col = mix(col, vec3(1.0),1.0/dot_second*0.001);\n                \n        }\n    }\n    return col;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*2.0;\n\n    vec3 direction = get_rayDirection(uv);\n    //if(iFrame%4==0){\n    vec3 color = intersectCubes(center,direction);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}