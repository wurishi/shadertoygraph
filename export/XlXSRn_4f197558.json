{"ver":"0.1","info":{"id":"XlXSRn","date":"1433974200","viewed":295,"name":"Junkyard","username":"kuvkar","description":"Someone left random junk flying around it seems. Just messing around with distance fields and repetition.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","repetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/// utils\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n////\n// from https://iquilezles.org/articles/distfunctions\n////\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n///// my stuff\n\nfloat map(in vec3 rp)\n{\n    vec3 c = vec3(1.0);\n    \n    vec2 uv = vec2(floor(mod(rp.z, 5.0) * 0.15), floor(mod(rp.y, 6.0)) * 0.25);\n    vec4 txc = texture(iChannel0, uv);\n   \tfloat f = max(txc.r, 0.1);\n    vec3 rpm = mod(rp, c) - c * 0.5;\n    \n    float d1 = mix(sdSphere(rpm, 0.15), sdBox(rpm, vec3(0.20)), sin(iTime));\n    float d2 = sdBox (rpm * rotx(iTime * f * 14.0), vec3(f * 1.4, 0.1, 0.1));\n    float d3 = sdBox (rpm * rotx(iTime * f * 6.0), vec3(0.1, 0.1, f * 1.3));\n    float r = smin(d1, d2, 0.2);\n    \n    r = smin(r, d3, 0.1);\n    return r;   \n}\n\n\nvec3 grad(in vec3 rp)\n{\n    vec2 offset = vec2(0.001, 0.0);\n\tvec3 g = vec3(map(rp + offset.xyy) - map(rp - offset.xyy),\n                  map(rp + offset.yxy) - map(rp - offset.yxy),\n                  map(rp + offset.yyx) - map(rp - offset.yyx));\n    \n    return normalize(g);\n}\n\n\nvec3 ld = normalize(vec3(0.5, 0.4, -0.7));\n\nvoid trace(inout vec3 rp, in vec3 rd, inout vec4 color)\n{\n    float trvl = 0.0;\n    vec3 ro = rp;\n    \n    for (int i = 0; i < 70; ++i)\n    {\n        float d = map(rp);\n        if ( d <= 0.0 )\n        {\n            rp += d * rd;\n            vec3 gr = grad(rp);\n            float cc1 = floor(mod(rp.z, 3.0)) * 0.33;\n            float cc2 = floor(mod(rp.x, 3.0)) * 0.33;\n            \n            // diffuse\n            float dp = dot(ld, gr);\n            dp = clamp(dp, 0.1, 1.0);\n            color = dp * vec4(cc1, cc2, 1.0, 0.0);\n\t\t\t            \n            // specular\n            vec3 H = normalize(-rd +ld);\n            float sd = dot(H, gr);\n            sd = clamp(sd, 0.0, 1.0);\n            sd = pow(sd, 6.0);\n            color += vec4(1.0, 1.0, 0.0, 0.0) * sd;\n            \n            // rim\n            float rimd = 1.0 - clamp(dot(-rd, gr), 0.0, 1.0);\n            rimd = pow(rimd, 3.0);\n            color += rimd * vec4(0.4, 1.0, 0.0, 0.0);\n            \n            color += texture(iChannel1, reflect(gr, rd)) * 0.35;\n            return;\n        }\n        trvl += max(d * 0.8, 0.010);\n        rp = ro + rd * trvl;\n        \n        if(trvl > 10.0)\n        {\n            return;\n        }\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    vec2 _uv = uv;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    // dila's fisheye trick\n    vec3 rd = normalize(vec3(uv, (1.0 - dot(uv, uv) * 1.3))); \n    rd *= roty(sin(iTime * 0.25) * 1.0);\n    rd *= rotx(cos(iTime * 0.25) * 1.0);\n\n    vec3 rp = vec3(0.0, 0.0, -1.0);\n    rp.x += sin(iTime * 0.25) * 2.0;\n    rp.y += sin(iTime * 0.5) * 0.05;\n    rp.z += iTime;\n    \n    vec3 ro = rp;\n    trace(rp, rd, fragColor);\n    \n    float dist = length(ro - rp);\n    fragColor += smoothstep(5.0, 7.0, dist) * vec4(1.4,1.7, 1.8, 0.0);\n    fragColor *= (1.0 - smoothstep(0.1, 0.77, length(_uv))) * vec4(0.7, 0.7, 0.7, 1.0);\n    \n}","name":"","description":"","type":"image"}]}