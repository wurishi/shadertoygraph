{"ver":"0.1","info":{"id":"WtfBWS","date":"1598176444","viewed":54,"name":"Tata","username":"surffer3d","description":"BTS Tata","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float _PI = 3.1415926535897932384626433832795;\nconst float _2PI = _PI * 2.0;\nconst float _PI2 = _PI * 0.5;\n\nfloat shape = 1000.0;\n\nfloat box(vec2 uv, vec2 sz) {\n    vec2 a = abs(uv) - sz;\n    return length(max(a,0.0)) + min(max(sz.x,sz.y),0.0);\n}\n\n\nfloat circle(vec2 uv, float r) {\n    return length(uv) - r;\n}\n\nfloat elipse(vec2 uv, float rx, float ry) {\n    float angle = atan(uv.x, uv.y);\n    vec2 st = vec2(rx,ry) * vec2(cos(angle),sin(angle));\n    return length(uv) - length(st);\n}\n\nfloat capsule(vec2 uv, vec2 sz) {\n    vec2 p = abs(uv);\n    return length(p-vec2(min(p.x, sz.x),0.0)) - sz.y;\n}\n\n\nfloat polygon(vec2 uv, float r, float sides) {\n    float sect = _2PI / sides;\n    float angle = sides * (atan(uv.y, uv.x) / _2PI + 0.5);\n    float fangle = fract(angle);\n    float d = length(uv);\n    float L = r * (1.0 - 2.0 * cos(sect*0.5));\n    float D = L / tan(sect*0.5);\n    float H = D * tan(abs(fangle-0.5)*sect);\n    float d2 = sqrt(H*H+D*D);\n    return d - d2;\n}\n\nfloat head(vec2 uv) {\n    const float r = 0.2;\n    float angle = atan(uv.x, -uv.y);\n    float fangle = 1.0-fract(abs(angle/_PI));\n    float limit = 0.75;\n    float d = length(uv);\n    \n    float a = fangle/limit;\n    float fa = sin(a*_PI);\n    fa = fa * cos(a*_PI2);\n    a = fa * (0.15 + step(0.0, angle)*0.1*pow(cos(a*_PI2),2.0));\n        \n    float b = (fangle-limit)/(1.0-limit);\n    float fb = b * pow(sin(b),2.0);\n    b = fb * 0.05;\n    \n    float m = mix(a, b, step(limit, fangle));\n    return d - r - m;\n}\n\nfloat elipse(vec2 uv, float r) {\n    float e = 0.001;\n    vec2 euv = vec2(e, 0.0);\n    float g = length(vec2(circle(uv-euv.xy,r)-circle(uv+euv.xy,r),\n                  circle(uv-euv.yx,r)-circle(uv+euv.yx,r))) / (2.0*e);\n    return circle(uv,r) / g;\n}\n\n\nfloat plot(float uv, float v) {\n    float w = 0.005 + fwidth(uv);\n    return smoothstep(v-w, v, uv) - smoothstep(v, v+w, uv);\n}\n\nfloat merge(float A, float B) {\n    return min(A, B);\n}\n\nfloat intersect(float A, float B) {\n    return max(A, B);\n}\n\nfloat substract(float A, float B) {\n    return intersect(A,-B);\n}\n\nvec3 fill(vec3 color, float d, vec3 fcolor, float bsz, vec3 bcolor) {\n    color = mix(color, bcolor, smoothstep(bsz+fwidth(d), bsz, d));\n    color = mix(color, fcolor, smoothstep(fwidth(d), 0.0, d));\n    return color;\n}\n\nvec3 fill(vec3 color, float d, vec3 fcolor) {\n    color = mix(color, fcolor, smoothstep(fwidth(d), 0.0, d));\n    return color;\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c) * uv;\n}\n\nvec3 COL_LINE = vec3(0.0);\n\n\nfloat head2(vec2 uv) {\n    float e = 0.001;\n    vec2 euv = vec2(e, 0.0);\n    float g = length(vec2(head(uv-euv.xy)-head(uv+euv.xy),\n                  head(uv-euv.yx)-head(uv+euv.yx))) / (2.0*e);\n    \n    float d = head(uv) / g;\n    \n    shape = merge(shape, d);\n    \n    return d;\n}\n\nvoid drawHead(inout vec3 col, vec2 uv) {\n    float angle = 0.15;\n    angle = sin(iTime) * 0.15;\n    uv = rotate(uv, angle);\n    \n    col = fill(col, head2(uv), vec3(0.95,0.0,0.0), 0.025, COL_LINE);\t// head\n    col = fill(col, circle(uv-vec2(-0.04,-0.04), 0.012), COL_LINE);\t// eye\n    col = fill(col, circle(uv-vec2( 0.04,-0.04), 0.012), COL_LINE);\t// eye\n    col = fill(col, capsule(uv-vec2(-0.04,-0.01), vec2(0.015,0.005)), COL_LINE);\t// eye brush\n    col = fill(col, capsule(uv-vec2( 0.04,-0.01), vec2(0.015,0.005)), COL_LINE);\t// eye brush\n    \n    \n    // Mouth\n    vec2 stmouth = uv-vec2(0.0,-0.11);\n    stmouth.y *= 1.5;\n    col = fill(col, circle(stmouth, 0.04), vec3(0.95,0.95,0.), 0.015, COL_LINE);\t// mouth\n    col = fill(col, capsule(uv-vec2(0.0,-0.11), vec2(0.015,0.0035)), COL_LINE);\t// mouth\n}\n\nvoid drawBody(inout vec3 col, vec2 uv) { \n    float body = 0.0f;\n    {\n    vec2 st = rotate(uv, _PI2-0.04);\n    float l1 = capsule(st-vec2( 0.05,-0.3).yx, vec2(0.2,0.07));\n    body = l1;\n    }\n    \n    {\n    vec2 st = rotate(uv, _PI2+0.04);\n    float l2 = capsule(st-vec2(-0.05,-0.3).yx, vec2(0.2,0.07));\n    body = merge(body, l2);\n    }\n    \n    {\n    vec2 st = rotate(uv, 0.5);\n    float l2 = capsule(st-vec2(-0.15,-0.25).yx, vec2(0.1,0.07));\n    body = merge(body, l2);\n    }\n    \n    {\n    vec2 st = rotate(uv, 0.85);\n    float l2 = capsule(st-vec2(-0.2,0.0).yx, vec2(0.1,0.07));\n    body = merge(body, l2);\n    }\n    \n    vec2 fst = fract(rotate(uv, -0.35) * 6.0);\n    vec2 st = fract(fst + vec2(0.0, 0.5*step(0.0, fst.x)));\n    float circles = circle(st-0.5, 0.2);\n    vec3 color = mix(vec3(0.95, 0.9, 0.005), vec3(0.4,0.5,0.8), smoothstep(0.0, fwidth(circles), circles));\n    col = fill(col, body, color, 0.025, COL_LINE);\n    \n    shape = merge(shape, body);\n}\n\n    \nvec3 background(vec2 uv) {\n    uv = rotate(uv, iTime*0.5);\n    float st = (atan(uv.x, uv.y))/_2PI;\n    float l = pow(length(uv),0.15)*10.0;\n    float d = floor(l)+st;\n    d = l-d;\n    d = min(abs(d), abs(1.0-d));\n    float f = d;\n    float sc = 0.5*(sin(iTime*0.15)+1.0)*0.4;\n    f = smoothstep(0.05+sc, 0.05+sc+fwidth(f), f);\n    return mix(vec3(0.95, 0.95, 0.85), vec3(0.85, 0.3, 0.3), f);\n}\n\n\nvec3 grade(vec3 col, vec2 fragCoord) {\n    float d = step(0.5,fract(fragCoord.y*0.25));\n    return col * (0.95 + 0.05*d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 5.0;\n    vec2 fuv = fract(uv);\n\n    // Time varying pixel color    \n    uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //uv.x = uv.x + 0.02*uv.y*sin(uv.y/0.2+iTime*2.0);\n    \n    vec3 col = background(uv);\n    \n    drawBody(col, uv);\n    drawHead(col, uv);\n    \n    col = grade(col, fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}