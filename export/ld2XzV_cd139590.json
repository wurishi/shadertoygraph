{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// caosdoar@gmail.com 2014\n\n// Some defines to control the mouse inputs\n#define MOUSE_INPUT 0\n#define MOUSE_INPUT_MODE 0\n\n// Anti-aliased step from Stefan Gustavson\nfloat aastep(float threshold, float value) \n{\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n   \n// The inverted box for the room\nfloat room(vec3 p)\n{\n    vec3 d = abs(p) - vec3(10.0, 3.5, 10.0);\n    return -max(d.x, max(d.y, d.z));\n}\n\nfloat mapTerrain(vec3 p)\n{\n    return room(p);\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n\tfloat maxd = 30.0;\n    float h = 1.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n        if( h<(0.001*t)||t>maxd ) break;\n\t    h = mapTerrain( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\n// An approximation to calculate regular polygons\nfloat poly(vec2 p, vec2 c, float l, float r)\n{\n    vec2 v = p - c;\n    float v_l = length(v);\n    vec2 n = v / v_l;\n    float a = acos(dot(n, vec2(1.0, 0.0)));\n    float pi_l = 3.14159265/l;\n    a = mod(a, 2.0*pi_l);\n    a = abs(a - pi_l);\n    float d = cos(pi_l);\n    return v_l - r * (d / cos(a));\n}\n\nfloat polylines(vec2 p, vec2 c, float l)\n{\n    vec2 v = p - c;\n    float v_l = length(v);\n    vec2 n = v / v_l;\n    float a = acos(dot(n, vec2(1.0, 0.0))) + 3.14159265 / l;\n    float line_angle = floor(a * l / 6.283185) * 6.283185 / l;\n    vec2 line_dir = normalize(vec2(cos(line_angle), sin(line_angle)));\n    return length((-v)-dot(-v,line_dir)*line_dir);\n}\n\n// A fancy circle\nfloat circle_curves(vec2 p, float r, float l)\n{\n    vec2 n = normalize(p);\n    float a = acos(dot(n, vec2(1.0, 0.0)));\n    float pi_l = 3.14159265/l;\n    a = mod(a, 2.0*pi_l);\n    a = abs(a - pi_l);\n    float s = a/pi_l;\n    s *= s;\n    return length(p) - (r - 0.01*r*s);\n}\n\n// Just a square\nfloat square(vec2 p, float lh)\n{\n    vec2 d = abs(p) - lh;\n    return max(d.x, d.y);\n}\n\nvec2 rotate_point(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\n// WIP test for the middle pattern\nfloat alahambra_pattern(vec2 p)\n{\n    /*p *= 1.5;\n    \n    float a = poly(p, vec2(0.0), 8.0, 0.3);\n    float b = poly(p, vec2(0.3, 0.3), 8.0, 0.3);\n    float c = poly(p, vec2(-0.3, 0.3), 8.0, 0.3);\n    float d = poly(p, vec2(0.3, -0.3), 8.0, 0.3);\n    float e = poly(p, vec2(-0.3, -0.3), 8.0, 0.3);\n    float f = poly(p, vec2(0.3, 0.0), 8.0, 0.3);\n    float g = poly(p, vec2(-0.3, 0.0), 8.0, 0.3);\n    float h = poly(p, vec2(0.0, 0.3), 8.0, 0.3);\n    float i = poly(p, vec2(0.0, -0.3), 8.0, 0.3);\n    \n    float lines = \n        min(abs(a), \n        min(abs(b), \n        min(abs(c), \n        min(abs(d), \n        min(abs(e),\n        min(abs(f),\n        min(abs(g),\n        min(abs(h),\n        abs(i)))))))));\n   \tlines = min(1.0, lines * 100.0);\n    return lines;*/\n   \n    float a = poly(p, vec2(0.0), 12.0, 0.1);\n    \n    float b = poly(p, vec2(0.0), 6.0, 0.15);\n    float b1 = poly(p, vec2(0.225, 0.13), 6.0, 0.15);\n    float b2 = poly(p, vec2(-0.225, 0.13), 6.0, 0.15);\n    float b3 = poly(p, vec2(0.225, -0.13), 6.0, 0.15);\n    float b4 = poly(p, vec2(-0.225, -0.13), 6.0, 0.15);\n    float b5 = poly(p, vec2(0.0, 0.26), 6.0, 0.15);\n    float b6 = poly(p, vec2(0.0, -0.26), 6.0, 0.15);\n    \n    float c = polylines(p, vec2(0.0), 12.0);\n    //float lines = min(abs(a), abs(b) * (c) );\n    \n    float s0 = square(rotate_point(p, 3.14159/12.0), 0.085);\n    float s1 = square(rotate_point(p, 3.14159*5.0/12.0), 0.085);\n    float s2 = square(rotate_point(p, 3.14159*9.0/12.0), 0.085);\n    \n    float lines = abs(abs(b) - 0.01) * 300.0;\n    lines = min(lines, abs(abs(b1) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b2) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b3) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b4) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b5) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b6) - 0.01) * 300.0);\n    \n    lines = min(lines, abs(s0) * 300.0);    \n    lines = min(lines, abs(s1) * 300.0);    \n    lines = min(lines, abs(s2) * 300.0);\n    \n    return lines;\n    //return min(1.0, lines * 100.0);\n}\n\n// One of the faces of the shadow box\nfloat shadowPlane(vec2 p)\n{\n    //return aastep(0.5, alahambra_pattern(p));\n    \n    vec2 p_abs = abs(p);\n    float p_abs_min = min(p_abs.x, p_abs.y);\n    float d = length(p);\n    \n    float c0 = min(1.0, abs(d - 0.35) * 80.0);\n    float c1 = min(1.0, abs(d - 0.48) * 80.0);\n    float c2 = min(1.0, abs(circle_curves(p, 0.55, 40.0)) * 120.0);\n    float c3 = min(1.0, abs(circle_curves(p, 0.59, 40.0)) * 80.0);\n    float s0 = min(1.0, abs(square(p, 0.595)) * 90.0);\n    float s1 = min(1.0, abs(square(p, 0.8)) * 90.0);\n    float s2 = min(1.0, abs(square(p, 1.0)) * 10.0);\n    /*s2 *= s2;\n    s2 *= s2;*/\n    \n    float lines = min(c0, min(c1, min(c2, min(c3, min(s0, min(s1, s2))))));\n    \n    \n    vec2 p45 = vec2(p.x-p.y,p.x+p.y) * 0.7071;\n    \n    float g0 = min(1.0, abs(square(fract(p45 * 40.0) * 2.0 - 1.0, 1.0)) * 2.0);\n    g0 = mix(1.0, g0, step(0.0, square(p, 0.8)));\n    float g1 = alahambra_pattern(p);\n    g1 = mix(1.0, g1, step(d - 0.35, 0.0));\n    \n    float patterns = min(g0, g1);\n    \n    return aastep(0.5, min(lines, patterns));\n}\n\n// Box in the middle of the room that creates the shadows\nfloat shadowBox(vec3 l)\n{\n    vec2 uv;\n    vec3 labs = abs(l);\n    float lmax = max(labs.x, max(labs.y, labs.z));\n    if (labs.x == lmax) uv = l.yz;\n    if (labs.y == lmax) uv = l.xz;\n    if (labs.z == lmax) uv = l.xy;\n    \n\tuv /= lmax;\n    \n    return shadowPlane(uv);\n    \n    /*uv = floor(uv * 5.0);\n    return mod(uv.x+uv.y, 2.0) * 0.5 + 0.5;\n    return length(uv);*/\n}\n\nfloat mapLamp(vec3 p)\n{\n    float l = 2.0;\n    vec3 d = abs(p) - l;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nfloat raymarchLamp(vec3 ro, vec3 rd)\n{\n\tfloat maxd = 30.0;\n    float h = 1.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n        if( h<(0.001*t)||t>maxd ) break;\n\t    h = mapLamp( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\n// Simplest lighting possible\nfloat lighting(vec3 p, vec3 n)\n{\n    vec3 l = -normalize(p);\n    float c = dot(n, l);\n    float shadow = shadowBox(-l);\n    c *= shadow;\n    return c;\n}\n\n// Transform from spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p)\n{\n    vec2 s  = sin(p);\n    vec2 c  = cos(p);\n    return normalize(vec3(c.x * s.y, c.y, s.x * s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#if MOUSE_INPUT\n    \n#if MOUSE_INPUT_MODE == 0 \n    // Rotate camera around the center\n    vec2 camSphe = vec2(0.0, 1.175) + iMouse.xy / iResolution.xy * vec2(5.0, 0.7);\n    vec3 co = sphe2cart(camSphe) * 9.0;\n    vec3 cd = vec3(0.0, 0.0, 0.0);\n#else\n    // Rotate the camera from the corner\n    vec3 co = vec3(8.5, -2.0, 8.5);\n    vec2 camSphe = vec2(0.0, 1.57) + (vec2(iMouse.x, -iMouse.y) / iResolution.xy - vec2(0.5)) * vec2(3.0, 1.5);\n    vec3 cd = co + sphe2cart(vec2(-2.4, 1.3) + camSphe);\n#endif\n\n#else\n    \n    vec2 camSphe;\n    if (iMouse.z < 1.0)\n    {\n        camSphe = vec2(iTime * 0.1, sin(iTime * 0.2) * 0.2 + 1.5);\n    }\n    else\n    {\n        camSphe = vec2(0.0, 1.175) + iMouse.xy / iResolution.xy * vec2(5.0, 0.7);\n    }\n    \n    vec3 co = sphe2cart(camSphe) * 9.0;\n    vec3 cd = vec3(0.0, 0.0, 0.0);\n    \n#endif\n    \n    // Camera\n    vec3 cf = normalize(cd - co);\n    vec3 cu = vec3(0.0,1.0,0.0);\n    vec3 cr = normalize(cross(cf, cu));\n    cu = cross(cr, cf);\n    \n    // Raymarch\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.0;\n    vec3 rd = normalize(cf + cr * uv.x + cu * uv.y);\n    float a = raymarch(co, rd);\n    vec3 p0 = co + rd * a;\n    vec3 n = calcNormal(p0);\n    \n    // Profit!\n    vec3 colour = lighting(p0, n) * vec3(0.85, 0.75, 0.6);\n    \n    // Raymarch lamp\n    float a1 = raymarchLamp(co, rd);\n    if (a1 > 0.0)\n    {\n    \tvec3 p1 = co + rd * a1;\n        colour = mix(vec3(0.1), colour, shadowBox(p1));\n    }\n    \n\tfragColor = vec4(vec3(colour),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2XzV","date":"1414096878","viewed":756,"name":"Lighting room","username":"caosdoar","description":"Reference:\nhttp://www.slate.com/blogs/the_eye/2014/10/17/intersections_art_installation_by_anila_quayyum_agha_uses_laser_cut_wood.html","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighting","shadows","distance","alahambra"],"hasliked":0,"parentid":"","parentname":""}}