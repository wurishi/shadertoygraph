{"ver":"0.1","info":{"id":"MltXWl","date":"1482345697","viewed":192,"name":"glowing leds","username":"acdimalev","description":"I've been studying and it's test time.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","pbr","ld48"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Glowing LEDs\n//\n//\n// Abstract\n//\n// I failed at Ludum Dare recently.  During the competition I asked myself if I could\n// write a game that ran nearly 100% out of GLSL.  To my surprise, the answer is\n// \"quite possibly\".  But one of the hurdles is learning how to render a scene without\n// too much help from an external program.\n//\n// Since there are really nice modern tools like Shadertoy to practice with GLSL,\n// and since GLSL is still the industry standard for writing shaders, I decided to\n// persue studying modern rendering techniques.\n//\n// This demo is a record of my progress.\n//\n// In particular, it is a demonstration, with several references, of the following\n// techniques:\n//\n// - Signed Distance Function\n// - Color Space Conversion\n// - Physically-Based Rendering\n//\n//\n// References\n//\n// Ray Marching and Signed Distance Functions\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n//\n// PBR_Test\n// https://www.shadertoy.com/view/MlB3DV\n//\n// PHYSICALLY-BASED RENDERING, AND YOU CAN TOO!\n// https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/\n//\n// Physically-Based Shading at Disney\n// http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_slides_v2.pdf\n//\n\nconst float EPSILON = 1.0 / 256.0;\nconst float PI = 3.14159;\n\nfloat op_i(float d1, float d2) { return max(d1, d2); }\nfloat op_u(float d1, float d2) { return min(d1, d2); }\n\nfloat sd_plane(vec3 p, vec4 n) {\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sd_segment(vec3 p, float a, float b, float c, float d) {\n    vec3 q1 = abs(p);\n    vec3 q2 = q1 + vec3(0.0, d, 0.0);\n    float n2 = 1.0 / sqrt(2.0);\n    float n3 = 1.0 / sqrt(3.0);\n    float d1 = sd_plane(q2, vec4(n3, n3, n3, -a * n3));\n    float d2 = q1.y - b;\n    float d3 = sd_plane(q1, vec4(n2, n2, 0.0, -c));\n    return op_i(d1, op_i(d2, d3));\n}\n\nfloat scene_sdf(vec3 p) {\n    // FIXME: adding a slant here distorts the distance function\n    vec3 p1 = p; // vec3(p.x + p.z / 4.0, p.y, p.z);\n    vec3 c0 = vec3(2.0, 1024.0, 2.0);\n    vec3 c1 = vec3(0.0, c0.y, 0.0);\n    vec3 q1 = mod(p1 + c1 / 2.0, c0) - c0 / 2.0;\n    vec3 q2 = mod(p1.zyx + c0 / 2.0, c0) - c0 / 2.0;\n    \n    vec4 v = vec4(1.0, 1.0/32.0, 1.0/4.0, 1.0/8.0);\n    float d1 = sd_segment(q1, v.x, v.y, v.z, v.w);\n    float d2 = sd_segment(q2, v.x, v.y, v.z, v.w);\n    return op_u(d1, d2);\n}\n\nvec3 ray_march(vec3 eye, vec3 ray, float max_depth) {\n    const int max_iterations = 64;\n    const float E = EPSILON;\n    \n    float dist = 0.0;\n    float sdf = 0.0;\n    float iter = 0.0;\n    \n    for (int i = 0; i < max_iterations; i++) {\n        iter = float(i);\n        vec3 p = eye + dist * ray;\n        sdf = scene_sdf(p);\n        if (sdf < E * dist) { break; }\n        dist += sdf;\n        if (dist > max_depth) { break; }\n    }\n    \n    return vec3(dist, sdf, iter);\n}\n\nvec3 ray_normal(vec3 eye, vec3 ray, vec3 marched) {\n    const vec2 o = vec2(0.0, EPSILON);\n    \n    float d = marched.y;\n    vec3 p = eye + marched.x * ray;\n    \n    return normalize(vec3(\n        scene_sdf(p + o.yxx) - d,\n        scene_sdf(p + o.xyx) - d,\n        scene_sdf(p + o.xxy) - d ));\n}\n\nvec3 half_vector(vec3 v1, vec3 v2) {\n    return normalize(v1 + v2);\n}\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nfloat geometric_attenuation(vec3 n, vec3 v, vec3 l) {\n    vec3 h = half_vector(v, l);\n\n    float c = 2.0 * dot(h, n) / dot(v, h);\n    float g1 = c * dot(v, n);\n    float g2 = c * dot(l, n);\n\n    return min(1.0, min(g1, g2));\n}\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Beckmann_distribution\nfloat beckmann_distribution(vec3 n, vec3 v, vec3 l, float roughness) {\n    vec3 h = half_vector(v, l);\n    float m = roughness;\n\n    float n_dot_h = dot(n, h);\n    float n_dot_h_sq = n_dot_h * n_dot_h;\n    float n_dot_h_qu = n_dot_h_sq * n_dot_h_sq;\n    float m_sq = m * m;\n\n    float expr1 = (n_dot_h_sq - 1.0) / (n_dot_h_sq * m_sq);\n    float expr2 = PI * m_sq * n_dot_h_qu;\n\n    return exp(expr1) / expr2;\n}\n\n// https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat shlick_fresnel(vec3 n, vec3 v, vec3 l, float reflection_coefficient) {\n    vec3 h = half_vector(v, l);\n    float c = reflection_coefficient;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n// with a separate reflection coefficient for each color channel\nvec3 shlick_fresnel(vec3 n, vec3 v, vec3 l, vec3 reflection_coefficients) {\n    vec3 h = half_vector(v, l);\n    vec3 c = reflection_coefficients;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nvec3 specular(vec3 n, vec3 v, vec3 l, vec3 F0, float roughness) {\n    vec3 reflection_coefficients = F0;\n    \n    float d = beckmann_distribution(n, v, l, roughness);\n    vec3 f = shlick_fresnel(n, v, l, reflection_coefficients);\n    float g = geometric_attenuation(n, v, l);\n    \n    vec3 k1 = d * f * g;\n    float k2 = 4.0 * dot(v, n) * dot(n, l);\n    \n    return k1 / k2;\n}\n\n// FIXME: locate source of this \"trivial BRDF\"\nvec3 diffuse(vec3 albedo) {\n    return albedo / PI;\n}\n\nvec3 render(vec3 eye, vec3 ray, vec3 marched, vec3 albedo, vec3 glow, float metalness, float roughness) {\n    vec3 n = ray_normal(eye, ray, marched);\n    vec3 v = -ray;\n    vec3 p = eye + marched.x * ray;\n    \n    vec3 diffuse_albedo = albedo * (1.0 - metalness);\n    vec3 F0 = 0.04 * (1.0 - metalness) + albedo * metalness;\n    \n    vec3 light1p = vec3(0.0, 8.0, 12.0);\n    vec3 light1c = vec3(1.0);\n    vec3 l1 = normalize(light1p - p);\n    vec3 specular1 = specular(n, v, l1, F0, roughness);\n    vec3 diffuse1 = diffuse(diffuse_albedo);\n    vec3 color1 = (diffuse1 + specular1) * light1c * max(0.0, dot(l1, n));\n\n    vec3 light2c = vec3(1.0 / 4.0);\n    vec3 l2 = vec3(0.0, -1.0, 0.0);\n    vec3 diffuse2 = diffuse(diffuse_albedo);\n    vec3 color2 = diffuse2 * light2c * max(0.0, dot(l2, n));\n    \n    return glow + color1 + color2;\n}\n\n// calculate ray vector for a given fragment coordinate\n//\n// this function also determines the handed-ness of the coordinate system\n//   z < 0 : left-handed\n//   z > 0 : right-handed\n//\nvec3 ray_vector(float fov, vec3 iResolution, vec2 fragCoord) {\n\n    // FIXME -- account for pixel aspect ratio\n    // iResolution.z is the pixel aspect ratio\n    // since this is 1.0 on my machine, I can not properly test compensation\n\n    // scale relative to pixel density\n    float size = sqrt(iResolution.x * iResolution.y);\n\n    // calculate vector in screen coordinates\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (size / 2.0) / tan(fov / 2.0);\n\n    // return normalized vector\n    return normalize(vec3(xy, z));\n}\n\n// return a view matrix from `eye` to `center`\n//\n// based on gluLookAt\n// and kindly translated to GLSL by jlfwong\n// https://www.shadertoy.com/user/jlfwong\n//\n// the sign of `f` on the output matrix must be adjusted\n// to match the handed-ness of the coordinate system\n//   left-handed: -f\n//   right-handed: f\n//\nmat3 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat3(s, u, f);\n}\n\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 tonemap(vec3 hdr, float white_point) {\n    vec4 vh = vec4(hdr, white_point);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 srgb_to_linear(vec3 srgb) {\n    float a = 0.055;\n    float b = 0.04045;\n    vec3 linear_lo = srgb / 12.92;\n    vec3 linear_hi = pow((srgb + vec3(a)) / (1.0 + a), vec3(2.4));\n    return vec3(\n        srgb.r > b ? linear_hi.r : linear_lo.r,\n        srgb.g > b ? linear_hi.g : linear_lo.g,\n        srgb.b > b ? linear_hi.b : linear_lo.b);\n}\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 linear_to_srgb(vec3 linear) {\n    float a = 0.055;\n    float b = 0.0031308;\n    vec3 srgb_lo = 12.92 * linear;\n    vec3 srgb_hi = (1.0 + a) * pow(linear, vec3(1.0/2.4)) - vec3(a);\n    return vec3(\n        linear.r > b ? srgb_hi.r : srgb_lo.r,\n        linear.g > b ? srgb_hi.g : srgb_lo.g,\n        linear.b > b ? srgb_hi.b : srgb_lo.b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = radians(45.0);\n    const float max_depth = 256.0;\n    \n    const vec3 albedo = vec3(0.7, 0.2, 0.2);\n    const vec3 glow = vec3(0.4, 0.0, 0.0);\n    const float metalness = 0.0;\n    const float roughness = 1.0 / 8.0;\n    \n    float t1 = mod(iTime / 2.0, 2.0 * PI);\n    float t2 = mod(iTime / 8.0, 2.0 * PI);\n    \n    vec3 eye = vec3(4.0 * sin(t1), 3.0 + sin(t2), -4.0 * cos(t1));\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 view = view_matrix(eye, center, up);\n    vec3 ray = view * ray_vector(fov, iResolution, fragCoord);\n    \n    vec3 marched = ray_march(eye, ray, max_depth);\n    \n    // debug\n    // vec3 color = vec3(1.0 / sqrt(marched.z));\n    // fragColor = vec4(linear_to_srgb(tonemap(color, 1.0)), 1.0);\n        \n    // debug\n    // vec3 normal = ray_normal(eye, ray, marched);\n    // vec3 color = normal / 2.0 + 0.5;\n    // fragColor = vec4(linear_to_srgb(tonemap(color / 2.0, 1.0)), 1.0);\n    \n    if (marched.x < max_depth) {\n        vec3 color = render(eye, ray, marched, albedo, glow, metalness, roughness);\n        fragColor = vec4(linear_to_srgb(tonemap(color / 2.0, 1.0)), 1.0);\n    }\n    else {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}