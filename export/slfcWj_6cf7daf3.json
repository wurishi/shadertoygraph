{"ver":"0.1","info":{"id":"slfcWj","date":"1648698689","viewed":61,"name":"Simple illumination based on SDF","username":"Lumos320","description":"The camera position can be controlled with mouse","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n//sdf阈值\n#define Tmin 0.1\n#define Tmax 20.\n//最大迭代次数\n#define Traymarch 128\n//阈值精度\n#define Precision .001\n#define R 1.;\n//光照系数\n#define K 0.2\n//抗锯齿\n#define AA 3\n\nvec2 fixUV(in vec2 uv)\n{\n    return (2.*uv - iResolution.xy)/ min(iResolution.x,iResolution.y);\n}\n\nfloat sdfSphere(in vec3 p)\n{\n    return length(p) - R;\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd)\n{\n    //射线走的距离\n    float t = Tmin;\n    for(int i=0; i<Traymarch && t<Tmax; ++i){\n        //当前位置\n        vec3 pos = ro + t*rd;\n        float d = sdfSphere(pos);\n        if(d < Precision) break;\n        t += d;\n    }\n    return t;\n}\n\n//SDF的法向量\nvec3 calcNormal( in vec3  p ) \n{\n    const float h = 0.0001; // 步长\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdfSphere( p + k.xyy*h ) + \n                      k.yyx*sdfSphere( p + k.yyx*h ) + \n                      k.yxy*sdfSphere( p + k.yxy*h ) + \n                      k.xxx*sdfSphere( p + k.xxx*h ) );\n}\n\n//摄像机变换矩阵\nmat3 setCamera(vec3 target, vec3 cpos, float theta)\n{\n    vec3 z = normalize(target - cpos);\n    //theta是y轴绕z旋转的角度，cp能确定相机上方向\n    vec3 cp = vec3(sin(theta),cos(theta),0.);\n    vec3 x = normalize(cross(z,cp));\n    vec3 y = cross(x,z);\n\n    return mat3(x,y,z);\n}\n\n\nvec3 render(vec2 uv)\n{\n    vec3 color = vec3(0.);\n    //摄像机位置\n    //vec3 ro = vec3(0.,0.,-2.);\n    vec3 ro = vec3(2.*cos(iTime), 1. , 2.*sin(iTime));\n    \n    //鼠标控制时\n    if(iMouse.z > 0.1){\n        //鼠标(0,1) 旋转角度(0,2pi)\n        float theta = iMouse.x/iResolution.x * 2. * PI;\n        ro = vec3(2. * cos(theta), 1., 2. * sin(theta));\n    }\n    \n    vec3 target = vec3(0.);\n    //摄像机变换矩阵\n    mat3 camera = setCamera(target, ro, 0.);\n    //方向要归一化\n    //ro是view坐标系原点，不用减\n    vec3 rd = normalize(camera * vec3(uv,1.));\n    float t = rayMarching(ro,rd);\n    \n    if(t < Tmax){\n        vec3 pos = ro + t*rd;\n        vec3 normal = calcNormal(pos);\n        //设置一个光源\n        vec3 light = vec3(1.,5.,4.);\n        //漫反射\n        float diffuse = dot(normalize(light-pos), normal);\n        diffuse = clamp(diffuse,0.,1.);\n        //环境光\n        vec3 ambi = K * vec3(0.49);\n        color = ambi  + diffuse * vec3(1.);\n    }\n    //伽马校正<1\n    return sqrt(color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec2 uv = fixUV(fragCoord);\n    vec3 color = vec3(0.);\n    //抗锯齿\n    for(int i=0; i<AA; ++i){\n        for(int j=0; j<AA; ++j){\n            //偏移量在(0,1)\n            vec2 offset = 2. * (vec2(float(i),float(j))/float(AA) - 0.5);\n            vec2 uv = fixUV(fragCoord+offset);\n            color += render(uv);\n        }\n    }\n    //color归一化\n    fragColor = vec4(color/float(AA*AA),1.);\n}","name":"Image","description":"","type":"image"}]}