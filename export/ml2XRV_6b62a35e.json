{"ver":"0.1","info":{"id":"ml2XRV","date":"1676345421","viewed":66,"name":"Noise experiment 1","username":"ianertson","description":"Just experimenting with some noise functions","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","raymarch","raytrace","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a, b) (abs(dot(a, b)))\n\n#define NEAR 0.003\n#define FAR 69.0\n#define STEPS 69\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_THING 2\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float dist;\n    float depth;\n    int id;\n    int skip;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 1.0, 0, 0)\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n};\n\n\n#define SAMPLE(var, id_) if (id_ != data.skip && var < dist) { data.id = id_; dist = var; }\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 getThingPos() {\n    return vec3(cos(T), 0.16+(0.5+(0.5*cos(T))), sin(T));\n}\n\nfloat thingSDF(inout Data data, vec3 p) {\n    float r = 1.0;\n    \n    vec3 thingPos = getThingPos();\n    p -= thingPos;\n    \n    p.yz *= rot(T);\n    p.xz *= rot(T*0.5);\n    vec3 k = texNoise(iChannel3, p, 0.52, 0.7291, vec2(0.0));\n\n    float n = k.x*2.0-1.0;//noise31(p, 391.298, 0.4) * 2.0-1.0;\n    n *= 0.9;\n \n    p += n;\n    r -= (k.y*2.0-1.0)*0.9;\n    n = abs(n);\n    float m = n;//max(n.x, max(n.y, n.z));\n    \n    float d = sphereSDF(p, r);\n    \n    return d / (1.0+(m*0.5));\n}\n\nfloat groundSDF(vec3 p) {\n    return p.y+1.;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    \n    float thing = thingSDF(data, p);\n    float ground = groundSDF(p);\n    \n    SAMPLE(thing, ID_THING);\n    SAMPLE(ground, ID_GROUND);\n    \n    return dist;\n}\n\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\n\nvec2 getUv(inout Data data, vec3 p) {\n    vec3 n = data.n;\n    vec2 uv = vec2(0.0);\n    \n    if (data.id == ID_THING) {\n        p -= getThingPos();\n        p.yz *= rot(T);\n        n.yz *= rot(T);\n        p.xz *= rot(T*0.5);\n        n.xz *= rot(T*0.5);\n    }\n    \n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    \n    return uv;\n    \n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n        \n    }\n    \n    dist = abs(dist);\n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.dist = dist;\n    data.depth = dist / FAR;\n    data.n = getNormal(data, p);\n    data.uv = getUv(data, p);\n    \n    return true;\n}\n\nfloat getShadow(int skip, vec3 ro, vec3 rd, float near, float far) {\n    float dist = 0.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= far) break;\n    }\n    dist = abs(dist);\n    if (dist >= far) return 1.0;\n    return max(0.0, dist/max(0.0001, near))/1.6;\n}\n\n\nvec3 getAlbedoThing(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec2 uv = data.uv;\n\n    col += texNoise(iChannel3, vec3(uv.xy, 1.), 8.0, 3.2915, vec2(0.));//noise23(uv*8., 0.5, 0.5);\n\n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.uv;\n    \n    float n = texNoise(iChannel3, vec3(uv, 1.0), 16.0, 11.2231, vec2(0.)).r;//noise21(uv, 2.2931, 0.5);\n    \n    return vec3(n);\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_THING: return getAlbedoThing(data); break;\n        case ID_GROUND: return getAlbedoGround(data); break;\n    }\n    \n    return vec3(0.48);\n}\n\nvec3 forEachLight(inout Data data, vec3 ro, vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    \n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    \n    vec3 n = data.n;\n    vec3 L = normalize(light.p);\n    float NdotL = max(0.01, dot(n, L));\n    vec3 att = light.c * light.s * NdotL;\n    \n    vec3 ref = reflect(L, n);\n    float VdotR = max(0.0, dot(rd, ref));\n    \n    float spec = pow(VdotR, 32.0);\n    \n    float shadow = 1.0;\n    \n    if (NdotL > 0.00002) {\n        shadow = getShadow(data.id, data.p, L, data.dist, FAR);\n    }\n    \n    return (diffuse+spec) * att * shadow;\n}\n\n\nvec3 render(inout Data data, vec2 uv, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 2, 3), vec3(0.97, 0.79, 0.71), 2.0);\n    \n    if (march(data, ro, rd)) {\n        col += forEachLight(data, ro, rd, light);\n    } else {\n        col += texture(iChannel2, rd).rgb;\n    }\n    \n    float depth = data.dist / FAR;\n    float hitDist = data.dist;\n    \n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    col += ((depth*depth) * smoothstep(0.3, 0.0, dotup))/M_PI;\n    \n    vec3 L = normalize(light.p);\n    \n    float dotL = max(0.0, dot(rd, L));\n    float k = max(0.0, 1.0 - smoothstep(5., 7.2, hitDist));\n   \n    \n    //return vec3(k);\n    \n    col += (light.c * light.s * pow(dotL, 8.)) * max(0.0, 1.0-k);\n \n    return col;\n}\n\nvoid getRay(vec2 uv, vec2 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0.0, -6.);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n    } else {\n        rd.xz *= rot(T*0.6);\n        ro.xz *= rot(T*0.6);\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n\n\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n\n    Data data = NEW_DATA;\n    col += render(data, uv, ro, rd);\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n\n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/*\n#define NOISE_ADV(func) n += amp*func(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n#define NOISE_LAYER(func)\\\n{\\\n    float div = 0.0;\\\n    float amp = 1.0;\\\n    NOISE_ADV(func);\\\n    NOISE_ADV(func);\\\n    NOISE_ADV(func);\\\n    NOISE_ADV(func);\\\n    n = n / div;\\\n}\n\n#define RAND0 11.29156\n#define RAND1 33.93811\n#define RAND3 47.11339\n\nfloat hash11(float x, float seed) {\n     uint y = floatBitsToUint(x);\n     uint w = floatBitsToUint(seed) << 167U;\n     y ^= (w << (~y >> 503U)) >> 3u;\n     w ^= (~y << 3u);\n     y ^= (y << 17U);\n     y ^= (y >> 9U);\n     y ^= (y << 5U);\n     y ^= (w >> 3u);\n     y *= 897539U;\n     return float(y) / float(0xFFFFFFFFU);\n}\n\nfloat hash21(vec2 p, float seed) {\n    uvec2 k = uvec2(floatBitsToUint(hash11(p.x, seed)), floatBitsToUint(hash11(p.y, seed)));\n    uvec2 w = (~k >> 3U);\n    uint x = k.y ^ (k.x >> 3u) << (k.x ^ (k.x << w.x) >> 3u) << 503u;\n    uint y = k.x ^ (k.y >> 3u) << (k.y ^ (k.y << w.y) >> 3u) << 509u;    \n    uint n = (x ^ (x << w.x) >> ~k.y) +\n             (y ^ (y << w.y) >> ~k.x);\n    return hash11(float(631285U*n) / float(0xFFFFFFFFU), seed);\n}\n\nvec3 hash23(vec2 p, float seed) {\n    float x = hash21(p, seed);\n    float y = hash21(p, seed+RAND0);\n    float z = hash21(p, seed+RAND1);\n    return vec3(x, y, z);\n}\n\nfloat hash31(vec3 p, float seed) {\n    uvec3 k = uvec3(floatBitsToUint(hash11(p.x, seed)), floatBitsToUint(hash11(p.y, seed)), floatBitsToUint(hash11(p.z, seed)));\n    uvec3 w = (~k >> 3U);\n    uint x = k.y ^ (k.x >> 3u) << (k.x ^ (k.x << w.x) >> 3u) << 503u;\n    uint y = k.x ^ (k.y >> 3u) << (k.y ^ (k.y << w.y) >> 3u) << 509u;\n    uint z = k.z ^ (k.z >> 3u) << (k.z ^ (k.z << w.z) >> 3u) << 521u;\n    uint n = (x ^ (x << w.x) >> ~k.z) +\n             (y ^ (y << w.y) >> ~k.z) +\n             (z ^ (z << w.z) >> ~k.y);\n    return hash11(float(631285U*n) / float(0xFFFFFFFFU), seed);\n}\n\nvec3 hash33(vec3 p, float seed) {\n    float x = hash31(p, seed);\n    float y = hash31(p, seed+RAND0);\n    float z = hash31(p, seed+RAND1);\n    return vec3(x, y, z);\n}\n\nfloat noise21(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),lv.y);\n}\n\nfloat noise21(vec2 p, float seed, float freq) {\n    float n = 0.0;\n    NOISE_LAYER(noise21);\n    return n;\n}\n\nvec3 noise23(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(hash23(id, seed), hash23(id+vec2(1, 0), seed), lv.x),\n        mix(hash23(id+vec2(0, 1), seed), hash23(id+vec2(1, 1), seed), lv.x),lv.y);\n}\n\nvec3 noise23(vec2 p, float seed, float freq) {\n    vec3 n = vec3(0.0);\n    NOISE_LAYER(noise23);\n    return n;\n}\n\nfloat noise31(vec3 p, float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(mix(hash31(id, seed), hash31(id+vec3(1, 0, 0), seed), lv.x),\n        mix(hash31(id+vec3(0, 1, 0), seed), hash31(id+vec3(1, 1, 0), seed), lv.x),lv.y), mix(mix(hash31(id + vec3(0, 0, 1), seed), hash31(id+vec3(1, 0, 1), seed), lv.x),\n        mix(hash31(id+vec3(0, 1, 1), seed), hash31(id+vec3(1, 1, 1), seed), lv.x),lv.y), lv.z);\n}\n\nfloat noise31(vec3 p, float seed, float freq) {\n    float n = 0.0;\n    NOISE_LAYER(noise31);\n    return n;\n}\n\nvec3 noise33(vec3 p, float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(mix(hash33(id, seed), hash33(id+vec3(1, 0, 0), seed), lv.x),\n        mix(hash33(id+vec3(0, 1, 0), seed), hash33(id+vec3(1, 1, 0), seed), lv.x),lv.y), mix(mix(hash33(id + vec3(0, 0, 1), seed), hash33(id+vec3(1, 0, 1), seed), lv.x),\n        mix(hash33(id+vec3(0, 1, 1), seed), hash33(id+vec3(1, 1, 1), seed), lv.x),lv.y), lv.z);\n}\n\n\nvec3 noise33(vec3 p, float seed, float freq) {\n    vec3 n = vec3(0.0);\n    NOISE_LAYER(noise33);\n    return n;\n}*/\n\nvec3 texHash33(sampler2D ch, vec3 p, float div, float seed, vec2 lod) {\n    return textureLod(ch, (vec2(p.x, p.y) +\n        div*(textureLod(ch, (vec2((p.y*p.z), p.z)+seed)/div, lod.x).xy*2.0-1.0))/div, lod.y).xyz;\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float seed, vec2 lod) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    float div = vec2(textureSize(tex, 0).xy).y;\n\n    return mix(\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 0), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 0), div, seed, lod), lv.x),\n          lv.y),\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 1), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 1), div, seed, lod), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float freq, float seed, vec2 lod) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }","name":"Common","description":"","type":"common"}]}