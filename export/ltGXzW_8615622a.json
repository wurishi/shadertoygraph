{"ver":"0.1","info":{"id":"ltGXzW","date":"1483206261","viewed":226,"name":"Path marcher","username":"public_int_i","description":"Path marcher","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["marcher","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n\tfragColor = pow(c/c.w, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n//Buf A - Rendering\n\n\n\n/*TODO:\n-Add movement, 3/4th the buffer isn't used plenty of room for storing camera\n-Fix depth of field\n*/\n\n\n\nconst float PI = 3.141592,\n            PI2 = PI*2.;\n\nstruct material {\n    vec3 diffuse, specular;\n    float metallic, roughness, emission;\n};\n    \nvec3 hash33(vec3 p);\nfloat hash13(vec3 s);\n\n\n#define motionBlur(p,v) (p+v*(hash13(p+fract(vec3(iFrame)/vec3(1.092384,25.28394,1564.82934)))-0.5))\n#define transparency(d,o) mix(d,1e7,clamp((hash13(p+fract(vec3(iFrame)/vec3(1.092384,25.28394,1564.82934)))-o)*1e7,0.,1.))\n\n\n\n//SCENE FUNCTIONS & VARIABLES\n\n\nconst vec3 CAMERA_POSITION = vec3(0., 5., -20.);\nconst vec2 CAMERA_ROTATION = vec2(PI/2.5, PI/2.);\n    \n    \nconst vec3 DEPTH_OF_FIELD_FOCALPOINT = vec3(-1.,4.,-16.);\nconst float DEPTH_OF_FIELD_POW = 1.0/2.,\n    \t\tDEPTH_OF_FIELD_SPIKES = 4.;\n//#define DEPTH_OF_FIELD .2\n\n\n\n//returns distance, material id\nvec2 scene(vec3 p) {\n    //floor\n    vec2 sr = vec2(p.y,0.);\n    \n    \n    //spheres\n    vec3 lp = p;\n    lp.y -= 2.;\n    float sx = length(vec3(mod(abs(lp.xz),6.)-3.,lp.y).xzy)-2.;\n    lp.y -= 17.;\n    sx = min(sx,\n            length(vec3(mod(abs(lp.xz),24.)-12.,lp.y).xzy)-12.);\n    \n    if (sx < sr.x) {\n        sr = vec2(sx, 1.);\n    }\n    \n    //mist/fog\n    float md = transparency(1e-1,1e-2);\n    if (md < sr.x) {\n        sr = vec2(md, 2.);\n    }\n    \n    return sr;\n}\n\n//outputs material(m) from material id, position(p) and normal(n)\nvoid getMaterial(float id, vec3 p, vec3 n, out material m) {\n    \n    //floor material\n    if (id < 1.) {\n        m = material(vec3(.9),//diffuse\n                     vec3(.9),//specular\n                     0.,//metallic\n                     1.,//roughness\n                     0.//emission\n                    );\n        return;\n    }\n    \n    //mist material\n    if (id > 1.) {\n        m = material(vec3(1.),//diffuse\n                     vec3(1.),//specular\n                     1.,//metallic\n                     .5,//roughness\n                     0.//emission\n                    );\n        return;\n    }\n    \n    //sphere material\n    float yflag = clamp((p.y-6.)*1e6,0.,1.);\n    vec2 spid = abs(p.xz)/mix(6.,24.,yflag);\n    spid = floor(spid)-9283.8273*(-sign(p.xz)*.5+.5);\n    vec3 rnd = hash33(-924.77129+yflag*239.9384+(spid.xyy*355.91823+spid.yxx*92.98234));\n        \n    m = material(vec3(sin(rnd.x*19.234),cos(rnd.x*8.98234+.32834),-sin(rnd.x*88.98772+9.9713))*.5+.5,//diffuse\n                 vec3(sin(rnd.y*99.94),cos(rnd.y*29.98234+92.32834),-sin(rnd.y*2.2772))*.5+.5,//specular\n                 cos(rnd.z*27.92874)*.5+.5,//metallic\n                 sin(rnd.z*18.283)*.5+.5,//roughness\n                 clamp((sin(rnd.y*28.9884)-.995)*1e6,0.,1.)//emission\n                );\n}\n\n//returns background color from ray direction(d)\nvec3 background(vec3 d) {\n    return vec3(0.);\n}\n\n\n\n\n\n//RENDERING VARIABLES\nconst int ITERATIONS = 64;\n\nconst float MIN_EPSILON = 2e-2,\n    \t\tMAX_EPSILON = 1e1,\n    \t\tEPSILON_FADE_DISTANCE = 1e3,\n    \n    \t\tMIN_STEP = 0.7,\n    \t\tMAX_STEP = 1.0;\n\n\n\n//2d rotation\nvec2 rot2(vec2 p, float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\n//generate seed from current iDate.w\nfloat timeSeed() {\n    float tseed = floor(iDate.w);\n    return fract(tseed*.73624+fract(iDate.w-tseed*.0928275)*1974.3252+float(iFrame)*.98726);\n}\n\n//random float3 with values from 0-1 seeded from float3\nvec3 hash33(vec3 p) {\n\treturn fract(abs(cos(p*.19487)*9284.3459 + cos(p.zxy*29.97612)*37.92384));\n}\n\n//random float from 0-1 seeded from float3\nfloat hash13(vec3 s) {\n\treturn fract(abs(cos(dot(s, vec3(7, 157, 113))))*43758.5453);\n}\n\n\n//calculate up(binorm) and right(tang) normals\nvoid calculateUpRight(vec3 normal, out vec3 tangent, out vec3 binormal)\n{\n    if (abs(normal.x) > abs(normal.y)) {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    } else {\n\t\ttangent = normalize(vec3(0., normal.z, -normal.y));\n\t}\n    \n\tbinormal = cross(normal, tangent);\n}\n//polar->cartesian\nvec3 polarToCartesian(float sinTheta, float cosTheta, \n\t\t\t\t      float sinPhi, float cosPhi) {\n\treturn vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\n\n//BRDF functions are from\n//mplanck https://www.shadertoy.com/view/lsV3zV\n//reindeer https://www.shadertoy.com/view/4tl3z4\n\n//brdf simulating microscopic surface roughness(bumps)\nvec3 brdf(vec3 rnd, vec3 norm, float rough, vec3 view, vec3 tangent, vec3 binormal) {\t\t\t\t\n\tfloat cosTheta = pow(max(0., rnd.x), rough*(1.-1e-3)+1e-3),\n          sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta)),\n          phi = rnd.y * PI2;\n    \n\tvec3 ldir = polarToCartesian(sinTheta, cosTheta, sin(phi), cos(phi)),\n         dir = normalize(ldir.x*tangent + ldir.y*binormal + ldir.z*norm);\n\t\t\t\t\n    return reflect(view, dir*(step(0.,dot(dir,-view))*2.-1.));\n}\n//simple cos-weighted brdf\nvec3 brdf2(vec2 r, vec3 n) {\n    vec3 uu = normalize(cross( n, vec3(0.0,1.0,1.0)));\n\tvec3 vv = cross(uu, n);\n    \n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(r.x*PI2),\n          ry = ra*sin(r.x*PI2);\n\tfloat rz = sqrt(1.0 - r.y);\n\n\treturn normalize(rx*uu + ry*vv + rz*n);\n}\n\n\nvec3 normal(vec3 p) {\n    const vec2 NE = vec2(MIN_EPSILON, 0.);\n    return normalize(vec3(scene(p+NE.xyy).x-scene(p-NE.xyy).x,\n                          scene(p+NE.yxy).x-scene(p-NE.yxy).x,\n                          scene(p+NE.yyx).x-scene(p-NE.yyx).x));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 120) {\n        //init, 2 seconds to go fullscreen\n        return;\n    }\n    \n    vec2 R = iResolution.xy/2.;\n    vec2 uv = fragCoord.xy / R;\n    \n    \n    //cut off 3/4th the screen because we only need 1/4th for super-sampling\n    if (uv.x >= 1. || uv.y >= 1.) return;\n    \n    \n    //pixel jitter for temporal super-sampling\n    float tseed = timeSeed();\n    vec3 tseed3 = hash33(cos(vec3(iFrame)*.098232+vec3(tseed)/vec3(42.7723,2.9914,26.9783)));\n    vec2 jitter = hash33(cos(vec3(iFrame)*.098232+vec3(tseed)/vec3(.92873,.092834,2.19823))).xy-0.5;\n    vec2 nuv = ((fragCoord+jitter)*2.-R)/R.x;\n    \n    \n    \n    //raymarch path\n    vec3 rp = CAMERA_POSITION,\n         rd = normalize(vec3(nuv,1.));\n    rd.yz = rot2(rd.yz, CAMERA_ROTATION.y);\n    rd.xz = rot2(rd.xz, CAMERA_ROTATION.x);\n    \n    #ifdef DEPTH_OF_FIELD\n    vec3 cup, cright,\n         fdir = normalize(DEPTH_OF_FIELD_FOCALPOINT-rp);\n    calculateUpRight(rd, cright, cup);\n    \n    vec2 crnd = hash33(rd+tseed3*2.19827).xy-0.5;\n    float ang = atan(crnd.y,crnd.x);\n    \n    float dofAmount = DEPTH_OF_FIELD*(1.-pow(dot(rd,fdir),DEPTH_OF_FIELD_POW))*\n        \t\t\t\t\t\t\tsin(ang*DEPTH_OF_FIELD_SPIKES);\n    rd = normalize(rd+(cup*crnd.x+cright*crnd.y)*dofAmount);\n    #endif\n    \n    \n    float s = 0.;\n    \n    vec3 l = vec3(1.),\n         o = vec3(0.);\n    for (int i = 0; i < ITERATIONS; i++) {\n        vec3 p = rp+rd*s;\n        vec2 sr = scene(p);\n        \n        if (sr.x < MIN_EPSILON+(MAX_EPSILON-MIN_EPSILON)*min(1.,s/EPSILON_FADE_DISTANCE)) {\n            vec3 norm = normal(p),\n                 rnd = hash33(p+tseed3),\n                tang,binorm;\n            \n            material mat;\n            getMaterial(sr.y, p, norm, mat);\n            \n            l *= mix(mat.diffuse,mat.specular,0.5+0.5*mat.metallic);\n            o += l*mat.emission;\n            \n            calculateUpRight(norm, tang, binorm);\n            \n            rd = brdf(rnd, norm, mix(mat.roughness,1.,step(0.5+0.5*mat.metallic,hash13(p-tseed3))), rd, tang, binorm);\n            rp = p+norm*(MIN_EPSILON+(MAX_EPSILON-MIN_EPSILON)*min(1.,s/EPSILON_FADE_DISTANCE));\n            s = 0.;\n        }\n        \n        s += sr.x*(MIN_STEP+hash13(p+tseed3)*(MAX_STEP-MIN_STEP));\n    }\n    \n    o += l*background(rd)*step(MAX_EPSILON/10., scene(rp+rd*s).x);\n    fragColor = vec4(o,1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n//Buf B - Super-sampling convolution.\n\n\n\n//generate seed from current iDate.w\nfloat timeSeed() {\n    float tseed = floor(iDate.w);\n    return fract(tseed*.73624+fract(iDate.w-tseed*.0928275)*1974.3252+float(iFrame)*.98726);\n}\n\n\n//random float3 with values from 0-1 seeded from float3\nvec3 hash33(vec3 p) {\n\treturn fract(abs(cos(p*.19487)*9284.3459 + cos(p.zxy*29.97612)*37.92384));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 120) {\n        //init blank, 2 seconds to go fullscreen\n        fragColor = vec4(0.);\n        return;\n    }\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    //pixel jitter\n    float tseed = timeSeed();\n    vec2 jitter = hash33(cos(vec3(iFrame)*.098232+vec3(tseed)/vec3(.92873,.092834,2.19823))).xy-0.5;\n\n    vec4 r = texture(iChannel1, uv);\n    vec2 muv = fragCoord-0.5;\n    \n    vec4 s = vec4(0.);\n    for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            vec2 suv = floor(fragCoord/2.)+vec2(x,y);\n            vec3 c = texture(iChannel0, (suv+0.5)/iResolution.xy).xyz;\n            float portion = max(0., 1.-(length(suv*2.+jitter-muv)/1.41));\n            s += vec4(c,1.)*portion;\n        }\n    }\n    if (s.w > 0.) s /= s.w;\n    \n    fragColor = r+s/512.;\n}","name":"Buf B","description":"","type":"buffer"}]}