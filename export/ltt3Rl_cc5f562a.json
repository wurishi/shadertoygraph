{"ver":"0.1","info":{"id":"ltt3Rl","date":"1470986863","viewed":660,"name":"HUD + iq's CloudyTerrain","username":"calx","description":"I whacked iq's cloudy terrain from here: https://www.shadertoy.com/view/MdlGW7 behind my HUD from here: https://www.shadertoy.com/view/4dtSRl","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["distancefields","ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define QUARTER_PI 0.78539816339\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\nconst vec4 \tBLUE\t\t\t= vec4(0.306, 0.502, 0.537, 1.000);\nconst vec4 \tRED\t\t\t\t= vec4(0.941, 0.306, 0.208, 1.000);\nconst vec4 \tGREY_BLUE\t\t= vec4(0.494, 0.620, 0.663, 1.000);\nconst vec4 \tYELLOW\t\t\t= vec4(0.969, 1.000, 0.804, 1.000);\nconst vec4 \tGREEN\t\t\t= vec4(0.804, 1.000, 0.965, 1.000);\nconst vec4 \tGREY\t\t\t= vec4(0.449, 0.481, 0.489, 1.000);\nconst vec4 \tD_GREY\t\t\t= vec4(0.050, 0.050, 0.050, 1.000);\nconst vec4 \tM_GREY\t\t\t= vec4(0.200, 0.200, 0.200, 1.000);\nconst vec4 \tWHITE \t\t\t= vec4(1.000, 1.000, 1.000, 1.000);\nconst vec4 \tT_WHITE \t\t= vec4(1.000, 1.000, 1.000, 0.500);\nconst vec4 \tBLACK\t\t\t= vec4(0.000, 0.000, 0.000, 0.000);\nconst vec2 \tORIGIN \t\t\t= vec2(0.0);\nconst float LINE_WEIGHT \t= 0.0035;\nconst float METER_WEIGHT \t= 0.0100;\n\t  float SMOOTH\t\t\t= 0.0;\n\t  float R_SMOOTH\t\t= 0.2000;\n\nfloat map(float value, float istart, float istop, float ostart, float ostop) \n{\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n\n\n\nfloat n_angleBetween(vec2 v1, vec2 v2)\n{\n    float angle = atan(v1.y-v2.y, v1.x-v2.x);\n    return ((angle < 0.0) ? (angle += TWO_PI) : angle) / TWO_PI;\n}\n\nvec2 rotate(vec2 v, float rotation)\n{\n\treturn vec2(cos(rotation)*v.x + sin(rotation)*v.y, -sin(rotation)*v.x + cos(rotation)*v.y);\n}\n\nfloat radialLine(vec2 r, float radius, float cutoff, float weight, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 180.0;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring * line;;\n}\n\nfloat radialMeter(vec2 r, float radius, float cutoff, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;  \n\tfloat or = \tir + METER_WEIGHT;   \n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 200.0;\n    float grads = fract(s);    \n\tfloat steps = (1.0-smoothstep((0.4-R_SMOOTH), (0.41+R_SMOOTH), grads)) * smoothstep((0.2-R_SMOOTH),(0.21+R_SMOOTH), grads) ;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n\n    steps *= ring * line;\n        \n\treturn steps;\n}\n\nfloat dottedSect(vec2 r, float radius, float cutoff, float dotSize, bool flip, float num)\n{ \n    float a = num;\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n    float theta =  round(n_angleBetween(uv, vec2(0.0)) * (TWO_PI * a)) / a;\n    float x = radius * cos(theta);\n    float y = radius * sin(theta);\n    vec2  v = vec2(x, y);   \n \tfloat d = distance(uv, v);\n    float e = smoothstep(d-SMOOTH, d+SMOOTH, dotSize);\n    float line =  step(theta, cutoff);\n\n    return e*line;\n}\n\nfloat returnBracket(vec2 r, float radius, float cutoff, float weight, float vCut, bool flip)\n{\n    vec2 uv =  rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float line =   step(theta, cutoff/TWO_PI);\n    float halfs =  (cutoff/TWO_PI) / 2.0;\n    float sec = step(halfs-(vCut/TWO_PI), theta) * (1.0-step(halfs+((vCut/TWO_PI)), theta));\n\tfloat ring = smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n  \n\treturn ring * (line - sec);\t\n}\n\nfloat solBracket(vec2 r, float radius, float weight, float cutoff, float cut, float retrn)\n{\n    vec2 uv =  r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n  \tfloat ring =  smoothstep(ir-SMOOTH, ir+SMOOTH, d) * (1.0 - smoothstep(or-SMOOTH, or+SMOOTH, d));\n    float circ = step(radius+weight, d);\n\tfloat block = \tsmoothstep(uv.y-SMOOTH, uv.y+SMOOTH, cutoff) * (1.0 - smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -cutoff));\n    float topLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH,  cutoff-weight);\n    float botLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -(cutoff-(weight)));\n    \n\tfloat xblock = step(-retrn, uv.x) * (1.0-step(retrn, uv.x));\n    float yblock = step(-cut, uv.y) * (1.0-step(cut, uv.y));\n    \n    ring *= block;\n    topLine *= (1.0 - botLine);\n    block *= (1.0 - topLine);\n    ring += block;\n    ring *= 1.0-circ;\n    float blocks = (xblock+yblock);\n    \n\treturn ring * (1.0-(blocks));\t\n}\n\nfloat single(vec2 r, float radius, float weight)\n{\n    vec2  uv = r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring;\n}\n\nfloat splitLine(vec2 r, float w, float yOffset, float split, float weight) \n{\n    vec2 uv = r + vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float g = step(uv.x, split) * (1.0-step(split, -uv.x));\n    \n    return f * l * (1.0-g);\n}\n\nfloat meter(vec2 r, float w, float yOffset, float inc, float weight, float num) \n{\n    vec2 uv = r - vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float incr = fract(uv.x*num);\n    float gnn = (1.0-smoothstep((0.4-SMOOTH), (0.41+SMOOTH), incr)) * smoothstep((0.2-SMOOTH),(0.21+SMOOTH), incr);\n    f *= (gnn * l);   \n    \n    return f ;\n}\n\nfloat grid(vec2 r, float num, float weight)\n{\n    vec2 uv = r * num;\n    float gridx = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.x));\n    float gridy = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.y));\n    \n    return (1.0 - (gridx * gridy));\n}\n\nfloat dots(vec2 r, float num, float pointSize)\n{\n    vec2 uv = r * num;\n    vec2  v = vec2(round(uv.x),round(uv.y));   \n \tfloat d = distance(uv, v);\n    return smoothstep(d-SMOOTH, d+SMOOTH, pointSize);   \n}\n\nfloat bg(vec2 r, float w, float h)\n{\n    float f = 1.0 - step(w, distance(r, ORIGIN));\n    \n    float g = step(-h, r.y) * (1.0-step(h, r.y));\n    \n    f *= g;\n    \n\treturn 1.0-f;\n}\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec2 hashPosition(float x)\n{\n    return vec2(hash(x) * 64.0, hash(x * 1.1) * 64.0);\n}\n\nfloat sineOut(float t) \n{\n  return sin(t * HALF_PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SMOOTH \t\t= map(iResolution.x, 800.0, 2560.0, 0.0025, 0.0010);\n\tvec2 uv =  2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float rotation = - PI / 4.0;\n    rotation = 0.0;\n    uv = vec2(cos(rotation)*uv.x + sin(rotation)*uv.y, -sin(rotation)*uv.x + cos(rotation)*uv.y);\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n\t\n\tconst float sequenceDuration = 1.25;\n\tfloat currentSequence = floor(iTime / sequenceDuration);\n\tfloat currentSequenceTime = mod(iTime, sequenceDuration);\n\tvec2  startingPosition = hashPosition(currentSequence) * 0.005;\n\tvec2  goalPosition = hashPosition(currentSequence + 1.0) * 0.005;\n\tvec2  currentPosition;\n\tconst float speed = 0.5;\n\tfloat potentialDistance = speed * currentSequenceTime;\n\tfloat goalDistance = length(goalPosition - startingPosition);\n    \n\tif (potentialDistance < goalDistance) {\n\t\tcurrentPosition = mix(startingPosition, goalPosition, sineOut(potentialDistance / goalDistance));\n\t} else {\n\t\tcurrentPosition = goalPosition;\n\t}\n\t\n    vec2 targetPosition = uv-currentPosition;\n    \n    vec4 tex = texture(iChannel0, q) * 0.5; //Sampling iq's https://www.shadertoy.com/view/MdlGW7\n    \n    vec4 final  = mix(tex, \tBLACK, \tbg(uv, 1.4805, 0.450) * 0.20);      \n    \t final  = mix(tex, \tBLACK, \tbg(uv, 1.3015, 0.670) * 0.35); \n    \n    final = mix(final, \tWHITE\t, dots(uv, 20.0, 0.04)  * 0.075);    \n    final = mix(final, \tWHITE\t, grid (uv, 10.0, 0.03) * 0.025);\n    \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, true)); \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, true));\n    final = mix(final,  BLUE    , splitLine  (targetPosition, 0.3000, 0.3300, 0.0160, 0.005));\n    final = mix(final,  WHITE   , splitLine  (targetPosition, 0.6231, 0.0000, 0.5324, LINE_WEIGHT));\n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, false, 12.40)); \n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, true, 12.40));  \n    final = mix(final,  GREY    , solBracket (targetPosition, 0.3490, LINE_WEIGHT, 0.3, 0.265, 0.000));\n   \tfinal = mix(final,  WHITE   , solBracket (targetPosition, 0.3777, LINE_WEIGHT, 0.05, 0.018, 0.3675));\n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, false));   \n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, true)); \n    final = mix(final,  GREY    , single     (targetPosition, 0.4527, LINE_WEIGHT));\n   \tfinal = mix(final, \tGREY_BLUE, splitLine  (targetPosition, 0.6231, 0.0, 0.5324, LINE_WEIGHT));    \n    final = mix(final, \tBLUE\t, solBracket (targetPosition, 0.5750, LINE_WEIGHT, 1.0, 0.2314, 0.0000));\n \tfinal = mix(final, \tWHITE\t, solBracket (uv, 1.4805, LINE_WEIGHT, 0.7000, 0.0592, 1.2900));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.6685, 0.1592, 0.0000));\n    final = mix(final, \tGREY\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.7000, 0.6950, 0.0000));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5174, 0.0000, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5374, 0.5300, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.6390, 0.6300, 0.8551));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, false, 112.40));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, true, 112.40));\n    final = mix(final, \tGREY\t, meter\t\t (uv, 0.8500, 0.6390, 0.9324, 0.010, 50.0));\n    \n\n    fragColor = final;\n} ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float a = textureLod( iChannel0, x.xy/256.0 + (p.z+0.0)*120.7123, 0.0 ).x;\n    float b = textureLod( iChannel0, x.xy/256.0 + (p.z+1.0)*120.7123, 0.0 ).x;\n\treturn mix( a, b, f.z );\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat envelope( vec3 p )\n{\n\tfloat isLake = 1.0-smoothstep( 0.62, 0.72, textureLod( iChannel0, 0.001*p.zx,0.0).x );\n\treturn 0.1 + isLake*0.9*textureLod( iChannel1, 0.01*p.xz, 0.0 ).x;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - envelope(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 50.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    h = mapTerrain( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 lig = normalize( vec3(0.7,0.4,0.2) );\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           0.5*2.0*eps.x,\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec4 mapTrees( in vec3 pos, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\t\n\tfloat den = 1.0;\n\n\tfloat kklake = textureLod( iChannel0, 0.001*pos.zx,0.0).x;\n\tfloat isLake = smoothstep( 0.7, 0.71, kklake );\n\t\n\tif( pos.y>1.0 || pos.y<0.0 ) \n\t{\n\t\tden = 0.0;\n\t}\n\telse\n\t{\n\t\t\n\t\tfloat h = pos.y;\n\t\tfloat e = envelope( pos );\n\t\tfloat r = clamp(h/e,0.0,1.0);\n\t\t\n        den = smoothstep( r, 1.0, textureLod(iChannel0, pos.xz*0.15, 0.0).x );\n        \n\t\tden *= 1.0-0.95*clamp( (r-0.75)/(1.0-0.75) ,0.0,1.0);\n\t\t\n        float id = textureLod( iChannel0, pos.xz,0.0).x;\n        float oc = pow( r, 2.0 );\n\n\t\tvec3  nor = calcNormal( pos );\n\t\tvec3  dif = vec3(1.0)*clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\t\n\t\tfloat w = (2.8-pos.y)/lig.y;\n\t\tfloat c = fbm( (pos+w*lig)*0.35 );\n\t\tc = smoothstep( 0.38, 0.6, c );\n\t\tdif *= pow( vec3(c), vec3(0.8, 1.0, 1.5 ) );\n\t\t\t\n\t\tvec3  brdf = 1.7*vec3(1.5,1.0,0.8)*dif*(0.1+0.9*oc) + 1.3*amb*vec3(0.1,0.15,0.2)*oc;\n\n\t\tvec3 mate = 0.6*vec3(0.5,0.5,0.1);\n\t\tmate += 0.3*textureLod( iChannel1, 0.1*pos.xz, 0.0 ).zyx;\n\t\t\n\t\tcol = brdf * mate;\n\n\t\tden *= 1.0-isLake;\n\t}\n\n\treturn vec4( col, den );\n}\n\n\nvec4 raymarchTrees( in vec3 ro, in vec3 rd, float tmax, vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n    float t = tmax;\n\tfor( int i=0; i<512; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tif( sum.a>0.99 || pos.y<0.0  || t>20.0 ) break;\n\t\t\n\t\tvec4 col = mapTrees( pos, rd );\n\n\t\tcol.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0018*t*t) );\n        \n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\t\t\n\t\tt += 0.0035*t;\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(2.8 - p.y);\n\td -= 1.6 * fbm( p*0.35 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\nfloat kk = 0.0;\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.0;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = (2.8-pos.y)/lig.y;\n\t\tfloat c = fbm( (pos + lig*h)*0.35 );\n\t\t//kk += 0.05*dt*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a);\n\t\tkk += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\t\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;//max(0.1,0.05*t);\n\t}\nkk = clamp( kk, 0.0, 1.0 );\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 32.0*cos(0.2+0.75*.1*time*1.5), 1.2, 32.0*sin(0.1+0.75*0.11*time*1.5) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\tfloat time = 23.5+iTime;\n\t\n    // camera\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+1.0 );\n\tta.y *= 0.2;\n\tfloat roll = 0.3*cos(0.07*time);\n\t// camera tx\n    mat3 cam = setCamera( ro, ta, roll );\n\n    // ray direction\n    vec3 rd = normalize( cam * vec3(p.xy,1.75) );\n\n    // sky\t \n\tvec3 col = vec3(0.84,0.95,1.0)*0.77 - rd.y*0.6;\n\tcol *= 0.75;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    col += vec3(1.0,0.7,0.3)*0.3*pow( sun, 6.0 );\n\tvec3 bcol = col;\n\n    // lakes\n    float gt = (0.0-ro.y)/rd.y;\n    if( gt>0.0 )\n    {\n        vec3 pos = ro + rd*gt;\n\n\t\tvec3 nor = vec3(0.0,1.0,0.0);\n\t    nor.xz  = 0.10*(-1.0 + 2.0*texture( iChannel3, 1.5*pos.xz ).xz);\n\t    nor.xz += 0.15*(-1.0 + 2.0*texture( iChannel3, 3.2*pos.xz ).xz);\n\t    nor.xz += 0.20*(-1.0 + 2.0*texture( iChannel3, 6.0*pos.xz ).xz);\n\t\tnor = normalize(nor);\n\n\t\tvec3 ref = reflect( rd, nor );\n\t    vec3 sref = reflect( rd, vec3(0.0,1.0,0.0) );\n\t\tfloat sunr = clamp( dot(ref,lig), 0.0, 1.0 );\n\n\t    float kklake = texture( iChannel0, 0.001*pos.zx,-100.0).x;\n\t\tcol = vec3(0.1,0.1,0.0);\n        vec3 lcol = vec3(0.2,0.5,0.7);\n\t\tcol = mix( lcol, 1.1*vec3(0.2,0.6,0.7), 1.0-smoothstep(0.7,0.81,kklake) );\n\t\t\n\t\tcol *= 0.12;\n\n\t    float fre = 1.0 - max(sref.y,0.0);\n\t\tcol += 0.8*vec3(1.0,0.9,0.8)*pow( sunr, 64.0 )*pow(fre,1.0);\n\t\tcol += 0.5*vec3(1.0,0.9,0.8)*pow( fre, 10.0 );\n\n\t\tfloat h = (2.8-pos.y)/lig.y;\n        float c = fbm( (pos+h*lig)*0.35 );\n\t\tcol *= 0.4 + 0.6*smoothstep( 0.38, 0.6, c );\n\n\t    col *= smoothstep(0.7,0.701,kklake);\n\n\t    col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*gt*gt) );\n    }\n\n\n    // terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n        // trees\t\t\n        vec4 res = raymarchTrees( ro, rd, t, bcol );\n\t    col = mix( col, res.xyz, res.w );\n\t}\n\n\t// sun glow\n    col += vec3(1.0,0.5,0.2)*0.35*pow( sun, 3.0 );\n\n    // clouds\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n\tcol += (1.0-0.8*col)*kk*kk*kk*0.4*vec3(1.0,0.8,0.7);\n\tcol = clamp( col, 0.0, 1.0 );\n\n\t\n    // gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    // contrast, desat, tint and vignetting\t\n\tcol = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= vec3(1.06,1.05,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Buf A","description":"","type":"buffer"}]}