{"ver":"0.1","info":{"id":"WlKSz1","date":"1582206736","viewed":198,"name":"Not In Mood","username":"Hei149","description":"learning ray marching","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","dof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GOLDEN_ANGLE = 2.3999;\nconst float MAX_BLUR_SIZE = 10.0;\nconst float RAD_SCALE = 0.5;\n\n/*\nDepth of field\n@copied from https://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n*/\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n    float coc = clamp(((1.0 / focusPoint) - (1.0 / depth)) * focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n{\n    vec4 centerPixel = texture(iChannel0, texCoord);\n    float centerDepth = centerPixel.w;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerPixel.rgb;\n    float total = 1.0;\n\n    float radius = RAD_SCALE;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    for(float ang = 0.0; radius <MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)\n    {\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * pixelSize * radius;\n        vec4 samplePixel = texture(iChannel0, tc);\n        float sampleDepth = samplePixel.w;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        if(sampleDepth > centerDepth)\n            sampleSize = clamp(sampleSize, 0.0, centerSize * 2.0);\n\n        float m = smoothstep(radius - 0.5, radius + 0.5, sampleSize);\n        color += mix(color/total, samplePixel.rgb, m);\n        total += 1.0;\n        radius += RAD_SCALE / radius;\n    }\n    return color/= total;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = depthOfField(uv, 3.4, 4.0);\n    col = pow(col, vec3(0.4545));\n    col *= 0.5 + 0.5*sqrt( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) );\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat2 rotate(float ang)\n{\n    float ca = cos(ang);\n    float sa = sin(ang);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p, vec2(8.24, 48.302))) * 1004.43);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 iv = floor(p);\n    vec2 uv = fract(p);\n    uv = uv * uv * (3.0 - 2.0 * uv);\n    return mix(\n        mix(rand(iv), rand(iv + vec2(1.0, 0.0)), uv.x),\n        mix(rand(iv + vec2(0.0, 1.0)), rand(iv + vec2(1.0)), uv.x),\n        uv.y\n    );\n}\n\nfloat fbm(vec2 p)\n{\n    float a = 1.0;\n    float f = 1.0;\n    float res = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        res += a * noise(p * f);\n        a *= 0.5;\n        f *= 2.0;\n    }\n    return res;\n}\n\n\nfloat sdCyl(vec3 p, float r, float h)\n{\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - h);\n}\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n    float d1 = length(p.xz) - r.x;\n    return length(vec2(d1, p.y)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 d)\n{\n    vec3 b = abs(p) - d;\n    return length(max(b, 0.0));\n}\n\nvec2 book(vec3 p)\n{\n    vec3 rp = p;\n    rp.xz += sin(rp.y * 100.0) * 0.002;\n    float d = sdBox(rp + vec3(1.5, 0.0, -1.3), vec3(0.5, 0.08, 0.7));\n    p.y = abs(p.y) - 0.1;\n    float d1 = sdBox(p + vec3(1.45, 0.0, -1.3), vec3(0.50, 0.0005, 0.75)) - 0.045;\n    if(d < d1){\n        return vec2(d, 1);\n    }else{\n        return vec2(d, 2);\n    }\n}\n\nvec2 pencil(vec3 p)\n{\n    float f = smoothstep(0.97, 1.1, p.y + 0.18);\n    float scale = mix(1.0, 6.0, f * 1.2);\n    p.xz *= scale;\n    float d = sdCyl(p, 0.05, 0.9) / scale;\n    return vec2(d, 3);\n}\n\nvec2 cup(vec3 p)\n{\n    p.xz *= rotate(-1.6);\n    float d = sdCyl(p - vec3(0.0, 0.3, 0.0), 0.3, 0.3);\n    d = max(d, -sdCyl(p - vec3(0.0, 0.3, 0.0), 0.26, 0.8));\n    d = min(d, sdTorus(p.zxy - vec3(0.38,0.0,0.35), vec2(0.15, 0.02)) - 0.01);    \n    return vec2(d, 4);\n}\n\nvec2 phone(vec3 p)\n{\n    float d = sdBox(p - vec3(0.0, 0.0, 1.0), vec3(0.4, 0.02, 0.21)) - 0.03;\n    return vec2(d, 6);\n}\n\nvec2 omin(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(p.y, 0.0);\n    vec3 rp = p;\n    rp.z = abs(rp.z) - 0.2;\n    rp.xz *= rotate(0.3);\n    d = omin(d, book(rp - vec3(0.0, 0.15, 0.0)));\n    rp.xz *= rotate(0.2);\n    rp.z -= 0.3;\n    d = omin(d, book(rp - vec3(0.0, 0.4, 0.0)));\n    d = omin(d, book(p - vec3(-0.4, 0.65, -1.5)));\n    d = omin(d, cup(p - vec3(0.0, 0.0, 2.0)));\n    d = omin(d, phone(p + vec3(0.0, 0.0, 2.0)));\n    d = omin(d, vec2(sdBox(p - vec3(3.0, 2.0, 3.0), vec3(0.5, 2.0, 0.5)), 3.0));\n    return omin(d, pencil(p.zxy + vec3(0.0, 0.0, -0.03)));\n}\n\nfloat shadow(vec3 r0, vec3 rd)\n{\n    float shadow = 1.0;\n    float d = 0.01;\n    for(int i = 0; i < 64; ++i)\n    {\n        float t = map(r0 + d * rd).x;\n        if(t < 0.001) return 0.0;\n        d += t;\n        shadow = min(shadow, 20.0 * (t / d));\n    }\n    return shadow;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(2.0, 3.0, -1.0);\n    vec3 tgt = vec3(0.);\n    vec3 ww = normalize(tgt - r0);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    float zoom = 1.0;\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + zoom * ww);\n\n    vec3 col = vec3(0.0);\n    float d = 0.0;\n\n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = r0 + d * rd;\n        vec2 t = map(p);\n        d += t.x;\n        float matId = t.y;\n        vec3 albedo = vec3(0.0);\n        if(t.x < 0.001) {\n            vec3 n = norm(p);\n            vec3 ld = normalize(vec3(0.5, 0.5, 0.5));\n\n            if(matId < 0.5){\n                //Plane\n                float noise = fbm(0.1 + sin(p.xz * vec2(2.0, 5.0) * 8.0));\n                albedo = mix(vec3(0.05, 0.024, 0.012), vec3(1.0, 0.66, 0.3), noise) * 0.5;\n            }\n            else if(matId < 1.5)\n            {\n                //book page\n                albedo = vec3(1.0);\n            }\n            else if(matId < 2.5)\n            {\n                //book cover\n                float gradientX = noise((p.xz + vec2(0.01, 0.0)) * 100.0);\n                float gradientZ = noise((p.xz + vec2(0.0, 0.01)) * 100.0);\n                vec3 gradient = normalize(vec3(gradientX, 2.0, gradientZ));\n                gradient -= dot(n, gradient) * n;\n                n = normalize(n - 0.4 * gradient);\n                albedo = normalize(p + vec3(3.2, 0.0, 0.3)) * 0.4;\n            }\n            else if(matId < 3.5)\n            {\n                //pencil\n                vec2 uv = vec2(atan(p.x, p.z), length(p.xz));\n                albedo += vec3(p.x > 0.8 && p.x < 0.85) * vec3(1.0, 0.8, 0.4);\n            }\n            else if(matId < 4.5)\n            {\n                //Cup\n                vec2 uv = vec2(atan(p.z, p.y), length(p.xy)) * 20.0;\n                albedo += length(p - vec3(0.0, 2., 0.0)) - 0.1;\n                albedo *= 0.9;\n            }\n            else{\n                vec2 c = p.xz - vec2(0.0, -1.0);\n                vec2 b = abs(c) - vec2(0.39, 0.25);\n                float d = smoothstep(0.0, 0.01, length(max(b, 0.0)));\n                albedo += d;\n\n                b = abs(c) - vec2(0.08, 0.06);\n                d = smoothstep(0.0, 0.01, length(max(b, 0.0)));\n                albedo += (1.0 - d) * 2.0;\n\n                b = abs(c + vec2(0.1, 0.0)) - vec2(0.011, 0.02);\n                d = smoothstep(0.0, 0.01, length(max(b, 0.0)));\n                albedo += (1.0 - d) * 2.0;\n\n                c = c - vec2(0.1, 0.0);\n                b = abs(c) - vec2(0.01, 0.06);\n                d = smoothstep(0.0, 0.01, length(max(b, 0.0)));\n                albedo +=  (1.0 - d) * vec3(10.0, 0.0, 0.0);\n                \n            }\n            float diff = max(dot(n, ld), 0.0);\n            vec3 h = normalize(ld - rd);\n            float spec = pow(max(dot(n, h), 0.0), 32.0);\n            float shad = shadow(p, ld);\n            col += (diff + spec * 5.0) * shad * 1.3;\n            col += (n.y * 0.5 + 0.5);\n            col *= albedo;\n            break;\n        }\n        if(d > 100.0){\n            d = 100.0;\n            break;\n        }\n    }\n    float depth = d;\n    fragColor = vec4(col, depth);\n}","name":"Buf A","description":"","type":"buffer"}]}