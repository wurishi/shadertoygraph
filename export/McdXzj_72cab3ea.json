{"ver":"0.1","info":{"id":"McdXzj","date":"1714178121","viewed":94,"name":"Laplacian Waves - Draw","username":"berelium","description":"https://beltoforion.de/en/recreational_mathematics/2d-wave-equation.php\nSolving the PDE wave equation using laplacian kernel. Click to make waves. Hold Space to draw on the screen and Shift to delete. I added a mouse lerp, it can be toggled in Buffer A.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["2d","grid","wave","laplacian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Laplacian Waves - Two slit\" by berelium. https://www.shadertoy.com/view/lfy3WD\n// 2024-04-27 00:14:03\n\nconst vec3 wallColor = vec3(0.6);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n    vec3 col = vec3(0);\n    \n    // Sample the wave\n    float wave  = textureLod(iChannel0, uv, 0.).r;\n    float awave = abs(wave);\n    //wave = (wave + 1.0) * 0.5; // Offset wave values, because some parts of the wave will be black\n    \n    // == Different ways to render the wave ==\n    //col += wave; // Raw wave\n    //col += wave / 2.0; // Subtle wave\n    //col += wave * 2.0; // Amplified wave\n    //col += awave; // Absolute wave\n    //col += awave - wave; // Trailing wave\n    col += awave + wave; // Darker center wave + lightened edges\n    // ====\n    \n    //col *= vec3(0.310,0.620,0.953); // Blue color\n    \n    col = mix(col, wallColor, textureLod(iChannel1, uv, 0.).r);\n    \n    // == Tonemap options == \n    //col = 1.001 - exp(-col); // Exponential remap\n    //col = tanh(col); // Hyperbolic remap\n    col = sqrt(col);\n    col = pow(col, vec3(1.0 / 2.2)); // Approximate sRGB\n    // ====\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Note that the eraser size is 2X the pen size\n#define PEN_SIZE 0.015\n// The float for lerp represents how many circles to draw between the previous mouse and the current\n#define DO_LERP 10.\n\n#define USE_PENROSE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prv = textureLod(iChannel0, fragCoord.xy/iResolution.xy, 0.).rgba;\n    \n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2  m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec2 pm = prv.zw;\n    \n    float prvCanvas = prv.x;\n    float canvas = prvCanvas;\n\n    //canvas += circle(uv, vec2(-.2), 0.05);\n    //canvas += circle(uv, vec2(0.0), 0.05);\n    //canvas += circle(uv, vec2(0.2), 0.05);\n    \n    if(iMouse.z > 0.5 && getKeyState(iChannel3, 32, 0)  && distance(m,pm) < 0.2) { // Space key press\n#ifdef DO_LERP\n        for(float i = 0.0; i <= 1.0; i += (1.0 / DO_LERP)) {\n            canvas += circle(uv, mix(pm,m,i), PEN_SIZE);\n        }\n#else\n        canvas += circle(uv, m, PEN_SIZE);\n#endif\n    }\n    if(iMouse.z > 0.5 && getKeyState(iChannel3, 16, 0)  && distance(m,pm) < 0.2) { // Shift0left key press\n#ifdef DO_LERP\n        for(float i = 0.0; i <= 1.0; i += (1.0 / DO_LERP)) {\n            canvas -= circle(uv, mix(pm,m,i), PEN_SIZE * 2.0);\n        }\n#else\n        canvas -= circle(uv, m, PEN_SIZE);\n#endif\n    }\n    \n    \n    canvas = clamp(canvas, 0.0, 1.0);\n\n    fragColor = vec4(canvas, 0.0, m);\n} ","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Credit to @Blackscreeen : https://www.shadertoy.com/view/Ndtyzl\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n     \n    return step1*step2;\n}\nfloat rectangle(vec2 uv, float left, float right, float bottom, float top){\n    float blur = 0.001;\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2; \n}\n\nfloat circle(vec2 uv, vec2 p, float r) {\n    return smoothstep(r, r - 0.025, length(uv - p) - r);\n}\n\n// Credit to @darkfox : https://www.shadertoy.com/view/wlfyW8\nbool getKeyState(sampler2D channel, int keyCode, int stateType){\n    return bool(texelFetch(channel, ivec2(keyCode, stateType), 0).x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float vel = 2.0; \nfloat freq = 13.; // The higher the frequency, the more subtractive banding there is in the output\nfloat damp = 0.965; \n\nvec4 scene(sampler2D channel, vec2 uv) {\n    vec2 p = uv * vec2(iResolution.x / iResolution.y, 1.0);\n    return mix(textureLod(channel, uv, 0.), vec4(0.0, 0.0, 0.0, 1.0), textureLod(iChannel1, uv, 0.).x);\n}\n\n// 3x3 kernel, derived from\n// 0  1  0\n// 1 -4  1\n// 0  1  0\n// Normalized from -1 to 1\nconst float[5] kernel = float[](\n       0.25,\n  .25, -1.0, .25,\n       0.25\n); // Note: optimized to simply be a 5 texel lookup\n\n// Relative neighbor locations from current pixel\nconst vec2[5] neighbors = vec2[5](\n                       vec2(0.0,  1.0),\n     vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),\n                       vec2(0.0, -1.0)\n);\n// Get neighboring pixel values to the current uv position\nfloat[5] getNeighbors(sampler2D channel, vec2 uv) {\n\tvec2 px = 1.0 / iResolution.xy;\n    float[5] field;\n    for (int i = 0; i < 5; i++) {\n        vec2 r = uv + px * neighbors[i];\n        //field[i] = texture(channel, r).x;\n        field[i] = scene(channel, r).x;\n    }\n    return field;\n}\n\n// Laplacian of a 2d-grid\nfloat laplacian(float[5] samples) {\n    float sum = 0.0;\n    for (int i = 0; i < 5; i++) {\n        sum += samples[i] * kernel[i];\n    }\n    return sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p  = fragCoord.xy / iResolution.yy;\n    \n    if (iFrame == 0) { // Ensure the buffer is zeroed\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n\n    vec2 tex = scene(iChannel0, uv).rg;\n    float u0 = 0.0;   // Future value \n    float u1 = tex.r; // Current value\n    float u2 = tex.g; // Past value\n    \n    float[5] field = getNeighbors(iChannel0, uv);\n    \n    // Solve for u0 using the wave formula\n    u0 = vel * laplacian(field) + (2.0 * u1) - u2; \n    u0 *= damp;\n     \n     \n    \n    // If the mouse is pressed, calculate a small circle of waves at its position\n    if(iMouse.z > 0.5 && !getKeyState(iChannel3, 32, 0)  && !getKeyState(iChannel3, 16, 0)) {\n        vec2 m = iMouse.xy / iResolution.y;        \n        if(length(p - m) < 0.005) u0 = abs(sin(iTime * freq)) * 0.25;\n    }\n    \n    \n    fragColor = vec4(u0, u1, u2, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}