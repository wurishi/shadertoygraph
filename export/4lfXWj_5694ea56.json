{"ver":"0.1","info":{"id":"4lfXWj","date":"1439576301","viewed":259,"name":"P_Malin's delorean modeling","username":"yasuo","description":"Mr. P_Malin's delorean modeling is so simple and It's good to start to learn modeling by code.\nBelow is original one, so Amazing and great work.\nhttps://www.shadertoy.com/view/MlsSzf\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["studymodelingbyraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define NEAR 0.01\n#define FAR 128.\n#define ITER 128\nfloat pi = 3.14159265359;\n\n\nmat4 matRotateX(float rad)\n{\n    return mat4(1,       0,        0,0,\n                0,cos(rad),-sin(rad),0,\n                0,sin(rad), cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n    return mat4( cos(rad),0,-sin(rad),0,\n                0,       1,        0,0,\n                sin(rad),0, cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n    return mat4(cos(rad),-sin(rad),0,0,\n                sin(rad), cos(rad),0,0,\n                0,        0,1,0,\n                0,        0,0,1);\n}\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 mapFloor ( vec3 pos )\n{\n    vec4 ret = vec4(0.1,0.1,0.1,1.0);\n    ret.w = pos.y;\n    return ret;\n}\n\n/* Mr. P_Malin's delorean modeling https://www.shadertoy.com/view/MlsSzf */\nfloat PlaneDist( const in vec3 vPos, const in vec4 vPlane )\n{\n    return dot(vPlane.xyz, vPos) - vPlane.w;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat CarBodyMin( float a, float b )\n{\n    return smin(a, b, 0.03);\n}\n\nfloat CarBodyMax( float a, float b )\n{\n    return -CarBodyMin(-a, -b);\n}\n\nfloat CarBodyDisance(vec3 _vPos )\n{\n    vec3 vCarPos = _vPos;\n\n    vec3 vBodyPos = vCarPos;\n    vBodyPos.x = abs(vBodyPos.x);\n\n    float distBonnet0 = PlaneDist(vBodyPos, vec4( -0.005687, 0.994044, 0.108829, 0.891393 ) );\n    float distRoof0 = PlaneDist(vBodyPos, vec4( 0.004004, 0.999946, 0.009596, 1.124596 ) );\n    float distFrontWindow0 = PlaneDist(vBodyPos, vec4( -0.002180, 0.918728, 0.394886, 1.033900 ) );\n    float distDoorWindow0 = PlaneDist(vBodyPos, vec4( 0.765404, 0.643545, -0.002593, 1.145616 ) );\n    float distSmallWindow0 = PlaneDist(vBodyPos, vec4( 0.760709, 0.645945, -0.063856, 1.201365 ) );\n    float distDoorUpper0 = PlaneDist(vBodyPos, vec4( 0.945737, 0.324923, -0.002605, 1.045727 ) );\n    float distDoorLower0 = PlaneDist(vBodyPos, vec4( 0.985543, -0.169304, 0.006400, 0.805219 ) );\n    float distFront0 = PlaneDist(vBodyPos, vec4( 0.001169, 0.393724, 0.919228, 2.167077 ) );\n    float distBase0 = PlaneDist(vBodyPos, vec4( -0.002855, -0.999987, 0.004094, -0.132802 ) );\n    float distRearWindow0 = PlaneDist(vBodyPos, vec4( 0.001012, 0.976084, -0.217392, 1.302470 ) );\n    float distRear0 = PlaneDist(vBodyPos, vec4( -0.000983, 0.100691, -0.994917, 2.116753 ) );\n    float distFrontBase0 = PlaneDist(vBodyPos, vec4( 0.000408, -0.940669, 0.339326, 0.348749 ) );\n    float distRearBase0 = PlaneDist(vBodyPos, vec4( 0.120237, -0.941372, -0.315218, 0.256832 ) );\n    float distTopRearPanel0 = PlaneDist(vBodyPos, vec4( 0.909642, 0.405237, -0.091298, 1.161221 ) );\n    float distBottomRearPanel0 = PlaneDist(vBodyPos, vec4( 0.974792, -0.205007, -0.088053, 0.849642 ) );\n\n    float topCurveX = abs(vBodyPos.x);\n    topCurveX = topCurveX * topCurveX;\n    distBonnet0 += topCurveX * 0.05;\n    distRoof0 += topCurveX * 0.1;\n    distFrontWindow0 += topCurveX * 0.01;\n    distRearWindow0 += topCurveX * 0.01;\n\n    float topCurveZ = abs(vBodyPos.z);\n    topCurveZ = topCurveZ * topCurveZ;\n    distRoof0 += topCurveZ * 0.05;\n\n    float result = -100000.0;\n\n    result = CarBodyMax( result, distRoof0 );\n    result = CarBodyMax( result, distDoorWindow0 );\n    result = CarBodyMax( result, distSmallWindow0 );\n    result = CarBodyMax( result, distDoorUpper0 );\n    result = CarBodyMax( result, distDoorLower0 );\n    result = CarBodyMax( result, distFront0 );\n    result = CarBodyMax( result, distBase0 );\n    result = CarBodyMax( result, distRearWindow0 );\n    result = CarBodyMax( result, distRear0 );\n    result = CarBodyMax( result, distFrontBase0 );\n    result = CarBodyMax( result, distRearBase0 );\n    result = CarBodyMax( result, distTopRearPanel0 );\n    result = CarBodyMax( result, distBottomRearPanel0 );\n\n    float distBonnetWindow = CarBodyMin(distBonnet0, distFrontWindow0);    \n    result = CarBodyMax( result, distBonnetWindow );\n\n    return result;\n}\n/* Mr. P_Malin's delorean modeling https://www.shadertoy.com/view/MlsSzf */\n\nvec4 map( vec3 pos, mat4 m)\n{\n    vec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n    vec4 val1 = mapFloor( q.xyz );\n\n    vec4 newCarPos = vec4(q.xyz + vec3( 0, -1, 0 ),1)*matRotateY(180.0*pi/180.0);\n    vec4 val2 = vec4(0.5,0.5,0.5,CarBodyDisance(newCarPos.xyz ));\n\n    vec4 val4 = combine ( val1, val2 );\n    return val4;\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n    position -= .5;\n    vec3 dir = vec3( position, 1.0 );\n\n    float aspect = iResolution.x / iResolution.y;\n    dir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n    dir.yz = rot(dir.yz, 0.2);\n\n    vec3 pos = vec3(0.0, 2.5, 44.0);\n    mat4 m = matRotateY(time);\n\n    vec4 result;\n    for (int i =0; i < ITER; i++)\n    {\n        result = map(pos, m);\n        if (result.w < NEAR || result.w > FAR) break;\n        pos += result.w * dir;\n    }\n\n    vec3 col = map(pos, m).xyz;\n    vec4 bgCol;\n    if ( pos.z> 100. )\n    {\n        // bg\n        col = vec3(0);\n    }\n    else\n    {\n        // shade\n        vec3 lightPos = vec3(20.0, 20.0, 20.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .01, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n                      result.w - map( pos - eps.yxy, m ).w,\n                      result.w - map( pos - eps.yyx, m ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        col *= vec3(lambert);\n\n        col += vec3(result.xyz) ;\n    }\n\n    fragColor = vec4( col, 1.0);\n}","name":"Image","description":"","type":"image"}]}