{"ver":"0.1","info":{"id":"3sf3Rn","date":"1544648918","viewed":108,"name":"Losing Focus ( Displace Fun )","username":"CyanSprite","description":"Playing around with displacement and ray marching","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","displacement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n//const fields\nconst int steps = 13;\nconst float axis = .5;\nconst bool fractalMe = true;\nconst bool anim = true;\nconst float speed = 0.5;\nconst float displaceSpeed = 0.2;\nconst float rayAccuracy = 0.5;\n\n// a trippy effect, instead of accurately marching,\n// smoothstep between only highlighting parts\n// if you have this on YOU MUST have displaceVision on.\nconst bool distortionMarching = false;\n\n// fract the fog ( color ) to highlight the displacement.\nconst bool displaceVision = true;\n\n// floor it so it ONLY shows the displacement.\n// displaceVision must be turned off.\nconst bool justDisplace = false;\n\n\n// the plasma effect will smoothly apply to the spheres\nconst bool smoothLighting = true;\nconst float smoothness = 0.5;\n\n\n//displace values\nconst float displaceMount = 1.0;\nconst float displaceDisplace = 1.0;\nconst float displaceMax = 1.0;\n\n//twist values\nfloat twistMount = .5;\nfloat twistBlur = 1.0;\n\n//lighting values\nfloat lightingSpeed = 1.0;\nfloat lightIntensity = 10.0; \n\n//wall rotation\nconst bool doRotate = true;\nfloat rotateSpeed = 0.1;\n\nfloat getTime()\n{\n\treturn iTime * speed;\n}\nfloat getDisplaceTime()\n{\n\tfloat x = getTime() * displaceSpeed;\n    x =  ( sin ( x ) ) * 0.0 *  displaceMax + tan( x ) * 1.0;\n    x = sin ( iTime * displaceSpeed ) * 100.0;\n    return x;\n}\n\n//grayscaler\nvec3 grayscale(vec3 texColor){\n\tfloat grayScale = dot(texColor.rgb, vec3(.3,.59,.11));\n    \n    texColor.r = grayScale;\n    texColor.b = grayScale;\n    texColor.g = grayScale;\n    \n    return texColor;\n}\n\n//displacement\nfloat displacement(vec3 p){\n    float animSpeed = speed;\n    float timeScaleDisplace = getDisplaceTime() * .2;\n    if(anim)\n        animSpeed = timeScaleDisplace;\n\treturn \n        sin(animSpeed*(p.x + 1.0)* displaceMount * 1.)*\n        sin(animSpeed*(p.y + 1.0)* displaceMount * 1.)*\n        sin(animSpeed*(p.z + 1.0)* displaceMount * 1.)*\n        displaceDisplace;\n}\n\n//primitive of choice and if fractal\nfloat prim(vec3 p, float s){\n    vec3 q = fract(p) * 2.0 - 1.0;\n    if(!fractalMe)\n    \tq=p;\n  \treturn length(q) - s;\n}\n\n//opDisplace derived from iq\nfloat opDisplace( vec3 p, float se)\n{\n    float d1 = prim(p, se);\n    float d3 = prim(p, se * 2.0);\n    float d2 = displacement(p);\n    float rtn = d1 + d2 * 0.1;\n    \n    rtn = mix (d1, d2, 0.2);\n    // rtn = smoothstep(d1 * 1.0, d2 * 1.0, 0.1);\n    // rtn = mix ( rtn, d1, 0.5);\n    \n    return rtn;\n}\n\n//trace for raymarch\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    \n    for(int i=1;i<steps;i++){\n    \tvec3 p = o + r * t;\n        float d = opDisplace(p,axis);\n        if ( distortionMarching )\n        \tt += smoothstep(d, d * .5, 0.2);\n        else\n            t += d * rayAccuracy;\n    }\n    return t;\n}\n\n//main...\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Generalizing to window\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //aspect\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //normalizing uvs to vec3\n    vec3 rec = normalize(vec3(uv,1.0)) * vec3(1.,1.,1.);\n    \n    // rotation if we want.\n    if(doRotate){\n        float rot = iTime * rotateSpeed + tan ( getTime() ) * cos(getTime() );\n        rec.xz *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n        rec.yz *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n\n    }\n    \n    //cam\n    float camView = 1.5 * sin(getTime()) - 2.5 * cos ( getTime() ) + 5.0;\n\tvec3 o = vec3(0.0,0.0,-camView);    \n    \n    //tracing\n    float tr = trace(o,rec);\n   \n    //fog\n    vec3 mixedColor;\n    \n    //dynamic lighting and color derived from plasma effect with tracing\n\tvec3 r = rec;\n\tfloat t = iTime * lightingSpeed;\n    r = r * 8.0 / ( abs ( sin ( getTime() )) + 0.1);\n    float v1 = cos(r.x +t) * .1;\n    float v2 = sin(r.y +t) * .1;\n    float v3 = cos(r.x+r.y +t) * .1;\n    float v4 = cos(r.z+r.y +t) * .1;\n    float v5 = cos(r.z+r.x +t) * .5;\n\tfloat v = v1+v2+v3+v4+v5;\n    \n    if ( smoothLighting )\n    \tv = smoothstep(v, floor(v), smoothness);\n  \t\n    //mixedColor\n    mixedColor.rgb = vec3(cos(v) * .8, sin(v+.8*PI) * 0.5, -.2);\n    vec3 grayMixed = fract(grayscale(mixedColor));// - mixedColor.rgb*.5 * vec3(0.1,0.1,0.1);\n    \n    //fog from tracing\n    float fog = 1.0/ (tr * tr) * 1. * ( abs (sin ( getTime()) ));\n    if ( displaceVision )\n    \tfog = fract(fog);\n    else if ( justDisplace )\n        fog = floor(fog);\n    \n    //final color vector fog * greyMixed dyn color and lighting\n    vec3 fc = .01 * vec3(fog) * 1.1 * (grayMixed * 2.9 + .9) - grayMixed * .00001; //* sin ( iTime );\n    //fc = .1 * vec3(fog);\n    //final output... Using iChannel0 to display a texture or buffer a,b,c, or d (just colors originally.)\n    fragColor = vec4(fc,1.0) * texture(iChannel0,r.xy) * lightIntensity * ( camView * camView);\n//    fragColor = mix(vec4(1.0,0.0,0.0,1.0), vec4(0.0,0.0,1.0,1.0), sin(iTime));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Generalizing to window\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float r = mix(1.0, 0.2, sin ( iTime ));\n    float b = 1.;\n    float g =  mix(1.0, 0.2, cos ( iTime ));\n    \n    fragColor = vec4(r, g, b, 0.) + ( r + b + g ) / 3.0;\n}","name":"Buffer A","description":"","type":"buffer"}]}