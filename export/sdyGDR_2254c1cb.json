{"ver":"0.1","info":{"id":"sdyGDR","date":"1631329858","viewed":126,"name":"Interest hunting mandelbrot","username":"tiusic","description":"Mandelbrot shader that automatically zooms in on a random interesting part of the fractal. Interesting parts are detected by looking for areas with a high rate of change.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float clrs = 0.1;\nconst float clro = 0.0;\nconst vec3 clrw = vec3(1.3, 1.1, 1.0);\nconst vec3 clrp = vec3(-0.2, 0.0, 0.2);\n\nvec3 color(float d) {\n  if (d < 0.0) return vec3(0.0, 0.0, 0.0);\n  float e = log(1.0 + max((d - clro) * clrs, 0.0));\n  return 0.5 - 0.5 * cos(TAU * (clrw * e + clrp));\n}\n\nvec3 run(vec2 pix) {\n  vec3 offzoom = getOffAndZoom(iFrame, iChannel1);\n  if (SHOWCURRENTTARGET) {\n    vec2 current = getCurrentTarget(iChannel1);\n    vec2 cpix = unscreen(unproj(current, offzoom), iResolution.xy);\n    if (distance(cpix, pix) < 3.0) {\n      return vec3(1.0, 1.0, 1.0);\n    } else if (distance(cpix, pix) < 5.0) {\n      return vec3(0.0, 0.0, 0.0);\n    }\n  }\n  if (SHOWTRUETARGET) {\n    vec2 target = getTrueTarget(iResolution.xy, iFrame, iTime, iChannel1);\n    vec2 tpix = unscreen(unproj(target, offzoom), iResolution.xy);\n    if (distance(tpix, pix) < 3.0) {\n      return vec3(1.0, 1.0, 1.0);\n    } else if (distance(tpix, pix) < 5.0) {\n      return vec3(0.0, 0.0, 0.0);\n    }\n  }\n  return vec3(color(texture(iChannel0, pix / iResolution.xy).r));\n}\n\nvoid mainImage(out vec4 clr, in vec2 pix) {\n  clr = vec4(run(pix), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n#define MAXITR 1000  // Decrease this if it's running too slow.\n#define SHOWCURRENTTARGET false\n#define SHOWTRUETARGET false\n#define PICKX 30\n#define PICKY 30\n#define PICKT 3.0\n#define PICKR 60\n#define ZOOMR 1.01\n#define MAXZ 3e4\n#define INITOFFZ vec3(-0.75, 0, 0.2)\n#define RANDBOUND vec4(-2, -1.15, 0.5, 1.15)\n\n// Hash is based on: https://www.shadertoy.com/view/4djSRW\n// Had to modify it a bit since I'm using iTime rather than pixels, so p's range is small.\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * 123.456789 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 screen(vec2 pix, vec2 res) { return (pix - 0.5 * res) / res.x; }\nvec2 unscreen(vec2 scr, vec2 res) { return scr * res.x + 0.5 * res; }\nvec2 proj(vec2 uv, vec3 offzoom) { return offzoom.xy + uv / offzoom.z; }\nvec2 unproj(vec2 p, vec3 offzoom) { return (p - offzoom.xy) * offzoom.z; }\nvec2 lerp(vec2 a, vec2 b, vec2 t) { return (1.0 - t) * a + t * b; }\n\nvec4 float2clr(float x) {\n  uint u = floatBitsToUint(x);\n  return vec4(u & 0xFFu, (u >> 8) & 0xFFu, (u >> 16) & 0xFFu, (u >> 24) & 0xFFu) / 255.0;\n}\n\nfloat clr2float(vec4 c) {\n  uvec4 u = uvec4(c * 255.0);\n  return uintBitsToFloat(u.r + (u.g << 8) + (u.b << 16) + (u.a << 24));\n}\n\nfloat texelGet(sampler2D samp, int x, int y) {\n  return clr2float(texelFetch(samp, ivec2(x, y), 0));\n}\n\nvec3 getOffAndZoom(int frame, sampler2D samp) {\n  if (frame < 10) return INITOFFZ;\n  return vec3(texelGet(samp, 0, 0), texelGet(samp, 0, 1), texelGet(samp, 0, 2));\n}\n\nvec2 getCurrentTarget(sampler2D samp) {\n  return vec2(texelGet(samp, 1, 0), texelGet(samp, 1, 1));\n}\n\nvec2 getRandTarget(vec2 res, float time) {\n  return lerp(RANDBOUND.xy, RANDBOUND.zw, hash21(time));\n}\n\nvec2 getTrueTarget(vec2 res, int frame, float time, sampler2D samp) {\n  if (frame < 10) return getRandTarget(res, time);\n  return vec2(texelGet(samp, 2, 0), texelGet(samp, 2, 1));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: The fractal, but just 1 float per pixel, not yet mapped to colors.\n\nfloat mandelbrot(vec2 p) {\n  vec2 z = vec2(0.0, 0.0);\n  for (int i = 0; i < MAXITR; ++i) {\n    if (dot(z, z) > 1e12) {\n      return max(0.0, float(i) - log2(log2(dot(z, z))));\n    }\n    z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + p.xy;\n  }\n  return -1.0;\n}\n\nfloat fractal(vec2 pix) {\n  vec3 offzoom = getOffAndZoom(iFrame, iChannel0);\n  return mandelbrot(proj(screen(pix, iResolution.xy), offzoom));\n}\n\nvoid mainImage(out vec4 clr, in vec2 pix) {\n  clr = vec4(fractal(pix), 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: Calculate the rate of change of the fractal value.\n\nfloat getValAt(vec2 pix) {\n  return texture(iChannel0, pix / iResolution.xy).x;\n}\n\nfloat getVelAt(vec2 pix) {\n  float vo = getValAt(pix);\n  float vx = getValAt(pix + vec2(1, 0));\n  float vy = getValAt(pix + vec2(0, 1));\n  return length(vec2(vx, vy) - vo);\n}\n\nvoid mainImage(out vec4 clr, in vec2 pix) {\n  float d = getVelAt(pix);\n  clr = vec4(d, d, d, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C: Downsample the rate of change buffer.\n\nvoid mainImage(out vec4 clr, in vec2 pix) {\n  vec2 uv = clamp(pix / vec2(PICKX, PICKY), 0.0, 1.0);\n  clr = texture(iChannel0, uv);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D: Regenerate the data buffer.\n// 0, 0: vec2(targx, targy)\n// 1, 0: vec3(offx, offy, zoom)\n\nbool isValidTarget(int i, int j) {\n  return texelFetch(iChannel0, ivec2(i, j), 0).r > PICKT;\n}\n\nvec3 calcCurrentTarget() {\n  vec2 target = getTrueTarget(iResolution.xy, iFrame, iTime, iChannel1);\n  vec3 offzoom = getOffAndZoom(iFrame, iChannel1);\n  if (offzoom.z > MAXZ) {\n    // Reset.\n    return vec3(target, 0.0);\n  }\n  vec2 tpix = unscreen(unproj(target, offzoom), iResolution.xy);\n  float mindist = 1e9;\n  vec2 minpos = target;\n  int n = 0;\n  for (int i = 0; i < PICKX; ++i) {\n    for (int j = 0; j < PICKY; ++j) {\n      if (isValidTarget(i, j)) {\n        vec2 pix = iResolution.xy * vec2(i, j) / vec2(PICKX - 1, PICKY - 1);\n        float dist = distance(tpix, pix);\n        if (dist < mindist) {\n          mindist = dist;\n          minpos = proj(screen(pix, iResolution.xy), offzoom);\n        }\n      }\n    }\n  }\n  return vec3(minpos, 0.0);\n}\n\nvec3 calcTrueTarget() {\n  vec3 offzoom = getOffAndZoom(iFrame, iChannel1);\n  vec2 current = getCurrentTarget(iChannel1);\n  if (offzoom.z > MAXZ) {\n    // Reset.\n    return vec3(getRandTarget(iResolution.xy, iTime), 0.0);\n  }\n  // Move true target towards the current target.\n  vec2 target = getTrueTarget(iResolution.xy, iFrame, iTime, iChannel1);\n  target += 0.03 * (current - target);\n  return vec3(target, 0.0);\n}\n\n\nvec3 calcOffAndZoom() {\n  vec3 offzoom = getOffAndZoom(iFrame, iChannel1);\n  vec2 off = offzoom.xy;\n  float zoom = offzoom.z;\n  if (zoom > MAXZ) {\n    // Reset.\n    return INITOFFZ;\n  }\n  vec2 current = getCurrentTarget(iChannel1);\n  vec2 target = getTrueTarget(iResolution.xy, iFrame, iTime, iChannel1);\n  off += current * (ZOOMR - 1.0);\n  off /= ZOOMR;\n  zoom *= ZOOMR;\n  // Move towards true target.\n  off += 0.03 * (target - off);\n  return vec3(off, zoom);\n}\n\nfloat pick(vec3 v, int i) { return i == 0 ? v.x : i == 1 ? v.y : v.z; }\n\nvoid mainImage(out vec4 clr, in vec2 pix) {\n  if (pix.y < 3.7) {\n    if (pix.x < 0.7) {\n      clr = float2clr(pick(calcOffAndZoom(), int(floor(pix.y))));\n    } else if (pix.x < 1.7) {\n      clr = float2clr(pick(calcCurrentTarget(), int(floor(pix.y))));\n    } else if (pix.x < 2.7) {\n      clr = float2clr(pick(calcTrueTarget(), int(floor(pix.y))));\n    }\n  }\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}