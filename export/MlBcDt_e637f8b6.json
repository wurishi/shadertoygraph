{"ver":"0.1","info":{"id":"MlBcDt","date":"1581526699","viewed":60,"name":"[TP4]Moving Illuminated Scene","username":"Sando","description":"Illuminated scene with sphere and textured floor.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","tp4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLT_MAX = 1.0 / 0.0;   \n\n\nstruct Material\n{\n    float Ka; // ambiant\t\tcoefficient\n    float Kd; // diffuse\t\tcoefficient\n    float Ks; // specular\t\tcoefficient\n    float Kn; // specular power coefficient\n};\n    \n// Camera Parameters\nconst vec3 \t\tcameraPos \t\t= vec3(6, 4, -5);\nconst vec3 \t\tcameraTarget\t= vec3(3, 1, -8);\nconst float \tcameraFovY\t\t= 80.0;\n\n//Light Parameters\nconst vec3\t\tambiantCol\t= vec3(0,0,1);\nconst vec3\t\tlightCol\t= vec3(1,1,1);\nconst vec3 \t\tlightPos \t= vec3(8, 10, -12);\n    \n    \n// Sky Parameters\nconst vec3\t\tskyCol\t= vec3(0.2);\nconst int\t\tskyId\t= 0;\nconst Material\tskyMat\t= Material(1.0,0.0,0.0,0.0);\n\n// Sphere Parameters\nconst int \t\tsphereId \t\t= 1;\nconst vec3 \t\tspherePos\t\t= cameraTarget + vec3(0, 1, 2);\nconst float \tsphereRadius\t= 1.0;\nconst vec3\t\tsphereCol\t\t= vec3(1,0,0);\nconst Material \tsphereMat\t\t= Material(0.2, 0.7, 1.0, 50.0);\n\n// Sphere Parameters\nconst int \t\tsphere2Id \t\t= 2;\nconst vec3 \t\tsphere2Pos\t\t= cameraTarget + vec3(2, 1, 2);\nconst float \tsphere2Radius\t= 1.0;\nconst vec3\t\tsphere2Col\t\t= vec3(0.2,0.5,0.5);\nconst Material \tsphere2Mat\t\t= Material(0.5, 0.7, 1.0, 500.0);\n\n// Plan Parameters\nconst int \t\tplaneId \t\t= 3;\nconst vec3 \t\tplanePos\t\t= vec3(0, 0.1, 0);\nconst vec3\t\tplaneNormal\t\t= vec3(0, 1.0, 0);\nconst vec3\t \tplaneCol1\t\t= vec3(1.0);\nconst vec3\t\tplaneCol2\t\t= vec3(0.4);\nconst Material \tplaneMat\t\t= Material(0.2, 1.0, 0.2, 5.0);\n\n\nvoid computeCameraRayFromPixel(vec2 fragCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    float fragX = fragCoord.x - iResolution.x/2.0;\n    float fragY = iResolution.y/2.0 - fragCoord.y;\n    float fragZ = iResolution.y/(2.0*tan(radians(cameraFovY/2.0)));\n \n    vec3 cz = normalize(cameraTarget - cameraPos); \n    \n    vec3 tmpCy = vec3(0, -1, 0);\n    vec3 tmpCx = cross(tmpCy, cz);\n    \n    vec3 cx = normalize(tmpCx);\n    vec3 cy = cross(cz, cx);\n    \n    rayDir = normalize(fragX*cx + fragY*cy + fragZ*cz);\n    rayPos = cameraPos;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersectPt, out vec3 normalP)\n{\n   \tfloat den = dot(planeNormal, rayDir);\n    if(abs(den) < 0.0001)\n        return(-1.0);\n    float intersectDist = dot(planeNormal, planePos - rayPos)/den;\n    intersectPt = rayPos + rayDir*intersectDist;\n    normalP = -sign(den)*planeNormal;\n    return intersectDist;\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersectS, out vec3 normalS)\n{\n    float intersectDist = 0.0;\n    vec3 camSph = spherePos - rayPos;\n\tfloat proj = dot(camSph, rayDir);\n    float intersect = pow(sphereRadius, 2.0)+ pow(proj,2.0) - pow(length(camSph),2.0);\n    if(intersect > 0.0)\n        intersectDist = proj - sqrt(intersect);\n    intersectS = rayPos + rayDir*intersectDist;\n    normalS = normalize(intersectS - spherePos);\n    \n    return intersectDist;\n}\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersectI, out vec3 normalI){\n\tfloat minDist = FLT_MAX;\n    objectId = skyId;\n    \n    vec3 intersectS, normalS;\n\tfloat distS = raySphere(rayPos, rayDir, spherePos  + vec3(tan(iTime+2.0), tan(iTime+1.0), tan(iTime)), sphereRadius, intersectS, normalS);\n    if((distS > 0.0) && (distS < minDist)){\n    \tintersectI = intersectS;\n        normalI = normalS;\n        minDist = distS;\n        objectId = sphereId;\n    }\n    \n    vec3 intersectS2, normalS2;\n\tfloat distS2 = raySphere(rayPos, rayDir, vec3(pow(sphere2Pos.x-sin(iTime),2.0), pow(sphere2Pos.y-sin(iTime),2.0), sphere2Pos.z), sphere2Radius, intersectS2, normalS2);\n    if((distS2 > 0.0) && (distS2 < minDist)){\n    \tintersectI = intersectS2;\n        normalI = normalS2;\n        minDist = distS2;\n        objectId = sphere2Id;\n    }\n    \n    vec3 intersectP, normalP;\n    float distP = rayPlane(rayPos, rayDir, planePos, planeNormal, intersectP, normalP);\n    if((distP > 0.0) && (distP < minDist)){\n    \tintersectI = intersectP;\n        normalI = normalP;\n        minDist = distP;\n        objectId = planeId;\n    }\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return(minDist);\n}\n\nvec3 getSphereColorAtPoint(vec3 pt){\n    return(sphereCol);\n}\n\nvec3 getSphere2ColorAtPoint(vec3 pt){\n    return(sphere2Col);\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt){    \n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n    vec3 diff = pt - planePos; \n    \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    vec3 planeCol = (mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0) ? planeCol1 : planeCol2;\n    return(planeCol);\n}\n\nvec3 getColorAtPoint(int object, vec3 pt, out Material objectMat){\n    if (object == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (object == sphere2Id)\n    {\n        objectMat = sphere2Mat;\n        return getSphere2ColorAtPoint(pt);\n    } \n    else if (object == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\nvec3 computePhongShader(vec3 objectCol, Material objectMat, vec3 normalI, vec3 L, vec3 R, vec3 V){\n    vec3 ambiant \t= objectMat.Ka*ambiantCol;\n    float cosTheta\t= max(dot(normalI,L),0.0);\n    float cosAlpha\t= max(dot(R, V),0.0);\n    \n    vec3 diffuse \t= objectMat.Kd*lightCol*objectCol*cosTheta;   \n    vec3 specular\t= objectMat.Ks*lightCol*pow(cosAlpha,objectMat.Kn) ;\n    return ambiant + diffuse + specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Compute the ray to be casteed through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n\n    //Test intersection\n    vec3 intersectI, normalI;\n    int objectId;\n\tfloat inter = computeNearestIntersection(rayPos, rayDir, objectId, intersectI, normalI);\n    if (inter > 0.0){  \n    \t// Unit-vector from surface point to light\n    \tvec3 L = normalize(lightPos - intersectI);\n    \t// Unit-vector of reflection direction of the light at the surface point\n    \tvec3 R = normalize(2.0*normalI*dot(normalI,L)-L);\n    \t// Unit-vector from surface point to camera\n\t    vec3 V = normalize(cameraPos - intersectI);\n        \n\t    //Get point color\n    \tMaterial objectMaterial;\n\t    vec3 color = getColorAtPoint(objectId, intersectI, objectMaterial); \n   \t \n    \tfragColor = vec4(computePhongShader(color, objectMaterial, normalI, L, R, V), 1.0);\n    } else{// We did not hit the sphere, so we have the sky color (here: black)\n     \tfragColor = vec4(skyCol, 1);\n    }\n}\n","name":"Image","description":"","type":"image"}]}