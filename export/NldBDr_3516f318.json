{"ver":"0.1","info":{"id":"NldBDr","date":"1663002767","viewed":65,"name":"Graphics turnin shader1","username":"jnthomas522","description":"more","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["class"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//I found much help from the ArtOfCode youtuber. There were many vidoes\n//that gave me inspiration and direction on how to create various things\n\n//I made an effort to comment most of the code to show that I understood\n//what it was actually doing though.\n\n//max num of steps we take when marching\n#define MAX_STEPS 30 \n//furthest we'd go to look for an object\n#define MAX_DIST 100.\n//how close we need to be to the object to consider a hit\n#define SURF_DIST .01\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dSphere (vec3 p, vec4 s){\n\n\n    //from our point, the sphere origin is a certain length\n    //away. but then we also need to subtract the radius\n    return length(p-s.xyz)-s.w;\n\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\n\treturn length(max(abs(p)-s, 0.));\n    \n}\n\n\nfloat GetDist (vec3 p){\n    //defining the sphere\n    //0ed on the left right (x-axis)\n    //1 unit above the ground (off the y axis)\n    //6 units back (z-axis)\n    //1 unit radius\n    float sD = dSphere(p, vec4(0, 1.5, 6, 1.2));\n    float sD2 = dSphere(p, vec4(0, 1.5, 6, .6));\n    \n    //making the spheres\n    vec3 ps = p;\n    float s1 = dSphere(p, vec4(sin(iTime), 1.5, 6, .25) + vec4(3, 0, 0, 0));\n    float s2 = dSphere(p, vec4(-sin(iTime), 1.5, 6, .25) + vec4(-3, 0, 0, 0));\n    float s3 = dSphere(p, vec4(0, 1.5+sin(iTime), 6, .25) + vec4(0, 3, 0, 0));\n    float s4 = dSphere(p, vec4(0, 1.5-sin(iTime), 6, .25) + vec4(0, -3, 0, 0));\n    \n    //the place is simply going to be on the ground (0). So we\n    //just need to know the y-value of out point (p)\n    float planeDist = p.y;\n    \n    \n    //box\n    vec3 pBox = p;\n    pBox -= vec3(0,1.5,6);\n    pBox.xz *= Rot(iTime);\n    pBox.yz *= Rot(iTime);\n    float bD = dBox(pBox, vec3(1,1,1));\n    \n    \n    //box inside of box\n    vec3 pBox2 = p;\n    pBox2 -= vec3(0,1.5,6);\n    pBox2.xz *= -Rot(iTime);\n    pBox2.yz *= -Rot(iTime);\n    float bD2 = dBox(pBox2, vec3(.5,.5,.5));\n    \n    \n    \n    \n    //returning the minimum one\n    float d = max(bD, -sD);\n    d = min(d, bD2);\n    d = max(d, -sD2);\n    d = min(d, s1);\n    d = min(d, s2);\n    d = min(d, s3);\n    d = min(d, s4);\n\n    \n    \n    return d;\n}\n\n\nfloat RayMarch (vec3 ro, vec3 rd) {\n\n    float dO = 0.; \n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        //p is the currect marching location\n        //assgining here is basically starting at the\n        //ray origin and going a certain distance in the \n        //ray direction\n        vec3 p = ro + rd * dO;\n        //getting the distance to the scence/object\n        float ds = GetDist(p);\n        //updating the distance from the origin\n        dO += ds;\n        //if we're too far away from the camera\n        //OR if we're close enough to the object\n        //then we're good\n        if(dO > MAX_DIST || ds < SURF_DIST){\n            break;\n        }\n    }\n    \n    return dO;\n    \n\n\n}\n\nvec3 GetNormal(vec3 p){\n    \n    //we need d because p won't be perfectly\n    //on an object always\n    float d = GetDist(p);\n    \n    //a small distance from the object\n    //this is used to find the slope\n    vec2 e = vec2(.01, 0);\n    \n    //we need to use three points on the \n    vec3 n = d - vec3(\n                GetDist(p-e.xyy),\n                GetDist(p-e.yxy),\n                GetDist(p-e.yyx));\n                \n    //this returns the normal vector\n    //of the face that we found\n    return normalize(n);\n\n}\n\nfloat GetLight (vec3 p){\n    \n    //this is where out light source is going to be\n    vec3 lightPos = vec3(0, 3, 4); \n    \n    \n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    \n    //a light vector. the vector between point and light \n    vec3 l = normalize(lightPos-p);\n    \n    //we want to know where this face is pointing\n    vec3 n = GetNormal(p);\n    \n    //the dot basically get's the angle between the point normal\n    //and the light\n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    //seeing if the object is in the way. If so, we need shadow\n    //..\n    //ray marching in the direction of the light(l). \n    //This direction may need to change if the ground wasn't\n    // the only shadowed object\n    //Note that we also have to move p off the surface a bit\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    \n    if(d<length(lightPos-p)){\n        dif *= .5;\n    }\n    \n    return  dif;\n\n    \n    \n}\n\nfloat random (vec2 st) {\n\n    return fract(sin(dot(st.xy,\n        vec2(mod(15.0,11.0),mod(iTime,23.0))))*\n        100.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // \n    vec3 col = vec3(0);\n    \n    //camera/Ray Oridin\n    vec3 ro  =  vec3(0, 2, 0);\n    \n    //Ray Direction. pointing it outward/into the image\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.7)); \n    \n    //finding the distance until object is hit\n    float d = RayMarch(ro, rd);\n    \n    \n    //texture\n    col += vec3(texture(iChannel1, vec2(uv.y * sin(iTime * 0.3)))) * 0.5;\n    \n    \n    \n    //getting the point of where the object is \n    vec3 p = ro + rd*d;\n    \n    //light diffuser\n    float dif = GetLight(p);\n    \n    //painting the nearby things. Shapes\n    if(d < 100.){\n        \n        col += vec3(0,0.3,0.5);\n        \n        col += vec3(dif,dif,dif*0.5);\n        col += texture(iChannel0, vec2(uv.x)).rrr * 0.1;\n        \n    }\n    \n    //painting the far away things. Background\n    else{\n    \n        //inspiration from https://www.youtube.com/watch?v=8bbTkNZYdQ8&ab_channel=Radian628\n       for (float i = 0.0; i < 16.0; i+= 1.0){\n           \n           uv = abs(uv);\n           uv -= 1.0;\n           uv *= 1.;\n           uv *= Rot(iTime * 0.3);\n           \n       }\n       \n       col += vec3(length(uv),\n                  length(uv + vec2(0., -0.2)),\n                  length(uv + vec2(0., -0.3))) *0.7 ;  \n    }\n\n\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}