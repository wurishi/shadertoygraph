{"ver":"0.1","info":{"id":"4cdGDf","date":"1712220662","viewed":62,"name":"Desert Dunes ","username":"nisoniso","description":"Desert dunes with day and night cycles","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cycle","night","day","dunes","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From the last submission, I have added the following features:\n\n// Sky with clouds\n// Stars\n// Day and night cycles\n// Sun glare and disk with the day cycle\n// Sun movement with the day cycle\n\n// The day cycle duration is 30 seconds, 15s with a visible sun \n// The night cycle duration is 30 seconds with stars\n\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p); p -= i; \n    p *= p*(3. - p*2.);      \n    return dot(mat2(fract(sin(mod(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)), 6.2831853))))*vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n}\n\n\nfloat gradN2D(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = noise(i);\n    float b = noise(i + vec2(1.0, 0.0));\n    float c = noise(i + vec2(0., 1.));\n    float d = noise(i + vec2(1., 1.0));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n\nfloat sand(vec2 p){\n    vec2 q = p * 0.1;\n    float grad1 = gradN2D(q*5.);\n    float grad2 = gradN2D(q*5.);\n    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .8;\n    float a1 = 1. - a2;\n    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);\n    return c;\n}\n\nfloat cloud(vec2 p){\n    vec2 q = p * 0.1;\n    float grad1 = gradN2D(q*5.);\n    float grad2 = gradN2D(q*5.);\n    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .8;\n    float a1 = 1. - a2;\n    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);\n    return c;\n}\n\n\nfloat stars(vec2 p){\n//    only points\n    float n = noise(p);\n    return smoothstep(0.999, 1.0, n);\n}\n \n \nvec3 GetSky(in vec3 ro, in vec3 rd)\n{\n    vec3 colNight = vec3(0.0, 0.0, 0.1);\n    vec3 colDay = vec3(0.792, 0.882, 0.992);\n    float angle = mod(iTime, 60.) / 60. * 6.28;\n    const vec3 sunColour = vec3(1.0, .8, .8);\n    vec3 lightDir = normalize( vec3(0.5,0.8,0.) );\n    vec3  sky = mix(vec3(0.2,0.4,1.), vec3(0.8,0.9,1.),\n        max(0.0, dot(lightDir, normalize(vec3(0.0,1.0,0.0)))));\n\n    if(angle < 1.57) {\n        vec3 sunPos = vec3( 0.5, abs(sin(angle * .2)) / 2. , 0.0 );\n        vec3 sunDir = normalize(sunPos);\n        float sunDot = dot(rd, sunDir);\n        float sunGlow = smoothstep(0.9995, 1.0, sunDot);\n        sky += sunGlow * sunColour;\n\n    } else if(angle < 3.14) {\n        // Day using 1 + cos for sunPos\n        vec3 sunPos = vec3( 0.5, abs(1. + cos(angle * .2)) / 2. , 0.0 );\n        vec3 sunDir = normalize(sunPos);\n        float sunDot = dot(rd, sunDir);\n        float sunGlow = smoothstep(0.9995, 1.0, sunDot);\n        sky += sunGlow * sunColour;\n\n    } else if(angle < 4.71) {\n        // Night using mix colDay to colNight\n        vec3 col = mix(colNight, colDay, mod(iTime, 15.) / 15.);\n        col = mix(colDay, colNight, mod(iTime, 15.) / 15.);\n        vec2 p = rd.xy * 100. + vec2(2., iTime);\n        float starAmount = stars(p);\n        col = mix(col, vec3(1.0, 1.0, 1.0), starAmount);\n        return col;\n    } else if(angle < 6.28) {\n        // Night using mix colNight to colDay\n        vec3 col = mix(colNight, colDay, mod(iTime, 15.) / 15.);\n        vec2 p = rd.xy * 100. + vec2(2., iTime);\n        float starAmount = stars(p);\n        col = mix(col, vec3(1.0, 1.0, 1.0), starAmount);\n        return col;\n    }\n\n        vec3 col = clamp(sky, 0.0, 1.0);\n        vec2 p = rd.yx * 50. + vec2(iTime, 0.4);\n        float cloudAmount = cloud(p);\n        col = mix(col, vec3(0.8, 0.8, .85), cloudAmount);\n        return col;\n\n}\n\n\n\n\nvec3 timeRendering( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(0.5,0.8,0.) );\n    vec3 lightColor = vec3(1.0);\n    vec3 sandColor = vec3(0.85,0.7,0.6);\n\n    float tmin = 0.; // start at 1.0 to avoid self-intersection\n    float tmax = 25.0; // max distance to trace\n    float t = tmin;\n\t\n    for( int i=0; i<100; i++ ) // this is the main raymarching loop\n\t{\n        vec3 pos = ro + t*rd; // current position\n\t\tfloat h = pos.y - sand( pos.xz ); // distance to the surface\n\t\tif( h<(0.0001*t) || t>tmax ) break; // stop marching when close enough or too far\n\t\tt += 0.5 * h; // step forward along the ray\n\t}\n    vec3 col;\n    if(t>tmax){ \n        col = GetSky(ro, rd);\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        float shadow = 1.;\n        vec3 normal = normalize(vec3(sand(pos.xz-vec2(0.002*t,0.0)) - sand(pos.xz+vec2(0.002*t,0.0)),\n                                     2.0*0.002*t,\n                                     sand(pos.xz-vec2(0.0,0.002*t)) - sand(pos.xz+vec2(0.0,0.002*t))));\n        \n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        float lambertian = max(dot(lightDir,normal), 0.);\n        col = \n        lambertian * \n        lightColor * \n        shadow * sandColor;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    float rotY;\n    float rotX;\n    \n    // Camera rotation\n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \trotY = time;\n    \trotX = 1.2;        \n    }\n    else{\n        float PI = 3.14159265;\n        rotY = iMouse.x * 0.05;\n    \trotX = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n\n    // Camera setup\n    vec2 p0 = fragCoord.xy / iResolution.xy; // 0 to 1\n    p0.x *= iResolution.x/iResolution.y; // correct aspect ratio\n    vec3 ro = 1.1*vec3(2.5*sin(0.25*rotY),2.5 * cos(rotX),2.5*cos(0.25*rotY)); // camera position\n    vec3 ww = normalize(vec3(0.0) - ro); // look at\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww )); // right\n    vec3 vv = normalize(cross(ww,uu)); // up\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww ); // ray direction\n    vec3 col = timeRendering( vec3(iTime,1.8,0.0), rd ); // render\n\n\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}