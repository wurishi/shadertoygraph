{"ver":"0.1","info":{"id":"M3fcWf","date":"1726726424","viewed":16,"name":"My first raymarcher!!!","username":"dunishaaa","description":"raymarching a sphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST .01\n\nfloat pointSDF(vec3 p, float r){\n    return length(p) - r;\n}\nfloat lineSDF(vec3 p, vec3 a, vec3 b, float r){\n    float h = min(1.,\n              max(0.,\n                  dot(p-a, b-a)/\n                  dot(b-a, b-a)));\n    return length(p - a - h*(b-a)) - r;\n}\nfloat boxSDF(vec3 p, vec3 r){\n    return length(max(abs(p)-r, 0.));\n}\nfloat getDist(vec3 p){\n    float dS = pointSDF(p-vec3(0., 3.5, 6.), 2.) - cos(p.y*2. + iTime)*.2;\n    float dP = p.y;//-sin(p.x*2.)*.2;\n    vec3 a = vec3(4.,2., 6.); \n    vec3 b = vec3(4.,5., 6.); \n    float dL = lineSDF(p, a, b, 1.) - cos(p.y * 6.+iTime)*.2;\n    float dB = boxSDF(p-vec3(-4., 3.5, 5.), vec3(1.5, 3., 1.5));\n    dB -= .5;\n    return min(min(dB,dS), min(dP, dL));\n    //return dP;\n    \n}\nvec3 getNormal(vec3 p){\n    vec2 off = vec2(.01, 0.);\n    float d = getDist(p);\n    vec3 n = d - vec3 (\n        getDist(p - off.xyy),\n        getDist(p - off.yxy),\n        getDist(p - off.yyx)\n    );\n    return normalize(n);\n    \n}\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n  \n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + dO * rd;\n    \n        float dS = getDist(p);\n        dO += dS;\n\n        if(dS < MIN_DIST || abs(dO)> MAX_DIST) break;\n\n    }\n    return dO;\n}\nvec3 getLight(vec3 p){\n    vec3 col = vec3(0.7, 0.6, .5);\n    float amb = 0.;\n\n    vec3 lightPos = vec3(7, 10, 4);\n    float t = iTime*.5;\n    lightPos.xz += vec2(sin(t)*10., cos(t)*10.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float diff = clamp(dot(l,n), 0., 1.);\n    float d = rayMarch(p+n+MIN_DIST *3., l);\n    if(d < length(lightPos - p)) diff *= 0.5;\n    if(d < MAX_DIST)\n        col *= (diff + amb);\n    else\n        col *= diff;\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = fract(uv*5.);\n    vec3 col = vec3(0.7, 0.6, .5);\n    vec3 ro = vec3(0., 4., -9.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    \n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 light = getLight(p);\n    col = light;// == vec3(0.) ? vec3(.1): light;\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}