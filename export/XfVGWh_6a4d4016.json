{"ver":"0.1","info":{"id":"XfVGWh","date":"1712692868","viewed":160,"name":"Acid Zoomer","username":"nr4","description":"Fast sunday night effect. Enjoy! :)","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["plasma","acid","caleidoscope","householder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Acid Zoomer\n * Copyright (C) 2024 Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1,0,-1);\nconst float pi = 3.14159;\n\n/*\n * Add linear equidistant system of coordinate mirrors along a direction.\n * x: original coordinates.\n * axis: axis to align the mirrors onto.\n * size: distance between two adjacent mirrors.\n*/\nvec2 mirrorLinear(vec2 x, vec2 axis, float size) {\n    mat2 m = mat2(axis, axis.yx * c.zx);\n    x = transpose(m) * x;\n    float y = mod(x.x, size) - .5 * size;\n    return m * vec2((-1. + 2. * mod(floor((x.x - y) / size), 2.)) * y, x.y);\n}\n\n/*\n * Add circular equidistant system of coordinate mirrors.\n * x: original coordinates.\n * size: polar angle size.\n */\nvec2 mirrorCircular(vec2 x, float size) {\n    float p = atan(x.y, x.x);\n    float dp = mod(p + .5 * size, size) - .5 * size;\n    dp *= -1. + 2. * mod(round((p - dp) / size), 2.);\n    return length(x) * vec2(cos(dp), sin(dp));\n}\n\nvec3 cmap(float t) {\n    return vec3(-0.00,0.07,0.23)\n        +t*(vec3(2.57,-0.81,-9.92)\n        +t*(vec3(-37.43,3.26,118.72)\n        +t*(vec3(199.77,73.84,-449.72)\n        +t*(vec3(-392.43,-274.37,756.72)\n        +t*(vec3(323.25,324.20,-590.28)\n        +t*(vec3(-95.71,-126.29,174.23)\n    ))))));\n}\n\nvec3 cmap_out(float t) {\n    return vec3(-0.00,0.08,0.20)\n        +t*(vec3(4.29,1.93,1.82)\n        +t*(vec3(-24.07,-18.64,14.16)\n        +t*(vec3(48.06,118.32,-103.38)\n        +t*(vec3(9.02,-275.98,226.84)\n        +t*(vec3(-91.37,263.78,-212.07)\n        +t*(vec3(54.27,-89.39,72.71)\n    ))))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = mirrorLinear(fragCoord, c.xy, iResolution.x);\n    fragCoord = mirrorLinear(fragCoord, c.yx, iResolution.y);\n\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    float s = 1. + .3 * sin(.05 * iTime);\n\n    uv = mirrorCircular(uv, pi / 6.);\n    uv = mirrorLinear(uv - .01 * iTime*c.yx, vec2(.2, -1), .5 * s);\n    uv = mirrorLinear(uv - .01 * iTime*c.xx, vec2(1, -.3), .4 * s);\n    \n    uv = mirrorCircular(uv, pi / 5.);\n    uv = mirrorLinear(uv + .05 * iTime*c.xy, vec2(1,.5), .45 * s);\n    uv = mirrorLinear(uv + .05 * iTime*c.yx, vec2(-.5, 1), .55 * s);\n\n    float t = fract(pow(2.*length(mix(.7*texture(iChannel0, uv).rgb, texture(iChannel1, uv).rgb, .5+.5*cos(.3*iTime))) / sqrt(3.), .5) - .5 + .4 * iTime);\n    vec3 col = mix(cmap(t), cmap_out(t), .5+.5*sin(iTime));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}