{"ver":"0.1","info":{"id":"DtKfzt","date":"1702453984","viewed":13,"name":"Fork UCSD CSE 1 spamudji 861","username":"spamudji","description":"This is a homework template for a homework for UCSD CSE 167.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["animation"],"hasliked":0,"parentid":"ddtyDs","parentname":"UCSD CSE 167 Boids template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth HSV2RGB from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = vec4(0.5, 0.5, 0.5, 1.0);\n    // Loop over all boids\n    vec4 bcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    bool hit = false;\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel = texelFetch(iChannel0, tex_pos, 0);\n        if (distance(fragCoord, pos_vel.xy) < BOIDS_SIZE || distance(fragCoord, pos_vel.xy) < PRED_SIZE && i == 0) {\n            vec3 rgb = hsv2rgb(vec3((float(i)+0.5) / float(NUM_BOIDS), 1.0, 0.9));\n            bcolor += vec4(rgb, 1.0);\n            hit = true;\n        }\n    }\n    if (hit) {\n        color = bcolor;\n    }\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Main rendering function.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates to the range of 0 to 1.\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Initialization for the first frame.\n    if (iFrame == 0) {\n        // Read initial position and velocity from texture.\n        vec4 pos_vel = texture(iChannel1, fragCoord / iChannelResolution[1].xy);\n        // Set initial position and velocity with some scaling.\n        pos_vel.xy = iResolution.xy / 2.0 + (pos_vel.xy - 0.5) * iResolution.xy * 0.2;\n        pos_vel.zw = (pos_vel.zw - 0.5) * iResolution.xy * 1.0;\n        fragColor = pos_vel;\n        return;\n    }\n\n    // Convert fragment coordinates to integer format.\n    ivec2 iFragCoord = ivec2(fragCoord);\n\n    // Fetch position and velocity for the current boid.\n    vec4 pos_vel = texelFetch(iChannel0, iFragCoord, 0);\n    vec2 pos = pos_vel.xy;\n    vec2 vel = pos_vel.zw;\n    \n    // Calculating boundaries for movement rules.\n    float bound_r = sqrt(pow(iResolution.x, 2.0) + pow(iResolution.y, 2.0));\n    // Boundary\n    float dleft = 200.0;\n    float dright = iResolution.x - 200.0;\n    float dtop = 160.0;\n    float dbottom = iResolution.y - 160.0;\n    \n    // ID computation for the current boid.\n    int my_id = int(iFragCoord.y) * int(iResolution.x) + int(iFragCoord.x);\n\n    // Initialize vectors for different forces.\n    vec2 force_s = vec2(0.0); // Separation force.\n    vec2 force_a = vec2(0.0); // Alignment force.\n    vec2 force_b = vec2(0.0); // Boundary force.\n    vec2 force_c = vec2(0.0); // Cohesion force.\n    vec2 force_p = vec2(0.0); // Predator force.\n    vec2 force_i = vec2(0.0); // Interaction force.\n    float cen_dist;\n\n    // Variables for averaging positions and velocities.\n    vec2 avg_s = vec2(0.0), avg_p = vec2(0.0), avg_v = vec2(0.0);\n    float num_s = 0.0, num_c = 0.0, num_a = 0.0; // Counters for nearby boids.\n\n    // Loop over all boids to apply forces.\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        // Calculate texture position for boid.\n        ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x), i / int(iChannelResolution[0].x));\n        vec4 b_pos_vel = texelFetch(iChannel0, tex_pos, 0);\n        float dist = distance(pos, b_pos_vel.xy);\n\n        // Separation force.\n        if (dist < DS) {\n            num_s += 1.0;\n            avg_s += pos - b_pos_vel.xy;\n        }\n        \n        // Alignment force.\n        if (dist < DV) {\n            num_a += 1.0;\n            avg_v += b_pos_vel.zw;\n        }\n        \n        // Cohesion force.\n        if (dist < DV || i == 1) {\n            num_c += 1.0;\n            avg_p += b_pos_vel.xy;\n        }\n\n        // Predator force (special rule for a specific boid).\n        if (i == 0) {\n            // Adjust separation force if boid is a predator.\n            force_s *= PS_STR;\n        } else {\n            // Calculate position for predator and apply force.\n            ivec2 predator_pos = ivec2(0 % int(iChannelResolution[0].x), 0 / int(iChannelResolution[0].x));\n            vec4 predator_pos_vel = texelFetch(iChannel0, predator_pos, 0);\n            float dist_p = distance(pos, predator_pos_vel.xy);\n\n            if (dist_p < DV_p) {\n                force_p = pos - predator_pos_vel.xy;\n                force_p *= ((DV_p - dist_p) / DV_p);\n            }\n        }\n\n       \n    // Additional force calculations for boundary and predator behavior.\n        force_b = vec2(\n        ((pos.x < dleft) ? 1.0 : 0.0) - ((pos.x > dright) ? 1.0 : 0.0),\n        ((pos.y < dtop) ? 1.0 : 0.0) - ((pos.y > dbottom) ? 1.0 : 0.0)\n        ); \n        \n    }\n    \n    // Alignment force calculation.\n    force_a = (avg_v) / num_a - vel;    \n    // Cohesion force calculation.\n    force_c = (avg_p) / num_c - pos;\n    // Separation force calculation.\n    force_s = (avg_s) / num_s;\n\n    // Mouse click interaction\n    //if (iMouse.z > 0.0) { // Check if the mouse button is pressed.\n        // Calculate the interaction force from the mouse position.\n        //vec2 force_i = pos - (iMouse.xy / iResolution.y); // Force vector from mouse position.\n        //vec2 mouseForce = normalize(force_i) * 0.65 / dot(force_i, force_i);\n\n        // Apply the mouse force to the boid.\n        //force_i += mouseForce;\n    //}\n    \n    // If mouse is pressed.\n    if (iMouse.z > 0.0) {\n        // Calculate attraction force\n        force_i = normalize(iMouse.xy - pos);\n    }\n    \n    // Combine all forces.\n    vec2 force = \n    S_STR * force_s + \n    A_STR * force_a + \n    B_STR * force_b +     \n    C_STR * force_c + \n    P_STR * force_p +\n    force_i;\n\n    // Update velocity and position based on the calculated force.\n    vel += force;\n    if (length(vel) > 0.0){\n        if (length(vel) > MAX_SPD) {\n            vel = vel * (MAX_SPD / length(vel));\n        }\n        if (length(vel) < MIN_SPD) {\n            vel = vel * (MIN_SPD / length(vel));\n        }\n    }\n    pos += vel; // Update position.\n\n    // Set the fragment color as the new position and velocity.\n    fragColor = vec4(pos, vel);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUM_BOIDS 200     // The total number of boids in the simulation.\n#define BOIDS_SIZE 10.0   // The size of each boid for rendering or collision detection.\n\n#define DS 30.0           // Separation distance: the distance within which boids try to keep apart.\n#define DV 100.0          // View distance: the distance within which a boid can see other boids for alignment and cohesion.\n\n#define A_STR 0.03        // Alignment strength: how strongly boids align their velocity with nearby boids.\n#define B_STR 0.5         // Boundary force strength: how strongly boids are repelled from the screen boundaries.\n#define C_STR 0.001       // Cohesion strength: how strongly boids move towards the average position of nearby boids.\n#define P_STR 0.05        // Predator strength: how strongly boids react to the presence of a predator.\n#define S_STR 0.02        // Separation strength: how strongly boids react to maintain separation.\n#define I_STR 0.05        // Interaction Strength: The intensity of the force applied when interacting with themouse.\n\n#define PRED_SIZE 60.0    // The size of the predator boid (if one exists in the simulation).\n#define PS_STR 0.5        // Predator Separation Strength: The factor modifying the predator's separation behavior.\n#define DV_p 150.0        // Predator view distance: the distance within which a boid can detect the predator.\n\n#define MAX_SPD 10.0      // Maximum speed a boid can move.\n#define MIN_SPD 5.0       // Minimum speed a boid can move.","name":"Common","description":"","type":"common"}]}