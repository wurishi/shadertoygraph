{"ver":"0.1","info":{"id":"wljBDt","date":"1600990836","viewed":208,"name":"kmrd_CornellBox_v2.3","username":"komradepasha","description":"pathtracing exercise. microfacet BRDF with importance sampling, multiple diffuse bounces\nJimenez translucency approximation","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["pathtracing","brdf","montecarlo","microfacet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// convert linear to sRGB\nfloat sRGB(float channel) \n{\n\tif (channel <= 0.00031308)\n        channel *= 12.92;\n    else\n        channel = 1.055 * pow(channel, (1.0 / 2.4)) - 0.055;\n\n    return channel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 drawBuffer =  texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(vec3(sRGB(drawBuffer.r), sRGB(drawBuffer.g), sRGB(drawBuffer.b)),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Cornell Box. version 2.3\t\t\t\t\t\t\t\t\t\t by Pavel Pranevsky //\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t//\n//\t\t\t\t\t\t\t\t\t!!Work in Progress!!\t\t\t\t\t\t  \t//\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t//\n// This is an exercise in learning GLSL and understanding Monte Carlo path tracing. //\n// All code is property of it's creator and cannot be used without permission.\t\t//\n\n\n\n////////////////////     defines    ////////////////////\n\n// ray marching limits\n#define MAX_MARCHING_STEPS 100\n#define MAX_MARCHING_DIST 20.0\n#define MIN_SURFACE_DIST 0.0001\n\n#define PIXEL_SAMPLES 1\n\n// ray depth\n#define DIFFUSE_BOUNCES 3\n#define SPEC_BOUNCES 1\n#define REFRACTION_DEPTH 2\n\n// constants\n#define Pi 3.14159265359\n#define epsilon 0.000001\n\n//////////////////// custom structs ////////////////////\nstruct surface \n{\n    bool \tmetallic, refractive;\n    float \tdiffuseScale, specularScale, emissive, IOR, F0, roughness, scatteringWeight;\n    vec3 \talbedo, scatteringColor;\n};\n    \n\nstruct ray \n{\n    vec3 \torigin, direction;\n};\n\nstruct rayHit \n{\n    float \tdist;\t\t\t\t\t\n    vec3  \tnormal;\n    surface material;\n};\n\nstruct camera \n{\n    vec3 \tposition, target, forward, right, up;\t\t\n};\n\nstruct light \n{\n    vec3 \tposition, color;\t\t\n    float \tintensity, radius;\n    bool\tisSpherical, isArea, isSpot, isPoint, isDirectional;\n};\n\n//////////////////////////////////////////////////////// \nfloat randFloat (vec2 seed)\t\n{\t\n\treturn fract(sin(dot(seed.xy + vec2(iTime), vec2(12.9898, 78.233))) * 43758.5453);\t\n}\n\n\nvec3 translateToWS(vec3 direction, vec3 normal)\t\n{\n\tvec3  right, forward;\n\n    if (abs(normal.x) > abs(normal.y))\t\t\n\t\tright \t= vec3(normal.z, 0.0, -normal.x) / sqrt(normal.x*normal.x + normal.z*normal.z);        \n\telse        \t\t\t\t\t\t\t\n\t\tright \t= vec3(0.0, -normal.z, normal.y) / sqrt(normal.y*normal.y + normal.z*normal.z);  \n\t\tforward = cross(normal, right);\t\t\t\n    \n    return vec3(direction.x * forward.x + direction.y * normal.x + direction.z * right.x,\n\t\t\t\tdirection.x * forward.y + direction.y * normal.y + direction.z * right.y,\n\t\t\t\tdirection.x * forward.z + direction.y * normal.z + direction.z * right.z);\t\n}\n\n\n\nlight makeLight(vec3 lightPosition, vec3 lightColor, float intensity, float radius, int type) \n{\n    light l;\n    l.isSpherical = l.isArea = l.isSpot = l.isPoint = l.isDirectional = false;\n\n    if (type == 0)\n        l.isSpherical \t= true;\n    if (type == 1)\n        l.isArea \t\t= true;\n    if (type == 2)\n        l.isSpot \t\t= true;\n    if (type == 3)\n        l.isPoint \t\t= true;\n    if (type == 4)\n        l.isDirectional = true;\n    \n    l.position \t\t= lightPosition;\n    l.color \t\t= lightColor;\n    l.intensity \t= intensity;\n    l.radius \t\t= radius;\n    return l;\t\n}\n\n\n\nvoid updateCamera(inout camera cam) \n{\n    cam.forward \t= normalize(cam.target - cam.position); \n    cam.right \t\t= cross(vec3(0, 1, 0), cam.forward);\t    \n    cam.up \t\t\t= cross(cam.forward, cam.right);\t\t\t\n}\n\n\n\nray getCameraRay(vec2 uv, camera cam, float zoom) \n{\n    ray r;\n        r.origin \t= cam.position;                          \t\n        vec3 c \t\t= r.origin + cam.forward * zoom;\t\t\t\n        vec3 i \t\t= c + uv.x * cam.right + uv.y * cam.up;\t\t\n        r.direction = normalize(i - r.origin);                  \n    return r;\t\n}\n\n\n\nvoid resetRayHitDetails (inout rayHit rayHitDetails)\t\n{\n    rayHitDetails.dist\t\t\t\t\t\t=\tMAX_MARCHING_DIST;\n    rayHitDetails.normal\t\t\t\t\t=\tvec3(0.0);\n    rayHitDetails.material.metallic\t\t\t=\tfalse;\n    rayHitDetails.material.refractive\t\t=\tfalse;\n    rayHitDetails.material.albedo\t\t\t=\tvec3(0.0);\n    rayHitDetails.material.scatteringColor\t=\tvec3(0.0);\n    rayHitDetails.material.diffuseScale\t\t=\t1.0;\t\n    rayHitDetails.material.specularScale\t=\t1.0;\t\n    rayHitDetails.material.emissive\t\t\t=\t0.0;\n    rayHitDetails.material.IOR\t\t\t\t=\t1.0;\n\trayHitDetails.material.F0\t\t\t\t=\t0.04;\n    rayHitDetails.material.roughness\t\t=\t0.0;\t\n    rayHitDetails.material.scatteringWeight\t=\t0.0;\t\n}\n\n\n\nbool planeTrace(ray r, vec3 i0, vec3 i1, vec3 i2, inout rayHit rayHitDetails) \n{\n    vec3  n = normalize(cross((i1 - i0), (i2 - i0)));\n    vec3  p = vec3(0.0);  \t\t\t\t\t\t\t\t\t\n    float d = MIN_SURFACE_DIST;  \t\t\t\t\t\t\t\n\n\t// early out if dot of view vector and plane normal is positive or zero \n\tif (dot(r.direction, n) >= 0.0)\n\t\treturn false;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n\t{\n        p = r.origin + r.direction * d;\n        vec3 v \t= abs(dot((p - i0), n)) * n;\n\n        if (length(v) > MIN_SURFACE_DIST || d < MAX_MARCHING_DIST)\t\n\t\t\td += length(v);\n        else\t\n\t\t\tbreak;\t\n\t}\n\n    if (d > rayHitDetails.dist\t|| \tp.x >  4.51\n\t\t\t\t\t\t\t\t||\tp.x < -4.51\n\t\t\t\t\t\t\t\t|| \tp.y >  5.0\n\t\t\t\t\t\t\t\t||\tp.y <  0.0        \n\t\t\t\t\t\t\t\t|| \tp.z >  5.0\n\t\t\t\t\t\t\t\t|| \tp.z < -4.0)\t\treturn false;\n\n    rayHitDetails.dist \t\t= d;\n    rayHitDetails.normal \t= n;\n    return true;\n}\n\n\n\nbool sphereTrace(ray r, vec4 sphere, inout rayHit rayHitDetails) \n{\n    float distToCenter \t= length(sphere.xyz - r.origin);\n    float radius\t\t= sphere.w - MIN_SURFACE_DIST;\n    float cosThetaMax\t= sqrt(distToCenter*distToCenter - radius*radius) / distToCenter;\n\tfloat cosTheta\t\t= dot((sphere.xyz - r.origin), r.direction) / distToCenter;\n\n    if (cosTheta < cosThetaMax && distToCenter > radius)\t\n\t\treturn false;\t\n\t\n    vec3  p = vec3(0.0);  \t\t\t\t\t\t\t\t\t\t\t\t\n    float d = MIN_SURFACE_DIST;  \t\t\t\t\t\t\t\t\t\t// distance to intersection\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n\t{ \n        p = r.origin + r.direction * d;\n        float distToSphere \t= abs(distance(sphere.xyz,p) - sphere.w);  \t// distance to sphere from P\n            \n        if (distToSphere > MIN_SURFACE_DIST && d < MAX_MARCHING_DIST)\t\n\t\t\td += distToSphere;\n        else\t\n\t\t\tbreak;\t\n\t}\n\n    if (d > rayHitDetails.dist)\t\t\n\t\treturn false;\n\n    rayHitDetails.dist\t\t= d;\n    rayHitDetails.normal \t= (p - sphere.xyz) / vec3(sphere.w);\n    \n    if (dot(r.direction, rayHitDetails.normal) > 0.0)\t\n\t\trayHitDetails.normal *= -1.0;\n\n\treturn true;\t\n}\n\n\n// trace scene objects\nvoid traceScene(ray r, light l, inout rayHit rayHitDetails) \n{\n    resetRayHitDetails (rayHitDetails);\n\n    // dielectric\n    if (sphereTrace(r, vec4(3.0, 1.02, 2.0, 1.0), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.4;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.2;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(0.85, 0.0, 0.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\t\t\n\n    // metallic brass\n    if (sphereTrace(r, vec4(2.5, 3.0, 3.0, 0.75), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= true;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.4;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.95;\n        rayHitDetails.material.diffuseScale\t\t= 0.0;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.2;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(0.71, 0.65, 0.26);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\n\n    // metallic chrome\n    if (sphereTrace(r, vec4(-3.5, 0.92, -0.5, 0.9), rayHitDetails))  \n\t{\n\t\trayHitDetails.material.metallic\t\t\t= true;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.4;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.9;\n        rayHitDetails.material.diffuseScale\t\t= 0.0;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.2;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\n\n\t// subsurface scattering\n    if (sphereTrace(r, vec4(-2.0, 0.67, 1.5, 0.65), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.4;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 0.5;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.45;\n        rayHitDetails.material.scatteringWeight\t= 0.5;\n        rayHitDetails.material.albedo \t\t\t= vec3(0.941, 0.721, 0.627);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\n    \n\t// delectric rough\n    if (sphereTrace(r, vec4(-2.0, 2.5, 1.5, 0.75), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.4;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.05;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.5;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(0.0, 1.0, 0.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}    \n\n    // subsurface scattering\n    if (sphereTrace(r, vec4(1.5, 0.77, 0.3, 0.75), rayHitDetails))  \n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.4;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 0.5;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.45;\n        rayHitDetails.material.scatteringWeight\t= 0.5;\n        rayHitDetails.material.albedo \t\t\t= vec3(0.941, 0.721, 0.627);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\n\n    // floor \n    if (planeTrace(r, \tvec3(-1, 0.01,  1),\n        \t\t\t\tvec3( 1, 0.01,  1),\n                   \t\tvec3( 1, 0.01, -1), rayHitDetails))\t\n\t{\n \t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.4;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.3;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(0.4);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\n\n    // ceiling \n    if (planeTrace(r, \tvec3( 1, 4.99, -1),\n        \t\t\t\tvec3( 1, 4.99,  1),\n                   \t\tvec3(-1, 4.99,  1), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 0.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\t\t\n\n    // back wall\n    if (planeTrace(r, \tvec3(-1,  1, 4.99),\n        \t\t\t\tvec3( 1,  1, 4.99),\n                   \t\tvec3( 1, -1, 4.99), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 0.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\t\n\t}\t\n\n   // left wall - red\n    if (planeTrace(r, \tvec3(-4.5, 1, -1),\n        \t\t\t\tvec3(-4.5, 1,  1),\n        \t\t\t\tvec3(-4.5, 0,  1), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 0.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0, 0, 0 );\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\t\n\t}\t\t\t\n\n    // right wall - green\n    if (planeTrace(r, \tvec3(4.5, 1, -1),\n        \t\t\t\tvec3(4.5, 0,  1),\n        \t\t\t\tvec3(4.5, 1,  1), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 0.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(0, 1.0, 0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\t\n\t}\t\t\n\n    // sphere light \n    if (sphereTrace(r, vec4(l.position, l.radius), rayHitDetails))\n    {\n    \trayHitDetails.material.albedo \t\t\t= l.color * l.intensity;\n        rayHitDetails.material.emissive \t\t= l.intensity;\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n\t\trayHitDetails.material.F0\t\t\t\t= 0.04;\n        rayHitDetails.material.diffuseScale\t\t= 1.0;\n        rayHitDetails.material.specularScale\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\t\n    }\n}\n\n\nvec3 getRandomSample (vec2 seed) \t\t\t\t\t\t// cosine weighted uniform distribution\n{\n\tfloat cosTheta\t= sqrt(1.0-randFloat(seed.xy)); \t\t\t\t\t\t   \n\tfloat sinTheta\t= sqrt(max(1.0 - cosTheta*cosTheta, 0.0));\n    float phi \t\t= randFloat(seed.yx) * 2.0 * Pi;\n\n    return vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);\t\n}\n\n\nvoid getSphericalLightSample(in vec3 p, in light l, in vec2 seed, out vec3 L)\n{\n    float u0\t\t\t\t= randFloat(seed.xy + vec2(1.0,2.0));\n\tfloat u1\t\t\t\t= randFloat(seed.yx - vec2(1.0));\n    float d \t\t\t\t= length(l.position - p);\t\t\t\t\t\t// distance to light center\n    vec3  lcVector\t\t\t= (l.position - p)/d;\t\t\t\t\t\t\t// vector from p to spherical light center\n\n    float sinThetaMaxSq\t\t= (l.radius * l.radius) / (d * d);\n    float cosThetaMax \t\t= sqrt(max((1.0 - sinThetaMaxSq), 0.0));\t\t// cosThetaMax of sphere light solid angle\n        \n    float cosTheta\t\t\t= (u0 * cosThetaMax) + (1.0 - u0);\t\t\t\t// random cosTheta, between cosThetaMax and 1.0\n\tfloat sinTheta\t\t\t= sqrt(max(1.0 - cosTheta*cosTheta, 0.0));    \n    float phi \t\t\t\t= u1 * 2.0 * Pi;\n    \n    vec3  sampleDirection \t= vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);\n\n    L = translateToWS(sampleDirection, lcVector);\n}\n\n\nvec3 T(float s) \n{\n\treturn\tvec3(0.233, 0.455, 0.649) * exp(-s*s/0.0064) +\n\t\t\tvec3(  0.1, 0.336, 0.344) * exp(-s*s/0.0484) +\n\t\t\tvec3(0.118, 0.198,   0.0) * exp(-s*s/0.187) +\n\t\t\tvec3(0.113, 0.007, 0.007) * exp(-s*s/0.567) +\n\t\t\tvec3(0.358, 0.004,   0.0) * exp(-s*s/1.99) +\n\t\t\tvec3(0.078,   0.0,   0.0) * exp(-s*s/7.41);\n}\n\n\nvec3 sampleScattering (vec3 P, vec3 N, vec2 seed, light l)\n{\n\tvec3  L\t\t\t\t \t= vec3 (0.0);\n\tfloat scale\t\t\t\t= 3.0;\t\t\t\t\t// relative object scale\n\tfloat bias\t\t\t\t= 0.01; \t\t\t\t// scattering effect bias\n    vec3 P1\t\t\t\t\t= P - N*0.005;\n\tfloat cosThetaMax    \t= 0.0;\n\n    getSphericalLightSample (P1, l, seed, L);\n\n    rayHit rayHitDetails;\n    ray scatSampleRay \t\t= ray(P1, L);\n\ttraceScene(scatSampleRay, l, rayHitDetails);\t\t\n    \n\tfloat D \t\t\t\t= rayHitDetails.dist; \t// distance a potential light ray travels through the object\n    vec3  N1 \t\t\t\t= -rayHitDetails.normal;\n    float cosTheta\t\t\t= dot(N1,L);\n    \n    scatSampleRay.origin \t= P1 + L * D;\n    traceScene(scatSampleRay, l, rayHitDetails);\n\n    float D1 \t\t\t\t= rayHitDetails.dist; \t// distance to light\n    \n    if (rayHitDetails.material.emissive > 0.0)\n    {\n        float S \t\t\t= scale * (D + bias);\n        float E \t\t\t= max(0.3 + cosTheta, 0.0);\n        float A\t\t\t\t= (1.0) / (D1 * D1);\t// light attenuation\n\n        return T(S) * E * A * rayHitDetails.material.albedo;\n    }\n}\n\n\nvec3 sampleDirectDiff (vec3 P, vec3 V, light l, vec3 N, in vec2 seed)\n{\n\trayHit rayHitDetails;\n\tvec3 L \t\t\t\t= vec3(0);\t\t\t\t\t// initialize light sample vector\n\tfloat cosThetaMax   = 0.0;\n\n    if (l.isSpherical)\n    \tgetSphericalLightSample(P, l, seed, L);\t\t// get random direction vector L, within the solid angle of sphere light l\n\t\t\n    float cosTheta\t= dot(N,L);\t\t\t\t\t\t// derive cosine term\n    if (cosTheta < 0.0)\t\t\t\t\t\t\t\t// if it's negative, p is definitely in shadow and we can return zero without tracing further\n        return vec3(0);\t\t\t\t\t\t\n       \n    ray lightSampleRay\t= ray(P, L);\t\t\t\t// build sample ray\n    traceScene (lightSampleRay, l, rayHitDetails);\n\n    float attenuation \t= rayHitDetails.dist / l.radius + 1.0;\t// direct light attenuation factor\n\n    if (rayHitDetails.material.emissive > 0.0)\t\n        return rayHitDetails.material.albedo * cosTheta / (attenuation * attenuation);\n}\n    \n\nvec3 sampleIndirectDiff (vec3 P, vec3 V, light l, vec3 N, in vec2 seed)\t// assuming simple lambertian BRDF\n{\n\tvec3 totalLight = vec3(0);\n\tvec3 L\t\t\t= vec3(0);\n    vec3 albedo\t\t= vec3(1);\n    int  i \t\t\t= 0;\n    float cosTheta\t= 0.0;\n    \n    for (i; i < DIFFUSE_BOUNCES; i++)\n    {\n        rayHit rayHitDetails;\n        L \t\t\t\t\t\t= translateToWS(getRandomSample(seed.yx + vec2(i)), N);\t// cosine weighted random sample\n        cosTheta\t\t\t\t= dot(N,L);\t\t\t\t\t\t\t\t\t\t\t\t// cosine term\n        ray diffuseSampleRay \t= ray(P,L);\t\t\t\t\t\t\t\t\t\t\t\t// build sample ray\n\n        traceScene (diffuseSampleRay, l, rayHitDetails);    \n\n        if (rayHitDetails.dist == MAX_MARCHING_DIST)\n        {\n            totalLight += albedo * texture(iChannel1, diffuseSampleRay.direction).rgb * cosTheta;\n            break;\n        }\n        \n        if (rayHitDetails.material.emissive > 0.0 && i > 0)\n        {\n            totalLight += albedo * cosTheta;\n        \tbreak;\n        }        \n\t\t\n        else\n        {\n            albedo *= rayHitDetails.material.albedo;\n            N \t\t= rayHitDetails.normal;\n            P \t\t= diffuseSampleRay.origin + diffuseSampleRay.direction * rayHitDetails.dist;\n           \ttotalLight += albedo * cosTheta * sampleDirectDiff(P, V, l, N, seed + vec2(i+1));\n\t\t\tcontinue;\n        }\n    }\n    return totalLight ;\n}\n\n\nfloat getFresnel (vec3 V, vec3 N, float IOR)\t// full fresnel derived from surface IOR\n{\n\tfloat cosTheta1 = dot(V, N);\n    float cosTheta2 = sqrt ( 1.0 - (( 1.0 - (cosTheta1 * cosTheta1) ) / (IOR * IOR) ));\t\t\t\t\t\t\t\t\t\t\t\t\t\n    float ratio1 \t= ((cosTheta1 - IOR * cosTheta2) / (IOR * cosTheta2 + cosTheta1));\n    float ratio2 \t= ((IOR * cosTheta1 - cosTheta2) / (IOR * cosTheta1 + cosTheta2));        \n    \n\treturn ((ratio1 * ratio1) + (ratio2 * ratio2)) / 2.0;\t\n}\n\n\nvec3 sampleBRDF (vec3 N, float alpha2, vec2 seed) \t// importance sample according to BRDF\n{\n    float u0\t\t= randFloat(seed);\n\tfloat u1\t\t= randFloat(seed.yx + vec2(1.3,2.7));\n    float cosTheta\t= sqrt( (1.0 - u0) / ((alpha2 - 1.0) * u0 + 1.0) );\t\t\t\t\t   \n\tfloat sinTheta\t= sqrt(max(1.0 - cosTheta*cosTheta, 0.0));\n    float phi \t\t= u1 * 2.0 * Pi;\n\t\n    return translateToWS(vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta), N);\n}\n\n\nfloat GTermSchlickGGX (float NdotV, float NdotL, float K)\n{\n\tfloat GTermV = NdotV / (NdotV * (1.0-K) + K);\n\tfloat GTermL = NdotL / (NdotL * (1.0-K) + K);\n    return GTermV * GTermL;\n}\n\n\nfloat GTermSmith (float NdotV, float NdotL, float alpha2)\n{\n\tfloat GTermV = sqrt(alpha2 + (1.0 - alpha2)*NdotV*NdotV);\n\tfloat GTermL = sqrt(alpha2 + (1.0 - alpha2)*NdotL*NdotL);\n    return 2.0 * NdotV * NdotL / (NdotL*GTermV + NdotV*GTermL);\n}\n\n\nfloat DTermGGXTR (float NdotH, float alpha)\n{\n\talpha \t\t= NdotH * alpha;\n\tfloat kappa = alpha / (NdotH * NdotH * (alpha * alpha - 1.0) + 1.0);\n    return kappa * kappa / Pi;\n}\n\n\n// microfacet specular BRDF\nvec3 specBRDF (vec3 P, vec3 V, light l, vec3 N, float roughness, float F0, in vec2 seed, inout float fresnel)\n{\n    vec3  inRadiance, specularLight\t= vec3(0.0);\n\tfloat DTerm, FTerm, GTerm = 0.0;\n    float alpha \t\t= roughness * roughness;\n    float alpha2\t\t= alpha * alpha;\n    float kDirect\t\t= (alpha2 + 1.0) / 8.0;\n    float kIBL \t\t\t= alpha / 2.0;    \n\n    // importance sampling according to BRDF\n\tvec3  H \t\t\t= sampleBRDF (N, alpha2, seed + vec2(1.234,2.3456));\t\t\t// generate a random half vector within the brdf PDF\n    float VdotH\t\t\t= max(dot(V,H), epsilon);\n    vec3  L\t\t\t\t= 2.0 * VdotH * H - V;\t\t\t\t\t\t\t\t\t\t\t// derive the light vector\n    float NdotV\t\t\t= max(dot(N,V), 0.0);\n    float NdotL\t\t\t= dot(N,L);\n    float NdotH\t\t\t= max(dot(N,H), 0.0);\n    float LdotH\t\t\t= max(dot(L,H), 0.0);\n    float NdotV2\t\t= NdotV * NdotV;\n    float NdotL2\t\t= NdotL * NdotL;\n    float NdotH2\t\t= NdotH * NdotH;\n\n    if (NdotL > 0.0)\n    {\n        ray sampleRay \t= ray(P,L);\n        rayHit rayHitDetails;\n        traceScene (sampleRay, l, rayHitDetails);\n\n        if(rayHitDetails.dist == MAX_MARCHING_DIST || rayHitDetails.material.emissive > 0.0)\n        \tinRadiance \t= texture(iChannel1, L).rgb;\n        else\n        \tinRadiance\t= rayHitDetails.material.albedo * (sampleDirectDiff(P + L*rayHitDetails.dist, -L, l, rayHitDetails.normal, seed + vec2(1.234)) \n                                           \t\t\t\t+ sampleIndirectDiff(P + L*rayHitDetails.dist, -L, l, rayHitDetails.normal, seed));\n\n        FTerm \t\t\t= F0 + (1.0 - F0) * pow(1.0 - NdotV, 5.0); \n        fresnel \t\t= FTerm;\n        GTerm \t\t\t= GTermSchlickGGX(NdotV, NdotL, kIBL);\n        specularLight \t= inRadiance * (GTerm * FTerm * VdotH / (NdotH * NdotV));\t\n\t}\n    \n    // importance sampling spherical light solid angle\n    getSphericalLightSample(P, l, seed, L);\t\t\t\t\t\t// generate a random light vector within the spherical light solid angle\n    H \t\t\t\t\t= (V + L)/length(V + L);\t\t\t\t// derive the half-vector\n    NdotL\t\t\t\t= dot(N,L);\n    NdotH\t\t\t\t= max(dot(N,H), 0.0);\n    LdotH\t\t\t\t= max(dot(L,H), 0.0);\n    NdotL2\t\t\t\t= NdotL * NdotL;\n    NdotH2\t\t\t\t= NdotH * NdotH;\n\n    if (NdotL > 0.0)\n    {\n        ray sampleRay \t= ray(P,L);\n        rayHit rayHitDetails;\n        traceScene (sampleRay, l, rayHitDetails);\n\n        if (rayHitDetails.material.emissive > 0.0)\n        {   \n            float attn\t= 1.0 / (rayHitDetails.dist * rayHitDetails.dist);\n        \tinRadiance\t= l.color * l.intensity * attn;\n\t\t\tDTerm\t\t\t= DTermGGXTR (NdotH, alpha);\t\t// need to improve sampling at low roughness values\n    \t    GTerm \t\t\t= GTermSchlickGGX(NdotV, NdotL, kDirect);\n        \tspecularLight \t+= inRadiance * GTerm * FTerm * DTerm / (4.0 * NdotV);\n        }\n    }\n\n    return specularLight;\n}\n\n\nvec3 getPixelColor (ray cameraRay, vec2 seed, light[1] lightList) \n{\n\trayHit rayHitDetails;\n    traceScene (cameraRay, lightList[0], rayHitDetails);\n\n    // early-out tests\n    // if we missed everything - return environment cubemap\n    if (rayHitDetails.dist == MAX_MARCHING_DIST)\n        return texture(iChannel1, cameraRay.direction).rgb;\n    \n    // if we hit an emissive object (light) - return it's color (light.color * light.intensity)\n    if (rayHitDetails.material.emissive > 0.0)\n        return rayHitDetails.material.albedo;\n    \n    vec3  diffuse, scattering, specular\t= vec3(0.0); \n    vec3  specAlbedo = vec3(1.0);\n    vec3  P = cameraRay.direction * rayHitDetails.dist + cameraRay.origin;\n    vec3  albedo = rayHitDetails.material.albedo;\n    if (rayHitDetails.material.metallic)\n        specAlbedo = albedo;\n    vec3  scatColor = rayHitDetails.material.scatteringColor;\n    float Kd = rayHitDetails.material.diffuseScale;\n    float Ks = rayHitDetails.material.specularScale;\n    float Ksss = rayHitDetails.material.scatteringWeight;\t\n    float F0 = rayHitDetails.material.F0;\n    vec3  N = rayHitDetails.normal;\n    vec3  V = -cameraRay.direction;\n    float roughness = max(rayHitDetails.material.roughness, 0.01);\n    float IOR = rayHitDetails.material.IOR;\n\tfloat fresnel = 0.0;\n    float NdotV = dot(N, V);\n\n    // diffuse\n    if (Kd > 0.0)\n\t\tdiffuse = Kd * albedo * (sampleDirectDiff(P, V, lightList[0], N, seed) \n                                           + sampleIndirectDiff(P, V, lightList[0], N, seed + vec2(1.0)));\n\n    // SSS - still need to test for energy conservation, absorbed transmission energy needs to be omited from diffuse scattering\n    if (Ksss > 0.0)\n\t\tscattering = Ksss * scatColor * sampleScattering(P, N, seed + vec2(1.325,2.4), lightList[0]);\n    \n    // specular\n    if (Ks > 0.0)\n    \tspecular = Ks * specBRDF(P, V, lightList[0], N, roughness, F0, seed - vec2(1.0), fresnel);\t// microfacet approximation\n\n    return (1.0 - fresnel)*(scattering + diffuse) + (specular * specAlbedo);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\t\n{\n    vec2 uv \t\t\t= fragCoord / iResolution.xy - 0.5;      \t// Normalized pixel coordinates -0.5 to 0.5\n    vec2 mouseCoords \t= iMouse.xy / iResolution.xy - 0.5;\t\t    // Normalized mouse coordinates -0.5 to 0.5\n    float resRatio \t\t= iResolution.x / iResolution.y;       \t\t// screeen aspect ratio, approximately 1.77\n    mouseCoords.x \t\t*= resRatio;\n    uv.x \t\t\t\t*= resRatio;                                 \n    vec4 prevBuffer\t\t= texture(iChannel0, fragCoord / iResolution.xy);\t\n    vec3 drawBuffer\t\t= vec3(0);\n\n/////////////////// camera block ////////////////////////////////////////////////////////////////////////////  \n    camera cam1;\n    float zoom = 7.0;\n    float speed = 2.5;\n    \n    // initial camera state\n    cam1.position = vec3(0, 4, -3);\n    cam1.target = vec3(0, 2, 0);\n    updateCamera(cam1);\t\n        \n    cam1.position += vec3(-sin(mouseCoords.x * speed), -sin(mouseCoords.y * speed), -cos(mouseCoords.x * speed)) * zoom;\n\n    updateCamera(cam1);\t\n\n/////////////////// light block ////////////////////////////////////////////////////////////////////////////    \n\tlight sphereLight1 = makeLight( vec3(0.0, 1.5, 2.5),\t// position\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvec3(1.0), \t\t\t\t// color\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t5.0,\t\t\t\t\t// intensity\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t0.55,\t\t\t\t\t// radius\n                                  \t0);\t\t\t\t\t\t// type\n\n\tlight[] lightList = light[](sphereLight1);\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////    \n    ray  cameraRay \t\t= getCameraRay(uv, cam1, 1.0);\n    drawBuffer \t\t\t= getPixelColor(cameraRay, uv, lightList);\n    float tAlpha\t\t= prevBuffer.w + 1.0;\n\n    if (iMouse.z > 0.0)\t\n\t\ttAlpha = 1.0;\n\n     fragColor = vec4(mix(drawBuffer, prevBuffer.rgb, (1.0-1.0/tAlpha)), tAlpha);\n}","name":"Buffer A","description":"","type":"buffer"}]}