{"ver":"0.1","info":{"id":"Xf2czR","date":"1721854806","viewed":241,"name":"Doctor who smoke tunel","username":"NS_Deathman","description":"Author - https://www.shadertoy.com/view/ms3GDs\nPlanes variation - https://www.shadertoy.com/view/msGGRW\nCylinder variant (thanks for help) - https://www.shadertoy.com/view/4f2yzR","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","ray","volume","clouds","fbm","cloud","volumetric","raymarcher","scattering","smoke","scatter","volumetrics"],"hasliked":0,"parentid":"4f2yzR","parentname":"Fork Between th ZnW 663"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////\n#define USE_BLACK_BARS //Optimisation\n#define USE_NOISE_TEXTURE\n#define FAR_DISTANCE_MULTIPLIER float(2.0)\n#define NUM_STEPS 256.0 * FAR_DISTANCE_MULTIPLIER // marching steps, higher -> better quality\n#define FOV 67.5\n//#define FOCAL_LENGTH 26.9389\n////////////////////////////////////////////////////////////////////////\n// aces tonemapping\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n////////////////////////////////////////////////////////////////////////\n// generate a number between 0 and 1\nfloat hash(float n) \n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise(vec3 x) {\n    vec3 p = floor(x+.5);\n    vec3 f = fract(x+.5);\n    f = f*f*(3.-2.*f);\n\n    x = floor(x + 0.5) + smoothstep(0.0, 1.0, fract(x + 0.5)) - 0.5;\n    \n#ifdef USE_NOISE_TEXTURE\n    return texture(iChannel0, x/iChannelResolution[0]).r;\n#else\n    return (simplex3d(x) + 0.9) * 0.5;\n#endif\n}\n////////////////////////////////////////////////////////////////////////\n// volume density\nfloat map(vec3 p) {\n    float f = 0.;\n    \n    vec3 t = TIME * vec3(-.5, -.75, 0.5);\n    \n    //Generate main noise\n    p *= 3.;\n#ifdef USE_NOISE_TEXTURE\n    f += .25*(noise(2.*p+t*.2) + noise(p+t*0.2) + noise(p+t*0.1));\n    f += .15*noise(p+t*.4);\n#else\n    //f += .25*(noise(0.1 * p + t * .25));\n    f += .35*(noise((1.25 * p + t * .025) * 0.9)) + 0.1;\n    f += .25*noise((1.25*p+t*0.25) * 0.9) + 0.05;\n#endif\n    f += .0625*noise(8.*p+t*.1);\n    f += .03125*noise(16.*p+t*.05);\n    f += .015625*noise(32.*p+t*.025);\n    f += .0078125*noise(32.*p+t*.05);\n    p /= 3.0; // restore coordinates\n    \n    vec3 c = vec3(3.0,0.0,-0.75);\n    \n    // twist based on time\n    c.x += cos(TIME + p.z * 0.5) * 0.03;\n    c.x += sin(TIME * 0.03) * 0.02;\n    c.x -= cos(TIME) * 0.02;\n    c.x += cos(TIME * 0.2 + p.z * 2.0 - 1.0) * 0.015;\n    \n    c.y += cos(TIME + p.z * 0.33) * 0.02;\n    c.y += cos(TIME * 0.8 + p.z) * 0.025;\n    c.y += sin(TIME * 0.2) * 0.015;\n    c.y -= cos(-TIME) * 0.02;\n    c.y += sin(TIME + p.z * 2.0 - 1.0) * 0.02;\n    \n    // cylinder sdf\n    float cf = 1.0 - (length(p.yx-c.xy)-c.z*1.3);\n    cf *= 2.5;\n    \n    f += cf;\n    \n    f -= .025;\n\n    return -256.*f;\n}\n////////////////////////////////////////////////////////////////////////\n// light intensity function\nfloat getLight(float h, float k, vec3 ce, vec3 p) {\n    vec3 lig = ce-p;\n    float llig = length(lig);\n    lig = normalize(lig);\n    float sha = clamp((h - map(p + lig*k))/128.,0.,1.);\n    float att = 1./(llig*llig);\n    return sha*att;\n}\n////////////////////////////////////////////////////////////////////////\n// volumetric rendering\nvec3 render(vec3 ro, vec3 rd) \n{                   \n    float tmax = 6.0 * FAR_DISTANCE_MULTIPLIER; // maximum distance\n    \n    float s = tmax / float(NUM_STEPS); // step size\n    \n    float t = 0.0; // distance travelled\n    \n    // dithering\n    t += s * hash(gl_FragCoord.x * 8315.9213 / iResolution.x + gl_FragCoord.y * 2942.5192 / iResolution.y);\n    \n    vec4 sum = vec4(0,0,0,1); // final result\n    \n    // current point\n    vec3 p = vec3(0.0);\n    \n    // marching loop\n    for (int i=0; i<int(NUM_STEPS); i++) \n    { \n        p = ro + rd * t; \n        \n        float h = map(p); // density\n        \n        // inside the volume\n        if (h > 0.0) \n        {   \n            // lighting\n            float occ = exp(-h * 0.08); // occlusion\n            \n            float k = 0.08;\n            \n            vec3 col = vec3(0.0);\n            \n            //Right main light source\n            col += getLight(h, k, ro + vec3(0.75, -1, 1.5), p);\n            \n            //Left main light source\n            col += getLight(h, k, ro + vec3(-0.5, 1.25, 2.0), p);\n       \n            //Coorect brightness and add color of light sources\n            col *= 3.0 * vec3(0.3, 0.6, 1);\n             \n            sum.rgb += h * s * sum.a * col * occ; // add the color to the final result\n            \n            sum.a *= exp(-h * s); // beer's law\n        }\n        \n        // optimization\n        if (sum.a < .01) \n            break;\n            \n        t += s; // march\n    }\n                   \n    // output\n    return sum.rgb;\n}\n////////////////////////////////////////////////////////////////////////\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) \n{\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(-1,0,0))); // side vector\n    vec3 v = cross(u, w); // cross vector\n    return mat3(u, v, w);\n}\n////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Optimisation\n    vec2 q = fragCoord / RESOLUTION;\n    \n#ifdef USE_BLACK_BARS\n    float bars = step(abs(q.y-.5),.4);\n#else\n    float bars = 1.0;\n#endif\n\n    if ((fragCoord.x > RESOLUTION.x || fragCoord.y > RESOLUTION.y) || bars != 1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // pixel coordinates centered at the origin\n    vec2 p = (fragCoord - .5*RESOLUTION) / RESOLUTION.y;\n\n#ifdef FOCAL_LENGTH\n    float fov = length_to_fov(FOCAL_LENGTH);\n#else\n    float fov = FOV;\n#endif\n\n    //https://www.shadertoy.com/view/ltGfzD\n    float cam_factor = 1.0 / tan(radians(fov / 2.0));\n    vec3 ro = vec3(0,3.0,iTime); // ray origin\n    vec3 ta = ro + vec3(0,0,1); // target (x - reverse Y (Vlad Doc)\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    vec3 rd = ca * normalize(vec3(p,cam_factor)); // ray direction\n    \n    vec3 col = render(ro, rd); // render\n    \n    col = ACES(col); // tonemapping\n    col = pow(col, vec3(.4545)); // gamma correction\n\n    // vignette\n    col *= pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .5);\n\n    // output\n    fragColor = vec4(col, 1.0);\n}\n////////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////\n#define RESOLUTION iResolution.xy\n#define TIME iTime\n#define PI radians(180.0)\n////////////////////////////////////////////////////////////////////////\n//https://github.com/HitmanVere/weapon-port-infopedia/issues/1\n////////////////////////////////////////////////////////////////////////\n// Diagonal measurement for a 'normal' 35mm lens\nfloat DiagonalMeasurment = 43.266615300557;\n#define CAMERA_MATRIX_CROP 1.0f\n\nfloat fov_to_length( float fov ) \n{\n\tif ( fov < 1.0 || fov > 179.0 )\n\t\treturn 0.0;\n        \n\treturn ( DiagonalMeasurment / ( 2.0 * tan( PI * fov / 360.f ) ) );\n}\n\nfloat length_to_fov( float length) \n{\n\tif ( length < 1.0 )\n\t\treturn 0.0;\n\n\tlength *= CAMERA_MATRIX_CROP;\n\n\treturn ( 2.0 * atan( DiagonalMeasurment / ( 2.f * length ) ) * 180.f / PI );\n}\n\n////////////////////////////////////////////////////////////////////////\n//https://www.shadertoy.com/view/XsX3zB\n////////////////////////////////////////////////////////////////////////\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n     e.z = min(e.z, 3.0 - dot(e, vec3(1.0)));\n     \n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}","name":"Common","description":"","type":"common"}]}