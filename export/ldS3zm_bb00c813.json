{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// The below code makes assumes the View Frustrum has a width of 1 unit\n// In screen space, the origin is at the center of the screen\n// In camera space, the origin is at the camera\n// In world space, the origin is at (0.0,0.0,0.0)\n\n//===========MATH========\n\nconst float PIx2 = 6.28318530718;\n\n\n//=========RENDERING QUALITY==========\n\nconst float MAX_T = 400.0;\nconst float DELT = 0.00003;\nconst float LOD = 1.35;\nconst float SCALE = 0.03;\n\n\n//============WORLD OBJECTS===========\n\nconst float FLOOR_HEIGHT = -0.5;\n\n\n//===CAMERA/SCREEN CALCULATIONS=====\n\n// Dimensions of screen, with 1.0 defined as width of screen\n//vec2 SCREEN_DIMENSIONS = vec2(1.0, iResolution.y / iResolution.x);\n\n// The viewing reference point of the near frustum in uv coordinates\n//vec2 VRP_UV = vec2(SCREEN_DIMENSIONS.x/2.0, SCREEN_DIMENSIONS.y/2.0);\n\n// The distance of the camera behind the near viewing frustum\nconst float FOV = 107.0;\n//float CAMERA_FRUSTUM_DEPTH = SCREEN_DIMENSIONS.x / atan(radians(FOV));\n\n\n//=========ANIMATION==========\n\n// Camera Position in World Space\nvec3 CameraPositionInWorld()\n{\n\tvec3 pos = vec3(3.0 * iTime, 0.0, 0.5);\n\treturn pos;\n}\n\n// Camera Orientation Vector in World Space\nvec3 CameraOrientationInWorld()\n{\n\tfloat theta = mod(iTime, PIx2);\n\t\n\treturn vec3(1.0, 0.0, 0.1 * sin(theta));\n}\n\n//==========COLORING=========\n\nvec4 FloorColor(vec3 coord)\n{\n\treturn texture(iChannel0, SCALE * (coord.xy));\n}\n\nvec4 BackgroundColor()\n{\n\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n\n//=======SOLID MODELING======\n\nbool InFloor(vec3 coord)\n{\n\treturn coord.z <= FLOOR_HEIGHT + \n\t\t0.9* (texture(iChannel0, SCALE * coord.xy)).y +\n\t\t0.07* (texture(iChannel0, 0.5 * coord.xy)).y;\n}\n\n\n//=======RAY MARCHING========\n\nvec4 RayMarch(vec3 coord, vec3 rayVector)\n{\n\tvec3 marchCoord = coord;\n\t\n\tfor (float t = 0.0; t < MAX_T; t++)\n\t{\n\t\tfloat dist = DELT * pow(t, LOD);\n\t\tmarchCoord += rayVector * dist;\n\t\t\n\t\tif (InFloor(marchCoord))\n\t\t{\n\t\t\tfloat fog = (MAX_T - t) / MAX_T;\n\t\t\treturn fog * FloorColor(marchCoord);\n\t\t}\n\t}\n\t\n\treturn BackgroundColor();\n}\n\n//=====Transforms=============\n\nvec2 GetUVCoord(vec2 fragCoord)\n{\n\treturn fragCoord.xy / iResolution.x;\n}\n\nvec2 ToScreenSpace(vec2 uv)\n{\n    vec2 SCREEN_DIMENSIONS = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 VRP_UV = vec2(SCREEN_DIMENSIONS.x/2.0, SCREEN_DIMENSIONS.y/2.0);\n\treturn uv - VRP_UV;\n}\n\nvec3 ToCameraSpace(vec2 uv)\n{\n    vec2 SCREEN_DIMENSIONS = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 VRP_UV = vec2(SCREEN_DIMENSIONS.x/2.0, SCREEN_DIMENSIONS.y/2.0);\n    float CAMERA_FRUSTUM_DEPTH = SCREEN_DIMENSIONS.x / atan(radians(FOV));\n\t// \"up\" in screen coordinates is y, but \"up\" in camera coordinates is z\n\treturn vec3(uv.x, CAMERA_FRUSTUM_DEPTH, uv.y);\n}\n\n\nvec3 ToWorldCoord(\n\t\tvec3 pixelCoord, \n\t\tvec3 cameraOrientation, \n\t\tvec3 cameraPositionInWorld,\n\t\tout vec3 rayVector)\n{\t\n\t// sin/cos for rotation about y-axis (pitch)\n\tfloat yzPlaneDist = length(pixelCoord.yz);\t\n\tfloat ySin = pixelCoord.z / yzPlaneDist;\n\tfloat yCos = pixelCoord.y / yzPlaneDist;\n\t\n\t// sin/cos for rotation about z-axis (yaw)\n\tfloat xyPlaneDist = length(pixelCoord.xy);\n\tfloat zSin = pixelCoord.x / xyPlaneDist;\t\n\tfloat zCos = pixelCoord.y / xyPlaneDist;\n\n\t// y-axis rotation matrix\t\n\tmat3 yAxisRotation = mat3(\n\t\t\t\t\t\tyCos, \t\t\t\t0.0, \t\t\t\tySin,\n\t\t\t\t\t\t0.0, \t\t\t\t1.0, \t\t\t\t0.0,\n\t\t\t\t\t\t-1.0 * ySin, \t\t0.0, \t\t\t\tyCos);\n\t\n\t\n\t// z-axis rotation matrix\n\tmat3 zAxisRotation = mat3(\n\t\t\t\t\t\tzCos,\t-1.0 * zSin, \t0.0,\n\t\t\t\t\t\tzSin,\tzCos, \t\t\t0.0,\n\t\t\t\t\t\t0.0,\t0.0,\t\t\t1.0);\n\t\n\n\t// apply rotation matrices to camera orientation to get ray vector\n\trayVector = normalize(yAxisRotation * zAxisRotation * cameraOrientation);\n\t\n\t// transform current pixel from camera coordinates to world coordinates\n\treturn pixelCoord + CameraPositionInWorld();\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 pixel_coord = ToCameraSpace(ToScreenSpace(GetUVCoord(fragCoord)));\n\tvec3 rayVector = vec3(0.0, 0.0, 0.0);\n\tvec3 world_coord = ToWorldCoord(pixel_coord, CameraOrientationInWorld(), CameraPositionInWorld(), rayVector);\n\t\n\tfragColor = RayMarch(world_coord, rayVector);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldS3zm","date":"1385231461","viewed":147,"name":"First 3d shader","username":"kp1197","description":"first beginner's 3d shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""}}