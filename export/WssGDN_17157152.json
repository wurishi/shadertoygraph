{"ver":"0.1","info":{"id":"WssGDN","date":"1546327426","viewed":1264,"name":"Helix Nebula (NGC 7293)","username":"WB","description":"Helix nebula (NGC 7293). It's not perfect but its fairly close for just some approximate math, noise, and my limited patience. The Helix Nebula is a planetary nebula in the constellation Aquarius and one of the closest to Earth. Mouse rotates and zooms.","likes":45,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","volumetric","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 128\n#define STEP_SIZE 0.025\n#define _FoV 55.0\n\n#define JITTER\n\n//#define ROTATE\n\nconst vec3 _StarColor = vec3(0.7,0.8,1.0);\nconst float _Absorption = 0.1;\nconst float _Scattering = 0.5;\nconst float _Density = 4.0;\nconst float _Radius = 1.0;\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\nvec3 rotateZ(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, -sinTheta, 0.0,\n                    sinTheta, cosTheta, 0.0,\n                    0.0, 0.0, 1.0);\n    \n    return rot * p;\n}\n\n//iq's lut based value noise\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    float result = mix( rg.x, rg.y, f.z );\n    result = (2.0 * result) - 1.0;\n\treturn result;\n}\n\n//Brownian pink noise\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    pos.z *= 0.9; //Prolate spheroid\n    //pos += noise(pos * 12.0) * 0.05;\n    return length(center-pos) - radius;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    float d = sdSphere(pos, vec3(0.0), 0.5);\n    float sphere = max(0.0, 0.3 - abs(d));\n    \n    float ring = max(0.0, (0.4-abs(pos.z)));\n    \n    if (ring <= 0.0 && sphere <= 0.0)\n        return 0.0;\n    \n    ring *= max(0.2,fbm(40.0+pos, 12, 4.0, 0.75)) * 6.0;\n    float r = length(pos);\n    ring *= 1.0-smoothstep(0.5,0.2,r);\n    vec3 n = normalize(-pos);\n    ring *= smoothstep(0.1,1.0,(0.5 + abs(noise(n)*0.1))/r);\n    float n2 = abs(fbm(100.0+pos, 3, 2.0, 2.0) * 10.0)*pow(r,32.0);\n    ring = max(0.0, ring - n2 /max(0.01,abs(pos.x)));\n    ring *= abs(pos.x * pos.x) - abs(pos.y) * 0.2 + 0.5;\n        \n    float result = sphere + ring;\n    return result * _Density;\n}\n\nfloat sampleProplyds(vec3 pos)\n{\n    float result = smoothstep(0.99,0.999,abs(fbm(20.0+pos, 2, 24.0, 2.0)));\n    float d = abs(sdSphere(pos, vec3(0.0), 0.4));\n    result *= max(0.0,0.05-d) * 800.0;\n    result *= max(0.0, 0.3-abs(pos.z));\n    return result;\n}\n\n//Raymarching loop\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);       \n        float r = length(pos);\n        vec3 em = mix(vec3(0.0, 0.25, 1.0), vec3(0.9, 1.0, 0.1), r/_Radius-0.075);\n        float ext = max(0.000001, (_Absorption + _Scattering) * p);\n        float trans = exp(-ext * ds);\n        em.r += pow(r, 6.0) * 4.0;\n        \n        vec3 lum = em * p;\n        vec3 integral = (lum - (lum * trans))/ext;\n        \n        result.rgb += integral * result.a;\n        result.a *= trans;\n        \n        float p2 = sampleProplyds(pos);\n        result.rgb -= p2 * ds;\n        result.a *= exp(-p2*ds);\n        \n        if (result.a <= 0.01)\n            return result;\n        \n\n        pos += dir * ds;\n    }\n        \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));\n    vec2 nuv = (-1.0 + 2.0 * uv) * vec2(ar, 1.0);\n    vec3 rayDir = normalize(vec3(nuv, d));\n    \n    #ifdef ROTATE\n    float t = iMouse.x * 0.01 + iTime * 0.2;\n\t#else\n    float t = iMouse.x * 0.01;\n    #endif\n    \n    rayDir = rotateY(rayDir, t);\n    rayOrigin = rotateY(rayOrigin, t);\n    \n    float zRot = radians(40.0);\n    rayDir = rotateZ(rayDir, zRot);\n    rayOrigin = rotateZ(rayOrigin, zRot);\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    \n    //Background\n    float starfield = fbm(rayDir, 2, 200.0, 1.0);\n    starfield = smoothstep(0.7,1.45,starfield);\n    col.rgb += starfield * starfield * mix(vec3(1.0,0.8,0.2),vec3(0.0,0.5,1.0),starfield*starfield);\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n        \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n        \n        //Central star\n    \tfloat star = 0.0001/dot(nuv, nuv);\n        star *= 2.0/dot(rayOrigin, rayOrigin);\n    \tcol.rgb += (1.0-exp(-star)) *  _StarColor;\n    }\t\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}