{"ver":"0.1","info":{"id":"cddXRN","date":"1680179747","viewed":84,"name":"Neon Drive","username":"Gruppe03","description":"Ray Marching","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to draw the grid\n// See: https://www.shadertoy.com/view/Wt33Wf\nfloat grid(vec2 uv, float battery, float x, float y)\n{\n    vec2 size = vec2(0.1);\n    uv.x *= .75;\n    uv.y *= .0;\n    uv += vec2(0., iTime * .0 * battery);\n    uv = abs(fract(uv) - 0.01);\n \tvec2 lines = smoothstep(size, vec2(0., 0), uv);\n \tlines += smoothstep(size * .1, vec2(0), uv) * 1. * battery;\n    return clamp(lines.x * 1. + lines.y * 0.1, 0.0, 1.);\n}\n\n\n// Begin PALM TREE FUNCTIONS\nSurface opLeafUpper(vec3 p){\n  p *= rotateY(PI*0.75);\n  p.xz = abs(p.xz);\n  return sdRhombus(p, .1, .5, 0.001, 0.2, vec3(0.5, 6.2, 0.3), PALM_COLOR, rotateY(PI*0.75) * rotateX(PI*-0.05));\n}\n\nSurface opLeafMiddle(vec3 p){\n  p.xz = abs(p.xz);\n  return sdRhombus(p, .5, 2.0, 0.01, 0.2, vec3(1, 5.7, 1), PALM_COLOR, rotateY(PI*0.75) * rotateX(PI*0.1));\n}\n\nSurface opLeafBottom(vec3 p){\n  p *= rotateY(PI*0.75);\n  p.xz = abs(p.xz);\n  return sdRhombus(p, .5, 2.0, 0.01, 0.2, vec3(1, 5.4, 1), PALM_COLOR, rotateY(PI*0.75) * rotateX(PI*0.13));\n}\n\nSurface sdPalmTree(vec3 p, vec3 m){\n\n    if(p.x == 0.){\n        return Surface(1000000., vec3(1));\n    }\n\n    if(distance(vec3(0, 0, 0), p) > 10.){\n        return Surface(1000000., vec3(1));\n    }\n    \n    if(sdRoundedCylinder(p, 1.7, 0., 1., vec3(0,3.25,0), vec3(0), identity()).sd >= 3.){\n        return Surface(1000000., vec3(1));\n    }\n    \n    p *= rotateY(PI*0.5);\n    \n\n    Surface trunk = sdRoundedCylinder(p, .1, .5, 6., m, PALM_COLOR, rotateZ(PI* 0.));\n    Surface co = trunk;\n    \n    // Upper Layer\n    Surface leaf_upper = opLeafUpper(p);\n    co = minWithColor(co, leaf_upper);\n    \n    \n    // Middle Layer\n    Surface leaf_middle = opLeafMiddle(p);\n    co = minWithColor(co, leaf_middle);\n    \n    // Bottom Layer\n    Surface leaf_bottom = opLeafBottom(p);\n    co = minWithColor(co, leaf_bottom);\n    return co;\n}\n\nSurface opRepLimPalmTree( in vec3 p, in vec3 c, in vec3 l){\n    vec3 q = vec3(p.x-c.x*clamp(round(p.x/c.x),-l.x,l.x),\n                p.y-c.y*clamp(round(p.y/c.y),-l.y,l.y),\n                p.z-c.z*clamp(round(p.z/c.z),-l.z,l.z));\n    return sdPalmTree(q,vec3(0));\n}\n// End PALM TREE FUNCTIONS\n\n// SAND DUNE FUNCTION\nSurface sdSandDune(vec3 p, vec3 m, mat3 transform){\n    \n    vec3 uv = (p-m) * transform;\n    \n    uv.y += cos(uv.z*1.2)*0.1;\n    uv.y -= sin(uv.x*1.2)*0.1;\n    \n    vec3 q = abs(uv) - vec3(10.25,.3,26);\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    \n    Surface desertDune = Surface(d, mix(vec3(0.01, 0.0, 0.1), vec3(1.0, 0.2, 1.0), grid(p.xz, 2.0, .2, .2)));\n    \n    return desertDune;\n}\n\n// Begin LAMP POST FUNCTIONS\nSurface sdLampPost(vec3 p, vec3 m, float direction){\n    Surface postUp = sdRoundedCylinder(p, .04, .0, 3., m, PALM_COLOR, identity());\n    Surface co = postUp;\n    \n    Surface postForward = sdRoundedCylinder(p, .02, 1., .75, m+vec3(0.75*direction,3.0, 0), PALM_COLOR, rotateZ(PI*0.5));\n    co = minWithColor(co, postForward);\n    \n    \n    Surface lightBulb = sdBox(p, vec3(.5,.01,.2), m+vec3(1.5*direction,2.97, 0), PALM_COLOR, identity());\n    co = minWithColor(co, lightBulb);\n     \n    return co;\n}\n\nSurface opRepLimLampPost( in vec3 p, in vec3 c, in vec3 l, in float direction){\n    vec3 q = vec3(p.x-c.x*clamp(round(p.x/c.x),-l.x,l.x),\n                p.y-c.y*clamp(round(p.y/c.y),-l.y,l.y),\n                p.z-c.z*clamp(round(p.z/c.z),-l.z,l.z));\n    return sdLampPost(q,vec3(0), direction);\n}\n// End LAMP POST FUNCTIONS\n\n// Begin BIOMES FUNCTIONS\nSurface sdDesertBiome(vec3 p, vec3 m){\n    vec3 GRID_COLOR = mix(vec3(0.01, 0.0, 0.1), vec3(1.0, 0.2, 1.0), grid(p.xz, 2.0, 0.2, 0.2));\n\n    Surface street = sdBox(p, vec3(4.5,.2,26), m, GRID_COLOR, identity());\n    Surface co = street;\n    \n    Surface curb_left = sdBox(p, vec3(.1,.7,26), m+vec3(4.7, 0, 0), GRID_COLOR, identity());\n    co = minWithColor(co, curb_left);\n    \n    Surface curb_right = sdBox(p, vec3(.1,.7,26), m-vec3(4.7, 0, 0), GRID_COLOR, identity());\n    co = minWithColor(co, curb_right);\n    \n    Surface palms = opRepLimPalmTree(p-m-vec3(7.5, 0, 0), vec3(15, 0, 52/3), vec3(2., 0., 1.));\n    co = minWithColor(co, palms);\n    \n    Surface dune_right = sdSandDune(p, m-vec3(15.75, 0, 0), identity());\n    co = minWithColor(co, dune_right);\n    \n    Surface dune_left = sdSandDune(p, m-vec3(-15.75, 0, 0), identity());\n    co = minWithColor(co, dune_left);\n    \n    Surface lampPostRigth = opRepLimLampPost(p-m-vec3(-4.5, 3, 0), vec3(0, 0, 17.333), vec3(0., 0., 1.), 1.);\n    co = minWithColor(co, lampPostRigth);\n    \n    Surface lampPostLeft = opRepLimLampPost(p-m-vec3(4.5, 3, 0), vec3(0, 0, 17.333), vec3(0., 0., 1.), -1.);\n    co = minWithColor(co, lampPostLeft);\n    \n    \n    return co;\n}\n\nSurface sdTunnelBiome(vec3 p, vec3 m){\n    vec3 GRID_COLOR = mix(vec3(0.01, 0.0, 0.1), vec3(1.0, 0.2, 1.0), grid(p.xz, 2.0, 0.2, 0.2));\n\n    Surface groundPlane = sdBox(p, vec3(26,.1,26), m, GRID_COLOR, identity());\n    Surface co = groundPlane;\n    \n    Surface street = sdBox(p, vec3(4.5,.2,26), m, GRID_COLOR, identity());\n    co = minWithColor(co, street);\n    \n    Surface curb_left = sdBox(p, vec3(.1,.7,26), m+vec3(4.7, 0, 0), GRID_COLOR, identity());\n    co = minWithColor(co, curb_left);\n    \n    Surface curb_right = sdBox(p, vec3(.1,.7,26), m-vec3(4.7, 0, 0), GRID_COLOR, identity());\n    co = minWithColor(co, curb_right);\n    \n    Surface tunnel_wall_right_bottom = sdBox(p, vec3(3.,2.,26.), m+vec3(-8.3, .0, 0), GRID_COLOR, rotateZ(PI*-0.25));\n    co = minWithColor(co, tunnel_wall_right_bottom);\n   \n    \n    Surface tunnel_wall_right_top = sdBox(p, vec3(.1,2.,20.), m+vec3(-6.15, 4.8, 0), GRID_COLOR, rotateZ(PI*0.25));\n    co = minWithColor(co, tunnel_wall_right_top);\n    \n    Surface tunnel_wall_left_bottom = sdBox(p, vec3(3.,2.,26.), m+vec3(8.3, .0, 0), GRID_COLOR, rotateZ(PI*0.25));\n    co = minWithColor(co, tunnel_wall_left_bottom);\n    \n    Surface tunnel_wall_left_top = sdBox(p, vec3(.1,2.,20.), m+vec3(6.15, 4.8, 0), GRID_COLOR, rotateZ(PI*-0.25));\n    co = minWithColor(co, tunnel_wall_left_top);\n    \n    \n    Surface tunnel_wall_ceil = sdBox(p, vec3(.1,4.9,20.), m+vec3(0, 6.16, 0), GRID_COLOR, rotateZ(PI*0.5));\n    co = minWithColor(co, tunnel_wall_ceil);\n    \n    Surface pyramid = sdPyramid(p,.8, m-vec3(0, -9.-sin(iTime)*1.5, 0), GRID_COLOR, rotateY(iTime));\n    co = minWithColor(co, pyramid);\n    \n    return co;\n}\n// Begin BIOMES FUNCTIONS\n\n// CAR FUNCTION\nSurface sdCar(vec3 p, vec3 m) {\n\n    p = (p-m);\n    // Reifen\n    float tyre_rotation = texture(iChannel0, vec2(0)).x;\n    float forwards = texture(iChannel0, vec2(0)).z;\n    \n    Surface tyre_back_right = sdRoundedCylinder(p+vec3(1., 0.4, 1.), .2, .1, .1, vec3(0),TYRE_COLOR, rotateZ(PI*0.5));\n    Surface co = tyre_back_right;\n    Surface tyre_back_left = sdRoundedCylinder(p+vec3(-1, 0.4, 1.), .2, .1, .1, vec3(0),TYRE_COLOR, rotateZ(PI*0.5));\n    co = minWithColor(co, tyre_back_left);\n    Surface tyre_front_left = sdRoundedCylinder(p+vec3(-1, 0.4, -1.), .2, .1, .1, vec3(0),TYRE_COLOR, rotateZ(PI*0.5));\n    co = minWithColor(co, tyre_front_left);\n    Surface tyre_front_right = sdRoundedCylinder(p+vec3(1, 0.4, -1.), .2, .1, .1, vec3(0),TYRE_COLOR, rotateZ(PI*0.5));\n    co = minWithColor(co, tyre_front_right);\n    \n    \n    p *= rotateY(PI);\n    vec3 col = vec3(0.02);\n    // Fahrzeug hinten oben\n    if(p.z > .4 && p.y > 0.2) {\n    p.y += (p.z-0.4) * 0.2;\n    col = vec3(.02);\n        // Rennstreifen\n        if(p.x < 0.5 && p.x > 0.4) {\n        col = vec3(1,0,1);\n        }\n\n        if(p.x < -0.4 && p.x > -0.5) {\n        col = vec3(1,0,1);\n        }\n    }\n    // Fahrzeug hinten unten\n    if(p.z > 1.7 && p.y < 0.) {\n    p.y += cos(p.z-0.1)*0.6;\n    col = vec3(.02);\n        // Rennstreifen\n        //if(p.x < 0.5 && p.x > 0.4) {\n        //col = vec3(1, 0, 1);\n        //}\n\n        //if(p.x < -0.4 && p.x > -0.5) {\n        //col = vec3(1, 0, 1);\n        //}\n    }\n    // Fahrzeug vorne oben entfernt\n    if(p.z < -1.1 && p.y > 0.1) {\n        p.y += 0.401;\n        col = vec3(0);\n    }\n    // Fahrzeug Windschutzscheibe\n    if(p.z < -.5 && p.z > -1.1 && p.y > 0.1) {\n        p.y -= (p.z+0.5) * 0.8;\n        col = vec3(.03);\n    }\n    // Fahrzeug Motorhaube oben\n    if(p.z < -1.1 && p.y > -.2 && p.y < 0.1) {\n        p.y -= cos(p.z-0.4)*0.9;\n        col = vec3(.02);\n    }\n    // Fahrzeug Motorhaube unten\n    if(p.z < -1.5 && p.y > -.5 && p.y < -.2) {\n        p.y += cos(p.z-0.1)*0.4;\n        col = vec3(.02);\n    }\n    \n    \n    // Fahrzeug kompletter Körper\n    vec3 q = abs(p) - vec3(1, .5, 2);\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    Surface carBody = Surface(d, col);  \n    co = minWithColor(co, carBody);\n    return co;\n}\n\n// SCENE FUNCTION\nSurface scene(vec3 p) {\n    Surface co = sdCar(p,  texture(iChannel0, vec2(0.0, 0.0)).xyz);\n  \n    Surface desert = sdDesertBiome(p, texture(iChannel1, vec2(0.0, 0.0)).xyz);\n    co = minWithColor(co,desert);\n\n    Surface tunnel = sdTunnelBiome(p, texture(iChannel2, vec2(0.0, 0.0)).xyz);\n    co = minWithColor(co, tunnel);\n    \n    return co;\n}\n\n\n// BASIC RAYMARCHING FUNCTIONS\n// See: https://inspirnathan.com/posts/47-shadertoy-tutorial-part-1/\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n// LIGHT FUNCTION\nvec3 calcLight(vec3 p, vec3 normal, vec3 col){\n    \n    // Lights have to be hardcoded!\n    vec3 m_sand_biome = texture(iChannel1, vec2(0.0, 0.0)).xyz;\n    vec3 m_tunel_biome = texture(iChannel2, vec2(0.0, 0.0)).xyz;\n    vec3 m_car = texture(iChannel0, vec2(0)).xyz;\n    \n    Light lights[11] = Light[11](\n        // Sand Biome\n        Light(m_sand_biome+vec3(4, 3., -17.333)+vec3(-1., 2.75, 0), vec3(1, 1, 0), 2.),\n        Light(m_sand_biome+vec3(-4, 3., -17.333)+vec3(1., 2.75, 0), vec3(1, 1, 0), 2.),\n        Light(m_sand_biome+vec3(4, 3., 0)+vec3(-1., 2.75, 0), vec3(1,1, 0), 2.),\n        Light(m_sand_biome+vec3(-4, 3., 0)+vec3(1., 2.75, 0), vec3(1,1, 0), 2.),\n        Light(m_sand_biome+vec3(4, 3., 17.333)+vec3(-1., 2.75, 0), vec3(1,1, 0), 2.),\n        Light(m_sand_biome+vec3(-4, 3., 17.333)+vec3(1., 2.75, 0), vec3(1,1, 0), 2.),\n        // Tunel Biome\n        Light(m_tunel_biome+vec3(0, 2.8, 18), vec3(1,0,1), 2.),\n        Light(m_tunel_biome+vec3(0, 2.8, 0), vec3(1,0,1), 2.),\n        Light(m_tunel_biome+vec3(0, 2.8, -18), vec3(1,0,1), 2.),\n        // Car Lights\n        Light(m_car+vec3(-0.7, 0.1, -2.3), vec3(1,0,0), 3.),\n        Light(m_car+vec3(0.7, 0.1, -2.3), vec3(1,0,0), 3.)\n    );\n    \n    vec3 finalColor = col;\n    \n    float totalDif = 0.;\n    \n    // Iterate through each light and calculate their weighted proportion on the surface\n    for(int i = 0; i < lights.length(); i++){\n        vec3 lp = lights[i].o;\n        if(distance(vec3(0), lp) > 50.){\n            continue;\n        }\n        vec3 ld = normalize(lights[i].o-p);\n        vec3 lc = lights[i].c;\n        float li = lights[i].i;\n        \n        float dif = clamp(dot(normal, ld), 0., 1.) + 0.5;\n        totalDif = max(dif, totalDif);\n        float softShadow = clamp(softShadow(p, ld, 0.02, 2.5), 0.0, 1.0);\n        \n        finalColor += (0.2+(1./distance(p, lp)))*dif*li*mix(finalColor, lc, 0.5) * softShadow * (1./float(lights.length()));\n        \n    }\n    \n    return finalColor*totalDif;\n    \n    \n}\n\n// BEGIN POSTPROCESSING\n// See: https://www.shadertoy.com/view/lsVSRt\nvec4 rgbShift( in vec2 p , in vec4 shift, in vec3 col) {\n    shift *= 1.02*shift.w - 1.;\n    vec2 rs = vec2(shift.x,-shift.y);\n    vec2 gs = vec2(shift.y,-shift.z);\n    vec2 bs = vec2(shift.z,-shift.x);\n    \n    float r = col.x;\n    float g = col.y;\n    float b = col.z;\n    \n    return vec4(r,g,b,1.0);\n}\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n// END POSTPROCESSING\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = mix(vec3(1.4, 0., 1.),vec3(0.01, 0.0, 0.1),  (fragCoord.xy / iResolution.xy).y * .9);\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0, 1, 0.); // lookat point (aka camera target)\n  vec3 ro = CAMERA_ORIGIN; // ray origin that represents camera position\n  \n  float cameraRadius = 1.;\n  \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    float fresnel = pow(clamp(1. - dot(normal, -rd), 0., 1.), 20.);\n    vec3 rimColor = vec3(1, 0, 1);\n\n\n    col = calcLight(p, normal, co.col);\n\n    col += fresnel * rimColor;\n  }\n\n  col = mix(col, backgroundColor, 1.0 - exp(-0.000015 * co.sd * co.sd * co.sd)); // fog\n  \n  // Apply ScreenLines\n  // See: https://www.shadertoy.com/view/lsVSRt\n  vec3 oldScreenLines = vec3(sin(uv.y*NUMBER_LINES+sin(iTime)*4.));\n    \n  col = mix(rgbShift(uv, vec4(0.015, 0.0, 0.015, 0.0), col).xyz, oldScreenLines, 0.01);\n  col -= .028*rand(uv.xy * iTime);\n  fragColor = vec4(col*1.1, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Mapped den Wert der gedrückten Taste auf die Werte aller Tasten (0-256)\n// 0 wenn Taste nicht gedrückt wird; 1 wenn Taste gedrückt wird\n#define GET_KEY(k) (texture(iChannel0, vec2(float(k) / 256.0, 0.1) ).x)\n\n// Bewegungsgeschwindigkeit des Objekts\n#define MOVE_SPEED 4.\n\n// Tasten Zahlencodes\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Startposition des Objekts\n    if (iFrame < 1) {\n      fragColor = vec4(0,0,0, 0);\n    }\n    else {\n      // Vorherige Position laden\n      vec3 objPos = texture(iChannel1, vec2(0.0, 0.0)).xyz;\n      \n      // Bewegung des Objektes\n      float key_left = GET_KEY(KEY_LEFT);\n      float key_right = GET_KEY(KEY_RIGHT);\n      float key_up = GET_KEY(KEY_UP);\n      float key_down = GET_KEY(KEY_DOWN);\n      \n      objPos += vec3(1, 0, 0) * key_left * iTimeDelta * MOVE_SPEED;\n      objPos -= vec3(1, 0, 0) * key_right * iTimeDelta * MOVE_SPEED;\n      objPos += vec3(0, 0, 1) * key_up * iTimeDelta * MOVE_SPEED;\n      objPos -= vec3(0, 0, 1) * key_down * iTimeDelta * MOVE_SPEED;\n\n      objPos.x = clamp(objPos.x, -3., 3.);\n      fragColor = vec4(objPos, 0);\n    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float a = 1.;\nconst float c = 0.;\nconst float m = 2.;\n\n\nfloat rand(float x) {return mod((a*x + c),m);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(0);\n    float t = 1.;\n    if(iFrame < 1) {\n        pos = vec3(0, -1, 23);\n        fragColor = vec4(pos, t);\n    }\n    else {\n        pos = texture(iChannel0, vec2(0.0, 0.0)).xyz;\n        if(pos.z < -29.) {\n            pos.z = 75.;\n            t = floor(rand(iTime));\n        }\n        pos.z -= 2. * iTimeDelta;\n        fragColor = vec4(pos,t);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nconst float a = 71.;\nconst float c = 97.;\nconst float m = 119.;\n\n\n//float rand(float x) { return mod((a*x + c),m);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(0);\n    \n    float t = 1.;\n    \n    if(iFrame < 1) {\n        pos = vec3(0, -1, 75);\n        fragColor = vec4(pos, t);\n    }\n    else {\n        pos = texture(iChannel0, vec2(0.0, 0.0)).xyz;\n        if(pos.z < -29.) {\n            pos.z = 75.;\n            t = floor(rand(exp(iTime)));\n        }\n        pos.z -= 2. * iTimeDelta;\n        fragColor = vec4(pos,t);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Begin CONSTANTS\nconst int MAX_MARCHING_STEPS = 75;\nconst float NUMBER_LINES = 300.;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 75.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\n\nconst vec3 CAMERA_ORIGIN = vec3(0, 2, -6.5);\n// End CONSTANTS\n\n\n// STRUCTS\nstruct Light{\n    vec3 o; // origin\n    vec3 c; // color\n    float i; // intensity \n};\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n// End STRUCTS\n\n\n// Begin COLORS\nconst vec3 PLANE_COLOR = vec3(0.2, 0.0, 0.5);\nconst vec3 STREET_COLOR = vec3(0.6, 0.6, 0.6);\nconst vec3 TYRE_COLOR = vec3(0.1, 0.1, 0.1);\nconst vec3 DESERT_COLOR = vec3(0.945, 0.745, 0.424);\nconst vec3 PALM_COLOR = vec3(0.01, 0.0, 0.1);\nconst vec3 LEAF_COLOR = vec3(1, 0, 1);\n// End COLORS\n\n// Begin HELPERS\n// See: https://iquilezles.org/articles/distfunctions/\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n// End HELPERS\n\n// Begin SDF\n// See: https://iquilezles.org/articles/distfunctions/\n\n// Return the closest Surface and its color\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd <= obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface opSmoothUnion( Surface s1, Surface s2, float k ) {\n    float h = clamp( 0.5 + 0.5*(s2.sd-s1.sd)/k, 0.0, 1.0 );\n    return Surface(mix( s2.sd, s1.sd, h ) - k*h*(1.0-h), minWithColor(s1, s2).col); \n}\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform){\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdPyramid( vec3 p, float h, vec3 offset, vec3 col, mat3 transform){\n    \n  p = (p-offset)*transform;\n  \n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 5.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return Surface(sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y)), col);\n}\n\nSurface sdRoundedCylinder(vec3 p, float ra, float rb, float h,vec3 offset, vec3 col, mat3 transform){\n    p = (p - offset) * transform;\n    vec2 q = vec2(length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    float d = min(max(q.x,q.y),0.0) + length(max(q,0.0)) - rb;\n    return Surface(d, col);\n}\n\nSurface sdRhombus(vec3 p, float la, float lb, float h, float ra, vec3 offset, vec3 col, mat3 transform){\n  p = abs((p-offset) * transform);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return Surface(min(max(q.x,q.y),0.0) + length(max(q,0.0)), col);\n}\n// End SDF","name":"Common","description":"","type":"common"}]}