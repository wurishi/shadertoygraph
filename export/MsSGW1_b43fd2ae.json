{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define lowdef //comment out for more magic\n\n#ifdef lowdef\nconst float MAXDIST = 30.0;\nconst float EPSILON = 0.01;\nconst int   MAXITER = 25;\n#else\nconst float MAXDIST = 100.0;\nconst float EPSILON = 0.001;\nconst int   MAXITER = 150;\n#endif\n\nstruct RayResult {\n\tvec3 pos;\n\tvec3 normal;\n\tfloat dist;\n\tfloat mindist;\n\tfloat totaldist;\n};\n\nfloat defRepeat(float p, float s){\n\treturn mod(p,s)-s*0.5;\t\n}\n\nvec3 rotX(vec3 p, float a){\n\tmat4 m = mat4(\n\t\t1.0,0.0,0.0,0.0,\n\t\t0.0,cos(a),sin(a),0.0,\n\t\t0.0,-sin(a),cos(a),0.0,\n\t\t0.0,0.0,0.0,1.0);\n\treturn (m*vec4(p,1.0)).xyz;\n}\n\nvec3 rotZ(vec3 p, float a){\n\tmat4 m = mat4(\n\t\tcos(a),sin(a),0.0,0.0,\n\t\t-sin(a),cos(a),0.0,0.0,\n\t\t0.0,0.0,1.0,0.0,\n\t\t0.0,0.0,0.0,1.0);\n\treturn (m*vec4(p,1.0)).xyz;\n}\n\nfloat cylinderX(vec3 p, float radius){\n\treturn length(p.zy)-radius;\n}\n\nfloat box(vec3 p, vec3 size){\n\treturn length(max(abs(p)-size,0.0));\n}\n\nfloat boxZ(vec3 p, vec2 size){\n\treturn length(max(abs(p.xy)-size,0.0));\n}\n\nfloat rbox(vec3 p, vec3 size, float r){\n\treturn length(max(abs(p)-size,0.0))-r;\n}\n\n// column in each X Y Z directions, repeated infinitely\nfloat mesh(vec3 p, float size, float thick){\n\tp = mod(p,size)-size*0.5;\n\tfloat x = length(max(abs(p.yz)-vec2(size*thick),0.0));\n\tfloat y = length(max(abs(p.xz)-vec2(size*thick),0.0));\n\tfloat z = length(max(abs(p.xy)-vec2(size*thick),0.0));\n\treturn min(x,min(y,z))-thick*0.1;\n}\n\n\nfloat sceneDist(vec3 p){\n    // rotate around Z, axis to put that wiggle in it\n\tp = rotZ(p,0.4*sin(p.z*0.4+iTime)+iTime);\n\t\n\tfloat v1 = mesh(p,0.35,0.1);\n\t\n\tfloat b1 = boxZ(p,vec2(1.0,1.0));\n\t\n\treturn max(b1,v1);\n}\n\nvec3 getNormal(vec3 pos){\n\tvec2 eps = vec2(0.0, EPSILON);\n\treturn normalize(vec3(\n\t\t\tsceneDist(pos + eps.yxx) - sceneDist(pos - eps.yxx),\n\t\t\tsceneDist(pos + eps.xyx) - sceneDist(pos - eps.xyx),\n\t\t\tsceneDist(pos + eps.xxy) - sceneDist(pos - eps.xxy)));\n}\n\nRayResult castRay(vec3 rPos, vec3 rDir){\n\tRayResult result;\n\tresult.dist=MAXDIST;\n\tresult.mindist=MAXDIST;\n\tresult.totaldist=0.0;\n\t\n\tfor (int i = 0; i < MAXITER; i++)\n\t{\n\t\t\n\t\tif (result.dist < result.mindist) { result.mindist = result.dist;}\n\t\tif (result.dist < EPSILON || result.dist > MAXDIST) {continue;}\n\t\t\n\t\tresult.dist = sceneDist(rPos); // Evalulate the distance at the current point\n\t\tresult.totaldist += result.dist;\n\t\trPos += result.dist * rDir; // Advance the point forwards in the ray direction by the distance\n\t}\n\tresult.pos = rPos;\n\tresult.normal = getNormal(result.pos);\n\treturn result;\n}\n\n\nvec3 getC(float x, float k){\n\tfloat y=clamp(1.0-x,0.0,1.0);\n\tx = clamp(x,0.0,1.0);\n\ty *= k;\n\treturn vec3(exp(-y*0.1)+0.2,\n\t\t\t\texp(-y*0.3),\n\t\t\t\texp(-y*0.7)\n\t\t\t   )*(1.0-exp(-x*k));\n}\n\nfloat ss(float x){\n\treturn 0.5+0.5*sin(x);\n}\n\n#define mBpm 147.75 // useless really\nconst float sBeat = 1.0/(mBpm / 60.0);\n#define mStart 9.75\nvec3 getCamPos(){\n\tvec3 p;\n\tfloat t = iChannelTime[0];\n\tif(t<mStart){\n\t\tp = vec3(-2.0,0.0,0.0);\n\t}\n\telse if(t<mStart+sBeat*32.0){\n\t\tp = vec3(-4.0*sin(-t*0.3),-4.0*cos(-t*0.3),0.0);\t\n\t}\n\telse if(t<mStart+sBeat*64.0){\n\t\tp = vec3(0.0,0.0,t*0.2);\t\n\t}\t\n\telse if(t<mStart+sBeat*96.0){\n\t\tp = vec3(1.7,-3.0,-t*30.0);\t\n\t}\t\n\telse{\n\t\tp = vec3(1.7,-2.0,-t*15.0);\t\n\t}\n\t\n\treturn p;\n}\n\nvec3 getCamTarget(){\n\tvec3 p;\n\tfloat t = iChannelTime[0];\n\tif(t<mStart){\n\t\tp = vec3(0.0,0.0,0.0);\n\t}\n\telse if(t<mStart+sBeat*64.0){\n\t\tp = vec3(0.0,0.0,3.0);\t\n\t}else if(t<mStart+sBeat*96.0){\n\t\tp = vec3(0.0,0.0,-t*30.0-2.5*ss(t*0.7));\n\t}else{\n\t\tp = vec3(0.0,0.0,-t*15.0+3.0);\t\n\t}\n\t\n\treturn p;\t\n}\n\nvec3 renderWorld(vec2 uv){\n\t\n\tfloat t = iTime;\n\t\n\t\n\tvec3 camPos = getCamPos();\n\tvec3 camTarget = getCamTarget();\n\t\n\tvec3 camDir = normalize(camTarget-camPos);\n\tvec3 camRight = normalize(cross(camDir,vec3(0.0,1.0,0.0))); // right is normal to forward and up\n\tvec3 camUp = normalize(cross(camDir,camRight)); // up is normal to forward and right\n\t\n\t\n\tRayResult ray = castRay(camPos,normalize(camRight*uv.x + camUp*uv.y + camDir));\n\t\n\tvec3 c;\n\t\n\tif(ray.dist<EPSILON){\n\t\tfloat vDiffuse = max(0.0, dot(ray.normal,-camDir )   );\n\t\t\n\t\tc = getC(vDiffuse+0.4*pow(ss(ray.pos.z*0.5-iTime*6.0),5.0),\n\t\t\t\t 40.0);\n\t}else{\n\t\tc = getC(1.0-clamp(ray.mindist,0.0,.8),400.0);\t\n\t}\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5) //centre\n\t\t* vec2(2.0,2.0/(iResolution.x/iResolution.y)); //normalise x to [-1,1], y adjusts aspect\n\t\n\t\n\tvec3 c = renderWorld(uv);\n\t\n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSGW1","date":"1386931711","viewed":1268,"name":"Signalmesh","username":"squeakyneb","description":"Inspired by Farbrausch - 43 and TDA - Embers (now with prototype music-sync'd camera driving as part of my goal to build a full intro in shadertoy)","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""}}