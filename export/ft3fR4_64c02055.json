{"ver":"0.1","info":{"id":"ft3fR4","date":"1662763013","viewed":205,"name":"Sierpinski + Hilbert fractal","username":"DjinnKahn","description":"A hybrid of Sierpinski carpet + Hilbert curve. \n\nFabrice posted an image of this on https://www.facebook.com/groups/shadertoy so I made this shader for it.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["fractal","hilbert","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float A = -.3; // location on edge of unit square\nconst float PI = acos( -1. );\n\nfloat angle( vec2 p ) { return atan( p.x, -p.y ); }\n\nfloat sdCircle( float dist, float radius )\n{\n    return dist - radius;\n}\n\n// uv range for L_shape & I_shape: the square [-1,1]x[-1,1]\n\n// 1 +--------------+                   \n//   |         |    |   \n//   |         |    |   \n//   |        /     |\n//   |       /      |   \n//   |    _--       |   \n// A |----          |   \n//   |              |   \n//   |              |   \n//-1 +--------------+    \n//  -1        -A    1\n//                            \nvec2 L_shape( vec2 uv )\n{    \n    vec2 circleCenter = vec2( -1., 1. );\n    float sd = sdCircle( length( uv - circleCenter ), circleCenter.y - A );\n    float x = angle( uv - circleCenter ) / (.5 * PI);\n    return vec2( x, sd );\n}\n\n// 1 +--------------+                   \n//   |              |   \n//   |              |   \n//   |        ------| -A\n//   |       /      |   \n//   |      /       |   \n// A |------        |   \n//   |              |   \n//   |              |   \n//-1 +--------------+    \n//  -1              1\n//\nvec2 I_shape( vec2 uv, float a )\n{    \n    vec2 circleCenter = vec2( -1., .5*a - .5/a );\n    bool flip = dot( uv, vec2( circleCenter.y, -circleCenter.x ) ) > 0.;\n    if ( flip )\n        uv = -uv;\n    float x = angle( uv - circleCenter ) / (2. * angle( -circleCenter ));\n    if ( flip )\n        x = 1. - x;\n    \n    float d = distance( uv, circleCenter );\n    float sd = sdCircle( d, circleCenter.y - a );\n    if ( flip )\n        sd = -sd;\n    return vec2( x, sd );\n}\n\nvec2 draw3x3cell( vec2 uv, bool curveStart, bool curveEnd )\n{\n    float col = 0.;\n        \n    ivec2 cell = ivec2( round( uv * 1.5 ) );\n    vec2 cell_uv = uv * 3. - vec2( cell ) * 2.;\n        \n    bool flip = cell.y*3 >= cell.x;\n    if ( flip )\n    {\n        cell = -cell;\n        cell_uv = -cell_uv;\n    }\n    \n    vec2 ret = vec2( 0., 999. );\n    if ( cell.x == -1 && cell.y == -1 )\n    {\n        bool curve = flip ? curveEnd : curveStart;\n        ret = curve ? L_shape( vec2( cell_uv.y, cell_uv.x ) ) * vec2( 1., -1. ) : I_shape( cell_uv, A );\n    }\n    if ( cell.x == 0 && cell.y == -1 )\n        ret = I_shape( vec2( cell_uv.x, -cell_uv.y ), A ) * vec2( 1., -1. ) + vec2( 1., 0. );\n    if ( cell.x == 1 && cell.y == -1 )\n        ret = L_shape( cell_uv ) + vec2( 2., 0. );\n    if ( cell.x == 1 && cell.y == 0 )\n        ret = L_shape( vec2( cell_uv.y, -cell_uv.x ) ) + vec2( 3., 0. );\n    if ( cell.x == 0 && cell.y == 0 )\n        ret = I_shape( vec2( -cell_uv ), A ) + vec2( 4., 0. );\n    \n    if ( flip )\n        ret.x = 9. - ret.x;  \n    if ( flip )\n        ret.y = -ret.y;        \n    ret.x /= 9.;    \n    return ret;\n}\n\nvec2 draw9x9cell( vec2 uv, bool curveStart, bool curveEnd )\n{\n    float col = 0.;\n        \n    ivec2 cell = ivec2( round( uv * 1.5 ) );\n    vec2 cell_uv = uv * 3. - vec2( cell ) * 2.;\n        \n    bool flip = cell.y*3 >= cell.x;\n    if ( flip )\n    {\n        cell = -cell;\n        cell_uv = -cell_uv;\n    }    \n\n    bool cell_curveStart = false;\n    bool cell_curveEnd = false;\n    float distanceOffset = 0.;    \n    if ( cell.x == -1 && cell.y == -1 ) { cell_curveStart = flip ? curveEnd : curveStart; }\n    if ( cell.x == 0 && cell.y == -1 ) { cell_uv = vec2( -cell_uv.y, cell_uv.x ); cell_curveStart = true; cell_curveEnd = true; distanceOffset = 1.; }\n    if ( cell.x == 1 && cell.y == -1 ) { cell_curveEnd = true; distanceOffset = 2.; }\n    if ( cell.x == 1 && cell.y == 0 ) { cell_uv = vec2( cell_uv.y, -cell_uv.x ); cell_curveEnd = true; distanceOffset = 3.; }\n    \n    vec2 ret;\n    if ( cell.x == 0 && cell.y == 0 ) { \n        ret = I_shape( vec2( -cell_uv.x, -cell_uv.y ), (A+1.)/3. - 1. ) * vec2( 1., 3. ) + vec2( 4., 0. );\n    }\n    else\n    {\n        ret = draw3x3cell( cell_uv, cell_curveStart, cell_curveEnd );\n        ret.x += distanceOffset;\n    }\n    \n    ret.x /= 9.;  \n    if ( flip )\n        ret = vec2( 1., 0. ) - ret;\n    \n    return ret;\n}\n\n\nvec2 draw27x27cell( vec2 uv, bool curveStart, bool curveEnd )\n{\n    float col = 0.;\n        \n    ivec2 cell = ivec2( round( uv * 1.5 ) );\n    vec2 cell_uv = uv * 3. - vec2( cell ) * 2.;\n        \n    bool flip = cell.y*3 >= cell.x;\n    if ( flip )\n    {\n        cell = -cell;\n        cell_uv = -cell_uv;\n    }    \n\n    bool cell_curveStart = false;\n    bool cell_curveEnd = false;\n    float distanceOffset = 0.;    \n    if ( cell.x == -1 && cell.y == -1 ) { cell_curveStart = flip ? curveEnd : curveStart; }\n    if ( cell.x == 0 && cell.y == -1 ) { cell_uv = vec2( -cell_uv.y, cell_uv.x ); cell_curveStart = true; cell_curveEnd = true; distanceOffset = 1.; }\n    if ( cell.x == 1 && cell.y == -1 ) { cell_curveEnd = true; distanceOffset = 2.; }\n    if ( cell.x == 1 && cell.y == 0 ) { cell_uv = vec2( cell_uv.y, -cell_uv.x ); cell_curveEnd = true; distanceOffset = 3.; }\n    \n    vec2 ret;\n    if ( cell.x == 0 && cell.y == 0 ) { \n        ret = I_shape( vec2( -cell_uv.x, -cell_uv.y ), (A+1.)/9. - 1. ) * vec2( 1., 9. ) + vec2( 4., 0. );\n    }\n    else\n    {\n        ret = draw9x9cell( cell_uv, cell_curveStart, cell_curveEnd );\n        ret.x += distanceOffset;\n    }\n    \n    ret.x /= 9.;  \n    if ( flip )\n        ret = vec2( 1., 0. ) - ret;\n    \n    return ret;\n}\n\nvec2 draw81x81cell( vec2 uv, bool curveStart, bool curveEnd )\n{\n    float col = 0.;\n        \n    ivec2 cell = ivec2( round( uv * 1.5 ) );\n    vec2 cell_uv = uv * 3. - vec2( cell ) * 2.;\n        \n    bool flip = cell.y*3 >= cell.x;\n    if ( flip )\n    {\n        cell = -cell;\n        cell_uv = -cell_uv;\n    }    \n\n    bool cell_curveStart = false;\n    bool cell_curveEnd = false;\n    float distanceOffset = 0.;    \n    if ( cell.x == -1 && cell.y == -1 ) { cell_curveStart = flip ? curveEnd : curveStart; }\n    if ( cell.x == 0 && cell.y == -1 ) { cell_uv = vec2( -cell_uv.y, cell_uv.x ); cell_curveStart = true; cell_curveEnd = true; distanceOffset = 1.; }\n    if ( cell.x == 1 && cell.y == -1 ) { cell_curveEnd = true; distanceOffset = 2.; }\n    if ( cell.x == 1 && cell.y == 0 ) { cell_uv = vec2( cell_uv.y, -cell_uv.x ); cell_curveEnd = true; distanceOffset = 3.; }\n    \n    vec2 ret;\n    if ( cell.x == 0 && cell.y == 0 ) { \n        ret = I_shape( vec2( -cell_uv.x, -cell_uv.y ), (A+1.)/27. - 1. ) * vec2( 1., 27. ) + vec2( 4., 0. );\n    }\n    else\n    {\n        ret = draw27x27cell( cell_uv, cell_curveStart, cell_curveEnd );\n        ret.x += distanceOffset;\n    }\n    \n    ret.x /= 9.;  \n    if ( flip )\n        ret = vec2( 1., 0. ) - ret;\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    //uv = (uv + 1.) * .5;\n            \n    //vec2 sdResult = L_shape( uv );\n    //vec2 sdResult = draw3x3cell( uv, true, true );\n    //vec2 sdResult = draw9x9cell( uv, true, true );\n    //vec2 sdResult = draw27x27cell( uv, true, true );\n    vec2 sdResult = draw81x81cell( uv, true, true );\n        \n    // sdResult.x is the parametric position along the curve (between 0 and 1)\n    // sdResult.y is the offset from the center of the curve (e.g. 0 is the center of the curve, positive values are the \"right side\")\n    \n    float perturbX = (iTime - 3.) * .01;\n    //float center = mix( 0., .2, smoothstep( .011, .01, abs( sdResult.x - perturbX ) ) );\n    \n    //float center = smoothstep( perturbX-.01, perturbX-.02, sdResult.x ) * .5;\n    \n    float thickness = .2;\n    thickness = mix( .2, .4, smoothstep( .011, .01, abs( sdResult.x - perturbX ) ) );\n    \n    vec3 col = 1. - vec3( smoothstep( thickness+.4, thickness, abs( sdResult.y ) ) );\n    \n    //if ( iTime > 10. )\n    //    col = mix( col, vec3( 1. ), sin( sdResult.x * 10000. - iTime * 1. ) * .5 + .5 );\n        \n    //vec3 col0 = vec3( smoothstep( .5, .4, sdResult.y ) * smoothstep( .1, .2, sdResult.y ) );\n    //col0.g *= sin( sdResult.x * 10000. - iTime * 10. ) * .5 + .5;\n    //\n    //vec3 col1 = vec3( smoothstep( -.5, -.4, sdResult.y ) * smoothstep( -.1, -.2, sdResult.y ) );\n    //col1.g *= sin( sdResult.x * 10000. + iTime * 10. ) * .5 + .5;\n    \n    //vec3 col = col0 + col1;\n               \n    // Output to screen\n    fragColor = vec4( col, 1. );\n    \n    if ( length( floor( (uv + 1.)/2. ) ) != 0. )\n        fragColor = vec4(1.);\n}","name":"Image","description":"","type":"image"}]}