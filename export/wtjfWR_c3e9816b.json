{"ver":"0.1","info":{"id":"wtjfWR","date":"1598707595","viewed":164,"name":"shadow problem?","username":"jcyuan","description":"hi, I'm practing on casting shadow with raymarching but the result obviously has problem, i can't figure out why.\nanyone help? SDF and shadow theory are from IQ's site: https://iquilezles.org/articles/rmshadows/rmshadows.htm","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","practice","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.);\n    const int s = 4;\n    vec2 d = distance(uv, vec2(.5)) * fwidth(uv) + .0008;  // test blur (anti-alias)\n    \n    for(int i = -s; i <= s; i++) {\n        for(int j = -s; j <= s; j++) {\n            col += texture(iChannel0, uv + vec2(i, j) * d).xyz;\n        }\n    }\n    float iterCount = float(s * 2 + 1);\n    col /= iterCount * iterCount;\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926536\n#define HASHSCALE1 .1031\n\nfloat hash(float p) {\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox(vec3 p, vec3 b, float e) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nmat3 lookAt(in vec3 fw, in vec3 up) {\n\tfw = normalize(fw);\n\tvec3 rt = normalize(cross(fw, normalize(up)));\n\treturn mat3(rt, cross(rt, fw), fw);\n}\n\nmat3 rotateVec(in vec3 v, in float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat sdGeo(vec3 p) {\n    float d = -sdBox(p - vec3(0., 10., 0.), vec3(10.));\n    d = min(d, sdBox((p - vec3(-4., 3., 0.)), vec3(2.)));\n    d = min(d, sdSphere(p - vec3(-4., 7., 0.), 2.));\n    d = min(d, sdBoundingBox(p - vec3(0., 3., -1.), vec3(3., 2., 2.), .2));\n    d = min(d, sdHexPrism(rotateVec(vec3(0., 1., 0.), 1.) * (p - vec3(5.2, 3., 0.)), vec2(2., 1.)));\n\td = max(d, -p.z - 9.);\n\t\n\treturn d;\n}\n\nvec3 castRay(vec3 o, vec3 rd, vec2 limit) {\n    vec3 p = o + rd * limit.x;\n    float t = 0.;\n    for (int i = 0; i < 64; i++) {\n        float d = sdGeo(p);\n        t += d;\n        p += rd * d;\n        if (d < .001 || t > limit.y)\n            break;\n    }\n\n    return p;\n}\n\nvec3 calcNrm(vec3 p) {\n    vec3 eps = vec3(.001, .0, .0);\n\n\treturn normalize(vec3(\n\t\tsdGeo(p+eps.xyy) - sdGeo(p-eps.xyy),\n\t\tsdGeo(p+eps.yxy) - sdGeo(p-eps.yxy),\n\t\tsdGeo(p+eps.yyx) - sdGeo(p-eps.yyx)\n\t));\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow(in vec3 ro, in vec3 rd, float k) {\n    const float mint = .02;\n    const float maxt = 4.5;\n    float res = 1.;\n    float ph = 1e20;\n    for (float t = mint; t < maxt;) {\n        float h = sdGeo(ro + rd * t);\n        if(h < .001) return .0;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0., t - y));\n        ph = h;\n        t += h * .5;  // changed from 't += h' (more cost more accurate, but solves the problem)\n    }\n\n    return res;\n}\n\nvec3 rndSphDir(vec3 n, float l) {\n    float s = hash(l + 1.) * PI * 2.;\n\tfloat t = hash(l + 2.) * 2. - 1.;\n\tvec3 v = vec3(sin(s), cos(s), t) / sqrt(1. + t * t);\n    return v * sign(dot(v, n));\n}\n\n// http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat calcAo(vec3 p, vec3 n, float d, float f) {\n    const int nbIte = 32;\n    const float nbIteInv = 1. / float(nbIte);\n    const float rad = 1. - nbIteInv;\n    \n\tfloat ao = .0;\n    \n    for(int i = 0; i < nbIte; i++) {\n        float l = hash(float(i)) * d;\n        vec3 rd = normalize(n + rndSphDir(n, l) * rad) * l;\n        ao += (l - max(sdGeo(p + rd), 0.)) / d * f;\n    }\n\t\n    return clamp(1. - ao * nbIteInv, 0., 1.);\n}\n\nvec3 shade(vec3 o, vec3 pos, vec3 nrm, vec3 lo) {\n    vec3 d = normalize(lo - pos);\n    float NdL = clamp(dot(nrm, d), 0., 1.);\n    float shadow = calcSoftShadow(pos, lo, 12.);\n    float ao = calcAo(pos, nrm, 4., 2.);\n    \n    return vec3(shadow + ao); // test shadow\n}\n\nvec3 render(vec3 o, vec3 dir) {\n    vec3 p = castRay(o, dir, vec2(1., 30.));\n    vec3 nrm = calcNrm(p);\n    \n    vec3 col = shade(o, p, nrm, vec3(.3 + cos(iTime), 1.8, -.3 + sin(iTime)));\n    col = clamp(col, 0., 1.);\n\n    col = pow(col, vec3(.454545));\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    vec3 o = vec3(cos(iTime) * 2., 10. + cos(iTime), -11. + sin(iTime));\n    vec3 d = lookAt(vec3(0., 5., 0.) - o, vec3(0., 1., 0.)) * normalize(vec3(uv.x, uv.y, 2.));\n\n    fragColor = vec4(render(o, d), 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}