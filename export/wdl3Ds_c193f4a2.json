{"ver":"0.1","info":{"id":"wdl3Ds","date":"1547869165","viewed":435,"name":"Tri Noise 2D Heightmap","username":"Elyxian","description":"An experiment with raymarching a tri-noise 2d noise field with shadows and normal lighting.\nThe Tri Noise 2D function is from Nimitz here: https://www.shadertoy.com/view/XtGGRt\nUse the mouse to look around, and try to ignore the horrible aliasing","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tri"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// An experiment with raymarching a tri-noise 2d distance field.\n// Note that tri noise 2d (taken from nimitz's implementation) isn't designed\n// as a distance field, and thus marching it can have improper normals and is difficult to\n// march quickly without artifacts.\n\n// The Tri Noise 2D function is from Nimitz here: https://www.shadertoy.com/view/XtGGRt\n\n// The aliasing on this shader looks awful, but this is just meant to be an experiment\n\nfloat saturate(float t) {return clamp(t, 0.0, 1.0);}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\n// Tri Noise 2D by Nimitz: https://www.shadertoy.com/view/XtGGRt\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(iTime*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat distanceMap(vec3 p) {\n    \n    float height = 0.0;\n    height += triNoise2d(p.xz * 0.2, 1.0) * 1.0;\n    //height += triNoise2d(p.xz * 0.1, 1.0) * 0.5;\n    //height += triNoise2d(p.xz * 0.05, 1.0) * 0.25;\n    \n    float dist = p.y - height;\n    return 0.5 * dist; // Magic constant to try to make it a distance field\n    \n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n\t\n    // Parameters\n    int maxSteps = 200;\n    float maxDist = 100.0;\n    float surfaceDist = 0.005;\n    \n    // Main raymarching loop\n    float t = 0.0;\n    for (int i = 0; i < maxSteps; i++) {\n    \t\n        vec3 p = ro + t * rd;\n        float d = distanceMap(p);\n        \n        // A surface is found\n        if (d < surfaceDist * t) {\n        \treturn t;\n        }\n        \n        // The ray has travelled too far from the origin\n        if (t > maxDist) {\n        \treturn -1.0;\n        }\n        \n        t += d;\n    }\n    \n    // Too many steps were taken from the origin\n    return -1.0;\n\n}\n\nvec3 getNormal(vec3 p) {\n    \n    // Samples neighbouring points to generate a normal vector\n    vec2 eps = vec2(0.005, 0.00);\n    float dist = distanceMap(p);\n    vec3 normal = vec3(\n    \tdist - distanceMap(p - eps.xyy),\n\t\tdist - distanceMap(p - eps.yxy),\n\t\tdist - distanceMap(p - eps.yyx)\n    );\n    normal = normalize(normal);\n    return normal;\n    \n}\n\nvec3 getColor(vec3 p) {\n\t\n    // Directional light source\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n    \n    // The intensity/color of light (all three values are the same for white light)\n    vec3 lightCol = vec3(1.0);\n    \n    // Applies the 'base color' of the light\n    vec3 baseLightCol = vec3(1.0, 1.0, 1.0);\n    lightCol *= baseLightCol;\n    \n    // Applies normal-based lighting\n    vec3 normal = getNormal(p);\n    float normalLight = saturate(dot(normal, lightDir));\n    lightCol *= normalLight;\n    \n    // Applies hard-shadow lighting\n    float eps = 0.01;\n    bool isInShadow = (raymarch(p + normal * eps, lightDir) > 0.00);\n    if (isInShadow) {\n    \tlightCol *= 0.3;\n    }\n    \n    // Gets the diffuse lighting\n    vec3 diffuse = vec3(0.701, 0.572, 0.368);\n    \n    // Get the final color\n    vec3 col = lightCol * diffuse;\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\t\n    float t = raymarch(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (t >= 0.0) {\n    \tcol = getColor(ro + t * rd);\n    }\n    \n    else {\n        col = vec3(0.0, 0.8, 0.8);\n    }\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, 5.5, -3.0);\n    //vec3 ro = vec3(0.0, 10.5, -3.0); // Stationary camera\n    //vec3 ro = vec3(0.0, 10.5, -3.0) + smoothstep(0.0, 1.0, sin((iTime - 20.0) * 0.1) * 5.0) * vec3(0.0, -9.0, 0.0); // Moving camera\n    vec3 rd = normalize(vec3(p, 0.9));\n\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.0,-0.4):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Render and output the ray to screen\n    vec3 col = render(ro, rd);\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}