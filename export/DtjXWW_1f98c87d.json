{"ver":"0.1","info":{"id":"DtjXWW","date":"1676074521","viewed":132,"name":"3 different noise functions","username":"ianertson","description":"Red = 2D hash\nGreen = smooth 2D noise\nBlue = Layered smooth 2D noise\nBackground = Layered smooth 3D noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","random","hash","nosie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Red = 2D hash\n    Green = smooth 2D noise\n    Blue = Layered smooth 2D noise\n    Background = Layered smooth 3D noise\n    \n    -----------------------------------------------------\n    License: https://www.gnu.org/licenses/gpl-3.0.txt\n*/\n\n\n//////////////////////////////////////////////////////////////\n#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n\n// takes 1 number, returns 1 number.\nfloat hash11(float x) {\n  uint y = floatBitsToUint(x) >> 3u;\n  uint w = (~y) ^ (y >> 3u) & (~y >> 3u);\n  y ^= ((~(y << w)) ^ (y >> 3u) << (w ^ (y << w) >> 3u));\n  return float(y * 3948u) / float(0xFFFFFFFFU);\n}\n\n// takes 2 numbers, returns 1 number.\nfloat hash21(vec2 x) {\n  uvec2 y = uvec2(floatBitsToUint(hash11(x.x)), floatBitsToUint(hash11(x.y)));\n  uvec2 w = (~y) >> 3u;\n  return hash11(\n      float(\n          (98215u * ((((y.x << w.x) ^ (y.y << w.y)) << ((y.x ^ y.y) << 2812u)) +\n                     ((w.x >> y.y) << (y.x << w.y) & ~(y.x ^ y.y))))) /\n      float(0xFFFFFFFFU));\n}\n\n// takes 3 numbers, returns 1 number.\nfloat hash31(vec3 x) {\n  uvec3 y = uvec3(floatBitsToUint(hash11(x.x)), floatBitsToUint(hash11(x.y)),\n                  floatBitsToUint(hash11(x.z)));\n  uvec3 w = (~y) >> 3u;\n  uint xy = (((y.x << w.x) ^ (y.y << w.y)) << (y.x ^ y.y)) +\n            (((w.x >> y.y) << (y.x << w.y)) & (y.x ^ y.y));\n  uint yz = (((y.y << w.y) ^ (y.z << w.z)) << (y.y ^ y.z)) +\n            (((w.y >> y.z) << (y.y << w.z)) & (y.y ^ y.z));\n  uint xz = (((y.x << w.x) ^ (y.z << w.z)) << (y.x ^ y.z)) +\n            (((w.x >> y.z) << (y.x << w.z)) & (y.x ^ y.z));\n  return hash11(float(xy + yz + xz) / float(0xFFFFFFFFU));\n}\n\n// smooth 2D noise\nfloat noise2D(vec2 p) {\n  vec2 id = floor(p);\n  vec2 lv = smoothstep(0.0, 1.0, fract(p));\n\n  return mix(mix(hash21(id), hash21(id + vec2(1, 0)), lv.x),\n             mix(hash21(id + vec2(0, 1)), hash21(id + vec2(1, 1)), lv.x), lv.y);\n}\n\n// layered smooth 2D noise\nfloat noise2D(vec2 p, float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  float n = 0.0;\n#define ADVANCE                                                                \\\n  n += amp * noise2D(p * freq);                                                \\\n  div += amp;                                                                  \\\n  amp /= 2.0;                                                                  \\\n  freq *= 2.0;\n  ADVANCE\n  ADVANCE\n  ADVANCE\n  ADVANCE\n#undef ADVANCE\n  return n / div;\n}\n\n// smooth 3D noise\nfloat noise3D(vec3 p) {\n  vec3 id = floor(p);\n  vec3 lv = smoothstep(0.0, 1.0, fract(p));\n  return mix(\n      mix(mix(hash31(id + vec3(0, 0, 0)), hash31(id + vec3(1, 0, 0)), lv.x),\n          mix(hash31(id + vec3(0, 1, 0)), hash31(id + vec3(1, 1, 0)), lv.x),\n          lv.y),\n      mix(mix(hash31(id + vec3(0, 0, 1)), hash31(id + vec3(1, 0, 1)), lv.x),\n          mix(hash31(id + vec3(0, 1, 1)), hash31(id + vec3(1, 1, 1)), lv.x),\n          lv.y),\n      lv.z);\n}\n\n// layered smooth 3D noise\nfloat noise3D(vec3 p, float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  float n = 0.0;\n#define ADVANCE                                                                \\\n  n += amp * noise3D(p * freq);                                                \\\n  div += amp;                                                                  \\\n  amp /= 2.0;                                                                  \\\n  freq *= 2.0;\n  ADVANCE\n  ADVANCE\n  ADVANCE\n  ADVANCE\n#undef ADVANCE\n  return n / div;\n}\n\n\n// Below is just some visual stuff \n\n/////////////////////////////////////////////////////////////////////////////////\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nbool getBox(vec2 p, vec2 pos, vec2 size, inout vec2 uv, out float edge) {\n    vec2 mi = pos-(size*0.5);\n    vec2 ma = pos+(size*0.5);\n    \n    float e1 = 1.0-smoothstep(0.0, 0.02, p.x-mi.x);\n    float e2 = 1.0-smoothstep(0.0, 0.02, ma.x-p.x);\n    float e3 = 1.0-smoothstep(0.0, 0.02, p.y-mi.y);\n    float e4 = 1.0-smoothstep(0.0, 0.02, ma.y-p.y);\n    edge = clamp(max(e1, max(e2, max(e3, e4)))*400.0, 0.0, 1.0);\n    \n    if (p.x < mi.x || p.x > ma.x) return false;\n    if (p.y < mi.y || p.y > ma.y) return false;\n    vec2 s = (ma-mi);\n    uv = (p - mi)/((size*0.5));\n    return true;\n}\n\n\nvoid mainImage(out vec4 O, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc - 0.5 * R.xy) / R.y;\n  vec2 m = (iMouse.xy - 0.5 * R.xy) / R.y;\n  vec3 rd = normalize(vec3(uv.xy, 1.0));\n\n  if (iMouse.z > 0.0) {\n      rd.yz *= rot(m.y * TAU);\n      rd.xz *= rot(m.x * TAU);\n  } else {\n      rd.yz *= rot(cos(T*0.5));\n      rd.xz *= rot(T*0.5);\n  }\n\n  col += noise3D(rd, 10.0);\n  \n  float bSize = (R.x / 3.0)/R.x;\n  \n  {\n      vec2 buv = vec2(0.);\n      float e = 0.0;\n      if (getBox(uv, vec2(-0.5, 0.0), vec2(bSize), buv, e)) {\n          col = vec3(hash21(buv));\n          col += vec3(1, 0, 0) * e;\n      }\n  }\n  \n  {\n      vec2 buv = vec2(0.);\n      float e = 0.0;\n      if (getBox(uv, vec2(0.0, 0.0), vec2(bSize), buv, e)) {\n          col = vec3(noise2D(buv*10.));\n          col += vec3(0, 1, 0) * e;\n      }\n  }\n  \n  {\n      float e = 0.0;\n      vec2 buv = vec2(0.);\n      if (getBox(uv, vec2(0.5, 0.0), vec2(bSize), buv, e)) {\n          col = vec3(noise2D(buv, 2.0));\n          col += vec3(0, 0, 1) * e;\n      }\n  }\n  \n  O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}