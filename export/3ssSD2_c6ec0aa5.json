{"ver":"0.1","info":{"id":"3ssSD2","date":"1552243804","viewed":62,"name":"Moy_mash","username":"dmitri","description":"Первое задание по курсу Машинной графики от студента 312 группы Михайлова Дмитрия Александровича.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec3 Capsule_a = vec3(-6.5, 3, 10);\nvec3 Capsule_b = vec3(-6.5, 0.3, 10);\nfloat Capsule_c = 0.2; \nvec3 Box_a = vec3(-6.5, 4, 10);\nvec3 Box_b =  vec3(0.75,.75,0.75);\nvec3 Tor_a = vec3(-6.5,.5,10);\nvec2 Tor_b = vec2(1.0, .2);\nfloat Sphere_a = 1.0;\nvec3 Sphere_b = vec3(1.5,4,7);\nvec3 Prism_a = vec3(8,1.2,10);\nvec2 Prism_b = vec2(1,0.2);\n\n\nfloat Sn_b = 1.6;\nvec3 Sn_a = vec3(1.5,1.5,7);\nvec3 Capsule1_a = vec3(-0.5, 3, 7);\nvec3 Capsule1_b = vec3( 1, 2, 7);\nfloat Capsule1_c = 0.2; \nvec3 Capsule2_a = vec3(3.5, 3, 7);\nvec3 Capsule2_b = vec3(2, 2, 7);\nfloat Capsule2_c = 0.2; \nfloat Sn1_b = 0.1;\nvec3 Sn1_a = vec3(1.3,4.2,6.);\nfloat Sn2_b = 0.1;\nvec3 Sn2_a = vec3(2,4.2,6.08);\nfloat Sn3_b = 0.1;\nvec3 Sn3_a = vec3(1.7,4,5.97);\n\nfloat sdTorus(vec3 p, vec2 a) \n{\n\tfloat t = length(p.xz)-a.x;\n    return length(vec2(t, p.y))-a.y;\n}\n\n\nfloat dBox(vec3 p, vec3 a) \n{\n\treturn length(max(abs(p)-a, 0.));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ba = b-a, pa = p-a;\n    float t = clamp(dot(ba, pa) / dot(ba, ba), 0.0, 1.0);\n    vec3 c = a + t*ba;\n    return length(p-c)-r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 b )\n{\n    vec3 a = abs(p);\n    return max(a.z-b.y,max((a.x*0.86+a.y*0.5),a.y)-b.x);\n}\n\nfloat sdSphere( vec3 p, float a )\n{\n  return length(p)-a;\n}\n\nfloat GetDist(vec3 p) {\n    float cd = sdCapsule(p, Capsule_a, Capsule_b, Capsule_c); \n    float td = sdTorus(p - Tor_a, Tor_b);\n    float bd = dBox(p-Box_a,Box_b);\n    float os = sdSphere(p-Sphere_b, Sphere_a);\n    float pr = sdHexPrism(p-Prism_a,Prism_b);\n    float sn = sdSphere(p-Sn_a, Sn_b);\n    float sn1 = sdSphere(p-Sn1_a, Sn1_b);\n    float sn2 = sdSphere(p-Sn2_a, Sn2_b);\n    float sn3 = sdSphere(p-Sn3_a, Sn3_b);\n    float snr1 = sdCapsule(p, Capsule1_a, Capsule1_b, Capsule1_c); \n    float snr2 = sdCapsule(p, Capsule2_a, Capsule2_b, Capsule2_c); \n    float d = min(cd, p.y);\n    d = min(d, td);\n    d = min(d, bd);\n    d = min(d, os);\n    d = min(d, pr);\n    d = min(d, sn);\n    d = min(d, sn1);\n    d = min(d, sn2);\n    d = min(d, sn3);\n    d = min(d, snr1);\n    d = min(d, snr2);\n    return d;\n}\n\nfloat RayMarch(vec3 a, vec3 b) {\n\tfloat c=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = a + b*c;\n        float d = GetDist(p);\n        c += d;\n        if(c>MAX_DIST || d<SURF_DIST) break;\n    }\n    \n    return c;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat a = GetDist(p);\n    vec2 b = vec2(.001, 0); \n    vec3 n = a - vec3(\n        GetDist(p-b.xyy),\n        GetDist(p-b.yxy),\n        GetDist(p-b.yyx));   \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(-2, 12, -10);\n    vec3 l = normalize(lightPos-p);\n    vec3 nor = GetNormal(p);\n    float diff = clamp(dot(nor, l), 0., 1.);\n    float dist = RayMarch(p+nor*SURF_DIST*2., l);\n    if(dist<length(lightPos-p)) diff *= .1;\n    return diff;\n}\n\nfloat GetLight1(vec3 p) {\n    vec3 lightPos = vec3(10, 10, -10);\n    vec3 l = normalize(lightPos-p);\n    vec3 nor = GetNormal(p);\n    float diff = clamp(dot(nor, l), 0., 1.);\n    float dist = RayMarch(p+nor*SURF_DIST*2., l);\n    if(dist<length(lightPos-p)) diff *= .1;\n    return diff;\n}\n\n\n\nvec3 Color(vec3 p)\n{\n    if(sdCapsule(p, Capsule_a, Capsule_b, Capsule_c) <= 0.001)\n    {\n        return vec3(0,0,1);\n    }\n    if(dBox(p-Box_a,  Box_b) <= 0.1)\n    {\n        return vec3(0,1,0);\n\t}\n    if(sdTorus(p-Tor_a, Tor_b) <= 0.1)\n    {\n        return vec3(1,1,0);\n\t}\n    if(sdSphere(p-Sphere_b,Sphere_a) <= 0.1)\n    {\n\t\treturn vec3(1,1,1);\n    }\n    if(sdSphere(p-Sn2_a,Sn2_b) <= 0.1)\n    {\n\t\treturn vec3(0,0,0);\n    }\n    if(sdSphere(p-Sn1_a,Sn1_b) <= 0.1)\n    {\n\t\treturn vec3(0,0,0);\n    }\n        if(sdSphere(p-Sn3_a,Sn3_b) <= 0.1)\n    {\n\t\treturn vec3(1,0.5,0);\n    }\n    if(sdHexPrism(p-Prism_a,Prism_b) <= 0.1)\n    {\n\t\treturn vec3(0.5,0,0.5);\n    }\n    if(p.y <= 0.1)\n    {\n        if(cos(p.x * 10.) <= 0.) return vec3(1, 0.7, 0.2); \n        if(sin(p.z * 10.) <= 0.) return vec3(0.5, 0.7, 1);\n        return vec3(0.3,0.8,0.3);\n    }\n    return vec3(1,1,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(2, 4, -4);\n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n    float d = RayMarch(ro, rd);\n    if (d <= MAX_DIST)  \n    {\n        vec3 p = ro + rd * d;\n\t\tfloat dif = GetLight(p);\n        float dif1 = GetLight1(p);\n\t\tcol = Color(p) * dif * dif1;\n    }\n    fragColor = vec4 (col, 2.);\n}","name":"Image","description":"","type":"image"}]}