{"ver":"0.1","info":{"id":"slBBzW","date":"1652039206","viewed":259,"name":"Wall Street Plaza","username":"luckyballa","description":"I moved to wall street last week, so here is a some building i see throw the window, but in shader :)\ncheating a lot, but at least it works quite fast\n","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","refraction","sky","reflections","city","helix","infinite","industrial","building","stocks","skyscraper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n\n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n\tvec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * 4.;\n    vec3 col = tex(uv);\n\n    fragColor = vec4(col, 1.) + grain;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .005\n#define PI 3.1415926535\n#define iTime iTime * 2.\n#define dot2(V) dot(V,V)\n#define saturate(x) min(max(x, 0.), 1.)\n#define tex(p) texture(iChannel0, p).rgb\n\n\n#define sunCol vec3(1., .725, 0.4)\n#define cloudsCol vec3(0.75, 0.75, 1.)\n#define skyCol vec3(0.425, 0.575, 0.85)\n\n\nvec3 hash3( float n ) {\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\nfloat hash( uvec2 x ) {\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nvec2 hash(vec2 p) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat hash(float q) {\n    uint n = uint(q);\n    \n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat noise( vec3 x ) {\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; \n    const float K2 = 0.211324865; \n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n }\n    \nvec2 rot(vec2 p, in float an ) {\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nvec3 rot(vec3 P, float a, vec3 A) {\n    vec3 O = dot(P, A) * A;\n    return O + (P-O) * cos(a) -  cross(A,P) * sin(a);\n}\n\nfloat bd(vec3 p) {\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// IQ\nfloat sdTriPrism( vec3 p, vec2 h ) {\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn bd(p);\n}\n\nvec3 closestPointOnCylinder(vec3 p, vec2 dim) {\n    return vec3(normalize(p.xy) * dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n}\n\n//https://www.shadertoy.com/view/ttB3DV\nvec2 spring(vec3 p, float r, float h, float t) {\n    float coils = 4.0 / (h / PI);\n    vec3 pc = closestPointOnCylinder(p, vec2(r, t));\n    float distToCyl =  distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z * coils + 0.5 * atan(p.x, p.y))) / coils;\n        \n    return vec2(distToCyl, distToCoil);\n}\n\nfloat building( vec3 p, vec3 b ) {\n  vec3 dp = p;\n  vec3 q = abs(dp)- b; q.xz = abs(q.xz) - 1.; q.xz = abs(q.xz) - 1.;\n  \n  p.y = abs(p.y);\n  vec3 qo = abs(p)- b * vec3(1.02, 1.5, 1.02); \n  qo.xz = abs(qo.xz) - 1.; \n  qo.xz = abs(qo.xz) - 1.; \n  \n  vec3 e = abs(p)- b; \n  e.xz = abs(e.xz) - 1.; \n  e.xz = abs(e.xz) - 1.; \n  e = abs(e) - vec3(0.05, 0.5, 0.05);\n  \n  vec3 q2 = abs(p - vec3(0., 0.125, 0.)) - b * vec3(1.05, 0.1, 1.05); \n  q2.xz = abs(q2.xz) - 1.; \n  q2.xz = abs(q2.xz) - 1.;\n\n  float ed = bd(e);\n  float qd = bd(q);\n  float qod = bd(qo);\n  float q2d = max(-qd, bd(q2));\n  \n  return smin(smin(ed, q2d, 0.02), qod, 0.05);\n}\n\nfloat buildingIn(vec3 p, vec3 b, vec3 op, float t) {\n  float flr = floor(op.y * 5.);\n\n  vec3 dp = p;\n  vec3 q = abs(dp)- b * 0.8;\n  q.xz = abs(q.xz) - 1.; q.xz = abs(q.xz) - 1.;\n  \n  vec3 q2 = abs(p) - b;\n  q2.xz = abs(q2.xz) - 1.; q2.xz = abs(q2.xz) - 1.;\n  \n  float h = hash(uvec2(abs((rot(p.xz * 2., flr)) + dot2(p) * 0.1))) * 0.3; \n  q.y = mix(q.y, h * q.y, step(op.y + h * 10. - 6., t));\n\n  return smin(bd(q2), bd(q), 0.05);\n}\n\nvec2 distOut(vec3 p) {\n    vec3 bp = p;\n    bp.y = mod(bp.y + 0.5, 1.) - 0.5;\n    float bd = building(bp, vec3(1., 0.1, 1.));\n    \n    vec3 q = abs(bp)- vec3(3., 1., 3.);\n    float gd = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n\n    float res = smin(gd, bd, 0.02);\n    return vec2(res, bd < gd ? 0. : 1.);\n}\n  \nvec2 distIn(vec3 p, float t) {\n    vec3 bp = p;\n    bp.y += 0.1;\n    bp.y = mod(bp.y + 0.5, 1.) - 0.5;\n    float bd = buildingIn(bp, vec3(1., 0.05, 1.), p, t);\n    \n    return vec2(bd, 1.);\n}\n\nvec2 dist(vec3 p, bool inside, float t, bool refl) {\n    vec2 b = vec2(MAX_DIST, -1);\n    if (!refl) {\n        vec3 q = p; \n        q.z = abs(q.z) - 2.;\n        b = inside ? distIn(q, t) : distOut(q);\n    }\n    \n    p.z *= 0.85;\n    float r = PI * 2.;\n    float tt = t * 2. + PI * 2.;\n    float h = PI * 20.;\n    vec2 s = spring(p.xzy, r, h, tt);\n    vec2 l = vec2(0.,3.);\n    vec2 c = vec2(0.1);\n    s = s - c * clamp( round(s / c), -l, l);\n    s.xy = abs(s.xy) - vec2(0.05, 0.1);\n    float cd = (length(max(s.xy, 0.)) + min(max(s.x,s.y),0.0));\n    float of = PI * 0.475;\n    float at = tt * (4.0 / (h / PI));\n    vec3 rr = vec3(cos(at + of) * r, t + of * 2., sin(at + of) * r);\n    vec3 ap = p - rr;\n   \n    float an = atan(p.x * r, p.z * r) - 0.0265;\n    ap = rot(ap, an, vec3(0., 1., 0.));\n    ap = rot(ap, PI / 2.55, vec3(0., -0.025, 1.));\n    float ad = sdTriPrism(ap, vec2(1.2, 0.05));\n    \n    // Clipping helix end with a box, can't figure out a better way to do it\n    of += PI * 0.05;\n    ap = p - vec3(cos(at + of) * r, t + of * 2., sin(at  + of) * r);\n    ap = rot(ap, an, vec3(0., 1., 0.));\n    ap = rot(ap, PI / 2.55, vec3(0., -0.025, 1.));\n    cd = smax(sdBox(ap, vec3(1.2)), cd, 0.45);\n    \n    cd = smin(cd, ad, 0.005);\n    b.y = cd < b.x ? 2. : b.y;\n    b.x = smin(cd, b.x, 0.5);\n\n    return b;\n}\n\n\nvec2 dist(vec3 p, bool inside, float t) {\n    return dist(p, inside, t, false);\n}\n\nvec2 march(vec3 ro, vec3 rd, bool inside, float t, bool bounce) {\n\tfloat dO = 0.;\n    float matId = -1.;\n    int steps = bounce ? MAX_STEPS / 3 : MAX_STEPS;\n    for(int i=0; i<steps; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = dist(p, inside, t, bounce);\n        float dS = res.x ;\n        dO += dS;\n        matId = dO>MAX_DIST ? -1. : res.y;\n\n        if(dO>MAX_DIST || abs(dS)<(SURF_DIST * (inside || bounce ? 5. : 1.))) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec2 march(vec3 ro, vec3 rd, bool inside, float t) {\n    return  march(ro, rd, inside, t, false);\n}\n\n\n\nvec3 normal(vec3 p, float ef, bool inside, float t) {\n\tfloat d = dist(p, inside, t).x;\n    vec2 e = vec2(ef, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy, inside, t).x,\n        dist(p-e.yxy, inside, t).x,\n        dist(p-e.yyx, inside, t).x);\n    \n    return normalize(n);\n}\n\nfloat window(vec3 p) {\n    float w = min(abs(p.z), abs(p.x));\n    return abs(sin(w * 2.) + sin(w * 150.));\n}\n\nvec3 bump(vec3 pos, vec3 n) {\n    float e = 0.02;\n    float b = 0.1;\n\tfloat ref = window(pos);\n    vec3 grad = ref - vec3(\n                        window(vec3(pos.x+e, pos.y, pos.z)),\n                        window(vec3(pos.x, pos.y+e, pos.z)),\n                        window(vec3(pos.x, pos.y, pos.z+e)));\n\t\n    grad *= b;\n    vec3 tgrad = grad - n * dot(n, grad);\n    return mix(n, normalize(n - tgrad), 0.1);    \n}\n\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = saturate(dot(n, l));\n\n    return dif;\n}\n\n// Inspired by https://www.shadertoy.com/view/XtVGzw\nvec3 camera(vec2 uv, vec3 d, float aspect, float f){ \n    vec3 up = vec3(0., 1., 0.);\n    vec3 r = normalize(cross(d, up));\n    vec3 u = cross(r, d);\n    vec2 ab = f / 360. * uv * PI;\n    \n    d = rot(d, -ab.x, u);\n    r = normalize(cross(d, u));\n    d = rot(d, -ab.y, r);\n    \n    return d;\n}\n\nvec3 arrowColor(float id, vec3 p, vec3 rd, float t, vec3 n) {\n      vec3 c = vec3(0.1, 1., 0.1);\n      return max(abs(dot(rd, n)), 0.25) * c * (id == 2. ? 1. : 0.);//c * 3.;\n}\n\nfloat shadow(vec3 ro,  vec3 rd,  float mint, float maxt, float k, bool inside, float ti) {\n    float shadow = 1.0;\n    float t = mint;\n    vec3 oc = vec3(0.);\n    for( int i=0; i < 20; i++ ) {\n        if(t < maxt) {\n            vec2 h = dist( ro + rd * t, inside, ti);\n            shadow = min(shadow, k * h.x / t);\n            vec3 p = ro + rd * t;\n            \n            t += 0.2;\n        }\n    }\n    \n    return saturate(shadow);\n}\n\n// IQ\nfloat ao( in vec3 p, in vec3 n, bool inside, float t) {\n\tfloat totao = 0.0;\n    for(int aoi=0; aoi<8; aoi++) {\n\t\tvec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n\t\taopos *= sign( dot(aopos,n) );\n\t\taopos = p + n*0.01 + aopos*0.04;\n        float dd = clamp( dist(aopos, inside, t).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    \n\ttotao /= 8.0;\n\t\n    return clamp( totao*totao*50.0, 0.0, 1.0 );\n}\n\nvec3 skyColor(vec3 rd, vec3 sd) {\n    vec3 ord = rd;\n    rd.y = max(rd.y + 0.05, 0.);\n    float f = (fbm(rd.xz * rd.y * 3.)) * smoothstep(0., 0.5,  max(rd.y + 0.05, 0.));\n\n    vec3 col = mix(skyCol, saturate(0.25 * skyCol + cloudsCol), saturate(f * 10.));\n    col += sunCol * pow( max(dot(rd, sd),0.), 8.) * .5; \n    col = mix(col, sunCol, (1. - saturate(exp(-pow(dot(rd, sd), 1.) * 0.25))) * 0.5); \n    col += pow(max(dot(rd, sd),0.), 100.0) *.1;\n    col = mix(col, mix(sunCol * 2., col, 0.75), smoothstep(0., -0.5, ord.y));\n    \n    return col;\n}\n\nvec3 env(vec3 rd, vec3 n, vec3 sd) {\n    vec3 ld = reflect(rd, n);    \n    \n    return skyColor(ld, sd);\n}\n\nfloat cloudMap(in vec3 p, in float d, float t) {\n    p.z += t * 4.;\n    float n = noise(p * vec3(0.4, 1., 0.5)) / d * max(sin(p.y / 4.), 0.25);\n    \n    return smoothstep(0., .55, n) ;\n}\n\nvec3 clouds(in vec3 col, in vec3 ro, in vec3 rd, in float depth, float t) {\n    float d = 5.;\n    vec3  pos = ro + rd * d;\n    float fog = cloudMap(pos, d, t);\n    vec3 col2 = vec3(0.9);\n    col = mix(col, col2, saturate(fog  * 1.5));\n        \n    \n    return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 suv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    float cd = 18.;\n    vec3 ro = vec3(sin(iTime / 16.) * cd + cos(iTime / 4.) / 2., iTime, cos(iTime / 8.) * cd);\n    vec3 rd = normalize(vec3(0., ro.y + 3., 1.) - ro);\n    rd = camera(uv, rd, aspect, 60. + 30. * sin(iTime /  8.) + 30. * (cos(iTime / 16.) + 1.) * 0.5);\n    vec3 col = vec3(0.);\n    vec2 d = vec2(0.);\n    vec3 p = vec3(0.);\n\n\n    vec3 sd = normalize(vec3(.0, .5, 1.));\n    vec3 sky = skyColor(rd, sd);\n    \n    d = march(ro, rd, false, iTime);\n    p = ro + rd * d.x;\n    vec3 n = normal(p, 0.02, false, iTime); \n    vec3 ld = reflect(normalize(rd + vec3(0., 0.25, 0.)), n);\n    vec3 arrCol = vec3(0.);\n    if (d.x < MAX_DIST) {\n        if (d.y == 0.) {\n            // Buiding\n            vec3 en = env(rd, n, sd);\n            col = en * mix(sky * 0.5, vec3(0.5), 0.5);\n            float ao = max(ao(p, n, false, iTime), 0.5);\n            float amb = (0.5 + 0.5 * n.y) * 1.2;\n            col += amb * ao;\n            float dir = saturate(0.1 + 0.9 * dot(n, sd));\n            col += dir * 0.5 * vec3(1., .7, .4);\n\n            float s = shadow(p , ld, 1., 10., 10., false, iTime);\n            col -= (1. - s) * col * 0.25;\n            col = saturate(col);\n         }\n         else if (d.y == 1.) {\n             // Glass\n             n = bump(p, n); \n\n             vec3 en = env(rd, n, sd);\n             col = en * 0.666 + saturate(dot(n, sd)) * sunCol * 0.1;\n             vec2 b = march(p + n * SURF_DIST, ld, false, iTime, true);\n             vec3 bp = p + ld * b.x;\n             vec3 bc = arrowColor(b.y, bp, ld, iTime, n);\n             col += bc * 0.2; \n\n             // Office         \n             vec3 inrd = refract(rd, n, 1.25);\n             vec3 ld = reflect(normalize(rd + vec3(0., 0.25, 0.)), n);\n\n             vec2 dd = march(p + n * SURF_DIST * 10., inrd, true, iTime); \n             vec3 inP = p + inrd * dd.x;\n             vec3 inN = normal(inP, 0.1, true, iTime);  \n             vec3 trans = arrowColor(dd.y, inP, inrd, iTime, n);\n             en = env(inrd, inN, sd);\n             vec3 inCol = trans;\n             float s = shadow(inP, ld, 0.1, 10., 5., true, iTime);\n             inCol += max(dot(inN, rd), 0.) * sky * s * saturate(dd.y);\n             inCol += s * sky.xxx * 0.75;\n             inCol += en * 0.5;\n             inCol -= inCol * dot(bc, vec3(0.333));\n\n             col = mix(saturate(inCol), col, 0.75);\n        } \n        else if (d.y == 2.) {\n            // Arrow\n            arrCol = arrowColor(2., p, rd, iTime, n);\n        }\n    }\n\n    float od = d.x;\n    d.x = d.x < MAX_DIST ? d.x : 0.;           \n    vec2 fp = fract(uv * 5.) - 0.5;\n    float g = max(fp.y, fp.x) ; \n    col = mix(col, sky, step(d.x, 0.1));\n    col = mix(col, vec3(dot(vec3(0.333), col)), 0.25); \n    col += arrCol;\n    col = pow(clouds(col, ro, rd, pow(od, 1.), iTime), vec3(0.75));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// FXAA implementation from\n// https://www.shadertoy.com/view/4tf3D8\n#define RES iResolution.xy\n\nvec3 fxaa(vec2 p) {\n\tconst float FXAA_SPAN_MAX   = 16.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n    vec3 col = fxaa(uv);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}