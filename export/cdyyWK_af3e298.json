{"ver":"0.1","info":{"id":"cdyyWK","date":"1696582663","viewed":125,"name":"micrograin - Graffiti","username":"SimonL","description":"micrograin demo - Graffiti\n\nYou can control the camera position with WASD or Arrow keys, and the camera rotation with the mouse. It is recommended to keep the mouse inside the viewport to avoid unexpected behaviors related to ShaderToy.","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["brdf","microfacet","siggraph","porosity","micrograin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A Micrograin BSDF Model for the Rendering of Porous Layers\n// https://hal.science/hal-04220006\n\n// camera misc\nvec3 getVec3(int add);\nvoid setVec3(vec3 v, int add, inout vec4 o);\nvoid setMat3(mat3 m, int add, inout vec4 o);\nmat3 getMat3(int address);\n\n// raytrace\nfloat intersect_plane( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor );\n\n\nvoid mainImage( out vec4 out_col, in vec2 in_coord )\n{\n    out_col = vec4(0.);\n    \n    // frame uv\n    vec2 uv = (in_coord-iResolution.xy*.5)/iResolution.y;\n    \n    // light animation time\n    float anim = iTime*0.1*PI;\n    \n    // ray generation\n    mat3 cam = getMat3(0);\n    vec3 ray_dir = cam * normalize(vec3(uv, 1.5));\n    vec3 ray_ori = getVec3(3);\n    \n    \n    // test intersection with the plane\n\tvec3 pos, nor;\n\tfloat t = intersect_plane( ray_ori, ray_dir, pos, nor);\n    if( t < 1e6 && pos.x < 1. && pos.x > -1. && pos.z < 1. && pos.z > -1. )\n\t{\n        // light definition\n        #if 1 // point light\n            vec3 point_light_pos = vec3(1.*cos(anim),1.,1.*sin(anim)+1. );\n            vec3 light_dir = point_light_pos-pos;\n            float d_sqr = dot(light_dir,light_dir);\n            float r = 10.;\n            light_dir /= sqrt(d_sqr);\n            float light_attenuation = (2. / (d_sqr + r*r + sqrt(d_sqr) * sqrt(d_sqr + r*r)));\n            float light_intensity = 500.;\n        #else // directional light\n            vec3 light_dir = normalize(vec3(0.0,sin(anim)*0.5 + 0.6,1.0));\n            float light_attenuation = 1.;\n            float light_intensity = 4.;\n        #endif\n        \n        // porous layer diffuse color\n        vec3 kd_s = vec3(0.);\n        // base diffuse color\n        vec3 color_noise = hpn(iChannel2,pos.xz*40.).xxx;\n        color_noise = smoothstep(vec3(0.4),vec3(0.6),color_noise);\n        vec3 kd_b = vec3(0.);\n        \n        // filling factor\n        float t = pow(texture(iChannel0,pos.xz*0.5+0.5).y,1.);\n        float tau_0 = smoothstep(0.,0.98,clamp(1.-t,0.,0.999));\n        \n        // porous layer R0\n        vec3 R0_s  = vec3(0.082,0.149,0.949);\n        // base R0\n        vec3 R0_b  = hpn(iChannel1,pos.xz*1.).xxx;\n        \n        // porous layer anfractuosity\n        float beta = 0.8;\n        // base roughness\n        float alpha = 0.05;\n        alpha *= pow(length(R0_b),2.);\n        \n        // porous layer type (conductor or plastic) \n        bool is_conductor_s = true;\n        // base type (conductor or plastic)\n        bool is_conductor_b = true;\n        \n        // model evalutation\n        out_col.xyz = eval(\n              nor\n            , -ray_dir\n            , light_dir\n            , tau_0\n            , beta\n            , alpha\n            , kd_s\n            , kd_b\n            , R0_s\n            , R0_b\n            , is_conductor_s\n            , is_conductor_b);\n            \n        out_col.xyz *= light_intensity * light_attenuation;\n\t}\n    else {\n        out_col = vec4(0.01);\n    }\n\t\n    \n    // tonemapping\n    out_col = out_col/(1.+out_col);\n    // gamma correction\n    out_col = pow(out_col,vec4(1.0/2.2));\n}\n\n\n// raytrace\nfloat intersect_plane( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor )\n{\n\tfloat tmin = 1e6;\n\tnor = vec3(0.);\n\tpos = vec3(0.);\n\t\n\tfloat h = (0.-ro.y)/rd.y;\n\tif(h > 0.) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.,1.,0.); \n\t\tpos = ro + h*rd;\n\t}\n\n\treturn tmin;\t\n}\n\n// camera misc\nvec3 getVec3(int add) {\n    return vec3(\n        texelFetch(iChannel3, ivec2(add, 0), 0).w,\n        texelFetch(iChannel3, ivec2(add, 1), 0).w,\n        texelFetch(iChannel3, ivec2(add, 3), 0).w\n    );\n}\nvoid setVec3(vec3 v, int add, inout vec4 o) {\n    ivec2 u = ivec2(gl_FragCoord.xy);\n    if(u == ivec2(add, 0)) o.w = v.x;\n    if(u == ivec2(add, 1)) o.w = v.y;\n    if(u == ivec2(add, 3)) o.w = v.z;\n}\nvoid setMat3(mat3 m, int add, inout vec4 o) {\n    for(int i = 0; i < 4; i++) {\n        setVec3(m[i], add+i, o);\n    }\n}\nmat3 getMat3(int address) {\n    return mat3(getVec3(address), getVec3(address+1), getVec3(address+2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////\n// Previous work /\n/////////////////\n\nvec3 FresnelDielectricDielectric(vec3 Eta, float CosTheta);\nvec3 FresnelDielectricConductor(vec3 Eta, vec3 Etak, float CosTheta);\nconst float PI = 3.141593f;\n\nfloat D_ggx(float alpha_sqr, float cos_theta)\n{\n    float cos2_theta = cos_theta*cos_theta;\n    float tan2_theta = (1.-cos2_theta) / cos2_theta;\n   \n    float denom = PI * cos2_theta * cos2_theta * (alpha_sqr + tan2_theta)*(alpha_sqr + tan2_theta);\n    \n    return alpha_sqr / denom;\n}\n\nfloat lambda_ggx(float alpha_sqr, float tan_theta)\n{\n    return (-1. + sqrt(1.+alpha_sqr*tan_theta*tan_theta))/2.;\n}\n\nfloat G1_ggx(float alpha_sqr, float cos_theta)\n{\n    float tan_theta = sqrt(1. - cos_theta * cos_theta) / cos_theta;\n    return 1./(1.+lambda_ggx(alpha_sqr,tan_theta));\n}\n\nfloat G_ggx(float alpha_sqr, float cos_theta_i, float cos_theta_o)\n{\n    return G1_ggx(alpha_sqr,cos_theta_i) * G1_ggx(alpha_sqr,cos_theta_o);\n}\n\n\nvec3 ggx_conductor_brdf(\n      float alpha_sqr\n    , vec3 R0\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{    \n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_ggx(alpha_sqr,cos_theta_h);\n    float G = G_ggx(alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    //vec3 F = FresnelDieletricConductor(eta,kappa,cos_theta_d);\n    return D*G*F / (4. * cos_theta_i * cos_theta_o);\n}\n\nvec3 ggx_plastic_brdf(\n      float alpha_sqr\n    , vec3 R0\n    , vec3 kd\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{    \n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_ggx(alpha_sqr, cos_theta_h);\n    float G = G_ggx(alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    vec3 spec = D*G*F / (4. * cos_theta_i * cos_theta_o);\n    \n    vec3 Ti = 1. - FresnelDielectricDielectric(eta,cos_theta_i);\n    vec3 To = 1. - FresnelDielectricDielectric(eta,cos_theta_o);\n    vec3 diff = To * Ti * kd / PI;\n    \n    return spec + diff;\n}\n\n/////////\n// Our /\n///////\n\n\n// Eq 18.\nfloat alpha2beta(float alpha,float tau_0)\n{\n    float fac = sqrt(-tau_0 / log(1. - tau_0));\n    return alpha / fac;\n}\n\n// Eq 18.\nfloat beta2alpha(float beta, float tau_0)\n{\n    float fac = sqrt(-tau_0 / log(1. - tau_0));\n    return beta * fac;\n}\n    \n// Eq. in section visible filling factor\nfloat gamma_beta(float beta_sqr,float cos_theta)\n{\n    float cos2_theta = cos_theta * cos_theta;\n    float sin2_theta = 1. - cos2_theta;\n    return sqrt(beta_sqr * sin2_theta + cos2_theta);\n}\n\n// Eq. in section Visible filling factor\nfloat gamma_beta_plus(float beta_sqr, float cos_theta)\n{\n    return 0.5 * (cos_theta + gamma_beta(beta_sqr,cos_theta));\n}\n\n// Eq. 21\nfloat tau_theta(float tau_0, float beta_sqr, float cos_theta)\n{\n    return 1. - pow((1. - tau_0) , (gamma_beta(beta_sqr,cos_theta)/cos_theta));\n}\n\n// Eq. 22\nfloat tau_theta_plus(float tau_0, float beta_sqr, float cos_theta)\n{\n    return 1. - sqrt((1. - tau_theta(tau_0, beta_sqr, cos_theta))*(1. - tau_0));\n}\n\n\n// Eq. in supplemental\nfloat G1_our(float tau_0, float beta_sqr, float cos_theta)\n{ \n    float pi_gamma = -log(1. - tau_0);\n    float exp_pi_gamma_minus_one = exp(pi_gamma) - 1.;\n\n    cos_theta = clamp(cos_theta,0.00001,0.99999);\n    float mu  = cos_theta / sqrt(1. - cos_theta * cos_theta);\n    \n    float beta2  = beta_sqr;\n    float beta4  = beta2  * beta2;\n    float beta6  = beta4  * beta2;\n    float beta8  = beta6  * beta2;\n    float beta10 = beta8  * beta2;\n    float beta12 = beta10 * beta2;\n    \n    float mu2  = mu   * mu;\n    float mu4  = mu2  * mu2;\n    float mu6  = mu4  * mu2;\n    float mu8  = mu6  * mu2;\n    float mu10 = mu8  * mu2;\n    float mu12 = mu10 * mu2;\n    \n    float beta2_mu2 = beta2 + mu2;\n    float sqrt_beta2_mu2 = sqrt(beta2_mu2);\n    \n    float F0 = pi_gamma * (-mu + sqrt_beta2_mu2)/(2.*mu);\n\n    float F1 = pow(pi_gamma,2.) * (beta2+2. * mu * (mu-sqrt_beta2_mu2))/(8. * mu * sqrt_beta2_mu2);\n\n    float F2 = pow(pi_gamma,3.) * (3. * beta4+12. * beta2 * mu2+8. * mu4-8. * mu * pow(beta2_mu2,3./2.))/(96. * mu * pow(beta2_mu2,3./2.));\n\n    float F3 = pow(pi_gamma,4.) * (5. * beta6+30. * beta4 * mu2+40. * beta2 * mu4+16. * mu6-16. * mu * pow(beta2_mu2,5./2.))/(768. * mu * pow(beta2_mu2,5./2.));\n\n    float F4 = pow(pi_gamma,5.) * (35. * beta8+280. * beta6 * mu2+560. * beta4 * mu4+448. * beta2 * mu6+128. * mu8-128. * mu * pow(beta2_mu2,7./2.))/(30720. * mu * pow(beta2_mu2,7./2.));\n\n    float F5 = pow(pi_gamma,6.) * (63. * beta10+630. * beta8 * mu2+1680. * beta6 * mu4+2016. * beta4 * mu6+1152. * beta2 * mu8+256. * mu10-256. * mu * pow(beta2_mu2,9./2.))/(368640. * mu * pow(beta2_mu2,9./2.));\n\n    float F6 = pow(pi_gamma,7.) * (231. * beta12+2772. * beta10 * mu2+9240. * beta8 * mu4+14784. * beta6 * mu6+12672. * beta4 * mu8+5632. * beta2 * mu10 + 1024. * mu12-1024. * mu * pow(beta2_mu2,11./2.))/(10321920. * mu * pow(beta2_mu2,11./2.));\n    \n    float lambda_ = (F0 + F1 + F2 + F3 + F4 + F5 + F6) / exp_pi_gamma_minus_one;\n    \n    return 1. / (1. + lambda_);\n}\n\nfloat G_our(float tau_0, float beta_sqr, float alpha_sqr, float cos_theta_i, float cos_theta_o)\n{\n    return G1_our(tau_0, beta_sqr, cos_theta_i) * G1_our(tau_0, beta_sqr, cos_theta_o);\n}\n\n\n// Eq. 16\nfloat D_our(float tau_0, float beta_sqr, float cos_theta_m)\n{ \n    float cos2_theta_m = cos_theta_m * cos_theta_m;\n    float tan2_theta_m = (1. - cos2_theta_m) / cos2_theta_m;\n    float tmp = beta_sqr + tan2_theta_m;\n    float num = beta_sqr * log(1. - tau_0) * pow(1. - tau_0,tan2_theta_m / tmp);\n    float denum = tau_0 * PI * tmp * tmp * cos2_theta_m * cos2_theta_m;\n    return -num / denum;\n}\n\n// Eq. 24\nfloat visibility_weight(float tau_0, float beta_sqr, float cos_theta_i, float cos_theta_o)\n{\n    float cos_theta_i_ = clamp(abs(cos_theta_i),0.00001,1.);\n    float cos_theta_o_ = clamp(abs(cos_theta_o),0.00001,1.);\n    return 1. - ((1. - tau_theta_plus(tau_0,beta_sqr, cos_theta_i_)) * (1. - tau_theta_plus(tau_0,beta_sqr, cos_theta_o_)) / (1.- tau_0));\n}\n\n// Eq. 1\nvec3 visibility_blend_our(float tau_0, float beta_sqr, float cos_theta_i, float cos_theta_o, vec3 brdf_s, vec3 brdf_b)\n{\n    return mix(brdf_b, brdf_s, visibility_weight(tau_0, beta_sqr, cos_theta_i, cos_theta_o));\n}\n\n\nvec3 micrograin_conductor_bsdf(\n      float tau_0\n    , float beta_sqr\n    , float alpha_sqr\n    , vec3 R0\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{    \n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_our(tau_0,beta_sqr,cos_theta_h);\n    float G = G_our(tau_0, beta_sqr, alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    //vec3 F = FresnelDielectricConductor(eta,kappa,cos_theta_d);\n    return D*G*F / (4. * cos_theta_i * cos_theta_o);\n}\n\nvec3 micrograin_plastic_bsdf(\n      float tau_0\n    , float beta_sqr\n    , float alpha_sqr\n    , vec3 R0\n    , vec3 kd\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{\n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_our(tau_0,beta_sqr,cos_theta_h);\n    float G = G_our(tau_0, beta_sqr, alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    vec3 spec = D*G*F / (4. * cos_theta_i * cos_theta_o);\n    \n    vec3 Ti = 1. - FresnelDielectricDielectric(eta,cos_theta_i);\n    vec3 To = 1. - FresnelDielectricDielectric(eta,cos_theta_o);\n    vec3 diff = To * Ti * kd / PI;\n    \n    return spec + diff;\n}\n\n\nvec3 eval(\n      vec3 n\n    , vec3 wi\n    , vec3 wo\n    , float tau_0\n    , float beta\n    , float alpha\n    , vec3 kd_s\n    , vec3 kd_b\n    , vec3 R0_s\n    , vec3 R0_b\n    , bool is_conductor_s\n    , bool is_conductor_b)\n{\n    vec3 wh = normalize(wi+wo);\n\tfloat cos_theta_o = clamp(dot(n,wo) ,0.0,1.0);\n\tfloat cos_theta_i = clamp(dot(n,wi) ,0.0,1.0);\n\tfloat cos_theta_h = clamp(dot(n,wh) ,0.0,1.0);\n\tfloat cos_theta_d = clamp(dot(wh,wi),0.0,1.0);\n    beta = clamp(beta,0.001,1.);\n    tau_0 = clamp(tau_0,0.001,0.999);\n    float beta_sqr = beta*beta;\n    float alpha_sqr = alpha*alpha;\n    \n    vec3 brdf_s = is_conductor_s ? \n        micrograin_conductor_bsdf(\n          tau_0\n        , beta_sqr\n        , alpha_sqr\n        , R0_s\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d) \n        :\n        micrograin_plastic_bsdf(\n          tau_0\n        , beta_sqr\n        , alpha_sqr\n        , R0_s\n        , kd_s\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d);\n    \n\n    \n    vec3 brdf_b = is_conductor_b ? \n        ggx_conductor_brdf(\n          alpha_sqr\n        , R0_b\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d)\n        :\n        ggx_plastic_brdf(\n          alpha_sqr\n        , R0_b\n        , kd_b\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d);\n    \n    \n    vec3 col = visibility_blend_our(\n          tau_0\n        , beta_sqr\n        , cos_theta_i\n        , cos_theta_o\n        , brdf_s\n        , brdf_b);\n\n    return col * cos_theta_o;\n    \n    \n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////\n// Misc /\n////////\n\n\n// Tileable noise\nvec2 hash( in vec2 p, in float scale, int seed )\n{\n    p = mod(p,scale);\n    p += float(seed) * scale;\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p, in float scale, in int seed)\n{\n    p *= scale;\n    p = mod(p,scale);\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0), scale, seed ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0), scale, seed ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0), scale, seed ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0), scale, seed ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(in vec2 p, in float scale, in int octaves, in int seed){\n\tfloat amp = 0.5;\n    float sum = 0.;\n\tfloat sum_amp = 0.;\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tsum += noise(p, scale, seed) * amp;\n        sum_amp += amp;\n        amp *= 0.5;\n        scale *= 2.;\n\t}\n\treturn sum/sum_amp;\n}\n\n// Tileable texture\nvec2 hash(vec2 p)\n{\n\treturn fract(sin((p) * mat2(127.1, 311.7, 269.5, 183.3) )*43758.5453);\n}\n\nconst mat2 grid_to_skewed_grid = mat2(1.0, 0.0, -0.57735027, 1.15470054);\n\nvoid triangle_grid(vec2 uv,\n\tout float w1, out float w2, out float w3,\n\tout vec2 vertex1, out vec2 vertex2, out vec2 vertex3)\n{\n\n\tvec2 skewed_coord = grid_to_skewed_grid * uv;\n\n\tvec2 baseId = floor(skewed_coord);\n\tvec3 temp = vec3(fract(skewed_coord), 0);\n\ttemp.z = 1.0 - temp.x - temp.y;\n\tif (temp.z > 0.)\n\t{\n\t\tw1 = temp.z;\n\t\tw2 = temp.y;\n\t\tw3 = temp.x;\n\t\tvertex1 = baseId;\n\t\tvertex2 = baseId + vec2(0, 1.);\n\t\tvertex3 = baseId + vec2(1., 0);\n\t}\n\telse\n\t{\n\t\tw1 = -temp.z;\n\t\tw2 = 1.0 - temp.y;\n\t\tw3 = 1.0 - temp.x;\n\t\tvertex1 = baseId + vec2(1., 1.);\n\t\tvertex2 = baseId + vec2(1., 0);\n\t\tvertex3 = baseId + vec2(0, 1.);\n\t}\n}\n\nvec4 hpn(sampler2D tex, vec2 uv){\n    float w1, w2, w3;\n\tvec2 vertex1, vertex2, vertex3;\n\ttriangle_grid(uv*2., w1, w2, w3, vertex1, vertex2, vertex3);\n    \n    vec2 of1 = hash(vec2(vertex1));\n    vec2 of2 = hash(vec2(vertex2));\n    vec2 of3 = hash(vec2(vertex3));\n    \n\n    mat2 unskew = transpose(inverse(grid_to_skewed_grid));\n    vec2 v1 = vec2(vertex1)*unskew;\n    vec2 v2 = vec2(vertex2)*unskew;\n    vec2 v3 = vec2(vertex3)*unskew;\n    \n    vec2 uv1 = uv - v1;\n\tvec2 uv2 = uv - v2;\n\tvec2 uv3 = uv - v3;\n\n\n    vec2 duvdx = dFdx(uv);\n\tvec2 duvdy = dFdy(uv);\n\n    uv1 -= 0.5 + of1; \n    uv2 -= 0.5 + of2;\n    uv3 -= 0.5 + of3;\n    \n    vec4 E = texture(tex,vec2(0.5),100.);\n    \n    // Fetch Gaussian input\n    vec4 G1,G2,G3;\n    G1 = textureGrad(tex, uv1, duvdx,duvdy) - E;\n    G2 = textureGrad(tex, uv2, duvdx,duvdy) - E;\n    G3 = textureGrad(tex, uv3, duvdx,duvdy) - E;\n\n    \n    // Burley 2019 /////////////////////////\n    #define p(x) pow(w.x,lambda)\n    vec3 w = vec3(w1,w2,w3);\n    float lambda = 1.;\n    float l = p(x)+p(y)+p(z);\n    w = vec3(p(x)/l,p(y)/l,p(z)/l);\n    ////////////////////////////////////////\n\n    w = normalize(w);\n    vec4 G = w.x*G1 + w.y*G2 + w.z*G3 + E;\n    \n    // Time varying pixel color\n    return G;\n\n}\n\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec3 FresnelDielectricConductor(vec3 Eta, vec3 Etak, float CosTheta)\n{  \n   float CosTheta2 = CosTheta * CosTheta;\n   float SinTheta2 = 1. - CosTheta2;\n   vec3 Eta2 = Eta * Eta;\n   vec3 Etak2 = Etak * Etak;\n\n   vec3 t0 = Eta2 - Etak2 - SinTheta2;\n   vec3 a2plusb2 = sqrt(t0 * t0 + 4. * Eta2 * Etak2);\n   vec3 t1 = a2plusb2 + CosTheta2;\n   vec3 a = sqrt(0.5f * (a2plusb2 + t0));\n   vec3 t2 = 2. * a * CosTheta;\n   vec3 Rs = (t1 - t2) / (t1 + t2);\n\n   vec3 t3 = CosTheta2 * a2plusb2 + SinTheta2 * SinTheta2;\n   vec3 t4 = t2 * SinTheta2;   \n   vec3 Rp = Rs * (t3 - t4) / (t3 + t4);\n\n   return 0.5 * (Rp + Rs);\n}\n\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec3 FresnelDielectricDielectric(vec3 Eta, float CosTheta)\n{\n   float SinTheta2 = 1. - CosTheta * CosTheta;\n\n   vec3 t0 = sqrt(1. - (SinTheta2 / (Eta * Eta)));\n   vec3 t1 = Eta * t0;\n   vec3 t2 = Eta * CosTheta;\n\n   vec3 rs = (CosTheta - t1) / (CosTheta + t1);\n   vec3 rp = (t0 - t2) / (t0 + t2);\n\n   return 0.5 * (rs * rs + rp * rp);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Tileable noise\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(\n          fbm(fragCoord/iResolution.xy,40.,6,0)\n        , fbm(fragCoord/iResolution.xy,40.,6,1)\n        , fbm(fragCoord/iResolution.xy,40.,6,2)\n    );\n    col = col*0.5 + 0.5;\n    fragColor = vec4(col,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// camera from  loicvdb's shader : https://www.shadertoy.com/view/flc3Rn\n\n#define FLY_MODE_QWERTY\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#ifdef FLY_MODE_QWERTY\nconst int FORWARD = 87;\nconst int BACKWARD = 83;\nconst int UP = 16;\nconst int DOWN = 17;\nconst int RIGHT = 68;\nconst int LEFT = 65;\n#endif\n\n#ifdef FLY_MODE_AZERTY\nconst int FORWARD = 90;\nconst int BACKWARD = 83;\nconst int UP = 16;\nconst int DOWN = 17;\nconst int RIGHT = 68;\nconst int LEFT = 81;\n#endif\n\nconst int ARROW_LEFT = 37;\nconst int ARROW_UP = 38;\nconst int ARROW_RIGHT = 39;\nconst int ARROW_DOWN = 40;\n\n\nvec3 getVec3(int add) {\n    return vec3(\n        texelFetch(iChannel0, ivec2(add, 0), 0).w,\n        texelFetch(iChannel0, ivec2(add, 1), 0).w,\n        texelFetch(iChannel0, ivec2(add, 3), 0).w\n    );\n}\n\n\nvoid setVec3(vec3 v, int add, inout vec4 o) {\n    ivec2 u = ivec2(gl_FragCoord.xy);\n    if(u == ivec2(add, 0)) o.w = v.x;\n    if(u == ivec2(add, 1)) o.w = v.y;\n    if(u == ivec2(add, 3)) o.w = v.z;\n}\n\n\nvoid setMat3(mat3 m, int add, inout vec4 o) {\n    for(int i = 0; i < 4; i++) {\n        setVec3(m[i], add+i, o);\n    }\n}\n\n\nmat3 getMat3(int address) {\n    return mat3(getVec3(address), getVec3(address+1), getVec3(address+2));\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n\n    o = texelFetch(iChannel0, ivec2(u), 0);\n    \n    setMat3(getMat3(0), 5, o);\n    vec3 p = getVec3(3);\n    setVec3(p, 8, o);\n    \n\n    // == mouse control ====================================\n    \n    vec3 v = iFrame == 0 ? normalize(vec3(0.,-1.,0.)) : getVec3(4);\n    const float sensitivity = 2.;\n    if(sign(iMouse.z) == -1. && sign(iMouse.w) == -1.) {\n        if(v.z > 0.) {\n            v.z = -1.;\n            v.xy += (iMouse.xy+iMouse.zw) * sensitivity/iResolution.y;\n        }\n    } else {\n        v.z = 1.;\n    }\n    setVec3(v, 4, o);\n    \n    vec2 rot = v.xy;\n    if(iMouse.z > 0.) {\n        rot += (iMouse.xy-abs(iMouse.zw)) * sensitivity/iResolution.y;\n    }\n    \n    \n    \n    \n    // == rotation matrix =====================================\n    \n    vec2 c = cos(rot);\n    vec2 s = sin(rot);\n    mat3 rx = mat3(1, 0, 0, 0, c.y, -s.y, 0, s.y, c.y);\n    mat3 ry = mat3(c.x, 0, -s.x, 0, 1, 0, s.x, 0, c.x);\n    mat3 cam = ry * rx;\n    \n    // == keyboard control ====================================\n    \n    p = iFrame==0 ? vec3(0.,2.,-1.5) : p;\n    vec3 m = vec3(0);\n    if(keyClick(FORWARD ) || keyClick(ARROW_UP)) m += cam * vec3(0, 0, 1);\n    if(keyClick(BACKWARD) || keyClick(ARROW_DOWN)) m -= cam * vec3(0, 0, 1);\n    if(keyClick(UP      )) m += vec3(0, 1, 0);\n    if(keyClick(DOWN    )) m -= vec3(0, 1, 0);\n    if(keyClick(RIGHT   ) || keyClick(ARROW_RIGHT)) m += cam * vec3(1, 0, 0);\n    if(keyClick(LEFT    ) || keyClick(ARROW_LEFT)) m -= cam * vec3(1, 0, 0);\n    if(dot(m, m) > 0.) {\n        p += normalize(m)*iTimeDelta;\n    }\n    p.y = max(p.y, .01);\n    \n    \n    setMat3(cam, 0, o);\n    setVec3(p, 3, o);\n    \n    vec3 res = getVec3(10);\n    \n    if(res == iResolution) {\n        return;\n    }\n    \n   \n    \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This shader was made by 104\n// link : https://www.shadertoy.com/view/ltj3Wc\n\n\n// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\n// from \"Magic Fractal\" by dgreensp\n// https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\n\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\n//vec2 hash( vec2 p )\n//{\n//\tp = vec2( dot(p,vec2(127.1,311.7)),\n//\t\t\t  dot(p,vec2(269.5,183.3)) );\n//\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n//}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 1.;//sin(iTime)*0.5 + 0.5;//iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60.;// + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n//    amt = 500.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= 0.4;\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvSignature = (fragCoord / iResolution.xy * 2.0) - 1.;\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\n    \n    vec3 col = vec3(1.,1.,0.875);// bg\n    float dist;\n    \n\t// geometry on display...\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\n                           vec2(-1.4, -.4+yo),\n                           vec2(2.6, -.4+yo), 0.3);\n\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\n                           vec2(1.3, 0.+yo),\n                           vec2(-2.9, 0.+yo), 0.03);\n\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\n                           vec2(-2.9, .3+yo), 0.1);\n\n\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\n                                vec2(0,0),// origin\n                                0.6,// radius\n                                0.2,// angle of brush start\n                                0.5,// sweep amt 0-1\n                                0.3,// width\n                                false);// clockwise\n    \n    // paint blotches\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n    col *= 1.-blotchAmt;\n    \n\t// signature\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\n\n    // grain\n    col.rgb += (rand(uv)-.5)*.08;\n    col.rgb = saturate(col.rgb);\n\n    \n    fragColor = vec4(col, 1.);\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}