{"ver":"0.1","info":{"id":"7dKGW1","date":"1631519062","viewed":91,"name":"loading weird","username":"HaleyHalcyon","description":"a","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n#define EASEO(x) (x*x-x*2.+1.)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// Fade function defined by Ken Perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// Corner vector for Perlin noise\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// Perlin generator.\n// Coordinates can loop an integer number of cells,\n// including in only 1 coordinate\n// * uv: coordinates\n// * offset: time from 0 to 1 (will loop around)\n// * loop: number of cells to loop around\nfloat perlin(vec2 uv, float offset, vec2 loop) {\n  // loop coordinates\n  if (loop.x > 0.) {uv.x = mod(uv.x, loop.x);}\n  if (loop.y > 0.) {uv.y = mod(uv.y, loop.y);}\n  vec2 i = floor(uv); // floored coordinates\n  vec2 n = floor(uv + 1.); // next coordinates\n  // loop next coordinates for wrap-around\n  if (loop.x > 0.) {n.x = mod(uv.x + 1., loop.x);}\n  if (loop.y > 0.) {n.y = mod(uv.y + 1., loop.y);}\n  // blending ratio\n  vec2 f = fract(uv);\n  vec2 u = fade(f);\n  offset = fract(offset);\n  // monstrous meta-mix expression\n  return\n  mix( // mix vertically\n    mix( // mix top horizontally\n      dot(cvec(i,              offset), f - vec2(0.0,0.0)),\n      dot(cvec(vec2(n.x, i.y), offset), f - vec2(1.0,0.0)),\n    u.x),\n    mix( // mix bottom horizontally\n      dot(cvec(vec2(i.x, n.y), offset), f - vec2(0.0,1.0)),\n      dot(cvec(n,              offset), f - vec2(1.0,1.0)),\n    u.x),\n  u.y);\n}\n\n// Reverse lerp and keeps the value between 0. and 1.\nfloat map(float vmin, float vmax, float v) {\n    return clamp(\n        (v-vmin)/(vmax-vmin), // reverse lerp\n        0., 1. // clamp\n    );\n}\n\nfloat orbits(vec2 uv, float dist, float angle, float scale){\n    vec2 center = vec2(cos(angle * TAU), sin(angle * TAU)) * dist;\n    float d = EASEO(clamp(0., 1., distance(uv, center) / scale));\n    return d + EASEO(clamp(0., 1., distance(uv, -center) / scale));\n}\n\nfloat timeRadius(float time) {\n    return EASEO(\n        map(0.12, 0.02, time)\n    ) + EASEO( \n        map(0.38, 0.48, time)\n    ) - 2.;\n}\n\nfloat timeAngle(float time) {\n    float t_ = fract(time - 0.25) - 0.5;\n    return 0.18 * tan(t_ * TAU / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / 3.0);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    \n    const float offset = 0.03;\n    const float angleOffset = 0.03;\n    float brightness = 0.;\n    for (int i = 0; i < 8; i++) {\n        float timeRadius_ = timeRadius(\n                fract(time - float(i) * offset)\n            );\n        brightness += orbits(\n            uv,\n            0.5 * timeRadius_, timeAngle(\n                fract(time - float(i) * offset)\n            ) - float(i) * angleOffset,\n            0.25 - 0.01 * float(i) + timeRadius_ * .1\n        ) * (-timeRadius_ + 0.5);\n    }\n    \n    float thres = 0.3;\n    thres += 0.15 * perlin((uv - 0.2) * 8.0, time, vec2(0.0));\n    thres += 0.03 * perlin(uv * 18.8, time * 2., vec2(0.0));\n    \n\n    // Time varying pixel color\n    vec3 col = mix(\n        HEX(0x202060),\n        HEX(0xa080ff),\n        smoothstep(thres, thres + 0.05, brightness)\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}