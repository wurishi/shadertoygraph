{"ver":"0.1","info":{"id":"mlffW7","date":"1693021498","viewed":19,"name":"2 sided arrow - triangular prism","username":"Salmon117","description":"my implementation of a 2 sided arrow. shader inputs from https://iquilezles.org/articles/distfunctions/ used, as I had issues with creating user input/rotation on my other shader i was creating. I flipped the triangular prism, and combined others","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["arrow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1\n#endif\n\n// Code adapted from https://iquilezles.org/ , modified for specific scene\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTriPrismFlipped( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = -p.y + 1.0 / k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n//float sdCylinder( vec3 p, vec2 h )\n//{\n//    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n//    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n//}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    // Adjust the position and height of the cylinder\n    p.y -= 0.05;  // Move the cylinder up\n\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n#define ZERO (min(iFrame,0))\n\n//vec2 map( in vec3 pos )\n//{\n    //vec2 res = vec2( pos.y, 0.0 );\n    \n    // top prism\n    //res = opU( res, vec2( sdTriPrism( pos-vec3(0.0,0.6,-0.2), vec2(0.15,0.05) ),43.5 ) );\n    \n    // bottom prism\n    // middle value in vec3 represents the height\n    //res = opU( res, vec2( sdTriPrismFlipped( pos-vec3(0.0,0.05,-0.2), vec2(0.15,0.05) ),43.5 ) );\n    \n    // central cylinder\n  //  res = opU( res, vec2( sdCylinder( pos + vec3(0.0, 0.1, 0.0) -vec3(0.0,0.1,-0.2), vec2(0.025,0.5) ), 3.0 ) );\n    \n//    return res;\n//}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( pos.y, 0.0 );\n    \n    // top prism\n    res = opU( res, vec2( sdTriPrism( pos-vec3(0.0,0.65,-0.2), vec2(0.15,0.05) ),43.5 ) );\n    \n    // bottom prism\n    // middle value in vec3 represents the height\n    res = opU( res, vec2( sdTriPrismFlipped( pos-vec3(0.0,0.15,-0.2), vec2(0.15,0.05) ),43.5 ) );\n    \n    // central cylinder\n    res = opU( res, vec2( sdCylinder( pos + vec3(0.0, 0.2, 0.0) -vec3(0.0,0.2,-0.2), vec2(0.025,0.5) ), 3.0 ) );\n    \n    // Avoid intersection with the ground plane\n    res = opU( res, vec2( pos.y + 2.0, 8.0 ) ); // Prevent intersection with the ground\n    \n    return res;\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 2.0;\n    float tmax = 20.0;\n      \n    //vec2 tb = vec2(0.75, -0.5);\n    vec2 tb = iBox( ro - vec3(0.5,0.5,0.5), rd, vec3(2.5,0.7,1.0) );\n    \n    if( tb.x <tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro + rd * t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t, h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n     // background\n    vec3 col = vec3(0.6, 0.6, 0.6) - max(rd.y,0.0);\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        \n\t\tvec3 lin = vec3(0.0);\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.7), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 1.0, 0.2, 0.5 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.2, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n        const float fl = 3.5;\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n#endif \n    fragColor = vec4( tot, 0.0 );\n}","name":"Image","description":"","type":"image"}]}