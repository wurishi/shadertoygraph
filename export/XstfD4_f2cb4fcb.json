{"ver":"0.1","info":{"id":"XstfD4","date":"1525183336","viewed":165,"name":"number printer compact","username":"akhgary","description":"this is the smaller and more optimized version of my previous printer.\n\nhttps://www.shadertoy.com/view/4sdfW4\n\n i think its still resource hungry because of 30 iterations there...","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["text","number","numbers","map","string","digit","table","digits","show","print"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ==========================================\n// Digit printer short version of\n//\n// https://www.shadertoy.com/view/4sdfW4\n// ==========================================\n//\n// in this version once you find the bitmasks,\n// reverse each row, then put them in order.\n// i'll lable each bitmask with a letter to make it eaiser to understand\n//\n// 01110  A\n// 10011  B\n// 10101  C\n// 11001  D\n// 10001  E\n// 01110  F\n//\n// should become\n//\n//   A     B     C     D     E     F     (base 10)\n// 01110 11001 10101 10011 10001 01110 = 496684590\n//\n// notice that each label was reversed before putting them in.\n// for example D was 11001 and became 10011\n// ==========================================\n// rectangle drawing:\n// https://thebookofshaders.com/07/\n// ==========================================\n\nconst float scale = 1.;\n\nconst float width = 1.;\nconst float height = 1.;\nconst vec2 position = vec2(0);\n\nint[] table = int[](\n496684590,  // 0\n140644494,  // 1\n487854175,  // 2\n1057374766, // 3\n281356264,  // 4\n1041744430, // 5\n471320110,  // 6\n1057230980, // 7\n488064558,  // 8\n488176142   // 9\n);\n\nvec2 uvmap(vec2 uv){\n    return (2.*uv-iResolution.xy)/iResolution.y;\n}\n\nfloat rect(vec2 uv, vec2 p0, vec2 offset){\n    vec2 lb = step(p0,uv), ub = 1.-step(p0+offset,uv);\n    return lb.x*lb.y*ub.x*ub.y;\n}\n\n//    print(uv, center, width, height, index)\nfloat print(vec2 uv, vec2 c, float w, float h, int ind)\n{\n    float r = 0.;\n    vec2 wh = vec2(w/5.,h/6.);\n    vec2 o =  vec2(w,h)/2.; // origin\n    vec2 bmin=c-o, bmax=c+o; // min and max boundaries\n    \n    // no need to render ouside boundaries.\n    if(uv.x<bmin.x||uv.y<bmin.y|| \n       uv.x>bmax.x||uv.y>bmax.y) return 0.;\n    \n    c = bmin; // move center to the origin\n    int map = table[ind];\n    for(int i=0;i<30;i++){\n        if(((map&(1<<i))>>i)==1) \n            r += rect(uv,c+wh*vec2(mod(float(i),5.),float(i/5)),wh);\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n    vec3 col = vec3(0);\n    \n    int d = int(mod(iTime,10.));\n    col += print(uv,position,width,height,d);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}