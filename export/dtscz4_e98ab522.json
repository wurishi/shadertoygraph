{"ver":"0.1","info":{"id":"dtscz4","date":"1690482977","viewed":93,"name":"Historical clock","username":"DantesPlan","description":"a historical watch","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["time","clock","historic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define SHADERTOY\n\n#ifdef SHADERTOY\n#define resolution iResolution\n#define time iTime\n#define data iDate\n#endif\n\n#ifndef SHADERTOY\nuniform vec2 resolution;\nuniform float time;\nuniform vec4 date;\n#define iResolution resolution\n#define iTime time\n#define iDate date\n#endif\n\n#define PI 3.141592\n#define TWOPI 6.28318530717958648\n#define HALFPI 1.5707963267948966\n\nvec2 rotateUV(vec2 uv, vec2 pivot, float angle)\n{\n\tfloat x = cos(angle) * (uv.x - pivot.x) + sin(angle) * (uv.y - pivot.y) + pivot.x;\n\tfloat y = cos(angle) * (uv.y - pivot.y) - sin(angle) * (uv.x - pivot.x) + pivot.y;\n\treturn vec2(x,y);\n}\n\n// found at https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine(in vec2 p,in vec2 a,in vec2 b,in float w)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length(pa - ba*h)-w;\n}\n\nfloat sdCircle(vec2 uv,vec2 pos,float radius)\n{\n\treturn length(uv-pos)-(radius*0.5);\n}\n\nfloat sdRing(vec2 uv,vec2 pos,float radius,float width)\n{\n\treturn smoothstep(0.0, width, abs(length(uv-pos) - radius * 0.5));\n}\n\nfloat sdSquare(vec2 uv,vec2 offset,vec2 size)\n{\n\treturn max(abs(uv.x - offset.x) - size.x, abs(uv.y - offset.y) - size.y);\n}\n\nfloat sdParallelogram(in vec2 p,float wi,float he,float sk)\n{\n\tvec2 e = vec2(sk,he);\n\tfloat e2 = sk*sk + he*he;\n\n\tp = (p.y<0.0)?-p:p;\n\n\t// horizontal edge\n\tvec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n\tvec2  d = vec2(dot(w,w), -w.y);\n\n\t// vertical edge\n\tfloat s = p.x*e.y - p.y*e.x;\n\tp = (s<0.0)?-p:p;\n\tvec2 v = p - vec2(wi,0);\n\tv -= e*clamp(dot(v,e)/e2,-1.0,1.0);\n\td = min(d, vec2(dot(v,v), wi*he-abs(s)));\n\n\treturn sqrt(d.x)*sign(-d.y);\n}\n\n// found at https://andorsaga.wordpress.com/2018/06/26/sdfs-rendering-a-rectangle/\nfloat sdRect(vec2 st,vec2 pos,vec2 size,float bVal)\n{\n\treturn smoothstep(bVal+0.0001,0.0,length(max(abs(st-pos)-size,0.0)));\n}\n\n// found at https://www.shadertoy.com/view/7tj3Wz\nfloat sdRhombus(vec2 st,vec2 pos,vec2 size,float bVal)\n{\n\tst -= pos;\n\n\tst = abs(st);\n\tst.x -= size.x;\n\n\tfloat f = clamp( (st.y-st.x)/(size.y+size.x), 0.0, 1.0 );\n\n\tvec2 q = abs(st-f*vec2(-size.x,size.y));\n\tfloat result = max(q.x,q.y)*((size.y*st.x+size.x*st.y>0.0)?1.0:-1.0);\n\n\t//return step(result, 0.0);\n\treturn smoothstep(bVal+0.001,0.0,result);\n}\n\nfloat romanNumerals(vec2 uv,vec2 pos,vec2 size,float angle,int num)\n{\n\tfloat n = 1.0;\n\n\tuv -= pos;\n\tuv /= size;\n\n\tuv = rotateUV(uv,vec2(0.0),-HALFPI+angle);\n\n\tif(num==1)\n\t{\n\t\tn = sdSquare(uv,vec2(0.0),vec2(0.35,2.0));\n\t}\n\telse if(num==2)\n\t{\n\t\tn = sdSquare(uv+vec2(0.6,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdSquare(uv-vec2(0.6,0.0),vec2(0.0),vec2(0.35,2.0)));\n\t}\n\telse if(num==3)\n\t{\n\t\tn = sdSquare(uv+vec2(1.2,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdSquare(uv,vec2(0.0),vec2(0.35,2.0)));\n\t\tn = min(n,sdSquare(uv-vec2(1.2,0.0),vec2(0.0),vec2(0.35,2.0)));\n\t}\n\telse if(num==4)\n\t{\n\t\tn = sdSquare(uv+vec2(1.8,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdParallelogram(uv-vec2(1.2,0.0),0.4,2.0,0.6));\n\t\tn = min(n,sdParallelogram(uv-vec2(0.0,0.0),0.4,2.0,-0.6));\n\t}\n\telse if(num==5)\n\t{\n\t\tn = sdParallelogram(uv-vec2(0.6,0.0),0.4,2.0,0.6);\n\t\tn = min(n,sdParallelogram(uv+vec2(0.6,0.0),0.4,2.0,-0.6));\n\t}\n\telse if(num==6)\n\t{\n\t\tn = sdSquare(uv-vec2(1.8,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdParallelogram(uv+vec2(0.0,0.0),0.4,2.0,0.6));\n\t\tn = min(n,sdParallelogram(uv+vec2(1.2,0.0),0.4,2.0,-0.6));\n\t}\n\telse if(num==7)\n\t{\n\t\tn = sdSquare(uv-vec2(1.2,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdSquare(uv-vec2(2.4,0.0),vec2(0.0),vec2(0.35,2.0)));\n\t\tn = min(n,sdParallelogram(uv+vec2(0.6,0.0),0.4,2.0,0.6));\n\t\tn = min(n,sdParallelogram(uv+vec2(1.8,0.0),0.4,2.0,-0.6));\n\t}\n\telse if(num==8)\n\t{\n\t\tn = sdSquare(uv-vec2(0.6,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdSquare(uv-vec2(1.8,0.0),vec2(0.0),vec2(0.35,2.0)));\n\t\tn = min(n,sdSquare(uv-vec2(3.0,0.0),vec2(0.0),vec2(0.35,2.0)));\n\t\tn = min(n,sdParallelogram(uv+vec2(1.2,0.0),0.4,2.0,0.6));\n\t\tn = min(n,sdParallelogram(uv+vec2(2.4,0.0),0.4,2.0,-0.6));\n\t}\n\telse if(num==9)\n\t{\n\t\tn = sdSquare(uv+vec2(1.6,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdParallelogram(uv-vec2(0.6,0.0),0.4,2.0,1.0));\n\t\tn = min(n,sdParallelogram(uv-vec2(0.6,0.0),0.4,2.0,-1.0));\n\t}\n\telse if(num==10)\n\t{\n\t\tn = sdParallelogram(uv,0.4,2.0,1.0 );\n\t\tn = min(n,sdParallelogram(uv,0.4,2.0,-1.0));\n\t}\n\telse if(num==11)\n\t{\n\t\tn = sdSquare(uv-vec2(1.6,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdParallelogram(uv+vec2(0.6,0.0),0.4,2.0,1.0));\n\t\tn = min(n,sdParallelogram(uv+vec2(0.6,0.0),0.4,2.0,-1.0));\n\t}\n\telse if(num==12)\n\t{\n\t\tn = sdSquare(uv-vec2(1.0,0.0),vec2(0.0),vec2(0.35,2.0));\n\t\tn = min(n,sdSquare(uv-vec2(2.2,0.0),vec2(0.0),vec2(0.35,2.0)));\n\t\tn = min(n,sdParallelogram(uv+vec2(1.2,0.0),0.4,2.0,1.0));\n\t\tn = min(n,sdParallelogram(uv+vec2(1.2,0.0),0.4,2.0,-1.0));\n\t}\n\t//return step(0.1,n);\n    return smoothstep(0.0,1.0,n);\n}\n\nvec4 clockNumbers(vec2 uv)\n{\n\tvec4 layer = vec4(0.0);\n\tfloat n = 0.0;\n\n\tif(length(uv) < 0.166 && (length(uv)) > 0.123)\n\t{\n\t\tuv = rotateUV(uv,vec2(0.0),-1.82);\n\n\t\tfloat num = 12.0;\n\t\tfloat angle = (atan(uv.y, uv.x) + PI) / TWOPI * num;\n\t\tfloat id = floor(angle);\n\t\tfloat baseAngle = id / num * TWOPI + PI;\n\n\t\tvec2 ruv = rotateUV(uv, vec2(0.0), (baseAngle + 0.245));\n\n\t\tfloat angleTmp = HALFPI;\n\t\tint numTmp = int(num-id);\n\t\tif(numTmp>3 && numTmp<9) angleTmp = -angleTmp;\n\n\t\truv = rotateUV(ruv,vec2(0.2),-HALFPI);\n\n\t\tn = romanNumerals(ruv,vec2(0.4,0.144),vec2(0.009), angleTmp, numTmp);\n\n\t\tvec4 numLayer = vec4(vec3(0.0),smoothstep(0.1,0.0,n));\n\n\t\tlayer = mix(layer,numLayer,numLayer.a);\n\n\t\t// debug\n\t\t/*\n\t\tvec4 idLayer = vec4(vec3(id/num),1.0);\n\t\tidLayer = pow(idLayer,vec4(0.5));\n\t\tlayer = mix(idLayer,layer,layer.a);\n\t\t*/\n\t}\n\treturn layer;\n}\n\nvec4 clockFace(vec2 uv)\n{\n\tvec4 layer = vec4(0.0);\n\tfloat r = 0.408;\n\n\tfloat d = sdCircle(uv,vec2(0.0),r);\n\n\t//layer = (d>0.0015) ? vec4(0.0) : vec4(vec3(1.0), smoothstep(0.005, -0.00125, d));\n\tlayer = (d>0.0015) ? vec4(0.0) : vec4(3.0*vec3(r-distance(uv*1.5,vec2(0.0))), smoothstep(0.005, -0.00125, d));\n\t//layer = (d>0.0015) ? vec4(0.0) : vec4(1.1-vec3((length(uv*4.0)-0.01)), smoothstep(0.005, -0.00125, d));\n\n\treturn layer;\n}\n\nvec4 clockLines(vec2 uv)\n{\n\tvec4 layer = vec4(0.0);\n\n\tfloat line=1.0,angle,numLines=6.0;\n\n\tfor(float i=0.0;i<numLines;i++)\n\t{\n\t\tangle = (PI / (numLines*2.0)) + (TWOPI * i / (numLines*2.0));\n\t\tline = min(line,sdLine(rotateUV(uv,vec2(0.0),angle),vec2(0.0,-0.2),vec2(0.0,0.2),0.0005));\n\t}\n\n\tlayer = (line>0.0015) ? vec4(0.0) : vec4(vec3(0.0),smoothstep(0.001,0.0, line));\n\n\treturn layer;\n}\n\nvec4 clockRings(vec2 uv)\n{\n\tvec4 layer = vec4(0.0);\n\tfloat d = 0.0,rw = 0.1;\n\n\td = sdRing(uv,vec2(0.0),0.4,rw);\n\td = min(d,sdRing(uv,vec2(0.0),0.37,rw));\n\td = min(d,sdRing(uv,vec2(0.0),0.2,rw));\n\td = min(d,sdRing(uv,vec2(0.0),0.05,rw));\n\n\tlayer = (d>0.0015) ? vec4(0.0) : vec4(vec3(0.0),smoothstep(0.001,0.0, d));\n\n\treturn layer;\n}\n\nvec4 clockMarks(vec2 uv)\n{\n\tvec4 layer = vec4(0.0);\n\tvec2 duv = uv;\n\tfloat mark = 1.0;\n\n\tfloat radius = 0.385;\n\tfloat numMarks = 60.0;\n\tfloat at = atan(uv.y, uv.x);\n\tfloat i = floor((at * numMarks / TWOPI) + 0.5);\n\tfloat angle = (TWOPI / numMarks) * i;\n\n\tif(mod(i,5.0)==0.0)\n\t\tmark = min(mark,sdCircle(uv,vec2(cos(angle),sin(angle))*radius*0.5, 0.006));\n\telse\n\t\tmark = min(mark,sdCircle(uv,vec2(cos(angle),sin(angle))*radius*0.5, 0.003));\n\n\tnumMarks = 12.0;\n\tfloat r, width;\n\tfloat a = mod(atan(uv.x,uv.y),TWOPI/numMarks) - TWOPI / (numMarks * 2.0);\n\tuv = vec2(sin(a),cos(a)) * length(uv);\n\tr = 0.185; width = 0.003;\n\tmark = min(mark,length(uv-vec2(0.0,r)) - width);\n\tr = 0.1;\n\n\tmark = min(mark, length(uv-vec2(0.0,r)) - width);\n\tmark = min(mark, smoothstep(0.0,0.1,length(duv)-0.015));\n\n\tlayer = (mark>0.0015) ? vec4(0.0) : vec4(vec3(0.0),smoothstep(0.001,0.0, mark));\n\n\treturn layer;\n}\n\nvec4 clockHandShape(in vec2 st,vec2 pos,vec2 size,int type)\n{\n\tvec4 layer=vec4(0.0);\n\n\tst -= pos;\n\tst /= size;\n\n\tfloat blurVal=0.008,shResult=0.0;\n\n\tfloat angle=0.0;\n\tfloat h = -(TWOPI*(iDate.w/3600.0/12.0));\n\tfloat m = mod(floor(iDate.w/60.0),60.0);\n\tfloat s = mod(floor(iDate.w),60.0);\n\n\t// Hour\n\tif(type==0)\n\t{\n\t\tangle = (iDate.w<=0.0)?sin(iTime*0.5)*PI+PI:h;\n\t\tvec2 huv = rotateUV(st,vec2(0.0),angle);\n\n\t\tif(abs(huv.x)*size.x>(size.x*0.11)||abs(huv.y-0.45)*size.y>(size.y*0.87)) return vec4(0.0);\n\n\t\tshResult = sdRhombus(huv,vec2(0.0,-0.2),vec2(0.05,0.2),blurVal);\n\t\tshResult = max(shResult,sdRhombus(huv,vec2(0.0,0.4),vec2(0.1,0.625),blurVal));\n\t\tshResult = max(shResult,sdRhombus(huv,vec2(0.0,1.0),vec2(0.085,0.3),blurVal));\n\t}\n\t// Minute\n\tif(type==1)\n\t{\n\t\tangle = (iDate.w<=0.0)?cos(iTime*0.25)*TWOPI:-(TWOPI*m/60.0);\n\t\tvec2 muv = rotateUV(st,vec2(0.0),angle);\n\n\t\tif(abs(muv.x)*size.x>(size.x*0.11)||abs(muv.y-0.55)*size.y>(size.y)) return vec4(0.0);\n\n\t\tshResult = sdRhombus(muv,vec2(0.0,-0.28),vec2(0.05,0.15),blurVal);\n\t\tshResult = max(shResult,sdRhombus(muv,vec2(0.0,0.55),vec2(0.09,0.9),blurVal));\n\t\tshResult = max(shResult,sdRhombus(muv,vec2(0.0,1.33),vec2(0.05,0.2),blurVal));\n\t}\n\t// Second hand\n\tif(type==2)\n\t{\n\t\tangle = (iDate.w <= 0.0) ? sin(iTime*0.75)*TWOPI : -(TWOPI*s/60.0);\n\t\tvec2 suv = rotateUV(st, vec2(0.0), angle);\n\n\t\tif(abs(suv.x)*size.x>(size.x*0.035)||abs(suv.y-0.55)*size.y>(size.y)) return vec4(0.0);\n\n\t\tshResult = sdRhombus(suv,vec2(0.0,-0.34),vec2(0.02,0.1),blurVal);\n\t\tshResult = max(shResult,sdRect(suv,vec2(0.0,0.6),vec2(0.0075,0.9),blurVal));\n\t\tshResult = max(shResult,sdRhombus(suv,vec2(0.0,1.44),vec2(0.02,0.1),blurVal));\n\t}\n\n\tlayer = vec4(shResult);\n\t//layer = (shResult>0.0) ? vec4(vec3(1.0),shResult) : vec4(0.0);\n\n\treturn layer;\n}\n\nvoid drawStaticClockface(vec2 uv, vec2 pos, float size, inout vec4 layer)\n{\n\tuv -= pos;\n\tuv /= size;\n\n\tvec4 clockBackground = clockFace(uv);\n\tvec4 clockLinesLayer = clockLines(uv);\n\tvec4 clockRingsLayer = clockRings(uv);\n\tvec4 clockMarksLayer = clockMarks(uv);\n\tvec4 clockNumbersLayer = clockNumbers(uv);\n\n\tlayer = mix(vec4(0.0),clockBackground,clockBackground.a);\n\tlayer = mix(layer,clockLinesLayer,clockLinesLayer.a);\n\tlayer = mix(layer,clockRingsLayer,clockRingsLayer.a);\n\tlayer = mix(layer,clockMarksLayer,clockMarksLayer.a);\n\tlayer = mix(layer,clockNumbersLayer,clockNumbersLayer.a);\n}\n\nvec4 drawHistoricClock(vec2 uv, vec2 pos, float size)\n{\n\tvec4 layer = vec4(0.0);\n\n\tvec2 huv = uv;\n\n\tuv -= pos;\n\tuv /= size;\n/*\n\tvec4 clockBackground = clockFace(uv);\n\tvec4 clockLinesLayer = clockLines(uv);\n\tvec4 clockRingsLayer = clockRings(uv);\n\tvec4 clockMarksLayer = clockMarks(uv);\n\tvec4 clockNumbersLayer = clockNumbers(uv);\n\n\tlayer = mix(layer,clockBackground,clockBackground.a);\n\tlayer = mix(layer,clockLinesLayer,clockLinesLayer.a);\n\tlayer = mix(layer,clockRingsLayer,clockRingsLayer.a);\n\tlayer = mix(layer,clockMarksLayer,clockMarksLayer.a);\n\tlayer = mix(layer,clockNumbersLayer,clockNumbersLayer.a);\n*/\n\tlayer = mix(layer, vec4(vec3(0.0),1.0), clockHandShape(huv,vec2(0.5),vec2(0.0925)*size,0).a);\n\tlayer = mix(layer, vec4(vec3(0.0),1.0), clockHandShape(huv,vec2(0.5),vec2(0.115)*size,1).a);\n\tlayer = mix(layer, vec4(vec3(0.0),1.0), clockHandShape(huv,vec2(0.5),vec2(0.122)*size,2).a);\n\n\treturn layer;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy-0.5*resolution.xy)/min(resolution.x,resolution.y)+0.5;\n\n\tfloat scaleFactor = (iResolution.x < iResolution.y) ? 2.25 : 2.0;\n\n    // update\n    drawStaticClockface(uv, vec2(0.5), scaleFactor, fragColor);\n\n\tvec4 historicClockLayer = drawHistoricClock(uv, vec2(0.5), scaleFactor);\n\n\tfragColor = mix(fragColor,historicClockLayer,historicClockLayer.a);\n}\n\n#ifndef SHADERTOY\nvoid main(void)\n{\n\tmainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}