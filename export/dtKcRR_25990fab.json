{"ver":"0.1","info":{"id":"dtKcRR","date":"1699901674","viewed":494,"name":"Sphere Texture Coordinate Study","username":"userman","description":"Mapping colors based on texture coordinates to study how textures and such can be layed out on a sphere.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere","textures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 origin = vec3(0.0, 0.0, 0.0);\nconst float dof = 1.0; \nconst float vw = 2.0; \nconst float vh = 1.0;\nconst vec4 BACKGROUND_COLOR = vec4(0.0, 0.0, 0.0, 1.0);\nconst float PI = 3.14159;\n\nstruct Sphere {\n    vec3 c;\n    float r;\n};\n\n\nstruct Ray {\n    vec3 a;\n    vec3 b;   \n};\n\n\nfloat checkIntersect(Ray ray, Sphere sp) {  // intersection test with the equation (p-c)2 = r2\n\n    float A = dot(ray.b, ray.b);\n    float B = 2.0 * dot(ray.b, (ray.a - sp.c));\n    float C = dot(ray.a - sp.c, ray.a - sp.c) - sp.r * sp.r;\n    \n\n    float discrim = B * B - 4.0 * A * C;\n    \n    \n    \n    if (discrim <= 0.0001) {\n        return -1.0;\n    }\n    \n    float sqrtd = sqrt(discrim);\n\n    float neg = (-B - sqrtd) / 2.0 * A;\n    float pos = (-B + sqrtd) / 2.0 * A;\n    \n    return min(neg, pos);\n    \n}\n\n\nRay makeRay(vec2 fragCoord) {\n    vec2 halfIRes = iResolution.xy * 0.5;\n    vec2 uv = (fragCoord - halfIRes) / halfIRes; \n    uv.x *= iResolution.x / iResolution.y; \n\n    vec3 dir = vec3(uv.x, uv.y, dof);\n    dir = normalize(dir);\n\n    return Ray(origin, dir);\n}\n\nvec3 cartToPolar(vec3 c) {\n    float theta = atan(c.z, c.x);\n    float phi = atan(sqrt(c.x * c.x + c.z * c.z), c.y);\n    \n    return vec3(length(c), theta, phi);\n}\n\n\nvec2 polarTo2DCoords(vec3 polar, vec2 widthHeight) {\n    return vec2(\n        int(((polar.y + PI) / 2.0 / PI) * widthHeight.x), // parens for readability\n        int((polar.z / PI) * widthHeight.y));\n}\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.8, 0.8, 0.8);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(.2);\n    vec3 d = vec3(0.,0.3,0.5);\n\n    return min(a + b*cos(6.28318*(c*t+d)), 1.0);\n}\n\nvec3 movePolar(vec3 polar, float x, float y) {\n    // polar.x is the radius, polar.y is theta, polar.z is phi\n\n    // Rotate theta around the Y axis\n    float newTheta = polar.y + x;\n\n    // Rotate phi around the X axis\n    float newPhi = polar.z + y;\n\n    // Ensure the angles stay within their respective ranges\n    newTheta = mod(newTheta, 2.0 * 3.14159265); // Normalize theta to [0, 2PI)\n    newPhi = clamp(newPhi, 0.0, 3.14159265);    // Clamp phi to [0, PI]\n\n    return vec3(polar.x, newTheta, newPhi);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) \n{\n    \n    // make and position point light, sphere, ray.\n    Sphere sp = Sphere(vec3(0.0, 0.0, 5.0), 3.0);\n    Ray ray = makeRay(fragCoord);\n    \n    \n    // check for some t, if there is a t such that (t < 0), the ray has an intersection\n    float t = checkIntersect(ray, sp);\n    \n    if (0.0 < t) {\n    \n        vec3 p = ray.a + ray.b * t;\n        vec3 n = normalize(p - sp.c);\n        \n        vec3 v = p - sp.c;\n        vec3 polar = cartToPolar(v);\n        \n        \n        vec2 p2d = polarTo2DCoords(polar, vec2(500, 500));\n        \n       \n        vec3 col1 = palette(iTime * 9.0+  p2d.x);\n        vec3 col2 = palette(iTime + p2d.y);\n        \n        fragColor = vec4(col1 * col2, 1.0);\n        return;\n        \n    } else {\n    \n       fragColor = BACKGROUND_COLOR;\n\n   }\n   \n}","name":"Image","description":"","type":"image"}]}