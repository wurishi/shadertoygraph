{"ver":"0.1","info":{"id":"ftS3zG","date":"1624119167","viewed":1127,"name":"The Dark Mark [HP]","username":"Yusef28","description":"Inspiration: [url]https://pottermore.fandom.com/wiki/The_Dark_Mark_(object)?file=Screenshot_-_10_5_2013_%252C_3_57_20_PM.png[/url]\nOriginal Cloud Shader: [url]https://www.shadertoy.com/view/MljXDw[/url]\n","likes":40,"published":1,"flags":64,"usePreview":0,"tags":["clouds","sky","volumetric","snake","glow","stars","night","scary","skull","skull","teeth","harrypotter","schadel","darkmark","schlange","harry"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ltlXRs","filepath":"https://soundcloud.com/user-17441338/forest-at-night-crickets-owls-rain-wind-in-trees-nature-sounds-to-relax-stud","previewfilepath":"https://soundcloud.com/user-17441338/forest-at-night-crickets-owls-rain-wind-in-trees-nature-sounds-to-relax-stud","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0},{"id":"lllSzs","filepath":"https://soundcloud.com/thebirthdaymassacre/black","previewfilepath":"https://soundcloud.com/thebirthdaymassacre/black","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define SCATTERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n\n/* original noise\nfloat pn(vec3 p) {\n   vec3 i = floor(p);\n   vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n   vec3 f = cos((p-i)*pi)*(-.5) + .5;\n   a = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n   a.xy = mix(a.xz, a.yw, f.y);\n   return mix(a.x, a.y, f.z);\n}\n*/\n\nfloat glow = 0.;\nfloat glow2 = 0.;\n// iq's noise\n\nfloat hash(vec2 p) {\n return fract(sin(dot(p*0.05, vec2(14.52, 76.38)))*43256.2895);   \n}\n\nvec3 hash13( float n )\n{\n    vec3 m = n*vec3(23.0,41.0,17.0) + vec3(9.0,1.0,31.0);\n    return fract( m*fract( m*0.3183099 ) );\n}\n\n\n\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(vec2 st)\n    {\n    float f = noise(st)*1.;st*=2.02;\n     f += noise(st)*0.5;st*=2.04;\n     f += noise(st)*0.25;st*=2.03;\n     f += noise(st)*0.125;st*=2.04;\n     f += noise(st)*0.0625;///st*=2.01;\n    \nreturn f;\n}\n\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n#define FAR 55.\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\n// https://www.shadertoy.com/view/tl23RK\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat knochen(vec3 p, vec3 xyz, vec3 dim, float th, float phi, float ga, \n                float spiegel, float r){\n    \n    vec3 sp = p - xyz;\n    sp.x = abs(sp.x) - spiegel;\n    \n    float cs = cos(th), si = sin(th);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    cs = cos(phi), si = sin(phi);\n    sp.xz*= mat2(cs, si, -si, cs);\n    \n    cs = cos(ga), si = sin(ga);\n    sp.xy*= mat2(cs, si, -si, cs);\n        \n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - r;    \n}\n\nfloat sdCircleCircle( in vec3 p, in int n, float zeichen){\nfloat a0 = float(n) / radians(360.); \nfloat a = round(atan(p.z, p.x) * a0) / a0;\nvec3 sp = p - vec3(cos(a), 0.0, sin(a));\n  \nfloat cs = cos(a), si = sin(a);//erste versuch!!!!\nsp.xz*=mat2(cs, si, -si, cs);\n  \ncs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!\nsp.xy*=mat2(cs, si, -si, cs);\n    \nsp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, 0.19, 0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen);\nreturn min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.02;  \n\n    \n    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    \n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\nfloat snake(vec3 pos)\n{\n    //the max distance so this is a blank world before\n    //I start adding in torus\n    float alle = 100.;\n    //theta, sin and cos for rotation\n    float th, si, cs;\n    vec3 p; //tmp position\n\n     //Snake going through eye hole because that's edgy\n     //translate pos\n     p=pos+vec3(0.3,0.,.3);\n     th = 1.14;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     //th = 1.14;\n     //cs = cos(th), si = sin(th);\n     //p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 1.14;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     float an = 1.9;\n     //c is how that is applied to the torus \n     vec2 c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     float tmp = sdCappedTorus(p, c, .2, 0.1);\n     //add it in\n     alle = min(alle, tmp);\n     \n     //Snake going through mouth because that's edgy\n     //translate pos\n     p=pos+vec3(0.15,0.29,.5);\n     th = -1.;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = -.4;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 2.4;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 3.;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .25, 0.08);\n     //add it in\n     alle = min(alle, tmp);\n     \n     //Snake going through eye hole because that's edgy\n     //translate pos\n     p=pos+vec3(-0.25,0.85,.2);\n     th = -0.4;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = -0.6;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 1.5;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 2.;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .29, 0.06);\n     //add it in\n     alle = min(alle, tmp);\n        \n        \n     //Tail (h)whip\n     //translate pos\n     p=pos+vec3(-0.35,1.1,.3);\n     th = 3.8;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = 0.;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 1.5;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 1.9;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .25, 0.03);\n     //add it in\n     alle = min(alle, tmp);\n     \n     pos.y+=0.05;\n     //Upper Body\n     //translate pos\n     p=pos+vec3(-0.5,0.3,.27);\n     th = 1.2;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = 3.;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = -0.1;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 2.4;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .19, 0.1);\n     //add it in\n     alle = min(alle, tmp);\n     \n     \n     \n     //Neck Head\n     //translate pos\n     p=pos+vec3(-0.5, -0.03, .53);\n     th = 1.6;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = -.7;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = .3;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 1.2;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .2, 0.12);\n     //add it in\n     alle = smin(alle, tmp, 0.07);\n     \n     \n     pos*=0.9;\n     th = .0;\n     cs = cos(th), si = sin(th);\n     pos.yz = mat2(cs, si, -si, cs)*pos.yz;\n     \n     //shere for head\n     p=pos+vec3(-0.47, -0.17, .52);\n     \n     th = -.2;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     tmp = length(p)-0.25;\n     alle = smin(alle, tmp,0.03);\n     \n     \n     //shaping the head with minus sheres\n     p=pos+vec3(-0.5, -0.1, .59);\n     \n     th = -.1;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     p.x = abs(p.x)-0.13;\n     tmp = length(p)-0.218;\n     alle = smax(alle, -tmp, 0.05);\n     \n     p=pos+vec3(-0.5, -0.28, .7);\n     tmp = length(p)-0.03;\n     alle = smin(alle, tmp, 0.05);\n     \n     \n     //shaping the head with minus sheres\n     p=pos+vec3(-0.5, -0.1, .5);\n     \n     th = -.1;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     tmp = length(p)-0.2;\n     alle = smax(alle, -tmp, 0.05);\n     \n    //jaw\n    p=pos;\n    th = -.14;\n    p.y+=sin(p.z*30.-.6)/40.;\n    cs = cos(th), si = sin(th);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    tmp = knochen(p, vec3(0.4, 0.26, -.65), vec3(0.08, 0.01, 0.14), \n                -1.2, -0.35, -0., 0., 0.0);\n    alle = smin(alle, tmp, 0.1);\n    \n    //teeth / zhane\n    //upper\n    p=pos;\n    th = -.17;\n    cs = cos(th), si = sin(th);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    \n    tmp = knochen(p, vec3(0.38, 0.22, -.78), vec3(0.005, 0.04, 0.005), \n                -0., -0., -0., 0.04, 0.0);\n    alle = smin(alle, tmp, 0.01);\n    //lower\n    p=pos;\n    th = -.17;\n    cs = cos(th), si = sin(th);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    tmp = knochen(p, vec3(0.38, 0.22, -.7), vec3(0.005, 0.05, 0.005), \n                -0., -0., -0., 0.04, 0.0);\n    alle = smin(alle, tmp, 0.01);\n    \n    return alle;\n}\nfloat map(vec3 p){\n    \n    float PosX, PosY;\n    PosX = 3.14;// - iMouse.x/iResolution.x*8. + 1.5;//0.2*2.*(rechts - links);\n    PosY = -0.3;// - iMouse.y/iResolution.y*8. + 1.5;\n    \n    p.z+=1.;\n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    \n    \n\tp*=0.6;\n    \n    p.y-=0.2;\n    \n\n    \n    vec3 sp = p;\n    float k = length(sp*vec3(1., 0.95, 0.9)) - 0.5;\n    float alle = k;\n    \n    //schadel unten schneiden\n    sp = p;\n    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;\n    alle = smax(alle, -k, 0.09);\n    \n    \n    //schadel seite\n    sp = p;\n    sp.x = abs(sp.x) - 0.65;\n    k = length(sp - vec3(0., -0.05, -0.28)) - 0.3;\n    alle = smax(alle, -k, 0.09);\n\n    \n    \n    \n    //oben augen knochen\n    sp = p;\n    k = knochen(p, vec3(0., \n                        0. + cos(abs(sp.x)*8. + 5.)*0.05 - 0.04 , \n                        -0.48 - cos(abs(sp.x)*8. + 5.8)*0.05), \n                vec3(0.12, 0.005, 0.005), \n                0., 0., 0., 0.14, 0.04);\n    alle = smin(alle, k, 0.09);\n\n    \n    //oberest knochen\n    sp = p;\n    k = knochen(p, vec3(0., 0.15, -0.22), vec3(0.005, 0.005, 0.25), \n                -0.5, 0., 0., 0.28, 0.03);\n    alle = smin(alle, k, 0.09);\n    \n    //augen seit knochen\n    sp = p;\n    k = knochen(p, vec3(0., -0.15 , -0.48), vec3(0.005, 0.08, 0.02), \n                0.0, 0.0, 0.1, 0.3, 0.01);\n    alle = smin(alle, k, 0.07);\n    \n    //wangen knochen vor\n    sp = p;\n    k = knochen(p, vec3(0., -0.3, -0.45), vec3(0.13, 0.06, 0.05), \n                -0.3, -0.1, -0.2, 0.15, 0.03);\n    alle = smin(alle, k, 0.1);\n    \n    //wangen knochen seit\n    sp = p;\n    k = knochen(p, vec3(0., -0.33, -0.32), \n                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), \n                0., 0.1, 0., 0.32 + cos(sp.z*8. + 2.)*0.09, \n                0.03 + cos(sp.z*8. + 4.7)*0.015);\n    alle = smin(alle, k, 0.05);\n    \n    float zahnNum = 12.;\n    //cyl oben\n    sp = p - vec3(0., -0.43, -0.4);\n    k = sdCappedCylinder(sp, 0.17\n                         + cos(sp.y*12. -5.3)*0.05\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.06 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02);\n    alle = smin(alle, k, 0.08);\n    \n    //oben zhan\n    sp = p - vec3(0.0, -0.51, -0.41);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    k = sdCircleCircle(sp*5.4, 24, 1.);\n    float zahn = k;\n    \n    \n    \n\n    //augen loche\n    sp = p;\n    sp.x = abs(sp.x) - 0.16;\n    float loche = length(sp - vec3(0., -0.14, -0.4)) - 0.16;\n    alle = smax(alle, -loche, 0.07);\n    \n    //gluende augen\n    //sp = p;\n    //sp.x = abs(sp.x) - 0.16;\n    //float augen = length(sp - vec3(0., -0.22, -.65)) - 0.04;\n    //alle = min(alle, augen);\n    \n    //nase\n    sp = p;\n    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), \n                -0.3, 0., 0.3, 0., 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //nase scheiden\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), \n                -0.35, 0., 0.3, 0., 0.03);\n    alle = smax(alle, -k, 0.04);\n    \n    //nase linie\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), \n                -0.35, 0., 0., 0., 0.005);\n    alle = smin(alle, k, 0.03);\n    \n    //KEIFER / JAW\n    \n    PosY = 0.4;\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    p.y-=0.08;\n    //wangen knochen zu keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.54, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), \n                vec3(0.001, 0.14, 0.1), \n                0.0, -0.45, -0.25, 0.32, 0.01);\n    alle = smin(alle, k, 0.05);\n    \n    //keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.69, -0.34), vec3(0.012, 0.04, 0.22), \n                -0.3, -0.5, 0., 0.22, 0.03);\n    alle = smin(alle, k, 0.09);\n    \n    //kinn\n    sp = p;\n    k = knochen(p, vec3(0., -0.74, -0.53), vec3(0.05, 0.04, 0.015), \n                0., 0., 0., 0., 0.03);\n    alle = smin(alle, k, 0.09);\n    \n    \n    //cyl unten\n    sp = p - vec3(0., -0.68, -0.42);\n    k = sdCappedCylinder(sp, 0.15\n                         + cos(sp.y*12. - 1.5)*0.03\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.08 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);\n    alle = smin(alle, k, 0.06);\n    \n  \n    //unten zahn\n    sp = p - vec3(0.0, -0.58, -0.4);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    \n    k = sdCircleCircle(sp*5.6, 24, -1.);\n    zahn = min(zahn, k);\n    \n    objID = vec4(zahn-0.05, alle, 0, 0);\n    alle =  smin(zahn,alle, 0.09);\n    \n    float ball_of_subtraction = length(p-vec3(0., -0.32, -0.2))-0.34;\n    alle = max(alle, -ball_of_subtraction);\n    \n    //if(min(augen, alle) == augen){\n    alle = min(alle, snake(p));\n    alle += fpn(p*100.+iTime*10.) * (0.03+0.03*sin(iTime));\n    \n    glow += abs(max(0.0001,(0.0001/(0.0075*pow((alle),.7 - 0.2*sin(iTime))))));//* (.5-augen*1.5);\n    //}\n    return alle;\n}\n\nfloat augenMap(vec3 p, float alle){\n\nfloat PosX, PosY;\n    //PosX = 3.14;// - iMouse.x/iResolution.x*8. + 1.5;//0.2*2.*(rechts - links);\n    //PosY = -0.3;// - iMouse.y/iResolution.y*8. + 1.5;\n    \n    //p.z+=1.;\n\n    //float alle = 100.;\n\tp*=0.8;\n    //p.y-=0.2;\n//gluende augen\n    vec3 sp = p;\n    //sp.x = abs(sp.x) -1.2;\n    float augen = length(sp - vec3(-1.2, 0.2, 5.94)) - 0.1;\n    alle = min(alle, augen);\n    if(min(augen, alle) == augen){\n        glow2 += abs(max(0.0001,(0.00005/(0.005*pow((augen),1.)))));//* (.5-augen*1.5);\n    }\n    \n    //snake eye\n    sp=p+vec3(1.3, -0.41, .51);\n    sp.x = abs(sp.x)-0.15;\n    float tmp = length(sp)-0.001;\n    if(min(tmp,alle) == tmp){\n    //glow2 += abs(max(0.0001,(0.00005/(0.005*pow((tmp),1.)))))/4.;//* (.5-augen*1.5);\n    \n    }\n    alle = min(alle, tmp);\n    \n    return alle;\n}\n\n\n\n/*\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(f(p+e.xyy) - f(p-e.xyy),f(p+e.yxy) - f(p-e.yxy),f(p+e.yyx) - f(p-e.yyx)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   // p: position on the ray\n   // d: direction of the ray\n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((gl_FragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n   vec2 uv = (gl_FragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   // total color\n   vec3 tc = vec3(0.);\n   \n   // i: 0 <= i <= 1.\n   // r: length of the ray\n   // l: distance function\n   float r=0., l=0., b=0.;\n\n   // rm loop\n   for (float i=0.; (i<1.); i+=1./64.) {\n       //break if you either\n       //get through all the loop calls, the total density is 95%  or more Y\n       // or both\n       //don't break only if both conditions are not met Y\n\t   if(!((i<1.) && (td < .95)))\n\t\t   break;\n      // evaluate distance function\n       //l for length to point\n       \n       //why take only 50% of the length?Y\n      l = map(p) * 0.55;\n      \n      \n      const float h = .025;\n       \n       // check whether we are close enough (step)\n      // compute local density and weighting factor\n       //if distance to point \"l\" is less than h, (step(h, l) would be the opposite Y\n       //h - l meaning difference between threshold and length\n       //that equals the \"local density\"\n       // otherwise local density = 0\n       //local density is relative to the threshhold 0.05.\n       //l will always be less than h, based on the step condition,\n       \n      ld = (h - l) * step(l, h);\n       \n       //total density\n       //density will be like how dark solid(colored in) the cloud is Y\n       //td will always be less than 0.95 based on the break condition\n      w = (1. - td) * ld;   \n     \n      //accumulate color and density\n      tc += w; // * hsv(w, 1., 1.); // * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1./200.;\n      \n      // enforce minimum stepsize\n      l = max(l, 0.003);\n      \n      // step forward\n      p += l*d;\n      r += l;\n   }  \n    \n    \n   vec3 lookAt = vec3(.0, -1.0, .0);\n    \n    vec3 campos = lookAt + vec3(0., .0, -4.);\n    \n\n    \n   // lookAt.xy += path(lookAt.z);\n   // campos.xy += path(campos.z);\n    \n   // light1.xy += path(light1.z);\n\t//light2.xy += path(light2.z);\n    //I've ommitted adding path to the lights because it seems redundant\n    //although it does make a difference somehow.\n    \n    float FOV = 3.14/3.;//is a bit more than one so multiplying this by right and up in ray\n    //direction increases those vector components (x and y) so it kinda stretches the screen\n    //so you can see more.\n    vec3 forward = normalize(lookAt - campos);\n    vec3 right = normalize(vec3(forward.z, 0.0, 0.0));//don't really need -forward.x?\n    \t\t\t\t\t\t\t//pretty cool using forward.z as the x component in this vector\n    vec3 up = cross(forward, right);\n    \n    \n    vec3 rd = normalize(forward + FOV*right*uv.x + FOV*up*uv.y);\n  //  rd.xy*=rot(iTime);\n    //rd.yz*=rot(-1.8);\n    \n    \n    float t = 0.0, dt;\n    for(int i = 0;i<128; i++)\n    {\n        dt = augenMap(campos + rd*t,td);\n    if(dt<0.005 || t > 150.){break;}\n    \n    t += dt*0.75;\n    }\n    \n   #ifdef SCATTERING\n   // simple scattering approximation\n   tc *= 1. / exp( ld * 0.4 ) * 1.5;\n   #endif\n   \n   \n   vec2 st = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n   vec3 sky = vec3(.0);\n   sky = mix(vec3(0.,0.1,0.0),sky, uv.y);\n   sky += vec3(step(0.99,hash(fragCoord/10.0)));\n   \n   st.x/=2.;\n   st.x+=iTime/16.;\n   vec3 skyGrad = mix(vec3(0., 0., 0.2),vec3(0.2,0.7,0.3),uv.y*2.);\n   float cloud = 0.04+fbm(st*4.+fbm(st*2.)/2.)*(noise(st));\n   sky = mix(sky, vec3(6.0)+skyGrad, clamp(cloud,0., 1. ));\n   \n   \n   //sky += fpn(uv.xyx+iTime*10.);\n   vec3 col  = mix(tc*vec3(0.3,0.7,0.37)+0.2 + glow/800. + glow2, sky, 1.0-tc.x);\n   //gamma\n   \n   col = pow(col,vec3(1.5));\n   \n   uv.x*=0.95;\n   uv.y*=1.2;\n   float baumen = 1.0-smoothstep(0.8, 0.85, length(uv)-fbm(vec2(atan(uv.y/uv.x)*9.,length(uv))+sin(iTime/5.))/5.);\n   col *= baumen;\n   //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}