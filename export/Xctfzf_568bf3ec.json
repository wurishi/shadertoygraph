{"ver":"0.1","info":{"id":"Xctfzf","date":"1733340600","viewed":199,"name":"triangle light","username":"nayk","description":"combination of shaders compiled by chat gpt combination by human","likes":13,"published":3,"flags":0,"usePreview":0,"tags":["fractal","light","tirangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\nvoid rot(inout vec3 p,vec3 a,float t)\n{\n\ta=normalize(a);\n\tp=mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a);\n}\n\nvec2 modifiedAbs(vec2 x){\n    vec2 k= vec2(15);\n    vec2 h=tanh(x*k);\n    return h*h*abs(x);    \n}\n\n// https://www.shadertoy.com/view/MsKGzw\nvec3 fold(vec3 p, float t)\n{\nrot(p,vec3(cos(iTime*.3),sin(iTime*.5),.5*sin(iTime*.2)),iTime*.7);\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    n.z=sqrt(1.-dot(n,n));         // normalize\n    for(float i=0.; i<t; i++){\n        p.xy=modifiedAbs(p.xy);\n        p.z-=min(abs(p.x*p.y),2.)*.2;\n        p-=2.*min(0.,dot(p,n))*n;\n    }\n    return p;\n}\n\n\nfloat c23(vec3 p){\n\nfloat c1=dot(p.x,p.y);\nfloat c2=reflect(p.x,p.y);\nreturn c1*c2;\n\n\n}\n\nfloat map(vec3 p)\n{\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.5),.5*sin(iTime*.2)),iTime*.7);\n    float t = float[](3.,4.,5.)[int(fract(iTime*0.)*3.)];\n    p = fold(p,t);\n    \n    p.z-=1.;\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    \n    n.z=sqrt(1.-dot(n,n)); \n    // normalize\n    return float[](\n            dot(p, normalize(vec3(n.z,0,-n.x))),\n            dot(p, normalize(vec3(0,n.z,-n.y))),\n            length(p.xz)-.1,\n            length(p.yz)-.1\n        )[int(fract(iTime/2.5)*0.)];\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.7,.5,.3)+cos(p*2.)*.5+.5;\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool useShader1 = true; // Переключатель между шейдерами\n\n     vec2 uv3 = fragCoord/iResolution.xy - 0.5;\n        // Код первого шейдера\n        vec4 O = vec4(0);\n        vec2 uv = fragCoord/iResolution.xy - 0.5;\n        uv *= 2.0;\n        float time = iTime;\n        float zoomFactor = exp(time * 0.102);\n        vec2 zoomCenter = vec2(0.0, 0.0);\n        \n        \n          vec2 uv2 = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n        vec3 ro = vec3(0,0,-5);\n        vec3 rd = normalize(vec3(uv2,3));\n        vec3 col= vec3(0);\n        const float maxd=50.;\n        float t=march(ro,rd,0.,maxd);\n        if(t<maxd){\n            vec3 p=ro+rd*t;\n            col=doColor(p);\n            vec3 n=calcNormal(p);\n            vec3 lightPos=ro+vec3(2,5,2);\n            vec3 li=lightPos-p;\n            float len=length(li);\n            li/=len;\n            float dif=clamp(dot(n,li),0.1,1.);\n            col*=max(dif,0.);\n            float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n            float frn=rimd+2.2*(1.-rimd);\n            col*=frn*.8;\n            col*=max(.5+.5*n.y,.1);\n            col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n            col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n        }\n        col=pow(col,vec3(1./2.2));\n        uv = (uv - zoomCenter) * zoomFactor + zoomCenter;\n        vec3 p,q,r=iResolution.xyz, d=normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.y,1));\n        float g = 0.0;\n        for(float i=0.,a,s,e; ++i<70.; O.xyz+=vec3(g*.1, g*.2, g*.3)*1./e/8e3) {\n            p = g*d;\n          p.z*=c23(p);\n            a = 30.;\n            p = mod(p-a,a*2.)-a;\n            s = 2.;\n            e = 1.0;\n            for(int j=0;j++<8;){\n                p = .03-abs(p);\n                p.x<p.y?p=p.zyx:p;\n                p.z<p.y?p=p.xzy:p;\n                s*=e=1.7+sin(iTime*.01)*.1;\n                p = abs(p)*e - vec3(5.*3., 120, 8.*5.)*col;\n            }\n            g += e=length(p.yz)/s;\n        }\n        \n    \n        // Код второго шейдера\n      \n        fragColor.xyz=O.xyz;\n         uv2 *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv3, anim) * vec3(0.35,0.2,0.15)*5., 1.0);\n}","name":"Image","description":"","type":"image"}]}