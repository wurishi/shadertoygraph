{"ver":"0.1","info":{"id":"ml3GW4","date":"1682420686","viewed":141,"name":"water tunnel spiral motion","username":"jojobavg","description":"Water tunnel with spiral motion. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","noise","tunnel","sea","water","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n// TDM for the getSkyColor function\n// https://www.shadertoy.com/view/Ms2SD1\n\n#define time iTime\n#define depth 40.0\n#define fogSize 25.0\n#define seuil 4.0\n#define steps 200.0\nfloat fogCoef=1.0/(depth-fogSize);\n\n\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\n\nfloat noise(in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n\trandom(n + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,0))),\n\trandom(n + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(n + dot(step, vec3(0,0,1))),\n\trandom(n + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,1))),\n\trandom(n + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat water(in vec3 p, vec3 centerPos, float scale,float radius ) {\n\tvec3 tunnel = vec3(p.x+sin(length(p*0.2)+time)*2.0,p.y+sin(length(p*0.2))*2.0,0.0);\n\tfloat coef = length(tunnel)-4.0;\n\n\tfloat c=1.0;\n\tfloat n1=1.0;\n\tfloat d=1.0;\n    vec3 noiseInput;\n    p.xy*= rot(time);\n\tfor(int i=0; i<8; ++i) {\n        \n        noiseInput = vec3(p*c-time*0.5*c*d);\n\n\t\tn1+=2.0/c*abs(noise(noiseInput*scale));\n\t\tc*=2.0;\n\t\td+=1.5;\n\t}\n\n\treturn n1*coef;\n\n}\n\nfloat mapHyper(vec3 p){\n\treturn water(p,vec3(0,0,0),0.3,0.1);\n}  \n\n\nvec3 tunnel(vec3 p){\n\tvec3 off=vec3(0);\n\toff.x += sin(p.z*0.2)*1.5;\n\toff.y += sin(p.z*0.3)*1.3;\n\treturn off;\n}\n\n\nvec3 getSkyColor(vec3 e) {\n\te.y = (e.y);\n\te.y = max(e.y,0.0);\n\treturn vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4)*noise(e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n\t\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 s=vec3(-1.0,-1.0,-3);\n    float t2=(time*1.5);\n    s.xz *= rot(sin(t2)*0.015);\n    vec3 t=vec3(0,0,0);\n    s -= tunnel(s);\n    t -= tunnel(t);\n    s.x += cos(t2*0.2)*1.0*sin(time*0.01);\n    s.y += sin(t2*0.2)*1.0*sin(time*0.01+10.0);\n    vec3 cz=normalize(t-s);\n    vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy=normalize(cross(cz,cx));\n    vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n    vec3 p=s;\n    float c= 0.0;\n\n    for(int i=0; i<int(steps); ++i) \n    {\n        float mH;\n        mH = mapHyper(p);\n        c +=mH;    \n        if(c>seuil)break;\n        p+=r*(mH-seuil)*0.09;\n    }\n    \n\tvec3 col=vec3(0);\n    float fresnel;\n    vec3 reflected;\n    \n    vec2 off=vec2(0.05,0.0);\n    vec3 zVect = vec3(0.0,0.0,1.0);\n    vec3 n=normalize(mapHyper(p)-vec3(mapHyper(p-off.xyy), mapHyper(p-off.yxy), mapHyper(p-off.yyx)));\n    col = mix(vec3(0.2,0.3,0.4),vec3(0.1,0.365,0.441),(abs(1.0+dot(n,s)*pow(dot(zVect,r),5.0))));\n    fresnel = clamp(1.0- dot(n,s), 0.05, 0.75);\n    reflected = getSkyColor(abs(reflect(r,n)));\n    col = mix(col,reflected,(fresnel*reflected.x));\n \n    float fog =  clamp((length(p-s)-fogSize)*fogCoef,0.0,1.0);\n    col = mix(col,vec3(0.85,0.85,0.85),fog);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}