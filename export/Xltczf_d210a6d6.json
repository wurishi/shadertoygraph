{"ver":"0.1","info":{"id":"Xltczf","date":"1533501636","viewed":104,"name":"PathMove","username":"TLC123","description":"Animation, Path follow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raycaster code credit to Inigo Quilez\n\n\n\n// animation data:  all keys have equal time spacing\nconst vec3[] v1= vec3[]  (  \n                    vec3 (50., 50., 50.), \n                    vec3 (-50., 50., 50.),           \n                    vec3 (-50., 50., 50.), \n                    vec3 (-50., -50., 50.), \n                    vec3 (50., -50., 50.), \n                    vec3 (50., -50., 50.), \n                    vec3 (50., -50., 10.),\n                    vec3 (50., 50., 10.), \n                    vec3 (-50., 50., 10.),\n                    vec3 (-0., 0., 100.),\n                    vec3 (-0., 0., 10.),\n                    vec3 (-0., 0., 100.), \n                    vec3 (-100., 0., 10.), \n                    vec3 ( 100., 0., 10.), \n                    vec3 (-100., 0., 10.), \n                    vec3 (-0., 0., 40.),\n                    vec3 (-0., 0., 15.),\n                    vec3 (-0., 0., 15.),      \n                    vec3 (-0., 0., 15.),\n                    vec3 (-0., 0., 15.), \n                    vec3 (-50., -50.,20.) \n                  \n) \n                                  ;\n \n\n\n\n \n// rotm sphere  credit to Inigo Quilez\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;}\nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\n \n // wraps index 0 - tak \nfloat wrapi( float x,float tak){ return mod((mod(x  , tak) + tak) , tak) ;}\n\nvec3 smooth_animate(float t){\n \nfloat ll=float(v1.length());     // array lenght\nfloat  i=round(ll*t);           // index of closest animation key\nfloat T=mod( (ll*t+0.5),1.) ;   // local t of curve piece\n\n\n//construct three point bezier of current key and  half way to next and prev key\n// wrap index to keep animation looping\nvec3 p0=    mix( v1[int( wrapi(i-1.,ll))], v1[int(wrapi(i,ll))],0.5);\nvec3 p1=    v1[int(wrapi(i,ll))];\nvec3 p2=    mix( v1[int(wrapi(i,ll))],v1[int( wrapi(i+1.,ll))],0.5)  ;\n    \n// 3p bezier\n    return mix(mix( p0,p1,T),mix(p1,p2,T),T) ;}\n\n\n \n\n\nvec4 map(vec4 r0)\n    \n{  \n    vec3 p=r0.xyz ;\n   vec3 psp1= vec3(p.x*cos(iTime)-p.y*sin(iTime),\n                  p.y*cos(iTime)+p.x*sin(iTime) ,p.z) ;\n\n   vec3 psp2= vec3(p.x*cos(iTime/-2.)-p.y*sin(iTime/-2.),\n                  p.y*cos(iTime/-2.)+p.x*sin(iTime/-2.) ,p.z) ;\n\n    vec3 m1= smooth_animate(mod(iTime/15.,1.))  ;\n   vec3 m2= smooth_animate(mod((iTime)/12.,1.)+0.5)  ;\n  vec3 pm1=psp1-m1 ;\n  vec3 pm2=psp2-m2 ;\n\n  float sphere1=sdSphere( psp1-m1, 19.9);\n  float sphere2=sdSphere( psp2-m2, 29.9);\n  float plane=p.z;\n\n float c1= mod( \n        mod (floor(pm1.x/10.),2.)+\n        mod (floor(pm1.y/10.),2.)+\n        mod (floor(pm1.z/10.),2.)\n        ,2.);\n    \n float c2= mod( \n        mod (floor(pm2.x/10.),2.)+\n        mod (floor(pm2.y/10.),2.)+\n        mod (floor(pm2.z/10.),2.)\n        ,2.);\n    \n float c3= mod( mod (floor(p.x/10.),2.)+mod (floor(p.y/10.),2.),2.);\n \n float c= sphere2>sphere1?c1:c2;\n       c= plane> min(sphere2,sphere1)?c:c3;\n \n    return vec4(smin(plane,smin(sphere1,sphere2,20.),20.),c,c,c );\n }\n\n\n\n\n\n\n//Raycaster code credit to Inigo Quilez\n\nconst vec3 bbox_min = vec3(-7.363703305156273, -7.363703305156273, -7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273, 7.363703305156273, 7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 250.;\n \n\tfloat t = tmin;\n\tvec3 c = vec3(-.0, -.0, -.0);\n\n\tfor (int i = 0; i < 200; i++) {\n\t\tfloat precis = 0.03;\n\t\tvec4 res = map(vec4(ro + rd * t, iTime));\n\n\t\tif (res.x < precis *300.) {\n\t\t\tc = mix(c,  (res.yzw*.5)*2., \n                    clamp(1. / res.x, 0., 1.) \n\t\t \n                   ) \n                ;\n\n\t\t\tif (res.x < precis) {\n\t\t\t\tc = mix(c, (res.yzw),0.6);\n \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tt += res.x;\n\t\tif (t > tmax) {\n\n\t\t\tc = mix(texture(iChannel0, rd.xzy).xyz, c, length(c));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec4(t, c);\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( true )\n    {col=c;}\n    else if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.12)*0.34;\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig1 = normalize( vec3(-0.8, 0.3, 0.5) );\n        vec3  lig2 = normalize( vec3(0.8, 0.3, 0.5) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif1 = clamp( dot( nor, lig1 ), 0.0, 1.0 );\n        float dif2 = clamp( dot( nor, lig2 ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig1.x,lig1.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe1 = pow(clamp( dot( ref, lig1 ), 0.0, 1.0 ),32.0);\n        float spe2 = pow(clamp( dot( ref, lig2 ), 0.0, 1.0 ),32.0);\n        \n        vec3 lin = vec3(0.0);\n        lin += 4.30*dif1*vec3(1.00,0.80,0.55);\n        lin += 4.30*dif2*vec3(1.00,0.80,0.55);\n        lin += 14.00*spe1*vec3(1.00,0.90,0.70)*dif1;\n        lin += 14.00*spe2*vec3(0.50,0.90,1.0)*dif2;\n        lin += 0.9*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.20*bac*vec3(0.935,0.935,0.935)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.64);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n \n      vec2 mouse = iMouse.xy / iResolution.xy;\n      //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\nvec3 eye = vec3(sin(iTime/5.)*150., cos(iTime/5.)*180., cos(iTime/10.)*4.+50.);\n    vec3 centre = vec3(-1.0, 0.0, 30.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 1.0);\n\t \n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}