{"ver":"0.1","info":{"id":"MscSWN","date":"1459366736","viewed":456,"name":"Terse Voxel Viewer","username":"akohdr","description":"Readable version of simple voxel viewer and some test geometry\n\nto make R/G/B functions of spacetime uncomment\n    #define SHOW_JETSETWILLY\n","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// building upon https://www.shadertoy.com/view/4dX3zl\n// looking to create terse cut/paste reuse (potentially minified) spacetime voxel viewer \n#define SPD_R 2.5\n//#define SHOW_JETSETWILLY\n#define SHOW_SPHERES\n#define SHOW_AXIS\n#define SHOW_QUADRANTS\n#define SHOW_RINGS\n\n// Cut/Paste begin ------------------------------------------------------------\n#define BOB_H 7.\n#define EYE_D 50.\n#define B0 vec4(.0,.0,.0,1.)\n#define B1 vec4(.6,.6,.6,1.)\n#define B2 vec4(.3,.3,.3,1.)\n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nbool cVoxel(out vec4 c, const in vec4 P );\n\nvoid VxViewer(out vec4 fc,        // fragColor\n         const in vec2 P,         // fragCoord\n         const in vec3 R,         // iResolution\n         const in vec2 UV,        // texture uv\n         const in float T ) {     // timebase\n\n    float l = P.x / R.x - .5,\n          sT = sin(T), cT = cos(T);\n\n    vec3 r = vec3(l*cT - .8*sT, (P.y/R.y - .5)*R.y/R.x, .8*cT + l*sT),\n         o = vec3(EYE_D*sT, BOB_H*sT, -EYE_D*cT),\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n    \n    for(int i=0;i<99;i++) {\n\n        bvec3 a = lessThan(s.xyz,s.yzx),\n              b = lessThanEqual(s.xyz,s.zxy);\n        m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n\n        if(cVoxel(fc,vec4(f.x,f.y,f.z,T))){ // move to top of loop for edgeless non-spin voxels\n            fc += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n\t\t\treturn; // early exit\n        }\n\n        s += m*d;\n        f += m*q;\n    }\n    fc = texture(iChannel0, UV);\n}\n// Cut/Paste end ------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    VxViewer(fragColor, \n             fragCoord,\n             iResolution,\n             fragCoord / iResolution.xy,  // uv\n             SPD_R*iTime);          // timebase\n}\n\n\n// Test Geometry\nconst vec4 BLK = vec4(.0,.0,.0,1.),\n           GRY = vec4(.3,.3,.3,1.),\n           WHT = vec4(.6,.6,.6,1.),\n#ifndef SHOW_JETSETWILLY\n\t\t   RED = vec4(.7,.0,.0,1.),\n           GRN = vec4(.0,.7,.0,1.),\n           BLU = vec4(.0,.0,.7,1.),\n#endif\n           YEL = vec4(.7,.7,.0,1.);\n\n// hint of the power of a spacetime based abstraction\n#ifdef SHOW_JETSETWILLY\n\t#define CB vec4(P.xyz,1.)/10.*sin(cos(20.*sin(T)))\n\t#define RED vec4(.7,.0,.0,1.)+CB\n\t#define GRN vec4(.0,.7,.0,1.)+CB\n\t#define BLU vec4(.0,.0,.7,1.)+CB\n#endif\n\n\n#define SPHERE(p,c,r) length(p.xyz-c)<r\n#define VOXEL(p,c) SPHERE(p,c,0.5)\n#define Q(q) if(q) return true;\n#define QX(p,c) Q(VOXEL(p,c))\n#define QS(C,P,X) {c=C+vec4(P.xyz,1.)/20.; Q(X)}\n#define ineq(a,v,b) (a<v && v<b)\n#define sq(a) a*a\n\nbool cVoxel(out vec4 c,\n       const in vec4 P ) {\n    \n    // TODO: scales O(n) with number tests\n    //       use decorator for memoization of static geometry\n    //       use distance field to cull \n    //       may need to pass view direction or light cone KISS\n#ifdef SHOW_SPHERES\n    float T = P.w;\n    vec3 dynP = 9.*vec3(sin(T), cos(T), sq(sin(T)));\n    c = RED;\n    \tQ(SPHERE(P, dynP.xyx, 3.3))\n        QX(P,vec3(19,0,0))\n    c = GRN; \n    \tQ(SPHERE(P, -dynP.xyx, 3.3))\n        QX(P,vec3(0,19,0))\n    c = BLU;\n    \tQ(SPHERE(P, vec3(0.), dynP.z))\n        QX(P,vec3(0,0,19))\n#endif\n            \n#ifdef SHOW_AXIS\n    c = GRY;\n        vec4 a = abs(P);\n        Q(a.y<.1 && a.z<.1 && ineq(0.,P.x,19.))\n        Q(a.x<.1 && a.z<.1 && ineq(0.,P.y,19.))\n        Q(a.x<.1 && a.y<.1 && ineq(0.,P.z,19.))\n#endif\n\n#ifdef SHOW_QUADRANTS\n    c = YEL;\n/* individual voxel comparisons slow but you can do it\n        float D = 8.;\n        QX(P,vec3( D, D, D))\n        QX(P,vec3( D, D,-D))\n        QX(P,vec3( D,-D, D))\n        QX(P,vec3( D,-D,-D))\n        QX(P,vec3(-D, D, D))\n        QX(P,vec3(-D, D,-D))\n        QX(P,vec3(-D,-D, D))\n        QX(P,vec3(-D,-D,-D))\n*/\n    Q(length(abs(P.xyz)-vec3(8.))<1.)  // faster \n#endif\n    \n#ifdef SHOW_RINGS\n    float L = length(P.xyz);\n    c = WHT;\n    c -= RED;\n        Q(ineq(11.,L,12.) && cos(P.x)>.5)  // CSG 101\n    c -= GRN;\n        Q(ineq(8.,L,9.) && cos(P.z+3.14)>.5)\n    c = YEL;\n        Q(ineq(3.,L,6.) && cos(P.y+3.14)>.5)\n#endif\n    return false;\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}