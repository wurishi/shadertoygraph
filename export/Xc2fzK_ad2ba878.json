{"ver":"0.1","info":{"id":"Xc2fzK","date":"1725208627","viewed":32,"name":"Controlled plexus","username":"k0mario","description":"Lines growing brighter based on the distance between points with certain threshold. Written using Claude Ai.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["points","plexus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Static/Dynamic Plexus effect with more points and smaller activation radius\n\n#define MAX_POINTS 200  // CHANGE 1: Increased from 100 to 200\n#define MAX_DISTANCE 0.1\n#define MIN_MOVE_DISTANCE 0.0005\n#define ASPECT_RATIO (1920.0 / 1080.0)\n#define LINE_THICKNESS 0.002\n#define POINT_SIZE 0.01\n#define GRID_SIZE 14  // CHANGE 2: Increased from 10 to 14 for more points\n\nstruct Point {\n    vec2 position;\n    float isActive;\n};\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    vec2 lastMouseUV = iMouse.zw/iResolution.xy;\n    \n    // Adjust UV and mouse coordinates for aspect ratio\n    uv.x *= ASPECT_RATIO;\n    mouseUV.x *= ASPECT_RATIO;\n    lastMouseUV.x *= ASPECT_RATIO;\n    \n    // Calculate mouse movement\n    vec2 mouseMove = mouseUV - lastMouseUV;\n    float moveDistance = length(mouseMove);\n    \n    // Initialize points array using jittered grid\n    Point points[MAX_POINTS];\n    int index = 0;\n    for (int y = 0; y < GRID_SIZE && index < MAX_POINTS; y++) {\n        for (int x = 0; x < GRID_SIZE && index < MAX_POINTS; x++) {\n            vec2 cellSize = vec2(ASPECT_RATIO / float(GRID_SIZE), 1.0 / float(GRID_SIZE));\n            vec2 cellCenter = vec2(float(x) + 0.5, float(y) + 0.5) * cellSize;\n            vec2 jitter = (vec2(rand(vec2(float(x), float(y))), rand(vec2(float(y), float(x)))) - 0.5) * cellSize;\n            points[index].position = cellCenter + jitter * 0.5;\n            points[index].isActive = 0.0;\n            index++;\n        }\n    }\n    \n    // CHANGE 3: Reduced activation radius\n    float activationRadius = 0.08;  // Changed from 0.15 to 0.08\n    for (int i = 0; i < MAX_POINTS; i++) {\n        float dist = distance(points[i].position, mouseUV);\n        if (dist < activationRadius) {\n            points[i].isActive = 1.0;\n        } else {\n            points[i].isActive = 0.0;\n        }\n    }\n    \n    // Generate new point if mouse moved\n    if (moveDistance > MIN_MOVE_DISTANCE) {\n        for (int i = 0; i < MAX_POINTS; i++) {\n            if (points[i].isActive == 0.0) {\n                points[i].position = mouseUV;\n                points[i].isActive = 1.0;\n                break;\n            }\n        }\n    }\n    \n    vec3 color = vec3(0.0);\n    \n    // Draw lines between points\n    for (int i = 0; i < MAX_POINTS; i++) {\n        if (points[i].isActive == 0.0) continue;\n        \n        for (int j = i + 1; j < MAX_POINTS; j++) {\n            if (points[j].isActive == 0.0) continue;\n            \n            vec2 p1 = points[i].position;\n            vec2 p2 = points[j].position;\n            float d = distance(p1, p2);\n            \n            if (d < MAX_DISTANCE) {\n                vec2 lineDir = normalize(p2 - p1);\n                float linePos = dot(uv - p1, lineDir);\n                linePos = clamp(linePos, 0.0, d);\n                vec2 closestPoint = p1 + lineDir * linePos;\n                \n                float intensity = 1.0 - smoothstep(0.0, LINE_THICKNESS, distance(uv, closestPoint));\n                intensity *= 1.0 - d / MAX_DISTANCE;\n                \n                color += vec3(0.2, 0.5, 0.8) * intensity;\n            }\n        }\n    }\n    \n    // Draw points\n    for (int i = 0; i < MAX_POINTS; i++) {\n        if (points[i].isActive == 0.0) continue;\n        \n        float intensity = 1.0 - smoothstep(0.0, POINT_SIZE, distance(uv, points[i].position));\n        color += vec3(0.9, 0.3, 0.1) * intensity;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}