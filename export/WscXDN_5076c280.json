{"ver":"0.1","info":{"id":"WscXDN","date":"1571950207","viewed":283,"name":"2 Axis Pixelsorting By Color","username":"SSHantaram","description":"2 axis pixel sorting by red and green components. swapping up, down, left right is interleaved, so each frame a different direction is swapped.\nThis idea is taken from https://www.shadertoy.com/view/4dcGDf . Reset with space bar.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["buffer","pixelsorting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // get color from buffer and output to screen\n\tfragColor = vec4(texelFetch( iChannel0, ivec2(fragCoord), 0 ).rgb, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// constants to calculte neighbouring pixels\nconst ivec2 up = ivec2(0, 1);\nconst ivec2 right = ivec2(1, 0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // init with texture if at first frame\n    if(\tiFrame == 0 || texelFetch(iChannel2, ivec2(32, 0), 0 ).x > 0.1)\n    {\n        fragColor = texture(iChannel1, uv);\n        return;\n    }\n    \n    // values to calculate neighbours in uv space\n    vec2 texel = 1. / iResolution.xy;\n    vec2 texelUp = vec2(0.0, texel.y);\n    vec2 texelRight = vec2(texel.x, 0.0);\n    \n    // fetch current pixel from buffer\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    ivec2 pixelOffset;\n    vec2 texelOffset;\n    \n    // swapping up, down, left, right is interleaved between frames\n    // idea taken from https://www.shadertoy.com/view/4dcGDf\n    // offets are set based on direction\n    if(int(mod(float(iFrame), 4.0)) < 2) {\n        if(int(mod(float(iFrame) + fragCoord.y, 2.0)) == 0) {\t// pixel below\n            pixelOffset = -up;\n            texelOffset = -texelUp;\n        } else {\t\t\t\t\t\t\t\t\t\t\t\t// pixel above\n  \t\t\tpixelOffset = up;\n            texelOffset = texelUp;\n        }\n    } else {\n        if(int(mod(float(iFrame) + fragCoord.x, 2.0)) == 0) {\t// pixel to the left\n\t\t\tpixelOffset = -right;\n            texelOffset = -texelRight;\n        } else {\t\t\t\t\t\t\t\t\t\t\t\t// pixel to the left\n\t\t\tpixelOffset = right;\n            texelOffset = texelRight;\n        }\n    }\n    \n    // calculate other pixel coordinates\n    ivec2 otherFragCoord = ivec2(fragCoord) + pixelOffset;\n    \n    // check if other pixel is inside the bounds of the buffer\n    if (otherFragCoord.x >= 0 &&\n       \totherFragCoord.y >= 0 &&\n       \totherFragCoord.x < int(iResolution.x) &&\n        otherFragCoord.y < int(iResolution.y))\n    {\n        // fetch other pixel from buffer\n        vec4 other = texelFetch(iChannel0, otherFragCoord, 0);\n    \t\n        // calculate difference vectors from red-green uv plane\n        // this is the difference of the pixels red-green components\n        // from its expected position on a red-green uv plane\n        // basically: fragColor = vec4(uv, 0.0, 1.0);\n    \tvec2 diff = current.xy - uv;\n    \tvec2 otherDiff = other.xy - (uv + texelOffset);\n    \t\n        // calculate difference vectors if the pixels were swapped\n    \tvec2 diffSwapped = current.xy - (uv + texelOffset);\n    \tvec2 otherDiffSwapped = other.xy - uv;\n        \n        // calculate sum of sqare distances for unswapped pixels\n        float error = dot(diff, diff);\n        float otherError = dot(otherDiff, otherDiff);\n        float combinedError = error + otherError;\n        \n        // calculate sum of sqare distances for swapped pixels\n        float errorSwapped = dot(diffSwapped, diffSwapped);\n        float otherErrorSwapped = dot(otherDiffSwapped, otherDiffSwapped);\n        float combinedErrorSwitched = errorSwapped + otherErrorSwapped;\n    \t\n        // if the sum of sqare distances goes down, then swap pixels\n    \tif (combinedError > combinedErrorSwitched) {\n    \t\tcurrent = other;\n    \t}\n    }\n    \n    fragColor = current;\t// output to buffer\n}","name":"Buffer A","description":"","type":"buffer"}]}