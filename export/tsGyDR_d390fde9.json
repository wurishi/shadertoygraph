{"ver":"0.1","info":{"id":"tsGyDR","date":"1602653373","viewed":1704,"name":"Marching Squares with Meta Balls","username":"iradicator","description":"Visualizing marching-squares on meta-balls generated data using only the fragment shader. \nBased on ideas from Zero-Wind (Jamie Wong).\n\nFor full explanation, check out: https://iradicator.com/2d-surface-reconstruction-marching-squares-with-meta-balls","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","marching","volumetric","visualize","marchingsquares"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visualizing marching-squares on meta-balls generated data using only the fragment shader. \n// For full explanation, check out: https://iradicator.com/2d-surface-reconstruction-marching-squares-with-meta-balls.\n// Based on ideas from Zero-Wind: http://jamie-wong.com/2014/08/19/metaballs-and-marching-squares/\n\n#define clamp01(x) clamp((x),0.0,1.0)\n#define smoothstep01(x) smoothstep(0.0,1.0,(x))\n#define sqr(x) ((x)*(x))\n#define lerp(a,b,t) mix((a),(b),(t))\n\nfloat sqrMagnitude(in vec2 v) { return dot(v,v); }\nfloat sqrMagnitude(in vec3 v) { return dot(v,v); }\nfloat sqrMagnitude(in vec4 v) { return dot(v,v); }\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp01(dot(pa,ba)/dot(ba,ba));\n  return length(pa - ba*h);\n}\n\nfloat sceneWeight(in vec2 p, in float t)\n{    \n\tfloat aspect = iResolution.x / iResolution.y;\n    \n    vec3[16] aSpheres;\n    aSpheres[0 ] = vec3(aspect*(0.5 + 0.5*sin(2.124*t+8.164)), 0.5 + 0.5*sin(3.823*t+5.812), 2.4 / 32.0);\n    aSpheres[1 ] = vec3(aspect*(0.5 + 0.5*sin(2.878*t+1.414)), 0.5 + 0.5*cos(2.816*t+0.752), 2.0 / 32.0);\n    aSpheres[2 ] = vec3(aspect*(0.5 + 0.5*cos(0.818*t+4.142)), 0.5 + 0.5*sin(1.183*t+4.127), 4.1 / 32.0);\n    aSpheres[3 ] = vec3(aspect*(0.5 + 0.5*sin(5.123*t+8.214)), 0.5 + 0.5*sin(6.182*t+5.612), 5.6 / 32.0);\n    aSpheres[4 ] = vec3(aspect*(0.5 + 0.5*sin(5.123*t+1.814)), 0.5 + 0.5*cos(3.182*t+8.834), 0.5 / 32.0);\n    aSpheres[5 ] = vec3(aspect*(0.5 + 0.5*sin(8.179*t+8.174)), 0.5 + 0.5*sin(6.182*t+3.178), 2.3 / 32.0);\n    aSpheres[6 ] = vec3(aspect*(0.5 + 0.5*sin(2.812*t+7.214)), 0.5 + 0.5*sin(8.182*t+6.714), 0.3 / 32.0);\n    aSpheres[7 ] = vec3(aspect*(0.5 + 0.5*cos(5.902*t+9.123)), 0.5 + 0.5*sin(2.232*t+2.873), 3.4 / 32.0);\n    aSpheres[8 ] = vec3(aspect*(0.5 + 0.5*sin(3.173*t+9.124)), 0.5 + 0.5*cos(6.743*t+8.238), 1.0 / 32.0); \n    aSpheres[9 ] = vec3(aspect*(0.5 + 0.5*sin(8.145*t+8.145)), 0.5 + 0.5*sin(5.743*t+8.475), 4.2 / 32.0); \n    aSpheres[10] = vec3(aspect*(0.5 + 0.5*sin(1.723*t+3.134)), 0.5 + 0.5*sin(4.127*t+1.456), 1.9 / 32.0); \n    aSpheres[11] = vec3(aspect*(0.5 + 0.5*cos(5.823*t+1.824)), 0.5 + 0.5*cos(7.151*t+5.235), 3.8 / 32.0); \n    aSpheres[12] = vec3(aspect*(0.5 + 0.5*sin(5.823*t+1.235)), 0.5 + 0.5*sin(3.131*t+2.327), 4.2 / 32.0); \n    aSpheres[13] = vec3(aspect*(0.5 + 0.5*sin(9.823*t+8.153)), 0.5 + 0.5*cos(5.912*t+4.235), 2.5 / 32.0); \n    aSpheres[14] = vec3(aspect*(0.5 + 0.5*cos(1.742*t+8.193)), 0.5 + 0.5*sin(3.874*t+4.121), 1.8 / 32.0); \n    aSpheres[15] = vec3(aspect*(0.5 + 0.5*sin(9.187*t+1.792)), 0.5 + 0.5*cos(1.894*t+1.247), 3.3 / 32.0); \n\n    float w = 0.0;\n    for (int k = 0; k < aSpheres.length(); ++k)\n\t\tw += sqr(aSpheres[k].z) / sqrMagnitude(p - aSpheres[k].xy);                \n    return w;\n}\n\nfloat marchsquares(\n    in float alpha, in float isovalue, in vec2 gridSize, \n    in vec2 uv, in vec2 uv00, in int code, \n    in float w00, in float w10, in float w11, in float w01\n)\n{    \n  const float thick = 0.0018;\n    \n  vec2 px0 = lerp(vec2(0.0,0.0), vec2(1.0,0.0), (isovalue - w00) / (w10 - w00));\n  px0 = lerp(vec2(0.5,0.0),px0,alpha);\n  px0 = uv00 + px0 / vec2(gridSize);\n  \n  vec2 px1 = lerp(vec2(0.0,1.0), vec2(1.0,1.0), (isovalue - w01) / (w11 - w01));\n  px1 = lerp(vec2(0.5,1.0),px1,alpha);\n  px1 = uv00 + px1 / vec2(gridSize);\n  \n  vec2 p0y = lerp(vec2(0.0,0.0), vec2(0.0,1.0), (isovalue - w00) / (w01 - w00));\n  p0y = lerp(vec2(0.0,0.5),p0y,alpha);\n  p0y = uv00 + p0y / vec2(gridSize);\n  \n  vec2 p1y = lerp(vec2(1.0,0.0), vec2(1.0,1.0), (isovalue - w10) / (w11 - w10));\n  p1y = lerp(vec2(1.0,0.5),p1y,alpha);\n  p1y = uv00 + p1y / vec2(gridSize);\n    \n  switch(code)\n  {\n    case 0:\n    {\n      return 0.0;\n    } break;\n    case 1:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px0));\n    } break;\n    case 2:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, p1y));\n    } break;\n    case 3:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, p1y));\n    } break;\n    case 4:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px1, p1y));\n    } break;\n    case 5:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, p1y))\n           + smoothstep(thick,0.0,sdSegment(uv, p0y, px1));\n    } break;\n    case 6:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, px1));\n    } break;\n    case 7:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px1));\n    } break;\n    case 8:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px1));\n    } break;\n    case 9:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, px1));\n    } break;\n    case 10:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px1, p1y))\n           + smoothstep(thick,0.0,sdSegment(uv, p0y, px0));\n    } break;\n    case 11:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px1, p1y));\n    } break;\n    case 12:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, p1y));\n    } break;\n    case 13:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, p1y));\n    } break;\n    case 14:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px0));\n    } break;\n    case 15:\n    {\n      return 0.0;\n    } break;\n  }\n}\n\nfloat isosurface(\n    in float isovalue, in float t, in vec2 gridSize, \n    in vec2 uv, in vec2 uv00, \n    in float w00, in float w10, in float w11, in float w01\n)\n{\n  int code = 15;\n  if (w00 < isovalue) code -= 1;\n  if (w10 < isovalue) code -= 2;\n  if (w01 < isovalue) code -= 8;\n  if (w11 < isovalue) code -= 4;\n  return marchsquares(t, isovalue, gridSize, uv, uv00, code, w00, w10, w11, w01);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n\tconst float kisovalue = 1.0;\n    \n    float timer = 76.0 * fract(iTime / 76.0);\n    float sceneTimer = iTime / 15.6;    \n\n    vec2 gridSize = vec2(lerp(8.0,128.0,smoothstep01(step(27.0,timer)*(timer-27.0)/(32.0-27.0))));\n\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;        \n    uv.x *= aspect;\n\n    vec2 uvc  = floor(vec2(gridSize) * uv + vec2(0.5,0.5)) / vec2(gridSize);\n  \tvec2 uv00 = floor(vec2(gridSize) * uv + vec2(0.0,0.0)) / vec2(gridSize);\n  \tvec2 uv10 = floor(vec2(gridSize) * uv + vec2(1.0,0.0)) / vec2(gridSize);\n  \tvec2 uv01 = floor(vec2(gridSize) * uv + vec2(0.0,1.0)) / vec2(gridSize);\n  \tvec2 uv11 = floor(vec2(gridSize) * uv + vec2(1.0,1.0)) / vec2(gridSize); \n  \tvec2 fuv  = fract(vec2(gridSize) * uv + vec2(0.5));\n            \n    float w   = sceneWeight(uv,   sceneTimer);\n    float wc  = sceneWeight(uvc,  sceneTimer);\n    float w00 = sceneWeight(uv00, sceneTimer);\n    float w10 = sceneWeight(uv10, sceneTimer);\n    float w01 = sceneWeight(uv01, sceneTimer);\n    float w11 = sceneWeight(uv11, sceneTimer);\n    \n  \tif (w < kisovalue) w = 0.0;\n    if (wc < kisovalue) wc = 0.0;    \n    \n  \tvec3 col = w * vec3(1.0);\n\n    float showVoxels = 0.95*(smoothstep(11.0,15.0,timer)-smoothstep(40.0,42.0,timer));\n    col = lerp(col, wc * vec3(1.0), showVoxels);\n    \n    col *= 1.0-smoothstep(0.05,0.0,abs(kisovalue-w));\n  \tcol = lerp(col, 90.0*vec3(0.03,0.01,0.8), smoothstep(0.05,0.0,abs(kisovalue-w)));\n      \n    float showGrid = smoothstep(5.0,7.0,timer-length(uv)) - smoothstep(45.0,52.0,timer+0.45*length(uv));\n    col *= lerp(1.0,smoothstep01(50.0*sqrMagnitude(fuv-vec2(0.5))),showGrid);\n  \tcol += showGrid * (1.0 - smoothstep01(50.0 * sqrMagnitude(fuv - vec2(0.5)))) * clamp01(vec3(kisovalue-w,w,0.0)) * vec3(1.0,1.0,0.0);\n\n    col = 0.06*col + vec3(0.003,0.005,0.004);\n    \n    col *= pow(clamp(0.5*(smoothstep(60.0,56.0,timer)+smoothstep(65.0,68.0,timer)),0.0005,1.0),0.92);\n    \n    float a0 = smoothstep(45.0,48.0,timer)-smoothstep(69.0,71.0,timer);\n  \tfloat a1 = smoothstep(20.0,22.0,timer)-smoothstep(73.0,76.0,timer);\n    float a2 = smoothstep(51.0,54.0,timer)-smoothstep(69.0,71.0,timer);\n    float a3 = smoothstep(50.0,54.0,timer)-smoothstep(70.0,72.0,timer);\n    \n    float isovalue0 = lerp(1.0,0.5,smoothstep(45.0,48.0,timer)-smoothstep(69.0,71.0,timer));\n    float isovalue1 = 1.0;\n    float isovalue2 = lerp(1.0,2.0,smoothstep(51.0,54.0,timer)-smoothstep(69.0,72.0,timer));\n    float isovalue3 = lerp(1.0,3.0,smoothstep(50.0,54.0,timer)-smoothstep(70.0,72.0,timer));\n    \n    float edgeInterp = smoothstep(22.0,23.0,timer) - smoothstep(25.0,26.0,timer) + smoothstep(37.0,42.0,timer);\n    float a = a0 * 0.05 * isosurface(isovalue0, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n            + a1 * 0.5  * isosurface(isovalue1, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n        \t+ a2 * 5.0  * isosurface(isovalue2, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n        \t+ a3 * 20.0 * isosurface(isovalue3, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n    ;    \n  \tvec3 edgeCol = lerp(vec3(0.0,0.9,0.88), vec3(0.8,0.9,0.0), edgeInterp);\n    col = lerp(col, edgeCol, a);\n    \n    col = col / (vec3(1.0) + col);\n    col = pow(col,vec3(1.0/2.2));    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}