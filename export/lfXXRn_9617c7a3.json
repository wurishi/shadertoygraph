{"ver":"0.1","info":{"id":"lfXXRn","date":"1704833212","viewed":41,"name":"_test__","username":"jiq","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in float bb )\n{\n    vec2 b = vec2(bb);\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nuint pcg(uint v){\n    uint state = v * uint(747796405) + uint(2891336453);\n    uint word = ((state >> ((state >> 28) + uint(4))) ^ state) * uint(277803737);\n    return (word >> 22) ^ word;\n}\n\nfloat random(int seed) {\n    return float(pcg(uint(seed)) % uint(1000000)) / 1000000.0f;\n}\n\nfloat grid(vec2 p, out int idx, vec2 t) {\n    float circleRadius = 0.001;\n    float gridSize = 0.05;\n    \n    vec2 id = round(p/gridSize);\n    vec2 r = p - gridSize*id;\n    idx = (int(id.x) + 1000) * (int(id.y) + 1000);\n    vec2 offset = normalize(t - id * gridSize) / max(length(t - id * gridSize) - 0.15, 0.0) * 0.001;\n    //offset += pattern(id / 10.0) * 0.02;\n    return sdBox(r - offset, circleRadius);// + (sin(float(id.x) * 0.5 + id.y * 0.05 + iTime * 0.0) * 0.5 + 0.5) * circleRadius * 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    //p *= 1.5;\n    float aspectRatio = 310.0 / 675.0;\n    float width = iResolution.y * aspectRatio;\n    if (p.x * iResolution.y * 0.5 < -width / 2.0 || p.x * iResolution.y * 0.5 >= width / 2.0) {\n        fragColor = vec4(0.05, 0.05, 0.05, 1);\n        return;\n    }\n\n    vec2 lightPos = vec2(sin(iTime) * 0.5, cos(iTime * 4.0) * 0.2);\n    lightPos = vec2(0.01);\n\n    \n    #if 1\n\tfloat d = abs(sdCircle(p-lightPos,0.15));\n    //d = min(d, abs(sdCircle(p, 0.7)));\n    //d = min(d, abs(sdCircle(p, 0.9)));\n    //d = min(d, abs(sdCircle(p, 1.1)));\n    //d = min(d, abs(sdCircle(p, 1.3)));\n    //d = min(d, abs(sdCircle(p, 1.5)));\n    //d = min(d, abs(sdCircle(p, 1.7)));\n    #else\n    \n    float d = sdBox(p,0.5);\n    d = min(d, abs(sdBox(p, 0.7)));\n    d = min(d, abs(sdBox(p, 0.9)));\n    d = min(d, abs(sdBox(p, 1.1)));\n    d = min(d, abs(sdBox(p, 1.3)));\n    d = min(d, abs(sdBox(p, 1.5)));\n    d = min(d, abs(sdBox(p, 1.7)));\n    #endif\n    \n    int id = 0;\n    d = min(grid(p, id, lightPos), d);\n    \n    vec3 bg_col = vec3(0,0,0);\n    float c = exp(-length(p-lightPos) * 2.5);//id != 0 ? random(id) * 0.2 - 0.1 : 0.0);\n    \n    vec3 light_col = vec3(1,1,1) * c * 1.5;\n    float t = 1.0 - smoothstep(-0.005 * (1.0 + c * 2.0), 0.005 * (1.0 + c * 2.0), d);\n    //t *= t;\n    float dd = sdCircle(p,0.5);\n    vec3 col = light_col * t + bg_col * (1.0 - t);\n    //col += d < 0.1 ? vec3(0.1) : vec3(0.0);\n    \n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}