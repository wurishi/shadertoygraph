{"ver":"0.1","info":{"id":"fsXBWl","date":"1645519142","viewed":73,"name":"Silly little spinny spheres","username":"kaia","description":"Trying to get back into shaders! A quick one to remind myself how everything works","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415926;\n\nfloat FOV_MULT = 0.5;\nvec3 DX = vec3(0.01, 0., 0.);\nvec3 DY = vec3(0., 0.01, 0.);\nvec3 DZ = vec3(0., 0., 0.01);\n\nvec3 MAT_AMBIENT = vec3(0.01);\nvec3 MAT_SPEC = vec3(100);\nvec3 MAT_DIFF = vec3(0.4, 0.8, 1.);\nfloat SMOOTHNESS = 20.;\n\nvec3 BG = vec3(0.05);\nvec3 LIGHT_COLOR = vec3(100.);\n\nvec3 to_color(vec3 vec) {\n    return (vec + vec3(1.0))/2.;\n}\n\nfloat bounce(float x) {\n    return 4.*x*(x-1.);\n}\n\nfloat easing(float x) {\n    float height_mult = 0.25;\n    float time_mult = 0.5;\n    //3 bounces\n    float total_time = .5 + time_mult + time_mult * time_mult;\n    x *= total_time;\n    \n    float bounce1 = float(x < .5);\n    float bounce2 = float(x < .5 + time_mult) - bounce1;\n    float bounce3 = 1. - bounce1 - bounce2;\n    \n    float bounce1_t = 0.5 + x;\n    float bounce2_t = (x - 0.5) / time_mult;\n    float bounce3_t = (x - 0.5 - time_mult) / (time_mult * time_mult);\n    \n    //BG=vec3(bounce1 * bounce1_t, bounce2 * bounce2_t, bounce3 * bounce3_t);\n    \n    return (bounce1 * bounce(bounce1_t)\n        + bounce2 * bounce(bounce2_t) * height_mult\n        + bounce3 * bounce(bounce3_t) * height_mult * height_mult);\n}\n\nfloat sphere_rotation() {\n    // pi/5 at t=1\n    // 0 at t= 0\n    // overshoot and lock\n    float t = mod(iTime*0.7, 1.);\n    float rotation = t;\n    float is_unlocked = float(t > 0.2);\n    float r = (t - 0.2) / 0.8;\n    float q = easing(r);\n    rotation = is_unlocked * (q);\n    \n    return rotation * PI*0.4;\n}\n\nfloat shape(vec3 pos, float t) {\n    float distortion = sin(pos.x * 8. + 4.*iTime);\n    \n    return length(pos) - .5 + 0.025 * distortion;\n}\n\nfloat sd(vec3 pos) {\n    float rot = sphere_rotation();\n    pos.xy = mat2(cos(rot), -sin(rot), sin(rot), cos(rot)) * pos.xy;\n    float theta = atan(pos.y, pos.x);\n    float radius = length(pos.yx);\n    \n    float mod_theta = mod(theta + 0.2 * PI, PI * 0.4) - 0.2 * PI;\n    vec3 bent_pos = vec3(cos(mod_theta) * radius, sin(mod_theta) * radius, pos.z);\n    return shape(bent_pos - vec3(2., 0., 0.), (.5+sin(iTime)*0.5));\n}\n\nvec3 normal(vec3 pos) {\n    float dist = sd(pos);\n    float dx = sd(pos + DX) - dist;\n    float dy = sd(pos + DY) - dist;\n    float dz = sd(pos + DZ) - dist;\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 phong(vec3 pos, vec3 camera_pos, vec3 light_pos, vec3 light_color, vec3 normal) {\n    vec3 light_vec = normalize(light_pos - pos);\n    vec3 camera_vec = normalize(camera_pos - pos);\n    \n    float diff = max(0., dot(normal, light_vec));\n    float spec = pow(max(0., dot(normal, (light_vec + camera_vec) / 2.)), SMOOTHNESS);\n    \n    vec3 light_falloff = light_color / pow(length(camera_pos - pos), 2.0);\n    \n    vec3 color = MAT_AMBIENT + light_falloff * MAT_SPEC * spec + light_falloff * MAT_DIFF * diff;\n    return vec3(color);\n}\n\nvec3 post_process(vec3 color, vec2 uv, float dist) {\n    vec3 alpha = pow(color, vec3(1./2.2));\n    return alpha * (1.0 - length(uv));\n}\n\nvec3 pixelImage(vec2 fragCoord) {\n    vec3 camera_pos = vec3(2., 0., -10.);\n    vec3 light_pos = vec3(3., 5., -2.);\n    vec3 camera_intensity = vec3(1.0);\n    \n    float max_size = max(iResolution.x, iResolution.y);\n    vec2 screen_uv = (fragCoord - (iResolution.xy / 2.0)) / (max_size / 2.0);\n    vec3 camera_ray = normalize(vec3(FOV_MULT * screen_uv, 1.));\n    \n    float dist = 100.;\n    vec3 ray_pos = camera_pos;\n    for (int i = 0; i < 10; i++) {\n        dist = sd(ray_pos);\n        ray_pos += camera_ray * dist;\n    }\n    vec3 norm_vec = normal(ray_pos);\n    vec3 phong_color = phong(ray_pos, camera_pos, light_pos, LIGHT_COLOR, norm_vec);\n    float is_bg = float(dist > 0.1);\n    vec3 color = phong_color * (1.0 - is_bg) + BG * is_bg;\n    \n    color = post_process(color, screen_uv, dist);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.);\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < 2; j++) {\n            color += pixelImage(fragCoord + vec2(float(i) / 2., float(j) / 2.));\n        }\n    }\n    fragColor = vec4(color/4., 1.0);\n}","name":"Image","description":"","type":"image"}]}