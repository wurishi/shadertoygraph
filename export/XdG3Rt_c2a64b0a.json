{"ver":"0.1","info":{"id":"XdG3Rt","date":"1581184413","viewed":82,"name":"Boring Basic Mandelbrot","username":"Xerophyte","description":"A basic float-only mandelbrot renderer. Nothing special, it just seemed like I should have one.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Maximum number of iterations of the Mandelbrot sequence to check before deciding if a point is in the set.\n// Has a high impact on both performance and accuracy.\nconst int MAX_ITER = 666;\n\n// Point on which the zoom is centered\nconst vec2 REGION_MID = vec2(-0.774472, 0.124979);\n\n// Zoom extremes\nconst float ZOOM_MIN  = 0.2;\nconst float ZOOM_MAX  = 50000.0;\n\n// Total time in seconds for the entire zoom loop\nconst float ZOOM_TIME = 50.0;\n\n// Colors used for the iteration count color cycle. Can use arbitrarily many.\nconst int NUM_COLORS = 3;\nvec4 COLORS[NUM_COLORS] = vec4[](\n    vec4(255.0, 237.0, 130.0, 255.0) / 255.0,\n    vec4(253.0, 143.0, 19.4,  255.0) / 255.0,\n    vec4(179.0, 29.0,  0.43,  255.0) / 255.0);\n\n// Colors used for the interior of the set\nvec4 INTERIOR_COLOR = vec4(0.1, 0.1, 0.1, 1.0);\n\n// Supersampling offsets used when rendering. This 16 sample pattern taken from:\n// http://docs.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels\nconst int NUM_SAMPLES = 16;\nvec2 SAMPLE_OFFSETS[NUM_SAMPLES] = vec2[](\n    vec2( 1.0, 1.0) / 16.0,\n    vec2(-1.0,-3.0) / 16.0,\n    vec2(-3.0, 2.0) / 16.0,\n    vec2( 4.0,-1.0) / 16.0,\n    \n    vec2(-5.0,-2.0) / 16.0,\n    vec2( 2.0, 5.0) / 16.0,\n    vec2( 5.0, 3.0) / 16.0,\n    vec2( 3.0,-5.0) / 16.0,\n    \n    vec2(-2.0, 6.0) / 16.0,\n    vec2( 0.0,-7.0) / 16.0,\n    vec2(-4.0,-6.0) / 16.0,\n    vec2(-6.0, 4.0) / 16.0,\n    \n    vec2(-8.0, 0.0) / 16.0,\n    vec2( 7.0,-4.0) / 16.0,\n    vec2( 6.0, 7.0) / 16.0,\n    vec2(-7.0,-8.0) / 16.0);\n\n\n// compute c0 * c1 for complex numbers c0, c1\nvec2 cmul(in vec2 c0, in vec2 c1) {\n    float r = c0.x * c1.x - c0.y * c1.y;\n    float i = c0.x * c1.y + c0.y * c1.x;\n    return vec2(r, i);\n}\n\n// compute c * c for a complex number c\nvec2 csqr(in vec2 c) {\n    float r = c.x * c.x - c.y * c.y;\n    float i = 2.0 * c.x * c.y;\n    return vec2(r, i);\n}\n\n// compute x * x for a float x\nfloat sqr(in float x) {\n\treturn x * x;   \n}\n\n// compute abs(c) * abs(c) for a complex number c\nfloat lengthsq(in vec2 c) {\n    return dot(c, c);\n}\n\n// Compute the next iteration of a Mandelbrot sequence from the previous value and the constant c\nvec2 iteration(in vec2 prev, in vec2 c) {\n    return csqr(prev) + c;\n}\n\n// True if a point c is in the main cardioid, else false\nbool inCardioid(in vec2 c) {\n    float tmp = c.x - 0.25;\n    float q = sqr(tmp) + sqr(c.y);\n    \n    return q * (q + tmp) < 0.25 * sqr(c.y);\n}\n\n\n// True if a point c is in the 2nd order bulb, else false\nbool in2Bulb(vec2 c) {    \n    return sqr(c.x + 1.0) + sqr(c.y) < (1.0 / 16.0);\n}\n\n\n// Compute the Mandelbrot normalized escape iteration count for a point on the complex plane.\n// Returns 0 for points that are estimated to be in the set\nfloat normIterCount(vec2 c) {\n    // If the point is in the main cardioid or 2nd order bulb then we can exit early.\n    if (inCardioid(c) || in2Bulb(c)) {\n        return 0.0;\n    }\n    \n    // Otherwise, see if and when the Mandelbrot sequence escapes for c.\n    vec2 z = c;\n    for (int i = 1 ; i < MAX_ITER ; ++i) {\n        float zsq = lengthsq(z);\n        \n\t\t// Escape is guaranteed if abs(z) > threshold on an iteration. A threshold of 2 is \n        // sufficient for testing if a point escapes, but with normalized iteration count the\n        // interpolation between iterations can only be estimated well with a larger threshold.\n        const float THRESHOLD = 256.0;\n        if (zsq > THRESHOLD * THRESHOLD) {\n            // The normalized iteration count formula following iq's fast version for\n            // a threshold of 256.\n            //\n            // Generally, given a THRESHOLD = p, the fast version is\n            // return float(i) - log2(log2(zsq)) + logs(log2(p)) + 1\n        \treturn float(i) - log2(log2(zsq)) + 4.0;\n        }\n        z = iteration(z, c);\n    }\n    \n    // The sequence did not escape for our iteration max. Treat as part of the set.\n    return 0.0;\n}\n\n// Convert from screen space fragment coordinates to a complex number.\nvec2 screenToComplex(vec2 fragCoord, float time) {    \n    // Weight is two smoothstep splines that blend from 0 to 1 and back over the specified time period.\n    float normTime = 2.0 * fract(time / ZOOM_TIME);\n    float weight = normTime > 1.0 ? 2.0 - normTime : normTime;\n    weight = smoothstep(0.0, 1.0, weight);\n    \n    // Do the interpolation in log space so the zoom rate appears constant.\n    // Blend between the log min/max zoom values, then transform back to real zoom coefficient.\n\tconst float LOG_ZOOM_MIN = log(ZOOM_MIN);\n    const float LOG_ZOOM_MAX = log(ZOOM_MAX);\n    float logZoom = mix(LOG_ZOOM_MIN, LOG_ZOOM_MAX, weight);    \n    float zoom = exp(logZoom);\n    \n    // Scale the render region by the zoom value and transform fragCoord to a complex number.\n\tfloat regionSize = 1.0 / zoom;\n    float scale = regionSize / iResolution.y;\n    vec2 c = fragCoord.xy * scale;    \n    c = c + REGION_MID - 0.5 * regionSize;\n    \n    return c;\n}\n\n// Compute a color value from a normalized iteration count.\nvec4 computeColor(float iter) {\n    // If a part of the set, use the interior color.\n    if (iter == 0.0) {\n    \treturn INTERIOR_COLOR;   \n    }\n    \n    // Else use a blend between the colors of the cycle. I take the log of the iteration count because I\n    // like how it makes the areas closer to the set where iterations change rapidly look less busy and\n    // aliased. Most renderers do not do this.\n    float ifloor;\n    float imod = modf(log2(iter), ifloor);    \n    int ix = int(ifloor);\n    vec4 color = mix(COLORS[ix % NUM_COLORS], COLORS[(ix + 1) % NUM_COLORS], imod);\n    \n    return color;\n}\n\n// Sample the mandelbrot colorization at a point in screen space.\nvec4 sampleMandelbrot(vec2 fragCoord, float time) {\n    // Convert screen position to a complex number c\n\tvec2 c = screenToComplex(fragCoord, time);\n    \n    // Compute the normalized iteration count for the Mandelbrot sequence for c \n    float iter = normIterCount(c);\n    \n    // Color according to the normalized iteration count.\n\treturn computeColor(iter);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 color = vec4(0.0);\n    \n    // Sample N points around the pixel according to the hardcoded supersample offsets.\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        color += sampleMandelbrot(fragCoord + SAMPLE_OFFSETS[i], iTime);\n    }\n    \n    // Average the color samples.\n\tfragColor = color / float(NUM_SAMPLES);\n}","name":"Image","description":"","type":"image"}]}