{"ver":"0.1","info":{"id":"7lBSWz","date":"1627412741","viewed":90,"name":"double spiral Tangent","username":"TLC123","description":"double spiral with limitations.\n Tried to solve limitation with linear\"middle\" piece but  failed to get perfect tangens\nOnly support Archimedean spiral for now, expand to log and hyp later\n ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","spiral","distance","saffronbun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"double spiral \" by TLC123. https://shadertoy.com/view/ft2SRh\n// 2021-07-27 16:21:03\n// and iquilezles.org/articles/distfunctions2d\n \nvec4  getTangents(float x1, float y1, float r1, float x2, float y2, float r2) {\n        float d_sq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n        if (d_sq <= (r1-r2)*(r1-r2)) return vec4(0);\n\n        float d =  sqrt(d_sq);\n        float vx = (x2 - x1) / d;\n        float vy = (y2 - y1) / d;\n\n        vec4 res  ;\n        int i = 0;\n\n        // Let A, B be the centers, and C, D be points at which the tangent\n        // touches first and second circle, and n be the normal vector to it.\n        //\n        // We have the system:\n        //   n * n = 1          (n is a unit vector)          \n        //   C = A + r1 * n\n        //   D = B +/- r2 * n\n        //   n * CD = 0         (common orthogonality)\n        //\n        // n * CD = n * (AB +/- r2*n - r1*n) = AB*n - (r1 -/+ r2) = 0,  <=>\n        // AB * n = (r1 -/+ r2), <=>\n        // v * n = (r1 -/+ r2) / d,  where v = AB/|AB| = AB/d\n        // This is a linear equation in unknown vector n.\n\n            float sign1 = -1.;\n            {\n            float c = (r1 - sign1 * r2) / d;\n\n            // Now we're just intersecting a line with a circle: v*n=c, n*n=1\n\n            if (c*c > 1.0)  ;\n            float h =  sqrt( max(0.0, 1.0 - c*c));\n\n             float sign2 = -1.;  {\n                float nx = vx * c - sign2 * h * vy;\n                float ny = vy * c + sign2 * h * vx;\n\n               res= vec4(\n                x1 + r1 * nx,\n                y1 + r1 * ny,\n                 x2 + sign1 * r2 * nx,\n                 y2 + sign1 * r2 * ny);\n            }\n        }\n        \n        return res ;\n    }\n \n \n float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat  smin( float a, float b,float k )\n{\n    float h =  clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ) ;\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n  \n\nfloat f(vec2 p,vec2 from ,vec2 to,float r0,float r1,float t0,float t1,float e0,float e1)\n{\n\n vec4 res=getTangents(from.x,from.y, r0, to.x, to.y, r1);\nvec2 p0=res.xy;\nvec2 p1=res.zw;\nvec2 v0=p0-from;\nvec2 v1=p1-to;\nvec2 vec=normalize(to-from);\nvec2 p2=from+vec2(-vec.y,vec.x)*-r0;\nvec2 p3=to+vec2(-vec.y,vec.x)*r1; \n\nfloat av= atan(vec.x,vec.y) ;\n    float c = cos(-av+3.1415*0.5);\n    float s = sin(-av+3.1415*0.5);\n    mat2 rot =mat2(c,s,-s,c);\nvec2 l0=(p-from)* rot;\n\n  av= atan(vec.x,vec.y) ;\n      c = cos(-av+3.1415*0.5);\n      s = sin(-av+3.1415*0.5);\n      rot =mat2(c,s,-s,c);\n \nvec2 l1=(p-to)* rot;\n\n\n\nfloat a0= atan(l0.x,l0.y)/(3.1415*2.) ;\nfloat a1= atan(-l1.x,-l1.y)/(3.1415*2.) ;\n\nfloat step0=.5+( a0 ) ;\nfloat step1=.5+ a1 ;\n\nfloat d=1./0.;\n \nfor (float i=fract(t0);i<= (t0);i++){\n d=min(d,abs(length  (p-from)-(( (i)-step0)/t0)*r0 ));\n}\nfor (float i=fract(t1);i<= (t1);i++){\n d=min(d,abs(length  (p-to  )-(( (i)-step1)/t1)*r1 ));\n}\n \n // the litte knob at centers\nd=smin(d,length(from-p)-r0*0.025,r0*0.1);\nd=smin(d,length(to-p)-r1*0.025,r1*0.1);\n \n\nd=min(d,sdSegment(   p, res.xy,res.zw ));\nd=min(d,length(p-(p0+p1)/2.)-(r0+r1)*.05);\nd=min(d,length(p-(p0 ) )-(r0+r1)*.025);\nd=min(d,length(p-(p1 ) )-(r0+r1)*.025);\nd=min(d,length(p-(p2 ) )-(r0+r1)*.025);\nd=min(d,length(p-(p3 ) )-(r0+r1)*.025);\n \nreturn d;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p =   (fragCoord*2.0-iResolution.xy)/iResolution.y;\n     \n     \n    // driver code \n \tvec2 r;\n    vec2 from = .5*vec2(-sin (iTime*0.4365  ), cos(iTime*0.3355  ));\n    vec2 to = .5*vec2(1, cos(iTime*0.8647   )*.9);\n  \n    r.x= length(from-to)- abs(sin(iTime*0.46436   ))*length(from-to)*.5-length(from-to)*.25 ;\n    r.y =length(from-to)-r.x;\n  r*=.5;\n    vec2 t =  3.+(2.*vec2(sin(iTime*0.513546   ), cos(iTime*0.96764   ) ));\n    t=clamp(t,.5,2.);\n  \n    // distance\n    float d=f(p,from ,to,r.x,r.y,t.x,t.y,1.,1.);\n\n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n \n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}