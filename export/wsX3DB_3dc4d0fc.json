{"ver":"0.1","info":{"id":"wsX3DB","date":"1547371808","viewed":108,"name":"Line overlap ","username":"anemolo","description":"Idea from Thom Yorke - The Eraser. Might make something similar soon\n\nControls:\n1 => toggle to see singular lines\n2 => toggle to see masking funciton","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["lines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.14159265359\n// Props to FabriceNeyret2 for this antialiasing function :)\n#define S(v) smoothstep(0.,1.5*fwidth(v), v )\n\n// keyToggle Stolen from https://www.shadertoy.com/view/Xsl3zX :b\n// Don't know how it works, might have to look into it later.\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel0,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec3 color = vec3(0.0);\n\n    // To move the cross we move the space\n\n    // Add the shape on the foreground\n    // Add  0.1 + sin(u_time) * 0.2) to move displacement\n    // Add u_time to displament sin for x movement\n    float yDisplacement = sin(st.x * PI * 2. + PI* iTime *2.)*(0.1 + sin(iTime*2.+PI) * 0.05) ;\n    st.y -= yDisplacement;\n    float freq = 19.;\n    // front wave\n    vec3 frontWave = vec3(S(sin(st.y * PI * freq) * 0.5+0.5 -0.5));\n    color = frontWave;\n    // Initially this sin function is a screen long. And to move into place, we just move it by the frequency \n    // PI * 1./14. Allways multiplied by PI because that's what sin uses\n    float lines = min(freq, 5.);\n    // Hidden has to be before the reset because we need it with the displacement\n    float mask = S(sin(st.y * PI + PI * 1./freq * lines)*0.5+0.5-0.5);\n    // Multiply by mask to eliminate everything outside of the white part of the mask\n    color *= mask;\n    // Reset y displacement\n    // So it doesnt affect the backWave\n    st.y += yDisplacement;\n    \n    //  Fisrt part of mult is for the wave itself.\n    // Second part is for how strong the wave is.\n    float xDisplacement = sin(st.y * PI * 2. + iTime * PI *2.)*(0.1 + sin(iTime*2.) *0.);\n    // xDisplacement = 600.5;\n    st.x -= xDisplacement;\n    // u_time here moves x axis. But dont need it because we have xDisplacement\n\tvec3 backWave = vec3(S(sin(st.x * PI * freq) * 0.5+0.5- 0.5));\n    // Multiply by the reverse mask to only add that part of the wave\n\tcolor += backWave * (1. - mask);\n    // Keyboard controls\n    // Look at the different parts of this shader\n    if (keyToggle(49)) { \n        color = frontWave * smoothstep(-0.05,0.05,sin(iTime* 1.5)) + backWave * smoothstep(-0.05,0.05,sin(iTime *1.5 + PI));\n    }\n\tif (keyToggle(50)) color = vec3(mask);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}