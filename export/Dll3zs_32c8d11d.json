{"ver":"0.1","info":{"id":"Dll3zs","date":"1676400929","viewed":3132,"name":"Diffuse ReSTIR GI","username":"Mathis","description":"ReSTIR GI using 2 bounces and TAA without a spatial denoiser --> some noise will be visible in the viewport.\nMax viewport resolution is 3072x2048.\n\nMore info in the Image tab.","likes":68,"published":1,"flags":48,"usePreview":1,"tags":["gi","tracing","path","restir","reservoir"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nNotes:\n    Performance\n        Analytic intersections are used instead of ray marching a SDF\n        Normals are computed by sampling a SDF-version of the scene\n        Many iterations will sample \"Gradient\" -> poor performance\n    Scene\n        Very high quality scene which is extremely artistic\n    ReSTIR\n        All meaningful attributes are stored together with reservoir positions to improve reprojection quality\n    Reprojection\n        Based on nearest neighbour gathering\n            Search in a 3x3 pixel area inside the last frame screen to find good reservoirs\n            To completely remove smearing/distortion a scattering approach is better\n                A 3x3 search area is enough\n                The main cost is increased noise, which can be reduced with an additional spatial pass\n        No motion vectors\n    Adaptivity\n        Old rays are retraced every third frame to remove stale samples when lights/geometry have moved\n    Spatial reservoirs\n        Visibility is approximated with a screen space ray marcher\n            It is bad because 2D samples are not uniformly distributed in screen space, just in world space\n            It also assumes pixels have infinite thickness behind their depths\n    Shadows are denoised using a two pass filter\n    TAA\n        Only reprojection and color clamping is used\n\nControls:\n    WASD to move the camera\n    Mouse to rotate the camera\n    M/N to rotate the sun\n*/\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float YOffset = floor(fragCoord.x*I1024)*1024.+floor(fragCoord.y*I1024)*3072.;\n    vec3 Color = textureCube(mod(fragCoord,1024.)+vec2(0.,YOffset)).xyz;\n    fragColor=vec4(pow(1.-exp(-1.2*Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV = radians(85.); //In radians\nconst vec3 SkyLight = vec3(0.15,0.6,1.)*0.75;\nconst vec3 SunLight = vec3(1.,0.7,0.4)*3.5;\nconst float SunCR = 0.08;\nconst float EmissiveStrength = 3.75;\nconst float M_CLAMP_T = 16.; //Temporal M clamp (diffuse)\n#define Spatial_Unbiased_RT\n\n//Other vars\nconst float ExternalLightFactor = 2.; //Factor outside of the color clamped value\nconst float LightCoeff = 5.;\nconst float ILightCoeff = 1./LightCoeff;\nconst float FAR = 256.;\nconst float CFOV = tan(FOV*0.5);\nconst float PI = 3.141592653;\nconst float IPI = 1./PI;\nconst float PI2 = PI*2.;\nconst float IPI2 = 0.5/PI;\nconst float I3 = 1./3.;\nconst float I16 = 1./16.;\nconst float I32 = 1./32.;\nconst float I64 = 1./64.;\nconst float I256 = 1./256.;\nconst float I300 = 1./300.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float I2048 = 1./2048.;\nconst vec2 eps = vec2(0.,0.00025);\n#define RES iChannelResolution[0].xy\n#define IRES (1./iChannelResolution[0].xy)\n#define ASPECT vec2(RES.x/RES.y,1.)\n\nconst vec2 SSOffsets[16] = vec2[16](vec2(0.),vec2(-0.4,-0.4),vec2(0.,0.2),vec2(0.15,-0.4),vec2(-0.4,-0.15),\n                                    vec2(0.15,0.4),vec2(-0.2,-0.2),vec2(-0.4,0.4),vec2(0.4,0.15),vec2(0.2,-0.2),\n                                    vec2(0.4,0.4),vec2(-0.4,0.15),vec2(0.4,-0.15),\n                                    vec2(-0.15,0.4),vec2(0.4,-0.4),vec2(-0.15,-0.4));\n//SKY\nvec3 SampleSky(vec3 d, float Time) {\n    return SkyLight*pow(max(0.,d.y),0.25); //*pow(max(0.,sin(Time*0.85+1.)),0.25);\n}\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec3 p, vec3 b) {\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat DFCylinder(vec3 p, float r, float h) {\n    vec2 d = vec2(length(p.xz)-r,abs(p.y)-h);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\n\nfloat DFPlane(vec3 p, vec3 p0, vec3 p1, vec3 p2) {\n    //Intersects a plane\n    vec3 Normal = normalize(cross(p1-p0,p2-p0));\n    vec3 tp = vec3(dot(p-p0,normalize(p1-p0)),dot(p-p0,normalize(p2-p0)),dot(p-p0,Normal));\n    return DFBox(tp-vec3(0.,0.,-0.005),vec3(length(p1-p0),length(p2-p0),0.01));\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = floor(atan(p.x,p.y)/ang+0.5);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\nvec4 MIN(vec4 d, vec4 nd) {\n    return ((nd.w<d.w)?nd:d);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)<=0.999)?normalize(cross(N,vec3(0.,1.,0.))):vec3(1.,0.,0.));\n    return normalize(cross(O,N));\n}\n\nvec3 RandSample(vec2 v) {\n    float r=sqrt(1.-v.x*v.x);\n    float phi=2.*3.14159*v.y;\n    return vec3(cos(phi)*r,sin(phi)*r,v.x);\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nvec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec2 boxfarNormal(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin=(bmin-origin)*dir;\n    vec2 tMax=(bmax-origin)*dir;\n    vec2 t2=max(tMin,tMax);\n    vec2 signdir = -(max(vec2(0.),sign(dir))*2.-1.);\n    if (t2.x<t2.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\n//Non-optimal vec2/vec3 to float functions\nvec3 FloatToVec3(float v) {\n    float x = fract(v);\n    float z = floor(v*I300);\n    float y = floor(v-z*300.)*I300;\n    return vec3(x,y,z*I300);\n}\n\nfloat Vec3ToFloat(vec3 v) {\n    v = min(v,vec3(0.998));\n    return v.x+floor(v.y*300.)+floor(v.z*300.)*300.;\n}\n\nvec2 FloatToVec2(float v) {\n    return vec2((floor(fract(v)*2048.)+0.5)*I2048,(floor(v)+0.5)*I2048);\n}\n\nfloat Vec2ToFloat(vec2 v) {\n    v = min(v,vec2(0.9999));\n    return v.x+floor(v.y*2048.);\n}\n\nvec2 FloatToVec2WM(float v) {\n    float x = fract(v);\n    float y = floor(mod(v,100.));\n    return vec2(x,y);\n}\n\nfloat Vec2ToFloatWM(vec2 v) {\n    return min(v.x,0.99999)+floor(v.y);\n}\n\n//Tracer\nvec3 C_DarkWood(vec3 uv) {\n    //uv in ([0,1],[0,1])\n    vec3 fuv = floor(uv*vec3(4.,16.,16.))+0.5;\n    vec2 RV = ARand23(fuv.xy*2.15362+fuv.z*1.43).xy;\n    return mix(vec3(0.15,0.1,0.05),vec3(0.3,0.15,0.06)*RV.x,RV.y);\n}\n\nvec3 C_Planks(vec2 uv) {\n    //uv in ([0,1],[0,1])\n    vec2 fuv = floor(uv*vec2(16.,4.)-0.001)+0.5;\n    vec2 RV = ARand23(fuv).xy;\n    return mix(vec3(0.7,0.4,0.13),vec3(0.6,0.45,0.325)*RV.x,RV.y)*(0.25+0.75*float(\n               DFBox(fract(uv*vec2(4.,1.)-0.001-vec2(0.,floor(uv.x*4.)*0.75)),vec2(1.-0.125,1.-I32))<0.));\n}\n\nvec3 C_Bricks(vec2 uv) {\n    //uv in ([0,1],[0,1])\n    vec2 fuv = floor(uv*vec2(16.,8.))+0.5;\n    if ((fuv.y>4. && abs(fuv.x-3.5)<0.1) || (fuv.y<4. && abs(fuv.x-11.5)<0.1) || fuv.y<1. || abs(fuv.y-4.5)<0.1) return vec3(0.2);\n    return vec3(0.9,0.25,0.1);\n}\n\nvec4 SDF(vec3 p, float Time) {\n    vec4 d = vec4(vec3(0.1,0.85,0.1),p.y+0.1);\n    \n    //Floor\n    d = MIN(d,vec4(C_Planks(p.xz),DFBox(p-vec3(0.,-0.1,0.),vec3(6.,0.1,8.))));\n    \n    //X-Normal wall with door\n    d = MIN(d,vec4(C_Bricks(fract(p.zy*vec2(1.5,3.01))),DFBox(p-vec3(0.,0.,3.),vec3(0.1,2.5,5.))));\n    \n    //X-Normal wall with opposite\n    d = MIN(d,vec4(C_Bricks(fract(p.zy*vec2(1.5,3.01))),DFBox(p-vec3(5.9,0.,0.),vec3(0.1,2.5,8.))));\n    \n    //Z-Normal wall\n    d = MIN(d,vec4(C_Bricks(fract(p.xy*vec2(1.5,3.01))),DFBox(p-vec3(0.,0.,0.),vec3(5.9,2.5,0.1))));\n    d = MIN(d,vec4(C_Bricks(fract(p.xy*vec2(1.5,3.01))),DFBox(p-vec3(0.1,0.,7.9),vec3(5.8,2.5,0.1))));\n    \n    //Ceiling wood\n    if (DFBox(p-vec3(-0.2,2.4,-0.2),vec3(6.4,1.,8.4))<0.) {\n        d = MIN(d,vec4(C_DarkWood(p),DFBox(p-vec3(-0.15,2.5,-0.15),vec3(6.3,0.3,0.3))));\n        d = MIN(d,vec4(C_DarkWood(p),DFBox(p-vec3(-0.15,2.5,3.),vec3(6.3,0.3,0.3))));\n        d = MIN(d,vec4(C_DarkWood(p),DFBox(p-vec3(-0.15,2.5,5.35),vec3(6.3,0.3,0.3))));\n        d = MIN(d,vec4(C_DarkWood(p),DFBox(p-vec3(-0.15,2.5,7.85),vec3(6.3,0.3,0.3))));\n    }\n    \n    //Rotated wood\n    vec3 RP = p-vec3(3.,2.8,4.); RP.xz = Rotate(RP.xz,max(0.,Time-1.)*0.6);\n    d = MIN(d,vec4(vec3(0.2),DFBox(RP-vec3(-2.5,0.,-4.2),vec3(5.,0.2,8.4))));\n    \n    //Random rotated box grid\n    if (DFBox(p-vec3(0.,0.,3.),vec3(6.,2.5,5.))<0.) {\n        vec3 fp = floor(p);\n        vec3 Rand3 = ARand23(fp.xz+0.25);\n        vec3 RP = p-vec3(fp.x+0.5,0.,fp.z+0.5); RP.xz = Rotate(RP.xz,Rand3.x*1.5);\n        float Radius = 0.4-0.2*Rand3.x;\n        d = MIN(d,vec4(C_DarkWood(RP.zyx)*3.,DFBox(RP-vec3(-Radius,0.,-Radius),vec3(2.*Radius,fp.z*fp.z*0.045,2.*Radius))));\n    }\n    \n    d = MIN(d,vec4(C_Planks(p.xz),DFBox(p-vec3(1.,1.,0.05),vec3(2.,0.1,1.45))));\n    d = MIN(d,vec4(C_DarkWood(p),DFBox(p-vec3(1.,0.,0.05),vec3(0.1,1.,1.45))));\n    d = MIN(d,vec4(C_DarkWood(p),DFBox(p-vec3(2.9,0.,0.05),vec3(0.1,1.,1.45))));\n    \n    //Output\n    return d;\n}\n\nvec3 Gradient(vec3 p, float Time, out vec4 SDFS) {\n    SDFS = SDF(p,Time);\n    return normalize(vec3(SDF(p+eps.yxx,Time).w,SDF(p+eps.xyx,Time).w,SDF(p+eps.xxy,Time).w)-SDFS.w);\n}\n\nfloat Trace_Sphere(vec3 Pos, vec3 Dir) {\n    //Ray tracing against geometry\n    float dfs; float D=0.;\n    for (int i=0; i<654; i++) {\n        dfs = length(Pos+Dir*D-vec3(1.5,0.5,1.5))-0.5;\n        if (min(FAR-D,dfs-0.0002)<0.) {\n            return D;\n        }\n        D += dfs;\n    }\n    return FAR+1.;\n}\n\nfloat Trace(vec3 P, vec3 D, float Time) {\n    float OUT = 100000.;\n    vec3 ID = 1./D;\n    //Ground\n    if (D.y<0.) OUT = -(P.y+0.1)/D.y;\n    \n    //Floor\n    vec2 bb = box(P,ID,vec3(0.,-0.1,0.),vec3(6.,0.,8.));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    \n    //X-Normal wall with door\n    bb = box(P,ID,vec3(0.,0.,3.),vec3(0.1,2.5,8.));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    \n    //X-Normal wall opposite\n    bb = box(P,ID,vec3(5.9,0.,0.),vec3(6.,2.5,8.));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    \n    //Z-Normal wall\n    bb = box(P,ID,vec3(0.,0.,0.),vec3(5.9,2.5,0.1));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    bb = box(P,ID,vec3(0.1,0.,7.9),vec3(5.9,2.5,8.));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    \n    //Ceiling\n    bb = box(P,ID,vec3(-0.2,2.5,-0.2),vec3(6.2,2.8,8.2));\n    if ((bb.x>0. && bb.y>bb.x) || DFBox(P-vec3(-0.2,2.4,-0.2),vec3(6.4,1.,8.4))<0.) {\n        bb = box(P,ID,vec3(-0.15,2.5,-0.15),vec3(6.15,2.8,0.15));\n        if (bb.x>0. && bb.y>bb.x) OUT = min(OUT,bb.x);\n        bb = box(P,ID,vec3(-0.15,2.5,3.),vec3(6.15,2.8,3.3));\n        if (bb.x>0. && bb.y>bb.x) OUT = min(OUT,bb.x);\n        bb = box(P,ID,vec3(-0.15,2.5,5.35),vec3(6.15,2.8,5.65));\n        if (bb.x>0. && bb.y>bb.x) OUT = min(OUT,bb.x);\n        bb = box(P,ID,vec3(-0.15,2.5,7.85),vec3(6.15,2.8,8.15));\n        if (bb.x>0. && bb.y>bb.x) OUT = min(OUT,bb.x);\n    }\n    \n    //Rotated wood\n    vec3 RP = P-vec3(3.,2.8,4.); RP.xz = Rotate(RP.xz,max(0.,Time-1.)*0.6);\n    vec3 RD = D; RD.xz = Rotate(RD.xz,max(0.,Time-1.)*0.6);\n    bb = box(RP,1./RD,vec3(-2.5,0.,-4.2),vec3(2.5,0.2,4.2));\n    if (bb.x>0. && bb.y>bb.x) OUT = min(OUT,bb.x);\n    \n    //Random rotated box grid\n    bb = box(P,ID,vec3(0.,0.,3.),vec3(6.,2.5,8.));\n    if ((bb.x>0. && bb.y>bb.x) || DFBox(P-vec3(0.,0.,3.),vec3(6.,2.5,5.))<0.) {\n        //Per 1x1 meter\n        vec3 StartPos = P;\n        if (bb.x>0. && bb.y>bb.x) StartPos = P+D*(bb.x+0.001);\n        vec3 fp = floor(StartPos); vec3 RP,RD,Rand3; float Radius;\n        for (int i=0; i<16; i++) {\n            if (DFBox(fp.xz+0.5-vec2(0.,3.),vec2(6.,5.))>0.) break;\n            Rand3 = ARand23(fp.xz+0.25);\n            RP = P-vec3(fp.x+0.5,0.,fp.z+0.5); RP.xz = Rotate(RP.xz,Rand3.x*1.5);\n            RD = D; RD.xz = Rotate(RD.xz,Rand3.x*1.5);\n            Radius = 0.4-0.2*Rand3.x;\n            bb = box(RP,1./RD,vec3(-Radius,0.,-Radius),vec3(Radius,fp.z*fp.z*0.045,Radius));\n            if (bb.x>0. && bb.y>bb.x) { OUT = min(OUT,bb.x); }\n            fp.xz -= boxfarNormal(P.xz,ID.xz,fp.xz,fp.xz+1.);\n        }\n    }\n    \n    bb = box(P,ID,vec3(1.,1.,0.05),vec3(3.,1.1,1.5));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    bb = box(P,ID,vec3(1.,0.,0.05),vec3(1.1,1.,1.5));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    bb = box(P,ID,vec3(2.9,0.,0.05),vec3(3.,1.,1.5));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT) OUT = bb.x;\n    \n    //Return\n    return OUT;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage + Depth + Secondary rays\n\nvec3 Sample_L(vec3 RayP, vec3 RayD, vec3 SunDir, vec2 Rand2, out float SampleD) {\n    //Returns 1 or 1+2 bounced lighting\n    vec3 L = vec3(0.);\n    //First bounce\n    SampleD = Trace(RayP,RayD,iTime);\n    if (SampleD<=FAR) {\n        //Geometry hit\n        vec3 SampleP = RayP+RayD*SampleD;\n        vec4 SampleSDF; vec3 SampleN = Gradient(SampleP,iTime,SampleSDF);\n        if (SampleSDF.x>1.) {\n            //Emissive\n            L += EmissiveStrength*vec3(SampleSDF.x-1.,SampleSDF.yz);\n        } else {\n            //Diffuse\n            vec3 Rand3 = clamp(ARand23(Rand2*9.234),vec3(0.0001,0.0001,0.),vec3(0.9999,0.9999,1.));\n            vec3 RandDir = normalize(RandSampleCos(Rand3.xy)*TBN(SunDir)*SunCR+SunDir);\n            if (dot(SampleN,RandDir)>0.) {\n                if (Trace(SampleP+SampleN*0.001,RandDir,iTime)>FAR) L += SunLight*SampleSDF.xyz*max(0.,dot(SampleN,RandDir));\n            }\n            //Second bounce\n            vec3 RayD2 = RandSample(Rand3.xy)*TBN(SampleN);\n            float SampleD2 = Trace(SampleP+SampleN*0.001,RayD2,iTime);\n            if (SampleD2<=FAR) {\n                //Geometry hit\n                vec3 SampleP2 = SampleP+SampleN*0.001+RayD2*SampleD2;\n                vec4 SampleSDF2; vec3 SampleN2 = Gradient(SampleP2,iTime,SampleSDF2);\n                if (SampleSDF2.x>1.) L += EmissiveStrength*SampleSDF.xyz*vec3(SampleSDF2.x-1.,SampleSDF2.yz);\n                else {\n                    //Diffuse\n                    Rand3 = clamp(ARand23(Rand2*3.234),vec3(0.0001,0.0001,0.),vec3(0.9999,0.9999,1.));\n                    RandDir = normalize(RandSampleCos(Rand3.xy)*TBN(SunDir)*SunCR+SunDir);\n                    if (dot(SampleN2,RandDir)>0.) {\n                        if (Trace(SampleP2+SampleN2*0.001,RandDir,iTime)>FAR)\n                            L += SunLight*SampleSDF.xyz*SampleSDF2.xyz*max(0.,dot(SampleN2,RandDir));\n                    }\n                }\n            } else {\n                //Sky hit\n                L += SampleSky(RayD2,iTime)*SampleSDF.xyz;\n            }\n        }\n    } else {\n        //Sky hit\n        L += SampleSky(RayD,iTime);\n    }\n    return L;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0,fragCoord.xy*IRES);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Output = vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Output = vec4(0.,-0.7,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Output = vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Output = vec4(5.5,1.7,0.5,1.); //Player Pos\n            else if (fragCoord.x<5.) Output = vec4(0.4,-2.15,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Output = vec4(0.,0.,0.,0.); //Sun direction\n        }\n    } else { //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //Börjat klicka\n                    if (Output.w==0.) {\n                    \tOutput.w = 1.;\n                    \tOutput.xy = iMouse.zw;\n                    }\n                } else Output.w = 0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Output.zw = Output.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tOutput.x = Output.z+(iMouse.y-LMouse.y)*0.01;\n                \tOutput.x = clamp(Output.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tOutput.y = Output.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tOutput.y = mod(Output.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles = texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Output.xyz = normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed = iTimeDelta;\n                \tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed = 5.*iTimeDelta;\n                vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Output.xyz += Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Output.xyz -= Eye*Speed; //S\n                vec3 Tan = normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Output.xyz -= Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Output.xyz += Tan*Speed; //D\n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Output.y += iTimeDelta*1.5;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Output.y -= iTimeDelta*1.5;\n                Output.z = Output.y; //Sunangle last frame\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles = texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Output = vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) { //Last frame dir\n                Output = texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) { //Last frame position\n                Output = texture(iChannel0,vec2(3.5,0.5)*IRES);\n            } else if (fragCoord.x<9.) { //Last frame SunDir\n                Output = texture(iChannel0,vec2(5.5,0.5)*IRES);\n            } else if (fragCoord.x<10.) { //Last last frame dir\n                Output = texture(iChannel0,vec2(6.5,0.5)*IRES);\n            } else if (fragCoord.x<11.) { //Last last frame position\n                Output = texture(iChannel0,vec2(7.5,0.5)*IRES);\n            }\n        } else if (DFBox(fragCoord-vec2(1.),RES-2.)<0.) {\n            vec2 SSOffset = SSOffsets[iFrame%16];\n            float CurrentFrame = float(iFrame);\n            vec2 UV = fragCoord+SSOffset;\n            vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n            vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n            vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n            vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n            vec3 LPos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n            vec3 LEye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n            mat3 LEyeMat = TBN(LEye);\n            vec3 Dir = normalize(vec3((UV*IRES*2.-1.)*CFOV*ASPECT,1.)*TBN(Eye));\n            float PixelD = Trace(Pos,Dir,iTime);\n            if (PixelD<=FAR) {\n                //Geometry\n                vec3 PPos = Pos+Dir*PixelD;\n                vec4 PixelSDF; vec3 Normal = Gradient(PPos,iTime,PixelSDF);\n                \n                \n                \n                \n                //\n                //Diffuse ray\n                //\n                vec3 RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n                RandV.xy = (floor(RandV.xy*2048.)+0.5)*I2048;\n                vec2 ShadowRandV = RandV.xy;\n                float DiffuseDist;\n                vec3 DPPos = PPos+Normal*0.001;\n                vec3 DNormal = Normal;\n                if (iFrame%3==0) {\n                    //Re-trace ray\n                    vec3 CVPos = PPos-LPos;\n                    vec3 LVPos = vec3(dot(CVPos,LTan),dot(CVPos,LBit),dot(CVPos,LEye));\n                    vec2 LuvCenter = floor(((LVPos.xy/LVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES);\n                    float SmallestDistance = 1000.; vec2 LResUV = vec2(-1.);\n                    vec3 RayStartPos = vec3(-1.); vec3 RayNormal = vec3(-1.);\n                    for (float x = -1.; x<1.5; x++) {\n                        for (float y = -1.; y<1.5; y++) {\n                            vec4 LRSample = texture(iChannel3,(LuvCenter+0.5+vec2(x,y))*IRES);\n                            vec2 LRluv = LuvCenter+vec2(x,y)+FloatToVec2(LRSample.y);\n                            vec3 LRDir = normalize(vec3((LRluv*IRES*2.-1.)*CFOV*ASPECT,1.)*LEyeMat);\n                            vec3 LRPPos = LPos+LRDir*LRSample.x;\n                            vec4 LRSDF; vec3 LRNormal = Gradient(LRPPos,iTime,LRSDF);\n                            //Reprojection on current screen space\n                            vec3 RVPos = LRPPos-Pos;\n                            RVPos = vec3(dot(RVPos,Tan),dot(RVPos,Bit),dot(RVPos,Eye));\n                            vec2 LRUV = ((RVPos.xy/RVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                            float LRUVDist = length(fragCoord-LRUV);\n                            if (LRSample.x<FAR && DFBox(LRUV-1.,RES-2.)<0. && abs(dot(Normal,LRPPos-PPos))<0.05\n                                && dot(Normal,LRNormal)>0.9 && LRUVDist<SmallestDistance) {\n                                SmallestDistance = LRUVDist;\n                                LResUV = LRluv;\n                                RayStartPos = LRPPos+LRNormal*0.001;\n                                RayNormal = LRNormal;\n                            }\n                        }\n                    }\n                    if (DFBox(LResUV-1.,RES-2.)<0.) {\n                        //Reprojection coordinate is outside of the last frame screen\n                        DPPos = RayStartPos;\n                        RandV.xy = FloatToVec2(texture(iChannel2,LResUV*IRES).y);\n                        DNormal = RayNormal;\n                    }\n                }\n                \n                \n                vec3 RandDir = RandSample(RandV.xy)*TBN(DNormal);\n                vec3 DiffuseLight = Sample_L(DPPos,RandDir,SunDir,RandV.xy,DiffuseDist);\n                \n                \n                \n                \n                //\n                //Shadow ray\n                //\n                RandDir = normalize(RandSampleCos(ShadowRandV)*TBN(SunDir)*SunCR+SunDir);\n                float ShadowDist = -1.;\n                if (dot(Normal,RandDir)>0.) ShadowDist = Trace(DPPos,RandDir,iTime);\n                //Output\n                Output = vec4(PixelD,Vec3ToFloat(DiffuseLight*ILightCoeff),DiffuseDist,ShadowDist);\n            } else {\n                //Sky\n                Output = vec4(FAR+10.,-1.,-1.,-1.);\n            }\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Reprojection of the reservoir positions + Shadow denoising\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (DFBox(fragCoord-vec2(1.),RES-2.)<0.) {\n        vec4 RefShad = texture(iChannel0,fragCoord*IRES);\n        if (RefShad.x<=FAR) {\n            //\n            //Normal\n            //\n            vec2 SSOffset = SSOffsets[iFrame%16];\n            float CurrentFrame = float(iFrame);\n            vec2 UV = fragCoord+SSOffset;\n            vec3 SunDir = texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n            vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n            mat3 EyeMat = TBN(Eye);\n            vec3 LPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n            vec3 LEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n            vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n            mat3 LEyeMat = TBN(LEye);\n            vec3 Dir = normalize(vec3((UV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n            vec3 PPos = Pos+Dir*RefShad.x;\n            vec4 PSDF; vec3 Normal = Gradient(PPos,iTime,PSDF);\n            Output.w = Vec3ToFloat(Normal*0.5+0.5);\n            \n            \n            \n            \n            //\n            //Reservoir position\n            //\n            vec3 CVPos = PPos-LPos;\n            vec3 LVPos = vec3(dot(CVPos,LTan),dot(CVPos,LBit),dot(CVPos,LEye));\n            vec2 Luv = ((LVPos.xy/LVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            vec2 LuvCenter = floor(Luv);\n            float SmallestDistance = 1000.; float WSDist; vec2 ResUV;\n            for (float x = -1.; x<1.5; x++) {\n                for (float y = -1.; y<1.5; y++) {\n                    vec4 LRSample = texture(iChannel3,(LuvCenter+0.5+vec2(x,y))*IRES);\n                    vec2 LRluv = LuvCenter+vec2(x,y)+FloatToVec2(LRSample.y);\n                    vec3 LRDir = normalize(vec3((LRluv*IRES*2.-1.)*CFOV*ASPECT,1.)*LEyeMat);\n                    vec3 LRPPos = LPos+LRDir*LRSample.x;\n                    vec4 LRSDF; vec3 LRNormal = Gradient(LRPPos,iTime,LRSDF);\n                    //Reprojection on current screen space\n                    vec3 RVPos = LRPPos-Pos;\n                    RVPos = vec3(dot(RVPos,Tan),dot(RVPos,Bit),dot(RVPos,Eye));\n                    vec2 LRUV = ((RVPos.xy/RVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                    float LRUVDist = length(UV*0.+fragCoord-LRUV);\n                    if (LRSample.x<FAR && DFBox(LRUV-1.,RES-2.)<0. && abs(dot(Normal,LRPPos-PPos))<0.05\n                        && dot(Normal,LRNormal)>0.9 && LRUVDist<SmallestDistance) {\n                        SmallestDistance = LRUVDist;\n                        WSDist = length(LRPPos-Pos);\n                        ResUV = LRUV;\n                    }\n                }\n            }\n            vec2 UVResidual = ResUV-floor(fragCoord);\n            if (DFBox(UVResidual,vec2(1.))<=0.) {\n                //Inside current pixel -> keep position\n                Output.xy = vec2(WSDist,Vec2ToFloat(UVResidual));\n            } else {\n                //Outside current pixel -> new positions\n                Output.xy = vec2(RefShad.x,Vec2ToFloat(SSOffset+0.5));\n            }\n            \n            \n            \n\n            //\n            //Shadow denoising pass 1\n            //\n            if (RefShad.w>-0.5) {\n                //Surface is pointing towards SunDir\n                vec3 CVPos0 = vec3(RefShad.w*SunCR,0.,RefShad.x+RefShad.w)*TBN(Dir);\n                vec3 CVPos1 = vec3(-RefShad.w*SunCR,0.,RefShad.x+RefShad.w)*TBN(Dir);\n                vec3 LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n                vec3 LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n                vec2 Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                vec2 Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                float MaxRadius = min(32.,length(Luv0-Luv1)*0.5); vec4 ssdf;\n                vec2 CShadow = vec2(float(RefShad.w>FAR)*2.,2.);\n                for (float x=-2.; x<2.5; x+=1.) {\n                    for (float y=-2.; y<2.5; y+=1.) {\n                        if (x==0. && y==0.) continue;\n                        vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*(MaxRadius*0.5);\n                        vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                        vec4 SRefShad = texture(iChannel0,SUV*IRES);\n                        float SDistance = SRefShad.x;\n                        vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                        if (DFBox(SUV-1.,RES-2.)>0. || SDistance>FAR || SRefShad.w<-0.5 ||\n                            abs(dot(Pos+SDir*SDistance-PPos,Normal))>0.05 ||\n                            dot(Gradient(Pos+SDir*SDistance,iTime,ssdf),Normal)<0.9) continue;\n                        vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                        vec3 HitP = Pos+SDir*SDistance+normalize(RandSampleCos(SRand.xy)*TBN(SunDir)*SunCR+SunDir)*SRefShad.w;\n                        if (dot(HitP-PPos,Normal)<=0.) continue;\n                        if (sqrt(1./dot(normalize(HitP-PPos),SunDir)-1.)<=SunCR) {\n                            CShadow += vec2(float(SRefShad.w>FAR),1.);\n                        }\n                    }\n                }\n                Output.z = CShadow.x/CShadow.y;\n            } else Output.z = -1.;\n        } else Output = vec4(FAR+10.,-1.,-1.,-1.);\n    }\n    //Output\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Temporal ReSTIR\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    //Diffuse temporal ReSTIR\n    if (DFBox(fragCoord-vec2(1.),RES-2.)<0.) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec2 UV = fragCoord+SSOffset;\n        vec3 SunDir = texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n        vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 LPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n        vec3 LEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n        vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n        mat3 LEyeMat = TBN(LEye);\n        vec3 Dir = normalize(vec3((UV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        vec4 DiffShad = texture(iChannel0,UV*IRES);\n        if (DiffShad.x<=FAR) {\n            //Geometry pixel\n            vec3 PPos = Pos+Dir*DiffShad.x;\n            vec4 CSDF; vec3 Normal = Gradient(PPos,iTime,CSDF);\n            vec3 L = vec3(0.);\n            //Reprojection\n            vec3 CVPos = PPos-LPos;\n            vec3 LVPos = vec3(dot(CVPos,LTan),dot(CVPos,LBit),dot(CVPos,LEye));\n            vec2 Luv = ((LVPos.xy/LVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            vec2 LuvCenter = floor(Luv);\n            //Find reprojection pixel\n            float SmallestDistance = 1000.; vec2 LResUV,ResUV;\n            for (float x = -1.; x<1.5; x++) {\n                for (float y = -1.; y<1.5; y++) {\n                    vec4 LRSample = texture(iChannel3,(LuvCenter+0.5+vec2(x,y))*IRES);\n                    vec2 LRluv = LuvCenter+vec2(x,y)+FloatToVec2(LRSample.y);\n                    vec3 LRDir = normalize(vec3((LRluv*IRES*2.-1.)*CFOV*ASPECT,1.)*LEyeMat);\n                    vec3 LRPPos = LPos+LRDir*LRSample.x;\n                    vec4 LRSDF; vec3 LRNormal = Gradient(LRPPos,iTime-iTimeDelta,LRSDF);\n                    //Reprojection on current screen space\n                    vec3 RVPos = LRPPos-Pos;\n                    RVPos = vec3(dot(RVPos,Tan),dot(RVPos,Bit),dot(RVPos,Eye));\n                    vec2 LRUV = ((RVPos.xy/RVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                    float LRUVDist = length(UV*0.+fragCoord-LRUV);\n                    if (LRSample.x<FAR && DFBox(LRUV-1.,RES-2.)<0. && abs(dot(Normal,LRPPos-PPos))<0.05\n                        && dot(Normal,LRNormal)>0.9 && LRUVDist<SmallestDistance) {\n                        SmallestDistance = LRUVDist;\n                        ResUV = LRUV;\n                        LResUV = LRluv;\n                    }\n                }\n            }\n            vec2 UVResidual = ResUV-floor(fragCoord);\n            if (SmallestDistance>900.) {// || DFBox(UVResidual,vec2(1.))>0.) {\n                //No valid reprojection on the last frame -> new pixel\n                vec3 Rand3 = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n                Rand3.xy = (floor(Rand3.xy*2048.)+0.5)*I2048;\n                Output = vec4(DiffShad.y,Vec2ToFloat(Rand3.xy),DiffShad.z,Vec2ToFloatWM(vec2(1.)));\n            } else {\n                //Old pixel\n                vec4 LR = texture(iChannel2,LResUV*IRES);\n                vec2 LRWM = FloatToVec2WM(LR.w);\n                float M = LRWM.y;\n                vec2 Rand2 = FloatToVec2(LR.y);\n                vec3 RLight = FloatToVec3(LR.x)*LightCoeff;\n                float RDist = LR.z;\n                float w = max(0.,dot(RLight,vec3(0.3333)))*M*LRWM.x;\n                float W = w/max(0.0001,M*dot(RLight,vec3(0.3333))); //Update W\n                if (iFrame%3==0) {\n                    //Sample validation\n                    L = FloatToVec3(DiffShad.y)*LightCoeff;\n                    if (length(RLight-L)>0.1) {\n                        //Invalid sample\n                        Output = vec4(Vec3ToFloat(L*ILightCoeff),LR.y,DiffShad.z,LR.w);\n                    } else {\n                        //Valid sample\n                        Output = LR;\n                    }\n                } else {\n                    //Temporal ReSTIR\n                    vec3 Rand3 = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n                    Rand3.xy = (floor(Rand3.xy*2048.)+0.5)*I2048;\n                    vec3 SRD = RandSample(Rand3.xy)*TBN(Normal);\n                    float SampleD = DiffShad.z;\n                    L = FloatToVec3(DiffShad.y)*LightCoeff;\n                    float wnew = max(0.,dot(L,vec3(0.3333)))*dot(SRD,Normal); //Target pdf\n                    M = min(M,M_CLAMP_T-1.); //Clamping\n                    w = max(0.,dot(RLight,vec3(0.3333)))*RandSample(Rand2.xy).z*M*W+wnew; //R.w += w\n                    if (Rand3.z<wnew/max(0.0001,w)) {\n                        //New sample\n                        RLight = L;\n                        Rand2 = Rand3.xy;\n                        RDist = SampleD;\n                    }\n                    M += 1.; //R.M += 1\n                    float p_hat = max(0.,dot(RLight,vec3(0.3333)))*RandSample(Rand2.xy).z; //p hat\n                    W = w/max(0.0001,M*p_hat); //Update W\n                    //Output\n                    Output = vec4(Vec3ToFloat(RLight*ILightCoeff),\n                                  Vec2ToFloat(Rand2),\n                                  RDist,\n                                  Vec2ToFloatWM(vec2(W,M)));\n                }\n            }\n        } else {\n            //Sky pixel\n            Output = vec4(0.,0.,0.,-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Spatial ReSTIR + Shadow denoising + Copy reservoir positions\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (DFBox(fragCoord-vec2(1.),RES-2.)<0.) {\n        //\n        //Copy positions\n        //\n        Output.xy = texture(iChannel1,fragCoord*IRES).xy;\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec2 UV = fragCoord+SSOffset;\n        vec3 SunDir = texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n        vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 LPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n        vec3 LEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n        vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n        mat3 LEyeMat = TBN(LEye);\n        vec3 Dir = normalize(vec3((UV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        vec4 DiffShad = texture(iChannel0,UV*IRES);\n        if (DiffShad.x<=FAR) {\n            //\n            //ReSTIR spatial\n            //\n            vec3 PPos = Pos+Dir*DiffShad.x;\n            vec4 CSDF; vec3 Normal = Gradient(PPos,iTime,CSDF);\n            vec4 CR = texture(iChannel2,fragCoord*IRES);\n            vec2 CRWM = FloatToVec2WM(CR.w);\n            float W = CRWM.x;\n            float M = CRWM.y;\n            vec3 CRLight = FloatToVec3(CR.x)*LightCoeff;\n            float CRRandFloat = CR.y;\n            float w = max(0.,dot(CRLight,vec3(0.3333)))*M*W*RandSample(FloatToVec2(CRRandFloat)).z;\n            vec3 Rand3 = ARand23(fragCoord*(1.+mod(iTime*18.327,13.9347)));\n            int NSamples = 9;\n            float SpatialRadius = 1.+Rand3.x //*(RES.x*0.1)\n                                  *clamp((2./DiffShad.x)*RES.x*0.1,1.,RES.x*0.1);\n            float AngleDelta = 6.28318530718/float(NSamples);\n            float CAngle = Rand3.y*AngleDelta;\n            float Jacobian,wnew,np_hat; vec2 SUV; vec3 SDir,SPos,SNormal,SRayHit,HitNormal; vec4 SDiffShad,SR,SSDF;\n            for (int s=0; s<NSamples; s++) {\n                //For all spatial reservoirs\n                CAngle += AngleDelta;\n                SUV = floor(fragCoord+vec2(sin(CAngle),cos(CAngle))*SpatialRadius)+0.5;\n                if (DFBox(SUV-1.,RES-2.)>=0.) continue;\n                SDiffShad = texture(iChannel0,SUV*IRES);\n                if (SDiffShad.x>FAR) continue; //Sky pixel test\n                SDir = normalize(vec3(((SUV-0.5+FloatToVec2(texture(iChannel1,SUV*IRES).y))*IRES*2.-1.)*CFOV*ASPECT,1.)*TBN(Eye));;\n                SPos = Pos+SDir*SDiffShad.x;\n                SNormal = Gradient(SPos,iTime,SSDF);\n                if (!(dot(SNormal,Normal)>0.9 && abs(dot(SPos-PPos,Normal))<0.05)) continue; //Geometric similarity test\n                SR = texture(iChannel2,SUV*IRES);\n                vec3 SRandDir = (RandSample(FloatToVec2(SR.y))*TBN(SNormal));\n                SRayHit = SPos+SR.z*SRandDir;\n                HitNormal = Gradient(SRayHit,iTime,SSDF);\n                if ((SR.z<FAR && dot(PPos-SRayHit,HitNormal)<=0.) || dot(SRayHit-PPos,Normal)<=0.) continue; //Hemisphere test\n                \n                //Exact visibility\n                    //if (abs(Trace(PPos+Normal*0.001,normalize(SRayHit-PPos),iTime)-length(SRayHit-PPos))>0.05) continue;\n                //Screen space ray tracing to approximate visibility\n                    bool Visible = true;\n                    float SSNSamples = 10.;\n                    vec3 SSRayDir = normalize(SRayHit-PPos);\n                    for (float di=ARand21(SUV)*0.8+0.1; di<SSNSamples; di++) {\n                        //For each sample\n                        vec3 SSP = PPos+SSRayDir*(di*0.1);\n                        vec3 SSVPos = SSP-Pos;\n                        SSVPos = vec3(dot(SSVPos,Tan),dot(SSVPos,Bit),dot(SSVPos,Eye));\n                        vec2 SSUV = ((SSVPos.xy/SSVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                        if (DFBox(SSUV-1.,RES-2.)>0.) break;\n                        float SSDepth = texture(iChannel0,SSUV*IRES).x;\n                        if (SSDepth+0.02<length(SSVPos)) { Visible = false; break; }\n                    }\n                    if (!Visible) continue;\n                \n                //Read reservoir\n                vec2 SWM = FloatToVec2WM(SR.w);\n                vec3 SRLight = FloatToVec3(SR.x)*LightCoeff;\n                //Jacobian\n                Jacobian = abs(dot(PPos-SRayHit,HitNormal)*pow(SR.z,3.))/\n                           max(0.0001,abs(dot(SPos-SRayHit,HitNormal)*pow(length(PPos-SRayHit),3.)));\n                if (SR.z>FAR) Jacobian = 1.; //Sky sample\n                np_hat = max(0.,dot(SRLight,vec3(0.3333)));\n                wnew = np_hat*SWM.y*SWM.x*RandSample(FloatToVec2(SR.y)).z*max(0.0001,Jacobian);\n                w += wnew;\n                M += SWM.y;\n                float RandV = ARand21(SUV+mod(float(iFrame+s),2048.)*vec2(3.683,4.887));\n                if (RandV<wnew/max(0.0001,w)) {\n                    CRLight = SRLight;\n                    CRRandFloat = SR.y;\n                }\n            }\n            //Bias correction\n            float bias_p_hat = max(0.,dot(CRLight,vec3(0.3333)))*RandSample(FloatToVec2(CRRandFloat)).z;\n            W = w/max(0.0001,M*bias_p_hat);\n            vec3 IndirectDiffuse = CRLight*W*RandSample(FloatToVec2(CRRandFloat)).z;\n\n\n\n\n            //\n            //Shadow denoising pass 2\n            //\n            vec4 RefShad = texture(iChannel0,fragCoord*IRES);\n            vec2 CShadow = vec2(0.);\n            if (RefShad.w>-0.5) {\n                //Surface is pointing towards SunDir\n                vec3 CVPos0 = vec3(RefShad.w*SunCR,0.,RefShad.x+RefShad.w)*TBN(Dir);\n                vec3 CVPos1 = vec3(-RefShad.w*SunCR,0.,RefShad.x+RefShad.w)*TBN(Dir);\n                vec3 LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n                vec3 LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n                vec2 Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                vec2 Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                float MaxRadius = min(8.,length(Luv0-Luv1)*0.5); vec4 ssdf;\n                CShadow = vec2(texture(iChannel1,fragCoord*IRES).z*2.,2.);\n                for (float x=-2.; x<2.5; x+=1.) {\n                    for (float y=-2.; y<2.5; y+=1.) {\n                        if (x==0. && y==0.) continue;\n                        vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*(MaxRadius*0.5);\n                        vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                        vec4 SRefShad = texture(iChannel0,SUV*IRES);\n                        float SDistance = SRefShad.x;\n                        vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                        if (DFBox(SUV-1.,RES-2.)>0. || SDistance>FAR || SRefShad.w<-0.5 ||\n                            abs(dot(Pos+SDir*SDistance-PPos,Normal))>0.05 ||\n                            dot(Gradient(Pos+SDir*SDistance,iTime,ssdf),Normal)<0.9) continue;\n                        vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                        vec3 HitP = Pos+SDir*SDistance+normalize(RandSampleCos(SRand.xy)*TBN(SunDir)*SunCR+SunDir)*SRefShad.w;\n                        if (dot(HitP-PPos,Normal)<=0.) continue;\n                        if (sqrt(1./dot(normalize(HitP-PPos),SunDir)-1.)<=SunCR) {\n                            CShadow += vec2(texture(iChannel1,SUV*IRES).z,1.);\n                        }\n                    }\n                }\n                CShadow.x = CShadow.x/CShadow.y;\n            }\n\n\n\n\n            //\n            //Composition\n            //\n            vec3 FinalColor = IndirectDiffuse+CShadow.x*SunLight*max(0.,dot(Normal,SunDir));\n            FinalColor *= CSDF.xyz;\n            Output.zw = vec2(Vec2ToFloat(FinalColor.xy*0.2),FinalColor.z);\n        } else {\n            //Sky\n            vec3 FinalColor = SampleSky(Dir,iTime);\n            Output.zw = vec2(Vec2ToFloat(FinalColor.xy*0.2),FinalColor.z);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//TAA\n    //Catmull-rom by hornet: https://www.shadertoy.com/view/MtVGWz\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 sampleLevel0(vec2 PriorUV) {\n    float YOffset = floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*3072.;\n    return textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n}\n\nvec4 SampleTextureCatmullRom(vec2 uv) {\n    vec2 samplePos = uv;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n    vec2 f = samplePos - texPos1;\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n    vec4 result = vec4(0.);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n    return max(vec4(0.,0.,0.,1.),result);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = vec4(0.,0.,0.,0.);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z<0.) UV.y += 1024.;\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.y>0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    vec2 RESOffset = vec2((mod(floor(UV.y*I1024)+0.5,3.)-0.5)*1024.,floor(UV.y*I1024*I3)*1024.);\n    vec2 CUV = mod(UV,1024.)+RESOffset;\n    if (DFBox(CUV-3.,RES-6.)<0.) {\n        //Inside the screen\n        vec2 BCRef = texture(iChannel2,CUV*IRES).zw;\n        vec3 FinalColor = vec3(FloatToVec2(BCRef.x)*5.,BCRef.y)*ExternalLightFactor;\n        //Reprojection\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 PriorPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n        vec3 PriorEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n        vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n        mat3 PriorEyeMat = TBN(PriorEye);\n        vec3 Dir = normalize(vec3(((CUV+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        float Distance = texture(iChannel0,CUV*IRES).x;\n        if (Distance<-0.5) Distance = 100000.; //Sky pixel\n        vec3 PPos = Pos+Dir*Distance;\n        vec4 CSDF; vec3 Normal = Gradient(PPos,iTime,CSDF);\n        vec3 PriorVPos = vec3(dot(PPos-PriorPos,PriorTan),dot(PPos-PriorPos,PriorBit),dot(PPos-PriorPos,PriorEye));\n        vec2 PriorUV = ((PriorVPos.xy/PriorVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n        if (DFBox(PriorUV-3.,RES-6.)<0.) {\n            //Valid reprojection\n            vec4 LFinalColor;\n            if (length(PriorUV-CUV-SSOffset)>0.02) {\n                //Catmull-rom sampling\n                PriorUV -= SSOffsets[(iFrame-1)%16];\n                LFinalColor = SampleTextureCatmullRom(PriorUV);\n            } else {\n                //Nearest neighbour sampling\n                PriorUV = floor(PriorUV)+0.5;\n                float YOffset = floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*3072.;\n                LFinalColor = textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n            }\n            //Clamping\n            vec3 FMIN = vec3(1000.);\n            vec3 FMAX = vec3(0.);\n            for (float x=-1.; x<1.5; x+=1.) {\n                for (float y=-1.; y<1.5; y+=1.) {\n                    BCRef = texture(iChannel2,(CUV+vec2(x,y))*IRES).zw;\n                    vec3 Sample = vec3(FloatToVec2(BCRef.x)*5.,BCRef.y)*ExternalLightFactor;\n                    FMIN = min(FMIN,Sample);\n                    FMAX = max(FMAX,Sample);\n                }\n            }\n            LFinalColor.xyz = clamp(LFinalColor.xyz,FMIN,FMAX);\n            //Output\n            Output = vec4((FinalColor+LFinalColor.xyz*LFinalColor.w)/(LFinalColor.w+1.),min(31.,LFinalColor.w+1.));\n            //Output.xyz = FinalColor;\n        } else {\n            //Invalid reprojection\n            Output = vec4(FinalColor,1.);\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}