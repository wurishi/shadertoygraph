{"ver":"0.1","info":{"id":"clVfzm","date":"1701946593","viewed":66,"name":"PK Fire","username":"midorikuma","description":"from EarthBound PSI","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","effect","earthbound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define linearstep(edge0, edge1, x) min(max(((x) - (edge0)) / ((edge1) - (edge0)), 0.0), 1.0)\n\n// Function for linear interpolation\nfloat linearInterpolation(float edge0, float edge1, float x) {\n    return min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0);\n}\n\n// Function to determine rhombus shape presence\nbool isRhombusShape(in float length, in float tOffset){\n    const float width = 0.01;\n    tOffset = 1.0 - width - tOffset;\n    return tOffset - width < length && length < tOffset + width;\n}\n\n// Wave pattern function\nfloat wavePattern(in vec2 normalizedCoord, in float t){\n    float tMod = mod(t, 1.0 / 3.0) * 3.0;\n    float polarity = sign(normalizedCoord.y);\n    float size = tMod * 10.0 / (t + 0.25);\n    return polarity * (1.0 - clamp(abs(normalizedCoord.x - polarity * tMod / 2.0) * 200.0 / size, 0.0, 1.0)) * size;\n}\n\nbool effect(in vec2 fragCoord, in float t){\n    vec2 normalizedCoord = (fragCoord - iResolution.xy / 2.0) / max(iResolution.x, iResolution.y);\n    normalizedCoord.x /= 2.0;\n    vec2 absCoord = abs(normalizedCoord);\n    float lengthSum = absCoord.x + absCoord.y;\n\n    // Calculate wave patterns\n    float t1 = smoothstep(0.0, 1.8, t) * 1.2;\n    bool rhombusPresent = isRhombusShape(lengthSum, t1) || isRhombusShape(lengthSum, t1 - 0.1) || isRhombusShape(lengthSum, t1 - 0.2);\n\n    // Generate wave patterns\n    float t2 = smoothstep(1.9, 2.5, t);\n    float t3 = smoothstep(2.2, 3.0, t);\n    float t4 = linearstep(1.9, 3.5, t);\n    float t5 = linearstep(1.9, 3.5, t - 0.25);\n    float wave1 = wavePattern(normalizedCoord, t4);\n    float wave2 = wavePattern(vec2(-normalizedCoord.x, normalizedCoord.y), t5);\n    vec2 sinPattern1 = abs(normalizedCoord - vec2(0.0, 0.01) * wave1 - vec2(0.0, 0.01) * wave2);\n    bool wavePresent1 = t < 3.5 && 0.015 * t3 <= sinPattern1.y && sinPattern1.y < 0.015 * t3 + 0.01 && absCoord.x < t2;\n\n    // Additional wave processing\n    float t6 = smoothstep(5.0, 4.0, t);\n    float t7 = linearstep(4.0, 3.5, t);\n    float t8 = smoothstep(3.6, 4.9, t) * 1.5;\n    float t9 = smoothstep(4.2, 5.0, t);\n    t8 = 1.0 - abs((t8 - absCoord.x) * 2.0 - 1.0);\n    vec2 waveSize = vec2(0.06, 0.1);\n    float wave3 = clamp((0.5 * t8) - abs(mod(absCoord.x, waveSize.x) / waveSize.x - 0.5), 0.0, 1.0) * 20.0 * sign(normalizedCoord.y);\n    vec2 sinPattern2 = abs(normalizedCoord - vec2(0.0, 0.01) * wave3);\n    bool wavePresent2 = 3.5 <= t && 0.015 * t7 <= sinPattern2.y && sinPattern2.y < 0.015 * t7 + 0.01 * t6 && t9 / 3.0 <= absCoord.x;\n    return rhombusPresent || wavePresent1 || wavePresent2;\n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool layer1 = effect(fragCoord,mod(iTime, 6.0));\n    bool layer2 = effect(fragCoord,mod(iTime-0.35, 6.0));\n\n    // Set color\n    vec3 backcolor = vec3(0.0, 0.0, 0.0); \n    vec3 color = vec3(1.0, 0.3, 0.0);\n    fragColor = layer1 ? vec4(color, 1.0) : (layer2 ? vec4(color,0.5) : vec4(backcolor,0.0));\n    fragColor = vec4(mix(backcolor, fragColor.rgb, fragColor.a),1.0);\n}\n","name":"Image","description":"","type":"image"}]}