{"ver":"0.1","info":{"id":"wslSDj","date":"1552250459","viewed":65,"name":"CompGraph1","username":"ankan2013","description":".","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["compgraph01"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 ambColor1 = vec3(0.1,0.3,0.7);\nconst vec3 ambColor2 = vec3(0.2,0.5,0.5);\nconst vec3 ambColor3 = vec3(0.3,0.7,0.3);\n\nconst vec3 light1Pos = vec3(2.0, 6.0, 0.0);\nconst vec3 light1Par = 0.7 * vec3(1.0, 1.0, 1.0);\n\nconst vec3 light2Pos = vec3(8.0, -8.0, 8.0);\nconst vec3 light2Par = 0.8 * vec3(0.5, 0.5, 0.0);\n\nconst vec3 colorDiff = vec3(0.7, 0.2, 0.2);\nconst vec3 ambLight = 0.5 * vec3(1.0, 1.0, 1.0);\n\nconst vec3 eye = vec3(0.0, 0.0, 5.0);\n\nconst vec3 backColor = vec3(0.0,0.1,0.1);\n\nvec3 ambColor;\n\nfloat torusSDF(vec3 p)\n{\n  vec2 q = vec2(length(p.xz)-0.5,p.y-0.80);\n  if (length(q)-0.05 <= EPSILON) ambColor = ambColor1;\n  return length(q)-0.05;\n}\n\nfloat brickSDF(vec3 p) {\n    vec3 d = abs(vec3(p.x,p.y+0.8,p.z)) - vec3(0.5, 0.05, 0.5);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0)); \n    if (insideDistance + outsideDistance <= EPSILON) ambColor = ambColor2;\n    return insideDistance + outsideDistance;\n}\n\nfloat sphere1SDF(vec3 p) {\n    if (length(vec3(p.x, p.y-0.4, p.z)) - 0.2 <= EPSILON) ambColor = ambColor3;\n    return length(vec3(p.x, p.y-0.4, p.z)) - 0.2;\n}\nfloat sphere2SDF(vec3 p) {\n    if (length(vec3(p.x-0.25, p.y, p.z)) - 0.2 <= EPSILON) ambColor = ambColor3;\n    return length(vec3(p.x-0.25, p.y, p.z)) - 0.2;\n}\nfloat sphere3SDF(vec3 p) {\n    if (length(vec3(p.x, p.y+0.4, p.z)) - 0.2 <= EPSILON) ambColor = ambColor3;\n    return length(vec3(p.x, p.y+0.4, p.z)) - 0.2;\n}\nfloat unionSDF(float distA, float distB, float distC, float distD, float distE) {\n    if (min(min(distA, distB), min(min(distC, distD), distE)) > EPSILON) ambColor = vec3(0.0,0.0,0.0);\n    return min(min(distA, distB), min(min(distC, distD), distE));\n}\n\nfloat sceneSDF(vec3 p) {\n\tfloat s1Dist = sphere1SDF(p);\n    float s2Dist = sphere2SDF(p);\n    float s3Dist = sphere3SDF(p);\n    float bDist = brickSDF(p);\n    float tDist = torusSDF(p);\n    return unionSDF(s1Dist,s2Dist,s3Dist,bDist,tDist);\n}\n\nfloat minDist(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 light(vec3 col_dif, vec3 p, vec3 eye, vec3 lightPos, vec3 lightPar) {\n    vec3 normDir = estimateNormal(p);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 eyeDir = normalize(eye - p);\n    vec3 refDir = normalize(reflect(-lightDir, normDir));\n    float lightVal = dot(lightDir, normDir);\n    float refVal = dot(refDir, eyeDir);\n    if (refVal < 0.0) {\n        return lightPar * (colorDiff * lightVal);\n    }\n    if (lightVal < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    return lightPar * (colorDiff * lightVal + vec3(1.0, 1.0, 1.0) * pow(refVal, 10.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 dir = rayDir(45.0, iResolution.xy, fragCoord);\n    float dist = minDist(eye, dir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(backColor, 0.0);\n\t\treturn;\n    }\n    vec3 p = eye + dist * dir;\n    vec3 color = ambLight * ambColor;\n    color += light(colorDiff, p, eye, light1Pos, light1Par);\n    color += light(colorDiff, p, eye, light2Pos, light2Par); \n    fragColor = vec4(color, 0.0);\n}","name":"Image","description":"","type":"image"}]}