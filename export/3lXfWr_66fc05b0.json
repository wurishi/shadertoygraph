{"ver":"0.1","info":{"id":"3lXfWr","date":"1596429442","viewed":72,"name":"Rule of Normal Neighbors pattern","username":"micahbro","description":"Spontaneous formation of a self-healing, scale-invariant pattern via the Rule of Normal Neighbors.\nUse mouse to erase parts of the pattern. Controls (left to right): Reset, toggle energy display, eraser size, \"temperature\" parameter, toggle button bar.\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["spontaneouspattern","selfhealing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    configureAndUpdate(iResolution, CTRL_CHANNEL, iMouse, iFrame < 10);    \n\n    vec3 sceneColor;\n    float maxp;\n    int c = maxState(maxp, fragCoord, iResolution, iChannel0, iChannel2);\n    sceneColor = qbcolor(c) * 1.4 * maxp;            \n       \n    // Output to screen\n    fragColor = vec4(sceneColor, 1.0);\n    \n   \n    // hack to show error signal\n    vec4 dummy;\n\tfloat ehat = 1.2 + calcUpdate(dummy, dummy, fragCoord, iFrame, iResolution, iChannel0, iChannel1, iChannel2, iChannel3, true);\n    if (controls[errorToggleCtl].value > 0.)  fragColor = vec4(-ehat, ehat * 2., -ehat / 5., 1.0);\n    \n    \n    if (fragCoord.y / iResolution.y < .25 && fragCoord.x / iResolution.x > 0.6) {\n        vec4 controlColor = texture(CTRL_CHANNEL, fragCoord / vec2(iResolution));\n    \tfragColor = (1. - controlColor[3]) * fragColor + controlColor[3] * controlColor;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ERASER_DIAM_DEFAULT 30.\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n// sh*ttyguikit 0.1.1\n\n#define TOGGLE_BTN_T 1\n#define PUSH_BTN_T 2\n#define SPINNER_T 3\n#define CLICKBOX_T 4\n\n#define MAX_CTRLS 9\n#define CTRL_CHANNEL iChannel1\n#define GRN_MID 0.3\n\nstruct control {\n    int type;\n    vec4 bboxUV;\n    float value; \n    float value2; \n    bool mouseDown;\n    bool visible;\n    bool enabled;\n    float opacity;\n};\n    \n    \ncontrol[MAX_CTRLS] controls;\nint controlCount = 0;\n\nvec3 giResolution;\n\n\nvec2 uvToXY(vec2 uv) {\n    return uv * giResolution.y + giResolution.xy*.5;\n}\n\nvec2 xyToUV(vec2 xy) {\n    return (xy - giResolution.xy*.5) / giResolution.y;\n}\n\nint newControl(int type, vec4 bbox) {\n    controls[controlCount].type = type;\n    controls[controlCount].bboxUV = bbox;\n    controls[controlCount].mouseDown = false;\n    controls[controlCount].visible = true;\n    controls[controlCount].enabled = true;\n    controls[controlCount].opacity = 1.0;\n    return controlCount++;\n}\n\n\nvec4 getControl(int index, sampler2D sampler) {\n    vec4 bbox = controls[index].bboxUV;\n    vec2 midpoint = vec2(bbox[0] + bbox[2], bbox[1] + bbox[3]) * 0.5;\n    ivec2 ixy = ivec2(uvToXY(midpoint));\n    return texelFetch(sampler, ixy, 0);\n}\n\nvoid updateValue2(int index) {\n    int type = controls[index].type;\n    if (type != CLICKBOX_T) {\n    \tcontrols[index].value2 = 1. - controls[index].value;\n    }\n}\n\nvoid updateControls(sampler2D sampler) {\n    for (int i = 0 ; i < controlCount; i++) {\n        vec4 readout = getControl(i, sampler);\n        controls[i].value = readout[2];\n        controls[i].value2 = readout[0];\n        controls[i].mouseDown = readout[1] > GRN_MID;\n        float alphanorm = 1.;\n        if (controls[i].opacity > 0.) {\n            alphanorm = (readout[3] / controls[i].opacity);\n        }\n        controls[i].visible = alphanorm > 0.;\n        controls[i].enabled = alphanorm > .5;        \n        updateValue2(i);\n    }    \n}\n\nfloat getShapeNorm(int type) {\n    if (type == TOGGLE_BTN_T) {\n    \treturn 3.5;\n    } else if (type == PUSH_BTN_T) {\n    \treturn  1.5;\n    } else if (type == CLICKBOX_T) {\n    \treturn  100.;\n    } else {\n    \treturn 2.0;\n    }\n}\n\n// -1 to 1\nvec2 hitCoordsNormalized(int index, vec2 xy) {\n    vec4 bbox = controls[index].bboxUV;\n    vec2 midpoint = vec2(bbox[0] + bbox[2], bbox[1] + bbox[3]) * 0.5;\n    vec2 span = abs(vec2(bbox[0] - bbox[2], bbox[1] - bbox[3]));\n    vec2 uv = xyToUV(xy);\n \n    return (uv - midpoint) / (0.5 * span);\n}\n    \nfloat midpointDistNorm(int index, int type, vec2 xy) {\n    vec2 dr = hitCoordsNormalized(index, xy);\n    //return sqrt(dot(dr, dr));\n    float normpow = getShapeNorm(type);\n    float sumnorm = pow(abs(dr[0]), normpow) + pow(abs(dr[1]), normpow);\n    return pow(sumnorm, 1.0 / normpow);\n}\n\nfloat midpointAngle(int index, vec2 xy) {\n    vec2 dr = hitCoordsNormalized(index, xy);\n    \n    return acos(dr[0] / sqrt(dot(dr, dr))) * sign(dr[1]);\n}\n\nvec2 clickboxCoordsNorm(float value) {\n    return 2. * vec2(fract(value) - 0.5, floor(value) / 500. - 0.5);\n}\n\nfloat normCoordsToClickboxVal(vec2 dr) {\n    return clamp(dr[0] * 0.5 + 0.5, 0., 1.) + round(500. * clamp(dr[1] * 0.5 + 0.5, 0., 1.));\n}\n\nvoid mouseDownEvt(int index, vec4 mouse, int capturedIndex) {\n    //  mouseDown event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = 1.;\n        break;\n\n        case TOGGLE_BTN_T:\n        controls[index].value = 1. - controls[index].value;\n        break;\n\n        case CLICKBOX_T:\n\t    vec2 dr = hitCoordsNormalized(index, mouse.xy) / 2.;\n        controls[index].value = normCoordsToClickboxVal(dr);\n        controls[index].value2 = controls[index].value;\n        break;        \n    }\n}\n\nvoid mouseMoveEvt(int index, vec4 mouse, int capturedIndex, bool inBounds) {\n    // mouseMove event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = inBounds ? 1. : 0.;\n        break;\n\n        case SPINNER_T:\n        controls[index].value = midpointAngle(index, mouse.xy) / 3.14159;\n        break;\n\n        case CLICKBOX_T:\n\t    vec2 dr = hitCoordsNormalized(index, mouse.xy) / 2.;\n        controls[index].value2 = normCoordsToClickboxVal(dr);\n        break;        \n    }\n}\n\nvoid mouseUpEvt(int index, vec4 mouse, int capturedIndex) {\n    // mouseUp event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = 0.;\n        break;\n    }\n}\n\nint typeCheatSheet(int index);\n\nbool handleMouse(int index, vec4 mouse, int capturedIndex) {\n    float dist = midpointDistNorm(index, typeCheatSheet(index), mouse.xy);\n    bool capturable = capturedIndex == index || capturedIndex < 0;\n    if (mouse[2] > 0. && dist < 1. && controls[index].visible) {\n        if (controls[index].enabled && capturable) {\n            if (!controls[index].mouseDown) {\n                controls[index].mouseDown = true;\n\n                mouseDownEvt(index, mouse, capturedIndex);\n            } else {\n            \tmouseMoveEvt(index, mouse, capturedIndex, true);\n        \t}\n        }\n        return true;\n    } else {\n        if (controls[index].mouseDown) {\n            if (mouse[2] <= 0.) {\n                mouseUpEvt(index, mouse, capturedIndex);\n            } else {            \n                mouseMoveEvt(index, mouse, capturedIndex, false);\n            }\n        }        \n        \n        if (capturedIndex != index) {\n            controls[index].mouseDown = false;        \n        }\n        return false;\n    }            \n}\n\nvec4 processMouse(vec4 mouse) {\n    int capturedIndex = -1;\n    if (mouse[2] > 0.) {\n        for (int i = 0 ; i < controlCount; i++) {\n            if (controls[i].mouseDown) {\n                capturedIndex = i;\n            }\n        }\n    }\n    \n    bool handled = false;\n    for (int i = controlCount - 1 ; i >= 0; i--) {\n        handled = handleMouse(i, mouse, capturedIndex);\n        if (handled) {\n            break;\n        }\n    }\n    if (handled || capturedIndex >= 0) {\n        return vec4(mouse.xy, 0., 0.);\n    } else {        \n    \treturn mouse;\n    }\n}\n\nvec4 renderControls(vec2 fragCoord, vec4 mouse) {\n    vec4 pixel = vec4(0.);\n    for (int i = 0 ; i < controlCount; i++) {\n        float dist = midpointDistNorm(i, controls[i].type, fragCoord);\n        float mouseThickAdj = controls[i].mouseDown ? 0.07 : 0.;\n        \n        float alpha = 0.;\n        if (controls[i].visible) {\n            alpha = (controls[i].enabled? 1. : 0.5) * controls[i].opacity;\n        }\n        \n        // special casing handling invisible controls partly overlapping visible ones\n        if (alpha > 0. || pixel[3] <= 0.) {\n            if (dist <= 0.9 - mouseThickAdj) {\n                float mouseColor = GRN_MID + (controls[i].mouseDown ? 0.02 : -0.02);\n                pixel = vec4(controls[i].value2, mouseColor, controls[i].value, alpha);\n\n                if (controls[i].type == SPINNER_T) {\n                    if (dist > 0.5 && \n                        abs(midpointAngle(i, fragCoord) / 3.14159 - controls[i].value) < .1) {\n                        pixel = vec4(0., 0., 0., alpha);\n                    }\n                }\n\n                if (dist > 0.8 - mouseThickAdj - .1) {\n                    float delta = dist - (0.9 - mouseThickAdj);\n                    float blend = exp(-delta * delta * 500.);\n                    pixel = (1. - blend) * pixel * pixel[3] + vec4(0., 0., 0., alpha);\n                    pixel[3] = alpha;\n                }\n                \n            } else if (dist <= 1.1) {                \n                float blend = exp(-(dist - 0.9) * (dist - 0.9) * 100.);\n                if (dist < 0.9) blend = 1.0;\n                pixel = (1. - blend) * pixel + vec4(0., 0., 0., blend * alpha);\n            }            \n        }\n    }    \n    \n    return pixel;    \n}\n\nint visControl;\nint dragclickCtl;\nint tempCtl;\nint eraserCtl;\nint errorToggleCtl;\nint resetCtl;\n\n\nvoid defineYourControls()\n{\n    vec2 corner = xyToUV(vec2(giResolution[0], 0.));\n\n    dragclickCtl = newControl(CLICKBOX_T, vec4(corner, -corner));\n    controls[dragclickCtl].opacity = 0.;\n    // clickbox is a little effed because its midpoint is outside the GUI slice of buffer B\n    \n    visControl = newControl(TOGGLE_BTN_T, vec4(corner, corner - vec2(0.05, -0.05)));\n    \n    float pos = corner.x - 0.046;\n    tempCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    eraserCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    errorToggleCtl = newControl(TOGGLE_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    resetCtl = newControl(PUSH_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n}\n\n// this function is sadness and kludge but remarkably faster than the obvious thing,\n// at least on my integrated graphics laptop -- perhaps because handleMouse is so serial?\nint typeCheatSheet(int index) {\n    // hard code results of controls[index].type, for fast access during mouse hit testing:\n    if (index == dragclickCtl) {\n        return CLICKBOX_T;\n    } else if (index == resetCtl) {\n        return PUSH_BTN_T;\n    } else if (index >= tempCtl && index <= eraserCtl) {\n        return SPINNER_T;\n    } else {\n        return TOGGLE_BTN_T;\n    }\n}\n\nvoid configure(vec3 res) {\n    giResolution = res;        \n    defineYourControls();\n}\n\nvec4 configureAndUpdate(vec3 res, sampler2D sampler, vec4 mouse, bool init) {\n    configure(res);\n    if (!init) {\n    \tupdateControls(sampler);\n    }\n    \n    return processMouse(mouse);\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n// RNN code\n\nvec3 qbcolor(int c) {\n\treturn vec3(float((c & 4) >> 2), float((c & 2) >> 1), float(c & 1)) / 2. + float((c & 8) >> 3) * vec3(0.5, 0.5, 0.5);    \n}\n\n\nint maxState(out float maxp, vec2 fragCoord, vec3 iResolution, sampler2D p1Channel, sampler2D p2Channel) {\n    maxp = 0.;\n    int maxs = -1;\n\n    vec4 p = texture(p1Channel, fragCoord / iResolution.xy);    \n    vec4 p2 = texture(p2Channel, fragCoord / iResolution.xy);    \n    for (int i = 0; i < 4; i++) {\n        if (p[i] > maxp) {\n            maxp = p[i];\n            maxs = i;\n        }\n        if (p2[i] > maxp) {\n            maxp = p2[i];\n            maxs = i + 4;\n        }        \n    }    \n    return maxs + 1;\n}\n\nfloat calcUpdate(out vec4 p1FragColor, out vec4 p2FragColor, in vec2 fragCoord, int iFrame, vec3 iResolution, sampler2D p1Channel, sampler2D qChannel, sampler2D p2Channel, sampler2D l2Channel, bool bPrimary) {\n    if (iFrame < 10 || controls[resetCtl].value > 0.) {\n        float theta = mod(exp(fragCoord.x / fragCoord.y) * fragCoord.y, 7.);\n        vec4 st = vec4(sin(theta), cos(theta), sin(theta) + cos(theta), cos(theta + .5) * .5);\n\t    p1FragColor = clamp(vec4(st / 2. + 0.5), 0.0001, 1.) / 1.e8;\n        return 0.;\n    } else {\n        int inc = (iFrame & 1) == 0 ? 8 : 9;\n        ivec2 iCoord = ivec2(trunc(fragCoord));\n\t    vec4 p = texelFetch(p1Channel, iCoord, 0);\n\t    vec4 p2 = texelFetch(p2Channel, iCoord, 0);\n        vec4 l2 = texelFetch(l2Channel, iCoord, 0);\n        \n        \n        int bc = 5;\n              \n        int range = 3;\n        vec4 pavg = vec4(0.);\n        vec4 p2avg = vec4(0.);\n        int nconstel = 0;\n        for (int ix = -range; ix <= range; ix++) {\n            for (int iy = -range; iy <= range; iy++) {\n                if (ix != iy) {\n                    ivec2 cpos = iCoord + ivec2(ix, iy) * inc;\n                    if (cpos.x >= 0 && cpos.y >= 0 && cpos.x < int(iResolution.x) && cpos.y < int(iResolution.y)) {\n                        pavg += texelFetch(p1Channel, cpos, 0);\n                        p2avg += texelFetch(p2Channel, cpos, 0);\n                        nconstel += 1;\n                    } else if (bc >= 0) {\n                        if (bc >= 4) {\n                            vec4 b = vec4(0.);\n                            b[bc - 4] = 1.;\n                            p2avg += b;\n                            nconstel += 1;\n                        } else {\n                            vec4 b = vec4(0.);\n                            b[bc] = 1.;\n                            pavg += b;\n                            nconstel += 1;\n                        }\n                    }\n                }\n            }\n        }\n        pavg /= float(nconstel);\n        p2avg /= float(nconstel);\n\n\t\tvec4 pga = texture(qChannel, vec2(1., .35));\n\t\tvec4 p2ga = texture(qChannel, vec2(1., .65));\n                \n    \n        float kh = 0.125;\n        float ks = 0.5;\n        float kq = 0.0125;\n        float ksoft = 0.005;\n        float T = 0.21 * ( 1.0 + controls[tempCtl].value / 2.);\n        \n        mat4 KH = mat4(kh);\n        mat4 KH2 = mat4(kh);\n\n        mat4 U = mat4(1.0 + ks);\n        mat4 U22 = mat4(1.0 + ks);\n        mat4 U12 = mat4(0.);\n\n        U[0][1] = U[1][0] = 1.0;\n        U[1][2] = U[2][1] = 1.0;\n        U[2][3] = U[3][2] = 1.0;\n        U[0][3] = U[3][0] = 1.0;\n        \n        U12[4-4][0] = 1.;\n        U12[4-4][1] = 1.;            \n        U12[4-4][2] = 1.;            \n        U12[4-4][3] = 1.;            \n        U12[5-4][0] = 1.;\n        U12[5-4][1] = 1.;            \n        U12[5-4][2] = 1.;            \n        U12[5-4][3] = 1.;            \n\n        \n        mat4 U21 = transpose(U12);\n        \n        vec4 kqv = kq * vec4(1., 1., 1., 1.);\n        vec4 kqv2 = kq * vec4(1., 0.7, 0., 0.);\n        \n        vec4 e = -KH * p - kqv / (pga + ksoft) - U * pavg - U12 * p2avg;\n        vec4 e2 = -KH2 * p2 - kqv2 / (p2ga + ksoft) - U21 * pavg - U22 * p2avg;\n        \n        vec4 panorm = exp(-e / T);\n        vec4 p2anorm = exp(-e2 / T);\n        float pasum = panorm[0] + panorm[1] + panorm[2] + panorm[3] +\n            p2anorm[0] + p2anorm[1] + p2anorm[2] + p2anorm[3];\n        \n        float ehat = dot(e, p) + dot(e2, p2);\n        float psqr = dot(p, p) + dot(p2, p2);\n        \n        \n        float alpha = .3;\n        \n        vec4 pnew = panorm / pasum * alpha + (1. - alpha) * p;\n        vec4 p2new = p2anorm / pasum * alpha + (1. - alpha) * p2;\n        \n        p1FragColor = vec4(pnew);        \n        p2FragColor = vec4(p2new);        \n               \n        \n        return ehat;\n    }\n}\n\nfloat eraserDiam() {\n    return pow(1. + controls[eraserCtl].value, 2.) * ERASER_DIAM_DEFAULT;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// States 0-3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    configureAndUpdate(iResolution, CTRL_CHANNEL, iMouse, iFrame < 10);    \n\n    vec4 dummy;\n\tcalcUpdate(fragColor, dummy, fragCoord, iFrame, iResolution, iChannel0, iChannel1, iChannel2, iChannel3, true);\n    \n    if (controls[dragclickCtl].mouseDown && length(iMouse.xy - fragCoord) < eraserDiam()) {\n        fragColor = vec4(0.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Global quorum sense\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    configureAndUpdate(iResolution, CTRL_CHANNEL, iMouse, iFrame < 10);    \n\n    \n    if (fragCoord.x / iResolution.x < 0.6) {\n        int gn = 100;\n        vec4 pacc = vec4(0.);\n        for (int xs = 0; xs < gn; xs++) {\n            vec2 pos = vec2(float(xs) / float(gn), fragCoord.y / iResolution.y);\n            vec4 pix;\n\t    \tif (fragCoord.x / iResolution.x < 0.25) {\n            \tpix = texture(iChannel0, pos);\n            } else {\n            \tpix = texture(iChannel2, pos);\n            }\n            pacc += pix * pix;\n        }\n        fragColor = pacc / float(gn);\n    } else {\n        int gn = 100;\n        vec4 pacc = vec4(0.);\n        for (int ys = 0; ys < gn; ys++) {\n            vec2 vpos = vec2(fragCoord.y / iResolution.y / 2., float(ys) / float(gn));\n            pacc += texture(iChannel1, vpos);\n        }\n        fragColor = pacc / float(gn);\n    }\n\n  \n\n    if (fragCoord.y / iResolution.y < .25 && fragCoord.x / iResolution.x > 0.6) {\n\n        if (iFrame < 10) {\n//            controls[overlayCtl].value = 1.;\n        }\n\n        // hackery: guess if we're in preview mode and show the button bar\n        if (iResolution.x + iResolution.y < 500.) {\n            controls[visControl].value = 1.;\n        }\n\n        for (int i = 0; i < MAX_CTRLS; i++) {\n            if (i != visControl && i != dragclickCtl) {\n                controls[i].visible = controls[visControl].value > 0.;\n                controls[i].enabled = controls[visControl].value > 0.;\n            } else {\n                // Resizes inevitably bork gui state, but at least the toggle should be made visible:\n                controls[i].visible = true;\n                controls[i].enabled = true;\n            }\n        }\n\n        fragColor = renderControls(fragCoord, iMouse);        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// States 4-7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    configureAndUpdate(iResolution, CTRL_CHANNEL, iMouse, iFrame < 10);    \n\n    vec4 dummy;\n\tcalcUpdate(dummy, fragColor, fragCoord, iFrame, iResolution, iChannel0, iChannel1, iChannel2, iChannel3, true);\n    \n    if (controls[dragclickCtl].mouseDown && length(iMouse.xy - fragCoord) < eraserDiam()) {\n        fragColor = vec4(0.);\n    }    \n}","name":"Buffer C","description":"","type":"buffer"}]}