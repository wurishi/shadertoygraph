{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289_1_0(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat permute_1_1(float x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt_1_2(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4_1_3(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise_1_4(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289_1_0(i);\n  float j0 = permute_1_1( permute_1_1( permute_1_1( permute_1_1(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute_1_1( permute_1_1( permute_1_1( permute_1_1 (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0_1_5 = grad4_1_3(j0,   ip);\n  vec4 p1 = grad4_1_3(j1.x, ip);\n  vec4 p2 = grad4_1_3(j1.y, ip);\n  vec4 p3 = grad4_1_3(j1.z, ip);\n  vec4 p4 = grad4_1_3(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_5,p0_1_5), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_5 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt_1_2(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0_1_5, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n\n\nfloat smin_2_6(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n\nfloat gaussianSpecular_5_7(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\n\nfloat orenNayarDiffuse_3_8(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\n\nfloat fogFactorExp2_4_9(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_7_10(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_7_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_7_11(vec4 x)\n{\n  return mod289_7_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_7_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_7_13(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise_7_14(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289_7_10(Pi0);\n  Pi1 = mod289_7_10(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_7_11(permute_7_11(ix) + iy);\n  vec4 ixy0 = permute_7_11(ixy + iz0);\n  vec4 ixy1 = permute_7_11(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_7_12(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_7_12(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_7_13(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_8_15(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_8_15(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_8_16(vec4 x) {\n     return mod289_8_15(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_8_17(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_8_18(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_8_19 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_8_20 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_8_20;\n  vec3 i1 = min( g_8_20.xyz, l.zxy );\n  vec3 i2 = max( g_8_20.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_8_19.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_8_15(i);\n  vec4 p = permute_8_16( permute_8_16( permute_8_16(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_8_19.wyz - D_8_19.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_8_21 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_8_22 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_8_21.xy,h.z);\n  vec3 p3 = vec3(a1_8_21.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_8_17(vec4(dot(p0_8_22,p0_8_22), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_8_22 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_8_22,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nfloat grain_6_23(vec2 texCoord, vec2 resolution, float frame, float multiplier) {\n    vec2 mult = texCoord * resolution;\n    float offset = snoise_8_18(vec3(mult / multiplier, frame));\n    float n1 = pnoise_7_14(vec3(mult, offset), vec3(1.0/texCoord * resolution, 0.0));\n    return n1 / 2.0 + 0.5;\n}\n\nfloat grain_6_23(vec2 texCoord, vec2 resolution, float frame) {\n    return grain_6_23(texCoord, resolution, frame, 2.5);\n}\n\nfloat grain_6_23(vec2 texCoord, vec2 resolution) {\n    return grain_6_23(texCoord, resolution, 0.0);\n}\n\n\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX ) {\n  float an = 0.6*iTime + 10.0*mouseX;\n  camPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n  camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void ) {\n  return vec3(0.2, 0.1, 0.2);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p ) {\n  p = mod(p + 4.5, 9.0) - 4.5;\n  \n  float r = 1.2;\n  \n  r += snoise_1_4(vec4(p * 5.5, iTime)) * 0.04;\n  \n  float d = length(p) - r;\n  \n  for (int i = 0; i < 15; i++) {\n    float I = float(i);\n    vec3 pp = vec3(sin(I + iTime), cos(I + iTime), sin(I - iTime * 3.0));\n    d = smin_2_6(d, length(p - pp * 0.9) - 0.1, 0.5);\n  }\n  \n  return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor ) {\n  return vec3(0.4, 0.35, 0.3);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal ) {\n  vec3 lin = vec3(0.0);\n\n  // key light\n  //-----------------------------\n  vec3  lig1 = normalize(vec3(1.0,0.7,0.9));\n  float dif1 = max(0.0, orenNayarDiffuse_3_8(lig1, -rd, nor, 0.9, 0.8));\n  float spc1 = max(0.0, gaussianSpecular_5_7(lig1, -rd, nor, 0.1));\n  \n  vec3  lig2 = normalize(vec3(0.5,-0.9,-0.9));\n  float dif2 = max(0.0, orenNayarDiffuse_3_8(lig2, -rd, nor, 0.9, 0.8)); // max(dot(nor,lig2),0.0);\n  float spc2 = max(0.0, gaussianSpecular_5_7(lig2, -rd, nor, 0.1));\n  \n  vec3 col1 = vec3(4.0, 1.3, 3.5);\n  vec3 col2 = vec3(1.0, 2.0, 5.0);\n  \n  lin += spc1*col1;\n  lin += dif1*col1;\n  lin += spc2*col2;\n  lin += dif2*col2;\n\n  // ambient light\n  //-----------------------------\n  lin += vec3(0.015);\n\n  \n  // surface-light interacion\n  //-----------------------------\n  vec3 col = mal*lin;\n\n  \n  // fog    \n  //-----------------------------\n  //col *= exp(-0.01*dis*dis);\n\n  return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd ) {\n  const float maxd = 20.0;           // max trace distance\n  const float precis = 0.001;        // precission of the intersection\n  float h = precis*2.0;\n  float t = 0.0;\n  float res = -1.0;\n  for( int i=0; i<90; i++ ) {\n    if( h<precis||t>maxd ) break;\n    h = doModel( ro+rd*t );\n    t += h;\n  }\n\n  if( t<maxd ) res = t;\n  return res;\n}\n\nvec3 calcNormal( in vec3 pos ) {\n  const float eps = 0.002;             // precision of the normal computation\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize(\n    v1*doModel( pos + v1*eps ) + \n    v2*doModel( pos + v2*eps ) + \n    v3*doModel( pos + v3*eps ) + \n    v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd ) {\n  float res = 1.0;\n  float t = 0.0005;                 // selfintersection avoidance distance\n  float h = 1.0;\n  for( int i=0; i<40; i++ ) {\n    h = doModel(ro + rd*t);\n    res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n    t += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n  }\n  return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ) {\n  vec3 ww = normalize( ta - ro );\n  vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n  vec3 vv = normalize( cross(uu,ww));\n  return mat3( uu, vv, ww );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n  vec2 m = iMouse.xy/iResolution.xy;\n\n  //-----------------------------------------------------\n  // camera\n  //-----------------------------------------------------\n  \n  // camera movement\n  vec3 ro, ta;\n  doCamera( ro, ta, iTime, m.x );\n\n  // camera matrix\n  mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n  // create view ray\n  vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n  //-----------------------------------------------------\n  // render\n  //-----------------------------------------------------\n\n  vec3 col = doBackground();\n\n  // raymarch\n  float t = calcIntersection( ro, rd );\n  if( t>-0.5 )\n  {\n    // geometry\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos);\n\n    // materials\n    vec3 mal = doMaterial( pos, nor );\n\n    col = mix(col, doLighting( pos, nor, rd, t, mal ), 1. - fogFactorExp2_4_9(t, 0.1));\n  }\n\n  //-----------------------------------------------------\n  // postprocessing\n  //-----------------------------------------------------\n  col = pow( clamp(col,0.0,1.0), vec3(0.785) );\n  col.r = smoothstep(-0.2, 0.9, col.r);\n  col.g = smoothstep(-0.1, 0.8, col.g);\n  col += dot(p, p * 0.04) * vec3(-1.);\n  //col *= mix(0.9, 1.2, grain(p / 2.5, vec2(250.), iTime*10.));\n     \n  fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtBGzz","date":"1426623975","viewed":424,"name":"Daily: 17/3/15","username":"hughsk","description":"Mucking around with shadertoy again","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["rays","lighting","fog","specular","oren","nayar","guassian"],"hasliked":0,"parentid":"","parentname":""}}