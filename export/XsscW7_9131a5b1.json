{"ver":"0.1","info":{"id":"XsscW7","date":"1488516924","viewed":561,"name":"quadratic flame","username":"chadmiral","description":"Flame effect based on intersecting parabolic curves\n\nUse the mouse to change wind direction!","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["vfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// We can define a parabola from a focus point F(fx, fy) and \"directrix\" C.\n// C represents a y-value, and the distance from C to F determines the \"steepness\"\n// of the parabola. We wander F and C around the XY plane using a smooth noise\n// to add organic chaos to the shader.\n//\n// Taking the union of N wandering parabolas produces a black and white mask with\n// a hard edge. While this can be ideal for certain effects, for flame, we soften the\n// edge by computing the vertical distance from a sample point to the closest parabolic curve.\n//\n// Finally, we add various VFX spices to improve the effect. We warp the input uvs by a smooth\n// texture, and scroll a flamey detail texture upwards. We could easily make this more complex\n// with multiple layers of texture combinations / warps, etc...\n//\n//\n// Try commenting out the #define lines below to see how it all comes together\n//\n#define ENABLE_MASKING\n#define ENABLE_SOFT_EDGE\n#define ENABLE_DETAIL\n#define ENABLE_WARP\n#define ENABLE_COLOR\n//#define DISPLAY_WARP_STRENGTH\n//#define TILEABLE\n\n\nint Num_parabolas = 8;    // Total number of parabola\nfloat Speed = 0.015; // Overall speed of motion\nfloat Scroll_speed = -0.35; // scroll speed of noise texture\nfloat Silhouette_height = 0.55; // vertical offset of flame silhouette\nfloat Horizontal_drift = 0.1f; // how much each parabolsa drift horizontally\nfloat Vertical_drift = 0.67f; // how much each parabolas drift vertically\nfloat Curvature_base = 0.002; // base width (?) of each parabola\nfloat Curvature_drift = 0.04; //how much the curvature of each parabola will drift\nfloat Warp_strength = 0.25;\nfloat Warp_tex_scale = 0.9;\nfloat Edge_sharpness = 1.0;\nfloat Tiling_rate = 1.0;\n\n\n//tints the flame based on the intensity\nvec3 flame_color_ramp(float val)\n{\n    vec3 color_a = 1.2 * vec3(1.2, 0.1, 0.2);  // red\n    vec3 color_b = 1.8 * vec3(1.0, 0.8, 0.5); // yellow\n    vec3 color_c = 0.95 * vec3(0.25, 0.25, 0.4); // blue\n    vec3 color_d = 0.5 * vec3(0.35, 0.2, 0.4);  // violet\n    \n    float pos_a = 0.35;\n    float pos_b = 0.65;\n    \n    if(val < pos_a)\n    {\n        return mix(color_a, color_b, val / pos_a);\n    }\n    else if(val < pos_b)\n    {\n        return mix(color_b, color_c, (val - pos_a) / (pos_b - pos_a));\n    }\n    return mix(color_c, color_d, (val - pos_b) / (1.0 - pos_b));   \n}\n\n// warp texture coordinates from a texture input\nvec2 warp(vec2 uv, vec2 warp_uvs, float strength, sampler2D tex)\n{\n#ifdef INVERT_WARP_TEX\n    vec4 w = 1.0 - texture(tex, warp_uvs);\n#else\n    vec4 w = texture(tex, warp_uvs);\n#endif\n    return uv + strength * w.xy;\n}\n\n//generate a random value\nfloat random(float seed, float t)\n{\n    //not sure which method is faster... texture vs. math\n    \n    //return texture(iChannel1, vec2(t, seed)).x;\n    return fract(seed * sin(19123.0 + t));\n}\n\n\nvec3 get_focus(float i)\n{\n\tvec4 r = texture(iChannel0, vec2(i, iTime * Speed));\n    \n    float gamma = 2.2;\n    //r = vec4(pow(r.r, gamma), pow(r.g, gamma), pow(r.b, gamma), 1.0);\n    \n    float x = i + mix(-Horizontal_drift, Horizontal_drift, r.r);\n    float y = (1.0 - Silhouette_height) + mix(-Vertical_drift, Vertical_drift, r.g);\n    \n    vec2 focus = vec2(x, y);\n    float directrix = y + Curvature_base + mix(0.0, Curvature_drift, r.b);\n    \n    return vec3(focus, directrix);\n}\n\nvec4 stretched_scrolling_noise(vec2 uv)\n{\n    vec2 scrolled_uvs = vec2(0.85 * uv.s, 0.2 * uv.t + iTime * Scroll_speed);\n    vec4 n = texture(iChannel1, scrolled_uvs);\n    return 1.0 - n;\n}\n\nvec4 contrast(vec4 in_rgb, float c)\n{\n\treturn ((in_rgb - 0.5) * c) + 0.5;\n}\n\nvec3 desaturate(vec3 in_rgb)\n{\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    float luminance = dot(in_rgb, W);\n    return vec3(luminance, luminance, luminance);\n}\n\nfloat quadratic_signed_distance(vec2 uv, vec2 focus, float c)\n{\n    // quadratic equation where a focus point F(fx, fy) = (a, b)\n    // and the directrix = c\n    // y = ((x−a)^2+b^2−c^2) / 2(b−c)\n    float x = uv.s;\n    float a = (x - focus.x);\n    float a2 = a * a;\n    float b2 = focus.y * focus.y;\n    float c2 = c * c;\n    float denominator = 2.0 * (focus.y - c);\n    float y = (a2 + b2 - c2) / denominator;\n\n    //this is vertical distance from the curve only (which is cheap to compute)\n    return (1.0 - uv.y) - y;\n    \n    //Side note - we can get some really crazy looks if we manipulate this value... for example:\n    //return clamp(pow((1.0 - uv.y) - y, 1.1), 0.0, 1.0);\n}\n\nvec4 add_sparks(vec3 color, vec2 uv)\n{\n    uv = 2.0 * uv + vec2(0.0, -2.0 * iTime);\n    float a = pow(1.0 - texture(iChannel3, uv).r, 60.0);\n    vec3 spark = 1.5 * a * vec3(1.0, 0.3, 0.1);\n    \n    return vec4(color + spark, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //wind\n    //float wind_pct = -(2.0 * iMouse.x / iResolution.x - 1.0);\n    //wind_pct = mix(0.0, 0.4 * wind_pct, pow(uv.y, 3.0));\n    //uv = uv + vec2(wind_pct, 0.0);\n    \n    vec2 wind_dir = -(uv - iMouse.xy / iResolution.xy);\n    float wind_strength = 1.5 * mix(0.0, 0.4, pow(uv.y, 2.0));\n    uv = uv + wind_strength * vec2(wind_dir.x, 0.0);\n    \n    uv = uv * vec2(Tiling_rate, 1.0);\n\n    //exponential remap of warp-strength, so that we warp much more at the top than the bottom.\n    Warp_strength = mix(4.0 * Warp_strength, 0.4 * Warp_strength, pow(1.0 - uv.y, 0.2));\n    Warp_strength = clamp(Warp_strength, 0.0, 0.2);\n   \n    vec2 warped_uv = uv;\n#ifdef ENABLE_WARP\n    vec2 warp_tex_uvs = vec2(Warp_tex_scale * uv.s + 0.0005 * iTime, 0.25 * uv.t - 0.8 * iTime);\n    warped_uv = warp(uv, warp_tex_uvs, Warp_strength, iChannel2);\n#endif\n\n    \n    float silhouette_mask = 1.0;\n    float edge_gradient = 1.0;\n    \n    //first parabola follows the mouse\n    vec3 focus = vec3(iMouse.xy / iResolution.xy, 0.0);\n    focus.y = 1.0 - focus.y;\n    float directrix = 0.09 + focus.y;\n    float d = quadratic_signed_distance(warped_uv, focus.xy, directrix);\n    float vertical_dist = Edge_sharpness * d;\n    if(vertical_dist < 0.0) {\n        silhouette_mask = min(silhouette_mask, 0.0);\n    } else {\n        edge_gradient = min(edge_gradient, vertical_dist);\n    }\n    \n    \n    for(int i = 1; i < Num_parabolas; i++)\n    {\n        float seed = float(i) / float(Num_parabolas - 1);\n        focus = get_focus(seed);\n        \n#if defined TILEABLE\n        //this is to make it tile nicely - there's probably a much\n        //faster / better way to do this.\n        warped_uv = vec2(fract(warped_uv.x), fract(warped_uv.y));\n        \n        float d1 = quadratic_signed_distance(warped_uv, focus.xy, focus.b);\n        float d2 = quadratic_signed_distance(warped_uv, focus.xy + vec2(1.0, 0.0), focus.b);\n        float d3 = quadratic_signed_distance(warped_uv, focus.xy + vec2(-1.0, 0.0), focus.b);\n      \n        d1 = min(min(d1, d2), d3);\n#else   \n        float d1 = quadratic_signed_distance(warped_uv, focus.xy, focus.b);\n#endif\n        \n\n        vertical_dist = Edge_sharpness * d1;\n\n//#ifdef ENABLE_MASKING\n        if(vertical_dist < 0.0)\n        {\n        \tsilhouette_mask = min(silhouette_mask, 0.0);\n        }\n//#endif\n//#ifdef ENABLE_SOFT_EDGE\n        else\n        {\n            edge_gradient = min(edge_gradient, vertical_dist);\n        }   \n//#endif\n    }\n    \n    float c = mix(1.0, 5.0, 1.0 - edge_gradient);\n    \n    vec2 scroll_uvs = warped_uv;\n    scroll_uvs.y = mix(2.0 * scroll_uvs.y, 0.7 * scroll_uvs.y, pow(uv.y, 0.5));\n    vec4 scroll_tex = contrast(stretched_scrolling_noise(scroll_uvs), c);\n    scroll_tex = vec4(desaturate(scroll_tex.rgb), 1.0);\n    \n    vec4 plasma_color = vec4(1.0, 1.0, 1.0, 1.0);\n#ifdef ENABLE_COLOR\n    plasma_color = vec4(flame_color_ramp(edge_gradient), 1.0);\n#endif\n    \n\tfragColor = plasma_color * silhouette_mask;\n\n#ifdef ENABLE_SOFT_EDGE\n    fragColor *= edge_gradient;\n#endif\n    \n#ifdef ENABLE_DETAIL\n    fragColor *= scroll_tex;\n#endif\n    \n#ifdef DISPLAY_WARP_STRENGTH\n\tfragColor = 4.0 * vec4(Warp_strength, Warp_strength, Warp_strength, 1.0);    \n#endif\n    \n    fragColor = add_sparks(fragColor.rgb, scroll_uvs);\n    \n    //show flame color gradient\n    //fragColor = vec4(flame_color_ramp(uv.x), 1.0);\n   \n}","name":"Image","description":"","type":"image"}]}