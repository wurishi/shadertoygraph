{"ver":"0.1","info":{"id":"XddBDn","date":"1524788466","viewed":123,"name":"Vector Ray Tracing","username":"ItsOnlyKatniss","description":"A simple raytracer that uses a lot of vector math","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int samples = 64; // Increase for smoother image.\nconst float sampleJitter = 0.001; // Higher = Fuzzier. Only works when samples is more than 1.\n\n//#define VIGNETTE\n\nconst float PI = 3.14159265;\nconst float TAU = PI * 2.0;\n\nfloat hash(float n) {\n\treturn fract(sin(n * 634.73) * 622.34);\n}\n\nvec3 sunDir() {\n\tfloat angle = 0.7;\n\treturn normalize(vec3(sin(angle), cos(angle), cos(angle) * 0.3));\n}\n\nvec3 skyColor(vec3 p) {\n\tvec3 sun = sunDir();\n\tfloat sunDot = dot(p, sun);\n\tvec3 horizon = vec3(0.8, 0.85, 0.9);\n\tvec3 zenith = vec3(0.3, 0.6, 0.9);\n\t\n\tfloat f1 = p.y - 0.1;\n\t\n\tvec3 res = horizon + (zenith - horizon) * 1.0;\n\t\n\tvec3 sunColor = vec3(1.0, 0.99, 0.8);\n\t\n\tif(sunDot > 0.0) res = res + ((sunColor - res) * pow(sunDot, 10.0));\n\treturn res;\n}\n\nbool checkerboard(vec3 p) {\n\tvec3 v = fract(p);\n\tbool x = v.x < 0.5;\n\tbool y = false;\n\tbool z = v.z < 0.5;\n\tif(x && y && z) return true;\n\tif(!x && !y && z) return true;\n\tif(x && !y && !z) return true;\n\tif(!x && y && !z) return true;\n\treturn false;\n}\n\nvec4 trace(vec3 rO, vec3 rD) {\n\tvec4 color = vec4(skyColor(rD), 1024);\n\tfloat f = testPlane(rO, rD, vec3(0, 0.001, 0), vec3(0, 1, 0));\n\tif(f > 0.0 && f < color.a) {\n\t\tvec3 p = rO + rD * f;\n\t\tbool b = checkerboard(p);\n\t\tcolor = vec4(b ? 0.7 : 0.1);\n\t\tcolor.a = f;\n\t}\n\t\n\tint r = 8;\n\t\n\tfloat f1 = testSphere(rO, rD, vec3(0, 3, 0), 2.0);\n\tif(f1 > 0.0 && f1 < color.a) {\n\t\tvec3 p = rO + rD * f1;\n\t\tcolor = vec4(0.8, 0.4, 0.4, 1.0);\n\t\tcolor.a = f1;\n\t}\n\n    return color;\t\n}\n\nvec4 distTrace(vec3 rO, vec3 rD) {\n    float d = 1024.0;\n    vec3 norm = vec3(0, 0, 0);\n\tfloat f = testPlane(rO, rD, vec3(0, 0.001, 0), vec3(0, 1, 0));\n\tif(f > 0.0 && f < d) {\n\t\td = f;\n        norm = vec3(0, 1, 0);\n\t}\n\t\n\tint r = 8;\n\t\n\tfloat f1 = testSphere(rO, rD, vec3(0, 3, 0), 2.0);\n\tif(f1 > 0.0 && f1 < d) {\n\t\td = f1;\n        vec3 p = rO + rD * d;\n        norm = normalize(p - vec3(0, 3, 0));\n\t}\n\n    return vec4(norm, d);\t\n}\n\nvec3 calcHeading(vec3 campos, vec2 rot, vec2 uv) {\n\tvec3 camtar = campos + vec3(\n\t\t\tcos(rot.y) * sin(rot.x),\n\t\t\tsin(rot.y),\n\t\t\tcos(rot.y) * cos(rot.x)\n\t\t);\n    \n\tvec3 cw = normalize(camtar-campos);\n\tvec3 cp = vec3(0, 1, 0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.6*cw );\n\treturn rd;\n}\n\nvec4 render(vec3 campos, vec3 rd) {\n\tvec4 final = vec4(1);\n\t//float angle = time * TAU / 100;\n\t\n\tvec3 sun = sunDir();\n\t\n\tbool enableSunlight = true;\n\t\n\tvec4 result = trace(campos, rd);\n\tif(result.w >= 0.0) {\n\t\tvec3 p = campos + rd * result.w;\n        \n\t\tfloat r = result.r;\n\t\tfloat g = result.g;\n\t\tfloat b = result.b;\n\t\tfloat f = 1.0;\n        \n        if(enableSunlight) {\n            vec3 off = fract(vec3(hash(p.x), hash(p.y), hash(p.z)));\n            vec4 light = distTrace(p + sun / 1024.0, sun + off * 0.01);\n            if(light.w < 1024.0) f /= 3.0;\n        }\n\t\t\n\t\tfinal = vec4(r, g, b, 1) * f;\n\t}\n\telse {\n\t\tfinal = vec4(skyColor(rd), 1.0);\n\t}\n\tfinal.a = 1.0;\n\treturn final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = ((2.0 * fragCoord / iResolution.xy) - 1.0) * vec2(ratio, 1);\n\n    float r = 8.0;\n    \n\tvec2 rot = vec2(-map(iMouse.x, 0.0, iResolution.x, 0.0, TAU), map(iMouse.y, 0.0, iResolution.y, -PI / 2.1, PI / 2.1));\n\tvec3 pos = vec3(\n\t\t\tcos(rot.y) * sin(rot.x),\n\t\t\tsin(rot.y),\n\t\t\tcos(rot.y) * cos(rot.x)\n\t\t) * -r;\n    \n\tvec3 rd = calcHeading(pos, rot, uv);\n    \n    if(samples < 2) fragColor = render(pos, rd);\n    else {\n        for(int i = 0; i < samples; i++) {\n            float f = float(i) * 734.35;\n            vec3 off = fract(vec3(hash(uv.x + uv.y * f * 53.4), hash(uv.x * f * uv.y), hash(uv.y + uv.x * f * 762.6)));\n            fragColor += render(pos, normalize(rd + off * sampleJitter));\n        }\n        fragColor /= float(samples);\n    }\n\t\n    #ifdef VIGNETTE\n\tfloat f = length(uv.xy) * 1.414;\n\tf = max(f, 1.0);\n\tfragColor.rgb /= sqrt(f);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float map(float x, float in_min, float in_max, float out_min, float out_max)\n{\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\nfloat testPlane(vec3 rO, vec3 rD, vec3 pos, vec3 normal) {\n\tfloat d = dot(rD, normal);\n\tif (d == 0.0) return 0.0;\n\treturn dot(pos - rO, normal) / d;\n}\n\nfloat testSphere(vec3 rO, vec3 rD, vec3 pos, float r) {\n\tvec3 toPoint = rO - pos;\n\n\tfloat B = 2.0 * dot(toPoint, rD);\n\tfloat C = dot(toPoint, toPoint) - r * r;\n\tfloat D = B * B - 4.0 * C;\n\n\tif (D < 0.0) return 0.0;\n\n\tfloat sqrtD = sqrt(D);\n\tfloat t = (-B - sqrtD) / 2.0;\n\tif (t < 0.0) t = (-B + sqrtD) / 2.0;\n\tif (t < 0.0) return 0.0;\n\n\treturn t;\n}\n\n\nfloat testBox(vec3 rO, vec3 rD, vec3 m, vec3 M) {\n\tvec3 inv = vec3(1) / rD;\n\t\n\tfloat tMin, tMax;\n\n\tfloat tx1 = (m.x - rO.x) * inv.x;\n\tfloat tx2 = (M.x - rO.x) * inv.x;\n\tfloat ty1 = (m.y - rO.y) * inv.y;\n\tfloat ty2 = (M.y - rO.y) * inv.y;\n\tfloat tz1 = (m.z - rO.z) * inv.z;\n\tfloat tz2 = (M.z - rO.z) * inv.z;\n\n\ttMin = min(tx1, tx2);\n\ttMax = max(tx1, tx2);\n\ttMin = max(tMin, min(ty1, ty2));\n\ttMax = min(tMax, max(ty1, ty2));\n\ttMin = max(tMin, min(tz1, tz2));\n\ttMax = min(tMax, max(tz1, tz2));\n\n\tif (tMax < 0.0 || tMin < 0.0)\n\t\treturn 0.0;\n\n\tif (tMax >= tMin)\n\t\treturn tMin;\n\t\n\treturn 0.0;\n}","name":"Common","description":"","type":"common"}]}