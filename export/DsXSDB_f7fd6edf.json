{"ver":"0.1","info":{"id":"DsXSDB","date":"1669454437","viewed":148,"name":"Random cubes with JFA","username":"kastorp","description":"strange color explosions when those cubes collide!","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["3d","voronoi","sdf","jfa","jumpflood"],"hasliked":0,"parentid":"cdlXRl","parentname":"Jump Flood Distance 3D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Random Cubes\n//-----------------------------------------------------\n// credits:  Spalmer  \"Jump Flood Distance 2D\"  https://www.shadertoy.com/view/dsXSD8\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(max(d.x,d.y),d.z),0.0);\n}\nfloat map(vec3 p){\n    p=p.xzy;\n    vec3 c=vec3(convM.x,convM.y,convM.z*convM.w)*.5;\n    p+=c;\n    \n    \n    vec4 d1 = T(vec3(p.xy,floor(p.z))),\n         d2 = T(vec3(p.xy,ceil(p.z))),        \n         d= mix(d1,d2,fract(p.z));\n         \n         float cl=length(d1.xyz-d2.xyz)/3.; //collision factor\n         \n         d.w=mix( \n         //cubes\n         max(sdBox(p- (d.xyz),vec3(1.5) )*(1.-cl),d.w-2.6),//safety distance between cubes         \n         d.w-2.,  //spheres\n         pow(sin(iTime*3.+d.x)*.5+.5,10.)); //pulse\n            \n    return min(-sdBox(p-c,c),abs(d.w)-.1);\n   \n}\n\nvec3 color(vec3 p){\n    p=p.xzy;\n    vec3 c= vec3(convM.x,convM.y,convM.z*convM.w)*.5;\n    p+=c;\n        \n    vec4 d1 = T(vec3(p.xy,floor(p.z))),\n         d2 = T(vec3(p.xy,ceil(p.z))),\n         d=  mix(d1,d2,fract(p.z));\n    vec3 seed= floor(d.xyz/3.); \n    return vec3(hash(seed.xy+14.), hash(seed.yz*2.1-17.), hash(seed.zx*1.4)) * .9 + .1;\n       \n}\n\n//-------------------------\n\n//Iq\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .002 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\treturn normalize(n);\n}\n\n\n//Iq\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0,1., 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\n\n\n\nfloat march(vec3 ro, vec3 rd,float st) {\n\tvec3 p;\n\tfloat d = .001;\n\tfor (float i = 0.; i <st; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .001  )break;\n        if(d >convM.x*20.) return 1e5;\n\t\td += h;\n\t} \n    return d;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd) {\n    float d=march(ro,rd,120.);\n    vec3 p=ro+d*rd;\n    vec3 c=vec3(convM.x,convM.z*convM.w,convM.y)*.5;\n    \n    vec3 col= sdBox(p,c)>-.2?vec3(0.145,0.302,0.333):color(p);\n \n    vec3 ld = normalize( vec3(6.,6.,18.) );\n\tvec3 n = calcN(p, d) ;\n\n\tfloat ao = 1.,\n\tl1 = .5 + .5 * dot(ld, n),\n\tspe = max(0., dot(rd, reflect(ld, n))) * .2,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n    \n    float ds=march(p+.01*n, ld,50.);\n\tl1 *= .3+ .7* step(-.2,sdBox(p+ld*ds,c));\n\tvec3 lig = clamp(l1 * ao + spe,0.,5.) * vec3(4.)*mix(.3, .4, fre)  ;\n    \n    \n\treturn mix(vec3(.4,.9,.9), col*lig,exp(-d*d * .00002));\n}\nvoid mainImage2d(out vec4 o, vec2 fc)\n{\n    \n\tvec4 seed = T(to3d(fc));\n    vec3 color = vec3(hash(seed.xy+14.), hash(seed.yz*2.1-17.), hash(seed.zx*1.4)) * .9 + .1;\n    \n    float d=seed.w;//length(seed.xyz-to3d(fc));\n    color *= cos(.8 *d) * .2 + .8;\n    color*=.1+.9*smoothstep(1.,0., abs(d-5.));\n    color.xy+=(smoothstep(2.,0.,mod(fc,convM.xy)));\n    o = vec4(pow(color, vec3(.45)), 1);\n    if(fc.x>convM.x*convM.z || fc.y>convM.y*convM.w) o*=0.;\n    \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n    setM(convM,iResolution.xy);\n    // if((iFrame%511) <60){mainImage2d(fragColor,fc);return;} //DEBUG\n    vec2 m=2.*iMouse.xy/iResolution.xy-1.;\n    float t=iTime*.3;\n\tvec3 ro = ( iMouse.x>0.)? convM.x*.4*vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y)):vec3(cos(t),1,sin(t))*convM.x*.3;\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(render(ro, getRayDir(ro, vec3(0), uv)), vec3(.4)), fc), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// JFA steps to do (resolution should be a power of 2)\nint maxSteps = 12;\n\n// frames between steps.  1 = full speed.\nconst int frameStepDelay = 1; //5; //15; //50; //\n\nfloat sqr(vec3 v) { return dot(v, v); }\n\nvec3 StepJFA(vec3 p, int level)\n{\n    level = maxSteps - 1 - level; // reverse order: coarse to fine works much better\n    level = clamp(level, 0, maxSteps);\n    vec3 best = vec3(-1000);\n    float bestd2 = 3e38,\n    w = float(1 << level);   \n    for (float z = -w; z <= w; z+= w)\n    for (float y = -w; y <= w; y += w)\n    for (float x = -w; x <= w; x += w) {\n        vec3 c=vec3(x,y,z);\n        if(all(lessThan(c+p,vec3(convM.x,convM.y,convM.z*convM.w))) && all(greaterThanEqual(c+p,vec3(0)))) {\n        \n            vec3 seed = T(c + p).xyz;\n            if (seed.x >= 0.) {\n                float d2 = sqr(seed -  p);\n                if (bestd2 > d2) {\n                    bestd2 = d2;\n                    best = seed;\n                }\n            }\n        }\n    }\n    return best;\n}\n\nbool isSeed(vec3 p)\n{\n    float seedChance = .0003, \n      rchance = sqrt(seedChance); // 2 hashes because precision issues\n    return hash13(p + fract(iDate.w * 1.214)) < rchance  && hash13(p.zxy +37.+ fract(iDate.w * 2.214)) < rchance;\n   \n}\n            \nvoid mainImage(out vec4 o, vec2 fc) // fragCoord\n{\n    if(max(fc.x,fc.y)<1.){o=vec4(iResolution.xyxy);return;}\n    vec3 seed;\n    setM(convM,iResolution.xy);\n    maxSteps=int(log2(convM.x))+3;\n    int f = iFrame &511;\n    vec3 pos =to3d(fc);\n    if (f == 0 || iResolution.x!=texelFetch(iChannel0,ivec2(0),0).x) {\n    \n        // initialize random seed locations\n        seed = isSeed(to3d(fc)) \n            ? floor(pos) : vec3(-1);\n    } else {    \n        // periodic steps\n        seed = (f % frameStepDelay == 0)\n            ? StepJFA(pos, f / frameStepDelay - 1) : T(to3d(fc)).xyz;\n    }\n    o = vec4(seed, length(pos-seed)); // output data has closest seed location in xy\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hoskins hash without sine from http://shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec4 convM; //x,y,zx,zy)\nvec3 to3d(vec2 c){\n   return  vec3(mod(c.x,convM.x),mod(c.y,convM.y),floor(c.x/convM.x)+ floor(c.y/convM.y)*convM.z);\n\n} \n\nvec2 to2d(vec3 c){\n    vec4 p1 = vec4( mod(c.x,convM.x),mod(c.y,convM.y),floor(mod(c.z,convM.z)),floor(c.z/convM.z));\n    return vec2(p1.x +p1.z*convM.x,p1.y +p1.w*convM.y);\n} \n\n\nvoid setM(inout vec4  convM, vec2 R){\n    float l = floor(pow(R.x*R.y,.33));\n    //l=exp2(ceil(log2(l)));\n    convM= vec4(l,l,floor(R.x/l),floor(R.y/l) );\n\n}\nvec4 Tex(sampler2D ch,vec2 R, vec3 p){\n    vec2 u =to2d(p);\n    return texture(ch, (u) / R);\n}\n// obtain nearest seed location to p from BufferA\n#define T(p) Tex(iChannel0, iResolution.xy,p)","name":"Common","description":"","type":"common"}]}