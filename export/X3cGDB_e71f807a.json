{"ver":"0.1","info":{"id":"X3cGDB","date":"1717004543","viewed":70,"name":"IntersectionBasedRendering","username":"Plastic","description":"Simple lambertian lightning.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535;\n\nmat3 rot(float x, float y, float z)\n{\n    mat3 rotation_x = mat3(\n        1., .0, .0,\n        .0, cos(x), -sin(x),\n        .0, sin(x), cos(x)\n    );\n    \n    mat3 rotation_y = mat3(\n        cos(y), .0, sin(y),\n        .0, 1., .0,\n        -sin(y), .0, cos(y)\n    );\n    \n    mat3 rotation_z = mat3(\n        cos(z), -sin(z), .0,\n        sin(z), cos(z), .0,\n        .0, .0, 1.\n    );\n    \n    mat3 finalrot = rotation_x * rotation_y * rotation_z;\n    \n    return finalrot;\n      \n}\n\nfloat motion(float x)\n{\n    float phase = fract(x)*pi;\n    return ((sin(phase))*10.)+4.;\n}\n\nvec4 iplane(vec3 ro, vec3 rd, vec4 plane)\n{\n    float product = dot(rd, plane.xyz);\n\n    if (product == 0.0)\n    {\n        return vec4(0.0);\n    }\n\n    float k = (-plane.w - dot(plane.xyz, ro)) / product;\n    \n    if (k < 0.0)\n    {\n        return vec4(0.0);\n    }\n\n    vec3 final = ro + k * rd;\n\n    return vec4(final, 1.0);\n}\n\nvec4 isphere(vec3 ro, vec3 rd, vec3 c, float r)\n{\n    float disc = pow(2.*(dot(rd, ro-c)), 2.) - 4.*pow(length(rd), 2.)*(pow(length(ro-c), 2.) - r*r);\n    \n    float ka = (-2.*(dot(rd, ro-c)) + sqrt(disc))/(2.*pow(length(rd), 2.));\n    float kb = (-2.*(dot(rd, ro-c)) - sqrt(disc))/(2.*pow(length(rd), 2.));\n    \n    if(disc < .0 || ka < .0 || kb < .0)\n    {\n        return vec4(.0);\n    }\n    \n    vec3 pa = ro+ka*rd;\n    vec3 pb = ro+kb*rd;\n    \n    if(disc == .0)\n    {\n        return vec4(pa, 1.); \n    }\n    \n    vec3 final = distance(ro, pa) < distance(ro, pb) ? pa : pb;\n    \n    return vec4(final, 1.);\n\n}\n\nfloat lamb(vec3 a, vec3 b)\n{\n    return min(max(smoothstep(-10., 10., dot(a, b)), 0.2), 1.);\n}\n\nfloat shadow(vec3 pos, vec3 light)\n{\n    vec4 check = isphere(pos, light, vec3(.0, motion(iTime), .0), 4.);\n    \n    if(check.w == .0)\n    {\n        return 1.;\n    }\n    else\n    {\n        return 0.2;\n    }\n\n}\n\nvec3 sphereNormal(vec3 c, vec3 pos)\n{\n    return normalize(pos - c);\n}\n\nvec3 rflcol(vec3 pos, vec3 ro, vec3 normal, vec3 lightdir, vec3 light)\n{\n    vec4 coefplane = vec4(.0, 1., 0., 0.);\n    vec4 check = iplane(pos, reflect(normalize(pos - ro), normal), coefplane);\n\n    float fake = (10./distance(light, pos.xyz));\n    \n    vec3 red = vec3(0.3, 0.3, 0.8);\n    float fac = 0.9;\n    \n    float shade = shadow(check.xyz, lightdir);\n\n    vec3 rflmat[3];\n    rflmat[0] = mix(vec3(sign(cos(check.x)+sin(check.z)))*shade, red, fac);\n    rflmat[1] = vec3(.0);\n    rflmat[2] = mix(vec3(.0), red, fac);\n    \n    if(check.w == 1.)\n    {\n        return rflmat[0]; \n    }\n    else\n    {\n        return rflmat[2]; \n    }\n\n}\n\nvec3 matsel(vec4 pack, vec3 normal[2], vec3 ro)\n{\n\n    vec3 light = vec3(4., 4., 4.);\n    vec3 lightdir = normalize(light);\n\n    vec3 mat[3];\n    mat[0] = vec3(sign(cos(pack.x)+sin(pack.z)))*shadow(pack.xyz, lightdir);\n    mat[1] = rflcol(pack.xyz, ro, normal[1], lightdir, light)*lamb(normal[1], light);\n    mat[2] = vec3(0.8, 1., 1.);\n    \n    float fake = (10./distance(pack.xyz, light.xyz));\n    \n    return mat[int(pack.w)]*fake;\n}\n\n\nvec3 torender(vec3 ro, vec3 rd)\n{\n    vec4 coefplane = vec4(.0, 1., 0., 0.);\n    vec3 sphereCenter = vec3(.0, motion(iTime), .0);\n    vec4 plane = iplane(ro, rd, coefplane);\n    vec4 sphere = isphere(ro, rd, sphereCenter, 4.);\n    \n    vec4 large = vec4(vec3(pow(10., 100.)),0);\n    \n    vec4 obj[2];\n    obj[0] = large;\n    obj[1] = large;\n    \n    if(plane.w == 1.)\n    {\n        obj[0] = plane;\n    }\n    if(sphere.w == 1.)\n    {\n        obj[1] = sphere;\n    }\n    \n    bool test = distance(ro, obj[0].xyz) < distance(ro, obj[1].xyz);\n    \n    vec3 finalpos = test ? obj[0].xyz : obj[1].xyz;\n    float index = test ? .0 : 1.;\n    \n    if(obj[1].w + obj[0].w == .0)\n    {\n        index = 2.;\n    }\n    \n    vec3 normal[2];\n    normal[0] = coefplane.xyz;\n    normal[1] = sphereNormal(sphereCenter, finalpos);\n    \n    vec3 col = matsel(vec4(finalpos, index), normal, ro);\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*0.2;\n\n    vec3 cam = vec3(cos(time)*15., 10., sin(time)*15.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1.))*rot(.0, -pi/2.-time, .0);\n    vec3 see = torender(cam, dir);\n\n    fragColor = vec4(see,1.0);\n}","name":"Image","description":"","type":"image"}]}