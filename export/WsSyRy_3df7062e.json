{"ver":"0.1","info":{"id":"WsSyRy","date":"1586812152","viewed":145,"name":"eyespy","username":"Del","description":"raymarch blinking eye test - classic eye texture by IQ :)\nleft click + move mouse to look around... the usual\n - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["eye","blink"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// simple raymarch blinking eye test using IQ's classic eye texture :)\n// optimized eye calc / texture lookup etc.\n\n#define MARCHSTEPS 80\n#define AA\t2\n#define PI\t3.1415926\n#define\tTAU\t6.28318\n\n// ---------------\n// IQ's classic eye texture \nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat length2( vec2 p )\n{\n    vec2 q = p*p*p*p;\n    return pow( q.x + q.y, 1.0/4.0 );\n}\n\nvec3 eyetex(vec2 p)\n{\n\tfloat r = length( p );\n    float a = atan( p.y, p.x );\n    float dd = 0.2*sin(1.4*iTime);\n    float ss = 1.0 + clamp(1.0-r,0.0,1.0)*dd;\n    r *= ss;\n    vec3 col = vec3( 0.0, 0.3, 0.4 );\n    float f = fbm( 5.0*p );\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n    col = mix( col, vec3(0.9,0.6,0.2), 1.0-smoothstep(0.2,0.6,r) );\n    a += 0.05*fbm( 20.0*p );\n    f = smoothstep( 0.3, 1.0, fbm( vec2(20.0*a,6.0*r) ) );\n    col = mix( col, vec3(1.0,1.0,1.0), f );\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*a,10.0*r) ) );\n    col *= 1.0-0.5*f;\n    col *= 1.0-0.25*smoothstep( 0.6,0.8,r );\n    f = 1.0-smoothstep( 0.0, 0.6, length2( mat2(0.6,0.8,-0.8,0.6)*(p-vec2(0.3,0.5) )*vec2(1.0,2.0)) );\n    //col += vec3(1.0,0.9,0.9)*f*0.985;\n    col *= vec3(0.8+0.2*cos(r*a));\n    f = 1.0-smoothstep( 0.2, 0.25, r );\n    col = mix( col, vec3(0.0), f );\n    f = smoothstep( 0.79, 0.82, r );\n    col = mix( col, vec3(1.0), f );    \n    return col;\n}\n// end of IQ's classic eye texture\n// ---------------\n\n// ----------\n// background stripes\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 SSTLines(vec2 duv, float nl, float grad,float thickness, float wibblesize, float wibblespeed, float glowintensity, float glowclamp, float extraglow)\n{\n   \tvec3 col2 =  hsv2rgb(vec3(iTime*0.025,0.5,0.5));\n    duv.y -= (floor(duv.x)*grad) + (duv.x*grad);\n    duv = fract(duv);\n    float l1 = abs(fract((duv.x*grad-duv.y)*nl) -0.5);\n    float dd = sin(iTime*wibblespeed+duv.x*6.28)*wibblesize;\n    l1 = min(glowclamp, (thickness+dd)/l1);\n    vec3 col = col2*l1*glowintensity+(dd*extraglow);\n    return mix(col2,col,l1);\n}\n\nvec3 background(vec2 uv)\n{\n    uv *= 0.5+sin(iTime)*0.25;\t// zoom\n    uv.y += iTime*0.1;\t\t\t// vscroll\n\treturn SSTLines(uv, 5.0, sin(iTime*0.35)*0.2, 0.15,  0.015, 6.5, 3.25, 1.0, 9.0);\n}\n//end of background stripes\n// ----------\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// simplified :)\nfloat _cindex = 0.0;\t\t\t// colour index\nfloat map( in vec3 p )\n{\n    float c = 3.3+pMod1(p.y,2.5);\n    p.x += sin(iTime+c*0.5)*4.0;\n    c *= 7.7+pMod1(p.x,2.5);\n    float d1 = length(p)-0.9;\n    float d2 = length(vec2(p.z-1.6,p.y))-(1.0-pow((sin( mod(iTime+c*0.35, 200.))*0.5+0.5), 40.));\n    d2 = ssub(d2, d1-0.1, 0.05);\n    _cindex = 2.0+step(d1,d2);\n    return  min(d2, d1);    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 bg = background(uv)*0.65;\n     // camera movement\t\n    float an = sin(iTime*0.7)*0.35;\n    float dist = 8.0+sin(iTime*0.8)*4.0;\n    an+=PI*0.5;\n    float y = 0.0;\n    \n    if (iMouse.z>0.5)\n    {\n        an=iMouse.x/iResolution.x*4.0;\n        y = (iMouse.y/iResolution.y)*8.0;\n        y-=4.0;\n    }\n    \n\tvec3 ro = vec3( dist*cos(an), -y, dist*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 40.0;\n        float t = 0.0;\n        for( int i=0; i<MARCHSTEPS; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        vec3 col = bg;\t//vec3(0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\n            // nasty :)\n            vec3 ambcol =  vec3(0.65, 0.4, 0.35);\n            if(_cindex > 2.5)\n\t\t\t\tambcol = eyetex(vec2((0.25-( atan(nor.z, nor.x) / TAU)) * 12.0, -( asin(nor.y) / PI)*6.0))*0.9;\n            col = (ambcol*ambcol)*(dif+0.25);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    \n\tfragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}