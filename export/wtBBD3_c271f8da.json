{"ver":"0.1","info":{"id":"wtBBD3","date":"1599989881","viewed":108,"name":"Logo UwU RayMarching","username":"VinsStm","description":"Logo de l'association UwU (association d'informatique de l'ENSE3) animé réalisé en ray-marching.\n\nanimated UwU association logo using ray-marching (UwU is the computer association of ENSE3, a french engineering school)\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sst smoothstep\n#define st step\n#define PI 3.1415926535897932384626433832795\n\n\n//---------------------------------------------------------\nfloat n21(vec2 p) {\n\tp += dot(p + vec2(0.5, 16.4268), p + vec2(23.45, 0.1563)) * 10000.;\t\n\treturn fract(cos(dot(p, vec2(63.428, 23.1452))) * 43437.3123545);\n}\n\n\n//---------------------------------------------------------\nfloat perlinNoise2D(vec2 p) {\n\tvec2 int_p = floor(p);\n\tvec2 flt_p = fract(p);\n\t\n\tvec2 swz = vec2(1., 0.);\t// for swizzle\n\t\n\tfloat n00 = n21(int_p) * 4. * PI;\n\tfloat n10 = n21(int_p + swz.xy) * 4. * PI;\n\tfloat n11 = n21(int_p + swz.xx) * 4. * PI;\n\tfloat n01 = n21(int_p + swz.yx) * 4. * PI;\n\t\n\tvec2 v00 = vec2(cos(n00), sin(n00));\n\tvec2 v10 = vec2(cos(n10), sin(n10));\n\tvec2 v11 = vec2(cos(n11), sin(n11));\n\tvec2 v01 = vec2(cos(n01), sin(n01));\n\t\n\tfloat d00 = dot(flt_p.xy, v00);\n\tfloat d10 = dot(flt_p.xy - swz.xy, v10);\n\tfloat d11 = dot(flt_p.xy - swz.xx, v11);\n\tfloat d01 = dot(flt_p.xy - swz.yx, v01);\t\n\t\n\t//vec2 cbc = sst(0., 1., flt_p);\t// cubic interpolation\n\tvec2 intp = flt_p*flt_p*flt_p*(flt_p*(flt_p*6.-15.)+10.);\t//quintic interpolation\n\t\n\tfloat m_bck_dwn = mix(d00, d10, intp.x);\t// from left to right\n\tfloat m_bck_up = mix(d01, d11, intp.x);\t// from left to right\n\treturn 0.5 + mix(m_bck_dwn, m_bck_up, intp.y);\t// bottom to top\n\t\n}\n\n\n//---------------------------------------------------------\nstruct Frame {\n\tvec3 o;\n\tvec3 x;\n\tvec3 y;\n\tvec3 z;\n};\n\n\n//---------------------------------------------------------\nstruct Camera {\n\tFrame fr;\t// the camera is oriented along -fr.z\n\tfloat ds;\t// position of the center of the screen on the z axis (this distance should be negative)\n};\n\n\n//---------------------------------------------------------\nstruct Ray {\n\tvec3 o;\t// ray origin\n\tvec3 d;\t// ray direction\n};\n\n\n//---------------------------------------------------------\nstruct Capsule {\n\tvec3 a;\n\tvec3 b;\n\tfloat r;\n};\n\n\n//---------------------------------------------------------\nstruct Torus {\n\tFrame fr;\n\tfloat r1;\n\tfloat r2;\n};\n\n\n//---------------------------------------------------------\nstruct Box {\n\tFrame fr;\n\tvec3 d;\t// d.x is the distance between the origin fr.o of the box and the sides of normal +/- fr.x\n\tfloat cr;\t// corner radius\n};\n\n\n//---------------------------------------------------------\nstruct Cylinder {\n\tvec3 a;\n\tvec3 b;\n\tfloat r;\n\tfloat cr;\t// corner radius\n};\n\n\n//---------------------------------------------------------\nstruct Pipe {\n\tvec3 a;\n\tvec3 b;\n\tfloat rext;\n\tfloat rint;\n};\n\n\n//---------------------------------------------------------\nstruct SurfaceElement {\n\tvec3 n;\t// vector normal to the surface element\n\tvec3 o;\t// middle point of the surface element\n\tvec3 clr;\t// color of the surface element\n};\n\n\n//---------------------------------------------------------\nstruct Light {\n\tvec3 clr;\n\tvec3 o;\n};\n\n\n//---------------------------------------------------------\nvec3 changeBasis1(vec3 v, Frame fr) {\n\treturn transpose(mat3(fr.x, fr.y, fr.z)) * v;\n}\n\n\n//---------------------------------------------------------\nvec3 changeBasis2(vec3 v, Frame fr) {\n\treturn mat3(fr.x, fr.y, fr.z) * v;\n}\n\n\n//---------------------------------------------------------\n// p is the point in the original frame, o is the origin of the final frame with respect to the original frame\n// x, y and z are vectors that define the final frame wrt the original frame\nvec3 changeFrame1(vec3 p, Frame fr) {\n\tvec3 cp = p - fr.o;\n\treturn changeBasis1(cp, fr);\n}\n\n\n//---------------------------------------------------------\n// p is the point in the original frame, o is the origin of the original frame with respect to the final frame\n// fr.x, fr.y and fr.z are vectors that define the original frame wrt the final frame\nvec3 changeFrame2(vec3 p, Frame fr) {\n\treturn fr.o + changeBasis2(p, fr);\n}\n\n\n//---------------------------------------------------------\n#define ROTX(a) mat3(1., 0., 0., 0., cos(a), -sin(a), 0., sin(a), cos(a))\n#define ROTY(a) mat3(cos(a), 0., -sin(a), 0., 1., 0., sin(a), 0., cos(a))\n#define ROTZ(a) mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.)\n\n\n//---------------------------------------------------------\nFrame rotateX(Frame f, float a) {\t// rotate with respect to the original frame\n\tmat3 mat = ROTX(a);\n\t\t\t\t\t\n\tf.x = mat * f.x;\n\tf.y = mat * f.y;\n\tf.z = mat * f.z;\n\t\n\treturn f;\n}\n\n\n//---------------------------------------------------------\nFrame rotateY(Frame f, float a) {\t// rotate with respect to the original frame\n\tmat3 mat = ROTY(a);\n\t\t\t\t\t\n\tf.x = mat * f.x;\n\tf.y = mat * f.y;\n\tf.z = mat * f.z;\n\t\n\treturn f;\n}\n\n\n//---------------------------------------------------------\nFrame rotateZ(Frame f, float a) {\t// rotate with respect to the original frame\n\tmat3 mat = ROTZ(a);\n\t\t\t\t\t\n\tf.x = mat * f.x;\n\tf.y = mat * f.y;\n\tf.z = mat * f.z;\n\t\n\treturn f;\n}\n\n\n//---------------------------------------------------------\nfloat smth(float a, float b, float k) {\n\tfloat h = clamp(0.5 + (b - a) / k, 0., 1.);\n\treturn h * a + (1. - h) * b - 0.5 * h * (1. - h) * k;\n}\n\n\n//---------------------------------------------------------\n#define BLUR_DIST 0.2\t// this is used to create a blur effect on \n\t\t\t\t\t\t// the shadows by creating a zone around the \n\t\t\t\t\t\t// shapes where the ligt rays are attenuated\n#define BLUR_INT -1.\n#define BLUR_EXT 1.\n#define NO_BLUR 0.\n\n\n//---------------------------------------------------------\nfloat dSphere(vec4 s, vec3 point, bool toLight, float blur) {\n\ts.w += toLight ? blur * BLUR_DIST / 2. : 0.;\n\treturn distance(point, s.xyz) - s.w;\n}\n\n\n//---------------------------------------------------------\nfloat dBox(Box bx, vec3 p, bool toLight, float blur) {\n\tbx.d += toLight ? blur * BLUR_DIST / 2. : 0.;\n\tp = changeFrame1(p, bx.fr);\t\n\t//return length(abs(p) - min(abs(bx.d - bx.cr), abs(p)));\n\treturn length(max(abs(p) - (bx.d - bx.cr), 0.)) - bx.cr;\n}\n\n\n//---------------------------------------------------------\nfloat dSurf(SurfaceElement srf, vec3 p, bool toLight, float blur) {\n\treturn dot(srf.n, p - srf.o) + (toLight ? blur * BLUR_DIST / 2. : 0.);\n}\n\n\n//---------------------------------------------------------\n#define SURF_DIST 0.004\t// this is the smallest distance considered by the raymarcher\n#define MAX_DIST 70.\t// greatest render distance\n\n\n//---------------------------------------------------------\nvec4 dLetter_U(vec3 shiftU, bool toLight, float smthness, float corner) {\n\tBox btm;\t// for bottom\n\tmat3 rotY = ROTY(PI * sst(0.75, 0.9, fract(iTime / 4.)));\n\tbtm.fr.o = vec3(0., 2., 0.);\n\tbtm.fr.y = vec3(0., 1., 0.);\n\tbtm.fr.x = rotY * vec3(1., 0., 0.);\n\tbtm.fr.z = rotY * vec3(0., 0., 1.);\n\tbtm.d = vec3(2.5, 0.75, 0.75);\n\tbtm.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat d_btm = dBox(btm, shiftU, toLight, BLUR_INT);\n\t\n\tBox top;\n\ttop.fr.o = vec3(1.75, 6.5, 0.);\n\ttop.fr.x = vec3(1., 0., 0.);\n\ttop.fr.y = top.fr.x.yxy;\n\ttop.fr.z = top.fr.x.yyx;\n\ttop.d = vec3(0.75);\n\ttop.cr = SURF_DIST + corner;\t// corner raduis\t\n\tfloat d_top = smth(d_btm, dBox(top, vec3(abs(shiftU.x), shiftU.yz), toLight, BLUR_INT), smthness);\n\t\n\tBox ltf;\t// for left\n\tmat3 rotX = ROTX(PI * sst(0.75, 0.9, fract(iTime / 4.)));\n\tltf.fr.o = vec3(1.75, 4.25, 0.);\n\tltf.fr.x = vec3(1., 0., 0.);\n\tltf.fr.y = rotX*ltf.fr.x.yxy;\n\tltf.fr.z = rotX*ltf.fr.x.yyx;\n\tltf.d = vec3(0.75, 3., 0.75);\n\tltf.cr = SURF_DIST + corner;\t// corner raduis\n\t\n\tfloat dist = smth(d_top, dBox(ltf, vec3(abs(shiftU.x), shiftU.yz), toLight, BLUR_INT), smthness);\n\treturn vec4(3. * vec3(0., 0.5 * 155. / 255., 0.5 * 60. / 255.), dist);\n}\n\n\n//---------------------------------------------------------\nvec4 dLetter_w(vec3 p, bool toLight, float smthness, float corner) {\n\tBox btm;\t// for bottom\n\tbtm.fr.o = vec3(0., 2.25, 0.);\n\tbtm.fr.x = vec3(1., 0., 0.);\n\tbtm.fr.y = btm.fr.x.yxy;\n\tbtm.fr.z = btm.fr.x.yyx;\n\tbtm.d = vec3(2.5, 0.625, 0.625);\n\tbtm.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat d_btm = dBox(btm, p, toLight, BLUR_INT);\n\t\n\tBox ltf;\t// for left\n\tltf.fr.o = vec3(2, 3.6875, 0.);\n\tltf.fr.x = vec3(1., 0., 0.);\n\tltf.fr.y = ltf.fr.x.yxy;\n\tltf.fr.z = ltf.fr.x.yyx;\n\tltf.d = vec3(0.625, 2., 0.625);\n\tltf.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat d_lft = smth(d_btm, dBox(ltf, vec3(abs(p.x), p.yz), toLight, BLUR_INT), smthness);\n\t\t\n\tBox cntr;\t// for center\n\tcntr.fr.o = vec3(0., 3.25, 0.);\n\tcntr.fr.x = vec3(1., 0., 0.);\n\tcntr.fr.y = ltf.fr.x.yxy;\n\tcntr.fr.z = ltf.fr.x.yyx;\n\tcntr.d = vec3(0.5, 1.5, 0.5);\n\tcntr.cr = SURF_DIST + corner;\t// corner raduis\n\tfloat dist = smth(d_lft, dBox(cntr, p, toLight, BLUR_INT), smthness);\n\treturn vec4(vec3(0.1), dist);\n}\n\n\n//---------------------------------------------------------\nvec4 getDist(vec3 p, bool toLight) {\n\n\t// distances\n\tvec4[3]\td;\n\n\t//------------shapes--------------\t\n\t\n\t\n\t//-------sphere-----(ground)\n\tfloat radius = 250.;\n\tvec4 earth = vec4(0., -radius , 0., radius);\t// x, y, z coordinates ; and the radius\n\tfloat dist_middle = length(p.xz);\n\tfloat offset = perlinNoise2D((p.xz + vec2(50., 50.)) * 0.4);\n\toffset += sst(10., 15., dist_middle) * sin(0.3 * dist_middle - iTime * 2.5) * sin(12. * atan(p.z, p.x) - 4.5 * iTime);\n\tfloat dist_ground = dSphere(earth, p, toLight, BLUR_INT) + offset;\n\tvec3 clr = vec3(0.2);\n\n\td[0] = vec4(clr, dist_ground);\t// ground distance\n\t\n\t\n\t// capital U\t\n\td[1] = dLetter_U(vec3(-abs(p.x), p.yz) - vec3(-6., 0., 0.), toLight, 1., 0.2);\n\t\n\t\n\t// w\n\td[2] = dLetter_w(p, toLight, 1., 0.2);\n\t\n\t\n\t// the minimum distance is the distance to the closest object\n\tvec4 minDist = vec4(vec3(1.), MAX_DIST);\n\tfor(int i=0 ; i<3 ; i++) {\n\t\tminDist = d[i].w < minDist.w ? d[i] : minDist;\n\t}\n\t\n\treturn minDist;\n}\n\n\n//---------------------------------------------------------\nvec3 intersect(Ray r, float d) {\n\treturn r.o + r.d * d;\n}\n\n\n//---------------------------------------------------------\n#define MAX_STEPS 100\n\nvec2 rayMarch(Ray r, bool toLight) {\n\tbool firstHit = false;\n\tfloat d_o = 0.; // distance from the origin\n\t\n\tfloat closest = MAX_DIST;\t// initialize smallest distance between the ray (not the ray marcher) and an object (that the ray marcher is getting closer)\n\tfloat prevDist = SURF_DIST;\t// initialize the distance between the last position of the ray marcher (point on the ray) and the closest object at this position\n\t\n\tint i;\n\tfor(i=0 ; i<MAX_STEPS ; i++) {\n\t\tvec3 p = intersect(r, d_o);\t// current position of the ray marcher\n\t\tfloat dst = getDist(p, toLight).w;\t// get the distance of the nearest object\n\t\t// if the ray marcher is getting closer of an object AND the distance between the ray marcher\n\t\t// and the object is smaller than the distance to the  previous closest\n\t\tif(dst<prevDist && dst<closest) {\t// object (that the ray marcher is getting closer)\n\t\t\tclosest = dst;\t// then, the distance to the previous closest object becomes the current distance between the ray marcher and the object\n\t\t}\n\t\t\n\t\td_o += dst;\t// increment the ray marcher with this distance\n\t\tif(abs(dst)<SURF_DIST || d_o>MAX_DIST) break;\t// taking the absolute value prevent the raymarcher from stopping inside an object\n\t\t\n\t\tprevDist = dst;\t// updating the previous distance (needs to be done after the 'if -> break')\n\t}\n\t\n\treturn vec2(d_o, closest);\n}\n\n\n//---------------------------------------------------------\nSurfaceElement getNormal(vec3 p) {\n\tvec4 d = getDist(p, false);\n\t\n\tvec2 e = vec2(SURF_DIST / 2., 0.);\t// used for swizzling\n\n\tvec3 n = d.w - vec3(\n\tgetDist(p - e.xyy, false).w,\n\tgetDist(p - e.yxy, false).w,\n\tgetDist(p - e.yyx, false).w);\n\t\n\tSurfaceElement sr;\n\tsr.clr = d.xyz;\n\tsr.n = normalize(n);\n\tsr.o = p;\n\t\n\treturn sr;\t// vector normal to the surface\n}\n\n\n//--------------------------------------------------------\n#define AMBIENT 0.025\n#define DARK_SHADOW 0.9\t\t// darkness of the projected shadows (1. is full darkness)\n\nvec3 getCol(vec3 p, Light lgt) {\n\tvec3 lr = lgt.o - p; //light ray\n\tvec3 lrn = normalize(lgt.o - p);\t// direction of tht light ray\n\tSurfaceElement sr = getNormal(p);\n\t\n\tRay r;\n\tr.o = p;\n\tr.d = lrn;\n\tvec2 rm = rayMarch(r, true);\t\n\tfloat shadow = sst(0., SURF_DIST + BLUR_DIST, rm.y);// with blur on the edges of the shadow\n\t//float shadow = st(SURF_DIST, rm.y);// without blur on the edges of the shadow\n\t\n\tfloat dif = clamp(dot(sr.n, lrn), 0., 1.);\n\tdif *= 1. - DARK_SHADOW + (rm.x > length(lr) ? DARK_SHADOW * shadow : 0.);\n\t//vec3 col = lgt.clr * clamp(sr.clr, 0., 1.) * dif;\n\tvec3 col = lgt.clr * sr.clr * dif;\n\treturn  col;\n}\n\n\n//---------------------------------------------------------\nvec3 renderLight(vec3 p) {\n\n\tfloat lights_height = 25.;\n\tfloat dfs = 15.;\t// distance from center\n\tfloat min_clr = 0.5;\n\t// light source 1\n\tLight ls1;\n\tls1.clr = vec3(1.);\t// color of the light\n\tls1.o = ROTY(- 2. * iTime / 5.) * vec3(0., lights_height, dfs);\t// light source\n\tvec3 col1 = getCol(p, ls1);\n\t\n\t// light source 2\n\tLight ls2;\n\tls2.clr = 0.5 + 0.5 * sin(iTime * vec3(0.345, 0.456, 0.657));\n\tls2.o = ROTY(2. * PI / 3.) * ls1.o;\n\tvec3 col2 = getCol(p, ls2);\n\t\n\t// light source 3\n\tLight ls3;\n\tls3.clr = 0.5 + 0.5 * sin(iTime * vec3(0.345, 0.456, 0.657));\n\tls3.o = ROTY(2. * PI / 3.) * ls2.o;\t\n\tvec3 col3 = getCol(p, ls3);\n\t\n\treturn col1 + col2 + col3;\n}\n\n\n\n//---------------------------------------------------------\nRay getRay(Camera cam, vec2 uv) {\n\tvec3 p = changeFrame2(vec3(uv, cam.ds), cam.fr);\n\tRay r;\n\tr.o = cam.fr.o;\n\tr.d = normalize(p - r.o);\n\treturn r;\n}\n\n\n\n//---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n\n\tfloat angle = -iTime / 5.;\n\tmat3 mty = ROTY(angle);\n\t\n\t//------------Camera-----------\n\tCamera cam;\n\tcam.fr.o = vec3(0., 8., 18);\n\tcam.fr.x = vec3(1., 0., 0.);\n\tcam.fr.y = cam.fr.x.yxy;\n\tcam.fr.z = cam.fr.x.yyx;\n\tcam.ds = -0.5;\n\t\n\tcam.fr.o = mty * cam.fr.o;\t// rotate origin of the camera around the y axis\n\tcam.fr = rotateX(cam.fr, PI / 8.);\n\tcam.fr = rotateY(cam.fr, angle);\n\t\n\tRay r = getRay(cam, uv);\n\t\n\t\n\t//-----------intersection with objects------------\n\tvec2 rm = rayMarch(r, false);\n\tvec3 p = intersect(r, rm.x); \t// intersection point\n\t\n\tvec3 col = renderLight(p) * (rm.x >= MAX_DIST ? 0. : 1.);\n\t\n\tcol = clamp(AMBIENT + (1. - AMBIENT) * col, AMBIENT, 1.);\n\tcol = pow(col, vec3(0.4545));\n\tcol = col*col*(3.0-2.0*col);\n\n\n\t//vec3 col = vec3(perlinNoise3D(vec3(uv * 10., iTime)));\n\t\n\tfragColor = vec4(col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}