{"ver":"0.1","info":{"id":"X3V3WD","date":"1717919102","viewed":90,"name":"tracing subtraction & edges","username":"elci","description":"subtraction on intersected shapes","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nShape ReadShape( int i ){\n    Shape s = ShapeData[i];\n    return s;\n}\n\nRayHit IntersectShape( in vec3 ro, in vec3 rd, in Shape shape ){\n\tmat3 rotm = RotationXYZ( shape.rot );\n\tro = (ro-shape.pos)*rotm;\n\trd = rd*rotm;\n\tRayHit hit = RayMiss;\n\tswitch( shape.type ){\n\tcase SHAPE_RECT:\n\t\thit = Intersect_Rect( ro, rd, shape.attr.xyz );\n\t\tbreak;\n\t}\n\thit.near.xyz *= inverse(rotm);\n\treturn hit;\n}\nfloat EdgeDistanceShape( in vec3 p, in Shape shape ){\n\tmat3 rotm = RotationXYZ( shape.rot );\n\tp = (p-shape.pos)*rotm;\n\tfloat d = -1.0;\n\tswitch( shape.type ){\n\tcase SHAPE_RECT:\n\t\td = EdgeDistance_Rect( p, shape.attr.xyz );\n\t\tbreak;\n\t}\n\treturn d;\n}\nfloat DistanceShape( in vec3 p, in Shape shape ){\n\tmat3 rotm = RotationXYZ( shape.rot );\n\tp = (p-shape.pos)*rotm;\n\tfloat d = -1.0;\n\tswitch( shape.type ){\n\tcase SHAPE_RECT:\n\t\td = Distance_Rect( p, shape.attr.xyz );\n\t\tbreak;\n\t}\n\treturn d;\n}\n\n\nRayHit StepThroughSubtractions( in vec3 ro, in vec3 rd, in Shape ps, inout int i, out vec4 debug ){\n\tint start = i;\n\tint n = 0;\n    \n\tRayHit far_hit;\n    far_hit.far.w = -999.0;\n\tShape far_shape;\n    \n\tRayHit near_hit;\n    near_hit.near.w = 999.0;\n\tShape near_shape;\n    \n    Shape ns;\n\tRayHit nhit;\n    int cur = start;\n    do{\n    \tcur++;\n    \tns = ReadShape(cur);\n    \tif( ns.operation != OP_SUB ) break;\n        \n    \tnhit = IntersectShape( ro, rd, ns );\n    \tif( nhit == RayMiss || nhit.far.w < 0.0 ) continue;\n\t\tn++;\n\t\tif( nhit.near.w < near_hit.near.w ){\n\t\t\tnear_hit = nhit;\n\t\t\tnear_shape = ns;\n\t\t}\n\t\tif( nhit.far.w > far_hit.far.w ){\n\t\t\tfar_hit = nhit;\n\t\t\tfar_shape = ns;\n\t\t}\n    }\n    while( ns.operation == OP_SUB );\n\n\ti = cur - 1;\n\t\n\tns = ps;\n    \n    RayHit phit = IntersectShape( ro, rd, ps );\n    \n\t// check if we're inside the primary shape and NOT in any negative volume\n\tif( phit.near.w < 0.0 && near_hit.near.w > 0.0 ){\n        // we're 'inside' the final shape\n        if( phit.far.w > near_hit.near.w ){\n\t\t\t//ns = near_shape;\n            return near_hit;\n        }\n\t\treturn RayHit( phit.far, phit.near );\n\t}\n\n\tif( n == 0 ) // didn't hit any negative volumes\n\t\treturn phit; // most likely outcome\n    \n\t// if the nearest negative volume is not exposed then we just hit the primary surface.\n\tif( near_hit.near.w > phit.near.w && phit.near.w > 0.0 )\n\t\treturn phit;\n  \n\t// if the primary is fully behind all negative volumes it will not be affected.\n\tif( phit.near.w > far_hit.far.w ) \n\t\treturn phit;\n    \n    // if we're inside the farthest negative volume there can't be anything between the far_hit.\n\t// !! not 100% accurate for concave negative shapes. !!\n\tif( far_hit.near.w <= 0.0 ){\n\t\tif( far_hit.far.w > phit.far.w )\n\t\t\treturn RayMiss; // went-through\n\t\t//ns = far_shape;\n\t\treturn RayHit( far_hit.far, far_hit.near );\n\t}\n    \n\t// if farthest negative volume extends to the visible surface, it is the only relevent shape.\n\tif( phit.near.w >= far_hit.near.w ){ // 2nd most likely outcome\n\t\tif( far_hit.far.w >= phit.far.w )\n\t\t\treturn RayMiss; // went-through\n\t\t//ns = far_shape;\n\t\treturn RayHit( far_hit.far, far_hit.near );\n\t}\n\n\tif( n == 1 ) // single negative volume that does not reach the surface\n\t\treturn phit;\n    \n\t// multiple negative volumes in the ray path, we step through slowly\n\t// this should be rare\n\n\tRayHit hit = phit;\n    float t = phit.near.w;\n\tif( t <= 0.0 ){\n        t = 0.0;\n\t\thit = RayMiss;\n    }\n    \n\tShape s;\n\tint limit = n; // failsafe\n\tbool progressed;\n    do{\n\t\tprogressed = false;\n\t\tfor( cur = start+1; cur <= i; cur++ ){\n    \t\ts = ReadShape(cur);\n    \t\tnhit = IntersectShape( ro, rd, s );\n    \t\tif( nhit == RayMiss ) continue;\n    \t\tif( nhit.near.w > t ) continue; // not inside this negative volume\n\n    \t\tif( nhit.far.w > t ){\n\t\t\t\tprogressed = true;\n\t\t\t\tt = nhit.far.w;\n\t\t\t\thit.near = nhit.far;\n\t\t\t\t//ns = s;\n\t\t\t}\n\t\t}\n\t\tif( t >= phit.far.w ) // went-through\n\t\t\treturn RayMiss;\n        \n\t\tif( t >= far_hit.near.w ){ // hit known max\n            if( far_hit.far.w >= phit.far.w )\n                return RayMiss; // went-through\n            return RayHit( far_hit.far, far_hit.near );\n\t\t}\n    }\n    while( progressed && limit-- > 0 );\n    \n\treturn hit;\n}\n\nRayHit SceneIntersect( in vec3 ro, in vec3 rd, out Shape shape, out vec4 debug ){\n    RayHit v = RayMiss;\n\tshape = SkyBox;\n    \n    for(int i = 0; i < MAX_SHAPES; i++ ){\n    \tShape s = ReadShape(i);\n        if( s == EmptyShape ) break;\n\t\tif( s.operation == OP_SUB ) continue;\n        //RayHit hit = IntersectShape( ro, rd, s );\n\t\tRayHit hit = StepThroughSubtractions(ro,rd, s, i, debug);\n\t\tif( hit == RayMiss || hit.near.w > v.near.w ) continue;\n        \n\t\tv = hit;\n\t\tshape = s;\n    }\n    \n\treturn v;\n}\n\n// TODO: hard include this in SceneDistance it's not used anywhere else\nfloat NegativeDistance( in vec3 p, inout int i ){\n    float d = 0.0;\n    int cur = i;\n    Shape s;\n    do{\n    \tcur++;\n    \ts = ReadShape(cur);\n\t\tif( s.operation != OP_SUB ) break;\n    \td = min(d, DistanceShape(p, s));\n    }\n    while( s.operation == OP_SUB );\n\ti = cur - 1;\n\treturn d;\n}\n\nfloat SceneDistance( in vec3 pos ){\n    float v = 1.0;\n    for(int i = 0; i < MAX_SHAPES; i++ ){\n    \tShape s = ReadShape(i);\n    \tif( s == EmptyShape ) break;\n\t\tif( s.operation == OP_SUB ) continue;\n        \n    \tfloat d = max(0.0, DistanceShape(pos, s));\n        d -= NegativeDistance( pos, i );\n        v = min(v, d);\n    }\n    return v;\n}\n\nvec3 SortedInsert( vec3 v, float n ){\n    if( n > v.z ) return v;\n    float a = min(v.x,n);\n    float b = max(v.y,n);\n    return vec3( a, v.x+v.y+n-a-b, b );\n}\nfloat EdgeDistance( in vec3 p, in Shape shape ){\n\tfloat e1 = EdgeDistanceShape(p, shape); // natural primary shape edges\n    float e2 = 1.0; // natural edges of negative volumes\n    float e3 = 1.0; // edges between negative volumes and their primary shapes.\n    float e4 = 1.0; // edges between two negative volumes\n    float e5 = 1.0; // edges between shapes\n    \n    vec3 pv = vec3(1.0); // sorted lowest 3 distances to solid shapes\n    vec3 nv = vec3(1.0); // nearest 3 to negative volumes that affect `shape`\n    float pd = 1.0;\n    float nd = 0.0;\n    int lastid = -1;\n    for(int i = 0; i < MAX_SHAPES; i++ ){\n    \tShape s = ReadShape(i);\n    \tif( s == EmptyShape ) break;\n        float d = DistanceShape(p, s);\n        \n\t\tif( s.operation == OP_SUB ){\n            nd = min(nd, d);\n            if( lastid == shape.id ){\n                e2 = min(e2, max(d, EdgeDistanceShape(p, s)));\n                e3 = min(e3, d-pd);\n                nv = SortedInsert(nv, d);\n            }\n            continue;\n        }\n        pd = max(0.0, pd);\n        pd -= nd;\n        pv = SortedInsert(pv, pd);\n        \n        lastid = s.id;\n        pd = d;\n        nd = 0.0;\n    }\n    pd = max(0.0, pd);\n    pd -= nd;\n    pv = SortedInsert(pv, pd);\n    \n    e4 = nv.y;\n    e5 = pv.y;\n    return min(min(min(e1,e2),min(e3,e4)),e5);\n}\n\nfloat SceneAO_SDF( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( float h = 0.01; h < 0.4; h += 0.05 ){\n        float d = SceneDistance( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.9;\n        if( occ>0.8 ) break;\n    }\n    return clamp( 1.0 - 0.5*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n// 32 distributed points on a sphere.\n// ordered so each point is the next optimal point to\n// achieve a somewhat even distribution.\nconst vec3 AO_Offsets[32] = vec3[](\n\tvec3(0.252,0.119,-0.960),\n\tvec3(-0.444,-0.136,0.885),\n\tvec3(0.759,0.582,0.294),\n\tvec3(-0.522,-0.834,-0.181),\n\tvec3(-0.522,0.834,0.181),\n\tvec3(0.759,-0.582,-0.294),\n\tvec3(-0.933,-0.078,-0.352),\n\tvec3(0.792,0.085,0.604),\n\tvec3(0.134,0.658,-0.741),\n\tvec3(0.134,-0.658,0.741),\n\tvec3(-0.933,0.078,0.352),\n\tvec3(0.298,-0.501,-0.812),\n\tvec3(-0.010,0.880,0.475),\n\tvec3(0.361,-0.932,-0.025),\n\tvec3(-0.560,0.630,-0.539),\n\tvec3(0.252,-0.119,0.960),\n\tvec3(0.620,0.667,-0.413),\n\tvec3(-0.598,-0.437,-0.672),\n\tvec3(-0.560,-0.630,0.539),\n\tvec3(0.955,0.268,-0.127),\n\tvec3(-0.598,0.437,0.672),\n\tvec3(-0.010,-0.880,-0.475),\n\tvec3(0.361,0.932,0.025),\n\tvec3(0.620,-0.667,0.413),\n\tvec3(-0.444,0.136,-0.885),\n\tvec3(0.298,0.501,0.812),\n\tvec3(-0.892,-0.446,0.075),\n\tvec3(0.792,-0.085,-0.604),\n\tvec3(-0.892,0.446,-0.075),\n\tvec3(0.955,-0.268,0.127),\n\tvec3(-0.173,0.956,-0.237),\n\tvec3(-0.173,-0.956,0.237)\n);\nfloat SceneAO( in vec3 pos, in vec3 normal ){\n    const int q = 16;\n\tfloat v = 0.0;\n\tShape s;\n    vec4 debug;\n\tfor( int i = 0; i < q; i++ ){\n\t\tRayHit hit = SceneIntersect( pos, AO_Offsets[i]+(Hash3(pos)-0.5), s, debug );\n\t\tv += clamp(hit.near.w, 0.0, 1.0);\n\t}\n\treturn clamp(v/float(q), 0.0, 1.0);\n}\n\nvec3 Render( vec3 ro, vec3 rd ){\n\tvec3 col = vec3(0.5, 0.6, 0.7);\n    \n    vec4 debug;\n    Shape shape;\n\tRayHit hit = SceneIntersect(ro, rd, shape, debug);\n\tif( hit != RayMiss ){\n\t\tvec3 pos = ro+(rd*hit.near.w);\n        float AO = 1.0;\n        AO = SceneAO_SDF(pos, hit.near.xyz);\n        //AO = SceneAO( ro+(rd*hit.near.w*0.9999), hit.near.xyz);\n        \n        //col = Hash3(vec3(shape.id));\n        col = hit.near.xyz*0.5+0.5;\n        \n\t\tfloat edge = EdgeDistance( pos, shape );\n\t\tedge = smoothstep(0.0, pow(hit.near.w,0.2), pow(edge,0.2));\n\t\tedge = step(edge, 0.25);\n\t\tcol = mix( col, vec3(1), edge );\n\t\t//AO = max(AO, edge);\n        \n        col *= AO;\n    }\n    col = mix(col,debug.rgb,debug.a);\n    return col;\n}\n\n\nvoid mainImage( out vec4 oFragColor, in vec2 vFragPos ){\n    // uniforms\n    float t = iTime*0.4+20.0;\n    vec3 uCameraTar = vec3(0);\n    vec3 uCameraPos = uCameraTar + vec3( sin(t), sin(t), cos(t) )*2.0;\n    vec4 uPerspective = vec4( 1.9, iResolution.x/iResolution.y, 1.0, 9000.0 );\n    // vertex shader stuff\n    vFragPos = (vFragPos / iResolution.xy);\n    mat4 vpm = VPM( uCameraPos, uCameraTar, uPerspective.x, uPerspective.y, uPerspective.zw );\n    vec3 vRayDirection = (inverse(vpm)*vec4( vFragPos*2.0-1.0, 1.0, 1.0)).xyz;\n    vec3 vRayOrigin = uCameraPos;\n    \n    // Fragment Shader\n    vec3 ro = vRayOrigin;\n    vec3 rd = normalize(vRayDirection);\n\tvec3 col = Render(ro, rd);\n    \n    \n    oFragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SHAPE_EMPTY 0\n#define SHAPE_RECT 1\n\n#define OP_ADD 0\n#define OP_SUB 1\n\nstruct RayHit{\n\tvec4 near;\n    vec4 far;\n};\nRayHit RayMiss = RayHit( vec4(0,0,0,999), vec4(0,0,0,-999) );\n\nstruct Shape{\n\tint id;\n\tint type;\n\tint operation;\n\tint material;\n\tvec3 pos;\n\tfloat opacity;\n\tvec3 rot;\n\tvec4 attr;\n};\nconst Shape SkyBox = Shape(-1, SHAPE_EMPTY, OP_ADD, 0, vec3(0), 1.0, vec3(0), vec4(0));\nconst Shape EmptyShape = Shape(-3, SHAPE_EMPTY, OP_ADD, 0, vec3(0), 0.0, vec3(0), vec4(0));\n\n// test data\n#define MAX_SHAPES 16\nconst Shape ShapeData[16] = Shape[](\n    Shape(1, SHAPE_RECT, OP_ADD, 1, vec3(0,0,0), 1.0, vec3(0,0,0), vec4(1,.3,1,0)),\n    Shape(2, SHAPE_RECT, OP_SUB, 1, vec3(0,0.3,0), 1.0, vec3(0,1,0), vec4(0.9,0.11,0.9,0)),\n    Shape(3, SHAPE_RECT, OP_SUB, 1, vec3(0,0.2,0), 1.0, vec3(0,2,0), vec4(0.8,0.11,0.8,0)),\n    Shape(4, SHAPE_RECT, OP_SUB, 1, vec3(0,0.1,0), 1.0, vec3(0,3,0), vec4(0.7,0.11,0.7,0)),\n    Shape(5, SHAPE_RECT, OP_SUB, 1, vec3(0,0.0,0), 1.0, vec3(0,4,0), vec4(0.6,0.11,0.6,0)),\n    Shape(6, SHAPE_RECT, OP_SUB, 1, vec3(0,-.1,0), 1.0, vec3(0,5,0), vec4(0.7,0.11,0.7,0)),\n    Shape(7, SHAPE_RECT, OP_SUB, 1, vec3(0,-.2,0), 1.0, vec3(0,6,0), vec4(0.8,0.11,0.8,0)),\n    Shape(8, SHAPE_RECT, OP_SUB, 1, vec3(0,-.3,0), 1.0, vec3(0,7,0), vec4(0.9,0.11,0.9,0)),\n    \n    Shape(11, SHAPE_RECT, OP_ADD, 1, vec3(1,0,0), 1.0, vec3(0,0,0), vec4(0.5,0.5,0.5,0)),\n    Shape(12, SHAPE_RECT, OP_SUB, 1, vec3(1,0.3,0), 1.0, vec3(0,0,1), vec4(0.1,1,0.1,0)),\n    Shape(13, SHAPE_RECT, OP_SUB, 1, vec3(1,0.3,0), 1.0, vec3(0,1,1), vec4(0.1,1,0.1,0)),\n    Shape(14, SHAPE_RECT, OP_SUB, 1, vec3(1,0.3,0), 1.0, vec3(0,2,1), vec4(0.1,1,0.1,0)),\n    Shape(15, SHAPE_RECT, OP_SUB, 1, vec3(1,0.3,0), 1.0, vec3(0,3,1), vec4(0.1,1,0.1,0)),\n    Shape(16, SHAPE_RECT, OP_SUB, 1, vec3(1,0.3,0), 1.0, vec3(0,4,1), vec4(0.1,1,0.1,0)),\n    Shape(17, SHAPE_RECT, OP_SUB, 1, vec3(1,0.3,0), 1.0, vec3(0,5,1), vec4(0.1,1,0.1,0)),\n    \n    EmptyShape\n);\n\n\nRayHit Intersect_Rect( in vec3 ro, in vec3 rd, in vec3 siz ) \n{\n    vec3 m = 1.0/rd;\n    vec3 k = vec3(rd.x>=0.0?siz.x:-siz.x, rd.y>=0.0?siz.y:-siz.y, rd.z>=0.0?siz.z:-siz.z);\n    vec3 t1 = (-ro - k)*m;\n    vec3 t2 = (-ro + k)*m;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n\tif( tN>tF || tF<0.0 ) return RayMiss;\n    return RayHit( vec4( -sign(rd)*step(vec3(tN),t1 ), tN ), \n                         vec4( -sign(rd)*step(t2,vec3(tF)), tF) );\n}\nfloat Distance_Rect( in vec3 p, in vec3 size ){\n    vec3 d = abs(p) - size;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat EdgeDistance_Rect( in vec3 p, in vec3 size ){\n\tp = abs(abs(p)- size);\n\treturn min(length(p.xy), min(length(p.yz), length(p.zx)));\n}\n\nvec3 Hash3(vec3 p){\n    return fract(sin(vec3(\n\t\tdot(p,vec3(131.49571, 239.71037, 038.14210)),\n        dot(p,vec3(238.78501, 083.33407, 110.55123)),\n        dot(p,vec3(126.80198, 182.64811, 230.78199))\n\t)) * 67.89012);\n}\nmat3 RotationXYZ( in vec3 a ){\n    vec3 s = sin(a);\n    vec3 c = cos(a);\n    return mat3(\n         c.z*c.y, c.z*s.y*s.x+s.z*c.x, -c.z*s.y*c.x+s.z*s.x,\n         -s.z*c.y, -s.z*s.y*s.x+c.z*c.x, s.z*s.y*c.x+c.z*s.x,\n         s.y, -c.y*s.x, c.y*c.x\n    );\n}\nmat4 VPM( in vec3 pos, in vec3 target, in float fov, in float aspect, in vec2 range ){\n    const vec3 up = vec3(0,1,0);\n    mat4 m;\n    m[2].xyz = normalize(pos-target);\n    m[0].xyz = normalize(cross(up, m[2].xyz));\n    m[1].xyz = normalize(cross(m[2].xyz, m[0].xyz));\n    m[3] = vec4( pos, 1.0 );\n\n    //float f = tan((3.14159265359-fov)*0.5);\n    float rinv = 1.0 / (range.x - range.y);\n    mat4 p = mat4(\n        fov / aspect, 0, 0, 0,\n        0, fov, 0, 0,\n        0, 0, (range.x + range.y) * rinv, -1,\n        0, 0, range.x * range.y * rinv * 2.0, 0\n    );\n\n    return p * inverse(m);\n}\n","name":"Common","description":"","type":"common"}]}