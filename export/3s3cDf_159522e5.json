{"ver":"0.1","info":{"id":"3s3cDf","date":"1601852840","viewed":185,"name":"Groovy...","username":"igneus","description":"Droste effect demo that sort of became a psychedelic simulator. ","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["psychedelic","droste"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the UVR texture coordinates\n    vec3 uvr = XYToUVR(fragCoord, iResolution);\n    \n    // Calculate the vignette effect\n    float vignette = 1.0 - kVignette * pow(uvr.z, 3.0);\n    \n\t// Composite the final image\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * vignette;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Droste effect parameters\nconst float kBladeSpeed = 0.2;\t\t\t\t// The speed of the blade rotation\nconst float kBlades = 5.0;\t\t\t\t\t// The number of blades\nconst float kBladeCurvature = 2.5; \t\t\t// The curvature of the blades. \nconst float kExp = 3.1;\t\t\t\t\t\t// The curl of the spiral (lower = more turns)\nconst float kZoomSpeed = 0.2;\t\t\t\t// The zoom rate\nconst float kSwerve = 1.0;\t\t\t\t\t// The degree of swerving around the image\nconst float kSpectrumFrequency = 0.666;    \t// The frequency of the colour spectrum\nconst float kPolkaDots = 0.2;\t\t\t\t// The intensity of the polka dot pattern\n\n// Sampling and image parameters\nconst int kSuperSamples = 10;\t\t\t\t// The super-sample rate\nconst float kDofBlur = 0.05;\t\t\t\t// The ammount of depth-of-field blur\nconst float kMotionBlur = 0.9;\t\t\t\t// The degree of motion blur\nconst bool kSquareAspectRatio = true;\t\t// Whether to always use a square aspect ratio\n\n// Post-processing parameters\nconst float kVignette = 0.5;\t\t\t\t// The amount of vignette\nconst int kBlendMode = 0;\t\t\t\t\t// The blend mode (0 = multiplicative, 1 = screen)\nconst float kTextureGamma = 1.0 / 1.5; \t\t// The gamma factor for the input texture\n\n// Compositing settings\nconst bool kShowGrid = false;\t\t\t\t// Toggle the grid for debugging\nconst bool kCompTexture = true;\t\t\t\t// Toggle whether or not the texture is used in the composite\nconst bool kCompSpectrum = true;\t\t\t// Toggle whether or not the colour spectrum is used in the composite\n\n// Constants and precomp\nconst float kLogExp = log(kExp);\nconst float kPi = 3.14159265359;\nconst float kTwoPi = 2.0 * kPi;\nconst float kRoot2 = sqrt(2.0);\nconst float kLog10 = log(10.0);\n\n// Returns a fully-saturated hue based on the angle phi\nvec3 Spectrum(in float phi)\n{\n\tphi = mod(phi * 6.0 / kTwoPi, 6.0);\n   \tint n = int(phi);\n   \tfloat delta = phi - float(n);\n    switch(n)\n    {\n        case 0: return vec3(1.0, delta, 0.0);\n        case 1: return vec3(1.0 - delta, 1.0, 0.0);\n        case 2: return vec3(0.0, 1.0, delta);\n        case 3: return vec3(0.0, 1.0 - delta, 1.0);\n        case 4: return vec3(delta, 0.0, 1.0);\n        case 5: return vec3(1.0, 0.0, 1.0 - delta);\n    }\n   \treturn vec3(0.0);\n}\n\n// Thresholds an RGB input based on parameter t\nvec4 Threshold(in vec4 v, in float t)\n{\n    return vec4((v.x < t) ? 0.0 : 1.0, \n                (v.y < t) ? 0.0 : 1.0, \n                (v.z < t) ? 0.0 : 1.0, \n                v.w); \n}\n\n// Returns the luminance of an RGB colour\nfloat Luminance(in vec4 v)\n{\n    return dot(v.xyz, vec3(0.21, 0.71, 0.07));\n} \n\n// Rotates v by theta radians\nvec2 Rotate(in vec2 v, in float theta)\n{\n    return vec2(cos(theta) * v.x + sin(theta) * v.y,\n                sin(theta) * v.x - cos(theta) * v.y);\n}\n\nvec3 XYToUVR(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = vec2(xy.x / iResolution.x, xy.y / iResolution.y);\n    if(kSquareAspectRatio)\n    {\n        uv.y = (uv.y - 0.5) * (iResolution.y / iResolution.x) + 0.5;\n    }\n    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    return vec3(uv, sqrt(x*x + y*y) / kRoot2);\n}\n\n// Returns the polar distance r to the perimeter of an n-sided polygon\nfloat Ngon(in float phi, in float iTime)\n{\n    float piBlades = kPi / kBlades;\n    float bladeRadius = cos(piBlades) / cos(mod(((phi + iTime * kBladeSpeed) + piBlades) + piBlades, 2.0f*piBlades) - piBlades);\n    \n    // Take into account the blade curvature\n    return kBladeCurvature + bladeRadius * (1.0 - kBladeCurvature);\n}\n    \n/** Remaps the xy input in the range [0, 1] according to the Droste spiral\nOutput: \n x: u coordinate [0, 1]\n y: v coordinate [0, 1]\n z: The number of turns into the spiral\n w: The normalised angle to the origin in the range [0, 1]\n**/\nvec4 DrosteMap(in vec2 xy, in float iTime)\n{\n\t// Remap into range [-1, 1]\n    float x = ((1. - xy.x) * 2. - 1.);\n  \tfloat y = ((xy.y) * 2. - 1.);\n    \n    // Just using constants for now\n    float Exp = kExp;\n    float LogExp = log(Exp);\n\n    float phi = atan(y, x);\n  \tfloat chi = mod(kPi + phi / (2.0*kPi) + 0.25, 1.0) + mod(kZoomSpeed * iTime, 1.0);\n    float r = pow(Exp, -chi) * sqrt(x*x + y*y) / kRoot2;\n    float s = r / Ngon(phi, iTime);\n    float turn = ceil(log(s) / LogExp);\n    float alpha = r / pow(Exp, turn);\n   \n    vec2 uv;\n    uv.x = (alpha * cos(phi) + 1.0) * 0.5;\n  \tuv.y = (alpha * sin(phi) + 1.0) * 0.5;   \n    return vec4(uv, turn, chi);\n}\n\nvec3 DrosteColourMapAngle(in vec2 xy, in float iTime)\n{\n    vec4 xyzw = DrosteMap(xy, iTime);\n    \n    return Spectrum((xyzw.z + xyzw.w) * 0.5 * kTwoPi);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Accumulate the motion-blurred pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uvr = XYToUVR(fragCoord, iResolution);\n    \n    // Check for out of bounds access\n    if(uvr.x < 0.0 || uvr.x > 1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec2 ssPixel = vec2(1.0 / iResolution.x, 1.0 / iResolution.x) + vec2(1.0, 1.0) * kDofBlur * pow(uvr.z, 2.0);\n    vec4 accum = vec4(0.0);\n    \n    // Supersample the Droste function\n  \tfor(int u = 0; u < kSuperSamples; u++)\n    {\n        for(int v = 0; v < kSuperSamples; v++)\n        {\n    \t\tvec2 ssUV = uvr.xy + ssPixel * vec2(float(u) / float(kSuperSamples), float(v) / float(kSuperSamples));\n            \n            vec4 droste = DrosteMap(ssUV, iTime);\n            \n            vec2 offset;\n    \t\toffset.x = kSwerve * 0.2 * sin(0.1 * 2.0 * kPi * (iTime + droste.z + droste.w));\n    \t\toffset.y = kSwerve * 0.1 * cos(0.1 * 2.0 * kPi * (iTime - droste.z - droste.w));\n            \n            droste.xy += offset;\n            \n       \t\tdroste.x = mod(droste.x, 1.0);\n            droste.y = mod(droste.y, 1.0);\n            \n            if(kShowGrid)\n            {\n            \tfloat uGrid = droste.x * 30.0, vGrid = droste.y * 30.0;\n    \t\t\tfloat grid = ((uGrid - floor(uGrid) < 0.05) || ( vGrid - floor(vGrid) < 0.05)) ? 0.0 : 1.0;\n            \n            \taccum +=vec4(droste.x * grid, droste.y * grid, 0.0, 0.0);\n                continue;\n            }\n            \n            // Are we using a texture?\n            vec4 pixel = vec4(1.0);\n            if(kCompTexture)\n            {\n                pixel *= texture(iChannel1, droste.xy);\n                pixel = vec4(pow(pixel.x, kTextureGamma), pow(pixel.y, kTextureGamma), pow(pixel.z, kTextureGamma), 1.0);\n            }\n            \n            // Are we using the spectrum?\n            if(kCompSpectrum)\n            {\n            \t// Polka dots\n                vec2 rot = Rotate(droste.xy, kPi / 4.0);\n                float dots = kPolkaDots * (0.5 * sin(rot.x * 50.) + 0.5) * (0.5 * cos(rot.y * 50.) + 0.5);\n                vec4 spectrum = vec4(Spectrum((droste.z + droste.w + dots) * kSpectrumFrequency * kTwoPi), 0.0);\n                \n                // Blend the spectrum with the texture\n            \tif(kBlendMode == 0)\n            \t{\n                \taccum += pixel * spectrum;\n            \t}\n                else\n                {\n                    float L = Luminance(pixel);\n                \tvec4 blend = (L < 0.5) ? (spectrum * L * 2.0) : (vec4(1.0) * (L - 0.5) * 2.0 + spectrum * (1.0 - ((L - 0.5) * 2.0)));            \n    \t\t\t\taccum += blend;\n                }\n            }\n            else\n            {\n                accum += pixel;\n            }\n        }\n    }    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * kMotionBlur;\n    fragColor += (1.0 - kMotionBlur) * accum / float(kSuperSamples * kSuperSamples);\n}","name":"Buffer A","description":"","type":"buffer"}]}