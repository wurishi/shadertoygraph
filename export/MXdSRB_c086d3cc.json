{"ver":"0.1","info":{"id":"MXdSRB","date":"1719278803","viewed":104,"name":"Homemade voxel DDA +fog","username":"Teluri","description":"the dda algorithm is the friends we made along the way\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycasting","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\nconst int RENDER_DISTANCE = 64*4;\nconst float offset=1.4;\n\nmat3 getXRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( 1, 0, 0,\n                 0, c, s,\n                 0,-s, c);\n}\n\nmat3 getYRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( c, 0,-s,\n                 0, 1, 0,\n                 s, 0, c);\n}\n\nmat3 getZRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( c, s, 0,\n                -s, c, 0,\n                 0, 0, 1);\n}\n\nbool getVoxel(ivec3 pos){\n    //mock data\n    bool e=abs((pos.x-7)%100)<10 && abs(pos.y+54)<10;\n    bool ee=(abs(pos.x)>10 || abs(pos.y)>10)&& pos.z<-1;\n    bool eee=pos.x+pos.y+pos.z==50;\n    return pos.z<-3||e||ee||eee;\n}\n\n// z is upward\n// x is the view horizontal rotation axis\n// y is the vertical cam rotation axis and view rotation axis\n// z is the horizontal cam rotation axis\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalizing screen size to -0.5 to 0.5 being the biggest centered square that fit on screen\n    float screenRatio=min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    //input\n    vec3 camRot= vec3(0.,clamp(-iMouse.y/screenRatio,-1.,1.),2.*-iMouse.x/iResolution.x)*PI;\n    vec3 camPos= vec3(sin(iTime*0.2)*10.-15.,cos(iTime*0.2)*10.-15.,3.);\n    \n    vec3 cameraPlaneU = vec3(0, -offset, 0);\n\tvec3 cameraPlaneV = vec3(offset, 0, 0) * iResolution.y / iResolution.x;\n    vec3 ray= vec3(0,0,1);\n\tray = ray + uv.x * cameraPlaneU + uv.y * cameraPlaneV;\n    \n    ray= getXRotMat(camRot.x)*ray;\n    ray= getYRotMat(camRot.y)*ray;\n    ray= getZRotMat(camRot.z)*ray;\n    \n    \n    \n    vec3 raySign= sign(ray);\n    ivec3 iRaySign = ivec3(raySign);\n\n    /////// doing the voxel traversal from here /////////\n    \n    \n    ray = abs(ray);                             // abstracting sign away for simplicity                       \n                                                \n    vec3  rayInv=1./ray;                        // the whole iteration process is divided by ray, this allow for\n                                                // easy priority check\n    bvec3 move;\n    bool  hit= false;\n    \n    vec3  itr;                                  // itr= iterator ray\n    itr = 1.-fract(camPos*raySign+0.5);           // adjusting for abstracting the sign away + centering shenanigans\n                                                // the +1 make smaller values components of ray lose priority \n                                                //(as multiplied by rayinv, they will get very big)\n                                                \n    itr*= rayInv;                               // itr is converted to ratio of ray\n    vec3 itrStart=itr;\n    \n    ivec3 pos= ivec3(round(camPos));            // pos start on camera position\n    for(int step = 0; step < RENDER_DISTANCE; step++){\n        bvec3 pon=lessThan(itr.xyz,itr.yzx);    // pon=Priority Over Next component\n        \n        move.x=pon.x&& !pon.z;                  // the smaller component is the one that will hit a voxel face first\n        move.y=pon.y&& !pon.x;\n        move.z=!(move.x||move.y);               // if neither x or y has prio, then default to z, this break triple ties\n        \n        itr+=vec3(move)*rayInv;                 // update the distance by adding 1 voxel worth of distance\n        pos+=ivec3(move)*iRaySign;              // register the move in pos\n        \n        hit=getVoxel(pos);\n        if(hit){                                // stop if opaque\n           break;\n        }\n    }\n    vec3 col=vec3(0.5,0.6,0.9)*1.1;\n    if(hit){\n        col=1.0-fract(vec3(pos)*0.05);          // applying cube test color\n        \n        vec3 facevec= vec3(move);               // adding face normal vector\n        col= col-facevec*0.05;\n        \n        \n    }\n    vec3 ratios=vec3(move)*(itr-rayInv*vec3(move)); //probably more correct as its remove the last move but idk, doesnt fix it\n    vec3 intersec=ray*max(max(ratios.x,ratios.y),ratios.z);\n    float dist=distance(vec3(0.),intersec);\n    //dist=fract(dist);\n    float fogr=dist*0.01;\n    col=col*(1.-fogr)+fogr*vec3(0.5,0.6,0.9)*1.1;\n    \n    // output to screen\n    fragColor = vec4(col, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}