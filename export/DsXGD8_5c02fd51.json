{"ver":"0.1","info":{"id":"DsXGD8","date":"1666800667","viewed":339,"name":"Irradiance Environment Map","username":"H2ongzh","description":"1. Buffer A : Vanilla Monte Carlo Sampling for Irradiance Map (The first row, wrapped CubeMap)\n2. Buffer B : Spherical Harmonics (The second row)\ncite:  https://www.shadertoy.com/view/3tlBW7\nThanks for his brilliant idea for storing the SH matrix!!","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["sphericalharmonics","ibl","irradiancemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------------\n// I am writing this to compare the Spherical Harmonic Lighting with\n// the standard Monte Carlo method. The result looks nice. SH does\n// do a good job for low-frequency lights.\n// I really got some ideas from \"https://www.shadertoy.com/view/3tlBW7\"\n// Thanks for Alro's great work!\n//\n// Author: Hong Zhang\n// Date: 10/23/2022\n//-----------------------------------------------------------\n\n// sample the 2D texture by direction\nvec2 sampleEM(vec3 dir){\n    vec2 pt;\n    pt.y = acos(dir.y) / PI;\n    float sin_theta = sqrt(1. - dir.y * dir.y);\n    dir.z > 0. ? pt.x = acos(dir.x/sin_theta): (pt.x = 2.* PI - acos(dir.x/sin_theta));\n    pt.x /= (2. * PI);\n    return pt;\n}\n\n// evaluate the SH transformation\nvec3 evaluateSH(vec3 norm, vec2 fragCoord){\n    vec3 col;\n    mat4 m_r;\n    m_r[0] = texelFetch(iChannel1, ivec2(0, 0), 0);\n    m_r[1] = texelFetch(iChannel1, ivec2(0, 1), 0);\n    m_r[2] = texelFetch(iChannel1, ivec2(0, 2), 0);\n    m_r[3] = texelFetch(iChannel1, ivec2(0, 3), 0);\n    \n    mat4 m_g;\n    m_g[0] = texelFetch(iChannel1, ivec2(1, 0), 0);\n    m_g[1] = texelFetch(iChannel1, ivec2(1, 1), 0);\n    m_g[2] = texelFetch(iChannel1, ivec2(1, 2), 0);\n    m_g[3] = texelFetch(iChannel1, ivec2(1, 3), 0);\n    \n    mat4 m_b;\n    m_b[0] = texelFetch(iChannel1, ivec2(2, 0), 0);\n    m_b[1] = texelFetch(iChannel1, ivec2(2, 1), 0);\n    m_b[2] = texelFetch(iChannel1, ivec2(2, 2), 0);\n    m_b[3] = texelFetch(iChannel1, ivec2(2, 3), 0);\n    \n    vec4 n = vec4(norm, 1.);\n    \n    col.r = dot(n, m_r * n);\n    col.g = dot(n, m_g * n);\n    col.b = dot(n, m_b * n);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the uv\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv_i = floor(uv * 2.);\n    vec2 uv_f = fract(uv * 2.);\n    \n     // set the position of camera\n    vec3 cam_pos = vec3(0., 0., 3.);\n    cam_pos = rotateY(cam_pos, iTime);\n\n    // get the camera view \n    vec3 view = getCameraView(uv_f, iResolution.xy);\n    view = rotateY(view, iTime);\n    \n    if(uv_i.x == 0.){\n        // compute the intersections\n        vec3 p = getIntersection(cam_pos, view);\n        vec3 norm = queryNormal(p);\n        // get the intersection\n        // if there is no intersection\n        if(p == vec3(MaxV)){\n            vec2 pt = sampleEM(view);\n            fragColor = texture(iChannel1, pt);\n        }\n        else{  // sample from bufferA\n            if(uv_i.y == 1.){\n                vec2 pt = sampleEM(norm);\n                fragColor = texture(iChannel0, pt);\n            }\n            else{ // evaluate SH from bufferB \n                fragColor = vec4(evaluateSH(norm, fragCoord), 1.);\n            }\n        }\n    \n    }\n    else{\n        if(uv_i.y == 1.){\n            fragColor = texture(iChannel0, vec2(uv_f.x, 1. - uv_f.y));\n        }\n        else{\n            vec3 dir;\n            float phi = uv_f.x * 2. * PI;  // the x axis of the irradiance map represent phi \n            float theta = (1. - uv_f.y) * PI; // y axis stands for theta\n\n            dir.x = sin(theta) * cos(phi);\n            dir.z = sin(theta) * sin(phi);\n            dir.y = cos(theta);\n            fragColor = vec4(evaluateSH(dir, fragCoord), 1.);//texture(iChannel1, vec2(uv_f.x, 1. - uv_f.y));\n        }\n    }\n    fragColor = vec4(Gramma(fragColor.xyz), 1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//-----------------------------------------------------------\n// Vanilla Monte Calro Sampling for Irradiance Map (low frequency lighting)\n// Author: Hong Zhang\n// Date: 10/23/2022\n//-----------------------------------------------------------\n#define IS_MONTE_CARLO\n\n// uniform sampling on the hemisphere of the surface\nvec3 uniSampHemi(vec2 uv, vec3 norm){\n    float phi = uv.x * 2. * PI;\n    float cos_theta = 1. - uv.y;\n    float sin_theta = sqrt(1. - cos_theta * cos_theta);\n   \n    \n    float x = sin_theta * cos(phi);\n    float y = sin_theta * sin(phi);\n    float z = cos_theta;\n    \n    // refers to the function in the 'Common' tab, which I found is good to reach a smooth result\n    // cite: https://www.shadertoy.com/view/MsXBzl\n    vec3 up = stepValue3(0.9999, norm.z, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    vec3 b1 = normalize(cross(up, norm));\n    vec3 b2 = cross(norm, b1);\n\n    //float sign_n = norm.z < 0.?  -1. : 1.;\n    //float a = -1./(sign_n + norm.z);\n    //float b = norm.x * norm.y * a;\n    //vec3 b1 = vec3(1. + sign_n * norm.x * norm.x * a, sign_n * b, -sign_n * norm.x);\n    //vec3 b2 = vec3(b, sign_n + norm.x * norm.y * a, -norm.y);\n    \n    return b1 * x + b2 * y + norm * z;\n    \n}\n\n\n// use the Monte Carlo Sampling method to get the irradiance Map \nvec3 irradianceMap(vec2 uv){\n    // compute the current normal, we use the direction of the normal to access the irradiance map\n    vec3 norm;\n    float phi = uv.x * 2. * PI;  // the x axis of the irradiance map represent phi \n    float theta = uv.y * PI; // y axis stands for theta\n    \n    norm.x = sin(theta) * cos(phi);\n    norm.z = sin(theta) * sin(phi);\n    norm.y = cos(theta);\n    \n    // Monte Carlo\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < numOfSamples; i += 1.){\n        vec2 pt = hammersley(i, numOfSamples);\n        vec3 l_i = uniSampHemi(pt, norm);\n        vec3 light = texture(iChannel1, l_i).rgb;\n        light = LinearSpace(light);\n        float ndotl = saturate(dot(l_i, norm));\n        col += light * ndotl;\n        \n    }\n    \n    col = 2. * col / numOfSamples;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    bool run = (iFrame == 0) || (iFrame == 10);    \n    \n    if(run){\n        vec3 col;\n        col =  irradianceMap(uv);\n        fragColor = vec4(col, 1.0);\n    }\n    else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0); // take the last frame\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------\n// Some common functions and data structure\n// Author: Hong Zhang\n//-----------------------------------------------------------\n\n#define PI 3.14159265358979323846\n#define FOV 60.\n#define Rad(x) x * PI / 180.\n#define MaxV 1e10\n#define Thre 1e-4\n#define Gramma(x) pow(x, vec3(1./2.2))\n#define LinearSpace(x) pow(x, vec3(2.2))\n\n#define numOfSamples 1024.\n\n//-----------------------------------------------------------\n// define the Object information and the Camera\n//-----------------------------------------------------------\n// object information \n#define sphereR 1.\n\n// define the material\nstruct Material {\n    vec3 albedo;\n    float reflectance;\n    float metallic;\n    float roughness;\n};\n\n// compute the camera view\nvec3 getCameraView(vec2 uv, vec2 resolution){\n    uv = (uv - 0.5) * 2.;\n    float h = tan(Rad(FOV)/2.);\n    float w = h * (resolution.x / resolution.y);\n    return normalize(vec3(w * uv.x, h * uv.y, -1.));\n} \n\n//-----------------------------------------------------------\n// Math \n//-----------------------------------------------------------\n// clamp the float value to [0., 1.]\nfloat saturate(float x){\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x){\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\n// rotate the dir \nvec3 rotateY(vec3 dir, float time){\n    float rate = time/2.;\n    mat3 rot = mat3(\n        cos(rate), 0., sin(rate),\n        0.       , 1., 0,\n        -sin(rate), 0., cos(rate)\n    );\n    return rot * dir;\n}\n\n// cite: https://www.shadertoy.com/view/MsXBzl\nvec3 stepValue3(float a, float b, vec3 ra, vec3 rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n//-----------------------------------------------------------\n// Signed Distance Field for constructing the object\n//-----------------------------------------------------------\n\n// define the SDF for sphere\nfloat sphereSDF(vec3 p, float radius){\n    return length(p) - radius;\n}\n\n// query the distance \nfloat querySDF(vec3 p){\n    return sphereSDF(p, sphereR);\n}\n\n// query the normal\nvec3 queryNormal(vec3 p){\n    vec3 norm = vec3(querySDF(p + vec3(Thre, 0., 0.)) - querySDF(p - vec3(Thre, 0., 0.)),\n                querySDF(p + vec3(0., Thre, 0.)) - querySDF(p - vec3(0., Thre, 0.)),\n                querySDF(p + vec3(0., 0., Thre)) - querySDF(p - vec3(0., 0., Thre)));\n    return normalize(norm);\n}\n\n// compute the intersection by Ray Marching\nvec3 getIntersection(vec3 o, vec3 dir){\n    int maxIteration = 50;\n    vec3 p = o;\n    float dist = 0.;\n    for(int i = 0; i < maxIteration; i+=1){\n        dist = querySDF(p);\n        if(dist < Thre) \n            return p;\n        p += dir * dist;\n    }\n    return vec3(MaxV);\n}\n\n\n\n//-----------------------------------------------------------\n// Random Variable Generator\n//-----------------------------------------------------------\n\n// Hammersley Sequences\nvec2 hammersley(float n, float N){\n    uint temp = uint(n);\n    temp = ((temp & 0xFFFF0000u) >> 16u) | ((temp & 0x0000FFFFu) << 16u);\n    temp = ((temp & 0xFF00FF00u) >> 8u) | ((temp & 0x00FF00FFu) << 8u);\n    temp = ((temp & 0xF0F0F0F0u) >> 4u) | ((temp & 0x0F0F0F0Fu) << 4u);\n    temp = ((temp & 0xCCCCCCCCu) >> 2u) | ((temp & 0x33333333u) << 2u);\n    temp = ((temp & 0xAAAAAAAAu) >> 1u) | ((temp & 0x55555555u) << 1u);\n    float y = float(temp) * 2.3283064365386963e-10; \n    return vec2(n/N, y);\n}\n\n//-----------------------------------------------------------\n// Physically Based Shading Functions\n//-----------------------------------------------------------\n\n// Fresnel Schlick Approximation\nvec3 FSchlick(vec3 f0, float vdoth){\n    return f0 + (1. - f0) * pow((1. - vdoth), 5.);\n}\n\n// GGX Normal Distribution\n// inputs: ndoth: cos<normal, half-normal>\n//         r: roughness\n//                       r ^ 2\n// GGX = ----------------------------------------\n//        PI * (<n, h> ^ 2 * (r ^ 2 - 1) + 1) ^ 2  \nfloat GGX(float ndoth, float r){\n    float r2 = r * r;\n    float denom = ndoth * ndoth * (r2 - 1.) + 1.;\n    return r2 / (PI * denom * denom);\n}\n\n// Height Corrected Smith Mask/Shadowing Function\nfloat HeightCorrectedSmith(float ndotv, float ndotl, float r){\n    float r2 = r * r;     \n    float GGX_L = ndotv * sqrt((-ndotl * r2 + ndotl) * ndotl + r2);     \n    float GGX_V = ndotl * sqrt((-ndotv * r2 + ndotv) * ndotv + r2);    \n    return 2. * ndotv * ndotl / (GGX_L + GGX_V);\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//-----------------------------------------------------------\n// Spherical Harmonic (L<=2, 9 coeffcients) Lighting for Irradiance Map (low frequency lighting)\n// Author: Hong Zhang\n// Date: 10/23/2022\n//-----------------------------------------------------------\n\n// [1] https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n// I directly copy these constant numbers for the SH transformation from paper [1]\n\n// const normalized factor for SH base functions\n// l:1                   0.282095\n// l:2          0.488603 0.488603 0.488603\n// l:3 1.092548 1.092548 0.315392 1.092548 0.546274\nconst float f00 = 0.282095;\nconst float f1n = 0.488603; // f1-1 = f10 = f11\nconst float f2n = 1.092548; // f2-2 = f2-1 = f21 \nconst float f20 = 0.315392;\nconst float f22 = 0.546274;\n\n// After transforming the clamped cosin term to SH bases,  we can get a set of coeffients A = {A0, A1, A3, ...}\n// combine the normalized factor with A.\n// please check the equation [12] in the paper [1].\nconst float c1 = 0.429043;\nconst float c2 = 0.511664;\nconst float c3 = 0.743125;\nconst float c4 = 0.886227;\nconst float c5 = 0.247708;\n\n\n// uniform sampling on the hemisphere of the surface\nvec3 uniSampleSphere(vec2 uv, vec3 norm){\n    float phi = uv.x * 2. * PI;\n    float cos_theta = cos(2. * acos(sqrt(1. - uv.y)));\n    float sin_theta = sqrt(1. - cos_theta * cos_theta);\n   \n    \n    float x = sin_theta * cos(phi);\n    float y = sin_theta * sin(phi);\n    float z = cos_theta;\n    \n    // refers to the function in the 'Common' tab, which I found is good to reach a smooth result\n    // cite: https://www.shadertoy.com/view/MsXBzl\n    vec3 up = stepValue3(0.999, norm.z, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    vec3 tangent = normalize(cross(up, norm));\n    vec3 bitangent = cross(norm, tangent);\n\n    return tangent * x + bitangent * y + norm * z;\n    \n}\n\n// SH transformation\nvec4 SHTrasform(vec2 uv, vec2 fragCoord){\n    // compute the current normal, we use the direction of the normal to access the irradiance map\n    vec3 norm;\n    float phi = uv.x * 2. * PI;  // the x axis of the irradiance map represent phi \n    float theta = uv.y * PI; // y axis stands for theta\n    \n    norm.x = sin(theta) * cos(phi);\n    norm.z = sin(theta) * sin(phi);\n    norm.y = cos(theta);\n  \n    vec4 col = vec4(0.);\n    col = texture(iChannel1, norm);\n    col.xyz = LinearSpace(col.xyz);\n  \n    \n    // define nine coeffients for SH bases\n    vec3 l00 = vec3(0.);\n    vec3 l11 = vec3(0.);\n    vec3 l10 = vec3(0.);\n    vec3 l1_1 = vec3(0.);\n    vec3 l20 = vec3(0.);\n    vec3 l2_1 = vec3(0.);\n    vec3 l2_2 = vec3(0.);\n    vec3 l22 = vec3(0.);\n    vec3 l21 = vec3(0.);\n    \n    \n    for(float i = 0.; i < numOfSamples; i += 1.){\n        vec2 pt = hammersley(i, numOfSamples);\n        vec3 l_i = uniSampleSphere(pt, vec3(0., 1., 0.));\n\n        \n        vec3 light = texture(iChannel1, l_i).rgb;\n        light = LinearSpace(light);\n        \n        // compute the coeffients of lights\n        l00 += light * f00;\n        \n        l10 += light * f1n * l_i.z;\n        l1_1 += light * f1n * l_i.y;\n        l11 += light * f1n * l_i.x;\n        \n        l2_1 += light * f2n * l_i.y * l_i.z;\n        l21 += light * f2n * l_i.x * l_i.z;\n        l2_2 += light * f2n * l_i.x * l_i.y;\n        \n        l20 += light * f20 * (3. * l_i.z * l_i.z - 1.);\n        l22 += light * f22 * (l_i.x * l_i.x - l_i.y * l_i.y);\n    }\n    \n    l00 *= 4. / numOfSamples;   // PI is cancelled by the constant term \"albedo/PI\", albedo can be specified, when you evaluate the SH\n    l1_1 *= 4. / numOfSamples;\n    l11 *=  4. / numOfSamples;\n    l10 *=  4. / numOfSamples;\n    l2_1 *=  4. / numOfSamples;\n    l21 *=  4. / numOfSamples;\n    l2_2 *= 4. / numOfSamples;\n    l20 *=  4. / numOfSamples;\n    l22 *=  4. / numOfSamples;\n    \n    \n    // we can encode matrix into the bufferB by obversing the equation [12] in the paper [1]\n    \n    if(fragCoord.x == 0.5){\n        mat4 m_r;\n        m_r[0] = vec4(c1*l22.r, c1*l2_2.r, c1*l21.r, c2*l11.r);\n        m_r[1] = vec4(c1*l2_2.r, -c1*l22.r, c1*l2_1.r, c2*l1_1.r);\n        m_r[2] = vec4(c1*l21.r, c1*l2_1.r, c3*l20.r, c2*l10.r);\n        m_r[3] = vec4(c2*l11.r, c2*l1_1.r, c2*l10.r, c4*l00.r - c5*l20.r);\n        \n        int i = int(fragCoord.y - 0.5);\n        if(i <= 3){\n            col = m_r[i];\n        }\n     }\n     \n    if(fragCoord.x == 1.5){\n        mat4 m_g;\n        m_g[0] = vec4(c1*l22.g, c1*l2_2.g, c1*l21.g, c2*l11.g);\n        m_g[1] = vec4(c1*l2_2.g, -c1*l22.g, c1*l2_1.g, c2*l1_1.g);\n        m_g[2] = vec4(c1*l21.g, c1*l2_1.g, c3*l20.g, c2*l10.g);\n        m_g[3] = vec4(c2*l11.g, c2*l1_1.g, c2*l10.g, c4*l00.g - c5*l20.g);\n\n        int i = int(fragCoord.y - 0.5);\n        if(i <= 3){\n            col = m_g[i];\n        }\n    }\n    \n    if(fragCoord.x == 2.5){\n        mat4 m_b;\n        m_b[0] = vec4(c1*l22.b, c1*l2_2.b, c1*l21.b, c2*l11.b);\n        m_b[1] = vec4(c1*l2_2.b, -c1*l22.b, c1*l2_1.b, c2*l1_1.b);\n        m_b[2] = vec4(c1*l21.b, c1*l2_1.b, c3*l20.b, c2*l10.b);\n        m_b[3] = vec4(c2*l11.b, c2*l1_1.b, c2*l10.b, c4*l00.b - c5*l20.b);\n        \n        int i = int(fragCoord.y - 0.5);\n        if(i <= 3){\n            col = m_b[i];\n        }\n    }\n       \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    bool run = (iFrame == 0)|| (iFrame == 10);    \n    \n    if(run){\n        vec4 col = SHTrasform(uv, fragCoord);\n        fragColor = vec4(col);\n    }\n    else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0); // take the last frame\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}