{"ver":"0.1","info":{"id":"4lVSDW","date":"1484393809","viewed":163,"name":"OJ - Fibber 28, scene 6","username":"rammoskar","description":"Full demo: https://www.youtube.com/watch?v=kw5uLHZiRpY\nSome minor differences from the original","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","morph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\n#define MAT_MORPH 16.0\n#define MAT_S6_WATER 19.0\n\n#define EPS 0.01\n\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\n\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\n\nvec2 water_6(vec3 p, vec3 rd)\n{\n\t/*float t = mod(iTime,30.0); //tick - SCENE_2;\n\tif(rd.y > 0.0){\n\t\treturn vec2(999999, MAT_S6_WATER);\n\t}\n\t\n\tfloat d = (sin(p.x + tick*0.5) + sin(p.z  + tick*0.5)) * 0.1;// + \n\t//length(texture(noiseP, p.xz*0.5 + vec2(0, tick*0.1)))*0.1 + \n\t//length(texture(noiseP, p.xz*0.5 + vec2(tick*0.13, 0)))*0.1;\n\td *= 0.1;\n\n\tfloat h = p.y - d * 0.1;\n\t\n\tfloat dis = (0.1 -p.y)/rd.y;\n\n\treturn vec2(max(h, dis), MAT_S6_WATER);*/\n    return vec2(p.y,MAT_S6_WATER);\n}\n\n\n\nbool inRefraction = false;\n\n\n\nvec2 scene(vec3 po, vec3 rd)\n{\n\tfloat tic = mod(iTime,30.0); \n\tvec3 cm = vec3(5);\n\tvec3 q = mod(po, cm)-0.5*cm;\n\tfloat dis = length(po.xz);\n\tvec3 p = vec3(q.x, po.y - min(0.0, tic * 1.5 - dis), q.z);\n\n\tfloat a = sdBox(p, vec3(1.0));\n\tfloat b = sdTorus(p, vec2(1,0.3));\n\tfloat c = min(sdTorus(p - vec3(2,0,0), vec2(1,0.3)), sdTorus(p + vec3(2,0,0), vec2(1,0.3)));\n\tfloat d = sphere(p, 1.0);\n\t\n\tfloat t = 5.0;\n\tfloat ti = tic - sqrt(po.x*po.x + po.z*po.z) * 0.7; \n\t\n\tfloat t1 = smoothstep(t*0.0, t*1.0, ti);\n\tfloat t2 = smoothstep(t*1.0, t*2.0, ti); \n\tfloat t3 = smoothstep(t*2.0, t*3.0, ti);\n\t\n\tfloat res = a*(1.0-t1) + b*t1*(1.0-t2) + c*t2*(1.0- t3) + d*t3;\n\t\n\treturn sunk(water_6(po - vec3(0, -1, 0), rd), vec2(res, MAT_MORPH), 0.8);\n}\n\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n\n\n\n#define jumps 2\n#define imax 600\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 eye = vec3(0);\n\tvec3 light = vec3(0);\n\tvec3 tar = vec3(0);\n\tfloat lightInvSize = 0.5;\n\tfloat shadowAmbient = 0.3;\n\tfloat lightIntensity = 0.004;\n\t\n\n\tfloat refJumpDistance = 0.02;\n\n\n\n\tbool cubicDis = false;\n\tvec3 rollV = vec3(0, 1, 0);\n\tfloat time = mod(iTime,30.0);\n    if (time < 15.0) {\n        eye = vec3(sin(time * 0.3) * 10.0, 3.0, cos(time * 0.3) * 10.0);\n        light = eye + vec3(0, 3, 0);\n    } else {\n        eye = vec3(sin(time * 0.3) * 10.0, 3.0, cos(time * 0.3) * 10.0);\n        eye += vec3(0, 0, time - 15.0);\n        tar = mix(vec3(0.0), eye + vec3(0.0, -0.5, -1.0), smoothstep(0.0, 10.0, time - 15.0));\n    }\n    light = tar + vec3(sin(time * 0.5) * 3.0, 3.0, cos(time * 0.5) * 3.0);\n\n\n\n    lightIntensity = 0.001;\n    lightInvSize = 100.0;\n    float tmax = 70.0;\n    cubicDis = true;\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(rollV, dir)); \n \tvec3 up = cross(dir, right);\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x); \n\n    vec3 color = vec3(0.0);\n      \n    float t = 0.0;\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\t\n\tfloat ref = 1.0;\n\tfloat lightAura = 0.0;\n    float breakVar = 0.0;\n\tfor(int j = 0; j < jumps; ++j)\n    {\n        if (breakVar > 0.5) {\n            break;\n        }\n    \tt = 0.0;\n    \t for(int i = 0; i < imax; ++i)\n   \t\t {\n             if (t >= tmax) {\n             \tbreak;\n             }\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t\t\t\n\t\t\t\n\t        if(d < EPS || i == imax || t >= tmax) //d < 0.001 \n\t        {\n\t        \tvec3 x0 = light;\n\t        \tvec3 x1 = ro;\n\t        \tvec3 x2 = ro + rd;\n\t        \tfloat ldis = pow(length(cross(x2 - x1, x1 - x0)),2.0) / pow( distance(x2, x1), 2.0); \n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\t\n\t\t\t\tvec3 invLight = normalize(light - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tvec3 refrd = reflect(rd, normal);\n\t        \t\n\n\t        \tvec3 n = floor(p);\n\t\t\t\tvec3 c = vec3(0.5);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t if (m == MAT_MORPH) {\n\t\t\t\t\tvec3 pc = p + vec3(90);\n\t        \t\tvec3 matCol = vec3(pc.x/10.0, (pc.x + pc.z) / 5.0, pc.z/8.0);\n\t        \t\tc = (sin(matCol) + 1.0) * 0.5;\n\t\t\t\t} else if (m == MAT_S6_WATER) {\n\t\t\t\t\tc = vec3(0.6, 0.6, 1.0);\n\t\t\t\t}\n\t\t\t\t\n\t        \t\n\t        \t\n                c = 0.7*c* (1.0 + diffuse);\n\n                c += specular(normal, -invLight, normalize(eye - p), 70.0);\n\t        \t\n\t            \n\t            float dis = length(light - p);\n\t            float disFact = 1.0 / (1.0 + lightIntensity*dis*dis * (cubicDis ? dis : 1.0 ));\n\t            c *= disFact;\n\t\t\t\t\n\t\t\t\t\t        \t\n\t        \tfloat tl = -dot(x1 - x0, x2 - x1)/pow(distance(x2,x1), 2.0);\n\t        \t\n\t        \tlightAura = max(lightAura, 1.0/(0.01 + lightInvSize*ldis));\n\n\n\t\t\t\tcolor = mix(color, c, ref);\n\t\t\t\t\n\t\t\t\tif( m == MAT_S6_WATER){\n\t\t\t\t\t\n                    rd = reflect(rd, normal);\n                    ro = p + rd*0.02;\n\n\t\t\t\t} else {\n\t\t\t\t\trd = reflect(rd, normal);\n\t         \t\tro = p + rd*refJumpDistance;\n\t\t\t\t}\n\t        \t\n\t        \tif (m == MAT_S6_WATER) {\n\t\t\t\t\tref *= 0.8;\t        \t\n\t       \t\t} else if (m == MAT_MORPH) {\n\t        \t\tref *= 0.4;\n\t        \t} else {\n\t\t        \tref = 0.0;\n\t        \t}\n\t        \tif (ref <= 0.01) {\n\t\t\t\t\tbreakVar = 1.0;\t        \t\t\n\t        \t}\n\t           \tbreak;\n\t        }\n\t\n\t        t += d;\n    \t}\n    }\n    \n   \n    fragColor = vec4(color + vec3(lightAura),  1.0); \n}\n\n  ","name":"Image","description":"","type":"image"}]}