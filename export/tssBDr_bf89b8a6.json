{"ver":"0.1","info":{"id":"tssBDr","date":"1588086504","viewed":345,"name":"Mandelbrot & Logistic Map","username":"Observer","description":"Experiment to store large voxel map by using the Cube A texture. Inspired by this video https://www.youtube.com/watch?v=ovJcsL7vyrk.\nShows relationship between Mandelbrot and Logistic Map in 1024x1024x648 voxels.\nMousable!","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","logistic","bifurcation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float HALFPI = acos(0.0);\nconst float PI = HALFPI * 2.0;\nconst float MINDIST = 0.001;\nconst float MAXDIST = 1000.0;\nconst vec3 AMBIENT = vec3(0.01, 0.01, 0.01);\nconst float REFL = 0.3;\nconst float MAXITER = 2.0;\n\nstruct Ray{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Camera{\n    vec3 from;\n    vec3 at;\n    vec3 up;\n    float aper;\n\n    vec3 look;\n    vec3 hor;\n    vec3 ver;\n};\n\nfloat hash12n(in vec2 p) {\n    p = fract(p * vec2(3123.3937, 5251.4321));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y * 95.4323);\n}\n\nCamera getCamera() {\n    Camera camera;\n    \n    bool down = dot(iMouse.xy, iMouse.zw) > 0.01;\n    float t = smoothstep(-0.8, 0.8, sin(iTime * 1.0));\n    float ta = t * HALFPI;\n    float r = mod(iTime, 20.0) > 10.0 ? 1.0 : 0.0;\n    float ra = iTime;\n    \n    float dst = down ? 5.0 : 2.0 * r + 1000.0 * (1.0 - r);\n    camera.from = down \n        ? vec3(dst * cos(iMouse.x * PI * 2.0 / iResolution.x) * cos(iMouse.y * PI * 0.6 / iResolution.y),\n        \tdst * sin(iMouse.x * PI * 2.0 / iResolution.x) * cos(iMouse.y * PI * 0.6 / iResolution.y),\n        \t0.01 + dst * sin(iMouse.y * PI * 0.6 / iResolution.y)) \n       \t: vec3(-1.0, sin(ta)*dst, cos(ta)*dst) * (1.0 - r) + \n            vec3(cos(ra)*dst, sin(ra)*dst, 2.0) * r;\n    \n    camera.up = down ? vec3(0.0, 0.0, 1.0) : vec3(0.0, -cos(ta), sin(ta)) * (1.0 - r) + vec3(0.0, 0.0, 1.0) * r;\n    for (int n = 0; n < 2; n++)\n    {\n        camera.at = vec3(-1.0, 0.0, 0.0);\n        camera.aper = 1.0 / dst;\n        camera.look = camera.at - camera.from;\n        float dmin = length(camera.look);\n        float hsize = camera.aper * dmin, vsize = hsize;\n        if (hsize * iResolution.x / iResolution.y > vsize)\n            hsize = vsize * iResolution.x / iResolution.y;\n        else\n            vsize = hsize * iResolution.y / iResolution.x;\n        camera.hor = normalize(cross(camera.look, camera.up)) * hsize;\n        camera.ver = normalize(cross(camera.hor, camera.look)) * vsize;\n        camera.up = camera.ver / vsize;\n    }\n\n    return camera;\n}\n\nRay getCameraRay( in Camera camera, in vec2 fragCoord ) {\n    Ray ray;\n    ray.ro = camera.from;\n    ray.rd = normalize(camera.look +\n            (fragCoord.x / iResolution.x * 2.0 - 1.0) * camera.hor +\n            (fragCoord.y / iResolution.y * 2.0 - 1.0) * camera.ver);\n    return ray;\n}\n\nfloat map( in ivec3 pos, out vec3 nrm )\n{\n    vec3 rd;\n    vec4 pixel;\n    uint pat1, pat2;\n    uvec4 field;\n    \n    // There are 6 planes of 1024x512 double pixels\n    // Each double pixel contains 2x 4x14 bits = 112 bits\n    // Using 6 planes a total z of 672 bits\n    // Of each pixel we use 13+14+14+13 = 54 bits as voxels\n    // The outer bits (0 and 55) are neighbor voxels used for normal calculation\n    // Because of symmetry, the Y-axis is mirrored\n    // So we can effectively display a voxel array of 1024x1024x648 (on/off-) voxels\n    int plane = pos.z / 108;\n\n    // Even or odd part of the double pixel\n    int index1 = (pos.z % 108) / 54, index2 = 1 - index1;\n\t\n    // Bit number in 4x14 bit color components\n    // but without the outer bits (bit 0 and bit 55),\n    // they are used for normal calculation\n    int pz = pos.z % 54 + 1;\n\n    // Mirror Y over the X-axis, it is symmetric in Y\n    int y1 = abs(1024 - pos.y * 2);\n\n    // Check z-column lookup (for performance)\n    rd = coordToRayDir(vec2(pos.x, y1 / 8 + 896), 5);\n    pixel = texture(iChannel0, rd);\n    pat1 = packHalf2x16(pixel.rg);\n    pat2 = packHalf2x16(pixel.ba);\n    if (pat1 == 0u && pat2 == 0u) return 0.0;\n    field = uvec4(pat1, pat1 >> 16, pat2, pat2 >> 16);\n    if ((field[(y1 / 8) % 4] & (1u << uint(plane * 2 + index1))) == 0u) return 0.0;\n\n    // Check voxel\n    int xx = pos.x;\n    int yy = pos.y * 2 + index1;\n    yy = yy > K ? yy-K : K-yy;\n    rd = coordToRayDir(vec2(xx, yy), plane);\n    pixel = texture(iChannel0, rd);\n    pat1 = packHalf2x16(pixel.rg);\n    pat2 = packHalf2x16(pixel.ba);\n    field = uvec4(pat1, pat1 >> 16, pat2, pat2 >> 16);\n\tif (((field[pz / 14] >> uint(pz % 14)) & 1u) == 0u) return 0.;\n    \n\t// Calculate translucency and normal   \n    float f = 0.;\n    nrm = vec3(.0, .0, 1E-6);\n    \n    // Calculate scale in z-dir (up/down)\n    float zScale = fK / 648. * (BOXMAX.z - BOXMIN.z) / (BOXMAX.x - BOXMIN.x);\n    \n    // Visit voxels arround the found voxel in [-2..+2, -2..+2, -1..+1] range (75 pixels)\n    for (int y = -1; y <= 1; y++)\n    {\n        // Mirror Y over the X-axis, it is symmetric in Y\n        int y1 = abs(1024 - (pos.y + y) * 2);\n        int y2 = abs(1024 - (pos.y + y) * 2 - 1);\n        \n        for (int x = -1; x <= 1; x++)\n        {\n            int xx = pos.x + x;\n            \n            rd = coordToRayDir(vec2(xx, y1 * index2 + y2 * index1), plane);\n            pixel = texture(iChannel0, rd);\n            pat1 = packHalf2x16(pixel.xy);\n            pat2 = packHalf2x16(pixel.zw);\n            field = uvec4( pat1, pat1 >> 16, pat2, pat2 >> 16 );\n            \n            for (int z = -1; z <= 1; z++)\n            {\n            \tfloat px = float((field[(pz + z) / 14] >> uint((pz + z) % 14)) & 1u);\n                f += px;\n                nrm += px * vec3(float(x), float(y), float(z) * zScale);\n            }\n        }\n    }\n    \n    nrm = -normalize(nrm);\n    return clamp(f / 500.0, 0.1, 1.0);\n}\n\nconst float SAMPLEX = 2.0;\nconst float SAMPLEY = 2.0;\n\nfloat mapLogistic( in vec2 fragCoord )\n{\n    float f2 = 0.0;\n    for (float smpx = 0.0; smpx < SAMPLEX; smpx += 1.0) \n    {\n        for (float smpy = 0.0; smpy < SAMPLEX; smpy += 1.0)\n        {\n            float x = fragCoord.x + smpx * 0.01 / SAMPLEX;\n    \t\tfloat y = fragCoord.y + smpy * 0.01 / SAMPLEY;\n    \n            vec2 z = vec2(0.0);\n            for (int i = 0; i < INITIAL_ITERATIONS; i++)\n            {\n                z = vec2(z.x * z.x - z.y * z.y + x, 2.0 * z.x * z.y);\n            }    \n\n            float f = 0.0;\n            for (int i = INITIAL_ITERATIONS; i < LOGMAP_ITERATIONS; i++)\n            {\n                z = vec2(z.x * z.x - z.y * z.y + x, 2.0 * z.x * z.y);\n                float h = (calcZ(z) - ZMIN) * (BOXMAX.z - BOXMIN.z) / (ZMAX - ZMIN) + BOXMIN.z;\n                f += exp(-1000000.0 * (h - y) * (h - y));\n            }\n            f2 += clamp(f, 0.0, 1.0);\n        }\n    }\n    return f2 / SAMPLEX / SAMPLEY;\n}\n\nivec3 getVoxelCoord( in vec3 pos )\n{\n    return ivec3((pos - BOXMIN) * vec3(K, K, 648.) / (BOXMAX - BOXMIN));\n}    \n\n\nvec3 calcVoxelBox( inout Ray ray, in float dmin, in float dmax, in float lmap, out float total ) \n{  \n\tdmin = max(0.0, dmin);\n\n    vec2 px1;\n    ivec3 lvox = ivec3(0);\n    ivec3 p1 = getVoxelCoord(ray.ro + dmin * ray.rd);\n    ivec3 p2 = getVoxelCoord(ray.ro + dmax * ray.rd);\n    int steps = max(max(abs(p2.x - p1.x), abs(p2.y - p1.y)), abs(p2.z - p1.z)) * 3 / 2;\n    float f1 = (dmax - dmin) / float(steps);\n\n    total = 0.;\n    vec3 sum = vec3(0.);\n    float lasty = ray.ro.y;\n    \n    for (int n = 0; n < steps; n++)\n    {\n        float d = dmin + float(n) * f1;\n        vec3 pos = ray.ro + d * ray.rd;\n        ivec3 vox = getVoxelCoord(pos);\n\n        // Apply logistic function when crossing -y to +y\n        if (lasty * pos.y < 1E-12)\n        {\n            sum += lmap * vec3(0.9, 0.8, 0.2);\n            total += lmap;\n            if (total > 1.5)\n                break;\n        }\n\n        if (vox != lvox)\n        {\n            lvox = vox;\n            vec3 nrm;\n            float f = map( vox, nrm );\n            float i = max(0.0, dot(nrm, normalize(LIGHT - pos)));\n            sum += f * (i * vec3(0.8, 0.4, 0.1) + pow(i, 20.0));\n            total += f;\n            if (total > 1.5)\n                break;\n        }\n        lasty = pos.y;\n    }\n    return sum;\n}\n\nvec3 render(inout Ray ray) {\n    vec3 result = vec3(0.0);\n\n    // Mouse & animation\n    bool down = dot(iMouse.xy, iMouse.zw) > 0.01;\n    float t = down ? 0.0 : smoothstep(-0.8, 0.8, sin(iTime * 1.0));\n    float ta = t * HALFPI;\n    float r = mod(iTime, 20.0) > 10.0 || down ? 1.0 : 0.0;\n    float ra = iTime;\n\n    // Collecting pixel info\n    vec3 sum = vec3(0.);\n    float total = 0.0;\n\n    // Logistic map\n    float lmap = 0.0;\n    float k = -ray.ro.y / ray.rd.y;\n    vec2 posg = ray.ro.xz + k * ray.rd.xz;\n    if (abs(posg.x) < 2.0 && abs(posg.y) < 3.0)\n    {\n    \tlmap = mapLogistic(posg);\n    }\n\n    // Background\n    vec3 backgr = vec3(0.15) * (1.0 - r) + texture(iChannel1, ray.rd.xzy).rgb * r;\n\n    // Voxel box\n    vec3 dA = (BOXMIN - ray.ro) / ray.rd;\n    vec3 dB = (BOXMAX - ray.ro) / ray.rd;\n    float dmin = max(max(min(dA.x, dB.x), min(dA.y, dB.y)), min(dA.z, dB.z));\n    float dmax = min(min(max(dA.x, dB.x), max(dA.y, dB.y)), max(dA.z, dB.z));\n\n    // Inside voxel box?\n    if (dmin > dmax)\n    {\n        sum = lmap * vec3(0.9, 0.8, 0.2);\n        return (1.0 - lmap) * backgr + sum;\n    }\n\n    sum = calcVoxelBox(ray, dmin, dmax, lmap, total);\n    vec3 fragColor = (1.0 - total) * backgr + sum;\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Camera camera = getCamera();\n    vec3 color = vec3(0.0);\n    \n    int precalcFrames = INITIAL_ITERATIONS / ITERATIONS_PER_FRAME + SKIP_FRAMES + 6;\n    if (iFrame <= precalcFrames) return;\n    \n    Ray ray = getCameraRay(camera, fragCoord);\n    fragColor.rgb = render(ray);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Memory sizes\nconst int K = 1024;\nconst int M = K*K;\nconst float fK = float(K);\nconst float fM = float(M);\n\nconst vec3 BOXMIN = vec3(-2.0, -1.3, -1.0);\nconst vec3 BOXMAX = vec3(.6, 1.3, 1.0);\n\nconst float ZMIN = 1.1;\nconst float ZMAX = -1.6;\n\nconst int SKIP_FRAMES = 10;\nconst int INITIAL_ITERATIONS = 300;\nconst int ADDITIONAL_ITERATIONS = 10;\nconst int ITERATIONS_PER_FRAME = 100;\nconst int LOGMAP_ITERATIONS = 800;\n\n// Y-coord where the octree starts in plane 5\nconst int YOFFS = 896;\n\nconst vec3 LIGHT = normalize(vec3(1.5, 3.0, 10.0));\n\n#define BITS_PER_COMP 14                      // Effective usable bits a low precision float (16 bit)\n#define BITS_PER_PIXEL (4 * BITS_PER_COMP)    // 4 components: r, g, b, a\n\n// Calculate rayDir based on plane and position [-1 .. +1])\nvec3 planeToRayDir(in int plane, vec2 pos) {\n    return\n        plane == 0 ? vec3(-1.0, -pos.y, pos.x) :\n        plane == 1 ? vec3( pos.x, -1.0, -pos.y) :\n        plane == 2 ? vec3(-pos.x, -pos.y, -1.0) :\n        plane == 3 ? vec3( 1.0, -pos.y, -pos.x) :\n        plane == 4 ? vec3( pos.x,  1.0, pos.y) :\n                     vec3( pos.x, -pos.y,  1.0)\n    ;\n}\n\n// Calculate rayDir based on address\nvec3 adrToRayDir(in int adr) {\n    int plane = adr / M;\n    vec2 pos = vec2(\n        (float(adr % K) + 0.5) * 2.0 / fK - 1.0, \n        (float((adr / K) % K) + 0.5) * 2.0 / fK - 1.0\n    );\n    return planeToRayDir(plane, pos);\n}\n\n// Calculate rayDir based on fragCoord and plane\nvec3 coordToRayDir(in vec2 fragCoord, int plane) {\n    vec2 pos = vec2(\n        (fragCoord.x + 0.5) * 2.0 / fK - 1.0, \n        (fragCoord.y + 0.5) * 2.0 / fK - 1.0\n    );\n    return planeToRayDir(plane, pos);\n}\n\n// Calculate plane based on rayDir\nint rayDirToPlane( in vec3 rayDir ) {\n    vec3 a = abs(rayDir);\n    int index = a.x > a.y && a.x > a.z ? 0 : a.y > a.z ? 1 : 2;\n    return rayDir[index] > .0 ? index + 3 : index;\n}\n\n// Calculate adr based on pre-calculated fragCoord and rayDir and plane\nint rayDirToAdr( in vec2 fragCoord, in vec3 rayDir, int plane ) {\n    ivec2 fc = ivec2(fragCoord);\n    return fc.x + fc.y * K + plane * M;\n}\n\n// Calculate adr based on just rayDir\nint rayDirToAdr( in vec3 rayDir ) {\n    vec3 dA = vec3(-1.00) / rayDir;\n    vec3 dB = vec3(+1.00) / rayDir;\n    float d = min(min(max(dA.x, dB.x), max(dA.y, dB.y)), max(dA.z, dB.z));\n    \n    ivec3 pos = ivec3(d * rayDir * 512.1 + vec3(512.0));\n    ivec3 p1 = \n        d == dA.x ? ivec3(pos.z, 1023-pos.y, 0) :\n        d == dA.y ? ivec3(pos.x, 1023-pos.z, M) :\n        d == dA.z ? ivec3(1023-pos.x, 1023-pos.y, 2 * M) :\n        d == dB.x ? ivec3(1023-pos.z, 1023-pos.y, 3 * M) :\n        d == dB.y ? ivec3(pos.x, pos.z, 4 * M) :\n                    ivec3(pos.x, 1023-pos.y, 5 * M);\n    return p1.x + p1.y * K + p1.z;\n}\n\nfloat calcZ(vec2 v)\n{\n    return v.x;\t\t\t// Returns the Re-part\n    // return v.y;\t\t\t// Returns the Im-part\n    // return atan(v.x, v.y);\n}\n\nuvec4 peek(in samplerCube sampler, in int adr) {\n\tvec4 pixel = texture(sampler, coordToRayDir(vec2(adr % 0x400, adr / 0x400 + YOFFS), 5));\n    uint pat1 = packHalf2x16(pixel.rg);\n    uint pat2 = packHalf2x16(pixel.ba);\n    return uvec4(pat1, pat1 >> 16u, pat2, pat2 >> 16u);\n} ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"vec4 mainVoxel( in lowp vec4 fragColor, in vec2 fragCoord, in vec3 rayDir, int plane) {\n    // Check if we're done here\n    int targetPlane = iFrame - SKIP_FRAMES;\n\n    // Calculate one plane at the time\n    if (targetPlane != plane) return fragColor;\n   \n    // Even pixel or odd pixel?\n    int index = int(fragCoord.y) % 2;\n\n    int k[54];\n    uvec4 pat = uvec4(0u);\n    \n    for (float smpx = 0.0; smpx < 1.0; smpx += 0.25)\n    {\n        for (float smpy = 0.0; smpy < 1.0; smpy += 0.25)\n        {        \n            vec2 coord = vec2(fragCoord.x, fragCoord.y - float(index))  + vec2(smpx, smpy) * 2.0;\n  \t\t\tvec2 c1 = vec2(\n                coord.x * (BOXMAX.x - BOXMIN.x) / fK + BOXMIN.x,\n                coord.y * BOXMAX.y / fK\n            );\n            vec2 z = vec2(0.);\n\n            for (int i = 0; i < INITIAL_ITERATIONS; i++)\n            {\n                z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c1;\n                if (dot(z, z) >= 4.0)\n                    break;\n            }\n            \n            for (int i = 0; i < ADDITIONAL_ITERATIONS; i++)\n            {\n                z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c1;\n                if (dot(z, z) >= 4.0)\n                    break;\n\n                float h = calcZ(z);\n                for (float n = -1.0; n < 1.0; n += 0.5)\n                {\n                    int h2 = int(clamp(((h - ZMIN) * 648.0 + n) / (ZMAX - ZMIN), -200.0, 800.0));\n                    if (h2 / 108 == plane && (h2 % 108) / 54 == index)\n                    {\n                        k[h2 % 54]++;\n                    }\n                }\n\t        }\n        }\n    }\n    for (int n = 0; n < 54; n++) \n    {\n        if (k[n] > 1)\n        {        \n            // Set bit in pattern\n            pat[(n + 1)/14] |= (1u << uint((n + 1) % 14));\n        }\n    }\n\n    // One bitpattern of 48 bits into 2x2 16-bit uints, using 14 bits each\n    uint pat1 = pat[0] | pat[1] << 16;\n    uint pat2 = pat[2] | pat[3] << 16;\n    \n    fragColor = vec4(unpackHalf2x16(pat1), unpackHalf2x16(pat2));\n    return fragColor;\n}\n\nvec4 copyEdgeBits( in lowp vec4 fragColor, in vec2 fragCoord, in vec3 rayDir, int plane) {\n    // Check if we're done here\n    if (iFrame != SKIP_FRAMES + 6) return fragColor;\n    \n    vec3 rd;\n    vec4 pixel;\n    uint pat, pat1, pat2;\n\tint index1, index2;\n    \n    // Even pixel or odd pixel?\n    //   0: Pixels 0..54\n    //   1: Pixels 55..109\n    index1 = abs(mod(fragCoord.y, 2.0)) < 0.1 ? 0 : 1; //    int(fragCoord.y) % 2;\n    index2 = 1 - index1;\n\n    pat1 = packHalf2x16(fragColor.rg);\n    pat2 = packHalf2x16(fragColor.ba);\n    \n    vec2 fragCoord2 = fragCoord + vec2(0., index2 * 2 - 1);\n    \n    // Copy highest bit of lower pixel\n    if (plane > 0 || index2 == 0)\n    {\n        rd = coordToRayDir(fragCoord2, plane - index2);\n        pixel = texture(iChannel0, rd);\n        pat = packHalf2x16(pixel.ba);\n        pat1 |= ((pat >> 28u) & 1u);\n    }\n\n    // Copy lowest bit of higher pixel\n    if (plane < 5 || index1 == 0)\n    {\n        rd = coordToRayDir(fragCoord2, plane + index1);\n        pixel = texture(iChannel0, rd);\n        pat = packHalf2x16(pixel.rg);\n        pat2 |= ((pat << 28u) & 0x20000000u);\n    }\n    \n    fragColor = vec4(unpackHalf2x16(pat1), unpackHalf2x16(pat2));\n    \n    return fragColor;\n}\n\nvec4 buildColumnLookup( in vec4 fragColor, in vec2 fragCoord, in vec3 rayDir, int plane) {\n    // Check if we're done here\n    if (iFrame != SKIP_FRAMES + 7 || plane != 5) return fragColor;\n    \n    ivec2 coord = ivec2(fragCoord) - ivec2(0, YOFFS);\n\tif (coord.y < 0) return fragColor;\n\n    uvec4 pat;\n    vec3 rd;\n    vec4 pixel, pixel1, pixel2;\n\t\n    // 1024x512x648 voxels -> 1024x128 pixels \n    // 48 bits/pixel (4 Y-pixels x 12 bits per Z-column)\n    pat = uvec4(0u);\n    for (int index = 0; index < 4; index++)\n    {\n        int y1 = coord.y * 8 + index * 2;   // [0..1022 in steps of 2]\n        for (int p1 = 0; p1 < 12; p1++)\t\t// 12 bits: 6 planes x 2 pixels\n        {\n            int y2 = y1 + p1 % 2;\n            rd = coordToRayDir(vec2(coord.x, y2), p1 / 2);\n            pixel = texture(iChannel0, rd);\n            if (packHalf2x16(pixel.rg) != 0u || packHalf2x16(pixel.ba) != 0u)\n            {\n                pat[index] |= (1u << p1);\n            }\n        }\n    }\n    \n    // One bitpattern of 48 bits into 2x2 16-bit uints, using 14 bits each\n    uint pat1 = pat[0] | pat[1] << 16;\n    uint pat2 = pat[2] | pat[3] << 16;\n    fragColor = vec4(unpackHalf2x16(pat1), unpackHalf2x16(pat2));\n    return fragColor;\n}\n\nvoid mainCubemap( out lowp vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = texture(iChannel0, rayDir);\n    \n    int plane = rayDirToPlane(rayDir);\n    fragColor = mainVoxel(fragColor, fragCoord, rayDir, plane);\n    fragColor = buildColumnLookup(fragColor, fragCoord, rayDir, plane);\n    fragColor = copyEdgeBits(fragColor, fragCoord, rayDir, plane);\n}    \n","name":"Cube A","description":"","type":"cubemap"}]}