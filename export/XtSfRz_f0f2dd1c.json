{"ver":"0.1","info":{"id":"XtSfRz","date":"1514186818","viewed":593,"name":"3D diffusion limited aggregation","username":"mattz","description":"Trying my hardest to make shadertoy do things it's not supposed to. Sorry if this crashes your GPU. I get 60fps on my Macbook Pro.","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["grid","diffusion","march","dla","aggregation","limited"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* 3D diffusion limited aggregation, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n   Press 'F' to toggle food particles, SPACE to reset.\n   Bonus xmas feature: press 'C' to toggle color palette.\n\n   Basic idea same as \"party grid 3d\" - https://www.shadertoy.com/view/XtlfWs\n   Raytrace through a voxel grid, intersecting spheres in each cell.\n   Only this time, sphere locations are stored in a multipass texture.\n\n   My goal here is to sidestep some apparent limitations on # of distinct\n   primitives in a shadertoy program. In principle, there's no reason this\n   can't render tens of thousands of spheres in realtime.\n\n   Next idea after this: real 3D Lorentz attractor!\n\n\n*/\n\nconst int nslot = 5; \nconst int num_wander = 64;\nint nx, ny;\nfloat nbox;\nivec2 tex_stride;\nivec4 vec_stride;\nint estart;\nvec3 ctr;\n\nvoid check_res() {\n    \n    int nboxi;\n\n    if (iResolution.x >= 320. && iResolution.y >= 240.) {\n        \n        ny = 240;  \n        nx = 320;  \n        nboxi = 24; \n        \n    } else {\n        \n        ny = 140;\n        nx = 200;\n        nboxi = 17;\n        \n    }\n\n    tex_stride = ivec2(1, nx); \n\n    vec_stride = ivec4(nboxi*nboxi*nslot,\n                       nboxi*nslot,\n                       nslot,\n                       1); // for converting idx <-> voxel / slot\n    \n    estart = nboxi*nboxi*nboxi*nslot; // number of voxel/slots\n    \n    nbox = float(nboxi);\n    \n    ctr = vec3(0.5*nbox) - 0.5;\n\n}\n\n// flat index -> tex coord\nivec2 idx2tex(int idx) {\n    return ivec2(idx % tex_stride.y, idx / tex_stride.y);\n}\n\nivec2 slot2tex(ivec3 v, int slot) {\n    return idx2tex(vec_stride.x*v.x + vec_stride.y*v.y + vec_stride.z*v.z + slot);\n}\n\n// voxel / slot -> tex uv\nivec2 slot2tex(vec3 vox, int slot) {\n    ivec3 v = ivec3(vox+0.5);    \n    return slot2tex(v, slot);\n}\n\nivec2 extra2tex(int e) {\n    return idx2tex(estart + e);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n\nconst float farval = 10000.0;\nconst vec4 miss = vec4(vec3(0.0), farval);\nconst float rad = .5;\nconst float wrad = .3;\n\nconst int rsteps = 50;\n\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nfloat alt_color = 0.;\n\n// RGB from hue\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n// rotate about x-axis \nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n// rotate about y-axis \nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n// ray-sphere intersection\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\n// median of vector\nfloat median3(vec3 x) {\n    return dot(x, vec3(1)) - min3(x) - max3(x);\n}\n\n// ray-box intersection\nfloat box(vec3 ro, vec3 rd, vec3 b) {\n\t\n\tvec3 rdi = 1.0/rd;\t\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tmin = min(t1, t2);\n\tvec3 tmax = max(t1, t2);\n    \n    float ta = max3(tmin);\n    float tb = min3(tmax);\n\t\n\tif (ta <= tb) {\n\t\treturn ta;\n\t} else {\n\t\treturn farval;\n\t}\n\n}\n\n// select whichever basis edge minimizes time to hit\nvec3 bselect(vec3 k, vec3 d, vec3 b1, vec3 b2) {\n\treturn (abs(dot(k,b1)*dot(d,b2)) < abs(dot(k,b2)*dot(d,b1))) ? b1 : b2;\n}\n\n// for stepping through cube lattice\nfloat stepcube(in vec3 p, in vec3 d) {\n\t\n\t// g is half-integer coords from p in the direction of d\n\tvec3 g = floor(p+vec3(0.5))-vec3(0.5) + step(vec3(0.0), d);\n\n\t// k is the vector from p to the corner in direction d\n\tvec3 k = g-p;\n\t\n\t// select the basis vector representing the first to intersect\t\n\tvec3 b = bselect(k, d, \n\t\t\t\t\t bselect(k, d, vec3(1.0, 0.0, 0.0), \n\t\t\t\t\t \t\t\t   vec3(0.0, 1.0, 0.0)), \n\t\t\t\t\t\t           vec3(0.0, 0.0, 1.0));\n\t\n\t// compute the distance along the ray to the nearest cube edge\n\treturn dot(k,b) / dot(d, b);\n\t\n}\n\n// point in box?\nbool inbox(vec3 c, float tol) {\n    float cmin = min(c.x, min(c.y, c.z));\n    float cmax = max(c.x, max(c.y, c.z));\n    return cmin >= -tol && cmax < nbox + tol;\n}\n\nfloat rayplane(vec3 ro, vec3 rd, vec3 n, vec3 p) {\n    float d = dot(n, p);\n    return (d - dot(ro, n)) / dot(rd, n);\n}\n\n\nfloat map(vec3 pos) {\n    \n    float result = farval;\n    \n    ivec3 vbase = ivec3(pos);\n    \n    \n    for (int j=0; j<8; ++j) {\n\n        ivec3 joffs = ivec3(j>>2, j>>1, j) & 1;\n        ivec3 v = vbase + joffs;\n        \n        if (inbox(vec3(v), 0.0) && \n            texelFetch(iChannel0, slot2tex(v, nslot-1), 0).w > 0.) {\n            \n            for (int k=0; k<nslot-1; ++k) {\n                \n                vec4 s = texelFetch(iChannel0, slot2tex(v, k), 0);\n                \n                if (s.w != 0.) {\n                    \n                    float d = length(s.xyz - pos) - rad;\n                    \n                    result = min(result, d);\n                    \n                }\n                \n            }\n        }\n    }\n    \n    return result;\n    \n}\n\n// adapted from https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.05 + 0.1*float(i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// fog blocking\nfloat fog(vec3 ro, vec3 rd, float t, vec3 n) {\n\n\t// get view direction\n\tvec3 viewz = Rview[2];\n    \n    // get structure size\n\tfloat rmax = max(texelFetch(iChannel0, extra2tex(num_wander), 0).y, 2.0);\n    \n    vec3 pos = ro + rd*t;\n    vec3 dis = pos - ctr;\n    float len = length(dis);\n    float oc1 = len/rmax;\n    float oc2 = 0.5 + 0.5*dot(n, dis/len);\n    float f = 0.1 + 1.1*oc1*oc2;\n    f *= calcAO(pos, n);\n    return f;\n    \n}\n\n// select closest ray intersection result\nvec4 pselect(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\n// raytrace against sphere whose position is given\n// by texture lookup\nvoid sphere_tex(in vec3 ro, in vec3 rd, in ivec2 tex, \n                in float r, inout vec4 rresult) {\n    \n    vec4 ct = texelFetch(iChannel0, tex, 0);\n    if (ct.w > 0.) {\n        vec4 s = sphere(ro, rd, ct.xyz, r);\n        s.xyz *= ct.w;\n        rresult = pselect(rresult, s);\n    }\n}\n\nconst int KEY_F = 70;\nconst int KEY_C = 67;\n\n/* Compare key state to default state. */\nfloat keyState(int key, float default_state) {\n    return abs( texelFetch(iChannel1, ivec2(key, 2), 0).x - default_state );\n}\n\n\n// ray trace\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \n    vec3 bgcolor = (alt_color == 0. ? vec3(0) : vec3(0.8, 0.8, 0.9));\n    \n    // raytrace against bounding box\n    float curw = box(ro, rd, 0.5*vec3(nbox) + 1.0);\n\n    // center box grid\n    ro += ctr;\n    \n    // raytrace result\n    vec4 rresult = miss;\n    \n    // wandering food particles\n    if (keyState(KEY_F, 1.0) != 0.) {\n        for (int i=0; i<num_wander; ++i) {\n            sphere_tex(ro, rd, extra2tex(i), wrad, rresult);        \n        }\n    }\n\n    // if hit box, raytrace thru\n    if (curw < farval) {\n\n        // added to cube step\n        const float eps = 0.001;\n\n        // march along ray thru grid\n        for (int i=0; i<rsteps; ++i) {\n\n            // point in grid\n            vec3 p = ro + curw * rd;\n\n            // base cell \n            ivec3 vbase = ivec3(p);\n\n            // for each neighbor in 2x2x2 neighborhood\n            for (int j=0; j<8; ++j) {\n\n                // offset to neighbor\n                ivec3 joffs = ivec3(j >> 2, j >> 1, j) & 1;\n\n                // center of cell\n                ivec3 v = vbase + joffs;\n\n                // if center in box and voxel occupied\n                if (inbox(vec3(v), 0.0) && \n                    texelFetch(iChannel0, slot2tex(v, nslot-1), 0).w > 0.) {\n\n                    for (int k=0; k<nslot-1; ++k) {\n                        sphere_tex(ro, rd, slot2tex(v, k), rad, rresult);\n                    }\n\n                } // center in box\n\n            } // for each neighbor\n\n            curw += stepcube(p, rd) + eps;\n\n        } // for each step along ray\n\n    } // if hit bounding box\n        \n    // if hit a sphere, shade it\n    if (rresult.w < farval) {\n\n        vec3 n = rresult.xyz;\n        float t = length(n);\n        n /= t;\n        \n        vec3 c, c2;\n        \n        if (alt_color != 0.) {\n            if (t < 1.0) {\n                if (mod(t, 0.1) > 0.02) {\n                    c = vec3(0.0, 0.55, 0.05);\n                } else {\n                    c = vec3(0.7, 0.0, 0.0);\n                }\n                c2 = mix(0.1*c, bgcolor, 0.4);\n            } else {\n                c = vec3(1);\n                c2 = mix(0.8*c, bgcolor, 0.4);\n            }\n        } else {\n            c = hue(t);\n            c2 = c;\n        }\n\n        vec3 diffamb = (0.2*clamp(dot(n,L), 0.0, 1.0)+0.8) * c;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        \n        float f = fog(ro, rd, rresult.w, n);\n\n        float spec = f*1.0*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        \n        return (diffamb + spec) * f;\n\n    } else {\n        \n        return bgcolor;\n        \n    }\n    \t\n}\t\n\n// basic view setup and raytrace\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    check_res();\n    \n    alt_color = keyState(KEY_C, 0.0);\n \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n   \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    vec3 cpos = vec3(0.0, 0.0, 1.8*nbox);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float thetay = 0.4*iTime;\n    float thetax = 0.75 * smoothstep(0.0, 5.0, iTime);\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = shade(ro, rd);\n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int nslot = 5; \nconst int num_wander = 64;\nint nx, ny;\nfloat nbox;\nivec2 tex_stride;\nivec4 vec_stride;\nint estart;\nvec3 ctr;\n\nvoid check_res() {\n    \n    int nboxi;\n\n    if (iResolution.x >= 320. && iResolution.y >= 240.) {\n        \n        ny = 240;  \n        nx = 320;  \n        nboxi = 24; \n        \n    } else {\n        \n        ny = 140;\n        nx = 200;\n        nboxi = 17;\n        \n    }\n\n    tex_stride = ivec2(1, nx); \n\n    vec_stride = ivec4(nboxi*nboxi*nslot,\n                       nboxi*nslot,\n                       nslot,\n                       1); // for converting idx <-> voxel / slot\n    \n    estart = nboxi*nboxi*nboxi*nslot; // number of voxel/slots\n    \n    nbox = float(nboxi);\n    \n    ctr = vec3(0.5*nbox) - 0.5;\n\n}\n\n// flat index -> tex coord\nivec2 idx2tex(int idx) {\n    return ivec2(idx % tex_stride.y, idx / tex_stride.y);\n}\n\nivec2 slot2tex(ivec3 v, int slot) {\n    return idx2tex(vec_stride.x*v.x + vec_stride.y*v.y + vec_stride.z*v.z + slot);\n}\n\n// voxel / slot -> tex uv\nivec2 slot2tex(vec3 vox, int slot) {\n    ivec3 v = ivec3(vox+0.5);    \n    return slot2tex(v, slot);\n}\n\nivec2 extra2tex(int e) {\n    return idx2tex(estart + e);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n\n// lookup texture from integer tex coords\nvec4 texlookup(ivec2 t) {\n    return texelFetch(iChannel0, t, 0);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// sample uniform on face of sphere\nvec3 random_dir(vec2 ti) {\n   \n    vec2 pq = hash22(ti);\n    \n    float z = pq.y * 2. - 1.;\n    float s = sqrt(1. - z*z);\n    \n    float theta = pq.x * 6.283185307179586;\n    \n    return vec3(cos(theta)*s, sin(theta)*s, z).yzx;\n    \n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\n// get flat index from tex coord\nint tex2idx(ivec2 tex) {\n    return tex.x*tex_stride.x + tex.y*tex_stride.y;\n}\n\n// this is the main logic behind the dla algorithm\nvoid mainImage( out vec4 fragColor, in vec2 floatFC ) {\n    \n    check_res();\n   \n    // future operations assume fragCoord is exact integer\n    ivec2 fc = ivec2(floatFC);\n\n    // check if current fragment in minimum texture area \n    ivec2 outside = fc - ivec2(nx, ny);\n    if (max(outside.x, outside.y) > 0) {\n        discard; \n        return;\n    }\n\n\t// each voxel has a number of \"slots\" (possible spheres)\n    // to keep things simple and avoid having to loop to check \n    // for free slots, we have a fixed destination slot\n    // which increments each frame.\n    int f = iFrame;\n    int frame_slot = f % (nslot - 1);\n    \n    // get the fragment color by looking up in the texture (feedback buffer)        \n    fragColor = texelFetch(iChannel0, fc, 0);\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.) {\n        \n        // on first frame, just write a single seed sphere in the middle of the scene\n        if (fc == slot2tex(ctr, 0) || fc == slot2tex(ctr, nslot-1)) {\n            // storage format is 3D position, color/material\n            fragColor = vec4(ctr, 0.0001);\n        } else {\n            fragColor = vec4(0);\n        }\n                \n    } else {\n        \n        // get the flat index (within texture) of this texel\n        int idx = tex2idx(fc);\n        int my_slot = idx % nslot;\n                \n        // see if it's a wandering food particle\n        bool is_wander = (idx >= estart && idx < estart + num_wander);\n        \n        int widx = -1; // wandering particle index\n        vec3 p_wander;    // wandering particle position\n\n        // texel one past wandering food particles stores max radius\n        if (idx == estart + num_wander) {\n            \n            // update max radius\n            float rmax = fragColor.x;\n                        \n            // for each food particle\n            for (int i=0; i<num_wander; ++i) {\n                \n                // get its current position\n                vec4 p = texlookup(extra2tex(i));\n                \n                // get its voxel\n                vec3 v = floor(p.xyz+0.5);\n                \n                // if it's in bounding cube\n                if (min3(v) >= 0. && max3(v) < nbox) {\n\n                    // lookup the current frame's slot inside this voxel\n                    vec4 q = texlookup(slot2tex(v, frame_slot));\n                    \n                    // if there's a sphere there, update the distance\n                    if (q.w != 0.0) {\n                        rmax = max(rmax, length(q.xyz - ctr));\n                    }\n\n                }\n                \n            }\n            \n            fragColor = vec4(rmax, mix(fragColor.y, rmax, 0.03), 0, 0);\n           \treturn;    \n            \n        } else if (is_wander) { \n            \n            // this texel corresponds to a wandering food particle, \n            // so stash its index and position\n            widx = idx - estart;\n            p_wander = fragColor.xyz;\n            \n        } else if (my_slot == frame_slot || my_slot == nslot - 1) {\n            \n            // this texel corresponds to the current frame slot in some voxel\n            \n            // see if this texel corresponds to some food particle,\n            // if so, stash its index and position\n            for (int i=0; i<num_wander; ++i) {\n                vec4 p = texlookup(extra2tex(i));\n                if (p.w != 0.0 && slot2tex(p.xyz, my_slot) == fc) {\n                    widx = i;\n                    p_wander = p.xyz;\n                }\n            }\n\n        }\n        \n        // if no current wandering particle, leave fragment unchanged\n        if (widx < 0) { return; }\n        \n        // get the floor of 2x2x2 neighborhood for this wandering poxel\n        ivec3 vbase = ivec3(p_wander);\n\n        // age of colliding sphere in voxel (0 if none)\n        float hit = 0.;\n\n        // check for collision among 2x2x2 neighborhood\n        for (int j=0; j<8; ++j) {\n            \n            ivec3 joffs = ivec3(j >> 2, j >> 1, j) & 1;\n            ivec3 v = vbase+joffs; // neighbor voxel\n            vec3 fv = vec3(v);\n            \n            // if neighbor in bounding cube\n            if (min3(fv) >= 0. && max3(fv) < nbox) {\n                \n                // check all neighbor's slots for collision\n                for (int slot=0; slot<nslot; ++slot) {\n                    vec4 q = texlookup(slot2tex(v, slot));\n                    if (q.w != 0.0 && length(p_wander - q.xyz) < 0.9) {\n                        hit = q.w;\n                    }\n                }\n                \n            }\n        }\n        \n        // now we need to update wandering particles and/or add them into\n        // grid if collided...\n\n        if (is_wander) { // current texel is wandering particle\n            \n            // get bounding sphere radius\n            float rmax = texlookup(extra2tex(num_wander)).x;\n\n            // starting radius\n            float rseed = max(rmax + 1.0, 4.0);\n            float r = length(p_wander - ctr);\n\n            // if hit or not yet generated or too old\n            if (hit > 0. || r > rseed + 1.0 || fragColor.w <= 1.2) {\n\n                p_wander = ctr + random_dir(vec2(float(f) + iDate.w, widx))*rseed;\n                fragColor = vec4(p_wander, 1.95);\n                \n            } else { // otherwise add brownian motion and age the particle\n\n                fragColor.xyz += random_dir(vec2(float(f) + iDate.w, widx)) * 0.5;\n                fragColor.w = mix(fragColor.w, 1.2, 0.005);\n                \n            }\n            \n        } else if (hit > 0.) { // current texel is where particle should be added\n            \n            fragColor.xyz = p_wander;\n            fragColor.w = fract(hit + 0.03);\n            \n        }\n\n    }\n   \n}","name":"Buf A","description":"","type":"buffer"}]}