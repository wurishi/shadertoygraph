{"ver":"0.1","info":{"id":"MXtXRH","date":"1718647544","viewed":78,"name":"Strange Checkberboard","username":"Borthralla","description":"Mobius Transformations of a Circular checkerboard. Goes back and forth between z -> z and z -> (z + 1)/(z - 1)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard","mobius","transform"],"hasliked":0,"parentid":"msdGRj","parentname":"Elliptic Mobius Transform"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nvec2 cMul(in vec2 z1, in vec2 z2) {\n    return  mat2(z1,-z1.y,z1.x) * z2;\n}\n\nvec2 cDiv(in vec2 z1, in vec2 z2) {\n    return z1 * mat2(z2,-z2.y,z2.x) / dot(z2,z2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = 12. * (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 unit = vec2(1., 0.);\n    float factor = sin(iTime * .1);\n    p = (1. - factor) * cDiv(p + unit, p - unit) + factor * p; // 2 fixed points, loxodromic\n    //p = cDiv(unit, p); // 1 fixed point, parabolic\n    \n    // Use these for elliptic/hyperbolic/loxodromic transforms depending on where itime is\n    // itime on both means loxodromic\n    // just on theta is elliptic\n    // just on length is hyerbolic\n    float theta = atan(p.y, p.x);\n    float len = length(p);\n    float x_index = sin( PI* ( theta * 12. / PI - iTime ));\n    float y_index = sin( PI* ( log(len) * 4.  - iTime));\n   \n    // Use these for parabolic mobious transformations\n    //float x_index = sin( PI* ( p.x * 10. + iTime ));\n    //float y_index = sin( PI* ( p.y * 10.  ));\n    \n    float v = x_index*y_index;\n    \n    \n    //Thank you to Fabrice for the anti anliasing tip\n    fragColor = vec4( .5 + v/fwidth(v) );\n}","name":"Image","description":"","type":"image"}]}