{"ver":"0.1","info":{"id":"ts3fD2","date":"1606003691","viewed":81,"name":"Exemple orbit","username":"xener","description":"Testing stuff","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n \tvec3 position;\n    vec3 couleur;\n    float taille;\n    bool lumiere;\n};\n\nconst int nombreDeSpheres = 8;\nSphere spheres[nombreDeSpheres];\n\nvoid Scene()\n{\n    spheres[0].position = vec3(2.0 * sin(iTime), 0, 2.0 * cos(iTime));\n    spheres[0].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[0].taille = 0.5;\n\tspheres[0].lumiere = false;\n    \n    spheres[1].position = vec3(4.0 * cos(iTime*.5), 0, 4.0 * sin(iTime*.5));\n    spheres[1].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[1].taille = 1.0;\n    spheres[1].lumiere = false;\n        \n    spheres[2].position = vec3(0.0, 0.0, 0.0);\n    spheres[2].couleur = vec3(1.0, 0.0, 0.0);\n    spheres[2].taille = 0.05;\n    spheres[2].lumiere = true;\n    \n    spheres[3].position = vec3(6.0 * cos(iTime * 0.8), 0, 6.0 * sin(iTime * 0.8));\n\tspheres[3].couleur = vec3(0.0, 1.0, 0.0);\n    spheres[3].taille = 0.05;\n    spheres[3].lumiere = true;\n    \n    spheres[4].position = vec3(7.0 * sin(iTime * 0.75), 0, 7.0 * cos(iTime * 0.75));\n\tspheres[4].couleur = vec3(0.0, 0.0, 1.0);\n    spheres[4].taille = 0.05;\n    spheres[4].lumiere = true;\n   \n    spheres[5].position = vec3(10.0 * cos(iTime*0.37), 0, 10.0 * sin(iTime*0.37));\n    spheres[5].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[5].taille = 2.0;\n\tspheres[5].lumiere = false;\n   \n    spheres[6].position = vec3(20.0 * cos(iTime*0.57), 0, 20.0 * sin(iTime*0.57));\n    spheres[6].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[6].taille = 3.0;\n\tspheres[6].lumiere = false;\n   \n    spheres[7].position = vec3(45.0 * sin(iTime*0.31), 0, 45.0 * cos(iTime*0.31));\n    spheres[7].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[7].taille = 20.0;\n\tspheres[7].lumiere = false;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\nfloat Intersection(vec3 p, out Sphere sphere, out vec3 normal)\n{\n    float minDist = 1e10;\n    \n    for(int i = 0; i < nombreDeSpheres; ++i)\n    {\n        float dist = sdSphere(p - spheres[i].position, spheres[i].taille);\n        if(dist < minDist)\n        {\n            minDist = dist;\n            sphere = spheres[i];\n            normal = normalize(p - spheres[i].position);\n        }\n    }\n    \n    return minDist;\n}\n\nbool RayCast(vec3 ro, vec3 rd, out float t, out Sphere sphere, out vec3 normal)\n{\n    float tmin = 1.0;\n    float tmax = 200.0;\n    \n    t = tmin;\n    \n    for(int i = 0; i < 70 && t < tmax; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float h = Intersection(p, sphere, normal);\n        \n        if(abs(h) < 0.0001 * t)\n        {\n            return true;\n        }\n        \n        t += h;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Scene();\n    \n    // Coordonnée du pixel à l'écran\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Position de la caméra\n    vec3 ro = vec3(0, 6, -12);\n    \n    // Cible de la caméra\n    vec3 lookat = vec3(0, 0, 0);\n    \n    // Calcul de la caméra\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n        \n    vec3 c = ro + f;\n    vec3 i = c + uv.x * r + uv.y * u;\n    vec3 rd = normalize(i - ro);\n    \n    // Lancé de rayon\n    float t;\n    Sphere sphere;\n    vec3 normal;\n    \n    if(RayCast(ro, rd, t, sphere, normal))\n    {        \n        vec3 lumiereTotal = vec3(0);\n        vec3 position = ro + rd * t;\n\n        // Calcul de la lumière\n        for(int i = 0; i < nombreDeSpheres; ++i)\n        {\n            if(spheres[i].lumiere)\n            {\n                // Ombres\n            \tvec3 positionLumiere = spheres[i].position - position;\n                vec3 lightDir = normalize(positionLumiere);\n                                \n                float tOmbre;\n                Sphere sphereOmbre;\n                vec3 normalOmbre;\n                \n                if(RayCast(position, lightDir, tOmbre, sphereOmbre, normalOmbre) && sphereOmbre.lumiere)\n                {                    \n            \t\tfloat lightDist = length(positionLumiere);       \n                    float distAttenuation = (3.0 / lightDist);\n                    vec3 diffus = sphere.couleur * spheres[i].couleur * max(dot(normal, lightDir), 0.0);\n                    vec3 speculaire = spheres[i].couleur * pow(max(dot(-rd, reflect(-lightDir, normal)), 0.0), 200.0);\n                    lumiereTotal += (diffus + speculaire) * distAttenuation;\n                }\n            }\n        }\n                \n     \tvec3 couleur = mix(lumiereTotal, sphere.couleur, sphere.lumiere ? 1.0 : 0.0);\n        fragColor = vec4(couleur, 1.0);\n    }\n    else\n    {\n     \tfragColor = vec4(0);   \n    }\n}","name":"Image","description":"","type":"image"}]}