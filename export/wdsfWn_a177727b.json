{"ver":"0.1","info":{"id":"wdsfWn","date":"1588212447","viewed":647,"name":"Voxel Cube Shapes","username":"spalmer","description":"tech demo voxelizing sdf shapes into cubic lattices of instances of shapes that fit into the cubic cells. \nusing variant of unnick's DDA scanner to skip empty space efficiently.\nFly w mouse+kbd\n\n","likes":28,"published":1,"flags":48,"usePreview":1,"tags":["raymarch","raycast","sdf","voxel","font","dda","extrude","lathe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a more advanced version of Alphabet Blocks https://shadertoy.com/view/WslBWH\n// which is basically a 3D version of https://shadertoy.com/view/wt3SW8\n// which is from unnick's DDA at https://shadertoy.com/view/wtXSW8\n\n// now has SDF shapes in the cube cells,\n// as block instances.  The shapes are all\n// extruded or lathed font glyphs, since\n// that's about all I had to work with.\n// So they won't look like cubes at all, probably.\n\n// I might make a 3D version of Dorf Fortress w this lol\n// seriously idk what it may be good for, but \n// it's basically voxelized instanced sdf shapes.\n// Surely it should be useful for something.\n\n// FIXME there's still some artifacts with the marching;\n// idk if it's worth holding up showing over.\n// If you have any suggestions to improve quality,\n// I'm all ears!  Leave a comment.\n// Anyway I'm still working on it.\n\n// TODO surely the lighting and sky and such\n// can be improved; don't care rn, just doing shapes.\n// Not even doing materials atm.\n\n#define Font iChannel3\n\nconst float border = .25;\n\nfloat tex(vec2 uv, vec2 subuv)\n{\n    float fd = texture(Font, uv).w - .5; // 'texture' unorm sdf in w\n   #if 0 // border\n     float bd = .5 - border - max(abs(.5-subuv.x), abs(.5-subuv.y));\n     fd = min(fd, bd);\n   #endif\n    return fd;\n}\n\n// deconstruction of hit point to obtain uvs for the \n// letters of font texture in iChannel3 which are \n// 16x16 layout glyphs\nfloat alphatex(vec2 subuv, ivec2 cell)\n{\n    vec2 atlas = subuv;\n   #if 1  // inset\n    atlas = mix(atlas, vec2(.5), -border);\n    atlas = clamp(atlas, 0., 1.); // can help certain cases but if it clamps into the shape, does weird stuff!\n   #endif\n    atlas += vec2(cell);\n    atlas /= 16.; // because Font texture is 16x16 grid of cells\n    float fd = tex(atlas, subuv);\n    return fd;\n}\n\nfloat textureAtlas(vec2 uv, int hitid)\n{\n    return alphatex(uv, ivec2(hitid, hitid >> 4) & 15);\n    // TODO various symmetry modes to extend the available shapes\n    // simple extrusions, lathes on various axes, vary orientation, etc.\n}\n\n// as proof of concept, doing ok, \n// but FIXME the grouping is pathetic;\n// I wanted them mixed up more!\nfloat shape(vec3 q, int id)\n{\n    int i15 = id & 15, i255 = id & 255, i3 = (id >> 8) & 3;\n    if (i255 == 0)\n    return max(abs(q.x),max(abs(q.y),abs(q.z))) - .485; //.475; // filled with boxes lol\n    if (i255 == 32)\n\treturn (length(q) - .488) * 1.; // every cell has a sphere inscribed\n    //float flite;\n    vec3 uvw = q + .5;\n    // TODO refactor all these into different styles that may be applied to any glyph\n    // using the high bits as style bits? somehow?\n    if (i3 == 3) uvw = uvw.zxy;\n    else if (i3 == 2) uvw = uvw.xzy;\n    // lathe mostly looks like pottery!\n    if (i15 == 7)\n        uvw = vec3(min(1., length(uvw.xy-.5)+.5), .5, uvw.z); // lathe right half vertically :) like vases\n    else if (i15 == 8)\n        uvw = vec3(uvw.x, .5, length(uvw.zy-.5) + .5); // lathe upper half horizontally?\n    else if (i15 == 9)\n    uvw = vec3(uvw.x, .5, .5 - min(.5, length(uvw.zy-.5))); // lathe lower half horizontally?\n\n    // all of the lathes must clamp the resulting length\n    float d = textureAtlas(uvw.xz, id);\n//    d += .01;\n//    float d2 = clamp(.5 - d * 2., 0., 1.); // wow I had this kludge in for a long time when I didn't think I did, now idk, must reevaluate my life lol\n    float p = abs(uvw.y - .5); //abs(q.y); //\n//    return max(p - .25, d); // another way to extrude is to intersect with a slab\n    return max(p - .05, d + .01); // much thinner slab :)\n//    return max(p - .05, d + (p - .05) * .5); // beveled - kinky field tho\n//    return p - .8*d2 + .08; // alphabet extrusion from Font atlas - exaggerated\n//    return p -  .5* d2 + .1; // alphabet extrusion from Font atlas\n}\n\nfloat Scene(vec3 p)\n{\n    vec3 f;\n    //f = fract(p); f -= .5; // center in cell\n    ivec3 i = voxid(p);\n\tf = p - voxpos(i); // relative to closest cell\n    int id = ComputeHitId(i);\n    return shape(f, id);\n}\n// TODO for accurate stepping will need to scan neighbor cells too\n//    return overallShape(p);\n\nvec3 SceneNormal(vec3 p, float h, out float d)\n{\n    vec3 n = vec3(\n          Scene(p + vec3(h,0,0))\n        , Scene(p + vec3(0,h,0))\n        , Scene(p + vec3(0,0,h))\n      ) - (d = Scene(p));\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\n// returns (distance, material)\nvec2 March(vec3 ro, vec3 rd, float rate, int iters)\n{\n    vec2 c = vec2(3.4e38, mSky);\n    int i = iters;\n    float t = 0.;\n    while (i-- > 0) {\n        vec3 p = ro + rd * t;\n        float d;\n        if (!Condition(voxid(p)))\n            d = max(1e-3, overallShape(p) + .6); //.5; //break; // TODO maybe distance to edge?\n        else \n        \td = Scene(p);\n        t += d * rate;\n        if (d < .01) { //abs(d) < .01) { //\n            c = vec2(d, mGray);\n            break;\n        }\n    }\n    // TODO if ever find an empty voxel, break from loop so can go back to stepping, which is better for that case\n    c.x = t;\n    return c;\n}\n\n// TODO use it for sub-cell shapes\n// from fly camera, example ray marcher\nfloat MarchThruSolidVoxels(vec3 ro, vec3 rd, float dlimit)\n{\n    vec2 mr = March(ro, rd, 1.04, 128 + IZERO);\n    //vec3 hp = ro + rd * t;\n    return mr.x;\n}\n\nfloat StepThruEmptyVoxels(vec3 ro, vec3 rd, float dlimit)\n{\n    ivec3 n;\n//    if (Condition(voxid(ro + rd * 1e-3))) \n//        return 0.;\n    float t = ScanDDA3(ro, ro + rd * dlimit, n);\n    //vec3 hp = ro + rd * t;\n    return t;\n}\n\nfloat TraceVoxels(vec3 ro, vec3 rd, float dlimit)\n{\n    float ttotal = 0., t = 0.;\n    for (int l = 1; l-- > 0; ) { // transparent voxel layers to step through\n\t    if (!isVoxel(voxid(ro)))\n\t    t = StepThruEmptyVoxels(ro, rd, dlimit - ttotal);\n        if (!(t >= 0.)) { ttotal = -1.; break; }\n        t += 1e-5; // HACK get past the gridline\n        ttotal += t;\n        //dlimit -= t;\n        if (ttotal >= dlimit) //dlimit <= 0.) //\n        { ttotal = -1.; break; }\n        ro += rd * t;\n        t = MarchThruSolidVoxels(ro, rd, dlimit - ttotal);\n        if (t >= 0. && t < dlimit - ttotal) {\n            ttotal += t;\n            return ttotal;\n        }\n        return -1.; // missed\n        // FIXME need to know how far it went before it gave up\n        // need to be able to tell difference between a hit and back to empty stepping results\n        //if (!(t >= 0.)) { ttotal = -1.; break; }\n        //ttotal += t;\n        //dlimit -= t;\n        //if (ttotal >= dlimit) //dlimit <= 0.) //\n        //{ ttotal = -1.; break; }\n        //ro += rd * t;\n    }\n    /*\n    if (false && c.x > .05 && ro.y > 0.) { // rescue?\n        if (rd.y < 0.) { // ground plane\n            t = ro.y / -rd.y; m = mGray;\n        } else { // sky dome\n            t = dmax * pow(1.-.5*rd.y, 2.); m = mSky;\n        }\n        c.y = float(m);\n    }\n\t*/\n    return ttotal; \n}\n\n// compute material (albedo for now) from id\nvec3 Material(int i)\n{\n    vec3 a;\n    switch (i) {\n      default:\n      case mSky:  a = vec3(0); break;\n      case mGray: a = vec3(.5); break;\n      case mRed:  a = vec3(1,0,0); break;\n    }\n    return a;\n}\n\n\nvec3 Light(int m, vec3 p, vec3 n, vec3 v)\n{\n//    if (m == mSky) return vec3(0);\n    return mix(n.y, 1., .5) * vec3(1);\n}\n\nvec3 hue(float x)\n{\n    return cos(vec3(0,2,4) + x * phi * tau) * .5 + .5;\n}\n\nfloat lighting(vec3 n, vec3 v)\n{\n\tvec3 L = normalize(vec3(1,3,2));\n   \tfloat nl = dot(vec3(n), L);\n   \tnl = max(0., nl); // lighting\n   \tnl = mix(nl, 1., .2); // ambient\n    return nl;\n}\n\n\nvec3 LightVoxelHitPoint(vec3 hp, float depth, out int hitid, vec3 v)\n{\n    float hitd;\n    vec3 n = SceneNormal(hp, 1e-2, hitd);\n//    vec2 uv = hitUV(hp, n);\n\t//vec2 d_dx = dFdx(uv), d_dy = dFdy(uv);\n    float fakel = 1.;\n    float faa = 1.; //textureAtlas(uv, hitid, fakel);\n    float nl = lighting(vec3(n), v);\n    nl *= fakel;\n    vec3 c = vec3(1);\n    c *= nl;\n    hitid = ComputeHitId(hp);\n    vec3 tint = hue(float(hitid)); // albedo\n    c *= tint;\n    return c;\n    #if 0\n    float t = mr.x // trace depth to first hit\n        , hd; // distance at hit point\n    int m = int(mr.y);\n    vec3 n = SceneNormal(hp, .004, hd)\n    , albedo = Material(m)\n    , light = Light(m, hp, n, v)\n    , c = vec3(1);\n    c *= albedo;\n    c *= light;\n    return c;\n    #endif\n}\n \nvec3 blendSky(vec3 c, vec3 rd, float t)\n{\n\tconst float fogdensity = .04;\n\tvec3 csky;\n    //csky = vec3(.81,.91,.99);\n    csky = rd * .5 + .5; // DEBUG directions\n    return mix(csky, c, exp2(-fogdensity * t)); // simple fog Beer's law\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n    const float maxd = 128.; //192.; //96.; //64.; //512.; //256.; //160.; //\n    ivec3 n;\n    float t = TraceVoxels(ro, rd, maxd);\n    vec3 c = vec3(0,0,0); // can't really see bg anyway due to atmo\n    if (t >= 0.) {\n        // hit a block\n\t\tvec3 hp = ro + rd * t;\n    \tint hitid;\n        c = LightVoxelHitPoint(hp, t, hitid, -rd);\n    } else {\n        t = maxd;\n    }\n    c = blendSky(c, rd, t);\n    return c;\n}\n    //\tc *= .5 + .5 * vec3(n); // DEBUG normal\n    //\tc *= exp2(-.15/*fogdensity*/ * t); // DEBUG black fog\n//\tc *= vec3(mix(exp2(-.2 * t), 1., .2)); // DEBUG black depth fog\n//\tc *= rd * .5 + .5; // DEBUG ray dir\n//\tc *= n * .5 + .5; // DEBUG hit normal\n\nvec3 Render(vec2 p)\n{\n    // TODO SSAA, focus, etc.\n    State state;\n    vec2 R = iResolution.xy;\n    ivec2 i = ivec2(p);\n    LoadState(state, BufA, ivec2(R));\n    vec2 q = (p + p - R) / R.y;\n    mat3 view = Camera(state.eyeaim);\n    // fovy HACK hardcoded at 60 deg\n    vec3 rv = vec3(q, 2.); // ray dir in view space\n    vec3 rd = normalize(view * rv);\n    vec3 ro = state.eyepos;\n    return Render(ro, rd);\n}\n\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n\tvec3 c = Render(p);\n    c = pow(c, vec3(.4545)); // gamma\n    c += .6 / 256. * Dither(p);\n    o = vec4(c, 1);\n}\n\n#if 0\nvec2 hitUV(vec3 hp, ivec3 n)\n{\n    vec2          uv = hp.xy * vec2(-n.z,1);\n    if (n.x != 0) uv = hp.zy * vec2( n.x,1);\n    if (n.y != 0) uv = hp.xz * vec2( n.y,1);\n    return fract(uv);\n}\n#endif\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define IZERO min(iFrame, 0)\n\nconst float \n  tau = 2. * acos(-1.) //6.28318531 //8. * atan(1.) //\n, phi = (sqrt(5.)+1.)*.5\n, voxtile = 8.\n;\n\nconst int\n  mSky  = 0\n, mGray = 1\n, mRed  = 2\n;\n\n\nfloat overallShape(vec3 q)\n{\n    q -= .5; // centers these shapes on the voxel grid cell centers\n    float dplane = q.y + 10.;\n    float dwaves = dplane + 5. * sin(.1*q.x) * sin(.1*q.z);\n    float dtorus = length(vec2(abs(length(q.xz)-12.), q.y)) - 3.5; // torus\n    q.z -= 30.; \n    q = abs(q);\n    q.x = max(0., q.x-6.); // rod \n    float dcapsule = length(q) - 6.5; // poof to capsule\n    return min(dwaves, min(dtorus, dcapsule));\n}\n\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n// convert cos,sin to rotation matrix\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n// in-place rotate between vectors a,b by rotation matrix m\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n    \n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution;\n    vec3 eyepos;\n    vec2 eyeaim;\n    bool boost; // move faster\n};\n\nconst int\n  slotResolution = 0\n, slotEyePos     = 1\n, slotEyeAim     = 2\n, slotCount      = 3\n;\n\n// measure offsets *backward* from R = ivec2(iResolution), \n// so slotResolution actually goes at R-1\n// slotCamPos goes at R - 1 - ivec2(1,0) etc.\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResolution].xy);\n    state.eyepos = data[slotEyePos].xyz;\n    state.eyeaim = data[slotEyeAim].xy;\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) {\n      case slotResolution:\n        c.xy = vec2(R);\n        break;\n      case slotEyePos:\n        c.xyz = state.eyepos;\n        break;\n      case slotEyeAim:\n        c.xy = state.eyeaim;\n        break;\n      default:\n        break;\n    }\n}\n\nvec3 voxpos(ivec3 i)\n{\n    return vec3(i) + .5;\n}\n     \nbool isVoxel(ivec3 i)\n{\n\treturn overallShape(voxpos(i)) < 0.;\n}\n\nivec3 voxid(vec3 p)\n{\n    return ivec3(floor(p));\n}\n\nint ComputeHitId(ivec3 qi)\n{\n\treturn ((qi.x^(qi.y*3)^(qi.z*7))*123) % 65536 ^ 0xaaaa;\n}\n\nint ComputeHitId(vec3 q)\n{\n\treturn ComputeHitId(voxid(q));\n}\n\nbool Condition(ivec3 qi)\n{\n    return isVoxel(qi); // is voxel here solid?\n}\n\n//int hitid = 0;\n// always just stop if hit a solid voxel\nbool Traverse(ivec3 qi)\n{\n//    hitid = ComputeHitId(qi);\n    return false;\n}\n\n// unnick's from https://shadertoy.com/view/wtXSW8\n// stripped down to just the DDA portion\n// converted to 3D\n// the dda raycaster; returns total distance traced along ray\nfloat ScanDDA3(vec3 pa, vec3 pb, out ivec3 n)\n{ \n    vec3 ro = pa, pd = pb - pa\n    , rd = normalize(pd), nrd = normalize(rd)\n    , ad = abs(pd)\n    , dd = 1. / abs(nrd)\n    , pos = ro\n    , sd = fract(pos);\n    ivec3 mp = ivec3(floor(pa)) // tile iterator\n    , aid = abs(ivec3(floor(pb))-mp)\n    , st = ivec3(sign(rd)); // step direction\n    int side = 0;\n    if (st.x > 0) sd.x = 1. - sd.x;\n    if (st.y > 0) sd.y = 1. - sd.y;\n    if (st.z > 0) sd.z = 1. - sd.z;\n    sd *= dd;\n    bool miss = true;\n    int nsteps = 1+aid.x+aid.y+aid.z; //\n    for (int i = nsteps; --i >= 0; ) {\n        if (Condition(mp))\n            if (!Traverse(mp)) {\n                miss = false;\n            \tbreak;\n            }\n        side = sd.x <= sd.y && sd.x <= sd.z\n            ? 0 : sd.y <= sd.z\n                ? 1 : 2;\n        switch (side) {\n            case 0: sd.x += dd.x; mp.x += st.x; break;\n        \tcase 1: sd.y += dd.y; mp.y += st.y; break;\n        \tcase 2: sd.z += dd.z; mp.z += st.z; break;\n        }\n    }\n    n = ivec3(0);\n    if (miss) return -1.; // past the destination, treat as missed\n    float dist = float(mp[side]) - pos[side];\n    dist += float((1 - st[side]) / 2);\n    dist /= rd[side]; // unproject distance from axial to along ray\n    n[side] = -st[side];\n    return dist;\n}\n    // FIXME not efficient enough to go very far;\n    // surely there's a way to optimize it more\n    // so I can traverse further without choking gpu\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// from Fly Camera at https://shadertoy.com/view/tdsfR4\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define Kbd  iChannel3\n\nconst float \n  eyeradius = .25\n, eyespeed = 10.\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n;\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    bool button;\n  //  bool sprint; // speed boost\n    float dt; // delta time seconds\n    // debug features TODO\n};\n    \nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://en.wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n// key bindings to local directions\n#if 0 // arrows\n, KEY_LF    = KEY_LEFT\n, KEY_RT    = KEY_RIGHT\n, KEY_FW    = KEY_UP\n, KEY_BW    = KEY_DOWN\n#elif 0 // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0 // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE // up - maybe PgUp/Dn?\n, KEY_DW    = KEY_C     // down - anything but control!\n;\n\nfloat key(int vk)\n{\n    return step(.5, texelFetch(Kbd, ivec2(vk, 0), 0).x);\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    if (iMouse.xyz == vec3(0)) // icon?\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    inp.move = vec3(key(KEY_RT) - key(KEY_LF)\n                  , key(KEY_UW) - key(KEY_DW)\n                  , key(KEY_FW) - key(KEY_BW));\n    inp.dt = iTimeDelta;\n}\nvec3 CollideSphere(vec3 pos, float radius)\n{\n#if 0\n    float d;\n    vec3 n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .7); // collision\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .9); // again!\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius); // again! helps with getting stuck in crevices\n    pos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case\n#endif\n    return pos;\n}\n\nvec3 MoveCamera(State state, Inputs inp) \n{\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed;\n    if (state.boost) spd *= 4.;\n    vec3 op = state.eyepos\n    , move = inp.move * inp.dt * spd \n    , p = op + view * move\n    ;\n    p = CollideSphere(p, eyeradius);\n    return p;\n}\n\nvec2 TurnCamera(State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = inp.mouse / R;\n    a.x = fract(a.x * eyespin);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    a = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate\n    return a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    state.boost = key(KEY_SHIFT) > .5;\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(2,6,-18);\n        state.eyeaim = vec2(0.,.5);\n    } else { // update state\n\t    state.eyepos = MoveCamera(state, inp);\n\t    state.eyeaim = TurnCamera(state, inp);\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bool init = iFrame == 0;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    vec4 c = init\n        ? vec4(0,0,0,1)\n     \t: fetch(BufA, i);\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n    SaveState(c, state, i);\n    o = c;\n}\n\n\n// unfortunately I cannot reset iMouse, \n// so when one resets the toy, \n// the camera will still be aimed\n// wherever user had it aimed last.\n\n","name":"Buffer A","description":"","type":"buffer"}]}