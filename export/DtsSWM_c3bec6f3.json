{"ver":"0.1","info":{"id":"DtsSWM","date":"1675681315","viewed":185,"name":"Recursive Refraction - The FAIL","username":"foodini","description":"This was intended to be a \"Polymorphic\" (which I'm now calling \"Barf-o-morphic\") rewrite of my original. I'm abandoning this path and starting a new one. See comments at the top of the code for explanation, since I'm limited to two lines here.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["refraction","raytrace","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// In addition to trying to object-ify my scene a bit better than the last tracer...\n//\n// Recursive ray tracers are a virtual impossibility in glsl because recursion\n// isn't allowed. My original recursive ray tracer (despite having a massive \n// refraction bug in it) looked pretty good, implementing recusion by making\n// the tracing function tail-recursive. Anything that can be made tail recursive\n// can be made iterative, so I just hit a surface, computed the new ray direction,\n// then went back to the top of the function. Keeping track of index of refraction\n// made it a little harder, since I had to know the ior of the exterior sphere\n// when I exited an interior sphere, but that isn't too bad.\n//\n// I wanted to add Fresnel Reflection. This is the effect you see on a glass ball\n// where some small amount of the surface color comes from reflection and some from\n// refraction. Unfortunately, my tail-recursive restriction meant that each time I\n// hit a fresnel point (where normally I'd need to cast two new rays and do a \n// weighted average of their results) I had to just randomly cast one ray and hope\n// that antialiasing would smooth it out. As you can see, that just sucks. (I'm \n// casting 9 AA rays per pixel here (at the time of writing this comment) and it's \n// still very noisy.\n//\n// I think what I'm going to do with my next attempt is actually keep track of a \n// queue of rays. When a ray \"splits\" at a surface, it enqueues two new rays. Each\n// of the new rays knows what the fraction of the original ray it represents. If\n// R0 is the original ray and R1 and R2 and the new ones, where R1 is twice as \n// \"intense\" as R2, then R1 is 67% of R0's intensity and R2 is 33%. These \n// intensities and their associated \"depths\" would be stored with the ray info in\n// the queue. (There's always the possibility that a ray will bounce aronud forever,\n// so I limit the depth to 20 bounces at the moment.)\n\n\n//TODO: \n// * Fix rand(). I really, really, really hate the available GLSL rand options.\n// * Attenuate reflections.\n// * Can we eliminate depth limiting entirely by using reflective/transmissive attenuation?\n//   In other words, every reflect/refract takes away a bit of energy, so even in an\n//   \"infinite\" reflection, reflection attenuation would reduce the \"contributing\n//   fraction\" for each enqueued ray to the point where it would eventually be ignored.\n\n\n// I call it \"Barf-o-morphism\" and you can't stop me.\nstruct Object {\n    int   type;\n    vec3  vec3_prop_0;\n    vec3  vec3_prop_1;\n    \n    float float_prop_0;\n    float float_prop_1;\n    \n    int   texture_id;\n};\n\nconst int max_objects = 10;\nint constructed_obj_count = 0;\nObject objects[max_objects];\n\n// For Spheres:\nconst int SPHERE_TYPE = 0;\n#define sphere_pos             vec3_prop_0\n#define sphere_alpha           vec3_prop_1\n#define sphere_radius          float_prop_0\n#define sphere_ior             float_prop_1\n\n// For Planes:\nconst int PLANE_TYPE = 1;\n#define plane_normal           vec3_prop_0\n#define plane_displacement     float_prop_0\n\n// For Lights:\nconst int LIGHT_TYPE = 2;\n#define light_pos              vec3_prop_0\n#define light_color            vec3_prop_1\n#define light_size             float_prop_0\n\nconst int REFLECT = 0;\nconst int REFRACT = 1;\nconst int MAND    = 2;\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nconst float PI = 3.1415926538;\nconst float EULER = 2.71828183;\nint rand_seed = 2987492621;\n// THIS SUCKS and is making antialiasing terrible.\nfloat rand(in vec2 co){\n    int chaos = int(co.x * 867530.9 * (PI + iTime) + co.y * 555236.8 * (EULER + iTime));\n    rand_seed += chaos;\n    rand_seed *= 1664525;\n    rand_seed += 1013904223;\n    return abs(float(rand_seed) / float(2147483647));\n}\n\nfloat sphere_dist(in Object sphere, in Ray ray) {\n    vec3 OC = sphere.sphere_pos - ray.origin;\n    float len_OC_squared = dot(OC, OC);\n    float r_squared = sphere.sphere_radius*sphere.sphere_radius;\n    float Tca;\n    float Tca_squared;\n    float Thc_squared;\n    \n    Tca = dot(OC, ray.dir);\n\n    // Is the ray origin outside the sphere?\n    if(len_OC_squared >= r_squared) {\n        // Does the ray point away from the sphere?\n        if(Tca < 0.0) {\n            return -1.0;\n        } else {\n            Tca_squared = Tca * Tca;\n            Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        }\n        // Does the ray miss the sphere?\n        if(Thc_squared < 0.0)\n            return -1.0;\n        return Tca - sqrt(Thc_squared);\n    } else {\n        Tca_squared = Tca * Tca;\n        Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        return Tca + sqrt(Thc_squared);\n    }\n}\n\nfloat plane_dist(in Object plane, in Ray ray) {\n    float Vprd = dot(plane.plane_normal, ray.dir);\n    float Vpro = -(dot(plane.plane_normal, ray.origin) + plane.plane_displacement);\n    float t = Vpro / Vprd;\n    if(t>0.0)\n        return t;\n    return -1.0;\n}\n\nfloat dist_to_obj(Object obj, in Ray ray) {\n    if(obj.type == SPHERE_TYPE) {\n        return sphere_dist(obj, ray);\n    } \n    if(obj.type == PLANE_TYPE) {\n        return plane_dist(obj, ray);     \n    }\n}\n\n// Attenuation of ray color as it passes through a medium:\nvec3 attenuate(vec3 sphere_alpha, float nearest_dist) {\n    return vec3(\n        1.0 - pow(EULER, - sphere_alpha.r * nearest_dist),\n        1.0 - pow(EULER, - sphere_alpha.g * nearest_dist),\n        1.0 - pow(EULER, - sphere_alpha.b * nearest_dist));\n}\n\nvec3 mand(in vec3 p) {\n    //return vec3(0.5);\n    //return grid(p);\n\n    //mandel (&intersect, raycolor, .003, 0.14707684544406, 0.651762543252595, \"blues.map\");\n    //void mandel (Point3 *p, col color, double scale, double ztrans, double xtrans, char *filename)\n    vec2 c = vec2(p.x, p.z) * 0.003;// * (0.0005 + pow(sin(iTime/15.0), 2.0));\n    c += vec2(0.1382309, 0.643002);\n    vec2 z = c;\n    vec2 zn;\n    \n    for(float i=0.; i<500.; i++) {\n        if(dot(zn,zn) >= 4.0) {\n            float d = i + 1. - log(log(length(zn)))/log(2.);\n            return vec3(\n                (1.0+sin((iTime*5. + d)/17.))/2.0,\n                (1.0+cos((iTime*7. + d)/13.))/2.0,\n                (1.0+sin((iTime*11. + d)/11.))/2.0\n                );\n        } else {\n            zn = mat2(zn,-zn.y,zn.x) * zn + c;\n    \t\tz = zn;\n        }\n    }\n    return vec3(0.0);\n}\n\nvec3 bump_out(in vec3 intersect_point, in vec3 normal) {\n    return intersect_point + (0.0001 * normal);\n}\n\nvec3 bump_in(in vec3 intersect_point, in vec3 normal) {\n    return intersect_point - (0.0001 * normal);\n}\n\nconst int max_recursion_depth = 20;\nint stack[max_recursion_depth+1];\nint top_of_stack = -1;\n\nvoid push(int sphere_id) {\n    top_of_stack++;\n    stack[top_of_stack] = sphere_id;\n}\n\nint stack_height() {\n    return top_of_stack + 1;\n}\n\n// Bad things will happen if there's nothing on the stack....\nint peek_id() {\n    return stack[top_of_stack];\n}\n\n// Bad things will happen if there's nothing on the stack....\nfloat peek_ior() {\n    return objects[stack[top_of_stack]].sphere_ior;\n}\n\nfloat peek_ior_exiting() {\n    if(top_of_stack > 0)\n        return objects[stack[top_of_stack-1]].sphere_ior / objects[stack[top_of_stack]].sphere_ior;\n    else\n        return 1.0/objects[stack[top_of_stack]].sphere_ior;\n}\n\nvoid pop() {\n    top_of_stack--;\n}\n\n// Fresnel is very costly to compute. I should just replace this with a cheap approximation.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel.html\nbool is_fresnel_reflected(in vec3 ray_dir, in vec3 normal, in float ior) {\n    //return false;\n    \n    float cosi = dot(ray_dir, normal);\n    float etai;\n    float etat;\n    if (cosi < 0.0) {\n        etai = 1.0;\n        etat = ior;\n    } else {\n        etai = ior;\n        etai = 1.0;\n    }\n    \n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if(sint >= 1.0)\n        return true;\n    \n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    \n    float probability = (Rs * Rs + Rp * Rp) / 2.0;\n    return rand(vec2(Rs, Rp)) < probability;\n}\n\nvec3 trace(in Ray ray) {\n    int depth = 0;\n        \n    //TODO: track the index so you do less unnecessary copying?\n    Object nearest;\n    float nearest_dist = 1e10;\n    vec3 intersect_point;\n    int nearest_index;\n    \n    vec3 new_vec_origin;\n    vec3 new_vec_dir;\n    bool traversed;\n    vec3 transmission = vec3(1.0);\n    // If this is true, the last time we did refractions (which would only happen in a previous\n    // antialiasing pass), we didn't properly exit everything we entered, or vice-versa.\n    if(top_of_stack != -1) {\n        return vec3(0.0, 500.0*fract(iTime * 1.5), 0.0); // 500, so we blow out that channel after the AA divide.\n    }\n    \n    while(depth < max_recursion_depth) {\n        nearest.type = -1;\n        nearest_index = -1;\n        \n        for(int obj_index=0; obj_index<=constructed_obj_count; obj_index++) {\n            float dist = dist_to_obj(objects[obj_index], ray);\n            if(dist > 0.0) {\n                if(nearest.type == -1 || dist < nearest_dist) {\n                    nearest = objects[obj_index];\n                    nearest_dist = dist;\n                    nearest_index = obj_index;\n                }\n            }\n        }\n        \n        // I would LOVE to put all of this in a \"texture()\" function, but that function\n        // would have to call trace() again when any recursion (reflection, refraction) \n        // were required.... and glsl doesn't allow recursion. Anything that triggers\n        // recursion has to be located in this function. =[\n        if(nearest.type != -1) {\n            intersect_point = ray.origin + ray.dir * nearest_dist;\n        }\n        if(stack_height() > 0) {\n            transmission *= (1.0 - attenuate(nearest.sphere_alpha, nearest_dist));\n        }\n        if(nearest.type == SPHERE_TYPE) {\n            vec3 normal = normalize(intersect_point - nearest.sphere_pos);\n            \n            if(nearest.texture_id == REFLECT) {\n                new_vec_dir = reflect(ray.dir, normal);\n                //ray.origin = bump_out(intersect_point, normal);\n            } else if(nearest.texture_id == REFRACT) {\n                float ior;\n                bool push_on_traverse = true;\n                if(stack_height() == 0) {\n                    ior = nearest.sphere_ior;\n                } else if(peek_id() == nearest_index) {\n                    // We're hitting the inside of the sphere.\n                    ior = peek_ior_exiting();\n                    push_on_traverse = false;\n                } else {\n                    ior = nearest.sphere_ior/peek_ior();\n                }\n                \n                \n                \n                // TODO: SWITCH THIS METHOD TO USE THE NORMAL RELATIVE TO INTERSECTION, NOT\n                // THE FUCKING SPHERE'S NORMAL!!! \n                \n                \n                \n                \n                vec3 tnormal = push_on_traverse?normal:-normal;\n                if(is_fresnel_reflected(ray.dir, tnormal, ior)) {\n                    if(push_on_traverse) {\n                        ray.origin = bump_out(intersect_point, normal);\n                        new_vec_dir = reflect(ray.dir, normal);\n                    } else {\n                        ray.origin = bump_in(intersect_point, normal);\n                        new_vec_dir = reflect(ray.dir, -normal);\n                    }\n                } else {\n                    float eta = 1.0/ior;\n                    if(push_on_traverse) {\n                        new_vec_dir = refract(ray.dir, normal,eta);\n                        traversed = dot(new_vec_dir, normal) < 0.0;\n                    } else {\n                        new_vec_dir = refract(ray.dir, -normal, eta);\n                        traversed = dot(new_vec_dir, -normal) < 0.0;\n                    }\n\n                    if(traversed) {\n                        if(push_on_traverse) {\n                            ray.origin = bump_in(intersect_point, normal);\n                            push(nearest_index);\n                        } else {\n                            ray.origin = bump_out(intersect_point, normal);\n                            pop();\n                        }\n                    } else {\n                        // There's a nasty bug in the GLSL refract() function: when total internal\n                        // reflection SHOULD occur (whenever going from a higher to a lower ior at\n                        // a steep angle) refract is returning a zero vector, so I compute the reflection\n                        // myself:\n                        if(push_on_traverse) {\n                            ray.origin = bump_out(intersect_point, normal);\n                            new_vec_dir = reflect(ray.dir, normal);\n                        } else {\n                            ray.origin = bump_in(intersect_point, normal);\n                            new_vec_dir = reflect(ray.dir, -normal);\n                        }\n                    }\n                } // NOT fresnel refracted\n            } // if nearest.texture_id == REFRACT\n            ray.dir = normalize(new_vec_dir);\n        }\n        if(nearest.type == PLANE_TYPE) {\n            return mand(intersect_point) * transmission;\n        }\n        if(nearest.type == -1) {\n            //nothing hit\n            float sky_blue = ray.dir.y;\n            float sky_rg = pow(sky_blue, 3.0);\n            return vec3(sky_rg, sky_rg, sky_blue);\n        }\n\n        depth++;\n    }\n    top_of_stack = -1; // If we're bailing out, don't screw up the next call, too.\n    return vec3(fract(iTime*1.), 0.0, 0.0);\n}\n\n// WARNING! The argument names here are being affected by the preprocessor, so you may\n//          get compile errors that reference \"float_prop_0\", etc.\nvoid add_sphere(in vec3 sphere_pos, in vec3 sphere_alpha, \n        in float sphere_radius, in float sphere_ior, in int texture_id) {\n    if(constructed_obj_count == max_objects)\n        return;\n        \n    constructed_obj_count++;\n    objects[constructed_obj_count].type = SPHERE_TYPE;\n    objects[constructed_obj_count].sphere_pos = sphere_pos;\n    objects[constructed_obj_count].sphere_alpha = sphere_alpha;\n    objects[constructed_obj_count].sphere_radius = sphere_radius;\n    objects[constructed_obj_count].sphere_ior = sphere_ior;\n    objects[constructed_obj_count].texture_id = texture_id;\n}\n\n// WARNING! The argument names here are being affected by the preprocessor, so you may\n//          get compile errors that reference \"float_prop_0\", etc.\nvoid add_plane(in vec3 plane_normal, in float plane_displacement, in int texture_id) {\n    if(constructed_obj_count == max_objects)\n        return;\n        \n    constructed_obj_count++;\n    objects[constructed_obj_count].type = PLANE_TYPE;\n    objects[constructed_obj_count].plane_normal = plane_normal;\n    objects[constructed_obj_count].plane_displacement = plane_displacement;\n    objects[constructed_obj_count].texture_id = texture_id;\n}\n\n// WARNING! The argument names here are being affected by the preprocessor, so you may\n//          get compile errors that reference \"float_prop_0\", etc.\nvoid add_light(in vec3 light_pos, in vec3 light_color, in float light_size) {\n    if(constructed_obj_count == max_objects)\n        return;\n        \n    constructed_obj_count++;\n    objects[constructed_obj_count].type = LIGHT_TYPE;\n    objects[constructed_obj_count].light_pos = light_pos;\n    objects[constructed_obj_count].light_color = light_color;\n    objects[constructed_obj_count].light_size = light_size;\n}\n\nvoid inclusions(in vec3 sphere_pos, in float radius) {\n    add_sphere(sphere_pos, vec3(0.0), 0.25, 1.0, REFRACT);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    add_sphere(vec3( 0.0,  0.0,   0.0), vec3(0.5, 0.5, 0.0), 1.0,  1.5,  REFRACT);\n    add_sphere(vec3(-0.51, 0.0,   0.0), vec3(0.5, 0.5, 0.0), 0.25, 1.8,  REFRACT);\n    add_sphere(vec3( 0.51, 0.0,   0.0), vec3(0.5, 0.5, 0.0), 0.25, 1.8,  REFRACT);\n    add_sphere(vec3( 0.0,  0.0,   0.51), vec3(0.5, 0.5, 0.0), 0.25, 0.8,  REFRACT);\n    add_sphere(vec3( 0.0,  0.0,  -0.51), vec3(0.5, 0.5, 0.0), 0.25, 0.8,  REFRACT);\n    add_sphere(vec3( 0.0,  0.51,  0.0), vec3(0.5, 0.5, 0.0), 0.25, 0.8,  REFRACT);\n    add_sphere(vec3( 0.0, -0.51,  0.0), vec3(0.5, 0.5, 0.0), 0.25, 0.8,  REFRACT);\n    add_sphere(vec3( 0.0,  0.0,   0.0), vec3(0.5, 0.5, 0.0), 0.25, 0.8,  REFRACT);\n\n    add_plane( vec3( 0.0,  1.0, 0.0), 2.0, MAND);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screen_space = uv * 2.0 - 1.0;\n    screen_space.x *= (iResolution.x/iResolution.y);\n\n    float cos2 = cos(iTime/4.0);\n    \n    vec3 cam_position = vec3(3.3 * sin(iTime/2.0), 1.3 + 1.5 * sin(iTime/10.0), 3.3 * cos(iTime/2.0));\n    \n    float dist_to_pix_plane = 3.0;\n    float pix_plane_height = 2.0;\n    vec3 cam_look_at = vec3(0.0);\n    vec3 cam_look_dir = dist_to_pix_plane * normalize(cam_look_at - cam_position);\n    \n    vec3 right = cross(vec3(0.0, 1.0, 0.0), cam_look_dir);\n    right = (pix_plane_height / 2.0) * normalize(right);\n    vec3 up = cross(cam_look_dir, right);\n    up = (pix_plane_height / 2.0) * normalize(up);\n    \n    vec3 pixel_width = right/iResolution.x;\n    vec3 pixel_height = up/iResolution.y;\n    \n    float antialias_level = 9.0;\n    float depth_of_field_intensity = 0.0;\n    vec3 out_color = vec3(0.0);\n    Ray ray;\n    for(float aa=0.0; aa<antialias_level; aa+=1.0) {\n        vec3 ray_screen_isect_point = cam_position + cam_look_dir + \n            (screen_space.x * right) + (screen_space.y * up);\n        \n        ray_screen_isect_point += pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n        ray_screen_isect_point += pixel_height * (rand(uv*(aa+1.5) * 2.0 - 1.0));\n\n        ray.origin = cam_position;\n        if(depth_of_field_intensity > 0.0) {\n            ray.origin += depth_of_field_intensity * pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n            ray.origin += depth_of_field_intensity * pixel_height * (rand(uv*(aa+1.0) * 2.0 - 1.0));                 \n        }\n\n        ray.dir = normalize(ray_screen_isect_point - ray.origin);\n\n        //COMPUTE RAY_DIR AFTER CAMERA HAS BEEN SET IN PLACE.\n        out_color += trace(ray);\n    }\n    out_color /= float(antialias_level);\n\n\n    // do a bit of fake gamma correcting as we output:\n    fragColor = vec4(\n        pow(out_color.x, 0.4),\n        pow(out_color.y, 0.4),\n        pow(out_color.z, 0.4),\n        1.0);\n}","name":"Image","description":"","type":"image"}]}