{"ver":"0.1","info":{"id":"NlVSzh","date":"1640857747","viewed":399,"name":"Diamond with caustics","username":"vladislavbelov","description":"Diamond with hard-coded geometry and caustics.\n\nUse mouse to look around.","likes":23,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","caustics","diamond","brilliant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n// \n// Copyright (c) 2021 Vladislav Belov\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvec3 getCameraRayDirection(in vec2 uv, in vec3 origin, in vec3 target)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, right));\n    return normalize(forward * 0.5 / tan(CAMERA_FOV / 2.0) + uv.x * right + uv.y * up);\n}\n\nvec2 getSampleSubPixelOffset(in int sampleIdx, in vec2 uv)\n{\n    return texture(iChannel1, vec2(sampleIdx, uv.y) / iChannelResolution[1].xy).rg;\n}\n\nvec2 getCameraAngles()\n{\n    return vec2(\n        (iMouse.x / iResolution.x) * PI,\n        PI / 6.0 + PI / 6.0 * ((iMouse.y / iResolution.y) - 0.5) * 2.0);\n}\n\nvec3 applyColorCorrection(in vec3 color)\n{\n    return color / (vec3(1.0) + color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    for (int sampleIdx = 0; sampleIdx < NUMBER_OF_AA_SAMPLES; ++sampleIdx)\n    {\n        vec2 subPixelOffset = getSampleSubPixelOffset(sampleIdx, fragCoord);\n        vec2 uv = (fragCoord + subPixelOffset * 1.0) / iResolution.xy;\n        vec2 cameraAngles = getCameraAngles();\n\n        vec3 origin = vec3(sin(cameraAngles.x), sin(cameraAngles.y), -cos(cameraAngles.x));\n        origin.xz *= cos(cameraAngles.y);\n        origin *= CAMERA_DISTANCE;\n        origin += CAMERA_TARGET;\n        vec3 direction = getCameraRayDirection(\n            vec2(uv.x - 0.5, (uv.y - 0.5) / (iResolution.x / iResolution.y)),\n            origin, CAMERA_TARGET);\n\n        color += applyColorCorrection(traceScene(origin, direction, iChannel0, float(iFrame)));\n    }\n    fragColor = vec4(color / float(NUMBER_OF_AA_SAMPLES), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// MIT License\n// \n// Copyright (c) 2021 Vladislav Belov\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst float PI = 3.14159265358979323846;\n\nconst float CAMERA_FOV = PI / 3.0;\nconst float CAMERA_DISTANCE = 2.0;\nconst vec3 CAMERA_TARGET = vec3(0.0, 0.1, 0.0);\n\nconst vec3 SUN_DIRECTION = normalize(vec3(-1.0, 1.0, 1.0));\nconst vec3 SUN_COLOR = vec3(200.0);\n\nconst vec3 GROUND_COLOR = vec3(0.6, 0.8, 0.4);\n\nconst float DIAMOND_IOR_RED = 2.42;\nconst float DIAMOND_IOR_GREEN = 2.425;\nconst float DIAMOND_IOR_BLUE = 2.43;\nconst float AIR_IOR = 1.0;\n\nconst vec2 PROJECTION_SIZE = vec2(4.0, 4.0);\nconst vec2 PROJECTION_OFFSET = vec2(-2.0, -2.0);\n\n#define DEBUG_PROJECTION_BOUNDS 0\n\nconst int MAX_NUMBER_OF_BOUNCES = 4;\n\nconst int NUMBER_OF_CAUSTICS_SAMPLES = 8;\nconst float CAUSTICS_HISTORY_FRAMES = 768.0;\n\n// Range [0, a browser explodes].\nconst int NUMBER_OF_AA_SAMPLES = 8;\n\nfloat getPlaneIntersection(\n    in vec3 origin, in vec3 direction,\n    in vec3 planeNormal, in float planeDistance,\n    in float tMin, in float tMax,\n    out vec3 normal)\n{\n    float distanceToPlane = planeDistance - dot(planeNormal, origin);\n    float cosA = dot(planeNormal, direction);\n    if (abs(cosA) < 1e-5)\n        return tMax;\n    float t = distanceToPlane / cosA;\n    if (t >= tMin)\n    {\n        normal = cosA > 0.0 ? -planeNormal : planeNormal;\n        return min(t, tMax);\n    }\n    return tMax;\n}\n\nfloat getDiamondIntersection(\n    in vec3 origin, in vec3 direction,\n    in float tMin, in float tMax,\n    out vec3 normal)\n{\n    float tCandidate = tMax;\n    vec3 normalCandidate;\n    tCandidate = getPlaneIntersection(origin, direction, vec3(0.0, 0.70711, 0.70711), 0.53033, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(0.70711, -0.5, -0.5), -0., tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(0.0, 0.0, -1.), 0.0, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(-0.70711, -0.5, -0.5), 0.0, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(-0., -1., 0.0), 0.0, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(0.70711, 0.5, 0.5), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(0.5, 0.85355, 0.14645), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(0.0, 1.0, 0.0), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(-0.5, 0.85355, 0.14645), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(-0.70711, 0.5, 0.5), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(-0.5, 0.14645, 0.85355), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(-0., 0.0, 1.0), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(0.5, 0.14645, 0.85355), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    tCandidate = getPlaneIntersection(origin, direction, vec3(0.5, 0.14645, 0.85355), 0.5, tMin, tMax, normalCandidate); if (tCandidate < tMax) { vec3 position = origin + direction * tCandidate; if (dot(vec3(0.0, 0.70711, 0.70711), position) <= 0.53033 && dot(vec3(0.70711, -0.5, -0.5), position) <= -0. && dot(vec3(0.0, 0.0, -1.), position) <= 0.0 && dot(vec3(-0.70711, -0.5, -0.5), position) <= 0.0 && dot(vec3(-0., -1., 0.0), position) <= 0.0 && dot(vec3(0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(0.0, 1.0, 0.0), position) <= 0.5 && dot(vec3(-0.5, 0.85355, 0.14645), position) <= 0.5 && dot(vec3(-0.70711, 0.5, 0.5), position) <= 0.5 && dot(vec3(-0.5, 0.14645, 0.85355), position) <= 0.5 && dot(vec3(-0., 0.0, 1.0), position) <= 0.5) { tMax = tCandidate; normal = normalCandidate; } }\n    return tMax;\n}\n\nfloat getR0(in float ior0, in float ior1)\n{\n    float ratio = (ior0 - ior1) / (ior0 + ior1);\n    return ratio * ratio;\n}\n\nfloat getFresnel(in float cosA, in float r0)\n{\n    // 1.0001 is used to avoid powering zero (suggested by @Dave_Hoskins).\n    return r0 + (1.0 - r0) * pow(1.0001 - cosA, 5.0);\n}\n\nstruct Optics\n{\n    float r0;\n    float etaIn;\n    float etaOut;\n};\n\nOptics getOptics(in float ior0, in float ior1)\n{\n    Optics optics;\n    optics.r0 = getR0(ior0, ior1);\n    optics.etaIn = ior0 / ior1;\n    optics.etaOut = ior1 / ior0;\n    return optics;\n}\n\nvec3 traceEnvironment(\n    in vec3 origin, in vec3 direction, in float tMin, in float tMax,\n    in sampler2D projectedTexture, float frame)\n{\n    vec3 skyColor = mix(\n        vec3(3.0, 3.0, 2.0),\n        vec3(1.0, 2.0, 7.0),\n        clamp(dot(direction, vec3(0.0, 1.0, 0.0)) * 0.8 + 0.2, 0.0, 1.0));\n    // Ground intersection.\n    vec3 groundNormal = vec3(0.0, 1.0, 0.0);\n    float t = getPlaneIntersection(origin, direction, groundNormal, 0.0, tMin, tMax, groundNormal);\n    if (t < tMax)\n    {\n        vec4 data = texture(projectedTexture, vec2(0, 0));\n        vec3 position = origin + direction * t;\n        vec2 projectionUV = (position.xz - PROJECTION_OFFSET) / PROJECTION_SIZE;\n        vec4 projectedColor = texture(projectedTexture, projectionUV);\n        vec3 color = projectedColor.rgb * projectedColor.a;\n        if (frame - data.z < CAUSTICS_HISTORY_FRAMES)\n            color = color / ((frame - data.z) + 1.0) * CAUSTICS_HISTORY_FRAMES;\n#if DEBUG_PROJECTION_BOUNDS\n        if (projectionUV.x >= 0.0 && projectionUV.x <= 1.0 &&\n            projectionUV.y >= 0.0 && projectionUV.y <= 1.0)\n        {\n            color *= 0.5;\n        }\n#endif\n        return mix(GROUND_COLOR * color, skyColor, smoothstep(0.0, 3.0, length(position)));\n    }\n    // Sky.\n    return skyColor +\n        SUN_COLOR * pow(clamp(dot(direction, SUN_DIRECTION), 0.0001, 1.0), 100.0);\n}\n\nvec3 traceSceneComponent(\n    in vec3 origin, in vec3 direction, in sampler2D projectedTexture,\n    in Optics optics, float frame)\n{\n    float tMin = 1e-5;\n    float tMax = 1e3;\n    vec3 color = vec3(0.0);\n    float weight = 1.0;\n    bool inside = false;\n    // Diamond intersection.\n    for (int bounce = 0; bounce < MAX_NUMBER_OF_BOUNCES; ++bounce)\n    {\n        vec3 normal = vec3(0.0);\n        float t = getDiamondIntersection(origin, direction, tMin, tMax, normal);\n        if (t < tMax)\n        {\n            float cosA = dot(normal, -direction);\n            float fresnel = getFresnel(cosA, optics.r0);\n            vec3 intersection = origin + direction * t;\n            vec3 reflectDirection = reflect(direction, normal);\n            vec3 refractDirection = refract(direction, normal, inside ? optics.etaOut : optics.etaIn);\n\n            vec3 envDirection = inside ? refractDirection : reflectDirection;\n            color += weight * (inside ? 1.0 - fresnel : fresnel) *\n                traceEnvironment(intersection + envDirection * 1e-3, envDirection,\n                    tMin, tMax, projectedTexture, frame);\n            weight *= inside ? fresnel : 1.0 - fresnel;\n\n            direction = inside ? reflectDirection : refractDirection;\n            origin = intersection + direction * 1e-3;\n            inside = !inside;\n        }\n        else\n        {\n            // If we left the diamond we won't need to return back because\n            // it has a convex shape.\n            break;\n        }\n    }\n    return color + weight * traceEnvironment(origin, direction, tMin, tMax, projectedTexture, frame);\n}\n\nvec3 traceScene(\n    in vec3 origin, in vec3 direction, in sampler2D projectedTexture, float frame)\n{\n    float red = traceSceneComponent(\n        origin, direction, projectedTexture, getOptics(AIR_IOR, DIAMOND_IOR_RED), frame).r;\n    float green = traceSceneComponent(\n        origin, direction, projectedTexture, getOptics(AIR_IOR, DIAMOND_IOR_GREEN), frame).g;\n    float blue = traceSceneComponent(\n        origin, direction, projectedTexture, getOptics(AIR_IOR, DIAMOND_IOR_BLUE), frame).b;\n    return vec3(red, green, blue);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MIT License\n// \n// Copyright (c) 2021 Vladislav Belov\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvec3 getRandomDirection(in vec2 planePosition, in int sampleIdx, in vec2 frameOffset)\n{\n    vec2 offset = vec2(planePosition.x * 8.0, planePosition.y / 1.0);\n    vec2 noiseUV = vec2(sampleIdx, 0.0) / iChannelResolution[1].xy + offset + frameOffset;\n    vec3 noise = texture(iChannel1, noiseUV).rgb;\n    vec3 direction = normalize(noise * 2.0 - 1.0);\n    if (abs(direction.y) < 1e-3)\n        direction = SUN_DIRECTION;\n    else if (direction.y < 0.0)\n        direction.y = -direction.y;\n    return direction;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 data = texture(iChannel0, vec2(0, 0));\n    // We need to reset the history when the resolution is changed.\n    bool outdated = data.xy != iResolution.xy;\n    if (fragCoord.x <= 1.0 && fragCoord.y <= 1.0)\n    {\n        fragColor = vec4(iResolution.xy, outdated ? float(iFrame) : data.z, 0.0);\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 planePosition = uv * PROJECTION_SIZE + PROJECTION_OFFSET;\n    vec3 position = vec3(planePosition.x, 0.0, planePosition.y);\n    // Noise texture offset for each frame.\n    vec2 frameOffset = texture(iChannel1, vec2(\n        int(mod(float(iFrame), float(iChannelResolution[1].x))),\n        int(iFrame) / int(iChannelResolution[1].y)) / iChannelResolution[1].xy).rg;\n    \n    vec3 color = vec3(0.0);\n    for (int sampleIdx = 0; sampleIdx < NUMBER_OF_CAUSTICS_SAMPLES; ++sampleIdx)\n    {\n        vec3 direction = getRandomDirection(planePosition, sampleIdx, frameOffset);\n        float cosA = clamp(dot(vec3(0.0, 1.0, 0.0), direction), 0.0, 1.0);\n        color += traceScene(position + direction * 1e-3, direction, iChannel0, float(iFrame)) * cosA;\n    }\n    color /= float(NUMBER_OF_CAUSTICS_SAMPLES);\n    \n    vec4 history = (float(iFrame) <= 1.0 || outdated) ? vec4(0.0) : texture(iChannel0, uv);\n    float weight = 1.0 / CAUSTICS_HISTORY_FRAMES;\n    fragColor = vec4(history.rgb * (1.0 - weight) + color * weight, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}