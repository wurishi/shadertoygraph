{"ver":"0.1","info":{"id":"ctffD8","date":"1692846117","viewed":42,"name":"[CODE]: Lighting System","username":"amankhan","description":"Code for adding multiple light sources to a ray marched scene. Please see Readme for an explanation.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["light","code","directional","spot","point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"[CODE]: Lighting System\" \n// by Aman Khan, 2023\n// License Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)\n\n/************* README **************\n************************************\n[Q1] Why another lighting system?\n\nTo save time and effort and most importantly stick to the DRY principle. Basic lights are needed\nin many physically based rendering scenarios. Instead of writing the same thing again and again I have \ntried to create a code base which can be copy pasted into a project to set things up quickly. Ofcourse\nthe style is mine and may not suite you. I have tried to keep it generally applicable. See Q5. \n\n[Q2] How to understand the code?\nThe main light 'models' are in the LIGHT/COLOR CALCULATIONS section. The other sections are basic\nray marching code. The idea is if you need multiple lights it should be easy to add. Just define the \nnew light based on the struct and call the light render function. Plus the code is highly commented\nto help you understand what's going on. Of course this is NOT a tutorial and hence there will be \nlimitations\n\n[Q3] Is it optimized?\nNO. The idea is to give the general framework to help you understand what's going on. Then one can \noptimize to their hearts content.\n\n[Q4] Will you adding more lights?\nYes, thats in the TODO list.\n\n[Q5] Suggestions/Criticism?\nAlways open as long as they are constructive.\n\n************ END README ************\n************************************/\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define T iTime\n\n#define AA 2 // Anti-aliasing Set to > 1 to turn on.\n\n/************** UTILS **************\n************************************/\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n/************** LIGHT/COLOR CALCULATIONS *************\n******************************************************/\n\n#define BG 0.\n#define PLANE 1.\n#define SPHERE 2.\n\nstruct DirectionalLight {\n    vec3 cLight;    // Color of light\n    vec3 dirN;      // Normalized light direction. From source to world.\n};\n\n\nstruct PointLight {\n    vec3 cLight;    // Color of light\n    vec3 pLight;    // Position of light source\n    float rMin;     // Size of source. Any point with distance to source less than this is inside the source.\n    float mDist;    // Maximum distance around which intensity drops to 0.\n};\n\n\nstruct SpotLight {\n    vec3 cLight;    // Color of light\n    vec3 pLight;    // Position of light source\n    float rMin;     // Size of source. Any point with distance to source less than this is inside the source.\n    float mDist;    // Maximum distance around which intensity drops to 0.\n    vec3 slDirN;    // Direction of the light. From source to world. Normalized.\n    float umbra;    // Angle of umbra in degrees.\n    float penumbra; // Angle of penumbra in degrees.\n};\n\nvec3 GetBg() {\n    return vec3(0);\n}\n\nvec3 RenderDirectionalLight(vec3 p, vec3 n, DirectionalLight dl) {\n    vec3 cLight = dl.cLight; // Light Color\n    vec3 l = dl.dirN; // Light Direction. Normalized\n    \n    // Ray density based on light dir and surface normal.\n    float density = clamp(dot(l, n), 0., 1.);\n    \n    return cLight*density;\n}\n\nvec3 RenderPointLight(vec3 p, vec3 n, PointLight pl) {\n    vec3 lightPos = pl.pLight; // Light position\n    vec3 cLight = pl.cLight; // Light Color\n    float rMin = pl.rMin; // Minimum light dimension. Points closer than this would be inside the light source.\n    \n    vec3 l = lightPos-p; // Vector to light from point\n    float r = length(l); // Distance to light from point\n    l /= r; // Normalize the vector\n    \n    // Falloff window function. Ref: Unreal/Frostbite Engine\n    float w = 1. - pow(r/pl.mDist, 4.);\n    w = pow(max(w, 0.), 2.);\n    \n    // Light Attenuation with distance. Ref: CryEngine/Frostbite.\n    float attn_dist = pow(5./max(r, rMin), 2.)*w;\n    \n    // Ray density based on light dir and surface normal.\n    float density = max(dot(l, n), 0.);\n    \n    return cLight*density*attn_dist;\n}\n\nvec3 RenderSpotLight(vec3 p, vec3 n, SpotLight sl) {\n    vec3 lightPos = sl.pLight; // Light position\n    vec3 cLight = sl.cLight; // Light Color\n    float rMin = sl.rMin; // Minimum light dimension. Points closer than this would be inside the light source.\n    \n    vec3 l = lightPos-p; // Vector to light from point\n    float r = length(l); // Distance to light from point\n    l /= r; // Normalize the vector\n    \n    // Spotlight direction attenuation calc.\n    vec3 s = sl.slDirN; // Spotlight direction. From source to world.\n    float um = radians(sl.umbra); // Umbra Region\n    float pum = radians(sl.penumbra); // Penumbra Region\n    float t = (dot(s, -l) - cos(um)) / (cos(pum) - cos(um));\n    t = clamp(t, 0., 1.);\n    //float attn_dir = t * t; // Frosbite Engine\n    float attn_dir = t*t*(3.-2.*t); // ThreeJS\n    \n    // Falloff window function. Ref: Unreal/Frostbite Engine\n    float w = 1. - pow(r/sl.mDist, 4.);\n    w = pow(max(w, 0.), 2.);\n    \n    // Light Attenuation with distance. Ref: CryEngine/Frostbite.\n    float attn_dist = pow(5./max(r, rMin), 2.)*w;\n    \n    // Ray density based on light dir and surface normal.\n    float density = max(dot(l, n), 0.);\n    \n    return cLight*density*attn_dist*attn_dir;\n}\n\nvec3 GetLight(vec3 p, vec3 surf, vec3 unlit, vec3 n) {\n    \n    // Add directional light\n    DirectionalLight dl = DirectionalLight(\n        vec3(1),\n        vec3(0,1,0)\n    );\n    vec3 res = unlit + RenderDirectionalLight(p, n, dl)*0.1*surf;\n    \n    vec3 q = p;\n    q.xz *= Rot(iTime);\n    // Add Spot light\n    SpotLight sl = SpotLight(\n        vec3(0.9, 0.4, 0.1),\n        vec3(-2, 4, 0),\n        0.1,\n        MAX_DIST,\n        normalize(-vec3(-5, 5, 0)),\n        45.,\n        35.\n    );\n    res += RenderSpotLight(q, n, sl)*surf;\n    q = p;\n    q.xz *= Rot(-iTime);\n    // Add point light\n    PointLight pl = PointLight(\n        vec3(0.1, 0.4, 0.9),\n        vec3(2, 4, 0),\n        0.1,\n        MAX_DIST\n    );\n    res += RenderPointLight(q, n, pl)*surf;\n    \n    return res;\n}\n\nvec3 GetColor(vec3 p, float o, vec3 n) {\n    vec3 unlit = vec3(0); // Defines global color when light doesn't reach object\n    vec3 surf = vec3(0); // Placeholder for color of objects.\n    \n    if(o == BG) return GetBg();\n    \n    if(o == PLANE) surf = vec3(0.5);\n    if(o == SPHERE) surf = vec3(1);\n    \n    return GetLight(p, surf, unlit, n);\n}\n\n/************** SDFs **************\n***********************************/\n\nfloat sdSphere(vec3 p, vec3 c, float r) {\n\treturn length(p - c) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, vec3 q) {\n\treturn dot(p - q, n) - 0.1;\n}\n\n/************** RAYMARCH *************\n**************************************/\n\nvec2 GetDist(vec3 p) {\n    float sphere = sdSphere(p, vec3(0), 0.5);\n    float plane = sdPlane(p, vec3(0, 1, 0), vec3(0, -1, 0));\n    \n    float d = min(sphere, plane);\n    \n    if(sphere < plane) return vec2(d, SPHERE);\n    \n    return vec2(d, PLANE);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        if(abs(dS.x)<SURF_DIST) return vec2(dO, dS.y);\n        if(dO>MAX_DIST) break;\n    }\n    \n    return vec2(dO, BG);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 m = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    ro.yz *= Rot(-m.y*PI);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 col = GetBg();\n    \n#if AA>1\n    for(int m=0; m<AA; m++)\n    for(int n=0; n<AA; n++)\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif        \n\n        vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n        vec2 d = RayMarch(ro, rd);\n\n        if(d.x<MAX_DIST) {\n            vec3 p = ro + rd * d.x;\n            vec3 n = GetNormal(p);\n\n            col += GetColor(p, d.y, n);\n            col = mix(col, GetBg(), smoothstep(5., MAX_DIST, d.x));\n        }   \n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    //col = pow(col, vec3(.4545));\t// gamma correction\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}