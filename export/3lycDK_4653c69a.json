{"ver":"0.1","info":{"id":"3lycDK","date":"1611740849","viewed":162,"name":"White Noise and Blue Noise","username":"Arion","description":"White Noise and Blue Noise","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","halton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float x)\n{\n\tfloat y = fract(sin(x)*753.5453123);\n\treturn y;\n}\n\n// white noise with UV\nfloat rand(vec2 st)\n{\n\treturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 rand2(vec2 st)\n{\n\treturn vec2(fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123),\n\t\tfract(sin(dot(st.xy,vec2(58.218,85.363)))*12543.1556)\n\t\t);\n}\n\nvec3 rand3(vec3 st)\n{\n\treturn vec3(fract(sin(dot(st.xyz,vec3(12.9898,78.233,521.689)))*43758.5453123),\n\t\tfract(sin(dot(st.xyz,vec3(58.218,85.363,55.689)))*12543.1556),\n\t\tfract(sin(dot(st.xyz,vec3(15.48,6.263,541.324)))*1854.2156)\n\t\t);\n}\n\nfloat Worley( vec2 x )\n{\n    vec2 p = floor( x );\n    vec2 w = fract( x );\n\n    float m = 1.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  neighbor = vec2( float(i), float(j) );\n        vec2  neighbor_w = rand2( p + neighbor );  // 全部九个位置上的位置\n        // 用于动态Worley\n    \t//neighbor_w = 0.5 + 0.5*sin(_Time.x+6.2831*neighbor_w);\n        vec2  r = neighbor + neighbor_w - w;\n        float d = dot( r, r );\n        m = min(m, d);\n    }\n    return m ;\n}\n\n\n// white noise, from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\nfloat blueNoise(vec2 p)\n{\n    //int m = int(p.y*iResolution.y*iResolution.x + p.x*iResolution.x) + iFrame;\n    //m = m%iFrame;\n    //vec2 n = halton(m);\n    \n    int mx = int(p.x*iResolution.x);// + int(iFrame);\n    int my = int(p.y*iResolution.y);// + int(iFrame);\n    \n    mx = mx;// % int(512);\n    my = my;// % int(1024);\n    \n    vec2 nx = halton(int(mx));\n    vec2 ny = halton(int(my));\n    \n    float h = 0.5* (nx.x + ny.x );\n    \n    return h;\n}\n\n// from https://www.shadertoy.com/view/XtGBDW\n#define LEVEL 15U\n#define WIDTH ( (1U << LEVEL) )\n#define AREA ( WIDTH * WIDTH )\nuint HilbertIndex( uvec2 Position )\n{   \n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return Index;\n}\n\nfloat blueNoise2(vec2 p)\n{\n    uint y = HilbertIndex( uvec2(p*iResolution.xy) );\n    y += uint(iFrame);\n    uint x =  y % (1u << 17u);\n    const float phi = 2.0/(sqrt(5.0)+1.0);\n\tfloat c = fract(0.5+phi*float(x));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 coord = vec2(sin(uv.x+iTime), cos(uv.y+iTime));//vec2( uv.x + iTime, uv.y * iTime);//  \n    \n    float noise_white = rand(coord); \n    \n    float noise_worley = Worley(coord*10.0);\n    \n    float noise_blue = blueNoise2(uv);\n    \n    float o = noise_white;\n    float p = 0.001;\n    if(uv.x>(0.5 + p) )\n        o = noise_blue;\n    else if(uv.x>(0.5 - p) && uv.x <(0.5+p))\n        o = 0.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(o,o,o);// 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}