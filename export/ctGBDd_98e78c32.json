{"ver":"0.1","info":{"id":"ctGBDd","date":"1702613784","viewed":81,"name":"Bumpy Analytic Normals RRD","username":"Kerdek","description":"analytic normals on this surface","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"wlsyD7","parentname":"Rounded Rhombic Dodecahedron"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Original Shader by yx: https://www.shadertoy.com/view/Wd2Gzt\n\nconst vec3 color = vec3(0.5, 0.55, 0.6);\nfloat gloss_ior = 2.7;\nfloat gloss_cosine_power = 100.0;\nconst int light_count = 3;\nconst vec3 lightdir[light_count] = vec3[](\n  normalize(vec3(-1.0, 1.0, 2.0)),\n  normalize(vec3(-1.0, 1.0, -2.0)),\n  normalize(vec3(1.0, 1.0, 0.0)));\nconst vec3 light_color[light_count] = vec3[](\n  vec3(0.6, 0.2, 0.2),\n  vec3(0.2, 0.6, 0.2),\n  vec3(0.2, 0.2, 0.6));\nconst float bump_freq = 1.0;\nconst float bump_power = 2.0;\nconst float bump_threshold = -3.0;\nconst float bump_scale = -0.5;\nconst int bump_harmonics = 20;\nconst float ss = 1.0 / 2.0;\n\n// handy nil vector\nconst vec4 nil = vec4(0.0);\n\n// basis vectors\nconst vec4 dx = vec4(1.0, nil.xyz);\nconst vec4 dy = dx.wxyz;\nconst vec4 dz = dy.wxyz;\nconst vec4 dw = dz.wxyz;\n\nmat4 translate(\n  vec4 by) {\n  return mat4(dx, dy, dz, by + dw); }\n\nmat4 scale(\n  float by) {\n  return mat4(by * dx, by * dy, by * dz, dw); }\n\nmat4 rotate(\n  vec4 axis,\n  float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  vec4 l = (1.0 - c) * axis;\n  vec3 m = l.xyz * axis.yzx;\n  vec4 n = s * axis;\n  return mat4(\n    l.x * axis.x, m.x - n.z, m.z + n.y, 0.0,\n    m.x + n.z, l.y * axis.y, m.y - n.x, 0.0,\n    m.z - n.y, m.y + n.x, l.z * axis.z, 0.0,\n    nil) + scale(c); }\n\nvec3 projectu(vec3 v, vec3 u) {\n  return u * dot(v, u); }\n\nvec3 rejectu(vec3 v, vec3 u) {\n  return v - projectu(v, u); }\n\n// linear sRGB component to nonlinear sR'G'B' component\nfloat srgb_gamma(\n  float v) {\n  return v <= 0.0031308\n    ? v * 12.92\n    : 1.055 * pow(v, 0.41666666666) - 0.055; }\n\nvec3 srgb_gamma(\n  vec3 v) {\n  return vec3(\n    srgb_gamma(v.r),\n    srgb_gamma(v.g),\n    srgb_gamma(v.b)); }\n\n// apparently this transforms linear srgb to aces srgb\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0); }\n\n// i can't believe it's an LCG\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst int lcgbase0 = 594156893;\nconst ivec3 lcgbase = lcgbase0 * ivec3(37769685, 26757677, 20501397);\n  \nfloat hash3d(\n  int seed,\n  ivec3 p) {\n  p *= lcgbase;\n  return pow(2.0, -30.0) * float((lcgbase0 * (seed +\n  (p.x ^ p.y ^ p.z))) >> 1); }\n\n// perlin noise with gradient\nvec4 noise3d(\n  int seed,\n  vec3 p) {\n  vec3 f = floor(p);\n  ivec3 ip = ivec3(f);\n  f = p - f;\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  vec3 v = 1.0 - u;\n  vec3 w = -6.0 * (f - 1.0) * f;\n  float k[8] = float[8](\n    hash3d(seed, ip + ivec3(0, 0, 0)),\n    hash3d(seed, ip + ivec3(1, 0, 0)),\n    hash3d(seed, ip + ivec3(0, 1, 0)),\n    hash3d(seed, ip + ivec3(1, 1, 0)),\n    hash3d(seed, ip + ivec3(0, 0, 1)),\n    hash3d(seed, ip + ivec3(1, 0, 1)),\n    hash3d(seed, ip + ivec3(0, 1, 1)),\n    hash3d(seed, ip + ivec3(1, 1, 1)));\n  return vec4(\n   - w.x * v.y * v.z * k[0]\n   + w.x * v.y * v.z * k[1]\n   - w.x * u.y * v.z * k[2]\n   + w.x * u.y * v.z * k[3]\n   - w.x * v.y * u.z * k[4]\n   + w.x * v.y * u.z * k[5]\n   - w.x * u.y * u.z * k[6]\n   + w.x * u.y * u.z * k[7],\n\n   - v.x * w.y * v.z * k[0]\n   - u.x * w.y * v.z * k[1]\n   + v.x * w.y * v.z * k[2]\n   + u.x * w.y * v.z * k[3]\n   - v.x * w.y * u.z * k[4]\n   - u.x * w.y * u.z * k[5]\n   + v.x * w.y * u.z * k[6]\n   + u.x * w.y * u.z * k[7],\n\n   - v.x * v.y * w.z * k[0]\n   - u.x * v.y * w.z * k[1]\n   - v.x * u.y * w.z * k[2]\n   - u.x * u.y * w.z * k[3]\n   + v.x * v.y * w.z * k[4]\n   + u.x * v.y * w.z * k[5]\n   + v.x * u.y * w.z * k[6]\n   + u.x * u.y * w.z * k[7],\n\n   + v.x * v.y * v.z * k[0]\n   + u.x * v.y * v.z * k[1]\n   + v.x * u.y * v.z * k[2]\n   + u.x * u.y * v.z * k[3]\n   + v.x * v.y * u.z * k[4]\n   + u.x * v.y * u.z * k[5]\n   + v.x * u.y * u.z * k[6]\n   + u.x * u.y * u.z * k[7]); }\n\n// fractal noise with gradient\nvec4 fractal3d(\n  int seed,\n  vec3 p,\n  float division,\n  float attenuation,\n  int harmonics) {\n  vec4 v = nil;\n  float ampl = 1.0;\n  float freq = 1.0;\n  for (int i = 0; i < harmonics; i++) {\n    vec4 s = noise3d(seed, freq * p);\n    s.xyz *= freq;\n    s *= ampl;\n    v += s;\n    freq += division;\n    ampl += attenuation;\n    seed++; }\n  return v; }\n\nvec2 rotate(vec2 a, float b) {\n  float c = cos(b);\n  float s = sin(b);\n  return vec2(\n    a.x * c - a.y * s,\n    a.x * s + a.y * c); }\n\nvec4 constg(float c) {\n  return vec4(nil.www, c); }\n\nmat4 constg(vec3 c) {\n  return mat4(\n    constg(c.x),\n    constg(c.y),\n    constg(c.z),\n    dw); }\n\nmat4 ivg(vec3 c) {\n  return mat4(\n    dx.xyz, c.x,\n    dy.xyz, c.y,\n    dz.xyz, c.z,\n    dw); }\n\nvec4 sumg(vec4 p, vec4 q) {\n  return p + q; }\n\nmat4 sumg(mat4 p, mat4 q) {\n  p += q;\n  p[3] = dw;\n  return p; }\n\nvec4 sqrtg(vec4 p) {\n  float fin = sqrt(p.w);\n  return vec4(\n    0.5 / fin * p.xyz,\n    fin); }\n\nmat4 sqrtg(mat4 p) {\n  return mat4(\n    sqrtg(p[0]),\n    sqrtg(p[1]),\n    sqrtg(p[2]),\n    dw); }\n\nvec4 powg(vec4 p, float c) {\n  return vec4(\n    c * pow(p.w, c - 1.0) * p.xyz,\n    pow(p.w, c)); }\n\nmat4 powg(mat4 p, float c) {\n  return mat4(\n    powg(p[0], c),\n    powg(p[1], c),\n    powg(p[2], c),\n    dw); }\n\nmat4 rotatelg(mat4 p) {\n  return mat4(\n    p[1], p[2], p[0], dw); }\n\nmat4 scaleg(mat4 p, float c) {\n  p *= c;\n  p[3] = dw;\n  return p; }\n\nvec4 maxg(vec4 p, vec4 q) {\n  return p.w > q.w ? p : q; }\n  \nvec4 ming(vec4 p, vec4 q) {\n  return p.w < q.w ? p : q; }\n\nmat4 maxg(mat4 p, mat4 q) {\n  return mat4(\n    maxg(p[0], q[0]),\n    maxg(p[1], q[1]),\n    maxg(p[2], q[2]),\n    dw); }\n  \nmat4 ming(mat4 p, mat4 q) {\n  return mat4(\n    ming(p[0], q[0]),\n    ming(p[1], q[1]),\n    ming(p[2], q[2]),\n    dw); }\n\nvec4 lengthg(mat4 p) {\n  return sqrtg(sumg(sumg(powg(p[0], 2.0), powg(p[1], 2.0)), powg(p[2], 2.0))); }\n\nvec4 logisticg(\n  vec4 v) {\n  float q = 1.0 / (1.0 + exp(v.w));\n  return vec4(\n    (q - q * q) * v.xyz,\n    1.0 / (1.0 + exp(-v.w))); }\n\nvec4 scene(mat4 p) {\n  float offset = 0.05 * (1.0 + cos(0.01 * float(iFrame)));\n  float radius = 0.5 - offset;\n  p = sqrtg(sumg(powg(p, 2.0), constg(vec3(pow(offset, 2.0)))));\n  mat4 q = p;\n  q[2] = 1.0 / 1.0 * sumg(0.5 * 1.0 * sqrtg(sumg(sumg(powg(p[0], 2.0), powg(p[1], 2.0)), powg(p[2], 2.0))), constg(-radius));\n  q[0] = sumg(0.50 * sumg(p[0], p[1]), constg(-radius));\n  q[1] = sumg(0.50 * sumg(p[1], p[2]), constg(-radius));\n  //q[2] = sumg(0.5 * sumg(p[2], p[0]), constg(-radius));\n  return sumg(lengthg(maxg(q, constg(vec3(0.0)))), constg(-offset)); }\n\nbool trace(vec3 cam, vec3 dir, out vec3 p, out vec3 n) {\n  float t;\n  for(int i = 0; i < 24; ++i) {\n    p = cam + dir * t;\n    vec4 s = scene(ivg(p));\n    n = normalize(s.xyz);\n    float dt = dot(dir, n);\n    // amazing convex surface optimization to ray-marching equation\n    t += s.w / -dt;\n    if (s.w < 1e-5) {\n      return true; } }\n  return false; }\n\nvoid cameraspin(inout vec3 p) {\n    p.yz = rotate(p.yz, 0.5 * sin(exp(-6.0) * float(iFrame)));\n    p.xz = rotate(p.xz, float(iFrame) * 0.002); }\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    vec3 cam = vec3(0.0, 0.0, -20.0);\n    cameraspin(cam);\n    out_color = vec4(0.0);\n    for (vec2 ij = vec2(0.0); ij.x < 1.0; ij.x += ss) {\n      for (ij.y = 0.0; ij.y < 1.0; ij.y += ss) {\n        vec2 uv = (fragCoord.xy + ij) / iResolution.xy - 0.5;\n        uv.x *= iResolution.x / iResolution.y;\n        vec3 dir = normalize(vec3(uv, 10.0));\n        cameraspin(dir);\n        vec3 p, n;\n        if (trace(cam, dir, p, n)) {\n          vec4 bump = fractal3d(\n            0, bump_freq * p,\n            1.0, 0.0,\n            bump_harmonics);\n          bump.xyz *= bump_freq;\n          bump = bump_scale * logisticg(bump_power * sumg(bump, constg(bump_threshold)));\n          bump.xyz = rejectu(bump.xyz, n);\n          vec3 bumpn = normalize(n - bump.xyz);\n          if (iMouse.z > 0.0) {\n            out_color.rgb += 0.5 + 0.5 * bumpn; }\n          else {\n            vec3 fresnel_n = normalize(n + (0.5 + 0.5 * dot(bumpn, dir)) * bump.xyz);\n            float dt1 = -dot(dir, fresnel_n);\n            float ior22 = pow(gloss_ior, 2.0);\n            float dt12 = pow(dt1, 2.0);\n            float discriminant = -1.0 + ior22 + dt12;\n            vec3 refracted_heading = normalize(\n              dir\n              + (dt1 - sqrt(discriminant)) * fresnel_n);\n            float dt2 = -dot(refracted_heading, fresnel_n);\n            float dt22 = pow(dt2, 2.0);\n            float k1 = dt12 + ior22 * dt22;\n            float k2 = ior22 * dt12 + dt22;\n            float v = 2.0 * gloss_ior * dt1 * dt2;\n            float reflectance = clamp(0.5 * (\n              (k1 - v) / (k1 + v)\n              + (k2 - v) / (k2 + v)), 0.0, 1.0);\n            float sad = exp(0.05 * bump.w * length(bump.xyz));\n            out_color.rgb += 0.1 * color * sad;\n            for (int i = 0; i < light_count; i++) {\n              float light_fraction = 0.995;\n              float lights = clamp((dot(reflect(dir, bumpn), lightdir[i])) / light_fraction, 0.0, 1.0);\n              float lightc = clamp((dot(n, lightdir[i])) / light_fraction, 0.0, 1.0);\n              out_color.rgb += color * light_color[i] * (0.2 * (1.0 - reflectance) * sad * lightc + 10.0 * reflectance * pow(lights, gloss_cosine_power) * (1.0 - pow(1.0 - lightc, gloss_cosine_power))); } } } } }\n    \n    out_color.rgb *= pow(ss, 2.0);\n    \n    if (iMouse.z <= 0.0) {\n        vec2 uv = (fragCoord.xy) / iResolution.xy - 0.5;\n    \tout_color.rgb *= pow(color, vec3(2.0 * dot(uv,uv)));\n        out_color.rgb = max(vec3(0.0), out_color.rgb);\n        out_color.rgb = aces(out_color.rgb);\n        out_color.rgb = min(vec3(1.0), out_color.rgb);\n    \tout_color.rgb = srgb_gamma(out_color.rgb); } }","name":"Image","description":"","type":"image"}]}