{"ver":"0.1","info":{"id":"dtyBWt","date":"1702622584","viewed":47,"name":"Mandelbox 3D","username":"noahsk","description":"By Pedro Schneider. This shader targets to achieve a mathematical render of Mandelbrot's Box, a fractal based on the same Mandelbrots's Formula used to construct the well known Mandelbrot's set.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","mandelbrot","glsl","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n*\n*\n*\n*     Uploaded by Noah Kahn on December 15th 2023\n*     All credits to the author below.\n*     Hosted here as the author left the ShaderToy link blank\n*     and it should to be seen by more.\n*\n*\n* /\n\n/**\n * https://github.com/pedrotrschneider/shader-fractals/blob/main/3D/Mandelbox.glsl\n *\n * @file Mandelbox.glsl\n *\n * @brief This shader targets to achieve a mathematical render of Mandelbrot's Box, a fractal based on the same\n * Mandelbrots's Formula used to construct the well known Mandelbrot's set.\n *\n * @author Pedro Schneider <pedrotrschneider@gmail.com>\n *\n * @date 06/2020\n *\n * Direct link to ShaderToy: <not available yet>\n*/\n\n#define MaximumRaySteps 2500\n#define MaximumDistance 200.\n#define MinimumDistance .001\n#define PI 3.141592653589793238\n\n// TRANSFORM FUNCTIONS //\n\nmat2 Rotate (float angle) {\n  float s = sin (angle);\n  float c = cos (angle);\n\n  return mat2 (c, -s, s, c);\n}\n\nvec3 R (vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize (l - p),\n    r = normalize (cross (vec3 (0, 1, 0), f)),\n    u = cross (f, r),\n    c = p + f * z,\n    i = c + uv.x * r + uv.y * u,\n    d = normalize (i - p);\n  return d;\n}\n\n// Converts a color from the HSV colorspace to RGB\nvec3 hsv2rgb (vec3 c) {\n  vec4 K = vec4 (1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs (fract (c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix (K.xxx, clamp (p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// SDF FUNCTIONS //\n// SDF sphere\nvec4 sphere (vec4 z) {\n  float r2 = dot (z.xyz, z.xyz);\n  if (r2 < 2.0)\n    z *= (1.0 / r2);\n  else z *= 0.5;\n\n  return z;\n}\n\n// SDF box\nvec3 box (vec3 z) {\n  return clamp (z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat DE0 (vec3 pos) {\n  vec2 m = iMouse.xy / iResolution.xy;\n  vec3 from = vec3 (0.0);\n  vec3 z = pos - from;\n  float r = dot (pos - from, pos - from) * pow (length (z), 2.0);\n  return (1.0 - smoothstep (0.0, 0.01, r)) * 0.01;\n}\n\nfloat DE2 (vec3 pos) {\n  vec2 m = iMouse.xy / iResolution.xy;\n  // vec3 params = vec3 (0.22, 0.5, 0.5);\n  vec3 params = vec3 (0.5, 0.5, 0.5);\n  vec4 scale = vec4 (-20.0 * 0.272321);\n  vec4 p = vec4 (pos, 1.0), p0 = p;\n  vec4 c = vec4 (params, 0.5) - 0.5; // param = 0..1\n\n  for (float i = 0.0; i < 10.0; i++) {\n    p.xyz = box (p.xyz);\n    p = sphere (p);\n    p = p * scale + c;\n  }\n\n  return length (p.xyz) / p.w;\n}\n\nfloat DE (vec3 pos) {\n\n  float d0 = DE0 (pos);\n  float d2 = DE2 (pos);\n\n  return max (d0, d2);\n}\n\n// Marches the ray in the scene\nvec4 RayMarcher (vec3 ro, vec3 rd) {\n  float steps = 0.0;\n  float totalDistance = 0.0;\n  float minDistToScene = 100.0;\n  vec3 minDistToScenePos = ro;\n  float minDistToOrigin = 100.0;\n  vec3 minDistToOriginPos = ro;\n  vec4 col = vec4 (0.0, 0.0, 0.0, 1.0);\n  vec3 curPos = ro;\n  bool hit = false;\n\n  for (steps = 0.0; steps < float (MaximumRaySteps); steps++) {\n    vec3 p = ro + totalDistance * rd; // Current position of the ray\n    float distance = DE (p); // Distance from the current position to the scene\n    curPos = ro + rd * totalDistance;\n    if (minDistToScene > distance) {\n      minDistToScene = distance;\n      minDistToScenePos = curPos;\n    }\n    if (minDistToOrigin > length (curPos)) {\n      minDistToOrigin = length (curPos);\n      minDistToOriginPos = curPos;\n    }\n    totalDistance += distance; // Increases the total distance armched\n    if (distance < MinimumDistance) {\n      hit = true;\n      break; // If the ray marched more than the max steps or the max distance, breake out\n    }\n    else if (distance > MaximumDistance) {\n      break;\n    }\n  }\n\n  float iterations = float (steps) + log (log (MaximumDistance)) / log (2.0) - log (log (dot (curPos, curPos))) / log (2.0);\n\n  if (hit) {\n    col.rgb = vec3 (0.8 + (length (curPos) / 10.0), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n  }\n\n  col.rgb /= steps * 0.08; // Ambeint occlusion\n  col.rgb /= pow (distance (ro, minDistToScenePos), 2.0);\n  col.rgb *= 20.0;\n\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  //uv *= 1.5;\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  vec3 ro = vec3 (0, 0, -2.0); // Ray origin\n  ro.yz *= Rotate ((iTime * PI + 1.0) / 20.0); // Rotate thew ray with the mouse rotation\n  ro.xz *= Rotate (iTime * 2.0 * PI / 10.0);\n  vec3 rd = R (uv, ro, vec3 (0, 0, 1), 1.); // Ray direction (based on mouse rotation)\n\n  vec4 col = RayMarcher (ro, rd);\n\n  // Output to screen\n  fragColor = vec4 (col);\n}","name":"Image","description":"","type":"image"}]}