{"ver":"0.1","info":{"id":"DsjyWt","date":"1688332918","viewed":245,"name":"London Star Trails","username":"13rac1","description":"Long exposure of star trails around Polaris, the North Star, over a London night. Click/tap mouse to move the star, drag for pointless rotations.","likes":19,"published":1,"flags":0,"usePreview":1,"tags":["camera","space","stars","night","london"],"hasliked":0,"parentid":"cd2yW3","parentname":"Polaris Star Trails"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * London Star Trails\n * \n * Using the only Shadertoy texture with a visible sky to create a long exposure star trail cityscape.\n *\n * Notes:\n * - Based on my fullscreen Polaris Star Trails https://www.shadertoy.com/view/cd2yW3\n * - Street light positions only work correctly on 16/9 displays.\n * - The texture masking could use work.\n * \n */\n\n#define PI 3.1415926538\n#define TWOPI (2.0 * PI)\n#define VIEW_SCALE 13.0\n#define TRAIL_COUNT 60.0\n// Radian length of the star trails, aka \"exposure time\"\n#define TRAIL_RAD TWOPI * 0.05\n#define TRAIL_LAYERS 18.0\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nvec3 light(vec2 pos, float bulbSize, float glowSize, float fade) {\n    float l = sdCircle(pos, bulbSize);\n    float c = smoothstep(0.0,fade/10.0,-l);\n    l = sdCircle(pos, glowSize);\n    return vec3(max(c, smoothstep(0.0,fade,-l)));\n}\n\n// Screen Blend Mode\n// src: https://www.shadertoy.com/view/4tSGWV\nvec3 screen(vec3 target, vec3 blend){\n    return 1.0 - (1.0 - target) * (1.0 - blend);\n}\n\n// src: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( TWOPI*(c*t+d) );\n}\n\nvec3 pSky(in float t) {    \n    // [[0.138 0.668 0.408] [0.000 0.500 0.500] [0.000 0.178 0.178] [0.000 0.338 1.148]]    \n    return palette(t,\n        vec3(0.138, 0.668, 0.408),\n        vec3(0.000, 0.500, 0.500),\n        vec3(0.000, 0.178, 0.178),\n        vec3(0.000, 0.338, 1.148)\n    );\n}\n\nvec3 pStars(in float t) {        \n    // [[0.718 0.718 1.388] [-0.922 -0.922 0.725] [-0.060 -0.060 1.028] [0.738 0.738 -0.072]]\n    return palette(t,\n        vec3(0.718, 0.718, 1.388),\n        vec3(-0.922, -0.922, 0.725),\n        vec3(-0.060, -0.060, 1.028),\n        vec3(0.738, 0.738, -0.072)\n    );\n}\n\nvec3 drawStarTrail(vec2 randSeed, float starTrail, float trailId, float dist, vec2 cStarUv) {\n    // Not all of them\n    if (random(sin(randSeed)) < 0.3) {\n        return vec3(0);\n    }\n\n    // TEST - Change all star trail starts with time\n    //float radStart = mod(0.0 + iTime, TWOPI);\n    // Radians around the circle where the star starts    \n    float radStart = random(cos(randSeed)) * TWOPI;\n    // starRadStart will never be greater than TWOPI, but starRadEnd can be\n    float radEnd = radStart + TRAIL_RAD;\n\n    // Find the coordinates of the star trail start\n    vec2 posStart = vec2(dist * cos(radStart), dist * sin(radStart));\n    // Find the coordinates of the star trail end\n    vec2 posEnd = vec2(dist * cos(radEnd), dist * sin(radEnd));\n\n    // Find the angle of the current coord, range [0, TWOPI]\n    float radCurrent = PI + atan(cStarUv.y, cStarUv.x);\n    // Find the coordinates of the current star trail\n    vec2 posCurrent = dist * vec2(cos(radCurrent), sin(radCurrent));\n\n    // If the current is less than the start value, then atan() looped.\n    if (radCurrent < radStart) {\n        // Add TWOPI to also push it out of bounds.\n        // range [0, TWOPI + TRAIL_RAD]\n        radCurrent += TWOPI;\n    }\n\n    // Return nothing if we are anywhere other than the star trail\n    if (radStart > radCurrent || radCurrent > radEnd) {\n        return vec3(0);\n    }\n    \n    // Find a reasonable star trail edge fade lenth\n    // TODO: Is there a better option for this calculation?\n    float edgeSize = sqrt(dist/1000.0);\n    \n    // Find the start/end edge distance\n    float edgeStart = distance(posStart, posCurrent);\n    float edgeEnd = distance(posCurrent, posEnd);\n    \n    // Default to no fade\n    float edgeDistance = 1.0;\n    // Fade near the start and end to avoid flat edges to star trails\n    if (edgeStart < edgeSize) {\n        edgeDistance = edgeStart/edgeSize;\n    }\n    else if (edgeEnd < edgeSize) {\n        edgeDistance = edgeEnd/edgeSize;\n    }\n    \n    // Fill star trail\n    float rand = random(randSeed * trailId);\n    // Fade out the selected color by distance to all edges\n    return edgeDistance * pow(starTrail+0.1,2.0) * pStars(rand);\n    \n}\n\nvec3 drawSky(vec2 uv, float resolutionDiviser) {\n\n    // Sky Palette [0,1]\n    vec3 col = pSky(uv.y+.5);\n    \n    uv *= VIEW_SCALE;\n       \n    vec2 cStarPos = -(iMouse.xy-iResolution.xy*.5)/resolutionDiviser*VIEW_SCALE;\n    // Center the star at startup (in the visible sky)\n    if (iMouse.x < 0.00001 && iMouse.y < 0.00001) {\n        cStarPos.x = -(iResolution.x/2.0-iResolution.x*.5)/resolutionDiviser*VIEW_SCALE;\n        cStarPos.y = -(iResolution.y/2.0-iResolution.y*.5)/resolutionDiviser*VIEW_SCALE-3.0;\n    }\n    vec2 cStarUv = uv + cStarPos;\n        \n    vec2 scaledMouse = iMouse.xy/resolutionDiviser;\n    // Rotate around the center start\n    cStarUv = rotate(cStarUv, iTime/(10.) + length(scaledMouse.xy)*5.);\n    // Draw the center star\n\tfloat cStar = sdCircle(cStarUv,0.09); \n    col += vec3(smoothstep(0.0,0.1,-cStar)) * pStars(0.43);\n        \n    // Find distance to center star\n    float dist = distance(-cStarPos,uv);\n               \n    // Create a unique ID for each trail\n    float trailId = floor(dist * TRAIL_COUNT/PI) + 1.0;\n    \n    // Create star trails from a sine wave emanating from the center star\n    float starTrail = abs(sin(dist * TRAIL_COUNT));\n        \n    // TEST - Select a color for the trail background\n    //vec3 trailColor = (mod(trailId, 2.0) < 0.5) ? vec3(0,0.7,0.2) : vec3(0,1,0.8);    \n    // TEST - Draw star trails\n    //col += trailColor * step(0.6, starTrail);\n    \n    vec2 randSeed = vec2(sin(trailId), cos(trailId));\n    \n    // Draw a few bright layers\n    for(float i = 1.0; i<3.0; i++) {\n        randSeed = tan(randSeed);\n        col = screen(col, drawStarTrail(randSeed, starTrail, trailId, dist, cStarUv));\n    }\n    // Draw many dim layers for depth\n    for(float i = 1.0; i<TRAIL_LAYERS; i++) {\n        randSeed = tan(randSeed);\n        col = screen(col, i/TRAIL_LAYERS*0.6 * drawStarTrail(randSeed, starTrail, trailId, dist, cStarUv));\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Find the diviser to handle vertical and horizontal screens.\n    float resolutionDiviser = min(iResolution.y,iResolution.x);\n    \n    // Set UV for loading texture\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 texCol = texture(iChannel0, uv).rgb;\n    \n    // White value to use as a mask\n    float texMask = 0.90;\n\n    // Set UV for sky and lights\n    uv = (fragCoord.xy-iResolution.xy*.5)/resolutionDiviser;\n\n    // Mask the city texture to make the white of the London sky transparent\n    if (texCol.r > texMask && texCol.g > texMask && texCol.b > texMask) {\n    \n        vec3 skyCol = drawSky(uv, resolutionDiviser);\n        fragColor = vec4(skyCol,1.0);\n        return;\n    }\n\n    // Draw street lights\n    vec3 lights = vec3(0.0);\n    lights = max(lights, light(uv-vec2(-0.705, 0.04), 0.037, 0.22, 0.3));\n\n    lights = max(lights, light(uv-vec2(-0.637, 0.03), 0.035, 0.22, 0.3));\n\n    lights = max(lights, light(uv-vec2(0.298, 0.03), 0.035, 0.2, 0.3));\n\n\n    lights = max(lights, light(uv-vec2(-0.225, 0.025), 0.025, 0.14, 0.3));\n    lights = max(lights, light(uv-vec2(-0.185, 0.025), 0.025, 0.14, 0.3));\n    lights = max(lights, light(uv-vec2(-0.205, 0.035), 0.025, 0.14, 0.3));\n\n    lights = max(lights, light(uv-vec2(-0.180, 0.0), 0.025, 0.14, 0.3));\n    lights = max(lights, light(uv-vec2(-0.150, 0.0), 0.025, 0.14, 0.3));\n    lights = max(lights, light(uv-vec2(-0.165, 0.01), 0.025, 0.14, 0.3));\n\n    lights = max(lights, light(uv-vec2(0.001, -0.035), 0.023, 0.14, 0.3));\n    lights = max(lights, light(uv-vec2(0.025, -0.035), 0.025, 0.14, 0.3));\n    lights = max(lights, light(uv-vec2(0.0125, -0.025), 0.025, 0.14, 0.3));\n\n    // Make it night\n    vec3 starlight = vec3(0.20,0.20,0.4);\n    texCol *= starlight;\n    // Add street lights\n    vec3 yellow = vec3(1.0,0.93,0.6);\n    texCol = screen(texCol, yellow * lights);\n\n    fragColor = vec4(texCol, 1.0);        \n}\n","name":"Image","description":"","type":"image"}]}