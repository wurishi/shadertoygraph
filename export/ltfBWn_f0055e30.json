{"ver":"0.1","info":{"id":"ltfBWn","date":"1511573185","viewed":129,"name":"Flowing grid","username":"CensoredUsername","description":"First attempt at writing a raymarching shader. Basic shading on a grid field with varied blending parameters.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.001;\nconst float MAX_DISTANCE = 1000.;\nconst float SCREEN_DISTANCE = 2.;\nconst int MAX_ITER = 120;\n\nfloat smootherstep(float e0, float e1, float x) {\n    x = clamp((x - e0) / (e1 - e0), 0., 1.);\n    return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = smootherstep(0., 1., 0.5+0.5*(b-a)/k);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = smootherstep(0., 1., 0.5+0.5*(a - b)/k);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat infcylinder(vec3 p, float r) {\n    return length(p.xy) - r;\n}\n\nfloat infcross(vec3 p, float r) {\n    return smin(infcylinder(p, r), smin(infcylinder(p.yzx, r), infcylinder(p.zxy, r), 1.15), 3.3);\n}\n\nfloat map(vec3 p, out float reduce) {\n    vec3 porig = p;\n    p += iTime * 40.0;\n    vec3 p2 = mod(p + 20., 40.) - 20.;\n\n    \n    float pabs = (porig.x + porig.y + porig.z) / 3.;\n    float a = cos(pabs / 20. * 3.14 - 3.);\n    float f = sign(a) * pow(abs(a), 0.5);\n\n    reduce = 0.75 * (abs(f) * 0.9 + 0.1);\n    return smax(\n        f * sphere(p2 / abs(f), 4.),\n        -f * infcross(p2 / abs(f), 2.7),\n        2.\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenpos = 2. * (fragCoord.xy - iResolution.xy / 2. ) / iResolution.y;\n\n\n    vec3 viewpoint_location = vec3(20.0, 10.0, 0.0);\n\n    float b = iTime / 3.;\n  \tvec3 viewpoint_direction = normalize(1. + 0.5 * vec3(cos(b), cos(b + 2.10), cos(b + 4.20)));\n  \t// create the upwards and sideways components of the reference frame.\n  \tvec3 upwards = vec3(0., 0., 1.);\n  \tvec3 viewpoint_sideways = normalize(cross(viewpoint_direction, upwards));\n  \tvec3 viewpoint_upwards = cross(viewpoint_sideways, viewpoint_direction);\n  \n  \tvec3 ray_relative_start = SCREEN_DISTANCE * viewpoint_direction +\n                              screenpos.x     * viewpoint_sideways  +\n                              screenpos.y     * viewpoint_upwards   ;\n  \n  \t// calculate initial values\n    vec3 o = viewpoint_location;\n  \tvec3 p = vec3(0., 0., 0.);\n  \tvec3 d = normalize(ray_relative_start);\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n        float reduce;\n        float r = map(o + p, reduce);\n        \n        float e = (EPSILON * length(p) / SCREEN_DISTANCE);\n        \n        if (r < e) {\n            e = 0.1;\n            vec3 ep = vec3(0.1, 0., 0.);\n            float dr_dx = map(o + p + ep.xyz, reduce) - map(o + p - ep.xyz, reduce);\n            float dr_dy = map(o + p + ep.yxz, reduce) - map(o + p - ep.yxz, reduce);\n            float dr_dz = map(o + p + ep.yzx, reduce) - map(o + p - ep.yzx, reduce);\n            vec3 normal_world = normalize(vec3(dr_dx, dr_dy, dr_dz));\n            \n            vec3 color = vec3(0.3, 0.35, 0.4);\n            \n            for (int i = 0; i < 3; i++) {\n                vec3 lightpos;\n                vec3 lightcolor;\n                if (i == 0) {\n                    lightpos = vec3(40.,  30., 140.); lightcolor = vec3(0.6, 0.7, 0.8);\n                } else if (i == 1) {\n                    lightpos = vec3(40., 150.,  20.); lightcolor = vec3(0.6, 0.7, 0.8);\n                } else {\n                    lightpos = vec3(160., 30.,  20.); lightcolor = vec3(0.6, 0.7, 0.8);\n                }\n                \n                vec3 dir = (o + p) - lightpos;\n                color += lightcolor * max(0.0, -dot(normal_world, normalize(dir))) * pow(120. / length(dir), 1.) * 0.5;\n                \n            }\n            color;\n            fragColor.xyzw = vec4(color * 60. / (length(p) + 25.) + 0.1, 1.);\n            return;\n        }\n        \n        p += d * r * reduce;\n        \n        if (length(p) > MAX_DISTANCE) {\n            break;\n        }\n    }\n    fragColor.xyzw = vec4(0.1, 0.1, 0.1, 1.);\n    return;\n    \n}","name":"Image","description":"","type":"image"}]}