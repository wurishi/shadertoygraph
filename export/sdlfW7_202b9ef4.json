{"ver":"0.1","info":{"id":"sdlfW7","date":"1644959899","viewed":184,"name":"Atmosphere - Real time shader","username":"Datablock","description":"A round green planet with an earth-like atmosphere around it. Every dot is ~300 meters.\nMovement: WASD Shift Spacebar\nSpeed control: 'cntrl'->20x 'x'->0.05x\nExposure is a bad makeshift variant.\nI dont know what causes the black strip.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nconst float gamma = 1.0;\nconst float contrast = 1.0;\nconst float exposure = 2.2*1.7;\n\nvec3 getCamPos() {\n    return vec3(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n}\n\nvec2 getCamRot() {\n    return texelFetch(iChannel0, ivec2(4, 0), 0).rg * 2.0 * PI;\n}\n\nfloat getSunAngle() {\n    return texelFetch(iChannel0, ivec2(5, 0), 0).r * 2.0 * PI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 camVec = getWorldVector(fragCoord, iResolution.xy);\n    vec2 camRot = getCamRot();\n    camVec = rotateVector(camVec, camRot);\n    \n    vec3 camPos = vec3(0.0, 0.0, -1500.0);\n    camPos += getCamPos();\n    float dist = length(camPos);\n    \n    float time = iTime * 0.5;\n    float sunangle = getSunAngle();\n    vec3 dirToSun = vec3(cos(sunangle), sin(sunangle), 0.0);\n    \n    vec3 color = calculateColor(camPos, camVec, dirToSun, time);\n    \n    //exposure calculation\n    camVec = getWorldVector(iResolution.xy*0.5, iResolution.xy);\n    camVec = rotateVector(camVec, camRot);\n    \n    float toEarth = clamp((radius - 6.5 - length(camPos)), 0.0, 1.0) + \n    clamp(dot(camVec, dirToSun)-0.8, 0.01, 1.0) + \n    max(dot(camVec, -normalize(camPos)) - clamp((clamp(dot(camVec, dirToSun), 0.0, 1.0)*(dist - planetRadius) - 100.0)/250.0, -0.4, 0.4), 0.01);\n    \n    float exposure = 3.0 / toEarth;\n    \n    vec3 mapped = vec3(1.0) - exp(-color * exposure);\n    mapped = clamp(mapped, 0.0, 1.0);\n    \n    //mapped = mapped*0.5 + 0.5*mapped*mapped*(3.0-2.0*mapped);\n    mapped *= (1.0 - contrast) + contrast * mapped*(3.0-2.0*mapped);\n    //mapped *= 0.5 + mapped * (1.5-mapped);\n    \n    mapped = pow(mapped, vec3(1.0/gamma));\n    fragColor = vec4(mapped, 1.0);\n}\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 sRGB(vec3 RGB) {\n    return max(RGB, vec3(0.0));//pow(max(RGB, vec3(0.0)), vec3(0.4545454545));\n}\n\n//----------< Stars >---------//\n\nconst int star_iterations = 10;\nconst vec3 col_star = vec3( 1.0, 0.7, 0.5 );\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nvec3 doBackgroundStars( in vec3 dir )\n{\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                           dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );\n    }\n    \n    return f * col_star;\n}\n\n//----------< Lineair algebra >----------//\n\nvec3 rotateVector(vec3 vec, vec2 rot) {\n    \n    float cx = cos(rot.x); float cy = cos(rot.y);\n    float sx = sin(rot.x); float sy = sin(rot.y);\n    mat3 RotAroundX = mat3(\n        1.0, 0.0, 0.0,\n        0.0,  cy,  sy,\n        0.0, -sy,  cy);\n    mat3 RotAroundY = mat3(\n         cx, 0.0, -sx,\n        0.0, 1.0, 0.0,\n         sx, 0.0,  cx);\n    vec = RotAroundX * vec;\n    vec = RotAroundY * vec;\n    return vec;\n}\n\nconst mat4 ScreenToCamera = mat4(\n    1.08,0   ,0   ,0,\n    0   ,0.60,0   ,0,\n    0   ,0   ,0   ,-5.0,\n    0   ,0   ,-1.0,5.0\n);\n\nvec3 getWorldVector(vec2 fragCoord, vec2 resolution) {\n    vec2 screenCoord = (fragCoord/resolution) * 2.0 - 1.0;\n    return normalize((ScreenToCamera * vec4(screenCoord, -1.0, 1.0)).xyz) * vec3(1.0,1.0,-1.0);\n}\n\n//----------< Data >----------//\n\nconst float skyBoxBrightness = 0.01;\n\nconst float epsilon = 0.001;\n\nconst float planetRadius = 637.1;\nconst float planetRadiusSquared = planetRadius * planetRadius;\nconst float radius = 647.1;\nconst float radiusSquared = radius*radius;\nconst float sunRadiusSquared = 45665301736.0;\n\nconst int inScatterPoints = 15;\nconst int opticalDepthPoints = 4;\n//612.0, 549.0, 464.0\n//700.0, 530.0, 440.0\nconst float scatteringFactor = 0.03;\nconst vec3 scatterValues = vec3(655.0, 550.0, 440.0);\nconst vec3 scatteringCoefficients = pow(vec3(400.0) / scatterValues, vec3(4.0)) * scatteringFactor;//vec3(pow(0.46,4.0),pow(0.7,4.0),pow(0.81,4.0)) * 0.05;\nconst float brightnessFactor = 5.3;\nconst float densityFalloff = 10.7;// is realistic for earth\nconst float densityFactor = 1.5;\n\nvec3 dirToSun;\n\n//----------< Atmosphere >----------//\n\nfloat raySphere(vec3 off, vec3 dir) {\n\tfloat b = dot(off, dir);\n\tfloat c = dot(off, off) - radiusSquared;\n\treturn -b + sqrt(b * b - c);\n}\n\nfloat densityAtPoint(vec3 point) {\n\tfloat heightAboveSurface = length(point) - planetRadius;\n\tfloat height01 = heightAboveSurface / (radius - planetRadius);\n\treturn exp(-height01 * densityFalloff) * (1.0 - height01) * densityFactor;\n}\n\nfloat opticalDepth(vec3 rayOrigin, vec3 rayDir, float rayLength) {\n\tfloat stepSize = rayLength / float(opticalDepthPoints - 1);\n\tvec3 dDist = rayDir * stepSize;\n\tvec3 densitySamplePoint = rayOrigin;\n\tfloat opticalDepth = 0.0;\n\tfor (int i = 0; i < opticalDepthPoints; i++) {\n\t\tfloat localDensity = densityAtPoint(densitySamplePoint);\n\t\topticalDepth += localDensity * stepSize;\n\t\tdensitySamplePoint += dDist;\n\t} return opticalDepth;\n}\n\nvec3 atmosphereColor(vec3 rayOrigin, vec3 rayDir, float rayLength, vec3 originalCol, float isPlanet) {\n    \n    float stepSize = rayLength / float(inScatterPoints - 1);\n\tvec3 dDist = rayDir * stepSize;\n\t\n\tfloat totalDensity = 0.0;\n\tvec3 inScatterPoint = rayOrigin;\n\tvec3 inScatteredLight = vec3(0.0, 0.0, 0.0);\n\tfloat viewRayOpticalDepth = 0.0;\n\t\n\tfor (int i = 0; i < inScatterPoints - 1; i++) {\n\t\tfloat li = float(i);\n        float localDensity = densityAtPoint(inScatterPoint);\n        \n\t\tfloat sunRayLength = raySphere(inScatterPoint, dirToSun);\n\t\t\n\t\tfloat sunRayOpticalDepth = opticalDepth(inScatterPoint, dirToSun, sunRayLength);\n\t\tviewRayOpticalDepth = totalDensity + localDensity * stepSize;\n        viewRayOpticalDepth *= 5.0;\n        \n\t\t//viewRayOpticalDepth = opticalDepth(inScatterPoint, -rayDir, stepSize * li);\n        \n\t\tvec3 transmittance = vec3(exp(scatteringCoefficients * -(sunRayOpticalDepth + viewRayOpticalDepth)));\n\t\ttransmittance *= 1.5;\n        \n\t\tinScatteredLight += sRGB(transmittance * scatteringCoefficients) * stepSize * localDensity;\n\t\ttotalDensity += localDensity * stepSize;\n\t\tinScatterPoint += dDist;\n\t}\n\tinScatteredLight *= brightnessFactor;\n    \n\t//---< Code For Sun >---//\n\tfloat SunSize = 0.001;\n\tfloat SunAngle = 1.0 - max(dot(rayDir, dirToSun) - (1.0 - SunSize), 0.0) / SunSize;\n\tvec3 SunTransmittance = vec3(exp(scatteringCoefficients * -SunAngle * 800.0) * pow(1.0 - SunAngle, 2.0));\n\tvec3 SunLight = totalDensity * SunTransmittance * scatteringCoefficients * 500.0;\n\tinScatteredLight += sRGB(SunLight * SunLight.r) * (1.0 - isPlanet);\n\t\n\t//---< Final Calculation >---//\n\tfloat originalColTransmittance = max(exp(-viewRayOpticalDepth / 20.0), 1.0 - length(inScatteredLight) * 1.5);\n\treturn originalCol * originalColTransmittance + inScatteredLight;\n}\n\n//----------< Main Algorithm >----------//\n\nvec3 calculateColor(vec3 camPos, vec3 rayDir, vec3 dirToSun2, float time) {\n    dirToSun = dirToSun2;\n    \n    float isPlanet = 0.0;\n    vec3 color = doBackgroundStars(rayDir) * 0.01;\n    float dist = 1000000000.0;\n    \n    //Sun\n    float sunDist = 14088840.0;\n    vec3 sunOffset = camPos - dirToSun * sunDist;\n    float bs = dot(sunOffset, rayDir);\n    float bbs = bs*bs;\n    float cs = dot(sunOffset, sunOffset) - sunRadiusSquared;\n    float ds = bbs - cs;\n    float ss = sqrt(ds);\n    float d1s = -bs - ss;\n    float d2s = -bs + ss;\n    \n    if (ds * d2s > 0.0 && d1s < dist) {\n        color = vec3(1.0, 1.0, 1.0);\n        dist = d1s;\n    }\n    \n    //Planet and Atmosphere\n    float b = dot(camPos, rayDir);\n    float bb = b*b;\n    float c = dot(camPos, camPos);\n    \n    float cp = c - planetRadiusSquared;\n    float dp = bb - cp;\n    float sp = sqrt(dp);\n    float d1p = -b - sp;\n    float d2p = -b + sp;\n    \n    if (dp * d2p > 0.0 && d1p < dist) {\n        vec3 loc = d1p * rayDir + camPos;\n        vec3 surfaceNormal = normalize(loc);\n        vec3 surfaceColor = vec3(0.282,0.435,0.220);\n        float d1 = dot(surfaceNormal, dirToSun);\n        float d2 = d1*0.9+0.1;\n        d1 = max(d1, 0.0); d2 = max(d2, 0.0);\n        vec3 extraColor = vec3(sin(10.0*(loc.x+loc.y+loc.z))*0.05);\n        extraColor += vec3(pow((sin(100.0*loc.x)+sin(100.0*loc.y)+sin(100.0*loc.z))/3.0, 3.0)*0.3);\n        float extraColorFactor = 1.0-1.0/(exp(-0.5*(d1p-20.0))+1.0);\n        color = (surfaceColor + extraColor * extraColorFactor) * (d1 + vec3(0.43,0.94,1.0) * 0.3 * d2);\n        dist = d1p;\n        isPlanet = 1.0;\n    }\n    \n    float ca = c - radiusSquared;\n    float da = bb - ca;\n    float sa = sqrt(da);\n    float d1a = max(0.0,  -b - sa);\n    float d2a = min(dist, -b + sa);\n    \n    if (da * d2a > 0.0 && d1a < dist) {\n        vec3 rayOrigin = camPos + rayDir * (d1a + epsilon);\n        float rayLength = d2a - d1a - epsilon * 2.0;\n        color = atmosphereColor(rayOrigin, rayDir, rayLength, color, isPlanet);\n    }\n    \n    //grayscale\n    //float g = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\n    //color = vec3(g);\n    \n    return color;\n}\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265359;\nconst int KEY_A = 65; const int KEY_B = 66; const int KEY_C = 67; const int KEY_D = 68; const int KEY_E = 69;\nconst int KEY_F = 70; const int KEY_G = 71; const int KEY_H = 72; const int KEY_I = 73; const int KEY_J = 74;\nconst int KEY_K = 75; const int KEY_L = 76; const int KEY_M = 77; const int KEY_N = 78; const int KEY_O = 79;\nconst int KEY_P = 80; const int KEY_Q = 81; const int KEY_R = 82; const int KEY_S = 83; const int KEYy_T = 84;\nconst int KEY_U = 85; const int KEY_V = 86; const int KEY_W = 87; const int KEY_X = 88; const int KEY_Y = 89;\nconst int KEY_Z = 90;\nconst int KEY_0 = 48; const int KEY_1 = 49; const int KEY_2 = 50; const int KEY_3 = 51; const int KEY_4 = 52;\nconst int KEY_5 = 53; const int KEY_6 = 54; const int KEY_7 = 55; const int KEY_8 = 56; const int KEY_9 = 57;\nconst int KEY_LEFT  = 37; const int KEY_RIGHT = 39; const int KEY_SHIFT = 16; const int KEY_SPACE = 32;\nconst int KEY_UP    = 38; const int KEY_DOWN  = 40; const int KEY_CNTRL = 17;\n\nfloat key(int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).r;\n}\n\nvec3 getCamPos() {\n    return vec3(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n}\n\nvec2 getCamRot() {\n    return texelFetch(iChannel0, ivec2(4, 0), 0).rg * 2.0 * PI;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float outData = 0.0;\n    \n    float speed = 50.0;\n    speed /= key(KEY_X) * 19.0 + 1.0;\n    speed *= key(KEY_CNTRL) * 19.0 + 1.0;\n    \n    vec3 dir = vec3(key(KEY_D) - key(KEY_A), key(KEY_SPACE) - key(KEY_SHIFT), key(KEY_W) - key(KEY_S));\n    dir *= speed * iTimeDelta;\n    vec3 dislocation = rotateVector(dir, getCamRot());\n    \n    switch(int(fragCoord.x)) {\n        case 0:\n            float currentX = texelFetch(iChannel0, ivec2(0), 0).r;\n            outData = currentX + dislocation.x;\n        \tbreak;\n        case 1:\n        \tfloat currentY = texelFetch(iChannel0, ivec2(1, 0), 0).r;\n            outData = currentY + dislocation.y;\n        \tbreak;\n        case 2:\n        \tfloat currentZ = texelFetch(iChannel0, ivec2(2, 0), 0).r;\n            outData = currentZ + dislocation.z;\n        \tbreak;\n        case 3:\n            vec2 mxy = iMouse.xy / iResolution.xy;\n            fragColor = vec4(mxy, 0.0, 1.0);\n            return;\n        case 4:\n            vec2 om = texelFetch(iChannel0, ivec2(3, 0), 0).rg;\n            vec2 nm = iMouse.xy / iResolution.xy;\n            vec2 dm = (nm - om) * vec2(1.0, -1.0);\n            vec2 otm = texelFetch(iChannel0, ivec2(4, 0), 0).rg;\n            vec2 ntm = otm;\n            if (iMouse.w < 0.0) ntm += dm;\n            ntm = vec2( mod(ntm.x, 1.0), mod(ntm.y, 1.0));\n            fragColor = vec4(ntm, 0.0, 1.0);\n            return;\n        case 5:\n            float currentsunpos = texelFetch(iChannel0, ivec2(5, 0), 0).r;\n            float deltasun = key(KEY_P) - key(KEY_O);\n            outData = mod(currentsunpos + deltasun * speed * 0.00003, 1.0);\n            break;\n    }\n    \n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}