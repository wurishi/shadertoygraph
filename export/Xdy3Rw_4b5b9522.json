{"ver":"0.1","info":{"id":"Xdy3Rw","date":"1453599660","viewed":168,"name":"Sphere Intersection","username":"Ramocles","description":"Simple show on the result of two spheres intersecting. The intersection is drawn as a red torus. Use the mouse in order to rotate the camera.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3draymarching","ik","sphereintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by Ramon Viladomat\n\n// Quick visualizer for 2 sphere intersection. \n\n// Sphere positons and radius here ( the movement is performed in line 50 )\n\nvec3 position1 = vec3(0.0,0.0,0.0);\nfloat radius1 = 0.8;\n\nvec3 position2 = vec3(1.0,1.0,1.0);\nfloat radius2 = 0.5;\n\nvec3 resultPosition = vec3(0.0);\nvec3 resultNormal   = vec3(0.0,1.0,0.0);\nvec3 resultLeft     = vec3(1.0,0.0,0.0);\nvec3 resultFwd      = vec3(0.0,0.0,1.0);\nfloat resultRadius  = 1.0;\nfloat resultWidth   = 0.01;\n\nvoid updateIntersection()\n{\n    vec3 AtoB = position2 - position1; \n    float dist = length(AtoB);\n    if (dist > 0.0)\n    {\n    \tfloat planeDist = ((radius1*radius1)-(radius2*radius2)+(dist*dist))/(2.0*dist);\n    \tfloat resultRadiusSqr = (radius1*radius1)-(planeDist*planeDist);\n    \n    \tif (resultRadiusSqr >= 0.0)\n    \t{\n        \tresultRadius = sqrt(resultRadiusSqr);\n            resultWidth  = 0.02;\n            \n            resultNormal   = normalize(AtoB);\n            resultPosition = position1 + resultNormal*planeDist;\n    \t}\n        else\n        {\n            resultWidth = 0.0;\n        }\n    }\n    else\n    {\n        resultWidth = 0.0;\n    }\n}\n\nvoid updateWorld()\n{\n    position2 = vec3(sin(iTime),sin(iTime*0.76),sin(iTime*0.24));\n    \n    updateIntersection();\n    resultLeft = normalize(cross(vec3(0.0,1.0,0.0),resultNormal)); \n    resultFwd  = normalize(cross(resultLeft,resultNormal)); \n}\n\n// PRIMITIVES\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float radius)\n{\n  \treturn length(p)-radius;\n}\n\n//--------------------------------------------------------------------------\nvec2 mapBg( in vec3 p)\n{\n\t//background room shape\n\tvec3 q = p; \n\tq.xz = abs(q.xz); \n\treturn vec2(min(min(p.y + 1.5,10.0 - p.y),min(10.0-q.z,10.0-q.x)),3.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{\t\n\tvec2 sphere1 = vec2(sdSphere( p-position1, radius1 ), 1.0);\n    vec2 sphere2 = vec2(sdSphere( p-position2, radius2 ), 2.0);\n    vec2 bg      = mapBg(p);\n\t\n    vec3 q = p - resultPosition;\n    vec3 q2 = vec3(dot(q,resultLeft),dot(q,resultNormal),dot(q,resultFwd));\n    vec2 intersection = vec2(sdTorus(q2,vec2(resultRadius,resultWidth)),4.0);\n    \n    vec2 res = sphere1;\n    if (res.x > sphere2.x)      res = sphere2; \n    if (res.x > bg.x)           res = bg;\n    if (res.x > intersection.x) res = intersection;\n    \n    return res;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 25.0;\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<150; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n// MATERIALS\n\nvec4 calcBgColor( in vec3 pos, in vec3 nor)\n{\n    vec3 groundtiles = 2.0*(0.5 - abs(0.5-mod(pos,vec3(0.89)))); \n\tfloat groundtileBorder = smoothstep(0.0,0.1,min(groundtiles.x,min(groundtiles.y,groundtiles.z)));//min(groundtiles.x,min(groundtiles.y,groundtiles.z)));\n\treturn groundtileBorder*vec4(0.2,0.2,0.2,0.2); \n}\n\nvec4 calcColor( in vec3 pos, in vec3 nor, float matID )\n{\n\tvec4 mate = vec4(0.0);\n\n    if (matID > 0.5) mate = vec4(0.0,0.2,0.2,0.05);\n    if (matID > 1.5) mate = vec4(0.0,0.2,0.0,0.05);\n    if (matID > 2.5) mate = calcBgColor(pos,nor);\n    if (matID > 3.5) mate = vec4(0.2,0.0,0.0,0.05);;\n\t\n\treturn mate;\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec3 e = vec3(0.0,0.0002,0.0);\n\tfloat d = map(pos).x;\n    return normalize(vec3( map(pos+e.yxx).x-d, map(pos+e.xyx).x-d, map(pos+e.xxy).x-d) );\t\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<45; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.04, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n//IQ ray-marched ambient occlusion algorithm \nfloat ambientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // update world\n    updateWorld();\n    \n    // camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\tfloat camAngle = -3.1415*2.0*mousePos.x;\n\tfloat camDist = 2.0+((1.0-mousePos.y)*2.0); \n\t\n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), 0.5, cos(camAngle)));\n    vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\n\t// render\n    vec3 color = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int k=0; k<2; k++ )\n\t{\n        // raymarch\n        vec2 tmat = intersect(camPosition,rayDir);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 position \t= camPosition + tmat.x*rayDir;\n            vec3 normal \t= calcNormal(position);\n            vec3 reflDir \t= reflect(rayDir,normal);\n\n            // material\n            vec4 mate = calcColor( position, normal, tmat.y );\n            normal = normalize( normal );\n\n            //ambient occlusion\n\t\t\tfloat occlusion = ambientOcclusion( position, normal );\n            \n            // lights\n            vec3 lightDir \t= normalize(vec3(-0.5,2.0,-1.0));\n\n            float ambient  = 0.6 + 0.4*normal.y;\n            float diffuse  = max(dot(normal,lightDir),0.0);\n            float specular = pow(clamp(dot(lightDir,reflDir),0.0,1.0),3.0);\n            float shadow   = softShadow( position, lightDir, 0.01, 10.0 );\n        \n            \n            color += attenuation*mate.xyz*occlusion;\n            color += attenuation*10.0*mate.w*mate.w*(0.5+0.5*mate.xyz)*specular*shadow*vec3(1.0,0.95,0.9);\n\n            attenuation *= 2.0*mate.w;\n            camPosition = position + 0.001*normal;\n            rayDir = reflDir;\n        }\n\t}\n\t\n\t// desat\n\tcolor = mix( color, vec3(dot(color,vec3(0.33))), 0.3 );\n\t\n    // gamma\n\tcolor = pow( color, vec3(0.45) );\n\n\t// tint\n\tcolor *= vec3(1.0,1.04,1.0);\n\n    fragColor = vec4( color,1.0 );\n}","name":"Image","description":"","type":"image"}]}