{"ver":"0.1","info":{"id":"Nst3RM","date":"1629392994","viewed":232,"name":"Water SSR","username":"Shcherbakov","description":"SSR shader written on stream: https://youtu.be/-s0NswG47JA","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["ssr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 center = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 color = center;\n    if (center.a > 0.0) {\n        color = vec4(0);\n        int RADIUS = 2;\n        for (int i = -RADIUS; i <= RADIUS; ++i) {\n            for (int j = -RADIUS; j <= RADIUS; ++j) {\n                color += texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy);\n            }\n        }\n        color /= pow(float(RADIUS * 2 + 1), 2.0);\n    }\n    vec4 gbuffer = texture(iChannel1, fragCoord / iResolution.xy);\n    vec3 frameColor = decodeColor(gbuffer.r);\n    fragColor.rgb = mix(frameColor, color.rgb, center.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float INF = 1e10;\nconst vec3 TO_LIGHT_DIR = normalize(vec3(1, 1, 0));\n\nconst float PI = 3.14;\nconst float CAMERA_SPEED = 0.0;\nconst float CAMERA_Y = 1.0;\n\nfloat towerSdf(vec3 pos) {\n    float cilindrDist = length(pos.xz);\n    float d = cilindrDist - 0.5;\n    d -= max(clamp(pos.y, -0.6, -0.2) + 0.6, 0.0) * 0.5;\n    d = max(d, pos.y + 0.3);\n    float sineScale = 0.04;\n    float sine = (\n        pow(sin(pos.y * 40.0) * 0.5 + 0.5, 0.125 * 0.25)\n        + pow(sin(atan(pos.z, pos.x) * 12.0 + float(int((pos.y) * 19.05 / PI) % 2) * PI) * 0.5 + 0.5, 0.125 * 0.25)\n        + pow(sin(cilindrDist * 40.0 + 0.5) * 0.5 + 0.5, 0.125 * 0.25)\n    );\n    d -= sine * sineScale;\n    {\n        float cil2 = length(pos.xz);\n        float dist = cil2 - 0.75;\n        dist = max(dist, -pos.y - 0.12);\n        dist = max(dist, pos.y - 0.7);\n        dist = max(dist, -cil2 + 0.7);\n        float doorCil1 = length(pos.xy * vec2(1.5, 0.5) + vec2(0, 0.3)) - 0.5;\n        dist = max(dist, -doorCil1);\n        float doorCil2 = length(pos.zy * vec2(1.5, 0.5) + vec2(0, 0.3)) - 0.5;\n        dist = max(dist, -doorCil2);\n        dist -= (pow(sin(pos.y * 40.0) * 0.5 + 0.5, 0.125 * 0.25)\n        + pow(sin(atan(pos.z, pos.x) * 12.0 + float(int((pos.y + 1.0) * 19.5 / PI) % 2) * PI) * 0.5 + 0.5, 0.125 * 0.25))\n        * sineScale;\n        d = min(d, dist);\n    }\n    return d;\n}\n\nfloat roofSdf(vec3 pos) {\n    float q = length(pos.xz);\n    pos.y -= 2.3;\n    float d = max(dot(vec2(sqrt(3.0) / 2.0, 0.5),vec2(q,pos.y)),-1.7-pos.y);\n    d += fract(pos.y * 7.0) * 0.02;\n    d -= pow(sin(atan(pos.z, pos.x) * 12.0 + float(int((pos.y + 1.0) * 22.0 / PI) % 2) * PI) * 0.5 + 0.5, 0.125 * 0.25) * 0.03;\n    return d;\n}\n\nfloat waterSdf(vec3 pos, float time) {\n    float octaves = sin(pos.x * 3.0 + pos.z * 5.0 + time * 7.0 + 32.432434)\n        + sin(pos.x * 7.0 - pos.z * 11.0 + time + 432.52342)\n        + cos(-pos.x * 13.0 + pos.z * 17.0 + time * 3.0 + 1.3323441) * 0.5\n        + cos(-pos.x * 5.5 + pos.z * 3.5 + time * 2.5 + 0.23123);\n    return pos.y + 0.2 + octaves * 0.02;\n}\n\nvec2 intersect(vec3 pos, vec3 dir, float time, bool use_water) {\n    float t = 0.0;\n    for (int i = 0; i < 150; ++i) {\n        vec3 samplePos = pos + t * dir;\n        float sdf = towerSdf(samplePos);\n        float sdf2 = roofSdf(samplePos);\n        float sdf3 = use_water ? waterSdf(samplePos, time) : 1e5;\n        if (sdf < 0.0) {\n            return vec2(t, 1.0);\n        }\n        if (sdf2 < 0.0) {\n            return vec2(t, 2.0);\n        }\n        if (sdf3 < 0.0 && t < 10.0) {\n            return vec2(t, 3.0);\n        }\n        t += max(min(min(sdf, sdf2), sdf3), 0.01);\n    }\n    return vec2(INF, 0.0);\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(towerSdf(p+h.xyy) - towerSdf(p-h.xyy),\n                           towerSdf(p+h.yxy) - towerSdf(p-h.yxy),\n                           towerSdf(p+h.yyx) - towerSdf(p-h.yyx) ) );\n}\n\nvec3 calcNormalRoof( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(roofSdf(p+h.xyy) - roofSdf(p-h.xyy),\n                           roofSdf(p+h.yxy) - roofSdf(p-h.yxy),\n                           roofSdf(p+h.yyx) - roofSdf(p-h.yyx) ) );\n}\n\nvec3 calcNormalWater( in vec3 p, float time ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(waterSdf(p+h.xyy, time) - waterSdf(p-h.xyy, time),\n                           waterSdf(p+h.yxy, time) - waterSdf(p-h.yxy, time),\n                           waterSdf(p+h.yyx, time) - waterSdf(p-h.yyx, time) ) );\n}\n\nvoid sampleOpaqueScene(vec3 pos, vec3 dir, float time, inout vec3 color, inout float dist, samplerCube sky, sampler2D tex, sampler2D tex2) {\n    vec2 dist_mat = intersect(pos, dir, time, false);\n    dist = dist_mat.x;\n    if (dist_mat.x == INF) {\n        color = texture(sky, dir).rgb;\n    } else {\n        vec3 worldPos = pos + dist_mat.x * dir;\n        vec2 shadowCast = intersect(worldPos + TO_LIGHT_DIR * 1e-1, TO_LIGHT_DIR, time, false);\n        float shadowVal = shadowCast.x == INF ? 1.0 : 0.0;\n        vec3 col = vec3(0.7, 0.7, 0.7);\n        vec3 normal;\n        if (dist_mat.y == 1.0) {\n            normal = calcNormal(worldPos);\n            vec3 samplePos = worldPos * 1.0;\n            vec3 x = texture(tex, samplePos.yz).xyz;\n            vec3 y = texture(tex, samplePos.zx).xyz;\n            vec3 z = texture(tex, samplePos.xy).xyz;\n\n            // blend factors\n            vec3 w = pow(abs(normal), vec3(1));\n            // blend and return\n            col = ((x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z)).xxx;\n        } else if (dist_mat.y == 2.0) {\n            col = vec3(0.7, 0.2, 0.2);\n            normal = calcNormalRoof(worldPos);\n            vec3 samplePos = worldPos * 5.0;\n            vec3 x = texture(tex2, samplePos.yz).xyz;\n            vec3 y = texture(tex2, samplePos.zx).xyz;\n            vec3 z = texture(tex2, samplePos.xy).xyz;\n\n            // blend factors\n            vec3 w = pow(abs(normal), vec3(1));\n            // blend and return\n            col = ((x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z)).xxx * col;\n        }\n        color = (max(0.0, dot(normal, TO_LIGHT_DIR)) * shadowVal + texture(sky, normal).rgb * 0.3) * col;\n    }\n}\n\nstruct Gbuffer\n{\n    vec3 color;\n    vec3 normal;\n    float depth;\n    float transparency;\n};\n\nvoid sampleScene(vec3 pos, vec3 dir, float time, inout Gbuffer gbuffer, samplerCube sky, sampler2D tex, sampler2D tex2) {\n    vec2 dist_mat = intersect(pos, dir, time, true);\n    bool underwater = false;\n    gbuffer.transparency = 0.0;\n    gbuffer.depth = dist_mat.x;\n    if (dist_mat.x == INF) {\n        gbuffer.color = texture(sky, dir).rgb;\n    } else {\n        vec3 worldPos = pos + dist_mat.x * dir;\n        vec2 shadowCast = intersect(worldPos + TO_LIGHT_DIR * 1e-1, TO_LIGHT_DIR, time, false);\n        float shadowVal = shadowCast.x == INF ? 1.0 : 0.0;\n        vec3 col = vec3(0.7, 0.7, 0.7);\n        if (dist_mat.y == 1.0) {\n            gbuffer.normal = calcNormal(worldPos);\n            vec3 samplePos = worldPos * 1.0;\n            vec3 x = texture(tex, samplePos.yz).xyz;\n            vec3 y = texture(tex, samplePos.zx).xyz;\n            vec3 z = texture(tex, samplePos.xy).xyz;\n\n            // blend factors\n            vec3 w = pow(abs(gbuffer.normal), vec3(1));\n            // blend and return\n            col = ((x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z)).xxx;\n        } else if (dist_mat.y == 2.0) {\n            col = vec3(0.7, 0.2, 0.2);\n            gbuffer.normal = calcNormalRoof(worldPos);\n            vec3 samplePos = worldPos * 5.0;\n            vec3 x = texture(tex2, samplePos.yz).xyz;\n            vec3 y = texture(tex2, samplePos.zx).xyz;\n            vec3 z = texture(tex2, samplePos.xy).xyz;\n\n            // blend factors\n            vec3 w = pow(abs(gbuffer.normal), vec3(1));\n            // blend and return\n            col = ((x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z)).xxx * col;\n        } else {\n            underwater = true;\n            float underwaterDist;\n            sampleOpaqueScene(worldPos + dir * 0.01, dir, time, col, underwaterDist, sky, tex, tex2);\n            gbuffer.normal = calcNormalWater(worldPos, time);\n            vec3 fogColor = vec3(0.35, 0.65, 0.65);\n            float fogDensity = 0.15;\n            float fog = exp(-pow(underwaterDist * fogDensity, 2.0));\n            col = mix(fogColor, col, fog);\n        }\n        if (underwater) {\n            gbuffer.color = col * vec3(0.65, 0.75, 0.9);\n            gbuffer.transparency = 0.35;\n        } else {\n            gbuffer.color = (max(0.0, dot(gbuffer.normal, TO_LIGHT_DIR)) * shadowVal + texture(sky, gbuffer.normal).rgb * 0.3) * col;\n        }\n    }\n}\n\nfloat encodeColor(vec3 color) {\n    uvec3 col = uvec3(clamp(color, 0.0, 1.0) * 255.0) << uvec3(16, 8, 0);\n    return float(col.x | col.y | col.z);\n}\n\nvec3 decodeColor(float color) {\n    uint col = uint(color);\n    return vec3((uvec3(col) >> uvec3(16, 8, 0)) & 0xFFu) / 255.0;\n}\n\nfloat encodeNormal(vec3 color) {\n    uvec3 col = uvec3((clamp(color, -1.0, 1.0) + 1.0) * 0.5 * 255.0) << uvec3(16, 8, 0);\n    return float(col.x | col.y | col.z);\n}\n\nvec3 decodeNormal(float color) {\n    uint col = uint(color);\n    return normalize(vec3((uvec3(col) >> uvec3(16, 8, 0)) & 0xFFu) / 255.0 * 2.0 - 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 CAMERA_POS = vec3(0, 1, 5);\n    const float CAMERA_DIST = 5.0;\n    CAMERA_POS = vec3(sin(iTime * CAMERA_SPEED) * CAMERA_DIST, CAMERA_Y, cos(iTime * CAMERA_SPEED) * CAMERA_DIST);\n    vec3 target = vec3(0, 0, 0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 finalColor = vec3(0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    vec3 forward = normalize(target - CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 viewVec = normalize(forward + right * uv.x + up * uv.y);\n\n    vec3 color;\n    vec3 worldPos;\n    float transparency;\n    Gbuffer gbuffer;\n    sampleScene(CAMERA_POS, viewVec, iTime, gbuffer, iChannel0, iChannel1, iChannel2);\n    \n    fragColor.r = encodeColor(gbuffer.color);\n    fragColor.g = gbuffer.transparency;\n    fragColor.b = gbuffer.depth;\n    fragColor.a = encodeNormal(gbuffer.normal);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 CAMERA_POS = vec3(0, 1, 5);\n    const float CAMERA_DIST = 5.0;\n    CAMERA_POS = vec3(sin(iTime * CAMERA_SPEED) * CAMERA_DIST, CAMERA_Y, cos(iTime * CAMERA_SPEED) * CAMERA_DIST);\n    vec3 target = vec3(0, 0, 0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 finalColor = vec3(0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    vec3 forward = normalize(target - CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 viewVec = normalize(forward + right * uv.x + up * uv.y);\n\n    vec4 gbuffer = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 color = decodeColor(gbuffer.r);\n    vec3 normal = decodeNormal(gbuffer.a);\n    float translucency = gbuffer.g;\n    vec3 worldPos = CAMERA_POS + viewVec * gbuffer.b;\n    \n    fragColor = vec4(0);\n    if (translucency > 0.0) {\n        vec3 reflected = reflect(viewVec, normal);\n        float L = 0.1;\n        vec3 reflection = vec3(0);\n        vec3 samplePos;\n        for (int i = 0; i < 10; ++i) {\n            vec3 samplePos = worldPos + L * reflected;\n            vec3 sampleViewVec = normalize(samplePos - CAMERA_POS);\n            float fowardScale = dot(sampleViewVec, forward);\n            if (fowardScale < 0.0) {\n                break;\n            }\n            vec3 scaledView = sampleViewVec / fowardScale;\n            vec2 sampleUV = vec2(dot(scaledView, right), dot(scaledView, up));\n            sampleUV = (sampleUV * iResolution.x + iResolution.xy * 0.5) / iResolution.xy;\n            vec4 sampleGbuffer = texture(iChannel0, sampleUV);\n            reflection = decodeColor(sampleGbuffer.r);\n            samplePos = CAMERA_POS + sampleViewVec * sampleGbuffer.b;\n            L = length(samplePos - worldPos);\n        }\n        float error = clamp(L / 10.0, 0.0, 1.0);\n        error *= 1.0 - max(0.0, dot(viewVec, reflect(normalize(samplePos - worldPos), normal)));\n        float fresnel = clamp(2.8 * pow(1.0+dot(viewVec, normal), 2.0), 0.0, 1.0);\n        reflection = mix(reflection, texture(iChannel1, reflected).rgb, vec3(error));\n        float blendFactor = (1.0 - translucency) * fresnel; \n        fragColor.rgb = mix(fragColor.rgb, reflection, vec3(blendFactor));\n        fragColor = vec4(reflection, blendFactor);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}