{"ver":"0.1","info":{"id":"wsKSWz","date":"1573820562","viewed":120,"name":"Ray Marching Sandbox [GudStuff]","username":"Lahusa","description":".oOo.oOo.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","torus","lighting","marching","slow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sd_sphere(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ) { vec2 q = vec2( length(p.xz), p.y ); float b = (r1-r2)/h; float a = sqrt(1.0-b*b); float k = dot(q,vec2(-b,a)); if( k < 0.0 ) return length(q) - r1; if( k > a*h ) return length(q-vec2(0.0,h)) - r2; return dot(q, vec2(a,b) ) - r1; }\n\nfloat map(vec3 pos)\n{\n    // create floor\n    float d = pos.y - -0.5;\n \n    vec3 p = pos;\n    \n    p.xz += vec2(sin(iTime), cos(iTime));\n    \n    //d = min(d, sdTorus(p, vec2(0.3, 0.1)));\n    d = min(d, sdRoundCone(p, 0.2, 0.3, 0.8*(sin(iTime*2.)+1.)));\n    //d = min(d, sd_sphere(p, 0.5));\n    //d = min(d, sd_sphere(p - vec3(0.3, 0.3, 0), 0.25));\n    //d = min(d, sd_sphere(p - vec3(-0.3, 0.3, 0), 0.25));\n\t\n    // float s = sin(iTime * 0.25);\n    // float c = cos(iTime * 0.25);\n    // p.xz *= mat2(c, -s, s, c);\n\n    // d = min(d, sd_mandelbulb(p, (sin(iTime * 0.25) + 1.1) * 8.0, 4.0));\n    \n    \n    return d;\n}\n\nvec3 calc_normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    fragCoord *= 2.0;\n\tvec2 p = (fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -2.0); // ray origin\n    vec3 rd = normalize(vec3(p, 1.5)); // ray direction\n    \n    vec3 col = vec3(0);\n    \n    /**\n     * Raymarch\n     **/\n    \n    int steps = 0;\n    float total = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        steps = i;\n        vec3 pos = ro + total * rd;\n        \n        float dist = map(pos);\n        \n        if (dist < 0.001) break; // to close\n        total += dist;\n        if (total > 20.0) { // to far\n            total *= -1.0;\n            break;\n        }\n    }\n    if(total > .0) {\n        vec3 pos = ro + total * rd;\n        vec3 normal = calc_normal(pos);\n        vec3 lightPos = vec3(0., 5., 0.);\n        vec3 lightFacing = (lightPos - pos);\n        float diffuse = clamp(dot(normal, normalize(lightFacing)), 0., 1.);\n        //(dot(normal, normalize(lightFacing))+0.2)\n        col = vec3(texture(iChannel0, reflect(pos-ro, normal)).xyz);\n    } else {\n     \tcol = texture(iChannel0, rd).xyz;   \n    }\n    //gamma correction\n    //col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}