{"ver":"0.1","info":{"id":"wljGRc","date":"1562359167","viewed":616,"name":"Moonrise kingdom","username":"skaplun","description":"Credits:\nMoon - @capitanNeptune\nWaves - @mrange\nParticles - @jaszunio15","likes":16,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","water","particles","animation","moon","simplexnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_TRACE_DISTANCE = 8.;\nconst int NUM_OF_TRACE_STEPS = 64;\nconst float EPS = .00001;\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nconst float gravity = 2.0;\nconst float waterTension = .11;\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return wave(t, a ,k, w*iTime);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return wave(t, a, k, w*iTime);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nmat2 mrot(in float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nmat2 mtrans(in mat2 m) {\n  return mat2(m[0][0], m[1][0], m[0][1], m[1][1]);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  float k = 2.5;\n  float kk = 1.2;\n  float a = ia*0.2;\n  float aa = 1.0/(kk*kk);\n\n  float h = 10.0;\n  \n  float angle = 0.0;\n\n  for (int i = 0; i < 3; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += gravityWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = gravityWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n\n  for (int i = 3; i < 7; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += capillaryWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = capillaryWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n  \n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}\n\nfloat map(vec3 p){\n    float h = sea(p.xz * 5. - vec2(1., iTime * 15.), .75).x;\n    return fPlane(p, vec3(0, 1, 0), .15 * h);\n}\n\nfloat march(in vec3 ro, in vec3 rd){\n    float h =  EPS * 2.0;\n    float t = 0.0;\n    float res = -1.0;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\t    if( h < EPS || t > MAX_TRACE_DISTANCE ) break;\n        h = map( ro+rd*t );\n        t += h * .75;\n    }\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.05, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// INNER ATMOS PROPIETIES:\n    // inner atmos inner strenght\n    #define in_inner 0.2\n    // inner atmos outer strenght\n    #define in_outer 0.2\n\n// OUTER ATMOS PROPIETIES:\n    // inner atmos inner strenght\n    #define out_inner 0.2 \n    // inner atmos outer strenght\n    #define out_outer 0.1 // 0.01 is nice too\nbool moon(vec3 eye, vec3 worldDir, out float dist, out float clr){\n    float time = iTime;\n    clr = 0.;\n    if(plane_hit(Ray(eye, worldDir), Plane(vec3(0.), vec3(0., 0., -1.)), dist)){\n    \tvec3 p = eye + worldDir * dist;\n        // LIGHT\n        vec3 l = normalize(vec3(0., 20., 5.));\n\n        // PLANET\n        float r = .5;\n        float z_in = sqrt(r*r - p.x*p.x - p.y*p.y);\n        float z_out = sqrt(-r*r + p.x*p.x + p.y*p.y);\n\n        // NORMALS\n        vec3 norm = normalize(vec3(p.x, p.y, z_in)); // normals from sphere\n        vec3 norm_out = normalize(vec3(p.x, p.y, z_out)); // normals from outside sphere\n        float e = 0.05; // planet rugosity\n        float nx = fbm(vec3(norm.x+e, norm.y,   norm.z  ))*0.5+0.5; // x normal displacement\n        float ny = fbm(vec3(norm.x,   norm.y+e, norm.z  ))*0.5+0.5; // y normal displacement\n        float nz = fbm(vec3(norm.x,   norm.y,   norm.z+e))*0.5+0.5; // z normal displacement\n        norm = normalize(vec3(norm.x*nx, norm.y*ny, norm.z*nz));\n        //norm = (norm+1.)/2.; // for normals visualization\n\n        // TEXTURE\n        float n = 1.0-(fbm(vec3(norm.x, norm.y, norm.z))*0.5+0.5); // noise for every pixel in planet\n\n        // ATMOS\n        float z_in_atm  = (r * in_outer)  / z_in - in_inner;   // inner atmos\n        float z_out_atm = (r * out_inner) / z_out - out_outer; // outer atmos\n        z_in_atm = max(0.0, z_in_atm);\n        z_out_atm = max(0.0, z_out_atm);\n\n        // DIFFUSE LIGHT\n        float diffuse = max(0.0, dot(norm, l));\n        float diffuse_out = max(0.0, dot(norm_out, l)+0.3); // +0.3 because outer atmosphere stills when inner doesn't\n\n        clr = (n * diffuse + z_in_atm * diffuse + z_out_atm * diffuse_out);\n        return true;\n    }\n    return false;\n}\n\nconst vec3 BLUE = vec3(72., 152., 206.)/255.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tglobalTime = fract(iTime * .5) * 1.5;\n\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0., .25, 3.);\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.)) * viewDir;\n    \n    float clr = 0.;\n    float dist;\n    moon(eye, worldDir, dist, clr);\n    float hit = march(eye, worldDir);\n    if(hit > 0. && hit < dist){\n        vec3 pos = eye + worldDir * hit;\n        vec3 nrm = calcNormal(pos);\n        vec3 reflected = reflect(worldDir, nrm);\n        \n        float totalClr = 0.;\n        for (int i=-1; i<2; i++){\n        \tfor (int j=-1; j<2; j++){\n        \t\tg_seed = float(base_hash(floatBitsToUint(pos.xz + vec2(i, j))))/float(0xffffffffU)+iTime;\n                vec3 rd = normalize(reflected + random_in_unit_sphere(g_seed) * .1);\n                float c = 0.;\n                moon(pos, rd, dist, c);\n                totalClr += c;\n        \t}\n        }\n        clr = totalClr/9.;\n    }\n    \n    float particles = layeredParticles(uv, eye + vec3(2., 0., iTime * 2.))\n        \t\t\t* smoothstep(.1, .05, clr);\n    clr = max(clr, particles);\n    fragColor = vec4(BLUE * clr, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float globalTime;\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat noise3D(vec3 p){\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\tif(x0>=y0)\n\t{\n\t\tif\t\t(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if\t(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse \t\t\t{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif\t\t(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if\t(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse \t\t\t{ i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t     \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n}\n\nfloat fbm(vec3 p){\n\tfloat f;\n    f  = 0.50000*(simplex3D( p )); p = p*2.01;\n    f += 0.25000*(simplex3D( p )); p = p*2.02;\n    f += 0.12500*(simplex3D( p )); p = p*2.03;\n    f += 0.06250*(simplex3D( p )); p = p*2.04;\n    f += 0.03125*(simplex3D( p )); p = p*2.05;\n    f += 0.015625*(simplex3D( p ));\n\treturn f;\n}\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nstruct Ray{vec3 origin, dir;};\nstruct Plane{ vec3 origin; vec3 normal;};\nbool plane_hit(in Ray inray, in Plane plane, out float t) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        t = dot(p0l0, plane.normal) / denom;\n        return true;\n    }\n    return false;\n}\n\n#define LAYERS_COUNT 6.0\n#define SIZE_MOD 2.0\n#define ALPHA_MOD 0.93\n#define FRONT_BLEND_DISTANCE 1.0\n#define BACK_BLEND_DISTANCE 4.0\n#define PARTICLE_SIZE 0.045\n#define FOV 1.0\n\nfloat hash12(vec2 x){\n \treturn fract(sin(dot(x, vec2(43.5287, 41.12871))) * 523.582);   \n}\n\nvec2 hash21(float x){\n \treturn fract(sin(x * vec2(24.0181, 52.1984)) * 5081.4972);   \n}\n\nvec2 rotate(vec2 point, float angle){\n \tfloat s = sin(angle);\n    float c = cos(angle);\n    return point * mat2(s, c, -c, s);\n}\n\n\n//Random point from [rootUV] to [rootUV + 1.0]\nvec2 particleCoordFromRootUV(vec2 rootUV){\n    return rotate(vec2(0.0, 1.0), globalTime * 3.0 * (hash12(rootUV) - 0.5)) * (0.5 - PARTICLE_SIZE) + rootUV + 0.5;\n}\n\n//particle shape\nfloat particleFromParticleUV(vec2 particleUV, vec2 uv)\n{\n \treturn 1.0 - smoothstep(0.0, PARTICLE_SIZE, length(particleUV - uv));   \n}\n\n//grid based particle layer\nfloat particlesLayer(vec2 uv, float seed)\n{\n   \tuv = uv + hash21(seed) * 10.0;\n    vec2 rootUV = floor(uv);\n    vec2 particleUV = particleCoordFromRootUV(rootUV);\n    float particles = particleFromParticleUV(particleUV, uv);\n    return particles;\n}\n\nfloat layerScaleFromIndex(float index)\n{\n \treturn log(pow(SIZE_MOD, index));  //Can be optimized by removing pow\n}\n\nfloat layeredParticles(vec2 screenUV, vec3 cameraPos)\n{\n    screenUV *= FOV;\n\tfloat particles = 0.0;\n    float alpha = 1.0;\n    float previousScale = 0.0;\n    float targetScale = 1.0;\n    float scale = 0.0;\n    \n    //Painting layers from front to back\n    for (float i = 0.0; i < LAYERS_COUNT; i += 1.0)\n    {\n        //depth offset\n        float offset = fract(cameraPos.z);\n        \n        //blending back and front\n        float blend = smoothstep(0.0, FRONT_BLEND_DISTANCE, i - offset + 1.0);\n        blend *= smoothstep(0.0, -BACK_BLEND_DISTANCE, i - offset + 1.0 - LAYERS_COUNT);\n        \n        float fog = mix(alpha * ALPHA_MOD, alpha, offset) * blend;\n        \n        targetScale = layerScaleFromIndex(i + 1.0);\n        \n        //dynamic scale - depends on depth offset\n        scale = mix(targetScale, previousScale, offset);\n        \n        //adding layer\n     \tparticles += particlesLayer(screenUV * scale + cameraPos.xy, floor(cameraPos.z) + i) * fog;\n        alpha *= ALPHA_MOD;\n        previousScale = targetScale;\n    }\n    \n    return particles;\n}","name":"Common","description":"","type":"common"}]}