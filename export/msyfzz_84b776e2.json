{"ver":"0.1","info":{"id":"msyfzz","date":"1697837063","viewed":115,"name":"Smoking cup","username":"athibaul","description":"Some fake smoke simulation + wave simulation for a nice cup of tea (or coffe, as you like).","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fractal brownian noise\n#define T(p) textureLod(iChannel1,(p)/256.,0.).r\nfloat fbm(vec2 p)\n{\n    p += T(p.yx*5. + iTime*0.1)*0.1;\n    return T(p)/2. + T(p*2.)/4. + T(p*4.)/8. + T(p*8.)/16. + T(p*16.)/32. + T(p*32.)/64.;\n}\n\n\nvec4 renderSmoke(vec2 u) {\n    // Render the smoke from Buffer A\n    vec4 smoke = A0(u.yx);\n    vec4 smoke_l = A0((u+vec2(-0.05,0.05)).yx);\n    vec4 smoke_l2 = A0((u+vec2(-0.05,0.05)*2.).yx);\n    vec4 smoke_light = smoke - 0.5*smoke_l - 0.4*smoke_l2;\n    smoke_light = clamp(smoke_light, 0., 1.);\n    vec4 Q = 2.*vec4(1.,0.8,0.6,0.) * dot(smoke_light, vec4(0.5,0.3,0.2,0.1));\n    Q += vec4(0.8,0.9,1.,1.) * dot(smoke, vec4(0.25)) * 0.2;\n    return Q;\n}\n\n\n// Scene : a teacup on a table\nfloat map(vec3 p) {\n    // Table and back wall\n    float d = p.z;\n    d = smin(d, 6. - p.y, 1.0);\n    \n    // Add teacup plate\n    d = min(d, sdCutHollowSphere((p-vec3(0,0,2)).xzy, 2.0, -1.5, 0.05) - 0.01 * fbm(10.*p.xy));\n    // Add teacup bowl\n    vec3 q = p - vec3(0,0,1);\n    // Noise coordinates\n    vec2 q_sph = vec2(atan(q.y,q.x), atan(q.z, length(q.xy)));\n    float fbm2 = fbm(10.*q_sph);\n    d = min(d, sdCutHollowSphere((p-vec3(0,0,1.0)).xzy, 1.0, 0.2, 0.05) + 0.01 * fbm2);\n    // Add handle\n    d = min(d, sdTorus(p-vec3(1.4,0,1.), vec2(0.35,0.1)));\n    // Add tea\n    vec2 rippleCoords = 0.5 + RSIM + (RSIM-1.)*q.xy;\n    //rippleCoords = floor(rippleCoords) + smoothstep(0.,1.,fract(rippleCoords));\n    float ripples = texture(iChannel2, rippleCoords/R).x * 0.05;\n    d = min(d, max(length(q)-1., q.z + ripples));\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    float eps = 1e-3;\n    return normalize(vec3(map(p + vec3(eps,0,0)) - map(p-vec3(eps,0,0)),\n                map(p + vec3(0,eps,0)) - map(p-vec3(0,eps,0)),\n                map(p + vec3(0,0,eps)) - map(p-vec3(0,0,eps))));\n}\n// Soft shadow calculation\n\nfloat calculateObstruction(vec3 pos, vec3 lpos, float lrad)\n{\n    // A homemade algorithm to compute obstruction\n    // Raymarch to the light source, and\n    // record the largest obstruction.\n    // We assume that if the ray passes through an object at depth\n    // d (negative distance), then the object obstructs light\n    // proportional to the relative size of d projected on the light\n    // as given by Thales's theorem.\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float d, t=lrad*0.1;\n    float obstruction=0.;\n    for(int j=0; j<128; j++)\n    {\n        d = map(pos + t*toLight);\n        obstruction = max(0.5+(-d)*distToLight/(2.*lrad*t), obstruction);\n        if(obstruction >= 1.){break;}\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lrad*t/distToLight);\n        if(t >= distToLight) break;\n    }\n    return clamp(obstruction, 0.,1.);\n}\n\nvec4 calcMatCol(vec3 p) {\n    // MatCol : vec3 color + roughness\n    vec4 matCol = vec4(vec3(0.5), 0.2);\n    vec3 q = p - vec3(0,0,1);\n    if(p.z <= 0.002 || p.y > 3.) {\n        // Table color texture\n        matCol = vec4(vec3(0.05),0.5);\n        matCol.xyz *= 0.3;\n        matCol.w = mix(0.8,0.1, smoothstep(0.5,0.9,fbm(20.*vec2(p.x, p.y+p.z))));\n    } else if(length(q) < 0.945) {\n        matCol = vec4(0.3,0.2,0.1,0.1);\n        matCol.xyz *= 0.15;\n    }\n    return matCol;\n}\n\nvec3 addLight(vec3 p, vec3 n, vec4 matCol, vec3 lpos, float lrad, vec3 lcol, vec3 camPos) {\n    float obstruction = calculateObstruction(p, lpos, lrad);\n    float shadow = (1.-obstruction);\n    float ldecay = 1. / ddot(lpos-p);\n    vec3 lightDir = normalize(lpos - p);\n    // Also use the smoke for obstruction\n    //vec3\n    \n    // Diffuse + slight subsurface scattering\n    float transmissionRange = 0.2;\n\tfloat transmission = map(p + lightDir*transmissionRange )/transmissionRange;\n    vec3 col = vec3(0);\n    vec3 diffuse = matCol.xyz * lcol * dot(n, normalize(lpos-p)) * shadow * ldecay;\n    vec3 subsurface = matCol.xyz * lcol * smoothstep(0.0,1.0,transmission) * ldecay;\n    col = 0.2*diffuse + subsurface;\n    // Specular\n    vec3 camDir = normalize(camPos - p);\n    vec3 h = normalize(camDir + lightDir);\n    float roughness = pow(matCol.w,2.0);\n    float specular = 0.1*smoothstep(1.-roughness, 1., dot(h, n)) * ldecay * shadow / (roughness*roughness); // not physically-based\n    float f0 = 0.1;\n    float costheta = dot(camDir, n);\n    float fresnel = f0 + (1.-f0) * pow(1.-costheta, 5.);\n    fresnel = clamp(fresnel, 0., 1.);\n    col = mix(col, vec3(1)*specular, fresnel);\n    return col;\n}\n\n\nMain {\n\n    vec2 u = uu(U);\n    \n    //Q = renderSmoke(u);\n    \n    vec3 camPos = vec3(0.,-3.,3);\n    \n    \n    vec2 angles = 0.5+0.1*cos(vec2(0,1.5)+0.2*iTime);\n    if(iMouse.z > 0.) {\n        angles = iMouse.xy / R;\n    }\n    camPos.yz *= rot(angles.y-0.5);\n    camPos.xy *= rot(angles.x-0.5);\n    \n    \n    vec3 camTarget = vec3(0,0,1);\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camRight = normalize(cross(camDir, vec3(0,0,1)));\n    vec3 camUp = normalize(cross(camRight, camDir));\n    float fov = 0.7;\n    vec3 r = normalize(camDir + fov * (u.x * camRight + u.y * camUp));\n    //Q.xyz = 0.5+0.5*r;\n    \n    float t = 0.;\n    vec3 p = camPos;\n    for(int i=0; i<200; i++) {\n        float d = map(p);\n        if(d < 0.001 || t > 100.) break;\n        t += d;\n        p = camPos + t*r;\n    }\n    //Q.xyz = 0.5 + 0.5*p;\n    //Q.xyz = 0.5+0.5*normal(p);\n    vec3 n = normal(p);\n    \n    \n    vec4 matCol = calcMatCol(p);\n    // Key light\n    vec3 col = addLight(p, n, matCol, vec3(-3.,0.,3.), 0.1, 80.*vec3(1.,0.9,0.8), camPos);\n    // Fill lights\n    col += addLight(p, n, matCol, vec3(0.,-3.,4.), 0.2, 5.*vec3(1.), camPos);\n    // Rim light\n    col += addLight(p, n, matCol, vec3(0.,4.,3.), 0.02, 5.*vec3(0.8,0.9,1.0), camPos);\n    \n    // Tonemapping\n    col = 1.-exp(-col);\n    Q.xyz = clamp(col, 0., 1.);\n    \n    // Add smoke\n    {\n    // Find where the ray intersects the plane y=0\n    float t1 = -camPos.y / r.y;\n    vec3 q = camPos + t1 * r;\n    vec4 smoke = renderSmoke(q.xz * 0.5 + vec2(0,-1.));\n    Q = mix(Q, Q+smoke, smoothstep(1.,2.,q.z));\n    }\n    \n    Q = sqrt(Q);\n    \n    \n    //Q = texelFetch(iChannel2, ivec2(U), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0, ivec2(U), 0)\n#define A0(u) texture(iChannel0, (0.5+0.5*(u)*R.y/R))\n#define R (iResolution.xy)\n#define uu(U) ((2.*U-R)/R.y)\n#define tScale 2.0\n#define rot(theta) mat2(cos(theta), sin(theta), -sin(theta), cos(theta))\n#define RSIM 20.\n\nfloat ddot(vec3 v) {\n    return dot(v,v);\n}\n\n\n\n\n// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//-------------------------------------\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n// sdfs by Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Smooth min by Inigo Quilez\n// https://iquilezles.org/articles/smin/\n// polynomial smooth min 2 (k=0.1)\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\nvec2 velocityField( vec2 uv, float t)\n{\n    // Velocity is the sum of the velocities of several vortex fields,\n    // each with a Kaufmann profile.\n    // https://www.shadertoy.com/view/3stcDr\n    \n    // The positions of vortices is chosen to look like a vortex street\n    // with random variation.\n    // https://en.wikipedia.org/wiki/K%C3%A1rm%C3%A1n_vortex_street\n    vec2 v = vec2(0);\n    float cx0 = 0.5*t*tScale;\n    float xScale = 0.5; // Smaller for more vortices\n    for(float cx = fract(cx0)-3.; cx < fract(cx0)+3.; cx += xScale)\n    {\n        for(float cy = -0.5; cy < 0.51; cy += 1.0)\n        {\n            float id = cx-cx0 + 0.25*sign(cy);\n            vec2 c = vec2(cx + 0.25*xScale*sign(cy), cy*0.8);\n            c += 0.3*(2.*hash21(id)-1.); // Randomize vortex position\n    \t\tfloat r0 = 0.15 + 0.2*hash11(id); // Radius of the smooth vortex core\n            vec2 uv2 = uv-c;\n            float denom = r0*r0 + dot(uv2,uv2);\n            // Fade them in and out\n            float vScale = smoothstep(-3.,-2.,cx) * smoothstep(3.,2.,cx);\n            v += sign(cy) * vec2(-uv2.y,uv2.x)/denom * xScale * vScale;\n        }\n    }\n    return v;\n}\n\n\n\nMain {\n\n    vec2 u = uu(U) * 1.5;\n    if(iFrame == 0) {\n        //Q = vec4(fbm(u));\n        Q = vec4(0);\n        return;\n    }\n    \n    // Transport the smoke along a vortex field\n    //vec2 u = uu(U);\n    //Q = A(U);\n    Q.x = A0(uu(U) - 0.002 * tScale * velocityField(u, iTime)).x;\n    Q.y = A0(uu(U) - 0.002 * tScale * velocityField(u, iTime + 100.)).y;\n    Q.z = A0(uu(U) - 0.002 * tScale * velocityField(u, iTime + 200.)).z;\n    Q.w = A0(uu(U) - 0.002 * tScale * velocityField(u, iTime + 300.)).w;\n    Q = mix(Q, vec4(1,0,0,1) * smoothstep(-2.,-2.1,u.x), 0.01*tScale);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nbool IsInDomain(vec2 U) {\n    return length(U - RSIM) < RSIM - 1.;\n}\n\n#define B(U) (IsInDomain(U) ? A(U).x : c)\n\nMain {\n    Q*=0.;\n    float c = A(U).x;\n    float n = B(U+vec2(0,1));\n    float s = B(U-vec2(0,1));\n    float w = B(U-vec2(1,0));\n    float e = B(U+vec2(1,0));\n    float dt = sqrt(0.5);\n    Q.x = 2.*A(U).x - A(U).y + dt*dt * (n+s+w+e - 4.*c);\n    Q.y = c;\n    Q.x *= 0.99; // Slight damping\n    Q.xy += 0.02 * texture(iChannel1, 0.2*U/R+iTime*vec2(1.,0.618)).x; // Random stirring\n    \n    if(iFrame == 0) {\n        Q.x = smoothstep(RSIM*0.5, 0., length(U - 0.5*RSIM));\n        Q.y = Q.x;\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}