{"ver":"0.1","info":{"id":"WlfXzs","date":"1563891022","viewed":564,"name":"RayMarchingStructureTest","username":"maplellll","description":"Unoptimized Organized RayMarching Codes with a lot of limitations.\n25 FPS on GTX 1060 and 16 objects are the maximum for my computer to run without compile crashes(reasons unknown)\nso you may want to throw some objects away before running it.","likes":1,"published":3,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by Maple\n// Under MIT License\n\n// code reference:\n// ShaderToy入门教程 by 穿越文明 source: https://blog.csdn.net/weixin_28710515/article/details/89532597\n// code by Inigo Quilez, source: https://iquilezles.org/articles/distfunctions\n// code by Low Kok Lim in NUS Summer workshop of CS 2019\n// glm source code on https://github.com/g-truc/glm\n\nconst float EPSILON = 0.001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst int MAX_MARCHING_STEPS = 255;\nconst int NUM_ITERATIONS = 5;\n\nconst int NUM_MATERIALS = 3;\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.2, 0.6);\n\nconst int MAX_LIGHT_NUM = 10;\nconst int MAX_OBJ_NUM = 50;\n\nint objectNum = 0;\nint lightNum = 0;\n\n\nstruct Ray {\n    vec3 origin;  // Ray Origin.\n    vec3 direction;  // Ray Direction. A unit vector.\n};\n\nstruct Object\n{\n    vec4 dimensions;\n    mat4 transformation;\n    int which_kind;\n    int materialID;\n};\n\nstruct Material {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\nstruct Light \n{\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nObject objects[MAX_OBJ_NUM];\nLight lights[MAX_LIGHT_NUM];\nMaterial materials[NUM_MATERIALS];\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.yz) - w, p.x );\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\n\n\n\n#define CUBE 0\n#define SPHERE 1\n#define DROP 2\n#define PLANE 3\n#define UNUSED 0.0\nvoid addCube( vec3 dimensions, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = CUBE;\n    objects[objectNum].dimensions = vec4(dimensions,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\nvoid addPlane(vec4 coefficients, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = CUBE;\n    objects[objectNum].dimensions = coefficients;\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\nvoid addSphere( float radius, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = SPHERE;\n    objects[objectNum].dimensions = vec4(radius,UNUSED,UNUSED,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\n\n//revolved vesica on https://www.shadertoy.com/view/4lyfzw\nvoid addDrop( float innerRadius, float size, float proportion, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = DROP;\n    objects[objectNum].dimensions = vec4(innerRadius,size, proportion,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\n\nvoid addLight(vec3 position, vec3 ambient, vec3 source)\n{\n    lights[lightNum].position = position;\n    lights[lightNum].I_a = ambient;\n    lights[lightNum].I_source = source;\n    lightNum += 1;\n}\n\nmat4 translateObj(mat4 matrix, vec3 translation)\n{\n    mat4 result = matrix;\n    translation = - translation;\n    result[3] = matrix[0] * translation[0] + matrix[1] * translation[1] + matrix[2] * translation[2] + matrix[3];\n    return result;\n}\n\n\nmat4 rotateObj(mat4 matrix, float angle, vec3 v)\n{\n    float a = -angle;//bacause actually ref point moving\n    float c = cos(a);\n    float s = sin(a);\n    vec3 axis = normalize(v);\n    vec3 temp = (1.0-c) * axis;\n    mat4 Rotate = mat4(1.0);\n    Rotate[0][0] = c + temp[0] * axis[0];\n\tRotate[0][1] = temp[0] * axis[1] + s * axis[2];\n\tRotate[0][2] = temp[0] * axis[2] - s * axis[1];\n\n\tRotate[1][0] = temp[1] * axis[0] - s * axis[2];\n\tRotate[1][1] = c + temp[1] * axis[1];\n\tRotate[1][2] = temp[1] * axis[2] + s * axis[0];\n\n\tRotate[2][0] = temp[2] * axis[0] + s * axis[1];\n\tRotate[2][1] = temp[2] * axis[1] - s * axis[0];\n\tRotate[2][2] = c + temp[2] * axis[2];\n\t\n    mat4 Result = mat4(1.0);\n    Result[0] = matrix[0] * Rotate[0][0] + matrix[1] * Rotate[0][1] + matrix[2] * Rotate[0][2];\n\tResult[1] = matrix[0] * Rotate[1][0] + matrix[1] * Rotate[1][1] + matrix[2] * Rotate[1][2];\n    Result[2] = matrix[0] * Rotate[2][0] + matrix[1] * Rotate[2][1] + matrix[2] * Rotate[2][2];\n\tResult[3] = matrix[3];\n    return Result;\n}\nconst float PI = 3.14159265358;\nvoid initScene()\n{\n    mat4 transformation = mat4(1.0);\n    mat4 identity = mat4(1.0);\n    //MIND THE ORDER OF MATRIX MULTIPLICATION WHICH IS REVERSED TO NORMAL ONE IN GLSL!\n     //MIND THE ORDER WHICH IS REVERSED!\n      //MIND THE ORDER WHICH IS REVERSED!\n    transformation = translateObj(transformation,vec3(-1.0,0.0,-1.0));\n    //GPU Killers\n    addDrop(0.0,0.9,0.7,0,translateObj(rotateObj(identity,PI/2.0,vec3(0.0,0.0,1.0))*transformation,vec3(0.0,sin(iTime*(1.0+0.04)),0.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.0,sin(iTime*(1.0+0.08)),0.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.0,sin(iTime*(1.0+0.12)),1.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.0,sin(iTime*(1.0+0.16)),1.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.0,sin(iTime*(1.0+0.20)),2.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.5,sin(iTime*(1.0+0.24)),0.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.5,sin(iTime*(1.0+0.28)),0.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.5,sin(iTime*(1.0+0.32)),1.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.5,sin(iTime*(1.0+0.36)),1.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(0.5,sin(iTime*(1.0+0.40)),2.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.0,sin(iTime*(1.0+0.44)),0.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.0,sin(iTime*(1.0+0.48)),0.5)));\n    addSphere(0.2,0,translateObj(transformation,vec3(1.0,sin(iTime*(1.0+0.52)),1.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.0,sin(iTime*(1.0+0.56)),1.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.0,sin(iTime*(1.0+0.60)),2.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.5,sin(iTime*(1.0+0.64)),0.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.5,sin(iTime*(1.0+0.68)),0.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.5,sin(iTime*(1.0+0.72)),1.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.5,sin(iTime*(1.0+0.76)),1.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(1.5,sin(iTime*(1.0+0.80)),2.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(2.0,sin(iTime*(1.0+0.84)),0.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(2.0,sin(iTime*(1.0+0.88)),0.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(2.0,sin(iTime*(1.0+0.92)),1.0)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(2.0,sin(iTime*(1.0+0.96)),1.5)));\n    addCube(vec3(0.2),0,translateObj(transformation,vec3(2.0,sin(iTime*(1.0+1.00)),2.0)));\n    \n    // Silver material.\n    materials[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    materials[0].k_a = 0.2 * materials[0].k_d;\n    materials[0].k_r = 2.0 * materials[0].k_d;\n    materials[0].k_rg = 0.5 * materials[0].k_r;\n    materials[0].n = 64.0;\n\n    // Gold material.\n    materials[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    materials[1].k_a = 0.2 * materials[1].k_d;\n    materials[1].k_r = 2.0 * materials[1].k_d;\n    materials[1].k_rg = 0.5 * materials[1].k_r;\n    materials[1].n = 64.0;\n\n    \n    addLight(vec3( 0.4,-3,0.1 ), vec3( 0.1, 0.1, 0.1 ), vec3( 1.0, 1.0, 1.0 ));\n    addLight(vec3( -4.0, 8.0, 0.0 ), vec3( 0.1, 0.1, 0.1 ), vec3( 1.0, 1.0, 1.0 ));\n    \n}\n\n// model algebra\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\nfloat unionSDF(float distances[MAX_OBJ_NUM])\n{\n    float min_dist = distances[0];\n    for(int i=0;i<objectNum;i++)\n    {\n        min_dist = min(min_dist, distances[i]);\n    }\n    return min_dist;\n}\nfloat unionSDF(float distances[MAX_OBJ_NUM], out int objIdx)\n{\n    float min_dist = distances[0];\n    objIdx = 0;\n    for(int i=0;i<objectNum;i++)\n    {\n        if(distances[i]<min_dist)\n        {\n            min_dist = distances[i];\n            objIdx = i;\n        }\n    }\n    return min_dist;\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//models\nfloat sdPlane( vec3 ref_pos, vec4 dimensions )\n{\n  // dimensions must be normalized\n  dimensions = normalize(dimensions);\n  return dot(ref_pos,dimensions.xyz) + dimensions.w;\n}\n\nfloat sdBox( vec3 ref_pos, vec3 dimensions )\n{\n  vec3 d = abs(ref_pos) - dimensions;\n  float dist_to_ref_pos = length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n  return dist_to_ref_pos;\n}\nfloat sdSphere( vec3 ref_pos, float s )\n{\n  return length(ref_pos)-s;\n}\n\n\nfloat calcDist(vec3 ref_point, Object obj)\n{\n    vec4 refP = vec4(ref_point,1.0);\n    refP = obj.transformation* refP;\n    ref_point = refP.xyz / refP.w;\n    switch (obj.which_kind)\n    {\n        case CUBE:\n            return sdBox(ref_point,  obj.dimensions.xyz);\n        case SPHERE:\n            return sdSphere(ref_point,  obj.dimensions.x);\n        case DROP:\n            return sdVesica(opRevolution(ref_point, obj.dimensions.x), obj.dimensions.y, obj.dimensions.z);\n        case PLANE:\n            return sdPlane(ref_point, obj.dimensions);\n        default:\n            return MAX_DIST;\n    }\n}\n\nfloat sceneSDF(in vec3 ref_point)\n{\n    float distances[MAX_OBJ_NUM];\n    for(int i=0;i<objectNum;i++)\n    {\n        distances[i] = calcDist(ref_point, objects[i]);\n    }\n    return unionSDF(distances);\n}\n\n\nvoid sceneSDF(in vec3 ref_point, out float distances[MAX_OBJ_NUM])\n{\n    for(int i=0;i<objectNum;i++)\n    {\n        distances[i] = calcDist(ref_point, objects[i]);\n    }\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start_dist, float limit_dist ,int preObj,out int objectIndex) \n{\n    float depth = start_dist;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        float distances[MAX_OBJ_NUM];\n        sceneSDF(eye + depth * marchingDirection, distances);\n        if(preObj != -1)\n            distances[preObj] = 2.0 * MAX_DIST;\n        int hitObjIdx;\n        float dist = unionSDF(distances,hitObjIdx);\n        if (dist < EPSILON) {\n            objectIndex = hitObjIdx;\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= limit_dist) \n        {\n            objectIndex = objectNum;\n            return limit_dist;\n        }\n    }\n    return limit_dist;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 ref_pos, Object obj) {\n    return normalize(vec3(\n        calcDist(vec3(ref_pos.x + EPSILON, ref_pos.y, ref_pos.z), obj) - calcDist(vec3(ref_pos.x - EPSILON, ref_pos.y, ref_pos.z), obj),\n        calcDist(vec3(ref_pos.x, ref_pos.y + EPSILON, ref_pos.z), obj) - calcDist(vec3(ref_pos.x, ref_pos.y - EPSILON, ref_pos.z), obj),\n        calcDist(vec3(ref_pos.x, ref_pos.y, ref_pos.z  + EPSILON), obj) - calcDist(vec3(ref_pos.x, ref_pos.y, ref_pos.z - EPSILON), obj)\n    ));\n}\n\n\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material mat, in Light light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\nvec3 castRay (in Ray ray, in int preObj,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg, out int hitObj )\n{\n    int objIndex;\n    float dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST,MAX_DIST,preObj, objIndex);\n    if(dist>MAX_DIST - EPSILON)\n    {\n        hasHit = false;\n        if(preObj == -1)\n            return texture(iChannel0, ray.direction).rgb;\n        return texture(iChannel0, ray.direction + ray.origin).rgb;\n    }\n    else\n    {\n        hitObj = objIndex;\n        Object obj = objects[objIndex];\n        hasHit = true;\n        vec3 ref_pos = ray.origin + dist * ray.direction;\n        hitPos = ref_pos;\n        hitNormal =  estimateNormal(ref_pos, obj);\n        k_rg = materials[obj.materialID].k_rg;\n        vec3 I_local = vec3(0.0);\n        // shadow ray\n        for (int i = 0;i<lightNum;i++)\n        {\n            Light light = lights[i];\n            vec3 shadowRay = light.position - hitPos;\n            Ray sRay;\n            sRay.origin = hitPos;\n            sRay.direction = normalize(shadowRay);\n            float max_dist = MAX_DIST;\n            int hitObjIndex;\n            float distTemp = shortestDistanceToSurface(sRay.origin, sRay.direction,MIN_DIST,max_dist,objIndex,hitObjIndex);\n            bool hitSth = (distTemp<max_dist-EPSILON);\n            I_local += PhongLighting(sRay.direction, hitNormal,-ray.direction, hitSth, materials[obj.materialID],light);\n        }\n        return I_local;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initScene();\n    float FOVY = 45.0;\n    vec3 viewInitDirection = rayDirection(FOVY, iResolution.xy, fragCoord);\n    vec3 eyePos = vec3(-4.0,1.0, 3.0);\n    vec2 rott = iMouse.xy / iResolution.xy;\n    mat4 identity = mat4(1.0);\n    mat4 transformation = rotateObj(identity, rott.x*1.5*PI, vec3(0.0,1.0,0.0));\n    transformation = rotateObj(transformation, rott.y*1.5*PI, vec3(0.0,0.0,1.0));\n    eyePos =(transformation* vec4(eyePos,1.0)).xyz;\n    // eyePos = vec3(0.0,0.0, 3.0);//for test\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 lookAtMatrix = lookAt(eyePos, center, up);\n    vec3 wcRayDir = (lookAtMatrix * vec4(viewInitDirection,0.0)).xyz;//wc : world coordinate\n    Ray primaryRay;\n    primaryRay.origin = eyePos;\n    primaryRay.direction = normalize(wcRayDir);\n    Ray nextRay = primaryRay;\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    int preObj = -1;\n    for(int level =0;level<NUM_ITERATIONS;level++)\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        vec3 I_local = castRay(nextRay,preObj, hasHit, hitPos, hitNormal,k_rg, preObj);\n        I_result += compounded_k_rg * I_local;\n        if(!hasHit)\n            break;\n        compounded_k_rg *= k_rg;\n        nextRay = Ray(hitPos,normalize( reflect(nextRay.direction, hitNormal)));\n    }\n    fragColor = vec4(I_result,1.0);\n}","name":"Image","description":"","type":"image"}]}