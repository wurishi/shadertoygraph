{"ver":"0.1","info":{"id":"4c2BRc","date":"1725287496","viewed":56,"name":"CostepLife","username":"chronos","description":"Smoothlife, but using just Costep for sigmoid, step and ramp functions.\nRampstep-life is also included, just change the stepfunction macro in Common tab","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["game","automata","life","cellular","smoothstep","smooth","ca","of","automaton","smoothlife","gol","smoothlifel","costep"],"hasliked":0,"parentid":"4cffzr","parentname":"SmoothStepLife"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    CosStepLife by chronos\n    ---------------------------------------------------------------------------\n    \n    Smoothlife, but using just costep for sigmoid, step and ramp functions.\n    Basically just a simple fork of SmoothStepLife with other soft step/ramp functions.\n    \n    The motivation was basically to switch to trigonometric step functions to see if anything falls\n    out or reduces in the transition function. But I didn't get that far. \n    Took a quick look, and it seems like one could replace with a sqared product of sines, ala:\n        (sin(PI*x/2)*sin(PI*y/2))^2\n    So not hugely promising or interesting to be honest... :)\n    \n    See also my previous smoothlife shaders\n\n    SmoothStepLife: https://www.shadertoy.com/view/4cffzr\n    Smoothlife(L): https://www.shadertoy.com/view/XtdSDn\n    WaveLife: https://www.shadertoy.com/view/XlsfRX\n    PulseLife: https://www.shadertoy.com/view/XlfBRs\n\n    ---------------------------------------------------------------------------\n    self link: https://www.shadertoy.com/view/4c2BRc\n    ---------------------------------------------------------------------------\n*/\n\n\nconst float slide_speed = 0.025;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv+iTime*slide_speed).rrr;\n    \n    // Inspect transition function by holding spacebar\n    if(texture(iChannel3, vec2(32./256., 0)).r > 0.5)\n    {\n        col*= 0.1;  col += transition(uv.x, uv.y);\n        col.rg+=smoothstep(0.95, 1., fract(uv.xy*12.));\n    }\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\n// inverse wrt x: y = mix(a,b,x) = (1-x) * a + x * b = (b-a)*x + a\n// x = (y - a)/(b - a)\nfloat invmix(float a, float b, float y)\n{\n    return (y - a)/(b - a);\n}\n\n// Didn't need this after all, so unused, but leaving it in :)\nfloat remap(float a0, float b0, float a1, float b1, float x)\n{\n    return mix(a1, b1, invmix(a0, b0, x));\n}\n\n// linear saturating ramp for x between a and b, with value from 0 (at a) to 1 (at b).\nfloat rampstep(float a, float b, float x)\n{\n    return clamp(invmix(a, b, x), 0., 1.);\n}\n\n// Cosine 'smoothstep'\nfloat costep(float a, float b, float x)\n{\n    float y = rampstep(a, b, x); // map x in range [a, b] to [0, 1] and clamp to saturate step\n    return .5 - .5*cos(PI * y);\n}\n\n#define stepfunction costep\n//#define stepfunction smoothstep\n//#define stepfunction rampstep\n\n// Or add you own here!\n// criteria:\n// - Must have same same function signature as smoothstep\n// - Must be monotonicly increasing from a to b, if a < b, and monotonically decrease otherwise\n// - Must be continuous\n// - Output range must be between 0 and 1\n// - If a < b, then x < a gives 0, x > b gives 1\n// - If a > b, then x > a gives 0, x < b gives 1\n\nfloat transition(float inner, float outer)\n{\n    \n    \n    #if 1\n    \n    // Costep params, make a bit wider life region so it doesn't die out as fast.\n    \n    // Birth range\n    float b0 = 5.975/24.;\n    float b1 = 8.025/24.;\n\n    // Survival range\n    float s0 = 8.975/24.;\n    float s1 = 13.025/24.;\n    \n    // costep half-widths\n    float db = 1.125/70.;\n    float ds = 1.125/27.;\n    \n    #else\n    \n    // Smoothstep params\n    \n    // Birth range\n    float b0 = 6./24.;\n    float b1 = 8./24.;\n\n    // Survival range\n    float s0 = 9./24.;\n    float s1 = 13./24.;\n    \n    // smoothstep half-widths\n    float db = 1./70.;\n    float ds = 1./27.;\n    #endif\n    \n    float b = stepfunction(b0-db, b0+db, inner) * stepfunction(b1+db, b1-db, inner);\n    float s = stepfunction(s0-ds, s0+ds, inner) * stepfunction(s1+ds, s1-ds, inner);\n        \n    return mix(b,s, stepfunction(0.425, 0.575, outer));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float outer_radius = 9.;\nconst float inner_radius = 3.;\n\nconst float inner_area = PI * inner_radius * inner_radius;\nconst float outer_area = PI * outer_radius * outer_radius - inner_area;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    if(iFrame == 0)\n    {\n        float hash = fract(31415.9265 * sin(dot(fragCoord.xy, vec2(1.61803398875, 31.14159265))));\n        fragColor.r = pow(hash, .75)\n            * stepfunction(0., 100., length(fragCoord-iResolution.xy/2.))\n            * stepfunction(1000., 100., length(fragCoord-iResolution.xy/2.))\n            ;\n        return;\n    }\n\n    float outer = 0.;\n    float inner = 0.;\n    \n    const int N = 10;\n    for(int i = -N; i <= N; i++)\n    for(int j = -N; j <= N; j++)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 bufA = texelFetch(iChannel0, ivec2(mod(fragCoord+ij +iResolution.xy, iResolution.xy)), 0);\n        \n        float d = length(ij);\n        \n        float inner_weight = stepfunction(inner_radius + .75, inner_radius - .75, d);\n        float outer_weight = stepfunction(outer_radius + .75, outer_radius - .75, d) * (1.-inner_weight);\n        \n        outer += bufA.r * outer_weight;\n        inner += bufA.r * inner_weight;\n    }\n    \n    inner /= inner_area;\n    outer /= outer_area;\n    \n    float dt = 0.3;\n    \n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float prev_state = bufA.r;\n    float new_state = prev_state + dt * (2. * transition(outer, inner) - 1.);\n        \n    new_state = clamp(new_state, 0., 1.);\n    \n    fragColor.r = new_state;\n}","name":"Buffer A","description":"","type":"buffer"}]}