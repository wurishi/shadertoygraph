{"ver":"0.1","info":{"id":"ddcfRM","date":"1696963126","viewed":37,"name":"my rainbow bouncing ball","username":"RoflanVglorius","description":"second version of bouncing ball","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 90;\nconst float maxDist = 10.0;\nconst float eps      = 0.01;\nconst float pi       = 3.14159265359;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - .5;\n}\n\n\nfloat sdfBall( in vec3 p )\n{\n    float v = 0.2;\n    float t = mod ( iTime * v, 1. ); \n    float arg = sqrt(1.5 - t);\n    float y = 3. * abs(cos(5.5 * arg / v * pi)) / pow(32., t);\n    return dSphere (p, vec3 (0, y - 0.5, 0 ));\n}\n\nfloat sdfPlane ( in vec3 p )\n{\n    return p.y + 1.;\n}\n\n\nfloat sdf ( in vec3 p , in mat3 m )\n{\n    vec3 q = m * p;\n    float ball = sdfBall ( q );\n    float plane = sdfPlane ( q );\n    return min ( ball , plane );\n}\n\n\nvec3 trace ( vec3 from, vec3 dir, out bool hit, in mat3 m )\n{\n    vec3     p         = from;\n    float    totalDist = 0.0;\n    \n    hit = false;\n    \n    for (  int steps = 0; steps < maxSteps; steps++ )\n    {\n        float    dist = sdf ( p , m );\n        \n        if ( dist < eps )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist;\n        \n        if ( totalDist > maxDist )\n            break;\n            \n        p += dist * dir;\n    }\n    \n    return p;\n}\n\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y + pi ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec3 p     = trace ( eye, dir, hit, m );\n    vec3 q = m * p;\n     vec4 color = texture(iChannel2, p.xy);\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 90.0 );\n\t\t\n\t\tcolor = 0.25 * sp * vec4 ( 3, 2, 2, 2 );\n        \n        vec3 q = m * p;\n        if ( sdfBall ( q ) < eps ) {\n            color += texture ( iChannel1, q.xz);\n        }\n\t\tif ( sdfPlane( q ) < eps ) {\n            color += texture ( iChannel0, q.xz );\n        }\n\n\t} \n\n        // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi       = 3.14159265359;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float v = 0.2;\n    float r = abs(sin(iTime));\n    float g = abs(sin(iTime) + cos(iTime));\n    float b = abs(cos(iTime));\n    \n    float t = mod ( iTime * v, 1. ); \n    float arg = sqrt(1.5 - t);\n    float y = 3. * cos(5.5 * arg / v * pi) / pow(32., t);\n    if ( y >= 0. ) {\n        fragColor = vec4(r,g,b,1.0);\n    }\n    else {\n    fragColor = vec4(0, 0, 0, 1);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}