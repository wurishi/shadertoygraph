{"ver":"0.1","info":{"id":"llcGDB","date":"1471661550","viewed":170,"name":"test reflections","username":"Slyth","description":"semi accurate reflections, not really fully working. only coding things that I full understand the math behind this go around in order to actually learn some stuff. lighting isn't accurate but it looks neat","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITER = 100;\nconst float MAX_DIST = 40.0;\nconst float EPSILON = 0.001;\nconst vec3 sky = vec3(0.0);//0.2, 0.4, 0.7);\n\nfloat FLOOR_COL = 10.0;\nfloat SPHERE_COL = 46.9;// * sin(iTime);\nfloat BOX_COL = 50.2;\n\nfloat obj_sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat obj_box(vec3 pos, vec3 bounds)\n{\n  return length(max(abs(pos) - bounds, 0.0));\n}\n\nfloat obj_floor(vec3 pos)\n{\n    return pos.y + 2.0;// + sin(pos.x / 2.0) * cos(pos.z / 2.0);   \n}\n\nfloat op_rep(vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c) - 0.5 * c;\n    return obj_sphere(q, 1.0);\n}\n\nvec2 obj_union(vec2 obj0, vec2 obj1)\n{\n    if (obj0.x < obj1.x)\n        return obj0;\n    else\n        return obj1;\n}\n\nvec2 distFunc(vec3 pos)\n{\n    vec3 sphereOff = vec3(2.0, 0.0, 0.0);\n    vec2 f = obj_union(vec2(obj_floor(pos), (mod(pos.x, 2.0) * mod(pos.z, 2.0)) > 0.25 ? 200. : 25.),\n                        obj_union(\n                            vec2(op_rep(pos, vec3(4.0, 0.0, 4.0)), SPHERE_COL),\n                            vec2(obj_box(pos + vec3(0.0, -5.0, 0.0), vec3((cos(iTime) + 1.0) * 2.0, 3.0, sin(iTime) + 1.0)), BOX_COL)));\n    \n    return f;\n}\n\nvec2 rayMarch(inout float totalDist, inout vec3 pos, inout float dist, vec3 rayDir)\n{\n    vec2 fin;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            return fin;\n\n        fin = distFunc(pos);\n        dist = fin.x;\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n    return fin;\n}\n\nvec4 reflections(vec3 pos, vec3 last, vec3 normal, const int maxBounces)\n{\n    float rdist = EPSILON;\n    float rtotalDist = 0.0;\n    vec3 rpos = pos + normal * EPSILON;\n    vec3 rRayDir = reflect(last, normal);    \n    vec3 factor = vec3(1.0);\n    \n    for(int i = 0; i <= 3; i++)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            distFunc(rpos + eps.yxx).x - distFunc(rpos - eps.yxx).x,\n            distFunc(rpos + eps.xyx).x - distFunc(rpos - eps.xyx).x,\n            distFunc(rpos + eps.xxy).x - distFunc(rpos - eps.xxy).x));\n        \n        rdist = EPSILON;\n        rtotalDist = 0.0;\n        rpos = pos + normal * EPSILON;\n        \n        vec2 ret = rayMarch(rtotalDist, rpos, rdist, rRayDir);\n        \n        rRayDir = reflect(rRayDir, normal);\n        \n        vec3 col = vec3(0.7, 0.9, 1.0) + rpos.y * 0.8;\n\n        if(rdist < EPSILON)\n        {\n            col = 0.45 + 0.3 * sin(vec3(0.05, 0.08, 0.10) * (ret.y - 1.0));\n            factor *= col;\n        } else\n            break;\n    }\n    \n    return vec4(factor, 1.0);\n}\n\nfloat shadow(inout float totalDist, inout vec3 pos, inout float dist, vec3 rayDir, float k)\n{    \n    float res = 1.0;\n    vec2 fin;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON)\n            return 0.0;\n\n        fin = distFunc(pos);\n        dist = fin.x;\n        totalDist += dist;\n        pos += dist * rayDir;\n        //res = min(res, k * fin.x / float(i));\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy);\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    vec3 cameraOrigin = vec3(sin(iTime * 0.5) * 10.0, 6.0 + sin(iTime * 0.5) * 5.0, cos(iTime * 0.5) * 10.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, -1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDir);\n\n    vec3 lightPos = -rayDir + vec3(cos(iTime * 0.5) * 16.0, 1.0, sin(iTime * 0.2) * 6.0);\n    \n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    vec2 ret = rayMarch(totalDist, pos, dist, rayDir);\n    vec3 col = vec3(0.7, 0.9, 1.0) + pos.y * 0.8;\n    \n    if (dist < EPSILON)\n    {\n        vec4 ambient = vec4(0.12);\n        float intensity = 0.5;\n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            distFunc(pos + eps.yxx).x - distFunc(pos - eps.yxx).x,\n            distFunc(pos + eps.xyx).x - distFunc(pos - eps.xyx).x,\n            distFunc(pos + eps.xxy).x - distFunc(pos - eps.xxy).x));\n        \n        col = 0.45 + 0.3 * sin(vec3(0.05, 0.08, 0.10) * (ret.y - 1.0));\n        vec4 diffuse = vec4(col, 1.0);//vec4(max(0.0, dot(normal, lightPos)) * intensity);\n        \n        vec3 lightDir = normalize(lightPos - pos);\n        float lightIntensity = dot(normal, lightDir);\n        \n        vec4 reflection = (reflections(pos, rayDir, normal, 3));\n        \n        float sdist = EPSILON;\n        float stotalDist = 0.0;\n        vec3 spos = pos + normal * EPSILON;\n        \n        float shad = shadow(stotalDist, spos, sdist, lightDir, 32.0);\n        \n        vec4 fog = vec4(1.0 - (totalDist / MAX_DIST));\n                \n        fragColor = max(vec4(0.05), (((diffuse * (shad) + reflection * 0.2)) * (lightIntensity)) + ambient) * fog;\n    }\n    else\n    {\n        fragColor = vec4(sky, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}