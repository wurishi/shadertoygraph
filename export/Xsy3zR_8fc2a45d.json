{"ver":"0.1","info":{"id":"Xsy3zR","date":"1452873683","viewed":315,"name":"140","username":"phi16","description":"[url]http://store.steampowered.com/app/242820/[/url]\nI love this game!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//Comment out this to see an actual shape\n#define _140\n\n\n#ifdef _140\n#define SKEWING\n#else\n#define SLOW\n#define LIGHTING\n#endif\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) //https://iquilezles.org/articles/distfunctions\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat dist(vec3 p){\n    float rot = 0.;\n    \n#ifdef SLOW\n    float period = 0.9;\n    float base = 0.5;\n#else\n    float period = 60./140.0;\n    float base = 0.1;\n#endif\n    float it = mod(iTime,period);\n    rot = it<period-base?0.:(it-period+base)/base*3.1415/2.;\n    vec3 bp = p, sp = p, cp = p;\n#ifdef SKEWING\n    bp.z *= 1.+sin(rot*2.)*0.4;\n#endif\n    bp.zx *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    float bs = sdCappedCylinder(bp.yzx,vec2(1,1));\n    \n#ifdef SKEWING\n    sp.y *= 1.+sin(rot*2.)*0.4;\n#endif\n    sp.xy *= mat2(sin(rot),-cos(rot),cos(rot),sin(rot));\n    sp.y -= 1.;\n    float sc = max(sdCone(sp.xzy,normalize(vec2(2,1))),-2.-sp.y);\n    \n#ifdef SKEWING\n    cp.y *= 1.+sin(rot*2.)*0.4;\n#endif\n    cp.xy *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    cp.y += 0.33;\n    cp.z /= 0.86;\n    float cb = sdTriPrism(cp.zyx,vec2(1.34,1));\n    \n    float t = mod(iTime,period*3.);\n    if(t<period)return bs;\n    else if(t<2.*period)return sc;\n    else return cb;\n}\n\nvec3 normal(vec3 p){\n    vec2 e=vec2(0.01,0.);\n    return normalize(vec3(\n        dist(p+e.xyy)-dist(p-e.xyy),\n        dist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)));\n}\n\nvec3 color(vec3 p, vec3 v){\n    int maxIter = 100;\n    float c = 0.001;\n    for(int i=0;i<100;i++){\n        float ci=dist(p+c*v);\n        if(abs(ci) < 0.001){\n            maxIter=i;\n            break;\n        }\n        c += ci;\n    }\n    vec3 col = vec3(0);\n    if(maxIter==100)col = vec3(0.06);\n    else col = vec3(0.96);\n#ifdef LIGHTING\n    vec3 pos = p+c*v;\n    v.z += p.z/2.4;\n    v.y -= p.y/2.4;\n    v = normalize(v);\n    vec3 n = normal(pos);\n    vec3 ref = texture(iChannel0,reflect(v,n)).xyz;\n    float fresnel = pow(1.+max(0.,dot(n,-v)),2.)*0.5+0.5;\n    if(col.x < 0.1){\n        col = texture(iChannel0,v).xyz;\n    }else{\n        col *= vec3(1.0,0.76,0.33)*ref*fresnel;\n    }\n#endif\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy, \n\tuv = (2.*fragCoord.xy - R)/R.y;\n    vec3 p=vec3(-2,uv.y*2.4,uv.x*2.4);\n    vec3 v=vec3(1,0,0);\n    v=normalize(v);\n\tfragColor = vec4(color(p,v),1.0);\n}","name":"Image","description":"","type":"image"}]}