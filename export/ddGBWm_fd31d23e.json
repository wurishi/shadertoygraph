{"ver":"0.1","info":{"id":"ddGBWm","date":"1698266316","viewed":16,"name":"Lab6-Shading","username":"lothrosl","description":"Shading a triangle","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["lab6"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n\n// Given three external points, and a point inside the triangle\n// Calculate the barycentric coordinates\nvec3 Barycentric(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    vec2 v0 = b - a;\n    vec2 v1 = c - a;\n    vec2 v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    vec3 result;\n    result.x = (d11 * d20 - d01 * d21) / denom;\n    result.y = (d00 * d21 - d01 * d20) / denom;\n    result.z = 1.0f - result.x - result.y;\n    return result;\n}\n\n// Given a coordinate, calculate a checkerboard texture\nvec3 checkerTex(vec2 coord) {\n   float size = 25.f;\n   float total = floor(coord.x/size) + floor(coord.y/size);\n   bool isEven = mod(total, 2.0) == 0.0;\n   return (isEven)?vec3(0.6):vec3(0.4); \n}\n\n// Interpolate between vertex attributes a,b,c based on the \n// coordinate 'bary_coord'\nvec3 bary_interp(vec3 bary_coord, vec3 a, vec3 b, vec3 c) {\n  return bary_coord.x*a + bary_coord.y*b + bary_coord.z*c;\n}\n\n// Returns the phong equation for a given direction to a camera, \n// direction to a light, and normal for a surface\nvec3 phongEquation(vec3 camera_dir, vec3 light_dir, vec3 normal ) {\n  vec3 R = reflect(-camera_dir, normal);\n  \n  vec3 out_color;\n  out_color = 0.5*max(0.0,dot(normal, light_dir))*vec3(1.0); \n  out_color += pow(max(0.0,dot(light_dir, R)),1.)*vec3(10.0);\n  out_color += vec3(0.2);\n  \n  return out_color;\n}\n\n// Given a light position, camera position, barycentric coordinate,\n// position and normals for three vertices\n// calculate the phong color by interpolating the normals and positions\n// by using the barycentric coordinates\n// and passing it to a single phong equation calculation\nvec3 phongShading(vec3 light_pos, vec3 camera_pos, vec3 bary_coord,\n                  vec3 p1, vec3 p2, vec3 p3,\n                  vec3 n1, vec3 n2, vec3 n3) {\n  // Interpolate position and normal using barycentric coordinates\n  vec3 interpolated_position = bary_interp(bary_coord, p1, p2, p3);\n  vec3 interpolated_normal = bary_interp(bary_coord, n1, n2, n3);\n\n  // Calculate the direction to the light source and the camera\n  vec3 light_direction = normalize(light_pos - interpolated_position);\n  vec3 view_direction = normalize(camera_pos - interpolated_position);\n\n  // Calculate the Phong shading color using the provided phong_equation function\n  vec3 phong_color = phongEquation(view_direction, light_direction, interpolated_normal);\n\n  return phong_color;\n}\n\n// Given a light position, camera position, barycentric coordinate,\n// position and normals for three vertices\n// calculate the Gouraud color by calculating the phong equation at the \n// three vertices (three times), then interpolating the three colours \n// using the barycentric coordinates\nvec3 gouraudShading(vec3 light_pos, vec3 camera_pos, vec3 bary_coord,\n                    vec3 p1,vec3 p2,vec3 p3,\n                    vec3 n1, vec3 n2, vec3 n3) {\n  // Calculate Phong shading color at each vertex\n  vec3 phong_color1 = phongEquation(camera_pos - p1, light_pos - p1, n1);\n  vec3 phong_color2 = phongEquation(camera_pos - p2, light_pos - p2, n2);\n  vec3 phong_color3 = phongEquation(camera_pos - p3, light_pos - p3, n3);\n\n  // Interpolate the three colors using barycentric coordinates\n  vec3 gouraud_color = bary_interp(bary_coord, phong_color1, phong_color2, phong_color3);\n\n  return gouraud_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float width = 8.0;\n    vec3 bary = Barycentric(fragCoord, \n                            vec2(0.0,0.0), \n                            vec2(iResolution.x,0.0),\n                            vec2(iResolution.x/2.0, iResolution.y));\n    vec3 out_color;\n    vec3 light_pos = 3.*width/2.0*vec3(cos(iTime/2.), sin(iTime/2.),1.0);\n    vec3 camera_pos = vec3(0.0,0.0,10.0);\n    vec3 pos = vec3(fragCoord.xy/iResolution.xy, 0.0)*width-width/2.0;\n    float aspect = iResolution.x/float(iResolution.y);\n    \n    // A single negative barycentric coordinate means outside of triangle\n    if (any(lessThan(bary, vec3(0.0,0.0,0.0)))) {\n        out_color = checkerTex(fragCoord);\n    } else { // inside triangle    \n        // no keys pressed\n        vec3 p1 = vec3(aspect*width/2., 0.0, 0.0);\n        vec3 p2 = vec3(aspect*width/4.0, 4.0, 0.0);\n        vec3 p3 = vec3(-aspect*width/2.0, 0.0, 0.0);\n        vec3 n1 = -normalize(vec3(0.5,0.0,0.5)); // bottom left vert\n        vec3 n2 = -normalize(vec3(0.0,0.5,0.5)); // top middle vert\n        vec3 n3 = -normalize(vec3(-0.5,0.0,0.5)); // bottom right vert\n \n        out_color = phongShading(light_pos, camera_pos, bary,\n                                 p1,p2,p3,\n                                 n1,n2,n3);\n        \n        // Pressing 'up' key\n        if (texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).r > 0.5) {\n            out_color = gouraudShading(light_pos, camera_pos, bary, \n                                       p1,p2,p3,\n                                       n1,n2,n3);\n        }\n        \n    }\n        \n    // Output to screen\n    fragColor = vec4(out_color,1.0);\n   }","name":"Image","description":"","type":"image"}]}