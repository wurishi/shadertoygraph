{"ver":"0.1","info":{"id":"fs2Sz1","date":"1619660235","viewed":106,"name":"lattice 00","username":"boxes","description":"infinite square lattice. i tried to add enough comments so it'd be self-explanatory. new to GLSL and really enjoying it. i used a couple of small but pleasant tricks for seamlessly moving through the grid, the fog ramp, subtly rounding out corners.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","monochrome"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define MAX_STEPS 1024\n#define DISTANCE_THRESHOLD 0.02 // large threshold to round out corners\n\n// from https://iquilezles.org/articles/distfunctions\nfloat box(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// check distance for all shapes\nfloat f( in vec3 p ) {\n    vec3 c = vec3(0.5, 0.5, 0.5); // grid intersection is at center so distance is correct at iteration edges\n    \n    vec3 w = vec3( fract(p.x / 4.0), // domain repetition every 4 world units\n                   fract(p.y / 4.0),\n                   fract(p.z / 4.0) );\n    \n    float t = 1.0 / 32.0;\n    float v = 1.0 / 32.0 + 1.0 / 128.0;\n    float l = 0.5;\n    float d = box(c - w, vec3(l, t, t));\n    d = min(d, box(c - w, vec3(t, l, t)));\n    d = min(d, box(c - w, vec3(t, t, l)));\n    d = min(d, box(c - w, vec3(v, v, v)));\n    // could probably sub in some kind of distance from grid line function instead of 3 boxes\n    return d;\n}\n\nvec3 get_normal( in vec3 p ) {  // sample along 3 axes to get a normal  \n    const float o = 0.0009765625; // 1 / 1024\n    float c = f(p); // calculate redundantly for now to avoid the bug\n    const vec2 h = vec2(o, 0); // transpose instead of making new per axis\n    return normalize(vec3( f(p + h.xyy) - c,\n                           f(p + h.yxy) - c,\n                           f(p + h.yyx) - c) );\n}\n\nfloat cast_ray(inout vec3 p, in vec3 h) {\n    float depth = 0.0;\n    float d;\n    for (int a = 0; a < MAX_STEPS; a ++) {\n        d = f(p);     // test distance\n        p += d * h;   // step the point\n        depth += d;\n        if (d < DISTANCE_THRESHOLD) {\n            break;\n        }\n    }\n    return d;\n}\n\n// from https://iquilezles.org\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash to initialize the random seed (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvec3 spherical() {\n    float z = frand() * 2.0 - 1.0;\n    float angle = TWO_PI * frand();\n    return vec3( sqrt(1.0 - z*z) * cos(angle), \n                 sqrt(1.0 - z*z) * sin(angle),\n                 z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // random seed\n    ivec2 q = ivec2(gl_FragCoord); \n    srand(hash(q.x + hash(q.y + hash(int(1000.0 * iTime)))));\n\n    // convert to 1:1 coordinates. the first number controls grid scale.\n    vec2 uv = 1.0 * (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; \n  \n    // camera plane\n    float pitch = PI * 1.0 / 3.0 * sin(0.021193 * iTime);\n    float heading = PI * sin(0.082315 * iTime); // these are desynced from movement so they phase\n    vec3 pos = vec3(iTime + 1.0, iTime, iTime + 3.0);\n    // this walks diagonally along a path which crosses no girders\n    // we wrap after exiting the first iteration\n    pos = 4.0 * vec3( fract( 0.25 * pos.x ), \n                      fract( 0.25 * pos.y ),\n                      fract( 0.25 * pos.z ) );\n    vec3 h = vec3( cos(heading) * cos(pitch), \n                   sin(heading) * cos(pitch), \n                   sin(pitch));\n    vec3 ref = vec3(0.0, 0.0, 1.0);   // z axis\n    h = -normalize(h);         // ray heading\n    vec3 i = cross(h, ref);    // corresponds to x in screen space\n    vec3 j = cross(i, h);      // corresponds to y in screen space\n    \n    h += i * uv.x; h += j * uv.y; // heading offsets, from pixel\n    normalize(h);\n\n\n    // light\n    vec3 light = vec3(0.5, 0.25, 0.5);\n    normalize(light);\n    \n\n    // cast ray\n    float d = cast_ray(pos, h); // this updates pos\n    vec3 normal = get_normal(pos);\n\n    float s = 1.0; // darkening factor. starts at 1.0. occlusion lowers this\n    \n    // ambient occlusion\n    for (float i = 0.0; i < 1.0; i += 0.25) {\n        float occlusion_offset = 0.1 * i * i;\n        s -= 32.0 * clamp(0.25 * ( (occlusion_offset + d)\n                           - f(pos + occlusion_offset * normal) ), \n                           0.0, 1.0);\n    }\n    \n\n    // lighting, fog etc.\n    \n    \n    // i/x (with offsets) yields an asymptote at infinity instead of a fog wall a finite distance away\n    float value = 0.25 * dot(h, normal);\n    float fog = (1.0 - 1.0 / (length(pos) * 0.005 + 1.0));\n    \n    value += 1.0 / 8.0 * (frand() - 0.5); // the noise is part of the diffuse light, so it's dimmed by ambient occlusion\n    value = value * s + fog;\n\n    fragColor = vec4( value, value, value, \n                      1.0 );\n\n    // fragColor = vec4( normal.x * 0.5 + 0.5, \n    //                   normal.y * 0.5 + 0.5, \n    //                   normal.z * 0.5 + 0.5, \n    //                   1.0);\n}","name":"Image","description":"","type":"image"}]}