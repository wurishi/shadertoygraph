{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// u2 : developped on my lapop at 2fps at the Revision 2014.\n//\t\tthe live coding session has rised my motivation to start something with shader toy\n//\t\tUsed a lot of template/code from other shaders.\n//\t\tOld school spiky ball effect.\n\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, vec2 fragCoord)\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n//\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n// return the distance to a sphere\nfloat Psphere( vec3 p, vec3 c, float r )\n{\n\treturn length(p-c)-r;\n}\n\nfloat Pcapsule( vec3 p, vec3 a, vec3 b, float rmin, float rmax )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3 norm = normalize( b - a );\n\tfloat d = -dot( norm, a );\n\tfloat dist = dot( norm, p ) + d ;\n\t\n\tfloat rf = dist / length( b-a );\n\t\n\tfloat r = mix( rmin, rmax, rf*rf*rf );\n\t\t\n    return length( pa - ba*h ) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blendPrim( float a, float b  )\n{\n\tfloat k=0.32 ;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n//\treturn min( a, b );\n}\n\n// Convert a vector into 2 Auler angle\nvec2 ToEuler( vec3 p )\n{\n\treturn vec2( atan( p.z, p.x  ),\n\t\t\t     atan( sqrt(p.x*p.x+p.z*p.z), p.y)) ;\n//\treturn vec2( atan( p.x, p.z ),\n//\t\t\t     atan( p.y, sqrt(p.x*p.x+p.z*p.z) )) ;\n}\n\nvec3 FromEuler( vec2 e )\n{\n\tfloat c = sin(e.y);\n\treturn vec3( c * cos(e.x),\n\t\t\t \t cos(e.y),\n\t\t\t \t c * sin(e.x)\t\t);\n}\n\nfloat nbSpikes = 16. ;\nfloat PI = 3.141592653 ;\nvec3 ClassifyDir( vec3 p, out float id )\n{\n\tvec2 angle = ToEuler( p )  ;\t\n\t\n\tfloat div = 2.*PI / nbSpikes\t;\n\t\n\tangle /= div ;\n\tangle = floor(angle);\n\tid = angle.x+angle.y ;\n\tangle = angle*div;\n\tangle += div*0.5 ;\n\t\n\treturn FromEuler(angle);\n//\treturn normalize(p) ;\n//\tif( p.y > 0. )\n//\t\treturn vec3(0.,1.,0.);\n//\telse\n//\t\treturn vec3(0.,-1.,0.);\n}\n\nfloat Pcapsule1( vec3 p, vec3 dir, float dist, float thickmin, float thickmax )\n{\n\treturn \tPcapsule( p, dir*1., dir*(dist-3.), thickmin, thickmax );\n}\n\nvec4 QuatFromAxisAngle( vec3 axis, float angle )\n{\n\tfloat theta = 0.5 * angle\t;\n\tfloat sine = sin(theta)\t\t\t;\n\treturn vec4( cos(theta),\n\t\t\t\t axis.x * sine,\n\t\t\t\t axis.y * sine,\n\t\t\t\t axis.z * sine );\n}\n\nvec3 TransformVecQuat( vec3 v, vec4 q )\n{\n\tvec3 t = 2. * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 PlaneFromNormPos( vec3 n, vec3 p )\n{\n\treturn vec4( n.x, n.y, n.z, \n\t\t\t\t - dot( n, p ) );\n}\n\nfloat Pplane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Compute the Spiky object\nfloat Spiky( vec3 p )\n{\n\t// transform input position*\n\tvec4 q = QuatFromAxisAngle( normalize( vec3(cos(iTime*0.7),1,0) ), iTime*1.5 - 0.35*length(p) );\n\tp = TransformVecQuat( p, q );\n\t\t\n\t\n\t// Spiky !\t\n\tfloat id ;\n//\tfloat p0 = Pcapsule( p, vec3(0,1,0), vec3(0,5,0), 0.05 );\n\tvec3 d = ClassifyDir(p,id);\n\tvec3 infos = vec3( 10., 0.3, 0.02 );\n/*\tfloat modc = mod(id,4. ) ;\n\tif( modc < 1. )\n\t\tinfos = vec3( 11., 0.2, 0.04 );\n\telse if( modc < 2. )\n\t\tinfos = vec3( 9., 0.4, 0.035 );\n\telse if( modc < 3. )\n\t\tinfos = vec3( 8., 0.1, 0.055 );*/\n\tfloat p0 = Pcapsule1( p, d, infos.x, infos.y, infos.z );\n\tfloat p1 = Psphere( p, vec3(0,0,0), 2.5 );\n\t\n\treturn blendPrim( p0, p1 );\t// blend primitives\t\n//\treturn p1;\t// blend primitives\t\n}\n\nfloat PlaneY = -7. ;\n\n// return the distance to the scene\nfloat Scene( vec3 p )\n{\n\tfloat s  = Spiky( p ) ;\n\t\n\t// Floor and background\n\tvec4 floorp = PlaneFromNormPos( vec3(0.,1.,0.), vec3(0.,PlaneY,0.) );\n\tfloat f = Pplane( p, floorp );\n\t\n\treturn min( s, f );\n//\treturn f ;\n//\treturn p1 ;\t// blend primitives\n}\n\n\nvec3 calcNormal( in vec3 p, out float valid )\n{\n\n\tvec3 e = vec3(0.001,0.0,0.0);\n\tvec3 norm = vec3(Scene(p+e.xyy) - Scene(p-e.xyy),\n\t\t\t\t\t\t   Scene(p+e.yxy) - Scene(p-e.yxy),\n\t\t\t\t\t\t   Scene(p+e.yyx) - Scene(p-e.yyx) );\n\tfloat l = length( norm );\n//\tif( l > 0.0015 && l < 1000. )\n//\t{\n\t\tvalid = 1. ;\n\t\tnorm /= l ;\n//\t}\n//\telse\n//\t{\n//\t\tvalid = 0. ;\n//\t}\n\treturn norm ;\t\t   \n}\n\nfloat calcAOSpiky( in vec3 pos, in vec3 nor )\n{\n    float ao = 1.0;\n    float totao = 0.0;\n    float sca = 15.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.002 + 0.04*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = Spiky( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return 1.0 - clamp( totao, 0.0, 1.0 );\n}\n\n// compute soft shadow from Spiky object\nfloat softShadowSpiky( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float dt = 0.02;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        float h = Spiky( ro + rd*t );\n        res = min( res, k*h/t );\n        t += max( 0.05, dt );\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat TraceSpiky( vec3 vpos, vec3 vdir )\n{\t\n\tfloat tmax = 80.0;\n\tfloat dist = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i < 30; i++ )\n\t{\n\t\tif( dist<0.01 || dist>tmax ) \n\t\t\tbreak;\n\t\t\n\t\tvec3 p = vpos + t*vdir;\n\t\tdist = Spiky( p );\t\n\t\t\n\t\tt += dist ;\n\t}\n\t\n\treturn t ;\n}\n\nfloat TraceFloor( vec3 vpos, vec3 vdir, vec3 viewDir )\n{\n\tfloat tmax = 80.0;\n\tfloat dist = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i < 30; i++ )\n\t{\n\t\tif( dist<0.01 || dist>tmax ) \n\t\t\tbreak;\n\t\t\n\t\tvec3 p = vpos + t*vdir;\n\t\t\n\t\tvec4 floorp = PlaneFromNormPos( vec3(0.,1.,0.), vec3(0.,PlaneY,0.) );\n\t\tdist = Pplane( p, floorp );\t\n\t\n//\t\tdist = min( dist, dot( p, -viewDir )-60. );\n\t\t\n\t\tt += dist ;\n\t}\t\n\t\n\treturn t ;\n}\n\n// main light\nvec3 lightDir = vec3( 1, -0.8, 0.5 );\nvec3 lightCol = vec3( 0.9, 0.9, 0.9 );\n\n// pseudo sss color\nvec3 sssCol = 2.*vec3( 0.12, 0.1, 0.07 );\n\n\n// fog\nvec3 fogCol = vec3(1.,1.,1.);\nfloat fogCutIn = 20. ;\nfloat fogPower = 0.04 ;\n\n\nfloat ComputeFog( vec3 pos, vec3 vpos )\n{\n\t// fog\n\tfloat lfog = length(pos-vpos) - fogCutIn ; // start the fog a much further from the camera\n\treturn exp( -fogPower*lfog );\t\n}\n\nvec3 ShadeSpiky( vec3 pos, vec3 vpos, vec3 vdir, vec3 viewDir )\n{\n\tfloat validNorm = 0.;\n\tvec3 nor = calcNormal( pos, validNorm );\n//\t\tvec3 nor = ClassifyDir( pos );\n\t\t\n\tlightDir = normalize( lightDir );\n\tfloat l0i = clamp( -dot( nor, lightDir ), 0., 1. );\n\tfloat l0Sh = 1. ;\n\tif( l0i >0.02 )\n\t\tl0Sh = softShadowSpiky( pos, -lightDir, 5., 40., 3. );\n\tvec3 l0 = l0i * l0Sh * lightCol; \n\t\t\n\t\t\n\tvec3 lightDir1 = vec3( -1, 1, 0 );\n\tvec3 lightCol1 = 0.5*vec3( 0.22, 0.2, -0.17 );\n\t\t\n\tvec3 lightDir2 = normalize( viewDir + vec3(0.5,0.1,0.) );\n\tvec3 lightCol2 = 0.5*vec3( 0.12, 0.12, 0.2 );\n\t\t\t\t\n\tfloat sshCoef = 1.-clamp( -dot( nor, viewDir ), 0., 1. );\n\tsshCoef = pow( sshCoef, 1. );\n\t\t\t\n\t// va calculer l'ambient occlusion\n\tfloat ao = 1.-calcAOSpiky( pos, nor );\n\t\t\n\tvec3 l1 = clamp( -dot( nor, lightDir1 ) * lightCol1, 0., 1. );\n\tvec3 l2 = clamp( -dot( nor, lightDir2 ) * lightCol2, 0., 1. );\n\t\t\n\n\tvec3 col = mix( l0+l1, l2, ao ) ;\t\n\tcol += sshCoef * sssCol * validNorm ;\n\n\t// apply fog\n\tfloat fi =  ComputeFog( pos, vpos );\n\tcol = mix( fogCol, col, fi );\t\n\t\n\treturn col;\n}\n\nvec3 ShadeFloor( vec3 pos, vec3 vpos, vec3 vdir )\n{\n\tfloat aoSh = calcAOSpiky( pos, vec3(0.,1.,0.) );\n\tfloat l0Sh = softShadowSpiky( pos, -lightDir, 4., 10., 3.5 );\n\tl0Sh *= aoSh;\n\n\tvec3 col = mix( vec3(0.85), 0.5*sssCol, 0.4*(1.-l0Sh) ) ;\n\t\n\t// compute reflection :\n\tvec3 rdir = reflect( vdir, vec3(0,1,0) );\n\tfloat ts = TraceSpiky( pos, rdir );\n\tif( ts < 20. )\n\t{\n\t\tvec3 hpos = pos+rdir*ts ;\n\t\tfloat attY = exp( -0.2*max(hpos.y+8.,0.) );\n\t\tcol = mix( col, ShadeSpiky( hpos, vpos, rdir, vdir ), attY );\n\t}\n\t\t\n\t\n\t// apply fog\n\tfloat fi =  ComputeFog( pos, vpos );\n\tcol = mix( fogCol, col, fi );\t\t\n\t\n\treturn col ;\n//\treturn vec3(length( vpos-pos)/120.1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 camRot = vec2(0.4,2.6)+vec2(-2.5,8.5)*(iMouse.yx/iResolution.yx) ;\n\tcamRot.x = max( camRot.x, 0. );\n\tvec3 vpos, vdir;\n\tvec3 targetPos = vec3(0.,0.,0.);\n\tCamPolar( vpos, vdir, targetPos, camRot, 25.0 + 5.*cos(iTime*0.1), 1.5, fragCoord);\n\tvec3 viewDir = normalize( targetPos - vpos );\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 p = -1.0 + 2.0*uv;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t\n\tfloat ts = TraceSpiky( vpos, vdir );\n\tfloat tf = TraceFloor( vpos, vdir, viewDir );\n\t\n\tvec3 col ; \n\tif( ts < tf )\n\t\tcol = ShadeSpiky( vpos+vdir*ts, vpos, vdir, viewDir );\n\telse\n\t\tcol = ShadeFloor( vpos+vdir*tf, vpos, vdir );\n\t\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MssXz4","date":"1397944572","viewed":2153,"name":"Spiky","username":"u2Bleank","description":"Old school spiky ball effect.\ndevelopped on my lapop at 0.5fps at the Revision 2014.\nThe live battle coding session has rised my motivation to start something with shader toy\nUsed a lot of template/code from other shaders.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["balls","rotation","spikes"],"hasliked":0,"parentid":"","parentname":""}}