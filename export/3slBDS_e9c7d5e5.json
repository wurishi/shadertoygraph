{"ver":"0.1","info":{"id":"3slBDS","date":"1588978854","viewed":169,"name":"ShATI - Ombre","username":"Flopine","description":"My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 5th subject: shadow :) ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animation","isometric","motiondesign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI 3.141592\n#define TAU 6.2831853071\n#define dt mod(iTime-PI/4.,TAU)\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\n// reference for animation curves: https://easings.net/\nfloat easeInOutCirc(float x)\n{\n    return x < 0.5\n      ? (1. - sqrt(1. - (2. * x)*(2. * x))) / 2.\n      : (sqrt(1. - (-2. * x + 2.)*(-2. * x + 2.)) + 1.) / 2.;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\n#define anim(freq) easeInOutCirc(sin(dt*freq)*0.5+0.5)\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n   \tfloat b2 = box(p, vec3(5.));\n    float bigper = 5.;\n    p = mod(p-bigper*0.5, bigper)-bigper*0.5;\n    \n    float b1 = box (p, vec3(2.));    \n    float per = 0.5;\n    vec3 id = floor((p-per*0.5)/per);   \n    p = mod(p-per*0.5, per)-per*0.5;\n\n    return max(b2,max(b1, box(p,vec3(0.3-anim(1.)*0.2))));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float scale = mix(2.,9.,floor(sin(dt-2.)+1.));\n    vec3 ro = vec3(uv*scale,-20.),\n    \trd = vec3(0.,0.,1.),\n    \tp = ro,\n        l = vec3(1.,2.,-1.),\n        col = vec3(0.);\n    \n    float shad; bool hit = false;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p+=d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,normalize(l)),0.);\n        col = vec3(light);\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}