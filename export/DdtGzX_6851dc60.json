{"ver":"0.1","info":{"id":"DdtGzX","date":"1677638638","viewed":183,"name":"flubber","username":"pb","description":"gloopy 3d projection of 4d transformations","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nmat2 rot(float an) { float cc=cos(an),ss=sin(an); return mat2(cc,ss,-ss,cc); }\nfloat myTime;\n\nvec3 wheel(vec3 p) {\n    \n    float pzz = p.z*p.z;\n        \n    vec4 q = vec4(p , 1. );  \n    \n    vec4 jc = q;\n    \n    q.xz = rot(iTime/2.) * q.xz;\n    \n    \n    float i=0.;\n    float scale = .8;\n    float scale2 = .9;\n    float scale3 = 1.27;\n    \n    \n    for (;i<11.;i++){\n        \n        if ( q.x > 1. )  q.x = 2. - q.x;\n        else if ( q.x < -1.) q.x = -2. - q.x;\n        \n        if ( q.y > 1. )  q.y = 2. - q.y;\n        else if ( q.y < -1.) q.y = -2. - q.y;\n        \n        if ( q.z > 1. )  q.z = 2. - q.z;\n        else if ( q.z < -1.) q.z = -2. - q.z;\n        \n        if ( q.w > 1. )  q.w = 2. - q.w;\n        else if ( q.w < -1.) q.w = -2. - q.w;\n        \n        \n        q.xyz /= dot(q.xyz,q.xyz);  \n        q.yzw /= dot(q.yzw,q.yzw);\n        q.zwx /= dot(q.zwx,q.zwx);\n       \n        q.xyz = scale * q.xyz ;\n        q.yzw = scale2 * q.yzw ;\n        q.zwx = scale3 * q.zwx;\n        \n        q.xy = rot(pzz) * q.xy;\n        \n        q += jc;\n    \n      \n    }\n    \n    return q.xyz;\n    \n}\n\n\nvec3 march( vec3 ro, vec3 rd) {\n\n    float dist =  .6; \n    \n    vec3 p = ro;\n    \n    vec3 color = vec3(0);\n    \n    for (float i=0.; i<5.; i++) {\n    \n    \n        vec3 cx = wheel(ro+i*dist*rd);\n        \n        cx = 1. - exp(-cx * cx);\n        color += cx * cx*  exp(-i)  ;\n        \n    }\n    \n    return color; \n}\n\n\n\nvoid mainImage0( out vec4 O, in vec2 U )\n{\n\n    myTime = mod(iTime,80.);\n\n    U = (2.*U - iResolution.xy) / iResolution.y *1.3  ;\n    \n    U.y*=1.5;\n    \n    vec3 rd = normalize( vec3(U, 2.) );\n     \n    vec3 ro = vec3(0.,0., -4. );  \n    \n    vec3 color = march( ro, rd );\n        \n    O = vec4( pow(color,vec3(.45)), 1);\n\n}\n\n//thanks Faabrice\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}