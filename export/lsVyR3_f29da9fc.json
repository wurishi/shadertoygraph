{"ver":"0.1","info":{"id":"lsVyR3","date":"1619216943","viewed":58,"name":"terrain hex caster","username":"bolloxim","description":"generated terrain that is a hex map but then rendered with ray casting - work inprogress","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["meh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\n// still extremely crap stuff..  \n\n#define LIGHTPOS vec3(0.0,20.0, 0.0)\n#define LIGHTCOL vec3(1.0, 1.0, 1.0)\n#define LIGHTAMB vec3(0.015, 0.015, 0.015)\n#define LIGHTDIR normalize(vec3(0.5,-1.0,-1.0))\n#define LIGHTSIZE 10.0\n#define LIGHTSPEC 8.0\n\n#define RAY_MAX 1000.0\n#define MAX_BOUNCES 3\n\n#define BALLBEARINGS 30\n#define BALLRADIUS 2.0\n#define TUBELENGTH 4.0\n#define TUBERADIUS 1.5\n\n#define sqrt3Over2 0.86602540378\n\nstruct hitstruct\n{\n    vec4 hit;\n    vec3 hitnorm;\n    vec3 rgbtex;\n    int mat;\n};\n    \n    \nfloat gAnimTime = 0.0f;\nfloat map( vec2 p ) \n{\n    gAnimTime = iTime\n        ;\n\tfloat f = texture( iChannel3, p/iChannelResolution[3].xy, -10.0 ).x;\n\t\n\tf *= sqrt( texture( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0 ).x );\n\treturn 8.0*f;\n}\n\nvec3 CalcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nhitstruct TestTerrain( in vec3 rd, in vec3 ro )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( RAY_MAX, 0.0, 0.0, 0.0 );\n\tint o;\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<20; i++ ) \n\t{\n\t\to = i;\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) -0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\thitstruct hit;\n   \n    hit.hit = vec4(ro + rd*res.x, res.x);     \n\thit.hitnorm = CalcNormal( fract(hit.hit.xyz)-0.5, res.y );\n    hit.rgbtex = vec3(float(200-o)/200.0);\n    return hit;\n}\n\n    \n// t = -(p0 . N +d) /V.N\n// p = p0+tV\nhitstruct testPlane(in vec3 raydir, in vec3 raypos)\n{\n    hitstruct h;\n    h.mat = -1;\n    vec4 loc;\n    // plane for the floor\n    vec4 plane = vec4(0,1,0,0); // d in W \n    float t = -(dot(raypos, plane.xyz)+plane.w) / dot(raydir, plane.xyz);\n    if (t>0.00001)\n    {\n        loc = vec4(raypos + raydir*t, t);\n        h.rgbtex =  texture(iChannel1, loc.xz/iChannelResolution[1].xy*8.0).xyz * LIGHTAMB;\n        h.mat = 0;\n             \n        h.hitnorm = plane.xyz;\n    }\n    else loc = vec4(0,0,0,RAY_MAX); // missed\n    \n\n    h.hit = loc;\n\n    \n    return h;\n}\n\nhitstruct testSphere(in vec3 raydir, in vec3 raypos, int i)\n{\n    hitstruct h;\n    h.mat = -1;\n    float a = iTime * float(i+1) *0.25;\n    vec4 sphere = vec4(sin(a)*12.0, float(i+1)*BALLRADIUS, cos(a)*12.0, 2.0*2.0);\n    vec3 dist = sphere.xyz - raypos;\n    float proj = dot(dist, raydir);\n    vec4 loc = vec4(0,0,0,RAY_MAX);\n    h.rgbtex = vec3(1.0,1.0,1.0)*0.2;\n    float t2 = sphere.w - dot(dist, dist) + proj * proj ;\n\tif (t2>0.0)\n    {\n        float t = proj - sqrt(t2);\n        if (t>0.00001)\n        {\n            loc = vec4(raypos+raydir*t, t);\n            h.hitnorm = normalize(loc.xyz - sphere.xyz);\n\t\t\th.mat = 1;\n        }\n\n    }\n    h.hit = loc;\n\treturn h;\n}\n\nhitstruct testCylinder(in vec3 raydir, in vec3 raypos, int i)\n{\n    hitstruct h;\n    h.mat = -1;\n    vec4 loc = vec4(0,0,0,RAY_MAX);\n    h.rgbtex = vec3(1.0,1.0,1.0)*0.2;\n    \n    float theta = iTime * float(i+1) *0.25;\n    vec4 cylinderV = vec4(sin(theta)*6.0, 0.0, cos(theta)*6.0, 0.0);\n    cylinderV = normalize(cylinderV);\n    cylinderV.w = TUBELENGTH;\n    vec4 cylinderP = vec4(0.0, 3.0, 0.0, TUBERADIUS*TUBERADIUS);\n    \n    vec3 dist = raypos - cylinderP.xyz;\n    float proj = dot(dist, cylinderV.xyz);\n    float proj2 = dot(raydir, cylinderV.xyz); \n    \n    float a = 1.0 - proj2*proj2;\n    float b = dot( dist, raydir) - proj2*proj;\n    float c = dot( dist, dist) - proj*proj - cylinderP.w;\n    float t2 = b*b - a*c; // now where did we hit on the cylinder\n    if (t2>0.0001)\n    {\n     \tfloat t2s = sqrt(t2);   \n        float t = (-b - t2s) / a;\n        float t1 = proj + t*proj2;\n        if (abs(t1)<cylinderV.w)//length\n        {\t \n            loc = vec4(raypos+raydir*t, t);\n            h.hitnorm = normalize( dist+t*raydir - cylinderV.xyz*t1);\n\t\t\th.mat = 2;\n        }\n        else\n        {\n            float sgnt1 = sign(t1);\n  \t\t \tfloat temp = (sgnt1*cylinderV.w - proj)/proj2;\n\n   \t\t\t if( abs(b+a*temp)<t2s )\n   \t\t\t {\n                  loc = vec4(raypos+raydir*temp, temp);\n                  h.hitnorm = normalize( cylinderV.xyz*sgnt1);\n                 h.mat = 2;\n             }\n        }\n\n    }\n    h.hit = loc;\n\treturn h;\n}\n\nhitstruct TestScene(in vec3 raydir, in vec3 raypos)\n{\n    hitstruct hit = testPlane(raydir, raypos);\n    for (int i=0; i<BALLBEARINGS; i++)\n    {\n    \thitstruct hit2 = testSphere(raydir, raypos,i);\n\t    if (hit2.hit.w< hit.hit.w)\n    \t    hit = hit2;\n\t}\n//    hitstruct hit3 = testCylinder(raydir, raypos,0);\n//\t    if (hit3.hit.w< hit.hit.w)\n//    \t    hit = hit3;   \n //     hitstruct hit4 = TestTerrain(raydir, raypos);\n  //   if (hit4.hit.w< hit.hit.w)\n    //\t    hit = hit4;  \n    return hit;\n}\n\nvec3 Light( hitstruct h, in vec3 eye, in vec3 ray)\n{\n    // shadow test simple direction \n    for (int i=0; i<BALLBEARINGS; i++)\n    {\n        hitstruct s = testSphere(-LIGHTDIR, h.hit.xyz, i);\n    \tif (s.hit.w != RAY_MAX) return LIGHTAMB * h.rgbtex;\n    }\n    \n    // lambert diffuse (basic of basic lighting)\n    float difcoef = clamp(dot(h.hitnorm, -LIGHTDIR), 0.0, 1.0);\n    vec3 col = h.rgbtex * difcoef * LIGHTCOL;\n    col+=h.rgbtex * LIGHTAMB;\n    \n    // spec\n    float spec = clamp(dot(ray, reflect(-LIGHTDIR, h.hitnorm)), 0.0, 1.0);\n    col+=LIGHTCOL*pow(spec, LIGHTSPEC);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 ray = vec3(uv.xy, 2);\n    vec2 yawPitch = PI * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    yawPitch.x+=PI*0.5;\n    \n    // calculate yawpitch rotations\n    vec2 cYP = cos(yawPitch);\n    vec2 sYP = sin(yawPitch);\n\tmat3 camDir;\n    camDir[0] = vec3 (cYP.x, sYP.x * -sYP.y, sYP.x * cYP.y);\n    camDir[1] = vec3 (0.0, cYP.y, sYP.y);\n    camDir[2] = vec3 (sYP.x, cYP.x * sYP.y, -cYP.x * cYP.y);\n    \n    ray = normalize(ray) * camDir;\n    // Time varying pixel color\n    vec3 eyeray = ray;\n    vec3 ray_pos = vec3(0.0, 15.0, 20.0);\n\n    vec3 col = vec3(0.0,0.0,0.0);  // accumulated colour\n\n    for (int i=0; i< MAX_BOUNCES; i++)\n    {\n    \thitstruct h = TestScene(ray, ray_pos);\n\t\tif (h.hit.w == RAY_MAX)\n        {\n            col+=texture(iChannel0,ray).rgb;\n            break;\n        }\n        \n        // light pixel using normal information\n        vec3 litcol = Light(h, eyeray, ray);\n   \t    col += litcol;\n    \t// bounce\n   \t\tvec3 incident = normalize(h.hit.xyz - ray_pos);\n\t\tray = reflect(incident, h.hitnorm);\n        ray_pos = h.hit.xyz + ray*0.0001; // move it slightly\n      \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}