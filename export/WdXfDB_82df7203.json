{"ver":"0.1","info":{"id":"WdXfDB","date":"1588946344","viewed":126,"name":"fork-Resonant Lowpass Sawtooth","username":"jorge2017a1","description":"fork-Resonant Lowpass Sawtooth","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["forkresonantlowpasssawtooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///Resonant Lowpass Sawtooth\n\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110);C(115);C(105);C(100);C(101); // message \"Sound inside\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//modificado por Jorgefp-jorge2017a1\n\n///https://www.shadertoy.com/view/XljSD3\n//Created by metabog in 2015-11-07\n///Resonant Lowpass Sawtooth\n\n\n\nfloat a = pow(2.0,(1.0/12.0));\n\n//#define maxTaps 128\n#define maxTaps 12\n\nint baseNote;\n#define PI 3.141516\n\n///---------------------------------------\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n//================================================\n\nfloat frequency( int note )\n{\n    return 440. * exp2( float(note + baseNote) / 12. );\n}\n\n\nfloat triangleWave( int note, float time )\n{\n    return fract(frequency(note)*time)*2.-1.;\n}\n\nfloat squareWave( int note, float time )\n{\n    return step(.5,fract(frequency(note)*time))*2.-1.;\n}\n\nfloat sineWave( int note, float time )\n{\n    return sin(6.283185*frequency(note)*time);\n}\n\nfloat sineWavefreq( float freq, float time )\n{\n    return sin(6.283185*freq*time);\n}\n\nfloat triangleWavefreq( float freq, float time )\n{\n    return fract(freq*time)*2.-1.;\n}\n\n\nfloat voice(float t, float freq)\n{\n    \n    return sin(t+freq*sin(t*2.+sin(t*3.*freq)));\n}\n\n//-----------------------------------------\n\n\nfloat getNote(float n)\n{\n    return 100.0 * pow(a,n);\n}\n\nfloat Hash( float n )\n{\n\treturn fract( (1.0 + cos(n)) * 415.92653);\n}\n\n//we can use jitter for analog driftness\nfloat genSaw(float time, float freq, bool useJitter)\n{\n    float jitter1 = 0.0;\n    float jitter2 = 0.0;\n\n    if(useJitter)\n    {\n      jitter1 = texture(iChannel0, vec2(time,0.2)*0.01).x;\n      jitter2 = texture(iChannel0, vec2(time-0.01,0.2)*0.01).x;\n    }\n    \n    float val = fract(time*(freq + (jitter1+jitter2)*0.2));\n    return val;\n}\n\n//we can use \nfloat genSin(float time, float freq)\n{\n    \n    float val=0.0;\n  \n    \n     val+= voice(freq*3.141516*1.0,time );\n     val+= voice(freq*3.141516*2.0,time );\n     val+= voice(freq*3.141516*3.0,time );\n    \n    \n    return val;\n}\n\n\nfloat genvoice(float time, float freq)\n{\n    \n    float val=0.0;\n    \n    \n     val+= voice(freq*3.141516*1.0,time );\n     val+= voice(freq*3.141516*2.0,time );\n     val+= voice(freq*3.141516*3.0,time );\n    \n    \n    \n    return val;\n}\n\n\n\nfloat genNiceSin(float time, float freq)\n{\n    return (genSin(time,freq) - 0.5) * 2.0;\n}\n\nfloat genNicevoice(float time, float freq)\n{\n    return (genvoice(time,freq) - 0.5) * 2.0;\n}\n\n\n\nfloat genNiceSaw(float time, float freq, bool useJitter)\n{\n    return (genSaw(time,freq,useJitter) - 0.5) * 2.0;\n}\n\n\n\n\n/* Reso lowpass saw... truncated IIR #yoloswag */\nfloat resoLpSaw(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.1;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNiceSaw(t,freq,false);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n\n\n//-----------\n/* Reso lowpass saw... truncated IIR #yoloswag */\nfloat resoLpSin(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.1;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNiceSin(t,freq);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n\n\n///------------------------\n\nfloat resoLpvoice(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.1;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNicevoice(t,freq);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n//-----------\n\nfloat gain(float inp, float g)\n{\n    return inp*g;\n}\n\n\nfloat SIDLead(float time, float freq)\n{    \n    return resoLpSaw(time,freq,0.9) + (1.0 - resoLpSaw(time,freq+0.6,0.9));\n}\n\nfloat SIDLeadSin(float time, float freq)\n{    \n    return resoLpSin(time,freq,0.9) + (1.0 - resoLpSaw(time,freq+0.6,0.9));\n}\n\n\n\nfloat ftom(float note)\n{\n    return 440.0 * pow(2.0,((note-24.0)/12.0));\n}\n\nconst float cps = 1.0;\nfloat patt[8];\n\nvoid initPatt()\n{\n    patt[0] = 0.0;\n    patt[1] = 7.0;\n    patt[2] = 12.0;\n    patt[3] = 0.0; \n    patt[4] = 7.0;\n    patt[5] = 3.0;\n    patt[6] = 7.0;\n    patt[7] = 3.0;\n}\n\nfloat decay = 0.25;\n\nvec2 mainSound( in int samp,float time)\n{\n    \n    initPatt();\n    \n    float cf = abs(cos(time));\n\n    \n    float pulse = mod(time,1.0);\n    float wave = 0.0;\n        \n    for(int i =0; i<8; i++)\n    {\n        float localPulse = float(i)/8.0;\n        if(localPulse<pulse)\n        {   \n            float rfreq = ftom(mod(patt[i],12.0));\n            wave-= resoLpSaw(time,rfreq,cf) *  (clamp(pulse-localPulse,0.0,decay)/0.25 - 1.0);\n            wave+= resoLpvoice(time,rfreq,cf) *  (clamp(pulse-localPulse,0.0,decay)/0.25 - 1.0);\n            wave+= SIDLead( time, rfreq)*  (clamp(pulse-localPulse,0.0,decay)/0.25 - 1.0);\n            \n        }\n    }\n    \n    return vec2(wave,wave)*0.125;\n}","name":"Sound","description":"","type":"sound"}]}