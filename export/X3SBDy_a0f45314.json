{"ver":"0.1","info":{"id":"X3SBDy","date":"1729870025","viewed":88,"name":"Simple Raymarching Boilerplate","username":"Bingle","description":"Simple boilerplate for raymarching with camera/ray structs and sdf functions. Based on my raytracing boilerplate","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","template"],"hasliked":0,"parentid":"lccXDB","parentname":"Simple Raytracing Boilerplate"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching Boilerplate by Bingle\n/* Axis orientation (from default camera view):\n\n             ^ +Y\n             |\n             |\n     +X      |\n     <-------+\n              \\\n               \\| +Z\n              ‾‾\n*/\n\nfloat SDF(vec3 p){\n    return opSmoothUnion(sdSphere(p-vec3(sin(iTime*0.8)*1.25,0.0,0.0),0.5),sdSphere(p,1.0),0.4);\n}\n\nvec3 normal(vec3 P){\n    vec2 h = .0001*vec2(1,-1);\n    return normalize( vec3(h.xxy*SDF(P+h.xxy) + h.xyx*SDF(P+h.xyx) + h.yxx*SDF(P+h.yxx) + h.yyy*SDF(P+h.yyy) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    cam camera = cam(vec3(sin(iTime),0,2),vec3(0,0,-1),vec3(0,1,0),0.5);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    ray r = getCamRay(camera,uv);\n    bool hit = false;\n    int iters = 150;\n    float dist = 0.0;\n    \n    while (iters>0){\n        dist = SDF(r.pos);\n        if (dist<0.001){\n            break;\n        }\n        r.pos+=r.dir*dist;\n        iters--;\n    }\n    \n    if (iters>0){ // Hit\n        vec3 norm = normal(r.pos);\n        col = texture(iChannel0,reflect(r.dir,norm)).rgb;\n    }else{ // Miss\n        col = 0.5 + 0.5*r.dir;\n    }\n    \n    //col = vec3(1.0-float(iters)/150.0);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct cam{\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    float viewDist;\n};\n\nstruct ray{\n    vec3 pos;\n    vec3 dir;\n};\n\n// Takes UV coords -0.5 to 0.5 (or in whatever centered range really) and returns a ray\nray getCamRay(cam c,vec2 uv){\n    vec3 side = cross(c.dir,c.up);\n    vec3 up = cross(side,c.dir);\n    \n    return ray(c.pos,normalize(c.dir*c.viewDist + side*uv.x + up*uv.y));\n}\n\n// Returns the point at distance t along ray r\nvec3 at(ray r,float t){\n    return r.pos + r.dir*t;\n}\n\n//////////\n// SDFS //\n//////////\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b + r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n///////////////////\n// SDF Operators //\n///////////////////\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}","name":"Common","description":"","type":"common"}]}