{"ver":"0.1","info":{"id":"ftVyzc","date":"1661953634","viewed":86,"name":"Inverse function visualization","username":"RodrigoCastroF","description":"Visualize how you can plot the inverse function by flipping the function's graph diagonally. In this case, you will see the sine function (in blue) turn into the inverse sine function, arcsine (in red).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["plot","inversefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define SIZE 5.\n# define THICKNESS 0.05\n# define AXTHICKNESS 0.0165\n# define MARGIN 0.001\n\n# define STARTCHANGE 2.\n# define ENDCHANGE 4.\n# define STARTFLIP 5.\n# define ENDFLIP 7.\n\n# define PI 3.1415926538\n\nfloat maxcomp(vec2 p)\n{\n    return max(p.x, p.y);\n}\n\nfloat rectangle_sdf(vec2 R, vec2 p)\n{\n    vec2 q = abs(p) - R;\n    return length(max(q,vec2(0))) + min(maxcomp(q),0.0);\n}\n\nvec2 rotate(vec2 p, float angle)\n{\n    vec2 q;\n    q.x = p.x*cos(angle) - p.y*sin(angle);\n    q.y = p.x*sin(angle) + p.y*cos(angle);\n    return q;\n}\n\nfloat xletter_sdf(float size, vec2 centre, vec2 p)\n{\n\n    vec2 rectangle = vec2(size, size/6.);\n    \n    p -= centre;\n    \n    float angle1 = -45.0*PI/180.0;\n    vec2 q1 = rotate(p, angle1);\n    float arm1 = rectangle_sdf(rectangle, q1);\n    \n    float angle2 = 45.0*PI/180.0;\n    vec2 q2 = rotate(p, angle2);\n    float arm2 = rectangle_sdf(rectangle, q2);\n    \n    return min(arm1, arm2);\n}\n\nfloat yletter_sdf(float size, vec2 centre, vec2 p)\n{\n\n    vec2 rectangle1 = vec2(size, size/6.);\n    vec2 rectangle2 = vec2(size/3., size/6.);\n    \n    p -= centre;\n    \n    // Stand the Y letter upright after flip\n    if (iTime > (STARTFLIP + ENDFLIP) / 2.)\n    {\n        p.x = - p.x;\n        p.y = - p.y;\n    }\n    \n    float angle1 = -45.0*PI/180.0;\n    vec2 q1 = rotate(p, angle1);\n    float arm1 = rectangle_sdf(rectangle1, q1);\n    \n    float angle2 = 45.0*PI/180.0;\n    vec2 q2 = rotate(p, angle2);\n    q2 += vec2(size/2., 0.);\n    float arm2 = rectangle_sdf(rectangle2, q2);\n    \n    return min(arm1, arm2);\n\n}\n\nvec2 stretch_diagonally(vec2 p, float stretching_amount)\n{\n\n    /** Returns a vector that corresponds to 'p'\n     * strecthed (amount>1) or compressed (amount<1) diagonally\n     * (closer to, or farther away from, the diagonal)\n     * Actually, the behaviour is the opposite,\n     * but this is the effect that is seen */\n\n    // Change to base {(1/sqrt(2), -1/sqrt(2)), (1/sqrt(2), 1/sqrt(2))}\n    vec2 q;\n    q.y = (p.x + p.y) * sqrt(2.)/2.;\n    q.x = (p.x - p.y) * sqrt(2.)/2.;\n    \n    // Stretch along the old base's diagonal, or the new base's horizontal\n    q.x *= 1./stretching_amount;\n    \n    // Change back to original base {(1, 0), (0, 1)}\n    vec2 r;\n    r.x = q.x/sqrt(2.) + q.y/sqrt(2.);\n    r.y = - q.x/sqrt(2.) + q.y/sqrt(2.);\n    \n    return r;\n    \n}\n\nvoid paint(inout vec3 col, in vec3 color, in float activation)\n{\n\n    /** Subtracts from 'col' = vec3(1.) (white) a vector\n     * so that the color 'color' is given\n     * to those pixels with 'activation' == 1 */\n    \n    col -= vec3(1. - color.r, 1. - color.g, 1. - color.b) * activation;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //// ---- Defining pixel's position ---- ////\n    \n    vec2 p = SIZE * fragCoord.xy / iResolution.xy; // Coordinates from 0 to SIZE\n    p -= vec2(SIZE/2., SIZE/2.);  // Origin in center\n    p.x *= iResolution.x/iResolution.y; // x coordinate proportional to width\n    \n    //// ---- Stretching pixel's position along the diagonal ---- ////\n    \n    // float stretching_amount = sin(iTime);\n    float stretching_amount = 2. * (smoothstep(ENDFLIP, STARTFLIP, iTime) - 0.5);\n    p = stretch_diagonally(p, stretching_amount);\n    \n    //// ---- Establishing pixel's color ---- ////\n    \n    vec3 col = vec3(1.);  // white background\n    \n    //// Draw function\n    \n    float func = sin(p.x);  // exp(p.x) | p.x * p.x | sin(p.x)\n    \n    // Function color - transition between red (original function) and blue (its inverse)\n    vec3 func_color = vec3(\n        smoothstep(STARTCHANGE, ENDCHANGE, iTime), \n        0., \n        smoothstep(ENDCHANGE, STARTCHANGE, iTime)\n    );\n    \n    // Gray for invalid values (e.g. x<0 for sqrt(x), inverse of x^2)\n    if (p.x < -PI/2. || p.x > PI/2.) func_color = vec3(0.5);\n    \n    // Give color if pixel's height is between func - THICKNESS and func + THICKNESS\n    paint(\n        col,\n        func_color,\n        smoothstep(func - THICKNESS, func - THICKNESS + MARGIN, p.y)\n      * smoothstep(func + THICKNESS + MARGIN, func + THICKNESS, p.y)\n    );\n         \n    //// Draw axes\n    \n    // x axis - same as FUNCTION, but with func = 0.\n    paint(\n        col,\n        vec3(0.),  // black\n        smoothstep(-AXTHICKNESS, -AXTHICKNESS + MARGIN, p.y)\n      * smoothstep(AXTHICKNESS + MARGIN, AXTHICKNESS, p.y)\n    );\n    \n    // y axis - same as x axis, but using width instead of height\n    paint(\n        col,\n        vec3(0.),\n        smoothstep(-AXTHICKNESS, -AXTHICKNESS + MARGIN, p.x)\n      * smoothstep(AXTHICKNESS + MARGIN, AXTHICKNESS, p.x)\n    );\n    \n    //// Draw X and Y labels\n    \n    // initial positions\n    vec2 xpos = vec2(SIZE*0.4, -SIZE*0.075);\n    vec2 ypos = vec2(-SIZE*0.075, SIZE*0.4);\n    \n    // x label\n    vec2 px = p - (ypos - xpos)\n        * smoothstep(STARTCHANGE, ENDCHANGE, iTime);\n    float xd = xletter_sdf(SIZE/17.5, xpos, px);\n    paint(\n        col,\n        vec3(0.),\n        smoothstep(xd, xd + MARGIN, 0.)\n    );\n    \n    // y label\n    vec2 py = p - (xpos - ypos)\n        * smoothstep(STARTCHANGE, ENDCHANGE, iTime);\n    float yd = yletter_sdf(SIZE/17.5, ypos, py);\n    paint(\n        col,\n        vec3(0.),\n        smoothstep(yd, yd + MARGIN, 0.)\n    );\n    \n    fragColor = vec4(col.rgb, 1.0);\n    \n\n}","name":"Image","description":"","type":"image"}]}