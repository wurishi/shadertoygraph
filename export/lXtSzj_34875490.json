{"ver":"0.1","info":{"id":"lXtSzj","date":"1719321832","viewed":18,"name":"iscg-2024 1","username":"goldy","description":"提出","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["iscg"],"hasliked":0,"parentid":"fljfDc","parentname":"iscg-2022-example-raytracing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 単純なレイトレーシングの雛形\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(5.0,3.0,2.0); }\nvec3 CameraTo() { return vec3(0.2, 0.7, 0.2); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{\n    // TODO: ベクトル正規化normalize()や外積cross()を用いて実装する。\n    w=(from-to)/length(from-to);\n    u=cross(up,w)/length(cross(up,w));\n    v=cross(w,u);\n    e=from;\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n    // TODO: pixel coords to camera coords。\n    float i=pixelCoordinate.x;\n    float j=pixelCoordinate.y;\n    float x_=FilmWidth()*(1.0-2.0*((i+0.5)/iResolution.x));\n    float y_=FilmHeight()*(1.0-2.0*((j+0.5)/iResolution.y));\n    return vec3(x_,y_,FilmDistance());\n\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    // TODO: 以下を実装する。\n    // 1. convert pixel coordinates to camera coordinate system.\n    // 2. compute the orthonormal Cartesian basis of the camera coordinate system from the camera parameters.\n    // 3. convert pixel coordinates to world coordinate system using basis.\n    // 4. compute the camera ray.\n    vec3 camco=convertToCameraCoordinateSystem(pixelCoordinate);\n    vec3 u,v,w,e;\n    createOrthoNormalBasis(CameraFrom(),CameraTo(),CameraUp(),u,v,w,e);\n    vec3 worldco=camco.x*u+camco.y*v+camco.z*w+e;\n    Ray dummy;\n    dummy.org=e;\n    dummy.dir=(dummy.org - worldco)/length(dummy.org - worldco);\n    return dummy;\n}\n\nbool intersectToSphere(\n    vec3 centre, float radius, Ray ray,\n    out Hit hit\n)\n{\n    vec3 c_=ray.org-centre;\n    float c=dot(c_,c_) - radius*radius;\n    float b=2.0*dot(ray.dir,c_);\n    float a=dot(ray.dir,ray.dir);\n    float dis=b*b - 4.0*a*c;\n    if(dis<0.0){return false;}\n    else\n    {\n        float disc=pow(dis,0.5);\n        if(disc>-b){hit.distanceToHitpoint=(-b + disc)/(2.0*a);}\n        else{hit.distanceToHitpoint=(-b - disc)/(2.0*a);}\n        hit.normal=(ray.org + ray.dir*hit.distanceToHitpoint - centre)/radius;\n        return true;\n    }\n}\n\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n    vec3 g=convertToCameraCoordinateSystem(iMouse.xy);\n    vec3 u,v,w,e;\n    createOrthoNormalBasis(CameraFrom(),CameraTo(),CameraUp(),u,v,w,e);\n    vec3 worldco=g.x*u+g.y*v+g.z*w+e;\n    // TODO: intersectToSphere を用いて具体的な球との交差判定を行う。\n    return intersectToSphere(worldco,1.0,ray,hit);\n\n    //return hit.distanceToHitpoint < LargeFloat();\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdCircle( vec3 p, float s )\n{\n  return length(vec2(p.x,p.y))-s;\n}\nfloat sdPlane( vec3 p, vec3 nr, float b )\n{\n  vec3 cntr=convertToCameraCoordinateSystem(iMouse.xy);\n  vec3 u,v,w,e;\n  createOrthoNormalBasis(CameraFrom(),CameraTo(),CameraUp(),u,v,w,e);\n  vec3 worldco=cntr.x*u+cntr.y*v+cntr.z*w+e;\n  vec3 nrm=normalize(nr);\n  float q = abs(dot(p-cntr,nrm));\n  if(q>0.0){return q;}\n  float t=min(distance(cntr,p+q*nrm),distance(cntr,p-q*nrm));\n  if(t>b){return t-b;}\n  return 0.0;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q= vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SDF(vec3 p)\n{\n  return sdTorus(p,vec2(0.7,0.4));\n  //return sdSphere(p,1.0);\n  \n  //return sdPlane(p,vec3(0.01,2.2,0.6),0.020);\n  //return sdCircle(p,1.0);\n\n}\n\nvec3 shade(Ray ray, Hit hit)\n{\n    // TODO: なんらかのシェーディングを行う。\n    return vec3(0.6*hit.normal+0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n    //マウスで動かせるボールはこの下のコードをuncomment、他をcomment\n    //Hit hit;\n    //if (intersect(ray, hit))\n    //{\n    //    fragColor = vec4(shade(ray, hit), 0.0);\n    //}\n    //else\n    //{\n    //    fragColor = vec4(0.0);\n    //}\n  vec3 dir = ray.dir;\n\n  vec3 cur = vec3(3.0); //initial ray position\n  for(int itr=0;itr<66;++itr){\n    float s0 = SDF(cur);\n    \n    if( s0 < 1.0e-3 ){\n      float del = 1.0e-3;\n      float sx = SDF(cur+vec3(del,0,0))-s0; \n      float sy = SDF(cur+vec3(0,del,0))-s0; \n      float sz = SDF(cur+vec3(0,0,del))-s0; \n      vec3 nrm = normalize(vec3(sx,sy,sz)); \n      \n      fragColor = vec4(0.6*nrm+vec3(0.7),0);\n      return;\n    }\n    cur += s0 * dir; // advance ray\n  }\n  fragColor = vec4(0.0);\n}\n","name":"Image","description":"","type":"image"}]}