{"ver":"0.1","info":{"id":"dtdSzB","date":"1685549842","viewed":39,"name":"Texturing Cones (Galaxy Cones)","username":"RaphaZev","description":"2 Cones with a camera spinning around them. Both have outward facing normals defining the color.\nOne uses a lines pattern and the other uses a Triangle pattern. The lines pattern is generated using noise, while the triangles are only deformed with noise.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","noise","intersection","primitives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raytracing the intersection with the suraface of a cone and mapping\n// noise to make a texture.\n\n// Special thanks to iquilezles for providing the cone intersection function\n// Cone intersection: https://www.shadertoy.com/view/llcfRf\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and https://iquilezles.org/articles/intersectors\n\n// Thanks to book of shaders for noise, tile and lines pattern functions\n// https://thebookofshaders.com/09/ | https://thebookofshaders.com/10/ | https://thebookofshaders.com/11/\n \n// Fbm and related functions from https://www.shadertoy.com/view/XlKyRw \n\nvec2 random2(vec2 st){\n   vec2 val = vec2(dot(st,vec2(127.1,311.7)),\n   dot(st,vec2(269.5,183.3)) );\n   return -1.0 + 2.0*fract(sin(val)*43758.5453123);\n}\n\nfloat fade(float t) \n{\n    return t*t*t*(t*(6.0*t-15.0)+10.0); \n}\n\nfloat hash13(vec3 pos)\n{\n    vec2 uv = pos.xy + pos.z;\n    return texture(iChannel0, (uv+ 0.5)/256.0).x;\n}\n\nfloat grad3D(float hash, vec3 pos) \n{\n    int h = int(1e4*hash) & 15;\n\tfloat u = h<8 ? pos.x : pos.y,\n \t\t  v = h<4 ? pos.y : h==12||h==14 ? pos.x : pos.z;\n    return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n}\n\nfloat perlinNoise3D(vec3 pos)\n{\n\tvec3 pi = floor(pos); \n    vec3 pf = pos - pi;\n    \n    float u = fade(pf.x);\n    float v = fade(pf.y);\n    float w = fade(pf.z);\n    \n    return mix( mix( mix( grad3D(hash13(pi + vec3(0, 0, 0)), pf - vec3(0, 0, 0)),\n                           grad3D(hash13(pi + vec3(1, 0, 0)), pf - vec3(1, 0, 0)), u ),\n            \t      mix( grad3D(hash13(pi + vec3(0, 1, 0)), pf - vec3(0, 1, 0)), \n                \t \t   grad3D(hash13(pi + vec3(1, 1, 0)), pf - vec3(1, 1, 0)), u ), v ),\n        \t\t mix( mix( grad3D(hash13(pi + vec3(0, 0, 1)), pf - vec3(0, 0, 1)), \n                \t\t   grad3D(hash13(pi + vec3(1, 0, 1)), pf - vec3(1, 0, 1)), u ),\n            \t\t  mix( grad3D(hash13(pi + vec3(0, 1, 1)), pf - vec3(0, 1, 1)), \n                \t\t   grad3D(hash13(pi + vec3(1, 1, 1)), pf - vec3(1, 1, 1)), u ), v ), w );\n}\n\nfloat fbm(vec3 pos, int octaves) \n{\n    float noiseSum = 0.0, frequency = 1.0, amplitude = 1.0;\n    \n    for(int i = 0; i < octaves; ++i) \n    {\n        noiseSum += perlinNoise3D(pos * frequency) * amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n\n    return noiseSum;\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat random3 (in vec3 st) {\n    return fract(sin(dot(st.xyz,\n                         vec3(12.9898,78.233, 151.7182)))\n                * 43758.5453123);\n}\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat perlin(vec2 p, float freq){\n    float unit = iTime * freq;\n    vec2 ij = floor(p);\n    vec2 xy = mod(p, 1.0);\n    //xy = 3.0 * xy * xy - 2.0 * xy * xy * xy;\n    xy = .5 * (1. - cos(3.14 * xy));\n    float a = dot(random2(ij), xy);\n    float b = dot(random2(ij + vec2(1.0, 0.0)), xy - vec2(1.0, 0.0));\n    float c = dot(random2(ij + vec2(0.0, 1.0)), xy - vec2(0.0, 1.0));\n    float d = dot(random2(ij + vec2(1.0, 1.0)), xy - vec2(1.0, 1.0));\n    return mix(mix(a, b, xy.x), mix(c, d, xy.x), xy.y);\n}\n\nmat3 rotate3d(float angle){\n    return mat3(cos(angle),-sin(angle),0.0,\n                sin(angle),cos(angle),0.0,\n                0.0,0.0,1.0);\n}\n\nfloat lines3d(in vec3 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\n\n\n// Triangle function based on drawn triangle from https://www.shadertoy.com/view/lsBfRc\n// And noise shape curve example from https://thebookofshaders.com/edit.php#11/circleWave-noise.frag\nfloat getTriangle(vec2 p, vec2 rp){\n    p *= vec2(iResolution.x, iResolution.y);\n    p /= max(iResolution.x, iResolution.y);\n    \n    p -= rp;\n\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n\n    // Remap the space to -1. to 1.\n    p = p *2.-1.;\n\n    // Number of sides of your shape\n    int N = 3;\n\n    // Angle and radius from the current pixel\n    float a = atan(p.x,p.y)+3.14;\n    float r = 2.*3.14/float(N);\n\n    // Modulating the shape so it \"moves\"\n    float m = abs(mod(a+iTime*12.,3.14*2.)-3.14)/3.6;\n    m += perlin((p+iTime*12.), mod(iTime, 5.))*.5;\n    r += sin(a*25.)*perlin((p+iTime*1.6), mod(iTime, 5.))*.1;\n    r += (sin(a*20.)*.1*pow(m,2.));\n    //r = 1.-smoothstep(r,r+0.007,2.*PI/float(N)); //crazy mode\n\n    // Shaping function that modulate the distance\n    d = cos(floor(.5+a/r)*r-a)*length(p);\n\n    // Applying noise to the border of the shape\n    d += 0.12*perlin((p*3.), mod(iTime, 5.)); // Change this value to deform the shape\n\n\n    return 1.0-step(.16,d);\n    //return 1.0-smoothstep(r, .12,d);\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st, float scale){\n\n    //  Scale the coordinate system by 2x2\n    _st *= scale;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,3.14*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        _st = rotate2D(_st,3.14*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        _st = rotate2D(_st,3.14);\n    }\n\n    return _st;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec4 iCappedCone( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n         if( m1<0.0 ) { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) return vec4(-m1/m3,-ba*inversesqrt(m0)); }\n    else if( m2>0.0 ) { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) return vec4(-m2/m3, ba*inversesqrt(m0)); }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) \n    {\n        return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n    }\n    \n    return vec4(-1.0);\n}\n\n#define AA 3\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n       \n        vec3  pa = vec3( 0.0, -0.20, 0.0);\n        vec3  pb = vec3( 0.0, 0.20, 0.0);\n        float ra = 0.25;\n        float rb = 0.00;\n        \n        // raytrace\n        vec4 tnor = iCappedCone( ro, rd, pa, pb, ra, rb );\n        // raytrace second cone but slighty to the right\n        vec4 tnor2 = iCappedCone( ro, rd, (pa+vec3(0.5,0.0,0.0)), (pb+vec3(0.5,0.0,0.0)), ra, rb );\n        // get the closest intersection\n        if( tnor.x>0.0 && tnor.x<tnor2.x ) tnor2.x  = 0.;\n\n        float t = tnor.x;\n        float t2 = tnor2.x;\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            \n            vec3 w = normalize(pb-pa);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-pa)*mat3(u,v,w);\n\n            col = tnor.yzw;\n            \n            vec3 post = vec3(1.);\n            \n            float pattern = post.x;\n\n            // Add noise\n            post = rotate3d( perlinNoise3D(pos) ) * pos;\n\n            // Draw lines\n            //pattern = lines(post,cos(iTime));\n            //pattern = lines(post,sin(iTime/1.5));\n            pattern = lines3d(post,0.5);\n            //float pattern2 = lines(post,0.5);\n            \n            //pattern = pattern*(sin(iTime)) + pattern*cos(iTime);\n            //pattern = mix(pattern*(sin(iTime)), pattern*(cos(iTime)), mod(iTime, 1.0));\n            \n            //uv = tile(uv,2.);\n            //uv = tile(uv,cos(iTime/4.));\n            //uv = rotateTilePattern(uv, 2.);\n            \n            //vec3 triangle = getTriangle(uv, vec2(0.0, -0.23)) * vec3(2.0, 30.0, 2.0) * 2.0;\n\n            // Apply perling noise to the first cone with 4 octaves\n            col = sqrt(vec3(fbm( pos, 4 )));\n            //col += 0.5*( gl_FragCoord.xyz/iResolution.xyz, 4 );\n            \n            //col = mix(triangle, col, sin(iTime/2.));\n        }\n\n        // Apply random perling noise to the second cone\n        if (t2>0.0) {\n            vec3 pos = ro + t2*rd;\n            vec3 nor = tnor2.yzw;\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n\n            vec3 w = normalize(pb-pa);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-pa)*mat3(u,v,w);\n\n            col = tnor2.yzw;\n\n            uv = tile(uv,2.);\n            uv = rotateTilePattern(uv, 1.);\n            \n            vec3 triangle = getTriangle(uv, vec2(0.0, -0.23)) * vec3(2.0, 30.0, 2.0) * 2.0;\n            \n            col += triangle; // Light Mode\n            //col *= triangle; // Dark Mode\n            \n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}