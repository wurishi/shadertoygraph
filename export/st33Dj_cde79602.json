{"ver":"0.1","info":{"id":"st33Dj","date":"1636720130","viewed":62,"name":"Fork Lorenz att but images","username":"Bupeldox","description":"Uses a lorenz attractor, a chaotic equation, to do weird stuff.\nThis compares start point of the strange attractor (screen xy + z kinda time), to the output (as the rotation from 0,1).","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math","trippy","lorenz"],"hasliked":0,"parentid":"stSGR3","parentname":"Lorenz attractor Weirdness"},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat speed = 1.;\nfloat scale = 4000.0;\nvec2 offset = vec2(0.0,0.0);\nfloat yitterations = 10.;\n\nfloat infinity = 1.0/0.0;\n\nfloat zinp = 0.0;\n\n\n\nfloat tSin(float inp){\nreturn (sin(inp)+1.)/2.;\n}\n\nvec3 LorenzDifferential(vec3 tinput,float delta){\n    float sigma = 20.0;\n    float beta= pow(tSin(speed*iTime/1.242)*10.0,2.);\n    float ohmega= pow(tSin(speed*iTime/4.35)*10.0,2.);\n\n    float x = tinput.x;\n    float y = tinput.y;\n    float z = tinput.z;\n    \n    vec3 newPoint = vec3(\n        (sigma*(y-(x))),\n        (x*(ohmega-abs(z)))-y,\n        ((x*y)-(beta*z))\n    );\n    newPoint = newPoint * delta;\n    return newPoint;\n}\n\n\nvec3 lorenzAttractor(vec3 start,float delta,float itterations){\n\t\n\t\n    \n\tvec3 currentPoint = start;\n    \n\t\n\tfor(float i = 0.;i<itterations;i+=1.0){\n\t\tvec3 tdelta = LorenzDifferential(currentPoint,delta);\n        vec3 newPoint = currentPoint + tdelta;\n        \n        if(abs(newPoint.x)==infinity||abs(newPoint.y)==infinity||abs(newPoint.z)==infinity){\n            //return vec3(max(-i,newPoint.x),max(-i,newPoint.y),max(-i,newPoint.z));\n            return vec3(-i);\n        }\n        \n\t\tcurrentPoint = newPoint;\n\t}\n    \n    vec3 finalTDelta = LorenzDifferential(currentPoint,delta*mod(itterations,1.));\n    \n\treturn currentPoint+finalTDelta;\n}\n\n\nvec3 canvasPToCoord(vec2 inp){\n\n\n    inp = inp - (iResolution.xy*0.5);\n    inp = inp/iResolution.xx;\n    inp.x *= 0.2;\n    inp = inp * scale;\n    inp = inp + offset;\n\treturn vec3(inp,zinp);\n}\n\nfloat transformFunc (float x){\n    //The largest sig fig.\n    float a = floor(log(x))/log(10.)-1.0;\n    float b = x/pow(10.,a);\n    float c = (b-10.)/90.;\n    return min(max(c,0.),1.);\n}\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 colourTransform(vec3 col){\n        ///*\n        //Winding\n\n        float angle = acos(dot(normalize(col.xy), vec2(0.,1.)))*2.;\n          float dist = length(col);\n        vec3 hsv = vec3(angle/(3.1415*2.),0.5,min(max(sqrt(dist)/20.,0.),1.));\n        col = hsv2rgb(hsv);\n        return col;\n        /**/\n        \n        /*\n        //Exponent\n        /**/\n        \n        /*\n        //Exponential Grid\n        col.x =transformFunc(col.x);\n        col.y =transformFunc(col.y);\n        col.z =transformFunc(col.z);\n        col = col*9.;\n        return col;\n        /**/\n\n}\n\n\n\nvec3 colorTransform2(vec3 col){\n   \n    vec3 hsl = rgb2hsv(col);\n\n    hsl.x = hsl.x/2.;\n    hsl.x+=mod(speed*iTime/12.3,1.0);\n    hsl.z = pow(hsl.z,0.2);\n    hsl.x += 0.5;\n\n    return hsv2rgb(hsl);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float tTime = speed*iTime/2.0;\n   \n    \n    float szoom = (sin(tTime/2.)+1.0);\n    \n    yitterations = 5. + ((sin(tTime)+1.0)*80.0);\n     \n     \n     \n     \n    scale = ((szoom+3.0)-pow((sin(tTime))+1.,1.1)) *3000.0;\n    zinp = cos(tTime/3.14)*1000.0;\n     \n    vec3 col = vec3(0);\n    \n    vec3 p = canvasPToCoord(fragCoord);\n    \n    \n    vec3 endPoint = lorenzAttractor(p,0.001,yitterations);\n    endPoint = abs(endPoint);\n    col = endPoint;\n    //col = colourTransform(endPoint); \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 outputCol = texture( iChannel0, uv).xyz; \n    \n    \n    if(col.x>col.y&&col.x>col.z){\n        outputCol = texture( iChannel0, uv).xyz; \n    }\n    if(col.y>col.z&&col.y>col.z){\n        outputCol = texture( iChannel1, uv).xyz; \n    }\n    if(col.z>col.x&&col.z>col.y){\n        outputCol = texture( iChannel2, uv).xyz; \n    }\n    \n    \n    fragColor = vec4(outputCol,1.0);\n}\n","name":"Image","description":"","type":"image"}]}