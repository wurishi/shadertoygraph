{"ver":"0.1","info":{"id":"Wd2GRR","date":"1547971084","viewed":281,"name":"3dCross grid","username":"theepicsnail","description":"Flying through a grid of crosses","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["asdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n#define MAX_DIST 10.0\n#define EPS 0.0001\n#define ITR 100.0\nvec2 delta = vec2(.01,0);\nvec3 lastCell = vec3(0);\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co){\n    return fract(sin(vec2(dot(co.xy ,vec2(12.9898,78.233)),dot(co.yx,vec2(13.1898,73.231)))) * 43758.5453);\n}\n\nfloat rand3(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233, 49.566))) * 43758.5453);\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat SDF(vec3 ro, vec3 rd) {\n    float d =MAX_DIST;\n    vec3 c = ro + .5;\n    lastCell = floor(c);\n    ro=fract(c)-.5;\n    \n    float t = iTime*.8 + length(lastCell)*.3;\n    float p = fract(t);\n    float r = p;//length(lastCell);\n    r *= PI / 2.0;\n    switch(int(mod(t,3.0))){\n        case 0: ro.xy = rotate(ro.xy,r); break;\n        case 1: ro.yz = rotate(ro.yz,r); break;\n        case 2: ro.zx = rotate(ro.zx,r); break;\n    }\n    \n    t= min(.1,length(ro.xy));\n    d = min(d, length(ro)*.1);\n    d = min(d, length(ro.xy)-t);\n    d = min(d, length(ro.yz)-t);\n    d = min(d, length(ro.zx)-t);\n    d = max(d, length(ro)-.45);\n    return d;\n}\n\n\nvec3 EstNormal(vec3 ro, vec3 rd) {\n    float cx = SDF(ro+delta.xyy, rd)-SDF(ro-delta.xyy, rd);\n    float cy = SDF(ro+delta.yxy, rd)-SDF(ro-delta.yxy, rd);\n    float cz = SDF(ro+delta.yyx, rd)-SDF(ro-delta.yyx, rd);\n    return normalize(vec3(cx,cy,cz));\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 p = ro;\n    float t;\n    float d;\n    float i = 0.0;\n    float c = 1.0;\n    vec3 pos;\n    for(; i < ITR ; i++) {\n    \tt += d = SDF(pos=ro+rd*t,rd);\n        c = min(d,c);\n        if(t > MAX_DIST || d < EPS) break;\n    }\n   \tvec3 cell = lastCell;\n    vec3 normal = EstNormal(pos, rd);\n    \n    \n    vec3 lightPos = ro + vec3(sin(iTime),cos(iTime),cos(iTime*.1))*100.0;\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 lightColor = hsv2rgb(vec3(iTime*.1,.5+.5*sin(iTime*.2),1));\n    float lightDist = length(lightPos-pos)+length(ro-pos);\n    float l = -dot(normal, lightDir);\n    //float l = clamp(0.0,1.0,dot(reflect(rd,normal), normalize(lightPos)));\n    \n    vec3 color = hsv2rgb(vec3(rand3(cell),1,1));\n    return color*(lightColor/lightDist + dot(normal,-rd)/t);\n    //return fract(ro+rd*t)/d*.02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tim=iTime;\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\ttim*=0.5;\n\tvec3 ro=vec3(cos(tim),cos(tim*0.3)*0.5,cos(tim*0.7))*min(0.5+tim*0.1+cos(tim*0.4)*0.5,1.5);\n\tvec3 rd=lookat(-ro)*normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y,1.0));\n    \n    ro.yz *= .2;\n    ro.yz += .5;\n    ro.x += iTime*.5;\n    \n\tvec3 color=scene(ro,rd,fragCoord.xy);\n\tcolor=clamp(color,0.0,min(tim,1.0));\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}