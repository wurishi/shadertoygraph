{"ver":"0.1","info":{"id":"ctGXDt","date":"1686442116","viewed":89,"name":"Infinity RayMarching","username":"Leopold_Waymire","description":"Infinity RayMarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxDist = 20.;\nvec3 cameraPos = vec3(0., 0., 0.);\nvec3 cameraRot = vec3(0., 0., 0.);\nvec3 light = vec3(4., 3., 2.);\nvec3 boxSize = vec3(4.);\nvec2 mouse;\n\n\nmat3x3 rotate(vec3 a){\n    a = vec3(radians(a));\n    mat3x3 xRot = mat3x3(\n    vec3(        1.,         0.,         0.),\n    vec3(        0.,  cos(-a.x), -sin(-a.x)),\n    vec3(        0.,  sin(-a.x),  cos(-a.x)));\n    mat3x3 yRot = mat3x3(\n    vec3( cos(-a.y),         0.,  sin(-a.y)),\n    vec3(        0.,         1.,         0.),\n    vec3(-sin(-a.y),         0.,  cos(-a.y)));\n    mat3x3 zRot = mat3x3(\n    vec3( cos(-a.z), -sin(-a.z),         0.),\n    vec3( sin(-a.z),  cos(-a.z),         0.),\n    vec3(        0.,         0.,         1.));\n    return xRot*yRot*zRot;\n}\n\nvec3 normVec(vec3 a)\n{\n    float dist = distance(a, vec3(0., 0., 0.));\n    if(dist > 0.)\n    {\n       return a/dist;\n    } else {\n        return vec3(0., 0., 1.);\n    }\n}\n\nfloat unionSDF(float a, float b){\n    return min(a, b);\n}\n\nfloat intersectSDF(float a, float b){\n    return max(a, b);\n}\n\nfloat differenceSDF(float a, float b){\n    return max(a, -b);\n}\n\n\nfloat sphereSDF(vec3 pos, float rad){\n    return(distance(pos, vec3(0.))-rad);\n}\n\nfloat boxSDF(vec3 pos, vec3 size){\n    vec3 d = abs(pos)-size;\n    float inDist = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outDist = length(max(d, 0.0));\n    return inDist+outDist;\n}\n\nfloat torusSDF( vec3 pos, vec2 size)\n{\n  vec2 q = vec2(length(pos.xz)-size.x,pos.y-size.y/2.);\n  return length(q)-size.y;\n}\n\nfloat cylinderSDF(vec3 pos, vec2 size)\n{\n  vec2 d = abs(vec2(length(pos.xz),pos.y)) - size;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat octSDF(vec3 pos, float size)\n{\n  pos = abs(pos);\n  return (pos.x+pos.y+pos.z-size)*inversesqrt(3.);\n}\n\nfloat sceneSDF(vec3 pos)\n{\n    float angle = float(iFrame)*1.;\n    vec3 corePos = pos*rotate(vec3(0., angle*2., 0.));\n    float core = differenceSDF(octSDF(corePos, 1.1), boxSDF(corePos, vec3(1.1, 0.1, 1.1)));\n    float outer = boxSDF(pos, vec3(0.9))-0.1;\n    outer = differenceSDF(outer, cylinderSDF(pos, vec2(0.8, 2.)));\n    outer = differenceSDF(outer, cylinderSDF(pos*rotate(vec3(90., 0., 0.)), vec2(0.8, 2.)));\n    outer = differenceSDF(outer, cylinderSDF(pos*rotate(vec3(0., 0., 90.)), vec2(0.8, 2.)));\n    outer = differenceSDF(outer, sphereSDF(pos, 1.2));\n    //outer = intersectSDF(outer, sphereSDF(pos, 1.6));\n    float dist = unionSDF(core, outer);\n    dist = unionSDF(dist, sphereSDF(pos-light, 0.1));\n    return dist;\n}\n\nvec3 guessNormal(vec3 pos, float offset){\n    return normalize(vec3(\n    sceneSDF(vec3(pos.x+offset, pos.y,pos.z))-sceneSDF(vec3(pos.x-offset, pos.y,pos.z)),\n    sceneSDF(vec3(pos.x, pos.y+offset,pos.z))-sceneSDF(vec3(pos.x, pos.y-offset,pos.z)),\n    sceneSDF(vec3(pos.x, pos.y,pos.z+offset))-sceneSDF(vec3(pos.x, pos.y,pos.z-offset))\n    ))*vec3(1., 1., -1.);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float minSide = min(iResolution.x, iResolution.y);\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/minSide;\n    mouse = vec2(90., 45.)*(2.0*vec2(iMouse)-iResolution.xy)/minSide;\n    cameraPos = rotate(vec3(0., mouse.x, 0.))*vec3(cos(radians(-mouse.y)), sin(radians(-mouse.y)), 0.)*3.;\n    //cameraPos = rotate(vec3(0., 45., 0.))*vec3(3., 3., 0.);\n    cameraRot = vec3(mouse.y, 90.-mouse.x, 0.);\n    //cameraRot = vec3(-45., -45., 0.);\n    vec3 ray = normVec(vec3(uv.x, uv.y, 1.)+0.0001*cameraPos);\n    ray = ray*rotate(cameraRot);\n    vec3 pos = cameraPos;\n    vec3 truePos = pos;\n    float dist = sceneSDF(pos);\n    for(int i = 0; i < 100; i += 1){\n        dist = sceneSDF(pos);\n        dist = min(dist, sceneSDF(mod(pos+ray*dist+boxSize*0.5, boxSize)-boxSize*0.5));\n        pos = mod(pos+ray*dist*1.0+boxSize*0.5, boxSize)-boxSize*0.5;\n        truePos += ray*dist;\n        if(distance(truePos, cameraPos) > 50.){\n            break;\n            }\n\n        \n    }\n    dist = distance(pos, cameraPos);\n    vec3 col = vec3(0., 0., 0.);\n    if(distance(pos, vec3(0., 0., 0.)) < maxDist){\n        vec3 normal = guessNormal(pos, 0.00005);\n        col = (normal+vec3(1.0))/2.;\n        //col *= dot(normalize(light-truePos), col)*0.9+0.1;\n        float brightness = 10.*(1.-distance(normal, normalize(light-truePos))*0.5)/distance(light, truePos);\n         col *= brightness;\n     }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}