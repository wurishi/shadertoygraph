{"ver":"0.1","info":{"id":"WlXfW7","date":"1596825654","viewed":260,"name":"Noise Normalization","username":"ruojake","description":"My technique for restoring contrast in noise with any number of octaves. Useful when you really need your noise to hit 0 and 1 consistently. Number of octaves and persistence per octave are modulated by time. Right side normalized.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Noise Normalization by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// The technique is at row 56, rest is your normal noise stuff.\n// I came up with this thing via trial and error in desmos\n// so it may well be that there's some named, established and\n// well defined math in play that I'm simply unaware of.\n// If so, feel free to educate me in the comments!\n\nfloat oct;\nfloat per;\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(1.433, 1.512))) * 4313.441);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(mix(hash12(i),hash12(i+o),f.x),\n               mix(hash12(i+o.yx),hash12(i+1.),f.x),\n               f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float res = 0.;\n    float a = 1.;\n    for(float i = 1.; i <= oct; i += 1.)\n    {\n    \tres += noise(p) * a;\n        a *= per;\n        p *= 2.;\n        p += 100.;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    oct = floor(fract(iTime / 48.) * 6. + 1.);\n\tper = fract(iTime * .125) * .9 + .05;\n\n    float comp = (1.-per)/(1.-pow(per,oct));\n    float n = fbm(uv * 10. - vec2(iTime * .1, 0.)) * comp;\n    \n\t// here's the interesting bit\n    if (uv.x > 0.)\n    {\n    \tn = clamp(\n            (1. + per * log(oct))\n            * (n - .5) + .5,\n            0., 1.);\n        // clamping is kinda optional here \n        // but the value does occasionally cross beyond 0-1 range\n    }\n\n    vec3 col = vec3(n);\n    \n    if (uv.y < 0.)\n    {\n    \tcol = mix(vec3(1,0,0),vec3(0,0,1), n);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}