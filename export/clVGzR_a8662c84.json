{"ver":"0.1","info":{"id":"clVGzR","date":"1684009037","viewed":208,"name":"Quadtree Incremental Load  ","username":"kastorp","description":"Wait  for quad data load... the resolution will increase up to 32768x32768\n\non the left: quad data (with counters for each level)\npress mouse to zoom 8x (hold shift  for further 4x zoom)","likes":18,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot","quadtree","morton"],"hasliked":0,"parentid":"cl33Ds","parentname":"Quadtree Compression"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Quadtree Incremental Load by Kastorp\n//----------------------------------------\n//  Wait  for quad data load... the resolution will increase up to 32768x32768\n//\n//   on the left side, dump memory utilization:\n//     color is the quad level (max level=15 with resolution 2^15=32768x32768)\n//     brightness is the quad state (0:EMPTY, 1:DIVIDED, 2:SOLID, 3:NEED EXPANSION)\n//     the counters show number of active quads for each level\n// \n//   ACTIONS:\n//    press bar to reset \n//    press mouse to move POV (and zoom 8x) \n//    hold shift  for further 4x zoom\n//    press A to disable lighting (faster quad loadings)\n//    press B to suspend incremental loading\n//    press C to collapse level 14\n//    press D to collapse level 13\n//    press E to reexpand from level 13\n//    press F to prioritize higher levels\n//----------------------------------------\n//\n//   COMMON:\n//    quad struct & functions\n//\n//   BUFFER A:\n//    at reset, the quad is inizialized with uncompressed data\n//    at each frame, the incremental loading routine:\n//      - expands quads with state=3  (using buffer D findings)\n//      - remove quads with state=0\n//\n//   BUFFER B & C:\n//    data are compressed and sorted by level & state\n//\n//   BUFFER D\n//    find free memory for new quads (4 texels for each row of buffer C)\n//    find the expandable quads (one for each row of buffer C) \n//    compute counters\n//\n//   IMAGE:\n//    quad coloring by level\n//    lighting using quad traversal\n//\n//--------------------------------------------\n\n\n#define MAXSTEP 150\n//#define DEBUG\n\n\n\n#define tvec vec2\n//using tree ray traversal from Abje: https://www.shadertoy.com/view/XdyfRy\nvec3 trace(in tvec ro,in tvec rd,float d) //, vec2 uv,inout vec3 O,float zm) \n{  \n    float size = 1.;  //current voxel size\n    tvec lro = mod(ro+.5,size); // quad corner position\n    tvec fro = ro-lro;  //relative position inside quad\n    tvec mask;\n    bool exit= false; \n    int recursions = 0; //current LOD from 0 to detail\n     \n      \n    //the tree traverser loop\n    for (int i = 0; i < MAXSTEP; i++)\n    {\n        \n        \n        int state =0;\n        if(exit)state=1;\n        else {\n            Quad qq= getQuadFromUV(iChannel2, recursions-1,lro +fro ); \n            state=qq.state;\n        }\n        \n        //debug        \n       // O= mix(O,vec3(1,1,0),smoothstep(0.05/zm*min(size,.1),.0,length(uv-fro-lro)));                   \n                       \n        //hit\n        if (state >=2 ||length(lro+fro-ro)>d)\n        {\n           // normal=-mask*sign(rd);                   \n            return vec3(length(lro+fro-ro),recursions,float(i));\n        }\n        //go up a level (without moving)\n        if (exit)\n        {           \n            tvec newfro = floor(fro/size*0.5+0.25)*size*2.0;           \n            lro += fro-newfro;fro = newfro;recursions--; size *= 2.0;           \n            exit = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n            continue;\n        }\n        //go down one level (without moving)\n        else if(state == 1 && recursions<=detail)\n        {           \n            recursions++; size *= 0.5;\n            //find which of the 4 quad I will enter\n            tvec mask2 = step(tvec(size),lro);\n            fro += mask2*size; lro -= mask2*size;\n            continue;\n        }\n               \n        //move forward\n\n        //raycast and find distance to nearest quad border in ray direction\n        tvec hit = -(sign(rd)*(lro-size*.5)-size*.5)/max(abs(rd),0.00001); \n \n            mask = step(hit, hit.yx); \n\n           // mask = step(hit.xyz, hit.yzx) * step(hit.xyz, hit.zxy);            \n\n        float len = dot(hit,mask)+0.00001; //move a bit forward, outside current block         \n\n        //moving forward in ray direction, and checking if i need to go up a level\n        lro += rd*len-mask*sign(rd)*size;\n        tvec newfro = fro+mask*sign(rd)*size ;\n \n        exit = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n        fro = newfro;\n\n    }\n    return vec3(length(lro+fro-ro),-1.,50.);\n    \n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   \n   vec2 uv = (I-RR.xy*.5)/RR.y;\n   O=vec4(0);\n   \n   if(uv.x<-.5){//DUMP MEMORY UTILIZATION \n              \n        int   cx= int((I.x/(RR.x*.5 -.5*RR.y) +I.y)*RR.x);\n        int   Rx =int(RR.x);\n        Quad q=  decodeQuad(texelFetch(iChannel2,ivec2(cx%Rx,cx/Rx),0));\n        O= vec4(0,1,0,0)+ vec4(q.state,q.unreachable,q.level,0)*vec4(.2,-1,.2,0)*(q.state==1 && q.firstChildPos<=0?.0:1.);\n        if(q.swapIndex<8 &&! q.unreachable) O=vec4(1,1,0,0);      \n         O=lcol(q.level)*(q.unreachable?0.:1.)*(.75 + float(q.state)/12.);\n        ivec4 st =ivec4(texelFetch(iChannel1,ivec2(cx%Rx,0),0));\n        if(cx/Rx==st.y) O=vec4(1,1,0,0); // SHOW TOP FOR EACH ROW\n        if(cx/Rx==st.x) O=vec4(1,1,1,0); // SHOW  EXPANDABLE QUADS\n         \n         //COUNTERS FOR EACH LEVEL       \n         #define C(c)   O+= char(U,64+32+c,0);U.x-=.5;\n         float ct=0.;\n         for(int lv =1;lv<16;lv++){\n             vec2 U=I/RR.y*25. -vec2(.1,8+lv);\n             pInt(U,1,float(lv),lv);  U.x-=1.;C(-38)\n             \n             vec4 dt =texelFetch(iChannel1,ivec2(lv,18),0);\n             float c=dt.y+dt.z+dt.w;ct+=(c);\n             pInt(U,6,c,0); //COUNTER OF ACTIVE QUADS\n             \n         }\n             \n             vec2 U=I/RR.y*25. -vec2(.6,8+16); \n             ct*=100./RR.x/RR.y;\n             C(16-32);C(-38) U.x+=.0;pInt(U,6,ct,ct<80.?2:5);\n\n         draw_char(iChannel0,O);\n    } else{\n         \n         if keyToggle(71) return;\n        float zoom=2. ;\n        vec2 ro= iMouse.z>.0? (iMouse.xy-RR.xy*.5)/RR.y :vec2(cos(iTime*.5)*.2,sin(iTime*.5)*.3);\n\n        if(iMouse.z>0.) {zoom=8.;}\n        if(keyDown(16)) zoom*=4.;\n        \n        uv=(uv-ro)/zoom+ro;\n        vec3 col=vec3(0);\n           \n        //get highest detail for current position  \n        res=ivec2(RR);\n        Quad q =getQuadFromUV(iChannel2,uv);;\n        if(q.state>=2 &&q.level>=0)  col= lcol(q.level).rgb ;\n        else if(q.state==0) col.z=float(q.level)/float(detail);  //empty\n\n\n    #ifdef DEBUG\n        int i = q.level;\n        if(i>0 && i<=detail){\n            int id= getQuadFromUV(i,uv).code;\n            int idp= getQuadFromUV(i-1,uv).code;\n            //if((idp-id/4)!=0) col.x*=1.; //DEBUG PARENT MORTON CODE\n            if( id > idp*4+3 || id < idp*4 ) col*=0.; //DEBUG PARENT MORTON CODE\n        }\n    #endif\n\n        if(!keyToggle(65)){\n             col+=smoothstep(0.005/zoom,.0,length(uv-ro));\n            //quad traversal distance           \n            vec3 h = trace(ro,normalize(uv-ro),length(ro-uv));//,uv,col,zoom);\n            if (h.x-length(ro-uv)>-.001/zoom) col+=  vec3(.8,.8,.3)* min(1.,exp(-15.*length(uv-ro))); \n            else col*=.7;\n         }   \n        O= vec4(col,1.0);\n    }\n       \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define RR iResolution.xy \n//https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//Z-Curve 2 by FabriceNeyret\n//https://www.shadertoy.com/view/XdsyWr\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n#define loglevel 3 // max 3    1: for 16x16 grid  2: for 256x256 grid\n\nint xy2z(ivec2 I) {                   // --- grid location to morton code \n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n\nivec2 z2xy(int z) {                  // --- morton code to grid location \n    int n=1;\n    ivec2 I = ivec2(z,z>>1) & MASKS[0];\n    for (int i=1; i<=loglevel+1; i++)\n        I = (I | (I >>  n)) & MASKS[i],\n        n *= 2;\n    return I;\n}\n\n\n\n//-----------------------\n\nstruct Quad{\n    int level;\n    int code;\n    bool unreachable; \n    int state;\n    int firstChildPos;\n    int swapIndex;\n    int nextChildPos;\n   \n\n};\n\nQuad decodeQuad(vec4 d){\n    ivec4 i =ivec4(d);\n    return Quad(\n        i.x&31,\n        //int(d.z), \n        floatBitsToInt(d.z),\n        (i.x&256)>0,\n        (i.x&192)/64,\n        i.y,\n        (i.x&(15*512))/512,\n        i.w);\n    \n}\nvec4 encodeQuad(Quad q){\n    vec4 d= vec4(max(q.level,0) + (q.state*64) + (q.unreachable?256:0)+(q.swapIndex*512),q.firstChildPos,0,q.nextChildPos);\n    d.z= //float(q.code);\n         intBitsToFloat(q.code);\n    return d;\n}\n\nQuad nullQuad( int i) {return Quad(i,floatBitsToInt(0.) ,true,0,0,8,0);}\n\n#define  detail 15  // maximum LOD \nivec2 res;\n\n//input idx=buffer position;  i=level\nQuad getQuadDirect(sampler2D ch, int i,int idx){\n    if(i<0)  return Quad(i,0,false,1,0,8,0);\n     \n     vec4 d =texelFetch(ch,ivec2(idx%res.x,idx/res.x),0);\n     if(idx>res.x*res.y) {return nullQuad(i) ;}                          \n     return decodeQuad(d);\n}\n\n\n//input m=morton code;  i=level\nQuad getQuadFromCode(sampler2D ch, int i, int m){\n    if(i<0)  return Quad(i,0,false,1,0,8,0);\n    int off= (1<<(i+1));\n    if( m>=0  && m<off*off){       \n        Quad q;\n       \n        for(int j=0;j<=i;j++){ \n\n           int cp = (m>>((i-j)*2))&3;   \n           for(int ci=0;ci<4;ci++){\n               int idx= (ci ==0)? (j<=0?0:q.firstChildPos):q.nextChildPos;\n               if(idx==0 && cp<3 &&j>0 ) return nullQuad(i);;\n               q= getQuadDirect(ch,j,idx);              \n               if(cp==(q.code&3)) break;       \n           }          \n        }\n         if(q.code!=m) return nullQuad(i);\n         return q;\n     }\n     return nullQuad(i);\n}\n//input i=tree level; p=uv position\nQuad getQuadFromUV(sampler2D ch,int i, vec2 p){\n    if(min(p.x,p.y) <-.5) return nullQuad(i) ; //outside quad     \n    ivec2 c = ivec2((p+.5)*exp2(float(i)+1. )); \n    int m= xy2z(c) ;\n    return getQuadFromCode(ch,i,m);\n}\n\n//input ps=position\nQuad getQuadFromUV(sampler2D ch,vec2 ps){\n    Quad q;\n    vec2 pso=ps;\n    for(int i=0;i<=detail;i++){           \n        if(any(greaterThan(abs(ps),vec2(.5)))) { q=nullQuad(i);   break;} //out of bound\n         vec2 mask = step(vec2(0),ps);\n         ps= (ps+.25 -mask*.5)*2.;\n         int cp=int(mask.x)+int(mask.y)*2;\n         for(int ci=0;ci<4;ci++){\n           int idx= (ci ==0)? (i<=0?0:q.firstChildPos):q.nextChildPos;\n           if(idx==0  &&ci>0 ) return nullQuad(i);\n           q= getQuadDirect(ch,i,idx);    \n           if(cp==(q.code&3) && i==q.level-1) break;\n         }\n\n       if(q.state>=2 || q.state==0)  break;\n\n    }\n    //double check... there's is a bug in the previous code of this routine\n    if(getQuadFromUV(ch,q.level-1,pso).code!=q.code) return nullQuad(q.level-1);\n     return q;\n}\n//------------------------------------------\n\n//David Hoskins Hash without sin\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//xy=center, z=orientation\nvec3 tri(vec2 uv){ \n    const mat2 sk = mat2(2./sqrt(3.),0,1./sqrt(3.),1),ski = inverse(sk); float d=1./6.;\n    float sd =step(fract(uv*sk).x ,fract(uv*sk).y)*2.-1.;\n    vec2  c = floor(uv*sk) +vec2(.5) + sd*d*vec2(-1,1) ;c*=ski;\n    return vec3(c,sd);\n}\n#define TAU 6.28318530718\n\nfloat maze(vec2 uv){\n\n    vec3 t = tri(uv);\n    float r = floor(hash12(t.xy)*6.); //random rotation \n\n    float tk=.05;\n    float d=1e5;\n    uv = t.xy+ (uv-t.xy)*rot(TAU/3.*(r));\n    \n    if(r>=3.){\n        for(int i=0;i<3;i++){\n            d=min(d,max((uv.x-t.x)*t.z,abs(t.y-uv.y)-tk));\n            uv = t.xy+ (uv-t.xy)*rot(TAU/3.);        \n        }\n    }else{\n        uv = t.xy+ (uv-t.xy)*rot(-TAU/4.);\n         d=min(d,abs(t.y-uv.y+.25/sqrt(3.)*t.z) -tk);  \n         d=min(d,length(uv-t.xy+vec2(0,.5/sqrt(3.))*t.z)-tk);\n    }\n    d=max(d,length(uv-t.xy)-.275);\n    return d;\n }\n//--------------------------------\n\n#define keyDown(i) (texelFetch(iChannel3,ivec2(i,0),0).x>.5)\n#define keyToggle(i) (texelFetch(iChannel3,ivec2(i,2),0).x>.5)\n\n//FabriceNeyret\n#define lcol(i)  (i<=0?vec4(1):.6+cos(vec4(0,2,4,0) - float(i)*1.15)*.3) \nint char_id = -1, char_col=0; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c,int cc) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) \n    char_id = c,char_col=cc, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvoid draw_char(sampler2D ch, inout vec4 O) {\n    int c = char_id; vec2 p = char_pos;\n    if( c >= 0 )O= lcol(char_col)*textureGrad( ch, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy ).x;\n}\nvec4 pInt(vec2 p, int nc,float n,int cc) {\n    vec4 v = vec4(0);\n    int nnc=int(log(n)/log(9.99999));\n    if (nnc<nc)  {p-=vec2(nc-nnc,0)*.5; nc=nnc;}\n    for (float i = float(nc); i>=0.; i--)  n /=  9.999999, v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.),cc );\n    return v;\n}\n#define  chars( pos,  ids) for(int i_=0;i_<ids.length();i_++) {char( pos +vec2(i,0)*10.,ids[i_]);}\n\n\n//MANDELBROT INTERIOR DISTANCE \n//https://github.com/adammaj1/Mandelbrot-book-book/blob/main/src/interior-distance.c\nfloat cnorm(vec2 z)\n{\n  return dot(z,z);\n}\nvec2 cmul(vec2 a,vec2 b){\nreturn vec2(a.x*b.x - a.y*b.y, \n\t\t\t\t a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a,vec2 b){\n    return vec2(a.x*b.x + a.y*b.y, \n\t\t\t\t -a.x*b.y + a.y*b.x)/dot(b,b);\n}\n\nfloat cabs(vec2 z){return sqrt(cnorm(z));}\n\nvec2  m_attractor(vec2  w0, vec2 c, int p, int n)\n{\n  vec2 w = w0;\n  for (int m = 0; m < n; ++m)\n  {\n    vec2 z = w;\n   vec2 dz = vec2(1,0);\n    for (int i = 0; i < p; ++i)\n    {\n      dz = 2. * cmul(z ,dz);\n      z = cmul(z , z) + c;\n    }\n    w = w - cdiv(z - w, dz - vec2(1,0));\n  }\n  return w;\n}\n\nfloat  m_interior_distance (vec2 z0, vec2 c, int p)\n{\n   vec2 z = z0;\n   vec2 dz= vec2(1,0);\n   vec2 dzdz = vec2(0);\n   vec2 dc =vec2(0);\n   vec2 dcdz =vec2(0);\n    for (int m = 0; m < p; ++m)\n    {\n        dcdz = 2. * (cmul(z , dcdz) + cmul(dz , dc));\n        dc = 2. * cmul(z , dc) + vec2(1,0);\n        dzdz = 2. * (cmul(dz , dz) + cmul(z , dzdz));\n        dz = 2. * cmul(z , dz);\n        z = cmul(z , z) + c;\n    }\n    return (1. - cnorm(dz))\n        / cabs(dcdz + cdiv(cmul(dzdz , dc) , (vec2(1.,0) - dz)));\n}\n\nfloat  m_distance(int N, float R, vec2 c)\n{\n    vec2  dc = vec2(0);\n    vec2 z = vec2(0);\n    float  m = 1e40;\n    int p = 0;\n    for (int n = 1; n <= N; ++n)\n    {\n        dc = 2. * cmul(z , dc) + vec2(1,0);\n        z = cmul(z , z) + c;\n        if (cabs(z) > R)\n            return tanh( cabs(z) * log(cabs(z)) / cabs(dc));\n           \n        if (cabs(z) < m)\n        {\n            m = cabs(z);\n            p = n;\n            vec2 z0 = m_attractor(z, c, p,64);\n            vec2 w = z0;\n            vec2 dw = vec2(1,0);\n            for (int k = 0; k < p; ++k)\n            {\n                dw = 2. *cmul( w , dw);\n                w = cmul(w , w) + c;\n            }\n            if (cabs(dw) <= 1.)\n                return -tanh(m_interior_distance(z0, c, p))/2.;\n        }\n    }\n    return 0.;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// buffer A: load quad data from SDF\n\n//#define DETAIL\n#define SLEV 11\nfloat map(vec2 p){\n\n#ifdef DETAIL\n    float z=.125, R=25.; vec2 c=vec2(-.85,0.24); int step=300;\n#else\n    float z=4.,R=25.; vec2 c=vec2(-.5,0.); int step=100;\n#endif\n\n    float d= //maze(p*8.)/8.;            \n              m_distance(step,R*R,p*z+c)/z;\n     return d;\n}\n\n//input p= the position, sz=the size of the quad\n//output state: 0=empty, 1=subdivide, 2=solid \nint check(vec2 p, float sz){\n   float d=map(p);\n    const float sq2=sqrt(2.)/2.*1.1;\n    ivec2 b= ivec2(d+sz*sq2<0., //inside,\n                   d-sz*sq2<0.); //not empty\n    return int(b.x+b.y); //state \n}\n\n#define RR iResolution.xy \n\nint check(int lv, int code){\n    ivec2 cp = z2xy(code);           \n    float sz =1./(exp2(float(lv)));\n    vec2 p = vec2(-0.5) + (sz)*(vec2(cp)+.5);\n    return check(p,sz);\n}\n\n//x: state(0=empty,1=divide,2=solid), y:code,z:unreachable, w: level\nvec4 setQuad(int idx){\n    vec4 O=vec4(0);\n    int lvl=16384,off=0;\n    if(idx<4){lvl=2; off=0;}\n    else if(idx<20){lvl=4; off=4;}\n    else if(idx<84){lvl=8; off=20;}\n    else if(idx<340){lvl=16; off=84;}\n    else if(idx<1364){lvl=32; off=340;}\n    else if(idx<5460){lvl=64; off=1364;}\n    else if(idx<21844){lvl=128; off=5460;}\n    else if(idx<87380){lvl=256; off=21844;}\n    else if(idx<349524){lvl=512; off=87380;}\n    else if(idx<1398100){lvl=1024; off=349524;}\n    else if(idx<1398100){lvl=1024; off=349524;}\n    else {lvl=2048; off=1398100;} // --> 1398100  working only on flullscreen\n     \n    int code= idx-off;\n    int lv =int(log2(float(lvl)));\n    \n    if(lv>SLEV) return encodeQuad(nullQuad(lv));\n    \n    int st =check(lv,code); \n    int fcp=code*4+ off+lvl*lvl; //first child pos\n    if(fcp>int(RR.x*RR.y)){fcp=0;if(st==1) st=3;}\n    if(st==0 || st==2) fcp=0;\n    int ncp=idx+1;\n    bool ur=false;\n    if(lv==SLEV) {fcp=0; if(st==1) st=3;}\n     \n    if((code&3)==3) ncp=0;\n\n   \n    \n    Quad q = Quad(lv,code,ur,st,fcp,8,ncp)  ;\n    \n    \n    //check unreachable      \n    //if(q.state==0) q.unreachable=true;\n    //else\n    int pcode=code;\n    for(int lvp=lv-1;lvp>0;lvp--){       \n     ;\n        pcode= pcode/4 ;\n        const float TOLERANCE=1.5; \n        if( lvp>0 && check(lvp,pcode) !=1  ) {q.unreachable=true;break;}\n    }\n       \n    return encodeQuad(q);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    Quad q;\n    ivec2 c =ivec2(I);\n    res=ivec2(RR);\n    int pos =c.x + c.y* int(RR.x);\n    if(iFrame<1 || keyDown(32)\n      ||texelFetch(iChannel0,ivec2(0),0).z!=iResolution.y\n        ){ \n        O=vec4(0);\n        O=setQuad(pos);\n        return;\n    }\n    \n    else q =  decodeQuad(texelFetch(iChannel2,c,0));\n    \n  \n    ivec4 st =ivec4(texelFetch(iChannel0,ivec2(c.x,0),0));\n    \n    bool go =!keyDown(66);\n    if(st.y>0 && c.y>=st.y &&  c.y<=st.y+3 && st.x>0  &&go ){\n  \n        //new quad\n        Quad qp = decodeQuad(texelFetch(iChannel2,ivec2(c.x,st.x),0))  ;\n        if(qp.level<15 && qp.code>0 &&qp.state==3 &&!qp.unreachable && q.unreachable){\n            q.level=qp.level +1;\n            q.firstChildPos=0;\n            //Quad qn = decodeQuad(texelFetch(iChannel2,ivec2(c)+ivec2(0,1),0))  ;\n            //if(qn.unreachable) \n            q.nextChildPos=pos + int(RR.x);\n            q.swapIndex=8;\n            q.code= (c.y-st.y) +4*qp.code;\n            q.state=check(q.level,q.code);\n            if(q.state==1) q.state=3;\n            q.unreachable=false;\n            //q.unreachable=(q.state==0);     \n        }\n    }\n    \n    else  if(c.y ==st.x && st.x>0  &&  st.y>0  && q.level<15 && q.state==3 &&go) {\n        //subdivisible quad\n        //Quad qc = decodeQuad(texelFetch(iChannel2,ivec2(c.x,st.y),0))  ;\n        //if(qc.unreachable)\n        q.firstChildPos=st.y*int(RR.x)+c.x;\n        q.state=1;\n       \n        \n    }\n    \n#if 1\n    //REMOVE EMPTY QUADS\n     else if(q.level>1 && go){\n        //mark unreachable quads\n        if( getQuadFromCode(iChannel2,q.level-1,q.code).code != q.code) {\n            q.state=0; q.unreachable=true;\n        }\n     \n        // skip empty quads in nextChildPos\n        if(q.state!=0 && q.nextChildPos>0){\n           Quad q2;\n           int idx=q.nextChildPos;\n           for(int ci=0;ci<4;ci++){ \n              \n               if(idx==0 ) break;\n               q2= getQuadDirect(iChannel2,q.level-1,idx); \n               if(q2.state!=0) break;\n               idx= q2.nextChildPos;         \n           } \n           q.nextChildPos=idx;        \n        }\n        \n        // skip empty quads in firstChildPos\n        \n        if(q.state==1 && q.firstChildPos>0){\n             Quad q2;\n            int idx=q.firstChildPos;\n            for(int ci=0;ci<4;ci++){ \n              \n               if(idx==0 ) break;\n               q2= getQuadDirect(iChannel2,q.level,idx);\n               \n               if(q2.state!=0) break;\n              \n               idx= q2.nextChildPos; \n               if((q2.code&3)==3)idx=0;\n           } \n           q.firstChildPos=idx; \n            if(idx==0) q.state=0; \n        \n        }\n        \n        if(q.state==1 && q.firstChildPos>0){\n             Quad q2;\n             int nSolid=0;\n            int idx=q.firstChildPos;\n            for(int ci=0;ci<4;ci++){ \n              \n               if(idx==0 ) break;\n               q2= getQuadDirect(iChannel2,q.level,idx);\n               \n               if(q2.state==2) nSolid++;\n              \n               idx= q2.nextChildPos; \n               if((q2.code&3)==3)idx=0;\n           } \n           if(nSolid==4) {q2.state=2; q.firstChildPos=0;}\n        \n        }\n        \n        \n        \n        if(q.state==0 || q.state==2) q.firstChildPos=0;\n        if(q.firstChildPos==0 && q.state==1) q.state=2;\n        //if(q.state==0 && q.level >1) q.unreachable=true;\n       \n       if(q.level>=15 && q.state>0) q.state=2;\n       if(q.level>=14 && q.state==3 && keyDown(67)) q.state=2;\n       if(q.level>=13 && q.state==3 && keyDown(68)) q.state=2;\n       if(q.level>=13 && q.state>0 && keyDown(69)) q.state=3;\n    }\n    \n\n    \n#endif  \n    \n\n    O=encodeQuad(q);\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//buffer B: sorting quads by reachability and level \n\nint reLevel(int l){return (l>=11 && l<=14?25-l:l); }\nbool priorityLevel15=false;\nbool cmp(vec4 a,vec4 b ){ \n    Quad qa = decodeQuad(a);\n    Quad qb = decodeQuad(b);\n    if(qa.unreachable) return true;\n    if(qb.unreachable) return false;    \n    \n    if(qa.level!=qb.level) return priorityLevel15? reLevel(qa.level)>reLevel(qb.level):(qa.level>qb.level); //\n    if(qa.state!=qb.state) return (qa.state<qb.state);\n    return qa.code>qb.code;\n}\n\n#define SW(a,b)  if(cmp(v[a],v[b])) {vec4 t = v[a]; v[a] =v[b]; v[b] = t; int s=np[a];np[a]=np[b];np[b]=s; }\nvoid sort(inout vec4[8] v,inout int[8] np){\n    SW(0,1); SW(2,3); SW(0,2); SW(1,3); SW(1,2); \n    SW(4,5); SW(6,7); SW(4,6); SW(5,7); SW(5,6);\n    SW(0,4); SW(1,5); SW(1,4); SW(2,6); SW(3,7); \n    SW(3,6); SW(2,4); SW(3,5); SW(3,4);\n}\n\n//pixel XOR Sorting 4x by Kastorp https://www.shadertoy.com/view/ftlfD8\n//sorting network https://www.shadertoy.com/view/XsXGDX\n\nvoid mainImage( out vec4 O, in vec2 U )\n{   \n    Quad q;\n\n    ivec2 R=ivec2(RR);\n    if(R.x*R.y>(1<<21)  || keyDown(70)) priorityLevel15=true;\n    int l= int(log2(RR.x*RR.y))-2, //maximum xor level\n        z=(iFrame/2)%l,zz=1<<z, //current xor level; also zz=1<<(2*z) works, with z<=l/2\n        ii = (int(U.x) + int(U.y)*R.x), //current position\n        i=ii/zz, //xor position\n        s= ((i&4)/4 == (iFrame&1)) ?0:1, //sorting side s=0 left, S=1 right\n        m= s*4+(i&(3)), //relative position in sort array\n        h= min(i -(i&(3)),i -(i&(3))-s*4) ; //first position in array  \n                \n    vec4[8] P; //sorting array\n    int[8] N; //swap index\n    for(int k=0;k<8;k++){\n         int j=(h+k)*zz + (ii%zz); //k-th absolute position\n         P[k]=texelFetch(iChannel2,ivec2(j%R.x,j/R.x),0); //previous values\n         N[k]=k;\n    }         \n    \n    if(h>=0 && (h+4)*zz>0 && (h+4)*zz  < ((R.x*R.y)&((1<<24)-4*zz)))  { ///sort only if inside boundaries\n        sort(P, N); \n              \n        int k;\n        for(k=0;k<8;k++){\n            if(N[k]==m) break;\n        }      \n        q=decodeQuad(P[m]);\n        if(N[m]!=m){          \n            q.swapIndex=k; //previous and next swap indexes\n        }else{\n            \n            q.swapIndex=8;\n        }       \n     } \n    else {\n        q=decodeQuad(P[m]);\n        q.swapIndex=8;   //otherwise keep order       \n    }\n    O=encodeQuad(q);\n    \n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//buffer B:  update pointers  after sorting\n\nint getPos(int ii, int k){\n    vec2 R=iResolution.xy;\n    int l= int(log2(R.x*R.y))-2, //maximum xor level\n    z=(iFrame/2)%l,zz=1<<z, //current xor level; also zz=1<<(2*z) works, with z<=l/2\n    i=ii/zz, //xor position\n    s= ((i&4)/4 == (iFrame&1)) ?0:1, //sorting side s=0 left, S=1 right\n    m= s*4+(i&(3)), //relative position in sort array\n    h= min(i -(i&(3)),i -(i&(3))-s*4) ; //first position in array  \n\n    return (h+k)*zz + (ii%zz);\n}\nvoid mainImage( out vec4 O, in vec2 I )\n{\n     Quad q =  decodeQuad(texelFetch(iChannel2,ivec2(I),0));\n    \n     int res = int(iResolution.x),\n         pfc = q.firstChildPos; //previous first child\n     vec4  data =texelFetch(iChannel2,ivec2(pfc%res,pfc/res),0);\n     Quad q2= decodeQuad(data);   \n     int nfc = getPos(pfc,q2.swapIndex); //new first child    \n      if(q2.swapIndex<8) q.firstChildPos=nfc; //update pointer\n      \n      \n     int   pnc = q.nextChildPos; \n     vec4  data3 =texelFetch(iChannel2,ivec2(pnc%res,pnc/res),0);\n     Quad q3= decodeQuad(data3);   \n     int nnc = getPos(pnc,q3.swapIndex); //new first child    \n      if(q3.swapIndex<8) q.nextChildPos=nnc; //update pointer\n      \n         \n      O=encodeQuad(q);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//buffer D: statistics &  subdivisible quads for each row\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O=vec4(0);\n    if(I.y>19.5) return;\n    \n    else if(I.y<1.5){\n        ivec4 st=ivec4(0);\n        //x= first subdivisible column \n        //y= first of 4 consecutive empty columns \n        int nu=0;\n        for(int y =0;y<int(iResolution.y);y++){\n            Quad q = decodeQuad(texelFetch(iChannel2,ivec2(I.x,y),0));\n            if(st.x==0 && q.state==3 && q.firstChildPos<=0 && !q.unreachable) st.x=y;\n\n            if(q.unreachable &&nu<4  &&y>0) {st.y=y-nu; nu++;}\n            else if(!q.unreachable && nu<4){ st.y=0; nu=0;}\n        }\n        if(nu<4 ) st.y=0;\n        \n        O=vec4(st);\n        O.z=iResolution.y;\n    }else if(I.y<17.5){\n        O=vec4(0);\n        int lv = int(I.y);\n        int nu=0;\n        for(int y =0;y<int(iResolution.y);y++){\n             Quad q = decodeQuad(texelFetch(iChannel2,ivec2(I.x,y),0));\n             if(q.level==lv)  O[q.state]++;\n        }      \n    }else{\n        O=vec4(0);\n        if(I.x<18.5){\n            O=vec4(0);\n            int lv=int(I.x);\n            for(int x =0;x<int(iResolution.x);x++){\n            \n                O+=texelFetch(iChannel0,ivec2(x,lv),0);\n            }          \n        }        \n    }   \n}","name":"Buffer D","description":"","type":"buffer"}]}