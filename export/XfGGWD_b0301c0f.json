{"ver":"0.1","info":{"id":"XfGGWD","date":"1712738947","viewed":30,"name":"S6 Sphere","username":"raphaeleg","description":"- ray marching\n- point on sphere\n- light, light direction\n-----\npurely for self-learning\nTutorial by Nathan Vaughn","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["light","sphere","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst vec3 SPHERE_COL = vec3(1, 0.58, 0.29);\nconst vec3 BG_COL = vec3(0.3, 0.4, 0.3);\nconst float AMBIENT_COL = 0.3;\n\nfloat sdSphere(vec3 p, float r)\n{\n  vec3 offset = vec3(0, 0, -2); // make it farther away from canvas / camera\n  return length(p-offset) - r; // p is the test point and r is the radius of the sphere\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start; // start with a depth of zero and increment the depth gradually\n  float i = 0.001; \n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd; // test point = start + depth ray direction\n    float d = sdSphere(p, 1.);\n    depth += d;\n    // If the distance is within 0.001 units away from the sphere, \n    // then we consider this close enough to the sphere.\n    // end = threshold to end ray marching\n    if (d < PRECISION || depth > end) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    // to find slope on sphere:\n    // We'll take a point on the surface of the sphere \n    // and subtract a small number from it to get the second point\n    // use slope value as surface normal\n  //float e = 0.0005; // epsilon\n  //float r = 1.; // radius of sphere\n  //return normalize(vec3(\n  //  sdSphere(vec3(p.x + e, p.y, p.z), r) - sdSphere(vec3(p.x - e, p.y, p.z), r),\n  //  sdSphere(vec3(p.x, p.y + e, p.z), r) - sdSphere(vec3(p.x, p.y - e, p.z), r),\n  //  sdSphere(vec3(p.x, p.y, p.z  + e), r) - sdSphere(vec3(p.x, p.y, p.z - e), r)\n  //));\n  \n  vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n  float r = 1.; // radius of sphere\n  return normalize(\n    e.xyy * sdSphere(p + e.xyy, r) +\n    e.yyx * sdSphere(p + e.yyx, r) +\n    e.yxy * sdSphere(p + e.yxy, r) +\n    e.xxx * sdSphere(p + e.xxx, r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We use normalized vectors to represent directions as a convention\n    // we can multiply a normalized ray by some scalar value to make it longer, but it stays in the same direction.\n    // vec2 normalizedRayDirection = normalize(vec2(2, 2));\n    \n    // forward: rays out of light source, ton of those rays never hitting our camera\n    // backward: rays are shot out of a camera or \"eye\", two rays march: object then light/shadow\n    // each pixel = ray\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; // Condense 3 lines down to a single line!\n\n    vec3 col = vec3(0);\n    vec3 lightPosition = vec3(1, 1, 2) + vec3(iTime);\n    \n    vec3 ro = vec3(0, 0, 5);  // ray origin\n    vec3 rd = normalize(vec3(uv, -1)); // ray direction, for each pixel of screen\n    float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n\n    // add color depending on d\n    if (d > MAX_DIST) {\n      col = BG_COL; // ray didn't hit anything\n    } else {\n      vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n      vec3 normal = calcNormal(p);\n      // the light ray direction will be the difference between \n      // the light position and a point we get back from the ray march loop.\n      vec3 lightDirection = normalize(lightPosition - p);\n\n      // the amount of light hitting the surface of our sphere\n      float dif = clamp(dot(normal, lightDirection), AMBIENT_COL, 1.);\n      col = vec3(dif) * SPHERE_COL;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}