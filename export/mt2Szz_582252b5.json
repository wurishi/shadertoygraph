{"ver":"0.1","info":{"id":"mt2Szz","date":"1675620275","viewed":149,"name":"fake hole","username":"josemorval","description":"Test of parallax a hole","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fake","parallax"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//cube sdf (iquilez)\nfloat map(vec3 p){\n    vec3 q = abs(p) - vec3(0.8,0.03,0.8);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//compute normal\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.001,0.);\n    return normalize(\n        vec3(\n            map(p+e.xyy)-map(p),\n            map(p+e.yxy)-map(p),\n            map(p+e.yyx)-map(p)\n        )\n    );\n}\n\nfloat linearstep(float a,float b,float t){\n    return clamp((t-a)/(b-a),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fabrice's suggestion\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    vec3 col;\n    \n    float tt = 0.5*iTime;\n    \n    //camera stuff\n    vec3 ro = vec3(1.5*cos(0.3*tt),1.4+0.2*sin(3.15*tt),1.5*sin(0.5*tt));\n    vec3 up = normalize(vec3(0.,1.,0.));\n    vec3 dir = -normalize(ro);\n    vec3 right = normalize(cross(dir,up));\n    up = normalize(cross(right,dir));\n    \n    vec3 pos = ro + dir + uv.x*right + uv.y*up;\n    vec3 rd = normalize(pos-ro);\n    \n    //raymarch routine\n    float t = 0.;\n    float mat = -1.;\n    for(int i=0;i<32;i++)\n    {\n        float s = map(pos+t*rd);\n        if(s<0.001){ mat=1.;break;}\n        t+=s;\n    }\n    \n    //draw if raymarch success\n    if(mat>0.){\n        pos = pos+t*rd;\n        vec3 uvs = pos*vec3(1.5,1.,1.5);\n        \n        \n        vec2 offset = 0.1*vec2(cos(1.1*tt),sin(1.2*tt));\n        \n        //some kind of parallax to draw a hole\n        vec3 coltex = vec3(1.,0.,0.);\n        tt*=0.2;\n        for(int j=0;j<128;j++)\n        {\n                //(mathematical) heightmap\n                float height = -2.*(0.2+0.8*fract(tt))*linearstep(1.3,0.,length(uvs.xz-offset));\n                if(uvs.y-height>0.5)\n                {\n                    //go more deep \n                    uvs += rd*0.01*(uvs.y-height);\n                }else{\n                    \n                    //ok, enough. sample the texture\n                    float angle =  3.*smoothstep(1.3,-1.,length(uvs.xz-offset)+1.*uvs.y);   \n                    uvs.xz = mat2(cos(angle),sin(angle),-sin(angle),cos(angle))*uvs.xz;\n                    \n                    \n                    uvs.xz += 1.5*fract(tt)*normalize(uvs.xz);\n                    coltex = texture(iChannel0,uvs.xz).rrr; \n                    break;\n                }\n        }\n        \n        //fake deepness\n        coltex*=smoothstep(-0.5,0.2,uvs.y);\n        coltex*=smoothstep(1.,0.8,fract(tt))*smoothstep(0.,0.1,fract(tt));\n        \n        //mask sides\n        vec3 nor = normal(pos);\n        col = coltex*nor.y;\n    }\n    \n\n    //draw the color\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}