{"ver":"0.1","info":{"id":"4tVGR1","date":"1473354076","viewed":411,"name":"Euclid's orchard","username":"rory618","description":"2 dimensional analog of Euclid's orchard created by projecting a 3D grid of points onto a plane. Drag mouse and press w to zoom.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    fragColor = texture(iChannel1, uv);\n    \n    vec2 nup = mouse.xy - mouse.zw;\n    vec2 nright = vec2(nup.y, -nup.x) * iResolution.x / iResolution.y;\n    \n\t\n    \n    vec2 o = (fragCoord - mouse.zw);\n    \n    float z = max(0.0, min(1.0, 1.0-\n    min(\n    \tmin(\n        \tabs( dot(o, nup)/length( nup) - length( nup)) , \n            abs( dot(o,-nup)/length(-nup) - length(-nup)) \n        ), min(\n            abs( dot(o, nright)/length( nright) - length( nright)) ,\n         \tabs( dot(o,-nright)/length(-nright) - length(-nright)) \n        )\n    )));\n    \n    if(iMouse.z>.1 && mouse.z != 0.0)\n        fragColor += z;//*fragColor + (z);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nfloat smoothing = 100.0;\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n\nbool keyIsDown( float key ) {\n    return texture( iChannel2, vec2(key,0.25) ).x > .5;\n}\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\nfloat start(vec2 c) {\n    return 0.0;\n}\n\nfloat loop(float z, vec2 c, int i) {\n    vec3 d = (\n        vec3(c,0.0)*mat3(1,0,0,\n                         0,1,0,\n                         0,0,1)\n    ) * float(i);\n    float l = length(mod(d+vec3(.5),vec3(1.0)) - vec3(.5) );\n        \n    return z + (1.-smoothstep(0.,0.1,l))/sqrt(float(i+1));\n    \n}\n\nvec3 color(float z){\n    return vec3(\n    \t.5+.5*sin(sqrt(z)*4.14),\n    \t.5+.5*sin(sqrt(z)*4.25),\n    \t.5+.5*sin(sqrt(z)*4.36)\n    );\n}\n\n#define MAX_ITER 1000\n\nfloat iteratedFractal(vec2 c) {\n    float z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, c, i);\n    }\n    return z;\n}\n\nvec4 image(vec2 p) {\n    \n    float f = iteratedFractal(p);\n    return vec4(color(f),1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = (fragCoord.xy - vec2(.5) + hash23(vec3(fragCoord, iTime))) / iResolution.xy;\n    \n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    if ( keyIsDown(KEY_R) || keyIsDown(KEY_W) || iFrame <= 1) {\n        fragColor = image(p);\n    } else {\n    \tfragColor = (1.0-1.0/smoothing)*texture(iChannel1, fragCoord / iResolution.xy) + (1.0/smoothing)*image(p);\n    }\n    \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n        \n    if (iMouse.z < 0.1) {\n        mouse.zw = -iMouse.xy;\n    } else if(mouse.z < 0.0) {\n        mouse.zw = iMouse.xy;\n    }\n    \n    mouse.xy = iMouse.xy;\n    if (iMouse.z > 0.1 && mouse.z != 0.0) {\n    \tif ( keyIsDown(KEY_W) && mouse.xy != mouse.zw ) {\n        \tvec2 ncenter = uvtoc(center, up, right, (mouse.zw / iResolution.xy - vec2(.5))*2.0);\n            vec2 nup = uvtoc(center, up, right, (mouse.xy / iResolution.xy - vec2(.5))*2.0) - ncenter;\n            center = ncenter;\n            up = nup;\n            mouse.z = 0.0;\n    \t}\n    }\n    \n    viewport = vec4(center, up);\n    \n    if ( keyIsDown(KEY_R) || iFrame <= 1) {\n        viewport = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    fragColor = vec4(0);\n    \n    fragColor += save(viewport,viewportLoc,fragCoord);\n    fragColor += save(mouse,mouseLoc,fragCoord);\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}