{"ver":"0.1","info":{"id":"Xc2cWh","date":"1722256219","viewed":57,"name":"2D ellipses ","username":"jvb","description":"Just some 2D animated ellipses","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDF ellipse function by IQ\nfloat sdEllipse( vec2 p, vec2 ab ){\n// source: https://www.shadertoy.com/view/4lsXDN\n    // symmetry\n\tp = abs( p );\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0*fragCoord/iResolution.xy-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    for (int i = 0; i < 40; i++) {\n        vec2 o = p;\n        o.y += float(i)*0.00+0.4*sin(0.1*float(i)+iTime);\n        float r = float(i)*0.05;\n        float d = abs(length(vec2(1,1)*o.xy)-r);\n        if (sin(float(i)*0.1-iTime*2.0) > 0.0) \n            col += vec3(1)*(smoothstep(0.005,0.0,abs(sdEllipse(o,r*vec2(1.0,0.25))) ));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}