{"ver":"0.1","info":{"id":"ddsfRl","date":"1690878275","viewed":173,"name":"Dalux physics","username":"nicoeps","description":"Dalux rigid body simulation","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","simulation","physics","dalux"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define EPSILON 0.01\n#define DEPTH -10.0\n#define AA 0\n\n/* DALUX LOGO\nbox w=1225 h=735\n0.65684, 0.39410\n\nbig triangle w=1865 h=825\n1.0, 0.44234\n\nsmall triangle w=1350 h=595\n0.72386, 0.31903\n\ntotal w=1865 h=1560\n*/\n#define BOX_W 0.65684\n#define BOX_H 0.39410\n#define BTRI_W 1.0\n#define BTRI_H 0.44234\n#define STRI_W 0.72386\n#define STRI_H 0.31903\n#define BOX_COL (vec3(141,199,63) / 255.)\n#define TRI_COL (vec3(62,88,103) / 255.)\n\nstruct Surface\n{\n    float d;\n    vec3 col;\n};\n\nSurface mins(Surface s1, Surface s2)\n{\n    if (s2.d < s1.d) return s2;\n    return s1;\n}\n\nfloat extrussion(in vec3 p, in Surface sdf, in float h)\n{\n    vec2 w = vec2(sdf.d, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nSurface sdSphere(in vec3 p, in float r, in vec3 col)\n{\n    return Surface(length(p) - r, col);\n}\n\nSurface sdBox(in vec3 p, in vec3 b, in vec3 col)\n{\n    vec3 q = abs(p) - b;\n    return Surface(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), col);\n}\n\nSurface sdRoundBox(in vec3 p, in vec3 b, in float r, in vec3 col)\n{\n    vec3 q = abs(p) - b;\n    return Surface(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r, col);\n}\n\nSurface sdBox2D(in vec2 p, in vec2 b, in vec3 col)\n{\n    vec2 d = abs(p)-b;\n    return Surface(length(max(d,0.0)) + min(max(d.x,d.y),0.0), col);\n}\n\nSurface sdTriangleIsosceles(in vec2 p, in vec2 q, in vec3 col)\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp(dot(p,q)/dot(q,q), 0.0, 1.0);\n    vec2 b = p - q*vec2(clamp( p.x/q.x, 0.0, 1.0 ), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a,a), s*(p.x*q.y-p.y*q.x)), vec2(dot(b,b), s*(p.y-q.y)));\n    return Surface(-sqrt(d.x)*sign(d.y), col);\n}\n\nSurface sdDalux(in vec3 p)\n{\n    Surface box = sdBox2D(p.xy, vec2(BOX_W, BOX_H), BOX_COL);\n    Surface btrig = sdTriangleIsosceles(p.xy-vec2(0.0, BOX_H+2.0*BTRI_H), vec2(BTRI_W, -2.0*BTRI_H), TRI_COL);\n    Surface strig = sdTriangleIsosceles(p.xy-vec2(0.0, BOX_H+2.0*STRI_H-EPSILON), vec2(STRI_W, -2.0*STRI_H), vec3(0));\n    Surface tri = Surface(max(btrig.d, -strig.d), btrig.col);\n    Surface dalux = mins(box, tri);\n    return Surface(extrussion(p, dalux, BOX_W), dalux.col);\n}\n\nSurface sdScene(in vec3 p)\n{\n    Surface box = sdRoundBox(p-vec3(0,12,DEPTH-RADIUS), vec3((BOUND_R-BOUND_L)*0.5, 12.0, 1.5), 1.0, vec3(0.6,0.6,0.6));\n    if (box.d > EPSILON) return box;\n    Surface box2 = sdRoundBox(p-vec3(0,13,DEPTH+RADIUS), vec3((BOUND_R-BOUND_L)*0.5-1.0, 12.0, 1.5), 1.0, vec3(0));\n    //Surface s = Surface(max(box.d,-box2.d), box.col);\n    Surface s = Surface(opSmoothSubtraction(box2.d, box.d, 1.0), box.col);\n    \n    for (int i = 0; i < OBJECTS; ++i) {\n        vec2 pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        if (s.d < length(p-vec3(pos-vec2(0., 0.5), DEPTH)) - RADIUS-0.5) continue; // stonks\n        vec4 q = texelFetch(iChannel1, ivec2(i, 0), 0);\n        mat3 r = to_matrix(q);\n        s = mins(s, sdDalux((p-vec3(pos, DEPTH))*r));\n        //s = mins(s, sdSphere(p-vec3(pos, DEPTH), RADIUS, vec3(0,0,1)));\n    }\n    return s;\n}\n\nvec3 getNormal(in vec3 p)\n{\n    Surface s = sdScene(p);\n    vec2 e = vec2(EPSILON, 0);\n    vec3 n = s.d - vec3(sdScene(p-e.xyy).d, sdScene(p-e.yxy).d, sdScene(p-e.yyx).d);\n    return normalize(n);\n}\n\nSurface rayMarch(in vec3 ro, in vec3 rd)\n{\n    float dist = MIN_DIST;\n    Surface s;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + rd*dist;\n        s = sdScene(p);\n        dist += s.d;\n        if (dist > MAX_DIST || s.d < SURF_DIST) break;\n    }\n    return Surface(dist, s.col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 total = vec3(0);\n#if AA > 1\nfor(int i = 0; i < AA; i++) {\nfor(int j = 0; j < AA; j++) {\n    vec2 o = vec2(float(i),float(j)) / float(AA) - 0.5;\n    vec2 uv = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    //vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(-6, 0, 4);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n    \n    mat3 rx = to_matrix(axis_angle(vec3(1, 0, 0), 0.523598776));\n    mat3 ry = to_matrix(axis_angle(vec3(0, 1, 0), -0.523598776));\n\n    ro = ro*ry*rx;\n    rd = rd*ry*rx;\n\n    Surface s = rayMarch(ro, rd);\n    vec3 p = ro + rd*s.d;\n    \n    vec3 lightPos = vec3(-5.0, 20.0, 0.0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    \n    float ambient = 0.3;\n    float nl = dot(n, l);\n    float diffuse = clamp(nl, 0.0, 1.0);\n    float specular = 0.0;\n    if (nl > 0.0) specular = 0.6*pow(clamp(dot(reflect(l,n), -rd), 0.0, 1.0), 8.0);\n  \n    Surface shadow = rayMarch(p+n*SURF_DIST*2.0, l);\n    if (shadow.d < length(lightPos-p)) diffuse *= 0.2;\n    float intensity = (ambient+diffuse+specular);\n    vec3 col = intensity*s.col;\n    if (s.d > MAX_DIST) {\n        col = (1.0-rd.y)*vec3(0,0.6,0.9);\n    }\n    total += col;\n    \n#if AA > 1\n}}  total /= float(AA*AA);\n#endif\n    fragColor = vec4(total, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DT 0.001\n#define E 0.5\n#define GRAVITY vec2(0, -9.81)\n\nconst vec2 normalu = vec2(0, 1);\nconst vec2 normald = vec2(0, -1);\nconst vec2 normall = vec2(-1, 0);\nconst vec2 normalr = vec2(1, 0);\n\nvoid constraint(in float speed, in vec2 normal, inout vec2 vel)\n{\n    if (speed < 0.0) {\n        float j = -(1.0 + E) * speed;// / 2.0;\n        vec2 impulse = j * normal;\n        vel -= impulse;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 ifragCoord = ivec2(fragCoord - 0.5);\n    if (ifragCoord.y >= 1 || ifragCoord.x >= OBJECTS) discard;\n    \n    if (iFrame < 1+ifragCoord.x*10) {\n        fragColor = vec4(-100,-100, 0, 0);\n        return;\n    }\n    \n    vec4 posvel = texelFetch(iChannel0, ivec2(ifragCoord.x, 0), 0);\n    vec2 pos = posvel.xy;\n    vec2 vel = posvel.zw;\n    \n    vel += GRAVITY*iTimeDelta;\n    vel -= normalize(vel)*0.1*iTimeDelta;\n    \n    int steps = int(iTimeDelta / DT);\n    for (int t = 0; t < steps; ++t) {\n        vec2 posn = pos-RADIUS;\n        vec2 posp = pos+RADIUS;\n        if (posn.y <= GROUND) {\n            constraint(vel.y, normald, vel);\n        }\n        if (posn.x <= BOUND_L) {\n            constraint(vel.x, normall, vel);\n        }\n        if (posp.x >= BOUND_R) {\n            constraint(-vel.x, normalr, vel);\n        }\n        \n        for (int i = 0; i < OBJECTS; ++i) {\n            if (ifragCoord.x == i) continue;\n            vec4 posvel_b = texelFetch(iChannel0, ivec2(i, 0), 0);\n            vec2 pos_b = posvel_b.xy;\n            vec2 vel_b = posvel_b.zw;\n            vec2 ab = pos_b - pos;\n            float dist = length(ab);\n            if (dist >= RADIUS*2.0) {\n                continue;\n            }\n            vec2 normal = normalize(ab);\n            vec2 rel_vel = vel_b - vel;\n            float speed = dot(rel_vel, normal);\n            if (speed >= 0.0) continue;\n            float j = -(1.0 + E) * speed / 2.0;\n            vec2 impulse = j * normal;\n            vel -= impulse;\n        }\n        pos += vel*DT;\n    }\n\n    if (iFrame == 1+ifragCoord.x*10) {;\n        pos = vec2(0, 26);\n        float spd = ifragCoord.x % 2 == 0 ? -10.0 : 10.0;\n        vel = vec2(spd, 0.0);\n    }\n    \n    fragColor = vec4(pos,vel);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define RADIUS 1.0\n#define OBJECTS 32\n\n#define GROUND 0.0\n#define BOUND_L -5.0\n#define BOUND_R 5.0\n\nvec4 axis_angle(vec3 axis, float theta)\n{\n    return vec4(axis*sin(theta*0.5), cos(theta*0.5));\n}\n\n\nvec4 prod(vec4 qa, vec4 qb)\n{\n    vec3 v = qa.w*qb.xyz + qb.w*qa.xyz + cross(qa.xyz, qb.xyz);\n    float w = qa.w*qb.w - dot(qa.xyz, qb.xyz);\n    return vec4(v , w);\n}\n\nmat3 to_matrix(vec4 q)\n{\n    mat3 r = mat3(0);\n    float qyy = q.y*q.y;\n    float qxx = q.x*q.x;\n    float qzz = q.z*q.z;\n    float qxy = q.x*q.y;\n    float qxz = q.x*q.z;\n    float qyz = q.y*q.z;\n    float qxw = q.x*q.w;\n    float qyw = q.y*q.w;\n    float qzw = q.z*q.w;\n    r[0][0] = 1.0 - 2.0*(qyy + qzz);\n    r[1][1] = 1.0 - 2.0*(qxx + qzz);\n    r[2][2] = 1.0 - 2.0*(qxx + qyy);\n    r[1][0] = 2.0*(qxy + qzw);\n    r[0][1] = 2.0*(qxy - qzw);\n    r[2][0] = 2.0*(qxz - qyw);\n    r[0][2] = 2.0*(qxz + qyw);\n    r[2][1] = 2.0*(qyz + qxw);\n    r[1][2] = 2.0*(qyz - qxw);\n    return r;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 ifragCoord = ivec2(fragCoord - 0.5);\n    if (ifragCoord.y >= 1 || ifragCoord.x >= OBJECTS) discard;\n    \n    if (iFrame < 1+ifragCoord.x*10) {\n        fragColor = vec4(0., 0.,0., 1.);\n        return;\n    }\n    \n    vec2 vel = texelFetch(iChannel0, ivec2(ifragCoord.x, 0), 0).zw;\n    vec4 q = texelFetch(iChannel1, ivec2(ifragCoord.x, 0), 0);\n    mat3 r = to_matrix(q);\n    vec4 w = axis_angle(normalize(vec3(-vel.y, vel.x, 0))*r, -length(vel)/RADIUS*iTimeDelta);\n    q += prod(w, q);\n    fragColor = normalize(q);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}