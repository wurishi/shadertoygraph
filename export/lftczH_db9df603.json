{"ver":"0.1","info":{"id":"lftczH","date":"1730315979","viewed":30,"name":"PT-3: MIS vs BSDF vs DL [veach]","username":"kastanileel","description":"I implemented this shader to fully understand MIS from E. Veach: (only 1 bounce)\n- https://graphics.stanford.edu/papers/veach_thesis/thesis.pdf\n- https://www.researchgate.net/publication/354065092_Multiple_Importance_Sampling_101\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["path","direct","bsdf","pdf"],"hasliked":0,"parentid":"XftyRn","parentname":"PT-2: MIS"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Resources:\n// MIS Thesis:\n// - https://graphics.stanford.edu/papers/veach_thesis/thesis.pdf\n// NVIDIA MIS 101:\n// - https://www.researchgate.net/publication/354065092_Multiple_Importance_Sampling_101\n// Other:\n// - https://learnopengl.com/PBR/Lighting\n// - https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html\n// - https://pbr-book.org/4ed\n// - https://www.shadertoy.com/view/4tl3z4\n// - https://iquilezles.org/articles/intersectors/\n\n// BUFFER A: Raytracing stuff (inspired by Vulkan/Optix rt pipelines)\n// COMMON: Helper functions & structs\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159f\n#define EPSILON 0.001\n\n\n#define NUM_SPHERES 3\n#define NUM_PLANES 7\n#define NUM_LIGHT_SPHERES 3\n//-----------------------------------------------------\n// Random functions\n//-----------------------------------------------------\n\n// we only use 2 sampling strategies\nfloat balanceHeuristic(float pdf, float pdf_other) {\n    return pdf / (pdf + pdf_other);\n}\n\nfloat hash1(inout float seed) {\n    seed = seed + 0.1f;\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    seed = seed + 0.1f;\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    seed = seed + 0.1f;\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\nvec2 antiAliasingOffset(inout float seed, vec2 resolution){\n    return hash2(seed);\n}\n\nvec3 randomCosineDirectionHemisphere(inout float seed){\n    vec2 rr = hash2(seed);\n    \n    float phi = 2.0*PI*rr.x;\n    float x = cos(phi)*sqrt(rr.y);\n    float y = sin(phi)*sqrt(rr.y);\n    float z = sqrt(1.0-rr.y);\n    \n    return vec3(x, y, z);\n}\n\nvec3 randomUniformDirectionSphere(inout float seed){\n    vec2 rr = hash2(seed);\n  \n    float x = cos(2.0f*PI*rr.x) * 2.0f * sqrt(rr.y*(1.0-rr.y));\n    float y = sin(2.0f*PI*rr.x) * 2.0f * sqrt(rr.y*(1.0-rr.y));\n    float z = 1.0 - 2.0*rr.y;\n\n    return normalize(vec3(x, y, z));\n}\n//-----------------------------------------------------\n// Structs\n//-----------------------------------------------------\nstruct ONB {\n    vec3 u, v, w;\n};\n\nONB buildONB(vec3 normal){\n    ONB onb;\n    onb.w = normal;\n    \n    // make sure a is nonparallel to onb.w\n    vec3 a = vec3(1.0f, 0.0f, 0.0f);\n    if(abs(onb.w.x) > 0.9f){\n        a = vec3(0.0f, 1.0f, 0.0f);\n    }\n    \n    onb.v = normalize(cross(onb.w, a));\n    onb.u = cross(onb.w, onb.v);\n    \n    return onb;\n}\n\nvec3 onbTransform(ONB onb, vec3 vector) {\n    return onb.u * vector.x + onb.v * vector.y + onb.w * vector.z;\n}\n\n// 0:emissive\n// 1: lambertian\n// 2: specular\nstruct Material {\n    vec3 emission;\n    vec3 albedo;\n    int type;\n};\n\nvec3 evaluateLambertianBRDF(Material material, vec3 theta_out, vec3 normal, vec3 theta_in){\n    return material.albedo/PI;\n}\n\nvec3 sampleCosineWeighted(vec3 theta_out, vec3 normal, inout float pdf, inout float seed) {\n    ONB onb = buildONB(normal);\n    vec3 scatterDirection = onbTransform(onb, randomCosineDirectionHemisphere(seed));\n    \n    pdf = max(EPSILON, dot(normalize(scatterDirection), normal))/PI;\n    \n    return normalize(scatterDirection);\n}\n\nvec3 evaluateSpecularBRFD(Material material, vec3 theta_out, vec3 normal, vec3 theta_in){\n     if(dot(normalize(reflect(theta_out, normal)), theta_in) < 1.0f-EPSILON)\n        return vec3(0.0f);\n    return material.albedo;\n}\n\nvec3 sampleSpecular(vec3 theta_out, vec3 normal, inout float pdf, inout float seed) {\n    pdf = 1.0f;\n    \n    return normalize(reflect(theta_out, normal));\n}\n\nbool isEmitter(Material material) {\n    return material.type == 0;\n}\n\nstruct Payload {\n    vec3 throughput;\n    vec3 accumulatedColor;\n    float pdf_bsdf;\n    int bounces;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    Payload payload;\n};\n\n// intersection geometry\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in Ray ray, in vec4 sph ) {\n    vec3 oc = ray.origin - sph.xyz;\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in Ray ray, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ray.origin)) / dot( pla.xyz, ray.direction );\n}\n\nstruct Camera {\n    vec3 origin;\n    vec3 forward;\n    vec3 up;\n    vec3 right;\n};\n\nstruct HitRecord {\n    vec3 point;\n    vec3 normal;\n    int primitiveID;\n    bool didHit;\n};\n\nvec3 sampleLight(Material material, HitRecord hit, vec4 lightSpheres[NUM_SPHERES], inout int sampledLightID, inout bool didSample, inout float pdf, inout float seed) {\n    // select 1 random light sphere\n    vec4 lightSphere;\n    sampledLightID = int(floor(hash1(seed)*float(NUM_LIGHT_SPHERES)));\n    lightSphere = lightSpheres[sampledLightID];\n    pdf = 1.0f/float(NUM_LIGHT_SPHERES);\n    // Generate a random point on the light sphere\n    vec3 randomUniformDirection = normalize(randomUniformDirectionSphere(seed));\n    vec3 ranPointOnSphere = randomUniformDirection * lightSphere.w + lightSphere.xyz;\n    vec3 sphereDirection = ranPointOnSphere - hit.point;\n\n    // Check if the sampled point is on the visible side of the surface\n    if (dot(sphereDirection, hit.normal) < 0.0f) {\n        didSample = false;\n        return vec3(0.0f);  // Early exit if the light is not visible from the hit point\n    }\n\n    // https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#cleaninguppdfmanagement/samplingasphereobject\n    float distance_to_center = length(lightSphere.xyz - hit.point);\n    float cos_theta = sqrt(1.0f - (lightSphere.w * lightSphere.w) / (distance_to_center * distance_to_center));\n    float solid_angle = max(EPSILON, 2.0 * PI * (1.0f - cos_theta));\n    pdf *= 1.0 / solid_angle;\n    \n   \n    return normalize(sphereDirection);\n}\n\nfloat getCosineWeightedSamplingPDF(vec3 normal, vec3 sampledDirection){\n    return max(EPSILON, dot(normalize(sampledDirection), normal))/PI;\n}\n\nfloat getSpecularSamplingPDF(vec3 theta_out, vec3 normal, vec3 sampledDirection){\n   if(dot(normalize(reflect(theta_out, normal)), sampledDirection) < 1.0f-EPSILON)\n        return 0.0f;\n    return EPSILON*2.0f;\n}\n\nfloat getLightSamplingPDF(vec3 rayOrigin, vec4 lightSphere, vec3 sampledDirection){\n    float distance_to_center = length(lightSphere.xyz - rayOrigin);\n    float cos_theta = sqrt(1.0f - (lightSphere.w * lightSphere.w) / (distance_to_center * distance_to_center));\n    float solid_angle = max(EPSILON, 2.0 * PI * (1.0f - cos_theta));\n    float pdf = 1.0 / solid_angle;\n    pdf *= 1.0f/float(NUM_LIGHT_SPHERES);\n    \n    return pdf;\n}\n\n//https://learnopengl.com/PBR/Theory\nfloat distributionGGX (vec3 N, vec3 H, float roughness){\n    float a2    = roughness * roughness * roughness * roughness;\n    float NdotH = max (dot (N, H), 0.0);\n    float denom = (NdotH * NdotH * (a2 - 1.0) + 1.0);\n    return a2 / (PI * denom * denom);\n}\n\nvec3 evaluateCookTorranceBRDF(Material material, vec3 theta_out, vec3 normal, vec3 theta_in) {\n    vec3 N = normal;\n    vec3 V = -theta_out;\n    vec3 L = theta_in;\n    vec3 H = normalize(V + L);\n\n    vec3 albedo = material.albedo;\n    float roughness = 0.05f;\n    // Cook-Torrance BRDF\n   \n    float NDF = distributionGGX(N, H, roughness);\n    float G   = 1.0f;//geometrySmith(N, V, L, roughness);\n    float F   = 1.0f;//fresnelSchlick(max(dot(H, V), 0.0), F0);        \n   \n    float  numerator   = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), EPSILON) * max(dot(N, L), EPSILON);\n    float  specular    = numerator / max(denominator, 0.001);  \n    \n    return specular*material.albedo;\n}\n\nvec3 sampleGlossy(vec3 theta_out, vec3 normal, inout float pdf, inout float seed) {\n    // Generate two random numbers for sampling\n    theta_out = -theta_out;\n    vec2 rr = hash2(seed);\n    float roughness = 0.05f;\n    // GGX sampling in spherical coordinates\n    float a = roughness * roughness;\n    float theta = atan(sqrt(a * rr.x) / sqrt(1.0 - rr.x));\n    float phi = 2.0 * PI * rr.y;\n\n    // Convert spherical coordinates to Cartesian\n    vec3 H;\n    H.x = sin(theta) * cos(phi);\n    H.y = sin(theta) * sin(phi);\n    H.z = cos(theta);\n\n    // Transform H to world space if normal is not aligned with Z-axis\n    vec3 up = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent = normalize(cross(up, normal));\n    vec3 bitangent = cross(normal, tangent);\n    H = normalize(tangent * H.x + bitangent * H.y + normal * H.z);\n\n    // Reflect the view vector around the half-vector to get the light direction\n    vec3 L = reflect(-theta_out, H);\n\n    // Calculate the PDF for this sample\n    float NdotH = max(dot(normal, H), 0.0);\n    float VdotH = max(dot(theta_out, H), 0.0);\n    float D = distributionGGX(normal, H, roughness);\n    pdf = D * NdotH / (4.0 * VdotH + 0.001); // 4 * V · H converts the PDF to L-space\n\n    return normalize(L);\n}\n\nfloat glossySamplingPDF(vec3 theta_out, vec3 normal, vec3 theta_in){\n    theta_out = -theta_out;\n    vec3 H = normalize(theta_out + theta_in);\n    float roughness = 0.05f;\n    float NdotH = max(dot(normal, H), 0.0);\n    float VdotH = max(dot(theta_out, H), 0.0);\n    float D = distributionGGX(normal, H, roughness);\n    float pdf = D * NdotH / (4.0 * VdotH + 0.001);\n    \n    return pdf;\n\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 spheres[NUM_SPHERES];\nvec4 planes[NUM_PLANES];\nMaterial materials[NUM_SPHERES+NUM_PLANES];\nCamera camera;\n\n\nvoid initializeMISScene() {\n    // Camera\n    camera.origin = vec3(0.0f, 2.0f, 0.5f);\n    camera.forward = normalize(vec3(0.0f, 0.0f, -1.0f));\n    camera.up = normalize(vec3(0.0f, 1.0f, 0.0f));\n    camera.right = normalize(vec3(1.0f, 0.0f, 0.0f));\n    \n    // Cornell Box\n    spheres[0] = vec4(1.5f, 3.3f, -1.9f, 0.2f);\n    spheres[1] = vec4(0.0f, 3.3f, -1.9f, 0.4f);\n    spheres[2] = vec4(-1.8f, 3.3f, -1.9f, 0.6f);\n\n    planes[0] = vec4( 0.0, 0.0,1.0,4.0);    \n    planes[1] = vec4( 0.0, 1.0,0.0,0.0);    \n    planes[2] = vec4( 1.0, 0.0,0.0,3.0);\n    planes[3] = vec4( -1.0, 0.0,0.0,3.0);\n    planes[4] = vec4( 0.0, -1.0, 0.0,4.0);\n    planes[5] = vec4( vec3(0.0, 1.0,0.5),-0.4);\n    planes[6] = vec4( vec3(0.0, 0.5,1.0),1.7);\n    \n    materials[0] = Material(vec3(16.86, 10.76, 8.2), vec3(0.0f), 0);    \n    materials[1] = Material(vec3(16.86, 10.76, 8.2)*0.8f, vec3(0.0f), 0);\n    materials[2] = Material(vec3(16.86, 10.76, 8.2)*0.5f, vec3(0.0f), 0);\n\n    materials[3] = Material(vec3(0.0f), vec3(.7295, .7355, .729), 1);   \n    materials[4] = Material(vec3(0.0f), vec3(.7295, .7355, .729), 1);\n    materials[5] = Material(vec3(0.0f), vec3(.117, .4125, .115), 1);\n    materials[6] = Material(vec3(0.0f), vec3(.611, .0555, .062), 1);\n    materials[7] = Material(vec3(0.0f), vec3(.1, .1, .1),1);\n    materials[8] = Material(vec3(0.0f), vec3(.9), 1);\n    materials[9] = Material(vec3(0.0f), vec3(.9), 2);\n}\n\nRay raygen(vec2 uv, inout float seed) {\n    Ray ray;\n   // uv += antiAliasingOffset(seed, iResolution.xy);\n    \n    ray.origin = camera.origin;\n    ray.direction = normalize(((camera.origin+camera.forward) + camera.right * uv.x + camera.up *uv.y)-camera.origin);\n    \n    Payload payload;\n    payload.throughput = vec3(1.0f);\n    payload.accumulatedColor =vec3(0.0f);\n    payload.bounces = 0;\n    payload.pdf_bsdf = 1.0f;\n    ray.payload = payload;\n    \n    return ray;\n}\n\nHitRecord intersectScene(Ray ray) {\n    HitRecord hit;\n    \n    int primitiveID = -1;\n    float t = 1e20;\n    vec3 normal;\n    \n    for(int i = 0; i < NUM_SPHERES; i++){\n        float it = iSphere( ray, spheres[i] );\n        if( it > EPSILON && it < t ) {\n            t = it;\n            normal = nSphere(ray.origin + ray.direction * t, spheres[i] ); \n            primitiveID = i;\n        }\n    }\n\t\n    for(int i = NUM_SPHERES; i < NUM_SPHERES+NUM_PLANES; i++){\n        float it = iPlane(ray, planes[i-NUM_SPHERES]);\n        if( it > EPSILON && it < t ) {\n            t = it;\n            normal = nPlane(ray.origin + ray.direction * t, planes[i-NUM_SPHERES] ); \n            primitiveID = i;\n        }\n    }\n    \n    hit.point = ray.origin + ray.direction * t;\n    hit.normal = normalize(normal);\n    hit.primitiveID = primitiveID;\n    hit.didHit = primitiveID != -1;\n\t\t\t\t\t  \n    return hit;\t\t\t\t\t  \n}\n\nvoid closestHitBSDF(inout Ray ray, in HitRecord hit, inout float seed){\n    Material material = materials[hit.primitiveID];\n    \n     // hit light emitter\n    if (isEmitter(material)) {\n        ray.payload.accumulatedColor += material.emission * ray.payload.throughput;\n        // terminate ray\n        ray.payload.bounces = 2;\n        return;\n    }\n  \n    vec3 brdf, sampledDirection;\n    float pdf_bsdf;\n    if(materials[hit.primitiveID].type == 1){\n        sampledDirection = sampleCosineWeighted(ray.direction, hit.normal, pdf_bsdf, seed);\n        brdf = evaluateLambertianBRDF(material, ray.direction, hit.normal, sampledDirection);\n    }\n    else {\n        sampledDirection = sampleGlossy(ray.direction, hit.normal, pdf_bsdf, seed);\n        brdf = evaluateCookTorranceBRDF(material, ray.direction, hit.normal, sampledDirection);\n        pdf_bsdf = max(EPSILON, pdf_bsdf);\n    }\n    \n    float cos_theta = max(0.0f, dot(sampledDirection, hit.normal));\n   \n    ray.payload.throughput *= (brdf * cos_theta)/pdf_bsdf;\n    // continue ray\n    ray.origin = hit.point + hit.normal * EPSILON; \n    ray.direction = sampledDirection;\n}\n\nvoid closestHitDL(inout Ray ray, in HitRecord hit, inout float seed){\n    Material material = materials[hit.primitiveID];\n    \n     // hit light emitter\n    if (isEmitter(material)) {\n        ray.payload.accumulatedColor += material.emission * ray.payload.throughput;\n        // terminate ray\n        ray.payload.bounces = 2;\n        return;\n    }\n  \n    float Visibility = 1.0f;\n    float pdf_light, pdf_bsdf;\n    int sampledLightID;\n    bool didSample = true;\n    vec3 sampledDirection = sampleLight(material, hit, spheres, sampledLightID, didSample, pdf_light, seed);\n    if(didSample){\n        vec3 brdf;\n        if(materials[hit.primitiveID].type == 1)\n            brdf = evaluateLambertianBRDF(material, ray.direction, hit.normal, sampledDirection);   \n        else \n            brdf = evaluateCookTorranceBRDF(material, ray.direction, hit.normal, sampledDirection);\n            \n        float cos_theta = max(0.0f, dot(sampledDirection, hit.normal));\n        // visibility test\n        {\n            Ray shadowRay;\n            shadowRay.origin = hit.point;\n            shadowRay.direction = sampledDirection;\n            HitRecord hitShadow = intersectScene(shadowRay);\n            if (!hit.didHit || hitShadow.primitiveID != sampledLightID) \n                Visibility = 0.0f;\n        }\n\n        pdf_light = max(EPSILON, pdf_light);\n        ray.payload.accumulatedColor += Visibility*ray.payload.throughput * brdf * cos_theta *materials[sampledLightID].emission/pdf_light;\n    }\n    // terminate ray\n    ray.payload.bounces = 2;\n}\n\n\nvoid closestHitMIS(inout Ray ray, in HitRecord hit, inout float seed) {\n    \n    Material material = materials[hit.primitiveID];\n    \n    // hit light emitter\n    if (isEmitter(material)) {\n        // now that we hit a light we must account for that with a misWeight\n        // because so far we assumed the pdf_light=0.0f;\n        float pdf_light = getLightSamplingPDF(ray.origin, spheres[hit.primitiveID], ray.direction);\n        \n        // if the ray from the camera directly hits the light, we didn't importance sample the light source\n        // => the misWeight should be just 1\n        if(ray.payload.bounces == 0)\n            pdf_light = 0.0f;\n        float misWeight = balanceHeuristic(ray.payload.pdf_bsdf, pdf_light);\n        \n        ray.payload.accumulatedColor += material.emission * ray.payload.throughput *misWeight;\n        // terminate ray\n        ray.payload.bounces  = 2;\n        return;\n    }\n    \n    //    ^\n    //    |\n    // check the light intersection from BSDF sampling of bounce=0 before terminating\n    if(ray.payload.bounces > 0){\n        return;\n    }    \n    \n    ray.payload.pdf_bsdf = 1.0f;\n    \n    // light sampling\n    float Visibility = 1.0f;\n    float pdf_light, pdf_bsdf;\n    int sampledLightID;\n    bool didSample = true;\n    vec3 sampledDirection = sampleLight(material, hit, spheres, sampledLightID, didSample, pdf_light, seed);\n    if(didSample){\n        \n        vec3 brdf;\n        if(materials[hit.primitiveID].type == 1){\n            brdf = evaluateLambertianBRDF(material, ray.direction, hit.normal, sampledDirection);\n            pdf_bsdf = getCosineWeightedSamplingPDF(hit.normal, -sampledDirection);\n           \n        }\n        else {\n            brdf = evaluateCookTorranceBRDF(material, ray.direction, hit.normal, sampledDirection);\n            pdf_bsdf = glossySamplingPDF(ray.direction, hit.normal, sampledDirection);\n            \n        }\n        \n        float cos_theta = max(0.0f, dot(sampledDirection, hit.normal));\n        // visibility test\n        {\n            Ray shadowRay;\n            shadowRay.origin = hit.point;\n            shadowRay.direction = sampledDirection;\n            HitRecord hitShadow = intersectScene(shadowRay);\n            if (!hit.didHit || hitShadow.primitiveID != sampledLightID) {\n                Visibility = 0.0f;\n            }\n        }\n\n        pdf_light = max(EPSILON, pdf_light);\n        float misWeight = balanceHeuristic(pdf_light, pdf_bsdf);\n\n        ray.payload.accumulatedColor += Visibility*ray.payload.throughput * brdf * cos_theta * misWeight*materials[sampledLightID].emission/pdf_light;\n    }\n    // bsdf sampling\n    // so far we don't know if we hit a light with that scatter\n    // so we assume we don't\n    // => pdf_light = 0.0f\n    // => misWeight = 1.0f;\n    // however we save the pdf_bsdf to the rays payload\n \n    vec3 brdf;\n    \n    if(materials[hit.primitiveID].type == 1){\n        sampledDirection = sampleCosineWeighted(ray.direction, hit.normal, pdf_bsdf, seed);\n        brdf = evaluateLambertianBRDF(material, ray.direction, hit.normal, sampledDirection);\n    }\n    else {\n        sampledDirection = sampleGlossy(ray.direction, hit.normal, pdf_bsdf, seed);\n        brdf = evaluateCookTorranceBRDF(material, ray.direction, hit.normal, sampledDirection);\n        pdf_bsdf = max(EPSILON, pdf_bsdf);\n    }\n    \n    float cos_theta = max(0.0f, dot(sampledDirection, hit.normal));\n    ray.payload.throughput *= (brdf * cos_theta)/pdf_bsdf;\n    ray.payload.pdf_bsdf = pdf_bsdf;\n    // continue ray\n    ray.origin = hit.point + hit.normal * EPSILON; \n    ray.direction = sampledDirection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ////////////////////////////////////////////////////\n    // split screen\n    // this is probably not the most efficient way\n    vec2 uv = (fragCoord*2.0f)/iResolution.xy;// - 1.0f;\n    if(uv.y > 1.0f){\n        uv =  fract(uv)-vec2(0.5f);\n        uv*=2.0f;\n        uv.x *= iResolution.x/iResolution.y;\n    }\n    else {\n        uv.x *= iResolution.x/iResolution.y;\n        uv -= iResolution.xy/iResolution.yx;\n        uv*=2.0f;\n        \n        if(abs(uv.x)>2.0f)\n            return;\n    }\n    ////////////////////////////////////////////////////\n          \n    float seed = uv.x + uv.y * 3.43121412313 + fract(1.12345314312*iTime);\n    \n    // assign sampling type to the different split screen\n    int samplingType = 0;\n    if(fragCoord.y/iResolution.y < 0.5f)\n        samplingType += 2;\n    if(fragCoord.x/iResolution.x > 0.5f)\n        samplingType += 1;\n            \n\n    initializeMISScene(); \n    Ray ray = raygen(uv, seed);\n\n    while(ray.payload.bounces <= 1 ){\n\n       HitRecord hit = intersectScene(ray);\n       if (!hit.didHit)\n           break;\n       switch(samplingType){\n           case 0:\n           closestHitBSDF(ray, hit, seed);\n           break;\n           case 1:\n           closestHitDL(ray, hit, seed);\n           break;\n           default:\n           closestHitMIS(ray, hit, seed);\n           break;\n       }\n       \n       ray.payload.bounces += 1;\n    }\n    \n    vec3 previousColor = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float ratio = 1.0f/(float(iFrame+1));\n    vec3 accumulatedColor = ratio * ray.payload.accumulatedColor + (1.0f-ratio)*previousColor;\n  \n    fragColor.xyz = accumulatedColor;\n}","name":"Buffer A","description":"","type":"buffer"}]}