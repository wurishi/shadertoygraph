{"ver":"0.1","info":{"id":"WsdXD7","date":"1572176907","viewed":289,"name":"Hyperbolic sierpinski triangles","username":"matthen","description":"creating a sierspinski-triangle-like fractal through iterated functions on a hyperbolic disk.\npoints are moved to be half way along the line to one of the three corners, at random","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fractal","sierpinski","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = 1. - texture(iChannel0, uv);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1013);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n    return vec2(\n        fract(sin(217.2 * p.x + 1076.3 * p.y) * p.x * 65.2 + 87.2 * p.y),    \n        fract(sin(3112.2 * p.x - 22.3 * p.y) * p.y * 89.1 + 11.4 * p.x)\n    );\n}\n\nvec2 mul(vec2 a, vec2 b) {\n\t// complex multiplication\n    return vec2(\n    \ta.x * b.x - a.y * b.y,\n        a.x * b.y + a.y * b.x\n\t);\n}\n\nvec2 conj(vec2 a) {\n\treturn vec2(a.x, -a.y);   \n}\n\nfloat safediv(float x, float y) {\n    if (abs(x) < kEps) {\n        return 0.;\n    }\n    if (abs(y) < kEps) {\n        y = sign(y) * kEps;\n    }\n    return x / y;\n}\n\nfloat dist(vec2 a, vec2 b) {\n    vec2 one = vec2(1., 0.);\n    float x = length(one - mul(conj(a), b));\n    float y = length(a - b);\n    return log(safediv(x + y, x - y));\n}\n\nvec2 centre(vec2 a, vec2 b) {\n    // centre in disk model of circle that connects a and b\n    float denom =  2. * (a.x * b.y - a.y * b.x);\n    return vec2(\n        safediv((1. + length(a)) * b.y - a.y * (1. + length(b)),\n        \t\tdenom),\n    \tsafediv(b.x * (1. + length(a)) - a.x * (1. + length(b)),\n        \t\t-1. * denom)\n    );\n\n}\n\n\nvec2 midPoint(vec2 a, vec2 b) {\n    vec2 c = centre(a, b);\n    vec2 ac = a - c;\n    vec2 bc = b - c;\n    float r = length(bc);\n    float thetaA = atan(ac.x, ac.y);\n    float thetaB = atan(bc.x, bc.y);\n    float t = .5;\n\tfloat tStep = .5;\n    \n    // binary search to find best theta\n    // i could solve some algebra. or...\n    float theta = .5 * (thetaA + thetaB);\n    return c + r * vec2(sin(theta), cos(theta));\n    vec2 mid;\n    for (float i = 0.; i < 8.; i++) {\n        float theta = mix(thetaA, thetaB, t);\n        mid = c + r * vec2(sin(theta), cos(theta));\n   \t\ttStep *= .5;\n        float dA = dist(mid, a);\n        float dB = dist(mid, b);\n        if (abs(dA - dB) < 0.00001) {\n            break;\n        }\n        else if (dist(mid, a) < dist(mid, b)) {\n        \tt += tStep;\t   \n        } else {\n        \tt -= tStep;   \n        }\n    }\n    \n    return mid;\n}\n\nvec2 getPoint(int i) {\n    ivec2 pi = ivec2(i % 100, i / 100);\n\treturn texelFetch(iChannel0, pi, 0).xy;   \n}\n\nfloat getAge(int i) {\n    ivec2 pi = ivec2(i % 100, i / 100);\n\treturn texelFetch(iChannel0, pi, 0).z;   \n}\n\n\nconst vec2 p1 = vec2(0.866025, -0.5);\nconst vec2 p2 = vec2(0., 1.);\nconst vec2 p3 = vec2(-0.866025, -0.5);\n\nvec2 nextPoint(vec2 p) {\n    float choice = hash12(p + fract(iTime));\n    float r = radius(iTime);\n    if (choice < 0.333) {\n        return midPoint(p, r * p1);\n    } else if (choice < 0.666) {\n        return midPoint(p, r * p2);\n    }\n    return midPoint(p, r * p3);\n}\n\nvec2 randomPoint(int i) {\n    float choice = hash12(vec2(float(i), fract(iTime)));\n    float r = radius(iTime);\n    if (choice < 0.333) {\n        return midPoint(r * p1, r * p2);\n    } else if (choice < 0.666) {\n        return midPoint(r * p1, r * p3);\n    }\n    return midPoint(r * p2, r * p3);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    if (fragCoord.x > float(kNumPoints) || fragCoord.y > .5) {\n        // Only process the points.\n        fragColor = vec4(0.);\n        return;   \n    }\n    \n    int i = int(fragCoord.x);\n    vec2 p = getPoint(i);\n    float age = getAge(i);\n    if ((iFrame + i) % kLifeTime == 0 || iFrame == 0 || length(p) > 1.) {\n        // Every 60 seconds, resample points.\n        p = randomPoint(i);\n        age = 0.;\n    } else {\n     \tp =  nextPoint(p);   \n        age += 1.;\n    }\n    \n    fragColor = vec4(p, age, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"# define kEps 0.0001\n# define kNumPoints 1200\n# define kLifeTime 300\n# define kRadiusLifeTime 10.0\n\nfloat radius(in float time) {\n    float t = floor(time / kRadiusLifeTime);\n\treturn 0.95 - fract(0.11 * t);\n}\n\nfloat radiusAge(in float time) {\n    return 60. * mod(time, kRadiusLifeTime);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nvec2 getPoint(int i) {\n    ivec2 pi = ivec2(i % 100, i / 100);\n\treturn texelFetch(iChannel0, pi, 0).xy;   \n}\n\nfloat getAge(int i) {\n    ivec2 pi = ivec2(i % 100, i / 100);\n\treturn texelFetch(iChannel0, pi, 0).z;   \n}\n\n// from https://www.shadertoy.com/view/ll2GD3\nvec3 gradient(in float t) {\t\n    vec3 a = vec3(.5, .5, .5);\n    vec3 b = vec3(.5, .5, .5);\n    vec3 c = vec3(1., 1., .5);\n    vec3 d = vec3(.8, .9, .3);\n    return a + b * cos(6.28318 * ( c * t + d));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.x;\n    \n    uv *= 4.;\n    \n    float thickness = 4. / iResolution.x;\n    if (length(uv) > 1. - thickness) {\n        fragColor = vec4(smoothstep(thickness, 0., abs(length(uv) - 1. - thickness)));\n    \treturn;   \n    }\n   \n    \n    vec3 col;\n    \n    \n    for (int i = 0; i < kNumPoints; i++) {\n        vec2 p = getPoint(i);\n        float age = getAge(i);\n        age = min(radiusAge(iTime), age);\n        float mask = smoothstep(15., 20., age);\n        mask *= 0.7;\n    \tcol += mask * gradient(1. - radius(iTime)) * smoothstep(2. / iResolution.x, 0., length(uv - p));\n    }\n    \n    vec3 bg = texture(iChannel1, fragCoord / iResolution.xy).rgb;\n    if (length(bg) > length(col)) {\n    \tcol = bg;   \n    } else {\n     \tcol = mix(col, bg, 0.1);   \n    }\n\n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}