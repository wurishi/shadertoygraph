{"ver":"0.1","info":{"id":"WsyyRG","date":"1603063155","viewed":237,"name":"FBM Gas Planet","username":"edorobek","description":"A gas Planet!","likes":12,"published":1,"flags":32,"usePreview":1,"tags":["sdf","fbm","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n#define MAX_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.00001\n\n#define PI 3.141592654\n\n\nfloat sphereSDF(vec3 p,  float r) \n{\n    return length(p) - r;\n}\n\n\n// Combinations\nfloat unionOp(float d1, float d2) { return min(d1,d2); }\nvec2 unionOp(vec2 d1, vec2 d2) { return (d1.x<d2.x) ? d1 : d2; }\n\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1e10, -2.0);\n\t{\n\t\tresult = unionOp(result, vec2(sphereSDF(p, 3.), 1.));\n\t}\n\t\n\treturn result;\n}\n\nconst float sunIntensity = .7;\nconst vec3 sunColor = sunIntensity*vec3(1.30,1.00,0.60);\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0) * p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// https://www.shadertoy.com/view/Md2SR3\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec3 background(vec3 q)\n{\n\treturn vec3(StableStarField(q.xy * iResolution.xy * 2., 0.99));\n    \n}\n\n// ============================================================== //\n\n// intersect ray with the scene\nvec2 raycast(vec3 ro, vec3 rd)\n{\n\tvec2 result = vec2(-1.0);\n\tfloat t = MIN_DIST;\n\tfor (int i =0; i < MAX_STEPS && t < MAX_DIST; i++) {\n\t\tvec2 h = map(ro + t*rd);\n\t\tif (abs(h.x) < (EPSILON*t)) {\n\t\t\tresult = vec2(t, h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\t\n\treturn result;\n}\n\n// get direction of ray with just device coordinates\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n// calculate the normal via finite differences\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nconst float R_INNER = 2.85;\nconst float R = R_INNER + .55;\n\nconst int NUM_OUT_SCATTER = 12;\nconst int NUM_IN_SCATTER = 35;\n\nfloat density( vec3 p, float ph ) {\n\treturn exp( -max( length( p ) - R_INNER, 0.0 ) / ph );\n}\n\nfloat optic( vec3 p, vec3 q, float ph ) {\n\tvec3 s = ( q - p ) / float( NUM_OUT_SCATTER );\n\tvec3 v = p + s * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v, ph );\n\t\tv += s;\n\t}\n\tsum *= length( s );\n\t\n\treturn sum;\n}\n\n\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phase_ray( float cc ) {\n\treturn ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );\n}\n\nvec3 in_scatter( vec3 o, vec3 dir, float t, vec3 l ) {\n\tconst float ph_ray = 0.05;\n    const float ph_mie = 0.02;\n    \n    const vec3 k_ray = vec3( 33.8, 17.5, 14.1 );\n    const vec3 k_mie = vec3( 21.0 );\n    const float k_mie_ex = 1.1;\n    \n\tvec3 sum_ray = vec3( 0.0 );\n    vec3 sum_mie = vec3( 0.0 );\n    \n    float n_ray0 = 0.0;\n    float n_mie0 = 0.0;\n    \n\tfloat len = 5. / float( NUM_IN_SCATTER );\n    vec3 s = dir * len;\n\tvec3 v = o + dir * ( t + len * 0.5 );\n    \n    for ( int i = 0; i < NUM_IN_SCATTER; i++, v += s ) {   \n\t\tfloat d_ray = density( v, ph_ray ) * len;\n        float d_mie = density( v, ph_mie ) * len;\n        \n        n_ray0 += d_ray;\n        n_mie0 += d_mie;\n        \n\t\tvec3 u = v + l * t;\n        \n        float n_ray1 = optic( v, u, ph_ray );\n        float n_mie1 = optic( v, u, ph_mie );\n\t\t\n        vec3 att = exp( - ( n_ray0 + n_ray1 ) * k_ray - ( n_mie0 + n_mie1 ) * k_mie * k_mie_ex );\n        \n\t\tsum_ray += d_ray * att;\n        sum_mie += d_mie * att;\n\t}\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n    vec3 scatter =\n        sum_ray * k_ray * phase_ray( cc ) +\n     \tsum_mie * k_mie * phase_mie( -0.78, c, cc );\n    \n\t\n\treturn 7.0 * scatter;\n}\n\nvec3 light = normalize( vec3(-0.5, 0.4, 0.6) );\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 rdx, vec3 rdy)\n{\n\t// background\n\tvec3 col = background(rd);\n\t\n\tvec2 tmat = raycast(ro, rd);\n\tfloat t = tmat.x;\n\tfloat m = tmat.y;\n    \n\n\tif (m > -1.) {\n\t\n\t\t\n\t\tcol = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n\t\n\t\tvec3 pos = ro + tmat.x*rd;\n\t\tvec3  hal = normalize(light - rd );\n\t\tvec3 norm = (m < 1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\t\tvec3 ref = reflect( rd, norm );\n\t\tvec3 lin = vec3(0.0);\n        \n\t\tif( m<1.5 )\n        {\n            float u = atan(pos.z, pos.x) / (2.*PI) + 0.5;\n\t\t\tfloat v = -asin(pos.y / PI);\n            vec2 UV = vec2(u,-v);\n            \n            col = texture( iChannel0, UV).xyz;\n            lin += in_scatter(ro, rd, t, light);\n            ks = 0.1;\n        }\n        \n        \n\t\t\n\t\tfloat occ = 1.0; \n\t\t\n\t\t\n\t\t// sun\n\t\t{\n            vec3  hal = normalize( light-rd );\n            float dif = clamp( dot( norm, light ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, light, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.16*pow(clamp(1.0-dot(hal,light),0.0,1.0),2.0);\n            lin += col*2.20*dif*sunColor;\n            lin +=     5.00*spe*sunColor*ks;\n        }\n        \n\n        col = lin;\n\n\t\t// falloff (fakes a depth blur)\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.00002*t*t*t ) );\n\t}\n\t\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 6.0, 18.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n  \t// ray derivatives\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = (viewToWorld * normalize( vec4(px,2.5, 1.0) )).xyz;\n    vec3 rdy = (viewToWorld * normalize( vec4(py,2.5, 1.0) )).xyz;\n    \n    vec3 col = render(eye, worldDir, rdx, rdy);\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// noise and FBM\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.85,  0.60, -0.60,  0.80 );\n\nfloat fbm3( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.8000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.5500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1625*(-1.0+2.0*noise( p ));\n    \n    return f/1.8375;\n}\n\nfloat fbm7( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.005000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.562500*noise( p ); p = mtx*p*2.04;\n    f += 0.231250*noise( p ); p = mtx*p*2.01;\n    f += 0.312500*noise( p ); p = mtx*p*2.02;\n    f += 0.15625*noise( p );\n\n    return f/5.41875;\n}\n\nvec2 fbm3_2( vec2 p )\n{\n    return vec2( fbm3(p+vec2(1.5)), fbm3(p+vec2(3.2)) );\n}\n\nvec2 fbm7_2( vec2 p )\n{\n    return vec2( fbm7(p+vec2(3.2)), fbm7(p+vec2(9.7)) );\n}\n\n\n// Domain Warping\nfloat warp(vec2 q, out vec2 o, out vec2 n)\n{\n    // animate q here\n    q += 0.1*sin(vec2(0.11,0.13)*.13*iTime + length( q )*4.0);\n    q *= 0.8;\n    \n    o = 0.5 + 0.5*fbm3_2( q );\n    \n    o += 0.04*sin(vec2(0.11,0.11)*.08*iTime*length( o ));\n\to *= 1.1;\n    \n    n = fbm7_2(.95*o);\n    \n    vec2 p = q + 2.0*n + 1.0;\n    \n    float f = 0.5 + 0.5*fbm3(2.0*p);\n    \n    f = mix(f, f*f*f*3.5, f*abs(n.x));\n    \n    f *= 1.0-0.5*pow( 0.5+0.5*sin(8.0*p.x)*sin(8.0*p.y), 8.0 );\n\n    return f;\n}\n\nfloat warps( in vec2 q )\n{\n    vec2 t1, t2;\n    return warp(q,t1,t2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 tot = vec3(0);\n    for( int mi=0; mi<4; mi++ )\n    for( int ni=0; ni<4; ni++ )\n    {\n    vec2 q = (fragCoord-iResolution.xy)/iResolution.y;\n    q *= vec2(1.6, 2.4);\n    q += vec2(0.004*iTime, 0.0);\n \n    vec2 o, n;\n    \n    float f = warp(q, o, n);\n    \n    vec3 col = vec3(0.2,0.7,0.3);\n        col = mix( col, vec3(0.2,0.25,0.35), f );\n        col = mix( col, vec3(0.9,0.9,0.9), dot(n,n) );\n        col = mix( col, vec3(0.5,0.4,0.1), 0.5*o.y*o.y );\n        col = mix( col, vec3(0.6,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) );\n        col *= f*2.0;\n    \n    vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n    vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n    \n    vec3 nor = normalize( vec3( warps(q+ex) - f, ex.x, warps(q+ey) - f ) );\n    \n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n    vec3 bdrf;\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.35,0.10,0.55)*dif;\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n\n    col *= 2.1*bdrf;\n    col = vec3(1.0)-col;\n    col = col*col;\n    col *= vec3(1.1,1.25,1.2);\n        \n    tot += col;\n    }\n    \n    tot /= 16.0;\n    \n    vec2 p = fragCoord / iResolution.xy;\n\ttot *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n    \n\tfragColor = vec4(tot, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}