{"ver":"0.1","info":{"id":"MdcGWH","date":"1449261305","viewed":167,"name":"Over Relax / SS intersection 1","username":"cabbibo","description":"Reading this paper:  http://lgdv.cs.fau.de/get/2234 and seeing how much of a speed up I can get on a regular scene!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","overrelaxedspheretracing","screenspaceintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Trying to understand the code from\n// http://lgdv.cs.fau.de/get/2234\n\nconst float t_min = .001;\nconst float t_max = 1000.;\nconst int MAX_ITERATIONS = 50;\nconst float infinite = 100000.;\n\nconst bool forceHit = false;\n\nfloat pixelRadius;\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n \tvec2 res = vec2( sdSphere( pos - vec3( .3 , .3 , -0.4 ) , 1.1 ) , 1. ); \n    res = opU( res , vec2( sdBox( pos- vec3( -.8 , -.4 , 0.2 ), vec3( .4 , .3 , .2 )) , 2. ));\n    \n    return res;\n    \n}\n\n\n\n\n//From\n//http://lgdv.cs.fau.de/get/2234\nvec2 calcIntersection( vec3 ro , vec3 rd ){\n    \n    // o, d : ray origin, direction (normalized)\n    // t_min, t_max: minimum, maximum\n    // pixelRadius: radius of a pixel\n    // forceHit: boolean enforcing to\n    // candidate_t value as result \n    \n\tfloat omega = 1.2;\n    float t = t_min;\n    float candidate_error = infinite;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float id = -10.;\n\n    // are we inside or outside the object?\n    // if inside reverse the field!\n    float functionSign = map(ro).x < 0. ? -1. : 1.; \n\n    for (int i = 0; i < MAX_ITERATIONS; i++ ) {\n        \n        vec2 mapVal = map(rd*t + ro); \n        \n        id = mapVal.y;\n        \n        float signedRadius = functionSign * mapVal.x; \n\n        float radius = abs(signedRadius);\n\n        bool sorFail = omega > 1. && (radius + previousRadius) < stepLength;\n\n        if (sorFail) { \n\n            stepLength -= omega * stepLength;\n            omega = 1.;\n\n        } else {\n\n            stepLength = signedRadius * omega;\n\n        } \n\n        previousRadius = radius; \n        float error = radius / t;\n\n\n        if (!sorFail && error < candidate_error) { \n            candidate_t = t;\n            candidate_error = error;\n        }\n\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n\n        t += stepLength; \n\n    }\n\n    if ((t > t_max || candidate_error > pixelRadius) && !forceHit){\n        return vec2( infinite , -1. );\n    }\n\n    return vec2( candidate_t , id );\n\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n    \n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    \n\treturn normalize(nor);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    \n    float pixel = .5 / iResolution.y;\n    \n  \tvec3 rdu = normalize( camMat * vec3(p.xy + vec2(pixel, 0.) ,2.0) );\n    vec3 rdd = normalize( camMat * vec3(p.xy - vec2(pixel, 0.),2.0) );\n\n    vec3 pu = ro + rdu;\n    vec3 pd = ro + rdd;\n    \n    // Can probably alter this for a speed up too\n    pixelRadius = ( pu.x - pd.x ) / 2.;\n    \n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = vec3( 1. );\n    \n    if( res.y > -.5 ){ \n        vec3 pos = ro + rd * res.x;\n        vec3 n = calcNormal( pos );\n        color = n * .5 + .5; \n        \n        if( res.y == 1. ){ color = vec3( 0. , 1. , 1. ); }\n    }\n    \n\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}","name":"","description":"","type":"image"}]}