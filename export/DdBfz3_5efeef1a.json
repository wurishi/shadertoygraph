{"ver":"0.1","info":{"id":"DdBfz3","date":"1689925979","viewed":188,"name":"stars new","username":"nayk","description":" fractal, space, stars","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","space","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*original  https://www.shadertoy.com/view/XlfGRj */\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.3\n\n#define zoom   2.300\n#define tile   0.250\n#define speed  0.010 \n\n#define brightness 0.0115\n#define darkmatter 0.500\n#define distfading 0.530\n#define saturation 0.750\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord/min(iResolution.x,iResolution.y))\n              -vec2(fract(max(iResolution.x,iResolution.y)/min(iResolution.x,iResolution.y))/2.0,0.0);\n\t\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n \n              \n    \n\t\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n    from*=(uv,cos(iTime));\n\tfrom+=vec3(time*0.,time,time*10.);\n    \n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n     vec2 center = vec2(0.5, 0.5);\n    vec2 delta = uv - center;\n    float strength = mix(0., 5., (sin(iTime) + 1.) / 2.);\n    float angle = strength * length(delta);\n    \n    \n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\n    \n    // if movement is wanted\n    vec2 offset = vec2(0., 0.) * iTime;\n    uv = vec2(x + center.x + offset.x, y + center.y + offset.y);\n\t\tvec3 p=sin(fract(from-s*dir)*1.10);\n        \n      p+=(uv,cos(iTime*0.5));\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p*3.1)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)+pa); // absolute sum of average change\n\t\t\tpa=0.2*fract(abs(length(p/2.)));\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>10) fade*=1.-dm; // dark matter, don't render near\n\t\tv+=vec3(fract(smoothstep(dm,dm*.1,0.)));\n\t\tv+=fade;\n         v+=(uv,cos(iTime));\n\t\tv+=vec3(s,1.*fract(s*s),s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*0.01,1.);\t\n\t\n}  ","name":"Image","description":"","type":"image"}]}