{"ver":"0.1","info":{"id":"mdy3WW","date":"1678506104","viewed":86,"name":"rainbow cube","username":"benjidial","description":"cube","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"DsG3DD","parentname":"weird cube thing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//world stuff\n\nvec4 cubeCenter = vec4(0.0, 0.0, 0.0, 1.0);\nfloat cubeRadius = 1.0;\n\nvec4 sphereCenter = vec4(0.0, 0.0, 0.0, 1.0);\nfloat sphereRadius = 1.2;\n\nvec4 lightPos = vec4(3.0, 10.0, 5.0, 1.0);\n\nvec3 shapeDiffusionColor;\n\n//constants\n\nconst float camVertFovDegrees = 40.0;\nconst float maxRenderDist = 10.0;\nconst float prec = 0.00001;\n\n//camera stuff\n\nvec4 camPos;\nvec4 camTarget;\n\nvec4 camForward;\nvec4 camForwardFlat;\nfloat camTheta;\nvec4 camUp;\nvec4 camRight;\nvec4 cpCenter;\n\nconst float camVertFov = camVertFovDegrees * 3.14159 / 180.0;\nconst float cpHeight = 2.0 * tan(camVertFov / 2.0);\n\nvoid updateCamera(vec4 pos, vec4 target) {\n  camPos = pos;\n  camTarget = target;\n  camForward = normalize(camTarget - camPos);\n  camForwardFlat = normalize(camForward.xwzw);\n  camTheta = asin(camForward.y);\n  camUp = -sin(camTheta) * camForwardFlat + vec4(0.0, cos(camTheta), 0.0, 0.0);\n  camRight = vec4(cross(camForward.xyz, camUp.xyz), 0.0);\n  cpCenter = camPos + camForward;\n}\n\n//functions\n\nvec2 clampToSquare(vec2 point, vec2 squareCenter, float squareRadius) {\n  return clamp(point, squareCenter - squareRadius, squareCenter + squareRadius);\n}\n\nvec4 nearestCubePoint(vec4 pos) {\n  vec2 xyClamp = clampToSquare(pos.xy, cubeCenter.xy, cubeRadius);\n  vec2 xzClamp = clampToSquare(pos.xz, cubeCenter.xz, cubeRadius);\n  vec2 yzClamp = clampToSquare(pos.yz, cubeCenter.yz, cubeRadius);\n  \n  vec4 candidates[6] = vec4[](\n    vec4(xyClamp, cubeCenter.z - cubeRadius, 1.0),\n    vec4(xyClamp, cubeCenter.z + cubeRadius, 1.0),\n    vec4(xzClamp.x, cubeCenter.y - cubeRadius, xzClamp.y, 1.0),\n    vec4(xzClamp.x, cubeCenter.y + cubeRadius, xzClamp.y, 1.0),\n    vec4(cubeCenter.x - cubeRadius, yzClamp, 1.0),\n    vec4(cubeCenter.x + cubeRadius, yzClamp, 1.0)\n  );\n\n  vec4 choice;\n  float dist = maxRenderDist;//hmm\n\n  for (int i = 0; i < 6; ++i)\n    if (distance(candidates[i], pos) < dist) {\n      dist = distance(candidates[i], pos);\n      choice = candidates[i];\n    }\n\n  return choice;\n}\n\nvec4 nearestSpherePoint(vec4 pos) {\n  return sphereCenter + sphereRadius * normalize(pos - sphereCenter);\n}\n\nvec4 nearestPoint(vec4 pos) {\n  vec4 cp = nearestCubePoint(pos);\n  //vec4 sp = nearestSpherePoint(pos);\n  //return distance(pos, cp) < distance(pos, sp) ? cp : sp;\n  return cp;\n}\n\nvec3 hueToColor(float hue) {\n  float huef = fract(hue);\n  switch (int(hue) % 6) {\n\n  case 0:\n    return vec3(1.0, huef, 0.0);\n  case 1:\n    return vec3(1.0 - huef, 1.0, 0.0);\n  case 2:\n    return vec3(0.0, 1.0, huef);\n  case 3:\n    return vec3(0.0, 1.0 - huef, 1.0);\n  case 4:\n    return vec3(huef, 0.0, 1.0);\n  case 5:\n    return vec3(1.0, 0.0, 1.0 - huef);\n\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  cubeCenter = 0.5 * vec4(sin(iTime * sqrt(2.0)), sin(iTime * sqrt(3.0)), sin(iTime * sqrt(5.0)), 1.0);\n  shapeDiffusionColor = hueToColor(iTime);\n  updateCamera(vec4(3.0, 3.0, 3.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0));\n\n  vec2 cpOffset = (fragCoord - 0.5 * iResolution.xy) * cpHeight / iResolution.y;\n  vec4 cpHit = cpCenter + cpOffset.x * camRight + cpOffset.y * camUp;\n\n  vec4 rayDir = normalize(cpHit - camPos);\n  vec4 rayPos = camPos;\n\n  while (distance(rayPos, camPos) < maxRenderDist) {\n    vec4 shapePoint = nearestPoint(rayPos);\n    float dist = distance(rayPos, shapePoint);\n    if (dist < prec) {\n      vec4 shapeNormal = normalize(rayPos - shapePoint);\n      vec4 lightDir = normalize(lightPos - shapePoint);\n      vec3 diffusion = shapeDiffusionColor * dot(shapeNormal, lightDir);\n      fragColor = vec4(diffusion, 1.0);\n      return;\n    }\n    rayPos += rayDir * dist;\n  }\n  \n  fragColor = texture(iChannel0, fragCoord / iResolution.xy) * 0.99;\n}","name":"Buffer A","description":"","type":"buffer"}]}