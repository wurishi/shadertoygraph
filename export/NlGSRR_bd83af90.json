{"ver":"0.1","info":{"id":"NlGSRR","date":"1641734168","viewed":124,"name":"2D sdf interactivity exp.","username":"farhan3d","description":"WIP for testing interactivity in SDFs.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","sdf","distance"],"hasliked":0,"parentid":"fd3SRf","parentname":"Hexagon -  distance 2D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n\n#define OBJ_TYPES_COUNT 20\n#define CIRC_RAD 0.1\n#define CIRC_OFF_X 0.1\n#define CIRC_OFF_Y 0.1\n#define SQ_SIZE 0.08\n#define SQ_OFF_X 0.0\n#define SQ_OFF_Y 0.0\n#define ROT_SPEED_MULT 0.5\n#define MAX_OBJ_COUNT 10\n#define BLOOM_FACTOR 1.0\n#define BLEND_RADIUS 0.015\n#define LINE_THK 0.0025\n#define DRAW_WIREFRAME true\n#define ROT_HEX true\n#define DRAW_FIELDS false\n#define FUNKY_BLOOM false\n#define SHOW_BOUNDINGBOX true\n#define TOGGLE_PERSISTANT_SELECTION false\n\nvec2 obj_centers[MAX_OBJ_COUNT];\n\n// storing the +X, -X, +Y, -Y max points of all objects\n// to compute their respective bounding boxes.\nvec4 obj_limits[MAX_OBJ_COUNT];\n\nvec2 obj_type_map[MAX_OBJ_COUNT];\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0 );\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nvec2 rotate(vec2 uv, float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvec2 rotationByCenter(in float angle,in vec2 position,in vec2 center)\n{\n    //Function seen from https://www.shadertoy.com/view/XlsGWf\n    float rot = radians(angle);\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2((position-center)*rotation);\n}\n\nfloat sdHexagon(vec2 p, float s, float r, vec2 offset) {\n    vec2 rotated = p;\n    if (ROT_HEX) {\n        rotated = rotate(vec2(p.x, p.y), iTime * ROT_SPEED_MULT);\n    }\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p = vec2(rotated.x - offset.x, rotated.y - offset.y);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z * s, k.z * s), s);\n    return length(p) * sign(p.y) - r;\n}\n\nfloat sdSquare(vec2 uv, float radius, vec2 offset) {\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    return max(abs(x), abs(y)) - radius;\n}\n\nfloat sdSphere(vec2 uv, vec2 offset, float radius) {\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    return length(vec2(x, y)) - radius;\n}\n\n// create tight-fit bounding boxes around objects\nvec3 drawBoundingBoxes(vec3 in_vec, \n                       float[MAX_OBJ_COUNT] d,\n                       vec2 obj_cen[MAX_OBJ_COUNT]) {\n    vec3 ret_vec = in_vec;\n    for (int i = 0; i < MAX_OBJ_COUNT; i++) {\n        \n    }\n    return ret_vec;\n}\n\nvec3 drawOutlineForObjects(vec3 in_vec, float[MAX_OBJ_COUNT] d) {\n    vec3 ret_vec = in_vec;\n    for (int i = 0; i < MAX_OBJ_COUNT; i++) {\n        if (d[i] == 0.0) {\n            break;\n        } else {\n            vec3 line_color = vec3(0.1, 0.2, 0.2);\n            ret_vec = mix(ret_vec, line_color, 1.0 -\n                smoothstep(0.0, 0.00175, abs(d[i])));\n        }\n    }\n    return ret_vec;\n}\n\nfloat drawLShape(vec2 uv, vec2 base_loc) {\n    float res = sdSphere(uv, vec2(base_loc.x, base_loc.y), CIRC_RAD * 0.75);\n    //res = smin(in_val, temp, BLEND_RADIUS);\n    float temp = sdSquare(uv, CIRC_RAD * 0.75, vec2(base_loc.x, base_loc.y - 0.075));\n    res = smin(res, temp, 0.0);\n    temp = sdSphere(uv, vec2(base_loc.x, base_loc.y), CIRC_RAD * 0.4);\n    res = opSmoothSubtraction(temp, res, 0.001);\n    temp = sdSquare(uv, CIRC_RAD * 0.75, vec2(base_loc.x, base_loc.y - 0.22));\n    res = smin(res, temp, 0.0);\n    temp = sdSquare(uv, CIRC_RAD * 0.75, vec2(base_loc.x + 0.14, base_loc.y - 0.22));\n    res = smin(res, temp, 0.0);\n    temp = sdSphere(uv, vec2(base_loc.x + 0.22, base_loc.y - 0.22), CIRC_RAD * 0.75);\n    res = smin(res, temp, 0.0);\n    temp = sdSphere(uv, vec2(base_loc.x + 0.22, base_loc.y - 0.22), CIRC_RAD * 0.4);\n    res = opSmoothSubtraction(temp, res, 0.001);\n    vec2 rotated = rotationByCenter(45.0, uv, base_loc);\n    temp = sdSquare(rotated, CIRC_RAD * 0.75, vec2(0.155, -0.28));\n    res = opSmoothSubtraction(temp, res, 0.001);\n    return res;\n}\n\nvec3 drawHoverHighlight(vec2 uv, vec2 obj_cen[MAX_OBJ_COUNT],\n                        float[MAX_OBJ_COUNT] d,\n                        int[OBJ_TYPES_COUNT] object_class) {\n    vec3 ret_vec;\n    \n    vec4 m = vec4 (iMouse.x / iResolution.y - 1.0, \n        iMouse.y / iResolution.y - 0.75,\n        iMouse.z, iMouse.w);\n    // excuse the weird hack below, need to fix\n    vec2 mouse_loc_adj = vec2(m.x + 0.1125, m.y + 0.25);\n\n    // while mouse button is pressed, highlight object which is clicked\n    if (m.z > 0.0) {\n        for (int i = 0; i < MAX_OBJ_COUNT; i++)\n        {\n            if (object_class[i] == 0) {\n                float test_val = sdSphere(mouse_loc_adj, obj_cen[i], CIRC_RAD);\n                if (test_val < 0.0) {\n                    vec3 hover_fill_col = vec3(0.2, 0.25, 0.25);\n                    if (d[i] < 0.0)\n                    {\n                        ret_vec = hover_fill_col;\n                    }\n                }\n            } else if (object_class[i] == 2) {\n                float hex1 = sdHexagon(mouse_loc_adj, SQ_SIZE * 1.15, SQ_SIZE * 0.35,\n                    obj_centers[i]);\n                float hex2 = sdHexagon(mouse_loc_adj, SQ_SIZE * 0.65, SQ_SIZE * 0.45,\n                    obj_centers[i]);\n                float test_val = opSmoothSubtraction(hex2, hex1, 0.001);\n                if (test_val < 0.0) {\n                    vec3 hover_fill_col = vec3(0.2, 0.25, 0.25);\n                    if (d[i] < 0.0)\n                    {\n                        ret_vec = hover_fill_col;\n                    }\n                }\n            } else if (object_class[i] == 3) {\n                float test_val = sdSquare(mouse_loc_adj, SQ_SIZE * 1.25, \n                    vec2(obj_centers[i].x, obj_centers[i].y));\n                if (test_val < 0.0) {\n                    vec3 hover_fill_col = vec3(0.2, 0.25, 0.25);\n                    if (d[i] < 0.0)\n                    {\n                        ret_vec = hover_fill_col;\n                    }\n                }\n            } else if (object_class[i] == 4) {\n                float test_val = drawLShape(mouse_loc_adj, \n                    obj_centers[i]);\n                if (test_val < 0.0) {\n                    vec3 hover_fill_col = vec3(0.2, 0.25, 0.25);\n                    if (d[i] < 0.0)\n                    {\n                        ret_vec = hover_fill_col;\n                    }\n                }\n            }\n        }\n    }\n    return ret_vec;\n}\n\nvec3 drawScene(vec2 uv) {\n    vec3 ret_vec;\n    float res;\n    ret_vec = vec3(0.15, 0.5, 0.8);\n    float d[MAX_OBJ_COUNT];\n    int obj_class[OBJ_TYPES_COUNT];\n\n    // creating objects\n    d[0] = sdSphere(uv, vec2(CIRC_OFF_X, CIRC_OFF_Y), CIRC_RAD);\n    obj_centers[0] = vec2(CIRC_OFF_X, CIRC_OFF_Y);\n    obj_class[0] = 0;\n    d[1] = sdHexagon(uv, SQ_SIZE * 1.15, SQ_SIZE * 0.35, vec2(SQ_OFF_X, SQ_OFF_Y));\n    obj_centers[1] = vec2(SQ_OFF_X, SQ_OFF_Y);\n    obj_class[1] = 1;\n    d[2] = sdHexagon(uv, SQ_SIZE * 0.65, SQ_SIZE * 0.45, vec2(SQ_OFF_X, SQ_OFF_Y));\n    obj_centers[2] = vec2(SQ_OFF_X, SQ_OFF_Y);\n    obj_class[2] = 1;\n    d[3] = opSmoothSubtraction(d[2], d[1], 0.001);\n    obj_centers[3] = vec2(SQ_OFF_X, SQ_OFF_Y);\n    obj_class[3] = 2;\n    d[4] = sdSquare(uv, SQ_SIZE * 1.25, vec2(SQ_OFF_X - 0.15, SQ_OFF_Y - 0.125));\n    obj_centers[4] = vec2(SQ_OFF_X - 0.15, SQ_OFF_Y - 0.125);\n    obj_class[4] = 3;\n    float full_un = smin(d[4], d[3], BLEND_RADIUS);\n    full_un = smin(full_un, d[0], BLEND_RADIUS);\n    d[5] = sdSquare(uv, SQ_SIZE * 1.25, vec2(SQ_OFF_X - 0.275, SQ_OFF_Y));\n    obj_centers[5] = vec2(SQ_OFF_X - 0.275, SQ_OFF_Y);\n    obj_class[5] = 3;\n    full_un = opSmoothSubtraction(d[5], full_un, 0.001);\n    \n    // create test L bracket thingy\n    obj_centers[6] = vec2(0.3, 0.0);\n    d[6] = drawLShape(uv, obj_centers[6]);\n    full_un = smin(full_un, d[6], BLEND_RADIUS);\n    obj_class[6] = 4;\n    \n    ret_vec += drawHoverHighlight(uv, obj_centers, d, obj_class);\n\n    // create the global objects field around them\n    res = full_un;\n    if (DRAW_FIELDS) {\n        ret_vec *= 1.5 - exp(-15.0 * abs(res));\n        ret_vec *= 0.75 + 0.1 * cos(300.0 * res);\n    }\n\n    // create the consumed part of drawn objects\n    if ((DRAW_WIREFRAME) && (true))\n    {\n        ret_vec = drawOutlineForObjects(ret_vec, d);\n    }\n\n    // draw object boundaries\n    ret_vec = mix(ret_vec, vec3(0.65), 1.0 - smoothstep(0.0, LINE_THK, abs(res)));\n\n    // color inside the combined objects\n    vec3 obj_fill_col = vec3(ret_vec.x + 0.1, ret_vec.y + 0.25, ret_vec.z + 0.25);\n    if (FUNKY_BLOOM) {\n        res = smoothstep(0.0, 0.0025 * BLOOM_FACTOR * sin(iTime), res * 0.005);\n    } else {\n        res = smoothstep(0.0, 0.005 * BLOOM_FACTOR , res);\n    }\n    ret_vec = mix(obj_fill_col, ret_vec, res);\n    \n    return ret_vec;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec3 color = drawScene(uv);\n\n    fragColor = vec4(color, 1.0);\n}\n\n/*\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    uv -= 0.5;\n    float aspect = u_resolution.x / u_resolution.y;\n    uv.x *= aspect;\n    vec3 color = drawScene(uv);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n*/\n","name":"Image","description":"","type":"image"}]}