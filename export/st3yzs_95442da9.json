{"ver":"0.1","info":{"id":"st3yzs","date":"1660329975","viewed":87,"name":"Gauss-Legendre Quadrature","username":"Envy24","description":"Green - f(x)\nBlue - exact definite integral of f(x)\nRed - numerical definite integral of f(x) calculated with Gauss-Legendre Quadrature.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["numerical","integral","gauss","integration","legendre","quadrature","definite"],"hasliked":0,"parentid":"sl3yRf","parentname":"Romberg-Richardson Integration"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Redefine this macroses for your function.\n#define integ(x)         ( -cos(x) + 1. )  // analytic definite integral form a to b of func(x) (by default a = 0 = const).\n#define func(x)          ( sin(x) )\n#define deriv(x)         ( cos(x) )\n\n/*\n    Caculator for roots and weights:\n    https://keisan.casio.com/exec/system/1329114617\n*/\nfloat GaussLegendreQuadratureDegree2(float a, float b)\n{\n    const float xs[2] = float[2]( 1./ sqrt(3.), -1./sqrt(3.) );\n    const float ws[2] = float[2]( 1. , 1. );  \n    \n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n          \n    float I = 0.;\n    for (int i = 0; i < 2; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n          \n    return I * mean;\n}\n\nfloat GaussLegendreQuadratureDegree3(float a, float b)\n{\n    const float xs[3] = float[3]( sqrt(3./5.),    0., -sqrt(3./5.) );\n    const float ws[3] = float[3](       5./9., 8./9.,       5./9. );\n\n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0; i < 3; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n\n    return I * mean;\n}\n\nfloat GaussLegendreQuadratureDegree4(float a, float b)\n{\n    const float xs[4] = float[4]( -0.861136311594052575224, -0.3399810435848562648027, 0.3399810435848562648027, 0.861136311594052575224  );\n    const float ws[4] = float[4]( 0.3478548451374538573731, 0.6521451548625461426269, 0.6521451548625461426269, 0.3478548451374538573731 );\n\n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0; i < 4; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n\n    return I * mean;\n}\n\nfloat GaussLegendreQuadratureDegree5(float a, float b)\n{\n    const float xs[5] = float[5](\n        -0.9061798459386639927976, -0.5384693101056830910363, 0., 0.5384693101056830910363, 0.9061798459386639927976  );\n    const float ws[5] = float[5](\n       0.2369268850561890875143, 0.4786286704993664680413, 0.5688888888888888888889, 0.4786286704993664680413, 0.2369268850561890875143 );\n\n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0; i < 5; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n\n    return I * mean;\n}\n\n/*\n    Generalization.\n*/\n\nfloat LegendrePolynomial(float degree, float x)\n{\n    float Legendre_p = 1., Legendre_c = x, Legendre_n = 0.;\n\n    for (float i = 2.; i <= degree; i += 1.)\n    {\n        float n = i - 1.;\n        Legendre_n = ((2.*n+1.)*x*Legendre_c - n*Legendre_p) / (n + 1.);       \n        \n        Legendre_p = Legendre_c; Legendre_c = Legendre_n;\n    }\n    \n    return \n        degree == 0. ?\n            1. :\n            degree == 1. ?\n                x :\n                Legendre_n;\n}\n\nfloat LegendrePolynomialFirstDerivative(float degree, float x)\n{\n    float Pc = LegendrePolynomial(degree, x);\n    float Pp = LegendrePolynomial(degree-1., x);\n    \n    return (degree / (x*x - 1.)) * (x*Pc - Pp);\n}\n\n/*\n    Modified version from this shader: https://www.shadertoy.com/view/fl3cRl\n*/\nvoid calculateRootsAndWeights(\n    inout float xs[16],\n    inout float ws[16],\n    in float degree)\n{\n    degree = max(1., degree);\n    degree = degree >= 16. ? 15. : degree;\n    \n    const float tolerance = 1e-7;\n    float dAngle = (PI)/(degree + 1.);\n    \n    for (float i = 0.; i < degree; i+= 1.)\n    {\n        int idx = int(i);      \n        xs[idx] = i == 0. ? -1.1 : cos(dAngle * i);\n        \n        float f = LegendrePolynomial(degree, xs[idx]),\n              t = LegendrePolynomial(degree-1., xs[idx]),\n              dfdx = (degree / (xs[idx]*xs[idx] - 1.)) * (xs[idx]*f - t);\n        \n        for (int s = 0; (s < 16) && (abs(f) > tolerance); ++s)\n        {\n            xs[idx] -= f / dfdx;\n            \n            f = LegendrePolynomial(degree, xs[idx]);\n            t = LegendrePolynomial(degree-1., xs[idx]);\n            dfdx = (degree / (xs[idx]*xs[idx] - 1.)) * (xs[idx]*f - t);\n        }\n        \n        ws[idx] = 2. / ((1. - xs[idx]*xs[idx])*(dfdx*dfdx));\n        //ws[idx] = (2.*(1. - xs[idx]*xs[idx])) / ((degree * t)*(degree * t));\n    }\n}\n\nfloat GaussLegendreQuadrature(\n    float xs[16],\n    float ws[16],\n    float a,\n    float b,\n    float degree)\n{  \n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0, e = int(degree); i < e; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += func(x)*ws[i];\n    }\n\n    return I * mean;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 3.0\n#define YSCALE 1.0\n#define OFFSET vec2(1.5, 0.25)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n            \n         NDC.x *= 2.0;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n         color.rg -= draw_func(NDC, YSCALE*integ(NDC.x), YSCALE*func(NDC.x));\n         \n    float a = 0.,  b = NDC.x, y = 0., yn = 0., dx = 0.1;\n         \n    /**\n    switch(int(iTime * 0.5) % 4)\n    {\n    case 0: y = GaussLegendreQuadratureDegree2(a, b); yn = GaussLegendreQuadratureDegree2(a, b + dx); break;\n    case 1: y = GaussLegendreQuadratureDegree3(a, b); yn = GaussLegendreQuadratureDegree3(a, b + dx); break;\n    case 2: y = GaussLegendreQuadratureDegree4(a, b); yn = GaussLegendreQuadratureDegree4(a, b + dx); break;\n    case 3: y = GaussLegendreQuadratureDegree5(a, b); yn = GaussLegendreQuadratureDegree5(a, b + dx); break;\n    }\n    /**/\n    \n    float xs[16];\n    float ws[16];\n    //                      current                 min and max degrees.\n    float degree = clamp(1. + floor(mod(iTime, 8.)), 1.,     15.);\n    \n    calculateRootsAndWeights(xs, ws, degree);\n    \n    y = GaussLegendreQuadrature(xs, ws, a, b, degree);\n    yn = GaussLegendreQuadrature(xs, ws, a, b + dx, degree);\n         \n    color.gb -= draw_func(NDC, YSCALE*y, YSCALE*(y-yn)/dx);\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}