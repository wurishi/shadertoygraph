{"ver":"0.1","info":{"id":"sl3yW8","date":"1659660280","viewed":106,"name":"Generate Line","username":"lunar","description":"something test the miter\nif the community have better ideas QAQ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2drendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat drawChar(vec2 p, in vec2 pos, in vec2 size, in int c)\n{\n    p -= pos - 0.5 * size;\n    if (p.x <0. || p.y < 0. || p.x > size.x || p.y > size.y) return 0.;\n    vec2 cx = vec2(float(c & 15) * 0.0625, float(c >> 4) * 0.0625);\n    return texture(iChannel0, p / size * 0.0625 + cx).r;\n}\n\nfloat lineSeg(in vec2 p, in vec2 p0, in vec2 p1)\n{\n    vec2 d = normalize(p1 - p0);\n    float t = dot(p - p0, d);\n    return t < length(p1 - p0) && t > 0. ? length(p - p0 - t * d) : t <= 0.? length(p - p0) : length(p - p1);\n}\n\nfloat line(in vec2 p, in vec2 p0, in vec2 p1)\n{\n    vec2 d = normalize(p1 - p0);\n    float t = dot(p - p0, d);\n    return length(p - p0 - t * d);\n}\n\nvec2 rotate(vec2 v, vec2 c, float theta) {\n    float ct = cos(theta);\n    float st = sin(theta);\n    mat2 rotationMatrix = mat2(ct, -st, st, ct);\n    return rotationMatrix * (v - c) + c;\n}\n\nfloat cross2(in vec2 v1, in vec2 v2)\n{\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nvoid betterMiter(vec2 p1, vec2 p2, vec2 p3, float d, out vec2[5] outer, out vec2[3] inner)\n{\n    vec2 d1 = normalize(p2 - p1);\n    vec2 d2 = normalize(p2 - p3);\n    \n    // search for the outward facing normal\n    // we should make sure normalN.dot(dir~N) > 0\n    vec2 n1,n2;\n    if (d1.x * d2.y - d1.y * d2.x > 0.)\n    {\n        n1 = vec2(-d1.y, d1.x); // n1.dot(d2) = -d1.y * d2.x + d1.x * d2.y\n        n2 = vec2(d2.y, -d2.x); // n2.dot(d1) = d1.x * d2.y - d1.x * d2.y\n    }\n    else\n    {\n        // look for combination of d1.y * d2.x - d1.x * d2.y\n        n1 = vec2(d1.y, -d1.x);\n        n2 = vec2(-d2.y, d2.x);\n    }\n    \n    float s1 = d / dot(n1, d2);\n    float s2 = d / dot(n2, d1);\n    \n\n    vec2 mp = s1 * d1 + s2 * d2; // this is the miter joint position\n    vec2 mp0 = min(length(mp), d) * normalize(mp); // outer cap at thickness\n    // inner might need to choose between tessellation bounds and mitter depending on length.\n    \n    float div = cross2(n1, n2);\n    // if (div == 0.), parallel\n    \n    vec2 diff = p1 - p3;\n    float sn1 = cross2(diff, n1);\n    float sn2 = cross2(diff, n2);\n    vec2 joint = p2 - mp0;\n    if (abs(div) > 0.)\n    {\n        joint = p3 - n2 * clamp(sn1/div, 0., d);\n        if (length(joint - p2) > length(mp))\n            joint = p2 - mp;\n    }\n    \n    \n    outer = vec2[](p1 + d * n1, p2 + d * n1,  p2 + mp0, p2 + d * n2, p3 + d * n2);\n    inner = vec2[](p1 - d * n1, joint, p3 - d * n2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p1 = vec2(450., 200.);\n    vec2 p2 = vec2(300., 280.);\n    vec2 p3 = rotate(vec2(200., 150.), p2, iTime * 0.5);\n    \n    float f = sdTriangle(fragCoord, p1, p2, p3);\n    \n    vec2 outer[5];\n    vec2 inner[3];\n    betterMiter(p1, p2, p3, 230., outer, inner);\n\n    vec4 fc = vec4(0., 0., 0., 1.);\n    //float s = min(length(fragCoord - p3), length(fragCoord - p2));\n    //s = min(s, length(fragCoord - p1));\n    \n    float t1 = sdTriangle(fragCoord, outer[0], outer[1], inner[0]);\n    float t2 = sdTriangle(fragCoord, inner[0], inner[1], outer[1]);\n    float t3 = sdTriangle(fragCoord, outer[1], outer[2], inner[1]);\n    float t4 = sdTriangle(fragCoord, outer[2], outer[3], inner[1]);\n    float t5 = sdTriangle(fragCoord, outer[4], outer[3], inner[1]);\n    float t6 = sdTriangle(fragCoord, outer[4], inner[2], inner[1]);\n\n    if (t1 < 0. || t5 < 0. || t3 < 0.) fc.x = .6;\n    if (t4 < 0. || t2 < 0. || t6 < 0.) fc.y = .6;\n    \n    // white line: tessellation bounds\n    float s0 = lineSeg(fragCoord, inner[0], outer[0]);\n    s0 = min(s0, lineSeg(fragCoord, inner[2], outer[4]));\n    if (s0 < 2.)  {fc.z = 1.; fc.x = 1.; fc.y = 1.;}\n    \n    // blue line: segments we want to generate miter against\n    float s1 = lineSeg(fragCoord, p1, p2);\n    s1 = min(s1, lineSeg(fragCoord, p2, p3));\n    if (s1 < 2.)  {fc.z = 1.; fc.x = 0.; fc.y = 0.;}\n    \n    // yellow line: outside bounds if doing uncapped miter\n    float s2 = line(fragCoord, outer[0], outer[0] + p2 - p1);\n    s2 = min(s2, line(fragCoord, outer[4], outer[4] + p3 - p2));\n    if (s2 < 1.)  {fc.z = 0.5; fc.x = 1.; fc.y = 1.;}\n    \n    float c = drawChar(fragCoord/iResolution.xy, inner[0]/iResolution.xy, vec2(50., 50.)/iResolution.xy, 112);\n    c += drawChar(fragCoord/iResolution.xy, inner[1]/iResolution.xy, vec2(50., 50.)/iResolution.xy, 113);\n    c += drawChar(fragCoord/iResolution.xy, inner[2]/iResolution.xy, vec2(50., 50.)/iResolution.xy, 114);\n    if (c > 0.) {fc.z = c; fc.x = c; fc.y = c;}\n\n    // Output to screen\n    fragColor = fc;\n}","name":"Image","description":"","type":"image"}]}