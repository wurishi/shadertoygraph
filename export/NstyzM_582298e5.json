{"ver":"0.1","info":{"id":"NstyzM","date":"1653192016","viewed":91,"name":"Haru86_Ray_220522-05","username":"Haru86_","description":"Haru86_Ray_220522-05","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    //col=vec3(uv,0.0);\n    \n    // \n    float val=(sin(time*2.0)+1.0)*0.5+0.1;\n\tvec2 st=uv;\n\n\tuv.y+=0.05*sin(time*100.0)*val;\n\tuv.x+=0.01*sin(time*50.0)*val;\n    \n    vec4 _GapOffsetX=vec4(1.0,0.5,0.25,0.0);\n\tvec4 _GapOffsetY=vec4(0.02,0.03,0.03,0.0)*6.0;\n\tfloat _gapOffsetPower=0.08*val;\n\t\t\t\t\n\tvec2 vecFromCenter=vec2(0.0,0.0)-(uv-vec2(0.5,0.5))*2.0;\n\n    vec2 st_R=uv+vecFromCenter*_gapOffsetPower*_GapOffsetX.r;\n    vec2 st_G=uv+vecFromCenter*_gapOffsetPower*_GapOffsetX.g;\n    vec2 st_B=uv+vecFromCenter*_gapOffsetPower*_GapOffsetX.b;\n\n    col.rgb=texture(iChannel0,uv).rgb;\n    col.r+=texture(iChannel0,st_R).r;\n    col.g+=texture(iChannel0,st_G).g;\n    col.b+=texture(iChannel0,st_B).b;\n\n\tcol.rgb*=0.5;\n\tst=2.0*st-1.0;\n\tfloat width=0.2;\n\tcol.rgb*=(abs(st.y)>1.0-width)? 0.0:1.0;   \n    \n    //col=texture(iChannel0,uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nprecision mediump float;\n#define time iTime\n#define resolution iResolution\n\nuniform float _cameraPositionIndex;\nuniform float _isWhiteOut;\nuniform float _whiteOutVal;\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI 3.14159265\n\nstruct DBuffer{\n  float d1;\n  float d2;\n  float d3;\n  float d4;\n  float d5;\n  float mainD;\n};\n\nstruct AccBuffer{\n  float acc1;\n  float acc2;\n  float acc3;\n  float acc4;\n  float acc5;\n};\n\nfloat rand(vec2 seeds){\n  return fract(sin(dot(seeds, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 seeds)\n{\n seeds = vec2(dot(seeds, vec2(127.1, 311.7)),\n dot(seeds, vec2(269.5, 183.3)));\n return fract(sin(seeds) * 43758.5453123);\n}\n\nfloat perlinNoise(vec2 seeds)\n{\nvec2 i = floor(seeds);\nvec2 f = fract(seeds);\nvec2 i00 = i + vec2(0, 0);\nvec2 i10 = i + vec2(1, 0);\nvec2 i01 = i + vec2(0, 1);\nvec2 i11 = i + vec2(1, 1);\nvec2 f00 = f - vec2(0, 0);\nvec2 f10 = f - vec2(1, 0);\nvec2 f01 = f - vec2(0, 1);\nvec2 f11 = f - vec2(1, 1);\nvec2 g00 = normalize(-1.0 + 2.0 * random2(i00));\nvec2 g10 = normalize(-1.0 + 2.0 * random2(i10));\nvec2 g01 = normalize(-1.0 + 2.0* random2(i01));\nvec2 g11 = normalize(-1.0 + 2.0* random2(i11));\nfloat v00 = dot(g00, f00);\nfloat v10 = dot(g10, f10);\nfloat v01 = dot(g01, f01);\nfloat v11 = dot(g11, f11);\nvec2 p = smoothstep(0.0, 1.0, f);\nfloat v00v10 = mix(v00, v10, p.x);\nfloat v01v11 = mix(v01, v11, p.x);\nreturn mix(v00v10, v01v11, p.y) * 0.5 + 0.5;\n}\n\nvec2 fmod(vec2 p,float r){\n  float a=atan(p.x,p.y)+PI/r;\n  float n=(2.*PI)/r;\n  a=floor(a/n)*n;\n  return rot(a)*p;\n}\n\nfloat Plane(vec3 p){\n  float d=-p.y+1.0;\n  d=min(d,p.y+1.0);\n\n  return d;\n}\n\nfloat Cube(vec3 p,vec3 s){\n  return length(max(abs(p)-s,0.0));\n}\n\nfloat d1(vec3 p){\n  p.z-=time;\n  p.y+=perlinNoise(vec2(p.x,p.z))+perlinNoise(vec2(p.x,p.z)*5.0)*0.5+perlinNoise(vec2(p.x,p.z)*10.0)*0.35;\n  p.y*=0.6;\n  p.y=p.y*2.0-1.0;\n  float d=Plane(p);\n      return d;\n}\n\nfloat d2(vec3 p){\np.z-=time*10.;\n  vec3 pos0=p;\n  float r=perlinNoise(vec2(pos0.x,pos0.z))+perlinNoise(vec2(pos0.x,pos0.y)*5.0)*0.5+perlinNoise(vec2(pos0.y,pos0.z)*10.0)*0.35;\nfloat k=2.1;\npos0=mod(pos0,k)-k*0.5;\n\n  float d=length(pos0)-r;\n\n  return d;\n}\n\n\nfloat d3(vec3 p){\n//p*=7.;\n  p+=vec3(0.,0.,1.);\n\n  float d=length(p)-.1;\n//p.xyz*=7.;\n//p.x+=1.5;\n\n  p.xy*=rot(time);\n  p.xz*=rot(time);\n  p.yz*=rot(time);\n  for(int i=0;i<3;i++){\n    p=abs(p)-.035;\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n\n    p.xy*=rot(1.2);\n    p.xz*=rot(.25);\n    p.yz*=rot(.25);\n\n}\n\nd=min(d,Cube(p,vec3(.2,.2,.2)*.1));\n\n  return d;\n}\n\nfloat d4(vec3 p){\n\n    p+=vec3(0.,0.,-1.);\n    p.xz*=rot(time);\n\n    p*=0.5;\n    for(int i=0;i<3;i++){\n      p=abs(p)-.02;\n      if(p.x<p.y)p.xy=p.yx;\n      if(p.x<p.z)p.xz=p.zx;\n      if(p.y<p.z)p.yz=p.zy;\n\n      p.xy*=rot(length(p)-2.5);\n      p.xz*=rot(0.2);\n      p.yz*=rot(length(p)-2.25);\n    }\n    float h=1.2;\n    p.x-=clamp(p.x,-h,h);\n\n\nfloat d=Cube(p,vec3(.1,.1,.1)*0.1);\n  return d;\n}\n\nfloat Lighting(vec3 p,float timeOffset,float randRot){\n  p.xy*=rot(randRot*2.0*PI*0.5);\n  p.yz*=rot(randRot*2.0*PI);\n  p.y+=perlinNoise(vec2(p.z*15.,p.z*10.)*5.)*0.1;\n  float d=Cube(p,vec3(.002,.002,1.)*2.)*((p.z>mod(time*4.0+timeOffset,3.))? 1.0:2000.0);\n  return d;\n}\n\nfloat d5(vec3 p){\n  p+=vec3(0.,0.,1.);\n\n  float d=Lighting(p,0.0,0.0);\n  for(int i=0;i<5;i++){\n    vec3 pos=p;\n    float r=rand(vec2(float(i),0.456));\n    r=r*0.25+0.25;\n    r*=0.5;\n    pos.xy+=vec2(\n      r*cos(2.0*PI*rand(vec2(float(i),0.123))),\n      r*sin(2.0*PI*rand(vec2(float(i),0.456)))\n      );\n    d=min(d,Lighting(pos,rand(vec2(0.963,float(i))),rand(vec2(0.741,float(i)))));\n  }\n\n  return d;\n}\n\nDBuffer map(vec3 p){\n  DBuffer d;\n  d.d1=d1(p);\n  //d.d1=2000.0;\n  d.d2=d2(p);\n  //d.d2=d2(p);\n//  d.d3=2000.0;\nd.d3=d3(p);\nd.d4=d4(p);\n//d.d4=2000.0;\nd.d5=d5(p);\n//d.d5=2000.0;\nd.mainD=min(min(min(d.d1,d.d2),min(d.d3,d.d4)),d.d5);\n  return d;\n}\n\nvec3 gn(vec3 p){\n  vec2 e=vec2(0.001,0.);\n  return normalize(\n    vec3(\n      map(p+e.xyy).mainD-map(p-e.xyy).mainD,\n      map(p+e.yxy).mainD-map(p-e.yxy).mainD,\n      map(p+e.yyx).mainD-map(p-e.yyx).mainD\n      )\n    );\n}\n\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = (fragCoord.xy*2.0-resolution.xy) / min(resolution.x,resolution.y);\n  //vec2 st=uv*2.0-1.0;\n  //st.x*=(resolution.x/resolution.y);\n//st*=rot(time);\n  vec3 col=vec3((st.y+1.0)*0.5*0.25);\n  float radius=2.5;\nfloat speed=-.25;\n vec3 ta=vec3(0.);\n float adjustAcc=0.5;\n// vec3 ro=vec3(-1.,0.,0.);\n// vec3 ro=vec3(-1.5,0.,1.5);\nvec3 ro=vec3(cos(time)*radius,0.0,sin(time)*radius);\n\nif(_cameraPositionIndex==0.0){\n    ro=vec3(cos(time)*radius,0.0,sin(time)*radius);\n}else if(_cameraPositionIndex==1.0){\n    ro=vec3(-2.,0.,-2.)*3.0;\n}else if(_cameraPositionIndex==2.0){\n    float radius=1.0*(perlinNoise(vec2(0.123,time*5.0))+1.0)*2.25;\n    ro=vec3(cos(time)*radius,sin(time)*radius*0.1,sin(time)*radius);\n    //ro=vec3(-1.5,0.,1.5)\n}\n\n vec3 cDir=normalize(ta-ro);\n vec3 cSide=normalize(cross(cDir,vec3(0.,-1.,0.)));\n vec3 cUp=normalize(cross(cDir,cSide));\n float depth=1.;\n vec3 rd=normalize(vec3(st.x*cSide+st.y*cUp+cDir*depth));\n\n  DBuffer d;\n  AccBuffer acc;\n  float t=0.0;\n  for(int i=0;i<128;i++){\n    d=map(ro+rd*t);\n    if(d.d1<0.001||d.d2<0.001||d.d3<0.001||d.d4<0.001||d.d5<0.001||t>1000.0)break;\n    t+=d.mainD*.5;\n\n    acc.acc1+=exp(-50.0*(d.d1));\n    acc.acc2+=exp(-50.0*d.d2);\n    acc.acc3+=exp(-50.0*d.d3);\n    acc.acc4+=exp(-50.0*d.d4);\n    acc.acc5+=exp(-50.0*d.d5);\n  }\n\n    if(d.d1<0.001){\n      vec3 pos=ro+rd*t;\n      float flash=1.0-abs(sin(pos.z*.5+time*4.0));\n      flash+=.25;\n    col+=vec3(exp(-.1*t))*vec3(0.,0.25,1.0)*acc.acc1*0.05*flash;\n    }\n\n    if(d.d2<0.001){\n      vec3 pos=ro+rd*t;\n      float flash=1.0-abs(sin(pos.z*.5+time*4.0));\n      flash+=.25;\n      col+=vec3(exp(-.01*t))*vec3(0.,0.25,1.0)*acc.acc2*0.04*flash;\n    }\n\n    if(d.d3<0.001){\n        col+=exp(-.025*t)*acc.acc3*0.02*vec3(0.5,0.25,1.0);\n    }\n\n    if(d.d4<0.001){\n      vec3 refro=ro+rd*t;\n      vec3 n=gn(refro);\n      rd=refract(rd,n,0.786);\n      ro=refro;\n      t=0.1;\n      float acc2=0.0;\n\n      for(int i=0;i<33;i++){\n        d=map(ro+rd*t);\n        if(d.d1<0.001||d.d2<0.001||d.d3<0.001||d.d4<0.001||t>1000.0)break;\n        t+=d.mainD;\n        acc2+=exp(-3.*d.mainD);\n      }\n\n\n      vec3 pos=ro+rd*t;\n      float flash=1.0-abs(sin(pos.z*.5+time*4.0));\n      flash+=.1;\n      float H = mod(time*0.5, 1.0);\n      col+=vec3(exp(-.1*t))*acc2*.25*flash*hsv2rgb2(vec3(H,1.0,1.0),2.2)*adjustAcc;\n    }\n\n    if(d.d5<0.01){\n      //col+=vec3(-.1*t)*acc.acc5*0.075;\n      col+=vec3(1.)*acc.acc5*0.025*vec3(1.,1.,1.);\n    }\n\n    if(_isWhiteOut==1.0){\n        col+=_whiteOutVal*vec3(1.0);\n    }\n\n  fragColor = vec4(col, 1.0);\n}\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/","name":"Buffer A","description":"","type":"buffer"}]}