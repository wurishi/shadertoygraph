{"ver":"0.1","info":{"id":"lcVyDw","date":"1732053228","viewed":58,"name":"Limited 2D Domain Rep","username":"incre_ment","description":"An exercise in 2D limited domain repetition.  Wanted to work this in 2D before attempting in 3D.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["limiteddomainrepetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I was working on a 3D shader when I realized I hadn't looked at \n// limited domain repetition before (at least not recently).  \n// This shader is just figuring that out.  Three different constrained components: \n// The square grid, the rotating circles, the outer edge.\n\n// There's probably a more elegant/optimized way to do some of this stuff\n// but I wanted a simple shader I could refer back to.\n\n#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\n// Thanks IQ!\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n  \n   float tt = fract(.3*iTime);\n   vec3 col = vec3(0.);  \n   \n   float scale = 5.;\n   uv *= scale;\n   \n   // Limited Domain Repetition\n   // 4 cells in each x-dir, 2 cells in each y-dir (and zero!)\n   vec2 cellID;\n   cellID.x = clamp(round(uv.x),-4.,4.);\n   cellID.y = clamp(round(uv.y),-2.,2.);\n   uv = uv - cellID;\n \n   // Squares\n   // 2x+1 squares in the x-dir (x=3); 2y+1 squares in the y-dir (y=1)\n   // Neighbor checking because glow.\n   float minVal = 1E20;\n   for(float i=-1.;i<=1.; i++)\n   for(float j=-1.;j<=1.; j++){\n     float boxDim = .2 + .2 * sin(TAU*tt + (cellID.x + i) * (cellID.y + j));\n     if (abs(cellID.x + i) <= 3. && abs(cellID.y + j) <= 1.)\n       minVal = min(minVal, abs(sdBox(uv - vec2(i,j), vec2(boxDim))) - .01);\n   }\n   col += .02/abs(minVal);\n \n   // Border Rings\n   // Constrained to the outer edge of the shader\n   // No neighbor checking because glow attenuated with pow().\n   if(abs(cellID.y) > 1. || abs(cellID.x) > 3.){\n     float rad = .05+.05*sin(TAU*(tt + (cellID.x)/5. * (-cellID.y)/5.) );\n     col += pow(.02/abs(length(uv) - rad),2.);\n   }\n \n   // Spinning Rings\n   // Limited Domain Repetition with a transformation (rotation)\n   // Lots of neighbor checking because rings span many cells.\n   uv = (uv + cellID) * rotation(TAU*tt);\n   uv -= cellID;\n   minVal = 1E20;\n   for(float i=-3.; i<=3.; i++)\n   for(float j=-3.; j<=3.; j++){\n     if (abs(cellID.x + i) <= 1. && abs(cellID.y + j) <= 1.)\n       minVal = min(minVal, length(uv - vec2(i,j)) - .3);\n   }\n   col += .02/abs(minVal);\n   fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}