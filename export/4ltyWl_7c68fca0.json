{"ver":"0.1","info":{"id":"4ltyWl","date":"1534656907","viewed":595,"name":"Escher - Cubic Space Division","username":"vug","description":"Yet another reproduction of Escher's Cubic Space Division (1954) in GLSL. Drag around with the mouse to change the camera position and angle. https://www.wikiart.org/en/m-c-escher/cubic-space-division","likes":15,"published":1,"flags":1,"usePreview":0,"tags":["3d","escher","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Yet another reproduction of Escher's Cubic Space Division (1954) in GLSL. \n * https://www.wikiart.org/en/m-c-escher/cubic-space-division\n *\n * Ray marching and lighting code taken from: https://www.shadertoy.com/view/4tcGDr\n * Simplex3D code taken from: https://www.shadertoy.com/view/XtBGDG\n * Edge Detection idea taken from: https://www.shadertoy.com/view/4s2XRd\n * Fog code taken from: https://iquilezles.org/articles/fog\n * Repetition by modulus code taken from: https://iquilezles.org/articles/distfunctions\n * Anti-alias code taken from: https://www.shadertoy.com/view/Mss3R8 not giving a good result :-(\n */\n#define AA 1\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0); \n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat columnSDF(vec3 p, vec3 size) {\n    vec3 d = abs(vec3(p.x, 0.0, p.z)) - size * 0.5;\n    \n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;    \n}\n\nfloat columnsSDF(vec3 p, float dbc) {\n    float columnThickness = 1.0;\n    \n    vec3 c = vec3(dbc, 0.0, dbc);\n    vec3 q = mod(p, c) - 0.5 * c;\n    float columns = columnSDF(q, vec3(1.0) * columnThickness);\n    return columns;    \n}\n\nfloat sceneSDF(vec3 p) {\n    float distanceBetweenColumns = 20.0;\n    \n    vec3 p1 = p;    \n    float columns1 = columnsSDF(p1, distanceBetweenColumns);\n    \n    vec3 p2 = rotateZ(PI * 0.5) * p;\n    float columns2 = columnsSDF(p2, distanceBetweenColumns);\n    \n    vec3 p3 = rotateX(PI * 0.5) * p;\n    float columns3 = columnsSDF(p3, distanceBetweenColumns);\n    \n    float columns = min(min(columns1, columns2), columns3);\n    \n    vec3 s = mod(p, vec3(distanceBetweenColumns)) - 0.5 * vec3(distanceBetweenColumns);\n    float boxes = boxSDF(s, vec3(3.0));\n    \n    return min(columns, boxes);\n}\n\n\n\nvec2 rayMarch(vec3 eye, vec3 marchingDirection) {\n    float depth = MIN_DIST;\n    \n    float EDGE_SIZE = 0.08;\n    float SMOOTH = 0.05; \n    float minDist = 10000.0;\n    bool stp = false;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        \n\t\tif (!stp) {\n            if (minDist < EDGE_SIZE && minDist < dist) {\n                stp = true;\n            }\n            minDist = min(minDist, dist);\n        }        \n        \n        \n        if (dist < EPSILON) {\n            float edge = 1.0;\n            if (stp) {\n                edge = smoothstep(EDGE_SIZE - SMOOTH, EDGE_SIZE + 0.01, minDist);\n            }                \n\t\t\treturn vec2(depth, edge);\n        }\n        \n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return vec2(MAX_DIST, 1.0);\n        }\n    }\n    return vec2(MAX_DIST, 1.0);\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 diffuseContribForLight(vec3 k_d, vec3 p, vec3 eye, vec3 lightDir, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightDir);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {  // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    return lightIntensity * (k_d * dotLN);    \n}\n\nvec3 illumination(vec3 k_a, vec3 k_d, vec3 p, vec3 eye) {\n    const vec3 ambientLight = vec3(-0.15\t);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0.3, 0.5, -1.0);\n    vec3 light1Intensity = vec3(1.0) * 5.0;\n    color += diffuseContribForLight(k_d, p, eye, light1Pos, light1Intensity);\n\n    return color;\n}\n\nvec3 applyFog( in vec3  rgb, in float distance )\n{\n   \tfloat decayRate = 0.03;\n    float fogAmount = 1.0 - exp(-distance * pow(decayRate, 1.4));\n    vec3 fogColor = vec3(1.0);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 computeColor(vec3 eye, vec3 worldDir, bool isVR) {\n    vec2 rm = rayMarch(eye, worldDir);    \n    float dist = rm.x;\n    float edge = rm.y;\n    \n    if (dist > MAX_DIST - EPSILON) {  // Didn't hit anything\n\t\treturn vec3(0.95);\n    }\n\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(1.0);\n    vec3 K_d = vec3(0.14);\n    float shininess = 5.0;\n    vec3 color = illumination(K_a, K_d, p, eye);\n\n    float noise = simplex3D(p * 12.0) * 0.5 + 0.5;\n    noise = pow(noise, 3.0);\n    color += noise * 0.4;\n\n    color = applyFog(color, dist);\n    \n    if (!isVR) {\n  \t\tcolor += vec3(1.0 - edge);\n    }\n    \n    color = pow(color, vec3(1.5)); // contrast\n        \n    return color;    \n}\n\nvec3 render(vec2 fragCoord) {\n    float fov = 40.0;\n    fov += 90.0 * iMouse.y / iResolution.y;\n\tvec3 viewDir = rayDirection(fov, iResolution.xy, fragCoord);    \n    vec3 target = vec3(7.0, 8.0, 3.0);\n    target += vec3(0.0, 0.0, -iTime * 4.0);\n    vec3 eye = vec3(0.7, 0.83, 1.8);\n    eye *= vec3(\n        cos(iMouse.x / iResolution.x * PI),\n        cos(iMouse.x / iResolution.x * PI * 2.0),\n        1.0\n    );\n    eye = eye * 25.0 + target;\n    \n    mat3 viewToWorld = viewMatrix(eye, target, vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;   \n    \n\treturn computeColor(eye, worldDir, false);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sColor = vec3(0.0);\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\t    sColor += render( fragCoord+of );\n\t}\n\tsColor /= float(AA*AA); \n    \n    fragColor = vec4(sColor, 1.0);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {\n    vec3 ro = fragRayOri + vec3(0.0, 0.0, iTime);\n    vec3 color = computeColor(-10.0*ro, fragRayDir, true);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int MAX_MARCHING_STEPS = 150;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\nconst float PI = 3.14159265;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}","name":"Common","description":"","type":"common"}]}