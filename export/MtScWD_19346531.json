{"ver":"0.1","info":{"id":"MtScWD","date":"1509213941","viewed":142,"name":"Hello Ray Marching (2)","username":"2YY","description":"How to apply camera focal length ......","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float COLLISION_THRESHOLD = 1e-6;\nconst float INFINITE = 1e128;\n\n\n\n\nfloat unionDistance(float distance1, float distance2) {return min(distance1, distance2);}\n\nfloat distanceToSphere(vec3 spherePosition, float sphereRadius, vec3 p) {\n\treturn distance(spherePosition, p) - sphereRadius;\n}\n\nfloat distanceToAll(vec3 p) {\n\tvec3 sphere1Pos = vec3(1.0, 1.0, 3.0);\n\tfloat sphere1Radius = mix(1.0, 1.1, sin(iTime));\n\tvec3 sphere2Pos = vec3(mix(-0.01, 1.0, sin(iTime*1.0)), 0.0, 2.0);\n\tfloat sphere2Radius = mix(1.0, 1.1, sin(iTime*0.5));\n\tvec3 sphere3Pos = vec3(-1.0, -1.0, mix(1.9, 2.1, sin(iTime)));\n\tfloat sphere3Radius = mix(0.8, 1.1, sin(iTime*0.9));\n\n\tfloat d1 = distanceToSphere(sphere1Pos, sphere1Radius, p);\n\tfloat d2 = distanceToSphere(sphere2Pos, sphere2Radius, p);\n\tfloat d3 = distanceToSphere(sphere3Pos, sphere3Radius, p);\n\tfloat d = unionDistance(d1, d2);\n\td = unionDistance(d, d3);\n\treturn d;\n}\n\nvec3 getNormal(vec3 p) {\n\tconst float d = 0.0001;\n\treturn normalize(\n\t\tvec3 (\n\t\t\tdistanceToAll(p+vec3(d,0.0,0.0))-distanceToAll(p+vec3(-d,0.0,0.0)),\n\t\t\tdistanceToAll(p+vec3(0.0,d,0.0))-distanceToAll(p+vec3(0.0,-d,0.0)),\n\t\t\tdistanceToAll(p+vec3(0.0,0.0,d))-distanceToAll(p+vec3(0.0,0.0,-d))\n\t\t)\n\t);\n\treturn vec3(false);\n}\n\n\n\n\n/**\n * とりあえずワールド座標のことは忘れて、ビュー座標上のみで計算する。\n * ビュー座標 === カメラの場所が原点であり、正のZ方向がカメラの方向。\n * 1. 方向\n * 2. 焦点距離\n * 3. Z回転\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 reso = iResolution.xy;\n\tif(iResolution.x > iResolution.y) {reso.x *= iResolution.y / iResolution.x;}\n\telse if(iResolution.y > iResolution.x) {reso.y *= iResolution.x / iResolution.y;}\n\tvec2 uv = (2.0*gl_FragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\tvec3 cameraPos = vec3(0.0, 0.0, 0.0); // ビュー座標なので、カメラの座標は常に座標系の原点になります。\n\tvec3 cameraDirection = vec3(0.0, 0.0, 1.0); // カメラの向きも、ビュー座標なので、正のZ方向で固定。\n\n\tfloat rayLength = 0.0;\n\tvec3 rayDirection = vec3(uv.x, uv.y, cameraDirection.z);\n\n\tvec4 color = vec4(false);\n\n\tfor(int i=0;  i<64; i++) {\n\t\tvec3 ray = cameraPos + rayDirection * rayLength;\n\t\tfloat d = distanceToAll(ray);\n\t\tif(d < COLLISION_THRESHOLD) {color=vec4(getNormal(ray), 1.0); break;}\n\t\trayLength += d;\n\t}\n\n\tfragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}