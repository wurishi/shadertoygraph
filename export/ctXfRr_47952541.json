{"ver":"0.1","info":{"id":"ctXfRr","date":"1692491977","viewed":89,"name":"Mandelbrot set with normals","username":"MrHAX00","description":"I was curious to see if I could fake some sort of 3d-ness by taking my old mandelbrot set shader and combining it with my recent bump map shader.\n\nControls:\nClick the circle and drag it for zooming in/out.\nClick and drag anywhere for movement.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","fractal","mouse","normals","mandelbrotset","bumpmap","mobile"],"hasliked":0,"parentid":"sslcRH","parentname":"Mandelbrot Set with cam controls"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926535897932384626433832795\n#define Circle(uv, Pos, Radius, Blur) smoothstep(Radius + Blur, Radius - Blur, length(uv - Pos));\n\nfloat Rectangle(vec2 uv, vec2 Pos, vec2 Size, float Blur) {\n    uv -= Pos;\n    \n    float XBand = smoothstep(-Size.x - Blur, -Size.x + Blur, uv.x) * smoothstep(Size.x + Blur, Size.x - Blur, uv.x);\n    float YBand = smoothstep(-Size.y - Blur, -Size.y + Blur, uv.y) * smoothstep(Size.y + Blur, Size.y - Blur, uv.y);\n    return XBand * YBand;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 TextureCoord = vec2(fragCoord);\n    vec4 Texture = texelFetch(iChannel0, ivec2(TextureCoord), 0);\n    \n    // calculate surface normal using cross\n    float Height = Texture.w;\n    float HeightX = texelFetch(iChannel0, ivec2(TextureCoord + vec2(1., 0.)), 0).w;\n    float HeightZ = texelFetch(iChannel0, ivec2(TextureCoord + vec2(0., 1.)), 0).w;\n    \n    vec3 NormalX = normalize(vec3(.1, Height - HeightX, 0.));\n    vec3 NormalZ = normalize(vec3(0., Height - HeightZ, .1));\n    \n    vec3 SurfaceNormal = normalize(cross(NormalZ, NormalX) * vec3(1., 1. / NormalStrength, 1.));\n    \n    float Brightness = smoothstep(-1., 1., dot(SurfaceNormal, normalize(vec3(cos(iTime * .2 * pi), .25, sin(iTime * .2 * pi)))));\n    Brightness *= Brightness * Brightness;\n    vec3 Color = Texture.rgb * (Brightness * .85 + .15);\n    //Color += Color * Brightness * Brightness * Brightness * Brightness * .2;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float AspectRatio = iResolution.x/iResolution.y;\n    uv.x *= AspectRatio;\n    uv -= vec2(AspectRatio * .5, .5);\n    uv *= 2.;\n    //Overlay the appropriate controls:\n    \n#if (Mobile)\n    float Button1 = Rectangle(\n        vec2(\n            uv.x,\n            -abs(uv.y + .7625) - .7625\n        ),\n        vec2(AspectRatio - .125, -.875),\n        vec2(.1),\n        .001\n    );\n    \n    vec2 Mirror = vec2(AspectRatio - .4625, -.7625);\n    float Button2 = Rectangle(\n            -abs(Mirror - uv) + Mirror,\n        vec2(AspectRatio - .575, -.875),\n        vec2(.1),\n        .001\n    );\n    \n    float Mirror2 = AspectRatio - .35;\n    float MinusSign = Rectangle(\n        vec2(\n            -abs(uv.x - Mirror2) + Mirror2,\n            uv.y\n        ),\n        vec2(AspectRatio - .575, -.65),\n        vec2(.06, .005),\n        .001\n    );\n    \n    float PlusSign = Rectangle(\n        uv,\n        vec2(AspectRatio - .125, -.65),\n        vec2(.005, .06),\n        .001\n    );\n    \n    Color = mix(Color, .5 - Color * .5, Button1 + Button2);\n    Color += vec3(MinusSign);\n    Color += vec3(PlusSign);\n#else\n    float Negate = 1.2 - Circle(\n        uv,\n        vec2(AspectRatio - .2, -.8125),\n        .16,\n        .001\n    );\n    \n    float Button1 = Negate * Circle(\n        uv,\n        vec2(AspectRatio - .2, -.8125),\n        .175,\n        .001\n    );\n    \n    Color = mix(Color, 1. - Color, Button1);\n#endif\n\n    fragColor = vec4(Color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Camera and button presses:\n\nfloat Rectangle(vec2 uv, vec2 Pos, vec2 Size, float Blur) {\n    uv -= Pos;\n    Size *= .5;\n    \n    float XBand = smoothstep(-Size.x - Blur, -Size.x + Blur, uv.x) * smoothstep(Size.x + Blur, Size.x - Blur, uv.x);\n    float YBand = smoothstep(-Size.y - Blur, -Size.y + Blur, uv.y) * smoothstep(Size.y + Blur, Size.y - Blur, uv.y);\n    return XBand * YBand;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 MouseAt = iMouse.xy/iResolution.xy;\n    \n    float AspectRatio = iResolution.x/iResolution.y;\n    MouseAt.x *= AspectRatio;\n    MouseAt -= vec2(AspectRatio * .5, .5);\n    MouseAt *= 2.;\n    \n#if Mobile == 1\n    int Address = int(fragCoord.x);\n    if (Address == ZoomAddress) {\n        fragColor = ZoomData;\n        \n        if (fragColor.w == 0.) {\n            fragColor = vec4(0., 1., 0., 1.);\n        }\n        \n        if (iMouse.w > 0.) {\n            fragColor.x = clamp(fragColor.x * -2. + Rectangle(\n            MouseAt,\n            vec2(AspectRatio - .125, -.65),\n            vec2(.1),\n            .001\n            ), 0., 1.);\n            \n            fragColor.z = clamp(fragColor.z * -2. + Rectangle(\n            MouseAt,\n            vec2(AspectRatio - .575, -.65),\n            vec2(.1),\n            .001\n            ), 0., 1.);\n        }\n        \n        if (fragColor.x > 0.) {\n            fragColor.y *= 1.025;\n        } else if (fragColor.z > 0.) {\n            fragColor.y /= 1.025;\n        }\n    } else if (Address == CamAddress) {\n        fragColor = CamData;\n        \n        if (fragColor.x == 0. && fragColor.y == 0.) {\n            fragColor = vec4(1., 0., 0., 0.);\n        }\n        \n        if (iMouse.w > 0.) {\n            float Hit1 = Rectangle(\n            MouseAt,\n            vec2(AspectRatio - .575, -.875),\n            vec2(.1),\n            .001\n            );\n            float Hit2 = Rectangle(\n                MouseAt,\n                vec2(AspectRatio - .35, -.875),\n                vec2(.1),\n                .001\n            );\n            float Hit3 = Rectangle(\n                MouseAt,\n                vec2(AspectRatio - .125, -.875),\n                vec2(.1),\n                .001\n            );\n            float Hit4 = Rectangle(\n                MouseAt,\n                vec2(AspectRatio - .35, -.65),\n                vec2(.1),\n                .001\n            );\n            \n            if (Hit1 > 0.) {\n                if (fragColor.z != 1.) fragColor.z = 1.;\n                else fragColor.z = 0.;\n            } else if (Hit2 > 0.) {\n                if (fragColor.z != 2.) fragColor.z = 2.;\n                else fragColor.z = 0.;\n            } else if (Hit3 > 0.) {\n                if (fragColor.z != 3.) fragColor.z = 3.;\n                else fragColor.z = 0.;\n            } else if (Hit4 > 0.) {\n                if (fragColor.z != 4.) fragColor.z = 4.;\n                else fragColor.z = 0.;\n            } else {\n                fragColor.z = 0.;\n            }\n        }\n        \n        float Zoom = MovementSpeed / ZoomData.y;\n        float Direction = fragColor.z;\n        \n        if (Direction == 1.) fragColor.x += Zoom;\n        else if (Direction == 2.) fragColor.y += Zoom;\n        else if (Direction == 3.) fragColor.x -= Zoom;\n        else if (Direction == 4.) fragColor.y -= Zoom;\n    }\n#else\n    int Address = int(fragCoord.x);\n    if (Address == ZoomAddress) {\n        fragColor = ZoomData;\n        \n        if (fragColor.w == 0.) {\n            fragColor = vec4(0., 1., 0., 1.);\n        }\n        \n        float Distance = length(vec2(AspectRatio - .2, -.8125) - MouseAt);\n        if (iMouse.w > 0. && Distance < .16) {\n            fragColor.x = 1.;\n        } else if (iMouse.z < 0.) {\n            fragColor.x = 0.;\n        } else if (fragColor.x == 1.) {\n            fragColor.y *= .99 + Distance * .05;\n        }\n    } else if (Address == CamAddress) {\n        fragColor = CamData;\n        \n        if (fragColor.x == 0. && fragColor.y == 0.) {\n            fragColor = vec4(1., 0., MouseAt);\n        }\n         \n        vec2 Delta = MouseAt - fragColor.zw;\n        \n        if (iMouse.w > 0. || ZoomData.x > 0. ) {\n            Delta = vec2(0.);\n        }\n        \n        fragColor.xy += Delta / clamp(ZoomData.y, .0001, 1. / 0.);\n        fragColor.zw = MouseAt;\n    }\n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Settings:\n#define MaxIteration 500\n#define NormalStrength 5.\n\n//Set \"mobile\" to 1 to activate the mobile control scheme:\n#define Mobile 0\n#define MovementSpeed .01\n\n//Buffer addresses:\n//Camera position:\n#define CamAddress 0\n#define CamData texelFetch(iChannel0, ivec2(0), 0)\n//Zoom info:\n#define ZoomAddress 1\n#define ZoomData texelFetch(iChannel0, ivec2(1), 0)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define pi 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize pixel coordinates:\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float AspectRatio = iResolution.x/iResolution.y;\n    uv.x *= AspectRatio;\n    uv -= vec2(AspectRatio * .5, .5);\n    uv *= 2.;\n    float Zoom = ZoomData.y;\n    vec2 FractalCam = (uv - CamData.xy * Zoom);\n    FractalCam /= Zoom;\n    \n    //Calculate the fractal:\n    vec2 Value = FractalCam;\n    int Itered = 1;\n    for (int i = 1; i <= MaxIteration; i++) {\n        float x = Value.x;\n        float y = Value.y;\n        Value = vec2(x * x - y * y, 2. * x * y) + FractalCam;\n        if (dot(Value, Value) < 4400.) {\n            Itered += 1;\n        } else {\n            break;\n        }\n    }\n    \n    //Plot the fractal:\n    if (Itered >= MaxIteration) {\n        fragColor = vec4(0., 0., 0., 1.);\n    } else {\n        float Temp = log(length(Value)) / log(60.);\n        Temp = pow((float(Itered) - log(Temp) / log(2.)), .5);\n        fragColor = vec4(\n            cos(Temp * 1.44 + iTime) * .5 + .5,\n            cos(Temp * .72 + iTime)*.5 + .5,\n            cos(Temp * .36 + iTime)*.5 + .5,\n            Temp\n        );\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}