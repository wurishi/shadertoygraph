{"ver":"0.1","info":{"id":"MfdyWs","date":"1731374361","viewed":29,"name":"Fork M1 - Ray t zebus 427","username":"zebus","description":"Source code for ray-tracing assignment : signed distance field representation, basic shading ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"lXXyzj","parentname":"M1 - Ray tracing - 2024"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Eric Galin\n\nstruct Ray {\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Val {\n    float v; // Signed distance\n    int c; // Cost\n};\n\n// Compute point on ray\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\n// Random direction in a hemisphere\nvec3 Hemisphere(int seed, vec3 n) {\n    float a = fract(sin(176.19 * float(seed)));\n    float b = fract(sin(164.19 * float(seed)));\n    float u = 2. * 3.1415 * a;\n    float v = acos(2. * b - 1.);\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));\n    if (dot(d, n) < 0.) { d = -d; }\n    return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\nmat3 Rz(float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\n// Compute the ray\nRay CreateRay(vec2 m, vec2 p) {\n    float a = 3. * 3.14 * m.x;\n    float le = 3.5;\n    vec3 ro = vec3(37., 0., 15.);\n    ro *= Rz(a);\n    vec3 ta = vec3(0., 0., 1.);\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(p.x * u + p.y * v + le * w);\n    return Ray(ro, rd);\n}\n\n// Primitives -------------------------------------------------------------------------------\n\nVal Sphere(vec3 p, vec3 c, float r) {\n    return Val(length(p - c) - r, 1);\n}\n\nVal Plane(vec3 p, vec3 n, vec3 o) {\n    return Val(dot((p - o), n), 1);\n}\n\nVal Ellipsoid(vec3 p, vec3 c, vec3 r) {\n    vec3 d = (p - c) / r;\n    float v = length(d) - 1.0;\n    return Val(v, 1);\n}\n\nVal Box(vec3 p, vec3 c, vec3 b) {\n    vec3 d = abs(p - c) - b;\n    float v = length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n    return Val(v, 1);\n}\n\nVal Capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float v = length(pa - h * ba) - r;\n    return Val(v, 1);\n}\n\nVal Torus(vec3 p, vec3 c, float r1, float r2) {\n    vec3 q = p - c;\n    vec2 d = vec2(length(q.xz) - r1, q.y);\n    float v = length(d) - r2;\n    return Val(v, 1);\n}\n\nVal Cylinder(vec3 p, vec3 c, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz - c.xz), p.y - c.y)) - vec2(r, h / 2.0);\n    float v = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n    return Val(v, 1);\n}\n\n// Operators\n\nmat4 Translation(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n    );\n}\n\nmat4 RotationZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(\n        c, -s, 0.0, 0.0,\n        s,  c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 Scaling(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n//jacobins\nfloat coef(vec3 s)\n{\n    // Calculate the inverse of each component\n    float invX = s.x;\n    float invY = s.y;\n    float invZ = s.z;\n\n    // Return the maximum value of the three\n    return max(invX, max(invY, invZ));\n}\n\n\nmat4 ModelMatrix(vec3 translation, vec3 scaling, float rotationAngle) {\n    return Translation(translation) * RotationZ(rotationAngle) * Scaling(scaling);\n}\n\n// Boolean operations\nVal Union(Val a, Val b) {\n    return Val(min(a.v, b.v), a.c + b.c + 1);\n}\n\nVal Difference(Val a, Val b) {\n    return Val(max(a.v, -b.v), a.c + b.c + 1);\n}\n\nVal Intersection(Val a, Val b) {\n    return Val(max(a.v, b.v), a.c + b.c + 1);\n}\n\n\n\n// Basic Noise Function\nfloat Noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n000 = dot(i + vec3(0, 0, 0), vec3(1.0, 57.0, 113.0));\n    float n100 = dot(i + vec3(1, 0, 0), vec3(1.0, 57.0, 113.0));\n    float n010 = dot(i + vec3(0, 1, 0), vec3(1.0, 57.0, 113.0));\n    float n110 = dot(i + vec3(1, 1, 0), vec3(1.0, 57.0, 113.0));\n    float n001 = dot(i + vec3(0, 0, 1), vec3(1.0, 57.0, 113.0));\n    float n101 = dot(i + vec3(1, 0, 1), vec3(1.0, 57.0, 113.0));\n    float n011 = dot(i + vec3(0, 1, 1), vec3(1.0, 57.0, 113.0));\n    float n111 = dot(i + vec3(1, 1, 1), vec3(1.0, 57.0, 113.0));\n\n    float x00 = mix(fract(sin(n000) * 43758.5453), fract(sin(n100) * 43758.5453), f.x);\n    float x10 = mix(fract(sin(n010) * 43758.5453), fract(sin(n110) * 43758.5453), f.x);\n    float x01 = mix(fract(sin(n001) * 43758.5453), fract(sin(n101) * 43758.5453), f.x);\n    float x11 = mix(fract(sin(n011) * 43758.5453), fract(sin(n111) * 43758.5453), f.x);\n\n    float y0 = mix(x00, x10, f.y);\n    float y1 = mix(x01, x11, f.y);\n\n    return mix(y0, y1, f.z) - 0.5;\n}\n\n// Fractional Brownian Motion (fBm) for turbulence effect\nfloat fBm(vec3 p, int octaves, float persistence) {\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float sum = 0.0;\n    float maxAmplitude = 0.0;\n\n    for (int i = 0; i < octaves; i++) {\n        sum += amplitude * Noise(p * frequency);\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n\n    return sum / maxAmplitude;\n}\n\n\n\n// Deform the object's surface with fBm for bumps and grooves\nVal Deform(Val obj, vec3 p, float scale, float intensity, int octaves, float persistence) {\n    float noise = fBm(p * scale, octaves, persistence) * intensity;\n    return Val(obj.v + noise, obj.c);\n}\n\n\nVal NoiseDeformation(Val val, vec3 p) {\n    float deformation = Noise(p) * 0.3;// <1=. for best results\n    return Val(val.v + deformation, val.c);\n}\n\n\nfloat Marble(vec3 p, float scale, int octaves, float persistence) {\n    float noise = fBm(p * scale, octaves, persistence);\n    return abs(sin(p.z + noise * 5.0));\n}\n\nVal object(vec3 p) {\n    Val sphere = Sphere(p, vec3(0.0, 0.0, 0.0), 1.5);\n    Val plane = Plane(p, vec3(0.0, 0.0, 1.0), vec3(0.0, -0.,-2.0));\n    Val ellipsoid = Ellipsoid(p, vec3(2.0, 0.0, 0.0), vec3(1.0, 1.5, 1.0));\n    Val box = Box(p, vec3(-2.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    Val capsule = Capsule(p, vec3(0.0, 2.0, 0.0), vec3(0.0, 3.5, 0.0), 0.5);\n    Val torus = Torus(p, vec3(0.0, -2.0, 0.0), 1.0, 0.3);\n    Val cylinder = Cylinder(p, vec3(2.0, 2.0, 0.0), 0.5, 2.0);\n\n    // Combine all primitives using union\n    Val obj = sphere;\n    obj = Union(obj, ellipsoid);\n    obj = Union(obj, box);\n    obj = Union(obj, capsule);\n    obj = Union(obj, torus);\n    obj = Union(obj, cylinder);\n    obj= NoiseDeformation(obj, p);\n    obj = Union(obj, Deform(plane, p, 1.0, 0.5, 5, 0.6));    \n\n    \n\n    return obj;\n}\n\n\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\nvec3 ObjectNormal(vec3 p) {\n    const float eps = .001;\n    vec3 n;\n    Val val = object(p);\n    float v = val.v;\n    n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n    n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n    n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n    return normalize(n);\n}\n\n// Sphere tracing\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c) {\n    bool h = false;\n    t = 0.0;\n    c = 0;\n    for (int i = 0; i < Steps; i++) {\n        s = i;\n        vec3 p = Point(ray, t);\n        Val val = object(p);\n        float v = val.v;\n        c += val.c;\n        if (v < 0.) {\n            h = true;\n            break;\n        }\n        t += max(Epsilon, v);\n        if (t > e) { break; }\n    }\n    return h;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\nvec3 background(Ray ray) {\n    return mix(vec3(.45, .55, .99), vec3(.65, .69, .99), ray.d.z * .5 + .5);\n}\n\nfloat Shadow(vec3 p, vec3 n, vec3 l) {\n    float t;\n    int s;\n    int c;\n    bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100., t, s, c);\n    if (!hit) {\n        return 1.;\n    }\n    return 0.;\n}\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    bool isDirectional;\n};\n\nvec3 PhongIllumination(vec3 p, vec3 n, vec3 viewDir, Light light, vec3 ambientColor, vec3 diffuseColor, vec3 specularColor, float shininess) {\n    vec3 lightDir;\n    if (light.isDirectional) {\n        lightDir = normalize(light.position);\n    } else {\n        lightDir = normalize(light.position - p);\n    }\n\n    // Ambient component\n    vec3 ambient = ambientColor * light.color;\n\n    // Diffuse component\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = diff * diffuseColor * light.color;\n\n    // Specular component\n    vec3 reflectDir = reflect(-lightDir, n);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    vec3 specular = spec * specularColor * light.color;\n\n    return ambient + diffuse + specular;\n}\n\nbool IsInShadow(vec3 p, vec3 lightDir, float lightDist) {\n    Ray shadowRay;\n    shadowRay.o = p + lightDir * Epsilon;\n    shadowRay.d = lightDir;\n    float t = 0.0;\n    int steps = 0;\n    for (int i = 0; i < Steps; i++) {\n        vec3 q = Point(shadowRay, t);\n        Val val = object(q);\n        if (val.v < Epsilon) {\n            return true;\n        }\n        t += val.v;\n        steps++;\n        if (t > lightDist) {\n            break;\n        }\n    }\n    return false;\n}\n\nfloat AmbientOcclusion(vec3 p, vec3 n) {\n    float ao = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        Val smple = object(p + h * n);\n        ao += (h - smple.v) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - ao, 0.0, 1.0);\n}\n\n\n\nvec3 Shade(vec3 p, vec3 n, Ray eye) {\n    const vec3 lp = vec3(5., 10., 25.);\n    vec3 l = normalize(lp - p);\n    vec3 ambient = .25 + .25 * background(Ray(p, n));\n    float shadow = Shadow(p, n, l);\n    float ao = AmbientOcclusion(p, n);\n    vec3 diffuse = .35 * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n    vec3 r = reflect(eye.d, n);\n    vec3 specular = .15 * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n    vec3 color = ambient + shadow * (diffuse + specular) * ao;\n    return color;\n}\n\n\n\n\n\n\n\n// Reflection\nvec3 ReflectColor(vec3 p, vec3 n, Ray eye) {\n    Ray reflectedRay = Ray(p + n * Epsilon, reflect(eye.d, n));\n    float t;\n    int s, c;\n    if (SphereTrace(reflectedRay, 100., t, s, c)) {\n        vec3 hitPoint = Point(reflectedRay, t);\n        vec3 hitNormal = ObjectNormal(hitPoint);\n        return Shade(hitPoint, hitNormal, reflectedRay);\n    }\n    return background(reflectedRay);\n}\n\nvec3 MarbleShadeWithReflection(vec3 p, vec3 n, Ray eye, float reflectivity) {\n    // Apply basic shading and marble texture\n    vec3 baseColor = Shade(p, n, eye);\n    float marblePattern = Marble(p, 1.0, 5, 0.6);  // Adjust for your desired marble effect\n\n    // Mix base color with marble pattern\n    vec3 marbleColor = mix(baseColor, vec3(1.0, 0.9, 0.8), marblePattern); // Adjust color for marble veins\n\n    // Add reflection effect\n    vec3 reflectedColor = ReflectColor(p, n, eye);\n\n    // Blend marble and reflection based on reflectivity\n    return mix(marbleColor, reflectedColor, reflectivity);\n}\n\n\nvec3 ShadeWithReflection(vec3 p, vec3 n, Ray eye, float reflectivity) {\n    vec3 baseColor = Shade(p, n, eye);\n    vec3 reflectedColor = ReflectColor(p, n, eye);\n    return mix(baseColor, reflectedColor, reflectivity);\n}\n\n//Image\nvoid mainImage(out vec4 color, in vec2 pxy) {\n    vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    Ray ray = CreateRay(m, pixel);\n    float t = 0.0;\n    int s = 0;\n    int c;\n    bool hit = SphereTrace(ray, 100., t, s, c);\n    vec3 rgb = background(ray);\n    if (hit) {\n        vec3 p = Point(ray, t);\n        vec3 n = ObjectNormal(p);\n        vec3 viewDir = normalize(ray.o - p);\n\n        // Define light sources\n        Light light1;\n        light1.position = vec3(10.0, 10.0, 10.0);\n        light1.color = vec3(0.0, 0.0, 1.0);\n        light1.isDirectional = false;\n\n        Light light2;\n        light2.position = vec3(-1.0, -1.0, -1.0);\n        light2.color = vec3(0.5, 1.0, 0.0);\n        light2.isDirectional = true;\n\n        // Phong illumination\n        vec3 ambientColor = vec3(0.1, 0.1, 0.1);\n        vec3 diffuseColor = vec3(0.8, 0.8, 0.8);\n        vec3 specularColor = vec3(1.0, 1.0, 1.0);\n        float shininess = 32.0;\n\n        vec3 phongColor = vec3(0.5);\n        phongColor += PhongIllumination(p, n, viewDir, light1, ambientColor, diffuseColor, specularColor, shininess);\n        phongColor += PhongIllumination(p, n, viewDir, light2, ambientColor, diffuseColor, specularColor, shininess);\n\n        // Shadows\n        if (IsInShadow(p, normalize(light1.position - p), length(light1.position - p))) {\n            phongColor *= 0.5;\n        }\n        if (IsInShadow(p, normalize(light2.position), 100.0)) {\n            phongColor *= 0.5;\n        }\n\n        // Ambient occlusion\n        float ao = AmbientOcclusion(p, n);\n        phongColor *= ao;\n\n        // Reflection\n        vec3 reflection = ReflectColor(p, n, ray);\n        phongColor = mix(phongColor, reflection, 0.3);\n\n        rgb = phongColor;\n    }\n    color = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}