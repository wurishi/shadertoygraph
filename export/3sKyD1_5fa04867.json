{"ver":"0.1","info":{"id":"3sKyD1","date":"1602876811","viewed":175,"name":"Your pixels are breathing","username":"Quinchilion","description":"A simple cellular automata simulation. Each cell wants to orient itself as close as it can to its neighbors. The fun was in the polishing of the idea - hiding grid artifacts, adding some randomness and of course the visuals.\nClick to randomize an area","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["2d","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 colormap[32] = vec2[](\n    vec2(0.18062, 0.13244), vec2(0.28659, 0.10560), vec2(0.39160, 0.14210), vec2(0.48191, 0.18751),\n    vec2(0.57057, 0.22542), vec2(0.66943, 0.24982), vec2(0.77286, 0.26494), vec2(0.86794, 0.28430),\n    vec2(0.93769, 0.33352), vec2(0.97216, 0.42130), vec2(0.98453, 0.51799), vec2(0.98736, 0.60758),\n    vec2(0.98630, 0.68916), vec2(0.98702, 0.76315), vec2(0.98875, 0.83206), vec2(0.98105, 0.89458),\n    vec2(0.94377, 0.93236), vec2(0.87014, 0.92815), vec2(0.78036, 0.89925), vec2(0.68710, 0.86514),\n    vec2(0.59134, 0.83035), vec2(0.49106, 0.79508), vec2(0.38239, 0.75922), vec2(0.26717, 0.72137),\n    vec2(0.19593, 0.67703), vec2(0.22381, 0.62348), vec2(0.26346, 0.56501), vec2(0.26997, 0.50576),\n    vec2(0.24161, 0.44609), vec2(0.19367, 0.38234), vec2(0.16005, 0.30712), vec2(0.14312, 0.21800)\n);\n\nvec3 cellVecToColor(vec2 cellVec)\n{\n    float phase = atan(cellVec.y, cellVec.x) / (2.0 * PI) + 0.5;\n    phase = fract(phase * 2.0);\n    \n    float p = phase * 31.9999;\n    int i0 = int(floor(p));\n    int i1 = i0 == 31 ? 0 : i0 + 1;\n    float f = p - float(i0);\n    \n    vec2 c0 = colormap[i0];\n    vec2 c1 = colormap[i1];\n    \n    vec3 c = vec3(mix(c0, c1, f), 0.0);\n    c.b = sqrt(max(1.0 - c.r - c.g, 0.0));\n    return clamp(c, 0.0, 1.0);\n}\n\nfloat aaRectangle(vec2 offset, vec2 size, float pixelSize)\n{\n    size += pixelSize / 2.0;\n\tfloat wx = clamp((size.x + offset.x) / pixelSize, 0.0, 1.0) * clamp((size.x - offset.x) / pixelSize, 0.0, 1.0);\n    float wy = clamp((size.y + offset.y) / pixelSize, 0.0, 1.0) * clamp((size.y - offset.y) / pixelSize, 0.0, 1.0);\n    return wx * wy;\n}\n\nfloat henyeyGreenstein(float cosTheta, float g)\n{\n\tfloat num = (1.0 - g) * (1.0 - g) * (1.0 - g);\n    float denom = sqrt(1.0 + g * g - 2.0 * g * cosTheta);\n    return num / (denom * denom * denom);\n}\n\nvec4 drawCell(vec2 cellCoord, vec2 coord, float pixelSize)\n{\n    vec2 texelSize = 1.0 / vec2(textureSize(iChannel0, 0));\n    vec2 pickRot = vec2(cos(iTime), sin(iTime));\n    \n    vec4 cell = texture(iChannel0, cellCoord * texelSize);\n    float pickCos = dot(pickRot, cell.zw);\n\n    float cellSize = 0.333 + 0.666 * henyeyGreenstein(pickCos, 0.2);\n    float cellBrightness = 1.0 + henyeyGreenstein(pickCos, 0.9);\n    \n    vec2 offset = (coord - cellCoord + cell.xy) / cellSize;\n    pixelSize /= cellSize;\n    \n    mat2 rotMat = mat2(cell.z, cell.w, -cell.w, cell.z);\n    vec2 rotOffset = rotMat * offset;\n    \n    vec3 rects = vec3(\n        aaRectangle(rotOffset + vec2( 0.666, 0.0), vec2(0.333, 1.0), pixelSize),\n        aaRectangle(rotOffset + vec2(   0.0, 0.0), vec2(0.333, 1.0), pixelSize),\n        aaRectangle(rotOffset + vec2(-0.666, 0.0), vec2(0.333, 1.0), pixelSize)\n    );\n    \n    float alpha = min(dot(rects, vec3(1.0 / 3.0)), 1.0);\n    \n    vec3 cellColor = pow(cellVecToColor(cell.zw), vec3(2.2));\n    vec3 color = cellColor * rects * cellBrightness;\n    \n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera magic\n    float pixelSize = getPixelSize(iTime);\n    vec2 coord = getWorldCoord(fragCoord, iResolution.xy, iTime);\n    \n    // Draw nearest cells\n    vec4 colorAccum = vec4(0.0, 0.0, 0.0, 1.0);\n    for (int y = -2; y <= 2; y++)\n        for (int x = -2; x <= 2; x++)\n        {\n            vec2 cellCoord = floor(coord) + vec2(x, y);\n            vec4 cellColor = drawCell(cellCoord, coord, pixelSize);\n            colorAccum += cellColor;\n        }\n    \n    vec3 color = colorAccum.rgb / colorAccum.a;\n    fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0); \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float TargetStep = 0.01;\nfloat RandomStep = 0.005;\nfloat PositionStep = 0.001;\n\n// Taken from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 timeContinuousHash(vec2 p, float t)\n{\n\tvec2 h0 = hash23(vec3(p, floor(t)));\n    vec2 h1 = hash23(vec3(p, floor(t) + 1.0));\n    return mix(h0, h1, fract(t));\n}\n\nvec2 safeNormalize(vec2 vec)\n{\n    float d2 = dot(vec, vec);\n    return d2 <= 1.0e-8 ? vec2(1.0, 0.0) : vec / sqrt(d2);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 coord)\n{\n    vec2 texelSize = 1.0 / vec2(textureSize(iChannel0, 0));\n\n    vec4 cell = texture(iChannel0, coord * texelSize);\n    \n    bool randomize = cell == vec4(0.0, 0.0, 0.0, 0.0);\n    // Reinitialize also on mouse click\n    if (iMouse.z > 0.0)\n    {\n        float pixelSize = getPixelSize(iTime);\n        vec2 clickCoord = getWorldCoord(iMouse.xy, iResolution.xy, iTime);\n        float clickDist = length(mod(clickCoord, iResolution.xy) - coord);\n        if (clickDist < 10.0)\n            randomize = true;\n    }\n    \n    if (randomize)\n    {\n        vec2 cellOffset = hash23(vec3(-coord, iTime));\n        vec2 cellVec = safeNormalize(hash23(vec3(coord, iTime)) * 2.0 - 1.0);\n        \n        fragColor = vec4(cellOffset, cellVec);\n        return;\n    }\n    \n    vec2 cellOffset = cell.xy;\n    vec2 cellPos = coord + cellOffset;\n    vec2 cellVec = cell.zw;\n    \n    vec3 vecSum = vec3(0.0, 0.0, 1.0e-6);\n    vec2 forceSum = vec2(0.0);\n    \n    // Sample circle of radius 2\n    for (int i = -2; i <= 2; i++)\n        for (int j = -2; j <= 2; j++)\n        {\n            if (i == 0 && j == 0) continue;\n            \n            vec2 neighborCoord = coord + vec2(i, j);\n            vec4 neighbor = texture(iChannel0, neighborCoord * texelSize);\n            vec2 neighborPos = neighborCoord + neighbor.xy;\n            vec2 neighborVec = neighbor.zw;\n            \n            float distanceToCell = length(cellPos - neighborPos);\n            float weight = max(2.0 - distanceToCell, 0.0);\n            \n            vecSum += weight * vec3(neighborVec, 1.0);\n            forceSum += weight * safeNormalize(cellPos - neighborPos);\n        }\n    \n    // Update \"breathing\" rotation vector\n    vec2 targetVec = safeNormalize(vecSum.xy / vecSum.z);\n    vec2 randomVec = safeNormalize(timeContinuousHash(coord, iTime) * 2.0 - 1.0);\n    float simSpeedMult = 11.0 - 10.0 * getSimulationScale(iTime);\n    cellVec = safeNormalize(cellVec + targetVec * TargetStep * simSpeedMult + randomVec * RandomStep);\n    \n    // Update position of the cell\n    cellOffset = clamp(cellOffset + forceSum * PositionStep, 0.01, 0.99);\n    \n    fragColor = vec4(cellOffset, cellVec);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float PI = 3.141592653589793;\n\nfloat getSimulationScale(float time)\n{\n    return cos(PI * (time - 10.0) / 120.0);\n}\n\nfloat getPixelSize(float time)\n{\n\treturn 1.0 / (8.0 + 6.0 * getSimulationScale(time));\n}\n\nvec2 getWorldCoord(vec2 fragCoord, vec2 resolution, float time)\n{\n    float pixelSize = getPixelSize(time);\n    float camRotAngle = PI * time / 75.0;\n    float rotRadius = 1000.0 * pixelSize;\n    vec2 camOffset = vec2(sin(camRotAngle), cos(camRotAngle)) * rotRadius;\n    \n    return camOffset + (fragCoord - resolution / 2.0) * pixelSize;\n}","name":"Common","description":"","type":"common"}]}