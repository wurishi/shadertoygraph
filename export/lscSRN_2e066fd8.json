{"ver":"0.1","info":{"id":"lscSRN","date":"1458082404","viewed":337,"name":"mobius transform","username":"roywig","description":"draft","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159;\nconst float pi2 = 2.0*3.14159;\n\nconst float WIDTH = 500.0;\nconst float HEIGHT = WIDTH /2.0;\n\n//https://github.com/mkovacs/reim/blob/master/reim.glsl\n\nvec2 cConj(vec2 c)\n{\n    return vec2(c.x, -c.y);\n}\nfloat cReal(vec2 c)\n{\n    return c.x;\n}\nvec2 complex(float r, float i){\n    return vec2(r,i);\n}\nfloat cImag(vec2 c)\n{\n    return c.y;\n}\nvec2 cNeg(vec2 c)\n{\n    return -c;\n}\nvec2 cInv(vec2 c)\n{\n    return cConj(c) / dot(c, c);\n}\nvec2 cMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y,\n                a.x*b.y + a.y*b.x);\n}\nvec2 cDiv(vec2 a, vec2 b)\n{\n    return cMul(a, cInv(b));\n}\n\nvec2 cCis(float r)\n{\n  return vec2( cos(r), sin(r) );\n}\n\nfloat cArg(vec2 c)\n{\n  return atan(c.y, c.x);\n}\n\nfloat cAbs(vec2 c)\n{\n  return length(c);\n}\nvec2 cCish(float r)\n{\n  vec2 e = vec2( exp(r), exp(-r) );\n  return vec2(e.x + e.y, e.x - e.y);\n}\nvec2 cExp(vec2 c)\n{\n  return exp(c.x) * cCis(c.y);\n}\n\nvec2 cLog(vec2 c)\n{\n  return vec2( log( cAbs(c) ), cArg(c) );\n}\nstruct CP1_coord {\n    vec2 z1;\n    vec2 z2;\n};\nstruct CP1_mat {\n    mat2 real;\n    mat2 imag;\n};\n\nCP1_mat sub(CP1_mat a, CP1_mat b){\n    return CP1_mat(a.real-b.real, a.imag-b.imag);\n}\n\nCP1_mat make_CP1_mat(vec2 p,vec2 q,vec2 r,vec2 s) {\n    return CP1_mat(mat2(p[0],q[0],\n                        r[0],s[0]),\n                   mat2(p[1],q[1],\n                        r[1],s[1]));\n}\nvoid get_CP(in CP1_mat M, out vec2 a, out vec2 b,out vec2 c,out vec2 d){\n    a = vec2(M.real[0][0], M.imag[0][0]);\n    b = vec2(M.real[0][1], M.imag[0][1]);\n    c = vec2(M.real[1][0], M.imag[1][0]);\n    d = vec2(M.real[1][1], M.imag[1][1]);\n}\n\nCP1_mat matrix_mult(CP1_mat A, CP1_mat B){\n    vec2 a,b,c,d,e,f,g,h;\n    get_CP(A,a,b,c,d);\n    get_CP(B,e,f,g,h);\n    \n    return make_CP1_mat(\n        cMul(a,e) + cMul(b,g), cMul(a,f) + cMul(b,h),\n        cMul(c,e) + cMul(d,g), cMul(c,f) + cMul(d,h)\n    );\n}\n\nCP1_mat matrix_mult(CP1_mat a, vec2 b){\n    vec2 a_0_0,a_0_1, a_1_1, a_1_0;\n    get_CP(a,a_0_0,a_0_1,a_1_0,a_1_1);\n\n    return make_CP1_mat(cMul(a_0_0,b), cMul(a_1_0,b),\n                        cMul(a_0_1,b), cMul(a_1_1,b));\n}\n\nvoid matrix_mult(CP1_mat A, vec2 b1, vec2 b2, out vec2 out1, out vec2 out2){\n    vec2 a,b,c,d;\n    get_CP(A,a,b,c,d);\n\n    out1 = cMul(a,b1) + cMul(b,b2);\n    out2 = cMul(c,b1) + cMul(d,b2);\n}\n\nCP1_coord matrix_mult(CP1_mat A, CP1_coord b){\n    vec2 z1,z2;\n    matrix_mult(A, b.z1, b.z2, z1, z2);\n    return CP1_coord(z1,z2);\n}\n\nCP1_mat matrix2_inv(CP1_mat a){\n    vec2 a_0_0,a_0_1, a_1_1, a_1_0;\n    get_CP(a,a_0_0,a_0_1,a_1_0,a_1_1);\n\n    vec2 det = cDiv(vec2(1.0,0),\n                    cMul(a_0_0,a_1_1) - cMul(a_1_0,a_0_1));\n\n    CP1_mat mat = make_CP1_mat( a_1_1, -a_1_0,\n                               -a_0_1,  a_0_0);\n    return matrix_mult(mat,det);\n}\n\n\n\n\nvec4 draw2by2(mat2 mat, vec2 point, vec4 color){\n    float scale = 20.0;\n    point.y = 2. * scale - point.y;\n\n    if (point.x < 0. || point.y < 0.){\n        return vec4(0.,0.,0.,0.);\n    }\n    float val = 0.0;\n    if (point.x < scale && point.y < scale){\n        val = mat[0][0];\n    } else if (point.x < scale*2. && point.y < scale){\n        val = mat[0][1];\n    }else if (point.y < scale*2. && point.x < scale){\n        val = mat[1][0];\n    } else if (point.y < scale*2. && point.x < scale*2.){\n        val = mat[1][1];\n    }\n    if (val < 0.){\n        color = color *-float(mod(point.x,2.0)>1.)-float(mod(point.y,2.0)>1.);\n    }\n    if (val > 1. && (mod(point.x,2.0)>1.)){\n        color.y = val-1.;\n    }\n    return val * color;\n}\n\nvec4 draw(CP1_mat mat, vec2 point){\n    vec4 ret = draw2by2(mat.real,point,vec4(1.,0.,0.,1.));\n    ret += draw2by2(mat.imag,point-vec2(40.,0.),vec4(0.,1.,0.,1.));\n    return ret;\n}\nvec4 draw(CP1_coord pt, vec2 point){\n    vec4 ret = draw2by2(mat2(vec2(pt.z1.x,0.), vec2(pt.z2.x,0.)),point,vec4(1.,0.,0.,1.));\n    ret += draw2by2(mat2(vec2(pt.z1.y,0.), vec2(pt.z2.y,0.)),point-vec2(20.,0.),vec4(0.,1.,0.,1.));\n    return ret;\n}\nvec4 testInvertMatrix(vec2 fragCoord){\n    CP1_mat mat = make_CP1_mat(vec2(1.0,0.2),vec2(1.0,.4),\n                               vec2(0.6,0.1),vec2(0.1,.4));\n    CP1_mat inv = matrix2_inv(mat);\n    CP1_mat actual_inv = make_CP1_mat(\n        vec2(-0.0738255,-0.751678), vec2(1.7047,0.993289),\n        vec2(1.0604,0.342282),\t    vec2(-1.75839,-0.630872));\n\n    CP1_mat ident = make_CP1_mat(vec2(1.,0.),vec2(0.,0.),\n                                 vec2(0.,0.),vec2(1.,0.));\n\n    vec4 fragColor = draw(mat,fragCoord.xy);\n    fragColor += draw(inv,fragCoord.xy-vec2(80.,0.));\n    fragColor += draw(actual_inv,fragCoord.xy-vec2(160.,0.));\n    fragColor += draw(sub(inv,actual_inv),fragCoord.xy-vec2(240.,0.));\n    //fragColor += drawCPMatrix(matrix_mult(mat,inv),fragCoord.xy-vec2(160.,0.));\n    //fragColor += drawCPMatrix(sub(matrix_mult(mat,inv),ident),fragCoord.xy-vec2(240.,0.));\n\t\n    return fragColor;\n}\nvec4 testMultMatrix(vec2 fragCoord){\n    CP1_mat mat = make_CP1_mat(vec2(1.0,0.2),vec2(1.0,.4),\n                               vec2(0.6,0.1),vec2(0.1,.4));\n    CP1_mat ident = make_CP1_mat(vec2(1.,0.),vec2(0.,0.),\n                                 vec2(0.,0.),vec2(1.,0.));\n\n    CP1_mat inv = matrix2_inv(mat);\n    vec4 fragColor = draw(matrix_mult(mat,inv),fragCoord.xy-vec2(0.,0.));\n    //fragColor += drawCPMatrix(sub(matrix_mult(mat,inv),ident),fragCoord.xy-vec2(80.,0.));\n    return fragColor;\n}\n\n\nvec2 angles_from_pixel_coords(in vec2 point, in float x_size){\n    //map from pixel coords to (0, 2*pi) x (-pi/2, pi/2) rectangle\"\"\"\n    float y_size = x_size/2.0;  //assume equirectangular format\n    return vec2(point[0] * 2.0*pi/x_size, \n                point[1] * pi/(y_size-1.0) - 0.5*pi);\n}\n\n\nvec2 pixel_coords_from_angles(in vec2 point, in float x_size){\n    //map from (0, 2*pi) x (-pi/2, pi/2) rectangle to pixel coords\"\"\"\n    float y_size = x_size/2.0;  //assume equirectangular format\n    return vec2(point[0] * float(x_size)/(2.0*pi), (point[1] + 0.5*pi)* float(y_size-1.0)/pi);\n}\n\n\nvec2 angles_from_sphere(in vec3 point){\n    //map from sphere in R^3 to (0, 2*pi) x (-pi/2, pi/2) rectangle (i.e. perform equirectangular projection)\"\"\"\n    float longitude = atan(point.y,point.x);\n    if (longitude < 0.0){\n        longitude = longitude + pi2;\n    }\n    float r = sqrt(point.x*point.x+point.y*point.y);\n    float latitude = atan(point.z,r);\n    return vec2(longitude, latitude);\n}\n\nvec3 sphere_from_angles(in vec2 point){\n    //map from (0, 2*pi) x (-pi/2, pi/2) rectangle to sphere in R^3 (i.e. perform inverse of equirectangular projection)\"\"\"\n    float horiz_radius = cos(point.y);\n    \n    return vec3(horiz_radius*cos(point.x), \n                horiz_radius*sin(point.x),\n                sin(point.y));\n}\n\nCP1_coord CP1_from_sphere(in vec3 point) {\n    //map from sphere in R^3 to CP^1\"\"\"\n    if (point.z < 0.0){\n        return CP1_coord(vec2(point.x,point.y), vec2(1.0-point.z,0));\n    }     else{\n        return CP1_coord(vec2(1.0+point.z,0.0), vec2(point.x,-point.y));\n    }\n}\n\n\nvec3 sphere_from_CP1(in CP1_coord point){\n    //map from CP^1 to sphere in R^3\"\"\"\n    if (length(point.z2) > length(point.z1)){\n        vec2 z = cDiv(point.z1,point.z2);\n        vec2 tmp = vec2(z.x, z.y); // x is real, y imag\n        float denom = 1.0 + z.x*z.x + z.y*z.y;\n        return vec3(2.0*z.x/denom, 2.0*z.y/denom, (denom - 2.0)/denom);\n    } else {\n        vec2 z = cConj(cDiv(point.z2,point.z1));\n        float denom = 1.0 + z.x*z.x + z.y*z.y;\n        return vec3(2.0*z.x/denom, 2.0*z.y/denom, (2.0 - denom)/denom);\n    }\n}\n\nvec2 clampf(in vec2 point, in float x_size){\n    //clamp to size of input, including wrapping around in the x direction\"\"\" \n    float y_size = x_size/2.0;      // assume equirectangular format\n    vec2 ret = vec2(mod(point.x,x_size), point.y);\n    if (point.y < 0.0){\n        ret.y = 0.0;\n    } else if ( point.y > y_size - 1.0) {\n        ret.y = y_size - 1.0;\n    } \n    return ret;\n}\nvec3 sphere_from_pixel_coords(in vec2 point, in float x_size){\n    //map from pixel coords to sphere in R^3\"\"\"\n    return sphere_from_angles(angles_from_pixel_coords(point, x_size));\n}\n\nvec4  get_pixel_colour(in vec2 pt, float x_size){\n    //given pt in integers, get pixel colour on the source image as a vector in the colour cube\"\"\"\n    vec2 point = clampf(pt, x_size);\n    return texture(iChannel0, point.xy / iChannelResolution[0].xy);\n}\n\nvec4  get_interpolated_pixel_colour(in vec2 pt, float x_size){\n    return get_pixel_colour(pt,x_size);\n}\n\n\nCP1_mat inf_zero_one_to_triple(CP1_coord p,CP1_coord q,CP1_coord r){\n    //\"\"\"returns SL(2,C) matrix that sends the three points infinity, zero, one to given input points p,q,r\"\"\"\n    //### infinity = [1,0], zero = [0,1], one = [1,1] in CP^1\n    CP1_mat M = make_CP1_mat(p.z1,q.z1,\n                             p.z2,q.z2);\n    CP1_mat Minv = matrix2_inv(M);\n    vec2 mu, lam;\n    matrix_mult(Minv,r.z1,r.z2,mu,lam);\n    return make_CP1_mat(cMul(mu,p.z1), cMul(lam,q.z1),\n                        cMul(mu,p.z2), cMul(lam,q.z2));\n}\nCP1_mat two_triples_to_SL(CP1_coord a1,CP1_coord b1,CP1_coord c1,CP1_coord a2,CP1_coord b2,CP1_coord c2){\n    //\"\"\"returns SL(2,C) matrix that sends the three CP^1 points a1,b1,c1 to a2,b2,c2\"\"\"\n    return matrix_mult( inf_zero_one_to_triple(a2,b2,c2), matrix2_inv(inf_zero_one_to_triple(a1,b1,c1) ) ) ;\n}\n\nCP1_mat three_points_to_three_points_pixel_coords(vec2 p1, vec2 q1, vec2 r1, vec2 p2, vec2 q2, vec2 r2, float x_size){\n    //  \"\"\"returns SL(2,C) matrix that sends the three pixel coordinate points a1,b1,c1 to a2,b2,c2\"\"\"\n    CP1_coord p1_ = CP1_from_sphere(sphere_from_pixel_coords(p1,x_size));\n    CP1_coord q1_ = CP1_from_sphere(sphere_from_pixel_coords(q1,x_size));\n    CP1_coord r1_ = CP1_from_sphere(sphere_from_pixel_coords(r1,x_size));\n    CP1_coord p2_ = CP1_from_sphere(sphere_from_pixel_coords(p2,x_size));\n    CP1_coord q2_ = CP1_from_sphere(sphere_from_pixel_coords(q2,x_size));\n    CP1_coord r2_ = CP1_from_sphere(sphere_from_pixel_coords(r2,x_size));\n\n    return two_triples_to_SL(p1_,q1_,r1_,p2_,q2_,r2_);\n}\n\nvec3 get_vector_perp_to_p_and_q(vec3 p, vec3 q){\n    //\"\"\"p and q are distinct points on sphere, return a unit vector perpendicular to both\"\"\"\n    if (abs(dot(p,q) + 1.0) < 0.0001){ //### deal with the awkward special case when p and q are antipodal on the sphere\n        if (abs(dot(p, vec3(1.0,0.0,0.0))) > 0.9999){ //#p is parallel to (1,0,0)\n            return vec3(0.0,1.0,0.0);\n        } else {\n            return normalize(cross(p, vec3(1.0,0.0,0.0)));\n        }\n    } else {\n        return normalize(cross(p, q));\n    }\n}\n\nCP1_mat rotate_sphere_points_p_to_q(vec3 p, vec3 q){\n    //\"\"\"p and q are points on the sphere, return SL(2,C) matrix rotating image of p to image of q on CP^1\"\"\"\n\n    CP1_coord CP1p = CP1_from_sphere(p);\n    CP1_coord CP1q = CP1_from_sphere(q);\n\n    if (abs(dot(p,q) - 1.0) < 0.0001){\n        return make_CP1_mat(vec2(1.0,0.0),vec2(0.0,0.0),\n                            vec2(0.0,0.0),vec2(1.0,0.0));\n    } else {\n        vec3 r = get_vector_perp_to_p_and_q(p, q);\n        CP1_coord CP1r = CP1_from_sphere(r);\n        CP1_coord CP1mr =  CP1_from_sphere(-r);\n        return two_triples_to_SL(CP1p, CP1r, CP1mr, CP1q, CP1r, CP1mr) ;\n    }\n}\n\nCP1_mat rotate_pixel_coords_p_to_q(vec2 p_, vec2 q_, float x_size){\n    //\"\"\"p and q are pixel coordinate points, return SL(2,C) matrix rotating image of p to image of q on CP^1\"\"\"\n    vec3 p = sphere_from_pixel_coords(p_, x_size);\n    vec3 q = sphere_from_pixel_coords(q_, x_size);\n    return rotate_sphere_points_p_to_q(p,q);\n}\n\nCP1_mat rotate_around_axis_sphere_points_p_q(vec3 p,vec3 q, float theta){\n    //\"\"\"p and q are points on sphere, return SL(2,C) matrix rotating by angle theta around the axis from p to q\"\"\"\n    CP1_coord CP1p = CP1_from_sphere(p);\n    CP1_coord CP1q = CP1_from_sphere(q);\n    //assert dot(p,q) < 0.9999, \"axis points should not be in the same place!\"\n    vec3 r = get_vector_perp_to_p_and_q(p, q);\n    CP1_coord CP1r = CP1_from_sphere(r);\n    CP1_mat M_standardise = two_triples_to_SL(CP1p, CP1q, CP1r,\n                                              CP1_coord(vec2(0.0,0.0),vec2(1.0,0.0)),\n                                              CP1_coord(vec2(1.0,0.0),vec2(0.0,0.0)),\n                                              CP1_coord(vec2(1.0,0.0),vec2(1.0,0.0)));\n    CP1_mat M_theta = make_CP1_mat(vec2(cos(theta),sin(theta)),vec2(0.0,0.0),\n                                   vec2(0.0,0.0),vec2(1.0,0.0));// #rotate on axis through 0, infty by theta\n    return matrix_mult( matrix_mult(matrix2_inv(M_standardise), M_theta), M_standardise );\n}\n\nCP1_mat rotate_around_axis_pixel_coords_p_q(vec2 p_,vec2 q_, float theta, float x_size){\n    //\"\"\"p and q are pixel coordinate points, return SL(2,C) matrix rotating by angle theta around the axis from p to q\"\"\"\n    \n\n    vec3 p = sphere_from_pixel_coords(p_, x_size);\n    vec3 q = sphere_from_pixel_coords(q_, x_size);\n    return rotate_around_axis_sphere_points_p_q(p,q,theta);\n}\nCP1_mat rotate_around_axis_pixel_coord_p(vec2 p_,float theta, float x_size){\n    //\"\"\"p is a pixel coordinate point, return SL(2,C) matrix rotating by angle theta around the axis from p to its antipode\"\"\"\n    vec3 p = sphere_from_pixel_coords(p_, x_size);\n    vec3 minus_p = -p;\n    return rotate_around_axis_sphere_points_p_q(p,minus_p,theta);\n}\n\nCP1_mat zoom_in_on_pixel_coords(vec2 p, float zoom_factor, float x_size){\n    //\"\"\"p is pixel coordinate point, return SL(2,C) matrix zooming in on p by a factor of scale\"\"\"\n    //# Note that the zoom factor is only accurate at the point p itself. As we move away from p, we zoom less and less.\n    //# We zoom with the inverse zoom_factor towards/away from the antipodal point to p.\n    CP1_mat M_rot = rotate_pixel_coords_p_to_q( p, vec2(0.0,0.0), x_size);\n    CP1_mat M_scl = make_CP1_mat(vec2(zoom_factor,0.0),vec2(0.0,0.0),\n                                 vec2(0.0,0.0),\t\t vec2(1.0,0.0)); //### zoom in on zero in CP^1\n    return matrix_mult( matrix_mult(matrix2_inv(M_rot), M_scl), M_rot );\n}\n\nCP1_mat zoom_along_axis_sphere_points_p_q(vec3 p, vec3 q, float zoom_factor){\n    //\"\"\"p and q are points on sphere, return SL(2,C) matrix zooming along axis from p to q\"\"\"\n    CP1_coord CP1p = CP1_from_sphere(p);\n    CP1_coord CP1q = CP1_from_sphere(q);\n    //assert dot(p,q) < 0.9999   #points should not be in the same place\n    vec3 r = get_vector_perp_to_p_and_q(p, q);\n    CP1_coord CP1r = CP1_from_sphere(r);\n    CP1_mat M_standardise = two_triples_to_SL(CP1p, CP1q, CP1r,\n                                              CP1_coord(vec2(0.0,0.0),vec2(1.0,0.0)),\n                                              CP1_coord(vec2(1.0,0.0),vec2(0.0,0.0)),\n                                              CP1_coord(vec2(1.0,0.0),vec2(1.0,0.0)));\n    CP1_mat M_theta = make_CP1_mat(vec2(zoom_factor,0.0),vec2(0.0,0.0),\n                                   vec2(0.0,0.0),\t\t vec2(1.0,0.0)); \n    return matrix_mult( matrix_mult(matrix2_inv(M_standardise), M_theta), M_standardise );\n}\nCP1_mat zoom_along_axis_pixel_coords_p_q(vec2 p_, vec2 q_, float zoom_factor, float x_size){\n    //\"\"\"p and q are pixel coordinate points, return SL(2,C) matrix zooming along axis from p to q by zoom_factor\"\"\"\n    //# This function does the same thing as zoom_in_on_pixel_coords, but with the \n    //# two given points instead of a single point and its antipodal point\n    vec3 p = sphere_from_pixel_coords(p_, x_size);\n    vec3 q = sphere_from_pixel_coords(q_, x_size);\n    return zoom_along_axis_sphere_points_p_q(p,q,zoom_factor);\n}\n\nCP1_mat translate_along_axis_pixel_coords(vec2 p, vec2 q, vec2 r1, vec2 r2, float x_size){\n    //\"\"\"Return SL(2,C) matrix translating/rotating on the axis from p to q, taking r1 to r2\"\"\"\n    return three_points_to_three_points_pixel_coords(p,q,r1,p,q,r2, x_size);\n}\n\nvec2 apply_SL2C_elt_to_pt(CP1_mat M, vec2 pt_){\n    CP1_mat Minv = matrix2_inv(M);\n    vec2 pt = angles_from_pixel_coords(pt_, WIDTH);\n    vec3 pt2 = sphere_from_angles(pt);\n    CP1_coord pt3 = CP1_from_sphere(pt2);\n    vec2 outa, outb;\n    matrix_mult(Minv, pt3.z1,pt3.z2,outa,outb);\n    CP1_coord pt4 = CP1_coord(outa,outb);\n    vec3 pt5 = sphere_from_CP1(pt4);\n    vec2 pt6 = angles_from_sphere(pt5);\n    return pixel_coords_from_angles(pt6, WIDTH);\n}\nvec2 droste_effect(vec2 pt_,vec2 zoom_center_pixel_coords, float zoom_factor, float zoom_cutoff,\n                   bool twist,float zoom_loop_value,float out_x_size){\n    CP1_mat M_rot = rotate_pixel_coords_p_to_q(zoom_center_pixel_coords, vec2(0.,0.), out_x_size);\n\tCP1_mat M_rot_inv = matrix2_inv(M_rot);\n    \n    vec2 droste_factor = cDiv(cLog(complex(zoom_factor,0.)) + vec2(0., 2.*pi) , vec2(0., 2.*pi));\n    \n    vec2 pt = angles_from_pixel_coords(pt_, out_x_size);\n    vec3 pt2 = sphere_from_angles(pt);\n    CP1_coord pt3 = CP1_from_sphere(pt2);\n    pt3 = matrix_mult(M_rot, pt3);\n    \n    pt = cDiv(pt3.z1,pt3.z2);\n    pt = cLog(pt);\n    if (twist){//:  # otherwise straight zoom\n        pt = cMul(droste_factor,pt);\n    }\n    pt = complex(\n        cReal(pt) + log(zoom_factor) * zoom_loop_value,\n        cImag(pt)\n    ); \n    pt = complex(\n        mod(cReal(pt) + zoom_cutoff, log(zoom_factor)) - zoom_cutoff,\n        cImag(pt)\n    );\n    pt = cExp(pt);\n    pt3 = CP1_coord(\n        \tpt,\n        \tvec2(1.,0.)\n        );// #back to projective coordinates\n    pt3 = matrix_mult(M_rot_inv, pt3);\n    pt2 = sphere_from_CP1(pt3);\n    pt = angles_from_sphere(pt2);\n\n    return pixel_coords_from_angles(pt, out_x_size);;\n}\n\nvec4 testpattern(vec2 fragCoord){\n    vec2 sphere = angles_from_sphere(sphere_from_angles(angles_from_pixel_coords(\n        pixel_coords_from_angles(\n            angles_from_sphere(\n                sphere_from_CP1(\n                    CP1_from_sphere(\n                        sphere_from_pixel_coords(fragCoord.xy,WIDTH)))),WIDTH),WIDTH)));\n    return vec4(sphere.x/(2.*pi),(sphere.y+pi/2.)/pi,0.0,1.0);\n}\nvec2 demo1(vec2 fragCoord){\n    vec2 center = iMouse.xy;//vec2(220.,150.);\n    /*if (distance(fragCoord,center) < 5.){\n        return vec4(1.0,1.0,0.0,1.0);\n    }*/\n    CP1_mat transform = rotate_around_axis_pixel_coord_p(center,iTime,WIDTH);\n\tvec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);\n\treturn outpt;\n}\n\nvec2 demo2(vec2 fragCoord){\n    vec2 center = iMouse.xy;//vec2(220.,150.);\n    /*if (distance(fragCoord,center) < 5.){\n        return vec4(1.0,1.0,0.0,1.0);\n    }*/\n    // TODO: Something's pretty wrong with this\n    CP1_mat transform = zoom_in_on_pixel_coords(iMouse.xy,3.,WIDTH);\n\tvec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);\n\treturn outpt;\n}\nvec2 demo3(vec2 fragCoord){\n    vec2 center1 = vec2(iMouse.xy);\n    vec2 center2 = vec2(iMouse.x + 100.,iMouse.y);\n    /*if (distance(fragCoord,center1) < 5. || distance(fragCoord,center2) < 5.){\n        return vec4(1.0,1.0,0.0,1.0);\n    }*/\n    CP1_mat transform = rotate_around_axis_pixel_coords_p_q(center1,center2,iTime,WIDTH);\n\tvec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);\n\treturn outpt;\n}\n\nvec2 demo4(vec2 fragCoord){\n    vec2 center = iMouse.xy;//vec2(220.,150.);\n    /*if (distance(fragCoord,center) < 5.){\n        return vec2(1.0,1.0,0.0,1.0);\n    }*/\n    CP1_mat transform = rotate_pixel_coords_p_to_q(vec2(WIDTH/2.,HEIGHT/2.), center,WIDTH);\n    vec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);\n    return outpt;\n}\nvec2 demo5(vec2 fragCoord){\n    vec2 center = vec2(iMouse.x,HEIGHT/2.);\n    return droste_effect(\n        fragCoord,center, 7.*iMouse.y/HEIGHT + 1.3,1., false, 13.0, WIDTH);\n\n}\nvec4 getpx(vec2 pt){\n        return texture(iChannel0,pt / iChannelResolution[0].xy);\n}\nvec2 demo(vec2 c){\n    int nDemos = 5;\n    float tEach = 20.;\n    float time = mod(iTime, float(nDemos) * tEach);\n    if (time < tEach){\n        return demo1(c);\n    }\n    if (time > tEach && time < tEach*2.){\n        return demo2(c);\n    }\n    if (time > tEach*2. && time < tEach*3.){\n        return demo3(c);\n    }\n    if (time > tEach*3. && time < tEach*4.){\n        return demo4(c);\n    }\n    if (time > tEach*4. && time < tEach*5.){\n        return demo5(c);\n    }\n    return vec2(0.,0.);\n}\nvoid test(in vec2 pt, out vec4 fragColor){\n    vec3 p = vec3(1.0,0.0,0.0);\n    vec3 q = vec3(0.0,0.0,-1.0);\n    CP1_coord CP1p = CP1_from_sphere(p);\n    CP1_coord CP1q = CP1_from_sphere(q);\n    \n    vec3 r = get_vector_perp_to_p_and_q(p, q);\n    CP1_coord CP1r = CP1_from_sphere(r);\n    CP1_coord CP1mr =  CP1_from_sphere(-r);\n    \n\n    CP1_mat term1 = inf_zero_one_to_triple(CP1q,CP1r,CP1mr);\n\t//-------\n    CP1_mat M = make_CP1_mat(CP1q.z1,CP1r.z1, // this is fine\n                             CP1q.z2,CP1r.z2);\n    CP1_mat Minv = matrix2_inv(M);\n    vec2 mu, lam;\n    CP1_coord mulam = matrix_mult(Minv,CP1mr);\n    CP1_mat term1_2 = make_CP1_mat(cMul(mulam.z1,CP1q.z1), cMul(mulam.z2,CP1r.z1),\n                        \t\t   cMul(mulam.z1,CP1q.z2), cMul(mulam.z2,CP1r.z2));\n\n    //-------\n    \n    CP1_mat term2 = inf_zero_one_to_triple(CP1p,CP1r,CP1mr);\n    CP1_mat mat = matrix_mult( term1, matrix2_inv(term2));\n\t\n    \n    fragColor = draw(term1_2,pt);\n}\n\nvec2 camera(in vec2 pt){\n    float focalLength = .5;\n    pt = (pt - iResolution.xy / 2.0) / iResolution.xy;\n    \n    vec3 eyeVec = normalize(vec3(focalLength,pt));\n    vec2 angles = angles_from_sphere(eyeVec);\n    //angles.x += .1;\n    //angles.x = mod(angles.x,pi2);\n    return pixel_coords_from_angles(angles,WIDTH);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pt = fragCoord.xy;\n    vec4 checkerboard = texture(iChannel0,uv);\n\n\t\n    CP1_mat outM = inf_zero_one_to_triple(CP1_coord(vec2(1.0,0.0), vec2(0.0,0.0)),\n                                          CP1_coord(vec2(0.0,0.0), vec2(1.0,0.0)),\n                                          CP1_coord(vec2(1.0,0.0), vec2(1.0,0.0)));\n\n    \n    /*fragColor = getpx(demo1(fragCoord));\n    if (fragCoord.x > WIDTH || fragCoord.y>HEIGHT){\n        fragColor = vec4(0.,0.,0.,0.);\n    }*/\n    if (mod(iTime,20.) < 10.){\n\t\tfragColor = getpx(demo(fragCoord));\n    } else {\n        fragColor = getpx(demo(camera(fragCoord)));\n    }\n    //fragColor  += draw(term2,pt-vec2(80.,0));\n\n    /*fragColor  = draw(rotate_pixel_coords_p_to_q(vec2(0,HEIGHT/2.),\n                                                         vec2(0.,0.),WIDTH),pt);\n    */\n\t//fragColor = draw(zoom_in_on_pixel_coords(vec2(WIDTH/2.,HEIGHT/2.),2.,WIDTH),pt);\n\t//fragColor = testpattern(pt);\n    //fragColor = testInvertMatrix(fragCoord);\n\t//fragColor = testMultMatrix(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define S 40. // Scale\n\nconst float WIDTH = 500.0;\nconst float HEIGHT = WIDTH/2.0;\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n\tvec2 uv = floor(S * p.xy * vec2(iResolution.x / iResolution.y, 1) / iResolution.xy);\n\tc = vec4(vec3(mod(uv.x + uv.y, 2.)), 1);\n    if (p.y < HEIGHT/2.){\n        c = c * vec4(0.9,0.,1.,1.);\n    }\n    if (p.x < WIDTH/2.){\n        c = c * vec4(0.,1.,1.,1.);\n    }\n    if (abs(p.y - HEIGHT/2.) <= 1.0) {\n        c = vec4(0.,0.,1.,1.);\n    }\n    if (abs(p.y - 3.*HEIGHT/4.) <= 1.0) {\n        c = vec4(1.,0.,1.,1.);\n    }\n    if (abs(p.y - HEIGHT/4.) <= 1.0) {\n        c = vec4(1.,1.,0.,1.);\n    }\n    if (abs(p.x - WIDTH/4.) <= 1.0) {\n        c = vec4(0.,1.,0.,1.);\n    }\n    if (abs(p.x - 3.*WIDTH/4.) <= 1.0) {\n        c = vec4(0.,1.,0.,1.);\n    }\n    if (abs(p.x - WIDTH/2.) <= 1.0) {  \n        c = vec4(1.,0.,0.,1.);\n    }\n    if (abs(p.x - WIDTH) <= 1.0) {  \n        c = vec4(1.,0.,0.,1.);\n    }\n    if (p.x <= 1.0) {  \n        c = vec4(1.,0.,0.,1.);\n    }\n    if (p.x > WIDTH || p.y > HEIGHT){\n        c = vec4(0.,0.,0.,0.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Cubemap to panorama unwrapping by Morgan McGuire @morgan3d\n// http://casual-effects.com\n\nconst float WIDTH = 500.0;\nconst float HEIGHT = WIDTH /2.0;\n\nconst float pi = 3.1415926536;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 P = fragCoord.xy / vec2(WIDTH,HEIGHT);\n\tfloat theta = (1.0 - P.y) * pi;\n\tfloat phi   = P.x * pi * 2.0;\n\t\n\t// Animate to make this less boring\n\t//phi += iTime;\n\t\n\t// Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = vec3(sin(theta) * sin(phi), -cos(theta), sin(theta) * cos(phi));\n\t\n\t\n\tfragColor = sqrt(texture(iChannel0, dir));\n}","name":"Buffer B","description":"","type":"buffer"}]}