{"ver":"0.1","info":{"id":"ldKfzm","date":"1528184149","viewed":587,"name":"Pokemon Pikachu 3D","username":"lzjseed","description":"Pokemon ball & Pikachu","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["3d","celshading","nintendo","pikachu","pokemon","tooney"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mul(a,b) ((b)*(a))\n#define saturate(a) clamp(a,0.0,1.0)\n\n\nstruct ObjectData\n{\n    float     distance;\n    float     materialId;\n    mat4      world2LocalMatrix;\n};\n\n#define Degree2Raduis(a) ((a) * 3.1415926 / 180.0)\n#define Raduis2Degree(a) ((a) * 180.0 / 3.1415926)\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 p)\n{\n    return vec2(rand(p.xy),rand(p.yx));\n}\n\nfloat SmoothStep_WithPower(float x,float dist,float pownum)\n{\n    return clamp(pow(x / dist,pownum),0.0,1.0);\n}\n\nfloat max2(vec2 a)\n{\n    return max(a.x,a.y);\n}\n\nfloat min2(vec2 a)\n{\n    return min(a.x,a.y);\n}\n\nfloat max3(vec3 a)\n{\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat min3(vec3 a)\n{\n    return min(a.x,min(a.y,a.z));\n}\n\nfloat max4(vec4 a)\n{\n    return max(a.x,max(a.y,max(a.z,a.w)));\n}\n\nfloat min4(vec4 a)\n{\n    return min(a.x,min(a.y,min(a.z,a.w)));\n}\n\nvec3 RGBtoHSV(vec3 arg1)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 P = mix(vec4(arg1.bg, K.wz), vec4(arg1.gb, K.xy), step(arg1.b, arg1.g));\n    vec4 Q = mix(vec4(P.xyw, arg1.r), vec4(arg1.r, P.yzx), step(P.x, arg1.r));\n    float D = Q.x - min(Q.w, Q.y);\n    float E = 1e-10;\n    return vec3(abs(Q.z + (Q.w - Q.y) / (6.0 * D + E)), D / (Q.x + E), Q.x);\n}\n\nvec3 HSVtoRGB(vec3 arg1)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 P = abs(fract(arg1.xxx + K.xyz) * 6.0 - K.www);\n    return arg1.z * mix(K.xxx, clamp(P - K.xxx,0.0,1.0), arg1.y);\n}\n\nvoid sincos(float a,out float si,out float co)\n{\n    si = sin(a);\n    co = cos(a);\n}\n\nmat3 FromQuaternion(vec4 q)\n{\n    mat3 m;\n    vec2 a;\n    sincos(q.w,a.x,a.y);\n\n    m[0] = vec3(a.y + q.x*q.x*(1.0-a.y), q.x*q.y*(1.0-a.y), q.y*a.x);\n    m[1] = vec3(q.x*q.y*(1.0-a.y), a.y + q.y*q.y*(1.0-a.y), -q.x*a.x);\n    m[2] = vec3(-q.y*a.x, q.x*a.x, a.y);\n    \n    return m;\n}\n\nvec3 RotateQuaternion(vec3 p,vec4 q)\n{\n    return mul(FromQuaternion(q),p);\n}\n\nmat3 FromEuler(vec3 ang) \n{   \n    vec2 a1,a2,a3;\n    sincos(Degree2Raduis(ang.x),a1.x,a1.y);\n    sincos(Degree2Raduis(ang.y),a2.x,a2.y);\n    sincos(Degree2Raduis(ang.z),a3.x,a3.y);\n\n    mat3 m;\n    m[0] = vec3(a3.y*a2.y,-a3.x*a2.y,a2.x);\n    m[1] = vec3(a3.x*a1.y + a1.x*a2.x*a3.y,a3.y*a1.y - a1.x*a2.x*a3.x,-a1.x*a2.y);\n    m[2] = vec3(a1.x*a3.x - a1.y*a2.x*a3.y,a3.y*a1.x + a1.y*a2.x*a3.x,a1.y*a2.y);\n    return m;\n}\n\nvec3 RotateEuler(vec3 p,vec3 ang,vec3 scale)\n{   \n    mat3 rot = FromEuler(ang);\n    rot[0] *= 1.0/scale.x;\n    rot[1] *= 1.0/scale.y;\n    rot[2] *= 1.0/scale.z;\n\n    return mul(rot,p);\n}\n\nvec3 RotateEuler(vec3 p,vec3 ang)\n{\n    return mul(FromEuler(ang),p);\n}\n\nfloat Noise(vec2 v)\n{\n    vec2 i = floor(v);\n    vec2 t = fract(v);\n    vec2 u  = t*t*(3.0-2.0*t);\n\n    return mix(mix(rand(i + vec2(0.0,0.0)),rand(i + vec2(1.0,0.0)),u.x),\n                mix(rand(i + vec2(0.0,1.0)),rand(i + vec2(1.0,1.0)),u.x),\n                u.y);\n}\n\nmat3 SetCamera(vec3 ro,vec3 ta)\n{\n    vec3 rz = normalize(ta - ro);\n    vec3 p = vec3(0.0, 1.0, 0.0);\n    vec3 rx = normalize(cross(rz,p));\n    vec3 ry = normalize(cross(rz,rx));\n\n    return mat3(-rx,ry,rz);\n}\n\n//Union\nfloat OpU(float o1,float o2)\n{\n    return min(o1,o2);\n}\n\n//Smooth Union\nfloat OpSU(float o1,float o2,float k)\n{\n    float h = clamp( 0.5+0.5*(o2-o1) / k, 0.0, 1.0 );\n    return mix( o2, o1, h ) - k*h*(1.0-h);\n}\n\n//Smooth Intersection\nfloat OpSI(float o1,float o2,float k)\n{\n    return -OpSU(-o1,-o2,k);\n}\n\n//subtract\nfloat OpS(float o1,float o2)\n{\n    return max(o1,-o2);\n}\n\n//Intersection\nfloat OpI(float o1,float o2)\n{   \n    return max(o1,o2);\n}\n\n//Union\nvec2 OpU2(vec2 o1,vec2 o2)\n{\n    return o1.x < o2.x ? o1 : o2;\n}\n\nObjectData OpU_OD(ObjectData o1,ObjectData o2)\n{\n    if(o1.distance < o2.distance)\n    {\n        return o1;\n    }\n    return o2;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max3(d),0.0) + length(max(d,0.0));\n}\n\nfloat udBox(vec3 p,vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nfloat udRoundBox(vec3 p,vec3 b,float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCapsule( vec3 p,vec2 h)\n{\n    float  d = p.y;\n    d = clamp(d,-h.y,h.y);\n    p.y -= d;\n    return length(p) - h.x;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max2(d),0.0) + length(max(d,0.0));\n}\n\n//x:outter radius \n//y:half height \n//z:inner radius\nfloat sdSphericalShell(vec3 p,vec3 h)\n{\n    float d = length(p);\n    float t = smoothstep(0.0,h.y,abs(p.y));\n    return mix(max(d - h.x,-(d - (h.x - h.z))),OpS(sdCappedCylinder(p,h.xy),sdCappedCylinder(p,h.xy-vec2(h.z,0))),t);\n}\n\nfloat sdSphericalShell2(vec3 p,vec3 h)\n{\n    float d = length(p);\n    float t = smoothstep(0.0,h.y,p.y);\n    return mix(d - h.x,sdCappedCylinder(p,h.xy),t);\n}\n\nfloat sdCosCurve(vec3 p,vec2 h,vec3 c)\n{   \n    p.x += c.x*cos(p.y / h.y * 3.1415926 * c.y);\n    p.z -= c.z*c.x*cos(p.y / h.y * 3.1415926);\n    p.y -= c.z*c.x*sin(p.y / h.y * 3.1415926);\n    return sdCapsule(p,h);\n}\n\nfloat sdHalfSphere( vec3 p, vec2 h )\n{\n    return mix(sdCappedCylinder(p,h),length(p) - h.x,p.y < 0.0 ? 1.:0.);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nmat4 invMaterix(mat4 m)\n{\n    mat4 m2;\n    mat3 m3;\n    m3[0] = m[0].xyz;\n    m3[1] = m[1].xyz;\n    m3[2] = m[2].xyz;\n    \n    mat3 m1 = transpose(m3);\n\n    vec3 t = mul(m1,vec3(m[0].w,m[1].w,m[2].w));\n\n    m2[0] = vec4(m1[0],-t.x);\n    m2[1] = vec4(m1[1],-t.y);\n    m2[2] = vec4(m1[2],-t.z);\n    m2[3] = vec4(0.0,0.0,0.0,1.0);\n\n    return m2;\n}\n\n\nmat4 trs(vec3 translate,vec3 angle,vec3 scale)\n{\n    mat3 rot = FromEuler(angle);\n    mat4 mat;\n\n    rot[0] *= 1.0/scale.x;\n    rot[1] *= 1.0/scale.y;\n    rot[2] *= 1.0/scale.z;\n\n    mat[0] = vec4(rot[0],translate.x);\n    mat[1] = vec4(rot[1],translate.y);\n    mat[2] = vec4(rot[2],translate.z);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n\n    return mat;\n}\n\nvec3 mulMat(mat4 mat,vec3 p)\n{\n    vec4 p2 = mul(mat,vec4(p.xyz,1.0));\n    return p2.xyz;\n}\n\nmat4 transMat(mat4 mat,vec3 t)\n{\n    mat[0].w += t.x;\n    mat[1].w += t.y;\n    mat[2].w += t.z;\n    return mat;\n}\n\nmat4 rotMat(mat4 mat,vec3 a)\n{\n    mat3 rot = FromEuler(a);\n    mat4 m;\n\n    m[0] = vec4(rot[0],0.0);\n    m[1] = vec4(rot[1],0.0);\n    m[2] = vec4(rot[2],0.0);\n    m[3] = vec4(0.0,0.0,0.0,1);\n\n    m = mul(m,mat);\n\n    return m;\n}\n\nmat4 scaleMat(mat4 mat,vec3 s)\n{\n    mat[0].xyz *= 1.0 / s.x;\n    mat[1].xyz *= 1.0 / s.y;\n    mat[2].xyz *= 1.0 / s.z;\n\n    return mat;\n}\n\nObjectData createObject(float d,float m,mat4 w2l)\n{\n    ObjectData od;\n    od.distance = d;\n    od.materialId = m;\n    od.world2LocalMatrix = w2l;\n\n    return od;\n}\n\nObjectData createObject(float d,float m)\n{\n    mat4 w2l;\n    w2l[0] = vec4(1.0,0.0,0.0,0.0);\n    w2l[1] = vec4(0.0,1.0,0.0,0.0);\n    w2l[2] = vec4(0.0,0.0,1.0,0.0);\n    w2l[3] = vec4(0.0,0.0,0.0,1.0);\n    \n    return createObject(d,m,w2l);\n}\n\nObjectData PikaHeadObjective(vec3 p)\n{   \n    float  move = sign(sin(iTime)) * abs(sin(iTime*1.0))*0.2;\n    move = max(0.0,move);\n\n    vec3 rotate = vec3(0.0,iTime*100.0,0.0);\n    rotate = vec3(0.0,0.0,0.0);\n    mat4 w2l = trs(vec3(0.0,move,0.0),rotate,vec3(1.0,1.0,1.0));\n\n    vec3 localPos = mulMat(w2l,p);\n\n    float  earAngle = mix(30.0,50.0,0.5 + 0.5 * sin(iTime*10.0));\n    //earAngle = 45;\n\n    vec3 head1Pos = localPos;\n    vec3 head2Pos = localPos + vec3(0.0,-0.11,0.0);\n    vec3 leftEar1Pos = RotateEuler(localPos - vec3(0.2,0.0,0.0),vec3(0.0,0.0,earAngle)) + vec3(0.2 - 0.36,0.16,0.0);\n    vec3 rightEar1Pos = RotateEuler(localPos - vec3(-0.2,0.0,0.0),vec3(0.0,0.0,-earAngle)) + vec3(-0.2 + 0.36,0.16,0.0);\n    vec3 leftEarClipPos = leftEar1Pos + vec3(-0.15,-0.03,0.0);\n    vec3 rightEarClipPos = rightEar1Pos + vec3(0.15,-0.03,0.0);\n    vec3 nosePos = localPos + vec3(0.0,-0.02,-0.21-0.01);\n\n    vec3 leftEye1Pos = localPos + vec3(-0.1,0.04,-0.21 + 0.065);\n    vec3 rightEye1Pos = localPos + vec3(0.1,0.04,-0.21 + 0.065);\n    vec3 leftEye2Pos = leftEye1Pos + vec3(-0.01,0.015,-0.05 + 0.015);\n    vec3 rightEye2Pos = rightEye1Pos + vec3(0.01,0.015,-0.05 + 0.015);\n    vec3 leftFacePos = localPos + vec3(-0.14,-0.07,-0.21 + 0.12);\n    vec3 rightFacePos = localPos + vec3(0.14,-0.07,-0.21 + 0.12);\n\n    vec3 mouthPos = RotateEuler(localPos,vec3(0.0,0.0,-90)) + vec3(-0.07,0.0,-0.21 - 0.011);\n    vec3 tonguePos = localPos;\n\n    ObjectData head1 = createObject(sdSphere(head1Pos,0.21),8.0,w2l);\n    ObjectData head2 = createObject(sdTorus(head2Pos,vec2(0.08,0.07)),8.0,w2l);\n\n    ObjectData leftEar1 = createObject(sdEllipsoid(leftEar1Pos,vec3(0.2,0.05,0.045)),8.0,w2l);\n    ObjectData rightEar1 = createObject(sdEllipsoid(rightEar1Pos,vec3(0.2,0.05,0.045)),8.0,w2l);\n\n    ObjectData leftEar2 = leftEar1;\n    leftEar2.materialId = 10.0;\n    ObjectData rightEar2 = rightEar1;\n    rightEar2.materialId = 10.0;\n\n    ObjectData leftEarClip = createObject(sdSphere(leftEarClipPos,0.1),8.0,w2l);\n    ObjectData rightEarClip = createObject(sdSphere(rightEarClipPos,0.1),8.0,w2l);\n\n    ObjectData nose = createObject(sdEllipsoid(nosePos,vec3(0.015,0.01,0.01)),2.0,w2l);\n\n    ObjectData leftEye1 = createObject(sdSphere(leftEye1Pos,0.05),2.0,w2l);\n    ObjectData rightEye1 = createObject(sdSphere(rightEye1Pos,0.05),2.0,w2l);\n    ObjectData leftEye2 = createObject(sdSphere(leftEye2Pos,0.016),3.0,w2l);\n    ObjectData rightEye2 = createObject(sdSphere(rightEye2Pos,0.016),3.0,w2l);\n\n    ObjectData leftFace = createObject(sdSphere(leftFacePos,0.08),9.0,w2l);\n    ObjectData rightFace = createObject(sdSphere(rightFacePos,0.08),9.0,w2l);\n\n    ObjectData mouse = createObject(sdCosCurve(mouthPos,vec2(0.003,0.06),vec3(0.01,1.5,0.3)),2.0,w2l);\n\n    leftEar1.distance = OpS(leftEar1.distance,leftEarClip.distance);\n    rightEar1.distance = OpS(rightEar1.distance,rightEarClip.distance);\n\n    leftEar2.distance = OpI(leftEar2.distance,leftEarClip.distance);\n    rightEar2.distance = OpI(rightEar2.distance,rightEarClip.distance);\n\n    head1.distance = OpSU(head1.distance,head2.distance,0.2);\n    head1.distance = OpSU(head1.distance,leftEar1.distance,0.04);\n    head1.distance = OpSU(head1.distance,rightEar1.distance,0.04);\n\n    head1 = OpU_OD(head1,leftEar2);\n    head1 = OpU_OD(head1,rightEar2);\n    head1 = OpU_OD(head1,leftEye1);\n    head1 = OpU_OD(head1,rightEye1);\n    head1 = OpU_OD(head1,leftEye2);\n    head1 = OpU_OD(head1,rightEye2);\n    head1 = OpU_OD(head1,leftFace);\n    head1 = OpU_OD(head1,rightFace);\n    head1 = OpU_OD(head1,nose);\n    head1 = OpU_OD(head1,mouse);\n\n    ObjectData obj = head1;\n\n    return obj;\n}\n\nObjectData BallObjective(vec3 p)\n{\n    vec3 rotate = vec3(20.0,60.0,-20.0);\n    //rotate = vec3(0,_Time.y*100,0);\n    mat4 w2l = trs(vec3(0.0,0.0,0.0),rotate,vec3(3.0,3.0,3.0));\n\n    vec3 localPos = mulMat(w2l,p);\n\n    float  openBallAngle = sign(sin(iTime)) * abs(sin(iTime*1.0))*90.0;\n\n    openBallAngle = max(0.0,openBallAngle);\n\n    vec3 p1 = RotateEuler(localPos + vec3(0.2,0.0,0.0),vec3(0.0,0.0,openBallAngle)) - vec3(0.2,0.0,0.0);\n    vec3 p2 = RotateEuler(localPos,vec3(0.0,0.0,180.0));\n    vec3 p3 = RotateEuler(localPos + vec3(0.2,0.0,0.0),vec3(0.0,0.0,90.0 + openBallAngle)) + vec3(0.0,-0.4,0.0);\n    vec3 p4 = RotateEuler(localPos + vec3(0.2,0.0,0.0),vec3(0.0,0.0,90.0 + openBallAngle)) + vec3(0.0,-0.41,0.0);\n    vec3 p5 = RotateEuler(localPos + vec3(0.2,0.0,0.0), vec3(0.0,0.0,openBallAngle)) - vec3(0.2,0.0,0.0) + vec3(0.0,0.005,0.0);\n    vec3 p6 = RotateEuler(localPos , vec3(0.0,0.0,0.0)) - vec3(0.0,0.005,0.0);\n\n    ObjectData obj1_0 = createObject(sdHalfSphere(p1,vec2(0.2,0.0005)),12.0,w2l);\n    ObjectData obj2_0 = createObject(sdHalfSphere(p2,vec2(0.2,0.0005)),11.0,w2l);\n\n    ObjectData obj1_1 = createObject(sdHalfSphere(p1,vec2(0.18,0.0005)),12.0,w2l);\n    ObjectData obj2_1 = createObject(sdHalfSphere(p2,vec2(0.18,0.0005)),11.0,w2l);\n\n    ObjectData obj3 = createObject(sdCappedCylinder(p3,vec2(0.03,0.005)),11.0,w2l);\n    ObjectData obj4 = createObject(sdCappedCylinder(p4,vec2(0.01,0.002)),11.0,w2l);\n\n    ObjectData obj5 = createObject(sdSphericalShell(p5 ,vec3(0.2005,0.005,0.015)),2.0,w2l);\n    ObjectData obj6 = createObject(sdSphericalShell(p6,vec3(0.2005,0.005,0.015)),2.0,w2l);\n\n    obj1_0.distance = OpS(obj1_0.distance,obj1_1.distance);\n    obj2_0.distance = OpS(obj2_0.distance,obj2_1.distance);\n\n    ObjectData obj = OpU_OD(obj1_0,obj2_0);\n    obj = OpU_OD(obj,obj3);\n    obj = OpU_OD(obj,obj4);\n    //obj = OpU_OD(obj,obj5);\n    //obj = OpU_OD(obj,obj6);\n\n    return obj;\n}\n\nObjectData BallLineObjective(vec3 p)\n{\n    vec3 rotate = vec3(20.0,60.0,-20.0);\n    //rotate = vec3(0,_Time.y*100,0);\n    mat4 w2l = trs(vec3(0.0,0.0,0.0),rotate,vec3(3.0,3.0,3.0));\n\n    vec3 localPos = mulMat(w2l,p);\n\n    float  openBallAngle = sign(sin(iTime)) * abs(sin(iTime*1.0))*90.0;\n\n    openBallAngle = max(0.0,openBallAngle);\n\n    vec3 p5 = RotateEuler(localPos + vec3(0.2,0.0,0.0), vec3(0.0,0.0,openBallAngle)) - vec3(0.2,0.0,0.0) + vec3(0.0,0.005,0.0);\n    vec3 p6 = RotateEuler(localPos , vec3(0.0,0.0,0.0)) - vec3(0.0,0.005,0.0);\n\n    ObjectData obj5 = createObject(sdSphericalShell(p5 ,vec3(0.2005,0.005,0.015)),13.0,w2l);\n    ObjectData obj6 = createObject(sdSphericalShell(p6,vec3(0.2005,0.005,0.015)),13.0,w2l);\n\n    ObjectData obj = OpU_OD(obj5,obj6);\n\n    return obj;\n}\n\nObjectData ObjectsGroup(vec3 p)\n{   \n    ObjectData pikahead = PikaHeadObjective(p);\n    ObjectData pokemonBall = BallObjective(p);\n    //return pikahead;\n    return OpU_OD(pikahead,pokemonBall);\n}\n\nfloat SoftShadow(vec3 ro, vec3 rd, float mint, float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i = 0; i < 16; i++ )\n    {\n        float h = ObjectsGroup( ro + rd*t ).distance;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n#define RAYMARCH_STEP_NUM 256\nObjectData Raymarching(vec3 ro, vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 10.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    float n = 0.5e-8;\n    mat4 w2l;\n\n    for( int i = 0; i < RAYMARCH_STEP_NUM; i++ )\n    {\n        float precis = n*t;\n        ObjectData res = ObjectsGroup( ro + rd*t );\n        if( res.distance < precis || t > tmax ) break;\n        t += res.distance;\n        m = res.materialId;\n        w2l = res.world2LocalMatrix;\n    }\n\n    if(t > tmax) m = -1.0;\n\n    ObjectData data = createObject(t,m,w2l);\n\n    return data;\n}\n\nObjectData RaymarchingBallLine(vec3 ro, vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 10.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    float n = 0.5e-8;\n    mat4 w2l;\n\n    for( int i = 0; i < RAYMARCH_STEP_NUM; i++ )\n    {\n        float precis = n*t;\n        ObjectData res = BallLineObjective( ro + rd*t );\n        if( res.distance < precis || t > tmax ) break;\n        t += res.distance;\n        m = res.materialId;\n        w2l = res.world2LocalMatrix;\n    }\n\n    if(t > tmax) m = -1.0;\n\n    ObjectData data = createObject(t,m,w2l);\n\n    return data;\n}\n\nfloat Fbm(vec2 p)\n{\n    const int octaves = 12;\n    float lacunarity = 0.5;\n    float gain = 2.0;\n    float sum = 0.0;\n    float freq = 2.0, amp = 1.1;\n    for(int i = 0; i < octaves; i ++)\n    {\n        float n = Noise(p * freq);\n        sum += n * amp;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n\n    return sum;\n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n    vec3 nor = vec3(\n        ObjectsGroup(pos+eps.xyy).distance - ObjectsGroup(pos-eps.xyy).distance,\n        ObjectsGroup(pos+eps.yxy).distance - ObjectsGroup(pos-eps.yxy).distance,\n        ObjectsGroup(pos+eps.yyx).distance - ObjectsGroup(pos-eps.yyx).distance );\n\n    return normalize(nor);\n}\n\nvec4 RenderOutline(vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor,1.0);\n}\n\nvec4 RenderBallLine(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    float aa = 1.0 - pow(saturate(abs(localPos.y / 0.01)),4.0);\n\n    return vec4(diffuseColor,aa);\n}\n\nvec4 RenderMaterial0(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    float wise = 0.1;\n    float ndl = ((dot(normal,lightDir)*0.5+0.5) + wise) / (1.0 + wise);\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor * ndl + pow(rdv,35.0),aa);\n}\n\nvec4 RenderMaterial1(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    float wise = 0.1;\n    float ndl = ((dot(normal,lightDir)*0.5+0.5) + wise) / (1.0 + wise);\n\n    vec3 p = (localPos);\n\n    diffuseColor = mix(diffuseColor,vec3(1.0,1.0,0.0),Fbm(vec2(length(p.xy),p.z)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor * ndl + pow(rdv,35.0),aa);\n}\n\nvec4 RenderMaterial2(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    float wise = 0.1;\n    float ndl = ((dot(normal,lightDir)*0.5+0.5) + wise) / (1.0 + wise);\n\n    vec3 p = normalize(localPos);\n    diffuseColor = mix(diffuseColor,vec3(1,0,1),Fbm(vec2(length(p.xy),p.z)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor * ndl + pow(rdv,35.0),aa);\n}\n\n\nvec4 RenderMaterial4(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    \n    float ndl = dot(normal,lightDir)*0.5+0.5;\n\n    float rampSmooth = 0.005;\n    float threshold1 = 0.5;\n    float threshold2 = 0.2;\n    float rampThresholdBlend = 0.7;\n\n    float ramp1 = smoothstep(threshold1 - rampSmooth, threshold1,ndl);\n    float ramp2 = smoothstep(threshold2 - rampSmooth, threshold2,ndl);\n\n    float ramp = mix(0.0,mix(mix(threshold2,threshold1,rampThresholdBlend) ,1.0,ramp1),ramp2);\n\n    vec3 diffuseHsv = RGBtoHSV(diffuseColor);\n    vec3 shadowHsv = RGBtoHSV(vec3(0.1,0.3,0.3));\n\n    diffuseColor = HSVtoRGB(vec3(diffuseHsv.rg,mix(shadowHsv.b,diffuseHsv.b,ramp)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    float outline = smoothstep(0.09,0.18,pow(max(0.0,dot(normal,viewDir)*0.9+0.1),1.4478));\n\n    vec3 finalColor = mix(vec3(0.0,0.0,0.0),diffuseColor + 0.15*pow(rdv,35.0),outline);\n\n    return vec4(finalColor*max(shadow,0.4),aa);\n}\n\nvec4 RenderMaterial5(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    \n    float ndl = dot(normal,lightDir)*0.5+0.5;\n\n    float ramp = ndl;\n    \n    vec3 diffuseHsv = RGBtoHSV(diffuseColor);\n    vec3 shadowHsv = RGBtoHSV(vec3(0.1,0.3,0.3));\n\n    diffuseColor = HSVtoRGB(vec3(diffuseHsv.rg,mix(shadowHsv.b,diffuseHsv.b,ramp)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    float outline = smoothstep(0.09,0.18,pow(max(0.0,dot(normal,viewDir)*0.9+0.1),1.4478));\n\n    vec3 finalColor = mix(vec3(0,0,0),diffuseColor + 0.65*pow(rdv,35.0),outline);\n\n    return vec4(finalColor*max(shadow,0.4),aa);\n}\n\nvec4 Render(vec3 orgPos,vec3 rayDir)\n{\n    vec4 color = vec4(0,0,0,0) ;\n\n    ObjectData result = Raymarching(orgPos, rayDir);\n    float  dist = result.distance;\n    float  material = result.materialId;\n\n    if(material >= 0.0)\n    {\n        mat4 w2l = result.world2LocalMatrix;\n        vec3 position = orgPos + rayDir * dist;\n        vec3 normal = CalcNormal(position);\n        vec3 lightDir = normalize(vec3(0.5*sin(iTime*2.0),-1,1));\n        vec3 diffColor = vec3(1,1,1);\n        vec3 uViewDir = -rayDir * dist;\n        vec3 localPos = mulMat(w2l,position);\n        float  shadow = SoftShadow(position,lightDir,0.02, 2.5);\n\n        mat4 w2l_2nd;\n        w2l_2nd[0]=vec4(1,0,0,w2l[0].w);\n        w2l_2nd[1]=vec4(0,1,0,w2l[1].w);\n        w2l_2nd[2]=vec4(0,0,1,w2l[2].w);\n        w2l_2nd[3]=vec4(0,0,0,1);\n        \n\n        vec3 localPos_2nd = mulMat(w2l_2nd,position);\n\n        if(material == 1.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial1(localPos_2nd,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 2.0)\n        {\n            diffColor = vec3(0,0,0);\n            color = RenderOutline(position,normal,lightDir,uViewDir,diffColor,shadow);  \n        }\n        else if(material == 3.0)\n        {\n            diffColor = vec3(1,1,1);\n            color = RenderOutline(position,normal,lightDir,uViewDir,diffColor,shadow);  \n        }\n        else if(material == 4.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial2(localPos_2nd,position,normal,lightDir,uViewDir,diffColor,shadow);\n        }\n        else if(material == 6.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial0(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 7.0)\n        {\n            diffColor = vec3(1,1,1);\n            color = RenderMaterial0(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 8.0)\n        {\n            diffColor = vec3(1,1,0);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 9.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 10.0)\n        {\n            diffColor = vec3(0,0,0);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 11.0)\n        {\n            diffColor = vec3(1,1,1);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 12.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial5(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n    }\n\n    ObjectData result2 = RaymarchingBallLine(orgPos, rayDir);\n\n    result2 = OpU_OD(result,result2);\n\n    float  dist2 = result2.distance;\n    float  material2 = result2.materialId;\n\n    if(material2 == 13.0)\n    {\n        mat4 w2l = result.world2LocalMatrix;\n        vec3 position = orgPos + rayDir * dist;\n        vec3 normal = CalcNormal(position);\n        vec3 lightDir = normalize(vec3(0.5*sin(iTime*2.0),-1,1));\n        vec3 diffColor = vec3(1,1,1);\n        vec3 uViewDir = -rayDir * dist;\n        vec3 localPos = mulMat(w2l,position);\n        float  shadow = SoftShadow(position,lightDir,0.02, 2.5);\n\n        mat4 w2l_2nd;\n        w2l_2nd[0]=vec4(1,0,0,w2l[0].w);\n        w2l_2nd[1]=vec4(0,1,0,w2l[1].w);\n        w2l_2nd[2]=vec4(0,0,1,w2l[2].w);\n        w2l_2nd[3]=vec4(0,0,0,1);\n        \n\n        vec3 localPos_2nd = mulMat(w2l_2nd,position);\n\n        diffColor = vec3(0,0,0);\n        vec4 color2 = RenderBallLine(localPos,position,normal,lightDir,uViewDir,diffColor,shadow); \n\n        color.rgb = mix(color.rgb,color2.rgb,color2.a);\n    }\n\n\n    return color;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aa = 0.0;\n    vec4 color = vec4(0.0);\n    vec2 canvasPos = fragCoord / iResolution.xy;\n    for(int i = -AA; i <= AA; ++ i)\n    {\n        for (int j = -AA; j <= AA; ++ j)\n        {\n            vec2 orgPos = (2.0 * (fragCoord + vec2(i,j) * 0.35) -  iResolution.xy) / iResolution.y;\n\t\t\t\n            vec3 cameraPos = vec3(0,0,2);\n            vec3 lookAtPos = vec3(0,0,0);\n\n            mat3 cameraMatrix = SetCamera(cameraPos,lookAtPos);\n\n            vec3 rayDir = mul(cameraMatrix,normalize(vec3(orgPos,1)));\n\n            color += Render(cameraPos,rayDir);\n            aa += 1.0;\n        }\n    }    \n    \n    color /= aa;\n    \n    vec4 skyBox = mix(vec4(1,1,1,1),vec4(0,0.3,1,1),pow(canvasPos.y,0.4));\n\n    vec4 finialColor = vec4(mix(skyBox.rgb,color.rgb,color.a),skyBox.a);\n\n    fragColor = finialColor;\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}