{"ver":"0.1","info":{"id":"Mljczy","date":"1528243124","viewed":256,"name":"const step ray marching","username":"tylerbata","description":"Made to test my other program to visualize the octree inefficiently.  ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float scale = 2.0;\n\nfloat min3(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\nfloat max3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 p) {\n    //return min(max(-sdSphere(p, 7.5 * scale), sdBox(p, vec3(6.0) * scale)), -sdSphere(p, 25.0 * scale));\n    return max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0)));\n}\n\n\n\nfloat hitBox(vec3 ro, vec3 rd, vec3 box0, vec3 box1, float minMax) {\n\tvec3 pos0 = (box0 - ro) / rd;\n\tvec3 pos1 = (box1 - ro) / rd;\n\tfloat tmin = max3(min(pos0, pos1));\n\tfloat tmax = min3(max(pos0, pos1));\n    \n    float t = (bool(minMax))? tmax : tmin;\n\treturn (tmin < tmax && tmax > 0.0)? t : -1.0;\n}\n\n\nfloat cast_ray( in vec3 ro, in vec3 rd, float t, float tmin,float tmax)\n{\n\tfloat precis = 0.005;\n    float delta = 0.05;\n    int steps = int((tmax - tmin) / delta);\n    for( int i=0; i < steps; i++ )\n    {\n\t    float tempT = map( ro+rd*t);\n        if( tempT<precis || t>tmax ) break;\n        t += delta;\n    }\n\n\tif(t + delta*1.5 > tmax)t = -1.0;\n\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rd = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 ro = vec3(0.0, 2.0 * sin(iTime), -25.0);\n\tro.xz = rotate2d(ro.xz, iTime*0.1);\n\trd.xz = rotate2d(rd.xz, iTime*0.1);\n\n    \n    float tEntry = hitBox(ro,rd,vec3(-6.0), vec3(6.0), 0.0);\n    float tExit = hitBox(ro,rd,vec3(-6.0), vec3(6.0), 1.0);\n    float dt = tExit - tEntry;\n    \n    float t = -1.0;\n    vec3 col = rd;\n    \n    if(tEntry > 0.0)\n        t = cast_ray(ro,rd,tEntry,tEntry,tExit);\n    \n    \n    col = vec3(t / 64.0);\n    \n    \n    \n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}