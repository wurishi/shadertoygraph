{"ver":"0.1","info":{"id":"wt3yW4","date":"1609077326","viewed":154,"name":"spectrum using mix âš™","username":"HaleyHalcyon","description":"rings","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (3.14159265358979 * 2.)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat random(uint seed) {\n    return uintBitsToFloat(0x007FFFFFu & hash(seed) | 0x3F800000u) - 1.;\n} \n\nvec3 spectrum(float x) {\n    x = mod(x, 3.);\n    return mix(\n       mix(vec3(1, 1, 0), vec3(0, 1, 1), x),\n       mix(vec3(1, 0, 1), vec3(1, 1, 0), x-2.),\n       x-1.\n    );\n}\n\nfloat odd(int x) {\n    return float(x & 1) * 2. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = length(iResolution);\n    vec2 uv = fragCoord / scale;\n\tuv -= (iResolution.xy / scale) / 2.;\n    uv *= 2.0;\n    \n    float distSq = uv.x*uv.x+uv.y*uv.y;\n    float angle = atan(uv.x, uv.y);\n    int ring = int(iTime + log(distSq) * 0.6);\n    float rand = random(uint(ring)) - 0.5;\n    float angleAdd = (iTime * rand);\n    \n    vec3 col = spectrum(\n        angleAdd + angle / TAU * 3. * odd(ring)\n    );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}