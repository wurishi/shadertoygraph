{"ver":"0.1","info":{"id":"wdGGDG","date":"1570825053","viewed":449,"name":"VolClouds","username":"space928","description":"Basic volumetric cloud shader. Not very performant, not very pretty.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["procedural","3d","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uniform vec2 resolution;\n//uniform sampler2D PerlinNoise;\nuniform float time;\n//uniform sampler2D PerlinNm;\n//uniform sampler2D noisec;\n//uniform sampler2D Mountain;\n\nconst int steps = 64;\nconst float stepSize = .005;\nconst float cloudScale = .05;\nconst float cloudCov = .4;\nconst float cloudTurb = .0015;\nconst float softness = .1;\nconst vec3 lightDir = normalize(vec3(.1,-0.3,-.2));\nconst float cloudAbsorption = 50.;\nconst float lightAbsorption = 300.;\n\nvec2 turbulence (vec3 p)\n{\n  return cloudTurb*(texture(iChannel1, 3.*(p.xz+p.zy*0.964654)).xy*2.-1.);\n}\n\nfloat sampleDens(vec3 p)\n{\n  vec2 t = turbulence (p);\n  float n = texture(iChannel0, p.xz*cloudScale+.5+t).r;\n  //n *= texture(iChannel0, p.zy*cloudScale*.976359+vec2(.3764,.662747)+t).r;\n\n  float cloudTaper = 1./clamp(1.-p.y*5., 0., 1.);\n  n = smoothstep(cloudCov*cloudTaper, cloudCov*cloudTaper+softness, n);\n\n  if(p.y<0.)\n    n = 0.;\n\n  return n;\n}\n\nfloat collectDens(vec3 o, vec3 r) {\n  float t = 0.0;\n  float d = 0.;\n  for( int i=0;i < steps/2;i++ ) {\n    vec3 p = o + r * t;\n\n    d += sampleDens(p)*stepSize;\n\n    t += stepSize/2.;\n  }\n  return d;\n}\n\nvec4 collectLight(vec3 o, vec3 r) {\n  float t = 0.0;\n  float trans = 1.;\n  float light = 0.;\n  for( int i=0;i < steps*2;i++ ) {\n    vec3 p = o + r * t;\n\n    vec3 d = lightDir;\n    float dens = sampleDens(p);\n    if(dens>.05)\n    {\n      light += collectDens(p,lightDir)*lightAbsorption*trans*stepSize;\n      trans *= exp(-dens*cloudAbsorption*stepSize);\n    }\n\n    t += stepSize*2.+turbulence((o + r * t+iTime)*50.).x*3.;\n  }\n  return vec4(light,light,light,trans);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = uv * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n\n  vec3 r = normalize(vec3(uv, 1.0));\n  vec3 o = vec3(0.,sin(iTime)*.125-.1,iTime*.3);\n\n  //float dens = collectDens(o, r);\n  vec4 cloud = collectLight(o,r);\n\n  vec3 col = mix(vec3(.7,.8,.9), vec3(.4,.6,.8), uv.y)*cloud.a+cloud.rgb;//mix(cloud.rgb, texture(iChannel2,uv*.5+.5).rgb*.8, 1.-cloud.a);\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}