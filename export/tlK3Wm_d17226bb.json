{"ver":"0.1","info":{"id":"tlK3Wm","date":"1579122398","viewed":77,"name":"columnas  s-0-n01","username":"jorge2017a1","description":"columnas  s-0-n01","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["columnass0n01"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n\n\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//--------------------------------------------------------\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\n//---------------------------------------------------------\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\n//---------------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------------\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n//----------------------------------------\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\tvec3 p;\n    float d;\n    \n    d=999.9;\n    p=pos;\n        \n     //p.zx *= rotate(iTime);\n  \t //p.yx *= rotate(iTime * 0.5);\n\n   \tfloat k =3.5;\n    \n\tp.xz =mod(p.xz,k)-0.5*k;\n    \n    \n   \n    float  distToCapsule =sdCylinder( p, vec2(0.5,2.0) );\n    //superior\n    float sdb1a = sdBox( p-vec3(0.0,2.5,0.0), vec3(1.0,0.125,1.0));\n    float sdb1b = sdBox( p-vec3(0.0,2.2,0.0), vec3(1.5,0.125,1.5));\n    float sdb1c = sdBox( p-vec3(0.0,2.0,0.0), vec3(1.0,0.125,1.25));\n    float sdb1d = sdBox( p-vec3(0.0,2.7,0.0), vec3(0.8,0.125,0.7));\n    float sdb1e = sdBox( p-vec3(0.0,2.7,0.0), vec3(0.5,1.0,0.7));\n    \n    \n    //inferior\n    float sdb2a = sdBox( p-vec3(0.0,-2.0,0.0), vec3(1.0,0.125,1.0));\n    float sdb2b = sdBox( p-vec3(0.0,-2.5,0.0), vec3(1.5,0.25,1.0));\n    \n    \n    \n    \n    //d= unionSDF(distToCapsule,distToCapsule2);\n    \n    //d= distToCapsule;\n    \n    d= unionSDF(d,distToCapsule); \n    d= unionSDF(d,sdb1a);\n    d= unionSDF(d,sdb1b);\n    d= unionSDF(d,sdb1c);\n    d= unionSDF(d,sdb1d);\n    d= unionSDF(d,sdb1e);\n    \n    d= unionSDF(d,sdb2a);\n    d= unionSDF(d,sdb2b);\n    \n    \n    //d=distToCapsule;\n    \n    \n /*   \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r =  abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n*/\n\n  return d;\n                        \n \n\t\t\n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\t//return max( d1, -d0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.5, 0.6 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n    \n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n    \n    \n    \n    \n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 10.0-iTime );\n\n\t// rotate camera\n    /*\n\tmat3 rot = rotationXY( vec2( iTime ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t*/\t\n\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}\n\n\n","name":"Image","description":"","type":"image"}]}