{"ver":"0.1","info":{"id":"l3SfRd","date":"1729819109","viewed":91,"name":"Plastic Cross","username":"Elsio","description":"Na vida nada se perde. Tudo se transforma. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","geometry","cross","shane","traversal","cruzes"],"hasliked":0,"parentid":"lXBfDh","parentname":"Concave Heptagon Traversal study"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// shaders lindos â™¥ https://www.shadertoy.com/playlist/cXBGzV\n#define h21(p) fract(sin(dot(p, vec2(27.619, 57.583))) * 43758.5453)\n#define Cor(p) fract(sin(p + p) * sin(29. * p).yx)\n#define rot(a) mat2(cos(a + pi * vec4(0, .5, 1.5, 0)))\n#define ang atan(1., 3.)\n#define pi acos(-1.)\n#define FAR 20.\n\nfloat gCD;\nvec2 id;\n\nfloat opExtrusion(float sdf, float pz, float h, float sf) {\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n    return min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\nfloat cruz(vec2 p) {\n    p = rot(ang) * p;\n    vec2 b = cos(ang) / vec2(2, 6.);\n    p = abs(p);\n    p -= p.x < p.y ? b.yx : b;\n    return max(p.x, p.y);\n}\n\nfloat roundCross(vec2 p, float r) {\n    p = rot(ang) * p;\n    vec2 b = cos(ang) / vec2(2, 6.) - .06;\n    p = abs(p);\n    p = p.x < p.y ? p.yx : p;\n    \n    vec2 q, w;\n    float k, d;\n    q = p - b;\n    \n    k = max(q.x, q.y);\n    \n    w = k > 0. ? q : vec2(b.y - p.x, -k);\n    d = length(max(w, 0.));\n    return (k > 0. ? d : -d) + r;\n}\n\n\nfloat hm(vec2 p) {\n    float ret = h21(p + .5)\n              + tanh(cos(h21(p + .5) * 4. + iTime * 2.) * 6.) * .35;\n    \n    //return .7; // stop animation\n    return max(ret, .1);\n}\n\n\nfloat neig(vec2 p, out vec2 q, out vec2 id){\n    id = floor(p);\n    q = fract(p) - .5;\n    \n    return cruz(q);\n}\n\n\nvec2 grid(vec3 p){\n    vec2 ID, Q, q;\n    float a = neig(p.xy + .5, Q, ID),\n          b = neig(p.xy     , q, id);\n    \n    if(a < b){\n        id = ID + .1; \n        q = Q;\n    }\n    \n    gCD = max(a, b) + .05;\n    \n    return q;\n}\n\nfloat map(vec3 p) {\n    vec2 q = grid(p);\n    float d2, h = hm(id), d;\n\n    d2 = roundCross(q, 0.) - .05; // cross shape\n    d2 = max(d2, -d2 - .14); // hole\n    \n    // 3D\n    d = opExtrusion(d2, p.z, h, .01);\n    \n    d += smoothstep(.0, .1,\n             abs(\n                 fract(  // wall detail\n                     (p.z + h) * 6.\n                 ) - .5\n             ) - .1\n         ) * .01;\n         \n    d += max(d2, -.03) * .8; // top detail\n    \n    // sticks\n    float sticks = \n        length(\n            fract(\n                p.xy * rot(pi / 4.) * sqrt(2.) + .5\n            ) - .5\n        ) - .04;\n    \n    id *= step(d, sticks);\n    \n    \n    // remove sticks  \n    if(iMouse.z > 0.)\n        return d;\n        \n    return min(d, sticks);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d, t;\n    \n    for(int i = 0; i < 96; i ++) {\n        d = map(ro + rd * t);\n        if(abs(d) < .001 || t > FAR) break;\n        t += min(d * .9, gCD);\n    }\n    \n    return min(t, FAR);\n}\n\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.01, 0, 0);\n    vec3 v = vec3(\n                 map(p - e.xyy),\n                 map(p - e.yxy),\n                 map(p - e.yyx)\n             ) - map(p);\n    return normalize(-v);\n}\n\n\nfloat AO(vec3 p, vec3 n) {\n    float i, sca = 2., occ;\n    \n    while(i++ < 6.) {\n        occ += (i * .04 - map(p + n * (i * .03 + .03))) * sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// @shane shadows\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k) {\n    const int maxIterationsShad = 28;\n    ro += n * .0015;\n    vec3 rd = lp - ro;\n    float shade = 1.;\n    float t = 0.;\n    float end = max(length(rd), .0001);\n    rd /= end;\n    \n    for(int i = min(iFrame, 0); i < maxIterationsShad; i ++) {\n        float d = map(ro + rd * t);\n        shade = min(shade, k * d / t);\n        t += clamp(min(d, gCD), .02, .25);\n        \n        if(d < 0. || t > end) break;\n    }\n    return max(shade, .5);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t = iTime;\n    vec2 r = iResolution.xy;\n    u = (u + u - r) / r.y;\n    \n    vec3 D = normalize(vec3(u, 3)),\n         p = vec3(.1, -4., -3.2),\n         lp;\n\n    //if(false) // stop the cam\n        D.yz = rot(.6) * D.yz,\n        p.xy *= rot(tanh(sin(t * .2) * 3.)),\n        D.xy *= rot(tanh(cos(t * .2) * 3.));\n    \n    float a = t * .1;\n    lp = p + vec3(cos(a), sin(a), 0);\n    \n    float d = march(p, D);\n    \n    o = vec4(0);\n    \n    if(d < FAR) {\n        vec3 p = p + d * D,\n             N = normal(p),\n             ref = reflect(D, N);\n        \n        vec4 alb = length(id) > 0. ? vec4(Cor(id), Cor(id + .3)) : vec4(.3);\n        float diff = length(sin(ref) * .5 - .43),\n              spec = pow(diff * .9, 25.) * .06,\n              sh = softShadow(p, lp, N, 16.);\n              //sh = 1.; // remove shadows\n        \n        o = (alb * diff * .6 + spec) * AO(p, N * .1);\n        o = pow(o * sh, vec4(.45)) * (1. - 3. * d / FAR) * 2.;\n    }\n}","name":"Image","description":"","type":"image"}]}