{"ver":"0.1","info":{"id":"tsjXW3","date":"1555172641","viewed":242,"name":"noise_in_box","username":"skaplun","description":"Simple demo of gradient noise.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["noise","raytrace","slice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SLICE .1\n#define NOISE_THRESHOLD 0.\n#define CLR_B vec3(91., 22., 71.)/255.\n#define CLR_U vec3(255., 196., 0.)/255.\n#define BG vec3(.2)\n#define CUBE_SIZE 1.\n#define subSample 4.\n\nvec3 traverseInCube(Ray ray, float upperMax){\n\tPlane plane = Plane(vec3(0., upperMax - mod(upperMax, SLICE), 0.), vec3(0., -1., 0.));\n    HitRecord rec;\n    for(int i=0; i<10; i++, plane.origin.y -= SLICE){\n\t\tfloat n;\n        if(plane_hit(ray, plane, rec, 0., MAX_FLOAT)\n           && max(abs(rec.p.x), abs(rec.p.z)) <= CUBE_SIZE\n           && (n = noise(rec.p + iTime * .1)) > NOISE_THRESHOLD){\n\t\t\tfloat edge = abs(max(abs(rec.p.x), abs(rec.p.z)) - CUBE_SIZE);\n            edge = smoothstep(.025, .02, edge);\n            float edge2 = smoothstep(.02, .01, abs(n - NOISE_THRESHOLD));\n            return mix(CLR_B, CLR_U, smoothstep(-CUBE_SIZE, CUBE_SIZE, rec.p.y)) * max(max(edge, edge2), .2);\n        }\n    }\n    return BG;\n}\n\nvec4 image(vec2 fragCoord, vec2 res){\n\tvec3 viewDir = rayDirection(60., res, fragCoord);\n    float ang = (iResolution.x - iMouse.x) * .01;\n    vec3 origin = vec3(5. * sin(ang), 3., 5. * cos(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray camRay = Ray(origin, dir);\n    vec3 outClr = BG;\n    Box box = Box(vec3(0.), vec3(CUBE_SIZE + .0001));\n    HitRecord rec;\n    if(box_hit(box, camRay, 0., MAX_FLOAT, rec)){\n\t\toutClr = traverseInCube(camRay, rec.p.y);\n    }\n    \n    return vec4(outClr, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    /*\n    vec2 subResolution = iResolution.xy * subSample;\n\n    float samples = subSample * subSample;\n    float sampleWeight = 1. / samples;\n\n    for ( float i = 0.; i < subSample ; i ++ ){\n\t\tfor ( float j = 0.; j < subSample ; j ++ ){\n        \tvec2 newCoord = fragCoord * subSample + vec2(i,j);\n            fragColor += image(newCoord, subResolution) * sampleWeight;\n        }\n    }\n\t*/\n    fragColor = image(fragCoord, iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 1e5\n\nstruct Box{ vec3 origin; vec3 bounds;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{ float t; vec3 p;};\nstruct Plane{ vec3 origin; vec3 normal;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, const in Ray inray, float t_min, float t_max, inout HitRecord rec){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.origin + inbox.bounds;\n    vec3 minbounds = inbox.origin + -inbox.bounds;\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN > t_min && tx.MIN < t_max){\n    \trec.t = tx.MIN;\n        rec.p = inray.origin + inray.dir * rec.t;\n        return true;\n    }\n        \n    return false;\n}\n\nbool plane_hit(in Ray inray, in Plane plane, out HitRecord rec, in float t_min, in float t_max) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        if(t >= t_min && t < t_max){\n\t\t\trec.t = t;\n            rec.p = inray.origin + inray.dir * rec.t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 hash( vec3 p ){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p ){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}","name":"Common","description":"","type":"common"}]}