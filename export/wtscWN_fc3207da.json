{"ver":"0.1","info":{"id":"wtscWN","date":"1592147185","viewed":50,"name":"Rose Rock","username":"mgjunior","description":"use multi axis","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MaxIteration =15;\nconst float PI = 3.14;\nconst float epsilon = 0.001;\nfloat degreeToRad(float degree){\n    return degree*PI/180.0;\n}\n\nfloat getHeight(float f,vec3 axis,vec3 p,vec3 center){\n    axis = normalize(axis);\n    vec3 v = normalize(p-center);\n    float projectToAxisLen =dot(axis,v);\n    vec3 projectToAxis = axis*projectToAxisLen;\n    vec3 projectToPlane = v-projectToAxis;\n    float rad =atan(projectToAxisLen,length(projectToPlane));\n    rad*=f;\n\treturn 0.25*(sin(2.0*rad)+0.5*(sin(4.0*rad)+0.5*sin(10.0*rad)));\n}\n\nfloat sdfBall(vec3 p,vec3 center,float r)\n{\n    return length(p-center)-r;\n}      \n\nfloat rock(vec3 p,vec3 center,float r){\n    float finalR=r\n        +3.0*getHeight(3.0,vec3(1.0,1.0,0.0),p,center)\n        -5.0*getHeight(0.75,vec3(0.0,0.0,1.0),p,center)\n        -7.0*getHeight(0.75,vec3(1.0,0.0,0.0),p,center);\n    return length(p-center)-finalR;\n}\n\n//gradient is normal\nvec3 getNormal(vec3 p,vec3 center,float r){\n    float delta =0.01;\n    vec3 n=vec3(\n        rock(p+vec3(delta,0.0,0.0),center,r)-rock(p,center,r),\n        rock(p+vec3(0.0,delta,0.0),center,r)-rock(p,center,r),\n        rock(p+vec3(0.0,0.0,delta),center,r)-rock(p,center,r)\n    );\n\n    return normalize(n);\n}\n\nstruct Ray\n{\n    vec3 from;\n    vec3 dir;\n};\n\nRay[4] createRayDiff(vec3 eye, vec3 xAxis,vec3 yAxis,vec3 p){\n    vec2[4] multisampleDiff;\n    float x = 0.86602540378;\n    float y =0.5;\n\tmultisampleDiff[0]=vec2(x,y);   // turn 30 degree\n    multisampleDiff[1]=vec2(-y,x);  // turn 120 degree\n    multisampleDiff[2]=vec2(-x,-y); // turn 210 degree\n    multisampleDiff[3]=vec2(y,-x);  // turn 300 degree\n\n    float scale = 0.002;\n    Ray[4] rays;\n    for(int i=0;i<4;++i){\n        rays[i].from =p+scale*( multisampleDiff[i].x*xAxis + multisampleDiff[i].y*yAxis );\n        rays[i].dir =normalize(rays[i].from-eye);\n    }\n\n    return rays;\n}\n\nvec3 shading(Ray ray){\n    vec3 ballCenter =vec3(0.0,0.0,-50.0);  \n    float ballR =15.0;\n    vec3 shadingColor = vec3(0.0,0.0,0.0);\n\n    // ray marching\n    for(int i=0;i<MaxIteration;++i){\n       \tfloat dis =rock(ray.from,ballCenter,ballR);\n        if(dis< epsilon){ // 打中了\n            // vec3 normal = normalize(ray.from-ballCenter);\n            vec3 normal = getNormal(ray.from,ballCenter,ballR);\n            float frontLight =max(0.0,dot(normal,vec3(0.0,0.0,1.0)));\n            float backLight =max(0.0,dot(normal,vec3(0.0,0.0,-1.0)));\n            vec3 pink =vec3(1.0,0.43,0.78);\n            vec3 aqua =vec3(0.0,1.0,1.0);\n            shadingColor = frontLight* pink+0.65*backLight*aqua;\n            break;\n        }\n            \n        ray.from += dis*ray.dir;\n    }\n\n    return shadingColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // weight (from -1 to 1)\n    vec2 weight = fragCoord/iResolution.xy;\n    weight= weight*2.0-1.0;\n\n    vec3 lookAt =vec3(0.0,0.0,-50.0);\n    vec3 eye = lookAt+35.0*vec3(cos(iTime),0.0,sin(iTime));\n    \n\n    vec3 zAsix = normalize(eye-lookAt);\n    vec3 yAxis = vec3(0.0,1.0,0.0);\n    vec3 xAxis = cross(yAxis,zAsix);\n    \n    // view frustum 的近平面\n    float fovDegree =90.0;\n    float halfFov = degreeToRad(0.5*fovDegree);\n    float tanH = tan(halfFov);\n    float tanW = tanH*iResolution.x/iResolution.y;\n\n    vec3 pointOnPlane = eye-zAsix+ xAxis*weight.x*tanW+yAxis*weight.y*tanH;\n\n    // Antialiasing: 射出多條ray，最後取平均\n    Ray[4] rays =createRayDiff(eye,xAxis,yAxis,pointOnPlane);\n    \n    vec3 color= vec3(0.0,0.0,0.0);\n    for(int i=0;i<1;++i) //射1條就好了，手機跑不動\n        color += shading(rays[i]);\n    // color *=0.25;\n\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}