{"ver":"0.1","info":{"id":"tsSSDw","date":"1553969732","viewed":178,"name":"white noise reverb","username":"baskanov","description":"Using exponentially decaying white noise as a reverb filter kernel.","likes":3,"published":1,"flags":40,"usePreview":0,"tags":["noise","reverb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 soundValue = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0.5 / iResolution.y)).xy;\n\n    float yGraphCoord = (soundValue.x * 0.5 + 0.5) * iResolution.y;\n\n    vec3 col = vec3(int(fragCoord.y) == int(yGraphCoord));\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float noise(const float time)\n{\n    return fract(sin(time * 1e4 * 12.9898) * 43758.5453) * 2. - 1.;\n}\n\nfloat reverbKernel(const float time)\n{\n    const float halfLife = 0.5;\n    return 1e3 * noise(time) * exp2(-time / halfLife);\n}\n\nconst float g_envelopeFreq = 0.25;\nconst float g_envelopeDutyCycle = 0.04;\n\nfloat envelope(const float time)\n{\n    const float attackRate = 1e2;\n    const float releaseRate = 1e2;\n    float phase = fract(time * g_envelopeFreq);\n    float attackEnvelope = phase * attackRate / g_envelopeFreq;\n    float releaseEnvelope = (g_envelopeDutyCycle - phase) * releaseRate / g_envelopeFreq;\n    return clamp(min(attackEnvelope, releaseEnvelope), 0., 1.);\n}\n\nbool envelopeIsZero(const float startTime, const float endTime)\n{\n    if (startTime < 0.)\n        return false;\n\n    float startPhase = fract(startTime * g_envelopeFreq);\n    float endPhase = startPhase + (endTime - startTime) * g_envelopeFreq;\n\n    return startPhase >= g_envelopeDutyCycle && endPhase < 1.;\n}\n\nfloat wave(const float time, const float freq)\n{\n    const float pi = 3.14159265;\n    const float gain0 = 1.;\n    const float gain1 = 4.;\n    const float freqRatio0 = 2.;\n    const float freqRatio1 = 1.;\n    float phase1 = 2. * pi * freqRatio1 * freq * time;\n    float value1 = gain1 * sin(phase1);\n    float phase0 = 2. * pi * freqRatio0 * freq * time + value1;\n    float value0 = gain0 * sin(phase0);\n    return value0;\n}\n\nfloat drySound(const float time)\n{\n    float sum = 0.;\n    sum += wave(time, 440.);\n    sum += wave(time, 440. * pow(2., 3. / 12.));\n    sum += wave(time, 440. * pow(2., 7. / 12.));\n    return sum * envelope(time);\n}\n\nbool drySoundIsZero(const float startTime, const float endTime)\n{\n    return envelopeIsZero(startTime, endTime);\n}\n\nfloat reverbSound(const float time)\n{\n    const float timeLimit = 4.;\n    float sum = 0.;\n\n    /* Optimization: only compute chunks where the input signal is nonzero. */\n    const int chunkSize = 256;\n    int chunkCount = (int(iSampleRate * timeLimit) + chunkSize - 1) / chunkSize;\n    for (int chunkIndex = 0; chunkIndex < chunkCount; ++chunkIndex)\n    {\n        int startIndex = chunkIndex * chunkSize;\n        int endIndex = startIndex + chunkSize;\n        float startOffset = float(startIndex) / iSampleRate;\n        float endOffset = float(endIndex) / iSampleRate;\n        if (!drySoundIsZero(time - endOffset, time - startOffset))\n        {\n            for (int i = 0; i < chunkSize; ++i)\n            {\n                float offset = float(startIndex + i) / iSampleRate;\n                sum += drySound(time - offset) * reverbKernel(offset);\n            }\n        }\n    }\n    /* Unoptimized version. */\n    /*\n    for (float i = 0.; i < iSampleRate * timeLimit; ++i)\n    {\n        float offset = i / iSampleRate;\n        sum += drySound(time - offset) * reverbKernel(offset);\n    }\n\t*/\n\n    return sum / iSampleRate;\n}\n\nvec2 sound(float time)\n{\n    if (time < 60.)\n    \treturn vec2(reverbSound(time) * 0.05 + drySound(time) * 0.1);\n    return vec2(0.);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.y < 1.)\n    {\n        vec2 soundValue = sound(iTime + fragCoord.x / iSampleRate);\n        \n    \tfragColor = vec4(soundValue, 0., 0.);\n    }\n    else\n    {\n    \tfragColor = vec4(0.);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound(in int samp, float time)\n{\n    return sound(time);\n}\n","name":"Sound","description":"","type":"sound"}]}