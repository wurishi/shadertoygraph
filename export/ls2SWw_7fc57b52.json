{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// https://www.shadertoy.com/view/Mdj3W3\n\n#define saturate(i) ( clamp( i, 0.0, 1.0 ) )\n\nfloat DistanceToOctahedron( vec3 position, vec3 center, float radius )\n{\n   position = abs( position - center );\n   return ( position.x + position.y + position.z - radius ) * 0.333333;\n}\n\nfloat DistanceToSphere( vec3 position, vec3 center, float radius )\n{\n    return length( position - center ) - radius;\n}\n\nfloat DistanceToBox( vec3 position, vec3 center, vec3 bounds )\n{\n    position = abs( position - center );\n    vec3 d = abs( position ) - bounds;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat DistanceToBlob( vec3 position, vec3 center, float radius )\n{\n\treturn DistanceToSphere( position, center, ( 1.2 + 0.1 * sin( 5.0 * position.x ) * \n        sin( 5.0 * position.y + 8.0 * iTime ) * sin( 5.0 * position.z ) ) * radius );\n}\n\nconst float scale=3.0;\nconst vec3 offset=vec3(0.8,1.0,1.0);\nconst int iters=4;\nfloat psni=pow(scale,-float(iters));\n\n//\n\nmat4  rotationMatrix(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat4(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y, 0.0,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x, 0.0,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translate(vec3 v) {\n\treturn mat4(1.0,0.0,0.0,0.0,\n\t\t0.0,1.0,0.0,0.0,\n\t\t0.0,0.0,1.0,0.0,\n\t\tv.x,v.y,v.z,1.0);\n}\n\nmat4 scale4(float s) {\n\treturn mat4(s,0.0,0.0,0.0,\n\t\t0.0,s,0.0,0.0,\n\t\t0.0,0.0,s,0.0,\n\t\t0.0,0.0,0.0,1.0);\n}\n\n//\n\n#define Phi 1.61803398875\n\nvec3 n1 = normalize(vec3(-Phi,Phi-1.0,1.0));\nvec3 n2 = normalize(vec3(1.0,-Phi,Phi+1.0));\nvec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nvec3 plnormal = normalize( vec3( 1.0, -0.0495, 0.70298 ) );\n\nfloat Scale = 2.0;\n\nfloat DistanceEstimateToFleursfer( vec3 z )\n{\n    vec3 Offset = vec3( 0.850651, 0.525731 + sin( iTime ) * 0.05, 0.0 );\n\n    mat4 fracRotation2 = rotationMatrix(normalize(vec3( 0.0, 0.0, 1.0 )),  sin( iTime ));\n    mat4 fracRotation1 = rotationMatrix(normalize(vec3( 1.0, -1.0, 0.0 )), 0.0 );\n\n    mat4 M =  translate(Offset) * scale4(Scale) * translate(-Offset);\n    \n\tfloat dmin=-10000.;//because we are using max operator to combine DEs we need to initialize it to a big negative value. If you use min operator initialize it to some big positive value\n\tfloat s = 1.0;\n\tfor(int i=0; i<4; i++){\n\t\tfloat t = 0.0;\n\t\t// Folds.\n\t\t//Dodecahedral.. you can use other sets of foldings!\n\t\tz = abs(z);\n\t\tt=dot(z,n1); //if (t>0.0) { z-=2.0*t*n1; }\n\t\tt=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n\t\tz = abs(z);\n\t\tt=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n\t\tt=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n\t\tz = abs(z);\n\n\t\t//combine DEs... explore different combinations ;)\n\t\t//the base DE is the distance to the plane going through vec3(Size,0.,0.) and which normal is plnormal\n\t\tdmin=max(dmin,s * dot( z - vec3( 0.475, 0.0, 0. ), plnormal ) );\n        //dmin=max( dmin, DistanceToSphere( z, vec3( 0.475, 0.0, 0. ), s ) );\n\t\t\n\t\t// Rotate, scale, rotate (we need to cast to a 4-component vector).\n\t\tz = (M*vec4(z,1.0)).xyz;\n        s/=Scale;\n\t}\n\treturn dmin;//you can take a look to the inside\n}\n\n//\n\nfloat DistanceEstimateToMenger( in vec3 position )\n{\n\tfor( int n = 0; n < iters; n++ ) \n    {\n\t\tposition = abs( position );\n        \n\t\tif( position.x < position.y)\n            position.xy = position.yx;\n\t\tif( position.x < position.z)\n            position.xz = position.zx;\n\t\tif( position.y < position.z)\n            position.yz = position.zy;\n        \n\t\tposition = position * scale - offset * ( scale - 1.0 );\n        \n\t\tif( position.z < -0.5 * offset.z * ( scale - 1.0 ) )\n            position.z += offset.z * ( scale - 1.0 );\n\t}\n\treturn DistanceToBox( position, vec3( 0.0 ), vec3( scale * 0.5 ) ) * psni;\n}\n\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat SampleDistanceField( vec3 position )\n{\n    /*float dist = min( \n        DistanceToBox( position, vec3( 0.0, 0.0, 0.0 ), vec3( 0.5 ) ),\n        DistanceToBlob( position, vec3( 1.5 * sin( iTime ), 0.0, 1.5 * cos( iTime ) ), 0.5 )\n        );\n    dist = min( DEMenger( position ), dist );*/\n    return DistanceEstimateToFleursfer( position );\n\t//return DistanceToBox( position, vec3( 0.0 ), vec3( 0.5 ) );\n}\n\nvec3 CalculateNormalAdvanced( vec3 pos, float normalDistance ) \n{\n\tnormalDistance = max( normalDistance * 0.5, 1.0e-7 );\n\tvec3 e = vec3( 0.0, normalDistance, 0.0 );\n\tvec3 n = vec3(\n        SampleDistanceField( pos + e.yxx ) - SampleDistanceField( pos - e.yxx ),\n\t\tSampleDistanceField( pos + e.xyx ) - SampleDistanceField( pos - e.xyx ),\n\t\tSampleDistanceField( pos + e.xxy ) - SampleDistanceField( pos - e.xxy ) );\n\treturn normalize(n);\n}\n\nvec3 CalculateNormalAlternate( vec3 p, float radius )\n{\n\tvec3 eps = vec3( radius, 0.0, 0.0 );\n\tfloat dfp = SampleDistanceField(p);\n\treturn normalize( vec3(\n\t\t( SampleDistanceField( p + eps.xyy ) - dfp ),\n\t\t( SampleDistanceField( p + eps.yxy ) - dfp ),\n\t\t( SampleDistanceField( p + eps.yyx ) - dfp ) ) );\n}\n\nvec3 CalculateNormal( in vec3 position, float radius )\n{\n\tvec3 eps = vec3( radius, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    SampleDistanceField(position+eps.xyy) - SampleDistanceField(position-eps.xyy),\n\t    SampleDistanceField(position+eps.yxy) - SampleDistanceField(position-eps.yxy),\n\t    SampleDistanceField(position+eps.yyx) - SampleDistanceField(position-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat focalDistance = 2.0, aperture = 0.03, fudgeFactor = 0.8, shadowCone = 0.5;\n\nfloat CircleOfConfusion( float len )\n{\n\tfloat pixelRadius = 0.5 / iResolution.y;\n\treturn max( abs( focalDistance - len ) * aperture, pixelRadius * ( 1.0 + len ) );\n}\n\nconst int maxmarchsteps = 75;\nconst float farPlane = 2.5, nearPlane = 0.25;\nconst float tau = 6.28318530717958647692;\n\nfloat Softshadow( in vec3 ro, in vec3 rd, float t, float k )\n{\n    float res = 1.0, h = 0.0;\n    for( int i = 0; i < 18; i++ )\n    {\n        h = SampleDistanceField(ro + rd*t);\n        if( h<0.01 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat AmbientOcclusion(vec3 p, vec3 n, float eps ) \n{\n\tfloat ao = 0.0;\n\tfloat de = SampleDistanceField(p);\n\tfloat wSum = 0.0;\n\tfloat w = 1.0;\n\tfloat d = 1.0;\n\tfor (float i =1.0; i <6.0; i++) \n    {\n\t\t// D is the distance estimate difference.\n\t\t// If we move 'n' units in the normal direction,\n\t\t// we would expect the DE difference to be 'n' larger -\n\t\t// unless there is some obstructing geometry in place\n\t\tfloat D = (SampleDistanceField(p+ d*n*i*i*eps) -de)/(d*i*i*eps);\n        \n\t\tw *= 2.25;\n\t\tao += w * saturate( 1.0 - D );\n\t\twSum += w;\n\t}\n\treturn 1.0 - saturate( ao / wSum );\n}\n\nvec3 combineNormals2(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;    \n\tn0  = vec3(n0.xy * n1.z + n1.xy * n0.z, n0.z * n1.z);    \n    return normalize(n0) * 0.5 + 0.5;\n}\n\nvec3 DoLight( vec3 origin, vec3 light, vec3 normal, float depth )\n{\n    float n_dot_l = saturate( dot( normalize( light ), normal ) );\n    return vec3( n_dot_l ) * Softshadow( origin, normalize( light ), 0.05, 16.0 );\n}\n\nvec3 GetColorMain( vec3 viewDirection, vec3 position, float eps )\n{\n    vec3 normal = CalculateNormalAdvanced( position, eps );\n    \n    float derivative = length( fwidth( position ) );\n    if( derivative > 0.25 )\n    {\n        vec3 newNormal = CalculateNormalAdvanced( position - viewDirection * eps * 1.5, eps * 1.5 );\n        normal = normalize( normal + newNormal );\n    }\n    \n    float n_dot_v = saturate( dot( -viewDirection, normal ) );\n    vec3 incidentReflection = reflect( viewDirection, normal );\n    vec3 light1 = vec3( 1.0, 0.0, 0.0 );\n    \n    float ambient = 1.0 - n_dot_v; ambient *= ambient;\n    ambient *= texture( iChannel0, incidentReflection ).g;\n    ambient *= 0.5 + AmbientOcclusion( position, normal, eps ) * 0.5;\n\n    vec3 lights = vec3( 0.0 );\n   \t//lights += DoLight( position, vec3( 100.0, sin( iTime * 0.3 ), 100.0 ), normal, depth ) * 0.5; //sin( iTime * 0.3 )\n    \n    vec3 color = vec3( 0.333 * ambient + lights );\n    return color;\n}\n\nvec3 GetColor( vec3 viewDirection, vec3 position, float depth )\n{\n\tfloat pixelRadius = 0.5 / iResolution.y;\n    float eps = pixelRadius * depth * 3.0;\n    \n    //vec3 normal = CalculateNormalAdvanced( position, eps );\n    vec3 backStepPositionOne = position - viewDirection * eps * 1.5;\n    //vec3 backStepPositionTwo = position - viewDirection * eps;\n    \n    vec3 color = GetColorMain( viewDirection, backStepPositionOne, eps );\n    return color;\n}\n\n//\n\nfloat LinearToSRGBSingleChannel( float lin )\n{\n\tif( lin < 0.00313067 ) return lin * 12.92;\n\treturn pow( lin, 1.0 / 2.4 ) * 1.055 - 0.055;\n}\n\nvec3 linearToSRGB( in vec3 linearCol )\n{\n\treturn vec3(\n\t\tLinearToSRGBSingleChannel( linearCol.r ),\n\t\tLinearToSRGBSingleChannel( linearCol.g ),\n\t\tLinearToSRGBSingleChannel( linearCol.b )\n    );\n}\n\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nvec3 Uncharted2Tonemap(vec3 x)\n{\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat pixelRadius = 0.5 / iResolution.y;\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n\tvec3 cameraPosition = vec3( sin( iTime * 0.2 ), \n                                cos( iTime * 0.2 ), \n                               \tsin( iTime * 0.2 ) );\n    \n\tvec3 cameraTarget   = vec3( 0.0 );\n\tvec3 cameraUp       = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cameraDirection   = normalize( cameraTarget - cameraPosition );\n    \n\tvec3 cameraRight = normalize( cross( cameraUp, cameraDirection ) );\n\tcameraUp = normalize( cross( cameraDirection, cameraRight ) );\n\n    vec3 rayOrigin    = cameraPosition;\n    vec3 rayDirection = normalize( cameraDirection + uv.x * cameraRight + uv.y * cameraUp );\n    vec3 rayPosition  = rayOrigin;\n    \n    vec2 trap = vec2( farPlane );\n    float rayProgress   = 0.0; float progressOverOne = 1.0 / float( maxmarchsteps );\n    float rayDistance   = 0.0, currentDistance = farPlane, previousDistance = farPlane;\n    float overstep      = 0.0;\n    float overstepScale = 0.007;\n    float MinStepSize   = 1.0 / float( 4 * maxmarchsteps );\n    float errorVis \t\t= 0.0;\n    \n    for( int i = 0; i < maxmarchsteps; ++i ) \n    {\n        rayPosition = rayDirection * rayDistance + rayOrigin;\n        currentDistance = SampleDistanceField( rayPosition );\n        \n\t\t/*float dNext_over_d = currentDistance / previousDistance;\n\t\tif( dNext_over_d < 0.0 )\n\t\t{\n\t\t\tpreviousDistance /= 1.0 - dNext_over_d;\n\t\t\tcurrentDistance = SampleDistanceField( rayDirection \n                                               * ( rayDistance + previousDistance ) \n                                               + rayOrigin );\n            break;\n\t\t}*/\n        \n        if( currentDistance > overstep )\n        {\n            if( currentDistance > previousDistance && previousDistance < trap.x )\n                trap = vec2( previousDistance, rayDistance );\n            \n            overstep = overstepScale * currentDistance;// * currentDistance / previousDistance;\n            rayDistance += currentDistance + overstep;//max( currentDistance + overstep, MinStepSize );\n        }\n        else\n        {\n\t\t\t//overstep    *= 0.5;\n\t\t\trayDistance -= overstep;\n            break;\n        }\n\n        if( rayDistance > farPlane || overstep < 0.0000025 )\n            break;\n        \n       \trayProgress += ( 1.0 - saturate( rayDistance / farPlane ) ) * progressOverOne;\n        previousDistance = currentDistance;\n    }\n    \n    //rayDirection = normalize( rayPosition - rayOrigin );\n    \n    vec3 color = vec3( 0.00125 );\n   \tif( currentDistance < pixelRadius * rayDistance * 4.0 )\n\t\tcolor = GetColor( rayDirection, rayPosition, rayDistance );\n    \n\tcurrentDistance = pixelRadius * trap.y * 2.5;\n\tif( trap.x < currentDistance )\n       // color.g = 1.0;\n        color = mix( GetColor( rayDirection, rayOrigin + rayDirection * trap.y, trap.y ), \n        \tcolor, smoothstep( 0.0, currentDistance, trap.x ) );\n    \n    //\n\n    float ExposureBias = 7.0;\n    vec3 curr = Uncharted2Tonemap( ExposureBias * color );\n\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap( vec3( W ) );\n    color = curr * whiteScale;\n    \n    //\n\n\tfragColor = vec4( vec3( LinearToSRGBSingleChannel( color.g ) ), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2SWw","date":"1412806458","viewed":155,"name":"Fleursfer","username":"Orihaus","description":"https://twitter.com/_threeWiseMen/status/520289091607601152","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}