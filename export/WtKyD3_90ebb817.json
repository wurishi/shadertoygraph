{"ver":"0.1","info":{"id":"WtKyD3","date":"1686397523","viewed":321,"name":"LTC VIDEO TEST","username":"MartinRGB","description":"ltc video research\nltc shader from https://www.shadertoy.com/view/wlGSDK\ntesla shader from https://www.shadertoy.com/view/wdGXzK","likes":26,"published":1,"flags":32,"usePreview":1,"tags":["ltcvideotest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code modified EvilRyu by JuliaPoo\n// https://www.shadertoy.com/view/4tBBDK\n\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n\nconst float intensity = 1.5;\nconst float light_width = .7;\nconst float light_height = 0.5;\n\nconst vec3 light_col = vec3(1.0)*intensity;\nconst vec3 light_pos = vec3(0., 0.3, 0.);\nconst vec3 light_normal = vec3(0., 0., 1.);\n\n\nconst float PI = 3.1415926;\nconst float LUTSIZE  = 8.0;\nconst float MATRIX_PARAM_OFFSET = 8.0;\n\nconst mat2 R_obj2 = mat2(\n        \t\t\t0.955336489125606,-0.295520206661339,\n        \t\t\t0.295520206661339, 0.955336489125606\n                  \t);\n\n\n\nfloat rect(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid init_rect_points(out vec3 points[4])\n{\n    // get the orthogonal basis of polygon light\n    vec3 right=normalize(cross(light_normal, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, light_normal));\n    \n    vec3 ex = light_width * right;\n    vec3 ey = light_height * up;\n\n    points[0] = light_pos - ex - ey;\n    points[1] = light_pos + ex - ey;\n    points[2] = light_pos + ex + ey;\n    points[3] = light_pos - ex + ey;\n}\n\n\n#define LIGHT 0.\n#define FLOOR 1.\n#define OBJ1  2.\n#define OBJ2  3.\n\nfloat object_id = 0.;\n\n\nfloat map(vec3 p)\n{\n    vec3 p0 = p;\n    p0.xz *= R_obj2;\n    \n    float d0=rect(p-light_pos, vec3(light_width, light_height, 0.));\n    \n    float d1;\n    if (abs(p.y + .5) > .015) d1 = abs(p.y+.5);\n    else d1=abs(p.y+0.5+texture(iChannel1, p.xz).x*.01)*.9;\n    \n   \tfloat d = d0;\n    object_id = LIGHT;\n    \n    if(d > d1)\n    {\n        d = d1;\n        object_id=FLOOR;\n    }\n    \n    \n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c < 0.005 ) break;\n        t += c;\n        if( t>50.0 ) return -1.0;\n    }\n    return t;\n}\n\n\n// Linearly Transformed Cosines \n\nfloat IntegrateEdge(vec3 v1, vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);    \n    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);\n\n    return res;\n}\n\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n)\n{\n    // detect clipping config\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n\n    // clip\n    n = 0;\n\n    if (config == 0)\n    {\n        // clip all\n    }\n    else if (config == 1) // V1 clip V2 V3 V4\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2) // V2 clip V1 V3 V4\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3) // V1 V2 clip V3 V4\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4) // V3 clip V1 V2 V4\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5) // V1 V3 clip V2 V4) impossible\n    {\n        n = 0;\n    }\n    else if (config == 6) // V2 V3 clip V1 V4\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7) // V1 V2 V3 clip V4\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8) // V4 clip V1 V2 V3\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9) // V1 V4 clip V2 V3\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10) // V2 V4 clip V1 V3) impossible\n    {\n        n = 0;\n    }\n    else if (config == 11) // V1 V2 V4 clip V3\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12) // V3 V4 clip V1 V2\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13) // V1 V3 V4 clip V2\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14) // V2 V3 V4 clip V1\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15) // V1 V2 V3 V4\n    {\n        n = 4;\n    }\n    \n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\n\n\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4])\n{\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n\n    // rotate area light in (T1, T2, N) basis\n    Minv = Minv * transpose(mat3(T1, T2, N));\n\n    // polygon (allocate 5 vertices for clipping)\n    vec3 L[5];\n    L[0] = Minv * (points[0] - P);\n    L[1] = Minv * (points[1] - P);\n    L[2] = Minv * (points[2] - P);\n    L[3] = Minv * (points[3] - P);\n\n    int n=0;\n    // The integration is assumed on the upper hemisphere\n    // so we need to clip the frustum, the clipping will add \n    // at most 1 edge, that's why L is declared 5 elements.\n    ClipQuadToHorizon(L, n);\n    \n    if (n == 0)\n        return vec3(0, 0, 0);\n\n    // project onto sphere\n    vec3 PL[5];\n    PL[0] = normalize(L[0]);\n    PL[1] = normalize(L[1]);\n    PL[2] = normalize(L[2]);\n    PL[3] = normalize(L[3]);\n    PL[4] = normalize(L[4]);\n\n    // integrate for every edge.\n    float sum = 0.0;\n\n    sum += IntegrateEdge(PL[0], PL[1]);\n    sum += IntegrateEdge(PL[1], PL[2]);\n    sum += IntegrateEdge(PL[2], PL[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(PL[3], PL[4]);\n    if (n == 5)\n        sum += IntegrateEdge(PL[4], PL[0]);\n\n    sum =  max(0.0, sum);\n    \n    // Calculate colour\n    vec3 e1 = normalize(L[0] - L[1]);\n    vec3 e2 = normalize(L[2] - L[1]);\n    vec3 N2 = cross(e1, e2); // Normal to light\n    vec3 V2 = N2 * dot(L[1], N2); // Vector to some point in light rect\n    vec2 Tlight_shape = vec2(length(L[0] - L[1]), length(L[2] - L[1]));\n    V2 = V2 - L[1];\n    float b = e1.y*e2.x - e1.x*e2.y + .1; // + .1 to remove artifacts\n\tvec2 pLight = vec2((V2.y*e2.x - V2.x*e2.y)/b, (V2.x*e1.y - V2.y*e1.x)/b);\n   \tpLight /= Tlight_shape;\n    //pLight -= .5;\n    //pLight /= 2.5;\n    //pLight += .5;\n    \n    vec3 ref_col = texture(iChannel2, pLight).xyz;\n\n    vec3 Lo_i = vec3(sum) * ref_col;\n\n    return Lo_i;\n}\n\n    \n/////////////////////////////////////////////\n\n\nvoid  LTC_shading_Diff(float roughness, \n                 vec3 N, \n                 vec3 V, \n                 vec3 pos, \n                 vec3[4] points, \n                 vec3 m_diff,\n                 inout vec3 col\n                 )\n{\n    \n    \n    float theta = acos(dot(N, V));\n    vec2 uv = vec2(roughness, theta/(0.5*PI)) * float(LUTSIZE-1.);   \n    vec2 wx = uv/iChannelResolution[0].xy;\n            \n    // The offset to get correct interpolation\n    uv += vec2(0.5);\n\n    vec4 params = texture(iChannel0, uv);\n\n    // The inverse transformation matrix, so we \n    // can integrate cosine distribution over the polygon \n    // transformed by this matrix, instead of integrating the\n    // complicated brdf over the untransformed polygon.\n    mat3 Minv = mat3(\n        vec3(  1,        0,      params.y),\n        vec3(  0,     params.z,   0),\n        vec3(params.w,   0,      params.x)\n    );\n\n\n    vec3 diff = LTC_Evaluate(N, V, pos, mat3(1), points)*m_diff; \n\n    col  = light_col*m_diff*diff;\n    col /= 2.0*PI;\n}\n\nvoid LTC_shading_Spec(float roughness, \n                 vec3 N, \n                 vec3 V, \n                 vec3 pos, \n                 vec3[4] points, \n                 vec3 m_spec,\n                 inout vec3 col\n                 )\n{\n    \n    \n    float theta = acos(dot(N, V));\n    vec2 uv = vec2(roughness, theta/(0.5*PI)) * float(LUTSIZE-1.);   \n    vec2 wx = uv/iChannelResolution[0].xy;\n            \n    // The offset to get correct interpolation\n    uv += vec2(0.5);\n\n    vec4 params = texture(iChannel0, (uv+vec2(MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[0].xy);\n\n    // The inverse transformation matrix, so we \n    // can integrate cosine distribution over the polygon \n    // transformed by this matrix, instead of integrating the\n    // complicated brdf over the untransformed polygon.\n    mat3 Minv = mat3(\n        vec3(  1,        0,      params.y),\n        vec3(  0,     params.z,   0),\n        vec3(params.w,   0,      params.x)\n    );\n            \n\n    vec3 spec = LTC_Evaluate(N, V, pos, Minv, points)*m_spec;\n\n    spec *= texture(iChannel0, uv/iChannelResolution[0].xy).x;\n\n\n    col  = light_col*m_spec*spec;\n    col /= 2.0*PI;\n}\n\nvoid store_buf(in vec2 pos,in vec4 val,in vec2 fragCoord,inout vec4 fragColor)\n{\n    const float error = 0.5;\n    if(abs(fragCoord.x-pos.x)<error&&abs(fragCoord.y-pos.y)<error)\n        fragColor=val;\n}\n\n// The first 8x8 stores the normalization\n// The second 8x8 stores the matrix parameters\n\nvoid setLUT(in vec2 fragCoord, inout vec4 fragColor)\n{\n    store_buf(vec2(0.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(2.5, 0.5), vec4(0.999138), fragCoord, fragColor);\n    store_buf(vec2(3.5, 0.5), vec4(0.953919), fragCoord, fragColor);\n    store_buf(vec2(4.5, 0.5), vec4(0.855017), fragCoord, fragColor);\n    store_buf(vec2(5.5, 0.5), vec4(0.677721), fragCoord, fragColor);\n    store_buf(vec2(6.5, 0.5), vec4(0.475624), fragCoord, fragColor);\n    store_buf(vec2(7.5, 0.5), vec4(0.306905), fragCoord, fragColor);\n    store_buf(vec2(0.5, 1.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 1.5), vec4(0.999990), fragCoord, fragColor);\n    store_buf(vec2(2.5, 1.5), vec4(0.995492), fragCoord, fragColor);\n    store_buf(vec2(3.5, 1.5), vec4(0.955938), fragCoord, fragColor);\n    store_buf(vec2(4.5, 1.5), vec4(0.852346), fragCoord, fragColor);\n    store_buf(vec2(5.5, 1.5), vec4(0.676815), fragCoord, fragColor);\n    store_buf(vec2(6.5, 1.5), vec4(0.478562), fragCoord, fragColor);\n    store_buf(vec2(7.5, 1.5), vec4(0.311751), fragCoord, fragColor);\n    store_buf(vec2(0.5, 2.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 2.5), vec4(0.999952), fragCoord, fragColor);\n    store_buf(vec2(2.5, 2.5), vec4(0.993337), fragCoord, fragColor);\n    store_buf(vec2(3.5, 2.5), vec4(0.950365), fragCoord, fragColor);\n    store_buf(vec2(4.5, 2.5), vec4(0.844905), fragCoord, fragColor);\n    store_buf(vec2(5.5, 2.5), vec4(0.674537), fragCoord, fragColor);\n    store_buf(vec2(6.5, 2.5), vec4(0.487632), fragCoord, fragColor);\n    store_buf(vec2(7.5, 2.5), vec4(0.327273), fragCoord, fragColor);\n    store_buf(vec2(0.5, 3.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 3.5), vec4(0.999865), fragCoord, fragColor);\n    store_buf(vec2(2.5, 3.5), vec4(0.991766), fragCoord, fragColor);\n    store_buf(vec2(3.5, 3.5), vec4(0.942684), fragCoord, fragColor);\n    store_buf(vec2(4.5, 3.5), vec4(0.831852), fragCoord, fragColor);\n    store_buf(vec2(5.5, 3.5), vec4(0.673589), fragCoord, fragColor);\n    store_buf(vec2(6.5, 3.5), vec4(0.505564), fragCoord, fragColor);\n    store_buf(vec2(7.5, 3.5), vec4(0.355949), fragCoord, fragColor);\n    store_buf(vec2(0.5, 4.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 4.5), vec4(0.999665), fragCoord, fragColor);\n    store_buf(vec2(2.5, 4.5), vec4(0.986371), fragCoord, fragColor);\n    store_buf(vec2(3.5, 4.5), vec4(0.930421), fragCoord, fragColor);\n    store_buf(vec2(4.5, 4.5), vec4(0.813602), fragCoord, fragColor);\n    store_buf(vec2(5.5, 4.5), vec4(0.678975), fragCoord, fragColor);\n    store_buf(vec2(6.5, 4.5), vec4(0.537882), fragCoord, fragColor);\n    store_buf(vec2(7.5, 4.5), vec4(0.403271), fragCoord, fragColor);\n    store_buf(vec2(0.5, 5.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 5.5), vec4(0.999025), fragCoord, fragColor);\n    store_buf(vec2(2.5, 5.5), vec4(0.973317), fragCoord, fragColor);\n    store_buf(vec2(3.5, 5.5), vec4(0.900245), fragCoord, fragColor);\n    store_buf(vec2(4.5, 5.5), vec4(0.804126), fragCoord, fragColor);\n    store_buf(vec2(5.5, 5.5), vec4(0.703751), fragCoord, fragColor);\n    store_buf(vec2(6.5, 5.5), vec4(0.594890), fragCoord, fragColor);\n    store_buf(vec2(7.5, 5.5), vec4(0.481143), fragCoord, fragColor);\n    store_buf(vec2(0.5, 6.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 6.5), vec4(0.992850), fragCoord, fragColor);\n    store_buf(vec2(2.5, 6.5), vec4(0.926124), fragCoord, fragColor);\n    store_buf(vec2(3.5, 6.5), vec4(0.860745), fragCoord, fragColor);\n    store_buf(vec2(4.5, 6.5), vec4(0.833379), fragCoord, fragColor);\n    store_buf(vec2(5.5, 6.5), vec4(0.782873), fragCoord, fragColor);\n    store_buf(vec2(6.5, 6.5), vec4(0.703637), fragCoord, fragColor);\n    store_buf(vec2(7.5, 6.5), vec4(0.620129), fragCoord, fragColor);\n    store_buf(vec2(0.5, 7.5), vec4(0.987461), fragCoord, fragColor);\n    store_buf(vec2(1.5, 7.5), vec4(0.938899), fragCoord, fragColor);\n    store_buf(vec2(2.5, 7.5), vec4(0.942983), fragCoord, fragColor);\n    store_buf(vec2(3.5, 7.5), vec4(0.943682), fragCoord, fragColor);\n    store_buf(vec2(4.5, 7.5), vec4(0.943818), fragCoord, fragColor);\n    store_buf(vec2(5.5, 7.5), vec4(0.943681), fragCoord, fragColor);\n    store_buf(vec2(6.5, 7.5), vec4(0.943351), fragCoord, fragColor);\n    store_buf(vec2(7.5, 7.5), vec4(0.942877), fragCoord, fragColor);\n\n    float BIAS = 8.;\n    \n    store_buf(vec2(BIAS+0.5, 0.5), vec4(0.000200, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 0.5), vec4(0.040821, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 0.5), vec4(0.163499, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 0.5), vec4(0.359810, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 0.5), vec4(0.608219, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 0.5), vec4(0.849327, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 0.5), vec4(1.026876, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 0.5), vec4(1.127918, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 1.5), vec4(0.000200, -0.000046, 1.052217, 0.228243), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 1.5), vec4(0.040821, -0.009316, 1.052066, 0.228242), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 1.5), vec4(0.163218, -0.036566, 1.051517, 0.228141), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 1.5), vec4(0.360871, -0.077435, 1.049110, 0.226851), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 1.5), vec4(0.608870, -0.112986, 1.040456, 0.216178), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 1.5), vec4(0.850681, -0.110371, 1.022363, 0.171798), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 1.5), vec4(1.033758, -0.063836, 1.011022, 0.089896), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 1.5), vec4(1.130218, 0.000062, 1.000010, -0.000080), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 2.5), vec4(0.000200, -0.000096, 1.232269, 0.481573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 2.5), vec4(0.040829, -0.019653, 1.232083, 0.481559), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 2.5), vec4(0.163323, -0.077152, 1.229494, 0.481157), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 2.5), vec4(0.361362, -0.161748, 1.215935, 0.476966), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 2.5), vec4(0.602530, -0.224893, 1.149731, 0.444834), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 2.5), vec4(0.832866, -0.211716, 1.066321, 0.339254), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 2.5), vec4(1.033638, -0.123274, 1.025543, 0.170803), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 2.5), vec4(1.137644, 0.000154, 0.999953, -0.000082), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 3.5), vec4(0.000199, -0.000159, 1.627474, 0.797472), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 3.5), vec4(0.040836, -0.032524, 1.635685, 0.797401), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 3.5), vec4(0.164108, -0.127318, 1.628042, 0.795956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 3.5), vec4(0.365844, -0.258932, 1.575327, 0.783120), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 3.5), vec4(0.602895, -0.339455, 1.372632, 0.710306), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 3.5), vec4(0.825683, -0.302224, 1.158343, 0.512880), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 3.5), vec4(1.030563, -0.173519, 1.049980, 0.243539), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 3.5), vec4(1.151713, 0.000105, 0.999957, -0.000055), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 4.5), vec4(0.000198, -0.000248, 2.529443, 1.253956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 4.5), vec4(0.040880, -0.051100, 2.570697, 1.253684), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 4.5), vec4(0.166706, -0.198049, 2.542881, 1.248409), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 4.5), vec4(0.380361, -0.384441, 2.334701, 1.206127), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 4.5), vec4(0.617299, -0.459699, 1.772357, 1.025249), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 4.5), vec4(0.835445, -0.380695, 1.304201, 0.680722), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 4.5), vec4(1.040850, -0.213042, 1.089431, 0.306573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 4.5), vec4(1.176060, 0.000010, 1.000023, -0.000021), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 5.5), vec4(0.000187, -0.000388, 4.301116, 2.076506), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 5.5), vec4(0.041070, -0.084546, 5.305590, 2.075270), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 5.5), vec4(0.175521, -0.321638, 5.161014, 2.051541), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 5.5), vec4(0.413187, -0.560077, 4.055352, 1.869406), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 5.5), vec4(0.665130, -0.580464, 2.432246, 1.376237), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 5.5), vec4(0.870094, -0.441204, 1.506300, 0.819691), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 5.5), vec4(1.068578, -0.241436, 1.137736, 0.354430), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 5.5), vec4(1.219174, -0.000534, 1.000063, 0.000162), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 6.5), vec4(0.000144, -0.000631, 6.468958, 4.381222), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 6.5), vec4(0.042200, -0.177353, 20.085962, 4.369584), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 6.5), vec4(0.209979, -0.606367, 16.868328, 4.106197), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 6.5), vec4(0.500901, -0.795643, 8.099620, 2.893355), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 6.5), vec4(0.769693, -0.688227, 3.439625, 1.659662), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 6.5), vec4(0.955036, -0.470746, 1.760819, 0.883184), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 6.5), vec4(1.134532, -0.254869, 1.190455, 0.377490), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 6.5), vec4(1.308330, -0.002944, 0.999844, 0.001275), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 7.5), vec4(0.000102, -0.118482, 1184.816772, 1184.816284), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 7.5), vec4(0.319603, -3.097308, 7133.888672, 23.645655), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 7.5), vec4(0.546638, -1.442077, 133.966263, 8.593670), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 7.5), vec4(0.837342, -1.129903, 20.226521, 3.658263), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 7.5), vec4(1.004258, -0.809128, 5.700182, 1.768790), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 7.5), vec4(1.117055, -0.531464, 2.269246, 0.923613), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 7.5), vec4(1.336692, -0.312752, 1.241618, 0.414403), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 7.5), vec4(1.670654, -0.056394, 0.998759, 0.033416), fragCoord, fragColor);\n}\n\n\nvoid LTC_shading(float roughness, \n                 vec3 N, \n                 vec3 V, \n                 vec3 pos, \n                 vec3[4] points, \n                 vec3 m_spec,\n                 vec3 m_diff,\n                 vec2 fragCoord,\n                 inout vec3 col\n                 )\n{\n    \n    \n    const float M_PI = 3.1415926;\n    const float M_LUTSIZE  = 8.0;\n    const float M_MATRIX_PARAM_OFFSET = 8.0;\n    \n    \n    const float N_PI = 3.1415926;\n    const float N_LUTSIZE  = 8.0;\n    const float N_MATRIX_PARAM_OFFSET = 8.0;\n    \n    float theta = acos(dot(N, V));\n    \n    vec2 uv = vec2(roughness, theta/(0.5*M_PI)) * float(M_LUTSIZE-1.);   \n            \n    // The offset to get correct interpolation\n    uv += vec2(0.5 );\n    \n    \n    vec2 n_uv = vec2(roughness, theta/(0.5*N_PI)) * float(N_LUTSIZE-1.);   \n            \n    // The offset to get correct interpolation\n    n_uv += vec2(0.5);\n    \n    \n    //vec4 params = texture(iChannel0, (n_uv+vec2(N_MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[0].xy);\n    \n    //params = texture(iChannel3, (uv+vec2(MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[3].xy);\n\n    vec4 params;\n    setLUT(n_uv+vec2(N_MATRIX_PARAM_OFFSET, 0.0),params);\n\n    //params = texture(iChannel0, (n_uv+vec2(N_MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[0].xy);\n\n    // The inverse transformation matrix, so we \n    // can integrate cosine distribution over the polygon \n    // transformed by this matrix, instead of integrating the\n    // complicated brdf over the untransformed polygon.\n    mat3 Minv = mat3(\n        vec3(  1,        0,      params.y),\n        vec3(  0,     params.z,   0),\n        vec3(params.w,   0,      params.x)\n    );\n\n    vec3 spec = LTC_Evaluate(N, V, pos, Minv, points)*m_spec;\n\n    //spec *= texture(iChannel0, uv/iChannelResolution[0].xy).x;\n    \n    vec3 diff = LTC_Evaluate(N, V, pos, mat3(1), points)*m_diff; \n\n    col  = light_col*(m_spec*spec+m_diff*diff);\n    col /= 2.0*PI;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    vec3 lookat = vec3(0.0, -0.5*light_height, 0.);\n    vec2 M = iMouse.xy;\n    M += iResolution.xy * vec2(.2, .2);\n    M = iResolution.xy * vec2(.3, .5);\n    float c0 = cos(M.x/iResolution.x * 3.);\n    float c1 = cos(M.y/iResolution.y * 3.);\n    float s0 = sin(M.x/iResolution.y * 3.);\n    float s1 = sin(M.y/iResolution.y * 3.);\n    mat2 R1 = mat2(\n                   \tc0,-s0,\n        \t\t\ts0, c0\n                  );\n   \tmat2 R2 = mat2(\n        \t\t\tc1,-s1,\n        \t\t\ts1, c1\n                  );\n\tvec3 ro = vec3(2.5, 0., 0.);\n    ro.xy *= R1;\n    ro.yz *= R2;\n    ro -= lookat;\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    \n    vec3 points[4];\n    \n    // setup the four vertices for the rect light\n    init_rect_points(points);\n\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    vec3 diffCol = vec3(0.);\n    vec3 specCol = vec3(0.);\n    if(t>-0.5)\n    {\n        \n        vec3 pos = ro + rd * t;\n        vec3 N = get_normal(pos);\n        vec3 V = -rd;\n        \n        if (object_id == LIGHT)\n        {\n            vec2 screen_pos = (pos.xy + vec2(light_width, .5-light_pos.y))/(vec2(light_width, light_height) * 2.);\n            col = texture(iChannel2, screen_pos).xyz;\n        }\n        else\n        {\n            vec3 diff; vec3 spec;\n            float roughness;\n            \n            if(object_id == FLOOR)\n            {            \n\n                roughness = texture(iChannel1, pos.xz).x;\n                roughness *= roughness;\n                roughness += 0.2;\n\n                diff = vec3(1.3);\n                spec = texture(iChannel1, pos.xz).xyz;\n\n            }\n            LTC_shading_Diff(roughness, N, V, pos, points, diff, diffCol);\n            LTC_shading_Spec(roughness, N, V, pos, points, spec, specCol);\n            LTC_shading(roughness, N, V, pos, points, diff,spec, fragCoord,col);\n            \n        }\n        \n\n    }\n    //col = diffCol*0.05 + specCol*4.;\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    //col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor =vec4(col,1.);\n    //fragColor =texture(iChannel0,fragCoord.xy/iResolution.xy);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// The inverse of the transformation matrix M is precomputed and \n// stored in this buffer as a lookup table.\n// The matrix is used to transform cosine distribution to whatever \n// brdf we like.\n// Refer to:  https://labs.unity.com/article/real-time-polygonal-light-shading-linearly-transformed-cosines\n\nvoid store_buf(vec2 pos,vec4 val,vec2 fragCoord,inout vec4 fragColor)\n{\n    if(abs(fragCoord.x-pos.x)<0.01&&abs(fragCoord.y-pos.y)<0.01)\n        fragColor=val;\n}\n\n// The first 8x8 stores the normalization\n// The second 8x8 stores the matrix parameters\n\nvoid setLUT(vec2 fragCoord, inout vec4 fragColor)\n{\n    store_buf(vec2(0.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(2.5, 0.5), vec4(0.999138), fragCoord, fragColor);\n    store_buf(vec2(3.5, 0.5), vec4(0.953919), fragCoord, fragColor);\n    store_buf(vec2(4.5, 0.5), vec4(0.855017), fragCoord, fragColor);\n    store_buf(vec2(5.5, 0.5), vec4(0.677721), fragCoord, fragColor);\n    store_buf(vec2(6.5, 0.5), vec4(0.475624), fragCoord, fragColor);\n    store_buf(vec2(7.5, 0.5), vec4(0.306905), fragCoord, fragColor);\n    store_buf(vec2(0.5, 1.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 1.5), vec4(0.999990), fragCoord, fragColor);\n    store_buf(vec2(2.5, 1.5), vec4(0.995492), fragCoord, fragColor);\n    store_buf(vec2(3.5, 1.5), vec4(0.955938), fragCoord, fragColor);\n    store_buf(vec2(4.5, 1.5), vec4(0.852346), fragCoord, fragColor);\n    store_buf(vec2(5.5, 1.5), vec4(0.676815), fragCoord, fragColor);\n    store_buf(vec2(6.5, 1.5), vec4(0.478562), fragCoord, fragColor);\n    store_buf(vec2(7.5, 1.5), vec4(0.311751), fragCoord, fragColor);\n    store_buf(vec2(0.5, 2.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 2.5), vec4(0.999952), fragCoord, fragColor);\n    store_buf(vec2(2.5, 2.5), vec4(0.993337), fragCoord, fragColor);\n    store_buf(vec2(3.5, 2.5), vec4(0.950365), fragCoord, fragColor);\n    store_buf(vec2(4.5, 2.5), vec4(0.844905), fragCoord, fragColor);\n    store_buf(vec2(5.5, 2.5), vec4(0.674537), fragCoord, fragColor);\n    store_buf(vec2(6.5, 2.5), vec4(0.487632), fragCoord, fragColor);\n    store_buf(vec2(7.5, 2.5), vec4(0.327273), fragCoord, fragColor);\n    store_buf(vec2(0.5, 3.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 3.5), vec4(0.999865), fragCoord, fragColor);\n    store_buf(vec2(2.5, 3.5), vec4(0.991766), fragCoord, fragColor);\n    store_buf(vec2(3.5, 3.5), vec4(0.942684), fragCoord, fragColor);\n    store_buf(vec2(4.5, 3.5), vec4(0.831852), fragCoord, fragColor);\n    store_buf(vec2(5.5, 3.5), vec4(0.673589), fragCoord, fragColor);\n    store_buf(vec2(6.5, 3.5), vec4(0.505564), fragCoord, fragColor);\n    store_buf(vec2(7.5, 3.5), vec4(0.355949), fragCoord, fragColor);\n    store_buf(vec2(0.5, 4.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 4.5), vec4(0.999665), fragCoord, fragColor);\n    store_buf(vec2(2.5, 4.5), vec4(0.986371), fragCoord, fragColor);\n    store_buf(vec2(3.5, 4.5), vec4(0.930421), fragCoord, fragColor);\n    store_buf(vec2(4.5, 4.5), vec4(0.813602), fragCoord, fragColor);\n    store_buf(vec2(5.5, 4.5), vec4(0.678975), fragCoord, fragColor);\n    store_buf(vec2(6.5, 4.5), vec4(0.537882), fragCoord, fragColor);\n    store_buf(vec2(7.5, 4.5), vec4(0.403271), fragCoord, fragColor);\n    store_buf(vec2(0.5, 5.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 5.5), vec4(0.999025), fragCoord, fragColor);\n    store_buf(vec2(2.5, 5.5), vec4(0.973317), fragCoord, fragColor);\n    store_buf(vec2(3.5, 5.5), vec4(0.900245), fragCoord, fragColor);\n    store_buf(vec2(4.5, 5.5), vec4(0.804126), fragCoord, fragColor);\n    store_buf(vec2(5.5, 5.5), vec4(0.703751), fragCoord, fragColor);\n    store_buf(vec2(6.5, 5.5), vec4(0.594890), fragCoord, fragColor);\n    store_buf(vec2(7.5, 5.5), vec4(0.481143), fragCoord, fragColor);\n    store_buf(vec2(0.5, 6.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 6.5), vec4(0.992850), fragCoord, fragColor);\n    store_buf(vec2(2.5, 6.5), vec4(0.926124), fragCoord, fragColor);\n    store_buf(vec2(3.5, 6.5), vec4(0.860745), fragCoord, fragColor);\n    store_buf(vec2(4.5, 6.5), vec4(0.833379), fragCoord, fragColor);\n    store_buf(vec2(5.5, 6.5), vec4(0.782873), fragCoord, fragColor);\n    store_buf(vec2(6.5, 6.5), vec4(0.703637), fragCoord, fragColor);\n    store_buf(vec2(7.5, 6.5), vec4(0.620129), fragCoord, fragColor);\n    store_buf(vec2(0.5, 7.5), vec4(0.987461), fragCoord, fragColor);\n    store_buf(vec2(1.5, 7.5), vec4(0.938899), fragCoord, fragColor);\n    store_buf(vec2(2.5, 7.5), vec4(0.942983), fragCoord, fragColor);\n    store_buf(vec2(3.5, 7.5), vec4(0.943682), fragCoord, fragColor);\n    store_buf(vec2(4.5, 7.5), vec4(0.943818), fragCoord, fragColor);\n    store_buf(vec2(5.5, 7.5), vec4(0.943681), fragCoord, fragColor);\n    store_buf(vec2(6.5, 7.5), vec4(0.943351), fragCoord, fragColor);\n    store_buf(vec2(7.5, 7.5), vec4(0.942877), fragCoord, fragColor);\n\n    float BIAS = 8.;\n    \n    store_buf(vec2(BIAS+0.5, 0.5), vec4(0.000200, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 0.5), vec4(0.040821, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 0.5), vec4(0.163499, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 0.5), vec4(0.359810, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 0.5), vec4(0.608219, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 0.5), vec4(0.849327, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 0.5), vec4(1.026876, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 0.5), vec4(1.127918, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 1.5), vec4(0.000200, -0.000046, 1.052217, 0.228243), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 1.5), vec4(0.040821, -0.009316, 1.052066, 0.228242), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 1.5), vec4(0.163218, -0.036566, 1.051517, 0.228141), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 1.5), vec4(0.360871, -0.077435, 1.049110, 0.226851), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 1.5), vec4(0.608870, -0.112986, 1.040456, 0.216178), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 1.5), vec4(0.850681, -0.110371, 1.022363, 0.171798), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 1.5), vec4(1.033758, -0.063836, 1.011022, 0.089896), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 1.5), vec4(1.130218, 0.000062, 1.000010, -0.000080), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 2.5), vec4(0.000200, -0.000096, 1.232269, 0.481573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 2.5), vec4(0.040829, -0.019653, 1.232083, 0.481559), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 2.5), vec4(0.163323, -0.077152, 1.229494, 0.481157), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 2.5), vec4(0.361362, -0.161748, 1.215935, 0.476966), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 2.5), vec4(0.602530, -0.224893, 1.149731, 0.444834), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 2.5), vec4(0.832866, -0.211716, 1.066321, 0.339254), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 2.5), vec4(1.033638, -0.123274, 1.025543, 0.170803), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 2.5), vec4(1.137644, 0.000154, 0.999953, -0.000082), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 3.5), vec4(0.000199, -0.000159, 1.627474, 0.797472), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 3.5), vec4(0.040836, -0.032524, 1.635685, 0.797401), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 3.5), vec4(0.164108, -0.127318, 1.628042, 0.795956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 3.5), vec4(0.365844, -0.258932, 1.575327, 0.783120), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 3.5), vec4(0.602895, -0.339455, 1.372632, 0.710306), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 3.5), vec4(0.825683, -0.302224, 1.158343, 0.512880), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 3.5), vec4(1.030563, -0.173519, 1.049980, 0.243539), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 3.5), vec4(1.151713, 0.000105, 0.999957, -0.000055), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 4.5), vec4(0.000198, -0.000248, 2.529443, 1.253956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 4.5), vec4(0.040880, -0.051100, 2.570697, 1.253684), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 4.5), vec4(0.166706, -0.198049, 2.542881, 1.248409), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 4.5), vec4(0.380361, -0.384441, 2.334701, 1.206127), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 4.5), vec4(0.617299, -0.459699, 1.772357, 1.025249), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 4.5), vec4(0.835445, -0.380695, 1.304201, 0.680722), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 4.5), vec4(1.040850, -0.213042, 1.089431, 0.306573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 4.5), vec4(1.176060, 0.000010, 1.000023, -0.000021), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 5.5), vec4(0.000187, -0.000388, 4.301116, 2.076506), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 5.5), vec4(0.041070, -0.084546, 5.305590, 2.075270), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 5.5), vec4(0.175521, -0.321638, 5.161014, 2.051541), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 5.5), vec4(0.413187, -0.560077, 4.055352, 1.869406), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 5.5), vec4(0.665130, -0.580464, 2.432246, 1.376237), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 5.5), vec4(0.870094, -0.441204, 1.506300, 0.819691), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 5.5), vec4(1.068578, -0.241436, 1.137736, 0.354430), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 5.5), vec4(1.219174, -0.000534, 1.000063, 0.000162), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 6.5), vec4(0.000144, -0.000631, 6.468958, 4.381222), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 6.5), vec4(0.042200, -0.177353, 20.085962, 4.369584), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 6.5), vec4(0.209979, -0.606367, 16.868328, 4.106197), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 6.5), vec4(0.500901, -0.795643, 8.099620, 2.893355), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 6.5), vec4(0.769693, -0.688227, 3.439625, 1.659662), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 6.5), vec4(0.955036, -0.470746, 1.760819, 0.883184), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 6.5), vec4(1.134532, -0.254869, 1.190455, 0.377490), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 6.5), vec4(1.308330, -0.002944, 0.999844, 0.001275), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 7.5), vec4(0.000102, -0.118482, 1184.816772, 1184.816284), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 7.5), vec4(0.319603, -3.097308, 7133.888672, 23.645655), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 7.5), vec4(0.546638, -1.442077, 133.966263, 8.593670), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 7.5), vec4(0.837342, -1.129903, 20.226521, 3.658263), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 7.5), vec4(1.004258, -0.809128, 5.700182, 1.768790), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 7.5), vec4(1.117055, -0.531464, 2.269246, 0.923613), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 7.5), vec4(1.336692, -0.312752, 1.241618, 0.414403), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 7.5), vec4(1.670654, -0.056394, 0.998759, 0.033416), fragCoord, fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tsetLUT(fragCoord, fragColor);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel1, uv);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Darken\nvec3 darken (vec3 target, vec3 blend){\n    \n return min (target, blend);   \n}\n\n//Multiply\nvec3 multiply (vec3 target, vec3 blend){\n    return target*blend;\n}\n\n//Color Burn\nvec3 colorBurn (vec3 target, vec3 blend){\n    return 1.0 - (1.0 - target)/ blend;\n}\n\n//Linear Burn\nvec3 linearBurn (vec3 target, vec3 blend){\n    return target + blend - 1.0;\n}\n\n//Lighten\nvec3 lighten (vec3 target, vec3 blend){\n    return max (target, blend);\n}\n\n//Screen\nvec3 screen (vec3 target, vec3 blend){\n    return 1.0 - (1.0 - target) * (1.0 - blend);\n}\n\n//Color Dodge\nvec3 colorDodge (vec3 target, vec3 blend){\n    return target / (1.0 - blend);\n}\n\n//Linear Dodge\nvec3 linearDodge (vec3 target, vec3 blend){\n    return target + blend;\n}\n\n//Overlay\nvec3 overlay (vec3 target, vec3 blend){\n    vec3 temp;\n    temp.x = (target.x > 0.5) ? (1.0-(1.0-2.0*(target.x-0.5))*(1.0-blend.x)) : (2.0*target.x)*blend.x;\n    temp.y = (target.y > 0.5) ? (1.0-(1.0-2.0*(target.y-0.5))*(1.0-blend.y)) : (2.0*target.y)*blend.y;\n    temp.z = (target.z > 0.5) ? (1.0-(1.0-2.0*(target.z-0.5))*(1.0-blend.z)) : (2.0*target.z)*blend.z;\n    return temp;\n}\n\n//Soft Light\nvec3 softLight (vec3 target, vec3 blend){\n vec3 temp;\n    temp.x = (blend.x > 0.5) ? (1.0-(1.0-target.x)*(1.0-(blend.x-0.5))) : (target.x * (blend.x + 0.5));\n    temp.y = (blend.y > 0.5) ? (1.0-(1.0-target.y)*(1.0-(blend.y-0.5))) : (target.y * (blend.y + 0.5));\n    temp.z = (blend.z > 0.5) ? (1.0-(1.0-target.z)*(1.0-(blend.z-0.5))) : (target.z * (blend.z + 0.5));\n    return temp;   \n}\n\n//Hard Light\nvec3 hardLight (vec3 target, vec3 blend){\n    vec3 temp;\n    temp.x = (blend.x > 0.5) ? (1.0-(1.0-target.x)*(1.0-2.0*(blend.x-0.5))) : (target.x * (2.0*blend.x));\n    temp.y = (blend.y > 0.5) ? (1.0-(1.0-target.y)*(1.0-2.0*(blend.y-0.5))) : (target.y * (2.0*blend.y));\n    temp.z = (blend.z > 0.5) ? (1.0-(1.0-target.z)*(1.0-2.0*(blend.z-0.5))) : (target.z * (2.0*blend.z));\n    return temp;\n}\n\n//Vivid Light\nvec3 vividLight (vec3 target, vec3 blend){\n     vec3 temp;\n    temp.x = (blend.x > 0.5) ? (1.0-(1.0-target.x)/(2.0*(blend.x-0.5))) : (target.x / (1.0-2.0*blend.x));\n    temp.y = (blend.y > 0.5) ? (1.0-(1.0-target.y)/(2.0*(blend.y-0.5))) : (target.y / (1.0-2.0*blend.y));\n    temp.z = (blend.z > 0.5) ? (1.0-(1.0-target.z)/(2.0*(blend.z-0.5))) : (target.z / (1.0-2.0*blend.z));\n    return temp;\n}\n\n//Linear Light\nvec3 linearLight (vec3 target, vec3 blend){\n    vec3 temp;\n    temp.x = (blend.x > 0.5) ? (target.x)+(2.0*(blend.x-0.5)) : (target.x +(2.0*blend.x-1.0));\n    temp.y = (blend.y > 0.5) ? (target.y)+(2.0*(blend.y-0.5)) : (target.y +(2.0*blend.y-1.0));\n    temp.z = (blend.z > 0.5) ? (target.z)+(2.0*(blend.z-0.5)) : (target.z +(2.0*blend.z-1.0));\n    return temp;\n}\n\n//Pin Light\nvec3 pinLight (vec3 target, vec3 blend){\n     vec3 temp;\n    temp.x = (blend.x > 0.5) ? (max (target.x, 2.0*(blend.x-0.5))) : (min(target.x, 2.0*blend.x));\n    temp.y = (blend.y > 0.5) ? (max (target.y, 2.0*(blend.y-0.5))) : (min(target.y, 2.0*blend.y));\n    temp.z = (blend.z > 0.5) ? (max (target.z, 2.0*(blend.z-0.5))) : (min(target.z, 2.0*blend.z));\n    return temp;\n}\n\n//Difference\nvec3 difference (vec3 target, vec3 blend){\n    return abs (target - blend);\n    \n}\n//Exclusion\nvec3 exclusion (vec3 target, vec3 blend){\n    return 0.5 - 2.0*(target-0.5)*(blend-0.5);\n    \n}\n\n//Subtract (thanks to Brandondorf9999)\nvec3 subtract (vec3 target, vec3 blend){\n    return target - blend;\n}\n\n//Divide (thanks to Brandondorf9999)\nvec3 divide (vec3 target, vec3 blend){\n return target/blend;   \n}\n\n#define T(a) texture(iChannel1,p.xz*.1-t*a)\nvec4 waterEffect(in vec2 fragCoord ) {\n    vec4 p = vec4(fragCoord,0.,1.)/iResolution.xyxy-1., d=p, e;\n    vec4 finCol;\n    float t = iTime+6., x;\n    d.y -= 0.3;\n    p.z += t*.3;\n    for(float i=1.; i>0.; i-=.02)\n    {\n        e = sin(p*6.+t);\n        x = abs(p.y+e.x*e.z*.1-.75)-(e=T(.01)+T(.02)).x*.08;\n        finCol = .3/length(p.xy) - e*i*i;\n        if(x<.005) break;\n        p -= d*x*.5;\n     }\n     return finCol;\n     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 texCol = texture(iChannel0, uv);\n    vec4 waterCol = waterEffect(fragCoord);\n    // Output to screen\n    fragColor = vec4(overlay(waterCol.rgb,texCol.rgb),1.);\n    //fragColor = mix(waterCol,texCol,0.5);\n    //fragColor = waterCol;\n    fragColor=texCol;\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// \"Wait.. what? CyberTruck!\" by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Music:\n// https://soundcloud.com/weareallsynners/cyberpunk\n//\n// Tesla's insanely cool new pickup truck. I figured it'd be doable because of the angular look\n// Still turned out to be A LOT of work. Code is quite messy as a result, which is quite usual\n// for a version 1 of anything ;)\n//\n// Might do a run through of how this was made on The Art of Code if there is enough interest\n//\n// I have a quite convoluted way of rendering the interior behind the glass. \n// I'm raymarching to the glass and then spawning another raymarch loop for the interior.\n// In hindsight that could have been done better, I think rendering everything without the glass\n// and then rendering the glass on top would have been better. Oww well.\n//\n// If you are not fond of the disco effect, or if you want a better look at the car then\n// I suggest lowering the BEAMS_PER_SECOND, pressing pause or activating MODEL_MODE\n//\n\n// Tweak these!\n#define BEAMS_PER_SECOND 0.85\n#define GROUND_DISPLACEMENT\n//#define MODEL_MODE\n\n\n#define MAX_STEPS 30\n#define MIN_DIST .5\n#define MAX_DIST 10.\n#define SURF_DIST .02\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n#define MAT_BASE 0.\n#define MAT_FENDERS 1.\n#define MAT_RUBBER 2.\n#define MAT_LIGHTS 3.\n#define MAT_GLASS 4.\n#define MAT_SHUTTERS 5.\n#define MAT_GROUND 6.\n#define MAT_CAB 6.\n\n\n\nvec3 beamStart, beamEnd, beamCol;\nfloat throughWindow;\n\nvec2 sdCar(vec3 p) {\n    float matId=MAT_BASE;\n    p.x = sabs(p.x, .5);\t\t// smooth abs to make front rounded\n    \n    vec2 P = p.yz;\n    \n    // body\n    float d, w;\n    \n    float frontGlass = dot(P, vec2(0.9493, 0.3142))-1.506; // front\n    d = frontGlass;\n    \n    float topGlass = dot(P, vec2(0.9938, -0.1110))-1.407;\n    d = max(d, topGlass); \n    float back = dot(P, vec2(0.9887, -0.16))-1.424;\n    d = max(d, back); // back\n    \n    float side1 = dot(p, vec3(0.9854, -0.1696, -0.0137))-0.580;\n    d = max(d, side1); // side 1\n    \n    float side2 = dot(p, vec3(0.9661, 0.2583, 0.0037))-0.986;\n    d = smin(d, side2, -.005);\n    d = max(d, dot(P, vec2(-0.1578, -0.9875))-2.056); // rear\n    d = max(d, dot(p, vec3(0.0952, -0.1171, 0.9885))-2.154);\n    d = max(d, dot(p, vec3(0.5019, -0.1436, 0.8529))-2.051);\n    d = max(d, dot(P, vec2(-0.9999, -0.0118))+0.2643); // bottom\n    d = max(d, dot(p, vec3(0.0839, -0.4614, 0.8832))-1.770);\n    d = max(d, dot(p, vec3(0.0247, -0.9653, 0.2599))-0.196);\n    d = max(d, dot(P, vec2(-0.9486, -0.3163))-0.295);\n    \n    float body = d;\n    float car = d;\n    if((-frontGlass<car && p.z < 1.8-p.x*p.x*.16 && side2<-.01) ||\n       (abs(-topGlass-car)<.01 && p.z>-.6 && p.z < .5 && side2<-.01)) \n        matId = MAT_GLASS;\n    \n    // bed shutters\n    d = max(1.-p.y, max(p.x-.63, abs(p.z+1.44)-.73));\n    if(d<-.02) matId = MAT_SHUTTERS;\n    \n    d = max(d, (-back-.01)-S(.5,1., sin(p.z*100.))*.0);\n    \n    car = max(car, -d);\n    \n    // bumper\n    d = S(.03, .02, abs(p.y-.55))*.045;\n    d -= S(.55, .52, p.y)*.05;\n    d *= S(1.3, 1.5, abs(p.z));\n    \n    float rB = max(p.x-p.y*.15-.21, .45-p.y);\n    float fB = max(p.x-.51, abs(.42-p.y)-.02);\n    d *= S(.0,.01, mix(rB, fB, step(0.,p.z)));\n   \tif(p.y<.58-step(abs(p.z), 1.3)) matId = MAT_FENDERS;\n    \n    // lights\n    float lt = map01(.5, .8, p.x);\n    float lights = map01(.02*(1.+lt), .01*(1.+lt), abs(p.y-(.82+lt*.03)));\n    lights *= S(2.08, 2.3, p.z);\n\td += lights*.05;\n    lights = map01(.01, .0, side1+.0175);\n    lights *= step(p.z, -2.17);\n    lights *= map01(.01, .0, abs(p.y-1.04)-.025);\n    d += lights*.03;\n    \n    if(d>0.&&matId==0.) matId = MAT_LIGHTS;\n    \n    if(car<.1) d*= .5;\n    car += d;\n    \n    // step\n    car += map(p.y+p.z*.022, .495, .325, 0., .05);//-S(.36, .34, p.y)*.1;\n    d = sdBox(p-vec3(0, .32, 0), vec3(.72+p.z*.02, .03, 1.2));\n    if(d<car) matId = MAT_FENDERS;\n    car = min(car, d);\n    \n    // windows Holes\n    \n    d = w = dot(P, vec2(-0.9982, -0.0601))+1.0773;\n    d = max(d, dot(P, vec2(0.1597, -0.9872))-0.795);\n    d = max(d, dot(P, vec2(0.9931, -0.1177))-1.357);\n    d = max(d, dot(P, vec2(0.9469, 0.3215))-1.459);\n    //d = max(d, -.03-side2);\n    float sideWindow = dot(p, vec3(-0.9687, -0.2481, 0.0106))+0.947;\n    sideWindow += map01(0., 1., p.y-1.)*.05;\n    if(d<-.005) matId = MAT_GLASS;\n    \n    d = max(d, sideWindow);\n    car = max(car, -d);\n    \n    // panel lines\n    if(car<.1) {\n    \td = abs(dot(p.yz, vec2(0.0393, 0.9992))+0.575);\n        d = min(d, abs(dot(p.yz, vec2(0.0718, 0.9974))-0.3));\n        d = min(d, abs(p.z-1.128));\n        float panels = S(.005, .0025, d) * step(0., w) * step(.36, p.y);\n        \n        float handleY = dot(p.yz, vec2(-0.9988, -0.0493))+0.94;\n        d = S(.02, .01, abs(handleY))*S(.01, .0, min(abs(p.z-.4)-.1, abs(p.z+.45)-.1));\n        panels -= abs(d-.5)*.5;\n        \n        // charger\n        d = S(.02, .01, abs(p.y-.81)-.04)*S(.01, .0, abs(p.z+1.75)-.12);\n        panels += abs(d-.5)*.5;\n        \n        d = S(.005, .0, abs(side2+.015));\n        d *= S(.03, .0, abs(frontGlass));\n        panels += d;\n        \n        car += panels *.001;\n    }\n    \n    // fenders\n    //front\n    d = dot(p, vec3(0.4614, 0.3362, 0.8210))-2.2130;\n    d = max(d, dot(p, vec3(0.4561, 0.8893, 0.0347))-1.1552);\n    d = max(d, dot(p, vec3(0.4792, 0.3783, -0.7920))+0.403);\n    d = max(d, dot(p, vec3(0.4857, -0.0609, -0.8720))+0.6963);\n    d = max(d, dot(p, vec3(0.4681, -0.4987, 0.7295))-1.545);\n    d = max(d, .3-p.y);\n    d = max(d, abs(p.x-.62-p.y*.15)-.07);\n    if(d<car) matId = MAT_FENDERS;\n    car = min(car, d);\n    \n    // back\n    d = dot(p, vec3(0.4943, -0.0461, 0.8681))+0.4202;\n    d = max(d, dot(p, vec3(0.4847, 0.4632, 0.7420))+0.0603);\n    d = max(d, dot(p, vec3(0.4491, 0.8935, 0.0080))-1.081);\n    d = max(d, dot(p, vec3(0.3819, 0.4822, -0.7885))-1.973);    \n    d = max(d, min(.58-p.y, -1.5-p.z));\n    d = max(d, .3-p.y);\n    d = max(d, abs(side1+.01)-.08);\n    if(d<car) matId = MAT_FENDERS;\n    car = min(car, d);\n    \n    //if(car>.1) return vec2(car, matId);\n    \n    // wheel well\n    // front\n    d = p.z-2.0635;\n    d = max(d, dot(p.yz, vec2(0.5285, 0.8489))-2.0260);\n    d = max(d, dot(p.yz, vec2(0.9991, 0.0432))-0.8713);\n    d = max(d, dot(p.yz, vec2(0.5258, -0.8506))+0.771);\n    d = max(d, 1.194-p.z);\n    d = max(d, .5-p.x);\n    car = max(car, -d);\n    if(d<car) matId = MAT_FENDERS;\n    \n    // back\n    d = p.z+0.908;\n    d = max(d, dot(p.yz, vec2(0.5906, 0.8070))+0.434);\n    d = max(d, dot(p.yz, vec2(0.9998, 0.0176))-0.7843);\n    d = max(d, dot(p, vec3(-0.0057, 0.5673, -0.8235))-1.7892);\n    d = max(d, -p.z-1.7795);\n   \td = max(d, .5-p.x);//.65-p.x\n    car = max(car, -d);\n    if(d<car) matId = MAT_FENDERS;\n    \n   return vec2(car, matId);\n}\n\nvec2 sdWheel(vec3 p) {\n    float matId=MAT_RUBBER;\n    \n    vec3 wp = p;\n\tfloat  w = sdCylinder(wp, vec3(-.1, 0,0), vec3(.1, 0,0), .32)-.03;\n    float dist = length(wp.zy);\n    \n    if(dist>.3&&w<.05) {\t\t// wheel detail\n    \tfloat a = atan(wp.z, wp.y);\n        float x = wp.x*20.;\n        float tireTop = S(.29, .4, dist);\n        float thread = S(-.5, -.3, sin(a*40.+x*x))*.01 * tireTop;\n        \n        thread *= S(.0, .007, abs(abs(wp.x)-.07+sin(a*20.)*.01));\n        thread *= S(.005, .01, abs(wp.x+sin(a*20.)*.03));\n        \n        w -= thread*2.;\n        \n        float e = length(wp-vec3(2, .1, 0))-.5;\n        w = min(w, e);\n    }\n    \n    if(w>.1) return vec2(w, matId);\n    \n    wp *= .95;\n    wp.yz = pModPolar(wp.yz, 7., 1.);\n    float cap = max(p.x-.18, wp.y-.3);\n    \n    wp.z = abs(wp.z);\n    \n    float d = map01( .3, .23, wp.y);\t\t// spoke bevel\n    d *= map01(.04, .03, wp.z);\t\t\t// spokes\n    d *= map01(-.23, .23, wp.y)*.7;\t\t\t// spoke gradient\n    \n    d = max(d, map01(.13, .0, wp.y)*1.5);\t// center outside\n    d = min(d, map01(.0, .07, wp.y));\t\t// center inside\n    d = max(d, .8*step(wp.y, .05));\t\t\t// middle plateau\n    \n    d = max(d, .4*map01(.23, .22, dot(wp.zy, normalize(vec2(1., 2.)))));\n    cap += (1.-d)*.07;\n    cap = max(cap, .05-p.x);\n    cap *= .8;\n    if(cap<w) matId = MAT_FENDERS;\n    \n    w = min(w, cap);\n    w += S(.3, .0, dist)*.025; // concavivy!\n    \n    return vec2(w, matId);\n}\n\nvec2 GetDist(vec3 p) {\n    vec2 car = sdCar(p);\n    vec3 wp = p-vec3(0,0,.14);\n    wp.xz = abs(wp.xz);\n    wp-=vec3(.7383, .365, 1.5);\n    \n    if(p.z>0.) wp.xz *= Rot(.3*sign(p.x));\n    vec2 wheel = sdWheel(wp);\n    \n    float y = p.y;\n    \n    #ifdef GROUND_DISPLACEMENT\n    float centerDist = dot(p.xz, p.xz);\n    if(centerDist<100.&&p.y<.01) {\n        y = SmoothNoise(p.xz*2.)+SmoothNoise(p.xz*5.)*.5+SmoothNoise(p.xz*23.)*.05;\n        y += SmoothNoise(y*p.xz);\n        \n        float fade = S(100.,0.,centerDist);\n        fade *= fade*fade;\n        \n        y = y*y*.03*fade;\n        y *= S(.0, .6, dot(wp.xz,wp.xz));\n    }\n\ty+=p.y;\n    #endif\n    \n    if(min(y, min(car.x, wheel.x))==y)\n        return vec2(y, MAT_GROUND);\n    else \n    \treturn car.x<wheel.x ? car : wheel;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=MIN_DIST;\n    float dS;\n    float matId=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 g = GetDist(p);\n        dS = g.x;\n        dO += dS;\n        matId = g.y;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec3(dO, abs(dS), matId);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(1e-4, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvec4 TubeInfo(vec3 ro, vec3 rd, vec3 a, vec3 b) {\n\tvec2 ts = RayLineDist(ro, rd, a, b);\n    \n    vec3 pr = ro+max(0., ts.x)*rd;\t\t\t// closest point on ray\n    vec3 pl = a+clamp(ts.y, 0., 1.)*(b-a);\t// closest point on line\n    float closestDist = length(pr-pl);\t\t// distance between closest points\n    //float distToCrossing = length(ro-pl);\t// distance along ray to crossing\n    \n    return vec4(pl, closestDist);\n}\n\nfloat Intensity(float d, float w) {\n    return exp(-(d*d)/w)/sqrt(w);\n}\n\n\nvec3 Ground(vec3 P) {\n\tvec2 p = P.xz;\n    float d = 1.+max(0.,dot(p,p));\n    float shadow = smoothstep(.5, 1.8, length(p-vec2(0, clamp(p.y, -1.5, 1.3))) );\n\t\n    float albedo = SmoothNoise(p*4.+SmoothNoise(p*7.)*.66+SmoothNoise(p*13.)*.33);\n    float specks = SmoothNoise(p*albedo*5.)+P.y;\n    albedo -= specks*specks*specks;\n    albedo /= 1.+max(0.,dot(p,p))*.5;\n    \n    albedo = (albedo+1.)/3.;\n    vec3 col = vec3(albedo)*shadow;\n    \n    return col;\n}\n\nvec3 GroundRef(vec3 ro, vec3 rd) {\n\tvec2 p = ro.xz-rd.xz*(ro.y/rd.y);\n    \n    float d = 1.+max(0.,dot(p,p));\n    float albedo = SmoothNoise(p*4.+SmoothNoise(p*7.)*.66+SmoothNoise(p*13.)*.33);\n    \n    albedo /= 1.+max(0.,dot(p,p))*.5;\n    \n    albedo = (albedo+1.)/3.;\n    vec3 col = vec3(albedo)*S(.6, .0, rd.y);\n    \n    return col;\n}\n\n// Interior of the car\nvec2 CabDist(vec3 p) {\n    p.x = abs(p.x);\n    \n    float cab,d;\n    \n    float frontGlass = dot(p.yz, vec2(0.9493, 0.3142))-1.506; // front\n    float topGlass = dot(p.yz, vec2(0.9938, -0.1110))-1.407;\n    float windowBottom = dot(p.yz, vec2(-0.9982, -0.0601))+1.0773;\n    \n    float side1 = dot(p, vec3(0.9854, -0.1696, -0.0137))-0.580;\n    float side2 = dot(p, vec3(0.9661, 0.2583, 0.0037))-0.986;\n    float side = max(side1, side2);\n    \n    float w = .05;\n    float hw = .5*w;\n    \n    float glass = max(frontGlass, topGlass);\n    float glassShell = abs( glass+.025 ) -.025; \n    d = min(glassShell, max(abs(p.z-.17),glass+.1)-.05); // center column\n    cab = max(d,abs(-side2-w)-w);\n    \n    // top bar\n    d = max(abs(p.z-.43)-w, glassShell);\n    d = max(d, side2);\n    cab = min(cab, d);\n    \n    d = max(abs(-side1-w)-w, -windowBottom);\t// side wall\n    float walls = min(p.y-.3, p.z+.6);\n    walls = min(d, walls);\n    \n    walls = max(walls, glass);\n    d = max(walls,side);\t\t\t\t// bottom\n\tcab = min(cab, d);\n    \n    // front seats\n    float cup = cos(p.x*10.);\n    vec3 seatPos = p-vec3(.35, .2+cup*.04, .8);\n    d = sdBox(seatPos, vec3(.27, .25, .3)*.8)-.05;\n    seatPos = p-vec3(.35, .75, .6);\n    seatPos.z += S(.0, 1.2, p.y)*.4-cup*.05;\n    vec3 seatScale = vec3(.27, .6, .03)*.8;\n    seatScale.x *= 1.-S(.9, 1.1, p.y)*.6;\n    seatScale.xz *= 1.-S(1.1, 1.3, p.y)*.7;\n    \n    d = min(d, sdBox(seatPos, seatScale)-.04);\n    \n    cab = min(cab, d);\n    \n    // dash\n    d = sdBox(p-vec3(0,.5,1.7), vec3(2,.5,.3));\n    d = min(d, sdBox(p-vec3(0,.89+(p.z-1.3)*.1,1.5), vec3(2,.07,.3))-.01);\n    d = max(d, side1);\n    cab = min(cab, d);\n    \n    // screen\n    vec3 scrPos = p-vec3(0,.9,1.15);\n    scrPos.yz *= Rot(-.4);\n    d = sdBox(scrPos, vec3(.16,.1,-.005))-.02;\n    cab = min(cab, d);\n    // wheel\n\t   \n   \n    return vec2(cab, MAT_CAB);\n}\n\nvec3 CabNormal(vec3 p) {\n\tfloat d = CabDist(p).x;\n    vec2 e = vec2(1e-4, 0);\n    \n    vec3 n = d - vec3(\n        CabDist(p-e.xyy).x,\n        CabDist(p-e.yxy).x,\n        CabDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec4 RenderCab(vec3 ro, vec3 rd) {\n    vec4 info;\n    \n\tfloat dO=MIN_DIST;\n    float dS;\n    float matId=0.;\n    vec3 p;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tp = ro + rd*dO;\n        vec2 g = CabDist(p);\n        dS = g.x;\n        dO += dS;\n        matId = g.y;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    vec3 col = vec3(0);\n    if(abs(dS)<SURF_DIST) {\n        vec3 n = CabNormal(p);\n        info = vec4( n, 0. );\n    } else\n        info = vec4(0,0,0,.5);\n    \n    return info;\n}\n\nvec3 Material(vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 d) {\n    vec3 col = vec3(0);\n    \n    float dif = n.y;\n    vec3 r = reflect(rd,n);\n    \n    vec4 nDif = TubeInfo(p, n, beamStart, beamEnd);\n    vec4 nRef = TubeInfo(p, r, beamStart, beamEnd);\n\n    float dist = length(nDif.xyz-p);\n    float nDiffuse = 4.*max(0., dot(n, nDif.xyz/dist))/(dist*dist);\n    nDiffuse *= S(50., 9., length(nDif.xyz-ro));\n\n    vec3 wp = abs(p-vec3(0,0,.14))-vec3(.7383, .36, 1.5);\n\tfloat matId = d.z;\n    \n    if(matId==MAT_GROUND) {\n        col = Ground(p);//ro, rd);\n        float z = p.z-2.;\n        float headLight = S(1.+z,-1.-z, abs(p.x)-p.z*.35);\n        \n        headLight -= headLight*n.z*2.; // bump map\n        headLight /= 1.+z*z*.05;\n        \n        vec3 tlPos = p+vec3(0,0,3);\n        col *= nDiffuse*beamCol+headLight*S(0., 3.,z)+\n            .5/(1.+dot(tlPos,tlPos))*vec3(1.,.1,.1);\n    } else if(matId==MAT_BASE || matId==MAT_GLASS || matId==MAT_SHUTTERS) { \n        vec3 ref = vec3(0.);//GetRef(p, r)*1.;\n\n        ref += Intensity(nRef.w*(10.*(1.+matId)), length(p-nRef.xyz)+.25)*5.;\n        ref *= beamCol;\n        ref += GroundRef(p, r)*beamCol;\n\n        vec3 P =p-r*(p.y/r.y);\n\n        nDif = TubeInfo(P, vec3(0,1,0), beamStart, beamEnd);\n\n        dist = length(nDif.xyz-P);\n        nDiffuse = 4.*max(0., dot(n, nDif.xyz/dist))/(dist*dist);\n        nDiffuse *= S(50., 9., length(nDif.xyz-ro));\n\n        col += ref*nDiffuse;\n        \n        vec3 lighten = max(0., r.y*r.y*n.y)*beamCol;\n        if(matId==MAT_BASE) {\n            col += ref*max(.1,nDiffuse);\n        \n            //col *= 2.;\n            col += lighten*.5;\n        } else if(matId==MAT_SHUTTERS) {\n            float seams = sin(p.z*150.)*.5+.5;\n            col *= seams;\n            col += lighten *.3*(S(.0, .1, seams)*.1+.9);  \n        } else if(matId==MAT_GLASS) {\n            vec4 cabInfo = RenderCab(ro, rd);\n            col += cabInfo.y*.005;\n            throughWindow = cabInfo.w;\n        }        \n    } else if(matId==MAT_LIGHTS) {\n    \tif(p.z<0.)\n        \tcol.r += 1.;\n        else\n            col += 1.;\n    } else if(matId==MAT_FENDERS) {\n        float spec = Intensity(nRef.w*3., length(p-nRef.xyz)+.25);\n        col += max(n.y*.05, spec)*(beamCol+.5);\n        \n    } else if(matId==MAT_RUBBER) {\n        float shadow = S(.0, .1, abs(p.x)-.7);\n        col += nDiffuse*shadow*beamCol*.2;\n    }\n    \n    return col;      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y*2.;\n\tvec4 m = iMouse/iResolution.xyxy;\n    if(m.x<.05) m.xy = vec2(.7,.45);\n    float t = iTime;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5)*.7;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831+t*.3+1.);\n    ro.y = max(ro.y, .1);\n    vec3 lookat = vec3(0,.5,0);\n    //lookat = vec3(.7,.5,1.5);\n    #ifdef MODEL_MODE\n    vec3 rd = R(uv, ro, lookat, 2.);\n\t#else\n    vec3 rd = R(uv, ro, lookat, 1.);\n    #endif\n    \n    vec3 d = RayMarch(ro, rd);\n    throughWindow = 0.;\t\t// will be set to >0 if we are looking all the way through the car\n   \n    // neon tubes\n    float climax = 1.+step(35.,iChannelTime[0])*5.*step(iChannelTime[0], 52.);\n    float ft = floor(t*BEAMS_PER_SECOND*climax)*BEAMS_PER_SECOND*climax;\n   \tbeamStart = vec3(-40,3.,0)+sin(ft*vec3(.234,.453,.486))*vec3(5,2,5)*.5;\n    beamEnd = vec3(40, 3.,0)+sin(ft*vec3(.345,.538,.863))*vec3(5,2,5)*.5;\n    mat2 rot = Rot(ft*45.4532);\n    beamStart.xz *=rot;\n    beamEnd.xz*=rot;\n    \n  \tbeamCol = sin(ft*vec3(.234,.453,.486))*.5+.5;\n    beamCol *= beamCol;\n    beamCol = normalize(beamCol);\n    \n    vec2 ts;\n    vec3 a, b, s;\n    float nd;\n    vec3 p = ro + rd * d.x;\n    \n    if(d.y<SURF_DIST) {\n    \tvec3 n = GetNormal(p);\n        \n        #ifdef MODEL_MODE\n        float matId = d.z;\n        col = vec3(1);//n*.5+.5;\n\n        if(matId==MAT_BASE)\n\t\t\tcol *= vec3(1,0,0);\n        else if(matId==MAT_FENDERS)\n            col *= vec3(0,1,0);\n        else if(matId==MAT_LIGHTS)\n            col *= vec3(0,0,1);\n        else if(matId==MAT_GLASS) {\n            vec4 cabInfo = RenderCab(ro, rd);\n            col = cabInfo.xyz/3.;\n            throughWindow = cabInfo.w;\n        }else if(matId==MAT_RUBBER)\n            col *= vec3(1,1,0);\n        else if(matId==MAT_SHUTTERS)\n            col *= vec3(0,1,1);\n        else if(matId==MAT_GROUND)\n            col *= .2;\n        #else\n    \tcol = Material(ro, rd, p, n, d);\n        #endif\n    } else if(rd.y>0.){\n        col += rd.y*rd.y*(beamCol);\n    }\n    \n    #ifndef MODEL_MODE\n    if(rd.y<0.) {\n        float groundDist = length(rd*(ro.y/rd.y));\n        if(groundDist<d.x){// || groundDist>MAX_DIST) {\n        \tvec3 groundPos = ro+groundDist*rd;\n           // col = Ground(ro, rd);\n        \t//col = texture(iChannel1, groundPos.xz*.1).rgb;\n        \t//col *= nDiffuse*beamCol;\n        //col += 1.;\n        }\n    }\n    \n    ts = RayLineDist(ro, rd, beamStart, beamEnd);\n    a = ro+max(0., ts.x)*rd;\n    b = beamStart+clamp(ts.y, 0., 1.)*(beamEnd-beamStart);\n    nd = length(a-b);\n    float dist = length(ro-b);\n    \n    float beam = (.005/dot(nd,nd))*S(50., 9., dist);\n    beam *= max(throughWindow, S(0., 1., d.x-length(ro-b)));\n    col += beam*beamCol;\n    \n    // headlights\n    float brightness = .02;\n    float z = 2.22;\n    float bias = 1.;\n    float offs = .0;\n    vec4 h;\n    \n    h = TubeInfo(ro, rd, vec3(.56, .82, z), vec3(.74,.85,z-.1));\n    float headlight = max(0., dot(vec2(.3, .8), -rd.xz)*bias+offs)*brightness/h.w;\n   \th = TubeInfo(ro, rd, vec3(-.56, .82, z), vec3(-.74,.85,z-.1));\n    headlight += max(0., dot(vec2(-.3, .8), -rd.xz)*bias+offs)*brightness/h.w;\n    \n    // middle\n    brightness *= .66;\n    h = TubeInfo(ro, rd, vec3(-.52, .82, z), vec3(.52,.82,z));\n    headlight += max(0., -rd.z)*brightness/h.w;\n    \n    // top\n   // h = TubeInfo(ro, rd, vec3(-.52, 1.43, .5), vec3(.52,1.43,.5));\n   // headlight += max(0., -rd.z)*.005/h.w;\n    \n    \n    col += headlight*vec3(.8, .8, 1);\n    \n    // rear light\n    h = TubeInfo(ro, rd, vec3(-.7, 1.05, -2.25), vec3(.7,1.05,-2.25));\n    col += vec3(1., .1, .1)*max(0., rd.z*rd.z*rd.z)*.04/h.w;\n    \n    \n    //col *= 3.;\n    \n    //if(uv.x>0.)col =  col*3.;//filmic_reinhard(col); else\n    col = Tonemap_ACES(col*4.);\n    //col *= 1.-dot(uv,uv)*.5;\n    \n    #endif\n    //col = pow(col,vec3(1./2.2));\n   fragColor = vec4(col,1.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\nvec2 sabs(vec2 x,float k) { return vec2(sabs(x.x, k), sabs(x.y,k)); }\nvec3 sabs(vec3 x,float k) { return vec3(sabs(x.x, k), sabs(x.y,k), sabs(x.z,k)); }\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// From http://mercury.sexy/hg_sdf\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = 6.2832/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat LineDist(vec2 a, vec2 b, vec2 p) {\n\tvec2 ab=b-a, ap=p-a;\n    float h = dot(ab, ap)/dot(ab, ab);\n    float d = length(ap - ab * h);\n    float s = sign(ab.x * ap.y - ab.y * ap.x);\n    return d*s;\n}\n\nfloat LineDist(float ax,float ay, float bx,float by, vec2 p) {\n    return LineDist(vec2(ax, ay), vec2(bx, by), p);\n}\nfloat map01(float a, float b, float t) {\n\treturn clamp((t-a)/(b-a), 0., 1.);\n}\nfloat map(float t, float a, float b, float c, float d) {\n\treturn (d-c)*clamp((t-a)/(b-a), 0., 1.)+c;\n}\n\nvec2 RayLineDist(vec3 ro, vec3 rd, vec3 a, vec3 b) {\n    \n    b -= a;\n    vec3 rdb = cross(rd,b);\n    vec3 rop2 = a-ro;\n    \n\tfloat t1 = dot( cross(rop2, b), rdb ); \n    float t2 = dot( cross(rop2, rd), rdb );\n    \n    return vec2(t1, t2) / dot(rdb, rdb);\n}\n\nfloat RayPlane(vec3 ro, vec3 rd, vec3 n, float d) {\n\treturn (d-dot(ro, n)) / dot(rd, n);\n}\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(123.34,456.23));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n    //return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\n\nfloat Tonemap_ACES(float x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 Tonemap_ACES(vec3 x) {\n    return vec3(Tonemap_ACES(x.r),Tonemap_ACES(x.g),Tonemap_ACES(x.b));\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}