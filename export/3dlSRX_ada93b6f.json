{"ver":"0.1","info":{"id":"3dlSRX","date":"1551840198","viewed":91,"name":"shadow study 2","username":"mindtree","description":"more shadow marching experiments","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n// Light RGBs\n#define LIGHT_COL vec3(1.0, 1.0, 1.0)\n#define LIGHT_SPREAD 64.\n\n#define BOX_SIZE 0.25\n\nconst float PI = 3.1457;\n\nfloat bpm() { return 128.5; }\nfloat beats_per_bar() { return 4.; }\nfloat bar() { return iTime * bpm() / 60.0 / beats_per_bar(); }\nfloat bar_phase() { return mod(bar(), 1.0); }\nfloat bar4_phase() { return mod(bar(), 4.0) / 4.0; }\nfloat bar8_phase() { return mod(bar(), 8.0) / 8.0; }\nfloat bar16_phase() { return mod(bar(), 16.0) / 16.0; }\nfloat beat() { return iTime * bpm() / 60.0; }\nfloat beat_phase() { return mod(beat(), 1.0); }\nfloat minim_phase() { return mod(beat()*0.5, 1.0); }\nfloat quaver_phase() { return mod(beat()*2.0, 1.0); }\nfloat semiquaver_phase() { return mod(beat()*4.0, 1.0); }\n\nfloat light_rot_phase() { return beat_phase(); }\nfloat light_spread_phase() { return bar16_phase(); }\nfloat box_size() { return sin(bar_phase()*2.*PI)*BOX_SIZE; }\n\nfloat light_spread() {\n    return LIGHT_SPREAD - pow(sin(light_spread_phase()*PI*2.0)*0.5+0.5, 0.5) * LIGHT_SPREAD;\n    //return LIGHT_SPREAD;\n}\n\nvec3 light_position() {\n    vec3 pos = vec3(0, 5, 6);\n    float spread = light_spread();\n    float phase = light_rot_phase() * PI * 2.0;\n    pos.xz += vec2(sin(phase), cos(phase))*spread;\n    pos.y += sin(bar4_phase()*PI*2.0)*2.0;\n\treturn pos;\n}\n\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;//*sin(bar_phase()*PI*2.0);\n    float planeDist = p.y;\n    \n    vec3 p_for_box = p;\n    //p_for_box.z = mod(p_for_box.z, 10.0);\n    p_for_box.x = mod(p_for_box.x, 8.0);\n    p_for_box.y = mod(p_for_box.y, 2.0);\n    vec3 boxp = vec3(4.0, 1.0, 10.0);\n    vec3 boxdim = vec3(1., 1., 1.)*BOX_SIZE;\n    float boxDist = dBox(p_for_box-boxp, boxdim);\n    \n    float d = min(sphereDist, planeDist);\n    d = min(d, boxDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat shadow_march(vec3 ro, vec3 rd, float min_light, float light_dist, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float maxt = min(MAX_DIST, light_dist);\n    for (float t=min_light; t < maxt;) {\n        vec3 p = ro + rd*t;\n        float h = GetDist(p);\n        if (h<SURF_DIST) {\n            return 0.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat invert_phase() {\n    return beat_phase();\n}\n\nfloat invert_lightness(float l) {\n    return mix(l, 1.0-l, cos(invert_phase()*PI*2.));\n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 light_pos = light_position();\n\n    vec3 l = normalize(light_pos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(light_pos-p)) dif *= .1;\n    float min_light = 0.2;\n    float light_dist = 1.0;\n    float k = 0.5;\n    float s = shadow_march(p+n*SURF_DIST*2., l, min_light, light_dist, k);\n    //s = 1.;\n    \n    return dif*s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));//*bar16_phase()));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    float fade_dist = 1.0 - pow(d / MAX_DIST, 2.);\n    //dif = invert_lightness(dif);\n    col = LIGHT_COL * dif * fade_dist;\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}