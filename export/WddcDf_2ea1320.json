{"ver":"0.1","info":{"id":"WddcDf","date":"1602061927","viewed":165,"name":"Stable cone frustum raytracing","username":"M_cgode","description":"A shader for raytracing a stable cone frustum (or a cone if you need to), useful when working with cone frustums when the angle gets really low.\nHandles the limit case where the cone frustum becomes a cylinder.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","cone","frustum","conefrustum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n    \n    \nstruct ConeFrustum {\n\tvec3 origin;\n    vec3 axis;\n    vec2 radii;\n    float height;\n};\n    \n \n// Perspective projection ray from screen coordinate\nRay getScreenRay(in vec2 uv)\n{\n    float vFov = 3.14 / 6.0;\n    float hFov = atan(iResolution.x / iResolution.y * tan(vFov));\n    \n    vec2 coord = 2.0 * uv - 1.0;\n    \n    //// Orthographic projection\n    //return Ray(2. * vec3(coord.x * iResolution.x / iResolution.y, coord.y, -2), vec3(0, 0, 1));\n    \n    float dv = atan(coord.y * tan(vFov));\n    float dh = atan(coord.x * tan(hFov));\n    \n    vec3 direction = vec3(coord.x * iResolution.x / iResolution.y, coord.y, -1.5);\n    return Ray(vec3(0,0,3), normalize(direction));\n}\n\nbool intersectConeFrustum( in Ray ray, in ConeFrustum cone, out float t, out vec3 normal )\n{\n    float dr = cone.radii.y - cone.radii.x;\n    float r = 1. + pow(dr / cone.height, 2.);\n    float R = cone.radii.x * dr / cone.height;\n    \n    vec3 D = ray.origin - cone.origin;\n    float DdA = dot(D, cone.axis);\n    float DdD = dot(D, D);\n    float VdA = dot(ray.direction, cone.axis);\n    float VdD = dot(ray.direction, D);\n    float VdV = dot(ray.direction, ray.direction);\n    \n    float c0 = pow(cone.radii.x, 2.) + 2. * R * DdA + r * pow(DdA, 2.) - DdD;\n    float c1 = R * VdA + r * DdA * VdA - VdD;\n    float c2 = r * pow(VdA, 2.) - VdV;\n    \n    // Quadratic equation, solve with discriminant\n    if ( c2 != 0. ) {\n    \tfloat discr = c1 * c1 - c2 * c0;\n        \n        // No real solution, no intersection\n        if ( discr < 0. ) \n            return false;\n        \n        // Two intersection points. Select best or reject.\n        else if ( discr > 0. ) {\n        \tfloat root = sqrt(discr);\n            int quantity = 0;\n            \n            float x0 = (-c1 -root) / c2;\n            vec3 p = D + x0 * ray.direction;\n            \n            // Check if valid ray-cone section intersection\n            float d = dot(cone.axis, p);\n            if (x0 >= 0. && d >= 0. && d <= cone.height) {\n                vec3 n = normalize(p - d * cone.axis);\n                float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n                normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n            \tt = x0;\n                quantity += 1;\n            } \n            \n            float x1 = (-c1 + root) / c2;\n            p = D + x1 * ray.direction;\n            d = dot(cone.axis, p);\n            \n            // Check if valid ray-cone section intersection and if x0 isn't a more adequate solution\n            if (x1 >= 0. && (x1 < x0 || quantity == 0) && d >= 0. && d <= cone.height) {\n                vec3 n = normalize(p - d * cone.axis); \n                float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n                normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n                t = x1;\n                quantity += 1;\n            }\n            \n            return quantity > 0;\n            \n        // One intersection. Ray tangent to the cone surface, but not parallel\n        } else {\n            float x = -c1 / c2;\n            vec3 p = D + x * ray.direction;\n            float d = dot(cone.axis, p);\n            \n            // Check if valid ray-cone section intersection\n            if (x > 0. && d >= 0. && d <= cone.height) {\n                vec3 n = normalize(p - d * cone.axis); \n                float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n                normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n                t = x;\n                return true;\n            }\n            return false;\n        }\n    \n    // Linear solution. Ray is parallel to cone surface.\n    } else if (c1 != 0.) {\n        float x = 0.5 * c0 / c1;\n        vec3 p = D + x * ray.direction;\n        float d = dot(cone.axis, p);\n        if (x > 0. && d >= 0. && d <= cone.height) {\n            vec3 n = normalize(p - d * cone.axis); \n            float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n            normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n            t = x;\n            return true;\n        }\n        return false;\n    }\n    \n    return false;        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 origin; vec3 dir;\n    Ray screenRay = getScreenRay(uv);\n    screenRay.origin += 0.2 * screenRay.direction;\n    \n    float t = PI +iTime;\n    vec3 normal = vec3(0,0,0);\n    \n    vec3 axis = vec3(0,1,0.4);\n    ConeFrustum cone;\n    cone.origin = vec3(0,-1.2,0.1);\n    cone.axis = normalize(axis);\n    cone.radii = vec2(0.7, 0.7 + 0.4 * cos(iTime / 3.));\n    cone.height = 2.;\n    \n    bool intersect = intersectConeFrustum(screenRay, cone, t, normal);\n    \n\n    // Output to screen \n    if (intersect) {\n        fragColor = vec4(vec3(1) * (dot(normalize(-vec3(1,1,1)), -normal) * 0.7 + 0.3), 1);\n        fragColor = vec4(normal * 0.5 + 0.5, 1);\n    } else {\n        fragColor = vec4(screenRay.direction*0.5+0.5,1.0);\n        fragColor = vec4(1);\n    }\n}","name":"Image","description":"","type":"image"}]}