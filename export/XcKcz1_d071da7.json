{"ver":"0.1","info":{"id":"XcKcz1","date":"1731496846","viewed":313,"name":"Spots in Time","username":"TinyTexel","description":"camera controls via mouse + shift key\nbreaks if viewport is too small","likes":16,"published":3,"flags":48,"usePreview":0,"tags":["waves","water","bloom","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    camera controls via mouse + shift key\n*/\n\nvec3 Hue(float x)\n{\n    float r = 1.0 - x * 2.0;\n    float b = -r;\n    float g = 1.0 - max(r, b);\n    \n    return vec3(max(0.0, r), g, max(0.0, b));\n}\n\nvec2 DistortTC(vec2 tc, float k2, float k4)\n{\n    vec2 vec = (tc - 0.5);\n    float r2 = dot(vec, vec);\n    float r4 = r2 * r2;\n    \n    return 0.5 + vec / ((1.0 + r2 * k2 + r4*r4 * k4) / (1.0 + 0.5 * k2 + 0.25*0.25 * k4)); \n    return 0.5 + vec / ((1.0 + r2 * k2 + r4 * k4) / (1.0 + 0.5 * k2 + 0.25 * k4)); \n}\n\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat Read(vec2 tc)\n{\n    //return mix(textureLod(iChannel1, tc, 0.0).g, textureLod(iChannel1, tc, 0.0).r, 0.5);\n    return textureLod(iChannel1, tc, 0.0).a;\n}\n\nvec4 bspline(float x)\n{\n\tfloat x2 = x * x;\n\tfloat x3 = x2 * x;\n\tvec4 w;\n\tw.x = -x3 + 3.0 * x2 - 3.0 * x + 1.0;\n\tw.y = 3.0 * x3 - 6.0 * x2 + 4.0;\n\tw.z = -3.0 * x3 + 3.0 * x2 + 3.0 * x + 1.0;\n\tw.w = x3;\n\treturn w / 6.0;\n}\n\nvec4 SampleCubic(sampler2D Tex, vec2 uvI, vec2 uvF, vec2 rcpTexSize)\n{\n\tvec4 cubicX = bspline(uvF.x);\n\tvec4 cubicY = bspline(uvF.y);\n\n\tvec2 cX = uvI.xx + vec2(-0.5, 1.5);\n\tvec2 cY = uvI.yy + vec2(-0.5, 1.5);\n\n\tvec2 sX = cubicX.xz + cubicX.yw;\n\tvec2 sY = cubicY.xz + cubicY.yw;\n\n\tvec2 offsetX = cX + cubicX.yw / sX;\n\tvec2 offsetY = cY + cubicY.yw / sY;\n\n\tvec4 value0 = textureLod(Tex, vec2(offsetX.x, offsetY.x) * rcpTexSize, 0.0);\n\tvec4 value1 = textureLod(Tex, vec2(offsetX.y, offsetY.x) * rcpTexSize, 0.0);\n\tvec4 value2 = textureLod(Tex, vec2(offsetX.x, offsetY.y) * rcpTexSize, 0.0);\n\tvec4 value3 = textureLod(Tex, vec2(offsetX.y, offsetY.y) * rcpTexSize, 0.0);\n\n\tfloat lX = sX.x / (sX.x + sX.y);\n\tfloat lY = sY.x / (sY.x + sY.y);\n\n\treturn mix(mix(value3, value2, lX),\n\t\t       mix(value1, value0, lX), lY);\n}\n\n\nvec4 SampleCubic(sampler2D Tex, vec2 uv, vec2 rcpTexSize)\n{\n    //return textureLod(Tex, uv * rcpTexSize, 0.0);\n\n\tuv -= 0.5;\n\n\tvec2 uvI = floor(uv);\n\tvec2 uvF = uv - uvI;\n\t\n\tvec4 r = SampleCubic(Tex, uvI, uvF, rcpTexSize);\n    \n    return r;\n}\n\n// C. Schlick. \"Fast alternatives to Perlin’s bias and gain function\"\n// inverse(Bias(x,s)) =   Bias(x  ,1-s)\n// inverse(Bias(x,s)) = 1-Bias(1-x,  s)\nfloat Bias(float x, float s)\n{\n    if(s == 0.0) return x != 1.0 ? 0.0 : 1.0;\n    if(s == 1.0) return x != 0.0 ? 1.0 : 0.0;\n    \n    return x / ((1.0/s - 2.0) * (1.0 - x) + 1.0);\n}\n\nvec3 Bias(vec3 x, float s)\n{\n    return vec3(Bias(x.x, s), Bias(x.y, s), Bias(x.z, s));\n}\n\nfloat Bump0(float x, float e)\n{\n    return (x - x*x) * pow(x, e);\n}\n\nfloat Bump(float x, float e)\n{\n    return Bump0(x, e) / Bump0((1.0 + e) / (2.0 + e), e);\n}\n\nfloat Curve(float x, vec2 p0, vec2 p1, vec2 p2)\n{\n    //x = clamp(x, p0.x, p2.x);\n    \n    bool isLeft = x < p1.x;\n        \n    vec2 pO = isLeft ? p0 : p2;\n    \n    float dx = pO.x - p1.x;\n    \n    float s = (p2.y - p0.y) / (p2.x - p0.x);\n    \n    float yA =  p1.y * 3.0 + s * dx;\n    float yB = (pO.y * 3.0 + yA) * 0.5;\n\n    float y0 = isLeft ? p0.y : p1.y;\n    float y1 = isLeft ?   yB : yA;    \n    float y2 = isLeft ?   yA : yB;\n    float y3 = isLeft ? p1.y : p2.y;\n\n    float x0 = isLeft ? p0.x : p1.x;\n    float t = (x - x0) / abs(dx);\n\n    float l = 1.0 - t;\n\n    float tt = t * t;\n    float ll = l * l;\n\n    return (y0 * l + y1 * t) * ll +\n           (y3 * t + y2 * l) * tt;\n}\n\nvec3 Curve(vec3 x, vec2 p0, vec2 p1, vec2 p2)\n{\n    return vec3(Curve(x.x, p0, p1, p2),\n                Curve(x.y, p0, p1, p2),\n                Curve(x.z, p0, p1, p2));\n}\n\nvec3 ColFoo(vec3 rgb)\n{\n    float mx = max(rgb.r, max(rgb.g, rgb.b));\n    \n    float V = mx;\n    \n    //if(v == 0.0) return vec3(0.0);\n    \n    rgb /= V != 0.0 ? V : 1.0;\n    \n    float mn = min(rgb.r, min(rgb.g, rgb.b));\n    \n    float S = 1.0 - mn;\n    \n    //if(mn == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - mn);// / S;\n    rgb /= S != 0.0 ? S : 1.0;\n    \n    vec3 H = rgb;\n    \n    float L = V * (1.0 - S * 0.5);\n    float S2 = L == 0.0 || L == 1.0 ? 0.0 : (V - L) / min(L, 1.0 - L);\n    //V = 0.9;\n    \n    L = mix(L, 1.0, 25.0*0.5/100.0);\n    S2 *= -25.0/100.0 + 1.0;\n    \n    V = L + S2 * min(L, 1.0 - L);\n        S = V == 0.0 ? 0.0 : 2.0 - L/V * 2.0;\n    \n    return mix(vec3(1.0), H, S) * V;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    vec2 tc = uv0 / iResolution.xy;\n    \n    float count = 5.0;\n    vec3 wa = vec3(0.0);\n    \n   #if 0\n    for(float i = 0.0; i < count; ++i)\n    {\n        float rnd = fract(dot(uv, rPhif2));\n        rnd = IGN(uv);\n        //rnd = abs(rnd * 2.0 - 1.0);\n    \n        float x = i / (count - 1.0);\n        //x = (i + rnd) / (count - .0);\n        \n        float k2 = mix(0.1, 0.2, 1.0-x) * 1.0;\n        float k4 = k2*-3.0;\n        //k4 = 0.00;\n        k2 = 0.0;\n        //k2 = -mix(0.1, 0.2, 1.0-x)*.75;\n        \n        vec2 tc2 = DistortTC(tc, k2, k4);\n\n        x = pow(1.0 - (x), 2.0);\n        //x *= mix(1.0, x, 0.5);\n        \n        vec3 w = Hue(x);\n        //w = Hue_to_RGB((x-0.5)*0.5+0.5);\n        col += vec3(Read(tc2)) * w;\n        wa += w;\n    }\n    \n    col /= wa;\n    //col = Hue(tc.x);\n   #elif 1\n    #if 1\n    count = 4.0;\n    for(float i = 0.0; i < count; ++i)\n    {\n        float rnd = fract(dot(uv, rPhif2));\n        rnd = IGN(uv);\n        rnd = abs(rnd * 2.0 - 1.0);\n    \n        float x = i / (count - 1.0);\n        x = (i + rnd) / (count - .0);\n        \n        float k2 = (1.0-x) *-0.02;\n        float k4 = (1.0-x) *-0.;\n        //k4 = 0.00;\n        //k2 = 0.0;\n        //k2 = -mix(0.1, 0.2, 1.0-x)*.75;\n        \n        vec2 tc2 = DistortTC(tc, k2, k4);\n\n        x = pow(1.0 - (x), 2.0);\n        //x *= mix(1.0, x, 0.5);\n        \n        vec3 w = Hue(x);\n        //w = Hue_to_RGB((x-0.5)*0.5+0.5);\n        col += vec3(Read(tc2)) * w;\n        wa += w;\n    }\n    \n    col /= wa;\n    \n    uv0 = DistortTC(uv0 / iResolution.xy, -0.01, -0.0) * iResolution.xy;\n    #else\n    col = vec3(Read(tc));\n    #endif\n    \n    vec3 col2 = vec3(0.0);\n    //col2 =           SampleCubic(iChannel1, DownsampleUVs(uv0, 4.0) + GetRect4().xy, 1.0 / iResolution.xy).bbb;\n    //col2 = mix(col2, SampleCubic(iChannel2, DownsampleUVs(uv0, 3.0) + GetRect3().xy, 1.0 / iResolution.xy).rrr, 1.0);\n    col2 =           SampleCubic(iChannel2, DownsampleUVs(uv0, 3.0) + GetRect3().xy, 1.0 / iResolution.xy).rrr*vec3(0.8, 1., 1.);\n    col2 = mix(col2, SampleCubic(iChannel1, DownsampleUVs(uv0, 2.0) + GetRect2().xy, 1.0 / iResolution.xy).bbb*vec3(1.0, 0.7, 0.7), 0.2);\n    col2 = mix(col2, SampleCubic(iChannel1, DownsampleUVs(uv0, 1.0) + GetRect1().xy, 1.0 / iResolution.xy).bbb*vec3(1.0, 0.9, 0.5), 0.2);\n    \n    float wb = SampleCubic(iChannel1, DownsampleUVs(uv0, 4.0) + GetRect4().xy, 1.0 / iResolution.xy).b;\n    \n    col2 = mix(col2, vec3(wb), 0.6)*vec3(0.95, 0.87, 1.0);\n    col2 = mix(col2, vec3(1.0)*vec3(0.75, 0.9, 1.0), 0.01);\n    col *= vec3(0.95, 1.0, 0.9);\n    \n    //col2 = mix(col2, SampleCubic(iChannel1, DownsampleUVs(uv0, 1.0) + GetRect1().xy, 1.0 / iResolution.xy).rrr, 1.0);\n    //col = vec3(Read(tc));\n    col = mix(col, col2, 0.5);\n    \n    float g;\n    {\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s *= s; s *= s; s = 1.0 - s;\n        float u = 1.0 - (s.x*s.y);\n        //col *= mix(1.0, 0.7, u);\n        g = 1.0 - u;\n    }\n    vec3 col3 = SampleCubic(iChannel1, DownsampleUVs(uv0, 3.0) + GetRect2BPos().xy, 1.0 / iResolution.xy).bbb;\n    col3 *= mix(vec3(0.7, 0.8, 1.0), vec3(1., 0.8, 0.8), 1.0-g);\n    //col3 = clamp(col3, 0.0, 1.0);\n    //col3 *= vec3(0.75, 0.85, 1.0);\n    //col3 *= vec3(1., 0.8, 0.8);\n    col += col3 * 0.05;// * (1.0 + wb*10.0);\n    \n   // col = col3;\n    //col = mix(col, col3 * vec3(0.7, 0.8, 1.0), 0.005);\n    //col += col3 * vec3(1., 0.7, 0.7) * 0.02;\n    //col += col3 * vec3(0.7, 0.8, 1.0) * 0.02;\n    //col += col3 * vec3(0.7, 0.8, 1.0)*wb;\n    //outCol = vec4(col3, 0.0); return;\n    \n    //col = mix(col, vec3(1.0), 0.004);\n    //col = vec3(Read(tc));\n      //  col =           SampleCubic(iChannel1, DownsampleUVs(uv0, 4.0) + GetRect4().xy, 1.0 / iResolution.xy).aaa;\n   // col = SampleCubic(iChannel2, DownsampleUVs(uv0, 3.0) + GetRect3().xy, 1.0 / iResolution.xy).rrr;\n\n    //col = col2.rgb;\n    //col =           SampleCubic(iChannel1, DownsampleUVs(uv0, 4.0) + GetRect4().xy, 1.0 / iResolution.xy).bbb;\n    \n    //col = EvalLensFlares(uv0);\n    //col = ReadU(uv0); outCol = vec4(col, 0.0); return;\n     \n    //col = textureLod(iChannel1, tc, 0.0).bbb*100.0; outCol = vec4(col, 0.0); return;\n    //col = textureLod(iChannel0, tc, 0.0).rrr;\n    //col = textureLod(iChannel2, tc, 0.0).rgb;\n   \n    #if 0\n    col *= vec3(1.0, 0.1, 0.03)*1.6;\n    //col *= 23.0;\n    \n    //col += vec3(0., 0.6, 1.0) * 0.003;\n    col += vec3(0., 0.3, 1.0) * 0.00;\n    #endif\n    \n   #else\n    col = vec3(Read(tc));\n   #endif \n\n  #if 0\n    col *= vec3(1.0, 0.1, 0.03)*1.6;\n    \n    col *= 40.0;\n    //col *= vec3(0.5, 0.5, 1.0);\n    col = col / (1.0 + col) * 1.;\n    \n    col = mix(col, dot(col, vec3(0.21, 0.71, 0.08))*vec3(1.0), -0.4);\n  #elif 1\n    col *= 8.0;\n    col *= vec3(vec2(0.85), 1.0);\n    //col *= vec3(0.8, 0.9, 1.0);\n    //col = col / sqrt(1.0 + col*col);\n    col = col / (1.0 + col);\n    //col = 1.0 - exp(-col * 1.0);\n    //col = mix(vec3(1., 0.4, 0.2)*0.01, vec3(1.0), col);\n    //col = mix(vec3(.1, 0.7, 1.)*0.015, vec3(1.0), col);\n    //col = mix(vec3(.1, 0.7, 1.)*0.05*sqrt(col), vec3(1.0), col);\n    \n    col = pow(col, vec3(1.4));\n    col = mix(col, dot(col, vec3(0.21, 0.71, 0.08))*vec3(1.0), -2.0);\n    \n  #elif 1  \n    col *= vec3(1.0, 0.4, 0.1);\n    col *= 8.0;\n    //col = col / sqrt(1.0 + col*col);\n    float L = dot(col, vec3(0.21, 0.71, 0.08));\n    float Lt = L / (1.0 + L);\n    \n    //float u = dot(col / (1.0 + col), vec3(0.21, 0.71, 0.08));\n    float u = Lt;\n    \n    //col = mix(col, vec3(1.0), u);\n    col = mix(col, dot(col, vec3(0.21, 0.71, 0.08))*vec3(1.0), u);\n    //col *= Lt / L;\n    //col = col / sqrt(1.0 + col*col);\n    col = col / (1.0 + col);\n    //col = 1.0 - exp(-col * 1.0);\n    col = pow(col, vec3(1.2));\n    col = mix(col, dot(col, vec3(0.21, 0.71, 0.08))*vec3(1.0), -2.0);\n  #endif\n    \n    //col = pow(col, vec3(1.2));\n\n    #if 1\n    {\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s *= s; s *= s; s = 1.0 - s;\n        float u = 1.0 - sqrt(s.x*s.y);\n        col *= mix(1.0, 0.7, u);\n    }\n    #endif\n    \n    #if 1\n    {\n        float r2 = fract(dot(uv, vec2(0.7548776662, 0.56984029)));\n        r2 = IGN(uv);\n        r2 = abs(r2 * 2.0 - 1.0);\n        col += (r2 - 0.5) * (0.5/256.0);\n    }\n    #endif \n    \n    #if 0\n    float L = max(col.r, max(col.g, col.b));\n    float Lt = L / sqrt(1.0+L*L);\n    //float Lt = TONE_TF(L);\n    Lt = clamp01(Lt);\n    \n    col2 = col * (Lt / L);\n    \n    float L2 = dot(col2, vec3(0.212586230785595520, 0.71517030370341080, 0.07220049864333620));\n    L2 = mix(L2, 1.0, 0.);\n    vec3 vec = 1.0 - col2;\n    //col = col2 + (normalize(vec) * (length(vec) * (1.0-Pow4(1.0-Bias(Lt, mix(0.0, 0.04, L2)))) ));\n    col = col2 + (normalize(vec) * (length(vec) * (1.0-Pow2(1.0-Bias(Lt, mix(0.0, 0.2, L2)))) ));\n    #endif\n    \n    //col = textureLod(iChannel0, tc, 0.0).rgb;\n    col = sRGB_Encode(clamp01(col));\n    float mn = min(col.r, min(col.g, col.b));\n    float mx = max(col.r, max(col.g, col.b));\n    float md = (col.r + col.g + col.b) - mn - mx;\n    float l = (md - mn) / (mx - mn);\n    vec3 mnm = mix(vec3(0.0), vec3(1.0), equal(col, vec3(mn)));\n    vec3 mxm = mix(vec3(0.0), vec3(1.0), equal(col, vec3(mx)));\n    vec3 mdm = vec3(1.0) - mnm - mxm;\n    vec3 mm = mnm + mxm;\n    vec3 colo = col;\n    //col = mix(col, vec3(1.0), 100.0/255.0);\n    float mc = mix(dot(col, mnm), dot(col, mxm), l);\n    //col = col * mm + mc * mdm;\n    //col = mdm;\n    //col = col + ((100.0/255.0) * (1.0 - col));\n    \n   #if 1\n    col.r = Bias(col.r, 0.49);\n    col.g = Bias(col.g, 0.52);\n    col.b-= Bump(col.b, 14.0) * 0.2;\n    col.g-= Bump(col.g, 8.0) * 0.05;\n    col.r+= Bump(1.0-col.b, 8.0) * 0.02;\n    #if 1\n    //col.r+= Bump(col.r, 2.0) * 0.0;\n    col.r-= Bump(col.r, 16.0) * 0.1;\n    #endif\n    col.b = Bias(col.b, 0.53);\n    col = pow(col, vec3(1.04));\n   #endif\n    \n  #if 0\n    col = ColFoo(col);\n  #elif 0\n    col = ColFoo(col);\n    //col = Bias(col, 0.6);    \n    //col = pow(col, vec3(0.8));\n    //col = mix(col, vec3(max(max(col.r, col.g), col.b)), 0.2);\n    //col = mix(col, dot(col, vec3(1.0,1.0,1.0))*vec3(0.3333), 0.2);\n    //col = mix(col, dot(col, vec3(0.21, 0.71, 0.08))*vec3(1.0), 0.1);\n    //col = floor(col * 256.0)/256.0;\n    #if 1\n    float V0 = max(col.r, max(col.g, col.b));\n    float V  = Curve(V0, vec2(0.0, 0.0), vec2( 55.0,  37.0)/255.0, vec2(235.0/255.0, 1.0));\n    \n    col.r = Curve(col.r, vec2(0.0, 0.0), vec2(180.0, 86.0)/255.0, vec2(252.0/255.0, 1.0));\n    col.g = Curve(col.g, vec2(0.0, 0.0), vec2( 13.0,  67.0)/255.0, vec2(245.0/255.0, 1.0));\n    col.b = Curve(col.b, vec2(0.0, 0.0), vec2( 49.0,  85.0)/255.0, vec2(1.0, 255.0/255.0));\n    \n    //V0 = max(col.r, max(col.g, col.b));\n    \n    col *= V / V0;\n    col = mix(col, col*col, 0.4)*1.05;\n    \n    //col   = Curve(col,   vec2(0.0, 0.0), vec2( 55.0,  37.0)/255.0, vec2(235.0/255.0, 1.0));\n    \n    //col   = Curve(col,   vec2(0.0, 0.0), vec2( 47.0,  19.0)/255.0, vec2(235.0/255.0, 1.0));\n    #endif\n  #elif 0\n    col *= 0.94;\n    col = ColFoo(col);\n  \n    col = Bias(col, 0.6);\n    col = mix(col, dot(col, vec3(0.21, 0.71, 0.08))*vec3(1.0), 0.3);\n    \n    col.r = Curve(col.r, vec2(0.0, 0.0), vec2(193.0, 100.0)/255.0, vec2(250.0/255.0, 1.0));\n    col.g = Curve(col.g, vec2(0.0, 0.0), vec2( 55.0, 118.0)/255.0, vec2(1.0, 188.0/255.0));\n    col.b = Curve(col.b, vec2(0.0, 0.0), vec2( 73.0, 108.0)/255.0, vec2(1.0, 246.0/255.0));\n    col   = Curve(col,   vec2(0.0, 0.0), vec2( 55.0,  34.0)/255.0, vec2(204.0/255.0, 1.0));\n    \n    col = mix(col, col*col, 0.25)*1.1;\n    //col = mix(col, col*col, 0.5)*1.15;\n    \n  #endif\n    //col = col.ggg;\n    //col *= vec3(0.9, 0.9, 1.0);\n    outCol = vec4(col, 0.0);\n    //outCol = vec4(col, 0.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\nvec2 cmul(vec2 c, float ang)\n{\n    return cmul(c, vec2(cos(ang), sin(ang)));\n}\n\nvec2 BoxMuller(vec2 h)\n{\n    float ang = h.x * Pi2;\n    \n    float rad = sqrt(-log2(h.y));\n\n    return vec2(cos(ang), sin(ang)) * rad;\n}\n\nvec2 DFT_Horizontal(ivec2 uviF, ivec2 srcRectId)\n{\n    if(uviF.y >= DFTRange05Int && uviF.y < GridSizeInt - DFTRange05Int) discard;\n\n    ivec2 uviBase = GridSizeInt * srcRectId;\n\n    float ang0 = -Pi2/GridSize * float(uviF);\n\n    vec2 res = vec2(0.0);\n    for(int i = 0; i < GridSizeInt; ++i)  \n    {\n        if(i == DFTRange05Int) i += GridSizeInt - DFTRangeInt;\n\n        vec4 v = texelFetch(iChannel0, uviBase + ivec2(i, uviF.y), 0);\n\n        float ang = ang0 * float(i);\n\n        res += cmul(v.xy, ang);\n    }\n    \n    return res;\n}\n\nvec2 DFT_Vertical(ivec2 uviF, ivec2 srcRectId)\n{\n    ivec2 uviBase = GridSizeInt * srcRectId;\n\n    float ang0 = -Pi2/GridSize * float(uviF.y);    \n\n    vec2 res = vec2(0.0);\n    for(int i = 0; i < GridSizeInt; ++i)  \n    {\n        if(i == DFTRange05Int) i += GridSizeInt - DFTRangeInt;\n\n        vec4 v = texelFetch(iChannel0, uviBase + ivec2(uviF.x, i), 0);\n\n        float ang = ang0 * float(i);\n\n        res += cmul(v.xy, ang);\n    }\n\n    return res;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    if(uv0.x < GridSize * 3.0 && uv0.y < GridSize * 2.0)\n    {\n        vec2 uv = uv0.xy - 0.5;\n        \n        ivec2 uvi = ivec2(uv);\n        \n        uvec2 uvI = uvec2(uvi) / GridSizeUInt;\n        uvec2 uvF = uvec2(uvi) - uvI.xy * GridSizeUInt;\n        \n        ivec2 uviI = ivec2(uvI);\n        ivec2 uviF = ivec2(uvF);\n        \n        //ivec2 uvi2 = ivec2(uvF.x + (uvI.x + 1u) * GridSizeUInt, uvi.y);\n        //vec4 col = texelFetch(iChannel0, ivec2(uvF, uvi.y), 0);\n        \n        col = vec4(0.0);\n        \n        if(uvI.x == 2u)\n        {\n            //uv.x -= GridSize * 2.0;\n            uv = vec2(uvF);\n            \n            // [0, size) -> [-size/2, size/2); makes uv match coefficient index/wave number\n            if(uv.x >= GridSize*0.5) uv.x -= GridSize;\n            if(uv.y >= GridSize*0.5) uv.y -= GridSize;\n            \n            float size = 2.;\n            vec2 k = uv / size;\n            float k0 = length(k);\n            vec2 kdir = normalize(k);\n            vec2 wdir = normalize(vec2(1.0, 1.0));\n            float o0 = dot(kdir, wdir);\n            float o = o0 * o0;\n            o *= o;\n            //o *= o;\n\n            float V = 2.5;\n\n            float e = 2.71828;\n            float g = 9.81;\n            float L = Pow2(V) / g;\n            //L = 0.03;\n            float ph = exp(-1.0 / Pow2(k0*L)) / Pow4(k0);\n            ph *= Pow2(e) / Pow3(L) * 0.25 * 0.001;// norm maximum to 1\n            //ph *= 1.0 / (Pow2(L) * Pi);// norm integration to 1\n            \n            ph *= o;\n\n            float l = L * 0.5;\n            //ph *= exp2(-Pow2(l*k0));\n\n            //float v = exp2(-dot(tc2, tc2));\n            float v = sqrt(ph);\n            \n            bool neg = o0 < 0.0;\n            //bool neg = uv.x < 0.0 || (uv.x == 0.0 && uv.y < 0.0);\n            //neg = uv.y < 0.0 || (uv.y == 0.0 && uv.x < 0.0);\n            \n            vec2 h = Hash01x2(neg ? -uv : uv, 2856u);\n            \n            float ang = h.x * Pi2;\n\n            {\n                // deep water dispersion + surface tension ( https://en.wikipedia.org/wiki/Capillary_wave )\n                float p_air =   1.2 ;// kg/m³\n                float p_wat = 998.0 ;// kg/m³\n                float o_wat =  0.072;// J/m² = (kg*m²/s²)/m² = kg/s²\n                float g     =   9.81;// m/s²\n\n                float a = (p_wat - p_air) / (p_wat + p_air) * g;\n                float b = o_wat / (p_wat + p_air);\n\n                float w = sqrt(k0 * (a + b * (k0*k0)));\n        \n                ang += w * iTime;\n            }\n            \n            vec2 vec = vec2(cos(ang), sin(ang));\n            \n            float mag = sqrt(-log2(h.y));\n            \n            v *= mag;\n            \n            \n            v /= size;\n            v /= size;\n\n            v *= 0.4;\n\n            vec2 tc = uv / (GridSize * 0.5) * Pi;\n                        \n            //if(dot(tc, tc) < Pi*Pi*0.125*0.125*0.25 || dot(tc, tc) >= Pi*Pi*0.125*0.125*0.5) v = 0.0; else v *= 2.0;\n            if(dot(tc, tc) >= Pi*Pi*0.25) v = 0.0;\n            if(uv.x == 0.0 && uv.y == 0.0) v = 0.0;\n            \n            #if 0\n            {\n               // test individual harmonics\n               v = 0.0;\n               vec = vec2(1.0, 0.0);\n               float count = 0.0;\n               \n               {\n                   float r = 6.0;\n                   float msk = abs(uv.x) == 0.0 && abs(uv.y) == r ? 1.0 : 0.0;\n\n                   if(msk != 0.0)\n                   {\n                       v = 0.5 / (Pi * r);\n                       vec = vec2(1.0, 0.0);\n                   }\n                   \n                   ++count;\n               }\n               \n               if(false)\n               {\n                   float r = 6.0;\n                   float msk = abs(uv.y) == 0.0 && abs(uv.x) == r ? 1.0 : 0.0;\n\n                   if(msk != 0.0)\n                   {\n                       v = 0.5 / (Pi * r);\n                       vec = vec2(1.0, 0.0);\n                   }\n                   \n                   ++count;\n               }               \n               \n               //if(false)\n               {\n                   float r = 3.0;\n                   float msk = abs(uv.y) == r && abs(uv.x) == r ? 1.0 : 0.0;\n\n                   if(msk != 0.0)\n                   {\n                       v = 0.5 / (Pi * r);\n                       vec = vec2(1.0, 0.0);\n                   }\n                   \n                   ++count;\n               }\n               \n               v /= count;\n            }\n            #endif\n            \n            vec *= v;\n\n            #if 1\n            {                \n               #if 0\n               float r = 2.0;\n                float msk = uv.x == 0.0 && abs(uv.y) == r ? 1.0 : 0.0;\n                      msk = uv.y == 0.0 && abs(uv.x) == r ? 1.0 : 0.0;\n                //msk = abs(uv.x) == r && abs(uv.y) == r ? 1.0 : 0.0;\n                //msk = ((uv.x) == 8.0) && ((uv.y) == 8.0) ? 1.0 : 0.0;\n                //msk+= ((uv.x) ==-8.0) && ((uv.y) ==-8.0) ? 1.0 : 0.0;\n                //msk = ((uv.x) ==-8.0) && ((uv.y) == 8.0) ? 1.0 : 0.0;\n                //msk+= ((uv.x) == 8.0) && ((uv.y) ==-8.0) ? 1.0 : 0.0;\n               \n                float ang = iTime * .0;\n                vec = vec2(cos(ang), sin(ang));\n                vec *= msk * 0.5/r/Pi;\n                //v = 0.18;\n               #endif\n               \n               \n                if(uvI.y == 1u)\n                {\n                    vec = vec2(-vec.y, vec.x);\n                }\n                \n                vec2 vecB = vec;\n                vecB = vec2(-vecB.y, vecB.x);\n                \n                if(!neg)\n                {\n                    vec.y  *= -1.0;\n                    vecB.x *= -1.0;\n                }\n\n                if(uv.x != 0.0 || uv.y != 0.0)\n                {\n                    if(uvI.y == 0u)\n                    {\n                        {\n                            vecB /= k0/GridSize;\n                            //vecB /= mix(k0*0.4, 1.0, 0.1);\n                            //cB *= 0.75 + 0.25 * exp2(-Pow2(k0 * 0.25*1.));\n                        }\n                    }\n                    else\n                    {\n                        float oX = dot(kdir, wdir);\n                        float oY = dot(kdir, vec2(-wdir.y, wdir.x));\n\n                        vec  *= abs(oX);//(kdir.x);\n                        vecB *= abs(oY);//(kdir.y);\n                    }\n                }\n                \n                vec += vecB;\n                \n                //v *= 4.0;\n            }\n            #endif\n            //v = 1.0; vec = vec2(1.0, 0.0);\n\n            \n            //vec2 fu = ((1.0 + cos(tc)) * (2.0 + cos(tc))) * 0.2;\n            //v *= exp2(-dot(tc, tc)*0.5);\n            //v=1.0/GridSize/GridSize;\n            //v /= fu.x*fu.y+0.0000001;\n\n            \n            //if(abs(uv.x) == GridSize*0.5 && abs(uv.y) == GridSize*0.5) v = 0.0;\n            \n           #if 0\n            v = 0.0;\n            if((uv.x) == 1.0 && uv.y == 0.0) v = 1.0;\n            vec = vec2(1.0, 0.0);\n            v *= 1.0;\n           #endif\n            \n            //col = vec4(v);\n            col = vec4(vec, 0.0, 0.0);\n        }\n        else if(uvI.x == 1u)\n        {\n            // horizontal DFT pass\n            col.rg = DFT_Horizontal(uviF, ivec2(2, uviI.y));\n        }\n        else if(uvI.x == 0u)\n        {\n            // vertical DFT pass\n            col.rg = DFT_Vertical(uviF, ivec2(1, uviI.y));\n            \n            col.xy /= 2.0;//[-1,1] -> [-0.5, 0.5]\n            \n            vec2 k = vec2(16.0, 8.0);\n            //col.x = cos(dot(uv/GridSize*Pi*2.0, k)) * 0.01;col.y = 0.0;\n            //col.xy = vec2(uv0.x-0.5 == GridSize*0.5 && uv0.y-0.5 == GridSize*0.5 ? .5125 : 0.0, 0.0);\n        }\n        \n        return;\n    }\n    \n    /* program state */\n    if(uv0.y != StateUVy + 0.5) discard;\n    \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, StateUVy), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, StateUVy), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == StateUVy) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == StateUVy) col = vec4(iMouseAccu1, iMouseAccu2);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nvec2 Resolution;\n\nconst float GridSize = 256.0;// vertex count per dimension\nconst uint GridSizeUInt = uint(GridSize);\nconst int GridSizeInt = int(GridSize);\n\nconst int DFTRangeInt = GridSizeInt / 2;\nconst int DFTRange05Int = DFTRangeInt / 2;\n            \nconst float StateUVy = 256.0 * 2.0;\n//const float StateUVy = GridSize * 2.0;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Z 90\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_Y 89\n#define KEY_X 88\n#define KEY_C 67\n#define KEY_V 86\n#define KEY_B 66\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_N0 48\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n#define KEY_N9 57\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat sRGB_Encode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_Decode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_Encode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_Decode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n////////////////////////////////////////////// CUBEMAP UTILITIES ///////////////////////////////////////////// \n//==========================================================================================================//\n\n#define ISCUBEFACE_COMMON vec3 adir = abs(rayDir); float mxdir = max(adir.x, max(adir.y, adir.z));\nbool IsCubeFaceXn(vec3 rayDir) { ISCUBEFACE_COMMON return mxdir == adir.x && rayDir.x < 0.0; }\nbool IsCubeFaceXp(vec3 rayDir) { ISCUBEFACE_COMMON return mxdir == adir.x && rayDir.x > 0.0; }\nbool IsCubeFaceYn(vec3 rayDir) { ISCUBEFACE_COMMON return mxdir == adir.y && rayDir.y < 0.0; }\nbool IsCubeFaceYp(vec3 rayDir) { ISCUBEFACE_COMMON return mxdir == adir.y && rayDir.y > 0.0; }\nbool IsCubeFaceZn(vec3 rayDir) { ISCUBEFACE_COMMON return mxdir == adir.z && rayDir.z < 0.0; }\nbool IsCubeFaceZp(vec3 rayDir) { ISCUBEFACE_COMMON return mxdir == adir.z && rayDir.z > 0.0; }\n#undef ISCUBEFACE_COMMON\n\nvec2 UVforCubeFaceXn(vec2 uv) { return vec2(1024.0 - uv.y,          uv.x); }\nvec2 UVforCubeFaceXp(vec2 uv) { return vec2(1024.0 - uv.y, 1024.0 - uv.x); }\nvec2 UVforCubeFaceYn(vec2 uv) { return vec2(         uv.x, 1024.0 - uv.y); }\nvec2 UVforCubeFaceYp(vec2 uv) { return vec2(         uv.x,          uv.y); }\nvec2 UVforCubeFaceZn(vec2 uv) { return vec2(1024.0 - uv.x, 1024.0 - uv.y); }\nvec2 UVforCubeFaceZp(vec2 uv) { return vec2(         uv.x, 1024.0 - uv.y); }\n\n#define UVWFORCUBEFACE_COMMON vec2 tc = uv / 1024.0 - 0.5;\nvec3 UVWforCubeFaceXn(vec2 uv) { UVWFORCUBEFACE_COMMON return vec3(tc, -0.5).zxy; }\nvec3 UVWforCubeFaceXp(vec2 uv) { UVWFORCUBEFACE_COMMON return vec3(tc,  0.5).zxy; }\nvec3 UVWforCubeFaceYn(vec2 uv) { UVWFORCUBEFACE_COMMON return vec3(tc, -0.5).xzy; }\nvec3 UVWforCubeFaceYp(vec2 uv) { UVWFORCUBEFACE_COMMON return vec3(tc,  0.5).xzy; }\nvec3 UVWforCubeFaceZn(vec2 uv) { UVWFORCUBEFACE_COMMON return vec3(tc, -0.5).xyz; }\nvec3 UVWforCubeFaceZp(vec2 uv) { UVWFORCUBEFACE_COMMON return vec3(tc,  0.5).xyz; }\n#undef UVWFORCUBEFACE_COMMON\n\n\nfloat Encode15(uint bits)\n{\n    if(bits == 0u) return 0.0;\n    \n    uint b1 = (bits >> 14u) & 1u;\n    uint b10 = (bits & 1023u);\n    uint b5 = (bits >> 10u) & 31u;\n    b5 |= 1u << 4u;// prevent subnormals\n\n    bool inf = b5 == 31u;\n\n    b5 = b5 + (127u - 15u);\n    \n    if(inf) b5 = 0xffu;\n    \n    float encoded = uintBitsToFloat((b1 << 31u) | (b5 << 23u) | (b10 << (23u-10u)));\n    \n    return encoded;\n}\n\nuint Decode15(float encoded)\n{\n    uint bits = floatBitsToUint(encoded);\n    \n    uint b10 = (bits >> (23u - 10u)) & 1023u;\n    uint b5 = (bits >> 23u) & 255u;\n    uint b1 = (bits >> 31u) & 1u;\n    \n    bool inf = b5 == 0xffu;\n\n    b5 = b5 - (127u - 15u);\n\n    if(inf) b5 = 31u;\n    \n    b5 &= 15u;\n    \n    uint decoded = (b1 << 14u) | (b5 << 10u) | b10;\n    \n    return decoded;\n}\n\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    \n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. O’Neill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//---------------------------------------------------------------------------------------------//\n\nuint  Hash(inout uint state  ) { return pcg(state); }\nuint  Hash(uint  h, uint seed) { return pcg(h, seed); }\nuvec2 Hash(uvec2 h, uint seed) { return pcg3(uvec3(h, 0u), seed).xy; }\nuvec3 Hash(uvec3 h, uint seed) { return pcg3(h, seed); }\nuvec4 Hash(uvec4 h, uint seed) { return pcg4(h, seed); }\n\nvec4  Hash01x4(inout uint state) { return Float01(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash01x3(inout uint state) { return Float01(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash01x2(inout uint state) { return Float01(uvec2(pcg(state), pcg(state))); }\nfloat Hash01  (inout uint state) { return Float01(      pcg(state)); }\n\nvec4  Hash11x4(inout uint state) { return Float11(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash11x3(inout uint state) { return Float11(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash11x2(inout uint state) { return Float11(uvec2(pcg(state), pcg(state))); }\nfloat Hash11  (inout uint state) { return Float11(      pcg(state)); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n\nvec3 EvalWaxMtl(vec3 V, vec3 N)\n{\n    vec3 up = normalize(vec3(0.0, 1.0, -1.0));\n    vec3 Ld = normalize(vec3(0.5, 1.0, -0.4));\n    vec3 L  = normalize(vec3(0.75, 0.5, -1.0));\n    \n    float LdN = dot(L, N);\n    float VdN = dot(V, N);\n    vec3 H = normalize(V + L);\n\tvec3 Hr = vec3(-H.xy, H.z);\n    \n    vec3 R = N * (2.0 * dot(N, V)) - V;\n\n    float f = Pow3(clamp01(dot(N, V)));\n    \n    vec3 c = vec3(1.0, 0.04, 0.03) * 0.2;\n    c *= 1.0 + f * 0.1;\n\n    float diff = cubic(clamp01(dot(N, Ld) * 0.5 + 0.5));\n    \n    float fd = mix(f, 1.0, diff);\n\n    vec3 col = mix(vec3(1.0, 0.0, 0.0)*diff*0.15,c, clamp01(dot(N, Ld)*0.8+0.2))*fd;\n\n    float s = 0.5;\n    col += (1.0/(1.025- clamp01(dot(N, H )))) * (s*0.0015*vec3(0.75, 0.9, 1.0))*cubic(clamp01(dot(R, up)*2.))*1.5;\n    col += (1.0/(1.03 - clamp01(dot(N, Hr)))) *    0.0002*vec3(0.25, 0.6, 1.0);\n    col += vec3(0.0, 0.5, 1.0) * (0.02*s) * cubic(clamp01((dot(R, up)*0.75+0.25)*2.));\n\n    col += vec3(1.0, 0.1, 0.3)*0.05 *(1.0-fd)*f;\n    col += vec3(1.0)*0.1*(1.0-diff)*(1.0-clamp01(VdN))*(c*c+c);\n    col *= mix(1.0, 0.75, Pow4(1.0-clamp01(VdN)));\n    col *= 1.3;\n    \n    float fuzz = Pow4(clamp01(LdN) / (clamp01(LdN) + clamp01(VdN) + exp2(-16.0)));\n    col += fuzz * diff * (0.1 * vec3(0.1, 0.8, 1.0));\n    \n    col *= mix(0.5, 1.0, sqrt(clamp01(dot(N, V)))) * 1.05;\n    \n    return col;\n}\n\n\nconst float BoundaryWidth = 2.0;\n\nbool IsUVinBounds(vec2 uv, vec4 rect)\n{\n    uv -= rect.xy;\n    \n    return uv.x >= 0.0 && uv.x < rect.z && \n           uv.y >= 0.0 && uv.y < rect.w;\n}\n\nvec4 SrcRect;\nvec4 Read(sampler2D Tex, vec2 tc)\n{\n#if 1\n    // read from rect region\n    vec2 uv = tc * Resolution;\n    \n    vec2 m = clamp01(SrcRect.zw*0.5+0.5 - abs(uv - SrcRect.xy - 0.5 * SrcRect.zw));\n    \n    tc = clamp(uv, SrcRect.xy + 0.5, SrcRect.xy + SrcRect.zw - 0.5) / Resolution;\n    \n#else\n\n    vec2 m = clamp01(Resolution*0.5+0.5 - abs(tc-0.5) * Resolution);\n    \n#endif    \n\n    vec4 col = textureLod(Tex, tc, 0.0);\n        \n    return col * (m.x*m.y);// emulate black border address mode\n}\n\nvec4 BloomDownKernel21(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 4.0 + 2.0;\n    uv -= BoundaryWidth * 4.0;\n    \n    //uv.xy += (floor(noise.xy * 3.9999) - .0);\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    vec2 o = RcpSrcTexRes;\n    \n    // radial symmetry + optimal stop-band\n    float w0 = 0.1004260;\n\tfloat a  = 0.0785262;\n\tfloat b  = 0.0611137;\n    float c  = 0.0337633;\n    float d  = 0.0257451;\n    \n\tfloat oa = 1.5 + 0.4375;\n\tfloat ob = 1.5 + 0.4375;\n\tfloat oc = 3.5 + 0.34375;\n\tvec2  od = vec2(3.5, 1.5) + vec2(0.34375, 0.4375);\n\n\n\tvec4 r = vec4(0.0);\n    r += Read(Tex, tc + vec2(0.0)) * w0;\n\tr += Read(Tex, tc + (vec2(-1.0, 0.0) * o) * oa) * a;\n\tr += Read(Tex, tc + (vec2( 1.0, 0.0) * o) * oa) * a;\n\tr += Read(Tex, tc + (vec2( 0.0,-1.0) * o) * oa) * a;\n\tr += Read(Tex, tc + (vec2( 0.0, 1.0) * o) * oa) * a;\n\tr += Read(Tex, tc + (vec2(-1.0,-1.0) * o) * ob) * b;\n\tr += Read(Tex, tc + (vec2( 1.0,-1.0) * o) * ob) * b;\n\tr += Read(Tex, tc + (vec2(-1.0, 1.0) * o) * ob) * b;\n\tr += Read(Tex, tc + (vec2( 1.0, 1.0) * o) * ob) * b;\n    r += Read(Tex, tc + (vec2(-1.0, 0.0) * o) * oc) * c;\n\tr += Read(Tex, tc + (vec2( 1.0, 0.0) * o) * oc) * c;\n\tr += Read(Tex, tc + (vec2( 0.0,-1.0) * o) * oc) * c;\n\tr += Read(Tex, tc + (vec2( 0.0, 1.0) * o) * oc) * c;\n\tr += Read(Tex, tc + (vec2(-1.0,-1.0) * o) * od.xy) * d;\n\tr += Read(Tex, tc + (vec2( 1.0,-1.0) * o) * od.xy) * d;\n\tr += Read(Tex, tc + (vec2(-1.0, 1.0) * o) * od.xy) * d;\n\tr += Read(Tex, tc + (vec2( 1.0, 1.0) * o) * od.xy) * d;\n\tr += Read(Tex, tc + (vec2(-1.0,-1.0) * o) * od.yx) * d;\n\tr += Read(Tex, tc + (vec2( 1.0,-1.0) * o) * od.yx) * d;\n\tr += Read(Tex, tc + (vec2(-1.0, 1.0) * o) * od.yx) * d;\n\tr += Read(Tex, tc + (vec2( 1.0, 1.0) * o) * od.yx) * d;\n    \n\treturn r;\n}\n\n\nvec2 EvalRectSize(float n)\n{\n    vec2 res = Resolution;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        res = ceil(res * 0.25) + BoundaryWidth * 2.0;\n    }\n    \n    return res;\n}\n\nvec4 EvalRectSizes(float n)\n{\n    vec4 res = vec4(Resolution, \n               ceil(Resolution * 0.25) + BoundaryWidth * 2.0);\n       \n    for(float i = 1.0; i < n; ++i)\n    {\n        res = vec4(res.zw, \n              ceil(res.zw * 0.25) + BoundaryWidth * 2.0);\n    }\n    \n    return res;\n}\n\n\nbool GetUVs_from_Rect(vec2 uv0, vec4 rect, out vec2 ruv)\n{\n    ruv = uv0 - rect.xy;\n    \n    bool isInRect = ruv.x >=    0.0 && ruv.y >=    0.0 &&\n                    ruv.x <  rect.z && ruv.y <  rect.w;\n    \n    return isInRect;\n}\n\nvec2 DownsampleUVs(vec2 uv0, float n)\n{\n#if 1\n    float s = 0.25;\n    float sn = pow(s, n);\n    \n    float b = BoundaryWidth * ((1.0 - sn) / (1.0 - s));\n    \n    return uv0 * sn + b;\n#else\n    vec2 uv = uv0;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        uv = uv * 0.25 + BoundaryWidth;\n    }\n    \n    return uv;\n#endif\n}\n\nvec2 GetRect1Pos()\n{\n    return vec2(0.0, 0.0);\n}\n\nvec2 GetRect2Pos()\n{\n    return vec2(EvalRectSize(1.0).x, 0.0);\n}\n\nvec2 GetRect2BPos()\n{\n    return vec2(floor(Resolution.x*0.5), 0.0);\n}\n\nvec2 GetRect3Pos()\n{\n    return vec2(0.0, GridSize);\n}\n\nvec2 GetRect4Pos()\n{\n    return vec2(0.0, floor(Resolution.y*0.5));\n}\n\nvec4 GetRect1()\n{\n    return vec4(GetRect1Pos(), EvalRectSize(1.0));\n}\n\nvec4 GetRect2()\n{\n    return vec4(GetRect2Pos(), EvalRectSize(2.0));\n}\n\nvec4 GetRect2B()\n{\n    return vec4(GetRect2BPos(), EvalRectSize(3.0));\n}\n\nvec4 GetRect3()\n{\n    return vec4(GetRect3Pos(), EvalRectSize(3.0));\n}\n\nvec4 GetRect4()\n{\n    return vec4(GetRect4Pos(), EvalRectSize(4.0));\n}\n\n\nbool Downsample4x4(sampler2D Tex, vec2 uv0, float n, vec2 rectAPos, vec2 rectBPos, inout vec4 col)\n{\n    vec4 sizes = EvalRectSizes(n);\n    \n    vec4 rectA = vec4(rectAPos, sizes.xy);\n    vec4 rectB = vec4(rectBPos, sizes.zw);\n    \n    if(!IsUVinBounds(uv0, rectB))\n    {\n        return false;\n    }\n    \n    SrcRect = rectA;\n\n    vec2 uv = floor(uv0) - rectB.xy + rectA.xy * 0.25;\n\n    col = BloomDownKernel21(Tex, uv);\n\n    return true;\n}\n\n/*\nbool ImplicitRC2(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n\n    out float t0, out float tm, out float t1)\n{\n    bool hit = false;\n//stepCount = 6.0;\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        tm = hit ? (t0 + t1) * 0.5 : i * ts;\n\n        vec3 p = x + dir * tm;\n\n        f = Map(p);\n\n        if (f < 0.0)\n        {\n            t1 = tm;\n            f1 = f;\n\n            if (minBinaryCount == 0.0)\n            {\n                hit = true;\n            }\n            else\n            if(!hit)\n            {\n                hit = true;\n\n                i = min(i, stepCount - minBinaryCount);\n            }\n        }\n        else\n        {\n            t0 = tm;\n            f0 = f;\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n*/\n\n/*\nbool ImplicitRC2(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n\n    out float t0, out float tm, out float t1)\n{\n    bool hit = false;\n    //vec3 dir0 = dir;\n    //dir /= length(dir.xz);\n//stepCount = 6.0;\nminBinaryCount = 0.0;\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n    //ts /= length(dir.xy);\n    //ts /= abs(dir.y);\n    t0 = tm = t1 = 0.0;\n\n#ifdef USE_POLY5_APPROX\n    vec4 o0;\n    vec4 u0 = Map3(x, o0);\n#else\n    vec4 u0 = Map2(x);\n#endif\n\n    float v0 = u0.w - x.y;\n    //float d0 = dir.y - dot(u0.xy, dir2d);\n\n    if(v0 >= 0.0) return true;\n\n    float f0 = u0.w;\n    float f1 = 0.0;\n    \n    float dy = dir.y / length(dir.xz);\n    \n#if 1\n    //vec2 dir2d = dir.xz / length(dir.xz);\n    vec2 dir2d = dir.xz / length(dir.xz);\n    float ts2 = ts;\n    ts2 *= length(dir.xz);\n    float rs = 1.0 / ts2;\n    \n    float d0 = dot(u0.xy, dir2d) - dy;\n    \n    #ifdef USE_POLY5_APPROX\n    float c0 = 2.0 * u0.z * (dir2d.x*dir2d.y) + dot(o0.xy, dir2d*dir2d);\n    #endif\n    \n    //d0=0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n#endif\n    bool doTestIntermediateStep = false;\n    float intermThresh = -0.01;\n    float j = 0.0;\n    float v1 = 0.0;\n    float d1 = 0.0;\n    float c1 = 0.0;\n    \n    for (float i = 1.0; i <= stepCount; ++i)\n    {\n        \n        if(!doTestIntermediateStep)\n        {\n            t1 = tm = ++j * ts;\n        }\n         \n        vec3 p = x + dir * t1;\n\n        if(isDebug)\n        {\n            //if(doTestIntermediateStep) d_col = mix(d_col, vec3(.0, 1.0, 1.0), Dot(d_p - p, 1.5)); else\n            d_col = mix(d_col, vec3(1.0, 0.0, 0.0), Dot(d_p - p, 0.3));\n        }\n\n    #ifdef USE_POLY5_APPROX\n        vec4 o;\n        vec4 u = Map3(p, o);\n    #else\n        vec4 u = Map2(p);\n    #endif\n    \n        f1 = u.w - p.y;\n            \n        if(f1 >= 0.0)\n        {\n            hit = true;\n\n            break;\n        }\n\n\n       #if 1\n        if(!doTestIntermediateStep)\n        {\n        v1 = f1;\n        d1 = dot(u.xy, dir2d) - dy;\n        \n     #ifndef USE_POLY5_APPROX\n        a = v0;\n        b = d0;\n        c = ((-2.0 * d0 - d1) * ts2 - 3.0 * (v0 - v1)) * (rs*rs);\n        d = ((       d0 + d1) * ts2 + 2.0 * (v0 - v1)) * (rs*rs*rs);\n     #else\n        c1 = 2.0 * u.z * (dir2d.x*dir2d.y) + dot(o.xy, dir2d*dir2d);\n\n        //#define POLY5\n       #ifndef POLY5\n        a = v0;\n        b = (ts2 * (114.0 * d0 + 12.0 * d1 + (8.0 * c0 +       c1) * ts2) +  42.0 * (v0 - v1)) * (1.0/84.0 * rs);\n        c =-(ts2 * ( 80.0 * d0 + 46.0 * d1 + (5.0 * c0 - 2.0 * c1) * ts2) + 126.0 * (v0 - v1)) * (1.0/28.0 * rs*rs);\n        d = (ts2 * ( 18.0 *(d0 +        d1)+ (      c0 -       c1) * ts2) +  36.0 * (v0 - v1)) * (1.0/12.0 * rs*rs*rs);\n       #else\n        a = v0;\n        b = d0;\n        c = c0 * 0.5;\n        d = (-12.0*d0 - 8.0*d1)*(0.5 * rs*rs) + (-3.0 * c0 + c1)*(0.5 * rs) + (10.0 * (-v0 + v1))*(rs*rs*rs);\n        float e = (16.0 * d0 + 14.0 * d1)*(0.5 * rs*rs*rs) + (3.0 * c0 - 2.0 * c1)*(0.5 * rs*rs) + (15.0 * (v0 - v1))*(rs*rs*rs*rs);\n        float f = -((3.0 * (d0 + d1))*(rs*rs*rs*rs)) + (-c0 + c1)*(0.5 * rs*rs*rs) + (6.0 * (-v0 + v1))*(rs*rs*rs*rs*rs);\n       #endif\n     #endif\n        \n        #if 1\n        if(isDebug)\n        {\n            float count = 8.0;\n            for(float j = .0; j < count; ++j)\n            {\n                float x0 = j * ts2/count;\n               #ifdef POLY5\n                float fv = EvalPoly(x0, a, b, c, d, e, f);\n               #else\n                float fv = EvalPoly(x0, a, b, c, d);\n               #endif\n                \n                float t = t0 + (j * ts/count);\n                vec3 p2 = x + dir * t;\n                p2.y += fv;\n                d_col = mix(d_col, vec3(j == 0.0 ? 1.0 : 0.0, 1.0, 0.0), Dot(d_p - p2, 0.1));\n            }\n        }\n        #endif\n                \n        \n       #ifdef USE_POLY\n        float aq = b;\n        float bq = c * 2.0;\n        float cq = d * 3.0;\n        \n        float D = bq * bq - 4.0 * aq * cq;\n        if(D >= 0.0)\n        {\n            float sqrtD = sqrt(D);\n\n            float x0 = (-bq - sqrtD) / (2.0 * cq);\n         // float x1 = (-bq + sqrtD) / (2.0 * cq);\n\n            if(x0 > 0.0 && x0 < ts2)\n            {\n                float fl = EvalPoly(x0, a, b, c, d);\n                float tl = t0 + x0;\n\n                if(isDebug)\n                {\n                    vec3 p2 = x + dir * tl;\n                    p2.y += fl;\n                    //p2.y = 0.0;\n                    d_col = mix(d_col, vec3(1.0, 1.0, 1.0)*4.0, Dot(d_p - p2, 0.1));\n                }\n                //if(false)\n                if(fl >= intermThresh)\n                {\n                    intermThresh *= 0.5;\n                    //intermThresh = 0.;\n                    \n                    #if 0\n                    doTestIntermediateStep = true;\n\n                    t1 = tl;\n                    #else\n                    {\n                        vec3 p = x + dir * tl;\n                    \n                        if(isDebug)\n                        {\n                            d_col = mix(d_col, vec3(1.0, 0.5, 0.0), Dot(d_p - p, 0.3));\n                        }\n\n                        vec4 u = Map2(p);\n    \n                        float f = u.w - p.y;\n\n                        if(f >= 0.0)\n                        {\n                            f1 = f;\n                            t1 = tl;\n                            \n                            hit = true;\n\n                            break;\n                        }\n                    }\n                    #endif\n                }\n            }\n\n        }\n        else\n        {\n            if(isDebug)\n            {\n                //d_col = mix(d_col, vec3(.0, 1.0, 1.0), Dot(d_p - p, 0.3));\n            }            \n        }\n       #endif\n       \n        }\n        else\n        {\n            doTestIntermediateStep = false;\n        }\n       #endif\n\n        if(!doTestIntermediateStep)\n        {\n        f0 = v1;\n        t0 = tm;\n        \n        v0 = v1;\n        d0 = d1;\n    #ifdef USE_POLY5_APPROX\n        c0 = c1;\n    #endif\n        }\n    }\n\n    float binaryStepCount = 3.0;\n    for(float i = 0.0; i < binaryStepCount; ++i)\n    {\n        tm = (t0 + t1) * 0.5;\n\n        vec3 p = x + dir * tm;\n\n        if(isDebug)\n        {\n            //d_col = mix(d_col, vec3(1.0, 0.0, 1.0), Dot(d_p - p, 0.3));\n        }\n\n        vec4 u = Map2(p);\n        float v1 = u.w - p.y;\n        float f = v1;\n          \n        if(f >= 0.0)\n        {\n            f1 = f;\n            t1 = tm;\n        }\n        else\n        {\n            f0 = f;\n            t0 = tm;\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    //if(false)\n    if(isDebug)\n    {\n        vec3 p = x + dir * tm;\n    \n        d_col = mix(d_col, vec3(1.0, 0.0, 1.0)*2.0, Dot(d_p - p, 0.3));\n    }    \n    \n    return hit;\n}\n\n\nbool ImplicitRC2b(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n\n    out float t0, out float tm, out float t1)\n{\n    bool hit = false;\n\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    for (float i = 1.0; i <= stepCount; ++i)\n    {\n        tm = i * ts;\n\n        vec3 p = x + dir * tm;\n\n        vec4 u = Map2(p);\n\n        float v = u.w - p.y;\n        \n        t1 = tm;\n        f1 = v;\n            \n        if (f1 >= 0.0)\n        {\n            \n            hit = true;\n            break;\n        }\n        \n        t0 = t1;\n        f0 = f1;\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nbool isDebug = false;\nvec2 d_tc;\nvec2 d_tc_s;\nvec3 d_dot_s;\nvec3 d_col;\nvec3 d_p;\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\nfloat ReadKey      (int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\nbool ImplicitRC(vec3, vec3, float, float, float, float, float, out float, out float, out float);\nbool ImplicitRC(vec3, vec3, float, float, float, float, float, out float, out float, out float, inout vec3);\n    \n//======================================================================//\n//////////////////////////////////////////////////////////////////////////\n\n//float kern_d(float x) { return cos((x - 0.5) * Pi) / Pi * (1.0 - abs(x)); }\n//float kern_dD1(float x) { x = abs(x); return -(x - 1.0) * cos(x * Pi) - sin(x * Pi)/Pi; }\n\n// CUBIC AND BICUBIC RECONSTRUCTION KERNELS ============================================================================================\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx      |  kernDyy      |  kernDxxy       |  kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\n// BICUBIC SAMPLING ROUTINES =============================================================================================================\n\n#if 0\nconst int WrapDim = GridSizeInt;\n#else\nconst int WrapDim = 1024;\n#endif\n\nint xoff = 0;\nint Wrap(int x)\n{\n    if(x >= WrapDim) return x - WrapDim;\n    if(x <        0) return x + WrapDim;\n    \n    return x;\n}\n\nivec2 Wrap(ivec2 v)\n{\n    return ivec2(Wrap(v.x) + xoff * WrapDim, Wrap(v.y));\n}\n\n// this is the most basic version which only evaluates the function value\nfloat SampleBicubic(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, Wrap(uv0 + ivec2(i, j)), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n// ... this version also outputs derivatives (used here to compute normals)\nvec4 SampleBicubic2(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, Wrap(uv0 + ivec2(i, j)), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives\nvec4 SampleBicubic3(sampler2D channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\nfloat Wrap2(float x)\n{\n    if(x >= 1024.0) return x - 1024.0;\n    if(x <     0.0) return x + 1024.0;\n    \n    return x;\n}\n\nvec2 Wrap2(vec2 v)\n{\n    return vec2(Wrap2(v.x), Wrap2(v.y));\n}\n\nfloat SampleCubeMapBicubic(samplerCube channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    float r = 0.0;\n    for(float j = 0.0; j < 2.0; ++j)\n    for(float i = 0.0; i < 2.0; ++i)\n    {\n        vec4 c = textureLod(channel, UVWforCubeFaceXp(Wrap2(uvi + vec2(i, j)) + 0.5), 0.0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0.0) l.x -= 1.0;\n        if(j != 0.0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\nvec4 SampleCubeMapBicubic2(samplerCube channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = textureLod(channel, UVWforCubeFaceXp(Wrap2(uvi + vec2(i, j)) + 0.5), 0.0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives\nvec4 SampleCubeMapBicubic3(samplerCube channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = textureLod(channel, UVWforCubeFaceXp(Wrap2(uvi + vec2(i, j)) + 0.5), 0.0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\nfloat Root4(float x)\n{\n    return rsqrt(rsqrt(x));\n}\n    \nfloat SinToGWave00(float x)\n{\n    return 1.0 - Root4(max(0.0, 1.0 - x));\n}\n\nfloat SinToGWave0(float x, float s)\n{\n    float ss = 1.0 - Pow4(1.0 - s);\n\n    return SinToGWave00(x * ss);\n}    \n\nfloat SinToGWave(float x, float s)\n{\n    return SinToGWave0(x * 0.5 + 0.5, s) * 2.0 - s;\n}\n\n\nfloat Map(vec3 x)\n{\n    //vec2 uv = clamp01(x.xz + 0.5) * (GridSize-1.0) + 0.5;\n    vec2 uv = fract(x.xz + 0.5) * (GridSize-.0) + 0.5;\n    //uv += GridSize * 0.5;\n    float v = textureLod(iChannel2, uv / iResolution.xy, 0.0).w * 1.;\n    \n    float s = 0.5;\n\n#if 1\n    float c = 8.0;\n    xoff = 1;\n    vec4 u = SampleBicubic2(iChannel2, uv);\n#else\n    float c = 100.0;\n    vec4 u = vec4(0.0);\n    xoff = 2;\n    u.x =SampleBicubic(iChannel2, uv);\n    xoff = 3;\n    u.y =SampleBicubic(iChannel2, uv);\n#endif\n\n    //uv += u.xy * -s*c;\n    //uv += SampleBicubic2(iChannel2, uv).xy * -s*c;\n    \n    xoff = 0;\n    v = SampleBicubic(iChannel2, uv)*s;\n    //v = u.x*c*0.01;\n    \n    uv = fract(x.xz + 0.5) * 1024.0;\n    \n    v = textureLod(iChannel3, UVWforCubeFaceXp(uv + 0.5), 0.0).r;\n\n    v = SampleCubeMapBicubic(iChannel3, uv);\n    \n   #if 0\n   {\n    float s = 20.0;\n    v = clamp(v*s,-1.0,1.0);\n    v = SinToGWave(v, .9) / s * 4.0;\n    }\n   #endif\n    \n    //v *= 0.4;\n    \n    return x.y - v;\n}\n\nvec4 Map2(vec3 x)\n{\n    vec2 uv = fract(x.xz + 0.5) * 1024.0;\n\n    return SampleCubeMapBicubic2(iChannel3, uv) * vec4(vec2(1024.0)*1.0, 0.0, 1.0);\n}\n\nvec4 Map3(vec3 x, out vec4 d2)\n{\n    vec2 uv = fract(x.xz + 0.5) * 1024.0;\n\n    vec4 d1 = SampleCubeMapBicubic3(iChannel3, uv, /*out*/ d2);\n    \n    d1.xy *= 1024.0;\n    d1.z  *= 1024.0;//*1024.0;\n    d2.xy *= 1024.0;//*1024.0;\n    \n    #if 1\n    d1.z  *= 1024.0;//*1024.0;\n    d2.xy *= 1024.0;//*1024.0;\n    #endif\n    \n    return d1;\n}\n\n\nvec3 MapN(vec3 x)\n{\n    //vec2 uv = clamp01(x.xz + 0.5) * (GridSize-1.0) + 0.5;\n    vec2 uv = fract(x.xz + 0.5) * (1024.0-.0) + 0.;\n    //uv += GridSize * 0.5;\n    \n    float s = 0.45;\n    float c = 2.0;\n    \n    xoff = 1;\n    vec4 u = SampleBicubic2(iChannel2, uv);\n\n    //uv += u.xy * -s*c;\n    //uv += SampleBicubic2(iChannel2, uv).xy * -s*c;\n    \n    xoff = 0;\n    vec4 v = SampleBicubic2(iChannel2, uv)*s;\n    \n    //return normalize(textureLod(iChannel2, (uv + GridSize*vec2(2.0, 0.0)) / iResolution.xy, 0.0).rgb);\n    //v = textureLod(iChannel2, (uv + GridSize*vec2(1.0, 0.0)) / iResolution.xy, 0.0);\n    \n    v = SampleCubeMapBicubic2(iChannel3, uv);\n    //v.xy *= 1024.0;\n    return normalize(vec3(-v.x, 1.0/1024.0, -v.y));\n}\n\nfloat EvalPoly(float x, float a, float b, float c, float d)\n{\n    //return a+b*x;\n    return a + x * (b + x * (c + x * d));\n}\n\nfloat EvalPoly(float x, float a, float b, float c, float d, float e, float f)\n{\n    return a + x * (b + x * (c + x * (d + x * (e + x * f))));\n}\n\n\nfloat Dot(vec3 p, float r)\n{\n    //p.x /= length(vec2(dFdx(p.x), dFdy(p.x)));\n    //p.y /= length(vec2(dFdx(p.y), dFdy(p.y)));\n    //p.z /= length(vec2(dFdx(p.z), dFdy(p.z)));\n    p *= d_dot_s;\n    \n    float u = length(p);\n    //u /= length(vec2(dFdx(u), dFdy(u)));\n    p.y /= abs(dFdy(u)) / abs(dFdx(u));\n    //u = length(p);\n    \n    return 1.0 - clamp(u * 1024.0*2.0 - r, 0.0, 1.0);\n}\n\n    #define USE_POLY\n   // #define USE_POLY5_APPROX\n\nbool ImplicitRC2(\n    vec3 x,\n    vec3 dir,\n    float off0,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n\n    out float t0, out float tm, out float t1)\n{\n    bool hit = false;\n    //vec3 dir0 = dir;\n    //dir /= length(dir.xz);\n//stepCount = 6.0;\nminBinaryCount = 0.0;\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n    //ts /= length(dir.xy);\n    //ts /= abs(dir.y);\n    t0 = tm = t1 = 0.0;\n\n#ifdef USE_POLY5_APPROX\n    vec4 o0;\n    vec4 u0 = Map3(x, /*out*/o0);\n#else\n    vec4 u0 = Map2(x);\n#endif\n\n    float v0 = u0.w - x.y;\n    //float d0 = dir.y - dot(u0.xy, dir2d);\n\n    if(v0 >= 0.0) return true;\n\n    float f0 = u0.w;\n    float f1 = 0.0;\n    \n    float dy = dir.y / length(dir.xz);\n    \n    float off = off0 * ts;\n    //off = ts;\n    \n#if 1\n    //vec2 dir2d = dir.xz / length(dir.xz);\n    vec2 dir2d = dir.xz / length(dir.xz);\n    float ts2 = ts;\n    ts2 *= length(dir.xz);\n    float rs = 1.0 / ts2;\n    \n    float d0 = dot(u0.xy, dir2d) - dy;\n    \n    #ifdef USE_POLY5_APPROX\n    float c0 = 2.0 * u0.z * (dir2d.x*dir2d.y) + dot(o0.xy, dir2d*dir2d);\n    #endif\n    \n#endif\n    float intermThresh = -0.01;\n    float v1 = 0.0;\n    float d1 = 0.0;\n    float c1 = 0.0;\n    \n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        float off2 = i == stepCount ? 0.0 : off;\n        \n        t1 = tm = i * ts + off2;\n         \n        vec3 p = x + dir * t1;\n\n        if(isDebug)\n        {\n            d_col = mix(d_col, vec3(1.0, 0.0, 0.0), Dot(d_p - p, 0.3));\n            //if(i == stepCount) d_col = mix(d_col, vec3(.0, 1.0, 1.0), Dot(d_p - p, 0.5));\n        }\n\n    #ifdef USE_POLY5_APPROX\n        vec4 o;\n        vec4 u = Map3(p, /*out*/ o);\n    #else\n        vec4 u = Map2(p);\n    #endif\n    \n        f1 = u.w - p.y;\n    \n       #ifdef USE_POLY\n        v1 = f1;\n        d1 = dot(u.xy, dir2d) - dy;\n       #ifdef USE_POLY5_APPROX\n        c1 = 2.0 * u.z * (dir2d.x*dir2d.y) + dot(o.xy, dir2d*dir2d);\n       #endif    \n            \n        if(f1 >= 0.0)\n        {\n            hit = true;\n\n            break;\n        }\n\n\n        //float vr = v0 + d0 * clamp((-d1 * ts2 - v0 + v1)/(d0 - d1), 0.0, ts2);\n        float dd = (v1 - v0) * rs;\n        //if(vr > v0 || vr > v1)\n        //if(d0 > dd || d1 < dd)\n        \n        //if(i != 0.0 && i != stepCount)\n        if(i != stepCount)\n        {\n            float s = i == 0.0 ? off0 : 1.0;\n                      //i == stepCount ? 1.0 - off0 : 1.0;\n                      \n            float ts2d = ts2 * s;\n            \n            //if(i == 0.0) ts2d *= off0;// use this if 'if(i != 0.0)' is not used\n            //if(i == stepCount) ts2d *= 1.0 - off0;\n            \n            float rcp_ts2d = 1.0 / ts2d;\n            \n     #ifndef USE_POLY5_APPROX\n        float a = v0;\n        float b = d0;\n        float c = ((-2.0 * d0 - d1) * ts2d + 3.0 * (v1 - v0)) * (rcp_ts2d * rcp_ts2d);\n        float d = ((       d0 + d1) * ts2d - 2.0 * (v1 - v0)) * (rcp_ts2d * rcp_ts2d * rcp_ts2d);\n     #else\n     \n        //#define POLY5\n       #ifndef POLY5\n        float a = v0;\n        float b = (ts2d * (114.0 * d0 + 12.0 * d1 + (8.0 * c0 +       c1) * ts2d) +  42.0 * (v0 - v1)) * (1.0/84.0 *  rcp_ts2d);\n        float c =-(ts2d * ( 80.0 * d0 + 46.0 * d1 + (5.0 * c0 - 2.0 * c1) * ts2d) + 126.0 * (v0 - v1)) * (1.0/28.0 * (rcp_ts2d*rcp_ts2d));\n        float d = (ts2d * ( 18.0 *(d0 +        d1)+ (      c0 -       c1) * ts2d) +  36.0 * (v0 - v1)) * (1.0/12.0 * (rcp_ts2d*rcp_ts2d*rcp_ts2d));\n       #else\n        // deprecated: replace rs with rcp_ts2d\n        float a = v0;\n        float b = d0;\n        float c = c0 * 0.5;\n        float d = (-12.0*d0 - 8.0*d1)*(0.5 * rs*rs) + (-3.0 * c0 + c1)*(0.5 * rs) + (10.0 * (-v0 + v1))*(rs*rs*rs);\n        float e = (16.0 * d0 + 14.0 * d1)*(0.5 * rs*rs*rs) + (3.0 * c0 - 2.0 * c1)*(0.5 * rs*rs) + (15.0 * (v0 - v1))*(rs*rs*rs*rs);\n        float f = -((3.0 * (d0 + d1))*(rs*rs*rs*rs)) + (-c0 + c1)*(0.5 * rs*rs*rs) + (6.0 * (-v0 + v1))*(rs*rs*rs*rs*rs);\n       #endif\n     #endif\n        \n        #if 1\n        if(isDebug)\n        {   \n            float count = 8.0;\n            //float count2 = i == stepCount ? count + 1.0 : count;\n            for(float k = 0.0; k < count; ++k)\n            {\n                float x0 = k * ts2*s/count;\n               #ifdef POLY5\n                float fv = EvalPoly(x0, a, b, c, d, e, f);\n               #else\n                float fv = EvalPoly(x0, a, b, c, d);\n               #endif\n                \n                float t = t0 + (k * ts*s/count);\n                vec3 p2 = x + dir * t;\n                p2.y += fv;\n                vec3 vec = d_p - p2;\n                \n                d_col = mix(d_col, vec3(k == 0.0 ? 1.0 : 0.0, 1.0, 0.0), Dot(vec, 0.1));\n            }\n        }\n        #endif\n                \n        \n       #if 1 \n        float aq = b;\n        float bq = c * 2.0;\n        float cq = d * 3.0;\n        \n        float D = bq * bq - 4.0 * aq * cq;\n        if(D >= 0.0)\n        {\n            float sqrtD = sqrt(D);\n\n            float x0 = (-bq - sqrtD) / (2.0 * cq);\n         // float x1 = (-bq + sqrtD) / (2.0 * cq);\n\n            if(x0 > 0.0 && x0 < ts2d)\n            {\n                float fl = EvalPoly(x0, a, b, c, d);\n                float tl = t0 + x0;\n\n                if(isDebug)\n                {\n                    vec3 p2 = x + dir * tl;\n                    p2.y += fl;\n                    d_col = mix(d_col, vec3(1.0, 1.0, 1.0)*4.0, Dot(d_p - p2, 0.1));\n                }\n                //if(false)\n                if(fl >= intermThresh)\n                {\n                    intermThresh *= 0.5;\n                    //intermThresh = 0.;\n                    \n                    vec3 p = x + dir * tl;\n\n                    if(isDebug)\n                    {\n                        d_col = mix(d_col, vec3(1.0, 0.5, 0.0), Dot(d_p - p, 0.3));\n                    }\n\n                    vec4 u = Map2(p);\n\n                    float f = u.w - p.y;\n\n                    if(f >= 0.0)\n                    {\n                        f1 = f;\n                        t1 = tl;\n\n                        hit = true;\n\n                        break;\n                    }\n                }\n            }\n\n        }\n       #endif\n       \n        }\n       #endif\n\n        f0 = v1;\n        t0 = tm;\n        \n        v0 = v1;\n        d0 = d1;\n    #ifdef USE_POLY5_APPROX\n        c0 = c1;\n    #endif\n    }\n\n   #if 1\n    float binaryStepCount = 3.0;\n    for(float i = 0.0; i < binaryStepCount; ++i)\n    {\n        if(i == -1.0)\n        {\n            float w = clamp01(f0 / (f0 - f1));\n            tm = t0 * (1.0 - w) + t1 * w;\n        }\n        else\n        tm = (t0 + t1) * 0.5;\n        \n        vec3 p = x + dir * tm;\n\n        if(isDebug)\n        {\n            //d_col = mix(d_col, vec3(1.0, 0.0, 1.0), Dot(d_p - p, 0.3));\n        }\n\n        vec4 u = Map2(p);\n        float v = u.w - p.y;\n        float d = dot(u.xy, dir2d) - dy;\n        \n        //if(false)\n        if(i == -3.0)\n        {\n            tm += -v / d;\n            tm = clamp(tm, t0, t1);\n        vec3 p = x + dir * tm;\n            \n            u = Map2(p);\n         v = u.w - p.y;\n         d = dot(u.xy, dir2d) - dy;\n        }\n        \n        float f = v;\n          \n        if(f >= 0.0)\n        {\n            f1 = f;\n            t1 = tm;\n            \n            v1 = v;\n            d1 = d;\n        }\n        else\n        {\n            f0 = f;\n            t0 = tm;\n            \n            v0 = v;\n            d0 = d;\n        }\n    }\n   #endif\n\n    #if 1\n    {\n        float ts2d = (t1 - t0) * length(dir.xz);\n        float rcp_ts2d = 1.0 / ts2d;\n            \n        float a = v0;\n        float b = d0;\n        float c = ((-2.0 * d0 - d1) * ts2d + 3.0 * (v1 - v0)) * (rcp_ts2d * rcp_ts2d);\n        float d = ((       d0 + d1) * ts2d - 2.0 * (v1 - v0)) * (rcp_ts2d * rcp_ts2d * rcp_ts2d);\n        \n        float t02d = 0.0;\n        float t12d = ts2d;\n        \n        float binaryStepCount = 1.0;\n        for(float i = 0.0; i < binaryStepCount; ++i)\n        {\n            float tm2d = (t02d + t12d) * 0.5;\n            tm = (t0 + t1) * 0.5;\n\n            float f = EvalPoly(tm2d, a, b, c, d);\n\n            if(f >= 0.0)\n            {\n                f1 = f;\n                t1 = tm;\n                t12d = tm2d;\n            }\n            else\n            {\n                f0 = f;\n                t0 = tm;\n                t02d = tm2d;\n            }\n        }\n    }\n    #endif\n   \n    #if 1\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    #endif\n    \n        \n    //if(false)\n    if(isDebug)\n    {\n        vec3 p = x + dir * tm;\n    \n        d_col = mix(d_col, vec3(1.0, 0.0, 1.0)*2.0, Dot(d_p - p, 0.3));\n    }    \n    tm = max(exp2(-100.0), tm);\n    return hit;\n}\n\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat EvalIGN(vec2 uv)\n{\n    uint frame = uint(iFrame);\n    \n    //frame += WellonsHash2(WeylHash(uvec2(uv)/4u)) % 4u;\n    \n    if((frame & 2u) != 0u) uv = vec2(-uv.y, uv.x);\n    if((frame & 1u) != 0u) uv.x = -uv.x;\n\n    //return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))) + float(frame)*0.41421356);\n    //return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));\n    //return fract(IGN(uv)+float(frame)*0.41421356*1.0);\n\n    // http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/#dither\n    return fract(uv.x*0.7548776662 + uv.y*0.56984029 + float(frame)*0.41421356*1.0);\n}\n\n// C. Schlick. \"Fast alternatives to Perlin’s bias and gain function\"\n// inverse(Bias(x,s)) =   Bias(x  ,1-s)\n// inverse(Bias(x,s)) = 1-Bias(1-x,  s)\nfloat Bias(float x, float s)\n{\n    if(s == 0.0) return x != 1.0 ? 0.0 : 1.0;\n    if(s == 1.0) return x != 0.0 ? 1.0 : 0.0;\n    \n    return x / ((1.0/s - 2.0) * (1.0 - x) + 1.0);\n}\n\nvec3 ParaboloidN(vec3 p, float a, vec2 b, vec3 c)\n{\n    p = p.xzy;\n    \n    float dx = b.x + 2.0 * c.x * p.x + c.z * p.y;\n    float dy = b.y + 2.0 * c.y * p.y + c.z * p.x;\n    \n    return normalize(vec3(-dx, 1.0, -dy));\n}\n\nbool IntersectParaboloid(vec3 rp, vec3 rd, float a, vec2 b, vec3 c, out float t)\n{\n    rp = rp.xzy;\n    rd = rd.xzy;\n    \n    t = 0.0;\n    \n    float bp = dot(b, rp.xy) - rp.z;\n    float bd = dot(b, rd.xy) - rd.z;\n    float cp = dot(c, rp.xyx * rp.xyy);\n    float cd = dot(c, rd.xyx * rd.xyy);\n    \n    vec3 pd = vec3(2.0 * (rd.xy * rp.xy), dot(rd.xy, rp.yx));\n    float cpd = dot(c, pd);\n    \n    float n = a + bp + cp;\n    float k = bd + cpd;\n    float u = cd;\n    \n    float D = k * k - 4.0 * u * n;\n    \n    if(D < 0.0) return false;\n    \n    t = (-k + sqrt(D)) / u * 0.5;// TODO: breaks if c = 0\n    \n    return true;\n}\n\nfloat IntersectPlane(vec3 rp, vec3 rd, float a, vec2 b)\n{\n    rp = rp.xzy;\n    rd = rd.xzy;\n    \n    float bp = dot(b, rp.xy);\n    float bd = dot(b, rd.xy);\n    \n    return (a + bp - rp.z) / (rd.z - bd);\n}\n\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi05 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\nvec3 GetCamRay(mat3x3 cmat, vec3 rp, vec2 uv0, vec2 off)\n{\n    float txlSize = 1.0 / iResolution.x * 2.0;\n    vec2 tc = uv0.xy * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n    \n  #if 1\n    //float fov = 0.394863 * Pi;\n    float fov = 0.4 * Pi;\n    float d = 0.1;\n\n    return cmat * PaniniProjection(tc, fov, d);\n  #else\n    float focalLen = 0.7;// = 0.5 * tan(Pi05 - fov * 0.5)\n    \n    vec2 tc2 = tc + off.xy * txlSize;\n   \n    return normalize(cmat * vec3(tc2, focalLen)); \n  #endif\n}\n\nfloat SimplexNoise(vec3 x, uint seed)\n{\n    // https://en.wikipedia.org/wiki/Simplex_noise\n    float F = 1.0/3.0;\n    float G = 1.0/6.0;\n    \n    vec3 xp = x + dot(x, vec3(1.0)) * F;\n    \n    vec3 xb = floor(xp);\n    vec3 xi = xp - xb;\n \n    vec3 m0 = step(0.0, xi - xi.zxy);\n    vec3 m1 = 1.0 - m0;\n    \n    vec3 v0 = vec3(0.0);\n    vec3 v1 = min(m0.xyz, m1.yzx);\n    vec3 v2 = max(m0.xyz, m1.yzx);\n    vec3 v3 = vec3(1.0);\n    \n    vec3 o = x - xb + dot(xb, vec3(1.0)) * G;\n    \n    vec3 off0 = o - v0 + 0.0 * G;\n    vec3 off1 = o - v1 + 1.0 * G;\n    vec3 off2 = o - v2 + 2.0 * G;\n    vec3 off3 = o - v3 + 3.0 * G;\n     \n    #define DIR(x) normalize(Hash11x3(x, seed))\n     \n    vec4 d;\n\td.x = dot(DIR(xb + v0), off0);\n\td.y = dot(DIR(xb + v1), off1);\n\td.z = dot(DIR(xb + v2), off2);\n\td.w = dot(DIR(xb + v3), off3);    \n         \n    #undef DIR\n    \n    vec4 w;\n    w.x = dot(off0, off0);\n    w.y = dot(off1, off1);\n    w.z = dot(off2, off2);\n    w.w = dot(off3, off3);\n    \n    w = max(1.0 - 2.0 * w, 0.0);\n    \n    return dot(d, w * w * w) * 4.73;\n}\n\nfloat TrigNoise(vec3 x, float detailScale, float detailAmount)\n{   \n    vec3 xd = x * detailScale;\n    \n    vec4 u = vec4(dot(xd, vec3( 1.0, 1.0, 1.0)), \n                  dot(xd, vec3( 1.0,-1.0,-1.0)), \n                  dot(xd, vec3(-1.0, 1.0,-1.0)),\n                  dot(xd, vec3(-1.0,-1.0, 1.0)));\n\n    vec4 su = sin(u);\n    vec4 cu = cos(u);\n\n    x.x += dot(cu.xz, su.yw) * detailAmount;\n    x.y += dot(cu.xy, su.zw) * detailAmount;\n    x.z += dot(cu.xy, su.wz) * detailAmount;\n    \n    return dot(sin(x.xyz), \n               cos(x.zxy));\n}\n\nfloat TrigNoise(vec3 x)\n{   \n    return dot(sin(x.xyz), \n               cos(x.zxy));\n}\n\n\nfloat Intersect_Scene(\nvec2 uv0, vec3 rp, vec3 rd, mat3 cmat, bool shadowRay,\nout float t, out vec3 n, out vec3 col)\n{\n    float hit = 0.0;\n    t = 1e10;\n    col = vec3(0.0);\n    \n    vec2 tt; vec3 n0, n1;\n    float th = Intersect_Ray_Cube(rp, rd, vec3(0.0, 0.0, 0.0), vec2(1.5, 0.028).xyx, tt, n0, n1);\n\n    if(th > 0.0)\n    if(hit <= 0.0 || tt.x < t)\n    {   \n        bool inside = tt.y < 0.0;\n\n        vec3 p = inside ? rp : rp + rd * tt.x;\n\n        float intervalLen = inside ? tt.x : tt.y - tt.x;\n        float stepCount = 8.0;\n        float minBinaryCount = shadowRay ? 0.0 : 4.0;\n        float sdfBlendF = 0.0;\n        float minStepF = 0.0;\n\n        float off0 = fract(dot(uv0 - 0.5, rPhif2));\n        //off0 = .0;\n        //off0 = IGN(floor(uv));\n       // float off = off0 * (intervalLen / stepCount);\n        //p -= rd * off;\n\n        if(isDebug)\n        {\n            d_tc_s = vec2(intervalLen * 1.25, 0.08);\n            \n            d_p = p + rd * (d_tc.x * d_tc_s.x);\n            d_p.y = (d_tc.y - 0.5) * d_tc_s.y;\n            \n            d_dot_s = vec3(d_tc_s.y * 8.0) * vec2(1.0/d_tc_s.x * mix(1.0, 0.25,  length(rd.xz)), 1.0).xyx; \n            \n            vec2 uv = (d_p.xz + 0.5) * 1024.0;\n            vec4 u = SampleCubeMapBicubic2(iChannel3, uv);// * vec4(vec2(1024.0), 0.0, 1.0)\n            \n            //col_d.rg = d_tc;\n            float v = 0.0;\n            \n            v = u.w > d_p.y ? .2 : 0.0;\n            \n            d_col.rgb = vec3(v);\n        }\n\n\n        float t0, tm, t1;\n\n        float l = 1.0;\n        //l = rsqrt(max(0.0, 1.0-(rd.y*rd.y)));\n\n        //vec3 N = inside ? -rd : n0;\n        bool th2 = ImplicitRC2(p, rd * l, off0, intervalLen, stepCount, minBinaryCount, /*out*/ t0, tm, t1);\n        //bool th2 = ImplicitRC2b(p, rd * l, intervalLen, stepCount, minBinaryCount, /*out*/ t0, tm, t1);\n        //bool th2 = ImplicitRC(p, rd * l, intervalLen, stepCount, minBinaryCount, sdfBlendF, minStepF, /*out*/ t0, tm, t1, N);\n        //if(tm < off) th2 = false;\n        \n        if(th2)\n        {\n            hit = 1.0;\n\n            float t = tm;//max(off, tm);\n            \n            //vec3 p = rp + rd * t;\n            p += rd * l * t;\n\n            //n = normalize(N);\n            //n = normalize(vec4(N, exp2(-16.0))).xyz;\n            \n            n = n0;\n            n = inside ? -rd : n0;\n            \n            if(t > 0.0)\n            {\n                n = MapN(p);\n                \n                vec4 o;\n                vec4 u = Map3(p, /*out*/ o);\n           \n                float a = u.w;\n                vec2  b = u.xy;\n                vec3  c = vec3(o.xy * 0.5, u.z);\n                \n                vec3 rp2 = rp - p * vec3(1.0, 0.0, 1.0);\n                //rp2 *= 0.0;\n                //rp2 = -rd;\n                \n                float tt;\n                bool hit = IntersectParaboloid(rp2, rd, a, b, c, /*out*/ tt);\n                \n                if(!hit || tt < 0.0) n = vec3(0.0, .0, 0.0); else\n                \n                n = ParaboloidN(rp2 + rd * tt, a, b, c);\n                //n = ParaboloidN(vec3(0.0), a, b, c);\n           \n                //n = normalize(vec3(-u.x, 1.0, -u.y));\n                \n                //n = MapN(p);\n                \n            }\n           \n                \n            //float c = cellTile(p*B0.x * 80.0);\n            //float c = Map(p);\n            //n = normalize(cellIdB - cellIdA);\n           // if(dot(-rd,n)<0.0)n=-n;\n            col = EvalWaxMtl(-rd * cmat, n * cmat);\n            \n           #if 1\n            vec4 o;\n            vec4 u = Map3(p, /*out*/ o);\n\n            float a = u.w;\n            vec2  b = u.xy;\n            vec3  c = vec3(o.xy * 0.5, u.z);\n\n                \n            col = vec3(0.0);\n            \n            vec2 flip = fract((uv0.yx - 0.5) * 0.5) * 4.0 - 1.0;\n            vec3 off = vec3(2.0, 0.0, -2.0) / 6.0;\n//off *= 0.0;\n            off = off.zxy;\n            off = off.zxy;\n\n           #if 1\n            #define FRWD_TF(x) (x/(x+1.0))\n            #define RVRS_TF(x) (x/(1.0-x))\n           #else\n            #define FRWD_TF(x) (x)\n            #define RVRS_TF(x) (x)\n           #endif\n           \n            float waccu = 0.0;\n           #if 0\n            for(uint i = 0u; i < 4u; ++i)\n            {\n                vec3 rd2 = rd;\n            \n                if(i != 0u)\n                {\n                    rd2 = GetCamRay(cmat, rp, uv0, off.xy*flip);\n\n                    off = off.zxy;\n\n                    vec3 rp2 = rp - p * vec3(1.0, 0.0, 1.0);\n\n                   #if 0\n                    float tt;\n                    bool hit = IntersectParaboloid(rp2, rd2, a, b, c, /*out*/ tt);\n                    if(!hit || tt < 0.0) continue;\n                   #else\n                    float tt = IntersectPlane(rp2, rd2, a, b);\n                    //IntersectParaboloid(rp2, rd2, a, b, vec3(0.00001), /*out*/ tt);\n                   #endif\n                    n = ParaboloidN(rp2 + rd2 * tt, a, b, c);\n                }\n                \n                vec3 V = -rd2;\n            #elif 0\n             vec3 rp2 = rp - p * vec3(1.0, 0.0, 1.0);\n             \n             vec3 rd0 = GetCamRay(cmat, rp, uv0, vec2(-0.5, -0.5));\n             float t00= IntersectPlane(rp2, rd0, a, b);\n             vec3  p0 = rp + rd0 * t00;\n             \n             vec3 rdx = GetCamRay(cmat, rp, uv0, vec2(0.5, 0.0));\n             float tx = IntersectPlane(rp2, rdx, a, b);\n             vec3  px = rp + rdx * tx;\n             \n             vec3 rdy = GetCamRay(cmat, rp, uv0, vec2(0.0, 0.5));\n             float ty = IntersectPlane(rp2, rdy, a, b);\n             vec3  py = rp + rdy * ty;\n             \n             vec3 vecx = px - p0;\n             vec3 vecy = py - p0;\n             \n             uint i0 = uint(uv0.x-0.5) * rPhi2.x + uint(uv0.y-0.5) * rPhi2.y;\n             //uint i0 = dot(uvec2(uv0-0.5), rPhi2);\n             \n             //for(uint i = 0u; i < 6u; ++i)\n             for(float i = 0.0; i < 6.0; ++i)\n             {\n                vec2 ll = fract(rPhif2 * i + fract(rPhif2 * (uv0 - 0.5)));// * 2.0 - 1.0;\n                //vec2 ll = Float01(rPhi2 * i);// * 2.0 - 1.0;\n                //vec2 ll = Float01(rPhi2 * (i0 + i));\n                vec3 p2 = vecx * ll.x + vecy * ll.y + (p0 - p);\n                n = ParaboloidN(p2, a, b, c);\n              \n                vec3 V = -rd;\n            #else\n             {\n                vec3 V = -rd;\n            #endif\n                vec3 L = normalize(vec3(1.0, 1.5, 1.0));\n\n                vec3 R = n * (2.0 * dot(n, V)) - V;\n\n                float VoN = clamp01(dot(V, n));\n\n                float v = 0.0;\n                //v = dot(R, L) > 0.99 ? 16.0 : 0.0;\n                float hmask = R.y > 0.4 ? 1.0 : 0.0;\n                {\n                    float s = 0.4;\n                    float u = clamp01((R.y - s) / (1.0 - s) * 6.0);\n                    u = u*u*(3.0-2.0*u);\n                    //u *= 1.0-pow(1.0-VoN, 22.0)*43.0;\n                    hmask = u;\n                }\n\n                v += hmask * 0.0;\n\n                {\n                    float s = 0.999;\n                    float u = clamp01((dot(R, L) - s) / (1.0 - s) * 1.0);\n                    u *= u;\n                    //u = u*u*(3.0-2.0*u);\n                    //u *= 1.0-pow(1.0-VoN, 22.0)*43.0;\n                    u *= hmask;\n                    v += u * 256.0*10.0;\n                }\n\n                {\n                    float s = 0.85;\n                    float u = clamp01((dot(R, L) - s) / (1.0 - s) * 1.0);\n                    u *= u;\n                    u *= u;\n                    u *= u;\n                    float u2 = Bias(u, 0.1);\n                    u *= u2;\n\n                    u = mix(u, u2, 1.);\n                    //u *= 1.0-pow(1.0-VoN, 22.0)*43.0;\n                    u *= hmask;\n                    v += u * 8.0*3.0;\n                }\n\n                {\n                    float s = 0.;\n                    float u = clamp01((dot(R, L) - s) / (1.0 - s) * 1.0);\n                    u = dot(R, L) * 0.5 + 0.5;\n                    u = Bias(u, 0.05);\n                    //u = u*u*(3.0-2.0*u);\n                    //u *= 1.0-pow(1.0-VoN, 22.0)*43.0;\n                    u *= hmask;\n                    v += u * 0.8*.5;\n                }\n\n                #if 1\n                {\n                   float u = TrigNoise(3.5 + R * 15.0);\n                         //u = TrigNoise(3.5 + R * 11.0, 0.6, 2.0);\n                         //u = TrigNoise(6.5 + R * 5., 0.6, 3.);\n\n                    u = max(0.0, u);\n                    u *= u;\n                    u *= u;\n                    float RoL = clamp(dot(R, L), 0.0, 1.0);\n                    //u *= RoL > 0.95 ? 1.5 : RoL > 0.85 ? 0.2 : 0.0;\n                    u *= RoL > 0.95 ? 1.5 : RoL > 0.85 ? 0.2 : RoL > 0.7 ? 0.05 : 0.01;\n                    //u *= RoL > 0.90 ? 0.5 : 0.0;\n                    v += u * hmask * 1.;\n                }\n                #endif\n\n                v *= mix(0.02, 1.0, pow(1.0 - VoN, 5.0));\n                //v = FRWD_TF(v);\n                //v = pow(1.0-VoN, 22.0)*43.0;\n                col += vec3(v);\n                waccu += 1.0;\n            }\n            \n            col = waccu != 0.0 ? col / waccu : vec3(1.0, 0.0, 1.0);\n            //col = vec3(RVRS_TF(col.r));\n            \n           #endif\n            //col = mix(col.gbr * c, col, sqrt(c));\n\n            //float ha = fract(dot(cellIdA, rPhif3));\n            //float hb = fract(dot(cellIdB, rPhif3));\n            //float hc = fract((ha*1.0 + hb) * rPhif1);\n            //\n            //col = n * 0.5 + 0.5;\n            //col = hc*vec3(1.0);\n            //col *= fract(dot(cellId, rPhif3));\n\n            if(t <= 0.0) col = col.gbr;\n        }\n    }\n\n    return hit;\n}\n\n\nvec3 EvalSceneCol(vec2 uv, vec3 rp, vec3 rd, mat3 cmat, vec3 light)\n{\n    vec3 col = vec3(0.0119);\n    \n    #if 1\n    {\n        bvec2 a = bvec2(rd.y > 0.0, abs(rd.y) > 0.8);\n        \n        bool b = (rd.x > 0.0) != (rd.z > 0.0); \n        \n        col = b != a.y ? col * (a.x ? 1.2 : 0.6) : col * (a.x ? 1.5 : 0.7);\n    }\n    #endif\n    \n    #if 1\n    if(ReadKeyToggle(KEY_Q) != 0.0)\n    {\n        float s = 0.25;\n        float r = 0.96;\n        col = mix(col, vec3(1.0, rd.x < 0.0 ? 0.125 : 0.0, 0.0), abs(rd.x) < r ? 0.0 : s);\n        col = mix(col, vec3(0.0, 1.0, rd.y < 0.0 ? 0.500 : 0.0), abs(rd.y) < r ? 0.0 : s);\n        col = mix(col, vec3(rd.z < 0.0 ? 0.250 : 0.0, 0.0, 1.0), abs(rd.z) < r ? 0.0 : s);\n    }\n    #endif\n    \n    float t; vec3 n; vec3 c;\n    float hit = Intersect_Scene(uv, rp, rd, cmat, false, t, n, c);\n \n    if(hit > 0.0)\n    {\n        vec3 p = rp + rd * t;\n\n        col = c;\n    }\n\n    return col;\n}\n\nvec3 Read(vec2 uv0)\n{\n    return textureLod(iChannel2, uv0 / iResolution.xy, 0.0).yyy;\n}\n\nfloat ReadL(vec2 uv)\n{\n    vec3 col = Read(uv);\n    \n    float l = col.r;//dot(col, vec3(0.21, 0.71, 0.08));\n    \n    l = sqrt(l);\n    \n    return l;\n}\n\n/*\n    l02 l12 l22\n    \n    l01 l11 l21\n    \n    l00 l10 l20\n*/\nvec2 CompGrad(float l00, float l10, float l20, float l01, float l11, float l21, float l02, float l12, float l22)\n{\n   #if 0\n    vec2 g = vec2(l21 - l01, l12 - l10) * 0.5;\n   #else\n    vec2 g = vec2(((l20 + l22) * 0.5 + l21) - ((l00 + l02) * 0.5 + l01), \n                  ((l02 + l22) * 0.5 + l12) - ((l00 + l20) * 0.5 + l10)) * 0.25;\n   #endif\n\n    return g;\n}\n\nvec2 Gradient(vec2 uv)\n{\n    float l00 = ReadL(uv + vec2(-1.0, -1.0));\n    float l10 = ReadL(uv + vec2( 0.0, -1.0));\n    float l20 = ReadL(uv + vec2( 1.0, -1.0));\n    \n    float l01 = ReadL(uv + vec2(-1.0,  0.0));\n    float l11 = ReadL(uv + vec2( 0.0,  0.0));\n    float l21 = ReadL(uv + vec2( 1.0,  0.0));\n    \n    float l02 = ReadL(uv + vec2(-1.0,  1.0));\n    float l12 = ReadL(uv + vec2( 0.0,  1.0));\n    float l22 = ReadL(uv + vec2( 1.0,  1.0));\n    \n    vec2 g = CompGrad(l00, l10, l20, l01, l11, l21, l02, l12, l22);\n   \n    return g;\n}\n\nfloat mainImage2( vec2 uv )\n{\n    vec4 outCol = vec4(0.0);\n    \n    uv = floor(uv) + 0.5;\n\n    //return Read(uv).r;\n\n    float vig = 1.0;\n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    vig = (1.0-sqrt(s.x*s.y));\n}\n#endif\n\n    float v = 0.0;\n        \n    //col = AnisotropicBlur(iChannel0, iChannel1, uv, 1.0/iResolution.xy, 4);\n\n    vec2 g_accu = vec2(0.0);\n\n#if 0\n    for(float y = -1.0; y <= 0.0; ++y)\n    for(float x = -1.0; x <= 0.0; ++x)\n    {\n        vec2 uv2 = uv + vec2(x, y);\n        \n        vec2 g = vec2(0.0);\n        \n        g += vec2(1.0, 1.0) * (ReadL(uv2 + vec2(1.0, 1.0)) - ReadL(uv2 + vec2(0.0, 0.0)));\n        g += vec2(1.0,-1.0) * (ReadL(uv2 + vec2(1.0, 0.0)) - ReadL(uv2 + vec2(0.0, 1.0)));\n        \n        g_accu += dot(g, g_accu) < 0.0 ? -g : g;\n    }\n    \n    int width = 2;\n    \n#elif 1\n\n    for(float y = -0.5; y <= 0.5; ++y)\n    for(float x = -0.5; x <= 0.5; ++x)\n    {\n        vec2 uv2 = uv + vec2(x, y);\n        \n        vec2 g = vec2(0.0);\n\n        float s = 1.;\n        g.x += (ReadL(uv2 + vec2(  s, 0.0)) - ReadL(uv2 - vec2(  s, 0.0)));\n        g.y += (ReadL(uv2 + vec2(0.0,   s)) - ReadL(uv2 - vec2(0.0,   s)));\n        \n        g_accu += dot(g, g_accu) < 0.0 ? -g : g;\n    }\n    \n    int width = 2;\n\n#elif 1\n    float count = 1.0;\n    for(float y = -count; y <= count; ++y)\n    for(float x = -count; x <= count; ++x)\n    {\n       #if 1\n        float wx = 1.0;\n        float wy = 1.0;\n       #else\n        float wx = abs(x) == 0.0 ? 0.5 : 0.25;\n        float wy = abs(y) == 0.0 ? 0.5 : 0.25;\n       #endif\n       \n        float w = 1.0;\n        \n        w = wx * wy;\n        \n        vec2 g = Gradient(uv + vec2(x, y));\n        \n        g *= w;\n        \n        g_accu += dot(g, g_accu) < 0.0 ? -g : g;\n    }\n    \n    int width = 3;\n#endif\n    \n    vec2 dir = vec2(-g_accu.y, g_accu.x);\n         dir = normalize(vec3(dir, exp2(-30.0))).xy;\n\n#if 1\n    vec3 col = vec3(0.0);\n    vec2 o = vec2(-dir.y, dir.x) * 0.5;\n    o *= mix(1.0, 4.0, vig);\n    \n    for(int i = -width; i <= width; ++i)\n    {\n        vec2 uv2 = uv + dir * float(i);\n        \n        //\n        vec3 c = (Read(uv2 - o) + Read(uv2 + o)) * 0.5;\n     //   c = mix(Read(uv2), c, 0.3);\n        c = mix(Read(uv2), (Read(uv2 - o) + Read(uv2 + o)) * 0.5, vec3(0.75, 0.5, 1.0));\n        //c = Read(uv2);\n        col += c.rgb;\n    }\n\n    col /= float(width) * 2.0 + 1.0;\n#else\n    vec3 cols[3];\n    for(uint j = 0u; j < 3u; ++j)\n    {\n        vec2 uv2 = uv + vec2(-dir.y, dir.x) * (float(j) - 1.0)*1.0;\n        \n        vec3 col = vec3(0.0);\n\n        for(int i = -width; i <= width; ++i)\n        {\n            vec3 c = Read(uv2 + dir * float(i));\n\n            col += c.rgb;\n        }\n        \n        col /= float(width) * 2.0 + 1.0;\n        \n        cols[j] = col;\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    col = cols[1];\n    \n    vec3 hp = cols[1] - (cols[0] + cols[2]) * 0.5;\n    //col += hp * 0.75;\n    col = mix(cols[1], (cols[0] + cols[2]) * 0.5, 0.3);\n#endif\n\n   #if 0\n    vec3 mn = vec3(1024.0);\n    vec3 mx =-vec3(1024.0);\n\n    float s = 1.0;\n    for(float y = -s; y <= s; ++y)\n    for(float x = -s; x <= s; ++x)\n    {\n        vec3 c = Read(uv + vec2(x, y));\n\n        mn = min(mn, c);\n        mx = max(mx, c);\n    }\n\n    col = clamp(col, mn, mx);\n   #endif\n       \n    //if(iMouse.x > iResolution.x * 0.5)\n    //col = Read(uv);\n    \n    //outCol = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n    //outCol = vec4(col, 1.0);\n    \n    return col.r;\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n\n    float debugSpot = 0.0;\n    #if 0\n    {\n        vec2 uvd = floor(iMouse.xy) + 0.5;\n        \n        debugSpot = 1.0 - clamp(length(uvd - uv0) - 2.0, 0.0, 1.0);\n        \n        if(ReadKeyToggle(KEY_CTRL) != 0.0)\n        {\n            float h = 256.0;\n            \n            if(uv0.y > iResolution.y - h)\n            {\n                isDebug = true;\n                d_tc = (uv0 - vec2(0.0, iResolution.y - h)) / vec2(iResolution.x, h);\n\n                uv0 = uvd;\n                \n                debugSpot = 0.0;\n            }\n        }\n        else\n        {\n            debugSpot = 0.0;\n        }\n    }\n    #endif\n    \n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    ivec2 uvi = ivec2(uv);\n    \n    #if 0\n    if(ReadKeyToggle(KEY_TAB) != 0.0)\n    if(uvi.x < GridSizeInt * 3 && uvi.y < GridSizeInt * 2)\n    {\n        vec4 col = texelFetch(iChannel0, uvi, 0)*1.0;\n        \n        outCol = col * (uvi.x < GridSizeInt ? 4.0 : 128.0*4.0);\n        //outCol = abs(col.r)>0.999?vec4(1.0):vec4(0.0);\n        \n        return;\n    }\n    #endif\n    \n    #if 1\n    if(ReadKeyToggle(KEY_SPACE) != 0.0)\n    if(uvi.x < GridSizeInt * 4 && uvi.y < GridSizeInt * 1)\n    {\n        //uvi.y -= GridSizeInt;\n        \n        vec4 col = texelFetch(iChannel2, uvi, 0)*122.0;\n        \n        outCol = col;// * (uvi.x < GridSizeInt ? 4.0 : 128.0*4.0);\n        //outCol = abs(col.r)>0.999?vec4(1.0):vec4(0.0);\n        \n        return;\n    }\n    #endif\n    \n    int I = 0;\n\n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, StateUVy), 0); \n        \n    vec2 lightAng = vec2(Pi * 0.7, Pi * 0.2);\n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(Pi * 0.5, -Pi * 0.35);\n    ang += mouseAccu.xy * 0.008;\n    \n    #if 0\n    ang.x += mix(sin(iTime * 0.5), cos(iTime * 0.3), 0.3) * 0.04;\n    ang.y += mix(sin(iTime * 0.2), cos(iTime * 0.7), 0.6) * 0.07;\n    #endif\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(-2.4 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n\n    float focalLen = 0.7;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    float txlSize = 1.0 / iResolution.x * 2.0;\n    vec2 tc = uv0.xy * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n   \n   #if 1\n\n    //vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n    vec3 rp = cpos;\n    vec3 rd = GetCamRay(cmat, rp, uv0, vec2(0., 0.));\n    col = EvalSceneCol(uv0, cpos, rd, cmat, light);  \n    \n   #elif 1\n\n    //vec2 flip = vec2(1.0, (fract(uv.x * 0.5) * 4.0 - 1.0) * (fract(uv.y * 0.5) * 4.0 - 1.0));\n    vec2 flip = fract(uv.yx * 0.5) * 4.0 - 1.0;\n    vec3 off = vec3(2.0, 0.0, -2.0) / 6.0;\n\n    for(uint i = 0u; i < 3u; ++i)\n   \t{\n        vec2 tc2 = tc + off.xy*flip * txlSize;\n        vec2 uv2 = (tc + vec2(1.0, iResolution.y / iResolution.x)) / txlSize - 0.5;\n        \n        vec3 rd = normalize(cmat * vec3(tc2, focalLen)); \n\n        off = off.zxy;\n        \n     \tcol += EvalSceneCol(uv2, cpos, rd, cmat, light);  \n    }\n    \n    col /= 3.0;\n    \n   #elif 1\n    \n    vec2 off0 = vec2(0.0);\n    vec4 off = vec4(-2.0, -4.0, 4.0, 2.0) * 0.1;\n    \n    for(uint i = 0u; i < 5u; ++i)\n   \t{\n        vec2 tc2 = tc + off0 * txlSize;\n        vec2 uv2 = (tc + vec2(1.0, iResolution.y / iResolution.x)) / txlSize - 0.5;\n\n    \tvec3 rd = normalize(cmat * vec3(tc + off0 * txlSize, focalLen)); \n         \n     \tcol += EvalSceneCol(uv2, cpos, rd, cmat, light); \n        \n        off = off.zxwy;\n        off0 = off.xy;\n    }\n    \n    col *= 0.2;\n    \n   #endif\n   \n    float rnd = fract(dot(vec2(0.7548776662, 0.56984029), uv));\n    vec3 col_last = textureLod(iChannel2, uv0 / iResolution.xy + (fract(vec2(0.7548776662, 0.56984029) * (float(iFrame) + rnd * 8.0)) - 0.5) * 0., 0.0).rgb;\n    \n    //col = mix(col, col_last, 0.5);\n    \n    col = mix(col, vec3(1.0, 0.0, 0.0), debugSpot);\n    if(isDebug) col = d_col;\n    \n    float noise = Hash01(uv0.xy, uint(iFrame));\n    \n    col += (noise - 0.5) * 0.005;\n    \n\t//outCol = vec4(sRGB_Encode(clamp01(col)), 1.0);\n    outCol = vec4(max(col, 0.0), 1.0);\n    \n   #if 1\n    #define FRWD_TF(x) (x/(x+1.0))\n    #define RVRS_TF(x) (x/(1.0-x))\n   #else\n    #define FRWD_TF(x) (x)\n    #define RVRS_TF(x) (x)\n   #endif\n           \n    outCol.x = mainImage2(uv0);\n    outCol.x = max(outCol.x, 0.0);\n    \n   #if 1\n    //outCol.x = col_last.y;\n   #else\n    outCol.y = FRWD_TF(outCol.y);\n    outCol.x = RVRS_TF(outCol.x);\n   #endif\n    //outCol = vec4(col, 1.0);\n}\n\n\n\n\n// ========================================================= RAY MARCHING ROUTINES =====================================================================\n\nbool ImplicitRC(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n    float sdfBlendF,\n    float minStepF,\n\n    out float t0, out float tm, out float t1)\n{\n    bool hit = false;\n\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        tm = hit ? (t0 + t1) * 0.5 : \n                   clamp(mix(i * ts, tm + f, sdfBlendF), tm + ts * minStepF, intervalLen);\n\n        vec3 p = x + dir * tm;\n\n        f = Map(p);\n\n        if (f < 0.0)\n        {\n            t1 = tm;\n            f1 = f;\n\n            if (minBinaryCount == 0.0)\n            {\n                hit = true;\n            }\n            else\n            if(!hit)\n            {\n                hit = true;\n\n                i = min(i, stepCount - minBinaryCount);\n            }\n        }\n        else\n        {\n            t0 = tm;\n            f0 = f;\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n\nbool ImplicitRC(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n    float sdfBlendF,\n    float minStepF,\n\n    out float t0, out float tm, out float t1, inout vec3 N)\n{\n    bool hit = false;\n\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    bool calcN = false;\n    vec3 e = vec3(1.0);\n    \n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        tm = hit || calcN ? (t0 + t1) * 0.5 : \n                            clamp(mix(i * ts, tm + f, sdfBlendF), tm + ts * minStepF, intervalLen);\n\n        vec3 p = x + dir * tm;\n\n        p += e * (calcN ? exp2(-14.0) : 0.0);\n            \n        f = Map(p);\n\n\t\tif(calcN)\n        {\n            N += e * f;\n            e = vec3(e.z, -e.yx);            \n        }\n        else\n        {\n            if (f < 0.0)\n            {\n                t1 = tm;\n                f1 = f;\n\n                if (minBinaryCount == 0.0)\n                {\n                    hit = true;\n                }\n                else\n                if(!hit)\n                {\n                    hit = true;\n                    \n                    if(i == 0.0) return true;\n                    \n                    i = min(i, stepCount - minBinaryCount);\n                }\n            }\n            else\n            {\n                t0 = tm;\n                f0 = f;\n            }\n            \n            if(i == stepCount)\n            {\n                N = vec3(0.0);\n            \n                calcN = true;\n                i = 0.0;\n                stepCount = 4.0;\n            }\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nfloat Read0(vec2 uv0)\n{\n    return textureLod(iChannel1, uv0 / iResolution.xy, 0.0).g;\n}\n\nfloat MiniKuwahara(vec2 uv)\n{\n    float col = 0.0;\n    \n    float mnm = 1024.0;\n\n    for(float y0 = -1.0; y0 < 1.0; ++y0)\n    for(float x0 = -1.0; x0 < 1.0; ++x0)\n    {\n        vec2 uv2 = uv + vec2(x0, y0);\n\n        float c  = 0.0;\n        float v  = 0.0;\n        float vv = 0.0;\n\n        for(float y = 0.0; y < 2.0; ++y)\n        for(float x = 0.0; x < 2.0; ++x)\n        {\n            float c0 = Read0(uv2 + vec2(x, y));\n\n            float l = sqrt(c0);\n        \n            c  += c0;\n            v  += l;\n            vv += l*l;\n        }\n\n        c  *= 0.25;\n        v  *= 0.25;\n        vv *= 0.25;\n        \n        float m = vv - v*v;\n        \n        if(m < mnm)\n        {\n            mnm = m;\n            col = c;\n        }\n    }\n    \n   return col;\n}\n\nvec3 Read(vec2 uv0)\n{\n    return textureLod(iChannel0, uv0 / iResolution.xy, 0.0).rrr;\n}\n\nfloat ReadL(vec2 uv)\n{\n    vec3 col = Read(uv);\n    \n    float l = col.r;//dot(col, vec3(0.21, 0.71, 0.08));\n    \n    l = sqrt(l);\n    \n    return l;\n}\n\n/*\n    l02 l12 l22\n    \n    l01 l11 l21\n    \n    l00 l10 l20\n*/\nvec2 CompGrad(float l00, float l10, float l20, float l01, float l11, float l21, float l02, float l12, float l22)\n{\n   #if 0\n    vec2 g = vec2(l21 - l01, l12 - l10) * 0.5;\n   #else\n    vec2 g = vec2(((l20 + l22) * 0.5 + l21) - ((l00 + l02) * 0.5 + l01), \n                  ((l02 + l22) * 0.5 + l12) - ((l00 + l20) * 0.5 + l10)) * 0.25;\n   #endif\n\n    return g;\n}\n\nvec2 Gradient(vec2 uv)\n{\n    float l00 = ReadL(uv + vec2(-1.0, -1.0));\n    float l10 = ReadL(uv + vec2( 0.0, -1.0));\n    float l20 = ReadL(uv + vec2( 1.0, -1.0));\n    \n    float l01 = ReadL(uv + vec2(-1.0,  0.0));\n    float l11 = ReadL(uv + vec2( 0.0,  0.0));\n    float l21 = ReadL(uv + vec2( 1.0,  0.0));\n    \n    float l02 = ReadL(uv + vec2(-1.0,  1.0));\n    float l12 = ReadL(uv + vec2( 0.0,  1.0));\n    float l22 = ReadL(uv + vec2( 1.0,  1.0));\n    \n    vec2 g = CompGrad(l00, l10, l20, l01, l11, l21, l02, l12, l22);\n   \n    return g;\n}\n\nfloat mainImage2( vec2 uv )\n{\n    vec4 outCol = vec4(0.0);\n    \n    uv = floor(uv) + 0.5;\n\n    float vig = 1.0;\n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    vig = Pow2(1.0-sqrt(s.x*s.y));\n}\n#endif\n\n    float v = 0.0;\n        \n    //col = AnisotropicBlur(iChannel0, iChannel1, uv, 1.0/iResolution.xy, 4);\n\n    vec2 g_accu = vec2(0.0);\n\n#if 0\n    for(float y = -1.0; y <= 0.0; ++y)\n    for(float x = -1.0; x <= 0.0; ++x)\n    {\n        vec2 uv2 = uv + vec2(x, y);\n        \n        vec2 g = vec2(0.0);\n        \n        g += vec2(1.0, 1.0) * (ReadL(uv2 + vec2(1.0, 1.0)) - ReadL(uv2 + vec2(0.0, 0.0)));\n        g += vec2(1.0,-1.0) * (ReadL(uv2 + vec2(1.0, 0.0)) - ReadL(uv2 + vec2(0.0, 1.0)));\n        \n        g_accu += dot(g, g_accu) < 0.0 ? -g : g;\n    }\n    \n    int width = 2;\n    \n#elif 1\n\n    for(float y = -0.5; y <= 0.5; ++y)\n    for(float x = -0.5; x <= 0.5; ++x)\n    {\n        vec2 uv2 = uv + vec2(x, y);\n        \n        vec2 g = vec2(0.0);\n\n        float s = 1.;\n        g.x += (ReadL(uv2 + vec2(  s, 0.0)) - ReadL(uv2 - vec2(  s, 0.0)));\n        g.y += (ReadL(uv2 + vec2(0.0,   s)) - ReadL(uv2 - vec2(0.0,   s)));\n        \n        g_accu += dot(g, g_accu) < 0.0 ? -g : g;\n    }\n    \n    int width = 2;\n\n#elif 1\n    float count = 1.0;\n    for(float y = -count; y <= count; ++y)\n    for(float x = -count; x <= count; ++x)\n    {\n       #if 1\n        float wx = 1.0;\n        float wy = 1.0;\n       #else\n        float wx = abs(x) == 0.0 ? 0.5 : 0.25;\n        float wy = abs(y) == 0.0 ? 0.5 : 0.25;\n       #endif\n       \n        float w = 1.0;\n        \n        w = wx * wy;\n        \n        vec2 g = Gradient(uv + vec2(x, y));\n        \n        g *= w;\n        \n        g_accu += dot(g, g_accu) < 0.0 ? -g : g;\n    }\n    \n    int width = 3;\n#endif\n    \n    vec2 dir = vec2(-g_accu.y, g_accu.x);\n         dir = normalize(vec3(dir, exp2(-30.0))).xy;\n\n#if 1\n    vec3 col = vec3(0.0);\n    vec2 o = vec2(-dir.y, dir.x) * 0.5;\n    //o *= mix(1.0, 6.0, vig);\n    //width = 0;\n    for(int i = -width; i <= width; ++i)\n    {\n        vec2 uv2 = uv + dir * float(i);\n        \n        //vec3 c = Read(uv2);\n        vec3 c = (Read(uv2 - o) + Read(uv2 + o)) * 0.5;\n     //   c = mix(Read(uv2), c, 0.3);\n        c = mix(Read(uv2), (Read(uv2 - o) + Read(uv2 + o)) * 0.5, vec3(0.75, 0.5, 1.0));\n        c = Read(uv2);\n        \n        col += c.rgb;\n    }\n\n    col /= float(width) * 2.0 + 1.0;\n#else\n    vec3 cols[3];\n    for(uint j = 0u; j < 3u; ++j)\n    {\n        vec2 uv2 = uv + vec2(-dir.y, dir.x) * (float(j) - 1.0)*1.0;\n        \n        vec3 col = vec3(0.0);\n\n        for(int i = -width; i <= width; ++i)\n        {\n            vec3 c = Read(uv2 + dir * float(i));\n\n            col += c.rgb;\n        }\n        \n        col /= float(width) * 2.0 + 1.0;\n        \n        cols[j] = col;\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    col = cols[1];\n    \n    vec3 hp = cols[1] - (cols[0] + cols[2]) * 0.5;\n    //col += hp * 0.75;\n    col = mix(cols[1], (cols[0] + cols[2]) * 0.5, 0.3);\n#endif\n\n   #if 0\n    vec3 mn = vec3(1024.0);\n    vec3 mx =-vec3(1024.0);\n\n    float s = 1.0;\n    for(float y = -s; y <= s; ++y)\n    for(float x = -s; x <= s; ++x)\n    {\n        vec3 c = Read(uv + vec2(x, y));\n\n        mn = min(mn, c);\n        mx = max(mx, c);\n    }\n\n    col = clamp(col, mn, mx);\n   #endif\n       \n    //if(iMouse.x > iResolution.x * 0.5)\n    //col = Read(uv);\n    \n    //outCol = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n    //outCol = vec4(col, 1.0);\n    \n    return col.r;\n}\n\nvec3 Hue(float x)\n{\n    float r = 1.0 - x * 2.0;\n    float b = -r;\n    float g = 1.0 - max(r, b);\n    \n    return vec3(max(0.0, r), g, max(0.0, b));\n}\n\nvec3 ReadU(vec2 uv0)\n{\n    uv0 += GetRect3Pos();\n    return textureLod(iChannel2, uv0 / iResolution.xy, 0.0).bbb;\n}\n\nvec3 EvalLensFlares(vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 k212 = vec2(0.7722090128189392, 0.35823959808621314);\n    float n = 1.0;\n    //n = fract(dot(uv0 - 0.5, rPhif2));\n    //n = fract(dot(uv0 - 0.5, k212));\n    //n = textureLod(iChannel2, uv0 / 8.0, 0.0).r;\n    //n = textureLod(iChannel1, uv0 / 1024.0, 0.0).r;\n\n    vec2 dir = DownsampleUVs(iResolution.xy*0.5, 3.0) - uv0;\n\n    float count = 3.0;\n    vec3 wa = vec3(0.0);\n    for(float j = 0.0; j < count; ++j)\n    {\n        float k = (j + n) / count;\n\n        vec3 w = Hue(fract(k*2.0 + 0.9));\n        //w = Hue_to_RGB(fract(k*2.0 + 0.6));\n        w = vec3(1.0)*cos(k * 4.0) * 0.5 + 0.5;\n        w = w * 0.95 + 0.05;\n        w = vec3(1.0);\n        //w *= k;\n        \n        float s = k * 2.0-0.3;\n        vec2 uv2 = uv0 + dir*s;\n        float detJacobi = Pow2(s - 1.0);\n\n        col += ReadU(uv2) * (w * detJacobi);\n        wa  += w;\n    }\n\n    col /= wa;\n    \n    return col;\n}\n\nvec3 CrossBlur(vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 k212 = vec2(0.7722090128189392, 0.35823959808621314);\n   // k212 = textureLod(iChannel1, uv0 / 1024.0, 0.0).rg;\n    float n = fract(dot(uv0 - 0.5, rPhif2));\n    //n = fract(dot(uv0 - 0.5, k212));\n    //n = abs(n * 2.0 - 1.0);\n\n    float s = 4.0;\n    \n    float count = 6.0;\n    vec3 wa = vec3(0.0);\n    for(float j = -count; j <= count; ++j)\n    {\n        float i = j;\n        //i = (j + n - 0.5) * (count/(count+0.5));\n        //col += Read(uv0 + vec2(i, 0.0));\n        //vec3 w = Hue(abs(i) / (count - 1.0));\n        //vec3 w = Hue_to_RGB(fract(abs(i+0.5) / (count) + 0.5));\n        vec3 w = Hue(fract((abs(i)+0.5) / (count)*1.0 + 0.2));\n        w = w * 0.95 + 0.05;\n        w = vec3(1.0);\n        \n        col += (ReadU(uv0 + vec2(i*s, 0.0)) + ReadU(uv0 + vec2(0.0, i*s))) * (0.5 * w);\n        wa  += w;\n    }\n\n    col /= wa;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    \n    outCol = vec4(0.0);\n    \n//    outCol.x = textureLod(iChannel0, uv0 / iResolution.xy, 0.0).x;\n    vec4 col0 = vec4(0.0);\n    Downsample4x4(iChannel0, uv0, 1.0, vec2(0.0), GetRect1Pos(), /*input*/ col0);\n    \n    outCol.r = col0.x;\n    //outCol.g = textureLod(iChannel0, uv0 / iResolution.xy, 0.0).x;\n    outCol.g = mainImage2(uv0);\n    \n    col0 = vec4(0.0);\n    vec4 last = textureLod(iChannel1, uv0 / iResolution.xy, 0.0);\n    col0 = last.rrrr;\n    \n    vec2 uv0B = uv0;\n    \n       Downsample4x4(iChannel1, uv0, 2.0, GetRect1Pos(), GetRect2Pos(), /*input*/ col0);\n    if(Downsample4x4(iChannel2, uv0, 4.0, GetRect3Pos(), GetRect4Pos(), /*input*/ col0))\n    {\n        col0.x = mix(col0.x, last.b, 0.9);\n    }\n    else if(GetUVs_from_Rect(uv0, GetRect2B(), /*out*/ uv0B)) \n    {\n        vec3 lf = EvalLensFlares(uv0B);\n        //vec3 cb = CrossBlur(uv0B);\n        \n        //col0.x = mix(cb, lf, 1.).b;    \n        col0.x = lf.b;    \n        col0.x = mix(lf.b, last.b, 0.9);\n    }\n\n    outCol.b = col0.x;\n    outCol.a = last.g;\n    //outCol.a = mix(last.g, MiniKuwahara(uv0), 0.95);\n    \n    col0 = vec4(0.0);\n    \n    //Downsample4x4(iChannel2, uv0, 4.0, GetRect3Pos(), GetRect4Pos(), /*input*/ col0);\n    //col0.x = mix(col0.x, textureLod(iChannel1, uv0 / iResolution.xy, 0.0).a, 0.9);\n    //outCol.a = col0.x;\n    \n    \n    return;\n    \n    #if 0\n    vec2 uv = uv0 - 0.5;\n    \n    vec2 v0 = textureLod(iChannel1, uv0 / iResolution.xy, 0.0).yz;\n    \n    float rnd = fract(dot(uv, rPhif2));\n    float s = 1.0 + rnd*4.0;\n    \n    float vx = 0.0;\n    vec2 vy = vec2(0.0);\n    float waccu = 0.0;\n    \n    float count = 16.0;\n    for(float i = -count; i <= count; ++i)\n    {\n        float w = 1.0;\n        w = exp2(-abs(i) * 0.25);\n        waccu += w;\n        \n        #if 0\n        vec2 uvx = uv0 + vec2( i, i)*s;\n        vec2 uvy = uv0 + vec2(-i, i)*s;        \n        #else\n        vec2 uvx = uv0 + vec2(0.0, i)*s;\n        vec2 uvy = uv0 + vec2(i, 0.0)*s;\n        #endif\n        \n        float v0x = textureLod(iChannel0, uvx / iResolution.xy, 0.0).x;\n        vec2  v0y = textureLod(iChannel1, uvy / iResolution.xy, 0.0).yz;\n        \n        vx += v0x * w;\n        vy += v0y * w;\n    }\n    \n    vx = waccu != 0.0 ? vx / waccu : 0.0;\n    vy = waccu != 0.0 ? vy / waccu : vec2(0.0);\n    \n    //outCol.x = vy.y;\n    outCol.y = vx;\n    outCol.x = mix(v0.y, mix(vy.x, mix(vy.y, v0.x, 0.75), 0.3), 0.33);\n    //outCol.x = mix(v0, (vx + vy) * 0.5, 0.75);\n    \n    //outCol.x = (vx + vy) * 0.5;\n    outCol.z = textureLod(iChannel0, uv0 / iResolution.xy, 0.0).x;\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    pre-filter pass (prepares height field for rendering)\n    https://www.shadertoy.com/view/WtsBDH (\"Bicubic C2 cont. Interpolation\")\n*/\n\n//#define FETCH(uv) (-length(texelFetch(iChannel0, uv, 0).rg))\nvec2 cmask;\nivec2 uviBase;\n//#define FETCH(uv) (texelFetch(iChannel0, uv, 0).r)\n#define FETCH(uv) dot(texelFetch(iChannel0, uv + uviBase, 0).rg, cmask)\n\nint Wrap(int x)\n{\n    if(x >= GridSizeInt) return x - GridSizeInt;\n    if(x <            0) return x + GridSizeInt;\n    \n    return x;\n}\n\nivec2 Wrap(ivec2 v)\n{\n    return ivec2(Wrap(v.x), Wrap(v.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    Resolution = iResolution.xy;\n    \n    fragColor = vec4(0.1);\n    \n    if(uv0.x > GridSize*2.0 || uv0.y > GridSize)\n    {\n        vec4 col0 = vec4(0.0);\n        if(Downsample4x4(iChannel1, uv0, 3.0, GetRect2Pos(), GetRect3Pos(), /*input*/ col0))\n        {\n            fragColor = col0.bbbb;\n            return;\n        }\n        else\n        {\n            //return;\n            discard;\n        }\n    }\n\n    cmask = vec2(1.0, 0.0);\n    uviBase = ivec2(0, 0);\n    \n    if(uv0.x >= GridSize)\n    {\n        uv0.x -= GridSize;\n        \n        cmask = vec2(0.0, 1.0);\n    }\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    vec4 col = vec4(0.0);\n#if 0\n    // ======================================================= INTERPOLATING CUBIC KERNEL =======================================================\n    \n    // truncated kernel radii for 1st and 2nd derivatives respectively\n    int r1 = 5;\n    int r2 = 2;\n    \n    col.w = FETCH(uv);\n    \n   #if 1\n    // precomputed kernel\n    float kern[12];\n    kern[0] = 0.0         ; kern[1] = -0.803848    ; kern[ 2] = 0.21539       ; kern[ 3] = -0.0577137    ; \n    kern[4] = 0.0154643   ; kern[5] = -0.00414365  ; kern[ 6] = 0.00111029    ; kern[ 7] = -0.000297501  ; \n    kern[8] = 0.0000797152; kern[9] = -0.0000213596; kern[10] = 0.00000572329 ; kern[11] = -0.00000153355;\n   #else\n    // compute kernel at compile time\n    float kern[12];\n    {\n    \tkern[0] = 0.0;\n        \n        float sn = -1.0;\n    \tfor(uint i = 1u; i < 12u; ++i, sn = -sn)\n        \tkern[i] = sn * 3.0 * exp2(-float(i) * log2(2.0 + sqrt(3.0)));\n    }\n   #endif    \n    \n    // d/dx\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(Wrap(uv + ivec2(i, 0)));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.x += f * k;\n    }\n    \n    // d/dy\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(Wrap(uv + ivec2(0, i)));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.y += f * k;\n    }\n    \n    \n    // d^2/dxy\n    for(int j = -r2; j <= r2; ++j)\n    for(int i = -r2; i <= r2; ++i)\n    {\n        if(i == 0 || j == 0) continue;\n        \n    \tfloat f = FETCH(Wrap(uv + ivec2(i, j)));\n        \n        float kx = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        float ky = kern[abs(j)] * (j > 0 ? -1.0 : 1.0);\n        \n        col.z += f * (kx * ky);\n    }\n\n    #if 0\n    vec2 k = vec2(16.0, 8.0);\n    float l = dot((uv0-0.5)/GridSize*Pi*2.0, k);\n    k/=10.0;\n    col.w = cos(l);\n    col.x = sin(l)*-k.x;\n    col.y = sin(l)*-k.y;\n    col.z = cos(l)*-k.y*k.x;\n    col *= 0.01;\n    #endif\n#else    \n    // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n    \n    float kernD0[4];\n    float kernD1[4];\n    \n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0; kernD0[3] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0; kernD1[3] = 0.0;\n    \n    float sw;// side lobes weight\n\n    sw = 0.0;// cubic BSpline\n    \n   #if 1\n   \n    sw = 0.25;// similar to 1/3 but less ringing\n    \n   #elif 0\n   \n    sw = 1.0/3.0;// kernD0[0] == 1\n    \n   #elif 0\n    \n    sw = 0.186605;// max abs derivative == 1\n    \n   #elif 0\n    \n    sw = 1.0/6.0;// maximaly flat pass band\n    \n   #elif 1\n    \n    sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n    \n   #endif\n    \n    // add a pair of side lobes:\n    kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n    \n   #if 0\n    kernD0[0] = 5.0/12.0; kernD0[1] = 1.0/4.0; kernD0[2] = 1.0/24.0;\n    kernD1[0] = 0.0     ; kernD1[1] =-1.0/4.0; kernD1[2] =-1.0/ 8.0;\n    \n    float kern2D0[4];\n    float kern2D1[4];\n    \n    kern2D0[0] = 1.0/3.0; kern2D0[1] = 23.0/96.0; kern2D0[2] = 1.0/12.0; kern2D0[3] = 1.0/96.0;\n    kern2D1[0] =     0.0; kern2D1[1] = -5.0/32.0; kern2D1[2] =-1.0/8.0 ; kern2D1[3] =-1.0/32.0;    \n    \n    vec4 cA = vec4(0.0);\n    vec4 cB = vec4(0.0);\n    \n    int r = 3;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(Wrap(uv + ivec2(i, j)));\n        \n        int x = abs(i);\n        int y = abs(j);\n\n        {\n            float kAx = kernD0[x];\n            float kAy = kernD0[y];\n\n            float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n            float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n\n            cA += f * vec4(kBx * kAy, \n                           kAx * kBy, \n                           kBx * kBy,\n                           kAx * kAy);\n        }\n        \n        {\n            float kAx = kern2D0[x];\n            float kAy = kern2D0[y];\n\n            float kBx = kern2D1[x] * (i > 0 ? -1.0 : 1.0);\n            float kBy = kern2D1[y] * (j > 0 ? -1.0 : 1.0);\n\n            cB += f * vec4(kBx * kAy, \n                           kAx * kBy, \n                           kBx * kBy,\n                           kAx * kAy);\n        }\n    }\n    \n    col = mix(cB, cA, 8.0/3.0);\n    \n   #else\n    int r = sw == 0.0 ? 1 : 2;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(Wrap(uv + ivec2(i, j)));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n   #endif\n #endif\n \n    // col = vec4(df/dx, df/dy, d^2f/dxy, f)\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n// CUBIC AND BICUBIC RECONSTRUCTION KERNELS ============================================================================================\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx      |  kernDyy      |  kernDxxy       |  kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\n// BICUBIC SAMPLING ROUTINES =============================================================================================================\n\nint xoff = 0;\nint Wrap(int x)\n{\n    if(x >= GridSizeInt) return x - GridSizeInt;\n    if(x <            0) return x + GridSizeInt;\n    \n    return x;\n}\n\nivec2 Wrap(ivec2 v)\n{\n    return ivec2(Wrap(v.x) + xoff * GridSizeInt, Wrap(v.y));\n}\n\n// this is the most basic version which only evaluates the function value\nfloat SampleBicubic(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, Wrap(uv0 + ivec2(i, j)), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n// ... this version also outputs derivatives (used here to compute normals)\nvec4 SampleBicubic2(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, Wrap(uv0 + ivec2(i, j)), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives\nvec4 SampleBicubic3(sampler2D channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\nfloat Wrap(float x)\n{\n    if(x >= 1024.0) return x - 1024.0;\n    if(x <     0.0) return x + 1024.0;\n    \n    return x;\n}\n\nvec2 Wrap(vec2 v)\n{\n    return vec2(Wrap(v.x), Wrap(v.y));\n}\n\nvoid mainCubemap( out vec4 col, in vec2 uv0, in vec3 rayOri, in vec3 rayDir )\n{\n    col = vec4(0.0);\n\n    if(IsCubeFaceXn(rayDir))\n    {\n        uv0 = UVforCubeFaceXn(uv0);\n        \n        vec2 uv = (uv0 - 0.) / 1024.0 * GridSize + 0.;\n        \n        float s = 1.;\n        float c = 1.0 * GridSize/(Pi*4.0) * s;// no idea where the 1.0/(Pi*4.0) scaling comes from\n        \n        xoff = 1;\n\n      #if 1\n        // 0.875\n        #if 0\n        // reference\n        vec2 offA = SampleBicubic2(iChannel0, uv       ).xy * (-c * 0.5496524051559180);\n        vec2 offB = SampleBicubic2(iChannel0, uv + offA).xy * (-c * 1.7400501802620651);\n        vec2 offC = SampleBicubic2(iChannel0, uv + offB).xy * (-c * 1.8572371808836061);\n        vec2 offD = SampleBicubic2(iChannel0, uv + offC).xy * (-c * 0.6241417108243891);\n        vec2 offE = SampleBicubic2(iChannel0, uv + offD).xy * (-c * 0.8849639608175093);\n        vec2 offF = SampleBicubic2(iChannel0, uv + offE).xy * (-c * 0.9042641123815153);\n        uv       += SampleBicubic2(iChannel0, uv + offF).xy * (-c * 0.8770181038999447);\n        #elif 1\n        float a = 1.372363182435823 * -c;\n        vec2  b = vec2(0.7951016300445584, 2.1453196992250145) * -c;\n        vec3  d = vec3(-0.29628248070936786, 0.7578937878287033, 0.6488902352563868) * -c;\n        vec4  q = vec4(-0.11081798721463341, 0.21249124707150752, -0.10388522201211563, 0.7843026470579635) * -c;\n        \n        vec2 offA = SampleBicubic2(iChannel0, uv).xy;\n        vec2 offB = SampleBicubic2(iChannel0, uv + offA * a).xy;\n        vec2 offC = SampleBicubic2(iChannel0, uv + offA * b.x + offB * b.y).xy;\n        vec2 offD = SampleBicubic2(iChannel0, uv + offA * d.x + offB * d.y + offC * d.z).xy;\n        \n        uv += offA * q.x + offB * q.y + offC * q.z + offD * q.w;    \n        #endif\n      #elif 0\n        // 0.75\n        vec2 offA = SampleBicubic2(iChannel0, uv       ).xy * (-c * 0.5848003648630817);\n        vec2 offB = SampleBicubic2(iChannel0, uv + offA).xy * (-c * 1.1692565794500254);\n        vec2 offC = SampleBicubic2(iChannel0, uv + offB).xy * (-c * 0.9227991041220243);\n        vec2 offD = SampleBicubic2(iChannel0, uv + offC).xy * (-c * 0.7120882816865387);\n        uv       += SampleBicubic2(iChannel0, uv + offD).xy * (-c * 0.748573752757914 );\n      #elif 0\n        // 0.5\n        #if 0\n        vec2 offA = SampleBicubic2(iChannel0, uv       ).xy * (-c * 0.4954844641446582);\n        vec2 offB = SampleBicubic2(iChannel0, uv + offA).xy * (-c * 0.5509267942013011);\n        uv       += SampleBicubic2(iChannel0, uv + offB).xy * (-c * 0.5025266694404723);\n        #else\n        vec2 uv0 = uv;\n        uv =          uv            + SampleBicubic2(iChannel0, uv).xy * (-c * 0.965393);\n        uv = mix(uv0, uv, 1.618880) + SampleBicubic2(iChannel0, uv).xy * (-c * 0.886404);\n        uv = mix(uv0, uv, 0.229925) + SampleBicubic2(iChannel0, uv).xy * (-c * 0.053036);        \n        #endif\n      #elif 0\n        // 0.25\n        uv += SampleBicubic2(iChannel0, uv).xy * (-c * 0.25);\n      #endif\n        \n    \n        xoff = 0;\n        col = SampleBicubic2(iChannel0, uv).wwww*s;\n        //col = vec4(u.x);\n        \n        xoff = 1;\n        //col = SampleBicubic2(iChannel0, uv).yyyy/Pi/4.0*s;\n        xoff = 0;\n        //col = SampleBicubic2(iChannel0, fract(uv0/1024.0+0.25)*GridSize).wwww*s;\n        \n        return;\n    }\n    \n    if(IsCubeFaceXp(rayDir))\n    {\n        uv0 = UVforCubeFaceXp(uv0);\n        \n        // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n\n        float kernD0[4];\n        float kernD1[4];\n\n        kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0; kernD0[3] = 0.0;\n        kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0; kernD1[3] = 0.0;\n\n        float sw;// side lobes weight\n\n        sw = 0.0;// cubic BSpline\n\n       #if 0\n\n        sw = 0.25;// similar to 1/3 but less ringing\n\n       #elif 0\n\n        sw = 1.0/3.0;// kernD0[0] == 1\n\n       #elif 0\n\n        sw = 0.186605;// max abs derivative == 1\n\n       #elif 0\n\n        sw = 1.0/6.0;// maximaly flat pass band\n\n       #elif 1\n\n        sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n\n       #endif\n\n        // add a pair of side lobes:\n        kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n                               kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n\n\n        int r = sw == 0.0 ? 1 : 2;\n        for(int j = -r; j <= r; ++j)\n        for(int i = -r; i <= r; ++i)\n        {\n            vec2 uv = Wrap(uv0 + vec2(i, j));\n            float f = textureLod(iChannel1, UVWforCubeFaceXn(uv), 0.0).r;\n\n            int x = abs(i);\n            int y = abs(j);\n\n            float kAx = kernD0[x];\n            float kAy = kernD0[y];\n\n            float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n            float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n\n            col += f * vec4(kBx * kAy, \n                            kAx * kBy, \n                            kBx * kBy,\n                            kAx * kAy);\n        }        \n        \n        //if(uv0.x == 1023.5) col *= 0.0;\n        //col = textureLod(iChannel1, UVWforCubeFaceXn(uv0), 0.0);\n        //col.r = col.w;\n        \n        return;\n    }\n    \n    discard;\n}\n\n\n\n\n","name":"Cube A","description":"","type":"cubemap"}]}