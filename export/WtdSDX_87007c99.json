{"ver":"0.1","info":{"id":"WtdSDX","date":"1581920827","viewed":299,"name":"Steiner Chain Carousel.","username":"Logos","description":"Study of Steiner Chain. Mouse controlled carousel / menu / slideshow.\n","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["circle","inversion","menu","slideshow","chain","carousel","steiner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 17.02.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n//--- program parameters ---//\n\n#define AA(v) smoothstep(ZOOM*1.5/iResolution.y, 0.0, v)\n\n\n//--- shader functions ---//\n\n// taken from: https://www.shadertoy.com/view/MtXSR7\nvec3 drawShaderA(vec2 u)\n{\n    vec3 f = vec3(0.0);\n\tfor (float i = 1.; i++ < 20.;)\n    f = u.y < sin( ceil(2e2*u.x/i+i*i-3.2*iTime) ) - .04*i ? f-f+i/20. : f;\n    \n    return f * vec3(0.36, 0.7, 1.0);\n}\n\n\n// trivial one - video\nvec3 drawShaderB(vec2 p)\n{\n    return texture(iChannel2, -0.58*p + vec2(0.5)).xyz;\n}\n\n\n// taken from: https://www.shadertoy.com/view/ldX3DH\nvec3 drawShaderC(vec2 p)\n{\n    vec2 newPos = p;\n   //newPos = (newPos -0.5);\n   \n   float k= 1.8;\n   float rd = length(newPos);\n   float ru = rd*(1.0+ k*rd*rd);\n   \n   newPos = newPos/length(newPos) * ru +0.5;\n   \n   vec2 oldPos = newPos;\n   float angle = 3.1415926535/4.0;\n   newPos = vec2(oldPos.x *cos(angle) - oldPos.y *sin(angle),\n   \t\t\t\t\t  oldPos.y *cos(angle) + oldPos.x *sin(angle));\n   \n    vec2 coords=newPos*vec2(0.15,-1)*3.1+vec2(iTime*1.321);\n\t\n\t\tvec2 texcoord = vec2(coords.x*0.3,coords.y*0.3);\n   \n\t\n   return texture(iChannel1, texcoord).xyz;\n}\n\n\n// ordinary Julia\nvec3 drawShaderD(vec2 p)\n{\n    p *= 2.3;\n    \n\tvec2 z = p;  \n\tfor (int i = 0; i < 20; i++)\n    {  \n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + 0.883*vec2(cos(0.66*iTime), sin(1.021*iTime));\n\n\t\tif (dot(z,z) > 4.)\n        {\n\t\t\tfloat s = .5 * float(i);\n\t\t\treturn vec3(vec3(cos(s + .9), cos(s + .3), cos(s + .2)) * .4 + .6);\n\t\t}\n\t}\n\n    return vec3(0.0);\n}\n\n\n// taken from: https://www.shadertoy.com/view/4tl3W8\nvec3 drawShaderE(vec2 w)\n{\n    vec4 f;\n    vec4 p = vec4(w.x-.9,w.y-.5,0,1);\n\tfloat t = iTime, r = length( p.xy += sin(t+sin(t*.8))*.4 ), a = atan(p.y,p.x);\n\tfor (float i=0.; i<40.; i++)\n        f +=  r * (.5+.5*sin(i+vec4(5,3,2,1)))\n                * smoothstep(.99, 1., sin( log(r+i*.05) -t-i + sin(a +=t*.01) ) ) ;\n    \n    return f.rgb;\n}\n\n\n//--- calculate output color ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- calculate point coordinates ---//\n    \n\tfloat\tZOOM = 2.3;\n    vec2\tp    = ZOOM * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    \n    //--- set current parameters ---//\n    \n    // calculations taken from wolfram world Steiner Chain article..\n    // .. http://mathworld.wolfram.com/SteinerChain.html\n\n    float PI = 3.1415926535;\n    float n = 5.0;//3.0 + floor(11.0*iMouse.y/iResolution.y);\n    float m = (1.0 - sin(PI/n)) / (1.0 + sin(PI/n));\n\n    float a = 1.08;\n    float b = a*m;\n    float c = 0.5 * (a - b);\n    float r = 0.5 * (a + b);\n\n    // inversion center\n    vec3 IC = vec3((iMouse.x/iResolution.x - 0.5) * 0.49, 0.0, b);\n    \n    // two constrain circles..\n    vec3 ca = vec3(0.0, 0.0, a);\n    vec3 cb = vec3(0.0, 0.0, b);\n\n    // ..and their inversions\n  \tvec3 ica = inverseCircle(ca, IC);\n  \tvec3 icb = inverseCircle(cb, IC);\n\n    // mapped to center...\n    ica = mapCircle(ica, icb, ca);  \n    //icb = mapCircle(icb, icb, ca);  // except this one... :)\n  \n    // background texture\n    vec3 color = vec3(0.0);\n    color += (distance(p, ca.xy) < ca.z? 0.26 : 0.6) * texture(iChannel0, p).xyz;\n    \n    // circles frames\n    color += AA(abs(length(ica.xy - p) - ica.z));\n    color += AA(abs(length(ca.xy - p) - ca.z));\n    \n    int i = 0;\n\tfor (float t = 0.0; t < n; t++, i++)\n  \t{\n    \tfloat angle = t/n * (2.0*PI) - 0.5*iTime;\n    \t//float angle = t/n * (2.0*PI) - iMouse.z > 0.0 ? 0.5*iTime : 3.0*PI*iMouse.y/iResolution.y;\n    \n        vec3 oc = vec3(r*cos(angle), r*sin(angle), c);\n        vec3 ic = mapCircle(inverseCircle(oc, IC), icb, ca);  \n \n        vec2 pos = ic.xy - p;\n\t    if (dot(pos, pos) < ic.z*ic.z)\n        {\n            pos /= ic.z;\n\n            // shader for each of 5 circles\n            switch (i)\n            {\n                case 0: color = drawShaderA(pos); break;\n                case 1: color = drawShaderB(pos); break;\n                case 2: color = drawShaderC(pos); break;\n                case 3: color = drawShaderD(pos); break;\n                case 4: color += drawShaderE(pos); break;\t// special case: ..\n                \t\t\t\t\t\t\t\t\t\t\t// .. translucent one...\n            }\n            \n            color *= 0.1 + 0.9 * smoothstep(1.0, 0.6, dot(pos, pos));\n        }\n\n        // strokes for 5 menu circles\n        color += AA(abs(length(ic.xy - p) - ic.z));\n\n\t}\n       \n    \n    //--- set final color ---//\n    \n    fragColor = vec4(color, 1.0);  \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/////////////////////////////////////////////////////////////////////////////////\n\nvec3 circleFromThreePoints(vec2 p1, vec2 p2, vec2 p3)\n{\n  float x1 = p1.x;\n  float y1 = p1.y;\n  float x2 = p2.x;\n  float y2 = p2.y;\n  float x3 = p3.x;\n  float y3 = p3.y;\n\n    \n  float a = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2;\n\n  float b = (x1 * x1 + y1 * y1) * (y3 - y2) \n          + (x2 * x2 + y2 * y2) * (y1 - y3)\n          + (x3 * x3 + y3 * y3) * (y2 - y1);\n\n  float c = (x1 * x1 + y1 * y1) * (x2 - x3) \n          + (x2 * x2 + y2 * y2) * (x3 - x1) \n          + (x3 * x3 + y3 * y3) * (x1 - x2);\n\n    \n  float denom = -1.0 / (2.0 * a);\n  float x = b * denom;\n  float y = c * denom;\n \n  return vec3(x, y, length(vec2(x - x1, y - y1)));\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////\n\nvec2 inversePoint(vec2 a_point, vec3 a_inversor)\n{\n    \n    //--- move point to the center of inversion ---//\n    \n\tvec2 d = a_point - a_inversor.xy;\n    \n    \n    //--- inverse point ---//\n    \n    d *= (a_inversor.z * a_inversor.z / dot(d, d));\n        \n    \n    //--- move point out of center of inversion ---//\n    \n    return d + a_inversor.xy;\n    \n}\n\n\n/////////////////////////////////////////////////////////////////////////////////\n\nvec3 inverseCircle(vec3 a_circle, vec3 a_inversor)\n{\n    \n    //--- get three points on source circle ---//\n    \n    vec2 p1 = vec2(a_circle.x - a_circle.z, a_circle.y);\n\tvec2 p2 = vec2(a_circle.x + a_circle.z, a_circle.y);\n    vec2 p3 = vec2(a_circle.x,       \t\ta_circle.y + a_circle.z);\n  \n    \n    //--- inverse them separately ---//\n    \n\tvec2 ip1 = inversePoint(p1, a_inversor);\n\tvec2 ip2 = inversePoint(p2, a_inversor);\n\tvec2 ip3 = inversePoint(p3, a_inversor);\n  \n    \n    //--- create new circle from inverted points ---//\n    \n\treturn circleFromThreePoints(ip1, ip2, ip3);\n    \n}\n\n\n/////////////////////////////////////////////////////////////////////////////////\n\n// maps value - like in Processing3 map() function\nfloat mapValue(float value, float min1, float max1, float min2, float max2)\n{\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////\n\n// maps circle a_circle to a_destination in respect to a_source\nvec3 mapCircle(vec3 a_circle, vec3 a_source, vec3 a_destination)\n{\n\n    //--- get circle dimensions ---//\n    \n    float s_x1 = a_source.x - a_source.z;\n    float s_y1 = a_source.y - a_source.z;\n    float s_x2 = a_source.x + a_source.z;\n    float s_y2 = a_source.y + a_source.z;\n\n    float d_x1 = a_destination.x - a_destination.z;\n    float d_y1 = a_destination.y - a_destination.z;\n    float d_x2 = a_destination.x + a_destination.z;\n    float d_y2 = a_destination.y + a_destination.z;\n\n    \n    //--- remap circle ---//\n    \n    return vec3\n    (\n\t    mapValue(a_circle.x, s_x1, s_x2, d_x1, d_x2),\n    \tmapValue(a_circle.y, s_y1, s_y2, d_y1, d_y2),\n    \ta_circle.z * a_destination.z / a_source.z\n\t);\n    \n}\n\n\n/////////////////////////////////////////////////////////////////////////////////\n","name":"Common","description":"","type":"common"}]}