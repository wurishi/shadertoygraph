{"ver":"0.1","info":{"id":"wsSfRz","date":"1589348372","viewed":101,"name":"Simple Scene w/ Texture","username":"blepfo","description":"Been following tutorials for camera, soft shadows, ambient occlusion, tri-planar texture mapping.\nReferences included in code comments","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","texture","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define PI (3.141)\n#define TWOPI (2.*PI)\n#define RAND_SEED (87629.3453)\n\n#define MARCH_MAX_STEPS (512)\n#define MARCH_MAX_DIST (1000.)\n#define MARCH_HIT_DIST (0.001)\n\n#define AO_ITERATIONS (5)\n#define GLOBAL_AO (0.143)\n\n#define SHADE_AO_ONLY (false)\n\n// Material IDs\n// Used so we can assign materials to objects\n// when scene SDF is defined, but we can defer material calculation\n// until later when we can compute normal\n#define MATERIAL_GROUND_PLANE (0)\n#define MATERIAL_CHECKERBOARD (1)\n\n\nstruct Ray {\n    vec3 o;\t\t\t// origin\n    vec3 d;\t\t\t// direction\n};\n\nstruct PointLight { \n    vec3 o;\t\t\t// origin\n    vec3 d;\t\t\t// diffuse intensity\n    vec3 s; \t\t// specular intensity\n    vec3 a;\t\t\t// ambient intensity\n};\n\nstruct DirectionLight {\n    vec3 dir;\t\t// direction\n    vec3 d;\t\t\t// diffuse intensity\n    vec3 s; \t\t// specular intensity\n    vec3 a;\t\t\t// ambient intensity\n};\n\nstruct Material {\n    vec3 d;\t\t\t// diffuse\n    vec3 s;\t\t\t// specular\n    vec3 a;\t\t\t// ambient\n    float shiny;\t// shininess\n};\n\nstruct SceneObj {\n    float sdf;\n\tint matId;\n};\n\nstruct Hit {\n    vec3 p;\n    vec3 n;\n    SceneObj obj;\n};\n\n/********* Transformations\n**********/\n\nvec3 transformLookup(vec3 p, int id) {\n    return p;\n}\n\nvec3 translate(vec3 p, vec3 t) {\n    return p - t;\n}\n\nmat2 rotate2d(float theta) { \n    return mat2(cos(theta), -sin(theta), \n                sin(theta), cos(theta)); \n}\n\nvec2 repeat(vec2 p, float c) {\n    // Center around origin\n    p = p + (c/2.);\n    // Repeat after interval of c, recenter around origin\n    return mod(p, c) - (c / 2.);\n}\n\nvec2 repeat(vec2 p, float c, float l) {\n\t// Center around origin\n    p = p + (c/2.);\n    // floor(p/c) == grid idxs for grid of size c\n    // by clamping floor(p/c) to +/- l, we only alow \n    // repeating up to (2l+1) idxs\n    return (p - c*clamp(floor(p/c), -l, l)) - (c / 2.);\n}\n\n\n/********* Textures\n**********/\n\n// Reference for pseudorandom:\n// https://thebookofshaders.com/10/\nfloat rand2(vec2 uv) {\n    return fract(\n        RAND_SEED*\n        \t(sin(dot(uv, vec2(21.243123, 15.23234)))\n        ));\n}\n\n// Reference for Value Noise:\n// https://thebookofshaders.com/11/\nfloat valueNoiseColor(vec2 uv, float scale) {\n    uv *= scale;\n    vec2 gridIdx = floor(uv);\n    vec2 m = smoothstep(0., 1., fract(uv));\n    float a = rand2(gridIdx);\n    float b = rand2(gridIdx + vec2(1., 0.));\n    float c = rand2(gridIdx + vec2(0., 1.));\n    float d = rand2(gridIdx + vec2(1.));\n    float ab = mix(a, b, m.x);\n    float cd = mix(c, d, m.x);\n    float abcd = mix(ab, cd, m.y);\n    return abcd;\n}\n\n// Reference for Tri-Planar Mapping:\n// https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821\nMaterial valueNoiseTexture(vec3 p, vec3 normal, float scale, float shiny) {\n\tvec3 weights = abs(normal);\n    weights = pow(weights, vec3(1.));\n    weights /= (weights.x + weights.y + weights.z + 0.00001);\n    \n    float xTexture = valueNoiseColor(p.yz, scale);\n    float yTexture = valueNoiseColor(p.xz, scale);\n    float zTexture = valueNoiseColor(p.xy, scale);\n    float texture = (xTexture * weights.x) + (yTexture * weights.y) + (zTexture * weights.z);\n    return Material(\n        vec3(texture),\n        vec3(0.900,0.900,0.900),\n        vec3(texture * 0.364),\n        shiny\n    );\n}\n\n\n/********* Signed Distance Functions (SDFs)\n\nReferences for SDFs:\nSphere, Cube, Torus, Capsule, Cylinder - https://youtu.be/Ff0jJyyiVyw (ArtOfCode)\nRotate, Scale, Union, Intersection, Difference - https://youtu.be/AfKGMUDWfuE (ArtOfCode)\nOnioning, Displacement Mapping, Twisting - https://youtu.be/Vmb7VGBVZJA (ArtOfCode)\n\nhttps://iquilezles.org/articles/distfunctions (Inigo Quilez)\n**********/\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdfPlane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\nfloat sdfTorus(vec3 p, vec2 r) {\n    // Distance to major circle\n    float x = length(p.xz) - r[0];\n    return length(vec2(x, p.y)) - r[1];\n}\n\nSceneObj objUnion(SceneObj s1, SceneObj s2) {\n    if (s1.sdf < s2.sdf) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\n\n// Define all objects in the scene\n// Use material Ids so we can wait until later to calculate Material colors\n// Materials using textures need scene normal, which we can't get until after\n// scene SDF is defined\nSceneObj mapScene(vec3 p) {\n    vec3 sphereP = translate(p, vec3(0.000,0.690,0.000));\n    float c = 5.688;\n    sphereP.xz = repeat(sphereP.xz, c, 2.);\n    float sphere1Sdf= sdfSphere(sphereP, 1.280);\n    sphere1Sdf = sdfTorus(sphereP, vec2(2.,0.380));\n    SceneObj sphere1 = SceneObj(sphere1Sdf, 1);\n    \n    float groundPlaneSdf = sdfPlane(p, normalize(vec3(0.,1.,0.)));\n    SceneObj groundPlane = SceneObj(groundPlaneSdf, MATERIAL_GROUND_PLANE);\n\n    \n    SceneObj s = groundPlane;\n    s = objUnion(groundPlane, sphere1);\n    return s ;\n}\n\nfloat sdfScene(vec3 p) {\n\tSceneObj objAtP = mapScene(p);\n    return objAtP.sdf;\n}\n\n\n// Scene normals using SDF gradient\n// References for normal calculation: \n// http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// https://iquilezles.org/articles/normalsSDF (Inigo Quilez)\nvec3 sceneNormal(vec3 p) {\n    vec2 epsilon = vec2(0.01, 0.);\n    return normalize(vec3(\n        sdfScene(p + epsilon.xyy) - sdfScene(p - epsilon.xyy),\n        sdfScene(p + epsilon.yxy) - sdfScene(p - epsilon.yxy),\n        sdfScene(p + epsilon.yyx) - sdfScene(p - epsilon.yyx)\n    ));\n}\n\n\n/********** MATERIALS **********/\n\nMaterial materialLookup(Hit hit) {\n    int matId = hit.obj.matId;\n    if (matId == MATERIAL_GROUND_PLANE) {\n        // Plane material\n        return Material(\n        \tvec3(0.5),\n        \tvec3(0.265,0.265,0.265), \n        \tvec3(0.500,0.488,0.500),\n        \t256.\n        );\n    } else if (matId == MATERIAL_CHECKERBOARD) {\n        return valueNoiseTexture(hit.p, hit.n, 7.5 , 256.);\n    }\n}\n\n\n// References for raymarching:\n// http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// https://youtu.be/PGtv-dBi2wE (ArtofCode)\nbool rayMarch(Ray r, out Hit hit) {\n    // Accumulated distance to ray origin\n    float dO = 0.;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++) {\n        vec3 p = r.o + (dO * r.d);\n        // Current distance to scene\n        float dS = sdfScene(p);\n        dO += dS;\n        if (abs(dS) < MARCH_HIT_DIST) {\n            hit = Hit(\n                p,\n                sceneNormal(p),\n                mapScene(p)\n            );\n            return true;\n        }\n        if (dO >= MARCH_MAX_DIST) {\n            return false;\n        }\n    }\n    return false;\n}\n\n\n/********** LIGHTING **********/\n\n// Reference for shadows: \n// https://youtu.be/2YZClgDWCaM (3dGraphicsFromScratch)\n// http://www.polygonpi.com/?p=318 (Polygon Pi)\n// https://iquilezles.org/articles/rmshadows (Inigo Quilez)\nfloat calcShadow(Ray shadowRay, float maxMarch, float k) {\n    // Shadow increases when ray from surface to light gets closer to scene (dS gets smaller)\n    // More distant objects cast darker shadows (dO gets larger)\n    float shadowMultiplier = 1.;\n    float dO = 0.;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++) {\n        if (dO > maxMarch) { break; }\n        vec3 p = shadowRay.o + (dO * shadowRay.d);\n        float dS = sdfScene(p);\n        if (abs(dS) < MARCH_HIT_DIST) {\n            // Hit surface -- we are in a shadow\n            return 0.;\n        }\n        dO += dS;\n        shadowMultiplier = min(shadowMultiplier, k * dS / dO);\n    }\n\treturn clamp(shadowMultiplier, 0., 1.);\n}\n\n// Reference for ambient occlusion:\n// https://youtu.be/6zYTrFRVGiU (3dGraphicsFromScratch)\nfloat calcAO(vec3 p, vec3 normal, float epsilon) {\n    float aoMultiplier = 0.;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITERATIONS ; i++) {\n        float t = epsilon * float(i);\n        aoMultiplier += (weight * (1. - (t - sdfScene(p + t*normal))));\n        weight /= 2.;\n    }\n    return aoMultiplier;\n}\n\n\n// Reference for lighting:\n// Basics - http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// Diffuse - https://youtu.be/9VJReTr7YXY (3dGraphicsFromScratch)\n// Diffuse - shadows - https://youtu.be/PGtv-dBi2wE (ArtOfCode)\nvec3 illuminateSingleLight(\n    Hit hit, \n    vec3 lDir, \n    vec3 lDiffuse, \n    vec3 lSpec, \n    vec3 lAmbient, \n    vec3 eye,\n    float maxMarch\n) {\n    Material mat = materialLookup(hit);\n    // DIRECT LIGHTING\n    // Diffuse illumination\n    float diffuse = dot(hit.n, lDir);\n    vec3 diffuseIllum = diffuse * lDiffuse * mat.d;\n    // Specular illumination\n    vec3 r = reflect(lDir, hit.n);\n    vec3 viewDir = normalize(eye - hit.p);\n    float specular = dot(r, viewDir);\n    vec3 specularIllum = pow(specular, mat.shiny) * mat.s * lSpec;\n    vec3 directLight = diffuseIllum + specularIllum;\n    // Estimate shadow\n    vec3 pNearSurface = hit.p + (hit.n * MARCH_HIT_DIST * 2.);\n    float shadow = calcShadow(Ray(pNearSurface, lDir), maxMarch, 3.);\n    directLight *= shadow;\n    // INDIRECT LIGHTING\n    vec3 ambientIllum = lAmbient * mat.a;\n    float ambientOcclusion = calcAO(hit.p, hit.n, GLOBAL_AO);\n    vec3 indirectLight = ambientIllum * ambientOcclusion;\n    \n    vec3 illum = directLight + indirectLight;\n    \n    if (SHADE_AO_ONLY) {\n        return vec3(ambientOcclusion);\n    }\n\n    return clamp(illum, 0., 1.);\n}\n\n\n// DirectionalLight\nvec3 illuminateSingleLight(Hit hit, DirectionLight l, vec3 eye, float maxMarch) {\n    vec3 illum = illuminateSingleLight(hit, l.dir, l.d, l.s, l.a, eye, maxMarch);\n    return illum;\n}\n\n\n// Point light\nvec3 illuminateSingleLight(Hit hit, PointLight l, vec3 eye) {\n    vec3 lDir = normalize(l.o - hit.p);\n    // Light intensity decayed by 1/(dist^2)\n    vec3 lDiff = (hit.p - l.o);\n    float falloff = 1. / dot(lDiff, lDiff);\n    vec3 illum = illuminateSingleLight(hit, DirectionLight(lDir, l.d*falloff, l.s*falloff, l.a), eye, distance(hit.p, l.o));\n\n    return illum;\n}\n\n\n// Define all lights in the scene\nvec3 illuminateScene(Hit hit, vec3 eye) {\n    vec3 l1Pos = vec3(0.769,4.652,4.080);\n    vec3 l1Intensity = vec3(15.);\n    PointLight l1 = PointLight(\n        l1Pos, \t\t\t\n        l1Intensity, \n        l1Intensity, \n        vec3(0.265,0.265,0.265)\n    );\n    \n    vec3 l2Pos = vec3(6., 4., -7.);\n    vec3 l2Intensity = vec3(19.);\n    //PointLight l2 = PointLight(l2Pos, l2Intensity);\n    \n    DirectionLight l2 = DirectionLight(\n        normalize(vec3(0.775,0.775,0.000)), \n        vec3(0.600,0.600,0.600),\t\t\t\t// diffuse\n        vec3(0.180,0.180,0.180),\t\t\t\t// specular\n        vec3(0.260,0.260,0.260)\t\t\t\t\t// ambient\n    );\n    \n    vec3 i1 = illuminateSingleLight(hit, l1, eye);\n    vec3 i2 = illuminateSingleLight(hit, l2, eye, 100.);\n    return i1 + i2;\n}\n\n\n/********* RENDER SCENE *********/\n\n// References for camera:\n// https://youtu.be/PBxuVlp7nuM (ArtofCode)\n// https://youtu.be/2SaGgTlkhSs (3dGraphicsFromScratch)\nRay cameraViewRay(vec2 uv, vec3 eye, vec3 lookat, float fovDegrees, float roll) {\n    // Axes\n    vec3 f = normalize(lookat - eye);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    // Image plane\n    float zoom = 1. / tan(radians(fovDegrees) / 2.);\n    vec3 c = eye + f*zoom;\n    uv *= rotate2d(roll);\n    vec3 i = c + (uv.x*r) + (uv.y*u);\n    // Ray from camera origin to intersection with image plane\n    return Ray(eye, normalize(i - eye));\n}\n\n\nvec3 renderScene(Ray viewRay) {\n    Hit sceneHit;\n    // rayMarch returns false if no scene intersection\n    if(!rayMarch(viewRay, sceneHit)) return vec3(0.072,0.145,0.035);\n    else return illuminateScene(sceneHit, viewRay.o);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Move origin to center of viewing plane\n    uv -= 0.5;\n    // Normalize aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    // Remap to [-1, -1] x [1, 1]\n    uv *= 2.;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= 0.5;\n    \n    // CAMERA SETUP\n    vec2 cameraXZ = 7. * vec2(cos(mouse.x*TWOPI*2.), sin(mouse.x*TWOPI*2.));\n    vec3 eye = vec3(cameraXZ[0], 6. + sin(mouse.y)*10., cameraXZ[1]);\n    vec3 lookat = vec3(0., 0., 0.);\n    Ray viewRay = cameraViewRay(uv, eye, lookat,  75., 0.);\n\n    // CALCULATE PIXEL COLOR\n    vec3 color = vec3(0.);\n    color = renderScene(viewRay);\n    \n    // Uncomment to see 2d value noise texture\n    //color = vec3(valueNoiseColor(uv, 5.472));\n\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}