{"ver":"0.1","info":{"id":"3dtBDf","date":"1606151849","viewed":95,"name":"Raymarched trees","username":"me_123","description":"In this shader, i am trying to get a nice outdoor lighting and sky. It has specular lighting and colored SDF's.\nsome of the distance functions are from https://iquilezles.org/articles/distfunctions/distfunctions.htm.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float max_steps = 1000.;\nfloat max_dist = 1000.;\nfloat e = 1e-3;\nfloat camSize = 40.;\nvec3 lightPos = vec3(10., 20, 10.);\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cc( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\nfloat mandel(vec3 p) {\n    vec3 z = p;\n    float dr = 1.;\n    float r = 0.0;\n    float power = 3.;\n    for (int i = 0; i < 100; i ++) {\n        r = length(z);\n        if (r > 2.0) {\n            break;\n        }\n        float thata = acos(z.z/r) * power;\n        float phi = atan(z.y, z.x) * power;\n        float zr = pow(r, power);\n        dr = pow(r, power-1.) * power * dr + 1.;\n        z = zr * vec3(sin(thata) * cos(phi), sin(phi) * sin(thata), cos(thata));\n    \tz += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nvec3 rep( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nvec4 uni(vec4 a, vec4 b) {\n\treturn a.w < b.w? a : b;\n}\nvec4 difr(vec4 a, vec4 b) {\n\treturn a.w > b.w? a : b;\n}\nvec4 suni(vec4 a, vec4 b, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(a.w-b.w)/k, 0.0, 1.0 );\n    vec3 c = mix(a.rgb, b.rgb, h);\n    float d = mix( a.w, b.w, h) - k*h*(1.-h); \n    return vec4(c, d);\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nvec3 mushromStep(vec3 p) {\n    float val = clamp(abs(dot(sin(p*5.), sin(p*2.1)))/2., 0.3, 0.4);\n    return vec3(val/1., val/2., 0.0);\n}\nfloat nois(vec3 p) {\n    float ou = sin(p.x/3.);\n    ou += sin(p.z/2.);\n\treturn ou/10.;\n}\nvec4 SDF(vec3 p) {\n    p = rep(p, 20., vec3(10., 0.0, 10.));\n    vec3 pp = rep(p, 1., vec3(100));\n    float disp = min(sphere(pp, 1.0), box(pp, vec3(1.)))+length(sin(p*5.)/3.);\n    float shape1 = p.y-nois(p);\n    vec4 shape2 = vec4(mushromStep(p), mix(cyl(p, 0.3, 7.)-0.5, disp, 0.1));\n    float c = cc(rep(p-vec3(0, 4, 0), 2.0, vec3(0, 1.0, 0)), 1.0, 4.0, 2.5);\n    vec4 shape3 = vec4(vec3(0, 1, 0), c);\n    vec4 shape4 = vec4(vec3(0, 1.0, 0.0), cc((p-vec3(0, 9.5, 0)), 2.0, 3.0, 0.0));\n    vec4 o = suni(suni(suni(shape2, shape3, 2.0), shape4, 1.0), vec4(vec3(0.25, 0.125, 0.0), mix(p.y,disp, 0.1)+7.), 1.0);\n    \n    return o;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = SDF(ro + rd*t).w/64.;\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\nvec2 getDist(vec3 ro, vec3 rd, out vec3 color) {\n    float d0 = 0.001;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        vec4 r = SDF(p);\n        float ds = r.w;\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n       \t\tc = r.xyz;\n            break;\n        };\n    }\n    color = c;\n    return vec2(d0, steps);\n}\nvec3 getNormal(vec3 p) {\n    float d = SDF(p).w;\n    vec2 e = vec2(.0001, 0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy).w,\n    \tSDF(p-e.yxy).w,\n    \tSDF(p-e.yyx).w\n    );\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 lightPos, vec3 rd, vec3 ro, vec2 ray, vec3 color) {\n    vec3 lp = normalize(lightPos-p);\n    vec3 norm = getNormal(p);\n    float sha1 = softshadow( p+0.001*norm, lightPos, 2.0 );\n    float l = length(p-lightPos)-1.0;\n    float dif = dot(norm, lp)/clamp(l/1., 1., 100.0)*6.;\n    float reflected = 0.0;//clamp(float((dot(reflect(rd, norm), lightPos)) - 10.0), 0.0, 1.0);\n    dif = (dif+(reflected/(l/0.5)));\n    if (ray.x < max_dist) {\n        dif += clamp(min(ray.y/255., 0.5), 0.0, 0.25);\n        dif += 0.4;\n    }\n    dif /= 1.;\n    dif += sha1;\n    return (reflected/10. + color+clamp(ray.y/40., 0.0, 0.3))*vec3(clamp(dif, 0.0, 1.0))*vec3(2.0, 2.0, 2.0);\n}\nfloat samples = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 mouse = ((iMouse.xy-.5*iResolution.xy)/iResolution.xy)*5.;\n    mouse.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(sin(iTime)*camSize, (0.5)*camSize, cos((iTime+5.5)/5.)*camSize);\n    for (int i = 0; i < int(samples); i += 1) {\n        vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.xy);\n        uv.x *= iResolution.x/iResolution.y;\n        uv.x += (hash(uv+float(i))-0.5)/(iResolution.y/2.);\n        uv.y += (hash(uv+1.+float(i))-0.5)/(iResolution.x/2.);\n        vec3 at = vec3(0, 10, 0);\n        vec3 c_z = normalize(at-ro);\n        vec3 c_x = normalize(cross(vec3(0,1,0), c_z));\n        vec3 c_y = cross(c_z, c_x);\n        vec3 rd = normalize(uv.x * c_x + uv.y * c_y + 1.73 * c_z);\n        vec3 color = vec3(0);\n        vec2 ray = getDist(ro, rd, color);\n        float dist = ray.x;\n        vec3 p = ro+rd*dist;\n        vec3 light = getLight(p, lightPos, rd, ro, ray, color);\n        vec3 ocol = (light);\n        if (dist < max_dist) {\n        \tocol += sqrt(ocol)/5.;\n            ocol /= 1.25+clamp(ray.y/50., 0.1, 1.0);\n        } else {\n        }\n        float val = abs(clamp(rd.y, 0.1, 1.0)+1.0)*0.9;\n        ocol = mix(ocol, vec3(val/1.5, val/1.5, val), clamp(dist/200., 0.0, 1.0));\n        col += ocol;\n    }\n    fragColor = vec4(col/samples,1.0);\n}","name":"Image","description":"","type":"image"}]}