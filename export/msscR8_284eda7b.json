{"ver":"0.1","info":{"id":"msscR8","date":"1686657060","viewed":109,"name":"黄土地","username":"amuda","description":"fbm terrain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 80\n#define PI 3.1415926\n#define LIGHT0_POS vec3(5.0, 5.0, -5.0)\n#define LIGHT0_COLOR vec3(0.8, 0.7, 0.1)\n#define LIGHT0_DIR vec3(1.0, 1.0, 0.5)\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43578.7263);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 z = fract(x);\n    z = z * z * (3.0 - 2.0 * z);\n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n\n    float a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n    \n    float e = hash(n + 113.0);\n    float f = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n\n    float res1 = mix(mix(a, b, z.x), mix(c, d, z.x), z.y);\n    float res2 = mix(mix(e, f, z.x), mix(g, h, z.x), z.y);\n    float res = mix(res1, res2, z.z);\n    \n    return res;\n}\n\nfloat fbm(vec3 p, bool detail)\n{\n    float f = 0.0;\n    float r = 1.0;\n    p *= 0.8;\n    f += r * noise(p); r *= 0.5;\n    f += r * noise(p); p *= 2.0; r *= 0.5;\n    f += r * noise(p); p *= 2.0; r *= 0.5;\n    f += r * noise(p); p *= 2.0; r *= 0.5;\n    if (!detail)\n    {\n        return f;\n    }\n    f += r * noise(p); p *= 2.0; r *= 0.5;\n    f += r * noise(p); p *= 2.0; r *= 0.5;\n    f += r * noise(p); p *= 2.0; r *= 0.5;\n    f += r * noise(p); p *= 2.0; r *= 0.5;\n    \n    return f;\n}\n\nfloat plane(vec3 p, bool detail)\n{\n    return fbm(p, detail) + p.y;\n}\n\nvec2 map(vec3 p, bool detail)\n{\n    float d = 9999999.0;\n    int mat = 0;\n    float h;\n\n    // float h = sphere(p, vec3(0.0, 1.0, 0.0), 0.15);\n    // if (h < d)\n    // {\n    //     d = h;\n    //     mat = 0;\n    // }\n\n    // 地面\n    h = plane(p, detail);\n    if (h < d)\n    {\n        d = h;\n        mat = 1;\n    }\n\n    return vec2(d, mat);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec3 e = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(p + e.xyy, true).x - map(p-e.xyy, true).x;\n    n.y = map(p + e.yxy, true).x - map(p-e.yxy, true).x;\n    n.z = map(p + e.yyx, true).x - map(p-e.yyx, true).x;\n    return normalize(n);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    for(float t = 0.1; t < 8.0;)\n    {\n        float h = map(ro + t * rd, false).x;\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, 8.0*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec2 rayMarching(vec3 startPoint, vec3 direction)\n{\n    float t = 0.0;\n    vec3 newPoint = startPoint;\n    for(int i = 0; i < MAX_STEP; i++)\n    {\n        vec2 result = map(newPoint, false);\n        t += result.x * 0.6;\n        if (result.x < 0.01)\n        {\n            return vec2(t, result.y);\n        }\n        newPoint = startPoint + t * direction;\n    }\n    return vec2(-1.0, 0);\n}\n\nvec3 materail0(vec3 lighDir, vec3 normal, vec3 viewDir, float shadow)\n{\n    vec3 ambient = vec3(0.3, 0.3, 0.3);\n    vec3 diffusion = vec3(0.5, 0.2, 0.1);\n    float diffusionRatio = clamp(dot(lighDir, normal), 0.0, 1.0);\n    vec3 specular = vec3(1.0, 1.0, 1.0);\n    float specularRatio = pow(clamp(dot(normalize((viewDir + lighDir) / 2.0), normal), 0.0, 1.0), 64.0);\n    return ambient + (diffusion * diffusionRatio + specular * specularRatio) * LIGHT0_COLOR * shadow;\n}\n\nvec3 materail1(vec3 lighDir, vec3 normal, vec3 viewDir, float shadow)\n{\n    vec3 ambient = vec3(0.4, 0.15, 0.1);\n    vec3 diffusion = vec3(0.4, 0.6, 0.0);\n    float diffusionRatio = clamp(dot(lighDir, normal), 0.0, 1.0);\n    vec3 specular = vec3(0.2, 0.2, 0.2);\n    float specularRatio = pow(clamp(dot(normalize((viewDir + lighDir) / 2.0), normal), 0.0, 1.0), 2.0);\n    return ambient + (diffusion * diffusionRatio + specular * specularRatio) * LIGHT0_COLOR * shadow;\n}\n\nvec3 shade(vec3 pos, float mat, vec3 eyePos)\n{\n    vec3 normal = calcNormal(pos);\n    vec3 viewDir = normalize(eyePos - pos);\n    // vec3 lighDir = normalize(LIGHT0_POS - pos);\n    vec3 lighDir = normalize(LIGHT0_DIR);\n    float shadowRatio = softShadow(pos, lighDir);\n    switch(int(mat))\n    {\n        case 0:\n            return materail0(lighDir, normal, viewDir, shadowRatio);\n        case 1:\n            return materail1(lighDir, normal, viewDir, shadowRatio);\n        default:\n            return vec3(1.0, 0.0, 1.0);\n            break;\n    }\n}\n\n\nvec3 getRayDirection(vec2 uv, vec3 cameraPos, vec3 lookPos, float fov)\n{\n    vec3 z = normalize(lookPos - cameraPos);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 x = cross(y, z);\n    z = cross(x, y);\n    mat3 cameraMat = mat3(x, y, z);\n\n    return normalize(cameraMat * vec3(uv, 0.5 / tan(fov / 180.0 * PI)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 rayOrigin = vec3(0.0, 1.5, 0.0) + vec3(0.0, 0.0, iTime);\n    //vec3 rayOrigin = vec3(0.0, 1.5, 0.0);\n    float fov = 25.0;\n    vec3 direction = getRayDirection(uv, rayOrigin, rayOrigin + vec3(-0.2, -1.0, 1.0), fov);\n\n    vec3 color = vec3(0.4, 0.6, 0.7);\n    vec3 fogColor = vec3(0.04f, 0.03f, 0.01f);\n    vec2 result = rayMarching(rayOrigin, direction);\n    if (result.x > 0.0)\n    {\n        color = shade(rayOrigin + direction * result.x, result.y, rayOrigin);\n        color -= 0.35 * fogColor * clamp(exp(result.x * 0.15), 0.0, 20.0);\n    }\n    else\n    {\n        // star\n        if (noise(vec3(uv * 9998.0, 0.0)) < 0.001)\n        {\n            color = vec3(1.0);\n        }\n\n        // cloud\n        float t = (800.0 - rayOrigin.y) / direction.y; \n        vec3 cloundPos = rayOrigin + direction * t + vec3(0.0, 0.0, noise(direction) * 500.0);\n        // color -= fbm(cloundPos * 0.003) * vec3(0.2);\n        color = color * 0.7 + fbm(cloundPos * 0.0022, false) * vec3(0.7) * 0.3;\n\n        // fog\n        vec3 finalPos = rayOrigin + direction * 999.0;\n        float flogY = 5.0 - finalPos.y / 500.0;\n        color -= 0.3 * fogColor * exp(flogY);\n    }\n\n    color = pow(color, vec3(2.2));\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}