{"ver":"0.1","info":{"id":"3s3GDX","date":"1569350427","viewed":117,"name":"Raymarching enthusiast","username":"TheOldBeach","description":"Raymarching enthusiast","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingenthusiast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SETUP_SCENE() float minDist = MAX_DIST*2.;float time = iTime; vec3 originalPos = pos; vec3 basePos = pos;vec3 temp3; float temp\n#define CREATE_SPHERE(p,r) (minDist = min(sdSphere(pos - p,r),minDist))\n#define CREATE_BOX(p,s) ( minDist = min(sdBox(pos - p,s ),minDist))\n#define CREATE_ROUNDBOX(p,s,k) ( minDist = min(sdRoundedBox(pos - p,s,k ),minDist))\n#define CREATE_CAPSULE(p1,p2,r) ( minDist = min(sdCapsule(pos, p1, p2,r),minDist))\n#define CREATE_DISK(p,ra,rb) (minDist = min(sdDisk(pos - p,ra,rb),minDist))\n#define CREATE_TORUS(p,ra,rb) (minDist = min(sdTorus(pos - p,ra,rb),minDist))\n#define CREATE_CUT_SPHERE(p,r) ( minDist = max(-sdSphere(pos - p,r),minDist))\n#define CREATE_SMOOTH_SPHERE(p,r,k) ( minDist = SmoothMin(sdSphere(pos - p,r),minDist,k))\n#define CREATE_SMOOTH_CUT_SPHERE(p,r,k) ( minDist = SmoothMin(-sdSphere(pos - p,r),minDist,-k))\n#define CREATE_MANDELBULB(p,s,pw)   minDist = min(sdMandelbulb((pos - p),s,pw,temp)/4.0,minDist)\n#define RETURN_SCENE() return minDist\n\n#define ROTATE_X(piv,a) (pos = RotateX(pos,piv,a))\n#define ROTATE_Y(piv,a) (pos = RotateY(pos,piv,a))\n#define ROTATE_Z(piv,a) (pos = RotateZ(pos,piv,a))\n#define RESET_TRANSFORM() (pos = originalPos)\n\n#define START_TILLING(tile) originalPos = pos = mod((tile*0.5)+pos,tile) - (tile/2.0)\n#define STOP_TILLING() originalPos = pos = basePos;\n\n#define TIME_SHIFT(g,t) temp3 = floor((pos + g*0.5)/g); time = time + (temp3.x+temp3.y+temp3.z)*t\n#define RESET_TIME() time = iTime;  \n\n#define C_SETUP_SCENE() float minDist = MAX_DIST*2.;float time = iTime; vec3 sceneColor = vec3(0); vec3 originalPos = pos; vec3 basePos = pos;vec3 temp3; float temp; float mD\n#define C_CREATE_SPHERE(p,r,c) (minDist = MinColor(sdSphere(pos - p,r),minDist,c, sceneColor))\n#define C_CREATE_BOX(p,s,c) ( minDist = MinColor(sdBox(pos - p,s ),minDist,c,sceneColor))\n#define C_CREATE_ROUNDBOX(p,s,k,c) ( minDist = MinColor(sdRoundedBox(pos - p,s,k ),minDist,c,sceneColor))\n#define C_CREATE_CAPSULE(p1,p2,r,c) ( minDist = MinColor(sdCapsule(pos, p1, p2,r),minDist,c,sceneColor))\n#define C_CREATE_DISK(p,ra,rb,c) (minDist = MinColor(sdDisk(pos - p,ra,rb),minDist,c,sceneColor))\n#define C_CREATE_TORUS(p,ra,rb,c) (minDist = MinColor(sdTorus(pos - p,ra,rb),minDist,c,sceneColor))\n#define C_CREATE_CUT_SPHERE(p,r,c) ( minDist = MaxColor(-sdSphere(pos - p,r),minDist,c,sceneColor))\n#define C_CREATE_SMOOTH_SPHERE(p,r,k,c) ( minDist = SmoothMinColor(sdSphere(pos - p,r),minDist,c,sceneColor,k))\n#define C_CREATE_SMOOTH_CUT_SPHERE(p,r,k,c) ( minDist = SmoothMinColor(-sdSphere(pos - p,r),minDist,c,sceneColor,-k))\n#define C_CREATE_MANDELBULB(p,s,pw)  mD = sdMandelbulb((pos - p),s,pw,temp)/4.0; minDist = MinColor(mD,minDist,mix(RED,BLUE,temp),sceneColor)\n#define C_RETURN_SCENE() return vec4(sceneColor,minDist)\n\nfloat SceneDist(vec3 pos)\n{\n    SETUP_SCENE();\n\t\n    TIME_SHIFT(vec3(4.0,4.0,4.0),0.1);\n    float teta = iTime;\n    minDist = min(sdSlice(pos - 0.0,1.0,normalize(vec3(cos(teta),0,sin(teta)))),minDist);\n    START_TILLING(vec3(4.0,0.0,4.0));\n    CREATE_BOX(vec3(0.0,-6.0,0.0),4.0);\n\n    RETURN_SCENE();\n}\n\nvec4 SceneDistColor(vec3 pos)\n{    \n    C_SETUP_SCENE();\n    sceneColor = GREY;\n\n\tTIME_SHIFT(vec3(4.0,4.0,4.0),0.1);   \n    \n\n    minDist = MinColor(sdSlice(pos - 0.0,1.0,vec3(0,0,1)),minDist, vec3(0.9,0.1,0.1), sceneColor);\n    START_TILLING(vec3(4.0,0.0,4.0));\n    C_CREATE_BOX(vec3(0.0,-6.0,0.0),4.0,DARK);     \n\n    C_RETURN_SCENE();\n}\n\n\nvec3 GetNormal(vec3 pos)\n{\n\tfloat d = SceneDist(pos);\n    vec2 off = vec2(0.0005,0.0);\n    vec3 normal = d - vec3(SceneDist(pos+off.xyy),\n                           SceneDist(pos+off.yxy),\n                           SceneDist(pos+off.yyx));\n    return normalize(-normal);\n}\n\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir, out float it)\n{\n    it = 0.0;\n    float dist = 0.;\n    float totalDist = 0.;\n    for(int i = 0; i < MAX_STEP; i++)\n    {\n        rayOrigin += rayDir * dist;\n    \tdist = SceneDist(rayOrigin);\n\n        if(totalDist > MAX_DIST || abs(dist) <= HIT_DIST)\n            break;\n        \n        it++;\n        totalDist += dist;\n    }\n    return totalDist;\n}\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float it;\n    return RayMarch(rayOrigin, rayDir,it);\n}\n\nvec3 Shading(vec3 pos, vec3 normal, vec3 scene, Sunlight sun)\n{\n    vec3 o;\n    float LdotN = clamp(dot(normal,sun.dir),0.0,1.0); \n\n    vec3 hitOff = pos + normal*SAFE;\n    float distToLight = RayMarch(hitOff,sun.dir);\n    float atten = step(MAX_DIST-0.01f,distToLight);                          \n        \n    o = scene.xyz * (sun.color * LdotN * atten + sun.ambient);\n\n        return o;\n}\n\nvec3 Sky(vec3 dir)\n{\n    return texture(iChannel0,dir).xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 worldUp = vec3(0.,1.0,0.);    \n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;   \n\n   \tvec2 mouse =iMouse.xy/iResolution.xy;\n\tfloat mouseAngle = mouse.x * TAU *2.0f;\n    float mousePitch =  mix( -0.1,PI,mouse.y);   \n    \n    const float sunIntensity = 3.0f;\n    \n    Sunlight sun;\n    sun.dir = -normalize(vec3(0.5,-0.8,0.5));\n    sun.ambient = vec3(0.42,0.474,0.485);\n    sun.color =  vec3(1.0,0.83,0.43) * sunIntensity;\n    \n    float angle = iTime*0.25f;\n    vec3 cameraPivot = vec3(0);\n\tvec3 cameraPos = vec3(sin(mouseAngle)*2.0f,mousePitch*2.0f-1.0,cos(mouseAngle)*2.0f) + cameraPivot;\n    float zoom = 0.5f * ( abs(mousePitch) *0.5f + 1.0);\n    vec3 lookAt = vec3(0);\n    \n    vec3 forward = normalize(lookAt - cameraPos);\n    vec3 right = normalize(cross(worldUp,forward));\n    vec3 up = normalize(cross(forward,right));\n        \n    vec3 screen = cameraPos + forward * zoom + right * uv.x + up * uv.y;\n    \n    vec3 ray = normalize(screen - cameraPos);\n\tfloat outline;\n    float depth = RayMarch(cameraPos,ray,outline); \n\n   \tvec3 hitPos = cameraPos + ray * depth;\n    float noiseTest = Noise31(hitPos);\n    \n    vec3 scene = SceneDistColor(hitPos).xyz;\n    \n    vec3 normal = GetNormal(hitPos);\n    \n    vec3 reflVector = normalize(reflect(ray,normal));\n\n    vec3 reflection = scene;\n    vec3 reflHitPos = hitPos;\n    vec3 rPos = hitPos;\n\tvec3 rNormal = normal;\n\n    float factor = 1.0;\n    \n    for(float i = 0.; i < 1.; i++)\n    {\n        rPos = rPos + rNormal * SAFE;\n        float rDepth = RayMarch(rPos,reflVector);\n        if(rDepth >= MAX_DIST){ reflection = Sky(reflVector); break;}\n            \n        vec3 rHit = rPos + reflVector * rDepth;\n        vec3 rScene = SceneDistColor(rHit).xyz;\n        rNormal = GetNormal(rHit);\n        reflVector = reflect(normalize(rHit-rPos),rNormal);\n        rPos = rHit;\n        factor *=0.95;\n        reflection = Shading(rHit,rNormal,rScene,sun);\n    }    \n    \n    vec3 litScene = Shading(hitPos,normal,scene,sun);\n    \n    float VdotL = dot(ray,sun.dir)*0.5+0.5;\n    float glow = clamp(pow(VdotL,16.0),0.0,1.0);\n    glow += mix(0.1,1.0,VdotL);\n    glow /= 4.0;\n    VdotL *= VdotL;    \n    VdotL *= VdotL;\n\n    vec3 col = vec3(0);\n    const float density = 0.05;\n    float fogFactor = 1.0-clamp(1.0/exp(pow(clamp(depth,0.0,50.0)*density,2.0)),0.0,1.0);\n    \n    col.rgb = mix(mix(litScene,litScene*reflection,0.5),vec3(0.5),fogFactor);\n\t\n    col.rgb = mix(col.rgb , sun.ambient+ sun.color*glow,fogFactor);\n\n   \t//col.rgb = vec3(depth*100.);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEP 200\n#define FLMAX_STEP MAX_STEP.0\n#define MAX_DIST 200.0\n#define HIT_DIST 0.005\n#define SAFE 0.0064\n\n#define TAU 6.28318530718\n#define PI 3.14159265359\n\n#define BLACK vec3(0.)\n#define RED vec3(0.6,0.15,0.15)\n#define GREEN vec3(0.3,0.5,0.3)\n#define DARK vec3(0.13,0.14,0.24)\n#define BLUE vec3(0.15,0.15,0.5)\n#define GREY vec3(0.5,0.5,0.5)\n#define WHITE vec3(1.0,1.0,1.0)\n#define GOLD vec3(0.95,0.74,0.05)\n\nstruct SurfaceInfo\n{\n    vec3 albedo;\n    float roughness;\n    float metalness;\n};\n    \nstruct Sunlight\n{\n    vec3 dir;\n    vec3 color;\n    vec3 ambient;\n};\n    \nfloat Unlerp(float mi,float ma,float x)\n{\n    return (x - mi)/(ma - mi);\n}\nfloat Hash21(vec2 p)\n{\n    p = vec2(p.x *1.4651, p.y * 3.6148);\n    p += dot(p,p+13.364);\n    return fract(p.x+p.y);\n}\nfloat Hash31(vec3 p)\n{\n    p = vec3(p.x *-13.4651, p.y * 34.6148, p.z * 61.314);\n    p += dot(p,p+13.364);\n    return fract(p.x+p.y+p.z);\n}\nvec3 Hash33(vec3 p)\n{\n    float a = Hash31(p);\n    float b = Hash31(vec3(a,p.x+p.y,p.z*13.6));\n    float c = Hash31(vec3(b,a+p.z,a+p.x*45.21));\n    return vec3(a,b,c);\n}\nfloat Noise21(vec2 p)\n{\n    vec2 id = floor(p);\n    vec2 gv = fract(p);\n    vec2 off = vec2(0.0,1.0);\n    float h00 = Hash21(id + off.xx);\n    float h01 = Hash21(id + off.xy);\n    float h10 = Hash21(id + off.yx);\n    float h11 = Hash21(id + off.yy);\n    float y0 = mix(h00,h01,gv.y);\n    float y1 = mix(h10,h11,gv.y);\n    float x = mix(y0,y1,gv.x);\n    return x;\n}\nfloat Perlin(vec2 p)\n{\n    float f;\n    float o;\n    for(float i = 1.0; i < 5.0;i++)\n    {\n        f += Noise21(p*i)/i;\n    }\n    return f/2.0;\n}\nfloat Noise31(vec3 p)\n{\n    p = p * 0.05;\n    vec3 id = floor(p);\n    vec3 coord = fract(p);    \n    float noise[8];\n \tint i = 0;\n    for(float X = 0.; X < 2.0;X++){\n        for(float Y = 0.; Y < 2.0; Y++){\n            for(float Z = 0.; Z < 2.0; Z++){\n               vec3 lid = id + vec3(X,Y,Z);\n               \n               vec3 rand = normalize(Hash33(lid));\n               vec3 toCorner = normalize(p-lid);\n                noise[i] = dot(rand,toCorner);\n               i++;\n                \n            }\n        }\n    }\n    \t\n    vec4 xPack0, xPack1;\n    xPack0 = vec4(noise[0],\n                  noise[1],\n                  noise[2],\n                  noise[3]);\n    xPack1 = vec4(noise[4],\n                  noise[5],\n                  noise[6],\n                  noise[7]);\n    vec4 xPack = mix(xPack0,xPack1,vec4(coord.x));\n    vec2 zPack = mix(xPack.xz,xPack.yw, vec2(coord.z));\n    float final = mix(zPack.x,zPack.y,coord.y);\n    return pow(clamp(final,0.0,1.0)*0.5+0.5,2.0);\n    \n}\n\n//-----------------------------------------------//\n//---------------BLENDING UTILITIES--------------//\n//-----------------------------------------------//\n\nfloat MinColor(float a, float b, vec3 aC, inout vec3 color)\n{\n    if(a<b) {color = aC; return a;}\n    else {color = color; return b;}\n}\nfloat MinSurface(float a, float b, SurfaceInfo aC, inout SurfaceInfo color)\n{\n    if(a<b) {color = aC; return a;}\n    else {color = color; return b;}\n}\n\nfloat MaxColor(float a, float b, vec3 aC, inout vec3 color)\n{\n    if(a<=b) {color = color; return b;}\n    else {color = aC; return a;}\n}\nfloat MaxSurface(float a, float b, SurfaceInfo aC, inout SurfaceInfo color)\n{\n    if(a<=b) {color = color; return b;}\n    else {color = aC; return a;}\n}\n\nfloat SmoothMin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat SmoothMinColor( float d1, float d2, vec3 aC, inout vec3 color, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    color = mix(color,aC,h);\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n//-----------------------------------------------//\n//---------------DISTANCE FUNCTIONS--------------//\n//-----------------------------------------------//\n\n\nfloat sdNoise(vec3 pos)\n{\n    return mix(HIT_DIST/4.0,10.0,(Noise31(pos)));\n}\nfloat sdSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdBox(vec3 pos, float size)\n{\n    vec3 d =abs(pos)-size;\n    vec3 i = min(d,0.0);\n    return length(max(d,0.0)) + max(i.z,max(i.x,i.y));\n}\n\nfloat sdRoundedBox(vec3 pos, float size , float roundness)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d,0.0)) - roundness + min(max(d.x,max(d.y,d.z)),0.0);\n\n}\n\nfloat sdCapsule(vec3 pos, vec3 a, vec3 b, float r)\n{\n    vec3 pa = pos - a;\n    vec3 ba = b - a;\n    \n    float l = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n   \n   \tfloat d = length( mix(a,b,l) - pos) - r;\n    return d;\n}\n\nvec3 sdArtefact_Factory(vec3 pos, float r, float offset,float t)\n{\n    vec3 dir = normalize(pos);\n    float rr = r;\n    float m = abs(mod(t-32.0,64.0)-32.0);\n    float a = mix(0.,offset,cos(atan(dir.x,dir.y)*m)*0.5+0.5);\n    float b = mix(0.,offset,cos(atan(dir.x,dir.z)*m)*0.5+0.5);\n    float c = mix(0.,offset,cos(atan(dir.y,dir.z)*m)*0.5+0.5);\n\treturn vec3(a,b,c)*0.2 + r;\n}\n\nfloat sdArtefactA(vec3 pos, float r,float t)\n{\n    vec3 art = sdArtefact_Factory(pos,r,0.1,t);\n    float h = min(max(art.x,art.y),art.z);\n    float d = length(pos)  - h;\n    return d*0.5;\n}\nfloat sdArtefactB(vec3 pos, float r,float t)\n{\n    vec3 art = sdArtefact_Factory(pos,r,0.1,t);\n    float h = max(max(art.x,art.y),art.z);\n    float d = length(pos)  - h;\n    return d*0.5;\n}\nfloat sdArtefactC(vec3 pos, float r,float t)\n{\n    vec3 art = sdArtefact_Factory(pos,r,0.1,t);\n    float h = min(min(art.x,art.y),art.z);\n    float d = length(pos)  - h;\n    return d*0.5;\n}\n\nfloat sdTorus(vec3 pos, float ra,float rb)\n{\n    vec2 tr = vec2(length(pos.xz) - ra,pos.y);\n    return length(tr) - rb;\n}\nfloat sdOctoCapsule(vec3 pos, float s)\n{\n    vec3 a = vec3(sign(pos.x),sign(pos.y),sign(pos.z))*s;\n    vec3 b = -a;\n    vec3 pa = pos - a;\n    vec3 ba = b - a;\n\tfloat l = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n   \treturn length(mix(a,b,l) - pos) - s;\n}\nfloat sdRectangle(vec3 pos, float r, float s)\n{\n\tvec3 clPos = clamp(pos,vec3(-s,0.0,-s),vec3(s,0.0,s));\n    float d = length(clPos - pos);\n    return d - r;\n}\nfloat sdDisk(vec3 pos, float ra, float rb, vec3 normal)\n{\n    normal = normalize(normal);\n    float proj = dot(pos,normal);\n    vec3 p = pos - proj*normal;\n   \tvec3 clPos = normalize(p)*rb;\n    float d;\n    if(length(clPos) > length(pos))\n        d = abs(proj);\n    else\n    \td = length(clPos - pos);\n    return d - ra; \n}\nfloat sdDisk(vec3 pos, float ra, float rb)\n{\n   \tvec3 clPos = normalize(vec3(pos.x,0.0,pos.z))*rb;\n    float d;\n    if(length(clPos.xz) > length(pos.xz))\n        d = abs(pos.y);\n    else\n    \td = length(clPos - pos);\n    return d - ra; \n}\nfloat sdPlane(vec3 pos, vec3 normal)\n{\n    return dot(pos,normal);\n}\nfloat sdSlice(vec3 pos, float radius, vec3 dir)\n{\n    vec3 tangent = normalize(dir.zyx);\n    vec3 normal = normalize(cross(dir,tangent));\n    vec3 normal0 = normalize(-(dir+tangent)/2.0);    \n    vec3 normal1 = normalize(-(dir-tangent)/2.0);\n    \n    float plane0 = sdPlane(pos, normal0);    \n    float plane1 = sdPlane(pos, normal1);\n    float disk = sdDisk(pos, 0.1,radius,normal);\n    return max(max(plane0,plane1),disk);\n}\nfloat sdShape(vec3 pos, float r,float s)\n{\n\tvec3 clPos = normalize(vec3(pos.x,0.0,pos.z))*s;\n    float d;\n    if(length(clPos.xz) > length(pos.xz))\n        d = abs(pos.y);\n    else\n    \td = length(clPos - pos);\n    return d - r;\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nfloat sdMandelbulb(vec3 pos,float size,float power, out float it) {\n    pos /= size;\n\tvec3 z = pos;\n    it = 0.;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    const float Iterations = 5.;\n    const float Bailout = 2.;\n    float Power = power;\n\tfor (float i = 0.0; i < Iterations ; i++) {\n\t\tr = length(z);\n        it++;\n        it = i / Iterations;\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n        \n        \n\t}\n\treturn size*0.5*log(r)*r/dr;\n}\n\nfloat sdGrid(vec3 p, float s, float t)\n{\n    float r = s/2.0;\n    vec3 shift = vec3(t*0.1,t*0.261,t*0.1345);\n    p = p / s;\n    float maxDist = length(vec3(s)) - s;\n    float minDist = maxDist;\n    vec3 id = floor(p);\n    vec3 coord = fract(p);    \n    float noise[8];\n \tint i = 0;\n    for(float X = -1.; X <= 1.1;X++){\n        for(float Y = -1.; Y <= 1.1; Y++){\n            for(float Z = -1.; Z <= 1.1; Z++){\n               vec3 lid = id + vec3(X,Y,Z);\n               float state =  step(0.5,clamp(smoothstep(1.0,-5.0,lid.y),0.0,1.0) *Hash31(lid+shift));\n                \n                if(state > 0.5)\n               minDist = min(minDist,sdBox(lid-p,r));\n\t\t\t\t\n                \n            }\n        }\n    }\n  return minDist;\n    \t\n}\n\nfloat MSTexture(sampler2D tex, vec2 uv, float off)\n{\n    float d,w;\n    for(float j = 0.0; j < 2.0; j++)\n    {\n        for(float i = 0.0; i < 2.0; i++)\n    \t{\n            vec2 coord = uv + vec2(i,j)*off;\n            float temp = textureLod(tex,coord ,off*500.0).y;\n           \tw = 1.-(length(vec2(i,j)) / 1.414);\n            d += temp*w;\n    \t}\n    }\n    return d/4.0;\n}\n//-----------------------------------------------//\n//--------------TRANSFORM UTILITIES--------------//\n//-----------------------------------------------//\n\nvec2 Rotate(vec2 pos, vec2 piv, float a)\n{\n    vec2 p = pos;\n    float s = sin(a);\n    float c = cos(a);   \n    \n    p = vec2(c*p.x - s*p.y,s*p.x + c*p.y);\n    return vec2(p.x,p.y);\n}\n\nvec3 RotateX(vec3 pos, vec3 piv, float a)\n{\n    pos -= piv;\n    vec2 p = Rotate(pos.yz, piv.yz, a);    \n    return vec3(pos.x,p.x,p.y) + piv;\n}\nvec3 RotateY(vec3 pos, vec3 piv, float a)\n{\n    pos -= piv;\n    vec2 p = Rotate(pos.xz, piv.xz, a);    \n    return vec3(p.x,pos.y,p.y) + piv;\n}\nvec3 RotateZ(vec3 pos, vec3 piv, float a)\n{\n    pos -= piv;\n    vec2 p = Rotate(pos.xy, piv.xy, a);    \n    return vec3(p.x,p.y,pos.z) + piv;\n}","name":"Common","description":"","type":"common"}]}