{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\n////////////////// distance field functions from https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n/////////////////\n\n\n// Utility stuff\n#define PI 3.14159\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\n    \n\nfloat toClipSpace(float f)\n{\n    return f * 2.0 - 1.0;\n}\n\n\nvec3 lookAt(vec3 from, vec3 to, vec3 dir)\n{\n    mat3 m;\n    \n    vec3 fwd = normalize(to - from);\n    vec3 _up = vec3(0.0, 1.0, 0.0);\n    vec3 r = cross(fwd, _up);\n    vec3 u = cross(r, fwd);\n    \n    m[0] = r;\n    m[1] = u;\n    m[2] = fwd;\n    vec3 d = m * dir;    \n    d.z *= -1.0;\n    return d;\n}\n\nmat3 rotation;\n\n\n// Density at any position in world\nfloat worldDensity(vec3 position)\n{\n    float m = 9999.0;\n    position = position * rotation;\n    float s = sdSphere(position, 0.1);\n    \n    vec3 offset = vec3(0.0, 0.0, iTime * 0.010);\n    \n    float n = (snoise(position , 8.0)) * 0.08;\n    n -= (snoise(position + offset, 20.0)) * 0.035;\n    n += (snoise(position, 100.0)) * 0.010;\n    \n    if (s + n < 0.0)\n    {\n        return n;\n    }\n    \n    return m;\n}\n\n\n// Ray marching parameters\nconst int STEPS = 50;\nconst float STEP = 0.005;    \nconst int STEPS_TO_SUN = 2;\n\n\n// These variables can be tweaked\nvec3 sun = vec3(0.0, 1.0, 0.0);\nconst float LIGHTNESS = 1.26;\nconst float ABSORPTION = 3.5;\nconst float INTENSITY = 1.75;\nconst float SUN_INTENSITY = 0.035;\nconst float SUN_SHARPNESS = 30.0;\n\n\nvec4 basecolor = vec4(1.5, 0.5, 0.0, 0.0);\nvec4 suncolor = vec4(1.0, 0.3, 0.0, 0.0);\nvec2 uv;\n\nbool trace(vec3 from, vec3 dir, inout vec4 color)\n{\n    \n    vec3 rp = from + dir * 0.85;\n    vec4 cloudcolor = vec4(0.0, 0.0, 0.0, 0.0);\n    bool hit = false;\n    for (int i = 0; i < STEPS; ++i)\n    {\n        rp += dir * STEP;\n        float densityAtPosition = worldDensity(rp);\n        \n        if (densityAtPosition <= 0.0 && cloudcolor.a <= 1.0)\n        {\n            // ambient color\n            float density = abs(densityAtPosition) * ABSORPTION;\n            cloudcolor.rgb += (1.0 - cloudcolor.a) * INTENSITY * pow(density, LIGHTNESS);\n            cloudcolor.a += density;\n            \n            // in scattering from sun\n            vec3 pos = rp;\n            float d = 0.0;\n            for (int j = 0; j < STEPS_TO_SUN; ++j)\n            {\n\n                pos += sun * STEP;\n                float densityAtPosition = worldDensity(pos);\n                d += abs(clamp(densityAtPosition, -1.0, 0.0)) * SUN_SHARPNESS;\n            }\n            d = 1.0 - clamp(d, 0.0, 1.0);\n            cloudcolor += suncolor * d * SUN_INTENSITY;\n            hit = true;\n        }\n        \n        if(cloudcolor.a >= 1.0)\n        {\n           break;\n        }\n    }\n    \n    cloudcolor *= cloudcolor;\n    float orange = smoothstep(0.7, 1.4, 1.3 - uv.y);\n\n    float blue = 1.0 - orange;\n    basecolor *= orange;\n    basecolor += blue * vec4(0.0, 0.0, 0.2, 0.0);\n    color = basecolor + cloudcolor;\n    return hit;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.x);\n    uv.y += (iResolution.y / iResolution.x) * 0.4;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= vec2(0.5);\n    rotation = mat3(1);\n    \n    rotation *= roty(mouse.x * 10.0);\n    rotation *= rotx(mouse.y * 10.0);\n    \n    vec3 camPos = vec3(0.0, 0.0, 1.0);    \n    vec3 lk = vec3(-toClipSpace(uv.x), -toClipSpace(uv.y), -4.0);\n    vec3 dir = lookAt(camPos, vec3(0.0), normalize(lk));\n    vec4 color = vec4(0.0);\n    \n    trace(camPos, dir,  color);\n    \n    fragColor = color;\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llj3RD","date":"1427556715","viewed":1004,"name":"Sunset Cloud","username":"kuvkar","description":"Cloud shader with sun coloring, was trying to accomplish a sunset look. Mouse to rotate cloud.","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud"],"hasliked":0,"parentid":"","parentname":""}}