{"ver":"0.1","info":{"id":"MtsXRn","date":"1434149144","viewed":412,"name":"BirthMachine","username":"dila","description":"A birth-machine for a parallel universe.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["fractal","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nvec2 map(vec3 p)\n{\n    float t = p.z;\n    p = fract(p) * 2.0 - 1.0;\n    vec3 q = p;\n    float k = 1.0;\n    float fd = 1000.0;\n    float mt = 0.0;\n    const int n = 8;\n    for (int i = 0; i < n; ++i) {  \n    \tfloat d = length(q) - 0.1;\n        if (d < fd) {\n            mt = float(i);\n            fd = d;\n        }\n        fd = min(fd, d);\n        q += -sign(q) * (length(q)-0.15);\n    }\n    mt /= float(n-1);\n    float tr = 1.0 + 0.4 * sin(t*3.0);\n    float ca = length(p.xy) - tr;\n    fd = max(fd, -ca);\n    return vec2(fd, mt);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d * 0.25;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\n\nvec3 col(float x)\n{\n\tvec3 ka = vec3(1.0, 1.0, 0.0) * 0.5;\n    vec3 kb = vec3(1.0, 0.5, 0.0) * 0.5;\n    vec3 kc = vec3(0.0, 0.0, 1.0) * 0.5;\n    vec3 ma = mix(ka, kb, x);\n    vec3 mb = mix(kb, kc, x);\n    return mix(ma, mb, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    mat3 xfm = yrot(iTime) * xrot(iTime*0.5) * zrot(iTime*0.25);\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*0.333));\n \tr *= xfm;\n    \n    vec3 o = vec3(0.5, 0.5, 0.0);\n    o.z += iTime * 0.125;\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    vec2 fd = map(w);\n    \n    float prod = max(dot(sn, -r), 0.0);\n    \n    float fog = 1.0 / (1.0 + t * t + fd.x * 100.0);\n    \n    float flmb = 0.0;\n    float fspec = 0.0;\n    float fls = 0.0;\n    \n    for (int j = -1; j <= 1; j+=2) {\n    \n        vec3 lpos = o + vec3(0.0,0.0,1.0) * float(j);\n\n        float lt = 0.0;\n        for (int i = 0; i < 16; ++i) {\n            lt += (length(o + r * lt - lpos) - 0.1) * 0.5;\n        }\n\n        float lm = 1.0;\n        if (t < lt) {\n            lm = 1.0 / (1.0 + lm * lm * 0.1);\n        }\n\n        float ls = 1.0 / (1.0 + lt * lt * 0.001);\n\n        vec3 ld = lpos - w;\n        float la = length(ld);\n        ld /= la;\n        float lmb = max(dot(ld, sn), 0.0);\n        vec3 refl = reflect(ld, sn);\n        float spec = max(dot(refl, r), 0.0);\n        spec = clamp(pow(1.0+spec, 4.0), 0.0, 1.0);\n        spec = mix(spec, 0.0, fd.y);\n        float atten = 1.0 / (1.0 + la * la * 0.01);\n        \n        flmb += lmb * atten;\n        fspec += spec * atten;\n        fls += ls * lm;\n    }\n    \n    vec3 diff = col(fd.y);\n    \n    diff = mix(diff, vec3(1.0, 1.0, 1.0), abs(sn.z));\n    \n    vec3 fc = diff * (flmb + fspec) * fog + fls;\n    \n\tfragColor = vec4(fc, 1.0);\n}","name":"","description":"","type":"image"}]}