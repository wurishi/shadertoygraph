{"ver":"0.1","info":{"id":"3lGyDz","date":"1610762138","viewed":78,"name":"Quality Check of Gradient Noise","username":"hayama","description":"Gradient noises generated by different selections of gradients (red is outlier)\nLeft: avoiding diagonal and axis-oriented direction (Perlin noise)\nCenter: diagonal direction\nRight: axis-oriented direction","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bd202101"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 fragCoord_;    //set as a uniform variable\nuint k = 0x456789abu;\nconst uint max32 = 0xffffffffu;\nvec2[8] gtable2 = vec2[](\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nvec2[4] diag = vec2[](    // 0.70710678 = 1.0 / sqrt(2.0)\n    vec2(0.70710678,0.70710678),\n    vec2(-0.70710678,0.70710678),\n    vec2(0.70710678,-0.70710678),\n    vec2(-0.70710678,-0.70710678)\n);\nvec2[4] axis = vec2[](\n    vec2(1.,0.),\n    vec2(-1.,0.),\n    vec2(0.,1.),\n    vec2(0.,-1.)\n);\n\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k;\n}\nvec2 hash22(vec2 p) {\n    uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n    n = n >>29;\n    if(fragCoord_.x < 0.33 * iResolution.x){\n        n = n % 8u;\n        return gtable2[n];\n    } else if (fragCoord_.x < 0.66 * iResolution.x){\n        n = n % 4u;\n        return diag[n];\n    } else {\n        n = n % 4u;\n        return axis[n];\n    }\n}\n\nfloat pnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 10.0;\n    pos += 2.0 * iTime;\n    vec3 col = vec3(pnoise21(pos));\n    if (col.x > 0.85 || col.x < 0.15){\n        col = vec3(1.,0.,0.);\n    } \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}