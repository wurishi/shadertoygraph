{"ver":"0.1","info":{"id":"4clGWS","date":"1703885641","viewed":71,"name":"Overlapping Volume AO","username":"aaron9000","description":"An experiment that approximates ambient occlusion using the sum of overlapping volumes.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raytracing","volume","ao","occlusion","ambientocclusion","aabb","overlapping","overlappingvolumeao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Overlapping Volume AO\n// - cast rays\n// - for each intersect, place an AABB in front of the intersection\n// - sum the volume overlap between the AABB and nearby world geometry\n// - calculate the ratio between the overlapping volume and AABB volume (high values == occluded)\n// - repeat N times with an expanding sample AABB\n// - sum results & shade pixel\n\nstruct Ray {\n    vec3 from;\n    vec3 forward;\n};\n\nstruct Intersect {\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec3 albedo;\n};\n\nstruct AABB {\n    vec3 center;\n    vec3 box_min;\n    vec3 box_max;\n    vec3 albedo;\n};\n\nconst int TILES_X = 5;\nconst int TILES_Y = 5;\nconst int TILE_COUNT = TILES_X * TILES_Y;\nconst float TILE_SIZE_XY = 15.0;\nconst float TILE_SIZE_Z = 120.0;\nconst vec3 TILE_GRID_HALF_DIMS = vec3(TILE_SIZE_XY * 0.5 * float(TILES_X), TILE_SIZE_XY * 0.5 * float(TILES_Y), 0.0);\nconst vec3 TILE_DIMS = vec3(TILE_SIZE_XY, TILE_SIZE_XY, TILE_SIZE_Z);\nconst vec3 TILE_HALF_DIMS = TILE_DIMS * 0.5;\nconst Intersect RAY_MISS = Intersect(100000000.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\n\n// https://thebookofshaders.com/11/\nfloat random(vec2 pos) {\n    return fract(sin(dot(pos, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat get_z_offset_for_tile(int tile_index){\n    float tile = float(tile_index);\n    float rate = (1.0 + random(vec2(tile * 0.98 + 0.92, tile * 0.371 + 0.123))) * 0.3;\n    float offset = random(vec2(tile * 1.34 + 0.58, tile * 0.231 + 2.45));\n    float t = (iTime * rate) + offset;\n    return float(tile_index) + sin(t) * 2.0;\n}\n\nfloat tile_overlap(vec3 box_min, vec3 box_max, int tile_x, int tile_y){\n    int tile_index = tile_y * TILES_X + tile_x;\n    float z_min = -TILE_SIZE_Z + get_z_offset_for_tile(tile_index);\n    vec3 b_min = vec3(float(tile_x) * TILE_SIZE_XY, float(tile_y) * TILE_SIZE_XY, z_min) - TILE_GRID_HALF_DIMS;\n    vec3 b_max = b_min + TILE_DIMS;\n    vec3 size_a = box_max - box_min;\n    vec3 size_b = b_max - b_min;\n    vec3 maxes = max(box_max, b_max);\n    vec3 mins = min(box_min, b_min);\n    vec3 overlap = max((size_a + size_b) - (maxes - mins), vec3(0.0));\n    return overlap.x * overlap.y * overlap.z;\n}\n\nfloat sum_tile_overlaps(AABB aabb){\n    vec3 offset_pos = aabb.center + TILE_GRID_HALF_DIMS;\n    vec3 box_min = aabb.box_min;\n    vec3 box_max = aabb.box_max;\n    int sample_x = clamp(int(offset_pos.x / TILE_SIZE_XY), 0, TILES_X);\n    int sample_y = clamp(int(offset_pos.y / TILE_SIZE_XY), 0, TILES_Y);\n    const int x_max = TILES_X - 1;\n    const int y_max = TILES_Y - 1;\n    float sum = tile_overlap(box_min, box_max, sample_x, sample_y);\n    sum += (sample_x < x_max)                     ? tile_overlap(box_min, box_max, sample_x + 1,   sample_y    ) : 0.0;\n    sum += (sample_x < x_max && sample_y < y_max) ? tile_overlap(box_min, box_max, sample_x + 1,   sample_y + 1) : 0.0;\n    sum += (sample_y < y_max)                     ? tile_overlap(box_min, box_max, sample_x,       sample_y + 1) : 0.0;\n    sum += (sample_x > 0 && sample_y < y_max)     ? tile_overlap(box_min, box_max, sample_x - 1,   sample_y + 1) : 0.0;\n    sum += (sample_x > 0)                         ? tile_overlap(box_min, box_max, sample_x - 1,   sample_y    ) : 0.0;\n    sum += (sample_x > 0 && sample_y > 0)         ? tile_overlap(box_min, box_max, sample_x - 1,   sample_y - 1) : 0.0;\n    sum += (sample_y > 0)                         ? tile_overlap(box_min, box_max, sample_x,       sample_y - 1) : 0.0;\n    sum += (sample_x < x_max && sample_y > 0)     ? tile_overlap(box_min, box_max, sample_x + 1,   sample_y - 1) : 0.0;\n    return sum;\n}\n\nfloat sample_overlapping_volume(Intersect intersect, float sample_size){\n    vec3 half_dims = vec3(sample_size) * 0.5;\n    vec3 center = intersect.pos + intersect.normal * sample_size * 0.5;\n    AABB aabb = AABB(center, center - half_dims, center + half_dims, vec3(0.0));\n    float overlapping_volume = sum_tile_overlaps(aabb);\n    float initial_volume = half_dims.x * half_dims.y * half_dims.z * 8.0;\n    return clamp(overlapping_volume / initial_volume, 0.0, 1.0);\n}\n\nfloat calculate_occlusion(Intersect intersect){\n    const int samples = 5;\n    const float size_grow_factor = 2.0;\n    const float strength_grow_factor = 1.25;\n    float sample_size = 0.5;\n    float sum = 0.0;\n    float strength = 0.20;\n    for (int i = 0; i < samples; i++){\n        sum += strength * sample_overlapping_volume(intersect, sample_size);\n        sample_size *= size_grow_factor;\n        strength *= strength_grow_factor;\n    }\n    return clamp(sum, 0.0, 1.0);\n}\n\nIntersect ray_aabb_intersect(Ray ray, AABB aabb){\n    vec3 t_min = (aabb.box_min - ray.from) / ray.forward;\n    vec3 t_max = (aabb.box_max - ray.from) / ray.forward;\n    vec3 t1 = min(t_min, t_max);\n    vec3 t2 = max(t_min, t_max);\n    float t_near = max(max(t1.x, t1.y), t1.z);\n    float t_far = min(min(t2.x, t2.y), t2.z);\n    if (t_near > t_far || t_far < 0.0){\n        return RAY_MISS;\n    }else{\n        vec3 pos = ray.from + (t_near * ray.forward);\n        vec3 delta_center = aabb.center - pos;\n        vec3 mag = abs(delta_center / TILE_HALF_DIMS);\n        vec3 normal = (mag.x > mag.y && mag.x > mag.z) ? \n                        vec3(-sign(delta_center.x), 0.0, 0.0) :\n                            (mag.y > mag.x && mag.y > mag.z) ? \n                            vec3(0.0, -sign(delta_center.y), 0.0) : \n                            vec3(0.0, 0.0, -sign(delta_center.z));\n\n        return Intersect(t_near, pos, normal, aabb.albedo);\n    }\n}\n\nIntersect intersect_tile(Ray ray, int tile_index){\n    float z_offset = get_z_offset_for_tile(tile_index);\n    vec3 offset = TILE_GRID_HALF_DIMS - vec3(TILE_HALF_DIMS.x, TILE_HALF_DIMS.y, z_offset - TILE_SIZE_Z * 0.5);\n    int tile_x = tile_index % TILES_X; \n    int tile_y = tile_index / TILES_X;\n    vec3 center = vec3(\n        float(tile_x) * TILE_SIZE_XY, \n        float(tile_y) * TILE_SIZE_XY, \n        0.0\n    ) - offset;\n    vec3 box_min = center - TILE_HALF_DIMS;\n    vec3 box_max = center + TILE_HALF_DIMS;\n    const int color_count = 5;\n    const vec3[color_count] colors = vec3[color_count](\n        vec3(220.0 / 255.0, 238.0 / 255.0, 209.0 / 255.0),\n        vec3(170.0 / 255.0, 191.0 / 255.0, 170.0 / 255.0),\n        vec3(115.0 / 255.0, 99.0 / 255.0, 114.0 / 255.0),\n        vec3(161.0 / 255.0, 130.0 / 255.0, 118.0 / 255.0),\n        vec3(122.0 / 255.0, 145.0 / 255.0, 141.0 / 255.0)\n    );\n    AABB box = AABB(center, box_min, box_max, colors[(tile_y + tile_x) % color_count]);\n    return ray_aabb_intersect(ray, box);\n}\n\nIntersect intersect_tiles(Ray ray){\n    Intersect closest_intersect = RAY_MISS; \n    for (int i = 0; i < TILE_COUNT; i++){\n        Intersect intersect = intersect_tile(ray, i);\n        if (intersect.dist < closest_intersect.dist){\n            closest_intersect = intersect;\n        }\n    }\n    return closest_intersect;\n}\n\nvec3 get_light_dir(){\n    float t = iTime * 0.25;\n    return normalize(vec3(sin(t), cos(t), -0.75));\n}\n\nvec3 get_tile_fragment(Ray ray, Intersect intersect){\n    float directional = 1.0 - ((dot(intersect.normal, get_light_dir()) + 1.0) * 0.5);\n    float ambient = 0.2;\n    float occlusion = calculate_occlusion(intersect);\n    return (intersect.albedo * (directional + ambient)) * (1.0 - occlusion);\n}\n\nvec3 get_bg_fragment(Ray ray, Intersect intersect){\n    float light_value = 1.0 - (0.5 * (dot(get_light_dir(), ray.forward) + 1.0));\n    return vec3(light_value * 0.5 + 0.25);\n}\n\nRay get_camera_ray(vec2 fragCoord){\n    vec3 camera_pos = vec3(-70.0, -51.0, 45.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 fwd = normalize(vec3(1.0, 0.8, -0.75));\n    vec3 left = cross(fwd, vec3(0.0, 0.0, 1.0));\n    vec3 up = cross(left, fwd);\n    mat3 rot = mat3(left, fwd, up);\n    vec3 ray_fwd = rot * normalize(vec3((uv.x - 0.5) * aspect_ratio, 1.0, (uv.y - 0.5)));\n    return Ray(camera_pos, ray_fwd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    Ray ray = get_camera_ray(fragCoord);\n    Intersect intersect = intersect_tiles(ray);\n    vec3 color = intersect == RAY_MISS ? get_bg_fragment(ray, intersect) : get_tile_fragment(ray, intersect);\n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}