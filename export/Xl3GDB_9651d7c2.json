{"ver":"0.1","info":{"id":"Xl3GDB","date":"1471154911","viewed":119,"name":"SDF mixed spheres","username":"tiusic","description":"Trying to understand how the mix function affects an SDF.\nCopied a bunch of code from https://www.shadertoy.com/view/XdKGWd","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\n\nfloat dBlendedSpheres(vec3 p, vec3 c0, float r0, vec3 c1, float r1, float b) {\n    return mix(length(p - c0) - r0, length(p - c1) - r1, b);\n}\n\nvoid test(inout vec2 distMat, float newDist, int newMat) {\n    if (newDist < distMat.x) {\n        distMat = vec2(newDist, float(newMat));\n    }\n}\n\nfloat d(vec3 p) {\n    bool first = true;\n    float mindd;\n    float tt = 3.0 * sin(0.1 * iTime);\n    for (float i = 0.0; i <= 1.01; i += 0.05) {\n        float dd = dBlendedSpheres(p, vec3(20.0 * i, 10, tt), 1.0, vec3(20.0 * i, 10, -tt), 1.0, i);\n        if (first || dd < mindd) {\n            mindd = dd;\n        }\n        first = false;\n    }\n    return mindd;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy) - d(pos-eps.xyy),\n\t    d(pos+eps.yxy) - d(pos-eps.yxy),\n\t    d(pos+eps.yyx) - d(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 1000.\n\nvoid IntersectScene(vec3 origin, vec3 direction) {\n    float t = 0.;\n    for (int ii = 0; ii < MAX_STEPS; ++ii) {\n        vec3 pos = origin + direction * t;\n        float dd = d(pos);\n        if (dd < MARCH_EPSILON) {\n            if (t < MAX_T) {\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n                intersectionT = t;\n            }\n            break;\n        }\n        t += dd;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\tvec3 origin = vec3(10.0, -7.0, 0.0);\n\tvec3 direction = vec3(uv.x, 1, uv.y);\n\tdirection.xz *= .8;\n\tdirection = normalize(direction);\n\tvec3 color = vec3(0);\n    intersectionT = 1e37;\n    IntersectScene(origin, direction);\n    if (intersectionT < MAX_T) {\n        float lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n        if (lightDot > 0.0) {\n        \tcolor = mix(vec3(0, 0, 1), vec3(0, 1, 0), lightDot);\n        } else {\n        \tcolor = mix(vec3(0, 0, 1), vec3(1, 0, 0), -lightDot);\n        }\n    }\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}