{"ver":"0.1","info":{"id":"4tSGDd","date":"1433453847","viewed":300,"name":"Look At","username":"cabbibo","description":"Trying to understand rotations","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n#define time iTime\n\nconst float INTERSECTION_PRECISION = .01;\nconst float MAX_TRACE_DISTANCE     = 10.;\nconst int NUM_TRACE_STEPS          = 100;\n\nconst vec3 lightPos = vec3( 3. , 0.  , 0. );\n\nvec3 lookPos;\n\n\nfloat smin_2_3(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n\nvoid doCamera( out vec3 camPos , out vec3 camTar , in float time ){\n\n  camPos = vec3( 0. , 0. , 2.5 );\n  camTar = vec3( 0. );\n\n}\n\nmat3 calcLookAtMatrix( vec3 camPos , vec3 camTar , float roll ){\n\n  vec3 up = vec3( sin( roll ) ,cos( roll ) , 0. );\n  vec3 ww = normalize( camTar - camPos );\n  vec3 uu = normalize( cross( ww , up ) );\n  vec3 vv = cross( uu , ww ); // already normalized\n\n  return mat3( uu , vv , ww );\n\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xy), -p.z );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nmat3 matInverse( mat3 m ){\n    \n  \n    vec3 a = vec3(\n      \n        m[1][1] * m[2][2] - m[2][1] * m[1][2],\n        m[0][2] * m[2][1] - m[2][2] * m[0][1],\n        m[0][1] * m[1][2] - m[1][1] * m[0][2]\n        \n    );\n    \n    vec3 b = vec3(\n      \n        m[1][2] * m[2][0] - m[2][2] * m[1][0],\n        m[0][0] * m[2][2] - m[2][0] * m[0][2],\n        m[0][2] * m[1][0] - m[1][2] * m[0][0]\n        \n    );\n    \n     vec3 c = vec3(\n      \n        m[1][0] * m[2][1] - m[2][0] * m[1][1],\n        m[0][1] * m[2][0] - m[2][1] * m[0][0],\n        m[0][0] * m[1][1] - m[1][0] * m[0][1]\n        \n    );\n    \n    \n    return mat3( \n        \n       a.x , a.y , a.z ,\n       b.x , b.y , b.z ,\n       c.x , c.y , c.z\n        \n    );\n    \n \n  \n    \n}\n\nfloat lookAtCone( vec3 p , vec3 pos   , vec3 lookP , vec3 c ){\n    \n    mat3 rot = calcLookAtMatrix( p , lookPos , 0. );\n    rot = matInverse( rot );\n    //vec2 res2 = vec2(udBox( rot * (pos - p) , vec3( .01 , .01 , .2 )  ) , float( i ) ); \n         \n    float v = sdCappedCone( rot * ( pos - p ) ,c  ); \n\treturn v;\n    \n    \n}\n\nvec2 map( vec3 pos ){\n\n\n  vec2 res = vec2( sdSphere( pos - lookPos , .1 ) ,1. );\n\n  float fRes = res.x;\n  for( int i = 0; i < 10; i ++ ){\n   \n    vec3 p  = vec3( \n      .8 * sin( ( float( i +1)+ time * .01 ) * 2. ) ,\n      .8 * sin( ( float( i +1)+ time * .01 ) * 5. ) ,\n      .8 * sin( ( float( i +1)+ time * .01 ) * 9. ) \n    );   \n\n         \n    vec2 res2 = vec2( lookAtCone(p , pos , lookPos ,  vec3( .1 , .02  , .3 ) ) , float( i ) ); \n\n\n    res = opU( res , res2 );\n\n  }  \n\n  return res;\n\n\n\n}\n\n\n// res = result;\nvec2 calcIntersection( in vec3 ro , in vec3 rd ){\n\n  float h     = INTERSECTION_PRECISION * 2.;\n  float t     = 0.;\n  float res   = -1.;\n  float id    = -1.;\n\n  for( int i = 0; i < NUM_TRACE_STEPS; i++ ){\n      \n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    \n    vec2 m = map( ro + rd * t );\n  \n    h  = m.x;\n    t += h;\n    id = m.y;\n\n  }\n\n  if( t < MAX_TRACE_DISTANCE ) res = t;\n  if( t > MAX_TRACE_DISTANCE ) id = -1.;\n\n  return vec2( res , id ); \n\n}\n\nvec3 calcNormal( vec3 pos ){\n\n  vec3 eps = vec3( 0.01 , 0. , 0. );\n  \n  vec3 nor = vec3(  \n    map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n    map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n    map( pos + eps.yyx ).x - map( pos - eps.yyx ).x\n  );\n\n  return normalize( nor );\n  \n\n}\n\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord){\n\n  vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n  \n  // Getting mouse position!\n  vec2 m =  ( -iResolution.xy + 2.0 * iMouse.xy ) / iResolution.y;;\n    \n  vec3 ro , ta;\n  \n  doCamera( ro , ta , time  );\n\n  mat3 camMat = calcLookAtMatrix( ro , ta , 0. ); \n \n  // z = lens length \n  vec3 rd = normalize( camMat * vec3( p.xy , 2. ) ); \n    \n  // Getting our mouse ray direction\n  vec3 md = normalize( camMat * vec3( m.xy , 2. ) ); \n    \n  lookPos = ro + md * 3.;\n \n  vec2 res = calcIntersection( ro , rd );\n  vec3 col = vec3( 0. );\n\n  if( res.x > 0. ){\n\n    vec3 pos = ro + rd * res.x;\n\n    vec3 lightDir = normalize( pos - lightPos );\n    vec3 nor = calcNormal( pos );\n\n    float lightMatch = max( 0. , dot( nor , lightDir ) );\n\n    vec3 refl = reflect( lightDir , nor );\n    float reflMatch = max( 0. , dot( refl , rd ) );\n\n    float rimMatch =  1. - max( 0. , dot( nor , -rd ) );\n\n\n    vec3 norCol = (nor * .5 + .5);\n\n    vec3 lambCol = ((nor * .5 + .5)* lightMatch);\n    vec3 ambiCol = ( vec3( 1. ) -norCol )*.1;\n    vec3 specCol = vec3( 1. , .8 , 0. ) * pow( reflMatch , 20. );\n    vec3 rimCol  = vec3( .4 , 1. , .8 ) * pow( rimMatch, 4. );\n    \n    col = lambCol + ambiCol + specCol + rimCol;\n\n  }\n\n  fragColor = vec4( col , 1. );\n\n}","name":"","description":"","type":"image"}]}