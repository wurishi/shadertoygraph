{"ver":"0.1","info":{"id":"McccRN","date":"1730313783","viewed":76,"name":"Medial Axis","username":"bradphelan","description":"A first attempt at shading a medial axis. Currently it's just inner voronoi.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","medialaxis"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T(x,y) texelFetch(iChannel0, ivec2( fragCoord + vec2(x,y)), 0)\n\nbool isConvex(int i, int j)\n{\n    return i!=-1&&j!=-1;\n}\n\nbool isMedialPoint(vec2 fragCoord, vec2 points[N]) {\n    int i0 = int(T(0,0)[0]);\n    int i1 = int(T(0,0)[1]);\n    \n    if(i0==-1&&i1==-1)\n       return false; \n       \n\n       \n    // Only convex inside corners\n    // generate cells where both are set\n    // so we can remove these cells \n    //  if(i0!=-1&&i1!=-1)\n    //    return false;\n\n    int n=0;\n    int l=3; // Width of neighbour search ( makes thicker medial lines )\n    for (int x = -l; x <= l; x++) {\n        for (int y = -l; y <= l; y++) {\n            if(x==0 && y==0) continue;\n            vec4 t = T(x,y);\n            int j0 = int(t[0]);\n            int j1 = int(t[1]);\n            if(j0==-1&&j1==-1)\n               return false;\n               \n            if(isConvex(i0,i1))\n            {\n               if(i0==j0&&i1!=j1)\n                  return false;\n                  \n               if(i1==j0)\n                   return false;                  \n\n            }else if(isConvex(j0,j1)){\n               if(i0==j0&&i1!=j1)\n                  return false;\n               if(i0==j1)\n                  return false;\n   \n            }\n            \n\n       \n            if (i0!=j0||i1!=j1){\n               n++;\n            }\n       \n        }\n    }\n    return n>0 ;\n}\n\n// Image: Read the distance field from Buffer A and identify the 0.0 isoline25\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float time = iTime;\n\n    vec2 points[N];\n    for (int i = 0; i < N; i++) {\n        points[i] = getPoint(i, time);\n    }\n     \n    bool d = isMedialPoint(fragCoord, points);\n\n    vec3 medialColor = mix(hashcolor(int(T(0,0)[0])),hashcolor(int(T(0,0)[1])), 0.5);\n    \n    fragColor = vec4(d ? medialColor: vec3(1) , 1);\n    \n    float dist = smoothstep(0., 0.01,T(0,0)[2]);\n    \n    vec4 distColor = vec4(vec3(dist,dist,dist), 1);\n    \n    fragColor = distColor * fragColor;\n\n    if(iMouse.z > 0.)\n    {\n        fragColor = vec4(medialColor,1);\n    }\n    \n   \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// Returns the (j,k) where j and k are the index of\n// the two closest segments. If there is only one closest\n// segment then k is -1\nvec3 medialDistanceField(vec2 p, vec2 points[N]) {\n\n    float mindist = 1e6;\n    int j;\n    int k;\n    for (int i = 0; i < N; i++) {\n        vec2 a = points[i];\n        vec2 b = points[(i+1)%N];\n        vec2 d = sdLine(p, a, b);\n        float dist = d[0];\n        if(abs(dist)<abs(mindist)){\n           mindist = dist;\n           if(d[1]==0.){\n             j = i == 0 ? N - 1 : i - 1;\n             k = i;\n           }else if(d[1]==1.){\n             j = i;\n             k = (i + 1) % N;\n           }else{\n             j = i;\n             k = -1;\n           }\n        }\n \n    }\n    \n    return vec3(j,k,mindist);\n}\n\nbool isLeftOfLine(vec2 a, vec2 b, vec2 p) {\n    // Compute the cross product of (b - a) and (p - a) using cross2D\n    return cross2D(b - a, p - a) > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime;\n\n    vec2 points[N];\n    for (int i = 0; i < N; i++) {\n        points[i] = getPoint(i, time);\n    }\n\n    vec3 f = medialDistanceField(uv, points);\n    int k = int(f[0]); // index of first closest segment\n    int l = int(f[1]); // index of second closest segment\n    float d = f[2]; // distance\n\n   \n    if(l==-1||k==-1){\n        // The pixel is closest to only one segment so\n        // we only have to check\n        vec2 a = points[k];\n        vec2 b = points[(k+1)%N];\n        if(!isLeftOfLine(a,b,uv)){ // This should do the inside polygon test but is unstable\n           k=-1; \n           l=-1;\n           \n        }\n           \n    }else{\n        // for points that are close to a vertex \n        // ie they share two segments we need to find\n        // if they are to the right or left of the combinded\n        // segments. This can be done by checking if\n        // the point is to the right of a line tangent\n        // to the vertex\n        vec2 a = points[k];\n        vec2 b = points[l];\n        vec2 c = points[(l+1)%N];\n        vec2 ab = normalize(b-a);\n        vec2 bc = normalize(c-b);\n        vec2 avg = ab + bc;\n        if(!isLeftOfLine(b,b+avg,uv)){     \n          k=-1;\n          l=-1;\n        }\n    }\n    \n    \n    \n    float c = abs(d)<0.05 ? 0. : 1.0;\n\n    vec3 colorj = vec3(k, l, d);\n    \n    fragColor = vec4(colorj, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Number of vertices in the polygon\n#define N 16\n\n// Frequency and amplitude of wobble\n#define WOBBLE_FREQ 0.6\n#define WOBBLE_AMP 0.1\n\n// Thresholds for medial axis rendering\n#define MEDIAL_AXIS_THRESHOLD 0.07\n#define DISTANCE_THRESHOLD 0.005\n\n// Function to create a point with wobble\nvec2 getPoint(int i, float time) {\n    float angle = float(i) * 2.0 * 3.14159 / float(N);\n    float radius = 0.35 + WOBBLE_AMP * sin(WOBBLE_FREQ * time + float(i));\n    return vec2(3.*cos(0.999*angle), 2.*sin(1.001*angle)) * radius;\n}\n\n// Signed distance to a line segment\nvec2 sdLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return vec2(length(pa - ba * h),h);\n}\n\n// 2D cross product (determinant)\nfloat cross2D(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nvec3 hashcolor( int p )\n{ \n    if(p==-1)\n       return vec3(1.,1.,1.);\n    vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n   \n}","name":"Common","description":"","type":"common"}]}