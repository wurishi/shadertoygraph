{"ver":"0.1","info":{"id":"Dst3D2","date":"1677861000","viewed":74,"name":"Hue Shifted Offset Circle Rings","username":"WhileRomeBurns","description":"Click to change to hue mode.\n\nDraws hue shifted sine waves from offset center to circle boundary. Simpler example: https://www.shadertoy.com/view/csdGD2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","circle","ring","distance","hsv","hue","shift"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Color transforms and values from:\n// https://www.shadertoy.com/view/lscGDr\n#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))\n#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))\n#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)\n\nconst vec3 COLOR0 = SRGB(255, 0, 114);\nconst vec3 COLOR1 = SRGB(197, 255, 80);\n\n// Smooth HSV to RGB conversion from:\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat parameterizeCircle01(vec2 center, vec2 uv, float radius)\n{\n    // uv is our shading point\n    // center is the offset center point inside the bounding circle\n    // radius is the radius of the bounding circle centered at (0,0)\n\n    vec2 to = uv - center;\n    vec2 rd = normalize(to); // ray direction\n    vec2 ro = uv;            // ray origin\n    \n    // https://www.shadertoy.com/view/wlcfW7\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        float t1 =  (root - b) / denom; // 1st root (intersection distance)\n        // don't need the second intersection in our case\n        // float t2 = -(root + b) / denom; // 2nd root (intersection distance)\n        \n        float distToCenter = length(to);\n        float spokeLength = t1 + distToCenter;\n\n        return min(distToCenter / spokeLength, 1.0);\n    }\n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.5;\n    vec2 center = vec2(cos(iTime*0.6), sin(iTime*0.3))*0.3;\n    float freq = iMouse.z>0.0 ? 22.0 : 44.0; // half freq if mouse down\n\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    \n    // center uv space so (0,0) is in the middle of our canvas\n    uv = (uv - vec2(0.5, 0.5/aspect)) * 2.0;\n    \n    // distance to bounding circle at (0,0)\n    float d = sdCircle(uv, radius);\n    \n\t// coloring bounding circle and outline\n    vec3 col = (d>0.0) ? vec3(0.05,0.05,0.05) : vec3(1,1,1);\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.0,0.0075,abs(d)) );\n\n    // draw center point\n    float d2 = sdCircle(center-uv, 0.02);\n    col = mix( col, vec3(0.0,1.0,0.94), 1.0-smoothstep(0.0, 0.001, d2) );\n    \n    // generate 0-1 value sine waves\n    float circle01 = parameterizeCircle01(center, uv, radius);\n    float wave = sin(freq*circle01);\n    wave = clamp(wave*0.5+0.5, 0.0, 1.0);\n    \n    // map waves to gradient\n    vec3 waveCol = mix(COLOR0, COLOR1, wave);\n    \n    // if mouse button is down, rotate through hsv instead\n    if( iMouse.z>0.0 ) \n        waveCol = hsv2rgb_smooth(vec3(wave, 0.98, 0.75));\n\n    // mix waves in circle with background\n    col = mix(waveCol, col, smoothstep(0.98, 1.0, circle01));\n\n    // Convert color from linear to sRGB color space (=gamma encode).\n    col = LINEAR_TO_SRGB(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}