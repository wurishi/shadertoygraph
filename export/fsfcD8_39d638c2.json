{"ver":"0.1","info":{"id":"fsfcD8","date":"1642007275","viewed":66,"name":"Raymarching fly test","username":"OdemTut","description":"Just some testing","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Surface Normal computation. Visualized in world space.\n// Taken from Ray Marching for Dummies\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n// scene description\nconst vec3 CAMERA_POSITION = vec3(0,1,0);\nconst vec3 SPHERE_POSITION = vec3(0, 0, 6);\nconst vec3 SPHERE_POSITION2Start = vec3(4, 0.4, 7);\nconst vec3 SPHERE_POSITION2End = vec3(-2, 2.5, 5.5);\nconst vec3 SPHERE_COLOR = vec3(1., 0., 0.);\nconst vec3 SPHERE_COLOR2 = vec3(0., 1., 0.);\n\nconst float SPHERE_RADIUS = 1.;\nconst float SPHERE_RADIUS2 = 1.;\nconst float PLANE_POSITION_Y = 0.;\nconst float sminFactor = 1.;\nvec3 SpherePosition2 = vec3(0, 2.5, 6);\nconst vec3 sunDirection = vec3(0.3, 0.4, -0.24);\nconst vec3 ambientColor = vec3(145. / 255., 180. / 255., 255. / 255.);\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\nfloat sat(float color)\n{\n    return clamp(color, 0., 1.);\n}\n\n// GetDistanceNearestSurface is hard coded for our scene, which is comprised\n// of a plane and a sphere.\n// The plane is axis aligned with the camera and below the camera.\nfloat GetDistanceToNearestSurface(vec3 point)\n{\n    float distanceToSphere = length(point-SPHERE_POSITION)-SPHERE_RADIUS;\n    float distanceToSphere2 = length(point-SpherePosition2)-SPHERE_RADIUS2;\n    float distanceToCombinedSpheres = smin(distanceToSphere, distanceToSphere2, sminFactor);\n    float distanceToPlane = point.y - PLANE_POSITION_Y;\n    float distanceToNearestSurface = min(distanceToCombinedSpheres, distanceToPlane);\n    return distanceToNearestSurface;\n}\n\nconst int MAX_STEPS = 50;\nconst float MAX_DIST = 100.;\nconst float SURFACE_DIST = 0.1;\n\n// Ray Marching using a Sphere Trace algorithm.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceFromOrigin = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayOrigin + distanceFromOrigin * rayDirection;\n        float distanceToScene = GetDistanceToNearestSurface(p);\n        distanceFromOrigin += distanceToScene;\n        bool foundSurface = distanceToScene < SURFACE_DIST;\n        bool exceededMax = distanceFromOrigin > MAX_DIST;\n        if (foundSurface || exceededMax)\n            break;\n    }\n    return distanceFromOrigin;\n}\n// Ray Marching using a Sphere Trace algorithm.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection, out float minDist)\n{\n    float distanceFromOrigin = 0.;\n    minDist = 1000.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayOrigin + distanceFromOrigin * rayDirection;\n        float distanceToScene = GetDistanceToNearestSurface(p);\n        distanceFromOrigin += distanceToScene;\n        bool foundSurface = distanceToScene < SURFACE_DIST;\n        bool exceededMax = distanceFromOrigin > MAX_DIST;\n        minDist = distanceToScene < minDist ? distanceToScene : minDist;\n        if (foundSurface || exceededMax)\n            break;\n    }\n    \n    return distanceFromOrigin;\n}\n\n// Get the normal of the surface at point p.\n// For more information to see how this works, see:\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetSurfaceNormal(vec3 p)\n{\n    float d0 = GetDistanceToNearestSurface(p);\n    const vec2 epsilon = vec2(.0001,0);\n    vec3 d1 = vec3(\n        GetDistanceToNearestSurface(p-epsilon.xyy),\n        GetDistanceToNearestSurface(p-epsilon.yxy),\n        GetDistanceToNearestSurface(p-epsilon.yyx));\n    return normalize(d0 - d1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv is the fragCoord with (0,0) in the center of the screen.\n    // The division by minres uses the same scaling on both\n    // axis to avoid distortion. The min is not strictly necessary in\n    // ShaderToy, since the aspect ratio is such that the min\n    // is always iResolution.y.\n    float minres = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - .5*iResolution.xy) / minres;\n    \n    // Camera Model\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Flip through xyz, x, y, and z visualizations.\n    const float CYCLE_SPEED_HZ = 1.;\n    float v = mod(CYCLE_SPEED_HZ* iTime, 4.) / 4.;\n    \n    SpherePosition2 = lerp(SPHERE_POSITION2Start, SPHERE_POSITION2End, (sin(iTime) + 1.)/2.);\n    \n    \n    // Compute Distance\n    vec3 rayOrigin = CAMERA_POSITION;\n    float distanceToSurface = RayMarch(rayOrigin, rayDirection);\n    \n    // Get the surface normal of the point.\n    vec3 pointOnSurface = rayOrigin + rayDirection * distanceToSurface;\n    vec3 surfaceNormal = GetSurfaceNormal(pointOnSurface);\n    \n    // Visualize surfaceNormal. surfaceNormal can point in any direction\n    // but has length one. Map the values from [(-1,-1,-1), (1,1,1)] to\n    // [(0,0,0), (1,1,1)].\n    vec3 visualized = (1. + surfaceNormal) / 2.;\n    \n    \n    vec3 shadowOrigin = pointOnSurface;\n    float MinDistance;\n    float shadow = RayMarch(shadowOrigin + sunDirection * 1.1, sunDirection, MinDistance) > 99. ? 1. : 0.;//sat(MinDistance * 1.)\n    \n    fragColor = vec4((sat(dot(sunDirection, surfaceNormal) * 2.) * shadow + ambientColor * 0.3) * 0.5, 1);\n}\n","name":"Image","description":"","type":"image"}]}