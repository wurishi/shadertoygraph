{"ver":"0.1","info":{"id":"clSSRR","date":"1675552903","viewed":114,"name":"Ring of Lavas","username":"patrickhartono","description":"Ring of Fire","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ringoffire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize two colors, colA and colB\n    vec4 colA = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 colB = vec4(2.0, 1.5, 0.8, 1.0);\n\n    // Calculate the initial UV coordinate from the fragment coordinate\n    vec2 uv0 = ((fragCoord.xy - iResolution.xy * .5) / iResolution.y) * 2.0;\n\n    // Calculate the angle of rotation based on the global iTime value\n    float angle = 0.79 + iTime * 0.5;\n\n    // Create the rotation matrix using the sin and cos functions\n    mat2 rot = mat2(\n        sin(angle), -cos(angle),\n        cos(angle), sin(angle)\n    );\n\n    // Rotate the UV coordinate using the rotation matrix\n    vec2 uv1 = uv0 * rot;\n    vec2 uv2 = rot * uv0;\n\n    // Calculate the amount of enlargement based on the iTime value\n    vec3 enlarge = 2. - fract(vec3(0., 0.333, 0.667) + iTime*0.5);\n\n    // Calculate the radial distance of the UV coordinate\n    //float r = dot(uv0,uv0);\n    float time = iTime * 0.3; // adjust the speed as desired\n    float size = 0.1; // adjust the size as desired\n    float r = dot(uv0, uv0) + size * sin(time);\n\n    // Apply a deformation to the UV coordinate\n    float p = (pow(r, 3.) + 0.3);\n    uv0 *= p;\n    uv1 *= p;\n    uv2 *= p;\n\n    // Sample the fire texture using the transformed UV coordinates\n    float fire = dot(vec3(\n        texture(iChannel0, uv0 * enlarge.x).x,\n        texture(iChannel0, uv1 * enlarge.y).y,\n        texture(iChannel0, uv2 * enlarge.z).z\n    ), smoothstep(vec3(0.5), vec3(0.0), abs(fract(enlarge)-0.5)));\n\n    // If the radial distance is less than a threshold, set the fragColor to black\n    if (r < 0.1)\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else\n        // Mix the two colors using the fire texture and apply a final adjustment\n        fragColor = mix(colA, colB, fire) - r*r * 1.75;\n}\n\n/*\nHere is a detailed explanation of each line:\n\nvec4 colA = vec4(1.0, 0.0, 0.0, 1.0); Initializes the color colA to a red color (RGBA: (1.0, 0.0, 0.0, 1.0))\n\nvec4 colB = vec4(2.0, 1.5, 0.8, 1.0); Initializes the color colB to a yellow-ish color (RGBA: (2.0, 1.5, 0.8, 1.0))\n\nvec2 uv0 = ((fragCoord.xy - iResolution.xy * .5) / iResolution.y) * 2.0; Calculates the initial UV coordinate from the fragment coordinate. UV coordinates are used to map a 2D image to a 3D surface.\n\nfloat angle = 0.79 + iTime * 0.5; Calculates the angle of rotation based on the global iTime value.\n\nmat2 rot = mat2(sin(angle), -cos(angle), cos(angle), sin(angle)); Creates the rotation matrix using the sin and cos functions.\n\nvec2 uv1 = uv0 * rot; Rotates the UV coordinate uv0 using the rotation matrix rot. The result is stored in uv1.\n\nvec2 uv2 = rot * uv0; Rotates the UV coordinate uv0 using the rotation matrix rot. The result is stored in uv2.\n\nvec3 enlarge = 2. - fract(vec3(0., 0.333, 0.667) + iTime*0.5); Calculates the amount of enlargement based on the iTime value.\n\nfloat r = dot(uv0,uv0); Calculates the radial distance of the UV coordinate uv0.\n\nfloat p = (pow(r, 3.) + 0.3); Calculates a value p that will be used to apply a deformation to the UV coordinate.\n\nuv0 *= p; Deforms the UV coordinate uv0 by scaling it with p.\n\nuv1 *= p; Deforms the UV coordinate uv1 by scaling it with p.\n\nuv2 *= p; Deforms the UV coordinate uv2 by scaling it with p.\n\nfloat fire = dot(vec3(texture(iChannel0, uv0 * enlarge.x).x, texture(iChannel0, uv1 * enlarge.y).y, texture(iChannel0, uv2 * enlarge.z).z), smoothstep(vec3(0.5), vec3(0.0), abs(fract(enlarge)-0.5))); Samples the fire texture using the transformed UV coordinates. iChannel0 is a texture input to the shader.\n\n`if (r < 0.1) fragColor = vec4(\n\n*/\n\n\n\n","name":"Image","description":"","type":"image"}]}