{"ver":"0.1","info":{"id":"ds2GWK","date":"1668260463","viewed":90,"name":"Curvature Plotter (Parametric)","username":"Envy24","description":"Template for plotting circles of curvature for parametric functions.\nRedefine x(t), y(t), scene_scale, and t0.\nTry points t0 = 3.1366 and t0 = 2.08937 with cardioid.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["template","plotter","parametric","graphs","curvaturetangent"],"hasliked":0,"parentid":"Dd23Ww","parentname":"Tangent Plotter (Parametric)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Curve defined as parametric(t) = (x(t), y(t))     - redefine.\n    First derivative parametric is parametric_dydx(t) - redefine of use numeric (see function body).\n    First derivative of parametric_dydx is deriv(t)   - redefine of use numeric (see mainImage body).\n    Recompile.\n    \n    \n    Some interpretation:\n         p(t) = [x(t), y(t)] - parametric curve \n                       dy/dt - change of y(t) with respect to t\n                       dx/dt - change of x(t) with respect to t\n         dy/dx = (dy/dt) / (dx/dt) =\n               = (dy/dt) * (dt/dx)\n                             - change of y(t) with respect to x(t).     \n*/\n#define R                           iResolution\n#define AR                        (  R.x / R.y  )\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define SCENE_SCALE               ( 3.0 )\n#define UNIT                      ( 3.*SCENE_SCALE / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n\n//float x(float t) { return t - sin(t); }\n//float y(float t) { return 1. - cos(t); }\n#define A ( 1. )\nfloat x(float t) { return 2.*A*cos(t)-A*cos(2.*t); }\nfloat y(float t) { return 2.*A*sin(t)-A*sin(2.*t); }\n//float x(float t) { return sin(t)*t-cos(t*2.); }\n//float y(float t) { return cos(t)*t-sin(t); }\n//float x(float t) { return t; }\n//float y(float t) { return sin(t); }\nvec2 parametric(float t) { return vec2(x(t), y(t)); }\nfloat dxdt(float t) \n{    \n    return (x(t+0.01) - x(t)) * 100.; // Numeric derivative.    \n    //return 1. - cos(t);               // Analytic derivative.\n}\nfloat dydt(float t) \n{     \n    return (y(t+0.01) - y(t)) * 100.; // Numeric derivative. \n    //return sin(t);                    // Analytic derivative.\n}\nvec2 tangent(float t)\n{   \n    return (parametric(t+0.01) - parametric(t)) * 100.; // Numeric derivative.  \n    //return vec2(dxdt(t), dydt(t));                  // Analytic derivative.\n}\nvec2 gradient(float t) { return tangent(t); }\nvec2 normal(float t) { vec2 T = tangent(t); return vec2(-T.y, T.x);  }\nfloat parametric_dydx(float t) { vec2 T = tangent(t); return T.y/T.x; }\nfloat parametric_dxdy(float t) { vec2 T = tangent(t); return T.x/T.y; }\nfloat parametric_d_dydx_dt(float t)\n{ \n    // d_dydx_dt = [d(dy/dx)]/dt          - not second derivative of parametric!\n    //   ddydxx = ([d(dy/dx)]/dt)/(dx/dt) - second derivative.\n        \n    return ( parametric_dydx(t+0.01) - parametric_dydx(t) ) * 100.; // Numeric derivative.    \n    //return 0.; // Analytic derivative.\n}\nfloat parametric_d_dxdy_dt(float t)\n{ \n    return ( parametric_dxdy(t+0.01) - parametric_dxdy(t) ) * 100.; // Numeric derivative.    \n    //return 0.; // Analytic derivative.\n}\nfloat parametric_ddydxx(float t) { return parametric_d_dydx_dt(t) / dxdt(t); }\nfloat parametric_ddxdyy(float t) { return parametric_d_dxdy_dt(t) / dydt(t); }\n\nvec2 curvature_a(float t)\n{\n    float a = parametric_dydx(t), b = 1. + a*a,\n          K = parametric_ddydxx(t)/sqrt(b*b*b),\n          ROC = 1./K; // radius of curvature \n\n    return vec2(K, ROC);\n}\nvec2 curvature_b(float t)\n{\n    float a = parametric_dxdy(t), b = 1. + a*a,\n          K = parametric_ddxdyy(t)/sqrt(b*b*b),\n          ROC = 1./K; // radius of curvature\n\n    return vec2(K, ROC);\n}\n\n// https://www.shadertoy.com/view/NtVfWG\nfloat parametric_sdf(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = parametric(linear_remap(from.x, from.x, from.y, to.x, to.y));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from.x, from.y, to.x, to.y);\n    \n        vec2 E = parametric(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    //float thickness = sinOSC(-5., 20., iTime)/R.y;\n    return minimal_distance;//-thickness;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0, 0), true);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         \n      \n      \n    /* Parametric function (x,y)=f(t) */\n    //                                                                         from                      to\n    //color = mix( color, vec3(1,0,0), SMAA(parametric_sdf(NDC, vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE), vec2(0, 1), 64.)) );\n    color = mix( color, vec3(1,0,0), SMAA(parametric_sdf(NDC, vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE), vec2(-20, 20), 512.)) );\n\n\n    /* Define t0 */\n#define RANGE      ( AR*SCENE_SCALE )\n    float t0 = sinOSC(-RANGE, RANGE, iTime*0.25) * 0.5;\n    //float t0 = sinOSC(-1., 1., iTime*0.15);\n   \n   \n   \n    // Problem points for cardioid.\n    //t0 = 3.1366;  // dxdy approaches to zero, so ROC from curvature_a approaches to infinity\n    //t0 = 2.08937; // dydx approaches to zero, so ROC from curvature_b approaches to infinity\n   \n   \n   \n    /* Circles of curvature. */\n    vec2 p0 = parametric(t0);\n    vec2 data_a = curvature_a(t0), data_b = curvature_b(t0);\n    vec2 N = normal(t0);\n    float dxdt_ = dxdt(t0), dydt_ = dydt(t0),\n          s = dxdt_ < 0. ? -1. : 1.;\n    vec2 C = p0 + s*normalize(N)*data_a.y;   \n    color = mix(color, vec3(0,0,1), SMAA(abs(diskSDF_L2(NDC, C, abs(data_a.y)))) );\n\n          s = dydt_ > 0. ? -1. : 1.;\n    C = p0 + s*normalize(N)*data_b.y;\n    color = mix(color, vec3(0,0,0), SMAA(abs(diskSDF_L2(NDC, C, abs(data_b.y)))) );\n\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, p0, 2.*UNIT)) );\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, C, 2.*UNIT)) );\n\n\n\n    /* Cells */\n    #define CELL_SIZE 1\n    NDC = mod(NDC, vec2(CELL_SIZE)); \n    color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n    color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n    color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat linear_remap(\n    float val,\n    float fl,\n    float fr,\n    float tl,\n    float tr)\n{\n    val = (val - fl) / (fr - fl); // inverse linear map from [fl; fr] to [0; 1].\n    return val * (tr - tl) + tl;  // linear map from [0; 1] to [tl; tr].\n}","name":"Common","description":"","type":"common"}]}