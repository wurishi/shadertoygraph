{"ver":"0.1","info":{"id":"XttBRn","date":"1538429231","viewed":277,"name":"Edge detectors","username":"vchizhov","description":"Gradient magnitude (GM) edge detection and laplacian zero-crossings (LP) edge detection.\nControls: LMB - change mode, Enter - image/video, Space - change GM mode, WS - sigma, AD - intensity GM, QE - threshold GM, ZC - intensity LP.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["blur","gradient","edgedetection","gaussian","laplacian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// change mode with LMB (0 - gaussian convolution, 1 - gradient magnitude,\n// 2 - laplacian, 3 - laplacian zero crossings)\n\n// WS - change the standard deviation sigma for the gaussian convolution, the darkening\n// artifact is due to the cutoff of the gaussian, a better variant would be iterated\n// heat diffusion, also it can be made faster by applying two 1d convolutions\n// (horizontal and vertical)\n\n// Space - chnage gradient magnitude edge detection between fuzzy/thresholded\n// AD - change intensity for fuzzy gradient magnitude vizualization\n// QE - change thresholding for thresholded gradient magnitude\n\n// ZC - change intensity for laplacian vizualization\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel3, uv).xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define NO_GAUSS 0\n\n\nfloat keyDown(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\nfloat keyHit(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,1.5/3.)).x == 1.0);\n}\n\n\nvec3 gaussianConv(in vec2 uv, in float sigma, in sampler2D sampler)\n{\n    int sg = int(round(3.0*sigma));\n    vec2 scale = vec2(1.0) / iResolution.xy;\n    vec3 col = vec3(0.0);\n    for(int y=-sg+2;y<sg-1;++y)\n    {\n        for(int x=-sg+2;x<sg-1;++x)\n        {\n            vec2 fc = vec2(float(x), float(y));\n            vec2 coord = fc * scale;\n            float gaussian = 1.0 / (sigma*sigma * 2.0 * PI) * exp(-0.5*dot(fc,fc)/(sigma*sigma));\n            col += texture(sampler, uv+coord).xyz*gaussian;\n        }\n    }\n    \n    return col;\n}\n\n\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_RETURN = 13;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool mode = bool((int(texelFetch(iChannel0, ivec2(0), 0).w>0.5) + int(keyHit(KEY_RETURN)))%2);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float sigma = max(1.0, texture(iChannel0, uv).w + 0.01*(keyDown(KEY_W) - keyDown(KEY_S))); \n    \n    \n    vec3 col;\n    if(mode)\n    {\n        col = gaussianConv(uv, sigma, iChannel1);\n    }\n    else\n    {\n        col = gaussianConv(uv, sigma, iChannel3);\n    }\n\n    \n    if(all(equal(floor(fragCoord.xy),vec2(0))))\n    {\n        fragColor = vec4(0.0,0.0,0.0,float(mode));\n    }\n    else\n    {\n        fragColor = vec4(col,sigma);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale\nvec3 luminance = vec3(0.2126, 0.7152, 0.0722);\n\nfloat keyDown(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\nfloat keyHit(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,1.5/3.)).x == 1.0);\n}\n\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_Q = 81;\nconst int KEY_E = 69;\nconst int KEY_SPACE = 32;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 scale = vec2(1.0)/iResolution.xy;\n    float e = dot(luminance,texture(iChannel1, uv+vec2(-1.0,0.0)*scale).xyz);\n    float w = dot(luminance,texture(iChannel1, uv+vec2(1.0,0.0)*scale).xyz);\n    float n = dot(luminance,texture(iChannel1, uv+vec2(0.0,1.0)*scale).xyz);\n    float s = dot(luminance,texture(iChannel1, uv+vec2(0.0,-1.0)*scale).xyz);\n    vec2 grad = 0.5*vec2(w-e,n-s);\n    float gradMagnitude = length(grad);\n    \n    vec4 uniformInfo = texelFetch(iChannel0, ivec2(0),0);\n    int modeInfo = int(uniformInfo.w);\n    \n    float thresholdInfo = uniformInfo.x;\n    if(iFrame==0) thresholdInfo = 0.05;\n    float threshold = max(0.0, thresholdInfo + 0.001*(keyDown(KEY_Q) - keyDown(KEY_E)));\n    \n    vec3 col;\n    \n    float amplitudeInfo = texture(iChannel0, uv).w;\n    if(iFrame==0) amplitudeInfo = 3.0;\n    float amplitude = max(0.0, amplitudeInfo + 0.1*(keyDown(KEY_D) - keyDown(KEY_A)));\n    \n    int mode = (modeInfo + int(keyHit(KEY_SPACE))) % 2;\n    if(mode==0)\n    {\n        col = amplitude*vec3(gradMagnitude);\n    }\n    else\n    {\n        col = gradMagnitude > threshold ? vec3(1.0) : vec3(0.0);\n    }\n    \n    if(all(equal(floor(fragCoord.xy),vec2(0))))\n    {\n        fragColor = vec4(threshold,0.0,0.0,float(mode));\n    }\n    else\n    {\n        fragColor = vec4((mode==0 ? amplitude : 1.0)*col, amplitude);\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale\nvec3 luminance = vec3(0.2126, 0.7152, 0.0722);\n\nfloat keyDown(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\nconst int KEY_Z = 90;\nconst int KEY_C = 67;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 scale = vec2(1.0)/iResolution.xy;\n    float e = dot(luminance,texture(iChannel1, uv+vec2(-1.0,0.0)*scale).xyz);\n    float w = dot(luminance,texture(iChannel1, uv+vec2(1.0,0.0)*scale).xyz);\n    float n = dot(luminance,texture(iChannel1, uv+vec2(0.0,1.0)*scale).xyz);\n    float s = dot(luminance,texture(iChannel1, uv+vec2(0.0,-1.0)*scale).xyz);\n    float c = dot(luminance,texture(iChannel1, uv).xyz);\n    float laplacian = w + e + n + s - 4.0*c;\n    \n    float amplitudeInfo = texture(iChannel0, uv).w;\n    if(iFrame==0) amplitudeInfo = 3.0;\n    float amplitude = max(0.0, amplitudeInfo + 0.3*(keyDown(KEY_C) - keyDown(KEY_Z)));\n    \n    fragColor = vec4(amplitude*vec3(laplacian), amplitude);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    bool mouseDown = iMouse.z>0.0;\n    bool mouseDownPrev = texelFetch(iChannel0, ivec2(0),0).w>0.0;\n    int mode = (int(texture(iChannel0, uv).w) + int(!mouseDownPrev && mouseDown))%4;\n    \n    \n    \n    \n    vec3 col;\n    \n    if(mode==0)\n    {\n        col = texture(iChannel1, uv).xyz;\n    }\n    else if(mode==1)\n    {\n        col = texture(iChannel2, uv).xyz;\n    }\n    else if(mode==2)\n    {\n        col = texture(iChannel3, uv).xyz;\n    }\n    else if(mode==3)\n    {\n        vec2 scale = vec2(1.0)/iResolution.xy;\n        float c = texture(iChannel3, uv).x;\n        float w = texture(iChannel3, uv+vec2(1.0,0.0)*scale).x;\n        float n = texture(iChannel3, uv+vec2(0.0,1.0)*scale).x;\n\n        col = c*w<0.0 || c*n<0.0 ? vec3(1.0) : vec3(0.0);\n    }\n    \n    \n    \n    if(all(equal(floor(fragCoord.xy),vec2(0))))\n    {\n        fragColor = vec4(0.0,0.0,0.0,float(mouseDown));\n    }\n    else\n    {\n        fragColor = vec4(col,float(mode));\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}