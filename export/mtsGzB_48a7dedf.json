{"ver":"0.1","info":{"id":"mtsGzB","date":"1672217436","viewed":87,"name":"Recursion Fibonacci (fork)","username":"kastorp","description":"forked from FabriceNeyret  [url=https://www.shadertoy.com/view/MsXyRM]recursion[/url]\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["stack","bug","recursion","factorial","switch","webgl2"],"hasliked":0,"parentid":"MsXyRM","parentname":"recursion (stack-based) "},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// forked from https://www.shadertoy.com/view/MsXyRM\n\n#define N 12. // recursion depth\n#define PR 2  // default is fibonacci2, change to 3 to get Fibonacci3, ie the sum of the previous 3 terms\n\n//                         | ENTRY POINT\n//float fib(int i){        |    \n//    if(i <=1) return 1.; | mode==CALL \n//    float s=0.; int p=0; |     \n//    s+= fib(i-1); p++;   |     \n//    s+= fib(i-2); p++;   | mode==RETURN && p==1    \n//    return s;            | mode==RETURN && p==2      \n//}    \nint t=0; //cycle counter\nfloat fib(int x) // -- fibonacci(n)\n{\n    #define SIZE 12 //stack size \n    #define ITERS 600 //max number of stack operations\n\n    struct StackData{ int i; int p;float s;}; //i=level, p=progress, s=sum\n\n    //auxiliary functions (should be the same for every direct recursion function\n    StackData n; //current level    \n    StackData stack[SIZE];  \n    int z=0; \n    int mode; const int CALL=1, RETURN=0;\n    #define push(v)       stack[z++] = v\n    #define pop()         stack[--z]\n    #define empty()       z<=0\n    #define CALL(v)     { SAVE_CTX; push(v); mode = CALL;   }\n    #define RETURN(v)   { push(v); mode = RETURN; }\n    #define SAVE_CTX      push(n)\n    #define RESTORE_CTX   n = pop()\n    #define GET_PARAM     pop()\n    #define GET_RETURN    pop(); RESTORE_CTX   \n \n    // recursion engine, \n    CALL(StackData(x,0,0.));                      \n    do {    \n       if (mode==CALL) { \n           n = GET_PARAM;\n            if (n.i<=1) RETURN(StackData(1,0,1.))        \n            else  CALL(StackData(n.i-1,0,0.));                                     \n            \n       } else {  \n            StackData v = GET_RETURN; \n            if (empty()) return v.s; \n            n.p++; n.s+=v.s;         \n            if(n.p<PR)  CALL(StackData(n.i-n.p-1,0,0.)) \n            else RETURN(n)                               \n         }\n    } while(t++<ITERS ); \n\n    return -1.;        \n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\tU /= iResolution.xy;\n    \n\n    int x = int(N*U.x);   \n    float f = fib(x);\n  \tO = U.y<.1 ? vec4(0,1,0,0)*float(x)/N                  // level\n               : f<0. ? vec4(.8,0,0,0.)                    // error\n               : vec4(1,1,0,0)* step(U.y-.1, f/N/20.) ;    // result\n\n    //numbers\n    pInt((U *N - vec2(x,1.2+float(f)/20.))*3. , float(f)); // result \n    pInt((U *N - vec2(x,.8))*3. , float(x));               // depth\n    O.xyz = mix(O.xyz,vec3(1),draw_char(iChannel0).x);   \n    pInt((U *N - vec2(x,.1))*3. , float(t));               // number of cycles\n    O.xyz = mix(O.xyz,vec3(1,0,0),draw_char(iChannel0).x);   \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--------------------------------\n\n//FabriceNeyret\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) \n    char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char(sampler2D ch) {\n    int c = char_id; vec2 p = char_pos;\n    char_id = -1;\n    return c < 0  ? vec4(0,0,0,1e5) : textureGrad( ch, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\n}\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.)  v += char(p - vec2(-.5,0), 45 ), n = -n;\n    for (float i = 3.; i>=0.; i--)  n /=  9.999999, v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}","name":"Common","description":"","type":"common"}]}