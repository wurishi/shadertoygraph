{"ver":"0.1","info":{"id":"sdlfW2","date":"1645442355","viewed":130,"name":"Waltzing Fractal Clock","username":"VL","description":"..","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime)\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n\nfloat BigHand(float2 uv, float time, float size)\n{\n    float t = floor(floor(mod(time, 3.f)) / 2.f);\n    float sx, cx;\n    float nsx, ncx;\n    sincos(floor(time + 1.f) * 0.1f, sx, cx);\n    sincos(floor(time) * 0.1f, nsx, ncx);\n    sx = t * sx + (1.f - t) * nsx;\n    cx = t * cx + (1.f - t) * ncx;\n    float2x2 rot = float2x2(cx, sx, -sx, cx);\n    \n    uv *= size;\n    uv = mul(rot, uv);\n    \n    float2 c = uv;\n    float2 zn = c;\n\n    int iterMax = 20;\n    int it = 0;\n    \n    while (it < iterMax && dot(zn, zn) < 4.f)\n    {\n        zn = float2(zn.x * zn.x - zn.y * zn.y, 2.f * zn.x * zn.y) + c;\n        ++it;\n    }\n\n    return it == 20 ? 0.f : pow(float( it) / float(iterMax), 3.f);\n}\n\nfloat SmallHand(float2 uv, float time, float size)\n{\n    float sx, cx;\n    sincos(floor(time) * 0.2f, sx, cx);\n\n    float2x2 rot = float2x2(cx, sx, -sx, cx);\n    \n    uv *= size;    \n    uv = mul(rot, uv);\n    \n    float2 c = uv;\n    float2 zn = c;\n\n    int iterMax = 20;\n    int it = 0;\n    \n    while (it < iterMax && dot(zn, zn) < 4.f)\n    {\n        zn = float2(zn.x * zn.x - zn.y * zn.y, 2.f * zn.x * zn.y) + c;\n        ++it;\n    }\n    \n    return it == 20 ? 0.f : pow(float (it) / float(iterMax), 3.f);\n}\n\nfloat2 complexPow(float2 z, const float k)\n{\n    float r = length(z);\n    float a = atan2(z.y, z.x);\n    sincos(a * k, z.y, z.x);\n    return pow(r, k) * z;\n}\n\nfloat kMandelbrot(float2 uv, const float k, const float size, const float angle)\n{\n    float sx, cx;\n    sincos(angle, sx, cx);\n    float2x2 rot = float2x2(cx, sx, -sx, cx);\n    \n    uv *= size;\n    uv = mul(rot, uv);\n    \n    float2 c = uv;\n    float2 zn = c;\n\n    int iterMax = 20;\n    int it = 0;\n    \n    while (it < iterMax && dot(zn, zn) < 4.f)\n    {\n        zn = complexPow(zn, k) + c;\n        ++it;\n    }\n    \n    return it == 20 || it == 0 ? 0.f : float( it) / float(iterMax) + 0.3f;\n}\n\n\n\nfloat kJulia(float2 zn, const float k, const float size, const float2 c)\n{\n    zn *= size;\n    \n    int iterMax = 20;\n    int it = 0;\n    \n    while (it < iterMax && dot(zn, zn) < 4.f)\n    {\n        zn = complexPow(zn, k) + c;\n        ++it;\n    }\n    \n    return float( it) / float(iterMax) - 0.2f;\n}\n\nfloat ToothFunc(float x)\n{\n    float c = cos(x);\n    return min(1.f, c * (sign(c) + 1.f) * 0.8f);\n}\n\nfloat Gear(float2 p, float size, float numTooth, float toothHeight, float angleOffset)\n{\n    float angle = atan2(p.y, p.x) - angleOffset;\n    float tooth = toothHeight * ToothFunc(angle * numTooth);\n    return length(p) - (tooth + size);\n}\n\nfloat Circle(float2 p, float size)\n{\n    return length(p) - size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 TexC = 4.f*(fragCoord.xy/iResolution.xy)-2.f;\n    TexC.x *= iResolution.x/iResolution.y;\n    TexC.y =-TexC.y;\n\n    float time = CurrentTime;\n    float gearTime = 0.f;\n    float mandelK = 0.f, mandelSize = 0.f;\n    float juliaK = 0.f, juliaSize = 0.f;\n    float bigTime = 0.f, bigSize = 0.f;\n    float smallTime = 0.f, smallSize = 0.f;\n    float3 colorOffset = vec3(0.f);\n    float3 sc = vec3(0.f);\n    sincos(CurrentTime * 0.4f, sc.x, sc.y);\n    \n       gearTime = time;\n        mandelK = -11.f;\n        mandelSize = 0.67f;\n        juliaK = -12.373f + sc.x * 0.1f;\n        juliaSize = 1.5f;\n        bigSize = 1.2f;\n        smallSize = 1.2f;\n        bigTime = -time * 2.f - 15.f;\n        smallTime = 3.f - time * 0.666666f;\n\n float gear = Gear(TexC, 2.1f, 12.f, 0.35f, gearTime);\n    gear = min(gear, max(-Circle(TexC - float2(2.565f, 1.82f), 0.35f), Gear(TexC - float2(2.565f, 1.82f), 0.7f, 4.f, 0.35f, -gearTime * 3.f)));\n    gear = min(gear, max(-Circle(TexC - float2(3.1f, -1.65f), 0.6f), Gear(TexC - float2(3.1f, -1.65f), 1.05f, 6.f, 0.35f, -gearTime * 2.f)));\n    gear = min(gear, max(-Circle(TexC + float2(3.1f, -1.65f), 0.6f), Gear(TexC + float2(3.1f, -1.65f), 1.05f, 6.f, 0.35f, -gearTime * 2.f)));\n    gear = min(gear, max(-Circle(TexC + float2(2.475f, 1.645f), 0.25f), Gear(TexC + float2(2.475f, 1.645f), 0.525f, 3.f, 0.35f, -gearTime * 4.f)));\n    \n    sc.xy *= TexC;\n    float3 color = smoothstep(0.001f, 0.f, gear) * sc;\n    color.rb += vec2(BigHand(TexC, bigTime, bigSize)) * float2(3.f, 2.5f);\n    color.r += SmallHand(TexC, smallTime, smallSize) * 3.f;\n    color = lerp(color, (1.f - vec3(kJulia(float2(abs(TexC.x), TexC.y), juliaK, juliaSize, float2(-0.635831f, -0.832158f)))) * float3(0.5f, 0.3f, 0.8f), 0.5f);\n    color = lerp(color, sc.gbr * kMandelbrot(TexC, mandelK, mandelSize, 1.5707963f), 0.5f);\n    color += colorOffset;\n    color = pow(color, vec3(0.78f));\n\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}