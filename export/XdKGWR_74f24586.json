{"ver":"0.1","info":{"id":"XdKGWR","date":"1454088667","viewed":391,"name":"Multiple wifi routers","username":"Andre","description":"Test to see what would happen with 7 routers in a block of houses. Did some variance on the beam forming/frequency/angle of the routers. Every 4 seconds 1 gets added. Signal strength is filtered in BufB","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["test","visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = clamp(texture(iChannel0,uv),0.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n                          \nconst float waveLength = 125.0; // Wavelength at 2.4 GHz is 125mm\n        \nvec3 router(vec2 center,float x)\n{\n    // Parameters for the calculation, you can change them to see the effect\n    const float antennaDistance = 125.0; // Distance between antenna's\n    \n    vec2 antenna1 = center;\n    vec2 antenna2 = antenna1;\n    vec2 antenna3 = antenna1;\n    \n    // Put distance between antanna's\n    float dist = 0.5 * (1.0 / waveLength) * 6.28 * antennaDistance; \n    antenna1.x += dist;\n    antenna2.x -= dist;\n    antenna1.y += x*3.;\n    antenna2.y -= x*3.;\n    \n    // Phase shift is used to steer beamforming\n    float phaseShift = x*3.14;// + 3.14* sin(iTime*(1.0+x));\n    float freqFactor = 1.0+x/100.0;\n    float phaseFactor = 1.0+(x+sin(iTime))/30.0;\n    \n    // Calculate color so you can see where they cancel each other (black area)\n    return vec3((1.0/(length(antenna3)+1.0))*(\n                sin(phaseFactor*iTime*-3.+length(antenna1*freqFactor)+phaseShift)\n              + sin(phaseFactor*iTime*-3.+length(antenna2*freqFactor))\n              + sin(phaseFactor*iTime*-3.+length(antenna3*freqFactor)+phaseShift*.5)));\n}\n\nfloat k(int key) {\n    return (texture(iChannel1,vec2((float(key)+.5)/256.0,0.75)).x>0.0?0.0:1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = pz_initializeState(fragCoord);\n    \n    const float viewDistance = 13000.0; // Distance in mm, view from center of antenna's\n    \n    vec2 c = (2.0*fragCoord-iResolution.xy) / iResolution.x; // -1.0 .. 1.0\n    c *= (1.0 / waveLength) * 6.28 * viewDistance; // put viewDistance into view\n    \n    float gt = iTime;\n    fragColor = vec4(abs(router(c,0.0)*vec3(0.7,.2,0.0)*k(49)\n                     +step( 4.0,gt)*router(c+vec2( 240.,   0.),-0.3)*vec3(0.7,0.1,1.0)*k(50)\n                     +step( 8.0,gt)*router(c+vec2( 240., 300.), 1.1)*vec3(0.7,0.1,0.3)*k(51)\n                     +step(12.0,gt)*router(c+vec2(-240., 220.),-0.5)*vec3(0.2,0.5,0.3)*k(52)\n                     +step(16.0,gt)*router(c+vec2(-440.,   0.),-0.7)*vec3(0.2,0.1,1.0)*k(53)\n                     +step(20.0,gt)*router(c+vec2( 540.,  30.), 1.4)*vec3(0.2,0.5,1.0)*k(54)\n                     +step(24.0,gt)*router(c+vec2( 250.,-400.), 1.7)*vec3(0.7,0.5,0.3)*k(55)\n                     +step(29.0,gt)*router(c+vec2( 250.,-500.), 1.7)*vec3(0.2,0.1,0.3)*k(56)\n                        )*100.0\n                     \n                     ,4.0) *0.25;\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 2\n#define pz_stateSample(x) texture(iChannel2,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n                          \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pz_initializeState();\n    \n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    vec4 bufA = texture(iChannel0,uv);\n    vec4 bufB = texture(iChannel1,uv);\n    bufB *= 0.997;\n    \n    if (pz_resetCount()>50.)\n        fragColor = bufA;\n    else\n        fragColor = vec4(max(bufB.rgb,bufA.rgb),1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n\n//======Defines for state behaviour\n#define pz_resetOnMove 1\n\nbool pz_checkCell(float nr, vec2 coord) {\n    return distance(pz_nr2vec(nr),coord)<=0.5;\n}\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\nconst float KEY_ADD   = 107.5/256.0;\nconst float KEY_SUBS  = 109.5/256.0;\nconst float KEY_EQUAL = 187.5/256.0;\nconst float KEY_MINUS = 189.5/256.0;\n\nbool checkKey(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.25)).x > 0.5;\n}\n\nbool checkKey(float key1, float key2)\n{\n    return checkKey(key1) || checkKey(key2);\n}\n\nbool checkKey(float key1, float key2, float key3)\n{\n    return checkKey(key1) || checkKey(key2) || checkKey(key3);\n}\n\nvoid pz_mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pz_initializeState();\n    fragColor = pz_stateSample(fragCoord/pz_realBufferResolution);\n    if (fragCoord.x < 1. \n     && fragCoord.y < 1.) {\n        //Lets store the initial buffersize at pos0 and use that for addressing\n        if (pz_originalBufferResolution.x == 0.0)\n            fragColor = vec4(pz_realBufferResolution,1.0,1.0);\n        \n    } else if (pz_checkCell(1.,fragCoord)) {\n        \n        // Use postion 1 to trigger screen size changes so we can clear other buffers on going fullscreen\n        if (distance(fragColor.xy,pz_realBufferResolution)>1.0 \n#if pz_resetOnMove            \n            || pz_readState(3.).w > 0.0\n#endif            \n           ) {\n            fragColor.xy = pz_realBufferResolution;\n            fragColor.z = 60.0;\n        } else {\n            if (fragColor.z > 0.0)\n                fragColor.z -= 1.0;\n        }\n        \n    } else if (pz_checkCell(2.,fragCoord)) {\n        // Store mouse delta if keydown\n        if (iMouse.w>0.5) {\n            if (fragColor.x>0.0) {\n                fragColor.zw = fragColor.xy - iMouse.xy;\n            } else {\n                fragColor.zw = vec2(0.0);\n            }\n            fragColor.xy = iMouse.xy;\n        } else {\n            fragColor = vec4(-1.,-1.,0.,0.);\n        }\n        \n    } else if (pz_checkCell(3.,fragCoord)) { \n        // Handle keyboard moves\n        vec2 delta = vec2( checkKey(KEY_LEFT ,KEY_A,KEY_Q)?-0.02:\n                           checkKey(KEY_RIGHT,KEY_D      )? 0.02:0.0\n                         , checkKey(KEY_DOWN ,KEY_S      )?-0.02:\n                           checkKey(KEY_UP   ,KEY_W,KEY_Z)? 0.02:0.0);\n        float factor = checkKey(KEY_SUBS, KEY_MINUS)?1.01:\n                       checkKey(KEY_ADD , KEY_EQUAL)?0.99:1.0;\n        if (fragColor.z<0.0000001)\n            fragColor.z = 1.0;\n        \n        //Update transform state\n        vec2 mouseDelta = pz_readState(2.).zw;\n        fragColor.z *= factor;\n        fragColor.xy += delta *  fragColor.z; //Add keyboard move\n        fragColor.xy += mouseDelta / iResolution.xy *  fragColor.z; //Add mouse delta\n        \n        //Store movement in w\n        fragColor.w = abs(factor-1.0) + length(delta) + length(mouseDelta);\n                \n    } else\n        fragColor = vec4(0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    pz_mainImage( fragColor, fragCoord );\n    \n    // Add multiple state handlers here\n}\n","name":"Buf C","description":"","type":"buffer"}]}