{"ver":"0.1","info":{"id":"XtjSzK","date":"1447584895","viewed":180,"name":"coding dojo 2","username":"pmilian","description":"shader developped during the second coding dojo","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dojo2shaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float zNear = 1.0;\nconst float zFar  = 400.0;\n\n\nfloat map(in vec3 m) {\n    \n\tvec3 sphereCenter = vec3(cos(iTime)*4.0, 0.0, +20.0);\n    float radius = 4.0+sin(iTime)*2.0;\n    \n    float displacementFactor = 0.8 + cos(iTime/2.0)* 0.4;\n    float displacement = sin(displacementFactor*m.x)*sin(displacementFactor*m.y)*sin(displacementFactor*m.z);\n    \n    return length(m - sphereCenter) - radius + displacement;\n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<50; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = dot(normal, -lightRay);\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), 20.0);\n    \n    vec3 diffuseComponent = vec3(1.0, 0.0, 0.0) * diffuse;\n    vec3 hilightComponent = vec3(1.0, 1.0, 1.0) * hilight;    \n    vec3 ambiantComponent = vec3(0.2, 0.0, 0.0);       \n    \n    vec3 reflectray = reflect(m-eye, normal);\n    vec3 envmap \t= texture( iChannel0, reflectray).xyz;\n    \n    vec3 sphereColor = diffuseComponent + hilightComponent + ambiantComponent;\n    \n    return vec4(mix(sphereColor, envmap, 1.0), 1.0);\n}\n\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= vec3(-15.0*cos(iTime), 25.0*cos(iTime/3.0), -5.0);\n    \n    vec3\tm;\n    \n    if(rayMarching(eye, ray, m)) {\n        \n        vec3 normal = computeNormal(m);\n        \n        fragColor = computeColor(ray, m, normal, light, eye);\n    }\n    else {\n        fragColor = vec4(0.0, 0, 0, 1.0);        \n    }\n}","name":"","description":"","type":"image"}]}