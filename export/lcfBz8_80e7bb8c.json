{"ver":"0.1","info":{"id":"lcfBz8","date":"1723319183","viewed":51,"name":"Voxel Pathtracing","username":"WyvernAllow","description":"voxel pathtracing and GI","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["raytracing","voxels","voxel","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_STEPS 64\n\nfloat sdSphere(vec3 p, float d) {\n    return length(p) - d;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nbool getVoxel(vec3 c) {\n    vec3 p = c + vec3(0.5);\n    float d = sdSphere(p, 7.5);\n    return d < 0.0;\n}\n\nstruct HitResult {\n    bool didHit;\n    vec3 normal;\n};\n\nHitResult raycast(vec3 origin, vec3 dir) {\n    vec3 mapPos = floor(origin);\n    vec3 deltaDist = abs(vec3(length(dir)) / dir);\n    vec3 rayStep = sign(dir);\n\n    vec3 sideDist = (rayStep * (mapPos - origin) + (rayStep * 0.5 + 0.5)) * deltaDist;\n    vec3 mask;\n\n    for (int i = 0; i < MAX_RAY_STEPS; i++) {\n        if (getVoxel(mapPos)) {\n            HitResult result;\n            result.didHit = true;\n            result.normal = -rayStep * mask;\n            return result;\n        }\n\n        if (sideDist.x < sideDist.y) {\n            if (sideDist.x < sideDist.z) {\n                sideDist.x += deltaDist.x;\n                mapPos.x += rayStep.x;\n                mask = vec3(1.0, 0.0, 0.0);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = vec3(0.0, 0.0, 1.0);\n            }\n        } else {\n            if (sideDist.y < sideDist.z) {\n                sideDist.y += deltaDist.y;\n                mapPos.y += rayStep.y;\n                mask = vec3(0.0, 1.0, 0.0);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = vec3(0.0, 0.0, 1.0);\n            }\n        }\n    }\n\n    HitResult result;\n    result.didHit = false;\n    return result;\n}\n\n// https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint pcgHash(uint inseed) {\n    uint state = inseed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfloat randomFloat(inout uint seed) {\n    seed = pcgHash(seed);\n    return float(seed) / float(0xFFFFFFFFu);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float aspect = float(iResolution.x) / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= aspect;\n\n    uint seed = uint(fragCoord.x) * uint(fragCoord.y);\n\n    vec3 pos = vec3(6.0, 6.0, 14.0);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.0));\n    vec3 sun_dir = normalize(vec3(0.2, 1.0, 0.5));\n   \n    HitResult result = raycast(pos, dir);\n    if (result.didHit) {\n        float diff = max(dot(sun_dir, result.normal), 0.0);\n        fragColor = vec4(diff, diff, diff, 1.0);\n    } else {\n        \n        float value = randomFloat(seed);\n        fragColor = vec4(value, value, value, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}