{"ver":"0.1","info":{"id":"mdt3D8","date":"1677232559","viewed":158,"name":"Fork Shepard Scale","username":"Carandiru","description":"fork of a really original shader by fabrice neyret @ https://www.shadertoy.com/view/XdlXWX\n\nmore must know the magic of the Shepard Scale !","likes":5,"published":3,"flags":8,"usePreview":0,"tags":["sound","illusion"],"hasliked":0,"parentid":"XdlXWX","parentname":"Shepard scale"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of a really original shader by fabrice neyret @ https://www.shadertoy.com/view/XdlXWX\n\n// some subtle changes, really just trying to build an engine out of sound waves from my stereo speakers....\n// most of the changes are in \"Sound / Common\"\n// and attempting to show that data - messing around with this shader.\n\n// first time I ever even heard of the Shepard Scale - was that stylistic shader by fb @ https://www.shadertoy.com/view/XdlXWX\n\n// more must know the magic of the Shepard Scale !\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime + 1.0f;\n    vec2 cs = vec2(sin(time*SPEED),sin(time*SPEED));\n    \n    float Oa = max(-O, O + cs.x*time*SPEED);\n    \n    Oa = channel(Oa, time);\n    \n    float Ob = max(-O, O - cs.y*time*SPEED);\n    \n    Ob = channel(Ob, time);\n    \n    \n    float eng = abs(Oa-Ob);\n    \n    vec3 color = vec3(0);\n    \n    float scale[5] = float[5]( smoothstep(0.0f, 1.0f, eng),\n                               smoothstep(0.0f, 1.0f, eng*eng),\n                               smoothstep(0.0f, 1.0f, pow(eng, 3.0f)),\n                               smoothstep(0.0f, 1.0f, pow(eng, 4.0f)),\n                               smoothstep(0.0f, 1.0f, pow(eng, 5.0f)) );\n    \n    for (uint i = 0u; i < 5u; ++i) {\n    \n        float e = (1.-cos(2.*PI*uv.x))/2.;\n        float phase = 80.*uv.x-(3.)*iTime;\n        float v = pow((sin(phase)+1.)/2.,30.0); \t\t\t\t\t// peaks\n        v *= step(.45,uv.y*3.)*smoothstep(e,e-.05,-.5+uv.y*(3.-2.0f*scale[i])); // enveloppe\n\n        vec3 scale_color = scale[i] * mix(vec3(10.0f,0.0f,0.0f), 1000.0f * vec3(0.95f,0.01f,0.15f), float(i)/5.0f);\n        \n        color += vec3(v) * scale_color;\n   \n    }\n    \n\tfragColor = vec4(pow(color, vec3(1.0f/2.2f)),1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"vec2 mainSound( in int samp,float time)\n{\n    vec2 cs = vec2(sin(time*SPEED),sin(time*SPEED));\n    \n    float Oa = max(-O, O + cs.x*time*SPEED);\n    \n    Oa = channel(Oa, time);\n    \n    float Ob = max(-O, O - cs.y*time*SPEED);\n    \n    Ob = channel(Ob, time);\n    \n    return vec2( GOLDEN_RATIO * vec2(Oa, Ob) );\n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define PI (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n\n#define T (16. * GOLDEN_RATIO)   // cycling time\n#define N 16.   // number of peaks\n#define O (GOLDEN_RATIO) // octaves\n\nfloat channel(float Oo, float time)\n{\n   float v = 0.;\n   for (float i=0.0; i<=N; ++i) {\n        float enveloppe = (1.-cos(2.*PI*i/N))/2.;\n        //float freq = pow(O,fract(time/T));\n        // phase = int of freq\n        float phase =floor(time/T) + pow(Oo,fract(time/T))-1.;\n        phase = phase * pow(Oo,i)*T/log(Oo) + i;\n        v += GOLDEN_RATIO * enveloppe*sin(2.*PI*phase);\n    }\n    \n    float mono = GOLDEN_RATIO_ZERO * v/float(N);\n    \n    return(mono);\n}\n\n#define SPEED ((GOLDEN_RATIO)/(time * PI * 2.0f))\n","name":"Common","description":"","type":"common"}]}