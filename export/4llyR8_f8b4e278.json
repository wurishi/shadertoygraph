{"ver":"0.1","info":{"id":"4llyR8","date":"1503402934","viewed":122,"name":"totality2","username":"visy","description":"marche","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["marche"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define QUALITY     2\n\n#define DECAY       .950\n#define EXPOSURE    .94\n #define SAMPLES    64\n #define DENSITY    .97\n #define WEIGHT     .35\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 coord = uv;\n    vec2 lightpos = texture(iChannel0, uv).zw;\n    \n    float occ = texture(iChannel0, uv).x; //light\n    float obj = texture(iChannel0, uv).y; //objects\n        \n    vec2 dtc = (coord - lightpos) * (1. / float(SAMPLES) * DENSITY);\n    float illumdecay = 1.;\n    \n    for(int i=0; i<SAMPLES; i++)\n    {\n        coord -= dtc;\n            float s = texture(iChannel0, coord).x;\n        s *= illumdecay * WEIGHT;\n        occ += s;\n        illumdecay *= DECAY;\n    }\n        \n    fragColor = vec4(vec3(0., 0., obj*.033)+occ*EXPOSURE,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR_CLIPPING_PLANE 0.0001\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 100\n#define EPSILON 0.01\n#define DISTANCE_BIAS 1.0\n\n#define AA 1\n\nfloat smin(float a, float b, float k)\n{\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(max(0.0001,res)) / k;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nconst float kHashScale1 = 443.8975;\n\nfloat hash11(float p) {\n  vec3 p3 = fract(vec3(p) * kHashScale1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 sun( vec2 uv, vec2 p ) \n{\t\t\t\t\t\t\t\n    vec3 res;\n    float di = distance(uv, p);\n    res.x =  di <= .3333 ? sqrt(1. - di*3.) : 0.;\n    \n    res.yz = p;\n    res.y /= (iResolution.x / iResolution.y);\n    res.yz = (res.yz+1.)*.5;\n    \n    return res;\n}\n\nvec2 scene(vec3 pos)\n{\n\tfloat finalDist = 1.0;\n        vec3 translate = vec3(0.0, 0.0,8.2);\n        vec3 opos = pos - translate;\n        float dist = sdSphere(opos,1.4);\n    \n    return vec2(dist, 1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec2 result = scene(position + direction * total_distance);\n        if(result.x < EPSILON)\n        {\n            return vec2(total_distance, result.y);\n        }\n        \n        total_distance += result.x * DISTANCE_BIAS;\n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 tot = vec3(0.0);\n\tvec3 light;\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec2 uv2 = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n\n    vec3 direction = normalize(vec3(uv, 0.0));\n    float cx = 0.;\n    float cy = 0.;\n    float cz = 0.1;\n    vec3 camera_origin = vec3(cx, cy, cz);\n\tvec3 lookAt = vec3(cx,cy,cz+1.);\n    \n    vec3 forward = normalize(lookAt-camera_origin); // Forward vector.\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); // Right vector... or is it left? Either way, so long as the correct-facing up-vector is produced.\n    vec3 up = normalize(cross(forward,right)); // Cross product the two vectors above to get the up vector.\n\n    float FOV = 0.25;\n\n    vec3 ro = camera_origin;\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec2 result = raymarch(ro, rd);\n            \n    float fog = pow(1.0 / (1.0 + result.x), 0.2);\n    \n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == 1.0)\n    {\n\t\tmaterialColor = vec3(0.00,0.00,0.00);\n    } else if (result.y == 2.0) {\n\t\tmaterialColor = vec3(0.03,0.1,0.1);\n    } else if (result.y == 3.0) {\n\t\tmaterialColor = vec3(0.5*0.5,0.4*0.5,0.4*0.5);\n    }\n    vec3 intersection = ro + rd * result.x;\n    \n    vec3 nrml = normal(intersection, 0.1);\n    float occ = calcAO( intersection, nrml );\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n\n    diffuse = diffuse * 0.5 + 0.5;\n    \n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 ambient_color = vec3(1.0,1.0, 1.0);\n    vec3 h = (light_dir - rd) / 2.;\n\tfloat s = pow( dot(nrml, h), 2.) * 0.5;\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color)+s;\n    vec3 outColor = diffuseLit*occ*fog;\n\tif (result.y == 0.0) outColor = vec3(1.0,1.0,1.0);\n\ttot+=outColor;\n\n    vec3 sa = vec3(0.0);\n    float ss = cos(distance(result.x*uv.y*1.*cos(uv.x*1.+cos((10.+iTime*0.1)*10.*uv.y*0.2)),0.0)*0.1)*(1.0-distance(uv.y,0.0));\n    ss *= cos(distance(result.x*cos(uv.x*3.+sin(uv.y*10.))*sin(uv.y*1.+sin((-10.+iTime*0.2)*10.*uv.y*0.2)),0.0)*0.1)*(1.0-distance(uv.x,0.0)*0.5);\n    sa = vec3(ss);\n    light = min(sun(uv, vec2(0.0,0.0)), 1.0);\n    if (result.y == 0.0) tot*=sa*0.2;\n    }\n    tot /= float(AA*AA);\n    \n\n\tfragColor = vec4(tot.xx*0.7, light.yz);\n\n}\n","name":"Buf A","description":"","type":"buffer"}]}