{"ver":"0.1","info":{"id":"XfScRW","date":"1721937637","viewed":54,"name":"Simple water reflection","username":"Eolc","description":"water reflection for texture\nunable to implement foam and fresnel :( ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","reflection","caustics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a trial after learning Perlin noise and water rendering\n// some expected effects couldn't implented yet :(\n#define PI 3.14159265359\nfloat shore_pos = 0.4;\nfloat random(vec2 p) {\n  return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat noise12(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f);\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\nvec2 perlin(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f);\n  float a = noise12(i);\n  float b = noise12(i + vec2(1.0, 0.0));\n  float c = noise12(i + vec2(0.0, 1.0));\n  float d = noise12(i + vec2(1.0, 1.0));\n  return vec2(mix(mix(a, b, f.x), mix(c, d, f.x), f.y), 0.);\n}\nvec2 panner(vec2 uv, float dir, float speed, float offset, float tiling,\n            float time) {\n  // use polar coord\n  dir = 2. * dir - 1.;\n  vec2 d = normalize(vec2(cos(PI * dir), sin(PI * dir)));\n  return (uv * tiling + offset) + d * (time * speed);\n}\n// dynamically gen a caustic tex, maybe not a good idea?\nvec4 getCausticTex(vec2 p) {\n  vec4 k = vec4(0.);\n  mat3 m = mat3(-2, -1, 2, 3, -2, 1, 1, 2, 2);\n  vec3 a = vec3(p / 4e2, 165. / 4.) * m, b = a * m * .4, c = b * m * .3;\n  k = vec4(pow(min(min(length(.5 - fract(a)), length(.5 - fract(b))),\n                   length(.5 - fract(c))),\n               7.) *\n           25.);\n  return k;\n}\n// originally used to split a caustic tex, but not used ultimately\nvec3 RGBSplit(vec2 uv, float split) {\n  vec2 r = uv + vec2(split, split);\n  vec2 g = uv + vec2(split, -split);\n  vec2 b = uv + vec2(-split, -split);\n  return vec3(getCausticTex(r).x, getCausticTex(g).y, getCausticTex(b).z);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n  float shoreFactor = (1. - shore_pos) / shore_pos;\n  vec3 col = vec3(0.0);\n  // up water\n  vec2 uv1 = vec2(uv.x, max(uv.y - shore_pos, 0.0) / (1.0 - shore_pos));\n  // under water\n  vec2 uv2 = vec2(uv.x, max(shore_pos - uv.y, 0.0) / shore_pos);\n  vec3 col1 = texture(iChannel0, uv1).xyz;\n  float time = iTime * 0.05;\n  \n  vec3 normal = vec3(1.);\n  vec3 viewDir = vec3(1., -1., 1.);\n  // wave\n  vec2 waveDir = vec2(.6, .3);\n  float waveSpeed = 20.;\n  float waveStrength = .025;\n\n  time *= waveSpeed;\n  vec2 waveOffset = perlin(uv + time * waveDir) * waveStrength;\n  uv2 += waveOffset;\n  \n  // TODO: how to get the normal of the water surface?\n  // normal = SomeFunction(waveOffset);\n  \n  // caustics\n  float causticStrength = 1.75;\n  float causticSpeed = 11.15;\n  float causticScale = .75;\n  float causticRGBSplit = .6;\n  float causticDepth = 1.;\n  vec3 causticColor = vec3(0.4471, 0.4471, 0.4667);\n  vec2 uvp = uv2*900.;\n  uvp.y*=1.414;\n  vec3 colCombine = min(RGBSplit(panner(uvp, 1., causticSpeed, 0.,\n                                        1. / causticScale, time),\n                                 causticRGBSplit),\n                        RGBSplit(panner(uvp, 1., causticSpeed, 0.,\n                                        -1. / causticScale, time),\n                                 causticRGBSplit));\n  colCombine *= causticStrength;\n  \n  // Not good as imagined :(\n  // foam\n  float foam1 = smoothstep(0.2, -0.1, uv2.y + fract(time) * 0.005) *\n               noise12(uv2 * 50.) * .9;\n  float foam2 = smoothstep(0.2, -0.1, uv2.y + (1. - fract(time)) * 0.005) *\n               noise12((uv2+vec2(0.1,0.)) * 50.) * .8;    \n               \n  // fresnel\n  vec3 fresnelColor = vec3(0.3882, 0.3882, 0.3882);\n  float fresnel = 1. - dot(normal, viewDir);\n\n  vec3 col2 = texture(iChannel0, uv2).xyz;\n  col2 += colCombine * causticColor;\n  col2 += fresnel * fresnelColor;\n  //col2 *= vec3(1., .9, .9);\n  col2 *= smoothstep(1.6, -0.1, 1.1 * uv2.y);\n  col2 = mix(col2, vec3(1.), foam1);\n  col2 = mix(col2, vec3(1.), foam2);\n  \n  float shore = smoothstep(-0.2, 0.2, 1.5 * uv2.y);\n  col = mix(col1, col2, 1. - smoothstep(shore_pos, shore_pos+0.01, uv.y));\n\n  fragColor =\n      vec4(col, step(shore_pos, uv.y) + (1. - step(shore_pos, uv.y)) * shore);\n}","name":"Image","description":"","type":"image"}]}