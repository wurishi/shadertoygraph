{"ver":"0.1","info":{"id":"ss2cWh","date":"1643559966","viewed":337,"name":"Voronoi PBD","username":"kastorp","description":"the best I could obtain.\nNeighbor freezing seems better than constraint iteration but it's too conservative.\nI need to study Position Based Dynamics methods [url]https://youtu.be/RhEkKDEQEYM[/url]\n","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","particles","verlet","pbd"],"hasliked":0,"parentid":"7tySDW","parentname":"Frozen Waterfalls"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Voronoi PBD by Kastorp\n//-----------------------------------------------------\n\nGETTERS\n\nvec4 Voronoi(in vec2 pos){\n    ivec4 nb = getClosest(ivec2(pos/ZOOM));\n  \n    bool ghost;\n    vec4 pi0 = getParticle(nb[0],ghost);\n    vec4 pi1 = getParticle(nb[1],ghost);\n    vec4 pi2 = getParticle(nb[2],ghost);\n\n    float d0 = distance(pos/ZOOM,pi0.xy)*ZOOM;\n    float d1 = distance(pos/ZOOM,pi1.xy)*ZOOM;  \n    float d2 = distance(pos/ZOOM,pi2.xy)*ZOOM; \n    //loat v= length(pi0.xy-pi0.zw);\n    \n    float v =  getDist(nb[0]);\n    return vec4(d0,d1,d2,v);\n}\n\nvoid mainImage( out vec4 O, in vec2 p ){\n\n    //float cid = fract(float(i2xy(idn).x)  /10.);\n    float vol=RRADIUS*ZOOM*(1.+MB);\n    \n    vec4 d = Voronoi(p);\n    float  df=smin(smin(d.x,d.y,vol*MB),d.z,vol*MB);\n    \n    float foam= clamp(1.-.2*smoothstep(vol,vol*.9 ,d.y)-.3*smoothstep(vol,vol*.9 ,d.z),0.,1.);\n    vec3  col = (.7+.3*cos(vec3(2,4,0)-d.w*6.))* vec3(.99*foam,.3+.7*foam,1.-.1*foam);\n\n    \n    col *= smoothstep(vol,vol*.8,df);   \n    \n\tO = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//configurable settings:\n#define NP 10000.  \n#define dt 1.5 //time delta\n#define L 2. //particle radius\n#define GR .1 //gravity\n#define SUBSTEP 2 //used with plugin and paint calls>1. Calculate other buffers only on N-th frame\n\n#define MB 0.  //metaball effect\n#define NN 21  //neighbors: 5=1st level, 21=2nd level, 85=3rd level\n#define NNN 1  //solve just current particle \n#define GRIDSIZE 400. //grid size\n#define NGH 1000 \n#define ZERO  min(iFrame,0)\n#define N ivec2(int(sqrt(NP)),int(sqrt(NP)))\n#define size min(vec2(GRIDSIZE*iResolution.x/iResolution.y,GRIDSIZE),vec2(iResolution.xy))\n#define RRADIUS L *  min(iResolution.y/GRIDSIZE,1.)\n#define ZOOM (iResolution.y/size.y)\n#define mouse (iMouse/ZOOM)\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define GETTERS ivec4 getClosest(ivec2 p){ return floatBitsToInt(texel(iChannel2, p));} \\\nivec4 getNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nivec4[2] getNeighbor2(int id){ uvec4 v= floatBitsToUint(texel(iChannel1, i2xy(id))); return ivec4[2](ivec4(v&65535u), ivec4(v>>16)); }\\\nvec4 getParticle(int id,out bool ghost){ vec4 p= texel(iChannel0, i2xy(id));ghost=min(p.x,p.y)<0.;return vec4(abs(p.xy),p.zw); }\\\nfloat getDist(int id){return texel(iChannel3, i2xy(id)).x;}\n\nconst int tot_n = N.x*N.y;\n\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle physics\n\nGETTERS\n\nbool gh;\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        int id = xy2i(p);\n\n        if(iFrame<2 || U==vec4(0))\n        {\n            U.xy = L+size*vec2(p)*mat2(1,-.001,0,1)/vec2(N);\n\t\t\tU.zw = U.xy-vec2(0.01);\n      \t\treturn;\n        }\n\n        //get neighbors\n        vec4[NN] a; int[NN] pi;\n        float FF = 1.- getDist(id); //reduce DT if any collision is expected before end of time step\n        \n        \n        a[0] = getParticle(id,gh);\n        pi[0]=id;\n        //ivec4 cp = getNeighbor(id);\n        ivec4 cp = getClosest(ivec2(a[0].xy*(2.-FF)- a[0].zw*(1.-FF)));\n        for(int i =0;i<4;i++){\n            pi[1+i]=cp[i];\n            a[1+i]= getParticle(cp[i],gh); \n#if (NN>5)\n            ivec4 cp2 = getNeighbor(cp[i]);\n            for(int j =0;j<4;j++) {\n                pi[5+i*4+j]=cp2[j];\n                a[5+i*4+j]= getParticle(cp2[j],gh); \n#if (NN>21)\n                    ivec4 cp3 = getNeighbor(cp2[j]);\n                    for(int l =0;l<4;l++) {\n                        pi[21+i*16+j*4+l]=cp3[l];\n                        a[21+i*16+j*4+l]= getParticle(cp3[l],gh); \n                    }\n#endif\n            }\n#endif            \n        }\n        \n        //update positions\n        for(int i =0;i<NN;i++){    \n              //force\n            float an=iTime/3. ;\n            vec2 f= GR*  mat2(cos(an),sin(-an),sin(an),cos(an)) *vec2(0.,-1.);\n            if( iMouse.z>0.) f= - GR*exp(-length(a[0].xy- iMouse.xy/iResolution.xy*size)/L/200.)*normalize(a[0].xy- iMouse.xy/iResolution.xy*size);\n\n            if (iFrame<180) f*=.1; //warming\n            \n            //verlet integration\n            vec2 po=a[i].zw, p = a[i].xy, dp= p-po;\n            if(i>=NNN) {f*=FF;dp*=FF;}  //freeze 1st level\n           \n            vec2 pn= p +dp + .5*dt*dt *f;  \n            a[i]=vec4(pn,p);          \n        }         \n            \n        //CONSTRAINTS:\n        //for(int k=0;k<5;k++)  for(int i =0;i<NNN;i++) { //NO ITERATIONS, IT WON'T WORK\n        {   int i=0;  //just check current particle       \n            // collisions\n            for(int j =i+1;j<NN;j++){  \n                vec2 dist=a[i].xy -a[j].xy; \n                if(pi[i]==pi[j] )continue;\n                if(dot(dist,dist)<4.*L*L ){\n                    float d =length(dist);\n                    vec2 m=(a[i].xy+ a[j].xy)*.5,\n                         d0= (1.001- d/2./L)*(m-a[i].xy),\n                         d1= (1.001- d/2./L)*(m-a[j].xy),\n                         v0= a[i].xy-a[i].zw,\n                         v1= a[j].xy-a[j].zw,\n                         n= normalize(a[i].xy -a[j].xy),\n                         vm= (v0+v1)*.5,\n                         vn= n* min(dot(n,v0-v1),0.)*.5;\n                         \n                    v0= vm-vn;v1=vm+ vn;\n                    a[i]=vec4(a[i].xy- d0,a[i].xy- d0- v0);\n                    a[j]=vec4(a[j].xy- d1,a[j].xy- d1- v1 );\n                }\n           } \n           \n           //wall\n            vec2 p=a[i].zw, pn = a[i].xy;\n            if(pn.y<L) { p.y= 2.*L-p.y; pn.y=2.*L-pn.y;  }\n            if(pn.x<L) { p.x= 2.*L-p.x; pn.x=2.*L-pn.x; }\n            if(pn.x>-L+size.x) { p.x= -2.*L+2.*size.x-p.x; pn.x= -2.*L+2.*size.x-pn.x;}\n            if(pn.y>-L+size.y) { p.y= -2.*L+2.*size.y-p.y; pn.y= -2.*L+2.*size.y-pn.y;}\n            a[i]=vec4(pn,p);                    \n        }\n         \n        U=a[0];\n        \n        bool ghost=true;\n        ivec4 nb = getClosest(ivec2(U.xy));\n        for(int i = 0; i<4; i++)\n        {\n            if(nb[i]==id) {ghost=false; break;}\n        }\n        if(ghost) U.xy=-U.xy;\n        \n    }\n    else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particcle connection\n\nGETTERS\n\n\n//sorting closest 4 particles\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp,ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n    if((iFrame%SUBSTEP)>0 && iFrame>20) {U=texelFetch(iChannel1,p,0);return; }\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < NGH; i++)\n    {\n        //sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort  \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(id); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(nc[i]); \n    }\n    \n    ivec4 nb = getNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n         ivec4 nbb = getNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[j]); \n        }\n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position\n\nGETTERS\n\nivec2 cross_distribution(int i, int j)\n{\n    return (1<<j) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\nbool ghost;\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id,ghost).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.w > dtemp){\n        if(d.x > dtemp)\n        {\n            d = vec4(dtemp, d.xyz);\n            u = ivec4(utemp, u.xyz);\n        }\n        else if(d.y > dtemp && dtemp >= d.x)\n        {\n            d.yzw = vec3(dtemp, d.yz);\n            u.yzw = ivec3(utemp, u.yz);\n        }\n        else if(d.z > dtemp && dtemp >= d.y)\n        {\n            d.zw = vec2(dtemp, d.z);\n            u.zw = ivec2(utemp, u.z);\n        }\n        else // if(d.w > dtemp && dtemp >= d.z) \n        {\n            d.w = dtemp;\n            u.w = utemp;\n        }\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = getClosest(p);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid sortPart(int id)\n{\n\n    ivec4 nb = getNeighbor(id);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen\n    \n    ivec2 p = ivec2(pos);\n    if((iFrame%SUBSTEP)>0  && iFrame>20) {U=texelFetch(iChannel2,p,0);return; }\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    sortpos(p); //resort this position, cause particles are moving\n    \n    //jump flood sorting; minimized gere, raising to 12 or 16 has small effect and  high impact on framerate  \n    for(int i = ZERO; i < 4; i++)\n    {\n        ivec2 p2 =p+cross_distribution(i,0);             \n        sortpos(p2); \n         p2 =p+cross_distribution(i,(iFrame%3 )+1);             \n        sortpos(p2); \n    }\n    \n    \n    // sort neighbors of closest particles\n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//collision estimate\n\nGETTERS\n\nbool gh;\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if((iFrame%SUBSTEP)>0  && iFrame>20) {U=texelFetch(iChannel3,p,0);return; }\n    if(p.x < N.x && p.y < N.y)\n    {\n        int id = xy2i(p);\n        \n\n        //get neighbors\n        vec4[NN] a; int[NN] pi;\n        a[0] = getParticle(id,gh);\n        pi[0]=id;\n        //ivec4 cp = getNeighbor(id);\n        ivec4 cp = getClosest(ivec2(a[0].xy*(2.)- a[0].zw*(1.)));\n        for(int i =0;i<4;i++){\n            pi[1+i]=cp[i];\n            a[1+i]= getParticle(cp[i],gh); \n#if (NN>5)\n            ivec4 cp2 = getNeighbor(cp[i]);\n            for(int j =0;j<4;j++) {\n                pi[5+i*4+j]=cp2[j];\n                a[5+i*4+j]= getParticle(cp2[j],gh); \n#if (NN>21)\n                    ivec4 cp3 = getNeighbor(cp2[j]);\n                    for(int l =0;l<4;l++) {\n                        pi[21+i*16+j*4+l]=cp3[l];\n                        a[21+i*16+j*4+l]= getParticle(cp3[l],gh); \n                    }\n#endif\n            }\n#endif            \n        }\n        \n        //update positions\n        for(int i =0;i<NN;i++){    \n              //force\n            float an=iTime/2. +1.;\n            vec2 f=( iMouse.z>0.?GR*( iMouse.xy/iResolution.y-iResolution.xy/iResolution.y*.5): mat2(cos(an),sin(-an),sin(an),cos(an)) *vec2(0.,-GR));\n            \n            //verlet integration\n            vec2 po=a[i].zw, p = a[i].xy, dp= p-po;\n            \n           \n            vec2 pn= p +dp + .5*dt*dt *f;  \n            a[i]=vec4(pn,p);          \n        }         \n         \n        // get minimum collision time  for each neighbor \n        float tmin = 1.;  //default = no collision\n        {   int i=0;  \n            \n            for(int j =i+1;j<NN;j++){  \n               \n                if(pi[i]==pi[j] )continue;\n\n                vec2 d1 = a[i].xy -a[j].xy, d0=a[i].zw -a[j].zw -d1;\n                float c= (dot(d1,d1)- 4.*L*L)/dot(d0,d0), b = - dot(d0,d1) / dot(d0,d0), det = (b*b - c), t1=b + sqrt(det),  t2=b - sqrt(det);\n\n                tmin =min(tmin,  ( abs(t1-.5)<.5 ? t1: abs(t2-.5)<.5 ? t2:1.)); //get collision time              \n           }                  \n        }\n         \n        U=vec4(tmin); \n        \n\n        \n    }\n    else discard;\n}","name":"Buffer D","description":"","type":"buffer"}]}