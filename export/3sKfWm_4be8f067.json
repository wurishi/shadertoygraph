{"ver":"0.1","info":{"id":"3sKfWm","date":"1613085601","viewed":58,"name":"Jumpeter - RayMarching 01","username":"Jumpeter","description":"First try","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float THRESHOLD = 0.000001;\nconst float MAX_SDF_VALUE = 20.0;\nconst int MAX_STEPS = 1000;\n\n// PixelBuffers\nvec3 BASE_COLOR = vec3(0.0);\nfloat DEPTH = 0.0;\nvec3 NORMAL = vec3(0.0);\n\nfloat sceneComplexity = 0.0;\n\nmat3 worldSpaceToCameraSpace(vec3 newZ/*Camera Direction*/)\n{\n    vec3 newX = normalize(cross(vec3(0.0, 1.0, 0.0), newZ));\n    vec3 newY = cross(newZ, newX);\n    \n    return mat3(newX, newY, newZ);\n}\n/*\nvec3 marchSphereLight(SphereLight l, vec3 rayStart, int lightSamples)\n{\n    vec3 illumination = vec3(0.0);\n    vec3 rayDirection;\n\n    for(int i = 0; i < lightSamples; i++)\n    {\n        \n    }\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    RANDOM_SEED = fract(iTime + fragCoord.x/iResolution.x * fragCoord.y/iResolution.y);\n    // Set up screen data\n    float screenDiagonal = distance(iResolution.xy, vec2(0.0, 0.0));\n    vec2 uv = 2.0 * ((fragCoord - iResolution.xy*0.5)/screenDiagonal);\n    \n    // Create camera data\n    vec3 cameraPosition = vec3(0.0, 15.0, -13.5);\n    vec3 cameraDirection = normalize(vec3(0.0, -1.0, 1.0));\n    float cameraFOV = 3.14159265359*0.2;\n    \n    // Create marching ray\n    vec3 rayDirection = normalize(vec3(uv, 1.0/tan(cameraFOV*0.5)));\n    rayDirection = worldSpaceToCameraSpace(cameraDirection) * rayDirection;\n    vec3 rayPosition = cameraPosition;\n    \n    // Create scene elements\n    Sphere sphere1 = Sphere(vec3(1.5, 1.0, 0.0), 1.0, vec3(0.8, 0.5, 0.4), 0.0);\n    Plane plane1 = Plane(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.5, 0.5, 0.5), 0.0);\n    Box cube1 = Box(vec3(-1.5, 1.0, 0.0), vec3(1.0), 0.2, vec3(0.4, 0.8, 0.6), 0.0);\n    SphereLight light1 = SphereLight(Sphere(vec3(sin(iTime*0.5)*3.0, 3.0, cos(iTime*0.75)*3.0), 0.25, vec3(1.0, 0.85, 0.6), 0.0), 15.0);\n    \n    // Evaluate distance field\n    float SDF;\n    int stepCounter = 0;\n    \n    while(SDF < MAX_SDF_VALUE && stepCounter < MAX_STEPS)\n    {\n        sceneComplexity++;\n        \n        // Evaluate the single objects sdf\n        sphereSDF(sphere1, rayPosition, sphere1.sdf);\n        planeSDF(plane1, rayPosition, plane1.sdf);\n        boxSDF(cube1, rayPosition, cube1.sdf);\n        sphereSDF(light1.shape, rayPosition, light1.shape.sdf);\n        \n        // Whole scene sdf\n        SDF = min(sphere1.sdf, min(plane1.sdf, min(cube1.sdf, light1.shape.sdf)));\n        \n        // If ray hasn't hit anything, march\n        if(SDF > THRESHOLD) rayPosition += rayDirection*SDF;\n        \n        // once hit the surface we can extrapolate some data\n        else\n        {\n            sceneComplexity += 3.0;\n        \n            // Depth is the distance from the camera to the hit surface\n            DEPTH = distance(cameraPosition, rayPosition);\n            // Color the pixel with the color of the negative sdf (which is the one hit)\n            BASE_COLOR += sphere1.color * max(0.0, -sign(sphere1.sdf-THRESHOLD)) +\n                          plane1.color * max(0.0, -sign(plane1.sdf-THRESHOLD)) +\n                          cube1.color * max(0.0, -sign(cube1.sdf-THRESHOLD)) +\n                          light1.shape.color * max(0.0, -sign(light1.shape.sdf-THRESHOLD));\n            \n            // evaluate surface Normal\n            vec3 rayPositionX = rayPosition + vec3(THRESHOLD*10.0, 0.0, 0.0);\n            vec3 rayPositionY = rayPosition + vec3(0.0, THRESHOLD*10.0, 0.0);\n            vec3 rayPositionZ = rayPosition + vec3(0.0, 0.0, THRESHOLD*10.0);\n            \n            float SDFX = min(sphereSDF(sphere1, rayPositionX),\n              \t\t\t min(planeSDF (plane1,  rayPositionX),\n                  \t\t\t boxSDF   (cube1,   rayPositionX)));\n            float SDFY = min(sphereSDF(sphere1, rayPositionY),\n              \t\t\t min(planeSDF (plane1,  rayPositionY),\n                  \t\t\t boxSDF   (cube1,   rayPositionY)));\n            float SDFZ = min(sphereSDF(sphere1, rayPositionZ),\n              \t\t\t min(planeSDF (plane1,  rayPositionZ),\n                  \t\t\t boxSDF   (cube1,   rayPositionZ)));\n            \n            NORMAL = normalize(vec3(SDFX - SDF, SDFY - SDF, SDFZ - SDF));\n            \n            break;\n        }\n        \n        stepCounter++;\n    }\n    \n    // move the ray slightly outside of the hit volume\n    rayPosition += NORMAL * -SDF + NORMAL * THRESHOLD * 1.5;\n    vec3 surfacePosition = rayPosition; // Start position of the shadow ray\n    /*\n    float shadowCasterDistance, shadowOpacity = 1.0;\n    float shadowSoftCoefficient = 32.0; // Lower Value is Softer\n    \n    vec3 lightDirection = normalize(-vec3(0.4, 1.0, -0.25));\n    \n    BASE_COLOR *= max(0.0, dot(NORMAL, -lightDirection));\n    \n    stepCounter = 0;\n    \n    while(SDF < MAX_SDF_VALUE && stepCounter < MAX_STEPS)\n    {\n    \tSDF = min(sphereSDF(sphere1, rayPosition),\n              min(planeSDF(plane1, rayPosition),\n                  boxSDF(cube1, rayPosition)));\n        \n        shadowCasterDistance = distance(rayPosition, sceneHitPosition);\n        shadowOpacity = min(shadowOpacity, shadowSoftCoefficient*SDF/shadowCasterDistance);\n        \n        if(SDF > THRESHOLD) rayPosition -= lightDirection*SDF;\n        else break;\n        \n        stepCounter++;\n    }\n    \n    BASE_COLOR *= pow(shadowOpacity, 0.5);\n    */\n    \n    vec3 illumination = vec3(0.0);\n    int lightSamples = 3;\n    \n    for(int i = 0; i < lightSamples; i++)\n    {\n        rayPosition = surfacePosition;\n        vec3 randomVector = normalize(vec3(1.0)) * (vec3(random(), random(), random()) * 2.0 - 1.0) * light1.shape.radius;\n        //randomVector = vec3(1.0, 0.0, 0.0) * light1.shape.radius;\n        rayDirection = normalize(light1.shape.position + randomVector - surfacePosition);\n        \n        stepCounter = 0; SDF = 1.0;\n        while(SDF < MAX_SDF_VALUE && stepCounter < MAX_STEPS)\n        {\n            sceneComplexity++;\n            \n            sphereSDF(sphere1, rayPosition, sphere1.sdf);\n            planeSDF(plane1, rayPosition, plane1.sdf);\n            boxSDF(cube1, rayPosition, cube1.sdf);\n            sphereSDF(light1.shape, rayPosition, light1.shape.sdf);\n            \n            SDF = min(sphere1.sdf, min(plane1.sdf, min(cube1.sdf, light1.shape.sdf)));\n            \n            if(SDF > THRESHOLD) rayPosition += rayDirection*SDF;\n            else\n            {\n                if(light1.shape.sdf <= THRESHOLD)\n                {\n                    illumination += light1.shape.color * vec3(light1.intensity) *\n                                    vec3(1.0 / dot(rayPosition - surfacePosition, rayPosition - surfacePosition));\n                }\n                \n                break;\n            }\n            stepCounter++;\n        }\n    }\n    \n    illumination *= 1.0/float(lightSamples);\n    illumination += vec3(0.05, 0.075, 0.2) * 3.0;\n    \n    // Output to screen\n    //fragColor = vec4(pow(1.0 - 1.0/sceneComplexity, 30.0));\n    fragColor = vec4(max(min(pow(BASE_COLOR * illumination, vec3(2.2)), 1.0), 0.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ################################################################################################################################\n\n// SHAPES DEFINITIONS\n\nstruct Sphere { vec3 position; float radius; vec3 color; float sdf; };\nstruct Plane { vec3 position; vec3 normal; vec3 color; float sdf; };\nstruct Box { vec3 position; vec3 size; float roundness; vec3 color; float sdf; };\n\n// ################################################################################################################################\n\n// LIGHTS DEFINITIONS\n\nstruct SphereLight { Sphere shape; float intensity; };\n\n// ################################################################################################################################\n\n// DISTANCE FIELDS EVALUATIONS\n\nvoid sphereSDF(Sphere s, vec3 rayPosition, out float sdf) { sdf = distance(s.position, rayPosition) - s.radius; }\nfloat sphereSDF(Sphere s, vec3 rayPosition) { return distance(s.position, rayPosition) - s.radius; }\n\nvoid planeSDF(Plane p, vec3 rayPosition, out float sdf) { sdf = dot((rayPosition - p.position), p.normal); }\nfloat planeSDF(Plane p, vec3 rayPosition) { return dot((rayPosition - p.position), p.normal); }\n\nvoid boxSDF(Box b, vec3 rayPosition, out float sdf)\n{\n    rayPosition = abs(rayPosition - b.position) - (b.size - b.roundness); //relativa al vertice quandrante positivo\n    \n    sdf = length(max(rayPosition, 0.0)) + min(max(rayPosition.x, max(rayPosition.y, rayPosition.z)), 0.0) - b.roundness;\n}\nfloat boxSDF(Box b, vec3 rayPosition)\n{\n    rayPosition = abs(rayPosition - b.position) - (b.size - b.roundness); //relativa al vertice quandrante positivo\n    \n    return length(max(rayPosition, 0.0)) + min(max(rayPosition.x, max(rayPosition.y, rayPosition.z)), 0.0) - b.roundness;\n}\n\n// ################################################################################################################################\n\n// LIGHT EVALUATIONS\n\nfloat RANDOM_SEED = 0.0;\nfloat random()\n{\n    RANDOM_SEED += 0.1;\n    return fract(sin(RANDOM_SEED*(91.3458)) * 47453.5453);\n}\n\n","name":"Common","description":"","type":"common"}]}