{"ver":"0.1","info":{"id":"NsjBDy","date":"1647002877","viewed":137,"name":"scnoise","username":"jrfrisvad","description":"Sparse convolution noise [Frisvad and Wyvill, Fast High-Quality Noise, GRAPHITE 2007]","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***\n  Sparse convolution noise based on the GRAPHITE 2007 paper:\n\n  Fast high-quality noise\n\n  By authors: Jeppe Revall Frisvad, Geoff Wyvill\n\n  Code written by Jeppe Revall Frisvad, 2016.\n  https://people.compute.dtu.dk/jerf/code/noise/\n  \n  The method in the paper is here rewritten as a closed function\n  (which is simple to implement but much more expensive than the\n  method described in the paper).\n*/\n\n// Knuth pseudo-random number generator\nconst float BEE = 3125.0;\nconst float CEE = 49.0;\nconst float RANGE = 65536.0;\nfloat rnd(inout float t)\n{\n  t = mod(t*BEE + CEE, RANGE);\n  return t/RANGE;\n}\nfloat cubic(vec3 v)\n{\n  float x = 1.0 - dot(v, v)*4.0;\n  return step(0.0, x)*x*x*x;\n}\n// sparse convolution noise\nvec3 scnoise(vec3 p)\n{\n  const float sources = 30.0;\n  float a = 0.8*pow(sources, -1.0/3.0);\n  vec3 pi0 = floor(p - 0.5);\n  vec3 result = vec3(0.0);\n  for(float i = 0.0; i < 7.5; ++i)\n  {\n    vec3 corner = mod(vec3(i, floor(i*0.5), floor(i*0.25)), 2.0);\n    vec3 pi = pi0 + corner;\n    float t = mod(6.0*sources*(pi.x + pi.y*1000.0 + pi.z*576.0 + pi.x*pi.y*pi.z*3.0), RANGE);\n    for(int j = 0; j < int(sources); ++j)\n    {\n      vec3 c = a*vec3(rnd(t), rnd(t), rnd(t))*(j < int(sources)/2 ? 1.0 : -1.0);\n      vec3 xi = vec3(rnd(t), rnd(t), rnd(t));\n      vec3 x = pi + xi;\n      result += c*cubic(x - p);\n    }\n  }\n  return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float noise_scale = 50.0;\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.x;\n\n  vec3 t = normalize(vec3(0.5));\n  vec3 b = normalize(cross(t, vec3(0.0, 0.0, 1.0)));\n  vec3 npos = noise_scale*vec3(uv, iTime*0.01);     // grid aligned\n  npos = npos.x*t + npos.y*b + cross(t, b)*npos.z;  // skewed\n\n  // Output to screen\n  fragColor = vec4(scnoise(npos)*0.5 + 0.5, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}