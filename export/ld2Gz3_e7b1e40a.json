{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\t\nstruct Material {\n\tvec3 ambient;\n\tvec3 diffuse;\n\tvec3 specular;\n\tfloat shine;\n\tfloat reflectivity;\n};\n\t\nstruct Sphere {\n\tvec3 origin;\n\tfloat radius;\n};\n\nstruct Plane {\n\tvec3 direction;\n\tfloat dis;\n};\n\t\nstruct PointLight {\n\tvec3 origin;\n\tvec3 color;\n};\n\nstruct Output {\n\tvec3 origin;\n\tvec3 normal;\n\tfloat dis;\n\tMaterial material;\n};\n\nconst float PI = 3.1415926536;\n\n#define planeCount 1\nPlane plane[planeCount];\n\n#define sphereCount 5\nSphere sphere[sphereCount];\n\n#define lightCount 6\nPointLight light[lightCount];\n\nvec3 eye;\n\nconst int materialCount = 2;\nMaterial material[2];\n\nSphere makeSphere(float offset) {\n\tfloat t = iTime + PI * 2.0 * offset;\n\tfloat x = cos(t) * 3.0;\n\tfloat z = sin(t * 2.0) * 1.5;\n\treturn Sphere(vec3(x, 0.8, z), 0.8);\n}\n\nvoid makeScene() {\n\t{\n\t\tmaterial[0] = Material(\n\t\t\tvec3(0.0, 0.0, 0.0),\n\t\t\tvec3(0.3, 0.3, 0.3),\n\t\t\tvec3(1.0, 1.0, 1.0),\n\t\t\t80.0,\n\t\t\t0.4\n\t\t);\n\t\t\n\t\tmaterial[1] = Material(\n\t\t\tvec3(0.0, 0.0, 0.0),\n\t\t\tvec3(0.5, 0.5, 0.5),\n\t\t\tvec3(1.0, 1.0, 1.0),\n\t\t\t40.0,\n\t\t\t0.6\n\t\t);\n\t}\n\t\n\t{\n\t\tplane[0].direction = vec3(0.0, 1.0, 0.0);\n\t\tplane[0].dis = 0.0;\n\n\t\tsphere[0] = makeSphere(0.0 / 5.0);\n\t\tsphere[1] = makeSphere(1.0 / 5.0);\n\t\tsphere[2] = makeSphere(2.0 / 5.0);\n\t\tsphere[3] = makeSphere(3.0 / 5.0);\n\t\tsphere[4] = makeSphere(4.0 / 5.0);\n\t}\n\n\t{\n\t\tfloat r = 4.0;\n\t\tfloat y = 4.0;\n\t\t\n\t\tfloat t0 = -iTime + PI * 0.0;\n\t\tlight[0].origin = vec3(cos(t0) * r, y, sin(t0) * r);\n\t\tlight[0].color = vec3(0.5, 0.0, 0.0);\n\n\t\tfloat t1 = -iTime + PI * 0.333333;\n\t\tlight[1].origin = vec3(cos(t1) * r, y, sin(t1) * r);\n\t\tlight[1].color = vec3(0.4, 0.4, 0.0);\n\n\t\tfloat t2 = -iTime + PI * 0.666666;\n\t\tlight[2].origin = vec3(cos(t2) * r, y, sin(t2) * r);\n\t\tlight[2].color = vec3(0.0, 0.5, 0.0);\n\n\t\tfloat t3 = -iTime + PI * 1.0;\n\t\tlight[3].origin = vec3(cos(t3) * r, y, sin(t3) * r);\n\t\tlight[3].color = vec3(0.0, 0.4, 0.4);\n\n\t\tfloat t4 = -iTime + PI * 1.333333;\n\t\tlight[4].origin = vec3(cos(t4) * r, y, sin(t4) * r);\n\t\tlight[4].color = vec3(0.0, 0.0, 0.5);\n\n\t\tfloat t5 = -iTime + PI * 1.666666;\n\t\tlight[5].origin = vec3(cos(t5) * r, y, sin(t5) * r);\n\t\tlight[5].color = vec3(0.4, 0.0, 0.4);\n\t}\n}\n\nvoid intersectSphere(const Sphere sphere, const Ray ray, Material material, inout Output o) {\n\tvec3 d = ray.origin - sphere.origin;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = dot(ray.direction, d);\n\tfloat c = dot(d, d) - sphere.radius * sphere.radius;\n\t\n\tfloat g = b*b - a*c;\n\t\n\tif(g > 0.0) {\n\t\tfloat dis = (-sqrt(g) - b) / a;\n\t\tif(dis > 0.0 && dis < o.dis) {\n\t\t\to.dis = dis;\n\t\t\to.origin = ray.origin + ray.direction * dis;\n\t\t\to.normal = (o.origin - sphere.origin) / sphere.radius;\n\t\t\to.material = material;\n\t\t}\n\t}\n}\n\nvoid intersectPlane(const Plane plane, const Ray ray, Material material, inout Output o) {\n\tfloat dis = plane.dis - dot(plane.direction, ray.origin) / dot(plane.direction, ray.direction);\n\t\n\tbool hit = false;\n\tif(dis > 0.0 && dis < o.dis) {\n\t\to.dis = dis;\n\t\to.origin = ray.origin + ray.direction * dis;\n\t\to.normal = faceforward(plane.direction, plane.direction, ray.direction);\n\t\to.material = material;\n\t\t\n\t\t// checkerboard hack\n\t\tvec2 cb = floor(o.origin.xz);\n\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n\t\to.material.ambient *= cb2 + 1.2;\n\t\to.material.diffuse *= cb2 + 1.2;\n\t\to.material.specular *= cb2 + 1.2;\n\t}\n}\n\n\nvec3 illuminatePointLight(PointLight light, Output o) {\n\tvec3 v = normalize(light.origin - o.origin);\n\t\n\tfloat d = clamp(dot(o.normal, v), 0.0, 1.0);\n\tfloat s = 0.0;\n\tif(d > 0.0) {\n\t\tvec3 eyeV = normalize(eye - o.origin);\n\t\tvec3 h = normalize(v + eyeV);\n\t\ts = pow(clamp(dot(o.normal, h), 0.0, 1.0), o.material.shine);\n\t}\n\t\n\tvec3 diffuse  = o.material.diffuse  * light.color * d;\n\tvec3 specular = o.material.specular * light.color * s;\n\treturn diffuse + specular;\n}\n\nvec3 illumiate(Output o) {\n\tvec3 color = o.material.ambient;\n\t\n\tfor(int i = 0; i < lightCount; ++i) {\n\t\tcolor += illuminatePointLight(light[i], o);\n\t}\n\t\n\tfloat dis = length(eye - o.origin);\n\t\n\tdis -= 4.0;\n\tdis *= 0.07;\n\tdis = clamp(dis, 0.0, 1.0);\n\t\n\treturn color * (1.0 - dis);\n}\n\nOutput raytraceIteration(Ray ray) {\n\tOutput o;\n\to.origin = vec3(0.0, 0.0, 0.0);\n\to.normal = vec3(0.0, 0.0, 1.0); \n\to.dis = 1.0e4;\n\to.material = Material(\n\t\tvec3(0.0, 0.0, 0.0),\n\t\tvec3(0.0, 0.0, 0.0),\n\t\tvec3(0.0, 0.0, 0.0),\n\t\t0.0,\n\t\t0.0\n\t);\n\n\tfor(int i = 0; i < planeCount; ++i) {\n\t\tintersectPlane(plane[i], ray, material[0], o);\n\t}\n\tfor(int i = 0; i < sphereCount; ++i) {\n\t\tintersectSphere(sphere[i], ray, material[1], o);\n\t}\n\n\treturn o;\n}\n\nvec3 raytrace(Ray ray) {\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\t\n\tfloat reflectivity = 1.0;\n\t\n\tfor(int i = 0; i < 4; ++i) {\n\t\tOutput o = raytraceIteration(ray);\n\t\t\n\t\tif(o.dis >= 1.0e3) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcolor += illumiate(o) * reflectivity;\n\t\t\n\t\tfloat l = length(ray.origin - o.origin) + 0.0001;\n\t\tcolor -= 0.02 / l;\n\n\t\treflectivity *= o.material.reflectivity;\n\t\tif(reflectivity < 0.05) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tray = Ray(o.origin + o.normal * 0.0001, reflect(normalize(o.origin - ray.origin), o.normal));\n\t}\n\t\n\treturn color;\n}\n\nRay getPrimaryRay(vec3 origin, vec3 lookat, vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.xx;\n\n\tvec3 forward = normalize(lookat - origin);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\t\n\tRay ray;\n\t\n\tray.origin = origin;\n\tray.direction = normalize(right * uv.x + up * uv.y + forward);\n\t\n\teye = ray.origin;\n\t\n\treturn ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tmakeScene();\n\t\n\tfloat xo = (iMouse.x * 2.0 / iResolution.x - 1.0) * PI;\n\tfloat yo = (0.5 - (iMouse.y / iResolution.y)) * 4.0 + 2.01;\n\t\n\teye = vec3(cos(iTime * 0.1 + xo) * 5.0, yo, sin(iTime * 0.1 + xo) * 5.0);\n\t\n\tvec3 lookat = vec3(0.0, 0.0, 0.0);\n\t\n\tRay ray = getPrimaryRay(eye, lookat, fragCoord);\n\t\n\tvec3 color = raytrace(ray);\n\t\n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2Gz3","date":"1391940630","viewed":2444,"name":"Lights on","username":"McZonk","description":"Porting my thesis from 2006 to Shadertoy.\nNo shadows and occlusions yet.","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}