{"ver":"0.1","info":{"id":"tt3cWH","date":"1608941397","viewed":198,"name":"Conformal Hyperbolic Tiling","username":"bulatov","description":"Another attempt to learn shaders use for conformal mapping. Based on code by @knightly with help from @mla","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["conformal","tiling","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// conformal mapping of hyperbolic tiling by Vladimir Bulatov http://bulatov.org\n// \n// based on shader by knightly \n// https://www.shadertoy.com/view/4sf3zX\n// triangular groups tessellations. Coxeter group p-q-r. Stereographic projection. \n// adapted from fragmentarium script.see: http://www.fractalforums.com/fragmentarium/triangle-groups-tessellation/\n// Licence: free.\n// the type of the space embedding the tessellation depend on the value: 1/p+1/q+1/r\n// if >1 its the sphere\n// if =1 its the euclidean plane\n// if <1 its the hyperbolic plane\n//  \n// Distance estimation to lines and vertices is used for antialiasing.\n// You can still improve quality by using antialiasing.\n\n\n// Iteration number.\nconst int Iterations=32;\n\n//these are the p, q and r parameters that define the coxeter/triangle group\nconst int pParam=2;// Pi/p: angle beween reflexion planes a and b .\nconst int qParam=3;// Pi/q: angle beween reflexion planes b and c .\nconst int rParam=7;// Pi/r: angle beween reflexion planes c and a .\n\n// U,V,W are the 'barycentric' coordinate for the vertex.\nfloat U=1.;\nfloat V=1.;\nfloat W=0.;\n\nconst float SRadius=0.01;//Thikness of the lines\n\n//Colors\nconst vec3 segColor=vec3(0.,0.,0.);\nconst vec3 backGroundColor=vec3(1.,1.,1.);\n\n#define PI 3.1415926\nvec3 nb,nc;//with na(=vec3(1,0,0)) these are the normals of the reflexion planes\nvec3 p,q;//the vertex\nvec3 pA,pB,pC;//\"vertices\" of the \"triangle\" made by the reflexion planes\n\nfloat spaceType=0.;\n\n\n//complex multiplication \nvec2 cMul(vec2 a, vec2 b){\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b,b);\n  return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d;\n}\n// complex inverse \nvec2 cInverse(vec2 a) {\n\treturn\tvec2(a.x,-a.y)/dot(a,a);\n}\n\n// complex exponent\nvec2 cExp(vec2 p) {\n\treturn vec2(exp(p.x) * cos(p.y), exp(p.x) * sin(p.y));\n}\n// complex hyperbolic tangent \nvec2 cTanh(vec2 z){\n\n  vec2 e = cExp(z);\n  vec2 e1 = cInverse(e);\n  return cDiv(e - e1,e + e1);\n        \n}\n// converts from band (-1 < y < 1) into unit disc\nvec2 band2disc(vec2 z){\n    return cTanh(z*(PI/4.));\n}\n\n// converts from band (-1 < y < 1) into unit disc\n// and calculates scaled pixel size \nvoid band2disc(inout vec2 p, inout float pixSize){\n\tfloat coeff = (PI/4.);\n\tvec2 pp = cTanh(p*coeff);\n    p = pp;\n\tpixSize *= coeff*length(vec2(1,0) - cMul(pp, pp));\n\t\n}\n\n\nfloat hdott(vec3 a, vec3 b){//dot product for \"time like\" vectors.\n\treturn spaceType*dot(a.xy,b.xy)+a.z*b.z;\n}\nfloat hdots(vec3 a, vec3 b){//dot product for \"space like\" vectors (these are duals of the \"time like\" vectors).\n\treturn dot(a.xy,b.xy)+spaceType*a.z*b.z;\n}\nfloat hlengtht(vec3 v){\n\treturn sqrt(abs(hdott(v,v)));\n}\nfloat hlengths(vec3 v){\n\treturn sqrt(abs(hdots(v,v)));\n}\n\nvec3 hnormalizet(vec3 v){//normalization of \"time like\" vectors.\n\tfloat l=1./hlengtht(v);\n\treturn v*l;\n}\n/*vec3 hnormalizes(vec3 v){//normalization of \"space like\" vectors.(not used)\n\tfloat l=1./hlengths(v);\n\treturn v*l;\n}*/\n/////////////////////////////////////////////////\n\n\nvoid init() {\n\tspaceType=float(sign(qParam*rParam+pParam*rParam+pParam*qParam-pParam*qParam*rParam));//1./pParam+1./qParam+1./rParam-1.;\n\n\tfloat cospip=cos(PI/float(pParam)), sinpip=sin(PI/float(pParam));\n\tfloat cospiq=cos(PI/float(qParam)), sinpiq=sin(PI/float(qParam));\n\tfloat cospir=cos(PI/float(rParam)), sinpir=sin(PI/float(rParam));\n\tfloat ncsincos=(cospiq+cospip*cospir)/sinpip;\n\n\t//na is simply vec3(1.,0.,0.).\n\tnb=vec3(-cospip,sinpip,0.);\n\tnc=vec3(-cospir,-ncsincos,sqrt(abs((ncsincos+sinpir)*(-ncsincos+sinpir))));\n\n\tif(spaceType==0.){//This case is a little bit special\n\t\tnc.z=0.25;\n\t}\n\n\tpA=vec3(nb.y*nc.z,-nb.x*nc.z,nb.x*nc.y-nb.y*nc.x);\n\tpB=vec3(0.,nc.z,-nc.y);\n\tpC=vec3(0.,0.,nb.y);\n\n\tq=U*pA+V*pB+W*pC;//the vertex is the weighted average of the vertices of the triangle\n\tp=hnormalizet(q);\n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<Iterations;i++){\n\t\tpos.x=abs(pos.x);\n\t\tfloat t=-2.*min(0.,dot(nb,pos)); pos+=t*nb*vec3(1.,1.,spaceType);\n\t\tt=-2.*min(0.,dot(nc,pos)); pos+=t*nc*vec3(1.,1.,spaceType);\n\t}\n\treturn pos;\n}\n\nfloat DD(float tha, float r){\n\treturn tha*(1.+spaceType*r*r)/(1.+spaceType*spaceType*r*tha);\n}\n\nfloat dist2Segment(vec3 z, vec3 n, float r){\n\t//pmin is the orthogonal projection of z onto the plane defined by p and n\n\t//then pmin is projected onto the unit sphere\n\t\n\t//we are assuming that p and n are normalized. If not, we should do: \n\t//mat2 smat=mat2(vec2(hdots(n,n),-hdots(p,n)),vec2(-hdott(p,n),hdott(p,p)));\n\tmat2 smat=mat2(vec2(1.,-hdots(p,n)),vec2(-hdott(p,n),1.));//should be sent as uniform\n\tvec2 v=smat*vec2(hdott(z,p),hdots(z,n));//v is the componenents of the \"orthogonal\" projection (depends on the metric) of z on the plane defined by p and n wrt to the basis (p,n)\n\tv.y=min(0.,v.y);//crops the part of the segment past the point p\n\t\n\tvec3 pmin=hnormalizet(v.x*p+v.y*n);\n\tfloat tha=hlengths(pmin-z)/hlengtht(pmin+z);\n\treturn DD((tha-SRadius)/(1.+spaceType*tha*SRadius),r);\n}\n\nfloat dist2Segments(vec3 z, float r){\n\tfloat da=dist2Segment(z, vec3(1.,0.,0.), r);\n\tfloat db=dist2Segment(z, nb, r);\n\tfloat dc=dist2Segment(z, nc*vec3(1.,1.,spaceType), r);\n\t\n\treturn min(min(da,db),dc);\n}\n\nfloat aaScale = 0.005;//anti-aliasing scale == half of pixel size.\n\nvec3 color(vec2 pos){\n\n    float phi = 0.25*iTime;\n    pos = cMul(pos, pos);\n    pos += vec2(cos(phi), sin(phi));\n    //band2disc(pos, aaScale);\n    aaScale = 0.5*length(fwidth(pos));\n\tfloat r=length(pos);\n    \n\tvec3 z3=vec3(2.*pos,1.-spaceType*r*r)*1./(1.+spaceType*r*r);\n\t//if(spaceType==-1. && r>=1.) return backGroundColor;//We are outside PoincarÃ© disc.\n\t\n\tz3=fold(z3);\n\t\n\tvec3 color=backGroundColor;\n\t\n\t//antialiasing using distance de segments and vertices (ds and dv) (see:https://iquilezles.org/articles/distance)\n\t{\n\t\tfloat ds=dist2Segments(z3, r);\n\t\tcolor=mix(segColor,color,smoothstep(-1.,1.,ds*0.5/aaScale));\n\t}\n\t\n\t//final touch in order to remove jaggies at the edge of the circle (for hyperbolic case)\n\t//if(spaceType==-1.) color=mix(backGroundColor,color,smoothstep(0.,1.,(1.-r)*0.5/aaScale));//clamp((1.-r)/aaScale.y,0.,1.));\n\treturn color;\n}\n\nvoid animUVW(float t){\n\tU=0.;//sin(t)*0.5+0.5;\n\tV=0.;//sin(2.*t)*0.5+0.5;\n\tW=1.;//sin(4.*t)*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float scaleFactor=2.5;\n\tvec2 uv = scaleFactor*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\taaScale = 1.1*scaleFactor/iResolution.y;\n\tanimUVW(0.125*PI*iTime);\n\tinit(); \n\tfragColor = vec4(color(uv),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}