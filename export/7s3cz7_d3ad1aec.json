{"ver":"0.1","info":{"id":"7s3cz7","date":"1653174583","viewed":115,"name":"Liminal Hell","username":"Hyeve","description":"This is what coding shaders late at night gets me, apparently....","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","glass","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 uv;\nvec3 cp,cn,cr,ss,oc,gl,vb;\nvec4 fc,cc;\nfloat tt,cd,sd,md,io,oa,td,tc;\nint es=0,ec;\n\n\nfloat bx(vec3 p,vec3 s){vec3 q=abs(p)-s;return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.));}\nfloat smin(float a, float b, float k){float h=clamp(0.5+0.5*(b-a)/k,0.,1.);return mix(b,a,h)-k*h*(1.-h);}\n\nvec3 snap(vec3 a, float d)\n{\n\treturn vec3(floor(a.x*d),floor(a.y*d),floor(a.z*d))/d;\n}\n\n\nfloat mp(vec3 p)\n{\n\t\tvec3 pp = p;\n\n\t\tp.z += tt*5.;\n\t\t\n\t\tp.x += sin(p.z/10.+tt*0.3)*2.;\n\t\tp = mod(p, 20.) - 10.;\n\t\tsd = bx(p,vec3(2,1,10.))-0.1;\n\t\tp.xz *= rot(45.*DTR);\n\t\tsd = smin(sd,bx(p, vec3(1,11,1)),10.);\n\t\tp.y = abs(p.y) - 5.;\n\t\tp.xz *= rot(45.*DTR);\n\t\tfloat rods = bx(p-vec3(10,-3,0), vec3(0.5,0.5,10))-0.1;\n\t\tsd = min(sd,rods);\n\t\tsd *= 0.5;\n\t\n\t\tsd = min(sd, length(pp-vec3(0,0,45))-10.);\n\t\tp=pp;\n\t\tfloat tube = abs(length(p.xy) - 10.)-0.001;\n\t\n\t\tsd = min(sd, tube);\n\t\n\t\tsd=abs(sd)-0.001;\n\t\n\t\tif(sd<0.01)\n\t\t{\t\n\t\t\tio=tube < sd + 0.01 ? 1.2 : -1.;\n\t\t\toc=io < 1. ? vec3(0.1,0.,0) + abs(p.y)*vec3(0.01,0.005,0.) : vec3(0.5,0.,0.3);\n\t\t\toa=io < 1. ? 0.8 : 0.6;\n\t\t\tss=rods<sd+0.01?vec3(8):vec3(0);\n\t\t\tec=2;\t\n\n\t\t}\n\t\treturn sd;\n}\n\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));cn=normalize(cn);}\n\nfloat tr(vec3 ro, vec3 rd)\n{cd=0.;md=64.;for(tc=1.;tc<512.;tc++){mp(cp=ro+rd*cd);cd+=sd;td+=sd;\nif(sd<md&&sd<cd-0.06)md=sd;if(sd<0.0001||cd>64.)break;}nm();return cd;}\n\nvoid px(vec3 rd)\n{\n  cc.rgb=vec3(1.,0.3,0.2)+length(pow(abs(rd+vec3(0,0,0)),vec3(10)))*vec3(0.)+gl/tc;\n  if(cd>64.){cc.a=1.;return;}cc.a=oa;\n\tvec3 ld = -normalize(cp+cn-vec3(0.,10,-30));\n  float df=clamp(length(cn*ld),0.,1.),\n\tsp=(1.-length(cross(rd,cn*ld)))*0.2,\n\tao=min(mp(cp+cn*0.3)-0.3,0.3)*0.8;\n  vec3 fr=pow(1.-abs(dot(rd,-cn)),3.)*mix(cc.rgb,vec3(0.1),0.1)*0.8;\n  cc.rgb=(oc*(df+fr+ss)+fr+sp+ao+gl/tc);tr(cp+cn*0.06,ld);\n\tfloat sh=1.-mix(1.-clamp(md/0.06,0.,1.),clamp(dot(cn,-ld),0.,1.),0.1)*(io>0.?oa:1.)*0.;\n\tcc.rgb=mix(mix(vec3(sh),oc,0.5),cc.rgb,sh)*sh;\n}\n\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n\ttt=mod(time,100.);\n\t\n  vec3 ro=vec3(0.,0,-15),rd=normalize(vec3(uv*0.9,1.));\n\t\n\t\n\tfor(int i=0;i<4;i++)\n  {\n\t\tfloat d=tr(ro,rd);\n\t\tro=cp-cn*(io<0.?-0.01:0.01);\n\t\tcr=refract(rd,cn,i%2==0?1./io:io);\n\t\ti=io<0.?i+1:i;\n    if((length(cr)==0.&&es<=0)||io<0.)\n\t\t{cr=reflect(rd,cn);es=(io<0.?es:ec);}\n\t\tpx(rd); if(max(es,0)%3==0&&d<64.)rd=cr;es--;\n\t\tfc=fc+vec4(cc.rgb*cc.a,cc.a)*(1.-fc.a);\n\t\tif(fc.a>=1.)break;\n  }\n  col = fc/fc.a;\n\tcol.rgb = snap(col.rgb, 16.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n}","name":"Image","description":"","type":"image"}]}