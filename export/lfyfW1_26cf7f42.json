{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Fait avec l'aide de Claude\n// Optimized Voronoi diagram colored by number of acute angles\n#define EPSILON 1e-4\nconst int NUM_POINTS = 40;\nconst float EDGE_THICKNESS = 0.006;\nconst float EDGE_SOFTNESS = 0.7;\n\n// Colors for different acute angle counts\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.000,0.616,1.000),    // Blue (0 acute angles)\n    vec3(1.000,0.682,0.000),    // Yellow (1 acute angle)\n    vec3(1.000,0.533,0.000),    // Orange (2 acute angles)\n    vec3(1.000,0.400,0.000)     // Red (3 or more acute angles)\n);\n\n// Fast hash function\nfloat hash(float n) { return fract(sin(n) * 43758.5453123); }\n\nvec2 generatePoint(int index) {\n    float aspect = iResolution.x/iResolution.y;\n    \n    // Simplified random point generation\n    float n = float(index);\n    vec2 basePos = vec2(\n        hash(n * 12.9898),\n        hash(n * 78.233)\n    );\n    \n    float time = iTime * 0.8;\n    float angle = time + n * 6.28318 / float(NUM_POINTS);\n    float radius = 0.15 * hash(n * 43.5453);\n    \n    return vec2(\n        (basePos.x * 2.0 - 1.0) * aspect + radius * cos(angle),\n        basePos.y * 2.0 - 1.0 + radius * sin(angle)\n    );\n}\n\n// Find closest point using squared distances for speed\nvoid getClosest(vec2 pos, out vec2 closest, out int closestIndex) {\n    float minDist = 1e10;\n    closestIndex = 0;\n    \n    for (int i = 0; i < NUM_POINTS; i++) {\n        vec2 p = generatePoint(i);\n        float d = dot(pos - p, pos - p);  // Squared distance\n        if (d < minDist) {\n            minDist = d;\n            closest = p;\n            closestIndex = i;\n        }\n    }\n}\n\n// Original vertex finding logic restored\nvoid getVertices(vec2 center, int centerIndex, out vec2[8] vertices, out int vertexCount) {\n    vertexCount = 0;\n    \n    for (int i = 0; i < NUM_POINTS; i++) {\n        if (i == centerIndex) continue;\n        vec2 p1 = generatePoint(i);\n        \n        for (int j = i + 1; j < NUM_POINTS; j++) {\n            if (j == centerIndex) continue;\n            vec2 p2 = generatePoint(j);\n            \n            vec2 v1 = p1 - center;\n            vec2 v2 = p2 - center;\n            float cross_v = v1.x * v2.y - v1.y * v2.x;\n            \n            if (abs(cross_v) < EPSILON) continue;\n            \n            vec2 vertex = center + vec2(\n                (v2.y * dot(v1, v1) - v1.y * dot(v2, v2)),\n                (v1.x * dot(v2, v2) - v2.x * dot(v1, v1))\n            ) / (2.0 * cross_v);\n            \n            bool valid = true;\n            for (int k = 0; k < NUM_POINTS; k++) {\n                if (k == centerIndex || k == i || k == j) continue;\n                vec2 p3 = generatePoint(k);\n                if (dot(vertex - p3, vertex - p3) < dot(vertex - center, vertex - center) - EPSILON) {\n                    valid = false;\n                    break;\n                }\n            }\n            \n            if (valid && vertexCount < 8) {\n                vertices[vertexCount++] = vertex;\n            }\n        }\n    }\n}\n\nvoid sortVertices(vec2 center, inout vec2[8] vertices, int vertexCount) {\n    for (int i = 0; i < vertexCount - 1; i++) {\n        for (int j = i + 1; j < vertexCount; j++) {\n            float angle_i = atan(vertices[i].y - center.y, vertices[i].x - center.x);\n            float angle_j = atan(vertices[j].y - center.y, vertices[j].x - center.x);\n            if (angle_j < angle_i) {\n                vec2 temp = vertices[i];\n                vertices[i] = vertices[j];\n                vertices[j] = temp;\n            }\n        }\n    }\n}\n\nfloat getAngle(vec2 p1, vec2 p2, vec2 p3) {\n    vec2 v1 = normalize(p1 - p2);\n    vec2 v2 = normalize(p3 - p2);\n    return acos(clamp(dot(v1, v2), -1.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec2 center;\n    int centerIndex;\n    getClosest(uv, center, centerIndex);\n    \n    vec2[8] vertices;\n    int vertexCount;\n    getVertices(center, centerIndex, vertices, vertexCount);\n    \n    if (vertexCount < 3) {\n        fragColor = vec4(CELL_COLORS[0], 1.0);\n        return;\n    }\n    \n    sortVertices(center, vertices, vertexCount);\n    \n    // Count acute angles\n    int acuteCount = 0;\n    for (int i = 0; i < vertexCount; i++) {\n        vec2 prev = vertices[(i + vertexCount - 1) % vertexCount];\n        vec2 curr = vertices[i];\n        vec2 next = vertices[(i + 1) % vertexCount];\n        if (getAngle(prev, curr, next) < 1.5708) acuteCount++;\n    }\n    \n    vec3 color = CELL_COLORS[min(acuteCount, 3)];\n    \n    // Edge distance calculation\n    float edgeDist = 1.0;\n    for (int i = 0; i < vertexCount; i++) {\n        vec2 v1 = vertices[i];\n        vec2 v2 = vertices[(i + 1) % vertexCount];\n        vec2 edge = v2 - v1;\n        vec2 toPixel = uv - v1;\n        float edgeLen = dot(edge, edge);\n        if (edgeLen > EPSILON) {\n            float t = clamp(dot(toPixel, edge) / edgeLen, 0.0, 1.0);\n            edgeDist = min(edgeDist, length(uv - (v1 + t * edge)) / EDGE_THICKNESS);\n        }\n    }\n    \n    color = mix(vec3(0.2), color, smoothstep(0.0, EDGE_SOFTNESS, edgeDist));\n    \n    // Acute angle markers\n    for (int i = 0; i < vertexCount; i++) {\n        vec2 prev = vertices[(i + vertexCount - 1) % vertexCount];\n        vec2 curr = vertices[i];\n        vec2 next = vertices[(i + 1) % vertexCount];\n        if (getAngle(prev, curr, next) < 1.5708) {\n            float dotDist = length(uv - curr) / (EDGE_THICKNESS * 8.0);\n            if (dotDist < 1.0) {\n                color = mix(color, vec3(1.0), smoothstep(1.0, 0.0, dotDist));\n            }\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfyfW1","date":"1734001602","viewed":125,"name":"Oasis - Acute Angles in Voronoi","username":"Chimel","description":"• Sharp acute angles (<90°) are marked white.\n• Based on N° of interior acute angles (1, 2, 3) the Voronoi cells change light yellow to dark orange.\n• Blue Voronoi cells have no acute angles.\n\nIt's still freakin' slow, suggestions to speed up are welcome.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["voronoi","acuteangles"],"hasliked":0,"parentid":"","parentname":""}}