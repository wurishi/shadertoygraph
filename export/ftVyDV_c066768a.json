{"ver":"0.1","info":{"id":"ftVyDV","date":"1662268304","viewed":268,"name":"Liquid Torus1","username":"grom12345","description":"Made this for the #WCCChallenge as a blob!\nUse your mouse on the torus!\nStill a little bit on a rough side with some glitches and lack of optimisation.\n//by the way, if anybody knows how to pass an array of sampler2D-uniforms, please tell me!!","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","transparency","sdf","refraction","water","deformation","blob","cellularautomata"],"hasliked":0,"parentid":"stGcRd","parentname":"Ice cube"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lighting( vec3 p, vec3 rd, vec3 n, Material m) {\n\n  vec3 lightPos = vec3(3., 3, -10.);\n  \n  //mat2 rot = Rot(iTime*rt*.5-pi*0.5);\n  //lightPos.xz *= rot;\n\n  vec3 l = normalize( lightPos - p );\n  //vec3 n = normal(p);\n\n  float diff = dot(l, n);\n  vec3 col = vec3(1);//m.color.rgb;//colorMap(diff*0.2);\n  \n  //diff = mix(diff*0.5+0.5, max(diff, 0.), 0.9);\n  diff = pow(clamp(diff, 0., 1.), m.specPow);\n  float frensel = pow(1. + dot(rd, n), 4.)*m.fren;\n  \n  return m.color.rgb*col*diff*m.spec+frensel;\n}\nvec3 getPixel(vec3 ro, vec3 rd, vec2 uv){\n    bool infinity = true;\n    float dd = 1.;//\n    float inD = 1.;//inside body coeff\n    float dir = 1.;\n    vec3 p=ro;\n    int i;\n    vec3 col = vec3(0);\n    vec3 oldRd = rd;\n    for (i = 0; i < transpIter; i++) {\n        Dist dist = raymarch(p, rd, dir,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3,iTime);\n        Material m = dist.m;\n        float d = dist.d;\n        p += d * rd;\n        dd += d;\n        if(dd-1.<MAX_DIST){\n           vec3 n = normal(p, \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3,iTime)*dir;\n           if(m.color.a==0.){\n\n               rd = refract(rd, n, m.refr);\n               col += lighting(p, rd, n, m)/inD;\n               if (dir<0.){\n                 inD+=d;\n                 col -= m.absorb*pow((inD-1.), 0.1)*.3;\n               }\n               dir *= -1.;\n               p-=SURF_DIST*4.*n;\n           }else{\n                col += lighting(p, rd, n, m)/inD;\n                infinity = false;\n                break;\n           }\n          \n        }else break;\n    }\n    \n    if(i>0){\n      if(infinity){\n          float a = atan(oldRd.x, oldRd.z);\n          rd.xz *= Rot(a);\n          rd*=-.5;\n          col += texture(iChannel1, uv*.5+.5+rd.xy).rgb/inD;\n      }\n    }else if (col == vec3(0)) col += texture(iChannel1, uv*.5+.5).rgb;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    Camera cam = getCamera(fragCoord, iResolution, iTime);\n    vec3 ro = cam.ro;\n    vec3 rd = cam.rd;\n\n    vec3 col = getPixel(ro, rd, uv);\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec4 fetch(ivec2 c){\n    ivec2 size = ivec2(iResolution.xy*texPart);\n    ivec2 coord = ivec2((c+size)%size);\n    return texelFetch(iChannel1, coord, 0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 color1 = vec4(0);\n    float count = 0.;\n    int u = 1;//+int(iTime*.1)%8;\n    int sx = 6;//+int(iTime*.1)%5;\n    int sy = 6;//+int(iTime*.1)%5;\n    vec4 c0 = fetch(ivec2(fragCoord));\n    for (int x = -u*(sx/2); x <= u*(sx/2) ; x+=u){\n        for (int y = -u*(sy/2); y <= u*(sy/2) ; y+=u){\n            if(x==0&&y==0) break;\n            vec4 c = fetch(ivec2(fragCoord)+ivec2(x, y));\n\n            if(c0.a<c.a){\n                color1 += c;\n                count += 1.;\n            }\n        }\n    }\n\nif(count>0.){\n    color1 /=count;\n    //color1.r += (hash1(fragCoord*10.+iTime).x-.5)*.2;\n    //color1.g += (hash1(fragCoord*10.+iTime).y-.5)*.2;\n    //color1.b += (hash1(fragCoord*38.+iTime).x-.5)*.2;\n    //color1.rgb = mix(c0, color1+hash(fragCoord*.1).x*.0, .5).rgb;\n}else{\n    color1 = c0;\n}\n\nvec2 m = hash(vec2(iTime))*iResolution.xy;\nif(iMouse.z > 0.0) {\n   m = iMouse.xy;\n}\n    Camera camera = getCamera(m, iResolution, iTime);\n    Dist dist = raymarch(camera.ro, camera.rd, 1.,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3,\n    iTime);\n    if(dist.object==0){\n        vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n        vec2 mUV = dist.uv*texPart-.5;\n\n        float dst = length(uv - mUV);  \n        if(dst <= spotSize) {\n            vec3 col = vec3(sin(iTime*5.)*2.+1.,\n                            sin(iTime*5.+pi*.5)*2.+1.,\n                            sin(iTime*5.+pi)*2.+1.);\n            color1 = vec4(col, iTime);\n        }\n    }\n//}\n    \n//if(iFrame<100) color1 = texture(iChannel0, uv);\n    fragColor = color1;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 20.0\n#define SURF_DIST 0.01\n//#define K_Dist 0.5\n\n#define texPart .2\n#define spotSize 0.001\n\n#define transpIter 5\n\n#define pi 3.1415926535\n\n//#define GLSL_BUG\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nvec2 hash1( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat curve(vec2 p){\n    return sdHexagram(p, .5);\n}\n\nvec2 N(float angle) {\n\n   return vec2(sin(angle), cos(angle));\n}\n\nmat2 Rot(float a){\n    vec2 sc = N(a);\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nstruct Material{\n   float refr;\n   vec4 color;\n   vec3 absorb;\n   float specPow;\n   float spec;\n   float fren;\n   int bump;\n   float bDist;\n   float bFactor;\n};\n\nstruct Dist{\n   Material m;\n   float d;\n   vec2 uv;\n   int object;\n};\n\nconst Material materials[]=Material[5](\n   Material(//0: glass\n    .7,\n    vec4(1., 1., 1., 0),\n    vec3(.7, .2, .0),\n    200.,\n    1.,\n    100.,\n    3,\n    .5,\n    .5),\n    Material(//1: concrete\n    0.,\n    vec4(5, 5, 5, 1),\n    vec3(1, 1, 1),\n    2.,\n    1.,\n    .1,\n    0,\n    .005,\n    .005),\n    Material(//2: brick\n    0.,\n    vec4(1, 1, 1, 1)*2.,\n    vec3(1, 1, 1),\n    2.,\n    1.,\n    .1,\n    2,\n    .03,\n    .03),\n    Material(//3: flat white\n    0.,\n    vec4(1, 1, 1, 1),\n    vec3(1, 1, 1),\n    2.,\n    1.,\n    .1,\n    4,\n    .2,\n    .2),\n    Material(\n    .2,\n    vec4(1., 1., 1., 0),\n    vec3(1., .5, 0.),\n    200.,\n    1.,\n    100.,\n    0,\n    .02,\n    .02)\n);\n\nDist scenePure(vec3 p, \n               sampler2D iChannel0,\n               sampler2D iChannel1,\n               sampler2D iChannel2,\n               sampler2D iChannel3,\n               float iTime){\n   //return smax(curve(p.xy), sdBox(p, vec3(10, 10, thickness)), sm);\n   float plane = p.y+1.1;\n   float sphere = abs(sdSphere(p, 10.))-0.1;\n   //float g = fract(iTime*.1)*2.;\n   //g+=sin(g+p.x*30.)*.5;\n   //Material bm;\n   //if(p.y+5.1<g*8.2)bm = materials[0]; else bm = materials[1];\n   //p.yz *= Rot(pi*.25);\n   //p.xz *= Rot(pi*.25);\n   //float box = sdBox(p, vec3(0.3))-0.2;\n   \n   vec3 tp = p;\n   tp = p+sin(iTime*3.)*sin(tp.x*2.5+iTime)*sin(tp.y*3.+iTime)*sin(tp.z*4.5+iTime)*.1;\n   tp-=vec3(0, .5, 0);\n   tp.xy*=Rot(iTime*.3);\n   vec2 q = vec2(length(tp.xz)-1.,-tp.y);\n   float uvY = atan(q.x, q.y)/(pi*2.)+.5;\n   float t = atan(tp.x, tp.z)/(pi*2.)+.5;\n   float torus = length(q-vec2(.0, 0))-.5;\n   \n   float d = torus;\n   //float d = box;\n   d = min(d, sphere);\n   d = min(d, plane);\n   //vec2 uv = vec2(t, uvY);\n   \n   //if(d==box)return Dist(bm, box, uv, 0);\n   if(d==torus){\n       Material m = materials[0];\n       vec2 uv = vec2(t, uvY);\n      // m.absorb = clamp(texture(iChannel3, uv.yx).rgb, 0., 1.);\n       m.absorb.r = 1.-.5*sin(iTime*.5)*2.;\n       m.absorb.g = 1.-.5*cos(iTime*.5)*2.;\n      //                      0,\n      //                      sin(iTime*.5+pi)*2.+1.);\n       //m.refr += sin(iTime*3.)*.1;\n       return Dist(m, torus, uv, 0);\n   }\n   if(d==plane){\n       vec2 uv = p.xz;\n       vec2 id = floor(uv*1.-.5);\n       float checkers = mod(id.y+id.x, 2.);\n       Material m;// = materials[2];\n       if (checkers==1.) {\n           m = materials[1];\n           m.color.rgb = texture(iChannel3, uv*.05+.5).rgb*3.;\n       }else {\n           m = materials[2];\n           //m.color = vec4(1,1,1,1);\n       }\n       return Dist(m, plane, uv*.2, 1);\n   }\n   if(d==sphere){\n       Material m = materials[3];\n       m.color = vec4(0, 0, clamp(p.y*.2+.5, 0., 1.), 1);\n       return Dist(m, sphere, vec2(t,p.y/12.+.5), 2);\n   }\n}\n\nfloat getBump(vec3 p, vec3 n, int bmp, vec2 uv,\n              sampler2D iChannel0,\n              sampler2D iChannel1,\n              sampler2D iChannel2,\n              sampler2D iChannel3,\n              float iTime){\n    \n     vec4 tx1Var = vec4(0.9, 1.3, 0.65, -0.66);\n     vec4 tx2Var = vec4(0.8, 1.2, 0.85, -0.45);\n     float b;\n     switch(bmp){\n     case 0: {\n         b = 1.*texture(iChannel0,uv).r-.5;\n         break;\n       }\n     case 2: {\n         b = 1.*texture(iChannel2,uv).r-.5;\n         break;\n       }\n       case 3: {\n         /* p = p*.1+.5;\n \n         mat3 uvm = mat3(vec3(p.xy, 0), vec3(p.yz,0), vec3(p.xz,0));\n         vec3 bb = -.5*vec3(texture(iChannel0,uvm[0].xy).r,\n                texture(iChannel0,uvm[1].xy*tx2Var.x+tx2Var.z).r,\n                texture(iChannel0,uvm[2].xy*tx1Var.y+tx1Var.w).r)-.2;\n         n=abs(n);\n         b=dot(bb, n.zxy)*.5;*/\n         b=.2-length(texture(iChannel3,uv*texPart).rgb)*.1;\n         break;\n       }\n       case 4:{\n         b=0.;\n       }\n     }\n     \n     return  b;\n}\n\nvec3 pureNormal(vec3 p, \n                sampler2D iChannel0,\n                sampler2D iChannel1,\n                sampler2D iChannel2,\n                sampler2D iChannel3,\n                float iTime){\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n#ifdef GLSL_BUG\n  return normalize(scenePure(p, \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,iTime).d-vec3(scenePure(k[0], \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,iTime).d,scenePure(k[1], \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,iTime).d,scenePure(k[2], \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,iTime).d));\n  \n}\n\n#else\nfloat d1 = scenePure(k[0], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d;\nfloat d2 = scenePure(k[1], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d;\nfloat d3 = scenePure(k[2], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d;\n\nreturn normalize(scenePure(p,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d-vec3(d1,d2,d3));\n}\n  \n#endif\n\nDist scene(vec3 p,\n           sampler2D iChannel0,\n           sampler2D iChannel1,\n           sampler2D iChannel2,\n           sampler2D iChannel3,\n           float iTime){\n   Dist dist = scenePure(p, \n                         iChannel0,\n                         iChannel1,\n                         iChannel2,\n                         iChannel3,\n                         iTime);\n   float d = dist.d;\n   Material m = dist.m;\n   int bmp = m.bump;\n   vec2 uv = dist.uv;\n   int object = dist.object;\n\n   if (d<m.bDist){\n      vec3 n = pureNormal(p, \n      iChannel0,\n                         iChannel1,\n                         iChannel2,\n                         iChannel3,iTime);//good and accurate\n      //vec3 n = normalize (p);//cheap and dirty\n      float bump = getBump(p,n, bmp, dist.uv,\n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,\n                           iTime);\n      d-=bump*m.bFactor;\n   }\n   return Dist(m, d, uv, object);\n}\n\nDist raymarch(vec3 ro, vec3 rd, float dir,\n              sampler2D iChannel0,\n              sampler2D iChannel1,\n              sampler2D iChannel2,\n              sampler2D iChannel3,\n              float iTime){\n    float d0 = 0.0;\n    vec3 p = ro;\n    Dist dist;\n    //Material m;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        dist = scene(p, \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime);\n        float dS = dist.d*dir;\n        d0 += dS;  \n        p = ro + d0 * rd;\n        if ( abs(dS) <= SURF_DIST || d0 >= MAX_DIST ) {\n            //m = dist.m;\n            break;\n        }\n    }\n    return Dist(dist.m, d0, dist.uv, dist.object);\n}\n\nvec3 normal(vec3 p, sampler2D iChannel0,\n                    sampler2D iChannel1,\n                    sampler2D iChannel2,\n                    sampler2D iChannel3, float iTime){\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n#ifdef GLSL_BUG\nreturn normalize(scene(p,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3\n  , iTime).d-vec3(scene(k[0], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d,\n                  scene(k[1], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d,\n  scene(k[2],\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3,\n  iTime).d));\n}\n#else\nfloat d1 = scene(k[0], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d;\nfloat d2 = scene(k[1], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d;\nfloat d3 = scene(k[2], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, iTime).d;\n\nreturn normalize(scene(p,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3\n  , iTime).d-vec3(d1,d2,d3));\n}\n#endif\n\nstruct Camera{\n    vec3 ro;\n    vec3 rd;\n};\n\nCamera getCamera(vec2 fragCoord, vec3 iResolution, float iTime){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*0.1+1.6;\n    float n = (sin(time*2.))*.5;\n    mat2 nn = Rot(time);\n    mat2 nn1 = Rot(pi*.22+n);\n    vec3 ro = vec3(0., .0, -4.5+cos(time));\n    ro.yz *= nn1;\n    ro.xz *= nn;\n    \n    \n    vec3 rd = vec3(uv, 1.);\n    rd.yz *= nn1;\n    rd.xz *= nn;\n    \n    rd = normalize(rd);\n    return Camera(ro, rd);\n}\n\n","name":"Common","description":"","type":"common"}]}