{"ver":"0.1","info":{"id":"Xt2yzc","date":"1509569559","viewed":718,"name":"Colour Smear","username":"Donald","description":"Smears an image based on colour","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float pyt=3.1415926*2./3.;\n    float m=-1e10;//very negitive start value for maximisation algorithm.\n    vec4 mv= vec4(0.);//lank starting value of max so far\n    \n    vec2 xy = fragCoord.xy / iResolution.xy;\n    int ic=0;//stores smear distance\n    for (int i=0;i<30;i++){\n        //point offset on a circle\n        vec2 np=vec2(xy.x+float(i)/iResolution.x*sin(iTime),xy.y+float(i)/iResolution.y*cos(iTime));\n        //colour cycles faster than position\n        float jTime = iTime*1.618;  \n        //get neerby point\n    \tvec4 tk=texture(iChannel0,np);\n        // and if its colourfull enough, use that\n        float t=tk.r*sin(jTime)+tk.g*sin(jTime+pyt)+tk.b*sin(jTime+2.*pyt)-.01*float(i);\n        if (t>m){m=t; mv=tk;ic=i;}\n    }\n    //mix smeared with background depending ondistance\n    float sc=float(ic)/30.;\n    vec4 tk=texture(iChannel0,xy);\n    mv=sc*tk+(1.-sc)*mv;\n    fragColor = vec4(mv.r,mv.g,mv.b,1.0);\n}","name":"Image","description":"","type":"image"}]}