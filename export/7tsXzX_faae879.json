{"ver":"0.1","info":{"id":"7tsXzX","date":"1626269763","viewed":384,"name":"ray triangle intersection","username":"Envy24","description":"How to texture look here: https://www.shadertoy.com/view/stjXRm\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ray","triangle","intersection","mllertrumbore"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define MX iMouse.x / R.x \n#define MY iMouse.y / R.y \n#define BACKGROUND (vec4(normalize(1.0 - rayDir), 1.0))\n\n\n// Source: https://www.shadertoy.com/view/wlVXRc\n//       : https://courses.cs.washington.edu/courses/csep557/14au/lectures/triangle_intersection.pdf\n//       : https://www.youtube.com/watch?v=XgUhgSlQvic&list=PL22CMuqloY0pRNhvBXowdpMtEin8-RFtb\n//       : http://www.cs.cornell.edu/courses/cs465/2003fa/homeworks/raytri.pdf\nvec4 rayTriangleIntersection0( \n    vec3 ray,\n    vec3 rayDir, \n    vec3 A,\n    vec3 B,\n    vec3 C) \n{ \n    vec3 normal = normalize(cross(B-A, C-A));\n\n    float t = dot(-ray, normal) / dot(normal, rayDir);\n    vec3 Q = ray + rayDir*t; // hit point\n      \n    float areaABC = 1.0 / dot(cross(B-A, C-A), normal);     \n    float areaQBC = dot(cross(B-A, Q-A), normal);\n\tfloat areaAQC = dot(cross(C-B, Q-B), normal);\n\tfloat areaABQ = dot(cross(A-C, Q-C), normal);\n\n    //vec3 barycentric = vec3(areaQBC, areaAQC, areaABQ) * areaABC;\n    \n    return \n        areaQBC >= 0.0 && areaAQC >= 0.0 && areaABQ >= 0.0 ?\n        vec4(normalize(vec3(areaQBC, areaAQC, areaABQ) * areaABC), 1.0) :\n        BACKGROUND;\n}\n\nfloat triangleArea(vec3 A, vec3 B, vec3 C) { return 0.5 * length(cross(B - A, C - A)); }\nfloat signedTriangleArea(vec3 A, vec3 B, vec3 C) \n{ \n    float determinant = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);\n\n    return 0.5 * determinant; \n}\n\nvec4 rayTriangleIntersection1( \n    vec3 ray,\n    vec3 rayDir, \n    vec3 A,\n    vec3 B,\n    vec3 C) \n{ \n    vec3 normal = normalize(cross(B-A, C-A));\n\n    float t = dot(-ray, normal) / dot(normal, rayDir);\n    vec3 Q = ray + rayDir*t; // hit point\n\n    if (dot(cross(B-A, Q-A), normal) >= 0.0 &&\n        dot(cross(C-B, Q-B), normal) >= 0.0 && \n        dot(cross(A-C, Q-C), normal) >= 0.0)\n        {\n            float areaABC = 1.0 / signedTriangleArea(A,B,C);\n            float areaQBC = signedTriangleArea(Q, B, C);\n            float areaAQC = signedTriangleArea(A, Q, C);\n            float areaABQ = signedTriangleArea(A, B, Q);\n            \n            vec3 BARYCENTRIC = vec3(areaQBC, areaAQC, areaABQ) * areaABC;\n            \n            //return vec4(normalize(BARYCENTRIC), 1.0);\n            return vec4(BARYCENTRIC, 1.0);  \n        }\n                            \n    return BACKGROUND;\n}\n\n\n\n// Source C++: http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\n//           : https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\n//           : book \"Real-Time Rendering\" https://www.realtimerendering.com/\nbool rayIntersectsTriangle0(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 A,\n    vec3 B,\n    vec3 C,\n    out vec3 res) \n{\n    /* Calculate edges. */\n\tvec3 BA = B - A;\n\tvec3 CA = C - A;\n\n\tvec3 RDIRcrossCA = cross(rayDir,CA);\n    \n    /* Calculate determinant using triple product dot(BA, cross(rayDit, CA)) */\n\tfloat det = dot(BA,RDIRcrossCA);\n\n    /* Avoiding division by zero. */\n\tif (det > -0.00001 && det < 0.00001) { return false; }\n\n\tfloat invDet = 1.0 / det;\n    \n\tvec3 RA = ray - A; // distance from ray origin to A vertex of triangle\n    \n\tfloat baryU = invDet * dot(RA, RDIRcrossCA);\n\n    /* Checking edge CA */\n\tif (baryU < 0.0 || baryU > 1.0) { return false; }\n\n\tvec3 RAcrossBA = cross(RA,BA);\n\tfloat baryV = invDet * dot(rayDir, RAcrossBA);\n\n    /* Checking edge BA */\n\tif (baryV < 0.0 || baryU + baryV > 1.0) { return false; }\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tfloat dist = invDet * dot(CA, RAcrossBA);\n\n\tif (dist > 0.00001) // ray intersection\n    {\n        res = vec3(baryU, baryV, dist);\n\t\treturn true;\n    }\n\n    // this means that there is a line intersection\n    // but not a ray intersection\n\treturn false;       \n}\n\n/*\n    Source: https://github.com/SebLague/Gamedev-Maths/blob/master/PointInTriangle.cs\n*/\nvec4 PointInTriangle0(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 A,\n    vec3 B,\n    vec3 C)\n{\n    vec3 normal = normalize(cross(B-A, C-A));\n\n    float t = dot(-ray, normal) / dot(normal, rayDir);\n    vec3 P = ray + rayDir*t; // hit point\n\n\n    float s1 = C.y - A.y;\n    float s2 = C.x - A.x;\n    float s3 = B.y - A.y;\n    float s4 = P.y - A.y;\n\n    float w1 = (A.x * s1 + s4 * s2 - P.x * s1) / (s3 * s2 - (B.x-A.x) * s1);\n    float w2 = (s4- w1 * s3) / s1;\n\n    return \n        w1 >= 0.0 && w2 >= 0.0 && (w1 + w2) <= 1.0 ?\n\n        vec4(w1, w2, t, 1.0) :\n        BACKGROUND;\n}\n\n/* \n    One side versions \n*/\n\n\nvec4 rayTriangleIntersection2( \n    vec3 ray,\n    vec3 rayDir, \n    vec3 A,\n    vec3 B,\n    vec3 C) \n{ \n    vec3 normal = normalize(cross(B-A, C-A));\n\n    bool backFace = dot(normal, rayDir) <= 0.0;\n    if (backFace == true) { return BACKGROUND; }\n\n    float t = dot(-ray, normal) / dot(normal, rayDir);\n    vec3 Q = ray + rayDir*t; // hit point\n      \n    float areaABC = 1.0 / dot(cross(B-A, C-A), normal);     \n    float areaQBC = dot(cross(B-A, Q-A), normal);\n\tfloat areaAQC = dot(cross(C-B, Q-B), normal);\n\tfloat areaABQ = dot(cross(A-C, Q-C), normal);\n\n    //vec3 barycentric = vec3(areaQBC, areaAQC, areaABQ) * areaABC;\n    \n    return \n        areaQBC >= 0.0 && areaAQC >= 0.0 && areaABQ >= 0.0 ?\n        vec4(normalize(vec3(areaQBC, areaAQC, areaABQ) * areaABC), 1.0) :\n        BACKGROUND;\n}\n\n/*\n    Great explanation: https://www.youtube.com/watch?v=fK1RPmF_zjQ\n*/\nbool rayIntersectsTriangle1(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 A,\n    vec3 B,\n    vec3 C,\n    out vec3 res) \n{\n    /* Calculate edges. */\n\tvec3 BA = B - A;\n\tvec3 CA = C - A;\n\n\tvec3 RDIRcrossCA = cross(rayDir,CA);\n    \n    /* Calculate determinant using triple product dot(BA, cross(rayDit, CA)) */\n\tfloat det = dot(BA,RDIRcrossCA);\n\n    /* Avoiding division by zero. */\n\tif (det < 0.00001) { return false; }\n  \n\tvec3 RA = ray - A; // distance from ray origin to A vertex of triangle\n    \n\tfloat baryU = dot(RA, RDIRcrossCA);\n\n    /* Checking edge CA */\n\tif (baryU < 0.0 || baryU > det) { return false; }\n\n\tvec3 RAcrossBA = cross(RA,BA);\n\tfloat baryV = dot(rayDir, RAcrossBA);\n\n    /* Checking edge BA */\n\tif (baryV < 0.0 || baryU + baryV > det) { return false; }\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tfloat dist = dot(CA, RAcrossBA);\n\n\tif (dist > 0.00001) // ray intersection\n    {\n        float invDet = 1.0 / det;\n        res = vec3(baryU * invDet, baryV * invDet, dist * invDet);\n\t\treturn true;\n    }\n\n    // this means that there is a line intersection\n    // but not a ray intersection\n\treturn false;       \n}\n\nvec4 PointInTriangle1(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 A,\n    vec3 B,\n    vec3 C)\n{\n    vec3 normal = normalize(cross(B-A, C-A));\n\n    float denominator = dot(normal, rayDir);\n    float t = dot(-ray, normal) / denominator;\n    vec3 P = ray + rayDir*t; // hit point\n\n\n    float s1 = C.y - A.y;\n    float s2 = C.x - A.x;\n    float s3 = B.y - A.y;\n    float s4 = P.y - A.y;\n\n    float w1 = (A.x * s1 + s4 * s2 - P.x * s1) / (s3 * s2 - (B.x-A.x) * s1);\n    float w2 = (s4- w1 * s3) / s1;\n\n    return \n        w1 >= 0.0 &&\n        w2 >= 0.0 &&\n        (w1 + w2) <= 1.0 &&\n        denominator >= 0.0 ?\n\n        vec4(w1, w2, t, 1.0) :\n        BACKGROUND;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /* TRINAGLE */\n    vec3 A = vec3(-1.0, -1.0, 0.0);\n    vec3 B = vec3(0.0, 1.0, 0.0);\n    vec3 C = vec3(1.0, -1.0, 0.0);\n    /* TRINAGLE */    \n\n    /* ROTATION */\n    float rad = iTime;\n    A = rotateAroundZ(A, rad);\n    B = rotateAroundZ(B, rad);\n    C = rotateAroundZ(C, rad);\n    /* ROTATION */\n        \n        \n        \n    /* Perspective camera with lookat (Blender). */\n    vec3 lookAt = (A + B + C) / 9.0;\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n    camera = rotateAroundY(camera, iTime);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n    \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = R.x / R.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n    \n      \n    \n    /* Ortographic camera (Blender). *\n    vec3 lookAt = (A+B+C) / 9.0;\n    vec3 camera = vec3(0.0, 0.0, 1.0);\n    camera = rotateAroundY(camera, iTime);\n    \n    vec3 f = normalize(lookAt - camera);                   // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up\n    \n    float aspectRatio = R.x / R.y;\n    float orthographicScale = 5.0;\n    float vpWidth = orthographicScale;\n    float vpHeight = vpWidth / aspectRatio;\n   \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n         \n    vec3 ray = camera + uv.x * r + uv.y * u;\n    vec3 rayDir = f;\n    /* Ortographic camera. */\n    \n\n\n    /* Variant 1 */\n    //vec4 color = rayTriangleIntersection0(ray, rayDir, A, B, C);\n    //vec4 color = rayTriangleIntersection1(ray, rayDir, A, B, C);\n    //vec4 color = rayTriangleIntersection2(ray, rayDir, A, B, C);\n    vec4 color = PointInTriangle0(ray, rayDir, A, B, C);\n    /* Variant 1 */\n    \n    /* Möller-Trumbore algorithm *\n    vec3 col;\n    rayIntersectsTriangle0(ray, rayDir, A, B, C, col);\n    rayIntersectsTriangle1(ray, rayDir, A, B, C, col);\n    vec4 color = vec4(col, 1.0);\n    /* Möller-Trumbore algorithm */\n    \n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}","name":"Common","description":"","type":"common"}]}