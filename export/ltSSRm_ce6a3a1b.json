{"ver":"0.1","info":{"id":"ltSSRm","date":"1444144529","viewed":216,"name":"Controlled texture distortion","username":"rohtie","description":"Mainly a test for how to apply texture mapping. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distancefields","distortion","texturemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float Sphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat Box( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nvec3 rotate(vec3 point) {\n    float t = iTime;\n    \n    float s = 0.9 - cos(t) * 0.2;\n    \n    point *= mat3(s, 0.0, 0.0,\n                  0.0, s, 0.0,\n                  0.0, 0.0, s);\n    \n    point *= mat3(1.0, 0.0, 0.0,\n                  0.0, -sin(t), cos(t),\n                  0.0, cos(t), sin(t));\n\n    return point;\n}\n\nfloat map (vec3 point) {\n    \n    point = rotate(point);\n    \n    return mix(\n        max(Box(point, vec3(0.75)), -Sphere(point, 1.0)), \n        texture(iChannel0, point.xx * point.yy * point.zz).r,\n        sin(iTime)*0.1\n    );\n}\n\nfloat intersect (vec3 rayOrigin, vec3 rayDirection) {\n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n    \n    float distance = 0.0;\n\n    float currentDistance = 1.0;\n    \n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        currentDistance = map(rayOrigin + rayDirection * distance);\n\n        distance += currentDistance;\n    }\n\n    if (distance > maxDistance) {\n        return -1.0;\n    }\n\n    return distance;\n}\n\nvec3 getNormal(vec3 point) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(point + extraPolate.xyy),\n        map(point + extraPolate.yxy),\n        map(point + extraPolate.yyx)\n    ) - map(point));\n}\n\nvec3 light = normalize(vec3(0.0, 2.0, 3.0));\n\nvoid mainImage (out vec4 color, in vec2 point) {\n    point /= iResolution.xy;\n    point = 2.0 * point - 1.0;\n\tpoint.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, 2.0);\n    vec3 rayDirection = normalize(vec3(point, -1.0));\n    \n    float distance = intersect(cameraPosition, rayDirection);\n    \n    vec3 col = vec3(0.0);\n\n    if (distance > 0.0) {\n        vec3 point = cameraPosition + rayDirection * distance;\n        vec3 normal = getNormal(point);\n        \n        \n        point = rotate(point);\n        \n        col += texture(iChannel0, point.xx * point.yy * point.zz).rgb;\n        \n        col += vec3(0.05, 0.01, 0.35);\n        col += vec3(0.7, 1.0, 0.95) * max(dot(normal, light), 0.0);\n        \n        vec3 halfVector = normalize(light + normal);\n        col += vec3(1.0) * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n    }\n\n    color.rgb = col;\n}\n","name":"","description":"","type":"image"}]}