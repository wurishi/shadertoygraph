{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define TWOPI 6.28318530718\n\n// Please try METHOD = 0, 1 and 2\n#define METHOD 0\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat triangle(vec2 r, vec2 A1, vec2 A2, vec2 A3) {\n\tvec2 q = r - A3;\n\tvec2 A1q = A1 - A3;\n\tvec2 A2q = A2 - A3;\n\tmat2 Bq = mat2(A1q, A2q);\n\tvec2 c = inverse(Bq)*q;\n\t\n\tfloat ret = 0.0;\n\tif(c.x>0. && c.y>0.0 && c.x+c.y<1.0) {\n\t\t// solid color\n\t\t//ret = 1.0;\n\t\t// darker towards edges\n\t\tfloat x = c.x*c.y*(1.-c.x-c.y)*75.;\n\t\t//x = 1.0-smoothstep(0.2, 5.8, x);\n\t\tret = pow(x,0.25);\n\t\t//ret = pow((1.0-c.x*c.y*(1.-c.x-c.y)),64.);\n\t\tret -= 0.5*pow(texture(iChannel0, 0.5*c).x, 4.0 );\n\t}\n\t\n\t\t\n\treturn ret;\n}\n\nfloat triangle2(vec2 r, vec2 A1, vec2 A2, vec2 A3) {\n\tmat2 B = mat2(A1-A3, A2-A3);\n\tvec2 c = inverse(B)*(r-A3);\n\t\n\tfloat ret = 0.0;\n\tif(c.x>0. && c.y>0.0 && 1.-c.x-c.y>0.0) {\n\t\tret = 1.0;\n\t}\n\treturn ret;\n}\n\nfloat triangle3(vec2 r, vec2 A3, mat2 inv) {\n\tvec2 c = inv*(r-A3);\n\t\n\tfloat ret = 0.0;\n\tif(c.x>0. && c.y>0.0 && 1.-c.x-c.y>0.0) {\n\t\t// solid color\n\t\t//ret = 1.0;\n\t\t// darker towards edges\n\t\tret = pow(c.x*c.y*(1.-c.x-c.y)*75.,1.15+sin(iTime));\n\t}\n\treturn ret;\t\n}\n\n\n// a new method to test being inside of triangle\n// no need of matrices etc. uses vectors and trigonometry\n//\n// Hmm... I expected this to be faster than matrix method,\n// but I was wrong. I don't get it. :-(\nfloat triangle4(vec2 r, vec2 A1, vec2 A2, vec2 A3) {\n\tfloat ret = 0.0;\n\t// Draw arrows from pixel to vertices\t\n\tvec2 A1p = A1 - r;\n\tvec2 A2p = A2 - r;\n\tvec2 A3p = A3 - r;\n\t// normalize them\n\tvec2 A1pn = normalize(A1p);\n\tvec2 A2pn = normalize(A2p);\n\tvec2 A3pn = normalize(A3p);\n\t// find the angles between the arrows\n\tfloat an12 = acos(dot(A1pn, A2pn));\n\tfloat an23 = acos(dot(A2pn, A3pn));\n\tfloat an31 = acos(dot(A3pn, A1pn));\t\n\t\n\t// if they add up to 2Pi then inside the triangle!\n\tif( abs(an12+an23+an31-TWOPI) < 0.01 ) {\n\t\t//float man = max(an12, an23);\n\t\t//man = max(man, an31);\n\t\tret = 1.0;\n\t\t//float col = 1. - man/PI;\n\t\t//col = pow(col, .4)*1.;\n\t\t//ret = (sin(man));\t\n\t}\n\treturn ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 r = 2.0*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\n\tvec3 pixel = vec3(0.0, 0.1, 0.0);\n\nconst int nPoints = 20;\nvec2 pt[20];\nconst int nTriangles = 31;\nivec3 triangles[31];\nmat3 tri[31];\nmat2 invB[31];\n\t\n#if METHOD == 0\npt[0] = vec2(-0.752524495777,0.276016142992);\npt[1] = vec2(-0.545694726988,0.507777307568);\npt[2] = vec2(0.0344987625226,-0.306673145755);\npt[3] = vec2(-0.297237538054,0.191710047873);\npt[4] = vec2(-0.715035346718,0.0364155198627);\npt[5] = vec2(0.612024151395,0.536568473836);\npt[6] = vec2(-0.40447145914,-0.79573858745);\npt[7] = vec2(-0.0664654101251,0.789470572312);\npt[8] = vec2(0.262284652061,-0.61074282809);\npt[9] = vec2(-0.350794881771,0.986410561889);\npt[10] = vec2(-0.794242268159,0.00942264957239);\npt[11] = vec2(0.45294387004,0.544629519029);\npt[12] = vec2(-0.670283449528,0.248633296271);\npt[13] = vec2(0.132599909009,-0.241305025684);\npt[14] = vec2(0.0758491466031,-0.370676582564);\npt[15] = vec2(-0.251344572955,0.381006780584);\npt[16] = vec2(-0.48716276886,0.84889489905);\npt[17] = vec2(-0.402684172294,0.388539347107);\npt[18] = vec2(0.851456864277,0.970948923036);\npt[19] = vec2(-0.392850985248,-0.651126446093);\ntriangles[0] = ivec3(19,6,10);\ntriangles[1] = ivec3(8,19,6);\ntriangles[2] = ivec3(11,7,18);\ntriangles[3] = ivec3(9,7,18);\ntriangles[4] = ivec3(14,8,13);\ntriangles[5] = ivec3(14,8,19);\ntriangles[6] = ivec3(4,19,10);\ntriangles[7] = ivec3(5,8,18);\ntriangles[8] = ivec3(5,11,18);\ntriangles[9] = ivec3(5,8,13);\ntriangles[10] = ivec3(5,11,13);\ntriangles[11] = ivec3(15,11,7);\ntriangles[12] = ivec3(15,3,13);\ntriangles[13] = ivec3(15,11,13);\ntriangles[14] = ivec3(2,14,19);\ntriangles[15] = ivec3(2,4,19);\ntriangles[16] = ivec3(2,4,3);\ntriangles[17] = ivec3(2,3,13);\ntriangles[18] = ivec3(2,14,13);\ntriangles[19] = ivec3(16,9,7);\ntriangles[20] = ivec3(16,15,7);\ntriangles[21] = ivec3(1,16,15);\ntriangles[22] = ivec3(12,4,3);\ntriangles[23] = ivec3(17,15,3);\ntriangles[24] = ivec3(17,1,15);\ntriangles[25] = ivec3(17,12,3);\ntriangles[26] = ivec3(17,12,1);\ntriangles[27] = ivec3(0,1,16);\ntriangles[28] = ivec3(0,12,1);\ntriangles[29] = ivec3(0,4,10);\ntriangles[30] = ivec3(0,12,4);\n#else\ntri[0] = mat3(vec3(-0.392850985248,-0.651126446093,0.0),vec3(-0.40447145914,-0.79573858745,0.0),vec3(-0.794242268159,0.00942264957239,0.0));\ntri[1] = mat3(vec3(0.262284652061,-0.61074282809,0.0),vec3(-0.392850985248,-0.651126446093,0.0),vec3(-0.40447145914,-0.79573858745,0.0));\ntri[2] = mat3(vec3(0.45294387004,0.544629519029,0.0),vec3(-0.0664654101251,0.789470572312,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[3] = mat3(vec3(-0.350794881771,0.986410561889,0.0),vec3(-0.0664654101251,0.789470572312,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[4] = mat3(vec3(0.0758491466031,-0.370676582564,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[5] = mat3(vec3(0.0758491466031,-0.370676582564,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(-0.392850985248,-0.651126446093,0.0));\ntri[6] = mat3(vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.392850985248,-0.651126446093,0.0),vec3(-0.794242268159,0.00942264957239,0.0));\ntri[7] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[8] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[9] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[10] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[11] = mat3(vec3(-0.251344572955,0.381006780584,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(-0.0664654101251,0.789470572312,0.0));\ntri[12] = mat3(vec3(-0.251344572955,0.381006780584,0.0),vec3(-0.297237538054,0.191710047873,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[13] = mat3(vec3(-0.251344572955,0.381006780584,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[14] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(0.0758491466031,-0.370676582564,0.0),vec3(-0.392850985248,-0.651126446093,0.0));\ntri[15] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.392850985248,-0.651126446093,0.0));\ntri[16] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[17] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(-0.297237538054,0.191710047873,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[18] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(0.0758491466031,-0.370676582564,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[19] = mat3(vec3(-0.48716276886,0.84889489905,0.0),vec3(-0.350794881771,0.986410561889,0.0),vec3(-0.0664654101251,0.789470572312,0.0));\ntri[20] = mat3(vec3(-0.48716276886,0.84889489905,0.0),vec3(-0.251344572955,0.381006780584,0.0),vec3(-0.0664654101251,0.789470572312,0.0));\ntri[21] = mat3(vec3(-0.545694726988,0.507777307568,0.0),vec3(-0.48716276886,0.84889489905,0.0),vec3(-0.251344572955,0.381006780584,0.0));\ntri[22] = mat3(vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[23] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.251344572955,0.381006780584,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[24] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.545694726988,0.507777307568,0.0),vec3(-0.251344572955,0.381006780584,0.0));\ntri[25] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[26] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.545694726988,0.507777307568,0.0));\ntri[27] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.545694726988,0.507777307568,0.0),vec3(-0.48716276886,0.84889489905,0.0));\ntri[28] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.545694726988,0.507777307568,0.0));\ntri[29] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.794242268159,0.00942264957239,0.0));\ntri[30] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.715035346718,0.0364155198627,0.0));\n#endif\n#if METHOD == 2\t\ninvB[0] = mat2(vec2(12.2510254236,-10.0506623921),vec2(5.93060355006,-6.10741623619));\ninvB[1] = mat2(vec2(1.53399980438,-1.96237643676),vec2(-0.123266307448,7.07273770067));\ninvB[2] = mat2(vec2(0.56888588823,-1.33639683109),vec2(-2.87743979553,1.24923120468));\ninvB[3] = mat2(vec2(-0.780971094288,-0.0665373746576),vec2(3.95017234978,-5.17375134818));\ninvB[4] = mat2(vec2(-9.78814469667,3.42766092189),vec2(-3.43595869638,-1.50359457115));\ninvB[5] = mat2(vec2(-0.24503895042,1.70170835607),vec2(3.9752195788,-2.84396975926));\ninvB[6] = mat2(vec2(10.4592126164,0.427408305219),vec2(6.35567711449,-1.25417177539));\ninvB[7] = mat2(vec2(-12.8819194429,3.53776514935),vec2(4.79845012174,-1.9500341436));\ninvB[8] = mat2(vec2(6.001840763,-6.11532635427),vec2(-5.61037454762,3.37079898937));\ninvB[9] = mat2(vec2(1.32893321047,2.79814875556),vec2(0.46649899066,-1.724573916));\ninvB[10] = mat2(vec2(6.15892743873,-6.09575755676),vec2(-2.51035563292,3.75697841644));\ninvB[11] = mat2(vec2(-0.951112766618,1.58672380226),vec2(-2.01770410166,-0.718184020575));\ninvB[12] = mat2(vec2(4.27714958179,-6.14694694126),vec2(4.24576225912,-3.79244991859));\ninvB[13] = mat2(vec2(-1.56839020972,1.24186899648),vec2(0.639269943792,0.766189462769));\ninvB[14] = mat2(vec2(-6.74237275671,8.28109708786),vec2(11.2681495377,-10.2740335142));\ninvB[15] = mat2(vec2(1.69848014931,-0.850925648119),vec2(0.795913223442,1.05571019566));\ninvB[16] = mat2(vec2(0.597883981974,-1.91877545315),vec2(-1.60852169555,-1.27718486218));\ninvB[17] = mat2(vec2(-6.13536188092,-0.926196561268),vec2(-6.0903383017,1.38998864331));\ninvB[18] = mat2(vec2(-14.4037331347,7.27783586836),vec2(6.3184123048,-10.9222055317));\ninvB[19] = mat2(vec2(-2.98592777252,0.900968604446),vec2(-4.31089322062,6.37845025774));\ninvB[20] = mat2(vec2(-2.23416737961,-0.325032218376),vec2(1.01123037862,-2.30108111076));\ninvB[21] = mat2(vec2(-4.33920223823,1.17567198807),vec2(-2.18698189397,2.72980825286));\ninvB[22] = mat2(vec2(-1.90045491795,-0.696612229362),vec2(5.11290327071,-4.56524094034));\ninvB[23] = mat2(vec2(-6.52887308512,6.78867244949),vec2(1.5828553422,3.63687044328));\ninvB[24] = mat2(vec2(-7.47107010851,0.443922841778),vec2(-17.3471759529,8.91901914235));\ninvB[25] = mat2(vec2(0.844257950794,-2.91927649076),vec2(5.53283562751,-1.56393322318));\ninvB[26] = mat2(vec2(4.99159876947,-2.29674632932),vec2(-2.39981202347,-2.75465099603));\ninvB[27] = mat2(vec2(-5.98579635017,10.0526494462),vec2(1.02709561182,-4.65646245201));\ninvB[28] = mat2(vec2(-10.4815316901,9.37398467703),vec2(5.03920826492,-8.36559087426));\ninvB[29] = mat2(vec2(-1.35032087116,13.336364544),vec2(3.96233368338,-2.08693548111));\ninvB[30] = mat2(vec2(-11.3616396639,12.8276527504),vec2(2.39591111903,2.00708069855));\n#endif\n\t\n\tpt[4] += 0.1*vec2(0.5*cos(iTime),sin(iTime));\n\tpt[2] += vec2(0.05,0.02)*vec2(cos(-iTime),sin(iTime*2.2));\n\tpt[7] += vec2(0.01,0.2)*vec2(cos(iTime*3.1),sin(iTime*1.2));\n\tpt[8] += vec2(0.2,0.0)+vec2(0.3,0.2)*vec2(cos(iTime*0.4),sin(iTime*1.2));\n\tpt[11] += vec2(0.01,0.03)*vec2(cos(iTime*3.1),sin(iTime*5.1));\n\tfloat nTrigInv = 1.0/float(nTriangles);\n\t\n\tvec3 col1 = vec3(1.0, 0.0, 0.0);\n\tvec3 col2 = vec3(0.0, 0.0, 1.0);\n\t\n\t#if METHOD == 0\n \t// 16 FPS\n\t// Here, the data structures are defined such that\n\t// points are given in \"pt\", an array of vec2s. \n\t// and each triangle is a set of 3 indices of pt array.\n\tfor(int i=0; i<nTriangles; i++) {\n\t\tivec3 tri = triangles[i];\n\n\t\tvec2 A1, A2, A3;\n\t\t// Super stupid method to reach array indices :-(\n\t\t// \"pt[tri.x]\" does not work -Grrr!- because\n\t\t// a variable has to be a constant (or a looping variable) \n\t\t// to be used as an index.\n\t\t// So, tri to be constant. But I can't make \"triangles\" \n\t\t// a constant array.\n\t\tfor(int ind=0; ind<nTriangles; ind++) {\n\t\t\tif(ind==tri.x) A1 = pt[ind];\n\t\t\tif(ind==tri.y) A2 = pt[ind];\n\t\t\tif(ind==tri.z) A3 = pt[ind];\t\t\n\t\t}\n\t\tpixel += vec3(1.0)*triangle(r,A1,A2,A3)*float(i)/float(nTriangles);\n\t}\n\t\n\t#elif METHOD == 1\n\t// 25 FPS\n\t// Here, the data structures are defined such that\n\t// each triangle is given as three points\n\tfor(int i=0; i<nTriangles; i++) {\n\t\tmat3 t = tri[i];\n\t\tvec2 A1 = t[0].xy;\n\t\tvec2 A2 = t[1].xy;\n\t\tvec2 A3 = t[2].xy;\n\t\tvec3 col = vec3(0.0);\n\t\t\n\t\tif( mod(float(i),2.0) < 0.9 ) {\n\t\t\tcol = col1;\n\t\t} else {\n\t\t\tcol = col2;\n\t\t}\n\t\t\n\t\tfloat x = float(i)-mod(iTime*1.0,float(nTriangles));\n\t\tif(abs(x)<0.5) {\n\t\t\tcol=mix(col,vec3(1.0, 1.0, 0.0), 0.8);\n\t\t\t//col=vec3(1.0, 1.0, 0.0);\n\t\t}\n\t\tpixel = mix(pixel, col, triangle(r,A1,A2,A3)*float(i)*nTrigInv);\n\t}\n\t\n\t#elif METHOD == 2\n\t// 15 FPS\n\t// Here, the data structures are defined such that\n\t// Triangle matrix inverses calculated beforehand\n\tfor(int i=0; i<nTriangles; i++) {\n\t\tmat3 t = tri[i];\n\t\tvec2 A3 = t[2].xy;\n\t\n\t\tpixel += vec3(1.0)*triangle3(r,A3,invB[i])*float(i)/float(nTriangles);\t\t\t\t\n\t}\t\t\n\t#endif\t\n\t\n\t/*\n\tfloat c1=0.1;\n\tfloat c2=0.3;\n\tvec2 x = c1*A1+c2*A2+(1.0-c1-c2)*A3;\n\tpixel = mix(pixel, vec3(1.0,1.0,0.0), disk(r, x, 0.05));\n\tfloat u = 0.1;\n\tfloat v = 0.1;\n\tx = u*A1q + v*A2q;\n\tpixel = mix(pixel, vec3(1.0,0.0,1.0), disk(q, x, 0.05));\n\t*/\n\t\n\t//pixel += 0.3*vec3( pow(texture(iChannel0, 1.*r).x, 4.0) );\n\tfragColor = vec4(pixel,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xs23W3","date":"1394386173","viewed":1429,"name":"[Study] Triangle patterns","username":"vug","description":"A study for finding whether the pixel is inside one of the given set of triangles, and painting the triangles. A Delanuay triangulation of random points is done via Python beforehand and triangles are loaded by assignment.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""}}