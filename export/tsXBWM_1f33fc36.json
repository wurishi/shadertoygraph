{"ver":"0.1","info":{"id":"tsXBWM","date":"1588336286","viewed":88,"name":"Laughing Man","username":"f00zz","description":"Laughing Man logo from Ghost in the Shell.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 笑い男\n\nconst float PI = 3.14159265;\n\nconst float W = .04;\n\nconst float Q0 = .3;\nconst float Q1 = Q0 + .5*W;\n\nconst float R0 = .21;\nconst float R1 = R0 + W;\n\nconst float HB = .02;\n\nconst float HR = .04;\nconst float HW = .32;\n\nconst float M0 = .13;\nconst float M1 = M0 + W;\n\nconst float EW = .08;\nconst float EY = -.02;\nconst float ER = .05;\nconst float EA = .03;\n\nconst float TB = .01;\nconst float TR0 = R1 + TB;\nconst float TR1 = Q0 - TB;\n\nfloat outer_circle(vec2 p)\n{\n    float r = length(p);\n\n    if (r > Q0 && r < Q1) {\n        if (p.x < 0. || p.y < -HR - W || p.y > HR + W) {\n            return 1.;\n        }\n    }\n\n    return 0.;\n}\n\nfloat inner_circle(vec2 p)\n{\n    float r = length(p);\n\n    if (r > R0 && r < R1) {\n        if (p.x > 0.) {\n            if (p.y < -HR || p.y > HR + W) {\n                return 1.;\n            }\n        } else {\n            if (p.y > HR || p.y < HR - HB) {\n                return 1.;\n            }\n        }\n    }\n\n    return 0.;\n}\n\nfloat hat(vec2 p)\n{\n    float r = length(p);\n\n    if (p.y < -HR && p.y > -HR - W && p.x > 0. && p.x < HW && r > R1) {\n        return 1.;\n    }\n\n    if (p.y > HR && p.y < HR + W && p.x < HW && (p.x > 0. || r < R0)) {\n        return 1.;\n    }\n\n    if (p.x > HW && abs(p.y) < HR + W) {\n        float r0 = length(p - vec2(HW, 0.));\n        if (r0 < HR + W && r0 > HR) {\n            return 1.;\n        }\n    }\n\n    return 0.;\n}\n\nfloat mouth(vec2 p)\n{\n    float r = length(p);\n\n    if (r < M1 && p.y < -HR && (r > M0 || p.y > -HR - W)) {\n        return 1.;\n    }\n\n    return 0.;\n}\n\nfloat eye(vec2 p, float x0)\n{\n    if (p.y > EY) {\n        float r0 = distance(p, vec2(x0, EY));\n\n        if (r0 < ER) {\n            float r1 = distance(p, vec2(x0, EY - EA));\n\n            if (r1 > distance(vec2(x0 - ER, EY), vec2(x0, EY - EA))) {\n                return 1.;\n            }\n        }\n    }\n    \n    return 0.;\n}\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat pattern(vec2 p)\n{\n    float r = length(p);\n    if (r > TR0 && r < TR1) {\n        if (p.x < 0. || p.y < -HR - W || p.y > HR + W) {\n            vec2 uv = vec2((atan(p.y, p.x) + iTime + PI)/2.*PI, (r - TR0)/(TR1 - TR0));\n            return step(.5, hash(floor(uv*8.)));\n        }\n    }\n    return 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = .35*(fragCoord.xy*2. - iResolution.xy)/iResolution.y;\n    float c = min(outer_circle(p) + inner_circle(p) + hat(p) + mouth(p) + eye(p, -EW) + eye(p, EW) + pattern(p), 1.);\n    fragColor = mix(vec4(1.), vec4(0., 0., .6, 1.), c);\n}\n","name":"Image","description":"","type":"image"}]}