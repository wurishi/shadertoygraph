{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float timeEffect=0.0;\n\n//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res*2.0-1.0;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nvec2 noise2(vec2 p)\n{\n\treturn \n\t\tvec2(\n\t\t\tnoise(vec3(p, 1.9+sin(iTime*0.8)*1.3)), \n\t\t\tnoise(vec3(p, -1.2+sin(iTime*1.2)*1.0)));\n}\n\nvec2 noise2(vec2 p, float fudge)\n{\n\treturn \n\t\tvec2(\n\t\t\tnoise(vec3(p, fudge+sin(iTime*0.8)*1.3)), \n\t\t\tnoise(vec3(p, -fudge+sin(iTime*1.2)*1.0)));\n}\n\n\nfloat triangleWave(float value)\n{\n\tfloat hval = value*0.5;\n\treturn 2.0*abs(2.0*(hval-floor(hval+0.5)))-1.0;\n}\n\nvec4 triangleWave(vec4 col)\n{\n\treturn \n\t\tvec4(\n\t\t\ttriangleWave(col.x),\n\t\t\ttriangleWave(col.y),\n\t\t\ttriangleWave(col.z),\n\t\t\ttriangleWave(col.w));\n}\n\n// Mattias' drawing functions ( http://sociart.net/ )\n// Terminals\nvec4 simplex_color(vec2 p) \n{\n\tconst float offset=12.0;\n\tconst float zoom = 2.45;\n\tfloat x = p.x*zoom;\n\tfloat y = p.y*zoom;\n\tvec4 col= vec4(\n\t\tfbm(vec3(x,y, offset)),\n\t\tfbm(vec3(x,y, offset*1.25)),\n\t\tfbm(vec3(x,y, offset*2.33)),\n\t\tfbm(vec3(x,y, offset*3.66)));\n\t\n\treturn (col-0.5)*1.5;\n}\n\nvec4 bw_noise(vec2 p) \n{\n\tp *= 1.5;\n\tfloat val = \n\t\t(noise(vec3(p.x*2.2+sin(iTime*0.6+0.23)*0.22, p.y*2.2, 1.4+sin(iTime)*0.22))*0.66+\n\t\tnoise(vec3(p.x*3.2, p.y*3.2+sin(iTime*1.2-0.3)*0.36, 4.3+sin(iTime*1.1+1.5*0.12)))*0.33)*2.0;\n\t\n\treturn vec4(val);\n}\n\nfloat ridged( vec3 p )\n{\n   \tfloat f = abs(noise(p));\t\t\t\t  \n\tf += abs(0.5000*noise( p )); p = m*p*2.02;\n\tf += abs(0.2500*noise( p )); p = m*p*2.03;\n\tf += abs(0.1250*noise( p ));\n\treturn f;\n}\n\nvec4 ridged_color(vec2 p)\n{\n\tconst float offset=0.2;\n\tfloat x = p.x*2.5;\n\tfloat y = p.y*2.5;\n\tvec4 col= vec4(\n\t\t1.0-ridged(vec3(x,y, offset)),\n\t\t1.0-ridged(vec3(x,y, offset*2.0)),\n\t\t1.0-ridged(vec3(x,y, offset*3.0)),\n\t\t1.0-ridged(vec3(x,y, offset*4.0)));\n\t\n\treturn col-0.55;\n}\n\nvec4 y(vec2 p)\n{\t\n\tfloat val=triangleWave(p.y);\n\treturn vec4(val, val, val, val);\n}\n\nvec4 x(vec2 p)\n{\t\n\tfloat val=triangleWave(p.x);\n\treturn vec4(val, val, val, val);\n}\n\nvec4 x_y_ang_dist(vec2 p)\n{\n\tfloat ang = atan(p.y, p.x);\n\treturn triangleWave(vec4(p.x*p.x+p.y*p.y, p.x, p.y, ang));\n}\n\nvec2 zoom2(vec2 a, vec4 b)\n{\n\treturn vec2(a.x*b.x, a.y*b.y);\n}\n\n// Functions\nvec4 dist(vec2 pos)\n{\n\tfloat d = triangleWave(length(pos));\t\n\treturn vec4(d, d, d, d);\n}\n\nvec4 rol(vec4 col)\n{\n\treturn\n\t\tvec4(col.w, col.x, col.y, col.z);\n}\n\nvec4 ror(vec4 col)\n{\n\treturn\n\t\tvec4(col.y, col.z, col.w, col.x);\n}\n\nconst float pi=3.14159;\nconst float piDiv=1.0/pi;\nconst float pi2 = 2.0*pi;\nvec4 ang(vec2 pos)\n{\n\tfloat angle = atan(pos.y, pos.x)*piDiv;\n\tfloat val = triangleWave(angle);\n\treturn vec4(val, val, val, val);\n}\n\nvec4 add(vec4 a, vec4 b)\n{\n\treturn triangleWave(a+b);\n}\n\t\n\n// Warpers\nvec2 julia(vec2 p)\n{\n\tfloat radius = pow(p.x*p.x+p.y*p.y,0.25);\n\tfloat angle = atan(p.y, p.x)*0.5;\n\treturn vec2(radius * cos(angle), radius*sin(angle));\n}\n\nvec4 sinf(vec4 p)\n{\n\treturn vec4(sin(p.x*pi2), sin(p.y*pi2),sin(p.z*pi2),sin(p.w*pi2));\n}\n\nvec4 minf(vec4 a, vec4 b)\n{\n\treturn triangleWave(min(a,b));\n}\n\nvec2 zoom(vec2 pos, vec4 arg)\n{\n\tfloat zoomFactor = (arg.x+arg.y+arg.z+arg.w)*0.25;\n\treturn pos * zoomFactor;\n}\n\t\nvec2 zoomin(vec2 p)\n{\n\treturn p*piDiv;\n}\n\nvec2 zoomout(vec2 p)\n{\n\treturn p*pi;\n}\n\nvec2 swirl(vec2 p)\n{\n\tfloat swirlFactor = 3.0+timeEffect*(sin(iTime+0.22)-1.5);\n\tfloat radius = length(p);\n\tfloat angle = atan(p.y, p.x);\n\tfloat inner = angle-cos(radius*swirlFactor);\n\treturn vec2(radius * cos(inner), radius*sin(inner));\n}\n\nvec2 horseShoe(vec2 p)\n{\n\tfloat radius = length(p);\n\tfloat angle = 2.0*atan(p.y, p.x);\n\treturn vec2(radius * cos(angle), radius*sin(angle));\n}\n\nvec2 wrap(vec2 p)\n{\n\tfloat zoomFactor = 1.5-timeEffect*(sin(iTime+0.36));\n\tfloat repeatFactor = 3.0;\n\tfloat radius = length(p)*zoomFactor;\n\tfloat angle = atan(p.y, p.x)*repeatFactor;\n\treturn vec2(radius * cos(angle), radius*sin(angle));\n}\n\nvec2 array(vec2 p)\n{\n\tconst float zoomOutFactor=1.5;\n\treturn vec2(triangleWave(p.x*zoomOutFactor), triangleWave(p.y*zoomOutFactor));\n}\n\nvec2 pan_rotate_zoom(vec2 pos, vec4 val)\n{\n\tvec2 pan = vec2(val.w, val.x);\n\tfloat angle= pi*val.y+timeEffect*(sin(iTime+1.2)-1.0);\n\tfloat zoom = val.z;\n\t\n\tfloat sinAngle = sin(angle);\n\tfloat cosAngle = cos(angle);\n\t\n\t// Pan\n\tvec2 next = pos+pan;\n\t// Rotate\n\tnext = \n\t\tvec2(\n\t\t\tcosAngle*next.x-sinAngle*next.y,\n\t\t\tsinAngle*next.x+cosAngle*next.y);\n\t// Zoom\n\tnext *= 1.0+zoom;\n\treturn next;\n}\n\nvec4 blend(vec4 a, vec4 b, vec4 c)\n{\n\tfloat blend = (a.x + a.y + a.z + a.w + 1.0)*0.5;\n\tblend = clamp(blend, 0.0, 1.0);\n\treturn mix(b,c,blend);\n}\n\t\n\nvec2 rotate(vec2 pos, vec4 rotation)\t\n{\n\tfloat simpleSum = rotation.x + rotation.y + rotation.z + rotation.w;\n\tfloat angle = pi * simpleSum * 0.25;\n\tfloat sinAngle = sin(angle);\n\tfloat cosAngle = cos(angle);\n\treturn\n\t\tvec2(\n\t\t\tcosAngle * pos.x - sinAngle * pos.y,\n\t\t\tsinAngle * pos.x + cosAngle * pos.y);\n}\n\nvec2 rotate(vec2 pos, float angle)\t\n{\n\tangle = pi * angle;\n\tfloat sinAngle = sin(angle);\n\tfloat cosAngle = cos(angle);\n\treturn\n\t\tvec2(\n\t\t\tcosAngle * pos.x - sinAngle * pos.y,\n\t\t\tsinAngle * pos.x + cosAngle * pos.y);\n}\n\n/* (array\n  (rotate x-y-ang-dist\n    (blend 1,87471 simplex-color noise))) */\n\nvec4 imageFunction(vec2 pos)\n{\n\tfloat p0 = texture( iChannel0, vec2(0.4,0.0) ).x;\n\tfloat p1 = texture( iChannel0, vec2(0.5,0.0) ).x;\n\tfloat p2 = texture( iChannel0, vec2(0.6,0.0) ).x;\n\tfloat p3 = texture( iChannel0, vec2(0.7,0.0) ).x;\n\tfloat p4 = texture( iChannel0, vec2(1.0,0.0) ).x;\n\t\t\n\t\n\tp4 = 0.4+smoothstep(0.4, 0.8, p4)*0.8;\n\t\n\tvec2 orgPos = pos;\n\tpos = array(pos);\t\t\n\t\n\tpos *= p4;\n\t\n\tpos = rotate(rotate(pos,0.5-p0*orgPos.x+iTime*0.1)+p1*0.5, x_y_ang_dist(pos+p2*0.9));\n\tvec4 color = simplex_color(pos+p3*0.9*orgPos.y+iTime*0.1);\n\t\n\treturn color;\n}\n\n// RENDER\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pos = -1.0 + 2.0*q;\n    pos.x *= iResolution.x/ iResolution.y;\t\n\tvec4 res = imageFunction(pos);\n\tvec4 color = imageFunction(pos);\n\tcolor = (color+1.0);\n\tcolor = ror(color);\t\n\tcolor.w=1.0;\n\tfragColor = color;\t\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mds3R7","date":"1366575901","viewed":275,"name":"Lollypop (sound)","username":"mfagerlund","description":"Shader based on http://sociart.net/image/21469/lollypop , an evolved image","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","evolved"],"hasliked":0,"parentid":"","parentname":""}}