{"ver":"0.1","info":{"id":"WtsyRf","date":"1592637656","viewed":261,"name":"Demofox Path Tracing 2; PBR Fork","username":"kara0xfb","description":"Fork of demofox's shadertoy: https://www.shadertoy.com/view/WsBBR3\nAll rights to him, no infringement intended.\nBlog post at blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/\nFork adds GGX specular BRDF.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing","fork","demofox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    // apply exposure (how long the shutter is open)\n    color *= c_exposure;\n\n    // convert unbounded HDR color range to LDR color range\n    vec3 r = Reinhard(color);\n    //vec3 a = ACESFilm(color);\n    //float diff = PerLum(abs(r-a));\n\n    // convert from linear to sRGB for display\n    color = LinearToSRGB(r);\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.metallic = 0.0f;\n            hitInfo.material.roughness = 0.5f;\n        }\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.metallic = 0.0f;\n            hitInfo.material.roughness = 0.5f;            \n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.metallic = 0.0f;\n            hitInfo.material.roughness = 0.5f;\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.metallic = 0.0f;\n            hitInfo.material.roughness = 0.5f;\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.1f, 0.7f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.metallic = 0.0f;\n            hitInfo.material.roughness = 0.5f;           \n        }        \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * c_lightIntensity;\n            hitInfo.material.metallic = 0.0f;\n            hitInfo.material.roughness = 1.0f;           \n        }        \n    }\n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.9f, 0.5f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n        hitInfo.material.metallic = 0.0f;\n        hitInfo.material.roughness = 0.01f;     \n    } \n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);   \n        hitInfo.material.metallic = 0.0f;\n        hitInfo.material.roughness = 0.5f;       \n    }    \n    \n    // a ball which has blue diffuse but red specular. an example of a \"bad material\".\n    // a better lighting model wouldn't let you do this sort of thing\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.0f, 0.0f, 1.0f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.metallic = 0.0f;\n        hitInfo.material.roughness = 1.0f;        \n    }\n    \n    // shiny green balls of varying roughnesses\n    {\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.metallic = 1.0f;\n            hitInfo.material.roughness = 0.0f;       \n        }     \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.metallic = 1.0f;\n            hitInfo.material.roughness = 0.25f;\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.metallic = 1.0f;\n            hitInfo.material.roughness = 0.5f;\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.metallic = 1.0f;\n            hitInfo.material.roughness = 0.75f;\n        }        \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.metallic = 1.0f;\n            hitInfo.material.roughness = 1.0f;\n        }           \n    }\n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    // initialize\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    \n    for (int b = 0; b <= c_numBounces; ++b)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo;\n        hitInfo.dist = c_superFar;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n        \n        // if the ray missed, we are done\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += SRGBToLinear(texture(iChannel1, rayDir).rgb) * c_skyboxBrightnessMultiplier * throughput;\n            break;\n        }\n        \n        // add light from the surface we hit\n        ret += hitInfo.material.emissive * throughput;\n        \n\t\t// update the ray position\n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        \n        // update the ray direction\n        SScatterInfo scInfo = Scatter(rngState, hitInfo.material, rayDir, hitInfo.normal);\n        if (scInfo.pdf < c_epsilon)\n        {\n         \tbreak;   \n        }\n        \n        rayDir = scInfo.dir;\n        \n        throughput *= scInfo.attenuation;    \n        \n        // Russian Roulette\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        float p = dot(throughput, vec3(0.3333333));\n        if (RandomFloat01(rngState) < p)\n        {\n        \t// Add the energy we 'lose' by randomly terminating paths\n        \tthroughput *= 1.0f / p;            \n        }\n        else\n        {\n            break;\n        }\n    }\n \n    // return pixel color\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    \n    // calculate the camera distance\n\tfloat cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);     \n    \n    // calculate subpixel camera jitter for anti aliasing\n    vec2 jitter = PtTent(Unorm2(rngState));\n    \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3(((fragCoord+jitter)/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    // correct for aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // raytrace for this pixel\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    \tcolor += GetColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    \n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    // show the result\n    fragColor = vec4(color, blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define saturate(x) clamp(x, 0.0f, 1.0f)\n#define lerp(a, b, t) mix(a, b, t)\n#define kRed vec3(1.0f, 0.0f, 0.0f)\n\n// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\n\n// number of ray bounces allowed max\nconst int c_numBounces = 8;\n\n// minimum bounces to begin russian roulette\nconst int c_rrbegin = 0;\n\n// intensity of ceiling light\nconst float c_lightIntensity = 5.0f;\n\n// a multiplier for the skybox brightness\nconst float c_skyboxBrightnessMultiplier = 5.0f;\n    \n// a pixel value multiplier of light before tone mapping and sRGB\nconst float c_exposure = 1.0f; \n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 8;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nconst float c_epsilon = 1.0f / float(1<<22);\n\nconst float KEY_SPACE = 32.5/256.0;\n\nstruct SMaterialInfo\n{\n    vec3 albedo;     // the color used for diffuse lighting\n    vec3 emissive;   // how much the surface glows\n    float metallic;  // percentage chance of doing specular instead of diffuse lighting\n    float roughness; // how rough the specular reflections are\n};\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nstruct SScatterInfo\n{\n \tvec3 dir;\n    vec3 attenuation;\n    float pdf;\n};\n\nbool IsUnitLength(vec3 v)\n{\n    return abs(1.0f - length(v)) < 0.0001f;\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nfloat Unorm1(inout uint state)\n{\n    return RandomFloat01(state);\n}\n\nvec2 Unorm2(inout uint state)\n{\n\treturn vec2(Unorm1(state), Unorm1(state));\n}\n\nvec3 Unorm3(inout uint state)\n{\n \treturn vec3(Unorm1(state), Unorm1(state), Unorm1(state));   \n}\n\nvec4 Unorm4(inout uint state)\n{\n \treturn vec4(Unorm1(state), Unorm1(state), Unorm1(state), Unorm1(state));  \n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// tent filter from smallpt\nvec2 PtTent(vec2 Xi)\n{\n \tXi *= 2.0f;\n    Xi.x = Xi.x < 1.0f ? sqrt(Xi.x) - 1.0f : 1.0f - sqrt(2.0f - Xi.x);\n    Xi.y = Xi.y < 1.0f ? sqrt(Xi.y) - 1.0f : 1.0f - sqrt(2.0f - Xi.x);\n    return Xi;\n    \n}\n\n// Cubic root fit of Linear to sRGB conversion\n// clamps output, since output is expected to enter framebuffer\nvec3 LinearToSRGB(vec3 linear)\n{\n\tvec3 s1 = sqrt(linear);\n    vec3 s2 = sqrt(s1);\n    vec3 s3 = sqrt(s2);\n    vec3 srgb = 0.582176f * s1 + 0.789747f * s2 - 0.371449f * s3;\n    return saturate(srgb);\n}\n\n// Cubic fit of sRGB to linear conversion\n// does not clamp output\nvec3 SRGBToLinear(vec3 sRGB)\n{\n    vec3 c2 = sRGB * sRGB;\n    vec3 c3 = c2 * sRGB;\n    return 0.016124f * sRGB + 0.667737f * c2 + 0.317955f * c3;\n}\n\n// perceptual luminance, based on human eye sensitivity\nfloat PerLum(vec3 x)\n{\n \treturn dot(x, vec3(0.2126f, 0.7152f, 0.0722f));  \n}\n\n// neutral looking tonemapping operator\nvec3 Reinhard(vec3 x)\n{\n \treturn x / (1.0f + x);   \n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    // scale factor of 0.6 to match original ACES curve (see comments in article)\n    x *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return (x*(a*x + b)) / (x*(c*x + d) + e);\n}\n\n// common re-parameterization of alpha = roughness^2\nfloat GetAlpha(float roughness)\n{\n    // NaN guard to avoid alpha=0\n \treturn max(roughness * roughness, 0.001f);   \n}\n\n// specular color (reflectance) at normal incidence (N==L)\nvec3 F0(vec3 albedo, float metallic)\n{\n \treturn lerp(vec3(0.04f), albedo, metallic);\n}\n\n// Specular 'F' term\n// Schlick's approximation\n// specular reflectance given HoV or HoL (symmetric about microfacet)\n// f0: normal reflectance\n// f90: tangent reflectance (usually 1.0)\nvec3 F_Schlick(vec3 f0, vec3 f90, float cosTheta)\n{\n    float t = 1.0f - cosTheta;\n    float t5 = t * t * t * t * t;\n    return lerp(f0, f90, t5);\n}\n\n// scalar version\nfloat F_Schlick1(float f0, float f90, float cosTheta)\n{\n    float t = 1.0f - cosTheta;\n    float t5 = t * t * t * t * t;\n    return lerp(f0, f90, t5);\n}\n\n// Specular 'D' term\n// represents the normal distribution function\n// Trowbridge-Reitz GGX approximation\nfloat D_GTR(float NoH, float alpha)\n{\n \tfloat a2 = alpha * alpha;\n    float f = lerp(1.0f, a2, NoH * NoH);\n    return a2 / (f * f * c_pi);\n}\n\n// Specular 'G' term\n// Correlated version of Smith's approximation\n// represents the self shadowing and masking of microfacets in rough materials\nfloat G_SmithGGX(float NoL, float NoV, float alpha)\n{\n    float a2 = alpha * alpha;\n    float NoL2 = NoL * NoL;\n    float NoV2 = NoV * NoV;\n    float v = sqrt(1.0f + a2 * (1.0f - NoL2) / NoL2) - 1.0f;\n    float l = sqrt(1.0f + a2 * (1.0f - NoV2) / NoV2) - 1.0f;\n    float g = 1.0f / (1.0f + 0.5f * v + 0.5f * l);\n    return g;  \n}\n\n// Lambert diffuse brdf\nfloat Fd_Lambert() { return 1.0f / c_pi; }\n\n// Maps a value in unorm square to a value in snorm circle\n// \"A Low Distortion Map Between Disk and Square\" by Peter Shirley and Kenneth Chiu.\nvec2 MapSquareToDisk(vec2 Xi)\n{\n    const float kPiD4 = c_pi / 4.0f;\n\n    float phi = 0.0f;\n    float r = 0.0f;\n\n    float a = 2.0f * Xi.x - 1.0f;\n    float b = 2.0f * Xi.y - 1.0f;\n    if (a > -b)\n    {\n        if (a > b)\n        {\n            r = a;\n            phi = kPiD4 * (b / a);\n        }\n        else\n        {\n            r = b;\n            phi = kPiD4 * (2.0f - (a / b));\n        }\n    }\n    else\n    {\n        if (a < b)\n        {\n            r = -a;\n            phi = kPiD4 * (4.0f + (b / a));\n        }\n        else\n        {\n            r = -b;\n            if (b != 0.0f)\n            {\n                phi = kPiD4 * (6.0f - (a / b));\n            }\n        }\n    }\n\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\n// produces an orthonormal basis about N\n// https://psgraphics.blogspot.com/2014/11/making-orthonormal-basis-from-unit.html\nmat3 NormalToTBN(vec3 N)\n{\n    mat3 TBN;\n    TBN[2] = N;\n    if (N.z < -0.9999f)\n    {\n    \tTBN[0] = vec3(0.0f, -1.0f, 0.0f);\n        TBN[1] = vec3(-1.0f, 0.0f, 0.0f);\n    }\n    else\n    {\n    \tfloat a = 1.0f / (1.0f + N.z);\n    \tfloat b = -N.x * N.y * a;\n        TBN[0] = vec3(1.0f - N.x * N.x * a, b, -N.x);\n        TBN[1] = vec3(b, 1.0f - N.y * N.y * a, -N.y);\n    }\n    TBN[0] = normalize(TBN[0]);\n    TBN[1] = normalize(TBN[1]);\n    return TBN;\n}\n\n// linear combination of orthonormal basis and unit vector.\nvec3 TbnToWorld(mat3 TBN, vec3 Nts)\n{\n \tvec3 r = TBN[0] * Nts.x;\n    vec3 u = TBN[1] * Nts.y;\n    vec3 f = TBN[2] * Nts.z;\n    return normalize(r + u + f);\n}\n\n// cache TBN when possible\nvec3 TanToWorld(vec3 Nws, vec3 Nts)\n{\n    return TbnToWorld(NormalToTBN(Nws), Nts);\n}\n\n// importance samples the GGX NDF for a microfacet normal H\n// output is in tangent space: N=(0,0,1)\nvec3 SampleGGXMicrofacet(vec2 Xi, float alpha)\n{\n    float a2 = alpha * alpha;\n    float phi = 2.0f * c_pi * Xi.x;\n    float cosTheta = sqrt((1.0f - Xi.y) / (1.0f + (a2 - 1.0f) * Xi.y));\n    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);\n    vec3 dir = vec3(\n        cos(phi) * sinTheta,\n        sin(phi) * sinTheta,\n        cosTheta);\n    return normalize(dir);\n}\n\n// samples a cosine weighted direction\n// output is in tangent space: N=(0,0,1)\nvec3 SampleCosineHemisphere(vec2 Xi)\n{\n    Xi = MapSquareToDisk(Xi);\n    float r = dot(Xi, Xi);\n    float z = sqrt(max(0.0f, 1.0f - r));\n    vec3 dir = vec3(Xi.x, Xi.y, z);\n    return normalize(dir);\n}\n\n// reflects an incident direction about a microfacet normal of the GGX NDF\nvec3 ScatterGGX(vec2 Xi, vec3 I, vec3 N, float alpha)\n{\n \tvec3 m = TanToWorld(N, SampleGGXMicrofacet(Xi, alpha));\n    return normalize(reflect(I, m));\n}\n\nvec3 ScatterCosine(vec2 Xi, vec3 N)\n{\n \treturn TanToWorld(N, SampleCosineHemisphere(Xi));   \n}\n\nfloat LambertPdf(float NoL)\n{\n \treturn NoL / c_pi;   \n}\n\nfloat GGXPdf(float NoH, float HoV, float alpha)\n{\n \tfloat d = D_GTR(NoH, alpha);\n    return (d * NoH) / max(c_epsilon, 4.0f * HoV);\n}\n\nSScatterInfo Scatter(inout uint state, SMaterialInfo mat, vec3 I, vec3 N)\n{\n    float alpha = GetAlpha(mat.roughness);\n    \n    float amountDiffuse = 1.0 - mat.metallic;\n    const float amountSpecular = 1.0;\n    float chanceSpecular = 1.0 / (amountSpecular + amountDiffuse);\n    vec2 Xi = Unorm2(state);\n    bool specular = RandomFloat01(state) < chanceSpecular;\n    vec3 L = specular ? ScatterGGX(Xi, I, N, alpha) : ScatterCosine(Xi, N);\n    \n    vec3 V = -I;\n    vec3 H = normalize(V + L);\n    float NoH = saturate(dot(N, H));\n    float HoV = saturate(dot(H, V));\n    float NoV = saturate(dot(N, V));\n    float NoL = saturate(dot(N, L));\n    \n    float diffusePdf = amountDiffuse * LambertPdf(NoL);\n    float specularPdf = amountSpecular * GGXPdf(NoH, HoV, alpha);\n    float pdf = diffusePdf + specularPdf;\n    \n    SScatterInfo info;\n    info.dir = L;\n    info.pdf = 0.0f;\n    info.attenuation = vec3(0.0f);\n    if ((pdf < c_epsilon) || (NoL < c_epsilon))\n    {\n        return info;\n    }\n    \n    vec3 brdf = vec3(0.0f);\n    vec3 F;\n    {\n     \tvec3 f0 = F0(mat.albedo, mat.metallic);\n        F = F_Schlick(f0, vec3(1.0f), HoV);\n        float D = D_GTR(NoH, alpha);\n        float G = G_SmithGGX(NoL, NoV, alpha);\n        vec3 Fr = F * D * G;\n        brdf += amountSpecular * Fr;\n    }\n    {\n        vec3 Fd = (vec3(1.0) - F) * mat.albedo * Fd_Lambert();\n        brdf += amountDiffuse * Fd;\n    }\n    \n    info.attenuation = (brdf * NoL) / pdf;\n    info.pdf = pdf;\n    return info;\n}","name":"Common","description":"","type":"common"}]}