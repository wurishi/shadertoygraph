{"ver":"0.1","info":{"id":"l3cSWn","date":"1718935802","viewed":47,"name":"2D Brillouin zones","username":"null_lambda","description":"1st and higher Brillouin zones of 2D lattice structures","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159265\n\nvec3 colorPalette(float t) {\n    t = mod(t, 4.);\n    return (max(1.-abs(t), 0.) + max(1.-abs(t-4.), 0.)) * vec3(0.933,0.424,0.302)\n        + max(1.-abs(t-1.), 0.) * vec3(0.878,0.984,0.988) \n        + max(1.-abs(t-2.), 0.) * vec3(0.596,0.757,0.851)\n        + max(1.-abs(t-3.), 0.) * vec3(0.239,0.353,0.502);\n}\n\nvec4 renderBrillouinZones(float scale, vec2 p, vec2 ax1, vec2 ax2, float aa) {\n  \n    // Count required number of bragg planes to reach origin\n    float zoneIdx = 0.;\n    \n    float rBound =  scale * sqrt(1. + pow(iResolution.x / iResolution.y, 2.));\n    int n1 = int(ceil(rBound /  sqrt(1e-8 + dot(ax1, ax1) - pow(dot(ax1, ax2), 2.) / dot(ax2, ax2)))); \n    int n2 = int(ceil(rBound / length(ax2))) + 1; \n    \n    // Limit loop size\n    const float nBound = 100.;\n    n1 /= int(sqrt(max(float(n1 * n2)/nBound, 1.)));\n    n2 /= int(sqrt(max(float(n1 * n2)/nBound, 1.)));\n    \n    for(int i=-n1; i<=n1; i++) {\n        int n2_shift = -int(round(float(i) * dot(ax1, ax2) / dot(ax2, ax2)));\n        for(int j=-n2 + n2_shift; j<=n2 + n2_shift; j++) {\n            vec2 v = float(i) * ax1 + float(j) * ax2;\n            float dist = dot(v, p - .5 * v);\n            zoneIdx += smoothstep(0., length(v) * aa, dist);\n        }\n    }\n    \n    return vec4(colorPalette(zoneIdx), 1.);\n}\n\nfloat renderLatticePoints(vec2 p, float b1, float b2, float alpha, vec2 ax1, vec2 ax2, float aa) {\n    // Closest reciprocal lattice point\n    vec2 rs = round(inverse(mat2(ax1, ax2)) * p);\n    vec2 p_lattice = rs.x * ax1 + rs.y * ax2;\n    \n    float min_lattice_dist = min(min(b1, b2), sqrt(b1*b1 + b2*b2 - 2.*b1*b2*abs(cos(alpha))));\n    float dist = .1 * min_lattice_dist - length(p - p_lattice);\n    return smoothstep(0., aa, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates \n    float scale = 5.;\n    // float scale = 2.5 + 5. * pow(sin(iTime * 0.8), 2.);\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    vec2 p = scale * uv;\n    \n    // Reciprocal lattice parameters and basis\n    float b1 = 1.;\n    float b2 = 1.;\n    // float alpha = M_PI*.02;\n    float alpha = iTime * .2;\n    \n    vec2 ax1 = vec2(b1, 0);\n    vec2 ax2 = vec2(b2 * cos(alpha), b2 * sin(alpha));\n    \n    // Anti-aliasing length scale\n    float aa = 1.2 * scale / iResolution.y;\n    \n    // Render\n    fragColor = mix(vec4(1), renderBrillouinZones(scale, p, ax1, ax2, aa), 0.6);\n    fragColor = mix(fragColor, vec4(vec3(0.05), 1.), 0.8 * renderLatticePoints(p, b1, b2, alpha, ax1, ax2, aa));\n }\n ","name":"Image","description":"","type":"image"}]}