{"ver":"0.1","info":{"id":"tltSWr","date":"1580886017","viewed":537,"name":"I heart Fourier","username":"harry7557558","description":"As a beginner to Fourier series, inspired by a picture on my religion teacher's slide. ","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["heart","fourier","love"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 path[18];\nvec2 a[10], b[10];  // 10 = int(18 / 2) + 1\nvoid init() {\n\t// manual point set\n\tpath[0] = vec2(1.0137, 0.3967);\n\tpath[1] = vec2(0.5626, 0.5417);\n\tpath[2] = vec2(0.3414, -0.0639);\n\tpath[3] = vec2(0.1158, 0.6121);\n\tpath[4] = vec2(-0.7459, 0.7070);\n\tpath[5] = vec2(-0.8443, 0.1465);\n\tpath[6] = vec2(-0.3618, 0.1444);\n\tpath[7] = vec2(-0.1585, 0.4285);\n\tpath[8] = vec2(-0.3173, 0.3743);\n\tpath[9] = vec2(-0.4706, -0.2456);\n\tpath[10] = vec2(-0.7936, -0.3968);\n\tpath[11] = vec2(-0.5655, -0.1589);\n\tpath[12] = vec2(0.2119, -0.6991);\n\tpath[13] = vec2(0.2968, -0.9548);\n\tpath[14] = vec2(0.3969, -0.4136);\n\tpath[15] = vec2(0.7119, 0.0779);\n\tpath[16] = vec2(0.6283, 0.2814);\n\tpath[17] = vec2(0.7057, -0.0209);\n\n\t// calculate Fourier coefficients, b[0] is always zero\n\tfloat t, dt;\n\tfor (int k = 0; k < 10; k++) {\n\t\ta[k] = vec2(0.), b[k] = vec2(0.);\n\t\tt = 0.0, dt = 6.283185 * float(k) / 18.;\n\t\tfor (int i = 0; i < 18; i++, t += dt)\n\t\t\ta[k] += path[i] * cos(t), b[k] += path[i] * sin(t);\n\t\ta[k] = a[k] * (2.0 / 18.), b[k] = b[k] * (2.0 / 18.);\n\t}\n\ta[0] = a[0] * 0.5;\n}\n\nvec2 eval(float t) {\n\tvec2 r = a[0];\n    float c0 = cos(t), s0 = sin(t), c = c0, s = s0, c1;\n    for (int k = 1; k < 10; k++) {\n        r += a[k] * c + b[k] * s;\n        c1 = c, c = c * c0 - s * s0, s = c1 * s0 + s * c0;\n    }\n\treturn r;\n}\n\n\n// an improvement of iq's https://www.shadertoy.com/view/Xlf3zl\nfloat sdSqSegment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tvec2 q = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn dot(q, q);\n}\nfloat sd(vec2 p) {\n\tfloat o = sin(0.5*iTime); o = .04 + .005*o*o;  // path offset\n\tfloat o2 = (o + .02)*(o + .02);\n\tfloat t_max = 6.3*min(1.5*fract(0.15*iTime), 1.0);\n\tvec2 a = eval(0.0), b, c;\n\tfloat dt = 0.05, t = dt;\n\tfloat d = 1e8, dd;\n\twhile (t < t_max) {\n\t\tb = eval(t);\n\t\tdd = sdSqSegment(p, a, b);\n\t\tif (dd < o2) {  // more accurate and doesn't reduce much speed\n\t\t\tc = eval(t - 0.5*dt);\n\t\t\tdd = min(sdSqSegment(p, a, c), sdSqSegment(p, c, b));\n\t\t}\n\t\td = min(d, dd);\n\t\tdt = clamp(0.026*length(a - p) / length(a - b), 0.02, 0.1);\n\t\tt += dt;\n\t\ta = b;\n\t}\n\td = min(d, sdSqSegment(p, a, eval(t_max))); \t// add this line to eliminate gaps\n\td = min(sqrt(d), abs(length(p) - 0.15));\n\treturn d - o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tinit();\n\tvec2 p = 5.0 * (fragCoord - 0.5*iResolution.xy) / length(iResolution.xy);\n\tfloat d = sd(p - vec2(-.1, .08));\n\n    // modified from iq's sdf visualizing function\n\tvec3 col = d > 0. ? vec3(1.0, 0.3, 0.5) : vec3(0.3, 1.5, 2.7);\n\tcol *= 1.0 - 0.9*exp(-6.*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.*d - 3.0*iTime);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}