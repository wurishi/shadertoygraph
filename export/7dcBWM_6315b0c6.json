{"ver":"0.1","info":{"id":"7dcBWM","date":"1656605940","viewed":186,"name":"d4 reflections","username":"pb","description":"d4 reflections, similar to d20 bubbles but using tetrahedron, more iterations and some lighting and color changes","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["reflections","metal","sierpinksi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//this one seems to need some post processing to smooth it out\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3[] d20 = vec3[] (\nvec3(1.,1.,1.),\nvec3(-1.,-1.,1.),\nvec3(1.,-1.,-1.),\nvec3(-1.,1.,-1)\n);\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n\n#define MAX_RAY_STEPS 100\n#define MAX_PRIME_RAY_DIST 10.\n#define PI 3.14159265\n\nint max_iter;\nvec3 ifs_color;\nfloat ifs_scale;\n\nvec3 ambientL  = vec3(.2,.2,.7);\nvec3 diffuseL  = vec3(.6,.2,.6);\nvec3 specularL = vec3(.8,0.,0.);\nvec3 ambdir    = normalize(vec3(-1.,0.,1.));\n\n\nstruct RAYMARCH_RESULT {\n    vec3  raypos;\n    float dist_from_origin;\n    float object_id;\n};\n\n\nvec3  light_pos = vec3(0.,0., 1.);\nvec2  myMouse;\nvec3  ro,rd;\n\nfloat sphere_sdf( vec3 pos, float r ) {\n    return length(pos) - r;\n}\n\nmat3 rot_xz(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(cc,0.,ss,0.,1.,0.,-ss,0.,cc);\n\n}\n\nvec2 dist_func01(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    ifs_color = vec3(0.);\n\n    for (int i=0; i<100; i++) {\n       \n        if ( i > max_iter ) break;\n\n        float w = iTime/3.;\n        vec3 dd_0 = rot_xz(w)*d20[0];\n        min_vtx = dd_0;\n        min_dist=length(z-dd_0);\n        for (int j=1; j<4; j++) {\n            vec3 ddj = rot_xz(w)*d20[j];\n            dist_to_vtx=length(z-ddj); \n            if (dist_to_vtx<min_dist) {min_vtx=ddj; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n\n        //potentially interesting colors\n        \n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n        \n        \n    }\n\n    ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    //tunnelling through when we are close enough\n    scene_dist = max( scene_dist, -(length(orig_z-ro)-.5) );\n    \n    return vec2( scene_dist, objid );\n}\n\n\nvec3 estimate_normal_vec( vec3 pos, float neps ) {\n\n    // in other words - the Gradient Vector...\n    \n    float norm_sign = 1.; \n\n    vec2  np = norm_sign * normalize(vec2( 1., -1)); //putting the wrong sign here makes a glossy effect\n\n    vec2  dp = vec2( neps, -neps);\n   \n    vec3 df1 = np.xxx * dist_func01( pos + dp.xxx ).x;\n    vec3 df2 = np.xyy * dist_func01( pos + dp.xyy ).x;\n    vec3 df3 = np.yxy * dist_func01( pos + dp.yxy ).x;\n    vec3 df4 = np.yyx * dist_func01( pos + dp.yyx ).x;\n    \n    \n    return normalize( df1 + df2 + df3 + df4 );\n\n}\n\n\nRAYMARCH_RESULT raymarch( vec3 ro, vec3 rd, float eps, float initial_object_id ) {\n\n    float dist_from_origin = 0.; \n    vec3 raypos = ro;\n    RAYMARCH_RESULT result;\n    result.object_id = initial_object_id; \n    result.dist_from_origin = 0.;\n   \n    float threshold = eps;\n    \n    for (int i=0; i<MAX_RAY_STEPS && dist_from_origin < MAX_PRIME_RAY_DIST; i++) {\n    \n        vec3 raypos = ro + dist_from_origin * rd;\n        vec2 dist_to_closest = dist_func01(raypos);\n        if ( abs(dist_to_closest.x) < threshold ) {\n        \n            result.object_id = dist_to_closest.y;\n            result.raypos = raypos;\n            result.dist_from_origin = dist_from_origin;\n            \n            break;\n        }\n        \n\n        raypos += dist_from_origin*rd; \n\n        dist_from_origin += dist_to_closest.x;\n        \n        threshold *= (1.+dist_from_origin*dist_from_origin*80.);\n        \n    }\n       \n    return result;\n    \n}\n\nvec3  main_loop( vec3 ro, vec3 rd ) {\n    \n    RAYMARCH_RESULT prime_ray = raymarch( ro, rd, .00001, 100.);\n    \n    vec3 color = vec3(0.);\n    \n    if (prime_ray.object_id > -1. ) { \n    \n        //ambdir = normalize(ro - prime_ray.raypos);\n    \n        vec3 nn = estimate_normal_vec( prime_ray.raypos, .001 );\n        \n        vec3 lt_pos = light_pos + vec3( 6.*cos(iTime/3.), .5*sin(iTime/5.) , 6.*sin(iTime/2.) );  \n        float spec_pow = 16.; \n        float spec_amp = 1.;\n        \n        //the signs on the lighting vectors is wrong, \n        //initially an accident but now intentional\n        //looks more interesting\n        vec3 view_dir= rd;\n        vec3 light_dir=normalize(lt_pos-prime_ray.raypos); \n        float diffuse_light = clamp(dot(light_dir, nn), 0., 1.);\n        float ambient_light = -0.5 * dot(nn, ambdir);\n     \n        vec3 refl=reflect(view_dir,nn);\n        float specular_light=pow(max(dot(refl,light_dir),0.0),spec_pow);\n        \n        vec3 fractal_color = cos( vec3(ifs_color.x*2.,\n                                       ifs_color.y*3., \n                                       ifs_color.z*5. ) );\n        \n        //give a hint at what happens during function iteration\n        fractal_color = pow(fractal_color,vec3(2.) );\n        \n        color = ambient_light  * ambientL + \n                diffuse_light  * (diffuseL-.5*fractal_color)  +\n                spec_amp*specular_light * specularL;\n             \n        color *= exp(-prime_ray.dist_from_origin/10.);\n        \n        vec3 new_ro = prime_ray.raypos + nn*.01;\n        vec3 new_rd = reflect( rd, nn );\n        RAYMARCH_RESULT reflection = raymarch( new_ro, new_rd, .00005, 100.);\n        \n        \n        if ( reflection.object_id > -1. ) {\n  \n            \n            vec3 nn2 = estimate_normal_vec( reflection.raypos, .02 ); \n         \n            vec3 light_dir2=normalize(lt_pos-reflection.raypos); \n            \n            float diffuse_light2 = clamp(dot(light_dir2, nn2), 0., 1.);\n            float ambient_light2 = 0.5 * dot(nn2, ambdir);\n                 \n \n            vec3 view_dir2 = new_rd;\n            \n            vec3 refl2=reflect(view_dir2,nn);\n            float specular_light2 = pow(max(dot(refl2,light_dir2),0.0),spec_pow);\n        \n            vec3 reflect_color = ambient_light2 * ambientL +\n                                 diffuse_light2 * diffuseL +\n                                 spec_amp*specular_light2 * specularL; \n                                 \n            float color_fac = 1.;\n            \n            reflect_color *= exp(-reflection.dist_from_origin/10.);\n\n            color += color_fac *  reflect_color;\n            \n        }    \n                      \n    }\n\n    //color -= .3*ifs_color;\n    return clamp(color, 0., 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float myTime = iTime/5.;\n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    myMouse = (iMouse.xy*2.0 - iResolution.xy) / iResolution.y;\n    \n    ifs_scale = 1.8; //2.1 - .9*abs(sin(iTime/120.));\n    max_iter = 10 ;  // - int(5.*abs(sin(myTime/2.)));\n    ro = vec3(0.3,0.,-2.7 + max(-.9,min(3.,3.*(sin(myTime-PI/2.)))) );  //ray origin\n    rd = normalize( vec3(uv, 1.7 ) );  //ray direction\n    \n    vec3 color = main_loop(ro, rd);\n \n    //looks better without any pow wowing\n    //color = pow( color, vec3(.6) );\n    \n    fragColor = vec4(color,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}