{"ver":"0.1","info":{"id":"WlsXzf","date":"1563785527","viewed":253,"name":"Dolphin Hologram","username":"96logda","description":"Procedural generated Menger Sponge world with some dolphins.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","water","underwater","mengersponge","dolphin","hologram","proceduralworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-07-13 - 2019-07-28 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://iquilezles.org/articles/menger\n\n//Copyright (c) 2019-07-13 - 2019-07-16 by Angelo Logahd\n//My orginal version:\n//http://glslsandbox.com/e#56191.0\n\n#define PI\t\t\t\t\t3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n\n#define MENGER_ITERATIONS\t3\n#define SOFT_SHADOW_STEPS \t32\n\n#define INTERSECT_STEPS\t\t200\n#define INTERSECT_MIN_DIST\t0.001\n#define INTERSECT_MAX_DIST\t100.0\n\nconst float DOLPHIN_ROTATION_SPEED = 1.1;\n\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    float k0 = length(p / r);\n    return k0 * (k0 - 1.0) / length(p / (r * r));\n}\n\nfloat curDolphinAngle = 0.0;\nfloat deDolphin(vec3 p)\n{\n    vec3 q;\n    float dMin;\n    float dBodyA;\n    float dBodyB;\n    float dMouth;\n    float dFin;\n    float dFinTop;\n    float dHands;\n    float dEye;\n    float d;\n\n    p.x += 8.0;\n    p.z += 1.5;\n\n    curDolphinAngle = 0.08 * sin(PI * iTime * DOLPHIN_ROTATION_SPEED);\n\n    p.xz = rotate2D(p.xz, -1.5);\n    p.x = abs(p.x);  \n    p.z -= 3.0;\n    p.yz = rotate2D(p.yz, curDolphinAngle);\n    q = p - vec3(0.0, 0.0, -0.65);\n    dBodyA = sdEllipsoid(q, vec3 (0.7, 0.8, 2.4));\n\t\n    q = p;\n    q.z -= -1.8;\n    q.yz = rotate2D(q.yz, curDolphinAngle);\n    q.z -= -1.6;\n    dBodyB = sdEllipsoid(q, vec3(0.40, 0.5, 2.5));\n\t\n    q.z -= -2.2;\n    q.xy = rotate2D(q.xy, 2.0 * curDolphinAngle);\n    q.xz -= vec2(0.5, -0.5);\n    q.yz = rotate2D(q.yz, 0.4);\n    dFin = sdEllipsoid(q, vec3(0.7, 0.05, 0.3));\n\t\n    q = p;\n    q.xy = rotate2D(q.xy, 2.0 * curDolphinAngle * 1.25);\n    q.yz -= vec2(-0.3, 0.1);\n    dHands = sdEllipsoid(q, vec3(1.8, 0.07, 0.4));\n\t\n    dFinTop = 1.0;\n    q = p;\n    q.y -= 0.8;\n    q.z -= -1.5;\n    q.yz = rotate2D(q.yz, 0.5);\n    q.xz = rotate2D(q.xz, 1.0);\n    dFinTop = sdEllipsoid(q, vec3(0.2, 0.6, 0.1));\n\t\n    dMin = smin(dBodyA, dBodyB,  0.1);\n    dMin = smin(dMin,   dFin,    0.1);\n    dMin = smin(dMin,   dHands,  0.1);\n    dMin = smin(dMin,   dFinTop, 0.1);\n    return dMin;\n}\n\nvec4 map(in vec3 p)\n{\t\n    p.xz = mod(p.xz + 1.0, 2.0) - 1.0;\n    p.y  = mod(p.y  + 1.0, 2.0) - 1.0;\n\t\n    float d = sdEllipsoid(p, vec3(1.0));\n    vec4 res = vec4(d, 1.0, 0.0, 0.0);\n\t\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    { \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 7.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 0.5) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.3 * da * db * dc), 0.0, 1.0);\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).y;\n        res = min(res, k * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n    \t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n     float tmin = 0.0;\n     float tmax = 40.0;\n\t\n     float precis = 0.001;\n     float t = tmin;\n     float m = -1.0;\n     for (int i = 0; i < 100; ++i)\n     {\n    \t float res = deDolphin(ro + rd * t);\n    \t if (res < precis || t > tmax)\n         {\n             break;\n         }\n   \t \t t += res;\n    \t m = res;\n     }\n\n     if (t > tmax)\n     {\n\t \tm = -1.0;\n     }\n\t\n     return vec2(t, m);\n}\n\nvec3 renderDolphin(in vec3 ro, in vec3 rd)\n{ \n    vec3 color = vec3(0.0);\t\n    vec2 res = castRay(ro, rd);\n    if (res.y > -0.5)\n    {\n\t \tconst vec3 light = vec3(0.5, 0.5, -0.5);\n\t\t\n\t \tvec3 pos = ro + res.x * rd;\n\t\n\t \tfloat red   = clamp(sin(iTime * 0.8), 0.2, 0.8);\n\t \tfloat green = clamp(cos(iTime * 0.4), 0.2, 0.8);\n\t \tfloat blue  = clamp(sin(iTime * 0.2), 0.2, 0.8);\n\t    \n        vec3 baseColor = vec3(red, green, blue);\n\t \tvec3 ambient = vec3(0.5) * baseColor;\n\t \tvec3 normal = calcNormal(pos);\n\t\t\n\t \tfloat shadow = softshadow(pos + 0.001 * normal, light, 32.0);\t\n\t \tvec3 diffuse = baseColor * shadow * vec3(0.2, 0.0, 10.0);\n\t\t\n\t \tcolor = diffuse + ambient;\n    }\t\n    return color;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light = vec3(0.0, 0.0, -0.5);\n\t\t\n\t\tvec3 pos = ro + res.x * rd;\n\t\n        vec3 baseColor = vec3(0.0, 0.2, 0.6);\n\t\tvec3 ambient = vec3(0.2) * baseColor;\n\t\t\n\t\tvec3 normal = calcNormal(pos);\n\t\tvec3 reflection = reflect(rd, normal);\n\t\n\t\tfloat occ = res.y;\n\t\tfloat shadow = softshadow(pos + 0.001 * normal, light);\n\t\n\t\tvec3 diffuse = baseColor * shadow * occ;\t\n\t\tcolor = diffuse + ambient;\n    }\n    \n    color += renderDolphin(ro, rd);\n    color += renderDolphin(ro + vec3(10.5, -1.3, 4.5), rd);\n    color += renderDolphin(ro + vec3(15.5, -1.3, -4.5), rd);\n\n    color += vec3(0.0, 0.05, 0.20);\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n    vec3 ro = vec3(12.25, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n\n    ro.x -= iTime * 0.1; //Camera / Ray moving\n\t\n \tvec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd);    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}