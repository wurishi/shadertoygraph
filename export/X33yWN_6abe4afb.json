{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/* This demonstrates how a Gaussian function can be created by\nadding together cosines of different frequencies when their intensity\nis proportional to the Gaussian of the cosine's frequency.\n\nEach cosine is represented visually as a band, with negative values\nin purple and positive values in amber. They all add up together into\none band which becomes a Gaussian function (albeit one that repeats).\n\nThis also contains the gamut_limiter() function which allows me to use\nout of gamut colours (where a channel or two is over 1) and bring them\nback into the gamut by desaturation so instead of dumbly capping at 1\nthe channels spread their extra energy to other channels and go towards\nwhite.\n*/\n\n\nfloat gaussian(float x)\n{\n\treturn exp(-x*x);\n}\n\nvec3 lsrgb(vec3 l)\t// converts a [0.0, 1.0] linear value into a [0.0, 1.0] sRGB value\n{\n\tvec3 line = l * 12.92;\n\tvec3 x = sqrt(l);\n\tvec3 curve = ((((0.455*x - 1.48)*x + 1.92137)*x - 1.373254)*x + 1.51733216)*x - 0.0404733783;\n\treturn mix(line, curve, greaterThan(l, vec3(0.0031308)));\n}\n\nvec3 gamut_limiter(vec3 pv)\n{\n    // Find the maximum of the 3 channels\n    float vmax = max(pv.x, max(pv.y, pv.z));\n    \n    if (vmax > 1.)   // if the colour is out of gamut\n    {\n        // Luminosity of the colour's grey point\n        float L = 0.16*pv.x + 0.73*pv.y + 0.11*pv.z;\n\n\t\tif (L < 1.) // if the grey point is no brighter than white\n\t\t{\n\t\t\t// t represents the ratio on the line between the input colour\n\t\t\t// and its corresponding grey point. t is between 0 and 1,\n\t\t\t// a lower t meaning closer to the grey point and a\n\t\t\t// higher t meaning closer to the input colour\n\t\t\tfloat t = (1.-L) / (vmax-L);\n\n\t\t\t// a simple linear interpolation between the\n\t\t\t// input colour and its grey point\n            pv = mix(vec3(L), pv, t);\n\t\t}\n\t\telse    // if it's too bright regardless of saturation\n\t\t{\n\t\t\tpv = vec3(1.);\n\t\t}\n    }\n    \n    return pv;\n}\n\nfloat formula(float x, float y, float t, float iterations)\n{\n    float width = 0.18;\n    float i, v, off_y, sum = 0.;\n\n    // Loop through each frequency to add them together\n    for (i=0.; i < iterations; i += 1.)\n    {\n        // Calculate cosine with its amplitude proportional to the Gaussian of its frequency\n        v = cos(x*i) * gaussian(i*width);\n\n        // Double every non-zero frequency due to combining positive and negative frequencies\n        if (i != 0.)\n            v *= 2.;\n\n        // Make it a band\n        off_y = max(0., (i-t)*2.);\n        v *= gaussian((off_y-y)*2.9);\n\n        // Add it to sum\n        sum += v;\n    }\n\n    // Dim the sum\n    sum *= 0.2;\n    //sum = (sum-1.)*40.;\n\n    return sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Pixel to world coordinates\n    float scrscale = 8. / iResolution.y;\n    vec2 uv = (fragCoord-iResolution.xy*0.5) * scrscale;\n\n    float iterations = 14.;\n    float neg_dur = 0.7;\n    float t = mod(iTime*1.333, iterations+neg_dur) - neg_dur;\n\n    float v = formula(uv.x, uv.y+1., t, iterations);\n\n    float curve = formula(uv.x, 0., t, iterations) * 0.5;\n    curve = gaussian((curve - (uv.y+3.5))*70.);\n\n    // Pixel color\n    vec3 pv = vec3(0.2, 0.6, 3.) * vec3(curve);\n    pv += vec3(1., 0.45, 0.05) * vec3(max(v, 0.));\n    pv += vec3(1., 0.05, 0.666) * vec3(max(-v, 0.));\n    fragColor = vec4(lsrgb(gamut_limiter(pv)), 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"X33yWN","date":"1735049532","viewed":104,"name":"Adding cosines into a Gaussian","username":"Michel_Rouzic","description":"See comment in the code","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["gaussian","fourier","graphingcalculator"],"hasliked":0,"parentid":"","parentname":""}}