{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float pi = 3.141592653589793;\n\nfloat hash(in vec3 p) {\n\treturn fract(sin(dot(p, vec3(15.64, 35.78, 75.42))) * 43758.23);\t\n}\n\nfloat shash(in vec3 p) {\n\treturn hash(p) * 2.0 - 1.0;\t\n}\n\nfloat sdPlane(in vec3 p) {\n\treturn p.y + 0.45;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n\treturn length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa, ba) / dot(ba , ba), 0.0, 1.0 );\n    \treturn length( pa - ba * h ) - r;\n}\n\nfloat motor(float _min, float _max, float time) {\n\tfloat t = 0.5 + 0.5 * sin(time);\n\treturn mix(_min, _max, t);\n}\n\nvec3 rotate_from_origin(vec3 origin, vec3 target, float r, float angle) {\n\treturn vec3(\n\t\torigin.x + r * cos(angle),\n\t\torigin.y + r * sin(angle),\n\t\ttarget.z\n\t);\n}\n\nvec3 preserve(vec3 p0, vec3 p1, float len) {\n\tvec3 v = p1 - p0;\n\tvec3 u = normalize(v);\n\treturn p0 + len * u;\n}\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(in vec3 p) {\n\tvec3 q = p;\n\tvec3 c = vec3(2.5, 0.0, 1.5);\n    p.xz = mod(p.xz, c.xz) - 0.5 * c.xz;\n\t\n\tfloat k = hash(floor( q * vec3(1.0 / 2.5, 1.0, 1.0 / 1.5) - vec3(0.0, 0.5, 0.0) ));\n\tfloat phase = k * pi;\n\tfloat t = iTime * (1.0 + k * 4.0);\n\t\n\tfloat cx = 0.2;\n\tfloat cz = 0.1;\n\tvec3 p0 = vec3(-cx, 0.0, 0.0);\n\tvec3 p1 = vec3(-cx, -0.2, -cz);\n\tvec3 p2 = vec3(-cx, -0.4, -cz);\n\tvec3 p3 = vec3(-cx, 0.2, cz);\n\tvec3 p4 = vec3(-cx, -0.4, cz);\n\t\n\tvec3 p5 = vec3(cx, 0.0, 0.0);\n\tvec3 p6 = vec3(cx, -0.2, -cz);\n\tvec3 p7 = vec3(cx, -0.4, -cz);\n\tvec3 p8 = vec3(cx, 0.2, cz);\n\tvec3 p9 = vec3(cx, -0.4, cz);\n\t\n\tvec3 p10 = vec3(0.0, 0.0, 0.0);\n\tvec3 p11 = vec3(cx, -0.2, 0.0);\n\t\n\tfloat angle0 = 0.0;\n\tfloat angle1 = 0.0;\n\tp0.y = -motor(-0.05, 0.05, t * 4.0 + phase);\n\tangle0 = -motor(pi * 0.35, pi * 0.55, t * 2.0 - pi * 0.5 + phase);\n\tangle1 = -motor(pi * 0.35, pi * 0.55, t * 2.0 + pi * 0.5 + phase);\n\tp1 = rotate_from_origin(p0, p1, 0.2, angle0); \n\tp3 = rotate_from_origin(p0, p3, 0.2, angle1); \n\tangle0 += -motor(0.0, pi * 0.15, t * 2.0 + pi + phase);\n\tangle1 += -motor(0.0, pi * 0.15, t * 2.0 + pi + pi + phase);\n\tp2 = rotate_from_origin(p1, p2, 0.2, angle0);\n\tp4 = rotate_from_origin(p3, p4, 0.2, angle1);\n\t\n\tt += pi * 0.5;\n\t\n\tp5.y = -motor(-0.05, 0.05, t * 4.0 + phase);\n\tangle0 = -motor(pi * 0.35, pi * 0.55, t * 2.0 - pi * 0.5 + phase);\n\tangle1 = -motor(pi * 0.35, pi * 0.55, t * 2.0 + pi * 0.5 + phase);\n\tp6 = rotate_from_origin(p5, p6, 0.2, angle0); \n\tp8 = rotate_from_origin(p5, p8, 0.2, angle1); \n\tangle0 += -motor(0.0, pi * 0.15, t * 2.0 + pi + phase);\n\tangle1 += -motor(0.0, pi * 0.15, t * 2.0 + pi + pi + phase);\n\tp7 = rotate_from_origin(p6, p7, 0.2, angle0);\n\tp9 = rotate_from_origin(p8, p9, 0.2, angle1);\n\t\n\tp10.y = -motor(-0.02, 0.02, t * 4.0 - pi * 0.5 + phase);\n\tp11 = preserve(p5, p11, -0.25);\n\tfloat w = 0.015;\n\t\n\tfloat d = sdPlane(p);\n\t\n\td = min(d, sdCapsule(p, p0, p1, w));\n\td = min(d, sdCapsule(p, p1, p2, w));\n\td = min(d, sdCapsule(p, p0, p3, w));\n\td = min(d, sdCapsule(p, p3, p4, w));\n\t\n\td = min(d, sdCapsule(p, p5, p6, w));\n\td = min(d, sdCapsule(p, p6, p7, w));\n\td = min(d, sdCapsule(p, p5, p8, w));\n\td = min(d, sdCapsule(p, p8, p9, w));\n\t\n\td = min(d, sdCapsule(p, p0, p10, w));\n\td = min(d, sdCapsule(p, p10, p5, w));\n\t\n\td = smin(d, sdCapsule(p, p5, p11, w), 0.1);\n\n    \treturn vec2(d, k);\n}\n\nvec3 calcNormal(in vec3 p) {\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n\t\tmap(p + e.yyx).x - map(p - e.yyx).x\n\t);\n\treturn normalize(nor);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxt) {\n\tfloat precis = 0.001;\n\tfloat h = precis * 2.0;\n\tfloat t = 0.0;\n\tvec2 m = vec2(0.0);\n\tfor(int i = 0; i < 60; i++) {\n\tif(abs(h) < precis || t > maxt) continue;\n\t\tm = map(ro + rd * t);\n\t\th = m.x;\n\t\tt += h;\n\t}\n\treturn vec2(t, m.y);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat sh = 1.0;\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfor(int i = 0; i < 30; i++) {\n\tif(t > maxt) continue;\n\t\th = map(ro + rd * t).x;\n\t\tsh = min(sh, k * h / t);\n\t\tt += h;\n\t}\n\treturn sh;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, out vec3 p) {\n\tvec3 col = vec3(1.0);\n\tvec2 m = castRay(ro, rd, 20.0);\n\tfloat t = m.x;\n\tvec3 pos = ro + rd * t;\n\tp = pos;\n\tvec3 nor = calcNormal(pos);\n\tvec3 lig = normalize(vec3(-0.4, 0.7, 0.5));\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tfloat sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n\tcol = col * (dif * (0.9 + 0.5 * m.y) + spec) * (0.5 + sh * 0.5) * (1.0 - pow(t, 0.8) * 0.1);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 ms = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n\tvec2 p = uv * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(ms.x * 10.0, 1.0 - ms.y, 10.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n\tvec3 q = vec3(0.0);\n\tvec3 col = render(ro, rd, q);\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd2XWh","date":"1411483305","viewed":2017,"name":"Centaurs","username":"erucipe","description":"random phase animation","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","animation","centaur"],"hasliked":0,"parentid":"","parentname":""}}