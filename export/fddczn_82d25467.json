{"ver":"0.1","info":{"id":"fddczn","date":"1652968918","viewed":211,"name":"Over The Moon - variation","username":"QuantumShader","description":"Made by following the tutorial linked at the top of the code. \n\nIf anyone has suggestions as to how I could fix the trees on the layer closest to the camera not blending smoothly with the ground that would be greatly apprectiated.","likes":9,"published":1,"flags":64,"usePreview":0,"tags":["scrolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlBXRh","filepath":"https://soundcloud.com/shyprince/a-miserable-heart-piano","previewfilepath":"https://soundcloud.com/shyprince/a-miserable-heart-piano","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// slight variation on this tutorial https://www.youtube.com/watch?v=LLZPnh_LK8c\n\n#define S(a, b, t) smoothstep(a,b,t)\n#define LAYER_COUNT 20.\n\n#define MOON_COLOR vec3(.99, .95, .95)\n#define MOON_RAD .15\n\n//#define STATIC_MOON\n\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur)\n{\n    float \n    m  = S(-blur, blur, p.y - yb);\n    m *=  S(blur, -blur, p.y - yt); \n    \n    p.x = abs(p.x);\n    \n    // 0 when p.y = yb, and 1 when p.y = yt\n    float w = mix(wb, wt, (p.y-yb) / (yt-yb));\n    \n    m *=  S(blur, -blur, p.x - w); \n\n    return m;\n}\n\n// hash returns value between 0 & 1 (input: vec2, output: float, hence 21)\nfloat Hash21(vec2 p)\n{\n    p = fract(p*vec2(234.45, 765.34));\n    p += dot(p, p+547.123);\n    return fract(p.x * p.y);\n}\n\n// returns a rgba vector\nvec4 Tree(vec2 uv, vec3 col, float blur)\n{    \n    // build tree from taper boxes\n    float m = TaperBox(uv, .03, .03, -0.2, .25, blur); // tree trunk\n    m += TaperBox(uv, .2, .1, .25, .50, blur); // canopy 1\n    m += TaperBox(uv, .15, .05, .50, .75, blur); // canopy 2\n    m += TaperBox(uv, .1, .0, .75, 1., blur); // canopy 3\n       \n    // add shadows to tree\n    float \n    shadow = TaperBox(uv - vec2(.2,0), .1, .5, .15, .25, blur);\n    shadow += TaperBox(uv + vec2(.25,0), .1, .5, .45, .50, blur);\n    shadow += TaperBox(uv - vec2(.25,0), .1, .5, .71, .75, blur);\n    \n    col -= shadow * .8;\n    return vec4(col, m);\n}\n\nfloat GetGroundHeight(float x)\n{\n    return sin(x*.432)*0.8 + sin(x)*0.3;\n}\n\nvec4 Layer(vec2 uv, float blur)\n{\n    vec4 col = vec4(0);\n    \n    // Add a ground\n    float ground = S(blur, -blur, uv.y + GetGroundHeight(uv.x));\n    \n    // create row of boxes with ids (dont mess with UV yet)\n    float id = floor(uv.x);\n    \n    // generate random number (0, 1) from id\n    float n = fract(sin(id*234.12) * 5463.3) * 2. - 1.;\n    float x = n*.3;\n    float y = GetGroundHeight(id + 0.5 + x);\n    \n    // now change the uv to be repeating\n    uv.x = fract(uv.x) - 0.5;\n    \n    vec2 treeScale = vec2(1., 1. + n*.2);\n    vec2 treeUV = (uv - vec2(x, -y)) * treeScale;\n    vec4 tree = Tree(treeUV, vec3(1.), blur);\n    \n    // ----- ISSUE -------\n    // the problem is most evident with large blurs. \n    // trees do not blend perfectly with the ground plane\n    col += ground;\n\n    // blend tree into image based on alpha\n    col = mix(col, tree, tree.a);\n\n    // fixes overlapp in blur region (not completely)\n    col.a = max(ground, tree.a);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\n    vec2 M = (iMouse.xy / iResolution.xy)*2. - 1.;\n    float t = iTime *.5;\n\n    float blur = 0.003;\n    \n\n    \n    // Make stars\n \n    float twinkle = dot(length(sin(uv*1.1+t*0.5)), length(cos(uv*vec2(210.21, 63.17)-t*1.)));\n    twinkle = sin(twinkle*10.12)*.5 + .5;\n    float stars = pow(Hash21(uv), 100.) * twinkle * 0.7;\n    vec4 col = vec4(stars);\n    \n    // Make moon\n    \n    #ifdef STATIC_MOON\n    vec2 moonPos = vec2(.4, .25);\n    float moonFade = 1.;\n    #else\n    float tOffset = 50.;\n    float wMoon = 2.;\n    float moonPeriod = 90.;\n    float tMoon = iTime + tOffset;\n    vec2 moonPos;\n    moonPos.x = (fract(tMoon / moonPeriod)*2. - 1.)*wMoon;\n    moonPos.y = 0.3*abs(cos((tMoon - moonPeriod/2.) * 3.14159 / moonPeriod));\n    \n    // fade moonlight in and out when it goes off screen\n    float moonFade = abs(fract(tMoon / moonPeriod + 0.5)*2. - 1.) * 0.70 + 0.3;\n    #endif\n    \n    float moon = S(.01, -.01, length(uv - moonPos) - MOON_RAD);\n    \n    // make sure no stars are drawn inside moon\n    col *= 1.- moon;\n    \n    // subtract another circle to make crescent\n    moon *= S(-.01, .1, length(uv - (moonPos + vec2(.1, .05))) - MOON_RAD*1.01);\n    col += moon;\n   \n    // loop over layers (special way so i goes from 0 to 1)\n    vec4 layer;\n    for(float i=0.; i<1.; i+=1./LAYER_COUNT)\n    {\n        \n        float scale = mix(30., 1., i);\n        \n        // blur back trees more (aliasing fix)\n        blur = mix(.03, .0005, i);\n        \n        // make new layer\n        layer = Layer(uv * scale + vec2(t+i*100., 2.*i- 1.5) - M, blur);\n        \n        // fade & color layers\n        layer.rgb *= (1.-i) * vec3(.7, .75, 1.);\n        \n        // blend layer into final image\n        col = mix(col, layer, layer.a);\n    }\n    \n\n    \n\n    \n    // make moon glow\n    float moonLight = 1. - length(uv - moonPos) / (1.4 * moonFade);\n    float moonGlow = S(MOON_RAD + 0.3, MOON_RAD ,length(uv-moonPos));\n    \n\n    \n    col.rgb += moonLight * MOON_COLOR * 0.4;\n    col.rgb += vec3(moonGlow) * MOON_COLOR * 0.1;\n\n    \n    // add 1 extra foreground tree layer\n    layer = Layer(uv*vec2(1. , 0.8) + vec2(t + 90., 0.5) - M, .07);\n    col = mix(col, layer*0.008, layer.a);\n    \n    float thickness = 1./iResolution.y;\n    //if(abs(uv.x)<thickness) col.g = 1.;\n    //if(abs(uv.y)<thickness) col.r = 1.;\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}