{"ver":"0.1","info":{"id":"4fK3WK","date":"1713286700","viewed":58,"name":"kaleidoscope Bao","username":"SamOrantin","description":"kaleidoscope","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n){return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat noise(float p){\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nfloat manh_distance(vec2 a, vec2 b) {\n    vec2 c = abs(a - b);\n    return c.x + c.y;\n}\n\nfloat pyramids(vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float mind = 2.0;\n    for (int i=-1;i<2;i++)\n    for (int j=-1;j<2;j++)\n    {\n        vec2 off = vec2(i,j);\n        vec2 top = vec2( rand(n+off), rand(n+off+234.1) );\n        float dist = manh_distance(f,top+off);\n        if (dist < mind) {\n            mind = dist;\n        }\n    }\n    return (2.0 - mind) / 2.0;\n}\n\n#define SQ3 1.7320508076\n\nmat2 rot2d(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nvec2 p6mmmap(vec2 uv, float repeats) {\n    // clamp to a repeating box width 6x height 2x*sqrt(3)\n    uv.x /= SQ3;\n    uv = fract(uv * repeats-0.5)-0.5;\n    uv.x *= SQ3;\n\n    uv = abs(uv);\n    \n    vec2 st = uv;\n    \n    vec2 uv330 = rot2d(radians(330.)) * uv;\n    if (uv330.x < 0.0){\n        st.y = (st.y - 0.5) * -1.0;\n        st.x *= SQ3;\n        return st * 2.0;\n    }\n    else if (uv330.x > 0.5){\n        st.x = (st.x - 0.5 * SQ3) * -1.0 * SQ3;\n        return st * 2.0;\n    }\n    \n    vec2 uv30 = rot2d(radians(30.)) * uv;\n    if (uv30.y < 0.0 && uv30.x >= 0.5) st = vec2(1.0,1.0);\n    else if (uv30.y >= 0.0 && uv30.x >= 0.5) st = vec2(-1.0,1.0);\n    else if (uv30.y < 0.0 && uv30.x < 0.5) st = vec2(1.0,-1.0);\n    else st = vec2(-1.0,-1.0);\n    \n    uv30.x = uv30.x - 0.5;\n    uv = rot2d(radians(270.))* uv30;\n    st = uv * st;\n    st.x *= SQ3;\n    return st * 2.0;\n}\n\nfloat uc(float a) { return clamp(a,0.,1.); }\nfloat ns(float a, float t) { return noise(a+t); }\n\nvec3 square_noise(vec2 uv, float t) {\n\n    float p1 = ns(pyramids(uv)*6.,t);\n    float p2 = ns(pyramids(uv+11.)*14.,t);\n    float p3 = ns(pyramids(uv+25.)*35.,t);\n    float p4 = ns(pyramids(uv+225.)*65.,t);\n    \n    float v = p1*0.55 + pow((pow(p3,2.0)*0.55 - pow(p4,3.0)*0.45 + 1.1*p2),3.0);//uc((p1*p2*p3-0.09)*41.);\n\n\treturn vec3(v,v,v);\n}\n\nvec4 animate_noise(vec2 uv, float t) {\n\treturn vec4(square_noise((rot2d(radians(t*12.7))*(uv-0.25)+0.25)+t*0.06,t*0.2),1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= iResolution.x / 2000.0;\n    \n    float mask = smoothstep(0.15,0.0,dot(uv,uv));\n\n    uv = p6mmmap(uv,3.) * 0.65;\n    fragColor = vec4(0.0,0.7,1.2,1.0) * animate_noise(uv, iTime)*vec4(mask,mask,mask,mask);\n}","name":"Image","description":"","type":"image"}]}