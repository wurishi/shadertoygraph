{"ver":"0.1","info":{"id":"7tVXzG","date":"1640957233","viewed":81,"name":"Black Hole between two plains","username":"Tameno","description":"A black hole that isn't very well made nor really scientifically accurate (probably)\nI made this just for fun and to pass the time","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float stepDistance = 0.1;\nfloat G = 0.1;\n\nfloat PI = 3.1415926;\nvec2 deformPath(vec2 ogPath) {\n    float camAngle = iTime/2.0;\n    \n    vec3 path = vec3(ogPath, 1.0).xyz;\n    vec2 flatPath = vec2(path.x, path.z).xy;\n    float flatLen = length(flatPath);\n    flatPath = normalize(flatPath);\n    float angle = atan(flatPath.y/flatPath.x);\n    angle += camAngle;\n    if (ogPath.x < 0.0) angle += PI;\n    flatPath = vec2(cos(angle), sin(angle));\n    flatPath *= flatLen;\n    path = vec3(flatPath.x, path.y, flatPath.y);\n    \n    \n    vec3 pos = vec3(cos(camAngle-PI/2.0), 0.0, sin(camAngle-PI/2.0))*2.0;\n    \n    float prevD = length(pos);\n    bool canEnd = false;\n    bool absorbed = true;\n    for (int i = 0; i < 100; i++) {\n        path = normalize(path);\n        pos += path*stepDistance;\n        float d = length(pos);\n        float f = G/(d*d);\n        vec3 fVect = normalize(pos*-1.0)*f;\n        path += fVect*stepDistance;\n        \n        if (d > prevD) canEnd = true;\n        \n        if (d < prevD && canEnd) {\n            break;\n        }\n        \n        prevD = d;\n        \n        if (length(pos) > 3.0) {\n            absorbed = false;\n            break;\n        }\n    }\n    \n    if (absorbed) return vec2(0.0, 0.0);\n    \n    return path.xy / path.z;\n}\n\nvec3 pattern(vec2 uv) {\n    float val;\n    \n    val =  sin(uv.x*10.0);\n    val += sin(uv.y*10.0);\n    val = round(val+0.5);\n\n    return vec3(uv.x+0.5, 1.0-val/2.0, 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y*2.0\n        -vec2(iResolution.x/iResolution.y, 1.0);\n    \n    uv = deformPath(uv);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    if (uv != vec2(0.0, 0.0)) {\n        col = pattern(uv);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}