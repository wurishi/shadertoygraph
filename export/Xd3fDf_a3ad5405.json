{"ver":"0.1","info":{"id":"Xd3fDf","date":"1526955483","viewed":259,"name":"sdf volume rendering","username":"hellochar","description":"experimenting with volume rendering sdfs","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["volume","sdf","experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 warp(vec3 v) {\n    v += sin(v.yzx * 2. / length(v) + vec3(0.5));\n    v += 0.5 * sin(v.zzx * 4.);\n    v += 0.25 * cos(v.yxy * 8.);\n    return v;\n}\n\nfloat map(vec3 q) {\n    vec3 p = warp(q);\n    return length(p) - (3.0 + sin(iTime / 4.) * sin(iTime / 4.) * 3.);\n    // return length( p ) - 1.0;\n}\n\nvec3 mapNormal(vec3 p) {\n    vec3 o = vec3(0.0001, 0., 0.);\n    return vec3(\n        (map(p + o.xyy) - map(p - o.xyy)) / (o.x * 2.),\n        (map(p + o.yxy) - map(p - o.yxy)) / (o.x * 2.),\n        (map(p + o.yyx) - map(p - o.yyx)) / (o.x * 2.)\n    );\n}\n    \nfloat intersect(vec3 rayPosition, vec3 rayDirection) {\n    float epsilon = 0.0001;\n    float t = 0.0;\n    for(int i = 0; i < 1000; i++) {\n        vec3 position = rayPosition + rayDirection * t;\n        float dist = map(position);\n        if (dist <= epsilon) {\n            return t;\n        }\n        if (dist > 50.) {\n            break;\n        }\n        t += dist / 20.0 + 0.001;\n    }\n    return -1.0;\n}\n\n#define NUM_ITERATIONS 300.\n\nfloat volume(vec3 rayPosition, vec3 rayDirection, float totalDist, out vec3 norm) {\n    float segmentLength = totalDist / NUM_ITERATIONS;\n    float sum = 0.0;\n    for (float i = 0.; i < NUM_ITERATIONS; i++) {\n        float t = totalDist * i / NUM_ITERATIONS;\n        vec3 position = rayPosition + rayDirection * t;\n        float value = -map(position);\n        // value = max(0., value);\n        sum += value * segmentLength;\n        norm += mapNormal(position) * segmentLength;\n    }\n    norm /= totalDist;\n    return sum / totalDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    float cameraXZAngle = iTime * 0.1;\n    float rad = mix(0.05, 0.2, sin(iTime / 20.) / 2. + 0.5);\n    vec3 cameraPosition = vec3(cos(cameraXZAngle) * rad, rad * 0.6, sin(cameraXZAngle) * rad);\n    vec3 cameraLookAt = vec3(0., sin(iTime / 12.) * 0.01, 0.);\n    \n    vec3 cameraZ = normalize( cameraLookAt - cameraPosition );\n    vec3 cameraX = normalize( cross(vec3(0., 1., 0.), cameraZ) );\n    vec3 cameraY = normalize( cross(cameraZ, cameraX) );\n    \n    vec3 rayPosition = cameraPosition;\n    float aspectRatio = iResolution.x / iResolution.y;\n    float rayX = (2. * fragCoord.x / iResolution.x - 1.) * aspectRatio;\n    float rayY = 2. * fragCoord.y / iResolution.y - 1.;\n//    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n//    float rayX = p.x;\n//    float rayY = p.y;\n\n    vec3 rayDirection = normalize(cameraX * rayX + cameraY * rayY + cameraZ);\n    \n    \n    vec3 bg = mix(vec3(0.04, 0.06, 0.08), vec3(0.12), (rayDirection.y + 1.) / 2.);\n    col += bg;\n    \n    /*\n    float t = intersect(rayPosition, rayDirection);\n    if (t > 0.0) {\n        vec3 pos = rayPosition + t * rayDirection;\n        vec3 normal = mapNormal(pos);\n        col = vec3(normalize(normal + pos));\n    } else {\n        \n    }\n\t*/\n    \n    vec3 norm;\n    float v = volume(rayPosition, rayDirection, 10., norm);\n    \n    vec3 lights =\n        vec3(0.9, 0.3, 0.2) * max(0., dot(norm, normalize(vec3(1., -1., 1.)))) +\n        vec3(0.2, 0.3, 1.5) * max(0., dot(norm, normalize(vec3(1.1, -1.2, 0.1)))) +\n        vec3(0.2, 0.6, 0.1) * max(0., dot(norm, normalize(vec3(1.1, -1.4, 0.2))));\n    \n    float alpha = 1. / (1. + exp(-v));\n    // col += lights;\n    col = mix(col, lights, alpha);\n    \n    float vFactor = exp(v) / 10.;\n    col += vFactor * vec3(0.1, 0.9, 0.7);\n    \n    col *= 0.86;\n    col += vec3(0.01, 0.03, 0.03);\n    \n    col = clamp(col, 0., 1.);\n\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}