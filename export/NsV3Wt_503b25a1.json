{"ver":"0.1","info":{"id":"NsV3Wt","date":"1632468779","viewed":161,"name":"Perlin Noise Functions","username":"VitaleMarco","description":"My approach of a 2D and 3D Perlin Noise\nFeedback is very welcome","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//2D AND 3D PERLIN NOISES\n//PERLIN NOISE\nfloat perlinNoise2D(vec2 uv, vec2 scale, vec2 offset){\n    //APPLY SCALE\n    uv.y = 1.0 - uv.y;\n    uv *= scale;\n\n    //APPLY OFFSET\n    uv += offset;\n\n    //CREATE A GRID OF CELLS\n    vec2 fraction = fract(uv);\n    \n    //RANDOM DIRECTIONS\n\tvec2 lowerLeftDirection = rand2dTo2d(vec2(floor(uv.x), floor(uv.y))) * 2.0 - 1.0;\n\tvec2 lowerRightDirection = rand2dTo2d(vec2(ceil(uv.x), floor(uv.y))) * 2.0 - 1.0;\n\tvec2 upperLeftDirection = rand2dTo2d(vec2(floor(uv.x), ceil(uv.y))) * 2.0 - 1.0;\n\tvec2 upperRightDirection = rand2dTo2d(vec2(ceil(uv.x), ceil(uv.y))) * 2.0 - 1.0;\n\n\t//GET CELL VALUES\n\tfloat lowerLeftFunctionValue = dot(lowerLeftDirection, fraction - vec2(0, 0));\n\tfloat lowerRightFunctionValue = dot(lowerRightDirection, fraction - vec2(1, 0));\n\tfloat upperLeftFunctionValue = dot(upperLeftDirection, fraction - vec2(0, 1));\n\tfloat upperRightFunctionValue = dot(upperRightDirection, fraction - vec2(1, 1));\n\n    //GET INTERPOLATION VALUES \n\tfloat interpolatorX = easeInOut(fraction.x);\n\tfloat interpolatorY = easeInOut(fraction.y);\n\n\t//INTERPOLATION BETWEEN CELLS\n\tfloat lowerCells = mix(lowerLeftFunctionValue, lowerRightFunctionValue, interpolatorX);\n\tfloat upperCells = mix(upperLeftFunctionValue, upperRightFunctionValue, interpolatorX);\n\n    //FINAL NOISE\n\tfloat noise = mix(lowerCells, upperCells, interpolatorY);\n    \n    //BECAUSE THE VALUES ARE IN A RANGE BETWEEN -0.5 AND 0.5\n    //ADDING 0.5 GETS THE OUTPUT INTO A RANGE OF 0.0 AND 1.0\n\treturn noise + 0.5;\n}\n\nfloat perlinNoise3D(vec3 pos, vec3 scale, vec3 offset){\n    //APPLY SCALE\n    pos *= scale;\n    \n    //APPLY OFFSET\n    pos += offset;\n    \n    //CREATE A GRID OF CELLS\n    vec3 fraction = fract(pos);\n\n    float interpolatorX = easeInOut(fraction.x);\n    float interpolatorY = easeInOut(fraction.y);\n    float interpolatorZ = easeInOut(fraction.z);\n\n    //LOOP THROUGH NEIGHBOUR CELLS\n    vec2 cellNoiseZ;\n    for(int z = 0; z <= 1; z++){\n        vec2 cellNoiseY;\n        for(int y = 0; y <= 1; y++){\n            vec2 cellNoiseX;\n            for(int x = 0; x <= 1; x++){\n                //CREATE RANDOM DIRECTIONS FOR THE CELLS\n                vec3 cell = floor(pos) + vec3(x, y, z);\n                vec3 cellDirection = rand3dTo3d(cell) * 2.0 - 1.0;\n                vec3 compareVector = fraction - vec3(x, y, z);\n                \n                //STORE THE VALUES\n                if (x == 0) {\n                    cellNoiseX.x = dot(cellDirection, compareVector);\n                } else {\n                    cellNoiseX.y = dot(cellDirection, compareVector);                \n                }\n            }\n            \n            //STORE THE VALUES\n            if (y == 0) {\n                cellNoiseY.x = mix(cellNoiseX.x, cellNoiseX.y, interpolatorX);\n            } else {\n                cellNoiseY.y = mix(cellNoiseX.x, cellNoiseX.y, interpolatorX);\n            }\n        }\n        \n        //STORE THE VALUES\n        if (z == 0) {\n            cellNoiseZ.x = mix(cellNoiseY.x, cellNoiseY.y, interpolatorY);\n        } else {\n            cellNoiseZ.y = mix(cellNoiseY.x, cellNoiseY.y, interpolatorY);\n        }\n    }\n    \n    //FINAL NOISE\n    float noise = mix(cellNoiseZ.x, cellNoiseZ.y, interpolatorZ);\n    \n    //BECAUSE THE VALUES ARE IN A RANGE BETWEEN -0.5 AND 0.5\n    //ADDING 0.5 GETS THE OUTPUT INTO A RANGE OF 0.0 AND 1.0\n    return noise + 0.5;\n}\n\n//FBM FUNCTIONS\nfloat fBmPerlinNoise2D(vec2 uv, vec2 scale, vec2 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n    \n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * perlinNoise2D(uv, scale, offset);\n        uv*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nfloat fBmPerlinNoise3D(vec3 pos, vec3 scale, vec3 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n\n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * perlinNoise3D(pos, scale, offset);\n        pos*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NORMALIZE COORDINATES TO UV\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //GET SCREEN RATIO\n    float ratio = iResolution.y / iResolution.x;\n        \n    //MOVEMENT\n    float offset = iTime * 0.2;\n\n    //SCALE\n    vec3 scale = vec3(4.0);\n    scale.y = scale.x * ratio;\n    \n    //INITIAL NOISE VALUE\n    float noise = 0.0;\n    \n    //SPLIT THE SCREEN INTO 4 COLUMNS\n    if (uv.x <= 0.25) {\n        //FIRST COLUMN 2D PERLIN NOISE\n        noise = perlinNoise2D(uv, scale.xy, vec2(offset));\n    } else if (uv.x <= 0.5) {\n        //SECOND COLUMN 3D PERLIN NOISE\n        noise = perlinNoise3D(vec3(uv, 0.0), scale, vec3(offset));\n    } else if (uv.x <= 0.75) {\n        //THIRD COLUMN 2D PERLIN NOISE FBM\n        //SHOWING MULTIPLE OCTAVES\n        if (uv.y >= 2.0/3.0){\n            noise = fBmPerlinNoise2D(uv, scale.xy, vec2(offset), 2, 2.0, 0.5);\n        } else if (uv.y >= 1.0/3.0){\n            noise = fBmPerlinNoise2D(uv, scale.xy, vec2(offset), 3, 2.0, 0.5);\n        } else {\n            noise = fBmPerlinNoise2D(uv, scale.xy, vec2(offset), 4, 2.0, 0.5);\n        }\n    } else {\n        //FOURTH COLUMN 3D PERLIN NOISE FBM\n        //SHOWING MULTIPLE OCTAVES\n        if (uv.y >= 2.0/3.0){\n            noise = fBmPerlinNoise3D(vec3(uv, 0.0), scale, vec3(offset), 2, 2.0, 0.5);\n        } else if (uv.y >= 1.0/3.0){\n            noise = fBmPerlinNoise3D(vec3(uv, 0.0), scale, vec3(offset), 3, 2.0, 0.5);\n        } else {\n            noise = fBmPerlinNoise3D(vec3(uv, 0.0), scale, vec3(offset), 4, 2.0, 0.5);\n        }\n    }\n    //OUTPUT\n    fragColor = vec4(vec3(noise), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//PSEUDO - RANDOM FUNCTIONS\n//TO 1D FUNCTIONS\nfloat rand3dTo1d(vec3 value, vec3 dotDir){\n    vec3 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nfloat rand2dTo1d(vec2 value, vec2 dotDir){\n    vec2 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);   \n    return random;\n}\n\nfloat rand1dTo1d(float value, float mutator){\n\tfloat random = fract(sin(value + mutator) * 143758.5453);\n\treturn random;\n}\n\n//TO 2D FUNCTIONS\nvec2 rand3dTo2d(vec3 value){\n    return vec2(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155))\n    );\n}\n\nvec2 rand2dTo2d(vec2 value){\n    return vec2(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135))\n    );\n}\n\nvec2 rand1dTo2d(float value){\n    return vec2(\n        rand1dTo1d(value, 3.9812),\n        rand1dTo1d(value, 7.1536)\n    );\n}\n\n//TO 3D FUNCTIONS\nvec3 rand3dTo3d(vec3 value){\n    return vec3(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155)),\n        rand3dTo1d(value, vec3(73.156, 52.235, 09.151))\n    );\n}\n\nvec3 rand2dTo3d(vec2 value){\n    return vec3(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135)),\n        rand2dTo1d(value, vec2(73.156, 52.235))\n    );\n}\n\nvec3 rand1dTo3d(float value){\n    return vec3(\n        rand1dTo1d(value, 3.9812),\n        rand1dTo1d(value, 7.1536),\n        rand1dTo1d(value, 5.7241)\n    );\n}\n\n//INTERPOLATION FUNCTIONS\n//USEFUL INTERPOLATION FUNCTIONS TO CREATE SMOOTH TRANSITIONS BETWEEN VALUES\nfloat easeIn(float interpolator){\n    return interpolator * interpolator;\n}\n\nfloat easeOut(float interpolator){\n\treturn 1.0 - easeIn(1.0 - interpolator);\n}\n\nfloat easeInOut(float interpolator){\n\tfloat easeInValue = easeIn(interpolator);\n\tfloat easeOutValue = easeOut(interpolator);\n\treturn mix(easeInValue, easeOutValue, interpolator);\n}\n","name":"Common","description":"","type":"common"}]}