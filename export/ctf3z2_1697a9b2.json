{"ver":"0.1","info":{"id":"ctf3z2","date":"1672021265","viewed":98,"name":"Daniel Levacov - Ray Marching","username":"danilevacov","description":"Trabalho Final de Computação Gráfica UFRJ 2022.2 - Daniel Levacov, DRE 118028241\nBola de boliche, basquete e ping-pong","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pingpong","boliche","basquete"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.0125\n#define PI 3.1415925359\n\n#define S smoothstep\n#define T iTime\n\n// Rotation matrix.\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// SDF of a sphere, given its center and radius.\nfloat dSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\n// Scene SDF: signed distance function.\nfloat getDist(vec3 p) {\n    float planeDist = p.y;\n    \n    float s = cos(iTime);\n    float s2 = cos(iTime*2.);\n    float s3 = cos(iTime*8.);\n    float s4 = cos(iTime);\n    float s5 = cos(iTime*12.);\n    \n    float cx = -3.0;\n    cx -= s;\n\n    float cx2 = 1.0;\n    cx2 -= s2;\n\n    float cx3 = 1.0;\n    cx3 -= s3/1.4; // pos inicial mais tamanho da bola\n\n    float cx4 = 0.0;\n    cx4 -= s4*5.;\n    \n    float cx5 = 1.0;\n    cx5 -= s5/1.2;\n    \n    float sd  = dSphere(p, vec4(0, 0.7, cx2 + 6. , 0.7));\n    float sd1  = dSphere(p, vec4(cx4, cx5 * 1.92, cx2*2. + 6. , 0.2));\n    float sd2  = dSphere(p, vec4(2, cx3 * 1.8, 6 , 0.4));\n    \n    float d = min(sd, planeDist);\n    d = min(sd1, d);\n    d = min(sd2, d);\n    \n    return d;\n}\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 bumpMappedTexture(sampler2D bumpMap, vec3 tex, vec2 texCoord, float bumpDepth) {\n  // Sample the bump map at the texture coordinate\n  vec3 bump = texture(bumpMap, texCoord).rgb;\n\n  // Calculate the perturbation vector by scaling the bump value and rotating it by 90 degrees\n  vec2 perturb = bumpDepth * bump.rg;\n  perturb = vec2(-perturb.y, perturb.x);\n\n  // Perturb the texture coordinate and sample the texture\n  vec3 texel = tex + vec3(perturb,0);\n\n  return texel;\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary — should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = \n        vec3(\n        getDist(p + e.xyy),\n        getDist(p + e.yxy),\n        getDist(p + e.yyx)) - \n        vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\n// Phong illumination model, given a point and camera position.\nfloat getLight(vec3 p, vec3 ro) {\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l,n);\n    \n    // ambient component\n    float amb = 0.1;\n    \n    // ambient reflection coefficient\n    float ka = 1.0;\n    \n    // diffuse component - apply Lambert's cosine law\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    // diffuse reflection coefficient\n    float kd = 0.8;\n    \n    // specular component\n    float shininess = 100.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    // specular reflection coefficient\n    float ks = 1.0;\n    \n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    float d = rayMarch(p + 2. * n * SURF_DIST , l);\n    \n    // cast a ray to the light\n    if (d < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n    \n    n = normalize(bumpMappedTexture(iChannel3,n,p.xy,texture(iChannel3,p.xy).r));\n    \n    // ambient + diffuse + specular components\n    return ka * amb + kd * dif + ks * spec;\n}\n\nvec3 Transform(vec3 p) {\n     p.xy *= Rot(iTime*.4);\n     p.xz *= Rot(iTime*.2);\n     \n     return p;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u,\n        d = normalize(i);\n    return d;\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // camera position\n    vec3 ro = vec3(0, 2, 0);\n    \n    // projection plane z = 1\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Rotate camera down about the x-axis\n    rd.yz *= Rot(PI * 10. / 180.); \n    \n    float d = rayMarch(ro, rd);\n    \n    // point hit by the ray\n    vec3 p = ro + rd * d;\n    vec3 p1 = vec3((1.,1.,1.));\n    \n    // illumination at point p\n    float light_intensity = getLight(p, ro);\n    \n    // LONDRES\n    vec3 background_color = texture(iChannel0, uv*vec2(1.,2.)).rgb;\n    \n    // pixel color\n    vec3 color;\n    \n    if (d < MAX_DIST) {\n        color = texture(iChannel1, p.yz).rgb;\n        \n    \tvec3 n = getNormal(p);\n        \n        vec3 colorXZ = texture(iChannel1, p.xz*.5+.5).rgb;\n        vec3 colorYZ = texture(iChannel2, p.yz*2.+.5).rgb;\n        vec3 colorXY = texture(iChannel2, p.xy*.5+.5).rgb;\n        \n        n = abs(n);\n        n *= pow(n, vec3(2));\n        n /= n.x + n.y + n.z;\n        \n        color = colorYZ*n.x + colorXZ*n.y + colorXY*n.z;\n        color *= vec3(light_intensity) + 0.05;\n    }\n    else \n        color = background_color;\n\n    // output to screen\n    fragColor = vec4(color,0.12);\n}","name":"Image","description":"","type":"image"}]}