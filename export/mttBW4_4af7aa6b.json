{"ver":"0.1","info":{"id":"mttBW4","date":"1701260719","viewed":30,"name":"basic raymarch stuff","username":"rawburt","description":"playarround","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["play"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3  campos        = vec3( 0. , .0 , -10.5 );\nfloat max_distance  = 50.;\nint   max_steps     = 150; \nfloat hit_distance  = 0.001;\nvec3  light_pos     = vec3( -10., 6., -10. );\n\n\nfloat \ndistance_sphere( in vec3 position, in vec3 sphere_position, float sphere_rad) {\n\n    float onion_out = length( ( position ) - sphere_position ) - sphere_rad;\n    \n    return onion_out;\n}\n\nfloat \ndistance_box( in vec3 position, in vec3 box_dims ) {\n\n    vec3 q =  abs( position ) - box_dims;\n    float onion_out = length( max( q, 0.0 ) );\n\n    return onion_out;\n}\n\nfloat \nsmax(float a, float b, float k ) {\n    float h = max( k - abs( a - b ), 0.0 );\n    return max( a, b ) + ( .25 / k )*h*h;\n}\n\nfloat \nsmin(float a, float b, float k ) {\n    float h = max( k - abs( a - b ), 0.0 );\n    return min( a, b ) - ( .25 / k )*h*h;\n}\n\n\nfloat\nmap_world(in vec3 p ) {\n   vec3 q = p;\n   q.x = mod(q.x, 7.);\n   q.z = abs(q.z);\n   float time = mod(iTime, 5.); \n   float y_pos = time * 3.;\n   \n   //q.xz = mat2(sin(iTime), -cos(iTime), cos(iTime), sin(iTime) ) * q.xz;\n   float da = distance_sphere(q, vec3(3.5, -4. + y_pos, 3.5), 1. );\n\n   float dg = q.y + 2.175;\n   da *= .5;\n   dg *= .5;\n   return smin(da, dg, min( max(.5 *  y_pos, 0.), 4.5 ) );\n\n}\n\nvec3\ncalc_normals( vec3 position ) {\n    vec3 small_step = vec3( 0.0001, 0., 0. );\n\n    float grad_x    = map_world( position + small_step.xyy ) - map_world( position - small_step.xyy );\n    float grad_y    = map_world( position + small_step.yxy ) - map_world( position - small_step.yxy );\n    float grad_z    = map_world( position + small_step.yyx ) - map_world( position - small_step.yyx ); \n\n    return normalize( vec3( grad_x, grad_y, grad_z ) );\n}\n\nfloat cast_ray(vec3 start, vec3 direct) {\n    float total_distance = 0.;\n\n    vec3  new_pos        = vec3(0., 0., 0.);\n\n    for(int i = 0; i < max_steps; i++) {\n\n        vec3  new_pos     = start + total_distance * direct;\n        float distance    = map_world( new_pos );\n\n        if( distance < hit_distance ) {\n            return total_distance;\n        }\n        if( total_distance > max_distance ) {\n            return -1.;\n        }\n        total_distance += distance;\n    }\n    return total_distance;\n}\n\nvec3 ray_march(vec3 dir) {\n\n    float  t = cast_ray(campos, dir);\n\n    if( t > 0. ) {\n        vec3  new_pos    = campos +  t * dir;\n\n        vec3  normal     =  calc_normals( new_pos );\n\n        vec3 light_dir  = normalize( light_pos - new_pos );\n\n        float intensity = clamp( dot( light_dir, normal ), .0, 1.);\n\n        vec3 refl       = reflect( -normalize(( campos - new_pos )), normal );\n        \n        float spec      = pow(max(dot(light_dir, refl ), 0. ), 16. );\n        \n        float sky       = clamp( .5 + .5 * dot(normal, vec3(0., 1., 0.) ), 0., 1.);\n\n        float shad      = step( cast_ray( new_pos + .01 * normal, light_dir ), 0.0 );\n\n        vec3 start = vec3( .1, .2, .8);\n        vec3 end   = vec3( .1, .3, .7);\n\n        vec3 col = vec3(.1, .4,  .7); \n\n        return col * shad * ( intensity + spec ) + vec3(.0, .1, .3 ) * sky;\n    }\n\n    return vec3( 0., 0., 0. );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n   \n    vec3  dir           = normalize( vec3( p, 1.5 ) );\n    // Output to screen\n    fragColor = vec4(ray_march(dir) ,1.0);\n}","name":"Image","description":"","type":"image"}]}