{"ver":"0.1","info":{"id":"l32XW3","date":"1714352890","viewed":117,"name":"chair_image","username":"soncho_E","description":"raymarching chair ","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture(tex, v_rgbSE).xyz;\n    vec4 texColor = texture(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n#pragma glslify: export(fxaa)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec4 bufferAColor = texture(iChannel0, uv);\n\n    vec2 v_rgbNW = uv + (vec2(-1.0, -1.0) / iResolution.xy);\n    vec2 v_rgbNE = uv + (vec2(1.0, -1.0) / iResolution.xy);\n    vec2 v_rgbSW = uv + (vec2(-1.0, 1.0) / iResolution.xy);\n    vec2 v_rgbSE = uv + (vec2(1.0, 1.0) / iResolution.zy);\n    vec2 v_rgbM = uv;\n\n    fragColor = fxaa(iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n    //fragColor =texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265\n\n// The Book of Shaders by Patricio Gonzalez Vivo&Jen Lowe\n// https://thebookofshaders.com/10/\nfloat ramdom1d(float x)\n{\n    return sin(2.*x)+sin(PI*x);\n}\nfloat random2d(vec2 st){\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453)*.5-.25;\n}\n\nvec3 noise(vec2 uv,float level){\n    return vec3(random2d(uv+1.)*level,random2d(uv+2.)*level,random2d(uv+3.)*level);\n}\n\n// Fractal Brownian Motion(fbb)\n// noiseをoctaveを変えて重ねる\n//\n// The Book of Shaders by Patricio Gonzalez Vivo&Jen Lowe\n// https://thebookofshaders.com/13\n// さつき先生  UHTK 03-ノイズ関数を利用する【理論的な知識をもってHoudiniを使う】\n// https://www.youtube.com/watch?list=PLAsWwUHApt3MVF8ByjGNFTwZ2DYUG8NGG&time_continue=1289&v=tEevAPnxbI8&source_ve_path=MzY4NDIsMjg2NjY&feature=emb_logo\n// Perlin Noise(fBm)を使ったカメラ揺れエフェクト\n// https://gist.github.com/keijiro/3731297\nfloat fbm(float x)\n{\n    float result=0.;\n    \n    // TODO: 手振れっぽいノイズになるように調整する\n    float frequency=1.;\n    float amplitude=1.;\n    int octave=5;\n    \n    float y=ramdom1d(x*frequency);\n    \n    for(int i=0;i<octave;i++)\n    {\n        result+=amplitude*y;\n        \n        amplitude*=.5;\n        y*2.;// octave jamp\n    }\n    return result;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265\nconst int MAX_MARCHING_STEPS=511;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=5000.;\nconst float PRECISION=.0001;\nconst vec3 SKY_COLOR=vec3(.6627,.9608,.9137);\n\nconst float CHAIR_HEIGHT=120.;\nconst float CHAIR_WIDTH=60.;\nconst float CHAIR_DEPTH=60.;\n// 角度ベクトルからXYZ順で回転行列を生成する関数\nmat3 rotationMatrix(vec3 rot){\n    \n    // 角度をラジアンに変換\n    float radX=radians(rot.x);\n    float radY=radians(rot.y);\n    float radZ=radians(rot.z);\n    \n    mat3 rotX=mat3(\n        1.,0.,0.,\n        0.,cos(radX),-sin(radX),\n        0.,sin(radX),cos(radX)\n    );\n    \n    mat3 rotY=mat3(\n        cos(radY),0.,sin(radY),\n        0.,1.,0.,\n        -sin(radY),0.,cos(radY)\n    );\n    \n    mat3 rotZ=mat3(\n        cos(radZ),-sin(radZ),0.,\n        sin(radZ),cos(radZ),0.,\n        0.,0.,1.\n    );\n    \n    // 全体の回転行列を合成 (XYZ順)\n    mat3 rotationMatrix=rotZ*rotY*rotX;\n    return rotationMatrix;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdPlane(vec3 p,vec3 n,float h){\n    // nは正規化された法線である必要がある\n    return dot(p,n)+h;\n}\n\nfloat sdBox(vec3 p,vec3 b,vec3 offset){\n    offset.y+=b.y;//原点を(b.y)Yminに設定してoffsetする\n    p-=offset;\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdRoundBox(vec3 p,vec3 b,float r,vec3 offset){\n    offset.y+=b.y;//原点を(b.y)Yminに設定してoffsetする\n    p-=offset;\n    vec3 q=abs(p)-b+r;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-r;\n}\n\nfloat sdChair(vec3 p){\n\n    p*=rotationMatrix(vec3(0.,210.,0));\n    \n    float seatHeight=4.;\n    float seatWidth=CHAIR_WIDTH*.5;\n    float seatDepth=CHAIR_DEPTH*.5;\n    \n    float legWidth=3.;\n    float legHeight=CHAIR_HEIGHT*.25;\n    float legDepth=3.;\n    float legR=sdRoundBox(p,vec3(legWidth,legHeight,legDepth),1.,vec3(seatWidth-legWidth,0.,seatDepth-legDepth));\n    float legL=sdRoundBox(p,vec3(legWidth,legHeight,legDepth),1.,vec3(-(seatWidth-legWidth),0.,seatDepth-legDepth));\n    \n    float seat=sdRoundBox(p,vec3(seatWidth,seatHeight,seatDepth),3.,vec3(0.,legHeight*2.,0.));\n    \n    float supportWidth=CHAIR_WIDTH*.45;\n    float supportHeight=3.;\n    float supportDepth=3.;\n    float frontSupport=sdRoundBox(p,vec3(supportWidth,supportHeight,supportDepth),1.,vec3(0.,CHAIR_HEIGHT*.45,seatDepth-supportDepth));\n    \n    float backSupportHeight=CHAIR_HEIGHT*.55;\n    float backSupportR=sdRoundBox(p,vec3(legWidth,backSupportHeight,legDepth),1.,vec3(seatWidth-legWidth,0.,-(seatDepth-legDepth)));\n    float backSupportL=sdRoundBox(p,vec3(legWidth,backSupportHeight,legDepth),1.,vec3(-(seatWidth-legWidth),0.,-(seatDepth-legDepth)));\n    \n    float backrestHeight=18.;\n    float backrestWidth=CHAIR_WIDTH*.55;\n    float backrestDepth=3.;\n    float backrest=sdRoundBox(p,vec3(backrestWidth,backrestHeight,backrestDepth),3.,vec3(0.,CHAIR_HEIGHT-backrestHeight,-seatDepth+backrestDepth*2.));\n    \n    float sideSupportWidth=legWidth-2.;\n    float sideSupportDepth=24.;\n    float sideSupportOffsetX=seatWidth;\n    float sideSupportTopR=sdRoundBox(p,vec3(sideSupportWidth,supportHeight,sideSupportDepth),1.,vec3(sideSupportOffsetX-legWidth,CHAIR_HEIGHT*.45,0.));\n    float sideSupportTopL=sdRoundBox(p,vec3(sideSupportWidth,supportHeight,sideSupportDepth),1.,vec3(-(sideSupportOffsetX-legWidth),CHAIR_HEIGHT*.45,0.));\n    float sideSupportMiddleR=sdRoundBox(p,vec3(sideSupportWidth,supportHeight,sideSupportDepth),1.,vec3(sideSupportOffsetX-legWidth,CHAIR_HEIGHT*.35,0.));\n    float sideSupportMiddleL=sdRoundBox(p,vec3(sideSupportWidth,supportHeight,sideSupportDepth),1.,vec3(-(sideSupportOffsetX-legWidth),CHAIR_HEIGHT*.35,0.));\n    \n    float d=min(min(min(legR,legL),seat),min(frontSupport,min(backSupportR,backSupportL)));\n    d=min(d,min(min(sideSupportTopR,sideSupportTopL),min(sideSupportMiddleR,sideSupportMiddleL)));\n    d=min(d,backrest);\n    \n    return d;\n}\n\nfloat sdRoom(vec3 p){\n    float floor=sdPlane(p,vec3(0.,1.,0.),0.);\n    float ceiling=sdBox(p,vec3(300.,1.,500.),vec3(0.,400.,0.));\n    float backWall=sdBox(p,vec3(300.,200.,1.),vec3(0.,0.,140.));\n    float sideWindow=sdBox(p,vec3(2.,150.,200.),vec3(300.,0.,0.));\n    float sideWallR=sdBox(p,vec3(1.,200.,500.),vec3(300.,0.,-100.));\n    float sideWallL=sdBox(p,vec3(1.,200.,500.),vec3(-300.,0.,0.));\n    float d=0.;\n    d=min(floor,ceiling);\n    d=min(d,backWall);\n    d=min(d,max(sideWallR,-sideWindow));\n    d=min(d,sideWallL);\n    return d;\n}\n\nfloat map(vec3 p){\n    float room=sdRoom(p);\n    // Mouse Interact\n    // https://www.shadertoy.com/view/Mss3zH\n    //if(sign(iMouse.z) ==1.)\n    //{\n    //    float angle=-90.*smoothstep(0.,1.,iTime);\n    //    vec3 pTranslated=p+vec3(CHAIR_WIDTH*.5,-CHAIR_HEIGHT*.5,0.);\n    //    p=vec3(vec3(p*rotationMatrix(vec3(0.,0.,angle))).xy,pTranslated.z);\n    //}\n\n    float chair=sdChair(p);\n    float d=0.;\n    d=min(chair,room);\n    return d;\n}\n\nfloat rayMarch(vec3 ro,vec3 rd,float start,float end){\n    float depth=start;\n    \n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        vec3 p=ro+depth*rd;\n        float d=map(p);\n        depth+=d;\n        if(d<PRECISION||depth>end)break;\n    }\n    \n    return depth;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p){\n    vec2 e=vec2(1.,-1.)*.5773;\n    const float eps=.0005;\n    return normalize(e.xyy*map(p+e.xyy*eps)+\n    e.yyx*map(p+e.yyx*eps)+\n    e.yxy*map(p+e.yxy*eps)+\n    e.xxx*map(p+e.xxx*eps));\n}\n\nfloat calcAO(vec3 pos,vec3 nor){\n    float occ=0.;\n    float sca=1.;\n    for(int i=0;i<5;i++)\n    {\n        float h=.01+.12*float(i)/4.;\n        float d=map(pos+h*nor);\n        occ+=(h-d)*sca;\n        sca*=.95;\n        if(occ>.35)break;\n    }\n    return clamp(1.-3.*occ,0.,1.)*(.5+.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow(vec3 ro,vec3 rd,float mint,float tmax){\n    // bounding volume\n    float tp=(.8-ro.y)/rd.y;\n    if(tp>0.)tmax=min(tmax,tp);\n    \n    float res=1.;\n    float t=mint;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++)\n    {\n        float h=map(ro+rd*t);\n        float s=clamp(8.*h/t,0.,1.);\n        res=min(res,s*s*(3.-2.*s));\n        t+=clamp(h,.02,.2);\n        if(res<.004||t>tmax)break;\n    }\n    return clamp(res,0.,1.);\n}\n\nvec3 screenComposition(vec3 bottom,vec3 top){\n    return bottom+top-bottom*top/1.;\n}\n\nvec3 render(vec3 ro,vec3 rd){\n    vec3 col=vec3(0.);\n    \n    float d=rayMarch(ro,rd,MIN_DIST,MAX_DIST);\n    \n    if(d>MAX_DIST)return col;// ray didn't hit anything\n    vec3 p=ro+rd*d;\n    vec3 normal=calcNormal(p);\n    \n    vec3 lightPosition=vec3(2000.,2000.,0.);\n    //vec3 lightDir=normalize(lightPosition-p);\n    vec3 lightDir=vec3(.2,.11,-.029);\n    vec3 albedo=vec3(.7,.6,.6);\n    float diffuse=clamp(dot(normal,lightDir),.3,1.);\n    float specular=pow(clamp(dot(reflect(lightDir,normal),rd),0.,1.),10.);\n    float ao=calcAO(p,normal);\n    float shadow=calcSoftshadow(p,lightDir,.25,5.);\n    \n    vec3 newRayOrigin=p+normal*PRECISION*2.;\n    float shadowRayLength=rayMarch(newRayOrigin,lightDir,MIN_DIST,MAX_DIST);\n    if(shadowRayLength<length(lightPosition-newRayOrigin))diffuse*=0.;// shadow\n    \n    col+=albedo*diffuse*shadow;\n    col+=albedo*ao*SKY_COLOR;\n    \n    return col;\n}\n\nvec3 postprocess(vec3 col,vec2 uv){\n    vec3 noiseCol=noise(uv,.5);\n    col=screenComposition(col,noiseCol);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 col=vec3(0);\n    \n    vec2 uv=fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 camBasePos=vec3(-200.,160.,-817.);\n    vec3 camMover=vec3(fbm(iTime*.3),fbm(iTime*.2+.5)*.3,0.);\n    vec3 ro=camBasePos+camMover;\n    \n    vec3 camTarget=vec3(0.,100.,50.);\n    mat3 camRotMatrix=rotationMatrix(vec3(-5.,0.,0.));\n    \n    vec3 camUp=normalize(camRotMatrix*vec3(0.,1.,0.));\n    vec3 camForward=normalize(camBasePos-camTarget);\n    vec3 camRight=normalize(cross(camForward,camUp));\n    float fov=150.;\n    \n    vec3 rd=normalize(camRight*uv.x+camUp*uv.y+camForward/tan(radians(fov)));\n    vec3 p=ro;\n    \n    float d=rayMarch(p,rd,MIN_DIST,MAX_DIST);\n    if(uv.x>.35||uv.x<-.35||uv.y>.35||uv.y<-.35)\n    {\n        col=vec3(0.);\n    }\n    else\n    {\n        col=render(ro,rd);\n        col=postprocess(col,uv);\n    }\n    \n    fragColor=vec4(col,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}