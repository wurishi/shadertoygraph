{"ver":"0.1","info":{"id":"tlVGRG","date":"1579255839","viewed":183,"name":"C_StarTravelling","username":"hyrchao","description":"小池塘遨游星翰\n\ninspired by https://www.youtube.com/watch?v=rvDo9LvfoVE&t=1307s","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["effect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPSILON 0.002\n#define STAR_COUNT 1.0\n#define STAR_LAYER 8.0\n#define STAR_SPEED 0.1\n\nconst float pi = 3.1415926;\n\nfloat saturate(float v) { return clamp(v, 0.0,       1.0);       }\nvec2  saturate(vec2  v) { return clamp(v, vec2(0.0), vec2(1.0)); }\nvec3  saturate(vec3  v) { return clamp(v, vec3(0.0), vec3(1.0)); }\nvec4  saturate(vec4  v) { return clamp(v, vec4(0.0), vec4(1.0)); }\n\n// Calc color based on temperature (kelvins)\nvec3 ColorTemperatureToRGB(float temperatureInKelvins)\n{\n\tvec3 retColor;\n\t\n    temperatureInKelvins = clamp(temperatureInKelvins, 1000.0, 40000.0) / 100.0;\n    \n    if (temperatureInKelvins <= 66.0)\n    {\n        retColor.r = 1.0;\n        retColor.g = saturate(0.39008157876901960784 * log(temperatureInKelvins) - 0.63184144378862745098);\n    }\n    else\n    {\n    \tfloat t = temperatureInKelvins - 60.0;\n        retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));\n        retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));\n    }\n    \n    if (temperatureInKelvins >= 66.0)\n        retColor.b = 1.0;\n    else if(temperatureInKelvins <= 19.0)\n        retColor.b = 0.0;\n    else\n        retColor.b = saturate(0.54320678911019607843 * log(temperatureInKelvins - 10.0) - 1.19625408914);\n\n    return retColor;\n}\n\n// Generate random number according to input vector2\nfloat Rand21(vec2 src)\n{\n\tvec2 rand = fract(src * vec2(233.33, 332.22));\n    rand += dot(rand, rand + vec2(66.6));\n    return fract(rand.x * rand.y);\n}\n\n// 2 dimension rotate \nvec2 Rotate(vec2 coord, float a)\n{\n    mat2 trans = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return trans * coord;\n}\n\n// Star pattern \nfloat DrawStar(vec2 coord , float crossIntensity)\n{\n    float distance = length(coord);\n    float light = 0.05 / distance;\n    float pattern = light;\n \tfloat crs1 = max(0.0, 1. - (abs(coord.x * coord.y * 1000.)));\n    pattern += crs1 * crossIntensity;\n    coord *= Rotate(coord, pi/4.);\n    float crs2 = max(0.0, 1. - (abs(coord.x * coord.y * 1000.)));\n    pattern += crs2 * 0.3 * crossIntensity;\n    \n    return smoothstep(1., .2, distance) * pattern;\n    //return distance / 50.; //debug range \n}\n\nvec3 StarLayer(vec2 coord)\n{\n    vec2 grid = fract(coord) - 0.5;\n    vec2 gridID = floor(coord);\n        \n    vec3 starPattern = vec3(0.0);\n    for (int i = -1; i <= 1; i++)\n        for (int j = -1; j <= 1; j++)\n        {\n            vec2 indexOffset = vec2(i, j);\n            vec2 id = gridID + indexOffset;\n            float rand = Rand21(id) - 0.5;\n            vec2 offset = vec2(rand, fract(rand * 23.3) - 0.5);\n            float size = fract(rand * 223.3);\n            // Calc star color based on star size and temporature\n            float tempRed = mix(7500.0, 1000.0, pow(size, 3.0));\n            // shape increase curve clamp to 0.0 to 1.0\n            float blueCurve = min(1.0, tan(size * 1.5) / 10.0);\n            float tempBlue = mix(7500.0, 30000.0, blueCurve);\n            float tempRand = fract(rand * 123.4) > 0.5 ? 1.0 : 0.0 ;\n            float temporature = mix(tempRed, tempBlue, tempRand);\n            vec3 starCol = ColorTemperatureToRGB(temporature);\n            // blink star based on layer (effected by otmosphere)\n            float blink = sin(iTime * 0.7 + rand * 33.22) * 0.4 + 0.6;\n            starPattern += DrawStar(grid - (indexOffset + offset), smoothstep(0.8, 1.2, size)) * size * starCol * blink;\n        }\n    return starPattern;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord/iResolution.xy - 0.5)* iResolution.y / iResolution.xy;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y ;\n    float t = (1.0 + sin(iTime)) * 1.5;\n    float k = t;\n    //uv *= k;\n    \n\tvec3 col = vec3(0.0);\n\n  \tuv = Rotate(uv, iTime * 0.1);\n    vec2 grid = uv * STAR_COUNT;;\n\n    for (float i = 0.0; i < 1.0; i += 1.0 / STAR_LAYER)\n    {\n    \tfloat depth = fract(iTime * STAR_SPEED + i);\n        float scale = mix(20.0, 0.1, depth);\n        // fade both in the begining and the end\n        float fade = depth * smoothstep(1.0, 0.9, depth);\n        col += StarLayer(grid * scale + i * 222.33) * fade;\n    }\n    //col = StarLayer(grid);\n    \n    // Debug\n    //float debugGridWidth = 0.01;\n    //float debugGrid = abs(grid.x - 0.5 + debugGridWidth) < EPSILON || abs(grid.y - 0.5 + debugGridWidth) < EPSILON ? 1.0 : 0.0;\n    //col *= 1. - debugGrid;\n    //col.b += debugGrid;\n\t//ol.rg *= gridID/.8; \n    \n    // Grid uv debug\n    //vec2 debugUV = grid;\n    //debugUV *= Rotate(debugUV, pi/4.);\n    //col.rg = debugUV;\n    \n    \n    fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"}]}