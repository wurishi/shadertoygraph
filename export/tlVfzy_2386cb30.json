{"ver":"0.1","info":{"id":"tlVfzy","date":"1614862424","viewed":86,"name":"Quantic ghost with luggage","username":"JeanArthurDeda","description":"A space-time flyby over a quantic ghost traveling with luggage and a breton hat\nTest for soft surfaces","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["softlight"],"hasliked":0,"parentid":"ttGfRW","parentname":"bondi template"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TYPE_GHOST 0\n#define TYPE_COUL 1\n\n// A space-time flyby on a quantic ghost traveling with luggage and a breton hat\n// He's aware of your GPU\n\nstruct Surfs\n{\n    Surf ghost;\n    Surf shirt;\n    Surf eyes;\n    Surf pupil;\n};\n\nstruct Context\n{\n    Surfs surfs;\n    float t;\n};\nSurf ghost(vec3 p, float hatAngle, float pupilAngle, Context cont)\n{\n    // pear head\n    const float head_hr=3.2f*.5;\n    const float head_wr=1.3*.5;\n    float g = ellipsoid(p,vec3(head_wr,head_hr,head_wr));\n    const float head_hr2=2.*.5;\n    const float head_wr2=1.7*.5;\n    g=opSU(g, ellipsoid(p+vec3(0,.52,0),vec3(head_wr2,head_hr2,head_wr2)),.3);\n    \n    // mouth\n    {\n        vec3 q=p;\n        q.y+=(q.x-.15)*(q.x-.15)*4.;\n        g = opS(sphere(q+vec3(-.15,.7,-0.7),.17),g);\n    }\n    \n    // nouse\n    g = opSU(g, cylinder(p-vec3(0,-.05,.5), 0.04,0.04),0.5);\n\n    // carve eye sockets\n    g = opS(sphere(p-vec3(.12,.4,.65),.13),g);\n    g = opS(sphere(p-vec3(-.12,.4,.65),.13),g);\n    \n    // eyes\n    float ed=.6;\n    float e;\n    {\n        vec3 q=p;\n        q.zy=rotate(q.zy,vec2(ed,.4),rad(-15.));\n        e=ellipsoid(q-vec3(.12,.4,ed),vec3(.11,.11,.04));\n        e=min(e,ellipsoid(q-vec3(-.12,.4,ed),vec3(.11,.11,.04)));\n    }\n    \n    // pupils\n    float pupilRadius=.07;\n    float pu=sphere(p-vec3(.12+cos(pupilAngle)*pupilRadius,.4+sin(pupilAngle)*pupilRadius,ed),0.06);\n    pu=min(pu,sphere(p-vec3(-.12+cos(pupilAngle)*pupilRadius,.4+sin(pupilAngle)*pupilRadius,ed),0.06));\n    \n    // ears\n    g = min(g, -0.05+cylinder((p-vec3(.6,.3,0)).xzy, 0.2, 0.1));\n    g = min(g, -0.05+cylinder((p-vec3(-.6,.3,0)).xzy, 0.2, 0.1));\n    \n    // breton hat\n    {\n        vec3 q=p;\n        float r=1.2;\n        q.y -= smoothstep(r-.5, r,length(q.xz))*.3;\n        q.yz=rotate(q.yz,vec2(.8,0),hatAngle);\n        g=min(g,-.02+.8*cylinder(q-vec3(0,.8,0), r, .00));\n    }\n    \n    // body\n    g=opSU(g,cylinder(p+vec3(0,2.2,0),.2,.8),.3);\n    g*=.9;\n    float b=-.5+box(p+vec3(0,2.35,0),vec3(.7,.2,.0));\n    \n    Surf s = surf(cont.surfs.ghost, g-0.001);\n    \n    s = opU(s, surf(cont.surfs.eyes,e));\n    s = opU(s, surf(cont.surfs.pupil,pu));\n    \n    cont.surfs.shirt.c*=cos(p.y*40.)*.5+.5;;\n    s = opU(s, surf(cont.surfs.shirt,opSU(g,b,.5)));\n    return s;\n}\nSurf scene(vec3 p, Context cont)\n{\n    vec3 q=p;\n    q.xz = rotate(q.xz, vec2(0, -3), q.x*.06);\n    vec3 i=wrapi(q,vec3(2.5));\n    q=wrapl(q,vec3(2.5), vec3(2,0,0));\n    Surf s = ghost(q, rad(40.+i.x*20.),rad(i.x*45.),cont);\n    s = opU(s, surf(cont.surfs.ghost, -.5+.9*box(q+vec3(0.,3.4,-1.),vec3(.5,.5,.2))));\n    return s;\n}\nvec3 sky(vec3 d, Context cont){return texture(iChannel0, d).xyz;}\nDECL_RAY (ray, scene,.0,20.,128)\nDECL_NOR (nor, scene)\nDECL_AO  (ao, scene)\nDECL_SHD (shadow, scene)\nDECL_SOFT(soft, scene)\nvec3 mat(vec3 p, vec3 n, vec3 d, Surf s, Context cont)\n{\n    float t=cont.t;\n    vec3 l=normalize(vec3(0,1,1));\n    float k;\n    k=soft(p,l,s.ss,cont);\n    vec3 c=s.c;\n    if (s.t == TYPE_GHOST)\n    {\n        float v = max(n.x, n.y)*.5+.5;\n        c*=mix(col(43,55,255),col(156,255,208),1.-cos(v*PI*.5));\n    }\n    return c*k;\n}\nvec3 fog(float t, vec3 d, vec3 c, Context cont){return mix(c,sky(d, cont),clamp(exp(-(15.-t)*.22),0.,1.));}\nDECL_TO_REFL(sky_to_refl,sky)\nDECL_RENDER(render,sky,ray,mat,nor,sky_to_refl,fog)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Context cont;\n    cont.t = iTime;\n    cont.surfs.ghost = surf(col(255),TYPE_GHOST,.1,1.,.3,1.);\n    cont.surfs.shirt = surf(col(255),TYPE_COUL,0.,0.,.03,1.);\n    cont.surfs.eyes = surf(col(512),TYPE_COUL,1.,1.,.3,1.);\n    cont.surfs.pupil = surf(col(30),TYPE_COUL,0.,0.,.0,1.);\n\n    vec2 p =(-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float t = sin(cont.t*.3)*3.;\n    float r=cos(t*.2)*2.+6.;\n    vec3 o=vec3(sin(t*.4)*r,cos(2.+t*.5)*2.,cos(t*.3)*r);\n    vec3 x,y,z;\n    vec3 d=normalize(vec3(p,1.)*camera(o,vec3(0),x, y, z));\n    fragColor=vec4(render(o,d,cont),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793238f\n\nvec3 col(int r, int g, int b){return vec3(r,g,b)/255.;}\n\nvec3 col(int i) {return vec3(i)/255.;}\n\nstruct Surf\n{\n    float d;\n    vec3 c; \n    int t; \n    float r;\n    float f;\n    float ss;\n    float m;\n};\n\nSurf surf(vec3 c,int t,float r,float f,float ss,float m){Surf s;s.c=c;s.t=t;s.r=r;s.f=f;s.ss=ss;s.m=m;return s;}\n\nSurf surf(Surf s, float d){Surf r=s;r.d=d;return r;}\n\nstruct Dir\n{\n    vec3 c;\n    vec3 d;\n};\n\nstruct Omni\n{\n    vec3 c;\n    vec3 p;\n};\n\nstruct Spot\n{\n    vec3 c;\n    vec3 p;\n    vec3 d;\n    vec2 h;\n};\n\nfloat rad(float a) {return a*PI/180.0;}\n\nfloat sphere(vec3 p,float r){return length(p)-r;}\n\nfloat box(vec3 p,vec3 s){vec3 q=abs(p)-s;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);}\n\nfloat ellipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat plane(vec3 p,vec3 n,float d){return dot(p,n)+d;}\n\nfloat cylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurf opU(Surf s1,Surf s2) {if(s1.d<s2.d)return s1; return s2;}\n\nfloat opS(float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI(float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 wrap(vec3 p, vec3 s){return mod(p+.5*s,s)-.5*s;}\n\nvec3 wrapi(vec3 p, vec3 s){return floor(p/s-.5);}\n\nvec2 wrap(vec2 p, vec2 s){return mod(p+.5*s,s)-.5*s;}\n\nvec2 wrapi(vec2 p, vec2 s){return floor(p/s-.5);}\n\nfloat wrap(float p, float s){return mod(p+.5*s,s)-.5*s;}\n\nfloat wrapi(float p, float s){return floor(p/s-.5);}\n\nvec3 wrapl(vec3 p, vec3 s, vec3 l){return p-s*clamp(round(p/s),-l,l);}\n\nvec2 wrapl(vec2 p, vec2 s, vec2 l){return p-s*clamp(round(p/s),-l,l);}\n\nfloat atten(vec3 l) {return 1./dot(l,l);}\n\nvec3 dir(vec3 p, vec3 n, Dir d)\n{\n    float k= clamp(dot(n,d.d),0.,1.);\n    return k*d.c;\n}\n\nfloat rand(float seed){return fract(sin(seed) * 1231534.9);}\n\nvec2 rotate(vec2 v, vec2 o, float a) \n{\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\tmat2 m=mat2(c,-s,s,c);\n\treturn o+(v-o)*m;\n}\n\nvoid omni(vec3 p, vec3 op, out vec3 l, out float k)\n{\n    l=op-p;\n    k = atten(l);\n    l = normalize(l);\n}\n\nvec3 omni(vec3 p, vec3 n, Omni o)\n{\n    vec3 l;\n    float k;\n    omni(p, o.p, l, k);\n    k*= clamp(dot(n,l),0.,1.);\n    return k*o.c;\n}\n\nvoid spot(vec3 p, vec3 sp, vec3 sd, vec2 sh, out vec3 l, out float k)\n{\n    omni(p, sp, l, k);\n    k *= smoothstep (cos(sh.y),cos(sh.x),dot(l,-sd));\n}\n\nvec3 spot(vec3 p, vec3 n, Spot s)\n{\n    vec3 l;\n    float k;\n    spot(p, s.p, s.d, s.h, l, k);\n    k*= clamp(dot(n,l),0.,1.);\n    return k*s.c;\n}\n\nmat3 camera(vec3 o, vec3 t, out vec3 x, out vec3 y, out vec3 z)\n{\n\tz = normalize(t-o);\n\tx = cross(vec3(0,1,0),z);\n\ty = cross(z,x);\n    return transpose(mat3(x,y,z));\n}\n\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) + \n#ifndef SIMPLE_APPROX\n           vec3(1.0,0.1,0.01)*0.2*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n#else\n           vec3(1.0,0.1,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n#endif\n}\n\n#define DECL_RAY(name,scene,near,far,iterations) \\\nSurf name(vec3 o, vec3 d, Context cont) \\\n{ \\\n    float t = near; \\\n    Surf r; \\\n    for( int i=0; i<iterations; i++ ) \\\n    { \\\n\t    r = scene(o+d*t,cont); \\\n        if(r.d<t*0.0001||t>far) break; \\\n        t+=r.d; \\\n    } \\\n    r.d=t>far?-1.:t; \\\n    return r; \\\n}\n\n#define DECL_NOR(name,scene) \\\nvec3 name(vec3 p, Context cont) \\\n{ \\\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005; \\\n    return normalize( e.xyy*scene(p+e.xyy,cont).d + \\\n\t\t\t\t\t  e.yyx*scene(p+e.yyx,cont).d + \\\n\t\t\t\t\t  e.yxy*scene(p+e.yxy,cont).d + \\\n\t\t\t\t\t  e.xxx*scene(p+e.xxx,cont).d );\\\n}\n\n#define DECL_AO(name,scene) \\\nfloat name(vec3 p, vec3 n, Context cont) \\\n{ \\\n\tfloat o = 0.0; \\\n    float s = 1.0; \\\n    for(int i=0;i<5;i++) \\\n    { \\\n        float hr = 0.01 + 0.12*float(i)/4.0; \\\n        vec3 aopos=n*hr+p; \\\n        float dd = scene(aopos,cont).d; \\\n        o += -(dd-hr)*s; \\\n        s *= 0.95; \\\n    } \\\n    return clamp(1.-3.*o,0.,1.); \\\n}\n// a wonderful doodle from https://www.shadertoy.com/view/XscyRs\n#define DECL_SOFT(name,scene) \\\nfloat name(vec3 p, vec3 l, float spread, Context cont)\\\n{ \\\n    float k=0.0; \\\n    const int numSamples=6; \\\n    for(int i = 1; i < numSamples;++i) \\\n    { \\\n        float d = rand(float(i)); \\\n        vec3 o = vec3(d, rand(float(i)+1.), rand(float(i)+2.));\\\n        o = normalize (o-vec3(.5)); \\\n        o = normalize (l+o); \\\n        float id = scene(p+o*d*spread,cont).d/spread; \\\n        float s=max(d+id, 0.1); \\\n        s/=pow(1.+.3*(1./d), 2.); \\\n        k+=s; \\\n    } \\\n    k/=float(numSamples);\\\n\treturn smoothstep(0.1, .5, k); \\\n}\n\n#define DECL_SHD(name,scene) \\\nfloat name(vec3 p,vec3 d,float s,float e, Context cont) \\\n{ \\\n\tfloat res = 1.0; \\\n    float t = s; \\\n    for( int i=0; i<16; i++ ) \\\n    { \\\n\t\tfloat h = scene(p+d*t,cont).d; \\\n        res = min(res,8.0*h/t); \\\n        t += clamp(h,0.02,0.10); \\\n        if(h<0.001||t>e) break; \\\n    } \\\n    return clamp(res,0.,1.); \\\n}\n\n#define DECL_TO_REFL(name, SKY) vec3 name(vec3 p,vec3 d,Context cont) {return SKY(d,cont);}\n\n#define DECL_RENDER(name,SKY,RAY,MAT,NOR,REFL,FOG) \\\nvec3 name(vec3 o,vec3 d, Context cont) \\\n{ \\\n    vec3 sky=SKY(d,cont); \\\n    vec3 c=sky; \\\n    Surf s=RAY(o,d,cont); \\\n    if (s.d>0.0) \\\n    { \\\n        vec3 p=o+s.d*d; \\\n        vec3 n=NOR(p,cont); \\\n        float f=1.-pow(dot(n,-d),s.f);\\\n        c=MAT(p,n,d,s,cont); \\\n        c+=REFL(p,reflect(d,n),cont)*s.r*f;\\\n        c=FOG(s.d,d,c,cont); \\\n        c=mix(c,sky,1.-pow(dot(n,-d),s.m));\\\n    } \\\n    return c; \\\n}","name":"Common","description":"","type":"common"}]}