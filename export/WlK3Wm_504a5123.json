{"ver":"0.1","info":{"id":"WlK3Wm","date":"1579880679","viewed":103,"name":"March 2D","username":"spalmer","description":"simple test of ray marching methods, but in 2D where it's relatively easy.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// March 2D !\n\n// for debugging 3d-style sdf ray marching methods\n// in 2 dimensions where the problems\n// are simpler and easier to visualize\n\n// for 1d version, see https://shadertoy.com/view/tlK3Ww\n// shows the marching process a bit clearer\n// for 3d version, see https://shadertoy.com/view/tlGXDK\n// has flyaround debug camera, lighting, shadows, \n// lots of good stuff, considering it's a \n// shape and march methodology testbed!\n\n// in fact since it's such a PITA to debug,\n// I actually want a March 1D similar to \n// the one I made in Vulkan, for fine-tuning\n// the actual marching algorithms.\n\n// see Common tab for shape and march functions\n\n#define STYLE 1\n\n// \"standard\" sdf gradient debugging    \nvec3 DebugSDF(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(120.*d);\n    return mix(col, vec3(1), 1.-smoothstep(.0,.02,abs(d))); // white at zero\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    vec2 q = StoQ(p, R);\n    vec2 m = StoQ(iMouse.xy, R);\n    vec2 mo = iMouse.z < 0. ? m : StoQ(abs(iMouse.zw), R);\n    float brad = .5, pixel = 2./R.y;\n    vec2 qs = q / brad; // main object scale\n    float sd; // signed distance to shape from q\n    sd = dshape(qs) * brad; //(q / brad)\n    float md; // signed distance to shape from m\n    md = dshape(m / brad) * brad;\n    vec2 la = mo, lb = m; //vec2(-.5,.7), lb = vec2(.5, .69);\n    vec2 ld = normalize(lb - la); // good chance ld will be nans if mouse isn't down.\n    vec2 lc = la / brad; // ray origin in local scale\n    const int niter = 0; //1; //4; //8; //16; //64; //\n    const int ndbg = 4;\n    vec4 lt;\n    float tlo = 0., thi = 6.; //12.;\n//    ClipRayToSlabY(lc, ld, tlo, thi); // clip while local\n    for (int i = 0; i < ndbg; ++i) {    \t\n    \tlt[i] = tshape(lc, ld, niter+i, tlo, thi) * brad;\n    }\n    float aa = .5 * iResolution.y;\n    //float lt = tshape(lc, ld, niter, tlo, thi) * brad;\n    tlo *= brad; thi *= brad;\n    float d = 3.4e38; c.rgb = vec3(0.); // bg\n    if (STYLE == 0) DR(d, c.rgb, sd, vec3(.8,.4,0)); // draw actual shape by its sdf\n    //bool missed = !(abs(lt[ndbg-1]) < .5*pixel); //4e-3); //!(lt[ndbg-1] >= 0. && lt[ndbg-1] < 2e-3); //thi); // || niter < 0;\n    bool missed = !(abs(PARA(dshape, lc, ld, lt[ndbg-1]/brad)) < 2.*pixel/brad);\n    vec3 chit = missed ? vec3(.5,.0,.0) : vec3(0.,.5,.0);\n    DR(d, c.rgb, dline(q, la, lb) - .5 * pixel, .6*chit);\n    DR(d, c.rgb, dball(q - la) + .988, .9*chit);\n//    if (tlo >= 0.)\n//    DR(d, c.rgb, dball(q - la - ld * tlo) + .98, vec3(.9,.9,.4));\n//    if (thi >= 0.)\n//    DR(d, c.rgb, dball(q - la - ld * thi) + .98, vec3(.9,.4,.9));\n//    if (missed)\n//        DR(d, c.rgb, dball(q - mix(la, lb, -.01)) + .99, vec3(1.,.0,.0));\n//    else {\n    \tfor (int i = 0; i < ndbg; ++i) {\n            if (!(lt[i] >= 0.)) continue;\n    \t    vec2 lh = la + ld * lt[i];\n            bool last = i == ndbg-1;\n\t        DR(d, c.rgb, abs(dball((q - la) / lt[0]) * lt[0]) - .5*pixel, vec3(.2,.3,.3));\n\t        DR(d, c.rgb, dball(q - lh) + (last ? .98 : .988),\n               last ? vec3(.5) :\n               \tlt[i] > lt[ndbg-1] ? vec3(.0,.0,.9) : vec3(.0,.9,.0));\n        }\n        //vec2 lh = la + ld * lt;\n        //DR(d, c.rgb, dball(q - lh) + .98, vec3(.7,.9,.9));\n//    }\n    float cov = clamp(.5-.5*R.y*d, 0., 1.); // antialias edge linearly\n    vec3 cbg = vec3(0.,0.,.15); // btw coverage is important for bg blending\n    if (missed) cbg = vec3(.1,.0,.0);\n\tif (STYLE == 1) cbg = DebugSDF(sd);\n    c.rgb = mix(cbg, c.rgb, cov);\n    if (STYLE == 0) c.gb += .04*exp2(-R.y*abs(abs(sd)-.25)); // debug isocontours - subtle\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamut\n    c.a = 1.;\n}\n\n// TODO fake lighting by gradient\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// copies of sdf functions from my Dist 2D\n// https://shadertoy.com/view/WtVGWm\n\nconst float pi = acos(-1.); //3.141592;\n\n// aspect-correct windowing\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n\n// signed distance\n\nfloat dbox(float p)\n{\n    return abs(p) - 1.;\n}\n\nfloat dplaine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 r = p - a, d = normalize(b - a);\n    return dot(r, vec2(-d.y, d.x));\n}\n\nfloat dline(vec2 p, vec2 a, vec2 b)\n{\n    return abs(dplaine(p, a, b));\n}\n\nfloat dplanex(vec2 q)\n{\n    return abs(q.x);\n}\n\nfloat dball(vec2 p)\n{\n    return length(p) - 1.;\n}\n\nfloat dslab(vec2 q, vec2 n)\n{\n    return dbox(dot(q, n));\n}\n\nfloat dhspacey(vec2 q)\n{\n    return q.y;\n}\n\nfloat dslabx(vec2 q)\n{\n    return abs(q.x) - 1.;\n//    return dslab(q, vec2(1, 0));\n}\n\nfloat dbox(vec2 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(1, 0)));\n    d = max(d, dslab(q, vec2(0, 1)));\n    // should replace distance in corner voronoi regions;\n    // sometimes would rather leave them too-sharp though.\n    if (all(lessThan(vec2(1.), abs(q)))) d = distance(abs(q), vec2(1));\n    return d;\n}\n\nfloat dpyras(vec2 q)\n{\n\tq.x = abs(fract(q.x / 4.) * 4. - 2.);\n    //q.x = mod(q.x + 9., 4.) - 2.;\n#if 0\n    q.x = abs(q.x);\n    float dp = (q.y + q.x - 1.) * sqrt(.5);\n    if (q.y > q.x + 1.) dp = length(q-vec2(0,1));\n    float r = min(dp, q.y);\n    return r;\n#else\n    // similar, newer stab at it\n\treturn q.x < q.y - 1.\n\t\t? length(q - vec2(0,1)) // above point\n\t\t: min(q.y, sqrt(.5) * (q.x + q.y - 1.)); // either ground plane or nearest pyra face \n#endif\n}\n\n\n// disc tiling stuff, basic kerning support\n#if 1\nconst float voxtile = .5;\nconst float discsize = voxtile * .25;\nconst vec2 voxorg = vec2(0);\n\nvec2 voxpos(ivec2 i)\n{\n    return vec2(i) * voxtile + voxorg;\n}\n\n// given world space position, return closest voxel id\nivec2 voxid(vec2 p)\n{\n    return ivec2(round((p - voxorg) / voxtile));\n}\nivec2 voxdid(vec2 p)\n{\n    p -= voxorg;\n    p /= voxtile;\n    ivec2 i = ivec2(round(p));\n    if (((i.x^i.y)&1) != 0) {\n        vec2 d = p - vec2(i);\n        vec2 a = abs(d);\n        if (a.x > a.y) i.x += int(sign(d.x));\n        else           i.y += int(sign(d.y));\n    }\n    return i;\n}\n\nbool isVoxel(ivec2 i) // object in this cell?\n{\n    if ((((i.x^i.y)>>1)&3)==0) return false;\n    return true; //i.y >= 0 && i.y <= 1; //\n}\n\nivec2 voxstorage(ivec2 i)\n{\n    i.x >>= 1;\n    return i;\n}\n\nfloat dOccupCell(vec2 q)\n{\n    // the actual object in this cell, wiggled if necessary\n\treturn length(q) - discsize; // ball at lattice points\n}\n\n// estimate distance to nearest possible neighbor bound\nfloat dEmptyCell(vec2 q)\n{\n    vec2 a = abs(q)\n    , d = step(0., q) * 2. - 1.; //d = sign(q); // sign is buggy\n    if (a.x > a.y) d.y = 0.; // x max\n    else d.x = 0.; // y largest component - keep only the largest\n    q -= d * voxtile; // snap to closest neighbor cell\n    return dOccupCell(q) - 1e-3; // conservative bounding disc size, max wiggle accounted for\n}\n// FCC tiling\nfloat dEmptyDCell(vec2 q)\n{\n    vec2 a = abs(q)\n    , d = step(0., q) * 2. - 1.;\n    // keep the two largest components (of two, in this 2D case)\n    q -= d * voxtile; // snap to closest neighbor cell\n    return dOccupCell(q) - 1e-3;\n}\n\nfloat dtileddiscs(vec2 p)\n{\n    ivec2 i = voxid(p);\n    vec2 q = p - voxpos(i);\n    return dOccupCell(q);\n}\n\nfloat ddiamondtileddiscs(vec2 q)\n{\n    ivec2 i = voxdid(q);\n    q -= voxpos(i);\n    return dOccupCell(q);\n}\n\nfloat dsparsetileddiscs(vec2 q)\n{\n    ivec2 i = voxid(q);\n    q -= voxpos(i);\n    return isVoxel(i)\n        ? dOccupCell(q)\n        : dEmptyCell(q);\n}\n\nfloat dsparsediamondtileddiscs(vec2 q)\n{\n    ivec2 i = voxdid(q);\n    q -= voxpos(i);\n    return isVoxel(i)\n        ? dOccupCell(q)\n        : dEmptyDCell(q);\n}\n\n#endif\n\nfloat dshape(vec2 q)\n{\n    return\n    //    dhspacey\n    \t  dpyras\n    //    dplanex\n    //    dball\n    //    dslabx\n    //    dbox\n    //    dmandelbulb2\n    //    dmandelbulbE2\n    //    dtileddiscs\n    //    ddiamondtileddiscs\n    //    dsparsetileddiscs\n    //    dsparsediamondtileddiscs\n        (q);\n}\n\n// analytical plane trace for reference\nfloat tplanex(vec2 ro, vec2 rd, int iter)\n{\n\treturn ro.x * rd.x > 0. ? -1. : \n    \tabs(ro.x) < 1e-7 ? 0. : ro.x / -rd.x;\n}    \n\n\n\n// trace intersections thru -1..1 unit slab and intersect the ranges incrementally\n// should initialize tmin to 0. and tmax to FLT_MAX or 3.4e38 or so\nvoid tslab(float no, float nd, inout float tmin, inout float tmax)\n{\n    if (nd == 0. && abs(no) <= 1.) return; \n    float d0 = no / -nd; // d to central plane\n    nd = abs(1./nd);\n    float d1 = d0 + nd;\n    d0 -= nd;\n    if (d0 <= tmax && d1 >= tmin) {\n\t    tmin = max(tmin, d0);\n        tmax = min(tmax, d1);\n       \tif (tmin < tmax) return;\n    }\n    tmin = tmax = -1.; // completely clipped\n}\n\n\n// a 2D tslab on y axis\nvoid ClipRayToSlabY(vec2 ro, vec2 rd, inout float tlo, inout float thi)\n{\n    tslab(ro.y, rd.y, tlo, thi);\n}\n\n// regula falsi from pyramid field https://shadertoy.com/view/3ld3Dl\n\n// a single iteration of a linear bracketed root finder algorithm aka regula falsi;\n// Linearly interpolate the position of a root between two known values on either side\n// returns mix factor to use between original two points\n// v0 = sdf(x0) and v1 = sdf(x1), then xRoot ~= mix(x0, x1, FalsePositionEstimate(v0, v1))\n// x0 and x1 *must* bracket the root, so v0 and v1 must have opposite signs or be zero.\n// takes two samples from field and returns interpolation factor between them where zero is likely to be found\nfloat FalsePositionEstimate(float v0, float v1)\n{\n\tfloat l = v0 - v1; \n\treturn abs(l) < 1e-24 ? .5 : v0 / l;\n}\n\n    \n// ray marching\n\n#if 1\n// you can have this old marching macro! yuck.  it used to work.\n#define  MARCH1(_t, _niter, _f, _lo, _hi, _rate)\t\t\t\t\t\t\\\nfloat _t = _lo;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat _d = _f;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat _od = _d + 1e-3, _ot = _lo + 1e-3;\t\t\t\t\t\t\t\\\n\tint _iter = _niter;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t/*float _rni = 1./float(_niter-1);*/\t\t\t\t\t\t\t\t\\\n\twhile(abs(_d) > 2e-3 && _iter-- >= 0) {\t\t\t\t\t\t\t\t\\\n\t\t_ot = _t; _od = _d;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t/*float _i = 1. - float(_iter) * _rni;*/\t\t\t\t\t\t\\\n\t\t_t = _t + max(1e-5, _rate*_d);\t\t\t\t\t\t\t\t\t\\\n\t\t_d = _f; \t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (_t >= _hi) { _t = -1.; break; }\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t_niter = _iter;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n/* * /    if (_t >= _lo && !(_t >= _hi)) _t = mix(_ot, _t, max(0., FalsePositionEstimate(_od, _d)));  / * */\t\\\n} while (false) // do not allow false position to go backwards past _ot!\n///\n#endif\n    \n// want a march macro that takes a 1d-parameterized sdf\n// instead of a ro and rd\n// then make the 2D sdf march macro just wrap that\n\n#if 1\n// a simpler, bad macro\n// f is a function of t\n#define MARCH0(_t, iter, f, _lo, _hi, _rate) \\\nfloat _t = _lo;\t\\\ndo { \\\n    float _d; \\\n    while (iter-- > 0 && (_d = f) > 0.) \\\n        _t += max(1e-5, _rate*_d); \\\n    if (/*iter < 0 ||*/ _t > _hi) \\\n        _t = -1.; \\\n} while (false)\n///\n#endif\n// macro selector, for trying different implementations\n#define MARCH MARCH1\n    //0//\n\n    \n\n// converts given sdf and ray into parametric function of ray and field and some argument\n#define PARA(sdf, ro, rd, t) \\\n\t(sdf((ro) + (rd) * (t)))\n///\n\n\n// tshape in terms of dshape\nfloat mshape(vec2 ro, vec2 rd, int iter, float tlo, float thi)\n{\n    MARCH(t, iter, PARA(dshape, ro, rd, t), tlo, thi, 1.001); //.8); //\n    return t;\n}\n\nfloat tshape(vec2 ro, vec2 rd, int iter, float tlo, float thi)\n{\n    return mshape(ro, rd, iter, tlo, thi);\n}\n\n\n// distance field color accumulator macro\n// basically keeps only the closest surface's color and distance.\n// beware dangling else issues; use {} just in case, requires do to allow trailing semicolon\n#define DR(od, oc, nd, nc) \\\ndo { float _nd = (nd); \\\n    if (_nd < od || _nd < 0.) od = _nd, oc = nc; \\\n    } while(false)\n\n","name":"Common","description":"","type":"common"}]}