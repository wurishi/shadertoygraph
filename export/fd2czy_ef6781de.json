{"ver":"0.1","info":{"id":"fd2czy","date":"1643721400","viewed":116,"name":"Textured Geometric Series","username":"jt","description":"Looplessly textured variant of [url=https://www.shadertoy.com/view/7dScRG]1/4+1/16+1/64+1/256+...[/url].\nFurther development see [url=https://www.shadertoy.com/view/sdByzy]Textured Sierpinski Triangle[/url].\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["infinite","geometric","textured","loopless","series","sum","telescoping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/fd2czy Textured Geometric Series 2022-2-1 by jt\n// Looplessly textured variant of https://www.shadertoy.com/view/7dScRG 1/4+1/16+1/64+1/256+...\n\n// tags: infinite, geometric, textured, loopless, series, sum, telescoping\n\n// original (243 chars)\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec2 s = floor(log2(u));\n    o -= o;\n    if(s.x > s.y) o += texture(iChannel0, u/exp2(s.x) - vec2(1.,0.)); // clamped (video-)texture requires adjustment -vec2(1.,0.)\n    //if(s.x > s.y) o += texture(iChannel0, u/exp2(s.x)); // repeated texture doesn't require adjustment -vec2(1.,0.)\n    if(s.x < s.y) o += texture(iChannel2, u/exp2(s.y) - vec2(0.,1.)); // clamped (video-)texture requires adjustment -vec2(0.,1.)\n    //if(s.x < s.y) o += texture(iChannel2, u/exp2(s.y)); // repeated texture doesn't require adjustment -vec2(0.,1.)\n    if(s.x == s.y) o += texture(iChannel1, u/exp2(s.x) - vec2(1.,1.)); // clamped (video-)texture requires adjustment -vec2(1.,1.)\n    //if(s.x == s.y) o += texture(iChannel1, u/exp2(s.x)); // repeated texture doesn't require adjustment -vec2(1.,1.)\n}\n\n/*\n// code-golfed by Xor (154 chars) - weirdly this breaks my videos (clamped, even though I selected repeat)\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o.xy = exp2(floor(log2(u)));\n    o = o.x > o.y ? texture(iChannel0, u/o.x):\n        o.x < o.y ? texture(iChannel2, u/o.y):\n                    texture(iChannel1, u/o.x);\n}\n*/\n","name":"Image","description":"","type":"image"}]}