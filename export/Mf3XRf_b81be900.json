{"ver":"0.1","info":{"id":"Mf3XRf","date":"1714432456","viewed":130,"name":"Boids of Prey","username":"gunthern","description":"Flocking based on Craig Reynolds' Boids: http://www.red3d.com/cwr/boids/\n\nAdded predators, who seek out, chase, and eat boids to grow larger and slower. Use the mouse to interact, and press space to toggle interaction mode.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["compute","flocking","boids","boid","agents","agent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;   \n    vec4 col = texture(iChannel0, uv);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Scatter boids throughout the space\nvoid init(inout vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = vec4(0.0);\n    \n    // Boids\n    if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount) {\n        fragColor = vec4(\n            random(fragCoord + vec2(1.0, 2.0)) + 1.0, // Position X + Marker\n            random(fragCoord + vec2(3.0, 4.0)), // Position Y + State\n            random(fragCoord + vec2(5.0, 6.0)) * 2.0 - 1.0, // Direction X\n            random(fragCoord + vec2(7.0, 8.0)) * 2.0 - 1.0 // Direction Y\n        );\n        \n        return;\n    }\n    \n    // Predators\n    else if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount + predatorCount) {\n        fragColor = vec4(\n            random(fragCoord + vec2(1.0, 2.0)) + 2.0, // Position X + Marker\n            random(fragCoord + vec2(3.0, 4.0)), // Position Y + State\n            random(fragCoord + vec2(5.0, 6.0)) * 2.0 - 1.0, // Direction X\n            random(fragCoord + vec2(7.0, 8.0)) * 2.0 - 1.0 // Direction Y\n        );\n        \n        return;\n    }\n    \n    else discard;\n\n}\n\nvoid update(inout vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 mousePos = iMouse.xy;\n\n    // Boids\n    if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount) {\n    \n        float boidsSeen = 0.0;\n        float predatorsSeen = 0.0;\n        float spacingCount = 0.0;\n        \n        vec2 posVectors = vec2(0.0);\n        vec2 dirVectors = vec2(0.0);\n        vec2 spacingVectors = vec2(0.0);\n        \n        vec2 predatorVectors = vec2(0.0);\n        \n        vec2 thisBoidPos = fract(fragColor.xy) * iResolution.xy;\n        vec2 thisBoidDir = fragColor.zw;\n        \n        bool boidEaten = fragColor.x >= 3.0 ? true : false;\n        \n        bool mouseSeen = false;\n        \n        if (!boidEaten) {\n            for (int i=0; i<predatorCount; i++) {\n                ivec2 coord = ivec2(int(mod(float(i+boidCount), iResolution.x)), int(float(i+boidCount) / iResolution.x));\n                vec4 predator = texelFetch(iChannel0, coord, 0);\n                vec2 predatorPos = fract(predator.xy) * iResolution.xy;\n                float dist = distance(thisBoidPos, predatorPos);\n\n                vec3 dp = loopDistPosition(thisBoidPos, predatorPos, dist, iResolution.xy);\n                predatorPos = dp.xy;\n                dist = dp.z;\n\n                if (dist < boidSearchRange) {\n                    if (iTime > predatorEatDelay && dist < predatorEatRange) {\n                        boidEaten = true;\n                        break;\n                    }\n                    predatorsSeen++;\n                    predatorVectors += thisBoidPos - predatorPos;\n                }\n            }\n\n            if (!boidEaten) {\n                for (int i=0; i<boidCount; i++) {\n                    ivec2 coord = ivec2(int(mod(float(i), iResolution.x)), int(float(i) / iResolution.x));\n                    if (coord != ivec2(fragCoord)) {\n                        vec4 otherBoid = texelFetch(iChannel0, coord, 0);\n                        \n                        if (otherBoid.x < 3.0) {\n                            vec2 otherBoidPos = fract(otherBoid.xy) * iResolution.xy;\n                            float dist = distance(thisBoidPos, otherBoidPos);\n\n                            vec3 dp = loopDistPosition(thisBoidPos, otherBoidPos, dist, iResolution.xy);\n                            otherBoidPos = dp.xy;\n                            dist = dp.z;\n\n                            if (dist < boidSearchRange) {\n                                boidsSeen++;\n                                posVectors += otherBoidPos - thisBoidPos;\n                                dirVectors += otherBoid.zw;\n\n                                if (dist < boidSpacingDist) {\n                                    spacingCount++;\n                                    spacingVectors += thisBoidPos - otherBoidPos;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (iMouse.z > 0.0) {\n                    float dist = distance(thisBoidPos, mousePos);\n                    if (dist < mouseSearchRange) mouseSeen = true;\n                }\n\n                if (iFrame > 1) {\n\n                    vec2 randomDir = vec2(\n                            random(fragCoord + sin(iTime)) * 2.0 - 1.0,\n                            random(fragCoord + sin(iTime*0.5)) * 2.0 - 1.0\n                         );\n\n                    if (mouseSeen) {\n                        thisBoidDir = normalize(mouseAttract ? mousePos - thisBoidPos : thisBoidPos - mousePos) * mouseStrength\n                        + thisBoidDir * (1.0 - mouseStrength);\n                    }\n\n                    if (boidsSeen > 0.0) {\n                        thisBoidDir = \n                            normalize(posVectors / boidsSeen) * boidAttractStrength\n                            + thisBoidDir * (1.0 - boidAttractStrength);\n\n                        thisBoidDir = \n                            normalize(dirVectors / boidsSeen) * boidAlignStrength\n                            + thisBoidDir * (1.0 - boidAlignStrength);\n\n                        if (spacingCount > 0.0) {\n                            thisBoidDir = normalize(spacingVectors / spacingCount) * 0.75\n                            + thisBoidDir * 0.25;\n                        }\n\n                        thisBoidDir = randomDir * boidRandomStrength + thisBoidDir * (1.0 - boidRandomStrength);\n                    }\n\n                    if (predatorsSeen > 0.0) {\n                        thisBoidDir =\n                            normalize(predatorVectors / predatorsSeen) * boidPredatorAvoidance\n                            + thisBoidDir * (1.0 - boidPredatorAvoidance);\n                    }\n\n                    if (predatorsSeen == 0.0 && boidsSeen == 0.0 && !mouseSeen) {\n                        thisBoidDir = randomDir;\n                    }\n                }\n\n                fragColor.xy = \n                    mod(\n                        (thisBoidPos + thisBoidDir * boidSpeed) / iResolution.xy,\n                        vec2(1.0)\n                    ) + vec2(1.0, clamp(predatorsSeen + (mouseSeen && !mouseAttract ? 1.0 : 0.0), 0.0, 1.0));\n                fragColor.zw = thisBoidDir;\n\n            }\n            else fragColor = vec4(fragColor.x + 3.0, fragColor.y, 1.0, 0.0);\n        }\n        \n        else {\n            fragColor -= vec4(0.0, 0.0, 0.025, 0.0);\n        }\n        \n        return;\n    }\n\n    // Predators\n    else if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount + predatorCount) {\n        \n        float boidsSeen = 0.0;\n        float predatorsSeen = 0.0;\n        \n        vec2 boidVectors = vec2(0.0);\n        vec2 predatorVectors = vec2(0.0);\n        \n        vec2 thisPredatorPos = fract(fragColor.xy) * iResolution.xy;\n        vec2 thisPredatorDir = fragColor.zw;\n        \n        float boidsEaten = max(floor(fragColor.y) * 0.01 - 0.01, 0.0);\n        \n        bool mouseSeen = false;\n        \n        for (int i=0; i<boidCount; i++) {\n            ivec2 coord = ivec2(int(mod(float(i), iResolution.x)), int(float(i) / iResolution.x));\n\n            vec4 boid = texelFetch(iChannel0, coord, 0);\n            vec2 boidPos = fract(boid.xy) * iResolution.xy;\n            float dist = distance(thisPredatorPos, boidPos);\n            \n            vec3 dp = loopDistPosition(thisPredatorPos, boidPos, dist, iResolution.xy);\n            boidPos = dp.xy;\n            dist = dp.z;\n\n            if (\n                dist < predatorSearchRange * clamp(floor(boidsEaten)*0.1, 1.0, 3.0) &&\n                boid.x < 3.0\n            ) {\n                boidsSeen++;\n                boidVectors += boidPos - thisPredatorPos;\n                if (iTime > predatorEatDelay && dist < predatorEatRange) {\n                    boidsEaten++;\n                }\n            }\n        }\n        \n        for (int i=0; i<predatorCount; i++) {\n            ivec2 coord = ivec2(int(mod(float(i+boidCount), iResolution.x)), int(float(i+boidCount) / iResolution.x));\n            if (coord != ivec2(fragCoord)) {\n                vec4 otherPredator = texelFetch(iChannel0, coord, 0);\n                vec2 otherPredatorPos = fract(otherPredator.xy) * iResolution.xy;\n                float dist = distance(thisPredatorPos, otherPredatorPos);\n                \n                vec3 dp = loopDistPosition(thisPredatorPos, otherPredatorPos, dist, iResolution.xy);\n                otherPredatorPos = dp.xy;\n                dist = dp.z;\n\n                if (dist < predatorSpacingDist * clamp(floor(boidsEaten)*0.1, 1.0, 3.0)) {\n                    predatorsSeen++;\n                    predatorVectors += thisPredatorPos - otherPredatorPos;\n                }\n            }\n        }\n        \n        if (iMouse.z > 0.0) {\n                float dist = distance(thisPredatorPos, mousePos);\n                if (dist < mouseSearchRange) mouseSeen = true;\n        }\n        \n        if (iFrame > 1) {\n        \n            vec2 randomDir = vec2(\n                    random(fragCoord + sin(iTime)) * 2.0 - 1.0,\n                    random(fragCoord + sin(iTime*0.5)) * 2.0 - 1.0\n                 );\n\n            if (boidsSeen > 0.0) {\n                thisPredatorDir = \n                    normalize(boidVectors / boidsSeen) * predatorAttractStrength\n                    + thisPredatorDir * (1.0 - predatorAttractStrength);\n\n                thisPredatorDir = randomDir * predatorRandomStrength + thisPredatorDir * (1.0 - predatorRandomStrength);\n            }\n            \n            if (mouseSeen) {\n                    thisPredatorDir = normalize(mouseAttract ? mousePos - thisPredatorPos : thisPredatorPos - mousePos) * mouseStrength\n                    + thisPredatorDir * (1.0 - mouseStrength);\n            }\n\n            if (predatorsSeen > 0.0) {\n                thisPredatorDir =\n                    normalize(predatorVectors / predatorsSeen) * 0.85\n                    + thisPredatorDir * 0.15;\n            }\n\n            if (predatorsSeen == 0.0 && boidsSeen == 0.0 && !mouseSeen) {\n                thisPredatorDir = randomDir;\n            }\n            \n        }\n        \n        fragColor.xy = \n            mod(\n                (thisPredatorPos + thisPredatorDir * (predatorSpeed - clamp(boidsEaten*0.05, 0.0, predatorSpeed*0.75))) / iResolution.xy,\n                vec2(1.0)\n            ) + vec2(2.0, floor(boidsEaten * 100.0));\n        fragColor.zw = thisPredatorDir;\n        \n        return;\n    }\n    \n    else discard;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    mouseAttract = (texelFetch(iChannel2, ivec2(32, 2), 0).x) > 0.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iFrame == 0) {\n        init(fragColor, fragCoord);\n    }\n    \n    else {\n        fragColor = texture(iChannel0, uv);\n        update(fragColor, fragCoord);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Change these parameters for different behavior\n#define boidCount 1024\n//#define showCount\n\n#define predatorCount 16\n\n#define boidSearchRange 60.0\n#define boidSpeed 6.0\n#define boidSpacingDist 16.0\n#define boidAttractStrength 0.4\n#define boidAlignStrength 0.6\n#define boidRandomStrength 0.01\n#define boidPredatorAvoidance 0.2\n\n#define predatorSearchRange 200.0\n#define predatorSpeed 1.25\n#define predatorAttractStrength 0.7\n#define predatorRandomStrength 0.01\n#define predatorSpacingDist 20.0\n#define predatorEatRange 10.0\n#define predatorEatDelay 3.0\n\n#define mouseStrength 0.99\n#define mouseSearchRange 600.0\n\n#define fade 0.92\n\nbool mouseAttract = false;\n\nfloat random(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n\ta += dot(a, a + 24.45);\n\treturn fract(a.x * a.y * a.z);\n}\n\nvec3 loopDistPosition(vec2 thisPos, vec2 otherPos, float dist, vec2 res) {\n    vec2 otherPos0 = otherPos - res;\n    vec2 otherPos1 = otherPos - vec2(0.0, res.y);\n    vec2 otherPos2 = otherPos + vec2(res.x, -res.y);\n    vec2 otherPos3 = otherPos - vec2(res.x, 0.0);\n    vec2 otherPos4 = otherPos + vec2(res.x, 0.0);\n    vec2 otherPos5 = otherPos - vec2(res.x, -res.y);\n    vec2 otherPos6 = otherPos + vec2(0.0, res.y);\n    vec2 otherPos7 = otherPos + res;\n\n    if (dist > distance(thisPos, otherPos0)) {\n        dist = distance(thisPos, otherPos0);\n        otherPos = otherPos0;\n    }\n    if (dist > distance(thisPos, otherPos1)) {\n        dist = distance(thisPos, otherPos1);\n        otherPos = otherPos1;\n    }\n    if (dist > distance(thisPos, otherPos2)) {\n        dist = distance(thisPos, otherPos2);\n        otherPos = otherPos2;\n    }\n    if (dist > distance(thisPos, otherPos3)) {\n        dist = distance(thisPos, otherPos3);\n        otherPos = otherPos3;\n    }\n    if (dist > distance(thisPos, otherPos4)) {\n        dist = distance(thisPos, otherPos4);\n        otherPos = otherPos4;\n    }\n    if (dist > distance(thisPos, otherPos5)) {\n        dist = distance(thisPos, otherPos5);\n        otherPos = otherPos5;\n    }\n    if (dist > distance(thisPos, otherPos6)) {\n        dist = distance(thisPos, otherPos6);\n        otherPos = otherPos6;\n    }\n    if (dist > distance(thisPos, otherPos7)) {\n        dist = distance(thisPos, otherPos7);\n        otherPos = otherPos7;\n    }\n    return vec3(otherPos, dist);\n}\n\n// Insertion sort from https://www.shadertoy.com/view/wlBBW1\nvoid insertion_sort(inout ivec4 idArray, inout vec4 distArray, int sortId, float sortDist){\t\n    if (any(equal(ivec4(sortId), idArray))) return;\n    if (sortDist < distArray[0]) idArray = ivec4(sortId, idArray.xyz), distArray = vec4(sortDist, distArray.xyz);\n    else if(sortDist < distArray[1]) idArray = ivec4(idArray.x, sortId, idArray.yz), distArray = vec4(distArray.x, sortDist, distArray.yz);\n    else if(sortDist < distArray[2]) idArray = ivec4(idArray.xy, sortId, idArray.z), distArray = vec4(distArray.xy, sortDist, distArray.z);\n    else if(sortDist < distArray[3]) idArray = ivec4(idArray.xyz, sortId), distArray = vec4(distArray.xyz, sortDist);\n    idArray = idArray.xyzw;\n    distArray = distArray.xyzw;\n}\n\n// Text utility from https://www.shadertoy.com/view/dsGXDt\n#define FONT_TEXTURE iChannel2\n#define CHAR_SPACING 0.5\n\n#define _dig(i) _ 48+int(i)\n\n#define makeStr1i(func_name) float func_name(vec2 u, int i, int j, int k, int l) { _print\n\n#define _end    ); return d; }\n\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n// Start\n#define _print float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _ ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).r * u.x * u.y;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"makeStr1i(printDynNum) _dig(i) _dig(j) _dig(k) _dig(l) _end \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel1, uv);\n    fragColor = col * (col.x + col.y + col.z > 0.2 ? fade : 1.0);\n    \n    // Check all boid positions and update counter\n    float boidsRemaining = 0.0;\n    for (int i=0; i<boidCount; i++) {\n        vec4 boid = texelFetch(\n            iChannel0, \n            ivec2(int(mod(float(i), iResolution.x)), int(float(i) / iResolution.x)), \n            0\n        );\n        vec2 p = fract(boid.xy) * iResolution.xy;\n        if (boid.x < 3.0) {\n            boidsRemaining++;\n            if (distance(p, fragCoord) < 3.0) {\n                fragColor = boid.y >= 1.0 ? \n                    vec4(0.0, 0.75 + cos(iTime)*0.25, 0.5 + cos(iTime*0.5)*0.25, 1.0) : \n                    vec4(0.0, 0.25 + cos(iTime*0.3)*0.25, 0.9 + cos(iTime*0.7)*0.1, 1.0);\n            }\n        }\n        else if (boid.z > 0.0) {\n            if (distance(p, fragCoord) < 3.0 * (2.0+boid.z)) {\n                fragColor = vec4(boid.z+0.5, boid.z+0.5, 0.0, 1.0);\n            }\n        }\n        else if (boid.z <= 0.0 && boid.z > -20.0 && col.x + col.y + col.z < 0.2) {\n            if (distance(p, fragCoord) < 3.0 * max((2.0+boid.z), 1.5)) {\n                fragColor = vec4(boid.z, boid.z, 0.0, 1.0);\n            }\n        }\n    }\n    \n    // Check all predator positions\n    for (int i=0; i<predatorCount; i++) {\n        vec4 predator = texelFetch(\n            iChannel0,\n            ivec2(int(mod(float(i+boidCount), iResolution.x)), int(float(i+boidCount) / iResolution.x)),\n            0\n        );\n        vec2 p = fract(predator.xy) * iResolution.xy;\n        if (distance(p, fragCoord) < 5.0 + min(floor(predator.y)*0.01, 20.0)) {\n            fragColor = vec4(0.9 + sin(iTime)*0.1, 0.0, 0.0 + sin(iTime*0.5)*0.25, 1.0);\n        }\n    }\n    \n#if defined showCount\n// Update counter\n    float number = printDynNum(\n        (fragCoord/iResolution.y)*10.0 - vec2(0.0, 9.0),\n        int(fract(boidsRemaining * 0.0001) * 10.0),\n        int(fract(boidsRemaining * 0.001) * 10.0),\n        int(fract(boidsRemaining * 0.01) * 10.0),\n        int(fract(boidsRemaining * 0.1) * 10.0)\n    );\n    \n    fragColor += vec4(number*0.2);\n#endif\n\n    // Buffer A debug\n    //fragColor = texture(iChannel0, uv*.1);\n}","name":"Buffer C","description":"","type":"buffer"}]}