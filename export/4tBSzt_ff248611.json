{"ver":"0.1","info":{"id":"4tBSzt","date":"1445705634","viewed":163,"name":"Raymarching test by Dan","username":"dancasas","description":"raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nvec3 transform(vec3 pt, vec3 translate, vec3 rot, vec3 scale) {\n    scale.x = 1.0/scale.x;\n    scale.y = 1.0/scale.y;\n    scale.z = 1.0/scale.z;\n    \n    mat3 invRot = mat3(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) ,\n                       cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z),\n                       -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z);\n    \n \tmat4 trans = mat4(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) , 0.0, \n                      cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z), 0.0, \n                      -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z, 0.0, \n                      (-invRot*translate).x, (-invRot*translate).y, (-invRot*translate).z, 1.0);\n    \n    vec4 newPt = vec4(pt, 1.0);\n    newPt = trans*newPt;\n    return vec3(newPt);\n                    \n}\n\nmat3 makeRotateX(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(1.0, c, -s,\n              0.0,  s, c,\n              0.0, 0.0, 1.0);\n}\nmat3 makeRotateY(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c,    0.0, s,\n              0.0,  1.0, 0.0,\n              -s,   0.0, c);\n}\nmat3 makeRotateZ(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c, -s, 0.0,\n              s,  c, 0.0,\n              0.0, 0.0, 1.0);\n}\n\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\nfloat sphereTranslated(vec3 pos, vec3 t, float radius)\n{\n    //float x = pow(abs(pos.x - t.x),2.0);\n    //float y = pow(abs(pos.y - t.y),2.0);\n    //float z = pow(abs(pos.z - t.z),2.0);\n\t\n    //return (sqrt(x+y+z) - radius);\n    //return sqrt(,pow(abs(pos.y - t.y)),2),pow(abs(pos.z - t.z)),2)); \n\n\n    mat4 m = mat4(vec4(1.0, 0.0, 0.0, t.x), \n                  vec4(0.0, 1.0, 0.0, t.y), \n                  vec4(0.0, 0.0, 1.0, t.z), \n                  vec4(0.0, 0.0, 0.0, 1.0));\n    vec3 q = vec4(m*vec4(pos,1.0)).xyz;\n    return sphere(q, radius);\n}\n\n\n\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\n\nfloat boxTransform(vec3 pos, vec3 size)\n{\n    //pos = transform(pos, -pos, vec3( 0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n   \n    pos = makeRotateY(2.0*iTime)*pos;\n    pos = makeRotateZ(iTime*2.0)*pos;\n    //pos = transform(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.5*iTime,1.0), vec3(1.0));\n    //pos = transform(os, vec3(-9.0, 0.0, 0.0), vec3( 1.0, 0.0, 0.0), vec3(3.0, 3.0, 3.0));\n    \n    //\n    return length(max(abs(pos) - size, 0.0));\n}\n\n\n              /*\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n\n\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n*/\n\nfloat distfunc(vec3 pos)\n{\n    float sphere1 = sphere(pos, 1.0);\n    float sphere2 = sphere(pos + vec3(0.0, 1.0, -1.0), 1.0);\n    \n    //float sphere3 = sphere(pos - lightPos, 0.2);\n    //return sdHexPrism(pos, vec2(0.4,0.4));\n    float min1 = min(sphere1, sphere1);\n    //float min2 = min(min1, sphere3);\n    \n    return min1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    const float EPSILON  = 0.0001;\n    \n    vec2 eps = vec2(0.0, EPSILON);\n    \n\treturn normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n    distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n}\n\nvec3 computeRayDir(vec3 origin, vec3 target)\n{\n    vec3 upDirection   = vec3(0.0, 1.0, 0.0);\n    \n    vec3 localDir      = normalize(target - origin);\n    vec3 localRight    = normalize(cross(upDirection, origin));\n    vec3 localUp       = cross(localDir, localRight);\n    \n    // Screen range from -1 to 1\n    vec2 screenPos     = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x       *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir        = normalize(localRight * screenPos.x + localUp * screenPos.y + localDir* 4.0);\n \n    \n    return rayDir;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //vec3 cameraOrigin  = vec3(2.0*cos(iTime*1.0), 2.0*cos(iTime*1.0), 2.0);\n    vec3 cameraOrigin  = vec3(0.0, 0.0, 70.0);\n    vec3 lightOrigin   = vec3(22.0*cos(iTime*1.0), 12.0*sin(iTime*1.0), 20.0);\n    \n    //vec3 cameraTarget  = vec3(10.0*sin(iTime*1.0), 0.0, 0.0);\n    vec3 cameraTarget  = vec3(0.0,0.0, 0.0);\n    \n   \n    vec2 screenPos     = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    \n    \n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir      = computeRayDir(cameraOrigin, cameraTarget);//normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    vec3 rayDir4     = computeRayDir(cameraOrigin, vec3(5.0, 0.0, 0.0)); \n    \n    vec3 lightRayDir = computeRayDir(lightOrigin, cameraTarget);\n    \n    const int MAX_ITER   = 100;\n    const float MAX_DIST = 90.0;\n    const float EPSILON  = 0.0001;\n    \n    float totalDist      = 0.0;\n    vec3 pos             = cameraOrigin;\n    float dist           = EPSILON;\n    int closest;\n    \n    for(int i=0; i< MAX_ITER; i++)\n    {\n        // Either we've hit the object or hit nothing at all, either way we should break out of the loop\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break; // If you use windows and the shader isn't working properly, change this to continue;\n\n        float dist1   = sphere(pos, 6.0);\n        float dist2\t  = sphere( pos + vec3(-7.0, 0.0, -1.0), 3.5);\n       // vec3 posLight = sqrt(pow(pos.x - lightOrigin.x),2),pow(pos.x - lightOrigin.x),2),pow(pos.x - lightOrigin.x),2),); \n        //float dist3   = sphereTranslated(pos, lightOrigin, 0.5);\n        float dist3   = sphere(pos - lightOrigin, 1.5);\n        //float dist4   = sphere(pos + vec3(6.0, 0.0, -2.0), 3.5);\n        float dist4   = boxTransform(pos - vec3(-12.0, 0.0, 0.0), vec3(4.0, 4.0, 4.0));\n        \n        \n        dist    = dist1;\n        closest = 1;\n         \n        if(dist2 < dist)\n        {\n            dist    = dist2;\n        \tclosest = 2;\n        }\n        \n        if(dist3 < dist)\n        {\n            dist       = dist3;\n        \tclosest    = 3;\n            }\n\n        if(dist4 < dist)\n        {\n            dist       = dist4;\n            closest    = 4;\n            //lightRayDir = computeRayDir(vec3(2.0, 0.0, 0.0),  vec3(3.0, 0.0, 0.0));\n            lightRayDir = computeRayDir(lightOrigin , cameraTarget );\n            }\n\n        totalDist += dist; \n     \tpos += dist * rayDir;\n    }\n    \n    \n    vec3 normal    = computeNormal(pos);   \n    float diffuse  = max(0.0, dot(-lightRayDir, normal));\n    float specular = pow(diffuse, 32.0);\n    \n    vec3 color;\n    if(totalDist > MAX_DIST)\n    {\n    \tcolor = vec3(0.3, 0.3, 0.4);\n    }\n    else\n    { \n        color = vec3(0.5,0.1, 0.4);\n        \n        if(closest == 1)\n        {\n            color = vec3(0.0,(diffuse + specular)*0.5, 0.0); \n        }\n        if(closest == 2)\n        {\n            specular = pow(diffuse, 128.0);\n            color = vec3((diffuse + specular), 0.0, (diffuse*0.5 + specular));\n        }\n        if(closest == 3)\n        {\n            color = vec3(1.0, 0.5, 0.0);\n        }\n        if(closest ==4)\n        {\n            float specular = pow(diffuse, 2.0);\n            color = vec3((diffuse + specular)*0.3, (diffuse + specular)*0.2, (diffuse + specular)*0.5);\n        }\n    }\n    \n    //fragColor = vec4(pos.z, pos.z, pos.z, 1.0);\n    fragColor = vec4(color, 1.0);\n    \n}","name":"","description":"","type":"image"}]}