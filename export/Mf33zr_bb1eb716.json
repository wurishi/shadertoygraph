{"ver":"0.1","info":{"id":"Mf33zr","date":"1711304653","viewed":178,"name":"Magic Night","username":"Hyeve","description":"MAKE SURE TO START THE MUSIC!!!\nPause the shader, hit the restart button (next to pause), then unpause.\n\nCreated for a MAJ7 cover ring event. See their full release here: https://www.youtube.com/watch?v=X-3qJXWv3Rw","likes":9,"published":1,"flags":96,"usePreview":0,"tags":["3d","raymarching","transparency","reactive","music","audio","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 CHROMA_OFFSET = vec4(0.0);\n\nvec4 read(vec2 uv) {\n    float r = texture(iChannel0, uv + CHROMA_OFFSET.xy).x;\n    float g = texture(iChannel0, uv).y;\n    float b = texture(iChannel0, uv + CHROMA_OFFSET.zw).z;\n    return vec4(r, g, b, 1.0);\n}\n\nvec4 fxaa(vec2 frag) {\n    //Manually minified FXAA antialiasing\n    \n    const float CONTRAST_THRESHOLD = 0.05;\n    const float RELATIVE_CONTRAST_THRESHOLD = 0.5;\n    const float OFFSETS[10] = float[10]( 1., 1., 1., 1.5, 2., 2., 2., 3., 4., 5. );\n    \n    #define re(x) read((x)/iResolution.xy)\n    #define lu(x) (x.r*.2126+x.g*.7152+x.b*.0722)\n    #define rl(x) lu(re((x)))\n    #define r(x, y) rl(frag+vec2(x,y))\n    \n    float M = r(0,0),N =r(0,1),NE=r(1,1),E =r(1,0),SE=r(1,-1),S =r(0,-1),SW=r(-1,-1),W =r(-1,0),NW=r(-1,1),\n    LC=min(N,min(E,min(S,min(W,M)))),HC=max(N, max(E, max(S, max(W, M)))),CT=HC-LC;\n    if(CT<max(CONTRAST_THRESHOLD,RELATIVE_CONTRAST_THRESHOLD*HC)) return re(frag);\n    \n    float LA = smoothstep(0.,1.,clamp(0.,1., abs((2.*(N+E+S+W)+NE+NW+SE+SW)*(1./12.)-M)/CT));\n\tbool IH = abs(N+S-2.*M)*2.+abs(NE+SE-2.*E)+abs(NW+SW-2.*W)>abs(E+W-2.*M)*2.+abs(NE+NW-2.*N)+abs(SE+SW-2.*S);\n    \n    float PL=IH?N:E,NL=IH?S:W,PG=abs(PL-M),NG=abs(NL-M),DR=1.,GR,OL;\n\n    OL=PL;GR=PG;\n\tif (PG<NG) {DR=-1.0;OL=NL;GR=NG;}\n\n    vec2 EF=frag,ES=vec2(0,1);EF.x+=.5*DR;\n    if(IH){EF.y+=.5*DR;ES=vec2(1,0);}\n    \n    float EL=(M+OL)*.5,GT=GR*.25;\n\tvec2 PF=EF+ES,NF=EF-ES,FO=vec2(0.);\n\tfloat PLD=rl(PF)-EL,NLD=rl(NF)-EL;\n\tbool PE=abs(PLD)>=GT,NED=abs(NLD)>=GT;\n    int i;\n    for(i=0;i<10&&!PE;i++){PF+=ES*OFFSETS[i];PLD=rl(PF)-EL;PE=abs(PLD)>=GT;}\n    for(i=0;i<10&&!NED;i++){NF-=ES*OFFSETS[i];NLD=rl(NF)-EL;NED=abs(NLD)>=GT;}\n    \n    float PD=PF.y-frag.y,ND=frag.y-NF.y,MD,EB=0.,BL;\n\tif(IH){PD=PF.x-frag.x;ND=frag.x-NF.x;}\n    MD=min(PD,ND);\n    bool DS=PD<=ND?PLD>=0.:NLD>=0.;\n\tif(DS!=(M-EL>=0.))EB=0.5-MD/(PD+ND);\n    BL=max(LA*LA,EB)*DR;\n\n\tif(IH)FO.y+=BL;\n\telse FO.x+=BL;\n    \n    return re(frag+FO);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    CHROMA_OFFSET = vec4(-1, -1, -1, 1) * pow(length(uv * 0.4), 5.);\n    fragColor = fxaa(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"lscGDj","filepath":"https://soundcloud.com/davidkhai/tatsuro-yamashita-magic-ways?in=enzo-lee-divito/sets/city-pop","previewfilepath":"https://soundcloud.com/davidkhai/tatsuro-yamashita-magic-ways?in=enzo-lee-divito/sets/city-pop","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float AUDIO_RATE = 22050.0;\nconst float AUDIO_VOL = -2.5;\n\nvec3 COL_A = vec3(5.); //Kinda needs to be >1! (Stars/Snow)\nvec3 COL_B = vec3(0.7, 0.9, 1.); //Ground A\nvec3 COL_C = vec3(0.6, 0.5, 0.7); //Ground B\nvec3 COL_D = vec3(1.5, 0., 0.3); //Spectrum top\nvec3 COL_E = vec3(0.5, 0., 0.5); //Spectrum glow\nvec3 COL_F = vec3(0.1, 0.1, 0.4); //Sky\n\n\nvec2 spectrumAt(float x) {\n  float idx = 55.0 / AUDIO_RATE * 0.5 * pow(2.0, x);\n\n  if (x < 0. || idx > 1.0) return vec2(0);\n  \n  float fft = texture(iChannel0, vec2(idx, 0)).x;\n  \n  fft *= 2.0 * log(1.0 + x);\n  fft += AUDIO_VOL;\n  fft *= 1.0 + idx;\n  \n  return vec2(fft); //Shadertoy only provides mono audio :(\n}\n\n\n\nfloat TIME; //Global time, usually modulo'd to loop ever few minutes\nbool LIGHTING_PASS = false; //True while doing lighting effects\n\n//--------- GENERAL CONSTANTS ---------\nconst float FPS_MULTIPLIER = 1.0; //Decrease this if you need the performance\nconst float SPEED_MULTIPLIER = 1.0; //Mess with how fast the shader time runs!\n                                    \nconst float MAX_SCENE_DEPTH = 128.; //Minor performance impact\nconst int MAX_SCENE_STEPS = 256; //Medium performance impact\nconst int MAX_SURFACES = 15; //Major performance impact with transparent/reflective surfaces\nconst float MAX_SHADOW_DIST = 64.; //Minor performance impact if shadows are used\nconst int MAX_SHADOW_STEPS = 64; //Medium performance impact if shadows are used\nconst float HIT_DIST = 1e-4; //Minor-Medium performace impact (dependent on geometry)\n\nconst float OFFSET_DIST = HIT_DIST * 2.; //For transparent object surfaces and normal calculations\nconst float SKIP_DIST = OFFSET_DIST * 3.; //For rays passing through transparent surfaces\n\nconst float VIGNETTE_STRENGTH = 0.8;\nconst float VIGNETTE_POWER = 5.;\n\nconst float GAMMA = 1.;\n//--------- ----------------- ---------\n\n\n\n//--------- LIGHTING PARAMATERS ---------\nvec3 LIGHT_POS = vec3(-200, 200, -200);\nvec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat LIGHT_BRIGHTNESS = 1.0;\n\nvec3 AMBIENT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat AMBIENT_BRIGHTNESS = 0.3;\n\nfloat FOG_ONSET = 20.;\nfloat FOG_SMOOTH = 100.;\nfloat FOG_POWER = 1.;\n\nfloat AO_DIST = 12.;\nfloat AO_POWER = 0.2;\n\nfloat SHADOW_SOFTNESS = 0.05;\nfloat SHADOW_STRENGTH = 0.0;\n\nfloat SUBSURF_DIST = 4.;\nfloat SUBSURF_BRIGHTNESS = 0.9;\n\nfloat UMBRA_POINT = 0.5;\nfloat UMBRA_CONTRAST = 0.5;\n\nint SURFACE_SKIPS = 1; //Skips rendering surfaces after passing into a transparent object - fakes backface culling.\n//--------- --------- --------- ---------\n\n\n\n//--------- MISC PARAMETERS ---------\nvec4 TONEMAP_VALUES = vec4(1., 1., 0., 999.); //Contrast, brightness, lift, quantization steps.\nvec4 TONEMAP_HUESAT = vec4(1.5, 0.5, 1.5, 2.); //Controls hue and sat shifting based on brightness.\n\nvec3 GLOW = vec3(0.); //For raymarching-accumulated fake glow.\n//--------- --------------- ---------\n\n\n\n//--------- SURFACE PARAMATERS ---------\nvec3 COLOR = vec3(0.5, 1., 1.);\nfloat GLOSS = 0.8;\nfloat SPECULAR = 0.5;\nfloat OPACITY = 1.0; //Opacity must be < 1 for refraction or reflection to have any effect.\nfloat REFRACTION = 1.03; //Refraction < 0 results in reflection instead.\nfloat BACKGROUND_REFLECTION = 0.0; //Blurry reflections of background only\nvec3 NORMAL_ROTATIONS = vec3(0.0); //Normal mapping effect\nfloat MATERIAL_ID = -1.0;\n//--------- ------------------ ---------\n\n\n\n//--------- JNEEN SPIRAL STUFF --------- (i golfed it a bit sorrrri)\nvec2 spiralCoordinates(vec2 p) {\n    vec2 polar = vec2(length(p), atan(p.y, p.x)/6.286+.5);\n    float spiralRadius = floor(polar.x - polar.y) + polar.y;\n    float spiralDist = polar.x - spiralRadius;\n    return vec2(spiralDist, spiralRadius);\n}\n\nfloat adjustDist(float dist) {\n  dist -= .02;\n  if (dist < 0.) dist = -1.;\n  dist += .02;\n  return dist;\n}\n\nfloat positiveSpiralDist(vec2 spiral, float i) {\n  float relative = spiral.x + 2.*i;\n  return max(relative - adjustDist(spectrumAt(spiral.y-i).x), -relative);\n}\n\nfloat negativeSpiralDist(vec2 spiral, float i) {\n  float relative = -spiral.x + 2.*i;\n  return max(relative - adjustDist(spectrumAt(spiral.y+i).y), -relative);\n}\n\nfloat zeroSpiralDist(vec2 spiral) {\n  vec2 audio = spectrumAt(spiral.y);\n  float dist = spiral.x;\n  float outer = dist - adjustDist(audio.x);\n  float inner = -dist - adjustDist(audio.y);\n  if ((dist >= 0. && outer < 0.) || (dist < 0. && inner < 0.)) return max(outer, inner);\n  return dist >= 0. ? outer : inner;\n}\n\nfloat spectrumSpiral(vec2 p) {\n    vec2 spiral = spiralCoordinates(p * 20./(1.+3.*0.));\n    spiral.x *= 2.;\n    spiral.x -= 1.;\n    float d = zeroSpiralDist(spiral);\n    d = min(d, positiveSpiralDist(spiral, 1.));\n    d = min(d, positiveSpiralDist(spiral, 2.));\n    d = min(d, positiveSpiralDist(spiral, 3.));\n    d = min(d, positiveSpiralDist(spiral, 4.));\n    d = min(d, negativeSpiralDist(spiral, 1.));\n    d = min(d, negativeSpiralDist(spiral, 2.));\n    d = min(d, negativeSpiralDist(spiral, 3.));\n    d = min(d, negativeSpiralDist(spiral, 4.));\n    return d;\n}\n\nfloat renderSpiral(float dist) {\n  float o = step(0., -dist);\n  return clamp(mix(o, o * (1.-dist), .1),0.,1.);\n}\n\n\n\n//--------- GENERAL FUNCTIONS ---------\n#define angle(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define quantize(value, steps) (floor((value)*(steps))/(steps))\n\nfloat hash(float value) {\n    return fract(sin((value) * 12.9898) * 43758.5453123);\n}\n\nfloat hash(vec2 value) {\n    return fract(sin(dot(value,vec2(127.1,311.7)))*43758.545);\n}\n\nfloat hash(vec3 value) {\n    return hash(value.xz*value.zy);\n}\n\nvec2 centered_uv(vec2 frag, vec2 res) {\n    return vec2(frag.xy - .5 * res.xy) / res.y;\n}\n\nfloat noise(float value) {\n    float i = floor(value), f = fract(value);\n    return mix(hash(i - 0.5), hash(i + 0.5), f);\n}\n\nfloat noise(vec2 value) {\n    vec2 i = floor(value), f = fract(value);\n  \n    float S = 0.098157123;\n  \n    float tl = hash(i + vec2(-0.5, -0.5) + S);\n    float tr = hash(i + vec2(0.5, -0.5) + S);\n    float bl = hash(i + vec2(-0.5, 0.5) + S);\n    float br = hash(i + vec2(0.5, 0.5) + S);\n  \n    float t = mix(tl, tr, 0.5);\n    float b = mix(bl, br, 0.5);\n    float v = mix(t, b, 0.5);\n  \n    return hash(v);\n}\n\nvec3 rotate(vec3 a, vec3 r) {\n    a.zy *= angle(r.x);\n    a.xz *= angle(r.y);\n    a.yx *= angle(r.z);\n    return a;\n}\n\n\nvec3 rgb_to_hsv(vec3 col) {\n    vec4 k = vec4(0., -1./3., 2./3., -1.),\n    p = mix(vec4(col.bg, k.wz), vec4(col.gb, k.xy), step(col.b, col.g)),\n    q = mix(vec4(p.xyw, col.r), vec4(col.r, p.yzx), step(p.x, col.r));\n    \n    float d = q.x - min(q.w, q.y);\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6. * d)), d / (q.x), q.x);\n}\n\n\nvec3 hsv_to_rgb(vec3 col) {\n    vec4 k = vec4(1., 2./3., 1./3., 3.);\n    vec3 p = abs(fract(col.xxx + k.xyz) * 6. - k.www);\n    return col.z * mix(k.xxx, clamp(p - k.xxx, 0., 1.), col.y);\n}\n\nvec3 recolor(vec3 base_color, float diffuse, vec3 light_color, vec4 hs_params, vec4 v_params) {\n\n  vec3 base_hsv = rgb_to_hsv(base_color);\n  vec3 tinted_hsv = rgb_to_hsv(base_color * light_color);\n  \n  \n  float value = quantize(pow(max(diffuse * base_hsv.z  +v_params.z, 0.),v_params.x)*v_params.y,v_params.w);\n \n  \n  float hueShiftLow = pow(max(0.5 - value * 0.5,0.), hs_params.x);\n  float hueShiftHigh = -pow(max(value * 0.5 - 0.5, 0.), hs_params.x);\n  float hueShiftDir = mix(-1., mix(1., -1., smoothstep(0.69, 0.75, base_hsv.x)), smoothstep(0.19, 0.24, base_hsv.x));\n  float hueShift = (hueShiftLow + hueShiftHigh) * hs_params.y * hueShiftDir;\n  \n  \n  \n  float hue = tinted_hsv.x + hueShift;\n\n  \n  float satShift = pow(max(0.5 - value * 0.5, 0.), hs_params.z) * hs_params.w;\n  float sat = tinted_hsv.y + satShift * step(1e-3, tinted_hsv.y);\n  \n\n  return hsv_to_rgb(vec3(hue,sat,value));\n  \n}\n\nfloat sdf_box(vec3 pos, vec3 size) {\n    vec3 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n\n\n//--------- SCENE CONTROL FUNCTIONS ---------\nvec4 scene2d(vec2 uv) {\n    float spir = spectrumSpiral(uv-vec2(0.,0.001));\n    vec4 col = vec4(COL_A, 0.8) * renderSpiral(spir-.05);\n    col = mix(col, vec4(COL_A, 1.), renderSpiral(spectrumSpiral(uv)));\n    \n    vec2 vn1 = vec2(cos(TIME * 0.5), TIME);\n    vec2 vn2 = vec2(sin(TIME * 0.5), TIME);\n    vec2 vn3 = vec2(cos(TIME * 0.5), TIME);\n    \n    float sn1 = noise(uv.xy * 20. + vn1 + 3.189273);\n    float sn2 = noise(uv.xy * 30. + vn2 + 1.213807);\n    float sn3 = noise(uv.xy * 40. + vn3 + 7.987615);\n    \n    vec2 a1 = max(spectrumAt(pow(sn1, 0.2) * 2.3) + 0.5, 0.);\n    vec2 g1 = mod(uv.xy * 20. + vn1, 1.) - 0.5;\n    float s1 = step(0.3, 1.0 - length(g1) * 3. + a1.y * 0.2);\n    vec2 a2 = max(spectrumAt(2.3 + sn2 * 2.3) + 0.5, 0.);\n    vec2 g2 = mod(uv.xy * 30. + vn2, 1.) - 0.5;\n    float s2 = step(0.3, 1.0 - length(g2) * 3. + a2.y * 0.2);\n    vec2 a3 = max(spectrumAt(6.6 + pow(sn3, 1.2) * 2.3) + 0.5, 0.);\n    vec2 g3 = mod(uv.xy * 40. + vn3, 1.) - 0.5;\n    float s3 = step(0.3, 1.0 - length(g3) * 3. + a3.y * 0.2);\n    float starfield = (s1 * step(0.8, sn1)) + (s2 * step(0.8, sn2)) + (s3 * step(0.8, sn3));\n    \n    starfield *= 1.0 - smoothstep(0.1, 0.3, length(uv));\n    starfield *= smoothstep(-0.2, 0., uv.y);\n    \n    return mix(col, vec4(COL_A, 1.), starfield);\n}\n\n\nfloat scene(vec3 pos)\n{\t\t   \n\n    float ground = pos.y + 2.5 - pow(abs(pos.x*0.07), 2.);\n    float xm = cos(pos.x * 0.2 + TIME * 0.1);\n    float zm = sin(pos.z * 0.1 + xm * 0.5 + TIME * 0.1);\n    vec3 ground_nmap = vec3(zm * 0.3, 0., 0.);\n    float colpatch = cos(pos.x * 0.1 - TIME * 0.1 + sin(pos.z * 0.05)) * 0.5 + 0.5;\n    \n    float scene_dist = ground;\n    vec3 rpos = pos;\n    pos = rotate(pos, vec3(0., TIME * 0.05, 0.));\n    \n    float glass = length(pos) - 5.;\n\n    pos.xz = abs(pos.xz) - 30.;\n\n    for(float i = 0.; i < 3.; i++) {\n        pos.x = abs(pos.x) - 10.;\n        pos.z = abs(pos.z) - 5.;\n        pos = rotate(pos, vec3(0., i + 15., 0.));\n        glass = min(glass, sdf_box(pos + vec3(0., 1, 0.), vec3(2., 15. - i * 5., 2.)) - hash(i));\n    }\n    \n    glass = max(glass, -sdf_box(rpos + vec3(0.,0., 20.), vec3(2., 100., 2.)));\n    \n    if(!LIGHTING_PASS) {\n        COLOR = mix(COL_B, COL_C, colpatch);\n        NORMAL_ROTATIONS = ground_nmap;\n        OPACITY = 1.;\n        if(glass < ground) OPACITY = 0.01;\n    }\n\n    scene_dist = min(scene_dist, glass);\n    \n    if(OPACITY < 1.) scene_dist = abs(scene_dist) - OFFSET_DIST;\n\n\treturn scene_dist;\n}\n\nvec3 background(vec3 dir, float blur) {\n    float y = -dir.y;\n    vec2 aud = max(spectrumAt(pow(abs(dir.x) + 0.01, 0.2) * 8.) + 1., 0.);\n    \n    y += pow(abs(dir.x) * 1., 2.5);\n    float yal = y;\n    y += (dir.x > 0. ? aud.y : aud.x) * 0.1;\n    \n    \n    float vis = step(0., y);\n    vec3 viscol = mix(COL_D, COL_C, (yal + 0.1) * 5.) * vis * 2.;\n    \n    vec2 vn1 = vec2(TIME, cos(TIME * 0.2));\n    vec2 vn2 = vec2(TIME, sin(TIME * 0.2));\n    vec2 vn3 = vec2(TIME, cos(TIME * 0.1));\n    \n    float sn1 = noise(dir.xy * 20. + vn1 + 3.189273);\n    float sn2 = noise(dir.xy * 30. + vn2 + 1.213807);\n    float sn3 = noise(dir.xy * 40. + vn3 + 7.987615);\n    \n    vec2 a1 = max(spectrumAt(pow(sn1, 0.2) * 2.3) + 0.5, 0.);\n    vec2 g1 = mod(dir.xy * 20. + vn1, 1.) - 0.5;\n    float s1 = step(0.7, 1.0 - length(g1) * 3. + a1.x * 0.3);\n    \n    vec2 a2 = max(spectrumAt(2.3 + sn2 * 2.3) + 0.5, 0.);\n    vec2 g2 = mod(dir.xy * 30. + vn2, 1.) - 0.5;\n    float s2 = step(0.7, 1.0 - length(g2) * 3. + a2.x * 0.3);\n    \n    vec2 a3 = max(spectrumAt(6.6 + pow(sn3, 1.2) * 2.3) + 0.5, 0.);\n    vec2 g3 = mod(dir.xy * 40. + vn3, 1.) - 0.5;\n    float s3 = step(0.7, 1.0 - length(g3) * 3. + a3.x * 0.3);\n    \n    float starfield = (s1 * step(0.9, sn1)) + (s2 * step(0.9, sn2)) + (s3 * step(0.9, sn3));\n    vec3 base = COL_F;\n    \n    if(blur <= 0.) {\n        base = mix(base, COL_E, pow(max(y * step(y, 0.2) * 10. + 1.5, 0.), 2.));\n        base = mix(base, viscol, vis);\n    }\n    vec3 starbg = mix(base, COL_A, starfield);\n   \n    return starbg;\n}\n\nvec3 camera_path() {\n    return vec3(0, 1, -20);\n}\n\nvec3 camera_look(vec2 uv) {\n    return normalize(vec3(uv + vec2(0., -0.05), 1));\n}\n\nvec2 uv(vec2 frag, vec2 res) {\n    return centered_uv(frag, res);\n}\n//--------- ----------------------- ---------\n\n\n\n\n//--------- RENDERING FUNCTIONS ---------\nvec2 raymarch(vec3 ray_origin, vec3 ray_dir, float surf_dist, float max_dist, int max_steps) {\n    float current_dist = 0.;\n    float min_dist = max_dist;\n    \n    for(int i = 0; i < max_steps; i++) {\n        float scene_dist = scene(ray_origin + ray_dir * current_dist);\n        current_dist += scene_dist;\n\n        if(scene_dist < min_dist && current_dist < max_dist) min_dist = scene_dist;\n        if(scene_dist < surf_dist || scene_dist > max_dist) break;\n    }\n\n    return vec2(current_dist, min_dist);\n}\n  \nvec4 calc_lighting(vec3 hit_pos, vec3 normal, vec3 mapped_normal, vec3 ray_dir, float total_dist)\n{\n    vec3 background_col = background(ray_dir, 0.0);\n    \n    if(total_dist > MAX_SCENE_DEPTH) {\n        vec3 result = background_col + GLOW;\n        return vec4(result, 1.);\n    }\n  \n    vec3 light_dir = normalize(LIGHT_POS - hit_pos);\n    vec3 reflection_dir = reflect(ray_dir, mapped_normal);\n\n    float diffuse = dot(mapped_normal, light_dir);\n    if(diffuse > 0.) diffuse = UMBRA_POINT + pow(diffuse, 1.0 - UMBRA_CONTRAST) * (1. - UMBRA_POINT);\n    else diffuse = UMBRA_POINT - pow(abs(diffuse), 1.0 + UMBRA_CONTRAST) * UMBRA_POINT;\n    diffuse = max(diffuse * LIGHT_BRIGHTNESS, AMBIENT_BRIGHTNESS);\n    \n    vec3 diffuse_color = COLOR;\n    vec3 light_color = mix(AMBIENT_COLOR, LIGHT_COLOR, diffuse);\n   \n    float reflected_diffuse = dot(reflection_dir, light_dir) * 0.5 + 0.5;\n    diffuse += pow(reflected_diffuse,  1.0 + SPECULAR * 50.) * SPECULAR; \n\n    vec3 background_reflection = background(reflection_dir, 1.0 - BACKGROUND_REFLECTION);\n    diffuse_color = mix(diffuse_color, background_reflection * COLOR, BACKGROUND_REFLECTION);\n    \n    float glossiness = (dot(ray_dir, mapped_normal) * 0.5 + 0.5) * GLOSS;\n    vec3 gloss_color = background(reflection_dir, 1.0 - glossiness) * 2.0;\n    diffuse_color = mix(diffuse_color, gloss_color, glossiness);\n    \n\n    //does not work (properly) on transparent objects\n    if(SUBSURF_BRIGHTNESS > 0.) {\n        float subsurf_level = pow(max(scene(hit_pos + light_dir * SUBSURF_DIST) / SUBSURF_DIST, 0.), 1.5);\n        diffuse = max(diffuse, subsurf_level * SUBSURF_BRIGHTNESS);\n    }\n\n\n    if(AO_POWER > 0.) {\n        float occlusion = raymarch(hit_pos + normal * 0.005, normal, 1e-3, AO_DIST, 12).x;            \n        diffuse *= pow(clamp(occlusion / AO_DIST, 1e-5, 1.), AO_POWER);\n    }\n\n    if(SHADOW_STRENGTH > 0.) {\n       float min_dist = raymarch(hit_pos + normal * SHADOW_SOFTNESS, light_dir, 1e-3, MAX_SHADOW_DIST, MAX_SHADOW_STEPS).y;\n       float occlusion = clamp(min_dist / SHADOW_SOFTNESS, 0.0, 1.);\n       diffuse *= occlusion * SHADOW_STRENGTH + (1.0 - SHADOW_STRENGTH);\n    }\n    \n\n    vec3 result = recolor(diffuse_color, diffuse, light_color, TONEMAP_HUESAT, TONEMAP_VALUES);\n\n    result += GLOW;\n    result *= max(max(result.r, max(result.g, result.b)), 1.);\n    \n    float fog = pow(min(max(total_dist - FOG_ONSET, 0.0) * (1.0 / FOG_SMOOTH), 1.0), FOG_POWER);\n    result = mix(result, background_col, fog); \n    \n    return vec4(result, OPACITY);\n}\n\nvec3 calc_normal(vec3 pos) {\n    mat3 k = mat3(pos, pos, pos) - mat3(OFFSET_DIST);\n    return normalize(scene(pos) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec4 render(vec2 frag, vec2 res, float real_time)\n{\n    TIME = mod(real_time, 300.);\n    \n    vec2 uv = uv(frag, res);\n    vec3 ray_origin = camera_path();\n    vec3 ray_dir = camera_look(uv);\n    \n    int skip_count = 0;\n    float total_dist = 0.;\n    vec4 final_color = vec4(0);\n    \n    for(int i = 0; i < MAX_SURFACES; i++)\n    {\n        float dist = raymarch(ray_origin, ray_dir, HIT_DIST, MAX_SCENE_DEPTH, MAX_SCENE_STEPS).x;\n        vec3 hit_pos = ray_origin + ray_dir * dist;\n        total_dist += dist;\n \n        \n        vec3 normal = calc_normal(hit_pos);\n        \n        vec3 mapped_normal = rotate(normal, NORMAL_ROTATIONS);\n        mapped_normal = dot(mapped_normal, -ray_dir) > 0. ? mapped_normal : reflect(mapped_normal, ray_dir);\n        \n        LIGHTING_PASS = true;\n        vec4 color = calc_lighting(hit_pos, normal, mapped_normal, ray_dir, total_dist);\n        LIGHTING_PASS = false;\n        \n        float refraction = i % 2 == 0 ? 1. / REFRACTION : REFRACTION;\n        vec3 new_ray = refract(ray_dir, mapped_normal, refraction);\n        if(REFRACTION < 0. || length(new_ray) == 0.) new_ray = reflect(ray_dir, mapped_normal);\n        \n        ray_origin = hit_pos - normal * (REFRACTION < 0. ? -SKIP_DIST : SKIP_DIST);\n        ray_dir = new_ray;\n    \n\t  \tif(skip_count < 1) final_color += vec4(color.rgb * color.a, color.a) * (1. - final_color.a);\n\t  \tif(final_color.a >= 1.) break;\n        \n        skip_count = skip_count == 0 ? REFRACTION < 0. ? 0 : SURFACE_SKIPS : skip_count - 1;\n    }\n    \n    \n    final_color /= final_color.a; //Fix any < 1. alphas\n\t\n    vec4 color2d = scene2d(uv);\n    final_color.rgb = mix(final_color.rgb, color2d.rgb, color2d.a);\n    \n    if(VIGNETTE_STRENGTH > 0.) final_color *= 1. - pow(length(uv), VIGNETTE_POWER) * VIGNETTE_STRENGTH;\n    \n    vec3 color = clamp(pow(final_color, vec4(1.0 / GAMMA)).rgb, vec3(5e-2), vec3(3.95));\n    \n    \n    return mix(vec4(0.), vec4(color, 1.0), min(TIME * 0.2, 1.));\n}\n//--------- ------------------- ---------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(float(iFrame), 1.0 / FPS_MULTIPLIER) < 1. || iFrame < 5) {\n        vec4 data = render(fragCoord.xy, iResolution.xy, iTime * SPEED_MULTIPLIER);\n        fragColor = data;\n    }   \n    else fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"}]}