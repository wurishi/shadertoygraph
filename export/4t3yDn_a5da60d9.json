{"ver":"0.1","info":{"id":"4t3yDn","date":"1533569309","viewed":1073,"name":"Orbit Noise","username":"nimitz","description":"Demonstration of \"Orbit noise\", as far as I know a new type of \"basic\" noise with a somewhat simple generation technique. In both 2D and 3D variants","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","worley","orbit","cell","technique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Orbit Noise\n//by nimitz 2018 (twitter: @stormoid)\n\n/*\n\tThis began while I was looking for ways to render high quality noise for\n\toffline noise pregeneration. I figured one of the main limitation with the\n\tstandard noise algorithm was the rigid grid, which inevitably ends up creating\n\tlinear artifacts in the produced noise.\n\n\tSo a natural way of avoiding this issue is to let the underlying grid move\n\tsomewhat freely. I started with experiments of moving cells on a grid and\n\trendering them additively, with some extra code to improve color distribution.\n\t(I'll share those experimental noises here on shadertoy soon). Then I added\n\tan extra layer of variation by making the cells also have brightness values.\n\tThis produced ok noise, but the underlying patterns were those of value noise,\n\twhich is somewhat low quality.\n\n\tSo to increase the quality, I instead used using two separate 2d vectors per cell,\n\tone for the cell displacement and the second to generate a (random) brightness gradient,\n\tthis ends up creating noise that is pretty much gradient/coherent/perlin while the\n\tcell displacement is zeroed, which exhibits strong linear patterns. But with increased\n\tdisplacement, those artifacts disappear and the resulting noise is of very high quality.\n\tAs far as I'm aware, this technique is new so I'm taking the liberty of calling it \"orbit noise\"\n\n\tThe noise works very well with a 3 cell wide kernel (9 taps in 2d), but I am using\n\ta 5-wide kernel here just to help make the animation more satisfying. I am also including\n\ta 3D version of the noise to show that it is easy to extend to higher dimensions.\n*/\n\n//modified (simplified) nuttall filter for orbit noise\n//see: https://www.shadertoy.com/view/XtVcWc\nfloat nuttall(float x, float w)\n{\n    const float pi = 3.14159265358979;\n    if (abs(x) > w)\n        return 0.;\n    //Standard Nuttall\n    //return 0.355768 - 0.487396*cos(pi*x/w + pi) + 0.144232*cos(2.*pi*x/w) - 0.012604*cos(3.*pi*x/w + pi*3.);\n    return 0.365 - (0.5)*cos(pi*x/w + pi) + (0.135)*cos(2.*pi*x/w);\n}\n\nfloat orbitNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    //16 taps\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 dp = vec2(j,i);\n        vec4 rn = hash42(dp + ip) - 0.5;\n        vec2 op = fp - dp + rn.zw*orbitRadius;\n        rz += nuttall(length(op),1.85)*dot(rn.xy*1.7, op);\n    }\n    return rz*0.5+0.5;\n}\n\n//3D version, roughly 3 times as expensive as the 2d version\n//still much cheaper than 3D voronoi since we can use a 3 cell wide kernel\nfloat orbitNoise3D(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = 0.75; //Zero value for standard coherent/gradient/perlin noise\n\n    for (int k = -1; k <= 2; k++)\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n            vec3 dp = vec3(k,j,i);\n            uint base = baseHash(floatBitsToUint(dp + ip));\n        \tvec3 rn1 = vec3(uvec3(base, base*16807U, base*48271U) & uvec3(0x7fffffffU))/float(0x7fffffff);\n        \tvec3 rn2 = vec3(base*1664525U, base*134775813U, base*22695477U) * (1.0/float(0xffffffffU)); //(2^32 LCGs)\n        \tvec3 op = fp - dp - (rn1.xyz-0.5)*orbitRadius;\n        \trz += nuttall(length(op),1.85)*dot(rn2.xyz*1.0, op);\n    }\n    \n    return rz*0.5 + 0.5;\n}\n\n//1D version, for completeness\nfloat orbitNoise1D(float p)\n{\n    float ip = floor(p);\n    float fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 rn = hash21(float(i) + ip) - 0.5;\n        float op = fp - float(i) + rn.y*orbitRadius;\n        rz += nuttall(abs(op), 1.85)*rn.x*3.0*op;\n    }\n    return rz*0.5+0.5;\n}\n\nfloat fbmNoise(vec2 p)\n{\n    float rz = 0.;\n    float amp = 2.;\n    for (int i = 0; i < 6; i++)\n    {\n\t\trz += orbitNoise(p)/amp;\n        amp *= 2.;\n        p *= 2.1;\n        p += 12.5;\n    }\n    return rz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    p += iTime*.05;\n    vec3 col = vec3(0);\n    \n    if (q.x < 0.53)\n    \tcol = orbitNoise(p*36.3)*vec3(1);\n        //col = orbitNoise3D(vec3(p*36.3,1.))*vec3(1);\n    \t//col = orbitNoise1D(p.x*50.)*vec3(1);\n    else\n    \tcol = fbmNoise(p*11.)*vec3(1);\n\n    col *= smoothstep(0.,0.002, abs(q.x-0.53));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Orbit Noise\n//by nimitz 2018 (twitter: @stormoid)\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 hash21(float x)\n{\n    uint n = baseHash(uint(int(x)));\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}","name":"Common","description":"","type":"common"}]}