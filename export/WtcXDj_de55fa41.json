{"ver":"0.1","info":{"id":"WtcXDj","date":"1581671313","viewed":103,"name":"Simple Julia Set Zoom","username":"enslow","description":"I stole some of darthxander's code with his permission to make this","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int isInSet(vec2 uv);\n\n//define function\nint isInSet(vec2 uv)\n{\n    //define coordinate and initial value\n    vec2 z = vec2(uv.x,uv.y);\n    \n    \n    //Changing this c cooridnate changes the geometry of the fractal\n    \n    float a = -0.3269;\n    float b = 0.8889;\n    float t = 3.082;\n    \n    \n    vec2 c = vec2(a*cos(t),b*sin(t));\n    //set for the amount of steps of iteration\n    int iter = 300;\n    \n    \n    //determine if after 50 tries, if (a+bi)^2 > 2, is not in set.\n    int i;\n    for (i = 0; i < iter; i++)\n    {       \t\n        \n        //conditional statement that can break loop early\n        //normally you do not want to define this type of conditional inside a loop because\n        //it will run on every interation, but here it saves more memory than it uses.\n        if (sqrt(z.x*z.x + z.y*z.y)>3.0)\n        {\n            return i;\n        }\n        \n        \n        //basically multiplying complex numbers\n        float newx = 1.0*(z.x * z.x - z.y * z.y) + c.x;\n        float newy = 1.0*(z.y * z.x + z.x * z.y) + c.y;        \n        z.x = newx;\n        z.y = newy;        \n    }    \n\treturn -1;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n    vec2 center = vec2(0.00442, 0.34067);   \n    float scale = exp(0.25*iTime-1.0);\n    uv = center + uv/scale;\n    \n    int val = isInSet(uv);\n    \n    if (val == -1)\n    {\n        vec3 color = vec3(0.0,0.0,0.0);\n        fragColor = vec4(color,1.0);\n    }\n    else\n    {\n\n        float intensity = 3.0*float(val)/50.0;\n        vec3 color;\n        color.rgb = vec3(1.0);\n        \n        //These three lines determine the color based on the amount of iterations\n        color.r =  sin(intensity+0.00);\n        color.g =  sin(intensity+0.75);\n        color.b =  sin(intensity+1.57);\n        \n        fragColor = vec4(color,1.0);\n    }\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}