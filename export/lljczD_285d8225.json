{"ver":"0.1","info":{"id":"lljczD","date":"1507786269","viewed":329,"name":"Round_trips","username":"duvengar","description":"Double truchet flow with inverted direction. derived from [url=https://www.shadertoy.com/view/llfyWX]Simple_animated_Truchet[/url] by @Shane\nMouse control the flow direction.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","flow","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Round_trips by julien Vergnaud @duvengar-2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n\n// Derived from Simple_animated_Truchet by @Shane\n// [url]https://www.shadertoy.com/view/llfyWX[/url]\n\n// Mouse control direction\n\n\n#define PI     3.14159265359\n#define TWO_PI (PI*2.)\n\n// vec2 to float hash function taken from @Shane - Based on IQ's original.\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.867)))*43758.5453); }\n\n// Standard 2D rotation formula.\n\nmat2 rot(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n\n//distance field dot\n\n\n\nfloat df_circle(vec2 pos, float rad){\n\n float shp  = length(pos) -rad;\n  \n    return   shp;\n}\n\n\n\n\nvoid mainImage( out vec4 c, in vec2 uv )\n{\n    \n    // I   //  Screen coordinates is formated to go from -1. to 1.\n    \n\tvec2 p = -1.+ 2.* uv / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    \n      \n   \n    // II  //  Moove & Rescale screen space\n    \n    p *= 1. + dot(p, p)*.05;        // fish eye\n    p += vec2(.0, iTime/12.);       // moove along Y axis\n    //p *= .7*floor(iResolution.x/200.); // rescale space\n    p*=3.;\n    \n \t// III //  Make truchet lines\n           //  store tile id & Divide screen into grid \n    \t   //  & store direction in a checkerboard way.\n\t\n    vec2 id = ceil(p);\n    \n    float dir = mod(id.x + id.y, 2.) * 2. -1.;  \n    \n    \n    p = fract(p) - .5;  // or // p -= id + .5; \n        \n           //  Truchet tiles orientation randomisation\n    float r =  hash21(id) > .5 ? 1. : -1.;\n    \n\tp.y *= r;\n    \n           //  Applying symetry on diagonal axis to avoid drawing two arcs\n           //  Tricks form @shane\n    \n    p *= sign(p.x + p.y);\n      \n           //  Drawing the two arc's strokes directly with a tickness of t\n           //  The tricks to draw a contour was taken from a @FabriceNeyret2 \n           //  comment in this shader https://www.shadertoy.com/view/MtXyWX\n    \n    p -= .5; \n\n    // IV  //  RENDER\n    \n           //  Animate flow\n     \n    vec2 pos  = p ;\n    vec2 pos2 = p ;\n    vec2 pos3 = p ;  \n \n    if(iMouse.z > 0.){\n    \tfloat m = smoothstep(.0,-1. + 2. * iResolution.x, -1. + 2. * iMouse.x);\n        m*= 20.;\n    \tpos  *= rot(m *  dir);\n        pos2 *= rot(m * -dir);\n        pos3 *= rot(-5.*dir * r);        // magic tricks here*\n    \n    }else{\n        pos  *= rot(iTime *  dir);\n        pos2 *= rot(iTime * -dir);\n        pos3 *= rot(-5.*r * dir);      // magic tricks here\n    \t\t\t\t\t\t       // * use the random state r to flip again the sections\n    \t\t\t\t\t\t       // and get the inner / outer truchet together.   \n    }\n           //  Part into cells  & convert into polar coordinates\n     \n    const float num = 8.;                              // partitions number\n    \n    float ang  = atan(pos.y, pos.x);                   // Pixel angle  \n    float ang2 = atan(pos2.y, pos2.x);                 // pixel angle with opposite rotation\n    float ang3 = atan(pos3.y, pos3.x);                 // offset angle WITHOUT animation\n                                                \n    float ctr  = ceil(ang / TWO_PI * num) -.5;         // the cell centers.\n    float ctr2 = ceil(ang2 / TWO_PI * num )-.5;\n    \n          pos  = rot(ctr  * TWO_PI / num) * pos;        // Converting to polar coordinates\n          pos2 = rot(ctr2 * TWO_PI / num) * pos2;       //\n          pos.x  -= .5;                                 // p.x = radius, p.y = angle.\n          pos2.x -= .5;                                 // Translate coordinates\n    \n      \n           //  render the objects\n \n    float t = .084;                                      // thickness\n    float rd = .1;                                     // offset value added on each side of \n                                                         // the original truchet line\n    \n    vec2 p1  = vec2(sin(ang3) *  rd,cos(ang3) * -rd);    // Two mirored points\n    vec2 p2  = p1*vec2(-1);                              // inner or outer around ang2 (main angle)\n   \n    float line1 = abs(length(p - p1) - .5) - t ;         // two lines\n          line1 = 1. - smoothstep(.01,.2, sqrt(line1));  // abs() draw the contour\n    \n    float line2 = abs(length(p - p2) - .5) - t ;    \n          line2 = 1. - smoothstep(.01,.2, sqrt(line2));\n    \n    float line3 = abs(length(p ) - .5) - .005 ;    \n          line3 = 1. - smoothstep(.01,.2, sqrt(line3));\n                   \t\t\t\t\t\t\t\t\t\t                 \n    float ball1 = smoothstep(.01, .02, df_circle(pos  + vec2(r * dir * .1, .0) , .025)); // two balls\n    float ball2 = smoothstep(.01, .02, df_circle(pos2 - vec2(r * dir * .1, .0) , .03));\n        \n    // V   //   Coloring\n\t\n    \n    c= vec4(.1);\n  \n    c  = vec4(line2 *cos(sin(r * ang))      + line1 * cos(sin(r * ang2)));        // first two opposite gradient\n    c *= vec4(line2 *cos(sin(r * ang * 2.)) + line1 * cos(sin(r * ang * 2.)));    // second two gradient  \n    c *= .3 + line1;\n    c -= .1 * sin(2. * cos(8. * uv.x + uv.y) - hash21(uv));                       // texture\n    c += 1.-ball1;                                                                // balls\n    c *= 1.*ball2+.2;\n    c += line3;\n    vec2 uu  = 1. - 2. * uv / iResolution.xy;                                     // vigneting\n    float v  = 1. - smoothstep(.7, 1.4, length(uu*uu));\n   \n    c *= vec4(v); \n    c+= vec4(.0,.0,.07,1.);\n    \n    //c = vec4(ball1);\n    \n    //c = vec4(line3);\n \n    \n\t\n}","name":"Image","description":"","type":"image"}]}