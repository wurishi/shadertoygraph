{"ver":"0.1","info":{"id":"lXGSDm","date":"1720023971","viewed":47,"name":"color of channel (hw3)","username":"zemi","description":"color of channel","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["colorofchannel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//inspired by viclw's watercolor blending\n\n// 定义用于读取纹理的函数\n\nvec3 textureColor(vec2 uv) {\n    return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float speed = .3;\n    float scale = 0.002;\n    float time = iTime * speed;\n\n    // 计算旋转角度\n    float angle = time;\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n\n    // 计算旋转后的坐标\n    vec2 center = iResolution.xy * 0.5;\n    vec2 p = fragCoord - center;\n    p = vec2(\n        cosAngle * p.x - sinAngle * p.y,\n        sinAngle * p.x + cosAngle * p.y\n    ) * scale + center * scale;\n\n    // 原有的坐标变换\n    for(int i=1; i<10; i++){\n        p.x += 0.3/float(i) * cos(float(i) * 3. * p.y + time) + iMouse.x / 1000.;\n        p.y += 0.3/float(i) * sin(float(i) * 3. * p.x + time) + iMouse.y / 1000.;\n    }\n\n    // 从纹理读取颜色\n    vec2 uv = p * 0.5 + 0.5; // 将坐标转换到 [0, 1] 范围内\n    vec3 texColor = textureColor(uv);\n\n    // 混合纹理颜色和计算颜色\n    float r = cos(p.x + p.y + 1.) * .5 + .5;\n    float g = sin(p.x + p.y + 1.) * .5 + .5;\n    float b = (cos(p.x + p.y) + sin(p.x + p.y)) * .3 + .5;\n    vec3 color = vec3(b, g, r);\n\n    // 最终颜色混合\n    color = mix(color, texColor, 0.5); // 混合纹理颜色和计算颜色\n\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}