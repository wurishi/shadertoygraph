{"ver":"0.1","info":{"id":"lsjfzz","date":"1499261997","viewed":410,"name":"Meta-slime","username":"dcbrwn","description":"Slightly modified version of this one\nhttps://www.shadertoy.com/view/XdBBzR\n\nBased on work:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttp://iquilezles.org/articles/distfunctions/distfunctions.htm\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision lowp float;\n\nconst int MAX_MARCHING_STEPS = 50;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/**\n * Signed distance function describing the scene.\n */\nfloat sceneSDF(vec3 samplePoint) {\n  float ballRadius = 1.0;\n  float t = iTime / 10.0 + 10500.0;\n  float balls = MAX_DIST;\n  for (float i = 1.0; i < 4.0; i += 1.3) {\n    for (float j = 1.0; j < 4.0; j += 1.3) {\n      float cost = cos(t * j);\n      balls = smin(balls, sphereSDF(samplePoint + vec3(sin(t * i) * j, cost * i, cost * j), ballRadius), 0.7);\n    }\n  }\n\n  return balls;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n *\n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n  float depth = start;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    float dist = sceneSDF(eye + depth * marchingDirection);\n    if (dist > 0.0 && dist < EPSILON) {\n      return depth;\n    }\n    depth += dist;\n    if (depth >= end) {\n      return end;\n    }\n  }\n  return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n  float dist = sceneSDF(p);\n  vec3 epsilon = vec3(EPSILON, 0.0, 0.0);\n  return normalize(vec3(\n    sceneSDF(p + epsilon.xyy) - dist,\n    sceneSDF(p + epsilon.yxy) - dist,\n    sceneSDF(p + epsilon.yyx) - dist));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n  // Based on gluLookAt man page\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat3(s, u, -f);\n}\n\nvec4 reflectColor(vec3 eye, vec3 dir) {\n  float dist = MAX_DIST;\n  vec3 origin = eye;\n  vec3 direction = dir;\n  vec4 color = vec4(0.0);\n\n  for (int i = 0; i < 4; i++) {\n    dist = shortestDistanceToSurface(origin, direction, MIN_DIST, MAX_DIST);\n\n    color = texture(iChannel0, direction);\n\n    if (dist > MAX_DIST - EPSILON) {\n      break;\n    }\n\n    origin = origin + (dist - EPSILON) * direction;\n    direction = reflect(direction, estimateNormal(origin));\n  }\n\n  return color;\n}\n\n\nvec4 refractColor(vec3 eye, vec3 dir) {\n  float dist = MAX_DIST;\n  vec3 origin = eye;\n  vec3 direction = dir;\n    \n  dist = shortestDistanceToSurface(origin, direction, MIN_DIST, MAX_DIST);\n\n  if (dist > MAX_DIST - EPSILON) {\n    return texture(iChannel0, direction);\n  }\n  \n  origin = origin + (dist + EPSILON) * direction;\n  vec3 refDirection = refract(direction, estimateNormal(origin), 0.94);\n\n  return texture(iChannel0, refDirection) * vec4(0.3, 0.8, 0.0, 1.0) * (acos(dot(refDirection, direction)) * 8.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 viewDir = rayDirection(90.0, iResolution.xy, gl_FragCoord.xy);\n  vec3 eye = rotateY(iTime / 3.0) * vec3(3.0, 3.0, 10.0);\n  mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n  vec3 worldDir = viewToWorld * viewDir;\n  fragColor = refractColor(eye, worldDir) - 0.2 + reflectColor(eye, worldDir) * 0.6;\n}","name":"Image","description":"","type":"image"}]}