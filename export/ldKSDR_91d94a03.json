{"ver":"0.1","info":{"id":"ldKSDR","date":"1464108076","viewed":276,"name":"Quanta Generator","username":"akohdr","description":"With the VAL() local feedback I guess technically this a 3D LFSR or multi-tape Turing machine.\nLocal rules combine principles of feedback, 'birth' condition, aging and movement to produce interesting output from single initial starting element.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["voxel","automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Viewer - displays a voxel volume described by 2D tiled z-slices\n//\n#define FRES vec3(37,37,77)\n#define EYE 80\n#define RES iResolution\n#define FDIM vec3(floor(RES.xy/FRES.xy),FRES.z)\n\nbool isVoxel(out vec4 k, const in vec3 P)\n{\n    if(any(greaterThan(abs(P),FRES/2.))) return false; \t// bounds check, kills repetition \n    vec3 p = P + FRES/2.;\t\t  \t\t\t\t\t\t// recenter volume in viewport\n\tfloat z = p.z, w = FDIM.x;\t\t\t\t\t\t\t// inlined prj4Dto2D()\n    k = texture(iChannel0, (FRES.xy * floor(vec2(mod(z,w),z/w)) + mod(p.xy,FRES.xy))/RES.xy);\n\n    return dot(k.xyz,vec3(1)) > (iMouse.z>0. ?\n        3.*iMouse.y/RES.y :\t\t// mouse controled culling\n    \t.5);\t\t\t\t\t// cull orange\n}\n\nvoid mainImage(out vec4 k, vec2 P)\n{\n    float a,b,c,T, Rx = RES.x, Ry = RES.y;\n    vec2 uv = P/RES.xy,\n         u = (P - vec2(0,.5)*Ry)/Rx - vec2(.5,0);\n    \n    if(iMouse.z>0.){\n        if (iMouse.y>250.){ \n            k = texture(iChannel0, uv); return; }\t\t// show state space\n        T = 5.*iMouse.x/Rx;  \t\t\t\t\t\t\t// mouse rotate\n    } else\n        T = 2.2; \t\t\t\t\t\t\t\t\t\t// fixed\n    \n    vec3 v = vec3(cos(T), 1, sin(T)),\n         r = mat3(u.x,    0,   .8,\n                    0,  u.y,    0,\n                  -.8,    0,  u.x) * v,\n         o = vec3(EYE,0,-EYE)*v.zyx,\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d * ( q*(f-o + .5) +.5), m;\n\n    for(int i=0; i<250; i++) {\n        a=s.x, b=s.y, c=s.z,\n        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b)),\n        f += m*q;\n        \n        if(isVoxel(k, f)) { \n            k += vec4(m.x>.0 ? 0. : m.y>.0 ? .6 : .3); \n            k *= .9-f.z/FRES.z;\t\t\t\t\t\t\t// cheap depth based faux lighting\n            return;} //early exit\n    }\n    k = vec4(P.y/RES.y); \t\t\t\t\t\t\t\t// background fade\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Automata - 3D state space maintained in looped buffer of 2D tiled z-slices\n//\n#define FRES vec3(37,37,77)\n#define FDIM vec3(floor(iResolution.xy/FRES.xy),FRES.z)\n\n#define BLK vec4(0)\n#define RED vec4(1,0,0,1)\n#define PRP vec4(.5,0,.5,1)\n#define GRN vec4(0,1,0,1)\n#define YEL vec4(1,.8,0,1)\n#define BLU vec4(0,0,1,1)\n#define CYN vec4(0,1,1,1)\n#define ORG vec4(.4,.1,0,1)\n#define  _  vec4(-1)\n\nvec2 prj4Dto2D(const in vec4 p)\n{\n    float z = p.z, w = FDIM.x;\n    return FRES.xy * floor(vec2(mod(z,w), z/w)) + mod(p.xy, FRES.xy);\n}\n\nvec4 prj2Dto4D(const in vec2 p)\n{\n    return vec4(mod(p,FRES.xy), dot(floor(p/FRES.xy),vec2(1,FDIM.x)), 0);//iTime);\n}\n\n// mini-DSL for rule definitions / processing ==============================================\n#define RULE(n) void n(out vec4 r[28]){SET(r,_);\n#define RULEM(F,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,s,t,u,v,w,x,y,z,A,B,C,o)void F(out vec4 r[28]){r[0]=o;r[25]=a;r[26]=b;r[27]=c;r[16]=d;r[17]=e;r[18]=f;r[7]=g;r[8]=h;r[9]=i;r[22]=j;r[23]=k;r[24]=l;r[13]=m;r[14]=n;r[15]=p;r[4]=q;r[5]=s;r[6]=t;r[19]=u;r[20]=v;r[21]=w;r[10]=x;r[11]=y;r[12]=z;r[1]=A;r[2]=B;r[3]=C;} \n#define SET(r,K) r[0]=r[1]=r[2]=r[3]=r[4]=r[5]=r[6]=r[7]=r[8]=r[9]=r[10]=r[11]=r[12]=r[13]=r[14]=r[15]=r[16]=r[17]=r[18]=r[19]=r[20]=r[21]=r[22]=r[23]=r[24]=r[25]=r[26]=r[27]=K;\n#define ARULE(n,v,A,B,C) RULE(n)WHEN A;RV(v)=B;OUT C;}\n#define TRVBNC(K,L,a,b,c,d,v) ARULE(a,v,BLK,K,K) ARULE(b,-v,BLK,L,L) ARULE(c,v,L,ORG,K) ARULE(d,-v,K,ORG,L)\n#define APPLY(f) f(r);applyRule(q,r,k);if(k.w>0.)return;\n#define APPLY4(a,b,c,d) APPLY(a)APPLY(b)APPLY(c)APPLY(d)\n#define VX(v,K) if(distance((v).xyz,q.xyz+.25)<.5)k=K;\n#define CK(x,y,z) if(noMatch(q+vec4(x,y,z,1),RV(vec3(x,y,z))))return;\n#define RV(v) r[(int(dot(v+1.,vec3(1,9,3)))+1)]\n#define RQ(x,y,z) RV(vec3(x,y,z))\n#define WHEN RV(vec3(0))=\n#define OUT  r[0]=\n#define VAL(x,y,z) vec4(x,y,z,-1)\n\n// rule processing =========================================================================\n\nbool noMatch(const in vec4 dp, const in vec4 K)\n{\n    return K != _ && K.rgb != texture(iChannel0, prj4Dto2D(dp)/iResolution.xy).rgb;\n}\n\nvoid applyRule(const in vec4 q, const in vec4 r[28], inout vec4 k)\n{\n    CK( 1, 1,-1)    CK( 1, 1, 0)    CK( 1, 1, 1)        \n    CK( 0, 1,-1)    CK( 0, 1, 0)    CK( 0, 1, 1)\n    CK(-1, 1,-1)    CK(-1, 1, 0)    CK(-1, 1, 1)\n        \n    CK( 1, 0,-1)    CK( 1, 0, 0)    CK( 1, 0, 1)\n    CK( 0, 0,-1)    CK( 0, 0, 0)    CK( 0, 0, 1)\n    CK(-1, 0,-1)    CK(-1, 0, 0)    CK(-1, 0, 1)\n        \n    CK( 1,-1,-1)    CK( 1,-1, 0)    CK( 1,-1, 1)\n    CK( 0,-1,-1)    CK( 0,-1, 0)    CK( 0,-1, 1)\n    CK(-1,-1,-1)    CK(-1,-1, 0)    CK(-1,-1, 1)\n    \n    vec4 o  = r[0];\n    k = o.w>0. ? o : texture(iChannel0,prj4Dto2D(q+o)/iResolution.xy);\n}\n    \n// local rules =============================================================================\n   \nRULEM(rFEEDBACK1, \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,ORG, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tVAL(-1,1,1))\n\nRULEM(rFEEDBACK2, \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ ,ORG, _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tVAL(1,1,-1))\n    \nRULEM(rREDAGE, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,RED, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tGRN)\n\nRULEM(rGRNAGE, \t \t _ , _ , _ ,\t _ , _ ,GRN,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tBLU)\n\nRULEM(rBLUAGE, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ ,BLU,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tYEL)\n\nRULEM(rYELAGE, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,YEL, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tORG)\n    \nRULEM(rBIRTH, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\tBLK,GRN,BLK,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tRED)\n\n// movement rules\nTRVBNC(RED,PRP,rRED,rPRP,rREDORG,rPRPORG,vec3(1,0,0))\nTRVBNC(GRN,YEL,rGRN,rYEL,rGRNORG,rYELORG,vec3(0,1,0))\nTRVBNC(BLU,CYN,rBLU,rCYN,rBLUORG,rCYNORG,vec3(0,0,1))\n    \nvoid applyLocalRules(out vec4 k, const in vec2 p, const in vec4 q)\n{\n    vec4 r[28];\t\t   \t\t\t\t\t\t\t// rule buffer\n    k = texture(iChannel0, p/iResolution.xy);\t// retrieve prior state\n    if(k!=ORG) k=BLK;  \t\t\t\t\t\t\t// clear everything except...\n\n    APPLY(rFEEDBACK1) APPLY(rFEEDBACK2)\n    APPLY(rBIRTH)\n\tAPPLY4(rRED, rPRP, rREDORG, rPRPORG)\n    APPLY4(rGRN, rYEL, rGRNORG, rYELORG)\n    APPLY4(rBLU, rCYN, rBLUORG, rCYNORG)\n    APPLY4(rREDAGE, rGRNAGE, rBLUAGE, rYELAGE)\n}\n\n// initial condition =======================================================================\nvoid init(out vec4 k, vec2 p, vec4 q)\n{\n    k = BLK;\n    VX(vec3(17),RED)\n}\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    const vec3 h = FRES/2.;\n    vec4 q = prj2Dto4D(p);\t\t\t\t\t\t// 4D state position\n    \n    if(mod(iTime,600.)<1.)\t\t\t\t// periodic reset\n        init(k,p,q);\n    else if(\n       q.z<FDIM.z &&\t\t\t\t\t\t\t// ignore z-slices beyond volume (redundant but more efficient)\n       all(lessThan(abs(q.xyz-h),h-1.))&&  \t\t// prevent cycling (BLK border)\n       all(lessThan(p,FDIM.xy*FRES.xy))  \t\t// ignore partial z-slices\n       )\n   \t\tapplyLocalRules(k,p,q);\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}