{"ver":"0.1","info":{"id":"cttXD8","date":"1687345838","viewed":91,"name":"Shader_based ViscousFlow","username":"illidan786123","description":"For training optical flow velocity estimator. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["flow","normalmapping"],"hasliked":0,"parentid":"ft3Bz2","parentname":"Normal mapped laminar flow 2tap"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Call console (eg. Chrome - cmd + opt + j) to load custom texture using the following command\n// gShaderToy.SetTexture(0, {mSrc:'https://t4.ftcdn.net/jpg/04/12/46/13/360_F_412461386_ArOwEJwRWaMZQRR6IZME8JFt7HMncFPd.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n\n// This function returns a 2D vector that represents the flow velocity at a given 2D position.\nvec2 GetFlowVelocity(vec2 pos)\n{\n    // Compute the aspect ratio of the resolution (height divided by width).\n    float y_size = iResolution.y / iResolution.x;\n    // Compute the vertical distance from the center of the screen, normalized by the aspect ratio.\n    float y_dist = abs(pos.y - y_size * 0.5f) / (0.5f * y_size);\n    // Return a 2D vector where the x component is computed from the squared y_dist and y component is 0.\n    return vec2(1.0f - y_dist * y_dist, 0.0f);\n}\n\n// This function constructs a 2D velocity field from a given 2D position.\nUvField GetVelocityField(vec2 pos)\n{\n    // Small number for numerical precision (epsilon).\n    float eps = 1e-2f;\n    UvField uv_field;\n    // Compute the x and yz components of the uv_field using GetFlowVelocity function and numerical differentiation.\n    uv_field[0].x = GetFlowVelocity(pos).x;\n    uv_field[0].yz = vec2(GetFlowVelocity(pos + vec2(eps, 0.0f)).x - uv_field[0].x, GetFlowVelocity(pos + vec2(0.0f, eps)).x - uv_field[0].x) / eps;\n\n    uv_field[1].x = GetFlowVelocity(pos).y;\n    uv_field[1].yz = vec2(GetFlowVelocity(pos + vec2(eps, 0.0f)).y - uv_field[1].x, GetFlowVelocity(pos + vec2(0.0f, eps)).y - uv_field[1].x) / eps;\n    return uv_field;\n}\n\n// This function computes the total light at a given 3D position with a certain surface normal and albedo color.\nvec3 GetTotalLight(vec3 pos, vec3 surface_norm, vec3 albedo_color)\n{\n    // Compute the aspect ratio of the resolution (height divided by width).\n    float y_size = iResolution.y / iResolution.x;\n    // Initialize the resulting light to 0.\n    vec3 res_light = vec3(0.0f);\n    // Compute light contributions from two light sources and add them to the result.\n    {\n        vec3 delta = pos - vec3(vec2(0.75f, y_size * 0.5f), 0.3f);\n        res_light += GetPointLightFalloff(delta) * GetLight(normalize(delta), surface_norm, albedo_color) * vec3(.5f,.5f, .5f);\n    }\n    {\n        vec3 delta = pos - vec3(vec2(0.25f, y_size * 0.5f), 0.3f);\n        res_light += GetPointLightFalloff(delta) * GetLight(normalize(delta), surface_norm, albedo_color) * vec3(.5f, .5f, .5f);\n    }\n    // Return the total light.\n    return res_light;\n}\n\n// This function computes the flow field based on the phase, phase_offset, and other parameters.\nField GetFlowField(sampler2D tex, UvField uv_field, UvField flow_field, float phase, float phase_offset, float eps, uint type)\n{\n    // Initialize the period.\n    float period = 3.0f;\n    // Get the interpolation nodes.\n    InterpNodes2 interp_nodes2 = GetInterpNodes2(phase / period);\n    // Initialize the moment.\n    float moment2 = 0.0f;\n    // Initialize the resulting field.\n    Field res_field;\n    // Loop over each node.\n    for(uint node_index = 0u; node_index < 2u; node_index++)\n    {\n        // Generate a hash value for the node.\n        vec3 node_hash = hash33(vec3(interp_nodes2.seeds[node_index], 0.0f, 0.0f));\n        // Compute the UV field for the node.\n        UvField node_uv_field = uv_field - period * flow_field * (2.0f * interp_nodes2.phases[node_index] - 1.0f) - phase_offset * flow_field;\n        // Apply a rotation and translation to the UV field.\n        UvField hashed_uv_field = RotateMoveUvField(node_uv_field, node_hash.xy, node_hash.z * 2.0f * pi);\n        // Sample the texture field at the UV coordinates.\n        Field tex_field = SampleTexField(hashed_uv_field, tex, eps);\n        // Compute the weight field.\n        Field weight_field = Field(interp_nodes2.weights[node_index], 0.0f, 0.0f);\n        \n        // Update the result field based on the interpolation type.\n            res_field += tex_field * weight_field.x;\n    }\n    // Return the final result field.\n    return res_field;\n}\n\n// The main function to compute the final color for each pixel.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Compute normalized pixel coordinates.\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y);\n    // Compute the stretch factor based on the mouse input.\n    float stretch = 1.0f;\n    // Compute the flow field.\n    Field res_field = GetFlowField(iChannel0, IdentityUvField(uv * 2.0f), GetVelocityField(uv) * 0.1f, iTime, stretch, 1.0f / 512.0f, 0u);\n    \n    // Compute the position and normal for the surface.\n    vec3 res_pos = vec3(uv, 0.6f);\n    vec3 res_norm = GradToNorm(res_field.yz * 1.0f);\n\n    // Compute the light at the surface.\n    vec3 res_light = GetTotalLight(res_pos, res_norm, vec3(0.15f));\n    \n\n    // Convert the light to sRGB color space and assign it to the fragment color.\n    vec3 srgb_color = pow(res_light, vec3(1.0f / 1.0f));\n    fragColor = vec4(srgb_color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Field vec3\n#define UvField mat2x3\n\n// Function to sample a texture field using a 2D UV coordinate and an epsilon value\n// Returns a field (vec3) with the sampled values\nField SampleTexFieldVec2(vec2 uv, sampler2D tex, float eps)\n{\n    Field res;\n    res.x = texture(tex, uv).r;\n    // In actual use, this is supposed to be precalculated\n    float center = textureLod(tex, uv, 0.0f).r;\n    res.y = (textureLod(tex, uv + vec2(eps, 0.0f), 0.0f).r - center) / eps;\n    res.z = (textureLod(tex, uv + vec2(0.0f, eps), 0.0f).r - center) / eps;\n    return res;\n}\n\n// Function to sample a texture field using a UV field, a texture, and an epsilon value\n// Returns a field (vec3) with the sampled values\nField SampleTexField(UvField uv_field, sampler2D tex, float eps)\n{\n    Field local_field = SampleTexFieldVec2(vec2(uv_field[0].x, uv_field[1].x), tex, eps);\n    return Field(local_field.x, uv_field[0].yz * local_field.y + uv_field[1].yz * local_field.z);\n}\n\n// Function to multiply two field values together\n// Returns the product of the two fields\nField FieldMul(Field field0, Field field1)\n{\n    return Field(field0.x * field1.x, field0.x * field1.yz + field1.x * field0.yz);\n}\n\n// Function to calculate linear step of a field value based on a center and steepness\n// Returns the resulting field value\nField FieldLinStep(Field value, Field center, Field steepness)\n{\n    return FieldMul(value, (steepness + Field(1.0f, 0.0f, 0.0f))) - FieldMul(center, steepness);\n}\n\n// Function to calculate the maximum value between two fields\n// Returns the maximum value\nField FieldMax(Field field0, Field field1)\n{\n    return field0.x > field1.x ? field0 : field1;\n}\n\n// Function to calculate the minimum value between two fields\n// Returns the minimum value\nField FieldMin(Field field0, Field field1)\n{\n    return field0.x < field1.x ? field0 : field1;\n}\n\n// Function to calculate the inverse of a field value\n// Returns the inverse field value\nField FieldInverse(Field value)\n{\n    float inv = 1.0f / value.x;\n    return Field(inv, -inv * inv * value.yz);\n}\n\n// Function to calculate the inverse of a field value while ensuring safety\n// Returns the inverse field value\nField FieldInverseSafe(Field value)\n{\n    float inv = abs(value.x) > 1e-5f ? 1.0f / value.x : 1e5f;\n    return Field(inv, -inv * inv * value.yz);\n}\n\n// Function to calculate (1 - value) of a field value\n// Returns the resulting field value\nField FieldOneMinus(Field value)\n{\n    return Field(1.0f - value.x, -value.yz);\n}\n\n// Function to calculate the square of a field value\n// Returns the resulting field value\nField FieldSqr(Field value)\n{\n    return Field(value.x * value.x, 2.0f * value.x * value.yz);\n}\n\n// Function to calculate the normalized ramp of a field value based on a center\n// Returns the resulting field value\nField FieldRampNormHalf(Field value, Field center)\n{\n    // Source: https://www.desmos.com/calculator/tpa2t76anf\n    return FieldMul(value, FieldInverseSafe(FieldMul(FieldSqr(2.0f * center), FieldOneMinus(value)) + value));\n}\n\n// Function to calculate the normalized ramp of a field value based on a center\n// Returns the resulting field value\nField FieldRampNorm(Field value, Field center)\n{\n    float eps = 1e-3f;\n    center.x = clamp(center.x, eps, 1.0f - eps);\n    bool mirror = center.x < 0.5f;\n    Field mirrored_value = mirror ? value : FieldOneMinus(value);\n    Field mirrored_center = mirror ? center : FieldOneMinus(center);\n    Field ramp = FieldRampNormHalf(mirrored_value, mirrored_center);\n    return mirror ? ramp : FieldOneMinus(ramp);\n}\n\n// Function to calculate the power of a field value with a constant exponent\n// Returns the resulting field value\nField FieldPowerConst(Field value, float p)\n{\n    float eps = 1e-3f;\n    if (value.x < eps) return value;\n\n    Field res;\n    res.x = pow(value.x, p);\n    res.yz = res.x * p / value.x * value.yz;\n    return res;\n}\n\n// Function to calculate the gain of a field value with a constant steepness\n// Returns the resulting field value\nField FieldGainConst(Field value, float steepness)\n{\n    float eps = 1e-3f;\n    steepness = clamp(steepness, -1.0f + eps, 1.0f - eps);\n    float power = (1.0f + steepness) / (1.0f - steepness);\n    Field p = 0.5f * FieldPowerConst(2.0f * ((value.x < 0.5f) ? value : FieldOneMinus(value)), power);\n    return (value.x < 0.5f) ? p : FieldOneMinus(p);\n}\n\n// Function to dissolve a field value based on an alpha value\n// Returns the dissolved field value\nField FieldDissolve(Field value, Field alpha)\n{\n    float eps = 1e-2f;\n    Field steepness = alpha.x > eps ? FieldInverse(alpha) : Field(1.0f / eps, 0.0f, 0.0f);\n\n    Field res = FieldMul(FieldMin(Field(0.0f, 0.0f, 0.0f), value - Field(1.0f, 0.0f, 0.0f)), steepness) + Field(1.0f, 0.0f, 0.0f);\n    res -= FieldMax(Field(0.0f, 0.0f, 0.0f), Field(eps, 0.0f, 0.0f) - alpha) / eps * 2.0f;\n    res = res.x < 0.0f ? Field(-1e-5f, 0.0f, 0.0f) : res;\n    return res;\n}\n\n// Function to create a UV field with an identity transformation based on a UV coordinate\n// Returns the resulting UV field\nUvField IdentityUvField(vec2 uv)\n{\n    UvField res_field;\n    res_field[0] = vec3(uv.x, 1.0f, 0.0f);\n    res_field[1] = vec3(uv.y, 0.0f, 1.0f);\n    return res_field;\n}\n\n// Function to apply a transformation to a UV field based on a source-to-destination transformation matrix\n// Returns the resulting transformed UV field\nUvField ApplyTransform(UvField src_uv_field, mat2x2 src_to_dst)\n{\n    // Eq0: This is how UV coordinates are transformed for operations like rotation\n    // dst.u(x,y) = src_to_dst * src.u(x,y)\n    // dst.v(x,y) = src_to_dst * src.v(x,y)\n    \n    // Eq1: Derivative with respect to x (d/dx)\n    // d/dx * dst.u(x,y) = src_to_dst * d/dx * src.u(x,y)\n    // d/dx * dst.v(x,y) = src_to_dst * d/dx * src.v(x,y)\n    \n    // Eq2: Derivative with respect to y (d/dy)\n    // d/dy * dst.u(x,y) = src_to_dst * d/dy * src.u(x,y)\n    // d/dy * dst.v(x,y) = src_to_dst * d/dy * src.v(x,y)\n    \n    // Eq0, Eq1, and Eq2 can be written as columns of a matrix with 2 rows and 3 columns:\n    // dst.u(x,y)   d/dx * dst.u(x,y)   d/dy * dst.u(x,y) = T(R) * src.u(x,y)   d/dx * src.u(x,y)   d/dy * src.u(x,y)\n    // dst.v(x,y)   d/dx * dst.v(x,y)   d/dy * dst.v(x,y)       src.v(x,y)   d/dx * src.v(x,y)   d/dy * src.v(x,y)\n    \n    // dst_uv_mat[2x3] = src_to_dst[2x2] * src_uv_mat[2x3]\n\n    // GLSL's mat3x2 has an actual size of [2x3] from a mathematical perspective.\n    // Praise OpenGL.\n    \n    // Transpose the UV field to make each row a vector\n    mat3x2 src_uv_mat = transpose(src_uv_field);\n    \n    // Apply the source-to-destination transformation matrix to each column of the source UV matrix\n    mat3x2 dst_uv_mat = src_to_dst * src_uv_mat;\n    \n    UvField res_uv_field;\n    res_uv_field = transpose(dst_uv_mat);\n    \n    return res_uv_field;\n}\n\n// Function to rotate and move a UV field based on an offset and angle\n// Returns the resulting rotated and moved UV field\nUvField RotateMoveUvField(UvField src_uv_field, vec2 offset, float ang)\n{\n    mat2 dst_to_src = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    mat2 src_to_dst = transpose(dst_to_src);\n    UvField dst_uv_field = ApplyTransform(src_uv_field, src_to_dst);\n    dst_uv_field[0].x += offset.x;\n    dst_uv_field[1].x += offset.y;\n    return dst_uv_field;\n}\n\n// Function to convert a gradient vector to a normal vector\n// Returns the resulting normalized normal vector\nvec3 GradToNorm(vec2 grad)\n{\n    return normalize(vec3(-grad, 1.0f));\n}\n\n// Function to convert a normal vector to a gradient vector\n// Returns the resulting gradient vector\nvec2 NormToGrad(vec3 norm)\n{\n    return -norm.xy / norm.z;\n}\n\n// Function to calculate the diffuse component of a light based on the light direction and surface normal\n// Returns the diffuse value\nfloat GetDiffuse(vec3 light_dir, vec3 surface_norm)\n{\n    return max(dot(-light_dir, surface_norm), 0.0f);\n}\n\n// Function to calculate the falloff of a point light based on the distance from the light\n// Returns the falloff value\nfloat GetPointLightFalloff(vec3 delta)\n{\n    return 1.0f / (dot(delta, delta) + 1e-5f);\n}\n\n// Function to calculate the light contribution based on the light direction, surface normal, and albedo color\n// Returns the resulting light value\nvec3 GetLight(vec3 light_dir, vec3 surface_norm, vec3 albedo_color)\n{\n    return GetDiffuse(light_dir, surface_norm) * albedo_color;\n}\n\n// Function to calculate the square of a value\n// Returns the squared value\nfloat sqr(float val) { return val * val; }\n\n// Structure to store interpolation nodes\nstruct InterpNodes2\n{\n    vec2 seeds;\n    vec2 phases;\n    vec2 weights;\n};\n\n// Function to get interpolation nodes based on a phase value\n// Returns the interpolation nodes\nInterpNodes2 GetInterpNodes2(float phase)\n{\n    vec2 global_phases = vec2(phase * 0.5) + vec2(0.5, 0.0);\n    vec2 phases = fract(global_phases);\n    vec2 seeds = floor(global_phases) * 2.0 + vec2(0.0, 1.0);\n    vec2 weights = min(phases, vec2(1.0f) - phases) * 2.0;\n    return InterpNodes2(seeds, phases, weights);\n}\n\n// Function to preserve variance in a linear color using mean color and second moment\n// Returns the resulting color with preserved variance\nvec3 PreserveVariance(vec3 linearColor, vec3 meanColor, float moment2)\n{\n    return (linearColor - meanColor) / sqrt(moment2) + meanColor;\n}\n\n// Function to generate a 3D hash value using a 3D point\n// Returns the hash value\nvec3 hash33(vec3 p)\n{\n    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n              dot(p, vec3(269.5, 183.3, 246.1)),\n              dot(p, vec3(113.5, 271.9, 124.6)));\n\n    return fract(sin(p) * 43758.5453123);\n}\n\nconst float pi = 3.141592f;\n","name":"Common","description":"","type":"common"}]}