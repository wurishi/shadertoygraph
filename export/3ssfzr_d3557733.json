{"ver":"0.1","info":{"id":"3ssfzr","date":"1587612101","viewed":45,"name":"Depth of Field Shangru","username":"pandaleo","description":"hw9","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cis561"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 20.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n\n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n    \n    float vignette = smoothstep(1.75, 0.0, length((2.0 * uv) - vec2(1.0)));\n    fragColor = mix(vec4(0.0, 0.0, 0.1, 1.0), fragColor, vignette);\n    \n    //fragColor = vec4(unblurredColor.a, unblurredColor.a, unblurredColor.a, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float FOCAL_LENGTH = 1.;\nfloat FOCAL_RANGE = 3.;\nmat3 rotateY(float rad)\n{\n    return mat3(vec3(cos(rad), 0, -sin(rad)),\n                vec3(0, 1, 0),\n                vec3(sin(rad), 0, cos(rad))\n               );\n}\nmat3 rotateZ(float rad)\n{\n    return mat3(vec3(cos(rad), -sin(rad), 0),\n                vec3(sin(rad), cos(rad), 0),\n                vec3(0, 0, 1)\n               );\n}\nmat3 rotateX(float rad)\n{\n    return mat3(vec3(1, 0, 0),\n        \t\tvec3(0, cos(rad), -sin(rad)),\n                vec3(0, sin(rad), cos(rad))\n               );\n}\nmat3 scale(float a, float b, float c)\n{\n    return mat3(vec3(a, 0, 0), vec3(0, b, 0), vec3(0, 0, c));\n}\nmat3 scale(float a)\n{\n    return scale(a, a, a);\n}\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\nfloat sdfSphere(vec3 p)\n{\n    return length(p) - 0.5;\n}\nfloat sdfPlane(vec3 p)\n{\n    return dot(p, vec3(0, 0, 1));\n}\nvec2 closer(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a: b;\n}\nfloat deg2rad(float r)\n{\n\treturn r / 180. * 3.14159;\n}\nvec2 map(vec3 pos) // find closest object\n{\n    vec3 sphereWorld = vec3(0.3, 0.3, -0.4);\n    vec3 posSphereModel = pos - sphereWorld; // position in sphere model space\n    vec2 sphereInfo = vec2(sdfSphere(posSphereModel), 1.);\n    \n    vec3 boxWorld = vec3(-0.35, -0.6, 0.3);\n    vec3 posBoxModel = inverse(rotateY(deg2rad(35.))) * (pos - boxWorld);\n    vec3 boxSize = vec3(0.2, 0.4, 0.2);\n    vec2 boxInfo = vec2(sdfBox(posBoxModel, boxSize), 2.);\n    \n    vec3 boxWorld2 = vec3(0.35, -0.8, 0.3);\n    vec3 posBoxModel2 = inverse(rotateY(deg2rad(60.))) * (pos - boxWorld2);\n    vec3 boxSize2 = vec3(0.22, 0.22, 0.22);\n    vec2 boxInfo2 = vec2(sdfBox(posBoxModel2, boxSize2), 8.);\n    \n    vec3 planeWorld1 = vec3(-1, 0, 0);\n    vec3 posPlaneModel1 = inverse(rotateY(3.14 / 2.)) * (pos - planeWorld1);\n    vec2 planeInfo1 = vec2(sdfPlane(posPlaneModel1), 3.);\n    \n    vec3 planeWorld2 = vec3(1, 0, 0);\n    vec3 posPlaneModel2 = inverse(rotateY(3. * 3.14 / 2.)) * (pos - planeWorld2);\n    vec2 planeInfo2 = vec2(sdfPlane(posPlaneModel2), 4.);\n    \n    vec3 planeWorld3 = vec3(0, 0, 0);\n    vec3 posPlaneModel3 = (pos - planeWorld3);\n    vec2 planeInfo3 = vec2(sdfPlane(posPlaneModel3), 5.);\n    \n    vec3 planeWorld4 = vec3(0, 1, 0);\n    vec3 posPlaneModel4 = inverse(rotateX(3. * 3.14 / 2.)) * (pos - planeWorld4);\n    vec2 planeInfo4 = vec2(sdfPlane(posPlaneModel4), 6.);\n    \n    vec3 planeWorld5 = vec3(0, -1, 0);\n    vec3 posPlaneModel5 = inverse(rotateX(3.14 / 2.)) * (pos - planeWorld5);\n    vec2 planeInfo5 = vec2(sdfPlane(posPlaneModel5), 7.);\n    \n    vec2 closest;\n    closest = closer(boxInfo, planeInfo1);\n    closest = closer(closest, planeInfo2);\n    closest = closer(closest, planeInfo3);\n    closest = closer(closest, planeInfo4);\n    closest = closer(closest, planeInfo5);\n    closest = closer(closest, boxInfo2);\n    return closest;\n}\nvec2 calcIntersection(in vec3 ro, in vec3 rd){\n    float currentMinSdf = 0.002;\n    float t = 0.0; // distance from ro (ray origin)\n\tfloat resDistance = -1.;\n    float id = -1.;\n    for (int i = 0; i < 100; ++i){\n        if (currentMinSdf < 0.001 || t > 10.) break; // hit or exceed max distance\n\t   \tvec2 hitInfo = map(ro + rd * t); // hit object distance and id\n        currentMinSdf = hitInfo.x; // distance\n        t += currentMinSdf; // update current distance from ro\n        id = hitInfo.y;\n    }\n    if (t <= 10.) resDistance = t; // if in distance\n    else id = -1.; // no hit\n    return vec2(resDistance, id);\n}\nvec3 calcNormal(in vec3 pos){\n    \n\tvec3 dx = vec3(0.001, 0.0, 0.0);    \n\tvec3 dy = vec3(0.0, 0.001, 0.0);    \n\tvec3 dz = vec3(0.0, 0.0, 0.001);\n\tvec3 nor = vec3(\n\t    map(pos + dx).x - map(pos - dx).x,\n\t    map(pos + dy).x - map(pos - dy).x,\n\t    map(pos + dz).x - map(pos - dz).x\n    );\n\treturn normalize(nor);\n}\nvec4 render(vec2 res, in vec3 ro, in vec3 rd)\n{\n    float ambient = 0.05;\n    vec3 color = vec3(0);\n    float T = 0.;\n    float lightX = 0.5 * sin(iTime * 4.);\n    vec3 lightPos = vec3(lightX, 0.9, 0.8);\n    if (res.y > 0.) // id\n    {\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 norm = calcNormal(pos);\n    \tvec3 lightDir = normalize(lightPos - pos);\n        float match = max(0., dot(lightDir, norm) / pow(length(lightPos - pos), 0.3));\n        if (res.y == 1.) color = vec3(1., 0., 0.) * match + ambient;\n        else if (res.y == 2.) color = vec3(0.4, 0.4, 0.4) * match + ambient;\n\t\telse if (res.y == 3.) color = vec3(1, 0, 0) * match + ambient;\n        else if (res.y == 4.) color = vec3(0, 1, 0) * match + ambient;\n\t\telse if (res.y == 5.) color = vec3(1, 1, 1) * match + ambient;   \n        else if (res.y == 6.) color = vec3(0.5, 0.5, 0.5) * match + ambient;\n\t\telse if (res.y == 7.) color = vec3(1, 1, 1) * match + ambient;  \n\t\telse if (res.y == 8.) color = vec3(1, 1, 1) * match + ambient;  \n        float distAlongCamZ = dot(pos - ro, vec3(0, 0, 1));\n        float currentLength = 1. + 0.8 * sin(iTime * 3.);\n        T = abs((distAlongCamZ - currentLength) / FOCAL_RANGE);\n    }\n    return vec4(color, T);\n}\nmat3 lookAt(in vec3 eye, in vec3 ref)\n{\n    vec3 front = normalize(ref - eye);\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, front));\n    return mat3(right, up, front);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0, 0, 2), ref = vec3(0, 0, 0);\n    vec3 direction = normalize(lookAt(eye, ref) * vec3(p.xy, 1));\n    vec2 res = calcIntersection(eye, direction);\n    fragColor = render(res, eye, direction);\n}","name":"Buffer A","description":"","type":"buffer"}]}