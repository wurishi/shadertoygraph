{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\nCONTROLS :\n\n    - LEFT CLICK            : revel the cell below the cursor\n    - SHIFT + LEFT CLICK    : place a flag\n    - R or click the smiley : regenerate the grid\n    \nYou can change : \n    - the size of the grid, see : GRID_X_SIZE\n    - the probability for a mine to be placed, see : MINE_PROBA\n*/\n\nvoid applyTexture(inout vec4 fragColor, in vec2 fragCoord, in ivec2 gridCoord, in ivec2 textureStartCoord, in bool reverse)\n{\n    float cellSize = (iResolution.x/(float(gridXRealSize)));\n    vec2 originCorner = vec2(gridCoord) * cellSize;\n    \n    ivec2 innerPos = ivec2(fragCoord - originCorner);\n    innerPos = ivec2(vec2(innerPos) * (16.0/float(cellSize)));\n    if(reverse)\n        innerPos = ivec2(15) - innerPos;\n    innerPos += textureStartCoord;\n    vec4 texelValue = texelFetch(MEMORY_CHANNEL, innerPos, 0);\n    if(texelValue.a == 1.0)\n        fragColor = texelValue;\n}\n\nvoid applyTexture(inout vec4 fragColor, in vec2 fragCoord, in ivec2 gridCoord, in ivec2 textureStartCoord)\n{\n    applyTexture(fragColor, fragCoord, gridCoord, textureStartCoord, false);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    ivec2 gridCoord      = coordFromScreenToGrid(fragCoord,iResolution.xy);\n    bool  isInGrid       = isGridCoordInGrid(gridCoord, iResolution.xy);\n    float gameLosed      = texelFetch(MEMORY_CHANNEL, coordIsGameLosed, 0).g;\n    float gameWin        = texelFetch(MEMORY_CHANNEL, coordIsGameWin, 0).g;\n    float timeLastCliked = texelFetch(MEMORY_CHANNEL, coordLastClickedTime, 0).r;\n    \n    \n    fragCoord += (vec2(sin(iTime*50.)*5.0,cos(iTime*50.)*5.0) * gameLosed * step(iTime - timeLastCliked, 0.1)); // wiggle the screen only if the game is loosed and the last click happened les than 0.1 ago\n    \n    \n    ivec2 cursorGridCoord = coordFromScreenToGrid(iMouse.xy,iResolution.xy);\n    \n    if(isInGrid)\n    {        \n        vec4 boxTatus = texelFetch(MEMORY_CHANNEL, gridCoord, 0);\n\n        if(boxTatus.g == 0.0) // the cell has not been revelde\n        {\n            if(boxTatus.a != 0.0) // a flag is placed ont the cell\n            {\n                applyTexture(fragColor, fragCoord, gridCoord, coordTextureUClicked, gridCoord == cursorGridCoord && iMouse.z > 0.0);\n                applyTexture(fragColor, fragCoord, gridCoord, coordTextureFlag);\n            }\n            else // no flag on the cell\n            {\n                applyTexture(fragColor, fragCoord, gridCoord, coordTextureUClicked, gridCoord == cursorGridCoord && iMouse.z > 0.0);\n            }\n            \n        }\n        else // the cell is revealed\n        {\n        \n            if(boxTatus.r == 1.0) // it's a bomb\n            {\n                applyTexture(fragColor, fragCoord, gridCoord, coordTextureMine);\n            }\n            else if(boxTatus.r == 2.0) // it's a bomb clicked\n            {\n                applyTexture(fragColor, fragCoord, gridCoord, coordTextureMineC);\n            }\n            else // it's not a bomb therefore it's a number\n            {\n                int cellNumber = int(boxTatus.b);\n                applyTexture(fragColor, fragCoord, gridCoord, texturesCoordTab[cellNumber]);\n            }\n            \n        }\n        \n    }\n    else\n    {\n        fragColor = colors[1];\n    }\n    \n#if SHOW_MEMORY\n    fragColor = texelFetch(MEMORY_CHANNEL, gridCoord, 0);\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor.b /= 4.0;\n    if(texture(iChannel0,uv).r +texture(iChannel0,uv).g + texture(iChannel0,uv).b + texture(iChannel0,uv).a !=0. )\n        fragColor = mix(fragColor, texture(iChannel0,uv), 0.9);    \n#endif\n        \n    \n    if(isInsideSmiley(fragCoord.xy, iResolution.xy)) // manage smiley button\n    {\n        vec2 centerPos = iResolution.xy*smileyButtonPos;\n        float halfSize = iResolution.x*(smileyButtonSizeX/2.);\n        float cellSize = iResolution.x*(smileyButtonSizeX);\n        vec2 originCorner = centerPos - vec2(halfSize);\n        \n        ivec2 innerPos = ivec2(fragCoord - originCorner);\n        innerPos = ivec2(vec2(innerPos) * (16./float(cellSize)));\n        if(isInsideSmiley(iMouse.xy, iResolution.xy))\n            innerPos = ivec2(15) - innerPos;\n        innerPos += coordTextureUClicked;\n        fragColor = texelFetch(MEMORY_CHANNEL, innerPos, 0);\n\n        fragColor = mix(fragColor, vec4(1.0,0.0,0.0,1.0), gameLosed * 0.5);\n        fragColor = mix(fragColor, vec4(0.0,1.0,0.0,1.0), gameWin   * 0.5);\n    }\n    \n    // red flash if the game is losed and last click waas less than 0.2s ago\n    fragColor = mix(fragColor, vec4(1.0,0.0,0.0,1.0), step(iTime - timeLastCliked, 0.2) * gameLosed * 0.2);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/*\n\nCONTROLS :\n\n    - LEFT CLICK            : revel the cell below the cursor\n    - SHIFT + LEFT CLICK    : place a flag\n    - R or click the smiley : regenerate the grid\n    \nYou can change : \n    - the size of the grid, see : GRID_X_SIZE\n    - the probability for a mine to be placed, see : MINE_PROBA\n*/\n\n\n//------------ change these to suit yout needs ------------//\n#define GRID_X_SIZE 22\n#define MINE_PROBA 0.10\n#define SHOW_MEMORY 0\n\n\n\n/*\nTODO AMELIORATIONS :\n    - add smiley\n    - show time taken\n    - add buttom to activate flag, so the user does not have to press the shiftKey\n\n*/\n\n\n//------------ MEMORY ------------//\n#define MEMORY_CHANNEL iChannel0\n#define GAME_STATE_SEPARATOR ivec2(0,1)\n#define TEXTURE_SEPARATOR ivec2(17,0)\n#define CELL_SIZE (iResolution.x/(float(gridXRealSize)))\nconst int gridXRealSize = GRID_X_SIZE + 2;\n// game state\nconst ivec2 coordIsMinePlaced           = ivec2(gridXRealSize+1,0);\nconst ivec2 coordIsNumGenerated         = coordIsMinePlaced           + GAME_STATE_SEPARATOR;\nconst ivec2 coordIsTextureStored        = coordIsNumGenerated         + GAME_STATE_SEPARATOR;\nconst ivec2 coordIsGameLosed            = coordIsTextureStored        + GAME_STATE_SEPARATOR;\nconst ivec2 coordNumberOfMines          = coordIsGameLosed            + GAME_STATE_SEPARATOR;\nconst ivec2 coordNumberOfReveledNotBomb = coordNumberOfMines          + GAME_STATE_SEPARATOR;\nconst ivec2 coordIsGameWin              = coordNumberOfReveledNotBomb + GAME_STATE_SEPARATOR;\nconst ivec2 coordIsJustClicked          = coordIsGameWin              + GAME_STATE_SEPARATOR;\nconst ivec2 coordFirstFrame             = coordIsJustClicked          + GAME_STATE_SEPARATOR;\nconst ivec2 coordLastClickedTime        = coordFirstFrame             + GAME_STATE_SEPARATOR;\n// textures\nconst ivec2 coordTexture0        = coordIsMinePlaced + ivec2(1,0);\nconst ivec2 coordTexture1        = coordTexture0 + TEXTURE_SEPARATOR;\nconst ivec2 coordTexture2        = coordTexture1 + TEXTURE_SEPARATOR;\nconst ivec2 coordTexture3        = coordTexture2 + TEXTURE_SEPARATOR;\nconst ivec2 coordTexture4        = coordTexture3 + TEXTURE_SEPARATOR;\nconst ivec2 coordTexture5        = coordTexture4 + TEXTURE_SEPARATOR;\nconst ivec2 coordTexture6        = coordTexture5 + TEXTURE_SEPARATOR;\nconst ivec2 coordTexture7        = coordTexture6 + TEXTURE_SEPARATOR;\nconst ivec2 coordTexture8        = coordTexture7 + TEXTURE_SEPARATOR;\nconst ivec2 coordTextureMine     = coordTexture8 + TEXTURE_SEPARATOR;\nconst ivec2 coordTextureMineC    = coordTextureMine     + TEXTURE_SEPARATOR;\nconst ivec2 coordTextureUClicked = coordTextureMineC    + TEXTURE_SEPARATOR;\nconst ivec2 coordTextureFlag     = coordTextureUClicked + TEXTURE_SEPARATOR;\nconst ivec2 texturesCoordTab[9]  = ivec2[9] (coordTexture0, coordTexture1, coordTexture2, coordTexture3, coordTexture4, coordTexture5, coordTexture6, coordTexture7, coordTexture8);\n\n\n//------------ TOP AREA & SMILEY ------------//\nconst vec2 smileyButtonPos = vec2(0.5,0.95);\nconst float smileyButtonSizeX = 0.04;\nconst float topArea = 0.9;\n\nbool isInsideSmiley(vec2 fragCoord, vec2 resolution)\n{\n    vec2 centerPos = resolution*smileyButtonPos;\n    float halfSize = resolution.x*(smileyButtonSizeX/2.);\n    if(fragCoord.x >= (centerPos.x-halfSize)\n    && fragCoord.x <= (centerPos.x+halfSize)\n    && fragCoord.y >= (centerPos.y-halfSize)\n    && fragCoord.y <= (centerPos.y+halfSize) )\n    {\n        return true;\n    }\n    return false;\n}\n\n\n//------------ RANDOM GENERATOR ------------//\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy*2.0, vec2(12.9898, 78.233))) * (45.1654561 + mod((iDate.w * 3600.0), 60.0)));\n}\n\n\n//------------ TEXEL PROCESSING UTILS ------------//\nconst int pixelKernelSize = 8;\nconst vec2 pixelKernel[pixelKernelSize] = vec2[pixelKernelSize](\n    vec2(0.,1.),vec2(0.,-1.),vec2(1.,0.),vec2(-1.,0.),\n    vec2(1.,1.),vec2(-1.,-1.),vec2(1.,-1.),vec2(-1.,1.)\n    );\n\n//------------ PROCESS COORD ------------//\nivec2 coordFromScreenToGrid(in vec2 coord, in vec2 iResolution)\n{\n    float tmpY = coord.y / CELL_SIZE;\n    float tmpX = coord.x / CELL_SIZE;\n    return ivec2(tmpX, tmpY);\n}\n\nbool isGridCoordInGrid(in ivec2 gridCoord, in vec2 iResolution)\n{\n    return \n        int(gridCoord.x) >= 0 \n        && int(gridCoord.x) < gridXRealSize \n        && int(gridCoord.y) >= 0 \n        && int(gridCoord.y) <= int((iResolution.y*topArea) / CELL_SIZE) - 1\n        ;\n}\n\n\nbool isBomb     (in vec4 cellStatus) { return cellStatus.r > 0.0; }\nbool isRevealed (in vec4 cellStatus) { return cellStatus.g > 0.0; }\nbool isNumber   (in vec4 cellStatus) { return cellStatus.b > 0.0; }\nint  getNumber  (in vec4 cellStatus) { return int(cellStatus.b) ; }\nbool isFlaged   (in vec4 cellStatus) { return cellStatus.a > 0.0; }\nbool isTrue     (in vec4 cellStatus) { return cellStatus.g > 0.0; }\n\n\n\n\n//------------ TEXTURES DATA ------------//\nconst vec4 colors[13] = vec4[13](\n        vec4(1.0), // white\n        vec4(vec3(0.667),1.), // light grey\n        vec4(vec3(0.333),1.), // dark grey\n        vec4(vec3(0.01),1.), // black\n        vec4(0.,0.,1.,1.), // blue\n        vec4(0., 0.5, 0.0, 1.0), // green\n        vec4(1., 0., 0., 1.), // red\n        vec4(0.34, 0., 0.66, 1.0), // purple\n        vec4(0.5, 0., 0., 1.), // dark red\n        vec4(0., 0.5, 0.5, 1.0), // cyan\n        vec4(0., 0.0, 0.5, 1.0),// dark blue\n        vec4(1.0,1.0,0.0,1.0), //yellow\n        vec4(0.0,0.0,0.0,0.0)); // nothing\n        \nconst int pixelsMine[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1, // 2\n        2,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1, // 3\n        2,1,1,1,3,1,3,3,3,3,3,1,3,1,1,1, // 4\n        2,1,1,1,1,3,3,3,3,3,3,3,1,1,1,1, // 5\n        2,1,1,1,3,3,0,0,3,3,3,3,3,1,1,1, // 6\n        2,1,1,1,3,3,0,0,3,3,3,3,3,1,1,1, // 7\n        2,1,3,3,3,3,3,3,3,3,3,3,3,3,3,1, // 8\n        2,1,1,1,3,3,3,3,3,3,3,3,3,1,1,1, // 9\n        2,1,1,1,3,3,3,3,3,3,3,3,3,1,1,1, // 10\n        2,1,1,1,1,3,3,3,3,3,3,3,1,1,1,1, // 11\n        2,1,1,1,3,1,3,3,3,3,3,1,3,1,1,1, // 12\n        2,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \n        \nconst int pixelsMineClicked[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, // 1\n        2,6,6,6,6,6,6,6,3,6,6,6,6,6,6,6, // 2\n        2,6,6,6,6,6,6,6,3,6,6,6,6,6,6,6, // 3\n        2,6,6,6,3,6,3,3,3,3,3,6,3,6,6,6, // 4\n        2,6,6,6,6,3,3,3,3,3,3,3,6,6,6,6, // 5\n        2,6,6,6,3,3,0,0,3,3,3,3,3,6,6,6, // 6\n        2,6,6,6,3,3,0,0,3,3,3,3,3,6,6,6, // 7\n        2,6,3,3,3,3,3,3,3,3,3,3,3,3,3,6, // 8\n        2,6,6,6,3,3,3,3,3,3,3,3,3,6,6,6, // 9\n        2,6,6,6,3,3,3,3,3,3,3,3,3,6,6,6, // 10\n        2,6,6,6,6,3,3,3,3,3,3,3,6,6,6,6, // 11\n        2,6,6,6,3,6,3,3,3,3,3,6,3,6,6,6, // 12\n        2,6,6,6,6,6,6,6,3,6,6,6,6,6,6,6, // 13\n        2,6,6,6,6,6,6,6,3,6,6,6,6,6,6,6, // 14\n        2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6  // 15\n        );\n        \nconst int pixels8[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,1,3,3,3,3,3,3,3,3,1,1,1,1, // 3\n        2,1,1,3,3,3,3,3,3,3,3,3,3,1,1,1, // 4\n        2,1,1,3,3,3,1,1,1,1,3,3,3,1,1,1, // 5\n        2,1,1,3,3,3,1,1,1,1,3,3,3,1,1,1, // 6\n        2,1,1,1,3,3,3,3,3,3,3,3,1,1,1,1, // 7\n        2,1,1,1,3,3,3,3,3,3,3,3,1,1,1,1, // 8\n        2,1,1,3,3,3,1,1,1,1,3,3,3,1,1,1, // 9\n        2,1,1,3,3,3,1,1,1,1,3,3,3,1,1,1, // 10\n        2,1,1,3,3,3,3,3,3,3,3,3,3,1,1,1, // 11\n        2,1,1,1,3,3,3,3,3,3,3,3,1,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \nconst int pixels7[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,7,7,7,7,7,7,7,7,7,7,1,1,1, // 3\n        2,1,1,7,7,7,7,7,7,7,7,7,7,1,1,1, // 4\n        2,1,1,1,1,1,1,1,1,1,7,7,7,1,1,1, // 5\n        2,1,1,1,1,1,1,1,1,1,7,7,7,1,1,1, // 6\n        2,1,1,1,1,1,1,1,1,7,7,7,1,1,1,1, // 7\n        2,1,1,1,1,1,1,1,1,7,7,7,1,1,1,1, // 8\n        2,1,1,1,1,1,1,1,7,7,7,1,1,1,1,1, // 9\n        2,1,1,1,1,1,1,1,7,7,7,1,1,1,1,1, // 10\n        2,1,1,1,1,1,1,7,7,7,1,1,1,1,1,1, // 11\n        2,1,1,1,1,1,1,7,7,7,1,1,1,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \nconst int pixels6[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,1,9,9,9,9,9,9,9,9,1,1,1,1, // 3\n        2,1,1,9,9,9,9,9,9,9,9,9,1,1,1,1, // 4\n        2,1,1,9,9,9,1,1,1,1,1,1,1,1,1,1, // 5\n        2,1,1,9,9,9,1,1,1,1,1,1,1,1,1,1, // 6\n        2,1,1,9,9,9,9,9,9,9,9,9,1,1,1,1, // 7\n        2,1,1,9,9,9,9,9,9,9,9,9,9,1,1,1, // 8\n        2,1,1,9,9,9,1,1,1,1,9,9,9,1,1,1, // 9\n        2,1,1,9,9,9,1,1,1,1,9,9,9,1,1,1, // 10\n        2,1,1,9,9,9,9,9,9,9,9,9,9,1,1,1, // 11\n        2,1,1,1,9,9,9,9,9,9,9,9,1,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \nconst int pixels5[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,8,8,8,8,8,8,8,8,8,8,1,1,1, // 3\n        2,1,1,8,8,8,8,8,8,8,8,8,8,1,1,1, // 4\n        2,1,1,8,8,8,1,1,1,1,1,1,1,1,1,1, // 5\n        2,1,1,8,8,8,1,1,1,1,1,1,1,1,1,1, // 6\n        2,1,1,8,8,8,8,8,8,8,8,8,1,1,1,1, // 7\n        2,1,1,8,8,8,8,8,8,8,8,8,8,1,1,1, // 8\n        2,1,1,1,1,1,1,1,1,1,8,8,8,1,1,1, // 9\n        2,1,1,1,1,1,1,1,1,1,8,8,8,1,1,1, // 10\n        2,1,1,8,8,8,8,8,8,8,8,8,8,1,1,1, // 11\n        2,1,1,8,8,8,8,8,8,8,8,8,1,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \nconst int pixels4[256] = int[256] (\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0\n        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 1\n        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 2\n        2, 1, 1, 1, 1,10,10,10, 1,10,10,10, 1, 1, 1, 1, // 3\n        2, 1, 1, 1, 1,10,10,10, 1,10,10,10, 1, 1, 1, 1, // 4\n        2, 1, 1, 1,10,10,10, 1, 1,10,10,10, 1, 1, 1, 1, // 5\n        2, 1, 1, 1,10,10,10, 1, 1,10,10,10, 1, 1, 1, 1, // 6\n        2, 1, 1,10,10,10,10,10,10,10,10,10,10, 1, 1, 1, // 7\n        2, 1, 1,10,10,10,10,10,10,10,10,10,10, 1, 1, 1, // 8\n        2, 1, 1, 1, 1, 1, 1, 1, 1,10,10,10, 1, 1, 1, 1, // 9\n        2, 1, 1, 1, 1, 1, 1, 1, 1,10,10,10, 1, 1, 1, 1, // 10\n        2, 1, 1, 1, 1, 1, 1, 1, 1,10,10,10, 1, 1, 1, 1, // 11\n        2, 1, 1, 1, 1, 1, 1, 1, 1,10,10,10, 1, 1, 1, 1, // 12\n        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 13\n        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 14\n        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // 15\n        );\n        \nconst int pixels3[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,6,6,6,6,6,6,6,6,6,1,1,1,1, // 3\n        2,1,1,6,6,6,6,6,6,6,6,6,6,1,1,1, // 4\n        2,1,1,1,1,1,1,1,1,1,6,6,6,1,1,1, // 5\n        2,1,1,1,1,1,1,1,1,1,6,6,6,1,1,1, // 6\n        2,1,1,1,1,1,6,6,6,6,6,6,1,1,1,1, // 7\n        2,1,1,1,1,1,6,6,6,6,6,6,1,1,1,1, // 8\n        2,1,1,1,1,1,1,1,1,1,6,6,6,1,1,1, // 9\n        2,1,1,1,1,1,1,1,1,1,6,6,6,1,1,1, // 10\n        2,1,1,6,6,6,6,6,6,6,6,6,6,1,1,1, // 11\n        2,1,1,6,6,6,6,6,6,6,6,6,1,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \nconst int pixels2[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,1,5,5,5,5,5,5,5,5,1,1,1,1, // 3\n        2,1,1,5,5,5,5,5,5,5,5,5,5,1,1,1, // 4\n        2,1,1,5,5,5,1,1,1,1,5,5,5,1,1,1, // 5\n        2,1,1,1,1,1,1,1,1,1,5,5,5,1,1,1, // 6\n        2,1,1,1,1,1,1,1,5,5,5,5,1,1,1,1, // 7\n        2,1,1,1,1,1,5,5,5,5,5,1,1,1,1,1, // 8\n        2,1,1,1,5,5,5,5,5,1,1,1,1,1,1,1, // 9\n        2,1,1,5,5,5,5,1,1,1,1,1,1,1,1,1, // 10\n        2,1,1,5,5,5,5,5,5,5,5,5,5,1,1,1, // 11\n        2,1,1,5,5,5,5,5,5,5,5,5,5,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \nconst int pixels1[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1, // 3\n        2,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1, // 4\n        2,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1, // 5\n        2,1,1,1,1,4,4,4,4,4,1,1,1,1,1,1, // 6\n        2,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1, // 7\n        2,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1, // 8\n        2,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1, // 9\n        2,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1, // 10\n        2,1,1,1,1,4,4,4,4,4,4,4,1,1,1,1, // 11\n        2,1,1,1,1,4,4,4,4,4,4,4,1,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \n        \nconst int pixels0[256] = int[256] (\n        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 1\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 2\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 3\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 4\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 5\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 6\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 7\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 8\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 9\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 10\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 11\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 12\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 13\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 14\n        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1  // 15\n        );\n        \nconst int pixelsUClicked[256] = int[256] (\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1, // 0\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2, // 1\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 2\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 3\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 4\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 5\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 6\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 7\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 8\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 9\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 10\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 11\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 12\n        0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2, // 13\n        0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 14\n        1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2  // 15\n        );\n        \n        \nconst int pixelsFlag[256] = int[256] (\n        12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, // 0\n        12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, // 1\n        12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, // 2\n        12,12,12,12,12,12,12,12, 6,12,12,12,12,12,12,12, // 3\n        12,12,12,12,12,12, 6, 6, 6,12,12,12,12,12,12,12, // 4\n        12,12,12,12,12, 6, 6, 6, 6,12,12,12,12,12,12,12, // 5\n        12,12,12,12,12, 6, 6, 6, 6,12,12,12,12,12,12,12, // 6\n        12,12,12,12,12,12, 6, 6, 6,12,12,12,12,12,12,12, // 7\n        12,12,12,12,12,12,12,12, 6,12,12,12,12,12,12,12, // 8\n        12,12,12,12,12,12,12,12, 3,12,12,12,12,12,12,12, // 9\n        12,12,12,12,12, 3, 3, 3, 3, 3, 3,12,12,12,12,12, // 10\n        12,12,12, 3, 3, 3, 3, 3, 3, 3, 3, 3,12,12,12,12, // 11\n        12,12,12, 3, 3, 3, 3, 3, 3, 3, 3, 3,12,12,12,12, // 12\n        12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, // 13\n        12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, // 14\n        12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12  // 15\n        );\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define SHIFT_PRESSED         ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0. )\n#define R_PRESSED             ( texelFetch(iChannel3,ivec2(82,0),0).x  > 0. )\n\nvec4 readMemory(in ivec2 coord) { return texelFetch(MEMORY_CHANNEL, coord, 0); }\nvec4 readMemory(in vec2 coord)  { return readMemory(ivec2(coord)); }\n\nvoid writeMemory(inout vec4 fragColor, in ivec2 iFragCoord, in ivec2 adress, in vec4 value)\n{\n    if(iFragCoord == adress)\n            fragColor = value;\n}\n\nbool isCoordInGridMemory( in vec2 coord )\n{\n    bool inBound = true;\n    if(coord.x < 0. || coord.y < 0. || int(coord.x) > GRID_X_SIZE+1 || int(coord.y) > int((iResolution.y*topArea) / CELL_SIZE) - 1)\n    {\n        inBound = false;\n    }\n    return inBound;\n}\n\n\nbool storeTexture(inout vec4 fragColor,const in vec2 fragCoord,const in ivec2 textureStartCoord, const in int[256] textureData)\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if(iFragCoord.x >= textureStartCoord.x && iFragCoord.x < textureStartCoord.x+16 && iFragCoord.y >= textureStartCoord.y && iFragCoord.y < textureStartCoord.y+16)\n    {\n        int subPosX = iFragCoord.x - textureStartCoord.x;\n        int subPosY = iFragCoord.y - textureStartCoord.y;\n\n        fragColor= colors[textureData[(15-subPosY)*16 + subPosX]];\n        return true;\n    }\n    return false;\n}\n\nvoid firstFrame(inout vec4 fragColor, in ivec2 iFragCoord)\n{\n    bool isFirstFrame      = readMemory(coordFirstFrame).g != 0.5;    \n    if(!isFirstFrame ) // if it's the first frame of the game then we init the screen to black \n    {\n        fragColor = vec4(vec3(0.0),1.0);\n        writeMemory(fragColor, iFragCoord, coordFirstFrame, vec4(vec3(0.5),1.0));\n    }\n}\n\nvoid placeMines(inout vec4 fragColor, in ivec2 fragCoord)\n{\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    bool b_coordInGridMemory = isCoordInGridMemory(fragCoord);  \n    \n    // game state\n    bool isMinePlaced    = isTrue(readMemory(coordIsMinePlaced    ));\n    bool isNumGenerated  = isTrue(readMemory(coordIsNumGenerated  ));\n    bool isTextureStored = isTrue(readMemory(coordIsTextureStored ));\n    bool isGameLosed     = isTrue(readMemory(coordIsGameLosed     ));\n    bool isGameWin       = isTrue(readMemory(coordIsGameWin       ));\n    \n    \n    firstFrame(fragColor, iFragCoord); // (frame 0)\n    if(!isMinePlaced) // PLACE MINES (frame 1)\n    {\n        float randomNum = rand(fragCoord);\n        fragColor = vec4(step(randomNum , MINE_PROBA), 0.0,0.0,0.0);\n        if(iFragCoord == coordIsMinePlaced)\n        {\n            fragColor = vec4(0.0,1.0,0.0,0.0);\n        }\n    }\n    else if(!isNumGenerated) // GENERATE DIGITS ARROUND MINES (frame 2)\n    {\n        if(b_coordInGridMemory && !isBomb(readMemory(iFragCoord))) \n        {\n            int numOfBombs = 0;\n            vec2 toCheckCoord;\n            for(int i = 0 ; i < pixelKernelSize; i++)\n            {\n                toCheckCoord = fragCoord + pixelKernel[i];\n                if(isCoordInGridMemory(toCheckCoord) && isBomb(readMemory(toCheckCoord)))\n                {\n                    numOfBombs++;\n                }\n            }\n            fragColor = vec4(0.0,0.0,float(numOfBombs),0.0);\n            \n        }\n        else\n        {\n            fragColor = texelFetch(MEMORY_CHANNEL, iFragCoord, 0);\n        }\n        \n        \n        if(iFragCoord == coordIsNumGenerated)\n        {\n            fragColor = vec4(0.0,1.0,0.0,0.0);\n        }\n    }\n    else if(!isTextureStored) // STORE TEXTURES IN SAVE BUFFER (frame 3)\n    {\n    \n        fragColor = texelFetch(MEMORY_CHANNEL, iFragCoord, 0);\n         \n        storeTexture(fragColor,  fragCoord, coordTexture0,        pixels0);\n        storeTexture(fragColor,  fragCoord, coordTexture1,        pixels1);\n        storeTexture(fragColor,  fragCoord, coordTexture2,        pixels2);\n        storeTexture(fragColor,  fragCoord, coordTexture3,        pixels3);\n        storeTexture(fragColor,  fragCoord, coordTexture4,        pixels4);\n        storeTexture(fragColor,  fragCoord, coordTexture5,        pixels5);\n        storeTexture(fragColor,  fragCoord, coordTexture6,        pixels6);\n        storeTexture(fragColor,  fragCoord, coordTexture7,        pixels7);\n        storeTexture(fragColor,  fragCoord, coordTexture8,        pixels8);\n        storeTexture(fragColor,  fragCoord, coordTextureMine,     pixelsMine);\n        storeTexture(fragColor,  fragCoord, coordTextureMineC,    pixelsMineClicked);\n        storeTexture(fragColor,  fragCoord, coordTextureUClicked, pixelsUClicked);\n        storeTexture(fragColor,  fragCoord, coordTextureFlag,     pixelsFlag);\n            \n            \n        if(iFragCoord == coordIsTextureStored)\n        {\n            fragColor = vec4(0.0,1.0,0.0,0.0);\n        }\n        \n        \n        if(iFragCoord == coordNumberOfMines)\n        {\n            for(int x = 0 ; x <= GRID_X_SIZE+1 ; x ++)\n            {\n                for(int y = 0 ; y <= int((iResolution.y*topArea) / CELL_SIZE) - 1; y++)\n                {\n                    ivec2 currentCoordToLook = ivec2(x,y);\n                    vec4 cellStatus = texelFetch(MEMORY_CHANNEL, currentCoordToLook, 0);\n                    if(isBomb(cellStatus))\n                    {\n                        fragColor += vec4(1.0);\n                    }\n                }\n            }\n        }\n    }\n    else // MANAGE GAME (frame 4+n)\n    {\n        fragColor = texelFetch(MEMORY_CHANNEL, iFragCoord, 0);\n        \n        bool isClicked = (iMouse.z > 0.0); // true if the mouse just clicked\n        \n        if(isClicked && iFragCoord == coordIsJustClicked)\n        {\n            fragColor = vec4(1.0);\n        }\n        \n        bool justReleased = false;\n        bool wasClicked = texelFetch(MEMORY_CHANNEL, coordIsJustClicked, 0).g > 0.0;\n        \n        if(wasClicked && !isClicked)\n        {\n            justReleased = true;\n            if(iFragCoord == coordIsJustClicked)\n            {\n                fragColor = vec4(0.0);\n            }\n        }\n        \n        if(justReleased) // the click just released\n        {\n            ivec2 clickGridCoord = coordFromScreenToGrid(iMouse.xy,iResolution.xy);\n            if(!isGameWin && !isGameLosed && isGridCoordInGrid(clickGridCoord,iResolution.xy))\n            {\n                if(clickGridCoord == iFragCoord)\n                {\n                    fragColor = texelFetch(MEMORY_CHANNEL, iFragCoord, 0);\n                    if(SHIFT_PRESSED) // if shift is pressed, then we place a flag\n                    {\n                        fragColor = vec4(fragColor.rgb,1.0-fragColor.a); \n                    }\n                    else // otherwise the cell is revealed\n                    {\n                        fragColor = vec4(fragColor.r,1.0,fragColor.ba);\n                        if(isBomb(readMemory(fragCoord))) // if it's a bomb then bomb is considered as detonated \n                        {\n                            fragColor.r = 2.0;\n                        }\n                    }\n                }\n                if(iFragCoord == coordNumberOfReveledNotBomb && !isGameLosed && !isBomb(readMemory(clickGridCoord)))\n                {\n                    fragColor += vec4(1.0);\n                }\n            }\n            if(isInsideSmiley(iMouse.xy, iResolution.xy) && iFragCoord.x == coordIsMinePlaced.x)\n            {\n                fragColor = vec4(vec3(0.0),1.0);\n            }\n            if(iFragCoord == coordLastClickedTime)\n            {\n                fragColor = vec4(iTime);\n            }\n        }\n        if(R_PRESSED && iFragCoord.x == coordIsMinePlaced.x) // put all memory flags to black, so it knows to regenerate the game\n        {\n            fragColor = vec4(vec3(0.0),1.0);\n        }\n        \n        if(b_coordInGridMemory) // reveal cells adjacents to an other revealed cell\n        {\n            vec4 currentSate = texelFetch(MEMORY_CHANNEL, iFragCoord, 0);\n            \n            for(int i = 0 ; i < pixelKernelSize; i++)\n            {\n                bool neighborInBound = isCoordInGridMemory(fragCoord+pixelKernel[i]);\n                vec4 neighborValue = texelFetch(MEMORY_CHANNEL, ivec2(fragCoord+pixelKernel[i]), 0);\n                if(neighborInBound && neighborValue.g != 0.0 && neighborValue.b == 0.0 && neighborValue.r == 0.0)\n                {\n                    fragColor = texelFetch(MEMORY_CHANNEL, iFragCoord, 0);\n                    fragColor += vec4(0.0,1.0,0.0,0.0);\n                }\n            }\n        }\n        \n        if(!isGameLosed && !isGameWin)\n        {\n            if(iFragCoord == coordIsGameLosed) // test if the game is loosed\n            {\n                for(int x = 0 ; x <= GRID_X_SIZE+1 ; x ++)\n                {\n                    for(int y = 0 ; y <= int((iResolution.y*topArea) / CELL_SIZE) - 1; y++)\n                    {\n                        ivec2 currentCoordToLook = ivec2(x,y);\n                        vec4 cellStatus = texelFetch(MEMORY_CHANNEL, currentCoordToLook, 0);\n                        if(isBomb(cellStatus) && cellStatus.g != 0.0)\n                        {\n                            fragColor = vec4(1.0,1.0,0.0,1.0);\n                        }\n                    }\n                }\n            }\n            if(iFragCoord == coordIsGameWin ) // test if the game is won\n            {\n                int numberOfReveledNotBomb = 0;\n                int numberOfCells = 0;\n                for(int x = 0 ; x <= GRID_X_SIZE+1 ; x ++)\n                {\n                    for(int y = 0 ; y <= int((iResolution.y*topArea) / CELL_SIZE) - 1; y++)\n                    {\n                        ivec2 currentCoordToLook = ivec2(x,y);\n                        vec4 cellStatus = texelFetch(MEMORY_CHANNEL, currentCoordToLook, 0);\n                        if(cellStatus.g != 0.0)\n                        {\n                            numberOfReveledNotBomb += 1;\n                        }\n                        numberOfCells++;\n                    }\n                }\n                int numberOfBombs = int(texelFetch(MEMORY_CHANNEL, coordNumberOfMines, 0).g );\n                if(numberOfCells - numberOfReveledNotBomb <= numberOfBombs)\n                {\n                    fragColor = vec4(1.0);\n                }\n            }\n        }\n        else // if the game is over, then it reveals all bombs\n        {\n            if(isCoordInGridMemory(fragCoord) && isBomb(readMemory(iFragCoord)))\n            {\n                fragColor.g = 1.0;\n            }\n        }\n    }    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lfdBDM","date":"1734442719","viewed":224,"name":"Minesweeper in Shader","username":"Noctiluce","description":"Minesweeper, lost so many hours playing this game as a child.\nThought I could spend some more remaking it in shader :)\n\nsee Common tab for controls ","likes":18,"published":1,"flags":48,"usePreview":0,"tags":["game","sprite","minesweeper"],"hasliked":0,"parentid":"","parentname":""}}