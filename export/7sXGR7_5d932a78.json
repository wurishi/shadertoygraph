{"ver":"0.1","info":{"id":"7sXGR7","date":"1615675977","viewed":108,"name":"Quaternion for Julia 2","username":"kovacjosh","description":"Quaternion equivalent for the Julila set with power of 2 rendered with ray-marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxSteps = 100.;\nconst int iMaxSteps = 100;\nconst float hitThreshold = .0008;\nconst float maxDistance = 1000.;\nconst float specExp = 8.;\nconst float AA = 2.;\n\n// Self dot-product helper functions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    vec3 color;\n};\n\nstruct Triangle\n{\n  vec3 a;\n  vec3 b;\n  vec3 c;\n  vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\n\n\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\n\nmat3 rotMat(vec3 u, float t)\n{\n    float c = cos(t);\n    float nc = 1. - cos(t);\n    float s = sin(t);\n    float xy = u.x*u.y;\n    float yz = u.y*u.z;\n    float xz = u.x*u.z;\n    return mat3(\n        c+u.x*u.x*nc, xy*nc+u.z*s, xz*nc-u.y*s,\n        xy*nc-u.z*s, c+u.y*u.y*nc, yz*nc+u.x*s,\n        xz*nc+u.y*s, yz*nc-u.x*s,  c+u.z*u.z*nc\n    );\n}\n\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p - s.center) - s.radius, s.color);\n}\n\nHit boxSDF( vec3 p, Box b )\n{\n  vec3 q = abs(p - b.center) - (b.size);\n  float radius = 0.05;\n  return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);\n}\n\nHit triangleSDF(vec3 p, Triangle tri)\n{\n    vec3 ba = tri.b - tri.a; vec3 pa = p - tri.a;\n    vec3 cb = tri.c - tri.b; vec3 pb = p - tri.b;\n    vec3 ac = tri.a - tri.c; vec3 pc = p - tri.c;\n    vec3 nor = cross( ba, ac );\n\n    float dist = sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(ac,nor),pc))<2.0)\n         ?\n         min( min(\n         dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n         dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n         dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n         :\n         dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n    return Hit(dist, tri.color);\n}\n\n// Signed distance functions for different shapes\n\nHit mandelbulbSDF(vec3 p)\n{\n    float power = 8.;\n    vec3 z = p;\n    float dr = 1.;\n    float r;\n    vec3 c1 = vec3(1., 1., 1.);\n    vec3 c2 = vec3(1., 0., 0.) * .02;\n    \n    for (int i = 0; i < 15; i++)\n    {\n        r = length(z);\n        if (r > 2.)\n        {\n            break;\n        }\n        float theta = acos(z.z / r) * power + iTime;\n        float phi = atan(z.y/z.x) * power + iTime;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n        c2 += c2;\n    }\n    return Hit(0.5 * log(r) * r / dr, c1 - c2);\n}\n\nvec4 multQuaterion(vec4 a, vec4 b)\n{\n    return vec4(\n        a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w,\n        a.x*b.y + a.y*b.x + a.z*b.w - a.w*b.z,\n        a.x*b.z - a.y*b.w + a.z*b.x + a.w*b.y,\n        a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x\n    );\n}\n\nHit quaternionSDF2(vec3 p)\n{\n    vec4 c = 0.65*cos( vec4(0.5,3.9,1.4,1.1) + iTime*0.1*vec4(1.7,1.8,1.2,1.5) ) - vec4(0.1,0.4,0.2,0.0);\n    vec4 z = vec4(p, 0.5);\n    float md2 = 1.0; // derivative of min distance, |dz|^2\n    float mz2 = dot(z,z); // min distance to z, will be changed iteratively\n    //float steps = 0.0; // useful for certain coloring techniques\n    for (int i=0; i < 10; i++)\n    {\n        // |dz|^2 = |2z|^2\n        md2 *= 4.0*mz2;\n        // z <- z^2 + c\n        z = multQuaterion(z,z) + c;\n        mz2 = dot(z,z);\n        if(mz2 > 4.0){\n            break;\n        }\n        //steps += 1.0;\n    }\n    \n    float dist = 0.25*sqrt(mz2/md2)*log(mz2);\n    vec3 color = vec3(0.0, 0.0, 1.0) + mz2*vec3(0.2, 0.3, 0.0);\n    return Hit(dist, color);\n    \n}\n\nHit quaternionSDF3(vec3 p)\n{\n    vec4 c = vec4(-0.1,0.6,0.9,-0.3) + 0.1*sin( vec4(3.0,0.0,1.0,2.0) + 0.5*vec4(1.0,1.3,1.7,2.1)*iTime);\n    vec4 z = vec4(p, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n    \n    for (int i=0; i < 10; i++)\n    {\n        vec4 zSqr = multQuaterion(z,z);\n        // |dz|^2 = |3z^2|^2\n        md2 *= 9.0*(dot(zSqr,zSqr));\n        // z <- z^3 + c\n        z = multQuaterion(z, zSqr) + c;\n        \n        md2 = dot(z,z);\n        if(md2 > 10.0) \n        {\n            break;\n        }\n    }\n    \n    float dist = 0.25*sqrt(mz2/md2)*log(mz2);\n    vec3 color = vec3(1.0, 1.0, 0.0) + dot(z,z)*vec3(0.0, 0.0, .5);\n    return Hit(dist, color);\n}\n\n// Smooth min to cause shapes to morph into eachother\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nHit hitMin(Hit a, Hit b)\n{\n    if (a.t < b.t)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nHit hitSMin(Hit a, Hit b, float k)\n{\n    float h = clamp(0.5+0.5*(b.t-a.t)/k, 0.0, 1.0 );\n    float f = mix(b.t, a.t, h) - k*h*(1.0-h);\n    vec3 c = mix(b.color, a.color, h) - k*h*(1.0-h);\n    return Hit(f, c);\n}\n\n// Define the objects in the scene and their relations to eachother\nHit map(vec3 p)\n{\n    mat3 rot = rotMat(vec3(0., 1., 0.), iTime/4.);\n    \n    //return Hit(mb(p).x, vec3(1.));\n    //return mandelbulbSDF(rot * p);\n    //Hit s = sphereSDF(p, Sphere(vec3(0., 0., 0.), .75, vec3(.7, .8, .2)));\n    //Hit b = boxSDF(p, Box(vec3(.0, 0., 0.), vec3(.25), vec3(1., 0., 0.)));\n    //return hitMin(s, b);\n    //return hitSMin(s, b, .1);\n    Hit b = quaternionSDF2(p);\n    return b;\n}\n\n// Calculate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec3 eps = vec3(0.001, 0., 0.);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n        i += 1;\n        if (i > iMaxSteps)\n        {\n            break;\n        }\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 3;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(0., 6., 5.), 20., vec3(1., .2, 0.), 8.),\n        Light(vec3(0., -5., 5.), 2., vec3(1., .5, .1), 8.),\n        Light(vec3(5., 0., 5.), 6., vec3(1., 0., 1.), 1.)\n    );\n    vec3 ambient = vec3(0.8,0.63,0.50) * .05;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        //float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness);\n        \n        float strength = lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glow = vec3(1., 1., 1.) * .7;\n    float t = 0.;\n    float i = 0.;\n    while (i < maxSteps && t <= maxDistance)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color + glow * i/maxSteps;\n        }\n        t += closestHit.t;\n        i += 1.;\n    }\n    return vec3(0.01, 0.02, 0.03) + glow * smoothstep(0., 1.5, i/maxSteps);\n    //return texture(iChannel0, ray.dir).xyz + glow * smoothstep(0., 1.5, i/maxSteps);\n}\n\nvec4 render(in vec3 e, in mat4 view, in vec2 uv) {\n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    return vec4(raymarch(viewRay), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    vec3 e = vec3(sin(iTime*0.1), 0., 1.7);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n        // Convert pixel coordinates to uv coordinates\n    if (AA > 1.) {\n      vec4 average = vec4(0.0);\n      for (float s = 0.; s < AA; s++) {\n        for (float t = 0.; t < AA; t++) {\n            vec2 offset = (vec2(s, t) / AA) - 0.5;\n\n            vec2 uv = (fragCoord + offset)/iResolution.xy * 2. - 1.;\n            uv.y *= iResolution.y/iResolution.x;\n\n            average += render(e, view, uv);\n        }\n      }  \n      average /= AA*AA;\n      fragColor = average;\n    } else {\n      vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n      uv.y *= iResolution.y/iResolution.x;\n\n      fragColor = render(e, view, uv);\n    }\n}","name":"Image","description":"","type":"image"}]}