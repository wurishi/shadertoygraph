{"ver":"0.1","info":{"id":"WdyXzz","date":"1574261840","viewed":320,"name":"Neon Jungle v0.5","username":"Delvar","description":"Flying around a smog filled Mega City, Mouse to free look.\nSome nice wet concrete and a parallax window box effect.","likes":12,"published":1,"flags":64,"usePreview":1,"tags":["reflection","parallax","fog","windows","neon","concrete","megacity","fly","smog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xtf3Ds","filepath":"https://soundcloud.com/freetousesounds/server-room-dark-ambient-drone-sound-effect","previewfilepath":"https://soundcloud.com/freetousesounds/server-room-dark-ambient-drone-sound-effect","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0},{"id":"4tf3Ds","filepath":"https://soundcloud.com/freetousesounds/binaural-airport-sounds-bangkok-intl-airport-soundscape","previewfilepath":"https://soundcloud.com/freetousesounds/binaural-airport-sounds-bangkok-intl-airport-soundscape","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0},{"id":"Xlf3Ds","filepath":"https://soundcloud.com/freetousesounds/new-york-city-traffic-and","previewfilepath":"https://soundcloud.com/freetousesounds/new-york-city-traffic-and","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================================================\n//  'Neon Jungle v0.5'\n//  https://www.shadertoy.com/view/WdyXzz\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tUpdated version of 'Neon Jungle v0.2' https://www.shadertoy.com/view/ws3XRj\n//\n//\tTips on how to optimise it furhter welcome!\n//\tThe 'Face Fog' hides a multitude of sins :)\n//\n//\tCredits: \n//\tIdea sparked from the 2d shader,  mhnewman : 'Descent ' : https://www.shadertoy.com/view/XtSGWD\n//\n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://iquilezles.org/articles/distfunctions\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tWindows inspired by but no longer bassed off otaviogood : 'Skyline' : https://www.shadertoy.com/view/XtsSWs\n//\tStarted from scratch with a parallax affect, lots of info taken from differnt palces but mainly this implementation, https://andrewgotow.com/2018/09/09/interior-mapping-part-1/\n//\tSome very good points here, like making the effect in texture space, and the optimisation of only needing to check 3 faces, which seems obvius once I read it.\n//\tObviusly my implementation doesn't use a cube texture for the interior, instead generates some pastal shaded walls.\n//\tI have added a fade to solid colour at distance too, no point doing the extra work for a window thats only a few pixles wide.\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 250\n#define RAY_MAX_DISTANCE 35.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.001\n\n#define RAY_MAX_STEPS_SHADOW 100\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW 0.001\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET 0.041\n\n#define RAY_MAX_STEPS_REFLECTION 50\n#define RAY_MAX_DISTANCE_REFLECTION 15.0\n#define OBJECT_MIN_SURFACE_DISTANCE_REFLECTION 0.001\n#define OBJECT_MIN_SURFACE_DISTANCE_REFLECTION_OFFSET 0.02\n\n#define PI 3.1415926535897932384626433832795\n\n#define PARALLAX_INTERROOM_WALL_THICKNESS 0.47\n#define PARALLAX_INTERROOM_WALL_COLOUR vec3(0.01)\n#define PARALLAX_WINDOW_SURROUND_THICKNESS 0.1\n#define PARALLAX_WINDOW_SURROUND_COLOUR vec3(0.05)\n\n#define FACE_FOG_DENSITY 0.35\n\n#define DEBUG_RAY_DITHER\n#define DEBUG_CAMERA_FLY\n#define DEBUG_WHITE_NEON\n#define DEBUG_DISTANCE_FOG\n#define DEBUG_FACE_FOG\n#define DEBUG_LIGHTING\n#define DEBUG_AMBIENT\n#define DEBUG_AMBIENT_OCCLUSION\n#define DEBUG_RENDER_RAILS\n#define DEBUG_VIGNETTE\n//#define DEBUG_OCCLUSION   // used instead of DEBUG_AMBIENT_OCCLUSION when you want the efect but without adding DEBUG_AMBIENT or DEBUG_LIGHTING\n#define DEBUG_REFLECTION\n#define DEBUG_REFLECTION_FRESNEL\n#define DEBUG_PARALLAX\n\n\n//change the filtering method, Linier, Smoothstep or Quintic, little visual change when noise is stacked but can impact performance.\n#define VALUE_NOISE_FILTER_SMOOTH\n//#define VALUE_NOISE_FILTER_QUINTIC\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel0\n//#define NOISE_TEXTURE_2D iChannel1\n\n// -- The Materials\n#define MAT_SKY \t0\n#define MAT_WINDOW\t1\n#define MAT_WALL\t2\n#define MAT_SOLID\t3\n#define MAT_RAIL\t4\n#define MAT_NEON\t5\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance;\n    vec3 neon;\n    int materialId;\n    int iteration;\n};\n\n// ========== ==========\n\n// ========== Constants ==========\n\nconst float gridSize = 5.0;\nconst float gridSizeH = gridSize*0.5;\nconst float gridSizeQ = gridSize*0.25;\n\nconst float roadLength = gridSize*5.0;\nconst float roadLengthH = roadLength*0.5;\nconst float roadLengthQ = roadLength*0.25;\n\nconst float roadWidth = gridSize;\nconst float roadWidthH = roadWidth*0.5;\nconst float roadWidthQ = roadWidth*0.25;\n\nconst float blockSize = roadLength + gridSize;\nconst float blockSizeH = blockSize*0.5;\nconst float blockSizeQ = blockSize*0.25;\n\nconst vec3 roadLightColour = vec3(0.9,0.6,0.1);\nconst float roadLightBrightness = 5.0;\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\n\nray getRefRay(vec3 origin, vec3 normal, vec3 originalDirection) {\n    ray ray;\n    ray.direction = normalize(reflect(originalDirection, normal));\n    ray.origin = origin + ray.direction*OBJECT_MIN_SURFACE_DISTANCE_REFLECTION_OFFSET;\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HD 43758.5453123\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st*HE)*HD); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec3(HE,HF,HG)))*HD);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HD);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HG))*HD);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nvec3 valueNoiseFilter(vec3 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nvec2 valueNoiseFilter(vec2 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat valueNoiseFilter(float x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat lengthSquare(vec2 a) {\n    return dot(a,a);\n}\n\nfloat lengthSquare(vec3 a) {\n    return dot(a,a);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n// - Value Noise, 3d, Unsigned\nfloat valueNoise3du(vec3 samplePoint) {\n    vec3 pointI = floor(samplePoint);\n    vec3 pointF = fract(samplePoint);\n    vec3 u = valueNoiseFilter(pointF);\n\n    //Slight Optimisation\n    vec4 m = mix(\n        vec4(\n            hash31(pointI ),//bbl,\n            hash31(pointI + vec3(0.0,1.0,0.0) ),//btl,\n            hash31(pointI + vec3(0.0,0.0,1.0) ),//fbl,\n            hash31(pointI + vec3(0.0,1.0,1.0) )//ftl\n        ),vec4(\n            hash31(pointI + vec3(1.0,0.0,0.0) ),//bbr,\n            hash31(pointI + vec3(1.0,1.0,0.0) ),//btr,\n            hash31(pointI + vec3(1.0,0.0,1.0) ),//fbr,\n            hash31(pointI + vec3(1.0,1.0,1.0) )//ftr\n        ),u.x);\n\n    vec2 n = mix(m.xz, m.yw, u.y);\n    return mix(n.x,n.y,u.z);\n}\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    vec2 u = valueNoiseFilter(pointF);\n\n    vec2 m = mix(\n        vec2(\n            hash21(pointI), //bl\n            hash21(pointI + vec2(0.0,1.0)) //fl\n        ),\n        vec2(\n            hash21(pointI + vec2(1.0,0.0) ),//br\n            hash21(pointI + vec2(1.0,1.0) ) //fr\n        ),u.x);\n\n    return mix(m.x,m.y,u.y);\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(pointI),hash11(pointI + 1.0 ),valueNoiseFilter(fract(samplePoint)));\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(mod(pointI, wrap)),hash11(mod(pointI + 1.0 ,wrap)),valueNoiseFilter(fract(samplePoint)));\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n// All primitives are centered at the origin.\n\n// == 2D ==\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// == 3D ==\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdXAlignedCylinder( vec3 p, float l, float r )\n{\n    p.z -= clamp( p.z, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdZAlignedCylinder( vec3 p, float l, float r )\n{\n    p.x -= clamp( p.x, 0.0, l );\n    return length(p) - r;\n}\n\n// ========== ==========\n\nfloat getFog(vec3 direction, float time) {\n    time=time*0.1;\n    float fog = 0.0;\n    vec2 t = vec2(time,-time);\n\n    fog+= valueNoise3du(direction + vec3(t.x));\n    fog+= valueNoise3du((direction + vec3(t.xyx)) * 2.0) * 0.5;\n    fog+= valueNoise3du((direction + vec3(t.xxy)) * 4.0) * 0.25;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 8.0) * 0.125;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 16.0)* 0.0625;\n    \n    return fog;\n}\n\n// --quick hack to strobe the road lights so they always strobe away from the camera\n\nfloat getRoadLightStrobe(float distanceFromCamera, float time) {\n    return smoothstep(0.0,1.0,clamp(sin(time*5.0 - (distanceFromCamera/RAY_MAX_DISTANCE)*PI*5.0)*0.5,0.0,1.0));\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    time *= 0.05;\n\n    float b = blockSize;\n\n    vec3 path[16];\n    int i=0;\n\n    path[i++] = vec3( 0.0*b,\t0.0,\t 0.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b - gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b + gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b - 1.0,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t-2.0*b+1.0);\n    path[i++] = vec3( 4.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t 0.0*b);\n\n    time = mod(time,float(path.length()));\n\n    float cornerRadius = 0.1;\n    float inverseCornerRadius = 1.0 - cornerRadius;\n\n    int timeI = int(floor(time));\n    float timeF = fract(time)*inverseCornerRadius+cornerRadius;\n\n    vec3 p0 = path[timeI];\n    vec3 r;\n    timeI += 1;\n    if (timeI>=path.length()) {\n        timeI = 0;\n    }\n    vec3 p1 = path[timeI];\n    if (timeF >= inverseCornerRadius) {\n        timeI += 1;\n        if (timeI>=path.length()) {\n            timeI = 0;\n        }\n        vec3 p2 = path[timeI];\n        vec3 p01 = p0 + ((p1-p0) * (inverseCornerRadius));\n        vec3 p12 = p2 + ((p1-p2) * (inverseCornerRadius));\n        float t = map(timeF,inverseCornerRadius,1.0,0.0,1.0);\n        vec3 a = mix(p01,p1,t);\n        vec3 b = mix(p1,p12,t);\n        r= mix(a,b,t);\n    } else {\n        r=mix( p0, p1, timeF);\n    }\n\n\n    vec3 rd;\n    rd.y = (sin(time*5.0) + sin(time*9.0)) * 0.8;\n    rd.x = sin(time*6.0) + sin(time*8.0);\n    rd.z = sin(time*7.0) + sin(time*7.0);\n\n    rd *= sin(fract(time)*PI);\n    rd *= clamp(length(r)/gridSize-gridSize,0.0,1.0);\n    r+=rd*0.5;\n    return r;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n        vec3 cameraPos2 = getCameraPath(time+0.5);\n        vec3 cameraPos3 = getCameraPath(time-0.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n\n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0);\n        roll = clamp(roll,-0.5,0.5);//clamp(-0.1,0.1,1.0-pow(1.0-roll,5.0));\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #else\n    return getCamera(vec3(0.0,0.0,0.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);    \n    #endif\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 position, float time) {\n    rayMarchHit hit;\n    #if defined(DEBUG_USE_SQUARE_DISTANCE)\n    hit.distance = RAY_MAX_DISTANCE*RAY_MAX_DISTANCE;\n    #else\n    hit.distance = RAY_MAX_DISTANCE;\n    #endif\n\n    float newDistance = hit.distance;\n\n    vec3 pBlockCenter = position + (0.5*blockSize);\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    vec3 pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n    //wold position of the center of the grid, positionGI*blockSize\n    vec3 pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    vec3 pBlockWF = pBlockF*blockSize; \n\n    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;\n\n    //on north/south - -2.5 < mod(x,blockSize) < 2.5\n    bool onNorthSouth = (pBlockWF.x >= -gridSizeH && pBlockWF.x <= gridSizeH && (pBlockWF.z < -gridSizeH || pBlockWF.z > gridSizeH) );\n    bool onEastWest = (pBlockWF.z >= -gridSizeH && pBlockWF.z <= gridSizeH && (pBlockWF.x < -gridSizeH || pBlockWF.x > gridSizeH) );\n\n    #if defined(DEBUG_RENDER_RAILS)\n    //Road Main Beams\n    //FIXME: the length of beams *0.8?!?!\n    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));\n    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF.zyx)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));\n\n    //Intersection Main Beams\n    newDistance = min(newDistance,sdCircle( abs(pBlockWF.xz) - vec2(2.0,2.2), 0.05 ));\n    newDistance = min(newDistance,sdCircle( abs(pBlockWF.zx) - vec2(2.0,2.2), 0.05 ));\n\n    //dont crossbrase the road\n    if (pBlockWF.y < -gridSizeH || pBlockWF.y > gridSizeH) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));\n    }\n\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));\n\n    if (onNorthSouth) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));\n    }\n\n    if (onEastWest) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_RAIL;\n        hit.neon = vec3(0.0);\n    }\n    #endif\n\n    // Lights\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.2,1.25,2.0), vec3(2.0,1.25,2.2), 0.1));\n\n    if (onNorthSouth) {\n        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));\n    }\n\n    if (onEastWest) {\n        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_NEON;\n        hit.neon = roadLightColour*4.0;\n    }\n\n    //Buildings.\n    //rework the grids so 0,0,0 is the center of the buildings\n    pBlockCenter = position;// + vec3(0.0,blockSize*0.5,0.0);\n\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n\n    //wold position of the center of the grid, positionGI*blockSize\n    pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    pBlockWF = pBlockF*blockSize; \n\n    float floorCount=1.0;\n    \n    float blockHash = hash21(pBlockI.xz)*20.0;\n    float buildingFloor = floor(position.y)+floor(blockHash);;\n    float round = clamp(fract(blockHash)-0.5,0.05,0.5);\n    \n    for(float i=-floorCount;i<=floorCount;i++) {\n\t\t//pick a random point where the width and width-round are both within a single world space unit,\n        //the texturing later snaps to the world grid and if the ends of hte window cross the boundy we get artifacts.\n        float windowWigle=valueNoise1du(buildingFloor + i + blockHash)*2.0;\n        float baseWidth=floor((roadLength-2.0-windowWigle)*0.5);\n        float buildingfloorSize=baseWidth-map(fract(windowWigle)*(1.0-round*2.0), 0.0, 1.0, 0.01, 0.5)-round;\n        newDistance = min(newDistance, sdBox(vec3(pBlockWF.x,fract(pBlockWF.y)-i,pBlockWF.z), vec3(buildingfloorSize,0.5-round,buildingfloorSize))-round);\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_WALL;\n        hit.neon = vec3(0.0);\n    }\n\n    //Corners\n    newDistance = min(newDistance, sdBox( abs(pBlockWF.xz)-(roadLength*0.5)+(gridSize*0.4), vec2(0.5) ) - 0.5 );\n\n    //Mid Beams\n    if (abs(pBlockWF.z) < (roadLength*0.5)) {\n        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.x)-(roadLength*0.5)+(gridSize*0.2),pCellWF.z), vec2(0.375) ) - 0.125);\n    }\n    if (abs(pBlockWF.x) < (roadLength*0.5)) {\n        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.z)-(roadLength*0.5)+(gridSize*0.2),pCellWF.x), vec2(0.375) ) - 0.125);\n    }\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_SOLID;\n        hit.neon = vec3(0.0);\n    }\n\n    return hit;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    rayMarchHit hit;\n    float accumilatedDistance = 0.0;\n    vec3 accumilatedNeon = vec3(0.0);\n    float modulatedMinSurfaceDistance = minSurfaceDistance;\n    int i;\n    \n    #if defined (DEBUG_RAY_DITHER)\n    float dither =  hash31(fract(ray.origin + ray.direction));\n    #endif\n    \n    for(i=0; i<maxSteps; i++) {\n        float distanceRatio = clamp((accumilatedDistance/maxDistance),0.0,1.0);\n\n        //the more itterations the less precise we are, improve perfomance a bit with only mild artifacts\n        modulatedMinSurfaceDistance=mix(minSurfaceDistance,minSurfaceDistance*20.0,distanceRatio);\n\n        vec3 currentPoint = ray.origin + ray.direction * accumilatedDistance;\n        hit = GetRayMarchHit(currentPoint, time);\n\n        if (hit.materialId==MAT_NEON) {\n            vec3 neon;\n            if (hit.distance > minSurfaceDistance) {\n                neon = (hit.neon) * max(1.0-hit.distance/2.0,0.0) * 0.05;\n            }\n            neon *= 1.0-distanceRatio;\n\n            float lightStrobe = getRoadLightStrobe(accumilatedDistance, time);\n\n            accumilatedNeon += neon*lightStrobe;\n        }\n        #if defined (DEBUG_RAY_DITHER)\n        if(hit.distance > 0.0) {\n            //we take smaller steps closer to the camera, gives a better Neon result.           \n            hit.distance *= 0.5+mix(distanceRatio,1.0,dither)*0.5;\n        }\n        #endif\n\n        accumilatedDistance += hit.distance;\n\n        if(accumilatedDistance >= maxDistance) {\n            accumilatedDistance = maxDistance;\n            hit.surfaceNormal = -ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        }\n        //terminate if we are very close or bounce back out if we end up within an object. \n        //else if(hit.distance > -minSurfaceDistance && hit.distance < minSurfaceDistance) {\n\n        //forget bouncing back, if we end up inside just terminate\n        else if(hit.distance < modulatedMinSurfaceDistance) {\n            break;\n        }\n\n    }\n    hit.iteration = i;\n    hit.distance = max(0.0,accumilatedDistance);\n    hit.neon = accumilatedNeon;\n    return hit;\n}\n// ========== ==========\n\n// ========== Texturing ==========\n\nfloat sampleConcrete(vec3 position) {\n    float concrete = valueNoise3du(position * 4.0);\n    concrete += valueNoise3du(position * 8.0) * 0.5;\n    concrete += valueNoise3du(position * 16.0) * 0.25;\n    concrete += valueNoise3du(position * 32.0) * 0.125;\n    concrete /= 1.875;\n    concrete = (abs(concrete*2.0-1.0));\n    return concrete;\n}\n\nfloat sampleConcreteLine(vec3 position) {\n    float line = abs(fract(position.y)-0.5);\n    line = 1.0-clamp(line*10.0,0.0,1.0);\n    line*=line*line*3.0;\n    return 1.0-line;\n}\n\nfloat getConcrete(vec3 position, inout vec3 normal, bool showLine) {\n    float center=sampleConcrete(position);\n    \n    if(showLine) {\n\t\tcenter=min(center,sampleConcreteLine(position));\n    }\n    \n    vec3 rightDir;\n\tvec3 upDir;\n\n    if(abs(normal.y)<0.999) {\n    \trightDir = normalize(cross(vec3(0.0, 1.0, 0.0), normal));\n\t\tupDir = normalize(cross(normal, rightDir));\n    } else {\n        rightDir = normalize(cross(vec3(1.0, 0.0, 0.0), normal));\n\t\tupDir = normalize(cross(normal, rightDir));\n    }\n    float right = sampleConcrete(position+rightDir*0.01);\n    float up = sampleConcrete(position+upDir*0.01);\n    \n    if(showLine) {\n    \tright=min(right,sampleConcreteLine(position+rightDir*0.01));\n    \tup=min(up,sampleConcreteLine(position+upDir*0.01));\n    }\n    \n    //FIXME: apply correct normal calculations, this is NOT how you do it!\n    vec3 pNormal;\n    pNormal=(vec3(\n        right - center,\n        up - center,\n        right - center\n    ));\n\n    pNormal*=-1.3;\n    normal = normalize(normal + pNormal);    \n\t   \n    float concrete=center*0.35+0.65;\n    \n    return concrete;\n}\n\nvoid textureSolid(in vec3 block, inout ray ray, inout rayMarchHit hit, inout vec3 colour, bool isReflection, in float time) {\n    float concrete = getConcrete(hit.origin, hit.surfaceNormal, true);\n    colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n    colour = clamp(colour,vec3(0.0),vec3(1.0));\n    colour *= concrete;\n}\n\n    //Features to implement?\n    //curtains_left\n    //curtains_right\n    //curtains_both\n\t//blinds\n    //circle lights\n    //light spacing\n    //door\n    //door colour\n    \n\t//brightness\n    //light colour\n    //strip lights x, z\n    //ceiling colour\n    //wall colour\n    //floor colour\n\nvoid textureParallaxWindow(in vec3 block, inout ray ray, inout rayMarchHit hit, in vec2 uv, in vec3 cell, in vec3 lightColour, in float brightness, inout vec3 colour, in float time) {\n    \n    if(abs(uv.x)>PARALLAX_INTERROOM_WALL_THICKNESS||abs(uv.y)>PARALLAX_INTERROOM_WALL_THICKNESS) {\n        colour=PARALLAX_INTERROOM_WALL_COLOUR;\n        return;\n    }\n    \n    vec3 absNormal = abs(hit.surfaceNormal);\n    vec3 flatNormal;\n\n    //flaten the normal so we still project axis aligned with no distortion of y axis curve.\n    if(absNormal.y > absNormal.x && absNormal.y > absNormal.z) {\n        flatNormal = vec3(0.0,1.0,0.0);\n    } else {\n        flatNormal = normalize(vec3(hit.surfaceNormal.x,0.0,hit.surfaceNormal.z));\n    }    \n    \n    vec3 roomSize = vec3(1.0) ;\n    roomSize.z += hash31(cell*16.8736)*2.0;\n        \n    vec3 tangent = normalize(cross(vec3(0.0,1.0,0.0),flatNormal));\n    vec3 bitangent = normalize(cross(flatNormal,tangent));\n    mat3 tMatrix = mat3(tangent,bitangent,flatNormal);\n    \n    vec3 rayDir = normalize(ray.direction*tMatrix)/roomSize;\n    vec3 hitPos = vec3(uv.x,uv.y,0.0)/roomSize;\n\t\n    //Room cube, We assume the room is 1 unit cube from -0.5 to +0.5, with a given wall thickness.\n    vec3 roomMin = vec3(-PARALLAX_INTERROOM_WALL_THICKNESS,-PARALLAX_INTERROOM_WALL_THICKNESS,-1.0);\n    vec3 roomMax = vec3(PARALLAX_INTERROOM_WALL_THICKNESS,PARALLAX_INTERROOM_WALL_THICKNESS,0.0);\n    vec3 roomMid = vec3(0.0);\n    \n    //we only need to interesct 3 planes per ray, looking at the direction of the ray find which 3 its heading towards.\n    vec3 planes = mix(roomMin, roomMax, step(0.0, rayDir));\n    \n    //now do the parallax calcualtion to find the project position 'into' the window\n    vec3 planeIntersect = ((planes-hitPos)/rayDir);\n    float distance;\n\n    if(planeIntersect.x < planeIntersect.y && planeIntersect.x < planeIntersect.z) {\n        //Left/Right wall\n        colour=clamp(hash33(cell*48.2270)+0.7,0.0,1.0);\n        distance = planeIntersect.x;\n    } else if (planeIntersect.y < planeIntersect.x && planeIntersect.y < planeIntersect.z) {\n        if(rayDir.y<0.0) {\n            //Floor\n            colour = clamp(hash33(cell*81.7619)+0.3,0.0,1.0);\n        } else {\n            //Ceiling\n            colour =mix(clamp(hash33(cell*20.9912)+0.3,0.0,1.0),\n                        lightColour*6.0,\n                \tabs(sin((planeIntersect.y*PI*3.0))));\n        }\n        distance = planeIntersect.y;\n    } else if (planeIntersect.z < planeIntersect.x && planeIntersect.z < planeIntersect.y) {\n        //Back wall\n        colour=clamp(hash33(cell*54.8454)+0.7,0.0,1.0);\n        distance = planeIntersect.z;\n    } else {\n        //error!\n        colour=PARALLAX_INTERROOM_WALL_COLOUR;\n        distance = 0.0;   \n    }\n    vec3 intersectionPos = ((hitPos + rayDir * distance) - roomMin);\n\t//add some distance and height shadow    \n    colour*=clamp(intersectionPos.z*(1.0-intersectionPos.y)+0.3,0.0,1.0)*brightness*lightColour;\n}\n\nvoid textureWall(in vec3 block, inout ray ray, inout rayMarchHit hit, inout vec3 colour, bool isReflection, in float time) {\n    vec2 uv;\n    vec3 absNormal = abs(hit.surfaceNormal);\n    float scale = 2.0;\n\n    if(absNormal.y-0.8 > absNormal.x && absNormal.y-0.8 > absNormal.z) {\n        uv.xy=fract(hit.origin.xz*scale)-0.5;\n    } else {\n        if(absNormal.x > absNormal.z) {\n            if(hit.surfaceNormal.x>0.0) {\n                uv.x=1.0-fract((hit.origin.z)*scale);\n            } else {\n                uv.x=fract((hit.origin.z)*scale);\n            }\n        } else {\n            if(hit.surfaceNormal.z>0.0) {\n                uv.x=fract((hit.origin.x)*scale);\n            } else {\n                uv.x=1.0-fract((hit.origin.x)*scale);\n            }\n        }\n        uv.y=fract(hit.origin.y*scale);\n\t\tuv-=0.5;\n        //vec2 windowSize=vec2(1.0);\n        vec2 windowSize=vec2(hash21(block.xy*39.195),hash21(block.xy*26.389))*0.7+0.2;\n\n        if (windowSize.x > 0.8){\n            windowSize.x=1.0;\n        }\n\n        if (windowSize.y > 0.8){\n            windowSize.y=1.0;\n        }\n\n        float round=0.0;\n\n        if (windowSize.x < 1.0 && windowSize.y < 1.0) {\n            round = min(windowSize.x,windowSize.y) * hash21(block.xy*87.981);\n        }\n\n       if ( abs(uv.x*2.0) < windowSize.x+PARALLAX_WINDOW_SURROUND_THICKNESS && abs(uv.y*2.0) < windowSize.y+PARALLAX_WINDOW_SURROUND_THICKNESS) {\n            float distance = sdBox(uv*2.0,windowSize-round)-round;\n            if(distance < 0.0) {\n                vec3 cell = floor(hit.origin*scale);\n                bool on = (hash31(cell) + sin(time*0.5)*0.05) > 0.5;\n                hit.materialId = MAT_WINDOW;\n                if(on) {\n                    float brightness = clamp(hash31(cell),0.1,1.0);\n                    vec3 lightColour = clamp(hash33(cell)+0.5,0.0,1.0);\n                    \n                    #if defined(DEBUG_PARALLAX)\n                        if(isReflection) {\n                            colour=lightColour*3.0*brightness;\n                        } else {\n                            float distanceRatio=hit.distance/RAY_MAX_DISTANCE;\n                            if(distanceRatio<0.5) {\n                                textureParallaxWindow(block, ray, hit, uv, cell, lightColour, brightness, colour, time);\n                                colour*=3.0;\n                                if(distanceRatio>0.25) {\n                                    colour=mix(colour,lightColour*3.0*brightness,(distanceRatio-0.25)*4.0);\n                                }\n                                //shade the edge of the glass a bit.\n                                colour = mix(PARALLAX_WINDOW_SURROUND_COLOUR,colour,clamp(abs(distance*20.0),0.0,1.0));\n                            } else {\n                                colour=lightColour*3.0*brightness;\n                            }\n                        }\n                    #else\n                    \tcolour=lightColour*3.0*brightness;\n                    #endif\n                } else {\n                    colour=vec3(0.0);\n                }\n            } else if(distance < PARALLAX_WINDOW_SURROUND_THICKNESS) {\n                hit.materialId = MAT_WINDOW;\n                colour=PARALLAX_WINDOW_SURROUND_COLOUR;\n            } \n        }\n    }\n\n    if (hit.materialId != MAT_WINDOW){\n        float concrete = getConcrete(hit.origin, hit.surfaceNormal, false);\n        colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n        colour = clamp(colour,vec3(0.0),vec3(1.0));\n        colour *= concrete;\n    }\n}\n\n\n// ========== ==========\n\n// ========== Lighting ==========\n\nfloat getOcclusion( in vec3 origin, in vec3 normal, float time)\n{\n    float occlusion = 0.0;\n    float scale = 2.0;\n    rayMarchHit hit;\n\n    for( float distance=0.0; distance<0.5; distance+=0.25 )\n    {\n        vec3  currentPoint = origin + distance*normal;\n        hit = GetRayMarchHit(currentPoint, time);\n        occlusion += (distance-hit.distance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occlusion, 0.0, 1.0 );\n}\n\nfloat getShadow(vec3 origin, vec3 destination, float soft, float time) {\n    float currentDistance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW;\n    float maxDistance = distance(destination, origin);\n    vec3 direction = normalize(destination-origin);\n    rayMarchHit rayMarchHit;\n    float light = 1.0;\n\n    for(int i=0; i<RAY_MAX_STEPS_SHADOW; i++) {\n        vec3 currentPoint = origin + direction*currentDistance;\n        rayMarchHit = GetRayMarchHit(currentPoint, time);\n        //Soft Shadows!\n        light = min(light,soft * rayMarchHit.distance/currentDistance);\n        currentDistance += rayMarchHit.distance;\n        if(currentDistance > maxDistance) {\n            break;\n        } else if(rayMarchHit.distance < OBJECT_MIN_SURFACE_DISTANCE_SHADOW) {\n            light = 0.0;\n            break;\n        }\n    }\n\n    return light;\n}\n\nvoid getOffsetLight(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance = length(lightOffset);\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    //dotProd *= diffuseBrightness;\n    dotProd *= fallOff;\n    specularBrightness = dotProd;\n}\n\nvoid getOffsetLight2(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, bool xAligned, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance;\n\n    if(xAligned) {\n        distance = sdXAlignedCylinder(lightOffset, 0.4, 0.1 );\n    } else {\n        distance = sdZAlignedCylinder(lightOffset, 0.4, 0.1 );\n    }\n\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    //dotProd *= diffuseBrightness;\n    dotProd *= fallOff;\n    specularBrightness = dotProd;\n}\n\nvoid getLight(vec3 position, vec3 normal, vec3 rayDirection, float shininess, vec3 cameraOrigin, out vec3 diffuseLight, out vec3 specularLight, bool isReflection, float time) {\n    diffuseLight = vec3(0.0);\n    specularLight = vec3(0.0);\n\n    vec3 lightOrigin;\n    float diffuseBrightness;\n    float specularBrightness;\n    \n    // -- Camera Light\n    if(!isReflection) {\n        lightOrigin = cameraOrigin;\n\n        diffuseBrightness;// = 0.0;\n        specularBrightness;// = 0.0;\n\n        getOffsetLight(position, normal, rayDirection,lightOrigin-position, 9.0, shininess, diffuseBrightness, specularBrightness);\n        diffuseLight = vec3(0.5 * diffuseBrightness);\n        specularLight = vec3(0.5 * specularBrightness);\n    }\n    // -- Road Lights\n\n    //get the closest road light\n    vec3 pBlockCenter = position+(0.5*blockSize);\n\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    vec3 pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n    //wold position of the center of the grid, positionGI*blockSize\n    //vec3 pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    vec3 pBlockWF = pBlockF*blockSize;\n    // Cell\n    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;\n\n    //sample just past the cross over point, has some artifacts but enlarges the light area.\n    float maxDistance = gridSize*0.75;\n\n    float lightStrobe;\n    vec3 lightPositionOffset;\n\n    if(abs(pBlockWF.y) -1.0 < gridSize) {\n\n        if(pBlockWF.y>0.0) {\n            lightPositionOffset.y = 1.0-pBlockWF.y;\n        } else {\n            lightPositionOffset.y = -1.0-pBlockWF.y;\n        }\n\n        // North/South\n        if(abs(pBlockWF.x) < gridSize) {\n            if(pBlockWF.z > gridSize*-0.5 && pBlockWF.z < 0.0) {\n                lightPositionOffset.z = -pCellWF.z - gridSize;\n            } else if(pBlockWF.z < gridSize*0.5 && pBlockWF.z > 0.0) {\n                lightPositionOffset.z = -pCellWF.z + gridSize;\n            } else {\n                lightPositionOffset.z = -pCellWF.z;\n            }\n            if(pBlockWF.x>0.0) {\n                lightPositionOffset.x = 2.0-pBlockWF.x;\n            } else {\n                lightPositionOffset.x = -2.0-pBlockWF.x;\n            }\n\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            if(lightStrobe>0.0) {\n                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, true, maxDistance, shininess, diffuseBrightness, specularBrightness);\n                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);\n                specularLight += roadLightColour * (specularBrightness*lightStrobe);\n            }\n        }\n\n        // East/West\n        if(abs(pBlockWF.z) < gridSize) {\n\n            if(pBlockWF.x > gridSize*-0.5 && pBlockWF.x < 0.0) {\n                lightPositionOffset.x = -pCellWF.x - gridSize;\n            } else if(pBlockWF.x < gridSize*0.5 && pBlockWF.x > 0.0) {\n                lightPositionOffset.x = -pCellWF.x + gridSize;\n            } else {\n                lightPositionOffset.x = -pCellWF.x;\n            }\n            if(pBlockWF.z>0.0) {\n                lightPositionOffset.z = 2.0-pBlockWF.z;\n            } else {\n                lightPositionOffset.z = -2.0-pBlockWF.z;\n            }\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            if(lightStrobe>0.0) {\n                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, false, maxDistance, shininess, diffuseBrightness, specularBrightness);\n                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);\n                specularLight += roadLightColour * (specularBrightness*lightStrobe);\n            }\n        }\n    } \n\n    // Up/Down\n    maxDistance = gridSize*1.4;\n    if (abs(pBlockWF.x)-2.0 < maxDistance && abs(pBlockWF.z)-2.0 < maxDistance) {\n        if(pBlockWF.x>0.0) {\n            lightPositionOffset.x = 2.0-pBlockWF.x;\n        } else {\n            lightPositionOffset.x = -2.0-pBlockWF.x;\n        }\n\n        if(pBlockWF.z>0.0) {\n            lightPositionOffset.z = 2.0-pBlockWF.z;\n        } else {\n            lightPositionOffset.z = -2.0-pBlockWF.z;\n        }\n\n        lightPositionOffset.y = 0.0-pCellWF.y;\n\n        lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n        getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n        diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);\n        specularLight += roadLightColour * (specularBrightness*lightStrobe);\n\n        //apply lights from above and below to get smooth transitions\n        if (pCellWF.y>0.0) {\n            lightPositionOffset.y = gridSize-pCellWF.y;\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);\n            specularLight += roadLightColour * (specularBrightness*lightStrobe);\n        } else {\n            lightPositionOffset.y = -gridSize-pCellWF.y;\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);\n            specularLight += roadLightColour * (specularBrightness*lightStrobe);\n        }\n    }\n}\n\n// ========== ==========\n\n// ========== Calculate Normal ==========\n\nfloat map(in vec3 pos, float time ){\n    return GetRayMarchHit(pos, time).distance;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n\n    #if 0\n    vec2 e = vec2(1.0,-1.0)*0.005773;\n    return normalize( e.xyy*map( pos + e.xyy, time ) + \n                     e.yyx*map( pos + e.yyx, time ) + \n                     e.yxy*map( pos + e.yxy, time ) + \n                     e.xxx*map( pos + e.xxx, time ) );\n    #else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time);\n    }\n    return normalize(n);\n    #endif    \n}\n\n// ==========  ==========\n\n// ========== Get colour for a ray hit ==========\n\nvoid renderRay(inout ray ray, inout rayMarchHit hit, inout vec3 colour, bool isReflection, float time) {\n    vec3 skybox = mix(vec3(0.03,0.1,0.25),vec3(0.5,0.4,0.3),(ray.direction.y*0.5+0.5)+0.2);\n\tvec3 block= vec3(floor(hit.origin.xz/blockSize), floor(hit.origin.y));\n    \n    #if defined(DEBUG_OCCLUSION)\n        float occlusion = getOcclusion(hit.origin, hit.surfaceNormal, time);\n    #endif\n    \n    if(hit.materialId == MAT_SKY) {\n        colour = skybox;\n    } else if (hit.materialId == MAT_WALL) {\n        textureWall(block, ray, hit, colour, isReflection, time);\n    } else if (hit.materialId == MAT_SOLID) {\n        textureSolid(block, ray, hit, colour, isReflection, time);\n    } else if (hit.materialId == MAT_NEON) {\n        #if defined(DEBUG_WHITE_NEON)\n        \tfloat lightStrobe = getRoadLightStrobe(hit.distance, time);\n        \tcolour = mix(roadLightColour*0.1,vec3(4.0),lightStrobe)*roadLightBrightness;\n        #else \n        \tcolour = vec3(0.0);\n        #endif\n    } else {\n        colour = vec3(0.5,0.4,0.3);\n    }\n    #if defined(DEBUG_LIGHTING)\n    if (hit.materialId != MAT_NEON) {\n        vec3 diffuseLight;\n        vec3 specularLight;\n        float shininess = 1.0;\n        float specularIntensity = 0.1;\n\n        if (hit.materialId == MAT_SOLID || hit.materialId == MAT_WALL) {\n            shininess = 5.0;\n            specularIntensity = 2.5;\n        } else if (hit.materialId == MAT_WINDOW) {\n            shininess = 20.0;\n            specularIntensity = 2.0;\n        } \n\n        getLight(hit.origin, hit.surfaceNormal, ray.direction, shininess, ray.origin, diffuseLight, specularLight, isReflection, time);\n\n        #if defined(DEBUG_AMBIENT)\n            vec3 ambient = skybox;\n            #if defined(DEBUG_AMBIENT_OCCLUSION) && !defined(DEBUG_OCCLUSION)\n            if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n                float distanceRatio = hit.distance/RAY_MAX_DISTANCE;\n                if(distanceRatio<0.4) {\n                    float occlusion = 1.0-getOcclusion(hit.origin, hit.surfaceNormal, time);\n                    if(distanceRatio>0.2) {\n                        occlusion*=1.0-((distanceRatio-0.2)*5.0);\n                    } \n                    ambient *= 1.0-occlusion;\n                }                 \n            }\n            #endif\n        \tdiffuseLight += ambient;\n        #endif\n        \n        /*#if defined(DEBUG_AMBIENT)\n            vec3 ambient = skybox;\n            #if defined(DEBUG_AMBIENT_OCCLUSION) && !defined(DEBUG_OCCLUSION)\n                if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n                    ambient *= (getOcclusion(hit.origin, hit.surfaceNormal, time));\n                }\n            #endif\n        \tdiffuseLight += ambient;\n        #endif*/\n\n        if (hit.materialId != MAT_WINDOW) {\n            colour*=diffuseLight;\n        }\n        colour+=(specularLight*specularIntensity);\n    }\n    #else\n    //dim the whoels scene down and exagerate the over-brights\n    \tcolour=pow(colour*0.5,vec3(1.7));\n    #endif\n    \n\t#if defined(DEBUG_OCCLUSION)\n\t\tcolour*=occlusion;\n\t#endif\n    \n    #if defined(DEBUG_DISTANCE_FOG)\n    float distanceFog = hit.distance/RAY_MAX_DISTANCE;\n    colour = mix(colour, skybox, distanceFog);\n    #endif\n    \n    #if defined (DEBUG_FACE_FOG)\n    if(!isReflection) {\n    \tfloat faceFog = getFog(ray.direction+ray.origin,time) * (FACE_FOG_DENSITY+0.1*sin(time*0.1));\n    \tcolour += hit.neon * (0.5+faceFog*2.0);\n    \tcolour = mix(colour, vec3(2.0), faceFog);\n    } else {\n        colour += hit.neon;\n    }\n    #else\n    colour += hit.neon;\n    #endif\n}\n\n// ==========  ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n\n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // ---- Ray\n    ray mainRay = getRay(uv, camera);\n    rayMarchHit hit = RayMarch(mainRay, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n    if (hit.materialId != MAT_SKY && hit.materialId != MAT_NEON) {\n    \thit.surfaceNormal = calcNormal( hit.origin, time );\n    }\n\t\n    // ---- Render\n    vec3 colour;\n    renderRay(mainRay, hit, colour, false, time);\n\n     #if defined(DEBUG_REFLECTION)\n        if (hit.materialId != MAT_NEON && hit.materialId != MAT_SKY && hit.materialId != MAT_RAIL) {\n            float distanceRatio = hit.distance/RAY_MAX_DISTANCE;\n            vec3 refColour;    \n            if(distanceRatio<0.5) {\n\t            float reflection = 0.05;\n\t\t\t\tif (hit.materialId == MAT_WINDOW) {\n        \t        reflection = 0.1;\n\t            } \n\n                #if defined(DEBUG_REFLECTION_FRESNEL)\n\t\t\t\tfloat fresnel = 1.0-max(0.0,-dot(hit.surfaceNormal,mainRay.direction));\n                reflection=(reflection*fresnel*2.0);\n                #endif\n                if (reflection > 0.0) {\n                    ray refRay = getRefRay(hit.origin, hit.surfaceNormal, mainRay.direction);\n                    rayMarchHit refHit = RayMarch(refRay, RAY_MAX_DISTANCE_REFLECTION, OBJECT_MIN_SURFACE_DISTANCE_REFLECTION, RAY_MAX_STEPS_REFLECTION, time);\n                    if (refHit.materialId != MAT_SKY && refHit.materialId != MAT_NEON) {\n                    \trefHit.surfaceNormal = calcNormal( refHit.origin, time );\n                    }\n                    renderRay(refRay, refHit, refColour, true, time);\n                    if(distanceRatio>0.25) {\n                        reflection*=1.0-((distanceRatio-0.25)*4.0);\n                    } \n                    colour = mix(colour,refColour,reflection);\n                }\n            } \n        }\n     #endif\n    \n    // Exposure and Gamma \n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n\n    // colour grading\n    //colour = colour*vec3(1.0,0.8,0.9);\n    // compress        \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    #if defined(DEBUG_VIGNETTE) \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float vignette = clamp(pow( uv.x*uv.y*5.0,0.5)+0.4,0.0,1.0);\n    //Burn it in\n    colour=vec3(1.0)-((vec3(1.0)-colour)/vignette);\n    #endif\n\n    fragColour = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}