{"ver":"0.1","info":{"id":"3ddyD8","date":"1678263963","viewed":165,"name":"2 Engines favarite repetition ","username":"ytktkd69","description":"2020 09 24 try remix ","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019   https://www.shadertoy.com/view/wdVGRc   Engine failure\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define T iTime\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z) * UI3;\n\treturn vec3(q) * UIF;\n}\n//////////////////////////////////////////////////\nconst float tnspeed=0.55 ;       // de 0.5 ;\n      float zoom   =1.35  ;     //de 0.95;\n\nvec3 camera(vec2 U, vec2 r, inout vec3 ro, inout vec3 la, float fl, float t) {\n    \n    vec2 uv = (U - r*.5) / r.y;\n    \n  //  ro = vec3(3.0, 2.0 + sin(t*0.13)*0.2, -22.0);  // z axis foward(20,2+ , -12)   De(3,2+  ,-22 ) \n  //  ro = vec3(8.0, 2.0 + sin(t*0.13)*0.2, iTime*2.22-22.0 );  \n      ro = vec3(10.0, 3.505 + sin(t*0.13)*0.1, mod(7.*iTime*tnspeed,140.)-70.0 );    // repetition 9/21\n    \n    \n    // la = vec3(0.,  3.0, mod(7.*iTime*tnspeed,140.)-9.  );// Default\n    //  la = vec3(-.0, 3.0, -9.0+ iTime);                     // target(-4,3,3)               De(0, 3  , -9) \n   //  la =vec3(-10., 3., iTime*4.) ;               // target transfer effect little ??\n     \n    //train Pos cf  vec2 tn = train(p + vec3(4.0,0.0, iTime*tnspeed-70.));     // vec3(4,0,T-300.) train transfer\n    \n    // image of camera trace is not available\n //  ro.xz *= rot(sin(t * 0.1)*0.02 );  //                  // De sin( )* 0.02);\n  //   ro.xz *= rot(atan(70.*2.,8.)/20.*10.   /* t  */) ;\n    \n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\n///////////////////////////////////////////////////////////////////////////////// common end\n// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define PI 3.141592\n#define EPS .005\n#define FAR 100.\n#define ZERO (min(iFrame,0))\n\n#define X 1.8             // rail width 1.8\n#define METAL 1.0        // 1.\n#define BLACK_GLOSS 2.0  // 2.  body\n#define BLACK_MATT 5.0   // 3.\n#define WOOD 4.0         // 4 .\n#define GROUND 5.0       // 5.\n\n#define SEP vec3(1.0, 0.7, 0.73)    // De (1.0,0.7,0.3);\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\nfloat fbm(vec3 x) {\n    float r = 0.0,\n          w = 1.0,\n          s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * n3D(s * x);\n    }\n    return r;\n}\n\n//IQ Sphere Functions\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd),\n          c = dot(oc, oc) - sph.w * sph.w,\n          h = b * b - c;\n    if (h < 0.0) return vec2(0.0);\n    h = sqrt(h);\n    float tN = -b - h,\n          tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat planeIntersect(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\n//SDF - IQ\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 nearest(vec2 a, vec2 b) {\n    float s = step(a.x, b.x);\n    return a*s + (1.0-s)*b;\n}\n\nvec2 track(vec3 p) {\n    p.x = abs(p.x);\n    //rail\n    float metal = sdBox(p - vec3(X+0.14, -0.1, 0.0), vec3(0.04, 0.12, 1000.0));\n    metal = min(metal, sdBox(p - vec3(X+0.14, -0.26, 0.0), vec3(0.2, 0.04, 1000.0)));\n    \n    metal = min(metal, sdBox(p - vec3(X+1.5,0.0,0.0),vec3(0.1,0.7,15.0)) );// ad\n    metal = min(metal, sdBox(p - vec3(X+1.5,0.0,-15.0),vec3(0.1,1.0,0.1)) );// ad                         \n    //sleeper\n    vec3 q = p;\n    q.z = mod(q.z, 0.8) - 0.4;\n    float wood = sdBox(q - vec3(0.0, -0.4, 0.0), vec3(3.2, 0.1, 0.24));\n    //clamps\n    metal = min(metal, sdTorus(q - vec3(2.2, -0.25, 0.0), vec2(0.14, 0.02)));\n    \n    return nearest(vec2(metal, METAL), vec2(wood, WOOD));\n}\n\nfloat wheel(vec3 p, float scale) {\n    float w = sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 1.0*scale, 0.02); //rim\n    w = smin(w, sdCappedCylinder(p.yxz - vec3(0.0, X + 0.08, 0.0), 0.9*scale, 0.06), 0.04); //rim\n    w = max(w, -sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 0.8*scale, 0.16)); //rim cutout\n    w = min(w, sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 0.3*scale, 0.13)); //hub\n    w = max(w, -sdCappedCylinder(p.yxz - vec3(0.0, X, 0.0), 0.2*scale, 0.2)); //hub cutout\n    w = min(w, sdCappedCylinder(p.yxz - vec3(0.0, 0.0, 0.0), 0.1*scale, X+0.1)); //axle\n    //spokes\n    float a = (atan(p.z, p.y) / 6.2831853);\n    float ia = (floor(a*10.0) + 0.5)/10.0*6.2831853;\n    p.yz *= rot(ia*T*0.4);             // Wheel rotation\n    return min(w, sdBox(p - vec3(X, 0.36*scale, 0.0), vec3(0.02, 0.5*scale, 0.05*scale)));    \n}\n\nfloat link(vec3 p, vec3 a, vec3 b) {    \n    float t = sdCappedCylinder(p.yxz - a.yxz, 0.1, 0.05);\n    t = min(t, sdCappedCylinder(p.yxz - b.yxz, 0.1, 0.05));\n    return min(t, sdCapsule(p, a, b, 0.05));\n}\n\nvec2 train(vec3 p) {\n    \n    p.x = abs(p.x);\n\n    //wheels\n    vec3 q = p;\n    q.z += 1.1;\n    float metal = wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 1.0, 1.1), 1.0);          //  size 1. (1)\n    metal = min(metal, wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 1.0, 3.3), 1.0));    // s 1.    (2)\n    metal = min(metal, wheel(p - vec3(0.0, 0.8, 6.0), 0.8));                         //　　s 0.8  (3)\n    metal = min(metal, wheel(p - vec3(0.0, 0.6, -8.0), 0.6));                         // s 0.6   (4)\n    //coal truck\n    q = p;\n    q.z -= 15.5;   // de  q.z-=15.5;\n    metal = min(metal, wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 0.6, 2.5), 0.6));    //    (5)\n    metal = min(metal, wheel(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 0.6, 4.5), 0.6));    //    (6)\n    \n    //coal truck bogeys\n    float matt = sdBox(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 0.7, 3.5), vec3(1.2, 0.2, 1.2));  // (7)\n\n    //engine\n    float gloss =      sdCappedCylinder(p.xzy - vec3(0.0, -1.0, 4.0), 1.6, 7.0);          //  (8) body\n    \n    \n   // gloss = min(gloss, sdCapsule(vec3(p.x,p.y,p.z),vec3(0.,4.,-8.),vec3(0.,4.,-6.),1.25)) ; // 9.19 ad   \n   // gloss = min(gloss,sdCappedCylinder(p.xzy - vec3(0.0, -9.1, 4.0),0.5,0.9)) ;            // 9.20 ad\n    \n    \n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(0.0, -4.6, 4.0), 1.7, 0.5));    //  (9) outer ring\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(0.0, 2.0, 4.0), 1.7, 0.3));     // (10) outer ring\n    \n    gloss = min(gloss,sdCappedCylinder(p.xzy - vec3(0.0, -8.0, 4.0),0.6,0.9)) ;    // 9.20 head plate\n //   gloss = min(gloss, sdCapsule(p.xzy,   vec3(0.,4.,-8.),vec3(0.,4.,-6.),1.25)) ;  // 9.20 head capsele  \n    \n //   gloss = max(gloss,-sdCappedCylinder(p.xzy - vec3(0.0, -7.0, 4.0), 1.54, 3.0));   //  (11) ??\n          gloss = min(gloss,sdCappedCylinder(p.xzy - vec3(0.0, -5.0, 4.0), 1.54, 3.0));   //(11) inner bodey\n    \n    \n    \n    //top cyclinders\n    gloss = smin(gloss, sdCappedCylinder(p - vec3(0.0, 5.50, -2.0), 0.8, 0.7), 0.5);   //\n    \n    gloss = smin(gloss, sdCappedCylinder(p - vec3(0.0, 6.0, -6.0), 0.5, 0.9), 0.5);   ////// ad chiminy\n    gloss = smin(gloss, sdCappedCylinder(p - vec3(0.0, 6.7, -6.0), 0.6, 0.05), 0.2);   ////// ad\n    \n    gloss = smin(gloss, sdCappedCylinder(p - vec3(0.0, 5.0, 3.4), 0.5, 0.8), 0.5);\n    \n    /////////////////////////////////////////////////////////////////////////////////////\n    gloss = smin(gloss, sdBox(p - vec3(0.0, 3.8, 5.0), vec3(1.4, 1.4, 1.2)), 0.2);\n    \n    gloss = min(gloss, sdBox(p - vec3(0.0, 2.5, 0.5), vec3(2.0, 0.1, 7.5)));//cylinder platform// (11)\n    gloss = min(gloss, sdBox(p - vec3(0.0, 2.5, 8.0), vec3(1.6, 0.1, 2.0)));//driver platform \n    matt = min(matt, sdBox(p - vec3(0.0, 2.0, 1.5), vec3(0.6, 0.4, 8.5)));//beam platform\n    matt = min(matt, sdBox(p - vec3(0.0, 1.7, -1.0), vec3(1.0, 1.0, 5.0)));//core platform\n    matt = min(matt, sdBox(p - vec3(0.0, 0.9, 5.0), vec3(1.4, 0.2, 2.0)));//rear axle platform\n    matt = min(matt, sdBox(p - vec3(0.0, 1.2, 6.4), vec3(0.4, 0.6, 0.4)));//rear support platform\n    //front platform\n    matt = min(matt, sdBox(p - vec3(0.0, 0.6, -7.0), vec3(1.0, 0.2, 1.4)));\n    matt = min(matt, sdBox(p - vec3(0.0, 1.2, -7.8), vec3(0.4, 0.6, 0.6)));\n    gloss = min(gloss, sdBox(p - vec3(0.0, 1.6, -8.4), vec3(2.0, 0.2, 0.2)));\n    //bumpers\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(1.2, -8.7, 1.6), 0.2, 0.1)); // 0.2=>0.92\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(1.2, -8.8, 1.6), 0.34, 0.03));\n    //link support    \n    gloss = min(gloss, sdBox(p - vec3(2.0, 2.2, -3.1), vec3(0.2, .4, 0.2)));\n    \n    //ladder\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 0.3, 9.4), vec3(1.4, 2.6, 9.4), 0.02));\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 0.3, 9.9), vec3(1.4, 2.6, 9.9), 0.02));\n    //rungs\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 0.5, 9.4), vec3(1.4, 0.5, 9.9), 0.02));\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 1.2, 9.4), vec3(1.4, 1.2, 9.9), 0.02));\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 1.9, 9.4), vec3(1.4, 1.9, 9.9), 0.02));\n    \n    //cab     // operater room\n    gloss = min(gloss, sdBox(p - vec3(0.0, 4.0, 7.0), vec3(2.0, 1.4, 1.0)));\n    gloss = max(gloss, -sdBox(p - vec3(0.0, 4.0, 7.1), vec3(1.94, 1.34, 1.0)));    \n    //roof\n    float r = sdBox(p - vec3(0.0, 6.7, 8.0), vec3(2.0, 1.4, 2.0));\n    r = max(r, sdCappedCylinder(p.xzy - vec3(0.0, 8.0, 0.0), 5.8, 2.0));\n\tgloss = min(gloss, r);\n    //windows\n    gloss = max(gloss, -sdBox(p - vec3(0.0, 4.5, 6.8), vec3(2.4, 0.4, 0.2)));\n    gloss = max(gloss, -sdBox(p - vec3(0.0, 4.5, 7.5), vec3(2.4, 0.4, 0.4)));\n    gloss = max(gloss, -sdBox(p - vec3(1.75, 4.5, 7.0), vec3(0.16, 0.4, 1.4)));   \n    \n    //coal truck\n    gloss = min(gloss, sdBox(p - vec3(0.0, 2.7, 15.5), vec3(2.2, 1.5, 5.4)));\n    gloss = min(gloss, sdBox(p - vec3(0.0, 1.4, 27.50), vec3(2.2, 1.0, 6.0)));    \n    \n    //front cylinders\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(2.0, -6.3, 2.1), 0.4, 0.7));\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(2.0, -6.3, 2.1), 0.5, 0.5));\n    gloss = min(gloss, sdBox(p - vec3(2.0, 1.7, -6.3), vec3(0.5, 0.4, 0.5)));\n    gloss = min(gloss, sdCappedCylinder(p.xzy - vec3(2.0, -6.3, 1.2), 0.5, 0.7));\n    gloss = min(gloss, sdCapsule(p, vec3(2.0, 2.1, -6.3), vec3(1.0, 4.0, -6.3), 0.3)); \n    //rear cylinder\n    gloss = min(gloss, sdCapsule(p, vec3(2.2, 2.3, 1.0), vec3(2.2, 2.3, 2.8), 0.3));\n    //front cylinder\n    gloss = min(gloss, sdCapsule(p, vec3(1.4, 2.1, -8.2), vec3(-1.4, 2.1, -8.2), 0.3));\n    gloss = min(gloss, sdCappedCylinder(p.yxz - vec3(2.1, 0.8, -8.2), 0.32, 0.1));\n    \n    //linkages\n    metal = min(metal, link(p, vec3(2.0, 1.2, -6.3), vec3(2.0, 1.2, 0.3)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, 0.0), vec3(2.0, 0.6, 2.2)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, 0.0), vec3(2.0, 0.6, -2.2)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, -2.2), vec3(2.0, 0.6, -4.6)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, 0.0), vec3(2.0, 1.2, 0.3)));\n    metal = min(metal, link(p, vec3(2.0, 2.1, -6.3), vec3(2.0, 2.1, -3.4)));\n    metal = min(metal, link(p, vec3(2.0, 0.6, -4.6), vec3(2.0, 2.1, -3.4)));\n\n    //pipes\n    //top\n    gloss = min(gloss, sdCapsule(p, vec3(1.8, 4.0, -7.0), vec3(1.8, 4.0, 6.0), 0.1));  // longest pipe\n    gloss = min(gloss, sdCapsule(p, vec3(1.8, 4.0, -7.0), vec3(-1.8, 4.0, -7.0), 0.1));    \n    q = p;\n    q.z += 2.0;\n    gloss = min(gloss, max(sdTorus(vec3(q.x,q.y,abs(q.z)) - vec3(0.0, 4.0, 3.0), vec2(1.7, 0.05)), -p.y+4.0));\n    //bottom\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 2.8, -5.0), vec3(1.9, 2.8, 6.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 2.8, -5.0), vec3(-1.9, 2.8, -5.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, -5.0), vec3(1.9, 3.0, 6.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, -5.0), vec3(-1.9, 3.0, -5.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, -3.0), vec3(1.9, 3.6, -3.0), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.0, 0.4), vec3(1.9, 3.6, 0.4), 0.05));\n    gloss = min(gloss, sdCapsule(p, vec3(1.9, 3.6, -3.0), vec3(1.9, 3.6, 0.4), 0.05));\n    \n     gloss = min(gloss, sdCapsule(p, vec3(0., 4.0, -7.05), vec3(0., 4.0, -4.50), 1.70));  // 2020.9.20 adition\n  \n        \n    return nearest(nearest(vec2(gloss, BLACK_GLOSS), vec2(matt, BLACK_MATT)),\n                           vec2(metal, METAL));                                  // 3 objecte union\n}\n\n/*\nfloat blowout(vec3 p) {\n    \n    p.xy -= vec2(-4.0, 4.0);\n    \n    //blowout\n    vec3 q = p;\n    float amt = max(0.0, abs(q.z)-7.4);\n    float a = (atan(q.y, q.x) / 6.2831853);\n    float ia = (floor(a*0.0) + 0.0)/16.0*6.2831853;\n    q.xy *= rot(ia);\n    \n    float dx = (amt*amt*-0.2) + sin(q.z*ia*0.4+n3D(q))*amt*0.4;\n    float bo = sdCapsule(vec3(q.x+dx, q.y, q.z), \n                       vec3(1.2, 0.0, -10.0), \n                         vec3(1.2, 0.0, -6.0), \n                         0.0);                     \n\n    q.xy *= rot(0.1);\n    dx = (amt*amt*-0.2) + sin((q.z+2.3)*(ia+3.0)*0.7+n3D(q*1.3))*amt*0.2;\n    bo = min(bo, sdCapsule(vec3(q.x, q.y, q.z), \n                           vec3(0.0, 0.0, -8.0), \n                           vec3(0.0, 0.0, -6.0), \n                           1.25));                    \n\n     q.xy *= rot(-0.2);\n     dx = (amt*amt*-0.2) + sin((q.z+1.7)*(ia+2.1)*0.7+n3D(q*1.6))*amt*0.4;\n     bo = min(bo, sdCapsule(vec3(q.x+dx, q.y, q.z), \n                            vec3(0.8, 0.0, -11.0), \n                            vec3(0.8, 0.0, -6.0), \n                             0.05));                                   \n    // bo =min( bo,sdCappedCylinder(q.xzy-vec3(0.,-9.4,0.),0.55,0.2));  // ad\n\n    q = p;\n    q.y += smoothstep(-8.0, -12.0, q.z) * 4.0;\n    q.x -= amt*amt * sign(q.x) * 0.2;\n    a = (atan(q.y, q.x) / 6.2831853);\n    ia = (floor(a*20.0) + 0.5)/20.0*6.2831853;\n    q.xy *= rot(ia);\n    bo = min(bo, sdCapsule(vec3(q.x+dx*0.4, q.y, q.z), \n                           vec3(0.6, 0.0, -12.0), \n                           vec3(0.6, 0.0, -6.0), \n                           0.05));\n    \n    dx = (amt*amt*-0.2) + sin((q.z+3.7)*(ia+5.1)*0.7+n3D(q*1.7))*amt*0.4;\n    q.xy *= rot(0.1);\n    bo = min(bo, sdCapsule(vec3(q.x+dx*0.4, q.y, q.z), \n                           vec3(0.8, 0.0, -11.0), \n                           vec3(0.8, 0.0, -6.0), \n                           0.05));                            \n    \n    return bo;\n}     */\n\nvec2 map(vec3 p) {\n   // float tnspeed;\n   // vec2 tn = train(p + vec3(4.0,0.0, iTime*tnspeed-70.));           // vec3(4,0,T-300.) train transfer\n      vec2 tn  = train(p + vec3(4.0,0.0, mod(iTime*tnspeed*7. ,140.)-70.));          // repetition 9/21\n      vec2 tnn  = train(p + vec3(-4.0,0.0, mod(iTime*tnspeed*7.*1.4 ,140.)-90.)); \n    //  vec2 tnns = train(p + vec3(-4.0,8.0, mod(iTime*tnspeed*7.*1.4 ,140.)-25.0 - 90.))*0.5 ; // scale down\n    //  vec2 tnn2 = train(p + vec3(-12.0,0.0, mod(iTime*tnspeed*7.*1. ,140.)-70.)); \n    \n    p.x = abs(p.x);\n  //  p.x = abs(p.x-8.);    // ad\n    vec2 tk = track(p - vec3(4.0,0.0,0.0));\n    return nearest(nearest(tn, tk),tnn) ;                 // 2 engines\n  //  return nearest(nearest(nearest(tn, tk),tnn),tnn2 )  ;   // 3 engines\n}\n\nvec3 normal(vec3 p) {  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec2 march(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.0, id = 0.0;\n    for (int i=ZERO; i<140; i++) {\n        vec3 p = ro + rd*t;\n        vec2 ns = map(p);\n        if (abs(ns.x)<EPS || t>maxt) {\n            id = ns.y;\n            break;\n        }\n        t += ns.x;\n    }\n    return vec2(t, id);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//IQ - https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for (int i = ZERO; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10.0 * d / max(0.0, t-y));\n        ph = h;        \n        t += h;\n        if (res < 0.0001 || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 bump(vec3 p, vec3 n, float ba) {\n    vec2 e = vec2(EPS, 0.0);\n    float nz = n3D(p);\n    vec3 d = vec3(n3D(p + e.xyy) - nz, n3D(p + e.yxy) - nz, n3D(p + e.yyx) - nz) / e.x;\n    n = normalize(n - d * ba / sqrt(0.1));\n    return n;\n}\n\n\n//Patu\nvec3 sky(vec3 rd, vec3 ld){\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(T*0.02, 0.0), T*0.02)) * 1.5,\n\t      sun = max(dot(rd, ld), 0.0);\n    vec3 col = mix(vec3(0.4, 0.1, 0.0), vec3(1.0, 0.7, 0.3), max(0.0, rd.z*0.5 + 0.8));\n    col += vec3(1.0, .7, 0.4) * pow(sun, 8.0);\n\tcol += vec3(1.0, .8, 0.6) * pow(sun, 64.0);\n    return col + col * clamp(pow(vec3(nz), vec3(4.0)) * rd.y, 0.0, 1.0);\n}\n\n/*\nvec3 normalBO(vec3 p) {  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = blowout(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec2 marchBO(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    for (int i=ZERO; i<160; i++) {\n        vec3 p = ro + rd*t;\n        float ns = blowout(p);\n        if (ns<EPS) break;\n        t += ns*0.3;\n        if (t>maxt) {\n            t = 0.0;\n            break;\n        }\n    }\n    return vec2(t, BLACK_GLOSS);\n}\n                                              */\n\nvec3 shade(vec3 ro, vec3 rd, vec2 s, vec3 n) {\n\n    vec3 pc = vec3(0),\n         lp = vec3(3.0, 20.0, 10.0),\n         SLD = normalize(vec3(1.0, 20.0, 2.0));\n    \n    if (s.x<FAR) {\n        \n        vec3 p = ro + rd*s.x;\n        float ao = AO(p, n);\n        \n        //sky\n        float sh = shadow(p+n*EPS, SLD, EPS, 20.0);\n        float specSky = pow(max(dot(reflect(-SLD, n), -rd), 0.0), 32.0);\n        pc = vec3(0.2) * SEP * max(0.2, dot(SLD, n));\n\n        //*\n        //highlight\n        vec3 sc = vec3(0.1);\n        vec3 ld = normalize(lp - p);\n        float specLight = pow(max(dot(reflect(-ld, n), -rd), 0.0), 12.0);\n        if (s.y==METAL) {\n            sc =  vec3(0.9,0.18,0.09);              // de vec3(1.4); \n            specLight = pow(max(dot(reflect(-ld, n), -rd), 0.0), 32.0)*2.0;\n        } else if (s.y==GROUND) {\n            sc =vec3(0.4);    \n        } else if (s.y==WOOD) {\n            sc =vec3(0.77);    \n        }\n        \n        pc += sc * SEP * max(0.05, dot(ld, n));\n        if (s.y==BLACK_GLOSS || s.y==METAL) {\n            pc += SEP * (specSky + specLight);\n        }\n        //*/\n        \n        pc *= ao;\n        pc *= sh;\n        \n    }\n    \n    pc = mix(pc, sky(rd, SLD)*0.4, s.x*1.2/FAR);\n    \n    return pc;\n}\n\nvoid mainImage(out vec4 C, in vec2 U) {\n    \n    vec3 ro,\n         la,\n         rd = camera(U, R, ro, la, zoom, T); //camera(U,R,ro,la,zoom0.6,Time)\n   \n    vec2 surface = vec2(FAR, 0.0);\n    vec3 n = vec3(0);\n    float dof = 1.0;\n    float zoom ;\n    \n    vec3 fo = vec3(0.0, -0.5, 0.0), fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersect(ro, rd, fn, fo);\n    if (ft>0.0 && ft<surface.x) {\n        vec3 p = ro + rd*ft;\n        surface = vec2(ft, GROUND);\n        n = bump(p*9.0, fn, 0.6);\n        dof = length(la-p);\n    }\n    \n    vec2 si = march(ro, rd, surface.x);\n    if (si.x>0.0 && si.x<surface.x) {\n        vec3 p = ro + rd*si.x;\n        surface = si;\n        n = normal(p);\n        if (si.y==WOOD) {\n            n = bump(vec3(p.x*1.0,p.y*20.0,p.z*20.0), n, 0.3);\n        }\n        dof = length(la-p);\n    }\n    \n    vec2 bt = sphIntersect(ro, rd, vec4(-4.0,4.0,-9.0,6.0));\n  /*  if (bt.x>0.0) {\n        vec2 t = marchBO(ro, rd, bt.x, min(surface.x, bt.y));\n       if (t.x>0.0 && t.x<surface.x) {\n            vec3 p = ro + rd*t.x;\n            surface = t;\n            n = normalBO(p);\n            dof = length(la-p);\n        } \n    }    */\n\n    vec3 pc = shade(ro, rd, surface, n); \n\n    //gamma correction\n    pc = pow(pc, vec3(1.0/1.6));\n    \n    /*\n    //debug\n    if (bt.y > 0.0) {\n        pc += vec3(0.2,0.0,0.0);\n    }\n    //*/\n    \n    C = vec4(pc, dof*1.4/FAR);\n}\n//////////////////////////////////////////////////////////////////////////// uffer   end\n\n\n","name":"Image","description":"","type":"image"}]}