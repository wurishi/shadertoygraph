{"ver":"0.1","info":{"id":"fl3fR7","date":"1662865778","viewed":95,"name":"Night walk between rocks","username":"jeffbustercase","description":"Tring to create terrain with walking cam","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["raymarch","sdf","glass","night"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4tSSWz","filepath":"https://soundcloud.com/diffusereality/akkamiau-live-recording-ambient-set-at-diffuse-reality-24-06-22?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/diffusereality/akkamiau-live-recording-ambient-set-at-diffuse-reality-24-06-22?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1\n\n\n#define t iTime\n#define rot mat2(-sin(t),cos(t),cos(t),sin(t))\n\nfloat sd(vec3 p, int id)\n{\n    float v = .17;\n    float y = (sin(p.x*v)*cos(p.z*v) + 1.);\n    \n    if(id == 2)\n    {\n        vec3 pbox = p;\n        pbox.x = abs(pbox.x);\n        pbox.x -= 8.;\n        pbox.z -= 1.;\n        pbox.y -= 2.8;\n        \n        \n        float vv = min(max(pbox.z/50.,45.),30.);\n        pbox.xy *= mat2(-sin(vv),cos(vv),cos(vv),sin(vv));\n        float uu = min(max(pbox.z/30.,10.),5.);\n        //pbox.yz *= mat2(-sin(uu),cos(uu),cos(uu),sin(uu));\n        \n        \n        vec3 prbox = opRep(pbox, vec3(0.,0.,15.));\n        \n        float wall = sdBox(prbox,vec3(.1,5.5,3.5));\n        return wall;\n    }\n    else if(id == 0)\n    {\n        p.y -= 5.;\n        \n        vec3 b = vec3(10000.,y,10000.);\n        vec3 q = abs(p) - b;\n\n        float terrain = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n        \n        // big rocks\n        vec3 prock = (p);\n        \n        \n        prock.x += 35.;\n        prock.z -= 55.;\n        prock.y -= 10.5;\n        \n        float sinz = sin(prock.z);\n        sinz = 0.;\n        vec3 prockRep = prock;\n        prockRep = opRep(prock,vec3(70,0.,38. + sinz));\n        prockRep.x *= 1.*cos(prockRep.z*.007);\n        \n        float r = 25.;\n        float grd = .2;\n        float g = 2.2;\n        r += g + g*sin(p.z*grd + p.y*.1) * cos(p.x*grd + p.y*.1);\n        float bigRock = length(prockRep) - r;\n        \n        return opSmoothUnion(terrain,bigRock,8.9);\n    } else \n    {\n        p = opSymZ(p);\n    \n        p.x -= 5.;\n        p.y -= 03.5;\n        p.z -= 15.;    \n        \n        float vv = p.z/10.;\n        //p.xy *= mat2(-sin(vv),cos(vv),cos(vv),sin(vv));\n        \n        vec3 prep = opRep(p, vec3(0.,0.,10));\n        \n        prep.y += y*.5;\n        \n        float r = 1.3;\n        \n        float grd = 1.2;\n        float g = .6;\n        //r += g + g*sin(p.z*grd + p.y*.1) * cos(p.x*grd + p.y*.1);\n        //float oct = sdOctahedron(prep,2.5);\n        float o = length(prep) - r;\n        return o;\n    }\n    \n}\n\nvec3 doMaterial(vec3 p, vec3 nor, int id)\n{\n    if(id == 2)\n    {\n        return vec3(0);\n    }\n    else if(id == 0)\n    {\n        vec2 xy = p.xz*0.07;\n        vec3 tex = texture(iChannel0,xy).xyz;\n        tex = pow(tex,vec3(2.2));\n        \n        return tex;    \n    } else \n    {\n        //return vec3(0.4,0.1,.7);\n        vec2 xy = p.xz*.1;\n        vec3 tex = texture(iChannel2,xy).xyz;\n        tex = pow(tex,vec3(2.2));\n        return tex * vec3(.42,.42,.7);\n    }\n}\n    \nvec3 render(vec2 uv)\n{\n    \n    vec3 col = vec3(0);\n    vec3 lightColor = vec3(.86,.9,.65);\n    \n    vec3 light = vec3(0,-7.0,0);\n    vec3 ro = vec3(0,0,-5.);\n    vec3 lookAt = vec3(0);\n    \n    float vel = iTime*2.;\n    \n    float mov = vel*1.8;\n    ro.z += mov;\n    lookAt.z = ro.z+2.;\n    light.z += mov;\n    \n    lookAt.y  += .2*sin(vel*2.)+.2*cos(vel);\n    ro.y += max(.3*sin(vel*4.)+.3*cos(vel*7.),.2);\n    ro.x += .1*cos(vel*2.5);\n    \n    //light.z += mov;\n    \n    \n    //ro.xz *= rot;\n    //light.x += 10.1*sin(iTime);\n    //light.z += (cos(iTime)+1.)*10. - 20.;\n    \n    ro.y -= 00.9;\n    if(iMouse.z > 0.)\n    {\n        float mf = 10.;\n        float mx = -(iMouse.x/iResolution.x*2.-1.)*mf;\n        float my = (iMouse.y/iResolution.y*2.-1.)*mf*.5;\n        float vv = mx;\n        lookAt.x += mx;\n        lookAt.y -= my;\n        //lookAt.xz += .01*lookAt.xz*mat2(-sin(vv),cos(vv),cos(vv),sin(vv));\n        \n        //light.xyz = lookAt.xyz;\n    }\n    \n    float focal = 300.;\n    vec2 coord = uv * iResolution.xy*.7;\n    vec3 camDir = normalize(lookAt-ro);\n    vec3 center = ro + camDir * focal;\n    \n    vec3 zpos = -camDir;\n    vec3 xpos = cross(vec3(0,1,0),zpos);\n    vec3 ypos = cross(xpos,zpos);\n    \n    vec3 target =\n        center\n        + xpos * coord.x\n        + ypos * coord.y;\n    \n    vec3 rd = normalize(target-ro);\n    \n    int reflIdx = 0;\n    const int MAX_REFL = 10;\n    \n    const float EPS = 0.005;\n    float depth = EPS;\n    for(int i=0;i<256;i++)\n    {\n        vec3 p = ro + depth*rd;\n        \n        float dis0 = sd(p,0);\n        float dis1 = sd(p,1);\n        float dis2 = sd(p,2);\n        \n        int id = -1;\n        if(dis0<dis1 && dis0<dis2) id = 0;\n        else if(dis2<dis1) id = 2;\n        else id = 1;\n        \n        \n        float dis = EPS;\n        if(id == 0) dis = dis0;\n        else if(id == 2) dis = dis2;\n        else dis = dis1;\n        \n        if(dis < EPS)\n        {\n            //col = vec3(.1,.1,.9);\n            //break;\n            vec2 eps = vec2(1,-1);\n            \n            vec3 nor = normalize( eps.xyy*sd( p + eps.xyy*EPS,id ) + \n                      eps.yyx*sd( p + eps.yyx*EPS,id ) + \n                      eps.yxy*sd( p + eps.yxy*EPS,id ) + \n                      eps.xxx*sd( p + eps.xxx*EPS,id ) );\n            \n            vec3 toLight = normalize(light-p);\n            \n            float diff = dot(toLight,nor);\n            \n            float ambient = 0.0035;\n            vec3 color = vec3(1.);\n            \n            color = doMaterial(p,nor,id);\n            vec3 shadowedColor = color*ambient;\n            col *= shadowedColor;\n            if(diff > EPS)\n            {\n                vec3 preCol = color * diff * lightColor;\n                preCol *= 1./distance(light,p);\n                \n                col += preCol;\n            }\n            \n            //apply shadow if so\n            float colforc = 1.;\n            float _depth = EPS;\n            float k = 3.;\n            vec3 orig = p+toLight*EPS*7.;\n            for(int j=0;j<65;j++)\n            {\n                vec3 _p = orig+_depth*toLight;\n                float _dis0 = sd(_p,0);\n                float _dis1 = sd(_p,1);\n                float _dis2 = sd(_p,2);\n                \n                int _id = -1;\n                if(_dis0<_dis1 && _dis0<_dis2)_id=0;\n                else if(_dis2<_dis1) _id=2;\n                else _id = 1;\n                \n                float _dis = EPS;\n                if(_id == 0) _dis=_dis0;\n                else if(_id == 2)_dis=_dis2;\n                else _dis=_dis1;\n                \n                if(_dis<EPS)\n                {\n                    colforc = ambient;\n                    break;\n                }\n                \n                colforc = max(min(colforc, k*_dis/_depth),ambient);\n                _depth += _dis;\n                \n                if(_dis>20.)\n                {\n                    break;\n                }\n            }\n            \n            col *= colforc;\n            col = col/float(reflIdx+1);\n            // if reflective, reflect\n            if(id == 2 && reflIdx < MAX_REFL)\n            {\n                vec3 refl = reflect(rd,nor);\n                ro = p+EPS*refl;\n                rd = refl;\n                depth = EPS;\n                reflIdx++;\n            }\n            else break;\n        }\n        \n        depth += dis;\n        \n        if(dis > 2000.)\n        {\n            col += vec3(0.3,.6,.9) * (1.-uv.y)*0.01;\n            col = col/float(reflIdx+1);\n            break;\n        }\n    }\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    \n    //if(uv.x < 0.15 || uv.x > .35 || uv.y > -.0 || uv.y < -.3) return;\n    \n    vec3 col = vec3(0);\n    \n    const int lim = AA;\n    vec2 st = uv;\n    for(int i=0;i<lim;i++)\n    {\n        float f = float(i);\n        col += render(st);\n        st.x += 0.002*sin(uv.x*f+f);\n        st.y += 0.002*cos(uv.y*f+f);\n    }\n    \n    col = col/float(lim);\n    \n    col = acesFilm(col);\n    //col = tonemapFilmic(col);\n    \n    \n    \n    //if(uv.x > 0. && uv.y > 0.) col = acesFilm(col);\n    //else if(uv.x < 0. && uv.y < 0.) col = tonemapFilmic(col);\n    \n    col = pow(col,vec3(.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// From IQ Articles page\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opRep( vec3 p, vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n\nvec3 opSymZ(  vec3 p )\n{\n    p.x = abs(p.x);\n    return (p);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Free real state?\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n// ..Somehow..\nvec3 tonemapFilmic(const vec3 color) {\n\tvec3 x = max(vec3(0.0), color - 0.004);\n\treturn (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n","name":"Common","description":"","type":"common"}]}