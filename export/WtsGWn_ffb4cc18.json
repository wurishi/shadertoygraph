{"ver":"0.1","info":{"id":"WtsGWn","date":"1556047031","viewed":478,"name":"Visualizer (glitchy rainbow)","username":"nils","description":"Connect music to mic and urn on webcam! Adjust the \"limit\" const in Buf A somewhere between 0.1 and 0.6 to get a good effect, depending on the loudness of the music.","likes":3,"published":1,"flags":38,"usePreview":0,"tags":["color","audio","visualizer","webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TAU = 6.3;\n\nvec3 lerp(vec3 a, vec3 b, float v) {\n    v = clamp(v, 0.0, 1.0);\n \treturn a * (1.0 - v) + b * v;   \n}\n\nfloat lerp(float a, float b, float v) {\n    v = clamp(v, 0.0, 1.0);\n \treturn a * (1.0 - v) + b * v;   \n}\n\n// hsv functions from ronja-tutorials\n// https://www.ronja-tutorials.com/2019/04/16/hsv-colorspace.html#function-library\n\nvec3 rgb2hsv(vec3 rgb)\n{\n    float maxComponent = max(rgb.r, max(rgb.g, rgb.b));\n    float minComponent = min(rgb.r, min(rgb.g, rgb.b));\n    float diff = maxComponent - minComponent;\n    float hue = 0.;\n    if(maxComponent == rgb.r) {\n        hue = 0.+(rgb.g-rgb.b)/diff;\n    } else if(maxComponent == rgb.g) {\n        hue = 2.+(rgb.b-rgb.r)/diff;\n    } else if(maxComponent == rgb.b) {\n        hue = 4.+(rgb.r-rgb.g)/diff;\n    }\n    hue = mod(hue / 6., 1.0);\n    float saturation = diff / maxComponent;\n    float value = maxComponent;\n    return vec3(hue, saturation, value);\n}\n\nvec3 hue2rgb(float hue) {\n    hue = mod(hue, 1.0); //only use fractional part\n    float r = abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.); //green\n    float b = 2. - abs(hue * 6. - 4.); //blue\n    vec3 rgb = vec3(r,g,b); //combine components\n    rgb = clamp(rgb, 0., 1.); //clamp between 0 and 1\n    return rgb;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec3(1.), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5 + vec2(0.0, -0.1);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float a = abs(atan(p.x, p.y) / TAU);\n    float lum = texture(iChannel0, vec2(a, 0)).r;\n    const float b1 = 0.01;\n    const float b2 = 0.01;\n    const float wid = .8;\n    lum = smoothstep(lum - b1, lum + b2, wid - length(p)) ;\n    lum = smoothstep(lum - b1/2., lum + b2/2., wid - length(p)) ;\n\tcol = vec3(lum);\n    \n    //col = max(texture(iChannel2, uv).rgb, col);\n    col = abs(texture(iChannel2, uv).rgb - col);\n    col = col * texture(iChannel1, uv).rgb;\n    \n    vec3 hsv = rgb2hsv(col);\n    float hOff = iTime + 0.5 * sin(p.x * TAU) + 0.5 * sin(p.y * TAU);\n    hOff = mod(hOff, 1.0);\n    float colorFreqMatch = texture(iChannel0, vec2(hsv.x + iTime * 0.5, 0.)).r;\n    hsv = hsv + vec3((hOff + hsv.z) * hsv.y, .0, -.5 + colorFreqMatch);\n   \n    col = hsv2rgb(hsv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 lerp(vec3 a, vec3 b, float v) {\n    v = clamp(v, 0.0, 1.0);\n \treturn a * (1.0 - v) + b * v;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 tint = vec3(1., 1., 1.01);\n    vec2 offset = p * -0.5 * iTimeDelta;\n    float sum = 0.0;\n    const int n = 8;\n    for(int i = 0; i < n; i++) {\n        sum += texture(iChannel2, vec2(float(i) / float(n), 0)).r;\n    }\n    sum = sum / float(n);\n    const float limit = .45;\n    const float d = 0.1;\n    float glitch = smoothstep(limit, limit + d, sum);\n    \n    col = lerp(col, texture(iChannel1, uv + offset).xxx * tint, 0.0 + glitch);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}