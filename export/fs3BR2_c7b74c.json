{"ver":"0.1","info":{"id":"fs3BR2","date":"1656757410","viewed":75,"name":"apollonian gasket2","username":"DimaVitruk12345","description":"Shader6","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["dimavitrukshader6"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Apollonian gasket.\n// Pattern is created by repeatitive step:\n// For each point in the plane, if it is inside any of the circles, invert the\n// point in that circle. \n\nconst float PI = 3.14159265;\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.12,5.0,2.0),6.15)-3.0)-1.23, 0.2, 0.9 );\n      rgb = rgb*rgb*(4.0-2.0*rgb);\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n        float sqr(float x) { //hsv2rgb\n          return x*x;\n        }\n\n        int maxsteps = 100;\n\n        const int MAXK = 15;\n\n        vec3 circles0[MAXK+1];\n        vec3 circles1[MAXK+1];\n\n        void createCirles(int K, float phi, float psi) {\n          float theta = PI/float(K); \n\n          float r = sin(theta);\n          r /= cos(phi); \n          float r2 = r*r;\n\n          float B = -r*0.9*cos(psi);\n          float C = r2-1.0;\n          float s = B + sqrt(B*B-C);\n          float s2 = s*s;\n\n          float scale2 = 1.0/(1.0-r2);\n          float scale = sqrt(scale2);\n              circles0[0] = vec3(0,0,scale2*s2);\n\n          float k = 0.5*(1.0+s2-r2)/cos(theta);\n          for (int i = 0; i < K; ++i) {\n            float t = float(2*i)*theta;\n                circles0[i+1] = vec3(scale*vec2(sin(t+theta),cos(t+theta)),scale2*r2);\n                    circles1[i+1] = vec3(scale*k*vec2(sin(t),cos(t)),scale2*(k*k-s2));\n          }\n        }\n\nbool isInsideCircle(vec2 p, vec3 c) {\n  float r2 = dot(p-c.xy, p-c.xy);\n  return r2 <= c.z;\n}\n\n// Invert p in circle c\nvec2 invert(vec2 p, vec3 c, inout float scale) {\n  p -= c.xy;\n  float k = c.z/dot(p,p);\n  scale *= k;\n  p *= k;\n  p += c.xy;\n  return p;\n}\n\n        void mainImage( out vec4 fragColor, in vec2 fragCoord ){ //invert, isInsideCircle, hsv2rgb\n          int K = 4;\n          int N = K+4;\n\n          // You can move the circles around with your mouse\n          float pmax = float((3*K-2)/(K-2));\n          float phi = PI/pmax*iMouse.x/iResolution.x;\n          float psi = PI/3.0*iMouse.y/iResolution.y;\n\n          (K,phi,psi);\n\n          vec3 color = vec3(0);\n          int counter = 1;\n          for (int i = 0; i < counter; ++i) {\n              for (int j = 0; j < counter; ++j) {\n                  vec2 z = (2.0*(fragCoord+vec2(i,j)) - iResolution.xy)/iResolution.y;\n                  float pwidth = 6.0 * fwidth(z.x);\n                  float scale = 1.25;\n                  float scale0 = scale;\n\n                  int step;\n                  for (step = 0; step < maxsteps; step++) {\n                    bool found = false;\n\n                    for (int i = 0; i < N; i++) {\n                      vec3 c = circles0[i];\n                      if (isInsideCircle(z,c)) {\n                        z = invert(z,c,scale);\n                            found = true;\n                        break;\n                      }\n                    }\n                    if (!found) \n                      break;\n                  }\n                  vec3 col = vec3(1);\n                  float dmin = 1000.0;\n                  int imin = 0;\n                  if (dot(z,z) > 1.0) {\n                    dmin = length(z)-1.0;\n                  } else {\n                    for (int i = 1; i < N; ++i) {\n                      vec3 c = circles1[i];\n                      float d = abs(length(z-c.xy) - sqrt(abs(c.z)));\n                      if (isInsideCircle(z,c)) {\n                        dmin = d;\n                            imin = i;\n                        break;\n                      }\n                    }\n                  }\n\n                  col = hsv2rgb(vec3(float(imin)/float(N+1),0.8,0.8));\n                      col *= smoothstep(0.0,0.002,dmin/scale);\n\n                  dmin = 1e3;\n                      imin = -1;\n\n                  for (int i = 0; i < N; ++i) {\n                      vec3 c = circles0[i];\n                      float d = abs(length(z-c.xy) - sqrt(c.z));\n                      if (d < dmin) {\n                          dmin = d;\n                              imin = i;\n                  }\n\n                  col = mix(col,vec3(0),0.3*smoothstep(0.0,pwidth,dmin/scale));\n               }   \n               color += col;\n             }\n          }\n\n          color /= float(counter*counter);\n              color = pow(color,vec3(0.75));\n                  fragColor = vec4(color,1);\n        }","name":"Image","description":"","type":"image"}]}