{"ver":"0.1","info":{"id":"dsscR2","date":"1687023243","viewed":55,"name":"Beamforming Waves - Faster","username":"neros_greb","description":"This shader is a simulation of several sources (could be speakers), each producing a wave of the same frequency, but with a different phase shift, so that the resulting wave forms a beam in a certain direction. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["waves","acoustics"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265358979323846264338327950288419;\n\nstruct emission{\n    float a_freq;\n    float a_wavenum;\n    \n    float phase;\n};\n\n//const int sourceSide = 6;\nconst int layers = 10;\nconst int layerSize = 12;\nconst int numSources = layers * layerSize; //sourceSide * sourceSide;\n\nfloat centeredEmission(vec2 uv, float time, emission emi){\n    return sin(emi.a_freq * time - emi.a_wavenum*length(uv) + emi.phase) / pow(length(uv) + 0.5, 2.);\n}\n\nstruct source{\n    emission emission;\n    vec2 location;\n};\n\n\nfloat sourceContribution(vec2 uv, float time, source src){\n    if(length(uv - src.location) < 0.003){\n        return float(numSources);\n    }\n    return centeredEmission(uv - src.location, time, src.emission);\n}\n\nsource initializeSourceCircle(int k, emission em){\n    //emission em = emission(16., 256., 0.);\n    float radius = 0.1;\n\n    source ret;\n    int i = k % layerSize;\n    int j = k / layerSize;\n    \n    float layerRadius = float(j + 1)/float(layers) * radius;\n    float angle = 2.*PI / float(layerSize) * (float(i));\n    ret = source(em, layerRadius*vec2(cos(angle), sin(angle)));\n   \n    return ret;\n}\n\n/*source[numSources] initializeSourcesGrid(){\n    source[numSources] ret;\n    float separation = 0.1;\n    emission em = emission(8., 32., 0.);\n    \n    float startingPosition = - separation * float(sourceSide - 1)/2.;\n    \n    for(int i =0; i!=sourceSide; i++){\n        for(int j = 0; j != sourceSide; j++){\n            ret[i*sourceSide+j] = source(em, vec2(startingPosition+separation*float(i), startingPosition+separation*float(j)));\n        }\n    }\n    return ret;\n    \n}*/\n\nsource beamSource(source src, float theta){\n    vec2 beam = vec2(cos(theta), sin(theta));\n     \n    float distOffset = dot(src.location, beam);\n    source ret = src;\n\n    ret.emission.phase = - distOffset * src.emission.a_wavenum;\n\n    return ret;\n}\n\nfloat drawSourceSet(vec2 uv, float time){\n    float result = 0.;\n    const float weight = 1. / float(numSources);\n    for(int i = 0; i != numSources; i++){\n        source f1 = beamSource(initializeSourceCircle(i, emission(8., 128., 0.)), radians(10. * iTime));\n        result += weight*sourceContribution(uv, time, f1);\n    }\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y) * 2. - 1.*vec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 col = vec3(0.3, 0.6, 1.) * (0.5*drawSourceSet(uv, iTime) + 0.5);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}