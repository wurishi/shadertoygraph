{"ver":"0.1","info":{"id":"XcscRM","date":"1720950468","viewed":67,"name":"Magical Potion","username":"sagieL","description":"A vial containing magical fluid which generates various items. Which one will pop up next?\nI wrote this shader for teaching purposes.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","water","fluid","potion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat waterIntensity(vec2 uv, float time) {\n    uv.y += 0.1; // Height from horizon offset.\n    uv *= 12.; // Scale.\n    \n    return uv.y + sin(uv.x * .6) * .4 + sin(uv.x * 2.145) * .1 + \n        sin(uv.x * 2. + time * 4.) * .04;\n}\n\nfloat randomShape(vec2 uv, float time, float id) {\n    const float shapeCount = 4.;\n    \n    time += id * PI / 3.;\n    \n    float t01 = cos(time) * 0.5 + 0.5;\n    float shapeIndexCyclic = mod(floor(time / TAU) + id * 100., shapeCount) / shapeCount;\n    float randomShapeIndex = hash(floor(time / TAU) * 34.256 + id * 40.34);\n    float shapeIndex = randomShapeIndex; // shapeIndexCyclic;\n    \n    // Scale and translate about y axis, down and up to center.\n    vec2 p = uv + vec2(0., t01 * 2. - 0.5); \n    p = Rot(time) * p; // Rotate around self.\n    \n    float shapeSDF;\n    \n    if (shapeIndex < 1.0 / shapeCount) {\n        shapeSDF = sdHexagram(p, 0.11);\n    } else if (shapeIndex < 2.0 / shapeCount) {\n        shapeSDF = sdMoon(p, 0.5, 0.2, 0.5);\n    } else if (shapeIndex < 3.0 / shapeCount) {\n        shapeSDF = sdRoundedX(p, 0.21, 0.07);\n    } else {\n        shapeSDF = sdHexagon(p, 0.2);\n    }\n  \n    return shapeSDF;\n}\n\nfloat map(vec2 uv, float time) {\n    const float width = 0.2;\n    const float shownItemsCount = 3.;\n    \n    vec2 shapeUV = uv * shownItemsCount;\n    \n    // TODO: use floor / fract boxing, but consider the smin (to the water) of a neighbours in your cell. \n    float d = smin(randomShape(shapeUV, time, 1.), waterIntensity(uv, time), width);\n    d = smin(d, randomShape(shapeUV - vec2(1.1, 0.), time, 2.), width);\n    d = smin(d, randomShape(shapeUV + vec2(1.1, 0.), time, 3.), width);\n    return d;\n}\n\nvec3 getNormal(vec2 uv, float time) {\n    const float eps = 0.0001;\n    \n    float dist = map(uv, time);\n    float distRight = map(uv + vec2(eps, 0.), time);\n    float distUp = map(uv + vec2(0., eps), time);\n    \n    float dX = distRight - dist;\n    float dY = distUp - dist;\n \n    float dZ = dist * 0.01; // TODO: play around with the z component!\n    return normalize(vec3(dX, dY, dZ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Uniforms, should be controllable via properties.\n    const vec3 lightDir = normalize(vec3(0.5, -0.9, 0.2)); // Using left-handed coord system.\n    const vec3 viewDir = vec3(0, 0, 1); // Using left-handed coord system.\n    const float ambientIntensity = 0.1;\n    \n    // Toon shading params. Convert to 1D texture LUT or just use properties. Convert to linear space.\n    const vec3 darkColor = pow(vec3(0.55, 0.1, 0.6), vec3(2.2));\n    const float litCutoff = 0.54;\n    const vec3 litColor = pow(vec3(0.8, 0.35, 0.9), vec3(2.2));\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    // SDF shape and normal.\n    float time = iTime + PI;\n    float dist = map(uv, time);\n    vec3 normal = getNormal(uv, time);\n    \n    float cupSDF = sdRoundedBox(uv - vec2(0, 0.0), vec2(0.5, 0.45), vec4(0.0, 0.2, 0.0, 0.2));\n    \n    dist = max(dist, cupSDF);\n    \n    const float shapeBlur = 0.005;\n    float shapeIntensity = smoothstep(-shapeBlur, shapeBlur, -dist);\n\n    vec3 point2Light = -lightDir;\n    vec3 point2View = -viewDir;\n\n    float NdotL = dot(normal, point2Light);\n    float diffuseIntensity = clamp(NdotL, 0.0, 1.0) * shapeIntensity;\n    \n    float intensity = diffuseIntensity + ambientIntensity * shapeIntensity;\n    \n    float cupIntensity = smoothstep(-shapeBlur, shapeBlur, -cupSDF);\n    \n    // Toon shading. See: https://www.youtube.com/watch?v=rCvISlussGE\n    const float cutoffBlur = 0.01;\n    vec3 col = mix(darkColor, litColor, smoothstep(litCutoff - cutoffBlur, litCutoff + cutoffBlur, intensity)) * shapeIntensity;\n    col = mix(col, vec3(0.1, 0.3, 0.8), cupIntensity * 0.1);\n    \n    col = pow(col, vec3(0.454)); // Gamma encode.\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.141592\n#define TAU 6.283185\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash(float p) {\n  p = fract(p * 0.011); \n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat smin( float a, float b, float k ) // exponential\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nfloat sdRoundedBox(vec2 p, vec2 b, vec4 r)\n{\n    // b.x = width\n    // b.y = height\n    // r.x = roundness top-right  \n    // r.y = roundness boottom-right\n    // r.z = roundness top-left\n    // r.w = roundness bottom-left\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdHexagon(vec2 p, float r)\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram(vec2 p, float r)\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}","name":"Common","description":"","type":"common"}]}