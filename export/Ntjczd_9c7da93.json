{"ver":"0.1","info":{"id":"Ntjczd","date":"1650124548","viewed":129,"name":"Revision 2022 shader shwdwn semi","username":"Exca","description":"Shader made during Revision 2022 shader showdown semifinal.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","revision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture( iChannel0, uv);\n}\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float time = 0.0;\n\nfloat ffti =0.0;\nfloat ffts  = 0.0;\nfloat beat =0.0;\nfloat beatstep = 0.0;\nfloat bar = 0.0;\n\nfloat glow = 0.0;\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target -cam);\n  vec3 right = normalize( cross(vec3(0,1,0), forward));\n  vec3 up = normalize( cross(forward, right));\n  return normalize( forward*fov + right*uv.x + up*uv.y);\n}\n\nfloat smin( float a, float b, float k)\n{\n  float h = clamp(0.5 +0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b,a,h) + k*h*(h-1.0);\n}\n\nvec2 shift( vec3 p)\n{\n  return vec2( \n    sin(p.z*0.33 + time),\n    cos(p.z*0.43 + time)\n  );\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length( p) -r;\n}\nvec3 map( vec3 p)\n{\n  float s1 = sphere( p + vec3( sin(time*0.9), cos(time*0.35), sin(time*.12))*0.25, 0.25);\n  float s2 = sphere( p + vec3( sin(time*0.59), cos(time*0.335), sin(time*.512))*0.25, 0.25);\n  float s3 = sphere( p + vec3( sin(time*0.19), cos(time*0.635), sin(time*.212))*0.25, 0.25);\n  \n  float s = smin( s1, smin(s2, s3, 0.15),0.15);\n  float w = (1.5+4.0 * smoothstep(50.0, 5.0, p.z)) - length(p.xy + shift(p));\n  \n  float mat = s < w ? 2.0 : 1.0;\n  \n  w = min(s,w);\n  \n  return vec3(w, mat, 1.0);\n}\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float t)\n{\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam+rd*t;\n    vec3 r = map(p);\n    t+=r.x;\n    if(r.x < 2.0) glow += r.x;\n    if(r.x < 0.001)\n    {\n      return r;\n    }\n    if(t > 50.0)\n    {\n      t = 50.0;\n      return vec3(-1.0);\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 normal( vec3 p)\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.01, 0.0);\n  return normalize( vec3(\n    map(p +e.xyy).x,\n    map(p +e.yxy).x,\n    map(p +e.yyx).x\n  )-c.x);\n}\n\nfloat light( vec3 p, vec3 l, vec3 n)\n{\n  return max(0.0, dot( n, normalize( l-p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\ntime = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  vec2 vuv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  ffts = texture(iChannel1,vec2(0.1,0.5)).r;\n  ffti = time*0.5;\n  \n  beat = floor( time * 165.0/60.0);\n  beatstep=  fract( time * 165.0/60.0);\n    bar = floor( beat / 4.0);\n \n  time = time*0.1 + ffti*10.0;\n  \n\tvec3 col = vec3(0.0);\n  vec3 light1 = vec3( sin(time)*10.0, 10.0, 0.0);\n  \n  vec3 cam = vec3(0,0,-3);\n  vec3 target = vec3(0,0,0);\n  float fov = 2.0 + sin(bar)*1.9;\n  \n  vec3 col1 = vec3(0.5, 0.3, 0.6);\n  vec3 col2 = vec3(0.1, 0.5, 0.9);\n  vec3 col3 = vec3(0.9, 0.0, 0.0);\n  \n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  vec3 p = cam; float t = 0.0;\n  vec3 res = march( cam, rd, p, t);\n  \n  if(res.y > 1.5){\n    vec3 n = normal(p);\n    col = col1*light(p,light1,n)+0.2*col3;\n    \n    vec3 refrd = reflect( rd, n);\n    vec3 refp = p;\n    vec3 refc = vec3(0.0);\n    float reft = 0.0;\n    vec3 refres = march( refp+ refrd*0.01, refrd, refp, reft);\n    vec3 rn = normal(refp);\n      \n    if(refres.y > 1.5){\n      refc = col1*light(refp,light1,rn)+0.2*col3;\n    \n    }\n    else if(refres.y>-0.5){\n      refc = col2*light(refp,light1,rn)+0.2*col3;\n      \n      float td = smoothstep(1.0, 0.9, sin(reft*2.0));\n      refc +=vec3(1.0, 0.1,0.0)* 0.1/td;\n    }\n    col = mix(col, refc, 0.5);\n    \n  }\n  else if(res.y > -0.5){\n    vec3 n = normal(p);\n    col = col2*light(p,light1,n)+0.2*col3;\n    \n    float td = smoothstep(1.0, 0.9, sin(t*2.0+time*5.0));\n    col += vec3(1.0, 0.1,0.0)* 0.1/td;\n  }\n  \n  vuv -= 0.5;\n  vuv *= 0.99;\n  vuv += 0.5;\n  vec3 previous = texture( iChannel0, vuv).rgb;\n  \n  col += previous * 0.9 * smoothstep( 0.0, 0.1, ffts*0.05);\n  \n  col = clamp( col, vec3(0.0), vec3(1.0));\n  \n  col += glow * vec3(1.0, 0.5, 0.0) *0.1;\n  \n  if(mod(bar, 4.0) < 0.5) col.rgb = col.bgr;\n  else if(mod(bar, 4.0) < 1.5) col.rgb = col.gbr;\n  else if(mod(bar, 4.0) < 2.5) col.rgb = col.grb;\n  \n  fragColor = vec4( col, 1.0);\n}\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}