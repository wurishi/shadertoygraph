{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n * # Simple Math Function Rendering\n\n *\n * ```\n * Author:  SÃ©bastien Pierre   \n * Website: http://sebastienpierre.ca\n * Twitter: @ssebastien\n * License: BSD License\n * ```\n *\n * This shader is useful if you'd like to see what a function is like. Of\n * course, you can also use iq's graphtoy \n * <https://iquilezles.org/apps/graphtoy/index.html>.\n*/\n\n// NOTE: The resolution is the minimum value for which we have a display\nfloat RESOLUTION = 0.1;\n\n// Because it's a per-pixel rendering, we cannot test for\n// equal value, but we can test that a pixel-equals b, which\n// means the difference between both is going to be the size\n// of a pixel in the normalized space.\nbool equals(float a, float b){\n\tfloat v = smoothstep(b-RESOLUTION,b+RESOLUTION,a);\n    if (v == 0.0 || v == 1.0) {\n        return false;\n    } else {\n    \treturn true;\n    }\n}\n\n// The RED function\nbool f(float x, float y) {\n    return equals(log(x), y);\n\t//return equals(sin(x * 3.1416), y);\n}\n\n// The GREEN function\n\nbool g(float x, float y) {\n     return equals(sqrt(x), y);\n\t//return equals(cos(x * 3.1416), y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = max(0.01, 100.0 * iMouse.x / iResolution.x);\n\tvec2 p      = fragCoord.xy / iResolution.xy;\n    p.x -= 0.5;\n    p.y -= 0.5;\n    p    = p * scale;\n\tp.x *= iResolution.x/iResolution.y; \n    RESOLUTION = scale / iResolution.y;\n\n    vec3 color      = vec3(0.0);\n    \n    // We adjust the grid unit based on the scale\n    float grid_unit = 1.0;\n    if (scale / grid_unit > iResolution.x / 10.0) {\n    \tgrid_unit *= 10.0;\n    }\n    \n    // We draw the dots for every .1 unit\n    if (equals(mod(p.x, grid_unit), 0.0) && equals(mod(p.y, grid_unit), 0.0)) {\n        color += vec3(0.35);\n    }\n    // We draw the X and Y axes\n    if (   (p.x >= -1.0 && p.x <= 1.0)\n       &&  (p.y >= -1.0 && p.y <= 1.0)) {\n        color += vec3(0.25);\n    }\n    // We draw the X and Y axes\n    if (equals(p.x,0.0) || equals(p.y,0.0)) {\n        color += vec3(0.5);\n    }\n    // We draw the red function\n    if ( f(p.x, p.y) ) {\n    \tcolor += vec3( 1.0, 0.0, 0.0 );\n    }\n    // And the green function\n    if ( g(p.x, p.y) ) {\n    \tcolor += vec3( 0.0, 1.0, 0.0 );\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltfGRM","date":"1419733821","viewed":425,"name":"Functions Toy","username":"sebastien","description":"A simplistic shader to visualize math functions in the form of f(x) == y. Move your mouse along the X axis to adjust the zoom level (100 to 1/100).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["math","function"],"hasliked":0,"parentid":"","parentname":""}}