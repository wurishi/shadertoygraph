{"ver":"0.1","info":{"id":"fldczr","date":"1659671952","viewed":142,"name":"Moon reflection_","username":"LucasR","description":"Just a reflections test","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set AA to 2 for antialiasing, set it to 0 if the shader is too slow\n#define AA 2\n#define ZERO (min(iFrame,0))\n\n\n// SDFs by iq: https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p ){\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nvec2 mmin(vec2 a, vec2 b){ // min function with extra channel for material ID\n    return (a.x < b.x) ? a : b;\n}\n\nfloat smin( float a, float b, float k ){\n// source: https://iquilezles.org/articles/smin/\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(in vec3 pos, in float time){ // signed distance in m.x and material ID in m.y\n    vec2 m = vec2(sdSphere(pos-vec3(0., 1.5, -5.), 0.5), 1.); // Moon\n    \n    // ocean bounding volume. Extra 2 fps. Not as good as boat BV, but everything counts I guess\n    if(pos.y < 0.23){\n        vec3 q = pos;\n        q.xz = mat2(4, -3, 3, 4)/5.*pos.xz;\n\n        float wav = (sin(5.5468*q.x+time*.856847)+sin(7.151*q.z-time*.5846)); // waves\n        wav += 0.5*(sin(9.841*q.x+time*1.98651)+sin(16.98*q.z-time*2.5483));\n        wav += 0.1*(sin(41.68*q.x+time*3.54865)+sin(68.130*q.z-time*5.5184));\n        wav += 10.5*smoothstep(0., abs(-10.+q.z), sin(35.47*q.z+time*5.4867));\n\n        vec2 ocean = vec2(pos.y + 0.2 + 0.012*wav, 2.);\n        m = mmin(m, ocean);\n    }\n    \n    // boat\n    vec3 b = pos + vec3(time*0.1, 0., 0.);\n    b.z = b.z+2.;\n    b.x = mod(b.x, 8.)-.5; // boat repetition\n    vec2 bt = vec2(sdSphere(b-vec3(0., -0.1, 0.), .2), 3.);\n    \n    // boat bounding volume. Did it just to try it out, and turned out to make a big difference in performance\n    if(bt.x-0.33 < 0.){\n        float an = .15*sin(time*.8);\n        float c = cos(an); float s = sin(an);\n        b.xy = mat2(c, -s, s, c)*b.xy; // make the boat move with the waves\n\n        bt.x = max(bt.x, b.y+.15); // clip sphere of body of boat\n        bt.x = min(bt.x, sdVerticalCapsule(b+vec3(0., .15, 0.), .4, .015)); // mast\n        bt = mmin(bt, vec2(sdRoundBox(b-vec3(0.1, -.11, 0.), vec3(.025, .025, .05), (b.y+.2)*.2), 4.)); // chest\n        vec3 v1 = vec3(0., 0.25, 0.); // define vertices of the sails\n        vec3 v2 = vec3(0.2, -.05, 0.);\n        vec3 v3 = vec3(-0.2, -.05, 0.);\n        bt = mmin(bt, vec2(udTriangle(v1, v2, v3, b)-.005, 5.)); // sails\n        m = mmin(m, bt);\n    }\n    \n    return m;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time ){\n    vec2 res = vec2(-1.0, -1.0);\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    for(int i=0; i<256 && t<tmax; i++){\n        vec2 h = map( ro+rd*t, time );\n        //if( h.x < 0.001 ){\n        if( abs(h.x)<(0.001*t) ){\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\nvec3 calcNormal(vec3 p, float time){\n  vec2 e = vec2(1.0, -1.0) * 0.0005;\n  return normalize(\n    e.xyy * map(p + e.xyy, time).x +\n    e.yyx * map(p + e.yyx, time).x +\n    e.yxy * map(p + e.yxy, time).x +\n    e.xxx * map(p + e.xxx, time).x);\n}\n\nfloat sdCircle( vec2 p, float r ){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\n\n\n\n\n// source: (iq) https://www.shadertoy.com/view/4ttSWf\n\nfloat hash1( vec2 p ){\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x ){\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat fbm_4( in vec2 x ){\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ ){\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\n\n\n\n\n\n\n\n\nvec3 MoonCol(in vec2 p){\n    p -= vec2(0., 1.4);\n    vec3 col;\n    if(length(p) < .57){ // don't calculate col if it won't be projected on the Moon\n        float d = sdCircle(p-vec2(.1, .1), .1);\n\n        d = smoothstep(0.7, -.5, d);\n        col = vec3(d);\n\n        d = sdCircle(p-vec2(-.3, .2), .1);\n        d = smin(d, sdCircle(p-vec2(-.2, .0), .05), .2);\n        d = min(d, sdCircle(p-vec2(.25, .2), .05));\n        d = smin(d, sdCircle(p-vec2(-.1, .2), .05), .1);\n        d = smin(d, sdCircle(p-vec2(.2, .0), .05), .3);\n        d = smin(d, sdCircle(p-vec2(.3, -.1), .05), .3);\n\n\n        float d2 = sdCircle(p-vec2(.05, -.2), .05);\n        d2 = min(d2, sdCircle(p-vec2(.2, .5), .05));\n        d2 = min(d2, sdCircle(p-vec2(-.2, .02), .02));\n\n        col = mix(vec3(0.1), col, smoothstep(0., .1, d));\n        col = mix(vec3(.7), col, smoothstep(0., .1, d2));\n\n        vec2 uv = 2500.*(p - .5 * iResolution.xy) / iResolution.y;\n        col += smoothstep(0., 1., vec3(fbm_4(uv)));\n        col = mix(col, vec3(.0), smoothstep(0., 1., vec3(fbm_4(uv-vec2(1.)))));\n    }\n    return col;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time ){\n    vec3 col = vec3(0.0136, 0.064, 0.144) - max(rd.y, 0.)*0.03; // sky color\n    vec2 res = castRay(ro, rd, time);\n    vec3 pos = ro+res.x*rd;\n    vec3 n = calcNormal(pos, time);\n    \n    // add glow behind Moon\n    col = mix(col, vec3(1., .9, .7), .6*smoothstep(.1, -.8, (length(pos.xy-vec2(0., -.2))-.1)));\n    \n    vec3 sunDir = normalize(vec3(0.2, 0.2, 0.25));\n    vec3 sunCol = vec3(1.2, 1.1, 0.8);\n    \n    float sunDif = clamp(dot(n, sunDir), 0.0, 1.0);\n    if(res.y > 0.5){ // not sky\n        vec3 Mcol = vec3(0.8, 0.7, 0.25); // Moon\n        Mcol = MoonCol(pos.xy);\n        col = Mcol;\n        if(res.y > 1.5){ // Ocean\n            if(res.y < 2.5){\n                col = vec3(0.01, 0.1, 0.2);\n                vec3 refD = reflect(rd, n); // reflection direction\n                \n                // if the reflection direction points towards the camera, there's nothing to reflect\n                // this should improve performance a bit, although I didn't really notice much change\n                if(refD.z < 0.){\n                    vec3 refO = pos + n*0.01; // reflection origin\n                    vec2 ref = castRay(refO, refD, time);\n                    vec3 rPos = refO+ref.x*refD;\n                    vec3 rn = calcNormal(rPos, time);\n                    vec3 rSun = vec3(clamp(dot(rn, sunDir), 0.0, 1.0)); // add shadow\n                    \n                    // I think it should be more efficient when set to 0, but might be slightly worse\n                  # if 1\n                    if((0.5 < ref.y) && (ref.y < 1.5)){ col = mix(col, rSun*MoonCol(rPos.xy), 0.5); }\n                    else if((2.5 < ref.y) && (ref.y < 4.5)){\n                        col = vec3(.3, .2, .1)*rSun; // boat reflections\n                    }else if(4.5 < ref.y){ col = vec3(1.)*rSun; } // sails reflections\n                  # else\n                    col = ((0.5 < ref.y && ref.y < 1.5)\n                    ? mix(col, rSun*MoonCol(rPos.xy), 0.5)\n                    : ((2.5 < ref.y && ref.y < 4.5) ? vec3(.3, .2, .1)*rSun : col));\n                    col = (ref.y > 4.5) ? vec3(1.)*rSun : col;\n                  # endif\n                }\n            }else{ // boat\n                col = vec3(.3, .2, .1);\n                if(res.y > 3.5){\n                    col = vec3(.45, .35, .1); // chest\n                    if(4.5 < res.y){col = vec3(1.);} // sails\n                }\n            }\n        }\n        \n        vec3 lin = vec3(0.0);\n        lin += sunDif*sunCol; // Sun\n        lin += (0.05+0.95*clamp(-n.y, 0.0, 1.0))*vec3(0.01, 0.03, 0.18);\n        col = col*lin;\n        \n        float fog = (1. - exp(-res.x*0.1)) // https://iquilezles.org/articles/fog/\n        ;//*step(pos.y, 0.7); // mask Moon out\n        \n        vec3 fogCol = vec3(0.0136, 0.064, 0.144);\n        vec3 MoonDir = vec3(0., 1.5, -5.);\n        float MoonAmount = max( dot( rd, MoonDir ), 0.0 );\n        fogCol = mix( fogCol, // bluish\n                            vec3(1.0,0.9,0.7), // yellowish\n                            pow(MoonAmount*0.13,8.) );\n        col = mix(col, fogCol, fog);\n    }\n    \n    // clouds\n    vec2 uv = 1.8*rd.xz/rd.y;\n    if(uv.y < 0.){ // don't calculate clouds if it's an ocean pixel. Added 3 or 4 fps\n        uv.x += time*.1;\n        float cl = fbm_4(uv*.6);\n        col = mix(col, vec3(1.), .1*smoothstep(-.1,.9,cl-.3) );//*smoothstep(50.,0.,-pos.z/(pos.y-.0)) );\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 tot = vec3(0.);\n#if AA > 1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = ((fragCoord+o) - .5 * iResolution.xy) / iResolution.y;\n#else\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    vec3 ro = vec3(0., 0., 2.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    float time = iTime;\n    vec3 col = render(ro, rd, time);\n    col = pow(col, vec3(0.4545)); // gamma correction\n    tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}