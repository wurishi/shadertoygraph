{"ver":"0.1","info":{"id":"mtccW4","date":"1699200753","viewed":432,"name":"star in cosmic hell","username":"nayk","description":"star, cosmos, universe","likes":12,"published":1,"flags":1,"usePreview":0,"tags":["star","cosmos","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* original https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/4tyfWy */\n \n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\n\n#define pi acos(-1.)\n#define deg pi/180.\n#define time iTime*pi/10.\n#define R iResolution.xy\n#define ar R.x/R.y\nvec3 cs = vec3(1.,2.,3.);\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n    #if 1\n    return cos(x) * sin(0.5*w)/(0.5*w);       // exact\n    #else\n    return cos(x) * smoothstep(6.2832,0.0,w); // approx\n    #endif    \n}\nvec3 t1(vec2 uv, float t, float v) {\n    vec3 col = vec3(0.);\n    float c = length(uv);\n    \n    uv = vec2(log(length(uv)),atan(uv.x,uv.y));\n    //uv.x *= sin(time*0.1);\n    //uv.x += time*8.;\n    //uv.x *= sin(-time*0.1)*0.1+0.5;\n    //uv.x -= t*-0.2+time*0.1;\n    uv.x += v*-2.;\n    uv.x *= 0.3;\n    //uv.x += time10.5;\n    //uv.y += -time*10.;\n    uv.x += uv.y*0.0795;\n    float sx = floor(uv.x*2.)/pi+2.+fract((uv.y/pi/2.+0.5))*-0.3183;\n    //uv.x += sin(uv.y*80.)*0.1;\n    uv.x = (fract(uv.x*2.)-0.5)/2.;\n    //\n    //uv.x *= 0.5;\n    \n    float s = (min(abs(uv.x-sin(uv.y*8.)*0.1),abs(uv.x+sin(uv.y*8.)*0.1)));\n    //s = min(s,abs(-abs(uv.x)+0.1));\n    //s = min(s,abs(-abs(uv.x)+0.2));\n    //s = min(s,(min(abs((abs(uv.x)-0.15)-sin(uv.y*8.)*0.05),abs((abs(uv.x)-0.15)+cos(uv.y*8.)*0.05))));\n    //s += 0.1;\n    col -= (smoothstep(0.01,0.,abs(uv.x-0.25))+smoothstep(0.01,0.,abs(uv.x+0.25)))*0.02;\n    col -= fcos(uv.xxx*190.+t*25.)*0.1;\n    \n    //col += sin(sx*2.);\n    col += fcos(sx*28.+t+cs*0.2+t*8.)*0.12;\n    col += fcos(sx*0.65*v*v+t*0.1+cs*0.8+time*2.)*0.4+0.6;\n    //col += sin(cs+s*200.+sx*10.+t*10.)*0.5;\n    //col += smoothstep(0.002+pow((1-c),5.)*0.02,0.,s)*(c*0.5+0.5);\n    col = clamp(col,-0.,1.);\n    return col;\n}\n\nvec3 t2(vec2 uv, float t) {\n    vec3 col = vec3(0.);\n    float c = length(uv);\n    uv = uv/dot(uv,uv);\n    uv *= 0.002;\n    uv *= 30.;\n    //uv.xy *= pow(time*0.3,2.)+1.;\n    uv = (fract(uv*12.-0.5)-0.5)/12.;\n    uv = abs(uv)-0.024;\n    uv *= r2d(time*-12.);\n    col = t1(uv,t,log(c)*0.8)*0.7;\n    col = clamp(col,0.,1.);\n    col = mix(col,vec3(0.5),log(1.-c)*0.);\n    return col;\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time2=iTime*speed+.25;\n \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\nvec4 O =fragColor;\nvec2 I= fragCoord;\n\nO*=0.;\n    vec3 p, q, r = iResolution;\n    \n    for(float i=1.,z; i>0.; i-=.02)\n        z=p.z = sqrt(max(z= i - dot( p = vec3(I+I-r.xy,0)/r.y, p ) , -z/1e4)),\n        p.xz *= mat2(cos(iTime*.2+vec4(0,11,33,0))),\n        O += sqrt(z)\n             * pow( cos( dot( cos(q+=p/2.),sin(q.yzx)) /.3) *.5 +.5, 8.)\n             * ( i* sin( i*200.+vec4(6,5,4,3)) + i ) / 7.;\n    O*=O;\n\t//mouse rotation\n dir.xy=rotate(uv,iTime/10.-length(uv)*0.1);\n\tvec3 from=vec3(1.,.5,0.5)+O.xyz;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    \n  \n\n    fragColor*= vec4(cheap_star(uv,anim) * vec3(0.35,1.2,1.15), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}