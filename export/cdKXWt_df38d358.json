{"ver":"0.1","info":{"id":"cdKXWt","date":"1681795122","viewed":93,"name":"Fork Empty Glas","username":"mehow_one","description":"Playing around and learning a bit about sdfs.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","refraction","glass","transparent"],"hasliked":0,"parentid":"4s2GDV","parentname":"Empty Glass"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tTesting some glass material rendering.\n\tYou can rotate the object with the mouse.\n\n*/\n\n#define PI 3.14159265359\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n\n#define t iTime\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 opTwist(in vec3 p )\n{\n    float k = clamp(sin(iTime*PI*.5)*1.,-0.85,.85)*1.5; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return  vec3(m*p.xz,p.y);\n}\n\n\nfloat df(vec3 p)\n{\n    //p += vec3(iTime,0.,0.);\n    vec3 c = vec3(5.,10.1,0.);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    q *= rotate_y(t);\n\tvec3 tw = opTwist(q+vec3(0.,.575,0.));\n    float r = 0.125;\n    float db = sdRoundBox(tw, vec3(0.5,0.5,1. )-r,r);\n    tw = opTwist((q+vec3(0.,-1.2,0.)));\n    float dc = sdRoundedCylinder(tw, r+.175,r,.5-r);\n    return min(db,dc);\n}\n\nvec3 getNormals(vec3 p)\n{\n\tfloat e = .02;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\nvec3 tex(vec3 d)\n{\n\treturn pow(texture(iChannel1,d).xyz*1.4,vec3(1.4));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tmat3 rotmat = rotate_y(t);\n\t\n\tvec3 pos = vec3(.0,.0,-5.0);\n\tvec3 dir = normalize(vec3(uv,2.5));\n\t\n\tvec3 light_dir = normalize(vec3(.4,1.0,.96));\n\t\n\t\n\tfloat dist;\n\t\n\tfor (int i=0; i<80; i++)\n\t{\n\t\tdist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.000001) break;\n\t}\n\n\tvec3 color = vec3(0.0);\n\tvec3 n = getNormals(pos);\n\t\n\tvec3 dfdxn = dFdx(n);\n\tvec3 dfdyn = dFdy(n);\n\t\n\tcolor = tex(dir).xyz;\n\t\n\tif (length(pos)>5.0)\n\t{\n\t\tcolor = vec3(0.0);\n\t}\n\telse\n\t{\n\t\tfloat oa = .5;//df(pos+n)*.5+.5;\n\t\tfloat od = 1.0;\n\n\t\tfloat ior = .7 + noise(n).r*0.1;\n\t\t\n\t\t//oa -= mod(oa,.33);\n\t\t\n\t\tvec3 drefl = reflect(dir,n);\n\t\tvec3 drefr = refract(dir,n,ior);\n\t\t\n\t\tfloat diffuse = max(.0,dot(n,light_dir)*.6+.4)*od*oa*1.25;\n\t\tfloat fresnel1 = dot(-dir,n);\n\t\t\n\t\t\n\t\tvec3 pos2 = pos+drefr*.05;\n\t\tfor (int i=0; i<40; i++)\n\t\t{\n\t\t\tfloat dist = df(pos2);\n\t\t\tpos2+=drefr*-dist;\n\t\t\tif (dist>-.0001) break;\n\t\t}\n\t\tvec3 n2 = getNormals(pos2);\n\t\tvec3 drefl2 = reflect(drefr,-n2);\n\t\tvec3 drefr2 = refract(drefr,-n2,ior);\n\t\tfloat fresnel2 = dot(-drefr,n2);\n\t\t\n\t\tvec3 pos3 = pos2+drefr2*.2;\n\t\tfor (int i=0; i<70; i++)\n\t\t{\n\t\t\tfloat dist = df(pos3);\n\t\t\tpos3+=drefr * dist;\n\t\t\tif (dist<.0001) break;\n\t\t}\n\t\tvec3 n3 = getNormals(pos3);\n\t\tvec3 drefl3 = reflect(drefr2,n3);\n\t\tvec3 drefr3 = refract(drefr2,n3,ior);\n\t\tfloat fresnel3 = dot(-drefr2,n3);\n\t\t\n\t\tvec3 pos4 = pos3+drefr3*.02;\n\t\tfor (int i=0; i<40; i++)\n\t\t{\n\t\t\tfloat dist = df(pos4);\n\t\t\tpos4+=drefr*-dist;\n\t\t\tif (dist>-.0001) break;\n\t\t}\n\t\tvec3 n4 = getNormals(pos4);\n\t\tvec3 drefl4 = normalize(reflect(drefr3,-n4));\n\t\tvec3 drefr4 = normalize(refract(drefr3,-n4,ior));\n\t\tfloat fresnel4 = dot(-drefr3,n4);\n\t\t\n\t\t\n\t\t\tcolor.r = tex(normalize(refract(drefr,-n2,ior*.9+noise(pos.xyz).r*fresnel2*.01))).r;\n\t\t\tcolor.g = tex(normalize(refract(drefr,-n2,ior*1.0+noise(pos.xyz).g*fresnel2*.01))).g;\n\t\t\tcolor.b = tex(normalize(refract(drefr,-n2,ior*1.1+noise(pos.xyz).b*fresnel2*.01))).b;\n\t\t\n\t\t\n\t\tcolor = mix(texture(iChannel1,drefl2).xyz,color,pow(-fresnel2,.2));\n\t\t//color = mix(tex(drefl).xyz,color*.7,pow(fresnel1,2.5));\n\t\t\n\t\tcolor += mix(1.-n2,n2,fresnel1)*0.075;\n        color += vec3(diffuse);\n\t}\n\t\n\t\t\n\t//color += noise(vec3(fragCoord.xy,t*60.0))*0.01;\n\t\n\tfragColor = vec4(pow(color ,vec3(.725)),1.0);\n}","name":"Image","description":"","type":"image"}]}