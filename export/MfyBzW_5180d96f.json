{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Lame ass without proper textures\n// Uncomment them in common if you have the browser extension\n// https://github.com/patuwwy/ShaderToy-Chrome-Plugin\n\nSphere swiborgSphere = Sphere(\n    vec3(0.0, 2.0, 6.0),\n    2.0,\n    Material(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        0.0\n    )\n);\n\nconst float moondist = float(1 << 30);\nconst float moonRadius = moondist / 20.0;\nconst vec3 moonStartingDir = normalize(vec3(0.4, 1, 0.4));\n\nconst vec3 milkyWayPlaneNorm = normalize(vec3(0, 0, +1));\n#define milkyWayPlaneNormTan (vec3(Rotate2DC(milkyWayPlaneNorm.xy, PI_DIV_2), milkyWayPlaneNorm.z))\n#define milkyWayPlaneNormTan2 (Rotate3D_2AnglesC(milkyWayPlaneNorm, vec2(PI_DIV_2, 0)))\n\n\nSphere moon = Sphere(\n    milkyWayPlaneNormTan2  * moondist,\n    moonRadius,\n    Material(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        0.0\n    )\n);\n\n\nPlane dafloor = Plane(\n    normalize(vec3(0, -1.0, 0)),\n    vec3(0, -1, 0),\n    Material(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        0.0\n    )\n);\n\nvec3 cameraPos = vec3(+0, +2, 0.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screenUV = fragCoord/iResolution.xy;\n\n    // [-1.0..1.0] screen coordinates\n    vec2 uvClip = \n        (fragCoord.xy - iResolution.xy * 0.5) / \n        min(iResolution.x, iResolution.y);\n    \n    //vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0; // [-1.0..1.0]\n    \n    vec2 mouse = texelFetch(iChannel3, ivec2(1, 0), 0).xy;\n    vec3 rd = GetDir(uvClip, mouse);\n        \n    vec3 posOffset = texelFetch(iChannel3, ivec2(0, 0), 0).xyz;\n    cameraPos += posOffset;\n    \n    \n    moon.pos = RotateAlong(moon.pos, milkyWayPlaneNorm, iTime * 0.0625);\n    //moon.pos.xy = Rotate2D(moon.pos.xy, iTime * 0.0625);\n\n    vec4 ambient = texture(iChannel2, vec2(0.5, 0.5), +10.0);\n    \n    //ambient *= 2.0;\n\n    const float ambientPower = 0.8;\n\n    Ray ray = Ray(cameraPos, rd);\n    HitData hd;\n    \n    hd = Sphere_Intersect(swiborgSphere, ray);\n    if(hd.success) {\n        vec3 normal = hd.normal;\n        normal.xz = -normal.xz;\n    \n        vec4 color = textureLod(iChannel0, Sphere_UV(normal), 0.0);\n        color = mix(color, ambient, ambientPower);\n        \n        fragColor = color;\n        return;\n    } \n\n    hd = Plane_Intersect(dafloor, ray);\n    if(hd.success) {\n        float planeBias = +0.0;\n        vec4 color;\n        //color = PlaneOG(hd.pos.xz, iResolution.yy / float(1 << 4));\n        \n        \n        color = texture(iChannel1, Plane_UV(hd, 8.0), planeBias);\n        color = mix(color, ambient, ambientPower);\n        \n        fragColor = color;\n        return;\n    }\n    \n    hd = Sphere_Intersect(moon, ray);\n    if(hd.success) {\n        vec3 normal = hd.normal;\n        \n        //normal.xz = -normal.xz;\n        \n        float res = 32.0;\n        \n        vec2 uv1 = Sphere_UV(normal);\n        vec2 uv2 = uv1;\n        \n        float texelSize = 1.0 / res;\n        //uv1 -= texelSize * 0.5;\n        \n        vec2 coord = fprecision(uv1, res) * res;\n        vec2 coordH = uv2 * res;\n        \n        vec2 blend = fract(coordH);\n        \n        float offset = 1.0;\n        \n        float seed = 2.0;//47.932112422167;\n        \n        float h1 = random2(coord, seed);\n        float h2 = random2(coord + vec2(offset, 0), seed);\n        float h3 = random2(coord + vec2(0, offset), seed);\n        float h4 = random2(coord + vec2(offset, offset), seed);\n        \n        float h12 = mix(h1, h2, blend.x);\n        float h34 = mix(h3, h4, blend.x);\n        \n        float height = mix(h12, h34, blend.y);\n        \n        vec3 top = vec3(1, 1, 1);\n        vec3 low = vec3(0.2, 0.2, 0.2);\n        \n        vec3 color = mix(low, top, height);\n        //color = mix(color, ambient, ambientPower);\n        \n        fragColor.xyz = color.xyz;\n        return;\n    }\n    \n    const float cubemapLod = 0.0;\n    \n    float cubemapRes = iResolution.x * 0.5;\n    //float cubemapRes = float(1 << 31);\n\n    //rd = rd.zxy;\n    //rd.xz = -rd.xz;\n\n    vec4 cubemap = mix(\n        textureLod(iChannel2, OctaHedron_UV(SetDirRes(rd, cubemapRes)), cubemapLod),\n        ambient, \n        0.0\n    );\n    \n    //float alpha = cubemap.x + cubemap.y + cubemap.z;\n    \n    //cubemap = mix(vec4(0.3, 1, 1, 1), cubemap, alpha);\n    \n    //fragColor = cubemap;\n    \n    vec4 star = StarSample(rd, fragCoord, cubemapRes, iTime);\n\n    // Output to screen\n    fragColor = mix(cubemap, star, 0.0);// min(star.w, 1.0 - cubemap.w));\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/* shadertoy-plugin parameters\n{\n    \"textures\": [\n        //\"https://static.turbosquid.com/Preview/2014/08/01__21_24_43/swiborg.jpg60a66eed-d386-4ba3-a118-d13a6012ad8bLarge.jpg\",\n        //\"https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/371b6fdf-69a3-4fa2-9ff0-bd04d50f4b98/de8synv-6aad06ab-ed16-47fd-8898-d21028c571c4.png/v1/fill/w_894,h_894,q_70,strp/stone_floor_texture_001_by_dimimoon_de8synv-pre.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTAyNCIsInBhdGgiOiJcL2ZcLzM3MWI2ZmRmLTY5YTMtNGZhMi05ZmYwLWJkMDRkNTBmNGI5OFwvZGU4c3ludi02YWFkMDZhYi1lZDE2LTQ3ZmQtODg5OC1kMjEwMjhjNTcxYzQucG5nIiwid2lkdGgiOiI8PTEwMjQifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.1s6qCHg5ECfjGbMwpiDmF-12XYU3cyWtdHhc2-9_GfU\",\n        //\"https://i.imgur.com/ISo3Gem.jpeg\"\n    ]\n}\n*/\n\n\nprecision highp float;\n\n#define FLT_MAX 3.402823466e+38F\n#define PI 3.14159265358979323846264338327950288\n#define PI_DIV_2 (PI * 0.5)\n#define TAU 6.2831853071795864\n\nstruct HitData\n{\n\tfloat dist;\n\tvec3 pos;\n\tvec3 normal;\n\n\tbool success;\n};\n\nHitData HitData_Init(float dist, vec3 pos, vec3 normal)\n{\n\tHitData h;\n\n\th.dist = dist;\n\th.pos = pos;\n\th.normal = normal;\n\th.success = true;\n\n\treturn h;\n}\n\nHitData HitData_Empty()\n{\n\tHitData h;\n\th.dist = 0.0;\n\th.normal = vec3(0.0);\n\th.pos =  vec3(0.0);\n\th.success = false;\n\n\treturn h;\n}\n\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n\nvec3 Ray_PointAt(in Ray r, float len)\n{\n\treturn r.origin + (len * r.dir);\n}\n\nstruct Material\n{\n\tvec4 diffuse;\n\tvec4 ambient;\n\tvec4 specular;\n\tfloat shininess;\n};\n\nstruct Sphere \n{\n\tvec3 pos;\n\tfloat radius;\n\tMaterial material;\n};\n\n\nstruct Plane\n{\n\tvec3 norm;\n\tvec3 p0;\n\n\tMaterial material;\n};\n\nHitData Plane_Intersect(in Plane p, in Ray r)\n{\n\tfloat denom = dot(p.norm, r.dir);\n\tif (denom > 1e-6)\n\t{\n\t\tvec3 p0r0 = p.p0 - r.origin;\n\t\tfloat dist = dot(p.norm, p0r0) / denom;\n\t\tif (dist > 1e-6)\n\t\t{\n\t\t\tvec3 point = Ray_PointAt(r, dist) + vec3(100, 0, 100);\n            //point.xz = r.dir.xz / r.dir.y;\n            //point.y = 0.0;\n\t\t\tvec3 normal = -p.norm;\n\n\t\t\treturn HitData_Init(dist, point, normal);\n\t\t}\n\t}\n\n\treturn HitData_Empty();\n}\n\nHitData Plane_Intersect2(in Plane p, in Ray r)\n{\n    float denom = dot(p.norm, r.dir);\n    if (abs(denom) > 1e-6) // Use abs to handle both positive and negative denom\n    {\n        vec3 p0r0 = p.p0 - r.origin;\n        float dist = dot(p.norm, p0r0);\n        \n        if (dist > 0.0)\n        {\n            dist /= denom; // Divide only if denom is not zero\n            if (dist > 1e-6) // Check if dist is sufficiently large\n            {\n                vec3 point = Ray_PointAt(r, dist);\n                vec3 normal = -p.norm;\n\n                return HitData_Init(dist, point, normal);\n            }\n        }\n    }\n\n    return HitData_Empty();\n}\n\n\nHitData Sphere_Intersect(in Sphere s, in Ray r)\n{\n\tvec3 oc = r.origin - s.pos.xyz;\n\n\n\tfloat a = 1.0f;\n\tfloat b = 2.0f * dot(oc, r.dir);\n\tfloat c = dot(oc, oc) - s.radius * s.radius;\n\n\tfloat disc = b * b - 4.0 * a * c;\n\n\tif (disc < 0.0) {\n\t\treturn HitData_Empty();\n\t}\n\n\tfloat dist = (-b - sqrt(disc)) / (2.0f * a);\n\n\tif (dist < 0.0f) return HitData_Empty();\n\n\tvec3 p = Ray_PointAt(r, dist);\n\tvec3 normal = normalize(p - s.pos.xyz);\n\n\treturn HitData_Init(dist, p, normal);\n}\n\nvec2 Sphere_UV(in vec3 dir) \n{\n\n\treturn vec2(\n        (atan(dir.x, dir.z) / TAU) + 0.5,\n        (asin(dir.y) / PI) + 0.5\n    );\n}\n\n\nvec2 SignNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, \n                (v.y >= 0.0) ? +1.0 : -1.0);\n}\n\n// https://jcgt.org/published/0003/02/01/paper.pdf#lstlisting.1\nvec2 OctaHedron_UV(in vec3 dir) \n{\n    dir = dir.xzy;\n\n\tvec2 p = dir.xy * (1.0 / (abs(dir.x) + abs(dir.y) + abs(dir.z)));\n    \n    p = (dir.z < 0.0) ? ((1.0 - abs(p.yx)) * SignNotZero(p)) : p;\n    \n    // [-1..1] -> [0..1] \n    return p * 0.5 + 0.5;\n}\n\nvec2 OctaHedron_UV2(vec3 co)\n{\n    // projection onto octahedron\n\tco /= dot( vec3(1), abs(co) );\n\n    // out-folding of the downward faces\n    if ( co.y < 0.0 ) {\n\t\tco.xy = (1.0 - abs(co.zx)) * sign(co.xz);\n    }\n\n\t// mapping to [0;1]Ë†2 texture space\n\treturn co.xy * 0.5 + 0.5;\n}\n\n\nvec2 Plane_UV(in HitData h, float scaler)\n{\n\tvec2 uv = fract(h.pos.xz / scaler); //fract(h.pos.xz);\n    \n    //uv.x = clamp(uv.x, 0.0, 1.0);\n    //uv.y = clamp(uv.y, 0.0, 1.0);\n    return uv;\n}\n\nfloat fprecision(float x, float samples)\n{\n    return round(x * samples) / samples;\n}\n\nvec2 fprecision(vec2 v, float samples)\n{\n    return vec2(\n        fprecision(v.x, samples),\n        fprecision(v.y, samples)\n    );\n}\n\nvec3 fprecision(vec3 v, float samples)\n{\n    return vec3(\n        fprecision(v.x, samples),\n        fprecision(v.y, samples),\n        fprecision(v.z, samples)\n    );\n}\n\n#define Rotate2DC(uv, a) (uv * mat2(cos(a), sin(a), -sin(a), cos(a)))\n\nvec2 Rotate2D(in vec2 uv, in float angle) \n{ \n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return uv * mat2(\n        +c, +s,\n        -s, +c\n    );\n}\n\n\n#define Rotate3D_2AnglesC(rd, rads) \\\n    (vec4(Rotate2DC(rd.yz, rads.y), \\\n          Rotate2DC(rd.xz, rads.x)).zxw)\n\n\nvec3 Rotate3D_2Angles(in vec3 rd, in vec2 rads)\n{   \n    rd.yz = Rotate2D(rd.yz, rads.y);\n    rd.xz = Rotate2D(rd.xz, rads.x);\n    \n    return rd;\n}\n\nvec2 GetCameraRotation(in vec2 mouse)\n{\n    return vec2(PI * mouse.x, PI_DIV_2 * mouse.y);\n}\n\n\nvec3 GetDir(in vec2 uv, in vec2 mouse)\n{\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    rd = Rotate3D_2Angles(rd, GetCameraRotation(mouse));\n\n    return normalize(rd);\n}\n\nvec3 SetDirRes(vec3 v, float res)\n{\n    return normalize(fprecision(v, res));\n}\n\n#define SEED3 43758.5453\n#define PHI 1.61803398874989484820459\n\nfloat random2(in vec2 xy, in float seed){\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat random3(vec3 x) {\n    return fract(sin(x.x + x.y * 57.0 + x.z * 113.0) * SEED3);\n}\n\nvec4 StarColor(in vec2 frag, in float time)\n{\n\n    uint kek = floatBitsToUint(time);\n    kek = kek & 255u;\n    float fkek = float(kek);\n    return vec4(\n        max(random2(frag, fkek), 0.6),\n        max(random2(frag, fkek + 1.0), 0.6), \n        max(random2(frag, fkek + 2.0), 0.6), \n        0.8);\n}\n\nvec4 StarSample(in vec3 dir, in vec2 fragCoord, in float res, in float time)\n{\n    vec3 lowresDir = SetDirRes(dir, res);\n\n    //float hasStars = random2(Sphere_UV(lowresDir) * res, SEED3);\n    float hasStars = random3(lowresDir);\n    const float threshold = 0.995;\n    \n    if(hasStars > threshold) \n        return StarColor(fragCoord, time);\n    else\n        return vec4(0);\n}\n\nvec4 PlaneOG(vec2 u, vec2 res)\n{   ivec2 U = ivec2( u / res * 16.0 ) % 2;\n    return vec4( U.x == U.y );\n}\n\nvec4 Plane_Color(vec2 screenUV, vec2 scaler, vec4 baseColor)\n{   ivec2 square = ivec2(screenUV / scaler) % 2;\n    return mix(vec4(square.x == square.y),\n               baseColor,\n               0.0);\n}\n\nvec4 Plane_Color(vec2 screenUV, vec2 scaler) {\n    return Plane_Color(screenUV, scaler, vec4(1, 1, 1, 1));\n}\n\nmat4 LookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 dir = normalize(origin - target);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    up.xy = Rotate2D(up.xy, roll);\n    \n    vec3 right = normalize(cross(up, dir));\n\n    vec3 cameraUp = cross(dir, right);\n\n    return mat4(\n        right, 0,\n        cameraUp, 0,\n        dir, 0,\n        0, 0, 0, 1\n    );\n}\n\n\nRay GetRay(in vec2 uv, in mat4 transform, in vec3 camera)\n{\n\tfloat u = uv.x;\n\tfloat v = 1.0 - uv.y;\n\n\tvec4 far = \n        vec4(u * 2.0 - 1.0, v * 2.0 - 1.0, 1.0, 1.0) * transform;\n\tfar /= far.w;\n\n\tRay r;\n\tr.origin = camera;\n\tr.dir = normalize(far.xyz - camera);\n\n\treturn r;\n}\n\nvec3 RotateAlong(vec3 v, vec3 axis, float angle) \n{\n\treturn \n        v * cos(angle) + \n        cross(axis, v) * sin(angle) + \n        axis * dot(axis, v) * (1.0 - cos(angle));\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Numbers are based on jabascript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SHIFT = 16;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst int KEY_O = 79;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_SEMICOLON = 59;\nconst int KEY_SEMICOLON2 = 186;\n\n\n#define MOUSE_CAMERA 0\n\nconst float velocity = 1.0 / 8.0;\n\nvec3 handleMovement(vec3 offset, vec2 mouse) {\n\n    vec2 left  = max(texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x) * vec2(-1, 0);\n                     \n    vec2 up    = max(texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x) * vec2(0, 1);\n                     \n    vec2 right = max(texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x) * vec2(1, 0);\n                     \n    vec2 down  = max(texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x) * vec2(0, -1);\n                     \n    float shift = 1.0 + float(texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).x > 0.0);\n                     \n    vec3 new_offset;\n    new_offset.xz = (left + up + right + down) * velocity * shift;\n    new_offset = Rotate3D_2Angles(new_offset, GetCameraRotation(mouse));\n\n    return offset + new_offset;\n}\n\n\nconst float ebych_rotation_velocity = 0.02;\n\nvec3 handleCamera(vec3 camera) {\n\n    vec2 left  = max(texelFetch(iChannel1, ivec2(KEY_K,    0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x) * vec2(-1, 0);\n                     \n    vec2 up    = max(texelFetch(iChannel1, ivec2(KEY_O,  0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x) * vec2(0, 1);\n                     \n    vec2 right = max(max(\n                     texelFetch(iChannel1, ivec2(KEY_SEMICOLON,  0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_SEMICOLON2, 0), 0).x),\n                     texelFetch(iChannel1, ivec2(KEY_RIGHT,      0), 0).x) * vec2(1, 0);\n                     \n    vec2 down  = max(texelFetch(iChannel1, ivec2(KEY_L,     0), 0).x,\n                     texelFetch(iChannel1, ivec2(KEY_DOWN,  0), 0).x) * vec2(0, -1);\n                     \n    vec2 dir = (left + up + right + down);\n                     \n    vec2 new_offset;\n    new_offset = dir * ebych_rotation_velocity;\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0; // [-1.0..1.0]\n\n    #if MOUSE_CAMERA == 0\n    vec2 v = (new_offset + camera.xy);\n    #else \n    vec2 v = mouse;\n    #endif\n    v.y = clamp(v.y, -1.0, 1.0);\n\n    return vec3(v, length(dir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 camera = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    camera = handleCamera(camera);\n\n    vec3 offset = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    offset = handleMovement(offset, camera.xy);\n\n    if(ivec2(fragCoord) == ivec2(0, 0)) {\n        fragColor = vec4(offset, 0);\n    } else if(ivec2(fragCoord) == ivec2(1, 0)) {\n        fragColor = vec4(camera, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfyBzW","date":"1734532937","viewed":29,"name":"The Shrine of Swiborg[def text]","username":"vladdoc","description":"swiborg shall shine its bald head(once I implement speculars)","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["swiborg"],"hasliked":0,"parentid":"","parentname":""}}