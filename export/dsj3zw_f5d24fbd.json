{"ver":"0.1","info":{"id":"dsj3zw","date":"1667537056","viewed":130,"name":"Bunch of color gradient routines","username":"Envy24","description":"Different examples commented in mainImage.\nUse mouse to change angle.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["color","radial","trigonometric","linear","smoothstep","smooth","directional","gradients","multi","angular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Other:\n    https://www.shadertoy.com/view/ll2GD3\n    https://www.shadertoy.com/view/lt2GDc\n    https://www.shadertoy.com/view/4dsSzr\n    https://www.shadertoy.com/view/4sdSz7\n    https://www.shadertoy.com/view/XsXBRj\n    https://www.shadertoy.com/view/XldBR8\n    https://www.shadertoy.com/view/4ttfRN\n    https://www.shadertoy.com/view/4scSRn\n    https://www.shadertoy.com/view/Mt2XDK\n*/\n\n#define R               ( iResolution )\n\n#define A_ ( vec3(1,0,0) )\n#define B_ ( vec3(1,0,1) )\n#define C_ ( vec3(0,0,1) )\n#define D_ ( vec3(0,1,1) )\n#define E_ ( vec3(0,1,0) )\n#define F_ ( vec3(1,1,0) )\n#define G_ ( vec3(0.4, 1.0, 0.8) )\n#define H_ ( vec3(0.2, 0.1, 0.3) )\n#define K_ ( vec3(0.1, 0.4, 0.7) )\n#define L_ ( vec3(0.7, 0.4, 0.1) )\n\nvec3 linear_gradient(in vec3 c0, in vec3 c1, in float t) \n{ \n    //return mix( c0, c1, t );\n    return c0 + (c1 - c0) * t; \n}\nvec3 trigonometric_gradient(\n    in vec3 c0,\n    in vec3 c1,\n    in float amp,\n    in float freq,\n    in float phase0,\n    in float t)\n{  \n    t = (1.+amp*sin(phase0+freq*t)) * 0.5;\n    return c0 + (c1 - c0) * t;\n    \n    #define shape(x)     ( 1.-pow(max(0.0, 2.*abs(x)-1.), 0.5) )\n    //return c0 + (c1 - c0) * smoothstep(88./R.y, 0., shape(t*2.));\n}\nvec3 smoothstep_gradient(in vec3 c0, in vec3 c1, in float t)\n{\n    // return mix(c0, c1, smoothstep(0., 1., t));\n    //t = (t - 0.) / (1. - 0.); // inverse linear interpolation\n    t = clamp(t, 0., 1.);\n    t = t * t * (3.0 - 2.0 * t); // P(t) = 3t^2 - 2t^3 - smoothstep polynomial\n         \n    return linear_gradient(c0, c1, t);\n}\nvec3 angular_gradient(vec2 NDC) // FabriceNeyret2 version from: https://www.shadertoy.com/view/XsXBRj\n{   \n    const float INV_TAU = 0.1591549430918953;\n    //const int N = 1; vec3 c[N] = vec3[N]( A_ );\n    //const int N = 2; vec3 c[N] = vec3[N]( A_, E_ );\n    //const int N = 3; vec3 c[N] = vec3[N]( A_, E_, C_ );\n    //const int N = 4; vec3 c[N] = vec3[N]( A_, E_, C_, B_ );\n    const int N = 5; vec3 c[N] = vec3[N]( A_, E_, C_, B_, F_ );\n    // 5 is max.\n\n    float a = float(N) * ( atan(NDC.y, NDC.x) * INV_TAU + .5 );\n    int i = int(a);\n    return mix( c[i], c[(i+1)%N], fract(a) );\n}\nvec3 radial_gradient(vec3 c0, vec3 c1, vec2 NDC)\n{\n    return linear_gradient(c0, c1, clamp(length(NDC), 0., 1.));\n    //return smoothstep_gradient(c0, c1, length(NDC));\n    //return trigonometric_gradient(c0, c1, 1., 3.14*10., 0., length(NDC));\n    //return trigonometric_gradient(c0, c1, 1., 3.14*10., 0., clamp(length(NDC), 0., 1.));\n}\nvec3 color_wheel(vec2 NDC)\n{   \n    const float invPI = 0.31830988618;\n    const int N = 6; vec3 c[N] = vec3[N]( \n        vec3(0,1,1), vec3(0,1,0), vec3(1,1,0),\n        vec3(1,0,0), vec3(1,0,1), vec3(0,0,1) );\n\n    float a = ( atan(NDC.y, NDC.x) * invPI + 1.0 ) * float(N) * 0.5;\n    int i = int(a);\n    //return mix( c[i], c[(i+1)%N], fract(a) );\n    return mix( vec3(1), mix( c[i], c[(i+1)%N], fract(a) ), length(NDC) );\n}\nvec3 directional_gradient(in vec3 c0, in vec3 c1, in vec2 NDC, in vec2 dir) \n{ \n   vec2 projNDCtoDIR = (dot(NDC, dir) / dot(dir, dir)) * dir;\n   float t = clamp(length(projNDCtoDIR), 0., 1.);\n   \n   return linear_gradient(c0, c1, t);\n   //return smoothstep_gradient(c0, c1, t);\n   //return trigonometric_gradient(c0, c1, 1., 3.14*10., 0., t); \n}\nvec3 directional_gradient(in vec3 c0, in vec3 c1, in vec2 SC, in float rad) \n{ \n   SC /= iResolution.xy; // map xy from [0; R.x][0; R.y] to [0,1][0,1]  \n   rad = clamp(rad, 0., 1.57079632679); // PI/2 = 1.57079632679\n\n   vec2 dir = vec2(cos(rad), sin(rad)),\n        projSCtoDIR = (dot(SC, dir) / dot(dir, dir)) * dir;\n   float t = length(projSCtoDIR);\n\n         t = clamp(t, 0., 1.);\n\n   return linear_gradient(c0, c1, t);\n   //return smoothstep_gradient(c0, c1, t);\n   //return trigonometric_gradient(c0, c1, 1., 2.*3.14*10., 0., t);\n}\nvec3 multi_color_linear_gradient(float t)\n{\n    //const int N = 5; vec3 c[N] = vec3[N]( A_, E_, C_, B_, F_ );\n    const int N = 12; vec3 c[N]   = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1), vec3(0) );\n    \n    /* Cycled *\n    t *= float(N);\n    int i = int(t);   \n    //return linear_gradient(c[i], c[(i+1)%N], 0.);\n    //return linear_gradient(c[i], c[(i+1)%N], fract(t));\n    return smoothstep_gradient(c[i], c[(i+1)%N], fract(t));\n    /* Not */\n    t *= float(N-1);\n    int i = int(t);   \n    //return linear_gradient(c[i], c[i+1], 0.);\n    //return linear_gradient(c[i], c[i+1], fract(t));\n    return smoothstep_gradient(c[i], c[i+1], fract(t));\n}\nvec3 multi_color_angular_gradient(vec2 NDC)\n{      \n    //const int N = 1; vec3 c[N]  = vec3[N]( A_ );\n    //const int N = 2; vec3 c[N]  = vec3[N]( A_, B_ );\n    //const int N = 3; vec3 c[N]  = vec3[N]( A_, B_, C_ );\n    //const int N = 4; vec3 c[N]  = vec3[N]( A_, B_, C_, D_ );\n    //const int N = 5; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_ );\n    //const int N = 6; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_ );\n    //const int N = 6; vec3 c[N]  = vec3[N]( B_, C_, D_, E_, F_, A_  ); // same as color wheel\n    //const int N = 7; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_ );\n    //const int N = 8; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_ );\n    //const int N = 9; vec3 c[N]  = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_ );\n    //const int N = 10; vec3 c[N] = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_ );\n    //const int N = 11; vec3 c[N] = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1) );\n    const int N = 12; vec3 c[N]   = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1), vec3(0) );\n    // e.t.c\n\n    const float invPI = 0.31830988618;\n    float a = ( atan(NDC.y, NDC.x) * invPI + 1.0 ) * float(N) * 0.5;\n    int i = int(a);\n    return mix( c[i], c[(i+1)%N], fract(a) );\n    //return mix( c[i], c[(i+1)%N], -fract(a) ); // angular step\n    //return mix( vec3(1), mix( c[i], c[(i+1)%N], fract(a) ), length(NDC) );\n}\nvec3 multi_color_radial_gradient(vec2 NDC)\n{\n    float t = length(NDC);\n    //const int N = 5; vec3 c[N] = vec3[N]( A_, E_, C_, B_, F_ );\n    const int N = 12; vec3 c[N]   = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1), vec3(0) );\n    t *= float(N); t = mod(t, float(N));\n    int i = int(t);\n\n    return linear_gradient(c[i], c[(i+1)%N], fract(t));\n    //return smoothstep_gradient(c[i], c[(i+1)%N], fract(t) );\n}\nvec3 multi_color_directional_gradient(in vec2 SC, in float rad) \n{ \n    SC /= iResolution.xy; // map xy from [0; R.x][0; R.y] to [0,1][0,1]  \n    rad = clamp(rad, 0., 1.57079632679); // PI/2 = 1.57079632679\n\n    vec2 dir = vec2(cos(rad), sin(rad)),\n        projSCtoDIR = (dot(SC, dir) / dot(dir, dir)) * dir;\n    float t = length(projSCtoDIR);\n\n    //const int N = 5; vec3 c[N] = vec3[N]( A_, E_, C_, B_, F_ );\n    const int N = 12; vec3 c[N]   = vec3[N]( A_, B_, C_, D_, E_, F_, G_, H_, K_, L_, vec3(1), vec3(0) );\n    t *= float(N); t = mod(t, float(N));\n    int i = int(t);\n\n    //return linear_gradient(c[i], c[(i+1)%N], fract(t));\n    //return smoothstep_gradient(c[i], c[(i+1)%N], fract(t));\n    \n    #define shape(x)     ( 1.-pow(max(0.0, 2.*abs(x)-1.), 0.5) )\n    return linear_gradient(c[i], c[(i+1)%N], smoothstep(16./R.y, 0., shape(fract(t))) );\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    /**\n    O = \n        SC.y < R.y*0.5 ?\n            vec4(linear_gradient(G_, H_, SC.x/R.x), 1.) :\n            vec4(linear_gradient(H_, G_, SC.x/R.x), 1.);\n    /**\n    O = \n        SC.y < R.y*0.5 ?\n            vec4(smoothstep_gradient(K_, L_, SC.x/R.x), 1.) :\n            vec4(smoothstep_gradient(L_, K_, SC.x/R.x), 1.);\n    /**\n    #define AMP    ( 1. )\n    #define FREQ   ( 3.14 * 10. )\n    #define PHASE0 ( 0. )\n        O = \n            SC.y < R.y*0.5 ?\n                vec4(trigonometric_gradient(G_, H_, AMP, FREQ, PHASE0, SC.x/R.x), 1.) :\n                vec4(trigonometric_gradient(H_, G_, AMP, FREQ, PHASE0, SC.x/R.x), 1.);\n    /**\n        vec2 dir = rotateAroundZ(vec2(1,0), iTime),\n             NDC = map_to_centered_ndc(SC, 0.5, vec2(0), true);\n        O = vec4(directional_gradient(G_, H_, NDC, dir), 1. );\n    /**\n        float a = atan(iMouse.y, iMouse.x);\n        O = vec4(directional_gradient(G_, H_, SC, a), 1. );\n    /**\n        vec2 NDC = (SC+SC-R.xy) / R.y;\n        O = vec4(angular_gradient(NDC), 1.);\n    /**\n        vec2 NDC = (SC+SC-R.xy) / R.y;\n        //NDC = twirl( NDC, vec2(0), 1., sinOSC(0., 80., iTime) ); // try uncomment\n        O = mix( vec4(0), vec4(multi_color_angular_gradient(NDC), 1.), smoothstep( 5./R.y, 0., 1.01*length(NDC)-1. ) );\n    /**\n        vec2 NDC = (SC+SC-R.xy) / R.y;\n        O = mix( vec4(0), vec4(color_wheel(NDC), 1.), smoothstep( 5./R.y, 0., 1.003*length(NDC)-1. ) );\n    /**\n        vec2 NDC = (SC+SC-R.xy) / R.y;\n        O = vec4(radial_gradient(G_, H_, NDC), 1.);\n    /**\n        O = vec4(multi_color_linear_gradient(SC.x/R.x), 1.);\n    /**\n        vec2 NDC = (SC+SC-R.xy) / R.y;\n        O = vec4(multi_color_radial_gradient(NDC), 1.);\n    /**/\n        vec2 M = iMouse.z > 0. ? iMouse.xy : R.xy;\n        float a = atan(M.y, M.x);\n        O = vec4(multi_color_directional_gradient(SC, a), 1. );\n    /**/\n    \n    // Gamma correction.\n    //O = pow( O, vec4(1.0/2.2) );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nvec2 twirl(vec2 NDC, vec2 C, float maxDistance, float phase)\n{\n    NDC -= C;\n\n    float length_ = length(NDC),\n          strength = \n              length_ > maxDistance ?\n                  0. :\n                  (maxDistance - length_) / maxDistance,\n          c = cos(phase * strength),\n          s = sin(phase * strength);\n\n    return vec2( \n        NDC.x * c - NDC.y * s,\n        NDC.x * s + NDC.y * c\n       );\n}\n","name":"Common","description":"","type":"common"}]}