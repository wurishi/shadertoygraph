{"ver":"0.1","info":{"id":"dlcGDj","date":"1683209382","viewed":254,"name":"Elliptope","username":"Ultraviolet","description":"The elliptope is the shape of the PSD matrices space (among all symmetric matrices with unit diagonal, which is isomorphic to RÂ³).\nSource: https://www.youtube.com/watch?v=2uKoKKLgZ4c","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["elliptope","spectrahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\n#define AA 3\n\n#define PI\t3.1415927\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec2 boxIntersection( vec3 ro, vec3 rd)\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m);\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n\n    return vec2( tN, tF );\n}\n\n\n// compute det(M) where\n//     | 1 x y |\n// M = | x 1 z |\n//     | y z 1 |\n//\nfloat det(vec3 p) {\n    return 1.+2.*p.x*p.y*p.z -p.x*p.x-p.y*p.y-p.z*p.z;\n}\n\nvec3 det_grad(vec3 p) {\n    return 2.*vec3(p.y*p.z-p.x, p.x*p.z-p.y, p.x*p.y-p.z);\n}\n\n\nvec4 intersect_elliptope(vec3 ro, vec3 rd) {\n\n    vec2 tnf = boxIntersection(ro,rd);\n    \n    float t = tnf.x;\n    for(; t<tnf.y; t += 0.01) {\n        vec3 p = ro+rd*t;\n        if(det(p) > 0.) {\n            break;\n        }\n    }\n    \n    if(t >= tnf.y) {\n        return vec4(-1.);\n    }\n    \n    vec3 p = ro+rd*t;\n    vec3 n = det_grad(p);\n    n = -normalize(n);\n    \n    return vec4(t,n);\n}\n\nconst vec3 bg_col = vec3(.8);\nconst vec3 dif_col = vec3(0.7, 0.9, 1.0);\nconst vec3 amb_col = mix(bg_col, dif_col, 0.5)*0.1;\nconst vec3 spe_col = vec3(.8);\nconst float shin = 256.;\n\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd ) {\n    vec4 res = intersect_elliptope(ro,rd);\n    \n    if(res.x<0.) {\n        return bg_col;\n    }\n    \n    vec3 nor = res.yzw;\n    vec3 ref = reflect(rd, nor);\n    \n    float dif = max(0., dot(nor, -rd));\n    float spe = pow(max(0., dot(ref, -rd)), shin);\n    \n    vec3 pos = ro + rd*res.x;\n    \n    float pattern = checkersGradBox(pos.xz*5.);\n    if(nor.y < 0.) {\n        pattern = 1.-pattern;\n    }\n    vec3 dif_col_ = (0.5+0.5*pattern)*dif_col;\n    vec3 amb_col_ = (0.5+0.5*pattern)*amb_col;\n    \n    vec3 col = mix(amb_col_, dif_col_, dif) + spe*spe_col;\n        \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\n        \n        vec3 ro = vec3(3.,0.,0.);\n        \n        if(iMouse.z>0.) {\n            float phi = mo.x*PI*2.;\n            float psi = (0.5-mo.y)*PI;\n        \tro = ro.x*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n        }\n        else {\n            float alpha = time*PI*2.*.1;\n            float c = cos(alpha), s = sin(alpha);\n            \n            ro = vec3(c*ro.x+s*ro.z, ro.y, c*ro.z-s*ro.x);\n        }\n            \n        vec3 ta = vec3(0.);\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        vec3 rd = ca[2];\n        \n        ro += 2.*(ca[0]*p.x+ca[1]*p.y);\n        //rd += .7*(ca[0]*p.x+ca[1]*p.y);\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}