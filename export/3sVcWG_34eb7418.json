{"ver":"0.1","info":{"id":"3sVcWG","date":"1603644939","viewed":338,"name":"Depths Of Doom","username":"kesson","description":"Depths of Doom\n\nMade while following Antoine Zanuttini live stream 24 on Youtube\nhttps://www.youtube.com/watch?v=h6euxpg8Q_s&list=WL&index=24&t=4391s","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","tunnel","rays","marching","generative","bloom","depth","lights","walking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* --- DEPTHS OF DOOM --- */\n\n// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n// Highly based on Antoine Zanuttini lise stream 24\n// https://www.youtube.com/watch?v=h6euxpg8Q_s&list=WL&index=24&t=4391s\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415\n\n#define RAYMARCH_MAX_STEPS \t\t100\n#define RAYMARCH_MAX_DIST \t\t200.0\n#define RAYMARCH_SURFACE_DIST \t0.01\n\n#define time mod(iTime, 200.0)\n\nvec3 lightPos = vec3(0.0, 0.0, 30.0);\nfloat light = 0.0;\nvec3 lightPos2 = vec3(0.0, 0.0, 30.0);\nfloat light2 = 0.0;\nfloat cameraMovement = 0.0;\nvec3 ro = vec3(0.0, 0.0, -10.0);\n\nfloat beamsShine = 0.0;\nfloat tmpo = 0.0;\n\n// This creates repetitions of something along the way\nvec3 repeat(vec3 p, vec3 s) {\n\treturn (fract(p/s - 0.5) - 0.5) * s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n\treturn (fract(p/s - 0.5) - 0.5) * s;\n}\n\nfloat repeat(float p, float s) {\n\treturn (fract(p/s - 0.5) - 0.5) * s;\n}\n\n// Rotation function\nmat2 rotate(float a) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdCylinder(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat smin(float a, float b, float h) {\n\tfloat k = clamp((a-b) / h * 0.5 + 0.5, 0.0, 1.0);\n\treturn mix(a, b, k) - k * (1.0 - k) * h;\n}\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0.0);\n  \tfloat dd = p.z * 0.02;\n\tdd = floor(dd*0.3) + smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, fract(dd*0.3)));\n\tdd *= 0.5;\n  \toff.x += sin(dd) * 60.0;\n  \toff.y = sin(dd * 0.7) * 60.0;\n  \treturn off;\n}\n\nfloat part1(vec3 p2) {\n\n\tp2.xy *= rotate(time*0.251);\n\n    float cylDist = -sdCylinder(p2.xy, 20.0);\n\n    float d = cylDist;\n\n    vec3 p3 = repeat(p2, vec3(2.0));\n\t\tfloat db = d;\n\n    float sphereDist = sdSphere(p3, 1.1);\n\n    d = max(d, -sphereDist);\n\td = min(d, db+1.0);\n\n    vec3 p5 = p2;\n\tp2.xy *= rotate(-time*0.5);\n    p5.x = atan(p2.y, p2.x) * 40.0 / PI;\n\t\tp5.x -= p2.z*0.5;\n    p5.y = length(p2.xy) - 10.0;\n    p5.xz = repeat(p5.xz, vec2(5.5));\n    d = min(d, sdBox(p5, vec3(1.0)));\n\n\n    return d;\n}\n\nfloat part2(vec3 p) {\n\n\tvec3 p2 = p;\n\n\tfloat d = -sdCylinder(p.xy, 30.0);\n\tfloat d1 = d;\n\n\tfor (float i = 0.0; i < 4.0; i++) {\n\n\t\tp.xy *= rotate(0.7 + time * 0.0015);\n\t\tp.zy *= rotate(0.9 - time * 0.00125);\n\n\t\tvec3 p3 = p;\n\n\t\tp3 = repeat(p3, vec3(12.0));\n\n\t\tfloat f = sdSphere(p3, i+10.0);\n\n\t\td = smin(d, f, 5.0);\n\n\t}\n\n\td = smin(d, d1-5.0, -20.0);\n\n\t// Tentacles\n\tvec3 p4 = p2;\n\tp4.xy *= rotate(p4.z * 0.05);\n\tp4.z = repeat(p4.z, 25.0);\n\tp4.x += sin(p4.y*0.1 + p2.z * 0.32 + cameraMovement*0.01 + distance(p4, ro)*0.05) * 8.0;\n\tfloat beams = sdCylinder(p4.xz, 1.0 + sin(p4.z + iTime) * 0.5 + 0.5);\n\ttmpo = beams;\n\td = smin(d, beams, 5.0);\n\n\td1 *= 0.7;\n\n\treturn d*0.25;\n\n}\n\nfloat getDist(vec3 p) {\n\n\tp += tunnel(p);\n\n\tfloat d1 = part1(p);\n\tfloat d2 = part2(p);\n\n\tvec3 p2 = p;\n\tp2.z = repeat(p2.z, 100.0);\n\tfloat mi = sdBox(p2, vec3(100.0, 100.0, 34.0));\n\n\td1 = max(d1, -mi);\n\td1 = min(d1, max(d2, mi));\n\n\t// Little cylinder at the entrance of each \"small tunnel\"\n\tfloat cc = abs(sdCylinder(p.xy, 11.0)) - 2.0;\n\tcc = max(cc, abs(mi) - 1.0);\n\td1 = min(d1, cc);\n\n\t// Light bulb 1\n\tfloat dl = length(lightPos - p) - 0.5;\n\tlight += 0.2/(0.2+dl);\n\td1 = min(d1, dl);\n\n\t// Light bulb 2\n\tfloat dl2 = length(lightPos2 - p) - 0.5;\n\tlight2 += 0.2/(0.2+dl2);\n\td1 = min(d1, dl2);\n\n\t// Beams, temp solution for artefacts\n\ttmpo = max(tmpo, mi);\n\tbeamsShine += 0.2 / (0.2 + tmpo);\n\n\treturn d1;\n\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = RAYMARCH_SURFACE_DIST;\n\n    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {\n\t\t\tvec3 p = ro + rd * dO;\n      float dS = getDist(p);\n      dO += dS;\n      if (dO > RAYMARCH_MAX_DIST || dS < RAYMARCH_SURFACE_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(0.01, 0.0);\n\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n\n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    // vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float dif = dot(n, l);\n\n    return dif;\n}\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rgb, // original color of the pixel\n              in vec3 fogColor, in float distance,\n              in float b) // camera to point distance\n{\n  float fogAmount = 1.0 - exp(-distance * b);\n  // vec3  fogColor  = vec3(0.5,0.6,0.7);\n  return mix(rgb, fogColor, fogAmount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n\n    //\n\n    // Camera\n\n    cameraMovement = time * 10.0;\n\n    ro.z += cameraMovement;\n    ro -= tunnel(ro);\n\n\tfloat lightRotation = time * 2.0;\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    ta.z += cameraMovement;\n    ta -= tunnel(ta);\n\n\tlightPos.x = sin(lightRotation) * 6.0;\n\tlightPos.y = cos(lightRotation) * 6.0;\n\tlightPos.z += cameraMovement - (sin(time) * 0.5 + 0.5) * 20.0;\n\tlightPos2.x = cos(lightRotation) * 6.0;\n\tlightPos2.y = sin(lightRotation) * 6.0;\n\tlightPos2.z += cameraMovement - (cos(time) * 0.5 + 0.5) * 20.0;;\n\n  \tvec3 ww = normalize(ta - ro);\n  \tvec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  \tvec3 vv = normalize(cross(uu, ww));\n\n    float fov = 1.0;\n  \tvec3 rd = normalize(uv.x * uu + uv.y * vv + ww * fov);\n\n    float d = rayMarch(ro, rd);\n\n    vec3 p = ro + rd * d;\n\n    float dif = clamp(getLight(p, lightPos), 0.0, 1.0);\n\n    col = vec3(dif);\n\n\tcol = applyFog(col, vec3(0.0), smoothstep(0.0, 10.0, d), 50.0);\n\tvec3 lightAmount = light * vec3(0.83, 0.1, 1.0);\n\tcol += lightAmount*0.1;// * volume * 5.0;\n\n\tvec3 lightAmount2 = light2 * vec3(0.1, 1.0, 0.62);\n\tcol += lightAmount2*0.1;// * volume * 3.0;\n\n\tfloat beamsAmount = 0.25;//volume * 5.0;//0.05 * volume;\n\tcol += beamsShine * beamsAmount * vec3(0.1, 0.5, 0.5);\n\n\tcol = 1.0 - exp(-col * 2.0);\n\tcol = pow(col, vec3(1.8));\n   \tcol *= 0.5 + vec3(smoothstep(100.0, 50.0, d))*0.5;\n\n    fragColor = vec4(col,smoothstep(40.0, 80.0, d));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//  Blur  effect\n//  Edited  from  https://www.shadertoy.com/view/XdfGDH\n\nfloat  normpdf(in float  x,  in float  sigma)  {\n    return  0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2  uv = fragCoord / iResolution.xy;\n    \n    vec3  c = texture(iChannel0, uv).rgb;\n    \n    vec2  center = vec2(0.5, 0.5);\n    center = vec2(0.5, 0.5);\n\n    float  d = smoothstep(0.3, 1.0, 0.1 + distance(center, uv));\n\n    //  grain  effect\n    float  strength = 4.0;\n    float  x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime * 10.0);\n    vec3  grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n\n    const int  mSize = 11;\n    const int  kSize = (mSize - 1) / 2;\n    float  kernel[mSize];\n    vec3  final_colour = vec3(0.0);\n\n    //create  the  1-D  kernel\n    float  sigma = 0.001 + texture(iChannel0, uv).w * 4.0;//7.0;\n    float  Z = 0.0;\n    for (int  j = 0; j <= kSize; ++j) {\n        kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n    }\n\n    //get  the  normalization  factor  (as  the  gaussian  has  been  clamped)\n    for (int  j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read  out  the  texels\n    for (int  i = -kSize; i <= kSize; ++i) {\n        for(int  j = -kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize + j] * kernel[kSize + i] * texture(iChannel0, (gl_FragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n                }\n    }\n\n    vec3  c_step_1 = final_colour / (Z * Z);\n\n    float  nd = 1.0 - d;\n    vec3 c_step_2 = clamp(c_step_1 * nd, 0.0, 1.0);\n\n    // I don't like the image too clean\n    c_step_2 += grain * 3.0;\n\n    fragColor = vec4(c_step_2, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}