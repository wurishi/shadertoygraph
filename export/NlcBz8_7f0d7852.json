{"ver":"0.1","info":{"id":"NlcBz8","date":"1662594266","viewed":134,"name":"Interactive Julia RGB","username":"berelium","description":"This is my first shader on here. Some of the implementation might be crude, so please excuse that, lol. You can move the mouse on the X and Y axis to move the C value for the set.\n\n(Edit): Made an attempt at layering a normal map on top\n(Edit 2): Added AA","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mouse","mandelbrot","interactive","normalmap","antialiasing","complex","smooth","normalization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1) You can toggle the normal map by simply commenting the define line below.\n// 2) Anti-Aliasing can be disabled by setting the value to 1, for anything above 2\n//    a relatively beefy GPU is required.\n// 3) Playing with the iterations will yield different results in the fractals\n//    resolution. This will also directly effect your framerate.\n// 4) The factor at which the screen is zoomed. Negative values will yield an inverted\n//    Julia set, as 0 is max zoom. Raising this float will cause the scene to zoom out.\n\n#define APPLY_NORMAL_MAP\n#define AA 2\n\nfloat ITERATIONS = 150.0;\nfloat zoomFactor = 3.1;\n\n// Lerp between two floating points, with a given factor\nfloat lerp(float a, float b, float t) {\n\treturn a + (b - a) * t;\n}\n\n// Multiply two complex numbers\nvec2 multiplyComplex(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// Calculate the julia set\nfloat juliaSet(vec2 p, vec2 c) {\n\tvec2 testP = p;\n\tfor(float i = 0.0; i < ITERATIONS; i++) {\n\t\ttestP = multiplyComplex(testP, testP) + c;\n\t\tfloat nDot = dot(testP, testP);\n\t\tif(nDot > 45678.0) {\n\t\t\t// Smooth iteration count borrowed from Inigo Quilez\n\t\t\tfloat sl = i - log2(log2(nDot)) + 4.0;\n\t\t\treturn sl / ITERATIONS;\n\t\t}\n\t}\n\treturn 0.0;\n}\n\n// Calculate the normal of julia set\nfloat juliaSetNormal(vec2 p, vec2 c) {\n\tvec2 testP = p;\n\tfor(float i = 0.0; i < ITERATIONS; i++) {\n\t\ttestP = multiplyComplex(testP, testP) + c;\n\t\tfloat nDot = dot(testP, testP);\n\t\tif(nDot > 45678.0) {\n\t\t\tvec3 o = vec3(1. / iResolution.x, 0., 1. / iResolution.y);\n\t\t\tvec3 n = vec3(juliaSet(p + o.xy, c) - juliaSet(p - o.zy, c),\n\t\t\t\t\t\t  juliaSet(p + o.yx, c) - juliaSet(p - o.yz, c),\n\t\t\t\t\t\t  1.0);\n\t\t\treturn 0.5 + 0.5 * atan(n.y, n.x) / 3.141592;\n\t\t}\n\t}\n\treturn 0.0;\n}\n\n\n// Map iter count to color\nvec3 colorMap(float ci, vec3 cFilter) {\n\treturn vec3(0.5 + 0.5*cos(2.7+ci*30.0 + cFilter));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup screen space\n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 fragment = fragCoord.xy / iResolution.xy - vec2(0.5);\n    vec2 uv = zoomFactor * aspect * fragment;\n\n    vec3 Julia = vec3(0.0);\n\n\t// Map julia set, using mouse as C position\n\tvec2 mouse = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n\tfloat currIter = juliaSet(uv, mouse);\n\tfloat normIter = juliaSetNormal(uv, mouse);\n\n\t// Set initial color filter\n\tvec3 colorFilter = vec3(1.0);\n\n\n\t// Apply anti-aliasing\n\t#if AA>1\n\t\tbool normAppliedOnce = false;\n\n\t\tfloat _AA = float(AA);\n\t\tvec2 aa = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n\t\tvec2 aaOffset = vec2(0.0, 0.0);\n\t\tfor(int i = 0; i < AA; i++) {\n\t\t\tfor(int j = 0; j < AA; j++) {\n\t\t\t\tfloat _i = float(i), _j = float(j);\n\t\t\t\taaOffset.x = (_i + 0.5) / _AA;\n\t\t\t\taaOffset.y = (_j + 0.5) / _AA;\n\n\t\t\t\tvec2 aaUV = uv + aa * aaOffset;\n\t\t\t\tfloat aaIter = juliaSet(aaUV, mouse);\n\n\t\t\t\tJulia += colorMap(aaIter, colorFilter);\n\n\t\t\t\t// Apply normal map\n\t\t\t\t#ifdef APPLY_NORMAL_MAP\n\t\t\t\t\tif(!normAppliedOnce) {\n\t\t\t\t\t\tfloat aaNorm = juliaSetNormal(aaUV, mouse);\n\n\t\t\t\t\t\taaIter = lerp(aaIter, aaNorm, 0.5);\n\t\t\t\t\t\tJulia = mix(Julia, colorMap(aaNorm, colorFilter), aaIter);\n\n\t\t\t\t\t\tnormAppliedOnce = true;\n\t\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\tJulia /= _AA * _AA;\n\t\tJulia = pow(Julia, vec3(2.5));\n\t#else\n\t\tJulia += colorMap(currIter, colorFilter);\n\t\tJulia = pow(Julia, vec3(2.5));\n\n\t\t#ifdef APPLY_NORMAL_MAP\n\t\t\tJulia = mix(Julia, vec3(normIter), 0.925);\n\t\t#endif\n\t#endif\n\t\n\n\t// Apply shifting rgb color filter\n\tfloat rgbSpeed = 0.5;\n\tvec3 rgbColor = vec3(0,3,5);\n\tvec3 rgb = 0.5 + 0.5*cos(iTime*rgbSpeed+uv.xyx+rgbColor);\n\t\t\n\tvec3 colorOut = mix(Julia, rgb, 0.05);\n\tcolorOut *= rgb;\n\n\t// Apply bloom to image\n\tvec3 bloomColor = colorMap(currIter, colorFilter);\n\tvec3 bloom = vec3(0.05);\n\tfloat bloomFactor = .55;\n\tfloat bloomStrength = 0.65;\n\n\tbloom += bloomColor;\n\tbloom = mix(vec3(0.0), bloom, bloomFactor);\n\tbloom *= bloomStrength;\n\tcolorOut += bloom;\n\n\t// Apply gamma correction\n\tcolorOut = pow(colorOut, vec3(1.5/2.2));\n\n    // Out to screen\n    fragColor = vec4(colorOut, 1.0);\n}","name":"Image","description":"","type":"image"}]}