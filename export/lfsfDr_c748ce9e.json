{"ver":"0.1","info":{"id":"lfsfDr","date":"1723646208","viewed":45,"name":"wip: The Little female Mole","username":"ArthurTent","description":"little mole Krtek, Krteček\nI'm new to shader programming: sorry for ugly code, but kinda proud of the result :)\nTIL: The difference between feet and breasts is sometimes just small dots in the right place.\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["littlemolekrtekkrteekmaulwurff"],"hasliked":0,"parentid":"lflBDn","parentname":"test-little-mole03"},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n#define S3(d,b) smoothstep(1.0/antialiasing(0.5),0. , d - (b) )\n\nfloat Sdf_I(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Sdf_U(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Sdf_D(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S3( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S3(abs( distObj)-0.005,0.0));\n  return colOut;\n}\nfloat audio = 0.;\n// Common\n\n//iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\nvec3 gradientBackground(vec2 p) {\n    float y = p.y*2.;\n    vec3 gardenGreen = vec3(0.0, 0.5, 0.0); // Green color for the garden\n    vec3 skyBlue = vec3(0.5, 0.7, 1.0); // Blue color for the sky\n\n    return mix(gardenGreen, skyBlue, smoothstep(0.0, 1.0, y));\n}\n\n\n// Parameters for arms\nvec2 leftArmCenter = vec2(0.25, 0.25); // Center position of the left arm\nvec2 rightArmCenter = vec2(0.75, 0.25); // Center position of the right arm\nfloat armWidth = 0.1;                   // Width of the arms\nfloat armHeight = 0.5;                  // Height of the arms\n\n\n// Define colors\nvec3 backgroundColor = vec3(0.8, 0.9, 1.0);  // Light blue background\nvec3 bodyColor = vec3(0.0, 0.0, 0.0);        // Black body\nvec3 bellyColor = vec3(0.000,0.000,0.000);       // Dark gray belly\nvec3 faceColor = vec3(0.000,0.000,0.000);        // White face\nvec3 noseColor = vec3(0.8, 0.1, 0.1);        // Red nose\nvec3 eyeColor = vec3(1.0, 1.0, 1.0);         // White eyes\nvec3 pupilColor = vec3(0.0, 0.0, 0.0);       // Black pupils\nvec3 outlineColor = vec3(0.0, 0.0, 0.0);     // Black outline\nvec3 skinColor = vec3(1.,0.667,0.561);\n\n// Parameters for position and size\nvec2 bodyCenter = vec2(0.5, 0.3);  // Adjusted center for body\nfloat bodyWidth = 0.5;             // Increased width for body\nfloat bodyHeight = 1.0;            // Increased height for body\n\nvec2 bellyCenter = vec2(0.5, 0.15);\nfloat bellyRadius = 0.3;           // Adjusted size of belly\n\nvec2 faceCenter = vec2(0.5, 0.55);  // Adjusted position for the face\nfloat faceRadius = 0.25;           // Adjusted size of the face\n\nvec2 nosePosition = vec2(0.5, 0.6); // Moved nose down to align with the face\nfloat noseSize = 0.05;\n\nvec2 leftEyePosition = vec2(0.42, 0.65); // Adjusted left eye position\nvec2 rightEyePosition = vec2(0.58, 0.65); // Adjusted right eye position\nfloat eyeSize = 0.08;               // Slightly reduced eye size\nfloat pupilSize = 0.03;\n\n// Hair parameters\nfloat hairThickness = 0.015;\nvec2 hairStart1 = vec2(0.45, 0.8);\nvec2 hairEnd1 = vec2(0.42, 0.99);\nvec2 hairStart2 = vec2(0.5, 0.8);\nvec2 hairEnd2 = vec2(0.5, 0.99);\nvec2 hairStart3 = vec2(0.55, 0.8);\nvec2 hairEnd3 = vec2(0.58, 0.99);\n\n// Outline thickness\nfloat outlineThickness = 0.01;\n\nfloat random(vec2 st) {\n    // Dot product to create variation based on input\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat sdEllipseBoobs( in vec2 p, in vec2 ab )\n{\n    // Transform coordinates\n    p = abs(p); \n    if( p.x > p.y ) { p = p.yx; ab = ab.yx; }\n    \n    // Compute ellipse implicit function\n    float l = ab.y * ab.y - ab.x * ab.x;\n    float m = ab.x * p.x / l;\n    float m2 = m * m; \n    float n = ab.y * p.y / l;\n    float n2 = n * n; \n    float c = (m2 + n2 - 1.0) / 3.0;\n    float c3 = c * c * c;\n    float q = c3 + m2 * n2 * 2.0;\n    float d = c3 + m2 * n2;\n    float g = m + m * n2;\n    float co;\n\n    if( d < 0.0 )\n    {\n        float h = acos(q / c3) / 3.0;\n        float s = cos(h);\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt(-c * (s + t + 2.0) + m2);\n        float ry = sqrt(-c * (s - t + 2.0) + m2);\n        co = (ry + sign(l) * rx + abs(g) / (rx * ry) - m) / 2.0;\n    }\n    else\n    {\n        float h = 2.0 * m * n * sqrt(d);\n        float s = sign(q + h) * pow(abs(q + h), 1.0 / 3.0);\n        float u = sign(q - h) * pow(abs(q - h), 1.0 / 3.0);\n        float rx = -s - u - c * 4.0 + 2.0 * m2;\n        float ry = (s - u) * sqrt(3.0);\n        float rm = sqrt(rx * rx + ry * ry);\n        co = (ry / sqrt(rm - rx) + 2.0 * g / rm - m) / 2.0;\n    }\n    \n    vec2 r = ab * vec2(co, sqrt(1.0 - co * co));\n    \n    // Compute distance to the ellipse and return only one half\n    float dist = length(r - p) * sign(p.y - r.y);\n\n    // Return distance only if p.x is in the positive half (right side)\n    return (p.y>=0.01) ? dist : 1.0; // 1.0 is an arbitrary large value to indicate the point is outside\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdRect(in vec2 p, in vec2 sz)\n{\n    vec2 d = abs(p) - sz;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nvec3 mole_feet(vec2 p, vec3 colout)\n{\n    //todo: cut \n    vec2 A, med;\n    float dfin;\n    p.x*=1.5;\n    p.y*=1.5;\n    p.x-=.25;\n    p.y+=.051;\n    \n    A=vec2(0.368,-0.125);\n    med=vec2(0.14021,0.069);\n    float d1=sdEllipse(p-A,med);\n    \n    A=vec2(0.65098,-0.125);\n    med=vec2(0.14021,0.069);\n    float d2=sdEllipse(p-A,med);\n    \n    dfin=d1;\n    dfin=Sdf_U(dfin,d2);\n    \n    vec3 colc=skinColor;\n    colout= DFB(colc, colout, dfin);\n    \n    return colout;\n}\n\nvec3 mole_boobs(vec2 p, vec3 colout)\n{\n    //todo: cut \n    vec2 A, med;\n    float dfin;\n    p.x*=1.8;\n    p.y*=1.5;\n    p.x-=.4;\n    p.y+=.051;\n    \n    A=vec2(0.368,-0.125);\n    med=vec2(0.14021,0.069);\n    float d1=sdEllipseBoobs(p-A,med);\n    \n    A=vec2(0.65098,-0.125);\n    med=vec2(0.14021,0.069);\n    float d2=sdEllipseBoobs(p-A,med);\n    \n    dfin=d1;\n    dfin=Sdf_U(dfin,d2);\n    \n    vec3 colc=skinColor;\n    colout= DFB(colc, colout, dfin);\n    \n    return colout;\n}\n\n// Function to draw a cloud using a simple noise function\nfloat cloud(vec2 p) {\n    p.x+=iTime/10.;\n    if(p.y>.75){\n        // Simplex or Perlin noise could be used for better clouds\n        //float noise = sin(p.x * 10.0) * cos(p.y * 10.0);\n        float noise = sin(p.x*10.+random(p)*audio)*cos(p.y*10.);\n        return smoothstep(0.4, 0.5, noise);\n    }\n    else {\n        return 0.;\n    }\n}\n\n// Function to draw the sun\nfloat sun(vec2 p, vec2 center, float radius) {\n    //p *=0.04;\n    //float dist = length(p - center);\n    p.y+=.345;\n    //return smoothstep(radius, radius - 0.05, dist);\n     if(p.y>1.15 && p.x>=1.5){\n        // Simplex or Perlin noise could be used for better clouds\n        float noise = sin(p.x * 4.0) * cos(p.y * 4.0);\n        float result = smoothstep(0.4, 0.5, noise);\n        result *=200.;\n        return result;\n    }\n    else {\n        return 0.;\n    }\n}\n\nvec3 mouth(vec2 uv, vec3 col)\n{\n\nuv.x*=2.;\nuv.y*=2.;\nuv.x-=.25;\nuv.y-=.28;\nvec2 pc1p1=vec2(.65-audio/15.,.434);\nvec2 pc1p2=vec2(.820,.2*(1.+audio));\nvec2 pc1p3=vec2(.85+audio/15.,.434);\n\n\nfloat d1= sdBezier(uv,pc1p1,pc1p2,pc1p3);\n\nvec3 C1=vec3(0.0);\ncol=DFB(C1,col,d1);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    audio = texture(iChannel0,vec2(sin(iTime),0.)).r/2.;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv.x += 0.5;\n    uv.y += 0.5;\n\n\n    // Draw background gradient\n    vec3 backgroundColor = gradientBackground(uv);\n    \n    // Draw the sun\n    vec2 sunPos = vec2(iResolution.x/4., iResolution.y/4.  );//* sin(iTime)); // Sun moves vertically\n    float sunRadius = 0.5 * iResolution.y;\n    float sunColor = sun(uv, sunPos, sunRadius);\n\n    // Blend sun color over background\n    backgroundColor = mix(backgroundColor, vec3(1.0, 1.0, 0.0), sunColor);\n\n    // Draw clouds\n    float cloudDensity = cloud(uv);\n    vec3 cloudColor = vec3(1.0); // White color for clouds\n    backgroundColor = mix(backgroundColor, cloudColor, cloudDensity);\n    \n\n    \n\n    // Start with the background color\n    vec3 color = backgroundColor;\n\n    // Draw the body with outline\n    vec2 uvBody = (uv - bodyCenter) / vec2(bodyWidth, bodyHeight);\n    uvBody.y *= 1.34;\n    float distBody = length(uvBody);\n    if (distBody < 0.5) {\n        color = bodyColor;\n    } else if (distBody < 0.5 + outlineThickness) {\n        color = outlineColor;\n    }\n    // Draw the face with outline\n    float distFace = distance(uv, faceCenter);\n    if (distFace < faceRadius) {\n        color = faceColor;\n    } else if (distFace < faceRadius + outlineThickness) {\n        color = outlineColor;\n    }\n    // Draw the belly with outline\n    float distBelly = distance(uv, bellyCenter);\n    if (distBelly < bellyRadius) {\n        color = bellyColor;\n    } else if (distBelly < bellyRadius + outlineThickness) {\n        color = outlineColor;\n    }\n    uv.y-=.0515;\n    distBelly = distance(uv, bellyCenter);\n    distBelly=distBelly*1.8;\n    if (distBelly < bellyRadius) {\n        color=vec3(0.5,0.5,0.5);\n    } else if (distBelly < bellyRadius + outlineThickness) {\n        color = outlineColor;\n    }\n    uv.y+=.0515;\n    \n    \n    uv.y-=.2;\n    distBelly = distance(uv, bellyCenter);\n    distBelly=distBelly*2.6;\n    if (distBelly < bellyRadius) {\n        color=vec3(0.5,0.5,0.5);\n    } else if (distBelly < bellyRadius + outlineThickness) {\n        //color = outlineColor;\n    }\n    uv.y+=.2;\n    \n    // draw the mouth\n    uv.y-=.0513;\n    vec2 uvMouth = (uv - bodyCenter) / vec2(bodyWidth, bodyHeight);\n    uvMouth.y *= 10.34;//+(audio*5.);\n    uvMouth.x *=10.;//+(audio*5.);\n    uvMouth.y-=0.9;\n    uvMouth*=(1.5+audio*2.6);\n    float distMouth = length(uvMouth);\n    if (distMouth < 0.5) {\n        color = bodyColor;\n    } else if (distMouth < 0.5 + outlineThickness) {\n        color = outlineColor;\n        //color = vec3(1.,0.,0.);\n    }\n    color = mouth(uv, color);\n     uv.y+=.0513;\n    \n    uv.y-=.405;\n    color = mole_boobs(uv, color);\n    uv.y+=.405;\n    \n\n    // Draw the nose with outline\n    float distNose = distance(uv, nosePosition);\n    if (distNose < noseSize) {\n        color = noseColor;\n    } else if (distNose < noseSize + outlineThickness) {\n        color = outlineColor;\n    }\n\n    // Draw the eyes with outline\n    float distLeftEye = distance(uv, leftEyePosition);\n    float distRightEye = distance(uv, rightEyePosition);\n    if (distLeftEye < eyeSize) {\n        color = eyeColor;\n    } else if (distLeftEye < eyeSize + outlineThickness) {\n        //color = outlineColor;\n    }\n    if (distRightEye < eyeSize) {\n        color = eyeColor;\n    } else if (distRightEye < eyeSize + outlineThickness) {\n        //color = outlineColor;\n    }\n    \n    uv.y+=0.05*(.35+sin(iTime/2.));\n    distLeftEye= distance(uv, leftEyePosition);\n    distRightEye = distance(uv, rightEyePosition);\n    uv.y-=0.05*(.35+sin(iTime/2.));\n    // Draw the pupils (no outline for pupils)\n    if (distLeftEye < pupilSize) {\n        color = pupilColor;\n    }\n    if (distRightEye < pupilSize) {\n        color = pupilColor;\n    }\n\n    // Draw the hairs\n    float distHair1 = abs(cross(vec3(hairEnd1 - hairStart1, 0.0), vec3(uv - hairStart1, 0.0)).z / length(hairEnd1 - hairStart1));\n    if (distHair1 < hairThickness && uv.y > hairStart1.y && uv.y < hairEnd1.y) {\n        color = outlineColor;\n    }\n\n    float distHair2 = abs(cross(vec3(hairEnd2 - hairStart2, 0.0), vec3(uv - hairStart2, 0.0)).z / length(hairEnd2 - hairStart2));\n    if (distHair2 < hairThickness && uv.y > hairStart2.y && uv.y < hairEnd2.y) {\n        color = outlineColor;\n    }\n\n    float distHair3 = abs(cross(vec3(hairEnd3 - hairStart3, 0.0), vec3(uv - hairStart3, 0.0)).z / length(hairEnd3 - hairStart3));\n    if (distHair3 < hairThickness && uv.y > hairStart3.y && uv.y < hairEnd3.y) {\n        color = outlineColor;\n    }\n\n    // Draw the arms with outline\n    float angle = 20.0 * 3.14159265 / 180.0;\n    // Compute the rotation matrix components\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    // Rotate UV coordinates\n    vec2 uv2 = uv; // Translate UV \n    uv2.y-=.185;\n    uv2.x+=.051;\n    vec2 rotatedUV_LeftArm,rotatedUV_RightArm;\n    rotatedUV_LeftArm.x = uv2.x * cosTheta - uv2.y * sinTheta;\n    rotatedUV_LeftArm.y = uv2.x * sinTheta + uv2.y * cosTheta;\n    //rotatedUV += center; // Translate UV back\n    \n    uv2 = uv; // Translate UV \n    uv2.y-=.33;\n    uv2.x-=1.51;\n    rotatedUV_RightArm.x = uv2.x * -cosTheta - uv2.y * sinTheta;\n    rotatedUV_RightArm.y = uv2.x * -sinTheta + uv2.y * cosTheta;\n    \n    vec2 uvLeftArm = (rotatedUV_LeftArm - leftArmCenter) / vec2(armWidth, armHeight);\n    vec2 uvRightArm = (rotatedUV_RightArm - rightArmCenter) / vec2(armWidth, armHeight);\n    uvLeftArm.y *= 1.34;\n    uvRightArm.y *= 1.34;\n    float distLeftArm = length(uvLeftArm);\n    float distRightArm = length(uvRightArm);\n\n    if (distLeftArm < 0.5) {\n        color = bodyColor;\n    } else if (distLeftArm < 0.5 + outlineThickness) {\n        color = outlineColor;\n        color = vec3(0.5, 0.5, 0.5);\n    }\n\n    if (distRightArm < 0.5) {\n        color = bodyColor;\n    } else if (distRightArm < 0.5 + outlineThickness) {\n        color = outlineColor;\n        color = vec3(0.5, 0.5, 0.5);\n    }\n\n    color = mole_feet(uv, color);\n\n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}