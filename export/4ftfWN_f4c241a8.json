{"ver":"0.1","info":{"id":"4ftfWN","date":"1733175247","viewed":33,"name":"Demo Daky-CPSC591","username":"PGN9","description":"Class Final Project\n- Buffer A: main rendering work \n- Buffer B: keyboard input handler\n- KEY_UP = move camera forward\n- KET_DOWN = move camera backward\n","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["beginner","toonshader"],"hasliked":0,"parentid":"XcKczD","parentname":"Daky-CPSC591 ZoomI/O"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from CPSC591 PA2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 r = texture(iChannel0, uv);\n    \n    // gamma\n    #ifdef XTOON_ON\n        fragColor = r;\n        return;\n    #endif\n    r = clamp(r,0.0,1.0);\n\tr = vec4( pow( r , vec4(1.0/2.2)));    \n    \n    fragColor =  r;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BufferB iChannel0\n#define TEAPOT_TEXTURE iChannel1\n#define FLOOR_TEXTURE iChannel2\n#define BUBBLE_TEXTURE iChannel3\n// Note: choose wrap=clamp for all textures\n\n// ======================================================================\n// Camera Movement\n// reference: CPSC591 PA-1 \nmat3 rot3xy( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n\n    return mat3(\n        c.y, 0.0, -s.y,\n        s.y * s.x, c.x, c.y * s.x,\n        s.y * c.x, -s.x, c.y * c.x\n    );\n}\n// reference: CPSC591 PA-3\nvec3 rotateWithMouse(vec3 v)\n// Rotate a 3D vector 'v' around the y and z axes based on mouse coordinates\n{\n    // Convert mouse coordinates to normalized screen coordinates and scale by 2.0\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m *= 2.0;\n    // Create a 4D vector 't' with sine values based on 'r' and a constant value (half pi)\n    vec4 t = sin( vec4( m, m + HALF_PI ) );\n    // Calculate the dot product between the 'v.yz' components and 't.yw'\n    float g = dot( v.yz, t.yw );\n    // Return a new 3D vector after applying rotation transformations\n    return vec3( v.x * t.z - g   * t.x,\n                 v.y * t.w - v.z * t.y,\n                 v.x * t.x + g   * t.z );\n}\n\n// Camera offset due to keyboard input\nvec3 getCamOffset() {\n    return vec3(0.0, 0.0, -texelFetch(BufferB, ivec2(1, 0), 0).r);\n}\n\n\n// ======================================================================\n// Nomal Visualization (for testing normal)\nvec3 getNormalColor(vec3 n){\n    return vec3((n+1.0)*0.5);\n}\n\n\n// Returns depth of p wrt camera\nfloat getDepth(float d, vec3 p, vec3 focal_axis, vec3 cam_p){\n    #ifdef DEPTH_FROM_CAMERA\n        return d;\n    #endif\n    #ifdef DEPTH_ALONG_FOCAL_AXIS\n        // project p onto focal_axis\n        p = dot(p,focal_axis) * focal_axis;\n        d = distance(p, cam_p);\n        return d;\n    #endif\n    return d;\n}\n\n// Depth Visualization\nvec3 getDepthColor(float d, vec3 p, vec3 focal_axis, vec3 cam_position){\n    d = getDepth(d,p,focal_axis,cam_position);\n    return vec3((d-MIN_DIST) / (MAX_DIST-MIN_DIST));\n}\n\n\n// ======================================================================\n// X-toon: attribute based texture coordinate calculation\nvec2 getTextureCoord(float NdotL, float NdotV, float VdotR, float z) {\n    float D = 1.0;\n    #ifdef DEPTH_BASED_D\n        // depth-based mapping\n        D = 1.0-log(z/z_min)/log(z_r);\n    #endif\n    #ifdef ORIENT_BASED_D_R\n        D = pow(abs(NdotV), z_r);\n    #endif\n    #ifdef ORIENT_BASED_D_S\n        D = pow(abs(VdotR), z_s);\n    #endif\n    return vec2(NdotL, D);\n}\n\n// ======================================================================\n// Shadow\n/* raymarch from p into the direction of the light and if the dist we get out \nof it is smaller than the distance to the light than we know we hit something\nin between the light and that point. (i.e. the point is shadowed) \n*/\nbool isShadowed(vec3 p, Ray light, vec3 n){\n    Ray backwardRay = Ray(p, normalize(light.direction)); // note this direction points from p to light source\n    backwardRay.origin = p + n*0.003;\n    float d_light = ray_marching(backwardRay, 0.0, MAX_DIST);\n    if (d_light < distance(p, light.origin)) return true;\n    return false;\n}\n\n\n\n// ======================================================================\n// Highlight\n/* Implementation of squared highlight proposed in the paper:\n    \"Stylized highlights for cartoon rendering and animation\" by Ken-ichi Anjyo and Katsuaki Hiramitsu\n*/\nvec3 squareHighlight(vec3 H, vec3 du, vec3 dv)\n{\n    float Hdu = dot(H,du);\n    float Hdv = dot(H,dv);\n    \n    vec3 V = Hdu * du + Hdv * dv;\n    V = normalize(V);\n    \n    float Vdu = dot(V,du);\n    float Vdv = dot(V,dv);\n\n    float theta = min(acos(Vdu), acos(Vdv));\n    float sqrnorm = pow(sin(2.0 * theta), highlight_sharpness);\n    vec3 H_sqr = H - highlight_square_magnitude * sqrnorm * V;\n    return normalize(H_sqr);\n}\n\nvec3 scaleHighlight(vec3 H, vec3 d)\n{\n    float Hd = min(dot(H, d), EPSILON);\n    vec3 H_scl = H - highlight_scale * Hd * d;\n    return normalize(H_scl);\n}\n\n\nvec3 splitHighlight(vec3 H, vec3 d)\n{\n\n    float sgnHd = sgn(dot(H,d));\n    vec3 H_spl = H - highlight_split * sgnHd * d;\n    return normalize(H_spl);\n}\n\n\n// ======================================================================\nfloat getLuminance(vec3 color) {\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// -------------------------------------------------------------\n\n// returns the color at point p\nvec3 getColor(vec3 p, vec3 N, Ray cam, Ray light, float z)\n{\n    vec3 V = normalize(  cam.origin - p  ); ///pointing from the position to the eye \n    vec3 L = light.direction;\n\n    vec3 color = hitObjColor(p);\n    float NdotL = dot(N,L);\n    float NdotV = dot(N,V);\n\n    vec3 R = L - 2.0*NdotL*N;\n    float VdotR = dot(V,R);\n\n    #ifdef XTOON_ON\n        vec3 tex_col; // color get from the texture\n        #ifdef SHADOW_ON\n            if (isShadowed(p, light, N)) NdotL =0.0;\n        #endif\n        // apply corresponding texture\n        if (color == teapot_col) tex_col = texture(TEAPOT_TEXTURE, getTextureCoord(NdotL, NdotV, VdotR, z)).rgb;\n        else if (color == floor_col) tex_col = texture(FLOOR_TEXTURE, getTextureCoord(NdotL, NdotV, VdotR, z)).rgb;\n        else tex_col = texture(BUBBLE_TEXTURE, getTextureCoord(NdotL, NdotV, VdotR, z)).rgb;\n        \n        #ifdef MULTIPLY_XTOON\n            color += vec3(0.25); // make the color lighter (visually looks better)\n            color *= vec3(getLuminance(tex_col));\n        #else\n            color = tex_col;\n        #endif\n        \n    #else\n        // apply traditional toon shading\n        if (NdotL >= 0.8) {\n            color += vec3 (0.3, 0.1, 0.0);\n        } else if (NdotL <= 0.2) {\n            color -= vec3 (0.2, 0.3, 0.1);\n        }\n        // apple shadow\n        #ifdef SHADOW_ON\n            if (isShadowed(p, light, N)) color -= vec3(0.2, 0.2, 0.2);\n        #endif\n    #endif\n    \n\n    #ifdef HIGHLIGHT_ON\n        vec3 H = normalize(V + L); // inspected vector H\n        \n        #ifdef STYLIZE_HIGHLIGHT\n        // stylize highligh\n        vec3 du, dv;\n        createLocalFrame(N, du, dv);\n        \n        \n        H = scaleHighlight(H, dv); // scale in the dv direction\n        H = splitHighlight(H, dv); // also split in the dv direction\n        H = squareHighlight(H, du, dv);\n        \n        #endif\n        \n        if (dot(H, N) > 1.0-highlight_size) {\n            // then p is highlighted \n            color = highlight_col;\n        }\n        \n    #endif\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3( 0.0 );\n    \n    // =======================================================================================\n    // Camera Setup\n    float fov = 40.0;\n    vec3 camPosition = vec3(0.0, 0.0, 10.0);\n    vec3 camDirection = ray_dir(fov, iResolution.xy, fragCoord.xy);\n\n    // rotate camera\n    mat3 rot = rot3xy(vec2(-DEG_TO_RAD * 10.0, iTime * 0.5));\n    camPosition = rot * (camPosition + getCamOffset()); // camera offset due to keyboard input\n    camDirection = rot * camDirection;\n    \n    // rotate if mouse is clicked\n    if (iMouse.z > 0.0) {\n        camPosition = rotateWithMouse(camPosition);\n        camDirection = rotateWithMouse(camDirection);\n    }\n    \n    vec3 focal_point = vec3(0.0);\n    vec3 focal_axis = normalize(focal_point - camPosition); \n    // Initialize a ray for the camera\n    Ray cam = Ray(camPosition, camDirection);\n\n    // =======================================================================================\n    // Ray March\n    float edgeLength = MAX_DIST;\n    float depth = ray_marching(cam, 0.0, MAX_DIST, edgeLength);\n    \n    \n    // depth test\n    if (false) {\n        vec3 p = cam.origin + cam.direction * depth;\n        color = getDepthColor(depth, p, focal_axis, camPosition);\n        fragColor = vec4( color, 1.0 );\n        return;\n    }\n    \n    \n    if (depth >= MAX_DIST) {// no hit\n        fragColor = vec4(background_col, 1.0);\n        return;\n    }\n    \n    #ifdef LINEART_ON\n        if (depth < EPSILON) { // edeg hit\n            fragColor = vec4(edge_col, 1.0);\n            return;\n        }\n    #endif\n    \n    // hit some object in the scene\n    vec3 pos = cam.origin + cam.direction * depth;\n    vec3 n = getNormal(pos);\n    \n    // =======================================================================================\n    // Light Setup\n    vec3 lightPosition = vec3(8.0, 12.0, 2.0);\n    vec3 lightDirection = normalize(lightPosition - pos);\n    \n    // rotate light \n    rot = rot3xy(vec2(0.0, iTime * 0.5));\n    lightPosition = rot * lightPosition;\n    lightDirection = rot * lightDirection;\n    \n    Ray light = Ray(lightPosition, lightDirection);\n    \n    // =======================================================================================\n    // apply toon shading\n    color = getColor(pos, n, cam, light, getDepth(depth, pos, focal_axis, camPosition));\n    \n\n    fragColor = vec4( color, 1.0 );\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* KEYBOARD INPUT */\n\n// reference: https://www.shadertoy.com/view/ltsyRS\n\n// KEY_UP = move camera forward\n// KET_DOWN = move camera backward\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nconst float speed = 10.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float outData = 0.0;\n    \n\n        outData = texelFetch(iChannel0, ivec2(1, 0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n        \t\t(iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n    \n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\nCPSC 591 Final Project\nDaky Wang (30131194)\n\n// KEY_UP = move camera forward\n// KET_DOWN = move camera backward\n\nreferences: \nTeapot SDF Model: https://www.shadertoy.com/view/3lG3Dc\nCylinder SDF Model: https://iquilezles.org/articles/distfunctions/\nRay Marching & Camera Rotation: CPSC591 PA-1, PA-3\nEdge Detection: https://www.shadertoy.com/view/ll33Wn\nShadow Mapping: https://www.shadertoy.com/view/flX3Ds\nKeyboard Input: https://www.shadertoy.com/view/ltsyRS\nPascal Barla, Jo¨elle Thollot ARTIS GRAVIR/IMAG INRIA* Grenoble France Lee Markosian University of Michigan 2006 X-Toon: An Extended Toon Shader\n\"Stylized highlights for cartoon rendering and animation\" by Ken-ichi Anjyo and Katsuaki Hiramitsu\n*/\n\n// ======================================================================\n// Ray Marching Constants\nconst int MAX_STEP = 255;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 1000.0;\nconst float scale_factor = 0.75;\n\n// USER DEFINED ATTRIBUTES\n// ======================================================================\n// MODEL CONFIG\n// sphere position and radius (to show different depth)\n#define SPHERE_OFFSET_VALUE 8.0\nconst vec3 sphere_pos_1 = SPHERE_OFFSET_VALUE * vec3(0.866, -0.15, -0.5);\nconst vec3 sphere_pos_2 = SPHERE_OFFSET_VALUE * vec3(0.0, -0.15, 1.0);\nconst vec3 sphere_pos_3 = SPHERE_OFFSET_VALUE * vec3(-0.866, -0.15, -0.5);\nconst float sphere_r = 1.0;\n// radius of floor (cylinder)\nconst float floor_radius = 5.0;\n\n// OUTPUT CONFIG\n// SWITCHES (COMMENT = TURN OFF)\n#define LINEART_ON\n#define SHADOW_ON\n#define HIGHLIGHT_ON\n#define STYLIZE_HIGHLIGHT\n\n// EDGE (LINEART)\nconst vec3 edge_col = vec3(0.1, 0.1, 0.3);\nconst float edge_thickness = 0.03;\n// DEFAULT COLORS\nconst vec3 background_col = vec3(0.5, 0.8, 1.0);\nconst vec3 teapot_col = vec3(0.7, 0.7, 0.75);\nconst vec3 floor_col = vec3(0.35, 1.0, 0.5);\nconst vec3 bubble_col = vec3(1.0, 0.7, 0.8);\n// HIGHLIGHT\nconst vec3 highlight_col = vec3(1.0, 1.0, 1.0);\nconst float highlight_size = 0.005; // adjust size of the highligh\nconst float highlight_sharpness = 2.0; // the larger the highlighted area becomes more sharpened (an integer)\nconst float highlight_square_magnitude = 0.02; // prescribes the magnitude of the squared area. (between 0 to 1)\nconst float highlight_scale = 0.4; // used for scaling highlight (0<delta<=1.0)\nconst float highlight_split = 0.15; // how far the splitted highlight should be\n\n// DEPTH (Z-VALUE) CALCULATION\n//#define DEPTH_FROM_CAMERA\n#define DEPTH_ALONG_FOCAL_AXIS\n\n// X-TOON ATTRIBUTES\n// ---------------------------------------------------------------------\n//#define XTOON_ON\n\n#define MULTIPLY_XTOON\n\n// how is D calculated (determines texture coordinate)\n//#define DEPTH_BASED_D\n//#define ORIENT_BASED_D_R\n#define ORIENT_BASED_D_S\n\nconst float z_min = 2.0;            //most vague\n//should be adjust when using different texture to achieve idea result\n#ifdef DEPTH_BASED_D\n    const float z_r = 100.0;         //>=1.0\n#else\n    const float z_r = 0.9;           //power of the orientation based effect\n#endif\nconst float z_s = 1.0;              // shininess\nconst float z_max = z_r * z_min;    //most detailed (the smaller, the more close you need to get to get most detailed)\n\n\n// ======================================================================\n// Math\nconst float PI = 3.14159265358979323846;\nconst float HALF_PI = 1.5707963268;\nconst float INV_PI = 0.31830988618379067154; \nconst float DEG_TO_RAD = PI / 180.0;\nconst float EPSILON = 0.00001; \n\n// ======================================================================\n// Structures\nstruct Ray {\n    vec3 origin;     // The starting point of the ray\n    vec3 direction;  // The direction in which the ray points\n};\n\n\n// ======================================================================\n// SDFs\n// Teapot SDF Model \n// reference: “Isosurface Teapot” by klk. https://www.shadertoy.com/view/3lG3Dc\n// Many thanks to TA Katherine\n// ----------------------------------------------------------------------\nfloat smin(float a, float b, float k)\n{\n\tfloat h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\treturn mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k)\n{\n\treturn -smin(-a,-b,k);\n}\n\nfloat smin( float a, float b)\n{\n\treturn smin(a,b,0.1);\n}\n\nfloat smax( float a, float b)\n{\n\treturn smax(a,b,0.1);\n}\n\nfloat sq(float x){return x*x;}\n\nfloat Torus(float x, float y, float z, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(x)+sq(z))-R)+sq(y))-r;\n}\n\nfloat Torus(vec3 p, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(p.x)+sq(p.z))-R)+sq(p.y))-r;\n}\n\n\nfloat Lid(float x, float y, float z)\n{\n\tfloat v=sqrt(sq(x)+sq(y-0.55)+sq(z))-1.4;\n\tv=smin(v,Torus(y-2.,x,z,.2,.08),.1);\n\tv=smax(v,-sqrt(sq(x)+sq(y-0.55)+sq(z))+1.3);\n\tv=smax(v,sqrt(sq(x)+sq(y-2.5)+sq(z))-1.3);\n\n\tv=smax(v,-sqrt(sq(x-.25)+sq(z-.35))+0.05,.05);\n\tv=smin(v,Torus(x,(y-1.45)*.75,z,.72,.065),.2);\n\treturn v;\n}\n\nfloat Nose(float x, float y, float z)\n{\n\tz-=sin((y+0.8)*3.6)*.15;\n\t\n\tfloat v=sqrt(sq(x)+sq(z));\n\t\n\tv=abs(v-.3+sin(y*1.6+.5)*0.18)-.05;\n\tv=smax(v,-y-1.);\n\tv=smax(v,y-0.85,.075);\n\t\n\treturn v;\n}\n\nfloat sdTeapot(vec3 p)\n{\n\tfloat x=p.x;\n\tfloat y=p.y;\n\tfloat z=p.z;\n\n\tfloat v=0.0;\n\tv=sqrt(x*x+z*z)-1.2-sin(y*1.5+2.0)*.4;\n\tv=smax(v,abs(y)-1.,0.3);\n\n\tfloat v1=sqrt(x*x*4.+sq(y+z*.1)*1.6+sq(z+1.2))-1.0;\n\tv1=smax(v1,-sqrt(sq(z+1.2)+sq(y+z*.12+.015)*1.8)+.8,.3);\n\t\n\tv=smin(v,Torus(y*1.2+.2+z*.3,x*.75,z+1.25+y*.2,.8,.1),.25);\n\tv=smin(v,sqrt(sq(x)+sq(y-1.1)+sq(z+1.8))-.05,.32);\n\n\tfloat v3=Nose(x,(y+z)*sqrt(.5)-1.6,(z-y)*sqrt(.5)-1.1);\n\n\tv=smin(v,v3,0.2);\n\t\n\tv=smax(v,smin(sin(y*1.4+2.0)*0.5+.95-sqrt(x*x+z*z),y+.8, .2));\n\tv=smax(v,-sqrt(sq(x)+sq(y+.15)+sq(z-1.5))+.12);\n\n\tv=smin(v,Torus(x,y-0.95,z,0.9,.075));\n\tv=smin(v,Torus(x,y+1.05,z,1.15,.05),0.15);\n\n\tfloat v2=Lid(x,y+.5,z);\n\tv=min(v,v2);\n\n\treturn v;\n}\n// ----------------------------------------------------------------------\nfloat sdFloor(vec3 p) {\n  //float v = p.y + 1.5;\n  p = p + vec3(0.0, 1.4, 0.0); //offset\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(floor_radius, 0.25);\n  float v = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return v;\n}\n// ----------------------------------------------------------------------\nfloat sdSphere( vec3 p, float r )\n{\n  return length(p)-r;\n}\n\n// ======================================================================\n// Ray marching\nvec3 ray_dir( float fov, vec2 size, vec2 pos )\n{\n    vec2 xy = pos - size * 0.5;\n\n    float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n    float z = size.y * 0.5 * cot_half_fov;\n    \n    return normalize( vec3( xy, -z ) );\n}\n\n\nvec3 hitObjColor(vec3 p) {\n    float bubble1 = sdSphere((p + sphere_pos_1), sphere_r);\n    float bubble2 = sdSphere((p + sphere_pos_2), sphere_r);\n    float bubble3 = sdSphere((p + sphere_pos_3), sphere_r);\n   \n    float teapot = sdTeapot(p);\n    float plate = sdFloor(p);\n    \n    float co = min(min(min(min(teapot, plate), bubble1), bubble2), bubble3); //closest object\n    \n    if (co == bubble1 || co == bubble2 || co == bubble3) {\n        return bubble_col;\n    } else if (co == teapot) {\n        return teapot_col;\n    } else {\n        return floor_col;\n    }\n\n    if (sdTeapot(p) < sdFloor(p)) return teapot_col;\n    return floor_col;\n}\n\nfloat sdScene(vec3 p) {\n    float bubble1 = sdSphere((p + sphere_pos_1), sphere_r);\n    float bubble2 = sdSphere((p + sphere_pos_2), sphere_r);\n    float bubble3 = sdSphere((p + sphere_pos_3), sphere_r);\n   \n    float teapot = sdTeapot(p);\n    float plate = sdFloor(p);\n    \n    return min(min(min(min(teapot, plate), bubble1), bubble2), bubble3);\n\n    return min(sdTeapot(p), sdFloor(p));\n}\n\n// with edge detection\n// view dependent\nfloat ray_marching( Ray cam, float start, float end, float edgeLength ) \n{\n    float depth = start;\n    \n    for (int i = 0; i < MAX_STEP; i++) \n    {\n        vec3 p = cam.origin + cam.direction * depth; // take minimum step\n        \n        // march for a distance in the scene\n        float dist = sdScene(p);\n        \n        edgeLength = min(dist, edgeLength);\n        \n        if ( dist < MIN_DIST ) \n            return depth; // hit\n        \n        \n        #ifdef LINEART_ON\n            if (dist > edgeLength && edgeLength <= edge_thickness ) // Edge hit\n                return 0.0;\n        #endif\n        \n        depth += dist * scale_factor;\n        \n        if ( depth >= end ) // no hit\n            return end;\n    }\n    \n    return depth;\n}\n\n// without edge detection\nfloat ray_marching( Ray ray, float start, float end) \n{\n    float depth = start;\n    \n    for (int i = 0; i < MAX_STEP; i++) \n    {\n        vec3 p = ray.origin + ray.direction * depth; // take minimum step\n        \n        // march for a distance in the scene\n        float dist = sdScene(p);\n        \n\n        \n        if ( dist < MIN_DIST ) \n            return depth; // hit\n        \n        \n        depth += dist * scale_factor;\n        \n        if ( depth >= end ) // no hit\n            return end;\n    }\n    \n    return depth;\n}\n\n\n\n// Gradient in the world\nvec3 getNormal( vec3 v ) \n{\n    const vec3 dx = vec3( 0.1, 0.0, 0.0 );\n    const vec3 dy = vec3( 0.0, 0.1, 0.0 );\n    const vec3 dz = vec3( 0.0, 0.0, 0.1 );\n    \n    return normalize(\n        vec3(\n            sdScene( v + dx ) - sdScene( v - dx ),\n            sdScene( v + dy ) - sdScene( v - dy ),\n            sdScene( v + dz ) - sdScene( v - dz )\n        )\n    );\n}\n\n// ======================================================================\n// Camera\nmat3 cameraMatrix(vec3 cx, vec3 cy, vec3 cam_dir){\n    return mat3(cx, cy, cam_dir);\n}\n\n// ======================================================================\n// Maths\nvoid createLocalFrame(vec3 N, out vec3 T, out vec3 B) \n{\n    // choose an arbitary vector v such that v is not parallel to N\n    vec3 v = vec3(1.0, 0.0, 0.0);\n    if (N == v) v = vec3(0.0, 0.0, 1.0);\n    // project v onto the plane perpendicular to N\n    T = v - dot(v, N) * N;\n    T = normalize(T);\n    // take the cross product of N and T to get B\n    B = cross(N, T);\n    B = normalize(B);\n}\n\nfloat sgn (float x) \n{\n    if (x==0.0) return 1.0;\n    else return x/abs(x);\n}","name":"Common","description":"","type":"common"}]}