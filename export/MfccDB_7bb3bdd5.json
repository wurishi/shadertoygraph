{"ver":"0.1","info":{"id":"MfccDB","date":"1731080500","viewed":102,"name":"genjutsu 2","username":"nayk","description":"source https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/MXSyzd","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","spiral","rotate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\n// Función de ruido mejorada utilizando una textura de ruido en iChannel0\nfloat noise(vec2 p) {\n    return texture(iChannel0, p * 0.1).r;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; i++) {\n        f += amp * noise(p);\n        p = p * 2.0;\n        amp *= 0.5;\n    }\n    return f;\n}\n\n// Función para calcular el conjunto de Mandelbrot\nfloat mandelbrot(vec2 c) {\n    vec2 z = vec2(0.0);\n    int maxIter = 100;\n    int i;\n    for(i = 0; i < maxIter; i++) {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(dot(z,z) > 4.0) break;\n    }\n    return float(i) / float(maxIter);\n}\n\nvec3 neonPalette(float t) {\n    // Paleta de colores brillantes\n    return vec3(0., -.2, 0.5 + 6.5 * sin(6.2831 * (t + vec3(0.0, 3.33, 99.66))));\n}\nbool pointInsideTriangle(vec3 p, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec3 u = v2 - v1;\n    vec3 v = v3 - v1;\n    vec3 w = p - v1;\n    \n    float uu = dot(u, u);\n    float uv = dot(u, v);\n    float vv = dot(v, v);\n    float wu = dot(w, u);\n    float wv = dot(w, v);\n    \n    float denom = uv * uv - uu * vv;\n    float s = (uv * wv - vv * wu) / denom;\n    float t = (uv * wu - uu * wv) / denom;\n    \n    return (s >= 0.0) && (t >= 0.0) && (s + t <= 1.0);\n}\n\n// Sets up the camera position in an orbit around a center point\nvec3 getCameraPosition(float radius, float angle, float height, vec3 center)\n{\n    return center + vec3(radius * cos(angle), height, radius * sin(angle));\n}\n\n// Calculates the screen plane vectors given a camera and target position\nvec3 getScreenPoint(vec2 screenPos, vec3 screenCenter, vec3 normalVector)\n{\n    vec3 rightVec = normalize(cross(vec3(0, 1, 0), normalVector));\n    vec3 upVec = normalize(cross(normalVector, rightVec));\n    return screenCenter + rightVec * screenPos.x + upVec * screenPos.y;\n}\n\n// Performs ray-plane intersection and returns the intersection point\nvec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDir, vec3 planePoint, vec3 planeNormal)\n{\n    float denom = dot(planeNormal, rayDir);\n    if (abs(denom) > 1e-6) { // Check for a valid intersection\n        float t = dot(planeNormal, planePoint - rayOrigin) / denom;\n        return rayOrigin + t * rayDir;\n    }\n    return vec3(0); // Return zero vector if no intersection (optional)\n}\n\n// Checks if a ray intersects a specific cube face and colors it\nbool checkCubeFaceIntersection(vec3 rayOrigin, vec3 rayDir, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 faceColor, inout vec4 fragColor)\n{\n    vec3 normal = normalize(cross(v2 - v1, v3 - v1));\n    vec3 inter = rayPlaneIntersection(rayOrigin, rayDir, v1, normal);\n    \n    bool insideA = pointInsideTriangle(inter, v1, v2, v3);\n    bool insideB = pointInsideTriangle(inter, v1, v3, v4);\n    if (insideA || insideB) {\n        fragColor = vec4(faceColor, 1.0);\n        return true;\n    }\n    return false;\n}\n\n// Function to calculate the center of a face given its four vertices\nvec3 calculateFaceCenter(vec3 v1, vec3 v2, vec3 v3, vec3 v4) {\n    return (v1 + v2 + v3 + v4) / 4.0;\n}\n\n// Bubble Sort for face indices based on distance from camPos\nvoid sortFacesByDistance(float distances[6], out int indices[6]) {\n    for (int i = 0; i < 6; i++) {\n        for (int j = i + 1; j < 6; j++) {\n            if (distances[i] < distances[j]) {\n                // Swap distances\n                float tempDist = distances[i];\n                distances[i] = distances[j];\n                distances[j] = tempDist;\n                \n                // Swap indices\n                int tempIndex = indices[i];\n                indices[i] = indices[j];\n                indices[j] = tempIndex;\n            }\n        }\n    }\n}\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define MAX_MANDELBROT_ITERATIONS 100\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat GetDist(vec3 p) {\n    // Rotation\n    float t = iTime;\n    p.xz *= Rot(t);\n    p.xy *= Rot(t * 0.7);\n    \n    // Throbbing effect\n    float pulse = sin(t * 2.0) * 0.1 + 1.0;\n    \n    // Box\n    float d = sdBox(p, vec3(0.3 * pulse));\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 mandelbrot2(vec2 uv) {\n    vec2 c = uv;\n    vec2 z = vec2(0.0);\n    float iter = 0.0;\n    \n    for(int i = 0; i < MAX_MANDELBROT_ITERATIONS; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if(dot(z, z) > 4.0) break;\n        iter++;\n    }\n    \n    if(iter == float(MAX_MANDELBROT_ITERATIONS)) {\n        return vec3(0.0);\n    }\n    \n    float f = iter / float(MAX_MANDELBROT_ITERATIONS);\n    vec3 col = 0.5 + 0.5 * cos(3.0 + f * 4.0 + vec3(0.0, 0.6, 1.0));\n    return col;\n}\n#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat TAU1 = 2.*3.14159;\n\n// Thanks IQ\nfloat eqTri( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n    vec2 uv2 = (fragCoord.xy / iResolution.xy) - .5;\n       uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n       uv*=vec2(fract(log(length(uv.xy))+iTime*.5));\n        \n\tfloat t3 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t3);\n\tfloat co = cos(t3);\n\tmat2 ma = mat2(co, si, -si, co);\n // Variable de tiempo\n    float t = iTime * 0.1;\n\n    // **Deformación del espacio en una forma fluida no euclidiana**\n    vec2 distortion = fbm(uv * 3.0 + t) * vec2(0.5, 0.5);\n    uv2 += distortion;\n\n    // **Cálculo del conjunto de Mandelbrot**\n    vec2 c = uv * vec2(3.5, 2.0) + vec2(-2.5, -1.0);\n    float m = mandelbrot(c);\n\n    // **Color de neón basado en el Mandelbrot**\n    vec3 neonColor = neonPalette(m);\n    neonColor *= pow(1.0 - m, 3.0); // Intensidad de brillo de neón\n\n    // Inicializar color\n    vec3 col3 = vec3(0.0);\n\n    // Coordenadas polares\n    float r = length(uv);\n    float angle = atan(uv.y, uv.x);\n\n    // Movimiento de la espiral con el tiempo\n    float spiral = angle + r * 8.0 - t * 2.0 + sin(t + r * 5.0) * 0.5;\n    float arms = sin(spiral * 3.0);\n\n    // Nebulosa nubosa usando fbm\n    float n = fbm(uv * 5.0 + vec2(t * 0.5, t * 0.3));\n\n    // Intensidad de la nebulosa y mezcla de colores\n    float nebulaIntensity = exp(-pow(r * 1.5, 2.0)) * arms * n;\n\n    // **Incorporar el valor de Mandelbrot en la intensidad de la nebulosa**\n    nebulaIntensity *= pow(1.0 - m, 2.0);\n\n    nebulaIntensity = smoothstep(0.0, 1.0, nebulaIntensity);\n    vec2 uv3 = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec3 ro = vec3(0, 1, -0.1);\n    \n    vec3 rd = GetRayDir(uv3, ro, vec3(0,0,0), 1.);\n\n    // Mandelbrot background\n    float zoom = exp(sin(iTime * 0.1) * 0.5 + 0.5) * 2.0;\n    vec2 mandelbrotUV = uv * zoom + vec2(-0.5, 0.0);\n    vec3 bgColor = mandelbrot2(mandelbrotUV);\n\n    float d = RayMarch(ro, rd);\n     vec3 cubeColor;\n  vec4 fragColor2 =fragColor;\n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        \n        vec3 lightPos = vec3(2, 4, -3);\n        vec3 l = normalize(lightPos - p);\n        \n        float dif = dot(n, l) * .5 + .5;\n        vec3 difColor = vec3(dif);\n        \n        // Color changing effect for cube\n        vec3 cubeColor = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0,2,4));\n        \n        // Apply lighting to cube\n        cubeColor *= difColor;\n        \n        // Apply semi-transparency and blend with background\n        float alpha = 0.7;\n        fragColor2 = vec4(mix(bgColor, cubeColor, alpha), 1.0);\n\n\n    // Colores rosa pastel y dorado\n    vec3 pastelPink = vec3(1.0, 0.7, 0.85);\n    vec3 gold = vec3(1.0, 0.85, 0.5);\n\n    // Mezclar colores como en una pintura\n    vec3 nebulaColor = mix(pastelPink, gold, n);\n\n    // **Mezclar el color de neón con el color de la nebulosa**\n    nebulaColor = mix(nebulaColor, neonColor, 0.5);\n\n    // Aplicar color de la nebulosa\n    col3 += nebulaIntensity * nebulaColor;\n\n    // Brillo del núcleo\n    float coreGlow = exp(-pow(r * 4.0, 2.0));\n    vec3 coreColor = gold;\n    col3 += coreGlow * coreColor;\n\n    // Ajustes finales de color\n    col3 = pow(col3, vec3(0.4545));\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t vec3 col = vec3(0.);\n   float time = mod(iTime,10.);\n    float speed;\n   if(time<2.){\n   \n   \n   speed=0.;\n   \n   }\n    if(time>2.){\n   \n   \n   speed=0.2;\n   \n   }\n    if(time>5.){\n   \n   \n   speed=0.5;\n   }\n   if(time>7.){\n   \n   \n   speed=2.5;\n   }\n   \n    vec2 uv2 = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n   vec3 col2 = vec3(0.);\n   float t2 = fract(.1 * iTime);\n   uv2 *= rotation(3. * t2*TAU * (.3 - clamp(length(uv2),0.,.3)));\n   float s2 = -1.;\n   for(float i = 0.; i < 3.; i++){\n     float rad = .4 / pow(2.,i) * (.9 - .2 * i);\n     uv2 *= rotation(-2. + iTime*speed * (i + 1.) * TAU * t2);\n     float tri = eqTri(uv2, rad);\n     s2 *= -1.;\n     col2 += .004 / abs(tri);\n   }\n   \n   \n   float t = fract(.01 * iTime);\n   uv2 *= rotation(0.1 * iTime * (.3 - clamp(length(uv2),0.,.3)));\n   float s = -1.;\n   for(float i = 0.; i < 3.; i++){\n     float rad = .4 / pow(2.,i) * (.9 - .2 * i);\n   \n     float tri = eqTri(uv2, rad);\n     s *= -1.;\n     col += .004 / abs(tri);\n   }\n\tfloat s22 = 0.0;\n\tfor (int i = 0; i <100; i++)\n\t{\n\t\tvec3 p = s22 * vec3(uv, 0.0);\n\tp.xy*=vec2(fract(log(length(p.xy))+iTime*.5));\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)*fragColor2.xyz+col3+col2 ;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts2  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.2, .2, len);\n\tv2 *= smoothstep(.2, .2, len);\n\tv3 *= smoothstep(.2, .0, len);\n\t\n\tvec3 col4 = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col4), vec3(1.2)), 1.0), 1.0);\n   \n }\n}","name":"Image","description":"","type":"image"}]}