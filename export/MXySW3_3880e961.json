{"ver":"0.1","info":{"id":"MXySW3","date":"1720552426","viewed":37,"name":"terrible value noise grid","username":"int_45h","description":"trying to mimic the look of an 80s style terrain rendered with grid lines","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["valuenoise","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST .001\n#define MAX_DIST 100.\n#define STEPS 140\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tuint n = (q.x ^ q.y ^ q.z) * 1597334673U;\n\treturn float(n) * 2.328306437080797e-10;\n}\n\nfloat value3d(vec3 p)\n{\n    vec3 pg=floor(p),pc=p-pg; \n    vec2 n=vec2(0,1);\n    \n    float p0 = mix(hash13(pg+n.xxx), hash13(pg+n.yxx), pc.x);\n    float p1 = mix(hash13(pg+n.xyx), hash13(pg+n.yyx), pc.x);\n    float p2 = mix(hash13(pg+n.xxy), hash13(pg+n.yxy), pc.x);\n    float p3 = mix(hash13(pg+n.xyy), hash13(pg+n.yyy), pc.x);\n    \n    pc.z = pc.z*pc.z*(3.-2.*pc.z);\n    return mix(mix(p0, p1, pc.y), mix(p2, p3, pc.y), pc.z);\n}\n\nfloat sd_plane(vec3 p, float h){return dot(p,vec3(0,1,0))+h;}\nfloat sd_sphere(vec3 p, float r){return length(p)-r;}\n\nfloat SDF(vec3 p, vec3 o)\n{\n    float t = iTime;\n    float n = value3d(vec3(p.xz, t))*clamp(length(p-o), 0., 1.)*smoothstep(0.2, .8, min(abs(p.x/6.), 1.));\n    return sd_plane(p, 1. - n);\n}\n\nfloat grid(vec2 p, float w)\n{\n    vec2 pc=fract(p);\n    return (pc.x < w || pc.x > (1.-w) || pc.y < w || pc.y >= (1.-w)) ? 1. : 0.;\n}\n\nvec3 raymarch(vec3 o, vec3 d)\n{\n    float sky = smoothstep(0., .35, d.y);\n    vec3 c = mix(vec3(.5,.2,.2),vec3(.2, .0, .4),sky);\n    float t = 0.;\n    for (int i=0;i<STEPS;i++)\n    {\n        vec3 p=o+t*d;\n        float dist=SDF(p, o);\n        t+=dist;\n        if (t>MAX_DIST) break;\n        if (dist<MIN_DIST)\n        {\n            float m = grid(p.xz, 0.05)*exp(-t/8.);\n            c = mix(c, vec3(1.), m*exp(-t/1000.));\n            break;\n        }\n    }\n    return c;\n}\n\nvec3 render(vec2 U)\n{\n    vec3 o = vec3(0,0,iTime);\n    vec3 d = normalize(vec3(\n        (U-.5*iResolution.xy)/iResolution.y,\n        1\n    ));\n    \n    vec2 n = vec2(0,.001);\n    return raymarch(o,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(render(fragCoord),1.0);\n}","name":"Image","description":"","type":"image"}]}