{"ver":"0.1","info":{"id":"3lSSzK","date":"1566373875","viewed":2219,"name":"Fast Sin and Cos","username":"alenwesker","description":"Fast sin and cos, only faster in mobile devices ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sin","cos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.14159265359\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n#define float2 vec2\n#define float4 vec4\n#define fmod mod\n#define saturate(x) clamp(x, 0.0f, 1.0f)\n#define frac fract\n\n/*\nOnly faster in mobile devices\n\nWe tested the time consumed by specific instructions, \nthat \"sin\" costs at least 4 times than a single \"dot\" instruction. \n\nActually, there's no reason for a 1 instruction optimization. \nBut there are certain reasons for avoiding sin at specific mobile environment:\n\n* Use this fastsin may be able for avoiding metal pre-z flickering when using fast math (Only if you encounter this problem on wind simulation)\n* A more stable random, you can find it on another shader published by myself. (I encounter this on my grass shader)\n* You can't predict how sin is expanded to Tylor Series on a certain mobile device, which may be a problem. (Some android devices just keep flickering)\n* Just use origin sin in PC / Console platforms,  it just cost 1 clock-cycle on PC/Console.\n\nhttps://www.desmos.com/calculator/n34l7ynlug  Here is the desmo graph\n*/\n\nfloat FastSinIn2PI(float zeroTo2PI) //If you garantee the input is within [0, 2pi], use this to avoid fmod and may save up to 4 instructions\n{\n    //This calculation is achieved by Desmo; Only 3 instructions !!!\n    float2 core = float2(zeroTo2PI, zeroTo2PI) * float2(1.0f / HALF_PI, 1.0f / HALF_PI)  + float2(-1.0f, -3.0f);  //mad\n    float2 result2 = saturate(-core * core + float2(1.0f, 1.0f)); //mad_sat\n    return result2.x - result2.y;  //add\n}\n\n/*\nIf you are using HLSL, which fmod differs from GLSL, https://stackoverflow.com/questions/7610631/glsl-mod-vs-hlsl-fmod\nTurn fmod to x - floor(x / y) * y;\n*/\n\nfloat FastSinV5(float x) \n{\n    //Base on v4, and try to optimize the instruction number a little\n\tfloat zeroTo2PI = fmod(x, TWO_PI); //move to range 0-2pi  //mod could be relatively expansive that it could be expanded to 4 instructions\n\n    return FastSinIn2PI(zeroTo2PI);\n}\n\n\nfloat2 FastSinCosV5(float x) //Calculate sin/cos together to save instructions\n{\n    //Base on FastSinV5\n\tfloat2 zeroTo2PI = fmod(float2(x, x) + float2(0, HALF_PI), float2(TWO_PI, TWO_PI)); //move to range 0-2pi\n\n    //This calculation is achieved by Desmo; Only 3 instructions !!!\n    float4 core = float4(zeroTo2PI.xxyy) * (1.0f / HALF_PI)  + float4(-1.0f, -3.0f, -1.0f, -3.0f);\n    float4 result = saturate(-core * core + float4(1.0f, 1.0f, 1.0f, 1.0f));\n    return float2(result.xz - result.yw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    #if 0 //Change it to 1 to review sin/cos curves\n    float2 sinCosValue = FastSinCosV5(uv.x * TWO_PI);\n    float valueSin = (uv.y*2.0 - 1.0) > sinCosValue.x ? 1.0 : 0.0;\n    float valueCos = (uv.y*2.0 - 1.0) > sinCosValue.y ? 1.0 : 0.0;\n    vec3 col = vec3(valueSin, valueCos, 0);\n    #else\n    float sinCosValue = FastSinV5(uv.x * TWO_PI);\n    float valueSin = (uv.y*2.0 - 1.0) > sinCosValue ? 1.0 : 0.0;\n    vec3 col = vec3(valueSin, valueSin, valueSin);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}