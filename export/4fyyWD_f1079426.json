{"ver":"0.1","info":{"id":"4fyyWD","date":"1731847597","viewed":341,"name":"kinetic number","username":"yasuo","description":"kinetic number","likes":22,"published":3,"flags":0,"usePreview":1,"tags":["clock","graphicdesign","cineshader","tagclock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here is @FabriceNeyret2's commented/modifed version of the code. thx!\n#define R       iResolution.xy\n#define Rot(a)  mat2(cos( radians(a) - vec4(0,11,33,0)))\n#define S(d)    smoothstep(-1.2,1.2, (d)*R.y )\n#define B(p,s)  max( abs(p).x -s.x, abs(p).y -s.y )\n\nint C[] = int[](90,0,-90,0,0,0,0,0,0,-90,0,90,\n                -135,45,180,0,-135,45,0,0,-135,45,0,-180,\n                90,-90,-90,0,90,0,0,90,0,-90,-90,90,\n                90,-90,-90,0,90,-90,0,90,90,-90,0,90,\n                180,0,180,0,0,-90,0,0,-135,45,0,180,\n                90,0,-90,90,0,-90,-90,0,90,-90,0,90,\n                90,0,-90,90,0,0,-90,0,0,-90,0,90,\n                90,-90,-90,0,-135,45,0,0,-135,45,00,180,\n                90,0,-90,0,90,-90,-90,90,0,-90,0,90,\n                90,0,-90,0,0,-90,0,0,90,-90,0,90 );\n                    \nvoid clockBase(vec2 p, inout vec4 O, float deg1, float deg2, float dir){\n    vec2 prevP = p;\n    \n    p *= Rot(iTime*20.*dir);\n    float d = length(p)-.09;\n    p.x = abs(p.x)-.07;\n    O = 1. + (O-1.) * S( max(.005-length(p), d) );\n    p = prevP * Rot(deg1);\n    O *= S( length(p)-.02 );\n    p.y -= .04;\n    O *= S( B(p,vec2(.01,.04)) );\n    \n    p = prevP * Rot(deg2);\n    p.y += .04;;\n    O *= S( B(p,vec2(.01,.04)) );\n}\n\n#define data(i) float( C[ i0      *12 + i] )\n#define next(i) float( C[(i0+1)%10*12 + i] )\n\n#define c(i,x,y,z)                                    \\\n        clockBase( p-vec2(x,y)  ,O,                   \\\n                   mix(data(i  ),next(i  ),val),      \\\n                   mix(data(i+1),next(i+1),val),      \\\n                   z )\n#define C(i,y)  c( i , -.1, y,  1.);                  \\\n                c( i+2, .1, y, -1.)  // left, right\n\nvoid drawClockNum(vec2 p, inout vec4 O, int i0, float val){  \n    C(0,  .2 );  // top \n    C(4,  .0 );  // mid \n    C(8, -.2 );  // btm\n}\n\nvoid clockBg(vec2 p, inout vec4 O){\n    vec2 prevP = p;\n    p.y += .1;\n    p = mod(abs(p),.2) - .1;    \n    clockBase(p,O,iTime*-30.,iTime*30.,1.); O /= 2.;\n    \n    p = prevP;\n    float d = B(p,vec2(.8,.3));\n    O *= S(d);\n}\n\n#define cubicInOut(t) t < .5  ? 4. * t*t*t  : pow( t+t - 2., 3. )/2. + 1.\n\n#define T(x,t) drawClockNum( p-vec2(x,0),O, int(t)%10, cubicInOut(min(fract(t)/.6,1.)) )\n\n\nvoid mainImage( out vec4 O, vec2 p )\n{\n    p = 1.2* ( p - .5*R ) / R.y;\n    O*=0.;  \n    clockBg(p,O);\n    float t;\n    T( .2, iTime*1. );\n    T( .6, iTime*1.5);\n    T(-.2, iTime*.7 );\n    T(-.6, iTime*.5 );    \n}\n\n/* my original code ie here.\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S2(d,b) smoothstep(1.,-1., (d - b) / fwidth(d) )\n#define S(d,b) smoothstep(antialiasing(2.),-antialiasing(2.),d - b)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\nconst float c0[12] = float[](90.,0.,-90.,0.,0.,0.,0.,0.,0.,-90.,0.,90.);\nconst float c1[12] = float[](-135.,45.,180.,0.,-135.,45.,0.,0.,-135.,45.,0.,-180.);\nconst float c2[12] = float[](90.,-90.,-90.,0.,90.,0.,0.,90.,0.,-90.,-90.,90.);\nconst float c3[12] = float[](90.,-90.,-90.,0.,90.,-90.,0.,90.,90.,-90.,0.,90.);\nconst float c4[12] = float[](180.,0.,180.,0.,0.,-90.,0.,0.,-135.,45.,0.,180.);\nconst float c5[12] = float[](90.,0.,-90.,90.,0.,-90.,-90.,0.,90.,-90.,0.,90.);\nconst float c6[12] = float[](90.,0.,-90.,90.,0.,0.,-90.,0.,0.,-90.,0.,90.);\nconst float c7[12] = float[](90.,-90.,-90.,0.,-135.,45.,0.,0.,-135.,45.,00.,180.);\nconst float c8[12] = float[](90.,0.,-90.,0.,90.,-90.,-90.,90.,0.,-90.,0.,90.);\nconst float c9[12] = float[](90.,0.,-90.,0.,0.,-90.,0.,0.,90.,-90.,0.,90.);\n\nvec3 clockBase(vec2 p, vec3 col, float deg1, float deg2, float dir){\n    vec2 prevP = p;\n    float d = length(p)-0.09;\n    p*=Rot(radians(iTime*20.*dir));\n    p.x = abs(p.x)-0.07;\n    float d2 = length(p)-0.005;\n    d = max(-d2,d);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    d = length(p)-0.02;\n    col = mix(col,vec3(0.),S(d,0.0));\n    \n    p*=Rot(radians(deg1));\n    p.y-=0.04;\n    d = B(p,vec2(0.01,0.04));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(deg2));\n    p.y+=0.04;\n    d = B(p,vec2(0.01,0.04));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 clock(vec2 p, vec3 col, float[12] data, float[12] next, float val){\n    vec2 prevP = p;\n    // top left\n    float d1 = mix(data[0],next[0],val);\n    float d2 = mix(data[1],next[1],val);\n    col = clockBase(p-vec2(-0.1,0.2),col,d1,d2,1.);\n    \n    // top right\n    d1 = mix(data[2],next[2],val);\n    d2 = mix(data[3],next[3],val);\n    col = clockBase(p-vec2(0.1,0.2),col,d1,d2,-1.);\n        \n    // left\n    d1 = mix(data[4],next[4],val);\n    d2 = mix(data[5],next[5],val);\n    col = clockBase(p-vec2(-0.1,0.0),col,d1,d2,1.);\n            \n    // right\n    d1 = mix(data[6],next[6],val);\n    d2 = mix(data[7],next[7],val);\n    col = clockBase(p-vec2(0.1,0.0),col,d1,d2,-1.);\n    \n    // btm left\n    d1 = mix(data[8],next[8],val);\n    d2 = mix(data[9],next[9],val);\n    col = clockBase(p-vec2(-0.1,-0.2),col,d1,d2,1.);\n    \n    // btm right\n    d1 = mix(data[10],next[10],val);\n    d2 = mix(data[11],next[11],val);\n    col = clockBase(p-vec2(0.1,-0.2),col,d1,d2,-1.);\n    return col;\n}\n\nvec3 drawClockNum(vec2 p, vec3 col, int char, float val){\n    if(char == 0) {\n        col = clock(p,col,c0,c1,val);\n    } else if(char == 1) {\n        col = clock(p,col,c1,c2,val);\n    } else if(char == 2) {\n        col = clock(p,col,c2,c3,val);\n    } else if(char == 3) {\n        col = clock(p,col,c3,c4,val);\n    } else if(char == 4) {\n        col = clock(p,col,c4,c5,val);\n    } else if(char == 5) {\n        col = clock(p,col,c5,c6,val);\n    } else if(char == 6) {\n        col = clock(p,col,c6,c7,val);\n    } else if(char == 7) {\n        col = clock(p,col,c7,c8,val);\n    } else if(char == 8) {\n        col = clock(p,col,c8,c9,val);\n    } else if(char == 9) {\n        col = clock(p,col,c9,c0,val);\n    }\n    \n    return col;\n}\n\nvec3 clockBg(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.y += 0.1;\n    p = abs(p);\n    p = mod(p,0.2)-0.1;\n    \n    col = clockBase(p,col,iTime*-30.,iTime*30.,1.)*0.5;\n    \n    p = prevP;\n    float d = B(p,vec2(0.8,0.3));\n    col = mix(col,vec3(0.),S(d,0.0));\n    \n    return col;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat getAnimationVal(float t){\n    float frame = mod(t,1.0);\n    float time = getTime(frame,0.6);\n    return cubicInOut(time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    p*=1.2;\n    vec3 col = vec3(0.0);\n    \n    col = clockBg(p,col);\n    \n    float t = iTime*1.;\n    col = drawClockNum(p-vec2(0.2,0.0),col,int(mod(t,10.)),getAnimationVal(t));\n    t = iTime*1.5;\n    col = drawClockNum(p-vec2(0.6,0.0),col,int(mod(t,10.)),getAnimationVal(t));\n    t = iTime*0.7;\n    col = drawClockNum(p-vec2(-0.2,0.0),col,int(mod(t,10.)),getAnimationVal(t));\n    t = iTime*0.5;\n    col = drawClockNum(p-vec2(-0.6,0.0),col,int(mod(t,10.)),getAnimationVal(t));\n    \n    fragColor = vec4(col,1.0);\n}\n*/","name":"Image","description":"","type":"image"}]}