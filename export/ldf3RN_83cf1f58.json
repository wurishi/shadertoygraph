{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float PI = 3.141592653589;\n\nfloat cap(vec2 a, vec2 b) {\n\tvec2 abd = vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y);\n\tfloat y_x = abd.y/(abd.x-1.);\n\t\n\treturn atan(-y_x)-y_x/(1.+y_x*y_x)+PI/2.;\n}\n\nfloat cap1(float p) {\n\tp = max(min(p,1.),-1.);\n\treturn asin(p)+p*sqrt(1.-p*p)+PI/2.;\n}\n\nfloat ebok(vec2 p, vec2 a, vec2 b) {\n\tvec2 an = vec2(a.y,-a.x);\n\tvec2 bn = vec2(b.y,-b.x);\n\t\n\tfloat surface;\n\tif (dot(normalize(an),normalize(bn))>.9999) {\n\t\t// This is neccessary to remove dot crawl around corners\n\t\tsurface = 0.;\n\t} else if (dot(p,p) < .99) {\n\t\tfloat pa = dot(p,a);\n\t\tfloat ra = -pa+sqrt(pa*pa-dot(p,p)+1.);\n\t\tvec2 pac = ra*a;\n\t\t\n\t\tfloat pb = dot(p,b);\n\t\tfloat rb = -pb+sqrt(pb*pb-dot(p,p)+1.);\n\t\tvec2 pbc = rb*b;\n\t\t\n\t\tsurface = cap(p+pac,p+pbc)+(pac.x*pbc.y-pac.y*pbc.x)*.5;\n\t} else {\n\t\tfloat d1 = dot(an,p);\n\t\tfloat d2 = -dot(bn,p);\n\t\tfloat sda = step(dot(p,a),0.);\n\t\tfloat sdb = step(dot(p,b),0.);\n\t\tsurface = PI*(sda+sdb-sda*sdb) - cap1(-d1)*sda - cap1(-d2)*sdb;\n\t\t\n\t}\n\treturn surface;\n}\n\nfloat handleCorner(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 ba = normalize(a-b);\n\tvec2 bc = normalize(c-b);\n\tfloat h = dot(a-p,vec2(ba.y,-ba.x));\n\treturn ebok(p-b, bc, ba) - cap1(h);\n}\n\nfloat bokehtria(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 mi = min(min(a,b),c)-1.;\n\tvec2 ma = max(max(a,b),c)+1.;\n\treturn (a.x-b.x)*(a.y-c.y)<(a.y-b.y)*(a.x-c.x)||p.x<mi.x||p.y<mi.y||p.x>ma.x||p.y>ma.y ? 0. :  handleCorner(p,a,b,c) + handleCorner(p,b,c,a) + handleCorner(p,c,a,b) + PI;\n}\n\nfloat bokehsquare(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, float scale) {\n\tp *= scale; a *= scale; b *= scale; c *= scale; d *= scale;\n\tvec2 mi = min(min(a,b),min(c,d))-1.;\n\tvec2 ma = max(max(a,b),max(c,d))+1.;\n\treturn (a.x-b.x)*(a.y-c.y)<(a.y-b.y)*(a.x-c.x)||p.x<mi.x||p.y<mi.y||p.x>ma.x||p.y>ma.y ? 0. :  handleCorner(p,a,b,c) + handleCorner(p,b,c,d) + handleCorner(p,c,d,a) + handleCorner(p,d,a,b) + PI;\n}\n\nvec2 project(vec3 v) {\n\treturn v.xy/(v.z+14.);\n}\n\nvec4 shade(vec3 v, float f) {\n\tfloat highlight = pow(f*.5+.5,100.);\n\treturn vec4(pow(f*.5+.5,10.)*v*1.5*(1.-highlight)+highlight,1.)/PI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat rx = iTime;\n\tmat3 matx = mat3(cos(rx),0,sin(rx),0,1,0,-sin(rx),0,cos(rx));\n\tmat3 mat = matx;\n\t\n\n\tmat3 rot = mat3(1,0,0,0,.8,.6,0,-.6,.8)*mat3(.96,.28,0,-.28,.96,0,0,0,1);\n\n\tvec2 p = ( fragCoord.xy - iResolution.xy*.5 ) / iResolution.x ;\n\t\n\tvec3 color = vec3(0,.2,.7);\n\t\n\tfor (float z = -1.; z <= 1.; z++) {\n\t\tfor (float x = -1.; x <= 1.; x++) {\n\t\t\tvec3 q = vec3(x*3.5+z,sin(x*2.+z*2.+iTime),z*-3.5+x);\n\t\t\t\n            vec2 mouse = iMouse.xy/iResolution.xy;\n\t\t\tfloat scale = 1./(1./(q.z+14.) - 1./(mouse.y*9.-4.5+14.1));\n\t\t\t\t\n\t\t\tvec2 a = project(vec3(-1.,1.,-1)*mat+q);\n\t\t\tvec2 b = project(vec3(1.,1.,-1.)*mat+q);\n\t\t\tvec2 c = project(vec3(-1.,1.,1.)*mat+q);\n\t\t\tvec2 d = project(vec3(1.,1.,1.)*mat+q);\n\t\t\tvec2 e = project(vec3(-1.,-1.,-1.)*mat+q);\n\t\t\tvec2 f = project(vec3(1.,-1.,-1.)*mat+q);\n\t\t\tvec2 g = project(vec3(-1.,-1.,1.)*mat+q);\n\t\t\tvec2 h = project(vec3(1.,-1.,1.)*mat+q);\n\t\t\t\n\t\t\tfloat s0 = step(dot(vec3(mat[0][1],mat[1][1],mat[2][1]),q+vec3(0,0,14.)),0.);\n\t\t\tfloat s1 = step(0.,dot(vec3(mat[0][2],mat[1][2],mat[2][2]),q+vec3(0,0,14.)));\n\t\t\tfloat s2 = step(0.,dot(vec3(mat[0][0],mat[1][0],mat[2][0]),q+vec3(0,0,14.)));\n\t\t\tfloat t0 = 1.-s0;\n\t\t\tfloat t1 = 1.-s1;\n\t\t\tfloat t2 = 1.-s2;\n\t\t\t\n\t\t\tvec4 color1 = \n\t\t\t\t   bokehsquare(p,a*s0+g*t0,b*s0+h*t0,d*s0+f*t0,c*s0+e*t0,scale)*shade(vec3(.7*s0+.3*t0,.5,.5),mat[2][1]*(t0-s0))\n\t\t\t\t+  bokehsquare(p,b*s1+h*t1,a*s1+g*t1,e*s1+c*t1,f*s1+d*t1,scale)*shade(vec3(.5,.7*s1+.3*t1,.5),mat[2][2]*(s1-t1))\n\t\t\t\t+  bokehsquare(p,a*s2+f*t2,c*s2+h*t2,g*s2+d*t2,e*s2+b*t2,scale)*shade(vec3(.5,.5,.7*s2+.3*t2),mat[2][0]*(s2-t2));\n\t\t\tcolor = color1.xyz + color*(1.-color1.w);\n\t\t\tmat *= rot;\n\t\t}\n\t}\n\n\t\n\n\tfragColor = vec4( vec3(sqrt(color)), 1.0 );\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldf3RN","date":"1363728009","viewed":9080,"name":"Bokeh blur","username":"Kabuto","description":"Click and drag to change focal plane.\n\nEach cube face is blurred separately and the results are added up. Instead of blurring polygons as a whole each (which would create lots of corner cases) each edge and corner is blurred separately. ","likes":202,"published":1,"flags":0,"usePreview":0,"tags":["blur","bokeh"],"hasliked":0,"parentid":"","parentname":""}}