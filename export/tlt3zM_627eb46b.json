{"ver":"0.1","info":{"id":"tlt3zM","date":"1576144914","viewed":777,"name":"FlowMapEditor","username":"sapporo_dynamite","description":"Easy Flow Map Editor\n[control]\nviewChange[paint mode or preview]: key 1 \nerase: key 2 + mouse drag \nreset:  key 3","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["water","paint","cell","gpgpu","editor","flowmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tFlow Map Editor\n\n\tImplements Easy Flow Map Editor\n\n\tHow Flow Map Editor works\n\t1. Buffer A: Create a texture that records vector values of movement\n\t2. Buffer B: Depress the texture of Buffer A with gaussian blur\n\n\tauthor:\n\tsapporo_dynamite/2019 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n　　URL：\n    naochang blog\n    ShaderでImageをかき混ぜる\n\thttp://naochang.me/?p=873#more-873\n\n    LIGHT11\n\t【Unity】【シェーダ】フローマップで水流を作る\n\thttp://light11.hatenadiary.com/entry/2018/03/15/000311\n*/\n\n/*\n2019/12/12\n  0.0.0 → 1.0.0\n    ・1st release   \n\n2019/12/11\n  0.0.0 → 0.0.0\n    ・start\n*/\n\nbool keyPress(int ascii){\n    return (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// draw line\nfloat Line (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    vec2 p1uv =  (p1.xy + 0.5) / vec2(iResolution.xy);\n    vec2 p2uv =  (p2.xy + 0.5) / vec2(iResolution.xy);\n    \n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1uv, p2uv);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1uv, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1uv, p2uv, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\n// draw circle\nfloat circle(vec2 r, vec2 center, float radius) \n{\n\treturn (1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center))) - (1.0 - smoothstep( radius * 0.99 -0.5, radius * 0.99 +0.5, length(r-center)));\n}\n\nvec4 getBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel1, uv, -100.0);\n    }\n    return vec4(0.); \n} \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------------------------------------------------------------\n    // Flow Map Editor の仕組み\n\t// 1. Buffer A: 移動量のベクトル値を記録するテクスチャの作成\n\t// 2. Buffer B: Buffer A のテクスチャを gaussian blur で暈す\n    //------------------------------------------------------------\n\t\n    // Implement FlowMap\n    vec2 uv = fragCoord/iResolution.xy;\n    const float timescale = .174;\n\tvec2 flowDir =  (texture(iChannel1, uv).xy - 0.5) * vec2(-1,1);\n\tfloat time = (iTime ) * timescale; \n\tfloat flow_t0 = fract(time);\n\tfloat flow_t1 = fract(time + .5);\n\tfloat lerp = abs((0.5 - flow_t0) / 0.5); \n\tvec4 samp0 = texture(iChannel3, uv + flowDir * flow_t0); \n\tvec4 samp1 = texture(iChannel3, uv + flowDir * flow_t1);\n\n\tfragColor = mix(samp0, samp1, lerp);\n \n    // key 1 で 表示切替( ペイントモード と プレビュー)\n    // key 1 chage view [paint mode or preview]\n    if(!keyToggle(49)){\n        fragColor = getBuffer(fragCoord);\n    }\n    // ペイントする範囲の表示\n    // debug circle (guide brush)\n    if( iMouse.z * circle(iMouse.xy, fragCoord.xy, 18.) > 0.0) { \n    \tfragColor += vec4(1.);\n    }\n    // ペイントの向きの表示\n    // debug line (guide draw direction)\n    if(iMouse.z > 0.0 && !keyPress(50)){\n        if ( Line(iMouse.xy, abs(iMouse.zw), uv, 1.) > 0.0 ){\n            fragColor = vec4(1);\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel0, uv, -100.0);\n    }\n    return vec4(0.);\n}\n\nbool keyPress(int ascii){\n    return (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cell = floor(fragCoord);\n    \n    if(iFrame == 0) {\n    \tfragColor = vec4(0.5,0.5,0.0,1.0);\n    }\n    else {\n        vec4 col = getBuffer(cell);\n        fragColor = col;\n        float size = 16.0;\n        \n        // 方向は 現在のマウス位置 と マウスクリックした位置 から求める\n        // direction　= current mouse pos - mouse click pos \n        vec2 v = vec2(iMouse.xy) - vec2(abs(iMouse.zw));\n        \n        if(length(v) > 0.01){\n        \tv = normalize(v);\n            v = v * 0.5 + 0.5;\n            if( iMouse.z * disk(iMouse.xy, cell.xy, size) > 0.0) { \n                fragColor = vec4(v.x, 1.0 - v.y, 0, 1.0);\n            }\n        }\n        // key 2 erase\n        if( iMouse.z * disk(iMouse.xy, cell.xy, size) > 0.0) { \n        \tif( keyPress(50) ) fragColor = vec4(0.5,0.5,0,1);\n        }\n        // key 3 reset \n        if( keyPress(51) ) fragColor = vec4(0.5,0.5,0,1);\n        \n         if(iTime<=3.14){\n              if(0.7<0.9*smoothstep(1.0,0.0,length(fragCoord.xy-iResolution.xy*0.5+vec2(sin(iTime*2.0)*100.0, cos(iTime*2.0)*100.0 ))*0.026)){\n               \t  vec4 color = vec4(-sin(iTime*2.0), cos(iTime*2.0), 0, 0);\n                  color = color * 0.5 + 0.5;\n                  fragColor = vec4(color.x, color.y, 0, 1);\n              }\n          }  \n    }    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Shader From\n// FabriceNeyret2 \n// Single-pass gaussian blur - fast \n// https://www.shadertoy.com/view/ltScRG\n\n// Thanks very useful!!\n\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 4; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    const int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(mod(float(i),float(s)), i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * texture( sp, U + scale * d , -100. );\n    }\n    \n    return O / O.a;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = blur( iChannel1, U/iResolution.xy, 1./iChannelResolution[0].xy );\n}","name":"Buffer B","description":"","type":"buffer"}]}