{"ver":"0.1","info":{"id":"dtGXDc","date":"1686416886","viewed":344,"name":"PolySense","username":"marcelliino","description":"Audio Reactive Ray Marching Object","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","music","glass","metal","material","audioreactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//---- Math Constant ----//\n\nconst float\n    E = 2.7182818284,\n\tK = 2.6854520010,\n\tPI = 3.1415926536,\n\tTAU = 6.2831853072,\n\tPHI = 1.6180339887,\n\tSQRT075 = 0.8660254038,\n\tSQRT2 = 1.4142135623,\n\tSQRT3 = 1.7320508075;\n\n\n//---- Math Equation ----//\n\n#define nsin(n)(sin(n) * .5 + .5)\n#define ncos(n)(cos(n) * .5 + .5)\n#define ntan(n)(tan(n) * .5 + .5)\n#define rad(deg)(deg * PI / 180.)\n\n\n//---- Math Function ----//\n\nfloat ndot(vec2 a, vec2 b) {\n\treturn a.x * b.x - a.y * b.y;\n}\n\n// float mod(float a, float b){ return a - b * floor(a / b); }\n\nfloat loop(float n) {\n\treturn fract(n / TAU) * TAU;\n}\n\nvec2 ratio(vec2 n) {\n\treturn vec2(min(n.x, n.y) / max(n.x, n.y), 1.0);\n}\n\nvec2 scale(vec2 pos, vec2 scale) {\n\tscale = max(scale, vec2(1.0 / 1024.0));\n\treturn pos * mat2(1.0 / scale.x, 0.0, 0.0, 1.0 / scale.y);\n}\n\nvec2 scale(vec2 pos, vec2 scale, vec2 dimension) {\n\tscale = max(scale, vec2(1.0 / 1024.0));\n\tvec2 R = ratio(dimension);\n\tR = dimension.x > dimension.y ? R.xy : R.yx;\n\treturn pos / scale * R * 0.5 + 0.5;\n}\n\nfloat angle(vec2 origin, vec2 target) {\n\treturn atan(target.y - origin.y, target.x - origin.x);\n}\n\nvec2 rotate(vec2 p, float angle) {\n\treturn p * mat2(\n\t\tcos(angle), sin(angle),\n\t\t-sin(angle), cos(angle)\n\t);\n}\n\nvec2 rotate(vec2 p, vec2 origin, vec2 target) {\n\treturn rotate(p - origin, angle(origin, target));\n}\n\n\n//---- Random Number ----//\n\nfloat random21(vec2 n) {\n\tn = fract(n * vec2(278.91, 530.46));\n\tn += dot(n, n + (TAU * E));\n\treturn fract(n.x * n.y);\n}\n\nvec3 hash3(vec2 p) {\n\tvec3 q = vec3(dot(p, vec2(127.1, 311.7)),\n\t\tdot(p, vec2(269.5, 183.3)),\n\t\tdot(p, vec2(419.2, 371.9)));\n\treturn fract(sin(q) * 43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v) {\n\tfloat k = 1.0 + 63.0 * pow(1.0 - v, 6.0);\n\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 a = vec2(0.0, 0.0);\n\tfor (int y = -2; y <= 2; y++)\n\t\tfor (int x = -2; x <= 2; x++) {\n\t\t\tvec2 g = vec2(x, y);\n\t\t\tvec3 o = hash3(i + g) * vec3(u, u, 1.0);\n\t\t\tvec2 d = g - f + o.xy;\n\t\t\tfloat w = pow(1.0 - smoothstep(0.0, 1.414, length(d)), k);\n\t\t\ta += vec2(o.z * w, w);\n\t\t}\n\n\treturn a.x / a.y;\n}\n\n//---- 2D mapping ----//\n\nvec2 square2circle(vec2 p) {\n\treturn vec2(\n\t\tsqrt(2.0 + 2.0 * SQRT2 * p.x + p.x * p.x - p.y * p.y) / 2.0 - sqrt(2.0 - 2.0 * SQRT2 * p.x + p.x * p.x - p.y * p.y) / 2.0,\n\t\tsqrt(2.0 + 2.0 * SQRT2 * p.y - p.x * p.x + p.y * p.y) / 2.0 - sqrt(2.0 - 2.0 * SQRT2 * p.y - p.x * p.x + p.y * p.y) / 2.0\n\t);\n}\n\nvec2 circle2square(vec2 p) {\n\treturn vec2(\n\t\tp.x * sqrt(1.0 - 0.5 * p.y * p.y),\n\t\tp.y * sqrt(1.0 - 0.5 * p.x * p.x)\n\t);\n}\n\nvec2 cartesian2polar(vec2 p) {\n\tfloat angle = atan(p.y, p.x);\n\tfloat radius = length(p);\n\treturn vec2(angle, radius);\n}\n\n\n//---- 2D Render Tools ----//\n\nconst float sN = 512.0;\nfloat draw(float sdf) {\n\treturn smoothstep(1.0 / sN, -1.0 / sN, sdf);\n}\n\nvec3 draw(vec3 sdf) {\n\treturn smoothstep(1.0 / sN, -1.0 / sN, sdf);\n}\n\n\n//---- 2D SDF ----//\n\nfloat circle(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat vesica(vec2 p, float r) {\n\tr /= SQRT075;\n\treturn circle(abs(p) + vec2(r / 2.0, 0.0), r);\n}\n\nfloat vesica(vec2 p, vec2 a, vec2 b) {\n\tfloat r = distance(a, b) / 2.0 / SQRT075;\n\tp = rotate(p - mix(a, b, 0.5), angle(a, b));\n\treturn circle(abs(p) + vec2(0.0, r / 2.0), r);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w) {\n\tfloat\n\tt = clamp(dot(p - a, b - a) / dot(b - a, b - a), 0.0, 1.0),\n\t\td = length((p - a) - (b - a) * t);\n\treturn d - w;\n}\n\nfloat rect(vec2 p, vec2 s) {\n\tvec2 d = abs(p) - s;\n\treturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat rect(vec2 p, vec2 s, float r) {\n\tr *= min(s.x, s.y);\n\tvec2 d = abs(p) - s + r;\n\treturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n}\n\nfloat squircle(vec2 p, vec2 s, float r) {\n\treturn length(pow(abs(p / s), 1.0 / r / min(s.x, s.y) * s)) - 1.0;\n}\n\nfloat rhombus(vec2 p, vec2 s, float r) {\n\tp = abs(p);\n\tr = min(min(s.x, s.y) - 1.0 / 1024.0, min(s.x, s.y) * r);\n\ts -= r;\n\tfloat\n\th = clamp((-2.0 * ndot(p, s) + ndot(s, s)) / dot(s, s), -1.0, 1.0),\n\t\td = length(p - 0.5 * s * vec2(1.0 - h, 1.0 + h));\n\treturn d * sign(p.x * s.y + p.y * s.x - s.x * s.y) - r;\n}\n\nfloat poly(vec2 p, float ap, float n) {\n\tp = rotate(p, PI);\n\tap *= cos(PI / n);\n\tn = PI * 2.0 / n;\n\tfloat a = atan(p.x, p.y);\n\treturn cos(floor(0.5 + a / n) * n - a) * length(p) - ap;\n}\n\n//---- other 2D shapes ----//\n\nfloat wave(vec2 p, float f, float a) {\n\treturn p.y + cos(p.x * f) * a;\n}\n\nvec3 wave(vec2 p, vec3 f, vec3 a) {\n\treturn p.y + cos(p.x * f) * a;\n}\n\n//---- Color Formulas ----//\n\n#define uRGB(r, g, b) vec3(r, g, b) / 255.0\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4\n\tK = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0),\n\t\tp = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)),\n\t\tq = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\tfloat\n\td = q.x - min(q.w, q.y),\n\t\te = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n#define uHSV(h, s, v) vec3(h / 360.0, s / 100.0, b / 100.0)\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//---- Color Definitions ----//\n\n#define grey vec3(0.5)\n#define red vec3(1.0, 0.0, 0.0)\n#define green vec3(0.0, 1.0, 0.0)\n#define blue vec3(0.0, 0.0, 1.0)\n\n\n//---- Blend Modes ----//\n\nvec4 normal(vec4 a, vec4 b) {\n\treturn mix(a, b, b.a);\n}\nvec4 multiply(vec4 a, vec4 b) {\n\treturn vec4((a * b).rgb, b.a);\n}\nvec4 linearBurn(vec4 a, vec4 b) {\n\treturn vec4(((a + b) - 1.0).rgb, b.a);\n}\nvec4 colorBurn(vec4 a, vec4 b) {\n\treturn vec4((1.0 - (1.0 - a) / b).rgb, b.a);\n}\nvec4 darken(vec4 a, vec4 b) {\n\treturn vec4(min(a, b).rgb, b.a);\n}\nvec4 lighten(vec4 a, vec4 b) {\n\treturn vec4(max(a, b).rgb, b.a);\n}\nvec4 screen(vec4 a, vec4 b) {\n\treturn vec4((1.0 - (1.0 - a) * (1.0 - b)).rgb, b.a);\n}\nvec4 add(vec4 a, vec4 b) {\n\treturn vec4((a + b).rgb, b.a);\n}\nvec4 colorDodge(vec4 a, vec4 b) {\n\treturn vec4((a / (1.0 - b)).rgb, b.a);\n}\nvec4 overlay(vec4 a, vec4 b) {\n\tvec4 c = vec4(0.0);\n\tc.r = a.r < 0.5 ? multiply(a, 2.0 * b).r : screen(a, 2.0 * (b - 0.5)).r;\n\tc.g = a.g < 0.5 ? multiply(a, 2.0 * b).g : screen(a, 2.0 * (b - 0.5)).g;\n\tc.b = a.b < 0.5 ? multiply(a, 2.0 * b).b : screen(a, 2.0 * (b - 0.5)).b;\n\tc.a = b.a;\n\treturn normal(a, c);\n}\nvec4 hardLight(vec4 a, vec4 b) {\n\tvec4 c = vec4(0.0);\n\tc.r = b.r < 0.5 ? multiply(a, 2.0 * b).r : screen(a, 2.0 * (b - 0.5)).r;\n\tc.g = b.g < 0.5 ? multiply(a, 2.0 * b).g : screen(a, 2.0 * (b - 0.5)).g;\n\tc.b = b.b < 0.5 ? multiply(a, 2.0 * b).b : screen(a, 2.0 * (b - 0.5)).b;\n\tc.a = b.a;\n\treturn normal(a, c);\n}\n\nvec4 softLight(vec4 a, vec4 b) {\n\treturn normal(a, vec4(((1.0 - 2.0 * b) * a * a + 2.0 * b * a).rgb, b.a));\n}\nvec4 vividLight(vec4 a, vec4 b) {\n\tvec4 c = vec4(0.0);\n\tc.r = b.r < 0.5 ? colorBurn(a, 2.0 * b).r : colorDodge(a, 2.0 * (b - 0.5)).r;\n\tc.g = b.g < 0.5 ? colorBurn(a, 2.0 * b).g : colorDodge(a, 2.0 * (b - 0.5)).g;\n\tc.b = b.b < 0.5 ? colorBurn(a, 2.0 * b).b : colorDodge(a, 2.0 * (b - 0.5)).b;\n\tc.a = b.a;\n\treturn normal(a, c);\n}\nvec4 linearLight(vec4 a, vec4 b) {\n\tvec4 c = vec4(0.0);\n\tc.r = b.r < 0.5 ? linearBurn(a, 2.0 * b).r : add(a, 2.0 * (b - 0.5)).r;\n\tc.g = b.g < 0.5 ? linearBurn(a, 2.0 * b).g : add(a, 2.0 * (b - 0.5)).g;\n\tc.b = b.b < 0.5 ? linearBurn(a, 2.0 * b).b : add(a, 2.0 * (b - 0.5)).b;\n\tc.a = b.a;\n\treturn c;\n}\nvec4 pinLight(vec4 a, vec4 b) {\n\tvec4 c = vec4(0.0);\n\tc.r = b.r < 0.5 ? darken(a, 2.0 * b).r : lighten(a, 2.0 * (b - 0.5)).r;\n\tc.g = b.g < 0.5 ? darken(a, 2.0 * b).g : lighten(a, 2.0 * (b - 0.5)).g;\n\tc.b = b.b < 0.5 ? darken(a, 2.0 * b).b : lighten(a, 2.0 * (b - 0.5)).b;\n\tc.a = b.a;\n\treturn normal(a, c);\n}\nvec4 hardMix(vec4 a, vec4 b) {\n\treturn normal(a, vec4(ceil(linearLight(a, b)).rgb, b.a));\n}\nvec4 exclusion(vec4 a, vec4 b) {\n\treturn normal(a, vec4(max(a + b - 2.0 * a * b, b.a).rgb, b.a));\n}\nvec4 difference(vec4 a, vec4 b) {\n\treturn normal(a, vec4(max(abs(a - b), b.a).rgb, b.a));\n}\nvec4 subtract(vec4 a, vec4 b) {\n\treturn normal(a, vec4(((a + max(1.0 - b, b.a)) - 1.0).rgb, b.a));\n}\nvec4 vivid(vec4 a, vec4 b) {\n\treturn normal(a, vec4((a / b).rgb, b.a));\n}\n\n#define multiply(a, b) normal(a, multiply(a, b))\n#define linearBurn(a, b) normal(a, linearBurn(a, b))\n#define colorBurn(a, b) normal(a, colorBurn(a, b))\n#define darken(a, b) normal(a, darken(a, b))\n#define lighten(a, b) normal(a, lighten(a, b))\n#define screen(a, b) normal(a, screen(a, b))\n#define add(a, b) normal(a, add(a, b))\n#define colorDodge(a, b) normal(a, colorDodge(a, b))\n#define linearLight(a, b) normal(a, linearLight(a, b))\n\n\n//--------//\n\nconst int MAX_STEPS = 256;\nconst float MAX_DIST = 512.0;\nconst float SURF_DIST = 1.0 / 64.0;\n\nconst float pdn = 1.0 / 16.0;\n\n\n//---- Math Functions ----//\n\nvec3 rotate(vec3 p, vec3 a) {\n\n\tvec3 c = cos(a), s = sin(a);\n\n\tp *= mat3(\n\t\tvec3(1.0, 0.0, 0.0),\n\t\tvec3(0.0, c.x, -s.x),\n\t\tvec3(0.0, s.x, c.x)\n\t) * mat3(\n\t\tvec3(c.y, 0.0, s.y),\n\t\tvec3(0.0, 1.0, 0.0),\n\t\tvec3(-s.y, 0.0, c.y)\n\t) * mat3(\n\t\tvec3(c.z, -s.z, 0.0),\n\t\tvec3(s.z, c.z, 0.0),\n\t\tvec3(0.0, 0.0, 1.0)\n\t);\n\n\treturn p;\n}\n\nvec4 suni(vec4 d1, vec4 d2, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (d2.a - d1.a) / k, 0.0, 1.0);\n\treturn mix(d2, d1, h) - vec2(0.0, k * h * (1.0 - h)).xxxy;\n}\n\nvec4 ssub(vec4 d1, vec4 d2, float k) {\n\tfloat h = clamp(0.5 - 0.5 * (d1.a + d2.a) / k, 0.0, 1.0);\n\treturn mix(d1, vec4(d2.rgb, -d2.a), h) + vec2(0.0, k * h * (1.0 - h)).xxxy;\n}\n\nvec4 sint(vec4 d1, vec4 d2, float k) {\n\tfloat h = clamp(0.5 - 0.5 * (d2.a - d1.a) / k, 0.0, 1.0);\n\treturn mix(d2, d1, h) + vec2(0.0, k * h * (1.0 - h)).xxxy;\n}\n\nfloat extrude(vec3 p, float sdf2d, float h) {\n\tfloat d = sdf2d;\n\tvec2 w = vec2(d, abs(p.z) - h);\n\treturn min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n\n//---- 3D SDF ----//\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat capsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0.0, h);\n\treturn length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s) {\n\tp = abs(p) - s;\n\treturn length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat boxFrame(vec3 p, vec3 b, float e) {\n\tp = abs(p) - b;\n\tvec3 q = abs(p + e) - e;\n\treturn min(min(\n\t\t\tlength(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n\t\t\tlength(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n\t\tlength(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nfloat torus(vec3 p, vec2 r) {\n\tvec2 q = vec2(length(p.xz) - r.x, p.y);\n\treturn length(q) - r.y;\n}\n\nfloat cone(vec3 p, vec2 c, float h) {\n\tvec2\n\tq = h * vec2(c.x / c.y, -1.0),\n\t\tw = vec2(length(p.xz), p.y),\n\t\ta = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0),\n\t\tb = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n\tfloat\n\tk = sign(q.y),\n\t\td = min(dot(a, a), dot(b, b)),\n\t\ts = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n\treturn sqrt(d) * sign(s);\n}\n\nfloat octahedron(vec3 p, float s) {\n\tp = abs(p);\n\tfloat m = p.x + p.y + p.z - s;\n\tvec3 q;\n\tif (3.0 * p.x < m) q = p.xyz;\n\telse if (3.0 * p.y < m) q = p.yzx;\n\telse if (3.0 * p.z < m) q = p.zxy;\n\telse return m * 0.57735027;\n\n\tfloat k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n\treturn length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\n\n//---- 3D Render Tools ----//\n\nvec2 edge(vec2 p) {\n\tvec2 p2 = abs(p);\n\tif (p2.x > p2.y) return vec2(p.x < 0.0 ? -1.0 : 1.0, 0.0);\n\telse return vec2(0.0, p.y < 0.0 ? -1.0 : 1.0);\n}\n\nvec3 material(vec3 c, int m) {\n\tvec2 id = vec2(-1.0, 1.0);\n\tc += pdn;\n\tc *= (m == 0 ? id.xxx : m == 1 ? id.xyy : m == 2 ? id.yxy : m == 3 ? id.yyx : vec3(1.0));\n\treturn c;\n}\n\n\n//---- Ray Marcher ----//\n\nvec4 getDist(vec3 p);\n\nvec4 rayMarch(vec3 ro, vec3 rd, float side) {\n\tvec4 dO = vec4(0.0);\n\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tif (dO.a > MAX_DIST) break;\n\t\tvec3 p = ro + rd * dO.a;\n\t\tvec4 dS = getDist(p) * side;\n\t\tif (dS.a < SURF_DIST) break;\n\t\tdO += dS;\n\t}\n\n\treturn dO;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).a;\n\tvec2 e = vec2(0.001, 0.0);\n\n\tvec3 n = d - vec3(\n\t\tgetDist(p - e.xyy).a,\n\t\tgetDist(p - e.yxy).a,\n\t\tgetDist(p - e.yyx).a\n\t);\n\n\treturn normalize(n);\n}\n\nvec4 getLight(vec3 p, vec3 n, vec3 lp, vec3 lc) {\n\tvec3 l = normalize(lp - p);\n\n\tvec4\n\tdif = vec4(clamp(dot(n, l), 0.0, 1.0)),\n\t\td = rayMarch(p + n * SURF_DIST / 0.5, l, 1.0);\n\n\tif (d.a < length(lp - p)) {\n\n\t\tif (d.x > 0.0 && d.y > 0.0 && d.z < 0.0) {\n\t\t\t//experimental\n\t\t}\n\n\t\tdif.a /= 2.0;\n\t}\n\n\treturn vec4(lc, 1.0) * smoothstep(-0.5, 1.5, dif);\n}\n\n\n//---- 3D Projections ----//\n\nfloat map(float v, float low1, float high1, float low2, float high2) {\n\treturn (v - low1) / (high1 - low1) * (high2 - low2);\n}\n\nvec2 cubemap(vec3 p) {\n\tvec3\n\tb = abs(p),\n\t\tv = (b.x > b.y && b.x > b.z) ? p.xyz :\n\t\t(b.y > b.x && b.y > b.z) ? p.yzx :\n\t\tp.zxy;\n\tvec2 q = v.yx / v.x;\n\tq *= 1.25 - 0.25 * q * q;\n\treturn q;\n}\n\nvec2 equimap(vec3 p) {\n\tp = normalize(p);\n\treturn\n\tvec2(\n\t\tmap(atan(p.x, -p.z), 0.0, PI, 0.0, 1.0),\n\t\tmap(asin(p.y), 0.0, -PI / 2.0, 0.0, 1.0)\n\t);\n}\n\nvec3 equiunwrap(vec2 p) {\n\tfloat\n\tlon = map(p.x, 0.0, 1.0, -PI, PI),\n\t\tlat = map(p.y, 0.0, 1.0, -PI / 2.0, PI / 2.0),\n\t\tx = sin(lat) * sin(lon),\n\t\ty = cos(lat),\n\t\tz = sin(lat) * cos(lon);\n\treturn vec3(x, -y, z);\n}\n\n\n//---- 3D renderer ----//\n\nvec4 render(\n\tinout vec3 ro, inout vec3 rd,\n\tvec3 lp, vec3 lc,\n\tinout float mr, float IOR,\n\tbool last\n);\n\n\n//---- input value ----//\n\nfloat spectrumValue(int value) {\n\tfloat x = mod(float(value), 8.0);\n\tfloat y = float(value) / 8.0;\n\treturn texture(iChannel1, vec2(x, y) / 8.0).x;\n}\n\n//----//\n\n#define reso iResolution\n#define mous iMouse\n#define time iTime\n#define spec spc\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2\n        st = fragCoord.xy / reso.xy,\n\t\tuv = (fragCoord.xy - reso.xy / 2.0) / 0.5 / (reso.x < reso.y ? reso.x : reso.y),\n\t\tmo = (mous.xy - reso.xy / 2.0) / 0.5 / (reso.x < reso.y ? reso.x : reso.y);\n\n\tvec4 col = vec4(1.0);\n\n\t//col = vec4(mod(length(uv) / 0.25 - time, 1.0));\n\n\t// 3D setups //\n\n\tvec3\n\tro = vec3(0.0, -8.0, 0.0).xzy,\n\t\tlp = vec3(0.0, -8.0, 32.0).xzy,\n\t\tlc = vec3(1.0);\n\n\tfloat\n\tmode = 0.0,\n\t\tstereoscopic = 0.0,\n\t\teyeDistance = stereoscopic / 2.0;\n\n\tvec2 UV = uv;\n\n\tfloat glitch = smoothstep(0.8, 1.0, fract(voronoise(rotate(uv / 0.25 - vec2(cos(time / 2.0), sin(time)) / 0.25, sin(time / 4.0)), 1.0, 0.625) - time));\n\tfloat sv = spectrumValue(0);\n\tsv = sv * sv * sv * sv;\n\tuv = mix(uv, uv / 0.5, glitch * smoothstep(0.625, 1.0, sv));\n\n\tuv.x = mix(uv.x, mod(uv.x, 2.0) - 1.0, stereoscopic * (1.0 - mode));\n\tuv.y = mix(uv.y, mod(uv.y, 1.0) - 0.5, stereoscopic * mode);\n\n\tro.x += eyeDistance * (mix(UV.x, UV.y, mode) < 0.0 ? -1.0 : 1.0);\n\n\tfloat zoom = 1.25;\n\n\tvec3 rd = mix(\n\t\tnormalize(vec3(uv.xy, zoom)),\n\t\trotate(normalize(equiunwrap(scale(uv, vec2(1.0), reso.xy)) * vec2(1.0, zoom).xxy), vec3(0.0, PI, 0.0)),\n\t\t0.0\n\t);\n\n\tvec3 M = vec3(\n\t\t0.0,\n\t\t0.0,\n\t\t0.0\n\t);\n\n\tvec3 R = vec3(\n\t\tcos(fract(time / TAU / 6.25) * TAU) / 1.25,\n\t\tfract(time / TAU / 8.0) * TAU,\n\t\t0.0\n\t);\n\n\tro -= M;\n\tro = rotate(ro, R);\n\trd = rotate(rd, R);\n\n\tro -= vec3(sin(fract(time / 16.0) * TAU) / 4.0, -cos(fract(time / 8.0) * TAU) / 32.0, cos(fract(time / 2.0) * TAU) / 8.0);\n\trd = rotate(rd, vec3(0.0, 0.0, sin(fract(time / 12.0) * TAU) / 48.0));\n\n\t// 3D render //\n\n\tfloat DOP = rayMarch(ro, rd, 1.0).a;\n\n\tfloat\n\tmr = 0.0,\n\t\tmx = 1.0;\n\n\tfloat IOR = 1.45;\n\n\tvec4 canvas = render(ro, rd, lp, lc, mr, IOR, false);\n\n\tconst int NUM_BOUNCES = 2;\n\n\tfor (int i = NUM_BOUNCES; i > 0; i--) {\n\t\tmx *= mr;\n\t\tvec4 bounce = mx * render(ro, rd, lp, lc, mr, IOR, (i == 1));\n\n\t\tcanvas.rgb = normal(canvas, bounce).rgb;\n\t}\n\n\tcol.rgb = normal(col, canvas).rgb;\n\n\tsv = spectrumValue(5);\n\tsv = sv * sv * sv * sv;\n\tsv = floor(sv / 0.25) / 4.0;\n\n\tvec3 inv = 1.0 - hsv2rgb(rgb2hsv(col.rgb) + vec2(0.5, 0.0).xyy);\n\tif (sv >= 0.32) col.rgb = inv * inv;\n\n\tvec3 sv3 = vec3(spectrumValue(8), spectrumValue(10), spectrumValue(12));\n\tsv3 = sv3 * sv3 * sv3 * sv3;\n\tvec3 wv = draw(abs(wave(floor((UV - vec2(time / 0.125, 0.0)) / 0.03125) / 32.0, vec3(1.0, 2.0, 0.5), sv3)) - sv3 / 4.0);\n\twv = hsv2rgb(rgb2hsv(wv) * vec2(0.0, 1.0).yxy);\n\tcol.rgb = mix(col.rgb, 1.0 - col.rgb, wv * smoothstep(8.0, 16.0, DOP) * length(sv3));\n\n\tcol.rgb = mix(col.rgb, vec3(1.0 - length(col.rgb)), ntan(time) * draw(max(-poly(rotate(UV, PI / 2.0), 0.8, 6.0), sin(poly(rotate(UV, PI / 2.0) / 0.25, 1.0, 6.0) * TAU - time / 0.25))));\n\n\tcol = softLight(col, vec4(vec3(smoothstep(24.0, 0.0, DOP)), 1.0));\n\t\n\tcol.a = 1.0;\n\tfragColor = vec4(col.rgb, 1.0);\n}\n\nvec4 getDist(vec3 p) {\n\n\tvec4 space = vec4(material(vec3(1.0), 0), abs(sphere(p, 256.0)));\n\n\tfloat sv = smoothstep(0.0, 1.0, spectrumValue(8));\n\tsv = sin(sv * sv * sv * sv);\n\n\tvec3 q = rotate(p - vec2(sv, 0.0).yxy, fract(vec3(0.8, 1.25, -0.625) * time / TAU / 2.0) * TAU);\n\n\tsv = spectrumValue(6);\n\tsv = sv * sv * sv;\n\n\tvec3 c = vec3(0.8, 0.8, 1.0);\n\n\tvec4 o;\n\to.rgb = material(hsv2rgb(c), 3);\n\to.a = abs(sphere(q, 2.0 + sv)) - 0.16;\n\n\tspace = suni(space, o, 0.0);\n\n\to.rgb = material(hsv2rgb(c - vec2(0.25, 0.0).xyy), 3);\n\to.a = sphere(abs(q) - 1.25 - sv, 0.8 + sv / 1.25);\n\n\tspace = ssub(space, o, 0.64);\n\n\to.rgb = material(hsv2rgb(vec3(0.0625, 0.8, 1.0)), 2);\n\to.a = sphere(q, 0.8);\n\n\tspace = suni(space, o, 0.0);\n\n\tsv = spectrumValue(7);\n\tsv = sv * sv;\n\n\to.rgb = material(hsv2rgb(vec3(0.0625, 0.8, 1.0)), 4);\n\to.a = sphere(abs(q) - 1.25 + sv * 0.64, 0.32);\n\n\tspace = suni(space, o, 0.0);\n\t\n\tvec3 sv3 = vec3(spectrumValue(18), spectrumValue(20), spectrumValue(22));\n\tsv3 = sv3 * sv3;\n\tsv3 = smoothstep(0.0, 0.5, sv3);\n\t\n\to.rgb = material(vec3(0.32, 0.125, 1.0), 1);\n\to.a = boxFrame(rotate(p, vec2(cos(fract(time / TAU / 10.0) * TAU) * PI, 0.0).yyx), 8.0 + sv3, 0.25) - 0.25;\n\n\tspace = suni(space, o, 0.0);\n\n\treturn space;\n}\n\nvec4 render(\n\tinout vec3 ro, inout vec3 rd,\n\tvec3 lp, vec3 lc,\n\tinout float mr, float IOR,\n\tbool last\n) {\n\tvec4 canvas = vec4(0.0);\n\n\tvec4 d = rayMarch(ro, rd, 1.0);\n\n\tmr = 0.0;\n\n\tif (d.a < MAX_DIST) {\n\t\tvec3\n\t\tp = ro + rd * d.a,\n\n\t\t\tn = getNormal(p),\n\n\t\t\trfl = reflect(rd, n);\n\n\t\tvec4\n\t\tdif = max(\n\t\t\t\tgetLight(p, n, lp, lc),\n\t\t\t\t0.3\n\t\t\t),\n\t\t\tc = getDist(p);\n\t\tc.a = step(0.0, c.a);\n\n\t\tcanvas.a = c.a;\n\n\t\tvec3 bga = vec3(0.0, PI / 2.0 - cos(fract(time / TAU) * TAU) * PI / 64.0, 0.0);\n\n\t\t// default texture\n\t\tcanvas.rgb = linearLight(vec4(dif.a), c).rgb;\n\t\tmr = 0.03125;\n\n\t\tconst int k = 1; // 0 for cubemap, 1 for equirectangular\n\n\t\tvec3 envMap = rotate(p, bga);\n\t\tvec4 envTex = texture(iChannel0, envMap);\n\n\t\t// background environment texture\n\t\tif (c.x < 0.0 && c.y < 0.0 && c.z < 0.0) {\n\t\t\tc = -c;\n\t\t\tcanvas.rgb = lc * multiply(c, envTex).rgb;\n\t\t\tmr = 0.0;\n\t\t\tdif = vec4(1.0);\n\t\t}\n\n\t\tfloat\n\t\tfl = clamp(1.0 + dot(rd, n), 0.0, 1.0),\n\t\t\tfresnel = fl * fl * fl * fl;\n\n\t\t// rough texture\n\t\tif (c.x < 0.0 && c.y > 0.0 && c.z > 0.0) {\n\t\t\tc.x = -c.x;\n\t\t\tcanvas.rgb = overlay(vec4(dif.a), c).rgb;\n\t\t\tmr = mix(0.03125, 0.25, fresnel);\n\t\t}\n\n\t\tenvMap = rfl;\n\n\t\tvec4 metal = vec4(dif.a);\n\t\tif (last) metal.rgb = texture(iChannel0, envMap).rgb;\n\n\t\t// metalic texture\n\t\tif (c.x > 0.0 && c.y < 0.0 && c.z > 0.0) {\n\t\t\tc.y = -c.y;\n\t\t\tcanvas.rgb = colorBurn(metal, overlay(c, metal)).rgb;\n\t\t\tmr = 0.84;\n\t\t\tro = p + n * SURF_DIST / 0.25;\n\t\t\trd = rfl;\n\t\t}\n\n\t\tvec4 trans = vec4(dif.a);\n\t\tvec3\n\t\trdIn = refract(rd, n, 1.0 / IOR),\n\t\t\tpEnter = p - n * SURF_DIST / 0.25,\n\t\t\tdIn = vec3(rayMarch(pEnter, rdIn, -1.0).a),\n\t\t\tpExit = pEnter + rdIn * dIn,\n\t\t\tnExit = -getNormal(pExit),\n\t\t\trdOut = refract(rdIn, nExit, IOR),\n\t\t\toptDist = exp(-dIn / 16.0);\n\t\tif (dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n\n\t\tenvMap = rdOut;\n\n\t\tif (last) trans = texture(iChannel0, envMap);\n\n\t\t// translucent texture\n\t\tif (c.x > 0.0 && c.y > 0.0 && c.z < 0.0) {\n\t\t\tc.z = -c.z;\n\t\t\tcanvas.rgb = softLight(trans, colorBurn(trans, c)).rgb;\n\t\t\tcanvas.rgb *= optDist;\n\t\t\tmr = mix(0.93, 0.63, fresnel);\n\t\t\tro = pExit - nExit * SURF_DIST / 0.25;\n\t\t\trd = rdOut;\n\t\t}\n\n\t\tcanvas.rgb -= vec3(pdn);\n\t\tcanvas.rgb *= lc;\n\t}\n\n\treturn canvas;\n}","name":"Image","description":"","type":"image"}]}