{"ver":"0.1","info":{"id":"4sy3Wt","date":"1456946469","viewed":585,"name":"Fuzzy Reflections","username":"Marrrk","description":"Test for fuzzy/glossy reflections. Mouse X coordinate terminates the glossiness (click into view).","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["reflection","blur","fuzzy","glossy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R 1.0\n#define max_distance 10.0\n#define epsilon 0.01\n#define max_steps 100\n#define K 0.37\n#define PI 3.141\n#define detailStepLength 0.1\n\n// increase this for more blur steps\n#define fuzzynessSteps 10\n\nvec3 ambientLightColor = vec3(0.5, 0.5, 0.5);\nvec3 lightPos = vec3(0.0, 0.0, -3.0);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\nstruct traceInfo\n{\n    vec3 color;\n\tvec3 pos;\n\tvec3 dir;\n    int level;\n    float objIndex;\n};\n    \nstruct objectInfo\n{\n    vec3 albedo;\n    vec3 emission;\n    float reflectivity;\n    float fuzzyness;\n    float fresnelBias;\n};\n\nobjectInfo objects[2];\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat getObject0Distance(vec3 pos)\n{\n    return box(pos + vec3(0,1,0), vec3(4.0, 0.1, 4.0));\n}\n\nfloat getObject1Distance(vec3 pos)\n{\n    float sphereDistance = sphere(pos + vec3(0.0, sin(iTime) - 1.0, 0.0), 1.0);\n    float boxDistance = box(pos + vec3(4.0, -1.0, 0.0), vec3(0.5, 2.0, 0.5));\n    return min(boxDistance, sphereDistance);\n}\n\nfloat getObjectDistance(vec3 pos, float index)\n{\n    if (index == 1.0)\n        return getObject1Distance(pos);\n    else\n        return getObject0Distance(pos);\n}\n\nvec2 getNearestObjectDistanceData(vec3 pos)\n{\n    vec2 nearest = vec2(getObject0Distance(pos), 0);\n\tfloat nearest1 = getObject1Distance(pos);\n\t\n\tif (nearest1 < nearest.x)\n\t\tnearest = vec2(nearest1, 1.0);\n   \n    return nearest;\n}\n\nvec3 getNormal(vec3 point, float index)\n{\n\tfloat d0 = getObjectDistance(point, index);\n\tfloat dX = getObjectDistance(point - vec3(epsilon, 0.0, 0.0), index);\n\tfloat dY = getObjectDistance(point - vec3(0.0, epsilon, 0.0), index);\n\tfloat dZ = getObjectDistance(point - vec3(0.0, 0.0, epsilon), index);\n\tvec3 baseNormal = normalize(vec3(dX-d0, dY-d0, dZ-d0));\n    if (index == 0.0)\n    {\n        baseNormal = normalize(baseNormal + 0.1 * (texture(iChannel1, point.xz).rgb * 2.0 - 1.0));\n    }\n    return baseNormal;\n}\n\nobjectInfo getObjectInfo(float index)\n{\n    if (index == 1.0)\n        return objects[1];\n    return objects[0];\n}\n\nvec3 getLight(traceInfo info)\n{\n    vec3 point_normal = getNormal(info.pos, info.objIndex);\n    vec3 light_dir = -normalize(lightPos - info.pos);\n    \n    float attenuation = 1.0 / (1.0 + K*pow( length(lightPos - info.pos), 2.0));\n    vec3 reflected_light_dir = reflect(-light_dir, point_normal);\n\n    float dotp_diffuse = attenuation * max(0.25, dot(light_dir, point_normal));\n    vec3 color = vec3(dotp_diffuse);\n    color = smoothstep(vec3(0.0), vec3(1.0), color);\n    color = pow(color, vec3(1.0/2.2));\n    color *= lightColor;\n    return color + ambientLightColor;\n\n}\n\nvec3 getColor(traceInfo info)\n{\n    objectInfo object = getObjectInfo(info.objIndex);\n    if (info.objIndex == 0.0)\n        return texture(iChannel1, info.pos.xz).rgb * object.albedo * getLight(info) + object.emission;\n    return object.albedo * getLight(info) + object.emission;\n}\n\ntraceInfo nextTraceInfo(traceInfo info)\n{\n    traceInfo next = info;\n    next.level ++;\n    next.pos -= info.dir * epsilon;\n    next.color = vec3(0.0, 0.0, 0.0);\n    return next;\n}\n\nbool trace(inout traceInfo info)\n{   \n    info.color = texture(iChannel0, vec3(info.dir.x, -info.dir.y, info.dir.z)).rgb;\n    \n\tfloat d = 0.0;\n\tbool success = false;\n\tfor (int i = 0; i < max_steps; i++) {\n\t\t\n        vec2 objData = getNearestObjectDistanceData(info.pos);\n\t\tif(objData.x < epsilon && info.objIndex != objData.y)\n        {\n            info.objIndex = objData.y;\n\t\t\tsuccess = true;\n            break;\n        }\n\t\tinfo.pos += info.dir * objData.x;\n\t\td += objData.x;\n\t\tif (d > max_distance)\n        {\n\t\t\tbreak;\n        }\n\t}\n\tif (!success)\n\t\tinfo.objIndex = -1.0;\n\telse\n\t\tinfo.color = getColor(info);\n\n\treturn success;\n}\n\ntraceInfo init(vec2 fragCoord)\n{    \n    /*\n\t*********************************\n\t** EDIT OBJECT PROPERTIES HERE **\n\t*********************************\n\t*/\n    objects[0] = objectInfo(vec3(0.5, 0.5, 0.5), vec3(0.0, 0.0, 0.0), 1.0 /*reflectivity*/, 0.5 /*fuzziness*/, 0.0 /*fresnelBias*/);\n    objects[1] = objectInfo(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.1, 0.0), 0.0 /*reflectivity*/, 0.0 /*fuzziness*/, 0.0 /*fresnelBias*/);\n    \n\ttraceInfo info;\n    info.objIndex = -1.0;\n    \n    vec2 mouse = vec2(iTime * 0.1, 3.0);\n    info.pos = vec3(sin(mouse.x), 0, cos(mouse.x)) * 1.0 * (mouse.y);\n    vec3 forward = normalize(vec3(0, -2.0, 0) - info.pos);\n    \n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 right = cross(up, forward);\n    up = cross(forward, right);\n    \n    vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n    info.dir = normalize(up * uv.y + right *uv.x + forward);\n\n\treturn info;\n}\n\nvec3 rotateAround(vec3 v, vec3 k, float theta)\n{\n  return v * cos(theta) + cross(k, v) * sin(theta) + k * dot(k, v) * (1.0 - cos(theta));\n}\n\nvec3 marchScene(traceInfo info, vec2 fragCoord)\n{\n    // Draw terminator\n    if (iMouse.x > fragCoord.x && iMouse.x - 5.0 < fragCoord.x)\n        return vec3(1.0, 1.0, 1.0);\n    \n    // Scan scene\n    vec3 startPos = info.pos;\n    vec3 eyeForward = info.dir;\n    \n    if (trace(info))\n    {\n        objectInfo object = getObjectInfo(info.objIndex);\n        if (object.reflectivity > 0.0)\n        {\n            float distanceToOrigin = distance(startPos, info.pos);\n            \n            vec3 normal = getNormal(info.pos, info.objIndex);\n            float fresnelTerm = clamp(0.0, 1.0, object.fresnelBias + 1.0 - dot(eyeForward, normal));\n            \n            vec3 reflectionColor;\n            float rayInfluence = 1.0 / float(fuzzynessSteps);\n            \n            float fuzzyness = object.fuzzyness / (pow(distanceToOrigin, 4.0));\n            if (iMouse.x > fragCoord.x)\n                fuzzyness = 0.0;\n            vec3 baseRayDir = reflect(info.dir, normal);\n            for (int i = 0; i < fuzzynessSteps; ++i)\n            {\n                float percentage = float(i) / float(fuzzynessSteps);\n\n                traceInfo subRay = nextTraceInfo(info);\n                \n                vec3 delta = rotateAround(vec3(0.0, 1.0, 0), baseRayDir, PI * 2.0 * percentage);\n                subRay.dir = normalize(delta * fuzzyness + baseRayDir);\n\t\t\t\t\n                trace(subRay);\n\n                reflectionColor += subRay.color * rayInfluence;\n            }\n           \n            float reflectivity = mix(0.0, object.reflectivity, fresnelTerm);\n            info.color = mix(info.color, reflectionColor, reflectivity);\n        }\n    }\n    return info.color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttraceInfo info = init(fragCoord);   \n    fragColor.rgb = marchScene(info, fragCoord);\n}\n","name":"Image","description":"","type":"image"}]}