{"ver":"0.1","info":{"id":"4tBBDm","date":"1528906347","viewed":158,"name":"RC terrain1","username":"vchizhov","description":"Something I did as a prototype for a rendering competition. Pretty much all lighting effects are fake.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","terrain","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n*`\tHashing function - produces noise\n*\n*\tThe idea is: float rnd = fract(bigseed*sin(smallerseed*x));\n*\tSmall changes in x produce big changes in the result,\n*\tsnce we are taking the fractional part we get big jumps in the result\n*\twhich looks kinda like noise\n*\tThe idea behind it is similar to a linear congruential generator:\n*\tXn+1 = (a*Xn+c) mod m\n*\tWe can rewrite our hash as: c = 0, Xn+1 = ((a*sin(b*Xn)) mod m)/m\n*\t\n*\t@param n:\tSome value (can be a coordinate or whatever)\n*\t@return:\tPseudo-random number in [0,1)\n*\n*/\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// rotation matrix for the fractal brownian motion\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n// inverse (in this case transpose) of the rotation matrix\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\n\n/*\n*\tValue noise with analytical derivative\n*\n*\tOriginally from: https://iquilezles.org/articles/morenoise\n*\tThe quintic interpolation was proposed by Ken Perlin in: https://mrl.nyu.edu/~perlin/paper445.pdf\n*\tAdditional info:\n*\thttps://thebookofshaders.com/11/\n*\thttps://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1\n*\tFor perlin noise, see:\n*\thttps://iquilezles.org/articles/gradientnoise\n*\n*\t@param x:\tSome point in 3d space\n*\t@return:\tThe first component has the value of the noise at location x,\n*\t\t\t\tthe last 3 are used to store the gradient\n*/\nvec4 noised( in vec3 x )\n{\n    // grid: take the whole part of x for grid point\n    // take the fractional part for interpolation\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    // derivative of the quintic polynomial\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    // build a seed from the coordinates\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    // compute the values for the noise at the 8 vertices of the noise grid\n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    // interpolation coefficients\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    // vec4.x = value, vec4.yzw = gradient (non-normalized normal)\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n/*\n*\n*\tFractal brownian motion\n*\n*\tUsed to create terrain structures from smoothed noise (value/perlin/vornoi/simplex)\n*\n*\tOriginally from here: https://iquilezles.org/articles/morenoise\n*\tMore info on fbm: https://thebookofshaders.com/13/\n*\t\n*\t@param x: \tSome point in 3d space at which we want to evaluate the terrain\n*\t@return:\tA 4d vector with first component the value, and last 3 components the gradient\n*/\n// this should be called fbmd_7 actually since I use only 7 octaves\nvec4 fbmd_8( in vec3 x )\n{\n    // starting frequency\n    float f = 1.92;\n    // amplitude attenutation factor\n    float s = 0.5;\n    // accumulate the noise values here\n    float a = 0.0;\n    // starting amplitude\n    float b = 0.5;\n    // accumulate the derivatives here\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\t\t\t\t // attenuate amplitude\n        x = f*m3*x;\t\t\t // increase frequency and rotate the kernel to reduce axial bias\n        m = f*m3i*m;\t\t // used for the derivative\n    }\n    // first component has the value of the fbm, last 3 have the gradient\n\treturn vec4( a, d );\n}\n\n// same thing as the hash above, this time without sin and has 2 coordinates\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n// 2d value noise (billinear interpolation)\nfloat valueNoise(vec2 p)\n{\n    // whole part\n    vec2 w = floor(p);\n    // fractional part\n    vec2 f = fract(p);\n    // quintic smoothstep - smoother(1st and 2nd order derivatives = 0 at x=0,x=1)\n    // suggested by Ken Perlin: https://en.wikipedia.org/wiki/Smoothstep\n    vec2 u = f*f*f*(f*(f*6.0f - 15.0f) + 10.0f);\n\t\n    // value noise grid vertices\n    float a = hash1(w);\n    float b = hash1(w+vec2(1.0f, 0.0f));\n    float c = hash1(w+vec2(0.0f, 1.0f));\n    float d = hash1(w+vec2(1.0f, 1.0f));\n\n    // perform bilinear interpolation\n    float bilinear = a + (b - a)*u.x + (c - a)*u.y + (a - b - c + d)*u.x*u.y;\n    return bilinear;\n}\n\n// 2d value noise with derivatives - just applying the chain rule to get the x and y partial derivatives\nvec3 valueNoiseD(vec2 p)\n{\n\t// whole part\n    vec2 w = floor(p);\n    // fractional part\n    vec2 f = fract(p);\n    // quintic smoothstep - smoother(0 1st and 2nd order derivatives at x=0,x=1)\n    // suggested by Ken Perlin: https://en.wikipedia.org/wiki/Smoothstep\n    vec2 u = f*f*f*(f*(f*6.0f - 15.0f) + 10.0f);\n\n    float a = hash1(w);\n    float b = hash1(w+vec2(1.0f, 0.0f));\n    float c = hash1(w+vec2(0.0f, 1.0f));\n    float d = hash1(w+vec2(1.0f, 1.0f));\n\tfloat k0 = a;\n\tfloat k1 = b-a;\n\tfloat k2 = c-a;\n\tfloat k3 = a-b-c+d;\n    // perform bilinear interpolation\n    float bilinear = k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n\tvec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n\tvec2 bilinearD = vec2((k1 + k3*u.y)*du.x, (k2+k3*u.x)*du.y);\n    return vec3(bilinear,bilinearD);\n}\n\n\n// more fbm\nconst int fbm_octaves = 4;\nconst float fbm_a = 0.5f;\nconst float fbm_f = 2.0f;\n\n// 2d fbm\nfloat fbm(in vec2 p)\n{\n    float sum = 0.0f;\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n\tconst float ampDamp = fbm_a;\n\tconst float freqAtt = fbm_f;\n    float shift = 100.0f;\n    p *= frequency;\n    for (int i = 0; i < fbm_octaves; ++i)\n    {\n        sum += amplitude*valueNoise(p);\n        amplitude *= ampDamp;\n        // rotation to reduce axial bias\n        p = mat2(0.8f, 0.6f, -0.6f, 0.8f)*p*freqAtt;\n    }\n\n    return sum;\n}\n\n// 2d fbm with derivatives - once again - applying the chain rule to get the derivatives\n// the matrix multiplication is to reduce the axial bias\nvec3 fbmd(in vec2 p)\n{\n\tfloat sum = 0.0f;\n\tvec2 d = vec2(0.0f, 0.0f);\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n\tconst float ampDamp = fbm_a;\n\tconst float freqAtt = fbm_f;\n    float shift = 100.0f;\n    p *= frequency;\n\t// used to reduce axial bias\n\tconst mat2 mRot = mat2(0.8f, 0.6f, -0.6f, 0.8f);\n\t// the transpose of mRot\n\tconst mat2 mRotTranspose = mat2(0.8f, -0.6f, 0.6f, 0.8f);\n\t// we'll accumulate the powers of the transpose of mRot here\n\t// in the beginning this is the identity matrix\n\tmat2 m = mat2(1.0f, 0.0f, 0.0f, 1.0f);\n    for (int i = 0; i < fbm_octaves; ++i)\n    {\n\t\tvec3 ns = valueNoiseD(p);\n        sum += amplitude*ns.x;\n\t\td += amplitude*m*ns.yz;\n        amplitude *= ampDamp;\n        // rotation to reduce axial bias\n        p = mRot*p*freqAtt;\n\t\tm = freqAtt*mRotTranspose*m;\n    }\n\n    return vec3(sum,d);\n}\n\n\nfloat fbm9(in vec2 p)\n{\n    float sum = 0.0f;\n    float amplitude = 0.15f;\n    float frequency = 0.8f;\n\tconst float ampDamp = 0.55f;\n\tconst float freqAtt = 1.9f;\n    float shift = 100.0f;\n    p *= frequency;\n    for (int i = 0; i < 9; ++i)\n    {\n        sum += amplitude*(2.0f*valueNoise(p)-1.0f);\n        amplitude *= ampDamp;\n        // rotation to reduce axial bias\n        p = mat2(0.8f, 0.6f, -0.6f, 0.8f)*p*freqAtt;\n    }\n\n    return sum;\n}\n\n\nconst float terrainScale = 0.15f;\nconst float terrainHeight = 4.0f;\n\n// how we define the terrain\nfloat terrainMap(in vec2 p)\n{\n    float anim = 1.5*(0.5+0.5*abs(sin(iTime*0.5)));\n    return terrainHeight*fbm(anim*terrainScale*p);\n}\n\n// normals from analytic derivatives\n// the other option is calculating the derivatives numerically, but that requires evaluating\n// terrainMap at least 2 times(forward differences, and the known value at the point we're in)\nvec3 terrainNormal(in vec2 p)\n{\n#if 0\n\tvec3 fd = terrainHeight*terrainScale*fbmd(terrainScale*p);\n\t// we have the implicit surface y = f(x,z) => F(x,y,z) = y-f(x,z) = 0\n\t// then the normal is given by the gradient: (dF/dx, dF/dy, dF/dz)\n\treturn normalize(vec3(-fd.y, 1.0f, -fd.z));\n#else\n\tvec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(p-e.xy) - terrainMap(p+e.xy),\n                           2.0*e.x,\n                           terrainMap(p-e.yx) - terrainMap(p+e.yx) ) );\n#endif\n}\n\n// try to find an intersection with the terrain\nfloat raymarchTerrain(in vec3 o, in vec3 rd, float mint, float maxt)\n{\n\t// starting step size\n\tconst float startingDelta = 0.2f;\n\t// step size scaling with t\n\tconst float scalingDelta = 0.01f;\n\t// near and far radius\n\t//const float mint = 0.0f;\n    //const float maxt = 20.0f;\n\t\n\t// used for linear interpolation (better intersection)\n\t// last y\n\tfloat ly = 0.0f;\n\t// last terrain y\n\tfloat lh = 0.0f;\n\t// integrate over the ray path\n\tfloat delta = startingDelta;\n\tfor(float t = mint; t<maxt; t+= delta)\n\t{\n\t\t// current sample point on ray\n\t\tvec3 p = o+t*rd;\n\t\t// evaluate terrain height\n\t\tfloat h = terrainMap(p.xz);\n\t\t// if the ray point is beneath the terrain - find the intersection (incorrect if we start inside the terrain)\n\t\tif(p.y<h)\n\t\t{\n\t\t\t// linearly interpolate the last point and the current one, to estimate\n\t\t\t// the ray-terrain intersection\n\t\t\tfloat resT = t-delta + delta*(lh-ly)/(p.y-ly-h+lh);\n\t\t\treturn resT;\n\t\t}\n\t\t// record the last ray sample y and terrain y\n\t\tly = p.y;\n\t\tlh = h;\n\t\t// rescale delta for a speedup\n\t\tdelta = startingDelta + t*scalingDelta;\n\t}\n\treturn -1.0f;\n}\n\nconst vec3 sunDir = normalize(vec3(-0.6f, 0.4f, 0.6f));\n\n// You're not interested in this atm\nfloat terrainShadow(in vec3 o, in vec3 rd)\n{\n\tconst float mint = 0.01f;\n    float t = mint;\n\tfloat res = 1.0f;\n\tfor( int i=0; i<32; i++ )\n    {\n        vec3  pos = o + t*rd;\n        float  env = terrainMap( pos.xz );\n        float hei = pos.y - env;\n        res = min( res, 32.0*hei/t );\n        if( res<0.0001 ) break;\n        t += clamp( hei, 1.0+t*0.1, 50.0 );\n    }\n\t\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 fogCol = vec3(0.4,0.6,1.15);\n    return mix( col, fogCol, 1.0-exp(-0.00005*t*t*t) );\n}\n\n\nfloat raytraceWater(in vec3 o, in vec3 rd)\n{\n    const float waterHeight = 0.5f;\n    float t = (waterHeight-o.y)/rd.y;\n    float resT = t<0.0f? -1.0f : t;\n    return resT;\n}\n\n/*\n*\tAn abomination that serves to replace random\n*\n*\t@param seed: some seed\n*\n*\t@return: \"random\" number in [0,1)\n*/\nfloat hashAO(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n/*\n*\tComputes ambient occlusion\n*\n*\t@param p: \t\t\tSome intersection points which we want to calculate ambient occlusion for\n*\t@param n: \t\t\tThe normal at this point\n*\t@param aoRadius:\tRadius of occlusion\n*\t@param seed:\t\tA seed for the abomination \"sampling random numbers\"\n*\n*\t@return:\t\tOcclusion coefficient in [0,1], 0 - totally occluded, 1 - totally non-occluded\n*/\n#define AO_SAMPLES 16\nfloat ao(in vec3 p, in vec3 n, float aoRadius)\n{\n    float seed = hashAO( dot( p.xy*p.yz, vec2(12.9898, 78.233)+float(iTime) ) );\n    float occ = 0.0;\n    // integration of the hemisphere - we take AO_SAMPLES number of samples\n    for(int k=1;k<AO_SAMPLES;++k)\n    {\n        // in your implementation u and v would look like this:\n        // u = random();\n        // v = random();\n        // the abomination you see here is because this is glsl code:\n        float u = hashAO( 78.233 + seed + float(k)*92.13);\n    \tfloat v = hashAO( 10.873 + seed + float(k)*35.00);\n        \n        // the next part generates a cosine distributed direction in the upper hemisphere\n        // given a normal, ofr more information: http://amietia.com/lambertnotangent.html\n        // you can simply use your code from the homework - you don't need to use this one\n        // it's just good since it doesn't require you to build a coordinate frame\n        float a = 6.2831853 * v;\n        u = 2.0*u - 1.0;\n        vec3 dir = normalize(n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));\n        // note that since I generate a cosine distributed direction,\n        // the pdf is = cos(theta)/pi\n        // we want to find the visibility integral from here:\n        // https://en.wikipedia.org/wiki/Ambient_occlusion\n        // the cosine term cancel out, with the pdf, also the pi from the pdf cancels out\n        // with the 1/pi in front of the integral from the wikipedia article\n        \n        // this is the part where you check whether this ray intersects anything \n        // in a given radius - if it does - increment the occlusion count\n        // if it doesn't - do nothing\n    \tif(raymarchTerrain(p,dir,0.01,aoRadius)>0.0)\n        {\n            ++occ;\n        }\n    }\n    // occ/AO_SAMPLES would be the occlusion\n    // I want the oposite, so I subtract it from 1\n    return 1.0-occ/float(AO_SAMPLES);\n}\n\n\nvec4 renderTerrain(in vec3 o, in vec3 rd)\n{\n\tvec3 col = vec3(0.0f);\n\t// find intersection between the ray and the terrain (if there is no intersection: t==-1.0f)\n\tfloat t = raymarchTerrain(o, rd, 0.01, 20.0);\n\tif(t>0.0f)\n\t{\n        // You're also not interested in this atm\n\t\t// intersection position\n\t\tvec3 pos = o+rd*t;\n\t\tvec3 nor = terrainNormal(pos.xz);\n        float anim = 1.5*(0.5+0.5*abs(sin(iTime*0.5)));\n\t\tnor = normalize( nor + 0.8*(1.0-abs(nor.y))*0.8*fbmd_8( anim*pos*0.3*vec3(1.0,0.2,1.0) ).yzw );\n\t\tvec3 green = vec3(0.3f, 0.3f, 0.0f);\n\t\tvec3 desert = vec3(0.18,0.11,0.10)*.75;\n\t\tvec3 interm = mix( desert, green, smoothstep(0.7,0.9,nor.y) );\n\t\tfloat w = (o+t*rd).y/(1.5f*terrainHeight);\n\t\tfloat diff = max(0.0f, dot(sunDir, nor));\n\t\t//if(diff>0.001f) diff *= terrainShadow(pos+nor*0.01f, sunDir);\n\t\tvec3 lin = 1.0*5.0*vec3(1.0,0.9,0.8)*diff;\n\t\tcol = interm*w;\n\t\tcol *= lin;\n        col = fog(col, t);\n\t\t\n        //vec3 pos = o+rd*t;\n        //float ambientTerm = ao(pos, terrainNormal(pos.xz), 3.0);\n        //col = vec3(ambientTerm);\n\t}\n\treturn vec4(col, t);\n}\n\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\n\n    // clouds\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm9( uv*0.002 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.4*dl );\n    }\n    \n\t// sun glare    \n    float sun = clamp( dot(sunDir,rd), 0.0, 1.0 );\n    col += 0.8*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec4 renderWater(in vec3 o, in vec3 rd)\n{\n    vec3 col = vec3(0.0f);\n    float tw = raytraceWater(o,rd);\n    if(tw>0.0f)\n    {\n        col = vec3(0.3f, 0.48f, 1.0f);\n        vec3 pos = o+rd*tw;\n        vec3 ref = reflect(rd, vec3(0.0f, 1.0f, 0.0f));\n        float diff = sunDir.y;\n        col *= diff;\n        vec3 spec = vec3(pow(max(0.0f, dot(ref, sunDir)),10.0));\n        col += spec;\n        vec3 bon = normalize(ref-vec3(0.0f, 0.4f+0.02f*(2.0f*rand(pos.xz)-1.0f), 0.0f));\n        vec4 rf = renderTerrain(pos+vec3(0.0f, 0.2f, 0.0f), bon);\n        if(rf.w>0.0f) col *= rf.xyz;\n        else\n        {\n            col *= 1.0f*mix(col, vec3(1.8f), (0.5f*fbm9( pos.xz*7.0f )+0.5f));\n        }\n        \n        col = fog(col, tw);\n    }\n    return vec4(col, tw);\n}\n\n\nvec3 render(in vec3 o, in vec3 rd)\n{\n\tvec3 col = renderSky(o,rd);\n    vec4 waterCol = renderWater(o,rd);\n    vec4 terrCol = renderTerrain(o, rd);\n    if(waterCol.w>0.0f && terrCol.w>0.0f)\n    {\n        if(waterCol.w<terrCol.w)\n        \tcol = waterCol.xyz;\n        else\n            col = terrCol.xyz;\n    }\n    else if(waterCol.w>0.0f)\n        col = waterCol.xyz;\n    else if(terrCol.w>0.0f)\n        col = terrCol.xyz;\n        \n\t// equivalent to col = terrCol.w==1.0f ? terrCol.xyz : col;\n\t\n\treturn col;\n}\n\n#define PI 3.14159265359f\nvec3 render(vec2 ndc, float aspectRatio)\n{\n\t// camera origin\n    vec3 o = vec3(0.0f, 5.0f, -6.0f);\n\t// camera horizontal field of view\n    const float fov = 2.0f*PI / 3.0f;\n    const float scaleX = tan(fov / 2.0f);\n\t// camera right vector\n    vec3 right = vec3(1.0f, 0.0f, 0.0f)*scaleX;\n\t// camera forward vector\n    vec3 forward = vec3(0.0f, 0.0f, 1.0f);\n\t// camera up vector\n    vec3 up = vec3(0.0f, 1.0f, 0.0f)*scaleX*aspectRatio;\n\t// ray direction\n    vec3 rd = normalize(forward + ndc.x*right + ndc.y*up);\n    return render(o, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ndc = 2.0f*fragCoord.xy / iResolution.xy-1.0f;\n\tvec3 col = render(ndc, 1.0);\n    \n    // approximate gamma correction\n    col = sqrt(col);\n\tfragColor = vec4(col,1.0f);\n}","name":"Image","description":"","type":"image"}]}