{"ver":"0.1","info":{"id":"4XGSzt","date":"1720449624","viewed":54,"name":"2d raymarching example #1","username":"hasenpfote","description":"This is a simple raymarching demo, created while experimenting with stateless mouse interactions.\n\nclick and drag.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","mouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * 2d raymarching example #1\n *\n * ===\n * https://iquilezles.org/articles/distgradfunctions2d/\n */\n\n//#define SHOW_NORMALS\n//#define SHOW_ISOLINES\n\nconst int MAX_MARCH_STEPS = 128;\nconst float MIN_HIT_DISTANCE = 1e-3;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.1);\nconst vec3 SAMPLE_POS_COLOR = vec3(181, 209, 0) / 255.;\nconst vec3 SHORTEST_DISTANCE_COLOR = vec3(0, 158, 156) / 255.;\nconst vec3 TRAJECTORY_COLOR = vec3(234, 96, 149) / 255.;\nconst vec3 TARGET_MARKER_COLOR = vec3(0., 1., 0.);\nconst vec3 HIT_MARKER_COLOR = vec3(1., 0., 0.);\nconst vec3 PRIMITIVE_COLOR = vec3(165, 222, 229) / 255.;\n\nfloat sd_circle(in vec2 p, in float r){\n    return length(p) - r;\n}\n\nfloat sd_box(in vec2 p, in vec2 b){\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\nfloat sd_rounded_x(in vec2 p, in float w, in float r){\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nfloat sd_equilateral_triangle(in vec2 p, in float r){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    if(p.x + k * p.y > 0.0)\n        p = vec2(p.x - k * p.y, - k * p.x - p.y) / 2.;\n    p.x -= clamp(p.x, -2. * r, 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p - a,\n         ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nfloat map(vec2 p){\n    float d = 1e1;\n#if 1\n    d = min(d, sd_circle(p - vec2(-0.75, 0.), 0.2));\n    d = min(d, sd_circle(p - vec2(-0.00, 0.), 0.3));\n    float d1 = sd_circle(p - vec2( 1.00, 0.), 0.4);\n    float d2 = sd_circle(p - vec2( 1.20, 0.), 0.3);\n    d = min(d, max(d1, -d2));\n#else\n    d = min(d, sd_box(p - vec2(-0.50, 0.), vec2(0.05, 0.05)));\n    d = min(d, sd_box(p - vec2(-0.25, 0.), vec2(0.05, 0.20)));\n    d = min(d, sd_box(p - vec2( 0.00, 0.), vec2(0.05, 0.40)));\n    d = min(d, sd_box(p - vec2( 0.25, 0.), vec2(0.05, 0.60)));\n    d = min(d, sd_box(p - vec2( 0.50, 0.), vec2(0.05, 0.80)));\n#endif\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec2 normal(in vec2 p){\n#if 0\n    vec2 d = vec2(1e-4, 0.);\n    return normalize(vec2(map(p + d.xy) - map(p - d.xy), map(p + d.yx) - map(p - d.yx)));\n#else\n    const float h = 1e-4;\n    const vec2 k = vec2(1., -1.);\n    return normalize(k.xx * map(p + h * k.xx) + k.xy * map(p + h * k.xy) - (k.xx + k.xy) * map(p));\n#endif\n}\n\nvec4 mouse_to_ray(){\n    vec2 delta = iMouse.xy - abs(iMouse.zw);\n    vec2 ro = mix((2. * abs(iMouse.zw) - iResolution.xy) / iResolution.y,\n                  vec2(0.),\n                  float(all(lessThan(iMouse.xy, vec2(0.5)))));\n    vec2 rd = normalize(mix(delta, vec2(1., 0.), float(length(delta) < 1e-1)));\n\n    return vec4(ro, rd);\n}\n\nvec3 draw_march(in vec2 p, in vec2 start, in vec2 end, in vec3 color){\n    float maxt = distance(start, end);\n\n    if(maxt < 1e-3)\n        return color;\n\n    vec2 bounds = vec2(-1., 1.) / iResolution.y;\n    vec2 ro = start;\n    vec2 rd = normalize(end - start);\n    float t = 0.;\n\n    for(int i = 0; i < MAX_MARCH_STEPS && t < maxt; i++){\n        vec2 sp = ro + t * rd;\n\n        float h = abs(map(sp));\n\n        if(h < MIN_HIT_DISTANCE)\n            break;\n\n        t += h;\n\n        vec3 mixed_color = mix(SHORTEST_DISTANCE_COLOR, color, 0.5);\n        float d = sd_circle(p - sp, h);\n        color = mix(mixed_color, color, smoothstep(0., 4. * bounds.y, d));\n        color = mix(SHORTEST_DISTANCE_COLOR, color, smoothstep(0., 4. * bounds.y, abs(d)));\n        color = mix(SAMPLE_POS_COLOR, color, smoothstep(0., 4. * bounds.y, sd_circle(p - sp, 0.01)));\n    }\n\n    vec2 hp = ro + t * rd;\n    float scale = 1.25 + 0.25 * sin(5. * iTime);\n\n    color = mix(0.25 * TRAJECTORY_COLOR, color,\n                smoothstep(0., 2. * bounds.y, sd_segment(p, ro, end) - 0.001));\n    color = mix(TARGET_MARKER_COLOR, color,\n                smoothstep(0., 4. * bounds.y, sd_equilateral_triangle(p - end, scale * 0.02)));\n\n    if(t < maxt){\n        color = mix(TRAJECTORY_COLOR, color,\n                    smoothstep(0., 2. * bounds.y, sd_segment(p, ro, hp) - 0.001));\n        color = mix(HIT_MARKER_COLOR, color,\n                    smoothstep(0., 4. * bounds.y, sd_rounded_x(p - hp, scale * 0.02, scale * 0.001)));\n\n        vec2 n = normal(hp);\n\n        color = mix(HIT_MARKER_COLOR, color,\n                    smoothstep(0., 2. * bounds.y, sd_segment(p, hp, hp + 0.1 * n) - 0.001));\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 color = BACKGROUND_COLOR;\n    float h = map(uv);\n\n#ifdef SHOW_NORMALS\n    color = mix(color, 0.5 + 0.5 * vec3(normal(uv), -1.), step(h, 0.));\n#else\n    vec2 bounds = vec2(-1., 1.) / iResolution.y;\n\n    color = mix(PRIMITIVE_COLOR, color, smoothstep(bounds.x, bounds.y, h));\n    color = mix(1. - PRIMITIVE_COLOR, color, smoothstep(0., 5. * bounds.y, abs(h)));\n#endif\n\n#ifdef SHOW_ISOLINES\n    color += 0.2 * sin(300.0 * h);\n#endif\n\n    color = draw_march(uv,\n                       mouse_to_ray().xy,\n                       (2. * iMouse.xy - iResolution.xy) / iResolution.y,\n                       color);\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//==============================================================================\n\nvec3 srgb_to_linear(in vec3 color){\n    vec3 lo = vec3(color / 12.92);\n    vec3 hi = pow((color + 0.055) / 1.055, vec3(2.4));\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.04045)));\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    vec3 lo = 12.92 * color;\n    vec3 hi = 1.055 * pow(color, vec3(1./2.4)) - 0.055;\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.0031308)));\n}\n","name":"Common","description":"","type":"common"}]}