{"ver":"0.1","info":{"id":"Wd3SR8","date":"1571366385","viewed":105,"name":"FVM - Test with lighting","username":"dfactor","description":"First test of FVM with lighting by A. V. Tolok.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","voxel","rfunc","fvm","functionalvoxelmodeling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle(vec2 uv, vec2 center, float radius) {\n    return length(uv-center)*length(uv-center)-radius*radius;\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b) {\n    return ((b.y-a.y)*uv.x + (a.x-b.x)*uv.y + (b.x*a.y-a.x*b.y))/sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));\n}\n\n// Here and further alpha is used for smooth interpolation between two given funcs\n// Alpha = [-1;1]\nfloat sum(float a, float b, float alpha) {\n    return (a+b+sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\nfloat mul(float a, float b, float alpha) {\n    return (a+b-sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\n// Our FV model\nfloat map(vec2 uv, float alpha) {\n    //vec2 pos1 = vec2(-cos(iTime)/2.0, 0.0);\n    //vec2 pos2 = vec2(0.0, sin(iTime)/2.0);\n    \n    //return mul(circle(uv, pos1, 0.5), circle(uv, pos2, 0.5), alpha);\n    \n    vec2 a = vec2(-0.5, mix(0.0,-0.5,0.5+cos(iTime)/2.0));\n    vec2 b = vec2(0.0, 0.0);\n    vec2 c = vec2(mix(-0.5,0.5,0.5+cos(iTime)/2.0), -0.5);\n    \n    float r = 0.75 + cos(iTime)/4.0;\n    \n    return sum(mul(line(uv, a, b), line(uv, b, c), alpha), circle(uv, b, r), alpha);\n}\n\n// Calculating the Multi-Dimennsional Image\nvec4 mdi(vec2 uv1, vec2 uv2, vec2 uv3, float value1, float value2, float value3) {\n    float Ai = uv1.y*(value2-value3)-uv2.y*(value1-value3)+uv3.y*(value1-value2);\n    float Bi = -(uv1.x*(value2-value3)-uv2.x*(value1-value3)+uv3.x*(value1-value2));\n    float Ci = uv1.x*(uv2.y-uv3.y)-uv2.x*(uv1.y-uv3.y)+uv3.x*(uv1.y-uv2.y);\n    float Di = uv1.x*(uv2.y*value3-uv3.y*value2)-uv2.x*(uv1.y*value3-uv3.y*value1)+uv3.x*(uv1.y*value2-uv2.y*value1);\n\n    float Nx = Ai / sqrt(Ai*Ai + Bi*Bi + Ci*Ci + Di*Di);\n    float Ny = -Bi / sqrt(Ai*Ai + Bi*Bi + Ci*Ci + Di*Di);\n    float Nz = -Ci / sqrt(Ai*Ai + Bi*Bi + Ci*Ci);\n    float Nt = Di / sqrt(Ai*Ai + Bi*Bi + Ci*Ci + Di*Di);\n    \n    int flag1 = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    if (value1>=0.0) flag1 = 1;\n    if (value2>=0.0) flag2 = 1;\n    if (value3>=0.0) flag3 = 1;\n    \n    int flag_sum = flag1 + flag2 + flag3;\n    if (flag_sum < 2) return vec4((Nx+1.0)/2.0, (Ny+1.0)/2.0, (Nz+1.0)/2.0, (Nt+1.0)/2.0); //xyz representation\n    return vec4(0.5, 0.5, 1.0, 1.0); //+Z normal\n}\n\n// Fake 4d light, further work need to be done\nfloat calcLight(vec2 uv, vec4 normals) {\n    vec4 light = normalize(vec4(-0.5,-0.5,1.0,1.0));\n    \n    return dot(normals.xyzw, light)/(length(normals.xyzw)*length(light));\n}\n\nvec4 calcImage(vec2 uv, float alpha) {\n    // Near coords\n    vec2 uv1 = uv;\n    vec2 uv2 = vec2(uv.x, uv.y+0.005);\n    vec2 uv3 = vec2(uv.x+0.005, uv.y);\n    \n    // Values in given coords\n    float value1 = map(uv1, alpha);\n    float value2 = map(uv2, alpha);\n    float value3 = map(uv3, alpha);\n    \n    return mdi(uv1, uv2, uv3, value1, value2, value3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n    \n    //vec4 value = circle_mdi(vWindow, vec2(sin(iTime)*0.5, cos(iTime)*0.5), 0.5);\n    //vec4 value = line_mdi(vWindow, vec2(sin(iTime),1), vec2(cos(iTime),-1));\n    vec4 value = calcImage(vWindow, 0.0);\n    \n    float val = calcLight(vWindow, value);\n    vec3 col = vec3(val, val, val);\n    //vec3 col = vec3(value.x, value.y, value.z);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}