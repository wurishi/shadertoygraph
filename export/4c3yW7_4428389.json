{"ver":"0.1","info":{"id":"4c3yW7","date":"1730718460","viewed":49,"name":"insper-blobs-eduardoarc","username":"Eduardoarcunha","description":"Made for Insper Computer Graphics course.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(vec2 st) { \n    float val = dot(st.xy, vec2(12.9898, 78.233)); \n    return fract(sin(val) * 43758.5453123); \n}\n\n// Perlin Noise\nfloat noise(vec2 st) {\n    vec2 i = floor(st);   \n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 fromCenter = (uv - 0.5) * 2.0;\n    float aberrationStrength = 0.005;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    // Canais RGB\n    for(int channel = 0; channel < 3; channel++) {\n        float channelOffset = float(channel - 1);\n        vec2 uvOffset = uv + fromCenter * (channelOffset * aberrationStrength);\n        \n        vec2 offsetUV = uvOffset;\n        offsetUV -= .5;\n        offsetUV.x *= iResolution.x / iResolution.y;\n        \n        // Tiles\n        const float N = 3.0;\n        vec2 tile = floor(offsetUV * N);\n        float tileNoise = random(tile);\n        \n        int NUM_BLOBS = int(floor(tileNoise * (N + 3.0))) + 3;  // 3-6 blobs / tile\n        \n        offsetUV = fract(offsetUV * N) - 0.5;\n        float combined = 0.0;\n        vec3 color = vec3(0.0);\n        \n        for (int i = 0; i < 5; i++) {\n            if (i >= NUM_BLOBS) break;\n            \n            float baseSpeed = 0.75 + tileNoise * 0.2;\n            float timeOffset = float(i) * 2.731 + tileNoise * 4.0;\n            \n            // Posicao + Ruido\n            float xNoise = noise(vec2(iTime * baseSpeed + timeOffset, 0.0));\n            float yNoise = noise(vec2(iTime * baseSpeed + timeOffset + 50.0, 100.0));\n            \n            float angle = float(i) * 6.28 / float(NUM_BLOBS) + tileNoise * 3.0;\n            float radius = 1.2 - float(i) * 0.15 + tileNoise * 0.3;\n            \n            float direction = (mod(float(i) + floor(tileNoise * 2.0), 2.0) == 0.0) ? 1.0 : -1.0;\n            \n            vec2 center = vec2(\n                sin(direction * iTime * baseSpeed + angle) * 0.15 * (1.0 + xNoise * 0.3),\n                cos(direction * iTime * baseSpeed * 0.7 + angle) * 0.15 * (1.0 + yNoise * 0.3)\n            );\n            \n            center += vec2(\n                sin(direction * iTime * 0.2 + timeOffset) * 0.05 * xNoise,\n                cos(direction * iTime * 0.15 + timeOffset) * 0.05 * yNoise\n            );\n            \n            float dist = length(offsetUV - center);\n            float wave = sin(15.0 * (offsetUV.x + offsetUV.y) + iTime * (1.5 + tileNoise)) * 0.05 * (1.0 + noise(offsetUV + iTime * 0.1) * 0.5);\n            float blobStrength = radius / (dist + wave * smoothstep(0.0, 0.8, dist));\n            combined += blobStrength;\n            \n            // Cor com o tempo\n            float hue = fract(0.1 * iTime + float(i) * 0.2 + tileNoise * 0.3);\n            float sat = 0.8 + sin(iTime * 0.3 + timeOffset) * 0.2;\n            float val = 0.9;\n            vec3 blobColor = hsv2rgb(vec3(hue, sat, val));\n            \n            color += blobColor * blobStrength * 0.5;\n        }\n        \n        // Gera o comportamento entre os Blobs\n        float threshold = 30.0 + tileNoise * 3.0;\n        float mask = smoothstep(threshold - 1.0, threshold + 1.0, combined);\n        \n        color = normalize(color) * mask;\n        \n        vec3 positionColor = hsv2rgb(vec3(\n            fract(length(offsetUV + 0.5) + iTime * 0.1),\n            0.5,\n            0.8\n        ));\n        vec3 tempColor = mix(color, positionColor, 0.2);\n        \n        finalColor[channel] = tempColor[channel];\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}