{"ver":"0.1","info":{"id":"4lffRS","date":"1512180080","viewed":216,"name":"sdf round edge cylinder","username":"mds2","description":"simple sdf raycasting against a cylinder with rounded corners.  I'm amused at how looking up reflections in the blurred cube map gives one's shape the appearance of rough metal","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simple","raycast","sdf","round","cylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 cyl_center = vec3(0.1, 0.0, -1.0);\n// const vec3 cyl_dir = vec3(0.6, 0.64, 0.48);\n//const vec3 sphere_center = vec3(-0.7, 0.1, -1.1);\nconst float sphere_rad = 0.7;\nconst float cyl_length = 2.0;\nconst float cyl_rad = 0.8;\nconst float curve_rad = 0.4;\n\nfloat orig_cyl_sdf(in highp vec3 point) {\n    vec3 cyl_dir =\n        vec3(sin(iTime) * cos(3.3 * iTime),\n             sin(3.3*iTime),\n             cos(iTime) * cos(3.3 * iTime));\n\tvec3 rel = point - cyl_center;\n    float along = dot(rel, cyl_dir);\n    vec3 across = rel - cyl_dir * along;\n    return length(max(vec2(length(across) - cyl_rad + curve_rad,\n                  \t       abs(along) - 0.5 * cyl_length + curve_rad),\n                     0.0)) - curve_rad;\n}\n\nfloat sphere_sdf(in highp vec3 point) {\n    vec3 sphere_center =\n        vec3(0.9 * sin(0.6 * iTime),\n             0.9 * cos(1.1 * iTime),\n             -1.0);\n\treturn length(point - sphere_center) - sphere_rad;\n}\n\nfloat soft_min(float a, float b, float amount) {\n\n    float h = clamp(0.5 + 0.5 * (a-b)/amount, 0.0, 1.0);\n    return mix(a,b,h) - amount*h*(1.0-h);\n}\n\nfloat soft_max(float a, float b, float amount) {\n    return -soft_min(-a, -b, amount);\n}\n\nfloat cyl_sdf(in highp vec3 point) {\n\treturn soft_min(orig_cyl_sdf(point), sphere_sdf(point), 0.2);\n}\n\nvec3 cyl_norm(in highp vec3 point) {\n\tfloat v = cyl_sdf(point);\n    return normalize(vec3(v + cyl_sdf(point + vec3(0.01, 0.00, 0.00)),\n                          v + cyl_sdf(point + vec3(0.00, 0.01, 0.00)),\n                          v + cyl_sdf(point + vec3(0.00, 0.00, 0.01))));\n}\n\nfloat cyl_isect(in highp vec3 ray_orig, in highp vec3 ray_dir) {\n\tfloat result = 0.0;\n    vec3 p = ray_orig;\n    float last_d = 2.0 * cyl_rad;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = cyl_sdf(p);\n        result += d;\n        p += d * ray_dir;\n        last_d = d;\n    }\n    if (last_d > 1.0e-3) {\n        return -1.0; // miss\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 ray_orig = vec3(0.0, 0.0, 2.0);\n    vec3 ray_dir = normalize(vec3(uv, -1.0));\n    \n    float d = cyl_isect(ray_orig, ray_dir);\n    if (d > 0.0) {\n    \tvec3 p = ray_orig + d * ray_dir;\n        vec3 n = cyl_norm(p);\n        ray_dir = normalize(reflect(ray_dir, n));\n    \n    fragColor = vec4(0.7, 0.8, 1.0, 1.0) * texture(iChannel1, ray_dir);\n    } else {\n    fragColor = texture(iChannel0, ray_dir);\n}\n}","name":"Image","description":"","type":"image"}]}