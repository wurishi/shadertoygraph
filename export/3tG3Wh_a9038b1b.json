{"ver":"0.1","info":{"id":"3tG3Wh","date":"1578959082","viewed":108,"name":"TransferWise logo raymarched","username":"kow","description":"Playing with shape extrusion and distortion of the TW logo. \n\n2D version of the logo: https://www.shadertoy.com/view/wtV3zW","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","logo","transferwise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Used the scene from this shader\n// https://www.shadertoy.com/view/lsKcDD\n\n// make this 1 is your machine is too slow\n#define AA 1\n#define ENABLE_BENDING 1\n//\n#define LOGO 0.\n#define PLANE 1.\n\n//------------------------------------------------------------------\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nvec2 uniOp(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nconst int N = 12;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;\n    }\n\n    return s*sqrt(d);\n}\n\nfloat sdLogo(vec2 p) {\n    vec2 center = vec2(-.45, .75);\n    float scale = .75;\n    vec2 v0 = center - vec2(-0.127,0) * scale;\n    vec2 v1 = center - vec2(-0.295,0.262) * scale;\n    vec2 v2 = center - vec2(-0,0.524) * scale;\n    vec2 v3 = center - vec2(-0.51,0.524) * scale;\n    vec2 v4 = center - vec2(-0.558,0.419) * scale;\n    vec2 v5 = center - vec2(-0.277,0.419) * scale;\n    vec2 v6 = center - vec2(-0.447,0.261) * scale;\n    vec2 v7 = center - vec2(-0.348,0.105) * scale;\n    vec2 v8 = center - vec2(-0.812,0.105) * scale;\n    vec2 v9 = center - vec2(-0.404,1) * scale;\n    vec2 v10 = center - vec2(-0.544,1) * scale;\n    vec2 v11 = center - vec2(-1,0) * scale;\n\n    // add more points\n    vec2[] poly = vec2[](v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11);\n\n\treturn sdPoly(poly, p);\n}\n\n//------------------------------------------------------------------\n\nvec2 map(in vec3 pos)\n{\n#if ENABLE_BENDING == 1\n    float k = 2. * sin(iTime) * .15;\n#else\n    float k = 0.;\n#endif\n    float c = cos(k*pos.y);\n    float s = sin(k*pos.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy, pos.z);\n\n    vec2 logo = vec2(opExtrussion(q, sdLogo(q.xy), 0.05), LOGO);\n    vec2 plane = vec2(sdPlane(pos.xyz), PLANE);\n    return uniOp(plane, logo);\n}\n\n//------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tvec2 h = map( ro + rd*t );\n        float y = h.x * h.x / (2.0 * ph);\n        float d = sqrt(h.x * h.x - y * y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h.x;\n\n        t += h.x;\n\n        if( res<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    vec2 m = vec2(0., 0.); // dist marched + material info\n\n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro + rd * t );\n        m.y = res.y;\n\n        if( res.x < precis || t > tmax ) break;\n        t += res.x;\n    }\n\n    if( t > tmax ) t = -1.0;\n    m.x = t;\n    return m;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        vec2 d = map( pos + h*nor );\n        occ += (h - d.x)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\n    vec2 t = castRay(ro,rd);\n\n    if( t.x > -0.5 )\n    {\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = calcNormal( pos );      \n\t\tvec3 color = vec3(.14, .21, .3);\n        \n        if(t.y == LOGO) {\n        \tcolor = vec3(0., 0.72, 1.);\n        }\n\n        // key light\n        vec3  lig = normalize( vec3(-0.5, 0.2, 0.25) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) *\n                    calcSoftshadow( pos, lig, 0.01, 4.0 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = color * dif * .7;\n        col += spe * vec3(1.);\n\n        // ambient light\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n        col += color * amb * .7 * occ * .25;\n\n        // fog\n        col *= exp( -0.03 * t.x * t.x * t.x );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 8.0 - sin(2.0 * iTime);\n    vec3 ro = vec3(cos(.58 * an), 1., .9 + sin(an));\n    vec3 ta = vec3(0.0, -.5, -3.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}