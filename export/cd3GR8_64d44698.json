{"ver":"0.1","info":{"id":"cd3GR8","date":"1678240529","viewed":74,"name":"Infinitely twisting cubes","username":"rdiersing","description":"Playing around with infinite modular repetition via ray marching. Made an infinite number of cubes that twist over time.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","cubes","twist","modular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nconst float epislon = 0.0001;\n\nvec3 rotate_z(in vec3 p, in float theta) {\n    mat4 t = mat4(cos(theta), -sin(theta), 0.0, 0.0,\n                  sin(theta), cos(theta), 0.0, 0.0,\n                  0.0, 0.0, 1.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    return (vec4(p, 1.0)*t).xyz;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 map(in vec3 p) {\n    vec3 c = vec3(0.24 + 0.1*sin(p.x), 0.42 + 0.1*sin(p.y), 0.64 + 0.1*sin(p.z));\n    vec3 p_t = p;\n    p_t = mod(p_t + 0.5*4.0, 4.0) - 0.5*4.0;\n    p_t = rotate_z(p_t, iTime*p_t.z);\n    // p_t -= vec3(0.0,6.0,0.0);\n    // return vec4(c, distance(p, vec3(0.0, 4.0, 10.0)) - 1.0);\n    return vec4(c, sdRoundBox(p_t, vec3(0.1,0.1,0.1), 0.1));\n}\n\n\nfloat sdf(in vec3 p) {\n    return map(p).w;\n}\n\nvec3 calcNormal(in vec3 p) {\n    const vec2 h = vec2(epislon,0);\n    return normalize( vec3(sdf(p+h.xyy) - sdf(p-h.xyy),\n                           sdf(p+h.yxy) - sdf(p-h.yxy),\n                           sdf(p+h.yyx) - sdf(p-h.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates and correct for aspect ratio\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv = vec2((uv.x * aspect_ratio) - aspect_ratio/2.0, uv.y-0.5);\n\n    // background color\n    vec3 col = vec3(0.76, 0.89, 0.93);\n    \n    // camera dir is always 0,1,0\n    vec3 cam_p = vec3(sin(iTime), 0.0, cos(iTime));\n    vec3 dir = normalize(vec3(uv.x, 1.0, uv.y));\n    vec3 p = cam_p;\n    vec4 dist = map(p);\n    for (int i = 0; i < 1000; ++i) {\n        if (dist.w < 0.01) {\n            col = dist.xyz;\n            vec3 norm = calcNormal(p);\n            vec3 light_dir = vec3(-1.0, 1.0, -1.0);\n            vec3 light_color = vec3(1.0, 1.0, 1.0);\n            float ambient = 0.2;\n            float diffuse = max(dot(norm, -light_dir), 0.0); \n            float specular = 0.03*pow(max(dot(dir, reflect(-light_dir, norm)), 0.0), 16.0);\n    \n            light_color *= ambient + diffuse + specular;\n            col = col * light_color;\n            break;\n        }\n        if (dist.w > 20.0) {\n            break;\n        }\n        if (length(p) > 100000.0) {\n            break;\n        }\n        p += dir*dist.w;\n        dist = map(p);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}