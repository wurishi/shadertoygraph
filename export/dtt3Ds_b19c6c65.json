{"ver":"0.1","info":{"id":"dtt3Ds","date":"1683387596","viewed":96,"name":"Raymarched Rec Room Logo","username":"Pancake992","description":"Rec Room logo rendered by my raymarcher\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["recroom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Settings in Common\n\n\n//Common funtions\n\nfloat getTime(){return iTime * TIME_SCALE*PI;}\n\nvec4 axis_to_quaternion(in vec3 axis, in float angle)\n{\n    return vec4(axis.x * sin(angle/2.),axis.y * sin(angle/2.),axis.z * sin(angle/2.), cos(angle/2.));\n}\n\nvec4 quaternion_multiply(in vec4 q1, in vec4 q2)\n{\n    vec4 q = vec4(0.,0.,0.,0.);\n    q.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    q.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    q.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    q.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return q;\n}\n\nvec3 rotate_position_axis(in vec3 p, in vec3 axis, in float angle)\n{ \n  vec4 q = axis_to_quaternion(axis, angle);\n  return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\nvec3 rotate_position_quat(in vec3 p, in vec4 q)\n{\n    vec4 v = vec4(p, 0.0);\n    vec4 q2 = vec4(-q.x,-q.y,-q.z,q.w);\n    return quaternion_multiply(quaternion_multiply(q,v),q2).xyz;\n}\n\nfloat deg_to_rad(in float degree) {return degree * PI / 180.;}\nfloat rad_to_deg(in float degree) {return degree / PI * 180.;}\n\n\n//SDF calculations\nfloat sphereSDF(in vec3 o, in float r, in vec3 p){return length(o-p)-r;}\nfloat planeSDF(in vec3 o, in vec3 n, in vec3 p){return abs(dot(n,p) - dot(n,o))/sqrt(dot(n,n));}\nfloat rrSDF(in vec3 p){return min(min(min(min(max(max(max((length(max(abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.5, 0.55 ,0.5),0.0) + min(max((abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.5, 0.55 ,0.5)).x,max((abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.5, 0.55 ,0.5)).y,(abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.5, 0.55 ,0.5)).z)),0.0)) - 0.1), -((length(max(abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.47, 0.52 ,0.5),0.0)) + min(max((abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.47, 0.52 ,0.5)).x,max((abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.47, 0.52 ,0.5)).y,(abs(p-vec3(0.0, 0.0 ,0.0)) - vec3(0.47, 0.52 ,0.5)).z)),0.0)) - 0.05)), -((length(max(abs(p-vec3(0.0, 0.0 ,1.0)) - vec3(1.0, 0.65 ,0.85),0.0)) + min(max((abs(p-vec3(0.0, 0.0 ,1.0)) - vec3(1.0, 0.65 ,0.85)).x,max((abs(p-vec3(0.0, 0.0 ,1.0)) - vec3(1.0, 0.65 ,0.85)).y,(abs(p-vec3(0.0, 0.0 ,1.0)) - vec3(1.0, 0.65 ,0.85)).z)),0.0)) - 0.1)), -((length(max(abs(p-vec3(0.0, 0.0 ,-1.0)) - vec3(1.0, 0.65 ,0.85),0.0)) + min(max((abs(p-vec3(0.0, 0.0 ,-1.0)) - vec3(1.0, 0.65 ,0.85)).x,max((abs(p-vec3(0.0, 0.0 ,-1.0)) - vec3(1.0, 0.65 ,0.85)).y,(abs(p-vec3(0.0, 0.0 ,-1.0)) - vec3(1.0, 0.65 ,0.85)).z)),0.0)) - 0.1)), (length(max(abs(p-vec3(0.0, 0.4 ,0.0)) - vec3(0.6, 0.05 ,0.05),0.0)) + min(max((abs(p-vec3(0.0, 0.4 ,0.0)) - vec3(0.6, 0.05 ,0.05)).x,max((abs(p-vec3(0.0, 0.4 ,0.0)) - vec3(0.6, 0.05 ,0.05)).y,(abs(p-vec3(0.0, 0.4 ,0.0)) - vec3(0.6, 0.05 ,0.05)).z)),0.0))), (length(max(abs(p-vec3(0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05),0.0)) + min(max((abs(p-vec3(0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05)).x,max((abs(p-vec3(0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05)).y,(abs(p-vec3(0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05)).z)),0.0))), (length(max(abs(p-vec3(-0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05),0.0)) + min(max((abs(p-vec3(-0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05)).x,max((abs(p-vec3(-0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05)).y,(abs(p-vec3(-0.2, 0.2 ,0.0)) - vec3(0.05, 0.25 ,0.05)).z)),0.0))), (length(max(abs(p-vec3(0.0, -0.35 ,0.0)-vec3(0.,0.5*pow(abs(p.x),2.),0.)) - vec3(0.6, 0.05 ,0.05),0.0)) + min(max((abs(p-vec3(0.0, -0.35 ,0.0)-vec3(0.,0.5*pow(abs(p.x),2.),0.)) - vec3(0.6, 0.05 ,0.05)).x,max((abs(p-vec3(0.0, -0.35 ,0.0)-vec3(0.,0.5*pow(abs(p.x),2.),0.)) - vec3(0.6, 0.05 ,0.05)).y,(abs(p-vec3(0.0, -0.35 ,0.0)-vec3(0.,0.5*pow(abs(p.x),2.),0.)) - vec3(0.6, 0.05 ,0.05)).z)),0.0)));}\nfloat boxSDF(vec3 o, vec3 s, float r, vec3 p){vec3 q = abs(p-o) - s; return (length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)) - r;}\n\n//modifiers\n\nvec3 repeat( in vec3 p, in float c){return p-c*round(p/c);}\n\n\n\n\n\n\n\n\n\n/////scene\n\nfloat Scene(in vec3 pos)\n{\n    vec3 p = pos;\n    vec3 c = floor(abs(pos)*0.45)/0.45;\n    p = repeat(p - vec3(0.,1.,0.), 3.25)- vec3(0.0,0.25*sin( getTime()*20.*TIME_SCALE+length(c)*0.25),0.0);\n    p = rotate_position_axis(p, normalize(c+vec3(0.01)), sin(length(c)*0.4));\n    p = rotate_position_axis(p, vec3(0.,1.,0.),getTime()*-10. *TIME_SCALE + PI*0.25);\n    float d = rrSDF(p- vec3(0.0,0.25*sin(getTime()*20.*TIME_SCALE+length(pos)*0.35),0.0));\n    return max(d,0.)-0.02;\n}\n\nvec4 color(in vec3 pos)\n{\n    float fall_off = pow(clamp(length(pos)/60.,0.,1.), 3.);\n    vec4 col = vec4(1.0,0.5,0.0,0.35); \n    col = mix(col,0.1*vec4(1.0,0.5,0.0,0.0), fall_off);\n    return col;    \n}\nvec3 normal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(Scene(pos+e.xyy)-Scene(pos-e.xyy),\n                          Scene(pos+e.yxy)-Scene(pos-e.yxy),\n                          Scene(pos+e.yyx)-Scene(pos-e.yyx)));\n}\n\n\n\n\n\n\n\n\n\n/////Raymarching\n\nmat3 cast_ray(in vec3 o, in vec3 dir, in float zNear, in float zFar){\n    float d = zNear;\n    float rho = 0.;\n    int refine = 0;\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = o + d * dir;\n        float dS = Scene(p);\n        d += dS *0.975;\n        if (d > zFar){d = -1.; break;}\n        \n        if (dS < SURF_DIST){break;}\n\n    }\n    \n    vec3 hit_position = o + d * dir;\n    vec3 hit_normal = normal(hit_position);\n    mat3 hit_data = mat3(vec3(d,d,d),\n                       hit_position,\n                       hit_normal);\n    return hit_data;   \n}\n\nfloat lights(in vec3 pos, in vec3 nor)\n{\n    vec3 sun_dir = normalize(vec3(1.,1.,2.));\n    \n    float l = AMB_LIGHT;\n    l += clamp(dot(nor, sun_dir), 0.0, 1.0 )   *   SUN_INT;\n    //calculate shading by taking the dot product of the sun direction and surface normal\n    //then clamping that between 0 and 1, and multiplying that by the sun intensity\n\n    mat3 ray_out = cast_ray(pos+nor*2.*SURF_DIST, sun_dir, 0.0, 15.0); //Shadow ray\n    if (ray_out[0].x > 0.){l = AMB_LIGHT;} //if the ray hits anything, shadow\n\n    return l;\n}\n\nvec4 raymarch(in camera camera, in vec2 fragCoord)\n{\n    vec4 col = vec4(0.0);\n    \n    float fov = deg_to_rad(camera.FOV)/2.;\n    vec3 view_vector = vec3((2.0*fragCoord-iResolution.xy)/iResolution.x*sin(fov), max(cos(fov), 0.0));\n    view_vector = normalize(view_vector);\n    vec3 ray_direction = rotate_position_quat(view_vector, camera.orientation);\n    //^Calculate Ray Direction^\n    \n    mat3 ray_out = cast_ray(camera.position, ray_direction, camera.zNear, camera.zFar);\n    float scene_depth = ray_out[0].x;\n    vec3 hit_position = ray_out[1];\n    vec3 hit_normal = ray_out[2];\n    \n    if (scene_depth > 0.){// Ray hit any object, if not, skybox color\n        col = vec4(lights(hit_position, hit_normal)) * color(hit_position);\n             //^Shading^                           ^Get object color^\n    } else {col = 0.1*vec4(1.0,0.5,0.0,0.5) * AMB_LIGHT;}//Skybox color\n    \n    \n    vec3 reflectDir = reflect(ray_direction, hit_normal);\n    \n    float reflected_amount = 1.;//Mixing value\n    if (color(hit_position).w > 0.0){//If surface it reflective\n        for (int i; i < REFL_COUNT; i++){//Calculate REFL_COUNT amount of reflections\n            ray_out = cast_ray(hit_position+ length(hit_position-camera.position)*hit_normal*0.0015,\n                            reflectDir, camera.zNear, camera.zFar);\n            vec3 prev_pos = hit_position;\n            hit_position = ray_out[1];\n            hit_normal = ray_out[2];\n            reflected_amount *= color(prev_pos).w; //multiply reflectiveness of hit position for mixing\n            if (ray_out[0].x > 0.){//if ray hits anything, else skybox color\n                col = mix(col, vec4(lights(hit_position, hit_normal)) * color(hit_position), reflected_amount);\n                //^mix color with the reflected color mix is the same thing as lerp\n            } else {col = mix(col,  0.1*vec4(1.0,0.5,0.0,0.5) * AMB_LIGHT, reflected_amount); break;}\n            reflectDir = reflect(reflectDir, hit_normal);\n\n        }\n    }\n    \n    //vec4(0.52,0.8,0.92,1.)\n    \n    if (scene_depth == -1.){col = 0.1*vec4(1.0,0.5,0.0,0.5);}\n    \n    return smoothstep(vec4(0.,0.,0.,0.), vec4(1.,1.,1.,1.), col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = getTime();\n    \n    vec3 cam_pos = vec3(sin(time)*5.5, 0.0, cos(time)*5.5);\n    cam_pos = vec3(cam_pos.x,1.05,cam_pos.z);\n    \n    vec4 cam_quat = axis_to_quaternion(vec3(0.,1.,0.), mod(time+PI,2.*PI));\n    \n    camera Cam = camera(cam_pos, cam_quat, CAMFOV, 0.01, 60.0);\n    \n    \n    vec4 col = raymarch(Cam, fragCoord);\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Camera Settings\n#define CAMFOV 55.\n\n//Render Settings\n#define MAX_STEPS 175\n#define SURF_DIST .005\n#define REFL_COUNT 1\n\n\n\n//Scene settings\n#define AMB_LIGHT 0.4\n#define SUN_INT 0.8\n#define TIME_SCALE 0.125\n\n//Constants\n#define PI 3.14159265359\n#define bigNum 1e38\n\n\n\n//Structs\nstruct camera\n{\n    vec3 position;\n    vec4 orientation;\n    float FOV;\n    float zNear;\n    float zFar;\n};","name":"Common","description":"","type":"common"}]}