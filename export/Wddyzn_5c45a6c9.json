{"ver":"0.1","info":{"id":"Wddyzn","date":"1600279751","viewed":121,"name":"Something beats","username":"bitblast","description":"Just playing around to unwind a bit","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","abstract","trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .7;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= .5 * (iResolution.x / iResolution.y - 1.); // aspect\n    \n    uv *= 3.; // tiles\n    uv += vec2(3. * time, 3. * time + .7 * sin(time * 3.)); // scrolling\n    \n    float k = 4.;\n    float t = (1.1*time + sin(.1*time)) * 10.;\n    float off_r = gain(clamp(abs(mod(1.1*time-1.5, 4.)-2.)-.5, 0., 1.), k);\n    float off_g = gain(clamp(abs(mod(1.1*time+1.5, 4.)-2.)-.5, 0., 1.), k);\n    \n  \tfloat r = the_func(uv + vec2(0.01 * cos(off_g * PI), -fract(off_r+.5)+.5), time);\n  \tfloat g = the_func(uv + vec2(-fract(off_g+.5)+.5, 0.01 * cos(off_r * PI)), time);\n  \tfloat b = the_func(uv, iTime);\n    vec3 col = vec3(0.);\n    col = vec3(r, g, b);\n    // col.xy = fract(voro_uv);\n    //col.xy = random2(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi(vec2 i_st, vec2 f_st, float anim) {\n    float m_dist = 1.;  // minimum distance\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(anim + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\treturn m_dist;\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvec2 gain2(vec2 v, float k)\n{\n\treturn vec2(gain(v.x, k), gain(v.y, k));\n}\n\nfloat parabola( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nvec2 parabola2( vec2 x, float k )\n{\n    return vec2(parabola(x.x, k), parabola(x.y, k));\n}\n\nfloat the_func(vec2 uv, float iTime)\n{\n    vec2 uv_i = floor(uv);\n    vec2 uv_f = fract(uv);\n    float gain_k = mix(0.2, 0.4, 0.5 * (1. - cos(iTime * 2.4 * (mod(uv_i.x, 4.) + 2.) + 3. * uv_i.y)));\n    vec2 uv_sf = gain2(uv_f, gain_k);\n    vec2 voro_uv = (uv_i + uv_sf) * 40.; // Voronoi subtiles\n    voro_uv += (random2(uv_i + 0.3f) - .5) * iTime * 20.;\n    float voro = voronoi(floor(voro_uv), fract(voro_uv), iTime);\n    \n    vec2 center = parabola2(uv_f, 0.4/gain_k);\n    float val = voro * center.x * center.y;\n\treturn val;\n}\n\n","name":"Common","description":"","type":"common"}]}