{"ver":"0.1","info":{"id":"tdS3zw","date":"1548409857","viewed":235,"name":"Temple of Time - Variation","username":"Flopine","description":"This is a variation on a shader made during a twitch live session : https://www.shadertoy.com/view/td23zD \nI really like this cheap \"old school effect\" :D","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","zelda","posterize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// This is a variation on this shader : https://www.shadertoy.com/view/td23zD \n// Made during a twitch live session :) \n\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define ITER 64.\n#define time (iTime*0.3)\n#define PI 3.141592\n\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 *(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    p.xz *= rot(-iTime);\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat column (vec3 p)\n{\n    float width = 5.;\n    float c1 = length(p.xz)-width;\n    \n    p.xz *= rot(p.y*0.2);\n    p.xz *= rot(iTime);\n    p.xz = moda(p.xz, PI);\n    p.x -= width;\n    float c2 = length(p.xz)-2.;\n    \n    return min(c1, c2);\n}\n\nfloat g2 = 0.;\nfloat columns (vec3 p)\n{\n\tp.xz = moda(p.xz, PI/3.);\n    p.x -= 60.;\n    float d = column(p);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat room (vec3 p)\n{\n    float g = abs(p.y+5.)-0.5;\n    float h = sdHexPrism(p.xzy, vec2(60.));\n    return min (g,-h);\n}\n\nfloat pedestal (vec3 p)\n{\n    vec3 new_p = vec3(p.x, p.z, p.y+4.);\n    float width = 15.;\n    float height = 0.2;\n    float st = 2.;\n\n    float hexs = sdHexPrism(new_p, vec2(width, height));\n\n    for (float i = 0.; i<2.; i++)\n    {\n        new_p.z -= 0.7;\n        width -= 4.+i;\n        height += 0.1+i;\n        hexs = stmin(hexs, sdHexPrism(new_p, vec2(width, height)), 1., st);\n        st++;\n    } \n    return hexs;\n}\n\nfloat g1 = 0.;\nfloat triforce (vec3 p)\n{\n    p.y -= 7.;\n    float tri1 = sdTriPrism(p, vec2(3,0.3));\n    float tri2 = sdTriPrism(vec3(p.x-2.5, p.y+4.5, p.z), vec2(3,0.3));\n    float tri3 = sdTriPrism(vec3(p.x+2.5, p.y+4.5, p.z), vec2(3,0.3));\n    float d = min(tri3,min(tri1, tri2));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    float r = stmin(room(p), columns(p), 10., 3.);\n    float hs = pedestal(p);\n    return min(triforce(p),stmin(hs, r, 0.5, 2.));\n}\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3 (SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                          SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                          SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                          )\n                    );\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvec3 point_light(vec3 p, vec3 n)\n{\n    vec3 lpos = vec3(0, 8, 0);\n    vec3 ldir = normalize(lpos - p);\n    float ldist = length(lpos - p);\n    float dotNL = dot(n, ldir)*0.5+0.5;\n\treturn (vec3(.8, .8, 0) * dotNL) / (.007 * ldist * ldist);\n}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n    vec3 forward = normalize(target - ro);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross (forward, left));\n    return normalize(forward*fov+ left*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    //pixellate\n    uv = floor(uv * 100.)/100.;\n    \n    vec3 ro = vec3(-18.*cos(time),5., -18.*sin(time)); vec3 p = ro; \n    vec3 target = vec3(0.);\n    vec3 rd = get_cam(ro, target, uv, 1.);\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    float dither = random(uv);\n       \n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            vec3 n = get_normals(p);\n            \n            // hemi light\n            col = mix(vec3(0.5, 0.1, 0.5), vec3(0.3, 0.8, 0.9),lighting(n, vec3(1., 10.,-2.)));\n            \n            // point light\n            col += point_light(p, n);\n            \n            // ao\n            shad = i/ITER;\n            col *= (1.- shad);\n            break;\n        }\n        d *= 0.9 + dither*0.2;\n        p += d*rd;\n    }\n    \n    float t = length(p-ro);\n\tcol += g1*vec3(1.,1.,0.)*0.8;\n    col += g2*0.1;\n    col = mix(col, vec3(0.5, 0.8, 0.9), (1.-exp(-0.002*t*t))*0.8);\n    \n    // posterize\n    col = floor(col*10.)/10.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"}]}