{"ver":"0.1","info":{"id":"Mt2XRt","date":"1445969431","viewed":1538,"name":"ImplicitBluePrint","username":"jt","description":"A simple (inefficient) proof-of-concept implicit-surface ray-tracer (originally written as test for my ShaderView-project).\n","likes":43,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","implicitsurface","simplified","proofofconcept"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Simple (inefficient) proof-of-concept implicit-surface ray-tracer by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat fn(vec3 v)\n{\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    //x = sfract(x * 2.0, 1.0);\n    return min(min(x * x + y * y + z * z - 0.5, x * x + y * y - 0.125), min(x * x + z * z - 0.125, y * y + z * z - 0.125));\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec3 tex(vec3 v)\n{\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    //float d = exp(-pow(z * 20.0 + (2.0 * fract((0.5 + 0.5 * time) / 4.0) - 1.0) * 4.0 * 5.0, 2.0));\n    float d = exp(-pow(abs(z * 20.0 + sfract(iTime, 4.0) * 5.0), 2.0));\n    //x += 0.01 * time;\n    //y += 0.01 * time;\n    z += 0.1 * iTime;\n    x = (x * 8.0);\n    y = (y * 8.0);\n    z = (z * 8.0);\n    float q = 0.0;\n    q = max(q, comb(x, 10.0));\n    q = max(q, comb(y, 10.0));\n    q = max(q, comb(z, 10.0));\n    float w = 1.0;\n    w = min(w, max(comb(x, 10.0), comb(y, 10.0)));\n    w = min(w, max(comb(y, 10.0), comb(z, 10.0)));\n    w = min(w, max(comb(z, 10.0), comb(x, 10.0)));\n    return (w + vec3(0.0, q, 0.5 * q)) + d * 5.0;\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float t = iTime * 0.1;\n    vec3 v;\n    v.x = uv.x * cos(t) + uv.y * sin(t); // uv.x;\n    v.y = uv.x * -sin(t) + uv.y * cos(t); // uv.y;\n    v.z = depth;\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n\n    return iso;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.1;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const int depth = 256;\n    float m = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for(int layer = 0; layer < depth; layer++) // slow...\n    {\n        vec3 v = camera(uv, 2.0 * float(layer) / float(depth) - 1.0);\n\n        if(abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0)\n            continue;\n\n        if(abs(fn(v)) < 0.05)\n        {\n            m = 2.0 * float(layer) / float(depth) - 1.0;\n            color = tex(v);\n        }\n    }\n    \n    fragColor = vec4(color * vec3(m), 1.0);\n}\n","name":"","description":"","type":"image"}]}