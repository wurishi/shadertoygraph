{"ver":"0.1","info":{"id":"ssKfDW","date":"1658245847","viewed":47,"name":"Dice Raymarching","username":"rayworld_dev","description":"Dice implemented using raymarching. Phong shading ilumination, fresnel with cubemap reflection, ambient occlusion, noise.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265\n\n/*************/\n/*** Noise ***/\n/*************/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 0.7;\n    float frequency = .0;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 4.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n/*************/\n/*** SDFs ***/\n/*************/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdDice(vec3 pos)\n{\n    // 1\n    float dice1 = sdSphere(pos + vec3(0.4, 0., 0.), .1);\n\n    // 2\n    float dice2_1 = sdSphere(pos + vec3(0.25, -0.4, 0.25), .1);\n    float dice2_2 = sdSphere(pos + vec3(-.25, -0.4, -.25), .1);\n    float dice2 = max(-dice2_1, -dice2_2);\n\n    // 3\n    float dice3_1 = sdSphere(pos + vec3(0.0, 0.0, 0.4), .1);\n    float dice3_2 = sdSphere(pos + vec3(-.25, -0.25, .4), .1);\n    float dice3_3 = sdSphere(pos + vec3(.25, 0.25, 0.4), .1);\n    float dice3 = max(max(-dice3_1, -dice3_2), -dice3_3);\n    \n    // 4\n    float dice4_1 = sdSphere(pos + vec3(0.25, 0.25, -0.4), .1);\n    float dice4_2 = sdSphere(pos + vec3(-.25, -0.25, -.4), .1);\n    float dice4_3 = sdSphere(pos + vec3(-.25, 0.25, -0.4), .1);\n    float dice4_4 = sdSphere(pos + vec3(.25, -0.25, -0.4), .1);\n    float dice4 = max(max(max(-dice4_1, -dice4_2), -dice4_3), -dice4_4);\n    \n    // 5\n    float dice5_1 = sdSphere(pos + vec3(0.25, 0.4, 0.25), .1);\n    float dice5_2 = sdSphere(pos + vec3(-0.25, 0.4, -0.25), .1);\n    float dice5_3 = sdSphere(pos + vec3(-0.25, 0.4, 0.25), .1);\n    float dice5_4 = sdSphere(pos + vec3(0.25, 0.4, -0.25), .1);\n    float dice5_5 = sdSphere(pos + vec3(0.0, 0.4, 0.0), .1);\n    float dice5 = max(max(max(max(-dice5_1, -dice5_2), -dice5_3), -dice5_4), -dice5_5);\n    \n    // 6\n    float dice6_1 = sdSphere(pos + vec3(-0.4, -0.25, -0.25), .1);\n    float dice6_2 = sdSphere(pos + vec3(-0.4, -0.25, 0.), .1);\n    float dice6_3 = sdSphere(pos + vec3(-0.4, -0.25, 0.25), .1);\n    float dice6_4 = sdSphere(pos + vec3(-0.4, 0.25, -0.25), .1);\n    float dice6_5 = sdSphere(pos + vec3(-0.4, 0.25, 0.), .1);\n    float dice6_6 = sdSphere(pos + vec3(-0.4, 0.25, 0.25), .1);\n    float dice6 = max(max(max(max(max(-dice6_1, -dice6_2), -dice6_3), -dice6_4), -dice6_5), -dice6_6);\n    \n    return max(-dice1, max(dice2, max(dice3, max(dice4, max(dice5, dice6)))));\n}\n\n\nvec3 rotate(vec3 pos, vec3 angles)\n{\n    mat3 rotx = mat3(\n        1.0, 0.0,            0.0,\n        0.0, cos(angles.x), -sin(angles.x),\n        0.0, sin(angles.x),  cos(angles.x)\n    );\n    \n    mat3 roty = mat3(\n        cos(angles.y),  0.0, sin(angles.y),\n        0.0,             1.0, 0.0,\n        -sin(angles.y), 0.0, cos(angles.y)\n    );\n    \n    mat3 rotz = mat3(\n        cos(angles.z), -sin(angles.z), 0.0,\n        sin(angles.z),  cos(angles.z), 0.0,\n        0.0,             0.0,            1.0\n    );\n    \n    return pos * rotz * roty * rotx;\n}\n\nfloat map(vec3 pos)\n{   \n    float rot_angle = iTime * .2;\n    \n    pos = rotate(pos, vec3(rot_angle, rot_angle, 0.0));\n    \n    float dRoundBox = sdRoundBox(pos, vec3(.4), 0.05);\n    float d = max(dRoundBox, sdDice(pos));\n       \n    return d;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    const float smallStep = 0.0001;\n    \n    // Gradient calculation.\n    float x = map(pos + vec3(smallStep, 0.0, 0.0)) - map(pos);\n    float y = map(pos + vec3(0.0, smallStep, 0.0)) - map(pos);\n    float z = map(pos + vec3(0.0, 0.0, smallStep)) - map(pos);\n\n    return normalize(vec3(x, y, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Camera.\n    vec3 camera_pos = vec3(0.2,.0, -1.2);//vec3(sin(iTime*.5), 0.0, cos(iTime*.5));\n    vec3 camera_target = vec3(0.0);\n    vec3 camera_forward = normalize(camera_target - camera_pos);\n    vec3 camera_right = normalize(cross(camera_forward, vec3(0.0, 1.0, 0.0)));\n    vec3 camera_up = normalize(cross(camera_right, camera_forward));\n    \n    vec3 ray_dir = normalize(vec3(\n        uv.x * camera_right +\n        uv.y * camera_up    +\n        1.0 * camera_forward\n    ));\n    \n    vec3 col = vec3(0.0);\n    \n    // Ray marching algorithm\n    int iterations = 512;\n    float total_distance = 0.0;\n    for (int i = 0; i < iterations; ++i)\n    {\n        vec3 pos = camera_pos + total_distance * ray_dir;\n        \n        float dist = map(pos);\n        if (dist < 0.0001)\n        {\n            vec3 normal = calcNormal(pos)/* *.5 + .5*/;\n            \n            // Calculate lighting.\n            vec3 light_pos = vec3(0.0, 0.0, -1.);\n            vec3 light_dir = normalize(light_pos - camera_target);\n            \n            // base color\n            float color_frequency = iTime * .5;            \n            vec3 base_color = vec3(clamp(abs(sin(color_frequency)), .2, .8), clamp(abs(cos(color_frequency)), .2, .8), abs(sin(color_frequency) + cos(color_frequency)));\n            vec3 light_color = vec3(1.0/*abs(sin(colorFrequency)), abs(cos(colorFrequency)), abs(sin(colorFrequency) + cos(colorFrequency))*/);\n            \n            // ambient.\n            float kA = .2;\n            vec3 ambient = kA * light_color;\n            \n            // diffuse\n            float kD = 1.0;\n            float diff = max(dot(normal, light_dir), 0.0);\n            vec3 diffuse = kD * diff * light_color;\n            \n            // specular\n            float kS = 5.0;\n            vec3 reflect_dir = reflect(light_dir, normal);\n            float spec = pow(max(0.0, dot(ray_dir, reflect_dir)), 256.0);\n            vec3 specular = kS * spec * light_color;\n            \n            mat2 rot = mat2(\n                 cos(iTime*.2), sin(iTime*.2),\n                -sin(iTime*.2), cos(iTime*.2)\n            );\n            \n            // noise\n            float noise_displacement = mix(.9, 1., sin(iTime*.5) * .5 + .5);\n            vec3 noise_color = vec3(fbm(vec2(length(sin(pos.xyz) * noise_displacement) * .55))) * 2.;\n            \n            // cubemap reflection\n            float reflection_intensity = 1.0;\n            vec3 cubemap_reflection = texture(iChannel0, reflect(ray_dir, normal)).rgb * reflection_intensity;\n            \n            // ambient occlusion\n            float ao = clamp(map(pos + normal * 3.0) / 3.0,0.,1.);\n\n            // fresnel\n            float fresnel = pow(1.0 - dot(normal, -camera_forward), 1.5);\n       \n            col = (ambient + diffuse + specular) * ao * noise_color /** cubemap_reflection*/ * base_color;\n            col = mix(col, .75*cubemap_reflection, fresnel);\n            //col = vec3(ao);\n            //col = vec3(fresnel);\n            //col = ambient;\n            //col = diffuse;\n            //col = specular;\n            //col = (ambient + diffuse + specular) * baseColor;\n            //col = cubemap_reflection;\n            //col = noise_color;\n            //col = (ambient + diffuse + specular) * ao * noise_color * cubemap_reflection;\n            \n            // we need the rotation of the dice.\n            float rot_angle = iTime * .2;\n            pos = rotate(pos, vec3(rot_angle, rot_angle, 0.0));\n            \n            float dist_to_center = max(distance(camera_target.z, pos.z), max(distance(camera_target.y, pos.y), distance(camera_target.x, pos.x)));\n            if (dist_to_center < .425)\n            {\n                col = (ambient + diffuse + specular) * ao /** cubemap_reflection*/ * vec3(0.75);\n                col = mix(col, .75*cubemap_reflection, fresnel);\n            }\n            \n            break;\n        }\n        else\n        {\n            col = texture(iChannel0, ray_dir).rgb;\n        }\n        total_distance += dist;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}