{"ver":"0.1","info":{"id":"WsKfzt","date":"1608078221","viewed":120,"name":"space rock  (vlllll)","username":"valalalalala","description":"A fun, silly little space scene. Changed the way the stars are done based on the feedback. Few odd clipping issues to resolve...","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["cartoon","space","stars","ufo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"space rock\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// based off https://www.shadertoy.com/view/tsyfDw\n\n#define RAY_MARCH_STEPS           133\n#define RAY_MARCH_TOO_FAR         float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE           0.0071\n#define PI2                       6.283185307179586\n\n#define VECTOR_PROJECTION(a,b,p) clamp( dot( p - a, b - a ) / dot( b - a, b - a ), 0., 1. )\n#define TRIG(len, angle)         (len * vec2( cos( angle ), sin( angle ) ))\n\n/////////////////////////////////////////////////////////\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n/////////////////////////////////////////////////////////\n\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3(sin(roll), cos(roll), 0.0);\n\tvec3 zz = normalize(target - origin);\n\tvec3 xx = normalize(cross(zz, up));\n\tvec3 yy = normalize(cross(xx, zz));\n\treturn mat3( xx, yy, zz );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n\nfloat starSegmentSDF( vec3 point, vec3 a, vec3 center, float thickness ) {\n    float h = VECTOR_PROJECTION( a, center, point );\n    vec3 q = a + ( center - a ) * h;\n    h = pow( h, 0.7 ) * .8;      \n    return length( point - q ) - thickness * h;\n}\n\nfloat starSDF( vec3 point, vec3 center, float len, float thickness ) {\n    vec3 a0 = vec3( +0.000 * len, +1.000 * len, center.z ); // @ r:+1.570 , d:90\n    vec3 a1 = vec3( -0.952 * len, +0.309 * len, center.z ); // @ r:+2.827 , d:162\n    vec3 a2 = vec3( -0.588 * len, -0.810 * len, center.z ); // @ r:+4.084 , d:234\n    vec3 a3 = vec3( +0.587 * len, -0.810 * len, center.z ); // @ r:+5.340 , d:306\n    vec3 a4 = vec3( +0.951 * len, +0.309 * len, center.z ); // @ r:+6.597 , d:378\n    \n    float d0 = starSegmentSDF( point, a0, center, thickness );\n    float d1 = starSegmentSDF( point, a1, center, thickness );\n    float d2 = starSegmentSDF( point, a2, center, thickness );\n    float d3 = starSegmentSDF( point, a3, center, thickness );\n    float d4 = starSegmentSDF( point, a4, center, thickness );\n\n    return min( d0, min( d1, min( d2, min( d3, d4 ) ) ) );\n}\n\nfloat starSDF_old( vec3 point, vec3 center, float len, float thickness ) {\n    const int count = 5;\n    float d = RAY_MARCH_TOO_FAR;\n    for ( int i = 0 ; i < count ; i++ ) {\n        float angle = PI2 * float( i ) / float( count ) + PI2 / float ( count ) * 0.25;\n        vec3 a = vec3( center.xy + TRIG(len, angle), center.z );\n        float h = VECTOR_PROJECTION( a, center, point );\n        vec3 q = a + ( center - a ) * h;\n        h = pow( h, 0.7 ) * .8;\n        d = min( d, length( point - q ) - thickness * h );\n    }\n    \n    return d;\n}\n\nfloat ufoSDF( vec3 point, vec3 center, float angle, float len ) {\n    vec2 o = vec2( cos( angle ), sin( angle ) );    \n    vec3 p = vec3( center.xy + len * o, center.z );\n    \n    float h = VECTOR_PROJECTION( p, center, point );\n    //h = clamp( h, 0.6, 1. ); // <-- fun\n    h = clamp( h, 0.1, 1. );\n    \n    vec3 q = mix( \n        p + h * ( center - p ),\n        p - h * ( center - p ) * 2.5,\n        step(.8,h)\n    );\n    \n    float r = len * pow(h,1.85) * 1.3;\n    r += 0.023 * (1.-step(0.6,h)+step(.9,h));\n    r += 0.2*h;\n    \n    return length( point - q ) - r ;\n}\n\nfloat planetSDF( vec3 point ) {\n    vec2 rot = point.xy + TRIG(1.,iTime*0.235);\n    float n = \n        + 0.10 * noise( rot * 3. )\n        + 0.03 * noise( rot * 9. )\n        + 0.01 * noise( rot * 23. )\n    ;\n    return length(point) - 1.1 + 2.9 * n;\n}\n\nfloat stars( vec3 point ) {\n    float t = iTime * .061;\n    float scale = .7;\n\n    vec3 i_point = floor( point * scale );\n    vec3 f_point = fract( point * scale );\n    f_point.z = i_point.z = point.z + 1.5;\n \n    float o = 3.*noise( i_point.xy * 721.3789 + t );\n    o = clamp( o, -.3, +.3 ) + .55;\n\n    return starSDF( f_point - o, vec3(.0), .13, .07 );\n}\n\n\nfloat starsx( vec3 point ) {\n    float t = iTime * 2.;\n    float scale = 1.2;\n    \n    float n = 0.1 * noise( 444. * (point.xy + t ) );\n    point.xy = fract( ( point.xy + TRIG(.4,t+0.2*point.y) ) * scale );\n\n    return starSDF( point -.4, vec3(.0,.0,-1.3), .19, .07 );\n}\n\nfloat stars_old( vec3 point ) {\n    float t = iTime * 2.;\n    float scale = .8;\n    \n    vec3 qq = floor( point*scale );\n    float nn = noise( 3. * floor( point.xy + t ) );\n   \n    vec3 c = vec3(.1+TRIG(.2,t*nn),-1.3);\n    \n    point.xy = fract( point.xy*scale );\n    //point.x += 0.7 * mod( floor( qq.y ), 2. );\n\n    return starSDF( point -.5, c, .19, .07 );\n    \n    \n\n    float d = RAY_MARCH_TOO_FAR;\n    const int rows = 3;\n    const int cols = 5;\n    \n\n    \n    for ( int row = 0 ; row < rows ; row++ ) {\n        float r = float( row ) / float( rows );\n        for ( int col = 0 ; col < cols ; col++ ) {\n            float c = float( col ) / float( cols );\n            c -= 0.25*mod(r,0.5);\n            \n            vec3 s = vec3( c * 9.4 - 3.8, r * 6.3 - 1.9, -1.3 );\n            s = vec3( c * 1., r * 6.3 - 1.9, -1.3 );\n            \n            float n = noise( 1.2 * ( s.xy + t + r + c ) );\n            s.xy += TRIG(.3,n * PI2 );\n            \n            d = min( d, starSDF( point, s, .19, .07 ) );\n            break;\n        }\n        break;\n    }   \n    \n    vec2 n = vec2( d, -d ) + 0.4 * abs(sin(t) ) + point.xy;\n    float sparkle = fract( noise( 133. * n ) );\n    \n    return d - .003 * sparkle;\n}\n\nfloat ufo( vec3 point ) {\n    vec2 t = TRIG( 1., iTime  *.8);\n    vec3 u = vec3( t.x * 3., t.x * 0.2, 1.5 + t.y * 1. );\n    //u = vec3(.2,-.1,2.8);\n    float w = 1.57 + 0.02 - 0.04 * sin( iTime * 8. );\n    return ufoSDF( point, u, w, .08 ); \n}\n\n// this is kind of gross.. :-(\nint whatsClosest( vec3 point ) {\n    int what = 0;\n    float d = RAY_MARCH_TOO_FAR;\n    float q;\n    \n    q = planetSDF( point );\n    if ( q < d ) {\n        what = 1;\n        d = q;\n    }\n    \n    q = stars( point );\n    if ( q < d ) {\n        what = 2;\n        d = q;\n    }\n    \n    q = ufo( point );\n    if ( q < d ) {\n        what = 3;\n        d = q;\n    }\n    return what;\n}\n\nfloat sceneDistance( vec3 point ) {\n    float d = planetSDF( point );\n    d = min( d, stars( point ) );\n    d = min( d, ufo( point ) );   \n    return d;\n}\n\nfloat rayMarch( in vec3 origin, in vec3 direction ) {\n    float total = .0;\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total;\n                \n        float current = sceneDistance( point );\n        total += current;\n        if ( total > RAY_MARCH_TOO_FAR || abs(current) < RAY_MARCH_CLOSE ) {\n            break;\n        }\n    }\n    return total;\n}\n\nvec3 sceneNormal(vec3 p) {\n\tfloat d = sceneDistance(p);\n    vec2 e = vec2(RAY_MARCH_CLOSE, .0);\n    return normalize( d - vec3(\n        sceneDistance(p-e.xyy),\n        sceneDistance(p-e.yxy),\n        sceneDistance(p-e.yyx))\n    );\n}\n\nfloat pointLight( vec3 point, vec4 light ) {\n    vec3 normal = sceneNormal( point );\n    \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n    towardLight = normalize( light.xyz - point );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight );\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point ) {\n    vec4 light    = vec4( .0, 7., 1., 6. );\n    float ambient = 0.07;\n    float gamma   = 1.33;\n    \n    float lighting = pointLight( point, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n    \n    float d = dot( point, point );\n    \n    // ...\n        \n    vec3 rock = 1. * vec3( .9, .2, .1 );\n    vec3 star = 2. * vec3( .9, .9, .3 );\n    vec3 ufo  = 2. * vec3( .5, .6, .8 );\n    \n    vec3 color = rock;\n    switch( whatsClosest( point ) ) {\n        case 2: color = star; break;\n        case 3: color = ufo; break;\n    }\n    \n\treturn vec3( color * ambient + color * lighting );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( 2. * gl_FragCoord.xy - iResolution.xy ) / iResolution.y; \n    \n    // camera settings\n    \n    float t = 0. * iTime + 1.57;\n\tvec3  eye  = vec3( 4. * cos( t ), 4., 4. * sin( t ) );  \n    eye = vec3( 0., 0., 4. );\n\tvec3  look = vec3( .0 );\n\tfloat roll = 0.2 * cos( iTime );\n    float zoom = 0.3 + 4. * ( 1. - abs( sin( iTime * .66 ) ) );\n    zoom = 2.2;\n\n    // setup and use the camera\n    \n\tmat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = vec3( uv.xy, zoom );\n    direction = normalize( camera * direction );\n    \n    // do the ray marching (sphere tracing)\n\n    float distance_ = rayMarch( eye, direction );\n    float tooFar = step( RAY_MARCH_TOO_FAR, distance_ );\n    vec3 point = eye + direction * distance_;\n    \n\t// the end\n    vec3 background = vec3(0.);\n    vec3 blue = vec3( .0, .0, .9 ); \n    \n    vec2 at = uv + cos( iTime * .1 );\n    background += blue * (0.1 + 0.9 * noise( at * 4. ) );\n    \n    background += vec3(.27)*step(0.5,noise(-at*99.));\n    \n    \n    fragColor = vec4( mix( colorPoint( point ), background, tooFar ), 1. );\n}","name":"Image","description":"","type":"image"}]}