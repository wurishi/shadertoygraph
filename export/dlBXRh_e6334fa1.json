{"ver":"0.1","info":{"id":"dlBXRh","date":"1687047055","viewed":66,"name":"Hex Lens Noise","username":"westgarthb","description":"An emulation of glass refraction with hexagonal lenses and animated noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","refraction","glass","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec4 noise( in vec3 x )\n{\n    // grid\n    x *= 2.0;\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = va + \n              u.x*(vb-va) + \n              u.y*(vc-va) + \n              u.z*(ve-va) + \n              u.x*u.y*(va-vb-vc+vd) + \n              u.y*u.z*(va-vc-ve+vg) + \n              u.z*u.x*(va-vb-ve+vf) + \n              u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n              \n    vec3 d = ga + \n             u.x*(gb-ga) + \n             u.y*(gc-ga) + \n             u.z*(ge-ga) + \n             u.x*u.y*(ga-gb-gc+gd) + \n             u.y*u.z*(ga-gc-ge+gg) + \n             u.z*u.x*(ga-gb-ge+gf) + \n             u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh) +   \n             \n             du * (vec3(vb-va,vc-va,ve-va) + \n                   u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + \n                   u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + \n                   u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) );\n                   \n    return vec4( v, d );                   \n}\n\n\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n    vec2 k = 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy);\n\tfloat e = dot( ma,  k);\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4((fract(p) - 0.5)*vec2(1.0,0.85), e, f );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n    \n    vec4 hex = hexagon(p*15.0);\n    float di = (hex.w);\n    \n    float rod_x = hex.x;\n    float rod_y = hex.y;\n    vec3 n = vec3(0.0, 0.0, 1.0);\n    if(di < 0.5)\n    {\n        float z = sqrt(1.0 - di*di);\n        n = normalize(vec3(rod_x, rod_y, -z));\n        n = mix(vec3(0.0, 0.0, -1.0), n, smoothstep(0.0, 0.3, hex.z));\n    }\n        \n    float refrac = 0.2;\n    vec3 refracted_ray = mix(n, rd, refrac);\n    float z_dist = 0.8 / (refracted_ray.z + 0.00001);\n    vec3 pos = vec3(p, 0.0) + z_dist*refracted_ray;\n    \n    float g = 1.0 - abs(n.z);\n    g = g * 0.5 / (g * 0.5 - g + 1.0);\n    float glass = (1.0-1.2*g);\n\n    vec3 c3 = mix(vec3(0.0), vec3(1.0), smoothstep(-0.05, 0.0, noise(vec3(pos.xy, iTime*0.2)).x));\n    \n\n    vec3 col = glass - 1.0 + c3;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}