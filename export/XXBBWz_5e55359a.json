{"ver":"0.1","info":{"id":"XXBBWz","date":"1729317800","viewed":149,"name":" ripples   (mouse)","username":"shadertoyjiang","description":"Learned from pyBlob's works:\nhttps://www.shadertoy.com/view/M3sBD2 \n\nmouse:\nAdjust transparency in the x direction; the further left, the more transparent.\nThe y direction is divided into three rows:\nRow 1: dark outlines\nRow 2: bright outlines\nRow 3: rand","likes":18,"published":3,"flags":32,"usePreview":0,"tags":["circle","loopless"],"hasliked":0,"parentid":"M3BfRw","parentname":"繁花玫瑰"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024-10-19 \n// 繁花玫瑰线 Fallen Rose\n\n//#define debug\n#define TAU 6.2831853\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    \n    O = T(U);\n    \n    //return; // debug: After commenting this line, the division of mouse operations is displayed.      \"\n    \n    //////#ifdef debug\n        vec2 R=iResolution.xy,\n             u = U/R.y,\n             k = R/R.y,\n             f = k/vec2(4,3),\n             g;\n             \n    //#ifndef debug            \n        if(length(round(iMouse.xy/R.y/f -vec2(4,0)))<.5) // The mouse shows the mouse operation area in the lower right corner.\n    //#endif\n        {     \n            g = u-round(u/f)*f;\n            g = abs(g);\n            float d =min(g.x,g.y);\n            if(length(g)<f.y*.2)\n            O = clamp(O,0.,1.),\n            O += 5. * clamp(exp(-880.*d),0.,1.);\n            O.xy += .5 * clamp(exp(-880.*abs(g.y)),0.,1.);\n        }\n    //////#endif\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2024-10-19\n// 繁花，玫瑰曲线\n// Learned from pyBlob's works\n// https://www.shadertoy.com/view/M3sBD2 - pyBlob\n#define TAU 6.2831853\nfloat NumberPerSecond = 20.;\n//                                     .9   .3  -.38\n#define transparency (length(iMouse.xy) < 2. ? .5 : 1.5 - iMouse.x / iResolution.x * 2.)\n#define BorderBrightnessID int(floor(iMouse.y / iResolution.y * 3.))\nvec4 rnd(float p) { // https://www.shadertoy.com/view/4djSRW - Dave_Hoskins\n        vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n        p4 += dot(p4, p4.wzxy + 33.33);\n        return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nint iii=0;\nvoid mainImage2(out vec4 O, in vec2 U) {\n        //U = floor(U/8.)*8.+.5;\n        float cct = iTime  + 10.,\n                ct = cct - T(U - U).x;\n        ct = .025;\n        float t =floor(iTime * NumberPerSecond);//+iDate.w*0.+iDate.w*0.)+ float(iFrame+5+iii);\n        \n        vec4 rnd1 = rnd(t + 1.23);//*.5+rnd(float(iii))*.5;\n        O = T(U);\n        O = mix(vec4(.5), O, exp(-.5 * ct));\n        float scl = 2.5;\n        vec2 R = iResolution.xy,\n                u = (U + U + .1 - R) / min(R.x, R.y) * scl,\n                p = u - (rnd(t).xy * 2. - 1.) * scl * 1.1 * R / min(R.x, R.y);\n        // Distributing N circles, with each circle's center at a distance r1 from the origin and a radius of r2. // 均匀地分布N个圆，以及每个圆的圆心距离原点r1，半径r2。\n        float N = 3. + floor(sqrt(rnd1.x * 256.)),\n                r1 = .05 + rnd1.y * .45,\n                r2 = .1 + rnd1.z * .6,\n                A = TAU / N,\n                a = atan(p.y, p.x) / A,\n                // i: Index number of the sector where the current point p is located.  // i: 输入点p 落在了第i个扇区上(当前扇区)\n                i = round(a),\n                //f = a-i,\n                h = length(p),\n                // cs: Let the input point p be the intersection point of two circles (length h). At this point, the cosine of the angle between the ray from p and the ray from one of the circle centers is cs. After listing and rearranging the relationships, we obtain.  // cs:设输入点p是两个圆的交点（长度h),此时射线p与其中一个圆心所在射线的夹角余弦值为 cs。列出关系式后整理得到。   h = r1 * cos(alpha) +(or-) sqrt( Square(r2) - Square( r1 * sin(alpha) ) )    ， cos(alpha)就是cs   \n                cs = (r1 * r1 - r2 * r2 + h * h) / (2. * h * r1);\n        // This bounding circle is for acceleration, so this sentence can be omitted. // 这个包围圆，是为了加速，可以不要这句。\n        if (h / 1.05 < r1 + r2) // \n        {\n                cs = clamp(cs, -1., 1.);\n                // b: The angle obtained from cs is only half the size of the angle A(==TAU/N). // b: 根据 cs 所求得的这个角只有角度A(等于TAU/N)的一半大小。\n                float b = acos(cs) / A,\n                        // j: The centroid of the closest circular ring to point p is ahead (or behind) the current sector (where point p is located) by j sectors. // j: 距离p最近的圆环的质心在当前扇区(p点所在的扇区)的前面(或后面) j 个扇区\n                        j = round(b);\n                // sign(a-i): Equivalent to (angle(p) > round(angle(p)) ? -1. : 1.).  Because of how round() works, the patterns of the two half-sectors are symmetrical, so one side's 'ahead' is the other side's 'behind' // sign(a-i): 因为round()的工作方式，两个半扇区的图案是对称的，所以其中一个的“超前”就是另一边的“落后”。 等价于 (angle(p)>round(angle(p)) ? -1. : 1.).\n                // sign(fract(b) - .5): equivalent to (mod(layer, 2.) == 0. ? -1. : 1.). The intervals are divided by the (all) intersection points of each circular ring on the scale of length(p). The circular rings used for two adjacent intervals are exactly in opposite directions. // sign(fract(b) - .5)：等价于 (mod(layer, 2.)==0. ? -1. : 1.)。在 length(p)这个刻度尺上以各圆环的（所有）交点划分区间。相临两个区间所要用到的圆环正好在相反方向。等价于 (mod(layer, 2.)==0. ? -1. : 1.)\n                j = i + j * sign((a - i) * (fract(b) - .5));\n                float dist = length(p - r1 * vec2(cos(j * A), sin(j * A))) - r2;\n                // render\n                float BorderLightTransmittance = min(exp(-80. * abs(dist)), 1.);\n                vec4 baseDiskColor = rnd(t + .34);\n                float layer = floor(b * 2.);\n                // Add 0.5 on the inner side of the circle and subtract 0.5 on the outer side, which fits perfectly.  // 在圆内侧加0.5，在外侧减去0.5，刚好衔接\n                layer -= .5 * sign(dist);\n                // When (layer < 0), it indicates the background. At other times, it represents the number of overlapping petals.  // 当 (layer < 0)时，它表示背景。其它时候表示花瓣重叠层数。\n                layer = clamp(layer, -1., N - 1.);\n                if (layer > -.5) // >= 0\n                        O = mix(pow(baseDiskColor * .9 + .1, vec4(layer)), O, transparency); //   .7);\n                if (BorderBrightnessID == 0) BorderLightTransmittance *= sign(rnd(t + .72).x - .5);\n                else if (BorderBrightnessID == 1) BorderLightTransmittance *= 1.;\n                else if (BorderBrightnessID == 2) BorderLightTransmittance *= -1.;\n                bool boolUsingDifferentColors = (rnd(t + .81).x > .5); //round(hs(t+.81).x)\n                //+=                 +0.6\n                //O += sign(hs(t+.72).x-.5)* edgeClr * (hs(t + .34-(.34+.6)*round(hs(t+.81).x)) * .5);\n                //O += (iMouse.y>R.y*.66 ? -1.:  (iMouse.y>R.y*.33 ? 1.:sign(hs(t+.72).x-.5)))* edgeClr * (hs(t + .34-(.34+.6)*round(hs(t+.81).x)) * .5);\n                //O += BorderBrightness * (hs(t + .34-(.34+.6)*float( usingDifferentColors )) * .5);\n                O += .5 * BorderLightTransmittance * mix(baseDiskColor, rnd(t + .65), float(boolUsingDifferentColors));\n        }\n        //if (length(U) < 2.) O = vec4(cct);\n}\n\nvoid mainImage(out vec4 O, in vec2 U){\n        mainImage2(O,U);\n        if(iFrame<2){\n             for(int i=min(0,iFrame);i<10;i++)\n             {\n                  iii=i-5;\n                  mainImage2(O,U*.04);\n             }\n        }\n}\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T(u) texture(iChannel0, (u)/iResolution.xy)","name":"Common","description":"","type":"common"}]}