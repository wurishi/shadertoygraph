{"ver":"0.1","info":{"id":"tldfzr","date":"1612433206","viewed":88,"name":"TicktokLogo","username":"leolu","description":"TicktokLogo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Cylinder{\n    float h;\n    float r;\n    vec3 center;\n};\n\nCylinder cylinder = Cylinder(4.0,1.0,vec3(-3.0,-2.1,-20.0));\n\nCylinder cylinder2 = Cylinder(2.0,1.5,vec3(-3.0,-2.1,-20.0));\n\nstruct Box{\n    // 长、高、宽\n    vec3 b;\n    vec3 center;\n};    \n\nBox box = Box(vec3(1.0,4.0,1.0),vec3(0.0,2.0,-20.0));\n\nBox bendBox = Box(vec3(2.5,1.0,1.0),vec3(2.2,3.4,-20.0));\n\nBox smallBox = Box(vec3(2.0,2.4,2.0),vec3(0.0,0.5,-20.0));\n\nfloat sdBox( vec3 p, Box box )\n{\n  p = p - box.center;\n \n  vec3 q = abs(p) - box.b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdBendBox(vec3 p,Box box )\n{\n    // 这里先做了相对box中心的偏移，因为我们希望下面的弯曲操作是对称的\n    p = p - box.center;\n    \n    // 在xy平面绕box中心旋转\n    p.xy = p.xy * rotate2d(0.4);\n    \n    // k 是弯曲的系数，通过调节k达到一个合适的弯曲效果\n    const float k = 0.15;\n    // 使用了点p的x坐标作为旋转的参数，这样最后得到的弯曲效果是对称的\n    mat2  rotateM = rotate2d(k*p.x);\n    // 在xy平面上旋转点p\n    vec3  q = vec3(rotateM*p.xy,p.z);\n    // 常规box的SDF\n    q = abs(q) - box.b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdSphere(vec3 point, Sphere sphere){\n    return length(point - sphere.position) - sphere.radius;\n}\n\nfloat sdCappedCylinder( vec3 p, Cylinder cylinder)\n{\n  p = p - cylinder.center;\n  p.yz = p.yz * rotate2d(radians(90.0));\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(cylinder.h,cylinder.r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 sphereNormal(vec3 point, Sphere sphere){\n    return normalize(point - sphere.position);\n}\n\nvec3 rotateCenter = vec3(0.0,2.5,-20.0);\n\nfloat map(vec3 point){\n\n    // 旋转的系数\n    float rotateArg = iTime * 0.5;\n    mat2 rotation = rotate2d(rotateArg);\n    \n    // 绕rotateCenter旋转\n    point = point - rotateCenter;\n    // 在xz平面进行旋转\n    point.xz = rotation*point.xz;\n    point = point + rotateCenter;\n\n\n\n    float d = sdBox(point,box);\n    float d1 = sdBendBox(point,bendBox);\n    // 上半部分\n    d = min(d,d1);\n    float d3 = sdCappedCylinder(point,cylinder);\n    float d4 = sdCappedCylinder(point,cylinder2);\n    // 下半部分\n    d3 = max(d3,-d4);\n    \n    float d5 = sdBox(point,smallBox);\n    \n    d3 = max(d3,-d5);\n    \n    return min(d,d3);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 point){\n    vec2 offset = vec2(0.0001,0.0);\n    return normalize(vec3(\n                     map(point+offset.xyy) - map(point-offset.xyy),\n                     map(point+offset.yxy) - map(point-offset.yxy),\n                     map(point+offset.yyx) - map(point-offset.yyx)));\n}\n\n\n\n\nbool sdScene(Ray ray,out vec3 point,out vec3 normal,out Material material){\n    // 最高迭代次数\n    int depth = 60;\n    // 射线累计前进的距离\n    float t = 0.0;\n    // 当前射线的末端，初始是射线的起点\n    point = ray.origin;\n    // 最大的距离，超过这个距离我们认为射线与场景没有交点\n    float maxDis = 100.0;\n    // materials(IvoryMaterial,RedMaterial,GlassMaterial,MirrorMaterial)\n    material = materials[3];\n    // 当前迭代point与场景最近平面的距离\n    float dis = 0.0;\n    while(depth > 0){\n        // 求射线当前迭代的末端\n        point = ray.origin + t*ray.dir;\n        \n        // 更新dis\n        dis = map(point);\n        \n        // dis足够小了，可以认为击中平面\n        if(abs(dis) < (0.0001*t)){\n            normal = getNormal(point);\n            return true;\n        }\n        \n        if(ray.isInside == 1){\n            // 在物体内部dis为负数，我们让射线继续前进\n            t -= dis;\n        } else {\n            t += dis;\n        }\n        \n        if(t > maxDis){\n            return false;\n        }\n        \n        depth--;\n    }\n    \n    return false;\n}\n\nvec3 cast_ray(in Ray ray){\n    \n    rays[0] = ray;\n    int depth = 0;\n    int start = 0;\n    int end = 1;\n    vec3 finalColor = vec3(0.0);\n    vec3 origin = vec3(0.0);\n    vec3 dir = vec3(0.0);\n    \n    while(depth < 5){\n        \n        for(int i=start;i<end;i++){\n        \tRay curRay = rays[i];\n            vec3 point = vec3(0.0);\n            vec3 normal = vec3(0.0);\n            Material material;\n\n            if(sdScene(curRay,point,normal,material)){\n                \n                // 直接光照\n                vec3 baseColor = phong_shading(point,normal,material,curRay.dir);\n\n                // 反射\n                vec3 reflectDir = normalize(reflect(curRay.dir,normal));\n                vec3 reflectPoint = getOffsetPoint(point,reflectDir,normal);\n                Ray reflectRay = Ray(reflectPoint,reflectDir,curRay.colorFactor*material.albedo[2],curRay.isInside);\n                int reflectIndex = 2*i+1;\n                rays[reflectIndex] = reflectRay;\n\n                // 折射\n                vec3 refractDir = myRefract(curRay.dir,normal,material.refractiveIndex);\n                vec3 refractPoint = getOffsetPoint(point,refractDir,normal);\n                Ray refractRay = Ray(refractPoint,refractDir,curRay.colorFactor*material.albedo[3],1-curRay.isInside);\n                int refractIndex = 2*i+2;\n                rays[refractIndex] = refractRay;\n                if(length(refractDir) != 0.0){\n                    refractDir = normalize(refractDir);\n                    rays[refractIndex].colorFactor = curRay.colorFactor*material.albedo[3];\n                } else{\n                    rays[refractIndex].colorFactor = 0.0;\n                }\n                \n                \n                finalColor += baseColor * curRay.colorFactor;\n\n            } else {\n            \tfinalColor += texture(iChannel0, curRay.dir).xyz * curRay.colorFactor;\n            }\n        }\n        \n        start = end;\n        end = start + myPow(depth);\n        depth += 1;\n    }\n    \n    \n    float m = max(finalColor.r,max(finalColor.g,finalColor.b));\n    if(m > 1.0){\n        finalColor.r = finalColor.r / m;\n        finalColor.g = finalColor.g / m;\n        finalColor.b = finalColor.b / m;\n    }\n    \n    return finalColor;\n}\n\n\n// 四个角落\nfloat connerPos[4 * 2] = float[](0.1,0.1,0.9,0.1,0.9,0.9,0.1,0.9);                                    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float fov = 3.14156 / 4.0;\n    const float half_fov = fov / 2.0;\n    \n    float y = (fragCoord.y/iResolution.y*2.0 -1.0)*tan(half_fov);\n    float x = (fragCoord.x/iResolution.x*2.0 -1.0)*tan(half_fov)*iResolution.x/iResolution.y;\n    // 每个像素的长度\n    float pixelUnit = 2.0*tan(half_fov)/iResolution.y;\n    //vec3 direction = normalize(vec3(x ,y,-1));\n    //vec3 color = cast_ray(Ray(vec3(0.0,0.0,0.0),direction,1.0));\n    \n    \n    vec3 color = vec3(0.0);\n    // 累加四个角落的采样结果\n    for(int i = 0;i< 4;i++){\n    \tvec3 direction = normalize(vec3(x + connerPos[2*i]*pixelUnit,y+ connerPos[2*i+1]*pixelUnit,-1));\n        color += cast_ray(Ray(vec3(0.0,0.0,0.0),direction,1.0,0));\n    }\n    \n    color = color / 4.0;\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FLT_MAX 3.402823466e+38\n\nstruct Material{\n    vec3 color;\n    // 漫反射系数、高光系数、反射系数和折射系数\n    float albedo[4];\n    // 高光指数\n    float specularExponent;\n    // 折射率\n    float refractiveIndex;\n};\n\nconst Material IvoryMaterial = Material(vec3(0.4,0.4,0.3),float[4](0.6,0.3,0.1,0.0),50.0,1.0);\nconst Material RedMaterial = Material(vec3(0.3,0.1,0.1),float[4](0.9,0.1,0.0,0.0),10.0,1.0);\nconst Material GlassMaterial = Material(vec3(0.6,0.7,0.8),float[4](0.0,0.5,0.1,0.8),125.0,1.5);\nconst Material MirrorMaterial = Material(vec3(1.0,1.0,1.0),float[4](0.0,10.0,0.8,0.0),1425.0,1.0);\n\nMaterial materials[] = Material[](IvoryMaterial,RedMaterial,GlassMaterial,MirrorMaterial);\n\nstruct Sphere{\n    vec3 position;\n    Material material;\n    float radius;\n};\n\n\n#define SPHERE_NUM 4\nSphere[] spheres = Sphere[](Sphere(vec3(-3.0,0.0,-16.0),IvoryMaterial,2.0),\n                            Sphere(vec3(-1.0,-1.5,-12.0),GlassMaterial,2.0),\n                           \tSphere(vec3(1.5,-0.5,-18.0),RedMaterial,3.0),\n                            Sphere(vec3(7.0,5.0,-18.0),MirrorMaterial,4.0));\n\n\nstruct Light{\n    vec3 position;\n    float intensity;\n};\n\n#define LIGHT_NUM 3\nLight[] lights = Light[](Light(vec3(-20.0,20.0,20.0),1.5),\n                         Light(vec3(30.0,50.0,-25.0),1.8),\n                         Light(vec3(30.0,20.0,30.0),1.7));\n\n\nstruct Ray{\n  vec3 origin;\n  vec3 dir;\n  float colorFactor;\n  // 0 表示射线是在物体外面，1表示射线在物体里面\n  int isInside;\n};\n\n\nvec3 getOffsetPoint(vec3 point,vec3 dir,vec3 normal){\n\tfloat cosValue = dot(dir,normal);\n    if(cosValue < 0.0){\n    \treturn point - normal*0.01;\n    } else {\n    \treturn point + normal*0.01;\n    }\n}\n\n// point:当前计算光照的顶点\n// normal:point的法线\n// baseColor:point的颜色\n// dir:观察向量\nvec3 phong_shading(in vec3 point,in vec3 normal,in Material material,in vec3 dir){\n    vec3 color = material.color;\n    float diffuse = 0.0;\n    float specular = 0.0;\n    // 遍历所有的光源计算光照\n    for(int i=0; i<LIGHT_NUM; i++){\n    \tvec3 lightDir = lights[i].position - point;\n    \tfloat lightDistance = length(lightDir);\n        lightDir = normalize(lightDir);\n        float lightCos = dot(lightDir,normal);\n        \n        // 漫反射\n        diffuse += max(0.0,lightCos)*lights[i].intensity;\n        // 高光\n        specular += pow(max(0.0,dot(reflect(lightDir,normal),dir)),material.specularExponent)*lights[i].intensity;\n        \n        \n        //只有一个logo 不计算阴影了\n        /*\n        // 阴影判断\n        // 这里有个小细节，shadowPoint是射线的起点\n        // 我们不希望这条射线与物体本身相交，所以需要根据当前的法线做一个偏移\n        vec3 shadowPoint = getOffsetPoint(point,lightDir,normal);\n        vec3 shadowIntersectPoint;\n        vec3 shadowNormal;\n        Material shadowMaterial;\n\n        bool shadowIntersect = sdfScene(Ray(shadowPoint,lightDir,1.0,0),shadowIntersectPoint,shadowNormal,shadowMaterial);\n        // 当射线不与其它物体相交，或者相交的距离大于顶点与光源的距离的时候，光源能够照亮顶点\n        if(!shadowIntersect || lightDistance <= length(shadowIntersectPoint-point)){\n            // 漫反射\n            diffuse += max(0.0,lightCos)*lights[i].intensity;\n            // 高光\n            specular += pow(max(0.0,dot(reflect(lightDir,normal),dir)),material.specularExponent)*lights[i].intensity;\n        }\n        */\n    }\n\n    color = color * diffuse * material.albedo[0];\n    color = color + vec3(1.0,1.0,1.0) * specular * material.albedo[1];\n    return color;\n}\n\nvec3 myRefract(vec3 dir,vec3 normal,float refractiveIndex){\n    float cosi = dot(dir,normal);\n    // 以空气的折射率为1.0，refractiveIndex是当前表面介质的折射率\n    float eta = 1.0/refractiveIndex;\n    // 从介质进入空气\n    if(cosi >= 0.0){\n        eta = 1.0/eta;\n        normal = -normal;\n    }\n    \n    return refract(dir,normal,eta);\n}\n\n// depth=0是一个，depth=1是两个，depth=2是四个，depth=3是八个，depth=4是十六个\n// 默认光线的贡献是0.0，只有在初始化之后才可能是非0\nRay[] rays = Ray[](Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0),\n                   Ray(vec3(0.0),vec3(0.0),0.0,0));\nint myPow(int num){\n    int result = 1;\n    for(int i=0;i<num;i++){\n    \tresult *= 2;\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}