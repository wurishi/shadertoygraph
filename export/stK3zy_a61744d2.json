{"ver":"0.1","info":{"id":"stK3zy","date":"1638276489","viewed":108,"name":"Shader Game","username":"peremoya2000","description":"Endless 3D rail game. Collect the golden spheres, avoid the red ones and get the highest score you can. Use the arrows or A-D ot move sideways and W-S to change speed.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","interactive","text","endless","videogame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fovzoom = .9;\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 )\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 pInt(vec2 p, float n) { \n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\nfloat drawChar() {\n    int c = char_id; \n    vec2 p = char_pos;\n    return c < 0\n        ? 0.\n        : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy ).x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //Calculate render parameters\n    vec4 playerData = texelFetch(iChannel0, ivec2(0,0),0);\n    vec3 ball = vec3(-3.*playerData.x,0,1),\n    camPos = vec3(0,2,-5);\n    float score = playerData.z;\n    \n    vec4 enemyZ = texelFetch(iChannel0, ivec2(0,1),0)-vec4(10);\n    vec3[6] balls = vec3[](\n    ball,\n    vec3(-6,0,enemyZ.x),vec3(-3,0,enemyZ.y),\n    texelFetch(iChannel0, ivec2(0,2),0).xyz-vec3(0,0,10),\n    vec3(3,0,enemyZ.z),vec3(6,0,enemyZ.w));\n      \n    vec3 f = normalize(vec3(0,0,1)-camPos),\n    u = vec3(0,1,0),\n    r = normalize(cross(f,u)),\n    sCenter = camPos+f*fovzoom,\n    screenPoint = sCenter + uv.x * r + uv.y * u,\n    rayDir = normalize(screenPoint-camPos);\n    \n    //Raymarch for spheres\n    vec3 ray;\n    float rayL, rayStep;\n    for (int i=0; i<500; ++i){\n        ray = camPos + rayDir * rayL;\n        \n        rayStep = min(length(ball-ray) - 1., \n        min(length(balls[1]-ray) - .8,\n        min(length(balls[2]-ray) - .8,\n        min(length(balls[3]-ray) - .8,\n        min(length(balls[4]-ray) - .8,\n        min(length(balls[5]-ray) - .8,\n        abs(1.+ray.y)))))));\n        \n        if(rayStep<.001 || rayStep>100.) break;\n        rayL += rayStep;\n    }\n    \n    vec2 oUV = vec2(0);\n    float diffuse;\n    if(rayStep<.001){\n        if (abs(ray.y+1.)<.001){ \n            //Floor\n            oUV=vec2(ray.x,ray.z);\n            float lanes = 1.-abs(sin(oUV.x)-4.*smoothstep(6.,9.,abs(oUV.x)));\n            col=vec3(.4,lanes,1);\n        }else{\n            int id = getHitSphere(ray, balls);\n            vec3 obj = balls[id];\n            \n            //Calculate uvs\n            oUV.x = sin(atan(ray.x-obj.x,ray.z-obj.z))*.5+.5;\n            oUV.y = (acos(ray.y)*.5+.5); \n        \n            //Diffuse lighting\n            vec3 normal = normalize(ray-obj);\n            diffuse = max(dot(normal,-normalize(vec3(0,.5,1))),0.);\n            vec3 reflectionRay = reflect(normalize(vec3(0,.5,1)),normal);\n            float specular = pow(max(0.f,dot(-f,reflectionRay)),10.);\n            if(id==0){\n                col=.7*diffuse*vec3(.1,1,.3)+specular*.2+vec3(.4,.1,1)*.15*oUV.y;\n            }else{\n                vec4 dv= texelFetch(iChannel0, ivec2(0,3),0);\n                float d[] = float[](dv.x,dv.y,texelFetch(iChannel0, ivec2(0,2),0).w,dv.z,dv.w);\n                col=.7*diffuse*mix(vec3(.95,1,.1),vec3(1,0,0),d[id-1])+specular*.2+vec3(.4,.1,1)*.15*oUV.y;\n            }\n            col.gb+=vec2(.12*railDist(ray.x/3.)*(1.-min(1.,2.*ray.y)));\n        }\n    }\n    fragColor = vec4(col,1.0);\n    \n    uv = ( uv - vec2(.8,.4) ) * 12.;\n    fragColor += pInt(uv, score);        \n    fragColor += drawChar();\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const ivec4 WASD = ivec4(87,65,83,68);\nconst ivec4 LURD = ivec4(37,38,39,40);\n\nvoid newDangerValue(int hit, inout vec4 d, inout vec4 d0){\n    float newD = round(hash11(iTime*4.)-.3);\n    switch(hit){\n        case -1:\n            break;\n        case 0:\n            d.w=newD;\n            break;\n        case 1:\n            d.z=newD;\n            break;\n        case 2:\n            d0.w=newD;\n            break;\n        case 3:\n            d.y=newD;\n            break;\n        case 4:\n            d.x=newD;\n            break;\n    } \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x,y = 0.;\n    vec4 wasd = vec4(0.);\n    vec4 lurd = vec4(0.);\n    \n    lurd.x = texelFetch( iChannel1, ivec2(LURD.x,0), 0 ).x;\n    lurd.y = texelFetch( iChannel1, ivec2(LURD.y,0), 0 ).x;\n    lurd.z = texelFetch( iChannel1, ivec2(LURD.z,0), 0 ).x;\n    lurd.w = texelFetch( iChannel1, ivec2(LURD.w,0), 0 ).x;\n    \n    wasd.x = texelFetch( iChannel1, ivec2(WASD.x,0), 0 ).x;\n    wasd.y = texelFetch( iChannel1, ivec2(WASD.y,0), 0 ).x;\n    wasd.z = texelFetch( iChannel1, ivec2(WASD.z,0), 0 ).x;\n    wasd.w = texelFetch( iChannel1, ivec2(WASD.w,0), 0 ).x;\n    \n    if( lurd.z>0. || wasd.w>0. ) ++x;\n    if( lurd.x>0. || wasd.y>0. ) --x;\n    if( lurd.y>0. || wasd.x>0. ) ++y;\n    if( lurd.w>0. || wasd.z>0. ) --y;\n        \n    vec4 playerData = texelFetch(iChannel0, ivec2(0,0), 0);\n    float pos = playerData.x;\n    float target = playerData.y;\n    float score = playerData.z;\n    float speed = playerData.w+y*.2;\n    speed=max(1.,min(speed,2.));\n    \n    vec4 danger = texelFetch(iChannel0, ivec2(0,3),0);\n    \n    vec4 enemies = vecMod(texelFetch(iChannel0, ivec2(0,1),0) - speed*vec4(.0491,(sin(iTime*.27)*.11+.1)+.4291,.2563+(score*.00011),.3139),271.);\n    enemies.x-=((.01*enemies.w+(280.-enemies.x))*.0022);\n    vec4 midEnemy = vec4(0,0,mod(texelFetch(iChannel0, ivec2(0,2),0).zw-vec2(speed*(sin(iTime*.21)*.4+.52+.00002*score),0.),271.));\n\n    if(abs(target-pos)<.075){\n       target=clamp(target+x,-2.,2.); \n    }else{\n       pos=mix(pos,target,.3);\n    }\n    if (abs(pos)<.1)pos*=.9;\n    \n    float[] dangerArr = float[](danger.w,danger.z,midEnemy.w,danger.y,danger.x);\n    int hit = getEnemyColision(float[](enemies.w,enemies.z,midEnemy.z,enemies.y,enemies.x),pos,target);\n    switch(hit){\n        case -1:\n            if (score>0.)score-=.01;\n            score*=.9999;\n            break;\n        case 0:\n            enemies.w=0.;\n            score+=points(100.,danger.w);\n            break;\n        case 1:\n            enemies.z=0.;\n            score+=points(107.,danger.z);\n            break;\n        case 2:\n            midEnemy.z=0.;\n            score+=points(173.,midEnemy.w);\n            break;\n        case 3:\n            enemies.y=0.;\n            score+=points(139.,danger.y);\n            break;\n        case 4:\n            enemies.x=0.;\n            score+=points(83.,danger.x);\n            break;\n    }\n    if(hit!=-1){score*=1.005;}\n    newDangerValue(hit, danger, midEnemy);\n    hit=enemyMissed(float[](enemies.w,enemies.z,midEnemy.z,enemies.y,enemies.x));\n    newDangerValue(hit, danger, midEnemy);\n    if (score>0. && hit!=-1){\n        if (dangerArr[hit]<.5){\n            score-=100.;score*=.97;\n        }else{\n            score+=100.;score*=1.01;\n        }      \n    }\n    vec4 col = vec4(0);   \n    playerData=vec4(pos,target,score,speed);\n   \n    if(floor(fragCoord.x) == 0.0 ){\n        switch(int(fragCoord.y)){\n            case 0:\n                col = playerData;\n                break;\n            case 1:\n                col = enemies;\n                break;\n            case 2:\n                col = midEnemy;\n                break;\n            case 3:\n                col = danger;\n                break;\n        }\n    }   \n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\nfloat hash11(float p){\n    p = fract(mod(p,7507.) * .1031);\n    p *= p + 33.33;\n    p *= p + p * PI;\n    return fract(p);\n}\n\nvec4 vecMod (vec4 p, float m){\n    return\n    vec4(mod(p.x,m),mod(p.y,m),mod(p.z,m),mod(p.w,m));\n}\n\nfloat manDist(vec3 v){\n    return abs(v.x)+abs(v.y)+abs(v.z);   \n}\n\nfloat railDist(float x){\n    return pow((1.-abs(round(x)-x)),1.5);\n}\n\nint getEnemyColision(float[5] enemies, float pos, float target){\n   float e,rail;\n   pos=round(pos);\n   for (int i=0; i<5; ++i){\n       e=enemies[i];\n       rail=float(i)-2.;\n       if (e<14. && e>9. && (pos==rail || target==rail)){\n            return i;\n       }\n   }   \n   return -1; \n}\n\nint enemyMissed(float[5] enemies){\n   float e;\n   for (int i=0; i<5; ++i){\n       e=enemies[i];\n       if (e<.8 && e>0.){\n            return i;\n       }\n   }   \n   return -1; \n}\n\n//Negate p when d>.6\nfloat points(float p, float d){\n    return p*(step(d,.6)*2.-1.);\n}\n\n//Get body closest to ray hit and return the id\nint getHitSphere(vec3 hitPos,vec3[6] points){\n    float minDist=99999.;\n    int id;\n    for (int i=0; i<6; ++i){\n        float d = manDist(points[i]-hitPos);\n        if (d<minDist) {\n           minDist=d;\n           id=i;\n        }\n    }\n    return id;\n}","name":"Common","description":"","type":"common"}]}