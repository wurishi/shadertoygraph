{"ver":"0.1","info":{"id":"mlVBDc","date":"1702594209","viewed":37,"name":"Leaf_sample","username":"tharusam","description":"leaf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["leaf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define USE_3D_MODEL_3\n\n// Roughness of Microfacets (m)\n// Default m = 0.4 as in Cook & Torrance 1982.\nconst float M_PARAM = 0.5; \n\n// Albedo Measure (ρ) for SchlickFresnel()\n// For copper (default) in the range of 0.2 to 0.4.\nconst float RHO_PARAM = 0.1; \n\n// Possible Combinations of 'D', 'G', and 'F' functions\n// i.e., numerators of the main Cook-Torrance equation:\n// ----------------------------------------------------------\n#define USE_CT_NUM_DGF 1 // original ( D * G * F ) numerator\n#define USE_CT_NUM_D   2 // ( D ) numerator\n#define USE_CT_NUM_G   3 // ( G ) numerator\n#define USE_CT_NUM_F   4 // ( F ) numerator\n#define USE_CT_NUM_DG  5 // ( D * G ) numerator\n#define USE_CT_NUM_DF  6 // ( D * F ) numerator\n#define USE_CT_NUM_GF  7 // ( G * F ) numerator\n\nconst int CT_num = USE_CT_NUM_DF; // numerator arrangement\n\n// Multiply BRDF by (1 / PI)? i.e., comment // in/out \n// #define USE_INV_PI \n\n// ======================================================================\n//   END - Parameters for the user to select\n// ======================================================================\n\n// 5 LIGHTS\n\n// Emission percentage \nconst float FULL = 1.0;\nconst float MED  = 0.5;\nconst float LOW  = 0.2;\n\n// Position\nconst vec3  L1_POS  = vec3(-3.0, 7.0, -3.0); //vec3( 2.0, 5.0, 2.0 );  \n// Emission\nconst float L1_EMI  = LOW;\n// Color\nconst vec3  WHITE   = vec3( 1.0, 1.0, 1.0 ) * L1_EMI;\n\nconst vec3  L2_POS  = vec3( 5.0, -5.0, 4.0 ); //vec3(-3.0, 7.0, -3.0);\nconst float L2_EMI  = LOW;\nconst vec3  YELLOW  = vec3( 1.0, 1.0, 0.0 ) * L2_EMI;\n\nconst vec3  L3_POS  = vec3( 2.0, 5.0, 2.0 );   //vec3( 5.0, -5.0, 20.0 );\nconst float L3_EMI  = LOW;\nconst vec3  GREEN   = vec3( 0.0, 1.0, 0.0 ) * L3_EMI;\n\nconst vec3  L4_POS  = vec3( 5.0, 5.0, 20.0 ); //vec3( 5.0, -5.0, 4.0 );\nconst float L4_EMI  = LOW;\nconst vec3  BLUE    = vec3( 0.0, 0.0, 1.0 ) * L4_EMI;\n\nconst vec3  L5_POS  = vec3( 5.0, -5.0, -5.0 );\nconst float L5_EMI  = LOW;\nconst vec3  CYAN    = vec3( 0.0, 1.0, 1.0 ) * L5_EMI;\n\n// Ray marching constants\n\nconst int maximum_iteration_count = 255;\nconst float halt_threshold = 0.001;\nconst float scale_factor = 0.5;\nconst float gradient_step = 0.1;\nconst float far_clipping_distance = 1000.0;\nconst float sphere_radius = 2.7;\nconst vec4 background_col = vec4(0.0, 0.0, 0.0, 1.0);\n\n\n\nconst float layers = 2.0;  // >1\n\nconst float ks = 5.0; //adjustment for Kelemen/Szirmay-Kalos model\nconst float oblateness = 0.6;\n\nconst float h = 0.5; //leaf thickness\nconst float kd = 25.2; // BRDF diff adjustment\nconst float kt = 0.1; // BTDF adjustment\n\n\nconst float refractive_index = 1.4;\nconst float tav59 = 0.964;  //transmissivity \nconst float tav90 = 0.923;\nconst float k = 0.16; //absorption coefficient of the plate \n\nconst bool all_white = true; //all white lights\nconst bool cooktorrence = false;\nconst bool texture_on = true;\nconst float mixrateT = 0.5; //mixing rate for BTDF and BRDF diff\n\nconst vec3 r_ellipse = vec3( 1.5, 0.1, 0.8 );\n\n\n// ======================================================================\n//   MATH\n// ======================================================================\n\nconst float PI = 3.14159265358979323846;\nconst float INV_PI = 0.31830988618379067154; \nconst float DEG_TO_RAD = PI / 180.0;\nconst float EPSILON = 0.00001; \n\n// ----------------------------------------------------------------------\nfloat BeckmannDistribution( vec3 H, vec3 N, float m ) \n// ----------------------------------------------------------------------\n{\n    float D;\n    float alpha = acos(max(dot(N,H), EPSILON));\n    D = (exp(-(pow((tan(alpha)/m),2.0))))/max(pow(m,2.0)*pow(cos(alpha),4.0), EPSILON);\n    \n    #ifdef USE_INV_PI \n        D *= INV_PI;\n    #endif\n\n    return D;\n}\n\n\n// ----------------------------------------------------------------------\nfloat SchlickFresnel ( float NdotH, float rho) //NdotH\n// ----------------------------------------------------------------------\n{\n    float F;\n    float n = refractive_index;\n    float C = NdotH; //LdotH;\n    float G = n * n + C * C - 1.0;\n    \n    //float n1 = refractive_index;\n    //float n2 = 1.0; // refractive index of air\n    //rho = 1.0;\n    //F = rho + ((1.0 - rho) * pow((1.0 - NdotH), 5.0));\n    F = 0.5 * pow(G - C, 2.0) * (1.0 + pow(C * (G + C) - 1.0, 2.0)/pow(C * (G + C) + 1.0, 2.0)) / pow(G + C, 2.0);\n    \n    return F; \n}\n\n// ----------------------------------------------------------------------\nfloat GeometricAttenuation( float NdotH, \n                            float NdotV, \n                            float NdotL, \n                            float HdotV )\n// ----------------------------------------------------------------------\n{  \n    float G;\n    \n    G = min(1.0,min((2.0*NdotH*NdotV)/max(HdotV, EPSILON),(2.0*NdotH*NdotL)/max(HdotV, EPSILON)));\n    \n    return G; \n}\n   \nfloat integrand(float x) {\n    return exp(-x) / x;\n}\n\nfloat riemann_sum(float lower_limit) {\n    float num_intervals = 1000.0;\n    float interval_width = 1.0;//(INFINITY - lower_limit) / num_intervals;\n    float riemann_sum = 0.0;\n\n    for (float i = 0.0; i < num_intervals; i++) {\n        float xi = lower_limit + (i + 0.5) * interval_width;\n        float riemann_sum_old = riemann_sum;\n        riemann_sum += integrand(xi) * interval_width;\n        \n        if (riemann_sum - riemann_sum_old < EPSILON) \n        {\n            break;\n        }\n    }\n\n    return riemann_sum;\n}\n\nvec2 prospectModel()\n{\n    float n = refractive_index; //refractive index\n    float C = riemann_sum(k);\n    \n    float theta = (1.0 - k) * exp(-k) + k * k * C;//(pow(k,-1.0) * exp(-k));\n    float rho90 = (1.0 - tav90) + (tav90 * tav90 * theta * theta * (n*n - tav90))/( n*n*n*n - theta * theta * pow( n*n - tav90, 2.0));\n    float tau90 = (tav90 * tav90 * theta * n * n ) /( n*n*n*n - theta * theta * pow( n*n - tav90, 2.0));\n    float delta90 = sqrt(pow(tau90 * tau90 - rho90 * rho90 - 1.0, 2.0) - 4.0 * rho90 * rho90);\n    float a90 = (1.0 + rho90 * rho90 - tau90 * tau90 + delta90)/(2.0 * rho90);\n    float b90 = (1.0 + rho90 * rho90 - tau90 * tau90 + delta90)/(2.0 * tau90);\n    float R90 =(pow(b90, layers) - pow(b90, -layers))/(a90 * pow(b90, layers) - pow(a90, -1.0) * pow(b90, layers));\n    float T90 =(a90 - pow(a90, -1.0))/(a90 * pow(b90, layers) - pow(a90, -1.0) * pow(b90, layers));\n    \n    float x = tav59 / tav90;\n    float y = x * (tav59 - 1.0) + 1.0 - tav59;\n    \n    float R = x * R90 + y;\n    float T = x * T90;\n    \n    float diff_reflectance = kd * R ;\n    float transmittance = kt * T * exp(-h);\n    //return mix( diff_reflectance, transmittance, mixrateT);\n    return vec2 (diff_reflectance, transmittance);\n}\n\n\nfloat KelemenSzirmayBRDF( vec3 L, vec3 V, vec3 N, float m, float rho ) \n// ----------------------------------------------------------------------\n{\n    // The result of your Cook-Torrance BRDF implementation\n    float specularBRDF;\n    // Numerator and Denominator of the main Cook-Torrance eq.\n    float num, num1, num2, den, den1, den2; \n    // The 3 main fuctions of Cook-Torrance\n    float D, G, F, rho1;\n       \n    vec3 H = normalize(L + V);\n    //vec3 H = cooktorrence? normalize(L + V): (L + V) * (L + V);\n    \n    // Allow user selection by editing the #define and consts for \n    // the Beckmann distribution and the numerators of the \n    // main Cook-Torrance equation (refer to top of the shader code)\n    \n    D = BeckmannDistribution(H, N, m);\n    G = GeometricAttenuation(max(dot(N, H), EPSILON),max(dot(N, V), EPSILON),max(dot(N, L), EPSILON),max(dot(H, V), EPSILON));\n    if (cooktorrence){\n        F = SchlickFresnel(max(dot(N, H), EPSILON), rho); \n    } else {\n        F = SchlickFresnel(max(dot(N, H), EPSILON), rho); //*LdtoH, but NdotH works better\n    }\n    \n    // Possible Combinations of 'D', 'G', and 'F' functions  \n    // i.e., numerators of the main Cook-Torrance equation\n    // Refer to the top of the shader's code.\n\n    if (layers > 2.5)\n    {\n        rho1 = 0.0;\n    } else {\n        rho1 = ks * pow( 0.7, 1.0/oblateness);\n    }\n    \n    num1 = rho1 * max(( D * F ), EPSILON );\n    num2 = rho1 * max(( D * G * F ), EPSILON );\n    \n    H = (L + V);\n    den1 = dot(H, H);\n    den2 = max(dot(N, L), EPSILON) * max(dot(N, V), EPSILON);\n    \n    num = cooktorrence? num2 : num1;\n    den = cooktorrence? den2 : den1;\n    den = max( den, EPSILON ); // Avoid division by zero\n    specularBRDF = num / den;\n            \n    #ifdef USE_INV_PI \n        specularBRDF *= INV_PI;\n    #endif\n    \n    return specularBRDF;\n}\n\nvec3 radiance(\n    vec3 sample_pos,  // Location of sample to be shaded\n    vec3 N,\t\t      // Surface normal n\n    vec3 L,\t\t      // Incoming direction wi from vertex to light\n    vec3 V,\t\t      // Outgoing direction wo from vertex to view\n    float m,\t             // Material roughness\n    float rho,               // Albedo of material (Fresnel eq)\n    vec3 ambi_col,       // Ambient reflectance of the material\n    vec3 diff_col,\t      // Diffuse reflectance of the material\n    vec3 spec_col,        // Specular reflectance of the material\n    vec3 light_col,\t       // Light color\n    vec3 diffuseTexture\n    )\n{\n    //float spec_BRDF = CookTorranceBRDF(L, V, N, m, rho);\n    float spec_BRDF = KelemenSzirmayBRDF(L, V, N, m, rho); // TSAM: float or vec3?\n    vec2 prospectM = prospectModel();\n    //float diff_BRDF = prospectM.x; // TSAM: float or vec3?\n    float BTDF =  prospectM.y;    // TSAM: float or vec3?\n    vec3 diff_BRDF = vec3( prospectM.x); \n    \n    if (texture_on) {\n        diff_BRDF = prospectM.x * diffuseTexture ; \n    } \n    // Calculate the equivalent cos(theta) of Lambert's law\n    float LdotN = max(dot(L, N), EPSILON);\n    \n    // Combine the ambient, diffuse, and specular BRDFs\n    vec3 finalColor = vec3( 0.0 );\n\n    vec3 ambi_BRDF = ambi_col;\n    //vec3 diff_BRDF = diff_col;\n    \n    diff_BRDF *= INV_PI;\n      \n    #ifdef USE_INV_PI \n        ambi_BRDF *= INV_PI;\n        diff_BRDF *= INV_PI;\n    #endif\n    \n      \n    //vec3 BRDF_col =  spec_BRDF * spec_col;    \n    //vec3 BRDF_col =  (spec_BRDF + diff_BRDF) *spec_col;    \n    //vec3 BTDF_col =  mix(BTDF, diff_BRDF, 0.9)  * diff_col;    \n    \n    //finalColor = ( ambi_BRDF + BTDF_col + BRDF_col) * ( light_col * LdotN );\n    finalColor = ( ambi_BRDF + diff_BRDF + spec_BRDF + BTDF) * ( light_col * LdotN );\n    \n    return finalColor;\n}\n\n// ----------------------------------------------------------------------\nvec3 shading(vec3 sample_pos, vec3 N, vec3 eye_pos, vec3 diffuseTexture)\n// ----------------------------------------------------------------------\n{\n    // Jade\n    // https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/3DLighting/MaterialProperties.html\n    // http://learnwebgl.brown37.net/10_surface_properties/surface_properties_color.html\n    // https://physicallybased.info/\n\n    // Jade\n    vec3 amb_col =  vec3( 0.0215,0.1745, 0.0215)*1.6;\n    vec3 diff_col = /*vec3(0.0); //*/vec3( 0.54, 0.89, 0.63 );\n    vec3 spec_col = /*vec3(0.0); //*/vec3( 0.316228 );\n\n    // Allow user selection by editing the values of \n    // consts float M_PARAM and RHO_PARAM\n    // (refer to top of the shader code) \n    float m = M_PARAM;\n    float rho = RHO_PARAM;\n    \n    // view (eye, camera) vector wo\n    vec3 V = normalize(eye_pos - sample_pos);  // YOUR CODE HERE  );\n\n    // Final radiance\n    vec3 Le = vec3 ( 0.0 );\n\n    // -- LIGHT #1 ----------------------------------\n    {\n        vec3 light_pos = L1_POS;\n        vec3 light_col = all_white ? WHITE : YELLOW;\n\n        // Light Vector L\n        vec3 L = normalize(light_pos - sample_pos); \n        // Accumulated Radiance\n        Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col, diffuseTexture);\n    }\n    // -- LIGHT #2 ----------------------------------\n    {\n        vec3 light_pos = L2_POS;\n        vec3 light_col = all_white ? WHITE : BLUE;\n        \n        // Light Vector L\n        vec3 L = normalize(light_pos - sample_pos); \n        // Accumulated Radiance\n        Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col, diffuseTexture);\n    }\n    // -- LIGHT #3 ----------------------------------\n    {\n        vec3 light_pos = L3_POS;\n        vec3 light_col = WHITE;\n\n        // Light Vector L\n        vec3 L = normalize(light_pos - sample_pos); \n        // Accumulated Radiance\n        Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col, diffuseTexture);\n        //Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col);\n    }\n    \n    // -- LIGHT #4 ----------------------------------\n    {\n        vec3 light_pos = L4_POS;\n        vec3 light_col = all_white ? WHITE : GREEN;\n\n        // Light Vector L\n        vec3 L = normalize(light_pos - sample_pos); \n        // Accumulated Radiance\n        Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col, diffuseTexture);\n        //Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col);\n    }\n\n    // -- LIGHT #5 ----------------------------------\n    {\n        vec3 light_pos = L5_POS;\n        vec3 light_col = all_white? WHITE : CYAN;\n\n        // Light Vector L\n        vec3 L = normalize(light_pos - sample_pos); \n        // Accumulated Radiance\n        Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col, diffuseTexture);\n        //Le = Le + radiance(sample_pos, N, L, V, m, rho, amb_col, diff_col, spec_col, light_col);\n    }\n\n    return ( amb_col + Le );\n    return ( amb_col + Le );\n}\n\n\n// ======================================================================\n// petal : https://www.shadertoy.com/view/Wdl3W4\n// ======================================================================\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 sight, out vec3 worldPosition ) {\n\n    // Of the object\n    vec3 position = vec3( 0.0, 0.0, 0.0 );\n\n    // The xyz component radius values of the ellipsoid\n    vec3 radius = r_ellipse;\n\n    // Define position in relation to the camera\n    position = sight - position;\n\n    // Bend the ellipsoid on the z axis\n    float bend = 0.2;\n    float c = cos( position.z * bend );\n    float s = sin( position.z * bend );\n    mat2  m = mat2( c, - s, s, c );\n    vec3  q = vec3( m * position.xy, position.z );\n\n   \t// Bend the ellipsoid on the x axis\n    bend =  -0.1;\n    c = cos( q.x * bend );\n    s = sin( q.x * bend );\n    m = mat2( c, - s, s, c );\n    q = vec3( m * q.xy, q.z );\n\n    worldPosition = q;\n\n    float sdf = sdEllipsoid( worldPosition, radius );\n    vec2 res = vec2( sdf, 0.0 );\n\n    return res;\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 pos ) {\n\n    // Near / Far Clipping Plane\n    float tmin = 1.0;\n    float tmax = 50.0;\n    \n    float t = tmin;\n    float m = - 1.0;\n    // TODO: Why does it need so many iterations\n    // to march correctly?\n    for( int i = 0; i < 128; i++ ) {\n\n\t    float precis = 0.0004 * t;\n\t    vec2 res = map( ro + rd * t, pos );\n\n        // Means no intersection\n        // and no possibility of checking again\n        // so stop the Ray Marching\n        if( res.x < precis || t > tmax ) break;\n\n        t += res.x;\n\t    m = res.y; // Identify which shape was intersected via a float\n\n    }\n\n    if( t > tmax ) m =- 1.0;\n    return vec2( t, m );\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\n    vec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv = normalize( cross( cu, cw ) );\n\n    return mat3( cu, cv, cw );\n\n}\n\nvec3 eliNormal( in vec3 pos)\n{\n    return normalize( (pos-vec3(0.0))/r_ellipse);\n}\n\n//----------\n\n\n//----------\n// from https://www.shadertoy.com/view/wtjGWy\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n)  \n{\n    vec3 blending = abs(n);\n    blending = normalize(max(blending, 0.00001));\n    \n    // normalized total value to 1.0\n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n   /* vec4 xaxis = texture(tex, p.yz*0.8-0.5);\n    vec4 yaxis = texture(tex, p.xz);\n    vec4 zaxis = texture(tex, p.xy);*/\n    //vec4 xaxis = texture(tex, p.yz*0.8-0.5);\n    vec4 yaxis = texture(tex, p.xz*0.6-0.5);\n    //vec4 zaxis = texture(tex, p.xy*0.8-0.5);\n    \n    // blend the results of the 3 planar projections.\n    return (/*xaxis * blending.x */+ yaxis * blending.y /*+ zaxis * blending.z*/).rgb;\n}\n//------------\n\n// ======================================================================\n//   mainImage() \n// ======================================================================\n// ----------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n// ----------------------------------------------------------------------\n{\n    vec3 radiance = vec3( 0.0 );    \n\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = iTime;\n\n    vec2 p = ( - iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n    // Camera Position\n     vec3 ro = vec3( 10.0 * cos( mo.x * 3.14 ), 10.0 * mo.y - 5.0, 10.0 * sin( mo.x * 3.14 ) );\n    //vec3 ro = vec3( 10.0 * cos( time ), 10.0 * sin( time * 2.0 ), 10.0 * sin( time ) );\n    // Camera Look At Vector\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 8.0 ) );\n\n    vec3 pos = vec3( 0.0 );\n    vec2 res = castRay( ro,rd ,pos );\n\n    float t = res.x;\n    float m = res.y;\n    vec3 col = vec3( 0.0 );\n\n    vec3 n = eliNormal(pos);\n\n    // Ray intersected object\n    if( m >= 0.0 ) {             \n        vec3 diffuseTexture = tex3D(iChannel0, pos, n); // drag and drop horizantally rotated texture to ichannle0 from -> https://3docean.net/item/green-leaf-hq-texture/5224796\n        col = shading(pos, n, ro, diffuseTexture); \n    } \n\n    // render\t\n    radiance = col; \n\n    fragColor = vec4( radiance, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}