{"ver":"0.1","info":{"id":"X3c3Ds","date":"1717115364","viewed":166,"name":"bae #016 ~ Slab Steps","username":"BretHudson","description":"A bunch of slabs going up & down","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(vec2 p)\n{\n    p = fract(p * vec2(123.345, 734.6897));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat map(vec3 p)\n{    \n    vec2 id = floor(p.xz);\n    \n    p.xz = fract(p.xz) - .5;\n    \n    float n = hash(id);\n    \n    n = fract(n * 47.13);\n    \n    float s = sin(iTime + n * PI * 2.);\n    s = smoothstep(0.5, 1., s) * .2;\n    \n    float r = .02;\n    float w = .5 - r;\n    float box = sdBox(p, vec3(w, .1 - r + s, w)) - r;\n    \n    return box;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.; // total distance travelled\n    for (int i = 0; i < 400; ++i)\n    {\n        vec3 p = ro + rd * t;\n\n        float d = map(p) * .1;\n\n        t += d;\n        \n        if (abs(d) < .001 || t > 100.) break;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    float h = .01;\n    vec2 k = vec2(1, -1);\n    return normalize(\n        k.xyy * map(p + k.xyy * h) +\n        k.yyx * map(p + k.yyx * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.xxx * map(p + k.xxx * h)\n    );\n}\n\nfloat scrollFactor = .8;\nfloat getLight(vec3 p)\n{\n    float a = 3.4;\n    \n    vec3 lightPos = vec3(\n        12. * sin(a),\n        20.,\n        12.0*cos(a)\n    ); // Light Position\n    lightPos.x -= iTime * scrollFactor;\n    lightPos.x += 30.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = normal(p);\n   \n    float dif = max(dot(n, l), 0.);\n    \n    float d = rayMarch(p + n * .01, l);\n    if (d < length(lightPos - p)) dif *= .7;\n    \n    return max(.3, dif);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.x;\n    \n    vec3 Y = vec3(0., 1., 0.);\n    \n    vec3 ro = vec3(1., 1.8, -2); // ray origin\n    \n    vec3 lookat = vec3(0);\n    \n    ro.x -= iTime * scrollFactor;\n    lookat.x -= iTime * scrollFactor;\n    \n    vec3 F = normalize(lookat - ro);\n    vec3 R = cross(Y, F);\n    vec3 U = cross(F, R);\n    \n    float zoom = 3.2;\n    R *= zoom;\n    U *= zoom;\n    ro += uv.x * R + uv.y * U;\n    vec3 rd = F;\n    \n    vec3 col = vec3(0);\n    \n    float t = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * t;\n    float dif = getLight(p);\n    \n    float n = hash(floor(p.xz) * 75.6);\n    vec3 c = hsv2rgb(vec3(mod(n, .5), .6, 1.));\n    c = pow(c, vec3(1./1.16));\n    \n    col = vec3(dif) * c;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}