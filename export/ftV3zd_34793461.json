{"ver":"0.1","info":{"id":"ftV3zd","date":"1638208603","viewed":146,"name":"Green Earth","username":"ifdita_hasan","description":"Rotating Earth","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I learned this from a video \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define NUM_NOISE_OCTAVES 5\n#define NOISE fbm\n\n// Map range\nfloat map(float Input,float input_start,float input_end,float output_start,float output_end) {\n    return output_start + ((output_end - output_start) / (input_end - input_start)) * (Input - input_start);\n}\n\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\n\n//3d noise\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n//p is a point in 3D space\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 2, 0, 2);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    // float planeDist = p.y;\n    \n    //float d = min(sphereDist, planeDist);\n    return sphereDist;\n}\n\n//ray marching\nfloat RayMarch(vec3 ray_origin, vec3 ray_dir) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ray_origin + ray_dir*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(8., 8., 8.);\n    lightPos.x *= sin(iTime)*10.;\n    lightPos.z *= cos(iTime)*10.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalising uv coordinates\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //black screen\n    vec3 col = vec3(0);\n    \n    //ray origin\n    vec3 ray_origin = vec3(0., 2., -7.);\n    //ray direction\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.));\n    ray_dir.x = ray_dir.x - ray_origin.x;\n\n    float d = RayMarch(ray_origin, ray_dir);\n    \n    vec3 p = ray_origin + ray_dir * d;\n    \n    float dif = GetLight(p);\n    \n    \n    float theta = iTime;\n    \n    float oceans = fbm(p*5.);\n    \n    float land = fbm(p*1.5);\n    \n    float landThresh = 0.5;\n    \n    if (land < landThresh) {\n        land = map(oceans,0.0,1.0,0.1,landThresh);\n    }\n    land = 1.-land;\n    \n    float final = dif*land;\n    final = map(final,0.1,1.,0.,1.); //cool bump map effect\n\n    \n    col = vec3(final);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    float r = col.r;\n    float g = col.g;\n    float b = col.b;\n    \n    //gradient mapping\n    if (r+g+b > 0.) {\n        if (land < landThresh) {\n        //green\n            r = map(r,0.,landThresh,3./255.,226./255.);\n            g = map(g,0.,landThresh,27./255.,254./255.);\n            b = map(b,0.,landThresh,12./255.,72./255.);\n        } else {\n        //blue\n            r = map(r,landThresh,1.,26./255.,88./255.);\n            g = map(g,landThresh,1.,0./255.,205./255.);\n            b = map(b,landThresh,1.,60./255.,234./255.);\n        }\n    }\n    \n    fragColor = vec4(r,g,b,1.0);\n}","name":"Image","description":"","type":"image"}]}