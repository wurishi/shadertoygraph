{"ver":"0.1","info":{"id":"7ssXRn","date":"1618906080","viewed":122,"name":"Alina_13","username":"aaaaa666","description":"Task by Computer Graphics course","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(2, 1.5, -8); //позиция камеры\nconst vec3 LIGHT1_POS = vec3(-3, 1.5, 1); //позиция источника света\nconst float LIGHT1_RADIUS = 0.5;\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 0.7);\n\nconst vec3 LIGHT2_POS = vec3(1.5, 0.2, 3);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(0.1, 0.5, 0.8);\nvec3 randDir;\n\n// типы материала\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\nconst int PROPHECY = 4;\n\n//коэффициэнты преломления сред\nconst float GLASS_N = 1.5; \nconst float AIR_N = 1.0;\n\nconst vec3 fog_color=vec3(0.8, 0.8, 0.8);\n\n\n// трассировка стола\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    // (CAMERA_POS + t * viewVec).y == -1.2\n    // t = (-1.2 - CAMERA_POS.y) / viewVec.y;\n    float t = (-1.2 - pos.y) / dir.y; //дистанция от позиции камеры до плоскости (расстояние вдоль луча, соответствующее к.-н. геометрии)\n    if (t <= 0.0) { //то что за спиной\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos; //мировые координаты точки до плоскости\n    if (dot(worldPos.xz, worldPos.xz) >= 50.0) { //ограничиваем кругом (все что за кругом - не видим)\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\n// трассировка сферы\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // dot(dir, dir) * t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (t > 0.0) { //наименьший\n        normal = normalize(pos + t * dir); //позиция и нормаль совпадают\n        return t;\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\n// трассировка цилиндра\nfloat traceCylinder(vec3 pos, vec3 dir, vec3 p, float h, float r, out vec3 normal) {\n    //нижнее основание конуса - окружность\n    float t = (p.y - pos.y) / dir.y;\n    float T = INF;\n    if (t <= 0.0) t = INF;\n    vec3 worldPos = t * dir + pos;\n    if (length(worldPos.xz - p.xz) < r) {\n        normal = vec3(0, -1, 0);\n        T=t;\n    }\n    \n    //верхнее основание конуса - окружность\n    t = (p.y+h - pos.y) / dir.y;\n    if (t <= 0.0) t = INF;\n    worldPos = t * dir + pos;\n    if (length(worldPos.xz - p.xz) < r && t < T) {\n        normal = vec3(0, 1, 0);\n        T=t;\n    }\n    \n    // боковая поверхность цилиндра (y=const)\n    vec3 posO = pos - p; //смещенная поцизия центра\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(posO.xz, dir.xz);\n    float c = dot(posO.xz, posO.xz) - r * r;\n    float D = b * b - a * c;\n    if (D >= 0.0) {\n        float t1 = (-b - sqrt(D)) / a;\n        float t2 = (-b - sqrt(D)) / a;\n        \n        t = t1 < t2 ? t1 : t2;\n        if (t > 0.0) {\n            worldPos = t * dir + pos;\n            if (worldPos.y >= p.y && worldPos.y <= p.y + h) {\n                normal = normalize(vec3(worldPos.x-p.x, 0, worldPos.z-p.z));\n                return t;\n            }\n        }\n    }\n    return T;\n}\n\n// трассировка параллелепипеда\nfloat traceBox(vec3 pos, vec3 dir, vec3 p, vec3 size, out vec3 normal) {\n    //ближайшие к нам грани параллелепипеда по X, Y, Z\n    float nearX = abs(pos.x - p.x) < abs(pos.x - (p.x+size.x)) ? p.x : p.x+size.x; //правая или левая боковая грань\n    float nearY = abs(pos.y - p.y) < abs(pos.y - (p.y+size.y)) ? p.y : p.y+size.y; //нижняя или верхняя грань\n    float nearZ = abs(pos.z - p.z) < abs(pos.z - (p.z+size.z)) ? p.z : p.z+size.z; //передняя или задняя\n\n    //правая или левая боковая грань\n    // (CAMERA_POS + t * viewVec).x == p.x\n    // t = (p.x - CAMERA_POS.x) / viewVec.x;\n    float t = (nearX - pos.x) / dir.x;\n    float T = INF;\n    if (t <= 0.0) t = INF;\n    vec3 worldPos = t * dir + pos;\n    if (worldPos.y >= p.y && worldPos.y <= p.y+size.y &&\n        worldPos.z >= p.z && worldPos.z <= p.z+size.z && t < T) {\n        normal = (nearX==p.x) ? vec3(-1, 0, 0) : vec3(1, 0, 0);\n        T = t;\n    }\n\n    //нижняя или верхняя грань\n    t = (nearY - pos.y) / dir.y;\n    if (t <= 0.0) t = INF;\n    worldPos = t * dir + pos;\n    if (worldPos.x >= p.x && worldPos.x <= p.x+size.x &&\n        worldPos.z >= p.z && worldPos.z <= p.z+size.z && t < T) {\n        normal = (nearY==p.y) ? vec3(0, -1, 0) : vec3(0, 1, 0);\n        T = t;\n    }\n\n    //передняя или задняя грань\n    t = (nearZ - pos.z) / dir.z;\n    if (t <= 0.0) t = INF;\n    worldPos = t * dir + pos;\n    if (worldPos.y >= p.y && worldPos.y <= p.y+size.y &&\n        worldPos.x >= p.x && worldPos.x <= p.x+size.x && t < T) {\n        normal = (nearZ==p.z) ? vec3(0, 0, -1) : vec3(0, 0, 1);\n        T = t;\n    }\n\n    return T;\n}\n\n// трассировка треугольной призмы\nfloat traceTrPrism(vec3 pos, vec3 dir, vec3 p, vec3 size, out vec3 normal) {\n    //нижняя плоскость - прямоугольник\n    float t = (p.y - pos.y) / dir.y;\n    float T = INF;\n    if (t <= 0.0) t = INF;\n    vec3 worldPos = t * dir + pos;\n    if (worldPos.x >= p.x && worldPos.x <= p.x+size.x &&\n        worldPos.z >= p.z && worldPos.z <= p.z+size.z) {\n        normal = vec3(0, -1, 0);\n        T = t;\n    }\n    \n    //передняя плоскость - треугольник\n    float k1 = 2.0*size.y / size.x, k2 = -k1; //коэффициэнты наклонных прямых\n    float b1 = p.y-k1*p.x, b2 = p.y-k2*(p.x+size.x); \n    t = (p.z - pos.z) / dir.z;\n    if (t <= 0.0) t = INF;\n    worldPos = t * dir + pos;\n    if (worldPos.y >= p.y &&\n        worldPos.y <= k1*worldPos.x + b1 && \n        worldPos.y <= k2*worldPos.x + b2 && t < T) {\n        normal = vec3(0, 0, -1);\n        T=t;\n    }\n    \n    //задняя плоскость\n    t = (p.z+size.z - pos.z) / dir.z;\n    if (t <= 0.0) t = INF;\n    worldPos = t * dir + pos;\n    if (worldPos.y >= p.y &&\n        worldPos.y <= k1*worldPos.x + b1 && \n        worldPos.y <= k2*worldPos.x + b2 && t < T) {\n        normal = vec3(0, 0, 1);\n        T=t;\n    }\n         \n    //правая боковая плоскость - наклонный прямоугольник\n    // | (x-x0) (y-y0) (z-z0) |\n    // |   ax     ay     az   | = 0\n    // |   bx     by     bz   |\n    \n    float ax=size.x/2.0, ay=size.y, az=0.0; //координаты векторов плоскости\n    float bx=0.0, by=0.0, bz=size.z;\n    vec3 p0 = p; //точка лежащая на плоскости\n    \n    float A=ay*bz-az*by; \n    float B=az*bx-ax*bz;\n    float C=ax*by-ay*bx;\n    //float D=az*by*x0-ay*bz*x0+ax*bz*y0-az*bx*y0+ay*bx*z0-ax*by*z0;\n\n    vec3 norm = vec3(A, B, C);\n    \n    //косинус угла между нормалью и вектором WP = 0, W=WorldPos, P=p0, => W лежит в пл.\n    //dot((pos + t * dir) - p0, norm) == 0 \n    //dot(pos, norm) - dot(p0, norm) + t*dot(dir, norm) = 0\n    //t = (dot(p0, norm) - dot(pos, norm)) / dot(dir, norm)\n    t = dot(p0-pos, norm) / dot(dir, norm);\n    if (t <= 0.0) t = INF;\n    worldPos = t * dir + pos;\n    if (worldPos.x >= p.x && worldPos.x <= p.x + size.x/2.0 &&\n        worldPos.y >= p.y && worldPos.y <= p.y+size.y && \n        worldPos.z >= p.z && worldPos.z <= p.z+size.z && t < T) {\n        normal = normalize(norm);\n        T=t;\n    }\n    \n    //левая боковая плоскость\n    ax = -ax;\n    B = az*bx-ax*bz; //0*0-ax*bz;\n    C = ax*by-ay*bx; //ax*by-ay*0;\n    p0 = vec3(p.x+size.x, p.y, p.z);\n    \n    norm = vec3(A, B, C);\n    \n    t = dot(p0-pos, norm) / dot(dir, norm);\n    if (t <= 0.0) t = INF;\n    worldPos = t * dir + pos;\n    if (worldPos.x >= p.x + size.x/2.0 && worldPos.x <= p.x+size.x &&\n        worldPos.y >= p.y && worldPos.y <= p.y+size.y && \n        worldPos.z >= p.z && worldPos.z <= p.z+size.z && t < T) { \n        normal = normalize(norm);\n        T=t;\n    }\n    \n    return T;\n}\n\n// трассировка прямоугольной пирамиды\nfloat tracePyramid(vec3 pos, vec3 dir, vec3 p, vec3 size, out vec3 normal) {\n    //нижняя плоскость - прямоугольник\n    float t = (p.y - pos.y) / dir.y;\n    float T = INF;\n    if (t <= 0.0) t = INF;\n    vec3 worldPos = t * dir + pos;\n    if (worldPos.x >= p.x && worldPos.x <= p.x+size.x &&\n        worldPos.z >= p.z && worldPos.z <= p.z+size.z) {\n        normal = vec3(0, -1, 0);\n        T = t;\n    }\n    \n    vec3 top = vec3(p.x+size.x/2.0, p.y+size.y, p.z+size.z/2.0); //координата вершины\n    \n    //боковые плоскости - наклонные треугольники\n    float ax=size.x, ay=0.0, az=0.0;\n    float bx=size.x/2.0, by=size.y, bz=size.z/2.0;\n    vec3 p0 = p, p1 = vec3(p.x+size.x, p.y, p.z); //координаты точек основания\n    \n    float A=ay*bz-az*by; \n    float B=az*bx-ax*bz;\n    float C=ax*by-ay*bx;\n\n    vec3 norm = vec3(A, B, C);\n    \n    //dot((pos + t * dir) - p0, norm) == 0 \n    t = dot(p0-pos, norm) / dot(dir, norm);\n    if (t > 0.0 && t < T) {\n        worldPos = t * dir + pos;\n\n        vec3 a = vec3(ax, ay, az);\n        vec3 b = vec3(bx, by, bz);\n        vec3 c = a - b;\n        vec3 d1 = worldPos - p0;\n        vec3 d2 = p1 - worldPos;\n        float cosB = dot(a, b) / (length(a) * length(b));\n        float cosC = dot(a, c) / (length(a) * length(c));\n        float cosD1 = dot(a, d1) / (length(a) * length(d1));\n        float cosD2 = dot(a, d2) / (length(a) * length(d2));\n\n        //угол меньше, чем угол треугольника, => косинус больше\n        if (cosD1 >= cosB && cosD2 >= cosB &&\n            worldPos.y >= p.y && worldPos.y <= p.y+size.y) {\n            normal = normalize(norm);\n            T=t;\n        }\n    }\n    \n    ax=0.0; az=size.z;\n    bx=-size.x/2.0;\n    p0 = p1; p1 = vec3(p.x+size.x, p.y, p.z+size.z);\n    A=ay*bz-az*by; B=az*bx-ax*bz; C=ax*by-ay*bx;\n    norm = vec3(A, B, C);\n    \n    t = dot(p0-pos, norm) / dot(dir, norm);\n    if (t > 0.0 && t < T) {\n        worldPos = t * dir + pos;\n\n        vec3 a = vec3(ax, ay, az);\n        vec3 b = vec3(bx, by, bz);\n        vec3 c = a - b;\n        vec3 d1 = worldPos - p0;\n        vec3 d2 = p1 - worldPos;\n        float cosB = dot(a, b) / (length(a) * length(b));\n        float cosC = dot(a, c) / (length(a) * length(c));\n        float cosD1 = dot(a, d1) / (length(a) * length(d1));\n        float cosD2 = dot(a, d2) / (length(a) * length(d2));\n\n        if (cosD1 >= cosB && cosD2 >= cosB &&\n            worldPos.y >= p.y && worldPos.y <= p.y+size.y) {\n            normal = normalize(norm);\n            T=t;\n        }\n    }\n    \n    ax=-size.x; az=0.0;\n    bz=-size.z/2.0;\n    p0 = p1; p1 = vec3(p.x, p.y, p.z+size.z);\n    A=ay*bz-az*by; B=az*bx-ax*bz; C=ax*by-ay*bx;\n    norm = vec3(A, B, C);\n    \n    t = dot(p0-pos, norm) / dot(dir, norm);\n    if (t > 0.0 && t < T) {\n        worldPos = t * dir + pos;\n        \n        vec3 a = vec3(ax, ay, az);\n        vec3 b = vec3(bx, by, bz);\n        vec3 c = a - b;\n        vec3 d1 = worldPos - p0;\n        vec3 d2 = p1 - worldPos;\n        float cosB = dot(a, b) / (length(a) * length(b));\n        float cosC = dot(a, c) / (length(a) * length(c));\n        float cosD1 = dot(a, d1) / (length(a) * length(d1));\n        float cosD2 = dot(a, d2) / (length(a) * length(d2));\n\n        if (cosD1 >= cosB && cosD2 >= cosB &&\n            worldPos.y >= p.y && worldPos.y <= p.y+size.y) {\n            normal = normalize(norm);\n            T=t;\n        }\n    }\n    \n    ax=0.0; az=-size.z;\n    bx=size.x/2.0;\n    p0 = p1; p1 = p;\n    A=ay*bz-az*by; B=az*bx-ax*bz; C=ax*by-ay*bx;\n    norm = vec3(A, B, C);\n    \n    t = dot(p0-pos, norm) / dot(dir, norm);\n    if (t > 0.0 && t < T) {\n        worldPos = t * dir + pos;\n        \n        vec3 a = vec3(ax, ay, az);\n        vec3 b = vec3(bx, by, bz);\n        vec3 c = a - b;\n        vec3 d1 = worldPos - p0;\n        vec3 d2 = p1 - worldPos;\n        float cosB = dot(a, b) / (length(a) * length(b));\n        float cosC = dot(a, c) / (length(a) * length(c));\n        float cosD1 = dot(a, d1) / (length(a) * length(d1));\n        float cosD2 = dot(a, d2) / (length(a) * length(d2));\n\n        if (cosD1 >= cosB && cosD2 >= cosB &&\n            worldPos.y >= p.y && worldPos.y <= p.y+size.y) {\n            normal = normalize(norm);\n            T=t;\n        }\n    }\n    \n    return T;\n}\n\n// трассировка конуса\nfloat traceCone(vec3 pos, vec3 dir, vec3 p, float h, float r, out vec3 normal) {\n    //нижнее основание конуса - окружность\n    float t = (p.y - pos.y) / dir.y;\n    float T = INF;\n    if (t <= 0.0) t = INF;\n    vec3 worldPos = t * dir + pos;\n    if (length(worldPos.xz - p.xz) < r) {\n        normal = vec3(0, -1, 0);\n        T=t;\n    }\n    \n    //смещенная относительно центра позиция вершины конуса\n    vec3 posO = pos - vec3(p.x, p.y+h, p.z); \n    //A - половинный угол конуса\n    float tgA = r / h; \n    float cosA = h / sqrt(h*h + r*r);\n\n    // боковая поверхность конуса\n\t// dot(pos-p, (0,1,0))*dot(pos-p, (0,1,0)) + 2 * t * (dot(dir, (0,1,0))*dot(pos-p, (0,1,0)) - dot(dir, pos-p) * cosA*cosA) + t * t * (dot(dir, (0,1,0)) * dot(dir, (0,1,0)) - cosA*cosA) == dot(pos-p, pos-p) * cosA*cosA\n\t// (dot(dir, dir).y - cosA*cosA) * t * t + 2 * (dot(dir, pos-p).y - dot(dir, pos-p) * cosA*cosA) * t +  dot(pos-p, pos-p).y - dot(pos-p, pos-p) * cosA*cosA == 0\n    float a = dir.y*dir.y - cosA*cosA;\n    float b = dir.y*posO.y - dot(dir, posO) * cosA*cosA;\n    float c = posO.y*posO.y - dot(posO, posO) * cosA*cosA;\n\n    float D = b * b - a * c;\n    if (D >= 0.0) {\n\t\tfloat t1 = (-b - sqrt(D)) / a;\n\t\tfloat t2 = (-b + sqrt(D)) / a;\n\n\t\tfloat t = t1 < t2 ? t1 : t2;\n\t\tif (t >= 0.0) {\n\t\t\tworldPos = t * dir + pos;\n            float y = worldPos.y - p.y;\n            float x = length(worldPos.xz - p.xz);\n\t\t\tif (y >= 0.0 && y <= h && t < T) {\n                normal = normalize(vec3(worldPos.x-p.x, x*tgA, worldPos.z-p.z));\n\t\t\t\tT = t;\n\t\t\t}\n\t\t}\n     }\n    return T;\n}\n\n\nvec4 minT(vec4 t1, vec4 t2) {\n    return t1.w < t2.w ? t1 : t2;\n}\n\n// трассировка здания внутри сферы\nfloat traceBuilding(vec3 curPos, vec3 curDir, out vec3 normal, out vec3 color) {\n    float t = INF;\n   \n    vec3 boxNorm;\n    vec3 sph1Norm;\n    vec3 cylNorm;\n    vec3 prismNorm;\n    vec3 con1Norm,con2Norm,con3Norm,con4Norm;\n    vec3 pyramNorm;\n    \n    vec4 box1T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.12, -0.35, -0.12), vec3(0.24, 0.5, 0.24), boxNorm));\n    vec4 box2T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.09, 0.15, -0.09), vec3(0.18, 0.15, 0.18), boxNorm));\n    vec4 box3T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.05, 0.3, -0.05), vec3(0.10, 0.1, 0.10), boxNorm));\n    vec4 box4T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.32, -0.35, -0.06), vec3(0.2, 0.25, 0.1), boxNorm));\n    vec4 box5T = vec4(boxNorm, traceBox(curPos, curDir, vec3(0.12, -0.35, -0.06), vec3(0.2, 0.25, 0.1), boxNorm));\n    vec4 box6T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.42, -0.35, -0.2), vec3(0.1, 0.25, 0.4), boxNorm));\n    vec4 box7T = vec4(boxNorm, traceBox(curPos, curDir, vec3(0.32, -0.35, -0.2), vec3(0.1, 0.25, 0.4), boxNorm));\n    vec4 box8T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.47, -0.35, -0.25), vec3(0.1, 0.3, 0.1), boxNorm));\n    vec4 box9T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.47, -0.35, 0.15), vec3(0.1, 0.3, 0.1), boxNorm));\n    vec4 box10T = vec4(boxNorm, traceBox(curPos, curDir, vec3(0.37, -0.35, -0.25), vec3(0.1, 0.3, 0.1), boxNorm));\n    vec4 box11T = vec4(boxNorm, traceBox(curPos, curDir, vec3(0.37, -0.35, 0.15), vec3(0.1, 0.3, 0.1), boxNorm));\n    vec4 box12T = vec4(boxNorm, traceBox(curPos, curDir, vec3(-0.10, -0.35, -0.37), vec3(0.2, 0.1, 0.3), boxNorm));\n    \n    vec4 Box = minT(box1T, minT(box2T, minT(box3T, minT(box4T, minT(box5T, \n               minT(box6T, minT(box7T, minT(box8T, minT(box9T, minT(box10T, minT(box11T, box12T)))))))))));\n    \n    float prismT = traceTrPrism(curPos, curDir, vec3(-0.10, -0.25, -0.37), vec3(0.2, 0.05, 0.3), prismNorm);\n\n    float sph1T = traceSphere(curPos - vec3(0, 0.62, 0), curDir, 0.04, sph1Norm);\n    \n    vec4 cyl1T = vec4(cylNorm, traceCylinder(curPos, curDir, vec3(0, 0.4, 0), 0.22, 0.02, cylNorm));\n    vec4 cyl2T = vec4(cylNorm, traceCylinder(curPos, curDir, vec3(-0.12, -0.35, -0.12), 0.5, 0.03, cylNorm));\n    vec4 cyl3T = vec4(cylNorm, traceCylinder(curPos, curDir, vec3(-0.12, -0.35, 0.12), 0.5, 0.03, cylNorm));\n    vec4 cyl4T = vec4(cylNorm, traceCylinder(curPos, curDir, vec3(0.12, -0.35, -0.12), 0.5, 0.03, cylNorm));\n    vec4 cyl5T = vec4(cylNorm, traceCylinder(curPos, curDir, vec3(0.12, -0.35, 0.12), 0.5, 0.03, cylNorm));\n    \n    vec4 Cyl = minT(cyl1T, minT(cyl2T, minT(cyl3T, minT(cyl4T, cyl5T))));\n\n   \n    /*vec4 pyram1T = vec4(pyramNorm, tracePyramid(curPos, curDir, vec3(-0.47, -0.1, -0.25), vec3(0.1, 0.1, 0.1), pyramNorm));\n    vec4 pyram2T = vec4(pyramNorm, tracePyramid(curPos, curDir, vec3(-0.47, -0.1, 0.15), vec3(0.1, 0.1, 0.1), pyramNorm));\n    vec4 pyram3T = vec4(pyramNorm, tracePyramid(curPos, curDir, vec3(0.37, -0.1, -0.25), vec3(0.1, 0.1, 0.1), pyramNorm));\n    vec4 pyram4T = vec4(pyramNorm, tracePyramid(curPos, curDir, vec3(0.37, -0.1, 0.15), vec3(0.1, 0.1, 0.1), pyramNorm));\n    \n    vec4 Pyram = minT(pyram1T, minT(pyram2T, minT(pyram3T, pyram4T)));\n    */\n    /*float con1T = traceCone(curPos, curDir, vec3(-0.12, 0.15, -0.12), 0.08, 0.03, con1Norm);\n    float con2T = traceCone(curPos, curDir, vec3(-0.12, 0.15, 0.12), 0.08, 0.03, con2Norm);\n    float con3T = traceCone(curPos, curDir, vec3(0.12, 0.15, -0.12), 0.08, 0.03, con3Norm);\n    float con4T = traceCone(curPos, curDir, vec3(0.12, 0.15, 0.12), 0.08, 0.03, con4Norm);\n    */\n\n\n    if (Box.w < t) {\n        t = Box.w; normal = Box.xyz; }\n        \n    if (prismT < t) {\n        t = prismT; normal = prismNorm; }\n    \n    if (sph1T < t) {\n        t = sph1T; normal = sph1Norm; }\n    \n    if (Cyl.w < t) {\n        t = Cyl.w; normal = Cyl.xyz; }\n        \n    //if (Pyram.w < t) {\n    //    t = Pyram.w; normal = Pyram.xyz; }\n    \n    /*if (con1T < t) {\n        t = con1T; normal = con1Norm; }\n    if (con2T < t) {\n        t = con2T; normal = con2Norm; }\n    if (con3T < t) {\n        t = con3T; normal = con3Norm; }\n    if (con4T < t) {\n        t = con4T; normal = con4Norm; }*/\n        \n    \n    if (t == Box.w) {\n        color = vec3(1, 0.77, 0.3) + (abs(normal)*0.25); }  \n    if (t == Cyl.w) {\n        color = vec3(1, 0.72, 0.2) + (abs(normal)*0.25); }\n    if (t == cyl1T.w || t == box3T.w || t == box12T.w || t == prismT) {\n        color = vec3(1, 0.65, 0) + (abs(normal)*0.25); }\n    if (t == sph1T) {\n        color = vec3(1, 0.1, 0) + (abs(normal)*0.25); }\n    \n    return t;\n}\n\n\n//для тени - перекрывает ли что-то\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm);\n    if (sphT < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, vec3(0,-1.2,0), 0.2, 1.4, cylNorm);\n    return (cylT < dist);\n}\n\n//вычисление освещения\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 20.0f / distSq1; //перекрыт ли источник света\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 10.0f / distSq2;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1; //n2, n1 - коэффициэнты преломления двух сред; вычисляем синус преломленного луча\n    if (sinB > 1.0) { //полное внутреннее отражение\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\nvec3 camera(vec2 fragCoord, vec3 randVals) {\n    //uv - координаты двумерной текстуры, куда мы рисуем\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x; \n    //- iResolution.xy * 0.5 - сдвигаем на половину разрешения в центр экрана; / iResolution.x - чтобы сохранить геом.пропорции\n    // + (randVals.xy - 0.5) - для сглаживания границ: каждый кадр случайно смещаем координаты в пределах пикселя\n    vec3 front = normalize(-CAMERA_POS); //вектор, направленный вперед --- (ось z)\n    vec3 up = vec3(0, 1, 0); //вектор, направленный вверх --- (ось y)\n    vec3 right = normalize(cross(front, up)); //вектор вправо - векторное произведение векторов -- (ось x)\n    up = normalize(cross(right, front)); //пересчитываем вектор вверх\n    return normalize(front + right * uv.x + up * uv.y); //вектор направления для каждого пикселя\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    \n    vec3 viewVec = camera(fragCoord, randVals);\n        \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    \n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    \n    for (int i = 0; i < 200; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n\t//перебираем все точки пересечения, ищем ближайшие из них (проверяем пересечение луча со всеми объектами)\n\t\n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm); //расстояние до точки пересечения\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) { //сфера света ближе, => рисуем её\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 sphNorm;\n        float sphT = traceSphere(curPos, curDir, 1.0, sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = sphNorm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.8, 1, 1);\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N; //из сферы наружу луч выходит\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, vec3(0,-1.2,0), 0.2, 1.4, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        \n        vec3 buildNorm, buildColor;\n        float buildT = traceBuilding(curPos, curDir, buildNorm, buildColor);\n        if (buildT < t) {\n            t = buildT;\n            materialType = PROPHECY;\n            color = buildColor;\n            normal = buildNorm;\n        }\n        \n\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz); //рисуем текстуру\n            if (materialType == EMISSION) { //материал излучает свет\n                fragColor.rgb = color;// * colorMult; \n                break; \n            } \n            else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal);// * colorMult;\n                break;\n            } \n            else if (materialType == PROPHECY) {\n                float fog = clamp((worldPos.y + 0.3) / 0.6, 0.0, 0.8); \n                color = color * (1.0 - fog) + fog * fog_color; \n                //color = mix(fog_color, color, fog);\n                fragColor.rgb = color;\n                break;\n            } \n            else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5; //прибавляем небольшое значение, чтобы отражение не попадало в само себя(иначе шум)\n            } \n            else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            } \n        }\n        else { // никуда не попали => фон\n            fragColor.rgb = texture(iChannel1, curDir).rgb;// * colorMult; \n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}