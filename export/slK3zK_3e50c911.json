{"ver":"0.1","info":{"id":"slK3zK","date":"1638197687","viewed":75,"name":"simple sphere+light ray marching","username":"EDB_02","description":"sksk","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"flyGzV","parentname":"first amogus"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max_steps 256\n#define epsi 1e-5\n#define max_dist 100.0\n\nvec3 camPos = vec3(0, 0, 0);\n\nstruct Sphere{\n    vec3 pos;    //centre of the sphere\n    float radius;\n};\n\nstruct Ray{\n    vec3 pos;   //position of the ray\n    vec3 rot;   //direction\n};\n\nstruct Light{\n    vec3 pos;  //position\n};\n\nLight initLight(in vec3 pos){\n    Light l;\n    l.pos = pos;\n    return l;\n}\n\nSphere initSphere(in vec3 pos, in float r){\n    Sphere s;\n    s.pos = pos;\n    s.radius = r;\n    return s;\n}\n\nfloat sphereSDF(in vec3 point, in Sphere s){\n    return distance(point, s.pos)-s.radius;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nRay initRay(in vec3 pos,in vec2 fragCoord){\n    Ray r;\n    r.pos = pos;\n    r.rot = rayDirection(45.0, iResolution.xy, fragCoord);\n    return r;\n}\n\n// number of spheres\n\n#define sphereC 2\nSphere s[sphereC];\nLight l;\n\nbool check1 = false;\n\nvoid initScene(){\n    if(check1) return;   //initialize the scene only 1 time\n    check1 = true;\n    \n    s[0] = initSphere(vec3(0, 0, 10), 1.0f);\n    s[1] = initSphere(vec3(3, .5, 10), .5f);\n    l = initLight(vec3(10, 0, 20));\n}\n\nfloat sceneSDF(in vec3 p){\n    float ret = max_dist;\n    \n    for(int i=0;i<sphereC;++i){\n        ret = min(ret, sphereSDF(p, s[i]));\n    }\n    \n    //displacement ff\n    // ret += sin(5.0 * p.x ) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25 * sin(iTime);\n    \n    return ret;\n}\n\nvec3 estimateNormal(in vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + epsi, p.y, p.z)) - sceneSDF(vec3(p.x - epsi, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + epsi, p.z)) - sceneSDF(vec3(p.x, p.y - epsi, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + epsi)) - sceneSDF(vec3(p.x, p.y, p.z - epsi))\n    ));\n}\n\nvec3 getColor(in vec3 p){\n    \n    vec3 normal = estimateNormal(p);\n    \n    vec3 direction_to_light = normalize(p - l.pos);\n\n    float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n    return vec3(1.0, 1.0, 1.0) * diffuse_intensity;\n}\n\nvoid rotateLight(){\n    float x = 50.0 * sin(iTime);\n    float y = 50.0 * cos(iTime);\n    \n    l.pos = vec3(x, 30, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initScene();\n    \n    rotateLight();\n    \n    Ray ray = initRay(vec3(0), fragCoord);\n    \n    float dist;\n    \n    for(int i=0;i<max_steps;++i){\n        dist = sceneSDF(ray.pos);\n        \n        if(dist <= epsi){\n            fragColor = vec4(getColor(ray.pos), 1.0f);\n            break;\n        }\n        \n        if(dist >= max_dist){\n            fragColor = vec4(0.0f);\n            break;\n        }\n        \n        ray.pos += ray.rot * dist;\n    }    \n}\n\n\n\n","name":"Image","description":"","type":"image"}]}