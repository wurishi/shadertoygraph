{"ver":"0.1","info":{"id":"mtXBDB","date":"1693406234","viewed":58,"name":"Complex Domain/Codomain Plot (2)","username":"Envy24","description":"Shows complex function as distribution.\nHold LMB to add uniformly distibuted samples.\nOther related shaders:\nhttps://www.shadertoy.com/view/msScWw\nhttps://www.shadertoy.com/view/mdlBRr\nhttps://www.shadertoy.com/view/mssfRr","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["domain","graph","plot","complex","distribution","codomain"],"hasliked":0,"parentid":"mtXBWB","parentname":"Complex Domain/Codomain Plot (1)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    O = vec4(texelFetch(iChannel0, ivec2(SC), 0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hu2to2sf(\n    const uint x,\n    const uint y)\n{\n    // Pick some seed values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * seed2 + x;\n    uint value1 = x * seed2 + y;\n\n    // Calculate hash.\n\tvalue0 += seed1; value0 *= 445593459u; value0 ^= seed0;\n    value1 += seed1; value1 *= 445593459u; value1 ^= seed0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define Hu2to2sf(P) ( hu2to2sf(uint(P.x), uint(P.y)) )\n\n/*Conversion*/\nvec2 cartesian(vec2 z) { return z.x * vec2(cos(z.y), sin(z.y)); }\nvec2 polar(vec2 z) { return vec2(length(z), atan(z.y, z.x)); } // atan2 implementation: https://www.shadertoy.com/view/csf3Wl\n\n/*Complex arithmetic in Cartesian coordinates vec2(Re, Im)*/\nvec2 complex(float real) { return vec2(real, 0); }\nvec2 cadd(vec2 l, vec2 r) { return vec2(l.x+r.x, l.y+r.y); }\nvec2 csub(vec2 l, vec2 r) { return vec2(l.x-r.x, l.y-r.y); }\nvec2 cmul(vec2 z, float s) { return z*s; }\nvec2 cmul(float s, vec2 z) { return s*z; }\nvec2 cmul(vec2 l, vec2 r) { return vec2(l.x*r.x-l.y*r.y, l.y*r.x+l.x*r.y); }\nvec2 cdiv(vec2 l, vec2 r) { \n\tfloat inv = 1.0 / (r.x*r.x+r.y*r.y);\n\treturn inv * vec2(l.x*r.x+r.y*l.y, r.x*l.y-l.x*r.y);\n}\nvec2 conjugate(vec2 z) { return vec2(z.x, -z.y); }\nvec2 cexp(float theta) { return vec2(cos(theta), sin(theta)); } // Euler formula\n// source: https://www.shadertoy.com/view/DdsSRS\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\nvec2 csqrt(vec2 z) {\n  float t = carg(z);\n  return sqrt(length(z))*vec2(cos(0.5*t),sin(0.5*t));\n}\nvec2 ccbrt0(vec2 z) {\n  // Trigless Newton Raphson verson\n  float r = length(z);\n  z /= r; // Normalize z\n  vec2 u = z+vec2(1,0); // First approximation (when normalized)\n  for (int i = 0; i < 4; i++) {\n    u = normalize(u);\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n// https://www.shadertoy.com/view/ltjczK\n//vec2 clog(vec2 z) { return polar(vec2(log(z.x),z.y)); }\nvec2 cpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\nvec2 cpow(float n, vec2 z) { return vec2(exp(log(n)*z.x*cos(z.y)),log(n)*z.x*sin(z.y)); }\nvec2 cpow(vec2 z1, vec2 z2) { return cpow(exp(1.),cmul(clog(z1),z2)); }\n\n/*Complex arithmetic in Polar coordinates vec2(mag, theta)*/\nvec2 caddp(vec2 z1, vec2 z2) { return polar(cartesian(z1) + cartesian(z2)); }\nvec2 csubp(vec2 z1, vec2 z2) { return polar(cartesian(z1) - cartesian(z2)); }\nvec2 cmulp(vec2 l, vec2 r) { return vec2(l.x*r.x, l.y+r.y); }\nvec2 cdivp(vec2 l, vec2 r) { return vec2(l.x/r.x, l.y-r.y); }\nvec2 conjugated(vec2 z) { return vec2(z.x, -z.y); }\n\n/*Complex functions*/\n//sinz, cosz and tanz came from -> https://www.shadertoy.com/view/Mt2GDV\nvec2 csin(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(sin(z.x)*cosh,cos(z.x)*sinh));\n}\nvec2 ccos(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(cos(z.x)*cosh,-sin(z.x)*sinh));\n}\nvec2 ctan(vec2 z) {\n    z = cartesian(z);\n    float e1 = exp(z.y);\n    float e2 = exp(-z.y);\n    float cosx = cos(z.x);\n    float sinh = (e1 - e2)*0.5;\n    float cosh = (e1 + e2)*0.5;\n    return polar(vec2(sin(z.x)*cosx, sinh*cosh)/(cosx*cosx + sinh*sinh));\n}\nvec2 lambert(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<15; i++)\n      sum += cartesian(cdivp(cpow(z,float(i)),csubp(vec2(1.,.0),cpow(z,float(i)))));\n   return polar(sum);\n}\n// More functions here: https://www.shadertoy.com/view/ltjczK","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SCENE_SCALE               ( 5.0 )\n#define AA_UNIT                   ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec3 grid(in vec2 NDC)\n{\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );       \n\n    return color;\n}\n\nfloat num_of_samples = 300.;\nvec2 f(vec2 z)\n{\n    vec2 zz = cmul(z,z),\n         zzzz= cmul(zz, zz);\n    \n    return cmul(z, zzzz) + cmul(z, zz);\n}\nvec2 domain(float s)\n{\n    float T = iTime * s;\n    vec2 S = Hu2to2sf( vec2(T/2., T/3.) ) * SCENE_SCALE;\n    \n    if (iMouse.z > 0.)\n        return S;\n\n    float r = round(length(S)) / 4.;\n    return normalize(S) * r;\n}\n\nvec2 codomain(float s)\n{\n    return f(domain(s));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y * SCENE_SCALE,\n          o = ar * 0.5;\n    \n    vec2  NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2( 0, 0), false),\n         dNDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2( o, 0), false),\n         cNDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(-o, 0), false);\n    \n    if (iFrame == 0)\n    {\n        vec3 color = SC.x >= R.x*0.5 ? grid(cNDC) : grid(dNDC);\n             color = mix(color, vec3(1,0,0), SMAA(vertical_lineSDF(NDC, 0.)));\n             \n        O = vec4(color, 1);\n        return;\n    }\n\n    vec3 curve_col = SC.x >= R.x*0.5 ? vec3(0,0,1) : vec3(0,.5,.5);\n    float min_d = 9e5;\n    \n    if (SC.x >= R.x*0.5)\n    {\n        for (float s = 0.; s < num_of_samples; s += 1.)\n              min_d = min(min_d, diskSDF(cNDC, codomain(s), 0.008));\n    }\n    else\n    {\n        for (float s = 0.; s < num_of_samples; s += 1.)\n            min_d = min(min_d, diskSDF(dNDC, domain(s), 0.008)); \n    }\n                                    \n    vec3 pcolor = texelFetch(iChannel0, ivec2(SC), 0).rgb,\n         color = mix(vec3(1), curve_col, SMAA(min_d));\n    \n    O = vec4(min(color, pcolor), 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}