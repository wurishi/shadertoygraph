{"ver":"0.1","info":{"id":"7sBSWV","date":"1621023930","viewed":169,"name":"Voxel Reflections Fork","username":"latel88","description":"fork \"Voxel Reflections\" by wildniklin\nhttps://www.shadertoy.com/view/NsjSWy","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["stupid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 getColor ( const in vec2 uv )\n{\n    return getCheckerPixel( iChannel0, uv, iResolution.xy ).rgb;\n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    vec2 coord = fragCoord;\n    \n    vec2 uv = coord.xy / resolution.xy;\n    \n    vec3 color = getColor( uv );\n\n    fragColor = vec4(color, 0.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nconst float PI = 3.1415;\nconst float TAU = PI * 2.0;\n\nmat2 rot(float r)\n{\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\n// CONFIG\n\nconst int REFLECTION_STEPS = 10;\nconst float RENDER_DIST = 100.0;\nvec3 sky(vec3 rd)\n{\n    return mix(vec3(0.2, 0.2, 0.2), vec3(0.7, 0.7, 0.7), saturate(rd.y));\n}\n\nvec3 light(vec3 p, vec3 n)\n{\n    vec3 l = vec3(0.2, 0.2, 0.2); // Ambient\n    l += 1.1 * vec3(1.0, 0.95, 0.9) * saturate(dot(n, vec3(0.2, 0.6, 0.5))); // Directional\n    return l;\n}\n\n// CONFIG END\n\n// ADD Methods\n\nfloat modI ( const in float a, const in float b )\n{\n    float m = a - floor( (a + 0.5) / b ) * b;\n    \n    return floor( m + 0.5 );\n    \n}\n\nconst vec2 checkerOffset[4] = vec2[4](\n\tvec2( 0, 0),\n    vec2(-1, 0),\n    vec2( 0, 1),\n    vec2( 0,-1)\n);\n\nvec2 compactCheckerUV ( const in vec2 u, const in vec2 coord, const in vec2 rez )\n{\n    vec2 r = vec2(rez.x / 2.0, rez.y);\n\n    return u - 1.0 / r * vec2(modI( coord.y, 2.0 ) == modI( coord.x, 2.0 ), 0.0);\n    \n}\n\nvec4 getCheckerPixel ( const in sampler2D tex, const in vec2 uv, const in vec2 rez )\n{\n    vec2 coord = floor( uv * vec2(rez.x / 2.0, rez.y) );\n    \n\tif (modI( coord.x, 2.0 ) == modI( coord.y, 2.0 ))\n\t{\n\t\tvec4 outCol = vec4(0.0);\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tvec4 pix = texelFetch(\n\t\t\t\ttex,\n\t\t\t\tivec2(floor( max( vec2(0.0), coord.xy + checkerOffset[i] ) )),\n\t\t\t\t0\n            );\n\n\t\t\toutCol += pix;\n\t\t\n\t\t}\n\t\t\n\t\treturn outCol / 4.0;\n\t}\n\telse\n\t{\n\t\treturn texelFetch(\n\t\t\ttex,\n\t\t\tivec2(floor( max( 0.0, coord.x ) ), coord.y),\n\t\t\t0\n\t\t);\n\n\t}\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int getVoxel(ivec3 vp)\n{\n    vec3 p = vec3(vp);\n    float h = texture(iChannel0, p.xz * 0.00390625).x * 36.0;\n    if(p.y < h) return 1;\n    return 0;\n}\n\nfloat fract1(float x) { return (1.0 - x) + floor(x); }\n\nbool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d)\n{\n    float maxdist = length(rd);\n    \n    rd = rd / maxdist;\n\n    float fposx = ro.x,\n          fposy = ro.y,\n          fposz = ro.z;\n\n    pos = ivec3(floor(fposx), floor(fposy), floor(fposz));\n    ivec3 ppos = pos;\n\n    float sx = sign(rd.x),\n          sy = sign(rd.y),\n          sz = sign(rd.z);\n\n    float tdx = sx / rd.x,\n          tdy = sy / rd.y,\n          tdz = sz / rd.z;\n\n    float tmx, tmy, tmz;\n\n    if(sx > 0.0) tmx = tdx * fract1(ro.x); else tmx = tdx * fract(ro.x);\n    if(sy > 0.0) tmy = tdy * fract1(ro.y); else tmy = tdy * fract(ro.y);\n    if(sz > 0.0) tmz = tdz * fract1(ro.z); else tmz = tdz * fract(ro.z);\n\n    for (int i = 0; i < 1000; i++)\n    {\n        if(d > maxdist) break;\n\n        pos = ivec3(floor(fposx), floor(fposy), floor(fposz));\n\n        index = getVoxel(pos);\n\n        if(index != 0)\n        {\n            nor = ppos - pos;\n            return true;\n        };\n\n        ppos = pos;\n    \n        if(tmx < tmy)\n        {\n            if(tmx < tmz)\n            {\n                d = tmx;\n                fposx += sx;\n                tmx += tdx;\n            }\n            else\n            {\n                d = tmz;\n                fposz += sz;\n                tmz += tdz;\n            }\n        }\n        else\n        {\n            if(tmy < tmz)\n            {\n                d = tmy;\n                fposy += sy;\n                tmy += tdy;\n            }\n            else\n            {\n                d = tmz;\n                fposz += sz;\n                tmz += tdz;\n            }\n        }\n    }\n    pos = ivec3(floor(ro));\n    nor = ivec3(0, 0, 0);\n    index = 0;\n    d = maxdist;\n    return false;\n}\n\nvec4 image(vec2 uv)\n{\n    float t = iTime * 0.5;\n\n    vec3 ro = vec3(0.0, 32.0, iTime * 2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.yz *= rot(PI * 0.17);\n    rd.xz *= rot(t * PI * 0.0625);\n\n    ivec3 vp, vn; int index; float d; bool hit;\n    \n    vec3 surfaceCol = vec3(0.0, 0.0, 0.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 resultCol = vec3(0.0, 0.0, 0.0);\n\n    float reflectionFactor = 1.0;\n\n    for(int reflectionIndex = 0; reflectionIndex < REFLECTION_STEPS; reflectionIndex++)\n    {\n        if(reflectionFactor < 0.001) break;\n    \n        hit = raycastVoxel(ro, rd * RENDER_DIST, vp, vn, index, d);\n        \n        if(hit)\n        {\n            vec3 p = ro + (rd * d);\n            vec3 n = vec3(vn);\n\n            vec3 vfp = p - vec3(vp);\n\n            if(index == 1)\n            {\n                vec3 dm = texture(iChannel1, vec2(vp.xy * vp.yz * vp.zx) * 0.0001).xyz;\n                surfaceCol = vec3(0.5, 0.5, 0.5) * dm.xyz;\n                reflectionFactor *= 0.7;\n            }\n\n            surfaceCol *= light(p, n);\n            \n            ro = p + (n * 0.01);\n            rd = reflect(rd, n);\n            \n            resultCol += surfaceCol * reflectionFactor;\n        }\n        else\n        {\n            resultCol += sky(rd) * reflectionFactor;\n\n            reflectionFactor = 0.0;\n        }\n    }\n\n    return vec4(resultCol, 1.0);\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    vec2 coord = fragCoord;\n    \n    if (coord.x <= floor(resolution.x / 2.0))\n    {\n        vec2 rez = vec2(iResolution.x / 2.0, iResolution.y);\n        vec2 u = (coord - (0.5 * rez)) / min(rez.x, rez.y);\n    \tvec2 uv = compactCheckerUV( u, coord, resolution );\n\n        fragColor = image(uv);\n        \n    }\n    else\n    {\n        discard;\n        \n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}