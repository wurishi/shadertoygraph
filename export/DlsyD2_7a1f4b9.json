{"ver":"0.1","info":{"id":"DlsyD2","date":"1691320224","viewed":135,"name":"bn bn bn","username":"Carandiru","description":"smootherstep() bluenoise variant (top), regular bluenoise (bottom)\n+added histogram to show the distribution of values","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// smootherstep() bluenoise variant (top), regular bluenoise (bottom)\n// - see buffer A\n\n\n\n// viridis palette function port //             \n#define fma(a,b,c) (a*b+c)\n\nvec3 viridis(float t) \n{\n\tconst vec3 _c0 = vec3( 0.2777273272234177, 0.005407344544966578, 0.3340998053353061 );\n\tconst vec3 _c1 = vec3( 0.1050930431085774, 1.404613529898575, 1.384590162594685 );\n\tconst vec3 _c2 = vec3( -0.3308618287255563, 0.214847559468213, 0.09509516302823659 );\n\tconst vec3 _c3 = vec3( -4.634230498983486, -5.799100973351585, -19.33244095627987 );\n\tconst vec3 _c4 = vec3( 6.228269936347081, 14.17993336680509, 56.69055260068105 );\n\tconst vec3 _c5 = vec3( 4.776384997670288, -13.74514537774601, -65.35303263337234 );  \n    const vec3 _c6 = vec3( -5.435455855934631, 4.645852612178535, 26.3124352495832 );  \n\n\tvec3 xmT = vec3(t);\n    \n    vec3 x;\n\n    // c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))))\n    x = fma(xmT, _c6, _c5);\n    x = fma(x, xmT, _c4);\n    x = fma(x, xmT, _c3);\n    x = fma(x, xmT, _c2);\n    x = fma(x, xmT, _c1);\n    x = fma(x, xmT, _c0);\n\n    return(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    float a, b, c, d;\n    \n    a = textureLod(iChannel0, uv, 0.0f).r;\n    b = length(textureLod(iChannel1, uv * vec2(2), 0.0f))/SIZE;\n    \n    c = textureLod(iChannel2, uv, 0.0f).r;\n    d = length(textureLod(iChannel3, uv * vec2(2), 0.0f))/SIZE;\n    \n    float buckets = iResolution.x * 0.5;\n    float bucket_size = buckets / 10.0f;\n    float bucket = uv.x * buckets;\n    float bucket_filled;\n    \n    float height = 0.05f + 0.5f * fract(iTime*0.1f);\n    \n    bucket_filled = abs(float(int(a*buckets) - int(bucket))) / bucket_size;\n    vec3 aa = mix(vec3(a), viridis(1.0f / (1.0f + bucket_filled*bucket_filled)), bvec3(uv.y < (height + 0.5f) && uv.y > (height + 0.5f) - 0.05f));\n    \n    \n    bucket_filled = abs(float(int(c*buckets) - int(bucket))) / bucket_size;\n    vec3 cc = mix(vec3(c), viridis(1.0f / (1.0f + bucket_filled*bucket_filled)), bvec3(uv.y < (height) && uv.y > (height) - 0.05f));\n    \n    uv = 2.0f * uv - 1.0f;\n    \n    bvec2 corner = lessThan(uv, vec2(0.0f));\n    vec3 r0 = mix(vec3(b), aa, corner.xxx);\n    vec3 r1 = mix(vec3(d), cc, corner.xxx);\n    \n    vec3 c0 = mix(r0, r1, corner.yyy);\n    \n    vec3 color = vec3(0);\n    \n    color = c0;\n    \n    color = mix(color, vec3(0.25,0,0.9) * (sin(uv.x * 3.14 * 64.0f) * 0.5f + 0.5f) * exp2(-100.0f * fract(iTime*1.618f) * c0), vec3( any(lessThan(abs(uv), vec2(0.002) * vec2(iResolution.y/iResolution.x, 1.0f))) ));\n    \n   //color = pow(color, vec3(1.0f/2.2f));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ken Perlin suggests an improved version of the smoothstep() function, \n// which has zero 1st- and 2nd-order derivatives at x = 0 and x = 1.\nfloat smootherstep(in float edge0, in float edge1, in float x) \n{\n  x = (x - edge0)/(edge1 - edge0);\n  return( x * x * x * (x * (x * 6.0f - 15.0f) + 10.0f) ); // quintic equation\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 0.5f;\n    \n    float bn = textureLod(iChannel0, (uv * iResolution.xy)/1024.0f, 0.0f).r;\n    \n    float bns = smootherstep(0.0f, 1.0f, bn);\n    \n    float m0 = min(bn, bns);\n    float m1 = max(bn, bns);\n    \n    // output bluenoise variant\n    float variant = abs(bn - (m1 - m0));     // alternatively:  = abs(bn - abs(bns - bn))\n    \n    fragColor = vec4(variant);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragCoord = uv * SIZE;\n    \n    for(float i = 0.0; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 0.5f;\n    \n    float bn = textureLod(iChannel0, (uv * iResolution.xy)/1024.0f, 0.0f).r;\n    \n    fragColor = vec4(bn);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragCoord = uv * SIZE;\n    \n    for(float i = 0.0; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SIZE (floor(iResolution.x*0.5)*2.0)","name":"Common","description":"","type":"common"}]}