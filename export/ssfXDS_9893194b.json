{"ver":"0.1","info":{"id":"ssfXDS","date":"1619129073","viewed":94,"name":"313_aitassova_v0v1","username":"NurizAite","description":"Ray Tracing","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\n    \nvec3 W = vec3(1120.0);\n\nvec3 uncharted2ToneMapping(vec3 x){\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = texture(iChannel0,fragCoord.xy / iResolution.xy).rgb;\n    vec3 curr = uncharted2ToneMapping(color.xyz*2.0);\n\tvec3 whiteScale = 1.0/uncharted2ToneMapping(W); \n\tvec3 mapped = curr*whiteScale;\n\tmapped = pow(mapped, vec3(1.0 / 2.2));\n\tfragColor =  vec4(mapped,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EMISSIVE 0\n#define DIELECTRIC 1\n#define METALIC 2\n#define GLASS 3\n\n\nfloat aperture = 0.02;\nint pathsPerFrame = 5; \nint maxDepth = 20; \nfloat t_max = 4294967296.0;\nfloat t_min = 0.0039;\n\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float refractiveIndex;\n    int type;\n};\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec3 attenuation;\n    vec3 radiance;\n    float rand;\n    float t;\n    bool done;\n};\n    \n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material mat;\n};\n\n\nstruct Cylinder\n{\n    vec3 bottom, top;\n    float radius;\n    Material mat;\n    //\n};\n\n\nstruct Plane\n{\n    vec3 point;\n    vec3 normal;\n    Material mat;\n};\n\n\nstruct Volume\n{\n    vec3 center;\n    float radius;\n    vec3 absorption;\n};\n\n    \nstruct Hit\n{\n  vec3 normal;\n  float t;\n  bool hit;\n  Material mat;\n};\n\n\nSphere pinkLight  = Sphere(vec3(-1.5, 1.6,  -1.0), 0.45, Material(vec3(0.4, 0.1, 0.9)*15.0, 0.7, 2.8735, EMISSIVE));\nSphere yellowLight = Sphere(vec3( 1.5, 1.35, -0.9), 0.25, Material(vec3(0.5, 0.9, 0.3)*15.0, 0.7, 2.8735, EMISSIVE));\n\nSphere sphere     = Sphere(vec3(-0.75, 0.25, 0.75), 0.25, Material(vec3(1.0), 0.0, 1.52, GLASS));\nSphere witchBall  = Sphere(vec3(0.0, 0.6, 0.0), 0.5, Material(vec3(1.0), 0.0, 1.1, GLASS));\n\nCylinder stand    = Cylinder(vec3(0.0, -0.0, 0.0), vec3(0.0, 0.1, 0.0), 0.35, Material(vec3(1.0, 0.766, 0.336), 0.05, 2.8735, METALIC));\nPlane plane       = Plane(vec3(0.0), vec3(0.0, 1.0, 0.0), Material(vec3(0.9), 0.1, 2.8735, DIELECTRIC));\n\nVolume fog        = Volume(vec3(0.0, 0.6, 0.0), 0.5, 10.0 * vec3(2.5, 5.5, 3.0));\n\nuint hash(uint x)\n{\n    x += (x << 10u);\n    x ^= (x >>  6u);\n    x += (x <<  3u);\n    x ^= (x >> 11u);\n    x += (x << 15u);\n    return x;\n}\n\n\nuint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }\nuint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }\nuint hash(uvec4 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w)); }\n\n\n\nfloat floatConstruct(uint m)\n{\n    const uint ieeeMantissa = 0x007FFFFFu;\n    const uint ieeeOne      = 0x3F800000u; \n\n    m &= ieeeMantissa;                     \n    m |= ieeeOne;                          \n\n    float  f = uintBitsToFloat( m );       \n    return f - 1.0;                        \n}\n\n\nfloat random(float x) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random(vec2  v) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random(vec3  v) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random(vec4  v) { return floatConstruct(hash(floatBitsToUint(v))); }    \n\n\nvec3 randv(float n)\n{\n\tvec3 v = 2.0 * vec3(random(n + 1.0), random(n + 2.0), random(n + 3.0)) - 1.0;\n    \n    do\n    {\n        v = 2.0 * vec3(random(v.x), random(v.y), random(v.z)) - 1.0;\n    }\n    while(length(v) >= 1.0);\n    \n    return v;\n}\n\n\nvec3 backgroundColor(vec3 dir)\n{\n    vec3 unit_dir = normalize(dir);\n    float t = 0.5*(unit_dir.y+1.0);\n\n    return pow(texture(iChannel1,dir).rgb,vec3(2.2))*10.1;\n}\n\n\nHit traceSphere(Ray ray, Sphere sphere)\n{\n   \tfloat a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, ray.origin - sphere.center) * 2.0;\n    float c = dot(ray.origin - sphere.center, ray.origin - sphere.center) - sphere.radius * sphere.radius;\n    float d = b*b - 4.0*a*c;\n    \n    Hit hit;\n    \n    if(d >= 0.0)\n    {\n        hit.t = (-b - sqrt(d)) / (2.0*a);\n      \tif(hit.t < t_max && hit.t > t_min)\n        {\n        \thit.normal = normalize((ray.origin + ray.direction * hit.t) - sphere.center);\n        \thit.mat = sphere.mat;\n        \thit.hit = true;\n        \treturn hit;\n        }\n        \n        hit.t = (-b + sqrt(d)) / (2.0*a);\n        if(hit.t < t_max && hit.t > t_min)\n        {\n        \thit.normal = normalize((ray.origin + ray.direction * hit.t) - sphere.center);\n        \thit.mat = sphere.mat;\n        \thit.hit = true;\n        \treturn hit;\n        }\n    }\n    \n\thit.hit = false;\n\treturn hit;\n}\n\n\nHit traceCylinder(Ray ray, Cylinder cylinder)\n{\n\n    vec3 cc = 0.5 * (cylinder.bottom + cylinder.top);\n    float ch = length(cylinder.top - cylinder.bottom);\n    vec3 ca = (cylinder.top - cylinder.bottom) / ch;\n    ch *= 0.5;\n\n    vec3  oc = ray.origin - cc;\n\n    float card = dot(ca, ray.direction);\n    float caoc = dot(ca, oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot(oc, ray.direction) - caoc*card;\n    float c = dot(oc, oc) - caoc*caoc - cylinder.radius*cylinder.radius;\n    float d = b*b - a*c;\n    \n    Hit hit;\n    \n    if(d >= 0.0)\n    {\n        float sqrtd = sqrt(d);\n        hit.t = (-b - sqrtd) / a;\n        float y = caoc + hit.t*card;\n        if(hit.t < t_max && hit.t > t_min)\n        {\n            if(abs(y) < ch)\n            {\n                hit.normal = normalize(oc + hit.t*ray.direction - ca*y);\n                hit.mat = cylinder.mat;\n                hit.hit = true;\n                return hit;\n            }\n        }\n        \n        float sy = sign(y);\n        hit.t = (sy*ch - caoc) / card;\n        if(hit.t < t_max && hit.t > t_min)\n        {\n            if(abs(b + a * hit.t) < sqrtd)\n            {\n                hit.normal = ca * sy;\n                hit.mat = cylinder.mat;\n                hit.hit = true;\n                return hit;\n            }\n        }\n    }\n\n    hit.hit = false;\n    return hit;\n}\n\n\nHit tracePlane(Ray ray, Plane plane)\n{\n    Hit hit;\n    \n    float dn = dot(ray.direction, plane.normal);\n    if(dn != 0.0)\n    {\n        hit.t = dot(plane.point - ray.origin, plane.normal) /  dn;\n        if(hit.t < t_max && hit.t > t_min)\n        {\n            hit.normal = plane.normal;\n            hit.mat = plane.mat;\n            hit.hit = true;\n            return hit;\n        }\n    }\n    \n    hit.hit = false;\n    return hit;\n}\n\n\nfloat sdf(vec3 p, Volume volume)\n{\n  return length(p - volume.center) - volume.radius;\n}\n\n\nvec3 BeerLambert(vec3 absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\n\nRay marchVolume(Ray ray, Volume volume)\n{   \n    float t = sdf(ray.origin, volume);\n    \n    if(t > ray.t) return ray;\n    \n    const float MARCH_SIZE = 0.01;\n    for (int i = 0; i < 50; ++i)\n    {\n        vec3 pos = ray.origin + (float(i) * MARCH_SIZE + t) * ray.direction;\n        float sdf0 = sdf(pos, volume);\n        if (sdf0 < 0.0)\n        {\n            ray.attenuation *= BeerLambert(volume.absorption * (\n            texture(iChannel2, pos * 0.2).x\n            + texture(iChannel2, pos * 0.4).x\n            + texture(iChannel2, pos * 0.8).x\n            + texture(iChannel2, pos * 1.6).x\n            ) * 0.25 * abs(sdf0), MARCH_SIZE);\n        }\n    }\n    \n    return ray;\n}\n\n\n\nHit compareHit(Hit hit, Hit newHit)\n{\n    if(newHit.hit)\n    {\n    \tif(newHit.t < hit.t )\n        {\n            return newHit;\n        }\n    }   \n   \t\n    return hit;\n}\n\n\nHit traceScene(Ray ray)\n{\n    Hit hit;\n    hit.t = t_max;\n   \n    hit = compareHit(hit, traceSphere(ray, pinkLight));\n    hit = compareHit(hit, traceSphere(ray, yellowLight));\n    \n    hit = compareHit(hit, traceSphere(ray, witchBall));\n  \thit = compareHit(hit, traceSphere(ray, sphere));\n    \n    hit = compareHit(hit, tracePlane(ray, plane));\n    hit = compareHit(hit, traceCylinder(ray, stand));\n\n    return hit;   \n}\n\n\nRay traceVolumes(Ray ray)\n{\n    return marchVolume(ray, fog);\n}\n\n\nfloat schlick(float cosine, float refractiveIndex)\n{\n    float r0 = (1.0 - refractiveIndex) / (1.0 + refractiveIndex);\n    r0 = r0 * r0;\n    \n    return r0 + (1.0 - r0) * pow(max(0.0, 1.0 - cosine), 5.0);\n}\n\n\nstruct Refracted\n{\n    bool did;\n    vec3 direction;\n};\n\nRefracted refract0(vec3 v,vec3 n, float ni_nt)\n{\n    Refracted ref;\n    \n    v = normalize(v);\n    float dt = dot(v, n);\n    float disc = 1.0 - ni_nt*ni_nt * (1.0 - dt*dt);\n    \n    if(disc > 0.0){\n        ref.direction = ni_nt * (v - n*dt) - n*sqrt(disc);\n        ref.did = true;\n    }\n    else\n    {\n        ref.did = false;\n    }\n    \n    return ref;\n    \t\n}\n\nRay castRay(Ray ray)\n{\n    Hit hit = traceScene(ray);\n    ray.t = hit.t;\n    float roughness = hit.mat.roughness * hit.mat.roughness;\n    ray = traceVolumes(ray);\n    \n    if(hit.hit)\n    {\n        float ref_idx = hit.mat.refractiveIndex;\n        \n        ray.radiance = vec3(0.0);\n        ray.rand = random(ray.rand);\n        \n        ray.origin = ray.t*ray.direction + ray.origin;\n        ray.attenuation = ray.attenuation * hit.mat.albedo;\n        \n        if(hit.mat.type == DIELECTRIC)\n        {\n            float cosine = -dot(ray.direction, mix(hit.normal, -ray.direction, roughness)) / length(ray.direction);\n            float schlick = schlick(cosine, ref_idx);\n            \n            if(ray.rand > schlick)\n            {\n\t\t\t\tray.direction = normalize(hit.normal + randv(ray.rand));\n            }\n            else\n            {\n\t\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n            }\n        }\n        \n        else if(hit.mat.type == METALIC)\n        {\n\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n        }\n        \n        else if(hit.mat.type == GLASS)\n        {        \n            float cosine;\n            float ni_nt;\n            vec3 normal;\n            \n            if(dot(ray.direction, hit.normal) > 0.0)\n            {\n\t\t\t\tnormal = -hit.normal;\n               \tni_nt = ref_idx;\n                cosine = ref_idx * dot(ray.direction, hit.normal) / length(ray.direction);\n            }\n            else\n            {\n                normal = hit.normal;\n                ni_nt = 1.0 / ref_idx;\n                cosine = -dot(ray.direction, hit.normal) / length(ray.direction);\n            }\n            \n            float schlick0;\n            Refracted ref = refract0(ray.direction, normal, ni_nt);\n            \n            if(ref.did)\n            {\n                schlick0 = schlick(cosine, ref_idx);\n            }\n            else\n            {  \n                schlick0 = 1.0;\n            }\n           \t\n            if(ray.rand > schlick0)\n            {\n                ray.direction = normalize(ref.direction + randv(ray.rand)*roughness);\n            }\n            else\n            {\n\t\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n            }\n        }\n        else if(hit.mat.type == EMISSIVE)\n        {\n\t\t\tfloat cosine = -dot(ray.direction, mix(hit.normal, -ray.direction, roughness)) / length(ray.direction);\n            float schlick = schlick(cosine, ref_idx);\n            \n            if(ray.rand > schlick)\n            {\n                ray.direction = normalize(hit.normal + randv(ray.rand)*roughness);\n                ray.radiance = hit.mat.albedo;\n            }\n            else\n            {\n\t\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n            }\n            ray.done = true;\n        }\n    }\n    else\n    {\n        ray.radiance = backgroundColor(ray.direction);\n        ray.done = true;\n    }\n    \n    return ray;   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (vec2(-1.0) + 2.0*(fragCoord.xy / iResolution.xy)) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    vec2 mouse;\n    if(iMouse.z != 0.0)\n        mouse = (iMouse.xy / iResolution.xy*2.0 - vec2(1.0)) * vec2(iResolution.x / iResolution.y, 1.0) * 2.0;\n    else\n        mouse = vec2(-1.0, -0.2);\n    \n    mat3 rotY = mat3(vec3(cos(mouse.x),0,sin(mouse.x)),\n                    vec3(0,1,0),\n                    vec3(-sin(mouse.x),0,cos(mouse.x)));\n                    \n    mat3 rotX = mat3(vec3(1,0,0),\n                    vec3(0,  cos(mouse.y), sin(mouse.y)),\n                    vec3(0, -sin(mouse.y), cos(mouse.y)));\n                    \n    mat3 rot = rotY * rotX;\n    \n    \n    vec4 previousColor = texture(iChannel0, (fragCoord.xy / iResolution.xy));\n    vec3 color = vec3(0.0); \n    \n    float focal = (iMouse.y / iResolution.y)*0.0 + 2.5;\n    \n    Ray ray;\n    \n    for(int path = 0; path < pathsPerFrame; path++)\n    {\n        vec2 offset0 = randv(random(vec4(uv, iFrame, path))).xy * aperture;\n        vec2 offset1 = (2.0*vec2(random(vec4(uv, path, iFrame)),\n                        random(vec4(uv, path + pathsPerFrame, iFrame))) - 1.0) / iResolution.xy * \n                        vec2(iResolution.x / iResolution.y, 1.0);\n\n        ray.direction = rot*normalize(vec3(uv*focal/2.5-offset0+offset1,-focal));\n        ray.origin = rot*vec3(offset0+offset1, 3.0) + vec3(0.0, witchBall.radius + stand.top.y, 0.0);\n        ray.attenuation = vec3(1.0);\n    \tray.rand = random(vec4(uv,path,iTime));\n   \t\tray.done = false;\n\n    \tfor(int depth = 0; depth < maxDepth && !ray.done ;depth++)\n    \t{\n    \t   ray = castRay(ray);\n    \t}\n    \t\n\t\tcolor += ray.radiance*ray.attenuation;\n    }\n    \n    color /= float(pathsPerFrame);\n    \n             \n   \tfloat temp = previousColor.w+1.0;\n    \n    if(iMouse.z > 0.0) temp = 1.0;\n    \n    float mixf = 1.0/temp;\n\t\n\tfragColor = vec4(mix(color, previousColor.rgb, 1.0-mixf),temp);\n}","name":"Buffer A","description":"","type":"buffer"}]}