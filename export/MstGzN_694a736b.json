{"ver":"0.1","info":{"id":"MstGzN","date":"1448467310","viewed":756,"name":"10_Cage","username":"yiwenl","description":"cage","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//float time = iTime * 3.0;\nconst float PI      = 3.141592657;\n// const float maxDist = 5.0;\n\n\n\n//\tTOOLS\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\nfloat rep(float p, float c) {\treturn mod(p, c) - 0.5*c;\t}\nvec2 rep(vec2 p, float c) {\t\treturn mod(p, c) - 0.5*c;\t}\n\nvec2 repAng(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}\n\nvec3 repAngS(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return vec3(p.x, p.y, mod(sector, n));\n}\n\n\n//\tGEOMETRY\nfloat sphere(vec3 pos, float radius) {\n\treturn length(pos) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat displacement(vec3 p) {\n\t return sin(20.0*p.x+iTime)*sin(20.0*p.y+iTime*.25)*sin(20.0*p.z+iTime*.33);\n}\n\nvec2 map(vec3 pos) {\n\tfloat colorIndex = 0.0;\n\tvec3 posBelt     = pos;\n\tposBelt.yz \t\t = rotate(posBelt.yz, iTime*.1);\n\tposBelt.yz       = repAng(posBelt.yz, 12.0);\n\tposBelt.xz       = repAng(posBelt.xz, 36.0*10.0);\n\tposBelt.z        -= 1.0;\n\tfloat d          = sdBox(posBelt, vec3(1.0, .05, .01));\n\n\tfloat r          = .90+pow(sin(iTime), 5.0)*.05;\n\tfloat dSphere    = sphere(pos, r);\n\tdSphere += displacement(pos*.15) * .05;\n\tif(dSphere < d) {\n\t\td = dSphere;\n\t\tcolorIndex = 1.0;\n\t\t\n\t}\n\t\n\treturn vec2(d, colorIndex);\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x\n\t);\n\treturn normalize(normal);\n}\n\n\n//\tLIGHTING\nconst vec3 lightPos0 = vec3(-0.6, 0.7, -0.5);\nconst vec3 lightColor0 = vec3(1.0, 1.0, .96);\nconst float lightWeight0 = 0.15;\n\nconst vec3 lightPos1 = vec3(-1.0, -0.75, -.6);\nconst vec3 lightColor1 = vec3(.96, .96, 1.0);\nconst float lightWeight1 = 0.15;\n\nfloat ao( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 envLight(vec3 normal, vec3 dir, samplerCube tex) {\n\tvec3 eye    = -dir;\n\tvec3 r      = reflect( eye, normal );\n\tvec3 color  = texture( tex, r ).rgb;\n\tfloat power = 10.0;\n\tcolor.r     = pow(color.r, power);\n\tcolor       = color.rrr;\n    return color;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat diffuse(vec3 normal, vec3 light) {\n\treturn max(dot(normal, light), 0.0);\n}\n\nvec4 getColor(vec3 pos, vec3 dir, vec3 normal, float colorIndex) {\n\tvec3 baseColor = vec3(0.0);\n\tvec3 env = vec3(.0);\n\tif(colorIndex == 0.0) {\n\t\tbaseColor = vec3(1.0, 1.0, .96) * .05;\n\t\tenv      = envLight(normal, dir, iChannel0)*.1;\n\t} else {\n\t\tbaseColor = vec3(.25, 0.0, .0);\n\t\tenv      = envLight(normal, dir, iChannel0);\n\t}\n\n\tvec3  lig     = normalize( lightPos0 );\n\tfloat shadow  = softshadow(pos, lig, 0.02, 2.5 );\n\tfloat _ao     = ao(pos, normal);\n\tvec3 _diffuse = diffuse(normal, normalize(lightPos0)) * lightColor0 * lightWeight0;\n\t_diffuse      += diffuse(normal, normalize(lightPos1)) * lightColor1 * lightWeight1;\n\treturn vec4(vec3(baseColor+env+_diffuse)*_ao*shadow, 1.0);\t\n\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nconst int NUM_ITER = 100;\nconst float maxDist  = 5.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float r = 3.0;\n    float t = 4.0;\n    float y = sin(iTime*.25) * .5 + .65;\n    vec3 pos = vec3( cos(t)*r, y, 0.5 + sin(t)*r );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n    mat3 ca = setCamera( pos, ta, 0.0 );\n\tvec3 dir = ca * normalize( vec3(uv,1.5) );\n    \n    float grey = length(uv*0.75);\n\tgrey = (1.0 - grey * .25) * .25;\n    \n    vec4 color = vec4(0.0);\n\tfloat prec = pow(.1, 7.0);\n\tfloat d;\n\tfloat colorIndex = 0.0;\n\tbool hit = false;\n\t\n\tfor(int i=0; i<NUM_ITER; i++) {\n\t\tvec2 result = map(pos);\t\t\t\t\t\t//\tdistance to object\n\t\td = result.x;\n\t\tcolorIndex = result.y;\n\n\t\tif(d < prec) {\t\t\t\t\t\t// \tif get's really close, set as hit the object\n\t\t\thit = true;\n\t\t}\n\n\t\tpos += d * dir;\t\t\t\t\t\t//\tmove forward by\n\t\tif(length(pos) > maxDist) break;\n\t}\n\n\n\tif(hit) {\n\t\tcolor = vec4(1.0);\n\t\tvec3 normal = computeNormal(pos);\n\t\tcolor = getColor(pos, dir, normal, colorIndex);\n\t}\n    \n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}