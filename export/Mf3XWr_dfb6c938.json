{"ver":"0.1","info":{"id":"Mf3XWr","date":"1713787288","viewed":59,"name":"Line/Segment Utility Functions","username":"Mr_Sorel","description":"Some basic geometric functions to work with a line or a segment.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["line"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat segmentEndsDistance(vec2 uv, vec2 p0, vec2 p1) {\n    return min(distance(uv, p0), distance(uv, p1));\n}\n\n// Returns (slope, yIntercept) for non-vertical lines,\n//  and (Inf, x) for vertical lines.\nvec2 lineParams(vec2 p0, vec2 p1) {\n    // Vertical line?\n    // Assume same point = vertical, too\n    if (p0.x == p1.x) {\n        return vec2(1. / 0., p0.x);\n    }\n    \n    // ax + b\n    // a * p0.x + b = p0.y\n    // a * p1.x + b = p1.y\n    \n    // a * (p1.x - p0.x) = (p1.y - p0.y)\n    // a = (p1.y - p0.y) / (p1.x - p0.x)\n    // b = p0.y - (a * p0.x)\n    vec2 segment = p1 - p0;\n    float a = segment.y / segment.x;\n    float b = p0.y - a * p0.x;\n    \n    return vec2(a, b);\n}\n\nvec2 closestPoint(vec2 line, vec2 p0) {\n    // If line is vertical, this is easier:\n    if (line.x == 1. / 0.) {\n        return vec2(line.y, p0.y);\n    }\n    \n    // If line is horizontal, we can't invert the slope:\n    if (line.x == 0.) {\n        return vec2(p0.x, line.y);\n    }\n\n    // Orthogonal slope:\n    // a' = -1/a\n    // Crossing uv:\n    // a' * uv.x + b' = uv.y\n    // b' = uv.y - a' * uv.x\n    float orthSlope = -1. / line.x;\n    float orthB = p0.y - orthSlope * p0.x;\n    \n    // a * x + b = a' * x + b'\n    // (a - a') * x = b' - b\n    // x = (b' - b) / (a - a')\n    float intersectionX = (orthB - line.y) / (line.x - orthSlope);\n    return vec2(intersectionX, line.x * intersectionX + line.y);\n}\n\nvec2 closestPointToSegment(vec2 seg0, vec2 seg1, vec2 uv) {\n    vec2 lineParams = lineParams(seg0, seg1);\n    if (lineParams.x == 1. / 0.) {\n        float minY = min(seg0.y, seg1.y);\n        float maxY = max(seg0.y, seg1.y);\n        float closestY = max(minY, min(uv.y, maxY));\n        return vec2(lineParams.y, closestY);\n    }\n    \n    vec2 closestInLine = closestPoint(lineParams, uv);\n    float minX = min(seg0.x, seg1.x);\n    float maxX = max(seg0.x, seg1.x);\n    \n    \n    float closestX = max(minX, min(closestInLine.x, maxX));\n    return vec2(closestX, lineParams.x * closestX + lineParams.y);\n}\n\nfloat aboveSegment(vec2 uv, vec2 p0, vec2 p1) {\n    vec2 line = lineParams(p0, p1);\n    float segmentY = uv.x * line.x + line.y;\n\n    float color = step(segmentY, uv.y);\n    color = color * step(p0.x, uv.x);\n    color = color * step(-p1.x, -uv.x);\n    \n    return color;\n}\n\nfloat lineDistance(vec2 uv, vec2 p0, vec2 p1) {\n    vec2 closest = closestPoint(lineParams(p0, p1), uv);\n    return distance(uv, closest);\n}\n\nfloat segmentDistance(vec2 uv, vec2 p0, vec2 p1) {\n    vec2 closest = closestPointToSegment(p0, p1, uv);\n    return distance(uv, closest);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = iTime;\n    // float time = .8;\n    float oscillatingValue = sin(time) / 2. + .5;\n    oscillatingValue = fract(time / 3.);\n    \n    float p0x = min((oscillatingValue - .25) * 4., -oscillatingValue * 4. + 4.);\n    p0x = clamp(p0x, 0.1, .9);\n    float p0y = min(oscillatingValue * 4., -oscillatingValue * 4. + 3.);\n    p0y = clamp(p0y, 0.1, .9);\n    \n    vec2 p0 = vec2(p0x, p0y);    \n    vec2 p1 = vec2(.5, .5);\n    \n    vec2 line = lineParams(p0, p1);\n    float segmentY = uv.x * line.x + line.y;\n    \n    // float color = segmentEndsDistance(uv, p0, p1);\n    // float color = aboveSegment(uv, p0, p1);\n    // float color = smoothstep(0., 0.008, segmentDistance(uv, p0, p1));\n    float lineSize = .01;\n    // Faded outline\n    float outlineThickness = 0.002;\n    \n    float dist = min(1., segmentDistance(uv, p0, p1));\n    float outlineFactor = smoothstep(0., outlineThickness, distance(dist, lineSize));\n    \n    float color = step(-lineSize, -dist) + 1. - outlineFactor;\n    vec3 col = vec3(color);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}