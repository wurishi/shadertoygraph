{"ver":"0.1","info":{"id":"MlcczX","date":"1533469816","viewed":699,"name":"glsl smallpt","username":"matt77hias","description":"GLSL modification of Kevin Baeson's 99 line C++ path tracer\n\nSee also: https://github.com/matt77hias/smallpt","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer","smallpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-------------------------------------------------------------------------\n// Display\n//-------------------------------------------------------------------------\n\nconst float g_quantization = 1.0f / 255.0f;\nconst float g_inv_gamma    = 1.0f / 2.2f;\n\n//-------------------------------------------------------------------------\n// Main\n//-------------------------------------------------------------------------\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    // Hashing for seeding, Xorshift/LCG for sequencing\n    uint  index  = uint(fragCoord.y * iResolution.x + fragCoord.x);\n    uint  key    = index ^ floatBitsToUint(iTime);\n    uint  state  = Hash_Wang(key);\n    \n    vec2  uv     = fragCoord.xy / iResolution.xy;\n\tvec3  hdr    = texture(iChannel0, uv).xyz;\n    // Apply basic tone mapping.\n    vec3  ldr    = Saturate(hdr);\n    // Apply basic gamma correction\n    vec3  gcolor = pow(ldr, vec3(g_inv_gamma));\n    // Apply temporal dithering.\n    float noise  = UniformFloat(state);\n    float qnoise = noise * g_quantization;\n    \n    color = vec4(gcolor + vec3(qnoise), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-------------------------------------------------------------------------\n// Math\n//-------------------------------------------------------------------------\n\nconst float g_pi  = 3.14159265358979323846f;\nconst float g_float_inf = 1e20f;\n\nfloat Max(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nvec3 Saturate(vec3 v) {\n    return clamp(v, 0.0f, 1.0f);\n}\n\n//-------------------------------------------------------------------------\n// Hash\n//-------------------------------------------------------------------------\n\nuint Hash_Wang(uint key) {\n\tkey = (key ^ 61u) ^ (key >> 16u);\n\tkey = key + (key << 3u);\n\tkey = key ^ (key >> 4u);\n\tkey = key * 0x27D4EB2Du;\n\tkey = key ^ (key >> 15u);\n\treturn key;\n}\n\n//-------------------------------------------------------------------------\n// RNG\n//-------------------------------------------------------------------------\n\nfloat UniformUintToFloat(uint u) {\n\t// IEEE-754: 2^-32 = 0x2F800000\n\treturn float(u) * uintBitsToFloat(0x2F800000u);\n}\n\nuint UniformUint(inout uint state) {\n    // Xorshift: slower than LCG better distribution for long sequences\n\tstate ^= (state << 13u);\n\tstate ^= (state >> 17u);\n\tstate ^= (state << 5u);\n    \n    // LCG: faster than Xorshift, but poorer distribution for long sequences\n    //const uint multiplier = 1664525u;\n\t//const uint increment  = 1013904223u;\n\t//state *= multiplier;\n    //state += increment;\n    \n    return state;\n}\n\nfloat UniformFloat(inout uint state) {\n    return UniformUintToFloat(UniformUint(state));\n}\n\n//-------------------------------------------------------------------------\n// Sampling\n//-------------------------------------------------------------------------\n\nvec3 CosineWeightedSampleOnHemisphere(float u1, float u2) {\t\n\tfloat cos_theta = sqrt(1.0f - u1);\n\tfloat sin_theta = sqrt(u1);\n\tfloat phi = 2.0f * g_pi * u2;\n\t\n\treturn vec3(cos(phi) * sin_theta, \n                sin(phi) * sin_theta, \n                cos_theta);\n}\n\n//-------------------------------------------------------------------------\n// Optics\n//-------------------------------------------------------------------------\n\nfloat Reflectance0(float n1, float n2) {\n\tfloat sqrt_R0 = (n1 - n2) / (n1 + n2);\n\treturn sqrt_R0 * sqrt_R0;\n}\n\nfloat SchlickReflectance(float n1, float n2, float c) {\n\tfloat R0 = Reflectance0(n1, n2);\n\treturn R0 + (1.0f - R0) * c * c * c * c * c;\n}\n\nvec3 IdealSpecularReflect(vec3 d, vec3 n) {\n\treturn reflect(d, n);\n}\n\nvec3 IdealSpecularTransmit(vec3 d, vec3 n, float n_out, float n_in, \n                           out float pr, inout uint state) {\n\t\t\n\tvec3 d_Re       = IdealSpecularReflect(d, n);\n    \n\tbool  out_to_in = (0.0f > dot(n, d));\n\tvec3  nl        = out_to_in ? n : -n;\n\tfloat nn        = out_to_in ? n_out / n_in : n_in / n_out;\n\tfloat cos_theta = dot(d, nl);\n\tfloat cos2_phi  = 1.0f - nn * nn * (1.0f - cos_theta * cos_theta);\n\n    // Total Internal Reflection\n    if (0.0f > cos2_phi) {\n        pr = 1.0f;\n        return d_Re;\n    }\n\n    // Stochastic branching between reflection and transmission \n    vec3  d_Tr      = normalize(nn * d - nl * (nn * cos_theta + sqrt(cos2_phi)));\n    float c         = 1.0f - (out_to_in ? -cos_theta : dot(d_Tr, n));\n\n    float Re        = SchlickReflectance(n_out, n_in, c);\n    float p_Re      = 0.25f + 0.5f * Re;\n    \n    if (UniformFloat(state) < p_Re) {\n        pr          = (Re / p_Re);\n        return d_Re;\n    }\n    else {\n        float Tr    = 1.0f - Re;\n        float p_Tr  = 1.0f - p_Re;\n        pr          = (Tr / p_Tr);\n        return d_Tr;\n    }\n}\n\n//-------------------------------------------------------------------------\n// Ray\n//-------------------------------------------------------------------------\n\nstruct Ray {\n    vec3  o; \n   \tvec3  d;\n\tfloat tmin;\n    float tmax;\n\tuint  depth;\n};\n \nvec3 EvalRay(Ray ray, float t) {\n    return ray.o + ray.d * t;\n}\n\n//-------------------------------------------------------------------------\n// Material\n//-------------------------------------------------------------------------\n\nconst uint g_reflection_type_diffuse    = 0u;\nconst uint g_reflection_type_specular   = 1u;\nconst uint g_reflection_type_refractive = 2u;\n\n//-------------------------------------------------------------------------\n// Sphere\n//-------------------------------------------------------------------------\n\n// Decreased epsilon (1e-4f -> 1e-2f) to avoid single precision artifacts.\nconst float g_sphere_epsilon = 1e-2f;\n\nstruct Sphere {\n    float r;\n\tvec3  p;\n\tvec3  e;\n\tvec3  f;\n\tuint  reflection_t;\n};\n\nbool Intersect(Sphere sphere, inout Ray ray) {\n    vec3  op  = sphere.p - ray.o;\n    float dop = dot(ray.d, op);\n    float D   = dop * dop - dot(op, op) + sphere.r * sphere.r;\n\n    if (D < 0.0f) {\n        return false;\n    }\n\n    float sqrtD = sqrt(D);\n\n    float tmin = dop - sqrtD;\n    if (ray.tmin < tmin && tmin < ray.tmax) {\n        ray.tmax = tmin;\n        return true;\n    }\n\n    float tmax = dop + sqrtD;\n    if (ray.tmin < tmax && tmax < ray.tmax) {\n        ray.tmax = tmax;\n        return true;\n    }\n\n    return false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//-------------------------------------------------------------------------\n// Camera\n//-------------------------------------------------------------------------\n\nconst vec3  eye = vec3(50.0f, 52.0f, 295.6f);\nconst float fov = 0.4135f;\n\n//-------------------------------------------------------------------------\n// Scene\n//-------------------------------------------------------------------------\n\nconst float g_scene_refractive_index_out = 1.0f;\nconst float g_scene_refractive_index_in  = 1.5f;\n\nconst uint  g_nb_spheres = 9u;\n\n// Decreased radii (1e-5f -> 1e-4f) to avoid single precision artifacts.\nSphere g_spheres[g_nb_spheres] = Sphere[](\n    Sphere(  1e4f, vec3( 1e4f + 1.0f,  40.8f, 81.6f),  vec3( 0.0f), vec3( 0.75f,  0.25f,  0.25f), g_reflection_type_diffuse),\n    Sphere(  1e4f, vec3(-1e4f + 99.0f, 40.8f, 81.6f),  vec3( 0.0f), vec3( 0.25f,  0.25f,  0.75f), g_reflection_type_diffuse),\n    Sphere(  1e4f, vec3(50.0f, 40.8f, 1e4f),           vec3( 0.0f), vec3( 0.75f), g_reflection_type_diffuse),\n    Sphere(  1e4f, vec3(50.0f, 40.8f, -1e4f + 170.0f), vec3( 0.0f), vec3(  0.0f), g_reflection_type_diffuse),\n    Sphere(  1e4f, vec3(50.0f, 1e4f, 81.6f),           vec3( 0.0f), vec3( 0.75f), g_reflection_type_diffuse),\n    Sphere(  1e4f, vec3(50.0f, -1e4f + 81.6f, 81.6f),  vec3( 0.0f), vec3( 0.75f), g_reflection_type_diffuse),\n    Sphere( 16.5f, vec3(27.0f, 16.5f, 47.0f),          vec3( 0.0f), vec3(0.999f), g_reflection_type_specular),\n    Sphere( 16.5f, vec3(73.0f, 16.5f, 78.0f),          vec3( 0.0f), vec3(0.999f), g_reflection_type_refractive),\n    Sphere(600.0f, vec3(50.0f, 681.33f, 81.6f),        vec3(12.0f), vec3(  0.0f), g_reflection_type_diffuse)\n);\n\nbool Intersect(inout Ray ray, out uint id) {\n\tbool hit = false;\n\tfor (uint i = 0u; i < g_nb_spheres; ++i) {\n\t\tif (Intersect(g_spheres[i], ray)) {\n\t\t\thit = true;\n\t\t\tid = i;\n\t\t}\n\t}\n\n\treturn hit;\n}\n\nvec3 Radiance(Ray ray, inout uint state) {\n    Ray  r = Ray(ray.o, ray.d, ray.tmin, ray.tmax, ray.depth);\n    vec3 L = vec3(0.0f);\n    vec3 F = vec3(1.0f);\n\n    while (true) {\n        uint id;\n        if (!Intersect(r, id)) {\n            return L;\n        }\n\n        Sphere sphere = g_spheres[id];\n        vec3 p = EvalRay(r, r.tmax);\n        vec3 n = normalize(p - sphere.p);\n\n        L += F * sphere.e;\n        F *= sphere.f;\n        \n        // Russian roulette\n        if (4u < r.depth) {\n            float continue_probability = Max(sphere.f);\n            if (UniformFloat(state) >= continue_probability) {\n                return L;\n            }\n            F /= continue_probability;\n        }\n\n        // Next path segment\n        switch (sphere.reflection_t) {\n\n            case g_reflection_type_specular: {\n                vec3 d = IdealSpecularReflect(r.d, n);\n                r = Ray(p, d, g_sphere_epsilon, g_float_inf, r.depth + 1u);\n                break;\n            }\n\n            case g_reflection_type_refractive: {\n                float pr;\n                vec3 d = IdealSpecularTransmit(r.d, n, g_scene_refractive_index_out, g_scene_refractive_index_in, pr, state);\n                F *= pr;\n                r = Ray(p, d, g_sphere_epsilon, g_float_inf, r.depth + 1u);\n                break;\n            }\n\n            default: {\n                vec3 w = (0.0f > dot(n, r.d)) ? n : -n;\n                vec3 u = normalize(cross(((0.1f < abs(w.x)) ? \n                                          vec3(0.0f, 1.0f, 0.0f) : \n                                          vec3(1.0f, 0.0f, 0.0f)), w));\n                vec3 v = cross(w, u);\n                vec3 sample_d = CosineWeightedSampleOnHemisphere(UniformFloat(state), \n                                                                 UniformFloat(state));\n                vec3 d = normalize(sample_d.x * u + sample_d.y * v + sample_d.z * w);\n                r = Ray(p, d, g_sphere_epsilon, g_float_inf, r.depth + 1u);\n                break;\n            }\n        }\n    }\n}\n\nvec3 Radiance(vec2 fragCoord, inout uint state) {\n\tvec3  cz   = normalize(vec3(0.0f, -0.042612f, -1.0f));\n\tvec3  cx   = vec3(iResolution.x * fov / iResolution.y, 0.0f, 0.0f);\n\tvec3  cy   = normalize(cross(cx, cz)) * fov;\n    \n    vec2  u2   = vec2(UniformFloat(state), UniformFloat(state));\n    vec2  cs   = (fragCoord + u2) / iResolution.xy - vec2(0.5f);\n    vec3  d    = cs.x * cx + cs.y * cy + cz;\n    \n    return Radiance(Ray(eye + d * 130.0f, normalize(d), g_sphere_epsilon, g_float_inf, 0u), state);\n}\n\n//-------------------------------------------------------------------------\n// Main\n//-------------------------------------------------------------------------\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    // Hashing for seeding, Xorshift/LCG for sequencing\n    uint  index  = uint(fragCoord.y * iResolution.x + fragCoord.x);\n    uint  key    = index ^ floatBitsToUint(iTime);\n    uint  state  = Hash_Wang(key);\n    \n    // Compute new HDR sample.\n    vec3  hdr    = Radiance(fragCoord, state);\n    \n    // Compute incremental HDR average (Welford).\n    vec2  uv     = fragCoord.xy / iResolution.xy;\n    vec3  mean   = texture(iChannel0, uv).xyz;\n   \tmean        += (hdr - mean) / float(iFrame + 1);\n    \n    // Store new HDR average.\n    color        = vec4(mean, 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"}]}