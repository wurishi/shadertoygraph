{"ver":"0.1","info":{"id":"wts3WH","date":"1556268626","viewed":148,"name":"drawword","username":"you","description":"draw word with cirle and line\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["word"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //简单的一个UV动画\n    vec2 distortionOffset = vec2(0.0,0.0);\n    vec2  texCoord = uv;\n    float time = iTime * 2.0;\n    texCoord.y += 0.1 * cos(5.0 * texCoord.x + time );\n    \n    //vec4 bgColor = texture(iChannel3,uv);\n    \n    //分别采样三个缓冲区的颜色值\n    vec4 color1 = texture(iChannel0,texCoord);\n    vec4 color2 = texture(iChannel1,texCoord);\n    vec4 color3 = texture(iChannel2,texCoord);\n    \n    vec4 res = color1 + color2 + color3;\n    \n    //流光效果\n    res = shinyEffect(res,uv,fract(iTime * 0.5)*2.0);\n    // Output to screen\n    vec4 dateColor = vec4(PrintDate(fragCoord),1.0);\n    fragColor = res + dateColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n//填充一个圆的数学模型是 判断点是否在圆内\n//params: \n// p： 当前屏幕的uv坐标\n// center : 圆的中心点\n// radius:圆的半径\n// blur: 圆的边缘平滑度\nfloat circle(vec2 p,vec2 center,float radius,float blur)\n{\n    //计算坐标点与中心点的长度\n    float len = length(p-center);\n    //如果长度比半径小，则判断在圆内；反之则在圆外\n    //这里用到smoothstep 用来处理边界平滑度，既如果半径在len-blur和len之间时执行平滑埃尔米特差值\n    float sign = smoothstep(len-blur,len,radius);\n    return sign;\n}\n\n//绘制一个空心的右半圆环\n//params: \n// p： 当前屏幕的uv坐标\n// center : 圆的中心点\n// radiusIn:内圆半径\n// radiusOut: 外圆半径\nfloat halfRightCircle(vec2 p,vec2 center,float radiusIn,float radiusOut)\n{\n    float sign = 0.0;\n    //左半圆直接丢弃\n    if (p.x - center.x < 0.0)\n      return sign;\n    float len = length(p - center);\n    //只绘制圆环部分\n    if (len > radiusIn && len < radiusOut)\n      return 1.0 ;\n    else \n      return 0.0;\n}\n\n//填充一个线段的数学模型是判断点距离向量的距离小于等于线段宽度\n//params:\n// p: 当前屏幕uv坐标\n// a,b : 开始和结束点\n// width：线段宽度\n// blur:边界平滑度\nfloat line(vec2 p, vec2 a, vec2 b, float width, float blur) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  //ab的单位向量\n  vec2 dir = normalize(ba);\n  //clamp约束了p在ab向量上的投影范围 既 A ---- P ------B \n  float t = clamp(dot(pa, dir), 0., length(ba));\n  \n  float dist = length(pa - dir * t);\n  return smoothstep(width - blur, width, dist);\n}\n\n//流光效果\nvec4 shinyEffect(vec4 oriColor,vec2 texCoord,float offset)\n{\n    const float factor = 1.0;\n    const vec3 color = vec3(0.4,0.4,0.4);//流光初始颜色\n    const float width = 0.15; //流光宽度\n    const float SQRT_2 = 1.414;\n    vec2 uv = texCoord;\n    \n    //修改流光方向为左上方到右下方\n    uv.y = 1.0 - uv.y;\n    \n    //斜线方程\n    // line (x+y-offset=0) offset:[0, 2] (2->0)\n    //     |y\n    //     |\n    // ____|0___ 1___2____x\n    //     |    |\n    //     |____|*\n    float distance = abs(uv.x+uv.y-offset)/SQRT_2;//SQRT_2; \n    // 线性渐变方程\n    // (1/width)x + y = 1\n    distance = 1.0-(1.0/width)*distance;\n    distance = max(distance, 0.0);\n\n    vec4 blendColor = vec4(0.0,0.0,0.0,0.0);\n    blendColor.xyz = mix(color * distance,oriColor.rgb,uv.x);// \n    blendColor.w = distance;\n\n    float aoffset = abs(1.0-(2.0-offset));\n    vec4 texColor = oriColor.xyzw;\n    // 三个颜色通道分别做混合叠加\n    float alpha = blendColor[3]*texColor[3];\n    texColor.x = (texColor.x + blendColor.x*alpha*factor) * texColor.r;// * aoffset;\n    texColor.y = (texColor.y + blendColor.y*alpha*factor) * texColor.r; //* aoffset;\n    texColor.z = (texColor.z + blendColor.z*alpha*factor) * texColor.r;//* aoffset;\n    return texColor;\n}\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n//打印日期\nvec3 PrintDate(const in vec2 fragCoord)\n{\n    vec3 vColour = vec3(0.0);\n\n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(8.0, 15.0);\n\n\t// Print Date\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, vec2(0.0, 5.0), vFontSize, iDate.x, 4.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, vec2(0.0 + 48.0, 5.0), vFontSize, iDate.y + 1.0, 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, vec2(0.0 + 72.0, 5.0), vFontSize, iDate.z, 2.0, 0.0));\n    \n    return vColour;\n}\n\n//灰度值\nfloat Luminance(vec3 c)\n{\n    return 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//绘制R\n\nconst vec3 lineColor = vec3(1.0,0,0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float width = 50.0;\n    float startX = 125.0;\n    //确定R的中心点\n    vec2 center = vec2(startX,iResolution.y/2.0);\n    //绘制竖线\n    vec2 start = center - vec2(0.0,width);\n    vec2 end = center + vec2(0.0,width);\n    float lineSign = line(fragCoord.xy,start,end,10.0,1.0);\n    vec3 lineColor1 = mix(lineColor,vec3(0.0,0.0,0.0),lineSign);\n    \n    //绘制斜线\n    vec2 start1 = center;\n    vec2 end1 = start + vec2(width,0.0);\n    float lineSign1 = line(fragCoord.xy,start1,end1,10.0,1.0);\n    vec3 lineColor2 = mix(lineColor,vec3(0),lineSign1);\n\t\n    float radius = width;\n    vec2 center1 = center + vec2(9.0,width/2.0 - 10.0);\n    float lineSign2 = halfRightCircle(fragCoord.xy,center1,radius - 30.0,radius - 10.0);\n    vec3 lineColor3 = mix(vec3(0),lineColor,lineSign2);\n    \n\n    // Output to screen\n    fragColor = vec4(lineColor1 + lineColor2 + lineColor3,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//绘制E\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float width = 50.0;\n    float startX = 225.0;\n    //确定R的中心点\n    vec2 center = vec2(startX,iResolution.y/2.0);\n    //绘制竖线\n    vec2 start = center - vec2(0.0,width);\n    vec2 end = center + vec2(0.0,width);\n    float lineSign = line(fragCoord.xy,start,end,10.0,1.0);\n    vec3 lineColor = mix(vec3(1.0,0,0),vec3(0.0,0.0,0.0),lineSign);\n    \n    vec2 start1 = center + vec2(0.0,width);\n    vec2 end1 = start1 + vec2(width,0.0);\n    float lineSign1 = line(fragCoord.xy,start1,end1,10.0,1.0);\n    vec3 lineColor1 = mix(vec3(1.0,0,0),vec3(0.0,0.0,0.0),lineSign1);\n    \n    \n    vec2 start2 = center;\n    vec2 end2 = start2 + vec2(width,0.0);\n    float lineSign2 = line(fragCoord.xy,start2,end2,10.0,1.0);\n    vec3 lineColor2 = mix(vec3(1.0,0,0),vec3(0.0,0.0,0.0),lineSign2);\n    \n    vec2 start3 = center + vec2(0.0,-width);\n    vec2 end3 = start3 + vec2(width,0.0);\n    float lineSign3 = line(fragCoord.xy,start3,end3,10.0,1.0);\n    vec3 lineColor3 = mix(vec3(1.0,0,0),vec3(0.0,0.0,0.0),lineSign3);\n    \n    fragColor = vec4(lineColor + lineColor1 + lineColor2 + lineColor3,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//绘制D\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float width = 50.0;\n    float startX = 325.0;\n\n    vec2 center = vec2(startX,iResolution.y/2.0);\n    //绘制竖线\n    vec2 start = center - vec2(0.0,width);\n    vec2 end = center + vec2(0.0,width);\n    float lineSign = line(fragCoord.xy,start,end,10.0,1.0);\n    vec3 lineColor1 = mix(vec3(1.0,0,0),vec3(0.0,0.0,0.0),lineSign);\n\n    float radius = width * 2.0 - 30.0;\n    vec2 center1 = center + vec2(0.0,width/2.0-25.0);\n    float lineSign2 = halfRightCircle(fragCoord.xy,center1,radius - 30.0,radius - 10.0);\n    vec3 lineColor3 = mix(vec3(0),vec3(1.0,0,0),lineSign2);\n    \n\n    // Output to screen\n    fragColor = vec4(lineColor1 + lineColor3,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}