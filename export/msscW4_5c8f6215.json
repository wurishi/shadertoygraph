{"ver":"0.1","info":{"id":"msscW4","date":"1686832819","viewed":66,"name":"Fox shine","username":"peremptor","description":"Tried my hand on (more or less accurately) reprodusing the shine effect of the space animals from the game super smash brothers. \nIf this violates any copyright agreement let me know and I'll remove it. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["basic","effect","shine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//defines so the shader works out of the box with shadertoy\n#define u_time iGlobalTime\n\n//constants that are often used\n#define PI 3.1415926\n\n\n//smaller values are faster\nconst float animationSpeed = 0.1;\n\n\n\nvec3 calculateFragmentColor(vec2 uv);\n\nfloat SinXToY(float lowerBound, float upperBound, float value, float frequencyFactor, float frequencyOffset) {\n    float sinValue = sin(value * frequencyFactor + frequencyOffset);\n    //move the sine up to the interval 0->2\n    float noNegativeSin = sinValue + 1.;\n    //limit the sine down to 0->1\n    float zeroToOneSin = noNegativeSin / 2.;\n    //scales the amplitude of the sin to the desired size, that is described with x->y\n    float sinOfDesiredSize = zeroToOneSin * (upperBound - lowerBound);\n    //now move the sine along the x axis, so that x is actually the lowest possible value;\n    float finalSin = sinOfDesiredSize + lowerBound;\n    return finalSin;\n}\n\nfloat SinXToY(float lowerBound, float upperBound, float value) {\n    return SinXToY(lowerBound, upperBound, value, 1., 0.);\n}\n\n// i did not create this rand function but i cannot find the source anymore D:\nfloat rand(vec2 co) {\n    const float a = 123.9898;\n    const float b = 781.22333;\n    const float c = 43758.5453;\n  return fract(sin(dot(co.xy, vec2(a, b))) * c);\n}\n\nfloat rand(float val) {\n  return rand(vec2(val));\n}\n\n\nconst float hexSize = sqrt(3.0);\n//all of the calculations on how to create the hex tiling \n//has been taken from https://www.youtube.com/watch?v=VmrIDyYiJBA\nfloat SHexDistance(vec2 uv)\n{\n    uv = abs(uv);\n    float signedVerticalBorderDistance = uv.x;\n    float signedSlopeBorderDistance = dot(uv, normalize(vec2(1.,sqrt(3.))));\n    float signedHexDistance = max(signedSlopeBorderDistance,signedVerticalBorderDistance);\n    return signedHexDistance;\n}\n\nfloat distanceToShine (vec2 uv, float shineSize)\n{\n    float hexDistance = SHexDistance(uv);\n    float inShineValue = hexDistance - shineSize /2.;    \n    return abs(inShineValue);    \n}\n\nvec2 timeLoop(float slotCount,float slotDuration, float time)\n{\n    float animationSlot = floor(mod(time / slotDuration, slotCount));\n    float loopIterationCount = (floor(time/ slotDuration) - animationSlot) / slotCount;\n    return vec2(loopIterationCount, animationSlot);\n}\n\nfloat calcShineStarStencil(vec2 uv, vec2 position, float size)\n{\n\tuv -= position;\n\tuv /= size;\n   float absX = abs(uv.x);\n   float absY = abs(uv.y);\n   float star = \n   (\n   \t.005/(absX) * smoothstep(0.09,0.0,absY) +\n   \t.005/(absY) * smoothstep(0.09,0.0,absX)\n   \t);\n    star+= 0.04/(length(uv) * 2.);\n    return max(0.,star);\n}\n\nvec2 calcStarPosition(float seedValue)\n{\n    /*\n    calculate randomized polarcoordinates \n    inside of a constrained radius for the stars\n    */\n    //                 rand is 0->1 value                         \n    float polarAngle = rand(seedValue) * 2.*PI;\n    //                      creates a random value between 0.2 and 0.5\n    float polarDistance = (rand(seedValue) * 0.3) + 0.2;\n\n    return vec2(polarDistance * cos(polarAngle), polarDistance * sin(polarAngle));\n}\n\nvec3 calculateFragmentColor(vec2 uv)\n{\n    vec3 ret = vec3(0);\n    \n    float shineThickness = 0.09;\n    float borderBlur = 0.005;\n    float shineSize = 0.7;\n        \n    \n    vec2 animationState = timeLoop(3.,animationSpeed,iTime);\n    float animationTime = 3. - animationState.y + 1.;\n    float animationLoopCounter = animationState.x;\n\n    float shineDist = distanceToShine(uv * animationTime, shineSize);\n    float shineStencil = smoothstep(shineThickness + borderBlur, shineThickness, shineDist);\n    float outwardDarkBlueTransitionFactor = smoothstep(0.05,0.09, shineDist);\n\n\n    \n    const vec3 shineColor = vec3(0.4,0.8, 1.0);\n    const vec3 shineBorderColor = vec3(0.2,0.6, 0.8);\n    ret +=  shineStencil * \n    (shineColor - outwardDarkBlueTransitionFactor + shineBorderColor*outwardDarkBlueTransitionFactor);\n\n    //calculate star positions based on the animationloop counter\n\n    for(int i = 0; i < 4; i++)\n    {\n        vec2 starPosition = calcStarPosition(animationLoopCounter * float(i + 1));\n        float starStencil = calcShineStarStencil(uv*animationTime,starPosition,0.5);\n        ret = mix(ret,shineBorderColor* starStencil ,starStencil);\n    }\n\t \n    \n    return ret;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord /iResolution.xy;\n       \n    //make coordinates go from -0.5 to 0.5\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y; \n    vec3 pixelColor = calculateFragmentColor(uv);\n\n    fragColor = vec4(pixelColor, 1);\n}\n","name":"Image","description":"","type":"image"}]}