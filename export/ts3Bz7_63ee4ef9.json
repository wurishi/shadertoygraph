{"ver":"0.1","info":{"id":"ts3Bz7","date":"1604648307","viewed":431,"name":"Among us Patch Tracing","username":"iuryBorgesRodrigues","description":"Among us Patch Tracing","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["amonguspatchtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n\nvec3 bloom(float scale, vec2 fragCoord){\n    \n \n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += vec3(  7,  4,  1) / 273. * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.4 * iResolution.y, fragCoord) * .07;\n    bloomSum += bloom(.07 * iResolution.y, fragCoord) * .07;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = ACESFilm(fragColor.rgb+bloomSum);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Pi 3.14159265359\n\n// radius of the scene\n#define SceneRadius 200.\n// minimum distance before considering a hit\n#define MinDist .01\n// maximum number of steps when tracing a ray\n#define MaxSteps 40096\n// number of light bounces\n#define RayDepth 1\n// Ior of the fresnel effect on the reflections\n#define Ior 1.45\n// enable reflexion caustics for more realism\n#define Caustics true\n\n#define HASH( seed ) fract(cos(seed)*43758.5453)\n#define RANDOM HASH(seed++)\n#define RANDOM2D vec2(RANDOM, RANDOM)\n\nfloat seed;\n\nvec3 CamPos = vec3(0, 0, -4.);\nvec3 CamRot = vec3(0., -1.5, 0.);\nfloat CamFocalLength = 1.5;\nfloat CamFocalDistance = 3.25;\nfloat CamAperture = .05;\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),   vec3( .0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),  vec3( -sa,.0,ca));}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\n\n\nvec3 LightDir = normalize(vec3(-.0, -.1, .1));\nvec3 LightColor = vec3(4.);\nfloat LightRadius = .3;\n\n// self explanatory ...\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\n// cosine weighted sample for diffuse samples\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n// cone sample for NEE on a spherical cap\nvec3 getConeSample(vec3 dir, float theta) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = 1. - r.y*(1.-cos(min(theta, Pi*.5)));\n\tfloat oneminus = sqrt(1.0 - r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n// fresnel\nfloat fresnel(vec3 dir, vec3 n, float ior) {\n    float cosi = dot(dir, n);\n    float etai = 1.0;\n  \tfloat etat = ior;\n    if (cosi > 0.0) {\n         float tmp = etai;\n         etai = etat;\n         etat = tmp;\n     }\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if (sint >= 1.0) return 1.0;\n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\n// julia variant of the quadratic mandelbulb\n// http://www.bugman123.com/Hypercomplex/index.html\nfloat sdBox(vec3 p, vec3 b, vec3 diffuseColor){\n   // p *= rotationMatrix(vec2(.0, .08).xxy);\n    \n    vec3 q = abs(p) - b;\n    \n\t\n    \n    \n    diffuseColor=diffuseColor;\n   \n   \n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t , vec3 diffuseColor)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n   diffuseColor=diffuseColor;\n  return length(q)-t.y;\n}\n\n// plane with a texture and POM\nfloat sdfPlane(vec3 pos, out vec3 diffuseColor){\n    diffuseColor = texture(iChannel2, pos.xz*.5).rgb;\n    // uncomment for a checkerboard pattern\n    //diffuseColor = fract(pos.x)<.5 ^^ fract(pos.z)<.5 ? vec3(0) : vec3(1);\n    return pos.y + .51 + length(diffuseColor)*.001;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat tripulant(vec3 pos, vec3 diffuseColor){\n    \n \tpos/=vec3(0.2);\n    vec3 p = pos;\n    \n    p.x+=((p.y-1.)*sign(p.x))*0.05;\n    float d = sdCapsule(p,vec3(0,1.5,2),vec3(0,-0.5,2),1.6);;\n    d = smin(d,sdBox(pos-vec3(0,0.4,3.55),vec3(1.9,1.7,0.4))-0.1,0.4);\n    vec3 p2 = p;\n    p2.x = abs(p2.x);\n    d = smin(d,sdCylinder(p2,vec3(0.8,-1.05,2),vec3(0.85,-2.75,2),0.3)-0.3,0.25);\n    diffuseColor=diffuseColor;\n    return d*0.2;\n}\n\n\n\nfloat scene(vec3 p, out vec3 diffuseColor){\n    \n    \n    \n    vec3 color[10];\n   \n    color[0]=vec3(1.0,0.0,0.0);\n   color[1]=vec3(1.0);\n    p+=vec3(-1.0,0.0,0.0);\n    float sdf[10];\n    float s = sdfPlane(p, diffuseColor);\n    sdf[0] = tripulant(p, color[0]);\n    p/=vec3(0.2);\n\tsdf[1] = sdBox(p+vec3(0,-1,-0.5-p.x*p.x*0.3),vec3(0.875,0.375,0.125), color[1])-0.125;\n    if(sdf[0] < s){\n        diffuseColor = color[0];\n        s = sdf[0];\n    }\n  \n   if(sdf[1] < s){\n        diffuseColor = color[1];\n        s = sdf[1];\n    }\n   \n    return s;   \n}\n\nfloat sdf(vec3 pos){\n    vec3 ph; // placeholder\n    return scene(pos, ph);\n}\n\nvec3 normal(vec3 pos, float dist){\n    vec2 k = vec2(dist, 0.);\n    return normalize(vec3(sdf(pos + k.xyy),\n\t  \t\t\t\t\t  sdf(pos + k.yxy),\n  \t\t\t\t          sdf(pos + k.yyx)) - k.xxx);\n}\n\n// traces a ray\nbool rayHit(inout vec3 pos, vec3 dir){\n    pos += RANDOM * sdf(pos) * dir;\n    float dist;\n    for(int i = 0; i < MaxSteps; i++){\n        dist = sdf(pos);\n        if(length(pos) > SceneRadius) break;\n        if(dist < MinDist) return true;\n        pos += dir * dist * .99;\n    }\n    return false;\n}\n\n// traces a shadow ray and computes direct light on the surface\nvec3 directLight(vec3 pos, vec3 n){\n    vec3 dir = getConeSample(-LightDir, LightRadius);\n    float dnrd = dot(n, dir);\n    if(dnrd < 0.0) return vec3(0);\n    return rayHit(pos, dir) ? vec3(0.) : LightColor * dnrd * (1.-fresnel(-dir, n, Ior));\n}\n\n\nvec3 background(vec3 dir) {\n    vec3 col = texture(iChannel1, dir).rgb;\n    return col*col+col;\n}\n\n// path tracing algorithm\nvec3 pathTrace(vec3 pos, vec3 dir){\n    \n    vec3 light = vec3(0.), attenuation = vec3(1.);\n    \n    // set this to zero for no reflected light at all (when fireflies are too annoying)\n    vec3 LCsLR2 = LightColor/(sin(LightRadius)*sin(LightRadius)); \n    \n    bool diffuse = false;\n    for(int i = 0; i <= RayDepth; i++){\n        \n        if(sdf(pos) < 0.) return light;\n        \n        // if the ray doesn't hit anything, the background gets rendered\n        if(!rayHit(pos, dir))\n            return light + attenuation *\n            \t(dot(dir, -LightDir) > cos(LightRadius)\t\t// if the ray end up in the light\n                    ? diffuse\t\t\t\t\t\t\t\t// if the ray if a diffuse ray\n                        ? vec3(0.)\t\t\t\t\t\t\t// then don't add any background (direct light already in nee)\n                        : LCsLR2\t\t\t\t\t\t\t// else add the light color\n                    : background(dir)\t\t\t\t\t\t// else sample the cubemap\n                );\n        \n        vec3 diffuseColor;\n        float dist = scene(pos, diffuseColor);\n        vec3 n = normal(pos, dist);\n        pos += n*(1.5*MinDist-dist);\n        \n        // nee\n        light += attenuation * diffuseColor * directLight(pos, n);\n        \n        if(fresnel(dir, n, Ior) > RANDOM) {\n            // reflection\n            dir = reflect(dir, n);\n            if(Caustics) diffuse = false;\n        } else {\n            // diffuse\n            dir = getCosineWeightedSample(n);\n        \tattenuation *= diffuseColor;\n            diffuse = true;\n        }\n    }\n    return light;\n}\n\n// n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation){\n    \n    // create a point on the first \"blade\"\n    float side = sin(Pi / float(nbBlades));\n    vec2 tri = RANDOM2D;\n    if(tri.x-tri.y > 0.) tri = vec2(1.-tri.x, -1.+tri.y);\n    tri *= vec2(side, sqrt(1.-side*side));\n    \n    // rotate it to create the other blades\n    float angle = rotation + 2.*Pi*floor(RANDOM * float(nbBlades))/float(nbBlades);\n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    \n    //mouse mouvement\n    CamRot.yx -= Pi*(iMouse.xy-iResolution.xy)/iResolution.y*0.1;\n    CamPos *= rotationMatrix(CamRot);\n    \n    // random numbers seed\n    seed = cos(iTime)+cos(fragCoord.x)+sin(fragCoord.y);\n    \n    // uv on the camera sensor (from -1 to 1 vertically)\n    vec2 uv = (fragCoord+RANDOM2D-iResolution.xy*.5) / iResolution.y;\n    \n    // gerenate ray direction & position in camera space\n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(6, 0.0), 0.0);\n    vec3 dir = normalize(focalPoint-aperture);\n    vec3 pos = aperture;\n    \n    // convertion to world space\n    mat3 CamMatrix = rotationMatrix(CamRot);\n    dir *= CamMatrix;\n    pos = pos*CamMatrix + CamPos;\n    \n    fragColor = iFrame == 0 ? vec4(0.) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.) fragColor.a = 0.;\n    fragColor.rgb = mix(fragColor.rgb, pathTrace(pos, dir), 1.0/(++fragColor.a));\n}","name":"Buffer A","description":"","type":"buffer"}]}