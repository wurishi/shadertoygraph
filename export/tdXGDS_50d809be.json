{"ver":"0.1","info":{"id":"tdXGDS","date":"1547330898","viewed":137,"name":"DJ Zhenya CHERVONA","username":"Glad8r","description":"My name","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["name"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// SixteenSegmentDisplay.glsl\n// 16 Segment Display Example v3\n// rearranged source code by I.G.P.\n// better comments added to source by Hekate\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec2 uv;\n\nuniform float time;\nuniform vec2 resolution;\n\nconst float pi = atan(1.0)*4.0;\nconst float tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nconst float epsilon = 1e-3;\nconst float infinity = 1e6;\n\nconst vec2 ch_size  = vec2(2.0, 4.0);              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.0, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -8., 2.); // start position\n      vec2 ch_pos   = vec2 (0.0, -0.5);             // character position(X,Y)\n      vec3 ch_color = vec3 (1.0, 0.0, 0.0);        // character color (R,G,B)\nconst vec3 bg_color = vec3 (0.0, 0.0, 0.0);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1000 1111\n\n 0011 0001 1001 1111\n 0x31AF\n\n binary to hex -> 0x119F\n*/\n\n#define n0 ddigit(0x22FF);\n#define n1 ddigit(0x0281);\n#define n2 ddigit(0x1177);\n#define n3 ddigit(0x11E7);\n#define n4 ddigit(0x1189);\n#define n5 ddigit(0x11EE);\n#define n6 ddigit(0x11FE);\n#define n7 ddigit(0x0087);\n#define n8 ddigit(0x11FF);\n#define n9 ddigit(0x11EF);\n\n#define A ddigit(0x119F);\n#define B ddigit(0x927E);\n#define C ddigit(0x007E);\n#define D ddigit(0x44E7);\n#define E ddigit(0x107E);\n#define F ddigit(0x101E);\n#define G ddigit(0x807E);\n#define H ddigit(0x1199);\n#define I ddigit(0x4466);\n#define J ddigit(0x4436);\n#define K ddigit(0x9218);\n#define L ddigit(0x0078);\n#define M ddigit(0x0A99);\n#define N ddigit(0x8899);\n#define O ddigit(0x00FF);\n#define P ddigit(0x111F);\n#define Q ddigit(0x80FF);\n#define R ddigit(0x911F);\n#define S ddigit(0x8866);\n#define T ddigit(0x4406);\n#define U ddigit(0x00F9);\n#define V ddigit(0x2218);\n#define W ddigit(0xA099);\n#define X ddigit(0xAA00);\n#define Y ddigit(0x4A00);\n#define Z ddigit(0x2266);\n#define Zh ddigit(0xEE00);\n#define Ya ddigit(0x318F);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0);\n#define s_minus   ddigit(0x1100);\n#define s_plus    ddigit(0x5500);\n#define s_greater ddigit(0x2800);\n#define s_less    ddigit(0x8200);\n#define s_sqrt    ddigit(0x0C02);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n\treturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\nfloat d = 1e6;\n\nvoid ddigit(int n)\n{\n\tfloat v = 1e6;\t\n\tvec2 cp = uv - ch_pos;\n\tif (n == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tuv = ( fragCoord.xy / iResolution.y ) - aspect / 2.0;\n\tuv *= 20.0 ;//+ sin(time);     //  set zoom size\n\tuv.y -= 3.;\n    uv.x -= 12.;\n\n\tch_pos = ch_start;// i//+ vec2(sin(time),0.0);  // set start position\n\t\n\n    C H E R V O N A _ nl1  nl2 A N D _ nl3 \n\tD J Zh E H Ya\n\t\n\t\n\tvec3 color = mix(ch_color, bg_color, 1.0- (0.08 / d));  // shading\n\t//color *= 0.4 + abs(sin(time*5.));\n\n    //Flicker fade in effect.\n    float tf_text = max(epsilon, abs(sin(121.*iTime)) );\n    float bright_text = 1. * min(1.0, 1.0 - sin(tf_text * pi * 50.0) / (tf_text * pi * 1.3));\n\n\tcolor *= bright_text;\n\tfragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}