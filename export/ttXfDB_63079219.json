{"ver":"0.1","info":{"id":"ttXfDB","date":"1597613963","viewed":452,"name":"Interface 00","username":"gunthern","description":"Book of shaders chapter 08 exercise ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["ui","hud","interface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nmat2 rotate2d (float _angle){\n\treturn mat2 (cos(_angle),sin(_angle),-sin(_angle),cos(_angle));   \n}\n\nmat2 scale2d (vec2 _scale){\n\treturn mat2 (_scale.x, 0.0, 0.0, _scale.y);  \n}\n\nfloat box (in vec2 _size, in vec2 _uv){\n    _size = vec2(0.5) - _size*.5;\n    vec2 st = smoothstep (_size, _size+vec2(0.04), _uv);\n    st *= smoothstep (_size, _size+vec2(0.04),vec2(1.0)-_uv);\n    float box = st.x * st.y;\n\treturn box;\n}\n\nfloat plot(in vec2 _uv, in float _pct) {    \n    return smoothstep(_pct-.01, _pct, _uv.y) - smoothstep(_pct, _pct+.01, _uv.y);\n}\n\nfloat random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //grids\n    float grid0x = cos((uv.x - 1.1) * 170.);\n    grid0x = step(0.99,grid0x);\n    float grid0y = cos((uv.y - 1.5) * 100.);\n    grid0y = step(0.99,grid0y);\n    \n    float grid2 = sin(uv.x * 170.) * sin(uv.y * 100.);\n    grid2 = step(.9,grid2);\n    \n    \n    //Box 0 (top right)\n    float box0 = box(vec2(.45,.65), uv - vec2(0.265, 0.15));\n    float box0inv = 1.0 - step(0.2,box0);\n    box0 = step(0.1,box0) - step(0.2,box0);\n    \n    //box 1 (bottom right)\n    float box1 = box(vec2(.45,.275), uv - vec2(0.265, -0.333));\n    float box1inv = 1.0 - step(0.2,box1);\n    box1 = step(0.1,box1) - step(0.2,box1);\n    \n    //box 2 (left)\n    float box2 = box(vec2(.525,.95), uv - vec2(-0.225, 0.));\n    float box2inv = 1.0 - step(0.2,box2);\n    box2 = step(0.1,box2) - step(0.2,box2);\n    \n    //box 0 contents\n    float plot0 = plot(uv, (sin((uv.x*sin(cos(iTime/2.5))+cos(iTime/2.))*50.)*.25) + .65) + .5;\n    \n    //box 1 contents\n    float loadingbar0 = box(vec2(clamp(abs(sin(iTime*2.4) * sin(iTime/3.6) * cos(iTime/10.5)),abs(sin(iTime)),1.0),0.5), uv - vec2(0.0, -0.333));\n    vec2 uvrot = rotate2d(.25) * uv;\n    float loadingbar0stripes = step(sin((uvrot.x-iTime*.1) * 100.),0.01);\n    loadingbar0 = step(1.,loadingbar0);\n    \n    //box2 contents\n    vec2 uvremap = uv *2.-1.;\n    uvremap = scale2d( vec2(sin(iTime/60.75)*sin(iTime/40.)) ) * uvremap;\n    uvremap *= rotate2d(PI*cos(iTime/10.233)*sin(iTime/40.87));\n    uvremap.y /= 1.75;\n    uvremap += vec2(sin(iTime/30.)*2. + 3.);\n    float dist = length( abs(uvremap)-(sin(iTime/20.3) * cos(iTime/22.33)));\n    vec2 pos = vec2(uvremap*0.5);\n    dist *= noise(pos * vec2(sin(iTime/32.3)));\n    dist = smoothstep(.3,.0,fract(dist*25.0));\n                            \n    //box outline color\n    vec3 lightblue = vec3(.2,.7,1.0);\n                    \n    vec3 col = vec3(0.0);\n    col += vec3(box0) * lightblue;\n    col += vec3(0.0,plot0,0.0) * (1. - vec3(box0inv));\n    col += ((vec3(grid0x) * lightblue * .2) + (vec3(grid0y) * lightblue * .3)) * (1. - vec3(box0inv));\n    col += vec3(box1) * lightblue;\n    col += vec3(loadingbar0*.55,loadingbar0*.25,loadingbar0*.65) * vec3(loadingbar0stripes*0.5+.5) * (1. - vec3(box1inv));\n    col += vec3(.55,0.1,0.5)  * (1. - vec3(box1inv));\n    col += vec3(box2) * lightblue;\n    col += vec3(0.3,0.2,0.45)  * (1. - vec3(box2inv));\n    col += vec3(dist*.2, dist*.9, dist*.9) *.6 * (1. - vec3(box2inv));\n    col += (vec3(grid2) * lightblue * .2) * (1. - vec3(box2inv));\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}