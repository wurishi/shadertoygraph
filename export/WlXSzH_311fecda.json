{"ver":"0.1","info":{"id":"WlXSzH","date":"1562365396","viewed":177,"name":"Dithering Examples","username":"Qendolin","description":"This is a simple shader to test out dithering using different patterns.\n\nInspired by bisqwit.","likes":1,"published":1,"flags":96,"usePreview":0,"tags":["noise","dithering","bluenoise","bayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Make sure sound is playing (buffer c) for better experience. Also make fullscreen\n//settings in the common tab\n//buf a -> some checks\n//buf b -> dithering\n//buf c -> the shader, try different ones if you like\n//buf d -> access to more textures\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//just double checking the color bit depth\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec4 f_col = texture(iChannel0, uv);\n   \n    fragColor.rgb = round(f_col.rgb*COLORS)/COLORS;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float step_round_f(float x, float step) {\n\tif(fract(x) > step) return ceil(x);\n    else return floor(x);\n}\n\nvec3 step_round(vec3 x, float step) {\n\treturn vec3(\n        step_round_f(x.x, step), \n    \tstep_round_f(x.y, step),\n    \tstep_round_f(x.z, step));\n}\n\nfloat getDithVal(in vec2 fragCoord, in vec2 uv) {\n    #if DITHER == 4\n    #define CHAN iChannel2\n    #elif DITHER == 5\n    #define CHAN iChannel3\n    #else\n    #define CHAN iChannel1\n    #endif\n    \n    vec2 chanRes = iChannelResolution[1+max(0,DITHER-3)].xy;\n    \n\tvec2 offset = vec2(0.);\n    #if JITTER && DITHER > 3\n    float timeOffset = floor(iTime*8.);\n    timeOffset = rand(vec2(timeOffset));\n    timeOffset *= chanRes.x;\n    offset.x = timeOffset;\n    timeOffset = rand(vec2(timeOffset));\n    timeOffset *= chanRes.x;\n    offset.y = timeOffset;\n    #endif\n    \n    ivec2 texCoord = ivec2(mod(fragCoord+offset, chanRes));\n    return texelFetch(CHAN, texCoord, 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 in_col = texture(iChannel0, uv).rgb;\n    #ifdef DITHER\n\tfloat dithVal = getDithVal(fragCoord, uv);\n    fragColor.rgb = (step_round(in_col*COLORS, dithVal) / COLORS).rgb;\n    #else\n    fragColor.rgb = in_col;\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtlGzX","filepath":"https://soundcloud.com/3kliksphilip/under-the-pizza","previewfilepath":"https://soundcloud.com/3kliksphilip/under-the-pizza","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//exact copy from https://www.shadertoy.com/view/MsKcRh\n//this buffer holds the actual visuals\n\n#define PI 3.14159265359\n\nfloat sinNorm(float x)\n{\n    return sin(x)*0.5+0.5;\n}\n\nfloat line(in int lineWidth, in vec2 pos, in vec2 point, in vec3 iResolution) {\n    float normalizedLineRadius = (float(lineWidth) / iResolution.y) / 2.;\n    float edgeWidth = 1. / iResolution.y;\n    if(normalizedLineRadius<1./iResolution.x)\n        return 0.;\n\treturn smoothstep(pos.y-normalizedLineRadius,pos.y-edgeWidth,point.y-normalizedLineRadius+edgeWidth) * \n        (1.-smoothstep(pos.y+normalizedLineRadius-edgeWidth, pos.y+normalizedLineRadius+edgeWidth, point.y));\n}\n\nfloat smoothVal(in float x, in float max) {\n\treturn clamp(smoothstep(0.0,1.0,x/max)*(1.-smoothstep(0.0,1.0,x/max))*4.,0.,1.);\n}\n\n//f(x) = amplitude*sinNormalized(frequency*x-offsetX)+d\nfloat normSinFunct(in float amplitude, in float freq, in float offsetX, in float offsetY, in float x) {\n    return amplitude*sinNorm(freq*x-offsetX)+offsetY;\n}\n\nfloat rand(float seed) {\n    return fract(sin(dot(vec2(seed, seed / PI) ,vec2(12.9898,78.233))) * 43758.5453);   \n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Make random values more random\nfloat randSeed = 0.;\n\n#define FLOORI(x) float(int(floor(x)))\n\n/* old function\nfloat smoothRand(float interval, float seed) {\n    float next = rand(1.+floor(iTime/interval)+seed);\n    float curr = rand(floor(iTime/interval)+seed);\n    randSeed++;\n    return mix(curr, next, fract(iTime/interval));\n}\n*/\n\nfloat smoothRand(float interval, float seed) {\n    float next = rand(.000001*FLOORI(1000000.*(1.+FLOORI(iTime/interval)+seed+randSeed)));\n    float curr = rand(.000001*FLOORI(1000000.*(FLOORI(iTime/interval)+seed+randSeed)));\n    randSeed++;\n    return mix(curr, next, fract(iTime/interval));\n}\n\nfloat f(vec2 point) {\n\treturn sin(point.x*2.+iTime*1.275)+point.y;   \n}\n\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\n//https://iquilezles.org/articles/distance\nfloat color( in vec2 point, in int lineWidth, in vec3 iResolution)\n{\n    float v = f( point );\n    vec2  g = grad( point );\n    float de = abs(v)/length(g);\n    float normalizedLineRadius = (float(lineWidth) / iResolution.y) / 2.;\n    float edgeWidth = 1. / iResolution.y;\n    if(normalizedLineRadius<1./iResolution.x)\n        return 0.;\n    float eps = max(1./iResolution.x, 1./iResolution.y)*normalizedLineRadius;\n    return 1.-clamp(smoothstep( 0., normalizedLineRadius, de ), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //init\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 point = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tpoint = 2.0 * point.xy / iResolution.y;\n    float x,y,z = 0.;\n \n    //Limit \"frames\" for uniterrupted animation\n    float frameRatio = floor(iFrameRate/ 30.);\n    if(mod(float(iFrame), frameRatio) != 0.) {\n        float decay = sinNorm(iTime*0.789)*0.5+0.1;\n        fragColor += texture(iChannel0, uv) * (1.-(1./(decay*iFrameRate)));\n\n        //Clamp to prevent overexposure\n        fragColor.r = clamp(fragColor.r, 0., 1.);\n        fragColor.g = clamp(fragColor.g, 0., 1.);\n        fragColor.b = clamp(fragColor.b, 0., 1.);\n        return;   \n    }\n    \n    //Scaling\n    const float maxZoom = 1.5;\n    const float minZoom = 0.5;\n    const float changeInterval = 2.;\n    float nextZ = rand(1.+floor(iTime/changeInterval));\n    float currZ = rand(floor(iTime/changeInterval));\n    z=minZoom+(maxZoom-minZoom)*mix(currZ, nextZ, fract(iTime/changeInterval));\n    point/=vec2(z);\n    \n    //Rotation\n    float rot = smoothRand(0.5,354.856)*PI;\n    point=vec2(cos(rot)*point.x+sin(rot)*point.y, -sin(rot)*point.x+cos(rot)*point.y);\n    \n    //Translation\n    point.x+=smoothRand(1.,842.546)*2.-1.;\n    //No need to translate y here, bc y is set by the function in \"f(point)\" and the rotation.\n    \n    //Line\n    const float minLength = 0.25;\n    const float maxLength=0.5;\n    float lineLength=minLength+smoothRand(4.,0.846)*(maxLength-minLength)+minLength;\n    float linePoint = (point.x+lineLength/2.) / lineLength;\n    //\t\t\t\tclamp - make sure the value is in bounds\n    //\t\t\t\t\t\t  smoothVal - make the line thinner at the ends\n    int lineWidth = int(clamp(floor(smoothVal(linePoint*100., 100.)*iResolution.x*0.025*z), 2., floor(iResolution.x*0.025*z)));//max(3,int((iResolution.x*0.1)*  pow((point.x*(1./lineLength)),3.)  ));\n    if(point.x >= -lineLength / 2. && point.x <= lineLength / 2.) { //Only show a small segment\n    \tfragColor+=color(vec2(point.x,point.y), lineWidth, iResolution);//line(lineWidth, vec2(x,y), point, iResolution);\n\t}\t\n    /*if(point.x-x<0.005) {\n        fragColor = vec4(1.);\n    }\n    if(point.y-y<0.005) {\n\t\t//fragColor = vec4(1.);\n    }*/\n    //Color\n    fragColor.rgb*=hsv2rgb(vec3(fract(iTime/7.), sinNorm(iTime*rand(135.54))*0.4+0.6,1.));\n    fragColor.rgb+=pow((fragColor.r+fragColor.g+fragColor.b)/3.+0.25,3.)-pow(0.25,3.);\n    \n    //Fade\n    float decay = sinNorm(iTime*0.789)*0.5+0.25;\n    fragColor += texture(iChannel0, uv) * (1.-(1./(decay*iFrameRate)));\n    \n    //Clamp to prevent overexposure\n    fragColor.r = clamp(fragColor.r, 0., 2.);\n    fragColor.g = clamp(fragColor.g, 0., 2.);\n    fragColor.b = clamp(fragColor.b, 0., 2.);\n    fragColor.a = 0.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n * 0 - Bayer\n * 1 - Blue Noise\n * 2 - White Noise\n * 3 - Organic 3\n * 4 - Abstract 3\n * 5 - Organic 2\n */\n#define DITHER 2\n\n/*\n * 0 - Off\n * 1 - On\n */\n#define JITTER 0\n\nconst ivec3 COLOR_BITS = ivec3(1,1,1);\nconst vec3 COLORS = vec3(1<<COLOR_BITS.r-1,1<<COLOR_BITS.g-1,1<<COLOR_BITS.b-1);\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if DITHER == 0\n    #define CHAN iChannel0\n    #elif DITHER == 1\n    #define CHAN iChannel1\n    #elif DITHER == 2\n    #define CHAN iChannel2\n    #elif DITHER == 3\n    #define CHAN iChannel3\n    #else\n    return;\n    #endif\n    \n    #if DITHER <= 3\n    vec2 chanRes = iChannelResolution[DITHER].xy;\n    \n\tvec2 offset = vec2(0.);\n    #if JITTER\n    float timeOffset = floor(iTime*8.);\n    timeOffset = rand(vec2(timeOffset));\n    timeOffset *= chanRes.x;\n    offset.x = timeOffset;\n    timeOffset = rand(vec2(timeOffset));\n    timeOffset *= chanRes.x;\n    offset.y = timeOffset;\n    #endif\n    \n    ivec2 texCoord = ivec2(mod(fragCoord+offset, chanRes));\n    fragColor = texelFetch(CHAN, texCoord, 0);\n    #endif\n}","name":"Buffer D","description":"","type":"buffer"}]}