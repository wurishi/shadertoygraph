{"ver":"0.1","info":{"id":"DslSD7","date":"1669033328","viewed":17,"name":"Exercise 11 - Ilia Esmaili Poor","username":"IEP","description":"Practice shader for computer graphics course.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,\n        ivec2(fragCoord.xy - 0.5), 0).rgba;\n    data.rgb *= 1.0/data.a;\n    \n    // Output to screen\n    fragColor = vec4(pow(data.rgb, vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 spherePos = vec3(0.2,0.2,-2);\nconst float sphereRadius = 1.0f;\nconst vec3 sphere2Pos = vec3(0.7,-0.35,-0.75);\nconst vec3 sphere3Pos = vec3(3.5,0.75,-3);\nconst vec3 sphere4Pos = vec3(-0.1,-0.25,-1);\nconst float sphere2Radius = 0.25f;\nconst float sphere3Radius = 1.5;\nconst float sphere4Radius = 0.5;\nconst float groundHeight = -0.65f;\nconst float lightWallDistance = -1.0;\nvec3 finalColor = vec3(0,0.7,0.95);\nvec3 lightDirection = vec3(0.25,0.5,0.95);\nconst float epsilon = 0.0001f;\nfloat sphereFloat;\nfloat sphere2Float;\nfloat sphere3Float;\nfloat sphere4Float;\nfloat groundFloat;\nfloat lightWallFloat;\nint material;\nvec3 matColor;\nbool insideObject;\n//vec3 p;\n\nconst vec3 ambientColor = vec3(0.1,0.15,0.2);\nconst vec3 specularColor = vec3(0.85,0.9,1);\nconst float shininess = 70.0;\nvec3 camPos = vec3(0,0,0);\nconst vec3 lightColor = vec3(0.85,1,1);\nconst float ambientReflectivity = 0.170;\n\nuvec4 pcg4d(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v += v.yzxy*v.wxyz;\n    v ^= v >> 16u;\n    v += v.yzxy*v.wxyz;\n    return v;\n}\n\nmat3 create_tangent_space(vec3 normal)\n{\n    const float one_over_sqrt_3 = 1.0 / sqrt(3.0);\n    vec3 major;\n    if(abs(normal.x) < one_over_sqrt_3) major = vec3(1,0,0);\n    else if(abs(normal.y) < one_over_sqrt_3) major = vec3(0,1,0);\n    else major = vec3(0,0,1);\n    vec3 tangent = normalize(cross(normal, major));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\n\nfloat sdf_scene(vec3 point)\n{\n    sphereFloat = length(point - spherePos) - sphereRadius;\n    sphere2Float = length(point - sphere2Pos) - sphere2Radius;\n    sphere3Float = length(point - sphere3Pos) - sphere3Radius;\n    sphere4Float = length(point - sphere4Pos) - sphere4Radius;\n    groundFloat =  point.y - groundHeight;\n    lightWallFloat = point.x - lightWallDistance;\n    \n    material = 1;\n    float theDistance = sphereFloat;\n    if (sphere2Float < theDistance)\n    {\n        material = 4;\n        theDistance = sphere2Float;\n    }\n    if (sphere3Float < theDistance)\n    {\n        material = 5;\n        theDistance = sphere3Float;\n    }\n    if (sphere4Float < theDistance)\n    {\n        material = 6;\n        theDistance = sphere4Float;\n    }\n    if (groundFloat < theDistance)\n    {\n        material = 2;\n        theDistance = groundFloat;\n    }\n    if (lightWallFloat < theDistance)\n    {\n        material = 3;\n        theDistance = lightWallFloat;\n    }\n    \n    return theDistance;\n}\n\nvec3 calculate_normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(sdf_scene(p + e.xyy) - sdf_scene(p - e.xyy),\n    sdf_scene(p + e.yxy) - sdf_scene(p - e.yxy),\n    sdf_scene(p + e.yyx) - sdf_scene(p - e.yyx)));\n}\n\n/*void DoBlinnPhong(vec3 pos, vec3 dir)\n{\n   vec3 reflection = reflect(-dir, calculate_normal(pos));\n   vec3 view = normalize(camPos - pos);\n   vec3 halfVector = (dir + view) / length(dir + view);   \n   vec3 specular = pow(max(dot(halfVector, calculate_normal(pos)), 0.0), shininess) * specularColor;\n   float diffuse = max(dot(lightDirection * lightColor, calculate_normal(pos)), 0.0);\n   finalColor = vec3(ambientColor * 0.25 + finalColor + specular);\n}*/\n\nfloat CastRayAndReturnClosestHit(vec3 ray_origin, vec3 ray_direction)\n{\n    material = 0;\n    float t = 0.0;\n    for (int i = 0; i < 50; ++i)\n    {\n        vec3 p = ray_origin + t * ray_direction;\n        float hitDistance = sdf_scene(p); // This returns a material and a hit distance\n        // vvv To test out the normal vvv\n        //finalColor = calculate_normal(p);    \n        if (hitDistance < epsilon)\n            break;\n            \n        t = t + hitDistance;\n    }\n    return t;\n}\n\n/*void ApplyFog(vec3 ray_origin)\n{\n    vec3 fogColor = vec3(0,0.1f,0.2f);\n    float fogIntensity = 0.075f;\n    float fog = exp(-fogIntensity * length(ray_origin - p));\n    finalColor = finalColor * fog + fogColor * (1.0f - fog);\n}*/\n\nfloat PDF(vec3 w, vec3 normal)\n{\n    return max((dot(w, normal)/3.1415), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    // Rescale x and y to a range between -1 and 1 and set z to -1\n    /*vec3 rd = vec3(uv * 2.f - 1.f, -1.0);\n    // Scale the x-axis by the aspect ratio\n    rd.x *= aspect_ratio;\n    // Normalize the ray direction\n    rd = normalize(rd);*/\n    \n    vec3 ro = camPos;\n    vec3 rd = vec3((uv)*2.0-1.0, -1.0);\n    rd.x *= aspect_ratio;\n    rd = normalize(rd);\n    finalColor = vec3(0.0, 0.0, 0.0);\n    vec3 attenuation = vec3(1.0, 1.0, 1.0);\n    uvec4 seed = uvec4(fragCoord.xy, iFrame, 0);\n    for(int bounce = 0; bounce < 5; bounce++)\n    {\n        float closestHit = CastRayAndReturnClosestHit(ro, rd);        \n        \n        if (closestHit < 50.0) // Means we hit something\n        {\n            vec3 intersection_point = ro + (rd * closestHit);\n            vec3 currentNormal = calculate_normal(intersection_point); \n            switch(material) // Give basic color of material\n            {\n                case 0:matColor = vec3(0,0.7,0.95);break; // Sky\n                case 1:matColor = vec3(0.7,0.7,0.7);break; // Blue sphere\n                case 2:matColor = vec3(0.2,0.2,0.2);break; // Ground\n                case 3:matColor = vec3(0.5,0.85,0);break; // Light wall\n                case 4:matColor = vec3(0.75,0.5,0);break; // Sun sphere\n                case 5:matColor = vec3(0.85,0,0.15);break; // Mirror sphere\n                case 6:matColor = vec3(0.85,0.85,0.05);break; // Glass sphere\n            }\n            \n            if (material == 3) // Emissive material\n                finalColor += attenuation * vec3(0.5,1.9,3); // Emmision strength\n                \n            if (material == 4) // Emissive material\n                finalColor += attenuation * vec3(2.75,0.5,0); // Emmision strength\n           \n            vec3 next_direction;\n           \n            if (material == 6) // Glass material\n            {\n                if(!insideObject)\n                {\n                    insideObject = true;\n                    next_direction = refract(rd, currentNormal, 1.0 / 1.5);\n                }\n                else\n                {\n                    insideObject = false;\n                    next_direction = refract(-rd, -currentNormal, 1.0 / 1.5);\n                }\n                attenuation *= matColor;\n            }\n            else if (material == 5) // Mirror material\n            {\n                next_direction = reflect(rd, currentNormal);\n                attenuation *= matColor;\n            }\n            else\n            {\n                // Generating a random direction\n                vec4 rand = vec4(pcg4d(seed)) / float(0xffffffffu);\n                vec3 secondOperand = \n                    vec3(sqrt(rand.x) * cos(2.0 * 3.1415 * rand.y),\n                    sqrt(rand.x) * sin(2.0 * 3.1415 * rand.y), \n                    sqrt(1.0 - rand.x));\n                vec3 randomDir = create_tangent_space(currentNormal) * secondOperand;\n                next_direction = normalize(randomDir.xyz);\n                // vvv Simplified BSDF vvv\n                attenuation *= matColor / vec3(3.1415,3.1415,3.1415);\n                attenuation *= abs(dot(next_direction, currentNormal));\n                attenuation /= PDF(next_direction, currentNormal);\n            }\n           \n            //attenuation *= matColor;\n            ro = intersection_point + currentNormal * 0.002;\n            rd = next_direction;\n            //DoBlinnPhong(ro, -rd);\n        }\n        else\n        {\n            finalColor += attenuation * texture(iChannel1, rd).rgb;\n            break;\n        }\n    } \n    \n    //ApplyFog(camPos);\n    \n    // Output to screen\n    if (iFrame >= 2 && iMouse.z < 0.0)\n    {\n        vec4 old_data = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0);\n        fragColor = old_data + vec4(finalColor, 1.0);\n    }\n    else\n        fragColor = vec4(finalColor,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}