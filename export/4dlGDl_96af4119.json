{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Sphere trace through inverse trilinear deformed space \n//Starts by ray-bilinear patch intersection x6 hexahedron faces to get a valid start and end for UVW\n//to interpolate as an initial guess to Newton's method to calculate the real UVW.\n\n//Try getting rid of ANGLE if you want shadows, otherwise shader is too complicated. run: \n//\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" -use-gl=desktop\n\n//#define SHADOWS\t\n\n#define pi 3.1415927\n\nmat3 inverse_transpose(mat3 m)\n{\n\tmat3 a;\n\ta[0]=cross(m[1],m[2]);\n\ta[1]=cross(m[2],m[0]);\n\ta[2]=cross(m[0],m[1]);\t\n\tfloat det = dot(a[2],m[2]);\n\treturn a * (1./det);\n}\n\nmat3 adjoint_transpose(mat3 m)\n{\n\tmat3 a;\n\ta[0]=cross(m[1],m[2]);\n\ta[1]=cross(m[2],m[0]);\n\ta[2]=cross(m[0],m[1]);\t\n\treturn a;\n}\n\nfloat det(mat3 m)\n{\n\tvec3 a;\n\ta=cross(m[0],m[1]);\t\n\tfloat det = dot(a,m[2]);\n\treturn det;\n}\n\n//http://web.archive.org/web/20110509034744/http://www.grc.nasa.gov/WWW/winddocs/utilities/b4wind_guide/trilinear.html\n\nvec3 InverseDeform(vec3 p, vec3 x[8], vec3 initial_guess)\n{\n\tvec3 f0 = (x[7] + x[6] + x[5] + x[4] + x[3] + x[2] + x[1] + x[0]) * 0.125;\t\n\tvec3 f1 = (x[7] - x[6] + x[5] - x[4] + x[3] - x[2] + x[1] - x[0]) * 0.125;\n\tvec3 f2 = (x[7] + x[6] - x[5] - x[4] + x[3] + x[2] - x[1] - x[0]) * 0.125;\n\tvec3 f3 = (x[7] + x[6] + x[5] + x[4] - x[3] - x[2] - x[1] - x[0]) * 0.125;\n\tvec3 f4 = (x[7] - x[6] - x[5] + x[4] + x[3] - x[2] - x[1] + x[0]) * 0.125;\n\tvec3 f5 = (x[7] - x[6] + x[5] - x[4] - x[3] + x[2] - x[1] + x[0]) * 0.125;\n\tvec3 f6 = (x[7] + x[6] - x[5] - x[4] - x[3] - x[2] + x[1] + x[0]) * 0.125;\n\tvec3 f7 = (x[7] - x[6] - x[5] + x[4] - x[3] + x[2] + x[1] - x[0]) * 0.125;\n\t\n\tvec3 q = initial_guess;\n\n\tfor (int i=0; i<2; i++)\n\t{\n\t\tfloat a=q.x;\n\t\tfloat b=q.y;\n\t\tfloat g=q.z;\n\t\t\t\n\t\tvec3 f = f0      + f1*a     + f2*b     + f3*g     +\n\t\t\t\tf4*(a*b) + f5*(a*g) + f6*(b*g) + f7*(a*b*g);\n\t\tf -=  p;\t\n\t\tmat3 M;\n\t\tM[0]=   (f1 + f4*b + f5*g + f7*(b*g));\n\t\tM[1]=\t(f2 + f4*a + f6*g + f7*(a*g));\n\t\tM[2]=\t(f3 + f5*a + f6*b + f7*(a*b));\n\t\tq -= f*inverse_transpose(M);\n\t}\n\t\n\treturn q;\n}\n\nmat3 Jacobian(vec3 x[8], vec3 q)\n{\n\tvec3 f0 = (x[7] + x[6] + x[5] + x[4] + x[3] + x[2] + x[1] + x[0]) * 0.125;\t\n\tvec3 f1 = (x[7] - x[6] + x[5] - x[4] + x[3] - x[2] + x[1] - x[0]) * 0.125;\n\tvec3 f2 = (x[7] + x[6] - x[5] - x[4] + x[3] + x[2] - x[1] - x[0]) * 0.125;\n\tvec3 f3 = (x[7] + x[6] + x[5] + x[4] - x[3] - x[2] - x[1] - x[0]) * 0.125;\n\tvec3 f4 = (x[7] - x[6] - x[5] + x[4] + x[3] - x[2] - x[1] + x[0]) * 0.125;\n\tvec3 f5 = (x[7] - x[6] + x[5] - x[4] - x[3] + x[2] - x[1] + x[0]) * 0.125;\n\tvec3 f6 = (x[7] + x[6] - x[5] - x[4] - x[3] - x[2] + x[1] + x[0]) * 0.125;\n\tvec3 f7 = (x[7] - x[6] - x[5] + x[4] - x[3] + x[2] + x[1] - x[0]) * 0.125;\n\n\tfloat a=q.x;\n\tfloat b=q.y;\n\tfloat g=q.z;\n\t\t\n\tvec3 f = f0      + f1*a     + f2*b     + f3*g     +\n\t\t\tf4*(a*b) + f5*(a*g) + f6*(b*g) + f7*(a*b*g);\n\t\n\tmat3 M;\n\tM[0]=   (f1 + f4*b + f5*g + f7*(b*g));\n\tM[1]=\t(f2 + f4*a + f6*g + f7*(a*g));\n\tM[2]=\t(f3 + f5*a + f6*b + f7*(a*b));\n\t\n\treturn M;\n}\n\t\t\t\n//Ray Bilinear Patch Intersections\n//http://shaunramsey.com/research/bp/\n\n//control points for a patch\nvec3 P00; vec3 P01; vec3 P10; vec3 P11;\n\t\n//#define ray_epsilon 1e-12 // some small epsilon for flt pt\n#define ray_epsilon 0.00001\n\n//choose between the best denominator to avoid singularities\n//and to get the most accurate root possible\nfloat getu(float v, float M1, float M2, float J1,float J2,\n\t    float K1, float K2, float R1, float R2)\n{\n\tfloat denom = v*(M1-M2)+(J1-J2);\n\tfloat d2 = v*M1+J1;\n\tif(abs(denom) > abs(d2)) // which denominator is bigger\n\t{\n\t\treturn (v*(K2-K1)+(R2-R1))/denom;\n\t}\n\treturn -(v*K1+R1)/d2;\n}\n\n\nfloat computet(vec3 dir, vec3 orig, vec3 srfpos)\n{\n\treturn length(srfpos-orig);\n}\n\nfloat copysign(float a, float b) { return abs(a)*sign(b); }\n\nvec3 SrfEval( float u, float v)\n{\n\treturn    (1.0 - u) * (1.0 - v) * P00 + \n\t\t\t  (1.0 - u) *        v  * P01 + \n\t\t\t\t\t u  * (1.0 - v) * P10 + \n\t\t\t\t\t u  *        v  * P11;\n}\n\nvec3 BilinearPatchTanU( float v)\n{\n  return ( 1.0 - v ) * (P10 - P00) + v * (P11 - P01);\n}\n\nvec3 BilinearPatchTanV( float u)\n{\n  return ( 1.0 - u ) * (P01 - P00) + u * (P11 - P10);\n}\n\nvec3 BilinearPatchNormal( float u, float v)\n{\n\treturn cross(BilinearPatchTanU( v ),BilinearPatchTanV( u )); \n}\n\n// a x ^2 + b x + c = 0\n// in this case, the root must be between min and max\n// it returns the # of solutions found\n// x = [ -b +/- sqrt(b*b - 4 *a*c) ] / 2a\n// or x = 2c / [-b +/- sqrt(b*b-4*a*c)]\nint QuadraticRoot(float a, float b, float c, float mmin, float mmax, inout float u[2])\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return 0;\n\td=sqrt(d);\t\n\t\n\tfloat q = -0.5  * (b + copysign(d,b));\n\tu[0] = c / q;\n\tu[1] = q / a;\n\t\n\tif(    (u[0] > mmin && u[0] < mmax)\n\t   &&  (u[1] > mmin && u[1] < mmax))\n\t\treturn 2;\n\telse if(u[0] > mmin && u[0] < mmax) //then one wasn't in interval\n\t\treturn 1;\n\telse if(u[1] > mmin && u[1] < mmax)\n\t{  \n\t\t// make u[0] be the valid one always\n\t\tu[0] = u[1];\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n// intersect rays of the form p = r + t q where t is the parameter\n// to solve for. With the patch pointed to by *this\n// for valid intersections:\n// place the u,v intersection point in uv[0] and uv[1] respectively.\n// place the t value in uv[2]\n// return true to this function\n// for invalid intersections - simply return false uv values can be \n// anything\nbool RayPatchIntersection(inout vec3 uv, vec3 orig, vec3 dir)\n{\n\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Equation of the patch:\n\t// P(u, v) = (1-u)(1-v)P00 + (1-u)vP01 + u(1-v)P10 + uvP11\n\t// Equation of the ray:\n\t// R(t) = r + tq\n\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tvec3 pos1, pos2; //Vector pos = ro + t*rd;\n\tint num_sol; // number of solutions to the quadratic\n\tfloat vsol[2]; // the two roots from quadraticroot\n\tfloat t2,u; // the t values of the two roots\n\n\tvec3 a=  P11 - P10 - P01 + P00;\n\tvec3 b = P10 - P00;\t\t\n\tvec3 c = P01 - P00;\n\t\n\t// Find d w.r.t. x, y, z - subtracting r just after  \n\tvec3 d = P00-orig;\n\t\n\tfloat A1 = a.x*dir.z - a.z*dir.x;\n\tfloat A2 = a.y*dir.z - a.z*dir.y;\n\t\n\tfloat B1 = b.x*dir.z - b.z*dir.x;\n\tfloat B2 = b.y*dir.z - b.z*dir.y;\n\t\n\tfloat C1 = c.x*dir.z - c.z*dir.x;\n\tfloat C2 = c.y*dir.z - c.z*dir.y;\n\t\n\tfloat D1 = d.x*dir.z - d.z*dir.x;\n\tfloat D2 = d.y*dir.z - d.z*dir.y;\n\t\n\tfloat A = A2*C1 - A1*C2;\n\tfloat B = A2*D1 - A1*D2 + B2*C1 -B1*C2;\n\tfloat C = B2*D1 - B1*D2;\n\t\n\tuv=vec3(-2.);\n\t\n\tnum_sol = QuadraticRoot(A,B,C,-ray_epsilon,1.+ray_epsilon,vsol);\n\t\n\tif (num_sol==0) \n\t\treturn false; // no solutions found\n\n\tuv.y = vsol[0];\n\tuv.x = getu(uv.y,A2,A1,B2,B1,C2,C1,D2,D1);\n\tpos1 = SrfEval(uv.x,uv.y);\n\tuv.z = computet(dir,orig,pos1);\n\t\n\tbool valid = uv.x < 1.+ray_epsilon && uv.x > -ray_epsilon && uv.z > 0.;\n\tif (num_sol==1) \n\t{\n\t\treturn valid;\n\t}\n\n\t//num_sol==2\n\tu = getu(vsol[1],A2,A1,B2,B1,C2,C1,D2,D1);\n\tif(valid)\n\t{\n\t\tif(u < 1.+ray_epsilon && u > ray_epsilon)\n\t\t{\n\t\t\tpos2 = SrfEval(u,vsol[1]);\n\t\t\tt2 = computet(dir,orig,pos2);\n\t\t\tif(t2 < 0. || uv.z < t2) // t2 is bad or t1 is better\n\t\t\t\treturn true; \n\t\t\t// other wise both t2 > 0 and t2 < t1\n\t\t\tuv.y = vsol[1];\n\t\t\tuv.x = u;\n\t\t\tuv.z = t2;\n\t\t\treturn true;\n\t\t}\n\t\treturn true; // u2 is bad but u1 vars are still okay\n\t}\n\t\n\t// doesn't fit in the root - try other one\n\tuv.y = vsol[1];\n\tuv.x = u;\n\tpos1 = SrfEval(uv.x,uv.y);\n\tuv.z = computet(dir,orig,pos1);\n\treturn uv.x < 1.+ray_epsilon && uv.x > -ray_epsilon && uv.z > 0.;\n}\n\n//all control points of the hexahedron\nvec3 corners[8];\n\nfloat Box( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.1;\n}\n\nfloat sdf(vec3 p) {\n\tfloat d = Box(p, vec3(0.9));\n\td = max( d, -Box(p,vec3(0.5,1.0,0.5)) );\n\td = max( d, -Box(p,vec3(1.0,0.2,0.2)) );\n\td = max( d, -Box(p,vec3(0.7,0.7,1.0)) );\n\td = min( d, length(p)-0.5);\n\treturn d;\t\n}\n\n//given a world pos and start guess for the uvw, return distance & uvw result\nvec4 sdf(vec3 p, vec3 initial_guess)\t\n{\n\tp=InverseDeform(p, corners, initial_guess);\n\tfloat d = sdf(p);\t\n\treturn vec4(d,p);\n}\n\n//lerp an enter and exit UVW as the start guess for the deformed space while tracing a ray\nvec4 Trace(vec3 viewP, vec3 viewD, float start_t, float end_t,\n\t\t\tvec3 initial_guess, vec3 end_guess, out float t)\n{\n\tt = start_t;\n\n\tvec3 guess = initial_guess; \n\tfloat oo_t_range = 1.0 / (end_t-start_t);\n\t\n\tvec4 dq;\n\tfor (int i=0; i<64; i++)\n\t{\n\t\tvec3 X = viewP + viewD * t;\n\t\t\n\t\tguess = mix(initial_guess, end_guess, (t-start_t)*oo_t_range );\n\t\t\t\n\t\tdq = sdf(X, guess);\n\t\t\t\t\t\t\t\t\n\t\tif (abs(dq.x) < 0.0001) break; //near enough surface for normals to look OK.\n\t\n\t\t//attempt to correct the step size by scaling d by volume ratio\n\t\t//should probably really trace bendy rays in uvw space??\n\t//\tfloat v = det(Jacobian(corners, dq.yzw));\n\t//\tdq.x *= pow(v,1./3.);\n#if 0\t\t\n\t\tmat3 J = Jacobian(corners, dq.yzw);\n\t//\tvec3 n = normalize( viewD * J ) * dq.x;\n\t//\tvec3 N = det(J) * (inverse_transpose(J) * n);\n\t//\tdq.x = length(N) * sign(dq.x);\n\t\tfloat s0 = length(J[0]);\n\t\tfloat s1 = length(J[1]);\n\t\tfloat s2 = length(J[2]);\n\t\tfloat s = min(s0,min(s1,s2));\n\t//\tdq.x *= s/abs(det(J));\t\t\t  \n#endif\t\t\n\t\t//N = det J J^-1T n\n\t\t//n = (1/detJ) * J^T N\n#if 0\t\t\n\t\tvec3 g = viewP + viewD * (t+dq.x);\n\t\tvec4 dq2 = sdf(g, dq.yzw);\n\t\tdq = mix(dq, dq2, abs(dq2.x / dq.x));\n#endif\t\t\t\n\t\tt += dq.x; \n\t}\n\n\treturn dq;\n}\n\n\nfloat nsdf(vec3 p, vec3 guess)\n{\t\n\t//for normals, add small bump displacements\n\tfloat d = sdf(p, vec3(guess)).x;\n\t\t\t\n\treturn d;\n}\n\n\nvec3 nor(vec3 X, vec3 guess)\n{\n\tfloat e = 0.025;\n#if 0\t\n\t//one sided difference normals\n\t//add epsilions in world space and convert sample points back to sdf space x 4\n\tfloat d = nsdf(X, guess);\n\tvec3 D;\n\tD.x = nsdf(vec3(X.x+e,X.y,X.z), guess);\n\tD.y = nsdf(vec3(X.x,X.y+e,X.z), guess);\n\tD.z = nsdf(vec3(X.x,X.y,X.z+e), guess);\n\t\t\n\treturn normalize(D-vec3(d));\n#else\n\t//do differencing in SDF space\n\tfloat d = sdf(guess);\n\tvec3 D;\n\tD.x = sdf(vec3(guess.x+e,guess.y,  guess.z));\n\tD.y = sdf(vec3(guess.x,  guess.y+e,guess.z));\n\tD.z = sdf(vec3(guess.x,  guess.y,  guess.z+e));\t\n\tvec3 n = D-vec3(d);\n\t\n\t//transform from SDF space to world space:\n\tmat3 J = Jacobian(corners, guess);\n\tn = adjoint_transpose(J) * n;\n\tn = normalize(n);\n\treturn n;\n#endif\n\t\n}\n\nvoid RayVsHexhedron(\n\tout vec3 min_uvt,\n\tout vec3 max_uvt,\n\tout vec3 face_uvw,\n\tout vec3 arse_uvw,\n\t//out vec3 face_nor,\n\tvec3 viewP, vec3 viewD, vec3 corners[8])\n{\n//\tP00 = corners[4]; P01 = corners[6]; P10 = corners[5]; P11=corners[7];\t//back\n//\tP00 = corners[0]; P01 = corners[2]; P10 = corners[1]; P11=corners[3];\t//front\n//\tP00 = corners[0]; P01 = corners[4]; P10 = corners[2]; P11=corners[6];\t//front side\n//\tP00 = corners[1]; P01 = corners[5]; P10 = corners[3]; P11=corners[7];\t//side\n//\tP00 = corners[2]; P01 = corners[6]; P10 = corners[3]; P11=corners[7];\t//top\t\n//\tP00 = corners[0]; P01 = corners[4]; P10 = corners[1]; P11=corners[5];\t//bottom\n\t\n\t\n\tmin_uvt = vec3(0,0,1e10);\n\tmax_uvt = vec3(0,0,-1e10);\n\t\n//\tvec3 face_uvw = vec3(0,0,0);\n//\tvec3 face_nor = vec3(0,0,0);\n//\tface_uvw = vec3(0,0,0);\n//\tface_nor = vec3(0,0,0);\n\tvec3 uvt;\n\tP00 = corners[0]; P01 = corners[2]; P10 = corners[1]; P11=corners[3];\t//front\n\tif (RayPatchIntersection(uvt, viewP, viewD))\n\t{\n\t\tif (uvt.z < min_uvt.z)\n\t\t{\n\t\t\tmin_uvt = uvt;\n\t\t\tface_uvw = vec3(uvt.xy,0.);\n\t\t//\tface_nor = BilinearPatchNormal(uvt.x, uvt.y);\n\t\t}\n\t\tif (uvt.z > max_uvt.z)\n\t\t{\n\t\t\tmax_uvt = uvt;\n\t\t\tarse_uvw = vec3(uvt.xy,0.);\n\t\t}\n\t}\n\tP00 = corners[4]; P01 = corners[6]; P10 = corners[5]; P11=corners[7];\t//back\n\tif (RayPatchIntersection(uvt, viewP, viewD))\n\t{\n\t\tif (uvt.z < min_uvt.z)\n\t\t{\n\t\t\tmin_uvt = uvt;\n\t\t\tface_uvw = vec3(uvt.xy,1.);\n\t\t//\tface_nor = BilinearPatchNormal(uvt.x, uvt.y);\n\t\t}\n\t\tif (uvt.z > max_uvt.z)\n\t\t{\n\t\t\tmax_uvt = uvt;\n\t\t\tarse_uvw = vec3(uvt.xy,1.);\n\t\t}\t\n\t}\t\n\tP00 = corners[0]; P01 = corners[4]; P10 = corners[2]; P11=corners[6];\t//front side\n\tif (RayPatchIntersection(uvt, viewP, viewD))\n\t{\n\t\tif (uvt.z < min_uvt.z)\n\t\t{\n\t\t\tmin_uvt = uvt;\n\t\t\tface_uvw = vec3(0,uvt.xy);\n\t\t//\tface_nor = BilinearPatchNormal(uvt.x, uvt.y);\n\t\t}\n\t\tif (uvt.z > max_uvt.z)\n\t\t{\n\t\t\tmax_uvt = uvt;\n\t\t\tarse_uvw = vec3(0,uvt.xy);\n\t\t}\t\t\t\n\t}\n\tP00 = corners[1]; P01 = corners[5]; P10 = corners[3]; P11=corners[7];\t//side\n\tif (RayPatchIntersection(uvt, viewP, viewD))\n\t{\n\t\tif (uvt.z < min_uvt.z)\n\t\t{\n\t\t\tmin_uvt = uvt;\n\t\t\tface_uvw = vec3(1,uvt.xy);\n\t\t//\tface_nor = BilinearPatchNormal(uvt.x, uvt.y);\n\t\t}\n\t\tif (uvt.z > max_uvt.z)\n\t\t{\n\t\t\tmax_uvt = uvt;\n\t\t\tarse_uvw = vec3(1,uvt.xy);\n\t\t}\t\t\n\t}\n\t\n\tP00 = corners[2]; P01 = corners[6]; P10 = corners[3]; P11=corners[7];\t//top\t\n\tif (RayPatchIntersection(uvt, viewP, viewD))\n\t{\n\t\tif (uvt.z < min_uvt.z)\n\t\t{\n\t\t\tmin_uvt = uvt;\n\t\t\tface_uvw = vec3(uvt.x,1.,uvt.y);\n\t\t//\tface_nor = BilinearPatchNormal(uvt.x, uvt.y);\n\t\t}\n\t\tif (uvt.z > max_uvt.z)\n\t\t{\n\t\t\tmax_uvt = uvt;\n\t\t\tarse_uvw = vec3(uvt.x,1.,uvt.y);\n\t\t}\t\t\t\n\t}\n\tP00 = corners[0]; P01 = corners[4]; P10 = corners[1]; P11=corners[5];\t//bottom\n\tif (RayPatchIntersection(uvt, viewP, viewD))\n\t{\n\t\tif (uvt.z < min_uvt.z)\n\t\t{\n\t\t\tmin_uvt = uvt;\n\t\t\tface_uvw = vec3(uvt.x,0.,uvt.y);\n\t\t//\tface_nor = BilinearPatchNormal(uvt.x, uvt.y);\n\t\t}\n\t\tif (uvt.z > max_uvt.z)\n\t\t{\n\t\t\tmax_uvt = uvt;\n\t\t\tarse_uvw = vec3(uvt.x,0.,uvt.y);\n\t\t}\t\t\n\t}\t\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, vec2 fragCoord);\nfloat RaySphere(vec3 P, vec3 V, vec3 A, float r);\n\n\nvec3 RotZ(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\tmat3 r = mat3(c,-s,0,\n\t\t\t\t  s,c,0,\n\t\t\t\t  0,0,1);\n\treturn r * p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD,fragCoord);\n\t\t\n\tfloat t = iTime * 0.5;\n\tfloat floor_height = -2.0; \n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\n\t//point on this plane\t\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\n\tvec3 L = normalize(vec3(1,1,-1));\n\n/*\t\nx1 = x(i  ,j  ,k  )\nx2 = x(i+1,j  ,k  )\nx3 = x(i  ,j+1,k  )\nx4 = x(i+1,j+1,k  )\nx5 = x(i  ,j  ,k+1)\nx6 = x(i+1,j  ,k+1)\nx7 = x(i  ,j+1,k+1)\nx8 = x(i+1,j+1,k+1)\n*/\n\t//generate 8 control points\n\tfloat t_corner=1e10;\n\tvec3 c_corner=vec3(0);\n\tfor (int k=0; k<2; k++)\n\t{\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tfor (int i=0; i<2; i++)\n\t\t\t{\n\t\t\t\tvec3 x = vec3(i,j,k)*2.-1.;\n\t\t\t\tvec3 wiggle = texture(iChannel0,vec2(float(k*4+j*2+i)*1./iChannelResolution[0].x, 0.01*iTime)).xyz;\n\t\t\t\t\n\t\t\t\tx += (wiggle * 2.0 - 1.0);\n\t\t\t\tx += wiggle*wiggle * x;\n\t\t\t//\tx = RotZ(x,pi);\n\t\t\t\t\n\t\t\t\tcorners[k*4+j*2+i]=x;\n\t\t\t\t\n\t\t\t\tfloat t = RaySphere(viewP, viewD, x, 0.1);\n\t\t\t\tif (t > 0. && t < t_corner)\n\t\t\t\t{\n\t\t\t\t\tt_corner = t;\n\t\t\t\t\tvec3 pS = viewP+t*viewD;\n\t\t\t\t\tvec3 n = normalize(pS-x);\n\t\t\t\t\tc_corner = vec3(i,j,k) * max(dot(n,L),0.);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t}\n\t\n\t//do ray vs bilinear patch for each face to start the trace from somewhere reasonable \n\t//otherwise, trace explodes a lot, and get initial uvws\n\t\n\tvec3 face_uvw = vec3(0,0,0);\n\tvec3 arse_uvw = vec3(0,0,0);\n\tvec3 min_uvt, max_uvt;\n\tRayVsHexhedron(min_uvt, max_uvt, face_uvw, arse_uvw, viewP, viewD, corners);\t\n\t\n\t\n#if 0\n\t//distance on our test plane\n\tvec3 q=InverseDeform(p, corners, vec3(0));\n\tfloat d = sdf(q, vec3(0)).x;\n\tvec3 c = hsv2rgb(vec3(d,1.,1.));\n#endif\n\n#if 1\t\n\tvec3 c = texture(iChannel1,p.xz*0.1).xyz;\n#endif\n\n#if 0 \n\t//difference between interpolating and inverse of interpolation, or disco\n\tvec3 c = mix( face_uvw, arse_uvw, (floor_intersect_t-min_uvt.z)/(max_uvt.z-min_uvt.z));\n\tc -= InverseDeform(p, corners, c*2.-1.)*0.5+0.5;\n\tc=abs(c);\n#endif\n\t\n\tif (t_corner < floor_intersect_t)\n\t{\n\t\tc = c_corner;\n\t}\n\t\t\n\tvec3 C=vec3(0.);\n\t\n#ifdef SHADOWS\n\tvec3 sha_face_uvw = vec3(0,0,0);\n\tvec3 sha_arse_uvw = vec3(0,0,0);\n\tvec3 sha_min_uvt, sha_max_uvt;\n\tRayVsHexhedron(sha_min_uvt, sha_max_uvt, sha_face_uvw, sha_arse_uvw, p, L, corners);\t\n//\tc *= sha_min_uvt.z < 1e5 ? 0.2 : 1.;\n#endif\t\n\n\tif (min_uvt.z < 1e5)\n\t{\t\n\t\tfloat t_sdf;\n\t\tvec4 d_uvw = Trace(viewP, viewD, min_uvt.z, max_uvt.z, face_uvw*2.-1., arse_uvw*2.-1., t_sdf);\n\t\tvec3 X = viewP + t_sdf*viewD;\n\t\tif (abs(d_uvw.x)<0.01 && t_sdf < t_corner && t_sdf < floor_intersect_t)\n\t\t{\n\t\t\tvec3 guess = mix( face_uvw, arse_uvw, (t_sdf-min_uvt.z)/(max_uvt.z-min_uvt.z));\n\t\t\tvec3 n=nor(X,d_uvw.yzw); //guess*2.-1.);\n\t\t\tc = vec3(max(dot(n,L),0.)+0.1);\n\n\t\t\tvec3 uvw = d_uvw.yzw*0.5+0.5;\n\t\t\tc *=  uvw * pow(texture(iChannel2,uvw.xy).xyz * \n\t\t\t\t \t   texture(iChannel2,uvw.xz).xyz *\n\t\t\t\t \t   texture(iChannel2,uvw.yz).xyz, vec3(1./3.));\n//\t\t\tc = vec3(max(dot(n,L),0.));\n#ifdef SHADOWS\n\t\t\tp=X + n*0.001;\n\t\t\tsha_min_uvt.z = 0.;\n\t\t\tsha_face_uvw = guess;\n#endif\t\t\t\n\t\t}\n\t}\n\n#ifdef SHADOWS\n\tfloat t_sha;\n\tvec4 d_uvw = Trace(p, L, sha_min_uvt.z, sha_max_uvt.z, sha_face_uvw*2.-1., sha_arse_uvw*2.-1., t_sha);\t\n\tif (abs(d_uvw.x)<0.01)\t\t\t//acne\n\t//if (t_sha < sha_max_uvt.z)    //holes\n\t\tc *= 0.2;\n#endif\t\t\t\n\t\n#if 0\n\tif (min_uvt.z < 1e5 && min_uvt.z < t_corner)\n\t{\n\t\t//c = vec3(min_uvt.xy,0.);\n\t\tc = face_uvw;\n\t\t//c =  vec3(max(dot(normalize(-face_nor),L),0.));\n\t}\n#endif\t\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}\n\nfloat Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return -1.0;\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5/a;\n\treturn min((-b-d)*oo2a,(-b+d)*oo2a);\n}\n\nfloat RaySphere(vec3 P, vec3 V, vec3 A, float r)\n{\n\treturn Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-r*r-(2.0*(dot(A,P))));\n}\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, vec2 fragCoord)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.,0.,0.);\n\teye = vec3(-2.5,3.5+sin(iTime)*2.5,-2.5) * 2.;\n\teye = RotY(eye,iTime);\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dlGDl","date":"1381770119","viewed":996,"name":"Trilinear deform","username":"Antonalog","description":"Sphere tracing distance fields through the inverse of a trilinear deformation aka 2x2x2 FFD.  Mostly bits of code from NASA and other places, duct taped together. Turns out, it's a bit expensive.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["deform","trilinear","inverse"],"hasliked":0,"parentid":"","parentname":""}}