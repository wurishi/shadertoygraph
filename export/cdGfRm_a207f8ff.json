{"ver":"0.1","info":{"id":"cdGfRm","date":"1698029701","viewed":13,"name":"skeletonize","username":"NueSB","description":"image processing skeletonization via the zhang-suen thinning algorithm! probably some optimzations can be made","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["skeletonization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv = uv / 8.0 + vec2(0.20, 0.2);\n    vec3 color = texture(iChannel1, uv ).rgb;\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/// https://www.shadertoy.com/view/XlG3DW\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 margin = vec2(10),\n         Sres = iResolution.xy -2.*margin,\n         Tres = iChannelResolution[0].xy,\n         ratio = Sres/Tres;\n    \n    U -= margin;\n    \n    // centering the blank part in case of rectangle fit\n    U -= .5*Tres*max(vec2(ratio.x-ratio.y,ratio.y-ratio.x),0.);\n    \n  //U /= Tres*ratio.y;               // fit height, keep ratio\n  //U /= Tres*ratio.x;               // fit width, keep ratio\n    U /= Tres*min(ratio.x,ratio.y);  // fit rectangle,  keep ratio\n    U *= 1.;                         // zoom out factor \n    \n\tO = fract(U)==U \n        ? texture(iChannel0, U)\n        : O-O;\n        \n   O = vec4(1.0 - vec3(step(O.g, 0.4)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// first pass: removes corner pixels\n\n#define LEFT 6\n#define RIGHT 2\n#define UP 0\n#define DOWN 4\n#define DOWNLEFT 5\n#define UPRIGHT 1\n#define UPLEFT 7\n#define DOWNRIGHT 3\n\n#define vLEFT ivec2(-1, 0)\n#define vRIGHT ivec2(1, 0)\n#define vUP ivec2(0, 1)\n#define vDOWN ivec2(0, -1)\n#define vDOWNLEFT ivec2(-1, -1)\n#define vUPRIGHT ivec2(1, 1)\n#define vUPLEFT ivec2(-1, 1)\n#define vDOWNRIGHT ivec2(1, -1)\n\n#define isempty(x) !filledspace[x]\n#define bcheck(x,y,z) (int(filledspace[x]) * int(filledspace[y]) * int(filledspace[z]))\n\nint sum(in bool[8] bools)\n{\n    int s = 0;\n    for (int i = 0; i < 8; i++)\n    {\n        s += int(!bools[i]);\n    }\n    \n    return s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0) // draw the base image on the first frame\n    { \n        fragColor = texture(iChannel1, uv);\n        return;\n    }\n    \n    \n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb;\n    float value = color.g;\n    \n    // don't run on empty pixels\n    if (value == 0.0)\n    {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    int neighborcount = 0;\n    int siblingcount = 0;\n    bool has_empty_neighbor = false;\n    \n    ivec2[8] offsets = ivec2[8] ( vUP, vUPRIGHT, vRIGHT, vDOWNRIGHT, vDOWN, vDOWNLEFT, vLEFT, vUPLEFT );\n    \n    bool[8] filledspace = bool[8] (false, false, false, false, false, false, false, false); \n    \n    int changecount = 0;\n    int changecurrent = -1;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        int x = offsets[i].x;\n        int y = offsets[i].y;\n\n\n        // skip self-pixel check\n        if (x == 0 && y == 0) \n            continue;\n\n        ivec2 coord = ivec2(fragCoord.xy) + ivec2(x,y);\n        int v;\n\n        // texelfetch has undefined behavior out of bounds, so skip those.\n        if (coord.x < 0 || \n            coord.y < 0 || \n            coord.x > int(iChannelResolution[0].x) || \n            coord.y > int(iChannelResolution[0].y))\n        {\n            v = 0;\n        }\n\n        else v = int(texelFetch(iChannel0, coord, 0).g);\n        \n        if (changecurrent == 0 && v != changecurrent)\n        {\n            changecount++;\n        }\n        changecurrent = v;\n\n        filledspace[i] = v != 0;\n        if (!filledspace[i])\n        {\n            neighborcount++;\n        }\n    }\n    \n    // the zhang-suen thinning algorithm thins an image\n    // if it fits these five criteria:\n    \n    //    1: the pixel is 1 and has eight neighbors \n    //       [basically, if it's a solid pixel and in the bounds of the image.]\n    \n    //    2: 2 <= sum(3x3 region around pixel) <= 6\n    //\n    //    3: A(P1) = 1\n    //\n    //    4: P2 * P4 * P6 = 0\n    //    5: P4 * P6 * P8 = 0\n    //\n    //   the Ps are referring to a grid laid out like this:\n    //  \n    //   P9 | P2 | P3\n    //   ------------\n    //   P8 | P1 | P4    where P1 is the pixel currently being processed.\n    //   ------------\n    //   P7 | P6 | P5\n    //\n    //  it's a 2 step process. on the second step, condition 4 and 5 change:\n    //  \n    //    4: P2 * P4 * P8 = 0\n    //    5: P2 * P6 * P8 = 0\n    \n    // A(P1): amt of transitions from black to white.\n    // this is changecount. the sweep is circular, so we add the first coord again...\n    if (changecurrent == 0 && filledspace[UP]) \n        changecount++;\n    \n    \n    bool erase = true;\n    \n    //erase = erase && neighborcount == 8;\n    erase = erase && sum(filledspace) >= 2 && sum(filledspace) <= 6;\n    erase = erase && changecount == 1;\n    if (iFrame % 2 != 0)\n    {\n        erase = erase && bcheck(UP, RIGHT, DOWN) == 0;\n        erase = erase && bcheck(RIGHT, DOWN, LEFT) == 0;\n    } else {\n        erase = erase && bcheck(UP, RIGHT, LEFT) == 0;\n        erase = erase && bcheck(UP, DOWN, LEFT) == 0;\n    }\n    \n    if (erase)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n        \n    fragColor = texture(iChannel0, uv);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}