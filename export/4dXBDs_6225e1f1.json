{"ver":"0.1","info":{"id":"4dXBDs","date":"1498724870","viewed":150,"name":"Mandelbrot Quaternion Extension","username":"Yevano","description":"Raymarched 3D slice of the mandelbrot set extended simply into the quaternions.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","raymarched","mandelbrot","quaternion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R_ITER 400.0\n#define M_ITER 70.0\n#define PI 3.14159265359\n\nconst vec4 bgColor = vec4(0.7, 1.0, 3.0, 1.0);\n\nfloat distSphere(vec3 v, float r) {\n    return length(v) - r;\n}\n\nvec4 iterate(vec4 z, vec4 c) {\n    // fn(c) = fn-1(c)^2 + c\n    return vec4(\n        z.x*z.x - z.y*z.y - z.z*z.z - z.w*z.w,\n        2.0 * z.x * z.y,\n    \t2.0 * z.x * z.z,\n    \t2.0 * z.x * z.w) + c;\n}\n\nvec4 iterateDerivative(vec4 d, vec4 z) {\n    //     fn'(c) = 2 * fn-1(c) * fn-1'(c) + 1 where z := fn-1(c), d := fn-1'(c)\n    // <=> fn'(c) = 2 * z * d + 1 \t\t\t   where Re(z), Im(z), J(z), K(z) = a, bi, cj, dk and\n    //\t\t\t\t\t\t\t\t\t\t   \t\t Re(d), Im(d), J(d), K(d) = l, mi, nj, ok\n    vec4 ret = 2.0 * vec4(\n    \tz.x*d.x - z.y*d.y - z.z*d.z - z.w*d.w,\n    \tz.x*d.y + z.y*d.x + z.z*d.w - z.w*d.z,\n    \tz.x*d.z - z.y*d.w + z.z*d.x + z.w*d.y,\n    \tz.x*d.w + z.y*d.z - z.z*d.y + z.w*d.x);\n    ret.x += 1.0;\n    return ret;\n}\n\nmat2 getRotMat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= iResolution.x/iResolution.y/2.0;\n    uv.y -= 0.5;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 p = ro;\n    vec3 pc = vec3(0.0);\n    float minFieldDist = 999999.0;\n    float bestRayDist = 0.0;\n    \n    float zl = 0.0;\n    \n    float i = 0.0;\n    \n    float cc = 0.0;\n    \n    for(float it = 0.0; it < R_ITER; it++) {\n        pc = p;\n        pc.xz *= getRotMat(-iMouse.x/iResolution.x*PI*4.0);\n        pc.xy *= getRotMat( iMouse.y/iResolution.y*PI*4.0);\n        vec4 z = vec4(0.0);\n        vec4 c = vec4(pc, 0.0);\n        vec4 d = vec4(0.0);\n        vec4 dz = vec4(0.0);\n        float m2 = 0.0;\n        zl = 0.0;\n        float dl = 0.0;\n        \n        for(i = 0.0; i < M_ITER && length(z) < 2.0; i++) {\n            dz = 2.0*z*dz + 1.0;\n            vec4 q = iterate(z, c);\n            vec4 r = iterateDerivative(d, z);\n            zl += length(z - q);\n            dl += length(d - r);\n            z = q;\n            d = r;\n        }\n\n        float dist = zl/dl*0.5*log(zl);\n        \n        float rdist = length(p - ro);\n        \n        if(rdist > 6.0) {\n            fragColor = bgColor;\n            break;\n        }\n        \n        if(dist < minFieldDist) {\n            minFieldDist = dist;\n            bestRayDist = rdist;\n        }\n        \n        if(dist < 0.01) {\n            vec3 pcs = pc * 20.0;\n            cc = length(pc.yz)*((sin(iTime)+1.0)*0.25+0.5);\n            fragColor = vec4(cc, 0.0, 0.2, 1.0);\n            return;\n        }\n        \n        p += rd * dist/16.0;\n    }\n    \n    fragColor = bgColor;\n    float threshold = 0.05;\n    if(minFieldDist < threshold) {\n        vec4 col = vec4(cc, 0.0, 0.2, 1.0);\n        fragColor = mix(fragColor, col, 1.0-minFieldDist/threshold);\n    }\n}","name":"Image","description":"","type":"image"}]}