{"ver":"0.1","info":{"id":"3lyGWV","date":"1579828757","viewed":289,"name":"Blue spheres 1","username":"valsag","description":"And old shader I did just for fun a while ago. Decided to clean it up a bit and shared. Still far from optimal and has some lighting artifacts, but it looks pretty cool. Nothing special on the technical end, just the usual stuff.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sphere","sonic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO (min(iFrame,0))\n#define PI 3.1415926535898\n#define FAR 12.\n#define bg_color vec3(0.02,0.15,0.5)\n#define bg_color2 vec3(0.2,0.35,0.5)\n\nfloat camYaw;\nvec3 camPos;\nvec2 global_uv;\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p )\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec3 get_background( vec3 pos )\n{\n    return mix( bg_color2, bg_color, global_uv.y * 2. + 0.5 );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 distortPos(in vec3 pos)\n{\n    vec3 p = pos;\n    float xx = (p - camPos).x;\n    float zz = (p - camPos).z;\n    float xxx = -(cos(camYaw)*zz-sin(camYaw)*xx);\n    float zzz = -(cos(camYaw)*xx+sin(camYaw)*zz);\n    float cx = cos(xxx * 0.3 ) * 1.1;\n    if (cx < 0.0) cx *= 2.0;\n    float cz = cos((zzz + 3.0)* 0.3 ) * 1.1;\n    if (cz < 0.0) cz *= 1.5;\n    p.y -= cx + cz;\n    return p;\n}\n\nvec2 map(vec3 pos)\n{\n    vec3 p = distortPos(pos);\n    vec2 res;\n\n    res.x = FAR; // distance\n    res.y = 0.0; // material id\n\n    // floor plane\n    if(p.y > 0.0) res = vec2(min(FAR, p.y), 1.);\n\n    vec3 sPos;\n    // blue spheres\n    sPos.x = mod(p.x - 0.5, 2.0) -0.5;\n    sPos.y = p.y - 0.15;\n    sPos.z = mod(p.z - 0.5, 4.0) - 0.5;\n    float d2 = sdSphere(sPos, 0.15);\n    if (d2 < res.x) res = vec2(d2, 3.0);\n\n    // red spheres\n    sPos.x = mod(p.x - 1.5, 4.0) -0.5;\n    sPos.z = mod(p.z - 1.5, 1.0) - 0.5;\n    float d3 = sdSphere(sPos, 0.15);\n    if (d3 < res.x) res =vec2(d3, 4.0);\n\n    // white spheres\n    sPos.x = mod(p.x - 0.5, 2.0) -0.5;\n    sPos.z = mod(p.z - 1.5, 2.0) - 0.5;\n    float d4 = sdSphere(sPos, 0.15);\n    if (d4 < res.x) res = vec2(d4, 5.0);\n\n    return res;\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.0001, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x,\n                          map(p + e.yxy).x-map(p - e.yxy).x,\n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.0; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    float t = 0.0, dt;\n    vec2 r;\n    for(int i=0; i<128; i++){\n        r = map(ro + rd * t);\n        dt = r.x;\n        if(dt<0.002 || t>FAR){ break; }\n        t += dt * 0.8;\n    }\n    return vec2(t,r.y);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 star2d(in vec3 pos)\n{\n    // adapted from: http://pryme8.com/tag/glsl/\n    vec3 c = vec3(1.5,1.5,1.5);\n    vec2 offsetFix = vec2(1.,0.83);\n    float ss, tt, angle, r, a;\n    float starAngle = 2.*PI/5.;\n    vec3 p0 = 0.14*vec3(cos(0.),sin(0.), 0.);\n    vec3 p1 = 0.06*vec3(cos(starAngle/2.),sin(starAngle/2.), 0.);\n    vec3 d0 = p1 - p0;\n    vec3 d1;\n    vec3 p = distortPos(pos);\n    ss = mod(p.x,2.0) - offsetFix.x;\n    tt = (1. - mod(p.y,2.0)) - offsetFix.y;\n    angle = atan(ss, tt) + PI;\n    r = sqrt(ss*ss + tt*tt);\n    a = mod(angle, starAngle)/starAngle;\n    if (a >= 0.5){a = 1.0 - a;}\n    d1 = r*vec3(cos(a), sin(a), 0.) - p0;\n    float in_out = smoothstep(0., 0.001, cross(d0 , d1).z);\n    return mix(vec3(1.5), vec3(1.,0.,0.0), in_out); ;\n}\n\nvec3 lighting(vec3 rd, vec3 ro, vec3 pos, vec3 n, float matid)\n{\n    if ( matid < 1.0 ){\n        return get_background( pos );\n    }\n\n    float z = length(pos - ro);\n\n    vec3 mate = vec3(1.0);\n\n    float spe_factor = 3.0;\n    float fog_factor = 0.005;\n    float black_rim_factor = 1.0;\n\n    if (matid < 1.9)\n    {\n        mate = vec3(1.0,0.5,0.1) * (vec3(0.4) + vec3(checkersGradBox( vec2(pos.x, pos.z) ) ));\n        spe_factor = 0.05;\n        fog_factor = 0.002;\n        black_rim_factor = 0.0;\n    }\n    else if (matid < 3.9)\n    {\n        // blue spheres\n        mate = vec3(0.05,0.3,0.9);\n    }\n    else if (matid < 4.9){\n        // red spheres\n        mate = vec3(1.0,0.05,0.0);\n    }\n    else if (matid < 5.9)\n    {\n        // white spheres\n        mate = star2d(pos);\n    }\n\n    vec3 lp0 = camPos +  vec3(0.0, 1.0, -1.0);\n    vec3 ld0 = normalize(lp0 - pos);\n    float dif = max(0.0, dot(n, ld0));\n    vec3 lin = vec3(1.0);\n    float spe = max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 20.0));\n    float ao = get_ao(pos, n);\n    lin = 10.0 * vec3(1.0) * spe * spe_factor;\n    lin += (1.0 + dif) * ao;\n    lin = lin * 0.22 * mate;\n    vec3  lig = normalize( vec3(0.0, 1.0, 0.0) );\n    lin *= vec3(0.5) + calcSoftshadow( pos, lig,  0.05, 1.0 );\n    // extra black rim to mimic original game spheres shade\n    float black_rim = max(dot(n,-rd),0.);\n    black_rim += max(dot(n,vec3(0.,1.,0.)),0.);\n    black_rim *= black_rim;\n    black_rim = smoothstep(0.,0.6,black_rim);\n    lin = mix( lin, lin * (0.25+0.75*black_rim), black_rim_factor);\n    // fog\n    lin = mix( lin, get_background(pos), 1.-exp(-fog_factor*z*z));\n\n    return lin;\n}\n\nvec3 shade(vec3 ro, vec3 rd)\n{\n    vec3 col = get_background(camPos);\n    vec2 res = intersect(ro, rd);\n    if(res.x < FAR)\n    {\n        vec3 pos = ro + rd * res.x;\n        vec3 n = get_normal(pos);\n        col = lighting(rd,ro, pos, n, res.y);\n    }\n    return col;\n}\n\nvoid updateCamera( in vec2 fragCoord, out vec3 rayOrigin, out vec3 rayDirection )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5)/ iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    global_uv = uv;\n    float velocity = 1.25;\n\n    float t = iTime;\n\n    float xpos = 0.0;\n    xpos = sin(t * 0.5)*cos(t * 0.25) * 4.0;\n\n    float phase = t * 0.1;\n    vec3 ro = vec3(xpos, 3.25+0.75*cos(phase)*cos(phase), -t * velocity);\n    vec3 ta = ro + vec3( sin(phase), 0.85 - 0.25*sin(phase)*sin(phase) , cos(phase)*cos(phase));\n\n    float FOV = 1.0;\n    vec3 fwd = normalize(ro - ta);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt);\n    vec3 rd = fwd + FOV*(uv.x*rgt + uv.y*up);\n    camYaw = atan( fwd.z, fwd.x );\n    rd = normalize(rd);\n\n    rayOrigin = ro;\n    rayDirection = normalize(rd);\n\n    camPos = ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro, rd;\n    updateCamera( fragCoord, ro, rd );\n    vec3 col = shade(ro, rd);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}