{"ver":"0.1","info":{"id":"tlfSzB","date":"1563366740","viewed":117,"name":"Menger Sponge Saturnus","username":"96logda","description":"Converted my Menger Sponge Saturnus from glslsandbox to shadertoy.\nThe smooth outer ring is a regular torus not effected by Menger Sponge.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere","mengersponge","saturnus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-07-14 - 2019-07-17 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n//Based on https://iquilezles.org/articles/menger\n\n//Copyright (c) 2019-07-14 by Angelo Logahd\n//My orginal version: \n//http://glslsandbox.com/e#56115.1\n\n// 2019-10-12: Improved the effect with starts.\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define SOFT_SHADOW_STEPS 32\n\n\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdTorus(vec3 p, float torusRadius, float ringRadius)\n{\n    return length(vec2(length(p.xz) - torusRadius, p.y)) - ringRadius;\n}\n\nfloat starHash(float n) \n{\n    return fract((1.0 + cos(n)) * 15.92653) * 1.35;\n}\n\nvec3 starSky(in vec2 uv) \n{\n    vec2 p = uv * 0.125; // Multiply with some small value to avoid flickering.\n    float starValue = fract(starHash(p.x * 37.0) + starHash(p.y * 80.0));\n    if (starValue > 0.98) \n    {\n        return vec3(pow((starValue - 0.98) / 0.02, 25.0));\n    }  \n    return vec3(0.0);\n}\n\nvec4 map(in vec3 p)\n{\n    float d = sdSphere(p, 1.0);\n    d = min(d, sdTorus(p - vec3(0.0, 0.25, 0.0), 1.5, 0.25));\n    vec4 res = vec4(d, 1.0, 0.0, 0.0);\n    res.x = min(res.x, sdTorus(p - vec3(0.0, 0.35, 0.0), 1.8, 0.15));\n\t\n    float s = 1.0;\n    for(int m = 0; m < 2; ++m)\n    {\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 8.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db,dc)) - 1.0) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 0.0);\n        }\n    }\n\t\n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for( int i=0; i < 64; ++i)\n    {\n\t\tif( h.x < 0.002 || t > 10.0) \n\t\t{\n\t    \tbreak;\n\t\t}\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if(t > 10.0) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; i++)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, k * h / t);\n        if(res < 0.201)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nvec3 render(in vec2 coord, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec4 res = intersect(ro,rd);\n    if(res.y > 0.0)\n    {\n        const vec3 light = vec3(0.25, 0.5, -0.5);\n        \n\t\tvec3 pos = ro + res.x * rd;\n\t\n        vec3 baseColor = vec3(0.8, 0.2, 0.0);\n\t\tvec3 ambient = vec3(0.2) * baseColor;\t\t\n\t\tvec3 normal = calcNormal(pos);\n\t\tvec3 reflection = reflect(rd, normal);\n\t\n\t\tfloat occ = res.y;\n\t\tfloat shadow = softshadow(pos + 0.001 * normal, light, 32.0);\n\t\n\t\tvec3 diffuse = baseColor * shadow * occ;\n\t\tcolor = (diffuse + ambient) * 0.4;\t\t\n\t\tcolor += 0.2 * smoothstep(0.0, 0.7, reflection.y) * softshadow(pos + 0.01 * normal, reflection, 2.0);\n    }\n    else\n    {\n        color = starSky(coord);\n        color *= vec3(sin(coord.x * coord.y), 1.0, 1.0);\n    }\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n    vec3 ro = vec3(2.5, 3.0, -5.0);\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    vec3 color = render(p, ro, rd);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}