{"ver":"0.1","info":{"id":"cdBXDy","date":"1670791914","viewed":220,"name":"Mandelbrot's Abyss (parallax)","username":"1ucasvb","description":"An intuitive picture of the Mandelbrot Set I just realized: you can see it as an abyss. Each iteration defines a \"level\" with a \"hole\", and the points in the set are the ones which fall forever. So I had to make a visualization!","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","parallax","mandelbrotset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FREQUENCY_XY          0.2\n#define FREQUENCY_Z           0.04\n#define AMPLITUDE_X           2.0\n#define AMPLITUDE_Y           2.0\n#define AMPLITUDE_XY_SCALE    0.15\n#define AMPLITUDE_Z           1.5\n\n// Norm to use for divergence\n// P = 2.0 is the typical \"smooth\" version\n// P = 1.0 is lumpy, which looks cooler\n//     but it's maybe not strictly correct!\n#define P                     1.0\n#define THRESHOLD             2.0\n\n#define TAU 6.28318530718\n#define DEPTH 50\n\n// Allow for mouse to change XY camera position\n#define INTERACTIVE 0\n\n// --------------------------------------------------------\n// Some stuff copied from elsewhere\n\n// \"Will it blend\" by nmz\n// https://www.shadertoy.com/view/lsdGzN\nvec3 hsv2rgb( in float h, in float s, in float v ) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn v * mix( vec3(1.0), rgb, s);\n}\n\n// \"matplotlib colormaps\" by mattz\n// https://www.shadertoy.com/view/WlfXRN\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n\n// \"complex exponentiation\" by stduhpf\n// https://www.shadertoy.com/view/MdKBWd\nvec2 toPol(vec2 a){\n    return vec2(length(a),atan(a.y,a.x));\n}\nvec2 toAlg(vec2 a){\n    return a.x*vec2(cos(a.y),sin(a.y));\n}\n\nvec2 cpow(vec2 a, vec2 b){\n \ta = toPol(a);\n    return toAlg(vec2(pow(a.x,b.x)*exp(-b.y*a.y),b.y*log(a.x)+b.x*a.y));\n}\n\n// --------------------------------------------------------\n// Original stuff from here on\nvec2 cmult(vec2 z1, vec2 z2) {\n    return vec2(\n        z1.x*z2.x - z1.y*z2.y,\n        z1.x*z2.y + z1.y*z2.x\n    );\n}\nvec2 rot(float ang) {\n    return vec2(cos(ang), sin(ang));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = (uv.x - 0.5) * iResolution.x / iResolution.y + 0.5;\n    \n    vec3 cam;\n    // float P = 1.0 + (1.0 + tanh(20.0*sin(iTime * TAU * FREQUENCY_Z * 2.0)))/2.0;\n    \n    #if (INTERACTIVE == 0)\n    cam = vec3(\n        rot(TAU * FREQUENCY_XY * iTime) * AMPLITUDE_XY_SCALE * vec2(AMPLITUDE_X, AMPLITUDE_Y),\n        1.0 + AMPLITUDE_Z*pow(sin(TAU * FREQUENCY_Z * iTime), 2.0)\n    );\n    #else\n    cam = vec3(\n        -(iMouse.xy / iResolution.xy - 0.5)*10.0*AMPLITUDE_XY_SCALE,\n        1.0 + AMPLITUDE_Z*pow(sin(TAU * FREQUENCY_Z * iTime), 2.0)\n    );\n    #endif\n    \n    vec2 z0, z1, lz1;\n    float l;\n    vec3 col;\n    bool hit = false;\n\n    for (int layer = 0; layer <= DEPTH; layer++) { \n        z0 = (uv - 0.5) * 2.0 * 1.5 * (1.0 / cam.z) + cam.xy / (1.0 + 1.0*float(layer));\n        z0.x -= 0.5;\n        z0.y -= 0.0;\n        z1 = z0;\n        lz1 = vec2(0.0, 0.0);\n        col = vec3(0.0, 0.0, 0.0);\n        l = 0.0 - 0.5*(cam.z - 1.0);\n        \n        // Skip computation inside main cardioid and bulb\n        //   https://iquilezles.org/articles/mset1bulb\n        //   https://iquilezles.org/articles/mset2bulb\n        float z2 = dot(z1, z1);\n        if( 256.0*z2*z2 - 96.0*z2 + 32.0*z1.x - 3.0 < 0.0 ) continue;\n        if( 16.0*(z2+2.0*z1.x+1.0) - 1.0 < 0.0 ) continue;\n        \n        float p = THRESHOLD;\n        for (int i = 0; i <= layer; i++) {\n            // use L2 norm on first layer to avoid covering the main bulb spikes\n            p = i == 0 ? THRESHOLD : 1.0; \n            z1 = cpow(z1, vec2(2.0, 0.0)) + z0;\n            l += pow(cam.z, 0.5)*length(z1 - lz1);\n            //#if LUMPY\n            //if (i == layer && length(z1) >= 2.0) {\n            if (i == layer && (pow(abs(z1.x), p) + pow(abs(z1.y),p)) >= pow(THRESHOLD, p)) {\n                // Color by length using Viridis\n                l += pow(float(layer), 1.0);\n                col = exp(-l*0.05)*viridis(pow(log(1.0 + 1.5/l), 0.8));\n                // Color by length using grayscale\n                //col = exp(-l*0.1) * vec3(1.0, 1.0, 1.0);\n                hit = true;\n                break;\n            }\n            lz1 = z1;\n        }\n        if (hit) break;\n    }\n    \n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}