{"ver":"0.1","info":{"id":"wtGBRK","date":"1614654246","viewed":117,"name":"fuzzy box","username":"ear7h","description":"A depth of field effect with raymarching. Click and drag to change some parameters.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n\nfloat ball(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nfloat box(vec3 p, float n) {\n    p = erot(p, vec3(1., 0., 0.), 0.1);\n    //n = n * .5;\n    vec3 d = abs(p) - vec3(n);\n    float i = min(max(d.x, max(d.y, d.z)), 0.0);\n    float o = length(max(d, 0.0));\n    return i + o;\n}\nfloat scene(vec3 p) {\n    return min(ball(p, 1.), box(p, .73));\n    \n}\n\nfloat raymarch(vec3 camera, vec3 ray) {\n    float depth = MIN_DIST;\n    \n    for (int i = 0; i < 255; i++) {\n        float dist = scene(camera + ray * depth);\n        if (dist < 0.0001) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n\n    return MAX_DIST;\n}\n\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[1])));\n}\n\n\n\nuint xorshift(uint x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nfloat rand(vec2 fragCoord) {\n    uint seed = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x);\n    uint x = xorshift(seed * uint(iTime * 100.) );\n    for (int i = 0; i < 3; i++) {\n        x = xorshift(x);\n    }\n    float xf = float(x) / float(uint(0xffffffff));\n    return xf;\n}\n\n\nvec3 rand3(vec2 fragCoord, int n) {\n    uint seed = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x);\n    uint x = xorshift(seed * uint(iTime * 1000.) *uint(n));\n    for (int i = 0; i < 4; i++) {\n        x = xorshift(x);\n    }\n    float f1 = float(x) / float(uint(0xffffffff)) - .5;\n    x = xorshift(x);\n    float f2 = float(x) / float(uint(0xffffffff)) - .5;\n    x = xorshift(x);\n    float f3 = float(x) / float(uint(0xffffffff)) - .5;\n    x = xorshift(x);\n    float f4 = float(x) / float(uint(0xffffffff)) - .5;\n    \n    \n    return normalize(vec3(f1, f2, f3)) * f4;\n}\n\nfloat rat(float mini, float maxi, float val) {\n    return (max(mini, min(maxi, val)) - mini) / (maxi - mini);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 uv = (fragCoord-iResolution.xy * .5)/iResolution.y;\n    vec3 cam = normalize(vec3(1, uv));\n    vec3 init = vec3(-3., 0., 0.);\n    \n    float zrot = iTime/1.5;\n    float yrot = 0.5;\n    \n    cam = erot(cam, vec3(0, 1, 0), yrot);\n    init = erot(init, vec3(0, 1, 0), yrot);\n    cam = erot(cam, vec3(0, 0, 1), zrot);\n    init = erot(init, vec3(0, 0, 1), zrot);\n\n    float depth = iMouse.y/iResolution.y * 5.;\n    float mousex = iMouse.x/iResolution.x;\n    \n    if (iMouse.xy == vec2(0.)) {\n        depth = (sin(iTime) + 1.) * 2.5;\n        mousex = (sin(0.5 * iTime) + 1.) * .5;\n    }\n    \n    vec3 p = init;\n    bool hit = false;\n    \n    fragColor = vec4(vec3(0.), 1.);\n \n #define PASSES 30\n \n    for (int j = 1; j <= PASSES; j++) {\n        for (int i = 0; i < 150 && !hit; i++) {\n            float r = pow(.2  * abs(depth - distance(p, init)), mousex);\n            vec3 p1 = r * rand3(fragCoord, j) + p;\n            float dist = scene(p1);\n            if (dist * dist < 1e-6) {\n                fragColor += (1./float(PASSES)) * vec4(norm(p1) * .5 + .5, 1.);\n                break;\n            }\n            p += cam*dist;\n            if (distance(p, init) > 20.) {\n                break;\n            }\n        }\n    }\n    \n    fragColor = sqrt(fragColor);\n}","name":"Image","description":"","type":"image"}]}