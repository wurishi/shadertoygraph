{"ver":"0.1","info":{"id":"tsXBzs","date":"1588868175","viewed":418,"name":"Cubeworld","username":"mla","description":"A World consisting of a single cube. Looking or moving out through the cube walls just comes back to the cube through a different wall. The grey sphere is you.","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["manifold","cubeworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Cubeworld\n// Matthew Arcus, mla, 2020\n//\n// The entire world consists of a single cube, each wall of the cube is just a\n// passage back into the cube, through a different wall.\n//\n// Mouse to look around. Haven't worked out the details of doing lighting yet,\n// so just uses fogging to indicate distance.\n//\n// Came out of thinking about tmst's excellent \"Non-Euclidean World\":\n// https://www.shadertoy.com/view/WsXcWn\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\nfloat AA = 2.0;\nfloat maxdist = 15.0;\nint maxiterations = 30;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat stepsize(vec3 p, vec3 r) {\n  // Want least k such that p + kr has coordinate 1 in some dimension\n  // eg. p.x+kr.x = 1 => k = (1-p.x)/r.x\n  // eg. p.x+kr.x = 0 => k = -p.x/r.x\n  // Want k positive, so assuming p.x is 0 < p.x < 1, depends on r.\n  float k = 1e8;\n  if (r.x > 0.0) k = (1.0-p.x)/r.x;\n  else if (r.x < 0.0) k = min(k,-p.x/r.x);\n  if (r.y > 0.0) k = min(k,(1.0-p.y)/r.y);\n  else if (r.y < 0.0) k = min(k,-p.y/r.y);\n  if (r.z > 0.0) k = min(k,(1.0-p.z)/r.z);\n  else if (r.z < 0.0) k = min(k,-p.z/r.z);\n  return k; // What if we cross 2 boundaries?\n}\n\nint gethitside(vec3 p) {\n  if (p.x > 1.0) return 0;\n  if (p.x < 0.0) return 1;\n  if (p.y > 1.0) return 2;\n  if (p.y < 0.0) return 3;\n  if (p.z > 1.0) return 4;\n  if (p.z < 0.0) return 5;\n  return -1;\n}\n\nvoid nextdir(int hitside, inout vec3 r) {\n  if (hitside == 0) { r.yz = vec2(r.z,-r.y); r.xz = r.zx; } // Reflection in x=y\n  if (hitside == 1) { r.yz = vec2(r.z,-r.y); r.xz = vec2(-r.z,r.x); } // Rotation by 90 deg\n  if (hitside == 4) { r.xz = vec2(r.z,-r.x); r.yz = vec2(-r.z,r.y); } // Opposite rotation by 90 deg\n  if (hitside == 5) { r.xz = r.zx; r.yz = vec2(-r.z,r.y); } // Reflection in x=y\n}\n\nvoid nextpos(int hitside, inout vec3 p) {\n  if (hitside == 0) p.x -= 1.0;\n  if (hitside == 1) p.x += 1.0;\n  if (hitside == 2) p.y -= 1.0;\n  if (hitside == 3) p.y += 1.0;\n  if (hitside == 4) p.z -= 1.0;\n  if (hitside == 5) p.z += 1.0;\n  if (hitside == 0) { p.yz = vec2(p.z,1.0-p.y); p.xz = p.zx; } // Reflection in x=y\n  if (hitside == 1) { p.yz = vec2(p.z,1.0-p.y); p.xz = vec2(1.0-p.z,p.x); } // Rotation by 90 deg\n  if (hitside == 4) { p.xz = vec2(p.z,1.0-p.x); p.yz = vec2(1.0-p.z,p.y); } // Opposite rotation by 90 deg\n  if (hitside == 5) { p.xz = p.zx; p.yz = vec2(1.0-p.z,p.y); } // Reflection in x=y\n}\n\nbool traceray(inout vec3 p, inout vec3 r, out vec3 n, out int type, out float totaldist) {\n  totaldist = 0.0;\n  vec3 p0 = p;\n  for (int i = 0; i < maxiterations; i++) {\n    if (i > 0) {\n      // find intersection with sphere at p0\n      vec3 q = p-p0;\n      //(q+kr).(q+kr) = r2\n      float A = dot(r,r);\n      float B = dot(q,r);\n      float r = 0.05;\n      float r2 = r*r;\n      float C = dot(q,q)-r2;\n      float D = B*B-A*C;\n      if (D >= 0.0) {\n        float t = (-B-sqrt(D))/A;\n        totaldist += t;\n        n = q+t*r;\n        type = 6;\n        return true;\n      }\n    }\n    float eps = 1e-3;\n    float k = stepsize(p,r)+eps;\n    p += k*r;\n    totaldist += k;\n    if (totaldist > maxdist) return false;\n    // determine the hit side\n    int hitside = gethitside(p);\n    type = hitside;\n    vec3 border = min(p,1.0-p);\n    // Have we hit the wall frames?\n    if (hitside/2 == 0 && min(border.y,border.z) < 0.05) { n = vec3(1,0,0); return true; }\n    if (hitside/2 == 1 && min(border.z,border.x) < 0.05) { n = vec3(0,1,0); return true; }\n    if (hitside/2 == 2 && min(border.x,border.y) < 0.05) { n = vec3(0,0,1); return true; }\n    // Advance p and r\n    nextpos(hitside,p);\n    nextdir(hitside,r);\n  }\n  return false;\n}\n\nvoid moveforward(inout vec3 p, inout vec3 r, vec3 dir, float t) {\n  for (int i = 0; i < 50; i++) {\n    float k = stepsize(p,dir) ;\n    float eps = 1e-3;\n    if (t <= k) break;\n    k += eps;\n    p += k*dir;\n    t -= k;\n    int hitside = gethitside(p);\n    nextpos(hitside,p);\n    nextdir(hitside,dir);\n    nextdir(hitside,r);\n  }\n  p += t*dir;\n}\n\nvec3 getcolor(int type) {\n  if (type == 0) return vec3(1,0,0);\n  if (type == 1) return vec3(0,1,0);\n  if (type == 2) return vec3(0,0,1);\n  if (type == 3) return vec3(1,1,0);\n  if (type == 4) return vec3(1,0,1);\n  if (type == 5) return vec3(0,1,1);\n  return vec3(0.2);\n}\n\nvec3 raycolor(vec3 p, vec3 r) {\n    int type; vec3 n; float totaldist;\n    vec3 bgcol = vec3(1,1,0.5);\n    //vec3 bgcol = vec3(1);\n    if (!traceray(p,r,n,type,totaldist)) return bgcol;\n    vec3 basecolor = getcolor(type);\n    vec3 color = basecolor;\n    color *= 0.5;\n    color = mix(color,bgcol,totaldist/maxdist);\n    return color;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (false) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,2);\n      vec3 p = vec3(0.5);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      moveforward(p,r,vec3(0,0,1),mod(0.2*iTime,4.0));\n      vec3 c = raycolor(p,r);\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}