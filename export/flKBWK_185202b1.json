{"ver":"0.1","info":{"id":"flKBWK","date":"1665251753","viewed":84,"name":"Learning 1-1","username":"travertexs","description":"Learning 1-1\nA bouncing sphere with simple lighting.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat Map(in vec3 pos)\n{\n    // Add some bouncing animation to the sphere.\n    vec3 sphere_pos_offset   = vec3(0.0, sin(iTime * 10.0), 0.0);\n         sphere_pos_offset.y = abs(sphere_pos_offset.y);\n         sphere_pos_offset.y = pow(sphere_pos_offset.y, 0.75) * 0.125;\n    \n    float d1 = length(pos - sphere_pos_offset) - 0.25;    // Sphere\n    float d2 = pos.y - (-0.25);                           // Ground\n    \n    return min(d1, d2);\n}\n\nvec3 CalcNorm(in vec3 pos)\n{\n    vec2 offset = vec2(0.0001, 0.0);\n\n    return normalize(\n        vec3(\n            Map(pos + offset.xyy) - Map(pos - offset.xyy),\n            Map(pos + offset.yxy) - Map(pos - offset.yxy),\n            Map(pos + offset.yyx) - Map(pos - offset.yyx)\n        )\n    );\n}\n\nfloat CastRay(in vec3 ray_orig, in vec3 ray_dir)\n{\n    float dist;\n    float ray_length;\n\n    for(ray_length = 0.0; ray_length <= 20.0; ray_length += dist)\n    {\n        vec3 samp_pos = ray_orig + ray_dir * ray_length;\n        \n        dist = Map(samp_pos);\n        \n        // If the distance between the sample point and\n        //  the surface is smaller than a specified\n        //  amount, then assume the ray hits the surface.\n        if(dist < 0.001)\n        {\n            break;\n        }\n    }\n\n    // If the ray length is too big,\n    //  then assume the ray hits the sky.\n    if(ray_length > 20.0)\n    {\n        ray_length = -1.0;\n    }\n\n    return ray_length;\n}\n\nfloat GetSoftShadows(\n    in vec3 ray_orig,\n    in vec3 ray_dir,\n    in float hardness)\n{\n    float map_dist;\n    float ray_length;\n    float ph = 1.0e20;\n    float shadow = 1.0;\n    \n    for(ray_length = 0.0; ray_length <= 20.0; ray_length += map_dist)\n    {\n        vec3 samp_pos = ray_orig + ray_dir * ray_length;\n        \n        map_dist = Map(samp_pos);\n\n        // If the distance between the sample point and\n        //  the surface is smaller than a specified\n        //  amount, then assume the ray hits the surface.\n        if(map_dist < 0.001)\n        {\n            shadow = 0.0;\n            break;\n        }\n\n        float dist = map_dist * map_dist * 0.5 / ph;\n        float esti_dist = sqrt(map_dist * map_dist - dist * dist);\n\n        shadow = min(shadow, hardness * esti_dist / max(0.0, ray_length - dist));\n        ph = map_dist;\n        //shadow = min(shadow, hardness * dist / ray_length);\n    }\n    \n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 colour = vec3(0.0);\n\n\n    vec3 ray_orig = vec3(0.0, 0.0, 1.0);\n    vec3 ray_dir  = normalize(vec3(coord, -1.5));\n\n    // Cast the rays from the origin to the space.\n    float ray_length = CastRay(ray_orig, ray_dir);\n    if(ray_length > 0.0)\n    {\n        vec3 view_pos  = ray_orig + ray_dir * ray_length;\n        vec3 view_norm = CalcNorm(view_pos);\n\n\n        vec3  sun_dir    = vec3(0.8, 0.625, 0.8);\n              sun_dir   *= vec3(sin(iTime), 1.0, cos(iTime));   // Rotation\n              sun_dir    = normalize(sun_dir);\n\n        float sun_light  = saturate(dot(view_norm, sun_dir));   // Sun light\n        float sun_shadow = GetSoftShadows(view_pos + view_norm * 0.001, sun_dir, 16.0);\n        colour += vec3(1.0, 0.8, 0.6) * sun_light * sun_shadow * 1.25;\n\n\n        float sky_light = saturate(                             // Sky light\n            dot(view_norm, vec3(0.0, 1.0, 0.0)) * 0.3 + 0.7\n        );\n        colour += vec3(0.0, 0.07, 0.3) * sky_light;\n    }\n    else\n    {\n        // Add a simple fake sky to make the scene looks more natural.\n        float horizon = 1.0 - smoothstep(0.0, 0.4, coord.y);\n        vec3  sky_colour     = vec3(0.0, 0.32, 1.0);\n        vec3  horizon_colour = vec3(0.5, 0.75, 1.0);\n        \n        colour += mix(sky_colour, horizon_colour, horizon);\n    }\n\n\n    colour = pow(colour, vec3(1.0 / 2.2));    // Gamma correction\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}