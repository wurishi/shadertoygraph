{"ver":"0.1","info":{"id":"dsc3Rn","date":"1676930807","viewed":113,"name":"Input Handling Practice","username":"Tynach","description":"A quick and dirty demonstration for how to use a single buffer to store state data, for the purpose of handling input.\n\nClick and drag any of the dots to drag just that one dot. The current dot being dragged is remembered while dragging.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["mouse","dots","gamma","drag","buffer","input","srgb","dragging"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 background = vec3(1, 1, 1);\nconst vec3 foreground = vec3(0, 0, 0);\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n\tvec2[DOT_COUNT] dots;\n\n\tfor (int i = 0; i < DOT_COUNT; ++i) {\n\t\tdots[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n\t}\n\n\tfloat dist = 1.0/0.0;\n\tfor (int i = 0; i < DOT_COUNT; ++i) {\n\t\tdist = min(dist, distance(floor(coord), dots[i]));\n\t}\n\n\tvec3 bg = toLinear(background, gamSrgb);\n\tvec3 fg = toLinear(foreground, gamSrgb);\n\n\tcolor.a = 1.0;\n\tcolor.rgb = toGamma(mix(fg, bg, clamp(dist + (1.0 - DOT_WIDTH)/2.0, 0.0, 1.0)), gamSrgb);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n\n/***************************\n * Specific to This Shader *\n ***************************/\n\n// Width in pixels of each dot\n#define DOT_WIDTH 17.0\n\n// How many dots are defined\n#define DOT_COUNT 3\n\n// Positions within buffer of each stored item after the dots\n#define OLD_MOUSE ivec2(DOT_COUNT + 0, 0)\n#define DOT_DRAG  ivec2(DOT_COUNT + 1, 0)\n\n\n/********************************\n * General Colorspace Utilities *\n ********************************/\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n#define EV_CONV 1239.842\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Automatically calculate the slope and cutoffs for transfer characteristics\n#define Transfer(po, of)\\\ntransfer(\\\n\t(po),\\\n\t(of),\\\n\t(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))/(po),\\\n\t(of)/((po) - 1.0),\\\n\t(of)/((po) - 1.0)*(po)/(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))\\\n)\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\t(r1), (r2), 1.0 - (r1) - (r2),\\\n\t\t(g1), (g2), 1.0 - (g1) - (g2),\\\n\t\t(b1), (b2), 1.0 - (b1) - (b2))\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y)\\\n\tvec3((x), (y), 1.0 - (x) - (y))/(y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag(inverse((space).primaries)*(space).white)\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\n/*\n * Standard XYZ -> LMS transformation matrices\n */\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC (Rec. 601) and SMPTE-240M\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Never-popular, antiquated, and idealized 'HDTV' primaries based mostly on the\n// 1953 NTSC colorspace. SMPTE-240M officially used the SMPTE-C primaries\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n// Original LMS matrix used to derive above primaries\nconst mat3 xyzFromLms = mat3(\n\t1.94735469, 0.68990272, 0,\n\t-1.41445123, 0.34832189, 0,\n\t0.36476327, 0, 1.93485343\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = White(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = White(1.0/3.0, 1.0/3.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = White(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = White(0.312713, 0.329016);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = White(0.34567, 0.35850);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = White(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = White(0.283, 0.298);\n\n// White balance for LMS so that each channel's spectral sensitivities peak at\n// exactly 1.0, at least according to the 2006 cone fundamentals\n//const vec3 whiteLmsUnity = White(89766673.0/387074477.0, 103822461.0/387074477.0);\nconst vec3 whiteLmsUnity = vec3(0.89766673, 1.03822461, 1.93485343);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; used by older Macintosh systems\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, and is close to what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. BT.1886 for displays with infinite contrast ratio\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with bit\n// depths higher than 10!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Rec. 2020; cutoffToGamma might be inaccurate, as I approximated it myself\nconst transfer gam2020 = transfer(1.0/0.45, 0.09929682680944, 4.5, 0.08124285829864, 0.018053968510807);\n\n// Gamma for sRGB. This is the only difference between sRGB and Rec. 709\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point and linearized\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 color, in vec2 coord)\n{\n\t// Initial dot positions\n\tvec2[DOT_COUNT] dots = vec2[DOT_COUNT](\n\t\tvec2(50, 50),\n\t\tvec2(50, 100),\n\t\tvec2(100, 50)\n\t);\n\n\tvec4 oldMouse = vec4(0, 0, -0.0, -0.0);\n\tint dotDrag = -1;\n\n\t// Get previous values unless it's the first frame\n\tif (iFrame != 0) {\n\t\tfor (int i = 0; i < DOT_COUNT; ++i) {\n\t\t\tdots[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n\t\t}\n\n\t\toldMouse = texelFetch(iChannel0, OLD_MOUSE, 0);\n\t\tdotDrag = floatBitsToInt(texelFetch(iChannel0, DOT_DRAG, 0).r);\n\t}\n\n\t// Process new values\n\t// (i|old)Mouse.z's raw bit values are checked so that -0 is detected;\n\t// this lets us fix the bug of it not detecting the first time we drag\n\tif (floatBitsToInt(iMouse.z) < 0) {\n\t\tdotDrag = -1;\n\t} else if (floatBitsToInt(oldMouse.z) < 0) {\n\t\tfor (int i = 0; i < DOT_COUNT; ++i) {\n\t\t\tif (distance(iMouse.xy, dots[i]) <= DOT_WIDTH/2.0) {\n\t\t\t\tdotDrag = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (dotDrag >= 0) {\n\t\tvec2 drag = iMouse.xy - oldMouse.xy;\n\t\tdots[dotDrag] += drag;\n\t}\n\n\t// Output new values\n\tif (ivec2(coord) == ivec2(0, 0)) {\n\t\tcolor.xy = dots[0].xy;\n\t} else if (ivec2(coord) == ivec2(1, 0)) {\n\t\tcolor.xy = dots[1].xy;\n\t} else if (ivec2(coord) == ivec2(2, 0)) {\n\t\tcolor.xy = dots[2].xy;\n\t} else if (ivec2(coord) == OLD_MOUSE) {\n\t\tcolor = iMouse;\n\t} else if (ivec2(coord) == DOT_DRAG) {\n\t\tcolor.r = intBitsToFloat(dotDrag);\n\t}\n}","name":"Buffer A","description":"","type":"buffer"}]}