{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float light_dir = 45.0 * DEGREE_TO_RADIANS; //[0, 180]\nfloat light_color = 2.0;\nfloat sky_color = 0.15;\nfloat baseColor = 0.6;\n\nfloat direct_lighting(float o)\n{   \n    vec2 hitInfo = trace_ray(o, light_dir, iTime);\n    if (hitInfo.x <= 0.0)\n    {\n        return baseColor * light_color;\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 5. * fragCoord/iResolution.y;\n\n    \n    vec3 col = vec3(sky_color);\n    \n    float o = uv.x;    \n    float res = 0.0;\n    // Direct Lighting\n    {\n        res += direct_lighting(o);\n    }\n    \n    // BSDF Sampling\n    {\n        int N = 16;\n        for (int i = 0; i < N; i++)\n        {\n            float d = 180.0 * float(float(i) + 0.5) / float(N) * DEGREE_TO_RADIANS;\n            vec2 hitInfo = trace_ray(o, d, iTime);\n            if (hitInfo.x >= 1.0)\n            {\n                res += 1.0 / float(N) * baseColor * direct_lighting(hitInfo.y);\n            }\n            else\n            {\n                res += 1.0 / float(N) * sky_color;\n            }\n        }\n    }\n    \n    float height = scene(o, iTime);\n    if (abs(uv.y - height) < 0.2)\n    {\n        col = vec3(res);\n    }\n    else if (uv.y < height)\n    {\n        col = vec3(0.0);\n    }\n    \n    col = pow(col, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define DEGREE_TO_RADIANS (3.1415 / 180.0)\n\nfloat random (float x) {\n\tfloat f = 43758.5453123;\n\treturn fract(sin(x) * f);\n}\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat fr = fract(x);\n\treturn mix(random(i), random(i + 1.0), fr);\n}\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n  //float k = hash(uint(i));\n  //float k = 0.5+0.5*sin(i);\n    float k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\nfloat fbm (float x, int octaves, float amplitude, float frequency, float lacunarity, float gain) {\n\tfloat value = 0.0;\n\tfor (int i = 0; i < octaves; ++i) {\n\t\tvalue += amplitude * noise(x * frequency);\n\t\tfrequency *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\treturn value;\n}\n\nfloat fbm(float x, int octaves) {\n\treturn fbm(x, octaves, 0.65, 1.0, 2.4, 0.5);\n}\n\nfloat scene(float x, float time)\n{\n    float n = bnoise(x + time);\n    return 2.2 + 2.0 * n; \n}\n    \nvec2 trace_ray(float o, float d, float time)\n{\n    float height = scene(o, time);\n    float t = (d >= (90.0 * DEGREE_TO_RADIANS))? -0.001: 0.001;\n    if (d >= (90.0 * DEGREE_TO_RADIANS))\n    {\n        d -= (90.0 * DEGREE_TO_RADIANS);\n    }\n    \n    for (int i = 0; i < 32; i++)\n    {\n        float hit_height = scene(o + t, time);\n        float delta = hit_height - height;\n        if ((delta / abs(t)) > (tan(d)))\n        {\n            return vec2(1.0, o + t);\n        }\n        t = t * 2.0;\n    }\n    return vec2(0.0);\n}\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"X33cRS","date":"1735229868","viewed":59,"name":"1D-GI","username":"ShadingKnight","description":"1D-GI","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["globalillumination"],"hasliked":0,"parentid":"","parentname":""}}