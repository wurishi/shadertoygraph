{"ver":"0.1","info":{"id":"McKyRw","date":"1731645049","viewed":58,"name":"Fast Shadow for SDF shapes","username":"kanro","description":"Create a fast shadow for SDF and 1-D box\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","blur","shadow","rectangle","distance","gaussian","signed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 blend(vec4 src, vec4 append) {\n  \treturn vec4(src.rgb * (1.0 - append.a) + append.rgb * append.a,\n              1.0 - (1.0 - src.a) * (1.0 - append.a));\n}\n\n// approximation to the gaussian integral [x, infty)\nfloat gi(float x) {\n\tfloat i6 = 1.0 / 6.0;\n\tfloat i4 = 1.0 / 4.0;\n\tfloat i3 = 1.0 / 3.0;\n\n    if (x > 1.5) return 0.0;\n    if (x < -1.5) return 1.0;\n\n    float x2 = x * x;\n    float x3 = x2 * x;\n    \n    if (x >  0.5) return .5625  - ( x3 * i6 - 3. * x2 * i4 + 1.125 * x);\n    if (x > -0.5) return 0.5    - (0.75 * x - x3 * i3);\n    return 0.4375 + (-x3 * i6 - 3. * x2 * i4 - 1.125 * x);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 drawShape(float d, vec4 color) {\n    vec4 result = color;\n\n    result *= 1. - smoothstep(-0.002, 0.0, d);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\tvec2 si = vec2(0.9,0.6) + 0.3*cos(iTime+vec2(0,2));\n    vec4 ra = 0.3 + 0.3*cos( 2.0*iTime + vec4(0,1,2,3) );\n    ra = min(ra,min(si.x,si.y));\n    \n    vec3 shapeColor = hsv2rgb(vec3(fract(iTime * 0.1), 0.8, 0.8));\n    \n    vec4 color = vec4(shapeColor,1.0);\n\n    // can be replced with any sdf shape in https://iquilezles.org/articles/distfunctions2d/\n    float d = sdRoundedBox(p, si, ra);\n    \n    // triangle\n    #if 0\n    // animate\n\tvec2 v1 = vec2(1.4,1.0)*cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = vec2(1.4,1.0)*cos( iTime + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = vec2(1.4,1.0)*cos( iTime + vec2(0.0,3.00) + 4.0 );\n\n    // distance\n\td = sdTriangle( p, v1, v2, v3 );\n    #endif\n    \n    vec4 shadow = vec4(shapeColor, gi(d * 4.));\n    vec4 shape = drawShape(d, color);\n    \n    \n    fragColor = blend(blend(vec4(1.), shadow), shape);\n}","name":"Image","description":"","type":"image"}]}