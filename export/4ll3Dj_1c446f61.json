{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct polygon{\n\tvec2 A, B, C;\n};\nfloat m_sign(vec2 p1, vec2 p2, vec2 p3){\n  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nint PointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\n\tint b1, b2, b3;\n\n\tif(m_sign(pt, v1, v2) < 0.0) b1=1;\n\tif(m_sign(pt, v2, v3) < 0.0) b2=1;\n\tif(m_sign(pt, v3, v1) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nint PointInTriangle(vec2 pt, polygon X){\n\tint b1, b2, b3;\n\n\tif(m_sign(pt, X.A, X.B) < 0.0) b1=1;\n\tif(m_sign(pt, X.B, X.C) < 0.0) b2=1;\n\tif(m_sign(pt, X.C, X.A) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nfloat triangle( vec2 coord, vec2 pos, float angle, float thick, float size){\n    vec2 original_coord = coord;\n    coord += pos;\n    coord *= rotate(angle);\n    float collision = 0.0;\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2( 0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.3,-0.2)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += 3.0*texture( iChannel0, original_coord * 0.6 + vec2(iTime*0.02) ).b * 0.6;\n    collision += 2.5*texture( iChannel0, original_coord * 0.1 + vec2(iTime*0.001) ).b * 0.4;\n    return -min(max(-collision,0.0),1.0);\n}\nfloat circle(vec2 coord, float size, float start, float end){\n    float angle = atan(coord.x, coord.y);\n    if(angle>start && angle<end) return 0.0;\n    return min(floor(distance(coord,vec2(0.))-size),0.);\n}\nvec3 piip(){\n    vec2 res=iResolution.xy;\n    vec2 coord = 1.8 * vec2((res.x/res.y),1.0) *(gl_FragCoord.xy / res.xy - 0.5);\n    vec2 p=coord;\n    coord*=0.7;\n    vec3 COLOR =vec3(0.7,0.77,0.9);\n    for(float ttt=0.; ttt<0.4; ttt+=0.1){\n    float time=ttt+iTime*(0.6)+floor(coord.y*4.+iTime*0.2+coord.x*0.2)*0.1;\n    coord*=sin(time*0.001)*0.4+0.7-time*0.001;\n   \tcoord*=rotate(time*0.1);\n    coord*=1.0+0.4*sin(iTime*0.2+length(coord)*2.1);\n    coord *= sin(cos(length(coord)*1.4-time*0.42)*4.+time*.1)*1.6;\n        \n    coord += 0.01*(rand(vec2(floor(coord.x*10.),floor(coord.y*44.)+ttt))-0.5);\n        \n        \n        \n    coord.x +=0.06*(rand(vec2(floor(coord.y*12.+time)))-0.5);\n    coord.y +=0.01*(rand(vec2(floor(coord.x*777.+time)))-0.5);\n    for(float i=0.; i<44.; i+=1.3)\n        COLOR -= (vec3(sin(i+time*.78),cos(i+time*.64+length(coord)*4.),sin(time))*0.05+0.3)*circle(coord,0.01*i+0.4*sin(time+i),sin(i*4.3+time*0.1)*3.141,sin(i*0.3+time*0.1)*3.141) - 0.3*circle(coord,-0.02+0.01*i+0.4*sin(time+i),sin(i*4.3+time*0.1)*3.141,sin(i*0.3+time*0.1)*3.141);\n    if(mod(p.y*2e2+p.x*2e2,3.)<1.1)\n        COLOR -= vec3(0.05);\n    COLOR += 0.2*(cos(time)*0.16 + 1.1 - min(time, 1.0));\n    COLOR+=0.1*(1.0+mod(time*5.0,1.0)*0.1)-\n        vec3(\n        rand(p+.21*vec2(time))*rand(vec2(p.x,time*.3)),\n        rand(vec2(coord.y,0.)+p+.31*vec2(time))*rand(vec2(p.x*0.01,time*2.1)),\n        rand(p+.41*vec2(time))*rand(vec2(p.x*0.1,time))\n        )*.4;\n    }\n    COLOR/=2.8;\n    return COLOR;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 tulos;\n\tvec4 lopullinentulos=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 ori_coord=coord;\n\tfor(float rgbare=0.0; rgbare<2.0; rgbare++){\n        coord = vec2(aspectCorrection,1.0) *coordinate_entered * (1.+0.2*cos(iTime*0.05));\n        coord.x*=1.0+rgbare*0.007;\n        coord*=1.5+0.1*sin(1.01*0.1);\n        tulos=vec4(vec3(16.0/255.0, 8.0/255.0, 0.0/255.0),1.0);\n        coord*=sin(iTime*3.)*.2+2.;\n\t\tcoord+=5.*(vec2(rand(vec2(floor(iTime))),rand(vec2(floor(iTime+66.))))-vec2(0.5));\n        coord*=rand(vec2(floor(iTime+444.)));\n    \tcoord+=max(2.0-(mod(iTime*8.,16.))/2.,0.)*vec2(rand(floor(coord*2.+iTime))-0.5,rand(floor(coord*2.+44.+iTime))-0.5);\n        \n        vec3 taikurivitunluttinen=vec3(0.);\n        if(mod(iTime,6.)>1.){\n            taikurivitunluttinen.rb+=0.7*max(1.0-(iTime,4.)/2.,0.)*vec2(rand(floor(coord*2.))-0.5,rand(floor(coord*2.+44.))-0.5);\n            taikurivitunluttinen.rg-=0.7*max(1.0-(iTime,4.)/2.,0.)*vec2(rand(floor(coord*.9))-0.5,rand(floor(coord*.9+44.))-0.5);\n        }\n        coord.x+=( 0.05*sin((iTime)*12.+coord.y) ) / (1.0+33.*(mod(iTime,2.)));\n    \tcoord.y+=( 0.05*sin((iTime)*12.+coord.x) ) / (1.0+33.*(mod(iTime,2.)));\n\n        float headTime=max(iTime-2.,0.);\n        vec2 head_coord=coord*(sin(headTime*40.)*0.1/(headTime*22.)+1.);\n        tulos.rgb+=sun(head_coord,vec2(0.),.9);\n        tulos.rgb+=sun(head_coord,vec2(0.),1.2);\n        tulos.rgb-=sun(head_coord,vec2(0.),1.1);\n        tulos.rgb-=sun(head_coord,vec2(0.35,0.12),.18);\n        tulos.rgb+=sun(head_coord,vec2(0.35,0.12),.12);\n        tulos.rgb-=sun(head_coord,vec2(-0.35,0.12),.12);\n        tulos.rgb+=sdCapsule( head_coord+vec2(0.,0.1*cos(head_coord.x*3.14159/1.4-3.14159/16.)), vec2(-.666,-0.4), vec2(.666,-0.4), 0.1);\n\n        if(head_coord.y>0.4){\n            tulos.rgb-=sun(head_coord,vec2(0.333,0.3),.33);\n            tulos.rgb+=sun(head_coord,vec2(0.333,0.3),.28);\n            tulos.rgb-=sun(head_coord,vec2(-0.333,0.3),.33);\n            tulos.rgb+=sun(head_coord,vec2(-0.333,0.3),.28);\n        }\n        tulos.rgb-=triangle( coord*rotate(iTime+1.), vec2(0.,-.2), 0.0, 0.1, 5.*sin(iTime+1.)+mod(iTime,2.)+10.+sin(iTime)*2.);\n        tulos.rgb-=triangle( coord*rotate(iTime*.42+1.), vec2(0.,-.2), 0.0, 0.2, 5.*sin(iTime+2.)+mod(iTime,2.)+12.+sin(iTime)*2.)/2.;\n        tulos.rgb-=triangle( coord*rotate(iTime*1.3+1.), vec2(0.,-.2), \t0.0, 0.133, 5.*sin(iTime+3.)+mod(iTime,2.)+14.+sin(iTime)*2.)/4.;\n        tulos.rgb-=triangle( coord*rotate(iTime*1.6+1.), vec2(0.,-.2), \t0.0, 0.4, 5.*sin(iTime+4.)+mod(iTime,2.)+14.+sin(iTime)*2.)/4.;\n        tulos.rgb-=triangle( coord*rotate(iTime*0.6+1.), vec2(0.,-.2), \t0.0, 0.1, 5.*sin(iTime+5.)+mod(iTime,2.)+14.+sin(iTime)*4.)/4.;\n\n        float collision = 0.0;\n        if(collision<0.0)\n            tulos.xyz += vec3(0.1);\n\n        tulos.xyz=tulos.xyz-vec3(min(max(-0.57+length(ori_coord)*0.32,0.0),1.0))-vec3(0.015+0.03*rand(vec2(ori_coord.x+ori_coord.y,1.01*ori_coord.y*ori_coord.x)));\n\n        if(rgbare==0.0)\n            lopullinentulos.r=tulos.r;\n        if(rgbare==1.0)\n            lopullinentulos.gb=tulos.gb;\n\t}\n\tlopullinentulos.xyz=lopullinentulos.xyz*(1.05-0.1*mod(fragCoord.y,2.0));\n    float vignette = 1.0 / max(0.3 + 1.7*dot(coord,coord),1.);\n\tfragColor = lopullinentulos*vec4(piip()+vec3(.6)+vignette,1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ll3Dj","date":"1425249829","viewed":133,"name":"Weirder","username":"Branch","description":"Weird","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["weird"],"hasliked":0,"parentid":"","parentname":""}}