{"ver":"0.1","info":{"id":"7t2BDV","date":"1652788411","viewed":170,"name":"rainbow ripple water thing","username":"HaleyHalcyon","description":"a","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"ssGGRd","parentname":"Anime Water 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n//  0   8   2  10\n// 12   4  14   6\n//  3  11   1   9\n// 15   7  13   5\n\n// 0000 1000 0010 1010\n// 1100 0100 1110 0110\n// 0011 1011 0001 1001\n// 1111 0111 1101 0101\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return float(\n        1 +\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    )/ 16.;\n}\n\nvec3 ease(vec3 t) {\n    t = clamp(t, 0., 1.);\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 posterize(vec3 col, float thres) {\nconst float steps = 2.;\n    return (floor(\n        col * steps\n    ) + step(\n        vec3(thres), fract(col * steps)\n    )) / steps;\n}\n\nfloat ease(float t) {\n    t = clamp(t, 0., 1.);\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat zigzag(float t) {\n    return 1. - abs(1. - fract(t) * 2.);\n}\n\nfloat ripple(vec2 uv, vec2 lightDir, float scale, float time) {\n    \n    return ease(zigzag(\n        length(uv) * scale - time\n    )) * 0.5 * dot(\n        lightDir,\n        normalize(uv) *\n        ease(length(uv) * scale * 0.25)\n    );\n}\n\nvec2 angleVec(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\n// gives pure saturated color from input [0, 6) for phase\nvec3 hue(float x) {\n    x = mod(x, 6.);\n    return clamp(vec3(\n        abs(x - 3.) - 1.,\n        -abs(x - 2.) + 2.,\n        -abs(x - 4.) + 2.\n    ), 0., 1.);\n}\n\n// does pseudo overexposure filter\nvec3 deepfry(vec3 rgb, float x) {\n    rgb *= x;\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime /4.);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    float lightAngle = 1.7 + 0.45 * sin(2. * uv.x * TAU);\n    const float centerSep = 0.1;\n    const float centerSpeed = -0.;\n    float centerOfs = 2.5;\n    vec2 center0 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time));\n    vec2 center1 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time+1./3.));\n    vec2 center2 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time-1./3.));\n    \n    const float sizeScale = 8.;\n    const float timeScale = 7.;\n    \n    uv += ripple(\n            uv, angleVec(lightAngle),\n            sizeScale, 0. + time * timeScale\n        ) * vec2(0.05, 0.2) * length(uv);\n    \n    //uv.x += 0.02 * sin(uv.y * 150.5 + time * 7. * TAU);\n    //uv.y += 0.002 * sin(uv.x * 14.7 + time * 11. * TAU + 0.2);\n   \n    float colorSep = 0.3;\n    vec2 cbcr = vec2(0.);\n    cbcr +=\n        ripple(\n            uv - center0, angleVec(lightAngle + colorSep),\n            sizeScale, time * timeScale\n        ) * vec2(1., 0.);\n    cbcr +=\n        ripple(\n            uv - center1, angleVec(lightAngle),\n            sizeScale, time * timeScale\n        ) * vec2(-0.5, sqrt(3.)/2.);\n    cbcr +=\n        ripple(\n            uv - center2, angleVec(lightAngle - colorSep),\n            sizeScale, time * timeScale\n        ) * vec2(0.5, sqrt(3.)/2.);\n    vec3 col = length(cbcr) * (hue(6. * (time - 1.3 * length(uv) + atan(cbcr.y, cbcr.x) / TAU)) - 0.5);\n    // add b/w\n    col +=\n        ripple(\n            uv, angleVec(lightAngle),\n            sizeScale, 0. + time * timeScale\n        ) * vec3(0.5);//*/\n    col = posterize(\n        col * 2.5 + 0.5,\n        crosshatch(fragCoord)\n    );\n    // color balance\n    col = vec3(0.5) + (col - 0.5) * vec3(0.3);\n    // overexpose\n    col = deepfry(col, 1.2);\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}","name":"Image","description":"","type":"image"}]}