{"ver":"0.1","info":{"id":"3lX3Wr","date":"1556048485","viewed":464,"name":"Color Lerp Gradient","username":"Diatom","description":"Linear interpolation multi color gradient bands.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gradientlinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define numColors  8\nvec3 colorArray[numColors];\nfloat _Speed = -0.0;\nfloat _Scale = 1.;\n\n//---------------------------------- random\nfloat random(vec2 st)\n\t\t\t{\n\t\t\t\treturn abs(fract(sin(dot(st.xy,\n\t\t\t\t\tvec2(12.9898, 78.233)))*\n\t\t\t\t\t43758.5453123));\n            }\n\n//---------------------------------- flat_band\nvec3 flat_band(float t, vec3 colA, float posA, float posB){\n\tvec3 retColor = vec3(0.);     \n    float maskStep = step(posA, t)*  (1.- step(posB, t));  \n    retColor +=   colA * maskStep;\n    return retColor;\n}\n\n//---------------------------------- color_lerp\nvec3 color_lerp(float t, vec3 colA,float posA, float posB){\n    //t = mod(t*_Scale +iTime*_Speed, 1.0); // transform UVs\n    t = t* (1.0-1.0/float(numColors)) + (1.0/float(numColors)*0.5); // frame for seamless looping\n\tvec3 retColor = vec3(0.);   // return color\n    float m = posA + ((posB - posA)/2.); // midpoint between A and B\n    float d = (posB - posA); // distance between A and B\n    float maskSmooth =  smoothstep(m-d, m, t) *( 1. - smoothstep(m, m+d, t));      \n    retColor = colA * maskSmooth; \n    return retColor;\n}\n\n//---------------------------------- main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\t    \n    float rSeed = 39.11025;\n    float rStrength = 0.;\n    float waveStrength = 1.;\n    float waveAmp = 1.0;\n    float waveFreq = 4.5;\n    float waveOff = 0.0;\n    float waveSpeed = 0.33;\n    vec3 colorPhase = vec3(0.2, 0.35, 0.8);\n    float PI = 3.1415926;\n    for (int i=0; i<numColors; i++)\n    {\n    \t// Random Color\n       /* colorArray[i] += vec3( random(vec2(float(i+1)*33.3 *rSeed, float(i+1)*66.6*rSeed) ), \n                              random(vec2(float(i+1)*11.1*rSeed, float(i+1)*55.6*rSeed)), \n                              random(vec2(float(i+1)*22.8*rSeed, float(i+1)*77.6*rSeed)) )* rStrength;*/\n    \t// Wave Color\n        \n   \t float w = float(i) / float(numColors) ;\n     colorArray[i] += vec3( (sin(w*PI*waveFreq+colorPhase.x*PI + waveSpeed*iTime)+1.0)*0.5 * waveAmp + waveOff,\n                              (sin(w*PI*waveFreq+colorPhase.y*PI + waveSpeed*iTime)+1.0)*0.5 * waveAmp + waveOff,\n                              (sin(w*PI*waveFreq+colorPhase.z*PI + waveSpeed*iTime)+1.0)*0.5 * waveAmp + waveOff )  * waveStrength;   \n\t}\n    \n    vec3 col = vec3(0.); \n    float ptInterval = 1./float(numColors);\n    int loop = 1;\n    int a,b;\n    float offset = 0.21;\n   // float ptStart, ptEnd;\n    for (int i=0; i < numColors; i++){\n        a = i % (numColors-1 + ((1-loop)*1000));      \n        col +=  color_lerp(uv.x,  colorArray[a],   ptInterval * float(i) ,  ptInterval * float(i)+ptInterval  ); \n        //col += flat_band(uv.x,  colorArray[a],   ptInterval * float(i),  ptInterval * float(i)+ptInterval ); \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}