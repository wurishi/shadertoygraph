{"ver":"0.1","info":{"id":"XdjcRm","date":"1676605076","viewed":121,"name":"Cubic polynomial root solver","username":"nilrem","description":"Implements and plots Jim Blinn's analytic cubic polynomial root solver\nhttps://courses.cs.washington.edu/courses/cse590b/13au\nSliders left2right, top2bottom: cubic polynomial coefficients ABCD\nDiscriminant in top left corner","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["solver","ui","cubic","widgets","polynomial","plotting","root"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nhighp float;\n\n// --- UI related stuff -----------------------------------------------------------------------------\n\n#define NUM_SLIDERS\t4.\n\n// define your sliders in BufA.  value [0,1]  = UI(i).a    , i=1..16\n// get mouse position enriched by demo-mode in UI(33)\n// get prev mouse position in UI(34) (e.g.: detect move, get velocity, direction...)\n\n/*\n// --- keyboard ---------------------------------------------------------\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\nbool keyClick(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n*/\n \n// --- Digit display ----------------------------------------------------\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv, float val, bool zeroTrim) { // val: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tint nr = int(val);\n    if (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\tif (val<0.) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); // minus sign.\n\t\t}\n\t}\n\tif (uv.x>0.) {\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\treturn digit(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) { // dot: bit 0 = bottom dot; bit 1 = top dot\n\tfloat point0 = float(dot/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .1;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n\n#define STEPX .875\n#define STEPY 2.33\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\n\n// 2digit int + sign\nfloat display_digit(vec2 uv, float scale, float offset, float number, int dot, bool zeroTrim ) { // dot: draw separator\n    uv = (uv-0.)/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\tfloat seg = showNum(uv, number, zeroTrim);\n\toffset += 2.;\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\t_offset = offset;\n\treturn seg;\n}\n\n// 2.2 float + sign\nfloat display_float(vec2 pos, float scale, float offset, float val) { // dot: draw separator\n\tif (display_digit( pos, scale, 0., val, 1, true ) > 0.) return 1.;\n    if (display_digit( pos, scale, _offset, fract(abs(val))*100., 0, false ) > 0.) return 1.;\n\treturn 0.;\n}\n\n// --- sliders and mouse widgets -------------------------------------------\n//vec2 R = iResolution.xy;\n#define R (iResolution.xy)\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n#define Swidth  .002\n#define Sradius .015\nfloat aff_sliders(vec2 U) { // display sliders ( grey level or 0.)\n    for (float i=0.; i<NUM_SLIDERS; i++) {\n\t//\tif (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n    //\tif (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;\t// vertical\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n    //\tif (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\t\t\t\t// vertical\n    }\n    return 0.;       \n}\n\n\n\n\n// --- Function Plotting -----------------------------------------------------------------------------\n\n#define x_axis_scale\t3.0\n#define y_axis_scale\t2.0\n#define line_thickness\t1.0\n\n#define black\tvec3( 0 )\n#define grey\tvec3( 0.4 )\n#define red\t\tvec3( 0.9, 0.2, 0.1 )\n#define green\tvec3( 0.2, 0.8, 0.2 )\n#define blue\tvec3( 0.2, 0.2, 0.7 )\n#define orange\tvec3( 0.9, 0.6, 0.1 )\n#define violet\tvec3( 0.8, 0.1, 0.7 )\n\nvec3 inv_output_color = vec3(0);\n\n// TODO: do this proper...\nvoid draw( float dist, vec3 color )\n{\n    float inv_dist = line_thickness * (x_axis_scale + y_axis_scale) * 0.5 / (dist * (iResolution.x + iResolution.y) * 0.5 );\n    float intensity = clamp( pow(abs(inv_dist), 1.6+0.5*smoothstep(1.0,2.0,600.0/iResolution.x)    ), 0.0, 1.0 );\n    inv_output_color += (1.0 - color) * intensity;\n}\n\nvoid draw_axes( float x, float y, vec3 color )\n{\n    draw( y, color );\n    draw( x * iResolution.x / iResolution.y, color );\n}\n\nvoid draw_point( vec2 uv, vec2 pos, vec3 color )\n{\n    vec2 diff = uv-pos;\n    diff.y *= iResolution.y/iResolution.x;\n    diff.x /= x_axis_scale;\n    diff.y /= y_axis_scale;\n\tfloat dist = dot(diff, diff);\n    float intensity = clamp( 0.99 - dist*7000., 0.0, 1.0 );\n    inv_output_color += (1.0 - color) * intensity;\n}\n\n\n// --- Math Functions --------------------------------------------------------------------------------\n\n// Sign function (deliberately returns 1 for x=0)\nfloat sgn( in float x )\n{\n\treturn x < 0.0 ? -1.0 : 1.0;\n}\n\n// Cubic root using pow (works on [-inf; inf]\nfloat cbrt( in float x )\n{\n\tfloat sign = sgn(x);\n\treturn sign * pow( abs(x), 0.333333333333 );\n}\n\n// Evaluates cubic polynomial Ax³ + Bx² + Cx + D at x, given its coefficients A B C D\nfloat eval_cubic( in float x, in float A, in float B, in float C, in float D )\n{\n    return A*x*x*x + B*x*x + C*x + D;\n}\n\n// Finds roots of homogeneous cubic polynomial Ax³ + 3Bx² + 3Cx + D   (Ax³ + 3Bx²w + 3Cxw² + Dw³)\n// Algorithm by Jim Blinn, see https://courses.cs.washington.edu/courses/cse590b/13au/lecture_notes/\n// This implementation directly converts the roots from homogeneous to cartesian space\nfloat solve_cubic( out vec3 roots, in float A, in float B, in float C, in float D )\n{\n    // Hessian coefficients\n\tfloat d_1 = A*C - B*B;\n\tfloat d_2 = A*D - B*C;\n\tfloat d_3 = B*D - C*C;\n    \n    // Hessian determinant ( = cubic discriminant)\n\tfloat d   = ( 4.0 * d_1 * d_3 ) - ( d_2 * d_2 );\n\n    \n\tif( d <= 0.0 )\t\t// one real root (a double root if d=0, a triple root if d_1=d_2=d_3=d=0)\n\t{\n        // Subscript b for \"bar\", t for \"tilde\"\n\n        // Depressed polynomial coefficients\n\t\tfloat A_t;\t// A or D\n\t\tfloat C_b;\t// 1/2 H(t, u)\n\t\tfloat D_b;\t// J(t, u)\n\t\t\n        // save predicate B³D >= AC³ to avoid multiple evaluations\n\t\tbool B3D_ge_AC3 = B*B*B*D >= A*C*C*C;\n\t\t\n\t\tif( B3D_ge_AC3 )\n\t\t{\n            // Algorithm A, t = 1, u = 0\n\t\t\tA_t = A;\n\t\t\tC_b = d_1;\n\t\t\tD_b = -2.0 * B * d_1 + A * d_2;\n\t\t}\n        else\n\t\t{\n            // Algorithm D, t = 0, u = 1  (reversed order of coefficients)\n\t\t\tA_t = D;\n\t\t\tC_b = d_3;\n\t\t\tD_b = -D * d_2 + 2.0 * C * d_3;\n\t\t}\n\n\t\tfloat T0   = -sgn( D_b ) * abs( A_t ) * sqrt( -d );\n\t\tfloat T1   = -D_b + T0;\n\t\tfloat p    = cbrt( T1*0.5 );\n\t\tfloat q    = T1 == T0  ? -p     : -C_b / p;\n\t\tfloat x_t1 = C_b <= 0. ?  p + q : -D_b / ( p*p + q*q + C_b );\n        \n        // Get back from tilde'ed space to homogeneous space and invert result if algorithm D\n\t\tfloat x1   = B3D_ge_AC3 ? x_t1 - B : -D;\n\t\tfloat w1   = B3D_ge_AC3 ? A        : x_t1 + C;\n        \n        // Convert from homogeneous to cartesian space\n\t\troots.x    = x1 / w1;\n\t}\n\telse\t// d > 0    // three real roots (with potentially one double root)\n\t{\n        // variables subscripted with A and D according to algorithms A and D\n        // t is the angle theta\n        // x_L/w_L is the first root, x_S/w_S the second root, x_M/w_M the third root\n        \n        // Use both algorithms A and D to find the first two roots\n        // Same C_b and D_b as before, according to algorithm A's and D's choices of t,u\n        \n        // 0.866025403784 -> sqrt(3)/2\n        \n        // Algorithm A\n\t\tfloat C_bA  = d_1;\n\t\tfloat D_bA  = -2.0 * B * d_1 + A*d_2;\n        \n\t\tfloat t_A   = 0.333333333333 * abs( atan( A*sqrt( d ), -D_bA) );\n\t\tfloat x_t1A = 2.0 * sqrt( -C_bA ) * cos( t_A );\n\t\tfloat x_t3A = 2.0 * sqrt( -C_bA ) * ( -0.5 * cos( t_A ) - 0.866025403784 * sin( t_A ) );\n\t\tfloat x_tL  = ( x_t1A + x_t3A > 2.0 * B ) ? x_t1A : x_t3A;\n        \n        // Get back from tilde'ed space, same as before\n\t\tfloat x_L   = x_tL - B;\n\t\tfloat w_L   = A;\n        \n\t\troots.x     = x_L / w_L;\n\t\t\n        \n        // Algorithm D\n        // same as Algorithm A except for choice of t,u (and thus inverted result)\n\t\tfloat C_bD  = d_3;\n\t\tfloat D_bD  = -D * d_2 + 2.0 * C * d_3;\n        \n\t\tfloat t_D   = 0.333333333333 * abs( atan( D*sqrt( d ), -D_bD ) );\n\t\tfloat x_t1D = 2.0 * sqrt( -C_bD ) * cos( t_D );\n\t\tfloat x_t3D = 2.0 * sqrt( -C_bD ) * ( -0.5 * cos( t_D ) - 0.866025403784 * sin( t_D ) );\n\t\tfloat x_tS  = ( x_t1D + x_t3D < 2.0 * C ) ? x_t1D : x_t3D;\n        \n        // Get back from tilde'ed space, same as before\n\t\tfloat x_S   = -D;\n\t\tfloat w_S   = x_tS + C;\n        \n\t\troots.y     = x_S / w_S;\n\t\t\n        \n        // Third root from the first two (no more to and from tilde'ed space here)\n\t\tfloat E   =  w_L * w_S;\n\t\tfloat F   = -x_L * w_S - w_L * x_S;\n\t\tfloat G   =  x_L * x_S;\n        \n\t\tfloat x_M =  C*F - B*G;\n\t\tfloat w_M = -B*F + C*E;\n        \n\t\troots.z   = x_M / w_M;\n\t}\n    \n\treturn d;\t// return discriminant\n}\n\n// ------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // --- UI -------------------------------------------------------------------\n    \n\tvec2 uv\t\t= fragCoord.xy / R.y;\n\tvec4 mouse\t= UI(33) / R.y;\n\t\n    // Read slider values\n    #define SLIDER_MIN (-2.)\n    #define SLIDER_MAX ( 2.)\n    \n    // Slighty convoluted formula as a workaround to some strange GLSL compiler bug\n    float slider_1 = ( UI(1).a + SLIDER_MIN / (SLIDER_MAX - SLIDER_MIN) ) * (SLIDER_MAX - SLIDER_MIN);\n    float slider_2 = ( UI(2).a + SLIDER_MIN / (SLIDER_MAX - SLIDER_MIN) ) * (SLIDER_MAX - SLIDER_MIN);\n    float slider_3 = ( UI(3).a + SLIDER_MIN / (SLIDER_MAX - SLIDER_MIN) ) * (SLIDER_MAX - SLIDER_MIN);\n    float slider_4 = ( UI(4).a + SLIDER_MIN / (SLIDER_MAX - SLIDER_MIN) ) * (SLIDER_MAX - SLIDER_MIN);\n    \n    // Display sliders and buttons \n\tif( aff_sliders(uv) > 0.0 )\t{ fragColor = vec4( 0.1, 0.7, 0.1, 1.0); return; }\n    \n\t// Display slider values\n\tfloat scale\t= 0.03;\n    vec2  pos\t= vec2( 0.61, -0.035 );\n\t\n    pos.y += STEPY*scale; \t// move up\n    if( display_float( uv-pos, scale, 0.0, slider_1 ) > 0.0 ) { fragColor = vec4( black, 1.0 ); return; }\n\t\n    pos.y += STEPY*scale; \t// move up\n    if( display_float( uv-pos, scale, 0.0, slider_2 ) > 0.0 ) { fragColor = vec4( black, 1.0 ); return; }\n\t\n    pos.x += 0.805;\t\t\t// next column, move right\n    pos.y -= STEPY*scale;\t// move down\n    if( display_float( uv-pos, scale, 0.0, slider_3 ) > 0.0 ) { fragColor = vec4( black, 1.0 ); return; }\n\t\n    pos.y += STEPY*scale;\t// move up\n    if( display_float( uv-pos, scale, 0.0, slider_4 ) > 0.0 ) { fragColor = vec4( black, 1.0 ); return; }\n    \n    // -------------------------------------------------------------------------\n    \n    \n    \n    \n    \n    // --- Function Plotting ---------------------------------------------------\n    \n    // Define origin (x,y) at center of screen\n    float x = x_axis_scale * ( fragCoord.x * 2.0 / iResolution.x - 1.0 );\n    float y = y_axis_scale * ( fragCoord.y * 2.0 / iResolution.y - 1.0 );\n    vec2 xy = vec2( x, y );\n    \n    draw_axes( x, y, grey );\n    \n    \n    // Read cubic polynomial coefficients from sliders\n    float A = slider_2;\n    float B = slider_4;\n    float C = slider_1;\n    float D = slider_3;\n    \n    // Draw cubic polynomial    \n    float cubic_value = eval_cubic( x, A, B, C, D );\n    draw( y - cubic_value, green );\n    \n    // Draw roots\n    vec3 roots;\n    float det = solve_cubic( roots, A, 0.3333333333*B, 0.3333333333*C, D );\n    if( det <= 0.0 )\n    {\n        draw_point( xy, vec2( roots.x, 0.0 ), orange );\n    }\n    else\n    {\n        draw_point( xy, vec2( roots.x, 0.0 ), green );\n        draw_point( xy, vec2( roots.y, 0.0 ), blue  );\n        draw_point( xy, vec2( roots.z, 0.0 ), red   );\n    }\n    \n    // Display discriminant\n    pos = vec2( 0.105, 0.95 );\n    if( display_float( uv-pos, scale, 0.0, det ) > 0.0 )\n    {\n        fragColor = vec4( black, 1.0 );\n        return;\n    }\n    \n    \n    /*\n\t// uncomment for \"stress test\" :)\n    #define _START -0.5\n    #define _END   0.5\n    #define _INCR  0.005\n    float g = _END + _INCR;\n    for (float f = _START; f <= _END; f += _INCR)\n    {\n        g -= _INCR;\n\n        float cubic_value = eval_cubic( x, A+f, 3.*(B+g), 3.*(C+f), D+g );\n    \tdraw( y - cubic_value, green );\n        \n        vec3 roots;\n        float det = solve_cubic( roots, A+f, B+g, C+f, D+g );\n        if (det <= 0.0)\n        {\n            draw_point( xy, vec2(roots.x, 0.0), orange );\n        } else\n        {\n            draw_point( xy, vec2(roots.x, 0.0), green );\n            draw_point( xy, vec2(roots.y, 0.0), blue );\n            draw_point( xy, vec2(roots.z, 0.0), red );\n        }\n    }    \n    */\n    \n    \n    fragColor = vec4( 1.0 - inv_output_color, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// only line 0, pixels 0 to 33 of bufA are used\n\n#define FAKE_MOUSE 0 // fake mouse motion if no user input\n#define Sradius .025  // influence radius for sliders\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n//vec2 R = iResolution.xy;\n#define R (iResolution.xy)\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n  O = texture(iChannel0,U/R);\n  U -= .5;\n  if (U.y == 0. && U.x < 36.)\n  {\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        // --- define your sliders here ---\n        // read value [0,1] in UI(i).a  with i = 1..16\n        add_slider (.05, .05, HORIZ, .5, .2);\n        add_slider (.05, .12, HORIZ, .5, .6);\n        add_slider (.85, .05, HORIZ, .5, .4);\n        add_slider (.85, .12, HORIZ, .5, .55);\n        \n        if (U==vec2(0,0)) O.xy = vec2(nbS, nbB);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  // previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)<10. && m.z<=0.) { // fake mouse motion if no user input\n\t        float t = iTime;         // you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    if (U==vec2(34,0)) { O = UI(33); return; } // previous mouse state (for other shaders)\n    \n    if (iMouse.z>0. && U.y==0.) {          // --- left mouse triggers the right slider\n       \tvec2 M = iMouse.xy/iResolution.y;\n        if (U.x <= UI(0).x+1.) {\n\t        vec4 S = UI(U.x);\n    \t    float l = abs(S.z);\n\t        if (S.z>0. && abs(M.y-S.y)<Sradius && abs(M.x-S.x-l*.5)<l*.52 ) O.a = (M.x-S.x)/l;\n\t\t//\tif (S.z<0. && abs(M.x-S.x)<Sradius /*&& abs(M.y-S.y-l*.5)<l*.5*/ ) O.a = (M.y-S.y)/l; // vertical\n            O.a = max(O.a,0.);\n            O.a = min(O.a,1.);\n    \t}\n    }\n  }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}