{"ver":"0.1","info":{"id":"XXV3zD","date":"1717657297","viewed":246,"name":"something cold","username":"FoRenard","description":"pathtracer practice","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://kinakomoti321.hatenablog.com/entry/2023/11/05/201719\n// https://github.com/KhronosGroup/ToneMapping/blob/main/PBR_Neutral/pbrNeutral.glsl\nvec3 PBRNeutralToneMapping(vec3 color)\n{\n    const float startCompression = 0.8 - 0.04;\n    const float desaturation = 0.15;\n\n    float x = min(color.r,min(color.g,color.b));\n    float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n    color -= offset;\n\n    float peak = max(color.r,max(color.g,color.b));\n    if(peak < startCompression)\n        return color;\n\n    const float d = 1. - startCompression;\n    float newPeak = 1. - d * d / (peak + d - startCompression);\n    color *= newPeak / peak;\n\n    float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n    return mix(color,newPeak * vec3(1,1,1),g);\n}\nfloat _tri(float x, float c)\n{\n    return (x < c ? x / c : 1. - (x - c) / (1. - c));\n}\n// 等色関数\nvec3 cloma(float x)\n{\n    x = fract(x);\n    return vec3(_tri(x, .7), _tri(x, .5), _tri(x, .2)) * 2.;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 fc=gl_FragCoord.xy,res = iResolution.xy,asp = res / min(res.x,res.y);\n    vec2 uv = fc / res,suv = (uv * 2. - 1.) * asp;\n    vec3 c=vec3(0);\n    int n=8;\n    rep(i,n)\n    {\n        float fi=(float(i)+.5)/float(n);\n        vec2 s=vec2(-suv*4.)/res*fi;\n        vec4 buf=texture(iChannel0,uv+s);\n        c+=buf.rgb/buf.a*cloma(fi);\n    }\n    c/=float(n);\n    c=PBRNeutralToneMapping(c*1.5);\n    float v=smoothstep(.9,.4,length(uv-.5));\n    c=smoothstep(.0,1.,c)*v;\n    fragColor = vec4(c,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// r to reset\n#define ACCUMULATE (step(texelFetch(iChannel1,ivec2(5*16+2,0),0).r,.5))\n#define ACC_COUNT 1\n#define MAX_DEPTH 8\n#define MAX_STEP 300\n#define MAX_LEN 1e2\n#define EPS 1e-3\nconst vec3 SUN=norm(vec3(-1,1,.3));\n// color,emission,roughness,metallic\nconst Material mats[2] = Material[](\nMaterial(vec3(1),vec3(0),1.,.0),\nMaterial(vec3(1),vec3(0),.2,.9)\n);\nfloat heart(vec3 p)\n{\n    vec3 op = p;\n    float rt = 0.5,alt=4.9;\n    p.x = abs(p.x);\n    p.zy *= rot(p.x * rt);\n    //p.xz *= rot(p.y * rt);\n    p.x -= 1.5;\n    p.xy = pmod(p.xy * rot(alt * 0.1),4.0);\n    p.x -= 1.;\n    float w = mix(.2,.05,length(op)/3.);\n    float d=max(min(length(p.xy),min(length(p.zy),length(p.xz)))-w,length(op)-6.);\n    return d*.5;\n}\nfloat map(vec3 p,out int id)\n{\n    #define opmin(_d,_id) if((_tmp=(_d))<d){d=_tmp;id=(_id);}\n    id=0;\n    float d=MAX_LEN,_tmp;\n    vec3 q=p;\n    float zi=floor(q.z/3.);\n    q.z=mod(q.z,3.)-1.5;\n    q.xy=fold(q.xy*rot(zi*.1)-vec2(zi*.5,0),PI/4.);\n    q-=vec3(0,5,0);\n    float dc=min(p.y,-p.x+5.);\n    dc=min(dc,box(q,vec3(10,.7,1.))-.1);\n    dc=min(.5,dc);\n    opmin(dc,0)\n    opmin(heart(p-vec3(0,1.5,0)),1)\n    return d;\n}\nvoid applyMat(inout Hit hit,int id)\n{\n    hit.mat = mats[id];\n    vec2 uv=uvtrip(hit.pos,hit.normal);\n    if(id==0)\n    {\n        float f=fbm12(uv*2.);\n        hit.mat.color=vec3(1)*remapc(f,-.5,1.,.8,1.)*mix(.6,1.,smoothstep(.0,.1,length(fract(uv*.5+vec2(-.1)+f*1.)-.5)));\n        hit.mat.roughness=.8;\n    }\n}\nvec3 IBL(vec3 dir)\n{\n    vec3 c=temp2rgb(mix(10000.,20000.,remapc(dir.y,.0,1.,.0,1.)))*1.;\n    return c;\n}\nvec3 getNormal(vec3 p){vec2 e = vec2(EPS*.5,0.0);int _;return normalize(vec3(map(p + e.xyy,_) - map(p - e.xyy,_),map(p + e.yxy,_) - map(p - e.yxy,_),map(p + e.yyx,_) - map(p - e.yyx,_)));}\nbool raymarching(vec3 ro,vec3 rd,inout Hit hit)\n{\n    float d,len = .0;\n    rep(i,MAX_STEP)\n    {\n        int id;\n        d = map(ro + rd * len,id);\n        len += d;\n        if(d < EPS)\n        {\n            hit.len = len;\n            hit.pos = ro + rd * len;\n            hit.normal = getNormal(hit.pos);\n            applyMat(hit,id);\n            return true;\n        }\n        if(MAX_LEN < len)\n            break;\n    }\n    hit.len = MAX_LEN;\n    hit.pos = ro + rd * len;\n    hit.normal = vec3(0);\n    hit.mat = Material(vec3(1,0,0),vec3(1,0,0),.5,.5);\n    return false;\n}\nvec3 render(vec3 ro,vec3 rd)\n{\n    vec3 oro=ro,ord=rd;\n    vec3 col = vec3(0);\n    vec3 tp = vec3(1);//反射率 throughput\n    Hit fhit;\n    bool sky=false;\n    rep(i,MAX_DEPTH)\n    {\n        // russian roulette\n        float dice = sat(max(max(tp.x,tp.y),tp.z));\n        if(dice < rnd1())\n            break;\n        tp /= dice;\n\n        // raymarching\n        Hit hit;\n        bool ishit=raymarching(ro,rd,hit);\n        if(i==0)fhit=hit;\n        if(!ishit)\n        {\n            // no hit\n            col += tp * IBL(rd);\n            sky = true;\n            break;\n        }\n        if(length(hit.mat.emission) > 0.0)\n        {\n            // hit light\n            col += tp * hit.mat.emission;\n            break;\n        }\n        vec3 normal = hit.normal;\n        vec3 tangent,binormal;\n        tangentSpaceBasis(normal,tangent,binormal);\n        vec3 local_wo = worldToLocal(tangent,normal,binormal,-rd);\n        vec3 local_wi;\n        tp *= BSDF(local_wo,hit,local_wi);\n        vec3 wi = localToWorld(tangent,normal,binormal,local_wi);\n        // fake nee\n        wi=norm(mix(wi,SUN,.1));\n        rd = wi;\n        ro = hit.pos + rd * EPS * 10.;// avoid self-intersection\n    }\n    // apply fog\n    float fog=.0;\n    vec3 fogc=temp2rgb(15000.);\n    {\n        float stp=.5;\n        vec3 rp,rd=ord,ro=oro;   \n        int fogn=32;\n        rep(i,fogn)\n        {\n            vec3 ro=oro+ord*stp*(float(i)+rnd1()-.5);\n            int id;\n            float d,l=map(ro,id)+(rnd1()-.5)*stp*.25,v=1.;\n            if(l<.0)break;\n            rep(j,32)\n            {\n              vec3 rp=ro+SUN*l;\n              l+=d=map(rp,id);\n              v=min(v,exp2(4.+4.*pcg3(rp).x)*d/l);\n              if(d<.0){v=0.;break;}\n            }\n            fog+=v;\n        }\n        fog=fog/float(fogn)*4.;\n    }\n    //fog+=1.-exp(-fhit.len*.01);\n    fog=sat(fog);\n    return mix(col,fogc,fog);\n}\nvoid getcam(vec2 fc,float t,out vec3 ro,out vec3 rd)\n{\n    fc += rnd2() - .5;\n    vec2 res = iResolution.xy,asp = res / min(res.x,res.y);\n    vec2 uv = fc / res,suv = (uv * 2. - 1.) * asp;\n    ro = vec3(0,1.5,-5);\n    vec3 dir=vec3(0,0,1);\n    float fov = 60.;\n    float z = 1. / tan(fov * PI / 360.) - length(suv) *.2;\n    rd = getBNT(dir,.0)*norm(vec3(suv,z));\n    // dof\n    vec3 tar=ro+rd*5.;\n    ro+=(rnd3()-.5)*.05;\n    rd=norm(tar-ro);\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    seed = uint(iFrame);\n    vec4 col = vec4(0);\n    rep(i,ACC_COUNT)\n    {\n        vec3 ro,rd;\n        getcam(gl_FragCoord.xy,iTime,ro,rd);\n        col += vec4(render(ro,rd),1);\n    }\n    //if(any(isnan(col)))col=vec4(1,0,0,1);\n    fragColor = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0)*ACCUMULATE + vec4(col.rgb / col.a,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define time iTime\n#define sat(x) clamp(x,.0,1.)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define norm(x) normalize(x)\n#define remap(x,a,b,c,d) ((((x)-(a))/((b)-(a)))*((d)-(c))+(c))\n#define remapc(x,a,b,c,d) clamp(remap(x,a,b,c,d),min(c,d),max(c,d))\n#define linearstep(a, b, x) min(max(((x) - (a)) / ((b) - (a)), 0.0), 1.0)\nconst float PI = acos(-1.);\nconst float TAU = 2.0 * PI;\nstruct Material\n{\n    vec3 color;\n    vec3 emission;\n    float roughness;\n    float metallic;\n};\nstruct Hit\n{\n    vec3 pos;\n    vec3 normal;\n    float len;\n    Material mat;\n};\nvec3 pcg3(vec3 x)\n{\n    uvec3 v = floatBitsToUint(x);\n    v = v * 20240413u + 1212121212u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v ^= v >> 16u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return vec3(v) / float(-1u);\n}\nuint seed = 0u;\nvec3 rnd3()\n{\n    seed = seed * 747796405u + 2891336453u;\n    return pcg3(vec3(gl_FragCoord.xy,seed));\n}\nvec2 rnd2()\n{\n    return rnd3().xy;\n}\nfloat rnd1()\n{\n    return rnd3().x;\n}\n\nvoid tangentSpaceBasis(vec3 normal,out vec3 tangent,out vec3 binormal)\n{\n    vec3 d = vec3(0,1,0);\n    if(abs(normal.y) > 0.99)\n        d = vec3(0,0,1);\n    tangent = normalize(cross(normal,d));\n    binormal = normalize(cross(tangent,normal));\n}\n\nvec3 worldToLocal(vec3 tangent,vec3 normal,vec3 binormal,vec3 world)\n{\n    return vec3(dot(world,tangent),dot(world,normal),dot(world,binormal));\n}\n\nvec3 localToWorld(vec3 tangent,vec3 normal,vec3 binormal,vec3 local)\n{\n    return tangent * local.x + binormal * local.z + normal * local.y;\n}\n\nvec3 hemisphereSampling(vec2 uv)\n{\n    float theta = acos(uv.x);\n    float phi = 2.0 * PI * uv.y;\n    return vec3(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi));\n}\n\nvec3 cosineSampling(vec2 uv,out float pdf)\n{\n    float theta = acos(1.0 - 2.0 * uv.x) * 0.5;\n    float phi = 2.0 * PI * uv.y;\n    pdf = cos(theta) / PI;\n    return vec3(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi));\n}\nvec3 shlickFresnel(vec3 F0,float cosTheta)\n{\n    float delta = 1.0 - cosTheta;\n    return F0 + (1.0 - F0) * delta * delta * delta * delta * delta;\n}\nfloat GGX_Lambda(vec3 v,float alpha)\n{\n    float delta = 1.0 + (alpha * alpha * v.x * v.x + alpha * alpha * v.z * v.z) / (v.y * v.y);\n    return (-1.0 + sqrt(delta)) / 2.0;\n}\nfloat GGX_D(vec3 wm,float alpha)\n{\n    float term1 = wm.x * wm.x / (alpha * alpha) + wm.z * wm.z / (alpha * alpha) + wm.y * wm.y;\n    float term2 = PI * alpha * alpha * term1 * term1;\n    return 1.0 / term2;\n}\nfloat GGX_G1(vec3 w,float alpha)\n{\n    return 1.0 / (1.0 + GGX_Lambda(w,alpha));\n}\nfloat GGX_G2_HeightCorrelated(vec3 wi,vec3 wo,float alpha)\n{\n    return 1.0 / (1.0 + GGX_Lambda(wi,alpha) + GGX_Lambda(wo,alpha));\n}\nvec3 ggx_halfsampling(vec2 uv,float alpha)\n{\n    float theta = atan(alpha * sqrt(uv.x) / sqrt(max(1.0 - uv.x,0.0)));\n    float phi = 2.0 * PI * uv.y;\n    return vec3(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi));\n}\nvec3 sampleVisibleNormal(vec2 uv,vec3 wo,float alpha)\n{\n    vec3 strech_wo = normalize(vec3(wo.x * alpha,wo.y,wo.z * alpha));\n    float phi = 2.0 * PI * uv.x;\n    float z = ((1.0 - uv.y) * (1.0 + strech_wo.y) - strech_wo.y);\n    float sinTheta = sqrt(clamp(1.0 - z * z,0.0,1.0));\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 c = vec3(x,z,y);\n    vec3 h = c + strech_wo;\n\n    vec3 wm = normalize(vec3(h.x * alpha,h.y,h.z * alpha));\n    return wm;\n}\nfloat pdfLambert(vec3 wi)\n{\n    return wi.y / PI;\n}\nfloat pdfGGX(vec3 wo,vec3 wm,float alpha)\n{\n    return 0.25 * GGX_D(wm,alpha) * dot(wo,wm) / (dot(wm,wo) * abs(wo.y) * (1.0 + GGX_Lambda(wo,alpha)));\n}\nvec3 BSDF(vec3 wo,Hit hit,out vec3 wi)\n{\n\n    float alpha = clamp(hit.mat.roughness * hit.mat.roughness,0.001,1.);\n    vec3 F0 = mix(vec3(0.04),hit.mat.color,hit.mat.metallic);\n\n    float dif_weight = (1. - hit.mat.metallic);\n    float spec_weight = 1.;\n    float sum_weight = dif_weight + spec_weight;\n\n    float cd = dif_weight / sum_weight;\n    float cs = spec_weight / sum_weight;\n\n    vec3 wm;\n    float pdf_diffuse;\n    float pdf_specular;\n    if(rnd1() < cd)\n    {\n        wi = cosineSampling(rnd2(),pdf_diffuse);\n        wm = normalize(wi + wo);\n        pdf_specular = pdfGGX(wo,wm,alpha);\n    }\n    else\n    {\n        wm = sampleVisibleNormal(rnd2(),wo,alpha);\n        wi = reflect(-wo,wm);\n        pdf_specular = pdfGGX(wo,wm,alpha);\n        pdf_diffuse = pdfLambert(wi);\n    }\n\n    if(wi.y < .0)\n    {\n        return vec3(0);\n    }\n\n    float pdf = cd * pdf_diffuse + cs * pdf_specular;\n\n    vec3 F = shlickFresnel(F0,dot(wi,wm));\n    float D = GGX_D(wm,alpha);\n    float G = GGX_G2_HeightCorrelated(wi,wo,alpha);\n\n    vec3 lambert = hit.mat.color / PI;\n\n    vec3 bsdf = lambert * (vec3(1) - F) * (1. - hit.mat.metallic) + F * D * G / (4. * wo.y * wi.y);\n\n    float cosine = wi.y;\n\n    return bsdf * cosine / pdf;\n}\nfloat box(vec3 p,vec3 s)\n{\n    vec3 d = abs(p) - s;return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n// from:https://www.shadertoy.com/view/4sc3D7\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\nvec3 temp2rgb(float temperature)\n{\n    // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \n    mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690), vec3(0.0, 1669.5803561666639, 2575.2827530017594), vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690), vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594), vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275));\n    return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), vec3(1.0), smoothstep(1000.0, 0.0, temperature));\n}\nvec2 uvtrip(vec3 P, vec3 N)\n{\n    N = N / dot(vec3(1), N);\n    return N.x * P.zy + N.y * P.xz + N.z * P.xy;\n}\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n// https://www.shadertoy.com/view/Xs3fR4\n// -1~1\nfloat perlin12(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f); // smoothstep\n\n    float v = mix(mix(hash12(i + vec2(0, 0)), hash12(i + vec2(1, 0)), f.x), mix(hash12(i + vec2(0, 1)), hash12(i + vec2(1, 1)), f.x), f.y);\n    return 2. * v - 1.;\n}\n// -1~1\nfloat fbm12(vec2 p)\n{\n    float v = 0., a = .5;\n    mat2 R = rot(.37);\n\n    for(int i = 0; i < 9; i++, p *= 2., a /= 2.) p *= R, v += a * perlin12(p);\n\n    return v;\n}\n// ortho basis\n// https://en.wikipedia.org/wiki/Osculating_plane\nmat3 getBNT(vec3 T,float cr)\n{\n    T = normalize(T);\n    vec3 N = vec3(sin(cr), cos(cr), 0.0);\n    vec3 B = normalize(cross(N, T));\n    N = normalize(cross(T, B));\n    return mat3(B, N, T);\n}\nvec2 fold(vec2 p, float a)\n{\n    vec2 v = vec2(cos(a), sin(a));\n    p -= 2.0 * min(0.0, dot(p, v)) * v;\n    return p;\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec2 pmod(vec2 suv,float div)\n{\n    float shift=.0;\n    float a = mod(atan(suv.y,suv.x) + shift,TAU / div) - PI / div;\n    return vec2(cos(a), sin(a)) * length(suv);\n}","name":"Common","description":"","type":"common"}]}