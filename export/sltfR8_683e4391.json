{"ver":"0.1","info":{"id":"sltfR8","date":"1662661374","viewed":254,"name":"Mandelbulb.... hmmm","username":"ShelbyLynn","description":"mandelbulb","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 de(vec3 p) {\n    vec3 c = p.xzy;\n    vec3 z = c;\n    float n = 8.;\n    float r2 = 0.;\n    float dr = 1.;\n    float s = 0.;\n    float tia = 0.;\n    int iters = 6;\n    for (int i =0;i<iters;i++)\n    {\n        r2 = dot(z,z);\n        if (r2 >32.) break;\n        dr = pow(r2, (n-1.)/2.) * n * dr + 1.;\n        \n        float theta = acos(z.z / max(0.001,sqrt(r2)));\n        float phi = atan(z.y/ (sign(z.x)*max(0.01, abs(z.x))));\n        if (i > 0)\n        {\n            tia += 0.5 + 0.5 * cos(2.*theta) * sin(2.*phi);\n        }\n        phi *= n;\n        theta *= n;\n        float zn = pow(r2,n/2.);\n        z = (zn * vec3(sin(theta)*cos(phi),sin(theta) * sin(phi),cos(theta))) + c;\n        s += exp(-r2);\n    }\n    return vec2(.25* log(sqrt(r2)) / max(0.0001,abs(log(sqrt(r2) / max(0.001,abs(dr))))), tia /float(iters));\n}\n\nvec3 compute_norm(vec3 p, float d, float epsilon) \n{\n    return vec3(de(p - vec3(epsilon,0.,0.)).x,\n    de(p - vec3(0.,epsilon,0.)).x,\n    de(p - vec3(0.,0.,epsilon)).x)-d;\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    float d = 0.;\n    float min_d = 1000.;\n    vec3 p = ro;\n    float mind = 0.01;\n    \n    vec3 p_light = vec3(4,-8.,2.);\n    float scale = 0.125;\n    for (int step = 0; step <64; step++)\n    {\n        vec2 e =scale*abs( de(p));\n        if (e.x < min_d * sqrt(d)) {\n            min_d = e.x;\n        }\n        if (e.x < mind)\n        {\n            d -= mind * 2.;\n            p = ro + rd * (d+e.x);\n            vec2 ne =scale* abs(de(p));\n            vec3 norm = compute_norm(p,ne.x,mind);\n            \n            float lighting = dot(norm, p_light-p) *2.;\n            \n            float idk =ne.y*100.;\n            float r = (cos(idk) + 1.) / 2.;\n            float b = (sin(idk) + 1.) / 2.;\n            float g = (r + b) / 2.;\n            \n            if (lighting > 0.) {\n                return vec3(r,g,b)*lighting;\n            } else {\n            return vec3(r,g,b)/2.;\n               \n            }\n            \n        }\n        d += e.x;\n        p = ro + rd * d;\n        if (d > 8.) {\n            break;\n        }\n    }\n\n    return vec3(0.);\n}\nfloat haltonb(int i, int b)\n{\n    float res = 0.;\n    float f = 1.;\n    int steps = 0;\n    while (i > 0 && steps < 8)\n    {\n        f = f / float(b);\n        res += (f * float(i%b));\n        i = i / b;\n        steps += 1;\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    \n    vec3 world_u = vec3(0.,1.,0.);\n    \n    vec3 cam_p = vec3(0.,1.0,0.);\n    float t = iTime/2.;\n    vec3 cam_o = vec3(cos(t) * 4.0,2.75,sin(t) * 4.0);\n    \n    vec3 cam_f = normalize(cam_p-cam_o );\n    vec3 cam_r = (cross(world_u, cam_f));\n    vec3 cam_u = (cross(cam_f,cam_r));\n    \n    vec3 col = vec3(0.);\n    \n    int samples = 6;\n    \n    for (int s = 0; s <samples; s++)\n    {\n        \n        vec2 offset = vec2(haltonb(s+1,2),haltonb(s+1,3)) - 0.5;\n        vec2 uv = (fragCoord + 0.5f + offset)/iResolution.xy;\n        uv.y*= (iResolution.y/iResolution.x);\n    vec2 px = (uv - 0.5) * 1.f;\n    vec3 rd = normalize(cam_r * px.x + cam_u* px.y + cam_f * 1.0);\n    \n    vec3 ro = cam_o;\n\n    col += pow(render(ro,rd), vec3(1. / 2.2));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(pow(col/float(samples), vec3(2.2)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}