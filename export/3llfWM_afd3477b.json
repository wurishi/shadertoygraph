{"ver":"0.1","info":{"id":"3llfWM","date":"1596886720","viewed":113,"name":"raymarching test01","username":"eclypse","description":"raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat sineCrazy(vec3 p){\n    return (sin(p.x) + sin(p.y) + sin(p.z)) / 3.0;\n}\n\nfloat sphere(vec3 p){\n\treturn length(p) - 0.75;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene(vec3 p){\n    vec3 p1 = rotate(p, vec3(1.0), iTime);\n    \n    float scale = 10.0 + 10.0 * abs(sin(iTime * 0.5));\n    \n    return max( sphere(p), sineCrazy(p1 * scale) / scale );\n}\n\nvec3 getNormal(vec3 p){\n    vec2 o = vec2(0.001, 0.0);\n    \n    return normalize(vec3( \n        scene(p + o.xyy) - scene(p - o.xyy),\n    \tscene(p + o.yxy) - scene(p - o.yxy),\n    \tscene(p + o.yyx) - scene(p - o.yyx)\n    ));\n    \n}\n\nvec3 getColor(float amount){\n\tvec3 col = 0.5 + 0.5 * cos(6.28318530718 * (vec3(0.2, 0.0, 0.0) + amount * vec3(1.0, 1.0, 0.5)));\n\treturn col * amount;\n}\n\nvec3 getColorAmount(vec3 p){\n    float amount = clamp((1.5 - length(p)) / 2.0, 0.0, 1.0);\n\tvec3 col = 0.5 + 0.5 * cos(6.28319 * (vec3(0.2, 0.0, 0.0) + amount * vec3(1.0, 1.0, 0.5)));\n\treturn col * amount;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    uv.x *= iResolution.x / iResolution.y;\n\t\n    vec3 camPos = vec3(0.0, 0.0, 2.);\n    \n    vec3 ray = normalize(vec3(uv, -1.0));\n    \n    vec3 rayPos = camPos;\n    \n    vec3 light = vec3(-1.0, 1.0, 1.0);\n    \n    float curDist = 0.0;\n    float rayLen = 0.0;\n    \n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i <= 64; i++){\n    \tcurDist = scene(rayPos);\n        rayLen += 0.6 * curDist;\n        \n        rayPos = camPos + ray * rayLen;\n\n        color += 0.2 * vec3(getColorAmount(rayPos));\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}