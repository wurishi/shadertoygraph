{"ver":"0.1","info":{"id":"4XKGWV","date":"1718285751","viewed":51,"name":"desert walk sunset","username":"milesd","description":"walking thru the desert . ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sun","desert","walk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D Desert on Mars with Oases Shader\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415928\n\n// Perlin noise function\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix(dot(hash(i.xy), f.xy), dot(hash(i.xy + vec2(1.0, 0.0)), f.xy - vec2(1.0, 0.0)), u.x),\n                   mix(dot(hash(i.xy + vec2(0.0, 1.0)), f.xy - vec2(0.0, 1.0)), dot(hash(i.xy + vec2(1.0, 1.0)), f.xy - vec2(1.0, 1.0)), u.x), u.y),\n               mix(mix(dot(hash(i.xy + vec2(0.0, 0.0)), f.xy - vec2(0.0, 0.0)), dot(hash(i.xy + vec2(1.0, 0.0)), f.xy - vec2(1.0, 0.0)), u.x),\n                   mix(dot(hash(i.xy + vec2(0.0, 1.0)), f.xy - vec2(0.0, 1.0)), dot(hash(i.xy + vec2(1.0, 1.0)), f.xy - vec2(1.0, 1.0)), u.x), u.y), u.z);\n}\n\nfloat map(vec3 p) {\n    // Scale the coordinates to lower the frequency of the noise\n    float frequency1 = 0.05;\n    float frequency2 = 0.1;\n    float height = 8.0 * noise(p.xz * frequency1) * 2.0 + noise(p.xz * frequency1 * 0.5) * 1.0;\n    height += 2.0 * noise(p.xz * frequency2) * 2.0 + noise(p.xz * frequency2 * 0.5) * 1.0;\n    height += -5.0 + 3.0 * cos(p.x * 0.1 + PI);\n    \n    // Create oases by subtracting spheres from the terrain\n    float oasis1 = max(0.0, 1.0 - length(p.xz - vec2(2.0, 2.0)));\n    float oasis2 = max(0.0, 1.0 - length(p.xz - vec2(-3.0, -1.0)));\n    float oasis = max(oasis1, oasis2);\n    \n    // Combine dune height and oasis effect\n    return p.y - height * (1.0 - oasis);\n}\n\nvec3 getNormal(vec3 p) {\n    float d = 0.001;\n    return normalize(vec3(\n        map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n        map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n        map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius + 0.5*noise3(vec3(p.x+iTime,p.y+iTime,p.z+iTime));\n}\n\nvec2 mapWithSphere(vec3 p, vec3 sunPos) {\n    float terrainDist = map(p);\n    float sunDist = sphereSDF(p, sunPos, 5.0);\n    return vec2(min(terrainDist, sunDist), sunDist);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, vec3 sunPos) {\n    float dO = 0.0;\n    int hitType = -1;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        vec2 dS = mapWithSphere(p, sunPos);\n        dO += dS.x * 0.5;\n        if (dO > MAX_DIST || dS.x < SURF_DIST) {\n            hitType = dS.x < dS.y ? 0 : 1;\n            break;\n        }\n    }\n    return vec2(dO, hitType);\n}\n\nfloat shadowMarch(vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.05;\n    for (int i = 0; i < 50; i++) {\n        float h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += h;\n        if (h < 0.001) break;\n    }\n    return mix(res, 0.5, 0.5); // Adjust the second parameter to make shadows less intense\n}\n\nvec3 getColor(vec3 p, int hitType, vec3 lightDir) {\n    if (hitType == 1) {\n        // Sun color with fiery effect\n        float noiseValue = noise3(p * 0.5 + iTime);\n        vec3 sunColor = vec3(1.0, 0.3, 0.2) * (1.0 + 0.5 * noiseValue);\n        float glow = 1.0 - smoothstep(0.0, 5.0, abs(sphereSDF(p, vec3(0.0, 12.0, -40.0), 5.0)));\n        sunColor *= glow;\n        return sunColor;\n    }\n    \n    // Desert color\n    vec3 color = vec3(1.0, 0.6, 0.3); // Brighter desert color\n    \n    // Add oasis color\n    if (length(p.xz - vec2(2.0, 2.0)) < 0.5 || length(p.xz - vec2(-3.0, -1.0)) < 0.5) {\n        color = mix(color, vec3(0.0, 0.5, 1.0), 0.5); // Brighter water color\n    }\n    \n    // Lighting\n    vec3 normal = getNormal(p);\n    float diff = 3.0*max(dot(normal, lightDir), 0.0); // Adjust brightness\n    float shadow = shadowMarch(p + normal * SURF_DIST * 2.0, lightDir);\n    color *= diff * shadow;\n\n    // Add sand texture using noise\n    float texture = noise(p.xz * 1.0);\n    color *= texture * 0.2 + 0.8;\n    \n    return color;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 normal) {\n    float ao = 0.0;\n    float scale = 1.0;\n    for (int i = 1; i <= 5; i++) {\n        float dist = float(i) * 0.1;\n        ao += dist - map(p + normal * dist) * scale;\n        scale *= 0.5;\n    }\n    return clamp(1.0 - ao * 0.5, 0.0, 1.0); // Adjust AO strength\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 5.0, iTime * -5.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1.0));\n    \n    // Move the sun along with the terrain\n    vec3 sunPos = vec3(0.0, 12.0, -40.0 + iTime * -5.0);\n    vec3 lightDir = normalize(sunPos - ro);\n    \n    // Raymarch the terrain and sphere\n    vec2 marchResult = rayMarch(ro, rd, sunPos);\n    float d = marchResult.x;\n    int hitType = int(marchResult.y);\n    vec3 p = ro + rd * d;\n    vec3 color = vec3(0.0); // Initialize color to black for background\n\n    if (d <= MAX_DIST) {\n        p = ro + rd * d;\n        color = getColor(p, hitType, lightDir);\n\n        // Apply ambient occlusion\n        vec3 normal = getNormal(p);\n        float ao = ambientOcclusion(p, normal);\n        color *= ao + 0.5; // Adjust AO influence\n    \n        // Add fog based on distance\n        float dist = length(ro - p);\n        vec3 fogColor = vec3(0.9, 0.6, 0.4); // Sandy fog color\n        float fogAmount = smoothstep(10.0, 70.0, dist);\n        fogAmount *= 0.5;\n        color = mix(color, fogColor, fogAmount);\n    }\n\n    // Apply sun color\n    if (hitType == 1) {\n        float glow = 1.0 - smoothstep(0.0, 5.0, abs(sphereSDF(p, sunPos, 5.0)));\n        float noiseValue = noise3(p * 0.2 + iTime*0.5);\n        vec3 sunColor = vec3(1.0, 0.3, 0.2) * (1.0 + 0.5 * noiseValue);\n        color = sunColor * glow;\n    }\n\n    // Blend with sky color for areas not hit\n    if (d > MAX_DIST || hitType == -1) {\n        vec3 skyColor = mix(vec3(0.9, 0.3, 0.2), vec3(1.0, 0.6, 0.3), uv.y);\n        color = mix(color, skyColor, 0.5);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}