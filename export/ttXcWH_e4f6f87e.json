{"ver":"0.1","info":{"id":"ttXcWH","date":"1591951735","viewed":137,"name":"Programmable SDF Scene Machine","username":"sdfgeoff","description":"A virtual machine that takes a scene representation from a uniform buffer and draws it. Too slow to be useful, but a fun experiment. \n\nSimilar to how a scripting language is run by a program, this shader runs a \"script\" from a uniform buffer on the GPU.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cad","bytecode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This was a technical demonstrator for a SDF CAD program I\n// worked on for a bit. It's goal was to determine if a programmable\n// shader was feasible. In relaity, performance was too low so I\n// abandoned the project.\n//\n// Project as standalone webapp (no UI or anything) available\n// https://github.com/sdfgeoff/sdf_designer_failed\n//\n// The idea was that the variable \"scene_description\" would\n// be a uniform that could be altered at runtime.\n//\n// I suspect the reason that performance is so low is because\n// every pixel has to sample all the elements in the scene\n// description array, which can be significant.\n//\n// Another possible performance limiter is that the shader includes\n// many conditional jump instructions, and although all pixels \n// follow the same path the opengl compiler may not recognise this.\n\n\n// SDF Rendering parameters\nconst int MAX_STEPS = 30;\nconst float SURFACE_DISTANCE = 0.001;\nconst float VIEW_DISTANCE = 20.0;\n\n\n// Core instructions\nconst float INSTRUCTION_STOP = (0.0); // Program stops executing\nconst float INSTRUCTION_NEW_ENTITY = (1.0);  // Current transforms are discarded so a new entity can be drawn\n\n\n// Shapes\nconst float INSTRUCTION_SPHERE = (100.0);  // Next data is the radius\nconst float INSTRUCTION_BOX = (101.0);  // Next three data items are the box dimensions\n\n// Transformations\nconst float INSTRUCTION_TRANSLATE = (200.0); // Next three data items are translations\nconst float INSTRUCTION_ROTATE = (201.0);  // Next three data items are euler angles\n\n\n// Operations\nconst float INSTRUCTION_UNION = (300.0); // Join the current entity to the scene\nconst float INSTRUCTION_DIFFERENCE = (301.0); // Difference the current entity to the scene\nconst float INSTRUCTION_INTERSECT = (302.0); // Intersect the current entity to the scene\n\n\n// This variable contains the scene that we want\n// to draw! Have a play with it.\n// Normally this would be a uniform passed into the\n// shader from main memory\nfloat[] scene_description = float[](\n    \n    INSTRUCTION_NEW_ENTITY, // New Entity\n    INSTRUCTION_TRANSLATE,  // translate\n    0.0, // x\n    0.0, // y\n    -5.0, // z\n    INSTRUCTION_ROTATE,     // rotate\n    0.0, // x\n    1.0, // y\n    0.5, // z\n    INSTRUCTION_BOX,        // box object\n    1.0, // x\n    0.5, // y\n    1.0, // z\n    INSTRUCTION_UNION,      // union to existing SDF\n\n    \n    INSTRUCTION_NEW_ENTITY, // New Entity\n    INSTRUCTION_TRANSLATE,  // translate\n    -1.0, // x\n    0.0, // y\n    -5.0, // z\n    INSTRUCTION_SPHERE,     // sphere object\n    1.0, // radius\n    INSTRUCTION_UNION,      // union\n\n    \n    INSTRUCTION_NEW_ENTITY, // New Entity\n    INSTRUCTION_TRANSLATE,  // translate\n    0.0, // x\n    -1.0, // y\n    -4.0, // z\n    INSTRUCTION_SPHERE,     // sphere object\n    1.0, // radius\n    INSTRUCTION_DIFFERENCE, // difference\n\n    INSTRUCTION_STOP // End\n);\n\n\nstruct surface_t {\n    int surface_id;\n    float sdf;\n};\n\n\nsurface_t sphere_sdf(vec3 query_point, int id, float sphere_radius) {\n    return surface_t(\n        id,\n        length(query_point)  - sphere_radius\n    );\n}\n\nsurface_t box_sdf(vec3 query_point, int id, vec3 dimensions) {\n\tvec3 q = abs(query_point) - dimensions;  \n  \n    return surface_t(\n        id,\n        length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)\n    );\n}\n\nsurface_t surface_union(surface_t surface_1, surface_t surface_2) {\n    // Join surface_1 to surface_2\n    if (surface_1.sdf < surface_2.sdf){\n        return surface_1;\n    } else {\n     \treturn surface_2;   \n    }\n}\nsurface_t surface_intersect(surface_t surface_1, surface_t surface_2) {\n    // Find the volume both surface occupy\n    if (surface_1.sdf > surface_2.sdf){\n        return surface_1;\n    } else {\n     \treturn surface_2;   \n    }\n}\n\nsurface_t surface_difference(surface_t surface_1, surface_t surface_2) {\n    // subtract surface_2 from surface_1\n    // invert surface 2:\n    surface_2.sdf = -surface_2.sdf;\n    return surface_intersect(surface_1, surface_2);\n}\n\n\n\nvec3 transform(vec3 inp, mat4 offset) {\n    return (offset * vec4(inp, 1.0)).xyz;\n}\n\nmat4 translation(vec3 trans) {\n    // Construct a translation matrix\n    return mat4 (\n        vec4(1.0, 0.0, 0.0, 0.0), \n        vec4(0.0, 1.0, 0.0, 0.0), \n        vec4(0.0, 0.0, 1.0, 0.0), \n        vec4(trans.x, trans.y, trans.z, 1.0)\n    );\n    \n}\n\nsurface_t world(vec3 world_position) {\n\t\n\t\n\tint pointer = 0;\n\tint entity_id = 0;\n\tsurface_t scene_sdf = surface_t(0, 9999.9);\n\tsurface_t obj_sdf = surface_t(0, 9999.9);\n\tvec3 view_point = world_position;\n\t\n\t\n\tfor(int i = 0; i < 9999; i++) {\n\t\tfloat data = scene_description[pointer];\n\t\tif (data == INSTRUCTION_STOP) {\n\t\t\t// Scene ends\n\t\t\tbreak;\n\t\t} else if (data == INSTRUCTION_NEW_ENTITY) {\n\t\t\t// New entity to work with\n\t\t\tview_point = world_position;\n\t\t\tentity_id += 1;\n\t\t\tpointer += 1;\n\t\t\t\n\n\t\t} else if (data == INSTRUCTION_TRANSLATE) {\n\t\t\t// Perform translation\n\t\t\tvec3 offset = vec3(\n\t\t\t\tscene_description[pointer+1],\n\t\t\t\tscene_description[pointer+2],\n\t\t\t\tscene_description[pointer+3]\n\t\t\t);\n\t\t\tview_point = transform(view_point, translation(offset));\n\t\t\tpointer += 4;\n\t\t\n\t\t} else if (data == INSTRUCTION_ROTATE) {\n\t\t\t// Perform translation\n\t\t\tvec3 offset = vec3(\n\t\t\t\tscene_description[pointer+1], // Euler X\n\t\t\t\tscene_description[pointer+2], // Euler Y\n\t\t\t\tscene_description[pointer+3] // Euler Z\n\t\t\t);\n\t\t\tvec3 c = cos(offset);\n\t\t\tvec3 s = sin(offset);\n\t\t\t\n\t\t\tmat4 mat = mat4(\n\t\t\t\tvec4(c.z*c.x, -c.z*s.x*c.y + s.z*s.y, c.z*s.x*s.y + s.z*c.y, 0.0),\n\t\t\t\tvec4(s.x, c.x*c.y, -c.x*s.y, 0.0),\n\t\t\t\tvec4(-s.z*c.x, s.z*s.x*c.y + c.z*s.y, -s.z*s.x*s.y + c.z*c.y, 0.0),\n\t\t\t\tvec4(0.0, 0.0, 0.0, 1.0)\n\t\t\t);\n\t\t\t\n\t\t\tview_point = transform(view_point, mat);\n\t\t\tpointer += 4;\n\t\t\n\t\t\n\t\t} else if (data == INSTRUCTION_SPHERE) {\n\t\t\tfloat radius = scene_description[pointer+1];\n\t\t\tobj_sdf = sphere_sdf(view_point, entity_id, radius);\n\t\t\tpointer += 2;\n\t\t} else if (data == INSTRUCTION_BOX) {\n\t\t\tvec3 dimensions = vec3(\n\t\t\t\tscene_description[pointer+1],\n\t\t\t\tscene_description[pointer+2],\n\t\t\t\tscene_description[pointer+3]\n\t\t\t);\n\t\t\tobj_sdf = box_sdf(view_point, entity_id, dimensions);\n\t\t\tpointer += 4;\n\n\n\t\t} else if (data == INSTRUCTION_UNION) {\n\t\t\tscene_sdf = surface_union(scene_sdf, obj_sdf);\n\t\t\tpointer += 1;\n\t\t} else if (data == INSTRUCTION_DIFFERENCE) {\n\t\t\tscene_sdf = surface_difference(scene_sdf, obj_sdf);\n\t\t\tpointer += 1;\n\t\t} else if (data == INSTRUCTION_INTERSECT) {\n\t\t\tscene_sdf = surface_intersect(scene_sdf, obj_sdf);\n\t\t\tpointer += 1;\n\t\t}\n\t}\n    \n    return scene_sdf;\n    \n    \n}\n\n\nvec3 gen_color(float t){\n\treturn vec3(\n\t\t0.5 + 0.5 * cos(2.0 * 3.1415 * (1.0 * t + 0.0)),\n\t\t0.5 + 0.5 * cos(2.0 * 3.1415 * (1.0 * t + 0.33)),\n\t\t0.5 + 0.5 * cos(2.0 * 3.1415 * (1.0 * t + 0.66))\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // camera coords (from -1 to 1)\n    vec2 cam_coords = (fragCoord/iResolution.xy - vec2(0.5)) * 2.0;\n    cam_coords.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray_start_position = vec3(cam_coords, 0.0);\n    vec3 ray_direction = vec3(0.0, 0.0, 1.0);\n        \n    vec3 sample_point = ray_start_position;\n    surface_t results = world(sample_point);\n    float dist = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i += 1) {\n        dist += results.sdf;\n        sample_point += ray_direction * results.sdf;\n        results = world(sample_point);\n        \n        if (results.sdf < SURFACE_DISTANCE || dist > VIEW_DISTANCE) {\n\t\t\tbreak;\n\t\t}\n    }\n    \n    \n    // There is banding caused by the difference in direction between\n    // calculation of normals of adjacent 2x2 pixel squares.\n    // It would be better to do this in a separate pass or\n    // with some other method\n    vec3 normal = vec3(\n\t\tdFdx(dist),\n\t\tdFdy(dist),\n\t\t0.0\n    );\n    \n    normal *= iResolution.y / 10.0;\n    //normal = pow(normal, vec3(0.5));\n    normal.z = sqrt(1.0-dot(normal.xy, normal.xy));\n    \n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (results.sdf < SURFACE_DISTANCE) {\n        // We hit a surface\n        \n        float lighting = dot(normal, vec3(0.2, 0.3, 0.7));\n        lighting = pow(lighting, 2.0);\n        \n        //~ color = vec4(\n            //~ normal.x,\n            //~ normal.y,\n            //~ float(results.surface_id),\n            //~ dist\n        //~ );\n\n        color = vec4(gen_color(float(results.surface_id) / 4.0), 1.0);\n        color *= vec4(vec3(lighting), 1.0);\n        color = clamp(color, 0.0, 1.0);\n    }\n\n    // Output to screen\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}