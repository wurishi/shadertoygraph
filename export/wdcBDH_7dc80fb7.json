{"ver":"0.1","info":{"id":"wdcBDH","date":"1604963020","viewed":311,"name":"Misty Jungle","username":"athibaul","description":"Here is a cheap height-dependent fog with an explicit formula.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fog","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nfloat T(vec2 p)\n{\n    return textureLod(iChannel0,p,0.).r-0.5;\n}\n\n\nfloat map(vec3 p)\n{\n    float d = p.z;\n    // Warp coordinates\n    p.x += T(p.xy*0.005)*5.;\n    p.y += T(p.xy*0.007+0.5)*5.;\n    // Add relief\n    d -= T(p.xy*0.1*mat2(.6,.8,-.8,.6));\n    d -= T(p.xy*0.02)*2.;\n    \n    return d;\n}\n\nfloat bmap(vec3 p)\n{\n    return map(p) - T(p.xy*4.*mat2(.6,.8,-.8,.6))*0.01;\n}\n\n\n\nvec3 normal( vec3 p, float eps)\n{\n    vec2 e = eps * vec2(1, -1);\n    return normalize(\n          e.xxx * bmap(p+e.xxx)\n        + e.xyy * bmap(p+e.xyy)\n        + e.yxy * bmap(p+e.yxy)\n        + e.yyx * bmap(p+e.yyx)\n    );\n}\n\n\n\n\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    float d, t=0.;\n    for(int i=0; i<256;i++)\n    {\n        d=map(ro+t*rd);\n        if(d<0.001+0.006*t||t>100.) break;\n        t += d*0.28;\n    }\n    return t;\n}\n\n\nfloat fogTransmittance(vec3 ro, vec3 rd, float t, float fog_a, float fog_b)\n{\n    // Calculate transmittance of fog along a ray.\n    // Density depends only on z:\n    // density = fog_a * exp(-fog_b * z).\n    float sigma_o = fog_a * exp(-fog_b * ro.z);\n    float lambda = -fog_b*rd.z;\n    float T = exp(sigma_o/lambda * (1.0-exp(lambda*t)));\n    return T;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    float t = raymarch(ro, rd);\n\tvec3 col = vec3(0.0);\n    \n    \n    vec3 skyCol = vec3(0.5,0.7,1.0);\n    vec3 sunCol = vec3(1.0,0.7,0.4);\n    // Render surface\n    if(t < 100.)\n    {\n        vec3 p = ro+t*rd;\n        float eps = 0.003 + 0.0005*t;\n        vec3 n = normal(p, eps);\n        \n        // Pick a surface color\n        vec3 green = vec3(0.25, 0.5, 0.15) + vec3(0.2,0.7,0.2)*T(p.xy*0.1)\n            + vec3(0.2,0.2,0.0)*T(p.xy*0.07); // Many shades of green\n        vec3 surfCol1 = vec3(0.5), // Rocks\n            surfCol2 = green*1.1;\n        // Alternate patches of grass and rocks, with more rocks on slopes\n        float grassy = smoothstep(0.2,-0.2,T(p.xy)+1.-n.z*1.2);\n        vec3 surfCol = mix(surfCol1, surfCol2, grassy);\n        \n        // Shade surface\n        col += surfCol * (0.5+0.5*n.z) * 0.4 * skyCol;\n        vec3 sunDir=normalize(vec3(1));\n        col += surfCol * pow(vec3(clamp(dot(n, sunDir),0.,1.)),vec3(1.,1.15,1.3)) * sunCol * 2.;\n    }\n    else\n    {\n        col = skyCol;\n    }\n    \n    // Add height-dependent fog\n    {\n        float T1 = fogTransmittance(ro,rd,t,0.02,5.0);\n        float T2 = fogTransmittance(ro,rd,t,0.01,0.2);\n        // Each transmittance is exact, \n        // but combining them with a product is an approximation\n        float T = T1*T2;\n        vec3 fogCol = 2.*sunCol + skyCol;\n        // Extinction should be modelled by using a larger density\n        // Instead we use the approximation that multiplying the density\n        // is equivalent to raising transmittance to a power.\n        col = col*pow(T,2.) + fogCol*(1.-T);\n    }\n    \n    col = max(col, 0.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,iTime,2);\n    vec3 camFwd = normalize(vec3(0,1,-0.3));\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.5*(uv.x*camRight+uv.y*camUp));\n    \n    \n    vec3 col = render(ro, rd);\n    \n    #if 0\n    // Basic tone mapping\n    col = 1.-exp(-col);\n    #else\n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col *= 0.6;\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    #endif\n    \n    \n    col = pow(col, vec3(1./2.2)); // gamma\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}