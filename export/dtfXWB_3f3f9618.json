{"ver":"0.1","info":{"id":"dtfXWB","date":"1729308671","viewed":138,"name":"Erodead","username":"Kushulain","description":"Just experimenting with erosion. :)","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["terrain","perlinnoise","normalmap","moutain","realistic","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//From Inigo Quilez https://www.shadertoy.com/view/XslGRr\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    x = p + f;\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //col.r =col.g=col.b = Perlin(vec3(fragCoord, iTime));\n\n    fragColor.xyzw = vec4(0.,0.,0.,0.);\n    // Output to screen\n    \n    //flow speed\n    fragColor.y = length(texture(iChannel1,fragCoord/iResolution.xy).xy) * 0.5;\n    \n    //water amount\n    fragColor.x = texture(iChannel1,fragCoord/iResolution.xy).z ;\n    \n    \n    vec4 heightBuffer = texture(iChannel0,fragCoord/iResolution.xy);\n    vec4 waterBuffer = texture(iChannel1,fragCoord/iResolution.xy);\n    \n    GroundInfo ground = GetGroundInfo(fragCoord, iResolution, iChannel0);\n    \n    \n    vec3 lightNormal = ground.normal;\n    \n    if (ground.totalHeight < SEA_LEVEL)\n        lightNormal = vec3(0.0,0.0,1.0);\n    \n    vec3 light = dot(lightNormal, vec3(0.9,0.9,0.7)) * vec3(0.9,0.9,0.9)*1.5;\n    \n    fragColor.xyz = light;\n    \n    float height = smoothstep(SEA_LEVEL, MOUNTAINS_LEVEL, ground.totalHeight);\n    \n    float sand = max(0.0, 1.0 - abs(0.0 - height*2.0));\n    float green = max(0.0, 1.0 - abs(0.3 - height*2.0));\n    float rocks = max(0.0, 1.0 - abs(0.6 - height*2.0));\n    float snow = max(0.0, 1.0 - abs(1.0 - height*2.0));\n    \n    float total = max(0.1, sand + green + rocks + snow);\n    sand /= total;\n    green /= total;\n    rocks /= total;\n    snow /= total;\n    \n    vec3 diffuseColor = sand * vec3(0.9,0.8,0.1);\n    diffuseColor += green * vec3(0.2,0.8,0.3);\n    diffuseColor += rocks * vec3(0.3,0.5,0.4);\n    diffuseColor += snow * vec3(0.9,0.9,0.9);\n    \n    diffuseColor *= 0.5;\n    \n    vec3 waterColor = vec3(0.8,0.8,1.0);\n    \n    if (ground.totalHeight < SEA_LEVEL)\n        diffuseColor = waterColor;\n        \n    //waterColor = mix(waterColor, vec3(1.0,1.0,1.0), length(waterBuffer.xy));\n        \n    diffuseColor = mix(diffuseColor, waterColor, min(1.0, waterBuffer.z));\n    \n    fragColor.xyz = diffuseColor * light;\n    //fragColor.xyz = vec3(height,height,height);\n    //fragColor.xyz = vec3(waterBuffer.z,waterBuffer.z,waterBuffer.z)*0.01;\n    \n    //fragColor.x = length(waterBuffer.xy);\n    //fragColor.y = length(waterBuffer.xy);\n    //fragColor.z = length(waterBuffer.xy);\n    \n    \n    //fragColor.xyz = vec3(ground.totalHeight,ground.totalHeight,ground.totalHeight) * 5.0;\n    //fragColor.xyz = ground.normal * 0.5 + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EROSION_SPEED 0.002\n#define HEIGHT 0.2\n#define NOISE_IMAGE_SIZE 256.0\n#define SCALE 0.4/NOISE_IMAGE_SIZE\n#define PERLIN_STEPS 16\n#define GOLDEN_RATIO 1.6180339887\n#define GRAVITY -1.0\n#define SEA_LEVEL 0.1\n#define MOUNTAINS_LEVEL 0.15\n#define WATER_FLOW_MULTIPLIER 0.7\n#define WATER_FLOW_MAX_SPEED 0.7\n#define PRECIPITATION 0.1\n#define PRECIPITATION_END 0.00\n#define LAKE_SPEED 0.000\n\nfloat samplingNeighborsX[8] = float[](-1.0, 0.0, 1.0, -1.0, 1.0, -1.0, 0.0, 1.0);\nfloat samplingNeighborsY[8] = float[]( 1.0, 1.0, 1.0,  0.0, 0.0, -1.0,-1.0,-1.0);\n\nstruct GroundInfo\n{\n    vec3 normal;\n    float totalHeight;\n    float rocksHeight;\n    float dirtHeight;\n};\n\n\nstruct WaterInfo\n{\n    vec2 velocity;\n    float amount;\n};\n\n\nWaterInfo GetWaterInfo(vec4 bufferColor)\n{\n    WaterInfo results;\n    results.velocity = bufferColor.xy;\n    results.amount = bufferColor.z;\n    \n    return results;\n}\n\nGroundInfo GetGroundInfo(vec2 pos, vec3 iResolution, sampler2D sampler)\n{\n    GroundInfo results;\n    \n    vec2 uv_0 = pos/iResolution.xy;\n    vec2 uv_X = clamp((pos + vec2(1.0,0.0))/iResolution.xy, 0.0, 1.0);\n    vec2 uv_Y = clamp((pos + vec2(0.0,1.0))/iResolution.xy, 0.0, 1.0);\n    \n    \n    vec4 height_0 = texture(sampler,uv_0).rgba;\n    vec4 height_X = texture(sampler,uv_X).rgba;\n    vec4 height_Y = texture(sampler,uv_Y).rgba;\n    \n    \n    \n    results.rocksHeight = height_0.x;\n    results.dirtHeight = height_0.y;\n    results.totalHeight = (height_0.x + height_0.y);\n    \n    float height_d_X = (height_X.x + height_X.y) - results.totalHeight;\n    float height_d_Y = (height_Y.x + height_Y.y) - results.totalHeight;\n    \n    height_d_X /= SCALE;\n    height_d_Y /= SCALE;\n    \n    vec3 heightDX = vec3(1.0,0.0,height_d_X);\n    vec3 heightDY = vec3(0.0,1.0,height_d_Y);\n    \n    \n    results.normal = normalize(cross(heightDX, heightDY));\n    \n    return results;\n}\n\n\nvec3 GetSlopeAcceleration(vec3 groundNormal)\n{\n    vec3 gravity = vec3(0.0, 0.0, GRAVITY);\n    \n    vec3 tangent = cross(groundNormal, vec3(0.0,0.0,1.0));\n    \n    vec3 slopeDir = cross(tangent, groundNormal);\n    \n    if (length(slopeDir) > 0.0)\n        slopeDir = normalize(slopeDir);\n    else\n        slopeDir = vec3(1.0,0.0,0.0);\n    \n    return slopeDir * dot(slopeDir, gravity);\n}\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n//From Inigo Quilez https://www.shadertoy.com/view/XslGRr\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat Perlin(in vec3 p)\n{\n    float result = 0.0;\n    vec3 seedStep = vec3(mod(NOISE_IMAGE_SIZE*GOLDEN_RATIO,NOISE_IMAGE_SIZE), \n    mod(NOISE_IMAGE_SIZE*GOLDEN_RATIO*GOLDEN_RATIO, NOISE_IMAGE_SIZE),\n    mod(NOISE_IMAGE_SIZE*GOLDEN_RATIO*GOLDEN_RATIO*GOLDEN_RATIO, NOISE_IMAGE_SIZE));\n    \n    float weightSum = 0.0;\n    float scale = 1.0;\n    float weight = 1.0;\n    \n    for (int i=0; i<PERLIN_STEPS; i++)\n    {\n        vec3 randomOffset = float(i) * seedStep;\n        \n        weightSum += weight;\n        \n        result += noise(p * SCALE * scale + randomOffset) * weight;\n        \n        scale *= 1.5;\n        \n        if (i > 3) //noise image bit depth too low, instead of sample once with big weight, we sample multiple times.\n            weight *= 0.6;\n    }\n    \n    return result / weightSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float rocksHeight;\n    float dirtHeight;\n    \n    if (iFrame == 0)\n    {\n        rocksHeight = Perlin(vec3(fragCoord, 0.0)) * HEIGHT;\n        dirtHeight = Perlin(vec3(fragCoord, 256.0)) * HEIGHT * 0.15;\n    }\n    else\n    {\n        vec4 heightBuffer = texture(iChannel1,fragCoord/iResolution.xy);\n        rocksHeight = heightBuffer.x;\n        dirtHeight = heightBuffer.y;\n        \n        vec4 waterBuffer = texture(iChannel2,fragCoord/iResolution.xy);\n        \n        float waterAmount = min(1.0, waterBuffer.z);\n        \n        dirtHeight = max(0.0, dirtHeight - dirtHeight * waterAmount * length(waterBuffer.xy) * EROSION_SPEED);\n    }\n    \n    //col.g = Perlin(vec3(fragCoord, 0.0)) * HEIGHT;\n    //col.b = Perlin(vec3(fragCoord, 0.0)) * HEIGHT;\n\n    // Output to screen\n    fragColor = vec4(rocksHeight, dirtHeight , 0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n        \n    \n    GroundInfo ground = GetGroundInfo(fragCoord, iResolution, iChannel1);\n    \n    vec3 slopeAcceleration = GetSlopeAcceleration(ground.normal);\n    \n    //display height with sea\n    //fragColor = vec4(heightWithSea,heightWithSea,heightWithSea,1.0);\n    \n    \n    \n    //normal\n    fragColor.xyz = ground.normal.xyz;\n    \n    \n    fragColor = fragColor * 0.5 + 0.5;\n    \n    //display height\n    fragColor = vec4(ground.totalHeight,ground.totalHeight,ground.totalHeight,1.0);\n    \n    //slope\n    fragColor.xyz = -slopeAcceleration.zzz * 0.1;\n    \n    vec2 uv_0 = fragCoord/iResolution.xy;\n    WaterInfo cellWaterInfo = GetWaterInfo(texture(iChannel2,uv_0).rgba);\n    \n    \n    vec2 myWaterDestination = cellWaterInfo.velocity * WATER_FLOW_MULTIPLIER;\n    float myWaterLeftInposition = max(0.0, (1.0-abs(myWaterDestination.x))) * max(0.0, (1.0-abs(myWaterDestination.y)));\n    \n    cellWaterInfo.amount = cellWaterInfo.amount * myWaterLeftInposition;\n    \n    float giveWater = 0.0;\n    float getWater = 0.0;\n    \n    \n    for (int i=0; i<8; i++)\n    {\n        vec2 neighborPos = vec2(samplingNeighborsX[i],samplingNeighborsY[i]);\n        \n        vec2 samplingPos = (fragCoord + neighborPos)/iResolution.xy;\n        WaterInfo neighborWaterInfos = GetWaterInfo(texture(iChannel2,samplingPos).rgba);\n        vec4 heightBuffer = texture(iChannel1,fragCoord/iResolution.xy);\n        \n        vec2 newWaterPosition = neighborPos + neighborWaterInfos.velocity * WATER_FLOW_MULTIPLIER;\n        \n        \n        //Is velocity of water heading to my position ? using bilinear sort of sampling\n        float newWaterPositionIsMyPosition = max(0.0, (1.0-abs(newWaterPosition.x))) * max(0.0, (1.0-abs(newWaterPosition.y)));\n        \n        cellWaterInfo.velocity += 0.0*neighborWaterInfos.velocity * newWaterPositionIsMyPosition * neighborWaterInfos.amount;\n        //cellWaterInfo.velocity = mix(cellWaterInfo.velocity, neighborWaterInfos.velocity, max(0.0, (0.5 + (neighborWaterInfos.amount - cellWaterInfo.amount)))  * newWaterPositionIsMyPosition);\n        \n        float flowingWater = neighborWaterInfos.amount * newWaterPositionIsMyPosition;\n        cellWaterInfo.amount += flowingWater;\n        neighborWaterInfos.amount -= flowingWater;\n        \n        float neighborHeightWater = heightBuffer.x + heightBuffer.y + neighborWaterInfos.amount;\n        \n        //getWater += (neighborWaterInfos.amount - flowingWater) * max(0.0, max(0.0, neighborHeightWater - flowingWater) - (ground.totalHeight+cellWaterInfo.amount));\n        //giveWater += max(0.0, (ground.totalHeight+cellWaterInfo.amount) - max(0.0, neighborHeightWater - flowingWater));\n        \n        //getWater += (neighborWaterInfos.amount - flowingWater) - cellWaterInfo.amount;\n        \n        float levelDIff = max(0.0, neighborHeightWater ) - (ground.totalHeight+cellWaterInfo.amount);\n        levelDIff = clamp(levelDIff, -1.0, 1.0);\n        \n        if (levelDIff > 0.0)\n            getWater += levelDIff * (neighborWaterInfos.amount);\n        else\n            getWater += levelDIff * max(0.0, (cellWaterInfo.amount));\n    }\n    \n    //cellWaterInfo.amount += getWater * LAKE_SPEED;\n    //cellWaterInfo.amount -= cellWaterInfo.amount * giveWater * LAKE_SPEED;\n    \n    \n    cellWaterInfo.amount += getWater * LAKE_SPEED;\n    cellWaterInfo.amount = max(0.0, cellWaterInfo.amount);\n    \n        \n    if (isnan(cellWaterInfo.velocity.x))\n        cellWaterInfo.velocity.x = 0.0;\n    if (isnan(cellWaterInfo.velocity.y))\n        cellWaterInfo.velocity.y = 0.0;\n    \n    float animatedPrecipitation = mix(PRECIPITATION , PRECIPITATION_END, smoothstep(0.0, 120.0, float(iFrame)));\n        \n    if (animatedPrecipitation > 0.0)\n        cellWaterInfo.amount += animatedPrecipitation;\n    //else\n    //    cellWaterInfo.amount = max(0.0, cellWaterInfo.amount - 0.8);\n    \n    float maxSpeed = WATER_FLOW_MAX_SPEED * min(1.0, cellWaterInfo.amount);\n    float speed = length(cellWaterInfo.velocity);\n    \n    if (dot(slopeAcceleration.xy,cellWaterInfo.velocity) > 0.0)\n        cellWaterInfo.velocity += min(1.0, cellWaterInfo.amount) * slopeAcceleration.xy * (1.0-speed/maxSpeed);\n    else\n        cellWaterInfo.velocity += min(1.0, cellWaterInfo.amount) * slopeAcceleration.xy;\n    \n    \n    if (speed > maxSpeed && speed > 0.0)\n        cellWaterInfo.velocity = normalize(cellWaterInfo.velocity) * maxSpeed;\n        \n    if (ground.totalHeight < SEA_LEVEL)\n        cellWaterInfo.amount = 0.0;\n        \n    fragColor.xy = cellWaterInfo.velocity;\n    fragColor.z = cellWaterInfo.amount;\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}