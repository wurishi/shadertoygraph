{"ver":"0.1","info":{"id":"3ttSWf","date":"1583579051","viewed":146,"name":"Progressive Fractal Pathtracer","username":"monty","description":"Progressive monte carlo path tracing with MIS, uses sphere tracing for intersection. Can render spheres or the mandelbulb.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbulb","spheretracing","pathtracing","mis","progressive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    fragColor = vec4(pow((fragColor.xyz/(fragColor.xyz+1.0)),vec3(1.0f/2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Object {\n    vec3 p;\n    float s;\n    int type;\n    vec3 color;\n    bool light;\n};\n    \nstruct Ray { vec3 o, d; };\nstruct Interaction { Object object; vec3 p; vec3 n; bool hit; };\nstruct PointLight { vec3 p, c; };\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\n\nObject[] objects = \n    Object[](\n        Object(vec3(0.0), 0.05, 0, vec3(1.0f), false),\n        Object(2.0*vec3(0.5, -0.5, 0.5), 0.25, 1, vec3(1.0), false),\n        Object(2.0*vec3(0.5,-0.5, -0.5), 0.25, 1, vec3(1.0), false),\n        Object(2.0*vec3(-0.5, 0.5, -0.5), 0.25, 1, vec3(1.0), false),\n        Object(2.0*vec3(-0.5, -0.5, 0.5), 0.25, 1, vec3(1.0), false),\n        Object(2.0*vec3(0.5, 0.5, 0.5), 0.25, 1, vec3(1.0), false),\n        Object(vec3(5.0, 5.0, -5.0), 3.5, 1, vec3(5.0), true),\n        Object(vec3(-5.0, 5.0, -5.0), 3.5, 1, vec3(5.0), true),\n        Object(vec3(-5.0, 5.0, 5.0), 3.5, 1, vec3(5.0, 1.0, 2.0), true)\n\n    );\n\n\nfloat sdf_sphere (vec3 p, vec3 c, float r)\n{\n    return distance(p,c) - r;\n}\n\n\nfloat sdf_mandelbulb(vec3 pos) {\n\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float Power = 8.0f;\n\tfor (int i = 0; i < 16 ; i++) {\n\t\tr = length(z);\n\t\tif (r>1.5f) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nInteraction sphere_trace(Ray ray)\n{\n    float depth = 0.0f;\n    vec3 rayFront;\n    float iterations = 0.0f;\n    float maxDepth = 100.0f;\n    \n    bool light = false;\n    bool hit = false;\n    \n    float e = 1000.0f;\n    if (iMouse.z > 0.) {\n        e = 100.0f;\n     \t   \n    }\n    \n    Object min_object;\n\n    for (int i = 0; i < 128; i++) {\n\n        iterations += 1.0f;\n        rayFront = ray.o + ray.d*depth;\n        \n        float min_dist = 9999.0f;\n        \n\n        for (int i = 0; i < objects.length(); i++) {\n            \n            float dist = 0.0f;\n            Object object = objects[i];\n\n            if (object.type == 0) {\n                dist = sdf_mandelbulb(rayFront);\n            } else {\n             \tdist = sdf_sphere(rayFront, object.p, object.s);   \n            }\n            \n            if (dist < min_dist) {\n                \n             \tmin_dist = dist;\n                min_object = object;\n            }\n            \n            \n        }\n\n\n        if (min_dist < depth/e) {\n            hit = true;\n        \tbreak;\n        }\n\n\n        depth += min_dist;\n        \n        \n        if (depth > maxDepth) {\n            break;   \n        }\n\n    }\n    \n    vec3 p = ray.o + ray.d*depth;\n    \n    vec3 n;\n    \n    if (hit) {\n        float delta = 0.001f;\n        \n        if (min_object.type == 0) {\n            n = normalize(vec3( \n                sdf_mandelbulb(p + vec3(delta, 0, 0)) - sdf_mandelbulb(p + vec3(-delta, 0, 0)), \n                sdf_mandelbulb(p + vec3(0, delta, 0)) - sdf_mandelbulb(p + vec3(0, -delta, 0)), \n                sdf_mandelbulb(p + vec3(0, 0, delta)) - sdf_mandelbulb(p + vec3(0, 0, -delta))));\n        } else {\n         \tn = normalize(p - min_object.p);   \n        }\n    }\n    \n    \n    return Interaction(min_object, p, n, hit);\n}\n\n\n\n\n\nvec3 sample_hemisphere( vec3 n )\n{\n    float u = rand();\n    float v = rand();\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n  \n}\n\nfloat powerHeuristicDividedByPdf(float pdf, float pdf2) {\n    return pdf/(pdf*pdf+pdf2*pdf2);\n}\n\n\n\nvec3 sample_pixel(Ray ray, int max_bounces) {\n    \n\n\tvec3 color = vec3(0.0f);\n    vec3 throughput = vec3(1.0f);\n    Interaction interaction = sphere_trace(ray);\n\n    for (int i = 0; i < max_bounces; i++) {\n        \n \n        \n        if (!interaction.hit) {\n        \treturn color;    \n        }\n        \n        if (interaction.object.light) {\n         \treturn interaction.object.color;\n        }\n        \n        vec3 newDir = sample_hemisphere(interaction.n);\n        \n        //throughput *= vec3(0.5f);\n        \n        ray = Ray(interaction.p, newDir);\n        \n        Interaction next_interaction = sphere_trace(ray);\n        \n        throughput *= 1.0/3.1416;\n        \n        float lights = 0.0;\n        \n        for (int j = 0; j < objects.length(); j++) {\n            if (objects[j].light) {\n             \tlights += 1.0   ;\n                \n            }\n        }\n  \n        for (int j = 0; j < objects.length(); j++) {\n        \n            \n            vec3 light_contrib = vec3(0.0f);\n            vec3 brdf_contrib = vec3(0.0f);\n        \n            float lightPdf = 0.0f;\n            float brdfPdf = 0.0f;\n            \n            \n            \n         \tObject object = objects[j];\n            \n            if (object.light) {\n             \t\n                // sample point on light\n                \n                vec3 ln = normalize(interaction.p - object.p);\n                \n                Ray shadowRay = Ray(interaction.p, -ln);\n                \n                Interaction shadowInteraction = sphere_trace(shadowRay);\n                \n                if (shadowInteraction.object.light) {\n                \n                    vec3 lns = sample_hemisphere(ln);\n\n                    float c = dot(ln, lns);\n\n                    vec3 lp = object.p + lns*object.s;\n\n\n                    float ll = length(object.p - interaction.p);\n                    float ll2 = ll*ll;\n                    float solidAngle = 3.1415f*object.s*object.s / (ll2);\n                    lightPdf = (c/3.1415f)/solidAngle;\n                    float light_weight;\n                    if (next_interaction.object.light) {\n                        light_weight = powerHeuristicDividedByPdf(lightPdf, dot(-ln, interaction.n)/3.1415f);\n                        \n                    } else {\n                        light_weight = 1.0f/lightPdf;\n                        \n                    }\n                    \n           \n                    light_contrib += light_weight*object.color*dot(-ln, interaction.n);\n\n                }\n                \n                if (next_interaction.object.light) {\n                    \n                \tvec3 ln = normalize(interaction.p - next_interaction.object.p);\n                    vec3 lns = normalize(next_interaction.p - next_interaction.object.p);\n\t\t\t\t\tfloat c = dot(normalize(interaction.p - next_interaction.object.p), lns);\n                    \n                    \n                    float ll = length(interaction.p - next_interaction.p);\n                    float ll2 = ll*ll;\n                    float solidAngle = 3.1415f*next_interaction.object.s*next_interaction.object.s / (ll2);\n                    lightPdf = (c/3.1415f)/solidAngle;\n                                  \n                    float brdf_weight = powerHeuristicDividedByPdf(dot(-ln, interaction.n)/3.1415f, lightPdf);\n\n\n                    brdf_contrib += brdf_weight*next_interaction.object.color*dot(-ln, interaction.n);\n                }\n                \n                             \n                color += throughput*(light_contrib + brdf_contrib)/lights;             \n\n            }\n      \n        }\n        \n        \n                                  \n        if (next_interaction.object.light) {\n        \tbreak;   \n        }\n        \n        interaction = next_interaction;\n        \n    }\n    \n\n\treturn color;\n}\n\n\nvec3[2] tangents(vec3 v) {\n    \n \tvec3 t1 = normalize(cross(v, normalize(vec3(1.0f))));\n    \n    vec3 t2 = normalize(cross(v, t1));\n                        \n    return vec3[2](t1, t2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 jitteredFragCoord = fragCoord + 1.0f*vec2(rand(), rand());\n    vec2 uv = 2. * jitteredFragCoord.xy / iResolution.xy - 1.;\n    \n    vec2 mouse = 5.0*(iMouse.xy/iResolution.xy + vec2(1.0));\n    \n    vec3 pos = 2.0f*vec3(sin(mouse.x)*cos(mouse.y), sin(mouse.x)*sin(mouse.y), cos(mouse.x)); \n    vec3 rayOrigin = pos;\n    \n    vec3 look_dir = -normalize(pos);\n    \n    vec3[2] ts = tangents(look_dir);\n    \n    vec3 c = vec3(0.0f);\n    \n    for (int i = 0; i < 1; i++) {\n    \n        vec2 jitteredFragCoord = fragCoord + 1.0f*vec2(rand(), rand());\n        vec2 uv = 2. * jitteredFragCoord.xy / iResolution.xy - 1.;\n\n        vec3 rayEnd = rayOrigin + normalize(ts[0]*uv.x + ts[1]*uv.y*(iResolution.y/iResolution.x) + look_dir);\n\n\n        Ray ray = Ray(rayOrigin, normalize(rayEnd - rayOrigin));\n        ;\n        c += sample_pixel(ray, 3);\n    }    \n    \n    float frame = float(iFrame) - texture(iChannel1,fragCoord/iResolution.xy).x;\n\n    \n    if (iMouse.z > 0. || frame <= 1.0) {\n        \n        fragColor = vec4(c, 1.0f);\n    } else {\n    \tfragColor =( texture(iChannel0,fragCoord/iResolution.xy)*float(frame) + vec4(c, 1.0f))/(float(frame)+1.0f);\n    } \n        \n    \n\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.) {\n        fragColor = vec4(iFrame,0.0, 0.0, 1.0);\n    }\n    else {\n     \tfragColor =    texture(iChannel1,fragCoord/iResolution.xy);\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}