{"ver":"0.1","info":{"id":"DsS3RW","date":"1667272935","viewed":216,"name":"Shapes and 2D Lighting","username":"romainguy","description":"A demo of lighting in 2D space using SDF shapes and shadows. The lighting itself is extremely fake, with ad-hoc falloffs, BRDFs, etc. The goal is to simulate some kind of subsurface scattering.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["2d","lights","hadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float interleavedGradientNoise(vec2 w) {\n    const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(m.z * fract(dot(w, m.xy)));\n}\n\nvec3 dither(vec3 rgb, float temporalNoise01) {\n    vec2 uv = gl_FragCoord.xy + temporalNoise01;\n\n    float noise = interleavedGradientNoise(uv);\n    noise -= 0.5;\n\n    return rgb + vec3(noise / 255.0);\n}\n\nvec3 Tonemap_ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 EOCF_sRGB(vec3 sRGB) {\n    return pow(sRGB, vec3(2.2));\n}\n\nvec3 OECF_sRGB(vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\nfloat roundedRect(vec2 p, vec2 size, float radius) {\n    return length(max(abs(p) - size + radius, 0.0)) - radius;\n}\n\nfloat circle(vec2 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat addToScene(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nvec2 translate(vec2 p, vec2 t) {\n\treturn p - t;\n}\n\nfloat fillMask(float d) {\n\treturn clamp(-d, 0.0, 1.0);\n}\n\nfloat aaMask(float d) {\n\treturn 1.0 - smoothstep(0.0, 1.0f, d);\n}\n\nfloat luminance(const vec3 linear) {\n    return dot(linear, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 background(vec2 uv, vec2 p, vec3 backgroundColor) {\n    float gradient = (1.0 - length(iResolution.xy / 2.0 - p) / iResolution.y);\n\n    vec3 color = EOCF_sRGB(texture(iChannel0, uv).rgb);\n    color = luminance(color) * backgroundColor * gradient;\n\n    return color;\n}\n\nfloat scene(vec2 p) {\n    float box1 = roundedRect(translate(p, vec2(120.0, 120.0)), vec2(80.0), 30.0);\n    float box2 = roundedRect(translate(p, vec2(640.0, 200.0)), vec2(140.0, 80.0), 50.0);\n    float circle1 = circle(translate(p, vec2(300.0, 390.0)), 100.0);\n    float circle2 = circle(translate(p, vec2(840.0, 450.0)), 60.0);\n\n    float sdf = addToScene(box1, box2);\n    sdf = addToScene(sdf, circle1);\n    sdf = addToScene(sdf, circle2);\n\n    return sdf;\n}\n\nfloat illumination(vec2 p, vec2 lightPosition, float radius) {\n\tvec2 direction = normalize(lightPosition - p);\n\tfloat distanceToLight = length(p - lightPosition);\n\t\n    float lightVisibility = distanceToLight * radius;\n\n    float raymarchDistance = 0.01;\n\n\tfor (int i = 0; i < 48; i++) {\t\t\t\t\n\t\tfloat sdf = scene(p + direction * raymarchDistance);\n        if (sdf < -radius) return 0.0;\n\n\t\tlightVisibility = min(lightVisibility, sdf / raymarchDistance);\n\n\t\traymarchDistance += max(1.0, abs(sdf));\n\t\tif (raymarchDistance > distanceToLight) break;\n\t}\n\n\tlightVisibility = clamp((lightVisibility * distanceToLight + radius) / (2.0 * radius), 0.0, 1.0);\n\n    return lightVisibility;\n}\n\nvec3 light(vec2 p, vec2 lightPosition, vec3 lightColor, float radius, float sourceRadius) {\n    float d = length(p - lightPosition);\n    if (d > radius) return vec3(0.0);\n\n    float illumination = illumination(p, lightPosition, sourceRadius);\n    float falloff = (radius - d) / radius;\n    falloff *= falloff;\n    falloff *= falloff;\n\n    float source = fillMask(circle(p - lightPosition, sourceRadius));\n    return (illumination * falloff + source) * lightColor;\n}\n\nvec3 mixLight(vec2 p, float shapes, vec3 fillColor, vec2 lightPosition, float lightRadius, vec3 lightColor, float lightIntensity) {\n    if (shapes < 1.0) {\n        vec2 direction = normalize(lightPosition - p);\n        float distanceToLight = length(p - lightPosition);\n        float dt = 2.0;\n        vec2 surfacePosition = p;\n        for (int i = 0; i < 48; i++) {\n            surfacePosition = p + direction * dt;\n            float sdf = scene(surfacePosition);\n            if (sdf > 0.0) break;\n            dt += abs(sdf);\n            if (dt > distanceToLight) break;\n        }\n\n        float falloff = 1.0 - clamp(distanceToLight / lightRadius, 0.0, 1.0);\n        falloff *= falloff;\n        falloff *= falloff;\n        falloff *= pow(1.0 - clamp(dt / (lightRadius * 0.4), 0.0, 1.0), 12.0);\n        return fillColor * mix(0.0, 1.0, falloff) * lightColor * lightIntensity;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 fillColor = vec3(uv, cos(iTime) * 0.5 + 0.5);\n\n    vec2 scale = (vec2(1024.0, 576.0) / iResolution.xy);\n    fragCoord *= scale;\n\n    float shapes = scene(fragCoord);\n\n    vec2 lightPosition1 = iMouse.xy * scale;\n    vec3 lightColor1 = vec3(0.4, 0.6, 1.0);\n    vec2 lightPosition2 = vec2(350.0 + cos(iTime) * 100.0, 190.0);\n    vec3 lightColor2 = vec3(0.2, 0.9, 0.2);\n    vec2 lightPosition3 = vec2(620.0 + cos(iTime) * 100.0, 420.0 + sin(iTime) * 100.0);\n    vec3 lightColor3 = vec3(0.9, 0.1, 0.1);\n    \n    float lightRadius = 700.0;\n    float lightIntensity = 3.0;\n\n    vec3 color = vec3(0.0);\n    color += background(uv, fragCoord, vec3(0.15));\n    color += light(fragCoord, lightPosition1, lightColor1, lightRadius, 15.0);\n    color += light(fragCoord, lightPosition2, lightColor2, lightRadius, 15.0);\n    color += light(fragCoord, lightPosition3, lightColor3, lightRadius, 15.0);\n\n    vec3 litColor = fillColor * 0.06; // ambient\n    litColor += mixLight(fragCoord, shapes, fillColor, lightPosition1, lightRadius, lightColor1, lightIntensity);\n    litColor += mixLight(fragCoord, shapes, fillColor, lightPosition2, lightRadius, lightColor2, 2.0);\n    litColor += mixLight(fragCoord, shapes, fillColor, lightPosition3, lightRadius, lightColor3, lightIntensity);\n\n    color = mix(color, litColor, aaMask(shapes));\n\n    color = Tonemap_ACES(color);\n    color = OECF_sRGB(color);\n    color = dither(color, fract(iTime));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}