{"ver":"0.1","info":{"id":"Mlj3Wc","date":"1433443978","viewed":195,"name":"aa plane trace publicinti","username":"public_int_i","description":"decently fast axis aligned planes, with a few bugs. codes probably hard to read though sorry about that. use mouse to move the camera","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytrace","planes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//by Ethan Alexander Shulman known as public_int_i 10100101010\n//This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License\n//http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n#define FOV_SCALE .6\n#define VIEW_DIST 5000.\n\nconst vec2 wallSize = vec2(2.);\nvec3 lightDir = normalize(vec3(10.,30.,-10.));\n\n//distance multiplier\n#define pm db *= 1.+(min(0.,db)*10000000.)\n//plane clip\n#define cp(p,s) db *= 1.+length(max(abs(p)-s,0.))*10000000.\n//plane clip position\n#define cc(p,d,c) ba = (p+d*db)-c\n//distance compare\n#define dc lt = float(db<d); lt1 = 1.-lt; d = d*lt1+db*lt\n//normal compare\n#define ns(n) nrm = lt1*nrm+lt*n\nfloat trace(in vec3 rp, in vec3 rd, inout vec3 nrm) {\n    vec2 ba;\n    float lt,lt1;\n    float d;\n    float nb = -2.-rp.y;//floor\n    float db = nb/rd.y;\n    pm;\n    d = db;\n    nrm = vec3(0.,sign(nb),0.);\n    \n    for (int i = 0; i < 128; i++) {\n        float fi = float(i);\n        float zi = mod(fi,10.);\n        float zp = floor(fi/10.);\n        \n        nb = (2.+zp*4.)-rp.z;\n        db = nb/rd.z;\n        cc(rp.xy,rd.xy,vec2(zi*7.,0.));\n        cp(ba,wallSize);\n        pm;\n        dc;\n        ns(vec3(0.,0.,sign(nb)));\n    }\n   \n    return d;\n}\n\n\nvec4 scene(inout vec3 rp, inout vec3 rd) {\n    vec4 c;\n    vec3 nrm;\n    \n \tfloat d = trace(rp,rd,nrm);\n    if (d < VIEW_DIST) {\n        rp += (d-.08)*rd;\n\n        c = texture(iChannel1,(rp.xz+rp.zy)*.2);\n        c = .2*c+max(0.,dot(-nrm,lightDir))*c;\n        \n    \tc = mix(c,texture(iChannel0,reflect(rd,nrm)),.2);\n    } else {\n\t\tc = texture(iChannel0,rd);\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float mX = iMouse.x/iResolution.x*6.3;\n    vec3 rp = vec3(sin(mX)*15.,(iMouse.y/iResolution.y-.1)*20.,cos(mX)*15.);\n    if (iMouse.z == 0.) rp = vec3(sin(iTime*.1)*15.,5.,cos(iTime*.1)*12.);\n    vec3 rd = normalize(-rp);\n    vec3 rr = cross(vec3(0.,1.,0.),rd);\n    rr = rd = normalize(rd*FOV_SCALE + uv.x*rr + uv.y*cross(rd,rr));\n    rp.y += 4.;\n    \n    fragColor = scene(rp,rd);\n}","name":"","description":"","type":"image"}]}