{"ver":"0.1","info":{"id":"stlGWs","date":"1623241718","viewed":445,"name":"flying_thru_the_neon_hall","username":"skaplun","description":"Inspired by this animation https://www.pinterest.ca/pin/581527370637663083/","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["3d","animation","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Tube tubes(float z){\n    float ang = hash11(z) * PI * 10.;\n    vec3 base = rz(vec3(0., .35, z), ang);\n    vec3 points[] = vec3[3](base + vec3(0., hash11n(z + 4.13) * .1, 0.),\n                          rz(base + vec3(0., hash11n(z + 5.07) * .1, 0.), PI * .66 + hash11n(z) * .1),\n                          rz(base + vec3(0., hash11n(z + 2.31) * .1, 0.), PI * 1.33 + hash11n(z + 3.17) * .1));\n                          \n    float c1 = fbm1x(z, iTime * .1);\n    vec2 c2 = shiftAtPos(c1, 2.) * 1.25;\n    \n    return Tube(points, vec3[3](hsv2rgb(vec3(c1, 1., 1.)), hsv2rgb(vec3(c2.x, 1., 1.)), hsv2rgb(vec3(c2.y, 1., 1.))));\n}\n\nvec3 hall(Ray ray){\n    //ray.dir.xy = abs(ray.dir.xy);\n    vec3 res = vec3(MAX_FLOAT);\n    \n    float dst = (.25 - ray.origin.x)/ray.dir.x;\n    if(dst > 0. && dst < res.b){\n        vec3 p = ray.origin + ray.dir * dst;\n        res.r = .4;\n        res.g = (.65 + .35 * smoothstep(.5, .4, p.y));\n        res.b = dst;\n    }\n    \n    dst = (-.25 - ray.origin.x)/ray.dir.x;\n    if(dst > 0. && dst < res.b){\n        vec3 p = ray.origin + ray.dir * dst;\n        res.r = .4;\n        res.g = (.65 + .35 * smoothstep(.5, .4, p.y));\n        res.b = dst;\n    }\n    \n    dst = (.25 - ray.origin.y)/ray.dir.y;\n    if(dst > 0. && dst < res.b){\n        vec3 p = ray.origin + ray.dir * dst;\n        res.r = .3;\n        res.g = (.85 + .25 * smoothstep(.5, .4, p.x));\n        res.b = dst;\n    }\n    \n    dst = (-.25 - ray.origin.y)/ray.dir.y;\n    if(dst > 0. && dst < res.b){\n        vec3 p = ray.origin + ray.dir * dst;\n        res.r = .3;\n        res.g = (.85 + .25 * smoothstep(.5, .4, p.x));\n        res.b = dst;\n    }\n    \n    return res;\n}\n\nconst float TUBE_RAD = .005;\nfloat getCylDensity(in Ray ray, vec3 a, vec3 b, float minD, out float dst){\n    const float BIGGER_RAD = .0125;\n    vec2 r;\n    if(cylinderHit(ray, Cylinder(a, b, BIGGER_RAD), r) && r.x < minD){\n        dst = r.x;\n        float den = pow(clamp((r.y - r.x)/(BIGGER_RAD * 2.), 0., 1.), 16.) * .1;\n            \n        if(cylinderHit(ray, Cylinder(a, b, TUBE_RAD), r) && r.x < minD){\n            den += pow(clamp((r.y - r.x)/(TUBE_RAD * 2.), 0., 1.), 4.);\n        }\n        return pow(clamp(den, 0., 1.), .1);\n    }\n    return 0.;\n}\n\nvec3 HALL_COLOR = vec3(0.114,0.012,0.149);\n//vec3[3] TUBE_COLORS = vec3[3](vec3(1.000,0.933,0.502), vec3(215., 67., 255.)/255., vec3(67., 108., 255.)/255.);\nvec4 world(const in Ray ray){\n    vec3 hall = hall(ray);\n    float minDist = hall.b;\n    vec4 result = vec4(HALL_COLOR, 0.);\n    float fade = smoothstep(3., 0., minDist);\n    {\n        vec3 p = ray.origin + ray.dir * minDist;\n        float z = fract(p.z) > .5 ? ceil(p.z) : floor(p.z);\n        //vec3[] tubes = tubes(z);\n        Tube tubes = tubes(z);\n        for(int i=1; i<4; i++){\n            float dst = sdCylinder(p, tubes.points[i-1], tubes.points[i%3], TUBE_RAD);\n            result.rgb = mix(result.rgb, tubes.colors[i-1],\n            .25 * pow(smoothstep(50., 0., dst), 16000. + 32000. * pow(smoothstep(.001, .1, distance(p.z, z)), .75))\n           + 1. * pow(smoothstep(1., .001, dst), 1024.));\n        }\n    }\n    result.rgb *= hall.g * fade;\n    \n    float first = ceil(ray.origin.z);\n    for(int i=8; i>0; i--){\n        Tube tubes = tubes(first - float(i));\n        \n        float dst;\n        float den = getCylDensity(ray, tubes.points[0], tubes.points[1], minDist, dst);\n        result.rgb = mix(result.rgb, mix(tubes.colors[0], vec3(1.), den * (2.-dst) * .35) * smoothstep(8., 7., dst), den);\n        den = getCylDensity(ray, tubes.points[1], tubes.points[2], minDist, dst);\n        result.rgb = mix(result.rgb, mix(tubes.colors[1], vec3(1.), den * (2.-dst) * .35) * smoothstep(8., 7., dst), den);\n        den = getCylDensity(ray, tubes.points[2], tubes.points[0], minDist, dst);\n        result.rgb = mix(result.rgb, mix(tubes.colors[2], vec3(1.), den * (2.-dst) * .35) * smoothstep(8., 7., dst), den);\n    }\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec2 e = shiftAtPos(1., iTime * .75) * .15;\n    vec2 l = shiftAtPos(1., iTime * .75 - 2.) * .15;\n    float time = -iTime * 2. + e.y * 5.;\n    \n    vec3 eye = vec3(e, time);\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, eye + vec3(l, -1.), rz(vec3(0., 1., 0.), l.y * 3.)) * viewDir;\n    \n    fragColor = world(Ray(eye, worldDir));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 1e6\n#define MIN_FLOAT 1e-6\n\nstruct Cylinder{vec3 A, B; float r;};\nstruct Ray{ vec3 origin, dir; };\nstruct HitRecord{ float t; vec3 p; vec3 normal; };\nstruct Tube{vec3 points[3], colors[3];};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nbool cylinderHit(const in Ray ray,  const in Cylinder cyl, out vec2 dst) {\n  float cxmin, cymin, czmin, cxmax, cymax, czmax;\n  if (cyl.A.z < cyl.B.z) {\n      czmin = cyl.A.z - cyl.r; czmax = cyl.B.z + cyl.r;\n  } else {\n      czmin = cyl.B.z - cyl.r; czmax = cyl.A.z + cyl.r;\n  }\n  if (cyl.A.y < cyl.B.y) {\n      cymin = cyl.A.y - cyl.r; cymax = cyl.B.y + cyl.r;\n  } else {\n      cymin = cyl.B.y - cyl.r; cymax = cyl.A.y + cyl.r;\n  }\n  if (cyl.A.x < cyl.B.x) {\n      cxmin = cyl.A.x - cyl.r; cxmax = cyl.B.x + cyl.r;\n  } else {\n      cxmin = cyl.B.x - cyl.r; cxmax = cyl.A.x + cyl.r;\n  }\n    /*\n  if (optimize) {\n   if (start.z >= czmax && (start.z + dir.z) > czmax) return;\n   if (start.z <= czmin && (start.z + dir.z) < czmin) return;\n   if (start.y >= cymax && (start.y + dir.y) > cymax) return;\n   if (start.y <= cymin && (start.y + dir.y) < cymin) return;\n   if (start.x >= cxmax && (start.x + dir.x) > cxmax) return;\n   if (start.x <= cxmin && (start.x + dir.x) < cxmin) return;\n  }\n    */\n\n    vec3 AB = cyl.B - cyl.A;\n    vec3 AO = ray.origin - cyl.A;\n    vec3 AOxAB = cross(AO, AB);\n    vec3 VxAB  = cross(ray.dir, AB);\n    float ab2 = dot(AB, AB);\n    float a = dot(VxAB, VxAB);\n    float b = 2. * dot(VxAB, AOxAB);\n    float c = dot(AOxAB, AOxAB) - (cyl.r * cyl.r * ab2);\n    float d = b * b - 4. * a * c;\n    if (d < 0.)\n        return false;\n    \n    //rec.t = (-b - 1. * sqrt(d)) / (2. * a);\n    \n    float[2] coef = float[2](1., -1.); \n    for(int i=0; i<2; i++){\n        float time = (-b - coef[i] * sqrt(d)) / (2. * a);\n        dst[i] = time;\n    }\n    return true;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nvec3 rz( in vec3 uv, float a){\n    float c = cos( a );\n    float s = sin( a );\n    return vec3( c * uv.x - s * uv.y, s * uv.x + c * uv.y, uv.z );\n}\n\nconst float PI = acos(-1.);\n\n#define HASHSCALE1 .1031\nfloat hash11(float p){\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11n(float p){\n    return hash11(p) * 2. - 1.;\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nvec2 shiftAtPos(float x, float time){\n\treturn vec2(fbm1x(x, time), fbm1x(x + 78.233, time));\n}\n\nvec3 hsv2rgb(in vec3 c){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"}]}