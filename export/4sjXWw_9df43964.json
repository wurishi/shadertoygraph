{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define STEPS 8.0\n#define R 0.2126\n#define G 0.7152\n#define B 0.0722\n#define LUT_SIZE 14\n\nvec4 lut[LUT_SIZE];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    lut[0] = vec4(0.0,0.0,0.0,0.0000);\n    lut[1] = vec4(0.0,0.0,1.0,0.0722);\n    lut[2] = vec4(1.0,0.0,-1.0,0.1404);\n    lut[3] = vec4(1.0,0.0,0.0,0.2126);\n    lut[4] = vec4(1.0,0.0,1.0,0.2848);\n    lut[5] = vec4(1.0,0.0,2.0,0.3570);\n    lut[6] = vec4(-1.0,1.0,-1.0,0.4304);\n    lut[7] = vec4(-1.0,1.0,0.0,0.5026);\n    lut[8] = vec4(-1.0,1.0,1.0,0.5748);\n    lut[9] = vec4(0.0,1.0,-1.0,0.6430);\n    lut[10] = vec4(0.0,1.0,0.0,0.7152);\n    lut[11] = vec4(0.0,1.0,1.0,0.7874);\n    lut[12] = vec4(1.0,1.0,-1.0,0.8556);\n    lut[13] = vec4(1.0,1.0,0.0,0.9278);\n\n\n    float y = (fragCoord.y-0.5) / iResolution.y;\n\tfloat signal = (fragCoord.x - 0.5) / iResolution.x;\n    float q_signal = floor(signal*STEPS) / STEPS;\n    float n_error = (signal - q_signal)*STEPS;\n\n    vec4 l = lut[0];\n    for (int i = 1; i < LUT_SIZE; ++i) {\n        if (n_error < lut[i].w) {\n            break;\n        }\n        l = lut[i];\n    }\n    \n    vec4 limbo = floor(vec4(signal)*STEPS + vec4(0.0, 1.0/3.0, 2.0/3.0, 0.0)) / STEPS;\n    vec4 better_than_limbo = floor(vec4(signal)*STEPS + vec4(0.0, 1.0-G-B, 1.0-B, 0.0)) / STEPS;\n    vec4 color = vec4(q_signal) + l.xyzz/STEPS;\n\n    if (y > 8.0/9.0) {\n        fragColor = vec4(signal);\n    } else if (y > 7.0/9.0) {\n        fragColor = vec4(q_signal);\n    } else if (y > 6.0/9.0) {\n        fragColor = limbo;\n    } else if (y > 5.0/9.0) {\n        fragColor = vec4(limbo.r*R + limbo.g*G + limbo.b*B);\n    } else if (y > 4.0/9.0) {\n        fragColor = better_than_limbo;\n    } else if (y > 3.0/9.0) {\n        fragColor = vec4(better_than_limbo.r*R + better_than_limbo.g*G + better_than_limbo.b*B);\n    } else if (y > 2.0/9.0) {\n        fragColor = color;\n    } else if (y > 1.0/9.0) {\n        fragColor = vec4(color.r*R + color.g*G + color.b*B);\n    } else {\n        fragColor = 0.25*STEPS*abs(vec4(signal)-color);\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sjXWw","date":"1412690912","viewed":1032,"name":"lut gradient [-1:1] (tweaked)","username":"danielpovlsen","description":"1. signal\n\n2. quantized signal\n\n3. limbo offset\n\n4. luminance of 3\n\n5. improved limbo offset\n\n6. luminance of 5\n\n7. &quot;advanced&quot; color offset\n\n8. luminance of 7\n\n9. abs error of 7-1\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["lut"],"hasliked":0,"parentid":"","parentname":""}}