{"ver":"0.1","info":{"id":"sdBGWh","date":"1617574262","viewed":939,"name":"MAGMA ELEMENTAL","username":"alro","description":"After the Main Hall burnt down in 1842, the Society banned all forms of volcanic pyromancy. The Lord Mayor's office hasn't approved use of public land for their summer party since.","likes":41,"published":1,"flags":32,"usePreview":0,"tags":["spectrum","fire","distortion","lava","flow","blackbody","rock","normalmapping","magma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Lava material using blackbody radiation spectrum, normal mapping and texture distortion.\n\n    Based on:\n    \n    https://catlikecoding.com/unity/tutorials/flow/texture-distortion/\n    https://scipython.com/blog/converting-a-spectrum-to-a-colour/\n    https://www.shadertoy.com/view/llSyRD\n    \n    BufferA: Camera and resolution change tracking\n    BufferB: Blackbody spectrum\n    BufferC: R - Perlin noise FBM for lava height map\n             G - Worley noise for staggered mixing of textures\n             \n    EDIT: Added blur glow postprocessing\n                 \n    Ocean elemental: https://www.shadertoy.com/view/NdS3zK\n    Magma elemental: https://www.shadertoy.com/view/sdBGWh\n    Rock elemental: https://www.shadertoy.com/view/csd3RX\n   \n*/\n\nconst bool renderGlow = true;\n\n//-------------------------------- Bicubic blur --------------------------------\n\n// https://www.shadertoy.com/view/Dl2SDW\n\n// Cubic B-spline weighting\nvec2 w0(vec2 a){\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nvec2 w1(vec2 a){\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nvec2 w2(vec2 a){\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nvec2 w3(vec2 a){\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 is the amplitude function\nvec2 g0(vec2 a){\n    return w0(a) + w1(a);\n}\n\n// h0 and h1 are the two offset functions\nvec2 h0(vec2 a){\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nvec2 h1(vec2 a){\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 bicubic(sampler2D tex, vec2 uv, vec2 textureLodSize, float lod){\n\t\n    uv = uv * textureLodSize + 0.5;\n    \n\tvec2 iuv = floor(uv);\n\tvec2 f = fract(uv);\n\n    // Find offset in texel\n    vec2 h0 = h0(f);\n    vec2 h1 = h1(f);\n\n    // Four sample points\n\tvec2 p0 = (iuv + h0 - 0.5) / textureLodSize;\n\tvec2 p1 = (iuv + vec2(h1.x, h0.y) - 0.5) / textureLodSize;\n\tvec2 p2 = (iuv + vec2(h0.x, h1.y) - 0.5) / textureLodSize;\n\tvec2 p3 = (iuv + h1 - 0.5) / textureLodSize;\n\t\n    // Weighted linear interpolation\n    // g0 + g1 = 1 so only one is needed for a mix\n    vec2 g0 = g0(f);\n    return mix( mix(textureLod(tex, p3, lod), textureLod(tex, p2, lod), g0.x),\n                mix(textureLod(tex, p1, lod), textureLod(tex, p0, lod), g0.x), g0.y);\n}\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n\n    vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n    vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n\n    vec4 floorSample = bicubic(s, uv, lodSizeFloor.xy, floor(lod));\n    vec4 ceilSample = bicubic(s, uv, lodSizeCeil.xy, ceil(lod));\n\n    return mix(floorSample, ceilSample, fract(lod));\n}\n\nvec4 getBlur(sampler2D s, vec2 uv, float blur){\n    float maxLod = floor(log2(iChannelResolution[0].x));\n    float lod = mix(0.0, maxLod-1.0, blur);\n    return textureBicubic(s, uv, lod);\n}\n\n//----------------------------- Tonemapping and output ------------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n\n    if(renderGlow){\n    \n        vec3 glow = vec3(0);\n        glow += getBlur(iChannel0, uv, 0.2).rgb;\n        glow += getBlur(iChannel0, uv, 0.3).rgb;\n        glow += getBlur(iChannel0, uv, 0.55).rgb;\n        glow += getBlur(iChannel0, uv, 0.6).rgb;\n        glow /= 4.0;\n\n        col += 0.5*glow;\n\n    }\n    \n    // Uncomment to see spectrum texture\n    //col = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    \n    // Tonemapping\n    col = ACESFilm(col);\n    \n    // Gamma\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2021 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n\n// Minimum dot product value\nconst float minDot = 1e-3;\n\n// Clamped dot product\nfloat dot_c(vec3 a, vec3 b){\n\treturn max(dot(a, b), minDot);\n}\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n#define CAMERA_DIST 2.9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(5.0, 3.0)*mouseMove, mouse.xy);\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 2.0*PI);\n        newMouse.y = min(0.99, max(-0.99, newMouse.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames\n            if(iFrame < 5){\n                newMouse = vec4(1.15, 0.2, 0.0, 0.0);\n            }\n            fragColor = vec4(newMouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Set camera position from mouse information.\n            vec3 cameraPos = CAMERA_DIST * \n                                vec3(sin(newMouse.x), -sin(newMouse.y), -cos(newMouse.x));\n                                \n            fragColor = vec4(cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Blackbody radiation spectrum. \n    Does not match other spectra seen online. Seems about 500K off.\n    Some images show 1300C as bright white whereas images of lava vary from red to bright\n    yellow. Exposure and adaption seems to affect the look a lot.\n    Comments and critique are very welcome.\n\n    Based on:\n    \n    https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n    https://scipython.com/blog/converting-a-spectrum-to-a-colour/\n    https://www.fourmilab.ch/documents/specrend/\n    https://en.wikipedia.org/wiki/Black-body_radiation\n    https://en.wikipedia.org/wiki/Planck%27s_law\n    https://en.wikipedia.org/wiki/Draper_point\n    https://en.wikipedia.org/wiki/Stefan%E2%80%93Boltzmann_law\n\n    https://www.shadertoy.com/view/MdBSRW\n    https://www.shadertoy.com/view/llSyRD\n    https://www.shadertoy.com/view/lsKczc\n*/\n\n// In C\nfloat MAX_TEMP = 2500.0;\n\n// The Draper point is the limit above which all solids glow with visible light\nfloat draperPoint = 525.0;\n\n// Given a temperature T, return the spectral radiance for wavelength lambda\nfloat planck(float T, float wavelength){\n\n    // Wavelength in metres\n    float wlm = wavelength * 1e-9;\n    \n    return (3.74183e-16 / pow(wlm, 5.0)) / (exp(1.4388e-2 / (wlm * T)) - 1.0);\n}\n\nconst mat3 XYZ_RGB_Matrix = (mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n));\n\nvec3 XYZToRGB(vec3 XYZ){\n    return XYZ_RGB_Matrix * XYZ;\n}\n\nvec3 spectrumToXYZ(float T){\n\n    // http://www.cie.co.at/technical-work/technical-resources\n    vec3 standardObserver1931[] =\n        vec3[] (\n        vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n        vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n        vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n        vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n        vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n        vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n        vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n        vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n        vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n        vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n        vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n        vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n        vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n        vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n        vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n        vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n        vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n        vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n        vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n        vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n        vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n        vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n        vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n        vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n        vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n        vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n        vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n        vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n        vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n        vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n        vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n        vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n        vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n        vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n        vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n        vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n        vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n        vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n        vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n        vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n        vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n        vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n        vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n        vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n        vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n        vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n        vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n        vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n        vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n        vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n        vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n        vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n        vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n        vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n        vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n        vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n        vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n        vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n        vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n        vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n        vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n        vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n        vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n        vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n        vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n        vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n        vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n        vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n        vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n        vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n        vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n        vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n        vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n        vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n        vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n        vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n        vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n        vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n        vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n        vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n        vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n    );\n    int size = 81;\n    \n    vec3 XYZ = vec3(0);\n    \n    for (int i = 0; i < size; i++){\n    \n        float radiance = planck(T, 380.0 + float(i) * 5.0);\n        \n        XYZ += radiance * standardObserver1931[i];\n        \n    }\n\n    return XYZ;\n}\n\nvec3 constrainRGB(vec3 col){\n\n    float w = -min(col.r, min(col.g, col.b));\n    \n    if (w > 0.0) {\n        col += w;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).r > 0.0;\n    \n    if(iFrame == 0 || resolutionChanged){\n    \n        float T;\n\n        T = 0.25 * draperPoint + uv.x * MAX_TEMP;\n\n        // C to K\n        T += 273.15;\n        MAX_TEMP += 273.15;\n        draperPoint += 273.15;\n\n        col = spectrumToXYZ(T);\n        \n        if(iFrame == 0 || resolutionChanged){\n            col = XYZToRGB(col);\n        }\n\n        col = constrainRGB(col);\n\n        float largest = max(max(col.r, col.g), col.b);\n        col /= largest > 0.0 ? largest : 1.0;\n\n        // The Stefanâ€“Boltzmann law gives the luminosity of a black body from its temperature\n        // The amount of radiance emitted is proportional to the 4th power of the temperature\n        float luminosity = 5.670374419e-8 * pow(T, 4.0);\n        float minLuminosity = 5.670374419e-8 * pow(draperPoint*0.25, 4.0);\n        float maxLuminosity = 5.670374419e-8 * pow(MAX_TEMP, 4.0);\n\n        // Pretty hacky\n        float EXPOSURE = 60.0;\n\n        col *= EXPOSURE * max(0.0,(luminosity-minLuminosity) / (maxLuminosity-minLuminosity));\n    \n    }else{\n        col = texelFetch(iChannel1, ivec2(fragCoord.xy), 0).rgb;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Perlin noise FBM for heightmap and Worley noise for texture fade out control.\n\n// GLSL version of 2D periodic seamless perlin noise.\n// https://github.com/g-truc/glm/blob/master/glm/gtc/noise.inl\n\nvec4 taylorInvSqrt(vec4 r){\n    return 1.79284291400159-0.85373472095314*r;\n}\n\nvec4 mod289(vec4 x){\n  return x-floor(x*(1.0/289.0))*289.0;\n}\n\nvec4 permute(vec4 x){\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec2 fade(vec2 t){\n  return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlin(vec2 Position, vec2 rep){\n    vec4 Pi = floor(vec4(Position.x, Position.y, Position.x, Position.y)) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(vec4(Position.x, Position.y, Position.x, Position.y)) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, vec4(rep.x, rep.y, rep.x, rep.y)); // To create noise with explicit period\n    Pi = mod(Pi, vec4(289)); // To avoid truncation effects in permutation\n    vec4 ix = vec4(Pi.x, Pi.z, Pi.x, Pi.z);\n    vec4 iy = vec4(Pi.y, Pi.y, Pi.w, Pi.w);\n    vec4 fx = vec4(Pf.x, Pf.z, Pf.x, Pf.z);\n    vec4 fy = vec4(Pf.y, Pf.y, Pf.w, Pf.w);\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = float(2) * fract(i / float(41)) - float(1);\n    vec4 gy = abs(gx) - float(0.5);\n    vec4 tx = floor(gx + float(0.5));\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(vec2(Pf.x, Pf.y));\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return float(2.3) * n_xy;\n}\n\nfloat hash(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\n// From Shadertoy somewhere but not sure where originally.\nfloat noise(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0 - 2.0 * f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(\n\tmix(\n       \tmix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x),\n\t\tf.y),\n\tmix(\n\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\tf.y),\n\tf.z);\n}\n\nfloat TILES = 1.0;\n\nfloat worley(vec3 pos, float numCells){\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n\t\t\tfor (int z = -1; z <= 1; z++){\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - noise(mod(tp, numCells / TILES));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn 1.0 - clamp(d, 0.0, 1.0);\n}\n\nfloat fbm(vec2 pos, vec2 scale){\n    float res = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    float sum = 0.0;\n    \n    int limit = 5;\n    \n    for(int i = 0; i < limit; i++){ \n        float offset = float(limit-i);\n        res += perlin(freq*(pos+offset), freq*scale) * amp;\n\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return res/float(limit);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).r > 0.0;\n    \n    if(iFrame == 0 || resolutionChanged){\n\n        float scale = 32.0;\n\n        // For seamless texture, UV scale has to match rep\n        float noise = perlin(scale*uv, vec2(scale));\n        noise = 0.5+0.5*(fbm(scale*uv, vec2(scale)));\n\n        scale = 2.0;\n        float worley = worley(scale*vec3(uv, 0.0), (scale));\n        \n        col = vec3(noise, worley, 0.0);\n        \n    }else{\n        col = texelFetch(iChannel1, ivec2(fragCoord.xy), 0).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\nconst int MAX_STEPS = 50;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 5.0;\nconst float EPSILON = 1e-4;\nconst float DETAIL_EPSILON = 2e-3;\nconst float SHADOW_SHARPNESS = 2.0;\nconst float DETAIL_HEIGHT = 0.25;\nconst vec3 DETAIL_SCALE = vec3(1.0);\nconst vec3 BLENDING_SHARPNESS = vec3(8.0);\n\n// The height where low and high frequency texturing switch. \n// The border between the magma and the rock on the upper body.\nconst float TRANSITION = 0.35;\n\n// Comment out for simple lighting and potentially better performance\n#define PBR\n\nconst vec3 skyColour = 0.025 * vec3(0.09, 0.33, 0.81);\n\n// Azimuth\nconst float sunLocation = -1.2;\nconst float sunHeight = 0.75;\n\nvec3 getSkyColour(vec3 rayDir){\n    return skyColour + mix(vec3(0.015,0,0), vec3(0), rayDir.y);\n}\n\n// https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//-------------------------------- Rotations --------------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\nvec3 rotateX(vec3 p, float angle){\n    return rotate(p, vec4(sin(angle/2.0), 0.0, 0.0, cos(angle/2.0)));\n}\nvec3 rotateY(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, sin(angle/2.0), 0.0, cos(angle/2.0)));\n}\nvec3 rotateZ(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, 0.0, sin(angle), cos(angle)));\n}\n\n\n//---------------------------- Distance functions ----------------------------\n\n// Distance functions and operators from:\n// https://iquilezles.org/articles/distfunctions\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\n//------------------------ Operations ------------------------\n\n// https://iquilezles.org/articles/smin\nfloat smoothMin(float a, float b, float k){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement(vec3 p){\n    return sin(p.x)*sin(p.y)*sin(p.z);\n}\n\nfloat opDisplace(vec3 p){\n    vec3 offset = 0.1*iTime * normalize(vec3(1.0, 1.0, 0.1));\n    return displacement(15.0*(p+offset));\n}\n\nvec4 opElongate( in vec3 p, in vec3 h ){ \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n//-------------------------- AABB -------------------------\n\n// Only evaluate the distance function when near a feature or when looking at it.\n// This results in sgnificant speed-up as we skip complex distance calculations \n// for most pixels.\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 boxMin, vec3 boxMax){\n    float eps = 1e-4;\n\treturn  (p.x > boxMin.x-eps) && (p.y > boxMin.y-eps) && (p.z > boxMin.z-eps) && \n\t\t\t(p.x < boxMax.x+eps) && (p.y < boxMax.y+eps) && (p.z < boxMax.z+eps);\n}\n\nbool testAABB(vec3 org, vec3 dir, vec3 boxMin, vec3 boxMax){\n\tvec2 intersections = intersectAABB(org, dir, boxMin, boxMax);\n\t\n    if(insideAABB(org, boxMin, boxMax)){\n        intersections.x = 1e-4;\n    }\n    \n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n//------------------------- Geometry -------------------------\n\nfloat getSDF(vec3 p, vec3 dir){\n    p.y -= 0.4;\n    float dist = 1e5;\n    vec3 q = p;\n    \n    if(testAABB(p, dir, vec3(-0.75, -2.0, -1.6), vec3(1.2, 0.85, 1.6))){\n        // Upper body\n        // Two round cones for chest and shoulders\n        q.z = abs(q.z);\n        q = rotateX(q, -1.7);\n\n        dist = smoothMin(dist, sdRoundCone(q, 0.6, 0.45, 0.5), 0.5);\n\n        // Neck\n        q = p;\n        q.y -= 0.1;\n        q.x += 0.05;\n        q = rotateZ(q, 0.65);\n        dist = smoothMin(dist, sdRoundCone(q, 0.45, 0.2, 0.75), 0.1);\n\n        // Head\n        q = p;\n        q.y -= 0.4;\n        q.x -= 0.75;\n\n        // Make a round box by elongating a sphere\n        float distHead = sphereSDF(opElongate(q, vec3(0.1, 0.22, 0.3)).xyz, 0.05);\n\n        // Subtract two smooth spheres from either side of the head for a skull-like look\n        q.z = abs(q.z);\n        q.z -= 0.4;\n        q.y += 0.4;\n        float distSphere = sphereSDF(q, 0.3);\n\n        distHead = opSmoothSub(distSphere, distHead, 0.1);\n\n        dist = smoothMin(dist, distHead, 0.1);\n\n        // Lower body\n        q = rotateX(p, PI);\n        q.y -= 0.15;\n        q.x += 0.05;\n        dist = smoothMin(dist, sdRoundCone(q, 0.55, 0.25, 1.2), 0.15);\n\n        // Arms\n        q = p;\n        q.z = abs(q.z);\n        q.z -= 0.7;\n        q.y += 0.1;\n        q = rotateZ(q, -1.7);\n        q = rotateX(q, -0.2);\n        dist = smoothMin(dist, sdRoundCone(q, 0.3, 0.2, 0.6), 0.15);\n\n        // Forearms\n        q = p;\n        q.z = abs(q.z);\n        q.z -= 0.825;\n        q.y += 0.7;\n        q.x -= 0.2;\n        q = rotateZ(q, -2.);\n        dist = smoothMin(dist, sdRoundCone(q, 0.2, 0.15, 0.4), 0.05);\n\n        // Fists\n        q = p;\n        q.z = abs(q.z);\n        q.z -= 0.77;\n        q.y += 0.95;\n        q.x -= 0.7;\n        q = rotateZ(q, PI*0.56);\n        dist = smoothMin(dist, sdRoundCone(q, 0.16, 0.1, 0.15), 0.15);\n\n        // Lava droplets\n        q = p;\n        q.y += 1.9;\n        q.x += 0.06;\n        q.z -= 0.05;\n        dist = smoothMin(dist, sdRoundCone(q, 0.02, 0.01, 0.5), 0.15);\n\n        q = p;\n        q.y += 1.7;\n        q.xz -= 0.1;\n        dist = smoothMin(dist, sdRoundCone(q, 0.02, 0.01, 0.5), 0.15);\n\n        q = p;\n        q.z -= 0.77;\n        q.y += 1.4;\n        q.x -= 0.65;\n\n        dist = smoothMin(dist, sdRoundCone(q, 0.02, 0.01, 0.25), 0.1); \n    }\n   \n    // Displace the surface for larger waves\n    // Add more displacement lower down\n    float strength = mix(0.0, 0.025, smoothstep(TRANSITION, TRANSITION-0.1, p.y+0.4));\n    dist -= strength * (0.5+0.5*opDisplace(p));\n   \n    return dist;\n}\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, out float glow){\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = ZERO; i < MAX_STEPS; i++) {\n        \n        // Get the sdf value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir, rayDir);\n        glow += getGlow(dist, 1e-3, 0.6);\n        \n        // If it is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if (dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += dist;\n        \n        // Test if we have left the scene\n        if (depth >= end){\n            return end;\n        }\n    }\n\n    return depth;\n}\n\n\n//----------------------------- Texture distortion -----------------------------\n\n// Find the local gradients in the X and Y directions which we use as the velocities \n// of the texure distortion\nvec2 getGradient(vec2 uv){\n\n    float scale = 0.1;\n    float delta = 1e-1;\n    \n    uv *= scale;\n    \n    float data = texture(iChannel2, uv).r;\n    float gradX = data - texture(iChannel2, uv-vec2(delta, 0.0)).r;\n    float gradY = data - texture(iChannel2, uv-vec2(0.0, delta)).r;\n    \n    return vec2(gradX, gradY);\n}\n\n// https://catlikecoding.com/unity/tutorials/flow/texture-distortion/\nfloat getDistortedTexture(vec2 uv, float height){\n\n    float strength = 0.6;\n    \n    // The texture is distorted in time and we switch between two texture states.\n    // The transition is based on Worley noise which will shift the change of differet parts\n    // for a more organic result\n    float time = 0.25 * iTime + texture(iChannel2, uv).g;\n   \n    // Make the texture on the upper body of the elemental static and more coarse\n    if(height > TRANSITION){\n        time = 0.0;\n        uv *= 0.2;\n    }\n    \n    float f = fract(time);\n    \n    // Get the velocity at the current location\n    vec2 grad = getGradient(uv);\n    vec2 distortion = strength * vec2(grad.x, grad.y);\n    \n    // Get two shifted states of the texture distorted in time by the local velocity.\n    // Loop the distortion from 0 -> 1 using fract(time)\n    float distort1 = texture(iChannel2, uv + f * distortion).r;\n    float distort2 = texture(iChannel2, 0.1 + uv + fract(time + 0.5) * distortion).r;\n\n    // Mix between the two texture states to hide the sudden jump from 1 -> 0.\n    // Modulate the value returned by the velocity to make slower regions darker in the final\n    // lava render.\n    return (1.0-length(grad)) * (mix(distort1, distort2, abs(1.0 - 2.0 * f)));\n}\n\n//----------------------------- Normal mapping -----------------------------\n\n// https://tinyurl.com/y5ebd7w7\nvec3 getTriplanar(vec3 position, vec3 normal, float height){\n    \n    // A hack to get the flow direction on the arms to be consistent\n    vec2 xpos = position.zx;\n    if(abs(position.z) > 0.6){\n        // If position is below 0.0, flip the uv direction for downwards flow\n        xpos = mix(xpos, vec2(position.z, -position.x), smoothstep(-0.0, -0.2, position.y));\n    }\n    vec3 xaxis = vec3(getDistortedTexture(DETAIL_SCALE.x*(position.zy), height));\n    vec3 yaxis = vec3(getDistortedTexture(DETAIL_SCALE.y*(xpos), height));\n    vec3 zaxis = vec3(getDistortedTexture(DETAIL_SCALE.z*(position.xy), height));\n   \n    vec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n    blending = pow(blending, BLENDING_SHARPNESS);\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= b;\n\n    return\txaxis * blending.x + \n       \t\tyaxis * blending.y + \n        \tzaxis * blending.z;\n}\n\n// Return the position of p extruded in the normal direction by normal map\nvec3 getDetailExtrusion(vec3 p, vec3 normal, float height){\n\n    float detail = DETAIL_HEIGHT * length(getTriplanar(p, normal, height));\n    \n    // Increase the normal extrusion height on the upper body\n    float d = 1.0 + smoothstep(TRANSITION-0.1, TRANSITION, height);\n    return p + d * detail * normal;\n}\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, vec3 dir){\n    vec3 n = vec3(0.0);\n    int id;\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON, dir);\n    }\n    return normalize(n);\n}\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n// Return the normal after applying a normal map\nvec3 getDetailNormal(vec3 p, vec3 normal, float h){\n\n    vec3 tangent;\n    vec3 bitangent;\n    \n    // Construct orthogonal directions tangent and bitangent to sample detail gradient in\n    pixarONB(normal, tangent, bitangent);\n    \n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n\n    vec3 delTangent = vec3(0);\n    vec3 delBitangent = vec3(0);\n    \n    for(int i = ZERO; i < 2; i++){\n        \n        //i to  s\n        //0 ->  1\n        //1 -> -1\n        float s = 1.0 - 2.0 * float(i&1);\n    \n        delTangent += s * getDetailExtrusion(p + s * tangent * DETAIL_EPSILON, normal, h);\n        delBitangent += s * getDetailExtrusion(p + s * bitangent * DETAIL_EPSILON, normal, h);\n\n    }\n    \n    return normalize(cross(delTangent, delBitangent));\n}\n//------------------------------- Shadows -------------------------------\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 pos, vec3 rayDir, float start, float end, float k ){\n    float res = 1.0;\n    float depth = start;\n    for(int counter = ZERO; counter < 32; counter++){\n        float dist = getSDF(pos + rayDir * depth, rayDir);\n        if( abs(dist) < EPSILON){ return 0.0; }       \n        if( depth > end){ break; }\n        res = min(res, k*dist/depth);\n        depth += dist;\n    }\n    return saturate(res);\n}\n\n//---------------------------- PBR ----------------------------\n\n// Trowbridge-Reitz\nfloat distribution(vec3 n, vec3 h, float roughness){\n    float a_2 = roughness * roughness;\n\treturn a_2/(PI * pow(pow(dot_c(n, h), 2.0) * (a_2 - 1.0) + 1.0, 2.0));\n}\n\n// GGX and Schlick-Beckmann\nfloat geometry(float cosTheta, float k){\n\treturn (cosTheta) / (cosTheta * (1.0 - k) + k);\n}\n\nfloat smiths(float NdotV, float NdotL, float roughness){\n    float k = pow(roughness + 1.0, 2.0) / 8.0; \n\treturn geometry(NdotV, k) * geometry(NdotL, k);\n}\n\n// Fresnel-Schlick\nvec3 fresnel(float cosTheta, vec3 F0){\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n} \n\n// Cook-Torrance BRDF\nvec3 BRDF(vec3 p, vec3 n, vec3 viewDir, vec3 lightDir,\n          vec3 albedo, vec3 F0, float roughness, float metalness){\n          \n    vec3 h = normalize(viewDir + lightDir);\n    float NdotL = dot_c(lightDir, n);\n    float NdotV = dot_c(viewDir, n);\n\n    float cosTheta = dot_c(h, viewDir);\n    vec3 lambertian = albedo / PI;\n\n    float D = distribution(n, h, roughness);\n    vec3 F = fresnel(cosTheta, F0);\n\n    float G = smiths(NdotV, NdotL, roughness);\n    \n    vec3 specular =  D * F * G / max(0.0001, (4.0 * NdotV * NdotL));\n   \n    vec3 kD = (1.0 - F) * (1.0 - metalness);\n    return kD * lambertian + specular;\n}\n\n\n//------------------------------- Shading -------------------------------\n\nvec3 shadingPBR(vec3 p, vec3 n, vec3 rayDir, vec3 geoNormal){\n    vec3 I = vec3(0);\n\n    vec3 albedo = vec3(0.01);\n    vec3 F0 = vec3(0.04);\n    float roughness = 0.7;\n    float metalness = 0.0;\n\n    vec3 lightPosition = 100.0*normalize(vec3(cos(sunLocation), sunHeight, sin(sunLocation)));\n    vec3 lightColour = vec3(5);\n\n    vec3 vectorToLight = lightPosition - p;\n   \tvec3 lightDir = normalize(vectorToLight);\n    vec3 radiance = lightColour;\n    float shadow = softShadow(p + n * EPSILON * 2.0, lightDir, MIN_DIST,\n                              length(vectorToLight), SHADOW_SHARPNESS);\n                              \n    I += shadow\n        * BRDF(p, n, -rayDir, lightDir, albedo, F0, roughness, metalness) \n        * radiance \n        * dot_c(n, lightDir);\n\n  \n    // How much the fragment faces down\n    float lava = max(dot(n, vec3(0,-1,0)), 0.0);\n    // A reddish light from directly below.\n\tvec3 lavaLight = lava * vec3(1, 0.1, 0.01);\n    \n    float ambientStrength = 0.15;\n    vec3 ambientColour = getSkyColour(n);\n    \n    // Combine light\n    vec3 ambient = 0.02 * lavaLight + ambientStrength * ambientColour;\n    \n    return ambient + I;\n}\n\nvec3 shadingSimple(vec3 org, vec3 position, vec3 normal, vec3 rayDir){\n    \n    float ambientStrength = 0.15;\n    float diffuseStrength = 0.025;\n    float specularStrength = 0.02;\n    float shininess = 8.0;\n    \n    vec3 ambientColour = getSkyColour(normal);\n    vec3 diffuseColour = vec3(1.5);\n    vec3 specularColour = vec3(1);\n\n    vec3 lightPos = 100.0*normalize(vec3(cos(sunLocation), sunHeight, sin(sunLocation)));\n    vec3 lightDirection = normalize(lightPos-position);\n    \n    // How much a fragment faces the light\n\tfloat diff = max(dot(normal, lightDirection), 0.0);\n    \n    // Colour when lit by light\n\tvec3 diffuse = diff * diffuseColour;\n    \n\tvec3 halfwayDir = normalize(lightDirection - rayDir);  \n\tfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n\n\t// Colour of light sharply reflected into the camera\n\tvec3 specular = spec * specularColour;\n\n\tvec3 result = vec3(0.0); \n        \n    float shadow = softShadow(position + normal * EPSILON * 2.0, lightDirection, MIN_DIST,\n                              length(lightPos-position), SHADOW_SHARPNESS);\n    \n    // How much the fragment faces down\n    float lava = max(dot(normal, vec3(0,-1,0)), 0.0);\n    // A reddish light from directly below.\n\tvec3 lavaLight = lava * vec3(1, 0.2, 0.0);\n    \n    // Combine light\n    result += 0.02 * lavaLight;\n\n    // Light and material interaction\n    result += ambientStrength * ambientColour + \n              shadow * (diffuseStrength * diffuse + specularStrength * specular);\n    \n    return  result;\n}\n\n// Glow from magma\nvec3 getEmissive(vec3 p, vec3 n, float h){\n\n    // The depressions in the texture where we want to have glowing magma.\n    float depth = (1.0-length(getTriplanar(p, n, h)));\n    \n    if(h > TRANSITION){\n        // Upper body has deep grooves and is mostly cooled rock\n        // Modulate by distance from transition boundary to avoid abrupt cutoffs of glow\n        depth = smoothstep(TRANSITION, TRANSITION+0.1, h) * pow(2.25*(depth), 3.5);\n        // Add a subtle pulsating inner glow\n        depth += 0.0125 * (0.5+0.5*sin( 4.0 * p.y +iTime * 4.0));\n    }else{\n        // Lower body has mostly low level liquid lava\n        depth *= 1.4;\n        // Darken lava near the transition border\n        depth *= 1.0-smoothstep(TRANSITION-0.225, TRANSITION+0.1, h);\n    }\n    \n    // Lighten lower parts\n    if(h < -0.8){\n        depth += 0.15*smoothstep(-0.8, -1.1, h);;\n    }\n    \n    // For two glowing eyes, increase the emission within the vicinity of two positions\n    // on the face\n    vec3 eyes = vec3(0.9, 0.8, 0.15);\n    float dist = smoothstep(0.05, 0.0, length(abs(p) - eyes));\n    depth += dist * 0.5;\n    \n    depth = saturate(depth);\n    \n    vec3 glow = 0.2 * texture(iChannel1, vec2(depth)).rgb;\n    return glow;\n\n}\n\n\n//----------------------------- Tonemapping and output ------------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\t//----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(60.0, fragCoord);\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n    vec3 targetDir = -cameraPos;\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\t\n    // Accumulate a glow along the view ray from the distance marching. Use it for a subtle\n    // silhouette effect.\n    float glow = 0.0;\n    \n    // Find the distance to where the ray stops.\n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, glow);\n    \n    vec3 col = vec3(0);\n    \n    if(dist < MAX_DIST){\n        vec3 position = cameraPos + rayDir * dist;\n        vec3 geoNormal = getNormal(position, rayDir);\n\n        // Avoid artefacts when trying to sample detail normals across Z-plane. Shape \n        // deformation increases the region where visible errors occur.\n        if(abs(geoNormal.z) < 1e-5){\n            geoNormal.z = 1e-5;\n        }\n\n        geoNormal = normalize(geoNormal);\n   \n        // Because the texture shifts in time, there isn't a way to smoothly transition \n        // to larger scale or slower speed regions. We therefore use a sharp border at a \n        // given height but offset the y value in the immediate region by noise. This will \n        // produce a curve instead of a line which looks better. Regions far away are not \n        // shifted.\n\n        float height = position.y;\n        vec2 uv = 0.15 * vec2(sin(position.x), cos(position.z));\n        float noise = 2.0 * (texture(iChannel2, uv).r - 0.5);\n        \n        // Get a gradient from 0.0 to 0.3 around the transition height\n        // Offset by a noise value in the range (-0.5, 0.5)\n        height += (1.0-smoothstep(0.0, 0.3, length(position.y - TRANSITION))) * noise;\n        \n        vec3 detailNormal = normalize(getDetailNormal(position, geoNormal, height));\n        \n        #ifdef PBR\n            col = shadingPBR(position, detailNormal, rayDir, geoNormal);\n        #else\n            col = shadingSimple(cameraPos, position, detailNormal, rayDir);\n        #endif\n        \n        col += getEmissive(position, geoNormal, height);\n\n    } else {\n        col = 0.75*getSkyColour(rayDir);\n        col += 0.01 * glow * vec3(1.0,0.15,0.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}