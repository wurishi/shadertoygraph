{"ver":"0.1","info":{"id":"llGSDV","date":"1485964707","viewed":5735,"name":"Light Sticks","username":"candycat","description":"Light sticks with raymarching, AA, bloom and cosine based color palettes. My first shadertoy in new year! Hope to have a colorful year ðŸ™‚","likes":31,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bloom Pass\n// Bloom shader (https://www.shadertoy.com/view/XslGDr)\n\nvec3 highlights(vec3 pixel, float thres)\n{\n\tfloat val = (pixel.x + pixel.y + pixel.z) / 3.0;\n\treturn pixel * smoothstep(thres - 0.1, thres + 0.1, val);\n}\n\nvec3 samplef(vec2 tc)\n{\n\treturn pow(texture(iChannel0, tc).xyz, vec3(2.2, 2.2, 2.2));\n}\n\nvec3 hsample(vec2 tc)\n{\n\treturn highlights(samplef(tc), 0.6);\n}\n\nvec3 blur(vec2 tc, float offs)\n{\n\tvec4 xoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.x;\n\tvec4 yoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.y;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.x)) * 0.00366;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.x)) * 0.01465;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.x)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.x)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.x)) * 0.00366;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.y)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.y)) * 0.05861;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.y)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.y)) * 0.05861;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.y)) * 0.01465;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, 0.0)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.y, 0.0)) * 0.09524;\n\tcolor += hsample(tc + vec2(    0.0, 0.0)) * 0.15018;\n\tcolor += hsample(tc + vec2(xoffs.z, 0.0)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.w, 0.0)) * 0.02564;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.z)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.z)) * 0.05861;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.z)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.z)) * 0.05861;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.z)) * 0.01465;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.w)) * 0.00366;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.w)) * 0.01465;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.w)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.w)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.w)) * 0.00366;\n\n\treturn color;\n}\n\nfloat square(int x) { return float(x * x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 tc = fragCoord.xy / iResolution.xy;\n\tvec3 col = blur(tc, 2.0);\n\tcol += blur(tc, 3.0);\n\tcol += blur(tc, 5.0);\n\tcol += blur(tc, 7.0);\n\tcol /= 4.0;\n\t\n\tcol += samplef(tc);\n    \n    // Vigneting\n    vec2 p = fragCoord.xy/iResolution.xy;\n    p = -1.0 + 2.0 * p;\n    p.x *= iResolution.x/iResolution.y;\n    col *= clamp(1.0 - length(p) * 0.4, 0.0, 1.0);\n    fragColor = vec4(col, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"///\n/// v.1: First released in 2017.02.01\n/// v.2: Add camera moving path control and replace with another bloom shader for better effects\n///\n\n// Raymarching Pass\n\n#define AA 1\n#define PRECIS 0.00\n#define DMIN 2.0\n#define DMAX 7.0\n#define HEIGHT 2.0\n\nfloat freqs[4];\n\n// ========= Noise ===========\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p, vec2(127.1, 311.7)),\n\t\t\t  dot(p, vec2(269.5, 183.3)));\n    \n    return fract(sin(p) * 43758.5453123);\n}\n\nfloat hash21(vec2 p)\n{\n\tfloat h = dot(p, vec2(127.1, 311.7));\n\t\n    return fract(sin(h) * 43758.5453123);\n}\n\nfloat hash11(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\n// ========= SDF =========\nfloat fBox(vec3 p, vec3 b)\n{\n  return length(max(abs(p)-b,0.0))-0.2;\n}\n\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); \n    return length( pa - ba * h ) - r;\n}\n\n// ========= Raymarching =========\nvec2 map(vec3 pos)\n{\n    vec2 fpos = fract(pos.xz); \n\tvec2 ipos = floor(pos.xz);\n    \n    float rid = hash21(ipos) + 0.5;\n\n    return vec2(fCapsule(vec3(fpos.x - 0.5, pos.y, fpos.y - 0.5), vec3(0.0, 0.0, 0.0), vec3(0.0, HEIGHT, 0.0), 0.1), rid);\n}\n\nvec3 normal(vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n                    \t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n                         \tmap(pos + eps.yyx).x - map(pos - eps.yyx).x));\n}\n\nvec2 render(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 50; i++) {\n       \tvec2 res = map(ro + t * rd);\n        t += res.x;\n        id = res.y;\n        if (res.x < PRECIS || t > DMAX) break; \n    }\n    \n    if (t > DMAX) id = -1.0;\n    \n    return vec2(t, id);\n}\n\nfloat height(vec3 pos)\n{\n    vec2 fpos = fract(pos.xz); \n\tvec2 ipos = floor(pos.xz);\n\t\n    float f = 0.0;\n\tfloat id = hash21(ipos);\n\tf += freqs[0] * clamp(1.0 - abs(id - 0.20)/0.30, 0.0, 1.0);\n\tf += freqs[1] * clamp(1.0 - abs(id - 0.40)/0.30, 0.0, 1.0);\n\tf += freqs[2] * clamp(1.0 - abs(id - 0.60)/0.30, 0.0, 1.0);\n\tf += freqs[3] * clamp(1.0 - abs(id - 0.80)/0.30, 0.0, 1.0);\n\n    f = pow(clamp(f, 0.0, 1.0), 2.0);\n    return f;\n}\n\n// Cosine based palettes: https://www.shadertoy.com/view/ll2GD3\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 raymarching(vec3 ro, vec3 rd)\n{\n    vec3 bg = vec3(0.0);\n    \n    vec2 res = render(ro, rd);\n    vec3 col;\n    if (res.y > -0.5) {\n        vec3 pos = ro + rd * res.x;\n        vec3 nor = normal(pos);\n        vec3 view = -rd;\n        float dif = dot(nor, view);\n        dif = dif * 0.5 + 0.5;\n        \n        float h = clamp(height(pos) + 0.2, 0.0, 1.0) * HEIGHT;\n        vec3 light = vec3(0.3 + hash11(res.y * 0.2), 0.3 + hash11(res.y * 0.4), 0.3 + hash11(res.y * 0.6));\n        col = vec3(0.8, 0.85, 1.0);\n        light = palette(pos.y * 0.2, vec3(0.5, 0.5, 0.5),vec3(0.5, 0.5, 0.5),vec3(1.0, 1.0, 0.5), light);\n        col = mix(light, col, smoothstep(h * 0.8, h, pos.y)) * dif;\n    \tcol = mix(bg, col, smoothstep(0.0, 0.3, pos.y));\n    }\n    \n    // distance fog\n    col = mix(col, bg, smoothstep(DMIN, DMAX, res.x));\n    \n    //return vec3(res.y + 1.0);\n    return col;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 path(float time, vec2 mo)\n{\n\treturn vec3(32.0 * cos(0.2 + 0.05 * time + 0.1 * mo.x), 3.0, 32.0 * sin(0.1 + 0.055 * time + 0.1 * mo.x));\n}\n\nvoid moveCamera(float time, vec2 mo, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl)\n{\t\n\toRo = path(time, mo);\n\toTa = path(time + 2.0, mo * 0.5);\n\toTa.y *= 0.2;\n\toCr = 0.3 * cos(0.07 * time);\n    oFl = 1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    freqs[0] = texture(iChannel0, vec2( 0.01, 0.25)).x;\n\tfreqs[1] = texture(iChannel0, vec2( 0.07, 0.25)).x;\n\tfreqs[2] = texture(iChannel0, vec2( 0.15, 0.25)).x;\n\tfreqs[3] = texture(iChannel0, vec2( 0.30, 0.25)).x;\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // Mouse\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    // Rotate the camera\n\tvec3 ro, ta;\n    float roll, fl;\n    moveCamera(iTime, mo, ro, ta, roll, fl);\n    // Compute the ray\n    mat3 camMat = setCamera(ro, ta, roll);\n    vec3 rd;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    for (int i = -AA; i <= AA; i++) {\n        for (int j = -AA; j <= AA; j++) {\n            rd = camMat * normalize(vec3(p.xy + 1.0/iResolution.y * vec2(i,j), fl));\n    \t\tcol += raymarching(ro, rd);\n        }\n    }\n    col /= float((2 * AA + 1) * (2 * AA + 1));\n    \n    // Calculate color\n    col = pow(col, vec3(0.454));\n\tfragColor = vec4(col, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}