{"ver":"0.1","info":{"id":"tsV3Dh","date":"1570220694","viewed":192,"name":"Sky Formations","username":"ailanthus","description":"Clouds generated with noise distorted by more noise and raymarched with a very basic lighting  approximation with two light sources.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds","cloud","sky","formations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// derivative noise by iq. https://www.shadertoy.com/view/4dffRH\n\nvec3 hash( vec3 p ) // i'm supposed to replace this with something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns 3D value noise (in .x)  and its derivatives (in .yzw)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = va + \n              u.x*(vb-va) + \n              u.y*(vc-va) + \n              u.z*(ve-va) + \n              u.x*u.y*(va-vb-vc+vd) + \n              u.y*u.z*(va-vc-ve+vg) + \n              u.z*u.x*(va-vb-ve+vf) + \n              u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n              \n    vec3 d = ga + \n             u.x*(gb-ga) + \n             u.y*(gc-ga) + \n             u.z*(ge-ga) + \n             u.x*u.y*(ga-gb-gc+gd) + \n             u.y*u.z*(ga-gc-ge+gg) + \n             u.z*u.x*(ga-gb-ge+gf) + \n             u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh) +   \n             \n             du * (vec3(vb-va,vc-va,ve-va) + \n                   u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + \n                   u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + \n                   u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) );\n                   \n    return vec4( v, d );                   \n}\n\nvec4 recursive_noise(vec3 p, float octaves){\n    vec4 n = vec4(0.);\n    for (float i = 0.; i < octaves; i += 1.){\n        float e = pow(2., i);\n        vec3 mini_pos = p*e;\n        //mini_pos.w *= e; // Smaller is noisier\n        n += noised(mini_pos)/e;\n    }\n    return n/2.;\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 2.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.2; // cutoff for clouds\n\nconst vec3 LIGHT_1 = vec3(0, 1, 0);\nconst vec3 LIGHT_2 = normalize(vec3(10, 3, -10)); // backlight\n\n//const vec3 LIGHT_1 = LIGHT_2;\n\n\nfloat sphere(vec3 samplePoint, float radius) {\n    return clamp(-length(samplePoint) + radius, 0., 1.);\n}\n\n\nfloat spheres(vec3 p){\n\tvec3 side = vec3(3, 0, 1);\n    //samplePoint.z += 1.;\n    return sphere(p, 2.) + sphere(p+side, 1.) + sphere(p-side, 1.);\n}\n\n\nvec4 sceneDeriv(vec3 voxel) {\n    //return spheres(voxel);\n    float scale = 3.; // larger noise\n    float p_scale = .5;\n    //vec4 p_noise = noised(voxel/8.-iTime); // perterbation noise, using derivative\n    \n    // Recursive displacement on normal noise\n    //vec4 p_noise = recursive_noise(voxel/p_scale-iTime/32., 8.);\n    \n    // move\n    voxel.xyz -= iTime/8.;\n    // change\n    float change = iTime/1.;\n    vec4 p_noise = noised(voxel*vec3(.5, 1, 1)-change/16.)/4.;\n    p_noise += noised(voxel*vec3(1, 2, 2) -change/4.)/4.;\n    p_noise += noised(-voxel*vec3(6, 6, 6)+change)/16.;\n    //vec4 noise = recursive_noise(voxel/scale + p_noise.yzw/4.1, 8.);\n    vec4 noise = noised(voxel/scale + p_noise.yzw);\n    \n\t//vec4 noise = recursive_noise(voxel*scale, 8.);\n    //vec4 noise = recursive_noise(vec3(voxel.x, voxel.y, voxel.z-iTime/(scale)), 8.);\n    noise.x = (0., (noise.x - EPSILON)/(1.-noise.x)); // cut off below epsilon and respread\n    return noise;\n    // we have no use for negative noise values, unless we want them as bad distance estimates\n}\n\nfloat scene(vec3 voxel){\n    //return spheres(voxel);\n\treturn sceneDeriv(voxel).x;\n}\n\n// Returns the extent to which a cloud bit is in \"shadow\"\n// Assuming a relative to the normalized light direction\nfloat getShadow(vec3 point, vec3 lightDirection, float end){\n    float step_length = .05;\n    float dist = 0.; // distance to edge of cloud in light direction\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        dist += step_length;\n        float new_point = scene(point + dist * lightDirection);\n        if (new_point < EPSILON) {\n            return dist;\n        }\n        dist += step_length;\n        if (dist >= end) {\n            return dist;\n        }\n    }\n    return dist;\n}\n\n// Check one point, shadow is relative change\n// Pick an arbitrary lightward neighbor\n// Shadow is density of neighbor + difference in densities\nfloat fastShadow(vec3 point, vec3 lightDirection){\n    float dist = .2; // distance to edge of cloud in light direction\n    float density = scene(point);\n    float neighbor = scene(point + dist * lightDirection);\n    //float volume_difference = scene(point + dist * lightDirection) - density;\n    // If volume_difference is negative (lighter), no shadow\n    float shadow = clamp((neighbor*4.-density*1.)*1.+.1, 0., 1.);\n    // effectively mixing difference (rough approximation of derivative)\n    // with neighbor density\n    return shadow;\n}\n    \nfloat sampleShadow(vec3 point, vec3 lightDirection){\n    float dist = 0.0; // distance to edge of cloud in light direction\n    float density = scene(point);\n    float shadow = 0.;\n    for (int i = 0; i < 3; i++) {\n        dist += 0.1;\n        float neighbor = scene(point + dist * lightDirection);\n        shadow += neighbor;\n        shadow -= density/2.; // this makes trends matter.\n        // in liight density, it will still be dark if neighbors are darker.\n    }\n    //float volume_difference = scene(point + dist * lightDirection) - density;\n    // If volume_difference is negative (lighter), no shadow\n    shadow = clamp(shadow, 0., 1.);\n\n    return shadow;\n}\n\n// Blends colors moving forward using alpha channels.\nvec4 composite(vec4 foreground, vec4 background){\n    float f_alpha = foreground.w;\n    float b_alpha = background.w * (1.-f_alpha);\n    vec3 color = foreground.xyz + background.xyz * b_alpha;\n\t//alpha = 1.-(1.-alpha)*(1.-background.w);\n\tfloat new_alpha = f_alpha + b_alpha;\n\treturn vec4(color, new_alpha);\n}\n\nvec4 shootRay(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec4 color = vec4(0); // start transparent\n    float depth = start;\n    float volume = 0.;\n    float max_shaded = 2.;\n    float step_length = .05;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // Distance according to SDF\n        vec3 point = eye + depth * marchingDirection;\n        float density = scene(point);\n        // float travel = dist;\n        float travel = step_length;\n        if (density > 0.) {\n            float max_density = .5;\n            // put a cap on density variance. \n            // clouds can still have irregular translucent edges, but no weird opaque cores.\n            density = min(density, max_density)/(1.-max_density);\n            float skyFade = 1.-(depth/end); // further away becomes fainter\n            //float light = (max_shaded-getShadow(point, vec3(0, 1, 0), max_shaded))/max_shaded;\n\t\t\tfloat opacity = density * .1 + .0;\n            //float opacity = .1;\n            vec3 light = vec3((1.-fastShadow(point, LIGHT_1)));\n            vec3 light2 = vec3((1.-fastShadow(point, LIGHT_2)));\n            //vec3 light = vec3((1.-sampleShadow(point, LIGHT_1)));\n            //vec3 light2 = vec3((1.-sampleShadow(point, LIGHT_2)));\n            light *= vec3(.2, .3, .6)* 2.;\n            light2 *= vec3(.4, .2, .1)* 2.;\n            vec4 backColor = vec4(light+light2, opacity);\n\t\t\t//backColor.b = skyFade;\n            color = composite(color, backColor);\n            //color = composite(backColor, color);\n            //volume += .1 * step_length;\n            //volume += step_length * density * light;\n            //volume += ()\n            //volume += step_length * density;\n           \t//travel = .05;\n        }\n        //else{ travel = dist;}\n        depth += travel;\n        if (depth >= end) {\n            return color;\n        }\n    }\n    return color;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(85.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    vec4 color = shootRay(eye, dir, MIN_DIST, MAX_DIST);\n    //volume = clamp(volume, 0., 1.);\n    // volume *= .2;\n    float height = fragCoord.y/iResolution.y;\n    vec4 skyColor = vec4(.9-height*.6, .86-height*.4, .75-height*.15, 1);\n    skyColor = composite(color, skyColor);\n    \n    // gama correction. i.e. converting from light amount to screen/eye colorspace.\n    skyColor.rgb = pow( skyColor.rgb, vec3(1.0/2.2) );\n    fragColor = skyColor;\n}\n","name":"Image","description":"","type":"image"}]}