{"ver":"0.1","info":{"id":"ft3cRB","date":"1673819326","viewed":107,"name":"221raymarching","username":"Willisburg","description":"learning raymarching, dithering, keyboard controls, saving data in a texture.\nMovement: WASD shift space\nLook: arrow keys","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["raymarchingdithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = vec2(800, 450);\n    vec2 zoom = vec2(2.);\n    vec2 uv = fragCoord/iResolution.xy/_PixelSize;\n    fragColor = texture(iChannel0, uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define DELTA 0.01\n#define Iterations 1000\n#define FOV 80.\n#define NearPlane 0.\n#define FarPlane 10000.\n#define bgColour 0xee9b00\n#define FloorOdd 0x34a0a4\n#define FloorEven 0xd9ed92\n#define FloorSize 20.\n#define BottomSky 0xffba08\n#define UpperSky 0x023e8a\n#define PI 3.14159\n#define RAD 0.017453292\n#define AC 0x284b63\n\n\nstruct Object\n{\n    int type;\n    vec3 pos;\n    vec3 scale;\n    int color;\n    int id;\n};\nObject[] scene = Object[]\n(\n    Object(1, vec3(0, 20, 5), vec3(5),  0x15444a, 0),\n    Object(1, vec3(20, 0, 8), vec3(8),  0x90a955, 1),\n    Object(0, vec3(-1000, 500, 25), vec3(800),  0xd00000, 2),\n    Object(1, vec3(-20, 0, 5), vec3(5), 0xa0075d, 3),\n    Object(2, vec3(0, 0, 0), vec3(0), 0xffffff, 4),\n    Object(1, vec3(-1000, 500, 5000), vec3(700, 700, 5000), 0x90be6d, 5),\n    Object(0, vec3(-1000, 500, 1200), vec3(900),  0xd00000, 6)\n);\n\nfloat rounding(float dist, float rounding)\n{\n    return dist - rounding;\n}\n\nfloat circleSDF(vec3 pos, Object object)\n{\n    return length(pos - object.pos) - object.scale.x;\n}\n\n\nfloat boxSDF(vec3 pos, Object object)\n{\n    vec3 dist = abs(pos - object.pos) - object.scale;\n    return min(max(dist.x,max(dist.y,dist.z)),0.0) + length(max(dist,0.0));\n}\n\nfloat planeSDF(vec3 pos, Object object)\n{\n    return abs(pos.z - object.pos.z) - DELTA;\n}\n\nfloat SceneSDF(vec3 pos)\n{\n    float _minDist = 10000.;\n    vec3 dire = random(3., vec2(-1, 1), vec2(-1, 1), vec2(2000, 7000));\n    vec3 scale = random(20., vec2(500, 2000), vec2(500, 2000), vec2(900, 3000));\n    vec2 poss = normalize(vec2(dire.x, dire.y)) * dire.z;\n    Object farAway = Object(1, vec3(poss.x, poss.y, scale.z), scale, 0xffffff,10);\n    for(int i = 0; i < scene.length(); i++)\n    {\n        float _tempDist = 0.;\n        if(scene[i].id == 2 || scene[i].id == 6)\n        {\n            continue;\n        }\n        switch(scene[i].type)\n        {\n            case 0:\n            _tempDist = circleSDF(pos, scene[i]);\n            break;\n            case 1:\n            if(scene[i].id == 5)\n            {\n                float timer = (sin(iTime)+1.)*300.+20.;\n                vec3 rotatedPos = zRotation(pos - scene[i].pos, pos.z/timer*RAD) + scene[i].pos;\n                _tempDist = boxSDF(rotatedPos, scene[i]);        \n                _tempDist = max(_tempDist, -circleSDF(pos, scene[2]));\n                _tempDist = max(_tempDist, -circleSDF(pos, scene[6])); \n            }\n            else\n            {\n                _tempDist = boxSDF(pos, scene[i]);\n            }\n            break;\n            case 2:\n            _tempDist = planeSDF(pos, scene[i]);\n            break;\n        }\n        _tempDist = min(_tempDist, boxSDF(pos, farAway));\n        _minDist = min(_minDist, _tempDist);\n    }\n    \n    return _minDist;\n}\n\nObject GetObject(vec3 pos)\n{\n    Object _object;\n    vec3 dire = random(3., vec2(-1, 1), vec2(-1, 1), vec2(2000, 7000));\n    vec3 scale = random(20., vec2(500, 2000), vec2(500, 2000), vec2(900, 3000));\n    vec2 poss = normalize(vec2(dire.x, dire.y)) * dire.z;\n    Object farAway = Object(1, vec3(poss.x, poss.y, scale.z), scale, 0xffffff,10);\n    float _minDist = 10000.;\n    for(int i = 0; i < scene.length(); i++)\n    {\n        float _tempDist = 0.;\n        if(scene[i].id == 2 || scene[i].id == 6)\n        {\n            continue;\n        }\n        switch(scene[i].type)\n        {\n            case 0:\n            _tempDist = circleSDF(pos, scene[i]);\n            break;\n            case 1:\n            if(scene[i].id == 5)\n            {\n                float timer = (sin(iTime)+1.)*300.+20.;\n                vec3 rotatedPos = zRotation(pos - scene[i].pos, pos.z/timer*RAD) + scene[i].pos;\n                _tempDist = boxSDF(rotatedPos, scene[i]);      \n                _tempDist = max(_tempDist, -circleSDF(pos, scene[2]));\n                _tempDist = max(_tempDist, -circleSDF(pos, scene[6])); \n            }\n            else\n            {\n                _tempDist = boxSDF(pos, scene[i]);\n            }\n            break;\n            case 2:\n            _tempDist = planeSDF(pos, scene[i]);\n            break;\n        }\n        _tempDist = min(_tempDist, boxSDF(pos, farAway));\n        if(_tempDist < _minDist)\n        {\n            _object = scene[i];\n        }\n        _minDist = min(_minDist, _tempDist);\n    }\n    \n    return _object;    \n}\n\n\nvec3 GetNormal(vec3 pos)\n{\n    vec2 deltaV = vec2(0.001, 0);\n    float dist = SceneSDF(pos);\n    vec3 normal = vec3(\n                  dist - SceneSDF(pos - deltaV.xyy),\n                  dist - SceneSDF(pos - deltaV.yxy),  \n                  dist - SceneSDF(pos - deltaV.yyx)\n                  );\n    return normalize(normal);\n}\n\nfloat RayMarch(vec3 pos, vec3 dir)\n{\n    vec3 _pos = pos;\n    float dist = 0.;\n    for(int i = 0; i < Iterations; i++)\n    {\n        float _dist = SceneSDF(pos + dir * dist);\n        if(_dist <= DELTA)\n        {\n            break;\n        }\n        dist += _dist;\n    }\n    return dist;\n}\n\n\nvec3 getCoord() {\n    return vec3(\n    \ttexelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n}\n\nvec2 getAngles()\n{\n    return vec2(\n    \ttexelFetch(iChannel0, ivec2(3, 1), 0).r,\n        texelFetch(iChannel0, ivec2(4, 1), 0).r\n    );\n}\n\nfloat GetLight(vec3 pos, vec3 lightPos)\n{\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 normal = GetNormal(pos);\n\n    float dif = clamp(dot(normal, lightDir), 0., 1.);\n    float shadowDist = RayMarch(pos + normal * 0.1, lightDir);\n    if(shadowDist < length(lightPos - pos)) dif *= .1;\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > iResolution.x/_PixelSize || \n       fragCoord.y > iResolution.y/_PixelSize)\n    {\n        return;\n    }\n    \n    vec3 poss = getCoord();\n    vec3 camPos = vec3(poss.xy, poss.z+5.);\n    vec3 ray;\n    vec2 uv = fragCoord / iResolution.xy * _PixelSize;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= tan((FOV / 2.) * RAD);\n    ray.xz = uv;\n    ray.y = 1.;\n    \n    \n    ray = normalize(ray);\n    vec2 angles = getAngles();\n    \n    ray = xRotation(ray, angles.y * RAD);\n    ray = zRotation(ray, angles.x * RAD);\n    float focusDistance = 200.;\n    float focalRange = 70.;\n    float dist = RayMarch(camPos, ray.xyz);\n    float blur = abs(dist - focusDistance) / focalRange;\n    blur = clamp(blur, 0., 1.);\n    \n    vec3 rayPos = camPos + ray * dist;\n    \n    vec3 col = hexToVec3(bgColour);\n    if(dist < FarPlane)\n    {\n        vec3 normal = GetNormal(rayPos);\n        Object hitObject = GetObject(rayPos);\n\n\n        vec3 light = yRotation(vec3(5000., cos(iTime*RAD)*5000., sin(iTime*RAD)*5000.), -45.*RAD);\n        float dif = GetLight(rayPos, light);\n\n\n        if(hitObject.type == 2)\n        {\n            float posx = (rayPos.x - mod(rayPos.x, FloorSize))/FloorSize;\n            float posy = (rayPos.y - mod(rayPos.y, FloorSize))/FloorSize;\n            posx = mod(posx, 2.);\n            posy = mod(posy, 2.);\n            if(posx == posy)\n            {\n                hitObject.color = FloorEven;\n            }\n            else\n            {\n                hitObject.color = FloorOdd;\n            }\n\n        }\n        else if(hitObject.id == 5)\n        {\n            vec3 rotatedPos = rayPos;\n            float posx = (rotatedPos.x - mod(rotatedPos.x, FloorSize))/FloorSize;\n            float posy = (rotatedPos.z - mod(rotatedPos.z, FloorSize))/FloorSize;\n            posx = mod(posx, 2.);\n            posy = mod(posy, 2.);\n            if(posx == posy)\n            {\n                hitObject.color = FloorEven;\n            }\n            else\n            {\n                hitObject.color = FloorOdd;\n            }\n\n        }\n        col = hexToVec3(hitObject.color)*2.20*dif*vec3(1.30,1.00,0.70);\n        col = lerp(col, hexToVec3(bgColour), NearPlane, FarPlane, dist);\n    }\n    col /= 255.;\n    //col = mix(col, vec3(0.), blur);\n    fragColor = vec4(col,dist);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 findClosestColor(vec3 color)\n{\n    float dist = length(color - hexToVec3(_Palette[0]));\n    int index = 0;\n    for(int i = 1; i < _Palette.length(); i++)\n    {\n        float tempDist = length(color - hexToVec3(_Palette[i]));\n        if(dist > tempDist)\n        {\n            dist = tempDist;\n            index = i;\n        }\n    }\n    return hexToVec3(_Palette[index]);\n}\n\nvec3 dither(vec3 color, vec2 uv)\n{\n    vec2 duv = mod(uv * iResolution.xy * 2., 8.)/8.;\n    \n    float value = texture(iChannel1, duv).r;\n    \n    return findClosestColor(color * value * 2.);\n}\nfloat gaussian(vec2 offset, float sigma) {\n    float coefficient = 1.0 / (2.0 * 3.14159265 * sigma * sigma);\n    float exponent = -(dot(offset, offset) / (2.0 * sigma * sigma));\n    return coefficient * exp(exponent);\n}\n\nvec4 gaussianBlur(sampler2D image, vec2 uv, vec2 resolution, float sigma, float blur) {\n    vec4 color = vec4(0.0);\n    vec2 offset;\n    float kernelWeight;\n    float weightSum = 0.0;\n    int KernelSize = 5;\n    for (int x = -KernelSize; x <= KernelSize; x++) {\n        for (int y = -KernelSize; y <= KernelSize; y++) {\n            offset = vec2(x, y) / resolution;\n            kernelWeight = gaussian(offset, sigma * blur);\n            vec2 wrappedUV = uv + offset;\n            wrappedUV.x = mod(wrappedUV.x, 1./_PixelSize);\n            wrappedUV.y = mod(wrappedUV.y, 1./_PixelSize);\n            color += texture(image, wrappedUV) * kernelWeight;\n            weightSum += kernelWeight;\n        }\n    }\n    return color / weightSum;\n}\n\nfloat calculateBlur(sampler2D depthMap, vec2 uv, float focusDistance, float focalRange)\n{\n    float depth = texture(depthMap, uv).a;\n    float blur = abs(depth - focusDistance) / focalRange;\n    blur = clamp(blur, 0.0, 1.0);\n    return blur;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > iResolution.x/_PixelSize || \n       fragCoord.y > iResolution.y/_PixelSize)\n    {\n        return;\n    }\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    float focusDistance = 0.;\n    float focalRange = 30000.;\n    float blur = calculateBlur(iChannel0, uv, focusDistance, focalRange);\n    vec4 color;\n    color = gaussianBlur(iChannel0, uv, iResolution.xy, 0.05, blur);\n    color.rgb *= 255.;\n    color.rgb = dither(color.rgb, uv);\n    color.rgb /= 255.;\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float _PixelSize = 4.;\n\nconst int[] _Palette = int[](\n    0xd9ed92, 0xb5e48c, 0x99d98c, 0x76c893, 0x52b69a,\n    0x34a0a4, 0x168aad, 0x1a759f, 0x1e6091, 0x184e77,\n    0x03071e, 0x370617, 0x6a040f, 0x9d0208, 0xd00000, \n    0xdc2f02, 0xe85d04, 0xf48c06, 0xfaa307, 0xffba08, 0xffffff\n    );\n    \nvec3 hexToVec3(int hex)\n{\n    int r = (hex >> 16) & 0xff;\n    int g = (hex >>  8) & 0xff;\n    int b = (hex >>  0) & 0xff;\n    \n    return vec3(float(r), float(g), float(b));    \n}\n\nint vec3ToHex(vec3 col)\n{\n    int r = int(col.r);\n    int g = int(col.g);\n    int b = int(col.b);\n    \n    int newCol = r << 16 | g << 8 | b;\n    return newCol;\n}\n\nvec3 lerp(vec3 c1, vec3 c2, float mn, float mx, float t)\n{\n    float i = (t - mn) / (mx - mn);\n    vec3 newc = vec3(c1.r + (c2.r - c1.r) * i,\n                     c1.g + (c2.g - c1.g) * i,\n                     c1.b + (c2.b - c1.b) * i);\n    return newc;\n}\n\n\nint lerp(int c1, int c2, float mn, float mx, float t)\n{\n    vec3 C1 = hexToVec3(c1);\n    vec3 C2 = hexToVec3(c2);\n\n    float i = (t - mn) / (mx - mn);\n    vec3 newc = vec3(C1.r + (C2.r - C1.r) * i,\n                     C1.g + (C2.g - C1.g) * i,\n                     C1.b + (C2.b - C1.b) * i);\n    return vec3ToHex(newc);\n}\n\n\nvec3 xRotation(vec3 vector, float angle)\n{\n    mat3 rotation = mat3(1., 0., 0., \n                         0., cos(angle), -sin(angle), \n                         0., sin(angle), cos(angle));\n    return vector * rotation;\n}\n\nvec3 yRotation(vec3 vector, float angle)\n{\n    mat3 rotation = mat3(cos(angle), 0., sin(angle), \n                         0., 1., 0., \n                         -sin(angle), 0., cos(angle));\n    return vector * rotation;\n}\n\nvec3 zRotation(vec3 vector, float angle)\n{\n    mat3 rotation = mat3(cos(angle), -sin(angle), 0., \n                         sin(angle), cos(angle), 0., \n                         0., 0., 1.);\n    return vector * rotation;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 random(float seed, vec2 rangex, vec2 rangey, vec2 rangez)\n{\n    vec3 hash = hash31(seed)*1000000.;\n    float x = rangex.x + mod(hash.x, rangex.y - rangex.x); \n    float y = rangey.x + mod(hash.y, rangey.y - rangey.x);\n    float z = rangez.x + mod(hash.z, rangez.y - rangez.x);\n    return vec3(x, y, z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int A  = 65;\nconst int W    = 87;\nconst int D = 68;\nconst int S  = 83;\nconst int JUMP  = 32;\nconst int SHIFT  = 16;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float speed = 100.0;\nconst float movementSpeed = 200.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float outData = texelFetch(iChannel0, ivec2(fragCoord), 0).r;\n    vec2 angle = vec2(texelFetch(iChannel0, ivec2(3, 1), 0).r, texelFetch(iChannel0, ivec2(4, 1), 0).r);\n    switch(int(fragCoord.x)) {\n        case 0:\n            angle = angle * 3.1425 / 180.;\n        \toutData = texelFetch(iChannel0, ivec2(0, 0), 0).r +\n                ((iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(D, 0), 0).r -\n                (iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(A, 0), 0).r) * cos(angle.x) +\n                ((iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(W, 0), 0).r -\n        \t\t(iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(S, 0), 0).r) * -sin(angle.x);\n        \tbreak;\n        \n        case 1:\n            angle = angle * 3.1425 / 180.;\n        \toutData = texelFetch(iChannel0, ivec2(1, 0), 0).r +\n                ((iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(W, 0), 0).r -\n        \t\t(iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(S, 0), 0).r) * cos(angle.x)+\n                ((iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(D, 0), 0).r -\n                (iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(A, 0), 0).r) * sin(angle.x);\n        \tbreak;\n        case 2:\n        \toutData = texelFetch(iChannel0, ivec2(2, 0), 0).r +\n                (iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(JUMP, 0), 0).r -\n        \t\t(iTimeDelta * movementSpeed) * texelFetch(iChannel1, ivec2(SHIFT, 0), 0).r;            \n            break;\n        case 3:\n            if(int(fragCoord.y) == 0)\n            {\n                outData = outData +\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r -\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r;            \n            }\n            else if(int(fragCoord.y) == 1)\n            {\n                outData += (texelFetch(iChannel0, ivec2(3, 0), 0).r - outData) * 0.25f;\n            }\n            break;\n        case 4:\n            if(int(fragCoord.y) == 0)\n            {\n                outData = outData +\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;            \n            }\n            else if(int(fragCoord.y) == 1)\n            {\n                outData += (texelFetch(iChannel0, ivec2(4, 0), 0).r - outData) * 0.25f;\n            }           \n            break;\n            \n    }\n    \n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}