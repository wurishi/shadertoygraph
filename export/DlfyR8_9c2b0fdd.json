{"ver":"0.1","info":{"id":"DlfyR8","date":"1690369929","viewed":98,"name":"Breath fog effect for STALKER","username":"yohjimane","description":"changelog:\n- checkout ingame implementation here: https://www.youtube.com/watch?v=3PGl0sFWN64\n- add fbm\n- made fog whiter the relative to the center of the fog\n- add two pass gauss blur\n- shift the breath fog down, tint it white\n- added FBM func from @lv\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractionalbrownianmotion","gamedev"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define debug;\n//#define staticSize;\n\nfloat fbm(vec2 texcoord, int iterations) \n{\n    vec3 image_noise = texture(iChannel2, texcoord).xyz;\n    float value = image_noise.x;\n    float amplitude = 1.8;\n    float frequency = 1.65; //play with is\n    float total_weight = 2.5;\n\n    for (int i = 0; i < iterations; i++) \n    {\n        value += image_noise.x * amplitude;\n        texcoord *= frequency;\n        amplitude *= 1.25; //with this thing too\n        total_weight += amplitude;\n    }\n    return value / total_weight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //uniforms\n    vec4 screen_res = vec4(iResolution.xy, 1.0 / iResolution.xy);\n    \n    //texcoord\n    vec2 texcoord = fragCoord * screen_res.zw;\n        \n    //set up textures\n    vec4 image = texture(iChannel0, texcoord);\n    vec4 image_blur = texture(iChannel1, texcoord);\n\n    vec3 noise = texture(iChannel2, texcoord).xyz;\n    vec2 seed = noise.xy;\n    float faker2 = clamp(ceil(sin(iTime)), 0., 1.);\n    int breath_idx = int(faker2 * mod(iDate.w, 60.0) / 10.); // fake index, updates every 10 seconds to give 5 diff breath variations\n    seed = fract(seed + vec2(breath_idx) * 0.38196601125); // disable to stop generating new versions\n    \n    //ratio correction (remember that only circle tc should be corrected)\n    vec4 circle_tc_pos;\n    circle_tc_pos.xy = texcoord; //texcoord\n    circle_tc_pos.x -= 0.5;\n    circle_tc_pos.x *= screen_res.x * screen_res.w;\n    circle_tc_pos.x += 0.5;\n    circle_tc_pos.zw = vec2(0.5); //position (center of the screen)\n#if !defined(debug)\n    circle_tc_pos.y += 0.6; // push it down to bottom 1/3 of screen\n#endif\n    \n    //circle settings\n    float radius = sin(iTime) * .75;\n#if defined(staticSize)\n    radius = 0.75;\n#endif\n    float distFromCenter = distance(circle_tc_pos.xy, vec2(0.5, 0.5)); // get distance between cur pos and approx center of circle\n    float fbmFactor = fbm(texcoord * (0.1 * (1.0 / seed)), 15); // precompute seed reciprocal in engine?\n\n    //draw circle\n    radius *= fbmFactor; // apply wiggliness\n    clamp(radius, 0., 1.);\n    float circle = 1.0 - smoothstep(radius, radius + 8e-2, length(circle_tc_pos.xy - circle_tc_pos.zw));\n    vec4 circleTex = vec4(vec3(circle), 1.0); //cast to vec3\n    \n#if defined(debug)\n    image = vec4(1.);\n    image_blur = vec4(0.);\n#endif\n    \n    float centerRadius = clamp(radius - distFromCenter, 0.0, 1.0);\n    circle_tc_pos.xy += radius; // shift where we sample the texture randomly so each breath looks unique\n    vec4 glossyTex = mix(texture(iChannel2, circle_tc_pos.xy), vec4(1.0), 0.); // reuse noise texture as regular one, tint it white\n    \n    image_blur = mix(image_blur, glossyTex, centerRadius); // tint the center of our blurred area\n    image = mix(image, image_blur, circleTex); // add our blurred area to the main texture\n    \n    fragColor = image;\n    \n#if defined(debug)\n    vec3 vColour = vec3(0);\n    vec2 vFontSize = vec2(8.0, 15.0);\n    float fDigits;\n    float fDecimalPlaces;\n    \n    vColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue( (fragCoord - vec2(184.0, 5.0)) / vFontSize, float(breath_idx), 2.0, 0.0));\n    \n    // Print Shader Time\n\tvec2 vPixelCoord1 = vec2(96.0, 5.0);\n\tfloat fValue1 = float(faker2);\n\tfDigits = 6.0;\n\tfloat fIsDigit1 = PrintValue( (fragCoord - vPixelCoord1) / vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n    \n    if (fragColor.xyz == vec3(1.) && texcoord.y < 0.05) \n        fragColor.xyz = mix(fragColor.xyz, vColour, 0.5);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// two pass gaussian blur from: https://www.shadertoy.com/view/ltBXRh\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 res = vec3(0.0);\n    float Z = 0.0;\n    float sigma = 7.0;\n    \n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    for (int i=-kSize; i <= kSize; ++i) {\n        res += kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+ vec2(float(i),0.0) ) / iResolution.xy).rgb;\n    }\n    \n    fragColor = vec4(res / Z, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// debugging funcs from https://www.shadertoy.com/view/3lGBDm\nconst int mSize = 25;\nconst int kSize = (mSize-1)/2;\nconst float sigma = 7.0;\nfloat kernel[mSize];\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// two pass gaussian blur from: https://www.shadertoy.com/view/ltBXRh\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 res = vec3(0.0);\n    float Z = 0.0;\n    \n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    for (int i=-kSize; i <= kSize; ++i) {\n        res += kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+ vec2(0.0,float(i)) ) / iResolution.xy).rgb;\n    }\n    \n    \n    fragColor = vec4(res / Z, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// FBM noise func from https://www.shadertoy.com/view/7sVyRw\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash3(i + vec2(0.0,0.0)), \n                   hash3(i + vec2(1.0,0.0)), u.x),\n               mix(hash3(i + vec2(0.0,1.0)), \n                   hash3(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nvec3 fractal(vec2 p, int oct) {\n    float tier = 0.5;\n    mat2 m = mat2(1.6, 1.2, 1.2, -1.6);\n    p *= 4.0;\n    vec3 n = vec3(0);\n    for (int i = 0; i < oct; i++) {\n        n += noise(p) * tier; \n        p = m * p;\n        tier *= tier;\n    }\n    return sqrt(n);\n}\n\nvec3 fbm(vec2 p, int oct, int iter) {\n    for (int i = 0; i < iter; i++) {\n        p = (fractal(p, oct) + noise(p * 50.0) / 25.0).xy - p;\n    }\n    return fractal(p, oct);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x * 2.0;\n    fragColor = vec4(vec3(fbm(uv * 2.0, 6, 2)), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}