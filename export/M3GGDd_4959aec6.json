{"ver":"0.1","info":{"id":"M3GGDd","date":"1718400327","viewed":45,"name":"4D hypercube rotated in 6 planes","username":"DiggerDwarf","description":"I probably could've optimized it but this was thrown together quickly so yeah\nAlso if one of the rotation matrices is wrong like i was half asleep don't blame me\n\nSo this is the 3D slice of a 4D-hypercube that i rotate along all 6 orthogonal 4D planes","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["normals","4d","hypercube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define small 0.00001\n#define big 300000.0\n\n// TODO : offset rotation start and speed for better visuals\n// TODO : find a better way to correct the color of 4D normal vectors\n\nvec4 rotate_xz(vec4 v, float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return vec4(\n        v.x*c + v.z*s,\n        v.y,\n        -v.x*s + v.z*c,\n        v.w\n    );\n}\n\nvec4 rotate_xy(vec4 v, float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return vec4(\n        v.x*c - v.y*s,\n        v.x*s + v.y*c,\n        v.z,\n        v.w\n    );\n}\n\nvec4 rotate_yz(vec4 v, float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return vec4(\n        v.x,\n        v.y*c - v.z*s,\n        v.y*s + v.z*c,\n        v.w\n    );\n}\n\nvec4 rotate_xw(vec4 v, float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return vec4(\n        v.x*c - v.w*s,\n        v.y,\n        v.z,\n        v.x*s + v.w*c\n    );\n}\n\nvec4 rotate_yw(vec4 v, float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return vec4(\n        v.x,\n        v.y*c - v.w*s,\n        v.z,\n        v.y*s + v.w*c\n    );\n}\n\nvec4 rotate_zw(vec4 v, float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return vec4(\n        v.x,\n        v.y,\n        v.z*c - v.w*s,\n        v.z*s + v.w*c\n    );\n}\n\nfloat sdf_4D_cube(vec4 b, vec4 p) {\n    vec4 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0);\n}\n\nfloat map(vec4 p) {\n    return sdf_4D_cube(vec4(1),p);\n}\n\nvec4 get_normal(vec4 pos) {\n    vec2 Dir = vec2(small,0);\n    return normalize(vec4(\n        map(pos+Dir.xyyy)-map(pos-Dir.xyyy),\n\t\tmap(pos+Dir.yxyy)-map(pos-Dir.yxyy),\n\t\tmap(pos+Dir.yyxy)-map(pos-Dir.yyxy),\n        map(pos+Dir.yyyx)-map(pos-Dir.yyyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy *2.0 -1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 ray_origin = vec4(0, 0, -3, 0);\n    vec4 ray_direction = normalize(vec4(uv, 1, 0));\n    \n    ray_origin = rotate_xz(ray_origin,iTime/2.);\n    ray_direction = rotate_xz(ray_direction,iTime/2.);\n    \n    ray_origin = rotate_xy(ray_origin,iTime/2.);\n    ray_direction = rotate_xy(ray_direction,iTime/2.);\n    \n    ray_origin = rotate_yz(ray_origin,iTime/2.);\n    ray_direction = rotate_yz(ray_direction,iTime/2.);\n    \n    ray_origin = rotate_xw(ray_origin,iTime/2.);\n    ray_direction = rotate_xw(ray_direction,iTime/2.);\n    \n    ray_origin = rotate_yw(ray_origin,iTime/2.);\n    ray_direction = rotate_yw(ray_direction,iTime/2.);\n    \n    ray_origin = rotate_zw(ray_origin,iTime/2.);\n    ray_direction = rotate_zw(ray_direction,iTime/2.);\n    \n    float steps = 0.0;\n    float max_steps = 160.0;\n    \n    float dist_to_objects;\n    float dist_travelled = 0.0;\n    \n    for (steps = 0.0; steps < max_steps; steps++) {\n        dist_to_objects = map(ray_origin);\n        ray_origin += dist_to_objects*ray_direction;\n        dist_travelled += dist_to_objects;\n        \n        if (dist_to_objects < small || dist_travelled > big) break;\n    }\n    vec4 normal = (get_normal(ray_origin));\n    vec3 corrected_normal = vec3(normal.x+(normal.w/3.0),normal.y+(normal.w/3.0),normal.z+(normal.w/3.0));\n    fragColor = vec4(abs(corrected_normal), 1.0);\n}","name":"Image","description":"","type":"image"}]}