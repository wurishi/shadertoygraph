{"ver":"0.1","info":{"id":"M3jcW1","date":"1727232544","viewed":3,"name":"hec-canux-emma-zhihui","username":"zhihui","description":"trinity","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["trinity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#iChannel0 \"file://data/home.png\"\n//#iChannel1 \"file://data/end.png\"\n//#iChannel2 \"file://data/canon.mp3\"\n//#iChannel3 \"file://data/JudgmentDay.wav\"\n//#iChannel4 \"file://data/words.png\"\n\n// shared functions.\nvec3 drawMoon(vec3 ro, vec3 rd, vec3 position, float radius) {\n    vec3 oc = ro - position;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return vec3(0.0);\n    h = sqrt(h);\n    float t = -b - h;\n    vec3 p = ro + t * rd;\n    vec3 n = normalize(p - position);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    float diff = max(dot(n, lightDir), 0.0);\n\n    // 计算反射向量\n    vec3 reflectDir = reflect(-lightDir, n);\n    // 计算观察向量\n    vec3 viewDir = normalize(-p);\n    // 计算镜面反射强度\n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n\n    // 添加镜面反射\n    vec3 specular = vec3(1.0) * spec;\n\n    // 添加环境光\n    vec3 ambient = vec3(0.2);\n\n    // 计算最终颜色\n    vec3 color = vec3(1.0, 1.0, 0.0) * diff + specular + ambient;\n\n    return color;\n}\n\nvec2 avoidOverlap(vec2 pos1, vec2 pos2, float minDistance) {\n    vec2 direction = normalize(pos2 - pos1);\n    float distance = length(pos2 - pos1);\n    if (distance < minDistance) {\n        pos2 += direction * (minDistance - distance);\n    }\n    return pos2;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// bad moon\nvec3 badMoon(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, 2.0); // 观察者位置\n    vec3 rd = normalize(vec3(uv, -1.0)); // 光线方向\n\n    // 随机生成三个位置\n    float time = iTime;\n    float speed = 0.1;\n    vec2 pos1 = vec2(rand(vec2(1.0, 2.0)) * 1.6 - 0.8, rand(vec2(3.0, 4.0)) * 1.6 - 0.8);\n    vec2 pos2 = vec2(rand(vec2(5.0, 6.0)) * 1.6 - 0.8, rand(vec2(7.0, 8.0)) * 1.6 - 0.8);\n    vec2 pos3 = vec2(rand(vec2(9.0, 10.0)) * 1.6 - 0.8, rand(vec2(11.0, 12.0)) * 1.6 - 0.8);\n\n    // 计算月亮的移动轨迹\n    float radius = 0.8 * 1.5; // 修改月亮大小为现在的1.5倍\n    float angle1 = time * speed;\n    float angle2 = time * speed * 2.0;\n    float angle3 = time * speed * 3.0;\n    pos1 = vec2(cos(angle1), sin(angle1)) * radius;\n    pos2 = vec2(cos(angle2), sin(angle2)) * radius;\n    pos3 = vec2(cos(angle3), sin(angle3)) * radius;\n\n    // 确保月亮在屏幕内完整显示且不重叠\n    float moonRadius = 0.2 * 1.5; // 修改月亮大小为现在的1.5倍\n    float minDistance = 2.0 * moonRadius;\n    pos1 = clamp(pos1, vec2(-0.8), vec2(0.8));\n    pos2 = clamp(pos2, vec2(-0.8), vec2(0.8));\n    pos3 = clamp(pos3, vec2(-0.8), vec2(0.8));\n    pos2 = avoidOverlap(pos1, pos2, minDistance);\n    pos3 = avoidOverlap(pos1, pos3, minDistance);\n    pos3 = avoidOverlap(pos2, pos3, minDistance);\n\n\n    // 绘制三个月亮\n    vec3 color = drawMoon(ro, rd, vec3(pos1, 0.0), moonRadius);\n    color += drawMoon(ro, rd, vec3(pos2, 0.0), moonRadius);\n    color += drawMoon(ro, rd, vec3(pos3, 0.0), moonRadius);\n\n    return color;\n}\n\n// draw moon for good situation\nvec3 goodMoon(vec2 uv)  {\n    vec3 ro = vec3(0.0, 0.0, 2.0); // 观察者位置\n    vec3 rd = normalize(vec3(uv, -1.0)); // 光线方向\n\n    // 随机生成两个位置\n    float time = iTime;\n    float speed = 0.1;\n    vec2 pos1 = vec2(0.0, 0.0); // 月亮1始终在屏幕中间\n    vec2 pos2 = vec2(rand(vec2(5.0, 6.0)) * 1.6 - 0.8, rand(vec2(7.0, 8.0)) * 1.6 - 0.8);\n    vec2 pos3 = vec2(rand(vec2(9.0, 10.0)) * 1.6 - 0.8, rand(vec2(11.0, 12.0)) * 1.6 - 0.8);\n\n    // 计算月亮的移动轨迹\n    float radius = 0.8 * 1.5; // 修改月亮大小为1.5倍\n    float angle1 = time * speed;\n    float angle2 = time * speed * 2.0;\n    float angle3 = time * speed * 3.0;\n    pos2 = vec2(cos(angle2), sin(angle2)) * radius;\n    pos3 = vec2(cos(angle3), sin(angle3)) * radius;\n\n    // 确保月亮在屏幕内完整显示且不重叠\n    float moonRadius = 0.2 * 1.5; // 修改月亮大小为1.5倍\n    float minDistance = 2.0 * moonRadius;\n    pos2 = avoidOverlap(pos1, pos2, minDistance);\n    pos3 = avoidOverlap(pos1, pos3, minDistance);\n    pos3 = avoidOverlap(pos2, pos3, minDistance);\n\n    // 绘制背景\n    vec3 background = vec3(0.0, 0.0, 0.0); // 星空黑背景\n    vec3 color = background;\n\n    // 绘制三个月亮\n    color += drawMoon(ro, rd, vec3(pos1, 0.0), moonRadius);\n    color += vec3(0.9, 0.5, 0.5) * drawMoon(ro, rd, vec3(pos2, 0.0), moonRadius); // 月亮2的颜色为银灰色\n    color += vec3(0.9, 0.5, 0.5) * drawMoon(ro, rd, vec3(pos3, 0.0), moonRadius); // 月亮3的颜色为银灰色\n\n    return color;\n}\n\n// main function\n// 1. homepage\n// 2. click to moon\n// 存储左键点击状态的变量\nint clickFrame = -1;\nint displayState = 0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = mod(iTime, 20.0);\n\n    if (time < 7.0) {\n        if (iMouse.z > 0.0) {\n            displayState = 1; // display words\n        } else {\n            displayState = 0;\n        }\n    } else if (time >= 7.0 && time < 11.0) {\n        displayState = 2;\n    } else if (time >= 11.0 && time < 17.0) {\n        displayState = 3;\n    }  else if (time >= 17.0 && time < 20.0) {\n        displayState = 4;\n    }\n\n    // Determine the current and next images based on the display state\n    switch (displayState) {\n        case 0:\n            fragColor = texture(iChannel0, uv);\n            break;\n        case 1:\n            //fragColor = words(uv);\n            fragColor = texture(iChannel1, uv);\n            break;\n        case 2:\n            // good\n            vec2 uv2 = uv * 2.0 - 1.0;\n            uv2.x *= iResolution.x / iResolution.y;\n            float audioLeft = texture(iChannel2, vec2(uv.x, 0.25)).r;\n            float audioRight = texture(iChannel2, vec2(uv.x, 0.75)).g;\n            float audio2 = (audioLeft + audioRight) * 0.5;\n            fragColor = vec4(goodMoon(uv2), 1.0);\n            break;\n        case 3:\n            vec2 uv3 = uv * 2.0 - 1.0;\n            uv3.x *= iResolution.x / iResolution.y;\n            float audioLeft3 = texture(iChannel3, vec2(uv.x, 0.25)).r;\n            float audioRight3 = texture(iChannel3, vec2(uv.x, 0.75)).g;\n            float audio3 = (audioLeft3 + audioRight3) * 0.5;\n            fragColor = vec4(badMoon(uv3), 1.0);\n            break;\n        case 4:\n            fragColor = texture(iChannel1, uv);\n            break;\n        default:\n            fragColor = texture(iChannel0, uv);\n            break;\n    }\n}","name":"Image","description":"","type":"image"}]}