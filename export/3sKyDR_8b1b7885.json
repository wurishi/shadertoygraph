{"ver":"0.1","info":{"id":"3sKyDR","date":"1602706017","viewed":173,"name":"DoubleDodecaSpin","username":"snolot","description":"testing raymarching with double spining structure.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code & inspirtion borowed from lsdlive https://www.shadertoy.com/view/wd3GWM\n\n\n// Enable/disable decay animation\n//#define DECAY\n\n#define PI 3.14159\n#define TAU 6.28318\n#define BEAT (time*170.0/60.0)\n#define time iTime\n#define lofi(x,d) (floor((x)/(d))*(d))\nmat3 m;\nmat3 m2;\n\nfloat kExposure = 0.6;\n\nfloat pal_scale = 1.;\nfloat pal_offset = 0.;\n\n// if you disable DECAY animation, you can control the noise\nfloat noise_freq = 2.;\nfloat noise_amt = .3;\n\nfloat g;\n\n//#define pal(t,a,b,c,d) (a+(b)*cos(2.*PI*((c)*(t)+d)))\n#define kick(t,b) (floor(t) + fract(t) + sin(fract(t)*PI)*b)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 colormapIQ(float t){\n    //vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n   \t// nice blue\n    vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    \n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    \n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    //vec3 col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    return col;\n}\n\n// iq's noise\nfloat noise(in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3. - 2. * f);\n\tvec2 uv = (p.xy + vec2(37., 17.) * p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv + .5) / 256., 0.).yx;\n\treturn -1. + 2.4 * mix(rg.x, rg.y, f.z);\n}\n\n// Fbm\nfloat fbm(vec3 p) {\n\treturn noise(p * .06125) * .5 + noise(p * .125) * .25 + noise(p * .25) * .125;\n}\n\n// Dodecahedron folding\n// checkout: https://www.shadertoy.com/view/wtsGzl\nvec3 fold(vec3 p) {\n\tvec3 nc = vec3(-.5, -.809017, .309017);\n\tfor (int i = 0; i < 5; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2.*min(0., dot(p, nc))*nc;\n\t}\n\treturn p - vec3(0, 0, 1.275);\n}\n\nfloat sdf_shell(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat dist = dot(fp, normalize(sign(fp))) - .0 - sin(fp.y*.2)*2. - sin(fp.y*.5)*1.;\n    //g+=(0.1/(.01+dist*dist*999.) * sin(iTime  * .5));\n    \n\tdist += min(fp.x*1., sin(fp.y*.4)) + fbm(fp )* .03;\n\t//g+=(0.1/(.01+dist*dist*995.) * sin(iTime  * .5));\n\tfp = fold(fp) - vec3(.4, 2, -2.3);\n\tfp = fold(fp) - vec3(.8, 1, .1);\n\tfp = fold(fp) - vec3(0, .3, 0);\n\tdist += sin(fp.y*.1)*.1;\n    \n\tdist *= 1.;\n\t//g+=(0.1/(.01+dist*dist*9995.));// * sin(iTime  * .5));\n    \n\treturn dist / scale;\n}\n\nfloat sdf_core(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat dist = dot(fp, normalize(sign(fp))) - .4 - sin(fp.y*.8)*1.8 - sin(fp.y*.7)*1.;\n\tdist += min(fp.x*8., sin(fp.y*.1));\n\n\tfp = fold(fp) - vec3(-.45, 6.7, -.1);\n\tfp = fold(fp) - vec3(-.3, 8.7, -0.9);\n\tfp = fold(fp) - vec3(0, .02, 0);\n\tdist += sin(fp.y*.2)*8.;\n\tdist *= .4;\n\n\treturn dist / scale;\n}\n\n\n\nfloat de(vec3 p, vec3 p2) {\n\n    \t\n\tfloat s = 37.;\n\tp = mod(p - s * .5, s) - s * .5;\n\n\tfloat dist;\n\tdist = sdf_shell(p, .1 * (1. /*+ sin(u_time * .5)*/));\n\tdist = min(dist, sdf_core(p2, .6/* * ( 1.7 - sin(u_time * .5 ) ) */)) * .7;\n\n    #ifdef DECAY\n\treturn dist + fbm(p*30.) * (.6+.45*sin(4.+1.*kick(iTime*.1, .1)));\n    #else\n    return dist + fbm(p*noise_freq) * noise_amt;\n    #endif\n}\n\nvec3 camera(vec3 ro, vec3 ta, vec2 uv) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x * left + up * uv.y);\n}\n\n\n// mat3 from quaternion\nmat3 SetRot( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\n\n// mat3 from axis / angle\nmat3 SetRot( vec3 vAxis, float fAngle )\n{\t\n\treturn SetRot( vec4(normalize(vAxis) * sin(fAngle), cos(fAngle)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n    //vUV = glitch(vUV);\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\t\n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n\n\t//vec3 ray_ori = vec3(-11.*cos(u_time), sin(u_time)*7., -11. * sin(u_time)); // softer cam\n    \n    /*vec3 ray_ori = vec3(-10.*cos(kick(u_time*2., .1)), 16.*cos(kick(u_time*1., .1)), -10.*sin(kick(u_time, .1)));\n    vec3 target = vec3(0);\n\tvec3 ray_dir = camera(ray_ori, target, uv);\n\tvec3 pos = ray_ori;*/\n    \n    \n\tfloat fHeading = iTime * 0.21;\n\tfloat fElevation = cos(iTime * 0.1) * 0.5;\n\tfloat fCameraDistance = 20.0 + sin(iTime * .5) * 5.0;\n\t\n\tfloat fSinElevation = sin(fElevation);\n\tfloat fCosElevation = cos(fElevation);\n\tfloat fSinHeading = sin(fHeading);\n\tfloat fCosHeading = cos(fHeading);\n\t\n\tvec3 vCameraOffset;\n\tvCameraOffset.x = fSinHeading * fCosElevation;\n\tvCameraOffset.y = fSinElevation;\n\tvCameraOffset.z = fCosHeading * fCosElevation;\n\t\n\tvec3 vCameraPos = vCameraOffset * fCameraDistance;\n\tvec3 pos = vCameraPos;\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n\tfloat fFov = 2.0;\n\t\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fFov);\n\t\n\tvec3 vRotationAxis = vec3(1.0, 4.0, 2.0);\n\n\t// Rotate the rotation axis\n\tmat3 m2 = SetRot( vec3(0.1, 1.0, 0.01), iTime * 0.3 );\t\t\n\t\n\tvRotationAxis = vRotationAxis * m2;\n\t\n\tfloat fRotationAngle = sin(iTime * 0.5);\n\t\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tvec2 vMouseOffset = vMouse * 2.0 - 1.0;\n\t\tvRotationAxis = vec3(vMouseOffset.x, 1.0, vMouseOffset.y);\n\t\t//vRotationAxis = vec3(vMouseOffset.y, vMouseOffset.x, 1.0);\n\t\tfRotationAngle = length(vRotationAxis);\n\t}\n\t\n\tm = SetRot(vRotationAxis, fRotationAngle);\n\tm2 = SetRot(-sin(vRotationAxis), -fRotationAngle*2.);\n\n\t// local density/distance\n\tfloat ldensity = 0.;\n\n\t// accumulation color & density\n\tvec3 bg = vec3(.16, .12, .22);\n\tvec4 sum = vec4(bg, 0.);\n\n\tfloat tmax = 45.;\n\tfloat tdist = 0., dist = 0.;\n\n\tfor (float i = 0.; (i < 1.); i += 1. / 64.) {\n\n\t\tif (dist < tdist * .001 || tdist > tmax || sum.a > .95)\n\t\t\tbreak;\n\n\t\t// evaluate distance function\n\t\tvec3 vPos = (pos.xyz) * m;\n\t\tvec3 vPos2 = (pos.xyz) * m2;\n\t\t//dist = de(pos) * .5;\n\t\tdist = de(vPos, vPos2) * .5;\n\n\t\t// check whether we are close enough (step)\n\t\t// compute local density and weighting factor \n\t\tconst float h = .05;\n\t\tldensity = (h - dist) * step(dist, h);\n\n\t\tvec4 col;\n\t\tcol.rgb = colormapIQ(ldensity * 3.5 );/*(ldensity * pal_scale + pal_offset,\n\t\t\tvec3(.7, .4, .2 + sin(iTime*1.5)*.1),\n\t\t\tvec3(.9, .8, .4),\n\t\t\tvec3(.4, .5, .6),\n\t\t\tvec3(.8, .5, .3));*/\n        \n        col.rgb = clamp(col.rgb, 0., 1.);\n\t\tcol.a = ldensity;\n\n\t\t// pre-multiply alpha\n\t\t// checkout: https://www.shadertoy.com/view/XdfGz8\n\t\t// http://developer.download.nvidia.com/assets/gamedev/files/gdc12/GDC2012_Mastering_DirectX11_with_Unity.pdf\n\t\tcol.rgb *= col.a;\n        \n\t\tsum += (1. - sum.a) * col;\n\t\t//sum += g * .01;\n\t\t// from duke/las\n\t\tsum.a += .015;\n\n\t\t// enforce minimum stepsize\n\t\tdist = max(dist, .05 + sin(iTime)*.01);\n\n\t\t// step forward\n\t\tpos += dist * vDir; // sphere-tracing\n\t\ttdist += dist;\n\t}\n\n\t// from duke/las\n\t// simple scattering approximation\n\tsum *= 1. / exp(ldensity * .2) * 1.25;\n\t\n\tfragColor = vec4(sum.rgb, 1.);\n    fragColor.rgb *= smoothstep( 1.5, 0.4, length(fragCoord.xy-iResolution.xy*.5)/length(iResolution.xy*.5) );\n    vec3 grunge = texture( iChannel1, fragCoord/iChannelResolution[1].xy + vec2(.7549,.5698)*float(iFrame) ).rgb;\n    fragColor.rgb = mix( fragColor.rgb*mix( vec3(1), grunge, .2 ), grunge*vec3(.3,1,.6), .02 );\n    fragColor.rgb *= 1.+.4*sin(6.283185*fragCoord.y*.5*.618+iTime);\n    fragColor.rgb *= mix( 1., 1.8, smoothstep(.0,.3,cos(iTime/7.)) );    \n    fragColor.rgb = max(vec3(0),fragColor.rgb-.02);\n}\n","name":"Image","description":"","type":"image"}]}