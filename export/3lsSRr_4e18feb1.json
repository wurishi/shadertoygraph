{"ver":"0.1","info":{"id":"3lsSRr","date":"1562872023","viewed":875,"name":"PBR renderer","username":"agordeevw","description":"Implementing PBR tutorial from learnopengl.com.\n\nBRDF LUT, irradiance map and prefiltered environment maps for specular IBL are computed in the first several seconds.\nIf image looks severely wrong, press Space to rebuild LUTs.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Begin: Noise\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n// End: Noise\n\nfloat Noise(vec3 p)\n{\n\treturn snoise(p);\n}\n\nstruct Camera\n{\n\tfloat fov;\n    vec3 position;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n};\n\nCamera LookAt(float fov, vec3 position, vec3 target, vec3 up)\n{\n\tCamera ret;\n    ret.fov = fov;\n    ret.position = position;\n    ret.forward = normalize(target - position);\n    ret.right = normalize(cross(ret.forward, up));\n    ret.up = cross(ret.right, ret.forward);\n    return ret;\n}\n    \nstruct Ray\n{\n  vec3 o, d;\n};\n\nRay CameraRay(vec2 fragCoord, Camera camera)\n{\n  \tvec2 fragPos = fragCoord / iResolution.xy;\n    fragPos = 2.0 * (fragPos - 0.5);\n  \tfloat aspectRatio = iResolution.x / iResolution.y;\n  \tfloat halfHeight = tan(camera.fov * 0.5f);\n  \tvec3 target =\n        camera.right * fragPos.x * halfHeight * aspectRatio\n    \t+ camera.up * fragPos.y * halfHeight\n    \t+ camera.forward;\n\n \tRay ret;\n  \tret.o = camera.position;\n  \tret.d = normalize(target - ret.o);\n    return ret;\n}\n\nstruct Sphere\n{\n\tvec3 c;\n    float r;\n};\n\nfloat RaySphere(Ray ray, Sphere s)\n{\n    Ray origRay = ray;\n    float od = dot(ray.o - s.c, ray.d);\n    float oo = dot(ray.o - s.c, ray.o - s.c);\n    float dd = dot(ray.d, ray.d);\n\tfloat idd = 1.0 / dd;\n    float discr = od * od - (oo - s.r * s.r) * dd;\n    if (discr < 0.0)\n        return 0.0;\n\tdiscr = sqrt(discr);\n    float t1 = (-od - discr) * idd;\n    float t2 = (-od + discr) * idd;\n    ray = origRay;\n    return min(t1, t2);\n}\n\nvec3 SphereNormal(Sphere s, vec3 p)\n{\n\treturn normalize(p - s.c);\n}\n\nvec3 SamplePrefilteredEnvMap(float roughness, vec3 dir)\n{\n\tint level = int(floor(roughness * float(ROUGHNESS_LEVELS)));\n    level = level == ROUGHNESS_LEVELS ? ROUGHNESS_LEVELS - 1 : level;\n    int nextLevel = level == ROUGHNESS_LEVELS - 1 ? level : level + 1;\n\tvec2 uv = SampleEquirectangular(dir);\n    float levelWidth = 1.0 / float(ROUGHNESS_LEVELS);\n    vec2 levelUV = vec2((uv.x + float(level)) * levelWidth, uv.y);\n    vec2 nextLevelUV = vec2(levelUV.x + levelWidth, uv.y);\n    float mixFactor = fract(roughness * float(ROUGHNESS_LEVELS));\n    return mix(textureLod(iChannel2, levelUV, 0.0).rgb,\n              textureLod(iChannel2, nextLevelUV, 0.0).rgb,\n              mixFactor);\n}\n\nvec3 ApproximateSpecularIBL(float roughness, vec3 f0, vec3 n, vec3 v)\n{\n\tfloat NoV = max(0.0, dot(n, v));\n    vec3 r = 2.0 * dot(v, n) * n - v;\n    \n    vec3 F = F_Schlick(NoV, f0, roughness);\n    vec2 envBRDF = textureLod(iChannel0, vec2(NoV, roughness), 0.0).xy;\n    return SamplePrefilteredEnvMap(roughness, r) * (F * envBRDF.x + envBRDF.y);\n}\n\nconst vec3 f0 = vec3(0.04, 0.04, 0.04);\n\nconst float MIN_LEVEL = -1.0;\nconst float MAX_LEVEL = 3.0;\n\nfloat Level(Sphere s, vec3 p, vec3 offset)\n{\n   \tvec3 pc = normalize(p - s.c) + offset;\n    float baseNoise = Noise(2.0 * pc) + Noise(4.0 * pc + 4.0) + Noise(8.0 * pc + 8.0);\n    if (baseNoise > 0.2)\n    {\n    \tbaseNoise += mix(\n            0.0,\n            0.25 * clamp(Noise(80.0 * pc + 80.0) + 0.25, 0.0, 2.0),\n            clamp(baseNoise, 0.2, 2.0));\n    }\n    return clamp(baseNoise, MIN_LEVEL, MAX_LEVEL);\n}\n\nvec3 NormalMap(Sphere s, vec3 p, vec3 offset)\n{\n    float level = Level(s, p, offset);\n    if (level <= 0.0)\n    {\n        vec3 pc = p - s.c;\n        vec3 normal = normalize(pc);\n        return normal;\n\t}\n    \n    vec3 dx = vec3(0.001, 0.0, 0.0);\n    vec3 dy = vec3(0.0, 0.001, 0.0);\n    vec3 dz = vec3(0.0, 0.0, 0.001);\n    \n    float x = Level(s, p + dx, offset) - Level(s, p - dx, offset);\n    float y = Level(s, p + dy, offset) - Level(s, p - dy, offset);\n    float z = Level(s, p + dz, offset) - Level(s, p - dz, offset);\n    return -normalize(vec3(x, y, z));\n}\n\nfloat MetallicMap(Sphere s, vec3 p, vec3 offset)\n{\n    float level = Level(s, p, offset);\n    return mix(1.0, 0.0, clamp(16.0 * level, 0.0, 1.0));\n}\n\nfloat RoughnessMap(Sphere s, vec3 p, vec3 offset)\n{\n    float level = Level(s, p, offset);\n    if (level > 0.0)\n    {\n    \treturn mix(0.40, 0.85, clamp(16.0 * level, 0.0, 1.0));\n    }\n    else\n    {\n        float mixFactor = clamp(-MIN_LEVEL + level, 0.0, 1.0);\n    \treturn mix(0.0, 0.40, mixFactor);\n    }\n}\n\nstruct AlbedoData\n{\n\tvec3 atZero;\n    vec3 atLow;\n    vec3 atHigh;\n};\n\nvec3 Albedo(Sphere s, vec3 p, vec3 offset, AlbedoData data)\n{\n    float level = Level(s, p, offset);\n    \n    if (level > 0.0)\n    {\n    \treturn mix(data.atLow, data.atHigh, level *  (1.0 / MAX_LEVEL));\n    }\n    else\n    {\n        return data.atZero;\n    }\n}\n\n//#define SHOW_BRDF_LUT\n//#define SHOW_IRRADIANCE_MAP\n//#define SHOW_PREFILTERED_ENVIRONMENT_MAP\n//#define SHOW_NORMAL_MAP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_BRDF_LUT\n\tfragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).rgb, 1.0);\n    return;\n#endif\n\n#ifdef SHOW_IRRADIANCE_MAP\n\tfragColor = vec4(texture(iChannel1, fragCoord / iResolution.xy).rgb, 1.0);\n    return;\n#endif\n    \n#ifdef SHOW_PREFILTERED_ENVIRONMENT_MAP\n\tfragColor = vec4(texture(iChannel2, fragCoord / iResolution.xy).rgb, 1.0);\n    return;\n#endif\n    \n    vec2 angles;\n    if (iMouse.z > 0.0)\n    {\n        angles = iMouse.xy / iResolution.xy;\n        angles = 2.0 * (angles - 0.5);\n        angles.x *= 2.0 * PI;\n    }\n    else\n    {\n        angles.x = 0.5 * iTime;\n        angles.y = 0.1 * sin(iTime);\n    }\n    \n    float cx = cos(angles.x);\n    float cy = cos(angles.y);\n    float sx = sin(angles.x);\n    float sy = sin(angles.y);\n    \n    vec3 cameraPos;\n    cameraPos.x = cx * cy;\n    cameraPos.y = sy;\n    cameraPos.z = sx * cy;\n    cameraPos *= 3.0;\n    \n    Camera camera = LookAt(\n        120.0 / 180.0 * PI,\n        cameraPos,\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0));\n    Ray ray = CameraRay(fragCoord, camera);\n    \n    const int numLights = 3;\n    vec3 lightPositions[numLights] = vec3[](\n    \t3.0 * vec3(cos(2.0 * iTime), 0.0, sin(2.0 * iTime)),\n        3.0 * vec3(cos(1.0 * iTime), 0.2, sin(1.0 * iTime)),\n        3.0 * vec3(cos(0.5 * iTime), -0.2, sin(0.5 * iTime))\n    );\n    vec3 lightColors[numLights] = vec3[](\n    \tvec3(16.0, 4.0, 0.0),\n        vec3(2.0, 4.0, 1.0),\n        vec3(0.0, 2.0, 4.0)\n    );\n    \n    const float radius = 0.6;\n   \tconst int numSpheres = 4;\n    Sphere spheres[numSpheres];\n    spheres[0].c = vec3(1.0, 0.0, 0.0);\n    spheres[0].r = radius;\n    spheres[1].c = vec3(-1.0, 0.0, 0.0);\n    spheres[1].r = radius;\n    spheres[2].c = vec3(0.0, 1.0, 0.0);\n    spheres[2].r = radius;\n    spheres[3].c = vec3(0.0, -1.0, 0.0);\n    spheres[3].r = radius;\n    \n    vec3 perlinOffsets[numSpheres];\n    for (int i = 0; i < numSpheres; i++)\n    {\n    \tperlinOffsets[i] = spheres[i].c;\n    }\n    \n    AlbedoData albedos[numSpheres];\n    albedos[0].atZero = vec3(0.2, 0.3, 0.5);\n    albedos[0].atLow = vec3(0.6, 0.5, 0.0);\n    albedos[0].atHigh = vec3(0.9, 0.9, 0.9);\n    \n    albedos[1].atZero = vec3(0.5, 0.05, 0.6);\n    albedos[1].atLow = vec3(0.2, 0.5, 0.2);\n    albedos[1].atHigh = vec3(0.6, 0.8, 0.4);\n    \n    albedos[2].atZero = vec3(0.6, 0.3, 0.0);\n    albedos[2].atLow = vec3(0.1, 0.2, 0.4);\n    albedos[2].atHigh = vec3(0.9, 0.9, 0.9);\n    \n    albedos[3].atZero = vec3(0.8, 0.1, 0.05);\n    albedos[3].atLow = vec3(0.2, 0.2, 0.2);\n    albedos[3].atHigh = vec3(0.9, 0.9, 0.9);\n    \n    float minT = 1000.0;\n    int hitSphereId = int(-1);\n    for (int i = 0; i < numSpheres; i++)\n    {\n    \tfloat t = RaySphere(ray, spheres[i]);\n        if (t > 0.0 && t < minT)\n        {            \n            minT = t;\n            hitSphereId = i;\n        }\n    }\n    \n    vec3 color;\n    if (hitSphereId != int(-1))\n    {\n        vec3 offset = perlinOffsets[hitSphereId];\n        vec3 p = ray.o + minT * ray.d;\n        vec3 view = normalize(cameraPos - p);\n        vec3 normal = NormalMap(spheres[hitSphereId], p, offset);\n#ifdef SHOW_NORMAL_MAP\n        color = normal;\n#else\n        float NoV = max(dot(normal, view), 0.0);\n        \n        float metallic = MetallicMap(spheres[hitSphereId], p, offset);\n        float roughness = RoughnessMap(spheres[hitSphereId], p, offset);\n        vec3 albedo = Albedo(spheres[hitSphereId], p, offset, albedos[hitSphereId]);\n        \n        vec3 F = F_Schlick(NoV, f0, roughness);\n        vec3 kSpecular = F;\n        vec3 kDiffuse = (1.0 - metallic) * (1.0 - kSpecular);\n        vec3 lightL0 = vec3(0.0);\n        for (int i = 0; i < numLights; i++)\n        {\n            vec3 lightPos = lightPositions[i];\n            vec3 lightColor = lightColors[i];\n            \n            vec3 l = normalize(lightPos - p);\n            vec3 h = normalize(view + l);\n            float dist = length(lightPos - p);\n            float attenuation = 1.0 / (dist * dist);\n            vec3 radiance = lightColor * attenuation;\n            float NoL = max(dot(normal, l), 0.0);\n            \n            float NDF = D_GGX(max(dot(normal, h), 0.0), roughness);\n            float G = G_SmithDirect(roughness, NoL, NoV);\n            vec3 nominator = NDF * F * G;\n\t\t\tfloat denominator = 4.0 * NoV * NoL + 0.001;\n            vec3 specular = nominator / denominator;\n            \n            lightL0 += (kDiffuse * albedo * INV_PI + specular) * radiance * NoL;\n        }\n        \n        vec3 irradiance = textureLod(iChannel1, SampleEquirectangular(normal), 0.0).rgb;\n        vec3 ambient = kDiffuse * albedo * irradiance\n            + ApproximateSpecularIBL(roughness, mix(f0, albedo, metallic), normal, view);\n        color = ambient + lightL0;\n#endif\n    }\n    else\n    {\n    \tcolor = textureLod(iChannel3, ray.d, 0.0).xyz;\n    }\n    \n    float minLightT = 1000.0;\n    int hitLightId = int(-1);\n    for (int i = 0; i < numLights; i++)\n    {\n    \tfloat t = RaySphere(ray, Sphere(lightPositions[i], 0.1));\n        if (t > 0.0 && t < minLightT)\n        {\n        \tminLightT = t;\n            hitLightId = i;\n        }\n    }\n    \n    if (hitLightId != int(-1) && (hitSphereId == int(-1) || minT > minLightT))\n    {\n        vec3 p = ray.o + minLightT * ray.d;\n        vec3 r = p - lightPositions[hitLightId];\n        vec3 x = r - dot(r, ray.d) * ray.d;\n        float mixParam = length(x) / 0.1;\n        vec3 lightColor = normalize(lightColors[hitLightId]);\n        vec3 sampledColor = mix(lightColor, vec3(0.0), mixParam);\n        color += sampledColor;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 IntegrateBRDF(float roughness, float NoV)\n{\n\tvec3 v;\n    v.x = sqrt(1.0 - NoV * NoV);\n    v.y = 0.0;\n    v.z = NoV;\n    \n    float A = 0.0;\n    float B = 0.0;\n    \n    vec3 n = vec3(0.0, 0.0, 1.0);\n    \n    const uint numSamples = 1024u;\n    for (uint i = 0u; i < numSamples; i++)\n    {\n    \tvec2 Xi = Hammersley(i, numSamples);\n        vec3 h = ImportanceSampleGGX(Xi, roughness, n);\n        vec3 l = 2.0 * dot(v, h) * h - v;\n        \n        float NoL = clamp(l.z, 0.0, 1.0);\n        float NoH = clamp(h.z, 0.0, 1.0);\n        float VoH = clamp(dot(v, h), 0.0, 1.0);\n        \n        if (NoL > 0.0)\n        {\n            float G = G_SmithIBL(roughness, NoL, NoV);\n            float G_Vis = G * VoH / (NoH * NoV);\n            float Fc = pow(1.0 - VoH, 5.0);\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    \n    return vec2(A, B) / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 0 && !KeyPressed(KEY_SPACE))\n    {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \treturn;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    float NoV = uv.x;\n    float roughness = uv.y;\n    fragColor = vec4(IntegrateBRDF(roughness, NoV).xy, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define INV_SQRT_PI 0.56418958354\n\nvec2 SampleEquirectangular(vec3 dir)\n{\n    vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));\n    uv *= vec2(0.1591, 0.3183);\n    uv += 0.5;\n    return uv;\n}\n\nvec3 F_Schlick(float NoV, vec3 F0, float roughness)\n{\n\treturn F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - NoV, 5.0);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\nfloat G_SmithIBL(float roughness, float NoL, float NoV)\n{\n\tfloat k = roughness * roughness * 0.5;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nfloat G_SmithDirect(float roughness, float NoL, float NoV)\n{\n\tfloat k = (roughness + 1.0) * (roughness + 1.0) * 0.125;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness, vec3 n)\n{\n\tfloat a = roughness * roughness;\n    float phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    vec3 h;\n    h.x = sinTheta * cos(phi);\n    h.y = sinTheta * sin(phi);\n    h.z = cosTheta;\n    \n    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = normalize(cross(up, n));\n    vec3 tangentY = cross(n, tangentX);\n    return tangentX * h.x + tangentY * h.y + n * h.z;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    uint bits = i;\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    float inv = float(bits) * 2.3283064365386963e-10;\n\treturn vec2(float(i)/float(N), inv);\n}\n\n#define ROUGHNESS_LEVELS 5\n\n#define KeyPressed(ascii) (texelFetch(iChannel3, ivec2(ascii, 0), 0).x != 0.0)\nconst int KEY_SPACE = 32;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 IrradianceMap(vec3 normal)\n{\n    vec3 up = abs(normal.y) < 0.9999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n    //vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, normal);\n    up = cross(normal, right);\n    \n    uint numSamples = 0u;\n    vec3 irradiance = vec3(0.0, 0.0, 0.0);\n    const float stepD = 0.025;\n\tfor (float phi = 0.0; phi < 2.0 * PI; phi += stepD)\n    {\n    \tfor (float theta = 0.0; theta <= 0.5 * PI; theta += stepD)\n        {\n        \tvec3 tangentSpaceDir = vec3(\n                cos(theta) * sin(phi),\n                cos(theta) * cos(phi),\n                sin(theta)\n            );\n            vec3 inDir = tangentSpaceDir.x * right\n                + tangentSpaceDir.y * up\n                + tangentSpaceDir.z * normal;\n            \n            irradiance += texture(iChannel1, inDir).rgb * cos(theta) * sin(theta);\n            numSamples++;\n        }\n    }\n    \n    return PI * irradiance / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 0 && !KeyPressed(KEY_SPACE))\n    {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \treturn;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 angles = uv * vec2(2.0 * PI, PI) + vec2(0.0, -PI * 0.5);\n    vec3 dir = vec3(\n    \tcos(angles.y) * cos(angles.x),\n        sin(angles.y),\n        cos(angles.y) * sin(angles.x)\n    );\n\n    vec3 col = IrradianceMap(dir);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 PrefilterEnvMap(float roughness, vec3 r)\n{\n\tvec3 n = r;\n    vec3 v = r;\n    \n    vec3 prefilteredColor = vec3(0.0, 0.0, 0.0);\n    float totalWeight = 0.0;\n    \n    const uint numSamples = 1024u;\n    for (uint i = 0u; i < numSamples; i++)\n    {\n    \tvec2 Xi = Hammersley(i, numSamples);\n        vec3 h = ImportanceSampleGGX(Xi, roughness, n);\n        vec3 l = 2.0 * dot(v, h) * h - v;\n        \n        float NoL = max(dot(n, l), 0.0);\n        if (NoL > 0.0)\n        {\n        \tprefilteredColor += textureLod(iChannel1, l, 0.0).rgb * NoL;\n            totalWeight += NoL;\n        }\n    }\n    \n    return prefilteredColor / totalWeight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 0 && !KeyPressed(KEY_SPACE))\n    {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \treturn;\n    }\n    \n    int level = int(floor((fragCoord.x / iResolution.x) * float(ROUGHNESS_LEVELS)));\n    float roughness = float(level) / float(ROUGHNESS_LEVELS - 1);\n    float levelWidth = 1.0 / float(ROUGHNESS_LEVELS);\n    \n    // Bounds for level n:\n    // [n * levelWidth, (n+1) * levelWidth)\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= float(ROUGHNESS_LEVELS);\n    vec2 angles = fract(uv) * vec2(2.0 * PI, PI) + vec2(0.0, -PI * 0.5);\n    vec3 dir = vec3(\n        cos(angles.y) * cos(angles.x),\n        sin(angles.y),\n        cos(angles.y) * sin(angles.x)\n    );\n    \n    fragColor = vec4(PrefilterEnvMap(roughness, dir), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}