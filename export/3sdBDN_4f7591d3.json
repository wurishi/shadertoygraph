{"ver":"0.1","info":{"id":"3sdBDN","date":"1605129860","viewed":106,"name":"Sound--Hey jude--V2","username":"jorge2017a1","description":"Hey jude--V2","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["heyjudev2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// by nothings\n// Derived fromn by Lou's Pseudo 3d page\n// http://www.gorenfeld.net/lou/pseudo/\n// and from space harrier glsl sandbox demo\n\n\n\n// hash from iq's live coded apple\nfloat hash(float n)\n{\n\treturn fract(sin(n)*43758.54);\n}\n\nfloat roadpoint(float n)\n{\n\tif (hash(n+0.5) > 0.75)\n\t\treturn 0.0;\n\tfloat z = (hash(n)-0.5)*2.2;\n\treturn sign(z) * pow(abs(z),2.0);\n}\n\n// cubic interpolator\nfloat noise(float x)\n{\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\tfloat p0 = roadpoint(p);\n\tfloat p1 = roadpoint(p+1.0);\n\tfloat p2 = roadpoint(p+2.0);\n\tfloat p3 = roadpoint(p+3.0);\n\tfloat a = (-p0*0.5 + 1.5*p1 - 1.5*p2 + p3*0.5);\n\tfloat b = p0 - 2.5*p1 + 2.0*p2 - 0.5*p3;\n\tfloat c = 0.5*p2 - 0.5*p0;\n\tfloat d = p1;\n\treturn d + f*(c + f*(b + f*a));\n}\t\n\nfloat road_offset(float pos)\n{\n\treturn noise(pos/80.0)*10.0\n\t\t+ noise(pos/500.0)*80.0; // add some \"long-range\" curves\n}\n\nfloat road_slope(float pos)\n{\t\n\treturn (road_offset(pos+4.0) - road_offset(pos-4.0))/8.0;\t\n}\n\n\nvec2 pix(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 position = fragCoord.xy / iResolution.yy;\n\t//position = pix(position, 0.01);  //por @z0rg \n    \n    \n\tfloat y = position.y-0.62;\n\tif (position.y > 0.6) {\n\t\tfragColor = vec4(0.2, 0.6, 1.0, 1.0);\n\t\t// enable this \"return\" statement not to draw the ceiling\n\t\treturn;\n\t} \n\ty = -y;\n\n\t// y ranges from 0.02 to 0.62\n\tfloat z = 1.0 / y; // yscreen = y/z, so z = y / yscreen\n\t// z ranges from ~1.5 to 50\n\tfloat speed = 4.5;\n\tfloat dist = pow(z,0.75); // fudge this so the distance doesn't get too aliasy\n\tfloat spacing = 7.0;\n\tfloat bottom_trackpos = iTime*speed*spacing + 1.4*spacing;\n\tfloat trackpos = (dist+iTime*speed)*spacing;\n\tfloat xcenter = -iResolution.x/iResolution.y*0.5;\n\n\t// using average_slope instead of base_slope smooths the camera movement\n\tfloat averaged_slope = (road_slope(bottom_trackpos) + road_slope(bottom_trackpos - speed)) / 2.0;\n\tfloat base_slope = road_slope(bottom_trackpos);\n\tfloat slope = averaged_slope*0.75; // at 1.0 we're always looking strictly forward\n\tfloat slope_offset = (0.62-y) * slope * 8.0; // dunno why 8.0\n\n\tfloat x = (position.x + xcenter - slope_offset) * z; // xscreen = x/z, so x = xscreen * z\n\n\t// compute the road \"view vector\" based on the bottom of the screen\n\tfloat road_point = road_offset(bottom_trackpos);\n\troad_point = road_point - slope*3.5; // move inside the curves\n\troad_point = road_point  + sin(iTime*1.0)*0.05;// + 1.5*(mouse.x-0.5);\n\n\tx -= road_point;\n\t\n\t// compute the course path at the current point\n\tx += road_offset(trackpos);\n\n\tfloat xa = abs(x);\n\tfloat phase = sin(trackpos);\n\tfloat state = phase > 0.0 ? 0.0 : 1.0;\n\tfloat darken = state == 0.0 ? 1.0 : 0.5;\n\tif (xa > 1.6)\n\t\tfragColor = vec4(0,1,0,1) * mix(1.0,darken * phase,y); // messing around here <<---\n\telse if (xa > 1.4) {\n\t\tfragColor = (state==0.0 ? vec4(1,0,0,1) : vec4(1,1,1,1));\n\t}\n\telse if (state==0.0 && abs(xa-0.45) < 0.05)\n\t\tfragColor = vec4(1,1,1,1);\n\telse\n\t\tfragColor = vec4(0.5,0.5,0.5,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Beatles-hey jude version n2 por Jorge flores\n\n//---por jorgeflores ----jorge2017a1\n\n//referencia\n//https://www.shadertoy.com/view/wsScWV ......Creado por NonGrate en 2020-04-19\n\n///Referencia  la grande comunidad de usuarios de  Shadertoy... :)\n//Reference the large community of Shadertoy users ... :)\n\n#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n\n// Durations\nconst float pulg=1.5;\n    \n\nconst float WHOLE_NOTE = 1.0*pulg;\nconst float HALF_NOTE = 1.0/2.0*pulg;\nconst float _2_NOTE = 1.0/2.0*pulg;\nconst float _4_NOTE = 1.0/4.0*pulg;\nconst float _8_NOTE = 1.0/8.0*pulg;\nconst float _16_NOTE = 1.0/16.0*pulg;\nconst float _32_NOTE = 1.0/32.0*pulg;\nconst float DOUBLE_NOTE = 2.0*pulg;\n\nconst float OCT00 = 0.0/8.0*pulg;\nconst float OCT01 = 1.0/8.0*pulg;\nconst float OCT02 = 2.0/8.0*pulg;\nconst float OCT03 = 3.0/8.0*pulg;\nconst float OCT04 = 4.0/8.0*pulg; //1/2\nconst float OCT05 = 5.0/8.0*pulg;\nconst float OCT06 = 6.0/8.0*pulg;\nconst float OCT07 = 7.0/8.0*pulg;\nconst float OCT08 = 8.0/8.0*pulg;\nconst float OCT09 = 9.0/8.0*pulg;\nconst float OCT0908 = 9.0/8.0*pulg;\n\nconst float SEG_1 = 1.0*pulg;\nconst float SEG_2 = 2.0*pulg;\nconst float SEG_1D2 =1.0/ 2.0*pulg;\nconst float SEG_1D8 =1.0/ 8.0*pulg;\nconst float SEG_1D16 =1.0/ 16.0*pulg;\nconst float SEG_3D16 =3.0/ 16.0*pulg;\nconst float SEG_3D4 =3.0/ 4.0*pulg;\nconst float SEG_1D4 =1.0/ 4.0*pulg;\n\n\n\n\nstruct TNote {\n    // in Hz, see \"common\" tab\n    float note;\n    float octave;\n    float offset; // offset - time in seconds when to start playing note\n    float duration;  // duration of a note (1/4, 1/8, ...), see \"common\" tab\n};\n\n    \n\nfloat n2f(float n)\n{\n    return 440.0*pow(2.0,(n-69.0)/12.0);\n}\n\n\nfloat n2m(float n)\n{\n    return pow(2.0,n/12.0);\n}\n\n\n\nfloat noise( float x ){return fract(sin(1371.1*x)*43758.5453);}\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n///-----------------------------------\n\nconst float t2 =6.5;\n\nconst TNote[] notes = TNote[] \n    (\n    //9/8*0.0\n    TNote(C, 4.0,OCT0908*0.0+ OCT07, _8_NOTE), \n    ///------------\n    //9/8*1.0\n    TNote(F, 2.0,OCT0908*1.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*1.0+ OCT01, SEG_1), \n    TNote(C, 2.0,OCT0908*1.0+ OCT01, SEG_1),\n        \n    TNote(A, 3.0,OCT0908*1.0+ OCT01, _2_NOTE),\n        \n    TNote(A, 3.0,OCT0908*1.0+ SEG_1D2+OCT01, _8_NOTE),\n        \n    TNote(C, 4.0,OCT0908*1.0+ SEG_1D2+OCT01*2.0, SEG_3D16),\n    TNote(D, 4.0,OCT0908*1.0+ SEG_1D2+OCT01*2.0+SEG_3D16, _8_NOTE),\n     //------------\n    //9/8*2.0   \n    TNote(E, 2.0,OCT0908*2.0+ OCT01, SEG_1), \n    TNote(G, 2.0,OCT0908*2.0+ OCT01, SEG_1),\n    TNote(C, 3.0,OCT0908*2.0+ OCT01, SEG_1), \n    \n    TNote(G, 3.0,OCT0908*2.0+ OCT01, SEG_3D4),\n        \n    TNote(G, 3.0,OCT0908*2.0+ OCT01*7.0, SEG_1D8),\n    TNote(A, 3.0,OCT0908*2.0+ OCT01*8.0, SEG_1D8),\n    \n    //------------\n    //9/8*3.0 \n       \n    //TNote(E, 2.0,OCT0908*3.0+ OCT01, SEG_1), \n    //TNote(G, 2.0,OCT0908*3.0+ OCT01, SEG_1),\n    //TNote(C, 3.0,OCT0908*3.0+ OCT01, SEG_1), \n       \n    TNote(AS, 3.0,OCT0908*3.0+ OCT01, SEG_1D4), \n        \n    TNote(F, 4.0,OCT0908*3.0+ OCT01+SEG_1D4, SEG_1D4), \n    \n    TNote(F, 4.0,OCT0908*3.0+ OCT01+SEG_1D4*2.0+SEG_1D8, SEG_3D16), \n    TNote(E, 4.0,OCT0908*3.0+ OCT01+SEG_1D4*2.0+SEG_1D8+SEG_3D16, SEG_1D8), \n    TNote(C, 4.0,OCT0908*3.0+ OCT01+SEG_1D4*2.0+SEG_1D8+SEG_3D16+SEG_1D8, SEG_1D8),\n     ///---------------------   \n    //9/8*4.0 \n    \n    TNote(F, 2.0,OCT0908*4.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*4.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*4.0+ OCT01, SEG_1),\n        \n    TNote(D, 4.0,OCT0908*4.0+ OCT01, SEG_1D8),\n    TNote(C, 4.0,OCT0908*4.0+ OCT01+SEG_1D8, SEG_1D16),\n    TNote(AS, 3.0,OCT0908*4.0+ OCT01+SEG_1D8+SEG_1D16, SEG_1D16),\n        \n    TNote(A, 3.0,OCT0908*4.0+ OCT01+SEG_1D8+SEG_1D16*2.0, SEG_1D2),\n        \n    TNote(C, 3.0,OCT0908*4.0+ OCT09-SEG_3D16, SEG_3D16),\n      ///---------------------   \n    //9/8*5.0    \n        \n    TNote(F, 2.0,OCT0908*5.0+ OCT01, SEG_1), \n    TNote(AS,2.0,OCT0908*5.0+ OCT01,SEG_1), \n    TNote(D, 3.0,OCT0908*5.0+ OCT01, SEG_1), \n        \n    TNote(D, 4.0,OCT0908*5.0+ OCT01, SEG_1D8), \n    TNote(D, 4.0,OCT0908*5.0+ OCT01+SEG_1D16, SEG_3D16), \n    \n    TNote(D, 4.0,OCT0908*5.0+ OCT01*4.0, SEG_3D16), \n    TNote(G, 4.0,OCT0908*5.0+ OCT01*5.0, SEG_1D8), \n    TNote(F, 4.0,OCT0908*5.0+ OCT01*6.0, SEG_3D16), \n    TNote(E, 4.0,OCT0908*5.0+ OCT01*7.0, SEG_3D16), \n    TNote(F, 4.0,OCT0908*5.0+ OCT01*7.5, SEG_1D16), \n    TNote(D, 4.0,OCT0908*5.0+ OCT01*8.0, SEG_3D16),\n        \n    //9/8*6.0\n    TNote(F, 2.0,OCT0908*6.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*6.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*6.0+ OCT01, SEG_1),\n    \n    TNote(C, 4.0,OCT0908*6.0+ OCT01*1.0, SEG_1D4),\n    TNote(F, 3.0,OCT0908*6.0+ OCT01*5.0, SEG_3D16),\n    TNote(G, 3.0,OCT0908*6.0+ OCT01*6.0+SEG_1D16, SEG_3D16),\n    TNote(A, 3.0,OCT0908*6.0+ OCT01*7.0+SEG_1D16, SEG_3D16),    \n    TNote(D, 4.0,OCT0908*6.0+ OCT01*8.0+SEG_1D16, SEG_3D16),\n   \n    //9/8*7.0\n    TNote(E, 2.0,OCT0908*7.0+ OCT01, SEG_1), \n    TNote(G, 2.0,OCT0908*7.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*7.0+ OCT01, SEG_1),\n        \n    TNote(C, 4.0,OCT0908*7.0+ OCT01, SEG_1D4),\n    \n    TNote(C, 4.0, OCT0908*7.0+ OCT01*4.0, SEG_3D16),\n    TNote(AS, 3.0,OCT0908*7.0+ OCT01*5.0, SEG_3D16),\n    TNote(A, 3.0, OCT0908*7.0+ OCT01*6.0, SEG_1D4),\n        \n    TNote(E, 3.0,OCT0908*7.0+ OCT01*9.0, SEG_3D16),\n        \n    //9/8*8.0\n    TNote(F, 2.0,OCT0908*8.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*8.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*8.0+ OCT01, SEG_1),\n        \n    TNote(F, 3.0,OCT0908*8.0+ OCT01, SEG_1D2)\n        \n        \n     \n);\n\n\nvec2 noteFreq(TNote note, float time) {\n    \n    // 6.2831 = 2pi\n    // exp() goes exponentially down to fade out the volume\n    //return vec2(sin(6.2831 * note.frequency * time) * exp(-1.0/note.duration * (time - note.offset)));\n    float n1=saw(time,note.note, note.octave)* exp(-1.0/note.duration * (time - note.offset));  ///ORIGINAL\n    return vec2(n1);\n}\n\n\nvec2 mainSound( in int samp,float time) \n{\n    \n    \n    \n    vec2 result;\n    \n    // time counts in seconds\n    // (time - x) is required, because we want to \"reset\" exp() function\n    // otherwise the output of exp() function will go down globally\n    // and we'll hear only first note\n\n    float ftime= mod(time, 16.5);\n    for (int i = 0; i < notes.length(); i++) {\n        TNote note = notes[i];\n        float x = float(i) * 1.0;\n        if (ftime > note.offset) \n        {\n            result += noteFreq(note, ftime);\n            \n        }\n    }\n\n\n    \n    return result*0.35;\n    //return result;\n}","name":"Sound","description":"","type":"sound"}]}