{"ver":"0.1","info":{"id":"lscfRM","date":"1524499923","viewed":312,"name":"Teleporter","username":"watusimoto","description":"Bitfighter teleporter (http://bitfighter.org)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2dbitfighter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159\n#define tau (2.0 * pi)\n\n// Gold Noise Â©2017-2018 dcerisano@standard3d.com\n// - based on the Golden Ratio, PI and the Square Root of Two\n// - fastest noise generator function\n// - works with all chipsets (including low precision)\n\nprecision lowp    float;\n\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(sin(dot(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\n\n\nvec3 getColor(vec2 fragCoord, float time, vec3 color, float theta, float rad, float len, float life, float dist, float ang) {\n       \n    float beamWidth = 2.0;\n    float timeLived = mod(time, life);\n\n    rad -= timeLived * rad / life;\t\t\t// Reduce radius as we spiral towards center\n\n\n    float angdiff = theta - ang;\t\t\t// Angle between pixel and head of tracker\n    if(angdiff < 0.0) \n        angdiff += tau;\n\n    float alpha = 0.0;\n    if(dist > (rad - beamWidth * (1.0 - angdiff)) && dist < rad + beamWidth + angdiff)\n        alpha = (1.0 - angdiff / len) * smoothstep(0.1, 1.0, timeLived/life + .4);\n    \n  \treturn vec3(color * alpha);\n}\n\n\nvec3 getBaseColor(int index) {\n    \n    if(index == 1)\n     \treturn vec3( 0.0, 0.25, 0.8 );\n    if(index == 2)\n     \treturn vec3( 0.0, 0.5,  1.0 );\n    if(index == 3)\n     \treturn vec3( 0.0, 0.0,  1.0 );\n    if(index == 4)\n     \treturn vec3( 0.0, 1.0,  1.0 );\n    if(index == 5)\n     \treturn vec3( 0.0, 0.5,  0.5 );\n    if(index == 6)\n     \treturn vec3( 0.0, 0.0,  1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float rad =  80.0;\n    \n    \n    const int trackers = 100;\n    #define baseColorCount 6\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 cen = iResolution.xy / 2.0;\n    float dist = distance(fragCoord, cen);\n\n       \n    vec3 color = vec3(0.0);\t// Start with black; we'll add up colors as we go\n    \n    if(dist < rad) {\n    \tfloat ang = -atan(fragCoord.y - cen.y, fragCoord.x - cen.x);\n\n        for(int i = 0; i < trackers; i++) {\n\n            float fi = float(i);\n\n            float life = 5.0 + 4.0 * gold_noise(vec2(fi),fi);\n            float len = 0.25 + 1.75 * gold_noise(vec2(fi)*3.0, fi); // in radians\n            float theta = mod(iTime * (0.5 +  2.0 * gold_noise(vec2(fi)*2.0,fi)), tau) - pi;\n\n            int colorIndex = int(mod(fi,float(baseColorCount)));\n\n            vec3 baseColor = getBaseColor(colorIndex);\n\n            vec3 col = getColor(fragCoord, iTime, baseColor, theta, rad, len, life, dist, ang);\n\n            color += col;\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}