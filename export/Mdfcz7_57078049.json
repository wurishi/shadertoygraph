{"ver":"0.1","info":{"id":"Mdfcz7","date":"1487462316","viewed":2571,"name":"ACES Color Grading via LUT","username":"Mynx","description":"Color grading in ACES color space via an unrolled 16^3 lookup table. Applies color grading and the ACES render/display transforms. Input is converted to ACESproxy to provide the LUT with a valid input range.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["colorgradingacesfilmfilmiccorrectionlutlookuptablematrixchartcolorchart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  Description: Transform input image to linear space and apply the 3D LUT for grading.\n//               Input for the LUT is in ACESproxy space (12bit version).\n//               Works for post-exposure HDR renders, i.e. games with HDR rendering.\n\n#define LUT_SIZE 22.0\n#define LUT_WIDTH (LUT_SIZE * LUT_SIZE)\n#define PI 3.1415926535897932384626433832795\n\n\n////////////////////////////////////////////////////////////////////////////\n//\n// # License Terms for Academy Color Encoding System Components #\n// \n// Academy Color Encoding System (ACES) software and tools are provided by the\n// Academy under the following terms and conditions: A worldwide, royalty-free,\n// non-exclusive right to copy, modify, create derivatives, and use, in source and\n// binary forms, is hereby granted, subject to acceptance of this license.\n// \n// Copyright Â© 2013 Academy of Motion Picture Arts and Sciences (A.M.P.A.S.).\n// Portions contributed by others as indicated. All rights reserved.\n// \n// Performance of any of the aforementioned acts indicates acceptance to be bound\n// by the following terms and conditions:\n// \n// * Copies of source code, in whole or in part, must retain the above copyright\n// notice, this list of conditions and the Disclaimer of Warranty.\n// \n// * Use in binary form must retain the above copyright notice, this list of\n// conditions and the Disclaimer of Warranty in the documentation and/or other\n// materials provided with the distribution.\n// \n// * Nothing in this license shall be deemed to grant any rights to trademarks,\n// copyrights, patents, trade secrets or any other intellectual property of\n// A.M.P.A.S. or any contributors, except as expressly stated herein.\n// \n// * Neither the name \"A.M.P.A.S.\" nor the name of any other contributors to this\n// software may be used to endorse or promote products derivative of or based on\n// this software without express prior written permission of A.M.P.A.S. or the\n// contributors, as appropriate.\n// \n// This license shall be construed pursuant to the laws of the State of\n// California, and any disputes related thereto shall be subject to the\n// jurisdiction of the courts therein.\n// \n// Disclaimer of Warranty: THIS SOFTWARE IS PROVIDED BY A.M.P.A.S. AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND\n// NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL A.M.P.A.S., OR ANY\n// CONTRIBUTORS OR DISTRIBUTORS, BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, RESITUTIONARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// \n// WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, THE ACADEMY SPECIFICALLY\n// DISCLAIMS ANY REPRESENTATIONS OR WARRANTIES WHATSOEVER RELATED TO PATENT OR\n// OTHER INTELLECTUAL PROPERTY RIGHTS IN THE ACADEMY COLOR ENCODING SYSTEM, OR\n// APPLICATIONS THEREOF, HELD BY PARTIES OTHER THAN A.M.P.A.S.,WHETHER DISCLOSED OR\n// UNDISCLOSED.\n//\n// -------------------------------------------------------------------------\n////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.Transform_Common.a1.0.0\n\nconst mat3 AP0_2_XYZ_MAT = mat3\n(\n\t0.9525523959, 0.0000000000, 0.0000936786,\n\t0.3439664498, 0.7281660966,-0.0721325464,\n\t0.0000000000, 0.0000000000, 1.0088251844\n);\n\nconst mat3 AP1_2_XYZ_MAT = mat3\n(\n\t 0.6624541811, 0.1340042065, 0.1561876870,\n\t 0.2722287168, 0.6740817658, 0.0536895174,\n\t-0.0055746495, 0.0040607335, 1.0103391003\n);\n\nconst mat3 XYZ_2_AP0_MAT = mat3\n(\n\t 1.0498110175, 0.0000000000,-0.0000974845,\n\t-0.4959030231, 1.3733130458, 0.0982400361,\n    0.0000000000, 0.0000000000, 0.9912520182\n);\n\nconst mat3 XYZ_2_AP1_MAT = mat3\n(\n\t 1.6410233797,-0.3248032942,-0.2364246952,\n\t-0.6636628587, 1.6153315917, 0.0167563477,\n\t 0.0117218943,-0.0082844420, 0.9883948585\n);\n\nconst mat3 AP0_2_AP1_MAT = ( XYZ_2_AP1_MAT * AP0_2_XYZ_MAT );\nconst mat3 AP1_2_AP0_MAT = ( XYZ_2_AP0_MAT * AP1_2_XYZ_MAT );\nconst vec3 AP1_RGB2Y = vec3(AP1_2_XYZ_MAT[0][1], AP1_2_XYZ_MAT[1][1], AP1_2_XYZ_MAT[2][1]);\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.Utilities_Color.a1.0.0\n\n// Transformations between CIE XYZ tristimulus values and CIE x,y \n// chromaticity coordinates\nvec3 XYZ_2_xyY( vec3 XYZ)\n{  \n\tvec3 xyY;\n\tfloat divisor = (XYZ[0] + XYZ[1] + XYZ[2]);\n\tif (divisor == 0.0)\n\t\tdivisor = 1e-10;\n\n\txyY[0] = XYZ[0] / divisor;\n\txyY[1] = XYZ[1] / divisor;  \n\txyY[2] = XYZ[1];\n  \n\treturn xyY;\n}\n\nvec3 xyY_2_XYZ( vec3 xyY)\n{\n\tvec3 XYZ;\n\tXYZ[0] = xyY[0] * xyY[2] / max( xyY[1], 1e-10);\n\tXYZ[1] = xyY[2];  \n\tXYZ[2] = (1.0 - xyY[0] - xyY[1]) * xyY[2] / max(xyY[1], 1e-10);\n\n\treturn XYZ;\n}\n\nconst mat3 CONE_RESP_MAT_BRADFORD = mat3\n(\n\t 0.89510, 0.26640,-0.16140,\n\t-0.75020, 1.71350, 0.03670,\n\t 0.03890,-0.06850, 1.02960\n);\n\nconst mat3 INV_CONE_RESP_MAT_BRADFORD = mat3\n(\n\t 0.9869929055,-0.1470542564, 0.1599626517,\n\t 0.4323052697, 0.5183602715, 0.0492912282,\n\t-0.0085286646, 0.0400428217, 0.9674766958\n);\n\nmat3 calculate_cat_matrix\n  (vec2 src_xy,        // x,y chromaticity of source white\n   vec2 des_xy         // x,y chromaticity of destination white\n  )\n{\n\t// Calculates and returns a 3x3 Von Kries chromatic adaptation transform \n\t// from src_xy to des_xy using the cone response primaries defined \n\t// by coneRespMat.\n\n\tvec3 src_XYZ = xyY_2_XYZ( vec3( src_xy, 1 ) );\n\tvec3 des_XYZ = xyY_2_XYZ( vec3( des_xy, 1 ) );\n\n\tvec3 src_coneResp = (src_XYZ * CONE_RESP_MAT_BRADFORD);\n\tvec3 des_coneResp = (des_XYZ * CONE_RESP_MAT_BRADFORD);\n\n\tmat3 vkMat = mat3\n\t(\n\t\tdes_coneResp[0] / src_coneResp[0], 0.0, 0.0,\n\t\t0.0, des_coneResp[1] / src_coneResp[1], 0.0,\n\t\t0.0, 0.0, des_coneResp[2] / src_coneResp[2]\n\t);\n\n\tmat3 cat_matrix = ( ( CONE_RESP_MAT_BRADFORD * vkMat ) * INV_CONE_RESP_MAT_BRADFORD );\n\n\treturn cat_matrix;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.ODT_Common.a1.0.0\n\nconst vec2 AP0_WhitePoint = vec2(0.32168, 0.33767);\nconst vec2 REC709_WhitePoint = vec2(0.31270, 0.32900);\n\n////////////////////////////////////////////////////////////////////////////\n// ODT.Academy.RGBmonitor_D60sim_100nits_dim.a1.0.0\n\nconst mat3 XYZ_2_DISPLAY_PRI_MAT = mat3\n(\n\t 3.2409699419,-1.5373831776,-0.4986107603,\n\t-0.9692436363, 1.8759675015, 0.0415550574,\n\t 0.0556300797,-0.2039769589, 1.0569715142\n);\n\nconst mat3 DISPLAY_PRI_2_XYZ_MAT = mat3\n(\n\t0.4123907993, 0.3575843394, 0.1804807884,\n\t0.2126390059, 0.7151686788, 0.0721923154,\n    0.0193308187, 0.1191947798, 0.9505321523\n);\n\n// ACEScsc.ACES_to_ACESproxy12i.a1.0.3\n    \nconst float StepsPerStop = 200.0;\nconst float MidCVoffset  = 1700.0;\nconst float CVmin        = 256.0;\nconst float CVmax        = 3760.0;\n\nvec3 ACES_2_ACESproxy(vec3 x)\n{\n    x = clamp( x, 0.0, 65535.0);\n    x = x * AP0_2_AP1_MAT;\n    x.r = (x.r <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.r) + 2.5) * StepsPerStop + MidCVoffset)));\n\tx.g = (x.g <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.g) + 2.5) * StepsPerStop + MidCVoffset)));    \n    x.b = (x.b <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.b) + 2.5) * StepsPerStop + MidCVoffset)));\n\treturn x / 4095.0;\n}\n\nvec3 ACESproxy_2_ACES(vec3 x)\n{\n    x = x * 4095.0;\n    x = pow(vec3(2.0), (x - MidCVoffset) / StepsPerStop - 2.5);\n\treturn x * AP1_2_AP0_MAT;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nvec3 log10(vec3 n)\n{\n\tconst float logBase10 = 1.0 / log2(10.0);\n\treturn log2( n ) * logBase10;\n}\n\nvec3 linear_2_cineon_log(in vec3 color)\n{\n\treturn ((log10(color.xyz * (1.0 - 0.0108) + 0.0108) * 300.0) + 685.0) / 1023.0;\n}\n\nvec3 rgb_2_ap0( vec3 color )\n{\n    mat3 D65_2_D60_CAT = calculate_cat_matrix( REC709_WhitePoint, AP0_WhitePoint );\n    mat3 sRGB_2_AP0 = ((DISPLAY_PRI_2_XYZ_MAT * D65_2_D60_CAT) * XYZ_2_AP0_MAT);\n\treturn (color * sRGB_2_AP0);\n}\n\nvec3 apply_chart(vec3 image)\n{\n\tconst vec3 scale = vec3(LUT_SIZE - 1.0, LUT_SIZE - 1.0, LUT_SIZE - 1.0) / LUT_SIZE;\n\tconst vec3 bias = vec3(0.5, 0.5, 0.0) / LUT_SIZE;\n    \n\tvec3 lookup = clamp(image, 0.0, 1.0) * scale + bias;\n \n\tfloat slice = lookup.z * LUT_SIZE;\t\n\tfloat sliceFrac = fract(slice);\t\n\tfloat sliceIdx = slice - sliceFrac;\n\t\n\tlookup.x = (lookup.x + sliceIdx) / LUT_SIZE;\n    lookup.xy /= iResolution.xy;\n    lookup.xy *= vec2(LUT_WIDTH, LUT_SIZE);\n    \n \tvec3 col0 = texture(iChannel1, lookup.xy).xyz;\n    \n    // slice interpolation\n \tlookup.x += 1.0 / LUT_SIZE * LUT_WIDTH / iResolution.x;\n \tvec3 col1 = texture(iChannel1, lookup.xy).xyz;\n    \n\treturn col0 + (col1 - col0) * sliceFrac;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 image = texture(iChannel0, uv);\n    image.xyz = pow(image.xyz, vec3(2.2));\n    \n    if (fragCoord.x < iMouse.x)\n    {        \n        // move to proxy space\n        image.xyz = ACES_2_ACESproxy(rgb_2_ap0(image.xyz));\n\n        // apply the chart\n        image.xyz = apply_chart(image.xyz);\n    }\n    else\n    {\n        image.xyz = pow(image.xyz, vec3(1.0 / 2.2));   \n    }\n   \n    vec3 lookupTable = (texture(iChannel1, uv).xyz);\n    if(fragCoord.x < LUT_WIDTH && fragCoord.y < LUT_SIZE)\n    \timage.xyz = lookupTable.xyz;\n    \n    fragColor = vec4(image.xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  Description: Generate a 3D color-grading LUT using the Academy Color Encoding System (ACES).\n//               Original sources for ACES can be found here: https://github.com/ampas/aces-dev/\n\n#define LUT_SIZE 22.0\n#define LUT_WIDTH (LUT_SIZE * LUT_SIZE)\n#define PI 3.1415926535897932384626433832795\n\n// general adjustment\n#define HUESHIFT            0.0\n#define SATURATION          1.0\n#define CONTRAST            1.0\n#define CONTRAST_PIVOT      0.5\n\n// levels adjustment\n#define LEVELS_MIN          vec3(0.0,0.0,0.0)\n#define LEVELS_MAX          vec3(1.0,1.0,1.0)\n#define LEVELS_GAMMA        vec3(1.0,1.0,1.0)\n\n// primary adjustment\n#define LIFT                vec3(1.0,1.0,1.0)\n#define GAIN                vec3(1.0,1.0,1.0)\n#define GAMMA               vec3(1.0,1.0,1.0)\n\n// log adjustment\n#define SHADOW_RANGE        0.333\n#define HIGHLIGHT_RANGE     0.667\n#define SHADOW_COLOR        vec3(1.0,1.0,1.0)\n#define MIDTONE_COLOR       vec3(1.0,1.0,1.0)\n#define HIGHLIGHT_COLOR     vec3(1.0,1.0,1.0)\n\n////////////////////////////////////////////////////////////////////////////\n\nfloat log10(float n)\n{\n\tconst float logBase10 = 1.0 / log2(10.0);\n\treturn log2( n ) * logBase10;\n}\n\n////////////////////////////////////////////////////////////////////////////\n//\n// # License Terms for Academy Color Encoding System Components #\n// \n// Academy Color Encoding System (ACES) software and tools are provided by the\n// Academy under the following terms and conditions: A worldwide, royalty-free,\n// non-exclusive right to copy, modify, create derivatives, and use, in source and\n// binary forms, is hereby granted, subject to acceptance of this license.\n// \n// Copyright Â© 2013 Academy of Motion Picture Arts and Sciences (A.M.P.A.S.).\n// Portions contributed by others as indicated. All rights reserved.\n// \n// Performance of any of the aforementioned acts indicates acceptance to be bound\n// by the following terms and conditions:\n// \n// * Copies of source code, in whole or in part, must retain the above copyright\n// notice, this list of conditions and the Disclaimer of Warranty.\n// \n// * Use in binary form must retain the above copyright notice, this list of\n// conditions and the Disclaimer of Warranty in the documentation and/or other\n// materials provided with the distribution.\n// \n// * Nothing in this license shall be deemed to grant any rights to trademarks,\n// copyrights, patents, trade secrets or any other intellectual property of\n// A.M.P.A.S. or any contributors, except as expressly stated herein.\n// \n// * Neither the name \"A.M.P.A.S.\" nor the name of any other contributors to this\n// software may be used to endorse or promote products derivative of or based on\n// this software without express prior written permission of A.M.P.A.S. or the\n// contributors, as appropriate.\n// \n// This license shall be construed pursuant to the laws of the State of\n// California, and any disputes related thereto shall be subject to the\n// jurisdiction of the courts therein.\n// \n// Disclaimer of Warranty: THIS SOFTWARE IS PROVIDED BY A.M.P.A.S. AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND\n// NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL A.M.P.A.S., OR ANY\n// CONTRIBUTORS OR DISTRIBUTORS, BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, RESITUTIONARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// \n// WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, THE ACADEMY SPECIFICALLY\n// DISCLAIMS ANY REPRESENTATIONS OR WARRANTIES WHATSOEVER RELATED TO PATENT OR\n// OTHER INTELLECTUAL PROPERTY RIGHTS IN THE ACADEMY COLOR ENCODING SYSTEM, OR\n// APPLICATIONS THEREOF, HELD BY PARTIES OTHER THAN A.M.P.A.S.,WHETHER DISCLOSED OR\n// UNDISCLOSED.\n//\n// -------------------------------------------------------------------------\n////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.Transform_Common.a1.0.0\n\nconst mat3 AP0_2_XYZ_MAT = mat3\n(\n\t0.9525523959, 0.0000000000, 0.0000936786,\n\t0.3439664498, 0.7281660966,-0.0721325464,\n\t0.0000000000, 0.0000000000, 1.0088251844\n);\n\nconst mat3 AP1_2_XYZ_MAT = mat3\n(\n\t 0.6624541811, 0.1340042065, 0.1561876870,\n\t 0.2722287168, 0.6740817658, 0.0536895174,\n\t-0.0055746495, 0.0040607335, 1.0103391003\n);\n\nconst mat3 XYZ_2_AP0_MAT = mat3\n(\n\t 1.0498110175, 0.0000000000,-0.0000974845,\n\t-0.4959030231, 1.3733130458, 0.0982400361,\n    0.0000000000, 0.0000000000, 0.9912520182\n);\n\nconst mat3 XYZ_2_AP1_MAT = mat3\n(\n\t 1.6410233797,-0.3248032942,-0.2364246952,\n\t-0.6636628587, 1.6153315917, 0.0167563477,\n\t 0.0117218943,-0.0082844420, 0.9883948585\n);\n\nconst mat3 AP0_2_AP1_MAT = ( XYZ_2_AP1_MAT * AP0_2_XYZ_MAT );\nconst mat3 AP1_2_AP0_MAT = ( XYZ_2_AP0_MAT * AP1_2_XYZ_MAT );\nconst vec3 AP1_RGB2Y = vec3(AP1_2_XYZ_MAT[0][1], AP1_2_XYZ_MAT[1][1], AP1_2_XYZ_MAT[2][1]);\n\nfloat rgb_2_saturation(vec3 rgb)\n{\n\tconst float TINY = 1e-10;\n\n\tfloat min_f3 = min( min( rgb.r, rgb.g ), rgb.b );\n\tfloat max_f3 = max( max( rgb.r, rgb.g ), rgb.b );\n\treturn ( max( max_f3, TINY ) - max( min_f3, TINY ) ) / max( max_f3, 1e-2 );\n}\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.Utilities_Color.a1.0.0\n\n// Transformations between CIE XYZ tristimulus values and CIE x,y \n// chromaticity coordinates\nvec3 XYZ_2_xyY( vec3 XYZ)\n{  \n\tvec3 xyY;\n\tfloat divisor = (XYZ[0] + XYZ[1] + XYZ[2]);\n\tif (divisor == 0.0)\n\t\tdivisor = 1e-10;\n\n\txyY[0] = XYZ[0] / divisor;\n\txyY[1] = XYZ[1] / divisor;  \n\txyY[2] = XYZ[1];\n  \n\treturn xyY;\n}\n\nvec3 xyY_2_XYZ( vec3 xyY)\n{\n\tvec3 XYZ;\n\tXYZ[0] = xyY[0] * xyY[2] / max( xyY[1], 1e-10);\n\tXYZ[1] = xyY[2];  \n\tXYZ[2] = (1.0 - xyY[0] - xyY[1]) * xyY[2] / max(xyY[1], 1e-10);\n\n\treturn XYZ;\n}\n\n\n// Transformations from RGB to other color representations\nfloat rgb_2_hue( vec3 rgb ) \n{\n\t// Returns a geometric hue angle in degrees (0-360) based on RGB values.\n\t// For neutral colors, hue is undefined and the function will return a quiet NaN value.\n\tfloat hue = 0.0;\n\n\t// RGB triplets where RGB are equal have an undefined hue\n\tif (rgb[0] == rgb[1] && rgb[1] == rgb[2])\n\t\thue = 0.0; \n\telse\n\t\thue = (180.0 / PI) * atan( sqrt(3.0) * (rgb[1] - rgb[2]), 2.0 * rgb[0] - rgb[1] - rgb[2]);\n    \n\tif (hue < 0.0)\n\t\thue = hue + 360.0;\n\n\treturn hue;\n}\n\nfloat rgb_2_yc( vec3 rgb, float ycRadiusWeight )\n{\n\t// Converts RGB to a luminance proxy, here called YC\n\t// YC is ~ Y + K * Chroma\n\t// Constant YC is a cone-shaped surface in RGB space, with the tip on the \n\t// neutral axis, towards white.\n\t// YC is normalized: RGB 1 1 1 maps to YC = 1\n\t//\n\t// ycRadiusWeight defaults to 1.75, although can be overridden in function \n\t// call to rgb_2_yc\n\t// ycRadiusWeight = 1 -> YC for pure cyan, magenta, yellow == YC for neutral \n\t// of same value\n\t// ycRadiusWeight = 2 -> YC for pure red, green, blue  == YC for  neutral of \n\t// same value.\n\n\tfloat r = rgb.r;\n\tfloat g = rgb.g;\n\tfloat b = rgb.b;\n  \n\tfloat chroma = sqrt(b * (b - g) + g * (g - r) + r * (r - b));\n\n\treturn ( b + g + r + ycRadiusWeight * chroma) / 3.0;\n}\n\nconst mat3 CONE_RESP_MAT_BRADFORD = mat3\n(\n\t 0.89510, 0.26640,-0.16140,\n\t-0.75020, 1.71350, 0.03670,\n\t 0.03890,-0.06850, 1.02960\n);\n\nconst mat3 INV_CONE_RESP_MAT_BRADFORD = mat3\n(\n\t 0.9869929055,-0.1470542564, 0.1599626517,\n\t 0.4323052697, 0.5183602715, 0.0492912282,\n\t-0.0085286646, 0.0400428217, 0.9674766958\n);\n\nmat3 calculate_cat_matrix\n  (vec2 src_xy,        // x,y chromaticity of source white\n   vec2 des_xy         // x,y chromaticity of destination white\n  )\n{\n\t// Calculates and returns a 3x3 Von Kries chromatic adaptation transform \n\t// from src_xy to des_xy using the cone response primaries defined \n\t// by coneRespMat.\n\n\tvec3 src_XYZ = xyY_2_XYZ( vec3( src_xy, 1 ) );\n\tvec3 des_XYZ = xyY_2_XYZ( vec3( des_xy, 1 ) );\n\n\tvec3 src_coneResp = (src_XYZ * CONE_RESP_MAT_BRADFORD);\n\tvec3 des_coneResp = (des_XYZ * CONE_RESP_MAT_BRADFORD);\n\n\tmat3 vkMat = mat3\n\t(\n\t\tdes_coneResp[0] / src_coneResp[0], 0.0, 0.0,\n\t\t0.0, des_coneResp[1] / src_coneResp[1], 0.0,\n\t\t0.0, 0.0, des_coneResp[2] / src_coneResp[2]\n\t);\n\n\tmat3 cat_matrix = ( ( CONE_RESP_MAT_BRADFORD * vkMat ) * INV_CONE_RESP_MAT_BRADFORD );\n\n\treturn cat_matrix;\n}\n\n// Signal encode/decode functions\nfloat moncurve_r( float y, float gamma, float offs )\n{\n\t// Reverse monitor curve\n\tfloat x;\n\tfloat yb = pow( offs * gamma / ( (gamma - 1.0) * (1.0 + offs)), gamma);\n\tfloat rs = pow( (gamma - 1.0) / offs, gamma - 1.0) * pow(( 1.0 + offs) / gamma, gamma);\n\tif ( y >= yb )\n\t\tx = ( 1.0 + offs) * pow( y, 1.0 / gamma) - offs;\n\telse\n\t\tx = y * rs;\n\treturn x;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.Tonescales.a1.0.0\n\n// Textbook monomial to basis-function conversion matrix.\nconst mat3 M = mat3\n(\n\t 0.5,-1.0, 0.5,\n\t-1.0, 1.0, 0.5,\n\t 0.5, 0.0, 0.0\n);\n\nstruct SegmentedSplineParams_c5\n{\n\tfloat coefsLow[6];\t\t// coefs for B-spline between minPoint and midPoint (units of log luminance)\n\tfloat coefsHigh[6];\t\t// coefs for B-spline between midPoint and maxPoint (units of log luminance)\n\tvec2 minPoint;\t\t// {luminance, luminance} linear extension below this\n\tvec2 midPoint;\t\t// {luminance, luminance} \n\tvec2 maxPoint;\t\t// {luminance, luminance} linear extension above this\n\tfloat slopeLow;\t\t\t// log-log slope of low linear extension\n\tfloat slopeHigh;\t\t// log-log slope of high linear extension\n};\n\nstruct SegmentedSplineParams_c9\n{\n\tfloat coefsLow[10];\t// coefs for B-spline between minPoint and midPoint (units of log luminance)\n\tfloat coefsHigh[10];\t// coefs for B-spline between midPoint and maxPoint (units of log luminance)\n\tvec2 minPoint;\t\t// {luminance, luminance} linear extension below this\n\tvec2 midPoint;\t\t// {luminance, luminance} \n\tvec2 maxPoint;\t\t// {luminance, luminance} linear extension above this\n\tfloat slopeLow;\t\t\t// log-log slope of low linear extension\n\tfloat slopeHigh;\t\t// log-log slope of high linear extension\n};\n\nfloat segmented_spline_c5_fwd( float x )\n{\n\t// RRT_PARAMS\n\tSegmentedSplineParams_c5 C;\n    C.coefsLow[0] = -4.0; C.coefsLow[1] = -4.0; C.coefsLow[2] = -3.1573765773;\n    C.coefsLow[3] = -0.4852499958; C.coefsLow[4] = 1.8477324706; C.coefsLow[5] = 1.8477324706;\n   \tC.coefsHigh[0] = -0.7185482425; C.coefsHigh[1] = 2.0810307172; C.coefsHigh[2] = 3.6681241237;\n    C.coefsHigh[3] = 4.0; C.coefsHigh[4] = 4.0; C.coefsHigh[5] = 4.0;\n\tC.minPoint = vec2(0.18 * exp2(-15.0), 0.0001);\n\tC.midPoint = vec2(0.18,                4.8);\n\tC.maxPoint = vec2(0.18 * exp2(18.0), 10000.0);\n\tC.slopeLow = 0.0;\n    C.slopeHigh = 0.0;\n\n\tconst int N_KNOTS_LOW = 4;\n\tconst int N_KNOTS_HIGH = 4;\n\n\t// Check for negatives or zero before taking the log. If negative or zero,\n\t// set to ACESMIN.\n\tfloat xCheck = x <= 0.0 ? exp2(-14.0) : x;\n\n\tfloat logx = log10(xCheck);\n\n\tfloat logy;\n\n\tif ( logx <= log10(C.minPoint.x) )\n\t{\n\t\tlogy = logx * C.slopeLow + ( log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );\n\t}\n\telse if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) ))\n\t{\n\t\tfloat knot_coord = float(N_KNOTS_LOW-1) * (logx-log10(C.minPoint.x))/(log10(C.midPoint.x)-log10(C.minPoint.x));\n\t\tint j = int(knot_coord);\n\t\tfloat t = knot_coord - float(j);\n\n        // can't index on non-const value...\n\t\t//vec3 cf = vec3(C.coefsLow[j], C.coefsLow[j + 1], C.coefsLow[j + 2]);\n        vec3 cf = vec3(C.coefsLow[0], C.coefsLow[1], C.coefsLow[2]);\n        if (j == 1)\n            cf = vec3(C.coefsLow[1], C.coefsLow[2], C.coefsLow[3]);\n        else if (j == 2)\n            cf = vec3(C.coefsLow[2], C.coefsLow[3], C.coefsLow[4]);\n         else if (j == 3)\n            cf = vec3(C.coefsLow[3], C.coefsLow[4], C.coefsLow[5]);       \n    \n\t\tvec3 monomials = vec3(t * t, t, 1.0);\n\t\tlogy = dot( monomials, (M * cf) );\n\t}\n\telse if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) ))\n\t{\n\t\tfloat knot_coord = float(N_KNOTS_HIGH-1) * (logx-log10(C.midPoint.x))/(log10(C.maxPoint.x)-log10(C.midPoint.x));\n\t\tint j = int(knot_coord);\n\t\tfloat t = knot_coord - float(j);\n\n        // can't index on non-const value...\n\t\t//vec3 cf = vec3(C.coefsHigh[j], C.coefsHigh[j + 1], C.coefsHigh[j + 2]); \n \t\tvec3 cf = vec3(C.coefsHigh[0], C.coefsHigh[1], C.coefsHigh[2]);\n        if (j == 1)\n            cf = vec3(C.coefsHigh[1], C.coefsHigh[2], C.coefsHigh[3]);\n        else if (j == 2)\n            cf = vec3(C.coefsHigh[2], C.coefsHigh[3], C.coefsHigh[4]);\n         else if (j == 3)\n            cf = vec3(C.coefsHigh[3], C.coefsHigh[4], C.coefsHigh[5]); \n             \n\t\tvec3 monomials = vec3(t * t, t, 1.0);\n\t\tlogy = dot( monomials, (M * cf) );\n\t}\n\telse //if ( logIn >= log10(C.maxPoint.x) )\n\t{\n\t\tlogy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );\n\t}\n\n\treturn pow(10.0, logy);\n}\n\nfloat segmented_spline_c9_fwd( float x )\n{\n\t// ODT_48nits\n\tSegmentedSplineParams_c9 C;\n    C.coefsLow[0] = -1.6989700043; C.coefsLow[1] = -1.6989700043; C.coefsLow[2] = -1.4779000000;\n    C.coefsLow[3] = -1.2291000000; C.coefsLow[4] = -0.8648000000; C.coefsLow[5] = -0.4480000000;\n    C.coefsLow[6] = 0.0051800000; C.coefsLow[7] = 0.4511080334; C.coefsLow[8] = 0.9113744414;\n    C.coefsLow[9] = 0.9113744414;\n    \n    C.coefsHigh[0] = 0.5154386965; C.coefsHigh[1] = 0.8470437783; C.coefsHigh[2] = 1.1358000000;\n    C.coefsHigh[3] = 1.3802000000; C.coefsHigh[4] = 1.5197000000; C.coefsHigh[5] = 1.5985000000;\n    C.coefsHigh[6] = 1.6467000000; C.coefsHigh[7] = 1.6746091357; C.coefsHigh[8] = 1.6878733390;\n    C.coefsHigh[9] = 1.6878733390;\n    \n    C.minPoint = vec2(segmented_spline_c5_fwd( 0.18*exp2(-6.5) ),  0.02);\n\tC.midPoint = vec2(segmented_spline_c5_fwd( 0.18 ),             4.8);\n\tC.maxPoint = vec2(segmented_spline_c5_fwd( 0.18*exp2(6.5) ),   48.0);\n\tC.slopeLow = 0.0;\n\tC.slopeHigh = 0.04;\n\n\n\tconst int N_KNOTS_LOW = 8;\n\tconst int N_KNOTS_HIGH = 8;\n\n\t// Check for negatives or zero before taking the log. If negative or zero,\n\t// set to OCESMIN.\n\tfloat xCheck = x <= 0.0 ? 1e-4 : x;\n\n\tfloat logx = log10(xCheck);\n\n\tfloat logy;\n\n\tif ( logx <= log10(C.minPoint.x) )\n\t{\n\t\tlogy = logx * C.slopeLow + ( log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );\n\t}\n\telse if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) ))\n\t{\n\t\tfloat knot_coord = float(N_KNOTS_LOW-1) * (logx-log10(C.minPoint.x))/(log10(C.midPoint.x)-log10(C.minPoint.x));\n\t\tint j = int(knot_coord);\n\t\tfloat t = knot_coord - float(j);\n\n        // can't index on non-const value...\n\t\t//vec3 cf = vec3(C.coefsLow[j], C.coefsLow[j + 1], C.coefsLow[j + 2]);\n        vec3 cf = vec3(C.coefsLow[0], C.coefsLow[1], C.coefsLow[2]);\n        if (j == 1)\n            cf = vec3(C.coefsLow[1], C.coefsLow[2], C.coefsLow[3]);\n        else if (j == 2)\n            cf = vec3(C.coefsLow[2], C.coefsLow[3], C.coefsLow[4]);\n        else if (j == 3)\n            cf = vec3(C.coefsLow[3], C.coefsLow[4], C.coefsLow[5]);    \n        else if (j == 4)\n            cf = vec3(C.coefsLow[4], C.coefsLow[5], C.coefsLow[6]);    \n        else if (j == 5)\n            cf = vec3(C.coefsLow[5], C.coefsLow[6], C.coefsLow[7]);    \n        else if (j == 6)\n            cf = vec3(C.coefsLow[6], C.coefsLow[7], C.coefsLow[8]);    \n        else if (j == 7)\n            cf = vec3(C.coefsLow[7], C.coefsLow[8], C.coefsLow[9]);    \n            \n\t\tvec3 monomials = vec3(t * t, t, 1.);\n\t\tlogy = dot( monomials, (M * cf) );\n\t}\n\telse if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) ))\n\t{\n\t\tfloat knot_coord = float(N_KNOTS_HIGH-1) * (logx-log10(C.midPoint.x))/(log10(C.maxPoint.x)-log10(C.midPoint.x));\n\t\tint j = int(knot_coord);\n\t\tfloat t = knot_coord - float(j);\n\n        // can't index on non-const value...\n\t\t//vec3 cf = vec3(C.coefsHigh[ j], C.coefsHigh[ j + 1], C.coefsHigh[ j + 2]); \n        vec3 cf = vec3(C.coefsHigh[0], C.coefsHigh[1], C.coefsHigh[2]);\n        if (j == 1)\n            cf = vec3(C.coefsHigh[1], C.coefsHigh[2], C.coefsHigh[3]);\n        else if (j == 2)\n            cf = vec3(C.coefsHigh[2], C.coefsHigh[3], C.coefsHigh[4]);\n        else if (j == 3)\n            cf = vec3(C.coefsHigh[3], C.coefsHigh[4], C.coefsHigh[5]);    \n        else if (j == 4)\n            cf = vec3(C.coefsHigh[4], C.coefsHigh[5], C.coefsHigh[6]);    \n        else if (j == 5)\n            cf = vec3(C.coefsHigh[5], C.coefsHigh[6], C.coefsHigh[7]);    \n        else if (j == 6)\n            cf = vec3(C.coefsHigh[6], C.coefsHigh[7], C.coefsHigh[8]);    \n        else if (j == 7)\n            cf = vec3(C.coefsHigh[7], C.coefsHigh[8], C.coefsHigh[9]);    \n            \n\t\tvec3 monomials = vec3(t * t, t, 1.);\n\t\tlogy = dot( monomials, (M * cf) );\n\t}\n\telse //if ( logIn >= log10(C.maxPoint.x) )\n\t{ \n\t\tlogy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );\n\t}\n\n\treturn pow(10.0, logy);  \n}\n\n////////////////////////////////////////////////////////////////////////////\n// ACSElib.RRT_Common.a1.0.0\n\n// \"Glow\" module constants\nconst float RRT_GLOW_GAIN = 0.05;\nconst float RRT_GLOW_MID = 0.08;\n\n// Red modifier constants\nconst float RRT_RED_SCALE = 0.82;\nconst float RRT_RED_PIVOT = 0.03;\nconst float RRT_RED_HUE = 0.0;\nconst float RRT_RED_WIDTH = 135.0;\n\n// Desaturation contants\nconst float RRT_SAT_FACTOR = 0.96;\n\n// Glow module functions\nfloat glow_fwd( float ycIn, float glowGainIn, float glowMid)\n{\n\tfloat glowGainOut;\n\n\tif (ycIn <= 2.0 / 3.0 * glowMid)\n\t\tglowGainOut = glowGainIn;\n\telse if ( ycIn >= 2.0 * glowMid)\n\t\tglowGainOut = 0.0;\n\telse\n\t\tglowGainOut = glowGainIn * (glowMid / ycIn - 1.0 / 2.0);\n\n\treturn glowGainOut;\n}\n\nfloat glow_inv( float ycOut, float glowGainIn, float glowMid)\n{\n     float glowGainOut;\n\n     if (ycOut <= ((1.0 + glowGainIn) * 2.0 / 3.0 * glowMid))\n\t\tglowGainOut = -glowGainIn / (1.0 + glowGainIn);\n     else if ( ycOut >= (2.0 * glowMid))\n\t\tglowGainOut = 0.0;\n     else\n\t\tglowGainOut = glowGainIn * (glowMid / ycOut - 1.0 / 2.0) / (glowGainIn / 2.0 - 1.0);\n\n     return glowGainOut;\n}\n\nfloat sigmoid_shaper( float x)\n{\n\t// Sigmoid function in the range 0 to 1 spanning -2 to +2.\n\n\tfloat t = max( 1.0 - abs( x / 2.0 ), 0.0 );\n\tfloat y = 1.0 + sign(x) * (1.0 - t * t);\n\t\n\treturn y / 2.0;\n}\n\n// Red modifier functions\nfloat cubic_basis_shaper\n( \n\tfloat x, \n\tfloat w   // full base width of the shaper function (in degrees)\n)\n{\n\tmat4 M = mat4(-1.0/6.0,  3.0/6.0, -3.0/6.0,  1.0/6.0,\n\t\t\t\t   3.0/6.0, -6.0/6.0,  3.0/6.0,  0.0/6.0,\n\t\t\t\t  -3.0/6.0,  0.0/6.0,  3.0/6.0,  0.0/6.0,\n\t\t\t\t   1.0/6.0,  4.0/6.0,  1.0/6.0,  0.0/6.0);\n  \n\tfloat knots[5];\n    knots[0] = -w/2.0;\n\tknots[0] = -w/4.0;\n\tknots[0] = 0.0;\n\tknots[0] = w/4.0;\n\tknots[0] = w/2.0;\n  \n\tfloat y = 0.0;\n\tif ((x > knots[0]) && (x < knots[4]))\n\t{  \n\t\tfloat knot_coord = (x - knots[0]) * 4.0 / w;  \n\t\tint j = int(knot_coord);\n\t\tfloat t = knot_coord - float(j);\n      \n\t\tvec4 monomials = vec4(t*t*t, t*t, t, 1.);\n\n\t\t// (if/else structure required for compatibility with CTL < v1.5.)\n\t\tif ( j == 3) {\n\t\t\ty = monomials[0] * M[0][0] + monomials[1] * M[1][0] + \n\t\t\t\tmonomials[2] * M[2][0] + monomials[3] * M[3][0];\n\t\t} else if ( j == 2) {\n\t\t\ty = monomials[0] * M[0][1] + monomials[1] * M[1][1] + \n\t\t\t\tmonomials[2] * M[2][1] + monomials[3] * M[3][1];\n\t\t} else if ( j == 1) {\n\t\t\ty = monomials[0] * M[0][2] + monomials[1] * M[1][2] + \n\t\t\t\tmonomials[2] * M[2][2] + monomials[3] * M[3][2];\n\t\t} else if ( j == 0) {\n\t\t\ty = monomials[0] * M[0][3] + monomials[1] * M[1][3] + \n\t\t\t\tmonomials[2] * M[2][3] + monomials[3] * M[3][3];\n\t\t}\n\t}\n  \n\treturn y * 3.0 / 2.0;\n}\n\nfloat center_hue( float hue, float centerH)\n{\n\tfloat hueCentered = hue - centerH;\n\tif (hueCentered < -180.0)\n\t\thueCentered = hueCentered + 360.0;\n\telse if (hueCentered > 180.0)\n\t\thueCentered = hueCentered - 360.0;\n\treturn hueCentered;\n}\n\nfloat uncenter_hue( float hueCentered, float centerH)\n{\n\tfloat hue = hueCentered + centerH;\n\tif (hue < 0.0)\n\t\thue = hue + 360.0;\n\telse if (hue > 360.0)\n\t\thue = hue - 360.0;\n\treturn hue;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// RRT.a1.0.0\n\n// \n// Reference Rendering Transform (RRT)\n//\n//   Input is ACES\n//   Output is OCES\n//\n\nvec3 RRT( vec3 aces )\n{\n\t// Glow module\n    float saturation = rgb_2_saturation( aces );\n    float ycIn = rgb_2_yc( aces, 1.75 );\n    float s = sigmoid_shaper( (saturation - 0.4) / 0.2 );\n    float addedGlow = 1. + glow_fwd( ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\n\n    aces *= addedGlow;\n  \n\t// Red modifier\n    float hue = rgb_2_hue( aces );\n    float centeredHue = center_hue( hue, RRT_RED_HUE );\n    float hueWeight = cubic_basis_shaper( centeredHue, RRT_RED_WIDTH );\n\t\t\n\taces.r += hueWeight * saturation * (RRT_RED_PIVOT - aces[0]) * (1.0 - RRT_RED_SCALE);\n\n\t// ACES to RGB rendering space\n    aces = clamp( aces, 0.0, 65535.0 );  // avoids saturated negative colors from becoming positive in the matrix\n\n    vec3 rgbPre = ( aces * AP0_2_AP1_MAT );\n    rgbPre = clamp( rgbPre, 0.0, 65535.0 );\n\n\t// Global desaturation\n    //rgbPre = RRT_SAT_MAT * rgbPre;\n\trgbPre = mix( vec3(dot( rgbPre, AP1_RGB2Y )), rgbPre, vec3(RRT_SAT_FACTOR) ); // faster than matrix\n\n\t// Apply the tonescale independently in rendering-space RGB\n    vec3 rgbPost;\n    rgbPost.r = segmented_spline_c5_fwd(rgbPre.r);\n    rgbPost.g = segmented_spline_c5_fwd(rgbPre.g);\n    rgbPost.b = segmented_spline_c5_fwd(rgbPre.b);\n\n\t// RGB rendering space to OCES\n\tvec3 rgbOces = ( rgbPost * AP1_2_AP0_MAT );\n\treturn rgbOces;\n}\n\n////////////////////////////////////////////////////////////////////////////\n// ACESlib.ODT_Common.a1.0.0\n\nconst vec2 AP0_WhitePoint = vec2(0.32168, 0.33767);\nconst vec2 REC709_WhitePoint = vec2(0.31270, 0.32900);\n\n// Target white and black points for cinema system tonescale\nconst float CINEMA_WHITE = 48.0;\nconst float CINEMA_BLACK = 0.02;\n// CINEMA_WHITE / 2400.\n\n// Gamma compensation factor\nconst float DIM_SURROUND_GAMMA = 0.9811;\n\n// Saturation compensation factor\nconst float ODT_SAT_FACTOR = 0.93;\n\nvec3 Y_2_linCV( vec3 Y, float Ymax, float Ymin) \n{\n\treturn (Y - Ymin) / (Ymax - Ymin);\n}\n\nvec3 darkSurround_to_dimSurround( vec3 linearCV )\n{\n\tvec3 XYZ = ( linearCV * AP1_2_XYZ_MAT );\n\n\tvec3 xyY = XYZ_2_xyY(XYZ);\n\txyY[2] = clamp( xyY[2], 0.0, 65535.0 );\n\txyY[2] = pow(xyY[2], DIM_SURROUND_GAMMA);\n\tXYZ = xyY_2_XYZ(xyY);\n\n\treturn ( XYZ * XYZ_2_AP1_MAT );\n}\n\n////////////////////////////////////////////////////////////////////////////\n// ODT.Academy.RGBmonitor_D60sim_100nits_dim.a1.0.0\n\n// \n// Output Device Transform - RGB computer monitor (D60 simulation)\n//\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a desktop computer monitor \n//  typical of those used in motion picture visual effects production used to \n//  simulate the image appearance produced by odt_p3d60. These monitors may\n//  occasionally be referred to as \"sRGB\" displays, however, the monitor for\n//  which this transform is designed does not exactly match the specifications\n//  in IEC 61966-2-1:1999.\n// \n//  The assumed observer adapted white is D60, and the viewing environment is \n//  that of a dim surround. \n//\n//  The monitor specified is intended to be more typical of those found in \n//  visual effects production.\n//\n// Device Primaries : \n//  Primaries are those specified in Rec. ITU-R BT.709\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.64      0.33\n//              Green:        0.3       0.6\n//              Blue:         0.15      0.06\n//              White:        0.3217    0.329     100 cd/m^2\n//\n// Display EOTF :\n//  The reference electro-optical transfer function specified in \n//  IEC 61966-2-1:1999.\n//\n// Signal Range:\n//    This tranform outputs full range code values.\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.32168      0.33767\n//\n// Viewing Environment:\n//   This ODT has a compensation for viewing environment variables more typical \n//   of those associated with video mastering.\n//\n\nconst float DISPGAMMA = 2.4; \nconst float OFFSET = 0.055;\nconst float SCALE = 0.955;\n\nconst mat3 XYZ_2_DISPLAY_PRI_MAT = mat3\n(\n\t 3.2409699419,-1.5373831776,-0.4986107603,\n\t-0.9692436363, 1.8759675015, 0.0415550574,\n\t 0.0556300797,-0.2039769589, 1.0569715142\n);\n\nconst mat3 DISPLAY_PRI_2_XYZ_MAT = mat3\n(\n\t0.4123907993, 0.3575843394, 0.1804807884,\n\t0.2126390059, 0.7151686788, 0.0721923154,\n    0.0193308187, 0.1191947798, 0.9505321523\n);\n\nvec3 ODT( vec3 oces )\n{\n\t// OCES to RGB rendering space\n\tvec3 rgbPre = ( oces * AP0_2_AP1_MAT );\n\n\t// Apply the tonescale independently in rendering-space RGB\n    vec3 rgbPost;\n    rgbPost[0] = segmented_spline_c9_fwd(rgbPre[0]);\n    rgbPost[1] = segmented_spline_c9_fwd(rgbPre[1]);\n    rgbPost[2] = segmented_spline_c9_fwd(rgbPre[2]);\n\n\t// Scale luminance to linear code value\n    vec3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n  \n  \t// Compensate for different white point being darker\n\t// This adjustment is to correct an issue that exists in ODTs where the device \n\t// is calibrated to a white chromaticity other than D60. In order to simulate \n\t// D60 on such devices, unequal code values are sent to the display to achieve \n\t// neutrals at D60. In order to produce D60 on a device calibrated to the DCI \n\t// white point (i.e. equal code values yield CIE x,y chromaticities of 0.314, \n\t// 0.351) the red channel is higher than green and blue to compensate for the \n\t// \"greenish\" DCI white. This is the correct behavior but it means that as \n\t// highlight increase, the red channel will hit the device maximum first and \n\t// clip, resulting in a chromaticity shift as the green and blue channels \n\t// continue to increase.\n\t// To avoid this clipping error, a slight scale factor is applied to allow the \n\t// ODTs to simulate D60 within the D65 calibration white point. \n\n    // Scale and clamp white to avoid casted highlights due to D60 simulation\n    linearCV = min(linearCV, 1.0) * SCALE;\n\n\t// Apply gamma adjustment to compensate for dim surround\n    linearCV = darkSurround_to_dimSurround( linearCV);\n\n\t// Apply desaturation to compensate for luminance difference\n    //linearCV = mul(linearCV, ODT_SAT_MAT);\n\tlinearCV = mix( vec3(dot( linearCV, AP1_RGB2Y )), linearCV, vec3(ODT_SAT_FACTOR) ); // faster than matrix\n\n\t// Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    vec3 XYZ = ( linearCV * AP1_2_XYZ_MAT );\n\n    // CIE XYZ to display primaries\n    linearCV = ( XYZ * XYZ_2_DISPLAY_PRI_MAT );\n\n\t// Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = clamp( linearCV, 0.0, 1.0 );\n  \n\t// Encode linear code values with transfer function\n    // moncurve_r with gamma of 2.4 and offset of 0.055 matches the EOTF found in IEC 61966-2-1:1999 (sRGB)\n    return vec3(moncurve_r(linearCV.r, DISPGAMMA, OFFSET),\n\t\t\t\t  moncurve_r(linearCV.g, DISPGAMMA, OFFSET),\n\t\t\t\t  moncurve_r(linearCV.b, DISPGAMMA, OFFSET));\n}\n\n// ACEScsc.ACES_to_ACESproxy12i.a1.0.3\n    \nconst float StepsPerStop = 200.0;\nconst float MidCVoffset  = 1700.0;\nconst float CVmin        = 256.0;\nconst float CVmax        = 3760.0;\n\nvec3 ACES_2_ACESproxy(vec3 x)\n{\n    x = clamp( x, 0.0, 65535.0);\n    x = x * AP0_2_AP1_MAT;\n    x.r = (x.r <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.r) + 2.5) * StepsPerStop + MidCVoffset)));\n\tx.g = (x.g <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.g) + 2.5) * StepsPerStop + MidCVoffset)));    \n    x.b = (x.b <= pow(2.0, -9.72)) ? CVmin : max(CVmin, min(CVmax, ((log2(x.b) + 2.5) * StepsPerStop + MidCVoffset)));\n\treturn x / 4095.0;\n}\n\nvec3 ACESproxy_2_ACES(vec3 x)\n{\n    x = x * 4095.0;\n    x = pow(vec3(2.0), (x - MidCVoffset) / StepsPerStop - 2.5);\n\treturn x * AP1_2_AP0_MAT;\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvec3 rgb_2_ap0( vec3 color )\n{\n    mat3 D65_2_D60_CAT = calculate_cat_matrix( REC709_WhitePoint, AP0_WhitePoint );\n    mat3 sRGB_2_AP0 = ((DISPLAY_PRI_2_XYZ_MAT * D65_2_D60_CAT) * XYZ_2_AP0_MAT);\n\treturn (color * sRGB_2_AP0);\n}\n\nvec3 rgb_2_ap1( vec3 color )\n{\n    mat3 D65_2_D60_CAT = calculate_cat_matrix( REC709_WhitePoint, AP0_WhitePoint );\n    mat3 sRGB_2_AP1 = ((DISPLAY_PRI_2_XYZ_MAT * D65_2_D60_CAT) * XYZ_2_AP1_MAT);\n\treturn (color * sRGB_2_AP1);\n}\n\nvec3 ap0_2_rgb( vec3 color )\n{\n    mat3 D60_2_D65_CAT = calculate_cat_matrix( AP0_WhitePoint, REC709_WhitePoint );\n \tmat3 AP0_2_sRGB = (AP0_2_XYZ_MAT * D60_2_D65_CAT) * XYZ_2_DISPLAY_PRI_MAT;\n    return (color * AP0_2_sRGB);\n}\n\nvec3 ap1_2_rgb( vec3 color )\n{\n    mat3 D60_2_D65_CAT = calculate_cat_matrix( AP0_WhitePoint, REC709_WhitePoint );\n \tmat3 AP1_2_sRGB = (AP1_2_XYZ_MAT * D60_2_D65_CAT) * XYZ_2_DISPLAY_PRI_MAT;\n    return (color * AP1_2_sRGB);\n}\n\nvec3 cineon_log_2_linear(in vec3 color)\n{\n\treturn (pow(vec3(10.0), (1023.0 * color - 685.0) / 300.0) - 0.0108) / (1.0 - 0.0108);\n}\n\nvec3 rgb_2_hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv_2_rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    // LUT in bottom rect.\n    if(fragCoord.x < LUT_WIDTH && fragCoord.y < LUT_SIZE)\n    {    \n        vec2 uv = fragCoord.xy / vec2(LUT_SIZE);\n\n        float scale = LUT_SIZE / (LUT_SIZE - 1.0);\n        float slice = floor(uv.x) / (LUT_SIZE - 1.0);\n        vec4 image = vec4(fract(uv) * scale - 0.5 / (LUT_SIZE - 1.0), slice, 1.0);\n\n        // Transform to ACEScg.\n        vec3 workingColor = ACESproxy_2_ACES(image.xyz) * AP0_2_AP1_MAT;\n\n        // Apply input levels adjustment.\n        workingColor.xyz = pow( max( (workingColor.xyz - LEVELS_MIN) / (LEVELS_MAX - LEVELS_MIN), 0.0), LEVELS_GAMMA);\n\n        // Apply primary adjusments.\n        workingColor = pow( workingColor * (GAIN - LIFT*0.5 + 0.5) + (LIFT*0.5 - 0.5), vec3(1.0 / GAMMA) );\n\n        // Apply sigmoid contrast.\n        workingColor.xyz = pow((workingColor.xyz / CONTRAST_PIVOT), vec3(CONTRAST)) * CONTRAST_PIVOT;\n        \n        // Apply log adjustment (Shadows/Midtones/Highlights).\n        float lum = dot(workingColor, AP1_RGB2Y);\n        float shadowWeight = 1.0 - smoothstep(0.0, SHADOW_RANGE, lum);\n        float highlightWeight = smoothstep(HIGHLIGHT_RANGE, 1.0, lum);\n        float midtoneWeight = 1.0 - shadowWeight - highlightWeight;\n        workingColor *= (shadowWeight * SHADOW_COLOR) + (midtoneWeight * MIDTONE_COLOR + (highlightWeight * HIGHLIGHT_COLOR));    \n\n        // Apply hue and saturation adjustments.\n        vec3 hsv = rgb_2_hsv(workingColor);\n        hsv.x += HUESHIFT;\n        hsv.y *= SATURATION;\n        workingColor = hsv_2_rgb(hsv);\n        \n        // Transform to ACES space.\n        workingColor = workingColor * AP1_2_AP0_MAT;\n        \n        // Apply RRT and ODT for final output.\n        image.xyz = ODT(RRT((workingColor)));\n        \n        fragColor = image;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}