{"ver":"0.1","info":{"id":"MlVyW1","date":"1536113314","viewed":409,"name":"Introflection","username":"efairbanks","description":"Playing around with rayscattering, infinite reflections, volumetric lights, temporal AA, etc...\n\nNothing fancy here, and the code is a bit bloated, but this runs well at even at pretty high settings on my GTX970.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","reflection","distancefields","montecarlo","temporalaa","rayscattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec3 col=texture(iChannel0, uv).xyz;\n    fragColor=vec4(vec3(col),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 10.\n#define MAX_STEPS 150\n#define MAX_REFLECTIONS 10\n#define REFLECTION_BACKSTEP 0.05\n#define MARCH_COEF 0.7\n#define MARCH_EPSILON 0.01\n#define NORM_EPSILON 0.005\n#define SSAA 2\nvec2 _max(vec2 a,vec2 b){return a.x>b.x?a:b;}\nvec2 _min(vec2 a,vec2 b){return a.x<b.x?a:b;}\nvec2 c2p(in vec2 p){return vec2(atan(p.y,p.x),length(p));}\nvec2 p2c(in vec2 p){return vec2(cos(p.x),sin(p.x))*p.y;}\nfloat rand31a(vec3 n){return fract(sin(sin(dot(n,vec3(70.19,44.57,32.99)))*10465.27)*1676.9023);}\nfloat rand31b(vec3 n){return fract(sin(sin(dot(n,vec3(21.53,37.97,55.07)))*3991.6801)*21474.83647);}\nfloat randa(float n){return fract(sin(sin(n*21474.83647)*108.301)*115.249);}\nfloat randb(float n){return fract(sin(sin(n*3991.6801)*993.319)*4790.01599);}\nvec2 map(vec3 p)\n{\n    vec3 q=p;\n    q=sin(q*0.6);\n    q=abs(q);\n    q-=0.3;\n    vec2 d=vec2(length(q)-.2,1.);\n    d=_max(d,vec2(length(p)-1.,1.));\n    d=_min(d,vec2(10.-length(p),101.));\n    return d;\n}\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(NORM_EPSILON,0.);\n    return normalize(vec3(\n    \tmap(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n}\nvec2 march(vec3 o,vec3 r)\n{\n    vec2 result;\n    float t=0.;\n\tfor(int i=0;i<MAX_STEPS;i++)\n    {\n        result=map(o+r*t);\n        if(result.x>=MAX_DIST) return vec2(MAX_DIST,0.);\n        if(result.x<MARCH_EPSILON) break;\n        t+=result.x*MARCH_COEF;\n    }\n    return vec2(t,result.y);\n}\nvec3 look(vec2 uv,vec3 o,vec3 t)\n{\n\tvec3 fwd=normalize(t-o);\n    vec3 up=normalize(vec3(0.,1.,0.));\n    vec3 right=normalize(cross(fwd,up));\n    up=normalize(cross(fwd,right));\n    return normalize(fwd+right*uv.x+up*uv.y);\n}\nstruct mat\n{\n    vec3 absorption;\n    vec3 luminance;\n    float diffusion;\n};\nmat material(vec3 p,float m)\n{\n    if(m==0.) return mat(vec3(0.),vec3(0.),0.);\n    if(m==1.) return mat(vec3(0.8,0.9,1.0)*0.99,vec3(0.),0.005);\n    if(m==2.) return mat(vec3(0.),vec3(20.),0.);\n    if(m==100.) return mat(vec3(0.),vec3(9000.),0.);\n    float xz=c2p(p.xz).x;\n    float xy=c2p(p.xy).x;\n    xz=mod(xz*1.,1.)-0.5;\n    xy=mod(xy*1.,1.)-0.5;\n    float lum=1.-min(length(vec2(xz*10.,xy*10.)),1.);\n    lum=pow(lum,0.5)*2000.;\n    return mat(vec3(1.,0.95,0.9),vec3(lum),0.);\n}\nvec3 scatter(vec3 ray,vec2 d)\n{\n    vec3 up=normalize(vec3(0.,1.,0.));\n    vec3 right=normalize(cross(ray,up));\n    up=normalize(cross(ray,right));\n    return normalize(ray+d.x*right+d.y*up);\n}\nvec3 light(vec3 o,vec3 r)\n{\n    vec3 origin=o;\n    vec3 ray=r;\n    vec3 absorption=vec3(1.);\n    vec3 luminance=vec3(0.);\n    float travelled=0.;\n    for(int i=0;i<MAX_REFLECTIONS;i++)\n    {\n        vec2 result=march(origin,ray);\n        travelled+=result.x;\n        mat m=material(origin+ray*result.x,result.y);\n        luminance+=m.luminance/pow(travelled,2.);\n        if(length(m.absorption)<=0.) break;\n        absorption*=m.absorption;\n        origin=origin+ray*(result.x-REFLECTION_BACKSTEP);\n        vec2 scat=vec2(rand31a(origin+randa(iTime)),rand31b(origin+randb(iTime)))-0.5;\n        ray=scatter(reflect(ray,normal(origin)),scat*m.diffusion);\n    }\n    return luminance*absorption;\n}\nvec3 pixel(vec2 xy)\n{\n    vec2 uv = (xy/iResolution.xy)-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float iTime=iTime/3.;\n    vec3 cam=vec3(0.,0.,1.);\n    cam.xz=p2c(c2p(cam.xz)+vec2(iTime/11.,0.));\n    cam.y=sin(iTime/7.)*0.5;\n    cam*=2.5;\n    vec3 ray=look(uv,cam,vec3(0.));\n    vec3 col=light(cam,ray);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ret=vec3(0.);\n    for(int i=0;i<SSAA;i++){\n        for(int j=0;j<SSAA;j++){\n    \t\tret += pixel(fragCoord+((float(i)-1.)+(float(j)-1.))*(1./float(SSAA)));\n        }}\n    ret/=pow(float(SSAA),2.);\n    float coef=0.1;\n    vec3 lastVal=texture(iChannel0, (fragCoord.xy+vec2(randa(iTime)-0.5,randb(iTime)-0.5)*0.15)/iResolution.xy).xyz;\n    ret=ret*coef+lastVal*(1.-coef);\n    ret=min(ret,1.);\n    fragColor=vec4(ret,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}