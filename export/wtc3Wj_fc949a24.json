{"ver":"0.1","info":{"id":"wtc3Wj","date":"1577786831","viewed":205,"name":"Ecosphere","username":"psandahl","description":"My first serious attempt in making a shader demo. Enjoy the Ecosphere!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","distancefields","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ecosphere - the procedural creation of a planet like sphere.\n//\n// Patrik Sandahl, 2019 - patrik.sandahl@gmail.com\n//\n// 3D noise algorithm by Ian McEwan, Ashima Arts.\n\n#define EPSILON 0.001\n#define DEFAULT_ZOOM 1.0\n\n#define PI 3.141592653589\n\n#define MAX_OCTAVES 9.0\n\n// Material for nothing. I.e. the empty space.\n#define MAT_NOTHING 0\n\n// Material for the colored sphere.\n#define MAT_COLOR_SPHERE 1\n\n// Material for the sea water.\n#define MAT_WATER_SPHERE 2\n\n// World seed - skew the input for the noise.\n#define WORLD_SEED 47.159\n\n// Initial scene - base sphere goes from dark to light and\n// gradually morphs into the naked ecosphere.\n#define SCENE0 0\n\n// Second scene - the colored ecosphere.\n#define SCENE1 1\n\n// Third scene - sea level rises.\n#define SCENE2 2\n\n// Forth scene - one day and night cycle.\n#define SCENE3 3\n\n// A ray object with origin and direction.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Force normalization of direction when creating a ray.\nRay ray(vec3 origin, vec3 direction);\n\n// Calculate a point at distance d along the ray.\nvec3 point(Ray r, float d);\n\n// Generate a primary camera ray given:\n// eye - the camera position.\n// at - the position where the camera is looking.\n// up - the world up position.\n// focalLength - the zoom value for the camera. A greater value zoom in.\n// uv - the uv coordinate for which the ray is produced. It is assumed\n// that uv zero is in the middle of the projection.\n// The camera is assuming an OpenGL like coordinate system.\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv);\n\n// An intersection object with distance along the ray, an displacement\n// offset for the object and the material id for the object.\nstruct Intersection {\n    float dist;\n    float offset;\n    int material;\n};\n\n// Produce the closest intersection from the scene given the position.\nIntersection intersectScene(int sceneId, vec3 pos);\n\n// March the ray for an intersection with the scene.\nIntersection march(int sceneId, Ray r, float far);\n    \n// Calculate a normal through central difference. It's very expensive\n// though. Consider a noise function with analytical derivatives as\n// future improvement.\nvec3 calcNormal(int sceneId, vec3 pos);\n\n// Calculate a 2D rotations matrix.\nmat2 calcRotate2d(float theta);\n\n// Distance function for the base sphere.\nfloat baseSphere(vec3 pos);\n\n// Distance function for a shere. The position - relative origin - and\n// the radius for the sphere.\nfloat sphere(vec3 pos, float radius);\n\n// Get the sun's position.\nvec3 sunPosition(int sceneId);\n\n// Normalize the height offset from ~[-1 : 1] to ~[0 : 1].\nfloat normalizeOffset(float offset);\n\n// Get the terrain color the given height offset.\nvec3 terrainColor(float offset);\n\n// Estimate the needed number of octaves from screen with.\nint estimateOctaves(float width);\n\n// Noise functions.\nfloat fbm(vec3 pos, int numOctaves);\nfloat snoise(vec3 v);\n\n// Entry point for generating the image.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinate where origo is in the\n    // middle and compensation is made for aspect ratio.\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Make a primary ray for the uv position.\n    vec3 eye = vec3(0.0, 0.0, 25.0);\n    vec3 at = vec3(0.0);\n    vec3 up = normalize(vec3(0.5, 1.0, 0.0)); // Tilt the view a little.\n    \n    Ray primaryRay = cameraRay(eye, at, up, DEFAULT_ZOOM, uv);\n            \n    // Determine scene id from time.   \n    int sceneId = SCENE0;\n    if (iTime >= 24.0) {\n      \tsceneId = SCENE3;\n    } else if (iTime >= 16.0) {\n        sceneId = SCENE2;\n    } else if (iTime >= 12.0) {\n        sceneId = SCENE1;\n    }\n    \n    // Perform the ray marching, keep the far plane near ;-)\n    Intersection intersection = march(sceneId, primaryRay, 45.0);\n    \n    // Create a default color for the current pixel.\n    vec3 color = vec3(0.0);\n    \n    switch (intersection.material) {\n        // A sphere colored using its height offset.\n        case MAT_COLOR_SPHERE:\n        {\n         \tvec3 pos = point(primaryRay, intersection.dist);\n    \t\tvec3 lightDirection = normalize(sunPosition(sceneId) - pos);\n    \t\tvec3 normal = calcNormal(sceneId, pos);                \n    \t\tfloat light = max(0.0, dot(normal, lightDirection));            \n                            \n            vec3 graySphere = vec3(normalizeOffset(intersection.offset));\n            vec3 colorSphere = terrainColor(intersection.offset);\n            color = mix(graySphere, colorSphere, smoothstep(12.0, 16.0, iTime));\n                \n        \tcolor = color * light;\n        }\n       \tbreak;\n        \n        // A sphere with ocean color.\n        case MAT_WATER_SPHERE:\n        {\n            vec3 pos = point(primaryRay, intersection.dist);\n    \t\tvec3 lightDirection = normalize(sunPosition(sceneId) - pos);\n    \t\tvec3 normal = calcNormal(sceneId, pos);                \n    \t\tfloat light = max(0.0, dot(normal, lightDirection));\n            \n            vec3 ocean = vec3(0.0, 67.0 / 255.0, 123.0 / 255.0);\n            color = ocean * light;\n        }\n        break;\n        \n        default:\n        \t// Just rendering the black void with default color.\n        \tbreak;\n    }\n\n    // Output to screen.\n    fragColor = vec4(color, 1.0);\n}\n\nRay ray(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\nvec3 point(Ray r, float d)\n{\n    return r.origin + r.direction * d;\n}\n\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv)\n{\n    vec3 z = normalize(at - eye);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = cross(x, z);\n    \n    vec3 center = eye + z * focalLength;\n    vec3 xy = center + uv.x * x + uv.y * y;\n    \n    return ray(eye, xy - eye);\n}\n\nIntersection intersectScene(int sceneId, vec3 pos)\n{\n    // The sphere shall be rotated in all scenes.\n    pos.xz = calcRotate2d(iTime * 0.05) * pos.xz;\n    \n    // And there always be a base sphere.\n    float sphereDist = baseSphere(pos - vec3(0.0));\n    \n    // There shall always be height offset.\n    float offset = fbm((pos + WORLD_SEED) * 0.13, estimateOctaves(iResolution.y));\n    \n    if (sceneId == SCENE0) {\n        \n        // Mix between the base sphere and the ecosphere.\n        float factor = smoothstep(4.0, 10.0, iTime);\n        float dist = mix(sphereDist, sphereDist - offset, factor);\n        \n        return Intersection(dist, offset, MAT_COLOR_SPHERE);      \n    }  else if (sceneId == SCENE1) {\n        \n        // Just the ecosphere.\n        return Intersection(sphereDist - offset, offset, MAT_COLOR_SPHERE);      \n    } else {\n        \n        // The ecosphere and sea.\n        float seaDist = sphere(pos - vec3(0.0), mix(9.00, 9.88, smoothstep(16.0, 24.0, iTime)));        \n        if (seaDist < sphereDist - offset) {\n            return Intersection(seaDist, 0.0, MAT_WATER_SPHERE);\n        } else {\n            return Intersection(sphereDist - offset, offset, MAT_COLOR_SPHERE);\n        }\n    }\n}\n\nIntersection march(int sceneId, Ray r, float far)\n{\n    float rayDistance = 0.0;\n    Intersection intersection = Intersection(0.0, 0.0, MAT_NOTHING);\n    \n    for (int i = 0; i < 100; ++i) {       \n        intersection = intersectScene(sceneId, point(r, rayDistance));\n        \n        rayDistance += intersection.dist;\n        if (intersection.dist < EPSILON) break;\n        if (rayDistance > far) {\n            intersection.material = MAT_NOTHING;\n            break;\n        }\n    }\n    \n    intersection.dist = rayDistance;\n    return intersection;\n}\n\nvec3 calcNormal(int sceneId, vec3 pos)\n{\n    float d = intersectScene(sceneId, pos).dist;\n    vec2 e = vec2(EPSILON, 0.0);\n    \n    vec3 n = d - vec3(\n        intersectScene(sceneId, pos - e.xyy).dist,\n        intersectScene(sceneId, pos - e.yxy).dist,\n        intersectScene(sceneId, pos - e.yyx).dist\n    );\n    \n    return normalize(n);\n}\n\nmat2 calcRotate2d(float theta)\n{\n    return mat2(vec2(cos(theta), -sin(theta)), vec2(sin(theta), cos(theta)));\n}\n\nfloat baseSphere(vec3 pos)\n{\n    return sphere(pos, 10.0);\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nvec3 sunPosition(int sceneId)\n{\n    // The base position for the sun.\n    vec3 basePosition = vec3(100.0, 0.0, 100.0);\n    \n    if (sceneId == SCENE0) {\n        // Let the sun travel one half orbit from back of sphere to base.\n        float theta = mix(-PI, 0.0, smoothstep(0.0, 10.0, iTime));\n        basePosition.xz = calcRotate2d(theta) * basePosition.xz;\n    } else if (sceneId == SCENE3) {\n        // Let the sun orbit. 20 seconds for a full circle.\n        float theta = mix(0.0, PI * 2.0, smoothstep(24.0, 34.0, iTime));\n        basePosition.xz = calcRotate2d(theta) * basePosition.xz;\n    }\n    \n    return basePosition;\n}\n\nfloat normalizeOffset(float offset)\n{\n    return offset * 0.75 + 0.5;\n}\n\nvec3 terrainColor(float offset)\n{\n    offset = normalizeOffset(offset);\n    \n    vec3 clay = vec3(127.0 / 255.0, 95.0 / 255.0, 63.0 / 255.0);\n    vec3 fern = vec3(79.0 / 255.0, 121.0 / 255.0, 66.0 / 255.0);\n    vec3 forest = vec3(11.0 / 255.0, 102.0 / 255.0, 35.0 / 255.0);\n    vec3 granite = vec3(97.0 / 255.0, 97.0 / 255.0, 97.0 / 255.0);\n    vec3 snow = vec3(1.0, 250.0 / 255.0, 250.0 / 255.0);\n    \n    vec3 color = mix(clay, fern, smoothstep(0.0, 0.4, offset));\n    color = mix(color, forest, smoothstep(0.4, 0.55, offset));\n    color = mix(color, granite, smoothstep(0.55, 0.65, offset));\n    color = mix(color, snow, smoothstep(0.65, 1.0, offset));\n    \n    return vec3(color);\n}\n\nint estimateOctaves(float height)\n{\n    // Ad hoc heuristics for the selection of octaves. Made from what's looking good.\n    if (height <= 450.0) {\n        return 7;\n    } else if (height <= 675.0) {\n        return 8;\n    } else {\n        return 9;\n    }\n}\n\nfloat fbm(vec3 pos, int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * snoise(pos);\n\t\tpos = pos * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x) {return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v)\n{ \n  \tconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  \tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n  \tvec3 i = floor(v + dot(v, C.yyy) );\n  \tvec3 x0 = v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n  \tvec3 g = step(x0.yzx, x0.xyz);\n  \tvec3 l = 1.0 - g;\n  \tvec3 i1 = min( g.xyz, l.zxy );\n  \tvec3 i2 = max( g.xyz, l.zxy );\n\n  \t//  x0 = x0 - 0. + 0.0 * C \n  \tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  \tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  \tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n\t// Permutations\n  \ti = mod(i, 289.0 ); \n  \tvec4 p = permute( permute( permute( \n    \t              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        \t   \t\t  + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients\n\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  \tfloat n_ = 1.0/7.0; // N=7\n  \tvec3  ns = n_ * D.wyz - D.xzx;\n\n  \tvec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  \tvec4 x_ = floor(j * ns.z);\n  \tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  \tvec4 x = x_ *ns.x + ns.yyyy;\n  \tvec4 y = y_ *ns.x + ns.yyyy;\n  \tvec4 h = 1.0 - abs(x) - abs(y);\n\n  \tvec4 b0 = vec4( x.xy, y.xy );\n  \tvec4 b1 = vec4( x.zw, y.zw );\n\n  \tvec4 s0 = floor(b0)*2.0 + 1.0;\n  \tvec4 s1 = floor(b1)*2.0 + 1.0;\n  \tvec4 sh = -step(h, vec4(0.0));\n\n  \tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  \tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  \tvec3 p0 = vec3(a0.xy,h.x);\n  \tvec3 p1 = vec3(a0.zw,h.y);\n  \tvec3 p2 = vec3(a1.xy,h.z);\n  \tvec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n  \tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  \tp0 *= norm.x;\n  \tp1 *= norm.y;\n  \tp2 *= norm.z;\n  \tp3 *= norm.w;\n\n\t// Mix final noise value\n  \tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  \tm = m * m;\n  \treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                  dot(p2,x2), dot(p3,x3) ) );\n}","name":"Image","description":"","type":"image"}]}