{"ver":"0.1","info":{"id":"dlKyRw","date":"1700068718","viewed":58,"name":" Pretty Veroni","username":"codeforger","description":"A pretty veroni shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["veroni"],"hasliked":0,"parentid":"ctGcRw","parentname":"Simple Veroni"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a cheap random nuber generator\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 randCol(vec2 co) {\n    float r = rand(co)/2. + .333;\n    return vec3(\n        0,r,r\n    );\n}\n\n// Makes a point, since this is pure, it will make the same point every time (for each index)\nivec2 makePoint(int i) {\n  return ivec2(rand(vec2(i*4+1,i*4+2)) * 10000.0 - 5000.0, rand(vec2(i*4+3,i*4+4)) * 10000.0 - 5000.0);\n}\n\n\n// Distance between two points\nfloat dist(ivec2 a, ivec2 b) {\n    ivec2 c = b - a;\n    c *= c;\n    return float(sqrt(float(c.x + c.y)));\n}\n\n// wrap a point back onto the screen\nivec2 center(ivec2 a, ivec2 iRes) {\n    ivec2 c = a % iRes;\n    if (c.x < 0) { c.x += iRes.x; }\n    if (c.y < 0) { c.y += iRes.y; }\n    return c;\n}\n\nivec2 verticalClip(ivec2 point, ivec2 iRes) {\n    if(point.y < iRes.y/2) {point.y += iRes.y;}\n    else {point.y -= iRes.y;}\n    return point;\n}\n\nivec2 horizontalClip(ivec2 point, ivec2 iRes) {\n    if(point.x < iRes.x/2) {point.x += iRes.x;}\n    else {point.x -= iRes.x;}\n    return point;\n}\n\nivec2 cornerClip(ivec2 point, ivec2 iRes) {\n    return horizontalClip(verticalClip(point, iRes), iRes);\n}\n\n// Take a point, move it along its given vector for the number of frames given, then wrap it back onto the screen\nivec2 ptop(ivec2 p, ivec2 iRes, int t) {\nreturn center(p * t / 5000, iRes);\n}\n\n// given 2 points, call dist2 on them and get the difference between the results\nfloat diff(ivec2 a, ivec2 b, ivec2 uv) {\n  return abs(dist(a, uv) - dist(b, uv));\n}\n// Same as above, but can take vec2 instead of ivec2\nfloat diff(vec2 a, vec2 b, ivec2 uv) {\n  return diff(ivec2(a), ivec2(b), uv);\n}\nconst int pointCount = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int t = iFrame + 1000;\n    // get co-ords as ints, making the % math easier\n    ivec2 iRes = ivec2(iResolution);\n    ivec2 iResBounds = ivec2(iResolution) / 2;\n    ivec2 uv = ivec2(fragCoord);\n\n    // our output color\n    vec3 col = vec3(0,0,0);\n    \n    bool isDot = false;\n    bool isBorder = false;\n    int pointI = -1;\n    \n    // find the closet two points, and the distance to them\n    vec3 closest = vec3(0.0,0.0,1000000.0);\n    vec3 second = vec3(0.0,0.0,1000000.0);\n    for(int i=0;i<pointCount;++i)\n    {\n        ivec2 point = ptop(makePoint(i), iRes, t);\n        ivec2 flipped = point;\n        bool hasFlipped = false;\n        \n        // the the point is more than half the screen away, its closer on the other side,\n        // flip it over to be outside the box on 'our side'.\n        // This allows the veroni to wrap, and prevents 'jumps' when a point crosses the border\n        if(abs(uv.x - flipped.x) > iResBounds.x) {\n            if (uv.x < iResBounds.x){flipped.x -= iRes.x;}\n            else {flipped.x += iRes.x;}\n            hasFlipped = true;\n        }\n        // if we are in oposite corners, both flips are needed, so no else here\n        if(abs(uv.y - flipped.y) > iResBounds.y) {\n            if (uv.y < iResBounds.y){flipped.y -= iRes.y;}\n            else {flipped.y += iRes.y;}\n            hasFlipped = true;\n        }\n\n        float d = dist(point, uv);\n         \n        // record the distances if its closer that all existing points\n        if(d < closest.z) { second = closest; closest = vec3(point, d); pointI = i; }\n        else if (d < second.z) { second = vec3(point, d); }\n        \n        if (hasFlipped) {\n            d = dist(flipped, uv);\n\n            // record the distances if its closer that all existing points\n            if(d < closest.z) { second = closest; closest = vec3(flipped, d); pointI = i; }\n            else if (d < second.z) { second = vec3(flipped, d); }\n        }\n        \n        \n        \n    }\n    \n   \n    // if the current pixes is on top of a point, draw it green\n    if (closest.z < 10.0) {\n        isDot = true;\n    }\n    \n    // get the difference in distances to these points\n    float diff = diff(closest.xy, second.xy, uv);\n    \n    // If the difference is low enough, this pixel must be a border between two cells, draw it red\n    if (diff < (dist(ivec2(closest.xy), ivec2(second.xy)))/(closest.z + second.z)){ \n        isBorder = true;\n    }\n    \n    col = randCol(vec2(pointI, pointI)) * (diff/60.);\n    \n    // debug: Add these to draw points and borders\n    //if (isDot) {\n    //    col.y = 1. * abs(1.- closest.z/10.);\n    //} else if (isBorder) {\n    //    col.x = 1.;\n    //}\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}