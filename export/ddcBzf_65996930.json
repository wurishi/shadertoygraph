{"ver":"0.1","info":{"id":"ddcBzf","date":"1697647600","viewed":33,"name":"3D Template (TOPHAT)","username":"WhiteTophat","description":"Starting point for quick 3D creations","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 origin = vec3(-10, 0, 0);\nfloat zoom = 1.0;\n\nvoid render( out vec4 fragColor, in vec2 fragCoord, vec3 dir ) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 cam;\n    bool hit;\n    vec3 p;\n    vec4 color;\n    vec4 lightColor;\n    raymarch(origin, dir, iTime, uv, zoom, cam, p, hit, color);\n    //bool isShadow = shadows(p, iTime);\n    if (hit) {\n        vec3 norm = calcNorm(p, iTime);\n        //fragColor = isShadow ? vec4(0) : vec4(lighting(p,iTime, normalize(getlightdir(p, norm, iTime)), iChannel0));\n        fragColor = vec4(lighting(p,iTime, normalize(getlightdir(p, norm, iTime)), iChannel0));\n    }\n    else {\n        skybox(cam, fragColor);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render( fragColor, fragCoord, vec3(iMouse.x / 50.0, 0.0, 0.0) );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Table of Contents\n//   1 | Constants\n//   2 | Scene Functions\n//   3 | Shape Functions\n//   4 | Event Functions <--- scene() located here\n\n// 1) Constants\n#define FAR_CLIP 120.0\n#define NEAR_CLIP 0.3\n#define MAX_STEPS 100\n#define PI 3.1415925359\n// 2) Scene Functions\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat dot2( vec3 v ) { return dot(v,v); }\nconst vec2 size = vec2(2.0,0.0);\nconst ivec3 off = ivec3(-1,0,1);\nfloat super(vec3 x) {\n    return sqrt(length(x*x));\n}\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat smin(float a, float b, float k) {\n    float h = max (0.0, k - abs(b - a)) / k;\n    return min(a, b) - h * h * h * k / 6.0;\n}\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\nvec3 world2Local(vec3 p, vec3 origin) {\n    return p - origin;\n}\n\n// 3) Shape Functions\nfloat torus(vec3 p, float r1, float r2) {\n    return length(vec2(length(p.xz)-r1, p.y)) - r2;\n}\nfloat box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat roundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat line( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat plane( vec3 p, vec4 n ) {\n  // n must be normalized\n  return dot(p,normalize(n).xyz) + normalize(n).w;\n}\nfloat hexPrism(vec3 p, vec2 h) {\n  vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat triPrism( vec3 p, vec2 h ) {\n    float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat cone( vec3 p, float h, float r1, float r2 ) {\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat cone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax+cay*cay*baba, cbx*cbx+cby*cby*baba) );\n}\nfloat pyramid(vec3 p, float h) {\n  float m2 = h*h + 0.25;\n     \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n \n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n    \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n     \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n     \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n     \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\nfloat hourglass(vec3 p, float h, float r1, float r2) {\n    return smin(cone(p, h, r1, r2), cone(p, h, r2, r1), 0.1);\n}\n\n// 4) Event Functions\n//  - Called when the main light source is needed, returns the direction of the light.\nvec3 getlightdir(vec3 p, vec3 n, float t) {\n    return normalize(vec3(1, 1, 1));\n}\n//  - Called when the distance to the nearest object is needed, returns said distance.\nvoid scene(vec3 p, float t, out float dist, out vec4 color) {\n    vec3 p2 = abs(erot(p - vec3(0, 0, 0.4), vec3(1, 0, 0), radians(45.0)));\n    p2.yz = vec2(-smin(-p2.y, -p2.z, 0.1), smin(p2.y, p2.z, 0.1));\n    float flooring = box(p+vec3(0,0,2), vec3(10,10,0));\n    float wall1 = box(p+vec3(0,10,0), vec3(10,0,5));\n    float wall2 = box(p-vec3(0,10,0), vec3(10,0,5));\n    float wall3 = box(p+vec3(10,0,0), vec3(0,10,5));\n    float wall4 = box(p-vec3(10,0,0), vec3(0,10,5));\n    dist = min(flooring, min(wall1,min(wall2,min(wall3,wall4))));\n    if (dist == flooring) {\n    \n    } else if (dist == wall1) {\n    \n    } else if (dist == wall2) {\n    \n    } else if (dist == wall3) {\n    \n    } else if (dist == wall4) {\n    \n    }\n}\n//  - Called when no object is rendered at a pixel\nvoid skybox(vec3 dir, out vec4 color) {\n    color = vec4(normalize(dir), 1.0);\n}\n\n//------------------------------------\n// Internal Stuff\nfloat lighting(vec3 normal, vec3 lightDir) {\n    float shade = dot(normalize(lightDir), normal);\n    return clamp(shade + 0.4, 0.1, 1.0);\n}\nfloat scene(vec3 p, float t) {\n    float d;\n    vec4 col;\n    scene(p, t, d, col);\n    return d;\n}\nvec3 pow3(vec3 a, vec3 b) {\n    return vec3(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));\n}\nvec3 pow3(vec3 a, float b) {\n    return vec3(pow(a.x, b), pow(a.y, b), pow(a.z, b));\n}\nvoid manualRaymarch(vec3 origin, vec3 dir, float t, out vec3 rayDir, out vec3 point, out bool didHit, out vec4 color) {\n    vec3 p = origin;\n    bool hit = false;\n    vec4 col = vec4(0);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist;\n        scene(p, t, dist, col);\n        hit = dist * dist < 1e-6;\n        p += normalize(dir) * dist;\n        if (distance(p, origin) > FAR_CLIP || distance(p, origin) < NEAR_CLIP) break;\n    }\n    rayDir = dir;\n    point = p;\n    didHit = hit;\n    color = col;\n}\nvoid raymarch(vec3 origin, vec3 dir, float t, vec2 uv, float zoom, out vec3 rayDir, out vec3 point, out bool didHit, out vec4 color) {\n    vec3 cam = normalize(vec3(1.0, uv));\n    vec3 init = origin/2.;\n    \n    float xrot = dir.z;\n    float yrot = dir.y;\n    float zrot = dir.x;\n    if (xrot != 0.0) cam = erot(cam, vec3(1, 0, 0), xrot);\n    if (yrot != 0.0) cam = erot(cam, vec3(0, 1, 0), yrot);\n    if (zrot != 0.0) cam = erot(cam, vec3(0, 0, 1), zrot);\n    if (xrot != 0.0) init = erot(init, vec3(1, 0, 0), xrot);\n    if (yrot != 0.0) init = erot(init, vec3(0, 1, 0), yrot);\n    if (zrot != 0.0) init = erot(init, vec3(0, 0, 1), zrot);\n    \n    manualRaymarch(init, cam, t, rayDir, point, didHit, color);\n}\nvec3 calcNorm(vec3 p, float t) {\n    mat3 k = mat3(p, p, p) - mat3(0.01);\n    return normalize(scene(p,t) - vec3(scene(k[0],t), scene(k[1],t), scene(k[2],t)));\n}\nvec3 getlightdir(vec3 p, float t) {\n    return getlightdir(p, calcNorm(p,t),t);\n}\nbool shadows(vec3 p, float t) {\n    vec3 lightdir = getlightdir(p, t);\n    vec3 rd;\n    vec3 po;\n    bool hit;\n    vec4 col;\n    manualRaymarch(p+(calcNorm(p, t)/3.), lightdir, t, rd, po, hit, col);\n    return hit;\n}\nvec2 uv3D(vec3 p, vec3 n) {\n    vec2 uv = vec2(0);\n    \n    vec2 uvXZ = p.xz * 0.5 + 0.5;\n    vec2 uvYZ = p.yz * 0.5 + 0.5;\n    vec2 uvXY = p.xy * 0.5 + 0.5;\n    \n    n = abs(n);\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n    \n    uv = uvYZ * n.x + uvXZ * n.y + uvXY * n.z;\n    return uv;\n}\nfloat grayscale(vec3 source) {\n    return (source.x + source.y + source.z) / 3.0;\n}\nfloat grayscale(vec2 source) {\n    return (source.x + source.y) / 2.0;\n}\nfloat grayscale(vec4 source) {\n    return grayscale(source.xyz);\n}\nvec3 normalFromHeightmap(sampler2D heightmap, vec2 uv) {\n    vec4 wave = texture(heightmap, uv);\n    float s11 = wave.x;\n    float s01 = grayscale(textureOffset(heightmap, uv, off.xy));\n    float s21 = grayscale(textureOffset(heightmap, uv, off.zy));\n    float s10 = grayscale(textureOffset(heightmap, uv, off.yx));\n    float s12 = grayscale(textureOffset(heightmap, uv, off.yz));\n    vec3 va = normalize(vec3(size.xy, s21-s01));\n    vec3 vb = normalize(vec3(size.yx, s12-s10));\n    vec4 bump = vec4( cross(va, vb), s11 );\n    return normalize(bump.xyz);\n}\nvec3 calcNorm(vec3 p, float t, sampler2D heightmap) {\n    vec3 norm = calcNorm(p,t);\n    vec2 uv = uv3D(p, norm);\n    return mix(norm, normalFromHeightmap(heightmap, uv), 0.5);\n}\nfloat lighting(vec3 p, float t, vec3 lightDir, sampler2D heightmap) {\n    vec3 norm = calcNorm(p, t, heightmap);\n    return lighting(norm, lightDir);\n}\nvec4 texture3D(vec3 p, float t, sampler2D sampler, sampler2D heightmap, bool affectedByLight, bool useHeightmap) {\n    vec3 col = vec3(0);\n    vec3 n = calcNorm(p,t);\n    vec3 lightNorm = mix(n, normalFromHeightmap(heightmap, uv3D(p, n)), 0.5);\n    \n    vec3 colXZ = texture(sampler, p.xz * 0.5 + 0.5).rgb;\n    vec3 colYZ = texture(sampler, p.yz * 0.5 + 0.5).rgb;\n    vec3 colXY = texture(sampler, p.xy * 0.5 + 0.5).rgb;\n    \n    n = abs(n);\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n    \n    col = colYZ * n.x + colXZ * n.y + colXY * n.z;\n    if (affectedByLight) col *= clamp(lighting(lightNorm, getlightdir(p,t)), 0.1, 1.0);\n    \n    return vec4(col, 1.0);\n}\nvec4 texture3D(vec3 p, float t, sampler2D sampler, sampler2D heightmap) {\n    return texture3D(p,t, sampler, heightmap, true, true);\n}\nvec4 texture3D(vec3 p, float t, sampler2D sampler) {\n    return texture3D(p,t, sampler, sampler, true, false);\n}","name":"Common","description":"","type":"common"}]}