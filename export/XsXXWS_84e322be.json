{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Mandelbulb Explained\n// open source under the http://opensource.org/licenses/BSD-2-Clause license\n// by Morgan McGuire, http://graphics-codex.com\n\n// Set to 1 to lower quality and increase speed\n#define FAST 0\n\n#define Color4 vec4\n#define Color3 vec3\n#define Point3 vec3\n#define Vector3 vec3\n\n////////////////////////////////////////////////////////////\n// Scene configuration:\n\n// = normalize(+1, +1, -1)\nconst Vector3 lightDirection = Point3(0.57735026919, 0.57735026919, -0.57735026919);\n\nconst Color3 keyLightColor  = Color3(1.0, 1.0, 1.0);\nconst Color3 fillLightColor = Color3(0.0, 0.2, 0.7);\n\nconst Color3 backgroundGradientCenterColor = Color3(0.9, 0.9, 0.9);\nconst Color3 backgroundGradientRimColor = Color3(0.5, 0.3, 0.1);\n\nconst float cameraDistance = 5.0;\n\n////////////////////////////////////////////////////////////\n// Algorithm options:\n\n// A point this close to the surface is considered to be on the surface.\n// Larger numbers lead to faster convergence but \"blur\" out the shape\nconst float minimumDistanceToSurface = 0.0003;\n\n// Higher is more complex and fills holes\nconst int ITERATIONS = \n#\tif FAST\n\t\t10;\n#\telse\n\t\t16;\n#\tendif\n\n// Larger is slower but more accurate and fills holes\nconst int RAY_MARCH_ITERATIONS = \n#\tif FAST\n\t\t100;\n#\telse\n\t\t150;\n#\tendif\n\n// Different values give different shapes; 8.0 is the \"standard\" bulb\nconst float power = 8.0;\n\n// A small step, used for computing the surface normal\n// by numerical differentiation. A scaled up version of\n// this is also used for computing a low-frequency gradient.\nconst Vector3 eps = Vector3(minimumDistanceToSurface * 5.0, 0.0, 0.0);\n\n// Orientation of the object\nmat3 rotation;\n\n////////////////////////////////////////////////////////////\n\n// AO = scale surface brightness by this value. 0 = deep valley, 1 = high ridge\nfloat distanceToSurface(Point3 P, out float AO) {\n\t// Rotate the query point into the reference frame of the function\n\tP = rotation * P;\n\tAO = 1.0;\n\t\n\t// Sample distance function for a sphere:\n\t// return length(P) - 1.0;\n\t\n\t// Unit rounded box (https://iquilezles.org/articles/distfunctions)\n\t//return length(max(abs(P) - 1.0, 0.0)) - 0.1;\t\n\t\n\t// This is a 3D analog of the 2D Mandelbrot set. Altering the mandlebulbExponent\n\t// affects the shape.\n\t// See the equation at\n\t// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\t\n\tPoint3 Q = P;\n\t\n\t// Put the whole shape in a bounding sphere to \n\t// speed up distant ray marching. This is necessary\n\t// to ensure that we don't expend all ray march iterations\n\t// before even approaching the surface\n\t{\n\t\tconst float externalBoundingRadius = 1.2;\n\t\tfloat r = length(P) - externalBoundingRadius;\n\t\t// If we're more than 1 unit away from the\n\t\t// surface, return that distance\n\t\tif (r > 1.0) { return r; }\n\t}\n\n\t// Embed a sphere within the fractal to fill in holes under low iteration counts\n\tconst float internalBoundingRadius = 0.72;\n\n\t// Used to smooth discrete iterations into continuous distance field\n\t// (similar to the trick used for coloring the Mandelbrot set)\t\n\tfloat derivative = 1.0;\n\t\n\tfor (int i = 0; i < ITERATIONS; ++i) {\n\t\t// Darken as we go deeper\n\t\tAO *= 0.725;\n\t\tfloat r = length(Q);\n\t\t\n\t\tif (r > 2.0) {\t\n\t\t\t// The point escaped. Remap AO for more brightness and return\n\t\t\tAO = min((AO + 0.075) * 4.1, 1.0);\n\t\t\treturn min(length(P) - internalBoundingRadius, 0.5 * log(r) * r / derivative);\n\t\t} else {\t\t\n\t\t\t// Convert to polar coordinates and then rotate by the power\n\t\t\tfloat theta = acos(Q.z / r) * power;\n\t\t\tfloat phi   = atan(Q.y, Q.x) * power;\t\t\t\n\t\t\t\n\t\t\t// Update the derivative\n\t\t\tderivative = pow(r, power - 1.0) * power * derivative + 1.0;\n\t\t\t\n\t\t\t// Convert back to Cartesian coordinates and \n\t\t\t// offset by the original point (which we're orbiting)\n\t\t\tfloat sinTheta = sin(theta);\n\t\t\t\n\t\t\tQ = Vector3(sinTheta * cos(phi),\n\t\t\t\t\t    sinTheta * sin(phi),\n\t\t\t\t\t    cos(theta)) * pow(r, power) + P;\n\t\t}\t\t\t\n\t}\n\t\n\t// Never escaped, so either already in the set...or a complete miss\n\treturn minimumDistanceToSurface;\n}\n\n\nfloat distanceToSurface(Point3 P) {\n\tfloat ignore;\n\treturn distanceToSurface(P, ignore);\n}\n\n\nColor3 trace(vec2 coord) {\n\tfloat zoom = pow(200.0, -cos(iTime * 0.2) + 1.0);\n\t\n\tPoint3 rayOrigin = Point3(2.0 * coord / iResolution.xy - 1.0, -cameraDistance);\n\n\t// Correct for aspect ratio\n\trayOrigin.x *= iResolution.x / iResolution.y;\n\t\n\tVector3 rayDirection = normalize(normalize(Point3(0.0, 0.0, 1.0) - rayOrigin) + 0.2 * Point3(rayOrigin.xy, 0.0) / zoom);\n\n\t// Distance from ray origin to hit point\n\tfloat t = 0.0;\n\t\n\t// Point on (technically, near) the surface of the Mandelbulb\n\tPoint3 X;\n\n\tbool hit = false;\n\tfloat d;\n\n\t// March along the ray, detecting when we are very close to the surface\n\tfor (int i = 0; i < RAY_MARCH_ITERATIONS; ++i) {\t\t\t\t\t\t\n\t\tX = rayOrigin + rayDirection * t;\n\t\t\n\t\td = distanceToSurface(X);\n\t\thit = (d < minimumDistanceToSurface);\n\t\tif (hit) { break; }\n\t\t\n\t\t// Advance along the ray by the worst-case distance to the\n\t\t// surface in any direction\n\t\tt += d;\n\t}\n\n\tColor3 color;\t\n\tif (hit) {\n\t\t// Compute AO term\n\t\tfloat AO;\n\t\tdistanceToSurface(X, AO);\n\t\t\t\t\n\t\t// Back away from the surface a bit before computing the gradient\n\t\tX -= rayDirection * eps.x;\n\t\t\t\t\n\t\t// Accurate micro-normal\n  \t\tVector3 n = normalize(\n\t\t\tVector3(d - distanceToSurface(X - eps.xyz),\n\t  \t\t        d - distanceToSurface(X - eps.yxz),\n\t  \t\t\t    d - distanceToSurface(X - eps.zyx)));\n\t\t\n\t\t// Broad scale normal to large shape\n  \t\tVector3 n2 = normalize(\n\t\t\tVector3(d - distanceToSurface(X - eps.xyz * 50.0),\n\t  \t\t        d - distanceToSurface(X - eps.yxz * 50.0),\n\t  \t\t\t    d - distanceToSurface(X - eps.zyx * 50.0)));\n\n\t\t// Bend the local surface normal by the\n\t\t// gross local shape normal and the bounding sphere\n\t\t// normal to avoid the hyper-detailed look\n\t\tn = normalize(n + n2 + normalize(X));\n\n\t\t// Fade between the key and fill light based on the normal (Gooch-style wrap shading).\n\t\t// Also darken the surface in cracks (on top of the AO term)\n\t\treturn AO * mix(fillLightColor, keyLightColor, AO * clamp(0.7 * dot(lightDirection, n) + 0.6, 0.0, 1.0)) +\n   \t\t\t   // Give the feel of blowing out the highlights with a yellow tint\n\t\t\t   AO * pow(max(dot(lightDirection, n2), 0.0), 5.0) * Color3(1.3, 1.2, 0.0);\n\t} else {\n\t\t// No hit: return the background gradient\t\t\n\t\treturn mix(backgroundGradientCenterColor, backgroundGradientRimColor, sqrt(length((coord / iResolution.xy - vec2(0.66, 0.66)) * 2.5)));\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Euler-angle animated rotation\t\n\tfloat pitch = sin(iTime * 0.2);\n\tfloat yaw   = cos(iTime * 0.3);\n\trotation    = mat3(1.0, 0.0, 0.0, 0.0, cos(pitch), -sin(pitch), 0.0, sin(pitch), cos(pitch)) *\n\t              mat3(cos(yaw), 0.0, sin(yaw), 0.0, 1.0, 0.0, -sin(yaw), 0.0, cos(yaw));\n\n\tColor3 color = \n#\t\tif FAST\n\t\t\t// Single sample for speed\n\t\t\ttrace(fragCoord.xy);\n#\t\telse\n         \t// 4x rotated-grid SSAA for antialiasing\n\t\t\t(trace(fragCoord.xy + vec2(-0.125, -0.375)) + \n\t\t\t trace(fragCoord.xy + vec2(+0.375, -0.125)) + \n\t\t\t trace(fragCoord.xy + vec2(+0.125, +0.375)) +\n\t\t\t trace(fragCoord.xy + vec2(-0.375, +0.125))) / 4.0;\n#\t\tendif\n\t\n\t// Coarse RGB->sRGB encoding via sqrt\n\tcolor = sqrt(color);\n\t\n\t// Vignetting (from iq https://www.shadertoy.com/view/MdX3Rr)\n\tvec2 xy = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tcolor *= 0.5 + 0.5*pow((xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.2);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsXXWS","date":"1406088283","viewed":4280,"name":"Mandelbulb Deconstructed","username":"morgan3d","description":"This is a fractal distance estimator implementation of Mandelbulb power-8 designed for readability. Set FAST to 1 for a ~6x speedup. Thanks to emin for https://www.shadertoy.com/view/XsfGR8 which introduced me to the fractal.","likes":57,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raymarch","mandelbulb","comments"],"hasliked":0,"parentid":"","parentname":""}}