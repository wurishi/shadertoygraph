{"ver":"0.1","info":{"id":"wdlGz8","date":"1545010149","viewed":1931,"name":"Card game in the single shader","username":"morimea","description":"Original \"single GLSL\" [url]https://www.shadertoy.com/view/3sX3zN[/url]\n[b]WARNING:[/b] compile time with Angle [b]very long[/b] \nturn off angle(windows) to launch\n[b]chrome.exe --use-angle=gl[/b]\n\n[b]read my comment below[/b] about launching and other","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["2d","game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// self https://www.shadertoy.com/view/wdlGz8\n\n\n// !!!!!!!!!!!!!!!!!!!\n// TO COMPILE in COMMON delete #define NOCOMPILE\n\n\n#define texture(a,b) textureLod(a,b,0.0)\n\n#ifdef NOCOMPILE\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define res (iResolution.xy / iResolution.y)\n\nconst vec3 gc= vec3(0x38, 0x38, 0x38) / float(0xff);\nconst vec3 wc= vec3(0xfc, 0xfc, 0xfc) / float(0xff);\nconst vec3 gc2= vec3(0x47, 0x47, 0x47) / float(0xff);\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat pattern_bg(vec2 p){\n    float d=0.;\n    p=vec2(mod(p.x+0.01*(floor((mod(p.y,0.04)-0.02)/0.02)),0.02)-0.01,mod(p.y,0.02)-0.01);\n    d=SS(-0.001,0.001,sdCircle(p,0.0035));\n    return d;\n}\n\nvec3 gr_bg(vec2 p){\n    vec3 col=mix(gc2,wc,SS(0.,0.2,abs(mod(p.x-0.2,.4)-0.2)));\n    col=mix(0.2*col,wc,SS(0.,0.3,abs(mod(p.x+0.1,.6)-0.3)));\n    return col;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 main_c_bg(vec2 p){\n    vec3 col=vec3(0.);\n    float d=pattern_bg(p);\n    col=mix(vec3(0.),gc,d);\n    float vignetteAmt = 1.-dot(p,p);\n    col *= vignetteAmt;\n    col += (rand(p)-.5)*.07;\n    col*=SS(-0.04,0.1,abs(abs(p.y)-.3));\n    col=mix(col,sqrt(gr_bg(p)*(1.-SS(-0.04,0.1,abs(abs(p.y)-.3)))),-step(0.3+0.002,abs(p.y))+step(0.3-0.002,abs(p.y)));\n    return vec4(col,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    col =col+(1.-col.r)*main_c_bg(fragCoord/iResolution.y-res/2.).rgb;\n    fragColor = vec4(col,1.0);\n}\n\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    fragColor = vec4(col,1.0);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/wdlGz8\n\n// using https://iquilezles.org/articles/distfunctions2d\n// using https://www.shadertoy.com/view/llyXRW\n// using https://www.shadertoy.com/view/ldKyW1\n\n// this is just \"demo\"\n// this is not \"universal UI/game engine\" this is fast code only for that game/demo\n// number cards in hand, its animation and many other thinks are hard coded(no way to change them(without very hard editing))(adding new cards/mechanics also complicated), faster for you will be rewrite the logic by you own\n\n// have fun xD\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI (4.0 * atan(1.0))\n#define TAU (2.*PI)\n#define E exp(1.)\n#define res (iResolution.xy / iResolution.y)\n\n#define texture(a,b) textureLod(a,b,0.0)\n\nstruct allData_struc {\n    float cards_player; //num of cards in player hand\n    float card_select_anim; //time of start card select animation\n    float card_add_anim; //time of start card add animation\n    vec2 mouse_pos;\n    float this_selected_card; //hand card selection\n    float last_selected_card; //hand card selection\n    float card_put_anim; //card put to board from hand\n    float card_hID_put_anim; //used only for animation removing card from hand\n    float card_bID_put_anim; //last putted card on board\n    float flag1;\n    float flag0;\n    vec2 player_hpmp;\n    vec2 en_hpmp;\n    float flag3;\n    float egt; //end game timer\n    float card_draw; //draw X cards\n    bool player_turn;\n    float ett; //end turn timer\n    bool player_etf; //used for \"cards on board hit other side\"\n    bool en_etf; //same\n};\n\nallData_struc allData;\n\nconst vec3 blue = vec3(0x90, 0xbb, 0xe4) / float(0xff);\nconst vec3 green = vec3(0x7f, 0xbe, 0x20) / float(0xff);\nconst vec3 purple = vec3(0x9e, 0x75, 0xaf) / float(0xff);\nconst vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 red = vec3(0xa6, 0x36, 0x2c) / float(0xff);\nconst vec3 redw = vec3(0xfd, 0x8c, 0x77) / float(0xff);\nconst vec3 sand = vec3(0xe9, 0xdf, 0xc3) / float(0xff);\nconst vec3 gc = vec3(0x38, 0x38, 0x38) / float(0xff);\nconst vec3 wc = vec3(0xfc, 0xfc, 0xfc) / float(0xff);\nconst vec3 gc2 = vec3(0x47, 0x47, 0x47) / float(0xff);\n\nfloat zv;\nvec2 res_g;\n\n// start time from extime value sec, for timers\n#define extime 15.\nfloat g_time;\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n    p = abs(p);\n    float b = sqrt(r * r - d * d);\n    return ((p.y - b) * d > p.x * b)\n            ? length(p - vec2(0.0, b))\n            : length(p - vec2(-d, 0.0)) - r;\n}\n\nfloat ndot(vec2 a, vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(in vec2 p, in vec2 b) {\n    vec2 q = abs(p);\n    float h = clamp((-2.0 * ndot(q, b) + ndot(b, b)) / dot(b, b), -1.0, 1.0);\n    float d = length(q - 0.5 * b * vec2(1.0 - h, 1.0 + h));\n    return d * sign(q.x * b.y + q.y * b.x - b.x * b.y);\n}\n\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n    float resa = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p * p*p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t) * t;\n        resa = dot(qos, qos);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t.x) * t.x;\n        resa = dot(qos, qos);\n        qos = d + (c + b * t.y) * t.y;\n        resa = min(resa, dot(qos, qos));\n        qos = d + (c + b * t.z) * t.z;\n        resa = min(resa, dot(qos, qos));\n    }\n    return sqrt(resa);\n}\n\nfloat sdTriangleIsosceles(in vec2 q, in vec2 p) {\n    p.y -= 0.5;\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n            vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat board(vec2 p) {\n    float d = 0.;\n    d = SS(0., zv, sdBox(p, vec2(0.6, 0.3)));\n    return d;\n}\n\nfloat card_shadow(vec2 p) {\n    float d = 0.;\n    d = SS(-0.01, 0.02 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat card(vec2 p) {\n    float d = 0.;\n    d = SS(0., 0.0 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat hp_s(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.06, 0.01));\n    d = SS(0., 0.0 + zv, d);\n    return d;\n}\n\nfloat hp_s2(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.045, 0.015));\n    d = SS(0., 0.0 + zv, d - 0.03);\n    return d;\n}\n\nfloat hp_s3(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.015, 0.001));\n    d = SS(-0.001, 0.008, d);\n    return d;\n}\n\nfloat get_animstate(float timeval) {\n    return SS(0., 1., timeval);\n}\n\nconst vec3 cw2 = vec3(0xf8, 0xf9, 0xfb) / float(0xff);\nconst vec3 cb2 = vec3(0x1c, 0x25, 0x36) / float(0xff);\nconst vec3 cr2 = vec3(0xe3, 0x6b, 0x7e) / float(0xff);\nconst vec3 cr3 = vec3(0xec, 0xd0, 0x6a) / float(0xff);\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.1)));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = (sqrt(3.) - 1.) / 2.;\n    const float K2 = (3. - sqrt(3.)) / 6.;\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n    return dot(n, vec3(50.0));\n}\n\nfloat fbm(vec2 uv) {\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float f = 0.5000 * noise(uv);\n    uv = m*uv;\n    f += 0.2500 * noise(uv);\n    uv = m*uv;\n    f += 0.1250 * noise(uv);\n    uv = m*uv;\n    f += 0.0625 * noise(uv);\n    uv = m*uv;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\nfloat card_fbg(vec2 p) {\n    float tx = g_time / 2.;\n    float nx = abs(noise(p + vec2(tx * 0.5)));\n    nx += 0.5 * abs(noise((p + vec2(-tx * 0.25, tx * 0.25)) * 2.0));\n    nx += 0.25 * abs(noise((p + vec2(tx * 0.15, -tx * 0.15)) * 4.0));\n    nx += 0.125 * abs(noise((p + vec2(-tx * 0.05, -tx * 0.05)) * 8.0));\n    return nx;\n}\n\nvec3 card_nbg(vec2 p, float tv) {\n    float _s = sign(p.y) * (200.0 + (tv * 0.051));\n    float l = p.y;\n    p.y = mod(abs(p.y), 2.50);\n    p.x += _s + pow(p.y, -1.002);\n    vec3 xx = vec3(fbm(p - vec2(0.0, tv * 0.0485)));\n    float s = 3.75;\n    float m = pow(xx.x, p.y * s) + .05;\n    if (l < 0.0) {\n        m *= 0.3;\n    }\n    vec3 color = mix((m / blue), (m / sand), clamp(sin(tv / 20.) - cos(tv / 20.), 0., 1.));\n    return clamp(color, vec3(0.), vec3(1.));\n}\n\nconst vec3 cef1a = vec3(0x69, 0x64, 0x7e) / float(0xff);\nconst vec3 cef1b = vec3(0xd8, 0x79, 0x8b) / float(0xff);\nconst vec3 cef2b = vec3(0x1b, 0x5f, 0x41) / float(0xff);\nconst vec3 cef3a = vec3(0x82, 0x9d, 0xa9) / float(0xff);\nconst vec3 cef4a = vec3(0xe6, 0x73, 0x00) / float(0xff);\nconst vec3 cef6a = vec3(0xb3, 0x24, 0x00) / float(0xff);\nconst vec3 cef7a = vec3(0x33, 0x33, 0xcc) / float(0xff);\nconst vec3 cef7b = vec3(0x66, 0x99, 0xff) / float(0xff);\nconst vec3 cef8a = vec3(0x99, 0x00, 0xcc) / float(0xff);\nconst vec3 cef9a = vec3(0x00, 0x33, 0x00) / float(0xff);\n\n\n// to load card pixels only when we need it without reading 20 pixels for every pixel, if use it in load_state\n\nvec4 load_card(int idx) {\n    ivec2 id = ivec2(0, idx) ;\n    return texelFetch(iChannel0, (id) , 0  );\n}\n\nvec4 load_card2(int idx) {\n    ivec2 id = ivec2(1, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\n\n#define c_bgr -1\n#define c_cr 0\n#define c_cr2 1\n#define c_cr3 2\n#define c_at1 3\n#define c_at2 4\n#define c_he1 5\n#define c_he2 6\n#define c_pat 7\n#define c_mn 8\n#define c_de 9\n\nvec3 decodeval(float colz) {\n    vec3 retc = vec3(0.);\n    retc.x = floor(floor(colz) / 10000.) - 1.;\n    retc.y = floor((-(retc.x + 1.)*10000. + floor(colz)) / 100.) - 1.;\n    retc.z = floor(-(retc.y + 1.)*100. - (retc.x + 1.)*10000. + floor(colz)) - 1.;\n    return retc;\n}\n\nfloat encodeval(vec3 colz) {\n    return floor(colz.r)*10000. + 10000. + floor(colz.g)*100. + 100. + floor(colz.b) + 1.;\n}\n\nvec3 decodecol(float colz) {\n    return decodeval(colz) / 98.;\n}\n\nfloat encodecol(vec3 colz) {\n    return encodeval(colz * 98.);\n}\n\nbool is_c_cr(int ix) {\n    return (ix - 3) < 0; // used only for cards in hand, they have not c_bgr(-1)\n    //return ((ix==c_cr)||(ix==c_cr2)||(ix==c_cr3));\n}\n\nfloat is_c_crf(int ix) {\n    return clamp(float(ix - 2), 0., 1.);\n}\n\nbool is_o_crf(int ix) {\n    return (((ix == c_de) || (ix == c_mn) || (ix == c_pat)));\n}\n\nfloat is_h_crf(int ix) {\n    return (((ix == c_at1) || (ix == c_at2)) ? 0. : 1.);\n}\n\nbool is_H_crf(int ix) {\n    return ((ix == c_he1) || (ix == c_he2));\n}\n\nfloat is_v_crf(int ix) {\n    return 1. - clamp(float(ix - 7), 0., 1.);\n}\n\nfloat is_d_crf(int ix) {\n    return clamp(float(ix - 8), 0., 1.);\n}\n\n// same as load_card logic\n\nvec4 load_board(int idx) {\n    ivec2 id = ivec2(3, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_board2(int idx) {\n    ivec2 id = ivec2(4, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_eff_buf() {\n    ivec2 id = ivec2(2, 3) ;\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nint card_baord_id(vec2 p) {\n    return int(floor((p.x + 0.18 * 3.) / 0.18));\n}\n\nint hpmp_get_hit(vec2 p) {\n    if ((allData.player_etf) || (allData.player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\nint card_get_hit(vec2 p) {\n    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), abs(p.y - 0.02) - 0.125 - zv / 2.);\n    float d = card(pt);\n    bool bv = (p.y - 0.02 < 0.);\n    d = max(d, step(0.18 * 3. + zv / 2., abs(p.x)));\n    if (d < 1.)return bv ? card_baord_id(p) : 10 + card_baord_id(p);\n    return -1;\n}\n\nint turnctrl_get_hit(vec2 p) {\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));\n    float d = SS(0., zv, sdBox(pt, vec2(0.04, 0.008)) - 0.02);\n    if (d < 1.)return 1;\n    return -1;\n}\n\nvoid card_get_select(vec2 p) {\n    float d = 1.;\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    const float angle_pos = 0.045;\n    allData.this_selected_card = -1.;\n    float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n    float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 6.5), 0., 1.));\n    if ((allData.card_draw > 0.) || (anim_t > 0.) || (allData.player_etf) || ((anim_t2zb == 0.)&&(!allData.player_turn)&&(!allData.en_etf)))return;\n    float anim_t2z = get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    if (allData.player_turn)p.y += 0.08 * (1. - anim_t2z);\n    else p.y += 0.08 * (anim_t2z);\n    for (float i = float(min(0,iFrame)); i < allData.cards_player + 1.; i++) {\n        if (i + 1. > allData.cards_player) {\n            break;\n        }\n        if (i + 2. > allData.cards_player) {\n            float tv = 0.5 - (allData.cards_player - (allData.cards_player / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv * (1. - anim_t)) - shift_pos * tv * (1. - anim_t) + vec2(sp_pos.x, 0.) * anim_t);\n        } else {\n            float ad = allData.cards_player - 1. * (anim_t);\n            float tv = 0.5 - (ad - (ad / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv) - shift_pos * tv);\n        }\n        if ((d < 1.)) {\n            allData.this_selected_card = i;\n        }\n    }\n    return;\n}\n\nfloat zoom_calc(float zv) {\n    float ex = 0.0025 * ((1080. * zv) / (iResolution.y));\n    return ex;\n}\n\nvoid init_globals() {\n    zv = zoom_calc(1.);\n    res_g = res;\n    g_time = iTime + extime;\n}\n\nvec2 click_control() {\n    return abs(iMouse.zw) / iResolution.y - res_g / 2.0;\n}\n\nfloat get_card_col(int id) {\n    if (id == c_cr) {\n        return encodecol(cb2);\n    }\n    if (id == c_at1) {\n        return encodecol(cef1b);\n    }\n    if (id == c_he1) {\n        return encodecol(green);\n    }\n    if (id == c_cr2) {\n        return encodecol(cef3a);\n    }\n    if (id == c_cr3) {\n        return encodecol(vec3(0.));\n    }\n    if (id == c_de) {\n        return encodecol(cef4a);\n    }\n    if (id == c_at2) {\n        return encodecol(cef6a);\n    }\n    if (id == c_he2) {\n        return encodecol(cef9a);\n    }\n    if (id == c_mn) {\n        return encodecol(cef8a);\n    }\n    if (id == c_pat) {\n        return encodecol(cef7a);\n    }\n    return encodecol(vec3(0.));\n}\n\nvec4 draw_cardx(float id, bool tp) {\n    int cid = int(10. * rand(vec2(10. - g_time, 5. + 2. * id + g_time)));\n    //balance\n    //he1 he2 pat\n    float val = encodeval(vec3(floor(1. + 14. * rand(vec2(g_time, id + g_time))), floor(1. + 14. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 14. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));\n    if (tp)if (cid == c_mn)cid = c_he2; //do not draw \"draw\" card for AI\n    //other types\n    if (cid == c_he2)val = encodeval(vec3(floor(1. + 25. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));\n    if (cid == c_at2)val = encodeval(vec3(floor(5. + 10. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));\n    if (cid == c_at1)val = encodeval(vec3(floor(1. + 10. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));\n    if (cid == c_cr)val = encodeval(vec3(floor(1. + 6. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));\n    if (cid == c_cr2)val = encodeval(vec3(floor(1. + 6. * rand(vec2(g_time, id + g_time))), floor(1. + 14. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(5. + 10. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));\n    if (cid == c_cr3)val = encodeval(vec3(floor(1. + 6. * rand(vec2(g_time, id + g_time))), floor(5. + 15. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));\n    return vec4(val, 0., get_card_col(cid), float(cid));\n}\n\nvec4 update_state(vec4 tc, vec4 tcc2) {\n    if (int(tc.w) != c_bgr) {\n        if (int(tcc2.w) != c_bgr) {\n            vec3 crvals = decodeval(tc.x);\n            vec3 crvalsx = decodeval(tcc2.x);\n            if (int(tc.y) != 1) {\n                crvals.y -= crvalsx.z;\n                if (crvals.y <= 0.) {\n                    tc.y = -g_time;\n                    crvals.y = 0.;\n                }\n            }\n            float rexf = encodeval(crvals);\n            tc.x = rexf;\n        }\n        if (int(tc.y) == 1) tc.y = 0.;\n    }\n    return tc;\n}\n\n//the enemy/AI logic\n\nvec2 en_turn_logic(vec4 card1_val, vec4 card2_val) {\n    float r1 = -100.;\n    float r2 = -100.;\n    vec3 efhpat1 = decodeval(card1_val.x); // order [EF,HP,AT]\n    vec3 efhpat2 = decodeval(card2_val.x);\n    bool isde = false;\n    // cast creature, include check for HP and AT(put this creature against other that HP<=this AT(or ...))\n    if (is_c_cr(int(card2_val.w))) {\n        float firstnbg = -1.;\n        float firstencr = -1.;\n        for (int i = min(0,iFrame); i < 6; i++) {\n            vec4 tcr2 = load_board2(i);\n            vec4 tcr = load_board(i);\n            tcr2 = update_state(tcr2, tcr); //because same frame creatures destroyed\n            if (tcr2.y < 0.)tcr2.w = float(c_bgr);\n            if (int(tcr2.w) == c_bgr) {\n                if (firstnbg < 0.)firstnbg = float(i);\n                if (int(tcr.w) != c_bgr) {\n                    if (firstencr < 0.)firstencr = float(i);\n                    vec2 thpat = decodeval(tcr.x).yz;\n                    if (thpat.x - efhpat2.z <= 0.) {\n                        r2 = float(i);\n                        break;\n                    }\n                    if (efhpat2.y - thpat.y > 0.) {\n                        r2 = float(i);\n                    }\n                }\n            }\n        }\n        if (r2 < 0.) {\n            if (firstnbg >= 0.)r2 = firstnbg; //put card to first empty background slot\n            if (firstencr >= 0.)r2 = firstencr; //put card against enemy creature, even if it this creature die\n        }\n        if (r2 >= 0.)r2 += 10.;\n    } else {\n        //cast spells\n        //AT\n        if (int(card2_val.w) == c_at2) {\n            r2 = -6. - 1.;\n        }\n        //HE\n        if (int(card2_val.w) == c_he2) {\n            r2 = -16. - 1.;\n        }\n        //de\n        if (int(card2_val.w) == c_de) {\n            //slect creature with hightest AT and HP to cast on it\n            float latmax = 0.;\n            float lhpmax = 0.;\n            int lix = -1;\n            for (int i = min(0,iFrame); i < 6; i++) {\n                vec4 tcr = load_board(i);\n                if (int(tcr.w) != c_bgr) {\n                    vec2 thpat = decodeval(tcr.x).yz;\n                    if (thpat.y >= latmax) {\n                        if (thpat.x >= lhpmax) {\n                            latmax = thpat.y;\n                            lhpmax = thpat.x;\n                            lix = i;\n                        } else if (lix < 0) {\n                            latmax = thpat.y;\n                            lix = i;\n                        }\n                    }\n                }\n            }\n            if (lix >= 0)r2 = -float(lix) - 1.;\n        }\n        //at\n        if (int(card2_val.w) == c_at1) {\n            //slect creature (HP-this AT)=0 or with hightest AT\n            float latmax = 0.;\n            int lix = -1;\n            int lkk = -1;\n            for (int i = min(0,iFrame); i < 6; i++) {\n                vec4 tcr = load_board(i);\n                if ((int(tcr.w) != c_bgr)&&(int(tcr.y) != 1)) {\n                    vec2 thpat = decodeval(tcr.x).yz;\n                    if (thpat.x - efhpat2.x <= 0.) {\n                        lkk = i;\n                        isde = true;\n                        break;\n                    }\n                    if (thpat.y >= latmax) {\n                        latmax = thpat.y;\n                        lix = i;\n                    }\n                }\n            }\n            if (lix >= 0)r2 = -float(lix) - 1.;\n            if (lkk >= 0)r2 = -float(lkk) - 1.;\n        }\n        //pat\n        if (int(card2_val.w) == c_pat) {\n            //slect creature with hightest AT and free lane, or creature wit AT<other side creature_HP\n            int lix = -1;\n            int lkk = -1;\n            float latmax = 0.;\n            float latmaxo = 0.;\n            for (int i = min(0,iFrame); i < 6; i++) {\n                vec4 tcr2 = load_board2(i);\n                vec4 tcr = load_board(i);\n                tcr2 = update_state(tcr2, tcr);\n                if (tcr2.y < 0.)tcr2.w = float(c_bgr);\n                if (int(tcr2.w) != c_bgr) {\n\n                    lix = i;\n                    if (int(tcr.w) == c_bgr) {\n                        vec2 thpat2 = decodeval(tcr2.x).yz;\n                        if (thpat2.y >= latmaxo) {\n                            lkk = i;\n                            latmaxo = thpat2.y;\n                        }\n                    }\n                    if ((int(tcr.w) != c_bgr)&&(int(tcr.y) != 1)) {\n                        vec2 thpat = decodeval(tcr.x).yz;\n                        vec2 thpat2 = decodeval(tcr2.x).yz;\n                        if ((thpat.x - thpat2.y > 0.)&&(thpat.y >= latmax)) {\n                            lix = i;\n                            latmax = thpat.y;\n                        }\n                    }\n                }\n            }\n            if (lix >= 0)r2 = -float(lix) - 1. - 10.;\n            if (lkk >= 0)r2 = -float(lkk) - 1. - 10.;\n        }\n        //he\n        if (int(card2_val.w) == c_he1) {\n            //slect creature with lowest hp\n            float lhpmi = 98.;\n            int lix = -1;\n            for (int i = min(0,iFrame); i < 6; i++) {\n                vec4 tcr2 = load_board2(i);\n                vec4 tcr = load_board(i);\n                tcr2 = update_state(tcr2, tcr);\n                if (tcr2.y < 0.)tcr2.w = float(c_bgr);\n                if (int(tcr2.w) != c_bgr) {\n                    vec2 thpat = decodeval(tcr2.x).yz;\n                    if (thpat.x <= lhpmi) {\n                        lix = i;\n                        lhpmi = thpat.x;\n                    }\n                }\n            }\n            if (lix >= 0)r2 = -float(lix) - 1. - 10.;\n        }\n\n    }\n    //almost same for second card(just include check for previus value)\n    if (is_c_cr(int(card1_val.w))) {\n        float firstnbg = -1.;\n        float firstencr = -1.;\n        bool fc = int(card2_val.w) == c_de;\n        bool fc2 = int(card2_val.w) == c_at1;\n        for (int i = min(0,iFrame); i < 6; i++) {\n            vec4 tcr2 = load_board2(i);\n            vec4 tcr = load_board(i);\n            tcr2 = update_state(tcr2, tcr);\n            if (tcr2.y < 0.)tcr2.w = float(c_bgr);\n            if (int(tcr2.w) == c_bgr) {\n                if (is_c_cr(int(card2_val.w))&&(i == int(r2 - 10.)))continue; //dont cast twice on same board id\n                if (firstnbg < 0.)firstnbg = float(i);\n                if (fc && (i == int(abs(r2) - 1.)))continue;\n                if (fc2 && isde && (i == int(abs(r2) - 1.)))continue;\n                if (int(tcr.w) != c_bgr) {\n                    if (firstencr < 0.)firstencr = float(i);\n                    vec2 thpat = decodeval(tcr.x).yz;\n                    if (thpat.x - efhpat1.z <= 0.) {\n                        r1 = float(i);\n                        break;\n                    }\n                    if (efhpat1.y - thpat.y > 0.) {\n                        r1 = float(i);\n                    }\n                }\n            }\n        }\n        if (r1 < 0.) {\n            if (firstnbg >= 0.)r1 = firstnbg;\n            if (firstencr >= 0.)r1 = firstencr;\n        }\n        if (r1 >= 0.)r1 += 10.;\n    } else {\n        if (int(card1_val.w) == c_at2) {\n            r1 = -6. - 1.;\n        }\n        if (int(card1_val.w) == c_he2) {\n            r1 = -16. - 1.;\n        }\n        if (int(card1_val.w) == c_de) {\n            bool fc = int(card2_val.w) == c_de; //dont cast twice\n            bool fc2 = int(card2_val.w) == c_at1; //check if it already removed\n            float latmax = 0.;\n            float lhpmax = 0.;\n            int lix = -1;\n            for (int i = min(0,iFrame); i < 6; i++) {\n                float thpxx = 0.;\n                if (fc && (i == int(abs(r2) - 1.)))continue;\n                if (fc2 && isde && (i == int(abs(r2) - 1.)))continue;\n                if (fc2 && (i == int(abs(r2) - 1.)))thpxx -= efhpat2.x;\n                vec4 tcr = load_board(i);\n                if (int(tcr.w) != c_bgr) {\n                    vec2 thpat = decodeval(tcr.x).yz;\n                    if (thpat.y >= latmax) {\n                        if (thpat.x + thpxx >= lhpmax) {\n                            latmax = thpat.y;\n                            lhpmax = thpat.x + thpxx;\n                            lix = i;\n                        } else if (lix < 0) {\n                            latmax = thpat.y;\n                            lix = i;\n                        }\n                    }\n                }\n            }\n            if (lix >= 0)r1 = -float(lix) - 1.;\n        }\n        if (int(card1_val.w) == c_at1) {\n            bool fc = int(card2_val.w) == c_de; //check if it already removed\n            bool fc2 = int(card2_val.w) == c_at1; //check if it already removed\n            float latmax = 0.;\n            int lix = -1;\n            int lkk = -1;\n            for (int i = min(0,iFrame); i < 6; i++) {\n                float thpxx = 0.;\n                if (fc && (i == int(abs(r2) - 1.)))continue;\n                if (fc2 && isde && (i == int(abs(r2) - 1.)))continue;\n                if (fc2 && (i == int(abs(r2) - 1.)))thpxx -= efhpat2.x;\n                vec4 tcr = load_board(i);\n                if ((int(tcr.w) != c_bgr)&&(int(tcr.y) != 1)) {\n                    vec2 thpat = decodeval(tcr.x).yz;\n                    if (thpat.x - thpxx - efhpat1.x <= 0.) {\n                        lkk = i;\n                        isde = true;\n                        break;\n                    }\n                    if (thpat.y >= latmax) {\n                        latmax = thpat.y;\n                        lix = i;\n                    }\n                }\n            }\n            if (lix >= 0)r1 = -float(lix) - 1.;\n            if (lkk >= 0)r1 = -float(lkk) - 1.;\n        }\n        if (int(card1_val.w) == c_pat) {\n            int lix = -1;\n            int lkk = -1;\n            float latmax = 0.;\n            float latmaxo = 0.;\n            bool fc = int(card2_val.w) == c_pat; //dont cast twice\n            for (int i = min(0,iFrame); i < 6; i++) {\n                if (fc && (i == int(abs(r2) - 1. - 10.)))continue;\n                vec4 tcr2 = load_board2(i);\n                vec4 tcr = load_board(i);\n                tcr2 = update_state(tcr2, tcr);\n                if (tcr2.y < 0.)tcr2.w = float(c_bgr);\n                if (is_c_cr(int(card2_val.w))&&(i == int(r2 - 10.)))tcr2 = card2_val; //self(this frame caster creature) cast\n                if (int(tcr2.w) != c_bgr) {\n                    lix = i;\n                    if (int(tcr.w) == c_bgr) {\n                        vec2 thpat2 = decodeval(tcr2.x).yz;\n                        if (thpat2.y >= latmaxo) {\n                            lkk = i;\n                            latmaxo = thpat2.y;\n                        }\n                    }\n                    if ((int(tcr.w) != c_bgr)&&(int(tcr.y) != 1)) {\n                        vec2 thpat = decodeval(tcr.x).yz;\n                        vec2 thpat2 = decodeval(tcr2.x).yz;\n                        if ((thpat.x - thpat2.y > 0.)&&(thpat.y >= latmax)) {\n                            lix = i;\n                            latmax = thpat.y;\n                        }\n                    }\n                }\n            }\n            if (lix >= 0)r1 = -float(lix) - 1. - 10.;\n            if (lkk >= 0)r1 = -float(lkk) - 1. - 10.;\n        }\n        if (int(card1_val.w) == c_he1) {\n            float lhpmi = 98.;\n            int lix = -1;\n            bool fc2 = int(card2_val.w) == c_he1;\n            for (int i = min(0,iFrame); i < 6; i++) {\n                float thpxx = 0.;\n                if (fc2 && (i == int(abs(r2) - 1. - 10.)))thpxx += efhpat2.x;\n                vec4 tcr2 = load_board2(i);\n                vec4 tcr = load_board(i);\n                tcr2 = update_state(tcr2, tcr);\n                if (tcr2.y < 0.)tcr2.w = float(c_bgr);\n                if (is_c_cr(int(card2_val.w))&&(i == int(r2 - 10.)))tcr2 = card2_val; //self cast\n                if (int(tcr2.w) != c_bgr) {\n                    vec2 thpat = decodeval(tcr2.x).yz;\n                    if (thpat.x + thpxx <= lhpmi) {\n                        lix = i;\n                        lhpmi = thpat.x + thpxx;\n                    }\n                }\n            }\n            if (lix >= 0)r1 = -float(lix) - 1. - 10.;\n        }\n    }\n    return vec2(r1, r2);\n}\n\nvoid card_logic(out vec4 fragColor, in vec2 fragCoord, ivec2 ipx) {\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        float val = encodeval(vec3(float(20 + ipx.y), float(1 + ipx.y), float(10 + ipx.y)));\n        fragColor = vec4(val, 0., get_card_col(ipx.y), float(ipx.y)); //this not used\n        if (ipx == ivec2(1, 2))fragColor = vec4(-1., -1., 0., 0.);\n        return;\n    }\n    if (ipx.x == 0) {\n        if (allData.flag1 == 1.) {\n            if (int(allData.card_hID_put_anim) <= ipx.y) {\n                fragColor = load_card(ipx.y + 1);\n                return;\n            }\n            if (int(allData.card_hID_put_anim) > ipx.y) {\n                fragColor = load_card(ipx.y);\n                return;\n            }\n        }\n        float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n        float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n        if ((anim_t == 0.)&&(anim_t2 == 0.)&&(allData.card_draw > 0.)) {\n            if (ipx.y == int(allData.cards_player)) {\n                fragColor = draw_cardx(float(ipx.y), false);\n                return;\n            }\n        }\n        fragColor = load_card(ipx.y);\n        return;\n    }\n    if (ipx.x == 1) {\n        if (allData.flag3 == 0.)\n            if ((!allData.player_turn)&&(allData.en_etf)) {\n                if (ipx.y == 2) {\n                    vec4 tcc = load_card2(ipx.y);\n                    if (tcc.x < 0.) {\n                        vec4 tcc2 = load_card2(0);\n                        vec4 tcc3 = load_card2(1);\n                        float tch1 = -10.;\n                        float tch2 = -10.;\n                        float xx = -10.;\n                        if ((tcc2.x > 0.)&&(tcc3.x > 0.)) {\n                            vec2 tcx = en_turn_logic(tcc2, tcc3);\n                            tch1 = tcx.y;\n                            tch2 = tcx.x;\n                            xx = 1.;\n                        }\n                        fragColor = vec4(xx, -.1, tch1, tch2);\n                    } else fragColor = load_card2(ipx.y);\n                    return;\n                } else\n                    if (ipx.y < 2) {\n                    vec4 tcc = load_card2(ipx.y);\n                    if (tcc.x < 0.)\n                        tcc = draw_cardx(float(ipx.y), true); //draw card for en turn\n                    fragColor = tcc;\n                } else\n                    fragColor = vec4(-10.);\n                return;\n            } else\n                if ((!allData.player_turn)&&(!allData.en_etf)) {\n                vec4 tcc = load_card2(ipx.y);\n                if (ipx.y == 2) {\n                    if (floor(tcc.y) >= 0.)tcc.y = -1.;\n                    if (floor(tcc.x) >= 0.) {\n                        float anim_t2 = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * tcc.x))*2., 0., 1.));\n                        if (anim_t2 == 0.) {\n                            tcc.y = floor(tcc.x);\n                            tcc.x = floor(tcc.x) - 1.;\n                        }\n                    }\n                }\n                fragColor = tcc;\n                return;\n            } else {\n                fragColor = vec4(-10.);\n                return;\n            };\n    }\n    fragColor = vec4(0.);\n    return;\n}\n\nvoid board_logic(out vec4 fragColor, in vec2 fragCoord, ivec2 ipx) {\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        fragColor = vec4(0., 0., 0., -1.);\n        return;\n    }\n\n    if (ipx.x == 3) {\n        vec4 tc = load_board(ipx.y);\n        if (allData.flag3 == 1.) {\n            fragColor = tc;\n            return;\n        }\n        float anim_t2za = 1. - get_animstate(clamp((g_time - allData.ett - 2.), 0., 1.));\n        //work once beucase player_etf change with same timer\n        if ((allData.player_turn)&&(anim_t2za == 0.)&&(allData.player_etf)) {\n            vec4 tcc2 = load_board2(ipx.y);\n            fragColor = update_state(tc, tcc2);\n            return;\n        }\n        if ((!allData.player_turn)&&(!allData.en_etf)) {\n            vec4 tcc = load_card2(2);\n            if (floor(tcc.y) >= 0.) {\n                vec4 tcc2x = load_card2(int(tcc.y));\n                if ((int(tcc.z) < 0)&&(int(tcc.z) != -100)) {\n                    if ((int(tcc2x.w) == c_de)&&((floor(tcc.y) == 1. ? (abs(int(tcc.z)) - 1) : (abs(int(tcc.w)) - 1)) == ipx.y)) {\n                        tc.y = -g_time;\n                        fragColor = tc;\n                        return;\n                    }\n                    if ((int(tcc2x.w) == c_at1)&&((floor(tcc.y) == 1. ? (abs(int(tcc.z)) - 1) : (abs(int(tcc.w)) - 1)) == ipx.y)) {\n                        vec3 crvals = decodeval(tc.x);\n                        vec3 crvalsx = decodeval(tcc2x.x);\n                        if (int(tc.y) == 1) {\n                            fragColor = tc;\n                            return;\n                        }\n                        crvals.y -= crvalsx.x;\n                        if (crvals.y <= 0.) {\n                            tc.y = -g_time;\n                            crvals.y = 0.;\n                        }\n                        float rexf = encodeval(crvals);\n                        tc.x = rexf;\n                        fragColor = tc;\n                        return;\n                    }\n                }\n            }\n        }\n        if (allData.last_selected_card >= 0.) {\n            float anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n            if (anim_t >= 1.) {\n                if (card_get_hit(allData.mouse_pos) == ipx.y) {\n\n                    vec4 tc2 = load_card(int(allData.last_selected_card));\n                    if ((int(tc.w) == c_bgr)&&(is_c_cr(int(tc2.w)))) {\n                        fragColor = tc2;\n                        return;\n                    }\n                }\n            }\n        }\n        if (tc.y < 0.) {\n            float anim_t2 = 1. - get_animstate(clamp((g_time - (-tc.y) - 0.5)*2., 0., 1.));\n            if (anim_t2 == 0.)fragColor = vec4(0., 0., 0., -1.);\n            else fragColor = tc;\n            return;\n        }\n        if ((allData.flag1 == 1.)&&(ipx.y == int(allData.card_bID_put_anim))) {\n            vec4 tcx = load_eff_buf();\n            vec4 ctx = load_board(int(allData.card_bID_put_anim));\n            if ((int(tcx.w) == c_he1)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                vec3 crvals = decodeval(tc.x);\n                vec3 crvalsx = decodeval(tcx.x);\n                crvals.y += crvalsx.x;\n                if (crvals.y > 98.)crvals.y = 98.;\n                float rexf = encodeval(crvals);\n                tc.x = rexf;\n                fragColor = tc;\n                return;\n            }\n            if ((int(tcx.w) == c_at1)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                vec3 crvals = decodeval(tc.x);\n                vec3 crvalsx = decodeval(tcx.x);\n                if (int(tc.y) == 1) {\n                    fragColor = tc;\n                    return;\n                }\n                crvals.y -= crvalsx.x;\n                if (crvals.y <= 0.) {\n                    tc.y = -g_time;\n                    crvals.y = 0.;\n                }\n                float rexf = encodeval(crvals);\n                tc.x = rexf;\n                fragColor = tc;\n                return;\n            }\n            if ((int(tcx.w) == c_de)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                tc.y = -g_time;\n                fragColor = tc;\n                return;\n            }\n            if ((int(tcx.w) == c_pat)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                vec3 crvals = decodeval(tc.x);\n                vec3 crvalsx = decodeval(tcx.x);\n                crvals.z += crvalsx.x;\n                if (crvals.z > 98.)crvals.z = 98.;\n                float rexf = encodeval(crvals);\n                tc.x = rexf;\n                tc.y = 1.;\n                fragColor = tc;\n                return;\n            }\n\n        }\n        fragColor = tc;\n        return;\n    }\n    if (ipx.x == 4) {\n        vec4 tc2 = load_board2(ipx.y);\n        if (allData.flag3 == 1.) {\n            fragColor = tc2;\n            return;\n        }\n        float anim_t2za = 1. - get_animstate(clamp((g_time - allData.ett - 2.), 0., 1.));\n        if ((!allData.player_turn)&&(anim_t2za == 0.)&&(allData.en_etf)) {\n            vec4 tcc2 = load_board(ipx.y);\n            fragColor = update_state(tc2, tcc2);\n            ;\n            return;\n        }\n        if ((!allData.player_turn)&&(!allData.en_etf)) {\n            vec4 tcc = load_card2(2);\n            if (floor(tcc.y) >= 0.) {\n                vec4 tcc2x = load_card2(int(tcc.y));\n                if ((is_c_cr(int(tcc2x.w)))&&((floor(tcc.y) == 1. ? (int(tcc.z) - 10) : (int(tcc.w) - 10)) == ipx.y)) {\n                    tc2 = tcc2x;\n                }\n                if (((int(tcc2x.w) == c_pat)&&(floor(tcc.y) == 1. ? (abs(int(tcc.z)) - 10 - 1) : (abs(int(tcc.w)) - 10 - 1)) == ipx.y)) {\n                    vec3 crvals = decodeval(tc2.x);\n                    vec3 crvalsx = decodeval(tcc2x.x);\n                    crvals.z += crvalsx.x;\n                    if (crvals.z > 98.)crvals.z = 98.;\n                    float rexf = encodeval(crvals);\n                    tc2.x = rexf;\n                    tc2.y = 1.;\n                    fragColor = tc2;\n                }\n                if (((int(tcc2x.w) == c_he1)&&(floor(tcc.y) == 1. ? (abs(int(tcc.z)) - 10 - 1) : (abs(int(tcc.w)) - 10 - 1)) == ipx.y)) {\n                    vec3 crvals = decodeval(tc2.x);\n                    vec3 crvalsx = decodeval(tcc2x.x);\n                    crvals.y += crvalsx.x;\n                    if (crvals.y > 98.)crvals.y = 98.;\n                    float rexf = encodeval(crvals);\n                    tc2.x = rexf;\n                    fragColor = tc2;\n                }\n            }\n        }\n\n        if (tc2.y < 0.) {\n            float anim_t2 = 1. - get_animstate(clamp((g_time - (-tc2.y) - 0.5)*2., 0., 1.));\n            if (anim_t2 == 0.)fragColor = vec4(0., 0., 0., -1.);\n            else fragColor = tc2;\n            return;\n        }\n        if ((allData.flag1 == 1.)&&(ipx.y == int(allData.card_bID_put_anim) - 10)) {\n            vec4 tcx = load_eff_buf();\n            vec4 ctx = load_board2(int(allData.card_bID_put_anim) - 10);\n            if ((int(tcx.w) == c_he1)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                vec3 crvals = decodeval(tc2.x);\n                vec3 crvalsx = decodeval(tcx.x);\n                crvals.y += crvalsx.x;\n                if (crvals.y > 98.)crvals.y = 98.;\n                float rexf = encodeval(crvals);\n                tc2.x = rexf;\n                fragColor = tc2;\n                return;\n            }\n            if ((int(tcx.w) == c_at1)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                vec3 crvals = decodeval(tc2.x);\n                vec3 crvalsx = decodeval(tcx.x);\n                if (int(tc2.y) == 1) {\n                    fragColor = tc2;\n                    return;\n                }\n                crvals.y -= crvalsx.x;\n                if (crvals.y <= 0.) {\n                    tc2.y = -g_time;\n                    crvals.y = 0.;\n                }\n                float rexf = encodeval(crvals);\n                tc2.x = rexf;\n                fragColor = tc2;\n                return;\n            }\n            if ((int(tcx.w) == c_de)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                tc2.y = -g_time;\n                fragColor = tc2;\n                return;\n            }\n            if ((int(tcx.w) == c_pat)&&(is_c_cr(int(ctx.w)))&&(int(ctx.w) != c_bgr)) {\n                vec3 crvals = decodeval(tc2.x);\n                vec3 crvalsx = decodeval(tcx.x);\n                crvals.z += crvalsx.x;\n                if (crvals.z > 98.)crvals.z = 98.;\n                float rexf = encodeval(crvals);\n                tc2.x = rexf;\n                tc2.y = 1.;\n                fragColor = tc2;\n                return;\n            }\n        }\n        fragColor = tc2;\n        return;\n    }\n    fragColor = vec4(0., 0., 0., -1.);\n    return;\n\n}\n\nvoid effect_buf_logic(out vec4 fragColor, in vec2 fragCoord, ivec2 ipx) {\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        fragColor = vec4(0., 0., 0., -1.);\n        return;\n    }\n    vec4 retx = vec4(0., 0., 0., -1.);\n    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n    if (anim_t2 > 0.) {\n        retx = load_eff_buf();\n    }\n\n    if (allData.last_selected_card >= 0.) {\n        float anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n        if (anim_t >= 1.) {\n            if (card_get_hit(allData.mouse_pos) >= 0) {\n                vec4 tc = load_board((card_get_hit(allData.mouse_pos) > 9 ? card_get_hit(allData.mouse_pos) - 10 : card_get_hit(allData.mouse_pos)));\n                vec4 tc2 = load_card(int(allData.last_selected_card));\n                if ((is_c_cr(int(tc.w)))&&(!is_c_cr(int(tc2.w))))\n                    fragColor = tc2;\n                else\n                    fragColor = retx;\n                return;\n            }\n            if (hpmp_get_hit(allData.mouse_pos) > 0) {\n                vec4 tc2 = load_card(int(allData.last_selected_card));\n                fragColor = tc2;\n                return;\n            }\n        }\n    }\n    fragColor = retx;\n    return;\n}\n\nfloat get_smhp() {\n    float retv = 0.;\n    for (int j = 0; j < 10; j++) {\n        vec4 card_vals = load_board(j);\n        vec4 card_vals2 = load_board2(j);\n        if ((int(card_vals.w) != c_bgr)&&(int(card_vals2.w) == c_bgr)) {\n            vec3 crvals = decodeval(card_vals.x);\n            retv += crvals.z;\n        }\n    }\n    return retv;\n}\n\nfloat get_smhp2() {\n    float retv = 0.;\n    for (int j = 0; j < 10; j++) {\n        vec4 card_vals = load_board2(j);\n        vec4 card_vals2 = load_board(j);\n        if ((int(card_vals.w) != c_bgr)&&(int(card_vals2.w) == c_bgr)) {\n            vec3 crvals = decodeval(card_vals.x);\n            retv += crvals.z;\n        }\n    }\n    return retv;\n}\n\nvoid hpmp_logic(out vec4 fragColor, in vec2 fragCoord, ivec2 ipx) {\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        fragColor = vec4(encodeval(vec3(0., 80., 2.)), encodeval(vec3(0., 80., 0.)), -1., 0.);\n        return;\n    }\n    float gegt = allData.egt;\n    float player_etfl = allData.player_etf ? 1. : 0.;\n    float en_etfl = allData.en_etf ? 1. : 0.;\n    if (allData.player_turn)allData.en_hpmp.y = 0.;\n    else allData.player_hpmp.y = 0.;\n    float tpt = allData.ett;\n    if (allData.player_turn)tpt = -tpt;\n    if ((turnctrl_get_hit(allData.mouse_pos) > 0)&&(!allData.player_etf)) {\n        if (allData.player_turn) {\n            tpt = g_time;\n            allData.en_hpmp.y = 2.;\n            en_etfl = 1.;\n        }\n    }\n    if ((!allData.player_turn)&&(!allData.en_etf)) {\n        vec4 tc2 = load_card2(2);\n        allData.en_hpmp.y = tc2.x;\n        if (allData.en_hpmp.y < 0.)allData.en_hpmp.y = 0.;\n    }\n    if ((!allData.player_turn)&&(allData.flag3 == 0.)&&(allData.en_etf)) {\n        gegt = get_smhp();\n        if (gegt > 98.)gegt = 98.;\n    }\n    if ((allData.player_turn)&&(allData.flag3 == 0.)&&(allData.player_etf)) {\n        gegt = get_smhp2();\n        if (gegt > 98.)gegt = 98.;\n    }\n    // enemy turn logic\n    if ((!allData.player_turn)&&(!allData.en_etf)) {\n        float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 7.), 0., 1.)); // (7-2)=5 sec for enemy turn\n        if (anim_t2zb == 0.) {\n            tpt = -g_time;\n            allData.player_hpmp.y = 2.;\n            player_etfl = 1.;\n        }\n        vec4 tcc = load_card2(2);\n        if (floor(tcc.y) >= 0.) {\n            vec4 tcc2x = load_card2(int(tcc.y));\n            if (int(tcc2x.w) == c_at2) {\n                vec3 crvalsx = decodeval(tcc2x.x);\n                float thpv = allData.player_hpmp.x - crvalsx.x;\n                float egtx = 0.;\n                if (thpv < 1.) {\n                    thpv = 0.;\n                    egtx = g_time;\n                };\n                fragColor = vec4(encodeval(vec3(player_etfl, thpv, allData.player_hpmp.y)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, egtx);\n                return;\n            }\n            if (int(tcc2x.w) == c_he2) {\n                vec3 crvalsx = decodeval(tcc2x.x);\n                float thpv = allData.en_hpmp.x + crvalsx.x;\n                if (thpv > 98.)thpv = 98.;\n                fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp)), encodeval(vec3(en_etfl, thpv, allData.en_hpmp.y)), tpt, gegt);\n                return;\n            }\n\n        }\n        fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, gegt);\n        return;\n    }\n    // en cards->player cards\n    if ((allData.player_turn)&&(allData.player_etf)) {\n        float anim_t2zc = 1. - get_animstate(clamp((g_time - allData.ett - 2.), 0., 1.)); //3 sec for board hit animation\n        if (anim_t2zc == 0.) {\n            player_etfl = 0.;\n            float thpv = allData.player_hpmp.x;\n            thpv += -get_smhp2();\n            float egtx = 0.;\n            if (thpv < 1.) {\n                thpv = 0.;\n                egtx = g_time;\n            };\n            fragColor = vec4(encodeval(vec3(player_etfl, thpv, allData.player_hpmp.y)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, egtx);\n            return;\n        }\n        fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, gegt);\n        return;\n    }\n    // player cards->en_cards\n    if ((!allData.player_turn)&&(allData.en_etf)) {\n        float anim_t2za = 1. - get_animstate(clamp((g_time - allData.ett - 2.), 0., 1.)); //3 sec for board hit animation\n        if (anim_t2za == 0.) {\n            en_etfl = 0.;\n            float thpv = allData.en_hpmp.x;\n            thpv += -get_smhp();\n            float egtx = 0.;\n            if (thpv < 1.) {\n                thpv = 0.;\n                egtx = g_time;\n            };\n            fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp)), encodeval(vec3(en_etfl, thpv, allData.en_hpmp.y)), tpt, egtx);\n            return;\n        }\n        fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, gegt);\n        return;\n    }\n    if ((allData.flag1 == 1.)) {\n        vec4 tcx = load_eff_buf();\n        if (allData.card_bID_put_anim == 6.)\n            if ((int(tcx.w) == c_he2)) {\n                vec3 crvalsx = decodeval(tcx.x);\n                float thpv = allData.player_hpmp.x + crvalsx.x;\n                if (thpv > 98.)thpv = 98.;\n                float tmpv = allData.player_hpmp.y - 1.;\n                if (tmpv < 0.)tmpv = 0.;\n                fragColor = vec4(encodeval(vec3(player_etfl, thpv, tmpv)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, gegt);\n                return;\n            }\n        if (allData.card_bID_put_anim == 16.)\n            if ((int(tcx.w) == c_at2)) {\n                vec3 crvalsx = decodeval(tcx.x);\n                float thpv = allData.en_hpmp.x - crvalsx.x;\n                float egtx = 0.;\n                if (thpv < 1.) {\n                    thpv = 0.;\n                    egtx = g_time;\n                };\n                float tmpv = allData.player_hpmp.y - 1.;\n                if (tmpv < 0.)tmpv = 0.;\n                fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp.x, tmpv)), encodeval(vec3(en_etfl, thpv, allData.en_hpmp.y)), tpt, egtx);\n                return;\n            }\n    }\n    if (allData.flag1 == 1.) {\n        float tmpv = allData.player_hpmp.y - 1.;\n        if (tmpv < 0.)tmpv = 0.;\n        fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp.x, tmpv)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, gegt);\n        return;\n    }\n    fragColor = vec4(encodeval(vec3(player_etfl, allData.player_hpmp)), encodeval(vec3(en_etfl, allData.en_hpmp)), tpt, gegt);\n    return;\n}\n\n//fix 2020\nint hpmp_get_hit_preinit(vec2 p, bool player_etf) {\n    if ((player_etf) || (player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\n// load last state\n\nvoid load_state(in vec2 fragCoord, bool ctrl) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 px = texelFetch(iChannel0, ivec2(2, 0), 0);\n    float cards_player = floor(px.x);\n    float flag0 = floor(px.y);\n    float cards_player_atime = (px.z);\n    float cards_player_select = floor(px.w);\n    px = texelFetch(iChannel0, ivec2(2, 2), 0);\n    float card_put_anim = (px.x);\n    float card_hID_put_anim = floor(px.y);\n    float card_bID_put_anim = floor(px.z);\n    float flag1 = floor(px.w);\n    vec2 click_pos = vec2(0.);\n    float card_select_anim=0.;\n    px = texelFetch(iChannel0, ivec2(2, 4), 0);\n    vec3 tvg = decodeval(px.x);\n    vec2 player_hpmp = tvg.yz;\n    bool player_etf = tvg.x == 1.;\n    tvg = decodeval(px.y);\n    vec2 en_hpmp = tvg.yz;\n    bool en_etf = tvg.x == 1.;\n    float ett = px.z;\n    bool player_turn = ett < 0.;\n    ett = abs(ett);\n    float flag3 = 0.;\n    float egt = px.w;\n    if ((flag0 != 1.) || (g_time < extime + 0.1)) {\n        egt = 0.;\n    } else {\n        if (player_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n        if (en_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n    }\n    if ((iMouse.z > 0.)&&(ctrl)) {\n        float anim_t2 = 1. - get_animstate(clamp((g_time - card_put_anim - 0.5)*2., 0., 1.));\n        float anim_t = get_animstate(clamp(1. - (g_time - cards_player_atime), 0., 1.));\n        if ((flag3 == 0.)&&(anim_t == 0.)&&(anim_t2 == 0.)) { //do not update mouse if anim played\n            click_pos = click_control();\n            if ((player_hpmp.y > 0.)&&((card_get_hit(click_pos) >= 0) || (hpmp_get_hit_preinit(click_pos,player_etf) > 0))) {\n                px = texelFetch(iChannel0, ivec2(2, 1), 0);\n                card_select_anim = px.z;\n            } else card_select_anim = g_time;\n        } else {\n            card_select_anim = g_time;\n        }\n    } else {\n        px = texelFetch(iChannel0, ivec2(2, 1), 0);\n        card_select_anim = px.z;\n        click_pos = px.xy;\n    }\n    px = texelFetch(iChannel0, ivec2(2, 1), 0);\n    float card_draw = floor(px.w);\n    if(flag3==1.)card_draw=0.;\n    allData = allData_struc(cards_player, card_select_anim, cards_player_atime, click_pos, -1., cards_player_select, card_put_anim, card_hID_put_anim, card_bID_put_anim, flag1, flag0,\n            player_hpmp, en_hpmp, flag3, egt, card_draw, player_turn, ett, player_etf, en_etf);\n}\n\n\n// save state used pixels, to [0-5,0-10]\n// pixel [0,0-9] <x> player cards player\n// <y> 0 to 9 is card (10 cards)\n\n// pixel [1,0-2] other side hand  <y> 0-1 two cards for this turn on opponent\n// <y>=2 (x num of cards to draw left, y last state of x, z where to put first, w where to put second)\n\n// card pixel values vec4[(EF/HP/AT) as float, ST, COL, ID] EF its effect value if card is not creature\n// ID its card ID\n// COL card background color\n// ST card state(effect on card, like freezed/has shield/any other mechanic) (ST<0. for card destroy animation, ST>0 1/2/3/etc index of state)\n\n// pixel [2,0]\n// vec4[cards in player hand, Flag0, time player card added anim, mouse selected card]\n// Flag0 signal(0/1) if this launched\n\n// pixel [2,1]\n// vec4[last iMouse.zw, time when card selected, draw control]\n\n// pixel [2,2]\n// vec4[time card to board anim, ID on hand, ID in board, Flag1]\n// Flag1 signal(0/1) if need to remove card from hand on this frame(once) for cards in hand array\n\n// pixel [2,3]\n// pixel values vec4[EF/HP/AT, ST, COL, ID]\n// used to save \"last played effect card\"\n\n// pixel [2,4]\n// vec4[encodeval(ETF, Plyer HP, player Manna), encodeval(ETF, Enemy HP, Enemy Manna),player turn,egt]\n// player turn +-g_time,time when End clicked +- player/opponent turn\n// egt=end game time, also used to save -hp value(number) on \"cardhit animation\" when game not ended\n// ETF=flag for both hp, (1/0) if \"end turn -hp\" animation is done (to make it work once)\n\n// pixel <x> 3 to 4 is card on board(3 is player, 4 other side), <y> 0 to 5 is card\n// pixel values vec4[EF/HP/AT, ST, COL, ID]\n\nbool save_state(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 ipx = ivec2(fragCoord - 0.5);\n    if (max(ipx.x + 5, ipx.y) > 10)return false;\n    load_state(fragCoord, true);\n    float cards_player = allData.cards_player;\n    if (ipx == ivec2(2, 0)) {\n        if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n            cards_player = 0.;\n            fragColor = vec4(cards_player, 1., g_time, allData.this_selected_card);\n            return true;\n        }\n        float stx = allData.egt + 01.;\n        if ((iMouse.z > 0.)&&(1. == SS(stx + 02.5, stx + 2. + 02.5, g_time))&&(allData.flag3 > 0.)) {\n            cards_player = 0.;\n            fragColor = vec4(cards_player, 0., g_time, allData.this_selected_card);\n            return true;\n        }\n        if (allData.flag1 == 1.)cards_player += -1.;\n        else {\n            float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n            if ((allData.card_draw > 0.)&&(anim_t2 == 0.)) {\n                float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n                if (anim_t == 0.) {\n                    cards_player += 1.;\n                    if (cards_player > 10.)cards_player = 10.;\n                }\n            }\n        }\n        card_get_select(allData.mouse_pos);\n        if (cards_player > allData.cards_player)\n            fragColor = vec4(cards_player, 1., g_time, allData.this_selected_card);\n        else\n            if (cards_player < allData.cards_player)\n            fragColor = vec4(cards_player, 1., allData.card_add_anim, allData.this_selected_card);\n        else\n            fragColor = vec4(allData.cards_player, 1., allData.card_add_anim, allData.this_selected_card);\n        return true;\n    }\n    if (ipx == ivec2(2, 1)) {\n        float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n        float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n        float cdr = allData.card_draw;\n        if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n            cdr = 8.; //draw X cards for players on start\n        } else\n            if ((anim_t == 0.)&&(anim_t2 == 0.)) {\n            cdr += -1.;\n            if (cdr < 0.)cdr = 0.;\n        }\n        if ((cdr == 0.)&&(allData.flag1 == 1.)) {\n            vec4 tcx = load_eff_buf();\n            if (allData.card_bID_put_anim == 6.)\n                if ((int(tcx.w) == c_mn)) {\n                    cdr = 2.;\n                }\n        }\n        if ((allData.player_turn)&&(allData.player_etf)) {\n            float anim_t2zc = 1. - get_animstate(clamp((g_time - allData.ett - 2.), 0., 1.));\n            if (anim_t2zc == 0.) {\n                cdr = 1.;\n            }\n        }\n        //reset mouse on new card\n        if ((cdr > 0.) || (allData.flag3 == 1.) || (allData.player_etf))\n            fragColor = vec4(vec3(0.), cdr);\n        else\n            fragColor = vec4(allData.mouse_pos, allData.card_select_anim, cdr);\n        return true;\n    }\n    if (ipx == ivec2(2, 2)) {\n        if ((allData.flag0 != 1.) || (g_time < extime + 0.1) || (allData.player_etf)) {\n            fragColor = vec4(-10.);\n            return true;\n        }\n        if (allData.last_selected_card >= 0.) {\n            float anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n            if (anim_t >= 1.) {\n                if (hpmp_get_hit(allData.mouse_pos) > 0) {\n                    vec4 tc2 = load_card(int(allData.last_selected_card));\n                    if (((hpmp_get_hit(allData.mouse_pos) == 6)&&((int(tc2.w) == c_mn) || (int(tc2.w) == c_he2))) || ((hpmp_get_hit(allData.mouse_pos) == 16)&&(int(tc2.w) == c_at2))) {\n                        fragColor = vec4(g_time, allData.last_selected_card, float(hpmp_get_hit(allData.mouse_pos)), 1.);\n                    } else {\n                        fragColor = vec4(allData.card_put_anim, allData.card_hID_put_anim, allData.card_bID_put_anim, 0.);\n                    }\n                    return true;\n                }\n                if (card_get_hit(allData.mouse_pos) >= 0) {\n                    int cval = (card_get_hit(allData.mouse_pos) > 9 ? card_get_hit(allData.mouse_pos) - 10 : card_get_hit(allData.mouse_pos));\n                    vec4 tc = (card_get_hit(allData.mouse_pos) < 10) ? load_board(cval) : load_board2(cval);\n                    vec4 tc2 = load_card(int(allData.last_selected_card));\n                    if ((int(tc.w) == c_bgr)&&(is_c_cr(int(tc2.w))&&(card_get_hit(allData.mouse_pos) < 10)))\n                        fragColor = vec4(g_time, allData.last_selected_card, float(cval), 1.);\n                    else\n                        if ((int(tc.w) != c_bgr)&&(is_c_cr(int(tc.w)))&&((int(tc2.w) == c_he1) || (int(tc2.w) == c_at1) || (int(tc2.w) == c_pat) || (int(tc2.w) == c_de)))\n                        fragColor = vec4(g_time, allData.last_selected_card, float(card_get_hit(allData.mouse_pos)), 1.);\n                    else\n                        fragColor = vec4(allData.card_put_anim, allData.card_hID_put_anim, allData.card_bID_put_anim, 0.);\n                    return true;\n                }\n            }\n        }\n        fragColor = vec4(allData.card_put_anim, allData.card_hID_put_anim, allData.card_bID_put_anim, 0.);\n        return true;\n    }\n\n    if (ipx == ivec2(2, 3)) {\n        effect_buf_logic(fragColor, fragCoord, ipx);\n        return true;\n    }\n\n    if (ipx == ivec2(2, 4)) {\n        hpmp_logic(fragColor, fragCoord, ipx);\n        return true;\n    }\n\n    for (int i = min(0,iFrame); i < 2; i++)\n        for (int j = min(0,iFrame); j < 10; j++) {\n            if (ipx == ivec2(i, j)) {\n                card_logic(fragColor, fragCoord, ipx);\n                return true;\n            }\n        }\n    for (int i = 3+min(0,iFrame); i < 5; i++)\n        for (int j = min(0,iFrame); j < 6; j++) {\n            if (ipx == ivec2(i, j)) {\n                board_logic(fragColor, fragCoord, ipx);\n                return true;\n            }\n        }\n    fragColor = vec4(1.);\n\n    return true;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifdef NOCOMPILE\n    res_g = res;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res_g / 2.0;\n    float x = 0.;\n    vec3 col = vec3(0.);\n    \n    fragColor = vec4(col, 1.);\n    return;\n#else\n    init_globals();\n    if (save_state(fragColor, fragCoord))return;\n    fragColor = vec4(01.0,01.0,01.0,1.0);\n#endif\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// delete or comment to compile, only Opera can compile it with Angle On, to disable Angle\n// chrome.exe --use-angle=gl\n#define NOCOMPILE\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/wdlGz8\n\n// using https://iquilezles.org/articles/distfunctions2d\n// using https://www.shadertoy.com/view/llyXRW\n// using https://www.shadertoy.com/view/ldKyW1\n\n// this is just \"demo\"\n// this is not \"universal UI/game engine\" this is fast code only for that game/demo\n// number cards in hand, its animation and many other thinks are hard coded(no way to change them(without very hard editing))(adding new cards/mechanics also complicated), faster for you will be rewrite the logic by you own\n\n// have fun xD\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI (4.0 * atan(1.0))\n#define TAU (2.*PI)\n#define E exp(1.)\n#define res (iResolution.xy / iResolution.y)\n\n#define texture(a,b) textureLod(a,b,0.0)\n\nstruct allData_struc {\n    float cards_player; //num of cards in player hand\n    float card_select_anim; //time of start card select animation\n    float card_add_anim; //time of start card add animation\n    vec2 mouse_pos;\n    float this_selected_card; //hand card selection\n    float last_selected_card; //hand card selection\n    float card_put_anim; //card put to board from hand\n    float card_hID_put_anim; //used only for animation removing card from hand\n    float card_bID_put_anim; //last putted card on board\n    float flag1;\n    float flag0;\n    vec2 player_hpmp;\n    vec2 en_hpmp;\n    float flag3;\n    float egt; //end game timer\n    float card_draw; //draw X cards\n    bool player_turn;\n    float ett; //end turn timer\n    bool player_etf; //used for \"cards on board hit other side\"\n    bool en_etf; //same\n};\n\nallData_struc allData;\n\nconst vec3 blue = vec3(0x90, 0xbb, 0xe4) / float(0xff);\nconst vec3 green = vec3(0x7f, 0xbe, 0x20) / float(0xff);\nconst vec3 purple = vec3(0x9e, 0x75, 0xaf) / float(0xff);\nconst vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 red = vec3(0xa6, 0x36, 0x2c) / float(0xff);\nconst vec3 redw = vec3(0xfd, 0x8c, 0x77) / float(0xff);\nconst vec3 sand = vec3(0xe9, 0xdf, 0xc3) / float(0xff);\nconst vec3 gc = vec3(0x38, 0x38, 0x38) / float(0xff);\nconst vec3 wc = vec3(0xfc, 0xfc, 0xfc) / float(0xff);\nconst vec3 gc2 = vec3(0x47, 0x47, 0x47) / float(0xff);\n\nfloat zv;\nvec2 res_g;\n\n// start time from extime value sec, for timers\n#define extime 15.\nfloat g_time;\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n    p = abs(p);\n    float b = sqrt(r * r - d * d);\n    return ((p.y - b) * d > p.x * b)\n            ? length(p - vec2(0.0, b))\n            : length(p - vec2(-d, 0.0)) - r;\n}\n\nfloat ndot(vec2 a, vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(in vec2 p, in vec2 b) {\n    vec2 q = abs(p);\n    float h = clamp((-2.0 * ndot(q, b) + ndot(b, b)) / dot(b, b), -1.0, 1.0);\n    float d = length(q - 0.5 * b * vec2(1.0 - h, 1.0 + h));\n    return d * sign(q.x * b.y + q.y * b.x - b.x * b.y);\n}\n\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n    float resa = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p * p*p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t) * t;\n        resa = dot(qos, qos);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t.x) * t.x;\n        resa = dot(qos, qos);\n        qos = d + (c + b * t.y) * t.y;\n        resa = min(resa, dot(qos, qos));\n        qos = d + (c + b * t.z) * t.z;\n        resa = min(resa, dot(qos, qos));\n    }\n    return sqrt(resa);\n}\n\nfloat sdTriangleIsosceles(in vec2 q, in vec2 p) {\n    p.y -= 0.5;\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n            vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat board(vec2 p) {\n    float d = 0.;\n    d = SS(0., zv, sdBox(p, vec2(0.6, 0.3)));\n    return d;\n}\n\nfloat card_shadow(vec2 p) {\n    float d = 0.;\n    d = SS(-0.01, 0.02 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat card(vec2 p) {\n    float d = 0.;\n    d = SS(0., 0.0 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat hp_s(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.06, 0.01));\n    d = SS(0., 0.0 + zv, d);\n    return d;\n}\n\nfloat hp_s2(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.045, 0.015));\n    d = SS(0., 0.0 + zv, d - 0.03);\n    return d;\n}\n\nfloat hp_s3(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.015, 0.001));\n    d = SS(-0.001, 0.008, d);\n    return d;\n}\n\nfloat get_animstate(float timeval) {\n    return SS(0., 1., timeval);\n}\n\nconst vec3 cw2 = vec3(0xf8, 0xf9, 0xfb) / float(0xff);\nconst vec3 cb2 = vec3(0x1c, 0x25, 0x36) / float(0xff);\nconst vec3 cr2 = vec3(0xe3, 0x6b, 0x7e) / float(0xff);\nconst vec3 cr3 = vec3(0xec, 0xd0, 0x6a) / float(0xff);\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.1)));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = (sqrt(3.) - 1.) / 2.;\n    const float K2 = (3. - sqrt(3.)) / 6.;\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n    return dot(n, vec3(50.0));\n}\n\nfloat fbm(vec2 uv) {\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float f = 0.5000 * noise(uv);\n    uv = m*uv;\n    f += 0.2500 * noise(uv);\n    uv = m*uv;\n    f += 0.1250 * noise(uv);\n    uv = m*uv;\n    f += 0.0625 * noise(uv);\n    uv = m*uv;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\nfloat card_fbg(vec2 p) {\n    float tx = g_time / 2.;\n    float nx = abs(noise(p + vec2(tx * 0.5)));\n    nx += 0.5 * abs(noise((p + vec2(-tx * 0.25, tx * 0.25)) * 2.0));\n    nx += 0.25 * abs(noise((p + vec2(tx * 0.15, -tx * 0.15)) * 4.0));\n    nx += 0.125 * abs(noise((p + vec2(-tx * 0.05, -tx * 0.05)) * 8.0));\n    return nx;\n}\n\nvec3 card_nbg(vec2 p, float tv) {\n    float _s = sign(p.y) * (200.0 + (tv * 0.051));\n    float l = p.y;\n    p.y = mod(abs(p.y), 2.50);\n    p.x += _s + pow(p.y, -1.002);\n    vec3 xx = vec3(fbm(p - vec2(0.0, tv * 0.0485)));\n    float s = 3.75;\n    float m = pow(xx.x, p.y * s) + .05;\n    if (l < 0.0) {\n        m *= 0.3;\n    }\n    vec3 color = mix((m / blue), (m / sand), clamp(sin(tv / 20.) - cos(tv / 20.), 0., 1.));\n    return clamp(color, vec3(0.), vec3(1.));\n}\n\nconst vec3 cef1a = vec3(0x69, 0x64, 0x7e) / float(0xff);\nconst vec3 cef1b = vec3(0xd8, 0x79, 0x8b) / float(0xff);\nconst vec3 cef2b = vec3(0x1b, 0x5f, 0x41) / float(0xff);\nconst vec3 cef3a = vec3(0x82, 0x9d, 0xa9) / float(0xff);\nconst vec3 cef4a = vec3(0xe6, 0x73, 0x00) / float(0xff);\nconst vec3 cef6a = vec3(0xb3, 0x24, 0x00) / float(0xff);\nconst vec3 cef7a = vec3(0x33, 0x33, 0xcc) / float(0xff);\nconst vec3 cef7b = vec3(0x66, 0x99, 0xff) / float(0xff);\nconst vec3 cef8a = vec3(0x99, 0x00, 0xcc) / float(0xff);\nconst vec3 cef9a = vec3(0x00, 0x33, 0x00) / float(0xff);\n\nfloat text_hp(vec2 U) {\n    initMsg;C(72);C(80);C(58);endMsg;\n}\n\nfloat text_a(vec2 U) {\n    initMsg;C(65);C(84);C(58);endMsg;\n}\n\nfloat text_pmhp(vec2 U, int v) {\n    initMsg;C((v * 43 + 45 * (1 - v)));C(72);C(80);endMsg;\n}\n\nfloat text_pat(vec2 U) {\n    initMsg;C(43);C(65);C(84);endMsg;\n}\n\nfloat text_ko(vec2 U) {\n    initMsg;C(75);C(79);endMsg;\n}\n\nfloat text_des(vec2 U) {\n    initMsg;C(68);C(101);C(115);C(116);C(114);C(111);C(121);endMsg;\n}\n\nfloat text_drw(vec2 U) {\n    initMsg;C(68);C(114);C(97);C(119);C(32);C(50);endMsg;\n}\n\nfloat text_end(vec2 U) {\n    initMsg;C(69);C(110);C(100);endMsg;\n}\n\nfloat text_mi(vec2 U) {\n    initMsg;C(45);endMsg;\n}\n\nfloat text_n0(vec2 U) {\n    initMsg;C(48);C(48);endMsg;\n}\n\nfloat text_n(vec2 U, float num) {\n    if (num < 1.)return text_ko(U);\n    initMsg;\n    num = floor(num);\n    int maxloop = 2;\n    bool x = false;\n    if (num < 10.) {\n        num = num * 10.;\n    } else {\n        num = floor(num / 10.)+(num * 10. - floor(num / 10.)*100.);\n        if ((num < 10.))x = true;\n    }\n    while (num >= 1.0) {\n        if (maxloop-- < 1)break;\n        C((48 + int(num) % 10));\n        if (x) {\n            C(48);\n            x = false;\n        }\n        num /= 10.0;\n    }\n    endMsg;\n}\n\n\n// to load card pixels only when we need it without reading 20 pixels for every pixel, if use it in load_state\n\nvec4 load_card(int idx) {\n    ivec2 id = ivec2(0, idx) ;\n    return texelFetch(iChannel0, (id) , 0  );\n}\n\nvec4 load_card2(int idx) {\n    ivec2 id = ivec2(1, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\n\n#define c_bgr -1\n#define c_cr 0\n#define c_cr2 1\n#define c_cr3 2\n#define c_at1 3\n#define c_at2 4\n#define c_he1 5\n#define c_he2 6\n#define c_pat 7\n#define c_mn 8\n#define c_de 9\n\nvec3 decodeval(float colz) {\n    vec3 retc = vec3(0.);\n    retc.x = floor(floor(colz) / 10000.) - 1.;\n    retc.y = floor((-(retc.x + 1.)*10000. + floor(colz)) / 100.) - 1.;\n    retc.z = floor(-(retc.y + 1.)*100. - (retc.x + 1.)*10000. + floor(colz)) - 1.;\n    return retc;\n}\n\nfloat encodeval(vec3 colz) {\n    return floor(colz.r)*10000. + 10000. + floor(colz.g)*100. + 100. + floor(colz.b) + 1.;\n}\n\nvec3 decodecol(float colz) {\n    return decodeval(colz) / 98.;\n}\n\nfloat encodecol(vec3 colz) {\n    return encodeval(colz * 98.);\n}\n\nbool is_c_cr(int ix) {\n    return (ix - 3) < 0; // used only for cards in hand, they have not c_bgr(-1)\n    //return ((ix==c_cr)||(ix==c_cr2)||(ix==c_cr3));\n}\n\nfloat is_c_crf(int ix) {\n    return clamp(float(ix - 2), 0., 1.);\n}\n\nbool is_o_crf(int ix) {\n    return (((ix == c_de) || (ix == c_mn) || (ix == c_pat)));\n}\n\nfloat is_h_crf(int ix) {\n    return (((ix == c_at1) || (ix == c_at2)) ? 0. : 1.);\n}\n\nbool is_H_crf(int ix) {\n    return ((ix == c_he1) || (ix == c_he2));\n}\n\nfloat is_v_crf(int ix) {\n    return 1. - clamp(float(ix - 7), 0., 1.);\n}\n\nfloat is_d_crf(int ix) {\n    return clamp(float(ix - 8), 0., 1.);\n}\n\n\n\n// long compile time because of this function(mostly because text)\n\n// using if(id==<card_type>)return func_that_generate_unique_texture_col_for_cardID();\n// make shader work same fast (card size is small, any card-shader-background can be used)\n// but compile time will be extrimly long (using if()func(); I had 5+ min compile time on Windows, and 30 sec on Linux)\n\n// p(0,0) is card center, card size (0.08,0.12)\n\nvec3 card_ubgx(vec2 p, int id, vec4 card_vals) {\n    vec3 c1 = decodecol(card_vals.z);\n    vec3 crvals = decodeval(card_vals.x);\n    vec3 c2 = (c1 + 0.2);\n    vec3 c3 = vec3(0.);\n    vec3 c4 = p.x > 0. ? cef7a * 1.5 : cr2;\n    vec3 col;\n    vec3 colt;\n    float isc = is_c_crf(id);\n    float isv = is_v_crf(id);\n    float ish = is_h_crf(id);\n    float isd = is_d_crf(id);\n    //return isc * vec3(1. * isv, 1. * ish, 1. * isd + ((id == c_pat) ? 1. : 0.)); //this make compile time to few sec (return single color for each card type)\n    colt = mix(c1, c2, SS(-0.05, 0.18, p.y));\n    col = mix(cw2, colt, SS(0., zv, p.y + 0.05));\n    col = mix(col, c3 * isc + c4 * (1. - isc), isv * 0.65 * SS(zv / 2., 0., sdCircle(vec2(abs(p.x)*(1. - isc) + p.x*isc, p.y) - vec2(0.08 * (1. - isc) - 0.08 * isc, 0.12), 0.03)));\n    float d = isv * text_n((p + vec2(0.0765, -0.11))*40. + res_g / 2., (1. - isc) * crvals.y + isc * crvals.x);\n    col = mix(col, cw2, d);\n    if (is_c_cr(id)) {\n        d = text_n((p + vec2(-0.059, -0.11))*40. + res_g / 2., crvals.z);\n        col = mix(col, cw2, d);\n        d = 1. - text_hp((p + vec2(0.07, 0.07))*50. + res_g / 2.);\n        d = min(d, 1. - text_a((p + vec2(0.07, 0.095))*50. + res_g / 2.));\n        col = col*d;\n        d = SS(0.003 - zv / 2., 0.004 + zv / 2., sdLine(p, -vec2(0.04, 0.071), -vec2(0.04 - 0.1 * (min(1., crvals.y / 98.)), 0.071)));\n        col = mix(cr2, col, d);\n        d = SS(0.003 - zv / 2., 0.004 + zv / 2., sdLine(p, -vec2(0.04, 0.096), -vec2(0.04 - 0.1 * (min(1., crvals.z / 98.)), 0.096)));\n        col = mix(cef7a * 1.5, col, d);\n    } else {\n        if (is_o_crf(id)) {\n            if (id == c_pat) {\n                d = 1. - text_pat((p + vec2(0.045, 0.08))*15. + res_g / 2.);\n                col = mix(vec3(0.5), col, d);\n            } else if (id == c_pat) {\n                d = 1. - text_pat((p + vec2(0.045, 0.08))*15. + res_g / 2.);\n                col = mix(vec3(0.5), col, d);\n            } else {\n                if (id == c_mn) {\n                    d = 1. - text_drw((p + vec2(0.06, 0.08))*25. + res_g / 2.);\n                    col = mix(vec3(0.5), col, d);\n                } else {\n                    d = 1. - text_des((p + vec2(0.06, 0.08))*25. + res_g / 2.);\n                    col = mix(vec3(0.5), col, d);\n                }\n            }\n        } else {\n            d = 1. - text_pmhp((p + vec2(0.045, 0.08))*15. + res_g / 2., int(ish));\n            col = mix(vec3(0.5), col, d);\n        }\n    }\n    float crx2 = (id == c_cr2 ? 1. : 0.);\n    float crx3 = (id == c_cr3 ? 1. : 0.);\n    if (is_H_crf(id) || (id == c_pat) || (1. - (isv + isd) > 0.)) {\n        p.y = -p.y + 0.07;\n        ish = 0.;\n    }\n    float da = (1. - 0.3 * (1. - isv - isd) - 0.2 * (1. - ish)) * SS(0.002 * crx3 + zv / 2., 0.001 * crx3 + 0., max(crx3 * abs(sdCircle(p + vec2(0., -0.035), 0.015)), sdCircle(p + vec2(0., -0.035 + 0.035 * (1. - ish)), 0.015)));\n    float db = (isv + isd)*(0.25 * crx2 + 0.25) * SS(zv / 2., 0., sdCircle(p + vec2(0., -0.035 + 0.035 * (1. - ish)), 0.03));\n    d = 0.5 * SS(zv / 2., 0., sdBox(p + vec2(0., -0.035 - 0.015), vec2(0.015, 0.05)));\n    col = mix(col, cw2, max(min(max((1. - crx2) * da, -da * crx2 + db), 1. * (1. - isd) + SS(0.035, 0.035 - zv, p.y)), d * SS(0.1, 0.0, p.y)*(1. - ish)));\n    return col; //-card_nbg((p+vec2(0.,0.15))*8.,g_time/2.+50.*float(id));\n}\n\nvec3 load_id_cardcolor(vec2 p, int id, vec4 card_vals) {\n    if (id == c_bgr)return card_nbg((p + vec2(0., 0.15))*8., g_time);\n    return card_ubgx(p, id, card_vals);\n}\n\nvec3 get_cardcolor(vec2 p, int id, bool vb) {\n    if (id < 0)return load_id_cardcolor(p, id, vec4(0.));\n    vec4 card_vals = vb ? load_card(id) : load_card2(id);\n    return load_id_cardcolor(p, int(card_vals.w), card_vals);\n}\n\n// same as load_card logic\n\nvec4 load_board(int idx) {\n    ivec2 id = ivec2(3, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_board2(int idx) {\n    ivec2 id = ivec2(4, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_eff_buf() {\n    ivec2 id = ivec2(2, 3) ;\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec3 get_boardccolor(vec2 p, int id, bool vb) {\n    vec4 card_vals = vb ? load_board(id) : load_board2(id);\n    if (id < 0)return load_id_cardcolor(p, id, vec4(0.));\n    vec3 tcc = load_id_cardcolor(p, int(card_vals.w), card_vals);\n    if (int(card_vals.y) == 1) {\n        float v2 = -p.y + 0.12 + zv;\n        float dxx = (sdCircle(vec2(abs(p.x), p.y) - vec2(0.08, 0.12), 0.03));\n        float dx = 1. - max(SS(zv / 2., 0.00 - zv / 2., dxx), SS(0.00, 0.03, v2));\n        if (dx < 1.) {\n            float nx = card_fbg((p + card_vals.w)*9.);\n            tcc = mix(tcc, -tcc + cef7a / (nx * (1. - dx * 0.99)), dx * (1. - nx)*0.6);\n            clamp(tcc, vec3(0.), vec3(1.));\n        }\n    }\n    if (card_vals.y < 0.) {\n        float anim_t2 = 1. - get_animstate(clamp((g_time - (-card_vals.y) - 0.5)*2., 0., 1.));\n        float nx = card_fbg((p + card_vals.w)*9.);\n        tcc = mix((((tcc * (anim_t2) + cef4a / 3. * (1. - anim_t2))) / (nx)), tcc, anim_t2);\n    }\n    return tcc;\n}\n\nvec3 get_boardeff(vec2 p) {\n    vec4 card_vals = load_eff_buf();\n    return load_id_cardcolor(p, int(card_vals.w), card_vals);\n}\n\nvec4 card_put_ani_c(vec2 p) {\n    vec3 col = vec3(0.);\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    float d = 1.;\n    const float angle_pos = 0.045;\n    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n    if ((anim_t2 == 0.) || (allData.flag1 == 1.))return vec4(col, 1.);\n    float anim_t = 1. - get_animstate(clamp((g_time - allData.card_put_anim)*4., 0., 1.));\n    float ad = allData.cards_player + 1. - 1. * (0.);\n    float tv = 0.5 - (ad - (ad / 2.) - allData.card_hID_put_anim);\n    vec2 epos = vec2(0., -0.08) * 1.;\n    vec2 tuv = p;\n    int ts = int(load_eff_buf().w);\n    if (ts < 0) {\n        if (anim_t > 0.)\n            tuv = (p + card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.)) * MD(angle_pos * tv * anim_t) + epos - shift_pos * tv;\n        else\n            tuv = p + (card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv) * anim_t2 + (1. - anim_t2)*(vec2(0.18 / 2., 0.1 + 0.005 + zv / 2.) + vec2(0.18 * 2. - 0.18 * allData.card_bID_put_anim, 0.));\n        d = card(tuv);\n        vec3 cardcol = vec3(0.);\n        if (d < 1.)\n            cardcol = get_boardccolor(tuv, int(allData.card_bID_put_anim), true);\n\n        float ds = card_shadow(tuv);\n        ds = (1., ds + 1. - anim_t2);\n        col = col * (ds);\n        col = mix(cardcol, col, d);\n        d = min(ds, d);\n    } else {\n        float td = 1.;\n        float nx = 1.;\n        tuv = (p + card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.)) * MD(angle_pos * tv * anim_t) + epos - shift_pos*tv;\n        td = SS(0., 0.01, sdBezier(p, -(card_pos - epos * (1. - 1.) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv),\n                vec2(0., 0.12 * 2.)-(card_pos - epos * (anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv),\n                vec2(-0.18 * 3. + 0.18 / 2. + (allData.card_bID_put_anim > 9. ? allData.card_bID_put_anim - 10. : allData.card_bID_put_anim)* 0.18, (allData.card_bID_put_anim > 9. ? 0.135 : -0.12))));\n        d = card(tuv);\n        if ((d < 1.) || (td < 1.))\n            nx = card_fbg(p * 9.);\n        vec3 cardcol = vec3(0.);\n        if (d < 1.)\n            cardcol = get_boardeff(tuv);\n        float ds = card_shadow(tuv);\n        ds = (1., ds + 1. - anim_t2);\n        col = col * (ds);\n        col = mix((col + (blue / 2.) / (nx)), col, td);\n        col = mix(cardcol, col, d);\n        d = min(ds, d);\n        float tdx = d;\n        d = min(td, d);\n        d = max(d, 1. - anim_t2);\n        col = mix((((col * (0.5 + anim_t2) + blue / 3. * (1. - anim_t2)) * (1. - tdx)) / (nx)), col, anim_t2);\n    }\n\n    return vec4(col, d);\n}\n\nvec4 card_put2_ani_c(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = 1.;\n    float td = 1.;\n    if ((!allData.player_turn)&&(!allData.en_etf)) {\n        if (allData.flag3 == 1.)return vec4(col, d);\n        vec4 lbx = load_card2(2);\n        if (floor(max(lbx.x, lbx.y)) >= 0.) {\n            float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 8.), 0., 1.));\n            const vec2 card_pos = vec2(0., 0.35);\n            const vec2 shift_pos = vec2(0.1, 0.);\n            const vec2 sp_pos = vec2(-0.75, 0.35);\n            float anim_t2 = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * max(lbx.x, lbx.y)))*2., 0., 1.));\n            float anim_t = 1. - get_animstate(clamp((g_time - allData.ett - 3.5 - (2. - 2. * max(lbx.x, lbx.y)))*2., 0., 1.));\n            vec2 epos = vec2(0., -0.28) * 1.;\n            float tvg = floor(floor(max(lbx.x, lbx.y)) == 1. ? lbx.z : lbx.w);\n            float tvgz = ((tvg < 0.)&&(tvg != -100.)) ? abs(tvg) - 1. : tvg;\n            vec2 epos2 = vec2(0., -0.35 + 0.12 - 0.02 - zv) - sp_pos + (vec2(0.18 / 2., 0.1 + 0.005 + zv / 2.) + vec2(0.18 * 2. - 0.18 * (tvgz > 9. ? tvgz - 10. : tvgz), 0.));\n            vec2 tuv = p;\n            if ((anim_t > 0.) || (!(tvg >= 0.)))\n                tuv = (p + sp_pos + epos * (1. - anim_t));\n            else\n                tuv = (p + sp_pos + epos * anim_t2 + epos2 * (1. - anim_t2));\n            if (!(tvg >= 0.)&&(tvg != -100.)) {\n                td = SS(0., 0.01, sdBezier(p, -(sp_pos + epos * (1. - anim_t)),\n                        vec2(0., 0.12 * 2.)-(sp_pos + epos * (1. - anim_t)),\n                        vec2(-0.18 * 3. + 0.18 / 2. + (tvgz > 9. ? tvgz - 10. : tvgz)* 0.18, (tvgz > 9. ? 0.135 : -0.12))));\n                float anim_tl = 1. - get_animstate(clamp((g_time - allData.ett - 4. - (2. - 2. * max(lbx.x, lbx.y)))*3., 0., 1.));\n                td = max(td, anim_tl);\n            }\n            d = card(tuv);\n            vec3 cardcol = vec3(0.);\n            if (d < 1.)\n                cardcol = get_cardcolor(tuv, int(max(lbx.x, lbx.y)), false);\n\n            float ds = card_shadow(tuv);\n            ds = (1., ds + 1. - anim_t2);\n            col = col * (ds);\n            float nx = 1.;\n            if ((!(tvg >= 0.))&&((d < 1.) || (td < 1.)))\n                nx = card_fbg(p * 9.);\n            col = mix((col + (purple / 2.) / (nx)), col, td);\n            col = mix(cardcol, col, d);\n            d = min(ds, d);\n            float tdx = d;\n            if (!(tvg >= 0.)) {\n                d = min(td, d);\n                d = max(d, 1. - anim_t2);\n                col = mix((((col * (0.5 + anim_t2) + blue / 3. * (1. - anim_t2)) * (1. - tdx)) / (nx)), col, anim_t2);\n            }\n        }\n    }\n\n    return vec4(col, d);\n}\n\nvec4 card_hand(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = 1.;\n    float ds = 1.;\n    float da = d;\n    float dt = 1.;\n    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n    bool pass = false;\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        return vec4(col, 1.);\n    }\n    if ((p.y>-0.1) || (p.x<-0.65)) { //save GPU time\n        if ((anim_t2 == 0.)&&(allData.player_turn))return vec4(col, 1.);\n        else\n            pass = true;\n    }\n    vec2 op = p;\n    float anim_t2z = get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    if (allData.player_turn)p.y += 0.08 * (1. - anim_t2z);\n    else p.y += 0.08 * (anim_t2z);\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    const float angle_pos = 0.045;\n    float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n    vec3 cardcol = vec3(0.);\n    vec2 tuv = vec2(0.);\n    float ec = -1.;\n    ec = allData.card_hID_put_anim;\n    float locsc = -1.;\n    if (allData.flag1 == 1.)locsc = ec;\n    else locsc = allData.last_selected_card;\n    vec4 col_t = card_put2_ani_c(op); //draw en cards\n    da = min(da, col_t.w); // min to off shadow blink on draw\n    col = mix(col_t.rgb, col, col_t.w);\n    if (!pass) {\n        if (op.y<-0.2) {\n            //optimization, calculating tiles to display only this tile+2 previous+2 next without loop all 10 cards(when hand maxsize)\n            //save ~15% GPU load on it\n            float ist = floor((p.x + (0.4) * (allData.cards_player / 10.)) / 0.1) - 2.;\n            float ien = ist + 4.; //change +4. to +3. to display tile borders\n            if (allData.cards_player > 1.)\n                ist = clamp(ist, 0., allData.cards_player - 1.);\n            else ist = 0.;\n            for (float i = ist+float(min(0,iFrame)); i < allData.cards_player; i++) {\n                if (i > ien)break;\n                da = min(d, da);\n                //calc card position shift\n                float avx = 0.;\n                tuv = vec2(0.);\n                if ((anim_t2 != 0.)&&(allData.flag1 == 0.)) {\n                    if (i >= ec)avx = 1.;\n                    if (i < ec)avx = -1.;\n                    avx *= anim_t2;\n                }\n                if (i != locsc) {\n                    if ((i + avx) + 2. > allData.cards_player + avx) {\n                        float tv = 0.5 - ((allData.cards_player + avx) - ((allData.cards_player + avx) / 2.) - (i + avx));\n                        tuv = (p + card_pos) * MD(angle_pos * tv * (1. - anim_t)) - shift_pos * tv * (1. - anim_t) + vec2(sp_pos.x, 0.) * anim_t;\n                        d = card(tuv);\n                        if (d < 1.)\n                            cardcol = get_cardcolor(tuv, int(i), true);\n                    } else {\n                        float ad = (allData.cards_player + avx) - 1. * (anim_t);\n                        float tv = 0.5 - (ad - (ad / 2.) - (i + avx));\n                        tuv = (p + card_pos) * MD(angle_pos * tv) - shift_pos*tv;\n                        d = card(tuv);\n                        if (d < 1.)\n                            cardcol = get_cardcolor(tuv, int(i), true);\n                    }\n                    ds = card_shadow(tuv);\n                    col = col * (ds);\n                    col = mix(cardcol, col, d);\n                    d = min(ds, d);\n                    da = (d * da); // not min(), min display sdf borders(not nice)\n                }\n            }\n            ds = card_shadow(op + sp_pos);\n            if (ds < 1.) {\n                d = card(op + sp_pos);\n                col = col * (ds);\n                col = mix(get_cardcolor(op + sp_pos, -1, true), col, d);\n                d = min(ds, d);\n                da = min(d, da); // off shadow on draw\n            }\n        }\n        //draw selected card\n        if (locsc >= 0.) {\n            float ad = allData.cards_player - 1. * (anim_t);\n            float tv = 0.5 - (ad - (ad / 2.) - locsc);\n            anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n            vec2 epos = vec2(0., -0.08) * anim_t;\n            tuv = (p + card_pos) * MD(angle_pos * tv) + epos - shift_pos*tv;\n            d = card(tuv);\n            if (d < 1.)\n                cardcol = get_cardcolor(tuv, int(locsc), true);\n            ds = card_shadow(tuv);\n            col = col * (ds);\n            col = mix(cardcol, col, d);\n            d = min(ds, d);\n            da = (d * da); // same not min()\n        }\n    }\n    col_t = card_put_ani_c(p);\n    da = (da * col_t.w); // same not min()\n    col = mix(col_t.rgb, col, col_t.w);\n    return vec4(col, da);\n}\n\nint card_baord_id(vec2 p) {\n    return int(floor((p.x + 0.18 * 3.) / 0.18));\n}\n\nint hpmp_get_hit(vec2 p) {\n    if ((allData.player_etf) || (allData.player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\nint card_get_hit(vec2 p) {\n    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), abs(p.y - 0.02) - 0.125 - zv / 2.);\n    float d = card(pt);\n    bool bv = (p.y - 0.02 < 0.);\n    d = max(d, step(0.18 * 3. + zv / 2., abs(p.x)));\n    if (d < 1.)return bv ? card_baord_id(p) : 10 + card_baord_id(p);\n    return -1;\n}\n\nint turnctrl_get_hit(vec2 p) {\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));\n    float d = SS(0., zv, sdBox(pt, vec2(0.04, 0.008)) - 0.02);\n    if (d < 1.)return 1;\n    return -1;\n}\n\nvoid card_get_select(vec2 p) {\n    float d = 1.;\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    const float angle_pos = 0.045;\n    allData.this_selected_card = -1.;\n    float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n    float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 6.5), 0., 1.));\n    if ((allData.card_draw > 0.) || (anim_t > 0.) || (allData.player_etf) || ((anim_t2zb == 0.)&&(!allData.player_turn)&&(!allData.en_etf)))return;\n    float anim_t2z = get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    if (allData.player_turn)p.y += 0.08 * (1. - anim_t2z);\n    else p.y += 0.08 * (anim_t2z);\n    for (float i = float(min(0,iFrame)); i < allData.cards_player + 1.; i++) {\n        if (i + 1. > allData.cards_player) {\n            break;\n        }\n        if (i + 2. > allData.cards_player) {\n            float tv = 0.5 - (allData.cards_player - (allData.cards_player / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv * (1. - anim_t)) - shift_pos * tv * (1. - anim_t) + vec2(sp_pos.x, 0.) * anim_t);\n        } else {\n            float ad = allData.cards_player - 1. * (anim_t);\n            float tv = 0.5 - (ad - (ad / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv) - shift_pos * tv);\n        }\n        if ((d < 1.)) {\n            allData.this_selected_card = i;\n        }\n    }\n    return;\n}\n\nfloat pattern_bg(vec2 p) {\n    float d = 0.;\n    p = vec2(mod(p.x + 0.01 * (floor((mod(p.y, 0.04) - 0.02) / 0.02)), 0.02) - 0.01, mod(p.y, 0.02) - 0.01);\n    d = SS(-0.001, 0.001, sdCircle(p, 0.0035));\n    return d;\n}\n\nvec3 gr_bg(vec2 p) {\n    vec3 col = mix(gc2, wc, SS(0., 0.2, abs(mod(p.x - 0.2, .4) - 0.2)));\n    col = mix(0.2 * col, wc, SS(0., 0.3, abs(mod(p.x + 0.1, .6) - 0.3)));\n    return col;\n}\n\nfloat glow(float x, float str, float dist) {\n    return dist / pow(x, str);\n}\n\nfloat sinSDF(vec2 st, float A, float offset, float f, float phi) {\n    return abs((st.y - offset) + sin(st.x * f + phi) * A);\n}\n\nfloat egbg(vec2 p) {\n    float d = 0.;\n    d = step(.3, abs(p.y));\n    return d;\n}\n\nfloat text_d(vec2 U) {\n    initMsg;C(68);C(101);C(102);C(101);C(97);C(116);endMsg;\n}\n\nfloat text_w(vec2 U) {\n    initMsg;C(86);C(105);C(99);C(116);C(111);C(114);C(121);endMsg;\n}\n\nfloat text_res(vec2 U) {\n    initMsg;C(82);C(101);C(115);C(116);C(97);C(114);C(116);endMsg;\n}\n\nvec4 main_c_egscr(in vec2 p, bool gx, float stx) {\n    stx += .5;\n    vec2 op = p;\n    p.y = mod(p.y, 0.6) - 0.3;\n    vec2 st = p + 0.5;\n    vec3 col = vec3(0.0);\n    float time = g_time / 2.0;\n    float str = 0.6;\n    float dist = 0.02;\n    float nSin = 4.0;\n    float timeHalfInv = -time * sign(st.x - 0.5);\n    float am = cos(st.x * 3.0);\n    float offset = 0.5 + sin(st.x * 12.0 + time) * am * 0.05;\n    float i = 0.;\n\n    for (float i = 0.; i < nSin; i++) {\n        col += glow(sinSDF(st, am * 0.2, offset, 6.0, timeHalfInv + i * 2.0 * PI / nSin), str, dist);\n    }\n    vec3 s = cos(6. * st.y * vec3(1, 2, 3) - time * vec3(1, -1, 1)) * 0.5;\n    float cut = (st.x + (s.x + s.y + s.z) / 33.0);\n    float vf = 3.5;\n    col = vec3(abs(smoothstep(-0.01 - (gx ? vf * SS(stx, stx + 2., g_time) : -vf * SS(stx + 2., stx, g_time)), -0.03 - (!gx ? vf * SS(stx, stx + 2., g_time) : -vf * SS(stx + 2., stx, g_time)), 0.5 - cut) - clamp(col, 0.0, 1.0)));\n    float d = SS(0.6, 0.59, abs(p.y) + 0.3);\n    float dv = SS(0., 0.01, sdVesica(vec2(abs(p.y), p.x) + vec2(0. - 0.3, 0.), 0.3 * SS(stx + 1., stx + 1. + 1., g_time), 0.25 * SS(stx + 1., stx + 1. + 1., g_time)));\n    d = (d * dv);\n    float dz = 0.;\n    if (dv < 1.)\n        if (gx)\n            dz = (1. - dv) * text_d(op * 15. + vec2(2.25, 0.45)) * SS(stx + 1.5, stx + 1.5 + 1., g_time);\n        else\n            dz = (1. - dv) * text_w(op * 15. + vec2(2.4, 0.45)) * SS(stx + 1.5, stx + 1.5 + 1., g_time);\n    col = mix(vec3(0.), col, d);\n    col = mix(col, vec3(.85), dz);\n    return vec4(col, 1.0);\n}\n\nvec4 main_c_wl(vec2 p) {\n    vec3 col = vec3(0.);\n    float dx = egbg(p);\n    float stx = allData.egt + 01.;\n    dx = max(dx, SS(res_g.x * SS(stx + 0.5, stx + 2. + 0.5, g_time), 1.2 * res_g.x * SS(stx, stx + 2., g_time), p.x + res_g.x / 2.));\n    col = mix(main_c_egscr(p, allData.player_hpmp.x < 1., stx).rgb, col, dx);\n    col += (rand(p) - .5)*.07;\n    if ((abs(p.x) < 0.15)&&(p.y<-0.3)) {\n        float dxx = 1.25 - text_res(p * 15. + vec2(2.4, 05.8));\n        col = mix(vec3(1.), col, dxx);\n        dx = min(max(dxx, (1. - SS(stx + 02.5, stx + 2. + 02.5, g_time))), dx);\n    }\n    return vec4(col, dx);\n}\n\nvec4 main_c_bg(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = pattern_bg(p);\n    col = mix(vec3(0.), gc, d);\n    float vignetteAmt = 1. - dot(p, p);\n    col *= vignetteAmt;\n    col += (rand(p) - .5)*.07;\n    col *= SS(-0.04, 0.1, abs(abs(p.y) - .3));\n    col = mix(col, sqrt(gr_bg(p)*(1. - SS(-0.04, 0.1, abs(abs(p.y) - .3)))), -step(0.3 + 0.002, abs(p.y)) + step(0.3 - 0.002, abs(p.y)));\n    bool bv = (p.y - 0.02) < 0.;\n    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), -(abs(p.y - 0.02) - 0.125 - zv / 2.));\n    d = card(pt);\n    float dod = step(0.18 * 3., abs(p.x));\n    d = max(d, dod);\n    vec3 ec = ((bv ? 0.75 * blue : red)*(1. - d));\n    col += col * ec;\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        return vec4(col, 1.);\n    }\n    //both sides of board\n    if (dod < 1.)\n        if (((!allData.en_etf)&&(bv)) || ((!allData.player_etf)&&(!bv))) {\n            if (d < 1.) {\n                vec4 lb = bv ? load_board(card_baord_id(p)) : load_board2(card_baord_id(p));\n                //display selection of target cells base on card type\n                if ((int(lb.w) == c_bgr)) {\n                    if ((bv)&&(allData.last_selected_card >= 0.) && (allData.player_turn) &&\n                            is_c_cr((int(load_card(int(allData.last_selected_card)).w)))) {\n                        float dx = SS(0.01, -0.05, (sdBox(pt, vec2(0.08, 0.12))));\n                        float anim_t = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                        float nx = card_fbg(p * 9.);\n                        col = mix(col + ((ec / 5. * (1. - dx)) / (5. * nx * (dx))) * anim_t, col, d);\n                    }\n                } else {\n                    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n                    if ((card_baord_id(p) == int(allData.card_bID_put_anim))&&(bv)&&(anim_t2 > 0.)&&(int(load_eff_buf().w) < 0)) {\n                    } else {\n                        float anim_t2x = 0.;\n                        if (lb.y < 0.) {\n                            anim_t2x = get_animstate(clamp((g_time - (-lb.y) - 0.5)*2., 0., 1.));\n                        }\n                        if (!bv)pt.y *= -1.;\n                        col = mix(get_boardccolor(pt, card_baord_id(p), bv), col, max(d, anim_t2x));\n                        int crr = (int(load_card(int(allData.last_selected_card)).w));\n                        if ((allData.last_selected_card >= 0.) && (allData.player_turn) &&\n                                is_c_cr((int(lb.w)))&&((c_he1 == crr) || (crr == c_at1) || (crr == c_pat) || (crr == c_de))) {\n                            float dx = SS(0.01, -0.05, (sdBox(pt, vec2(0.08, 0.12))));\n                            float anim_t = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                            float nx = card_fbg(p * 9.);\n                            col = mix(col * (1. - 0.35 * anim_t)+ (((c_pat == crr) ? blue : ((c_he1 == crr) ? green : red)) * 2.)*((ec / 5. * (1. - dx)) / (5. * nx * (dx))) * anim_t, col, d);\n                        }\n                    }\n                }\n            }\n        } else {\n            //card hit animation\n            vec4 lb = ((allData.en_etf)&&(bv)) ? load_board(card_baord_id(p)) : load_board2(card_baord_id(p));\n            float anim_t2za = min(get_animstate(clamp((g_time - allData.ett - 0.4 * float(card_baord_id(p)))*3., 0., 1.)),\n                    1. - get_animstate(clamp((g_time - allData.ett - .4 - 0.4 * float(card_baord_id(p)))*8., 0., 1.)));\n            anim_t2za *= 1. - allData.flag3;\n            if (int(lb.w) != c_bgr) {\n                p.y += (((allData.en_etf)&&(bv)) ? 1. : -1.)*0.06 * anim_t2za;\n                bv = (p.y - 0.02) < 0.;\n                if (((allData.en_etf)&&(bv)) || ((allData.player_etf)&&(!bv))) {\n                    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), -(abs(p.y - 0.02) - 0.125 - zv / 2.));\n                    d = card(pt);\n                    d = max(d, step(0.18 * 3., abs(p.x)));\n                    if (d < 1.) {\n                        float anim_t2zb = 1. - min(get_animstate(clamp((g_time - allData.ett)*6., 0., 1.)),\n                                1. - get_animstate(clamp((g_time - allData.ett - 2.5)*4., 0., 1.)));\n                        anim_t2zb = max(anim_t2zb, allData.flag3);\n                        if (!bv)pt.y *= -1.;\n                        col = mix(get_boardccolor(pt, card_baord_id(p), bv), col, d);\n                        float ddc = sdTriangleIsosceles(vec2(0.06, 0.03), vec2(pt.x, (bv ? 1. : -1.)*-pt.y) + vec2(0., 0.5 + 0.125)) - 0.02;\n                        float ddz = SS(-0.01, 0.02, ddc + 0.025);\n                        col = clamp(col, vec3(0.), vec3(1.));\n                        if (bv)\n                            col = mix(-col + 0.25 * blue / ddz, col, min(1., max(anim_t2zb, ddz) + 0.5));\n                        else\n                            col = mix(-col + 0.25 * purple / ddz, col * (min(1., max(anim_t2zb, ddz) + 0.5)), min(1., max(anim_t2zb, ddz) + 0.5));\n                    }\n                }\n            } else {\n                if (d < 1.)\n                    col *= (0.5 + 0.5 * (1. - anim_t2za));\n            }\n        }\n\n\n    return vec4(col, 1.);\n}\n\nvec4 draw_turnctrl(vec2 p) {\n    vec3 col = vec3(0.);\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));\n    float d = SS(0., zv, sdRhombus(pt, vec2(0.06, 0.12)));\n    float bxx = sdBox(pt, vec2(0.04, 0.008)) - 0.02;\n    float dy = SS(0., zv, bxx);\n    float dx = 1.;\n    if (dy < 1.)\n        dx = 1. - text_end(vec2(pt.x, pt.y)*15. + vec2(01.5, 0.5));\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = SS(-0.01, 0.02, abs(bxx));\n    float anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n    float anim_t2z = 1. - get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    float anim_t2za = 1. - get_animstate(clamp((g_time - allData.ett), 0., 1.));\n    col = mix(bv ? (allData.player_turn ? green * (1. - anim_t2z) : green * anim_t2z) : (allData.player_turn ? green * anim_t2z : green * (1. - anim_t2z)), vec3(0.), d);\n    col = mix(cw2, col, dy);\n    col = mix(vec3(0.), col, dx);\n    if (allData.player_turn) {\n        col = mix(0.5 * (allData.player_hpmp.y > 0. ? cef4a : mix(redw, green, anim_t)) / dz, col, dz);\n    } else {\n        col = mix(0.5 * (green * anim_t2za) / dz, col, dz);\n    }\n    d = min(min(min(d + 0.65, dy + 0.4), dz), dx);\n    return vec4(clamp(col, vec3(0.), vec3(4.)), min(1., d));\n}\n\nvec4 draw_hpmp(vec2 p) {\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    vec3 col = vec3(0.);\n    bool bv = (p.y - 0.02 < 0.);\n    float d = 1.;\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.) {\n        d = hp_s(pt);\n        float nx = 1.;\n        if (d < 1.)\n            nx = card_fbg(p * 18.);\n        float ddx = hp_s3(pt + vec2(.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));\n        float ddx2 = hp_s3(pt + vec2(-.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));\n        float vx = (bv ? allData.player_hpmp.x / 98. : allData.en_hpmp.x / 98.)*0.12 - 0.12 / 2.;\n        float nxx = step(vx, pt.x);\n        col = mix((bv ? green : redw) / (nx * 3.), col, max(d, nxx));\n        float dx = 1. - text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, 0.), bv ? allData.player_hpmp.x : allData.en_hpmp.x);\n        col = mix(white, col, dx);\n        d = min(d, dx);\n        vec3 tccx = vec3(0.);\n        int crr = (int(load_card(int(allData.last_selected_card)).w));\n        if (allData.player_turn)\n            if (bv) {\n                if (((c_mn == crr) || (c_he2 == crr))&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {\n                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);\n                    tccx = clamp((c_mn == crr ? blue : green) / (100. * td), vec3(0.), vec3(4.));\n                    tccx = tccx*anim_tx;\n                }\n            } else {\n                if ((c_at2 == crr)&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {\n                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);\n                    tccx = clamp(redw / (100. * td), vec3(0.), vec3(4.));\n                    tccx = tccx*anim_tx;\n                }\n            }\n        col = mix(tccx, col, max(dz + 0.35, 1. - d));\n        d = min(d, dz + 0.35);\n        float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*3., 0., 1.));\n        if (allData.flag1 == 1.)anim_t2 = 0.;\n        bool bvx = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 0.;\n        bool bvy = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 1.;\n        if ((!allData.player_turn)&&(!allData.en_etf)) {\n\n            float anim_t2x = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * allData.en_hpmp.y))*2., 0., 1.));\n            anim_t2 = anim_t2x;\n        }\n        anim_t2 = allData.player_turn ? (bv ? anim_t2 : 0.) : (!bv ? anim_t2 : 0.);\n        col = mix(col, clamp((bvx ? blue : blue * anim_t2) / ddx, vec3(0.), vec3(4.)), 1. - ddx);\n        col = mix(col, clamp((bvy ? blue : (bvx ? blue * anim_t2 : vec3(0.))) / ddx2, vec3(0.), vec3(4.)), 1. - ddx2);\n        d = min(d, ddx * ddx2);\n    }\n    if (allData.en_etf || allData.player_etf) {\n        float anim_t2zb = 1. - min(get_animstate(clamp((g_time - allData.ett - 0.1)*3., 0., 1.)),\n                1. - get_animstate(clamp((g_time - allData.ett - 2.8)*4., 0., 1.)));\n        dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.07));\n        if (dz < 1.) {\n            float dxz = 1.;\n            if (floor(allData.egt) > 0.)\n                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7), allData.egt));\n            else\n                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n0(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7)));\n            dxz = max(anim_t2zb, dxz);\n            col = mix(redw, col, dxz);\n            d = min(d, dxz);\n        }\n    }\n    return vec4(col, min(1., d + 0.35));\n}\n\nvec4 main_c(vec2 p) {\n    vec3 col = vec3(0.);\n    col = main_c_bg(p).rgb;\n    vec4 col_t = vec4(0.);\n    float dz = 0.;\n    if (allData.flag3 == 1.) {\n        dz = SS(allData.egt + 1., allData.egt + 1.5, g_time);\n    }\n    col_t = draw_hpmp(p);\n    col = mix(col_t.rgb, col, col_t.w);\n    col_t = draw_turnctrl(p);\n    col = mix(col_t.rgb, col, max(col_t.w, dz));\n    /*col_t = card_hand(p);\n    col = mix(col_t.rgb, col, max(col_t.w, dz));\n    if (allData.flag3 == 1.) {\n        col_t = main_c_wl(p);\n        col = mix(col_t.rgb, col, col_t.w);\n    }*/\n    return vec4(col, 1.);\n}\n\n\nfloat zoom_calc(float zv) {\n    float ex = 0.0025 * ((1080. * zv) / (iResolution.y));\n    return ex;\n}\n\nvoid init_globals() {\n    zv = zoom_calc(1.);\n    res_g = res;\n    g_time = iTime + extime;\n}\n\nvec2 click_control() {\n    return abs(iMouse.zw) / iResolution.y - res_g / 2.0;\n}\n\n//fix 2020\nint hpmp_get_hit_preinit(vec2 p, bool player_etf) {\n    if ((player_etf) || (player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\n\n// load last state\n\nvoid load_state(in vec2 fragCoord, bool ctrl) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 px = texelFetch(iChannel0, ivec2(2, 0), 0);\n    float cards_player = floor(px.x);\n    float flag0 = floor(px.y);\n    float cards_player_atime = (px.z);\n    float cards_player_select = floor(px.w);\n    px = texelFetch(iChannel0, ivec2(2, 2), 0);\n    float card_put_anim = (px.x);\n    float card_hID_put_anim = floor(px.y);\n    float card_bID_put_anim = floor(px.z);\n    float flag1 = floor(px.w);\n    vec2 click_pos = vec2(0.);\n    float card_select_anim=0.;\n    px = texelFetch(iChannel0, ivec2(2, 4), 0);\n    vec3 tvg = decodeval(px.x);\n    vec2 player_hpmp = tvg.yz;\n    bool player_etf = tvg.x == 1.;\n    tvg = decodeval(px.y);\n    vec2 en_hpmp = tvg.yz;\n    bool en_etf = tvg.x == 1.;\n    float ett = px.z;\n    bool player_turn = ett < 0.;\n    ett = abs(ett);\n    float flag3 = 0.;\n    float egt = px.w;\n    if ((flag0 != 1.) || (g_time < extime + 0.1)) {\n        egt = 0.;\n    } else {\n        if (player_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n        if (en_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n    }\n    if ((iMouse.z > 0.)&&(ctrl)) {\n        float anim_t2 = 1. - get_animstate(clamp((g_time - card_put_anim - 0.5)*2., 0., 1.));\n        float anim_t = get_animstate(clamp(1. - (g_time - cards_player_atime), 0., 1.));\n        if ((flag3 == 0.)&&(anim_t == 0.)&&(anim_t2 == 0.)) { //do not update mouse if anim played\n            click_pos = click_control();\n            if ((player_hpmp.y > 0.)&&((card_get_hit(click_pos) >= 0) || (hpmp_get_hit_preinit(click_pos,player_etf) > 0))) {\n                px = texelFetch(iChannel0, ivec2(2, 1), 0);\n                card_select_anim = px.z;\n            } else card_select_anim = g_time;\n        } else {\n            card_select_anim = g_time;\n        }\n    } else {\n        px = texelFetch(iChannel0, ivec2(2, 1), 0);\n        card_select_anim = px.z;\n        click_pos = px.xy;\n    }\n    px = texelFetch(iChannel0, ivec2(2, 1), 0);\n    float card_draw = floor(px.w);\n    if(flag3==1.)card_draw=0.;\n    allData = allData_struc(cards_player, card_select_anim, cards_player_atime, click_pos, -1., cards_player_select, card_put_anim, card_hID_put_anim, card_bID_put_anim, flag1, flag0,\n            player_hpmp, en_hpmp, flag3, egt, card_draw, player_turn, ett, player_etf, en_etf);\n}\n\n#ifdef NOCOMPILE\n\nfloat text_play(vec2 U) {\n    initMsg;C(80);C(76);C(65);C(89);endMsg;\n}\n\nfloat text_playex(vec2 U) {\n    initMsg;C(82);C(69);C(65);C(68);C(32);C(67);C(111);C(109);C(109);C(111);C(110);endMsg;\n}\n\nfloat text_playex2(vec2 U) {\n    initMsg;C(70);C(79);C(82);C(32);C(76);C(97);C(117);C(110);C(99);C(104);endMsg;\n}\n\nfloat text_playupd(vec2 U) {\n    initMsg;C(85);C(112);C(100);C(97);C(116);C(101);C(100);endMsg;\n}\n\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifdef NOCOMPILE\n    res_g = res;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res_g / 2.0;\n    float x = 0.;\n    vec3 col = vec3(0.);\n    if (iResolution.y > 250.) {\n        x = text_play((uv)*1.25 + vec2(res.x, res.y / 4.));\n        col = vec3(1.) * x;\n        x = text_playex((uv)*5. + vec2(res.x * 2.62, res.y * 2.));\n        col += vec3(1., 0., 0.) * x;\n        x = text_playex2((uv)*5. + vec2(res.x * 2.63, res.y * 1.2));\n        col += vec3(0., 0., 1.) * x;\n        x = text_playupd((uv)*5. + vec2(res.x * 1.5, res.y * 2.62));\n        col += vec3(0., 0.5, .5) * x;\n    } else col = vec3(text_play((uv)*1.25 + vec2(res.x, res.y / 2.)));\n    fragColor = vec4(col, 1.);\n    return;\n#else\n    init_globals();\n    load_state(fragCoord, false);\n    vec2 uv = (fragCoord.xy) / iResolution.y - res_g / 2.0;\n    vec4 ret_col = main_c(uv);\n    fragColor = ret_col;\n#endif\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/wdlGz8\n\n// using https://iquilezles.org/articles/distfunctions2d\n// using https://www.shadertoy.com/view/llyXRW\n// using https://www.shadertoy.com/view/ldKyW1\n\n// this is just \"demo\"\n// this is not \"universal UI/game engine\" this is fast code only for that game/demo\n// number cards in hand, its animation and many other thinks are hard coded(no way to change them(without very hard editing))(adding new cards/mechanics also complicated), faster for you will be rewrite the logic by you own\n\n// have fun xD\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI (4.0 * atan(1.0))\n#define TAU (2.*PI)\n#define E exp(1.)\n#define res (iResolution.xy / iResolution.y)\n\n#define texture(a,b) textureLod(a,b,0.0)\n\nstruct allData_struc {\n    float cards_player; //num of cards in player hand\n    float card_select_anim; //time of start card select animation\n    float card_add_anim; //time of start card add animation\n    vec2 mouse_pos;\n    float this_selected_card; //hand card selection\n    float last_selected_card; //hand card selection\n    float card_put_anim; //card put to board from hand\n    float card_hID_put_anim; //used only for animation removing card from hand\n    float card_bID_put_anim; //last putted card on board\n    float flag1;\n    float flag0;\n    vec2 player_hpmp;\n    vec2 en_hpmp;\n    float flag3;\n    float egt; //end game timer\n    float card_draw; //draw X cards\n    bool player_turn;\n    float ett; //end turn timer\n    bool player_etf; //used for \"cards on board hit other side\"\n    bool en_etf; //same\n};\n\nallData_struc allData;\n\nconst vec3 blue = vec3(0x90, 0xbb, 0xe4) / float(0xff);\nconst vec3 green = vec3(0x7f, 0xbe, 0x20) / float(0xff);\nconst vec3 purple = vec3(0x9e, 0x75, 0xaf) / float(0xff);\nconst vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 red = vec3(0xa6, 0x36, 0x2c) / float(0xff);\nconst vec3 redw = vec3(0xfd, 0x8c, 0x77) / float(0xff);\nconst vec3 sand = vec3(0xe9, 0xdf, 0xc3) / float(0xff);\nconst vec3 gc = vec3(0x38, 0x38, 0x38) / float(0xff);\nconst vec3 wc = vec3(0xfc, 0xfc, 0xfc) / float(0xff);\nconst vec3 gc2 = vec3(0x47, 0x47, 0x47) / float(0xff);\n\nfloat zv;\nvec2 res_g;\n\n// start time from extime value sec, for timers\n#define extime 15.\nfloat g_time;\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n    p = abs(p);\n    float b = sqrt(r * r - d * d);\n    return ((p.y - b) * d > p.x * b)\n            ? length(p - vec2(0.0, b))\n            : length(p - vec2(-d, 0.0)) - r;\n}\n\nfloat ndot(vec2 a, vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(in vec2 p, in vec2 b) {\n    vec2 q = abs(p);\n    float h = clamp((-2.0 * ndot(q, b) + ndot(b, b)) / dot(b, b), -1.0, 1.0);\n    float d = length(q - 0.5 * b * vec2(1.0 - h, 1.0 + h));\n    return d * sign(q.x * b.y + q.y * b.x - b.x * b.y);\n}\n\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n    float resa = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p * p*p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t) * t;\n        resa = dot(qos, qos);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t.x) * t.x;\n        resa = dot(qos, qos);\n        qos = d + (c + b * t.y) * t.y;\n        resa = min(resa, dot(qos, qos));\n        qos = d + (c + b * t.z) * t.z;\n        resa = min(resa, dot(qos, qos));\n    }\n    return sqrt(resa);\n}\n\nfloat sdTriangleIsosceles(in vec2 q, in vec2 p) {\n    p.y -= 0.5;\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n            vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat board(vec2 p) {\n    float d = 0.;\n    d = SS(0., zv, sdBox(p, vec2(0.6, 0.3)));\n    return d;\n}\n\nfloat card_shadow(vec2 p) {\n    float d = 0.;\n    d = SS(-0.01, 0.02 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat card(vec2 p) {\n    float d = 0.;\n    d = SS(0., 0.0 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat hp_s(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.06, 0.01));\n    d = SS(0., 0.0 + zv, d);\n    return d;\n}\n\nfloat hp_s2(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.045, 0.015));\n    d = SS(0., 0.0 + zv, d - 0.03);\n    return d;\n}\n\nfloat hp_s3(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.015, 0.001));\n    d = SS(-0.001, 0.008, d);\n    return d;\n}\n\nfloat get_animstate(float timeval) {\n    return SS(0., 1., timeval);\n}\n\nconst vec3 cw2 = vec3(0xf8, 0xf9, 0xfb) / float(0xff);\nconst vec3 cb2 = vec3(0x1c, 0x25, 0x36) / float(0xff);\nconst vec3 cr2 = vec3(0xe3, 0x6b, 0x7e) / float(0xff);\nconst vec3 cr3 = vec3(0xec, 0xd0, 0x6a) / float(0xff);\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.1)));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = (sqrt(3.) - 1.) / 2.;\n    const float K2 = (3. - sqrt(3.)) / 6.;\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n    return dot(n, vec3(50.0));\n}\n\nfloat fbm(vec2 uv) {\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float f = 0.5000 * noise(uv);\n    uv = m*uv;\n    f += 0.2500 * noise(uv);\n    uv = m*uv;\n    f += 0.1250 * noise(uv);\n    uv = m*uv;\n    f += 0.0625 * noise(uv);\n    uv = m*uv;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\nfloat card_fbg(vec2 p) {\n    float tx = g_time / 2.;\n    float nx = abs(noise(p + vec2(tx * 0.5)));\n    nx += 0.5 * abs(noise((p + vec2(-tx * 0.25, tx * 0.25)) * 2.0));\n    nx += 0.25 * abs(noise((p + vec2(tx * 0.15, -tx * 0.15)) * 4.0));\n    nx += 0.125 * abs(noise((p + vec2(-tx * 0.05, -tx * 0.05)) * 8.0));\n    return nx;\n}\n\nvec3 card_nbg(vec2 p, float tv) {\n    float _s = sign(p.y) * (200.0 + (tv * 0.051));\n    float l = p.y;\n    p.y = mod(abs(p.y), 2.50);\n    p.x += _s + pow(p.y, -1.002);\n    vec3 xx = vec3(fbm(p - vec2(0.0, tv * 0.0485)));\n    float s = 3.75;\n    float m = pow(xx.x, p.y * s) + .05;\n    if (l < 0.0) {\n        m *= 0.3;\n    }\n    vec3 color = mix((m / blue), (m / sand), clamp(sin(tv / 20.) - cos(tv / 20.), 0., 1.));\n    return clamp(color, vec3(0.), vec3(1.));\n}\n\nconst vec3 cef1a = vec3(0x69, 0x64, 0x7e) / float(0xff);\nconst vec3 cef1b = vec3(0xd8, 0x79, 0x8b) / float(0xff);\nconst vec3 cef2b = vec3(0x1b, 0x5f, 0x41) / float(0xff);\nconst vec3 cef3a = vec3(0x82, 0x9d, 0xa9) / float(0xff);\nconst vec3 cef4a = vec3(0xe6, 0x73, 0x00) / float(0xff);\nconst vec3 cef6a = vec3(0xb3, 0x24, 0x00) / float(0xff);\nconst vec3 cef7a = vec3(0x33, 0x33, 0xcc) / float(0xff);\nconst vec3 cef7b = vec3(0x66, 0x99, 0xff) / float(0xff);\nconst vec3 cef8a = vec3(0x99, 0x00, 0xcc) / float(0xff);\nconst vec3 cef9a = vec3(0x00, 0x33, 0x00) / float(0xff);\n\nfloat text_hp(vec2 U) {\n    initMsg;C(72);C(80);C(58);endMsg;\n}\n\nfloat text_a(vec2 U) {\n    initMsg;C(65);C(84);C(58);endMsg;\n}\n\nfloat text_pmhp(vec2 U, int v) {\n    initMsg;C((v * 43 + 45 * (1 - v)));C(72);C(80);endMsg;\n}\n\nfloat text_pat(vec2 U) {\n    initMsg;C(43);C(65);C(84);endMsg;\n}\n\nfloat text_ko(vec2 U) {\n    initMsg;C(75);C(79);endMsg;\n}\n\nfloat text_des(vec2 U) {\n    initMsg;C(68);C(101);C(115);C(116);C(114);C(111);C(121);endMsg;\n}\n\nfloat text_drw(vec2 U) {\n    initMsg;C(68);C(114);C(97);C(119);C(32);C(50);endMsg;\n}\n\nfloat text_end(vec2 U) {\n    initMsg;C(69);C(110);C(100);endMsg;\n}\n\nfloat text_mi(vec2 U) {\n    initMsg;C(45);endMsg;\n}\n\nfloat text_n0(vec2 U) {\n    initMsg;C(48);C(48);endMsg;\n}\n\nfloat text_n(vec2 U, float num) {\n    if (num < 1.)return text_ko(U);\n    initMsg;\n    num = floor(num);\n    int maxloop = 2;\n    bool x = false;\n    if (num < 10.) {\n        num = num * 10.;\n    } else {\n        num = floor(num / 10.)+(num * 10. - floor(num / 10.)*100.);\n        if ((num < 10.))x = true;\n    }\n    while (num >= 1.0) {\n        if (maxloop-- < 1)break;\n        C((48 + int(num) % 10));\n        if (x) {\n            C(48);\n            x = false;\n        }\n        num /= 10.0;\n    }\n    endMsg;\n}\n\n\n// to load card pixels only when we need it without reading 20 pixels for every pixel, if use it in load_state\n\nvec4 load_card(int idx) {\n    ivec2 id = ivec2(0, idx) ;\n    return texelFetch(iChannel0, (id) , 0  );\n}\n\nvec4 load_card2(int idx) {\n    ivec2 id = ivec2(1, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\n\n#define c_bgr -1\n#define c_cr 0\n#define c_cr2 1\n#define c_cr3 2\n#define c_at1 3\n#define c_at2 4\n#define c_he1 5\n#define c_he2 6\n#define c_pat 7\n#define c_mn 8\n#define c_de 9\n\nvec3 decodeval(float colz) {\n    vec3 retc = vec3(0.);\n    retc.x = floor(floor(colz) / 10000.) - 1.;\n    retc.y = floor((-(retc.x + 1.)*10000. + floor(colz)) / 100.) - 1.;\n    retc.z = floor(-(retc.y + 1.)*100. - (retc.x + 1.)*10000. + floor(colz)) - 1.;\n    return retc;\n}\n\nfloat encodeval(vec3 colz) {\n    return floor(colz.r)*10000. + 10000. + floor(colz.g)*100. + 100. + floor(colz.b) + 1.;\n}\n\nvec3 decodecol(float colz) {\n    return decodeval(colz) / 98.;\n}\n\nfloat encodecol(vec3 colz) {\n    return encodeval(colz * 98.);\n}\n\nbool is_c_cr(int ix) {\n    return (ix - 3) < 0; // used only for cards in hand, they have not c_bgr(-1)\n    //return ((ix==c_cr)||(ix==c_cr2)||(ix==c_cr3));\n}\n\nfloat is_c_crf(int ix) {\n    return clamp(float(ix - 2), 0., 1.);\n}\n\nbool is_o_crf(int ix) {\n    return (((ix == c_de) || (ix == c_mn) || (ix == c_pat)));\n}\n\nfloat is_h_crf(int ix) {\n    return (((ix == c_at1) || (ix == c_at2)) ? 0. : 1.);\n}\n\nbool is_H_crf(int ix) {\n    return ((ix == c_he1) || (ix == c_he2));\n}\n\nfloat is_v_crf(int ix) {\n    return 1. - clamp(float(ix - 7), 0., 1.);\n}\n\nfloat is_d_crf(int ix) {\n    return clamp(float(ix - 8), 0., 1.);\n}\n\n\n\n// long compile time because of this function(mostly because text)\n\n// using if(id==<card_type>)return func_that_generate_unique_texture_col_for_cardID();\n// make shader work same fast (card size is small, any card-shader-background can be used)\n// but compile time will be extrimly long (using if()func(); I had 5+ min compile time on Windows, and 30 sec on Linux)\n\n// p(0,0) is card center, card size (0.08,0.12)\n\nvec3 card_ubgx(vec2 p, int id, vec4 card_vals) {\n    vec3 c1 = decodecol(card_vals.z);\n    vec3 crvals = decodeval(card_vals.x);\n    vec3 c2 = (c1 + 0.2);\n    vec3 c3 = vec3(0.);\n    vec3 c4 = p.x > 0. ? cef7a * 1.5 : cr2;\n    vec3 col;\n    vec3 colt;\n    float isc = is_c_crf(id);\n    float isv = is_v_crf(id);\n    float ish = is_h_crf(id);\n    float isd = is_d_crf(id);\n    //return isc * vec3(1. * isv, 1. * ish, 1. * isd + ((id == c_pat) ? 1. : 0.)); //this make compile time to few sec (return single color for each card type)\n    colt = mix(c1, c2, SS(-0.05, 0.18, p.y));\n    col = mix(cw2, colt, SS(0., zv, p.y + 0.05));\n    col = mix(col, c3 * isc + c4 * (1. - isc), isv * 0.65 * SS(zv / 2., 0., sdCircle(vec2(abs(p.x)*(1. - isc) + p.x*isc, p.y) - vec2(0.08 * (1. - isc) - 0.08 * isc, 0.12), 0.03)));\n    float d = isv * text_n((p + vec2(0.0765, -0.11))*40. + res_g / 2., (1. - isc) * crvals.y + isc * crvals.x);\n    col = mix(col, cw2, d);\n    if (is_c_cr(id)) {\n        d = text_n((p + vec2(-0.059, -0.11))*40. + res_g / 2., crvals.z);\n        col = mix(col, cw2, d);\n        d = 1. - text_hp((p + vec2(0.07, 0.07))*50. + res_g / 2.);\n        d = min(d, 1. - text_a((p + vec2(0.07, 0.095))*50. + res_g / 2.));\n        col = col*d;\n        d = SS(0.003 - zv / 2., 0.004 + zv / 2., sdLine(p, -vec2(0.04, 0.071), -vec2(0.04 - 0.1 * (min(1., crvals.y / 98.)), 0.071)));\n        col = mix(cr2, col, d);\n        d = SS(0.003 - zv / 2., 0.004 + zv / 2., sdLine(p, -vec2(0.04, 0.096), -vec2(0.04 - 0.1 * (min(1., crvals.z / 98.)), 0.096)));\n        col = mix(cef7a * 1.5, col, d);\n    } else {\n        if (is_o_crf(id)) {\n            if (id == c_pat) {\n                d = 1. - text_pat((p + vec2(0.045, 0.08))*15. + res_g / 2.);\n                col = mix(vec3(0.5), col, d);\n            } else if (id == c_pat) {\n                d = 1. - text_pat((p + vec2(0.045, 0.08))*15. + res_g / 2.);\n                col = mix(vec3(0.5), col, d);\n            } else {\n                if (id == c_mn) {\n                    d = 1. - text_drw((p + vec2(0.06, 0.08))*25. + res_g / 2.);\n                    col = mix(vec3(0.5), col, d);\n                } else {\n                    d = 1. - text_des((p + vec2(0.06, 0.08))*25. + res_g / 2.);\n                    col = mix(vec3(0.5), col, d);\n                }\n            }\n        } else {\n            d = 1. - text_pmhp((p + vec2(0.045, 0.08))*15. + res_g / 2., int(ish));\n            col = mix(vec3(0.5), col, d);\n        }\n    }\n    float crx2 = (id == c_cr2 ? 1. : 0.);\n    float crx3 = (id == c_cr3 ? 1. : 0.);\n    if (is_H_crf(id) || (id == c_pat) || (1. - (isv + isd) > 0.)) {\n        p.y = -p.y + 0.07;\n        ish = 0.;\n    }\n    float da = (1. - 0.3 * (1. - isv - isd) - 0.2 * (1. - ish)) * SS(0.002 * crx3 + zv / 2., 0.001 * crx3 + 0., max(crx3 * abs(sdCircle(p + vec2(0., -0.035), 0.015)), sdCircle(p + vec2(0., -0.035 + 0.035 * (1. - ish)), 0.015)));\n    float db = (isv + isd)*(0.25 * crx2 + 0.25) * SS(zv / 2., 0., sdCircle(p + vec2(0., -0.035 + 0.035 * (1. - ish)), 0.03));\n    d = 0.5 * SS(zv / 2., 0., sdBox(p + vec2(0., -0.035 - 0.015), vec2(0.015, 0.05)));\n    col = mix(col, cw2, max(min(max((1. - crx2) * da, -da * crx2 + db), 1. * (1. - isd) + SS(0.035, 0.035 - zv, p.y)), d * SS(0.1, 0.0, p.y)*(1. - ish)));\n    return col; //-card_nbg((p+vec2(0.,0.15))*8.,g_time/2.+50.*float(id));\n}\n\nvec3 load_id_cardcolor(vec2 p, int id, vec4 card_vals) {\n    if (id == c_bgr)return card_nbg((p + vec2(0., 0.15))*8., g_time);\n    return card_ubgx(p, id, card_vals);\n}\n\nvec3 get_cardcolor(vec2 p, int id, bool vb) {\n    if (id < 0)return load_id_cardcolor(p, id, vec4(0.));\n    vec4 card_vals = vb ? load_card(id) : load_card2(id);\n    return load_id_cardcolor(p, int(card_vals.w), card_vals);\n}\n\n// same as load_card logic\n\nvec4 load_board(int idx) {\n    ivec2 id = ivec2(3, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_board2(int idx) {\n    ivec2 id = ivec2(4, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_eff_buf() {\n    ivec2 id = ivec2(2, 3) ;\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec3 get_boardccolor(vec2 p, int id, bool vb) {\n    vec4 card_vals = vb ? load_board(id) : load_board2(id);\n    if (id < 0)return load_id_cardcolor(p, id, vec4(0.));\n    vec3 tcc = load_id_cardcolor(p, int(card_vals.w), card_vals);\n    if (int(card_vals.y) == 1) {\n        float v2 = -p.y + 0.12 + zv;\n        float dxx = (sdCircle(vec2(abs(p.x), p.y) - vec2(0.08, 0.12), 0.03));\n        float dx = 1. - max(SS(zv / 2., 0.00 - zv / 2., dxx), SS(0.00, 0.03, v2));\n        if (dx < 1.) {\n            float nx = card_fbg((p + card_vals.w)*9.);\n            tcc = mix(tcc, -tcc + cef7a / (nx * (1. - dx * 0.99)), dx * (1. - nx)*0.6);\n            clamp(tcc, vec3(0.), vec3(1.));\n        }\n    }\n    if (card_vals.y < 0.) {\n        float anim_t2 = 1. - get_animstate(clamp((g_time - (-card_vals.y) - 0.5)*2., 0., 1.));\n        float nx = card_fbg((p + card_vals.w)*9.);\n        tcc = mix((((tcc * (anim_t2) + cef4a / 3. * (1. - anim_t2))) / (nx)), tcc, anim_t2);\n    }\n    return tcc;\n}\n\nvec3 get_boardeff(vec2 p) {\n    vec4 card_vals = load_eff_buf();\n    return load_id_cardcolor(p, int(card_vals.w), card_vals);\n}\n\nvec4 card_put_ani_c(vec2 p) {\n    vec3 col = vec3(0.);\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    float d = 1.;\n    const float angle_pos = 0.045;\n    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n    if ((anim_t2 == 0.) || (allData.flag1 == 1.))return vec4(col, 1.);\n    float anim_t = 1. - get_animstate(clamp((g_time - allData.card_put_anim)*4., 0., 1.));\n    float ad = allData.cards_player + 1. - 1. * (0.);\n    float tv = 0.5 - (ad - (ad / 2.) - allData.card_hID_put_anim);\n    vec2 epos = vec2(0., -0.08) * 1.;\n    vec2 tuv = p;\n    int ts = int(load_eff_buf().w);\n    if (ts < 0) {\n        if (anim_t > 0.)\n            tuv = (p + card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.)) * MD(angle_pos * tv * anim_t) + epos - shift_pos * tv;\n        else\n            tuv = p + (card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv) * anim_t2 + (1. - anim_t2)*(vec2(0.18 / 2., 0.1 + 0.005 + zv / 2.) + vec2(0.18 * 2. - 0.18 * allData.card_bID_put_anim, 0.));\n        d = card(tuv);\n        vec3 cardcol = vec3(0.);\n        if (d < 1.)\n            cardcol = get_boardccolor(tuv, int(allData.card_bID_put_anim), true);\n\n        float ds = card_shadow(tuv);\n        ds = (1., ds + 1. - anim_t2);\n        col = col * (ds);\n        col = mix(cardcol, col, d);\n        d = min(ds, d);\n    } else {\n        float td = 1.;\n        float nx = 1.;\n        tuv = (p + card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.)) * MD(angle_pos * tv * anim_t) + epos - shift_pos*tv;\n        td = SS(0., 0.01, sdBezier(p, -(card_pos - epos * (1. - 1.) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv),\n                vec2(0., 0.12 * 2.)-(card_pos - epos * (anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv),\n                vec2(-0.18 * 3. + 0.18 / 2. + (allData.card_bID_put_anim > 9. ? allData.card_bID_put_anim - 10. : allData.card_bID_put_anim)* 0.18, (allData.card_bID_put_anim > 9. ? 0.135 : -0.12))));\n        d = card(tuv);\n        if ((d < 1.) || (td < 1.))\n            nx = card_fbg(p * 9.);\n        vec3 cardcol = vec3(0.);\n        if (d < 1.)\n            cardcol = get_boardeff(tuv);\n        float ds = card_shadow(tuv);\n        ds = (1., ds + 1. - anim_t2);\n        col = col * (ds);\n        col = mix((col + (blue / 2.) / (nx)), col, td);\n        col = mix(cardcol, col, d);\n        d = min(ds, d);\n        float tdx = d;\n        d = min(td, d);\n        d = max(d, 1. - anim_t2);\n        col = mix((((col * (0.5 + anim_t2) + blue / 3. * (1. - anim_t2)) * (1. - tdx)) / (nx)), col, anim_t2);\n    }\n\n    return vec4(col, d);\n}\n\nvec4 card_put2_ani_c(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = 1.;\n    float td = 1.;\n    if ((!allData.player_turn)&&(!allData.en_etf)) {\n        if (allData.flag3 == 1.)return vec4(col, d);\n        vec4 lbx = load_card2(2);\n        if (floor(max(lbx.x, lbx.y)) >= 0.) {\n            float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 8.), 0., 1.));\n            const vec2 card_pos = vec2(0., 0.35);\n            const vec2 shift_pos = vec2(0.1, 0.);\n            const vec2 sp_pos = vec2(-0.75, 0.35);\n            float anim_t2 = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * max(lbx.x, lbx.y)))*2., 0., 1.));\n            float anim_t = 1. - get_animstate(clamp((g_time - allData.ett - 3.5 - (2. - 2. * max(lbx.x, lbx.y)))*2., 0., 1.));\n            vec2 epos = vec2(0., -0.28) * 1.;\n            float tvg = floor(floor(max(lbx.x, lbx.y)) == 1. ? lbx.z : lbx.w);\n            float tvgz = ((tvg < 0.)&&(tvg != -100.)) ? abs(tvg) - 1. : tvg;\n            vec2 epos2 = vec2(0., -0.35 + 0.12 - 0.02 - zv) - sp_pos + (vec2(0.18 / 2., 0.1 + 0.005 + zv / 2.) + vec2(0.18 * 2. - 0.18 * (tvgz > 9. ? tvgz - 10. : tvgz), 0.));\n            vec2 tuv = p;\n            if ((anim_t > 0.) || (!(tvg >= 0.)))\n                tuv = (p + sp_pos + epos * (1. - anim_t));\n            else\n                tuv = (p + sp_pos + epos * anim_t2 + epos2 * (1. - anim_t2));\n            if (!(tvg >= 0.)&&(tvg != -100.)) {\n                td = SS(0., 0.01, sdBezier(p, -(sp_pos + epos * (1. - anim_t)),\n                        vec2(0., 0.12 * 2.)-(sp_pos + epos * (1. - anim_t)),\n                        vec2(-0.18 * 3. + 0.18 / 2. + (tvgz > 9. ? tvgz - 10. : tvgz)* 0.18, (tvgz > 9. ? 0.135 : -0.12))));\n                float anim_tl = 1. - get_animstate(clamp((g_time - allData.ett - 4. - (2. - 2. * max(lbx.x, lbx.y)))*3., 0., 1.));\n                td = max(td, anim_tl);\n            }\n            d = card(tuv);\n            vec3 cardcol = vec3(0.);\n            if (d < 1.)\n                cardcol = get_cardcolor(tuv, int(max(lbx.x, lbx.y)), false);\n\n            float ds = card_shadow(tuv);\n            ds = (1., ds + 1. - anim_t2);\n            col = col * (ds);\n            float nx = 1.;\n            if ((!(tvg >= 0.))&&((d < 1.) || (td < 1.)))\n                nx = card_fbg(p * 9.);\n            col = mix((col + (purple / 2.) / (nx)), col, td);\n            col = mix(cardcol, col, d);\n            d = min(ds, d);\n            float tdx = d;\n            if (!(tvg >= 0.)) {\n                d = min(td, d);\n                d = max(d, 1. - anim_t2);\n                col = mix((((col * (0.5 + anim_t2) + blue / 3. * (1. - anim_t2)) * (1. - tdx)) / (nx)), col, anim_t2);\n            }\n        }\n    }\n\n    return vec4(col, d);\n}\n\nvec4 card_hand(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = 1.;\n    float ds = 1.;\n    float da = d;\n    float dt = 1.;\n    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n    bool pass = false;\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        return vec4(col, 1.);\n    }\n    if ((p.y>-0.1) || (p.x<-0.65)) { //save GPU time\n        if ((anim_t2 == 0.)&&(allData.player_turn))return vec4(col, 1.);\n        else\n            pass = true;\n    }\n    vec2 op = p;\n    float anim_t2z = get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    if (allData.player_turn)p.y += 0.08 * (1. - anim_t2z);\n    else p.y += 0.08 * (anim_t2z);\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    const float angle_pos = 0.045;\n    float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n    vec3 cardcol = vec3(0.);\n    vec2 tuv = vec2(0.);\n    float ec = -1.;\n    ec = allData.card_hID_put_anim;\n    float locsc = -1.;\n    if (allData.flag1 == 1.)locsc = ec;\n    else locsc = allData.last_selected_card;\n    vec4 col_t = card_put2_ani_c(op); //draw en cards\n    da = min(da, col_t.w); // min to off shadow blink on draw\n    col = mix(col_t.rgb, col, col_t.w);\n    if (!pass) {\n        if (op.y<-0.2) {\n            //optimization, calculating tiles to display only this tile+2 previous+2 next without loop all 10 cards(when hand maxsize)\n            //save ~15% GPU load on it\n            float ist = floor((p.x + (0.4) * (allData.cards_player / 10.)) / 0.1) - 2.;\n            float ien = ist + 4.; //change +4. to +3. to display tile borders\n            if (allData.cards_player > 1.)\n                ist = clamp(ist, 0., allData.cards_player - 1.);\n            else ist = 0.;\n            for (float i = ist+float(min(0,iFrame)); i < allData.cards_player; i++) {\n                if (i > ien)break;\n                da = min(d, da);\n                //calc card position shift\n                float avx = 0.;\n                tuv = vec2(0.);\n                if ((anim_t2 != 0.)&&(allData.flag1 == 0.)) {\n                    if (i >= ec)avx = 1.;\n                    if (i < ec)avx = -1.;\n                    avx *= anim_t2;\n                }\n                if (i != locsc) {\n                    if ((i + avx) + 2. > allData.cards_player + avx) {\n                        float tv = 0.5 - ((allData.cards_player + avx) - ((allData.cards_player + avx) / 2.) - (i + avx));\n                        tuv = (p + card_pos) * MD(angle_pos * tv * (1. - anim_t)) - shift_pos * tv * (1. - anim_t) + vec2(sp_pos.x, 0.) * anim_t;\n                        d = card(tuv);\n                        if (d < 1.)\n                            cardcol = get_cardcolor(tuv, int(i), true);\n                    } else {\n                        float ad = (allData.cards_player + avx) - 1. * (anim_t);\n                        float tv = 0.5 - (ad - (ad / 2.) - (i + avx));\n                        tuv = (p + card_pos) * MD(angle_pos * tv) - shift_pos*tv;\n                        d = card(tuv);\n                        if (d < 1.)\n                            cardcol = get_cardcolor(tuv, int(i), true);\n                    }\n                    ds = card_shadow(tuv);\n                    col = col * (ds);\n                    col = mix(cardcol, col, d);\n                    d = min(ds, d);\n                    da = (d * da); // not min(), min display sdf borders(not nice)\n                }\n            }\n            ds = card_shadow(op + sp_pos);\n            if (ds < 1.) {\n                d = card(op + sp_pos);\n                col = col * (ds);\n                col = mix(get_cardcolor(op + sp_pos, -1, true), col, d);\n                d = min(ds, d);\n                da = min(d, da); // off shadow on draw\n            }\n        }\n        //draw selected card\n        if (locsc >= 0.) {\n            float ad = allData.cards_player - 1. * (anim_t);\n            float tv = 0.5 - (ad - (ad / 2.) - locsc);\n            anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n            vec2 epos = vec2(0., -0.08) * anim_t;\n            tuv = (p + card_pos) * MD(angle_pos * tv) + epos - shift_pos*tv;\n            d = card(tuv);\n            if (d < 1.)\n                cardcol = get_cardcolor(tuv, int(locsc), true);\n            ds = card_shadow(tuv);\n            col = col * (ds);\n            col = mix(cardcol, col, d);\n            d = min(ds, d);\n            da = (d * da); // same not min()\n        }\n    }\n    col_t = card_put_ani_c(p);\n    da = (da * col_t.w); // same not min()\n    col = mix(col_t.rgb, col, col_t.w);\n    return vec4(col, da);\n}\n\nint card_baord_id(vec2 p) {\n    return int(floor((p.x + 0.18 * 3.) / 0.18));\n}\n\nint hpmp_get_hit(vec2 p) {\n    if ((allData.player_etf) || (allData.player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\nint card_get_hit(vec2 p) {\n    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), abs(p.y - 0.02) - 0.125 - zv / 2.);\n    float d = card(pt);\n    bool bv = (p.y - 0.02 < 0.);\n    d = max(d, step(0.18 * 3. + zv / 2., abs(p.x)));\n    if (d < 1.)return bv ? card_baord_id(p) : 10 + card_baord_id(p);\n    return -1;\n}\n\nint turnctrl_get_hit(vec2 p) {\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));\n    float d = SS(0., zv, sdBox(pt, vec2(0.04, 0.008)) - 0.02);\n    if (d < 1.)return 1;\n    return -1;\n}\n\nvoid card_get_select(vec2 p) {\n    float d = 1.;\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    const float angle_pos = 0.045;\n    allData.this_selected_card = -1.;\n    float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n    float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 6.5), 0., 1.));\n    if ((allData.card_draw > 0.) || (anim_t > 0.) || (allData.player_etf) || ((anim_t2zb == 0.)&&(!allData.player_turn)&&(!allData.en_etf)))return;\n    float anim_t2z = get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    if (allData.player_turn)p.y += 0.08 * (1. - anim_t2z);\n    else p.y += 0.08 * (anim_t2z);\n    for (float i = float(min(0,iFrame)); i < allData.cards_player + 1.; i++) {\n        if (i + 1. > allData.cards_player) {\n            break;\n        }\n        if (i + 2. > allData.cards_player) {\n            float tv = 0.5 - (allData.cards_player - (allData.cards_player / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv * (1. - anim_t)) - shift_pos * tv * (1. - anim_t) + vec2(sp_pos.x, 0.) * anim_t);\n        } else {\n            float ad = allData.cards_player - 1. * (anim_t);\n            float tv = 0.5 - (ad - (ad / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv) - shift_pos * tv);\n        }\n        if ((d < 1.)) {\n            allData.this_selected_card = i;\n        }\n    }\n    return;\n}\n\nfloat pattern_bg(vec2 p) {\n    float d = 0.;\n    p = vec2(mod(p.x + 0.01 * (floor((mod(p.y, 0.04) - 0.02) / 0.02)), 0.02) - 0.01, mod(p.y, 0.02) - 0.01);\n    d = SS(-0.001, 0.001, sdCircle(p, 0.0035));\n    return d;\n}\n\nvec3 gr_bg(vec2 p) {\n    vec3 col = mix(gc2, wc, SS(0., 0.2, abs(mod(p.x - 0.2, .4) - 0.2)));\n    col = mix(0.2 * col, wc, SS(0., 0.3, abs(mod(p.x + 0.1, .6) - 0.3)));\n    return col;\n}\n\nfloat glow(float x, float str, float dist) {\n    return dist / pow(x, str);\n}\n\nfloat sinSDF(vec2 st, float A, float offset, float f, float phi) {\n    return abs((st.y - offset) + sin(st.x * f + phi) * A);\n}\n\nfloat egbg(vec2 p) {\n    float d = 0.;\n    d = step(.3, abs(p.y));\n    return d;\n}\n\nfloat text_d(vec2 U) {\n    initMsg;C(68);C(101);C(102);C(101);C(97);C(116);endMsg;\n}\n\nfloat text_w(vec2 U) {\n    initMsg;C(86);C(105);C(99);C(116);C(111);C(114);C(121);endMsg;\n}\n\nfloat text_res(vec2 U) {\n    initMsg;C(82);C(101);C(115);C(116);C(97);C(114);C(116);endMsg;\n}\n\nvec4 main_c_egscr(in vec2 p, bool gx, float stx) {\n    stx += .5;\n    vec2 op = p;\n    p.y = mod(p.y, 0.6) - 0.3;\n    vec2 st = p + 0.5;\n    vec3 col = vec3(0.0);\n    float time = g_time / 2.0;\n    float str = 0.6;\n    float dist = 0.02;\n    float nSin = 4.0;\n    float timeHalfInv = -time * sign(st.x - 0.5);\n    float am = cos(st.x * 3.0);\n    float offset = 0.5 + sin(st.x * 12.0 + time) * am * 0.05;\n    float i = 0.;\n\n    for (float i = 0.; i < nSin; i++) {\n        col += glow(sinSDF(st, am * 0.2, offset, 6.0, timeHalfInv + i * 2.0 * PI / nSin), str, dist);\n    }\n    vec3 s = cos(6. * st.y * vec3(1, 2, 3) - time * vec3(1, -1, 1)) * 0.5;\n    float cut = (st.x + (s.x + s.y + s.z) / 33.0);\n    float vf = 3.5;\n    col = vec3(abs(smoothstep(-0.01 - (gx ? vf * SS(stx, stx + 2., g_time) : -vf * SS(stx + 2., stx, g_time)), -0.03 - (!gx ? vf * SS(stx, stx + 2., g_time) : -vf * SS(stx + 2., stx, g_time)), 0.5 - cut) - clamp(col, 0.0, 1.0)));\n    float d = SS(0.6, 0.59, abs(p.y) + 0.3);\n    float dv = SS(0., 0.01, sdVesica(vec2(abs(p.y), p.x) + vec2(0. - 0.3, 0.), 0.3 * SS(stx + 1., stx + 1. + 1., g_time), 0.25 * SS(stx + 1., stx + 1. + 1., g_time)));\n    d = (d * dv);\n    float dz = 0.;\n    if (dv < 1.)\n        if (gx)\n            dz = (1. - dv) * text_d(op * 15. + vec2(2.25, 0.45)) * SS(stx + 1.5, stx + 1.5 + 1., g_time);\n        else\n            dz = (1. - dv) * text_w(op * 15. + vec2(2.4, 0.45)) * SS(stx + 1.5, stx + 1.5 + 1., g_time);\n    col = mix(vec3(0.), col, d);\n    col = mix(col, vec3(.85), dz);\n    return vec4(col, 1.0);\n}\n\nvec4 main_c_wl(vec2 p) {\n    vec3 col = vec3(0.);\n    float dx = egbg(p);\n    float stx = allData.egt + 01.;\n    dx = max(dx, SS(res_g.x * SS(stx + 0.5, stx + 2. + 0.5, g_time), 1.2 * res_g.x * SS(stx, stx + 2., g_time), p.x + res_g.x / 2.));\n    col = mix(main_c_egscr(p, allData.player_hpmp.x < 1., stx).rgb, col, dx);\n    col += (rand(p) - .5)*.07;\n    if ((abs(p.x) < 0.15)&&(p.y<-0.3)) {\n        float dxx = 1.25 - text_res(p * 15. + vec2(2.4, 05.8));\n        col = mix(vec3(1.), col, dxx);\n        dx = min(max(dxx, (1. - SS(stx + 02.5, stx + 2. + 02.5, g_time))), dx);\n    }\n    return vec4(col, dx);\n}\n\nvec4 main_c_bg(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = pattern_bg(p);\n    col = mix(vec3(0.), gc, d);\n    float vignetteAmt = 1. - dot(p, p);\n    col *= vignetteAmt;\n    col += (rand(p) - .5)*.07;\n    col *= SS(-0.04, 0.1, abs(abs(p.y) - .3));\n    col = mix(col, sqrt(gr_bg(p)*(1. - SS(-0.04, 0.1, abs(abs(p.y) - .3)))), -step(0.3 + 0.002, abs(p.y)) + step(0.3 - 0.002, abs(p.y)));\n    bool bv = (p.y - 0.02) < 0.;\n    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), -(abs(p.y - 0.02) - 0.125 - zv / 2.));\n    d = card(pt);\n    float dod = step(0.18 * 3., abs(p.x));\n    d = max(d, dod);\n    vec3 ec = ((bv ? 0.75 * blue : red)*(1. - d));\n    col += col * ec;\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        return vec4(col, 1.);\n    }\n    //both sides of board\n    if (dod < 1.)\n        if (((!allData.en_etf)&&(bv)) || ((!allData.player_etf)&&(!bv))) {\n            if (d < 1.) {\n                vec4 lb = bv ? load_board(card_baord_id(p)) : load_board2(card_baord_id(p));\n                //display selection of target cells base on card type\n                if ((int(lb.w) == c_bgr)) {\n                    if ((bv)&&(allData.last_selected_card >= 0.) && (allData.player_turn) &&\n                            is_c_cr((int(load_card(int(allData.last_selected_card)).w)))) {\n                        float dx = SS(0.01, -0.05, (sdBox(pt, vec2(0.08, 0.12))));\n                        float anim_t = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                        float nx = card_fbg(p * 9.);\n                        col = mix(col + ((ec / 5. * (1. - dx)) / (5. * nx * (dx))) * anim_t, col, d);\n                    }\n                } else {\n                    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n                    if ((card_baord_id(p) == int(allData.card_bID_put_anim))&&(bv)&&(anim_t2 > 0.)&&(int(load_eff_buf().w) < 0)) {\n                    } else {\n                        float anim_t2x = 0.;\n                        if (lb.y < 0.) {\n                            anim_t2x = get_animstate(clamp((g_time - (-lb.y) - 0.5)*2., 0., 1.));\n                        }\n                        if (!bv)pt.y *= -1.;\n                        col = mix(get_boardccolor(pt, card_baord_id(p), bv), col, max(d, anim_t2x));\n                        int crr = (int(load_card(int(allData.last_selected_card)).w));\n                        if ((allData.last_selected_card >= 0.) && (allData.player_turn) &&\n                                is_c_cr((int(lb.w)))&&((c_he1 == crr) || (crr == c_at1) || (crr == c_pat) || (crr == c_de))) {\n                            float dx = SS(0.01, -0.05, (sdBox(pt, vec2(0.08, 0.12))));\n                            float anim_t = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                            float nx = card_fbg(p * 9.);\n                            col = mix(col * (1. - 0.35 * anim_t)+ (((c_pat == crr) ? blue : ((c_he1 == crr) ? green : red)) * 2.)*((ec / 5. * (1. - dx)) / (5. * nx * (dx))) * anim_t, col, d);\n                        }\n                    }\n                }\n            }\n        } else {\n            //card hit animation\n            vec4 lb = ((allData.en_etf)&&(bv)) ? load_board(card_baord_id(p)) : load_board2(card_baord_id(p));\n            float anim_t2za = min(get_animstate(clamp((g_time - allData.ett - 0.4 * float(card_baord_id(p)))*3., 0., 1.)),\n                    1. - get_animstate(clamp((g_time - allData.ett - .4 - 0.4 * float(card_baord_id(p)))*8., 0., 1.)));\n            anim_t2za *= 1. - allData.flag3;\n            if (int(lb.w) != c_bgr) {\n                p.y += (((allData.en_etf)&&(bv)) ? 1. : -1.)*0.06 * anim_t2za;\n                bv = (p.y - 0.02) < 0.;\n                if (((allData.en_etf)&&(bv)) || ((allData.player_etf)&&(!bv))) {\n                    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), -(abs(p.y - 0.02) - 0.125 - zv / 2.));\n                    d = card(pt);\n                    d = max(d, step(0.18 * 3., abs(p.x)));\n                    if (d < 1.) {\n                        float anim_t2zb = 1. - min(get_animstate(clamp((g_time - allData.ett)*6., 0., 1.)),\n                                1. - get_animstate(clamp((g_time - allData.ett - 2.5)*4., 0., 1.)));\n                        anim_t2zb = max(anim_t2zb, allData.flag3);\n                        if (!bv)pt.y *= -1.;\n                        col = mix(get_boardccolor(pt, card_baord_id(p), bv), col, d);\n                        float ddc = sdTriangleIsosceles(vec2(0.06, 0.03), vec2(pt.x, (bv ? 1. : -1.)*-pt.y) + vec2(0., 0.5 + 0.125)) - 0.02;\n                        float ddz = SS(-0.01, 0.02, ddc + 0.025);\n                        col = clamp(col, vec3(0.), vec3(1.));\n                        if (bv)\n                            col = mix(-col + 0.25 * blue / ddz, col, min(1., max(anim_t2zb, ddz) + 0.5));\n                        else\n                            col = mix(-col + 0.25 * purple / ddz, col * (min(1., max(anim_t2zb, ddz) + 0.5)), min(1., max(anim_t2zb, ddz) + 0.5));\n                    }\n                }\n            } else {\n                if (d < 1.)\n                    col *= (0.5 + 0.5 * (1. - anim_t2za));\n            }\n        }\n\n\n    return vec4(col, 1.);\n}\n\nvec4 draw_turnctrl(vec2 p) {\n    vec3 col = vec3(0.);\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));\n    float d = SS(0., zv, sdRhombus(pt, vec2(0.06, 0.12)));\n    float bxx = sdBox(pt, vec2(0.04, 0.008)) - 0.02;\n    float dy = SS(0., zv, bxx);\n    float dx = 1.;\n    if (dy < 1.)\n        dx = 1. - text_end(vec2(pt.x, pt.y)*15. + vec2(01.5, 0.5));\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = SS(-0.01, 0.02, abs(bxx));\n    float anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n    float anim_t2z = 1. - get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    float anim_t2za = 1. - get_animstate(clamp((g_time - allData.ett), 0., 1.));\n    col = mix(bv ? (allData.player_turn ? green * (1. - anim_t2z) : green * anim_t2z) : (allData.player_turn ? green * anim_t2z : green * (1. - anim_t2z)), vec3(0.), d);\n    col = mix(cw2, col, dy);\n    col = mix(vec3(0.), col, dx);\n    if (allData.player_turn) {\n        col = mix(0.5 * (allData.player_hpmp.y > 0. ? cef4a : mix(redw, green, anim_t)) / dz, col, dz);\n    } else {\n        col = mix(0.5 * (green * anim_t2za) / dz, col, dz);\n    }\n    d = min(min(min(d + 0.65, dy + 0.4), dz), dx);\n    return vec4(clamp(col, vec3(0.), vec3(4.)), min(1., d));\n}\n\nvec4 draw_hpmp(vec2 p) {\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    vec3 col = vec3(0.);\n    bool bv = (p.y - 0.02 < 0.);\n    float d = 1.;\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.) {\n        d = hp_s(pt);\n        float nx = 1.;\n        if (d < 1.)\n            nx = card_fbg(p * 18.);\n        float ddx = hp_s3(pt + vec2(.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));\n        float ddx2 = hp_s3(pt + vec2(-.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));\n        float vx = (bv ? allData.player_hpmp.x / 98. : allData.en_hpmp.x / 98.)*0.12 - 0.12 / 2.;\n        float nxx = step(vx, pt.x);\n        col = mix((bv ? green : redw) / (nx * 3.), col, max(d, nxx));\n        float dx = 1. - text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, 0.), bv ? allData.player_hpmp.x : allData.en_hpmp.x);\n        col = mix(white, col, dx);\n        d = min(d, dx);\n        vec3 tccx = vec3(0.);\n        int crr = (int(load_card(int(allData.last_selected_card)).w));\n        if (allData.player_turn)\n            if (bv) {\n                if (((c_mn == crr) || (c_he2 == crr))&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {\n                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);\n                    tccx = clamp((c_mn == crr ? blue : green) / (100. * td), vec3(0.), vec3(4.));\n                    tccx = tccx*anim_tx;\n                }\n            } else {\n                if ((c_at2 == crr)&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {\n                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);\n                    tccx = clamp(redw / (100. * td), vec3(0.), vec3(4.));\n                    tccx = tccx*anim_tx;\n                }\n            }\n        col = mix(tccx, col, max(dz + 0.35, 1. - d));\n        d = min(d, dz + 0.35);\n        float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*3., 0., 1.));\n        if (allData.flag1 == 1.)anim_t2 = 0.;\n        bool bvx = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 0.;\n        bool bvy = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 1.;\n        if ((!allData.player_turn)&&(!allData.en_etf)) {\n\n            float anim_t2x = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * allData.en_hpmp.y))*2., 0., 1.));\n            anim_t2 = anim_t2x;\n        }\n        anim_t2 = allData.player_turn ? (bv ? anim_t2 : 0.) : (!bv ? anim_t2 : 0.);\n        col = mix(col, clamp((bvx ? blue : blue * anim_t2) / ddx, vec3(0.), vec3(4.)), 1. - ddx);\n        col = mix(col, clamp((bvy ? blue : (bvx ? blue * anim_t2 : vec3(0.))) / ddx2, vec3(0.), vec3(4.)), 1. - ddx2);\n        d = min(d, ddx * ddx2);\n    }\n    if (allData.en_etf || allData.player_etf) {\n        float anim_t2zb = 1. - min(get_animstate(clamp((g_time - allData.ett - 0.1)*3., 0., 1.)),\n                1. - get_animstate(clamp((g_time - allData.ett - 2.8)*4., 0., 1.)));\n        dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.07));\n        if (dz < 1.) {\n            float dxz = 1.;\n            if (floor(allData.egt) > 0.)\n                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7), allData.egt));\n            else\n                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n0(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7)));\n            dxz = max(anim_t2zb, dxz);\n            col = mix(redw, col, dxz);\n            d = min(d, dxz);\n        }\n    }\n    return vec4(col, min(1., d + 0.35));\n}\n\nvec4 main_c(vec2 p) {\n    vec3 col = vec3(0.);\n    //col = main_c_bg(p).rgb;\n    vec4 col_t = vec4(0.);\n    float dz = 0.;\n    if (allData.flag3 == 1.) {\n        dz = SS(allData.egt + 1., allData.egt + 1.5, g_time);\n    }\n    /*col_t = draw_hpmp(p);\n    col = mix(col_t.rgb, col, col_t.w);\n    col_t = draw_turnctrl(p);\n    col = mix(col_t.rgb, col, max(col_t.w, dz));\n    */\n    col=texture(iChannel1,p/res_g+0.5).rgb;\n    col_t = card_hand(p);\n    col = mix(col_t.rgb, col, max(col_t.w, dz));/*\n    if (allData.flag3 == 1.) {\n        col_t = main_c_wl(p);\n        col = mix(col_t.rgb, col, col_t.w);\n    }*/\n    return vec4(col, 1.);\n}\n\nfloat zoom_calc(float zv) {\n    float ex = 0.0025 * ((1080. * zv) / (iResolution.y));\n    return ex;\n}\n\nvoid init_globals() {\n    zv = zoom_calc(1.);\n    res_g = res;\n    g_time = iTime + extime;\n}\n\nvec2 click_control() {\n    return abs(iMouse.zw) / iResolution.y - res_g / 2.0;\n}\n\n//fix 2020\nint hpmp_get_hit_preinit(vec2 p, bool player_etf) {\n    if ((player_etf) || (player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\n\n// load last state\n\nvoid load_state(in vec2 fragCoord, bool ctrl) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 px = texelFetch(iChannel0, ivec2(2, 0), 0);\n    float cards_player = floor(px.x);\n    float flag0 = floor(px.y);\n    float cards_player_atime = (px.z);\n    float cards_player_select = floor(px.w);\n    px = texelFetch(iChannel0, ivec2(2, 2), 0);\n    float card_put_anim = (px.x);\n    float card_hID_put_anim = floor(px.y);\n    float card_bID_put_anim = floor(px.z);\n    float flag1 = floor(px.w);\n    vec2 click_pos = vec2(0.);\n    float card_select_anim=0.;\n    px = texelFetch(iChannel0, ivec2(2, 4), 0);\n    vec3 tvg = decodeval(px.x);\n    vec2 player_hpmp = tvg.yz;\n    bool player_etf = tvg.x == 1.;\n    tvg = decodeval(px.y);\n    vec2 en_hpmp = tvg.yz;\n    bool en_etf = tvg.x == 1.;\n    float ett = px.z;\n    bool player_turn = ett < 0.;\n    ett = abs(ett);\n    float flag3 = 0.;\n    float egt = px.w;\n    if ((flag0 != 1.) || (g_time < extime + 0.1)) {\n        egt = 0.;\n    } else {\n        if (player_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n        if (en_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n    }\n    if ((iMouse.z > 0.)&&(ctrl)) {\n        float anim_t2 = 1. - get_animstate(clamp((g_time - card_put_anim - 0.5)*2., 0., 1.));\n        float anim_t = get_animstate(clamp(1. - (g_time - cards_player_atime), 0., 1.));\n        if ((flag3 == 0.)&&(anim_t == 0.)&&(anim_t2 == 0.)) { //do not update mouse if anim played\n            click_pos = click_control();\n            if ((player_hpmp.y > 0.)&&((card_get_hit(click_pos) >= 0) || (hpmp_get_hit_preinit(click_pos,player_etf) > 0))) {\n                px = texelFetch(iChannel0, ivec2(2, 1), 0);\n                card_select_anim = px.z;\n            } else card_select_anim = g_time;\n        } else {\n            card_select_anim = g_time;\n        }\n    } else {\n        px = texelFetch(iChannel0, ivec2(2, 1), 0);\n        card_select_anim = px.z;\n        click_pos = px.xy;\n    }\n    px = texelFetch(iChannel0, ivec2(2, 1), 0);\n    float card_draw = floor(px.w);\n    if(flag3==1.)card_draw=0.;\n    allData = allData_struc(cards_player, card_select_anim, cards_player_atime, click_pos, -1., cards_player_select, card_put_anim, card_hID_put_anim, card_bID_put_anim, flag1, flag0,\n            player_hpmp, en_hpmp, flag3, egt, card_draw, player_turn, ett, player_etf, en_etf);\n}\n\n#ifdef NOCOMPILE\n\nfloat text_play(vec2 U) {\n    initMsg;C(80);C(76);C(65);C(89);endMsg;\n}\n\nfloat text_playex(vec2 U) {\n    initMsg;C(82);C(69);C(65);C(68);C(32);C(67);C(111);C(109);C(109);C(111);C(110);endMsg;\n}\n\nfloat text_playex2(vec2 U) {\n    initMsg;C(70);C(79);C(82);C(32);C(76);C(97);C(117);C(110);C(99);C(104);endMsg;\n}\n\nfloat text_playupd(vec2 U) {\n    initMsg;C(85);C(112);C(100);C(97);C(116);C(101);C(100);endMsg;\n}\n\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifdef NOCOMPILE\n    res_g = res;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res_g / 2.0;\n    float x = 0.;\n    vec3 col = vec3(0.);\n    if (iResolution.y > 250.) {\n        x = text_play((uv)*1.25 + vec2(res.x, res.y / 4.));\n        col = vec3(1.) * x;\n        x = text_playex((uv)*5. + vec2(res.x * 2.62, res.y * 2.));\n        col += vec3(1., 0., 0.) * x;\n        x = text_playex2((uv)*5. + vec2(res.x * 2.63, res.y * 1.2));\n        col += vec3(0., 0., 1.) * x;\n        x = text_playupd((uv)*5. + vec2(res.x * 1.5, res.y * 2.62));\n        col += vec3(0., 0.5, .5) * x;\n    } else col = vec3(text_play((uv)*1.25 + vec2(res.x, res.y / 2.)));\n    fragColor = vec4(col, 1.);\n    return;\n#else\n    init_globals();\n    load_state(fragCoord, false);\n    vec2 uv = (fragCoord.xy) / iResolution.y - res_g / 2.0;\n    vec4 ret_col = main_c(uv);\n    fragColor = ret_col;\n#endif\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/wdlGz8\n\n// using https://iquilezles.org/articles/distfunctions2d\n// using https://www.shadertoy.com/view/llyXRW\n// using https://www.shadertoy.com/view/ldKyW1\n\n// this is just \"demo\"\n// this is not \"universal UI/game engine\" this is fast code only for that game/demo\n// number cards in hand, its animation and many other thinks are hard coded(no way to change them(without very hard editing))(adding new cards/mechanics also complicated), faster for you will be rewrite the logic by you own\n\n// have fun xD\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI (4.0 * atan(1.0))\n#define TAU (2.*PI)\n#define E exp(1.)\n#define res (iResolution.xy / iResolution.y)\n\n#define texture(a,b) textureLod(a,b,0.0)\n\nstruct allData_struc {\n    float cards_player; //num of cards in player hand\n    float card_select_anim; //time of start card select animation\n    float card_add_anim; //time of start card add animation\n    vec2 mouse_pos;\n    float this_selected_card; //hand card selection\n    float last_selected_card; //hand card selection\n    float card_put_anim; //card put to board from hand\n    float card_hID_put_anim; //used only for animation removing card from hand\n    float card_bID_put_anim; //last putted card on board\n    float flag1;\n    float flag0;\n    vec2 player_hpmp;\n    vec2 en_hpmp;\n    float flag3;\n    float egt; //end game timer\n    float card_draw; //draw X cards\n    bool player_turn;\n    float ett; //end turn timer\n    bool player_etf; //used for \"cards on board hit other side\"\n    bool en_etf; //same\n};\n\nallData_struc allData;\n\nconst vec3 blue = vec3(0x90, 0xbb, 0xe4) / float(0xff);\nconst vec3 green = vec3(0x7f, 0xbe, 0x20) / float(0xff);\nconst vec3 purple = vec3(0x9e, 0x75, 0xaf) / float(0xff);\nconst vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 red = vec3(0xa6, 0x36, 0x2c) / float(0xff);\nconst vec3 redw = vec3(0xfd, 0x8c, 0x77) / float(0xff);\nconst vec3 sand = vec3(0xe9, 0xdf, 0xc3) / float(0xff);\nconst vec3 gc = vec3(0x38, 0x38, 0x38) / float(0xff);\nconst vec3 wc = vec3(0xfc, 0xfc, 0xfc) / float(0xff);\nconst vec3 gc2 = vec3(0x47, 0x47, 0x47) / float(0xff);\n\nfloat zv;\nvec2 res_g;\n\n// start time from extime value sec, for timers\n#define extime 15.\nfloat g_time;\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n    p = abs(p);\n    float b = sqrt(r * r - d * d);\n    return ((p.y - b) * d > p.x * b)\n            ? length(p - vec2(0.0, b))\n            : length(p - vec2(-d, 0.0)) - r;\n}\n\nfloat ndot(vec2 a, vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(in vec2 p, in vec2 b) {\n    vec2 q = abs(p);\n    float h = clamp((-2.0 * ndot(q, b) + ndot(b, b)) / dot(b, b), -1.0, 1.0);\n    float d = length(q - 0.5 * b * vec2(1.0 - h, 1.0 + h));\n    return d * sign(q.x * b.y + q.y * b.x - b.x * b.y);\n}\n\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n    float resa = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p * p*p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t) * t;\n        resa = dot(qos, qos);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp(t, 0.0, 1.0);\n        vec2 qos = d + (c + b * t.x) * t.x;\n        resa = dot(qos, qos);\n        qos = d + (c + b * t.y) * t.y;\n        resa = min(resa, dot(qos, qos));\n        qos = d + (c + b * t.z) * t.z;\n        resa = min(resa, dot(qos, qos));\n    }\n    return sqrt(resa);\n}\n\nfloat sdTriangleIsosceles(in vec2 q, in vec2 p) {\n    p.y -= 0.5;\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n            vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat board(vec2 p) {\n    float d = 0.;\n    d = SS(0., zv, sdBox(p, vec2(0.6, 0.3)));\n    return d;\n}\n\nfloat card_shadow(vec2 p) {\n    float d = 0.;\n    d = SS(-0.01, 0.02 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat card(vec2 p) {\n    float d = 0.;\n    d = SS(0., 0.0 + zv, sdBox(p, vec2(0.08, 0.12)));\n    return d;\n}\n\nfloat hp_s(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.06, 0.01));\n    d = SS(0., 0.0 + zv, d);\n    return d;\n}\n\nfloat hp_s2(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.045, 0.015));\n    d = SS(0., 0.0 + zv, d - 0.03);\n    return d;\n}\n\nfloat hp_s3(vec2 p) {\n    float d = 0.;\n    d = sdBox(p, vec2(0.015, 0.001));\n    d = SS(-0.001, 0.008, d);\n    return d;\n}\n\nfloat get_animstate(float timeval) {\n    return SS(0., 1., timeval);\n}\n\nconst vec3 cw2 = vec3(0xf8, 0xf9, 0xfb) / float(0xff);\nconst vec3 cb2 = vec3(0x1c, 0x25, 0x36) / float(0xff);\nconst vec3 cr2 = vec3(0xe3, 0x6b, 0x7e) / float(0xff);\nconst vec3 cr3 = vec3(0xec, 0xd0, 0x6a) / float(0xff);\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.1)));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = (sqrt(3.) - 1.) / 2.;\n    const float K2 = (3. - sqrt(3.)) / 6.;\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n    return dot(n, vec3(50.0));\n}\n\nfloat fbm(vec2 uv) {\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float f = 0.5000 * noise(uv);\n    uv = m*uv;\n    f += 0.2500 * noise(uv);\n    uv = m*uv;\n    f += 0.1250 * noise(uv);\n    uv = m*uv;\n    f += 0.0625 * noise(uv);\n    uv = m*uv;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\nfloat card_fbg(vec2 p) {\n    float tx = g_time / 2.;\n    float nx = abs(noise(p + vec2(tx * 0.5)));\n    nx += 0.5 * abs(noise((p + vec2(-tx * 0.25, tx * 0.25)) * 2.0));\n    nx += 0.25 * abs(noise((p + vec2(tx * 0.15, -tx * 0.15)) * 4.0));\n    nx += 0.125 * abs(noise((p + vec2(-tx * 0.05, -tx * 0.05)) * 8.0));\n    return nx;\n}\n\nvec3 card_nbg(vec2 p, float tv) {\n    float _s = sign(p.y) * (200.0 + (tv * 0.051));\n    float l = p.y;\n    p.y = mod(abs(p.y), 2.50);\n    p.x += _s + pow(p.y, -1.002);\n    vec3 xx = vec3(fbm(p - vec2(0.0, tv * 0.0485)));\n    float s = 3.75;\n    float m = pow(xx.x, p.y * s) + .05;\n    if (l < 0.0) {\n        m *= 0.3;\n    }\n    vec3 color = mix((m / blue), (m / sand), clamp(sin(tv / 20.) - cos(tv / 20.), 0., 1.));\n    return clamp(color, vec3(0.), vec3(1.));\n}\n\nconst vec3 cef1a = vec3(0x69, 0x64, 0x7e) / float(0xff);\nconst vec3 cef1b = vec3(0xd8, 0x79, 0x8b) / float(0xff);\nconst vec3 cef2b = vec3(0x1b, 0x5f, 0x41) / float(0xff);\nconst vec3 cef3a = vec3(0x82, 0x9d, 0xa9) / float(0xff);\nconst vec3 cef4a = vec3(0xe6, 0x73, 0x00) / float(0xff);\nconst vec3 cef6a = vec3(0xb3, 0x24, 0x00) / float(0xff);\nconst vec3 cef7a = vec3(0x33, 0x33, 0xcc) / float(0xff);\nconst vec3 cef7b = vec3(0x66, 0x99, 0xff) / float(0xff);\nconst vec3 cef8a = vec3(0x99, 0x00, 0xcc) / float(0xff);\nconst vec3 cef9a = vec3(0x00, 0x33, 0x00) / float(0xff);\n\nfloat text_hp(vec2 U) {\n    initMsg;C(72);C(80);C(58);endMsg;\n}\n\nfloat text_a(vec2 U) {\n    initMsg;C(65);C(84);C(58);endMsg;\n}\n\nfloat text_pmhp(vec2 U, int v) {\n    initMsg;C((v * 43 + 45 * (1 - v)));C(72);C(80);endMsg;\n}\n\nfloat text_pat(vec2 U) {\n    initMsg;C(43);C(65);C(84);endMsg;\n}\n\nfloat text_ko(vec2 U) {\n    initMsg;C(75);C(79);endMsg;\n}\n\nfloat text_des(vec2 U) {\n    initMsg;C(68);C(101);C(115);C(116);C(114);C(111);C(121);endMsg;\n}\n\nfloat text_drw(vec2 U) {\n    initMsg;C(68);C(114);C(97);C(119);C(32);C(50);endMsg;\n}\n\nfloat text_end(vec2 U) {\n    initMsg;C(69);C(110);C(100);endMsg;\n}\n\nfloat text_mi(vec2 U) {\n    initMsg;C(45);endMsg;\n}\n\nfloat text_n0(vec2 U) {\n    initMsg;C(48);C(48);endMsg;\n}\n\nfloat text_n(vec2 U, float num) {\n    if (num < 1.)return text_ko(U);\n    initMsg;\n    num = floor(num);\n    int maxloop = 2;\n    bool x = false;\n    if (num < 10.) {\n        num = num * 10.;\n    } else {\n        num = floor(num / 10.)+(num * 10. - floor(num / 10.)*100.);\n        if ((num < 10.))x = true;\n    }\n    while (num >= 1.0) {\n        if (maxloop-- < 1)break;\n        C((48 + int(num) % 10));\n        if (x) {\n            C(48);\n            x = false;\n        }\n        num /= 10.0;\n    }\n    endMsg;\n}\n\n\n// to load card pixels only when we need it without reading 20 pixels for every pixel, if use it in load_state\n\nvec4 load_card(int idx) {\n    ivec2 id = ivec2(0, idx) ;\n    return texelFetch(iChannel0, (id) , 0  );\n}\n\nvec4 load_card2(int idx) {\n    ivec2 id = ivec2(1, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\n\n#define c_bgr -1\n#define c_cr 0\n#define c_cr2 1\n#define c_cr3 2\n#define c_at1 3\n#define c_at2 4\n#define c_he1 5\n#define c_he2 6\n#define c_pat 7\n#define c_mn 8\n#define c_de 9\n\nvec3 decodeval(float colz) {\n    vec3 retc = vec3(0.);\n    retc.x = floor(floor(colz) / 10000.) - 1.;\n    retc.y = floor((-(retc.x + 1.)*10000. + floor(colz)) / 100.) - 1.;\n    retc.z = floor(-(retc.y + 1.)*100. - (retc.x + 1.)*10000. + floor(colz)) - 1.;\n    return retc;\n}\n\nfloat encodeval(vec3 colz) {\n    return floor(colz.r)*10000. + 10000. + floor(colz.g)*100. + 100. + floor(colz.b) + 1.;\n}\n\nvec3 decodecol(float colz) {\n    return decodeval(colz) / 98.;\n}\n\nfloat encodecol(vec3 colz) {\n    return encodeval(colz * 98.);\n}\n\nbool is_c_cr(int ix) {\n    return (ix - 3) < 0; // used only for cards in hand, they have not c_bgr(-1)\n    //return ((ix==c_cr)||(ix==c_cr2)||(ix==c_cr3));\n}\n\nfloat is_c_crf(int ix) {\n    return clamp(float(ix - 2), 0., 1.);\n}\n\nbool is_o_crf(int ix) {\n    return (((ix == c_de) || (ix == c_mn) || (ix == c_pat)));\n}\n\nfloat is_h_crf(int ix) {\n    return (((ix == c_at1) || (ix == c_at2)) ? 0. : 1.);\n}\n\nbool is_H_crf(int ix) {\n    return ((ix == c_he1) || (ix == c_he2));\n}\n\nfloat is_v_crf(int ix) {\n    return 1. - clamp(float(ix - 7), 0., 1.);\n}\n\nfloat is_d_crf(int ix) {\n    return clamp(float(ix - 8), 0., 1.);\n}\n\n\n\n// long compile time because of this function(mostly because text)\n\n// using if(id==<card_type>)return func_that_generate_unique_texture_col_for_cardID();\n// make shader work same fast (card size is small, any card-shader-background can be used)\n// but compile time will be extrimly long (using if()func(); I had 5+ min compile time on Windows, and 30 sec on Linux)\n\n// p(0,0) is card center, card size (0.08,0.12)\n\nvec3 card_ubgx(vec2 p, int id, vec4 card_vals) {\n    vec3 c1 = decodecol(card_vals.z);\n    vec3 crvals = decodeval(card_vals.x);\n    vec3 c2 = (c1 + 0.2);\n    vec3 c3 = vec3(0.);\n    vec3 c4 = p.x > 0. ? cef7a * 1.5 : cr2;\n    vec3 col;\n    vec3 colt;\n    float isc = is_c_crf(id);\n    float isv = is_v_crf(id);\n    float ish = is_h_crf(id);\n    float isd = is_d_crf(id);\n    //return isc * vec3(1. * isv, 1. * ish, 1. * isd + ((id == c_pat) ? 1. : 0.)); //this make compile time to few sec (return single color for each card type)\n    colt = mix(c1, c2, SS(-0.05, 0.18, p.y));\n    col = mix(cw2, colt, SS(0., zv, p.y + 0.05));\n    col = mix(col, c3 * isc + c4 * (1. - isc), isv * 0.65 * SS(zv / 2., 0., sdCircle(vec2(abs(p.x)*(1. - isc) + p.x*isc, p.y) - vec2(0.08 * (1. - isc) - 0.08 * isc, 0.12), 0.03)));\n    float d = isv * text_n((p + vec2(0.0765, -0.11))*40. + res_g / 2., (1. - isc) * crvals.y + isc * crvals.x);\n    col = mix(col, cw2, d);\n    if (is_c_cr(id)) {\n        d = text_n((p + vec2(-0.059, -0.11))*40. + res_g / 2., crvals.z);\n        col = mix(col, cw2, d);\n        d = 1. - text_hp((p + vec2(0.07, 0.07))*50. + res_g / 2.);\n        d = min(d, 1. - text_a((p + vec2(0.07, 0.095))*50. + res_g / 2.));\n        col = col*d;\n        d = SS(0.003 - zv / 2., 0.004 + zv / 2., sdLine(p, -vec2(0.04, 0.071), -vec2(0.04 - 0.1 * (min(1., crvals.y / 98.)), 0.071)));\n        col = mix(cr2, col, d);\n        d = SS(0.003 - zv / 2., 0.004 + zv / 2., sdLine(p, -vec2(0.04, 0.096), -vec2(0.04 - 0.1 * (min(1., crvals.z / 98.)), 0.096)));\n        col = mix(cef7a * 1.5, col, d);\n    } else {\n        if (is_o_crf(id)) {\n            if (id == c_pat) {\n                d = 1. - text_pat((p + vec2(0.045, 0.08))*15. + res_g / 2.);\n                col = mix(vec3(0.5), col, d);\n            } else if (id == c_pat) {\n                d = 1. - text_pat((p + vec2(0.045, 0.08))*15. + res_g / 2.);\n                col = mix(vec3(0.5), col, d);\n            } else {\n                if (id == c_mn) {\n                    d = 1. - text_drw((p + vec2(0.06, 0.08))*25. + res_g / 2.);\n                    col = mix(vec3(0.5), col, d);\n                } else {\n                    d = 1. - text_des((p + vec2(0.06, 0.08))*25. + res_g / 2.);\n                    col = mix(vec3(0.5), col, d);\n                }\n            }\n        } else {\n            d = 1. - text_pmhp((p + vec2(0.045, 0.08))*15. + res_g / 2., int(ish));\n            col = mix(vec3(0.5), col, d);\n        }\n    }\n    float crx2 = (id == c_cr2 ? 1. : 0.);\n    float crx3 = (id == c_cr3 ? 1. : 0.);\n    if (is_H_crf(id) || (id == c_pat) || (1. - (isv + isd) > 0.)) {\n        p.y = -p.y + 0.07;\n        ish = 0.;\n    }\n    float da = (1. - 0.3 * (1. - isv - isd) - 0.2 * (1. - ish)) * SS(0.002 * crx3 + zv / 2., 0.001 * crx3 + 0., max(crx3 * abs(sdCircle(p + vec2(0., -0.035), 0.015)), sdCircle(p + vec2(0., -0.035 + 0.035 * (1. - ish)), 0.015)));\n    float db = (isv + isd)*(0.25 * crx2 + 0.25) * SS(zv / 2., 0., sdCircle(p + vec2(0., -0.035 + 0.035 * (1. - ish)), 0.03));\n    d = 0.5 * SS(zv / 2., 0., sdBox(p + vec2(0., -0.035 - 0.015), vec2(0.015, 0.05)));\n    col = mix(col, cw2, max(min(max((1. - crx2) * da, -da * crx2 + db), 1. * (1. - isd) + SS(0.035, 0.035 - zv, p.y)), d * SS(0.1, 0.0, p.y)*(1. - ish)));\n    return col; //-card_nbg((p+vec2(0.,0.15))*8.,g_time/2.+50.*float(id));\n}\n\nvec3 load_id_cardcolor(vec2 p, int id, vec4 card_vals) {\n    if (id == c_bgr)return card_nbg((p + vec2(0., 0.15))*8., g_time);\n    return card_ubgx(p, id, card_vals);\n}\n\nvec3 get_cardcolor(vec2 p, int id, bool vb) {\n    if (id < 0)return load_id_cardcolor(p, id, vec4(0.));\n    vec4 card_vals = vb ? load_card(id) : load_card2(id);\n    return load_id_cardcolor(p, int(card_vals.w), card_vals);\n}\n\n// same as load_card logic\n\nvec4 load_board(int idx) {\n    ivec2 id = ivec2(3, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_board2(int idx) {\n    ivec2 id = ivec2(4, idx);\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec4 load_eff_buf() {\n    ivec2 id = ivec2(2, 3) ;\n    return texelFetch(iChannel0, (id) , 0 );\n}\n\nvec3 get_boardccolor(vec2 p, int id, bool vb) {\n    vec4 card_vals = vb ? load_board(id) : load_board2(id);\n    if (id < 0)return load_id_cardcolor(p, id, vec4(0.));\n    vec3 tcc = load_id_cardcolor(p, int(card_vals.w), card_vals);\n    if (int(card_vals.y) == 1) {\n        float v2 = -p.y + 0.12 + zv;\n        float dxx = (sdCircle(vec2(abs(p.x), p.y) - vec2(0.08, 0.12), 0.03));\n        float dx = 1. - max(SS(zv / 2., 0.00 - zv / 2., dxx), SS(0.00, 0.03, v2));\n        if (dx < 1.) {\n            float nx = card_fbg((p + card_vals.w)*9.);\n            tcc = mix(tcc, -tcc + cef7a / (nx * (1. - dx * 0.99)), dx * (1. - nx)*0.6);\n            clamp(tcc, vec3(0.), vec3(1.));\n        }\n    }\n    if (card_vals.y < 0.) {\n        float anim_t2 = 1. - get_animstate(clamp((g_time - (-card_vals.y) - 0.5)*2., 0., 1.));\n        float nx = card_fbg((p + card_vals.w)*9.);\n        tcc = mix((((tcc * (anim_t2) + cef4a / 3. * (1. - anim_t2))) / (nx)), tcc, anim_t2);\n    }\n    return tcc;\n}\n\nvec3 get_boardeff(vec2 p) {\n    vec4 card_vals = load_eff_buf();\n    return load_id_cardcolor(p, int(card_vals.w), card_vals);\n}\n\nvec4 card_put_ani_c(vec2 p) {\n    vec3 col = vec3(0.);\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    float d = 1.;\n    const float angle_pos = 0.045;\n    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n    if ((anim_t2 == 0.) || (allData.flag1 == 1.))return vec4(col, 1.);\n    float anim_t = 1. - get_animstate(clamp((g_time - allData.card_put_anim)*4., 0., 1.));\n    float ad = allData.cards_player + 1. - 1. * (0.);\n    float tv = 0.5 - (ad - (ad / 2.) - allData.card_hID_put_anim);\n    vec2 epos = vec2(0., -0.08) * 1.;\n    vec2 tuv = p;\n    int ts = int(load_eff_buf().w);\n    if (ts < 0) {\n        if (anim_t > 0.)\n            tuv = (p + card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.)) * MD(angle_pos * tv * anim_t) + epos - shift_pos * tv;\n        else\n            tuv = p + (card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv) * anim_t2 + (1. - anim_t2)*(vec2(0.18 / 2., 0.1 + 0.005 + zv / 2.) + vec2(0.18 * 2. - 0.18 * allData.card_bID_put_anim, 0.));\n        d = card(tuv);\n        vec3 cardcol = vec3(0.);\n        if (d < 1.)\n            cardcol = get_boardccolor(tuv, int(allData.card_bID_put_anim), true);\n\n        float ds = card_shadow(tuv);\n        ds = (1., ds + 1. - anim_t2);\n        col = col * (ds);\n        col = mix(cardcol, col, d);\n        d = min(ds, d);\n    } else {\n        float td = 1.;\n        float nx = 1.;\n        tuv = (p + card_pos - epos * (1. - anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.)) * MD(angle_pos * tv * anim_t) + epos - shift_pos*tv;\n        td = SS(0., 0.01, sdBezier(p, -(card_pos - epos * (1. - 1.) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv),\n                vec2(0., 0.12 * 2.)-(card_pos - epos * (anim_t) * abs(((ad - 1.) / 2. - allData.card_hID_put_anim) / 6.) + epos - shift_pos * tv),\n                vec2(-0.18 * 3. + 0.18 / 2. + (allData.card_bID_put_anim > 9. ? allData.card_bID_put_anim - 10. : allData.card_bID_put_anim)* 0.18, (allData.card_bID_put_anim > 9. ? 0.135 : -0.12))));\n        d = card(tuv);\n        if ((d < 1.) || (td < 1.))\n            nx = card_fbg(p * 9.);\n        vec3 cardcol = vec3(0.);\n        if (d < 1.)\n            cardcol = get_boardeff(tuv);\n        float ds = card_shadow(tuv);\n        ds = (1., ds + 1. - anim_t2);\n        col = col * (ds);\n        col = mix((col + (blue / 2.) / (nx)), col, td);\n        col = mix(cardcol, col, d);\n        d = min(ds, d);\n        float tdx = d;\n        d = min(td, d);\n        d = max(d, 1. - anim_t2);\n        col = mix((((col * (0.5 + anim_t2) + blue / 3. * (1. - anim_t2)) * (1. - tdx)) / (nx)), col, anim_t2);\n    }\n\n    return vec4(col, d);\n}\n\nvec4 card_put2_ani_c(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = 1.;\n    float td = 1.;\n    if ((!allData.player_turn)&&(!allData.en_etf)) {\n        if (allData.flag3 == 1.)return vec4(col, d);\n        vec4 lbx = load_card2(2);\n        if (floor(max(lbx.x, lbx.y)) >= 0.) {\n            float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 8.), 0., 1.));\n            const vec2 card_pos = vec2(0., 0.35);\n            const vec2 shift_pos = vec2(0.1, 0.);\n            const vec2 sp_pos = vec2(-0.75, 0.35);\n            float anim_t2 = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * max(lbx.x, lbx.y)))*2., 0., 1.));\n            float anim_t = 1. - get_animstate(clamp((g_time - allData.ett - 3.5 - (2. - 2. * max(lbx.x, lbx.y)))*2., 0., 1.));\n            vec2 epos = vec2(0., -0.28) * 1.;\n            float tvg = floor(floor(max(lbx.x, lbx.y)) == 1. ? lbx.z : lbx.w);\n            float tvgz = ((tvg < 0.)&&(tvg != -100.)) ? abs(tvg) - 1. : tvg;\n            vec2 epos2 = vec2(0., -0.35 + 0.12 - 0.02 - zv) - sp_pos + (vec2(0.18 / 2., 0.1 + 0.005 + zv / 2.) + vec2(0.18 * 2. - 0.18 * (tvgz > 9. ? tvgz - 10. : tvgz), 0.));\n            vec2 tuv = p;\n            if ((anim_t > 0.) || (!(tvg >= 0.)))\n                tuv = (p + sp_pos + epos * (1. - anim_t));\n            else\n                tuv = (p + sp_pos + epos * anim_t2 + epos2 * (1. - anim_t2));\n            if (!(tvg >= 0.)&&(tvg != -100.)) {\n                td = SS(0., 0.01, sdBezier(p, -(sp_pos + epos * (1. - anim_t)),\n                        vec2(0., 0.12 * 2.)-(sp_pos + epos * (1. - anim_t)),\n                        vec2(-0.18 * 3. + 0.18 / 2. + (tvgz > 9. ? tvgz - 10. : tvgz)* 0.18, (tvgz > 9. ? 0.135 : -0.12))));\n                float anim_tl = 1. - get_animstate(clamp((g_time - allData.ett - 4. - (2. - 2. * max(lbx.x, lbx.y)))*3., 0., 1.));\n                td = max(td, anim_tl);\n            }\n            d = card(tuv);\n            vec3 cardcol = vec3(0.);\n            if (d < 1.)\n                cardcol = get_cardcolor(tuv, int(max(lbx.x, lbx.y)), false);\n\n            float ds = card_shadow(tuv);\n            ds = (1., ds + 1. - anim_t2);\n            col = col * (ds);\n            float nx = 1.;\n            if ((!(tvg >= 0.))&&((d < 1.) || (td < 1.)))\n                nx = card_fbg(p * 9.);\n            col = mix((col + (purple / 2.) / (nx)), col, td);\n            col = mix(cardcol, col, d);\n            d = min(ds, d);\n            float tdx = d;\n            if (!(tvg >= 0.)) {\n                d = min(td, d);\n                d = max(d, 1. - anim_t2);\n                col = mix((((col * (0.5 + anim_t2) + blue / 3. * (1. - anim_t2)) * (1. - tdx)) / (nx)), col, anim_t2);\n            }\n        }\n    }\n\n    return vec4(col, d);\n}\n\nvec4 card_hand(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = 1.;\n    float ds = 1.;\n    float da = d;\n    float dt = 1.;\n    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n    bool pass = false;\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        return vec4(col, 1.);\n    }\n    if ((p.y>-0.1) || (p.x<-0.65)) { //save GPU time\n        if ((anim_t2 == 0.)&&(allData.player_turn))return vec4(col, 1.);\n        else\n            pass = true;\n    }\n    vec2 op = p;\n    float anim_t2z = get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    if (allData.player_turn)p.y += 0.08 * (1. - anim_t2z);\n    else p.y += 0.08 * (anim_t2z);\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    const float angle_pos = 0.045;\n    float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n    vec3 cardcol = vec3(0.);\n    vec2 tuv = vec2(0.);\n    float ec = -1.;\n    ec = allData.card_hID_put_anim;\n    float locsc = -1.;\n    if (allData.flag1 == 1.)locsc = ec;\n    else locsc = allData.last_selected_card;\n    vec4 col_t = card_put2_ani_c(op); //draw en cards\n    da = min(da, col_t.w); // min to off shadow blink on draw\n    col = mix(col_t.rgb, col, col_t.w);\n    if (!pass) {\n        if (op.y<-0.2) {\n            //optimization, calculating tiles to display only this tile+2 previous+2 next without loop all 10 cards(when hand maxsize)\n            //save ~15% GPU load on it\n            float ist = floor((p.x + (0.4) * (allData.cards_player / 10.)) / 0.1) - 2.;\n            float ien = ist + 4.; //change +4. to +3. to display tile borders\n            if (allData.cards_player > 1.)\n                ist = clamp(ist, 0., allData.cards_player - 1.);\n            else ist = 0.;\n            for (float i = ist+float(min(0,iFrame)); i < allData.cards_player; i++) {\n                if (i > ien)break;\n                da = min(d, da);\n                //calc card position shift\n                float avx = 0.;\n                tuv = vec2(0.);\n                if ((anim_t2 != 0.)&&(allData.flag1 == 0.)) {\n                    if (i >= ec)avx = 1.;\n                    if (i < ec)avx = -1.;\n                    avx *= anim_t2;\n                }\n                if (i != locsc) {\n                    if ((i + avx) + 2. > allData.cards_player + avx) {\n                        float tv = 0.5 - ((allData.cards_player + avx) - ((allData.cards_player + avx) / 2.) - (i + avx));\n                        tuv = (p + card_pos) * MD(angle_pos * tv * (1. - anim_t)) - shift_pos * tv * (1. - anim_t) + vec2(sp_pos.x, 0.) * anim_t;\n                        d = card(tuv);\n                        if (d < 1.)\n                            cardcol = get_cardcolor(tuv, int(i), true);\n                    } else {\n                        float ad = (allData.cards_player + avx) - 1. * (anim_t);\n                        float tv = 0.5 - (ad - (ad / 2.) - (i + avx));\n                        tuv = (p + card_pos) * MD(angle_pos * tv) - shift_pos*tv;\n                        d = card(tuv);\n                        if (d < 1.)\n                            cardcol = get_cardcolor(tuv, int(i), true);\n                    }\n                    ds = card_shadow(tuv);\n                    col = col * (ds);\n                    col = mix(cardcol, col, d);\n                    d = min(ds, d);\n                    da = (d * da); // not min(), min display sdf borders(not nice)\n                }\n            }\n            ds = card_shadow(op + sp_pos);\n            if (ds < 1.) {\n                d = card(op + sp_pos);\n                col = col * (ds);\n                col = mix(get_cardcolor(op + sp_pos, -1, true), col, d);\n                d = min(ds, d);\n                da = min(d, da); // off shadow on draw\n            }\n        }\n        //draw selected card\n        if (locsc >= 0.) {\n            float ad = allData.cards_player - 1. * (anim_t);\n            float tv = 0.5 - (ad - (ad / 2.) - locsc);\n            anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n            vec2 epos = vec2(0., -0.08) * anim_t;\n            tuv = (p + card_pos) * MD(angle_pos * tv) + epos - shift_pos*tv;\n            d = card(tuv);\n            if (d < 1.)\n                cardcol = get_cardcolor(tuv, int(locsc), true);\n            ds = card_shadow(tuv);\n            col = col * (ds);\n            col = mix(cardcol, col, d);\n            d = min(ds, d);\n            da = (d * da); // same not min()\n        }\n    }\n    col_t = card_put_ani_c(p);\n    da = (da * col_t.w); // same not min()\n    col = mix(col_t.rgb, col, col_t.w);\n    return vec4(col, da);\n}\n\nint card_baord_id(vec2 p) {\n    return int(floor((p.x + 0.18 * 3.) / 0.18));\n}\n\nint hpmp_get_hit(vec2 p) {\n    if ((allData.player_etf) || (allData.player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\nint card_get_hit(vec2 p) {\n    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), abs(p.y - 0.02) - 0.125 - zv / 2.);\n    float d = card(pt);\n    bool bv = (p.y - 0.02 < 0.);\n    d = max(d, step(0.18 * 3. + zv / 2., abs(p.x)));\n    if (d < 1.)return bv ? card_baord_id(p) : 10 + card_baord_id(p);\n    return -1;\n}\n\nint turnctrl_get_hit(vec2 p) {\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));\n    float d = SS(0., zv, sdBox(pt, vec2(0.04, 0.008)) - 0.02);\n    if (d < 1.)return 1;\n    return -1;\n}\n\nvoid card_get_select(vec2 p) {\n    float d = 1.;\n    const vec2 card_pos = vec2(0., 0.35);\n    const vec2 shift_pos = vec2(0.1, 0.);\n    const vec2 sp_pos = vec2(-0.75, 0.35);\n    const float angle_pos = 0.045;\n    allData.this_selected_card = -1.;\n    float anim_t = get_animstate(clamp(1. - (g_time - allData.card_add_anim), 0., 1.));\n    float anim_t2zb = 1. - get_animstate(clamp((g_time - allData.ett - 6.5), 0., 1.));\n    if ((allData.card_draw > 0.) || (anim_t > 0.) || (allData.player_etf) || ((anim_t2zb == 0.)&&(!allData.player_turn)&&(!allData.en_etf)))return;\n    float anim_t2z = get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    if (allData.player_turn)p.y += 0.08 * (1. - anim_t2z);\n    else p.y += 0.08 * (anim_t2z);\n    for (float i = float(min(0,iFrame)); i < allData.cards_player + 1.; i++) {\n        if (i + 1. > allData.cards_player) {\n            break;\n        }\n        if (i + 2. > allData.cards_player) {\n            float tv = 0.5 - (allData.cards_player - (allData.cards_player / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv * (1. - anim_t)) - shift_pos * tv * (1. - anim_t) + vec2(sp_pos.x, 0.) * anim_t);\n        } else {\n            float ad = allData.cards_player - 1. * (anim_t);\n            float tv = 0.5 - (ad - (ad / 2.) - i);\n            d = card((p + card_pos) * MD(angle_pos * tv) - shift_pos * tv);\n        }\n        if ((d < 1.)) {\n            allData.this_selected_card = i;\n        }\n    }\n    return;\n}\n\nfloat pattern_bg(vec2 p) {\n    float d = 0.;\n    p = vec2(mod(p.x + 0.01 * (floor((mod(p.y, 0.04) - 0.02) / 0.02)), 0.02) - 0.01, mod(p.y, 0.02) - 0.01);\n    d = SS(-0.001, 0.001, sdCircle(p, 0.0035));\n    return d;\n}\n\nvec3 gr_bg(vec2 p) {\n    vec3 col = mix(gc2, wc, SS(0., 0.2, abs(mod(p.x - 0.2, .4) - 0.2)));\n    col = mix(0.2 * col, wc, SS(0., 0.3, abs(mod(p.x + 0.1, .6) - 0.3)));\n    return col;\n}\n\nfloat glow(float x, float str, float dist) {\n    return dist / pow(x, str);\n}\n\nfloat sinSDF(vec2 st, float A, float offset, float f, float phi) {\n    return abs((st.y - offset) + sin(st.x * f + phi) * A);\n}\n\nfloat egbg(vec2 p) {\n    float d = 0.;\n    d = step(.3, abs(p.y));\n    return d;\n}\n\nfloat text_d(vec2 U) {\n    initMsg;C(68);C(101);C(102);C(101);C(97);C(116);endMsg;\n}\n\nfloat text_w(vec2 U) {\n    initMsg;C(86);C(105);C(99);C(116);C(111);C(114);C(121);endMsg;\n}\n\nfloat text_res(vec2 U) {\n    initMsg;C(82);C(101);C(115);C(116);C(97);C(114);C(116);endMsg;\n}\n\nvec4 main_c_egscr(in vec2 p, bool gx, float stx) {\n    stx += .5;\n    vec2 op = p;\n    p.y = mod(p.y, 0.6) - 0.3;\n    vec2 st = p + 0.5;\n    vec3 col = vec3(0.0);\n    float time = g_time / 2.0;\n    float str = 0.6;\n    float dist = 0.02;\n    float nSin = 4.0;\n    float timeHalfInv = -time * sign(st.x - 0.5);\n    float am = cos(st.x * 3.0);\n    float offset = 0.5 + sin(st.x * 12.0 + time) * am * 0.05;\n    float i = 0.;\n\n    for (float i = 0.; i < nSin; i++) {\n        col += glow(sinSDF(st, am * 0.2, offset, 6.0, timeHalfInv + i * 2.0 * PI / nSin), str, dist);\n    }\n    vec3 s = cos(6. * st.y * vec3(1, 2, 3) - time * vec3(1, -1, 1)) * 0.5;\n    float cut = (st.x + (s.x + s.y + s.z) / 33.0);\n    float vf = 3.5;\n    col = vec3(abs(smoothstep(-0.01 - (gx ? vf * SS(stx, stx + 2., g_time) : -vf * SS(stx + 2., stx, g_time)), -0.03 - (!gx ? vf * SS(stx, stx + 2., g_time) : -vf * SS(stx + 2., stx, g_time)), 0.5 - cut) - clamp(col, 0.0, 1.0)));\n    float d = SS(0.6, 0.59, abs(p.y) + 0.3);\n    float dv = SS(0., 0.01, sdVesica(vec2(abs(p.y), p.x) + vec2(0. - 0.3, 0.), 0.3 * SS(stx + 1., stx + 1. + 1., g_time), 0.25 * SS(stx + 1., stx + 1. + 1., g_time)));\n    d = (d * dv);\n    float dz = 0.;\n    if (dv < 1.)\n        if (gx)\n            dz = (1. - dv) * text_d(op * 15. + vec2(2.25, 0.45)) * SS(stx + 1.5, stx + 1.5 + 1., g_time);\n        else\n            dz = (1. - dv) * text_w(op * 15. + vec2(2.4, 0.45)) * SS(stx + 1.5, stx + 1.5 + 1., g_time);\n    col = mix(vec3(0.), col, d);\n    col = mix(col, vec3(.85), dz);\n    return vec4(col, 1.0);\n}\n\nvec4 main_c_wl(vec2 p) {\n    vec3 col = vec3(0.);\n    float dx = egbg(p);\n    float stx = allData.egt + 01.;\n    dx = max(dx, SS(res_g.x * SS(stx + 0.5, stx + 2. + 0.5, g_time), 1.2 * res_g.x * SS(stx, stx + 2., g_time), p.x + res_g.x / 2.));\n    col = mix(main_c_egscr(p, allData.player_hpmp.x < 1., stx).rgb, col, dx);\n    col += (rand(p) - .5)*.07;\n    if ((abs(p.x) < 0.15)&&(p.y<-0.3)) {\n        float dxx = 1.25 - text_res(p * 15. + vec2(2.4, 05.8));\n        col = mix(vec3(1.), col, dxx);\n        dx = min(max(dxx, (1. - SS(stx + 02.5, stx + 2. + 02.5, g_time))), dx);\n    }\n    return vec4(col, dx);\n}\n\nvec4 main_c_bg(vec2 p) {\n    vec3 col = vec3(0.);\n    float d = pattern_bg(p);\n    col = mix(vec3(0.), gc, d);\n    float vignetteAmt = 1. - dot(p, p);\n    col *= vignetteAmt;\n    col += (rand(p) - .5)*.07;\n    col *= SS(-0.04, 0.1, abs(abs(p.y) - .3));\n    col = mix(col, sqrt(gr_bg(p)*(1. - SS(-0.04, 0.1, abs(abs(p.y) - .3)))), -step(0.3 + 0.002, abs(p.y)) + step(0.3 - 0.002, abs(p.y)));\n    bool bv = (p.y - 0.02) < 0.;\n    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), -(abs(p.y - 0.02) - 0.125 - zv / 2.));\n    d = card(pt);\n    float dod = step(0.18 * 3., abs(p.x));\n    d = max(d, dod);\n    vec3 ec = ((bv ? 0.75 * blue : red)*(1. - d));\n    col += col * ec;\n    if ((allData.flag0 != 1.) || (g_time < extime + 0.1)) {\n        return vec4(col, 1.);\n    }\n    //both sides of board\n    if (dod < 1.)\n        if (((!allData.en_etf)&&(bv)) || ((!allData.player_etf)&&(!bv))) {\n            if (d < 1.) {\n                vec4 lb = bv ? load_board(card_baord_id(p)) : load_board2(card_baord_id(p));\n                //display selection of target cells base on card type\n                if ((int(lb.w) == c_bgr)) {\n                    if ((bv)&&(allData.last_selected_card >= 0.) && (allData.player_turn) &&\n                            is_c_cr((int(load_card(int(allData.last_selected_card)).w)))) {\n                        float dx = SS(0.01, -0.05, (sdBox(pt, vec2(0.08, 0.12))));\n                        float anim_t = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                        float nx = card_fbg(p * 9.);\n                        col = mix(col + ((ec / 5. * (1. - dx)) / (5. * nx * (dx))) * anim_t, col, d);\n                    }\n                } else {\n                    float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*2., 0., 1.));\n                    if ((card_baord_id(p) == int(allData.card_bID_put_anim))&&(bv)&&(anim_t2 > 0.)&&(int(load_eff_buf().w) < 0)) {\n                    } else {\n                        float anim_t2x = 0.;\n                        if (lb.y < 0.) {\n                            anim_t2x = get_animstate(clamp((g_time - (-lb.y) - 0.5)*2., 0., 1.));\n                        }\n                        if (!bv)pt.y *= -1.;\n                        col = mix(get_boardccolor(pt, card_baord_id(p), bv), col, max(d, anim_t2x));\n                        int crr = (int(load_card(int(allData.last_selected_card)).w));\n                        if ((allData.last_selected_card >= 0.) && (allData.player_turn) &&\n                                is_c_cr((int(lb.w)))&&((c_he1 == crr) || (crr == c_at1) || (crr == c_pat) || (crr == c_de))) {\n                            float dx = SS(0.01, -0.05, (sdBox(pt, vec2(0.08, 0.12))));\n                            float anim_t = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                            float nx = card_fbg(p * 9.);\n                            col = mix(col * (1. - 0.35 * anim_t)+ (((c_pat == crr) ? blue : ((c_he1 == crr) ? green : red)) * 2.)*((ec / 5. * (1. - dx)) / (5. * nx * (dx))) * anim_t, col, d);\n                        }\n                    }\n                }\n            }\n        } else {\n            //card hit animation\n            vec4 lb = ((allData.en_etf)&&(bv)) ? load_board(card_baord_id(p)) : load_board2(card_baord_id(p));\n            float anim_t2za = min(get_animstate(clamp((g_time - allData.ett - 0.4 * float(card_baord_id(p)))*3., 0., 1.)),\n                    1. - get_animstate(clamp((g_time - allData.ett - .4 - 0.4 * float(card_baord_id(p)))*8., 0., 1.)));\n            anim_t2za *= 1. - allData.flag3;\n            if (int(lb.w) != c_bgr) {\n                p.y += (((allData.en_etf)&&(bv)) ? 1. : -1.)*0.06 * anim_t2za;\n                bv = (p.y - 0.02) < 0.;\n                if (((allData.en_etf)&&(bv)) || ((allData.player_etf)&&(!bv))) {\n                    vec2 pt = vec2((mod(p.x, 0.18) - 0.18 / 2.), -(abs(p.y - 0.02) - 0.125 - zv / 2.));\n                    d = card(pt);\n                    d = max(d, step(0.18 * 3., abs(p.x)));\n                    if (d < 1.) {\n                        float anim_t2zb = 1. - min(get_animstate(clamp((g_time - allData.ett)*6., 0., 1.)),\n                                1. - get_animstate(clamp((g_time - allData.ett - 2.5)*4., 0., 1.)));\n                        anim_t2zb = max(anim_t2zb, allData.flag3);\n                        if (!bv)pt.y *= -1.;\n                        col = mix(get_boardccolor(pt, card_baord_id(p), bv), col, d);\n                        float ddc = sdTriangleIsosceles(vec2(0.06, 0.03), vec2(pt.x, (bv ? 1. : -1.)*-pt.y) + vec2(0., 0.5 + 0.125)) - 0.02;\n                        float ddz = SS(-0.01, 0.02, ddc + 0.025);\n                        col = clamp(col, vec3(0.), vec3(1.));\n                        if (bv)\n                            col = mix(-col + 0.25 * blue / ddz, col, min(1., max(anim_t2zb, ddz) + 0.5));\n                        else\n                            col = mix(-col + 0.25 * purple / ddz, col * (min(1., max(anim_t2zb, ddz) + 0.5)), min(1., max(anim_t2zb, ddz) + 0.5));\n                    }\n                }\n            } else {\n                if (d < 1.)\n                    col *= (0.5 + 0.5 * (1. - anim_t2za));\n            }\n        }\n\n\n    return vec4(col, 1.);\n}\n\nvec4 draw_turnctrl(vec2 p) {\n    vec3 col = vec3(0.);\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));\n    float d = SS(0., zv, sdRhombus(pt, vec2(0.06, 0.12)));\n    float bxx = sdBox(pt, vec2(0.04, 0.008)) - 0.02;\n    float dy = SS(0., zv, bxx);\n    float dx = 1.;\n    if (dy < 1.)\n        dx = 1. - text_end(vec2(pt.x, pt.y)*15. + vec2(01.5, 0.5));\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = SS(-0.01, 0.02, abs(bxx));\n    float anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));\n    float anim_t2z = 1. - get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));\n    float anim_t2za = 1. - get_animstate(clamp((g_time - allData.ett), 0., 1.));\n    col = mix(bv ? (allData.player_turn ? green * (1. - anim_t2z) : green * anim_t2z) : (allData.player_turn ? green * anim_t2z : green * (1. - anim_t2z)), vec3(0.), d);\n    col = mix(cw2, col, dy);\n    col = mix(vec3(0.), col, dx);\n    if (allData.player_turn) {\n        col = mix(0.5 * (allData.player_hpmp.y > 0. ? cef4a : mix(redw, green, anim_t)) / dz, col, dz);\n    } else {\n        col = mix(0.5 * (green * anim_t2za) / dz, col, dz);\n    }\n    d = min(min(min(d + 0.65, dy + 0.4), dz), dx);\n    return vec4(clamp(col, vec3(0.), vec3(4.)), min(1., d));\n}\n\nvec4 draw_hpmp(vec2 p) {\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    vec3 col = vec3(0.);\n    bool bv = (p.y - 0.02 < 0.);\n    float d = 1.;\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.) {\n        d = hp_s(pt);\n        float nx = 1.;\n        if (d < 1.)\n            nx = card_fbg(p * 18.);\n        float ddx = hp_s3(pt + vec2(.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));\n        float ddx2 = hp_s3(pt + vec2(-.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));\n        float vx = (bv ? allData.player_hpmp.x / 98. : allData.en_hpmp.x / 98.)*0.12 - 0.12 / 2.;\n        float nxx = step(vx, pt.x);\n        col = mix((bv ? green : redw) / (nx * 3.), col, max(d, nxx));\n        float dx = 1. - text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, 0.), bv ? allData.player_hpmp.x : allData.en_hpmp.x);\n        col = mix(white, col, dx);\n        d = min(d, dx);\n        vec3 tccx = vec3(0.);\n        int crr = (int(load_card(int(allData.last_selected_card)).w));\n        if (allData.player_turn)\n            if (bv) {\n                if (((c_mn == crr) || (c_he2 == crr))&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {\n                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);\n                    tccx = clamp((c_mn == crr ? blue : green) / (100. * td), vec3(0.), vec3(4.));\n                    tccx = tccx*anim_tx;\n                }\n            } else {\n                if ((c_at2 == crr)&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {\n                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));\n                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);\n                    tccx = clamp(redw / (100. * td), vec3(0.), vec3(4.));\n                    tccx = tccx*anim_tx;\n                }\n            }\n        col = mix(tccx, col, max(dz + 0.35, 1. - d));\n        d = min(d, dz + 0.35);\n        float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*3., 0., 1.));\n        if (allData.flag1 == 1.)anim_t2 = 0.;\n        bool bvx = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 0.;\n        bool bvy = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 1.;\n        if ((!allData.player_turn)&&(!allData.en_etf)) {\n\n            float anim_t2x = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * allData.en_hpmp.y))*2., 0., 1.));\n            anim_t2 = anim_t2x;\n        }\n        anim_t2 = allData.player_turn ? (bv ? anim_t2 : 0.) : (!bv ? anim_t2 : 0.);\n        col = mix(col, clamp((bvx ? blue : blue * anim_t2) / ddx, vec3(0.), vec3(4.)), 1. - ddx);\n        col = mix(col, clamp((bvy ? blue : (bvx ? blue * anim_t2 : vec3(0.))) / ddx2, vec3(0.), vec3(4.)), 1. - ddx2);\n        d = min(d, ddx * ddx2);\n    }\n    if (allData.en_etf || allData.player_etf) {\n        float anim_t2zb = 1. - min(get_animstate(clamp((g_time - allData.ett - 0.1)*3., 0., 1.)),\n                1. - get_animstate(clamp((g_time - allData.ett - 2.8)*4., 0., 1.)));\n        dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.07));\n        if (dz < 1.) {\n            float dxz = 1.;\n            if (floor(allData.egt) > 0.)\n                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7), allData.egt));\n            else\n                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n0(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7)));\n            dxz = max(anim_t2zb, dxz);\n            col = mix(redw, col, dxz);\n            d = min(d, dxz);\n        }\n    }\n    return vec4(col, min(1., d + 0.35));\n}\n\nvec4 main_c(vec2 p) {\n    vec3 col = vec3(0.);\n    //col = main_c_bg(p).rgb;\n    vec4 col_t = vec4(0.);\n    float dz = 0.;\n    if (allData.flag3 == 1.) {\n        dz = SS(allData.egt + 1., allData.egt + 1.5, g_time);\n    }\n    /*col_t = draw_hpmp(p);\n    col = mix(col_t.rgb, col, col_t.w);\n    col_t = draw_turnctrl(p);\n    col = mix(col_t.rgb, col, max(col_t.w, dz));\n    \n    col_t = card_hand(p);\n    col = mix(col_t.rgb, col, max(col_t.w, dz));*/\n    col=texture(iChannel1,p/res_g+0.5).rgb;\n    if (allData.flag3 == 1.) {\n        col_t = main_c_wl(p);\n        col = mix(col_t.rgb, col, col_t.w);\n    }\n    return vec4(col, 1.);\n}\n\nfloat zoom_calc(float zv) {\n    float ex = 0.0025 * ((1080. * zv) / (iResolution.y));\n    return ex;\n}\n\nvoid init_globals() {\n    zv = zoom_calc(1.);\n    res_g = res;\n    g_time = iTime + extime;\n}\n\nvec2 click_control() {\n    return abs(iMouse.zw) / iResolution.y - res_g / 2.0;\n}\n\n//fix 2020\nint hpmp_get_hit_preinit(vec2 p, bool player_etf) {\n    if ((player_etf) || (player_etf))return -1;\n    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);\n    bool bv = (p.y - 0.02 < 0.);\n    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));\n    if (dz < 1.)return bv ? 6 : 16;\n    return -1;\n}\n\n// load last state\n\nvoid load_state(in vec2 fragCoord, bool ctrl) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 px = texelFetch(iChannel0, ivec2(2, 0), 0);\n    float cards_player = floor(px.x);\n    float flag0 = floor(px.y);\n    float cards_player_atime = (px.z);\n    float cards_player_select = floor(px.w);\n    px = texelFetch(iChannel0, ivec2(2, 2), 0);\n    float card_put_anim = (px.x);\n    float card_hID_put_anim = floor(px.y);\n    float card_bID_put_anim = floor(px.z);\n    float flag1 = floor(px.w);\n    vec2 click_pos = vec2(0.);\n    float card_select_anim=0.;\n    px = texelFetch(iChannel0, ivec2(2, 4), 0);\n    vec3 tvg = decodeval(px.x);\n    vec2 player_hpmp = tvg.yz;\n    bool player_etf = tvg.x == 1.;\n    tvg = decodeval(px.y);\n    vec2 en_hpmp = tvg.yz;\n    bool en_etf = tvg.x == 1.;\n    float ett = px.z;\n    bool player_turn = ett < 0.;\n    ett = abs(ett);\n    float flag3 = 0.;\n    float egt = px.w;\n    if ((flag0 != 1.) || (g_time < extime + 0.1)) {\n        egt = 0.;\n    } else {\n        if (player_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n        if (en_hpmp.x < 1.) {\n            flag3 = 1.;\n            egt = px.w;\n        }\n    }\n    if ((iMouse.z > 0.)&&(ctrl)) {\n        float anim_t2 = 1. - get_animstate(clamp((g_time - card_put_anim - 0.5)*2., 0., 1.));\n        float anim_t = get_animstate(clamp(1. - (g_time - cards_player_atime), 0., 1.));\n        if ((flag3 == 0.)&&(anim_t == 0.)&&(anim_t2 == 0.)) { //do not update mouse if anim played\n            click_pos = click_control();\n            if ((player_hpmp.y > 0.)&&((card_get_hit(click_pos) >= 0) || (hpmp_get_hit_preinit(click_pos,player_etf) > 0))) {\n                px = texelFetch(iChannel0, ivec2(2, 1), 0);\n                card_select_anim = px.z;\n            } else card_select_anim = g_time;\n        } else {\n            card_select_anim = g_time;\n        }\n    } else {\n        px = texelFetch(iChannel0, ivec2(2, 1), 0);\n        card_select_anim = px.z;\n        click_pos = px.xy;\n    }\n    px = texelFetch(iChannel0, ivec2(2, 1), 0);\n    float card_draw = floor(px.w);\n    if(flag3==1.)card_draw=0.;\n    allData = allData_struc(cards_player, card_select_anim, cards_player_atime, click_pos, -1., cards_player_select, card_put_anim, card_hID_put_anim, card_bID_put_anim, flag1, flag0,\n            player_hpmp, en_hpmp, flag3, egt, card_draw, player_turn, ett, player_etf, en_etf);\n}\n\n#ifdef NOCOMPILE\n\nfloat text_play(vec2 U) {\n    initMsg;C(80);C(76);C(65);C(89);endMsg;\n}\n\nfloat text_playex(vec2 U) {\n    initMsg;C(82);C(69);C(65);C(68);C(32);C(67);C(111);C(109);C(109);C(111);C(110);endMsg;\n}\n\nfloat text_playex2(vec2 U) {\n    initMsg;C(70);C(79);C(82);C(32);C(76);C(97);C(117);C(110);C(99);C(104);endMsg;\n}\n\nfloat text_playupd(vec2 U) {\n    initMsg;C(85);C(112);C(100);C(97);C(116);C(101);C(100);endMsg;\n}\n\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifdef NOCOMPILE\n    res_g = res;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res_g / 2.0;\n    float x = 0.;\n    vec3 col = vec3(0.);\n    if (iResolution.y > 250.) {\n        x = text_play((uv)*1.25 + vec2(res.x, res.y / 4.));\n        col = vec3(1.) * x;\n        x = text_playex((uv)*5. + vec2(res.x * 2.62, res.y * 2.));\n        col += vec3(1., 0., 0.) * x;\n        x = text_playex2((uv)*5. + vec2(res.x * 2.63, res.y * 1.2));\n        col += vec3(0., 0., 1.) * x;\n        x = text_playupd((uv)*5. + vec2(res.x * 1.5, res.y * 2.62));\n        col += vec3(0., 0.5, .5) * x;\n    } else col = vec3(text_play((uv)*1.25 + vec2(res.x, res.y / 2.)));\n    fragColor = vec4(col, 1.);\n    return;\n#else\n    init_globals();\n    load_state(fragCoord, false);\n    vec2 uv = (fragCoord.xy) / iResolution.y - res_g / 2.0;\n    vec4 ret_col = main_c(uv);\n    fragColor = ret_col;\n#endif\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}