{"ver":"0.1","info":{"id":"MfcSzB","date":"1714083592","viewed":101,"name":"Between Two Beehives","username":"GarlicGraphix","description":"Raymarching code from Kishimisu, signed distance and smooth union code from Inigo Quilez.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","bee"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map( vec3 ray, vec3 m ) {\n    float height = 0.7;\n    float heightRange = 0.3;\n    float width = 0.06;\n    float widthRange = 0.02;\n    bool inverted = false;\n    float x = normalize(ray).x;\n    vec3 ogRay = ray;\n    if (ray.y >= 0.0) {\n        inverted = true;\n        ray.y = -ray.y;\n    }\n    \n    ray.xz = fract(ray.xz);\n    vec3 capPos = vec3(1.0, -0.75, 0.5);\n    //if (inverted) {capPos.xz *= 0.45;}\n    float ground = ray.y + 0.75;\n    float final = 1.0;\n    for (int i = 1; i < 10; i++) {\n        \n        vec3 fractPos = ray - capPos;\n        fractPos.xz += fract(0.3*iTime*float(i)/16.0);\n        fractPos.z += fract(iTime);\n        \n        float curHeight = length(ogRay/8.0)*height-(sin(iTime+float(i))*heightRange)-float(i)*0.05;\n        curHeight *= clamp(length(normalize(m)-normalize(ogRay))*1.5, 0.0, 1.0);\n        float curWidth = length(ogRay)*0.005+width+(sin(iTime+float(i))*widthRange)-float(i)*0.0025;\n        \n        fractPos.x = fract(-fractPos.x);\n        fractPos.z = fract(-fractPos.z);\n        final = min(final, sdVerticalCapsule(fractPos, curHeight, curWidth));\n        fractPos.x = fract(-fractPos.x);\n        final = min(final, sdVerticalCapsule(fractPos, curHeight, curWidth));\n        capPos.x += float(i)*0.71;\n        capPos.z += float(i)*0.46;\n    }\n    return opSmoothUnion(ground, final, 0.3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n        \n    vec2 uv = (fragCoord *2.0 - iResolution.xy) / iResolution.y;\n    \n\n    // Time varying pixel color\n    \n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    vec3 m = vec3(0.0,0.0, 1.0);\n    \n    vec3 col = vec3(0.1, 0.1, 0.02);\n\n    float totDist = 0.0;\n    \n    int iterations = 50;\n    \n    for (int i = 0; i < 50; i++) {\n        vec3 pos = origin + ray * totDist;\n        \n        float dist = map(pos, m);\n        \n        totDist += dist;\n        \n        if (dist <= 0.001 || dist >= 50.0) {\n            iterations = i;\n            break;\n        }\n    }\n    \n    vec3 mask = vec3(totDist* 0.01+float(iterations)*0.025);\n    col.rg += (1.0-clamp(length(uv.yy/1.3-vec2(0.,0.)), 0.0, 1.0))*vec2(1.0, 0.8);\n    col = (col-mask);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}