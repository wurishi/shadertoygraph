{"ver":"0.1","info":{"id":"3lfSzN","date":"1562196332","viewed":449,"name":"Dithermania","username":"104","description":"Comparing a few dithering techniques and experimenting with a voronoi-based dither.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Credits:\n// iq: basic voronoi https://www.shadertoy.com/view/MslGD8\n// Dave_Hoskins: trig-less hashes https://www.shadertoy.com/view/4djSRW\n// SigSegOwl: Sharpen kernel https://www.shadertoy.com/view/XlycDV\n\n// just comparing various dither patterns.\n// click mouse on the left 50px; top half to view a simple animated scene\n// click mouse on the left 50px; bottom half to view a greyscale ramp\n// click mouse on the dither patterns elsewhere to make them full-screen\n\n// from top to bottom:\n// 1. no dithering applied\n// 2. random value perturbance. very noisy and ugly.\n// 3. blue noise perturbance; commonly used because it looks so neutral\n// 4. using voronoi effect to simulate blue-ish noise. it's chunky in places and fine in\n//    others, but it doesn't disturb me. the irregularity has a sort of organic look.\n// 5. bayer ordered dithering. a familiar look.\n\n// there are certainly bugs here; this is cobbled together for fun.\n// a pixellation effect is also possible using the global var 'pix',\n// but for some reason the bayer sampling doesn't work for even values ...\n\nconst int pix = 1;\nconst float voronoiSize = 3.;\nconst float paletteDist = 1.; // dist between palette values. more dest palette colors = smaller value here.\n\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash22( n + g );\n      vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n//----------------------------------------------------------------------------\n// c64 palette\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\n\nvec3 selectIfCloser (in vec3 idealColor, in vec3 paletteColor, in vec3 bestColorSoFar, inout float currentDistance) \n{\n    float thisDistance = distance(idealColor, paletteColor);\n    if(thisDistance < currentDistance)\n    {\n        currentDistance = thisDistance;\n        return paletteColor;\n    }\n    return bestColorSoFar;\n}\n\n// a more optimized version of this could do something like a binary search\n// or order by luminocity and short-circuit search that way.\nvec3 palettizeC64(vec3 idealColor)\n{\n    // init with first palette color\n\tfloat dmin = distance(idealColor, color0);\n    vec3 closest = color0;\n\n    closest = selectIfCloser(idealColor, color1, closest, dmin);\n    closest = selectIfCloser(idealColor, color2, closest, dmin);\n    closest = selectIfCloser(idealColor, color3, closest, dmin);\n    closest = selectIfCloser(idealColor, color4, closest, dmin);\n    closest = selectIfCloser(idealColor, color5, closest, dmin);\n    closest = selectIfCloser(idealColor, color6, closest, dmin);\n    closest = selectIfCloser(idealColor, color7, closest, dmin);\n    closest = selectIfCloser(idealColor, color8, closest, dmin);\n    closest = selectIfCloser(idealColor, color9, closest, dmin);\n    closest = selectIfCloser(idealColor, colorA, closest, dmin);\n    closest = selectIfCloser(idealColor, colorB, closest, dmin);\n    closest = selectIfCloser(idealColor, colorC, closest, dmin);\n    closest = selectIfCloser(idealColor, colorD, closest, dmin);\n    closest = selectIfCloser(idealColor, colorE, closest, dmin);\n    closest = selectIfCloser(idealColor, colorF, closest, dmin);\n    return closest;\n}\n\n\nvec3 palettize(vec3 i) \n{\n    //return palettizeC64(i); // c64 palette\n    //return step(.8,i); // reduced colors\n    //i = vec3(i.r+i.g+i.b)/3.; return floor(i*2.5)/2.; // 3 shades of gray\n\treturn vec3(step(1.5, i.r+i.g+i.b)); // black & white\n}\n\nvec3 texSample(const int x, const int y, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;\n\tuv = (uv + vec2(x, y)) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).xyz;       \n}                                         \nvec3 sharpenFilter(in vec2 fragCoord, float strength){\n\tvec3 f =\n\ttexSample(-1,-1, fragCoord) *  -1. +                     \n\ttexSample( 0,-1, fragCoord) *  -1. +                    \n\ttexSample( 1,-1, fragCoord) *  -1. +                      \n\ttexSample(-1, 0, fragCoord) *  -1. +                    \n\ttexSample( 0, 0, fragCoord) *   9. +                     \n\ttexSample( 1, 0, fragCoord) *  -1. +                      \n\ttexSample(-1, 1, fragCoord) *  -1. +                     \n\ttexSample( 0, 1, fragCoord) *  -1. +                     \n\ttexSample( 1, 1, fragCoord) *  -1.\n\t;                                              \n\treturn mix(texSample( 0, 0, fragCoord), f , strength);    \n}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\n\nvec4 gen(vec2 uv_) {\n    vec2 uv = uv_;\n    float t = iTime;\n    vec2 p1 = vec2(sin(t*.7), cos(t*.5))*.5+.5;\n    vec2 p2 = vec2(cos(t*1.), sin(t*1.4))*.5+.5;\n\n    float sd = length(p1-uv)-.2;\n    sd = min(sd, length(p2-uv)-.05);\n    \n    float a = dtoa(sd, 40.);\n    if (uv_.x > .5)\n\t    return vec4(a);\n\treturn  1.-vec4(a);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord) / pix * pix;\n    fragCoord = vec2(fc);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 origCol = texture(iChannel0, uv);\n    origCol = sharpenFilter(fragCoord, 1.).rgbb;\n\n    vec2 uvm = iMouse.xy / iResolution.xy;\n    if (iMouse.z > 0. && iMouse.x < 50.) {\n        \n        if (uvm.y < 0.5)\n        \torigCol = vec4(uv.x); // ramp\n        else\n            origCol = gen(uv);\n    }\n\n    vec3 noDither = palettize(origCol.rgb);\n    \n    float rand_ditherVal = hash12(fragCoord);\n    vec4 rand_perturbed = origCol + (rand_ditherVal - .5) * paletteDist;\n    vec4 rand_final = palettize(rand_perturbed.rgb).rgbb;\n    \n    vec4 blue_ditherval = texelFetch(iChannel1, ivec2(fragCoord)%1024, 0);\n    vec4 blue_perturbed = origCol + (blue_ditherval - .5) * paletteDist;\n    vec4 blue_final = palettize(blue_perturbed.rgb).rgbb;\n    \n    // doing separate voronoi for R G and B values; works better for non-grayscale palettization.\n    // but for grayscale, 1 channel would do.\n    vec3 vor_ditherVal = vec3(voronoi(fragCoord/(float(pix)*voronoiSize)).x,\n                              voronoi((fragCoord+iResolution.x)/(float(pix)*voronoiSize)).x,\n                              voronoi((fragCoord+iResolution.x*2.)/(float(pix)*voronoiSize)).x);\n    vor_ditherVal = (vor_ditherVal * 1.5) -.1;// needs some adjustment to fit in gradient\n    vor_ditherVal = clamp(vor_ditherVal, 0.01,.99);\n    vec4 vor_Perturbed = origCol + (vor_ditherVal.rgbb - .5) * paletteDist;\n    vec3 vor_final = palettize(vor_Perturbed.rgb);\n\n    float bayer_ditherval = texture(iChannel2, vec2(fc%8)/8.).r; // texelFetch(iChannel2, fc%8, 1).r;\n    vec4 bayer_perturbed = origCol + (bayer_ditherval-.5) * paletteDist;\n    vec4 bayer_final = palettize(bayer_perturbed.rgb).rgbb;\n\n    float my = (iMouse.z > 0. && iMouse.x >= 50.) ? iMouse.y / iResolution.y : -1.;\n    if ((my < 0. && uv.y > .8) || (my > .8))\n        o = noDither.rgbb;\n    else if ((my < 0. && uv.y > .6) || (my > .6))\n        o = rand_final;\n    else if ((my < 0. && uv.y > .4) || (my > .4))\n        o = blue_final;\n    else if ((my < 0. && uv.y > .2) || (my > .2))\n        o = vor_final.rgbb;\n    else\n        o = bayer_final;\n\n    if (my < 0. && length(fragCoord.x - 50.) < float(pix)-.5)\n        o = vec4(1.,0.,0.,1);\n    if (my < 0. && fragCoord.x > 50. && length(mod(uv.y,.2)) < 0.001)\n        o = vec4(1,0,0,0);\n}\n\n","name":"Image","description":"","type":"image"}]}