{"ver":"0.1","info":{"id":"wlBSDD","date":"1565970757","viewed":220,"name":"Have A Good Night.","username":"Hirai_worthless","description":"Noise Practice by https://thebookofshaders.com/13/","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n\n//tracing result structure\nstruct TraceData {\n\tvec3 normal;\n    float t;\n    float nearestT;\n    float nearestD;\n    int uniqueID;\n    \n};\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .4;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < 8; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec2 pmod(vec2 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec2(l * cos(theta), l * sin(theta));  \n}\nvec3 modCell(vec3 p,vec3 cellSize){\n    p.x = (fract(p.x / cellSize.x + 0.5) - 0.5) * cellSize.x;\n    p.y = (fract(p.y / cellSize.y + 0.5) - 0.5) * cellSize.y;\n    p.z = (fract(p.z / cellSize.z + 0.5) - 0.5) * cellSize.z;\n    return p;\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 p){\n    vec2 st = p.xz;\n    float time = iTime / 10.;\n    float f = fbm(st + time  + fbm(st + fbm(st))) * exp(p.x  - 0.5);\n    float terrain = p.y - f * 2.0 + 1.5;\n    \n    vec3 q = p - vec3(-7.5,4.5,iTime + 6.0);\n    float theta = q.x;\n    float phi = q.y;\n    vec2 pol = vec2(q.x,q.y);\n    float r= 1.2 + fbm(pol + iTime)/1.5;\n    float moon = length(q) - r;\n    return min(terrain,moon);\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 wPos){\n                vec3 dx = dFdx(wPos);\n                vec3 dy = dFdy(wPos);\n                vec3 normal = normalize(cross(dy, dx));\n                return normal;\n            }\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(0,0,-2.5 + iTime);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 r = normalize(vec3(uv,z));\n    return r;\n}\n\n//Tracing Ray\n\nTraceData trace (vec3 o, vec3 r){\n    TraceData data;\n\tfloat t = 0.0;\n    float nearestT = 10000000.0;\n    float nearestD = 10000000.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 64; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.2;\n        nearestT = d < nearestD ? t : nearestT;\n        nearestD = min(nearestD,d);\n        \n    }\n    data.nearestD = nearestD;\n    data.nearestT = nearestT;\n    data.normal = getNormal(p);\n    data.t = t;\n    return data;\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,TraceData data){\n    float t = data.t;\n    float fog = 1.0 / (1.0 + t * t * 0.0125);\n    float a = dot(data.normal,r);\n    vec3 p = o + r * t;\n    vec3 fc = vec3(0.05);\n    fc = fract(p.y * 4. + 0.5) < 0.1 && (p.y < -1.) ? vec3(0.95) : fc;\n    vec3 moonCol = vec3(226,201,110)/255.;\n    fc = (p.y < 1.0 || p.x > 0.) ? fc : moonCol;\n    float farFromMoon =  10. - length(p.xz - vec2(-7.5,iTime + 6.));\n    fc = mix(fc,moonCol,smoothstep(0.,10.,max(0.,farFromMoon)));\n    fc = mix(fc,vec3(1.),1. + a*1.5);\n    vec3 fogCol = vec3(27,47,82)/255.;\n    fc = !(p.y < 1.0 || p.x > -1. || p.z - iTime > 10.) ? fc  : mix(vec3(0.1),fc,fog);\n    \n    //fc = vec3(fog);\n    return fc;\n}\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    TraceData data = trace(o,r);\n    float vig = 1. - length(uv)/5.;\n    vec3 fc = getColor(o,r,data) * vig ;\n    \n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}