{"ver":"0.1","info":{"id":"lstSzj","date":"1460393263","viewed":6504,"name":"curvaticEmpire2","username":"dello32","description":"curve space glow","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["curvespaceglow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define speed  0.1\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera\t\n    vec3 ro =  vec3(sin(iTime*0.16),0.,cos(iTime*0.1) );\n\tvec3 ta =  ro + vec3(sin(iTime*0.15),sin(iTime*0.18),cos(iTime*0.24));\n    float roll = 0.0;\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cp,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cp + cw*2.0 );\n    \n    //volumetric rendering\n\tvec3 v=vec3(0.);\n\tfor (float s=0.1; s<=5.0; s+=0.1) {\n        //float spread = hash(rd.x+rd.y+rd.z);\n\t\tvec3 p=ro+rd*s;\n\n        for(float i=0.1; i<1.; i+=0.12){\n\t\t\tp=abs(p)/dot(p+sin(iTime*0.1)*0.1,p)-0.5; // the magic formula\n\t\t\tfloat a=length(p); // absolute sum of average change\n            v+= vec3(i,i*i,i*i*i)*a*0.12; // coloring based on distance\n        }\n        \n\t}\n\tfragColor = vec4(v*.01,1.);\t\n\t\n}","name":"Image","description":"","type":"image"}]}