{"ver":"0.1","info":{"id":"XXyXDt","date":"1720603671","viewed":47,"name":"abstract gloss","username":"mike2367","description":"the gloss effect implemented with random hash function","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code ref: https://www.shadertoy.com/view/3slSWs\n// code ref: https://www.shadertoy.com/view/tdcXDf\nfloat hash(float n)\n{\n    return fract(10000.0 * sin(n));\n}\nfloat hash12(vec2 p)\n{\n\treturn fract(10000.0 * sin(p.x*p.y));\n}\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*uvec2(1597334673U, 3812015801U);\n\tq = (q.x ^ q.y) * uvec2(1597334673U, 3812015801U);\n\treturn vec2(q) * (1.0 / float(0xffffffffU));\n}\n\n// Do cubic interpolation between random numbers at each point on a grid.\nfloat noise2_param(vec2 p, float s, float t)\n{\n    vec2 fl = floor(p);\n    vec2 fr = fract(p);\n\n    vec2 terp = fr * fr * (3.0 - 2.0 * fr);\n\n    float n = fl.x * s + fl.y * t;\n\n    return mix(\n        mix(hash(n),     hash(n + s),     terp.x),\n        mix(hash(n + t), hash(n + s + t), terp.x),\n        terp.y);\n}\n\nfloat noise2(vec2 p)\n{\n    return noise2_param(p, 87.0, 37.0);\n}\n\n// Fractional Brownian motion\nconst float theta = 60.0;\nconst mat2 m = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 8.;i++)\n\t{\n\t\trz+= abs((noise2(p)-0.5)*2.5)/z;\n\t\tz = z*2.;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat perlin (vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = hash12(id);\n    float b = hash12(id + vec2(1.0, 0.0));\n    float c = hash12(id + vec2(0.0, 1.0));\n    float d = hash12(id + vec2(1.0, 1.0));\n\n    vec2 u = gv * gv * (1. - 3.0 * gv);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1. - u.x) +\n            (d - b) * u.x * u.y;\n}\nvec2 curl (vec2 uv)\n{\n    vec2 eps = vec2(0.5, 1.);\n    \n    float n1, n2, a, b;\n    n1 = perlin(uv+eps);\n    n2 = perlin(uv-eps);\n    a = (n1-n2)/(.5*eps.y); // ∂x1/∂y\n    \n    n1 = perlin(uv+eps.yx);\n    n2 = perlin(uv-eps.yx);\n    b = (n1-n2)/(.5*eps.y); // ∂y1/∂x\n    \n    return vec2(a, -b);\n}\nfloat worley(vec2 uv, float freq, float t)\n{\n    uv *= freq;\n    uv += t;\n    \n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    float minDist = 100.;\n    for (float y = -1.; y <= 1.; ++y)\n    {\n        for(float x = -1.; x <= 1.; ++x)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 h = hash22(id + offset) * .8 + .1; // .1 - .9\n    \t\th += offset;\n            vec2 d = gv - h;\n           \tminDist = min(minDist, dot(d, d));\n        }\n    }\n    \n    return minDist + .4;\n}\nvec3 fbmCurlWorley(vec2 uv, float freq, float t)\n{\n    float worley1 = 2. - worley(uv, freq * 2., t * 2.);\n    float worley2 = 2. - worley(uv, freq * 4., t * 4.);\n    float worley3 = 1. - worley(uv, freq * 8., t * 8.);\n    float worley4 = 1. - worley(uv, freq * 16., t * 16.);\n    \n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n    return vec3(fbm1, fbm2, fbm3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = texelFetch(iChannel0, ivec2(fragCoord), 0).yz;\n    pos = curl(pos);\n    float t = iTime;\n    vec3 curlWorleyFbm = fbmCurlWorley(pos, 4., t);\n    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + \n        curlWorleyFbm.b * .125;\n    vec3 col = mix(sin((t * 2.0 + pos.xyx + vec3(0, 2, 4)) / 10.0), cos((t * 2.0 + pos.yxy + vec3(4, 2, 0)) / 10.0), pos.x * pos.x) * 0.5 + 0.5;\n    fragColor = vec4(1.2*fbm(col.xy + fbm(col.xy)), 1.3*fbm(col.yx + fbm(col.yx)),0.8, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}