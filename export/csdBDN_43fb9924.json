{"ver":"0.1","info":{"id":"csdBDN","date":"1698513438","viewed":223,"name":"Lower","username":"EDragon","description":"HUGE win for miku dayo","likes":17,"published":1,"flags":64,"usePreview":0,"tags":["music","animation","graphics","recreation","ease","notshadertoy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dt3RS","filepath":"https://soundcloud.com/ldq5kidtnspc/lower-25-xmeiko-full-ver","previewfilepath":"https://soundcloud.com/ldq5kidtnspc/lower-25-xmeiko-full-ver","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////\n//\n// HELLO !!!!!!!\n// WELCOME TO MY GREATEST WORK SO FAR ! !\n//\n//          ------- IMPORTANT NOTICE -------\n//\n// This shader uses a song on iChannel0 to run\n// If it's static (just blue) please pause and reset time\n// Hope you enjoy :3\n//\n//             -------------------------\n//\n// This shader is inpired by the following Music Video\n// https://youtu.be/16M9oC-a5bY?si=CupmmSt6pV1V2P60\n//\n// (none intro animation version soon)\n//\n////////////////////////////////////////////////////\n\n#define t iChannelTime[0]\n#define res iResolution.xy\n#define pi 3.1415\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define s smoothstep\n#define ls linearstep\n#define s2(uv, a) s(-a, -a+0.005, -uv)\n#define se(uv, f) s(0.0, f / res.x, uv)\n\nvec3 bg = vec3(0.1, 0.2, 0.3);\nvec3 yel = vec3(1.0, 0.8, 0.4);\n\nfloat linearstep(float a, float b, float x){\n    return clamp(((x - a)/(b - a)), 0.0, 1.0);\n}\n\nvec3 layer(vec3 l1, float l2, float l22, vec3 col){\n    return clamp(l1, 0.0, 1.0-min(l2,1.0))+l22*col;\n}\n\n//I don't think I know what I'm doing\nfloat cline(vec2 uv, float count, float si, float ro){\n\n    uv *= si;\n    uv *= rot(ro);\n    float r = (length(uv)*2.0)/s2(.1, length(uv)*0.3);\n    float a = atan(uv.y,uv.x);\n\n    float f = 1.-s(.0,1., cos(a*count));\n    f *= s(.35, .502, length(uv));\n    \n\n    return 1.-s(f,f+0.005,r);\n\n}\n\nfloat moon(vec2 uv, vec2 p, float count, float cover, float si, float ro, float flip){\n    uv *= rot(ro);\n    uv -= p;\n    uv *= rot(-ro);\n    uv *= si;\n    vec2 uv2 = uv;\n    float l = cline(uv, count, 5.0, t);\n    uv2.x += sqrt(1.0 - pow((uv2.y*pi*31.0)*0.1, 2.0))*(cover*0.105);\n    l += s(0.103, 0.1, length(uv))*s2(0.0, uv2.x*flip);\n    l = min(l, 1.0);\n    return l;\n}\n\nfloat rin(vec2 uv, vec2 p, float si, float div){\n    uv -= p;\n    return div/(1.-(s(0.05+si, 0.0+si, length(uv))\n    *s(-0.05+si, 0.0+si, length(uv))));\n}\n\n\nfloat star(vec2 uv, vec2 p, float r){\n\n    uv *= rot(pi*r);\n    uv -= p;\n    \n    return (s(0.001, 0.0005, abs(uv.x*uv.y))*s(0.15, 0.13, length(vec2(uv.x*1.25, uv.y))));\n}\n\nfloat stik(vec2 uv, vec2 p, float r){\n\n    uv *= rot(pi*r);\n    uv -= p;\n    \n    return s(0.01, 0.005, abs(uv.x))*s(0.25, 0.23, abs(uv.y));\n}\n\nfloat rand (float a) {\n  return fract(sin(dot(vec2(a), vec2(12.9898,78.233)))*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*res)/res.y;\n    vec2 over = (fragCoord-.5*res)/res;\n    float ss = 1.75;\n    float fish = 0.0;\n    float scene = 0.0;\n    \n    \n    vec3 col = vec3(0.0); //\n    col += bg;\n    \n    //round to make sure they will increase properly with no funny floating points\n    scene = round(scene);\n    scene += round(linear(17.4, 0.001, 1.0, t)); //\n    scene += round(linear(18.3, 0.001, 1.0, t)); //\n    \n    vec2 i2 = vec2(floor(100.0*uv.y));\n    vec2 f2 = vec2(fract(100.0*uv.y));\n    \n    float gli = 0.0;\n    \n    gli += tri(17.35, 0.1, 0.5, t);\n    \n    gli += tri(31.0, 0.1, 0.5, t);\n    ss -= linear(31.0, 0.01, 2.25, t);\n    uv -= linear(31.0, 0.01, 0.5, t);\n    \n    gli += tri(31.45, 0.1, 0.5, t);\n    ss += linear(31.45, 0.01, 0.1, t);\n    uv += linear(31.45, 0.01, 1.45, t);\n    \n    gli += tri(31.9, 0.1, 0.5, t);\n    ss += linear(31.9, 0.01, 0.4, t);\n    uv.x -= linear(31.9, 0.01, 2.5, t);\n    \n    gli += tri(32.35, 0.1, 0.5, t);\n    ss -= linear(32.35, 0.01, 0.25, t);\n    uv.x += linear(32.35, 0.01, 1.55, t);\n    uv.y -= linear(32.35, 0.01, .95, t);\n    \n    ss += linear(32.8, 0.01, -2.0, t);\n    ss += outExpo(32.8, 1.0, 3.75, t);\n    fish += linear(32.8, 0.01, -50., t);\n    fish += outExpo(32.8, 2.0, 50., t);\n    \n    uv.x += mix(floor(rand(i2.x)*10.), floor(rand(i2.x + 1.0)*10.), s(0.0,0.75,f2.x))*0.1*gli-0.5*gli;\n    \n    \n    ss += linear(17.0, 0.01, -0.5, t);\n    ss += invert(17.0, 2.0, 1.0, t);\n    ss += linear(18.0, 21.9-18.0, 0.5, t);\n    //fish += linear(18.3, 0.01, -75., t);\n    fish += invert(18.3, 1.5, 75., t+0.75);\n    float ro = 0.0;\n    ro += invert(18.3, 1.0, 0.5, t+0.5);\n    ro += linear(32.8, 0.01, -1., t);\n    ro += outExpo(32.8, 2.0, 1., t);\n    \n    uv *= rot(length(uv)*min(ro, 1.0));\n        ///\n        \n        fish += invert(18.0, 0.5, -100.0, t);\n        //fish += linear(18.3, 0.001, 100.0, t);\n        \n    \n    if (scene == 0.0){\n        float bend = 0.0;\n        float em = 20.0;\n        float mm = 20.0;\n        float km = 20.0;\n        float im = 20.0;\n\n        float lp = 0.0;\n        bend += inOutQuad(4.0, 3.0, 0.25, t);\n        bend += inOutSine(8.5, 2.0, -0.5, t);\n        bend += inOutSine(11.0, 3.0, -0.5, t);\n        bend += inOutSine(12.0, 3.0, 1.5, t);\n        bend += inOutSine(14.5, 3.0, -0.75, t);\n        uv *= inOutSine(15.0, 2.0, -0.9, t)+1.0;\n        uv *= rot(uv.x*bend+t*0.25+inOutSine(12.0, 2.5, 2.0, t)+inCubic(16.0, 1.5, 2.0, t)-1.0);\n        \n        uv.x -= inOutSine(15.0, 2.0, 0.4, t);\n        \n        em -= outBack(3.5, 0.5, em-1.0, t, 0.35);\n        lp += inOutSine(4.0, 3.5, 3.8, t);\n        uv.x += inOutQuad(4.0, 3.5, 4.0, t);\n        \n        //changed alpha division to it's own ease instead of relying on the size ease\n        float en = moon(uv, vec2(0.0), 25.0, 0.6, em, 0.0, 1.0)*outCubic(3.5, 0.5, 1.0, t);\n        col = layer(col, en, en, yel);\n        \n        mm -= outBack(7.0, 0.5, mm-1.0, t, 0.35);\n        lp += inOutSine(7.5, 3.5, 4.0, t);\n        uv.x += inOutQuad(7.5, 3.5, 4.0, t);\n        \n        float mafu = moon(uv, vec2(4.0, 0.0), 25.0, 0.0, mm, 0.0, -1.0)*outCubic(7.0, 0.5, 1.0, t);\n        col = layer(col, mafu, mafu, yel);\n        \n        \n        km -= outBack(10.5, 0.5, km-1.0, t, 0.35);\n        lp += inOutSine(11.0, 3.5, 4.0, t);\n        uv.x += inOutQuad(11.0, 3.5, 4.0, t);\n        \n        float kana = moon(uv, vec2(8.0, 0.0), 25.0, 0.0, km, 0.0, 1.0)*outCubic(10.5, 0.5, 1.0, t);\n        col = layer(col, kana, kana, yel);\n        \n        im -= outBack(14.25, 0.5, im-1.0, t, 0.35);\n        lp += inOutSine(14.75, 3.5, 3.8, t);\n        uv.x += inOutQuad(14.75, 3.5, 4.0, t);\n        \n        float mizu = moon(uv, vec2(12.0, 0.0), 25.0, 0.6, im, 0.0, -1.0)*outCubic(14.25, 0.5, 1.0, t);\n        col = layer(col, mizu, mizu, yel);\n        \n        \n        float meik = moon(uv, vec2(3.5, 0.5), 25.0, 1.0, 1.0, 0.0, -1.0)+\n        moon(uv, vec2(7.75, -0.5), 25.0, 1.0, 1.0, 0.0, -1.0)+\n        moon(uv, vec2(12.0, 0.5), 25.0, 1.0, 1.0, 0.0, -1.0)+\n        star(uv-vec2(6.0, 0.5), vec2(0.0), 0.55)+\n        star(uv-vec2(9.0, -0.25), vec2(0.0), 0.3)+\n        star(uv-vec2(12.25, -0.25), vec2(0.0), 0.44);\n        col = layer(col, meik, meik, yel);\n        \n        \n        \n        //line control\n        float line1 = s(0.0055, 0.005, abs(uv.y))* s(0.01, 0.012, abs(mod(uv.x-t*0.1,0.075)-0.05))*step(-uv.x, -0.15)\n        *step(uv.x, lp)\n        *step(1.0-abs(uv.x-4.0), 0.8)\n        *step(1.0-abs(uv.x-8.0), 0.8)\n        *step(1.0-abs(uv.x-12.0), 0.8);\n        col = layer(col, line1, line1, yel);\n    }\n    \n        vec2 p = uv;\n        float prop = res.x / res.y;//screen proroption\n        \n        vec2 m = vec2(0.5);\n        float fr = sqrt(dot(uv, uv));\n        float power = ( 2.0 * 3.141592 / (2.0 * sqrt(dot(m, m))) ) *\n                    (fish / 480.0);//amount of effect\n                    \n        float bind;//radius of 1:1 effect\n        if (power > 0.0) bind = sqrt(dot(m, m));//stick to corners\n        else {if (prop < 1.0) bind = m.x; else bind = m.y;}//stick to borders\n        \n        if (power < 0.0)//antifisheye\n            uv = normalize(uv) * atan(fr * -power * 10.0) * bind / atan(-power * bind * 10.0);\n        else uv = p;//no effect for power = 1.0\n        \n        ///\n    if (scene == 1.0){\n        float ex = 0.0;\n        float ea = 0.0;\n        float mx = 0.0;\n        float ma = 0.0;\n        float kx = 0.0;\n        float ka = 0.0;\n        float ix = 0.0;\n        float ia = 0.0;\n        //17.3\n        ea += linear(17.3, 0.001, 1.0, t);\n        \n        ex += linear(17.6, 0.001, 0.25, t);\n        ma += linear(17.6, 0.001, 1.0, t);\n        mx += linear(17.6, 0.001, -0.25, t);\n        \n        ex += linear(17.8, 0.001, 0.25, t);\n        mx += linear(17.8, 0.001, -0.25, t);\n        ka += linear(17.8, 0.001, 1.0, t);\n        \n        ex += linear(18.0, 0.001, 0.25, t);\n        kx += linear(18.0, 0.001, 0.25, t);\n        mx += linear(18.0, 0.001, 0.25, t);\n        ia += linear(18.0, 0.001, 1.0, t);\n        ix += linear(18.0, 0.001, -0.75, t);\n        //kx += linear(17.9, 0.001, 0.25, t);\n\n        \n        float ena = moon(uv, vec2(ex, 0.0), 25.0, 0.6, 1.0, 0.0, 1.0)*ea;\n        col = layer(col, ena, ena, yel);\n        \n        \n        float mafuyu = moon(uv, vec2(mx, 0.0), 25.0, 0.0, 1.0, 0.0, -1.0)*ma;\n        col = layer(col, mafuyu, mafuyu, yel);\n        \n        \n        float kanade = moon(uv, vec2(kx, 0.0), 25.0, 0.0, 1.0, 0.0, 1.0)*ka;\n        col = layer(col, kanade, kanade, yel);\n        \n        \n        float mizuki = moon(uv, vec2(ix, 0.0), 25.0, 0.6, 1.0, 0.0, -1.0)*ia;\n        col = layer(col, mizuki, mizuki, yel);\n    \n    }\n    \n    \n    if (scene == 2.0){\n    \n    ss += outCirc(21.9, 1.5, 0.75, t);\n    ss += linear(21.9, 3.6, 0.5, t);\n    ss -= outCirc(25.5, 1.5, 0.75, t);\n    ss -= linear(25.5, 3.6, 0.75, t);\n    ss += outCirc(29.2, 1.5, 1.5, t);\n    ss += linear(29.2, 1.8, 0.25, t);\n    uv *= ss;\n    \n    \n\n    float dot1 = cline(uv, 20.0, 1.65, t*0.5);\n    float dot2 = cline(uv, 20.0, 0.4, -t*0.5);\n    float a = length(uv);\n    dot1 *= s(0., 0.05, -atan(uv.x, uv.y)+linear(18.3, 4.0, pi*2.1, t)-pi);\n    dot2 *= s(0., 0.05, atan(uv.x, uv.y)+linear(19.15, 4.0, pi*2.1, t)-pi);\n    col = layer(col, dot1, dot1, yel);\n    col = layer(col, dot2, dot2, yel);\n\n    float mc = 20.0;\n    float rt = t*0.25;\n    float mm = 8.0;\n    float ms = 0.75;\n    float mul = 0.0;\n    mul += inOutSine(18.3, 2.0, 1.0, t);\n    //no for loops because society says no :pensive:\n    float \n    l  = moon(uv, vec2(-sin(0.0/mm*pi)*ms,  cos(0.0/mm*pi)*ms), mc,  1.00*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2(-sin(1.0/mm*pi)*ms,  cos(1.0/mm*pi)*ms), mc,  0.75*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2( sin(1.0/mm*pi)*ms,  cos(1.0/mm*pi)*ms), mc, -0.75*mul, 1.0, rt, -1.0);\n    l += moon(uv, vec2(-sin(2.0/mm*pi)*ms,  cos(2.0/mm*pi)*ms), mc,  0.50*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2( sin(2.0/mm*pi)*ms,  cos(2.0/mm*pi)*ms), mc, -0.50*mul, 1.0, rt, -1.0);\n    l += moon(uv, vec2(-sin(3.0/mm*pi)*ms,  cos(3.0/mm*pi)*ms), mc,  0.25*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2( sin(3.0/mm*pi)*ms,  cos(3.0/mm*pi)*ms), mc, -0.25*mul, 1.0, rt, -1.0);\n    l += moon(uv, vec2(-sin(4.0/mm*pi)*ms,  cos(4.0/mm*pi)*ms), mc,  0.00*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2( sin(4.0/mm*pi)*ms,  cos(4.0/mm*pi)*ms), mc,  0.00*mul, 1.0, rt, -1.0);\n    l += moon(uv, vec2(-sin(5.0/mm*pi)*ms,  cos(5.0/mm*pi)*ms), mc, -0.25*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2( sin(5.0/mm*pi)*ms,  cos(5.0/mm*pi)*ms), mc,  0.25*mul, 1.0, rt, -1.0);\n    l += moon(uv, vec2(-sin(6.0/mm*pi)*ms,  cos(6.0/mm*pi)*ms), mc, -0.50*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2( sin(6.0/mm*pi)*ms,  cos(6.0/mm*pi)*ms), mc,  0.50*mul, 1.0, rt, -1.0);\n    l += moon(uv, vec2(-sin(7.0/mm*pi)*ms,  cos(7.0/mm*pi)*ms), mc, -0.75*mul, 1.0, rt,  1.0);\n    l += moon(uv, vec2( sin(7.0/mm*pi)*ms,  cos(7.0/mm*pi)*ms), mc,  0.75*mul, 1.0, rt, -1.0);\n    l += moon(uv, vec2(-sin(8.0/mm*pi)*ms,  cos(8.0/mm*pi)*ms), mc,  1.00*mul, 1.0, rt, -1.0);\n    \n    l = min(l, 1.0);\n    \n    col = layer(col, l, l, yel);\n    \n    vec2 uv2 = uv;\n    \n    float ring = s(0., 1.5, rin(uv2, vec2(0.0), 0.6, 0.02));\n    \n    float oring = s(0., 1.5, rin(uv2, vec2(0.0), 0.9, 0.02));\n    \n    vec2 uv4 = uv;\n    uv4 *= rot(0.25*pi);\n    float ring1 = s(0., 1.5, rin(uv4, vec2(0.7-0.01, 0.0), 1.6, 0.02));\n    float ring2 = s(0., 1.5, rin(uv4, vec2(-0.7+0.01, 0.0), 1.6, 0.02));\n    \n    \n    vec2 uv5 = uv;\n    uv5 *= rot(t*pi*0.2);\n    float iring1 = s(0., 1.5, rin(uv5, vec2(0.3, 0.0), 0.3, 0.02));\n    uv5 -= vec2(0.3, 0.0);\n    uv5 *= rot(t*pi*0.2);\n    float iring2 = s(0., 1.5, rin(uv5, vec2(0.15, 0.0), 0.15, 0.02));\n\n    iring1 += iring2;\n    \n    \n    int oc = 2;\n    \n    vec2 q;\n    q.x = noisefbm(uv, oc);\n    q.y = noisefbm(uv, oc);\n    vec2 r;\n    r.x = noisefbm(uv + q + vec2(1.7,9.2)+ 0.15*t , oc);\n    r.y = noisefbm(uv + q + vec2(8.3,2.8)+ 0.125*t, oc);\n    \n    float f = noisefbm(uv+r, oc);\n    float v = voronoi((uv*10.+r)*2., 0.5).x;\n    \n    ring1 += ring2;\n    \n    ring1 *= 1.0;    //\n    \n    v = max(s(0.25, 1.0, v), 0.1);\n    \n    float ra1 = 1000.0;\n    float ra2 = 1000.0;\n    ra1 -= linear(21.9, .1, 990.0, t);   //controls the mult of the rings\n    ra2 -= linear(25.5, 1., 990.0, t);\n    iring1 -= max(f/v, 0.0)*ra2*(flip(inOutQuad(23.0, 6.0, 2.0, t), 1.)+1.0);\n    iring1 = max(min(iring1,1.0), 0.0);\n    ring1 -= v*ra1*s(flip(linear(21.9, 6.0, 2.0, t)-2.0, 0.5)+0.1, flip(linear(21.9, 6.0, 2.0, t)-2.0, 0.5), length(uv));\n    \n    ring1 = max(min(ring1,1.0), 0.0);\n    \n    ring += oring+ring1+iring1;\n\n    ring *= s(1.0, -0.25,f)*5.0;\n\n    col = layer(col, ring, ring, yel);\n    float om = -2.0;   //inner white circle\n    float omo = 0.0;   //outer white circle\n    om += outExpo(29.8, 2.0, 2.0, t);\n    omo += outExpo(29.2, 2.0, 1.0, t);\n    omo += inOutCubic(30.2, 10.0, 10.0, t);\n    \n    float wr = 2.0;   //controls the white bg twirl\n    wr -= linear(29.9, 2.0, 0.5, t);\n    \n    uv *= rot(1.-length(uv)*wr-t*0.25);\n    float wbg = s(0.5+0.5+om, 1.0+0.5+om, length(uv))*s(4.02*omo, 4.0*omo, length(uv))*min(omo*10.0,1.0); //\n    \n    \n    float v2 = voronoi((uv*2.0+r*0.75)*1., 0.5).x;\n    \n    \n    uv *= rot(length(uv)*wr+t*0.25);\n    wbg -= v2*s(1.0+0.75+om, 0.25+0.75+om, length(uv))*5.0;\n    \n    wbg = max(wbg, 0.0);\n    \n    \n    col = layer(col, wbg, wbg, vec3(0.93, 0.88, 0.82));\n    float st;\n    //yes for loops because I am lazy !!!!!!!!!!!!!!!\n    for (float i = 0.0; i < 1.0; i+=1.0/20.0){\n        st += star(uv, vec2(0.0, 1.9*min(omo,1.)), -t*0.1+i*2.0);\n        st += stik(uv, vec2(0.0, 2.5*(1.5-inOutCubic(29.2, 2.5, 0.5, t))), t*0.05+i*2.0);\n    }\n    st *= wbg;\n    col = layer(col, st, st, vec3(0.0));\n    }\n    col *= s(1.2, 0.0, length(over));\n    //col = vec3(step(1.-abs(uv.x), 0.9));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shoutout to easings.net\n\n#define pi 3.1415\n#define tr start,dur,x\n#define par float start, float dur, float p, float x\n// writing start,dur,x everywhere gets annoying\n#define xs (x-start)\n// same thing with par, just to make things less clutered\n#define s smoothstep\n\n\n// reminder for whenever I touch eases here ever again\n// 1 - stop being dumb\n// 2 - no the ease function does not have to do anything with the timing\n// 3 - when you add x please PLEASE add it as (x - start) (it's \"xs\" now)\n// 4 - stop being a silly little bean\n\nfloat c(float x){\n    return max(0.0, min(1.0, (x - 0.0) / (1.0 - 0.0)));\n}\n\nfloat o(float x){\n    return clamp(x, -1.0, 0.0);\n}\n\nfloat ease(float easing, float start, float dur, float x){\n    start += 1.0;\n    if (x >= start - 1.0 && x <= start){\n        return easing;\n    }else return o(xs) + 1.0;\n}\n\n//changed clamp dark magic to just \"return 0.0;\"                 epic\nfloat ease2(float easing, float start, float dur, float x){\n    start += 1.0;\n    if (x >= start - 1.0 && x <= start){\n        return easing;\n    }else return 0.0;\n}\n\nfloat linear(par){\n    start /= dur; x /= dur;\n    return p*ease(xs,tr);\n}\n\nfloat inSine(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - cos((xs * pi) / 2.0),tr);\n}\n\nfloat outSine(par){\n    start /= dur; x /= dur;\n    return p*ease(sin((xs * pi) / 2.0),tr);\n}\n\n// I am pretty sure doing inEase + outEase would give the same result\n// but whatev, I've already wrote everything out\n\nfloat inOutSine(par){\n    start /= dur; x /= dur;\n    return p*ease(-(cos(pi * xs) - 1.0) / 2.0, tr);\n}\n\nfloat outInSine(par){\n    start /= dur; x /= dur;\n    return p*outSine(start, 0.5, 0.5, x) + p*inSine(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 2.0),tr);\n}\n\nfloat outQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 2.0),tr);\n}\n\nfloat inOutQuad(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5 \n    ? p*ease(2.0 * (xs * xs),tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 2.0) / 2.0,tr);\n}\n\nfloat outInQuad(par){\n    start /= dur; x /= dur;\n    return p*outQuad(start, 0.5, 0.5, x) + p*inQuad(start + 0.5, 0.5, 0.5, x);\n}\n\n\nfloat inCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 3.0),tr);\n}\n\nfloat outCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow( 1.0 - xs, 3.0),tr);\n}\n\nfloat inOutCubic(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease(4.0 * xs * xs * xs, tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 3.0) / 2.0, tr);\n}\n\nfloat outInCubic(par){\n    start /= dur; x /= dur;\n    return p*outCubic(start, 0.5, 0.5, x) + p*inCubic(start+0.5, 0.5, 0.5, x);\n}\n\nfloat inQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 4.0),tr);\n}\n\nfloat outQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 4.0), tr);\n}\n\nfloat inOutQuart(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5 \n    ? p*ease(8.0 * pow(xs, 4.0), tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 4.0) / 2.0, tr);\n}\n\nfloat outInQuart(par){\n    start /= dur; x /= dur;\n    return p*outQuart(start, 0.5, 0.5, x) + p*inQuart(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 5.0),tr);\n}\n\nfloat outQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 5.0), tr);\n}\n\nfloat inOutQuint(par){\n    start /= dur; x /= dur;\n    return xs < 0.5 \n    ? p*ease(16.0 * pow(xs, 5.0), tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 5.0) / 2.0, tr);\n}\n\nfloat outInQuint(par){\n    start /= dur; x /= dur;\n    return p*outQuint(start, 0.5, 0.5, x) + p*inQuint(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(2.0, 10.0 * xs - 10.0),tr);\n}\n\nfloat outExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(2.0, -10.0 * xs), tr);\n}\n\nfloat inOutExpo(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease(pow(2.0, 20.0 * xs - 10.0) / 2.0, tr)\n    : p*ease((2.0 - pow(2.0, -20.0 * xs + 10.0)) / 2.0, tr);\n}\n\nfloat outInExpo(par){\n    start /= dur; x /= dur;\n    return p*outExpo(start, 0.5, 0.5, x) + p*inExpo(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(1.0 - sqrt(1.0 - pow(xs, 2.0))), tr);\n}\n\nfloat outCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(sqrt(1.0 - pow(xs - 1.0, 2.0))), tr);\n}\n\n\nfloat inOutCirc(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease((1.0 - sqrt(1.0 - pow(2.0 * xs, 2.0))) / 2.0, tr)\n    : p*ease((sqrt(1.0 - pow(-2.0 * xs + 2.0, 2.0)) + 1.0) / 2.0, tr);\n}\n\nfloat outInCirc(par){\n    start /= dur; x /= dur;\n    return p*outCirc(start, 0.5, 0.5, x) + p*inCirc(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 <= 0.0) c1 = 1.70158;\n    float c3 = c1 + 1.0;\n    \n    return p*ease(c3 * pow(xs, 3.0) - c1 * pow(xs, 2.0), tr);\n}\n\nfloat outBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 <= .0) c1 = 1.70158;\n    float c2 = c1 + 1.;\n    \n    return p*ease(1. + c2 * pow(xs - 1., 3.) + c1 * pow(xs - 1.0, 2.0), tr);\n}\n\nfloat inOutBack(par){\n    start /= dur; x /= dur;\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n    \n    return x - (start - 1.0) < 1.5\n    ? p*ease((pow(2.0 * xs, 2.0) * ((c2 + 1.0) * 2.0 * xs - c2)) / 2.0, tr)\n    : p*ease((pow(2.0 * xs - 2.0, 2.0) * ((c2 + 1.0) * (xs * 2.0 - 2.0) + c2) + 2.0) / 2., tr);\n}\n\nfloat outInBack(par, float c1){\n    start /= dur; x /= dur;\n    return p*outBack(start, 0.5, 0.5, x, c1) + p*inBack(start + 0.5, 0.5, 0.5, x, c1);\n}\n\nfloat inElastic(par){\n    start /= dur; x /= dur;\n    float c = (2.0 * pi) / 3.0;\n    \n    return p*ease(-pow(2.0, 10.0 * xs - 10.0) * sin((xs * 10.0 - 10.75) * c), tr);\n}\n\nfloat outElastic(par){\n    start /= dur; x /= dur;\n    float c = (2.0 * pi) / 3.0;\n    \n    return p*ease(pow(2.0, -10.0 * xs) * sin((xs * 10.0 - 0.75) * c) + 1.0, tr);\n}\n\nfloat inOutElastic(par){\n    start /= dur; x /= dur;\n    float c = (2. * pi) / 4.5;\n    \n    return xs < 0.5\n      ? p*ease(-(pow(2.0, 20.0 * xs - 10.0) * sin((20.0 * xs - 11.125) * c)) / 2.0, tr)\n      : p*ease((pow(2.0, -20.0 * xs + 10.0) * sin((20.0 * xs - 11.125) * c)) / 2.0 + 1.0, tr);\n}\n\nfloat outInElastic(par){\n    start /= dur; x /= dur;\n    return p*outElastic(start, 0.5, 0.5, x) + p*inElastic(start + 0.5, 0.5, 0.5, x);\n}\n\n// I can't figure this out,,,\n// (^lie^) I FIGURE TI OUTBJkfnlajskbf\nfloat outBounce(par){\n    start /= dur; x /= dur;\n    float n = 7.5625;\n    float d = 2.75;\n    \n\tif (xs < 1.0 / d){\n\t\treturn p*ease(n * xs * xs, tr);\n\t}else if (xs < 2.0 / d){\n\t\tx = x - 1.5 / d;\n\t\treturn p*(n * xs * xs + 0.75);\n\t}else if (xs < 2.5 / d){\n\t\tx = x - 2.25 / d;\n\t\treturn p*(n * xs * xs + 0.9375);\n\t}else{\n\t\tx = x - 2.625 / d;\n\t\treturn p*min(n * xs * xs + 0.984375, 1.);\n\t}\n}\n\nfloat inBounce(par){\n    return p*(1.0-outBounce(start, 1.0, 1.0, 1.0-xs));\n}\n\nfloat inOutBounce(par){\n    start /= dur; x /= dur;\n    return xs < 0.5\n    ? p*(1.0 - outBounce(start, 1.0, 1.0, (1.0+start) - 2.0 * xs)) / 2.0\n    : p*(1.0 + outBounce(start, 1.0, 1.0, 2.0 * xs - (1.0-start))) / 2.0;\n}\n\n\n// mirin eases\n\nfloat bounce(par){\n    start /= dur; x /= dur;\n    return p*ease2(4.0 * xs * (1.0 - xs), tr);\n}\n\nfloat tri(par){\n    start /= dur; x /= dur;\n    return p*ease2(1.0 - abs(2.0 * xs - 1.0), tr);\n}\n\nfloat bell(par){\n    start /= dur; x /= dur;\n    return p*inOutQuint(start, 1.0, 1.0, tri(start, 1.0, 1.0, x)+start);\n}\n\nfloat pop(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * (1.0 - xs) * (1.0 - xs) * sqrt(xs), tr);\n}\n\nfloat tap(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * xs * xs * sqrt(1.0 - xs), tr);\n}\n\nfloat pulse(par){\n    start /= dur; x /= dur;\n    return p*tap(start, 0.5, 0.5, x)-pop(start+0.5, 0.5, 0.5, x);\n}\n\nfloat spike(par){\n    start /= dur; x /= dur;\n    return p*ease2(exp(-10.0 * abs(2.0 * xs - 1.0)), tr);\n}\n\nfloat invert(par){\n    start /= dur; x /= dur;\n    return p*ease2(xs * xs * (1.0 - xs) * (1.0 - xs) / (0.5 - xs), tr);\n}\n\nfloat flip(float ease){\n    return 1.0-ease;\n}\nfloat flip(float ease, float power){\n    return power-ease;\n}\n\n\nfloat hash1( float n){\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash2( vec2 p ){\n    p = vec2(dot(p, vec2(67.1, 21.7)), dot(p, vec2(59.5, 43.23)));\n    return fract(sin(p)*4358.5453);\n    \n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n    vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec4 voronoi( vec2 x, float w ){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec4 m = vec4(8.0, 0.0, 0.0, 0.0);\n\n    for (int j=-2; j<=2; j++)\n    for (int i=-2; i<=2; i++){\n        \n        vec2 g = vec2( float(i), float(j) );\n        vec2 o = hash2(n +g);\n\n        //animate\n        //o = 0.5 + 0.5*sin(t+pi*2.0*o);\n\n        float d = length(g-f+o);\n\n        vec3 col = 0.5 + 0.5*sin(hash1(dot(n+g, vec2(7.0, 113.0)))*2.5 + 3.5 + vec3(2.0, 3.0, 0.0));\n\n        col *= col;\n\n        float h = s(-1.0, 1.0, (m.x-d)/w);\n        m.x = mix(m.x, d, h) - h*(1.0-h)*w/(1.0+3.0*w);\n        m.yzw = mix(m.yzw, col, h) - h*(1.0-h)*w/(1.0+3.0*w);\n        \n    }\n\n    return m;\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noisefbm (vec2 st, int octaves) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(st*6.);\n        st *= .5;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat voronoisefbm (vec2 st, int octaves) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * voronoi(st*6., 1.0).x;\n        st *= 1.5;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n","name":"Common","description":"","type":"common"}]}