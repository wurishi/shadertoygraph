{"ver":"0.1","info":{"id":"wlX3RS","date":"1556658986","viewed":149,"name":"Proper dithering with gamma","username":"orlp","description":"Proper dithering with gamma.","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["noise","dither","gamma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LINE_THICKNESS 0.002\n#define DEPTH 4.\n#define REPS 500.\n\n\nfloat lin2srgb(float x) {\n    if (x <= 0.0031308)\n        return 12.92 * x;\n    else\n        return 1.055*pow(x, (1.0 / 2.4)) - 0.055;\n}\n\nfloat srgb2lin(float x) {\n    if (x <= 0.04045)\n        return x / 12.92;\n    else\n        return pow((x + 0.055) / 1.055, 2.4);\n}\n\nfloat tr(float x) {\n    return srgb2lin(x / (DEPTH - 1.0)) * (DEPTH - 1.0);\n}\n\n\n\nuint bindith(float c, uint depth, float rng) {\n    float cmax = float(depth) - 1.0;\n    float lo = floor(c * cmax);\n    float hi = lo + 1.;\n    \n    float linlo = srgb2lin(lo / cmax);\n    float linhi = srgb2lin(hi / cmax);\n    float linc = srgb2lin(c);\n    \n    if (rng < (linc - linlo)/(linhi - linlo)) {\n        return uint(hi);\n    } else {\n    \treturn uint(lo);\n    }\n}\n\n// Original idea by Mikkel Gjoel (https://computergraphics.stackexchange.com/a/5952/10515),\n// simplified to one readable function.\n\n// Dithers and quantizes color value c in [0, 1] to the given color depth.\n// It's expected that rng contains a uniform random variable on [0, 1].\nuint dither_quantize(float c, uint depth, float rng) {\n    float cmax = float(depth) - 1.0;\n    float ci = c * cmax;\n\tfloat cr = floor(ci + 0.5);\n    \n    if (ci < 0.5 || ci > cmax - 0.5) {\n        return bindith(c, depth, rng);\n    }\n    \n    float lop = pow((ci - (cr - .5)), 2.0) * (tr(cr + .5) - tr(cr))/(tr(cr + 1.0) - tr(cr));\n    float midp = -((tr(ci) + (-1.0 + lop)*tr(-1.0 + cr) - lop*tr(1.0 + cr))/(tr(-1.0 + cr) - tr(cr)));\n    //float hip = (tr(ci) + (-1.0 + lop)*tr(cr) - lop*tr(1.0 + cr))/(tr(-1.0 + cr) - tr(cr));\n  \n    if (rng < lop) {\n        return uint(cr + 1.0);\n    } else if (rng < lop + midp) {\n        return uint(cr);\n    }\n    return uint(cr - 1.);\n}\n\n\n\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat line(float d) {\n    return smoothstep(0., d, LINE_THICKNESS);\n}\n\n\nfloat i2f(uint i) {\n    return float(i) / (DEPTH - 1.0);\n}\n\nvec3 graphic(vec2 uv) {\n    vec2 g = vec2(uv.x * 1.5 - 0.25, (uv.y - 0.05) / 0.4);\n    \n    if (-LINE_THICKNESS < g.x && g.x < 0. ||\n        1.0 < g.x && g.x < 1.0 + LINE_THICKNESS) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    \n    uvec3 seed = uvec3(int(uv.x * 100000.), int(uv.y*100000.), iFrame);\n    float signal = clamp(g.x, 0.0, 1.0);\n    float dithered = i2f(dither_quantize(signal, uint(DEPTH), hash(seed).x));\n    float avg = 0.;\n    float variance = 0.;\n    for (float i = 0.; i < REPS; i += 1.) {\n        uvec3 r = seed + uint(i);\n        float d = i2f(dither_quantize(signal, uint(DEPTH), hash(r).x));\n        avg += srgb2lin(d) / REPS;\n        variance += (d - signal) * (d - signal) / REPS;\n    }\n    \n    avg = lin2srgb(avg);\n    float error = avg - signal;\n    dithered = dithered;\n    \n    if (uv.y > 4.5/6.) {\n        return vec3(signal);\n    }\n    \n    //if (uv.y > 4./6.) {\n    //    return vec3(avg);\n    //}\n    \n    if (uv.y > 3./6.) {\n        float rand = texture(iChannel0, uv*iResolution.xy/1024.).y;\n        return vec3(i2f(dither_quantize(signal, uint(DEPTH), rand)));\n        return vec3(dithered);\n    }\n    \n    vec3 c = vec3(0.);\n    \n    // Signal.\n    c += vec3(0.5) * line(abs(g.y - signal));\n    \n    // Average dithered signal.\n    c += vec3(1.0, 1.0, 0.0) * line(abs(g.y - avg));\n    \n    // Error of average.\n    c += vec3(1.0, 0.0, 0.0) * line(abs(g.y - 0.5 - error * 5.));\n    \n    // Variance.\n    c += vec3(0.0, 0.0, 1.0) * line(abs(g.y - variance * 15.));\n    \n    return c;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.);\n    fragColor = vec4(graphic(uv), 1.0);\n}","name":"Image","description":"","type":"image"}]}