{"ver":"0.1","info":{"id":"tsVBzR","date":"1606498914","viewed":162,"name":"City Game  II  (all features)","username":"kastorp","description":"same as City game II,  with multiple lanes , view mode enabled (on half resolution).\n35s compilation time with Angle.  Optimized for full screen visualization.\nASWD to move, mouse to rotate/zoom, caps-lock to switch to edit mode\n","likes":5,"published":1,"flags":48,"usePreview":1,"tags":["game","simulation","city","traffic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// City Game  II  (all features) by KASTORP\n// Fork of \"City Game  II\"\n/*------------------------------------------------------\nIt takes 35s compilation time with Angle... please wait \non windows+chrome,  this cmd to reduce compilation time to 2sec:\n\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" --use-angle=gl\n\nThis version is by default in view mode, \noptimized for full screen visualization. \nI also reduced resolution to achieve an acceptable framerate.\nUse \"#define RR 1.\" to set full resolution.\n\nIf you want to edit, toggle CAPS-LOCK on.\n\nto move camera target (red dot), use ASWD \nto rotate and zoom camera around target, use mouse\n\nwhen car crashes, one of them becomes red and the other disappers\nthere are still some residual cases where this happen, but it's hard to find them \n\nThe game is tested only on windows   \n\n\n-----------\nGAME INSTRUCTIONS\n\nthe city needs your help!\n- connects all road to the center (yellow square)\n- connect all buildings to roads\n- convert congested semaphores & overpass into roundabouts\n- let all taxis (yellow cars) reach the center\n\nUnconnected roads/building are darker\nThe overall % of connected is shown up/right\nThe counter of remaining taxis is shown uu/right \n\nblock types and actions:\n   ROAD: add road\n   SEMAphore:  use with care! if 4 connections --> overpass\n   ROUNdabout: best solution for crossing\n   BUILding: add skyscraper\n   GRASs: clear block \n\nControls:\n   click on block type: select \n   click or drag on map: add selected block\n   ASWD: move camera\n   mouse in right panel: rotate/zoom camera\n   CAPS-LOCK:  view mode / game mode\n   click + SHIFT or CTRL: special actions for selected block type\n\t\tROAD: +SHIFT: disabile auto roundabout, +CTRL= remove single connection between blocks\n\t\tGRASS: +SHIFT=increase altitude, +CTRL=decrease altitude\n   SPACE BAR: reset map \n   Z: switch 2D/isometric view in right panel (2D is faster)\n\nThe simulation work also with 3 lanes (#define LANES 3)\n\n//TODO:\n  variable number of lanes & wider lane rendering\n  better congestion detection for each block, based on average velocity\n  use congestion to update paths\n\n------------------------------------------------------*/\n\n#define R iResolution.xy\nvec4 char(vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    return textureGrad( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n\n// --- display int4\nvec4 pInt(float d, vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = d-1.; i>=0.; i--) \n        n /= 10.,\n        v += char(p - vec2(.5*i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n#define pString(p,st)  for(int _i= st.length()-1 ;_i>=0;_i-- ) Q+= char(p -vec2(.5*float(_i),0.), st[_i]).x; \n#define pStringC(p,st,c) for(int _i= st.length()-1 ;_i>=0;_i-- ) Q+= c* char(p -vec2(.5*float(_i),0.), st[_i]).x; \n\n//quick & dirty tilt shift emulation\nvoid tiltshift( out vec4 o, in vec2 q, in vec2 center )\n{\t\n    vec4 ref = texelFetch( iChannel3, ivec2(q),0);\n       \n\tint N = 2;\n    vec4 acc = vec4(0.0);\n    float sf = clamp(6. - length(q - center)*12.*RR,.5,5.);\n\tfor( int j=-N; j<=N; j++ ) for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));      \n        vec4 tmp = texture( iChannel3, q + off/vec2(iResolution.xy)+vec2(.01) );      \n\t\tfloat w =  1./(1.+  pow(length(off)*sf,2.)) ;\n        acc += vec4(tmp.xyz*w,w);     \n    }\n    vec3 col = acc.xyz / acc.w;\n    o = vec4(col,ref.w) * (5.+sf*2.)/15.;\n}\n\n\nMain {\n    if(DEMO){\n        tiltshift(Q,U/iResolution.xy/RR,vec2(1./2.,1./3.)/RR);\n    \n    \tQ.rgb =pow( clamp(Q.rgb,0.,1.) , vec3(.5));\n    }\n    else Q=texture(iChannel3, U/iResolution.xy/RR );\n    \n       #ifdef HELP \n\n    //VERTICAL BAR\n    if(((!WIN && !DEMO )) && abs(U.x-R.x*ZX)<2. ) {Q=vec4(0.);return;}\n\n\n    //INSTRUCTIONS\n    #if QUALITY>0\n    if((DEMO || WIN) && iMouse.z>0. ){\n        if(length(U-vec2(R.x/2.,R.y/3.))<R.x/150.) Q=vec4(1.,0.,0,0.);\n        /*\n        if(abs(U.x-R.x*ZX)<2.  && abs(iMouse.x-R.x*ZX)<R.x/10.) Q=vec4(0.);\n        if(iMouse.x> R.x*ZX){\n\t        pString( U/R*22. -vec2(17.,20.), int[] (82,79,84,65,84,69));\n            pString( U/R*22. -vec2(17.,19.), int[] (90,79,79,77));\n        }\n        else{\n        \tpString( U/R*22. -vec2(2.,20.), int[] (77,79,86,69));\n        }\n        */\n    }else{\n    \tif(iMouse.z>0.  && length(U-vec2(R.x*(ZX*.5+.5),R.y/3.))<R.x/150.) Q=vec4(1.,0.,0,0.);\n    }\n    #endif        \n\n            //COUNTER\n        vec4 c= CONF(vec2(1.,0.));\n        //CARS\n        if(c.g>0.){\n            pString( U/R*22. -vec2(16.,19.), int[] (67,65,82,83,58));\n            if(pInt(5., U/R*22. -vec2(19.,19.),(c.g ) ).x >0.4) Q=vec4(1.,1.,0.,0.); \n        }\n    \n    if(DEMO){\n        #if QUALITY>0\n        if(RESET<100.) pString( U/R*22. -vec2(7.5,1.), int[] (80,82,69,83,83,32,83,80,65,67,69));\n        #endif\n    }else{\n\n\n\n        //WIN\n        if(GAME){\n            if(c.b<1. && c.g<1.){\n                U.x+=  (-1.+ mod(iTime/3.,2.))*R.x;\n                pString( U/R*3. -vec2(1.,1.), int[] (64+23,64+9,64+14));\n            }else {\n                if(c.b>0.){\n                    Q += char(U/R*11. -vec2(8.,10.) ,29   ).x;\n                    Q +=pInt(2., U/R*11. -vec2(9.,10.),(100.- c.b/c.r*100. ) ).x; \n                    Q += char(U/R*11. -vec2(10.2,10.) ,37   ).x;\n            }\n        }\n    }\n        vec4 Q0=Q;\n        if(sdBox(U/R*20. -vec2(10.*ZX,.6 ),vec2(10.*ZX -.2 ,.4 ))<0. && keyToggle(CH_CAPS)){\n            Q= vec4(1.);\n    \t\tint sel = int(CONF(vec2(2.,0.)).x);\n            vec4 C=vec4(1,.5,.5,1);\n            if(abs(floor(U.x/R.x/(ZX-.1)*4.5 +.8*(ZX/.7))-float(sel))<.5) C=vec4(.5,1.,.5,1);\n            pStringC( U/R*20.*vec2(.7/ZX) -vec2(1.,.1), int[] (82,79,65,68,32, //ROAD\n                                                               83,69,77,65,32, //SEMA\n                                                               82,79,85,78,32, //ROUN\n                                                               66,85,73,76,32, //BUIL\n                                                               71,82,65,83     //GRAS\n                                                              ),C);\n\n            if(Q.x>1.) Q-=vec4(1.,1.,1.,1.);else Q=mix(Q0,Q,.3);\n        }\n        \n      \n    }\n    #endif   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*ENGINE SHADER\n\neach 6x6 block is divided into 36 position; (0,0) is block data, the other are Cells\n\n5\t11\t17\t23\t29\t35\n4\t10\t16\t22\t28\t34\n3\t9\t15\t21\t27\t33\n2\t8\t14\t20\t26\t31\n1\t7\t13\t19\t25\t31\n0\t6\t12\t18\t24\t30\n\neach cell can be a road or not, depending on the block type\n\nROUND   SEMA    ROAD    OVER\nbtype=4 btype=2 btype=4 btype=5\n\n..00..  ..00..  ..00..  ..00..       \n.xxxx.  ..00..  ..00..  .S00S.   \n3x..x1  33xx11  33xx11  33xx11   \n3x..x1  33xx11  33xx11  33xx11   \n.xxxx.  ..22..  ..22..  .S22S.  \nR.22..  R.22..  R.22..  R.22..   \n\nroad cell can contain a vehicle per lane \nfor each lane/vehicle the cell stores \n\tvehicle type --> none, blue, yellow\n\tincoming direction --> the relative position of incoming cell\n \tspeed, --> determined by precedence and closest vehicle distance  \n    offset --> -5. when entering, +.5 when leaving\n\toutgoing direction --> determined by available direction and target block\n\toutgoing lane --> determined by lane change logic\n\nwhen a vehicle moves from one cell to the neightbour, both leave & enter logic must be executed\n\n--------------*/\n\n#define R iResolution.xy\n    \n//ROUTING\nvec2  next_(vec2 point, in block b,bool turn){\n    \n    //block position is always excluded\n\tif( abs(point.x-.5) <.5 && abs(point.y-.5)<.5) return vec2(0.);\n     \n    vec2 d = (vec2(point.x-3.,point.y-3.));\n    \n    float dm=max(abs(d.x),abs(d.y));\n          \n\n    // CROSS   \n    if(b.btype==1  ){\n        //TURN DIRECTION\n        if(turn==true){\n        \tif(abs(point.x-4.5) <.5 && abs(point.y-2.5)<.5 && (b.conns&2)>0) return vec2(1.,2.);\n            if(abs(point.y-4.5) <.5 && abs(point.x-3.5)<.5 && (b.conns&1)>0) return vec2(0.,2.);\n            if(abs(point.x-1.5) <.5 && abs(point.y-3.5)<.5 && (b.conns&8)>0) return vec2(3.,2.);\n            if(abs(point.y-1.5) <.5 && abs(point.x-2.5)<.5 && (b.conns&4)>0) return vec2(2.,2.);\n        \n        }\n        // DEFAULT DIRECTION\n        else{\n            if( (abs(point.x-3.5) <1.5 && abs(point.y-4.5)<.5 ) || (abs(dm-2.5) <.5 && abs(d.y-.5)<.5 )) return vec2(3.,15.);   \n            if( (abs(point.x-4.5) <.5 && abs(point.y-2.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x-.5)<.5 ))return vec2(0.,15.);\n            if( (abs(point.x-2.5) <1.5 && abs(point.y-1.5)<.5)  || (abs(dm-2.5) <.5 && abs(d.y+.5)<.5 ))return vec2(1.,15.);\n            if( (abs(point.x-1.5) <.5 && abs(point.y-3.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x+.5)<.5 )) return vec2(2.,15.);\n        }\n    }\n    //SEMAPHORE\n    if(b.btype==2 && turn==true){\n        int pos= 1+int(floor(mod(point.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod((point.y-1.), BLOCK_BUFFER.y)));\n    \tint k=100;//set to 0 to enable left turn\n        if((pos==14+k || (pos==20 && (b.conns&2)>0)) && b.semaphore==0) return vec2(1.,2.);\n        if((pos==21+k || (pos==15 && (b.conns&8)>0))  && b.semaphore==0) return vec2(3.,2.);\n        if((pos==20+k || (pos==21 && (b.conns&1)>0)) && b.semaphore==1) return vec2(0.,2.);\n        if((pos==15+k || (pos==14 && (b.conns&4)>0)) && b.semaphore==1) return vec2(2.,2.);\n\n    }\n    \n    //JUNCTION\n\tif((b.btype==4 || b.btype==2 || b.btype==5 || b.btype==6)&& turn==false){ \n        \n\n        \n        bool central = (abs(dm) <1.);\n        if(b.btype==2 && central){\n       \t\t if(b.semaphore>0) b.conns &= 10; else b.conns &= 5;\n   \t\t}\n        \n        \n        //OVERPASS\n\n        float shift_out = 0.;\n        if(b.btype==5){                    \n        \tif( central ) b.conns &= 10; //overpass down              \n            int pos= 1+int(floor(mod(point.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod((point.y-1.), BLOCK_BUFFER.y)));\n   \t\t\t\n            if(pos==25 || pos==28) return vec2(0.,15.);  //overpass up\n            if(pos==7 || pos==10) return vec2(2.,15.);  //overpass up\n        }\n\n        \n        //UP\n        if(abs(point.x-3.5)<.5 &&(\n            ( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&2)==0 && abs(point.y-2.5)<.5  )  \n            ||( (b.conns&1)==1 && abs(point.y-3.5)<.5  )  \n        )) return vec2(0.,15.);\n\t\t//DOWN\n         if(abs(point.x-2.5)<.5 &&(\n            ( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&8)==0 && abs(point.y-3.5)<.5  )  \n            ||( (b.conns&4)==4 && abs(point.y-2.5)<.5  )  \n        )) return vec2(2.,15.);\n        //RIGHT\n        if(abs(point.y-2.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&4)==0 && abs(point.x-2.5)<.5  )  \n            ||( (b.conns&2 )==2 && abs(point.x-3.5)<.5  )  \n        )) return vec2(1.,15.);\n        //LEFT\n        if(abs(point.y-3.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&1)==0 && abs(point.x-3.5)<.5  )  \n            ||( (b.conns&8 )==8 && abs(point.x-2.5)<.5  )  \n        )) return vec2(3.,15.);\n        \n    }\n    \n    return vec2(0.);\n\n    \n}\nvec2  next(int pos, in block b,bool turn){\n    vec2 point=  vec2(\n         floor(float(pos)/BLOCK_BUFFER.x),\n         floor(mod(float(pos),BLOCK_BUFFER.x)) \n    ) +.5;\n    return  next_(point,  b, turn);\n}\n\ncell nextCell(cell c, int i , int btype){\n    vec3 ncoord = nextCoord(c,i,btype); \n    vec4 ndata = CELL(coord2buffer(ncoord));       \n    return decodeCell(ndata,ncoord); \n}\n\n\n\n//STOP\nbool stop(block b, cell c){\n    if(b.btype==2 && b.semaphore==1 && (c.pos==16 || c.pos==117 || c.pos==118 || c.pos==19 ) ) return true;\n    if(b.btype==2 && b.semaphore==0 && (c.pos==102 || c.pos==8 || c.pos==27 || c.pos==133 ) ) return true;\n    return false;\n}\n\n\nbool isShift(in block b, int pos){\n    if(b.btype==5 &&  (pos==7 || pos==10 || pos==25 || pos==28 ) ) return true;    \n\treturn false;\n}\n\n\nbool  isRoad(in block b, int pos){\n    vec2 point=  vec2(\n         floor(float(pos)/BLOCK_BUFFER.x),\n         floor(mod(float(pos),BLOCK_BUFFER.x)) \n    ) +.5;\n    return  isRoad_( b, point);\n}\n\n//------------------------\n\nMain {\n    \n \tQ =vec4(0.);\n \n\tvec3 coord = buffer2coord(U);\n    vec3 bcoord= vec3( coord.xy,0.);\n    \n      \n    \n    //discard texels outside view\n    if(coord.x>=BMAX.x || coord.y>= BMAX.y) { discard;}\n    \n    //RESET\n    if (iFrame<2 || TS.x != CONF(vec2(0.)).z\n\t\t|| (RESET <2. && (DEMO|| WIN))\n       ){\n        \n        \n       \tint ltype=  int(.8+ fbm_noise(100. + bcoord.xy/30.+iTime*100.,2))*2;\n        int btype=min(int(.9 + hash(U +iTime)*(ltype==2?1.8: .7)),1)*4;     \n     \n        if(isBlockCoord(coord)){\n            \n            float thp=float(THEIGHT+5) * (1.- length(coord.xy -vec2(BMAX/2.)) /length(BMAX/2.)  );\n             int th=  max(0, -5+ int(fbm_noise(bcoord.xy/15.+iTime*100.,2)*thp));\n\t\t\t\t\n            th= int(float(th+6)/10.)*10;\n            \n            if(mod(coord.x,2.)+mod(coord.y,2.)<.5)  btype= 0;     \n            \n            if(th<=1) {btype=0; ltype=0;}\n            \n            int bh= 50+ int(floor(hash(bcoord.xy)*float(HEIGHT-50)/10.)*10.);\n            \n            float ctr=sdBox(bcoord.xy-vec2(floor(BMAX/2.)),vec2(.5));\n            if(ctr<=0.) {\n                ltype=3;\n                btype=0;\n                bh=HEIGHT;\n                th=max(th,10);\n            }\n            else if(ctr<=1.) {btype=1;}\n            \n        \tblock b = newBlock(coord,btype,ltype,bh,th);\n            \n            Q= encodeBlock(b);\n        \n        }       \n        else {\n            \n\n            cell c = newCell( coord, false,false);\n            \n            for(int n=0;n<LANES;n++){\n                if(hash(U*float(n+2))<VEHICLE_DENSITY) {\n                     c.v[n] = newVehicle(\n                        int(1.5+ hash(U*5.)*1.4),\n                        3, //SPEED\n                        -.52, //OFFSET\n                        vec2(vec2(mod(U.x , BMAX.x), mod(U.y ,  BMAX.y))),\n                        0,\n                        0,\n                         n //LANE\n                        );\n\n                }\n            }\n        \t//packing\n            Q= encodeCell(c);\n        }\n          \n    } \n    \n    //MAIN CYCLE\n    else if(U.y>0.5 && coord.x>=0. && coord.y>=0. ){\n        \n        Q = BLOCK(U);\n        \n        block b = decodeBlock(BLOCK(coord2buffer(bcoord)),bcoord.xy);\n        \n        int sel = int(CONF(vec2(2.,0.)).x);\n        \n        //block logic\n        if(isBlockCoord(coord)){\n            \n\n            //mouse ACTIONS\n            vec3 mcoord=buffer2coord(  (MOUSE_INPUT*RR-SHIFT_VIEW) /ZOOM +.5);\n            vec2 mcoords= buffer2point( (MOUSE_INPUT*RR-SHIFT_VIEW) /ZOOM +.5)-vec2(3.);\n            int mdir =abs(mcoords.x)>abs(mcoords.y)?(mcoords.x>0.?2:8):(mcoords.y>0.?1:4);\n            if(keyToggle(CH_CAPS) && !DEMO &&!WIN  && !zoomMode  &&b.ltype!=3) \n            { \n                \n                float l= length(mcoord.xy-bcoord.xy );\n                \n                if(l<2.&&sel==5 && iMouse.z>0.){\n                    int thd=0;\n                    if(keyDown(CH_SH)) thd+= 6 -int(l*3.);\n                    if(keyDown(CH_CTRL)) thd-= 6 -int(l*3.);\n                \t b.th =clamp( b.th + thd,0,THEIGHT);\n                }\n                \n                if(l<1.){\n                    if(sel==5) { b.btype= 0; b.ltype=0;b.dist=MAX_DIST;b.aconns=15;}\n                    else if(sel==4) {b.btype= 0; b.ltype=2;b.dist=MAX_DIST; b.aconns=15;}\n                    else if(sel==3) {b.btype=1; b.aconns=15;}\n                    else if(sel==2)  {b.btype=2; b.aconns=15;}\n                    else {\n                        \n                        if(keyDown(CH_CTRL)) b.aconns = b.aconns & (15-mdir);\n                        else if(!keyDown(CH_SH) && (b.conns&1) + (b.conns&2)/2 + (b.conns&4)/4 + (b.conns&8)/8 >=3 ) {b.btype=1; } \n                        else {b.btype=4;}\n                    }\n                }\n            }\n            \n\n            \n            \n        \t//connections:\n        \tint conX =0,conY=0, conns=0 , dmin=MAX_DIST,dir=0,buildings=0,th=0;\n            for(int i=0;i<4;i++){\n            \tvec3 nbCoord=vec3(coord.xy + DIRS[i], coord.z);\n                if(nbCoord.x>=0. && nbCoord.x< BMAX.x && nbCoord.y>=0. && nbCoord.y< BMAX.y){\n                    block nb = decodeBlock(BLOCK(coord2buffer(nbCoord)),nbCoord.xy);\n                    int bit =int(pow(2., float(i))), bitn=int(pow(2., float( (i+2)%4))) ;\n                    if ((b.aconns & bit )> 0 && (nb.aconns&bitn)>0){\n                        if((nb.btype>0  )  && i%2==0) conY++;\n                        if((nb.btype>0 ) && i%2==1) conX++;\n                        if(nb.btype>0 || nb.ltype==3 ) conns +=  bit;// 1>>i;\n                        if(nb.btype==0 && nb.ltype>0 ) buildings +=1;\n                    }\n                    if(nb.dist<dmin) {dmin= nb.dist;dir=i;}\n                    \n                    \n                    //max th\n                    if(int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==0 ) {\n                        th=b.th;\n                    }\n                    else th=max(th,nb.th); \n\t\t\t\t\t\n                    \n                } \n            }\n            #if QUALITY>1\n            if(b.btype==0 && b.ltype==2 && th>b.bh) b.bh=th+40;\n            if(b.btype==0 && b.ltype==2 && th<1) b.ltype=0;\n            #endif\n            \n            //DISTANCE FROM CENTER\n            if(b.ltype==3 ) b.dist=!DEMO?0:MAX_DIST;\n            else if( dmin< b.dist && b.btype>0 ){b.dist=dmin+1; b.dir=dir;}\n            else if( b.dist<  dmin ){ b.dist =MAX_DIST;}\n            \n            //if(mod(coord.x,2.)+mod(coord.y,2.)<.5) b.btype=0; else \n            \n            //semaphore-->OVERPASS\n            if(b.btype==5 && b.conns<15){\n            \tb.btype==2;\n            }\n            if(b.btype==2 && b.conns==15){\n            \tb.btype=5; \n\n            }\n            \n            if( RESET <5. ){\n                if(conX+conY<1 && b.btype!=0 ) b.btype=0;\n                if(conX+conY==1  && b.btype!=0  && buildings==0 ) b.btype=0; \n                if(conX+conY==3 &&  b.btype!=0  ) b.btype=(hash(U*4. +iTime)>.5 )?1:2; \n                else if(conX+conY==4 &&  b.btype!=0  ) b.btype= (hash(U*7. +iTime)>.5 )?1:5;\n                else if(conX+conY==2 &&  b.btype!=0  ) b.btype=4;\n                else if(b.btype!=0 ) b.btype=4;\n            }\n            b.conns=conns;\n            \n\n\n            \n             //SEMAPHORE switch every 5 secs\n            if(b.btype==2){\n            \tb.semaphore = int(mod(iTime/5. +hash(coord.xy*7.),2.));\n            }\n                \n                \n\t\t\t//COUNTER\n            b.counter=0.;\n            for(float k=1.;k<36.;k++){\n            \tvec3 vcoord =vec3(coord.xy,k);\n        \t\tvec4 vdata = CELL(coord2buffer(vcoord));\n        \t\tcell c = decodeCell(vdata,vcoord);\n                for(int n=0;n<LANES;n++){\n                    bool carCounter= GAME?c.v[n].vtype==1: c.v[n].vtype>0;\n                \tif(carCounter && c.road)b.counter+=1.;\n                }\n            }     \n                \n            Q= encodeBlock(b);\n                \n                \n        }\n        //vehicle logic\n        else{\n            //unpacking\n            cell c = decodeCell(Q,coord);\n            \n            \n            c.road=isRoad( b,  c.pos);          \n            c.shift=isShift( b,  c.pos);\n                     \n            \n\t\t\t//clean vehicles outside road\n            if(!c.road && !c.shift ) c = newCell( coord, false,false);\n                      \n            else for(int n=0;n<LANES;n++){\n                \n                int n2 = (n+1)%LANES; //other lane   \n             \tint n3 = (n+2)%LANES; //right lane (if LANES==3 and central lane)\n                int vcount=0;\n                if(c.v[n].vtype>0 ) {\n                \tvcount++;\n                    c.v[n].brake=false;\n                    //next direction (initialization)\n                    if(c.v[n].offset <=-.5){\n                        vec2 nx =next(c.pos,b,false);\n                        if(nx.y>0.) {c.v[n].dir_out=int(nx.x); }\n\n                        vec2 nx2 =next(c.pos,b,true);\n                        if(nx2.y>0.  ) {c.v[n].dir_out=int(nx2.x); nx=nx2;}\n                    }\n\n\t\t\t\t\t\n                    cell nc = nextCell(c,c.v[n].dir_out,b.btype);\n                    #if LANES>1\n                    \n                    int n_out = c.v[n].lane_out;\n                    // in every momenty, revert lane change if other lane is busy\n                    if(n_out!= n && c.v[n_out].vtype>0) {c.v[n].lane_out=n; n_out=n;}\n\n                    #else\n                    int n_out =n;\n                    #endif\n                    \n\t\t\t\t\t//check vehicle in same target  lane of next cell\n                    float dist =(nc.v[n_out].vtype==0) ? ACC_DIST : (1.+ nc.v[n_out].offset-c.v[n].offset +float(nc.v[n_out].vel)/VSTEP- float( c.v[n].vel)/VSTEP);                \n \t\t\t\t\t\n                        \n                    #if LANES >1\n                                        \n              \n                    int n_ch =  c.v[n].lane_out!=1?1: LANES<3? 0: (iFrame%2)*2; //other target lane\n                    \n                    //check distance of vehicle changing line in the next cell\n                    float dist2 =(nc.v[n2].vtype==0 || nc.v[n2].lane_out!=n_out ) ? ACC_DIST : (1.+ nc.v[n2].offset-c.v[n].offset +float(nc.v[n2].vel)/VSTEP- float(c.v[n].vel)/VSTEP);                \n                      \n                    // distance on alternate lane\n                    float dist_ch =(nc.v[n_ch].vtype==0) ? ACC_DIST : (1.+ nc.v[n_ch].offset-c.v[n].offset +float(nc.v[n_ch].vel)/VSTEP- float(c.v[n].vel)/VSTEP);                \n    \n                    dist=min(dist,dist2);\n                    dist_ch=min(dist_ch,dist2);\n                    \n                    #endif\n\t\t\t\t\t#if LANES>2\n                    if(n==1){               \n                        float dist3 =(nc.v[n3].vtype==0 || nc.v[n3].lane_out!=n_out ) ? ACC_DIST : (1.+ nc.v[n3].offset-c.v[n].offset +float(nc.v[n3].vel)/VSTEP- float(c.v[n].vel)/VSTEP);                \n                        dist=min(dist,dist2);\n                        dist_ch=min(dist_ch,dist2);\n                    }\n                    #endif\n                    \n                    vec2 nx1 =next(nc.pos ,b,false);\n                                      \n                    \n                    //precedence of from other cells\n                    for(int i =0;i<4;i++){\n\n                       cell nc2 =nextCell(nc,i,b.btype);\n                        \n                        //check vehicle on cells with precedence\n                        if(nc2.road && nc2.v[n].vtype>0 \n                           && abs( nc2.v[n].dir_out -i)==2 \n                           && c.v[n].dir_out!=nc2.v[n].dir_out\n                           && int(nx1.x) == nc2.v[n].dir_out\n                          \n                          ) dist=-1.; //  brake if an incoming car (same lane)has precedence over next cell/lane\n\n                        #if LANES >1     \n                        if(nc2.road && nc2.v[n2].vtype>0 \n                           && abs( nc2.v[n2].dir_out -i)==2 \n                           && c.v[n].dir_out!=nc2.v[n2].dir_out\n                           && int(nx1.x) == nc2.v[n2].dir_out\n                           //&& nc2.v[n2].lane_out==n // c.v[n].lane_out\n                           \n                          ) dist=-1.; // brake if an incoming car  (other lane) has precedence over next cell/lane\n                        \n                        //collision with other lane (only in semaphere and roundabout)\n                        if(c.v[n2].vtype>0  &&(b.btype==1 && b.btype==2) && n==1 && c.v[n2].dir_out== ((c.v[n].dir_out+1)%4) ) dist=-1.;\n                        #endif\n                    \t\n                         #if LANES >2    \n                        if(n==1 && nc2.road && nc2.v[n3].vtype>0 \n                           && abs( nc2.v[n3].dir_out -i)==2 \n                           && c.v[n].dir_out!=nc2.v[n3].dir_out\n                           && int(nx1.x) == nc2.v[n3].dir_out\n                           //&& nc2.v[n2].lane_out==n // c.v[n].lane_out\n                           \n                          ) dist=-1.; // brake if an incoming car  (other lane) has precedence over next cell/lane\n                        \n                        \n                        \n                        //collision with other lane (only in semaphere and roundabout)\n                        if(c.v[n3].vtype>0  &&(b.btype==1 && b.btype==2) && n==1 && c.v[n3].dir_out== ((c.v[n].dir_out+1)%4) ) dist=-1.;\n                        #endif\n \n                    }\n                    \n                    \n                    #if LANES >1 \n                    #ifdef LANE_CHANGE\n                    \n                    \n                    if( \n                        c.v[n].offset <=-.3 \n                       && ((dist<=DEC_DIST &&  dist_ch>=ACC_DIST) // passing suggested\n                        \n                       )\n                       //&& c.v[n].vtype==1\n                        && (nc.v[n_out].vtype==0 || nc.v[n_out].lane_out==n_out) //previous vehicle not changing\n                      ){\n                        \n                        float dist_inc=ACC_DIST;\n                        for(int i =min(iFrame,0);i<4;i++){\n\n                        \tcell pc = nextCell(c,i,b.btype);\n                            //incoming vehicle distance, watch the mirror!\n                        \tif(pc.v[n2].vtype>0 && abs(nc.v[n2].dir_out -i)==2 )\n                    \t\t\t dist_inc = min (dist_inc, 1.- nc.v[n2].offset+c.v[n].offset -float(nc.v[n2].vel)/VSTEP+ float(c.v[n].vel)/VSTEP);                \n\t\t\t\t\t\t\t#if LANES >2\n                            \n                            if(n==1){\n                                if(pc.v[n3].vtype>0 && abs(nc.v[n3].dir_out -i)==2 )\n                                dist_inc = min (dist_inc, 1.- nc.v[n3].offset+c.v[n].offset -float(nc.v[n3].vel)/VSTEP+ float(c.v[n].vel)/VSTEP);                \n                            }\n                            #endif\n                         }\n                        \n                        //other line is free begin pass\n                        if(c.v[n_ch].vtype==0 && c.v[n].lane_out==n && dist_inc>=ACC_DIST){\n                        \tc.v[n].lane_out=n_ch;\n                            dist=dist_ch;\n                        }\n                        //change idea, remain on this lane\n                        else {\n                        \tc.v[n].lane_out=n;\n                            dist=dist_ch;\n                        }                   \n                       \n                    \n                    } \n                    \n                    //ROUNDABOUT SINGLE LANE\n                    if(b.btype==1 && c.v[n].lane_out!=1 && n!=1 &&c.v[n].offset<-.3) {\n                        float dist1= 1.+ nc.v[1].offset-c.v[n].offset +float(nc.v[1].vel)/VSTEP- float(c.v[n].vel)/VSTEP;\n                        if(c.v[1].vtype==0  || dist1<DEC_DIST ) dist=-1.; \n                        if(c.v[1].vtype==0 ) c.v[n].lane_out=1;\n                    }\n                    #endif\n                    #endif\n                   \n                    \n\t\t\t\t\t\n                     if(dist < DEC_DIST || stop(b,c) ) {\n                         \n                        if(c.v[n].vel >0) c.v[n].vel-=1  ;\n                        c.v[n].brake=true;\n                    } \n                    \n                    \n                    else if(dist >=ACC_DIST){\n                        int vmax= VMAX[c.v[n].vtype-1];\n                        if(LANES>1 &&n==0) vmax+= 1;\n                        if(LANES>2 &&n<2) vmax+= 1;\n                        if(c.v[n].vel< vmax)  c.v[n].vel+=1 ;\n                    }\n\n                    //update offset                          \t                \n                    c.v[n].offset += float(c.v[n].vel)/VSTEP;\n\n                    \n                     \n\n                    //vehicle leaving cell\n                    //if(c.v[n].offset>OFF_MAX &&\n                    if(c.v[n].leaving ) {\n                        \n                        c.v[n] = newVehicle( 0, 0,0. ,vec2(0.),0,0,n);\n\n                    }\n                    //pre-leaving cell\n                    else if(c.v[n].vtype>0 \n                        && c.v[n].offset+float(c.v[n].vel)/VSTEP>=OFF_MAX \n                        ) c.v[n].leaving=true;\n\n\n                }\n\n \t            //else if(c.v[n].vtype==0 ){ \n                    //incoming vehicles   \n                for(int i =min(iFrame,0);i<4;i++){\n\n                        cell nc = nextCell(c,i,b.btype);\n                        bool incoming=false;\n                            #if LANES >1\n                                int nlane_out=nc.v[n].lane_out;\n                            #else\n                                int nlane_out=n;\n                            #endif\n                        if(nc.v[n].vtype>0 && nlane_out==n && nc.v[n].leaving && abs(nc.v[n].dir_out -i)==2 ){\n\t\t\t\t\t\t\tif(c.v[n].vtype==0){\n                                c.v[n].vtype=nc.v[n].vtype;\n                                c.v[n].offset=clamp(nc.v[n].offset+float(nc.v[n].vel)/VSTEP -1.,-.5,.5);\n                                c.v[n].vel=nc.v[n].vel;\n                                c.v[n].dir_in= i;\n                            \tc.v[n].damaged=nc.v[n].damaged;                         \n                            \tc.v[n].lane_out=n;\n                            \n                            \tincoming=true;\n                             }\n                            \tvcount++;\n                         }\n#ifdef LANE_CHANGE \n                        #if LANES >1                     \n                        // incoming vehicle with line change\n                        if(!incoming && nc.v[n2].vtype>0 && nc.v[n2].lane_out==n && nc.v[n2].offset + float(nc.v[n2].vel)/VSTEP>=OFF_MAX && abs(nc.v[n2].dir_out -i)==2 ){\n                                if(c.v[n].vtype==0){\n                                    c.v[n].vtype=nc.v[n2].vtype;\n                                    c.v[n].offset=clamp(nc.v[n2].offset+float(nc.v[n2].vel)/VSTEP -1.,-.5,.5);\n                                    c.v[n].vel=nc.v[n2].vel;\n                                    c.v[n].dir_in= i;\n                                    c.v[n].lane_out=n;\n                                    c.v[n].damaged=nc.v[n2].damaged;\n                                    incoming=true;\n                                }\n                            \tvcount++;\n                         }\n\t\t\t\t\t\t#endif\n                        #if LANES >2                     \n                        // incoming vehicle with line change in central line\n                        if(!incoming && nc.v[n3].vtype>0 && nc.v[n3].lane_out==n && nc.v[n3].offset + float(nc.v[n3].vel)/VSTEP>=OFF_MAX && abs(nc.v[n3].dir_out -i)==2 ){\n                                if(c.v[n].vtype==0){\n                                    c.v[n].vtype=nc.v[n3].vtype;\n                                    c.v[n].offset=clamp(nc.v[n3].offset+float(nc.v[n3].vel)/VSTEP -1.,-.5,.5);\n                                    c.v[n].vel=nc.v[n3].vel;\n                                    c.v[n].dir_in= i;\n                                    c.v[n].lane_out=n;\n                                    c.v[n].damaged=nc.v[n3].damaged;\n                                    incoming=true;\n                                }\n                            \tvcount++;\n                         }\n\t\t\t\t\t\t#endif\n#endif\n                                \n                        if(incoming==true ){\n                                //next direction                          \n                                vec2 nx =next(c.pos,b,false);\n\n                                //default direction\n                                if(nx.y>0.) {c.v[n].dir_out=int(nx.x); }\n\n                                //turn direction (if allowed)\n                                vec2 nx2 =next(c.pos,b,true);\n                                //connected... turn only if direction to destination\n                                if(nx2.y>0. && b.dist<MAX_DIST  &&nc.v[n].vtype== 1){\n                                   if( int(nx2.x)==b.dir ) {c.v[n].dir_out=int(nx2.x); nx=nx2;}\n                                }\n                                //else turn randomly \n                                else if(nx2.y>0. && hash(iTime +U)> TURN ) {c.v[n].dir_out=int(nx2.x); nx=nx2;}\n              \n                         }\n                    //}\n                   \n    \n            \t}\n             \n                if(vcount>1) c.v[n].damaged=true;\n        \t}\n            //packing\n            \n            Q= encodeCell(c);\n        }\n   \n    } \n    \n    //GLOBAL VARIABLES\n    else {\n      \n        int sh = int(mod(U.x -.5,BLOCK_BUFFER.x));\n        Q=vec4(0.); //r=?,g=?, b=unconnected,a=?\n                \n\n         if(sh==1){\n            vec3 coord = buffer2coord(U+vec2(-1.,1.));\n\n            //subtotal over columns\n            for(float k=  -1.;k<BMAX.y;k++){\n                vec3 nbCoord=vec3(coord.xy +DIRS[0]*k, coord.z);\n                block nb = decodeBlock(BLOCK(coord2buffer(nbCoord)),nbCoord.xy);\n\n                Q.g += nb.counter;\n\t\t\t\tif(nb.th>=1 && ( nb.btype>0  || (nb.ltype==2 && nb.btype==0))) Q.r+=1.;\n                if(nb.th>=1 && nb.conns==0 && nb.ltype==2 && nb.btype==0) Q.b +=1.;\n                if(nb.th>=1 && nb.btype>0 && nb.dist>=MAX_DIST) Q.b +=1.;\n            }\n\n            //total over rows\n            if(U.x <6.)for(float k=1.;k<BMAX.x+1. ;k++){\n                Q +=CONF(U + vec2(BLOCK_BUFFER.x,0)*k );\n            }\n        } \n        else if( U.x <6. && sh==2){\n            \n            //SELECTED ACTION:       \n            if(sdBox(iMouse.xy/R*20. -vec2(10.*ZX,.6 ),vec2(10.*ZX -.2 ,.4 ))<0.)             \n            Q.x= floor(iMouse.x/R.x/(ZX-.1)*4.5 +.8*(ZX/.7));\n            else Q.x=max(CONF(vec2(2.,0.)).x,1.);\n       \n\n            Q.w= clamp(RESET<5. || iMouse.x <1.? .4:  (iMouse.x>R.x*ZX ||DEMO || WIN)? iMouse.y/R.y:CONF(vec2(2.,0.)).w,.2,10.);\n        }\n        else if( U.x <6. && sh==3){\n            \n            \n            //SMOOTH CAMERA POSITION\n            //xy=position, z=rotation w= zoom \n                       \n            float mx =  RESET<5.  ?1.: clamp(1./iFrameRate,0.,1.); //(iFrameRate>10.?.07:.15) ;                  \n            Q.xy=mix(CONF(vec2(3.,0.)), CONF(vec2(0.,0.)),mx).xy;\n               \n            float rz1=CONF(vec2(3.,0.)).z, rz2= CONF(vec2(2.,0.)).z;         \n            if(rz2<rz1  && rz1-rz2>3.14) {rz2=rz1+.5; }\n            \n            if (iMouse.x<1. ||RESET<5.) Q.z= iTime/4.;\n            else if( iMouse.x>R.x*ZX && !DEMO && !WIN) Q.z=  rz1+ .1* (.5+ ZX*.5 - iMouse.x/R.x);                \n            else if(DEMO || WIN) Q.z= rz1+ (iMouse.x<=0.?0.: .1*(.5 - iMouse.x/R.x));\n            else Q.z=3.6;\n                        \n            Q.w=  mix(CONF(vec2(3.,0.)), CONF(vec2(2.,0.)),mx).w;\n        }\n    }\n    \n    // TEXTURE SIZE & LAST RESET \n    if(max(U.x,U.y)<1.) {\n        Q= vec4(\n            iMouse.x<1. || RESET<5.? R/8.: iMouse.x>R.x*ZX|| DEMO || iMouse.y<R.y/20. ? CONF(U).xy: (iMouse.xy-SHIFT_VIEW)/RR,\n            TS.x, \n            iFrame==0 || TS.x != CONF(vec2(0.)).z || ( keyDown(CH_SPACE) ) ? float(iFrame):CONF(vec2(0.)).w);\n       // if( iMouse.x>R.x*ZX || iMouse.x<0. || DEMO  || WIN){\n            float rz =  CONF(vec2(3.,0.)).z;\n            Q.xy = clamp(Q.xy +rot(rz) *vec2(1.,0.)*ZOOM*(-(keyDown(CH_D)?1.:0.) +(keyDown(CH_A)?1.:0.)) ,vec2(0.),vec2(ZOOM*6.*BMAX/RR));\n            Q.xy = clamp(Q.xy +rot(rz)*vec2(0.,1.)*ZOOM*(-(keyDown(CH_W)?1.:0.) +(keyDown(CH_S)?1.:0.)),vec2(0.),vec2(ZOOM*6.*BMAX/RR)) ;\n       // }\n    } \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//SETTINGS\n#define QUALITY 2 //0=LOW,1=MEDIUM, 2=HIGH\n#define MIN_ZOOM 1. //minimum zoom (for small resolutions)\n#define RR (iResolution.x>800.?2.:1.)// resolution reduction factor\n#define CITY_SIZE 90. //20 small 40 medium 100 big\n#define LANES 2 //1 = sigle lane, 2 = double lane (takes up to 40s compilation time) 3= triple lanes\n#define LANE_CHANGE //if defined, car lane change is allowed (not working well with 3 lanes)\n#define VEHICLE_DENSITY 0.3//0.=no traffic 1.= full\n#define ZOOM2H 10. // horizontal zoom for right panel\n#define ZOOM2V (6. *ZOOM/6.) // vertical zoom for right panel\n#define HEIGHT 40 //max building height\n#define THEIGHT 90 // max terrain height (-5 water level)\n#define VMAX int[2] (5,3) // max speed by vehicle type\n#define VCOLOR vec3[2] (vec3(1.,1.,0.) ,vec3(.0,.2,1.)) // color by vehicle type\n#define ACC_DIST 1.8 // higher value: less reactive cars\n#define DEC_DIST 1.7 //lower values causes vehicle crashes and disappereance\n#define TURN 0. //0.= always (no congestions) , 1.= never (high congestions)\n#define HEIGHT_MARGIN 25.\n#define HELP\n\n\n//DEBUG\n#define DEBUG 0 // set to 1 to display debug colors\n#if DEBUG>0\n    #define ALERT_COLOR vec3(0.,1.,1.)\n    #define DEBUG_COLOR vec3(.3,0.,0.)\n    #define DEBUG_COLOR2 vec3(.5,0.,0.)\n#endif\n\n\n//INTERNAL\n#define CH_Z 90  \n#define CH_SPACE 32\n#define CH_SH 16\n#define CH_CAPS 20\n#define CH_CTRL 17\n#define CH_A 65 \n#define CH_D 68\n#define CH_W 87 \n#define CH_S 83 \n//#define CH_ALT 18\n#define keyDown(k) (texelFetch(iChannel1, ivec2(k,0), 0).r>.5)\n#define keyPress(k) (texelFetch(iChannel1, ivec2(k,1), 0).r>.5)\n#define keyToggle(k) (texelFetch(iChannel1, ivec2(k,2), 0).r>.5)\n#define DEMO  !keyToggle(CH_CAPS) // !keyToggle(CH_SPACE)\n#define CITY_SIZE2  CITY_SIZE //(DEMO?15.:CITY_SIZE)\n#define VP 3.\n#define VSTEP 1./32. \n#define OFF_MAX -.5 +(31./32.)\n#define BLOCK_BUFFER vec2(6.,6.)\n#define MAX_DIST min((1<<10)-2,int(CITY_SIZE*3.))\n#define SHIFT_VIEW vec2(3.,R.y/20. )\n\n#define ZOOM max(MIN_ZOOM, (R.y)/6./(CITY_SIZE2) ) //zoom factor for left panel\n#define ZX .5 // split screen ratio from 0 to 1 (.3= big preview, .7=small preview )\n#define BMAX floor(iResolution.xy/BLOCK_BUFFER/ZOOM*vec2(ZX,1.) -2.)\n#define zoomMode  (!DEMO && !keyToggle(CH_Z) &&  U.x > R.x*(!WIN?ZX:0.))\n#define UNCONNECTED (GAME &&  b.dist>=MAX_DIST)\n#define GAME keyToggle(CH_CAPS) //false to disable connection counters \n\n#define MOUSE_INPUT   iMouse.xy/RR // ((!keyToggle(CH_CAPS)? iMouse.xy:iMouse.zw )/2.)\n#define RZ (iResolution/RR)\n#define Main void mainImage(out vec4 Q, vec2 U) \n#define CELL(U) texelFetch(iChannel0, ivec2(mod(U,R) ), 0) //texture(iChannel0,(U)/R)\n#define BLOCK(U) texelFetch(iChannel0, ivec2(mod(U,R) ), 0) //texture(iChannel0,(U)/R)\n#define CONF(U) texelFetch(iChannel0, ivec2(mod(U,R) ), 0) //texture(iChannel0,(U)/R)\n#define WIN (CONF(vec2(1.,0.)).b<1. && CONF(vec2(1.,0.)).g<1. && GAME)\n#define TS vec2(textureSize(iChannel0,0))\n#define RESET abs(float(iFrame)-max(CONF(vec2(0.)).w,0.)) \n\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits    \nconst vec2 DIRS[4] = vec2[] (vec2(0,1), vec2(1,0),vec2(0,-1) ,vec2(-1,0));  \nconst float PI = 3.14159265359;\n\n//iq\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n//Hash/noise utils (copied from others)\nfloat hash(in float x) { return fract(sin(x*.0007)*29835.24389); }\nfloat hash(in vec2 x) { return hash(dot(x,vec2(23.17,17.23))); }\nvec2 hash22( vec2 p ) { float t = hash(p);\treturn vec2( t,hash(t)); }\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\nfloat fbm_noise(vec2 uv, int steps) {\n\tfloat v = 0.;\n    for(int i = 0; i < steps; i++){\n        float factor = pow(2.,float(i + 1)) / 2.;\n    \tv += snoise(uv * factor) / factor;\n    }\n    return v / ((pow(.5,float(steps))- 1.) / -.5);\n}\n \n// MODEL COMMON FUNCTIONS\n     \n//CELL-VEHICLE\nstruct vehicle {\n\n    //V1\n    int vtype; //2 bit 0=none 1=car,2=slowcar \n    int dir_in; // 0..3 DIRS[i]\n    int dir_out;   // 0..3 DIRS[i]     \n\tfloat offset; // -.5 ... +.5\n\tint vel; // 0..7\t\n    bool brake; \n    int lane; //lane\n    int lane_out;\n    bool leaving;\n    bool damaged;\n\n};\n \nvehicle newVehicle( int vtype,int vel, float off, vec2 tg , int di, int dout,int lane){\n    vehicle o;\n\n    o.vtype=vtype; \n    o.dir_in= di ;\n    o.dir_out=dout;\n\to.offset= off; \n\to.vel=vel; \n    o.brake=false;\n    o.lane=lane;\n    o.lane_out=lane;\n    o.leaving=false;\n    o.damaged=false;\n    return o;\n}\n\n\nstruct cell {\n    vec2 block_pos; // block xy  (not persistent)\n    int pos; //  (not persistent)\n    bool road;\n    bool shift;\n    \n\tvehicle[LANES] v;  //vehicles (max 2)\n    \n    \n};\n \ncell newCell(vec3 coord, bool road,bool shift){\n//cell newCell(vec3 coord, bool road, int vtype,float vel, float off, vec2 tg , int di, int dout){\n    cell o;\n    o.block_pos=coord.xy;   \n    o.pos=int(coord.z); \n    o.road=road;\n    o.shift=shift;\n    for(int n=0;n<LANES;n++){\n        o.v[n]=  newVehicle(0, 0,0. ,vec2(0.),0,0,0);\n        o.v[n].lane_out=n;            \n        o.v[n].lane=n;\n        //o.v[n].leaving=false;\n    }\n\n\n    return o;\n}\n\ncell decodeCell(vec4 t,vec3 coord) {\n\tcell o;\n    o.pos=int(coord.z);\n    o.block_pos= coord.xy;\n    \n    //VEHICLES\n    for(int n=0;n<LANES;n++){\n\t\tfloat f = (n==0? t.r:(n==1 ? t.g:t.b));\n        o.v[n].offset= gb(f,0., 5.) /pow(2.,5.)  -.512; \n        o.v[n].vel= int(gb(f,5., 3.)) ;       \n        o.v[n].lane_out=int(gb(f,8., 2.));\n        o.v[n].vtype= int(gb(f,10., 2.));  \n        o.v[n].dir_in = int(gb(f,12., 2.));\n        o.v[n].dir_out = int(gb(f,14., 2.));\n        o.v[n].lane=n;\n    }\n    \n\t//CELL\n    o.road=gb(t.a,0., 1.)<.5;\n    o.shift =gb(t.a,1., 1.)<.5;\n    \n    for(int n=0;n<LANES;n++) {\n        o.v[n].brake=gb(t.a ,2.+float(n), 1.)<.5;\n        o.v[n].leaving=gb(t.a ,5.+float(n), 1.)<.5;\n        o.v[n].damaged=gb(t.a ,8.+float(n), 1.)<.5;\n    }\n    return o;\n}\n\n\nvec4 encodeCell(cell o) {\n\tvec4 t=vec4(0.);\n  \n    //VEHICLES\n    for(int n=0;n<LANES;n++){\n        float f=0.;\n        sb(f,0.,5.,(o.v[n].offset +.512)* pow(2.,5.));\n        sb(f,5.,3., float(o.v[n].vel));    \n        sb(f,8.,2.,float(o.v[n].lane_out));\n        sb(f,10.,2.,float(o.v[n].vtype));\n        sb(f,12.,2.,float(o.v[n].dir_in));\n        sb(f,14.,2.,float(o.v[n].dir_out));       \n        if(n==0) t.r=f; else if(n==1) t.g=f; else t.b=f;\n    }\n\n    \n    //CELL\n    sb(t.a,0.,1.,o.road?0.:1.);\n    sb(t.a,1.,1.,o.shift?0.:1.);\n    \n    for(int n=0;n<LANES;n++) {\n        sb(t.a,2.+float(n),1.,o.v[n].brake?0.:1.);\n        sb(t.a,5.+float(n),1.,o.v[n].leaving?0.:1.);\n        sb(t.a,8.+float(n),1.,o.v[n].damaged?0.:1.);\n    }  \n    return t;\n}\n\n//BLOCK (or Tile)\nstruct block {\n    vec2 block_pos;\n    int btype; //3 bit 0=none 1=roundabout 2=semaphore 4=street 5 =overpass \n    int ltype; //0=none  2=building 3=center\n    int bh; //building height\n    int th; //terrain height\n    int conns; // current connections (bitmask)\n    float counter;\n    int dist; //distant from center\n    int dir; //dir to center\n    int aconns;// allowed connections (bitmask)\n    \n    int semaphore; //0:YELLOW 2:VERTICAL 1:HORIZONTAL\n       \n};\n\nblock newBlock(vec3 coord, int btype,int ltype, int bh, int th ){\n\tblock o;\n    o.block_pos= coord.xy;\n    o.btype=btype; \n    o.ltype=ltype;\n    o.th=th;\n    o.bh=bh;\n    o.conns=15;\n  \to.counter=0.;\n    o.dist=MAX_DIST;\n    o.dir=0;\n    o.semaphore=0;\n    o.aconns=15;\n    return o;               \n}              \n                 \nblock decodeBlock(vec4 t,vec2 coord) {\n\tblock o;\n    o.block_pos= coord;\n    o.btype=int(gb(t.r,0., 3.));\n    o.ltype = int(gb(t.r,3., 3.)); \n    o.conns = int(gb(t.r,6., 4.));\n    o.semaphore = int(gb(t.r,10., 2.));\n    o.aconns =int(gb(t.r,12., 4.));\n    \n    o.bh = int(gb(t.g,0., 8.));\n    o.th = int(gb(t.g,8., 8.));\n    o.counter=t.b;\n    o.dist= int(gb(t.a,0., 10.));\n    o.dir= int(gb(t.a,10., 2.));\n    return o;\n}\n\nvec4 encodeBlock(block o) {\n\tvec4 t=vec4(0.);\n    \n    sb(t.r,0.,3.,float(o.btype));\n    sb(t.r,3.,3.,float(o.ltype));\n    sb(t.r,6.,4.,float(o.conns));\n    sb(t.r,10.,2.,float(o.semaphore));\n    sb(t.r,12.,4.,float(o.aconns));\n    sb(t.g,0.,8.,float(o.bh));\n    sb(t.g,8.,8.,float(o.th));\n    \n    t.b=o.counter;\n    sb(t.a,0.,10.,float(o.dist));\n    sb(t.a,10.,2.,float(o.dir));\n    return t;\n}\n\n//MAPPING FUNCTIONS\nbool isBlockCoord(vec3 coord) {\n    return (int(coord.z)== 0);\n}\n    \nvec3 buffer2coord(vec2 b) {  \n    return vec3(\n        floor(b.x/BLOCK_BUFFER.x),\n        floor((b.y-1.)/BLOCK_BUFFER.y),\n        floor(mod(b.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod((b.y-1.), BLOCK_BUFFER.y))\n     );\n\n}\n\nvec2 buffer2point(vec2 b){\n\treturn vec2(\n    \t\tmod(b.x, BLOCK_BUFFER.x),\n        \tmod((b.y-1.), BLOCK_BUFFER.y)\n    );\n}\n    \nvec2 coord2buffer(vec3 c){\n\treturn vec2(\n        floor(c.x) * BLOCK_BUFFER.x  + floor(c.z/BLOCK_BUFFER.x),\n        floor(c.y) * BLOCK_BUFFER.y  + floor(mod(c.z,BLOCK_BUFFER.x)) +1.\n    );\n}\n\n//This function returnns  the coordinates  of neightbor cell.\n// A special case is  the overpass, where the vehicles in the 4 cells\n// of the lower level of the center are  remapped this way on unused cells:\n// 15--> 11, 14-->7, 20-->25, 21-->28\nvec3 nextCoord(cell c, int d, int btype){\n    \n    vec2 dir=DIRS[d];\n    if(btype==5){\n       \tint npos=-1;\n        if(d==0) switch (c.pos){\n\t\t\tcase 19: npos=25;break;\n            case 25: npos=28;break;\n            case 28: npos=22;break;\n            case 10: npos=16;break;\n            case 7: npos=10;break;\n            case 13: npos=7;break;\n            default: break;\n\n        }else if(d==2) switch (c.pos){\n        \tcase 25: npos=19;break;\n            case 28: npos=25;break;\n            case 22: npos=28;break;\n            case 16: npos=10;break;\n            case 10: npos=7;break;\n            case 7: npos=13;break;\n            default: break;\n        }\n        \n        if((d%2)==0 &&\n            (c.pos==9 || c.pos==14 ||c.pos==15 ||c.pos==20 ||c.pos==21 ||c.pos==26 )    \n                ) npos=5;\n\n        if(npos!=-1) return vec3(c.block_pos,float(npos));\n    }\n\treturn buffer2coord(coord2buffer(vec3(c.block_pos,c.pos)) +dir);\n}\n\n// returns true if current point is within a road; used both for logic and rendering\nbool isRoad_(in block b, vec2 point){\n            \n    float fCross= (b.btype==1)?1.:0.;\n    \n    bool road=true;\n\n    if( b.btype==0 )  road=false;\n    else if(b.btype==1 &&  (abs(point.x-3.) +abs(point.y-3.) >3.  || abs(point.x-3.) +abs(point.y-3.) <2. )) road=false;    \n        \n    else if((b.conns&1)==0 &&  abs(point.y-1. ) >3. +fCross  )  road=false;\n    else if((b.conns&2)==0 &&  abs(point.x-1. ) >3. +fCross )  road=false;\n    else if((b.conns&4)==0 &&  abs(point.y-5. ) >3. +fCross  )  road=false;\n    else if((b.conns&8)==0 &&  abs(point.x-5. ) >3. + fCross )  road=false;\n    else if(( b.btype==4 || b.btype==2 || b.btype==5  )&&  (min(abs(point.x-3.),abs(point.y-3.)) >1.)    ) road=false;\n        \n\treturn road;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//RENDERING SHADER\n\n#define R (iResolution.xy/RR)\n\n#define GCOL(th) (th +float(THEIGHT)*.3 )/float(THEIGHT)/1.3*(.8+.2*hash(P0*4.))\n\n\n\n// vehicle position in a block type based on its offset, lanes and directions\nvec2 rpos(int ni,int no, float off, int di, int dout){\n    #if LANES>1\n    float ki= -.5+ 1.* float(ni)/float(LANES-1),  ko= -.5+ 1.*float(no)/float(LANES-1);\n    #else  \n    float ki=0.,ko=0.;\n    #endif\n    vec2 pOut=DIRS[dout]+ ko*DIRS[(dout+1)%4];\n    vec2 pIn=DIRS[di]+ki*DIRS[(di+3)%4];\n\n   \t/*circle path ... not working\n    if((di+1)%4==dout) return vec2(.5) \n        + pIn* sin((off+.5)*1.57)*.25\n        + pOut*cos((off+.5)*1.57)*.25;\n    if((di+3)%4==dout) return vec2(.5) \n        + pIn* cos((off+.5)*1.57)*.25\n        + pOut*sin((off+.5)*1.57)*.25;*/\n    return mix(\n        //45 path\n        .5 + mix(pIn, pOut,.5+off)*.5,\n         \n        //90 path\n        (off<0.? .5- pIn*off: .5+ pOut*off), LANES==1?.5:0.);\n}\n\n//distance of point from vehicle\nfloat vdist(vec2 p, vehicle nv,bool top){\n    \n    #if LANES >1\n    \tint lane_out=nv.lane_out;\n    #else\n        int lane_out=nv.lane;\n    #endif\n    float vSize=LANES>2?  .15:LANES >1? .15: .20 ;  //width= vSize*2, length=vSize*1.5 \n    \n    vec2 dir = normalize(rpos(nv.lane,lane_out, nv.offset+.5,nv.dir_in,nv.dir_out)-rpos(nv.lane,lane_out,nv.offset-.5,nv.dir_in,nv.dir_out));\n    vec2 pos=p-rpos(nv.lane,lane_out,nv.offset,nv.dir_in,nv.dir_out);\n    pos= vec2(pos.x* dir.x + pos.y*dir.y , pos.y*dir.x-pos.x*dir.y);\n    return sdBox(pos,vec2(top? vSize: vSize*1.5 ,vSize));\n}\n\n// current pixel position on the map at height j\nvec2 position(vec2 U, float j){\n    //smooth position change \n    float \n        rz= CONF(vec2(3.,0.)).z+3.14\n        ,zz= .2 + CONF(vec2(3.,0.)).w*8. *.2\n        ,zh= 3.5 - CONF(vec2(3.,0.)).w*2.5;\n\n    \n    vec2 M = CONF(vec2(3.,0.)).xy/ZOOM;  \n\n    float h=  ZOOM2V* float(j)* zz ;\n\n    if(zoomMode|| WIN || DEMO)\n        return  (rot(rz )* ((U  - vec2(0.,-R.y/5.+h)) *vec2(1.,zh)-vec2(R.x*(.5+ (DEMO||WIN?0.: ZX*.5)),R.y*zh/2.)) /ZOOM/ZOOM2H /zz  +M ); \n    else\n        return  (rot(rz-.25)* ((U - vec2(0.,-R.y/5.+h)) -vec2(R.x*(.5+ (DEMO||WIN?0.: ZX*.5)),R.y*.5)) /ZOOM/ZOOM2H /zz  +M ); \n\n}\n\n// returns the vertical map for a position at height j inside current block\n// Q.w --> upper height of the closest object below j\n// Q.rgb --> colors of closest object below j, or 2D map color if j==0\nvec4 map(in vec2 P, in float j, in block b,bool zoomView){\n\n    vec4 Q=vec4(0.);\n\n    vec2 P0 = floor(P)+.5; //position center\n    vec4 data=CELL(P0);\n    vec3 coord= buffer2coord(P0);\n    vec3 bcoord= vec3( coord.xy,0.);\n\n    cell c = decodeCell(data,coord); //CURRENT VEHICLE        \n    vec2 point = buffer2point(P); //RELATIVE COORDS\n    bool outside = bcoord.x <0. || bcoord.y<0. || bcoord.x>=floor(BMAX.x/RR-1.)|| bcoord.y>= floor(BMAX.y/RR-1.); //true if outside buffer A\n\n    //TERRAIN HEIGHT AND SLOPE\n\n\tvec2 pointH=point;\n    #if QUALITY>1\n    //ROAD  HEIGHT\n    \n    if((b.btype==4 || b.btype==2 || b.btype==5) && isRoad_(b,point)){ \n        if(b.conns==10) pointH.x=point.x;\n        else if(abs(point.x-3.)<1.) pointH.x=3.;\n        else if(point.x>4.) pointH.x=6.- (6.-point.x)*1.5;\n        else pointH.x=point.x*1.5;\n\n        if(b.conns==5) pointH.y=point.y;\n        else if(abs(point.y-3.)<1.) pointH.y=3.;\n        else if(point.y>4.) pointH.y=6.- (6.-point.y)*1.5;\n        else pointH.y=point.y*1.5;\n\n    }\n    #endif  \n    //BUSH HEIGHT\n    bool bushPoint=((b.btype==0 && b.ltype==0) ||(b.btype>0 && abs(point.x-3.)> 1.5 &&  abs(point.y-3.)> 1.5 )) && hash(P0*3.)>.8 && !isRoad_(b,point) ;\n    if(bushPoint ) pointH=floor(point)+.5;\n\n      \n    //TERRAIN HEIGHT INTERPOLATION\n    float th = +float(b.th);\n    if(int(mod(bcoord.x,2.))==1 && int(mod(bcoord.y,2.))==0) {\n        vec3 bcoord1 = vec3(coord.xy + DIRS[0],0.);\n        float th1= float(decodeBlock(BLOCK(coord2buffer(bcoord1)),bcoord1.xy).th);\n        vec3 bcoord2 = vec3(coord.xy + DIRS[2],0.);\n        float th2= float(decodeBlock(BLOCK(coord2buffer(bcoord2)),bcoord2.xy).th);\n        th=(th1*pointH.y +th2*(6.-pointH.y))/6.;\n    }\n    else if(int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==1){\n        vec3 bcoord1 = vec3(coord.xy + DIRS[1],0.);\n        float th1= float(decodeBlock(BLOCK(coord2buffer(bcoord1)),bcoord1.xy).th);\n        vec3 bcoord2 = vec3(coord.xy + DIRS[3],0.);\n        float th2= float(decodeBlock(BLOCK(coord2buffer(bcoord2)),bcoord2.xy).th);\n        th=(th1*pointH.x +th2*(6.-pointH.x))/6.;\n    }\n    else if( int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==0){\n        vec3 bcoord1 = vec3(coord.xy + DIRS[0]+ DIRS[1],0.);\n        float th1= float(decodeBlock(BLOCK(coord2buffer(bcoord1)),bcoord1.xy).th);\n        vec3 bcoord2 = vec3(coord.xy + DIRS[2]+ DIRS[1],0.);\n        float th2= float(decodeBlock(BLOCK(coord2buffer(bcoord2)),bcoord2.xy).th);\n        vec3 bcoord3 = vec3(coord.xy + DIRS[2]+ DIRS[3],0.);\n        float th3= float(decodeBlock(BLOCK(coord2buffer(bcoord3)),bcoord3.xy).th);\n        vec3 bcoord4 = vec3(coord.xy + DIRS[0]+ DIRS[3],0.);\n        float th4= float(decodeBlock(BLOCK(coord2buffer(bcoord4)),bcoord4.xy).th);\n\n        th=(th1*pointH.y*pointH.x \n            +th2*(6.-pointH.y)*( pointH.x)  \n            + th3*(6.-pointH.y)*(6.- pointH.x) \n            +th4*pointH.y*(6.-pointH.x))/36.;\n\n\n    }\n    if(outside) th=0.;\n\n    #if QUALITY>1\n    //ROAD OVER WATER LEVEL\n    if((c.road || b.btype==1 && sdBox(point-3.,vec2(1.))<0.)  &&  c.pos>0 && !outside) th=max(th,5.);\n    #endif\n    \n\n\n    //OPTIMIZATION #2\n    if( float(j)<=max(th+10.,float(b.bh)) ) {\n\n\t\t//used by stripes \n        float fJun= (b.btype==1)?2.:(b.btype==2 ?1.: 0.);        \n    \t//roundabout center\n    \tbool roadP= c.road || (abs(length(point.xy-3.)-1.5)<.5 && !c.road && b.btype==1) ;\n\n        #if DEBUG>0\n        if( DEBUG>0 && (abs(point.x-3.)>2.8 || abs(point.y-3.)>2.8)) Q=vec4(0.); //DEBUG borders\n        else if (             \n            (b.th>0 && th<1. && b.conns==0 && b.ltype==2 && b.btype==0)|| \n            (b.th>0 && th<1. && b.btype>0 && UNCONNECTED)\n        ) Q=vec4(1.,0.,.0,0.); //DEBUG HIDDEN UNCONNECTEDS\n        else\n        #endif\n            //RENDERING---------------------\n\n\n            //BUILDINGS\n        if(j<=float(b.bh) + th && b.btype==0 && b.ltype>0 && b.th>=1 &&!outside \n               &&  sdBox(point - vec2(3.),vec2(1.7))<1. \n\n              ) {\n\n               float h= float(b.bh) + th;\n               float shadow= abs(point.x-3.)>  abs(point.y-3.)?.5:1.+sign(point.y-3.);\n               //if(zoomMode &&  iMouse.x>R.x/2. && iMouse.y >R.y*.55) h=th+15.;\n               h= (floor(h/10.)*10.);\n\n               float fl=j >= (h) ||  int(j)%5==0  ? .7:.7+float(j-th)/float(HEIGHT)*1.4;\n\n               if(b.ltype==3 &&b.dist<=1) Q= vec4(1.6*fl,1.6*fl,0. ,h  );\n               \n               else Q= vec4(vec3(.7+ hash22(coord.xy).x*.2,.6, .7+hash22(coord.xy).y*.3)*fl*(b.conns==0 && GAME ?.3:1.),h  );\n               Q.xyz*= (.4+shadow*.3);\n               //Q= vec4(.5*fl,.3*fl,.3*fl + hash22(coord.xy).x*.3 ,h); \n\n            }\n\n\n\n        #if QUALITY>1\n        //RONDABOUT SIDEWALKS\n        else if(j<= max(th+1.5,5.)  && b.btype==1 //&&  sdBox(point.xy-3.,vec2(1.))<2. \n                && abs(length(point.xy-3.)-2.5)<.2 \n                && min(abs(point.x-3.),abs(point.y-3.))>1.\n               &&!outside )  Q= vec4(vec3(UNCONNECTED?.2:.6)*(j>0.&& max(th+1.5,5.)-j>1.?.5:1.),max(th+1.5,5.));\n        #endif   \n\t\t\n        //else if(c.shift && c.v[0].vtype>0) Q= vec4(vec3(1.),max(th+1.5,5.)); //DEBUG OVERPASS\n\n        //NOT ROAD\n        else if( j<= th +12.   &&( isBlockCoord(coord) || !roadP  || b.btype==0  || outside  ) ){\n\n                \n                #if QUALITY>0\n            \t//ROUNDABOUT CENTER GRASS\n                bool rag= (j<= th+1.5  && b.btype==1 && sdBox(point.xy-3.,vec2(1.))<0.);                    \n                    \n         \t\tvec2 rp= mod(point+.5,1.)-.5;\n            \n               //SEMAPHORE\n                 if(j<= th+10.  && !outside && b.btype==2 && sdBox(point.xy-3.,vec2((zoomView?1.2 : 1.5)))<0. && min(abs(point.x-3.),abs(point.y-3.) )>1. ) \n                   Q=vec4( abs(j-th-4.)>3. && sign((point.x-3.)*(point.y-3.))!=sign(float(b.semaphore*2-1))?1.:0. ,0.,0.,th +10.);\n\n\n                //ROAD SIDEWALKS\n                else if(j<= max(5.,th+1.5) && !outside && b.btype!=0 && !roadP && !rag && (\n                    (abs(point.x-3.)<1.3   && ((b.conns&1)==1 ||( b.btype==1&& point.y<5.4 )) && point.y>2.)|| \n                    (abs(point.x-3.)<1.3  && ((b.conns&4)==4 ||( b.btype==1 && point.y>.6 ) )&& point.y<4.)|| \n                    (abs(point.y-3.)<1.3   && ((b.conns&2)==2 || ( b.btype==1 && point.x<5.4)) && point.x>2.)||\n                    (abs(point.y-3.)<1.3  && ((b.conns&8)==8 || ( b.btype==1 && point.x>.6) ) && point.x<4.)||\n                    sdBox(point-3.,vec2(1.3))<0. \n\n                )) Q=vec4(vec3(UNCONNECTED?.2:.6)*(j>0.&& max(th+1.5,5.)-j>1.?.2:1.),max(th+1.5,5.));\n                     \n\n                //BUILDING SIDEWALK\n                else if(j<= th+1.5  && b.btype==0 && b.ltype>0 && b.th>=1 &&!outside \n                        &&  sdBox(point -3.,vec2(1.7))<1.3       \n                       ) Q=vec4(vec3(b.conns>0?.6:.2),th+1.5);\n              \n                else  \n                #endif\n                 //WATER\n                 if( th<1. || outside) Q=vec4(  vec3(0.,.7,.9)*GCOL(th)*2. ,0.);\n                            \n                 //BUSH\n                 #if QUALITY>0\n                else if(j<= th+12. && bushPoint  && length(rp)*20.>j-th ){\n                    \n                    float shadow= //abs(atan(-rp.y,rp.x)/3.14-1.57);\n                        abs(rp.x)<  abs(rp.y)?.5:1.+sign(rp.y);\n\n                    Q=vec4(0.,GCOL(th)*(.7-shadow*.3),0.,10.+th);\n                    \n                }\n                #endif\n                //GRASS\n                else if(j<= th+.5 && j>=th || j<1. ) Q=vec4(0.,GCOL(th)*1.2,0. ,th+.5);\n                    \n                //DIRT\n                else Q=vec4(vec3(.6,.4,.4)*GCOL(th),th);\n\n        } \n\n        //ROAD       \n        else if (j<= th +(b.btype==5?15.:10.)  &&  roadP  ) {\n            float thr=th;\n            float thm= -1.;\n            \n            //OVERPASS \n            if(b.btype==5) {\n                if(abs(point.x-3.)<1. && abs(point.y-3.)<1. && j>th ) thr=th+5.;\n                else if(abs(point.x-3.)<1. && abs(point.y-3.)<1. && j<=th) thr=th-5.;\n            \telse if(point.x>4. && abs(point.y-3.)<1.) thr = th +(6.-point.x)*2.5;\n                else if(point.x<2. && abs(point.y-3.)<1.) thr = th + (point.x)*2.5;\n                else if(point.y<2.) thr = th - (point.y)*2.5;\n                else if(point.y>4.) thr = th - (6.-point.y)*2.5;\n                thm=  thr-2.;\n            \n                if(j<=th ){\n                    vec3 ncoord =vec3(c.block_pos,float(c.pos));\n                    if(c.pos==15) ncoord.z=10.;\n                     if(c.pos==14) ncoord.z=7.;\n                     if(c.pos==20) ncoord.z=25.;\n                     if(c.pos==21) ncoord.z=28.;\n                    vec4 ndata = CELL(coord2buffer(ncoord)); \n                    c = decodeCell(ndata,ncoord);\n                    \n                }\n            }\n            //VEHICLE\n            float pd= 10.;\n            int vtype=0;\n            bool brake =false;\n            bool lanechange=false;\n            bool damaged =false;\n            if(j<= thr+5.){\n\n            if(float(j)<thr+5. && (j>=thr || j<=0.)){\n                for(int n =0;n<LANES;n++){\n                    float pdi =  c.v[n].vtype==0? 10.:vdist(mod(point,1.),c.v[n],float(j) -thr>1.5); //DISTANCE FROM VEHICLE\n                    if(pdi<pd){\n                        pd=pdi;\n                        vtype =c.v[n].vtype; //closest vheicle type\n                        brake = c.v[n].brake;\n                        damaged = c.v[n].damaged;\n                        #if LANES>1\n                        lanechange =c.v[n].lane_out!=n;\n                        #endif\n                    }\n                }\n\n\n                //neghtbours\n                for(int i =min(iFrame,0);i<4;i++){\n                    for(int n=0;n<LANES;n++){\n                        vec3 ncoord =nextCoord(c,i,b.btype);\n                        vec4 ndata = CELL(coord2buffer(ncoord)); \n                        cell nc = decodeCell(ndata,ncoord);\n                        bool show= b.btype!=5 || ((i%2)==1  && j>=th )||  ((i%2)==0  && j< th );\n                        \n                        if(nc.v[n].vtype>0 && show ) {\n                            float npd=vdist(mod(point,1.) - DIRS[i],nc.v[n],float(j) -thr>1.5);\n                            if(pd>npd) {\n                                pd=npd;\n                                brake=nc.v[n].brake;\n                                vtype=nc.v[n].vtype;\n                                damaged = nc.v[n].damaged;\n                                #if LANES>1\n                        \t\tlanechange =nc.v[n].lane_out!=n;\n                        \t\t#endif\n                            }\n                        }\n                    }\n                }\n            }\n            }\n            if(pd<0.){\n               vec3 color= VCOLOR[vtype-1];\n                if(damaged) color=vec3(1.,0.,0.);\n                Q=vec4( (brake||lanechange) && abs(j-thr-1.)<.2 ? vec3(brake&&(!lanechange)?1.:0.,lanechange?1.:0.,0.): color*(j-thr>=1.5?.9:1.)*(pd >-.05?.5:1.),3.+thr);\n             }\n             //ROAD LIGHTS... TODO should be moved on road sides\n             #if QUALITY>1\n             //else if(j<= thr+10.&& j>= thm && b.btype==4&& abs(point.x-3.05 ) <.1 &&  abs(point.y-3.05 )<.1 )  Q=vec4(j-thr<8.?vec3(.5):vec3(1.,1.,.7),thr+10.);\n  \t          \n\n            //STRIPES            \n  \t        else if(j<= thr+.5 && j>= thm && j<th +.5  && mod(point.y,1.)<.5 && (b.conns&1)>0 &&  abs(point.x-3.05 ) <(zoomView?.03:.15)   &&  point.y>3. + fJun)  Q=vec4(1.,1.,1.,thr+.5);\n            else if(j<= thr+.5 && j>= thm && j<th +.5 && mod(point.y,1.)<.5 && (b.conns&4)>0 &&  abs(point.x-3.05 ) <(zoomView?.03:.15)   &&  point.y<3. - fJun)  Q=vec4(1.,1.,1.,thr+.5);\n            else if(j<= thr+.5 && j>= thm && (j>th -.5 ||j==0.) && mod(point.x,1.)<.5 && (b.conns&2)>0 &&  abs(point.y-3.05 ) <(zoomView?.03:.15)  &&  point.x>3. + fJun)  Q=vec4(1.,1.,1.,thr+.5);\n            else if(j<= thr+.5 && j>= thm && (j>th -.5 ||j==0.) && mod(point.x,1.)<.5 && (b.conns&8)>0 &&  abs(point.y-3.05 ) <(zoomView?.03:.15)   &&  point.x<3. - fJun)  Q=vec4(1.,1.,1.,thr+.5);\n\t\t\t#endif\n             //ASPHALT \n            else if(( j<= thr && j>= thm) || (j==0.&&b.btype==5))\n                Q=vec4(// (isDoubleLane(c.pos,b)?1.:.5)*\n                       //vec3(.4)*(j>0. && thr-j>1.?.5:1.) *(.9- (th-thr)/20.) * (UNCONNECTED ?.3:.8),thr);\n                        vec3(DEMO?.4:clamp(float(b.counter)/15.,.4,1.),.4,.4)*(j>0. && thr-j>1.?.5:1.) *(.9- (th-thr)/20.) * (UNCONNECTED ?.3:.8),thr);\n        \n            \n\t\t\telse Q=vec4(vec3(0.),j >thm? thr: th-5.);\n\t\t }\n    }\n    return Q;\n}\n\n// RAY TRACING\nMain {\n\n    if(U.x>R.x || U.y>R.y) return;\n    if(RESET<20.) {Q=vec4(0.); return; }//Q=vec4(.4); return;} \n\n    int sel = int(CONF(vec2(2.,0.)).x);\n\n    //if isometric 3d, the tracing is on horizontal slices\n    float dj=2.5;\n    int k=0;\n    block b;\n    b.block_pos=vec2(-100.);\n\n    for(float j =float(!zoomMode && !WIN && !DEMO ?0 : HEIGHT+THEIGHT) ; j>=0. ;j-=dj){\n\n        //SETUP VIEW---------------------\n        vec2 P= (U -SHIFT_VIEW)/ ZOOM; \n        if( U.x>R.x*ZX || WIN || DEMO)  {\n            P=position(U,float(j));\n        } \n\n        //BLOCK VARIABLES----------------------      \n        vec2 P0 = floor(P)+.5; //position center\n        vec3 coord= buffer2coord(P0);\n        vec3 bcoord= vec3( coord.xy,0.); \n\n        //OPTIMIZATION #3\n        if(length(b.block_pos-coord.xy)>.5)  \n            b = decodeBlock(BLOCK(coord2buffer(bcoord)),bcoord.xy); //CURRENT BLOCK\n      \n\n\n        //OPTIMIZATION #1     \n        if(j<= float(b.th)  + (b.btype==0 && b.ltype>0 ? float(b.bh)+5.:HEIGHT_MARGIN)) {\n            k++;\n            Q= map(P,j,b,zoomMode|| WIN || DEMO);\n            float th=Q.w;\n            //if(k>30) Q*=.2;\n\n            //HIGHLIGHT\n            vec2 m =  CONF(vec2(0.,0.)).xy;\n            if( !DEMO && U.x< RZ.x*ZX &&   length(buffer2coord(  m/ZOOM +.5).xy-bcoord.xy )<1. )  Q+= sel==4|| sel==5 ? vec4(1.,0.,0.,0.): vec4(0.,1.,0.,0.);\n\n            if(th>= float(j)) { \n                break;\n            };\n\n\n            dj=2.5;\n            #if QUALITY>0           \n            if(j <= th+15.) dj=.5;\n            if(j <= th+2.) dj=.2;\n            #else\n            if(j > th +10.) dj=2.5;  \n            if(j <= th+5.) dj=1.;         \n            #endif\n        }\n\n\n    } \n\n   //DEBUG HEIGHT    \n    //Q=vec4(Q.a/float(THEIGHT+ HEIGHT),mod(Q.a,10.),.5,0.);\n\n}\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}