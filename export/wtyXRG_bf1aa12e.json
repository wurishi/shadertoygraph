{"ver":"0.1","info":{"id":"wtyXRG","date":"1582982601","viewed":194,"name":"Reflection of a stripy room","username":"bencoder","description":"Playing with reflections","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["reflection","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CLOSE_D 0.01\n#define MAX_D 100.\n#define MAX_ITER 100\n#define REFL_BOUNCES 4\n\nmat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat hex( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xz -= 2.0*min(dot(k.xy, p.xz), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xz-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.z-h.x),\n       p.y-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat room(vec3 p) {\n    p.y -= 12.1;\n    return 0.1-sdBox(p, vec3(12));      \n}\n\n//returns the vec2 with the lower x component\n//used to handle distance in x and object id in y\nvec2 xmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat hit = 0.;\nfloat objectNearCount=0.;\nfloat sdf(vec3 p) {\n    vec2 room = vec2(room(p), 0);\n    float hexagon = hex(p-vec3(0,1.5,0),vec2(1.5,1.5));\n    float spheres = min(\n        min(\n            sphere(p-vec3(4,2.+sin(iTime),0),1.),\n            sphere(p-vec3(-4,2.+sin(iTime+3.14),0),1.)\n        ),\n        min(\n            sphere(p-vec3(0,2.+sin(iTime+3.14/2.),4),1.),\n            sphere(p-vec3(0,2.+sin(-iTime+3.14*1.5),-4),1.)\n        )\n    );\n    vec2 objects = vec2(\n        min(hexagon,spheres),\n    \t1\t//object id\n    );\n    \n    vec2 res = xmin(\n        room,\n        objects\n    );\n    hit = res.y;\n    objectNearCount += hit;\n    return res.x;\n}\n\nfloat rm(vec3 ro, vec3 rd, float max_d) {\n    float td=0.;\n    for(int i=0;i<MAX_ITER;i++) {\n        float d = sdf(ro+rd*td);\n        td += d;\n        if (abs(d) < CLOSE_D || td > max_d) break;\n    }\n    return td;\n}\n\nvec3 norm(vec3 p) {\n    vec2 e = vec2(.001,0);\n    return normalize(sdf(p) - vec3(\n        sdf(p - e.xyy),\n        sdf(p - e.yxy),\n        sdf(p - e.yyx)));\n}\n\nfloat light(vec3 p, vec3 rd) {\n    float originalONC = objectNearCount;\n    vec3 n = norm(p);\n\n    int b=0;\n    //If we hit something reflective (object id 1) and up to REFL_BOUNCES bounces:\n    while (hit == 1. && b++<REFL_BOUNCES) {\t\n        rd = reflect(rd, n); //get a new ray direction\n        p+=n*CLOSE_D*2.;     //pull out of the surface a bit so we're no longer intersecting\n        p = p+rd*rm(p, rd, MAX_D);  //raymarch from the old position to the next hit\n        n = norm(p);\n    }\n    \n    vec3 lp = vec3(5,10,-5);\n    vec3 ld = normalize(lp-p);\n    float l = dot(n,ld);\n    \n    float baseColor = .1+.9*smoothstep(-.05,.05,sin((p.y+p.x)*2.));\n    //reset the counter for how many iterations we are closer to the objects than the room\n    objectNearCount = 0.;\n    float max_d = length(lp-p);\n    float lm = rm(p+n*CLOSE_D*2.,ld, max_d);\n    if (lm < max_d) {\n        l *= 0.1;\n    }\n   \tl *= 1. * smoothstep(50.,10.,objectNearCount); //smooth shadows\n    //l += (1.-l)*smoothstep(20.,30.,originalONC); //glow around the objects\n    return l * baseColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.) / iResolution.y;\n\n    vec3 ro = vec3(0,4.,-8);\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    rd.yz *= rot(0.25);\n    if (iMouse.w < .5) {\n        ro.zx *= rot(iTime*0.1);\n        rd.zx *= rot(iTime*0.1);\n    } else {\n        ro.yz *= rot(-.5+(iMouse.y/iResolution.y) * 3.14/2.);\n        rd.yz *= rot(-.5+(iMouse.y/iResolution.y) * 3.14/2.);\n        ro.zx *= rot(iMouse.x/iResolution.x * 6.2);\n        rd.zx *= rot(iMouse.x/iResolution.x * 6.2);\n    }\n    objectNearCount = 0.;\n\tfloat d = rm(ro,rd, MAX_D);\n    \n    vec3 col = vec3(light(ro+rd*d, rd));\n    \n    col *= smoothstep(100.,50.,d);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}