{"ver":"0.1","info":{"id":"tdsfzN","date":"1587844864","viewed":328,"name":"Bicubic contours","username":"TheoHonohan","description":"Contour drawing with bicubic interpolation. Based on \"bicubic\" by simesgreen and \"contour lines\" by 8x.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bicubic","contour","fwidth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 4x4 bicubic filter using 4 bilinear texture lookups \n// See GPU Gems 2: \"Fast Third-Order Texture Filtering\", Sigg & Hadwiger:\n// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter20.html\n\n// w0, w1, w2, and w3 are the four cubic B-spline basis functions\nfloat w0(float a)\n{\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nfloat w1(float a)\n{\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nfloat w2(float a)\n{\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nfloat w3(float a)\n{\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 and g1 are the two amplitude functions\nfloat g0(float a)\n{\n    return w0(a) + w1(a);\n}\n\nfloat g1(float a)\n{\n    return w2(a) + w3(a);\n}\n\n// h0 and h1 are the two offset functions\nfloat h0(float a)\n{\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nfloat h1(float a)\n{\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 texture_bicubic(sampler2D tex, vec2 uv, vec4 texelSize)\n{\n\tuv = uv*texelSize.zw + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\n    float g0x = g0(fuv.x);\n    float g1x = g1(fuv.x);\n    float h0x = h0(fuv.x);\n    float h1x = h1(fuv.x);\n    float h0y = h0(fuv.y);\n    float h1y = h1(fuv.y);\n\n\tvec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\tvec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\t\n    return g0(fuv.y) * (g0x * texture(tex, p0)  +\n                        g1x * texture(tex, p1)) +\n           g1(fuv.y) * (g0x * texture(tex, p2)  +\n                        g1x * texture(tex, p3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - iMouse.xy) / iResolution.xy;\n    \n    vec2 uv = p*0.1;\n\t\n    //---------------------------------------------\t\n\t// regular texture map filtering\n    //---------------------------------------------\t\n\tvec3 colA = texture( iChannel0, uv ).xyz;\n\n    // bicubic\n    vec4 texelSize = vec4( 1.0 / iChannelResolution[0].xy,  iChannelResolution[0].xy);\n\tvec3 colB = texture_bicubic( iChannel0, uv, texelSize ).xyz;\t\n    \n    //---------------------------------------------\t\n    // mix between the two colors\n    //---------------------------------------------\t\n\tvec3 col = mix( colA, colB, smoothstep( -0.3, 0.3, sin(1.0*p.x + 3.1416*iTime) ) );\n    \n    //\n    // attempt to draw contours added by TH\n    //\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n\n    float z = colB.x;\n    \n    z *= 4.0 * sin(1.57);\n    float d = fract(z);\n    if(mod(z, 2.0) > 1.) d = 1.-d;\n     \n\n    d = d/fwidth(z);\n    fragColor = vec4(d);\n    \n    // \n    // end of attempt to draw contours\n    //\n    \n    \n    // original return\n    //fragColor = vec4( colB, 1.0 );\n}","name":"Image","description":"","type":"image"}]}