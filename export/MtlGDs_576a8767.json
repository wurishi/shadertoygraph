{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by nick whitney - nwhit/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Uses Double Precision floats, so it should develop errors after zoom level ~42. \n// Seems to have the same issue with float precision as the Single P version, however.\n// I don't know if this is because of WebGL or Nvidia cards or something else.\n\n// I would use a ds_div function instead of the (1. / var), but the ds_div function causes\n// an error but no error messages show up.\n\n// Attemping to stop NVidia cards from reverting to singleP\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n\n/////////////////////////////////\n// Zoom Centers\n/////////////////////////////////\nconst vec2 fillErUp = vec2(0.3585614710926859372,\n                           0.3229491840959411351);\n\nconst vec2 sunflowers = vec2(-1.985540371654130485531439267191269851811165434636382820704394766801377,\n                             0.000000000000000000000000000001565120217211466101983496092509512479178);\n\nconst vec2 sunflowersX = vec2(-1.9855403900146484375,\n                              0.000000018360517951968560732808730148188834565363617179);\n\nconst vec2 sunflowersY = vec2(0.000000000000000000000000000001565120228882564491389030362389781052341234098969,\n                              0.);\n#define FILLERUP\n//#define SUNFLOWERS\n\n/////////////////////////////////\n// General Constants\n/////////////////////////////////\nconst int maxIterations = 4000;\nconst float zoomSpeed = .35;\nconst float radius = 20.;\n\n/////////////////////////////////\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n\n// Add: res = ds_add(a, b) => res = a + b\nvec2 ds_add(vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float t1, t2, e;\n\n    t1 = dsa.x + dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\n// Subtract: res = ds_sub(a, b) => res = a - b\nvec2 ds_sub(vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float e, t1, t2;\n\n    t1 = dsa.x - dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat ds_compare(vec2 dsa, vec2 dsb)\n{\n    if (dsa.x < dsb.x) return -1.;\n    else if (dsa.x == dsb.x) \n    {\n        if (dsa.y < dsb.y) return -1.;\n        else if (dsa.y == dsb.y) return 0.;\n        else return 1.;\n    }\n    else return 1.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 ds_mul(vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float c11, c21, c2, e, t1, t2;\n    float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n    cona = dsa.x * split;\n    conb = dsb.x * split;\n    a1 = cona - (cona - dsa.x);\n    b1 = conb - (conb - dsb.x);\n    a2 = dsa.x - a1;\n    b2 = dsb.x - b1;\n\n    c11 = dsa.x * dsb.x;\n    c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));\n\n    c2 = dsa.x * dsb.y + dsa.y * dsb.x;\n\n    t1 = c11 + c2;\n    e = t1 - c11;\n    t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n\n    return dsc;\n}\n\n// create double-single number from float\nvec2 ds_set(float a)\n{\n    vec2 z;\n    z.x = a;\n    z.y = 0.0;\n    return z;\n}\n\n// End Double-Single Emulation Section\n//////////////////////////////////////\n\n//////////////////////////////////////\n// Begin Main Section\n//////////////////////////////////////\n// Calculate and return the iteration depth for the current pixel\nfloat ds_Mandelbrot(vec2 px, vec2 py, vec2 cx1, vec2 cy1, float zoom)\n{       \n    //calculate the initial real and imaginary part of z, based on the pixel location and zoom and position values        \n    vec2 ds_invZoom = ds_set(1. / zoom);\n    \n    vec2 cx = ds_add(ds_mul(px, ds_invZoom), cx1);\n    vec2 cy = ds_add(ds_mul(py, ds_invZoom), cy1);\n    \n    vec2 zx = cx;\n    vec2 zy = cy;\n    \n    vec2 ds_two = ds_set(2.);\n    \n    vec2 ds_radius = ds_set(radius * radius);\n      \n    //start the iteration process\n    for(int i = 0; i < maxIterations; i++)\n    {     \n        vec2 oldzx = zx;\n        zx = ds_add(ds_sub(ds_mul(zx, zx), ds_mul(zy, zy)), cx);\n    \tzy = ds_add(ds_mul(ds_two, ds_mul(oldzx, zy)), cy);\n        \n        if(ds_compare(ds_add(ds_mul(zx, zx), ds_mul(zy, zy)), ds_radius) > 0.) \n        {\n            //float modulus = sqrt(z.x*z.x + z.y*z.y);\n            \n            //return(float(i) + 1. - log(log(modulus)) / log(2.));\n            return float(i);\n        }\n    }    \n    \n    return 0.;\n}\n\n// generates a color based on the iteration depth\nvec3 stepColor(float iter)\n{   \n    //vec3 color = vec3(mod(iter, 255.), sin(iter), cos(iter));\n    \n    vec3 color = vec3((-cos(0.025*float(iter))+1.0)/2.0,\n                      (-cos(0.08*float(iter))+1.0)/2.0,\n                      (-cos(0.12*float(iter))+1.0)/2.0);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 one = ds_set(1.0);\n    vec2 two = ds_set(2.0);\n    \n    //vec2 p = 2.0 * fragCoord.xy / iResolution - 1.;\n\n    vec2 p = fragCoord.xy / iResolution.xy;\n        \n    vec2 px = ds_sub(ds_mul(two, ds_set(p.x)), one);\n    vec2 py = ds_sub(ds_mul(two, ds_set(p.y)), one);\n    \n    float ratio = iResolution.x/iResolution.y;\n    vec2 ds_ratio = ds_set(ratio);\n    \n    px = ds_mul(px, ds_ratio);\n\n    // animation\t\n    float zoom = pow( 0.5, -zoomSpeed * mod(iTime, 30. / zoomSpeed) );\n    \n    vec2 invRes = vec2(1.0) / iResolution.xy;\n    vec2 iResX = ds_set(iResolution.x);\n    vec2 iResY = ds_set(iResolution.y);\n    \n    #ifdef FILLERUP\n    vec2 cx = ds_set(fillErUp.x);\n    vec2 cy = ds_set(fillErUp.y);\n    #else\n    vec2 cx = sunflowersX;\n    vec2 cy = sunflowersY;\n    #endif\n    \n    float iter = float(ds_Mandelbrot(px, py, cx, cy, zoom));\n    \n    vec3 col = stepColor(iter);\n    \n   \tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtlGDs","date":"1426388780","viewed":312,"name":"Mandel Deep Zoom - Double P","username":"Razaekel","description":"Attempted Deep Zoom into the Mandelbrot set with emulated double precision.\n\nSingle Precision version: https://www.shadertoy.com/view/MlsGWs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","mandelbrot","deepzoom"],"hasliked":0,"parentid":"","parentname":""}}