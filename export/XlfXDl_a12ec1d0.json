{"ver":"0.1","info":{"id":"XlfXDl","date":"1440408319","viewed":416,"name":"Ghost in the noise ","username":"tomkh","description":"Based on my previous experiment: MtlSWX\nJust added some colors, animated light and relfections.\nNoise is in fact 4d now - distance to light is affecting 4th dimension.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// A simple example tracing over value-noise\n// tomkh@2015\n\nconst int iterations = 200;\nconst float dist_eps = .004;\nconst float ray_max = 50.0;\nconst float fog_density = .05;\n\nconst float cam_dist = 8.5;\n\n// Estimated inverse \"steepness\" factor:\nfloat invslope_factor = .9;\n\nvec3 light_pos;\n\n//------------------------------------------------------------------------\n// Some of IQ's noise that is in fact a value-noise (not a gradient-noise)\n// Extended with offset\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x, in float offset )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z + offset*17.0;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n//------------------------------------------------------------------------\n\nfloat dField(in vec3 p)\n{\n   // Simply take a noise value * invslope_factor as a distance:\n   p += vec3(.7,1.2,-5.0);\n   \n   // Take distance to light as interpolation factor:\n   vec3 dp = p - light_pos;\n   float m = max(0.0, 3.0 - length(dp)*.5);\n    \n   // Interpolate two noise values:\n   float value;\n   if (m > 0.0) {\n     float o = floor(m);\n     float f = m - o;\n     f = f*f*(3.0-2.0*f);\n     value = mix(noise(p,o),noise(p,o+1.0),f);\n   } else {\n     value = noise(p,0.0);\n   }\n   \n    return (value - .33)*invslope_factor;\n}\n\nvec3 dNormal(in vec3 p)\n{\n   const float eps = .005;\n   const vec3 x_eps = vec3(eps,0,0);\n   const vec3 y_eps = vec3(0,eps,0);\n   const vec3 z_eps = vec3(0,0,eps);\n   return normalize(vec3(\n      dField(p + x_eps) - dField(p - x_eps),\n      dField(p + y_eps) - dField(p - y_eps),\n      dField(p + z_eps) - dField(p - z_eps) ));\n}\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir, inout float ray_len, inout float light_gather)\n{\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = dField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      \n      vec3 light_dir = light_pos - p;\n      float light_dist = dot(light_dir, light_dir);\n      float light_falloff = (5.0/light_dist)*(1.0-dist);\n      //light_falloff *= texture(iChannel0, normalize(light_dir).xy*.1).x*.5+.5;\n      light_gather += light_falloff*dist; // gather along the ray\n      \n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\nvec4 shade(in vec3 ray_dir, in float ray_len, in float light_gather, in vec4 hit, out vec3 norm)\n{\n   const vec3 ambient = vec3(-.08,.22,.08);\n   const vec3 light_color = vec3(1.,1.,.7);\n   vec3 fog_color = light_color*(light_gather*.07) + ambient;\n   \n   if (hit.w == 0.0) {\n      return vec4(fog_color, 1.0);\n   }\n   \n   norm = dNormal(hit.xyz);\n   vec3 light_dir = light_pos - hit.xyz;\n   float light_dist = dot(light_dir, light_dir);\n   light_dir *= inversesqrt(light_dist);\n   float light_falloff = min(1.5,(5.0/light_dist));\n   float diffuse = max(0.0, dot(norm, light_dir));\n   float spec = max(0.0,dot(reflect(light_dir,norm),ray_dir));\n   spec = pow(spec, 16.0)*.5;\n   diffuse *= light_falloff;\n   spec *= light_falloff;\n\n   vec3 base_color = vec3(.7,.5,.1);\n   //vec3 anorm = abs(norm.xyz);\n   //vec2 uv = (anorm.x>max(anorm.y,anorm.z))?hit.yz:(anorm.y>anorm.z)?hit.xz:hit.xy;\n   //base_color *= texture(iChannel0, uv).x*.1 + .9;\n   vec3 color = mix(ambient,light_color*base_color,diffuse) +\n      spec*vec3(1.,1.,.9);\n   \n   float fog = 1.0 - 1.0/exp(ray_len*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   float ang, si, co;\n    \n   float light_anim = iTime*.25;\n   si = sin(light_anim*.6); co = cos(light_anim*.4);\n   light_pos = vec3(sin(light_anim)*3.0*si,co*1.0,si*cos(light_anim*.7)*3.0);\n    \n   //if (iMouse.z > 0.0) {\n   //  invslope_factor = iMouse.y * 2.0 / iResolution.y;\n   //}\n   \n   // Simple rotating camera:\n   ang = (iMouse.z > 0.0) ? -(iMouse.x - iResolution.x*.5)*.003 : sin(iTime*.5)*.05;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   if (iMouse.z > 0.0) {\n      ang = -(iMouse.y - iResolution.y*.5)*.003;\n\t  si = sin(ang); co = cos(ang);\n      cam_mat *= mat4(\n         1., 0., 0., 0.,\n         0., co, si, 0.,\n         0.,-si, co, 0.,\n         0., 0., 0., 1.);\n   }\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n\n   light_pos += vec3(cam_mat*vec4(0., 0., -cam_dist + 3.0, 1.0));\n   \n   vec3 norm;\n   \n   float ray_len = 0.0, light_gather = 0.0;\n   vec4 hit = trace(pos + dir*.25, dir, ray_len, light_gather);\n   vec4 col = shade(dir, ray_len, light_gather, hit, norm);\n   \n   if (hit.w > 0.0) {\n      dir = reflect(dir, norm);\n      pos = hit.xyz + dir*.01;\n      light_gather = 0.0;\n      vec4 hit = trace(pos, dir, ray_len, light_gather);\n      col = mix(col, shade(dir, ray_len, light_gather, hit, norm), .25);\n   }\n   \n   fragColor = col;\n}\n","name":"","description":"","type":"image"}]}