{"ver":"0.1","info":{"id":"clVSWm","date":"1686232201","viewed":114,"name":"M^n(lbr0t Zo0m","username":"TheG3ntleman","description":" mandelbrot zoom.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Which point to zoom into\n#define CENTER_REAL -0.104943 //-0.05\n#define CENTER_IMAGINARY  0.927572 //.6805\n\n// Higher the more detailed\n// Will be slow if the value is too high\n#define MAX_ITERATIONS 15000u \n\n#define Z_THRESHOLD 2.5\n\n// How quickly to zoom in\n#define ZOOM_START -0.5\n#define ZOOM_SPEED 1.5 \n\n// When to repeat the zoom\n#define MAX_ZOOM_DURATION 30.0\n\n// Higher the more distinct the colors per region\n#define SEPERATION_FREQUENCY 350.0 \n\n\nvec3 palette( in float t )\n{\n    // Got this from here: https://iquilezles.org/articles/palettes/\n\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 MandelbrotRecursiveStep(vec2 z, vec2 c) {\n\n    // Mandelbrot recursive step for more check out: \n    // https://en.wikipedia.org/wiki/Mandelbrot_set\n    // Could be replaced to render other fractals.\n    return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n}\n\nuint MandelbrotIterations (vec2 c) {\n    vec2 z = vec2(0.0, 0.0);    \n    uint n = 0u;\n    \n    for(; (length(z) < Z_THRESHOLD) && (n < MAX_ITERATIONS); n++)\n        z = MandelbrotRecursiveStep(z, c);\n\n    \n    return n;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    // Scaling coordinates to Mandelbrot coordinates\n    // x will represent real values where as y will represent complex values\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x = uv.x * 2.05 - 2.0;\n    uv.y = uv.y * 2.0 - 1.0;\n   \n    // Repeating zoom after some time because of floating point precision.\n    float time = MAX_ZOOM_DURATION * fract(iTime / MAX_ZOOM_DURATION);\n   \n    // Zooming works by reducing the coordinate space size.\n    uv /= ZOOM_START + pow(ZOOM_SPEED, time);\n    uv = vec2(CENTER_REAL,CENTER_IMAGINARY) + uv;\n    \n    // Intensity of a point is calculated by checking how many iterations the point\n    // took to reach the threshold out of the maximum number of iterations calculated.\n    float intensity = 1.0 - float(MandelbrotIterations(uv)) / float(MAX_ITERATIONS);\n    \n    // The color of a point depends on the position, the intensity, and time.\n    fragColor = vec4 (intensity * palette(time + intensity * SEPERATION_FREQUENCY), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}