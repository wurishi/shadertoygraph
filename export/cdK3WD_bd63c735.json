{"ver":"0.1","info":{"id":"cdK3WD","date":"1678549830","viewed":113,"name":"cube-sphere reflection","username":"benjidial","description":"interpolating between a sphere distance function and a cube distance function","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","cube","sphere"],"hasliked":0,"parentid":"mdy3WW","parentname":"rainbow cube"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//world stuff\n\nvec4 cubeCenter = vec4(0.0, 0.0, 0.0, 1.0);\nfloat cubeRadius = 1.0;\n\nvec4 sphereCenter = vec4(0.0, 0.0, 0.0, 1.0);\nfloat sphereRadius = (sqrt(3.0) + 1.0) / 2.0;\n\n//0.0 is just a cube, 1.0 is just a sphere\nfloat maxCubiness = 0.0;\nfloat maxSpheriness = 1.0;\n\n//constants\n\nconst float camVertFovDegrees = 40.0;\nconst float maxRenderDist = 10.0;\nconst float prec = 0.002;\n\n//camera stuff\n\nvec4 camPos;\nvec4 camTarget;\n\nvec4 camForward;\nvec4 camForwardFlat;\nfloat camTheta;\nvec4 camUp;\nvec4 camRight;\nvec4 cpCenter;\n\nconst float camVertFov = camVertFovDegrees * 3.14159 / 180.0;\nconst float cpHeight = 2.0 * tan(camVertFov / 2.0);\n\nvoid updateCamera(vec4 pos, vec4 target) {\n  camPos = pos;\n  camTarget = target;\n  camForward = normalize(camTarget - camPos);\n  camForwardFlat = normalize(camForward.xwzw);\n  camTheta = asin(camForward.y);\n  camUp = -sin(camTheta) * camForwardFlat + vec4(0.0, cos(camTheta), 0.0, 0.0);\n  camRight = vec4(cross(camForward.xyz, camUp.xyz), 0.0);\n  cpCenter = camPos + camForward;\n}\n\n//functions\n\nvec2 clampToSquare(vec2 point, vec2 squareCenter, float squareRadius) {\n  return clamp(point, squareCenter - squareRadius, squareCenter + squareRadius);\n}\n\nvec4 nearestCubePoint(vec4 pos) {\n  vec2 xyClamp = clampToSquare(pos.xy, cubeCenter.xy, cubeRadius);\n  vec2 xzClamp = clampToSquare(pos.xz, cubeCenter.xz, cubeRadius);\n  vec2 yzClamp = clampToSquare(pos.yz, cubeCenter.yz, cubeRadius);\n  \n  vec4 candidates[6] = vec4[](\n    vec4(xyClamp, cubeCenter.z - cubeRadius, 1.0),\n    vec4(xyClamp, cubeCenter.z + cubeRadius, 1.0),\n    vec4(xzClamp.x, cubeCenter.y - cubeRadius, xzClamp.y, 1.0),\n    vec4(xzClamp.x, cubeCenter.y + cubeRadius, xzClamp.y, 1.0),\n    vec4(cubeCenter.x - cubeRadius, yzClamp, 1.0),\n    vec4(cubeCenter.x + cubeRadius, yzClamp, 1.0)\n  );\n\n  vec4 choice;\n  float dist = maxRenderDist;//this is probably safe?\n\n  for (int i = 0; i < 6; ++i)\n    if (distance(candidates[i], pos) < dist) {\n      dist = distance(candidates[i], pos);\n      choice = candidates[i];\n    }\n\n  return choice;\n}\n\nfloat cubeSignedDist(vec4 pos) {\n  float dist = distance(nearestCubePoint(pos), pos);\n  vec4 cubeScale = abs(pos - cubeCenter) / cubeRadius;\n  if (cubeScale.x < 1.0 && cubeScale.y < 1.0 && cubeScale.z < 1.0)\n    return -dist;\n  return dist;\n}\n\nfloat sphereSignedDist(vec4 pos) {\n  return distance(pos, sphereCenter) - sphereRadius;\n}\n\nfloat combinedSignedDist(vec4 pos) {\n  float cd = cubeSignedDist(pos);\n  float sd = sphereSignedDist(pos);\n  \n  //return cd - 0.5;\n\n  //return min(cd, sd);\n\n  //return max(cd, sd);\n\n  //return (cd + sd) / 2.0;\n\n  float t = sin(iTime / sqrt(11.0)) * 0.5 + 0.5;\n  t = maxSpheriness * t + maxCubiness * (1.0 - t);\n  return cd * t + sd * (1.0 - t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float camAx = iTime / 20.0;\n  float camAy = 3.14159 * .25;\n  vec3 camXZ = vec3(cos(camAx), 0.0, sin(camAx));\n  vec3 camXYZ = camXZ * cos(camAy) + vec3(0.0, 1.0, 0.0) * sin(camAy);\n\n  updateCamera(vec4(6.0 * camXYZ, 1.0), vec4(0.0, 0.0, 0.0, 1.0));\n\n  vec2 cpOffset = (fragCoord - 0.5 * iResolution.xy) * cpHeight / iResolution.y;\n  vec4 cpHit = cpCenter + cpOffset.x * camRight + cpOffset.y * camUp;\n\n  vec4 rayDir = normalize(cpHit - camPos);\n  vec4 rayPos = camPos;\n\n  while (distance(rayPos, camPos) < maxRenderDist) {\n    float dist = combinedSignedDist(rayPos);\n    if (dist < prec) {\n      float gradDist = dist / 10.0;\n      vec4 gradDx = vec4(gradDist, 0.0, 0.0, 0.0);\n      vec4 gradDy = vec4(0.0, gradDist, 0.0, 0.0);\n      vec4 gradDz = vec4(0.0, 0.0, gradDist, 0.0);\n      \n      float gradX = (combinedSignedDist(rayPos + gradDx) - combinedSignedDist(rayPos - gradDx)) / (2.0 * gradDist);\n      float gradY = (combinedSignedDist(rayPos + gradDy) - combinedSignedDist(rayPos - gradDy)) / (2.0 * gradDist);\n      float gradZ = (combinedSignedDist(rayPos + gradDz) - combinedSignedDist(rayPos - gradDz)) / (2.0 * gradDist);\n      vec3 grad = vec3(gradX, gradY, gradZ);\n\n      vec4 shapeNormal = normalize(vec4(grad, 0.0));\n      vec4 reflectionDir = reflect(rayDir, shapeNormal);\n\n      fragColor = textureLod(iChannel0, reflectionDir.xyz, 0.0);\n      return;\n    }\n    rayPos += rayDir * dist * 0.5; //removing the * 0.5 causes some weird artifacts to appear\n  }\n  \n  fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}","name":"Image","description":"","type":"image"}]}