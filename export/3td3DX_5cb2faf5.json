{"ver":"0.1","info":{"id":"3td3DX","date":"1577756273","viewed":119,"name":"original-32360-1","username":"jorge2017a1","description":"original-32360-1","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["original323601"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI=3.14159265;\n#define Power 10.0\n#define Bailout 2.0\n\nvoid powN1(inout vec3 z, float r, inout float dr) {\n\t// extract polar coordinates\n\tfloat theta = acos(z.z/r);\n\tfloat phi = atan(z.y,z.x);\n\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\n\t// scale and rotate the point\n\tfloat zr = pow( r,Power);\n\ttheta = theta*Power;\n\tphi = phi*Power;\n\t\n\t// convert back to cartesian coordinates\n\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n}\n\n\n// Compute the distance from `pos` to the Mandelbox.\nfloat DE(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=0.75;\n\tr=length(z);\n\tfor(int i=0; (i < 4); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tif (r>Bailout) break;\n\t}\n\t\n\treturn (cos(iTime*0.60+cos(iTime*0.3+(pos.x*pos.x+pos.y*pos.y+pos.z*pos.z)*50.0)*0.4)*0.06+0.14)*log(r)*r/dr;\n    \n}\n\nvec3 DEColor(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=1.0;\n\tr=length(z);\n\tfloat minR = 1000.0;\n\tfor(int i=0; (i < 2); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tminR = min(r,minR);\n\t\tif (r>Bailout) break;\n\t}\n\tfloat i = minR*minR*minR*minR*0.50;\n\treturn vec3(clamp(i,0.0,1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n\n  //Camera animation\n  vec3 vuv=vec3(0,1.0,0.5);//Change camere up vector here\n  vec3 vrp=vec3(0,cos(iTime)*0.25,sin(iTime)*0.25); //Change camere view here\n  float mx=iMouse.x*PI*1.0;\n  float my=iMouse.y*PI/1.0;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*2.0; //Trackball style camera pos\n  \n\n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn))*0.25;\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  //Raymarching\n  const vec3 e=vec3(0.001,0,0);\n  const float maxd=4.0; //Max depth\n  float s=0.0;\n  vec3 c,p,n;\n\n  float f=0.10;\n  for(int i=0;i<46;i++){\n    f+=s;\n    p=prp+scp*f;\n    s=DE(p)*1.0;\n    if (abs(s)<.0025||f>maxd) break;\n   \n  }\n  \t\n  if (f<maxd){\n    n=normalize(\n      vec3(s-DE(p-e.xyy),\n           s-DE(p-e.yxy),\n           s-DE(p-e.yyx)));\n    c = DEColor(p);\n    c.yz = max(mix(c.yz, n.yz, 0.2),0.3)+0.2;\n    float b=dot(n,normalize(prp-p));  \n    fragColor = mix(vec4((b*c+pow(b,256.0))*(1.0-f*.31),1.0), vec4(c,1.0),0.38);\n  }\n  else {\n      fragColor=vec4(0.0,0,0,1); //background color\n  }\n\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}