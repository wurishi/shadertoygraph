{"ver":"0.1","info":{"id":"cdSGz1","date":"1667194682","viewed":95,"name":"Fractal rising pitch","username":"WhiteWalrus518","description":"My first sound shader :)\nIt uses the same fractal pattern I use for spaced repetition - I thought it would be fun to hear it\n","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colLookup(int index){\n    vec3[10] colors;\n    colors[0] = normalize(vec3(0.8, 0.2, 0.2));\n    colors[1] = normalize(vec3(0.8, 0.4, 0.2));\n    colors[2] = normalize(vec3(0.8, 0.6, 0.2));\n    colors[3] = normalize(vec3(0.8, 0.8, 0.2));\n    colors[4] = normalize(vec3(0.6, 0.8, 0.2));\n    colors[5] = normalize(vec3(0.4, 0.8, 0.2));\n    colors[6] = normalize(vec3(0.2, 0.8, 0.2));\n    colors[7] = normalize(vec3(0.2, 0.8, 0.4));\n    colors[8] = normalize(vec3(0.2, 0.8, 0.6));\n    colors[9] = normalize(vec3(0.2, 0.8, 0.8));\n    \n   return colors[index];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 10.0;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 pos = floor(uv * scale);\n    pos.x += speed * iTime;\n    vec3 col = vec3(1.0);\n    \n    \n    float height = float(factorPowersOfTwo(int(pos.x) - 1));\n    if(pos.y + 1.0 == height){\n        col = colLookup(int(height) - 1);\n        if(floor(uv.x * scale) == 0.0){\n            col = vec3(0.0, 0.0, 0.3);\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159265828\n\nfloat MajorScale(int position){\n    float[7] intervals;\n    intervals[0]  = pow(2.0, 0.0/12.0);\n    intervals[1]  = pow(2.0, 2.0/12.0);\n    intervals[2]  = pow(2.0, 4.0/12.0);\n    intervals[3]  = pow(2.0, 5.0/12.0);\n    intervals[4]  = pow(2.0, 7.0/12.0);\n    intervals[5]  = pow(2.0, 9.0/12.0);\n    intervals[6]  = pow(2.0, 11.0/12.0);\n    //intervals[7]  = pow(2.0, 12.0/12.0);\n    float term = mod(float(position), 8.0);\n    float octave = float(position / 8);\n    \n    return intervals[int(term)] * pow(2.0, octave);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float t = time  * speed;\n    int power = factorPowersOfTwo(int(t));\n    float freq = MajorScale(power - 1) * 440.0;\n    \n    return vec2( sin(2.0 * pi * freq * time) * fract(t) * (1.0 - fract(t)));\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"// factorPowersOfTwo is meant to give the bit address \n// of the lowest value 1 in the binary representation\n// i.e. 16 = ...1000 hence output => 4\n//      19 = ...1011 hence output => 1\n//\n// My iterative solution is in log-time, but surely there's a constant time solution??\n//\n// Anyways, all suggestions welcome :)\nint factorPowersOfTwo( int x )\n{\n    for(int i = 0; i < 1 + int(log(float(x)) / log(2.0)); i++ ){\n        if( fract(float(x) / pow(2.0, float(i))) != 0.0 ){\n            return i;\n        }\n    }\n}\n\nfloat speed = 10.0;\n","name":"Common","description":"","type":"common"}]}