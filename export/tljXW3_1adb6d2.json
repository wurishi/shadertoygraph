{"ver":"0.1","info":{"id":"tljXW3","date":"1588187745","viewed":120,"name":"Moving particles by tesselator","username":"Tesselator","description":"trying to implement physics behaviour","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["physicsparticles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct particle {\n    vec2 p;\n    vec2 v;\n};\n\nparticle read( vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;   \n    particle p;\n    p.p = texture(iChannel0, uv).xy;\n    p.v = texture(iChannel0, uv).zw;\n    return p;\n}\n\nfloat sdSphere( vec2 p, float s )\n{\n  return length(p) - s;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat map(vec2 p)\n{\n    float r = 10000.0;\n    for(float i = 0.0; i < iResolution.x; i++)\n    {\n        particle x = read(vec2(i + 0.5, 0.5));\t\n        r = opSmoothUnion(r, sdSphere(p - x.p, 2.0), 20.0);\n        if( r < 1.0 )\n            return r;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( map (fragCoord) < 1.0 )\n\t\tfragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    else\n        fragColor = vec4(1.0);\n    if( texture(iChannel1, fragCoord / iResolution.xy).r == 1.0)\n        fragColor.xyz = 0.5 * fragColor.xyz + 0.5 * vec3(1.0, 0.0, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define timeScale 10.0\nstruct particle {\n    vec2 p;\n    vec2 v;\n};\n\nparticle read( vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;   \n    particle p;\n    p.p = texture(iChannel0, uv).xy;\n    p.v = texture(iChannel0, uv).zw;\n    return p;\n}\n\nvec4 write( particle p )\n{\n    return vec4(p.p, p.v);\n}\n\n#define fk 1.0\n#define rad 2.0\nvec2 collide(particle p)\n{\n\tvec2 f = vec2(0.0);\n    for(float i = 0.0; i < iResolution.x; i++)\n    {\n        particle x = read(vec2(i + 0.5, 0.5));\n        vec2 d = x.p - p.p;\n        float l = length(d);\n        if(l < 2.0 * rad)\n        \tf += -fk * d;\n//\t        f += -d * pow(l, -3.0);\n    }\n    return f;\n}\n\nvoid initParticle( vec2 fragCoord, vec2 uv, out particle p )\n{\n    p.p = iResolution.xy * 0.5;\n//    p.v.x = fragCoord.x * (int(fragCoord.x) % 2 == 0 ? 1.0 : -1.0);//texture(iChannel1, uv).x;\n    vec2 noise = texture(iChannel1, uv).xy;\n    p.v.x = 100.0 * cos(noise.x);\n    p.v.y = 100.0 * sin(noise.x);\n}\n    \nvec2 calcNormal( in vec2 uv )\n{\n    vec2 h = vec2(1.0) / iResolution.xy;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xy*texture(iChannel2, uv + k.xy*h ).x + \n                      k.yy*texture(iChannel2, uv + k.yy*h ).x + \n                      k.yx*texture(iChannel2, uv + k.yx*h ).x + \n                      k.xx*texture(iChannel2, uv + k.xx*h ).x );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if(fragCoord.y > 10.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    particle p = read(fragCoord);\n    if( iFrame == 0 )\n        initParticle(fragCoord, uv, p);\n   \telse\n    {\n    \tvec2 a = vec2(0.0, -9.8);\n    \ta -= 0.01 * p.v;\n        a += collide(p);\n    \tp.v += a * iTimeDelta * timeScale;\n    }\n    if(p.p.y < 0.0)\n    {\n        p.p.y = 0.0;\n        p.v.y *= -0.9;\n    }\n    if(p.p.x < 0.0)\n    {\n        p.p.x = 0.0;\n        p.v.x *= -0.9;\n    }\n    else\n    if(p.p.x > iResolution.x)\n    {\n        p.p.x = iResolution.x;\n        p.v.x *= -0.9;\n    }\n    uv = p.p / iResolution.xy;\n    if( texture(iChannel2, uv).r == 1.0 )\n    {\n        vec2 n = -calcNormal(uv);\n        float d = dot(n, p.v);\n        if(d < 0.0)\n        {\n            p.v -= d * n;\n            for(int i = 0; i < 10; i++)\n                if (texture(iChannel2, p.p/iResolution.xy).r != 1.0)\n                \tbreak;\n                else\n                    p.p += n;\n        }\n    }\n    p.p += p.v * iTimeDelta * timeScale;\n    fragColor = write(p);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( length(fragCoord - iMouse.xy) < 10.0 )\n        fragColor = vec4(1.0);\n   \telse\n    \tdiscard;\n}","name":"Buffer C","description":"","type":"buffer"}]}