{"ver":"0.1","info":{"id":"wlXBWX","date":"1597868613","viewed":204,"name":"Drainage Erosion","username":"j91000","description":"landscape evolution model. Click to reset the sim.\nI have since added sediment transport and deposition in this shader:\nhttps://www.shadertoy.com/view/wtffDX","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fluid","heightmap","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getState(in vec2 p){\n    return texture(iChannel0,p);\n}\nfloat accumulatedFlowMag(in vec4 state){\n    float xflow=state.z;\n    float yflow=state.w;\n    if(xflow!=0.){return abs(xflow);}\n    return abs(yflow);\n}\nfloat getLevel(in vec2 p){\n    vec4 state=getState(p);\n    float level=state.x+accumulatedFlowMag(state)+state.y;\n    return level;\n}\nfloat getW(in vec2 p){\n    vec4 state=getState(p);\n    float water=state.y;\n    water+=accumulatedFlowMag(state);\n    return water;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec4 col = vec4(getLevel(uv));\n    if(getW(uv)>.0001){col.xy=vec2(.0);col.z=200.*pow(getW(uv),.75);}\n\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float RAINFALL=0.000001;\nconst float EROSIONPOWER=.3;\nconst float UPLIFT=.0005;\nvec4 getState(in vec2 p){\n    return texture(iChannel0,p/iResolution.xy);\n}\nfloat accumulatedFlowMag(in vec4 state){\n    float xflow=state.z;\n    float yflow=state.w;\n    return max(abs(xflow),abs(yflow));\n}\nfloat getLevel(in vec2 p){\n    vec4 state=getState(p);\n    float level=state.x+accumulatedFlowMag(state)+state.y;\n     level=state.x+state.y;\n    return level;\n}\n\nfloat getW(in vec2 p){\n    vec4 state=getState(p);\n    float water=state.y;\n    //water+=accumulatedFlowMag(state);\n    return water;\n}\nfloat getH(in vec2 p){\n    vec4 state=getState(p);\n    float height=state.x;\n    return height;\n}\nvec2[8] getNeighbs(vec2 p){\n    vec2 nw=vec2(-1.,-1.)+p;\n    vec2 n=vec2(0.,-1.)+p;\n    vec2 ne=vec2(1.,-1.)+p;\n    vec2 w=vec2(-1.,0.)+p;\n    vec2 e=vec2(1.,0.)+p;\n    vec2 sw=vec2(-1.,1.)+p;\n    vec2 s=vec2(0.,1.)+p;\n    vec2 se=vec2(1.,1.)+p;\n    return vec2[8](nw,n,ne,w,e,sw,s,se);\n}\nvec2 getLowestNeighb(in vec2 p){\n    vec2[8] neighbs=getNeighbs(p);\n    vec2 lowest=p;\n    for(int i=0;i<8;i++){\n        vec2 neighb=neighbs[i];\n        if(getLevel(neighb)<getLevel(lowest)){\n            lowest=neighb;\n        }   \n    }\n    return lowest;\n}\nfloat getInFlow(vec2 p){\n    float result=0.;\n    vec2[8] neighbs=getNeighbs(p);//(nw,n,ne,w,e,sw,s,se) NW=== (-1 , -1)\n    for(int i=0;i<8;i++){\n        vec2 neighb=neighbs[i];\n        vec4 neighbState=getState(neighb);\n   \t\tfloat flowMag=accumulatedFlowMag(neighbState);\n        if(flowMag>0.){\n        \tvec2 neighbOffset=neighb-p;\n        \tvec2 neighbFlowOffset=neighbState.zw/flowMag;\n            if(length(neighbOffset+neighbFlowOffset)<.000005){\n                result+=flowMag;\n            }\n        }\n    }\n    return result+RAINFALL;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{//x coord is topo height. y coord is water height.\n    vec2 pos=fragCoord;\n    float inflow=getInFlow(pos);\n    vec2 lowest=getLowestNeighb(pos);\n    float dif=getLevel(pos)-getLevel(lowest);//difference in heights\n    if(pos.x<5.||pos.y<5.||pos.x>iResolution.x-5.||pos.y>iResolution.y-5.){dif=10.;}//edges drain off a cliff.\n    float drainage=min(getW(pos),dif/2.);//drain all your water, \n    \t//or enough to level you with lowest, whichever is smaller\n    vec2 newAccumulatedFlow=lowest-pos;//offset vector pointing at drain target.\n    newAccumulatedFlow*=drainage;//points at the neighb to drain, non-zero components have magnitude equal to drainage.\n    fragColor=getState(pos);//out state same as in state\n    float erosion=EROSIONPOWER*pow(drainage,1./3.)*pow(dif,2./3.);//stream power law stuff\n    fragColor.x+=UPLIFT+-erosion;\n    fragColor.y+=inflow-drainage;//water level changes by +in -out.\n    fragColor.zw=newAccumulatedFlow;//overwrite last turns flow as it has been incorporated\n    if(iMouse.z>0.||iFrame<60){\n        fragColor=texture(iChannel3,pos/iResolution.xy).xyyy*vec4(1.,0.,0.,0.);\n        fragColor+=vec4(0.,.0,0.,.0);\n    }\n    if(pos.x<1.||pos.y<1.||pos.x>iResolution.x-1.||pos.y>iResolution.y-1.){fragColor.y=0.;fragColor.y-=.01;}\n}","name":"Buffer A","description":"","type":"buffer"}]}