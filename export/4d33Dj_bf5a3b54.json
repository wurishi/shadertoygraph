{"ver":"0.1","info":{"id":"4d33Dj","date":"1452100563","viewed":3813,"name":"A Popular Game","username":"phi16","description":"[b]It takes much time to compile codes, so please wait![/b]\n\nShadertoy is a good toy-making platform ;)\nRotate : Z/X, Move : Left/Right/Down, HardDrop:Up, Hold:Shift","likes":54,"published":1,"flags":48,"usePreview":1,"tags":["2d","game","tetris","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(texture(iChannel0,fragCoord/iResolution.xy));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int read(int p,int q){\n    /*\n    This is a historical code for preventing WebGL crash.\n    Thanks to many viewers, and technology improvements.\n    */\n    // return 0;\n    \n    return int(texture(iChannel0,(vec2(p,q)+0.5)/iResolution.xy).x*255.);\n}\nvoid writeF(int p,int q,int s,inout vec4 fragColor,in ivec2 fragC){\n    if(ivec2(p,q)==fragC)fragColor = vec4(float(s)/255.,0.,0,1);\n}\n#define write(p,q,s) writeF(p,q,s,fragColor,fragC)\n\nbool keyboard(int t){ // 0-6 <^>vZXS\n    float p = 0.;\n    if(t<4)p = float(t)+37.5;\n    if(t==4)p = 90.5;\n    if(t==5)p = 88.5;\n    if(t==6)p = 16.5;\n    return texture(iChannel1,vec2(p/256.,0)).x > 0.5;\n}\nvoid keyManage( inout vec4 fragColor, in ivec2 fragC ){\n    if(fragC.x < 7)write(fragC.x,0,keyboard(fragC.x)?read(fragC.x,0)+1:0);\n    /*\n\tfor(int i=0;i<7;i++){\n        int p = i, q = 0, s = keyboard(i)?read(i,0)+1:0;\n    \twrite(i,0,s);\n    }*/\n}\nbool key(int t,bool rep){\n    int r = read(t,0);\n    return r==1 || (rep && r>10);\n}\n\nint timer( inout vec4 fragColor, in ivec2 fragC ){\n    int t = read(8,0);\n    write(8,0,t==60?0:t+1);\n    return t;\n}\n//0:noCurrentPiece 1:falling 2:erasing 3:gameOver 4:wait for restart\n#define state() read(9,0)\n#define writeField(x,y,i) write(y,(x)+3,i);\nint field(int x,int y){//_#IOTSZLJ\n    if(x<0 || x>9)return 1;\n    if(y<0)return 0;\n    if(y>19)return 1;\n    return read(y,x+3);\n}\n// IOTSZLJ\n#define pieceType() read(0,1)\n#define pieceX() read(1,1)\n#define pieceY() read(2,1)\n#define pieceR() read(3,1)\nint maxi(int a,int b){\n    return a<b?b:a;\n}\nint pposXs(int t,int i){\n    if(t==0)return i-1;\n    else if(t==1)return (i==1||i==3)?0:1;\n    else{\n        if(i==0)return 0;\n        if(t<5)return i-2;\n        else if(t==5)return -((maxi(2,i)-2)*2-1);\n        else if(t==6)return (maxi(2,4-i)-2)*2-1;\n    }\n    return 0;\n}\nint pposYs(int t,int i){\n    if(t==0)return 0;\n    else if(t==1)return i<2?0:-1;\n    else{\n        if(i==0)return 0;\n        if(i==2)return t<5?-1:0;\n        return (t==5-(i+1)/2 || t==(i+1)/2+4)?-1:0;\n    }\n    return 0;\n}\nint pposX(int t,int i,int r){\n    if(t==0){\n        if(r==1)return 1;\n        else if(r==3)return 0;\n        else return pposXs(t,i);\n    }else if(t==1)return pposXs(t,i);\n    else{\n        if(r==0)return pposXs(t,i);\n        if(r==1)return -pposYs(t,i);\n        if(r==2)return -pposXs(t,i);\n        if(r==3)return pposYs(t,i);\n    }\n    return 0;\n}\nint pposY(int t,int i,int r){\n    if(t==0){\n        if(r==0)return 0;\n        else if(r==2)return 1;\n        else return pposXs(t,i)+1;\n    }else if(t==1)return pposYs(t,i);\n    else{\n        if(r==0)return pposYs(t,i);\n        if(r==1)return pposXs(t,i);\n        if(r==2)return -pposYs(t,i);\n        if(r==3)return -pposXs(t,i);\n    }\n    return 0;    \n}\nbool safe(int t,int x,int y,int r){\n    bool ret = true;\n    for(int i=0;i<4;i++){\n        if(field(x+pposX(t,i,r),y+pposY(t,i,r))!=0){\n            ret = false;\n            break;\n        }\n    }\n    return ret;\n}\nbool safeDef(int x,int y,int r){\n    int ru = r+pieceR()+4;\n    ru -= (ru/4)*4;\n    return safe(pieceType(),pieceX()+x,pieceY()+y,ru);\n}\nint sh(bool I,int curR,bool LR,int idx,int xy){\n    if(idx==0)return 0;\n    if(I){\n        int cr = curR>=2?curR-2:curR;\n        if(cr==1)LR=!LR;\n        int d=0;\n        if(xy==1){\n            if(idx>=3){\n                if(idx==3 && LR || idx==4 && !LR)d=1;\n                if(idx==3 && !LR || idx==4 && LR)d=-2;\n            }\n        }else{\n            idx = idx-1;\n            if(idx>=2)idx-=2;\n            if(idx==0 && LR)d=-2;\n            if(idx==0 && !LR)d=-1;\n            if(idx==1 && LR)d=1;\n            if(idx==1 && !LR)d=2;\n        }\n        if(cr==1 && LR)d*=-1;\n        if(curR>=2)d*=-1;\n    \treturn d;\n    }else{\n        int cr = curR>=2?curR-2:curR;\n        if(cr==1)LR=false;\n        int d=0;\n        if(xy==0 && idx!=3)d=-1;\n        if(xy==1){\n            if(idx==2)d=-1;\n            if(idx>=3)d=2;\n        }\n        if(LR && xy==0)d*=-1; \n        if(cr==1)d*=-1;\n        if(curR>=2 && xy==0)d*=-1;\n        return d;\n    }\n    return 0;\n}\nvoid shift(int i,int r,out int dx,out int dy){\n    dx = sh(pieceType()==0,pieceR(),r<0,i,0);\n    dy = sh(pieceType()==0,pieceR(),r<0,i,1);\n}\nbool movePiece(int x,int y,int r, inout vec4 fragColor, in ivec2 fragC ){\n    int p=x,q=y;\n    int shx=0,shy=0;\n    bool b=safeDef(p,q,0);\n    if(!b)p=0;\n    bool ret = false;\n    for(int i=0;i<5;i++){\n        shift(i,r,shx,shy);\n        if(safeDef(p+shx,q+shy,r)){\n            write(1,1,pieceX()+p+shx);\n            write(2,1,pieceY()+q+shy);\n            int ru = pieceR()+r+4;\n            ru -= ru/4*4;\n            write(3,1,ru);\n            ret = true;\n            break;\n        }\n        if(r==0)break;\n    }\n    return ret;\n}\nvoid setPiece( inout vec4 fragColor, in ivec2 fragC ){\n    int t = pieceType();\n    int xo = pieceX();\n    int yo = pieceY();\n    int ro = pieceR();\n    for(int i=0;i<4;i++){\n        int xu = xo + pposX(t,i,ro);\n        int yu = yo + pposY(t,i,ro);\n        writeField(xu,yu,t+2);\n    }\n    write(9,0,2);\n    write(5,1,0);//release hold\n}\n#define swap(p,q) b=p,p=q,q=b\nvoid perm(int r,out int a0,out int a1,out int a2,out int a3,out int a4,out int a5,out int a6){\n    a0=0,a1=1,a2=2,a3=3,a4=4,a5=5,a6=6;\n    int d,b;\n    d = r - r/7*7, r /= 7;\n    if(d==0)swap(a6,a0);\n    if(d==1)swap(a6,a1);\n    if(d==2)swap(a6,a2);\n    if(d==3)swap(a6,a3);\n    if(d==4)swap(a6,a4);\n    if(d==5)swap(a6,a5);\n    if(d==6)swap(a6,a6);\n    d = r - r/6*6, r /= 6;\n    if(d==0)swap(a5,a0);\n    if(d==1)swap(a5,a1);\n    if(d==2)swap(a5,a2);\n    if(d==3)swap(a5,a3);\n    if(d==4)swap(a5,a4);\n    if(d==5)swap(a5,a5);\n    d = r - r/5*5, r /= 5;\n    if(d==0)swap(a4,a0);\n    if(d==1)swap(a4,a1);\n    if(d==2)swap(a4,a2);\n    if(d==3)swap(a4,a3);\n    if(d==4)swap(a4,a4);\n    d = r - r/4*4, r /= 4;\n    if(d==0)swap(a3,a0);\n    if(d==1)swap(a3,a1);\n    if(d==2)swap(a3,a2);\n    if(d==3)swap(a3,a3);\n    d = r - r/3*3, r /= 3;\n    if(d==0)swap(a2,a0);\n    if(d==1)swap(a2,a1);\n    if(d==2)swap(a2,a2);\n    d = r - r/2*2, r /= 2;\n    if(d==0)swap(a1,a0);\n    if(d==1)swap(a1,a1);\n}\nint nextInit( inout vec4 fragColor, in ivec2 fragC ){\n    int r = int(mod(iTime*1000.,5040.));\n    int a1,a2,a3,a4,a5,a6,a7;\n    perm(r,a1,a2,a3,a4,a5,a6,a7);\n        write(0,2,a1);\n        write(1,2,a2);\n        write(2,2,a3);\n        write(3,2,a4);\n        write(4,2,a5);\n        write(5,2,a6);\n        write(6,2,a7);\n    r = int(mod(iTime*1000.+2000.,5040.));\n    perm(r,a1,a2,a3,a4,a5,a6,a7);\n        write(7,2,a1);\n        write(8,2,a2);\n        write(9,2,a3);\n        write(10,2,a4);\n        write(11,2,a5);\n        write(12,2,a6);\n        write(13,2,a7);\n    write(10,1,13);\n    return a7;\n}\nvoid genNext( inout vec4 fragColor, in ivec2 fragC ){\n    int r = int(mod(iTime*1000.,5040.));\n    int a1,a2,a3,a4,a5,a6,a7;\n    perm(r,a1,a2,a3,a4,a5,a6,a7);\n        write(0,2,a1);\n        write(1,2,a2);\n        write(2,2,a3);\n        write(3,2,a4);\n        write(4,2,a5);\n        write(5,2,a6);\n        write(6,2,a7);\n    if(7 <= fragC.x && fragC.x < 14 &&  fragC.y == 2)write(fragC.x,2,read(fragC.x-7,2));\n    /*\n\tfor(int i=0;i<7;i++){\n        write(7+i,2,read(i,2));\n    }*/\n    write(10,1,read(10,1)+7-1);\n}\nvoid consumeNext( inout vec4 fragColor, in ivec2 fragC ){\n    write(10,1,read(10,1)-1);\n}\nvoid endTimer( inout vec4 fragColor, in ivec2 fragC ){\n    write(8,0,0);\n}\nvoid generate( inout vec4 fragColor, in ivec2 fragC ){\n    int ti=0;\n    if(read(10,1)==0){\n        ti=nextInit(fragColor,fragC);\n    }else{\n        if(read(10,1)==7)genNext(fragColor,fragC);\n        else consumeNext(fragColor,fragC);\n        ti=read(read(10,1)-1,2);\n    }\n    write(0,1,ti);\n    write(1,1,4);\n    write(2,1,1);\n    write(3,1,0);\n    if(!safe(ti,4,1,0)){\n        write(9,0,3);\n        endTimer(fragColor,fragC);\n    }\n}\nvoid initPiece( inout vec4 fragColor, in ivec2 fragC ){\n    write(9,0,1);\n    write(8,0,1);\n    generate(fragColor,fragC);\n}\nvoid hold( inout vec4 fragColor, in ivec2 fragC ){\n    if(read(5,1)==1)return;\n    int ti = read(4,1)-1;\n    if(read(4,1)==0){\n        write(4,1,pieceType()+1);\n        write(5,1,1);\n        generate(fragColor,fragC);\n    }else if(safe(ti,4,1,0)){\n        write(0,1,ti);\n        write(1,1,4);\n        write(2,1,1);\n        write(3,1,0);\n        write(4,1,pieceType()+1);\n        write(5,1,1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y>13. || fragCoord.x>21.)discard;\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    ivec2 fragC = ivec2(fragCoord);\n    if(fragC.y==0)keyManage(fragColor,fragC);\n    int t = timer(fragColor,fragC);\n    if(state()==0)initPiece(fragColor,fragC);\n    else if(state()==1){\n        if(t==0){\n            if(!movePiece(0,1,0,fragColor,fragC)){\n                setPiece(fragColor,fragC);\n            }else write(8,0,1);\n        }else if(key(1,false)){\n            int i=1;\n            for(int j=0;j<20;j++){\n                if(!safeDef(0,i,0))break;\n                i++;\n            }\n            i--;\n            if(i>0)movePiece(0,i,0,fragColor,fragC);\n            endTimer(fragColor,fragC);\n        }else if(key(3,true)){\n            if(movePiece(0,1,0,fragColor,fragC)){\n            \twrite(8,0,1);\n            }\n        }else if(key(6,false)){\n            hold(fragColor,fragC);\n        }else{\n            bool ui=false;\n            int x=0,r=0;\n            if(key(0,true))ui=true,x-=1;\n            if(key(2,true))ui=true,x+=1;\n            if(key(4,false))ui=true,r-=1;\n            if(key(5,false))ui=true,r+=1;\n            if(ui)movePiece(x,0,r,fragColor,fragC);\n        }\n    }else if(state()==2){\n        int cur=19;\n        for(int i=19;i>-1;i--){\n            bool f = true;\n            for(int j=0;j<10;j++){\n                if(field(j,i)==0){\n                   f = false;\n     \t           break;\n                }\n            }\n            if(!f){\n                if(0 <= fragC.y-3 && fragC.y-3 < 10)writeField(fragC.y-3,cur,field(fragC.y-3,i));\n                /*\n                for(int j=0;j<10;j++){\n                    writeField(j,cur,field(j,i));\n                }*/\n                cur--;\n            }\n        }\n        if(0 <= fragC.y-3 && fragC.y-3 < 10 && 0 <= fragC.x && fragC.x <= cur)writeField(fragC.y-3,fragC.x,0);\n        /*for(int j=20;j>-1;j--){\n            if(j<=cur){\n                for(int i=0;i<10;i++){\n                \twriteField(i,j,0);\n            \t}\n            }\n        }*/\n        write(9,0,0);\n    }else if(state()==3){\n        if(t>40){\n            write(9,0,4);\n            return;\n        }\n        int d = 19-t/2;\n        if(0 <= fragC.y-3 && fragC.y-3 < 10 && field(fragC.y-3,d)!=0)writeField(fragC.y-3,d,1);\n        /*for(int i=0;i<10;i++){\n            if(field(i,d)!=0){\n                writeField(i,19-t/2,1);\n            }\n        }*/\n        int ti = pieceType();\n        for(int i=0;i<4;i++){\n            int xu = 4 + pposX(ti,i,0);\n            int yu = 1 + pposY(ti,i,0);\n            if(yu==d)writeField(xu,yu,1);\n        }\n    }else if(state()==4){\n        bool e = false;\n        for(int i=0;i<7;i++){\n            if(key(i,false)){\n                e=true;\n                break;\n            }\n        }\n        if(e){\n            fragColor=vec4(0);\n            if(fragC.x < 7)write(fragC.x,0,1);\n        }\n        /*for(int i=0;i<7;i++){\n            if(key(i,false)){\n                fragColor=vec4(0);\n                write(i,0,1);\n                return;\n            }\n        }*/\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float POW(float b,float e){\n    if(b<0.)return -pow(-b,e);\n    else return pow(b,e);\n}\nfloat noise( in vec3 x )//https://www.shadertoy.com/view/4sfGzS\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\nf = f*f*(3.0-2.0*f);\nvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\nvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\nreturn mix( rg.x, rg.y, f.z );\n}\n\nvec3 nrand3( vec2 co )//https://www.shadertoy.com/view/MslGWN\n{\nvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\nvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\nvec3 c = mix(a, b, 0.5);\nreturn c;\n}\n\nint read(int p,int q){\n    return int(texture(iChannel0,(vec2(p,q)+0.5)/iResolution.xy).x*255.);\n}\n//0:noCurrentPiece 1:falling 2:erasing 3:gameOver 4:wait for restart\n#define state() read(9,0)\nint field(int x,int y){//_#IOTSZLJ\n    if(x<0 || x>9)return 1;\n    if(y<0)return 0;\n    if(y>19)return 1;\n    return read(y,x+3);\n}\n#define pieceType() read(0,1)\n#define pieceX() read(1,1)\n#define pieceY() read(2,1)\n#define pieceR() read(3,1)\nint maxi(int a,int b){\n    return a<b?b:a;\n}\nint pposXs(int t,int i){\n    if(t==0)return i-1;\n    else if(t==1)return (i==1||i==3)?0:1;\nelse{\n    if(i==0)return 0;\n        if(t<5)return i-2;\n        else if(t==5)return -((maxi(2,i)-2)*2-1);\n        else if(t==6)return (maxi(2,4-i)-2)*2-1;\n    }\n    return 0;\n}\nint pposYs(int t,int i){\n    if(t==0)return 0;\n    else if(t==1)return i<2?0:-1;\n    else{\n        if(i==0)return 0;\n        if(i==2)return t<5?-1:0;\n        return (t==5-(i+1)/2 || t==(i+1)/2+4)?-1:0;\n    }\n    return 0;\n}\nint pposX(int t,int i,int r){\n    if(t==0){\n        if(r==1)return 1;\n        else if(r==3)return 0;\n        else return pposXs(t,i);\n    }else if(t==1)return pposXs(t,i);\n    else{\n        if(r==0)return pposXs(t,i);\n        if(r==1)return -pposYs(t,i);\n        if(r==2)return -pposXs(t,i);\n        if(r==3)return pposYs(t,i);\n    }\n    return 0;\n}\nint pposY(int t,int i,int r){\n    if(t==0){\n        if(r==0)return 0;\n        else if(r==2)return 1;\n        else return pposXs(t,i)+1;\n    }else if(t==1)return pposYs(t,i);\n    else{\n        if(r==0)return pposYs(t,i);\n        if(r==1)return pposXs(t,i);\n        if(r==2)return -pposYs(t,i);\n        if(r==3)return -pposXs(t,i);\n    }\n    return 0;\n}\nvec3 colorType(int t){//IOTSZLJ\n    if(t==1)return vec3(0.5);\n    if(t==2)return vec3(0,0.8,0.8);\n    if(t==3)return vec3(0.8,0.8,0);\n    if(t==4)return vec3(0.5,0,1);\n    if(t==5)return vec3(0,0.8,0);\n    if(t==6)return vec3(0.8,0,0);\n    if(t==7)return vec3(1,0.5,0);\n    if(t==8)return vec3(0.2,0.2,1);\n    return vec3(0,0,0);\n}\nvec4 coloring(int t,vec2 e){\n    vec3 color = colorType(t);\n    float d = max(abs(e.x),abs(e.y));\n    color += abs(-POW(d,4.)+0.5)-0.3;\n    if(t==1)e=-e;\n    if(d<0.9)color += max(POW(e.x/0.9,3.),POW(e.y/0.9,3.));\n    return vec4(color,1);\n}\nvoid drawField( inout vec4 fragColor, in vec2 uv){\n    vec2 p = uv*25.;\n    if(p.x<-6. || p.x>6. || p.y < 4.)return;\n    ivec2 pi = ivec2(floor(p))+ivec2(5,-4);\n    int t = 0;\n    int s = state();\n    if(s==1 || s==3){\n        int mt = pieceType();\n        int mx = pieceX();\n        int my = pieceY();\n        int mr = pieceR();\n        for(int i=0;i<4;i++){\n            if(mx+pposX(mt,i,mr)==pi.x && my+pposY(mt,i,mr)==pi.y){\n                t=mt+2;\n            }\n        }\n    }\n    int v = field(pi.x,pi.y);\n    if(t==0 || v==1)t = v;\n    bool fi = v != 0;\n    vec2 e = fract(p)*2.-1.;\n    if(t==0){\n        fragColor *= 0.7;\n        fragColor += POW(max(abs(e.x),abs(e.y)),3.)*0.1;\n    }else{\n        fragColor = coloring(t,e);\n        if(fi)fragColor *= 0.8;\n    }\n}\nvoid drawHold( inout vec4 fragColor, in vec2 uv){\n    vec2 p = uv*25.;\n    if(p.x<-11.5 || p.x>-6.5 || p.y < 4.5 || p.y > 9.5)return;\n    p -= vec2(-11,5);\n    vec2 fr = p;\n    int mt = read(4,1);\n    if(mt==1)p-=vec2(0,0.5);\n    if(mt>2)p-=vec2(0.5,0);\n    ivec2 pi = ivec2(floor(p));\n    int t = 0;\n    if(mt>0){\n        for(int i=0;i<4;i++){\n            if(1+pposX(mt-1,i,0)==pi.x && (mt<2?1:2)+pposY(mt-1,i,0)==pi.y){\n                t=mt+1;\n            }\n        }\n    }\n    vec2 e = fract(p)*2.-1.;\n    if(t!=0){\n        fragColor = coloring(t,e);\n    if(read(5,1)==1)fragColor *= 0.5;\n    }\n    p=fr;\n    p-=vec2(2,2);\n    float er = (max(abs(p.x),abs(p.y))-2.)*4.-1.;\n    if(er>-1.){\n    fragColor = vec4(0);\n        fragColor += POW(1.-er,2.)*0.3;\n    }\n}\n\nvoid drawNextMain( inout vec4 fragColor, in vec2 uv){\n    vec2 p = uv*25.;\n    if(p.x<-4. || p.x>4. || p.y < 0. || p.y > 4.)return;\n    p -= vec2(-2,0);\n    int mt = read(read(10,1)-1,2);\n    if(mt==0)p-=vec2(0,0.5);\n    if(mt>1)p-=vec2(0.5,0);\n    p = (p-vec2(2,2))/1.2+vec2(2,2);\n    ivec2 pi = ivec2(floor(p));\n    int t = 0;\n    for(int i=0;i<4;i++){\n        if(1+pposX(mt,i,0)==pi.x && (mt<1?1:2)+pposY(mt,i,0)==pi.y){\n            t=mt+2;\n        }\n    }\n    vec2 e = fract(p)*2.-1.;\n    \n    if(t!=0){\n        fragColor = coloring(t,e);\n    }\n}\nvoid drawNext( inout vec4 fragColor, in vec2 uv){\n    vec2 p = uv*25.;\n    int c = int((p.y-5.)/5.);\n    p.y -= float(c)*5.;\n    if(p.x<7. || p.x>11. || p.y < 5. || p.y > 9.)return;\n    p -= vec2(7,5);\n    int mt = read(read(10,1)-2-c,2);\n    if(mt==0)p-=vec2(0,0.5);\n    if(mt>1)p-=vec2(0.5,0);\n    ivec2 pi = ivec2(floor(p));\n    int t = 0;\n    for(int i=0;i<4;i++){\n        if(1+pposX(mt,i,0)==pi.x && (mt<1?1:2)+pposY(mt,i,0)==pi.y){\n            t=mt+2;\n        }\n    }\n    vec2 e = fract(p)*2.-1.;\n    if(t!=0){\n        fragColor = coloring(t,e);\n    }\n}\nvec3 bg(vec2 uv){\n    vec3 v = normalize(vec3(1.5,1.-uv.y*2.,uv.x*2.));\n    float r=-iTime/16.;\n    v.xz *= mat2(cos(r),sin(r),-sin(r),cos(r));\n    v.y*=-1.0;\n    vec3 d=vec3(0,0.4,1.0);\n    d*=pow(max(v.y+0.7,0.0),3.0)+0.5;\n    d.y-=0.4*max(-(v.y-0.5),0.0);\n    \n    vec2 seed = v.zy * 0.6;//https://www.shadertoy.com/view/MslGWN\nseed = floor(seed * iResolution.x);\nvec3 rnd = nrand3( seed );\nvec4 starcolor = vec4(pow(rnd.y,40.0));\n    d += pow(starcolor.x*5.0*(0.8-v.y),2.0);\n    return d/3.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n    uv.x /= 2.;\n    uv.y = 1. - fragCoord.y / iResolution.y;\n    fragColor = vec4(0);\n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n    fragColor += texture(iChannel1,(fragCoord+vec2(i,j))/iResolution.xy);\n        }\n    }\n    fragColor/=10.;\n    fragColor += vec4(bg(uv),0)/10.;\n\tdrawField(fragColor,uv);\n    drawHold(fragColor,uv);\n    drawNextMain(fragColor,uv);\n    drawNext(fragColor,uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}