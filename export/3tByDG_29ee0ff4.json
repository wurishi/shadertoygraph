{"ver":"0.1","info":{"id":"3tByDG","date":"1595187861","viewed":86,"name":"3D ray marching test with ocean","username":"HalbFettKaese","description":"Just my other ripple project plugged into a 3D shader.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","perlin","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\n#define FAR 50.\n\n// Ripples\n\nint rand3(vec3 uv, int seed) {\n\treturn int(4769.*fract(cos(floor(uv.y-5234.)*755.)*245.* sin(floor(uv.x-534.)*531.)*643.)*sin(floor(uv.z-53345.)*765.)*139.);\n}\n\nfloat fade(float t) {\n\treturn t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat lerp(float a, float b, float t) {\n\treturn a + fade(t) * (b - a);\n}\n\nvec3 randVec3(vec3 uv, int seed) {\n\tint a = rand3(uv, seed)*5237;\n    int p1 = (a & 1) * 2 - 1;\n    int p2 = (a & 2) - 1;\n    int p3 = (a & 4) / 2 - 1;\n    return vec3(p1, p2, p3);\n}\n\nfloat perlin3D(vec3 uv, int seed) {\n\tvec3 fuv = fract(uv);\n    float c1 = dot(fuv - vec3(0, 0, 0), randVec3(floor(uv) + vec3(0, 0, 0), seed));\n    float c2 = dot(fuv - vec3(0, 0, 1), randVec3(floor(uv) + vec3(0, 0, 1), seed));\n    float c3 = dot(fuv - vec3(0, 1, 0), randVec3(floor(uv) + vec3(0, 1, 0), seed));\n    float c4 = dot(fuv - vec3(0, 1, 1), randVec3(floor(uv) + vec3(0, 1, 1), seed));\n    float c5 = dot(fuv - vec3(1, 0, 0), randVec3(floor(uv) + vec3(1, 0, 0), seed));\n    float c6 = dot(fuv - vec3(1, 0, 1), randVec3(floor(uv) + vec3(1, 0, 1), seed));\n    float c7 = dot(fuv - vec3(1, 1, 0), randVec3(floor(uv) + vec3(1, 1, 0), seed));\n    float c8 = dot(fuv - vec3(1, 1, 1), randVec3(floor(uv) + vec3(1, 1, 1), seed));\n    return ( \n            lerp(\n        \t\tlerp(\n            \t\tlerp(c1, c2, fuv.z), \n                    lerp(c3, c4, fuv.z), \n                    fuv.y), \n                lerp(\n                    lerp(c5, c6, fuv.z), \n                    lerp(c7, c8, fuv.z), \n                    fuv.y), \n                fuv.x)\n           );\n}\n\nfloat layeredPerlin3D(vec3 uv, int layerNumber, float fade, float frequencyShift, int seed) {\n    float weight = 1.;\n    float frequency = 1.;\n    float result = 0.;\n    int layer_seed = seed;\n    float final_range = 0.;\n    for (int i = 0; i < layerNumber; i++) {\n        result += perlin3D(uv/frequency, layer_seed) * fade;\n        final_range += fade;\n        weight *= fade;\n        frequency *= frequencyShift;\n    \tlayer_seed = rand3(uv, layer_seed);\n    }\n    return result/final_range;\n}\n\n\n// 3D rendering\n\nfloat Cube(vec3 p) {\n    float d1 = abs(p.x) - .5;\n    float d2 = abs(p.y) - .5;\n    float d3 = abs(p.z) - .5;\n    return max(d1, max(d2, d3));\n}\n\nfloat Sphere(vec3 p) {\n\treturn length(p) - 1.;\n}\n\nfloat Water(vec3 p) {\n    float d = length(p.xz);\n    float perlinAmp = 0.55;\n    float sinAmp = .25;\n    float water = .7 + p.y + sinAmp+perlinAmp;\n    if (p.y < .0) {\n        water -= sinAmp;\n\t\twater += sinAmp*sin(.5*(p.x + p.z)+2.*iTime)*sin(.13*(p.x + .14*p.z) + .1*iTime);\n        water -= perlinAmp;\n        water += perlinAmp*layeredPerlin3D(vec3(p.x, iTime, p.z), 4, 2., 2., 4);\n    }\n   \t\n\treturn water*.1;\n}\n\nfloat getDist(vec3 p) {\n    float water = Water(p);\n    float cube = Cube(p - vec3(2.5, -0.5, 3.75));\n    float sphere = Sphere(p - vec3(2., 0, 0));\n    return min(max(water, -cube), sphere);\n}\n\nvec3 getNormal(vec3 p, float s) {\n\tfloat d = getDist(p);\n    vec2 v01 = vec2(0, 1);\n    return normalize(\n        vec3(\n        \tgetDist(p + v01.yxx*s),\n        \tgetDist(p + v01.xyx*s),\n        \tgetDist(p + v01.xxy*s))\n        );\n    \n}\n\nvec2 march(vec3 vo, vec3 vd) {\n\tfloat s = 0.;\n    int i;\n    for (i = 0; i < 500 && s < FAR; i++) {\n    \tvec3 p = vo + s * vd;\n        float d = getDist(p);\n        if (d <= 0.) break;\n        s += d;\n    }\n    \n    return vec2(s, i);\n}\n\nvec3 drawSky(vec3 dir, vec3 light_source) {\n\tfloat skyPos = dot(dir, light_source);\n \tvec3 sky_top = vec3(0., .7, 1.);\n    vec3 sky_bottom = vec3(0., 0.5, 1.);\n    \n    vec3 col = mix(sky_bottom, sky_top, smoothstep(-1., 1., skyPos));\n    \n    vec4 sun = mix(vec4(0), vec4(10), smoothstep(.980, .995, skyPos));\n    \n    col += sun.rgb;\n    return col;\n}\n\nfloat refr(float angle, float n1, float n2) {\n    float a = n1*cos(angle);\n    float b = n2 * cos(asin(n1*sin(angle)/n2));\n\treturn pow((a-b)/(a+b), 2.);\n}\n\nvec3 getColorInDir(vec3 vo, vec3 vd) {\n    \n    vec3 col = vec3(0);\n    \n    //col.rg += uv.xy;\n    \n    vec3 light_source = normalize(vec3(.5, 0.5, .75));\n                                                \n    vec2 mResult = march(vo, vd);\n    float depth = mResult.x;\n    \n    vec3 p = vo + vd*depth;\n\tvec3 n = getNormal(p, .01);\n    \n    if (getDist(p) <= .01) { \n        col += dot(n/2.+.5, light_source)/3.;\n    \n    \tvec3 water_color = vec3(.5, .75, 1);\n    \t\t\n    \tvec3 foam_color = vec3(smoothstep(-0.8, -0.5, p.y));\n        water_color = mix(water_color, foam_color, smoothstep(.9, 1.3, dot(n, vec3(0, 1, 0))));\n        col *= water_color;\n        \n        float hit_angle = acos(length(vd*n));\n            \n        vec3 out_dir = normalize(vd-2.*(n*vd)*n);\n            \n        float refr = refr(hit_angle, 1., 1.3325);\n           \n        if (refr > .0) {\n        \tcol += mix(vec3(0), drawSky(out_dir, light_source), refr);\n        }\n    } else {\n        col = drawSky(vd, light_source);\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec2 M = iMouse.xy/iResolution.xy;\n    \n    vec2 rot = M * 2. * PI;\n    \n    rot.y /= 2.;\n    \n    vec3 vo = vec3(0, 2.5, 0);\n    \n    vec3 lookat = vo - 2.*normalize(vec3(sin(rot.x), 0, cos(rot.x))*sin(rot.y) + \n                                 vec3(0, cos(rot.y), 0));\n    \n    //vo *= rot(vec3(0,1,0), 2.*PI*M.x);\n    //vo *= rot(vec3(1, 0, 0), PI*M.y);\n    \n    float zoom = .6;\n    \n    vec3 f = normalize(lookat-vo),\n        r = normalize(cross(f, vec3(0, -1, 0))),\n        u = cross(f, r);\n    \n    vec3 vd = normalize(f*zoom + r * uv.x + u * uv.y);\n\n    vec3 col = getColorInDir(vo, vd);\n\t\n    //col = texture(iChannel0, uv + vec2(.5, .5)).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}