{"ver":"0.1","info":{"id":"lfcXDl","date":"1714598292","viewed":186,"name":"Gaussian blur using inverse CDF","username":"fishy","description":"Inspired by [url]https://www.shadertoy.com/view/MlVSzw[/url]","likes":8,"published":3,"flags":32,"usePreview":0,"tags":["agsagf"],"hasliked":0,"parentid":"mttBR8","parentname":"Gaussian blur using inverse CDF2"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by stubbe's \"Single sample gaussian noise\": https://www.shadertoy.com/view/MlVSzw\n// Uses atanh(x) * 0.825, a much more crude approximation\n// but it still works well and is easier to type\n\n// The graph shows the luminance of the pixels at the red line, which mouse Y controls\n// Mouse X controls the strength of the blur\n// Turn off dithering in Common\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = pow(texture(iChannel0, uv /* + 0.5 / iResolution.xy */), vec4(0.4545));\n    \n    float sampleY = abs(iMouse.w/iResolution.y);\n    if (iMouse.w == 0.0)\n    {\n        sampleY = 0.5;\n    }\n    \n    vec3 c = texture(iChannel0, vec2(uv.x, sampleY)).rgb;\n    float v = abs(uv.y-dot(c, vec3(0.2126, 0.7152, 0.0722)));\n    v = smoothstep(1.0, -0.0, v/fwidth(v));\n    fragColor.rgb -= vec3(v);\n    fragColor.r += smoothstep(0.002, 0.001, abs(uv.y - sampleY));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gamma corrected image\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(2.2));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Horizontal blur pass\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = iMouse.z > 0.0? iMouse.x/iResolution.x * 0.05 : tanh(sin(iTime * 1.5) * 3.0) * 0.01 + 0.01;   \n    \n    fragColor = blur(iChannel0, 0.0, uv, SAMPLES, vec2(s, 0.0)*vec2(1.0, iResolution.x/iResolution.y), dither(fragCoord, 0));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* --- CONTROLS --- */\n\n// Number of samples to use\n#define SAMPLES 16.0\n\n// Dithering hids some undersampling artifacts\n// but introduces noise (if it's blue noise it's\n// not super noticable, especially if used in\n// combination with TAA or a slight blur to hide the noise)\n#define DITHER\n\n// Uncomment to use a box blur, for comparison\n#define USE_GAUSSIAN\n\n/* --- OTHER THINGS --- */\n\n#define dither(fc, i) texelFetch(iChannel1, ivec2(fc) % textureSize(iChannel1, 0), 0)[i]\n\n// Inverse Gaussian CDF approximation\nfloat inv(float x)\n{\n    // It's good enough\n    return atanh(x)*0.825;\n}\n\n// 1-dimensional blur\nvec4 blur(sampler2D tex, float lod, vec2 uv, float samples, vec2 dir, float offset)\n{\n    vec4 sum = vec4(0);\n    // No need to track the total sum of the weights,\n    // since all the samples are equally weighted\n    for(float i = 0.0; i < samples; i++)\n    {\n        vec2 o = \n#ifdef USE_GAUSSIAN\n        inv  \n#endif\n        (((i\n#ifdef DITHER\n        + offset\n#endif\n        ) / samples) * 2.0 - 1.0)*dir;\n        vec4 s = textureLod(tex, clamp(uv + o, vec2(0), vec2(1)), lod); \n        sum += s;\n    }\n    return sum / samples;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Vertical blur pass\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = iMouse.z > 0.0? iMouse.x/iResolution.x * 0.05 : tanh(sin(iTime * 1.5) * 3.0) * 0.01 + 0.01;\n    \n    fragColor = blur(iChannel0, 0.0, uv, SAMPLES, vec2(0.0, s)*vec2(1.0, iResolution.x/iResolution.y), dither(fragCoord, 1));\n}","name":"Buffer C","description":"","type":"buffer"}]}