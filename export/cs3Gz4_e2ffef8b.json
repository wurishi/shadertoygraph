{"ver":"0.1","info":{"id":"cs3Gz4","date":"1677015355","viewed":167,"name":"Glowing Menger Sponge","username":"chickenlegs","description":"The following is a Menger Sponge rendered with ray marching. The basic shape was achieved after a bit of tweaking and experimentation.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","sdf","menger"],"hasliked":0,"parentid":"DscGRn","parentname":"Raymarch 18 Playing around"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Defines for the ray marcher\n#define MAX_STEPS 100.\n#define MAX_DIS 100.\n#define HIT_EPS 0.00001\n#define SLOPE_EPS 0.0001\n\n// Defines for shader settings\n#define DETAIL_ITER 4// How detailed the Menger Sponge is\n#define MAIN_COL vec3(1,.7,.2) // Main color of the shape\n\nstruct Hit {\n    float dis;\n    vec3 albedo;\n};\n\nHit uHit(Hit h1, Hit h2) {\n    if (h1.dis < h2.dis) return h1; else return h2;\n}\n\nHit iHit(Hit h1, Hit h2) {\n    if (h1.dis > h2.dis) return h1; else return h2;\n}\n\nHit dHit(Hit h1, Hit h2) {\n    if (h1.dis > -h2.dis) return h1; else return Hit(-h2.dis, h2.albedo);\n}\n\nstruct March {\n    Hit hit;\n    float disCovered;\n    float minDis;\n    int steps;\n    bool hasHit;\n};\n\nMarch initMarch()\n{\n    Hit initHit = Hit(HIT_EPS, vec3(0));\n    return March(initHit, 0., 1e20, 0, false);\n}\n\nfloat SDFbox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SDFmengerSponge(vec3 pos, float os) {\n    float b = SDFbox(pos, vec3(os, os, os));\n    float s = os/3.;\n\n    float c = os/3.;\n    vec3 pmod;\n\n    for (int i = 0; i < DETAIL_ITER; i++) {\n        s /= 3.;\n        pmod = mod(pos + c, c * 2.) - c;\n        b = max(b, -SDFbox(pmod, vec3(os, s, s)));\n        b = max(b, -SDFbox(pmod, vec3(s, os, s)));\n        b = max(b, -SDFbox(pmod, vec3(s, s, os)));\n        c /= 3.;\n    }\n\n    s = os / 3.;\n    os += 1.;\n\n    b = max(b, -SDFbox(pos, vec3(os, s, s)));\n    b = max(b, -SDFbox(pos, vec3(s, os, s)));\n    b = max(b, -SDFbox(pos, vec3(s, s, os)));\n\n    return b;\n}\n\nHit getHit(vec3 pos) {\n    return Hit(SDFmengerSponge(pos, 1.), vec3(MAIN_COL));\n}\n\nMarch RayMarch(vec3 pos, vec3 dir) {\n    // inits\n    March marched = initMarch();\n    vec3 currpos = pos;\n    float disCovered = 0.;\n    \n    // marching\n    for (int i = 0; i < int(MAX_STEPS); i++) {\n        currpos = pos + dir*disCovered;\n\n        Hit currHit = getHit(currpos);\n        \n        marched.hasHit = abs(currHit.dis) < HIT_EPS;\n        marched.hit = currHit;\n        disCovered += currHit.dis;\n        marched.disCovered += currHit.dis;\n        marched.minDis = min(marched.minDis, currHit.dis);\n        marched.steps++;\n\n        if (marched.hasHit || marched.disCovered > MAX_DIS) break;\n    }\n    \n    return marched;\n}\n\n// From https://iquilezles.org/articles/rmshadows/\nfloat LightMarch(vec3 pos, vec3 dir, vec3 lpos, float k) {\n    // inits\n    float lf = 1.; // lit factor\n    vec3 currpos = pos;\n    float posTOlpos = distance(pos, lpos);\n    \n    float preDis;\n    float currDis;\n    float currDis2;\n    \n    // marching\n    for (float disCovered = 0.; disCovered < MAX_DIS;) {\n        if (disCovered > posTOlpos) break;\n        \n        currpos = pos + dir*disCovered;\n        currDis = getHit(currpos).dis;\n        if (currDis < HIT_EPS) return 0.;\n        \n        currDis2 = currDis*currDis;\n        \n        float y = currDis2/(2.0*preDis);\n        float d = sqrt(currDis2-y*y);\n        \n        lf = min(lf, k*d/max(0.0,disCovered-y));\n        //lf = min(lf, k*currDis/disCovered);\n        preDis = currDis;\n        disCovered += currDis;\n    }\n    return lf;\n}\n\n// from https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 pos)\n{\n    vec3 n = vec3(0.0);\n    for(int i=0; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getHit(pos+e*SLOPE_EPS).dis;\n    }\n    return normalize(n);\n}\n\nvec3 getPixel(vec3 cpos, vec3 cdir, vec3 lpos, vec3 lcol) {\n    // March\n    March m = RayMarch(cpos, cdir);\n\n    // Hit position\n    vec3 hpos = cpos + cdir*m.disCovered;\n        \n    // Normal\n    vec3 n = getNormal(hpos);\n        \n    //// Ambient Occlusion\n    float Apower = 0.25;\n    float AO = 0.;\n        \n    float e = 0.1;\n    float weight = 0.5;\n    for (int i = 1; i <= DETAIL_ITER; ++i) // https://www.shadertoy.com/view/lltBR4\n    {\n        float d = e * float(i);\n        AO += weight * (1.0 - (d - getHit(hpos + d * n).dis));\n            \n        weight *= 0.5;\n    }\n        \n    AO *= Apower;\n        \n    // Light dir\n    vec3 l = normalize(lpos-hpos);\n        \n    //// Diffuse\n    float Dpower = 0.5;\n    float D = clamp(dot(n,l), 0., 1.)*Dpower;\n        \n    //// Specular\n    float Spower = 0.1;\n    float Shardness = 8.;\n    float S = pow(clamp(dot(n,l), 0., 1.), Shardness)*Spower;\n        \n    // Soft Shadows\n    float shadow = LightMarch(hpos+n*HIT_EPS*5., l, lpos, 16.);\n    \n    // Glow\n    float glow = float(m.steps)/float(MAX_STEPS);\n    vec3 glowCol = vec3(1,0.5,0);\n    vec3 glowRes = glow*glowCol;\n    \n    // Light final color\n    vec3 lfinal = m.hit.albedo*lcol*(AO + D*shadow + S);\n\n    if (m.hasHit) return glowRes + lfinal; \n    return glowRes;\n}\n\nmat3 lookAt(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Setting up view port\n    float zoom = 1.;\n    vec2 zoomCenter = vec2(0., 0.);\n    float viewPortCenter = 0.5;\n    float ratio = iResolution.y/iResolution.x;\n    \n    // Establishing screen xy values\n    vec2 xy = (uv - viewPortCenter) * zoom + zoomCenter;\n    xy = vec2(xy.x, xy.y*ratio);\n    \n    // Establishing mouse xy values\n    mouse = (mouse - viewPortCenter) * zoom + zoomCenter;\n    mouse.y *= ratio;\n    \n    // Camera init\n    float cdis = 6.;\n    vec3 cpos;\n    \n    if (sign(iMouse.z) == 1.) \n        cpos = vec3(sin(mouse.x*10.)*cdis, mouse.y*cdis*4., cos(mouse.x*10.)*cdis);\n    else \n        cpos = vec3(sin(iTime/5.)*cdis, 2., cos(iTime/5.)*cdis);\n    \n    vec3 cup = vec3(0,1,0);\n    vec3 ctar = vec3(0,0,0);\n    vec3 cdir = normalize(vec3(xy,1));\n    \n    vec3 cwdir = lookAt(cpos, ctar, cup)*cdir;\n    \n    // Light init\n    vec3 lpos = vec3(10);\n    vec3 lcol = vec3(1);\n    \n    // Col init\n    vec3 col = vec3(0);\n    \n    col = getPixel(cpos, cwdir, lpos, lcol);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}