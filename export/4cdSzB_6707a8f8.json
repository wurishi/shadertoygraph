{"ver":"0.1","info":{"id":"4cdSzB","date":"1714083658","viewed":111,"name":"Numerical Penumbra doodle","username":"chronos","description":" A 'brute force' numerical 2D visibility / soft shadow calculation.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["simple","shadow","doodle","penumbra","soft","nmerical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Numerical Penumbra Doodle by chronos\n    --------------------------------------------\n    \n    A 'brute force' numerical 2D visibility calculation.\n    Area light source to generate soft shadow and a single occluder.\n    Assumes the shapes don't overlap.\n    Not monte-carlo, just regular uniform sampling.\n    No accumulation, just a lot of samples :)\n    \n    true sRGB makes a notable difference here (on my screen at least).\n    \n\n*/\n\nconst float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 mouse = ( 2.*iMouse.xy - iResolution.xy ) / iResolution.y;\n\n    float ps = 2. / iResolution.y;\n\n    if(length(iMouse.xy) < 10.) mouse = vec2(-1, 0);\n\n    vec3 color = vec3(0);\n\n    vec2 ro = uv;\n    vec2 rd = vec2(0);\n    \n    vec2 light_pos = mouse;\n    vec2 occluder_pos = vec2(0.75 + .25 * sin(iTime),0);\n    \n    float light_radius = 0.5 + 0.25 * cos(iTime);\n    \n    float occluder_radius = 0.25;\n    \n    float num_samples = 1000.;\n    \n    for(int i = 0; i < int(num_samples); i++)\n    {\n        float angle = 2. *  PI * (float(i) / num_samples);\n        \n        rd = vec2(cos(angle), sin(angle));\n\n        // Project light center onto ray:\n\n        float light_scalar_proj = dot(light_pos - ro, rd);\n        vec2 proj_light_pos = light_scalar_proj * rd + ro;\n\n        float occluder_scalar_proj = dot(occluder_pos - ro, rd);\n        vec2 proj_occluder_pos = occluder_scalar_proj * rd + ro;\n\n        // Detect light and occluder hit\n        // Branched version in comment under main()\n        float contribution = \n            max(\n                max(\n                    step(occluder_scalar_proj, 0.),\n                    step(light_scalar_proj, occluder_scalar_proj)), \n                    step(occluder_radius, distance(proj_occluder_pos, occluder_pos)\n                )\n            );\n\n        contribution *= \n            max(\n                step(0., light_scalar_proj) * step(distance(proj_light_pos, light_pos), light_radius), \n                smoothstep(light_radius+ps, light_radius-ps, distance(ro, light_pos))\n            );\n\n        color += contribution;\n    }\n    \n    color /= num_samples;\n    \n    // Draw occluder shape\n    color = mix(color, vec3(0.5), smoothstep(occluder_radius+ps, occluder_radius-ps, distance(uv, occluder_pos)));\n\n    #if 0\n    color = tanh(color);\n    #endif\n    \n    #if 1\n    color = sRGBencode(color); \n    #else\n    color = pow(color, vec3(1./2.2));\n    #endif\n    \n    #if 1\n    color += 1./255. * (-1. + 2.  * texture(iChannel0, fragCoord/1024.)[iFrame%4]);\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n/*\n\nif(0. <= light_scalar_proj && distance(proj_light_pos, light_pos) <= light_radius || distance(ro, light_pos) < light_radius)\n{\n    if(occluder_scalar_proj < 0. || light_scalar_proj < occluder_scalar_proj || occluder_radius < distance(proj_occluder_pos, occluder_pos))\n        color += 1.;\n}        \n*/\n","name":"Image","description":"","type":"image"}]}