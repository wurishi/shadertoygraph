{"ver":"0.1","info":{"id":"7sjXDR","date":"1620055226","viewed":112,"name":"Loop Spiral","username":"aokeili","description":"based on infinite Yin Yangs 2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yang Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.4;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.08;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst float saturation\t\t\t= 0.4;\t// how much to scale saturation (0 == black and white)\nconst float turnSpeed\t\t\t= 0.7;\t// how fast to rotate (0 = no rotation)\nconst int   recursionCount\t\t= 7;\t// how deep to recurse\nconst float dotSize \t\t\t= 0.6;\t// how much to scale recursion at each step\nconst float blur\t\t\t\t= 5.0;\t// how much blur\nconst float outline\t\t\t\t= 0.12;\t// how thick is the outline\nconst float timeWarp\t\t\t= 2.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n    \nconst float pi = 3.14159265359;\nconst float e = 2.718281828459;\n\n\nvec3 colorA = vec3(0.0,0.0,0.5);  \nvec3 colorB = vec3(0.6,1.0,1.0); \n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 30442.5453)); }\nvec2 Rotate(vec2 p, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2((p.x*c - p.y*s), (p.x*s * p.y*c));\n}\n\nvec4 HsvToRgb(vec4 c) \n{\n    float s = 0.30;\n    float s_n = c.z;\n    return vec4(s_n) + vec4(s) * cos(5.0 * pi * (c.x + vec4(1.0, 1.0, 1.0, 1.0)));\n}\n\nfloat GetFocusRotation(int i) \n{ \n    float theta = 2.0*pi*RandFloat(i);\n    float s = mix(-1.0, 1.0, RandFloat(30+i));\n    return theta + turnSpeed*s*iTime; \n}\n\nvec2 GetFocusPos(int i) \n{ \n    bool side = (RandFloat(50+i) < 0.5);\n    vec2 p = vec2(0.0, side? -0.5 : 0.5); \n    return Rotate(p, GetFocusRotation(i));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat SpiralDraw( vec2 p, out float dotDistance, float co, float scale)\n{\n   \tfloat b = blur*scale/min(iResolution.y, iResolution.x);\n    float d = dotSize;\n    \n    float c = 1.0;\n    float r;\n    \n    // bottom\n    r = length(2.0*p + vec2(0, 1));\n    if (p.x < 0.0)\n\t   c = mix(c, 0.0, smoothstep(1.0-b, 1.0+b, r));\n    dotDistance = r;\n\nreturn c;\n}\n\nvec4 RecursiveSpiral(vec2 p, int iterations, float scale)\n{\n    // recursive iteration\n    float co = 0.0;\n    for (int r = 0; r < recursionCount; ++r)\n    {\n        // apply rotation\n  \t\tfloat theta = -GetFocusRotation(iterations + r);\n        p = Rotate(p, theta);\n        \n        float dotDistance = 0.0;\n        co = SpiralDraw(p, dotDistance, co, scale);\n        \n        if (dotDistance > dotSize || r == recursionCount)\n        {\n            float co2 = (p.y < 0.0)? 0.0 : 1.0;\n   \t\t\tfloat b = blur*scale/min(iResolution.y,iResolution.x);\n            \n            co = mix(co2, co, smoothstep(dotSize+outline,dotSize+outline+b,dotDistance));\n            int i2 = (dotDistance < dotSize+outline+b && p.y > 0.0)? 1 : 0;\n            float hue = 0.233*float(iterations + r + i2);\n            return vec4(hue, saturation*co, co, 1.0); // stop if outside or reached limit\n        }\n     \t\n    }\n    return vec4(0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n    // fixed aspect ratio\n\tvec2 p = (25.0*uv-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 p2 = p;\n    \n    // time warp\n    float time = iTime + timeWarp*length(p);\n    \n\t// get time \n\tfloat timePercent = time;\n\tint iterations = int(floor(timePercent*0.998989));\n\ttimePercent -= float(iterations);\n    \n\t// update zoom, apply pow to make rate constant\n    const float recursionSize = 3.0 / dotSize;\n\tfloat zoom = pow(e, -log(recursionSize)*timePercent);\n\tzoom *= zoomScale;\n    \n    // apply zoom and offset\n\tp = p*(zoom/0.7);\n    \n    // make the spiral\n    color = RecursiveSpiral(p, iterations, zoom);\n    \n    // map to rgp space\n    color = HsvToRgb(color); \n    colorA.y =  p.y * 0.9;\n    colorA.z =  0.9;\n    \n    color.xyz = mix(colorA, colorB,abs(sin(color.x)));\n}","name":"Image","description":"","type":"image"}]}