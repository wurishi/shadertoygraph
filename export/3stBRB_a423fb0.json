{"ver":"0.1","info":{"id":"3stBRB","date":"1606196836","viewed":257,"name":"atom simulator","username":"romeosoft","description":"An atom simulator!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["atom","atom3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nfloat a0 = 5.1;\nint  n = 5;\nint  l = 2;\nint  m = 1;\nfloat A = 0.;\nfloat Y0 = 0.;\n\nfloat JC(int x)\n{\n    float v = 1.;\n    for (int i = 1; i <= x; i++)\n    {\n        v *= float(i);\n    }\n    return v;\n}\nint powN1(int n)\n{\n    return n % 2 == 0 ? 1 : -1;\n}\nfloat Cmn(int n, int m)\n{\n    return JC(n) / (JC(m) * JC(n - m));\n}\nfloat laguerreL(int n, int m, float x)\n{\n    float sum = 0.;\n    for (int k = 0; k <= n; k++)\n    {\n        sum += float(powN1(k))* Cmn(n + m, n - k)* pow(x, float(k)) / JC(k);\n    }\n    return sum;\n}\nfloat PML(float m, float l, float x)\n{\n    float A1 = pow(1. - x * x, m / 2.);\n    float sum = 0.;\n    int kl = int((l - m) / 2.);\n    for (int k = 0; k <= kl; k++)\n    {\n        float jk = JC(k);\n        float jk2 = JC(int(l) - k);\n        float jk3 = JC(int(l) - 2 * k - int(m));\n        float B = pow(2., l) * jk * jk2 * jk3;\n\n        float E = pow(x, l - 2. * float(k) - m);\n        sum += (float(powN1(k)) * JC(2 * int(l) - 2 * k) / B) * E;\n    }\n    return A1 * sum;\n}\n\nfloat calcR(float r)\n{\n    float B = pow(2. * r / (float(n) * a0), float(l));\n    float C = laguerreL(n - l - 1, 2 * l + 1, 2. * r / (float(n) * a0));\n    float E = exp(-(r / (float(n) * a0)));\n    return A * B * C * E;\n}\nfloat calcY(float cosang)\n{\n    float pml = PML(float(m), float(l), \n                    abs(cosang)\n                   ); \n    float Yml = Y0 * pml;\n    return pml * Yml;\n}\nvec2 calcF(float fai)\n{\n    return vec2(cos(float(m) * fai), sin(float(m) * fai));\n}\nbool mapcor(vec3 p, out float fcolor)\n{\n\tfloat r = length(p);\n\tvec3 v = p / r;\n\tvec2 xz = normalize(v.xz);\n\tfloat R = calcR(r);\n\n\tfloat Y = calcY(v.y / length(v));\n\tfloat fai = atan(-xz.y, xz.x);\n    vec2 VF = calcF(fai);\n\t\n\tfloat epx = R * Y * VF.x;\n    float epy = R * Y * VF.y;\n\t\n\tfloat nlum =  (epy*epy) * 10000.0f;\n\tfcolor += nlum * 100.0f;\n\n\tbool ret = fcolor >= 1.0;\n\tif (ret)\n\t\tfcolor = 1.0;\n    \n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x + 80.5) / iResolution.x) * 3.1415926 * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * 3.1415926 * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n    ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.75 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    \n    float dt = 0.03;\n    float cor = 0.0;\n    A = sqrt(pow(2. / (float(n) * a0), 3.) * (JC(n - l - 1) / (2.0 * float(n) * JC(n + l))));\n    Y0 = (1. / sqrt(2. * 3.1415926)) * sqrt(((2. * float(l) + 1.) / 2.0) * (JC(l - m) / JC(l + m)));\n    \n    for(int i = 0; i < 100; i ++)\n    {\n        p += v * dt;\n        \n\t\tif(mapcor(p * 500., cor))\n            break;\n    }\n    vec4 color = vec4(cor,cor,cor,1.0);\n\t\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}