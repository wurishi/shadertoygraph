{"ver":"0.1","info":{"id":"lc3GRs","date":"1712012896","viewed":284,"name":"Derivatives based noises","username":"movax20h","description":"Playing with terrain height noise from Elevated by iq.\n\nRemoved all 3d stuff, and just playing with noise, using 7 different influence factors of each octave based on derivatives.\n\nOriginal: A raymarched version of the demo Elevated from 2009.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","distancefield","terrain","perlin","rigged"],"hasliked":0,"parentid":"MdX3Rr","parentname":"Elevated"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// on the derivatives based noise: https://iquilezles.org/articles/morenoise\n\n// Borrowed from https://www.shadertoy.com/view/MdX3Rr by iq.\n// With heavy modifications.\n\n// See also:\n// https://iquilezles.org/articles/morenoise/\n// https://www.shadertoy.com/view/lsf3WH - Noise - value - 2D\n// https://www.shadertoy.com/view/XdXBRH - Noise - Gradient - 2D - Deriv\n// https://www.shadertoy.com/view/XdXGW8 - Noise - gradient - 2D\n// https://www.shadertoy.com/view/3dVXDc - Tileable Perlin-Worley 3D\n\n#define ANIMATE_LAYERS\n\n#define USE_SMOOTH_NOISE   // Enable to prevent discontinuities\n\n// Value noise, and its analytical derivatives\nvec3 noised(vec2 x, uint subseed) {\n  vec2 f = fract(x);\n#ifdef USE_SMOOTH_NOISE\n  vec2 u = f*f*(3.0 - 2.0*f);\n  vec2 du = 6.0*f*(1.0 - f);\n#else\n  vec2 u = f*f*f*(f*(f*6.0 - 15.0) + 10.0);\n  vec2 du = 30.0*f*f*(f*(f - 2.0) + 1.0);\n#endif\n\n  ivec2 p = ivec2(floor(x));\n  float a = texelFetch(iChannel0, (p + ivec2(0, 0)) & 255, 0).x;\n  float b = texelFetch(iChannel0, (p + ivec2(1, 0)) & 255, 0).x;\n  float c = texelFetch(iChannel0, (p + ivec2(0, 1)) & 255, 0).x;\n  float d = texelFetch(iChannel0, (p + ivec2(1, 1)) & 255, 0).x;\n\n  return vec3(a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y,\n              du*(vec2(b-a, c-a) + (a-b-c+d)*u.yx));\n}\n\nfloat influenceFactor(vec2 d, int whichInfluenceFactor) {\n  float d2 = dot(d, d);\n\n  switch (whichInfluenceFactor) {\n    case 0:\n    // Classic Perlin\n    return 1.0;\n\n    case 1:\n    // Rigged noise\n    return 1.0 / (1.0 + d2);\n\n    case 2:\n    // Higher powers and other variations\n    return 1.0 / (1.0 + pow(d2, 8.0));\n\n    case 3:\n    return 1.0 / (1.0 + pow(d2, 0.5));\n\n    case 4:\n    return exp(-d2);\n\n    case 5:\n    return exp(-2.0 * pow(d2, 2.0));\n\n    case 6:\n    return 1.0 / (1.1 + sin(iTime + 15.0 * d2));  // Pretty cool\n  }\n}\n\n// Called terrainH, because without some extra modifications,\n// like animation of each octave, and using just \"Rigged noise\",\n// this is a terrain hight function from \"Elevated\" by iq.\n// https://www.shadertoy.com/view/MdX3Rr\nfloat terrainH(vec2 x, int whichInfluenceFactor) {\n  vec2 p = x;\n  vec2 p0 = p;\n  float a = 0.0;\n  float b = 1.0;\n  vec2  d = vec2(0.0);\n  for (uint i = 0u; i < 5u; i++) {\n    vec2 p2 = p;\n\n#ifdef ANIMATE_LAYERS\n    // We can also make layers rotate, with each deeper layer rotating faster.\n    {\n    float s = sin(0.02 * float(i + 1u) * iTime);\n    float c = cos(0.02 * float(i + 1u) * iTime);\n    p2 = mat2(c, s, -s, c) * p0;\n    }\n#else\n    p2 = p0;\n#endif\n\n#ifdef ANIMATE_LAYERS\n    p2 += vec2(0.2 * iTime);  // Slow diagonal motion overall\n\n    // Move each layer a bit in kind of circular fashion, but\n    // each layer with different frequency.\n    // Slightly detuned, but not too much.\n    vec2 layerOffset = 0.5 * vec2(sin(float(i) * iTime), cos((float(i) + 0.1) * iTime));\n    p2 = p2 + layerOffset;\n#endif\n\n    vec3 n = noised(p2, i);\n\n    // Accumulate derivative\n    // (Interesting there is no b*, but with b* it also creates decent results)\n    d += n.yz;\n\n    // Accumulate height\n    a += b * n.x * influenceFactor(d, whichInfluenceFactor);\n    b *= 0.5;\n\n    // This rotation here is to decorlate different octaves of\n    // the noised, as it is of poor quality.\n    p0 = mat2(0.8, -0.6, 0.6, 0.8) * p0 * 2.1;\n  }\n\n  return a;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n  // Give each influence factor type 5 second showcase.\n  // int whichInfluenceFactor = int(floor(0.2 * iTime)) % 7;\n\n  // Divide into 7 strips, each with own influence factor.\n  int whichInfluenceFactor = int(floor(fragCoord.x / iResolution.x * 7.0));\n\n  float h = terrainH(2.0 * p, whichInfluenceFactor) / 4.0;\n\n  fragColor = vec4( h, h, h, 0.0 );\n}\n","name":"Image","description":"","type":"image"}]}