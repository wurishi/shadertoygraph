{"ver":"0.1","info":{"id":"lXV3z3","date":"1718043371","viewed":49,"name":"Equirectangular Voronoi","username":"gllama","description":"Despite hours of f*ckery this still has pinching artifacts around the poles when mapped onto a sphere. \n\nPretty sure there's precision lost when we do:[code]vec3 uvTo3D(vec2 uv)[/code], just use sphere's normal instead and it fixes it\n\nCC0-1.0 licensed ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","4d","purple","cc0","equirectangular","voronoi4d"],"hasliked":0,"parentid":"l3KGz3","parentname":"Voronoi initial"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ðŸ¦  Equirectangular Voronoi Noise\n// License CC0-1.0\n\n#define PI 3.1415926535897932384626433832795\nvec4 permute(vec4 x) { \n    return mod(((x*34.0)+1.0)*x, 289.0); \n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat hash1(vec4 p) {\n    p = fract(p * 0.1031);\n    p *= dot(p, p + 33.33);\n    return fract((p.x + p.y) * p.z * p.w);\n}\n\nfloat voronoi4D(vec4 p) {\n    vec4 b = floor(p);\n    vec4 f = fract(p);\n    float res = 1.0;\n    \n    for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int i = -1; i <= 1; i++) {\n                for (int l = -1; l <= 1; l++) {\n                    vec4 neighbour = vec4(float(i), float(j), float(k), float(l));\n                    vec4 point = b + neighbour;\n                    vec4 r = neighbour - f + hash1(point);\n                    float d = dot(r, r);\n                    res = min(res, d);\n                }\n            }\n        }\n    }\n    return sqrt(res);\n}\n\n// UV coords to 3D space (spherical/equirectangular)\nvec3 uvTo3D(vec2 uv) {\n\n    // Normalize uv from [0,1] -> [-1,1]\n    uv=uv*2.-1.;\n    \n    // Convert UV to spherical coords (2-Sphere Angles)    \n    float theta = uv.x * PI+iTime/10.; // Longitude [-PI,PI]\n    float phi = uv.y * (PI*.5); // Latitude [-1/2 PI, 1/2 PI]\n    \n    // Convert Spherical-Coords to 3D Cartesian Coords\n    // Similar to what you would get from a sphere normal vec3 at position UV\n    float x = cos(phi) * cos(theta);\n    float y = cos(phi) * sin(theta);\n    float z = sin(phi);\n    return vec3(x, y, z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Offset time b/c pattern too perfect around t=0;\n    float t=iTime+10.; \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; \n    \n    \n    vec3 pos = uvTo3D(uv);\n    \n    vec4 pos4D = vec4(pos * 5.0, t * 0.4);  // 4D position, with time as the fourth dimension\n    float noise = voronoi4D(pos4D);\n    //float colorFader = (((cos(iTime*2.)/2.)+.5)*.1)+.9;\n    //float marble = sin(pos.z * 5.0 + noise * 10.0) * 0.5 + 0.5;\n    //noise = cos(pos.z * 5.0 + noise * 10.0) * 0.5 + 0.5;\n    vec3 color = mix(pos, vec3(1.0),noise );\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}