{"ver":"0.1","info":{"id":"4XSBRK","date":"1733542599","viewed":90,"name":"SDF_KOI","username":"kosalos","description":"SDF functions","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["sdfpractice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 uv; // screen coordinate as -1.7 ... 1.7\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid sdfLine(vec2 p1,vec2 p2, float r1, float r2, vec3 color,inout vec4 O) {\n    float d = ptLineDistance(uv,p1,p2);\n    float d1 = length(uv-p1);\n    float d2 = length(uv-p2);    \n    float w = mix(r1,r2, d1/(d1+d2));\n    \n    if(d < w) {\n        O.xyz = color;\n        \n        float ww = w * (1. + sin(iTime)* 0.2);\n        float d2 = ptLineDistance(uv - vec2(-ww,ww),p1,p2);\n        O.xyz += color - vec3(d2 / (w * 1.5));\n    }\n}\n\nvoid sdfCircle(vec2 pt, float radius, vec3 color,inout vec4 O) {\n    float d = length(uv - pt);\n    if(d < radius) {\n        float d2 = length(uv - vec2(-radius * 0.3,radius * 0.3) - pt);\n        O.xyz = color - vec3(d2 / (radius * 3.5));\n    }\n\n    if(abs(d - radius) < 0.002) O.xyz = vec3(0.);\n}\n\n// ----------------------------------------------------------\n\nvec3 dat[10]; // temporary segment memory while drawing\n\n#define p1Offset(angle,len) p1 + vec2(cos(angle)*len,sin(angle)*len)\n\nvoid drawFins(int index,float scale,float angleOffset,vec3 color,inout vec4 O) {  \n    vec2 p1 = dat[index].xy;\n    vec3 seg = bodySegment[index] * scale;\n    float r1 = seg.x * 0.3;\n    float r2 = seg.y * 0.8;\n    float angle = PIh + dat[index].z;\n    float side = 0.35 * scale;\n    float a2 = angle - angleOffset;\n    vec2 p2 = p1Offset(a2,side);\n    sdfLine(p1,p2,r1,r2,color,O);\n\n    a2 = angle + angleOffset + PI;\n    p2 = p1Offset(a2,side);\n    sdfLine(p1,p2,r1,r2,color,O);\n}\n\nvoid drawFish(FishData q,inout vec4 O) {\n    vec2 p2,p1 = q.position;\n    \n    if(length(p1-uv) > 1.4) return;\n    \n    vec3 segOffset;\n    float angle = q.angle;\n\n    // memorize flexed positions\n    for(int i=0;i<bodySegment.length();++i) {\n        angle += flexFactor[i] * q.flex;\n        p2 = p1Offset(angle,bodySegment[i].z * q.scale);\n        p1 = p2;\n        dat[i] = vec3(p2,angle);\n    }\n    \n    // whiskers ---------------\n    float tLen = .25 * q.scale;\n    float width = 0.02 * q.scale;\n    p1 = q.position; \n    p2 = p1Offset(PI * 0.75 + dat[1].z,tLen);\n    sdfLine(p1,p2,width,width * 0.8, q.c2,O);    \n    p2 = p1Offset(PI * 1.25 + dat[1].z,tLen);\n    sdfLine(p1,p2,width,width * 0.8, q.c2,O);    \n\n    // fins -------------------\n    float finAngle = 0.1 + abs(q.flex) * 0.03;\n    float scale2 = q.scale * 0.8;\n    vec3 c2b = q.c2 * 0.7;\n    drawFins(1,q.scale,-finAngle,c2b, O);\n    drawFins(1,scale2, finAngle, q.c2,O);\n    drawFins(4,q.scale,-finAngle,c2b, O);\n    drawFins(4,scale2, finAngle, q.c2,O);\n\n    // tail -------------------\n    int index = bodySegment.length()-1;\n    p1 = dat[index].xy;\n    tLen = 0.6 * q.scale;\n    segOffset = bodySegment[index] * q.scale;\n    float tLen2 = tLen * 0.9;\n    float r1 = segOffset.x * 0.3;\n    float r2 = segOffset.y * 1.2;\n    float fan = 0.1 + abs(q.flex) * 0.03;\n\n    // sides\n    angle = dat[index].z - fan;\n    for(int i=0;i<2;++i) {\n        p2 = p1Offset(angle,tLen2);\n        sdfLine(p1,p2,r1,r2,q.c2,O);    \n        angle += fan * 2.;\n    }\n    // center\n    angle -= fan * 3.;\n    p2 = p1Offset(angle,tLen);\n    sdfLine(p1,p2,r1,r2,c2b,O);    \n    \n    // body -------------------\n    p1 = q.position;\n    angle = q.angle; \n    vec3 color;\n    for(int i=0;i<bodySegment.length();++i) {\n        color = q.c1;\n        if(i == 0) color *= 0.7;\n        segOffset = bodySegment[i] * q.scale;\n        p2 = dat[i].xy;\n        sdfLine(p1,p2,segOffset.x,segOffset.y,color,O);\n        p1 = p2;\n    }\n        \n    // top fin-----------------\n    tLen = 0.4 * q.scale;\n    for(int index=3;index>=1;--index) {\n        p1 = dat[index].xy;\n        segOffset = vec3(0.04) * q.scale;\n        angle = dat[index].z - q.flex * float(index) * 0.05;\n        p2 = p1Offset(angle,tLen);\n        sdfLine(p1,p2,segOffset.x,segOffset.y * 1.5, c2b,O);    \n        tLen *= 0.8;\n    }\n    \n    // eyes -------------------\n    color = mix(q.c1,q.c2,0.5);\n    float side = 0.09 * q.scale;\n    p1 = mix(q.position,dat[0].xy,0.2);\n    angle = PIh + q.angle;\n    p2 = p1Offset(angle,side);\n    sdfCircle(p2,0.04 * q.scale,color,O);\n    angle += PI;\n    p2 = p1Offset(angle,side);\n    sdfCircle(p2,0.04 * q.scale,color,O);\n}\n\n// ----------------------------------------------------------\n\nvec3 jetColorMap(float t) { // 0 ... 1\n    return clamp(vec3(1.5) - abs(4.0 * vec3(t) + vec3(-3., -2., -1.)), vec3(0.), vec3(1.));\n}\n\nvec2 hash2(vec2 p ) {\n   return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);   \n}\n\n//Based off of iq's described here: https://iquilezles.org/articles/voronoilines\nfloat voronoi(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float md = 5.0;\n    vec2 m = vec2(0.0);\n    for (int i = -1;i<=1;i++) {\n        for (int j = -1;j<=1;j++) {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(n+g);\n            o = 0.5+0.5*sin(iTime+5.038*o);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d<md) {\n              md = d;\n              m = n+g+o;\n            }\n        }\n    }\n    return md;\n}\n\nfloat ov(vec2 p) {\n    float v = 0.0;\n    float a = 0.4;\n    for (int i = 0;i<3;i++) {\n        v+= voronoi(p)*a;\n        p*=2.0;\n        a*=0.5;\n    }\n    return v;\n}\n\n// ---------------------------------------------------------\n\nvoid rocks(inout vec4 O,vec2 R) { \n    vec2 p1,p2;\n    ivec2 index = ivec2(0);\n    vec3 pixel;\n   \n    for(float x=-1.8;x<1.7;x+=0.15) {\n        for(float y=-1.;y<0.9;y+= 0.15) {\n            pixel = texelFetch(iChannel3,index,0).xyz - vec3(0.37);\n            if(++index.x > 500) { index.x = 0; ++index.y; }\n            p1 = vec2(x + pixel.x * 2.,y + pixel.y * 3.);\n            p2 = p1 + pixel.z * 0.3;\n            \n            pixel = texelFetch(iChannel3,index,0).xyz * 0.16;\n            if(pixel.z < 0.3) pixel.z = 0.;\n            sdfLine(p1,p2,pixel.x,pixel.x,pixel * 6.,O);\n        }\n    }\n}\n\nvoid leaves(inout vec4 O,vec2 R) { \n    vec2 p1,p2;\n    ivec2 index = ivec2(0,50);\n    vec3 pixel;\n   \n    for(float x=-1.7;x<1.7;x+=1.1) {\n        for(float y=-1.;y<0.9;y+= 1.) {\n            pixel = texelFetch(iChannel3,index,0).xyz - vec3(0.47);\n            if(++index.x > 500) { index.x = 0; ++index.y; }\n            p1 = vec2(x + pixel.x * 12.,y + pixel.y * 63.);\n            p1 += vec2(cos(iTime * 0.1) * 0.41,sin(iTime * 0.1) * 0.41);\n            p2 = p1 + pixel.z * 0.8;\n            \n            pixel = texelFetch(iChannel3,index,0).xyz * 0.16;\n            pixel.x += 0.2;\n            if(pixel.z < 0.3) pixel.z = 0.;\n            sdfLine(p1,p2,pixel.x,pixel.x, vec3(0.1,0.6,pixel.y * 7.),O);\n        }\n    }\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 O,vec2 U) {\n    vec2 R = iResolution.xy;\n    uv = (2.0 * U - R) / min(R.x, R.y); \n    \n    vec2 tsz = vec2(textureSize(iChannel3,0)); \n    O.xyz = texelFetch(iChannel3,ivec2(U * tsz / R),0).zzx;\n\n    rocks(O,uv);\n\n    O.xyz += smoothstep(0.0, .5, ov(uv * .8)); // ripples\n\n    FishData fa;\n    loadData(iChannel0);\n\n    for(int i;i<QSIZE;i+=QWIDTH) {\n        fa.scale = 0.02 + float(i) * 0.01;  // overall size of fish\n        fa.position = qPos;\n        fa.angle = qAngle + PI;\n        \n        int ai = int(qIndex);        \n        fa.flex = clamp(animationF[ai] * 3., -maxFlex,maxFlex);\n        fa.c1 = jetColorMap(float(i)/float(QSIZE));\n        fa.c2 = fa.c1.yzx;\n        drawFish(fa,O);\n    }\n    \n    leaves(O,uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float PIh = PI * 0.5;\n\n#define qPos      q[i].xy   // position\n#define qAngle    q[i].z    // direction\n#define qAspeed   q[i].w    // change direction amount\n#define qIndex    q[i+1].x  // animation index\n#define qIspeed   q[i+1].y  // animation cycle speed\n#define qIscale   q[i+1].z  // animation amplitude\n\nconst int QWIDTH =  2; // # vec4 per fish\nconst int QCOUNT =  20; // # fish\nconst int QSIZE = QCOUNT * QWIDTH; // total storage\n\nvec4 q[QSIZE];\n\nvoid loadData(sampler2D channel) {\n    for(int i=0;i<QSIZE;++i) \n        q[i] = texelFetch(channel,ivec2(i,0),0);\n}\n\nvoid saveData(inout vec4 O,vec2 U) {\n    ivec2 I = ivec2(U);\n    \n    if(I.y == 0 && I.x < QSIZE) \n        O = q[I.x];\n}\n\n// ----------------------------------------------------\n\nstruct FishData {\n    vec2 position;\n    float angle,flex,scale;\n    vec3 c1,c2;\n};\n\nconst vec3 bodySegment[] = vec3[](  // r1,r2,length \n    vec3(0.08,0.33,0.35), vec3(0.22,0.25,0.3),  vec3(0.27,0.18,0.3),\n    vec3(0.27,0.14,0.25), vec3(0.24,0.11,0.2),  vec3(0.19,0.10,0.2),\n    vec3(0.16,0.07,0.2),  vec3(0.11,0.06,0.15), vec3(0.08,0.05,0.2));\n\nconst float maxFlex = 9.; \nconst float flexFactor[] = float[](0., 0.01, 0.01, 0.015, 0.017, 0.02, 0.025, 0.045, 0.06);  \n\nconst float animationF[] = float[]( // tail flex amount\n    0.1,0.3,0.6,0.9,1.0,0.9,0.7,0.4,0.2,0.,-0.1,-0.3,-0.6,-0.9,-1.0,-0.9,-0.7,-0.4,-0.2,0.,\n    0.1,0.3,0.6,0.9,1.0,0.9,0.7,0.4,0.2,0.,-0.1,-0.3,-0.6,-0.9,-1.0,-0.9,-0.7,-0.4,-0.2,0.,\n    0.1,0.1,0.1,0.,0.,0.,0.,0.,-0.1,-0.1,-0.1,0.,0.,0.,0.,0.,0.,0.,0.,0.,\n    0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n\nconst float animationD[] = float[]( // distance travelled\n    0.1,0.2,0.4,0.6,0.8,1.,1.,1.,1.,1.,0.9,0.8,0.8,0.7,0.7,0.6,0.6,0.5,0.5,0.5,\n    0.4,0.4,0.4,0.3,0.3,0.2,0.2,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,\n    0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,\n    0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1);\n    \nconst int ANIMATION_LENGTH = min(animationF.length(),animationD.length());\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 rseed = vec2(12.9898, 78.233);\n\nfloat fRandom() { // 0...1\n    rseed.xy += texelFetch(iChannel3,ivec2(fract(iTime) * 64.),0).xy;\n    float v = sin(dot(rseed, vec2(12.9898, 78.233))) * 43758.5453;\n\treturn fract(v);\n}\n\n// ----------------------------------------------------------\n\nvoid randomStart(int i) {\n    float pAngle = fRandom() * PI * 2.;    \n    float aspect = iResolution.x / iResolution.y;\n    const float offEdge = 2.;\n    \n    qAngle = fRandom() * PI * 2.;\n    qPos = vec2(cos(pAngle + PI) * offEdge * aspect,sin(pAngle + PI) * offEdge);\n    qAspeed = -0.3 + fRandom() * 0.25;\n    qIndex = fRandom() * float(ANIMATION_LENGTH);    \n    qIspeed = 0.01 + fRandom() * 2.;\n    qIscale = 0.01 + fRandom() * 0.01;\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n    if(U.x > float(QSIZE) || U.y > 1.0) return;\n    \n    if(iFrame < 2) {\n        for(int i;i<QSIZE;i+=QWIDTH) \n            randomStart(i);\n        saveData(O,U);\n        return;\n    }\n    \n    loadData(iChannel0);\n    \n    float t;\n    for(int i;i<QSIZE;i+=QWIDTH) {  // all fish\n        int ai = int(qIndex);\n        t = 0.015 + animationD[ai] * qIscale;  // forward distance\n        qPos += vec2(cos(qAngle) * t,sin(qAngle) * t);\n    \n        t = length(qPos);  // swam offscreen? restart\n        if(t > 3.0) randomStart(i);\n\n        t = 0.01 + sin(qAspeed) * 0.01;// angle changes over time\n        qAngle += t;\n                \n        qIndex += qIspeed;  // advance index of animation cycle\n        if(qIndex >= float(ANIMATION_LENGTH))\n            qIndex = 0.;\n    }\n       \n    saveData(O,U);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}