{"ver":"0.1","info":{"id":"4tVyDR","date":"1535808711","viewed":582,"name":"lonelytree.txt","username":"Kali","description":"A shader from 2013, one of my firsts. It was missing and I've just found it on an old hard drive with that filename.","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["lonely"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n---------------------------------------------------------------------------------------\n\n \"Lonely Tree\" by Pablo Roman Andrioli (Kali)\n \n Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Please report any problems (I'm aware this shader could work slow on some systems)\n\n--------------------------------------------------------------------------------------- \n*/\n\n\n// Params to play with:\n\n// Raytracer \n\nconst float viewsize=.5;    // reduced raytracing area for speeding up (>1 for full view)\nconst float zoom=1.1; \nconst float detail=.02;    // distance to stop tracing\nconst float maxdist=28.;    // scene depth\nconst int maxsteps=100;      // max ray steps\n\n// Light \n\nconst vec3 lightdir=vec3(1,-.6,0.); \nconst float diffuse=.75;\nconst float specular=.8;\nconst float specularexp=5.;\nconst float ambient=.2;\n\n// Tree shape\n// you can try to find better trees or even some really weird ones.\n\nconst float inititer=37.;   // Iterations to do at first run\nconst float maxiter=50.;    // Max iterations to reach with mouse\nconst float leavestart=29.; // Iteration to stop texturing and start green coloring\nconst float width=0.55; \nconst float height=0.62;\nconst float branchsegments=3.; // Number of segments for each branch\nconst float scaling=0.90;\t   // Scaling factor at each iteration\nconst vec3 rotvector=vec3(-0.3,-1.,0.2); // IFS rotation vector\nconst float rotangle=85.;      // IFS rotation angle\nconst float anglevary=-0.2;    // Angle variation at each iteration\n\n// Animation \n\nconst float amplitude=.1;   \nconst float speed=0.8;\nconst float dynscaling=0.8; // Scaling factor for the dynamic fractal animation\n\n\n//-------------------------------------------------------------------------------------------\n\nvec3 dir;\nvec2 pix;\nvec2 coord;\n\n\n// Rotation function included in MathUtils.frag of Syntopia's Fragmentarium \nmat3 rotationMat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\n// Terrain heightmap\nfloat terrain(vec3 p){\n\tp.x+=1.5;\n\tfloat h=(sin(p.x)+cos(p.z))*.25;\n\tfloat l=length(p.xz);\n\tp.xz*=2.3;\n\tp.x+=l*.5;\n\th+=(cos(p.x)+sin(p.z))*.1;\n\tp.xz*=1.3;\n\tp.z+=l*.7;\n\th+=(cos(p.x)+sin(p.z))*.08;\n\th+=texture(iChannel0,p.xz*.4).z*.2; //texture displacement\n\treturn p.y-h;\n}\n\nfloat totalit;\n\n// Scene DE\nvec2 DE(vec3 pos){\n\tvec3 p=pos;\n\tint n = 0;\n\tfloat sc=1.;\n\tfloat time=iTime*speed;\n\tfloat amp=sin(time/2.)*amplitude;\n\tfloat angle=radians(rotangle)/branchsegments;\n\tbool rotstart=false;\n\tfloat dtree;\n\tfloat minit=maxiter;\n\tvec3 minp=pos;\n\tfloat mouseit=iMouse.y/iResolution.y*maxiter; //mouse iterations\n\tbool mouse=length(iMouse.xy)>0.; //see if mouse was used\n\ttotalit=0.;\n\tfor (float n=0.; n < maxiter; n++) {\n\t\ttotalit++; //iter count\n\t\tif ((n>mouseit && mouse) ||\n\t\t  (!mouse && n>inititer)) break;\n\t\tfloat d=length((p+vec3(0,sc,0))*vec3(1,.3,1))-width*sc; //branch segment\n\t\tif (n<1.) dtree=d;\n\t\tif (d<=dtree) { //test min distance and save iteration & vector\n\t\t\tdtree=d;\n\t\t\tminit=n;\n\t\t\tminp=p;\n\t\t}\n\t\tif (mod(n,branchsegments) > branchsegments-2.) { \n\t\t\tp.x=abs(p.x); // fold after max segments reached for each branch\n\t\t\trotstart=true; // start rotating at first fold\n\t\t}\n\t\tif (rotstart) { // rotate and animate rotation\n\t\t\tp*=rotationMat(normalize(rotvector),angle+sin(time)*amp);\n\t\t}\n\t\tp.y-=height*sc; // go up\n\t\tsc*=scaling; // scale size\n\t\tamp*=dynscaling; // scale amplitude\n\t\ttime/=dynscaling; // scale time\n\t\tangle+=radians(anglevary); // vary rotation\n\t}\n\tif (minit<leavestart){ //apply texture displacement\n\t\tdtree+=length(texture(iChannel1,vec2(minp.y*2.,atan(minp.x,minp.z)*1.)).xyz)*.04;\n\t} \n\t\n\tfloat dterr=terrain(pos);\n\tfloat de=min(dterr,dtree);\n\tfloat col;\n\tif (de==dterr) col=0.; else col=minit+1.; // return coloring parameter\n\treturn vec2(de,col);\n}\n\n\n// finite difference normal\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx).x-DE(pos-e.yxx).x,\n\t\t\tDE(pos+e.xyx).x-DE(pos-e.xyx).x,\n\t\t\tDE(pos+e.xxy).x-DE(pos-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\n// coloring\nvec3 color(float obj, vec3 p) {\n\n\tif (obj<1.) { //terrain texture\n\t\tvec3 tex=texture(iChannel0,p.xz*.4).xyz;\n\t\treturn mix(vec3(.55,.7,.3),tex,.75)*(.5+smoothstep(0.,1.0,length(p.xz)*.35));\n\t} \n\telse if (obj>0. && obj<leavestart) { //branches\n\t\treturn vec3(.55,.4,.25);\n\t} else { //leaves (vary brightness by iteration, kind of fake AO)\n\t\treturn vec3(.80,1,.6)*1.1*(1.-.7*(totalit-obj)/(totalit-leavestart));\n\t}\n\t\n}\n\n//lighting\nvec3 light(vec3 p) {\nvec3 ldir=normalize(lightdir);\nvec3 n=normal(p);\nfloat diff=max(max(0.0,dot(-n, ldir))*diffuse,ambient);\nvec3 r = reflect(ldir,n);\nfloat spec=max(0.,dot(dir,-r));\nreturn vec3(diff+pow(spec,specularexp)*specular);\t\n}\n\n//raytracing\nvec3 trace(vec3 from, vec3 dir) {\n\tvec3 p;\n\tfloat totdist=0.;\n\tvec3 col;\n\tvec2 d;\n\tfor (int i=1; i<maxsteps; i++) {\n\t\tp=from+totdist*dir;\n\t\td=DE(p);\n\t\tif (d.x<detail || totdist>maxdist) break;\n\t\ttotdist+=d.x; \n\t}\n\tvec3 back=mix(vec3(.9),vec3(.6,.7,.8),clamp((dir.y+.15)*6.,0.,1.)); //background gradient\n\tif (d.x<detail) {\n\t\tcol=color(d.y,p)*light(p-detail*dir*.5); //apply color+light\n\t\tcol=mix(col,back,smoothstep(0.,1.,totdist*totdist/maxdist*.03)); //a bit of fog\n\t} else { //background sky with moving clouds (and some contrails? :D)\n\t\tcol=back+vec3(1,.9,.6)*texture(iChannel1,\n\t\tvec2(dir.y*4.,atan(dir.z,dir.x)*1.5+iTime*.02)*.15).g*(dir.y*.7+.15);\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Camera\n\t//limited view angle to reduce symmetry appreciation\n\t//(introducing assymmetry breaks the distance field, any suggestions?)\n\tpix=fragCoord.xy / iResolution.xy;\n\tfloat viewangle=-135.+(iMouse.x/iResolution.x)*90.; \n\tmat3 rotview=rotationMat(vec3(0.,1.,0.),radians(viewangle));\n\tcoord = pix-vec2(.5);\n\tcoord.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,0.,7.5)*rotview*zoom;\n\tfrom+=vec3(0.,3,0.);\n\tdir=normalize(vec3(coord*2.,-1.))*rotview;\n\tvec3 col=vec3(0.);\n\tfloat view=length(coord*vec2(.8,1.)*4.);\n\tif (view<viewsize*2.) col=trace(from,dir); \t//trace only inside view area\n\tcol=col*.9+vec3(.1); //desaturate a bit\n\tcol = mix(col, vec3(0.73), smoothstep(0.5,1.,view*view/pow(viewsize*2.,2.))); //smooth edges\n\tfragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}