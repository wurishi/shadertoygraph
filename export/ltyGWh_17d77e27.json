{"ver":"0.1","info":{"id":"ltyGWh","date":"1474378536","viewed":460,"name":"glossy reflections","username":"andrewww1","description":"mouse click to set the first person view yaw and pitch.\n\nChange GLOSS_RAYS_NUM to set the number of rays.\nChange GLOSS_RAYS_SPREAD to set the spread of the rays.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["reflection","glossy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GLOSS_RAYS_NUM 2\n#define GLOSS_RAYS_SPREAD 0.025\n\nfloat opS(float d1, float d2) {\n    return max(-d2,d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n    return (d1.y<d2.y) ? d1 : d2;\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat length6( vec2 p ) {\n    p = p*p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat sdCylinder6( vec3 p, vec2 h ) {\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nvec3 checkerCol(vec3 texc, vec3 color0, vec3 color1) {\n    if (mod((floor(texc.x) + floor(texc.y) + floor(texc.z)),2.0 ) == 0.0) {\n        return color0;\n    } else {\n        return color1;\n    }\n}\n\nvec3 brickCol(vec3 localPos,vec3 BrickColor, vec3 MortarColor, vec3 BrickSize,vec3 BrickPct) {\n    vec3 position = localPos / BrickSize.xyz;\n\n    if (fract(position.y * 0.5) > 0.5){\n        position.x += 0.5;\n        position.z += 0.5;\n    }\n\n    position = fract(position);\n    vec3 useBrick = step(position, BrickPct.xyz);\n\n    return mix(MortarColor, BrickColor, useBrick.x * useBrick.y * useBrick.z);\n}\n\nvec2 distScene(vec3 p) {\n    vec2 rs=vec2(0.2,opS(sdBox(p-vec3(0.0,1.5,0.0), vec3(24.0,3.0,24.0)),\n                                             sdBox(p-vec3(0.0,0.0,0.0), vec3(23.5,7.0,23.5))));\n\n    rs=opU(rs,vec2(0.1,sdBox(p-vec3(0.0,-1.5,0.0), vec3(24.0,0.5,24.0))));\n\n    rs=opU(rs, vec2(0.3, (sdCylinder6((opRep(vec3(clamp(p.xz,vec2(-23.0),vec2(23.0)),p.y).xzy, \n                                             vec2(7.0,0.0).xyx)-vec3(0.0,1.5,0.0)),vec2(0.5,3.0)) )));\n\n    return rs;\n}\n\nfloat rand(vec2 coordinate) {\n    return fract(sin(dot(coordinate.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 castRay3( in vec3 ro, in vec3 rd ) {\n    float t=0.0;\n    float d=0.0;\n    const float maxSteps=48.0;\n    \n    for(float i = 1.0; i <= maxSteps; ++i) {\n        vec3 p = ro + rd * t;\n        vec2 rs=distScene(p);\n        d = rs.y;\n\n        float q=0.01;\n        \n        if(d < q ) {\n            return vec2(rs.x,t);\n        }\n\n        t += d;\n    }\n\n    return vec2(0.0,0.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n    float t=0.0;\n    float d=0.0;\n    const float maxSteps=96.0;\n    \n    for(float i = 1.0; i <= maxSteps; ++i) {\n        vec3 p = ro + rd * t;\n        vec2 rs=distScene(p);\n        d = rs.y;\n        float q=0.01;\n        \n        if(d < q ) {\n            return vec2(rs.x,t);\n        }\n\n        t += d;\n    }\n\n    return vec2(0.0,0.0);\n}\n\nvec3 getNormal(vec3 p) {\n    float h = 0.0001;\n    vec3 n;\n    n.x=distScene(p+vec3(h,0.0,0.0)).y-distScene(p-vec3(h,0.0,0.0)).y;\n    n.y=distScene(p+vec3(0.0,h,0.0)).y-distScene(p-vec3(0.0,h,0.0)).y;\n    n.z=distScene(p+vec3(0.0,0.0,h)).y-distScene(p-vec3(0.0,0.0,h)).y;\n    n=normalize(n);\n    return n;\n}\n\n\nvec3 calcPtLightCol3(vec3 pos, vec3 nor, vec3 lightPos,vec3 atten,vec3 lightCol,vec3 mtrlCol,float shininess,float strength) {\n    vec3 lightDir=lightPos.xyz-pos;\n    float lightDist=length(lightDir);\n    lightDir=lightDir/lightDist;\n    vec2 rs=castRay3(pos+lightDir*0.1,lightDir);\n\n    if(rs.x>0.0 && rs.y < lightDist) {\n        return vec3(0.0);\n    }\n\n    //\n    float a = 1.0/(atten.x+atten.y*lightDist+atten.z*lightDist*lightDist);\n    vec3 reflectVec=reflect(-lightDir,nor);\n    float NdotL = max(0.0,dot(nor,lightDir));\n    float spec=0.0;\n\n    if(NdotL > 0.0) {\n        float NdotR = max(0.0, dot(nor, reflectVec));\n        spec = pow(NdotR, shininess*128.0) * strength*a;\n    }\n\n    float diffuse=NdotL*a;\n    return lightCol*(mtrlCol*diffuse+spec);\n}\n\nvec3 calcPtLightCol(vec3 pos, vec3 nor, vec3 lightPos,vec3 atten,vec3 lightCol,vec3 mtrlCol,float shininess,float strength) {\n    vec3 lightDir=lightPos.xyz-pos;\n    float lightDist=length(lightDir);\n    lightDir=lightDir/lightDist;\n\n    vec2 rs=castRay(pos+lightDir*0.1,lightDir);\n\n    if(rs.x>0.0 && rs.y < lightDist) {\n        return vec3(0.0);\n    }\n\n    //\n    float a = 1.0/(atten.x+atten.y*lightDist+atten.z*lightDist*lightDist);\n\n    vec3 reflectVec=reflect(-lightDir,nor);\n    float NdotL = max(0.0,dot(nor,lightDir));\n    float spec=0.0;\n\n    if(NdotL > 0.0) {\n        float NdotR = max(0.0, dot(nor, reflectVec));\n        spec = pow(NdotR, shininess*128.0) * strength*a;\n    }\n\n    float diffuse=NdotL*a;\n\n    return lightCol*(mtrlCol*diffuse+spec);\n}\n\nfloat calcVecAngle(vec3 v0,vec3 v1) {\n    float l=length(v0)*length(v1);\n    float d=dot(v0,v1);\n    return acos(d/l);\n}\n\nmat3 rotMatFromNormalOld(vec3 RN1,vec3 n) {\n    //vec3 RN1=n.zyx*vec3(1.0,1.0,-1.0);\n    vec3 RN2=cross(n,RN1);\n    mat3 m=mat3(RN1,RN2,n);\n    return m;//transpose(m);\n}\n\n\nmat3 rotMatFromNormal(vec3 n,vec3 r) {\n\tvec3 a=normalize(cross(n,r));\n    vec3 b=normalize(cross(a,r));\n    mat3 m=mat3(a,b,r);\n    return m;\n}\n\nvec2 rand2(vec2 co){\n    //from lumina.sourceforge.net/Tutorials/Noise.html\n    vec2 r;\n    r.x=fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    r.y=fract(cos(dot(co.xy ,vec2(4.898,7.23))) * 23421.631);\n    return r;\n}\n\nvec2 jitter(vec2 offset, float d) {\n    //from gamedev.stackexchange.com/questions/26789/random-vector-within-a-cone\n    for(int i=0;i<32;i++) {\n        offset=rand2(offset)*d;\n        //offset=rand2(offset*u_time)*d;\n\n        if((offset.x*offset.y)>(d*d)) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nvec3 calcMtrlCol(float id,vec3 p,vec3 n) {\n    vec3 col;\n\n    if(id==0.1) {\n        col=checkerCol(p,vec3(0.9,0.9,0.9),vec3(0.3,0.5,0.7));\n    } else if(id==0.2) {\n        col=brickCol(p,vec3(0.9,0.3,0.3), vec3(0.85), vec3(0.95),vec3(0.85));\n    } else if(id==0.3) {\n        col=brickCol(p,vec3(0.8), vec3(0.6), vec3(0.7),vec3(0.9));\n    } else {\n        col=vec3(1.0);\n    }\n\n    return col;\n}\n\nfloat calcFlare(vec3 ro,vec3 rd, vec2 rs,vec3 lightPos) {\n    float t=rs.y;\n    float val=0.0;\n    vec3 viewLightDir=normalize(lightPos-ro);\n    float viewLightDist=length(lightPos-ro);\n    float q = dot(rd,viewLightDir)*0.5+0.5;\n    //float g=calcVecAngle(viewLightDir,rd);\n    //float o = (colViewDist!=-1.0 && colViewDist<viewLightDist)?0.0:(1.0/viewLightDist)*0.15 ;//occ(u_viewPos,lightPos,1.0);\n    //col+=pow(q,500.0/o)*lightCol*1.2;//*((atten.x+atten.y*viewLightDir+atten.z*viewLightDir*viewLightDir));\n\n    if(rs.x==0.0 || (t<0.0 || t>=viewLightDist) /*&& calcVecAngle(rd,viewLightDir)<0.01*/) {\n        float o = (1.0/viewLightDist)*0.15 ;\n        val=clamp(pow(q,900.0/o)*1.0,0.0,2.0);\n    }\n\n    return val;\n}\n\nvec3 render3(vec3 ro, vec3 rd,vec3 lightPos,vec3 lightAtten,vec3 lightCol) {\n    vec3 col;\n    vec2 rs=castRay3(ro,rd);\n    float t = rs.y;\n\n    if(rs.x!=0.0) {\n        vec3 p = ro + t*rd;\n        vec3 p2 = ro + (t+0.1)*rd;\n        vec3 n = getNormal(p);\n        vec3 r=reflect(rd,n);\n        col=calcMtrlCol(rs.x,p,n);\n        col=calcPtLightCol3(p,n,lightPos,lightAtten,lightCol,col,0.45,0.25)+col*0.075;\n    } else {\n        col= vec3(0.1);\n    }\n\n    col=mix(col,lightCol*1.5,calcFlare(ro,rd,rs,lightPos));\n    return col;\n}\n\nvec3 render2(vec3 ro, vec3 rd,vec3 lightPos,vec3 lightAtten,vec3 lightCol,vec2 fragCoord) {\n    vec3 col;\n    vec2 rs=castRay(ro,rd);\n    float t = rs.y;\n    vec3 flareCol=vec3(0.0);\n\n    if(rs.x!=0.0) {\n        vec3 p = ro + t*rd;\n        vec3 p2 = ro + (t-0.1)*rd;\n        vec3 n = getNormal(p);\n        vec3 r=reflect(rd,n);\n        col=calcMtrlCol(rs.x,p,n);\n        col=calcPtLightCol(p,n,lightPos,lightAtten,lightCol,col,0.45,0.25)+col*0.075;\n\n        vec2 offset=fragCoord.xy;\n        vec3 rf=normalize(reflect(rd,n));\n\n\t\tmat3 rfmat=rotMatFromNormal(n,rf);\n        for(int u=0;u<GLOSS_RAYS_NUM;u++) {\n            offset=jitter(offset,GLOSS_RAYS_SPREAD);\n            vec3 jj=normalize(rfmat*vec3(offset.x,offset.y,1.0));\n            col=mix(col,render3(p2,jj,lightPos,lightAtten,lightCol),0.1);\n        }\n    } else {\n        col= vec3(0.1);\n    }\n\n    col=mix(col,lightCol*1.5,calcFlare(ro,rd,rs,lightPos));\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd,vec3 lightPos,vec3 lightAtten,vec3 lightCol,vec2 fragCoord) {\n    vec3 col=render2(ro,rd, lightPos, lightAtten, lightCol,fragCoord);\n    return vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n    float d=1.0/tan(fovy/2.0);\n    vec3 v=vec3(screen.x*aspect,screen.y,-d);\n    v=normalize(v);\n    return v;\n}\n\nvec3 calcLightPos(float a) {\n    float x=(cos(a) + cos(3.0*a)/3.0 + sin(9.0*a)/9.0)*10.0+cos(a)*8.0;\n    float z=(sin(a) + sin(3.0*a)/3.0+ cos(9.0*a)/9.0 )*10.0+sin(a)*8.0;\n    //+(cos(13.0*a)/13.0+ sin(19.0*a)/19.0)*5.0;\n    //+(sin(13.0*a)/13.0+ cos(19.0*a)/19.0)*5.0;\n    //lightPos.x=(cos(a) + cos(3.0*a)/3.0    + cos(7.0*a)/7.0 + cos(9.0*a)/9.0)*12.0;\n    //lightPos.z=(sin(a) + sin(3.0*a)/3.0    + sin(7.0*a)/7.0 + sin(9.0*a)/9.0)*12.0;\n    return vec3(x,2.5,z);\n}\n\nmat3 rotateAt(vec3 e, vec3 c, vec3 u) {\n  vec3 z=normalize(e-c);\n  vec3 x=normalize(cross(u,z));\n  vec3 y=normalize(cross(z,x));\n  return mat3(x,y,z);\n}\n\nmat3 lookRot(float yaw,float pitch) {\n    vec2 s=vec2(sin(pitch),sin(yaw));\n    vec2 c=vec2(cos(pitch),cos(yaw));\n    return mat3(c.y,0.0,-s.y,s.y*s.x,c.x,c.y*s.x,s.y*c.x,-s.x,c.y*c.x);\n}\n\n#define PI 3.14159265359\n\nfloat atan2(float y,float x) {\n    if(x>0.0) {\n        return atan(y/x);\n    } else if(y>0.0) {\n        return PI/2.0-atan(x/y);\n    } else if(y<0.0) {\n        return -PI/2.0 -atan(x/y);\n    } else if(x<0.0) {\n        return atan(y/x)+PI;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ms = iMouse.xy / iResolution.xy;\n    float aspect=iResolution.x/iResolution.y;\n    float fovy=0.7854;\n\n    float lightAngle=iTime*0.05;\n    vec3 lightPos=calcLightPos(lightAngle);\n\n    vec3 lightAtten=vec3(0.55,0.0001,0.01);\n    vec3 lightCol=vec3(1.0,0.9,0.8);\n\n    vec3 prevLightPos0=calcLightPos(lightAngle-0.7);\n    vec3 prevLightPos1=calcLightPos(lightAngle-0.2);\n\n    vec2 dd= normalize(prevLightPos1.xz-prevLightPos0.xz);\n\n    vec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.5,0.5):ms;//centre view when mouse.xy=0.0,0.0\n\n    float pitch=ms2.y*2.0-1.0;\n    float yaw=-(ms2.x*2.0-1.0)*2.0;// + atan2(dd.x,dd.y)+PI;\n    \n    mat3 at=rotateAt(prevLightPos0,prevLightPos1,vec3(0.0,1.0,0.0));\n    mat3 look=lookRot(yaw,pitch);\n    mat3 viewRot=at*look;\n\n    vec3 ro=prevLightPos0;\n    vec3 rd=viewRot*calcPrimaryRay(uv*2.0-1.0,fovy,aspect);\n\n    vec3 c=render(ro,rd,lightPos,lightAtten,lightCol,fragCoord);\n\n    //c=mix(c,vec3(1.0),step(floor(length(abs(fragCoord-iMouse.xy)-vec2(4.0))),0.0));\n\tc=mix(c,vec3(1.0),step(abs(floor(length(abs(fragCoord-iMouse.xy)))-4.0),1.0));\n    fragColor = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}]}