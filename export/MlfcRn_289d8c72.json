{"ver":"0.1","info":{"id":"MlfcRn","date":"1503040598","viewed":180,"name":"ray marcher","username":"archibate","description":"a simple ray marcher based on physical princles.\nnew version of the old one at https://www.shadertoy.com/view/4tfyRn\nrefs:\nhttps://www.shadertoy.com/view/XlKSDR\nhttp://blog.csdn.net/carbonsunsu/article/details/6398628\ncool?","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","phong","ray","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*{{{*\\ vim: ft=glsl ts=4 sts=4 sw=4 ai et fdm=marker\n *\n * Copyfuck (C) 2017 archibate <207773419@qq.com>\n * \n * All Fuck Reserved\n *\n\\*}}}*/\n\n#define BLINN_PHONG\n#define PI 3.1415926525897\n#define INF 2e4\n#define BIF 1e3\n#define DPS 6e-4\n#define DPS2 1e-3\n#define EPS 4e-4\n\nvoid rotate(inout vec3 v, vec2 a);\nvec4 iUnion(vec4 t, vec4 u);\nvec4 iInter(vec4 t, vec4 u);\nvec4 iSphere(vec3 p, float r, vec3 d);\nvec4 iPlaneNH(vec3 n, float h, vec3 d);\nfloat sdSphere(vec3 p, float r);\nfloat sdBox(vec3 p, vec3 b);\n\n#define sdUnion min\n#define sdInter max\n\n/* main program */\n\nfloat sdScene(vec3 p)\n{\n    float sd = INF;\n    /*************     Geometry  |       center         |    size          | */\n    //sd = sdUnion(sd, sdBox(      p-   vec3(.0,-1.5,.0)  ,  vec3(1.,1.,1.)  ));\n    sd = sdUnion(sd, sdSphere(   p-   vec3(.0,-1.5,.0)    ,  .8              ));\n    sd = sdUnion(sd, sdSphere(   p-   vec3(.0,.1,.0)    ,  .8              ));\n    return sd;\n}\n\n\nfloat rayScene(out float h, inout vec3 p, in vec3 d, int ni)\n{\n    float t = 0.;\n    for (int i = 0; i < ni; i++) {\n        h = sdScene(p);\n        if (h >= INF)\n            break;\n        if (h < DPS)\n            break;\n        t += h;\n        p += d * h;\n    }\n    return t;\n}\n\nvec3 getNorm(vec3 p)\n{\n    return normalize(vec3(\n        sdScene(p + vec3(DPS2,0,0))\n        - sdScene(p - vec3(DPS2,0,0)),\n        sdScene(p + vec3(0,DPS2,0))\n        - sdScene(p - vec3(0,DPS2,0)),\n        sdScene(p + vec3(0,0,DPS2))\n        - sdScene(p - vec3(0,0,DPS2))) / DPS2);\n}\n\nvec3 render(vec3 p, vec3 d, vec3 light, vec3 dark, vec3 bright)\n{\n    vec3 color = vec3(0.);\n    vec3 clr_left = vec3(1.);   /* color strength during reflections */\n    \n    for (int dep = 0; dep < 3; dep++) {\n        float h;\n        float t = rayScene(h, p, d, 100);\n        \n        vec3 clr = texture(iChannel0, d).rgb;\n        if (h < DPS) {     /* hit something */\n            \n            /* N is the normal vector of current vertex */\n            vec3 N = getNorm(p);\n\n\n            /* V is pointing from vertex towards eye */\n            vec3 V = -d;\n            /* L is the light direction */\n            vec3 L = normalize(light - p);\n            /* NoL is N dot L */\n            float NoL = dot(N, L);\n            /* R is the reflected ray direction */\n            vec3 R = normalize(max(2. * NoL, 0.) * N - L);\n            /* k_s is the specular reflectiveness of material */\n            /* n_s is shineness of material */\n            float n_s = 50.;\n            /* i_l is the light source irrdiance */\n            float i_l = 3. / dot(L, L);  // I' = I / |L|^2\n#ifdef BLINN_PHONG\n            /* phong_val is N dot H, according to Blinn-Phong */\n            float phong_val = dot(N, normalize(L + V));\n#else\n            /* phong_val is V dot R, according to Phong */\n            float phong_val = dot(V, R);\n#endif\n            /* i_spec is the specular irrdiance */\n            float i_spec = i_l * pow(max(phong_val, 0.), n_s);\n            /* now, adding some CaCO3 */\n            i_spec = 1. - mix(1. - max(NoL, 0.), 1. - i_spec, .4);\n            clr = vec3(0.);//mix(dark, bright, i_spec);\n            /* foggy effect */\n            clr = mix(dark, clr, exp(-.03 * t * t));\n            \n        \td = reflect(d, N);//normalize(d - 2. * dot(N, d) * N);\n            p += DPS2 * d;\n        }\n        \n        color += clr * clr_left;\n        clr_left *= .8;  /* reflectiveness */\n        \n        if (h >= DPS)   /* didn't hit any */\n            break;\n    }\n    \n    return color;//return vec3(.5 + .5 * sin(iTime + iMouse.x / iResolution.x));//return color;\n}\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = -1. + 2. * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 light = vec3(3.,8.,0.);\n\n    vec3 pos = vec3(.0,.8,.0);\n    vec3 target = vec3(.0,.0,.0);\n\n    float angle = iTime + iMouse.x / iResolution.x;\n    pos.x += 2.1 * cos(angle);\n    pos.z += 2.1 * sin(angle);\n\n    mat3 cam = setCamera(pos, target, 0.);\n    vec3 dir = cam * normalize(vec3(p.xy, 2.));\n\n    vec3 dark = vec3(.05, .1, .15);\n    vec3 bright = vec3(1., .9, .8);\n\n    vec3 color = render(pos, dir, light, dark, bright);\n\n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n\n/**** geometries ****/\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.));\n}\n\nfloat sdPlaneNH(vec3 n, float h, vec3 p)\n{\n    return dot(n, p) + h;\n}\n\nvec4 iSphere(vec3 p, float r, vec3 d)\n{\n    float b = -dot(p, d);\n    float det = b * b - dot(p, p) + r * r;\n    if (det < 0.)\n        return vec4(vec3(0.), INF);\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t <= EPS) {\n        t = b - det;\n        if (t <= EPS)\n            return vec4(vec3(0.), INF);\n    }\n    return vec4(normalize(p + t * d), t);\n}\n\nvec4 iPlaneNH(vec3 n, float h, vec3 d)\n{\n    float t = h / -dot(n, d);\n    if (t < EPS)\n        return vec4(vec3(0.), INF);\n    return vec4(n, t);\n}\n\nvec4 iUnion(vec4 t, vec4 u)\n{\n    return t.w < u.w ? t : u;\n}\n\nvec4 iInter(vec4 t, vec4 u)\n{\n    return t.w > u.w ? t : u;\n}\n\n/**** vector operations ****/\n\nvoid rotate(inout vec3 v, vec2 a)\n{\n\tv.yz = cos(a.y) * v.yz + sin(a.y) * vec2(-1,1) * v.zy;\n\tv.xz = cos(a.x) * v.xz + sin(a.x) * vec2(-1,1) * v.zx;\n}\n","name":"Image","description":"","type":"image"}]}