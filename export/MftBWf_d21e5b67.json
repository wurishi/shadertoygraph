{"ver":"0.1","info":{"id":"MftBWf","date":"1733600130","viewed":65,"name":"Pytom's Planet","username":"pytom","description":"This is a little planet","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 fade(vec3 t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat permute(float x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nvec3 permute(vec3 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// Gradient Noise function\nfloat cnoise(vec3 P) {\n    vec3 Pi = floor(P);\n    vec3 Pf = fract(P);\n    vec3 Pf0 = Pf - vec3(0.0);\n    vec3 Pf1 = Pf - vec3(1.0);\n    vec4 ix = vec4(Pi.x, Pi.x + 1.0, Pi.x, Pi.x + 1.0);\n    vec4 iy = vec4(Pi.y, Pi.y, Pi.y + 1.0, Pi.y + 1.0);\n    vec4 iz0 = vec4(Pi.z, Pi.z, Pi.z, Pi.z);\n    vec4 iz1 = vec4(Pi.z + 1.0, Pi.z + 1.0, Pi.z + 1.0, Pi.z + 1.0);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = fract(ixy0 / 7.0) * 2.0 - 1.0;\n    vec4 gy0 = abs(gx0) - 0.5;\n    vec4 gz0 = vec4(0.5) - abs(vec4(gx0.x, gx0.y, gx0.z, gx0.w) + gy0);\n    gx0 -= floor(gx0 + 0.5);\n\n    vec4 gx1 = fract(ixy1 / 7.0) * 2.0 - 1.0;\n    vec4 gy1 = abs(gx1) - 0.5;\n    vec4 gz1 = vec4(0.5) - abs(vec4(gx1.x, gx1.y, gx1.z, gx1.w) + gy1);\n    gx1 -= floor(gx1 + 0.5);\n\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g100, g100), dot(g010, g010), dot(g110, g110)));\n    g000 *= norm0.x;\n    g100 *= norm0.y;\n    g010 *= norm0.z;\n    g110 *= norm0.w;\n\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g101, g101), dot(g011, g011), dot(g111, g111)));\n    g001 *= norm1.x;\n    g101 *= norm1.y;\n    g011 *= norm1.z;\n    g111 *= norm1.w;\n\n    vec4 n0 = vec4(dot(g000, Pf0), dot(g100, vec3(Pf1.x, Pf0.yz)), dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)), dot(g110, vec3(Pf1.xy, Pf0.z)));\n    vec4 n1 = vec4(dot(g001, vec3(Pf0.xy, Pf1.z)), dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z)), dot(g011, vec3(Pf0.x, Pf1.yz)), dot(g111, Pf1));\n\n    vec3 fade_xyz = fade(Pf);\n    vec4 n_x = mix(n0, n1, fade_xyz.z);\n    vec2 n_xy = mix(n_x.xy, n_x.zw, fade_xyz.y);\n    float n_xyz = mix(n_xy.x, n_xy.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat radius = 0.5;\nfloat earthRotatingSpeed = 0.0;\nfloat sunRotatingSpeed = 1.0;\nfloat sunIntensity = 1.0;\nfloat planetTurningSpeed = 0.9;\nfloat residualLight = 0.04;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy* 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float resizedRadius = radius*(1.0+texelFetch(iChannel0, ivec2(0, 0), 0).r);\n    \n    float mask = 1.0 - step(resizedRadius, length(uv));\n    \n    vec2 pos = uv/resizedRadius;  \n    \n    vec3 normal = mask*((vec3(pos.x, pos.y, sqrt(1.0-pow(pos.x, 2.0)-pow(pos.y, 2.0)))+ 1.0)* 0.5);\n    \n    float earthRotation = earthRotatingSpeed*iTime;\n    vec3 unrotatedSpherePos = normal;\n    vec3 spherePos;\n    spherePos.x = unrotatedSpherePos.x*cos(earthRotation) - unrotatedSpherePos.z*sin(earthRotation);\n    spherePos.y = unrotatedSpherePos.y;\n    spherePos.z = unrotatedSpherePos.x*sin(earthRotation) + unrotatedSpherePos.z*cos(earthRotation);\n    \n    float height = cnoise(5.0*spherePos) + 0.2*cnoise(10.0*spherePos) + 0.05*cnoise(50.0*spherePos);\n    vec3 groundCol = vec3(0.11, 0.78, 1.0);\n    vec4 cityLightCol = vec4(0.0, 0.0, 0.0, 0.0);\n    if (height > 0.8) {\n        groundCol = vec3(0.93, 0.93, 0.93); // Snow\n    } else if (height > 0.6) {\n        groundCol = vec3(0.64, 0.64, 0.64); // Rocks\n    } else if (height > 0.22) {\n        groundCol = vec3(0.294, 0.831, 0.251); // Grass\n        float cityness = 1.0-step(cnoise(25.0*spherePos), 0.4);\n        float cityLightsIntensity = cityness * cnoise(1000.0*spherePos);\n        if (cityness > 0.01) {\n            groundCol = vec3(0.369, 0.263, 0.263); // Building\n        }\n        if (cityLightsIntensity > 0.01) {\n            cityLightCol = vec4(cityLightsIntensity, cityLightsIntensity, 0.0, 1.0);\n        }\n    } else if (height > 0.1) {\n        groundCol = vec3(1.0, 0.933, 0.31); // Sand\n    }\n    groundCol *= mask;\n    \n    vec3 sunDirection = vec3(cos(sunRotatingSpeed*iTime), 0.0, sin(sunRotatingSpeed*iTime));\n    \n    float sunPower = ((1.0-residualLight) * max(dot(normal, sunDirection), 0.0) + residualLight) * sunIntensity;\n    groundCol *= sunPower;\n    cityLightCol.rgb *= smoothstep(0.4, 0.2, sunPower);\n\n    // Output to screen\n    fragColor = vec4(groundCol, 1.0) + cityLightCol;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}