{"ver":"0.1","info":{"id":"MlVSDD","date":"1484494359","viewed":138,"name":"planets","username":"sanctify","description":"planets","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["planets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T iTime\n\n// Falloff : attenuation en fonction de la distance\n// x : distance\n// r : distance limite\n// a : coefficient de ponderation\nfloat Falloff(in float x,in float r,in float a)\n{\n    if (x<r)\n    {\n        float t = x / r;\n        return a*(1.0-t*t)*(1.0-t*t)*(1.0-t*t);\n    }\n    else \n    {\n        return 0.0;\n    }\n}\n\n// Cercle\n// c  : Centre\n// r  : Rayon\n// cc : Couleur cercle\n// uv : position pixel\nvec4 Circle(in vec2 c,in float r,in vec4 cc, in vec2 uv)\n{\n  float l=length(uv-c);\n  \n  // Dans le cercle si distance < rayon\n  if (l<r)\n  {\n    return Falloff(l,r,1.0)*cc;\n  }\n  // Else ancienne couleur\n  else\n  {\n    return vec4(0.0);\n  }\n}\n\n// Cercle\n// c  : Centre\n// r  : Rayon\n// cc : Couleur cercle\n// uv : position pixel\n// old : ancienne couleur\nvec4 Trajectoire(in vec2 c,in float r,in vec4 cc, in vec2 uv)\n{\n  float l=length(uv-c);\n  \n  if (l<r)\n  {\n      if (abs(l-r)<1./iResolution.y)\n     {\n     \treturn vec4(1.0,1.0,1.0,1.0);\n     }\n     else{\n      \treturn vec4(0.0);\n     }\n  }\n  else{\n    return vec4(0.0);\n  }\n}\n\nvec2 RandomPoint(in float k)\n{\n    vec2 vec = vec2(cos(350.0*k),sin(225.0*k));\n        return vec;\n}\n\nfloat RandomRadius(in float k)\n{\n    return 0.25+0.125*sin(258.5*k);\n}\nfloat RandomOffset(in float k)\n{\n    return 3.14*(1.0+sin(158.5*k));\n}\n\n\nbool isOnEllipse(vec2 uv, vec2 c, vec2 dim, float angle,float deltaX, float deltaY)\n{\n    uv *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    uv.x -= deltaX;\n    uv.y += deltaY;\n\tc = pow(abs(uv - c)/ dim, vec2(2));\n\tfloat d = c.x/0.45 + c.y/0.90;\n    return d < 1. && d > .98;\n}\n\n// Image \nvoid mainImage( out vec4 c, in vec2 p )\n{\n  //ellipse parameters \n   vec2 uv = 2. * p / R - 1.;\n   uv.x *= R.x / R.y;\n   c.rgb = vec3(0);\n   vec2 center = vec2(0, 0);\n   vec2 dim = vec2(.5, 1); \n\n    \n  // Coordonnées sur [.,.] x [-0.5,0.5]\n  uv = (p.xy-iResolution.xy/vec2(1.25)) / iResolution.y;\n\n  vec2 q=RandomPoint(2.0)+0.125;\n  //Creation du soleil\n  c = c+Circle(q,0.45,vec4(1.0,0.85,0.0,1.0),uv-0.25);\n  c= c+Trajectoire(q,0.34,vec4(1.0,0.85,0.0,1.0),uv-0.25);\n    \n  //Génération des ellipses \n  if (isOnEllipse(uv, center-0.15, dim*.425, 0.75,0.02,0.225)){\n      c.rgb = vec3(1, 1, 1);\n  }\n  if (isOnEllipse(uv, center-0.15, dim*.425, 0.75,0.02,0.575)){\n      c.rgb = vec3(1, 1, 1);\n  }\n  //Fin de génération des Ellipses\n\n    \n  //Planete Bleue\n  q=RandomPoint(2.0) + RandomRadius(1.25)*vec2(sin(1.25*T),cos(1.25*T+RandomOffset(2.0)));\n  c = c+Circle(q+0.25,0.05,vec4(0.0,0.0,1.0,1.0),uv-0.25);\n  \n    \n  //Planete rose\n  q=RandomPoint(2.0) + RandomRadius(1.25)*vec2(sin(1.125*T),cos(1.125*T+RandomOffset(2.0)));\n  c = c+Circle(q+0.25,0.05,vec4(0.55,0.0,1.0,1.0),uv);\n\n    \n  //Planete verte + orbite + satellite\n  q=RandomPoint(2.0)+0.125;\n  q=q + RandomRadius(1.0)*vec2(sin(0.75*T),cos(0.75*T+RandomOffset(1.0)));\n  c = c+Circle(q+0.25,0.15,vec4(0.0,1.0,0.0,1.0),uv);\n  c= c+Trajectoire(q+0.25,0.15,vec4(0.0,1.0,0.0,1.0),uv);\n    \n  q=q + RandomRadius(-0.125)*vec2(sin(5.5*T),cos(5.5*T+RandomOffset(1.0)));  \n  c = c+Circle(q+0.25,0.025,vec4(0.0,1.0,0.0,1.0),uv);\n    \n}","name":"Image","description":"","type":"image"}]}