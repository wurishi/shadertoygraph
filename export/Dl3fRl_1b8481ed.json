{"ver":"0.1","info":{"id":"Dl3fRl","date":"1701453258","viewed":136,"name":"Hexagon Sampling/Tiling/Grid","username":"Mirza","description":"Implementation of the various uses of hexagonal lattices.\nGreat for procedural sci-fi/futuristic effects, like shields and portals :)\n\nClick around with the mouse to highlight tiles, change tiling scale, and offset the scan effect.","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["example","grid","sdf","hexagon","hex","tile","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mirza: Example of hexagonal sampling and animation.\n// I made this largely for my own learning, but hopefully it can help others.\n\n// https://twitter.com/TheMirzaBeig/status/1731324791557140490\n\n// See links for [re]sources and more detailed explanations.\n\n// Not used, but a good read:\n// > https://www.redblobgames.com/grids/hexagons/\n\n#define FLAT_TOP_HEXAGON\n\n// https://www.shadertoy.com/view/wtdSzX\n\n// Note from original author:\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n\n// MB: This special right-angle triangle (30-60-90°) is just half an equilateral ('regular') triangle (all sides = 60°).\n\n// https://en.wikipedia.org/wiki/Equilateral_triangle\n\n#ifdef FLAT_TOP_HEXAGON\n    const vec2 s = vec2(sqrt(3.0), 1.0);\n#else\n    const vec2 s = vec2(1.0, sqrt(3.0));\n#endif\n\nfloat Hex(in vec2 p)\n{    \n    p = abs(p);    \n    \n    #ifdef FLAT_TOP_HEXAGON\n        return max(dot(p, s * 0.5), p.y);\n    #else\n        return max(dot(p, s * 0.5), p.x);\n    #endif  \n}\n\n// xy = 2D distance in each cell. Use with Hex() to get hexagon shape.\n// zw = hexagonal-quantized UV coordinates (cell ID).\n\n// MB: See, https://andrewhungblog.wordpress.com/2018/07/28/shader-art-tutorial-hexagonal-grids/\n\n// Essentially rows of points, where every other row is shifted.\n// https://blender.stackexchange.com/questions/161701/how-to-do-uv-indexing-in-hexagonal-pattern\n\nvec4 HexLattice(vec2 uv)\n{     \n    // MB: Using round (vs. floor), removing need for + 0.5.\n    \n    #ifdef FLAT_TOP_HEXAGON\n        vec4 hexCenter = round(vec4(uv, uv - vec2(1.0, 0.5)) / s.xyxy);\n    #else\n        vec4 hexCenter = round(vec4(uv, uv - vec2(0.5, 1.0)) / s.xyxy);\n    #endif    \n    \n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + 0.5) * s);\n     \n    return\n     \n    dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ?     \n    vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw + 0.5); \n}\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define PI 3.14159\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1.0/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\n// Render.\n\nfloat Glow(float sdf, float width, float power)\n{\n    return pow(width / sdf, power);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized UVs and mouse.\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;    \n    \n    // Tiling between range, with mouse as input.\n    \n    float tiling = mix(8.0, 32.0, mouse.x);\n    \n    vec2 hexTiling = vec2(tiling);\n    hexTiling.x *= aspectRatio;\n    \n    vec2 hexUV = uv * hexTiling;\n    vec2 hexMouse = mouse * hexTiling;\n    \n    vec4 hexGrid = HexLattice(hexUV);    \n    vec4 hexGridOriginal = hexGrid;\n        \n    vec3 colour;\n        \n    #ifdef FLAT_TOP_HEXAGON\n        hexGrid.z *= aspectRatio;\n    #else\n        hexGrid.w *= aspectRatio;\n    #endif \n        \n    vec2 hexGridUV = hexGrid.zw / hexTiling;\n    vec2 hexGridOriginalUV = hexGridOriginal.zw / hexTiling;\n\n    #ifndef FLAT_TOP_HEXAGON    \n        hexGridUV *= vec2(1.0, 0.975);    \n    #endif\n        \n    colour.xy = hexGridUV.xy;\n    \n    // Z is just wild.\n    \n    colour.z = uv.y * (abs(sin(iTime * 10.0)) * 5.0);\n    \n    // Get distance field.\n    // Used as an animated hexagonal mask with a tiling scan.\n        \n    float hex = Hex(hexGrid.xy) * 2.0;\n    \n    float scanSpeed = 1.0;\n    \n    // Tiling scan (hexGridOriginal.w), as opposed to using uv.y.\n    \n    float noiseTiling = 2.0;\n    vec2 noiseAnimation = vec2(-2.0, -2.0);        \n    \n    float animatedNoise = noise(hexGrid.zw + vec2(noiseAnimation * iTime), noiseTiling);\n    \n    float scanBase = hexGridOriginalUV.y;\n    \n    // For a wild effect.    \n    //scanBase *= hexGridOriginal.z; \n    \n    // For a wipe effect.    \n    //scanBase *= hexGridOriginal.z / tiling;\n    \n    // Offset scan up/down (using hex-quantized noise).\n    \n    scanBase += animatedNoise * 0.2;\n    scanBase += sin(hexGridUV.x * 64.0) * 0.05;\n    \n    // Repeating scan animation (using fract), with vertical mouse input.\n    \n    float scan = fract(scanBase + (iTime * scanSpeed) + mouse.y);\n        \n    colour *= step(smoothstep(0.0, 0.7, scan), 1.0 - hex);\n    \n    // Apply noise.\n        \n    colour *= animatedNoise;\n    \n    // Highlight mouse tile.\n    \n    if (hexGridOriginal.zw == HexLattice(hexMouse).zw)\n    {\n        vec3 glowColour = vec3(0.5, 0.1, 1.0);\n        colour = Glow(hex, 0.5, 5.0) * glowColour; \n    }  \n    \n    // Mix with texture. Use either iChannel [0] or [1].\n    \n    vec3 textureColour = texture(iChannel0, hexGridUV).rgb;\n    colour = mix(colour, textureColour, 0.3);\n\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}