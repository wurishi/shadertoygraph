{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define DIST_MAX 200.\n//#define SOFT\n\n\nvec3 diffuse = vec3(.9,.02,.01);\nvec3 specular = vec3(.3,.3,.3);\nvec3 intensity = vec3(.95, .95, .95);\nvec3 ambient = vec3(.05,.05,.05);\nvec3 bg = vec3(.9,.9,.9);\nfloat atten = 0.03;\nfloat shininess = .04;\n\nfloat sdSphere ( in vec3 centre, in vec3 pos, in float r ){\n\treturn length(pos - centre) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 planeP, vec3 planeN )\n{\n  return dot(p - planeP, planeN);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdfMap(in vec3 p)\n{\n    //return min(sdSphere(vec3(0.,0.,0.), p, .5), sdPlane(p, vec3(0.,-1.,0.), vec3(0.,1.,0.)));\n    \n    vec3 c = vec3(15,20,15);\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere(vec3(0.,0.,0.), q, 3.);\n\n}\n\nvec3 getNorm(in vec3 p)\n{\n\tvec3 e = vec3(0.001, 0., 0.);\n    vec3 norm = vec3\n        (sdfMap(p+e.xyy) - sdfMap(p-e.xyy),\n         sdfMap(p+e.yxy) - sdfMap(p-e.yxy),\n         sdfMap(p+e.yyx) - sdfMap(p-e.yyx));\n   \treturn normalize(norm);\n}\n\nvec3 castRay(in vec3 rd, in vec3 p, in float tmax)\n{\n    float tmin = .1;\n    float precis = 0.0002;\n    float d = 0.;\n    float steps = 0.;\n    \n    float t = tmin;\n    for(int i = 0; i < 200; i++){\n        d = sdfMap(p + t*rd);\n        if( t > tmax || d < precis) break;\n        t += d;\n        steps++;\n    }\n    \n    if(t > tmax) d = -1.0;\n    return vec3(t, d, steps);\n}\n\nfloat shadow(in vec3 rd, in vec3 p, in float tmax)\n{\n    float tmin = .1;\n    float precis = 0.01;\n    \n    float d = 0.;\n    float dmin = 1.;\n    \n    float t = tmin;\n    for(int i = 0; i < 100; i ++){\n     \td = sdfMap(p + rd * t);\n        if(d < precis) return 0.;\n        if(t > tmax) break;\n        #ifdef SOFT\n        \tdmin = min(dmin, 50. * d/t);\n        #endif\n        t += d;\n    }\n    \n    #ifdef SOFT\n    \treturn dmin;\n    #else\n    \treturn 1.;\n    #endif\n}\n\n// Function takes normal and ray direction,\n// returns light shaded color\nvec3 shade(in vec3 camPos, in vec3 pos, in vec3 normal, in vec3 rd){\n    vec3 lightPos = vec3(0.,camPos.y, 20. + 20. * sin(iTime));\n    vec3 lightDiff = lightPos - pos;\n    vec3 lightDir = normalize(lightDiff);\n    \n    // Standard light\n    float angOfInc = dot(normal, lightDir);\n    angOfInc = step(angOfInc, 1.);\n    \n    // Specular component - was gaussian before I made this toony\n    // Probably simpler ways to do this\n    vec3 halfAngle = normalize(lightDir - rd);\n    float angleNormalHalf = acos(dot(halfAngle, normal));\n    float exponent = angleNormalHalf/shininess;\n    exponent = -pow(exponent, 2.);\n    float gaussian = exp(exponent);\n    gaussian = step(shininess, gaussian);\n    \n    //Attenuation\n    float distSquared = dot(lightDiff, lightDiff);\n    intensity *= (1.0 / (1.0 + atten * sqrt(distSquared)));\n    \n    //Edge Lines\n    vec3 camDir = normalize(camPos - pos);\n    float dist = length(camPos - pos);\n    float c = mix(.25, .5, dist / DIST_MAX);\n    if(dot(normal, camDir) < c ){\n       diffuse = vec3(0.,0.,0.);\n       specular = vec3(0.,0.,0.);\n    }\n    \n    //Shadows\n    float s = shadow(lightDir, pos, length(lightDiff));\n    intensity *= s;\n    \n    vec3 color =(intensity * diffuse * angOfInc)\n        \t+ (intensity * specular * gaussian)\n        \t+ (ambient * diffuse)\n            ;\n    \n    return color;\n}\n\nvec3 rayMarch(in vec3 rd, in vec3 p)\n{\n    vec3 col;\n\n\tvec3 res = castRay(rd, p, DIST_MAX);\n    float t = res.x;\n    float d = res.y;\n\n    if(d > -0.5){\n        vec3 pos = p + t*rd;\n        vec3 norm = getNorm(pos);\n        vec3 ref = normalize(reflect(rd, norm));\n        \n        col = shade(p, pos, norm, rd);\n        col = pow( col, vec3(1.0/2.2) );\n        col = mix( col, bg, smoothstep(100., 200., t));//clamp(t / 190.0,0.,1.) );\n        //col = mix( col, bg, 1.-exp(-.005*t) );\n        //col = mix( col, bg, clamp(res.z / 70.0,0.,1.) );\n        \n    \n    }else{\n        col = bg;\n    }\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 rayDir(in vec2 uv, out vec3 camPos)\n{\n    float radius = 1.;\n    float theta = sin(iTime / 2.);\n    \n    float camZ = radius * cos(theta);\n    float camX = radius * sin(theta);\n    \n    //camera frame setup\n    vec3 target = vec3(0.,iTime * 3.,0.);\n    camPos = target + vec3(camX, 0., -camZ);\n    \n    vec3 up = vec3(0,1,0);\n    vec3 fo = normalize(target - camPos);\n    vec3 ri = normalize(cross(fo, up));\n    \n    float fov = .5;\n    \n    //Calcuate rayDir\n    vec3 rayDir = normalize(fo + fov*uv.x*ri + fov*uv.y*up);\n    \n    return rayDir;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pp = (-1.0 + 2.0*uv);\n    pp.x *= iResolution.x / iResolution.y;\n    \n\tvec3 camPos;\n    vec3 rd = rayDir( pp, camPos );\n    fragColor.xyz = rayMarch(rd, camPos);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lll3W2","date":"1425399712","viewed":298,"name":"Toon Spheres","username":"DeathOfRats","description":"First ray march attempt. Thanks to huwb for his help talking me through the abstract stuff behind ray marching in general. Also nicked a few things from iq's website. (quite a few things)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""}}