{"ver":"0.1","info":{"id":"3lt3W7","date":"1579066797","viewed":790,"name":"Winter Cabin","username":"suyoku","description":"Thomas Kinkade inspired winter cabin scene. First time going this in-depth with an SDF ShaderToy so anything clever here is really just stolen from IQ as this was more of a learning exercise.\n","likes":54,"published":1,"flags":32,"usePreview":1,"tags":["wintercabin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define KERNEL_SIZE 9\n\nvoid DecompressColor(in vec4 color, out vec3 diffuseColor, out vec3 specularColor, out float depth, out int materialID)\n{\n    depth = fract(color.w);\n    materialID = int(color.w - depth);\n\tdepth *= SCENE_MAX_T; \n    \n    diffuseColor = fract(color.rgb);\n    specularColor = (color.rgb - diffuseColor) / 1000.0;\n} \n\nfloat GaussianCurve(float x, float stdDev)\n{\n    return exp(-(x * x) / (2.0 * stdDev * stdDev)) / (sqrt(2.0 * PI) * stdDev);\n}\n\nvec3 GammaCorrect(in vec3 color)\n{\n    return pow( color, vec3(1.0 /2.2) );\n}\n\nvec3 Vignette(in vec3 color, in vec2 uv)\n{\n    // Don't vignette the top because that takes \n    // away from the aurora borealis\n    float distToEdge = min(\n        min(uv.x, 1.0 - uv.x),\n        uv.y);\n    return mix(color * 0.3, color, min(distToEdge / 0.12, 1.0));\n}\n\n#define NO_BLUR 0x0\n#define SNOW_BLUR 0x1\n#define DOF_BLUR 0x2\n#define ICE_BLUR 0x4\n#define DOF_BLUR_START 500.0\n#define DOF_BLUR_GAUSSIAN_STD_DEV 2.1\nint DetermineBlurType(float depth, int materialID)\n{\n    if(depth > DOF_BLUR_START)\n    {\n        return DOF_BLUR;\n    }\n    else if(materialID == SNOW_MATERIAL_ID)\n    {\n        return SNOW_BLUR;\n    }\n    else if(materialID == ICE_MATERIAL_ID)\n    {\n        return ICE_BLUR;\n    }\n    else\n    {\n        return NO_BLUR;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelUVOffset = 1.0 / iResolution.xy;\n    float accumulatedWeight = 0.0;\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 centerSpecularColor;\n\tvec3 centerDiffuseColor;\n    \n    // Tuned at 800x450, scale gaussian distribution based on how much larger the\n    // current viewport is\n    float gaussianScale = iResolution.x / 800.0;\n\n    float depth;\n    vec3 diffuse, specular;\n    int materialID;\n    DecompressColor(texture(iChannel0, uv), centerDiffuseColor, centerSpecularColor, depth, materialID);\n    int blurType = DetermineBlurType(depth, materialID);\n    \n    if(blurType != NO_BLUR)\n    {\n        for(int x = -KERNEL_SIZE / 2; x <= KERNEL_SIZE / 2; x++)\n        {\n            for(int y = -KERNEL_SIZE / 2; y <= KERNEL_SIZE / 2; y++)\n            {\n                float distFromCenter = sqrt(float(x * x + y * y));\n                vec2 uvOffset = pixelUVOffset * vec2(x, y);\n\n                vec3 diffuse, specular;\n                DecompressColor(texture(iChannel0, uv + uvOffset), diffuse, specular, depth, materialID);\n                \n                bool validPixel = blurType != SNOW_BLUR || (materialID == SNOW_MATERIAL_ID);\n                validPixel = blurType != ICE_BLUR || (materialID == ICE_MATERIAL_ID);\n                if(validPixel)\n                {\n                    float gaussianStdDev;\n                    if(blurType == DOF_BLUR)\n                    {\n                        // Just picking a constant amount that looks good\n                        // Needed something that blurs the trees\n                        // but also leaves some details for the \n                        // aurora borealis in-tact.\n\t\t\t\t\t\tgaussianStdDev = DOF_BLUR_GAUSSIAN_STD_DEV;\n                    }\n                    else\n                    {\n                        // Reduce the blur the further you get as a hack to account for\n                        // perspective\n                        gaussianStdDev = max(7.0 - depth / 50.0, DOF_BLUR_GAUSSIAN_STD_DEV);\n                    }\n                    float gaussianWeight = GaussianCurve(distFromCenter, gaussianStdDev * gaussianScale);\n               \t\taccumulatedWeight += gaussianWeight;\n                \taccumulatedColor += gaussianWeight * diffuse;\n                }\n\n            }\n        }\n    }\n    else\n    {\n        accumulatedWeight = 1.0;\n        accumulatedColor = centerDiffuseColor;\n    }\n    \n    vec3 finalColor = centerSpecularColor + (accumulatedColor / accumulatedWeight);\n\tfragColor = vec4(GammaCorrect(Vignette(finalColor, uv)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14\n#define SCENE_MAX_T 900.0\n\n#define WOOD_MATERIAL_ID 0\n#define SNOW_MATERIAL_ID 1\n#define CABIN_LAMP_MATERIAL_ID 2\n#define ICE_MATERIAL_ID 3\n#define TREE_MATERIAL_ID 4\n#define DISTANT_TREE_MATERIAL_ID 4\n#define LEAF_MATERIAL_ID 5\n#define ROOF_SNOW_MATERIAL_ID 6\n#define NUM_MATERIALS 7\n\n#define CABIN_WINDOW_MATERIAL_CUSTOM_BASE_ID 50\n\n#define INVALID_MATERIAL_ID int(-1)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Christopher Wallis\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n\n#define SKY_LIGHT_COLOR vec3(0.08, 0.16, 0.24)\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 19, 380),\n    vec3(0, 15, 0),\n    2.0,\n    7.0\n);\n\nOrbLightDescription CabinLamp = OrbLightDescription(\n    vec3(35, 5.6, 7.0),\n    1.2,\n    vec3(20.0, 8.0, 0.4));\n\nstruct PointLightDescription\n{\n    vec3 Position;\n    vec3 LightColor;\n};\n\nvec3 AmbientSnowColor = vec3(0, 0, 0.05);\n\n// Pulse the lamp brighness to simulate fireplace-like lighting\nfloat CabinLampMultiplier()\n{\n    float loopTimeLengthMS = 3000.0;    \n    float halfLoopTimeLengthMS = loopTimeLengthMS / 2.0;\n    float lerpValue = float(int(iTime * 1000.0) % int(halfLoopTimeLengthMS)) / (halfLoopTimeLengthMS);\n    bool invertLerp = (int(iTime * 1000.0) / int(halfLoopTimeLengthMS)) % 2 == 1;\n\tif(invertLerp)\n    {\n       lerpValue = 1.0 - lerpValue; \n    }\n    return mix(0.6, 1.2, lerpValue);\n}\n\nstruct AABB\n{\n    vec3 origin;\n    vec3 dimensions;\n};\n\nstruct WindowDescription\n{\n    vec3 Position;\n    vec3 Dimension;\n};\n\n    \n#define NUM_POINT_LIGHTS 3\n#define NUM_CABIN_WINDOWS 5\nstruct CabinDescription\n{\n\tPointLightDescription PointLights[NUM_POINT_LIGHTS];\n};\n    \nconst vec3 CabinOrigin = vec3(40.0, 0.3, -10);\nconst vec3 CabinDimensions = vec3(25, 10, 15);\nconst vec3 CabinZOrientedWindowDimensions = vec3(3.0, 2.5, 0.3);\nconst vec3 CabinXOrientedWindowDimensions = vec3(\n    CabinZOrientedWindowDimensions.z, \n    CabinZOrientedWindowDimensions.y, \n    CabinZOrientedWindowDimensions.x);\nconst float WindowYOffset = 5.0;\nconst AABB CabinAABB = AABB(\n    CabinOrigin,\n    CabinDimensions * vec3(2.0, 3.0, 2.0));\n\nconst vec3 FrontAtticWindowPosition = CabinOrigin + vec3(0, 16, CabinDimensions.z);\nconst vec3 SideMainRoomWindowPosition = CabinOrigin + vec3(CabinDimensions.x, WindowYOffset, 0.0);\nconst vec3 SideAtticRoomWindowPosition = SideMainRoomWindowPosition + vec3(0.0, 11.0, 0.0);\nCabinDescription Cabin = CabinDescription(\n    PointLightDescription[NUM_POINT_LIGHTS] (\n       PointLightDescription(FrontAtticWindowPosition + vec3(0, 0, 4.5), vec3(9.0, 3.3, 0.2)),\n       PointLightDescription(SideMainRoomWindowPosition + vec3(4.0, 0, 0), vec3(12.0, 4.0, 0.2)),\n       PointLightDescription(SideAtticRoomWindowPosition + vec3(4.0, 0, 0), vec3(6.0, 2.2, 0.15))\n\t)\n);\n\n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\nfloat rand(float seed)\n{\n    return fract(sin(seed / 100.0) * 999.999);\n}\n\n// I believe this was written using Scratchapixel as a reference, it's been a while\n// https://www.scratchapixel.com/code.php?id=57&origin=/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2\nvec2 GenerateGradientVector(float x, float y)\n{\n    float resolution = 1024.0;\n    float val = x + y * resolution;\n\tfloat angle = rand(val) * 3.1415;\n    return vec2(cos(angle), sin(angle));\n}\n\n// https://www.scratchapixel.com/code.php?id=57&origin=/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2\nfloat perlin_noise(vec2 pos)\n{\n    float x = pos.x / 32.0;\n    float y = pos.y / 32.0;\n    \n\tfloat value = 0.0;\n    float x0 = floor(x);    \n    float y0 = floor(y);\n\tfloat x1 = x0 + 1.0;\t\n    float y1 = y0 + 1.0;\n    \n    vec2 a = GenerateGradientVector(x0, y0);\n    vec2 b = GenerateGradientVector(x1, y0);\n    vec2 c = GenerateGradientVector(x0, y1);\n    vec2 d = GenerateGradientVector(x1, y1);\n    \n    vec2 aD = vec2(x - x0, y - y0);    \n    vec2 bD = vec2(x - x1, y - y0);\n    vec2 cD = vec2(x - x0, y - y1);\n    vec2 dD = vec2(x - x1, y - y1);\n    \n    float aDot = dot(a, aD);\n    float bDot = dot(b, bD);\n    float cDot = dot(c, cD);\n    float dDot = dot(d, dD);\n    \n    float dx = x - x0;    \n    float dy = y - y0;\n\tfloat sX = 3.0 * dx * dx - 2.0 * dx * dx * dx;\n\tfloat sY = 3.0 * dy * dy - 2.0 * dy * dy * dy;\n    float firstAverage = mix(aDot, bDot, sX);\n    float secondAverage = mix(cDot, dDot, sX);\n    value = mix(firstAverage, secondAverage, y - y0);\n\t\n\treturn ( value + 1.0 ) / 2.0;\n}\n\nfloat PerlinSeries(vec2 pos)\n{\n    return perlin_noise(pos) + 0.4 * perlin_noise(pos * 2.0) + 0.2 * perlin_noise(pos * 4.0);\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=min(0, iFrame); i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n// --------------------------------------------//\n//               SDF Functions\n// --------------------------------------------//\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 Translate(vec3 pos, vec3 translate)\n{\n    return pos -= translate;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 origin, vec3 a, vec3 b, float r )\n{\n  p -= origin;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, vec3 origin, float h, float r )\n{\n\tp -= origin;\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat CappedCylinder( vec3 p, vec3 cylinderOrigin, float h, float r )\n{\n  p = Translate(p, cylinderOrigin);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat BoxIntersect( vec3 p, vec3 boxOrigin, vec3 boxDimensions)\n{\n  p = Translate(p, boxOrigin);\n  vec3 q = abs(p) - boxDimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nvec3 SymetryAcrossXAxis(vec3 pos)\n{\n    pos.x = abs(pos.x);\n    return pos;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat SphereIntersect( vec3 p, vec3 origin, float s )\n{\n  p = Translate(p, origin);\n  return length(p)-s;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec3 origin, vec2 c )\n{\n  p = Translate(p, origin);\n  float q = length(p.xz);\n  return dot(c,vec2(q,p.y));\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat dot2(in vec2 v ) {return dot(v,v);}\nfloat sdCappedCone( vec3 p, vec3 origin, float h, float r1, float r2 )\n{\n  p -= origin;\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// Modified Prism sdf code from https://iquilezles.org/articles/distfunctions\nfloat TriPrism( vec3 p, vec2 h, float angle )\n{\n  float NinetyDegreesInRadians = PI / 2.0;\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*sin(angle)+p.y*sin(NinetyDegreesInRadians - angle),-p.y)-h.x*sin(NinetyDegreesInRadians - angle));\n}\n\nfloat ZAlignedTriPrism( vec3 p, vec3 origin, vec2 h, float angle )\n{\n  p = Translate(p, origin);\n  p.y -= h.x / 2.0;\n  return TriPrism(p, h, angle);\n}\n\n\n// Strange hack required because using a global array causes\n// some strange compiler optimizations to go wrong\nWindowDescription GetWindow(int index)\n{\n    switch(index)\n    {\n        default:\n        case 0:\n        \treturn WindowDescription(FrontAtticWindowPosition, CabinZOrientedWindowDimensions * 0.6);\n        case 1:\n        \treturn WindowDescription(CabinOrigin + vec3(15, WindowYOffset, CabinDimensions.z), CabinZOrientedWindowDimensions);\n        case 2:\n\t\t\treturn WindowDescription(CabinOrigin + vec3(-15, WindowYOffset, CabinDimensions.z), CabinZOrientedWindowDimensions);\n        case 3:\n\t\t\treturn WindowDescription(CabinOrigin + vec3(CabinDimensions.x, WindowYOffset, 0.0), CabinXOrientedWindowDimensions);\n\t\tcase 4:\n        \treturn WindowDescription(SideAtticRoomWindowPosition, CabinXOrientedWindowDimensions * 0.6);\n    }\n}\n\n#define MATERIAL_NEEDS_REFLECTION_RAYS 0x1\n#define MATERIAL_IS_LIGHT_SOURCE 0x2\n#define MATERIAL_NO_SPECULAR 0x4\n#define MATERIAL_IS_SNOW 0x8\n#define MATERIAL_SUPPORTS_SPECULAR_LIGHT 0x10\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n    int flags;\n};\n    \nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, vec3(0), flags);\n}\n\nbool NeedsReflectionRays(in Material m)\n{\n    return (m.flags & MATERIAL_NEEDS_REFLECTION_RAYS) != 0;\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nbool IsSnow(in Material m)\n{\n    return (m.flags & MATERIAL_IS_SNOW) != 0;\n}\n\nbool SupportsSpecular(in Material m)\n{\n    return (m.flags & MATERIAL_NO_SPECULAR) == 0;\n}\n\n\nbool SupportsSpecularLight(in Material m)\n{\n    return (m.flags & MATERIAL_SUPPORTS_SPECULAR_LIGHT) != 0;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[SNOW_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), MATERIAL_NO_SPECULAR | MATERIAL_SUPPORTS_SPECULAR_LIGHT | MATERIAL_IS_SNOW);\n    materials[ROOF_SNOW_MATERIAL_ID] = NormalMaterial(vec3(0.8, 0.8, 1.3), MATERIAL_SUPPORTS_SPECULAR_LIGHT | MATERIAL_IS_SNOW);\n    materials[WOOD_MATERIAL_ID] = NormalMaterial(vec3(0.2, 0.1, 0.05), MATERIAL_NO_SPECULAR);\n\tmaterials[CABIN_LAMP_MATERIAL_ID] = NormalMaterial(CabinLamp.LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    materials[ICE_MATERIAL_ID] = NormalMaterial(vec3(0.05, 0.05, 0.1), MATERIAL_NEEDS_REFLECTION_RAYS);\n    materials[TREE_MATERIAL_ID] = NormalMaterial(vec3(0.1, 0.1, 0.0), 0);\n    materials[DISTANT_TREE_MATERIAL_ID] = NormalMaterial(vec3(0.03, 0.03, 0.0), MATERIAL_NO_SPECULAR);\n    materials[LEAF_MATERIAL_ID] = NormalMaterial(vec3(0.1, 0.1, 0.0), MATERIAL_NO_SPECULAR);\n    \n    if(materialID < int(NUM_MATERIALS))\n    {\n        return materials[materialID];\n    }\n    else // Is a custom material\n    {\n\t\tif(materialID >= int(CABIN_WINDOW_MATERIAL_CUSTOM_BASE_ID) && materialID < int(CABIN_WINDOW_MATERIAL_CUSTOM_BASE_ID + NUM_CABIN_WINDOWS))\n        {\n            int windowIndex = materialID - int(CABIN_WINDOW_MATERIAL_CUSTOM_BASE_ID);\n            \n            Material windowMaterial = Material(vec3(0.0, 0.0, 0.0), vec3(0), 0);\n            WindowDescription window = GetWindow(windowIndex);\n            float radius = max(window.Dimension.z, max(window.Dimension.x, window.Dimension.y));\n            bool orientedTowardsXAxiz = window.Dimension.z > window.Dimension.x;\n            if(orientedTowardsXAxiz)\n            {\n                position.xz = position.zx;\n                window.Position.xz = window.Position.zx;\n                window.Dimension.xz = window.Dimension.zx;\n            }\n            float xDist = abs(position.x - window.Position.x);\n            float yDist = abs(position.y - window.Position.y);\n            float xRatio = xDist / (window.Dimension.x / 2.0);\n\t\t\tfloat yRatio = yDist / (window.Dimension.y / 2.0);\n            if(xRatio  < 0.13 || yRatio < 0.13)\n            {\n                return materials[WOOD_MATERIAL_ID];\n            }\n            \n            float distFromCenter = length(position.xy - window.Position.xy);\n            float lerpValue = min(distFromCenter / radius, 1.0);\n\t\t\twindowMaterial.emissive = mix(vec3(0.85, 0.85, 0.02), vec3(0.85, 0.15, 0.02), lerpValue);;\n\t\t\treturn windowMaterial;\n        }\n    }\n    \n    \n    // Should never get hit\n    return materials[0];\n}\n\nbool IsColorSignificant(vec3 color)\n{\n    const float insignificantThreshold = 0.01;\n    return color.r > insignificantThreshold || color.b > insignificantThreshold \n        || color.g > insignificantThreshold;\n}\n\nbool IntersectsAABB(vec3 rayOrigin, vec3 rayDirection, AABB aabb)\n{\n    vec3 inverseDirection = 1.0 / rayDirection;\n    vec3 middlePoint = (aabb.origin - rayOrigin) * inverseDirection;\n    vec3 maxL = middlePoint + aabb.dimensions * abs(inverseDirection);\n    vec3 minL = middlePoint - aabb.dimensions * abs(inverseDirection);\n\n    float minT = max(max(minL.x, minL.y), minL.z);\n    float maxT = min(min(maxL.x, maxL.y), maxL.z);\n\n    return max(minT, 0.0) < maxT;\n}\n\nfloat WoodDeformation(vec3 pos, bool horizontal)\n{\n    // Stretch the noise in a direction to give the appearance of wood grain\n    vec2 uv = horizontal ? \n        vec2((pos.x + pos.z) / 500.0, pos.y / 50.0) : \n    \tvec2((pos.x + pos.z) / 50.0, pos.y / 500.0);\n    float noise = texture(iChannel3, uv).r;\n    return mix(-0.075, 0.075, noise);\n}\n\nfloat CabinLogDeformation(vec3 pos)\n{\n    // abs of a sin wave seems to be a good enough approx. of logs\n    return 0.2 * -abs(sin(pos.y * 2.3)) + 0.1 + WoodDeformation(pos, true);\n}\n\nfloat CabinBoxIntersect( vec3 p, vec3 boxOrigin, vec3 boxDimensions)\n{\n    return BoxIntersect(p, boxOrigin, boxDimensions) + CabinLogDeformation(p);\n}\n\nfloat ZAlignedCabinRoof( vec3 p, vec3 origin, vec2 h, float angle )\n{\n    return ZAlignedTriPrism(p, origin, h, angle) + CabinLogDeformation(p);\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float temp = x;\n    x = y;\n    y = temp;\n}\n\nfloat XAlignedTriPrism( vec3 p, vec3 origin, vec2 h, float angle )\n{\n  p -= origin;\n  p.y -= h.x / 2.0;\n  swap(p.x, p.z);\n  return TriPrism(p, h, angle);\n}\n\nfloat XAlignedCabinRoof( vec3 p, vec3 origin, vec2 h, float angle )\n{\n    return XAlignedTriPrism(p, origin, h, angle) + CabinLogDeformation(p);\n}\n\nfloat DetailedTreeIntersect(vec3 p, vec3 origin, float h, float r1, float r2, float fbmNoise )\n{\n    return sdCappedCone(p, origin, h, r1, r2) + 3.7 * fbmNoise;\n}\n\nfloat CapsuleGridIntersect( vec3 p, vec3 origin, float h, float r, float interval, vec3 l)\n{\n    p -= origin;\n    vec3 q = p-interval*clamp(round(p/interval),-l,l);\n    return sdCappedCylinder( q, vec3(0.0), h, r);\n}\n\nfloat TreeTrunkIntersect( vec3 p, vec3 origin, vec2 c )\n{\n  return sdCone(p, origin, c);\n}\n\nfloat DistantTreeIntersect( vec3 p, vec3 origin, vec2 c, float noiseValue )\n{\n  return sdCone(p, origin, c) + 2.9 * noiseValue;\n}\n\nfloat DistantTreeGridIntersect( vec3 p, vec3 origin, vec2 c, float interval, vec3 l, float noiseValue)\n{\n    p -= origin;\n    vec3 q = p-interval*clamp(round(p/interval),-l,l);\n    return DistantTreeIntersect( q, vec3(0.0), c, noiseValue);\n}\n\nfloat snowMicroDisplacement(in vec3 p)\n{\n    return 0.5 * PerlinSeries(p.xz * 32.0) - 0.25 +\n        3.0 * smoothstep(0.0, 1.0, PerlinSeries(p.xz * 4.0)) - 1.5 +  \n        4.0 * smoothstep(0.0, 1.0, PerlinSeries(p.xz * 1.0)) - 2.0;\n}\n\nfloat snowLandscape(in vec3 p )\n{   \n    vec2 CabinLocation = vec2(40.0, 25);\n    float distToCabin = length(p.xz - CabinLocation);\n    \n    // Push the snow down to form a river moat around the cabin\n    {\n        // Offset the moat's center so it's not obvious the river is a circle\n        vec2 RiverPivotLocation  = CabinLocation + vec2(50, -90);\n    \tfloat distToPivot = length(p.xz - RiverPivotLocation);\n        \n        // sin distortion to the river bank looks interesting\n        float sinTransformedDistToPivot = 10.0 * sin(p.z / 20.0) + distToPivot;\n        float riverDistFromPivot = 200.0;\n        float riverWidth = 160.0;\n        float riverDepth = 10.0;\n        if(sinTransformedDistToPivot > riverDistFromPivot - riverWidth / 2.0 && \n           sinTransformedDistToPivot < riverDistFromPivot + riverWidth / 2.0)\n        {\n            float multiplier = 1.0 - (abs(sinTransformedDistToPivot - riverDistFromPivot) / (riverWidth / 2.0));\n            multiplier = multiplier * multiplier * (3.0-2.0*multiplier);\n            p.y += multiplier * riverDepth;\n        }\n    }\n    \n    float planeDist = sdPlane(p);\n    float snowDuneDispacement = 3.0 * sin(p.x / 30.0)*sin(p.z / 30.0);\n    float microDisplacement = 0.0;\n    float approxCameraDist = length(p.xz);\n    \n    // Poor man's attempt at snow LOD\n    if(approxCameraDist < 400.0)\n    {\n        microDisplacement = snowMicroDisplacement(p);\n    }\n    return planeDist + snowDuneDispacement + microDisplacement;\n}\n\nconst float PatioOffset = 28.0;\nconst float stairWidth = CabinDimensions.x / 2.0;\nconst vec3 railingDimensions = vec3((CabinDimensions.x - stairWidth / 2.0) / 2.0, 0.4, 0.4);\nconst float railingHeight = CabinDimensions.y / 4.0;\n\nfloat CabinPillarIntersect(vec3 pos)\n{\n    float woodDeformation = WoodDeformation(pos, false);\n    // Make all SDFs symetrical wrt the cabin\n    pos = SymetryAcrossXAxis(Translate(pos, CabinOrigin));\n    \n    float pillar1Dist = woodDeformation + sdCappedCylinder(pos, vec3(CabinDimensions.x - 0.7, 0, PatioOffset), CabinDimensions.y, 0.7);\n    float pillar2Dist = woodDeformation + sdCappedCylinder(pos, vec3(stairWidth / 2.0, 0, PatioOffset), CabinDimensions.y, 0.7);\n    return min(pillar1Dist, pillar2Dist);\n}\n\nfloat CabinRailingIntersect(vec3 pos)\n{\n    float woodDeformation = WoodDeformation(pos, false);\n    // Make all SDFs symetrical wrt the cabin\n    pos = SymetryAcrossXAxis(Translate(pos, CabinOrigin));\n    \n\tfloat railingSupportDist = woodDeformation + CapsuleGridIntersect(pos, vec3((CabinDimensions.x + stairWidth / 2.0) / 2.0, 0, PatioOffset), railingHeight, 0.4, 2.5 , vec3(2, 0, 0));       \n\tfloat railingBarDistance = BoxIntersect(pos, vec3((CabinDimensions.x + stairWidth / 2.0) / 2.0, railingHeight, PatioOffset), railingDimensions);\n\treturn min(railingSupportDist, railingBarDistance);\n}\n\n#define DEFAULT_INTERSECT_FLAG 0x0\n#define SHADOW_INTERSECT_FLAG 0x1\n#define SKIP_CABIN_INTERSECT_FLAG 0x2\n#define SKIP_GROUND_PLANE_INTERSECT_FLAG 0x4\n\nvec2 QueryDistanceField( in vec3 pos, in int IntersectFlags )\n{    \n    // Hacky way of trying to speed up the marching when the ray is far past the \n    // close-up geometry\n    float approxCameraDist = length(pos.xz);\n    bool farFromCamera = approxCameraDist > 500.0;\n    \n    vec2 res = vec2(99999.0f, 0);\n    float noise = fbm_4(pos / 5.0);\n    if((IntersectFlags & SHADOW_INTERSECT_FLAG) == 0)\n    {\n        // Spamming a bunch of instanced trees with enough interval difference to fake a random\n        // assortment of trees in the background\n        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(0, 30, -400.0), vec2(0.8, 0.2), 40.0 , vec3(10, 0, 1), noise), DISTANT_TREE_MATERIAL_ID));\n        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(0, 50, -400.0), vec2(0.8, 0.2), 60.0 , vec3(10, 0, 1), noise), DISTANT_TREE_MATERIAL_ID));\n        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(0, 70, -400.0), vec2(0.8, 0.2), 150.0, vec3(10, 0, 1), noise), DISTANT_TREE_MATERIAL_ID));\n\n        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(-450, 30, 0.0), vec2(0.8, 0.2), 40.0 , vec3(1, 0, 10), noise), DISTANT_TREE_MATERIAL_ID));\n        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(-450, 50, 0.0), vec2(0.8, 0.2), 60.0 , vec3(1, 0, 10), noise), DISTANT_TREE_MATERIAL_ID));\n        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(-450, 70, 0.0), vec2(0.8, 0.2), 150.0, vec3(1, 0, 10), noise), DISTANT_TREE_MATERIAL_ID));\n\n    }\n    \n    if(!farFromCamera && (IntersectFlags & SHADOW_INTERSECT_FLAG) == 0)\n    {\n        res = opU(res, vec2(TreeTrunkIntersect(pos, vec3(0, 50, -5.0), vec2(0.95, 0.05)), TREE_MATERIAL_ID));\n        res = opU(res, vec2(DetailedTreeIntersect(pos, vec3(0, 30, -5.0), 25.0, 10.0, 0.0, noise), LEAF_MATERIAL_ID));    \n        res = opU(res, vec2(DetailedTreeIntersect(pos, vec3(35, 30, -45.0), 50.0, 16.0, 0.0, noise), LEAF_MATERIAL_ID));    \n        res = opU(res, vec2(TreeTrunkIntersect(pos, vec3(88, 50, -5.0), vec2(0.95, 0.05)), TREE_MATERIAL_ID));\n        res = opU(res, vec2(DetailedTreeIntersect(pos, vec3(88, 30, -5.0), 30.0, 12.0, 0.0, noise), LEAF_MATERIAL_ID));    \n    }\n    \n    if((IntersectFlags & SKIP_GROUND_PLANE_INTERSECT_FLAG) == 0)\n    {\n\t\tres = opU(res, vec2( snowLandscape(pos), SNOW_MATERIAL_ID ));\n    }\n\n    res = opU(res, vec2(SphereIntersect(pos, CabinLamp.Position, CabinLamp.Radius), CABIN_LAMP_MATERIAL_ID));\n    \n    // Cabin\n    if(!farFromCamera && (IntersectFlags & SKIP_CABIN_INTERSECT_FLAG) == 0)\n    {\n        vec3 PatioDimensions = vec3(CabinDimensions.x, 1, PatioOffset / 2.0);\n        // Main room\n        res = opU(res, vec2(CabinBoxIntersect(pos, CabinOrigin, CabinDimensions), WOOD_MATERIAL_ID));\n        \n        vec3 DoorDimensions = vec3(2.0, 7.0, 0.3);\n        res = opU(res, vec2(BoxIntersect(pos, CabinOrigin + vec3(0, 0, CabinDimensions.z), DoorDimensions), WOOD_MATERIAL_ID));\n\n        vec3 WindowDimensions = vec3(3.0, 2.5, 0.3);\n        float WindowYOffset = 5.0;\n        \n        for(int i = 0; i < NUM_CABIN_WINDOWS; i++)\n        {\n            res = opU(res, vec2(BoxIntersect(pos, GetWindow(int(i)).Position, GetWindow(int(i)).Dimension), CABIN_WINDOW_MATERIAL_CUSTOM_BASE_ID + i));\n        }\n        \n        res = opU(res, vec2(CabinPillarIntersect(pos), WOOD_MATERIAL_ID));\n        res = opU(res, vec2(CabinRailingIntersect(pos), WOOD_MATERIAL_ID));\n\t\t\n        // Patio roof\n        res = opU(res, vec2(BoxIntersect(pos, CabinOrigin + vec3(0, CabinDimensions.y, PatioOffset / 2.0), PatioDimensions), WOOD_MATERIAL_ID));\n \n        // Patio deck\n        vec3 DeckDimensions = vec3(CabinDimensions.x, 5, PatioOffset / 2.0);\n        res = opU(res, vec2(BoxIntersect(pos, CabinOrigin + vec3(0, -3.5, PatioOffset / 2.0), PatioDimensions), WOOD_MATERIAL_ID));\n\n        float roofAngle = PI / 4.5;\n        float atticRoofAngle = PI / 3.6;\n        float CabinRoofHeight = CabinDimensions.z * 0.55;\n        vec3 CabinRoofOrigin = CabinOrigin + vec3(0, CabinDimensions.y + 2.0, 0);\n\n        if((IntersectFlags & SHADOW_INTERSECT_FLAG) == 0)\n        {\n        \tres = opU(res, vec2(ZAlignedCabinRoof(pos, CabinRoofOrigin, vec2(CabinRoofHeight * 0.7, CabinDimensions.z), atticRoofAngle), WOOD_MATERIAL_ID));\n        \tres = opU(res, vec2(XAlignedCabinRoof(pos, CabinRoofOrigin, vec2(CabinRoofHeight, CabinDimensions.x), roofAngle), WOOD_MATERIAL_ID));\n        }\n        \n\t\tfloat yOffset = snowMicroDisplacement(pos) - 1.3;\n        float unionMergeFactor = 1.25;\n        // Roof snow\n        res = opU(res, vec2(\n            opSmoothUnion(\n                opSmoothUnion(\n                    // Patio roof snow\n                    BoxIntersect(pos, CabinOrigin + vec3(0, CabinDimensions.y + yOffset, PatioOffset / 2.0), PatioDimensions * 0.98), \n                    // Main roof snow\n                    XAlignedTriPrism(pos, CabinRoofOrigin + vec3(0, yOffset + 1.0, 0),  vec2(CabinRoofHeight, CabinDimensions.x) * 0.98, roofAngle),\n                    unionMergeFactor),\n                // Cabin attic room roof snow\n                ZAlignedTriPrism(pos, CabinRoofOrigin + vec3(0, yOffset + 1.15, 0), 0.98 * vec2(CabinRoofHeight * 0.7, CabinDimensions.z),  atticRoofAngle),\n                unionMergeFactor), \n            ROOF_SNOW_MATERIAL_ID));\n    }\n\n    return res;\n}\n\nint CalculateOptimizedIntersectFlags(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    int intersectFlags = DEFAULT_INTERSECT_FLAG;\n    if(!IntersectsAABB(rayOrigin, rayDirection, CabinAABB))\n    {\n        intersectFlags |= SKIP_CABIN_INTERSECT_FLAG;\n    }\n    \n    float maxSnowPlaneHeight = 0.00;\n\tif(rayOrigin.y > maxSnowPlaneHeight)\n    {\n\t\tfloat t = (maxSnowPlaneHeight - rayOrigin.y) / rayDirection.y;\n        if(t < 0.0 || t > SCENE_MAX_T)\n        {\n            intersectFlags |= SKIP_GROUND_PLANE_INTERSECT_FLAG;\n        }\n    }\n    \n    \n    return intersectFlags;\n}\n\nvoid Intersect( in vec3 rayOrigin, in vec3 rayDirection, in float tmin, in int intersectFlags, out int materialID, out float t)\n{\n    intersectFlags |= CalculateOptimizedIntersectFlags(rayOrigin, rayDirection);\n    float tmax = SCENE_MAX_T;\n    \n\tfloat precis = 0.002;\n    float precisPadPerDist = 0.0001;\n    t = tmin;\n    materialID = INVALID_MATERIAL_ID;\n    int maxIteration = 75;\n    int i;\n    for( i=(min(iFrame,0)); i<maxIteration; i++ )\n    {\n\t    vec2 res = QueryDistanceField( rayOrigin+rayDirection*t, intersectFlags);\n        if( res.x< (precis + t * precisPadPerDist) || t>tmax ) break;\n        t += res.x;\n\t    materialID = int(res.y);\n    }\n\n    if( t>tmax ) materialID = INVALID_MATERIAL_ID;\n}\n\n// Mostly taken from https://iquilezles.org/articles/rmshadows\nfloat SoftShadowIntersect(in vec3 rayOrigin, in vec3 rayDirection, in float tmin, in float tmax, in int iterations, in float width)\n{\n    int rayIntersectFlags = CalculateOptimizedIntersectFlags(rayOrigin, rayDirection);\n\tfloat precis = 0.01;\n    float t = tmin;\n    float shadowFactor = 1.0;\n    float ph = 1e20;\n    int i;\n    for( i=(min(iFrame,0)); i<iterations; i++ )\n    {\n\t    vec2 res = QueryDistanceField( rayOrigin+rayDirection*t, SHADOW_INTERSECT_FLAG | rayIntersectFlags );\n        if( res.x < precis || t>tmax )\n        {\n            int materialID = int(res.y);\n            if(materialID == int(INVALID_MATERIAL_ID) || materialID == int(CABIN_LAMP_MATERIAL_ID))\n            {\n                break;\n            }\n            else\n            {\n                shadowFactor = 0.0;\n            }\n        }\n        float y = res.x*res.x/(2.0*ph);\n        float d = sqrt(res.x*res.x-y*y);\n        shadowFactor = min( shadowFactor, width*d/max(0.0,t-y) );\n\n        ph = res.x;\n        t += res.x;\n    }\n    return shadowFactor;\n}\n\n// Taken from https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal( in vec3 pos )\n{\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*QueryDistanceField(pos+0.005*e, DEFAULT_INTERSECT_FLAG).x;\n    }\n    return normalize(n);\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\n// Global Illumination is guestimated to just be the sky color reflected off the snow.\n// A small hack is done if GI is being sampled by the cabin since the sky color would\n// be blocked by the roof and the lamp color would be more relevant.\nvec3 GetGlobalIllumination(in vec3 pos)\n{\n    float cabinDist = length(pos - CabinOrigin);\n    float lampReachDist = 55.0;\n    float lerpValue = min(cabinDist / lampReachDist, 1.0);\n    vec3 cabinGIValue = vec3(0.05, 0.026, 0.0);\n\n\treturn mix(cabinGIValue, AmbientSnowColor, lerpValue);\n}\n\nvec3 GetSkyColor(vec3 rayDirection)\n{\n    \n    float p = atan(rayDirection.x, rayDirection.z);\n    p = p > 0.0 ? p : p + 2.0 * PI;\n    vec2 uv = vec2(p / (2.0 * PI), acos(rayDirection.y) / PI);\n\n    float yCapValue = 0.05 + .01 * sin(uv.x + iTime * 0.1);\n    float yLerpValue = min(rayDirection.y, yCapValue) / yCapValue;\n    vec3 skyColor = 1.3 * mix(vec3(0.02, 0.26, 0.64), vec3(0.04, 0.04, 0.6), yLerpValue);\n\n    vec3 cloudTexture = texture(iChannel1, uv + vec2(iTime * 0.001, 0.0)).bgr;\n    skyColor = skyColor * cloudTexture;\n    \n    vec2 auroraCenter = vec2(0.525, 0.5);\n    float distanceFromAuroraCeter = length(uv - auroraCenter);\n    float ring1Start = 0.05;\n    float ring1End = 0.1;\n    float distanceFromAuroraCeter1 = distanceFromAuroraCeter + \n        0.003 * sin(uv.y * 100.0 + iTime * 1.1) +\n        0.001 * noise(vec3(uv * 200.0, iTime * 1.1));\n    \n    float yDistFromCenter = abs(uv.y - auroraCenter.y); \n\n    if(distanceFromAuroraCeter1 > ring1Start && distanceFromAuroraCeter1 < ring1End)\n    {\n        float ring1Center = ring1Start * 0.75 + ring1End * 0.25;\n        float ring1Length = (distanceFromAuroraCeter1 < ring1Center) ? \n            (ring1Center - ring1Start) : (ring1End - ring1Center);\n        float multiplier = 1.0 - (abs(distanceFromAuroraCeter1 - ring1Center) / ring1Length); \n        multiplier = pow(multiplier, 2.0);\n        float borealisLerpValue = noise(vec3(uv.x * 200.0, 0.0, 0.0));\n        vec3 borealisColor = mix(vec3(0.0, 0.4, 0.15), vec3(0.0, 0.2, 0.02), borealisLerpValue);\n        skyColor += multiplier * borealisColor;\n    }\n    \n    float ring2Start = 0.07;\n    float ring2End = 0.1;\n    float distanceFromAuroraCeter2 = distanceFromAuroraCeter + \n        0.005 * sin(uv.y * 80.0 + iTime * 1.5) +\n        0.003 * noise(vec3(uv * 200.0, iTime * 1.1));\n    if(distanceFromAuroraCeter2 > ring2Start && distanceFromAuroraCeter2 < ring2End)\n    {\n        float ring2Center = ring2Start * 0.75 + ring2End * 0.25;\n        float ring2Length = (distanceFromAuroraCeter2 < ring2Center) ? \n            (ring2Center - ring2Start) : (ring2End - ring2Center);\n        float multiplier = 1.0 - (abs(distanceFromAuroraCeter2 - ring2Center) / ring2Length); \n        multiplier = pow(multiplier, 2.0);\n        float borealisLerpValue = uv.y * noise(vec3(0.0, uv.x * 250.0, 0.0));\n        vec3 borealisColor = mix(vec3(0.3, 0, 0.13), vec3(0.12, 0.0, 0.05), borealisLerpValue);\n        skyColor += multiplier * borealisColor;\n    }\n    \n    float ring3Start = 0.11;\n    float ring3End = 0.16;\n    float distanceFromAuroraCeter3 = distanceFromAuroraCeter + \n        0.004 * sin(uv.y * 120.0 + iTime * 0.9) +\n        0.003 * noise(vec3(uv * 200.0, iTime));\n    if(distanceFromAuroraCeter3 > ring3Start && distanceFromAuroraCeter3 < ring3End)\n    {\n        float ring3Center = ring3Start * 0.75 + ring3End * 0.25;\n        float ring3Length = (distanceFromAuroraCeter3 < ring3Center) ? \n            (ring3Center - ring3Start) : (ring3End - ring3Center);\n        float multiplier = 1.0 - (abs(distanceFromAuroraCeter3 - ring3Center) / ring3Length); \n        multiplier = pow(multiplier, 2.0);\n        float borealisLerpValue = uv.y * noise(vec3(0.0, uv.x * 250.0, 0.0));\n        vec3 borealisColor = mix(vec3(0.05, 0.25, 0.15), vec3(0.0, 0.1, 0.2), borealisLerpValue);\n        skyColor += multiplier * borealisColor;\n    }\n    \n    clamp(skyColor, 0.0, 1.0);\n    return skyColor;\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, bool shootShadowRays, inout vec3 diffuseColor, inout vec3 specularColor)\n{\n    vec3 lightDirection = (CabinLamp.Position - position);\n    float lightDistance = length(lightDirection);\n    lightDirection /= lightDistance;\n\n    // Manually tuned light falloff for what looked best\n    vec3 lightColor = CabinLampMultiplier() * CabinLamp.LightColor / pow(lightDistance, 0.7); \n\n    float shadowFactor = 1.0;\n    if(shootShadowRays && IsColorSignificant(lightColor))\n    {\n       shadowFactor = SoftShadowIntersect(position, lightDirection, 0.1, 200.0, 50, 64.0);\n    }\n\n    if(SupportsSpecularLight(material))\n    {\n        specularColor += shadowFactor * 0.25 * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n    }\n    diffuseColor += shadowFactor * lightColor * Diffuse(normal, lightDirection, material.albedo);\n    diffuseColor += material.emissive;\n    \n    for(int i = 0; i < NUM_POINT_LIGHTS; i++)\n    {\n        vec3 pointLightDirection = (Cabin.PointLights[i].Position - position);\n        float pointLightDistance = length(pointLightDirection);\n        pointLightDirection /= pointLightDistance;\n\n        vec3 pointLightColor = Cabin.PointLights[i].LightColor / (pointLightDistance * pointLightDistance);\n\n        if(SupportsSpecularLight(material))\n        {\n            specularColor += 0.25 * pointLightColor * pow(max(dot(reflectionDirection, pointLightDirection), 0.0), 4.0);\n        }\n        diffuseColor += pointLightColor * Diffuse(normal, pointLightDirection, material.albedo);\n    }\n    \n    diffuseColor += GetGlobalIllumination(position);\n\n    {\n        float skyNDotL = normal.y;\n        // Alter where the sky light is coming from just for snow to give the snow\n        // a little more texture\n        if(IsSnow(material))\n        {\n            skyNDotL = dot(normal, normalize(vec3(1, 1, 0.2)));\n            diffuseColor += \n                mix(vec3(0.1, 0.2, 0.3), SKY_LIGHT_COLOR * material.albedo, pow(skyNDotL, 4.0));\n        }\n        else\n        {\n\t\t\tdiffuseColor += SKY_LIGHT_COLOR * skyNDotL * material.albedo;\n        }\n    }\n\n    specularColor = clamp(specularColor, 0.0, 1.0);\n    diffuseColor = clamp(diffuseColor, 0.0, 1.0);\n}\n\nvoid UpdateMaterial(int materialID, vec3 position, vec3 normal, bool showSnowOnDistantTrees, inout Material material)\n{\n    // Convert upwards facing leaf materials to snow to imitate snowfall\n    if((materialID == int(LEAF_MATERIAL_ID) && (normal.y > 0.2)) ||\n       (showSnowOnDistantTrees && materialID == int(DISTANT_TREE_MATERIAL_ID) && (normal.y > 0.2)))\n    {\n        material = GetMaterial(int(SNOW_MATERIAL_ID), position);\n    }\n}\n\nvoid TraceRay( in vec3 rayOrigin, in vec3 rayDirection, out vec3 diffuseColor, out vec3 specularColor, out float depth, out int materialID)\n{\n    depth = SCENE_MAX_T;\n    diffuseColor = specularColor = vec3(0.0);\n    \n    float t;\n    materialID = INVALID_MATERIAL_ID;\n    Intersect(rayOrigin, rayDirection, 0.1, DEFAULT_INTERSECT_FLAG, materialID, t);\n    \n    if( materialID != INVALID_MATERIAL_ID )\n    {\n        depth = t;\n        vec3 position = rayOrigin + t*rayDirection;\n        Material material = GetMaterial(materialID, position);\n\t\tif(IsLightSource(material))\n        {\n            diffuseColor = min(material.albedo, vec3(1.0));\n            return;\n        }       \n        \n        vec3 normal = GetNormal( position );\n       \tUpdateMaterial(materialID, position, normal, true, material);\n        vec3 reflectionDirection = reflect( rayDirection, normal );\n\t\t\n        CalculateLighting(position, normal, reflectionDirection, material, true, diffuseColor, specularColor);\n    }\n    else\n    {\n       diffuseColor = GetSkyColor(rayDirection);\n    }\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 25.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    if(iMouse.x <= 0.0)\n    {\n        // Default value when shader is initially loaded up\n        return 0.65f;\n    }\n    \n    return iMouse.x / iResolution.x;\n}\n \nvec3 AdjustColorForFog(vec3 color, float depth, float height)\n{\n\tvec3 fogColor = AmbientSnowColor;\n    float fogHeight = 60.0;\n\n\tvec3 lerpFogColor = mix( color, fogColor, 1.0-exp(-0.0045*depth) );\n    return mix(lerpFogColor, color, min(max(height, 0.0), fogHeight) / fogHeight);\n}\n                          \nvoid FogPass(in vec3 rayOrigin, in vec3 rayDirection, in float depth, inout vec3 diffuseColor, inout vec3 specularColor)\n{\n\tvec3 position = rayOrigin + rayDirection * depth;\n\n    depth -= 230.0;\n    depth = max(0.0, depth);\n\n    diffuseColor = AdjustColorForFog(diffuseColor, depth, position.y);\n    specularColor = AdjustColorForFog(specularColor, depth, position.y);\n}\n\nvoid RenderIce(in vec3 rayOrigin, in vec3 rayDirection, in float depth, inout vec3 diffuseColor, inout vec3 specularColor, inout int materialID)\n{\n    float icePlaneHeight = -7.0;\n    vec3 position = rayOrigin + rayDirection * depth;\n    \n    if(position.y <= icePlaneHeight)\n    {\n        float iceDepth = (icePlaneHeight - rayOrigin.y) / rayDirection.y;\n\t\tvec3 icePosition = rayOrigin + rayDirection * iceDepth;\n        \n        // Coat the ice with bits of snow\n        bool isIce = noise(icePosition / 4.0) > -0.620;\n        \n        // Ice is a plane so normal is always up\n        vec3 normal = vec3(0, 1, 0);\n        Material material = GetMaterial(int(ICE_MATERIAL_ID), position);\n        vec3 reflectionDirection = reflect( rayDirection, normal );\n\t\tif(isIce)\n        {\n            materialID = ICE_MATERIAL_ID;\n            int reflectionMaterialID = INVALID_MATERIAL_ID;\n            float reflectionDistance = 0.0;\n            {\n                // Hack the reflection angle slightly\n                // for the sake of art\n                {\n                    reflectionDirection.y -= 0.02;\n                    reflectionDirection = normalize(reflectionDirection);\n                }\n\n                Intersect(icePosition + EPSILON * reflectionDirection, reflectionDirection, 0.01, DEFAULT_INTERSECT_FLAG, reflectionMaterialID, reflectionDistance);\n                if(reflectionMaterialID != INVALID_MATERIAL_ID)\n                {\n\n                    vec3 reflectionPosition = icePosition + reflectionDirection * reflectionDistance;\n                    vec3 reflectionNormal = GetNormal(reflectionPosition);\n                    Material material = GetMaterial(reflectionMaterialID, reflectionPosition);\n                    UpdateMaterial(reflectionMaterialID, reflectionPosition, reflectionNormal, true, material);\n\n                    if(IsLightSource(material))\n                    {\n                        diffuseColor = min(material.albedo, vec3(1.0));\n                    }\n                    else\n                    {\n                        // Best variable name ever\n                        vec3 reflectionReflection = reflect(reflectionDirection, normal);\n\n                    \tvec3 reflDiffuse;\n                    \tCalculateLighting(reflectionPosition, reflectionNormal, reflectionReflection, material, true, diffuseColor, specularColor);\n                    \tFogPass(icePosition, reflectionDirection, reflectionDistance, diffuseColor, specularColor);\n                    }\n                }\n                else\n                {\n                    specularColor += GetSkyColor(reflectionDirection);\n                }\n            }\n            float icePenetrationDepth = depth - iceDepth;\n            diffuseColor = mix(material.albedo * SKY_LIGHT_COLOR, diffuseColor, 1.0-exp(-0.01*icePenetrationDepth) );\n        }\n        else\n        {\n            specularColor = diffuseColor = vec3(0.0);\n            CalculateLighting(icePosition, normal, reflectionDirection, GetMaterial(int(SNOW_MATERIAL_ID), icePosition), false, diffuseColor, specularColor);\n        } \n    }\n}\n                          \nvoid TransparencyPass(in vec3 rayOrigin, in vec3 rayDirection, in float depth, inout vec3 diffuseColor, inout vec3 specularColor, inout int materialID)\n{\n\tRenderIce(rayOrigin, rayDirection, depth, diffuseColor, specularColor, materialID);\n}\n                \nvec3 PostProcessSnow(vec2 uv, in vec3 rayOrigin, in vec3 rayDirection, inout float depth)\n{\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.y *= aspectRatio; \n    \n    \n    // Close Snowflakes\n    {\n        vec2 closeSnowUV = uv;\n        \n        // Offsetting by the rotation gives a good enough\n        // illusion of 3D snow\n        closeSnowUV.x += -GetRotationFactor() * 3.0;\n        closeSnowUV.y += iTime / 4.0;\n        closeSnowUV = fract(closeSnowUV);\n\n        // This is super lame but I'm tired\n        // and it's good enough...\n        #define NUM_SNOWFLAKES 10\n        vec3 Snowflakes[NUM_SNOWFLAKES];\n        Snowflakes[0] = vec3(0.1, 0.7, 100.0);\n        Snowflakes[1] = vec3(0.3, 0.3, 200.0);\n        Snowflakes[2] = vec3(0.5, 0.5, 150.0);\n        Snowflakes[3] = vec3(0.2, 0.73, 50.0);\n        Snowflakes[4] = vec3(0.54, 0.94, 88.0);\n        Snowflakes[5] = vec3(0.99, 0.34, 295.0);\n        Snowflakes[6] = vec3(0.07, 0.28, 196.0);\n        Snowflakes[7] = vec3(0.11, 0.32, 161.0);\n        Snowflakes[8] = vec3(0.88, 0.9, 254.0);\n        Snowflakes[9] = vec3(0.63, 0.01, 17.0);\n            \n        for(int i = 0; i < NUM_SNOWFLAKES; i++)\n        {\n            float uvDist = length(Snowflakes[i].xy - closeSnowUV);\n            float snowDepth = Snowflakes[i].z;\n            if(snowDepth < depth)\n            {\n                float radius = 0.008 * (1.0 - snowDepth / 300.0);\n                if(uvDist < radius)\n                {\n                    vec3 diffuse = vec3(0.5) * (1.0 - (uvDist / radius));\n                    vec3 specular = vec3(0.0);\n                    FogPass(rayOrigin, rayDirection, snowDepth, diffuse, specular);\n                    return diffuse;\n                }\n            }\n        }\n    }\n    \n    // Distance Snowflakes\n    {\n        // Offsetting by the rotation gives a good enough\n        // illusion of 3D snow\n        uv.x += -GetRotationFactor() * 2.0;\n\n        uv.y += iTime / 10.0;\n        vec4 noiseValue = texture(iChannel3, uv);\n        float snowValue = noiseValue.r;\n        float snowDepth = 300.0;//noiseValue.r * SCENE_MAX_T;\n        if( (snowDepth < depth && snowValue > 0.95) )\n        {\n            vec3 diffuse = vec3(0.5);\n            vec3 specular = vec3(0.0);\n            FogPass(rayOrigin, rayDirection, snowDepth, diffuse, specular);\n            return diffuse;\n        }\n\n    }\n    return vec3(0.0);\n}\n                              \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    float depth = 0.0;\n    vec3 diffuseColor, specularColor;\n    int materialID;\n    TraceRay( rayOrigin, rayDirection, diffuseColor, specularColor, depth, materialID);\n    \n    TransparencyPass(rayOrigin, rayDirection, depth, diffuseColor, specularColor, materialID);\n    FogPass(rayOrigin, rayDirection, depth, diffuseColor, specularColor);    \n\n    specularColor += PostProcessSnow(uv, rayOrigin, rayDirection, depth);\n    \n    specularColor = clamp(specularColor, 0.0, 1.0);\n    diffuseColor = clamp(diffuseColor, 0.0, 1.0);\n    \n    // intBitsToFloat seems to have some issues with ShaderToy so compressing \n    // diffuse + specular in this lame way\n    specularColor = specularColor * 1000.0f;\n    specularColor -= fract(specularColor);\n    vec3 color = specularColor + diffuseColor;\n    depth = fract(depth / SCENE_MAX_T);\n    depth += float(materialID);\n    \n    fragColor=vec4( color, depth );\n}","name":"Buffer B","description":"","type":"buffer"}]}