{"ver":"0.1","info":{"id":"wdXSWs","date":"1552509739","viewed":88,"name":"earth and moon","username":"ghost7","description":"earth and moon. Feel free to use this as long as you credit me <3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["earth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//noise (translated into glsl by ghost7 from Ken Perlin's Java implementation)\nint b(int N, int B) { return N>>B & 1; }\nint T[] = int[](0x15,0x38,0x32,0x2c,0x0d,0x13,0x07,0x2a);\nint A[] = int[](0,0,0);\n\nint b(int i, int j, int k, int B) { return T[b(i,B)<<2 | b(j,B)<<1 | b(k,B)]; }\n\nint shuffle(int i, int j, int k) {\n    return b(i,j,k,0) + b(j,k,i,1) + b(k,i,j,2) + b(i,j,k,3) +\n        b(j,k,i,4) + b(k,i,j,5) + b(i,j,k,6) + b(j,k,i,7) ;\n}\n\nfloat K(int a, vec3 uvw, vec3 ijk)\n{\n    float s = float(A[0]+A[1]+A[2])/6.0;\n    float x = uvw.x - float(A[0]) + s,\n        y = uvw.y - float(A[1]) + s,\n        z = uvw.z - float(A[2]) + s,\n        t = 0.6 - x * x - y * y - z * z;\n    int h = shuffle(int(ijk.x) + A[0], int(ijk.y) + A[1], int(ijk.z) + A[2]);\n    A[a]++;\n    if (t < 0.0)\n        return 0.0;\n    int b5 = h>>5 & 1, b4 = h>>4 & 1, b3 = h>>3 & 1, b2= h>>2 & 1, b = h & 3;\n    float p = b==1?x:b==2?y:z, q = b==1?y:b==2?z:x, r = b==1?z:b==2?x:y;\n    p = (b5==b3 ? -p : p); q = (b5==b4 ? -q : q); r = (b5!=(b4^b3) ? -r : r);\n    t *= t;\n    return 8.0 * t * t * (p + (b==0 ? q+r : b2==0 ? q : r));\n}\n    \nfloat noise(float x, float y, float z)\n{\n    float s = (x + y + z) / 3.0;  \n    vec3 ijk = vec3(int(floor(x+s)), int(floor(y+s)), int(floor(z+s)));\n    s = float(ijk.x + ijk.y + ijk.z) / 6.0;\n    vec3 uvw = vec3(x - float(ijk.x) + s, y - float(ijk.y) + s, z - float(ijk.z) + s);\n    A[0] = A[1] = A[2] = 0;\n    int hi = uvw.x >= uvw.z ? uvw.x >= uvw.y ? 0 : 1 : uvw.y >= uvw.z ? 1 : 2;\n    int lo = uvw.x <  uvw.z ? uvw.x <  uvw.y ? 0 : 1 : uvw.y <  uvw.z ? 1 : 2;\n    return K(hi, uvw, ijk) + K(3 - hi - lo, uvw, ijk) + K(lo, uvw, ijk) + K(0, uvw, ijk);\n}\n//endnoise\n\n\nfloat normalizedDistance(vec2 normalizedCoord, vec2 otherNormalizedCoord)\n{\n    vec2 coord = normalizedCoord * iResolution.xy;\n    vec2 otherCoord = otherNormalizedCoord * iResolution.xy;\n    return distance(coord, otherCoord);\n}\n\nvec3 circle(vec2 coord, vec2 center, float radius)\n{\n    return vec3(step(distance(coord, center), abs(radius)));\n}\n\nvec3 normalizedCircle(vec2 normalizedCoord, vec2 normalizedCenter, float normalizedRadius)\n{\n    vec2 coord = normalizedCoord * iResolution.xy;\n    vec2 center = normalizedCenter * iResolution.xy;\n    \n    //use the smaller of the two resolution lengths to de-normalize the radius\n    float radius = (iResolution.y < iResolution.x) ? normalizedRadius * iResolution.y : normalizedRadius * iResolution.x;\n    \n    return circle(coord, center, radius);\n}\n\nvec3 screenColor;\nvoid addImageToScreen(vec3 color)\n{\n    screenColor += color;\n}\n\n//TODO: Add layering system.\n//have an ordered list of layers. adding layer to the screen must subtracts all the layers below it.\n\n\nvec3 addColorToShape(vec3 shape, vec3 color)\n{\n    return vec3(shape.x * color.x, shape.y * color.y, shape.z * color.z);\n}\n\nvec3 getStars(vec2 normalizedCoord) {\n    return vec3(noise(normalizedCoord.x * 300.0 + iTime / 8.0, normalizedCoord.y * 300.0 + iTime / 8.0, 0.0));\n}\n\nvec3 getLighting(vec2 normalizedCoord) {\n    return vec3(smoothstep(0.0, 0.7, noise(normalizedCoord.x * 0.9 + iTime / 8.0 - 10.0, normalizedCoord.y * 0.9 + iTime / 8.0 - 10.0, 0.0)));\n}\n\nvoid drawEarth(vec2 normalizedCoord, vec2 centerOfTheEarth)\n{\n    //shape\n    vec3 circle = normalizedCircle(normalizedCoord, centerOfTheEarth, 0.2);\n    \n    //color\n    float noiseSize = 8.0;// + iIime\n    float noiseyPt = iTime / 8.0 - 1.0/noise(normalizedCoord.x * noiseSize, normalizedCoord.y * noiseSize, 0.0);\n   \tnoiseyPt = smoothstep(0.1, 0.5, noiseyPt);\n    vec3 color = sin(noiseyPt + vec3(-1, 1, 2));   \n    //remove stars from texture\n    color -= getStars(normalizedCoord);\n    \n    //image\n    vec3 image = addColorToShape(circle, color);\n    addImageToScreen(image);\n}\n\nvoid drawMoon(vec2 normalizedCoord, vec2 centerOfTheEarth)\n{\n    //shape\n    vec2 centerOfTheMoon = vec2(sin(iTime) * 0.25 + centerOfTheEarth.x, cos(iTime) * 0.4 + centerOfTheEarth.y);\n    vec3 circle = normalizedCircle(normalizedCoord, centerOfTheMoon, 0.1);\n    \n    //color\n    //vec3 color = vec3(sin(iTime), 1.0, 1.0);\n    \n    //color\n    float noiseSize = 8.0 + iTime;\n    float noiseyPt = iTime / 8.0 - 1.0/noise(normalizedCoord.x * noiseSize, normalizedCoord.y * noiseSize, 0.0);\n   \tnoiseyPt = smoothstep(0.1, 0.5, noiseyPt);\n    vec3 color = sin(noiseyPt + vec3(1, 1, 1));\n    //remove stars from texture\n    color -= getStars(normalizedCoord);\n    \n    //image\n    vec3 image = addColorToShape(circle, color);\n\taddImageToScreen(image); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 normalizedCoord = fragCoord.xy / iResolution.xy;\n    \n    screenColor = getStars(normalizedCoord);\n\tscreenColor += getLighting(normalizedCoord);\n    \n    //stationary\n    //vec2 centerOfTheEarth = vec2(0.4);\n    \n    //moving (orbits, yay!)\n    vec2 centerOfTheEarth = vec2(cos(iTime / 2.0) * 0.2 + 0.5, sin(iTime / 2.0) * 0.3 + 0.5);\n    \n    drawEarth(normalizedCoord, centerOfTheEarth);\n    drawMoon(normalizedCoord, centerOfTheEarth);\n    \n    fragColor = vec4(screenColor, 1.0);    \n}","name":"Image","description":"","type":"image"}]}