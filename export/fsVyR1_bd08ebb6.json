{"ver":"0.1","info":{"id":"fsVyR1","date":"1654442225","viewed":175,"name":"sphere_fire_gas23","username":"edwardbraed","description":"My first simple volumetric gas tracing (with additive blending accumulated intersections).\nHold mouse btn for rotate camera position.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","noise","sphere","volumetric","gas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE_SIZE 0.75\n#define NOISE_SIZE 5.0\n#define NOISE_ACCURACY 3.5\n#define NOISE_OCTAVES 5\n#define DARK_POWER 60.0\n#define GAS_POWER 140.0\n#define GAS_COLOR vec3(0.8, 0.25, 0.0)\n#define MARCH_STEPS 128\n\nvec3 raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec2 ad = vec2(0.0);\n    float rs = length(rd) / float(MARCH_STEPS);\n    float ds = rs;   // density step\n    \n    for(int x = 0; x < MARCH_STEPS; x++)\n    {\n        vec3 pos = ro + rd * t;\n        float lp = length(pos);\n        if(lp < SPHERE_SIZE)\n        {\n            float vn1 = noiseVol(pos, NOISE_SIZE, NOISE_OCTAVES, NOISE_ACCURACY, GAS_POWER);\n            float vn2 = noiseVol(pos, NOISE_SIZE + 3.0, NOISE_OCTAVES, NOISE_ACCURACY, DARK_POWER);\n            float gs = ds * (1.0 - lp / SPHERE_SIZE);\n            ad += vec2(vn1 * gs, vn2 * gs);\n        }\n        t +=rs;\n    }\n    \n    return mix(vec3(0.5), GAS_COLOR * (ad.x - ad.y), ad.x + ad.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // aspect ratio for correction rays..\n    float a = iResolution.x / iResolution.y;\n    \n    // ray origin\n    vec3 ro = vec3(0.0);\n    if(iMouse.z > 0.9)\n    {\n        float mPosX = (iMouse.x / iResolution.x - 0.5) * 15.0;\n        ro = vec3(sin(mPosX), 0.5, -cos(mPosX));\n    }\n    else\n        ro = vec3(sin(iTime * 0.4), 0.5, cos(iTime * 0.4));\n    \n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y),\n                   1.0);\n    rd.x *= a;\n    rd = getCamera(ro, vec3(rd.xy, -0.9));\n    \n    fragColor = vec4(raymarch(ro, rd), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define norm(a) (a + 1.0) * 0.5\n    \n//thanks: https://www.shadertoy.com/view/ll33zS\nvec3 getCamera(vec3 z, vec3 p)\n{\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z) * p;\n}\n\nvec3 quantic(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat rand3(vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(12.9898, 4.1414, 17.9361))) * 43758.5453);\n}\n\nfloat valueNoise3(vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 lp = p - ip;\n    vec3 q  = quantic(lp);\n    \n    float v1   = rand3(ip); //+ vec3(0.0, 0.0, 0.0);\n    float v2   = rand3(ip     + vec3(1.0, 0.0, 0.0));\n    float v3   = rand3(ip     + vec3(0.0, 1.0, 0.0));\n    float v4   = rand3(ip     + vec3(1.0, 1.0, 0.0));\n    \n    float v5   = rand3(ip     + vec3(0.0, 0.0, 1.0));\n    float v6   = rand3(ip     + vec3(1.0, 0.0, 1.0));\n    float v7   = rand3(ip     + vec3(0.0, 1.0, 1.0));\n    float v8   = rand3(ip     + vec3(1.0, 1.0, 1.0));\n    \n\treturn mix(mix(mix(v1,v2,q.x), mix(v3,v4,q.x), q.y),\n               mix(mix(v5,v6,q.x), mix(v7,v8,q.x), q.y), q.z);\n}\n\nfloat valueFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        \n        res += abs((0.5 - valueNoise3(pos)) * amplitude * 2.0);\n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\nfloat noiseVol(vec3 pos, float sz, int no, float na, float p)\n{\n    return pow(valueFBM3(pos * sz, no), na) * p;\n}","name":"Common","description":"","type":"common"}]}