{"ver":"0.1","info":{"id":"wlSGzd","date":"1560709291","viewed":296,"name":"Breathing tar","username":"Darien","description":"Combining FBM with raymarching... ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589\n#define OCTAVES 5\n#define STEPS 32\n#define MIN_DIST 0.1\n#define MAX_DIST 10.0\n\nmat3 rotateX(float a) {\n    return mat3(\n        vec3(1., 0., 0.),\n        vec3(0., cos(a), -sin(a)),\n        vec3(0., sin(a), cos(a))\n        );\n}\n\n//  Simplex 3D Noise\n//  by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm(vec3 p) {\n  float n = 0.0;\n  float a = 0.5;\n  float s = 2.0;\n  for(int i = 0; i < OCTAVES; i++) {\n    n += snoise(p + vec3(0., 0., iTime*0.1)) * a;\n    p *= s;\n    a *= 0.5;\n  }\n  return n;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - 0.5 * r;\n}\n\nfloat scene(vec3 p) {\n    return sphere(p + fbm(p*0.4), 12.0);\n}\n\nvec3 getNormals(vec3 p) {\n    vec3 delta = vec3(0.001, 0., 0.);\n    float x = scene(p + delta.xyy) - scene(p - delta.xyy);\n    float y = scene(p + delta.yxy) - scene(p - delta.yxy);\n    float z = scene(p + delta.yyx) - scene(p - delta.yyx);\n    return normalize(vec3(x, y, z));\n}\n\n\nfloat rayMarch(vec3 pos, vec3 dir, out vec3 p) {\n    float currentDist = 0.;\n    for(int i = 0; i < STEPS; ++i) {\n        p = pos + (dir * currentDist);\n        float distanceToObj = scene(p);\n        if(distanceToObj < MIN_DIST) {\n            break;\n        }\n        currentDist += distanceToObj;\n        if(currentDist > MAX_DIST) {\n            currentDist = 0.;\n            break;\n        }\n    }\n    return currentDist;\n}\n\n// Standard Blinn lighting model.\n// This model computes the diffuse and specular components of the final surface color.\nvec3 calculateLighting(vec3 pointOnSurface, vec3 surfaceNormal, vec3 lightPosition, vec3 cameraPosition)\n{\n    vec3 fromPointToLight = normalize(lightPosition - pointOnSurface); // Get normal\n    float diffuseStrength = clamp( dot( surfaceNormal, fromPointToLight ), 0.0, 1.0 );\n    vec3 diffuseColor = diffuseStrength * vec3(abs(fbm(pointOnSurface)*2.0)); // Here the color\n    vec3 reflectedLightVector = normalize( reflect( -fromPointToLight, surfaceNormal ) );\n    vec3 fromPointToCamera = normalize( cameraPosition - pointOnSurface );\n    float specularStrength = pow( clamp( dot(reflectedLightVector, fromPointToCamera), 0.0, 1.0), 10.0);\n    // Ensure that there is no specular lighting when there is no diffuse lighting.\n    specularStrength = min( diffuseStrength, specularStrength );\n    vec3 specularColor = specularStrength * vec3( 1.0 );\n    vec3 finalColor = diffuseColor + specularColor;\n    return finalColor;\n}\n\nfloat rect(vec2 st, float horz, float vert, float soft) {\n    float h = smoothstep(-horz, -horz+soft, st.x);\n    h *= smoothstep(horz, horz-soft, st.x);\n    float v =  smoothstep(-vert, -vert+soft, st.y);\n    v *= smoothstep(vert, vert-soft, st.y);\n    return h * v;// * d;\n}\n\nfloat crossShape(vec2 st, float thick, float size, float soft) {\n    float c = rect(st, thick, size, soft);\n    c += rect(st, size, thick, soft);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 st = gl_FragCoord.xy / iResolution.xy * 2. - 1.;\n\tst.x *= iResolution.x / iResolution.y;\n\n    vec3 cameraPos = vec3(0., 0., -10.);\n    vec3 cameraDir = vec3(st.x, st.y, 1.0);\n    vec3 p;\n    vec3 color = vec3(0.);\n    float dist = rayMarch(cameraPos, cameraDir, p);\n\n    //Red cross\n    vec3 redCross = vec3(crossShape(st, 0.003, 0.02, 0.001), 0., 0.);\n\n\n    if(dist > 0.){\n        vec3 lightPos = vec3(-1., 7., -10.);\n        float camDist = normalize(length(cameraPos - p));\n        vec3 normal = getNormals(p);\n        color = calculateLighting(p, normal, lightPos, cameraPos);\n    }\n\n    color += redCross;\n    fragColor = vec4(color, 1.);\n\n}","name":"Image","description":"","type":"image"}]}