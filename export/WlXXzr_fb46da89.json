{"ver":"0.1","info":{"id":"WlXXzr","date":"1561720362","viewed":125,"name":"DIY Ray Tracing","username":"unindicated","description":"Just some maths.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int FLOOR = 0;\nconst int SPHERE = 1;\nconst int SKY = 2;\nconst int NOTHING = -1;\n\nconst int NOTEXTURE = -1;\nconst int CHANNEL0 = 0;\nconst int CHANNEL1 = 1;\n\nconst bool SUPERSAMPLE = false;\n\nstruct Solid {\n    int id;\n    int type;\n    vec3 position;\n    vec3 size;\n    vec3 reflectColour;\n};\n\nstruct Scene {\n    vec4 sunColour;\n    vec3 sunDir;\n    int skyId;\n\tSolid solids[5];\n};\n    \nstruct Hit {\n    int id;\n    float reflection;\n    int textureId;\n    vec2 uv;\n    vec3 intersection;\n    vec3 reflectedRay;\n    vec3 colourMul;\n};\n    \nHit NOHIT = Hit(-1, 0.0, 0, vec2(0), vec3(0), vec3(0), vec3(0)); \n\nHit sphereHit(vec3 origin, vec3 rayNormal, Solid solid) {\n    vec3 point;\n    vec3 originRelativePos = solid.position - origin;\n    if(intersectedSpherePoint(rayNormal, originRelativePos, solid.size.x, point)) {\n        vec3 sphereNormal = normalize(point - originRelativePos);\n        vec3 reflection = reflect(rayNormal, sphereNormal);\n        return Hit(solid.id, 1.0, NOTEXTURE, vec2(0), point + origin, reflection, solid.reflectColour);\n    } else {\n        return NOHIT;\n    }\n}\n\nHit floorHit(vec3 origin, vec3 rayNormal, Solid solid) {\n    vec3 originRelativeFloorPos = solid.position - origin;       \n    float a = (originRelativeFloorPos.y / rayNormal.y);\n    if(a > 0.0) {\n        vec3 intesersection = origin + rayNormal * a;\n        vec3 floorRelativeIntersection = intesersection - solid.position;\n        if(abs(floorRelativeIntersection.x) < solid.size.x && abs(floorRelativeIntersection.z) < solid.size.y) {\n            float textureScale = solid.size.z;\n            vec2 uv = floorRelativeIntersection.xz * textureScale;\n            return Hit(solid.id, 0.0, CHANNEL0, uv, intesersection, vec3(0), solid.reflectColour);\n        }\n    }\n    return NOHIT;\n}\n\nHit skyHit(vec3 origin, vec3 rayNormal, Solid solid) {\n    vec2 uv = rayNormal.xy;\n    return Hit(solid.id, 0.0, CHANNEL1, uv, origin + rayNormal * 1000.0, vec3(0), solid.reflectColour);\n}\n\nHit sceneHit(vec3 origin, vec3 rayNormal, Scene scene) {\n\n    Hit hit = NOHIT;\n    \n    for(int i=0; i<scene.solids.length(); i++) {\n        Solid solid = scene.solids[i];\n        \n        Hit thisHit = NOHIT;\n\n        if(solid.type == FLOOR) {\n            thisHit = floorHit(origin, rayNormal, solid);\n        } if(solid.type == SPHERE) {\n            thisHit = sphereHit(origin, rayNormal, solid);\n        } if(solid.type == SKY) {\n            thisHit = skyHit(origin, rayNormal, solid);\n        }\n\n        if(thisHit.id != NOTHING) {\n            if(hit.id == NOTHING) {\n                hit = thisHit;\n            } else {\n                float d0 = distance(origin, thisHit.intersection);\n                float d1 = distance(origin, hit.intersection);\n                if(d0 < d1 ) {\n                    hit = thisHit;\n                }\n            }\n        }\n    }\n    \n    return hit;\n}\n    \nvec4 fireRay(vec3 origin, vec3 rayNormal, Scene scene) {\n\t\n    Hit hit;\n    \n\tint loops = 4;    \n    vec3 colourMul = vec3(1);\n    \n    for(int i=0; i<loops; i++) {\n        hit = sceneHit(origin, rayNormal, scene);\n        if(hit.id != NOTHING) {\n            colourMul *= hit.colourMul;\n            if(hit.reflection == 0.0) {\n                break;\n            } else {\n                origin = hit.intersection;\n                rayNormal = hit.reflectedRay;\n            }\n        } else {\n            break;\n        }\n    }\n    \n    vec4 colour;\n    \n    if(hit.textureId == CHANNEL0) {\n        colour = texture(iChannel0, hit.uv);\n    } else if(hit.textureId == CHANNEL1) {\n        colour = texture(iChannel1, hit.uv);\n    } else {\n        colour = vec4(rayNormal, 1.0);\n    }\n    \n    colour *= scene.sunColour;\n    \n    if(hit.id == FLOOR) {\n        vec3 rayNormal = scene.sunDir;\n        vec3 origin = hit.intersection + rayNormal * 0.001;\n        Hit shadowHit = sceneHit(origin, rayNormal, scene);\n        if(shadowHit.id != scene.skyId) {\n            colour *= 0.25;\n        }\n    }\n\t\n    return colour * vec4(colourMul, 1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    Scene scene;\n    \n    scene.sunDir = normalize(vec3(0.5+sin(iTime*0.1)*0.1, 1.0, 0.5+cos(iTime*0.1)*0.1));\n    scene.sunColour = vec4(1.25);\n    \n    float mouseDx = 0.0;\n    float mouseDy = 0.0;\n\n    if(iMouse.z > 0.0) {\n        mouseDx = iMouse.x - iMouse.z;\n        mouseDy = iMouse.y - iMouse.w;\n    }\n\n    \n    int id = 0;\n    \n    scene.solids[id].id = id;\n    scene.solids[id].type = FLOOR;\n    scene.solids[id].position = vec3(0.0, -2.0, 0.0);\n    scene.solids[id].size = vec3(100.0, 100.0, 0.01);\n    scene.solids[id].reflectColour = vec3(1);\n\n    id++;\n    \n    scene.solids[id].id = id;\n    scene.solids[id].type = SPHERE;\n    scene.solids[id].position = vec3(3.5, 0.0, 15.0);\n    scene.solids[id].size = vec3(2.0, 0.0, 0.0);\n    scene.solids[id].reflectColour = vec3(0.5, 1.0, 1.0);\n    \n    id++;\n\n    scene.solids[id].id = id;\n    scene.solids[id].type = SPHERE;\n    scene.solids[id].position = vec3(-3.5, 1.0, 15.0);\n    scene.solids[id].size = vec3(3.0, 0.0, 0.0);\n    scene.solids[id].reflectColour = vec3(1.0, 0.5, 1.0);\n    \n    id++;\n\n    scene.solids[id].id = id;\n    scene.solids[id].type = SPHERE;\n    scene.solids[id].position = vec3(2.0 + mouseDx * 0.2, 3.0, 30.0 + mouseDy * 0.2);\n    scene.solids[id].size = vec3(5.0, 0.0, 0.0);\n    scene.solids[id].reflectColour = vec3(1.0, 1.0, 0.5);\n    \n    id++;\n    \n    scene.solids[id].id = id;\n    scene.solids[id].type = SKY;\n    scene.solids[id].reflectColour = vec3(1);\n    \n    scene.skyId = id;\n\n    \n    vec3 camPos = vec3(sin(iTime * 0.3) * 4.0,0,sin(iTime * 0.1) * 4.0);\n    \n    fragColor = fireRay(camPos, initialRayNormal(fragCoord + vec2(0.0,0.0), iResolution), scene);\n    \n    if(SUPERSAMPLE) {\n        fragColor += fireRay(camPos, initialRayNormal(fragCoord + vec2(0.5,0.0), iResolution), scene);\n        fragColor += fireRay(camPos, initialRayNormal(fragCoord + vec2(0.0,0.5), iResolution), scene);\n        fragColor += fireRay(camPos, initialRayNormal(fragCoord + vec2(0.5,0.5), iResolution), scene);\n        fragColor *= 0.25;\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat PI = 3.1415927;\t\n\nvec3 nearPlanePixelPos(vec2 fragCoord, vec3 resolution) {\n    float nearPlaneDist = 1.0;\n    vec2 posXY = ( fragCoord - ( resolution.xy * 0.5 ) ) / resolution.x;\n    vec3 pos = vec3(posXY, nearPlaneDist);\n    return pos;\n}\n\nvec3 initialRayNormal(vec2 fragCoord, vec3 resolution) {\n    vec3 pixelCamPos = nearPlanePixelPos(fragCoord, resolution);\n    return normalize(pixelCamPos);\n}\n\nbool intersectionDistance(vec3 rayNormal, vec3 spherePos, float radius, out float dist) {\n\n    vec3 toSphereN = normalize(spherePos);\n    float cosAngle = dot(rayNormal, toSphereN);\n    \n    if(cosAngle<0.0) {\n        return false;\n    }\n    \n    float c = length(spherePos);\n    float A = acos(cosAngle);\n    float sinA = sin(A);\n    \n    if(sinA * c > radius) {\n        return false;\n    }\n    \n    // law of sines\n    // see: https://en.wikipedia.org/wiki/Law_of_sines\n    // \"The ambiguous case of triangle solution\"\n    float a = radius;\n    float d = sinA / a;\n    float C = PI - asin( d * c );\n    // sum of angles\n    float B = PI - ( A + C );\n    // law of cosines\n    float bSquared = (a*a) + (c*c) - 2.0 * a * c * cos(B);\n    float b = sqrt(bSquared);\n    dist = b;\n    return true;\n}\n\nbool intersectedSpherePoint(vec3 rayNormal, vec3 spherePos, float radius, out vec3 point) {\n    float dist;\n    if(intersectionDistance(rayNormal, spherePos, radius, dist)) {\n        point = rayNormal * dist;\n        return true;\n    } else {\n    \treturn false;\n    }\t\n}","name":"Common","description":"","type":"common"}]}