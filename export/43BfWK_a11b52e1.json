{"ver":"0.1","info":{"id":"43BfWK","date":"1729930229","viewed":83,"name":"Basic08","username":"42n4","description":"Task from thebookofshaders.com/07/","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["test","gear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//inspired by gear function from https://www.shadertoy.com/view/Msf3D7\n//and thebookofshaders.com/07/\n#define PI 3.14159265359\n\nfloat plot (float pct, float eps, vec2 st){\n  return  smoothstep( -eps, 0., st.y - pct) -\n          smoothstep( 0., eps, st.y - pct);\n}\n\nfloat white_square(vec2 move, vec2 size, float margin, vec2 st){\n    // bottom-left\n    vec2 bl;\n    bl = smoothstep(0.,margin,st-move);\n    float pct = bl.x * bl.y;\n\n    // top-right\n    vec2 tr;\n    //tr = smoothstep(1.-move-size,1.-move-size+margin,1.-st);\n    tr = smoothstep(0.,-margin,st-move-size);\n    pct *= tr.x * tr.y;\n    return pct;\n}\n\nvec3 color_square(vec3 colorin, vec2 move, vec2 size, float margin, vec2 st){\n    vec3 color_pct = vec3(0);\n    float pct = white_square(move, size, margin, st);\n    color_pct = pct * colorin;\n    return color_pct;\n}\n\nfloat dot_circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nfloat white_circle(vec2 move, float r, float margin, vec2 st){\n    return 1.-smoothstep(-margin,+margin,distance(st,move)-r);\n}\n\nvec3 color_circle(vec3 colorin, vec2 move, float r, float margin, vec2 st){\n    float pct = white_circle(move, r, margin, st);\n    return pct * colorin;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat stepfunc(float a)\n{\n\treturn step(a, 0.0);\n}\n\nfloat white_gear(vec2 move, float size, float teeth_no, float ang, bool right, vec2 st){\n    vec2 pos = move-st;\n    float r = length(pos)*0.6/size;\n    float a = atan(pos.y,pos.x), f=0., v=0., w=0.;\n    if(right)\n        f = cos(a*teeth_no+ang+iTime);\n    else\n        f = cos(a*teeth_no+ang-iTime);\n    f = smoothstep(-.5,0.7, f)*0.2+0.5;\n    v = r - 0.1;\n\tv = min(v, v-f);\n\tw = r - 0.4;\n\tv = max(v, -w);\n    return stepfunc(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (y from 0 to 1)\n    vec2 st = fragCoord/iResolution.y;\n    float t = 0.5*iTime;\n    // gear radius\n    float r = 0.05;\n    float nx = 2.*floor(iResolution.x/iResolution.y/r/2.34/2.)+1.;\n    float ny = floor(1./r/2.34);\n\n    float frame[1000];\n    vec3 color[1000];\n    float pct[1000];\n\n    vec3 color1 = vec3(0.95, 0.7, 0.2);\n    vec3 color2 = vec3(0.30,0.833,0.224)-0.3;\n    vec3 color3 = vec3(1.00,0.833,0.224)-0.3;\n    vec3 color4 = vec3(0.30,0.833,0.224)-0.3;\n    vec3 color5 = vec3(0.90,0.13,0.324);\n\n    pct[0] = white_gear(vec2(0.5,0.45), 0.3, 10.0, 1., true, st);\n    pct[1] = white_gear(vec2(0.5+2.34*0.3,0.45), 0.3, 10.0, 2.15, false, st);\n    pct[2] = white_gear(vec2(0.5+2.34*0.3/2., 0.45), 0.3, 10.0, 1., true, st);\n    color[0] = color4;\n    color[1] = color2;\n    color[2] = color3;\n    color[3] = color1;\n    frame[0] = pct[0]*(1.-pct[1])*(1.-pct[2]);\n    frame[1] = pct[1]*(1.-pct[2]);\n    frame[2] = pct[2];\n\n    for(int i=3; i<int(ny)*int(nx)+3; i++){\n        if(i%2==0){\n            pct[i] = white_gear(vec2(r*(2.34/1.7)+(float(i)-3.-floor((float(i)-3.)/nx)*nx)*2.34*r,1.-r*(2.34/1.7)-2.34*floor((float(i)-3.)/nx)*r), r, 10., 2.15, false, st);\n            frame[i] = pct[i];\n            color[i] = color1-0.1;\n            for(int j=0;j<3;j++)\n                frame[i] = frame[i]*(1.-pct[j]);\n        }\n        else{\n            pct[i] = white_gear(vec2(r*(2.34/1.7)+(float(i)-3.-floor((float(i)-3.)/nx)*nx)*2.34*r,1.-r*(2.34/1.7)-2.34*floor((float(i)-3.)/nx)*r), r, 10., 1., true, st);\n            frame[i] = pct[i];\n            color[i] = color1;\n            for(int j=0;j<3;j++)\n                frame[i] = frame[i]*(1.-pct[j]);\n        }\n    }\n    vec3 shape = vec3(0);\n    for(int i=0; i < int(ny)*int(nx)+3; i++)\n       shape += frame[i]*color[i];\n    // output to screen\n    fragColor = vec4(shape,1.0);\n}","name":"Image","description":"","type":"image"}]}