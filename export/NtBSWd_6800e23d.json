{"ver":"0.1","info":{"id":"NtBSWd","date":"1634702776","viewed":82,"name":"BottleModel","username":"antoinefortin","description":"model","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["model"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\n/* SDF */\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat sdPlane(vec3 pos)\n{\n\treturn pos.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opu(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n\nfloat h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel1, p * 0.055).x ;    \n    float b = (sin(p.x * 2.))  ;\n    \n    b*=  ba * sin( cos( 2.)) * abs(sin(1.) + 1.25);\n    b *= b - abs(sin(iTime));\n    return -b - 1.2;\n}\n\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// Polynomial smooth minimum by iq\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nfloat bottle(vec3 pos)\n{\n    float d1 = sdSphere(pos + vec3(0, -1., 0.), 1.);\n    float d2 = sdBox(pos, vec3(1.1));\n    float bottleBody = sdRoundedCylinder(pos + vec3(0., -1.0, 0.), .25, .25, .5);\n    float bottleGoulot = sdRoundedCylinder(pos + vec3(0., -2.0, 0.), .12, .12, .25);\n    \n    \n    float ds = sdCappedCylinder(pos+ vec3(0., -1.3, 0.), .75, 1.);\n    float ds2 = sdCappedCylinder(pos+ vec3(0., -2.75, 0.), .35, .5);\n    float ds3 = sdCappedCylinder(pos+ vec3(0., -1.85, 0.), .45, .15);\n    float ds4 = sdCappedCylinder(pos+ vec3(0., -3.55, 0.), .15, .045);\n    \n    return smin(ds,smin(ds2, smin(ds3, ds4, .15), .55), .45);\n    \n    return min(bottleBody,bottleGoulot);\n    return min(d1,d2);\n}\n\n/* Scene */\nvec2 map(vec3 pos)\n{\n    \n    float box = sdBox(pos, vec3(3., .25, 3.));\n\n    \n    float bottle = bottle(pos);\n    \n    vec2 res =     vec2(box,       1.0 /*Object ID*/);\n    res = opu(res, vec2(bottle,     2.0 /*Object ID*/));   \n//    res = opu(res, vec2(arms, 3.));\n    return res;\n}\n\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n\n    float t = 0.0;\n    float id = -20.;\n\tfloat farClippingPlane = 120.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        \n    \tvec3 pos = ro + t * rd;\n        float h = map(pos).x;\n        id = map(pos).y;\n        \n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        if(t > farClippingPlane) break;\n        \n    }\n    \n    if(t > farClippingPlane) t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x\n    \t\t\t\t));\n}\n\nvoid resetToZero(inout vec3 r)\n{\n\tr = vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tvec3 ro = vec3(0., 5.55 ,-3.5);\n\t//vec3 rd = normalize(vec3(uv.x, uv.y - .2,1.)); \n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(m.x * 12.);\n\tvec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\tvec3 col = vec3(.22);\n\t\n\t\n\tfloat hitDistance = castRay(ro, rd).x;\n    float objectId = castRay(ro, rd).y;\n    \n    vec3 unfinishedSky;\n    \n    // No hit color\n    if(hitDistance < 0.01)\n    {\n        \n        /* Sky properties*/\n        vec3 skyColor = vec3(.4, 0.75, 12.0);\n        float skyMovement = .5;\n\t\tcol = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n        \n        col = vec3(0.15);\n        \n    }\n    \n    \n    if(hitDistance > 0.)\n    {\n       \tvec3 debugColor = vec3(1.);\n        vec3 pos = ro + hitDistance * rd;\n        vec3 normalWS = calcNormal(pos);\n\n        /* Global Lighting section */\n        \n        // Sky\n        vec3 skyColor = vec3(.4, 0.75, .12);\n\t\t\n        //col = skyColFactor;\n        vec3 sundir = normalize(vec3(0.2, 0.4, 0.2));\n        float sundif = clamp(dot(normalWS, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + normalWS * 0.001, sundir).x,0., 1.);\n        float sky_dif = clamp(dot(normalWS,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n        \n        bool materialSystem = true;\n        \n        if(materialSystem)\n        {\n            \n            if(objectId == 2.)\n            {\n                float f = dot(normalWS, pos); \n                vec3 ambiant = vec3(.12, .26, .38);\n                vec3 bottleColor =ambiant * vec3(f); \n                col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha + bottleColor;\n                 col += vec3(0.0, 0.2, 0.4) * sky_dif;\n               //  col *= bottleColor;\n     \n            }\n        }\n\n        \n        col = col;\n        \n\t}\n    // Output to screen\n    fragColor = vec4(sqrt(col * abs(sin(uv.x - 1.))) * 1.,1.0);\n}","name":"Image","description":"","type":"image"}]}