{"ver":"0.1","info":{"id":"3tjGzd","date":"1566674522","viewed":277,"name":"Inside the Helix","username":"holtsetio","description":"Recursive Helix made out of torii","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","raymarcher","helix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Parameters\n#define outerT 3.5\n#define FUZZ 0.50\n#define PHASELENGTH 30.0\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define EPSILON 0.0005\n#define KEPLER_MAXITER 2\n#define MAXSTEPS 150\n#define MAXDIST 95.0\n#define PHASE mod(iTime/PHASELENGTH,1.0)\n\n\nvec3 glow = vec3(0);\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 buildtransform(vec3 point, float off, vec3 trans, bool isNeg) {\n    vec3 zaxis = normalize(point);\n    vec3 xaxis = normalize(vec3(zaxis.z, 0.0, -zaxis.x));\n    if (!isNeg && zaxis.x < 0.0) {\n        xaxis *= -1.0;\n    }\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat4(xaxis.x, yaxis.x, zaxis.x, 0,\n                xaxis.y, yaxis.y, zaxis.y, 0,\n                xaxis.z, yaxis.z, zaxis.z, 0,\n                dot(xaxis,trans),dot(yaxis,trans),dot(zaxis,trans)+off,1);\n}\n\n   \nfloat solveKeplerHalley(float e,float M) {\n    float E =clamp(M+PI,0.00,PI);\n    int i=0;\n    while(i<KEPLER_MAXITER) {\n        float esinE = e*sin(E);\n        float k0mM = (E-esinE)-M;\n        float k1 = (1.0-e*cos(E));\n        E -= (2.0*k0mM*k1)/(2.0*k1*k1-k0mM*(esinE));\n        i++;\n    }\n    return E;\n}\n\nfloat solveKepler(float e, float M) {\n    //http://www.jgiesen.de/kepler/kepler.html\n    if (e >= 1.0) {\n        return solveKeplerHalley(e,M);\n    }\n    float E = (e < 0.8 ? M : PI);\n    float F = E - e*sin(M)-M;\n    int i = 0;\n    while (i < KEPLER_MAXITER) {\n    \tE -= F/(1.0 - e*cos(E));\n        F = E - e*sin(E) - M;\n        i++;\n    }\n\treturn E;\n}\n\nstruct HelixHit {\n\tvec4 p;\n    float strand;\n    float theta;\n};\n\n// Computes the closest point to p on a Helix (R,T) with n strands.\n// The returned struct contains the closest point, the strand and the point Theta on the helix.\nHelixHit ClosestPointHelixStep(vec4 p, float R, float T, float n_helices, float stepsize,float offset) {\n    // Nievergelt 2009\n    // doi: 10.1016/j.nima.2008.10.006\n    \n    //Helix: H(Theta) = [R*cos(Theta), R*sin(Theta), T*Theta]\n    //Point: D = (u, v, w) = [r * cos(delta), r * sin(delta), w]\n    HelixHit res;\n    float delta = atan(p.y, p.x);\n    float r = length(p.yx);\n    float kt = ((p.z/T)-delta)/TWOPI;\n    float inv_n_helices = 1.0/n_helices;\n    float n = floor((fract(kt) + 0.5*inv_n_helices)/inv_n_helices -0.5);\n    float s_offset = -(n+0.5)*inv_n_helices*TWOPI;\n    float dktp = delta + round(kt-(n+0.5)*inv_n_helices) * TWOPI; \n    float M = PI + (p.z/T) + s_offset - dktp;\n    float e = (r*R)/(T*T);\n    float E = solveKepler(e,M);\n    float Theta = E - PI + dktp;\n    Theta = round((Theta-s_offset+offset)/stepsize)*stepsize+s_offset-offset;\n    \n    res.theta = (Theta-s_offset);\n    res.strand=n;\n    res.p = vec4(R*cos(Theta), R*sin(Theta), res.theta*T,1.0);\n    res.theta += s_offset;\n    \n    \n    return res;\n}\n\nstruct TorusHit {\n  \tvec4 p;\n  \tfloat angle;\n};\n\nTorusHit sdTorus(vec4 pos, float r1)\n{\n  \tTorusHit hit;\n  \thit.angle = atan(pos.y,pos.x);\n  \thit.p = vec4(normalize(pos.xy)*r1,0,1);\n    return hit;\n}\n\nstruct Result {\n\tfloat dist;\n    vec4 n;\n};\nResult ED(vec4 p) {\n    float T = outerT;\n    HelixHit hit = ClosestPointHelixStep(p,4.0,T,3.0,PI/6.5,PHASE*TWOPI);\n\n    Result res;\n    \n    vec3 lookDir = (vec3(hit.p.y,-hit.p.x,-T));\n    mat4 transform = buildtransform(lookDir.xyz,0.0,-hit.p.xyz,true);\n    TorusHit hit2 = sdTorus(transform*p,1.7);\n    \n    vec3 lookDir2 = (vec3(hit2.p.y,-hit2.p.x,0));\n    transform = buildtransform(lookDir2.xyz,-hit2.angle*1.7,-hit2.p.xyz,false) * transform;\n    float T2 = 0.34;\n    HelixHit hit3 = ClosestPointHelixStep(transform*p,0.6,T2,2.0,PI/10.0,0.0);\n    \n    glow += normalize(vec3(0.8 + 0.4*sin(2.0*PHASE*TWOPI+0.75*PI),1.0,0.6+0.4*sin(PHASE*TWOPI))) * pow(max(0.0,(1.0-1.0*length(hit3.p - transform*p))),2.0) * 0.031;\n    \n    vec3 lookDir3 = (vec3(hit3.p.y,-hit3.p.x,-T2));\n    transform = buildtransform(lookDir3.xyz,0.0,-hit3.p.xyz,true) * transform;\n    TorusHit hit4 = sdTorus(transform*p,0.15+0.05*hit3.strand*0.0+0.05*sin(15.0*PHASE*PI*2.0+hit3.theta*2.0+1.0*hit3.strand*3.14159));\n    \n    \n    mat4 inv = inverse(transform);\n    res.dist = distance(p,inv*hit4.p)-0.043*2.00;\n    res.n = inv*normalize(transform*p-hit4.p);\n\treturn res;\n}\n\nvec3 raymarch(vec4 orig, vec4 dir) {\n    float dist = 0.0;\n    float minDist = 1e9;\n    int steps = 0;\n    vec4 pos = orig;\n    Result res;\n    res.dist = 1e9;\n    \n    while (dist < MAXDIST && steps < MAXSTEPS && res.dist >= EPSILON) {\n    \tres = ED(pos);\n        minDist = min(minDist,res.dist);\n        \n        dist += FUZZ*res.dist;\n        \n        pos = orig + dist*dir;\n    \tsteps++;\n    }\n    glow = pow(glow,vec3(1.2));\n    return pow(1.0-glow,vec3(1.0+4.0*dist/MAXDIST));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.x * PI * 0.5;\n    \n    vec4 raydir = normalize(vec4(sin(uv.x),1.0,-sin(uv.y),0.0));\n    vec4 rayorig = vec4(0.0,0.0,2.0*PHASE*TWOPI*outerT,1);\n    \n    vec2 rot = (iMouse.xy / iResolution.xy - 0.5) * 2.0 * PI;\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n    \trot = vec2(0,0);\n    rot += vec2(0.0,-0.5)*PI;\n    \n    mat4 m = rotationY(-rot.x) * rotationX(rot.y);\n    raydir = m * raydir;\n\n    fragColor = vec4(raymarch(rayorig, raydir),1.0);\n}","name":"Image","description":"","type":"image"}]}