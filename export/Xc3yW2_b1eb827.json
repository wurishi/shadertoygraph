{"ver":"0.1","info":{"id":"Xc3yW2","date":"1731138351","viewed":22,"name":"TP MIF02 Informatique Graphique","username":"KatiaL","description":"TP Image","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["enzo","katia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n\n\nstruct Ray{\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Val {\n  float v; // Signed distance\n  int c;   // Cost\n};\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray, float t)\n{\n    return ray.o + t * ray.d;\n}\n\n// material mat et réfléchissant\nstruct Material {\n    vec3 ambient;    // Couleur ambiante\n    vec3 diffuse;    // Couleur diffuse\n    vec3 specular;   // Couleur spéculaire\n    float shininess; // Coefficient de brillance\n    float reflectivity; // Coefficient de réflexion (0 pour mat, 1 pour très réfléchissant)\n};\n\n// Structure contenant les informations sur l'objet à un point donné\nstruct ObjectInfo {\n    float distance;\n    Material material;\n    int cost;\n};\n\n// Fonction pour créer une texture à rayures bleues claires et violettes\nvec3 stripedTexture(vec3 p, float stripeWidth) {\n    // Calculer la position X pour déterminer l'index de la rayure\n    float stripeIndex = floor(p.z / stripeWidth);\n    \n    // Définir les couleurs pour les rayures\n    vec3 lightBlue = vec3(0.6, 0.8, 1.0);  \n    vec3 purple = vec3(0.6, 0.2, 0.8);     \n    \n    // Alterner entre les couleurs en fonction de l'index de la rayure\n    vec3 color = mod(stripeIndex, 2.0) < 1.0 ? lightBlue : purple;\n    \n    return color; // Retourner la couleur calculée\n}\n\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed, vec3 n)\n{\n    float a = fract(sin(176.19 * float(seed))); // Uniform randoms\n    float b = fract(sin(164.19 * float(seed)));\n    \n    float u = 2. * 3.1415 * a; // Random angle\n    float v = acos(2. * b - 1.); // Arccosine distribution to compensate at poles\n    \n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v)); // Direction\n    if (dot(d, n) < 0.) { d = -d; } // Hemisphere\n    \n    return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\nRay CreateRay(vec2 m, vec2 p)\n{\n  float a = 3. * 3.14 * m.x;\n  float le = 3.5;\n  \n  // Origin\n  vec3 ro = vec3(37., 0., 15.);\n  ro *= Rz(a);\n  \n  // Target point\n  vec3 ta = vec3(0., 0., 1.);\n  \n  // Orthonormal frame\n  vec3 w = normalize(ta - ro);\n  vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n  vec3 v = normalize(cross(u, w));\n  vec3 rd = normalize(p.x * u + p.y * v + le * w);\n  return Ray(ro, rd);\n}\n\n\n\n// Operators ------------------------------------------------------------------------------\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a, Val b)\n{\n    return Val(min(a.v, b.v), a.c + b.c + 1);\n}\n\n// Subtraction\n// a,b : field function of left and right\nVal Subtraction(Val a, Val b)\n{\n    return Val(max(a.v, -b.v), a.c + b.c + 1);\n}\n\n// Intersection\n// a,b : field function of left and right sub-trees\nVal Intersection(Val a, Val b)\n{\n    return Val(max(a.v, b.v), a.c + b.c + 1);\n}\n\n// Deformation Function ------------------------------------------------------------------------------\n\n\n// Simple noise function using sin and fract for randomization\nfloat Noise(vec3 p)\n{\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 37.719))) * 43758.5453);\n}\n\n// Function to add noise to an object's SDF to create surface bumps or crevices\n// v : The original SDF value (distance from point to surface)\n// p : Point in space where the noise is evaluated\n// scale : Scale of the noise (controls the frequency of the noise)\n// strength : Strength of the perturbation\nfloat AddNoise(float v, vec3 p, float scale, float strength)\n{\n    // Apply noise to perturb the SDF\n    float noise = Noise(p * scale);\n    return v + noise * strength;\n}\n\n// Function for Fractal Brownian Motion (FBM) based turbulence\nfloat FBM(vec3 p, int octaves, float persistence)\n{\n    float total = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float maxValue = 0.0; // Normalization factor\n\n    for (int i = 0; i < octaves; i++)\n    {\n        total += Noise(p * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n\n    return total / maxValue;\n}\n\n// Function to add turbulence to an object's SDF\nfloat AddTurbulence(float v, vec3 p, float scale, float strength)\n{\n    float turbulence = FBM(p * scale, 5, 0.5); // 5 octaves, persistence 0.5\n    return v + turbulence * strength;\n}\n\n// Function to create a marble-like texture using turbulence\nfloat Marble(vec3 p, float scale)\n{\n    float turbulence = FBM(p * scale, 5, 0.5);\n    return sin(p.x * scale + turbulence);\n}\n\n// Primitives -------------------------------------------------------------------------------\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nVal Plane(vec3 p, vec3 o, vec3 n)\n{\n    return Val(dot((p - o), normalize(n)), 1);\n}\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nVal Sphere(vec3 p, vec3 c, float r)\n{\n    return Val(length(p - c) - r, 1);\n}\n\n// Primitives 2.0 -------------------------------------------------------------------------------\n\n// Function to create a cube using intersections of planes\n// p : Point in space where the distance is evaluated\n// c : Center of the cube\n// size : Full size of the cube (each side of the cube)\n// TEST : Cube(p, vec3(0.,0.,0.), 2.)\nVal Cube(vec3 p, vec3 c, float size)\n{\n    vec3 d = abs(p - c) - vec3(size);\n\n    float distance = length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n\n    return Val(distance, 1);\n}\n\n// Function to create a cube using intersections of six planes\n// p : Point in space where the distance is evaluated\n// c : Center of the cube\n// size : Full size of the cube (each side of the cube)\n// TEST : Cube_bis(p, vec3(0.,0.,0.), 5.);\nVal Cube_bis(vec3 p, vec3 c, float size)\n{\n    \n    Val r1 = Plane(p, c + vec3(0., 0., size), vec3(0., 0., 1.));\n    \n    r1 = Intersection(r1, Plane(p, c + vec3(0., 0., -size), vec3(0., 0., -1.)));\n\n    r1 = Intersection(r1, Plane(p, c + vec3(0., size, 0.), vec3(0., 1., 0.)));\n\n    r1 = Intersection(r1, Plane(p, c + vec3(0., -size, 0.), vec3(0., -1., 0.)));\n\n    r1 = Intersection(r1, Plane(p, c + vec3(size, 0., 0.), vec3(1., 0., 0.)));\n\n    r1 = Intersection(r1, Plane(p, c + vec3(-size, 0., 0.), vec3(-1., 0., 0.)));\n\n    return r1;\n}\n\n// Tore\n// p : Point in space where the distance is evaluated\n// c : Center of the tor\n// r : rayon of the tor\n// R : \n// TEST : Torus(p, vec3(0.,0.,0.), 0.5, 2.);\nVal Torus(vec3 p, vec3 c, float r, float R)\n{\n    vec3 u = (p - c);\n    \n    vec2 q = vec2(length(u.xz) - R, u.y);\n    \n    return Val(length(q) - r, 1);\n}\n\n// Infinite Cylinder\n// p : Point in space where the distance is evaluated\n// c : Center of the cylinder\n// r : Raduis of the cylinder\n// TEST : Infinite_Cylinder(p, vec3(0.,0.,0.), 2.)\nVal Infinite_Cylinder(vec3 p, vec3 c, float r)\n{\n    float n = (length(p.xy - c.xy) - r);\n    \n    return Val(n, 1);\n}\n\n// Cylinder orifice in Z\n// p : Point in space where the distance is evaluated\n// c : Center of the cylinder\n// r : Radius of the cylinder\n// d : \n// TEST : Cylinder_z(p, vec3(0.,0.,0.), 2., 2.)\nVal Cylinder_z(vec3 p, vec3 c, float r, float d)\n{\n    Val n = Val(length(p.xy - c.xy) - r, 1);\n    \n    n = Subtraction(n, Plane(p, c + vec3(0., 0., -d), vec3(0., 0., 1.)));\n    \n    n = Subtraction(n, Plane(p, c + vec3(0., 0., d), vec3(0., 0., -1.)));\n    \n    return n;\n}\n\n// Cylinder orifice in Y\n// p : Point in space where the distance is evaluated\n// c : Center of the cylinder\n// r : Radius of the cylinder\n// d : \n// TEST : Cylinder_y(p, vec3(0.,0.,0.), 2., 2.)\nVal Cylinder_y(vec3 p, vec3 c, float r, float d)\n{\n    Val n = Val(length(p.xz-c.xz)-r, 1);\n    \n    n=Subtraction(n,Plane(p,c+vec3(0.,-d,0.),vec3(0.,1.,0.)));\n    \n    n=Subtraction(n,Plane(p,c+vec3(0.,d,0.),vec3(0.,-1.,0.)));\n    \n    return n;\n}\n\n\n// Cylinder along X axis\n// p : Point in space where the distance is evaluated\n// c : Center of the cylinder\n// r : Radius of the cylinder\n// d : Length of the cylinder\n// TEST : Cylinder_x(p, vec3(0.,0.,0.), 2., 1.);\nVal Cylinder_x(vec3 p, vec3 c, float r, float d)\n{\n    Val n = Val(length(p.yz - c.yz) - r, 1);\n    \n    n = Subtraction(n, Plane(p, c + vec3(-d, 0., 0.), vec3(1., 0., 0.)));\n    \n    n = Subtraction(n, Plane(p, c + vec3(d, 0., 0.), vec3(-1., 0., 0.)));\n    \n    return n;\n}\n\n// Function to create a capsule along the X axis\n// p : Point in space where the distance is evaluated\n// c : Center of the capsule\n// r : Radius of the capsule\n// d : Half the distance between the spheres at the ends\n// TEST : Capsule_x(p, vec3(0.,0.,0.), 2., 1.);\nVal Capsule_x(vec3 p, vec3 c, float r, float d)\n{\n    float n = length(p.yz - c.yz) - r;\n\n    Val valN = Val(n, 1);\n    \n    valN = Subtraction(valN, Plane(p, c + vec3(-d, 0., 0.), vec3(1., 0., 0.)));\n\n    valN = Subtraction(valN, Plane(p, c + vec3(d, 0., 0.), vec3(-1., 0., 0.)));\n\n    valN = Union(valN, Sphere(p, c + vec3(d, 0., 0.), r));\n\n    valN = Union(valN, Sphere(p, c + vec3(-d, 0., 0.), r));\n\n    return valN;\n}\n\n// Function to create a capsule along the Y axis\n// p : Point in space where the distance is evaluated\n// c : Center of the capsule\n// r : Radius of the capsule\n// d : Half the distance between the spheres at the ends\n// TEST : Capsule_y(p, vec3(0.,0.,0.), 2., 1.);\nVal Capsule_y(vec3 p, vec3 c, float r, float d) \n{\n    \n    float n = length(p.xz - c.xz) - r;  \n    \n    Val valN = Val(n, 1);\n    \n    valN = Subtraction(valN, Plane(p, c + vec3(0., -d, 0.), vec3(0., 1., 0.)));\n    \n    valN = Subtraction(valN, Plane(p, c + vec3(0., d, 0.), vec3(0., -1., 0.))); \n    \n    valN = Union(valN, Sphere(p, c + vec3(0., d, 0.), r));  \n    \n    valN = Union(valN, Sphere(p, c + vec3(0., -d, 0.), r));  \n    \n    return valN;\n}\n\n// Function to create a capsule along the Z axis\n// p : Point in space where the distance is evaluated\n// c : Center of the capsule\n// r : Radius of the capsule\n// d : Half the distance between the spheres at the ends\n// TEST : Capsule_z(p, vec3(0.,0.,0.), 2., 1.);\nVal Capsule_z(vec3 p, vec3 c, float r, float d) \n{\n    \n    float n = length(p.xy - c.xy) - r; \n    \n    Val valN = Val(n, 1);\n    \n    valN = Subtraction(valN, Plane(p, c + vec3(0., 0., -d), vec3(0., 0., 1.)));\n    \n    valN = Subtraction(valN, Plane(p, c + vec3(0., 0., d), vec3(0., 0., -1.))); \n    \n    valN = Union(valN, Sphere(p, c + vec3(0., 0., d), r));  \n    \n    valN = Union(valN, Sphere(p, c + vec3(0., 0., -d), r));  \n    \n    return valN;\n}\n\n// Advanced Shape ---------------------------------------------------------\n\n// Function to create a double cube structure \n// p : Point in space where the distance is evaluated\n// d : Size of the cubes\n// r : Radius of the cylinders\n// TEST : Double_Cube(p, 3., 2.);\nVal Double_Cube(vec3 p, float d, float r)\n{\n    Val v = Cube(p, vec3(0., 0., 0.), d);\n    v = Subtraction(v, Cube(p, vec3(0., 0., 0.), d - 0.2));\n\n    v = Subtraction(v, Cylinder_z(p, vec3(0., 0., 0.), r, d));\n    v = Subtraction(v, Cylinder_y(p, vec3(0., 0., 0.), r, d));\n    v = Subtraction(v, Cylinder_x(p, vec3(0., 0., 0.), r, d));\n\n    Val u = Cube(p, vec3(d, d, d), d);\n    u = Subtraction(u, Cube(p, vec3(d, d, d), d - 0.2));\n\n    u = Subtraction(u, Cylinder_z(p, vec3(d, d, d), r, d));\n    u = Subtraction(u, Cylinder_y(p, vec3(d, d, d), r, d));\n    u = Subtraction(u, Cylinder_x(p, vec3(d, d, d), r, d));\n\n    v = Union(v, u);\n\n    return v;\n}\n\n\n// Function to create a spiral tower structure\n// p : Point in space where the distance is evaluated\n// size : Size of each sphere and cylinder in the tower\n// height : Number of stacked spheres\n// radius : Radius of the cylinders\n// TEST : Spiral_Tower(p, 1.5, 10, 0.5);\nVal Spiral_Tower(vec3 p, float size, int height, float radius)\n{\n    Val shape = Sphere(p, vec3(0., 0., 0.), size);\n\n    for (int i = 1; i <= height; i++)\n    {\n        float y_offset = float(i) * size * 2.0;\n        \n        shape = Union(shape, Sphere(p, vec3(sin(float(i) * 0.5) * radius * 2., y_offset, cos(float(i) * 0.5) * radius * 2.), size));\n\n        shape = Union(shape, Cylinder_z(p, vec3(sin(float(i) * 0.5) * radius * 2., y_offset - size, cos(float(i) * 0.5) * radius * 2.), radius * 0.5, size * 4.));\n    }\n\n    return shape;\n}\n\n\n// Function to create a stacked double torus structure with a sphere in the center\n// p : point in space where the distance is evaluated\n// r : small radius of the torus\n// R : large radius of the torus\n// size : size of the central sphere\n// TEST : Double_Torus(p, 0.5, 2.0, 1.0);\nVal Double_Torus(vec3 p, float r, float R, float size)\n{\n    Val shape = Sphere(p, vec3(0., 0., 0.), size);  \n    \n    shape = Union(shape, Torus(p, vec3(0., 2.0 * size, 0.), r, R));\n\n    shape = Union(shape, Torus(p, vec3(0., -2.0 * size, 0.), r, R));\n\n    return shape;\n}\n\n// Function to create a dice shape using the intersection of a cube and an inscribed sphere\n// p : Point in space where the distance is evaluated\n// c : Center of the dice\n// r : Radius, which is half the size of the dice\n// TEST : Dice(p, vec3(0.,0.,0.), 2.0);\nVal Dice(vec3 p, vec3 c, float r)\n{\n    Val cube = Cube(p, c, r * 0.75); \n    \n    Val sphere = Sphere(p, c, r); \n    \n    return Intersection(cube, sphere);\n}\n\n\n// Function to create a noisy sphere with surface perturbations\nVal NoisySphere(vec3 p, vec3 c, float r, float noiseScale, float noiseStrength)\n{\n    float sdf = Sphere(p, c, r).v;\n    \n    sdf = AddNoise(sdf, p, noiseScale, noiseStrength);\n    \n    return Val(sdf, 1);\n}\n\n\n\n// Bounding Volume -----------------------------------------------------------------\n\n// Bounding Box (AABB - Axis-Aligned Bounding Box)\n// p : Point in space where the distance is evaluated\n// minBounds : Minimum corner of the box\n// maxBounds : Maximum corner of the box\n// TEST : BoundingBox(p, vec3(0.,0.,0.), vec3(10.,10.,10.))\nVal BoundingBox(vec3 p, vec3 minBounds, vec3 maxBounds)\n{\n    vec3 d = max(minBounds - p, p - maxBounds);\n    float dist = length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n    return Val(dist, 1);\n}\n\n\n\n// Potential field of the object\n// p : The point in space where the distance is evaluated\nVal object(vec3 p)\n{\n\n    // objects\n    Val sphere1 = Sphere(p, vec3(0, 0, 1), 1.5);\n    Val cube1 = Cube(p, vec3(2, 2, 2), 2.0);\n    Val torus1 = Torus(p, vec3(-2, -2, 1), 1.2, 1.5);\n    \n    // Combine objects\n    Val result = Union(sphere1, cube1);\n    result = Union(result, torus1);\n    \n    // Add a ground plane\n    Val ground = Plane(p, vec3(0, 0, -2), vec3(0, 0, 1));\n    \n    // Union the result with the ground plane\n    result = Union(result, ground);\n    \n    return result;\n}\n\n\nconst int Steps = 200; // Number of steps\nconst float Epsilon = .01; // Marching epsilon\n\n// Bounding volume\nVal boundingVolume(vec3 p)\n{\n    //return BoundingBox(p, vec3(-2, -2, -2), vec3(2, 2, 2));\n    return Sphere(p, vec3(0, 0, 0), 8.0);\n}\n\n// DirectRayCast\nVal DirectRayCast(Ray ray, float maxDist)\n{\n    float t = 0.0;\n    int steps = 0;\n    int totalCost = 0;\n    \n    while (t < maxDist && steps < Steps)\n    {\n        vec3 p = Point(ray, t);\n        Val res = object(p);\n        totalCost += res.c;\n        \n        if (res.v < Epsilon) return Val(t, totalCost);\n        \n        t += res.v;\n        steps++;\n    }\n    \n    return Val(-1.0, totalCost); // No intersection\n}\n\n// BoundedRayCast\nVal BoundedRayCast(Ray ray, float maxDist)\n{\n    float t = 0.0;\n    int steps = 0;\n    int totalCost = 0;\n    \n    while (t < maxDist && steps < Steps)\n    {\n        vec3 p = Point(ray, t);\n        Val boundingRes = boundingVolume(p);\n        totalCost += boundingRes.c;\n        \n        if (boundingRes.v < Epsilon)\n        {\n            Val objectRes = object(p);\n            totalCost += objectRes.c;\n            \n            if (objectRes.v < Epsilon) return Val(t, totalCost);\n            \n            t += objectRes.v;\n        }\n        else\n        {\n            t += boundingRes.v;\n        }\n        \n        steps++;\n    }\n    \n    return Val(-1.0, totalCost); // No intersection\n}\n\n// Reflectivity ---------------------------------------------------------------------------\n\n\n// Fonction qui retourne les informations sur l'objet à un point donné\n// p : Le point où évaluer l'objet\nObjectInfo matObject(vec3 p) {\n    // Define materials with distinct colors for matte and reflective objects\n    Material mat01 = Material(\n        vec3(0.1), // Ambient\n        stripedTexture(p, 0.11), // Diffuse (utilise la texture à rayures verticales)\n        vec3(0.8), // Specular\n        32.0, // Shininess\n        0.2 // Reflectivity\n    );\n    \n    //Material mat01 = Material(vec3(0.1), vec3(0.9, 0.5, 0.5), vec3(0.8), 32.0, 0.);\n    Material mat02 = Material(vec3(0.1), vec3(0.5, 0.9, 0.5), vec3(1.0), 64.0, 0.);\n    Material mat03 = Material(vec3(0.1), vec3(0.5, 0.5, 0.9), vec3(1.2), 128.0, 0.);\n    Material matGround = Material( vec3(0.1), vec3(0.5, 0.5, 0.9), vec3(0.2), 16.0, 0.1);\n\n    Val sphere1 = Sphere(p, vec3(0, 0, 1), 1.5);\n    Val cube1 = Cube(p, vec3(3, 3, 2), 2.0);\n    Val torus1 = Torus(p, vec3(-3, -3, 1), 1.2, 1.5);\n    \n    // Add a ground plane at z = -2\n    Val ground = Plane(p, vec3(0, 0, -3), vec3(0, 0, 1));\n\n    ObjectInfo result;\n    result.distance = sphere1.v;\n    result.material = mat01;\n    result.cost = sphere1.c;\n\n    if (cube1.v < result.distance) {\n        result.distance = cube1.v;\n        result.material = mat02;\n        result.cost = cube1.c;\n    }\n\n    if (torus1.v < result.distance) {\n        result.distance = torus1.v;\n        result.material = mat02;\n        result.cost = torus1.c;\n    }\n    \n    if (ground.v < result.distance) {\n        result.distance = ground.v;\n        result.material = matGround;\n        result.cost = ground.c;\n    }\n    \n\n\n    return result;\n}\n\n// Calcule la normale de l'objet à un point donné\n// p : Le point où calculer la normale\nvec3 ObjectNormal2(vec3 p)\n{\n    const float eps = 0.001;\n    vec3 n;\n    ObjectInfo center = matObject(p);\n    float v = center.distance;\n\n    n.x = matObject(vec3(p.x + eps, p.y, p.z)).distance - v;\n    n.y = matObject(vec3(p.x, p.y + eps, p.z)).distance - v;\n    n.z = matObject(vec3(p.x, p.y, p.z + eps)).distance - v;\n\n    return normalize(n);\n}\n\n// Function to compute the reflected ray from a surface\n// incidentRay : The incoming ray that hits the surface\n//       point : The point of intersection on the surface\n//      normal : The normal vector at the intersection point\nRay ReflectRay(Ray incidentRay, vec3 point, vec3 normal) {\n    Ray reflectedRay;\n    reflectedRay.o = point + normal * Epsilon;\n    reflectedRay.d = reflect(incidentRay.d, normal);\n    return reflectedRay;\n}\n\nbool SphereTrace2(Ray ray, float maxDist, out float t, out int s, out int c)\n{\n    t = 0.0;\n    s = 0;\n    c = 0;\n    \n    for (int i = 0; i < Steps; i++)\n    {\n        vec3 p = Point(ray, t);\n        ObjectInfo info = matObject(p);\n        c += info.cost;\n        \n        if (info.distance < Epsilon)\n        {\n            s = i;\n            return true;\n        }\n        \n        t += info.distance;\n        if (t > maxDist) break;\n    }\n    \n    return false;\n}\n\n// Fonction de rendu principal\n//        ray : Le rayon de la caméra\n//    maxDist : La distance maximale de rendu\n// maxBounces : Le nombre maximum de rebonds pour les réflexions\nvec3 Render(Ray ray, float maxDist) {\n    float t;\n    int s, c;\n    bool hit = SphereTrace2(ray, maxDist, t, s, c);\n    \n    if (hit) {\n        vec3 p = Point(ray, t);\n        vec3 n = ObjectNormal2(p);\n        ObjectInfo objInfo = matObject(p);\n        Material mat = objInfo.material;\n        \n        // Calcul de l'éclairage direct\n        vec3 lightDir = normalize(vec3(1, 1, 1));\n        float diff = max(dot(n, lightDir), 0.0);\n        vec3 reflectDir = reflect(-lightDir, n);\n        float spec = pow(max(dot(ray.d, reflectDir), 0.0), mat.shininess);\n        \n        vec3 color = mat.ambient + diff * mat.diffuse + spec * mat.specular;\n        \n        // Calcul de la réflexion\n        if (mat.reflectivity > 0.0) {\n            Ray reflectedRay;\n            reflectedRay.o = p + n * Epsilon;\n            reflectedRay.d = reflect(ray.d, n);\n            \n            float reflectedT;\n            int reflectedS, reflectedC;\n            bool reflectedHit = SphereTrace2(reflectedRay, maxDist, reflectedT, reflectedS, reflectedC);\n            \n            if (reflectedHit) {\n                vec3 reflectedP = Point(reflectedRay, reflectedT);\n                ObjectInfo reflectedObjInfo = matObject(reflectedP);\n                vec3 reflectedColor = reflectedObjInfo.material.diffuse; // Simplification\n                \n                color = mix(color, reflectedColor, mat.reflectivity);\n            }\n        }\n        \n        return color;\n    }\n    \n    return vec3(0., 0., 0.); // Couleur de fond\n}\n\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\n\n\n// Object normal\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps = .001;\n  vec3 n;\n  Val val = object(p);\n  float v = val.v;\n  n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n  n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n  n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\n//   r : reflexivity\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c, out float r)\n{\n  bool h = false;\n  \n  // Start at the origin\n  t = 0.0;\n  c = 0;\n  \n  for (int i = 0; i < Steps; i++)\n  {\n    s = i;\n    vec3 p = Point(ray, t);\n    Val val = object(p);\n    float v = val.v;\n    c += val.c;\n    // Hit object\n    if (v < 0.)\n    {\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += max(Epsilon, v);\n    // Escape marched too far away\n    if (t > e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\nbool BoundingSphereTrace(Ray ray, float e, vec3 center, float radius, out float t, out int s, out int c)\n{\n    bool hit = false;\n    float r;// reflexivity\n    \n    Val boundingSphere = Sphere(Point(ray, t), center, radius);\n    if (boundingSphere.v < 0.)\n    {\n        hit = SphereTrace(ray, e, t, s, c, r); \n    }\n\n    return hit;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\n\n\n//Occlusion calculates ambient occlusion at a point p on a surface\n//          p : point in space where ambient occlusion is being calculated\n//          n : normal vector at point p\n// numSamples : number of random rays (samples) used to calculate ambient occlusion.\n//          R : maximum distance up to which occlusion is considered\nfloat Occlusion(vec3 p, vec3 n, int numSamples, float R) {\n  int hits = 0;\n\n  for (int i = 0; i < numSamples; i++) {\n      // Générer une direction aléatoire dans l'hémisphère autour de la normale\n      vec3 randomDir = Hemisphere(i, n);\n        \n        // Lancer un rayon depuis p dans la direction aléatoire\n      float t;\n      int s;\n      int c;\n      float r;\n      bool hit = SphereTrace(Ray(p + Epsilon * n, randomDir), R, t, s, c, r);\n        \n        // Si le rayon intersecte quelque chose avant R, on compte un \"hit\"\n      if (hit && t < R) {\n          hits += 1;\n      }\n  }\n    // Calculer la fraction d'occlusion : (1 - hits / numSamples)\n  float occlusion = 1.0 - float(hits) / float(numSamples);\n  return occlusion;\n}\n\n// Background color\nvec3 background(Ray ray)\n{\n  return mix(vec3(.45, .55, .99), vec3(.65, .69, .99), ray.d.z * .5 + .5);\n}\n\n\n// Shadowing\nfloat Shadow(vec3 p, vec3 n, vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  float r;\n  bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100., t, s, c, r);\n  if (!hit)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Soft shadow\n// max_dist : Distance maximale pour le ray tracing de l'ombre\n// t : Distance de départ pour éviter les auto-intersections\nfloat SoftShadow(vec3 p, vec3 n, vec3 l, int nb_rayons) {\n    float shadow = 1.0;\n    float max_dist = 100.0;    \n    float t = 0.02;            \n    float k = 16.0;            // Constante de douceur de l'ombre\n    float ts, r;                  // Distance trouvée par SphereTrace\n    int s, c;                  // Variables pour l'état du hit\n\n    // Parcours dans la direction de la lumière\n    for (int i = 0; i < nb_rayons; i++) {\n        \n        bool hit = SphereTrace(Ray(p + Epsilon * n, l), max_dist, ts, s, c, r);\n\n        // Si un obstacle est détecté\n        if (hit) {\n            // Calcul de la force de l'ombre en fonction de la distance parcourue\n            shadow = min(shadow, k * ts / t);\n        } else {\n            // Si aucun obstacle, arrêt de la boucle\n            break;\n        }\n\n        // Avancer en utilisant la distance calculée par SphereTrace\n        t += ts;\n\n        // Si la distance dépasse la limite maximale, on arrête\n        if (t > max_dist) {\n            break;\n        }\n    }\n\n    // Retourne l'intensité de l'ombre entre 0 (complète) et 1 (pas d'ombre)\n    return clamp(shadow, 0.0, 1.0);\n}\n\n// Shading and lighting\nvec3 Shade(vec3 p, vec3 n, Ray eye)\n{\n  // Point light\n  const vec3 lp = vec3(5., 10., 25.);\n  \n  // Light direction to point light\n  vec3 l = normalize(lp - p);\n  \n  // Ambient color\n  vec3 ambient = .25 + .25 * background(Ray(p, n));\n  \n  // Shadow computation\n  int ns = 100;\n  //float shadow = Occlusion(p,n,ns,1.0);\n  float shadow = SoftShadow(p, n, l, 90);\n  \n  // Phong diffuse\n  vec3 diffuse = .35 * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n  \n  // Specular\n  vec3 r = reflect(eye.d, n);\n  vec3 specular = .15 * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n  vec3 c = ambient + shadow * (diffuse + specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\nvec3 ShadeSteps(int n, int m)\n{\n  float t = float(n) / float(m);\n  return .5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);\n}\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy)\n{  \n  // Convert pixel coordinates\n  vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n\n  // Mouse\n  vec2 m = iMouse.xy / iResolution.xy;\n  \n  // Camera\n  Ray ray = CreateRay(m, pixel);\n  \n   // Trace ray\n  float t = 0.0;\n  int s = 0;\n  int c;\n  float r = 1.0;\n  bool hit = SphereTrace(ray, 100., t, s, c, r);\n  \n  // Shade background\n  vec3 rgb = background(ray);\n  \n  if (hit)\n  {\n    vec3 p = Point(ray, t);\n    vec3 n = ObjectNormal(p);\n    rgb = Shade(p, n, ray);\n  }\n  \n  \n  \n  //Volumes englobants------------------------------------------\n   \n  // Direct ray casting\n  Val directResult = DirectRayCast(ray, 100.0);\n  \n  // Bounded ray casting\n  Val boundedResult = BoundedRayCast(ray, 100.0);\n   \n  // Shade background\n  //vec3 rgb = background(ray);\n  \n  if (directResult.v > 0.0 || boundedResult.v > 0.0)\n    {\n        // Hit detected, shade based on performance difference\n        float performanceDiff = float(directResult.c - boundedResult.c) / float(max(directResult.c, boundedResult.c));\n        //Uncomment this line to see the comparaison\n        //rgb = vec3(0.5) + 0.5 * vec3(performanceDiff, -performanceDiff, 0.0);\n\n    }\n    else\n    {\n        // No hit, use background color\n        //rgb = background(ray);\n    }\n    \n    \n  \n  // Rouge indique que le lancer direct est plus coûteux.\n  // Vert indique que le lancer avec volume englobant est plus coûteux.\n  // Gris indique des performances similaires.\n\n  // Mat object ---------------------------\n  // Paramètres de rendu\n  float maxDist = 100.0;\n    \n  // Appeler la fonction Render\n  rgb = Render(ray, maxDist);\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  // rgb = ShadeSteps(s, Steps);\n  \n  // Uncomment this line to shade cost\n  // rgb = ShadeSteps(c, 500);\n  \n  color = vec4(rgb, 1.);\n}","name":"Image","description":"","type":"image"}]}