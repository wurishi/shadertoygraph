{"ver":"0.1","info":{"id":"McKcWh","date":"1731814959","viewed":40,"name":"Stylized Les Flare Star v1","username":"8InfinityTaco8","description":"a slight yet dynamic variant using noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","star","lensflare","lensflare","stylized"],"hasliked":0,"parentid":"lcKcWh","parentname":"Stylized Lens Flare Star v0"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Noise function\nfloat hash(float n) { \n    return fract(sin(n) * 43758.5453123); \n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i.x + i.y * 57.0);\n    float b = hash(i.x + 1.0 + i.y * 57.0);\n    float c = hash(i.x + (i.y + 1.0) * 57.0);\n    float d = hash(i.x + 1.0 + (i.y + 1.0) * 57.0);\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat getDynamicLength(vec2 uv, float time, float baseLength) {\n    float posNoise = noise2D(uv * 2.0 + time);\n    float timeNoise = noise(time * 2.0);\n    \n    // Reduced dynamic range for more controlled stretching\n    float dynamicFactor = mix(0.5, 2.5, posNoise * timeNoise);\n    \n    return baseLength * dynamicFactor;\n}\n\nvec3 calculateLensFlare(vec2 uv, float flickerIntensity) {\n    float flareIntensity = 0.0;\n    float eps = 0.001;\n    \n    // Adjusted base lengths - made diagonals shorter\n    float horizontalLength = 0.02;\n    float verticalLength = 0.02;\n    float diagonalLength = 0.005; // Reduced from 0.01\n    \n    // Get dynamic lengths with noise\n    float time = iTime;\n    vec2 stretchUV = uv * 2.0;\n    \n    // Calculate dynamic lengths for each direction\n    float dynHorizLength = getDynamicLength(stretchUV.yx, time * 0.7, horizontalLength);\n    float dynVertLength = getDynamicLength(stretchUV.xy, time * 0.8, verticalLength);\n    float dynDiagLength1 = getDynamicLength(stretchUV.xy + stretchUV.yx, time * 0.9, diagonalLength);\n    float dynDiagLength2 = getDynamicLength(stretchUV.xy - stretchUV.yx, time * 1.1, diagonalLength);\n    \n    // Add some pulsing to the lengths\n    float pulse = sin(time * 2.0) * 0.5 + 0.5;\n    dynHorizLength *= 1.0 + pulse * 0.5;\n    dynVertLength *= 1.0 + pulse * 0.5;\n    // Reduced pulse effect on diagonals\n    dynDiagLength1 *= 1.0 + pulse * 0.3;\n    dynDiagLength2 *= 1.0 + pulse * 0.3;\n    \n    // Create the flare with dynamic lengths\n    float horizontalFlare = dynHorizLength / (abs(uv.x) + eps);\n    horizontalFlare *= smoothstep(1.0, 0.0, abs(uv.y));\n    \n    float verticalFlare = dynVertLength / (abs(uv.y) + eps);\n    verticalFlare *= smoothstep(1.0, 0.0, abs(uv.x));\n    \n    // Added distance attenuation for diagonal flares\n    float diagAttenuation = smoothstep(1.5, 0.0, length(uv));\n    \n    float diagonalFlare1 = dynDiagLength1 / (abs(uv.x + uv.y) + eps);\n    diagonalFlare1 *= diagAttenuation;\n    \n    float diagonalFlare2 = dynDiagLength2 / (abs(uv.x - uv.y) + eps);\n    diagonalFlare2 *= diagAttenuation;\n    \n    // Add some noise to the flare intensity\n    float noisePattern = noise2D(uv * 3.0 + vec2(time * 0.5));\n    \n    // Combine flares with noise\n    flareIntensity = horizontalFlare + verticalFlare + diagonalFlare1 + diagonalFlare2;\n    flareIntensity *= mix(0.8, 1.2, noisePattern);\n    \n    // Enhanced distance fade with stronger falloff\n    float distanceFade = exp(-length(uv) * (2.0 + noisePattern));\n    flareIntensity *= distanceFade;\n    \n    // Apply flicker\n    flareIntensity *= flickerIntensity;\n    \n    // Dynamic color based on length\n    vec3 baseColor = vec3(1.0, 0.8, 0.6);\n    vec3 stretchColor = vec3(1.0, 0.9, 0.8);\n    vec3 flareColor = mix(baseColor, stretchColor, pulse);\n    \n    return flareColor * flareIntensity * 0.3;\n}\n\nfloat smoothFlicker(float t) {\n    return mix(\n        noise(t * 3.0),\n        noise(t * 6.0),\n        0.5\n    ) * 0.8 + 0.2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    float moveSpeed = 0.3;\n    float moveNoise = noise(iTime);\n    uv.x += sin(iTime * moveSpeed) * 0.5 * moveNoise;\n    uv.y += cos(iTime * moveSpeed * 0.7) * 0.3 * moveNoise;\n    \n    float flickerIntensity = smoothFlicker(iTime);\n    vec3 color = calculateLensFlare(uv, flickerIntensity);\n    \n    vec3 bgColor = vec3(0.1) + vec3(0.02) * noise2D(uv + iTime * 0.1);\n    color += bgColor;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}