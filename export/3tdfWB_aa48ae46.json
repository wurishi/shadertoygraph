{"ver":"0.1","info":{"id":"3tdfWB","date":"1613409521","viewed":125,"name":"Ludicrous Speed","username":"GaryCXJk","description":"They've gone plaid!\n\nThis is an attempted recreation of the Ludicrous Speed scene of Spaceballs. It's not perfect, but it does come close.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ludicrous Speed\n// Author: GaryCXJk\n#define PI 3.1415926538\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 getRatio() {\n    vec2 ratio = vec2(1.0, 1.0);\n    \n    if (iResolution.x < iResolution.y) {\n        ratio.y = iResolution.x / iResolution.y;\n    } else if (iResolution.y < iResolution.x) {\n        ratio.x = iResolution.y / iResolution.x;\n    }\n    return ratio;\n}\n\nvec4 centerGlow(vec2 uv, float glowSize, vec4 glowColor, vec4 glowColorShift) {\n    vec2 ratio = getRatio();\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec4 box = 0.5 + vec4(-ratio.x, -ratio.y, ratio.x, ratio.y) * glowSize;\n    \n    if (uv.x >= box.x && uv.x <= box.z && uv.y >= box.y && uv.y <= box.w) {\n        vec2 miniUV = uv;\n        miniUV-= box.xy;\n        miniUV/= ratio * 2.0 * glowSize;\n        float angle = atan(miniUV.y - 0.5, miniUV.x - 0.5);\n        vec2 pos = vec2(cos(angle), sin(angle));\n        float mag = distance(miniUV, vec2(0.5, 0.5));\n        mag += sin(angle * 3.0 + iTime * 24.0) * cos(angle * 5.0 - iTime * 26.0) * sin(angle * 4.0 + iTime * 48.0) * 0.02;\n        mag += sin(angle * 3.0 + 0.2 + iTime * 32.0) * cos(angle * 7.0 - iTime * 40.0) * sin(angle * 4.0 - iTime * 68.0) * 0.01;\n        mag += sin(angle * 7.0 + 0.3 + iTime * 20.0) * cos(angle * 2.0 - iTime * 24.0) * sin(angle * 4.0 + iTime * 88.0) * 0.03;\n        float dist = 2.0 * (0.5 - mag);\n        dist = smoothstep(0.1, 1.14, dist) * 2.0;\n        col.xyz = vec3(dist);\n        float colorRatio = (1.0 - clamp(dist, 0.0, 1.0));\n        vec4 realColor = glowColor * (1.0 - colorRatio) + glowColorShift * colorRatio;\n        col*= realColor;\n    }\n    \n    return col;\n}\n\nvec4 plaid(vec2 uv, float yPos, float tunnelOffset) {\n    vec4 plaidCol = vec4(0.0);\n    float brightness = 1.2 - yPos * 0.6;\n    \n    if ((uv.x > 0.025 && uv.x < 0.1) || (uv.x > 0.9 && uv.x < 0.975)) {\n        return vec4(1.0, 0.6, 0.0, 1.0) * 0.9 * brightness;\n    } else {\n        float darkMultiplier = 1.0;\n        if (yPos > tunnelOffset) {\n            if ((uv.y > 0.025 && uv.y < 0.1) || (uv.y > 0.9 && uv.y < 0.975)) {\n                plaidCol+= vec4(1.0, 0.6, 0.0, 1.0) * 0.7;\n            }\n            if ((uv.y > 0.65 && uv.y < 0.725) || (uv.y > 0.775 && uv.y < 0.85)) {\n                plaidCol+= vec4(0.8, 0.0, 0.0, 1.0) * 0.3;\n            }\n            brightness = 1.6 - yPos * 1.2;\n        } else {\n            darkMultiplier = 0.65;\n            brightness = 1.0;\n        }\n        if ((uv.x > 0.15 && uv.x < 0.225) || (uv.x > 0.275 && uv.x < 0.35)) {\n            plaidCol+= vec4(0.8, 0.0, 0.0, 1.0) * 0.5;\n        }\n        if ((uv.x > 0.525 && uv.x < 0.6) || (uv.x > 0.775 && uv.x < 0.85)) {\n            plaidCol+= vec4(0.0, 0.0, 0.8, 1.0) * 0.5 * darkMultiplier;\n        }\n        if ((uv.x > 0.4 && uv.x < 0.475) || (uv.x > 0.65 && uv.x < 0.725)) {\n            plaidCol+= vec4(0.2, 0.2, 0.2, 1.0) * 0.5 * darkMultiplier;\n        }\n    }\n    \n    return plaidCol * brightness;\n}\n\nvec4 wall(vec2 uv, float angle, float tunnelOffset) {\n    // For now horizon isn't used.\n    // float horizon = max(iResolution.x, iResolution.y);\n    \n    // Initialize the ratio, as well as the ratio adjusted UV.\n    vec2 ratio = getRatio();\n    vec2 newUV = -(uv - 0.5) / ratio;\n    \n    // We'll calculate the distance from origin, as well as the angle relative to origin.\n    float dist = distance(newUV, vec2(0.0, 0.0));\n    float cAngle = atan(newUV.y, newUV.x);\n    \n    // Convert the angle in degrees to radians.\n    float rad = angle / 180.0 * PI;\n    \n    // Now we'll rotate the UV accordingly.\n    newUV.x = dist * cos(cAngle + rad);\n    newUV.y = dist * sin(cAngle + rad);\n    \n    float yPos = newUV.y;\n    \n    // Originally we defined the horizon, from which we'd calculate the Z.\n    // float z = newUV.y * horizon;\n    float scale = 0.0;\n    if (newUV.y > 0.0) {\n        scale = 1.0 / newUV.y;\n    }\n    \n    if (newUV.x < -newUV.y) {\n        return vec4(0.0);\n    }\n    \n    if (newUV.x > newUV.y) {\n        return vec4(0.0);\n    }\n    \n    float invScale = 0.0;\n    if (newUV.y < 1.0) {\n        invScale = 1.0 / (1.0 - newUV.y);\n    }\n    \n    newUV.x*= 1.3;\n    \n    newUV.x = mod(newUV.x * scale + 0.3, 1.0);\n    newUV.y = mod(newUV.y + iTime + scale * 4.0, 1.0);\n    \n    return plaid(newUV, yPos, tunnelOffset);\n}\n\nvec4 plaidSquare(vec2 uv, float tunnelOffset, float tunnelSpawnSize) {\n    vec2 ratio = getRatio();\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec4 box = 0.5 + vec4(-ratio.x, -ratio.y, ratio.x, ratio.y) * tunnelOffset;\n    \n    float tunnelSpawnOffset = 1.0 - tunnelSpawnSize;\n    \n    if (uv.x >= box.x && uv.x <= box.z && uv.y >= box.y && uv.y <= box.w) {\n        vec2 miniUV = uv;\n        miniUV-= box.xy;\n        miniUV/= ratio * 2.0 * tunnelOffset;\n        \n        vec2 boxUV = abs((miniUV.xy * 2.0) - 1.0);\n        \n        float maxDist = max(boxUV.x, boxUV.y);\n        \n        float distVal = clamp((maxDist - tunnelSpawnOffset) / tunnelSpawnSize, 0.0, 1.0);\n        distVal = 1.0 - mod(distVal - iTime, 1.0);\n        \n        if (maxDist < tunnelSpawnOffset) {\n          distVal = 0.0;\n        }\n        \n        if ((distVal > 0.0 && distVal < 0.015) || (distVal > 0.02 && distVal < 0.035)) {\n            col = vec4(0.8, 0.0, 0.0, 1.0) * 0.3;\n        }\n        if ((distVal > 0.04 && distVal < 0.055) || (distVal > 0.06 && distVal < 0.075)) {\n            col = vec4(1.0, 0.6, 0.0, 1.0) * 0.7;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iGlowSize = 0.12;\n    vec4 iGlowColor = vec4(1.0, 0.9, 0.5, 1.0);\n    vec4 iGlowColorShift = vec4(1.0, 0.1, 0.0, 1.0);\n    float iTunnelOffset = 0.15;\n    float iTunnelSpawnSize = 0.375;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 glowCol = centerGlow(uv, iGlowSize, iGlowColor, iGlowColorShift);\n    vec4 wallCol = wall(uv, 0.0, iTunnelOffset) + wall(uv, 90.0, iTunnelOffset) + wall(uv, 180.0, iTunnelOffset) + wall(uv, 270.0, iTunnelOffset);\n\n    // Output to screen\n    // fragColor = glowCol;\n    fragColor = glowCol + wallCol + plaidSquare(uv, iTunnelOffset, iTunnelSpawnSize);\n}","name":"Image","description":"","type":"image"}]}