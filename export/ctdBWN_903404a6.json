{"ver":"0.1","info":{"id":"ctdBWN","date":"1702152726","viewed":31,"name":"Mickey au coin du feu","username":"ncTN","description":"Mickey au coin du feu","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["mickeypaisible"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Structures de base (non formes)\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vec3(0,0,1),C.View));\n    C.Up = normalize(cross(C.View,C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = (C.H / 2.0) / tan(radians(aperture/2.0));\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray R;\n   R.Origin = C.Obs;\n   vec3 p = C.Obs + C.z * C.View + (XY.x - C.W / 2.0) * C.Horiz + (XY.y - C.H / 2.0) * C.Up;\n   R.Dir = p - C.Obs;\n   return R;\n}\n\n// Formes : struct + intersect\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n   vec3 Color;\n   bool illuminate;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n     float a = dot(R.Dir, R.Dir);\n     float b = 2.0*dot(R.Dir, (R.Origin - S.Center));\n     float c = dot(R.Origin - S.Center, R.Origin - S.Center) - pow(S.R, 2.0);\n     \n     float delta = pow(b, 2.0) - 4.0 * a * c;\n     if (delta < 0.0) {\n         t = -1.0;\n         return false;\n     } \n     \n     if (delta == 0.0) {\n         t = -b / (2.0 * a);\n     }\n     t = (-b - sqrt(delta)) / (2.0 * a) ;\n     return true;\n     \n}\n\nfloat calcCos( vec3 p, vec3 c, vec3 l) {\n\n    vec3 n = normalize(p - c);\n    vec3 d = normalize(l - p);\n                    \n    float cosT = dot(n,d);\n    if (cosT<0.0){\n        cosT = 0.0;\n    }\n    \n    return cosT;\n\n}\n\n\nstruct Plan {\n    vec3 Origin;\n    vec3 v1;\n    vec3 v2;\n    vec3 Color;\n};\n\nbool intersect_plan(in Ray R, in Plan P, out float t){\n    \n    mat3 X = mat3(R.Dir, -P.v1, -P.v2);\n    vec3 v0 = P.Origin - R.Origin;\n    \n    if (dot(cross(P.v1,P.v2),R.Dir) == 0.0){\n        return false;\n    }\n    \n    vec3 C = inverse(X)*v0;\n    \n    t = C.x;\n    \n    return true;\n\n}\n\nfloat calcCosPlan( vec3 Point, Plan plan, vec3 Lumiere, Camera c) {\n\n    vec3 n = normalize(cross(plan.v2, plan.v1));\n    \n    Plan CameraPlan = Plan(c.Obs, plan.v1, plan.v2, vec3(.0, .0, .0));\n    \n    float t;\n    Ray r = Ray(Point, n);\n    if (intersect_plan(r, CameraPlan, t)){\n        if (t < 0.){\n            n = -n;\n        }\n    }\n    \n    \n    vec3 d = normalize(Lumiere - Point);\n                    \n    float cosT = dot(n,d);\n    if (cosT<0.0){\n        cosT = 0.0;\n    }\n    \n    return cosT;\n\n}\n\n\nstruct PlanFin {\n    vec3 Origin;\n    vec3 v1;\n    vec3 v2;\n    float u1;\n    float u2;\n    vec3 Color;\n};\n\nbool intersect_planfin(in Ray R, in PlanFin P, out float t){\n    \n    mat3 X = mat3(R.Dir, -P.v1, -P.v2);\n    vec3 v0 = P.Origin - R.Origin;\n    \n    if (dot(cross(P.v1,P.v2),R.Dir) == 0.0){\n        return false;\n    }\n    \n    vec3 C = inverse(X)*v0;\n    \n    t = C.x;\n    \n    if (abs(C.y) > P.u1 || abs(C.z) > P.u2) {\n        return false;\n    }\n    \n    return true;\n\n}\n\nfloat calcCosPlanFin( vec3 Point, PlanFin plan, vec3 Lumiere, Camera c) {\n\n    vec3 n = normalize(cross(plan.v2, plan.v1));\n    \n    Plan CameraPlan = Plan(c.Obs, plan.v1, plan.v2, vec3(.0, .0, .0));\n    \n    float t;\n    Ray r = Ray(Point, n);\n    if (intersect_plan(r, CameraPlan, t)){\n        if (t < 0.){\n            n = -n;\n        }\n    }\n    \n    \n    vec3 d = normalize(Lumiere - Point);\n                    \n    float cosT = dot(n,d);\n    if (cosT<0.0){\n        cosT = 0.0;\n    }\n\n    return cosT;\n\n}\n\n\nstruct Cylindre {\n    vec3 Origin;\n    vec3 Dir;\n    float R;\n    float H;\n    vec3 Color;\n};\n\nbool intersect_cyl(in Ray R, in Cylindre C, out float t){\n     \n     vec3 y = R.Origin - C.Origin - (dot((R.Origin - C.Origin),C.Dir)*C.Dir);\n     vec3 x = R.Dir - dot(C.Dir,R.Dir) * C.Dir;\n     \n     float a = dot(x, x);\n     float b = 2.0*dot(x, y);\n     float c = dot(y, y) - pow(C.R, 2.0);\n     \n     float delta = pow(b, 2.0) - 4.0 * a * c;\n     if (delta < 0.0) {\n         t = -1.0;\n         return false;\n     } \n     \n     t = (-b - sqrt(delta)) / (2.0 * a) ;\n     \n     \n     \n     vec3 M = R.Origin + t * R.Dir;\n     \n     float l = dot(C.Dir, (M-C.Origin));\n     \n     if (-C.H/2.0 < l && l < C.H/2.0){\n         return true;\n     }\n     \n     t = (-b + sqrt(delta)) / (2.0 * a) ;\n     \n     M = R.Origin + t * R.Dir;\n     \n     l = dot(C.Dir, (M-C.Origin));\n     \n     if (-C.H/2.0 < l && l < C.H/2.0){\n         return true;\n     }\n     \n     return false;\n\n}\n\nfloat calcCosCyl( Ray R ,vec3 Point, Cylindre Cyl, vec3 Lumiere, Camera c) {\n\n    float l = dot(Cyl.Dir, (Point-Cyl.Origin));\n    vec3 n = normalize(Point - (Cyl.Origin + l*Cyl.Dir));\n    \n    if (dot(n,R.Dir)>0.){\n        n = -n;\n    }\n\n    vec3 d = normalize(Lumiere - Point);\n\n    float cosT = dot(n,d);\n    if (cosT < 0.0) {\n        cosT = 0.0;\n    }\n    \n    return cosT;\n\n}\n\n\nstruct Cone {\n    vec3 Origin; // Centre du chapeau\n    vec3 Dir; // Direction de la hauteur\n    float Theta; // Tangente de l'angle du cône\n    float Height;\n    vec3 Color;\n    bool illuminate;\n};\n\nbool intersect_cone(Ray R, Cone C, out float t) {\n    // Translation de l'origine du rayon et du cône pour le placer à l'origine\n    vec3 O = R.Origin - C.Origin;\n    float TanTheta = tan(C.Theta);\n\n    // Calcul de la tangente de l'angle du cône\n    float tan2 = TanTheta * TanTheta;\n\n    // Calcul des coefficients de l'équation quadratique\n    float a = dot(R.Dir - (dot(R.Dir, C.Dir) * C.Dir), R.Dir - (dot(R.Dir, C.Dir) * C.Dir)) - tan2 * dot(R.Dir, C.Dir) * dot(R.Dir, C.Dir);\n    float b = 2.0 * dot(R.Dir - (dot(R.Dir, C.Dir) * C.Dir), O - (dot(O, C.Dir) * C.Dir)) - 2.0 * tan2 * dot(R.Dir, C.Dir) * dot(O, C.Dir);\n    float c = dot(O - (dot(O, C.Dir) * C.Dir), O - (dot(O, C.Dir) * C.Dir)) - tan2 * dot(O, C.Dir) * dot(O, C.Dir);\n\n    // Résoudre l'équation quadratique\n    float discriminant = b * b - 4. * a * c;\n\n    if (discriminant < 0.) {\n        t = -1.0;\n        return false;\n    }\n\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n    // Vérifier si le point d'intersection est à l'intérieur de la hauteur du cône\n    vec3 intersection = R.Origin + t1 * R.Dir;\n    float intersection_height = dot(intersection - C.Origin, C.Dir);\n    \n    if (t1 >= 0. && intersection_height > 0. && intersection_height < C.Height ) {\n        t = t1;\n        return true;\n    }\n        \n    intersection = R.Origin + t2 * R.Dir;\n    intersection_height = dot(intersection - C.Origin, C.Dir);\n    if (t2 >= 0. && intersection_height > 0. && intersection_height < C.Height ) {\n        t = t2;\n        return true;\n    }\n        \n    t = -1.0;\n    return false;\n\n}\n\n\nfloat calcCosCone(Ray R, vec3 Point, Cone cone, vec3 Lumiere, Camera c) {\n\n    // Calcul de la distance entre le point et la pointe du cône projetée sur son axe\n    float l = dot(cone.Dir, (Point - cone.Origin));\n\n    // Calcul du vecteur depuis la pointe du cône jusqu'au point\n    vec3 v = normalize(Point - (cone.Origin + l * cone.Dir));\n\n    // Calcul de la normale du cône en fonction de son angle d'ouverture\n    vec3 n = normalize(cos(cone.Theta) * v - sin(cone.Theta) * normalize(cone.Dir));\n\n    // Inversion de la normale si elle est dirigée vers l'opposé du rayon incident\n    if (dot(n, -R.Dir) < 0.) {\n        n = -n;\n    }\n\n    // Calcul de la direction de la lumière incidente normalisée\n    vec3 d = normalize(Lumiere - Point);\n\n    // Calcul du cosinus de l'angle entre la normale et la direction de la lumière\n    float cosT = dot(n, d);\n\n    // Si le cosinus est négatif (angle > 90 degrés), le mettre à zéro\n    if (cosT < 0.0) {\n        cosT = 0.0;\n    }\n\n    // Retourner la valeur du cosinus calculé\n    return cosT;\n}\n\n\n\n\n\n//Création des différentes formes dans des tableaux\n\n//Nombre de sphères\n#define MAX_SPHERES 32\n\n//Debut des indice des elements à la lumière vive mais qui ne produisent pas de lumières (braises au dessus du feu par exemple)\n#define DEB_UNLUM 17\n\n//Debut des indices des sphères faisant de la lumière\n#define DEB_LUM 29\n\nSphere[MAX_SPHERES] createSpheres() {\n    Sphere spheres[MAX_SPHERES];\n    \n    //Tete de mickey\n    spheres[0] = Sphere(vec3(0.,3.3,3.), 1., vec3(0., 0., 0.),false);\n    spheres[1] = Sphere(vec3(0. + cos(iTime/2.0 + 1.55),3.3 + sin(iTime/2.0 + 1.55),3.9), 0.65, vec3(1.0, 0.0, 0.0),false);\n    spheres[2] = Sphere(vec3(0. + cos(iTime/2.0 - 1.55),3.3 + sin(iTime/2.0 - 1.55),3.9), 0.65, vec3(.0, 1.0, 0.0),false);\n    \n    //Cailloux autour du feu\n    for (int i = 0; i < 10; i++) {\n        spheres[3+i] = Sphere(vec3(0. + cos(float(i)/5. * 3.14 -3.14), 0. + sin(float(i)/5. * 3.14 - 3.14 ), 0.), 0.2, vec3(0.8, 0.8, 0.8),false);\n    }\n    \n    //Pieds de mickey\n    spheres[14] = Sphere(vec3(-1.1, 1.6, .7), .3, vec3(1.0,1.0,.1),false);\n    spheres[15] = Sphere(vec3(1.1, 1.6, .7), .3, vec3(1.0,1.0,.1),false);\n    \n    //Cou de mickey\n    spheres[16] = Sphere(vec3(0.0, 3.37, 1.9), .6, vec3(.0,.0,.0),false);\n    \n    int j = 17;\n    \n    //Braises au dessus du feu\n    int nbRonds = 2;\n    for (int k = 1; k < nbRonds + 1; k++) {\n        for (int l = 0; l < (k * 2); l++) {\n            spheres[j] = Sphere(vec3(0. + 0.7 * float(k) / float(nbRonds) *  cos(float(l)/float(k) * 3.14 -3.14),0. + 0.7 * float(k) / float(nbRonds) * sin(float(l)/float(k) * 3.14 -3.14), 2.1 + mod( 1.5 * iTime + float( k * l ), 10.0)), 0.04, vec3(0.8, 0.8, 0.2),true);\n            j = j + 1;\n        }\n    }\n    \n    //Yeux de mickey\n    spheres[27] = Sphere(vec3(0. + 0.95 * cos(iTime/2.0 - 0.3),3.3 + 0.95 *  sin(iTime/2.0 - 0.3),3.3), 0.1, vec3(1.0, .0, 0.0),true);\n    spheres[28] = Sphere(vec3(0. + 0.95 * cos(iTime/2.0 + 0.3),3.3 + 0.95 *  sin(iTime/2.0 + 0.3),3.3), 0.1, vec3(1.0, .0, 0.0),true);\n\n\n    //Lumière au dessus du feu de camps\n    spheres[29]= Sphere(vec3(0., 0., 2.2), 0.001, vec3(0.8, 0.8, 0.1),false);\n    \n    //Lune\n    spheres[30]= Sphere(vec3(10., -15., 10.0), .7, vec3(0.3, 0.3, 0.3),false);    \n    \n    \n    return spheres;\n}\n\n#define MAX_PLANS 1\n\nPlan[MAX_PLANS] createPlans() {\n    Plan plans[MAX_PLANS];\n    //Sol\n    plans[0] = Plan(vec3(0.0,-50.0, .0),vec3(0.0,-1.0,0.0),vec3(1.0,0.0,0.0),vec3(.25,0.5,0.05));\n\n    return plans;\n}\n\n#define MAX_PLANS_FIN 8\n\nPlanFin[MAX_PLANS_FIN] createPlansFin() {\n    PlanFin plans[MAX_PLANS_FIN];\n    \n    //Une rangée de flames\n    plans[0] = PlanFin(vec3(.0,.00001,.0),vec3(0.25,0.,1.),vec3(-0.25,0.,1.), 1.0, 1.0, vec3(1.0,.0,.0));    \n    plans[1] = PlanFin(vec3(.0,-.00001,.0),vec3(0.25,0.,1.),vec3(-0.25,0.,1.), 1.0, 1.0, vec3(1.0,.0,.0));\n    plans[2] = PlanFin(vec3(.0,.0,.0),vec3(0.1,0.0,.7),vec3(0.5,0.,.7), 1.0, 1.0, vec3(1.0,.0,.0));    \n    plans[3] = PlanFin(vec3(.0,.0,.0),vec3(-0.1,0.0,.7),vec3(-0.5,0.,.7), 1.0, 1.0, vec3(1.0,.0,.0));\n    \n    //Une autre rangée de flames\n    plans[4] = PlanFin(vec3(.00001, 0., .0),vec3(0., 0.25,1.),vec3(0.,-0.25,1.), 1.0, 1.0, vec3(1.0,.0,.0));    \n    plans[5] = PlanFin(vec3(-.00001, 0., .0),vec3(0., 0.25,1.),vec3(0.,-0.25,1.), 1.0, 1.0, vec3(1.0,.0,.0));\n    plans[6] = PlanFin(vec3(.0,.0,.0),vec3(0., 0.1,.7),vec3(0.,0.5,.7), 1.0, 1.0, vec3(1.0,.0,.0));    \n    plans[7] = PlanFin(vec3(.0,.0,.0),vec3(0.,-0.1,.7),vec3(0., -0.5,.7), 1.0, 1.0, vec3(1.0,.0,.0));\n/*\n    plans[7] = PlanFin(vec3(.0,.0001,.0),vec3(0.15,0.,.5),vec3(-0.15,0.,.5), 1.0, 1.0, vec3(1.0,1.0,.1));\n    plans[8] = PlanFin(vec3(.0,-.0001,.0),vec3(0.15,0.,.5),vec3(-0.15,0.,.5), 1.0, 1.0, vec3(1.0,1.0,.1));\n    \n    plans[9] = PlanFin(vec3(.0001,.0,.0),vec3(0.,0.15,.5),vec3(0., -0.15,.5), 1.0, 1.0, vec3(1.0,1.0,.1));\n    plans[10] = PlanFin(vec3(-.0001,.0, .0),vec3(0.,0.15,.5),vec3(0., -0.15,.5), 1.0, 1.0, vec3(1.0,1.0,.1));  \n*/\n\n    //plans[1] = PlanFin(vec3(0.1, 0.0, 0.5),vec3(0.0,-1.0,1.0),vec3(0.0,0.0,1.0), 1.0, 1.0, vec3(1.0,0.0,1.0));\n\n    return plans;\n}\n\n#define MAX_CYL 8\n\nCylindre[MAX_CYL] createCyl() {\n    Cylindre cyl[MAX_CYL];\n    \n    //Bois dans le feu\n    cyl[0] = Cylindre(vec3(.0,.0,.1),normalize(vec3(1.,.0,.0)), 0.1, 1.5, vec3(.5,.2,.2));\n    cyl[1] = Cylindre(vec3(.0,.0,.1),normalize(vec3(.0,1.0,.0)), 0.1, 1.5, vec3(.5,.2,.2));\n    \n    //Jambes de mickey\n    cyl[2] = Cylindre(vec3(-0.7,2.5,.2),normalize(vec3(.4,1.,.0)), 0.2, 1.5, vec3(.0,.0,.0));\n    cyl[3] = Cylindre(vec3(0.7,2.5,.2),normalize(vec3(-.4,1.0,.0)), 0.2, 1.5, vec3(0.,.0,.0));\n    \n    //Corps de mickey\n    cyl[4] = Cylindre(vec3(0.,3.5,0.6),normalize(vec3(0.,-0.1,1.)), 0.6, 1.2, vec3(1.,0.,0.));    \n    cyl[5] = Cylindre(vec3(0.,3.4,1.6),normalize(vec3(0.,-0.1,1.)), 0.6, 0.81, vec3(.0,.0,0.));\n    \n    //Peids de mickey\n    cyl[6] = Cylindre(vec3(-1.1, 1.6, .35),normalize(vec3(0.,0.,1.)), 0.3, 0.7, vec3(1.,1.,0.1));\n    cyl[7] = Cylindre(vec3(1.1, 1.6, .35),normalize(vec3(0.,0.,1.)), 0.3, 0.7, vec3(1.,1.,0.1));\n\n\n\n\n\n    return cyl;\n}\n\n\n#define MAX_CONE 2\n\nCone[MAX_CONE] createCone() {\n    Cone cone[MAX_CONE];\n    \n    //Flamme jaune du feu de camps\n    cone[0] = Cone(vec3(0.,0.,1.),normalize(vec3(0.,0.,-1.)), radians(15.), 1., vec3(1.0,1.0,.1), true);\n\n    return cone;\n}\n\n\n//Main prog\n\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n   //Caméra qui bouge\n   Camera C = camera(\n       vec3(10. * cos(iTime/2.), 10. * sin(iTime/2.) , 5),\n       vec3(0., 0., 4.),\n       50.0       \n   );\n   /*\n   //Caméra qui bouge pas\n   C = camera(\n       vec3(-10., -10., 5),\n       vec3(0., 0., 4.),\n       50.0       \n   );*/\n   \n   \n   Ray R = launch(C, fragCoord);\n   \n   //Création de toutes les formes\n   Sphere spheres[MAX_SPHERES] = createSpheres();   \n   Plan plans[MAX_PLANS] = createPlans();   \n   PlanFin plansFin[MAX_PLANS_FIN] = createPlansFin();\n   Cylindre cyls[MAX_CYL] = createCyl();\n   Cone cones[MAX_CONE] = createCone();\n   vec3 textureColor = vec3(0.0);\n   \n    // Déclarer un tableau 1D pour mettre en cache les échantillons de texture\n    vec3 textureSamples[64];\n\n    // Précalculer les échantillons de texture avant la boucle\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            // Convertir les coordonnées à l'échelle du tableau\n            float u = float(i) / 7.0;\n            float v = float(j) / 7.0;\n\n            // Utiliser la texture du canal iChannel0 pour les échantillons\n            int index = i * 8 + j;\n            textureSamples[index] = texture(iChannel0, vec2(u, v)).xyz;\n        }\n    }\n       \n\n    vec3 col = vec3(0, 0, 0);\n    float t;\n    float minT = 1000000.0; // Une valeur initiale très grande\n    \n    /*\n    Spheres\n    */\n    for (int i = 0; i < MAX_SPHERES; i++) {\n        if (intersect_sphere(R, spheres[i], t)) {\n            if (t > 0. && t < minT) {\n                minT = t;\n\n                //Si ce n'est pas une sphere lumineuse\n                if (i < DEB_UNLUM) {\n                     //Reset de la couleur\n                     col = vec3(0, 0, 0);\n                     //Gestion des ombres, boucle sur les spheres lumineuses\n                     for (int j = DEB_LUM; j < MAX_SPHERES; j++){\n                        vec3 p = C.Obs + t*R.Dir;\n                        Ray R2 = Ray(p,spheres[j].Center - p);\n                        float t2;\n                        int ombre = 1;\n                        \n\n                        //Spheres\n                        for (int k = 0; k < MAX_SPHERES ; k++) {\n                            if (k!= j && !(spheres[k].illuminate) && intersect_sphere(R2, spheres[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n/*\n                        //Plan\n                        for (int k = 0; k < MAX_PLANS; i++) {\n                            if (intersect_plan(R2, plans[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n\n                        //Plan fini\n                        for (int k = 0; k < MAX_PLANS_FIN; i++) {\n                            if (intersect_planfin(R2, plansFin[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }*/\n\n                        //Cylindre\n                        for (int k = 0; k < MAX_CYL; k++) {\n                            if (intersect_cyl(R2, cyls[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n\n                        //Cone\n                        for (int k = 0; k < MAX_CONE; k++) {\n                            if (intersect_cone(R2, cones[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n\n                        //Prise en compte des ombres\n                        if (ombre == 1 && i != 1){\n                           col += \n                             spheres[i].Color *\n                             spheres[j].Color *\n                             calcCos(p, spheres[i].Center, spheres[j].Center);\n\n                        }\n                        else {\n                            if (ombre == 1 ){\n                                vec3 sphereToHitPoint = p - spheres[i].Center;\n\n                                // Facteur de ralentissement de la vitesse de rotation\n                                float rotationSpeed = 0.125; // Ajustez la valeur selon votre préférence\n\n                                // Calculer l'angle de rotation en fonction du temps\n                                float rotationAngle = -mod(iTime * rotationSpeed, 2.0) / 2.0 * 3.1415 * 2.0;\n\n                                // Appliquer la rotation autour de l'axe Z pour suivre la rotation de la tête de mickey\n                                float x = sphereToHitPoint.x * cos(rotationAngle) - sphereToHitPoint.y * sin(rotationAngle);\n                                float y = sphereToHitPoint.x * sin(rotationAngle) + sphereToHitPoint.y * cos(rotationAngle);\n                                float z = sphereToHitPoint.z;\n\n                                float u = 0.5 + atan(z, x) / (2.0 * 3.1415);\n                                float v = 0.5 - asin(y / spheres[i].R) / 3.1415;\n\n                                // Convertir les coordonnées de texture à l'échelle du tableau\n                                int texX = int(u * 8.0);\n                                int texY = int(v * 8.0);\n\n                                // Utiliser la couleur du tableau\n                                int index = texY * 8 + texX;\n                                vec3 textureColor = textureSamples[index];\n\n                                // Utiliser la couleur de la texture\n                                col = textureColor *\n                                     spheres[j].Color *\n                                     calcCos(p, spheres[i].Center, spheres[j].Center);\n\n                            }\n\n                        }\n                     }\n                }\n                //Si elle est lumineuse\n                else{\n                    col = spheres[i].Color;\n                }\n            }\n        }\n    }\n   \n    //\n    //Plans\n    //\n    for (int i = 0; i < MAX_PLANS; i++) {\n        if (intersect_plan(R, plans[i], t)) {\n            if (t > 0. && t < minT) {\n                minT = t;\n\n                 //Reset de la couleur\n                 col = vec3(0, 0, 0);\n                 //Gestion des ombres, boucle sur les spheres lumineuses\n                 for (int j = DEB_LUM; j < MAX_SPHERES; j++){\n                    vec3 p = C.Obs + t*R.Dir;\n                    Ray R2 = Ray(p,spheres[j].Center - p);\n                    float t2;\n                    int ombre = 1;\n\n                    //Spheres\n                    for (int k = 0; k < MAX_SPHERES ; k++) {\n                        if (k!= j && (k < DEB_UNLUM || k >= DEB_LUM ) && intersect_sphere(R2, spheres[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n/*\n                    //Plan\n                    for (int k = 0; k < MAX_PLANS; i++) {\n                        if (intersect_plan(R2, plans[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Plan fini\n                    for (int k = 0; k < MAX_PLANS_FIN; i++) {\n                        if (intersect_planfin(R2, plansFin[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }*/\n\n                    //Cylindre\n                    for (int k = 0; k < MAX_CYL; k++) {\n                        if (intersect_cyl(R2, cyls[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Cone\n                    for (int k = 0; k < MAX_CONE; k++) {\n                        if (intersect_cone(R2, cones[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Prise en compte des ombres\n                    if (ombre == 1){\n                       col += \n                         plans[i].Color *\n                         spheres[j].Color *\n                         calcCosPlan(p, plans[i], spheres[j].Center, C);\n                    }\n                }\n            }\n        }\n    }\n    \n    //\n    //Plans Finis\n    //\n    for (int i = 0; i < MAX_PLANS_FIN; i++) {\n        if (intersect_planfin(R, plansFin[i], t)) {\n            if (t > 0. && t < minT) {\n                minT = t;\n\n                 //Reset de la couleur\n                 col = vec3(0, 0, 0);\n                 //Gestion des ombres, boucle sur les spheres lumineuses\n                 for (int j = DEB_LUM; j < MAX_SPHERES; j++){\n                    vec3 p = C.Obs + t*R.Dir;\n                    Ray R2 = Ray(p,spheres[j].Center - p);\n                    float t2;\n                    int ombre = 1;\n\n                    //Spheres\n                    for (int k = 0; k < MAX_SPHERES ; k++) {\n                        if (k!= j && (k < DEB_UNLUM || k >= DEB_LUM ) && intersect_sphere(R2, spheres[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n/*\n                    //Plan\n                    for (int k = 0; k < MAX_PLANS; i++) {\n                        if (intersect_plan(R2, plans[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Plan fini\n                    for (int k = 0; k < MAX_PLANS_FIN; i++) {\n                        if (intersect_planfin(R2, plansFin[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }*/\n\n                    //Cylindre\n                    for (int k = 0; k < MAX_CYL; k++) {\n                        if (intersect_cyl(R2, cyls[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Cone\n                    for (int k = 0; k < MAX_CONE; k++) {\n                        if (intersect_cone(R2, cones[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Prise en compte des ombres\n                    if (ombre == 1){\n                       col += plansFin[i].Color ;\n                    }\n                }\n            }\n        }\n    }\n    \n    //\n    //Cylindres\n    //\n    for (int i = 0; i < MAX_CYL; i++) {\n       if (intersect_cyl(R, cyls[i] , t)) {\n            if (t > 0. && t < minT) {\n                minT = t;\n\n                 //Reset de la couleur\n                 col = vec3(0, 0, 0);\n                 //Gestion des ombres, boucle sur les spheres lumineuses\n                 for (int j = DEB_LUM; j < MAX_SPHERES; j++){\n                    vec3 p = C.Obs + t*R.Dir;\n                    Ray R2 = Ray(p,spheres[j].Center - p);\n                    float t2;\n                    int ombre = 1;\n\n                    //Spheres\n                    for (int k = 0; k < MAX_SPHERES ; k++) {\n                        if (k!= j && (k < DEB_UNLUM || k >= DEB_LUM ) && intersect_sphere(R2, spheres[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n/*\n                    //Plan\n                    for (int k = 0; k < MAX_PLANS; i++) {\n                        if (intersect_plan(R2, plans[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Plan fini\n                    for (int k = 0; k < MAX_PLANS_FIN; i++) {\n                        if (intersect_planfin(R2, plansFin[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }*/\n\n                    //Cylindre\n                    for (int k = 0; k < MAX_CYL; k++) {\n                        if (intersect_cyl(R2, cyls[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Cone\n                    for (int k = 0; k < MAX_CONE; k++) {\n                        if (intersect_cone(R2, cones[k], t2)){\n                            if (t2 > 0.0001 && t2 < 1.0){\n                                ombre = 0;\n                                break;\n                            }\n                        }\n                    }\n\n                    //Prise en compte des ombres\n                    if (ombre == 1){\n                       col += \n                           cyls[i].Color * \n                           spheres[j].Color * \n                           calcCosCyl(R ,p, cyls[i], spheres[j].Center, C);\n                    }\n                }\n            }\n        }\n    }\n    \n    //\n    //Cones\n    //\n    for (int i = 0; i < MAX_CONE; i++) {\n       if (intersect_cone(R, cones[i] , t)) {\n            if (t > 0. && t < minT) {\n                minT = t;\n                if (cones[i].illuminate){\n                       col = cones[i].Color;  \n                     }\n                else{\n\n                     //Reset de la couleur\n                     col = vec3(0, 0, 0);\n                     //Gestion des ombres, boucle sur les spheres lumineuses\n                     for (int j = DEB_LUM; j < MAX_SPHERES; j++){\n                        vec3 p = C.Obs + t*R.Dir;\n                        Ray R2 = Ray(p,spheres[j].Center - p);\n                        float t2;\n                        int ombre = 1;\n\n                        //Spheres\n                        for (int k = 0; k < MAX_SPHERES ; k++) {\n                            if (k!= j && (k < DEB_UNLUM || k >= DEB_LUM ) && intersect_sphere(R2, spheres[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n    /*\n                        //Plan\n                        for (int k = 0; k < MAX_PLANS; i++) {\n                            if (intersect_plan(R2, plans[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n\n                        //Plan fini\n                        for (int k = 0; k < MAX_PLANS_FIN; i++) {\n                            if (intersect_planfin(R2, plansFin[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }*/\n\n                        //Cylindre\n                        for (int k = 0; k < MAX_CYL; k++) {\n                            if (intersect_cyl(R2, cyls[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n\n                        //Cone\n                        for (int k = 0; k < MAX_CONE; k++) {\n                            if (intersect_cone(R2, cones[k], t2)){\n                                if (t2 > 0.0001 && t2 < 1.0){\n                                    ombre = 0;\n                                    break;\n                                }\n                            }\n                        }\n\n                        //Prise en compte des ombres\n                        if (ombre == 1){\n                           col += \n                               cones[i].Color * \n                               spheres[j].Color * \n                               calcCosCone(R ,p, cones[i], spheres[j].Center, C);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    fragColor = vec4(col, 1.0); \n}","name":"Image","description":"","type":"image"}]}