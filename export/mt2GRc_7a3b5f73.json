{"ver":"0.1","info":{"id":"mt2GRc","date":"1673659400","viewed":121,"name":"UV remap to quads test","username":"ianertson","description":"Wanted to try and remap uv coordinates to separate boxes, and then made something fun with it.\nYou can drag around the ball by clicking and dragging with the mouse.","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["uv","box","quads"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_BOXES 8\n#define SEED fract(131.2215175 * iDate.z)\n\n\nstruct Box {\n  vec2 min;\n  vec2 max;\n  vec2 uv;\n  vec3 color;\n};\n\nbool boxVsPoint(in Box box, in vec2 fc) {\n  if (fc.x < box.min.x || fc.x > box.max.x) return false;\n  if (fc.y < box.min.y || fc.y > box.max.y) return false;\n  return true;\n}\n\n\nbool getBox(vec2 fc, vec2 boxPos, float bsize, inout Box box) {\n  box.min = boxPos - vec2(bsize);\n  box.max = boxPos + vec2(bsize);\n\n  if (!boxVsPoint(box, fc)) return false;\n    \n  vec2 size = box.max - box.min;\n  box.uv = ((box.max - fc)/size)*-1.0;\n    \n  return true;\n}\n\nvec2 getPos(vec2 p, float s) {\n  s *= 6.36;\n  p *= 0.10291;\n  vec3 rgb = texture(iChannel0, p).rgb;\n  vec3 rgb2 = texture(iChannel0, rgb.rg*rgb.b).rgb;\n    \n  float sx = mix(-1.0, 1.0, smoothstep(0.0, 1.0, rgb2.x));\n  float sy = mix(-1.0, 1.0, smoothstep(0.0, 1.0, rgb2.y));\n    \n  vec2 a = vec2(sx, sy)*mix(rgb.rg, rgb.gb, smoothstep(0.0, 1.0, rgb.b+s));\n  vec3 b_ = normalize(hashv3Signed(rgb2, s));\n  vec2 b = b_.xy*b_.z;\n    \n  return normalize(mix(a, b, smoothstep(0.0, 1.0, rgb2.z+s)));\n     \n}\nvec2 getPan(vec2 pos, float i) {\n   \n  vec2 k = getPos((pos*0.6)-vec2(0.521, 0.325), i+0.0215);\n  vec2 a = vec2(cos(k.x*iTime), sin(k.y*iTime));\n  vec3 b = abs(hashv3Signed(vec3(k, i), i));\n  \n  return mix(a, b.xy, smoothstep(0.0, 1.0, b.z)) * ((k.x+k.y)/2.0);\n}\n\nfloat getSize(vec2 minmax, vec2 pos, float i) {\n  pos += vec2(0.015, 0.0315)*6.0;\n    \n  vec2 k0 = vec2(hash2(pos, i), hash2(pos, i+0.5));\n  vec2 k1 = vec2(hash2(pos*k0, i-0.5), hash2(pos, i+(k0.x*0.5)));\n    \n    \n  float scale = mix(k0.x, k1.x, smoothstep(0.0, 1.0, k1.y));\n    \n  return toRange(scale, minmax.x, minmax.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fc/iResolution.xy;\n  vec3 col = vec3(0.0);\n  vec2 center = iResolution.xy/2.0;\n  float seed = fract(tan((SEED*cos(SEED*0.2185))*200.2));\n    \n  float ballSize = 32.0;\n  float ballId = 0.021+fract(cos(seed));\n  vec2 ball = getPos(vec2(ballId), 0.51)*(iResolution.xy*0.5);\n  ball = ball + (getPan(ball*0.1, ballId)*2.0*ballSize);\n  ball = iMouse.z > 0.001 ? iMouse.xy : ball;\n    \n  vec2 sizeRange = vec2(0.2, 1.0) * 128.0;\n\n\n  vec2 pos = center;\n    \n\n    \n  vec2 off = vec2(0.0);\n    \n  for (int i = 0; i < NUM_BOXES; i++) {\n    float boxId = (float(i)/float(NUM_BOXES));\n\n    float size = getSize(sizeRange, vec2(boxId), boxId+0.1);\n    //vec2 pan = getPan(pos*0.00001, idx);\n    pos = getPos(pos*0.5, boxId)*(iResolution.xy*0.5);\n    //vec2 offpos = pos + off;\n    \n    vec2 mypos = pos;\n    vec2 panned = mypos + (getPan(pos*0.1, boxId)*2.0*size);\n    \n    mypos = mix(mypos, panned, 0.99*smoothstep(0.0, 1.0, (length(panned))));\n\t\n    // pos += pan*(size*6.0);\n\n\t\n    \n    Box box;\n    if (getBox(fc, mypos, size, box)) {\n      col = texture(iChannel0, box.uv).rgb;\n\t    \n      if (boxVsPoint(box, ball)) {\n        vec2 size = box.max - box.min;\n        vec2 mv = ((box.max - ball)/size)*-1.0;\n\n\n        col.xyz *=textureLod(iChannel2, (mv+box.uv)/256.0, 0.0).rgb;\n      }\n    }\n\t\n\t\n  }\n    \n   \n  Box box; \n  float dist = length(ball.xy-fc);\n  float feather = 6.5;\n  float mag = 1.0-smoothstep(ballSize-feather, ballSize+feather, dist);\n\n  if (getBox(fc, ball.xy, ballSize, box)) {\n\n    vec3 mouseCol = textureLod(iChannel2, box.uv/128.0, .0).rgb;\n    col = mix(col, mouseCol, mag*length(mouseCol));\n  }\n  \n  \n  float dx = atan(tan(uv.y*0.5), 1.1215)*cos(uv.y-cos(uv.x*1.6*atan(uv.y, 0.1215)));\n  float dy = atan(tan(uv.x*0.5)-1.1215, 0.21515)*cos(uv.x-cos(uv.y*1.6*atan(uv.x*dx, 0.1215)));\n  \n \n\n  \n  \n  float dx1 = hash2(3.0*vec2(dx, dy)-uv, seed)*1.6;\n  float dy1 = hash2(3.0*vec2(dx, dy)*dx1+uv, seed)*1.16;\n  vec2 distort = vec2(dx1, dy1);\n  vec2 pan = getPan((vec2(dx,dy)*distort)/656.0, 0.001);\n  distort += pan*0.1;\n  \n  distort.y = smoothstep(0.0, 1.0, distort.x-dx);\n  distort.x = mix(dy, cos(uv.y*20.6), smoothstep(0.0, 1.0, hash2(distort*22.0, seed)));\n  \n\n  \n  vec2 bguv = mix(uv*uv, uv*distort*uv, smoothstep(0.0, 1.0, hash2(uv-distort-pan, seed+0.5)));\n  float bgmag = textureLod(iChannel3, bguv/16.0, 0.0).r;\n  vec3 bg = vec3(bgmag) * textureLod(iChannel2, (uv*distort)/64.0, 0.0).rgb;\n  bg /= 1.6;\n  \n  float shade = pow(1.0 - 0.9*pow((0.5+(0.5*cos(sin(uv.y)*3.6))), 2.0), 3.3);\n\n  float items = length(col);\n  \n  float L = (col.r+col.g+col.b)*3.14;\n  col = mix(col, bg, max(0.0, 1.0-L));\n  \n  col = (col*(shade+col));\n  col = pow(col, vec3(1.1));\n  \n  col += (col*luma(col)*items);\n  \n  col = mix(col, unreal(col), 0.6*clamp(0.5+items, 0.1, 0.99));\n\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**\n*  Extremely simple value noise\n*/\n\n#define C0 3815\n#define C1 9847\n#define C2 8477\n#define C3 9582\n#define C4 6186\n#define C5 9354\n#define C6 2276\n\n// converts vec2 to a 1D index\nfloat idx(vec2 v, float k) { return v.x * k + v.y; }\n\n// yields a pseudo-random value from a float\nfloat hash1(float v, float seed) {\n    float s = fract(cos(v*idx(vec2(v+(seed*0.1), seed/1.6), 3.3019)));\n    s = smoothstep(0.0, 1.0, fract(cos((seed/1.6)*s)));\n    s = seed*s;\n    s = fract(1.6/max(0.01, 0.1+s))*1.6;\n    \n    float x0 = v;\n    float y0 = atan(s-v, float(C0) / float(C1));\n    float x1 = atan(s-y0, float(C1) / float(C2));\n    float y1 = atan(s-x1, float(C3) / float(C4));\n    return fract(cos(v*((1.2715+s)*sin((s*0.2)*(0.5+atan(y1, x0))))+y0)\n        * dot(vec2(x0, y0), vec2(x1, y1)));   \n}\n\n// smooth value noise from vec2\nfloat hash2(vec2 uv, float seed) {\n    float k = hash1(float(C2), seed);\n    vec2 id = floor(uv);\n    vec2 lv = smoothstep(0.0, 1.0, fract(uv));\n    float a = hash1(idx(id, k), seed);\n    float b = hash1(idx(id + vec2(1.0, 0.0), k), seed);\n    float ab = mix(a, b, lv.x);\n    float c = hash1(idx(id + vec2(0.0, 1.0), k), seed);\n    float d = hash1(idx(id + vec2(1.0, 1.0), k), seed);\n    float cd = mix(c, d, lv.x);\n    return mix(ab, cd, lv.y);\n}\n\nfloat hash2Signed(vec2 uv, float seed) {\n  return hash2(uv, seed) * mix(-1.0, 1.0, hash2(uv+vec2(0.01), seed+0.2915));\n}\n\nvec3 hashv3Signed(vec3 uv, float seed) {\n  float x = hash2Signed(vec2(uv.x, uv.z), seed);\n  float y = hash2Signed(vec2(uv.y, uv.z), seed);\n  float z = hash2Signed(vec2(uv.x, uv.y), seed);\n\n  return vec3(x, y, z);\n}\n\nfloat toRange(float scale, float mi, float ma) {\n    return clamp(mi + scale * ( ma - mi ), mi, ma);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\nvec3 gammaCorrect(vec3 color, float gamma) {\n  return pow(color, vec3(1.0 / gamma));\n}\n\nvec3 unreal(vec3 x) {\n  return x / (x + 0.155) * 1.019;\n}","name":"Common","description":"","type":"common"}]}