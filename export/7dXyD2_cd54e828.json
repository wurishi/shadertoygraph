{"ver":"0.1","info":{"id":"7dXyD2","date":"1642701870","viewed":155,"name":"glowing bubbles","username":"vanilin","description":"basic ray marching implementation with a custom glowing effect","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 60\n#define SMALL_DISTANCE 0.01\n#define INFINITE_DISTANCE 100.0\n\nstruct Surface{\n    vec4 glow;\n    vec4 smoothColor;\n    float smoothDistance;\n};\n\nstruct Object{\n    float distanceToSurface;\n    float nearDistance;\n    vec4 color;\n};\n\nfloat regularUnion(vec2 distances){\n    return min(distances.x, distances.y);\n}\n\nfloat smoothUnion(vec2 distances, float smoothness)\n{\n    float degree = max(smoothness-abs(distances.x-distances.y), 0.0);\n    return min(distances.x, distances.y) - pow(degree, 2.0) / smoothness * 0.25;\n}\n\nfloat firstRadius = 0.7;\nfloat secondRadius = 1.0;\nfloat thirdRadius = 1.2;\n\nvec4 firstColor = vec4(0.6, 0.6, 0.2, 1.0);\nvec4 secondColor = vec4(0.7, 0.2, 0.6, 1.0);\nvec4 thirdColor = vec4(0.1, 0.7, 0.4, 1.0);\n\nfloat glowDistance = 1.0;\nfloat glowModifier = 0.05;\n\nSurface getDistances(vec3 point){\n\n    vec3 firstCenter = vec3(\n        cos(iTime) * 3.0,\n        sin(iTime * 2.0),\n        -5.0 + 2.0 * cos(iTime)\n    );\n\n    vec3 secondCenter = vec3(\n        sin(iTime) * 3.0,\n        cos(iTime),\n        -5.0\n    );\n\n    vec3 thirdCenter = vec3(\n        0.0,\n        0.0,\n        -5.8\n    );\n\n\n    vec3 firstPoint = point - firstCenter;\n    vec3 secondPoint = point - secondCenter;\n    vec3 thirdPoint = point - thirdCenter;\n    \n    float firstDistance = length(firstPoint) - firstRadius;\n    float secondDistance = length(secondPoint) - secondRadius;\n    float thirdDistance = length(thirdPoint) - (1.2 + sin(pow(thirdPoint.x, 2.0) + pow(thirdPoint.y, 2.0))) * 0.5 * thirdRadius;\n    \n    vec4 thirdPattern = thirdColor * (mod((thirdPoint.x - iTime * 0.5 - thirdPoint.y * 0.1), 0.2) < 0.1 ? 1.0 : 0.7);\n    \n    float smoothDistance = smoothUnion(vec2(firstDistance, secondDistance), 0.8);\n    smoothDistance = smoothUnion(vec2(smoothDistance, thirdDistance), 0.8);\n    \n    vec4 color = mix(firstColor, secondColor, 0.5 + clamp(firstDistance - secondDistance, -0.5, 0.5));\n    color = mix(color, thirdPattern,  0.5 + clamp(min(firstDistance, secondDistance) - thirdDistance, -0.5, 0.5));\n    \n    vec4 glow = vec4(0.0);\n    \n    if (firstDistance < glowDistance){\n        glow += mix(firstColor, firstColor * glowModifier, firstDistance + SMALL_DISTANCE);\n    }\n    \n    if (secondDistance < glowDistance){\n        glow +=  mix(secondColor,secondColor * glowModifier, secondDistance + SMALL_DISTANCE);\n    }\n    \n    if (thirdDistance < glowDistance){\n        //glow +=  mix(thirdColor, thirdColor * glowModifier, thirdDistance + SMALL_DISTANCE);\n    }\n    \n    glow *= glowModifier;\n    \n    return Surface(\n        glow,\n        color,\n        smoothDistance\n    );\n}\n\nvec3 getNormal(vec3 point){\n    vec2 unit = vec2(0.01, 0.0);\n    float distanceToSurface = getDistances(point).smoothDistance;\n    return normalize(vec3(distanceToSurface) - vec3(\n        getDistances(point - unit.xyy).smoothDistance,\n        getDistances(point - unit.yxy).smoothDistance,\n        getDistances(point - unit.yyx).smoothDistance\n    ));\n}\n\nObject rayMarch(vec3 view, vec3 direction){\n    float currentDistance = 0.0;\n    float nearDistance = INFINITE_DISTANCE;\n    vec4 color = vec4(0.0);\n    for (int index = 0; index < MAX_ITERATIONS ; index++){\n        vec3 point = view + direction * currentDistance;\n        Surface surface = getDistances(point);\n        currentDistance += surface.smoothDistance;\n        color += surface.glow;\n        if (surface.smoothDistance < nearDistance){\n            nearDistance = surface.smoothDistance;\n        }\n        if (surface.smoothDistance < SMALL_DISTANCE){\n            color = surface.smoothColor;//+ surface.glow;\n            break;\n        }\n        if (currentDistance > INFINITE_DISTANCE){\n            break;\n        }\n    }\n    return Object(currentDistance, nearDistance, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = 5.0 * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 point = vec3((fragCoord - 0.5 * iResolution.xy)/iResolution.y, -1.0f);\n    vec3 view = vec3(vec2(0.0), 0.0);\n    vec3 direction = normalize(point - view);\n    Object object = rayMarch(view, direction);\n    float distanceToSurface = object.distanceToSurface;\n    fragColor = vec4(0.8, 0.5, 0.5, 0.0) * 0.2;\n    if (distanceToSurface < INFINITE_DISTANCE){\n        vec3 pointOnSurface = view + direction * distanceToSurface;\n        vec3 lightDirection = vec3(mouse.xy, 1.0);\n        float light = (dot(\n            normalize(lightDirection - point),\n            getNormal(pointOnSurface)\n        ) + 1.0) / 2.0;\n        fragColor = object.color * pow(light, 2.0);\n    }\n    if (object.nearDistance < glowDistance){\n        fragColor += object.color;   \n    }\n}","name":"Image","description":"","type":"image"}]}