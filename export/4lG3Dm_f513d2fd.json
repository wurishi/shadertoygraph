{"ver":"0.1","info":{"id":"4lG3Dm","date":"1474886827","viewed":337,"name":"Big3D RayTracer","username":"sohale","description":"Click and drag the mouse around to change the camera angle. \nA Ray-Tracing demo. Features: reflection, Phong shading, Ellipsoids. It's a mini version of my very old program Big3D.\nSee https://github.com/sohale/shaders/blob/master/raytrace1.glsl","likes":1,"published":1,"flags":2,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_CAMERA 1\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nconst vec3 e1=vec3(1.0, 0.0, 0.0);\nconst vec3 e2=vec3(0.0, 1.0, 0.0);\nconst vec3 e3=vec3(0.0, 0.0, 1.0);\nconst vec3 o0=vec3(0.0, 0.0, 0.0);\n\nconst vec4 e4=vec4(0.0, 0.0, 0.0, 1.0);\n\n/*\nmat3 inverse(mat3 m) {\n  // from https://github.com/stackgl/glsl-inverse/blob/master/index.glsl\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n*/\n\n\nconst int SPHERE = 5;\n\nstruct Obj\n{\n    int type;\n    vec3 center;\n    mat3 forward_matrix;\n    mat3 inverse_matrix;\n    vec3 rgb;\n};\n\nObj make_ellipsoid(float rx, float ry, float rz) {\n    // vec4 loc=vec4(0.0, 0.0, 0.0, 0.0);\n    Obj obj;\n    obj.type = SPHERE;\n    // obj.matrix = mat3(e1, e2*2.0, e3);\n    obj.center= e3*6.0 * 0.0;  // Ellipsoid\n    // mat3 im = inverse(obj.matrix);\n    obj.rgb = vec3(1.0,1.0,1.0);\n\n    // rx = 1.0;\n    // ry = 1.0;\n    // rz = 1.0;\n\n    // obj.inverse_matrix = inverse(obj.matrix);\n    obj.inverse_matrix = mat3(e1 / rx, e2 / ry, e3 / rz);\n    obj.forward_matrix = mat3(e1*rx, e2*ry, e3*rz);\n    return obj;\n}\n\n\n// todo: cleanup and fix careless code.\nbool solveQuadratic(in vec3 abc, out float x0, out float x1)\n{\n    float discr = abc.y * abc.y - 4.0 * abc.x * abc.z;\n    if (discr < 0.0) return false;\n    else if (discr == 0.0)\n        x0 = x1 = - 0.5 * abc.y / abc.x;\n    else {\n        float q = (abc.y > 0.0) ?\n            -0.5 * (abc.y + sqrt(discr)) :\n            -0.5 * (abc.y - sqrt(discr));\n        x0 = q / abc.x;\n        x1 = abc.z / q;\n    }\n    if (x0 > x1) {\n        float t = x0;\n        x0 = x1;\n        x1 = t;\n    }\n    return true;\n}\n\nbool sphere_intersect(in Ray ray, out float t, out vec3 where)\n{\n    const float radius2 = 1.0;\n\n    // analytic solution\n    vec3 L = ray.org; // - center;\n    float a = ray.dir.x * ray.dir.x + ray.dir.y * ray.dir.y + ray.dir.z * ray.dir.z ;\n    float b = 2.0 * (ray.dir.x*L.x + ray.dir.y*L.y + ray.dir.z*L.z);\n    float c = (L.x*L.x + L.y*L.y + L.z*L.z) - radius2;\n    vec3 abc = vec3(a,b,c);\n\n    float t0, t1; // solutions for t if the ray intersects\n    if (!solveQuadratic(abc, t0, t1)) return false;\n\n    if (t0 > t1) {\n        float tt = t0;\n        t0 = t1;\n        t1 = tt;\n    }\n\n    if (t0 < 0.0) {\n        t0 = t1; // if t0 is negative, let's use t1 instead\n        if (t0 < 0.0) return false; // both t0 and t1 are negative\n    }\n\n    t = t0;\n\n    where = t * ray.dir + ray.org;\n    return true;\n}\n\nmat3 transpose_(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nvec3 sphere_normal(in Obj obj, in vec3 where) {\n    // vec3 d = vec3(where - obj.center);\n    //d = normalize(d);\n\n    vec3 d = obj.inverse_matrix * (where - obj.center);\n    d = transpose_(obj.forward_matrix) * d;\n\n    d = normalize(d);\n    return d;\n}\n\nbool raycast(in Ray ray, in Obj obj, out float t, out vec3 where)\n{\n    if (obj.type == SPHERE) {\n        Ray ray2 = ray;\n        ray2.dir = obj.inverse_matrix * ray.dir;\n        ray2.org = obj.inverse_matrix * (ray.org - obj.center);\n        float new_norm = length(ray2.dir);\n\n\n        vec3 where2;\n        float t2;\n        bool did = sphere_intersect(ray2, t2, where2);\n\n        where = obj.forward_matrix * where2 + obj.center;\n        t = t2 ; //* new_norm;\n        ////////////////\n        return did;\n    }\n    // error: unrecognised object type\n    return false;\n}\n\n\nvec3 my_reflect(in vec3 ray, in vec3 normal) {\n    float cos_ = dot(ray, normal);\n    vec3 p = cos_ * normal;\n    return 2.0 * p - ray;\n}\n\nfloat my_inner(in vec3 a, in vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec4 phong_material(in vec3 light_dir, in vec3 ray_dir, in vec3 normal, in vec3 obj_rgb) {\n    float diffuse = - (light_dir.x * normal.x + light_dir.y * normal.y + light_dir.z * normal.z);\n    diffuse = diffuse > 0.0 ? diffuse : 0.0;\n\n    vec3 refl = my_reflect(-light_dir, normal);\n    refl = normalize(refl);\n    ray_dir = normalize(ray_dir);\n    float specular0 = my_inner(refl, -ray_dir);\n    specular0 = specular0 > 0.0 ? specular0 : 0.0;\n    // specular0 = specular0 > 1.0 ? 1.0:specular0;\n    // specular0 = specular0 > 10.0 ? specular0: 0.0;\n    float specular = pow(specular0, 5.0);\n    // float specular = specular0 * 1.0 - floor(specular0 * 1.0);  // nice debug tool\n\n    return vec4(diffuse * obj_rgb + specular * vec3(1.0,1.0,1.0), 1.0);\n}\n\nfloat min_(vec2 v) {\n    return v.x > v.y ? v.x : v.y;\n}\n\nvec2 screen_uv(vec2 fragCoord) {\n    float mindim = min_(iResolution.xy) / 2.0;\n    vec2 center = iResolution.xy / 2.0;\n    vec2 uv = (fragCoord.xy - center.xy) / mindim;\n    vec2 uv2 = vec2(uv.x, uv.y);\n    return uv2;\n}\n\n\nmat3 rotationMatrixXY(float aXY){\n    return mat3(\n        cos( aXY ), -sin( aXY ), 0.0,\n        sin( aXY ),  cos( aXY ), 0.0,\n        0.0,           0.0, 1.0\n    );\n}\nmat3 rotationMatrixYZ(float a){\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos( a ), -sin( a ),\n        0.0, sin( a ),  cos( a )\n    );\n}\nmat3 rotationMatrixXZ(float a){\n    return mat3(\n        cos( a ), 0.0, -sin( a ),\n        0.0,      1.0,  0.0,\n        sin( a ), 0.0,  cos( a )\n    );\n}\n\n/*\nmat4 rotationMatrix(xy, yz, xz){\n    rotationMatrixXY();\n}\n*/\n\n\nstruct Camera {\n    mat3 screen_mat;\n    vec3 screen_center;\n    vec3 origin;  // eye point\n};\n\nconst float PI = 4.1415926536;\n\nCamera init_camera(vec2 mouse) {\n    Camera camera;\n\n    //camera.screen_mat = mat3(e1, e2, o0);\n    // mat3 rot = rotationMatrixYZ(0.5*PI) * rotationMatrixXZ(0.0);\n    // camera.screen_center = -e3 + mouse.x * e1 * 1.0 + mouse.y * e2 * 1.0;\n\n    mat3 rot = rotationMatrixYZ(-mouse.y) * rotationMatrixXZ(-mouse.x);\n    camera.screen_mat = rot * mat3(e1, e2, e3);\n    camera.screen_center = rot * (-e3) *5.0;\n    camera.origin =  (camera.screen_center - rot * 5.0*e3);\n\n\n    // mat3 m = rotationMatrixYZ()\n\n    return camera;\n}\n\nRay make_ray(Camera camera, vec2 uv2) {\n    vec3 uv3 = vec3(uv2, 0.0);\n\n    vec3 s = camera.screen_mat * uv3 + camera.screen_center; //screen\n\n    Ray r;\n    r.org = s;\n    r.dir = s - camera.origin;\n    //r.dir = -s;\n    r.dir = normalize(r.dir);\n\n    return r;\n}\n\nstruct TexturedScreen {\n    // mat3 screen_mat;\n    // vec3 screen_center;\n    vec3 e3t_Minv;\n    float e3t_Minv_C0;\n};\n\nTexturedScreen make_TexturedScreen_behind_camera(Camera camera) {\n    /*\n    screen.screen_mat = camera.screen_mat;\n    screen.screen_center = camera.screen_center;\n    screen.e3t_Minv = transpose_(inverse(screen.screen_mat))*vec3(1.0, 0.0, 0.0);\n    screen.e3t_Minv_C0 = my_inner(screen_center, e3t_Minv);\n    */\n\n    //copied from camera\n    float mouse_y =0.0, mouse_x = 0.0;\n    mat3 rot = rotationMatrixYZ(-mouse_y) * rotationMatrixXZ(-mouse_x);\n    // camera__screen_mat = rot * mat3(e1, e2, e3);\n    vec3 screen_center = rot * (-e3) *5.0;\n    mat3 rot_inv = rotationMatrixYZ(+mouse_y) * rotationMatrixXZ(+mouse_x);\n\n    TexturedScreen screen;\n   \n    screen.e3t_Minv = rot_inv * vec3(0.0, 0.0, 1.0);\n    screen.e3t_Minv_C0 = my_inner(screen_center, screen.e3t_Minv);\n\n    return screen;\n}\n\nbool project_onto_screen_t(in TexturedScreen screen, in Ray ray, out float t) {\n    float denom = my_inner(ray.dir, screen.e3t_Minv);\n    if (abs(denom) < 0.000000001)\n        return false;\n    t = my_inner(ray.org, screen.e3t_Minv) - screen.e3t_Minv_C0;\n    return (t >= 0.0);\n}\n\nbool project_onto_screen_uv2(in TexturedScreen screen, in Ray ray, out vec2 uv2) {\n    float t;\n    if (project_onto_screen_t(screen, ray, t)) {\n        vec3 uv3 = t * ray.dir + ray.org;\n        uv2 = uv3.xy;\n        return true;\n    }\n    return false;\n}\n\n\nvec4 panic() {\n    return vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nconst int num_objects = 4;\n\n\nbool world_raycast(Ray ray,\n    in Obj[num_objects] obj,\n    out Obj chosen_obj,\n    out vec3 chosen_where,\n    out int chosen_obj_id,\n    out float tmin,\n    in int exclude\n) {\n    bool did = false;\n\n    chosen_obj_id = -1;\n\n    tmin = 100000000.0;\n\n    //Obj chosen_obj;\n    //vec3 chosen_where;\n    chosen_obj_id = -1;\n\n    {\n        Obj curr_obj;\n\n\n        for (int i = 0 ; i < num_objects; ++i) {\n            /*\n            if (i==0) {\n                curr_obj = obj[0];\n            } else if (i==1) {\n                curr_obj = obj[1];\n            } else if (i==2) {\n                curr_obj = obj[2];\n            }\n            */\n            curr_obj = obj[i];\n            // Avoid self intersection\n            if (exclude == i)\n                continue;\n\n            float t;\n            vec3 where;\n            bool did1;\n\n            did1 = raycast(ray, curr_obj, t, where);\n            if (did1) {\n                if (tmin > t)\n                {\n                    tmin = t;\n                    chosen_obj_id = i;\n                    chosen_obj = curr_obj;\n                    chosen_where = where;\n                    did = true;\n                }\n                // assert did == true\n            }\n        };\n\n    }\n\n\n    return did;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    float time = iTime;\n\n    vec2 mousexy = screen_uv(iMouse.xy);\n\n    Camera camera = init_camera(-mousexy * 3.14*2.0 + vec2(0.0, 0.6)* 3.14*2.0 + vec2(time*0.02 + (-0.1) + sin(time*0.33 *PI*2.0)*0.2, time*0.004));\n\n    //vec3 uv3 = vec3(screen_uv(fragCoord), 0.0);\n    // vec3 s = camera_screen_mat * uv3 + camera_screen_center; //screen\n\n    vec2 uv2 = screen_uv(fragCoord);\n    Ray r = make_ray(camera, uv2);\n\n    Obj obj[num_objects];\n    obj[0] = make_ellipsoid(1.0, 1.0,1.0);\n    obj[0].center.x -= 1.5/1.0;\n    obj[0].rgb = vec3(1.0, 1.0, 0.0);\n\n    obj[1] = make_ellipsoid(1.0, 0.7,1.0);\n    obj[1].center.x += 1.5/2.0;\n    obj[1].center.z -= 0.3;\n    obj[1].rgb = vec3(1.0, 0.0, 0.0);\n\n    obj[2] = make_ellipsoid(1.0, 1.0, 0.7);\n    obj[2].center.y += 0.5;\n    obj[2].center.z += 0.9;\n    obj[2].rgb = vec3(0.0, 1.0, 0.0);\n\n    obj[3] = make_ellipsoid(0.3, 0.3, 0.3);\n    obj[3].center.y += 0.0;\n    obj[3].center.y += 0.2;\n    obj[3].center.z += 0.0;\n    obj[3].rgb = vec3(0.0, 0.0, 1.0);\n\n    // mat4 invobj = inverse(obj);\n\n    if (false) {\n    #ifdef USE_CAMERA\n        TexturedScreen webcam_screen = make_TexturedScreen_behind_camera(camera);\n    #endif\n    }\n\n    //int obj_id = -1;\n\n    Obj chosen_obj;\n    vec3 chosen_where;\n    int chosen_obj_id;\n    float tmin;\n\n    bool did = world_raycast(r, obj, chosen_obj,chosen_where,chosen_obj_id,tmin, -1);\n\n    // not necessary anymore:\n    //vec3 ray_dir_normalized = normalize(r.dir);\n\n    // vec3 radial = where - obj[i].center;\n\n    vec3 light_dir = vec3(-1.0, -1.0, +1.0);\n    light_dir = normalize(light_dir);\n\n    vec4 cc;\n    vec4 cc2;\n\n    if (did) {\n        // // c = t / 5.0;\n        //c = -radial.z * 1.0;\n\n        if (chosen_obj_id < 0) {\n            fragColor = panic();\n            return;\n        }\n\n        vec3 normal = sphere_normal(chosen_obj, chosen_where);\n        cc = phong_material(light_dir, r.dir, normal, chosen_obj.rgb);\n\n\n        Ray ray2;\n        ray2.org = chosen_where + r.dir * 0.001 * 0.0;\n        ray2.dir = my_reflect(-r.dir, normal);\n\n        Obj chosen_obj2;\n        vec3 chosen_where2;\n        int chosen_obj_id2;\n        float tmin2;\n\n        bool did2 = world_raycast(ray2, obj, chosen_obj2,chosen_where2,chosen_obj_id2, tmin2, chosen_obj_id);\n\n        if (did2) {\n            vec3 normal2 = sphere_normal(chosen_obj2, chosen_where2);\n            cc2 =   phong_material(light_dir, ray2.dir, normal2, chosen_obj2.rgb );\n\n            // float w1 = 0.6, w2 = 0.4; //\n            float w1 = 1.0, w2 = 0.0; // Pure reflection\n            cc2.r = cc2.r * w1 + chosen_obj.rgb.r * w2;\n            cc2.g = cc2.g * w1 + chosen_obj.rgb.g * w2;\n            cc2.b = cc2.b * w1 + chosen_obj.rgb.b * w2;\n            //cc2 = vec4(0.0, 0.0, 0.0, 0.0);\n\n        } else {\n            cc2 = vec4(0.0, 0.0, 0.0, 0.0);\n\n            #ifdef USE_CAMERA\n                cc2.xyz = texture(iChannel0, ray2.dir.xy).xyz;\n                cc2.xyz = texture(iChannel0, 1.0-ray2.dir.xy).xyz - 0.5;\n            if (false) {\n\n                //vec3 screen_center = vec3();\n                //mat3 screen_matrix = mat3(e1, e2, e3);\n                //rayscreen = transform(ray2, screen_matrix, screen_center)\n                //vec2 uv;\n                //project_onto_screen_uv2(webcam_screen, ray2, uv);\n                //cc2.xyz = texture(iChannel0, uv).xyz;\n            }\n            #endif\n\n        }\n\n\n        // float tn = abs((tmin -2.5)*1.0);\n        // cc = vec4(tn, tn, tn, 0.0) + vec4(0.0,0.0,0.0,1.0);\n    } else {\n        //c = 0.0;  // why omitting this causes apparent noise?\n        cc = vec4(0.0, 0.0, 0.0, 1.0);\n        cc2 = vec4(0.0, 0.0, 0.0, 0.0);\n\n        // Background will be from the camera (which is not good)\n        // cc.xyz = texture(iChannel0, r.dir.xy).xyz;\n\n    }\n\n    // fragColor = vec4(uv,0.5+0.5*sin(time),1.0);\n    // fragColor = vec4(c, c, c, 1.0);\n    fragColor = cc * 1.00 + cc2 * 0.4;\n}\n","name":"Image","description":"","type":"image"}]}