{"ver":"0.1","info":{"id":"stSXRD","date":"1627262937","viewed":319,"name":"Columns / Domain Rep","username":"byt3_m3chanic","description":"Columns / Domain Rep - music \"droid bishop\" ","likes":14,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    Columns / Domain Rep \n    @byt3_m3chanic | 07/25/21\n    \n    working with some looping movement\n    / animation in a cute isometric thing\n    - music \"droid bishop\" \n    \n*/\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    1e-4\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq - all sdf's\nfloat box(vec3 p, vec3 s) \n{\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat box(vec2 p,vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat cap( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat vcap( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nconst float drep = 12.;\nconst float angle = 2.*PI/drep;\nconst float angfl = angle/2.;\nconst float hfrep = drep/2.;\n\nfloat polar(inout vec2 p) \n{\n    //float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angfl;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angfl;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (hfrep)) ? abs(c) : c;\n} \n\n//constants\nconst float sz = 6.;\nconst float hf = sz/2.;\nconst float db = sz*2.;\n\n//global\nfloat ftime=0.,ga1,ga2,ga3,ga4,tmod=0.,speed=0.;\nmat2 turn,rurn,r45,rx,ry;\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0);\n\nfloat column(vec3 q)\n{\n    float clm = cap(q,.3,1.5);\n    vec3 p =vec3(q.x,abs(q.y),q.z);\n    float pcap = box(p-vec3(0,1.45,0),vec3(.5,.1,.5))-.005;\n          pcap = min(cap(p-vec3(0,1.3,0),.4,.05),pcap);\n    \n    polar(q.xz);\n    float grv = vcap(q-vec3(.3,-1.1,0),2.2,.045);\n    return min(pcap,max(clm,-grv));\n}\n\nvec2 map(vec3 p)\n{\n    p.x-=T*.4;\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n\n    vec3 qid = floor((q+hf)/sz)+vec3(11);\n    vec3 ofs = q+vec3(hf);\n    vec3 xid = floor((ofs+hf)/sz);\n    vec3 tt = q;\n    \n    float fhs;\n    if(tmod<4.){\n      \tfhs = hash21(qid.zy);\n        tt.x += (fhs>.5) ? ftime : -ftime;\n    } else {\n      \tfhs = hash21(qid.xy);\n        tt.z += (fhs>.5) ? ftime : -ftime;\n    }\n\n    q = mod(q+hf,sz)-hf;\n    vec3 tid = floor((tt+hf)/sz);\n    tt = mod(tt+hf,sz)-hf;\n\n    if(tmod<4.){\n        tt.xy*=(fhs>.5) ? turn : rurn;\n    }else{\n        tt.yz*=(fhs>.5) ? rurn : turn;\n    }\n    \n    float sphere = length(abs(q)-hf)-1.15;\n    sphere = min(length( vec2(abs(q.z)-hf,abs(q.y)-hf))-.1,sphere);\n    if(p.y>-1.65) sphere = 0.5;\n    if(sphere<res.x)\n    {\n        res = vec2(sphere,2.);\n    \thit=q;\n        gid=xid+25.;\n    }\n    \n    float pillar = column( vec3(abs(q.x)-hf,q.y,abs(q.z)-hf));\n    pillar=min(column( vec3(abs(q.x)-hf,q.z,abs(q.y)-hf)),pillar);\n    if(p.y>-1.65) pillar = 0.5;\n    if(pillar<res.x)\n    {\n        res = vec2(pillar,4.);\n    \thit=q;\n        gid=qid+25.;\n    }\n\n    float balls = length(abs(tt)-.45)-.45;\n    balls=max(box(tt,vec3(.55)),balls);\n    if(p.y>1.) balls = 1.;\n    if(balls<res.x)\n    {\n        res = vec2(balls,1.);\n    \thit=q;\n        gid=tid+25.;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    vec3 c = vec3(0.325,0.976,0.867);\n    return .50 + .35*cos(T*.3+PI2*t*(c*vec3(.98,.99,.97))); \n}\n\nvoid topLayer(inout vec3 C, vec2 uv)\n{\n    float px = fwidth(uv.x);\n    uv*=rot(.03);\n    float bx = box(uv-vec2(-.02,.02),vec2(.85,.45))-.0125;\n    float dx = abs(bx)-.0025;\n    dx=smoothstep(px,-px,dx);\n    bx=smoothstep(-px,px,bx);\n\n    float bd = box(uv-vec2(.065,-.055),vec2(.825,.425))-.0125;\n    float sd =smoothstep(.085-px,px,bd);\n\n    float ln = texture(iChannel0,uv*.75).r;\n    ln=smoothstep(.42-px,px,ln);\n    vec3 base = vec3(.83);\n    base = mix(base*.3,base,clamp((uv.y+.5),0.,1.));\n    vec3 acct = hue(55.)*.1;\n    vec3 edge = mix(vec3(.95),acct,clamp((uv.y+.5),0.,1.));\n    C=mix(C,base,bx);\n    C=mix(C,acct,min(ln,bx));\n    C=mix(C,C*.15,min(sd,bx));\n    C=mix(C,edge,dx);\n    C=mix(C,C*.8,max(hash21(uv),bx));\n\n}\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal    \n    float zoom = mod(T*.1,4.)<2. ? 10. : 6.;\n    tmod=mod(T,8.);\n    ftime = fract(T*.25)*sz;\n    r45=rot(-0.78539816339);\n    turn=rot(ftime*PI/2.);\n    rurn=rot(-ftime*PI/2.);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0.,0.,1.);\n\n    ro.yz*=r45;\n    ro.xz*=r45;\n    rd.yz*=r45;\n    rd.xz*=r45;\n    \n    vec3 FC = mix(hue(3.),hue(95.),clamp((uv.y+.5)*.75,0.,1.));\n    vec3 C = vec3(0);\n    vec3 p;\n    float d=0.,m=0.;\n\n    if(uv.y>-.48&&uv.y<.52 && uv.x>-.9&&uv.x<.87)\n    {      \n        //marcher\n        for(int i=0;i<100;i++)\n        {\n            p=ro+rd*d;\n            vec2 ray = map(p);\n            d += ray.x;\n            m  = ray.y;\n            if(abs(ray.x)<MIN_DIST ||d>MAX_DIST)break;\n        }\n\n        float alpha = 1.;\n        sid=gid;\n\n        if(d<MAX_DIST)\n        {\n            alpha = 0.;\n            vec3 n = normal(p,d);\n            vec3 lpos =vec3(3, 8., -7.);\n            vec3 l = normalize(lpos-p);\n            float diff =  clamp(dot(n,l),0.,1.);\n\n            float shdw = 1.;\n            for( float t=.03; t < 13.; )\n            {\n                float h = map(p + l*t).x;\n                if( h<MIN_DIST ) { shdw = 0.; break; }\n                shdw = min(shdw, 24.*h/t);\n                t += h * .25;\n                if( shdw<MIN_DIST || t>25. ) break;\n            }\n\n            vec3 h = vec3(.125);\n\n            if(m==1.) {\n                vec3 view = normalize(p - ro);\n                vec3 ret = reflect(normalize(lpos), n);\n                float spec = .75 * pow(max(dot(view, ret), 0.), 10.);\n                h=hue(14.732*(sid.y+5.));\n                diff = mix(diff,diff*shdw,.65);\n                C = vec3(diff*h)+spec;\n            }\n\n            if(m==2.) {\n                diff=d*.1;\n                h=hue(33.6+(sid.z*.05));\n                diff = mix(diff,diff*shdw,.65);\n                C = diff*h;\n            }\n\n            if(m==4.){\n                vec3 view = normalize(p - ro);\n                vec3 ret = reflect(normalize(lpos), n);\n                float spec = .75 * pow(max(dot(view, ret), 0.), 10.);\n                h = hue(41.5);\n                diff = mix(diff,diff*shdw,.65);\n                C = vec3(diff*h)+spec;\n            }\n\n        } \n\n        C = mix(FC,C,exp(-.000095*d*d*d));\n    }\n    \n    topLayer(C,uv);\n    C=pow(C, vec3(.4545));\n    C=clamp(C,vec3(.03),vec3(1.));\n    \n    O = vec4(C,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}