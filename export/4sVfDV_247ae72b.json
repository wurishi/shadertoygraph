{"ver":"0.1","info":{"id":"4sVfDV","date":"1530601404","viewed":108,"name":"Raymarch doodling","username":"dust","description":"Cool animation I found when I was working on something else :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","distancefield","distance","function"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Scene distance function\nfloat SceneDF(vec3 coord,\n              vec3 dir,\n              vec4 sphInfo)\n{\n    // Find baseline distance to the super-sphere SDF\n    float superSph = SphDF(coord,\n                           sphInfo);\n\n    // Find distance to the sphere-set on x,y\n    float sphSet = SphFieldSDF(4.0,\n               \t\t\t\t   coord);\n    \n    // Return blend between the single sphere SDF and\n    // the sphere-set\n    return mix(superSph, sphSet, sin(iTime));\n}\n\n// Four-tap tetrahedral normals from nimitz\n// (https://www.shadertoy.com/view/Xts3WM)\nvec3 norml(vec3 coord,\n           vec3 dir,\n           vec4 sphInfo)\n{\n    vec2 e = vec2(-1.0f, 1.0f) * EPSILON;\n    return normalize(SceneDF(coord + e.yxx, dir, sphInfo) * e.yxx +\n                     SceneDF(coord + e.xxy, dir, sphInfo) * e.xxy +\n                     SceneDF(coord + e.xyx, dir, sphInfo) * e.xyx +\n                     SceneDF(coord + e.yyy, dir, sphInfo) * e.yyy);\n}\n\n// Core render function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Simple marching loop\n    vec3 eyePos = vec3(0, 0.0, -2.5);\n    vec3 rayDir = RayDir(fragCoord,\n                         iResolution.xy);\n    float currRayDist = 0.0;\n    vec3 rgb = vec3(0.25, 0.25, 0.25);\n    for (int i = 0; i < 256; i += 1)\n    {\n        vec3 ray = eyePos + (rayDir * currRayDist);\n        float dist = SceneDF(ray,\n                             rayDir,\n                             vec4(0.0, 0.0, 0.0, \n                                  1.0));\n        if (dist < EPSILON)\n        {\n            vec3 ltPos = vec3(0, 0.2, -3);\n            rgb = vec3(0.1, 0.1, 0.1) * dot(vec3(ltPos - ray), norml(ray,\n                                                                     rayDir,\n                                                                     vec4(0.0, 0.0, 0.0, \n                                  \t\t\t\t\t\t\t\t\t\t  1.0)));\n            break;\n        }\n        else\n        {\n            currRayDist += dist;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// Epsilon value used to define approximate contact distance\n// for fields within the scene\n#define EPSILON 0.001\n\n// Spherical distance function\n// [sphInfo] has position in [xyz], radius in [r]\nfloat SphDF(vec3 coord,\n            vec4 sphInfo)\n{\n    return length(coord - sphInfo.xyz) - sphInfo.w;\n}\n\n// Small function to evaluate sphere sets in XY\n#define SPH_FIELD_HEIGHT 0.1\nfloat SphFieldSDF(float freq,\n                  vec3 coord)\n{\n    // Extract a period from the given frequency\n    float period = 1.0f / freq;\n    \n    // Trap the given position in the interval [-period, period]\n    // Also allow for a half-period buffer around each figure\n    vec3 xyPos = vec3(mod(coord.x, period) - (0.5 * period), \n                      mod(coord.y, period) - (0.5 * period),\n                      coord.z);\n    \n    // Evaluate distance to implicit members of the set\n    return SphDF(xyPos, \n                 vec4(0,0,0,SPH_FIELD_HEIGHT));\n}\n\n// Ray generator for a perspective pinhole camera\nvec3 RayDir(vec2 pixPos,\n            vec2 viewSizes)\n{\n    vec3 dir = vec3(pixPos - (viewSizes / 2.0),\n                \tviewSizes.y / tan(1.62 / 2.0));\n    return normalize(dir);\n}\n","name":"Common","description":"","type":"common"}]}