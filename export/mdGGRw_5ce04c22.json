{"ver":"0.1","info":{"id":"mdGGRw","date":"1678306221","viewed":148,"name":"Windows Pipe Dream 2D","username":"gunthern","description":"Windows Pipes Screensaver (https://www.youtube.com/watch?v=Uzx9ArZ7MUU) in 2D SDF voxel grid.\nTry changing the grid size, seed, number of pipes or speed in the common tab to see different results!\n\nThanks @morimea for tips on improving previous version.","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["screen","windows","screensaver","dream","microsoft","saver","xp","pipe","pipes","pipes","windows95","95","y2k","pipedream","2000","windows98"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D version of the classic Microsoft \"Pipe Dream\" screensaver\n// Big thanks to @morimea for many tips on improving the first \n// version of this shader, specifically using voxels for each \n// pipe point instead of a very slow for loop when drawing the pipes.\n\nvoid getFade(out float fade, out int iter) {\n\n    iter = iFrame / (duration + fadeDuration);\n    \n    fade = 1.0 - (float(max((iFrame - (duration+fadeDuration)*iter) - duration, 0)) / float(fadeDuration));\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Fade amount and iteration\n    float fade;\n    int iter;\n    getFade(fade, iter);\n    \n    // Draw pipes\n    fragColor = texture(iChannel1, uv) * fade;\n    \n    // Buffer debug\n    //fragColor = texture(iChannel0, uv * 0.1);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Global Variables //\n\n// Max FPS\n#define fps 60\n// Square grid size\n#define gridSize 21\n// Random seed (for start positions, directions, and colors)\n#define randomSeed 34.24\n// Number of pipes\n#define numPipes 7\n// Speed (frames between updates)\n#define speed int(3.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Duration (length of one arrangement in frames)\n#define duration int(120.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Fade (length of fade out)\n#define fadeDuration int(30.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n\n// Global Functions //\n\n// Random function from the Book of Shaders - returns random value between 0 and 1\nfloat random (in vec2 uv) {\n    \n    return fract(sin(dot(uv.xy, vec2(12.98,78.23))) * randomSeed);\n    \n}\n\n// sdCircle iquilezles.org/articles/distfunctions2d/\nfloat circle(in vec2 p, in bool joint)\n{\n    float r = .1;\n    if (joint) r = .15;\n    return 1.0 - step(r, length(p) - r);\n}\n\n// sdRoundBox iquilezles.org/articles/distfunctions2d/\nfloat connector(in vec2 p, in vec2 b) \n{\n    vec2 q = abs(p)-b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// Random colors\nvec3 color(in float p, in int iter) {\n    \n    float ti = float(iter) * random(vec2(p+1.0));\n    \n    float r = random(vec2(p+ti, p+ti+1.0));\n    float g = random(vec2(p+ti+2.0, p+ti+3.0));\n    float b = random(vec2(p+ti+4.0, p+ti+5.0));\n    \n    vec3 col = vec3(r,g,b);\n    return col;\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Initialize grid and start points\nvoid initGrid(inout vec4 fragColor, in ivec2 ipx, in int iter) {\n\n    fragColor = vec4(0.0);\n    \n    vec3 point;\n    \n    // Unique start points, one per pipe\n    int startPoints[numPipes];\n    const int maxPoints = gridSize*gridSize;\n    int allPoints[maxPoints];\n    \n    for (int i=0; i < maxPoints; i++) {\n        allPoints[i] = i;\n    }\n    \n    for (int i=0; i < numPipes; i++) {\n        int randomStart = int(floor(random(vec2(1.0 + float(i) + float(iter) * randomSeed)) * float(maxPoints - i)));\n        startPoints[i] = allPoints[randomStart];\n        allPoints[randomStart] = allPoints[maxPoints - (1+i)];\n    }\n    \n    int pointIncrement = 0;\n    \n    // Populate grid with available points and start points\n    for (int i=0; i < gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = i / gridSize;\n        \n        int startPoint = 0;\n\n        for (int i=0; i < numPipes; i++) {\n            if (pointIncrement == startPoints[i]) {\n                startPoint = i + 1;\n            }\n        }\n\n\n        if (\n            ipx.x == x\n            && ipx.y == y\n            && startPoint != 0\n        )\n        {\n            point = vec3(float(startPoint) / float(numPipes), 1.5, 0.0);\n        }\n\n        pointIncrement++;\n\n    }\n    \n    fragColor = vec4(point, 1.0);\n    \n}\n\n// Update grid points\nvoid updateGrid(inout vec4 fragColor, in ivec2 ipx, in vec4 previousTex) {\n    \n    fragColor = previousTex;\n    \n    // Get point states\n    bool pointStates[gridSize*gridSize];\n    \n    for (int i=0; i < gridSize*gridSize; i++) {\n        pointStates[i] = true;\n    }\n\n    ivec2 nextPoint;\n    \n    // Find active points\n    for (int i=0; i < gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = i / gridSize;\n        \n        vec3 state = texelFetch(iChannel0, ivec2(float(x)+0.5, float(y)+0.5), 0).rgb;\n\n        if (int(state.g) == 1) {\n\n            // Get possible directions for next point\n            ivec2 up = y < gridSize - 1 ? ivec2(x, y+1) : ivec2(x, y-1);\n            ivec2 down = y > 0 ? ivec2(x, y-1) : ivec2(x, y+1);\n            ivec2 left = x > 0 ? ivec2(x-1, y) : ivec2(x+1, y);\n            ivec2 right = x < gridSize - 1 ? ivec2(x+1, y) : ivec2(x-1, y);\n\n            const int directionCount = 4;\n\n            ivec2 directions[directionCount];\n            directions[0] = up;\n            directions[1] = down;\n            directions[2] = left;\n            directions[3] = right;\n\n            int randomDirIter = 0;\n\n            int directionKey = 0;\n\n            // Generate next point\n            bool validNextPoint = false;\n\n            for (int i=0; i < directionCount; i++) {\n                float newRandom = random(vec2(x + y + randomDirIter + iFrame)) * 0.999;\n                int randomDir = int(floor(newRandom*float(directionCount-i-1)));\n                nextPoint = directions[randomDir];\n                vec3 nextPointState = texelFetch(iChannel0, ivec2(float(nextPoint.x)+0.5, float(nextPoint.y)+0.5), 0).rgb;\n                // Check point availability\n                if (nextPointState.r == 0.0 && pointStates[int(nextPoint.x*gridSize + nextPoint.y)]) {\n                    validNextPoint = true;\n                    // Mark point as taken\n                    pointStates[int(nextPoint.x*gridSize + nextPoint.y)] = false;\n                    directionKey = directions[randomDir] == ivec2(x, y + 1) ? 1 :\n                       directions[randomDir] == ivec2(x, y - 1) ? 2 :\n                       directions[randomDir] == ivec2(x - 1, y) ? 3 :\n                       directions[randomDir] == ivec2(x + 1, y) ? 4 : 0;\n                    break;\n                }\n\n                directions[randomDir] = directions[directionCount-i-1];\n                randomDirIter++;\n\n            }\n\n            // Update next point\n            if (\n                validNextPoint\n                && ipx == nextPoint.xy\n            )\n            {\n\n                fragColor = vec4(state.r, 1.0, directionKey, 1.0);\n            }\n\n            // Update this point\n            if (\n                ipx == ivec2(x,y)\n            )\n            {\n                fragColor = vec4(state.r, 2.5, state.b, 1.0);\n                if (validNextPoint) {\n                    float thisPointDir = mod(state.b, 10.0) + float(directionKey)*10.0;\n                    fragColor = vec4(state.r, fract(state.g) + 2.0, thisPointDir, 1.0);\n                    if (directionKey != int(state.b) && random(vec2(nextPoint)) > 0.5) {\n                        fragColor = vec4(state.r, 2.5, thisPointDir, 1.0);\n                    }\n                } \n            }\n\n        }\n        \n        if (int(state.g) == 2 && ipx == ivec2(x,y)) { \n        \n            fragColor.g = 3.0;\n        \n        }\n\n    }\n\n}\n\n// Stop all pipes\nvoid stopPipes(inout vec4 fragColor, in ivec2 ipx, in vec4 previousTex) {\n    \n    fragColor = previousTex;\n    \n    // Find active points\n    for (int i=0; i < gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = i / gridSize;\n\n        vec3 state = texelFetch(iChannel0, ivec2(float(x)+0.5, float(y)+0.5), 0).rgb;\n\n        if (\n            ipx.x == x\n            && ipx.y == y\n            && int(state.g) == 1\n        )\n        {\n            fragColor = vec4(state.r, 2.5, state.b, 1.0);\n        }\n\n    }\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    if (fragCoord.x > float(gridSize) || fragCoord.y > float(gridSize)) discard;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Current iChannel0\n    vec4 previousTex = texture(iChannel0, uv);\n    \n    // Iteration\n    int iter = iFrame / (duration + fadeDuration);\n    \n    // Draw buffer texture\n    fragColor = previousTex;\n    \n    bool stopCondition = false;\n    \n    // Int fragCoord\n    ivec2 ipx = ivec2(fragCoord);\n    \n    // Initialize\n    if (iFrame == 0 || iFrame % (duration + fadeDuration) == 0) {\n        \n    \tinitGrid(fragColor, ipx, iter);\n        \n        stopCondition = true;\n        \n    }\n    \n    // Stop pipes at duration\n    if ((iFrame - iter*fadeDuration) % duration == 0 && !stopCondition) {\n        \n        stopPipes(fragColor, ipx, previousTex);\n        \n        stopCondition = true;\n    \n    }\n    \n    // Update every s frames\n    if (iFrame % speed == 0 && !stopCondition) {\n    \n        updateGrid(fragColor, ipx, previousTex);\n    \n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void drawPipes(inout vec4 fragColor, in vec2 p, in int iter, inout vec4 previousTex) {\n\n    fragColor = previousTex;\n    \n    // 2D repetition from iquilezles.org/articles/distfunctions/\n    vec2 q = p*float(gridSize)/2.0 + vec2(float(gridSize/2));\n    vec2 r = q-clamp(round(q), vec2(0), vec2(gridSize));\n    \n    // Get point state from buffer\n    int x = int(q.x + 1.5);\n    int y = int(q.y + 1.5);\n    vec3 state = texelFetch(iChannel0, ivec2(x-1,y-1), 0).rgb;\n    \n    vec3 col = vec3(0.0);\n    \n    // Update current point\n    if (int(state.g) == 1) {\n    \n        // Get point attributes\n        bool pipeJoint = mod(state.g, 1.0) == 0.5;\n        \n        int joinDir = int(mod(state.b, 10.0));\n        \n        // Joining connector distance\n        float jd = joinDir == 1 ? connector(r + vec2(0.0, 0.5), vec2(0.2, 0.5)) : \n        joinDir == 2 ? connector(r + vec2(0.0, -0.5), vec2(0.2, 0.5)) : \n        joinDir == 3 ? connector(r + vec2(-0.5, 0.0), vec2(0.5, 0.2)) :\n        joinDir == 4 ? connector(r + vec2(0.5, 0.0), vec2(0.5, 0.2)) : 1.0;\n        \n        // Circle distance\n        float d = circle(r, pipeJoint);\n\n        // Pipe color\n        vec3 color = color(state.r, iter);\n        \n        // SDF combine\n        float v = clamp(sign(d) + (1.0-clamp(sign(jd), 0.0, 1.0)), 0.0, 1.0);\n\n        // Draw circles and color\n        col = v*color;\n        \n    }\n    \n    // Update last point\n    if (int(state.g) == 2) {\n    \n        previousTex = vec4(vec3(0.0), 1.0);\n        \n        // Get point attributes\n        bool pipeJoint = fract(state.g) == 0.5;\n        \n        int reachDir = int(state.b * 0.1);\n        int joinDir = int(mod(state.b, 10.0));\n        \n        // Reaching connector distance\n        float rd = reachDir == 1 ? connector(r + vec2(0.0, -0.5), vec2(0.2, 0.5)) : \n        reachDir == 2 ? connector(r + vec2(0.0, 0.5), vec2(0.2, 0.5)) : \n        reachDir == 3 ? connector(r + vec2(0.5, 0.0), vec2(0.5, 0.2)) :\n        reachDir == 4 ? connector(r + vec2(-0.5, 0.0), vec2(0.5, 0.2)) : 1.0;\n        \n        // Joining connector distance\n        float jd = joinDir == 1 ? connector(r + vec2(0.0, 0.5), vec2(0.2, 0.5)) : \n        joinDir == 2 ? connector(r + vec2(0.0, -0.5), vec2(0.2, 0.5)) : \n        joinDir == 3 ? connector(r + vec2(-0.5, 0.0), vec2(0.5, 0.2)) :\n        joinDir == 4 ? connector(r + vec2(0.5, 0.0), vec2(0.5, 0.2)) : 1.0;\n        \n        // Circle distance\n        float d = circle(r, pipeJoint);\n\n        // Pipe color\n        vec3 color = color(state.r, iter);\n        \n        // SDF combine\n        float v = clamp(sign(d) + (1.0-clamp(sign(rd), 0.0, 1.0)) + (1.0-clamp(sign(jd), 0.0, 1.0)), 0.0, 1.0);\n\n        // Draw circles and color\n        col = v*color;\n    \n    }\n    \n    fragColor = vec4(col, 1.0);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Iteration\n    int iter = iFrame / (duration + fadeDuration);\n    \n    // Get previous texture\n    vec4 previousTex = texture(iChannel1, uv);\n    fragColor = previousTex;\n    \n    bool startSeq = false;\n    \n    // Initialize new sequence\n    if (iFrame % (duration + fadeDuration) == 0) {\n    \n        fragColor = vec4(vec3(0.0), 1.0);\n        \n        startSeq = true;\n    \n    }\n    \n    // Draw pipes\n    if (iFrame % speed == 0) {\n    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        drawPipes(fragColor, p, iter, previousTex);\n        \n        if (!startSeq) fragColor += previousTex;\n        \n    }\n    \n    // Buffer debug\n    //fragColor = texture(iChannel0, (fragCoord/iResolution.xy) * 0.1);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}