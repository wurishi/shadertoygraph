{"ver":"0.1","info":{"id":"3sc3Dj","date":"1569271594","viewed":125,"name":"Infinite Reflecting Spheres","username":"Not_Sean","description":"Infinite spheres with a single reflection","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOV 0.9\n#define EPSILON 0.00001\n\n#define MAX_STEPS 70.\n#define MAX_DIST 40.\n#define REFLECTIONS 30.\n\n#define SPACING 2.\n\n#define multisample\n\n#define CELL_SHADER 0.03\n\nfloat sdf(in vec3 p, float spacing)\n{\n    float dist = length(mod(p, spacing) - .5 * spacing) - .5;\n    return dist;\n}\n\nvec3 estimateNormal(vec3 p, float spacing) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z), spacing) - sdf(vec3(p.x - EPSILON, p.y, p.z), spacing),\n        sdf(vec3(p.x, p.y + EPSILON, p.z), spacing) - sdf(vec3(p.x, p.y - EPSILON, p.z), spacing),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON), spacing) - sdf(vec3(p.x, p.y, p.z - EPSILON), spacing)\n    ));\n}\n\nfloat darkness(float t) \n{\n    return pow(2., - 0.07 * t);\n}\n\nvec3 marchOne(in vec3 p, in vec3 dir, float spacing)\n{\n    vec3 color = vec3(0, 0, 0);\n    \n    float t = 0.;\n    for (float r = 0.; r <= REFLECTIONS; r++)\n    {\n        float minDist = 100000.;\n        for (float i = 0.; i < MAX_STEPS; i++)\n        {\n            float dist = sdf(p, spacing);\n\n            if (abs(dist) < 0.001) {\n                vec3 normal = estimateNormal(p, spacing);\n\n                p -= 0.3 * dir;\n\n                dir = dir - (2.0 * normal * (dot(normal, dir)));\n                \n                vec3 cell3 = mod(ceil (p / spacing), 2.);\n                float cell = cell3.x + cell3.y + cell3.z;\n\n                color += 1.4 * pow(.5, r + 1.) * vec3(0.9 - 0.2 * cell, 0.3 + 0.2 * mod(cell + 1., 2.), 0.2 + 0.3 * cell) * darkness(t);\n\n                break;\n            }\n\n            p += dir * dist;\n            t += dist;\n\n            if (\n                #ifdef CELL_SHADER\n                (minDist < dist && minDist < CELL_SHADER) || \n                #endif\n                t > MAX_DIST)\n            {\n                return .5 * color;\n            }\n\n            minDist = min(dist, minDist);\n        }\n    }\n    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec3 samplePixel(mat4 view, vec3 center, vec2 uv, float spacing)\n{\n    vec4 pixDir = view * normalize(vec4(FOV * uv, 1, 0));\n    \n    return marchOne(center, pixDir.xyz, spacing);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.xx;\n    float pixelStep = 2. / iResolution.x;\n    \n    vec3 eye = vec3(1, cos(iTime * .12), sin(iTime * .06));\n    vec3 center = vec3(0., 0., 0.);\n    vec3 up = vec3(0, 1, 0);\n    \n    mat4 view = viewMatrix(eye, center, up);\n    \n    float spacing = SPACING * (1. + pow(sin(iTime), 2.) * (pow(sin(iTime * 0.1), 2.) + 0.1) * 0.2);\n    \n    vec3 c1 = samplePixel(view, center, uv, spacing);\n    \n    #ifdef multisample\n    vec3 c2 = samplePixel(view, center, uv + vec2(pixelStep, pixelStep) * .5, spacing);\n    vec3 c3 = samplePixel(view, center, uv + vec2(0, pixelStep) * .5, spacing);\n    vec3 c4 = samplePixel(view, center, uv + vec2(pixelStep, 0) * .5, spacing);\n    \n    vec3 col = c1 + c2 + c3 + c4;\n    col *= .25;\n    # else\n    vec3 col = c1;\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}