{"ver":"0.1","info":{"id":"Mt2XWG","date":"1446238845","viewed":2072,"name":"Max norm ellipsoid","username":"sjb","description":"Max norm signed distance field for ellipsoid shape, as described in http://gamma.cs.unc.edu/RECONS/maxnorm.pdf.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["distance","ellipsoid","maxnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MAX_ITER 64\n#define SIGNED_DIST_MAX 1000.0\n\nfloat min3(float a, float b, float c)\n{\n\treturn min(min(a, b), c);\n}\nfloat max3(float a, float b, float c)\n{\n\treturn max(max(a, b), c);\n}\n\nfloat max_element(vec3 v)\n{\n\treturn max3(v.x, v.y, v.z);\n}\nfloat sumx(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\n\nfloat max_norm(vec3 v)\n{\n\treturn max_element(abs(v));\n}\nvec3 max_normalize(vec3 v)\n{\n    return v/max_norm(v);\n}\n\nfloat sd_cube(vec3 p, float r)\n{\n\treturn max_norm(p) - r;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n\t// ax^2 + bx + c = 0, a non-zero\n\tfloat q = b*b - 4.0*a*c;\n\tif (q < 0.0) {\n\t\treturn vec2(SIGNED_DIST_MAX);\n\t}\n\tfloat r0 = -b/(2.0*a);\n\tfloat r1 = sqrt(q)/(2.0*a);\n\treturn vec2(r0 - r1, r0 + r1);    \n}\n\nfloat sd_ellipsoid(vec3 p, vec3 r)\n{\n\t// move ellipse so that target point is at origin, centre in positive space\n\t// f(v) = (v.x - c.x)^2/r.x^2 + (v.y - c.y)^2/r.y^2 + (v.z - c.z)^2/r.z^2 - 1\n\tvec3 c = abs(p);\n\tvec3 c2 = c*c;\n\tvec3 r2 = r*r;\n    float d = SIGNED_DIST_MAX;\n\n\t// gather terms of quadratic\n\tvec3 qa = 1.0/r2;\n\tvec3 qb = -2.0*c/r2;\n\tvec3 qc = c2/r2;\n    float qcs = sumx(qc) - 1.0;\n\n    // check corners:\n    // solve f(v)=0 for v.x=v.y=v.z=t\n    {\n\t\tvec2 t0 = abs(solve_quadratic(sumx(qa), sumx(qb), qcs));\n        d = min3(d, t0.x, t0.y);\n    }\n\n\t// interior of convex shape always hits corners first, so early out\n\tif (qcs <= 0.0) {\n\t\treturn -d;\n\t}\n\n\t// check edges:\n\t// df/dx=0 => v.x=c.x, solve f(v)=0 for v.x=c.x, v.y=v.z=t\n    // then do the same for y and z cases\n    {\n        vec2 t = abs(solve_quadratic(qa.y + qa.z, qb.y + qb.z, qc.y + qc.z - 1.0));\n        d = min(d, max(min(t.x, t.y), c.x));\n\t}\n    {\n        vec2 t = abs(solve_quadratic(qa.x + qa.z, qb.x + qb.z, qc.x + qc.z - 1.0));\n        d = min(d, max(min(t.x, t.y), c.y));\n\t}\n    {\n        vec2 t = abs(solve_quadratic(qa.x + qa.y, qb.x + qb.y, qc.x + qc.y - 1.0));\n        d = min(d, max(min(t.x, t.y), c.z));\n\t}\n\n\t// check faces:\n    // df/dx=df/dy=0 => v.xy=c.xy, so f(v)=0 => |v.z - c.z|=r.z\n\t{\n\t\td = min(d, max3(c.x, c.y, abs(c.z - r.z)));\n\t\td = min(d, max3(c.x, abs(c.y - r.y), c.z));\n\t\td = min(d, max3(abs(c.x - r.x), c.y, c.z));\n\t}\n\n\t// done\n\treturn d;\n}\n\nfloat sd_scene(vec3 p)\n{\n    float sd = sd_cube(p - vec3(1.5, 0.0, 1.5), 0.5);\n    \n    sd = min(sd, sd_ellipsoid(p - vec3(-1.5, 0.0,  1.5), vec3(0.5, 1.0, 1.5)));\n    sd = min(sd, sd_ellipsoid(p - vec3( 1.5, 0.0, -1.5), vec3(1.5, 0.5, 1.0)));\n    sd = min(sd, sd_ellipsoid(p - vec3(-1.5, 0.0, -1.5), vec3(1.0, 1.5, 0.5)));\n    \n\treturn sd;\n}\n\nvoid sample_camera(\n\tvec2 pixel_coord,\n\tout vec3 camera_pos,\n\tout vec3 ray_dir,\n\tout float eps_factor)\n{\n\tvec2 uv = (pixel_coord - iResolution.xy/2.0)/iResolution.y;\n\n\tfloat camera_phi = 0.5*iTime + 0.5;\n\tcamera_pos = 8.0*vec3(cos(camera_phi), 0.7, sin(camera_phi));\n\n\tvec3 look_dir = normalize(-camera_pos);\n\tvec3 u_dir = normalize(cross(look_dir, vec3(0.0, 1.0, .0)));\n\tvec3 v_dir = cross(u_dir, look_dir);\n\n\tfloat fov_factor = 0.5;\n    vec2 fov_uv = fov_factor*uv;\n\tray_dir = max_normalize(look_dir + fov_uv.x*u_dir + fov_uv.y*v_dir);\n\teps_factor = 0.5*fov_factor/iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camera_pos, ray_dir;\n    float eps_factor;\n    sample_camera(fragCoord, camera_pos, ray_dir, eps_factor);\n    \n\tvec3 col = vec3(0.8);\n\n\t// show field on ground plane\n    float ground_y = (iTime > 10.0) ? (cos(iTime - 10.0) - 1.0) : 0.0;\n\tfloat debug_dist = (ground_y - camera_pos.y)/ray_dir.y;\n\tif (0.0 < debug_dist) {\n\t\t\n\t\tfloat debug_sd = sd_scene(camera_pos + ray_dir*debug_dist);\n\t\tfloat d = abs(debug_sd);\n\t\tcol = 0.4 + 0.6*vec3(fract(2.0*d), fract(4.0*d), debug_sd < 0.0);\n\t}\n\t\n\t// ray march\n\tfloat dist = 0.0;\n\tbool is_hit = false;\n\tfor (int i = 0; i < MAX_ITER; ++i) {\n\t\tfloat sd = sd_scene(camera_pos + ray_dir*dist);\n\t\tdist += sd;\n\t\tif (sd < dist*eps_factor) {\n\t\t\tis_hit = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (dist > debug_dist) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// shade\n\tif (is_hit) {\n\t\tvec3 hit_pos = camera_pos + ray_dir*dist;\n\t\tfloat eps = dist*eps_factor;\n\t\t\n\t\tvec2 e = eps*vec2(0.5, -0.5);\n\t\tvec3 normal = normalize(\n\t\t\t  e.xyy*sd_scene(hit_pos + e.xyy)        \n\t\t\t+ e.yxy*sd_scene(hit_pos + e.yxy)        \n\t\t\t+ e.yyx*sd_scene(hit_pos + e.yyx)        \n\t\t\t+ e.xxx*sd_scene(hit_pos + e.xxx));\n\t\t\n\t\tvec3 light_dir = normalize(vec3(2.0, 4.0, 1.0));\n        vec3 light_col = vec3(0.6, 0.5, 0.4);\n\t\tvec3 amb_col = vec3(0.4);        \n        \n\t\tcol = mix(amb_col + light_col*max(dot(normal, light_dir), 0.0), col, 0.2);\n\t}\n\n\tfragColor = vec4(pow(col, vec3(2.2)), 1.0);\n}\n","name":"","description":"","type":"image"}]}