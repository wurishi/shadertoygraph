{"ver":"0.1","info":{"id":"Xc3yR8","date":"1730211348","viewed":23,"name":"Funky Stripes","username":"vuenc","description":".","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["noise","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//vec3[3] palette = vec3[3](vec3(0.702, 0.000, 0.000), vec3(0.902, 0.812, 0.000), vec3(0.071, 0.514, 0.702));\n//vec3[5] palette = vec3[5](vec3(0.953, 0.882, 0.494), vec3(0.867, 0.282, 0.235), vec3(0.294, 0.541, 0.373), vec3(0.051, 0.082, 0.043), vec3(0.980, 0.973, 0.886));\n//vec3[4] palette = vec3[4](vec3(0.027, 0.133, 0.310), vec3(0.929, 0.212, 0.102), vec3(0.988, 0.518, 0.020), vec3(0.969, 0.780, 0.165));\n//vec3[5] palette = vec3[5](vec3(0.267, 0.392, 0.631), vec3(0.384, 0.714, 0.871), vec3(0.702, 0.863, 0.878), vec3(0.980, 0.980, 0.980), vec3(1.000, 0.773, 0.780));\nvec3[8] palette = vec3[8](vec3(0.941, 0.941, 0.941), vec3(0.549, 0.549, 0.549), vec3(0.059, 0.059, 0.059), vec3(0.031, 0.388, 0.827), vec3(0.961, 0.824, 0.086), vec3(0.957, 0.220, 0.035), vec3(0.031, 0.698, 0.200), vec3(0.600, 0.075, 0.749));\n//vec3[8] palette = vec3[8](vec3(0.996, 0.976, 0.776), vec3(1.000, 0.800, 0.302), vec3(0.961, 0.722, 0.000), vec3(0.337, 0.631, 0.769), vec3(0.267, 0.392, 0.631), vec3(0.933, 0.447, 0.420), vec3(0.875, 0.373, 0.314), vec3(0.353, 0.188, 0.204));\n//vec3[6] palette = vec3[6](vec3(1), vec3(0.267, 0.392, 0.631), vec3(0), vec3(0), vec3(0.702, 0.863, 0.878), vec3(0));\n//vec3[14] palette = vec3[14](vec3(0.949, 0.922, 0.541), vec3(0.996, 0.816, 0.000), vec3(0.988, 0.518, 0.020), vec3(0.929, 0.212, 0.102), vec3(0.886, 0.941, 0.953), vec3(0.702, 0.863, 0.878), vec3(0.267, 0.392, 0.631), vec3(0.125, 0.188, 0.318), vec3(1.000, 0.773, 0.780), vec3(0.953, 0.596, 0.765), vec3(0.812, 0.220, 0.584), vec3(0.427, 0.208, 0.541), vec3(0.024, 0.706, 0.690), vec3(0.294, 0.541, 0.373));\n//vec3[5] palette = vec3[5](vec3(0.024, 0.098, 0.133), vec3(0.898, 0.839, 0.176), vec3(0.898, 0.176, 0.741), vec3(0.596, 0.176, 0.898), vec3(0.573, 0.941, 0.898));\n//vec3[2] palette = vec3[2](vec3(1.), vec3(0.));\n//vec3[4] palette = vec3[4](vec3(.3),vec3(0.180,0.761,0.494),vec3(.7),vec3(0.3));\n\nconst float PALETTE_SIZE = 8.;\nconst float[4] COPRIME_NUMBERS = float[4](1., 3., 5., 7.);\n\nvec3 palettePermuted(float index, float permutationIndex) {\n    return palette[int(mod(index*COPRIME_NUMBERS[int(permutationIndex)], PALETTE_SIZE))];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = fetchDataFrom(iChannel0, fragCoord);\n    vec4 oldColor = fetchDataFrom(iChannel1, fragCoord);\n    bool flipColor = false;\n    for (int i = -0; i <= 0; i++) {\n        for (int j = -0; j <= 0; j++) {\n            if (length(fetchDataFrom(iChannel0, fragCoord+vec2(i,j)) - fetchDataFrom(iChannel1, fragCoord+vec2(i,j)))\n                > 0.03) {\n                flipColor = true;\n            }\n        }\n    }\n    if (flipColor) color = 1.-oldColor;\n    else color = oldColor;\n    //color = 0.5 * color + 0.5 * oldColor;\n    \n    //if (mod(fragCoord.x, 2.0) == 0.) color=oldColor;\n    /*if (iMouse.z > 0.) {\n        //vec4 oldColor = fetchDataFrom(iChannel1, fragCoord);\n        //fragColor.rgb = length(oldColor.rgb - fragColor.rgb) > 0.003 ? vec3(1) : vec3(0);\n        float sumDifhttps://www.shadertoy.com/img/themes/classic/play.pngf = 0.;\n        for (int i = -5; i <= 5; i++) {\n            for (int j = -5; j <= 5; j++) {\n                sumDiff += length(fragColor.rgb - fetchDataFrom(iChannel0, fragCoord + vec2(i, j)).rgb);\n            }\n        }\n        fragColor.rgb = sumDiff > 15.6 * (iMouse.x / iResolution.x) ? \n            vec3(1.)\n            : fragColor.rgb;\n    }*/\n    \n    float b = length(color.rgb)/1.74;\n    //b += iTime * 0.1;\n    //fragColor.rgb = vec3(b*(1.-b)*b*(1.-b)*16.);\n    float t2 = (max(sin(.3*iTime + 0.001*\n     (sin(0.1*iTime+0.001*fragCoord.x)*pow(fragCoord.x, 1.1)\n    + cos(0.1*iTime+0.0015*fragCoord.x)*pow(fragCoord.y, 1.1))), 0.01));\n    //float factor = 20. + cos(t2)*40.;\n    float xOrYRatio = iResolution.x > iResolution.y ? fragCoord.x/iResolution.x : fragCoord.y/iResolution.y;\n    float factor = 60. * (1.-0.7*cos(1.1*(xOrYRatio-0.5)*PI));\n\n    vec2 focusPoint = iMouse.xy;\n    if (iMouse.z <= 0.) {\n        focusPoint = iResolution.xy * (vec2(0.5) + 0.3 * vec2(sin(iTime*.5), sin(iTime)));\n    }\n    factor += 15. * pow(1.-(length(focusPoint - fragCoord.xy)/length(iResolution.xy) - 0.5), .5);\n    \n    fragColor.rgb = palette[int(mod(b*factor + iTime*.0 , PALETTE_SIZE))];\n    /*fragColor.rgb = palettePermuted(\n        floor(mod(b*factor + iTime*0.05 , PALETTE_SIZE)),\n        floor(RGBtoHCV(color.rgb).x * 3.99)\n    );*/\n    \n    float t = sin(iTime);\n    if (mod(b*factor, 2.) < 1.) t = 1.-t;\n    //fragColor.rgb *= (1.-0.2*mod(b*factor, 1.)) * (1.-t) + (0.8 + 0.2*mod(b*factor, 1.)) * t;\n    //fragColor.rgb *= (0.6 + 0.4 * pow(dot(color.rgb, fragColor.rgb)/length(color.rgb)/length(fragColor.rgb), 1.0 + sin(iTime * 0.1)));\n    //fragColor.rgb *= color.r;\n    //vec3 mouseColor = fetchDataFrom(iChannel0, iMouse.xy).rgb;\n    //fragColor.rgb *= dot(color.rgb, mouseColor)/length(color.rgb)/length(mouseColor);\n    /*fragColor.rgb = palette[\n        fragColor.r > max(fragColor.g, 2. * fragColor.b) ? 4\n        : fragColor.r > max(fragColor.g, fragColor.b) ? 0\n        : fragColor.g > 2. * fragColor.b ? 1\n        : fragColor.g > fragColor.b ? 3\n        : 2];*/\n    //fragColor.rgb *= (1. - 10.*length(oldColor - color));\n    fragColor.rgb *= 1.8 - 0.6*(mod(b*factor + iTime*0.0, 2.));\n    //fragColor.rgb *= 1.3;\n    //fragColor *= 1.2;\n    //if (flipColor) fragColor.rgb = vec3(0.);\n    if (flipColor) fragColor.rgb *= 4.;\n\n    //if (iMouse.z > 0.) fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define fetchDataFrom(buf, addr) texelFetch(buf, ivec2(addr), 0)\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float PI = 3.14159265358979323846264338327950288;\n\nconst vec2 POSITION_ADDR = vec2(0, 0);\nconst vec2 BRUSH_AREA_FROM_TO_ADDR = vec2(0, 1);\nconst int WAIT_FRAMES = 100;\nconst float NEG_INFINITY = -1e400;\nconst float POS_INFINITY = 1e400;\n\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*376 + p.y*153213;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    const float EPSILON = 1e-10;\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 noise = vec4(mod(vec3(hash(ivec2(fragCoord*0.02)), hash(ivec2((fragCoord + 10.)*0.0199)), hash(ivec2((fragCoord+20.)*0.0198))), 1.0), 1.0);\n    if (iFrame <= WAIT_FRAMES) {\n        fragColor = noise;\n        return;\n    }\n    vec4 oldColor = fetchDataFrom(iChannel0, fragCoord);\n    if (iMouse.z > 0.) {\n        fragColor = oldColor;\n        return;\n    }\n    \n    vec4 bestColor = vec4(0, 0, 0, 1);\n    float bestFitness = NEG_INFINITY;\n    //float t = 0.09*iTime + 0.0001*fragCoord.x;\n    float t = (max(sin(1.*iTime + 0.001*\n         (sin(0.1*iTime+0.001*fragCoord.x)*pow(fragCoord.x, 1.1)\n        + cos(0.1*iTime+0.0015*fragCoord.x)*pow(fragCoord.y, 1.1))), 0.01));\n    t = 0.01*mod(iTime, 45.) + 0.1*iTime + 0.0001*fragCoord.x;\n    vec3 targetColor = max(vec3(sin(t), cos(t*1.62), sin(t*2.32)), vec3(-0.1));\n    //targetDistance = length(fragCoord)/length(iChannelResolution[0].xy)+length(iMouse.xy)/length(iChannelResolution[0].xy)*1.73;\n    for (int i = -15; i <= 5; i++) {\n        if (fragCoord.x + float(i) < 0. || fragCoord.x + float(i) >= iChannelResolution[0].x) continue;\n        for (int j = -5; j <= 5; j++) {\n            if (fragCoord.y + float(j) < 0. || fragCoord.y + float(j) >= iChannelResolution[0].y) continue;\n            vec4 c = fetchDataFrom(iChannel0, fragCoord + vec2(i, j));\n            float fitness = dot(targetColor, c.rgb)/length(c.rgb);\n            if (fitness > bestFitness) {\n                bestFitness = fitness;\n                bestColor = c;\n            }\n        }\n    }\n    fragColor = bestColor * 0.99 + noise * 0.01;\n    /*if (fragCoord.x < 10. && fragCoord.y < 10.) \n        fragColor.rgb = targetColor;*/\n    //fragColor.rgb = targetColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 oldColor = fetchDataFrom(iChannel1, fragCoord);\n    fragColor = fetchDataFrom(iChannel0, fragCoord);\n    fragColor = 0.5*fragColor + 0.5*oldColor;\n}","name":"Buffer B","description":"","type":"buffer"}]}