{"ver":"0.1","info":{"id":"ds3yD8","date":"1694983277","viewed":38,"name":"Strange Attractor Escape Map","username":"DigitalShadow","description":"Playing around with animating the coefficients for a quadratic strange attractor escape map","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["chaos","strangeattractor","escapemap"],"hasliked":0,"parentid":"ms3cDn","parentname":"Quadratic Strange Attractor Test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define itr 50\n#define maxL 10000.\n#define fade 0.1\n\n\nint iterate(vec2 p){\n    \n    //coefficients\n    float a1 =  -0.5 + 0.01 * sin(iTime);\n    float a2 =  -0.7 + 0.002 * cos(iTime * 3.);\n    float a3 =  -0.5 + 0.001 * sin(iTime * 5.);\n    float a4 =  0.1 + 0.001 * sin(iTime * 2.);\n    float a5 =  -0.8 + .5 * cos(iTime/3.);\n    float a6 =  0.2 + 0.002 * sin(iTime * 7.);\n    float a7 =  -0.9 + 0.01 * cos(iTime * 1.1);\n    float a8 =  0.9 + 0.005 * sin(iTime * 2.3);\n    float a9 =  0.10 + .001 * cos(iTime * 1.7);\n    float a10 = -0.3 + .5 * sin(iTime/5.);\n    float a11 = -1.5 + .5 * sin(iTime/7.);\n    float a12 = 0.3 + .2 * sin(iTime/11.);\n    \n    //optimize math\n    float x2, y2, xy;\n    \n    int i=0;\n    while (i < itr){\n        x2 = p.x * p.x;\n        y2 = p.y * p.y;\n        xy = p.x * p.y;\n        \n        //x = a1  + a2 *P.x + a3 *x2 + a4 *xy + a5 *P.y + a6 *y2;\n        //y = a7  + a8 *P.x + a9 *x2 + a10*xy + a11*P.y + a12*y2;\n        p = vec2(a1  + a2 *p.x + a3 *x2 + a4 *xy + a5 *p.y + a6 *y2, a7  + a8 *p.x + a9 *x2 + a10*xy + a11*p.y + a12*y2);\n        \n        if (length(p) > maxL) break;\n        i++;\n    }\n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //Measure how many iterations it takes to escape bounds\n    int i = iterate(uv*20.0 - 10.);\n    float t= float(i) / float(itr);\n  \n    //mix existing image and new to temporally smooth pixel values\n    vec3 ghost = texture(iChannel0, uv).rgb;\n    vec3 col = vec3(sqrt(t), t, t*0.5 + 0.5 * sin(30.0 * t));\n   \n    fragColor = vec4(col*fade + ghost*(1.0-fade),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}