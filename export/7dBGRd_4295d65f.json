{"ver":"0.1","info":{"id":"7dBGRd","date":"1618472192","viewed":83,"name":"316_volkov-rarog_v2v6","username":"artemvolkovrarog","description":"My homework","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float hash_val =  0.1031;\nconst vec3 CAMERA_POS = vec3(2, 2.3, -10);\nconst float INFIMUM =1e15;\nconst int recursive_depth = 10;\n\nconst float GLASS = 1.55;\nconst float AIR = 1.0;\nconst float WATER = 1.33;\n\n\nconst int EMISSION = 1;\nconst int DIFFUSAL = 2;\nconst int REFLECTIVE = 3;\nconst int REFRACTION = 4;\nconst int INSIDEOBJ = 5;\n\nconst float ABSORPTION = 0.06;\n\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;\nconst int MAX_STEPS = 64;\n\nvec3 RandomDirection;\n\nstruct LightSource{\n    vec3 coord;\n    vec4 color;\n    float radius;\n};\n\nstruct MyGeom{\n    vec3[5] vertices;\n    vec4 color;\n    float refraction_val;\n};\n\nvec3 reflection(vec3 dir, vec3 normal){\n    vec3 t = normal * dot(dir,normal);\n    return normalize(dir - 2.0*t);\n}\n\n\nconst int NumOfLights = 3;\nconst LightSource L1 = LightSource(vec3(0, 2.5, 0),vec4(1, 1, 1, 1), 0.5);\nconst LightSource L2 = LightSource(vec3(3.5, 2.5, -1),vec4(0, 1, 1, 1), 0.4 );\nconst LightSource L3 = LightSource(vec3(-3, 2.0, -2),vec4(1, 0.2, 0.2, 1), 0.4);\n\nconst LightSource S = LightSource(vec3(-2,1,-2 ), vec4(1,1,1,1), 0.6);\n\nLightSource[NumOfLights] LSS = LightSource[NumOfLights](L1, L2, L3);\nconst MyGeom MyObject = MyGeom(vec3[5](vec3(-1.0,0.0,-2.0), vec3(0.5, 0.0, -3.5), vec3(2.0, 0.0,-2.0), vec3(0.5, 0.0,-0.5), vec3(0.5, 2.5, -2.0)), vec4(1,1,1,1), GLASS);\nconst LightSource ObjectInside = LightSource(vec3(0.5, 0.7, -2.0), vec4(0,1,0,1), 0.5);\n\n\n\n\n\nfloat hash(vec3 p3)\n{\n\tp3 = fract(p3 *hash_val); \n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 fade(vec3 t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, vec3 p) \n{\n    int h = int(1e4*hash) & 15;\n\tfloat u = h<8 ? p.x : p.y,\n \t\t  v = h<4 ? p.y : h==12||h==14 ? p.x : p.z;\n    return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n}\n\nfloat perlinNoise3D(vec3 p)\n{\n\tvec3 pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix( mix( mix( grad(hash(pi + vec3(0, 0, 0)), pf - vec3(0, 0, 0)),\n                           grad(hash(pi + vec3(1, 0, 0)), pf - vec3(1, 0, 0)), w.x ),\n            \t      mix( grad(hash(pi + vec3(0, 1, 0)), pf - vec3(0, 1, 0)), \n                \t \t   grad(hash(pi + vec3(1, 1, 0)), pf - vec3(1, 1, 0)), w.x ), w.y ),\n        \t\t mix( mix( grad(hash(pi + vec3(0, 0, 1)), pf - vec3(0, 0, 1)), \n                \t\t   grad(hash(pi + vec3(1, 0, 1)), pf - vec3(1, 0, 1)), w.x ),\n            \t\t  mix( grad(hash(pi + vec3(0, 1, 1)), pf - vec3(0, 1, 1)), \n                \t\t   grad(hash(pi + vec3(1, 1, 1)), pf - vec3(1, 1, 1)), w.x ), w.y ), w.z );\n}\n\nfloat fbm(vec3 pos, int octaves, float persistence) \n{\n    float total = 0.0, frequency = 3.0, amplitude = 10.0, maxValue = 0.0;\n    for(int i = 0; i < octaves; ++i) \n    {\n        total += perlinNoise3D(pos * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return total / maxValue;\n}\n\nfloat getNoise(vec3 p)\n{\n    return 0.15 * fbm(p + 0.3*10.0, 16, 0.3);\n}\n\n\nfloat rand(float frame){\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\n\nvec3 refraction(vec3 dir, vec3 normal, float n_in, float n_out, out bool full_reflect){\n    if (dot(dir,normal) < 0.0) normal = -normal;\n    float COSA1 = dot(dir, normal);\n    float SINA1 = sqrt(1.0 - COSA1 * COSA1);\n    float SINA2 = SINA1 * n_in / n_out;\n  \n    if ((SINA2 >= 1.0)){\n    return reflection(dir, normal);\n    }\n    full_reflect = false;\n    \n    float COSA2 = sqrt(1.0 - SINA2 * SINA2);\n    vec3 tang = dir - normal * COSA1;\n    return tang * SINA2/SINA1 + normal * COSA2;\n    \n}\n\n\n\nfloat SphereDist(vec3 dir, float radius){\n    return length(dir) - radius;\n}\n\n\nvec2 NoisePos(vec3 pos, out bool refracted){\n    float res = SphereDist(pos - ObjectInside.coord, ObjectInside.radius);\n    if (res < 1e-5) refracted = true;\n    res += getNoise(pos);\n    return vec2(res,0.0);\n}\n\nvec3 GetNormal(in vec3 pos) \n{\n    bool s;\n    vec3 shift_x = vec3(0.01, 0.0, 0.0);\n    vec3 shift_y  = vec3(0.0, 0.01, 0.0);\n    vec3 shift_z = vec3(0.0, 0.0, 0.01);\n    float grX = NoisePos(pos + shift_x, s).x - NoisePos(pos - shift_x, s).x;\n    float grY = NoisePos(pos + shift_y, s).x - NoisePos(pos - shift_y, s).x;\n    float grZ = NoisePos(pos + shift_z, s).x - NoisePos(pos - shift_z, s).x;\n    vec3 normal = vec3(grX, grY, grZ);\n    return normalize(normal);\n}\n\n\nvec2 Marching(vec3 pos, vec3 dir)\n{\n    const float MARCHING_LIMIT = 30.0;\n    const int MARCHING_STEPS = 64;\n    bool refracted = false, to_refract = false;\n    bool s = true;\n    float total_distance = 0.0, miss = -1.0;\n    for (int i = 0; i < MARCHING_STEPS; ++i) {\n        vec2 rm = NoisePos(pos + total_distance * dir, to_refract);\n        if (!refracted && to_refract){\n        vec3 norm = GetNormal(pos + dir * total_distance);\n        dir = refraction(dir, norm, AIR,WATER, s);\n        refracted = !refracted;\n        }\n        float minHitDistance = 0.00005 * total_distance;\n        if (rm.x < minHitDistance) {\n            miss = rm.y; break; \n        }\n        if (total_distance > MARCHING_LIMIT) break;\n        total_distance += rm.x;\n    }\n    \n\treturn vec2(total_distance, miss);\n}\n\nvec3 TraceObj(out vec3 pos, out vec3 dir, out bool nice)\n{\n    vec2 rm = Marching(pos, dir);\n    int miss = int(rm.y);\n    bool s = true;\n    if (miss >= 0) {\n        vec3 pos = pos + dir*rm.x;\n        vec3 norm = GetNormal(pos);\n\t\tdir = refraction(dir, norm, WATER,AIR, s);\n        nice = true;\n        vec3 col =  pow(texture(iChannel3, dir.xy).rgb,vec3(2.2))* exp(-ABSORPTION*rm.x) * vec3(0.1, 0.1, 1.0);\n        col = pow(col, vec3(0.3));\n        return col;\n    }\n    \n    return vec3(0.0,0.0,0.0);\n}\n\n\nfloat intersect_triangle(vec3 v0, vec3 v1, vec3 v2, vec3 pos, vec3 dir, out vec3 normal){\n    \n    vec3 e1 = v1 - v2;\n    vec3 e2 = v1 - v0;\n    vec3 f = v1 - pos;\n    mat3 matrix = mat3(dir, e1, e2);\n    if (abs(determinant(matrix)) < 1e-5) return INFIMUM;\n    else matrix = inverse(matrix);\n    vec3 tuv = matrix * f;\n    if (tuv.y < 0.0 || tuv.z < 0.0 || (tuv.y + tuv.z) > 1.0 || tuv.y > 1.0 || tuv.z > 1.0) return INFIMUM;\n    normal = -normalize(cross(e1,e2));\n    return tuv.x; \n}\n\nfloat get_intersection(vec3 v0, vec3 v1, vec3 v2, vec3 pos, vec3 dir, out vec3 normal, float t_old){\n    vec3 normal1 = normal;\n    float temp = intersect_triangle(v0, v1, v2, pos, dir, normal);\n    \n    if (temp < t_old && temp > 0.0) {\n        return temp;\n    }\n    else {\n    normal = normal1;\n    return t_old;\n    }\n}\n\n\n\nfloat TraceGeometry(vec3 CAM_POS, vec3 VV, out vec3 normal){\n    float t = INFIMUM;\n    MyGeom obj = MyObject;\n    for (int i = 0; i < 4; ++i)\n    {\n        t = get_intersection(obj.vertices[i%4], obj.vertices[4], obj.vertices[(i + 1)%4], CAM_POS, VV, normal, t);\n    }\n\n    t = get_intersection(obj.vertices[1], obj.vertices[2], obj.vertices[3], CAM_POS, VV, normal, t);\n    t = get_intersection(obj.vertices[3], obj.vertices[0], obj.vertices[1], CAM_POS, VV, normal, t);\n    return t;\n    \n}\n\n\n\n\n\nvec3 get_view(vec2 fragCoord, vec3 pos, vec3 rand){\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (rand.xy - 0.5)*2.5)/iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 ViewVec = normalize(vec3(front + up * uv.y - right*uv.x));\n    return ViewVec;\n}\n\n\n\n\nfloat TracePlane(vec3 cpos, vec3 view){\n    float t = (-0.3 - cpos.y) / view.y;\n    if (t < 0.0){\n        return INFIMUM;\n    }\n    vec3 wp = cpos + t*view;\n    if (dot(wp.xz, wp.xz) < 100.0){\n    return t;\n    }\n    else{\n        return INFIMUM;\n    }\n}\n\nfloat TraceSphere(vec3 diam, vec3 viewVec, float R){\n    float b = dot(viewVec, diam);\n    float c = dot(diam, diam) - R*R;\n    float D = b*b - c;\n    if (D < 0.0){\n        return INFIMUM;\n    }\n    float t = b - sqrt(D);\n    if (t < 0.0){\n        t = b + sqrt(D);\n    }\n    if (t < 0.0){\n        return INFIMUM;\n    }\n    else {\n        return t;\n    }\n}\n\nfloat TraceStand(vec3 pos, vec3 dir, out vec3 normal){\n \n    vec3 shiftx = vec3(0.5, 0.0,0.0), shifty_vert = vec3(0,0.005,0), shifty = vec3(0,0.295, 0), shiftz = vec3(0,0,0.5);\n    vec3 v0 = MyObject.vertices[0] - shiftx - shifty_vert, v1 = MyObject.vertices[1] - shiftz - shifty_vert,\n    v2 = MyObject.vertices[2] + shiftx - shifty_vert, v3 = MyObject.vertices[3] + shiftz - shifty_vert;\n    vec3 v01 = v0 - shifty, v11 = v1 - shifty, v21 = v2 - shifty, v31 = v3 - shifty;\n    float t = INFIMUM;\n    \n    t = get_intersection(v0, v1, v2, pos, dir, normal, t);\n    t = get_intersection(v0, v2, v3, pos, dir, normal, t);\n    t = get_intersection(v01, v0, v1, pos, dir, normal, t);\n    t = get_intersection(v01, v1, v11, pos, dir, normal, t);\n    t = get_intersection(v11, v1, v2, pos, dir, normal, t);\n    t = get_intersection(v11, v2, v21, pos, dir, normal, t);\n    t = get_intersection(v21, v2, v3, pos, dir, normal, t);\n    t = get_intersection(v21, v3, v31, pos, dir, normal, t);\n    t = get_intersection(v31, v3, v0, pos, dir, normal, t);\n    t = get_intersection(v01, v0, v31, pos, dir, normal, t);\n    t = get_intersection(v11, v21, v31, pos, dir, normal, t);\n    t = get_intersection(v11, v31, v01, pos, dir, normal, t);\n    \n    return t;\n}\n\nbool Occlusion(vec3 pos, LightSource LSS){\n    vec3 normal;\n    vec3 dir = LSS.coord + RandomDirection*LSS.radius - pos;\n    pos += dir*1e-6;\n    float TraceLight = TraceSphere(dir, dir, LSS.radius);\n    float t = TracePlane(pos, dir);\n    if (t < TraceLight) return true;\n    t = TraceStand(pos,dir, normal);\n    if (t < TraceLight) return true;\n    t = TraceGeometry(pos, dir, normal);\n    if (t < TraceLight) return true;\n    return false;\n    \n}\n\nvec4 LightCalculate(vec3 WorldPos, vec3 normal){\n    vec4 LightTotal = vec4(0, 0, 0, 0);\n    float[NumOfLights] Pars = float[NumOfLights](45.0, 40.0, 30.0);\n    for (int i = 0; i < NumOfLights; i++){\n      vec3 PtoC = LSS[i].coord - WorldPos;\n      float att = Occlusion(WorldPos, LSS[i])? 0.0 : Pars[i] / dot(PtoC, PtoC);\n      LightTotal += max(0.0, dot(normal, normalize(PtoC))) * att * LSS[i].color;  \n    }\n    LightTotal += texture(iChannel1, normal)*0.1;\n    return LightTotal;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 RandVec = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 10)));\n    RandomDirection = normalize(RandVec - 0.5);\n    vec3 ViewVec = get_view(fragCoord, CAMERA_POS, RandVec);\n    vec3 CurPos = CAMERA_POS;\n    vec3 CurDir = ViewVec;\n    float n1 = AIR;\n    float n2 = GLASS;\n    bool full_reflect = false;\n    vec4 color;\n    vec3 Color_mix;\n    bool nice = false;\n    bool water = false;\n    \n    for (int i = 0; i < 20; i++){\n    int MaterialType;\n    float t = INFIMUM;\n    vec3 normal1;\n    vec3 normal;\n    vec3 WorldPos;\n    float R = (n1 - n2)*(n1 - n2)/(n1 + n2)/(n1+n2);\n    bool internal = false;\n    \n    float planeT = TracePlane(CurPos, CurDir);\n    if (planeT < t){\n        if (RandVec.y < 0.4) MaterialType = REFLECTIVE; \n        else MaterialType = DIFFUSAL;\n        t = planeT;\n        WorldPos = t*CurDir + CurPos;\n        color =texture(iChannel0, WorldPos.xz * 0.1);\n        normal = vec3(0,1,0);\n    }\n    for (int j = 0; j < NumOfLights; j++){\n        float LightT = TraceSphere(LSS[j].coord - CurPos, CurDir, LSS[j].radius);\n        if (LightT < t){\n            MaterialType = EMISSION;\n            t = LightT;\n            color = LSS[j].color;\n            normal = normalize(LSS[j].coord - CurPos);\n        }\n    }\n    \n    float StandT = TraceStand(CurPos,CurDir, normal1);\n    if(StandT < t){\n        if (RandVec.y < 0.5) MaterialType = DIFFUSAL;\n        else MaterialType = REFLECTIVE;\n        t = StandT;\n        WorldPos = CurPos + CurDir * t;\n        color = texture(iChannel2, (WorldPos.xz + WorldPos.xy)*0.2);\n        normal = normal1; \n    }\n    \n    float GeometryT = TraceGeometry(CurPos, CurDir, normal1);\n    if (GeometryT < t){\n        if (RandVec.x*0.1 < R) MaterialType = REFLECTIVE;\n        else  MaterialType = REFRACTION;\n        t = GeometryT;\n        color = MyObject.color;\n        normal = normal1;\n    }\n    if (t < INFIMUM){\n        WorldPos = CurPos + t*CurDir;\n        if (MaterialType == EMISSION){ \n            fragColor = color;\n            if (nice) fragColor += vec4(Color_mix,1);\n        }\n        else if (MaterialType == DIFFUSAL){\n            vec4 calc_light = LightCalculate(WorldPos, normal);\n            fragColor = color * calc_light;\n            if (nice) fragColor += vec4(Color_mix, 1);\n            \n        }\n        else if (MaterialType == REFLECTIVE){\n            CurDir = reflection(CurDir, normal);\n            CurPos = WorldPos + 1e-6 * CurDir;\n        }\n        else if (MaterialType == REFRACTION){\n            CurDir = refraction(CurDir, normal, n1, n2, full_reflect);\n            if (!(full_reflect)){\n                float tmp = n1;\n                n1 = n2; \n                n2 = tmp;\n                full_reflect = !(full_reflect);\n            }\n            CurPos = WorldPos + 1e-6 * CurDir; \n            if (RandVec.z < 0.6) Color_mix += TraceObj(CurPos, CurDir, nice);\n        }\n    }\n        else {\n            fragColor = texture(iChannel1, CurDir) * 0.3;\n            if (nice) fragColor += vec4(Color_mix, 1);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) + texture(iChannel1, screenUV);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 color = vec3(.71, .65, .6);\nvec3 blue = vec3(0.18, 0.47, .84);\nvec3 red = vec3(1., 0., 0.);\nvec3 white = vec3(1., 1., 1.);\nvec3 lightblue = vec3(.36, .60, .88);\nvec3 yellow = vec3(1., 1., 0.);\nvec3 blue2 = vec3(0., 0., .63);\n\n#define PATTERN 1\n\n\n#define PI 3.141592\n#define TWO_PI 6.2831\n\nfloat random (in vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat createCircle(vec2 uv, vec2 center, float radius)\n{\n    float circle = step(distance(center,uv), radius);\n    return circle;\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat rectangle(vec2 uv, vec2 position, vec2 size)\n{\n    float leftSide = position.x;\n    float rightSide = position.x + size.x;\n    float bottom = position.y;\n    float top = position.y + size.y;\n    \n    float rect = step(leftSide, uv.x) - step(rightSide, uv.x); \n    float rect2 = step(bottom, uv.y) - step(top, uv.y);\n    \n    return (rect * rect2);\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\nfloat galaxy (in vec2 uv) {\n    float layer1 = step(.99, random(uv)) * (sin(iTime) + 1.) / 2.;\n    layer1  += step(.995, random(uv));\n   \treturn layer1;\n}\n\n\n\n#if PATTERN == 1\n//Wood\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec3 value = vec3(0.860, 0.806, 0.574);\n    \n    float planks;\n    planks = abs(sin(uv.x*10.));\n    value *= planks;\n    \n    vec3 colorA = vec3(0.);\n    value = mix(value, colorA, vec3(fbm(uv.xx * 10.)));  \n   \t\n   \tvalue = mix(value, vec3(0.390, 0.265, 0.192), vec3(fbm(uv.xx*22.)));\n    value = mix(value, vec3(0.930, 0.493, 0.502), random(uv.xx)*.1);\n    value -= (noise(uv*vec2(500., 14.) - noise(uv*vec2(1000., 64.))) * 0.1);\n    \n    fragColor = vec4(vec3(value) , 1.0);\n}\n\n//Lava\n#elif PATTERN == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n   \tuv += iTime/100.;\n\tfloat brightness = 1.7;\n    yellow *= brightness;\n    vec3 color = mix(yellow, red,vec3(fbm(uv*15.)*1.3));\n    fragColor = vec4(vec3(color),1.0);\n}\n\n#elif PATTERN == 3\n//Scottish\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec3 value = vec3(1., 0., 0.);\n    \n    float planks;\n    planks = abs(sin(uv.x*20.) +.5 );\n    value *= planks;\n    \n    vec3 colorA = vec3(0.);\n    value = mix(value, colorA, vec3(fbm(uv.yy * 50.)));  \n   \t\n   \tvalue = mix(value, vec3(0.390, 0.265, 0.192), vec3(fbm(uv.xx*22.)));\n    value = mix(value, vec3(0.930, 0.493, 0.502), random(uv.xx)*.1);\n    value -= (noise(uv*vec2(500., 14.) - noise(uv*vec2(1000., 64.))) * 0.1);\n    \n    fragColor = vec4(vec3(value) , 1.0);\n}\n\n\n#elif PATTERN == 4\n//Galaxy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 clouds = mix(blue,vec3(0.),vec3(fbm(uv*10.)*2.));\n    fragColor = vec4(vec3(galaxy(uv) + clouds), 1.0);\n}\n\n//Moon\n#elif PATTERN == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float ratio = iResolution.x / iResolution.y;\n   \tuv.x *= ratio;\n  \n\tvec3 circle = vec3(createCircle(uv, vec2(0.5 * ratio, -0.6), .99));\n    vec3 color = mix(vec3(0.07,  0.1, .25), vec3(1.),vec3(fbm(uv*15.)*1.3));\n\tcircle *= color;\n    \n    vec3 blue = vec3(0.07,  0.1, .25);\n    vec3 clouds = mix(blue,vec3(0.),vec3(fbm(uv*10.)*2.)); \n    vec3 stars = vec3(galaxy(uv) + clouds);\n    \n    vec3 circle2 = vec3(createCircle(uv, vec2(0.5 * ratio, 0.5), .1)) * blue;\n    \n    if(circle.x == 0.){\n    \tfragColor = vec4(vec3(stars) , 1.0);\n    }\n    else {\n        fragColor = vec4(vec3(circle), 1.0);\n    }\n}\n\n//Rain\n#elif PATTERN == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.y *= -ratio;\n\t\n    float value = 0.;\n    float idy = floor(uv.x * 200.);\n    float r = random(vec2(idy));\n    float speed = fract(iTime * 2. * r );\n    uv.y += r - speed;\n    uv.y = fract(uv.y);\n    \n    value = step(0.14 * r, uv.y) - step(.17 *r, uv.y);\n    fragColor = vec4(vec3(lightblue - (value * white)), 1.);\n}\n\n//Clouds\n#elif PATTERN == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv /= 2.;\n   \tuv += iTime / 100.;\n\tvec3 clouds = mix(blue,vec3(.8, .86, .91),vec3(fbm(uv*10.)*1.));\n    fragColor = vec4(vec3(clouds),1.0);\n}\n\n//Granite\n#elif PATTERN == 8\n//https://2.imimg.com/data2/TS/UE/MY-2957688/black-granite-250x250.jpg\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 clouds = mix(vec3(1.),vec3(0.),vec3(fbm(uv*50.)*2.5));\n    fragColor = vec4(vec3(clouds),1.0);\n}\n#endif","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 Grayscale(vec4 Texture) {\n    \n\tfloat Median = (Texture.r * 0.2126) + (Texture.g * 0.7152) + (Texture.b * 0.0722);\n    \n    return vec4(vec3(Median), 1.0);\n    \n}\n\nvec2 RotateUV(vec2 UV, float Angle) {\n    \n   UV -= 0.5;\n    \n   float XMod = (UV.x * cos(Angle)) - (UV.y * sin(Angle));\n   float YMod = (UV.x * sin(Angle)) + (UV.y * cos(Angle));\n    \n   vec2 NewUV = vec2(XMod, YMod);\n    \n   NewUV += 0.5;\n    \n   return NewUV;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 UV = fragCoord.xy / iResolution.xy;\n    vec2 StretchUV = UV;\n    \n    StretchUV = RotateUV(StretchUV, -45.0);\n    \n    UV *= 1.0 + (sin((StretchUV.x * 3.141592) + (iTime * 2.0)) * 0.05);\n    \n    float WavingSpeed = 0.25;\n    \n    UV.y += sin((UV.x * 3.141592) + (iTime * WavingSpeed)) * 0.05;\n    UV.x += cos((UV.y * 3.141592) + (iTime * WavingSpeed)) * 0.025;\n    \n    vec2 FoamUV = UV;\n    FoamUV += iTime / 12.0;\n    \n    vec2 ShallowUV = UV;\n    ShallowUV += iTime / 16.0;\n    \n    vec2 OceanUV = UV;\n    OceanUV += iTime / 24.0;\n    \n    vec2 DeepUV = UV;\n    DeepUV += iTime / 32.0;\n    \n    float TimeSpeed = 2.0;\n    \n    float DeepSpeedMod = 3.0;\n    float OceanSpeedMod = 2.0;\n    float ShallowSpeedMod = 2.0;\n    float FoamSpeedMod = 4.0;\n    \n    float DeepMaskMod = 0.4 + (abs(sin(iTime / (TimeSpeed * DeepSpeedMod))) * 0.2);\n    float OceanMaskMod = 0.5 - (abs(sin(iTime / (TimeSpeed * OceanSpeedMod))) * 0.1);\n    float ShallowMaskMod = 0.3 + (abs(sin(iTime / (TimeSpeed * ShallowSpeedMod))) * 0.2);\n    float FoamMaskMod = 0.6 + (abs(sin(iTime / (TimeSpeed * FoamSpeedMod))) * 0.1);\n    \n    vec3 OceanDeepMask = step(DeepMaskMod, Grayscale(texture(iChannel1, DeepUV))).rgb;\n    vec3 OceanMask = step(OceanMaskMod, Grayscale(texture(iChannel2, OceanUV))).rgb;\n    vec3 OceanShallowMask = step(ShallowMaskMod, Grayscale(texture(iChannel0, ShallowUV))).rgb;\n    vec3 FoamMask = step(FoamMaskMod, Grayscale(texture(iChannel3, FoamUV))).rgb;\n    \n    vec3 OceanBottomColor = vec3(0.0, 0.1, 0.3);\n    vec3 OceanDeepColor = vec3(0.0, 0.2, 0.5) * OceanDeepMask;\n    vec3 OceanColor = vec3(0.2, 0.3, 0.75) * OceanMask;\n    vec3 OceanShallowColor = vec3(0.5, 0.75, 1.0) * OceanShallowMask;\n    vec3 WaterFoam = vec3(0.8, 0.9, 0.9) * FoamMask;\n    \n    vec3 Color = OceanBottomColor * (1.0 - OceanDeepMask);\n    Color += OceanDeepColor;\n    \n    Color = Color * (1.0 - OceanMask);\n    Color += OceanColor;\n    \n    Color = Color * (1.0 - OceanShallowMask);\n    Color += OceanShallowColor;\n    \n    Color = Color * (1.0 - FoamMask);\n    Color += WaterFoam;\n    \n    fragColor = vec4(Color, 1.0);\n    \n}\n","name":"Buffer D","description":"","type":"buffer"}]}