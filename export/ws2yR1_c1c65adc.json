{"ver":"0.1","info":{"id":"ws2yR1","date":"1586128262","viewed":80,"name":"CG lab 3  Ellipsoid ","username":"pgkg","description":"simple Ellipsoid ray tracer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ellipsoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Макаров И 4.2 \n//поворот в радианах\n#define ellipsoidRotationAlongX 3.1415/4.0\n#define ellipsoidRotationAlongY 3.1415\n#define ellipsoidRotationAlongZ 3.1415\n//полуоси \n#define ellipsoidSizeX 2.0\n#define ellipsoidSizeY 1.0\n#define ellipsoidSizeZ 1.0\n//точность (т.к. используются ЧМ, то возможна нехватка производительности)\n#define numberOfIteration 50\n\n//rotation matrix reference - https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\nbool pointInsideEllipsoid(vec3 point, vec3 center)\n{\n    float a = ellipsoidSizeX;\n    float b = ellipsoidSizeY;\n    float c = ellipsoidSizeZ;\n    point = rotate(point, vec3(0.0, 0.0, 1.0), ellipsoidRotationAlongX);\n    point = rotate(point, vec3(0.0, 1.0, 0.0), ellipsoidRotationAlongY);\n    point = rotate(point, vec3(1.0, 0.0, 0.0), ellipsoidRotationAlongZ);\n\tif(pow(point.x, 2.0) / pow(a, 2.0) + pow(point.y, 2.0) / pow(b, 2.0) + pow(point.z, 2.0) / pow(c, 2.0) <= 1.0)\n    {\n\t\treturn true;\n    } else {\n     \treturn false;   \n    }\n}\n\nfloat sic(vec3 ro, vec3 rd, vec3 so, float r)\n{\n\tconst int nos = numberOfIteration;\n    float d = 0.0;\n    vec3 cd = so - ro;\n\tfloat stepSize = (sqrt((pow(length(so - ro), 2.0)) + (r * r)) / float(nos));\n    for(int i = 0; i < nos; i++)\n    {\n\t\td = d + stepSize;\n        if(pointInsideEllipsoid(ro + rd * d, so) == true)\n        {\n\t\t\treturn d;\n        }\n    }\n    return -1.0;\n}\n//background function reference - https://www.shadertoy.com/view/ldS3DW#\nvec3 background(float t, vec3 rd, vec3 sunPos)\n{\n\tvec3 light = normalize(sunPos);\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //нормализуем координаты от -1 до 1 \n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    //нормализуем кординаты клика мыши\n    vec2 nmc = (-1.0 + 2.0*iMouse.zw / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    vec2 nmd = (-1.0 + 2.0*iMouse.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    //позиция камеры и ray origin\n    vec3 cameraPos = rotate(vec3(nmd.x * 1.0, nmd.y * 1.0, -5.0), vec3(0.0, 1.0, 0.0), mod(iTime, 6.283));\n    //позиция экрана и ray direction\n    vec3 pixelGridPos = rotate(normalize(vec3(uv, 1)), vec3(0.0, 1.0, 0.0), mod(iTime, 6.283));\n    vec3 spherePos = vec3(0.0, 0.0, 0.0);\n    vec3 sunPos = vec3(2.0, 3.0, -5.0);\n    float id = sic(cameraPos, pixelGridPos, spherePos, 1.0); //intersection distance -1 если не пересекает\n    vec3 hp = cameraPos + pixelGridPos * sic(cameraPos, pixelGridPos, spherePos, 1.0); //точка пересечения\n    if(id < -0.00001)\n    {\n\t\tfragColor = vec4(background(id, pixelGridPos, sunPos), 1.0);\n    } else {\n        vec3 reflectDir = normalize(hp - spherePos);\n        float dotSign = dot(hp - spherePos, sunPos - hp);\n        if(dotSign >= 0.0)\n        {\n            float angle = (3.1415 - acos(dot(hp - spherePos, sunPos - hp)/length(hp - spherePos) / length(sunPos - hp)))/3.1415;\n        \tfragColor = vec4(vec3(1.0, 1.0, 1.0) * angle, 1.0); \n        } else {\n            fragColor = vec4(vec3(1.0, 1.0, 1.0) * 0.5 , 1.0);\n        }\n        \n         \n    }\n    \n}","name":"Image","description":"","type":"image"}]}