{"ver":"0.1","info":{"id":"3tyfWy","date":"1615237470","viewed":416,"name":"Spherify UVs Solar system","username":"nebbul","description":"The planets of our solar system orbits the Sun (Ceres included!)\n\nThe orbit speeds should be fairly matching, but the other params are not accurate\n\nThe planets can be seen like sprites that has been \"spherified\". Check the debug render layers!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sun","uv","sphere","solar","system"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// spheriphy idea comes from twitter\n// https://twitter.com/bgolus/status/1233279164947451909\n//\n// check my other shader what Spherify actually is\n// TLDR: it's bending a flat plane to a sphere\n// \n// https://www.shadertoy.com/view/3lGfWy\n\n// some global variables\n#define LAYER_DISPLAY 0\n#define GLOBAL_SPEED 0.05\n#define GLOBAL_ORBIT_SPEED 3.\n#define GLOBAL_ROT_SPEED 0.6\n#define GLOBAL_ORBIT_RING 0 // this is quite expensive\n#define GLOBAL_ORBIT_SUBDIVISIONS 300.\n#define GLOBAL_ORBIT_SIZE 0.002\n#define PI     3.14159265f\n\n// global functions\n// rotate a 2d vector\nvec2 Rotate2dVector(vec2 v, vec2 a) {\n\treturn vec2(a.x*v.x - a.y*v.y, a.y*v.x + a.x*v.y);\n}\n\n// remap a range\nfloat remap(float x, float in_min, float in_max, float out_min, float out_max)\n{\n    return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);\n}\n\n// remap from whatever to 0-1\nfloat remap01(float x, float in_min, float in_max)\n{\n    return (x - in_min) / (in_max - in_min);\n}\n\n// \nstruct Layers\n{\n    float mask;\n    float depth;\n    vec2 uv;\n    vec3 normals;\n};\n// stars method from: https://www.shadertoy.com/view/XltSz7\nvec3 star(vec3 star, vec2 coord)\n{\n    vec3 color = fract(star) * .4 + .6;\n    \n    float intensity = star.x * star.y ;\n    intensity = 2. * (fract(intensity) + .1) * (sin(iTime + intensity) + 1. / 2.);\n    \n    float z = pow(star.z, 5.); // z paralax amount\n    \n    star.xy += z * (.5 * iResolution.xy - iMouse.xy);\n    float size = distance(coord, star.xy);\n    size *= 0.2; // max size\n    size /= max(.2, z); // min size\n    size = max(0., 1. - size);\n    \n    return vec3(size * intensity * color);\n}\n\n// colors using IQ method\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n// pick a color based on index\nvec3 getClr(vec2 uv, vec2 clip, int clrIndex) {\n    float p = smoothstep(clip.x, clip.y, texture(iChannel0, uv).x);\n    if(clrIndex == 0) return 1.3 * pal( p, vec3(0.5,0.6585,0.3984),vec3(0.5,0.3384,0.9784),vec3(-0.151,0.3984,.5284),vec3(0.,0.,0.15) );           // sun\n    if(clrIndex == 1) return pal( p, vec3(0.5,0.6,0.6),vec3(0.3,.09,0.03),vec3(0.1,0.36,-0.49),vec3(0.,0.,0.) );                 // ceres\n    if(clrIndex == 2) return pal( p, vec3(0.5,0.4,0.),vec3(0.2,.05,0.),vec3(0.1,0.5,0.),vec3(0.,0.,0.) );                        // mercury\n    if(clrIndex == 3) return pal( p, vec3(0.68,0.96,0.82),vec3(0.5,.09,0.03),vec3(0.1,0.36,-0.49),vec3(0.,0.,0.) );              // venus\n    if(clrIndex == 4) return pal( p, vec3(0.35,0.73,0.5),vec3(.12,.08,0.63),vec3(0.44,0.86,0.35),vec3(0.16,0.03,1.05) );       // earth\n    if(clrIndex == 5) return pal( p, vec3(0.5,0.4,0.),vec3(0.5,.1,0.),vec3(0.1,0.5,0.),vec3(0.,0.,0.) );                         // mars\n    if(clrIndex == 6) return pal( p, vec3(0.82,0.7,0.15),vec3(0.16,0.20,-.4),vec3(0.52,0.27,0.35),vec3(2.97,1.18,4.39) );        // jupiter\n    if(clrIndex == 7) return pal( p, vec3(0.73,0.78,0.35),vec3(0.16,0.20,-.4),vec3(0.52,0.27,0.35),vec3(2.97,1.18,4.39) );       // saturn\n    if(clrIndex == 8) return pal( p, vec3(0.0,0.9,0.9),vec3(0.0,0.1,.1),vec3(0.,0.5,0.33),vec3(0.,0.5,0.66) );                   // uranus\n    if(clrIndex == 9) return pal( p, vec3(0.0,0.55,0.73),vec3(0.0,0.12,.25),vec3(0.,0.5,0.33),vec3(0.,0.5,0.66) );               // neptune\n    if(clrIndex == 10) return pal( p, vec3(0.5,0.6,0.6),vec3(0.3,.09,0.03),vec3(0.1,0.36,-0.49),vec3(0.,0.,0.) );                // pluto\n}\n\n// animate planet UVs\nvec2 planet_uv_scroll(vec2 uv_in, vec2 uv_scale, vec2 uv_scroll_speed, vec2 mouseMovement)\n{\n    vec2 scale = (1. / uv_scale);\n    \n    vec2 uv_mouse = vec2(-mouseMovement.x, -mouseMovement.y) * .1;\n    vec2 uv = (uv_in + uv_mouse) * scale;\n\n    return uv + (24. * iTime * uv_scroll_speed * GLOBAL_SPEED * GLOBAL_ROT_SPEED * scale / PI);\n}\n\n// get coordinates for the planet\nvec3 getPos(float orbitDistance, float orbitSpeed, float timeOffset, vec2 mMovement)\n{\n    float centerx = 0.5 * iResolution.x / iResolution.y;\n    float centery = 0.5 * iResolution.y / iResolution.y;\n    \n    float mOffset = (mMovement.x * 0.5);\n    \n    float x = centerx + sin(iTime * orbitSpeed * GLOBAL_SPEED * GLOBAL_ORBIT_SPEED + mOffset + timeOffset) * orbitDistance;\n    float z = cos(iTime * orbitSpeed * GLOBAL_SPEED * GLOBAL_ORBIT_SPEED + mOffset + timeOffset) * orbitDistance * orbitDistance;\n    float y = centery - ( (z / (orbitDistance * 2.)) * -clamp(mMovement.y, -iResolution.y, 0.) ) - (z / (orbitDistance * 2.))*0.3;\n    return vec3(x,y,z);\n}\n\n// make planet layers\nLayers planet(vec2 in_uv, float rad, vec3 pos, vec2 mask_smoothness) {\n    vec2 uv_pos = vec2(pos.x, pos.y);\n    float depth = pos.z;\n    \n    vec2 uv = (((in_uv - 0.5) * 2.) + uv_pos) * 1. / rad;\n    uv = (in_uv - uv_pos) * 1. / rad;\n\n    float d = sqrt(1.-clamp(dot(uv, uv), 0., 1.));\n    vec3 normals = vec3(uv, d);\n\n    vec2 q = (vec2(d, d) + vec2(1.,1.));\n    \n    uv /= q;\n\n    float mask = smoothstep(mask_smoothness.x, mask_smoothness.y, d);\n\n    return Layers(mask, depth, uv, normals);\n}\n\n// make ring layers - for saturn and uranus\nLayers rings(vec2 in_uv, float rad, vec3 pos, vec3 phases, float opacity, float angle, float squash) {\n    vec2 in_uv_rot = in_uv;\n\n    in_uv_rot = Rotate2dVector(in_uv_rot, vec2(cos(angle),sin(angle)));\n    \n    vec2 uv_pos = vec2(pos.x, pos.y);\n    uv_pos = Rotate2dVector(uv_pos, vec2(cos(angle),sin(angle)));\n    \n    vec2 uv = (((in_uv_rot - 0.5) * 2.) + uv_pos) * 1. / rad;\n    uv = (in_uv_rot - uv_pos) * 1. / rad;\n\n    uv.y *= squash; // squash the ring\n    \n    float depth = pos.z;\n    depth -= uv.y * 0.1;\n    \n    float d = sqrt(1.-clamp(dot(uv, uv), 0., 1.));\n\n    vec3 normals = vec3(Rotate2dVector(uv, vec2(cos(-angle),sin(-angle))), d);\n\n    vec2 q = (vec2(d, d) + vec2(1.,1.));\n    \n    uv /= q;\n    \n    // polar coordinates with an offset to hide seam behind planet\n    uv.y = mod(remap(atan(uv.y, uv.x), -PI, PI, 0., 1.) + 0.25, 1.);\n    uv.x = d;\n\n    float thickness = 0.8;\n    vec2 soft = mix(vec2(0., 0.5), vec2(0.4, 0.5), 0.);\n    float mask = smoothstep(soft.x, soft.y, d) - smoothstep(thickness - 0.05, thickness + 0.05, d);\n    \n    // stack some nice lines on the rings\n    float scroll = iTime * 0.4;\n    float rings = 1.;\n    rings *= smoothstep(0., .5, remap01(sin(d * phases.x + scroll * 0.8), -1., 1.));\n    rings *= smoothstep(0.2, 1., remap01(sin(d * phases.y + scroll), -1., 1.));\n    rings *= smoothstep(0.1, .8, remap01(sin(d * phases.z + scroll * 1.2), -1., 1.));\n    rings = smoothstep(0., 0.2, rings);\n    rings = remap(rings, 0., 1., 0.9, 1.1);\n    \n    mask *= rings;\n    mask *= opacity;\n\n    return Layers(mask, depth, uv, normals);\n}\n\n// draw planet to layers \nvoid MakePlanet(vec2 in_uv, float orbit_speed, float t_offset, float radius, float dist, float rot_speed, vec2 uv_scale, vec2 mMovement, int clrIndex, vec2 clrClip, inout float mask, inout float depth, inout vec3 normals, inout vec3 clr, inout vec2 uv)\n{\n    vec3 myPos = getPos(dist, orbit_speed, t_offset, mMovement);\n    \n    Layers myPlanet = planet(in_uv, radius, myPos, vec2(0., 0.2));\n    float mask_planet = mix(0., 1., depth < myPlanet.depth ? 1. : 0.) * myPlanet.mask;\n    mask = mix(mask, 1., mask_planet);\n    depth = mix(depth, myPlanet.depth, mask_planet);\n    vec2 planet_uv = planet_uv_scroll(myPlanet.uv, uv_scale, vec2(rot_speed, 0.), mMovement);\n    uv = mix(uv, planet_uv, mask_planet);\n    clr = mix(clr, getClr(planet_uv, clrClip, clrIndex), mask_planet);\n    normals = mix(normals, myPlanet.normals, mask_planet);\n    \n    // orbit ring\n    #if GLOBAL_ORBIT_RING\n    float planet_orbit_count = dist * GLOBAL_ORBIT_SUBDIVISIONS;\n    float m = mix(1., 5., remap01(radius, 0.007, 0.07));\n    for(float i = m ; i < planet_orbit_count-m ; i++ )\n    {\n        float angle = t_offset + ((i / planet_orbit_count) * PI * 2.);\n        myPos = getPos(dist, orbit_speed, angle, mMovement);\n\n        Layers planet_orbit = planet(in_uv, GLOBAL_ORBIT_SIZE, myPos, vec2(0., 1.));\n        float mask_planet_orbit = mix(0., 1., depth < planet_orbit.depth ? 1. : 0.) * planet_orbit.mask;\n        mask = mix(mask, 1., mask_planet_orbit);\n        depth = mix(depth, planet_orbit.depth, mask_planet_orbit);\n        uv = mix(uv, planet_orbit.uv, mask_planet_orbit);\n        clr = mix(clr, vec3(1.,1.,1.), mask_planet_orbit);\n        normals = mix(normals, planet_orbit.normals, mask_planet_orbit);\n    }\n    #endif\n}\n\n// draw rings to layers\nvoid MakeRing(vec2 in_uv, float orbit_speed, float t_offset, float radius, float dist, float rot_speed, vec2 uv_scale, vec2 mMovement, int clrIndex, vec2 clrClip, inout float mask, inout float depth, inout vec3 normals, inout vec3 clr, inout vec2 uv, vec3 phases, float opacity, float angle, float squash)\n{\n    vec3 myPos = getPos(dist, orbit_speed, t_offset, mMovement);\n    \n    Layers myRings = rings(in_uv, radius, myPos, phases, opacity, angle, squash);\n    float mask_rings = mix(0., 1., depth < myRings.depth ? 1. : 0.) * myRings.mask;\n    mask = mix(mask, 1., mask_rings);\n    depth = mix(depth, myRings.depth, mask_rings);\n    vec2 uv_rings = planet_uv_scroll(myRings.uv, uv_scale, vec2(0., rot_speed), vec2(0.,0.));\n    uv = mix(uv, uv_rings, mask_rings);\n    clr = mix(clr, getClr(uv_rings, clrClip, clrIndex), mask_rings);\n    normals = mix(normals, myRings.normals, mask_rings);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen uvs 0-1\n    //vec2 uv = fragCoord.xy/iResolution.yy;\n    \n    // tilt and rotate with mouse\n\tvec2 p = fragCoord / iResolution.x;\n    vec4 m = iMouse / iResolution.x;\n    \n    float mSens = 3.;\n    vec2 mFrom = (p - m.xy) * mSens;\n    vec2 mTo = (p-abs(m.zw)) * mSens;\n    vec2 mMovement = mFrom - mTo;\n\n    // init the layers\n    float mask = 0.;\n    float depth = -1.;\n    vec2 uv = fragCoord.xy/iResolution.yy;\n    vec3 clr = vec3(0,0,0);\n    vec3 normals = vec3(.5,.5,1.);\n    \n    float sun_distance = 0.001;\n    float ceres_distance = 0.13;\n    float mercury_distance = 0.17;\n    float venus_distance = 0.22;\n    float earth_distance = 0.28;\n    float mars_distance = 0.34;\n    float jupiter_distance = 0.44;\n    float saturn_distance = 0.57;\n    float uranus_distance = 0.68;\n    float neptune_distance = 0.78;\n    float pluto_distance = 0.88;\n    \n    float sun_radius = 0.1;\n    float ceres_radius = 0.007;\n    float mercury_radius = 0.015;\n    float venus_radius = 0.02;\n    float earth_radius = 0.03;\n    float mars_radius = 0.025;\n    float jupiter_radius = 0.07;\n    float saturn_radius = 0.05;\n    float uranus_radius = 0.03;\n    float neptune_radius = 0.025;\n    float pluto_radius = 0.007;\n    \n    float sun_orbit_speed = 0.001;\n    float ceres_orbit_speed = 0.052318;\n    float mercury_orbit_speed = 1.;\n    float venus_orbit_speed = 0.391633;\n    float earth_orbit_speed = 0.240964;\n    float mars_orbit_speed = 0.128093;\n    float jupiter_orbit_speed = 0.020319;\n    float saturn_orbit_speed = 0.008188;\n    float uranus_orbit_speed = 0.002877;\n    float neptune_orbit_speed = 0.001472;\n    float pluto_orbit_speed = 0.000972;\n    \n    float sun_t_offset = 0.;\n    float ceres_t_offset = 0.4;\n    float mercury_t_offset = 0.;\n    float venus_t_offset = 123.;\n    float earth_t_offset = 233.;\n    float mars_t_offset = 2243.;\n    float jupiter_t_offset = 623.;\n    float saturn_t_offset = 140.5;\n    float uranus_t_offset = 1143.;\n    float neptune_t_offset = 55.f;\n    float pluto_t_offset = 3.4;\n    \n    float sun_rotation_speed = -.2;\n    float ceres_rotation_speed = -2.655;\n    float mercury_rotation_speed = -0.016;\n    float venus_rotation_speed = 0.004;\n    float earth_rotation_speed = -1.;\n    float mars_rotation_speed = -0.9715;\n    float jupiter_rotation_speed = -2.4141;\n    float saturn_rotation_speed = -2.2191;\n    float uranus_rotation_speed = 1.3895;\n    float neptune_rotation_speed = -1.5827;\n    float pluto_rotation_speed = 0.1559;\n    \n    vec2 generic_uv = fragCoord.xy / iResolution.yy;\n    \n    //make the planets\n    MakePlanet(generic_uv, sun_orbit_speed, sun_t_offset, sun_radius, sun_distance, sun_rotation_speed, vec2(.9, .9), mMovement, 0, vec2(0., 0.8), mask, depth, normals, clr, uv);\n    normals = mix(normals, vec3(0.0,0.0,1.0), mask); // remove the normals for the sun\n    MakePlanet(generic_uv, ceres_orbit_speed, ceres_t_offset, ceres_radius, ceres_distance, ceres_rotation_speed, vec2(2., 2.), mMovement, 1, vec2(0., 0.7), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, mercury_orbit_speed, mercury_t_offset, mercury_radius, mercury_distance, mercury_rotation_speed, vec2(2., 2.), mMovement, 2, vec2(0.1, 0.5), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, venus_orbit_speed, venus_t_offset, venus_radius, venus_distance, venus_rotation_speed, vec2(1., 0.6), mMovement, 3, vec2(0.0, 0.4), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, earth_orbit_speed, earth_t_offset, earth_radius, earth_distance, earth_rotation_speed, vec2(4., 4.), mMovement, 4, vec2(0.1, .8), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, mars_orbit_speed, mars_t_offset, mars_radius, mars_distance, mars_rotation_speed, vec2(3., 3.), mMovement, 5, vec2(0.1, .8), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, jupiter_orbit_speed, jupiter_t_offset, jupiter_radius, jupiter_distance, jupiter_rotation_speed, vec2(15., 0.9), mMovement, 6, vec2(0., .9), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, saturn_orbit_speed, saturn_t_offset, saturn_radius, saturn_distance, saturn_rotation_speed, vec2(50., 1.), mMovement, 7, vec2(0., .9), mask, depth, normals, clr, uv);\n    MakeRing(generic_uv, saturn_orbit_speed, saturn_t_offset, saturn_radius + 0.05f, saturn_distance, -.1, vec2(0.3, 3.), mMovement, 7, vec2(0., .9), mask, depth, normals, clr, uv, vec3(23.34, 37.2234, 64.432), 0.9f, -0.3, 3.);\n    MakePlanet(generic_uv, uranus_orbit_speed, uranus_t_offset, uranus_radius, uranus_distance, uranus_rotation_speed, vec2(13., 13.), mMovement, 8, vec2(0., 1.), mask, depth, normals, clr, uv);\n    MakeRing(generic_uv, uranus_orbit_speed, uranus_t_offset, uranus_radius + 0.05f, uranus_distance, -.1, vec2(0.3, 3.), mMovement, 8, vec2(0., .9), mask, depth, normals, clr, uv, vec3(23.34, 37.2234, 64.432), 0.7f, 1.7, 4.);\n    MakePlanet(generic_uv, neptune_orbit_speed, neptune_t_offset, neptune_radius, neptune_distance, neptune_rotation_speed, vec2(12., 4.), mMovement, 9, vec2(0., .7), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, pluto_orbit_speed, pluto_t_offset, pluto_radius, pluto_distance, pluto_rotation_speed, vec2(12., 4.), mMovement, 10, vec2(0., .7), mask, depth, normals, clr, uv);\n    \n    // background stars\n    vec3 stars_clr;\n\n    float texStep = 1. / 64.;\n    for (float y = 0.; y < .25; y += texStep) {\n        for (float x = 0.; x < 1.; x += texStep) {\n            vec3 pos = texture(iChannel1, vec2(x, y)).xyz;\n            pos.xy = (pos.xy - .5) * 2. + .5;\n            pos.xy *= iResolution.xy;\n            stars_clr += star(pos, fragCoord);\n        }\n    }\n    vec4 bg = vec4(stars_clr, 1.);\n    \n    // foreground lighting, center of screen is the origin since that's where the sun is\n\tvec2 uv_light = fragCoord.xy/iResolution.xy;\n\tvec2 delta = uv_light - vec2(0.5,0.5);\n    vec3 lightdir = normalize(vec3(-delta, 0.));\n    \n    // shadows from the sun\n    float shadows = mix(1., smoothstep(0., 0.8,(dot(lightdir, normals) + 1.) / 2.), 0.5);\n    \n    // highlight from the sun\n    vec3 highlight = vec3(1., 1., 0.5) * mix(0., smoothstep(0., 1., clamp(dot(lightdir, normals), 0., 1.)), 0.2);\n    \n    // apply shadows and highlight\n    vec3 fg = clr * shadows + highlight;\n    \n    // blend bg with fg by the mask\n    vec4 col = mix(bg, vec4(fg, 1.), mask);\n    \n    // display render layers by using global flag\n#if LAYER_DISPLAY\n    vec2 visuv = fragCoord.xy / iResolution.yy + fragCoord.y/iResolution.y;\n    float sliceCount = 6.;\n    float sliceWidth = 2.;\n    \n    float lineWidth = 0.05;\n    float speed = 0.2;\n    \n    float slice = floor(mod(visuv.x * sliceWidth - iTime * speed, sliceCount)) / sliceCount;\n    float line = 1.-(smoothstep(0., lineWidth, mod((visuv.x - iTime * speed * (1./sliceWidth)) * sliceWidth * sliceCount, sliceCount)) * smoothstep(0., lineWidth, mod((-visuv.x + iTime * speed * (1./sliceWidth)) * sliceWidth * sliceCount, sliceCount)));\n    \n    float sliceStep = 1. / sliceCount;\n    if(slice >= sliceStep && slice <= sliceStep*2.) col = vec4(normals, 1.);\n    if(slice >= sliceStep*2. && slice <= sliceStep*3.) col = vec4(clr, 1.);\n    if(slice >= sliceStep*3. && slice <= sliceStep*4.) col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), remap01(depth, -0.5, 0.5));\n    if(slice >= sliceStep*4. && slice <= sliceStep*5.) col = vec4(mod(uv, 1.), 0., 1.);\n    if(slice >= sliceStep*5. && slice <= sliceStep*6.) col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), mask);\n    \n    col = mix(col, vec4(1.,1.,1.,1.), line);\n#endif\n    \n    // display individual layers\n    //col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), mask);\n    //col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), remap01(depth, -1.,1.));\n    //col = vec4(mod(uv, 1.), 0., 1.);\n    //col = vec4(clr, 1.);\n    //col = vec4(normals, 1.);\n\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}