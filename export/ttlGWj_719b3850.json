{"ver":"0.1","info":{"id":"ttlGWj","date":"1560935170","viewed":200,"name":"Voxel tiles","username":"tyomalu","description":"attempt to render voxel tiles","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst int tileWidth = 5;\nconst int tileHeight = 5;\nconst int tileDepth = 5;\n    \nint tile[] = int[](\n    0,0,0,0,0,\n    0,0,0,0,0,\n    0,0,1,0,0,\n    0,0,0,0,0,    \n    0,0,0,0,0,        \n    \n    0,0,0,0,0,\n    0,0,0,0,0,\n    0,0,1,0,0,\n    0,0,0,0,0,    \n    0,0,0,0,0,        \n\n    0,0,0,0,0,\n    0,0,1,0,0,\n    0,1,1,1,0,\n    0,0,1,0,0,    \n    0,0,0,0,0,        \n\n    0,0,0,0,0,\n    0,1,1,1,0,\n    0,1,1,1,0,\n    0,1,1,1,0,    \n    0,0,0,0,0,        \n\n    0,0,1,0,0,\n    0,1,1,1,0,\n    1,1,1,1,1,\n    0,1,1,1,0,    \n    0,0,1,0,0\n);\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Plane {\n    vec3 position;\n    vec3 normal;\n};    \n \nstruct Intersection{\n\tfloat t;\n\tfloat hit;\n\tvec3  hitPoint;\n\tvec3  normal;\n};\n    \nint voxelAt(ivec3 pos) {\n    return tile[(pos.z % tileDepth) * tileHeight * tileWidth + (pos.y % tileHeight) * tileWidth + (pos.x % tileWidth)];\n}\n\nIntersection intersectPlane(Ray ray, Plane p){\n    Intersection i;\n    i.t = 1.0e+30;\n\ti.hit = 0.0;\n\ti.hitPoint = vec3(0.0);\n    i.normal = vec3(0.0); \n    \n\tfloat d = -dot(p.position, p.normal);\n\tfloat v = dot(ray.direction, p.normal);\n\tfloat t = -(dot(ray.origin, p.normal) + d) / v;\n\tif(t > 0.0 && t < i.t){\n\t\ti.t = t;\n\t\ti.hit = 1.0;\n\t\ti.hitPoint = vec3(\n\t\t\tray.origin.x + t * ray.direction.x,\n\t\t\tray.origin.y + t * ray.direction.y,\n\t\t\tray.origin.z + t * ray.direction.z\n\t\t);\n\t\ti.normal = p.normal;\n\t}\n    return i;\n}\n\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    Ray ray = Ray(vec3(-1.5, 16.5 + sin(iTime) * 10.0, 12.0), rot3xy(vec2(-DEG_TO_RAD * 34.0, sin(iTime*2.0)/10.0)) * normalize(vec3(uv.x, uv.y, -1.0)));\n    \n    Plane tileTopPlane = Plane(\n    \tvec3(0.0, tileDepth, 0.0), \n    \tvec3(0.0, 1.0, 0.0)\n    );\n\n    \n    Intersection iTop = intersectPlane(ray, tileTopPlane);\n    \n    Plane dp = tileTopPlane;\n\n    fragColor = vec4(vec3(0.4, 0.0, 0.0), 1.0);\n    \n    for (int z=0; z < tileDepth; z++, dp.position.y -= 1.0) {\n        Intersection it = intersectPlane(ray, dp);\n        \n        if(it.hit > 0.0) {\n            ivec2 tileCoord = ivec2(\n                ceil(it.hitPoint.x / float(tileWidth)), \n                ceil(it.hitPoint.z / float(tileHeight))\n            );\n            \n            ivec2 voxelCoord = ivec2(\n                ceil(float(tileWidth) - (float(tileCoord.x * tileWidth) - it.hitPoint.x + 1.0)),\n                ceil(float(tileHeight) - (float(tileCoord.y * tileHeight) - it.hitPoint.z + 1.0))\n            );\n\n            //if (tileCoord.x >= -2 && tileCoord.y >= -4 && tileCoord.x <= 2 && tileCoord.y <= 1) {\n                if (voxelAt(ivec3(voxelCoord, z)) == 1) {\n\t             \tfragColor = vec4(vec3(float(z) / float(tileDepth)), 1.0);\n                    break;\n                }\n                //else\n                //\tfragColor += vec4(vec3(0.1), 1.0);\n            //}\n            \n        } \n    }\n\n}","name":"Image","description":"","type":"image"}]}