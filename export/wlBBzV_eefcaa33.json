{"ver":"0.1","info":{"id":"wlBBzV","date":"1599332605","viewed":127,"name":"Point in Triangle-Quad","username":"Wunkolo","description":"Extending the Point-In-Triangle test using barycentrics to limit the coordiantes to the maximum circumscribed quad that the triangle may contain.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","rasterization","quad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Pi = 3.1415926535897932384626433832795;\n\nbool PointInTriangleQuadBarycentric(\n    in vec2 Triangle[3],\n    in vec2 Point,\n    out vec2 UV\n)\n{\n    // Ideally you don't have to do this and can use something like:\n    // SV_Barycentrics                         (HLSL)\n    // GL_NV_fragment_shader_barycentric       (Nvidia)\n    // GL_AMD_shader_explicit_vertex_parameter (AMD)\n    // Or using interpolated vertex colors to get per-pixel barycentric coordiantes (Intel, etc)\n    mat3 Barycentric = inverse(\n        mat3(\n    \t\tTriangle[0], 1.0f,\n        \tTriangle[1], 1.0f,\n        \tTriangle[2], 1.0f\n    \t)\n    );\n\n    vec3 Weights = Barycentric * vec3( Point, 1.0f);\n    // Convert incoming point to barycentric coordinates\n\n    // Test the barycentric coordinates for if they land within the quad\n    if(\n        all( greaterThanEqual( Weights, vec3(0.0f) ) ) &&\n        all( lessThan(Weights.xz,vec2(0.5)))\n    )\n    {\n        // Remap the barycentric coordiantes to be UV coordinates\n        UV = Weights.xz * 2.0;\n        return true;\n    }\n    // If the pixel missed, you would be using \"discard;\" here to cull the pixel entirely\n    return false;\n}\n\nbool PointInTriangleCrossOpt(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    vec2 EdgeDir[3] = vec2[](\n    \tTriangle[1] - Triangle[0],\n        Triangle[2] - Triangle[1],\n        Triangle[0] - Triangle[2]\n\t);\n    \n    vec2 PointDir[3] = vec2[](\n    \tPoint - Triangle[0],\n        Point - Triangle[1],\n        Point - Triangle[2]\n\t);\n    \n    vec3 Crosses = vec3(\n        // EdgeDir[0].x * PointDir[0].y - EdgeDir[0].y * PointDir[0].x,\n        // EdgeDir[1].x * PointDir[1].y - EdgeDir[1].y * PointDir[1].x,\n        // EdgeDir[2].x * PointDir[2].y - EdgeDir[2].y * PointDir[2].x,\n        // GLSL declares matrices by columns\n        // The determinant of a square matrix is the same as the determinant of its transpose.\n        // So this works too!\n        determinant( mat2( EdgeDir[0], PointDir[0] ) ),\n\t\tdeterminant( mat2( EdgeDir[1], PointDir[1] ) ),\n\t\tdeterminant( mat2( EdgeDir[2], PointDir[2] ) )\n    );\n    \n    if(\n        // Area0 >= 0.0f &&\n        // Area1 >= 0.0f &&\n        // Area2 >= 0.0f\n        all( greaterThanEqual( Crosses, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 Rotate(in vec2 Point, float Angle)\n{\n\tfloat RotSine = sin(Angle);\n\tfloat RotCosine = cos(Angle);\n    \n\treturn mat2(\n        RotCosine, -RotSine,\n        RotSine  ,  RotCosine\n    ) * Point;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec2 UV = -1.0 + 2.0 * (FragCoord/iResolution.xy);\n    UV.x *= iResolution.x/iResolution.y;\n    \n    vec2 Tri[3] = vec2[](\n    \tvec2( -1.5f, -0.5f ) + vec2(cos(Pi * iTime * 0.75),sin(Pi * iTime * 2.0)) * 0.13,\n    \tvec2(  1.5f, -0.5f ),\n    \tvec2(  1.5f,  0.5f )\n\t);\n    \n    for( int i = 0; i < 3; ++i )\n    {\n        Tri[i] = Rotate( Tri[i], iTime * Pi * 1.0f/25.0f );\n    }\n    \n    vec3 CurColor = vec3( 0.25f );\n    \n    CurColor = PointInTriangleCrossOpt( Tri, UV) ? vec3(0.5,0.5,0.5) : CurColor;\n    \n    vec2 QuadUV = vec2(0,0);\n    CurColor = PointInTriangleQuadBarycentric( Tri, UV, QuadUV ) ? vec3(QuadUV,0) : CurColor;\n\n    FragColor = vec4(\n        CurColor,\n        1.0\n    );\n}","name":"Image","description":"","type":"image"}]}