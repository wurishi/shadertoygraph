{"ver":"0.1","info":{"id":"mldSDn","date":"1685306006","viewed":61,"name":"Experimental Ray Marcher","username":"boytoy","description":"Experimental ray marcher (my first one).\n\nI think i invented a method for bouncing rays, ripped out of optimization search algorithms.\nEssentially, technique allows for rays bouncing a surface to escape when SDFs are near zero.\n\nmention me if copied.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingbouncereflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parameters\n\n// differential parameters\nconst float dh     = 0.1;\nconst float inv_dh = 1./dh;\n\n// Algorithm Parameters\n#define MAX_STEPS 35\n#define RAY_BOUNCES 3\n#define JUMP_SEARCH  7 // quality increases\n#define JUMP_MULT 3.   // quality decreases\n// in general, aim for : pow(jump_search,jump_mult) * dh ~ 1.\n\n// scene parameters\nconst vec3 camera_pos = vec3(0.,4.,-1.);\n\nconst float phi = -PI*0.4;\nconst vec3 right   = vec3(1.,0.,0.);\nconst vec3 forward = vec3(0.,sin(phi), cos(phi));\nconst vec3 up      = vec3(0.,cos(phi),-sin(phi));\nconst mat3 camera_rotation = mat3(right,up,forward);\n\n#define pixelated false\nconst ivec2 pixels = ivec2(480); // these look aesthetical, but also, they hide artifacts c:<\n\nconst float reflection_index = 0.4;\nconst float reflection_decay = 0.7;\nconst float far = 100.;\n\n#define default_color vec3(0.561,0.561,0.561)\n#define sky_bg        vec3(1.000,0.843,0.910)\n\n// SDF declaration /////////////////////////////////////////////////////////////\n\nfloat get_sdf(vec3 pos, const float t){ // t is just iTime here\n    vec3 center = vec3(0.,-1.,2.);\n    float sdf = sphere_sdf(pos,center + vec3(0.,-5. + 11.*cos(t*.777),0.) , 2.);\n    \n    // put several bodies on a ring\n    float ring_sdf = 1000.;\n\tfloat r = 4. + 1.5*sin(0.5*t); // ring radius\n\tfloat RR = 1.; // body radius\n\tint N = 3; // Number of figures\n\tfor(int i = 0; i <N ; i++ ){\n\t\tfloat angle = 2.*PI*float(i)/float(N); // spinning,\n\t\tvec3 c_center = center + vec3(0.,0.,0.); // centered at\n\t\tvec3 displacement_h = r*vec3(cos(angle + t),0.,sin(angle+t));\n\t\t\tring_sdf = min(ring_sdf,sphere_sdf(pos,c_center+displacement_h,RR));\n\t}\n    \n    float plane_sdf = plane_sdf(pos, normalize(vec3(.2,1.,.1)), - 11.);\n    float sdf2 = min(plane_sdf,ring_sdf);\n    sdf = exp_smin(sdf,sdf2,3.);\n    \n    return sdf;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\n// colors for a palette\n#define color_1 vec3(0.145,0.847,0.494)\n#define color_2 vec3(0.902,0.808,1.000)\n#define color_3 vec3(0.376,0.000,1.000)\n#define color_4 vec3(0.549,1.000,0.796)\n\n#define x1 vec2(1.,0.)\n#define x2 vec2(0.,1.)\n#define x3 vec2(-1.,0.)\n#define x4 vec2(0.,-1.)\n\n// palette returns an interpolation between four sequential colors...\nvec3 palette(float t){\n    // explanation: color is continuously interpolated by how near \n    // the vector (cos(t),sin(t)) is to each the four points x1,x2,x3,x4\n    // when nearest to point xi, the color returned is closest to color_i\n    vec2 xy = vec2(cos(t),sin(t));\n    // uses convex combinations:\n    float l1 = 2. - length(xy-x1);\n    float l2 = 2. - length(xy-x2);\n    float l3 = 2. - length(xy-x3);\n    float l4 = 2. - length(xy-x4);\n    l1*=l1;l2*=l2;l3*=l3;l4*=l4;\n    float sum = l1+l2+l3+l4;\n    l1/=sum;l2/=sum;l3/=sum;l4/=sum;\n    // the result is a convex combination of the colors:\n    vec3 combination = l1*color_1 + l2*color_2 + l3*color_3 + l4*color_4;\n    return combination;\n}\n\nvec3 get_color(vec3 pos,float depth, float t){\n    float sdf = get_sdf(pos,t);\n\t// faraway stuff gets colored with background: sky or floor color.\n    if (sdf >= far) return sky_bg;\n    float pattern = iTime + length(pos*0.2);\n    vec3 obj_c = default_color*0.5 + 0.5 * palette(pattern);\n    return obj_c; \n}\n\n// Gradient of the SDF. Used for calculating normals (therefore bounces)\nvec3 get_gradient(vec3 pos,float t){\n\tfloat dx = get_sdf(pos+vec3(dh,0.,0.),t) - get_sdf(pos,t) ;\n\tfloat dy = get_sdf(pos+vec3(0.,dh,0.),t) - get_sdf(pos,t) ;\n\tfloat dz = get_sdf(pos+vec3(0.,0.,dh),t) - get_sdf(pos,t) ;\n\treturn vec3(dx,dy,dz)*inv_dh;\n}\n\n\n// algorithms /////////////////////////////////////////\n\n// single ray cast //\nray_march_hit ray_march(vec3 pos, vec3 ray, float t, bool first_ray){\n\tray_march_hit result;\n\tresult.depth = 0.;\n\tbool break_condition = false;\n\tint steps = 0;\n\tfloat d;\n\tfloat sdf = get_sdf(pos,t);\n\t\n\tif(first_ray){// ray coming from camera:\n\t\td = sdf;\n\t} else { // ray bouncing out of a surface:\n        // the ray needs help getting out of the object:\n\t\t// find largest d such that gradient is increasing with ray.\n\t\t// this technique does not come from ray tracing literature, but from optimization.\n\t\t// Look for \"Boyd Convex Optimization Book -> Algorithms - Linesearch\".\n\t\td = dh;\n\t\tfor(int j = 0; j<JUMP_SEARCH;j++){\n\t\t\tvec3 gradient  = get_gradient(pos + d*ray ,t); // \"normal to surface vector\"\n\t\t\tfloat projection = dot(ray,gradient);\n\t\t\tbool distance_increasing = projection > 0.;\n\t\t\td *= JUMP_MULT;\n\t\t\tif (!distance_increasing){ // breaks once ray leaves the increasing distance zone.\n\t\t\t\td /= JUMP_MULT;break;}\n\t\t}\n\t}\n\t\n\t// ray cast\n\tdo {\n\t\tresult.depth += d;\n\t\tpos = pos + ray * d;\n\t\td = get_sdf(pos,t);\n\t\tsteps++;\n\t\tbreak_condition = (d <= 0.);\n\t} while ( (!break_condition) && (steps < MAX_STEPS  ));\n\t\n\tresult.max_iterations = (steps>=MAX_STEPS);\n\tresult.sdf      = d;\n\tresult.position = pos;\n\tresult.color  = get_color(pos,result.depth,t);\n\treturn result;\n}\n\n// ray with bounces //\n// Generates a ray, then bounces it RAY_BOUNCES times.\n// The color is calculated mixing each bound, and the depth is the depth of the first ray.\ncolor_and_depth ray_marching(vec3 pos, vec3 ray, float t){\n\tcolor_and_depth result;\n\tray_march_hit[RAY_BOUNCES] hits;\n\t\n\tfor(int i = 0; i < RAY_BOUNCES; i++){\n\t\thits[i] = ray_march(pos,ray,t,(i==0));\n\t\tpos = hits[i].position;\n\t\tif(hits[i].sdf >= 2.*dh) continue; // if the \"hit\" is far from an object, continue.\n\t\t// this code is only executed when the ray hits a surface\n\t\tray = reflect_vector_plane(ray,get_gradient(pos,t));\n\t}\n\tvec3 color = hits[0].color;\n    float reflection_ponderator = reflection_index;\n\tfor(int i = 1; i < RAY_BOUNCES; i++){\n\t\t// color mixing.\n\t\tvec3 reflection_color = hits[i].color;\n\t\tcolor = (1.-reflection_ponderator) * color + reflection_ponderator * reflection_color;\n        reflection_ponderator*= reflection_decay;\n\t}\n\tresult.color = color;\n\tresult.depth = hits[0].depth;\n\treturn result;\n}\n\n// fragment ///////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    if (pixelated) uv = pixel_uv(uv,pixels);\n    uv = 2.*uv - 1. ; uv.x *= iResolution.x/iResolution.y;\n    \n    // camera position\n    vec3 ro = camera_pos;\n    vec3 rd = ray(uv,camera_rotation);\n    \n    // run algorithm\n    color_and_depth result = ray_marching(ro,rd,iTime);\n    vec3 col = result.color;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// SDF declaration WAY BELOW\n\n// sdfs and other raymarching primitives\n// i used some from IQ, https://iquilezles.org/articles/ (thanks)\n\nfloat sphere_sdf(vec3 pos, vec3 center, float radius){ // iq i think\n\treturn length((pos-center)) - radius;\n}\n\nfloat cube_sdf(vec3 pos, vec3 center, vec3 R){ // iq i think\n\tfloat d = length(max(abs(pos-center)-R,vec3(0.)));\n\treturn d;\n}\n\nfloat plane_sdf(vec3 pos, vec3 normal, float cut){\n    return dot(pos,normal) - cut;\n}\n\nfloat exp_smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat smin(float a,float b){\n\treturn exp_smin(a,b,2.);\n}\n\n// ray marching algorithm structures\nstruct ray_march_hit {\n\tvec3 position;\n\tvec3 color;\n\tfloat depth;\n\tbool max_iterations;\n\tfloat sdf;\n};\n\nstruct color_and_depth {\n\tvec3 color;\n\tfloat depth;\n};\n\n// ray marching algorithms\n\n// takes an uv coordinate from the screen renderer and\n// returns the normalized ray.\nvec3 ray(vec2 uv, const mat3 camera_rotation){\n    // pass a ray through the {(x,y,z) : z=1} plane coming from the origin\n\tvec3 rd = vec3(uv,1.);\n\t// transform it according to camera\n\trd = camera_rotation * rd;\n\t// return answer\n\treturn normalize(rd);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// other\nvec2 pixel_uv(vec2 uv, ivec2 pixels){\n\tvec2 ans;\n\tans.x = floor(uv.x * float(pixels.x-1) + 0.5)/float(pixels.x-1);\n\tans.y = floor(uv.y * float(pixels.y-1) + 0.5)/float(pixels.y-1);\n\treturn ans;\n}\n//\nvec3 reflect_vector_plane(vec3 rd, vec3 normal){\n\tvec3 n = normalize(normal);\n\treturn normalize(rd - 2.*dot(rd,n)*n);\n}\n\n\nconst float PI = 3.14159265359;\n\n","name":"Common","description":"","type":"common"}]}