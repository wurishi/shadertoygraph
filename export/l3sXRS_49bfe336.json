{"ver":"0.1","info":{"id":"l3sXRS","date":"1709684512","viewed":109,"name":"wtf is this ?","username":"amusement","description":"sometimes it gets stuck, restart the video and run again (dunno)","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pixel","sort","sorting","odd","even"],"hasliked":0,"parentid":"wsSczw","parentname":"Odd-even horizontal pixel sort"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n\n// Randomizer on/off control (0.0 - 1.0)\nfloat randomizeParameters = 1.0;\n\n// Randomness percentage control (0.0 - 100.0)\nfloat randomnessPercentage = 0.001;\n\n// BPM (Beats Per Minute) control\nfloat bpm = 0.01;\n\n// Sorting speed control\nfloat sortingSpeed = 1.1;\n\n// Sorting distance control\nfloat sortingDistance = 1.09;\n\n// Sorting mode control\n// 0: Grayscale (default)\n// 1: Red channel\n// 2: Green channel\n// 3: Blue channel\nint sortingMode = 2;\n\n// Background color\nvec3 backgroundColor = vec3(1.0, 1.0, 1.0);\n\n// Contrast control\nfloat contrast = 1.01;\n\n// Saturation control\nfloat saturation = 1.01;\n\n// Random value generation function\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(1.1,1.1))) * 1.1)* 0.99;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // uvs\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Scale randomness based on percentage\n    float randomnessScale = randomnessPercentage / 100.0;\n    \n    // Random seed based on shader's run time\n    float randomSeed = fract(iTime);\n    \n    // Randomize parameters if the randomizer is on\n    if (randomizeParameters > 0.5) {\n        // Random BPM between 10 and 200\n        float bpmRange = 100.0 * randomnessScale;\n        float bpmMin = max(0.1, bpm - bpmRange * 0.5);\n        float bpmMax = min(2.0, bpm + bpmRange * 0.5);\n        bpm = bpmMin + random(vec2(randomSeed, 0.0)) * (bpmMax - bpmMin);\n        \n        // Random sorting speed between 0.1 and 10.0\n        float sortingSpeedRange = 9.9 * randomnessScale;\n        float sortingSpeedMin = max(0.1, sortingSpeed - sortingSpeedRange * 0.5);\n        float sortingSpeedMax = min(10.0, sortingSpeed + sortingSpeedRange * 0.5);\n        sortingSpeed = sortingSpeedMin + random(vec2(randomSeed, 1.0)) * (sortingSpeedMax - sortingSpeedMin);\n        \n        // Random sorting distance between 0.1 and 10.0\n        float sortingDistanceRange = 9.9 * randomnessScale;\n        float sortingDistanceMin = max(0.1, sortingDistance - sortingDistanceRange * 0.5);\n        float sortingDistanceMax = min(10.0, sortingDistance + sortingDistanceRange * 0.5);\n        sortingDistance = sortingDistanceMin + random(vec2(randomSeed, 2.0)) * (sortingDistanceMax - sortingDistanceMin);\n        \n        // Random sorting mode between 0 and 3\n        sortingMode = int(floor(random(vec2(randomSeed, 3.0)) * 4.0));\n        \n        // Random background color\n        backgroundColor = vec3(random(vec2(randomSeed, 4.0)), random(vec2(randomSeed, 5.0)), random(vec2(randomSeed, 6.0)));\n        \n        // Random contrast between 0.1 and 5.0\n        float contrastRange = 4.9 * randomnessScale;\n        float contrastMin = max(0.1, contrast - contrastRange * 0.5);\n        float contrastMax = min(5.0, contrast + contrastRange * 0.5);\n        contrast = contrastMin + random(vec2(randomSeed, 7.0)) * (contrastMax - contrastMin);\n        \n        // Random saturation between 0.0 and 5.0\n        float saturationRange = 5.0 * randomnessScale;\n        float saturationMin = max(0.0, saturation - saturationRange * 0.5);\n        float saturationMax = min(5.0, saturation + saturationRange * 0.5);\n        saturation = saturationMin + random(vec2(randomSeed, 8.0)) * (saturationMax - saturationMin);\n    }\n    \n    // Convert BPM to frequency\n    float beatFrequency = bpm / 60.0;\n    float elapsedTime = mod(iTime, 1.0 / beatFrequency);\n    float pulseWidth = 0.1 / beatFrequency; // Adjust the pulse width as needed\n    float pulseValue = step(elapsedTime, pulseWidth);\n    \n    if (iFrame < 10 || pulseValue > 0.1) {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    int numPasses = int(sortingSpeed); // Adjust the number of passes based on sorting speed\n    \n    vec4 sortedColor = vec4(0.0);\n    \n    for (int pass = 0; pass < numPasses; pass++) {\n        // the frame number parity, -1 is odd 1 is even\n        float fParity = mod(float(iFrame), 2.) * 2. - 1.;\n        \n        // we differentiate every 1/2 pixel on the vertical axis, will be -1 or 1\n        float vp = mod(floor(uv.y * iResolution.y), 2.0) * 2. - 1.;\n        \n        vec2 dir = vec2(0, sortingDistance);\n        dir *= fParity * vp;\n        dir /= iResolution.xy;\n\n        // we sort\n        vec4 curr = texture(iChannel1, uv);\n        vec4 comp = texture(iChannel1, uv + dir);\n        \n        // Calculate the sorting values based on the selected sorting mode\n        float sortCurr = 0.0;\n        float sortComp = 0.0;\n        \n        if (sortingMode == 0) {\n            // Grayscale sorting\n            sortCurr = dot(curr.rgb, vec3(0.299, 0.587, 0.114));\n            sortComp = dot(comp.rgb, vec3(0.299, 0.587, 0.114));\n        } else if (sortingMode == 1) {\n            // Red channel sorting\n            sortCurr = curr.r;\n            sortComp = comp.r;\n        } else if (sortingMode == 2) {\n            // Green channel sorting\n            sortCurr = curr.g;\n            sortComp = comp.g;\n        } else if (sortingMode == 3) {\n            // Blue channel sorting\n            sortCurr = curr.b;\n            sortComp = comp.b;\n        }\n        \n        // Introduce depth-based effects\n        float depthFactor = smoothstep(0.0, 1.0, sortCurr);\n        dir *= depthFactor;\n        \n        // we prevent the sort from happening on the borders\n        if (uv.y + dir.y < 0.0 || uv.y + dir.y > 1.0) {\n            sortedColor = curr;\n            break;\n        }\n        \n        // the direction of the displacement defines the order of the comparison\n        if (dir.y < 0.0) {\n            if (sortComp > sortCurr) {\n                sortedColor = comp;\n            } else {\n                sortedColor = curr;\n            }\n        } \n        else {\n            if (sortCurr >= sortComp) {\n                sortedColor = comp;\n            } else {\n                sortedColor = curr;\n            }\n        }\n    }\n    \n    // Blend the sorted pixels with the background color\n    vec3 blendedColor = mix(backgroundColor, sortedColor.rgb, sortedColor.a);\n    \n    // Adjust contrast\n    blendedColor = (blendedColor - 0.5) * contrast + 0.5;\n    \n    // Adjust saturation\n    float luminance = dot(blendedColor, vec3(0.299, 0.587, 0.114));\n    blendedColor = mix(vec3(luminance), blendedColor, saturation);\n    \n    fragColor = vec4(blendedColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}