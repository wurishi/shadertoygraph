{"ver":"0.1","info":{"id":"fdjSWD","date":"1620258163","viewed":122,"name":"MandleBulb","username":"UberAtlas","description":"Learning shaders by rendering a mandlebulb.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","fractals","mandlebulb","trippy","replication"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//////////////////////\n// Raymarch Config\n//////////////////////\nconst int MAX_STEPS = 100;\nconst float MINIMUM_HIT_DISTANCE = 0.001;\nconst float MAXIMUM_TRACE_DISTANCE = 500.0;\nconst float DARKNESS = 35.0;\n\n//////////////////////\n// MandleBulb Config\n//////////////////////\nconst int ITERATIONS = 15;\nconst float BULB_SCALE = 0.5;\n\n\n// Adapted from: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandleBulbDistance(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n    float power = 1. + iTime / 15.;\n\n\tfor (int i = 0; i < ITERATIONS ; i++) {\n\t\tr = length(z);\n\t\tif (r > 2.) break;\n\n\t\t// convert to polar coordinates\n        float theta = asin( z.z/r );\n        float phi = atan( z.y,z.x );\n\t\tdr =  pow(r, power - 1.0) * power * dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(cos(theta) * cos(phi), cos(theta) * sin(phi), sin(theta));\n\t\tz += pos;\n\t}\n\n\treturn BULB_SCALE * log(r) * r / dr;\n}\n\nfloat world(in vec3 pos) {\n    return mandleBulbDistance(pos);\n}\n\nvec3 normalOfPos(in vec3 pos) {\n    const vec3 step = vec3(0.001, 0.0, 0.0);\n\n    float gradX = world(pos + step.xyy) - world(pos - step.xyy);\n    float gradY = world(pos + step.yxy) - world(pos - step.yxy);\n    float gradZ = world(pos + step.yyx) - world(pos - step.yyx);\n\n    vec3 normal = vec3(gradX, gradY, gradZ);\n\n    return normalize(normal);\n}\n\n// Adapted from https://michaelwalczyk.com/blog-ray-marching.html\nvec3 rayMarch(in vec3 ro, in vec3 rd, in vec2 uv) {\n    float totalDistanceTraveled = 0.0;\n    \n    vec3 color = mix(sin(iTime / 7. + vec3(1.4,0.7,10.1)), vec3(uv.x), vec3(uv.y)) * 0.3;\n    \n    int steps = 0;\n    while (steps < MAX_STEPS) {\n        // Calculate our current position along the ray\n        vec3 curPos = ro + totalDistanceTraveled * rd;\n\n        float distToClosest = mandleBulbDistance(curPos);\n        \n        // Hit\n        if (distToClosest < MINIMUM_HIT_DISTANCE) {\n            vec3 normal = normalOfPos(curPos);\n            vec3 lightPos = vec3(1., 2., 3.);\n            vec3 lightDir = normalize(curPos - lightPos);\n            float diffuseIntensity = max(0.0, dot(normal, lightDir));\n            color = sin(iTime / 7. + curPos.zyx + vec3(1.4,0.7,10.1)) * diffuseIntensity;\n            break;\n        }\n        \n        // Miss\n        if (totalDistanceTraveled > MAXIMUM_TRACE_DISTANCE) break;\n\n        // accumulate the distance traveled thus far\n        totalDistanceTraveled += distToClosest;\n        \n        steps += 1;\n    }\n\n    // Inspired by https://github.com/SebLague/Ray-Marching/blob/f7e44c15a212dec53b244b1f53cdaf318f6ec700/Assets/Scripts/Fractal/Fractal.compute\n    float rim = float(steps) / DARKNESS;\n    return color * rim;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 cameraPos = vec3(-.7, -.5, -2.);\n    vec3 ro = cameraPos;\n    vec3 rd = vec3(uv, 0.75);\n\n    // Time varying pixel color\n    vec3 col = rayMarch(ro, rd, uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}