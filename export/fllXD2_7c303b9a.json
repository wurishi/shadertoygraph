{"ver":"0.1","info":{"id":"fllXD2","date":"1626862827","viewed":201,"name":"Class 3: Fork 2 192 Cephalopod","username":"Cephalopodium","description":"Simple texturing shading and lighting. To implement lighting get normals from its position instead of the eye / camera position. This is called Lambertian or diffuse shading. I've used 4 texture files :- picture, video, music and webcam respectively.","likes":2,"published":1,"flags":2,"usePreview":0,"tags":["texture","shading"],"hasliked":0,"parentid":"ftfXDj","parentname":"Class 3: Fork 1 877 Cephalopod"},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = 0.0;\n\n// vec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n// CDA pow() replacement - required to support vec3 inputs for iPhone\nvec3 power( vec3 a, float b) {\n vec3 r = vec3(1.0,1.0,1.0);\n r.x = pow(a.x,b);\n r.y = pow(a.y,b);\n r.z = pow(a.z,b);\n return r; // vec3(a.x,a.y,a.z); \n}\n  \nint cdaMod(int a, int b) {\n   int divi; int rem;\n   divi = int(a/b);\n   rem = a - (divi * b);\n   return rem;\n}\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nSphere spheres[4];\nLight  lights[1];\n\nvoid makeScene(int f) {\n    // CDA Added blue to yellow ball\n    spheres[0] = Sphere(1.5, vec3(0, 0, -6), vec3(1, 1, 1));   \n    // CDA light position and color oscillations\n    lights[0] = Light(vec3(-1.0+sin(float(f)/20.0)*3.0,\n                           -1.0+cos(float(f)/20.0)*3.0, \n                           -2.0+sin(float(f)/20.0)*3.0), vec3(1,1,1.0)); //.54,.54,.54)); \n                           /* \n                      vec3(abs(tan(float(f)/20.0)+.250)*3.0,     // prefix with abs(trig(..)) \n                           abs(cos(float(f)/20.0)+1.0)*3.0,      // to remove shadow\n                           (sin(float(f)/20.0)-1.0)*3.0));       // colour artifacts \n                           */\n//   lights[0] = Light(vec3(-1.0, 0.0, -4.0), vec3(.1, .1, .1));\n//   lights[0] = Light(vec3(0.0,0.0, -4.0), vec3(.01, .01, .01));\n}\n\nint numSamples = 1;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0; \n   for (int i=0; i<=numSamples; i++) { // on iPhone replace numSamples with its value\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       Sphere sphere = spheres[0];\n       \n       float t = raySphereIntersect(ray, sphere);\n       if (t < 1000000.0) {\n           vec3 hit = ray.origin + t*ray.direction;\n           vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointNormal = normalize(hit-sphere.center); // redundant variable name\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           vec3 hitPointToLight = normalize(lights[0].location-hit);\n           float angle = dot(hitPointNormal, hitPointToLight); // hitPointToEye);\n           float u = asin(norm.x) / 3.14 + 0.5;\n           float v = asin(norm.y) / 3.14 + 0.5;\n           int cdaTexture = cdaMod(int(iFrame/400),4);\n           switch (cdaTexture) {   // timed texture toggle\n             case 0: sphere.color = sphere.color + texture(iChannel0, vec2(u,v)).xyz; break;\n             case 1: sphere.color = sphere.color + texture(iChannel1, vec2(u,v)).xyz; break;\n             case 2: sphere.color = sphere.color + texture(iChannel2, vec2(u,v)).xyz; break;\n             case 3: sphere.color = sphere.color + texture(iChannel3, vec2(u,v)).xyz; break;\n             default: break;\n           }\n           vec3 cdatmp = angle* sphere.color;\n           // CDA Using power to fix contrast + multipled by light color\n           samp = samp + (power(cdatmp,1.5161)-1.0) * power(lights[0].color,-.185); \n       } \n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}