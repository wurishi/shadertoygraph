{"ver":"0.1","info":{"id":"DsSSWh","date":"1671478730","viewed":1467,"name":"LEGO Creator 5891","username":"Mathis","description":"Press R to watch the building process.\nIf there are no bricks with colors, the blue noise texture has not loaded yet.\n\nUsing manully modelled bricks, compilation optimizations and an octree to render 490 dynamic bricks.","likes":77,"published":1,"flags":48,"usePreview":1,"tags":["3d","lego"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nLEGO Creator 5891\n    Rendering\n        GGX Path Tracing\n        Edge detection when geometry moves\n    LEGO 5891\n        This set is really good, I did not add interior details in this shader\n        Some changes have been made to the original instructions:\n            The door has another model entirely (no frame)\n            The basketball hoop, mower and grey arc are not included\n            The hinge for the disk is changed (the functionality still works)\n            The tree has reduced complexity as the renderer is limited (max 4 bricks/voxel)\n    Bricks\n        They are stored in arrays and sampled/updated i Buffer A\n            Modified quaternions are used to describe rotation\n        3D models are not perfect of course\n    Brick propagation\n        Propagation-type movement is efficient for a large number of objects but put constraints on free movement\n            3^3 search box in the volume means the maximum absolute velocity (translation + transformation) vector at any point\n            on the brick is limited to 1 voxel_vec3/frame\n        This max velocity is clamped to max 30 bricks/sec (to not break high fps counts)\n        Max 4 bricks can be stored in a voxel\n            When more than 4 bricks intersect with a voxel, bricks that are cut off repair themselves as they propagate\n    Feedback is welcome!\n\n\n\n\nControls\n    Movement\n        WASD to move the camera\n        Hold space to move faster\n        Click and hold mouse to rotate the camera\n    Bricks\n        Press R to watch the building process\n        Press it again during the animation to pause\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = texture(iChannel3,fragCoord*IRES).xyz;\n    fragColor = vec4(pow(1.-exp(-1.2*Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV = radians((100.)/2.);\n\n//Constants\nconst int BuildFrames = 33;\nconst float SAFram = 0.24145316170843;\nconst float SASida = 0.18443362850791;\nconst float PI = 3.14159265;\nconst float IPI = 1./PI;\nconst float ToRadians = PI/180.;\nconst float I16 = 1./16.;\nconst float I26 = 1./26.;\nconst float I32 = 1./32.;\nconst float I64 = 1./64.;\nconst float I128 = 1./128.;\nconst float I255 = 1./255.;\nconst float I256 = 1./256.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float Sqrt2 = sqrt(2.);\nconst float Sqrt05 = sqrt(0.5);\nconst float ISqrt3 = 1./sqrt(3.);\nconst vec2 eps = vec2(0.001,0.);\nconst float CFOV = tan(FOV);\nconst vec3 SunLight = vec3(1.,0.15,0.03)*4.;\nconst vec3 SkyLight = vec3(0.2,0.45,0.99);\nconst vec3 LEGOObliqueSlope = normalize(vec3(0.,-3.,-3.4));\nconst vec3 LEGOSlope331 = normalize(vec3(0.9,2.,0.));\nconst vec3 LEGOSlope = normalize(vec3(0.9,1.,0.));\nconst vec3 LEGOISlope = normalize(vec3(0.9,-1.,0.));\nconst vec3 LEGOOSlope = normalize(vec3(3.5/6.,1.,0.));\n//Defines\n#define RES iChannelResolution[0].xy\n#define IRES 1./iChannelResolution[0].xy\n#define ASPECT vec2(iChannelResolution[0].x/iChannelResolution[0].y,1.)\n\n//Structs\nstruct HIT { float D; vec3 P; vec3 N; vec3 C; int I; float M; };\nstruct BRICK { vec3 P; vec3 Q; int Color; int I; };\n\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC2(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = floor(atan(p.x,p.y)/ang+0.5);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\nfloat SMIN(float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec2 PToUV(vec3 p) {\n    return vec2(floor(p.x)+floor(p.y)*2.,floor(p.z))+0.5;\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb = vec3(1.,0.,0.);\n        Nt = vec3(0.,0.,1.);\n    } else {\n    \tNb = normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt = normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)>0.999)?vec3(1.,0.,0.):normalize(cross(N,vec3(0.,1.,0.))));\n    return normalize(cross(O,N));\n}\n\nfloat boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t2 = max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nfloat boxfar(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nvec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec3 boxfarNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = max(vec3(0.),sign(dir))*2.-1.;\n    if (t2.x<min(t2.y,t2.z)) return vec3(signdir.x,0.,0.);\n    else if (t2.y<t2.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nfloat boxfarNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = max(vec3(0.),sign(dir))*2.-1.;\n    if (t2.x<min(t2.y,t2.z)) N = vec3(signdir.x,0.,0.);\n    else if (t2.y<t2.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nvec2 boxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) N = vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nfloat Schlick(float R0, float COS) {\n    //Schlick approximation\n    return R0+(1.-R0)*pow(1.-COS,5.);\n}\n\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nfloat SmithGGXMasking(vec3 wi, vec3 wo, float a2) {\n    //Smith masking function\n    float dotNL=wi.z;\n    float dotNV=wo.z;\n    float denomC=sqrt(a2+(1.-a2)*dotNV*dotNV)+dotNV;\n    return 2.*dotNV/denomC;\n}\n\nfloat SmithGGXMaskingShadowing(vec3 wi, vec3 wo, float alpha) {\n    //Smith masking shadowing function\n    float dotNL=wi.z;\n    float dotNV=wo.z;\n    float denomA=dotNV*sqrt(alpha+(1.-alpha)*dotNL*dotNL);\n    float denomB=dotNL*sqrt(alpha+(1.-alpha)*dotNV*dotNV);\n    return 2.*dotNL*dotNV/(denomA+denomB);\n}\n\nvec3 GgxVndf(vec3 wo, float roughness, float u1, float u2) {\n    //Returns the mini normal\n    vec3 v=normalize(vec3(wo.x*roughness,wo.y*roughness,wo.z));\n    vec3 t1=(v.z<0.999)?normalize(cross(v,vec3(0.,0.,1.))):vec3(1.,0.,0.);\n    vec3 t2=cross(t1, v);\n    float a=1./(1.+v.z);\n    float r=sqrt(u1);\n    float phi=(u2<a)?(u2/a)*PI:PI+(u2-a)/(1.-a)*PI;\n    float p1=r*cos(phi);\n    float p2=r*sin(phi)*((u2<a)?1.:v.z);\n    vec3 n=p1*t1+p2*t2+sqrt(max(0.,1.-p1*p1-p2*p2))*v;\n    return normalize(vec3(roughness*n.x,roughness*n.y,max(0.,n.z)));\n}\n\nvoid ImportanceSampleGGX(vec2 uRand, vec3 wo, float Roughness, vec3 SpecularColor,\n                         out vec3 wi, out vec3 reflectance) {\n    //Importance sampling\n    float a2=Roughness*Roughness;\n    vec3 wm=GgxVndf(wo,Roughness,uRand.x,uRand.y);\n    wi=reflect(-wo,wm);\n    if (wi.z>0.) {\n        vec3 F=SchlickFresnel(SpecularColor,dot(wi, wm));\n        float G1=SmithGGXMasking(wi,wo,a2);\n        float G2=SmithGGXMaskingShadowing(wi,wo,a2);\n        reflectance=F*(G2/G1);\n    } else {\n        reflectance=vec3(0.);\n    }\n}\n\nvec3 SampleSky(vec3 d, vec3 sd) { \n    vec3 L = vec3(0.);\n    L = SkyLight*(1.-0.5*d.y)+SunLight*pow(dot(d,sd)*0.4+0.4,2.);\n    if (d.y>0.) {\n        float dist = -1000./d.y; //1000 brick height\n        vec3 hitp = d*dist;\n        vec2 gridp = floor(hitp.xz*0.001); //500 brick size\n        vec4 glR4 = vec4(ARand21(gridp),ARand21(gridp+vec2(1.,0.)),ARand21(gridp+vec2(0.,1.)),ARand21(gridp+1.));\n        vec2 glfrac = fract(hitp.xz*0.001);\n        float glrv = mix(mix(glR4.x,glR4.y,glfrac.x),mix(glR4.z,glR4.w,glfrac.x),glfrac.y);\n        L += float(glrv<0.4)*3.;\n    }\n    L = mix(SkyLight*0.8+0.2,L,pow(abs(d.y),0.5));\n    //Return\n    return L;\n}\n\n//MODELS\nfloat DFStud(vec3 p) {\n    float d = -smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+0.2,0.075);\n    d = max(-p.y,smin(d,DFDisk(p),0.05));\n    return d;\n}\n\nfloat DFBrick(vec3 p, vec3 BSize) {\n    float d = DFBox(p-vec3(0.04),BSize-vec3(0.08,0.48,0.08))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),BSize-vec3(0.4,-0.4,0.4)));\n    if (min(BSize.x,BSize.z)>1.5) {\n        d = min(d,max(max(max(DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,1.),vec3(0.5,1.,1.))-0.407,\n        -DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,1.),vec3(0.5,1.,1.))+0.3),p.y-(BSize.y-0.45)),-p.y));\n    } else {\n        float tmpLine = DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n        d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),p.y-(BSize.y-0.45)),-p.y));\n    }\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,BSize.x-1.),BSize.y-0.4,clamp(floor(p.z),0.,BSize.z-1.));\n    d = max(d,-max(DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,-0.05,0.5))-0.15,p.y-1.19)); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFBrick_NoStud(vec3 p, vec3 BSize) {\n    float d = DFBox(p-vec3(0.04),BSize-vec3(0.08,0.48,0.08))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),BSize-vec3(0.4,-0.59,0.4)));\n    if (min(BSize.x,BSize.z)>1.5) {\n        d = min(d,max(max(max(DFLine(vec3(fract(clamp(p.x,0.5,3.5)-0.5),p.yz),vec3(0.5,-1.,1.),vec3(0.5,1.,1.))-0.407,\n        -DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,1.),vec3(0.5,1.,1.))+0.3),p.y-(BSize.y-0.45)),-p.y));\n    }\n    return d;\n}\n\nfloat DFGrate(vec3 p) {\n    float d = DFBox(p-vec3(0.02),vec3(1.96,0.36,0.96))-0.02;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.25,0.6)));\n    d = max(d,-DFBox(vec3(p.x+2.,p.y-0.2,fract(p.z*2.5)*0.4-0.2),vec3(8.,1.,0.2)));\n    return d;\n}\n\nfloat DFCorner(vec3 p, float Yi) {\n    float Y = Yi*0.4;\n    float d = min(DFBox(p-vec3(0.02),vec3(1.96,Y-0.04,0.96))-0.02,DFBox(p-vec3(0.02),vec3(0.96,Y-0.04,1.96))-0.02);\n    //Interior\n    d = max(d,-min(DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,0.8+Y,0.6)),DFBox(p-vec3(0.2,-1.,0.2),vec3(0.6,0.8+Y,1.6))));\n    float tmpLine = min(DFLine(vec3(fract(clamp(p.x,0.5,2.-0.5)-0.5),p.yz),vec3(0.5,-1.,0.5),vec3(0.5,0.8+Y,0.5)),\n    DFLine(vec3(p.xy,fract(clamp(p.z,0.5,2.-0.5)-0.5)),vec3(0.5,-1.,0.5),vec3(0.5,0.6+Y,0.5)));\n    d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),p.y-(Y-0.075)),-p.y));\n    //Stud\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,1.),Y,clamp(floor(p.z),0.,1.-floor(p.x)));\n    d = max(d,-max(DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,-0.05,0.5))-0.15,p.y-1.19)); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFRound111(vec3 p) {\n    float d = -smin(smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.5,-p.y+0.4,0.04),p.y-0.3,0.015);\n    d = min(d,max(max(max(DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))-0.397,-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.305)\n    ,p.y-0.35),-p.y));\n    d = max(d,-max(DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))-0.15,p.y-0.39));\n    d = min(d,DFStud(vec3(p.x,p.y-0.4,p.z))); //Stud\n    return d;\n}\n\nfloat DFRound131(vec3 p) {\n    float d = max(max(DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))-0.397,p.y-0.35),-p.y);\n    d = min(d,max(-smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.48,-p.y+1.2,0.05),-p.y+0.2));\n    //Stud\n    d = smin(d,max(-smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.07),-p.y+1.2),0.07);\n    d = -smin(-d,DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))-0.2,0.07);\n    return d;\n}\n\nfloat DFCone131(vec3 p) {\n    float d = max(max(DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))-0.397,p.y-0.35),-p.y);\n    d = min(d,max(-smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+mix(0.48,0.33,p.y-0.2),-p.y+1.2,0.05),-p.y+0.2));\n    //Stud\n    d = smin(d,max(-smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.07),-p.y+1.2),0.04);\n    d = -smin(-d,DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))-0.2,0.07);\n    return d;\n}\n\nfloat DFSlope(vec3 p, float Z) {\n    float d = DFBox(p-vec3(0.02),vec3(1.96,1.16,Z-0.04))-0.02;\n    d = -smin(-d,-smin(-DFBox(p-vec3(0.22,-1.,0.22),vec3(1.56,1.96,Z-0.44))+0.02,-dot(LEGOSlope,p-vec3(1.8,0.2,0.)),0.05),0.02);\n    //Interior\n    if (Z>1.5) {\n        d = min(d,max(max(max(DFLine(vec3(p.xy,fract(clamp(p.z,0.5,Z-0.5)-0.5)),vec3(1.,-1.,0.5),vec3(1.,1.,0.5))-0.407,\n        -DFLine(vec3(p.xy,fract(clamp(p.z,0.5,Z-0.5)-0.5)),vec3(1.,-1.,0.5),vec3(1.,1.,0.5))+0.3),p.y-(1.2-0.05)),-p.y));\n    }\n    d = -smin(-d,-dot(LEGOSlope,p-vec3(2.,0.3,0.)),0.05);\n    vec3 StudPos = vec3(0.,1.2,clamp(floor(p.z),0.,Z-1.));\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFSlope331(vec3 p) {\n    float d = DFBox(p-vec3(0.02),vec3(2.96,1.16,0.96))-0.02;\n    //d = -smin(-d,-smin(-DFBox(p-vec3(0.22,-1.,0.22),vec3(1.56,1.96,Z-0.44))+0.02,-dot(LEGOSlope,p-vec3(1.8,0.2,0.)),0.05),0.02);\n    //Interior\n    //if (Z>1.5) {\n        //d = min(d,max(max(max(DFLine(vec3(p.xy,fract(clamp(p.z,0.5,Z-0.5)-0.5)),vec3(1.,-1.,0.5),vec3(1.,1.,0.5))-0.407,\n        //-DFLine(vec3(p.xy,fract(clamp(p.z,0.5,Z-0.5)-0.5)),vec3(1.,-1.,0.5),vec3(1.,1.,0.5))+0.3),p.y-(1.2-0.05)),-p.y));\n    //}\n    d = -smin(-d,-dot(LEGOSlope331,p-vec3(3.,0.3,0.)),0.05);\n    d = min(d,DFStud(p-vec3(0.,1.2,0.))); //Studs\n    return d;\n}\n\nfloat DFISlope(vec3 p, float Z) {\n    float d = -smin(-DFBox(p-vec3(0.02),vec3(1.96,1.16,Z-0.04))+0.02,-dot(LEGOISlope,p-vec3(1.,0.,0.)),0.03);\n    d = -smin(-d,max(DFBox(p-vec3(1.15,0.2,0.15),vec3(0.75,2.,Z-0.3)),dot(LEGOISlope,p-vec3(1.,0.2,0.))),0.05);\n    //Stud\n    float StudZ = clamp(floor(p.z),0.,Z-1.)+0.5;\n    d = smin(d,-smin(-max(-smin(-DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))+0.3,-p.y+1.4,0.07),-p.y+0.85),\n    DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))-0.2,0.07),0.07);\n    d = min(d,DFStud(p-vec3(0.,1.2,StudZ-0.5))); //Studs\n    return d;\n}\n\nfloat DFOnlySlope(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.1,0.1,0.1),vec3(0.8,0.8,0.8))+0.1,-dot(LEGOOSlope,p-vec3(0.,0.8,0.)),0.06);\n    return d;\n}\n\nfloat DFHeadLight(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.04),vec3(0.92,1.12,0.92))+0.04,DFBox(p-vec3(-1.,0.25,-1.),vec3(1.2,2.,3.)),0.05);\n    //Stud\n    d = smin(d,-smin(-DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))+0.3,p.x,0.07),0.05);\n    d = max(d,-min(DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))-0.2,DFBox(p-vec3(0.2,-1.,0.2),vec3(0.6,1.2,0.6))));\n    d = max(d,-DFBox(p-vec3(0.3,0.2,0.2),vec3(3.,0.8,0.6)));\n    d = min(d,max(-smin(-DFLine(p-vec3(0.,1.2,0.),vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+1.2+0.2,0.075),-p.y+1.2)); //Stud\n    return d;\n}\n\nfloat DFHose(vec3 p) {\n    vec3 rp = p-vec3(0.5,0.,0.5);\n    float lrp = length(rp);\n    float d = -smin(rp.y,-max(lrp-0.45,-lrp+0.35),0.02);\n    d = smin(d,DFLine(p,vec3(0.5,0.45,0.5),vec3(0.5,1.15,0.5))-0.2,0.07);\n    //Stud\n    d = smin(d,-smin(smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.07),p.y-1.2,0.07),0.07);\n    //Arm\n    d = smin(d,DFLine(p,vec3(0.7,0.95,0.5),vec3(1.2,0.95,0.5))-0.2+(p.x-0.7)*0.1,0.1);\n    d = smin(d,max(max(DFLine(p,vec3(0.,0.95,0.5),vec3(3.,0.95,0.5))-0.2,-p.x+1.2),p.x-1.4),0.04);\n    return d;\n}\n\nfloat DFDoubleSlope(vec3 rp, float fi) {\n    vec3 p = vec3(1.+abs(rp.x-1.),rp.yz);\n    float d = DFBox(p-vec3(0.02),vec3(1.96,1.16,fi-0.04))-0.02;\n    d = -smin(-d,-smin(-DFBox(p-vec3(0.22,-1.,0.22),vec3(1.56,1.96,fi-0.44))+0.02,-dot(LEGOSlope,p-vec3(0.8,1.2,0.)),0.05),0.02);\n    d = -smin(-d,-dot(LEGOSlope,p-vec3(1.,1.25,0.)),0.05);\n    return d;\n}\n\nfloat DFRound232(vec3 p) {\n    float dfl = DFLine(p,vec3(1.,-3.,1.),vec3(1.,3.,1.));\n    float d = -smin(smin(-max(dfl-1.,-dfl+0.9),p.y-1.2,0.02),-p.y,0.02);\n    d = -smin(-max(-smin(-dfl+1.,-p.y+1.2,0.1),smin(-dfl+0.9,-p.y+1.,0.92)),p.y,0.04);\n    d = min(d,max(max(max(DFLine(p,vec3(1.,-1.,1.),vec3(1.,1.,1.))-0.407,\n    -DFLine(p,vec3(1.,-1.,1.),vec3(1.,1.,1.))+0.3),p.y-(1.2-0.05)),-p.y));\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,1.),0.,clamp(floor(p.z),0.,1.));\n    d = -smin(-d,DFStud(p-StudPos),0.08); //Studs\n    float ds = max(-p.y+1.16,-smin(-DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.075));\n    d = smin(d,ds,0.04); //Studs\n    //Cross\n    d = -smin(-d,smin(DFBox(p-vec3(0.925,-1.,0.8),vec3(0.15,4.,0.4)),\n              DFBox(p-vec3(0.8,-1.,0.925),vec3(0.4,4.,0.15)),0.04)-0.02,0.08);\n    return d;\n}\n\nfloat DFPanel(vec3 p) {\n    float d = DFBox(p-vec3(0.04),vec3(1.92,0.32,0.92))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.2,0.6)));\n    d = min(d,DFBox(p-vec3(0.05,0.05,0.05),vec3(1.9,1.1,0.))-0.05);\n    return d;\n}\n\nfloat DFWindow(vec3 p, float S) {\n    float Size = S*2.;\n    float YSize = 1.2+S*1.2;\n    float d = DFBox(p-vec3(0.04),vec3(Size-0.08,YSize-0.08,0.92))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(Size-0.4,1.2,0.6))); //Under\n    //Under\n    float tmpLine = DFLine(vec3(fract(clamp(p.x,0.5,Size-0.5)-0.5),p.yz),vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n    d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),p.y-(0.2)),-p.y));\n    //Window\n    d = max(d,-DFBox(p-vec3(0.2,0.4,-1.),vec3(Size-0.4,YSize-0.6,3.)));\n        d = max(d,-DFBox(p-vec3(0.1,0.4,0.6),vec3(Size-0.2,YSize-0.6,3.)));\n    //Stud\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,Size-1.),YSize,0.);\n    d = min(d,DFStud(p-StudPos)); //Studs\n    vec3 linep = vec3(mod(p.x,3.3)-(1.65-0.65*S),p.y-0.4,p.z-0.7);\n    d = max(d,-DFLine(linep,vec3(0.),vec3(0.,4.,0.))+0.1*S);\n    return d;\n}\n\nfloat DFWindowFrame(vec3 p) {\n    float d = DFBox(p-vec3(0.18,0.08,0.08),vec3(1.64,2.84,0.04))-0.08;\n    d = smin(d,DFLine(p,vec3(0.1,0.1,0.1),vec3(vec3(0.1,2.9,0.1)))-0.1,0.1);\n    //Window boxes\n    //d = max(d,-DFBox(p-vec3(0.2,0.15+floor(p.y/1.2)*0.,-1.),vec3(1.55,1.2-0.15-0.15,3.))-0.02);\n    d = max(d,-DFBox(p-vec3(0.2,0.25+floor(p.y/1.5)*1.425,-1.),vec3(1.55,1.1,3.))-0.02);\n    d = min(d,DFBox(p-vec3(0.08,0.08+floor(p.y/2.75)*2.75,0.08),vec3(0.3,0.1,0.1))-0.08);\n    return d;\n}\n\nfloat DFBrickHole(vec3 p) {\n    float d = DFBox(p-vec3(0.04),vec3(0.92,1.12,0.92))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(0.4,1.2,0.4)));\n    d = -smin(-d,DFLine(p,vec3(-5.,0.7,0.5),vec3(5.,0.7,0.5))-0.4,0.08);\n    d = min(d,DFStud(p-vec3(0.,1.2,0.)));\n    return d;\n}\n\nfloat DFHandle(vec3 p, float type) {\n    //Symmetric through the x-axis\n    vec3 syp = vec3(p.xy,abs(p.z-1.));\n    float d = DFBox(syp-vec3(0.04,0.04,-0.96),vec3(0.92,0.32,1.92))-0.04;\n    //Handle\n    float Z = type*0.4;\n    float tmpCyl = length(syp.xy-vec2(1.5,0.3));\n    d = min(d,DFBox(syp-vec3(0.04,0.04,0.74-Z),vec3(1.46,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-tmpCyl+0.3,1.-Z-syp.z,0.04),syp.z-0.7+Z,0.04));\n    d = min(d,max(tmpCyl-0.2,syp.z-1.));\n    //Interior + Stud\n    d = max(d,-DFBox(syp-vec3(0.2,-1.,-0.8),vec3(0.6,1.2,1.6)));\n    float tmpLine = min(DFLine(vec3(syp.xy,syp.z+0.5),vec3(0.5,-1.,0.5),vec3(0.5,1.2,0.5)),\n    DFLine(vec3(syp.xy,syp.z+0.5),vec3(0.5,-1.,0.5),vec3(0.5,0.6,0.5)));\n    d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),syp.y-(0.4-0.075)),-syp.y));\n    d = max(d,-max(DFLine(syp,vec3(0.5,-1.,0.5),vec3(0.5,0.35,0.5))-0.15,syp.y-1.19)); //Hole under stud\n    d = min(d,DFStud(syp-vec3(0.,0.4,0.))); //Studs\n    return d;\n}\n\nfloat DFGrip(vec3 p) {\n    float d = DFBox(p-vec3(0.04,0.44,0.04),vec3(0.92,0.32,0.92))-0.04;\n    //Grip\n    d = min(d,DFBox(p-vec3(0.04,0.44,0.39),vec3(1.36,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-length(p.xy-vec2(1.45,0.68))+0.37,-p.z+0.65,0.04),-0.35+p.z,0.04));\n    d = max(d,-length(p.xy-vec2(1.5,0.7))+0.2);\n    d = -smin(-d,1.62-p.x,0.08);\n    //Stud\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(0.6,1.6,0.6)));\n    vec3 StudPos = vec3(0.,0.8,0.);\n    d = max(d,-max(DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))-0.15,p.y-0.75)); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFDisk(vec3 p, float radius) {\n    //(0.4-y)^2 = 1+(0.1-y)^2\n    //(0.8-y)^2 = 2.25+(0.1-y)^2\n    float d;\n    float sY = ((radius<1.5)?-1.41667:-1.375);\n    if (radius<1.5) {\n        float LenMiddle = length(p.xz-1.);\n        d = max(max(length(p-vec3(1.,sY,1.))-(-sY+0.4),\n             -length(p-vec3(1.,sY-0.1,1.))+(-sY+0.4)),LenMiddle-1.);\n        d = smin(d,max(-p.y,-smin(-DFLine(p,vec3(1.,-1.,1.),\n             vec3(1.,1.,1.))+0.3,-p.y+0.6,0.075)),0.04); //Stud\n        d = min(d,max(max(LenMiddle-0.4,-p.y),p.y-0.35));\n        //Holes\n        d = -smin(-d,LenMiddle-0.2,0.05);\n        d = max(d,-max(p.y+0.05-0.4*radius,LenMiddle-0.3));\n    } else {\n        float LenMiddle = length(p.xz-1.5);\n        d = max(max(length(p-vec3(1.5,sY,1.5))-(-sY+0.8),\n             -length(p-vec3(1.5,sY-0.1,1.5))+(-sY+0.8)),LenMiddle-1.5);\n        d = min(d,max(-p.y,max(p.y-0.2,abs(LenMiddle-1.4)-0.1)));\n        d = smin(d,max(-p.y+0.4,-smin(-DFLine(p,vec3(1.5,-1.,1.5),\n             vec3(1.5,1.,1.5))+0.3,-p.y+1.,0.075)),0.04); //Stud\n        d = min(d,max(max(LenMiddle-0.4,-p.y+0.4),p.y-0.75));\n        //Holes\n        d = -smin(-d,LenMiddle-0.2,0.05);\n        d = max(d,-max(p.y+0.05-0.8,LenMiddle-0.3));\n    }\n    return d;\n}\n\nfloat DFDoor(vec3 p) {\n    //~Model 3861\n    float d = DFBox(p-vec3(0.48,0.42,0.02),vec3(3.46,7.16,0.16))-0.02;\n    //Ornament\n    d = -smin(-d,DFBox(p-vec3(0.75,0.6,-1.),vec3(2.5,2.6,1.15)),0.1);\n    d = min(d,DFBox(p-vec3(1.15,1.,0.),vec3(1.7,1.8,0.15)));\n    //Window\n    d = -smin(-d,DFBox(p-vec3(0.75,4.,-1.),vec3(2.5,2.5,1.1)),0.1);\n        d=-smin(-d,DFBox(vec3(abs(p.x-2.),abs(p.y-5.25),p.z+1.)-vec3(0.125,0.125,0.),vec3(1.,1.,3.)),0.1);\n    //Handle\n    d = min(d,DFLine(p,vec3(3.5,3.6,0.),vec3(3.2,3.6,0.))-0.15);\n    //Vertical cylinder\n    d = min(d,max(max(DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,10.,0.5))-0.5,p.y-7.2),-p.y));\n    return d;\n}\n\nfloat DFSlopeCross(vec3 p) {\n    return smin(DFSlope(p,2.),DFSlope(p.zyx,2.),0.04);\n}\n\nfloat DFDoubleSlopeInverse(vec3 p) {\n    return -smin(-DFDoubleSlope(p,2.),dot(vec3(0.,LEGOSlope.y,-LEGOSlope.x),p-vec3(0.,0.1,1.)),0.1);\n}\n\nfloat DFWindowOblique(vec3 p) {\n    float DOT0 = dot(LEGOObliqueSlope,p-vec3(0.,0.4,4.));\n    float DOT1 = dot(LEGOObliqueSlope,p-vec3(0.,0.,3.));\n    float d = DFBox(p-vec3(0.04,0.04,0.04),vec3(3.92,3.52,3.92))-0.04;\n    d = max(d,-DFBox(p-vec3(0.24,0.44,-5.),vec3(3.52,2.72,10.))+0.04);\n    d = -smin(-d,DOT0,0.05);\n    d = -smin(-d,-DOT1,0.05);\n    //Interior\n    d = min(d,max(max(DFBox(p-vec3(0.,0.4,0.),vec3(4.,0.8,4.)),-DOT0+0.1),DOT1+0.8));\n        d = min(d,max(max(max(DFBox(p-vec3(0.,1.2,0.),vec3(4.,2.4,4.)),1.6-abs(p.x-2.)),-DOT0+0.4),DOT1+0.5));\n    d = max(d,-DFLine(p,vec3(-1.,3.,1.4),vec3(5.,3.,1.4))+0.1);\n    d = max(d,-DFLine(p,vec3(-1.,1.2,2.9),vec3(5.,1.2,2.9))+0.1);\n    //Studs\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,3.),3.6,0.);\n    d = min(d,DFStud(p-StudPos));\n    return d;\n}\n\nvec3 TraceBrick(vec3 BRPos, vec3 BRDir, vec3 CBrickSize, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFBrick(biRP,CBrickSize);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>CBrickSize.y-0.201) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceBrick_NoStud(vec3 BRPos, vec3 BRDir, vec3 CBrickSize, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFBrick_NoStud(biRP,CBrickSize);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceGrate(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFGrate(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceCorner(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFCorner(biRP,fi);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>1.399) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceRound111(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFRound111(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>0.599) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceRound131(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFRound131(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceCone131(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFCone131(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceSlope(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFSlope(biRP,fi);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>1.399) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceSlope331(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFSlope331(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>1.399) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceISlope(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFISlope(biRP,fi);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>1.399 && biRP.x<1.) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceOnlySlope(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFOnlySlope(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceHeadLight(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFHeadLight(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>1.399) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceHose(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFHose(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceDoubleSlope(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFDoubleSlope(biRP,fi);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceRound232(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFRound232(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TracePanel(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFPanel(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceWindow(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFWindow(biRP,fi);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>2.599+1.2*(fi-1.)) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceWindowFrame(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFWindowFrame(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceBrickHole(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFBrickHole(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>1.399) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceDoor(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFDoor(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceHandle(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFHandle(biRP,fi);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>0.599) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceGrip(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFGrip(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>0.599) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceDisk(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFDisk(biRP,fi);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceSlopeCross(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFSlopeCross(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>1.399) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nvec3 TraceDoubleSlopeInverse(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFDoubleSlopeInverse(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    return OUT;\n}\n\nvec3 TraceWindowOblique(vec3 BRPos, vec3 BRDir, float fi, float biFAR) {\n    vec3 OUT = vec3(0.,-1.,-1.); float bit; vec3 biRP;\n    for (int i=0; i<400; i++) {\n        biRP = BRPos+BRDir*OUT.x;\n        bit = DFWindowOblique(biRP);\n        OUT.x = OUT.x+bit;\n        if (min(biFAR-OUT.x,bit-0.0005)<0.) break;\n    }\n    if (biRP.y>3.799) OUT.yz = fract(biRP.xz);\n    return OUT;\n}\n\nfloat DF32x32(vec3 sp) {\n    //32x32 floor SDF\n    float tmpd = DFBox(sp.xz-0.25,vec2(31.75))-0.25;\n    vec2 tmpw = vec2(tmpd,abs(sp.y));\n    float d = min(min(max(tmpw.x,tmpw.y),0.)+length(max(tmpw,0.)),DFStud(vec3(fract(sp.x),sp.y,fract(sp.z))));\n        //d = min(d,DFDoubleSlope(sp-vec3(0.,0.4,0.),1.)); //DEBUG\n    return d;\n}\n\n//BrickDim array\nfloat BrickADim[7]=float[7](1.,2.,3.,4.,6.,8.,10.);\nvec3 BrickDim[42]=vec3[42](\n    vec3(2.,0.8,1.), //DFGrate\n    vec3(2.,0.8,2.), //DFCorner 2x1x2\n    vec3(2.,1.2,2.), //DFCorner 2x2x2\n    vec3(2.,1.6,2.), //DFCorner 2x3x2\n    vec3(1.,0.8,1.), //Round111\n    vec3(1.,1.6,1.), //Round131\n    vec3(1.,1.6,1.), //Cone131\n    vec3(2.,1.6,1.), //Slope 2x3x1\n    vec3(2.,1.6,2.), //Slope 2x3x2\n    vec3(2.,1.6,3.), //Slope 2x3x3\n    vec3(2.,1.6,4.), //Slope 2x3x4\n    vec3(2.,1.6,5.), //Slope 2x3x5\n    vec3(2.,1.6,6.), //Slope 2x3x6\n    vec3(2.,1.6,7.), //Slope 2x3x7\n    vec3(2.,1.6,8.), //Slope 2x3x8\n    vec3(3.,1.6,1.), //DFSlope331\n    vec3(2.,1.6,1.), //DFISlope 2x3x1\n    vec3(2.,1.6,2.), //DFISlope 2x3x2\n    vec3(1.,0.8,1.), //DFOnlySlope\n    vec3(1.,1.6,1.), //DFHeadLight\n    vec3(2.,1.6,1.), //DFHose\n    vec3(2.,1.2,1.), //DFDoubleSlope\n    vec3(2.,1.2,2.), //DFDoubleSlope\n    vec3(2.,1.2,3.), //DFDoubleSlope\n    vec3(2.,1.2,4.), //DFDoubleSlope\n    vec3(2.,1.2,5.), //DFDoubleSlope\n    vec3(2.,1.2,6.), //DFDoubleSlope\n    vec3(2.,1.6,2.), //DFRound232\n    vec3(2.,1.2,1.), //DFPanel\n    vec3(2.,2.8,1.), //DFWindow 2x2x1\n    vec3(4.,5.2,1.), //DFWindow 4x4x1\n    vec3(2.,3.,1.), //DFWindowPanel\n    vec3(1.,1.6,1.), //DFBrickHole\n    vec3(4.,7.2,1.), //DFDoor\n    vec3(2.,0.8,2.), //DFHandle 1 Handle\n    vec3(2.,0.8,2.), //DFHandle 3 Handle\n    vec3(2.,1.2,1.), //DFGrip\n    vec3(2.,0.8,2.), //DFDisk R = 1\n    vec3(3.,1.2,3.), //DFDisk R = 1.5\n    vec3(2.,1.6,2.), //DFSlopeCross\n    vec3(2.,1.2,2.), //DFDoubleSlopeInverse\n    vec3(4.,4.,4.) //DFWindowOblique\n);\n\nfloat USDF(vec3 p, int i, float fi, vec3 BrickSize) {\n    //Unified SDF (visualizes indices)\n    /*\n    if (i<28) return DFBrick(p,BrickSize);\n    else if (i<56) return DFBrick_NoStud(p,BrickSize);\n    else if (i==56) return DFGrate(p);\n    else if (i<=59) return DFCorner(p,fi-56.);\n    else if (i==60) return DFRound111(p);\n    else if (i==61) return DFRound131(p);\n    else if (i==62) return DFCone131(p);\n    else if (i<=70) return DFSlope(p,fi-62.);\n    else if (i==71) return DFSlope331(p);\n    else if (i<=73) return DFISlope(p,fi-71.);\n    else if (i==74) return DFOnlySlope(p);\n    else if (i==75) return DFHeadLight(p);\n    else if (i==76) return DFHose(p);\n    else if (i<82) return DFDoubleSlope(p,fi-76.);\n    else if (i==83) return DFRound232(p);\n    else if (i==84) return DFPanel(p);\n    else if (i<=86) return DFWindow(p,fi-84.);\n    else if (i==87) return DFWindowFrame(p);\n    else if (i==88) return DFBrickHole(p);\n    else if (i==89) return DFDoor(p);\n    else if (i<=91) return DFHandle(p,fi-90.);\n    else if (i==92) return DFGrip(p);\n    else if (i<=94) return DFDisk(p,fi-92.);\n    else if (i==95) return DFSlopeCross(p);\n    else if (i==96) return DFDoubleSlopeInverse(p);\n    else if (i==97) return DFWindowOblique(p);\n    */\n    return 1000.;\n}\n\n//Brick array\n//Colors: //White,Yellow,Brown,Black,Red,Blue,Beige,Orange,LightBlack,LightGreen,Grey,DarkGrey,TrueYellow\nconst vec3 BrickColorArray[13] = vec3[13](vec3(0.99),vec3(1.,0.7,0.2),vec3(0.25,0.12,0.03),vec3(0.05),\n    vec3(0.99,0.05,0.05),vec3(0.05,0.05,0.95),vec3(0.7,0.6,0.1),vec3(0.8,0.6,0.3),\n    vec3(0.2),vec3(0.15,0.99,0.15),vec3(0.5),vec3(0.35),vec3(1.,1.,0.1)\n);\nconst vec3 GarageY = normalize(vec3(0.,cos(radians(30.)),sin(radians(30.))));\nconst vec3 GarageRotP = vec3(21.,5.9,11.7);\nconst vec3 StairX = normalize(vec3(cos(radians(65.)),sin(radians(65.)),0.));\nconst vec3 StairY = vec3(-StairX.y,StairX.x,0.);\nconst vec3 StairRotP = vec3(19.5,8.3,24.);\nconst vec3 LampZ = normalize(vec3(0.,1.,-1.));\nconst vec3 LampY = vec3(0.,LampZ.z,-LampZ.y);\nconst vec3 LampRotP = vec3(24.5,9.5,11.5);\nconst vec3 DiskX = normalize(vec3(1.,1.,0.));\nconst vec3 DiskY = vec3(-DiskX.y,DiskX.x,0.);\nconst vec3 DiskRotP = vec3(20.4,12.2,15.5);\nconst int NBricks = 128;\nconst BRICK BrickArray[NBricks]=BRICK[NBricks](\n    //2 lightgreen 214\n    BRICK(vec3(2.,0.,14.),vec3(0.,0.,1.),9,10),\n        BRICK(vec3(32.,0.,14.),vec3(0.,0.,1.),9,10),\n    //2 lightgreen 212+211+dark filter\n    BRICK(vec3(32.,0.,12.),vec3(0.,0.,1.),9,8),\n        BRICK(vec3(32.,0.,10.),vec3(0.,0.,1.),9,1),\n    BRICK(vec3(29.,0.,10.),vec3(1.,0.,0.),8,56),\n    //Grey walls (garage)\n    BRICK(vec3(31.,0.,11.),vec3(0.,0.,1.),10,61),\n    BRICK(vec3(30.,0.,11.),vec3(0.,0.,1.),10,18),\n        BRICK(vec3(30.,0.,17.),vec3(0.,0.,1.),10,15),\n        BRICK(vec3(30.,0.,19.),vec3(0.,0.,1.),10,18),\n    BRICK(vec3(30.,0.,27.),vec3(-1.,0.,0.),10,59),\n    //3 grey bricks behind + filter\n    BRICK(vec3(22.,0.,26.),vec3(1.,0.,0.),10,18),\n        BRICK(vec3(16.,0.,26.),vec3(1.,0.,0.),10,18),\n        BRICK(vec3(10.,0.,26.),vec3(1.,0.,0.),10,18),\n    BRICK(vec3(10.,0.,25.),vec3(0.,0.,1.),8,56),\n    //Grey bricks forward and side + under door\n    BRICK(vec3(11.,0.,24.),vec3(0.,0.,1.),10,15),\n        BRICK(vec3(11.,0.,18.),vec3(0.,0.,1.),10,18),\n    BRICK(vec3(10.,0.,17.),vec3(1.,0.,0.),10,16), //beyond door\n        BRICK(vec3(17.,0.,17.),vec3(1.,0.,0.),10,16),\n        BRICK(vec3(21.,0.,15.),vec3(0.,0.,1.),10,16),\n        BRICK(vec3(20.,0.,13.),vec3(1.,0.,0.),10,64), //Slope 2x3x2\n    BRICK(vec3(15.,0.,15.),vec3(0.,0.,1.),10,9), //Under Door\n        BRICK(vec3(17.,0.,15.),vec3(0.,0.,1.),10,9),\n    //In to garage (grey)\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n        BRICK(vec3(22.,0.,6.),vec3(0.,0.,1.),10,32),\n        BRICK(vec3(23.,0.,6.),vec3(0.,0.,1.),10,32),\n        BRICK(vec3(22.,0.,0.),vec3(0.,0.,1.),10,32),\n        BRICK(vec3(23.,0.,0.),vec3(0.,0.,1.),10,32),\n    BRICK(vec3(27.,0.,12.),vec3(1.,0.,0.),10,29),\n        BRICK(vec3(28.,0.,6.),vec3(0.,0.,1.),10,32),\n        BRICK(vec3(29.,0.,6.),vec3(0.,0.,1.),10,32),\n        BRICK(vec3(28.,0.,0.),vec3(0.,0.,1.),10,32),\n        BRICK(vec3(29.,0.,0.),vec3(0.,0.,1.),10,32),\n    //Grey at garage + yellow at door entrance + trappsteg\n    BRICK(vec3(21.,0.,11.),vec3(0.,0.,1.),10,15),\n    BRICK(vec3(18.,0.,15.),vec3(0.,0.,1.),1,29),\n        BRICK(vec3(13.,0.,15.),vec3(0.,0.,1.),1,29),\n        BRICK(vec3(12.,0.,14.),vec3(1.,0.,0.),1,32),\n    BRICK(vec3(14.,0.,12.),vec3(1.,0.,0.),1,29),\n        BRICK(vec3(14.,0.,10.),vec3(1.,0.,0.),1,29),\n        BRICK(vec3(14.,0.,8.),vec3(1.,0.,0.),1,29),\n        BRICK(vec3(13.,0.,6.),vec3(1.,0.,0.),1,29),\n        BRICK(vec3(12.,0.,4.),vec3(1.,0.,0.),1,29),\n        BRICK(vec3(11.,0.,2.),vec3(1.,0.,0.),1,29),\n        BRICK(vec3(10.,0.,0.),vec3(1.,0.,0.),1,29),\n    //Cones + 2 flowers + 4 base\n    BRICK(vec3(9.,0.,17.),vec3(1.,0.,0.),1,62), //Cone\n        BRICK(vec3(8.,0.,17.),vec3(1.,0.,0.),1,62),\n        BRICK(vec3(9.,0.,20.),vec3(1.,0.,0.),1,62),\n        BRICK(vec3(8.,0.,20.),vec3(1.,0.,0.),1,62),\n    BRICK(vec3(4.,0.,19.),vec3(1.,0.,0.),4,60),\n        BRICK(vec3(3.,0.,21.),vec3(1.,0.,0.),4,60),\n    BRICK(vec3(2.,0.,19.),vec3(1.,0.,0.),2,74),\n        BRICK(vec3(1.,0.,20.),vec3(-1.,0.,0.),2,74), //Onlyslope\n        BRICK(vec3(1.,0.,19.),vec3(0.,0.,-1.),2,74),\n        BRICK(vec3(2.,0.,20.),vec3(0.,0.,1.),2,74),\n    //Table + door front\n    BRICK(vec3(10.,1.2,17.),vec3(0.,0.,1.),2,31), //Table\n        BRICK(vec3(9.,1.2,17.),vec3(0.,0.,1.),2,31),\n    BRICK(vec3(17.,0.4,15.),vec3(0.,0.,1.),1,29),\n        BRICK(vec3(14.,0.4,15.),vec3(0.,0.,1.),1,29),\n        BRICK(vec3(14.,0.4,15.),vec3(1.,0.,0.),1,29),\n        BRICK(vec3(14.,0.4,16.),vec3(1.,0.,0.),8,56),\n    //H=1.2 grey walls\n    BRICK(vec3(31.,1.2,11.),vec3(0.,0.,1.),10,61), //Round 131\n    BRICK(vec3(30.,1.2,11.),vec3(0.,0.,1.),10,20),\n        BRICK(vec3(30.,1.2,21.),vec3(0.,0.,1.),10,16), //3x3x1\n        BRICK(vec3(30.,1.2,24.),vec3(0.,0.,1.),10,15), //2x3x1\n    BRICK(vec3(27.,1.2,26.),vec3(1.,0.,0.),10,16), //3x3x1 behind\n        BRICK(vec3(21.,1.2,26.),vec3(1.,0.,0.),10,18),\n        BRICK(vec3(11.,1.2,26.),vec3(1.,0.,0.),10,20),\n        BRICK(vec3(10.,1.2,26.),vec3(1.,0.,0.),3,75),\n    //Rest of the wall + hose\n    BRICK(vec3(11.,1.2,23.),vec3(0.,0.,1.),10,16),\n        BRICK(vec3(11.,1.2,17.),vec3(0.,0.,1.),10,18),\n    BRICK(vec3(11.,1.2,17.),vec3(1.,0.,0.),10,15),\n        BRICK(vec3(17.,1.2,17.),vec3(1.,0.,0.),10,15),\n        BRICK(vec3(19.,1.2,17.),vec3(1.,0.,0.),10,15),\n        BRICK(vec3(21.,1.2,11.),vec3(0.,0.,1.),10,18),\n    BRICK(vec3(10.2,2.3,27.1),vec3(0.,-270.9682,-0.25),10,76),\n    //Flowers on round232\n    BRICK(vec3(18.,0.,12.),vec3(1.,0.,0.),2,83),\n        BRICK(vec3(18.,1.2,12.),vec3(1.,0.,0.),9,60),\n        BRICK(vec3(18.,1.2,13.),vec3(1.,0.,0.),9,60),\n        BRICK(vec3(19.,1.2,12.),vec3(1.,0.,0.),9,60),\n        BRICK(vec3(19.,1.2,13.),vec3(1.,0.,0.),9,60),\n            BRICK(vec3(18.,1.6,12.),vec3(1.,0.,0.),12,60),\n            BRICK(vec3(18.,1.6,13.),vec3(1.,0.,0.),4,60),\n            BRICK(vec3(19.,1.6,12.),vec3(1.,0.,0.),4,62),\n            BRICK(vec3(19.,1.6,13.),vec3(1.,0.,0.),12,62),\n    BRICK(vec3(2.,0.,15.),vec3(1.,0.,0.),2,83),\n        BRICK(vec3(2.,1.2,15.),vec3(1.,0.,0.),4,60),\n        BRICK(vec3(3.,1.2,15.),vec3(1.,0.,0.),4,60),\n        BRICK(vec3(2.,1.2,16.),vec3(1.,0.,0.),4,60),\n    //Bush garage\n    BRICK(vec3(32.,0.,6.),vec3(0.,0.,1.),2,3),\n        BRICK(vec3(32.,0.4,9.),vec3(-1.,0.,0.),9,73),\n            BRICK(vec3(32.,0.4,9.),vec3(0.,0.,1.),9,72),\n            BRICK(vec3(31.,0.4,7.),vec3(0.,0.,-1.),9,72),\n        BRICK(vec3(32.,1.6,10.),vec3(-1.,0.,0.),9,64),\n            BRICK(vec3(31.,1.6,8.),vec3(0.,0.,-1.),9,63),\n        BRICK(vec3(31.,1.6,5.),vec3(1.,0.,0.),12,60),\n            BRICK(vec3(30.,1.6,7.),vec3(1.,0.,0.),12,60),\n            BRICK(vec3(31.,1.6,10.),vec3(1.,0.,0.),12,60),\n    //Bush behind house\n    BRICK(vec3(3.,0.,28.),vec3(1.,0.,0.),2,3),\n        BRICK(vec3(4.,0.4,29.),vec3(0.,0.,-1.),9,73),\n            BRICK(vec3(6.,0.4,28.),vec3(1.,0.,0.),9,72),\n            BRICK(vec3(4.,0.4,29.),vec3(-1.,0.,0.),9,72),\n        BRICK(vec3(3.,1.6,29.),vec3(0.,0.,-1.),9,64),\n            BRICK(vec3(5.,1.6,28.),vec3(1.,0.,0.),9,63),\n        BRICK(vec3(7.,1.6,28.),vec3(1.,0.,0.),12,60),\n            BRICK(vec3(5.,1.6,27.),vec3(1.,0.,0.),12,60),\n            BRICK(vec3(2.,1.6,28.),vec3(1.,0.,0.),12,60),\n    //Small round + Red layer\n    BRICK(vec3(31.,2.4,11.),vec3(0.,0.,1.),10,60),\n    BRICK(vec3(30.,2.4,11.),vec3(0.,0.,1.),4,5),\n        BRICK(vec3(30.,2.4,19.),vec3(0.,0.,1.),4,5),\n    BRICK(vec3(26.,2.4,26.),vec3(1.,0.,0.),4,2),\n        BRICK(vec3(18.,2.4,26.),vec3(1.,0.,0.),4,5),\n        BRICK(vec3(10.,2.4,26.),vec3(1.,0.,0.),4,5),\n    BRICK(vec3(11.,2.4,18.),vec3(0.,0.,1.),4,5),\n    BRICK(vec3(10.,2.4,17.),vec3(1.,0.,0.),4,2),\n        BRICK(vec3(17.,2.4,17.),vec3(1.,0.,0.),4,2),\n        BRICK(vec3(20.,2.4,17.),vec3(1.,0.,0.),4,60),\n    BRICK(vec3(21.,2.4,14.),vec3(0.,0.,1.),4,2),\n        BRICK(vec3(21.,2.4,11.),vec3(0.,0.,1.),4,2),\n    //First white layer\n    BRICK(vec3(30.,2.8,11.),vec3(0.,0.,1.),0,17),\n        BRICK(vec3(30.,2.8,15.),vec3(0.,0.,1.),0,18),\n        BRICK(vec3(30.,2.8,21.),vec3(0.,0.,1.),0,18),\n    BRICK(vec3(23.,2.8,26.),vec3(1.,0.,0.),0,18),\n        BRICK(vec3(17.,2.8,26.),vec3(1.,0.,0.),0,18),\n        BRICK(vec3(11.,2.8,26.),vec3(1.,0.,0.),0,18),\n    BRICK(vec3(11.,2.8,24.),vec3(0.,0.,1.),0,16),\n        BRICK(vec3(11.,2.8,20.),vec3(0.,0.,1.),0,3),\n        BRICK(vec3(11.,3.2,20.),vec3(0.,0.,1.),0,3),\n    //Rest of first white layer + post bottom\n    BRICK(vec3(11.,2.8,17.),vec3(0.,0.,1.),0,16),\n    BRICK(vec3(11.,2.8,17.),vec3(1.,0.,0.),0,1)\n);\n\nconst BRICK BrickArray1[NBricks]=BRICK[NBricks](\n    BRICK(vec3(17.,2.8,17.),vec3(1.,0.,0.),0,17),\n        BRICK(vec3(21.,2.8,11.),vec3(0.,0.,1.),0,18),\n    //Window base + 2 round131 + Second white layer\n    BRICK(vec3(11.,3.6,20.),vec3(0.,0.,1.),8,10),\n        BRICK(vec3(10.,4.,20.),vec3(0.,0.,1.),10,31),\n    BRICK(vec3(31.,2.8,11.),vec3(0.,0.,1.),10,61),\n        BRICK(vec3(31.,4.,11.),vec3(0.,0.,1.),10,61),\n    BRICK(vec3(30.,4.,11.),vec3(0.,0.,1.),0,16),\n        BRICK(vec3(30.,4.,14.),vec3(0.,0.,1.),0,15),\n        BRICK(vec3(30.,4.,16.),vec3(0.,0.,1.),0,20),\n    BRICK(vec3(20.,4.,26.),vec3(1.,0.,0.),0,20),\n        BRICK(vec3(10.,4.,26.),vec3(1.,0.,0.),0,20),\n    BRICK(vec3(11.,4.,24.),vec3(0.,0.,1.),0,15),\n    //Rest of second white layer + Post red\n    BRICK(vec3(11.,4.,17.),vec3(0.,0.,1.),0,16), //1x3x3 near window\n    BRICK(vec3(21.,4.,11.),vec3(0.,0.,1.),0,16),\n        BRICK(vec3(21.,4.,14.),vec3(0.,0.,1.),0,17),\n        BRICK(vec3(17.,4.,17.),vec3(1.,0.,0.),0,16),\n    BRICK(vec3(11.,3.2,16.),vec3(1.,0.,0.),4,8),\n    //Drain cross + third white layer\n    BRICK(vec3(31.,5.2,13.),vec3(-1.,0.,0.),10,57), //Cross\n        BRICK(vec3(30.,5.2,12.),vec3(-1.,0.,0.),0,0), //White 1x1x1\n    BRICK(vec3(30.,5.2,13.),vec3(0.,0.,1.),0,15),\n        BRICK(vec3(30.,5.2,15.),vec3(0.,0.,1.),0,18),\n        BRICK(vec3(30.,5.2,21.),vec3(0.,0.,1.),0,18),\n    BRICK(vec3(23.,5.2,26.),vec3(1.,0.,0.),0,18),\n        BRICK(vec3(17.,5.2,26.),vec3(1.,0.,0.),0,18),\n        BRICK(vec3(11.,5.2,26.),vec3(1.,0.,0.),0,18),\n    BRICK(vec3(11.,5.2,24.),vec3(0.,0.,1.),0,16),\n        BRICK(vec3(11.,5.2,18.),vec3(0.,0.,1.),0,15),\n    //Post panels + post roof\n    BRICK(vec3(13.,3.6,16.),vec3(0.,0.,1.),4,84),\n        BRICK(vec3(11.,3.6,18.),vec3(0.,0.,-1.),4,84),\n    BRICK(vec3(11.,4.8,16.),vec3(1.,0.,0.),4,8), //Red roof\n        BRICK(vec3(11.,5.2,16.),vec3(1.,0.,0.),4,29),\n        BRICK(vec3(10.,5.2,17.),vec3(1.,0.,0.),0,16),\n    BRICK(vec3(17.,5.2,17.),vec3(1.,0.,0.),0,17), //White to the small window\n        BRICK(vec3(21.,5.2,15.),vec3(0.,0.,1.),0,15),\n        BRICK(vec3(21.,5.2,11.),vec3(0.,0.,1.),0,1),\n    //Small window + 4th white layer\n    BRICK(vec3(21.,5.2,13.),vec3(0.,0.,1.),1,85), //Small window\n        BRICK(vec3(21.,6.4,15.),vec3(0.,0.,1.),0,17), //4x1x1\n    BRICK(vec3(30.,6.4,13.),vec3(0.,0.,1.),0,16),\n        BRICK(vec3(30.,6.4,16.),vec3(0.,0.,1.),0,20),\n    BRICK(vec3(27.,6.4,26.),vec3(1.,0.,0.),0,16),\n        BRICK(vec3(21.,6.4,26.),vec3(1.,0.,0.),0,18),\n        BRICK(vec3(20.,6.4,27.),vec3(0.,0.,-1.),0,72), //Inverse slope\n    //End of 4th white layer + big window\n    BRICK(vec3(10.,6.4,26.),vec3(1.,0.,0.),0,20),\n    BRICK(vec3(11.,6.4,24.),vec3(0.,0.,1.),0,15),\n        BRICK(vec3(11.,4.,20.),vec3(0.,0.,1.),1,86), //Big window\n            BRICK(vec3(10.4,4.4,20.1),vec3(0.,0.,1.),0,87),\n            BRICK(vec3(10.4,7.4,23.65),vec3(-0.707,180.,-0.707),0,87),\n        BRICK(vec3(11.,6.4,17.),vec3(0.,0.,1.),0,16),\n    BRICK(vec3(11.,6.4,17.),vec3(1.,0.,0.),0,15),\n        BRICK(vec3(17.,6.4,17.),vec3(1.,0.,0.),0,14),\n        BRICK(vec3(19.,6.4,17.),vec3(0.,0.,1.),3,75),\n        BRICK(vec3(19.,6.4,17.),vec3(1.,0.,0.),0,14),\n    //Garage door\n    BRICK(GarageRotP-GarageY*5.2,vec3(1.,30.,0.),4,5),\n        BRICK(GarageRotP-GarageY*4.8,vec3(1.,30.,0.),4,16),\n            BRICK(GarageRotP-GarageY*4.8-vec3(-5.,0.,0.),vec3(1.,30.,0.),4,16),\n        BRICK(GarageRotP-GarageY*4.8-vec3(-4.,0.,0.),vec3(GarageY.x,-GarageY.z,GarageY.y),3,75),\n            BRICK(GarageRotP-GarageY*4.8-vec3(-5.,0.,0.),vec3(GarageY.x,-GarageY.z,GarageY.y),3,75),\n        BRICK(GarageRotP-GarageY*3.6-vec3(-5.,0.,0.)+vec3(GarageY.x,-GarageY.z,GarageY.y)*0.2,vec3(-1.,60.,0.),3,84),\n    BRICK(GarageRotP-GarageY*3.6,vec3(1.,30.,0.),4,5),\n        BRICK(GarageRotP-GarageY*3.2,vec3(1.,30.,0.),4,19),\n    BRICK(GarageRotP-GarageY*2.,vec3(1.,30.,0.),4,5),\n        BRICK(GarageRotP-GarageY*1.6,vec3(1.,30.,0.),4,19),\n    BRICK(GarageRotP-GarageY*0.4,vec3(1.,30.,0.),4,5),\n        BRICK(GarageRotP-vec3(-1.,0.,0.),vec3(1.,30.,0.),4,16),\n            BRICK(GarageRotP-vec3(-4.,0.,0.),vec3(1.,30.,0.),4,16),\n        BRICK(GarageRotP,vec3(1.,30.,0.),4,88),\n            BRICK(GarageRotP-vec3(-7.,0.,0.),vec3(1.,30.,0.),4,88),\n    BRICK(GarageRotP+GarageY*1.2,vec3(1.,30.,0.),4,33),\n    //Garage join technic brick\n    BRICK(vec3(20.,5.6,12.),vec3(1.,0.,0.),10,88),\n        BRICK(vec3(29.,5.6,12.),vec3(1.,0.,0.),10,88),\n    BRICK(vec3(20.,5.6,11.),vec3(1.,0.,0.),0,14),\n        BRICK(vec3(29.,5.6,11.),vec3(1.,0.,0.),0,14),\n        BRICK(vec3(30.,5.6,11.),vec3(1.,0.,0.),10,61),\n            BRICK(vec3(30.,6.8,11.),vec3(1.,0.,0.),10,61),\n    //2 2x1x1\n    BRICK(vec3(21.,6.8,11.),vec3(0.,0.,1.),0,1),\n        BRICK(vec3(21.,7.2,11.),vec3(0.,0.,1.),0,1),\n    BRICK(vec3(30.,6.8,11.),vec3(0.,0.,1.),0,1),\n        BRICK(vec3(30.,7.2,11.),vec3(0.,0.,1.),0,1),\n    //Door\n    BRICK(vec3(12.8,0.4,17.4),vec3(0.8,0.,-0.6),0,89),\n    //Stairs\n    BRICK(vec3(21.,7.6,18.),vec3(0.,0.,1.),1,5),\n        BRICK(vec3(21.,8.,18.),vec3(0.,0.,1.),1,2),\n            BRICK(vec3(21.,8.,21.),vec3(0.,0.,1.),1,2),\n        BRICK(vec3(21.,7.6,25.),vec3(-1.,0.,0.),3,92),\n            BRICK(vec3(21.,7.6,26.),vec3(-1.,0.,0.),3,92),\n        BRICK(vec3(21.,8.4,18.),vec3(0.,0.,1.),1,5),\n    //Rotated stairs\n    BRICK(StairRotP-StairX*1.5-StairY*0.3,StairX,10,90),\n        BRICK(StairRotP-StairX*1.5-StairY*0.3,vec3(0.,65.,1.),10,1),\n        BRICK(StairRotP-StairX*2.5-StairY*0.7,StairX,10,8),\n        BRICK(StairRotP-StairX*8.5+StairY*0.1,StairX,2,12),\n            BRICK(StairRotP+vec3(0.,0.,2.)-StairX*1.5+StairY*0.5,vec3(0.,295.,-1.),3,84),\n            BRICK(StairRotP+vec3(0.,0.,2.)-StairX*3.5+StairY*0.5,vec3(0.,295.,-1.),3,84),\n            BRICK(StairRotP+vec3(0.,0.,2.)-StairX*5.5+StairY*0.5,vec3(0.,295.,-1.),3,84),\n            BRICK(StairRotP+vec3(0.,0.,2.)-StairX*7.5+StairY*0.5,vec3(0.,295.,-1.),3,84),\n    //5th white layer\n    BRICK(vec3(30.,7.6,18.),vec3(0.,0.,1.),0,16),\n        BRICK(vec3(30.,7.6,21.),vec3(0.,0.,1.),0,18),\n    BRICK(vec3(23.,7.6,26.),vec3(1.,0.,0.),0,18),\n        BRICK(vec3(17.,7.6,26.),vec3(1.,0.,0.),0,18),\n        BRICK(vec3(11.,7.6,26.),vec3(1.,0.,0.),0,18),\n    BRICK(vec3(11.,7.6,21.),vec3(0.,0.,1.),0,18),\n        BRICK(vec3(11.,7.6,18.),vec3(0.,0.,1.),0,16),\n    BRICK(vec3(10.,7.6,17.),vec3(1.,0.,0.),0,15),\n        BRICK(vec3(18.,7.6,17.),vec3(1.,0.,0.),0,15),\n        BRICK(vec3(20.,7.6,17.),vec3(1.,0.,0.),0,20),\n    //Lamp\n    BRICK(vec3(19.,6.6,17.2),vec3(0.,0.999,0.04471),3,60),\n        BRICK(vec3(18.,7.6,16.8),vec3(0.,-180.999,0.04471),3,76),\n        BRICK(vec3(17.5,6.,14.9),vec3(1.,0.,0.),3,93),\n        BRICK(vec3(18.,4.8,15.4),vec3(1.,0.,0.),12,61),\n        BRICK(vec3(18.,4.4,15.4),vec3(1.,0.,0.),3,60),\n    //Blue over door + floor over garage\n    BRICK(vec3(12.,7.6,18.),vec3(0.,0.,-1.),5,65),\n        BRICK(vec3(15.,7.6,18.),vec3(0.,0.,-1.),5,65),\n    BRICK(vec3(20.,7.6,11.),vec3(1.,0.,0.),0,13),\n        BRICK(vec3(20.,7.6,13.),vec3(1.,0.,0.),0,13),\n        BRICK(vec3(20.,7.6,15.),vec3(1.,0.,0.),0,13),\n    //Yellow floor + removable roof base\n    BRICK(vec3(20.,8.8,17.),vec3(1.,0.,0.),1,13),\n        BRICK(vec3(20.,8.8,19.),vec3(1.,0.,0.),1,13),\n        BRICK(vec3(20.,8.8,21.),vec3(1.,0.,0.),1,13),\n        BRICK(vec3(20.,8.8,23.),vec3(1.,0.,0.),1,13),\n        BRICK(vec3(20.,8.8,25.),vec3(1.,0.,0.),1,13),\n    BRICK(vec3(14.,8.8,26.),vec3(1.,0.,0.),1,32),\n        BRICK(vec3(13.,8.8,26.),vec3(1.,0.,0.),1,0),\n        BRICK(vec3(11.,8.8,26.),vec3(1.,0.,0.),1,29),\n    BRICK(vec3(14.,8.8,17.),vec3(1.,0.,0.),1,32),\n        BRICK(vec3(13.,8.8,17.),vec3(1.,0.,0.),1,0),\n        BRICK(vec3(11.,8.8,17.),vec3(1.,0.,0.),1,29),\n    BRICK(vec3(11.,8.8,17.),vec3(0.,0.,1.),1,29),\n        BRICK(vec3(11.,8.8,19.),vec3(0.,0.,1.),1,0),\n        BRICK(vec3(11.,8.8,20.),vec3(0.,0.,1.),1,29),\n        BRICK(vec3(11.,8.8,22.),vec3(0.,0.,1.),1,29)\n);\n\nconst BRICK BrickArray2[NBricks]=BRICK[NBricks](\n    BRICK(vec3(11.,8.8,24.),vec3(0.,0.,1.),1,0),\n    BRICK(vec3(11.,8.8,25.),vec3(0.,0.,1.),1,29),\n    //First layer on garage\n    BRICK(vec3(21.,8.,11.),vec3(1.,0.,0.),0,24),\n        BRICK(vec3(25.,8.,11.),vec3(1.,0.,0.),0,24),\n    BRICK(vec3(21.,8.,16.),vec3(1.,0.,0.),4,19), //Red brick\n    BRICK(vec3(21.,8.,14.),vec3(-1.,0.,0.),5,66),\n        BRICK(vec3(21.,8.,17.),vec3(-1.,0.,0.),5,65),\n        BRICK(vec3(29.,8.,10.),vec3(1.,0.,0.),5,66),\n        BRICK(vec3(29.,8.,14.),vec3(1.,0.,0.),5,65),\n    //First layer inner quad\n    BRICK(vec3(21.,9.2,17.),vec3(0.,0.,1.),0,29),\n        BRICK(vec3(21.,9.2,17.),vec3(1.,0.,0.),0,24),\n        BRICK(vec3(25.,9.2,17.),vec3(1.,0.,0.),0,24),\n    BRICK(vec3(30.,9.2,17.),vec3(0.,0.,1.),0,20),\n        BRICK(vec3(29.,9.2,24.),vec3(0.,0.,1.),10,15), //Grey\n    BRICK(vec3(26.,9.2,26.),vec3(1.,0.,0.),0,16),\n        BRICK(vec3(22.,9.2,26.),vec3(1.,0.,0.),0,17),\n        BRICK(vec3(22.,9.2,25.),vec3(0.,0.,1.),0,15),\n        BRICK(vec3(21.,9.2,25.),vec3(0.,0.,1.),0,29),\n    //Second layer on garage\n    BRICK(vec3(22.,9.2,13.),vec3(-1.,0.,0.),5,65),\n        BRICK(vec3(22.,9.2,17.),vec3(-1.,0.,0.),5,66),\n        BRICK(vec3(28.,9.2,10.),vec3(1.,0.,0.),5,65),\n        BRICK(vec3(28.,9.2,13.),vec3(1.,0.,0.),5,66),\n    BRICK(vec3(22.,9.2,11.),vec3(1.,0.,0.),0,22),\n        BRICK(vec3(26.,9.2,11.),vec3(1.,0.,0.),0,22),\n        BRICK(vec3(24.,9.2,12.),vec3(0.,0.,-1.),3,91),\n    BRICK(vec3(22.,9.2,16.),vec3(1.,0.,0.),0,18), //Whie brick on red\n    //Second layer inner quad\n    BRICK(vec3(31.,10.4,26.),vec3(0.,0.,1.),5,70),\n        BRICK(vec3(23.,10.4,26.),vec3(0.,0.,1.),5,64),\n    BRICK(vec3(29.,10.4,24.),vec3(0.,0.,1.),10,15), //Grey\n    BRICK(vec3(30.,10.4,23.),vec3(0.,0.,1.),0,16), //White bricks\n        BRICK(vec3(30.,10.4,18.),vec3(0.,0.,1.),0,16),\n    BRICK(vec3(29.,10.4,18.),vec3(0.,0.,-1.),5,64), //Blue slope\n    BRICK(vec3(21.,10.4,26.),vec3(0.,0.,-1.),0,72), //ISlope\n        BRICK(vec3(22.,10.4,18.),vec3(0.,0.,1.),0,72),\n    //Blue slopes + 2 SlopeCross\n    BRICK(vec3(23.,10.4,12.),vec3(-1.,0.,0.),5,64),\n        BRICK(vec3(23.,10.4,16.),vec3(-1.,0.,0.),5,66),\n        BRICK(vec3(23.,10.4,18.),vec3(-1.,0.,0.),5,95),\n            BRICK(vec3(27.,10.4,18.),vec3(0.,0.,-1.),5,95),\n    BRICK(vec3(27.,10.4,10.),vec3(1.,0.,0.),5,64),\n        BRICK(vec3(27.,10.4,12.),vec3(1.,0.,0.),5,66),\n    //2 Islopes + 2 grey round131 + 2 white 6x3x1\n    BRICK(vec3(24.,10.4,18.),vec3(0.,0.,1.),0,72),\n        BRICK(vec3(27.,10.4,18.),vec3(0.,0.,1.),0,72),\n    BRICK(vec3(24.,10.4,17.),vec3(0.,0.,1.),10,61),\n        BRICK(vec3(27.,10.4,17.),vec3(0.,0.,1.),10,61),\n    BRICK(vec3(24.,10.4,11.),vec3(0.,0.,1.),0,18),\n        BRICK(vec3(27.,10.4,11.),vec3(0.,0.,1.),0,18),\n    //2 white + some blue ceiling bricks + doubleslope\n    BRICK(vec3(30.,11.6,23.),vec3(0.,0.,1.),0,15), //White bricks\n        BRICK(vec3(30.,11.6,19.),vec3(0.,0.,1.),0,15),\n    BRICK(vec3(28.,11.6,19.),vec3(0.,0.,-1.),5,65), //Blue slope near garage\n        BRICK(vec3(26.,11.6,19.),vec3(0.,0.,-1.),5,95), //Blue slopecross\n    BRICK(vec3(31.,11.6,25.),vec3(0.,0.,1.),5,64), //Blue slope behind house\n    BRICK(vec3(21.,11.6,19.),vec3(0.,0.,-1.),5,77), //Double slope\n    //Inner quad window + one blue ceiling\n    BRICK(vec3(29.,11.6,25.),vec3(0.,0.,1.),5,70),\n    BRICK(vec3(29.,10.4,23.),vec3(0.,0.,-1.),1,85), //Window\n    BRICK(vec3(23.,11.6,19.),vec3(1.,0.,0.),0,17),\n    //Window over garage + some other bricks\n    BRICK(vec3(21.,11.6,25.),vec3(0.,0.,-1.),0,72), //White ISlope\n        BRICK(vec3(22.,11.6,19.),vec3(0.,0.,1.),0,72),\n    BRICK(vec3(28.,11.6,25.),vec3(0.,0.,-1.),10,72), //Grey ISlope\n    BRICK(vec3(24.,9.6,11.),vec3(1.,0.,0.),1,85), //Window\n        BRICK(vec3(24.,12.,11.),vec3(1.,0.,0.),0,1),\n        BRICK(vec3(24.,12.4,11.),vec3(1.,0.,0.),0,1),\n    BRICK(vec3(24.,11.6,19.),vec3(-1.,0.,0.),5,95),\n    //Only blue ceiling\n    BRICK(vec3(24.,11.6,14.),vec3(-1.,0.,0.),5,66), //Directly over garage\n        BRICK(vec3(24.,11.6,17.),vec3(-1.,0.,0.),5,65),\n        BRICK(vec3(26.,11.6,10.),vec3(1.,0.,0.),5,66),\n        BRICK(vec3(26.,11.6,14.),vec3(1.,0.,0.),5,65),\n    BRICK(vec3(23.,12.8,24.),vec3(0.,0.,1.),5,64), //Behind house\n        BRICK(vec3(31.,12.8,24.),vec3(0.,0.,1.),5,70),\n    //Two white islopes + grey islope + blue ceiling\n    BRICK(vec3(21.,12.8,24.),vec3(0.,0.,-1.),0,72), //White ISlope\n        BRICK(vec3(22.,12.8,20.),vec3(0.,0.,1.),0,72),\n    BRICK(vec3(28.,12.8,24.),vec3(0.,0.,-1.),10,72), //Grey ISlope\n    BRICK(vec3(27.,12.8,20.),vec3(0.,0.,-1.),5,66), //Blue ceiling over garage\n        BRICK(vec3(21.,12.8,20.),vec3(0.,0.,-1.),5,64),\n    BRICK(vec3(29.,12.8,24.),vec3(0.,0.,-1.),0,17),\n    BRICK(vec3(25.,12.8,20.),vec3(-1.,0.,0.),5,95), //Blue slopecross\n        BRICK(vec3(25.,12.8,20.),vec3(0.,0.,-1.),5,95),\n    //Blue ceiling that covers garage + white 2x3x1 over inner quad window\n    BRICK(vec3(25.,12.8,18.),vec3(-1.,0.,0.),5,70),\n        BRICK(vec3(25.,12.8,10.),vec3(1.,0.,0.),5,70),\n    BRICK(vec3(30.,14.,21.),vec3(0.,0.,1.),0,15), //White 2x3x1\n    BRICK(vec3(31.,14.,23.),vec3(0.,0.,1.),5,64), //Blue behind\n        BRICK(vec3(29.,14.,23.),vec3(0.,0.,1.),5,70),\n    //Grey and blue ceiling on almost final ceiling height\n    BRICK(vec3(28.,14.,23.),vec3(0.,0.,-1.),10,72), //Grey ISlope\n    BRICK(vec3(22.,14.,21.),vec3(0.,0.,1.),0,15), //White 2x3x1\n    BRICK(vec3(29.,14.,21.),vec3(0.,0.,-1.),5,64), //Blue forward\n        BRICK(vec3(21.,14.,21.),vec3(0.,0.,-1.),5,70),\n    //Grey disk-layer on top of garage\n    BRICK(vec3(26.,14.,10.),vec3(0.,0.,1.),10,9),\n        BRICK(vec3(26.,14.,16.),vec3(0.,0.,1.),10,9),\n    BRICK(vec3(24.,14.,13.),vec3(1.,0.,0.),10,60),\n        BRICK(vec3(25.,14.,13.),vec3(1.,0.,0.),10,60),\n        BRICK(vec3(25.,14.,14.),vec3(1.,0.,0.),10,60),\n        BRICK(vec3(25.,14.,15.),vec3(1.,0.,0.),10,60),\n    BRICK(vec3(25.,14.,16.),vec3(-1.,0.,0.),8,91), //Disk holder\n    BRICK(LampRotP+LampZ*2.2,-LampZ-vec3(0.,180.,0.),3,92), //Lamp over garage\n        BRICK(LampRotP+LampZ*2.2+LampY*0.8,-LampZ-vec3(0.,180.,0.),12,74),\n    //Disk\n    BRICK(DiskRotP+DiskX*2.2,DiskX+vec3(0.,180.,0.),3,92),\n        BRICK(DiskRotP+DiskX*2.2,DiskX+vec3(0.,180.,0.),10,60), //1x1x1 round\n        BRICK(DiskRotP+DiskX*1.2+DiskY*0.8+vec3(0.,0.,1.),DiskX+vec3(0.,180.,0.),0,94), //Disk\n        BRICK(DiskRotP+DiskX*3.2+DiskY*1.6-vec3(0.,0.,1.),-DiskX-vec3(0.,180.,0.),10,76), \n            BRICK(DiskRotP+DiskX*2.2+DiskY*2.,DiskX+vec3(0.,180.,0.),10,60),\n    //Top slopes on inner quad\n    BRICK(vec3(21.,15.2,22.),vec3(0.,0.,-1.),5,64), //Blue forward\n        BRICK(vec3(23.,15.2,22.),vec3(0.,0.,-1.),5,70),\n    BRICK(vec3(23.,15.2,22.),vec3(0.,0.,1.),5,64), //Blue behind\n        BRICK(vec3(31.,15.2,22.),vec3(0.,0.,1.),5,70),\n    //Doubelslope ceiling on garage + grey on inner quad\n    BRICK(vec3(24.,14.4,18.),vec3(1.,0.,0.),5,96),\n        BRICK(vec3(24.,14.4,14.),vec3(1.,0.,0.),5,80),\n        BRICK(vec3(24.,14.4,10.),vec3(1.,0.,0.),5,80),\n    BRICK(vec3(21.,16.4,21.),vec3(1.,0.,0.),10,9),\n        BRICK(vec3(24.,16.4,21.),vec3(1.,0.,0.),10,9),\n        BRICK(vec3(30.,16.4,21.),vec3(1.,0.,0.),10,7),\n    //Doubleslope ceiling on inner quad\n    BRICK(vec3(22.,16.8,21.),vec3(0.,0.,1.),5,77),\n        BRICK(vec3(26.,16.8,21.),vec3(0.,0.,1.),5,80),\n        BRICK(vec3(27.,16.8,21.),vec3(0.,0.,1.),5,77),\n        BRICK(vec3(31.,16.8,21.),vec3(0.,0.,1.),5,77),\n    //Chimney\n    BRICK(vec3(28.,16.4,21.),vec3(1.,0.,0.),1,22),\n        BRICK(vec3(27.,16.4,21.),vec3(1.,0.,0.),10,21),\n    BRICK(vec3(27.,17.6,21.),vec3(1.,0.,0.),1,22),\n        BRICK(vec3(29.,17.6,21.),vec3(1.,0.,0.),10,21),\n    BRICK(vec3(28.,18.8,21.),vec3(1.,0.,0.),8,62),\n        BRICK(vec3(28.,18.8,22.),vec3(1.,0.,0.),8,62),\n    //Removable ceiling - basis\n    BRICK(vec3(10.,9.2,25.),vec3(1.,0.,0.),0,13), //10x1x2\n        BRICK(vec3(10.,9.2,17.),vec3(1.,0.,0.),0,13),\n        BRICK(vec3(11.,9.2,19.),vec3(0.,0.,1.),0,4),\n    BRICK(vec3(11.,9.6,17.),vec3(0.,0.,1.),0,6), //1x1x10\n    BRICK(vec3(11.,9.6,26.),vec3(1.,0.,0.),0,6), //10x1x1\n        BRICK(vec3(11.,9.6,17.),vec3(1.,0.,0.),0,6),\n    BRICK(vec3(17.,9.6,25.),vec3(1.,0.,0.),1,2), //Yellow 3x1x1\n        BRICK(vec3(17.,9.6,18.),vec3(1.,0.,0.),1,2),\n    BRICK(vec3(11.,9.6,18.),vec3(1.,0.,0.),10,1)\n);\n\nconst BRICK BrickArray3[NBricks]=BRICK[NBricks](\n    //White layer\n    BRICK(vec3(17.,10.,25.),vec3(1.,0.,0.),0,10), //White 4x1x2\n        BRICK(vec3(17.,10.,17.),vec3(1.,0.,0.),0,10),\n    BRICK(vec3(11.,10.,26.),vec3(1.,0.,0.),0,4), //6x1x1\n    BRICK(vec3(11.,10.,24.),vec3(0.,0.,1.),0,2), //1x1x3\n        BRICK(vec3(11.,10.,17.),vec3(0.,0.,1.),0,2),\n    BRICK(vec3(12.,10.,17.),vec3(0.,0.,1.),0,1),\n        BRICK(vec3(13.,10.,17.),vec3(0.,0.,1.),0,1),\n    //Window bases + blue ceiling behind + 2 1x3x1\n    BRICK(vec3(11.,10.,20.),vec3(0.,0.,1.),8,10),\n        BRICK(vec3(10.,10.4,20.),vec3(0.,0.,1.),10,31),\n    BRICK(vec3(13.,10.,16.),vec3(1.,0.,0.),8,10),\n        BRICK(vec3(13.,10.4,16.),vec3(1.,0.,0.),10,31),\n    BRICK(vec3(21.,10.4,26.),vec3(0.,0.,1.),5,70), //Blue ceiling behind\n        BRICK(vec3(13.,10.4,26.),vec3(0.,0.,1.),5,66),\n    BRICK(vec3(20.,10.4,18.),vec3(1.,0.,0.),0,14), //1x3x1\n        BRICK(vec3(20.,10.4,25.),vec3(1.,0.,0.),0,14),\n    //White ISlopes + some white bricks\n    BRICK(vec3(20.,10.4,18.),vec3(0.,0.,1.),0,72),\n        BRICK(vec3(18.,10.4,18.),vec3(0.,0.,1.),0,72),\n        BRICK(vec3(13.,10.4,18.),vec3(0.,0.,1.),0,72),\n    BRICK(vec3(19.,10.4,26.),vec3(0.,0.,-1.),0,72),\n    BRICK(vec3(11.,10.4,18.),vec3(0.,0.,1.),0,15), //White 2x3x1\n        BRICK(vec3(11.,10.4,24.),vec3(0.,0.,1.),0,15),\n    BRICK(vec3(18.,10.4,17.),vec3(0.,0.,1.),0,14), //White 1x3x1\n        BRICK(vec3(13.,10.4,17.),vec3(0.,0.,1.),0,14),\n    //4 blue ceilings\n    BRICK(vec3(9.,10.4,18.),vec3(0.,0.,-1.),5,65), //Blue ceiling forward\n        BRICK(vec3(18.,10.4,18.),vec3(0.,0.,-1.),5,65),\n    BRICK(vec3(13.,11.6,25.),vec3(0.,0.,1.),5,66), //Blue ceiling behind\n        BRICK(vec3(21.,11.6,25.),vec3(0.,0.,1.),5,66),\n    //White bricks second layer\n    BRICK(vec3(18.,11.6,17.),vec3(0.,0.,1.),0,15), //White 1x3x1\n        BRICK(vec3(13.,11.6,17.),vec3(0.,0.,1.),0,15),\n    BRICK(vec3(11.,11.6,19.),vec3(0.,0.,1.),0,14),\n        BRICK(vec3(11.,11.6,24.),vec3(0.,0.,1.),0,14),\n    BRICK(vec3(20.,11.6,19.),vec3(0.,0.,1.),0,18),\n    //Third layer - blue ceilings and white ISlopes\n    BRICK(vec3(9.,11.6,19.),vec3(0.,0.,-1.),5,65), //Blue ceiling forward\n        BRICK(vec3(18.,11.6,19.),vec3(0.,0.,-1.),5,65),\n    BRICK(vec3(13.,12.8,24.),vec3(0.,0.,1.),5,66), //Blue ceiling behind\n        BRICK(vec3(21.,12.8,24.),vec3(0.,0.,1.),5,66),\n    BRICK(vec3(18.,11.6,19.),vec3(0.,0.,1.),0,72),\n        BRICK(vec3(13.,11.6,19.),vec3(0.,0.,1.),0,72),\n    //Third layer white 1x3x4 + crossed slopes\n    BRICK(vec3(20.,12.8,20.),vec3(0.,0.,1.),0,17),\n    BRICK(vec3(9.,12.8,20.),vec3(0.,0.,-1.),5,64), //Blue ceiling forward\n        BRICK(vec3(19.,12.8,20.),vec3(0.,0.,-1.),5,64),\n    BRICK(vec3(13.,12.8,20.),vec3(-1.,0.,0.),5,95),\n        BRICK(vec3(17.,12.8,20.),vec3(0.,0.,-1.),5,95),\n    //2 Windows\n    BRICK(vec3(11.,10.4,20.),vec3(0.,0.,1.),1,86), //Big window\n        BRICK(vec3(10.4,10.8,20.1),vec3(0.,0.,1.),0,87),\n        BRICK(vec3(10.4,13.8,23.9),vec3(0.,180.,-1.),0,87),\n    BRICK(vec3(17.,10.4,18.),vec3(-1.,0.,0.),1,86),\n        BRICK(vec3(16.9,10.8,17.4),vec3(-1.,0.,0.),0,87),\n        BRICK(vec3(13.1,13.8,17.4),vec3(1.,180.,0.),0,87),\n    //Blue ceilings + arc\n    BRICK(vec3(13.,14.,23.),vec3(0.,0.,1.),5,66), //Blue ceiling behind\n        BRICK(vec3(21.,14.,23.),vec3(0.,0.,1.),5,66),\n    BRICK(vec3(13.,12.8,18.),vec3(-1.,0.,0.),5,64), //Blue ceiling forward near window\n        BRICK(vec3(17.,12.8,16.),vec3(1.,0.,0.),5,64),\n    BRICK(vec3(18.,12.8,21.),vec3(-1.,0.,0.),10,18), //Grey \"arc\"\n    //Two 10x3x1 white bricks\n    BRICK(vec3(10.,14.,21.),vec3(1.,0.,0.),0,20),\n        BRICK(vec3(10.,14.,22.),vec3(1.,0.,0.),0,20),\n    //Blue ceiling forward + slopecross\n    BRICK(vec3(9.,14.,21.),vec3(0.,0.,-1.),5,65), //Blue ceiling forward\n        BRICK(vec3(18.,14.,21.),vec3(0.,0.,-1.),5,65),\n    BRICK(vec3(14.,14.,21.),vec3(-1.,0.,0.),5,95), //SlopeCross\n        BRICK(vec3(16.,14.,21.),vec3(0.,0.,-1.),5,95),\n    //Forward window ceiling + 2x3x1 on top\n    BRICK(vec3(16.,14.,18.),vec3(-1.,0.,0.),0,15),\n    BRICK(vec3(14.,14.,19.),vec3(-1.,0.,0.),5,65), //Blue ceiling forward near window\n        BRICK(vec3(16.,14.,16.),vec3(1.,0.,0.),5,65),\n    //Oblique window\n    BRICK(vec3(13.,11.6,23.),vec3(1.,0.,0.),0,97),\n    //Ceiling behind + SlopeCross\n    BRICK(vec3(11.,15.2,22.),vec3(0.,0.,1.),5,64),\n        BRICK(vec3(19.,15.2,22.),vec3(0.,0.,1.),5,70),\n        BRICK(vec3(21.,15.2,22.),vec3(0.,0.,1.),5,64),\n    BRICK(vec3(15.,15.2,22.),vec3(-1.,0.,0.),5,95), //SlopeCross\n        BRICK(vec3(15.,15.2,22.),vec3(0.,0.,-1.),5,95),\n    //Rest of the slopes\n    BRICK(vec3(9.,15.2,22.),vec3(0.,0.,-1.),5,66), //Blue ceiling forward\n        BRICK(vec3(17.,15.2,22.),vec3(0.,0.,-1.),5,66),\n    BRICK(vec3(15.,15.2,20.),vec3(-1.,0.,0.),5,66), //Blue ceiling forward near window\n        BRICK(vec3(15.,15.2,16.),vec3(1.,0.,0.),5,66),\n    //Grey layer\n    BRICK(vec3(18.,16.4,21.),vec3(1.,0.,0.),10,9),\n        BRICK(vec3(15.,16.4,21.),vec3(1.,0.,0.),10,9),\n        BRICK(vec3(12.,16.4,21.),vec3(1.,0.,0.),10,9),\n        BRICK(vec3(9.,16.4,21.),vec3(1.,0.,0.),10,9),\n    BRICK(vec3(14.,16.4,21.),vec3(0.,0.,-1.),10,9),\n        BRICK(vec3(14.,16.4,18.),vec3(0.,0.,-1.),10,8),\n    //DoubeSlopes on top\n    BRICK(vec3(14.,16.8,20.),vec3(1.,0.,0.),5,96), //InverseDoubleSlope\n        BRICK(vec3(14.,16.8,16.),vec3(1.,0.,0.),5,80),\n    BRICK(vec3(13.,16.8,21.),vec3(0.,0.,1.),5,80),\n        BRICK(vec3(17.,16.8,21.),vec3(0.,0.,1.),5,80),\n        BRICK(vec3(21.,16.8,21.),vec3(0.,0.,1.),5,80),\n    //Tree\n    BRICK(vec3(1.,0.,19.),vec3(1.,0.,0.),2,61),\n        BRICK(vec3(1.,1.2,19.),vec3(1.,0.,0.),2,61),\n        BRICK(vec3(1.,2.4,19.),vec3(1.,0.,0.),2,61),\n        BRICK(vec3(0.5,3.6,18.5),vec3(1.,0.,0.),9,83),\n    BRICK(vec3(0.5,4.8,19.5),vec3(0.,0.,-1.),9,72), //Green ISlopes\n        BRICK(vec3(1.5,4.8,18.5),vec3(1.,0.,0.),9,72),\n        BRICK(vec3(2.5,4.8,19.5),vec3(0.,0.,1.),9,72),\n        BRICK(vec3(1.5,4.8,20.5),vec3(-1.,0.,0.),9,72),\n    BRICK(vec3(1.5,6.,19.5),vec3(-1.,0.,0.),9,71), //Slope 331\n        BRICK(vec3(1.5,6.,19.5),vec3(0.,0.,-1.),9,71),\n        BRICK(vec3(1.5,6.,19.5),vec3(1.,0.,0.),9,71),\n        BRICK(vec3(1.5,6.,19.5),vec3(0.,0.,1.),9,71),\n    BRICK(vec3(1.5,6.,17.5),vec3(0.,0.,1.),9,14), //1x3x1\n        BRICK(vec3(3.5,6.,18.5),vec3(0.,0.,1.),9,14),\n        BRICK(vec3(2.5,6.,20.5),vec3(0.,0.,1.),9,14),\n        BRICK(vec3(0.5,6.,19.5),vec3(0.,0.,1.),9,14),\n    BRICK(vec3(-1.5,5.6,18.5),vec3(1.,0.,0.),4,60), //Apples\n        BRICK(vec3(1.5,5.6,16.5),vec3(1.,0.,0.),4,60),\n        BRICK(vec3(3.5,5.6,19.5),vec3(1.,0.,0.),4,60),\n        BRICK(vec3(0.5,5.6,21.5),vec3(1.,0.,0.),4,60),\n    //Post\n    BRICK(vec3(12.,4.,15.5),vec3(0.42,0.,0.9075241),0,29),\n        BRICK(vec3(12.9,4.4,15.5),vec3(-0.42,0.,0.9075241),0,29),\n    \n    \n    \n    \n    //Unused bricks (22 st)\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(21.,0.,12.),vec3(1.,0.,0.),10,29)\n);\n\n//Lego logo (see Image)\nconst int samples = 2;\nconst vec3 positions[225] =\n    vec3[225](vec3(0.9408613367791228, 0.43095909706765456, 0),\n              vec3(0.9264762435267317, 0.44352663509707624, 0),\n              vec3(0.8947861254762883, 0.4638692865687953, 0),\n              vec3(0.8777536433400679, 0.4715814511436973, 0),\n              vec3(0.841995189500208, 0.48193008580309815, 0),\n              vec3(0.8048872251098951, 0.48530129825064333, 0),\n              vec3(0.7861678547856077, 0.4842916850607259, 0),\n              vec3(0.7490796945333518, 0.47672464768502254, 0),\n              vec3(0.7309834472672143, 0.47010427463184123, 0),\n              vec3(0.6967507470536414, 0.45128546857518964, 0),\n              vec3(0.6815966127536668, 0.4397110894047105, 0),\n              vec3(0.6551836294986841, 0.41262743744267205, 0),\n              vec3(0.634461035245403, 0.3809322504759403, 0),\n              vec3(0.626419887197555, 0.3635934525495947, 0),\n              vec3(0.6174678863278233, 0.3359891364381042, 0),\n              vec3(0.47899216991926896, -0.24549629059456585, 0),\n              vec3(0.4741737266143069, -0.2751084016236367, 0),\n              vec3(0.473508033500468, -0.29441126217125624, 0),\n              vec3(0.4778079185647557, -0.33209980412273227, 0),\n              vec3(0.4891422806195873, -0.36776620212046324, 0),\n              vec3(0.5069424579864692, -0.40045137004997605, 0),\n              vec3(0.5306397889869092, -0.42919622179679773, 0),\n              vec3(0.5445221803251843, -0.44179131469092675, 0),\n              vec3(0.575999001128787, -0.4628274056990749, 0),\n              vec3(0.5934512651744912, -0.471028632284476, 0),\n              vec3(0.6313136680076146, -0.48217771366078943, 0),\n              vec3(0.6700652677983625, -0.48548096726553785, 0),\n              vec3(0.7077538097498388, -0.48118108220125, 0),\n              vec3(0.7434202077475696, -0.46984672014641854, 0),\n              vec3(0.7761053756770824, -0.45204654277953654, 0),\n              vec3(0.8048502274239044, -0.4283492117790967, 0),\n              vec3(0.8286956768735618, -0.3993233888235917, 0),\n              vec3(0.8466826379115826, -0.36553773559151465, 0),\n              vec3(0.8557512754292231, -0.33741694258942456, 0),\n              vec3(0.996423388384482, 0.25472647096242323, 0),\n              vec3(1, 0.29294405649279703, 0),\n              vec3(0.9960265197448488, 0.3307089760104401, 0),\n              vec3(0.9846915584576656, 0.3670555420215273, 0),\n              vec3(0.7570787710671805, -0.3279246723576778, 0),\n              vec3(0.7481456607517563, -0.34489128805259295, 0),\n              vec3(0.7363053501222789, -0.3595089915158228, 0),\n              vec3(0.7220133343540593, -0.37147883456812697, 0),\n              vec3(0.705725108622407, -0.38050186903026445, 0),\n              vec3(0.6878961681026325, -0.3862791467229943, 0),\n              vec3(0.6689820079700466, -0.3885117194670758, 0),\n              vec3(0.649438123399958, -0.38690063908326805, 0),\n              vec3(0.6304205367457778, -0.3813442914822551, 0),\n              vec3(0.6058327710290847, -0.3668259574428918, 0),\n              vec3(0.5925016292489125, -0.3537028573471296, 0),\n              vec3(0.5819678219692868, -0.33835579970027974, 0),\n              vec3(0.5720660623804614, -0.31216168851770726, 0),\n              vec3(0.5701398889260951, -0.28352583320630764, 0),\n              vec3(0.7155770729851352, 0.3272211318267263, 0),\n              vec3(0.7245101833005594, 0.3441877475216413, 0),\n              vec3(0.7363504939300369, 0.35880545098487127, 0),\n              vec3(0.7506425096982563, 0.3707752940371754, 0),\n              vec3(0.7669307354299086, 0.37979832849931283, 0),\n              vec3(0.7847596759496831, 0.38557560619204273, 0),\n              vec3(0.803673836082269, 0.38780817893612424, 0),\n              vec3(0.8330139122006925, 0.38387499214489884, 0),\n              vec3(0.8511765563761193, 0.3765710374186516, 0),\n              vec3(0.8670548875320945, 0.36613614277101764, 0),\n              vec3(0.8803725907900135, 0.35302297421472734, 0),\n              vec3(0.8908533512712726, 0.3376841977625116, 0),\n              vec3(0.8982208540972669, 0.3205724794271009, 0),\n              vec3(0.9021987843893928, 0.3021404852212259, 0),\n              vec3(0.49404521200236484, 0.32051485979824523, 0),\n              vec3(0.48453276188440575, 0.3577040643779089, 0),\n              vec3(0.4771903875232675, 0.3751107130887582, 0),\n              vec3(0.4578154766529401, 0.40706596689622404, 0),\n              vec3(0.432829864860236, 0.4345676472763559, 0),\n              vec3(0.4030049704751837, 0.4568443358991251, 0),\n              vec3(0.3691122118278114, 0.47312461443450343, 0),\n              vec3(0.3508814516338892, 0.4787750316912871, 0),\n              vec3(0.3319230072481476, 0.4826370645524623, 0),\n              vec3(0.29392752080375106, 0.4846864612988684, 0),\n              vec3(0.2612007307844826, 0.48048830820567073, 0),\n              vec3(0.2302822471806536, 0.47103805054705644, 0),\n              vec3(0.20168320536497242, 0.4567572335473808, 0),\n              vec3(0.17591474071014757, 0.43806740243099923, 0),\n              vec3(0.15348798858888713, 0.41539010242226715, 0),\n              vec3(0.13491408437389962, 0.3891468787455399, 0),\n              vec3(0.12070416343789314, 0.35975927662517293, 0),\n              vec3(0.1132180666353646, 0.33590866248028545, 0),\n              vec3(-0.025338065404089227, -0.24549634892148534, 0),\n              vec3(-0.030138663741522187, -0.27510780484715514, 0),\n              vec3(-0.03077473905960626, -0.29440849931717467, 0),\n              vec3(-0.026382729388821247, -0.33208369115772834, 0),\n              vec3(-0.021501053563444672, -0.35021629512770946, 0),\n              vec3(-0.0067323828414551645, -0.3844667856656981, 0),\n              vec3(0.01422201609720819, -0.4152246749992118, 0),\n              vec3(0.026835852193426657, -0.4289915274635997, 0),\n              vec3(0.05597077473090595, -0.45269631448625475, 0),\n              vec3(0.07234545200867437, -0.46239235564396874, 0),\n              vec3(0.10834321567353711, -0.47686699975078806, 0),\n              vec3(0.12770761787487328, -0.4814513703741509, 0),\n              vec3(0.16645647691437215, -0.4847091805549651, 0),\n              vec3(0.20413166875492594, -0.4803171708841801, 0),\n              vec3(0.23976561979432254, -0.46886097801576615, 0),\n              vec3(0.27239075643035005, -0.45092623860369346, 0),\n              vec3(0.30103950506079724, -0.4270985893019323, 0),\n              vec3(0.31357036712323705, -0.41315793489678415, 0),\n              vec3(0.3344403332411665, -0.38158898948668446, 0),\n              vec3(0.3489149773479858, -0.3455912258218219, 0),\n              vec3(0.42894164996584827, -0.011973834455500498, 0),\n              vec3(0.42972497189919556, 0.005285807701407088, 0),\n              vec3(0.4243979338193449, 0.022557766661810377, 0),\n              vec3(0.410058067874302, 0.03884635586226634, 0),\n              vec3(0.3951169066462894, 0.04640446369357787, 0),\n              vec3(0.381196346171893, 0.04853615910943173, 0),\n              vec3(0.29306584924039014, 0.048288253738397215, 0),\n              vec3(0.274830481833795, 0.04272753468825939, 0),\n              vec3(0.2605446253882744, 0.030976607914030365, 0),\n              vec3(0.25170207774583986, 0.014529271257721282, 0),\n              vec3(0.24954095118037345, 0.000010362544709030003, 0),\n              vec3(0.25170207774583986, -0.014508546168303221, 0),\n              vec3(0.2605446253882744, -0.030955882824612358, 0),\n              vec3(0.274830481833795, -0.042706809598841385, 0),\n              vec3(0.283547839032084, -0.04635430745454747, 0),\n              vec3(0.31863004442757803, -0.048515434020013674, 0),\n              vec3(0.25202421179653345, -0.32792467235767736, 0),\n              vec3(0.2430911014811088, -0.3448912880525925, 0),\n              vec3(0.22438277766140802, -0.36584357985454286, 0),\n              vec3(0.20067054935175999, -0.380501869030264, 0),\n              vec3(0.18284160883198575, -0.38627914672299396, 0),\n              vec3(0.15420575352058608, -0.3882053201773602, 0),\n              vec3(0.13463670610345768, -0.3845783042799128, 0),\n              vec3(0.11660773985991546, -0.37726960481225597, 0),\n              vec3(0.09378165831698615, -0.3605708705373532, 0),\n              vec3(0.07691326269863996, -0.3383557997002793, 0),\n              vec3(0.06947573809880092, -0.3212402796776524, 0),\n              vec3(0.0647789303657329, -0.29324752838512047, 0),\n              vec3(0.06639001074954098, -0.2737036438150323, 0),\n              vec3(0.20590410104503487, 0.3127127704626628, 0),\n              vec3(0.21430798481922464, 0.33602689053214585, 0),\n              vec3(0.2307763633722193, 0.3590033597484454, 0),\n              vec3(0.24497227602406446, 0.37110352110207073, 0),\n              vec3(0.2612004704622315, 0.3802611176093988, 0),\n              vec3(0.288338328393416, 0.3877891213826372, 0),\n              vec3(0.31743891786417455, 0.3869192865064165, 0),\n              vec3(0.34946754816430725, 0.37512846657511933, 0),\n              vec3(0.3628577585368089, 0.365782121700417, 0),\n              vec3(0.37946114119164776, 0.34811165849076364, 0),\n              vec3(0.3938616180155652, 0.3191469867055984, 0),\n              vec3(0.3981023608114145, 0.2852790298923329, 0),\n              vec3(0.40366307986155214, 0.26704366248573774, 0),\n              vec3(0.40885812964828094, 0.2593136830277175, 0),\n              vec3(0.42314398609380155, 0.24756275625348856, 0),\n              vec3(0.4463802520051028, 0.24175413183231625, 0),\n              vec3(0.470219090251927, 0.2480492150414748, 0),\n              vec3(0.4849219338265358, 0.2599629758397277, 0),\n              vec3(0.4902778529410525, 0.2677196751665549, 0),\n              vec3(-0.4238290609360067, -0.3879545880996168, 0),\n              vec3(-0.42399143141451245, -0.3857869964555996, 0),\n              vec3(-0.3435303791941341, -0.04876145696646751, 0),\n              vec3(-0.1881453922760149, -0.04826752864897948, 0),\n              vec3(-0.17862738206770856, -0.04635430745454769, 0),\n              vec3(-0.16218004541139952, -0.037511759812112966, 0),\n              vec3(-0.15042911863717046, -0.023225903366592502, 0),\n              vec3(-0.14678162078146462, -0.014508546168303545, 0),\n              vec3(-0.1448683995870328, 0.005011261049414758, 0),\n              vec3(-0.15042911863717046, 0.02324662845600997, 0),\n              vec3(-0.16218004541139952, 0.037532484901530376, 0),\n              vec3(-0.17862738206770856, 0.04637503254396521, 0),\n              vec3(-0.19314629078072088, 0.04853615910943141, 0),\n              vec3(-0.3201711275962441, 0.04853615910943141, 0),\n              vec3(-0.2395580256922737, 0.3877292902425807, 0),\n              vec3(-0.013614947063175453, 0.3879753131890342, 0),\n              vec3(0.001553809488533675, 0.3901364397545005, 0),\n              vec3(0.010271166686822708, 0.3937839376102065, 0),\n              vec3(0.024557023132343314, 0.4055348643844355, 0),\n              vec3(0.03339957077477784, 0.42198220104074474, 0),\n              vec3(0.035560697340244474, 0.436501109753757, 0),\n              vec3(0.03339957077477784, 0.45102001846676926, 0),\n              vec3(0.024557023132343314, 0.46746735512307847, 0),\n              vec3(0.010271166686822708, 0.4792182818973075, 0),\n              vec3(0.001553809488533675, 0.4828657797530134, 0),\n              vec3(-0.012965099224478305, 0.4850269063184797, 0),\n              vec3(-0.28168609287903024, 0.48485067306612756, 0),\n              vec3(-0.3043423804615203, 0.47698065006041873, 0),\n              vec3(-0.32039964632717177, 0.4593075787165124, 0),\n              vec3(-0.5323543124694348, -0.42474224806260563, 0),\n              vec3(-0.5337338883980041, -0.43998512769155146, 0),\n              vec3(-0.5289140955923151, -0.45796681352017904, 0),\n              vec3(-0.5177230286574426, -0.4726176319384635, 0),\n              vec3(-0.5012621748910309, -0.48217218549675583, 0),\n              vec3(-0.48805568326353965, -0.4848137981736519, 0),\n              vec3(-0.18106368398796246, -0.4846778019002089, 0),\n              vec3(-0.16282831658136732, -0.47911708285007126, 0),\n              vec3(-0.1485424601358467, -0.46736615607584225, 0),\n              vec3(-0.13969991249341207, -0.4509188194195329, 0),\n              vec3(-0.13780384309711902, -0.4313999159620832, 0),\n              vec3(-0.14369958214938683, -0.41318230940945977, 0),\n              vec3(-0.1559911147398615, -0.3989255304682293, 0),\n              vec3(-0.17289041011825634, -0.3901082881133118, 0),\n              vec3(-0.8900128517657221, -0.3879545880996168, 0),\n              vec3(-0.6958469474912434, 0.43024439706208367, 0),\n              vec3(-0.6970680454957241, 0.44937401560737006, 0),\n              vec3(-0.7052111612782105, 0.46615542921161646, 0),\n              vec3(-0.711534261055692, 0.4730785079255896, 0),\n              vec3(-0.7279951148221036, 0.4828153067067156, 0),\n              vec3(-0.7474699697899465, 0.48548096726553785, 0),\n              vec3(-0.756841335071212, 0.48394209929187737, 0),\n              vec3(-0.7735159477880796, 0.4757893172039107, 0),\n              vec3(-0.7858110168317786, 0.461806574093651, 0),\n              vec3(-0.789707952521583, 0.45298025484212406, 0),\n              vec3(-0.9986204823983503, -0.42409851472697496, 0),\n              vec3(-1, -0.4393413360290013, 0),\n              vec3(-0.9951802071943109, -0.4573230218576287, 0),\n              vec3(-0.9839891402594383, -0.4719738402759131, 0),\n              vec3(-0.9675282864930268, -0.48152839383420565, 0),\n              vec3(-0.9543217948655356, -0.48417000651110154, 0),\n              vec3(-0.6473297955899583, -0.48403401023765885, 0),\n              vec3(-0.629094428183363, -0.4784732911875213, 0),\n              vec3(-0.6148085717378426, -0.4667223644132922, 0),\n              vec3(-0.6059660240954079, -0.4502750277569829, 0),\n              vec3(-0.6040688937631473, -0.43076335438168084, 0),\n              vec3(-0.6099273821747845, -0.41268783466083125, 0),\n              vec3(-0.6220949031388547, -0.3986636757539205, 0),\n              vec3(-0.6387381593037988, -0.3900488756991408, 0),\n              vec3(-0.6530549597150334, -0.3879545880996168, 0),\n              vec3(-0.1875131137334065, -0.3879545880996168, 0),\n              vec3(0.4962741058527447, 0.2909237200595889, 0),\n              vec3(0.9001729001451884, 0.2680691160390561, 0),\n              vec3(0.9714728267726251, 0.392803750658161, 0));\nconst ivec3 triangles[219] = ivec3[219](\n    ivec3(0, 61, 1), ivec3(0, 62, 61), ivec3(0, 224, 62), ivec3(1, 60, 2),\n    ivec3(1, 61, 60), ivec3(2, 60, 3), ivec3(3, 59, 4), ivec3(3, 60, 59),\n    ivec3(4, 58, 5), ivec3(4, 59, 58), ivec3(5, 58, 6), ivec3(6, 57, 7),\n    ivec3(6, 58, 57), ivec3(7, 56, 8), ivec3(7, 57, 56), ivec3(8, 56, 9),\n    ivec3(9, 55, 10), ivec3(9, 56, 55), ivec3(10, 54, 11), ivec3(10, 55, 54),\n    ivec3(11, 53, 12), ivec3(11, 54, 53), ivec3(12, 52, 13), ivec3(12, 53, 52),\n    ivec3(13, 52, 14), ivec3(14, 52, 15), ivec3(15, 51, 16), ivec3(15, 52, 51),\n    ivec3(16, 51, 17), ivec3(17, 50, 18), ivec3(17, 51, 50), ivec3(18, 50, 19),\n    ivec3(19, 49, 20), ivec3(19, 50, 49), ivec3(20, 48, 21), ivec3(20, 49, 48),\n    ivec3(21, 47, 22), ivec3(21, 48, 47), ivec3(22, 47, 23), ivec3(23, 46, 24),\n    ivec3(23, 47, 46), ivec3(24, 46, 25), ivec3(25, 45, 26), ivec3(25, 46, 45),\n    ivec3(26, 44, 27), ivec3(26, 45, 44), ivec3(27, 43, 28), ivec3(27, 44, 43),\n    ivec3(28, 42, 29), ivec3(28, 43, 42), ivec3(29, 41, 30), ivec3(29, 42, 41),\n    ivec3(30, 40, 31), ivec3(30, 41, 40), ivec3(31, 39, 32), ivec3(31, 40, 39),\n    ivec3(32, 38, 33), ivec3(32, 39, 38), ivec3(33, 38, 223),\n    ivec3(33, 223, 34), ivec3(34, 223, 35), ivec3(35, 65, 36),\n    ivec3(35, 223, 65), ivec3(36, 64, 37), ivec3(36, 65, 64),\n    ivec3(37, 63, 224), ivec3(37, 64, 63), ivec3(62, 224, 63),\n    ivec3(66, 143, 67), ivec3(66, 144, 143), ivec3(66, 222, 144),\n    ivec3(67, 143, 68), ivec3(68, 142, 69), ivec3(68, 143, 142),\n    ivec3(69, 142, 70), ivec3(70, 141, 71), ivec3(70, 142, 141),\n    ivec3(71, 140, 72), ivec3(71, 141, 140), ivec3(72, 139, 73),\n    ivec3(72, 140, 139), ivec3(73, 139, 74), ivec3(74, 139, 75),\n    ivec3(75, 138, 76), ivec3(75, 139, 138), ivec3(76, 137, 77),\n    ivec3(76, 138, 137), ivec3(77, 137, 78), ivec3(78, 136, 79),\n    ivec3(78, 137, 136), ivec3(79, 135, 80), ivec3(79, 136, 135),\n    ivec3(80, 134, 81), ivec3(80, 135, 134), ivec3(81, 134, 82),\n    ivec3(82, 133, 83), ivec3(82, 134, 133), ivec3(83, 133, 84),\n    ivec3(84, 132, 85), ivec3(84, 133, 132), ivec3(85, 131, 86),\n    ivec3(85, 132, 131), ivec3(86, 131, 87), ivec3(87, 130, 88),\n    ivec3(87, 131, 130), ivec3(88, 130, 89), ivec3(89, 129, 90),\n    ivec3(89, 130, 129), ivec3(90, 128, 91), ivec3(90, 129, 128),\n    ivec3(91, 128, 92), ivec3(92, 127, 93), ivec3(92, 128, 127),\n    ivec3(93, 126, 94), ivec3(93, 127, 126), ivec3(94, 126, 95),\n    ivec3(95, 125, 96), ivec3(95, 126, 125), ivec3(96, 124, 97),\n    ivec3(96, 125, 124), ivec3(97, 123, 98), ivec3(97, 124, 123),\n    ivec3(98, 123, 99), ivec3(99, 122, 100), ivec3(99, 123, 122),\n    ivec3(100, 121, 101), ivec3(100, 122, 121), ivec3(101, 121, 102),\n    ivec3(102, 120, 103), ivec3(102, 121, 120), ivec3(103, 119, 104),\n    ivec3(103, 120, 119), ivec3(104, 109, 105), ivec3(104, 119, 109),\n    ivec3(105, 107, 106), ivec3(105, 109, 107), ivec3(107, 109, 108),\n    ivec3(109, 119, 110), ivec3(110, 113, 111), ivec3(110, 114, 113),\n    ivec3(110, 118, 114), ivec3(110, 119, 118), ivec3(111, 113, 112),\n    ivec3(114, 118, 115), ivec3(115, 117, 116), ivec3(115, 118, 117),\n    ivec3(144, 147, 145), ivec3(144, 148, 147), ivec3(144, 149, 148),\n    ivec3(144, 222, 149), ivec3(145, 147, 146), ivec3(149, 222, 150),\n    ivec3(150, 222, 151), ivec3(152, 181, 153), ivec3(152, 186, 181),\n    ivec3(152, 187, 186), ivec3(152, 221, 187), ivec3(153, 181, 154),\n    ivec3(154, 165, 155), ivec3(154, 180, 165), ivec3(154, 181, 180),\n    ivec3(155, 159, 156), ivec3(155, 160, 159), ivec3(155, 164, 160),\n    ivec3(155, 165, 164), ivec3(156, 158, 157), ivec3(156, 159, 158),\n    ivec3(160, 163, 161), ivec3(160, 164, 163), ivec3(161, 163, 162),\n    ivec3(165, 180, 166), ivec3(166, 177, 167), ivec3(166, 178, 177),\n    ivec3(166, 180, 178), ivec3(167, 172, 168), ivec3(167, 177, 172),\n    ivec3(168, 171, 169), ivec3(168, 172, 171), ivec3(169, 171, 170),\n    ivec3(172, 177, 173), ivec3(173, 175, 174), ivec3(173, 176, 175),\n    ivec3(173, 177, 176), ivec3(178, 180, 179), ivec3(181, 185, 182),\n    ivec3(181, 186, 185), ivec3(182, 184, 183), ivec3(182, 185, 184),\n    ivec3(187, 193, 188), ivec3(187, 194, 193), ivec3(187, 221, 194),\n    ivec3(188, 190, 189), ivec3(188, 193, 190), ivec3(190, 192, 191),\n    ivec3(190, 193, 192), ivec3(195, 205, 196), ivec3(195, 206, 205),\n    ivec3(195, 211, 206), ivec3(195, 212, 211), ivec3(195, 220, 212),\n    ivec3(196, 205, 197), ivec3(197, 205, 198), ivec3(198, 200, 199),\n    ivec3(198, 205, 200), ivec3(200, 205, 201), ivec3(201, 205, 202),\n    ivec3(202, 205, 203), ivec3(203, 205, 204), ivec3(206, 210, 207),\n    ivec3(206, 211, 210), ivec3(207, 209, 208), ivec3(207, 210, 209),\n    ivec3(212, 218, 213), ivec3(212, 219, 218), ivec3(212, 220, 219),\n    ivec3(213, 218, 214), ivec3(214, 218, 215), ivec3(215, 218, 216),\n    ivec3(216, 218, 217));\nconst int len = 219;\n\nbool sameSide(vec3 p1, vec3 p2, vec3 a, vec3 b) {\n  vec3 cp1 = cross(b - a, p1 - a);\n  vec3 cp2 = cross(b - a, p2 - a);\n\n  return dot(cp1, cp2) >= 0.0;\n}\n\nbool pointInTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n  return sameSide(p, a, b, c) && sameSide(p, b, a, c) && sameSide(p, c, a, b);\n}\n\nbool inPath(vec2 p) {\n  for (int i = 0; i < len; i++) {\n    ivec3 triangle = triangles[i];\n    vec3 a = positions[triangle[0]];\n    vec3 b = positions[triangle[1]];\n    vec3 c = positions[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage + G-Buffer\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color = texture(iChannel0,fragCoord.xy*IRES);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color = vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Color = vec4(-0.3,0.4,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color = vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color = vec4(12.5,11.2,5.5,1.); //Player Pos\n            else if (fragCoord.x<5.) Color = vec4(0.36,-0.2,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Color = vec4(0.,0.,0.,0.); //Sun direction\n            else if (fragCoord.x<9.) Color = vec4(0.,0.,0.,0.); //R-Value\n            else if (fragCoord.x<10.) Color = vec4(0.,0.,0.,0.); //RTime\n        } else if (DFBox(fragCoord-vec2(0.,1.),vec2(26.*3.,26.))<0.) {\n            //Initializing the bricks\n            float OutIndex = floor(fragCoord.x*I26);\n            int CIndex = int(floor(mod(fragCoord.x,26.))+floor(fragCoord.y-1.)*26.);\n            if (CIndex<512) {\n                //Within the amount of bricks\n                BRICK CBrick;\n                if (CIndex<128) CBrick = BrickArray[CIndex];\n                else if (CIndex<256) CBrick = BrickArray1[CIndex-128];\n                else if (CIndex<384) CBrick = BrickArray2[CIndex-256];\n                else if (CIndex<512) CBrick = BrickArray3[CIndex-384];\n                float CIndexf = float(CIndex);\n                vec3 CBrickP = CBrick.P;\n                Color = ((OutIndex<0.5)?vec4(CBrickP,float(CBrick.I)+0.5):\n                        ((OutIndex<1.5)?vec4(normalize(vec3(CBrick.Q.x,fract(abs(CBrick.Q.y))*sign(CBrick.Q.y),CBrick.Q.z)),\n                        floor(abs(CBrick.Q.y))*ToRadians):\n                        vec4(BrickColorArray[CBrick.Color],-length(CBrickP.xz-CBrick.P.xz))));\n            }\n        }\n    } else { //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //Börjat klicka\n                    if (Color.w==0.) {\n                    \tColor.w = 1.;\n                    \tColor.xy = iMouse.zw;\n                    }\n                } else Color.w = 0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Color.zw = Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x = Color.z+(iMouse.y-LMouse.y)*0.01;\n                \tColor.x = clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y = Color.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tColor.y = mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles = texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Color.xyz = normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed = iTimeDelta*2.;\n                \tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed = 20.*iTimeDelta;\n                vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz += Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz -= Eye*Speed; //S\n                vec3 Tan = normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz -= Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz += Tan*Speed; //D\n                //Position clamping\n                Color.y = clamp(Color.y,0.1,21.);\n                Color.xz = clamp(Color.xz,vec2(0.1),vec2(31.9));\n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Color.y += iTimeDelta*1.5;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Color.y -= iTimeDelta*1.5;\n                Color.z = Color.y; //Sunangle last frame\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles = texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Color = vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) { //Last frame dir\n                Color = texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) { //Last frame position\n                Color = texture(iChannel0,vec2(3.5,0.5)*IRES);\n            } else if (fragCoord.x<9.) { //R-Value and movement boolean\n                //R\n                if (texelFetch(iChannel1,ivec2(82,1),0).x>0.) Color.x = 1.-Color.x;\n                float RTime = texture(iChannel0,vec2(9.5,0.5)*IRES).x+min(iTimeDelta,1./30.);\n                if (RTime>70.) Color.x = 0.; //Stop building\n                //Movement\n                Color.y = 1.;\n                if (iFrame<BuildFrames ||\n                    texelFetch(iChannel1,ivec2(87,0),0).x>0. ||\n                    texelFetch(iChannel1,ivec2(83,0),0).x>0. ||\n                    texelFetch(iChannel1,ivec2(65,0),0).x>0. ||\n                    texelFetch(iChannel1,ivec2(68,0),0).x>0. ||\n                    iMouse.xy!=Color.zw) Color.y = 0.;\n                Color.zw = iMouse.xy;\n            } else if (fragCoord.x<10.) { //RTime\n                vec2 RMoved = texture(iChannel0,vec2(8.5,0.5)*IRES).xy;\n                if (iFrame>BuildFrames && RMoved.x>0.5) {\n                    Color.x += min(iTimeDelta,1./30.);\n                    if (Color.x>70.) Color.x = 0.; //Reset RTime and set R to 0\n                }\n            }\n        } else if (DFBox(fragCoord-vec2(0.,1.),vec2(26.*3.,26.))<0.) {\n            //Updating the bricks\n            float OutIndex = floor(fragCoord.x*I26);\n            float CIndexf = floor(mod(fragCoord.x,26.))+floor(fragCoord.y-1.)*26.;\n            int CIndex = int(CIndexf);\n            vec2 BrickUV = vec2(mod(fragCoord.x,26.),fragCoord.y);\n            //R-key and time\n            vec2 RMoved = texture(iChannel0,vec2(8.5,0.5)*IRES).xy;\n            if (texelFetch(iChannel1,ivec2(82,1),0).x>0.) RMoved.x = 1.-RMoved.x;\n            float FrameTime = min(iTimeDelta,1./30.);\n            float RelativeTimeCoeff = iTimeDelta/FrameTime;\n            float RTime = texture(iChannel0,vec2(9.5,0.5)*IRES).x;\n            if (iFrame>BuildFrames && RMoved.x>0.5) {\n                RTime += FrameTime;\n            }\n            if (RTime>70.) RMoved.x = 0.;\n            if (CIndex<512 && iFrame>BuildFrames && RMoved.x>0.5) {\n                //Within the amount of bricks\n                vec4 CBrick0 = texture(iChannel0,BrickUV*IRES);\n                vec4 CBrick1 = texture(iChannel0,vec2(BrickUV.x+26.,BrickUV.y)*IRES);\n                vec4 CBrick2 = texture(iChannel0,vec2(BrickUV.x+52.,BrickUV.y)*IRES);\n                //Falling\n                float UFallTime = (20.-CBrick0.y)/(4.+4.*(CBrick0.x+CBrick0.z)*I64);\n                if (RTime<6. && RTime>UFallTime) {\n                    vec3 Velocity = vec3(0.,min(0.4,pow(RTime-UFallTime,2.)*0.5),0.); //In relation to 30 fps\n                    CBrick0.xyz += Velocity*RelativeTimeCoeff;\n                }\n                //Building\n                if (RTime>6.+CIndexf*0.125) {\n                    float TimeDiff = RTime-6.-CIndexf*0.125;\n                    //Brick attributes\n                    BRICK CBrick;\n                    if (CIndex<128) CBrick = BrickArray[CIndex];\n                    else if (CIndex<256) CBrick = BrickArray1[CIndex-128];\n                    else if (CIndex<384) CBrick = BrickArray2[CIndex-256];\n                    else if (CIndex<512) CBrick = BrickArray3[CIndex-384];\n                    //Create coordinate system\n                    vec3 CX = CBrick1.xyz;\n                    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                    vec3 RefCY = cross(RefCZ,CX);\n                    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                    CY *= (max(0.,sign(CY.y))*2.-1.); //CY.y should be positive\n                    //Spawn brick\n                    CBrick0.xyz = CBrick.P+CY*max(0.,1.2-TimeDiff*TimeDiff*2.)*RelativeTimeCoeff;\n                }\n                //Output\n                Color = ((OutIndex<0.5)?CBrick0:((OutIndex<1.5)?CBrick1:CBrick2));\n            }\n        } else if (DFBox(fragCoord-vec2(0.,27.),vec2(26.*3.,26.))<0.) {\n            //Last frame copy of bricks\n            Color = texture(iChannel0,vec2(fragCoord.x,fragCoord.y-26.)*IRES);\n        }\n    }\n    //Logo\n    vec2 UV = fragCoord;\n    if (DFBox(UV-vec2(0.,53.),vec2(128.))<0.) {\n        //LEGO logo SVG\n        if (iFrame > 0) {\n        } else {\n            vec2 fragUV=UV-vec2(0.,53.); fragUV.x = 128.-fragUV.x;\n            float normalizer = float(samples * samples);  \n            float fstep = 1.0 / float(samples);\n            for (int sx = 0; sx < samples; sx++) {\n                for (int sy = 0; sy < samples; sy++) {  \n                    vec2 uv = (fragUV + vec2(float(sx), float(sy)) * fstep)*I128;\n                    uv *= 2.0;\n                    uv -= vec2(1.0);\n                    uv *= 2.24;\n                    if (inPath(uv)) {\n                        Color += vec4(1.0);\n                    }\n                }\n            }\n            Color = vec4(Color.xyz/normalizer,1.);\n        }\n    } else if (DFBox(UV-vec2(128.,53.),vec2(128.))<0.) {\n        //LEGO logo gradient\n        if (iFrame > 1) {\n        } else {\n            for (float i=-2.; i<2.5; i++) {\n                for (float j=-2.; j<2.5; j++) {\n                    if (i==0. && j==0.) continue;\n                    Color.xy += normalize(vec2(i,j))*texture(iChannel0,(UV-vec2(128.,0.)+vec2(i,j))*IRES).x;\n                }\n            }\n            Color = vec4(normalize(vec3(-Color.y/16.,0.5,-Color.x/16.)),1.);\n        }\n    }\n    //Output\n    fragColor = Color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Primary rays\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 Trace(vec3 P, vec3 D) {\n    //Traces a ray through the scene\n    vec3 IDir = 1./D;\n    vec4 OUT = vec4(100000.,-10.,-1.,-1.);\n    //32x32 brick\n    vec2 bb = box(P,IDir,vec3(0.),vec3(32.,0.4*8.,32.));\n    bool Inside32 = (DFBox(P,vec3(32.,0.4*8.,32.))<=0.);\n    if ((bb.x>0. && bb.y>bb.x) || Inside32) {\n        //Bottom brick\n        float dft; float dfdist = ((Inside32)?0.:bb.x); float dfFAR = min(bb.y,OUT.x);\n        for (int i=0; i<356; i++) {\n            if (dfdist>dfFAR) break;\n            dft = DF32x32(P+D*dfdist);\n            if (dft<0.0005) {\n                OUT = vec4(dfdist,-1.,-1.,-1.);\n                if (P.y+D.y*dfdist>0.199) OUT.zw = fract(P.xz+D.xz*dfdist);\n                break;\n            }\n            dfdist = dfdist+dft;\n        }\n    }\n    //Dynamic bricks\n    float t = 0.;\n    bb = box(P,IDir,vec3(-48.001,0.001,-48.001),vec3(79.999,51.199,79.999));\n    float bbDF = DFBox(P-vec3(-48.001,0.001,-48.001),vec3(127.998,51.198,127.998));\n    float FAR = min(OUT.x,bb.y);\n    float LFar = FAR; vec3 cp,fp,Normal; vec4 C;\n    float LOD = 0.;\n    vec3 LS = vec3(1.,0.4,1.);\n    vec3 ILS = vec3(1.,2.5,1.);\n    fp = floor(P*ILS)*LS;\n    //Iterations\n    for (int i=0; i<112; i++) {\n        if (t>FAR) break;\n        cp = P+D*t;\n        C = textureCube(vec2(fp.x+floor(mod(fp.y*2.5+0.5,8.))*128.,fp.z+floor((fp.y*2.5+0.5)*0.125)*128.)+48.5);\n        bb = box(P,IDir,fp,fp+LS);\n        bbDF = DFBox(cp-fp,LS);\n        if (C.x>0. && ((bb.x>=0. && bb.y>bb.x) || bbDF<=0.)) {\n            if (LOD==0.) {\n                float GCDist = 100000.; int GCBrickArrayIndex = -1;\n                vec2 GCBrickUV; vec3 GCX,GCY,GCZ; vec2 StudUV;\n                for (int ColorIndex = 0; ColorIndex<4; ColorIndex++) {\n                    float CBrickArrayIndex = floor(C[ColorIndex]);\n                    if (CBrickArrayIndex<-0.5) break;\n                    vec2 CBrickUV = vec2(mod(CBrickArrayIndex+0.5,26.),floor((CBrickArrayIndex+0.5)*I26)+27.5);\n                    vec4 CBrick0 = texture(iChannel0,CBrickUV*IRES);\n                    vec4 CBrick1 = texture(iChannel0,vec2(CBrickUV.x+26.,CBrickUV.y)*IRES);\n                    float CBrickIndexf = floor(CBrick0.w);\n                    int CBrickIndex = int(CBrickIndexf);\n                    vec3 CBrickSize = vec3(0.);\n                    if (CBrickIndex<28)\n                        CBrickSize = vec3(BrickADim[CBrickIndex%7],0.8+0.8*floor(CBrick0.w/14.),1.+mod(floor(CBrick0.w/7.),2.));\n                    else if (CBrickIndex<56)\n                        CBrickSize = vec3(BrickADim[CBrickIndex%7],0.8+0.8*floor((CBrick0.w-28.)/14.),\n                                          1.+mod(floor((CBrick0.w-28.)/7.),2.));\n                    else\n                        CBrickSize = BrickDim[CBrickIndex-56];\n                    //Semi-quaternion\n                    vec3 CX = CBrick1.xyz;\n                    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                    vec3 RefCY = cross(RefCZ,CX);\n                    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                    vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                    vec3 BRPos = cp-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    vec3 BRDir = D.x*vec3(CX.x,CY.x,CZ.x)+D.y*vec3(CX.y,CY.y,CZ.y)+D.z*vec3(CX.z,CY.z,CZ.z);\n                    //Unified SDF\n                    float biFAR = min(FAR,bb.y)-t;\n                    vec3 DS = vec3(100000.,0.,0.);\n                    if (CBrickIndex<28) DS = TraceBrick(BRPos,BRDir,CBrickSize,biFAR); //(1,2,3,4,6,8,10)x(0.4,1.2)x(1,2) = 7*2*2\n                    else if (CBrickIndex<56) DS = TraceBrick_NoStud(BRPos,BRDir,CBrickSize,biFAR);\n                    else if (CBrickIndex==56) DS = TraceGrate(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=59) DS = TraceCorner(BRPos,BRDir,CBrickIndexf-56.,biFAR);\n                    else if (CBrickIndex==60) DS = TraceRound111(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==61) DS = TraceRound131(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==62) DS = TraceCone131(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=70) DS = TraceSlope(BRPos,BRDir,CBrickIndexf-62.,biFAR);\n                    else if (CBrickIndex==71) DS = TraceSlope331(BRPos,BRDir,CBrickIndexf-62.,biFAR);\n                    else if (CBrickIndex<=73) DS = TraceISlope(BRPos,BRDir,CBrickIndexf-71.,biFAR);\n                    else if (CBrickIndex==74) DS = TraceOnlySlope(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==75) DS = TraceHeadLight(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==76) DS = TraceHose(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=81) DS = TraceDoubleSlope(BRPos,BRDir,CBrickIndexf-76.,biFAR);\n                    else if (CBrickIndex==83) DS = TraceRound232(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==84) DS = TracePanel(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=86) DS = TraceWindow(BRPos,BRDir,CBrickIndexf-84.,biFAR);\n                    else if (CBrickIndex==87) DS = TraceWindowFrame(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==88) DS = TraceBrickHole(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==89) DS = TraceDoor(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=91) DS = TraceHandle(BRPos,BRDir,CBrickIndexf-90.,biFAR);\n                    else if (CBrickIndex==92) DS = TraceGrip(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=94) DS = TraceDisk(BRPos,BRDir,CBrickIndexf-92.,biFAR);\n                    else if (CBrickIndex==95) DS = TraceSlopeCross(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==96) DS = TraceDoubleSlopeInverse(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==97) DS = TraceWindowOblique(BRPos,BRDir,CBrickIndexf,biFAR);\n                    if (DS.x<biFAR && GCDist>DS.x) {\n                        GCX = CX; GCY = CY; GCZ = CZ;\n                        GCBrickUV = CBrickUV;\n                        GCBrickArrayIndex = int(CBrickArrayIndex);\n                        GCDist = DS.x;\n                        StudUV = DS.yz;\n                    }\n                }\n                //Intersection test\n                if (GCDist<99990.) return vec4(t+GCDist,GCBrickArrayIndex,StudUV);\n            }\n        }\n        vec3 farNormal = boxfarNormal(P,IDir,fp,fp+LS);\n        fp += farNormal*LS;\n        t = bb.y;\n    }\n    //Return\n    return OUT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color = vec4(0.);\n    //Set up camera\n    float Frame = float(iFrame);\n    vec2 RMoved = texture(iChannel0,vec2(8.5,0.5)*IRES).xy;\n    vec2 SSOffset = (texture(iChannel2,vec2(Frame*I1024)).zx-0.5)*float(RMoved.x<0.5);\n    vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n    vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n    mat3 EyeMat = TBN(Eye);\n    vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n    //Render scene\n    vec4 Pixel = Trace(Pos,Dir);\n    Color = vec4(Pixel.x,Pixel.y+0.5,Pixel.zw);\n    fragColor = Color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//Acceleration structure\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 UpdateOutput(vec4 Output, int bi, vec3 VPos, inout int WriteIndex) {\n    //Updates Output\n    float CBrickArrayIndex = float(bi);\n    vec2 CBrickUV = vec2(mod(CBrickArrayIndex+0.5,26.),floor((CBrickArrayIndex+0.5)*I26)+27.5);\n    vec4 CBrick0 = texture(iChannel0,CBrickUV*IRES);\n    vec4 CBrick1 = texture(iChannel0,vec2(CBrickUV.x+26.,CBrickUV.y)*IRES);\n    vec3 CBrickSize;\n    float cbfi = floor(CBrick0.w);\n    int cbint = int(cbfi);\n    if (cbint<28)\n        CBrickSize = vec3(BrickADim[cbint%7],0.8+0.8*floor(cbfi/14.),1.+mod(floor(cbfi/7.),2.));\n    else if (cbint<56)\n        CBrickSize = vec3(BrickADim[cbint%7],0.8+0.8*floor((cbfi-28.)/14.),1.+mod(floor((cbfi-28.)/7.),2.));\n    else\n        CBrickSize = BrickDim[cbint-56];\n    //Quaternion coordinate system\n    vec3 CX = CBrick1.xyz;\n    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n    vec3 RefCY = cross(RefCZ,CX);\n    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n    vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n    vec3 CXT = vec3(CX.x,CY.x,CZ.x);\n    vec3 CYT = vec3(CX.y,CY.y,CZ.y);\n    vec3 CZT = vec3(CX.z,CY.z,CZ.z);\n    //Rotate brick\n    bool Intersects = true;\n    vec3 BVP = VPos-vec3(0.5,0.2,0.5)-CBrick0.xyz;\n    BVP = BVP.x*CXT+BVP.y*CYT+BVP.z*CZT;\n    //Plane separation test\n    float CBrickDFSample = DFBox(BVP+(CXT*0.5+CYT*0.2+CZT*0.5),CBrickSize);\n    if (CBrickDFSample>1.22474487139) {\n        Intersects = false;\n    } else if (CBrickDFSample>0.) {\n        for (int axis=0; axis<3; axis++) {\n            //For each axis\n            float BVPA = BVP[axis];\n            float CXA = CXT[axis];\n            float CYA = CYT[axis]*0.4;\n            float CZA = CZT[axis];\n            float VMin = BVPA+min(min(min(0.,CXA),min(CYA,CXA+CYA)),\n                             min(min(CZA,CXA+CZA),min(CYA+CZA,CXA+CYA+CZA)));\n            float VMax = BVPA+max(max(max(0.,CXA),max(CYA,CXA+CYA)),\n                             max(max(CZA,CXA+CZA),max(CYA+CZA,CXA+CYA+CZA)));\n            float BMin = 0.;\n            float BMax = CBrickSize[axis];\n            if (VMin>=BMax || BMin>=VMax) {\n                //No intersection\n                Intersects = false; break;\n            }\n            //Plane in world coordinate system\n            BVPA = (CBrick0.xyz-(VPos-vec3(0.5,0.2,0.5)))[axis];\n            BMin = 0.;\n            BMax = vec3(1.,0.4,1.)[axis];\n            CXA = (CX*CBrickSize.x)[axis];\n            CYA = (CY*CBrickSize.y)[axis];\n            CZA = (CZ*CBrickSize.z)[axis];\n            VMin = BVPA+min(min(min(0.,CXA),min(CYA,CXA+CYA)),\n                             min(min(CZA,CXA+CZA),min(CYA+CZA,CXA+CYA+CZA)));\n            VMax = BVPA+max(max(max(0.,CXA),max(CYA,CXA+CYA)),\n                             max(max(CZA,CXA+CZA),max(CYA+CZA,CXA+CYA+CZA)));\n            if (VMin>=BMax || BMin>=VMax) {\n                //No intersection\n                Intersects = false; break;\n            }\n        }\n    }\n    if (Intersects) {\n        //Brick intersects the current voxel\n        bool UniqueIndex = true;\n        float OUTf = float(bi)+0.5;\n        for (int OutIndex=0; OutIndex<WriteIndex; OutIndex++) {\n            if (abs(Output[OutIndex]-OUTf)<0.1) UniqueIndex = false;\n        }\n        if (UniqueIndex) {\n            Output[WriteIndex] = OUTf;\n            WriteIndex += 1;\n        }\n    }\n    return Output;\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3,rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z<0.) UV.y += 1024.;\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.y>0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    if (iFrame==0) {\n        Output = vec4(-1.);\n    } else if (UV.y<2048. && iFrame<BuildFrames) {\n        //Initial frames\n        vec3 VPos = vec3(mod(UV.x,128.)-48.,(floor(UV.x*I128)+floor(UV.y*I128)*8.+0.5)*0.4,mod(UV.y,128.)-48.);\n        int WriteIndex = 0;\n        for (int lbi=0; lbi<4; lbi++) {\n            if (Output[lbi]<-0.5) break;\n            WriteIndex += 1;\n        }\n        for (int lbi=0; lbi<16; lbi++) {\n            if (WriteIndex>3) break;\n            Output = UpdateOutput(Output,lbi+(iFrame-1)*16,VPos,WriteIndex);\n        }\n    } else if (UV.y<2048.) {\n        //Brick propagation\n        vec4 OutputCopy = Output;\n        Output = vec4(-1.);\n        vec3 VPos = vec3(mod(UV.x,128.)-48.,(floor(UV.x*I128)+floor(UV.y*I128)*8.+0.5)*0.4,mod(UV.y,128.)-48.);\n        int WriteIndex = 0;\n        //Test the current voxel with its bricks\n        for (int axis=0; axis<4; axis++) {\n            int CBIndex = int(floor(OutputCopy[axis]));\n            if (CBIndex<0) break;\n            Output = UpdateOutput(Output,CBIndex,VPos,WriteIndex);\n        }\n        if (WriteIndex<4) {\n            //Inject bricks at building stage\n            vec2 RMoved = texture(iChannel0,vec2(8.5,0.5)*IRES).xy;\n            float FrameTime = min(iTimeDelta,1./30.);\n            float RelativeTimeCoeff = iTimeDelta/FrameTime;\n            float RTime = texture(iChannel0,vec2(9.5,0.5)*IRES).x;\n            if (RMoved.x>0.5 && RTime>6. && RTime<70.) {\n                int BuildBIndex = int(floor((RTime-6.)*8.));\n                Output = UpdateOutput(Output,BuildBIndex,VPos,WriteIndex);\n            }\n            //Propagate\n            for (float zoff=-1.; zoff<1.5; zoff++) {\n                for (float xoff=-1.; xoff<1.5; xoff++) {\n                    for (float yoff=-1.; yoff<1.5; yoff++) {\n                        if (WriteIndex>3 || (xoff==0. && yoff==0. && zoff==0.)) continue;\n                        vec3 SPos = VPos+vec3(xoff,yoff*0.4,zoff);\n                        vec2 SUV = vec2(SPos.x+48.+floor(mod(SPos.y*2.5,8.))*128.,SPos.z+48.+floor(SPos.y*2.5*0.125)*128.);\n                        vec4 SC = textureCube(SUV);\n                        for (int axis=0; axis<4; axis++) {\n                            int CBIndex = int(floor(SC[axis]));\n                            if (CBIndex<0 || WriteIndex>3) break;\n                            Output = UpdateOutput(Output,CBIndex,VPos,WriteIndex);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Secondary rays\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 Trace(vec3 P, vec3 D) {\n    //Traces a ray through the scene\n    vec3 IDir = 1./D;\n    vec4 OUT = vec4(100000.,-10.,-1.,-1.);\n    //32x32 brick\n    vec2 bb = box(P,IDir,vec3(0.),vec3(32.,0.4*8.,32.));\n    bool Inside32 = (DFBox(P,vec3(32.,0.4*8.,32.))<=0.);\n    if ((bb.x>0. && bb.y>bb.x) || Inside32) {\n        //Bottom brick\n        float dft; float dfdist = ((Inside32)?0.:bb.x); float dfFAR = min(bb.y,OUT.x);\n        for (int i=0; i<356; i++) {\n            if (dfdist>dfFAR) break;\n            dft = DF32x32(P+D*dfdist);\n            if (dft<0.0005) {\n                OUT = vec4(dfdist,-1.,-1.,-1.);\n                if (P.y+D.y*dfdist>0.199) OUT.zw = fract(P.xz+D.xz*dfdist);\n                break;\n            }\n            dfdist = dfdist+dft;\n        }\n    }\n    //Dynamic bricks\n    float t = 0.;\n    bb = box(P,IDir,vec3(-48.001,0.001,-48.001),vec3(79.999,51.199,79.999));\n    float bbDF = DFBox(P-vec3(-48.001,0.001,-48.001),vec3(127.998,51.198,127.998));\n    float FAR = min(OUT.x,bb.y);\n    float LFar = FAR; vec3 cp,fp,Normal; vec4 C;\n    float LOD = 0.;\n    vec3 LS = vec3(1.,0.4,1.);\n    vec3 ILS = vec3(1.,2.5,1.);\n    fp = floor(P*ILS)*LS;\n    //Iterations\n    for (int i=0; i<112; i++) {\n        if (t>FAR) break;\n        cp = P+D*t;\n        C = textureCube(vec2(fp.x+floor(mod(fp.y*2.5+0.5,8.))*128.,fp.z+floor((fp.y*2.5+0.5)*0.125)*128.)+48.5);\n        bb = box(P,IDir,fp,fp+LS);\n        bbDF = DFBox(cp-fp,LS);\n        if (C.x>0. && ((bb.x>=0. && bb.y>bb.x) || bbDF<=0.)) {\n            if (LOD==0.) {\n                float GCDist = 100000.; int GCBrickArrayIndex = -1;\n                vec2 GCBrickUV; vec3 GCX,GCY,GCZ; vec2 StudUV;\n                for (int ColorIndex = 0; ColorIndex<4; ColorIndex++) {\n                    float CBrickArrayIndex = floor(C[ColorIndex]);\n                    if (CBrickArrayIndex<-0.5) break;\n                    vec2 CBrickUV = vec2(mod(CBrickArrayIndex+0.5,26.),floor((CBrickArrayIndex+0.5)*I26)+27.5);\n                    vec4 CBrick0 = texture(iChannel0,CBrickUV*IRES);\n                    vec4 CBrick1 = texture(iChannel0,vec2(CBrickUV.x+26.,CBrickUV.y)*IRES);\n                    float CBrickIndexf = floor(CBrick0.w);\n                    int CBrickIndex = int(CBrickIndexf);\n                    vec3 CBrickSize = vec3(0.);\n                    if (CBrickIndex<28)\n                        CBrickSize = vec3(BrickADim[CBrickIndex%7],0.8+0.8*floor(CBrick0.w/14.),1.+mod(floor(CBrick0.w/7.),2.));\n                    else if (CBrickIndex<56)\n                        CBrickSize = vec3(BrickADim[CBrickIndex%7],0.8+0.8*floor((CBrick0.w-28.)/14.),\n                                          1.+mod(floor((CBrick0.w-28.)/7.),2.));\n                    else\n                        CBrickSize = BrickDim[CBrickIndex-56];\n                    //Semi-quaternion\n                    vec3 CX = CBrick1.xyz;\n                    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                    vec3 RefCY = cross(RefCZ,CX);\n                    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                    vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                    vec3 BRPos = cp-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    vec3 BRDir = D.x*vec3(CX.x,CY.x,CZ.x)+D.y*vec3(CX.y,CY.y,CZ.y)+D.z*vec3(CX.z,CY.z,CZ.z);\n                    //Unified SDF\n                    float biFAR = min(FAR,bb.y)-t;\n                    vec3 DS = vec3(100000.,0.,0.);\n                    if (CBrickIndex<28) DS = TraceBrick(BRPos,BRDir,CBrickSize,biFAR); //(1,2,3,4,6,8,10)x(0.4,1.2)x(1,2) = 7*2*2\n                    else if (CBrickIndex<56) DS = TraceBrick_NoStud(BRPos,BRDir,CBrickSize,biFAR);\n                    else if (CBrickIndex==56) DS = TraceGrate(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=59) DS = TraceCorner(BRPos,BRDir,CBrickIndexf-56.,biFAR);\n                    else if (CBrickIndex==60) DS = TraceRound111(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==61) DS = TraceRound131(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==62) DS = TraceCone131(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=70) DS = TraceSlope(BRPos,BRDir,CBrickIndexf-62.,biFAR);\n                    else if (CBrickIndex==71) DS = TraceSlope331(BRPos,BRDir,CBrickIndexf-62.,biFAR);\n                    else if (CBrickIndex<=73) DS = TraceISlope(BRPos,BRDir,CBrickIndexf-71.,biFAR);\n                    else if (CBrickIndex==74) DS = TraceOnlySlope(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==75) DS = TraceHeadLight(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==76) DS = TraceHose(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=81) DS = TraceDoubleSlope(BRPos,BRDir,CBrickIndexf-76.,biFAR);\n                    else if (CBrickIndex==83) DS = TraceRound232(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==84) DS = TracePanel(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=86) DS = TraceWindow(BRPos,BRDir,CBrickIndexf-84.,biFAR);\n                    else if (CBrickIndex==87) DS = TraceWindowFrame(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==88) DS = TraceBrickHole(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==89) DS = TraceDoor(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=91) DS = TraceHandle(BRPos,BRDir,CBrickIndexf-90.,biFAR);\n                    else if (CBrickIndex==92) DS = TraceGrip(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex<=94) DS = TraceDisk(BRPos,BRDir,CBrickIndexf-92.,biFAR);\n                    else if (CBrickIndex==95) DS = TraceSlopeCross(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==96) DS = TraceDoubleSlopeInverse(BRPos,BRDir,CBrickIndexf,biFAR);\n                    else if (CBrickIndex==97) DS = TraceWindowOblique(BRPos,BRDir,CBrickIndexf,biFAR);\n                    if (DS.x<biFAR && GCDist>DS.x) {\n                        GCX = CX; GCY = CY; GCZ = CZ;\n                        GCBrickUV = CBrickUV;\n                        GCBrickArrayIndex = int(CBrickArrayIndex);\n                        GCDist = DS.x;\n                        StudUV = DS.yz;\n                    }\n                }\n                //Intersection test\n                if (GCDist<99990.) return vec4(t+GCDist,GCBrickArrayIndex,StudUV);\n            }\n        }\n        vec3 farNormal = boxfarNormal(P,IDir,fp,fp+LS);\n        fp += farNormal*LS;\n        t = bb.y;\n    }\n    //Return\n    return OUT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = vec3(0.);\n    //Set up camera\n    float Frame = float(iFrame);\n    vec2 RMoved = texture(iChannel0,vec2(8.5,0.5)*IRES).xy;\n    vec2 SSOffset = (texture(iChannel2,vec2(Frame*I1024)).zx-0.5)*float(RMoved.x<0.5);\n    vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n    vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n    mat3 EyeMat = TBN(Eye);\n    vec3 VDir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.));\n    vec3 Dir = VDir*EyeMat;\n    //Render scene\n    vec4 GBSample = texture(iChannel1,fragCoord*IRES);\n    if (GBSample.y>-5.5) {\n        //Geometry\n        HIT Pixel;\n        Pixel.D = GBSample.x;\n        Pixel.P = Pos+Dir*Pixel.D;\n        float CBrickArrayIndex = floor(GBSample.y);\n        vec2 CBrickUV = vec2(mod(CBrickArrayIndex+0.5,26.),floor((CBrickArrayIndex+0.5)*I26)+27.5);\n        if (GBSample.y>-0.5) Pixel.C = texture(iChannel0,vec2(CBrickUV.x+52.,CBrickUV.y)*IRES).xyz;\n        else if (GBSample.y>-1.5) Pixel.C = vec3(0.15,0.99,0.15);\n        else Pixel.C = vec3(1./(1.-Pixel.P.y));\n        vec3 RealNormal = vec3(0.,1.,0.);\n        if (GBSample.z>-0.5) {\n            //Stud normal map\n            Pixel.N = texture(iChannel0,(GBSample.zw*128.+vec2(128.,53.))*IRES).zyx;\n            if (GBSample.y>-0.5) {\n                //Brick\n                vec4 CBrick1 = texture(iChannel0,vec2(CBrickUV.x+26.,CBrickUV.y)*IRES);\n                vec3 CX = CBrick1.xyz;\n                vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                vec3 RefCY = cross(RefCZ,CX);\n                vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                Pixel.N = vec3(0.,Pixel.N.y,0.)+CX*Pixel.N.x+CZ*Pixel.N.z;\n            }\n            if (dot(Dir,Pixel.N)>0.) Pixel.N = normalize(Pixel.N-1.01*Dir*dot(Dir,Pixel.N));\n        } else {\n            //Normal from depth\n            vec3 PixelVP = VDir*Pixel.D;\n            vec3 Tan = vec3(0.,0.,0.);\n            vec3 Bit = vec3(0.,0.,0.);\n            vec4 XD = vec4(texture(iChannel1,(fragCoord+vec2(1.,0.))*IRES).xy,texture(iChannel1,(fragCoord+vec2(-1.,0.))*IRES).xy);\n            vec3 XP0 = normalize(vec3(((fragCoord+vec2(1.,0.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*XD.x;\n            vec3 XP1 = normalize(vec3(((fragCoord-vec2(1.,0.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*XD.z;\n            if (XD.y>-5.5) Tan = XP0-PixelVP;\n            if (XD.w>-5.5 && (length(Tan)==0. || length(Tan)>length(XP1-PixelVP))) Tan = XP1-PixelVP;\n            vec4 YD = vec4(texture(iChannel1,(fragCoord+vec2(0.,1.))*IRES).xy,texture(iChannel1,(fragCoord+vec2(0.,-1.))*IRES).xy);\n            vec3 YP0 = normalize(vec3(((fragCoord+vec2(0.,1.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*YD.x;\n            vec3 YP1 = normalize(vec3(((fragCoord-vec2(0.,1.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*YD.z;\n            if (YD.y>-5.5) Bit = YP0-PixelVP;\n            if (YD.w>-5.5 && (length(Bit)==0. || length(Bit)>length(YP1-PixelVP))) Bit = YP1-PixelVP;\n            Pixel.N = normalize(cross(Bit,Tan))*EyeMat;\n            Pixel.N *= sign(dot(Pixel.N,-Dir));\n            RealNormal = Pixel.N;\n        }\n        vec3 PPos = Pixel.P+RealNormal*0.005;\n        if (RMoved.x>0.5) {\n            //Edge detection\n            float AO = 0.;\n            for (float x=-1.; x<1.5; x++) {\n                for (float y=-1.; y<1.5; y++) {\n                    if (x==0. && y==0.) continue;\n                    vec2 SUV = fragCoord+vec2(x,y);\n                    vec2 SD = texture(iChannel1,SUV*IRES).xy;\n                    if (SD.y<-5.5) { AO += 0.5; continue; }\n                    vec3 XP0 = Pos-Pixel.P+normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat)*SD.x;\n                    float SDot = dot(XP0,Pixel.N);\n                    AO += max(0.,SDot-0.01);\n                }\n            }\n            Color = Pixel.C*((Pixel.N.y*0.5+0.5)*0.5+0.5)/(1.+AO*150.);\n        } else {\n            //GGX Path Tracing\n            vec2 RM = vec2(0.01,0.5);\n            Color = vec3(0.);\n            vec3 Rand3 = (texture(iChannel2,(fragCoord+Frame*vec2(279.267,199.123))*I1024).xyz+\n                          texture(iChannel2,(fragCoord*1.12+Frame*vec2(179.267,239.123))*I1024).xyz*255.)/256.;\n            vec3 NB,NT,TDir,RDir,Reflectance;\n            if (Rand3.z<RM.y) { //Roughness\n                //GGX\n                NB = TBN(Pixel.N,NT);\n                TDir = -vec3(dot(Dir,NT),dot(Dir,NB),dot(Dir,Pixel.N)); //Negative direction in tangent space \n                ImportanceSampleGGX(Rand3.xy,TDir,RM.x,vec3(0.075),RDir,Reflectance);\n                RDir = normalize(RDir*TBN(Pixel.N));\n            } else {\n                //Diffuse\n                RDir = RandSampleCos(Rand3.xy)*TBN(Pixel.N);\n            }\n            if (dot(RDir,RealNormal)<0.) RDir = reflect(RDir,RealNormal);\n            //Ray trace\n            vec4 RHit = Trace(PPos,RDir);\n            if (RHit.y>-5.5) {\n                float RHI = floor(RHit.y);\n                CBrickUV = vec2(mod(RHI+0.5,26.),floor((RHI+0.5)*I26)+27.5);\n                vec3 RHC;\n                if (RHit.y>-0.5) {\n                    RHC = texture(iChannel0,vec2(CBrickUV.x+52.,CBrickUV.y)*IRES).xyz;\n                } else {\n                    RHC = vec3(0.15,0.99,0.15);\n                }\n                if (Rand3.z>=RM.y) Color += Pixel.C*RHC*0.5*(1.-exp(-RHit.x*0.05)); //Fake multibounce integrand\n            } else {\n                //Sky\n                Color = SampleSky(RDir,SunDir)*((Rand3.z<RM.y)?Reflectance:Pixel.C);\n            }\n            //Nan test\n            bvec3 test = isnan(Color);\n            if (test.x || test.y || test.z) Color = vec3(0.);\n        }\n    } else {\n        //Sky\n        Color = SampleSky(Dir,SunDir);\n    }\n    \n    \n    //DEBUG\n    /*\n    vec2 CMUV = floor(fragCoord+vec2(0.,max(0.,iMouse.y*IRES.y*1024.*7.-1024.)))+0.5;\n    if (CMUV.y<1024.*6.) Color = textureCube(floor(CMUV)+0.5).xyz;\n    //*/\n    //Color = texture(iChannel0,fragCoord*0.25*IRES).xyz;\n    \n    \n    fragColor = vec4(Color,1.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Accumulation\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel2,fragCoord*IRES);\n    vec4 Sample = texture(iChannel1,fragCoord*IRES);\n    vec2 RMoved = texture(iChannel0,vec2(8.5,0.5)*IRES).xy;\n    bool Accumulate = (RMoved.x<0.5 && RMoved.y>0.5);\n    if (!Accumulate) {\n        //Reset accumulation\n        Output = vec4(Sample.xyz,0.);\n    } else {\n        //Continue accumulation\n        Output = vec4((Sample.xyz+Output.xyz*Output.w)/(Output.w+1.),min(1024.,Output.w+1.)); //Remove 32 later\n    }\n    fragColor = Output;\n}","name":"Buffer D","description":"","type":"buffer"}]}