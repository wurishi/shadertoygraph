{"ver":"0.1","info":{"id":"flG3RV","date":"1640299596","viewed":126,"name":"softbody","username":"HuntNight1337","description":"3d softbody","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 30\n#define MAX_DIST 30.\n#define SURF_DIST 0.01\n#define BIAS_S 0.5\n#define LIGHT_POS vec3(0, 0, 0)\n#define BLEND 2.\n\nfloat smin(float a, float b)\n{\n    float h = clamp( 0.5+0.5*(b-a)/BLEND, 0.0, 1.0 );\n    return mix( b, a, h ) - BLEND*h*(1.0-h);\n}\nvec3 SpherePos(int index, int count) {\n    float full = 3.14 * 1.7;\n    float delta = (full / float(count)) * float(index);\n    return vec3(sin(iTime + delta) / 1. * BIAS_S, cos(iTime + delta) / 1. * BIAS_S + 1., sin(iTime + delta) * 0.5 * BIAS_S) + vec3(0,0,5);\n}\nfloat GetDistance(vec3 p) {\n    float minDist = 10000.;\n    float sphereR = 0.3;\n    int count = 3;\n    for (int i = 0; i < count; i++) {\n        float sphereDistance = length(SpherePos(i, count) - p) - sphereR;\n        minDist = smin(minDist, sphereDistance);\n    }\n    return minDist;\n}\n\nfloat RayMarching(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dd = GetDistance(ro + rd * d);\n        d += dd;\n        if (dd < SURF_DIST || d > MAX_DIST) break;\n    }\n    return d;\n}\nfloat Shadow (vec3 p) {\n    return 0.;\n    float d = length(LIGHT_POS - p);\n    vec3 toLight = normalize(LIGHT_POS - p);\n    p += toLight * SURF_DIST;\n    float realDir = RayMarching(p, LIGHT_POS - p);\n    float r = step(-0.001, d / realDir);\n    return 1. - clamp(r, 0., 1.);\n}\n\nvec3 Normal(vec3 p) {\n    vec2 b = vec2(0.1, 0.);\n    float d = GetDistance(p);\n    vec3 n = d - vec3(\n        GetDistance(p - b.xyy),\n        GetDistance(p - b.yxy),\n        GetDistance(p - b.yyx));\n    return normalize(n);\n}\nfloat Light(vec3 p) {\n    vec3 dTLight = normalize(LIGHT_POS - p);\n    vec3 normal = Normal(p);\n    float prod = dot(dTLight, normal);\n    float l = clamp(prod, 0.0, 1.);\n    float s = Shadow(p);\n    float res = l - s;\n    return clamp (res, 0.1, 1.0);\n    \n}\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    vec3 bgCol = vec3(0);\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = vec3(uv.x, uv.y, 1);\n    float d = RayMarching(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 fgCol = vec3(uv.x + 0.5, uv.y + 0.5, 0.2);\n    fgCol += vec3(0.5, 0.0, 0.5);\n    fgCol = clamp(fgCol, 0., 1.);\n    fgCol = pow(fgCol, vec3(0.45));\n    fgCol = rgb2hsv(vec3(fgCol.x * sin(uv.x), fgCol.y * cos(uv.y), fgCol.z * cos(uv.x)));\n    float light = Light(p);\n    \n    fragColor = vec4(mix(bgCol, fgCol, light), 1);\n    //fragColor = vec4(vec3(light), 1);\n}","name":"Image","description":"","type":"image"}]}