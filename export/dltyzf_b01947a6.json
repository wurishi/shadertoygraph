{"ver":"0.1","info":{"id":"dltyzf","date":"1699968394","viewed":73,"name":"Duffin + Kelvin Transform WoS","username":"minHieu","description":"walk-on-sphere implementation to solve Helmholtz equation in sound propagation.\nDuffin Correspondence theorem allows the mapping of Helmholtz equation to a Laplace equation. \nKelvin Transform allows for inverting domain and thus unbounded Walk-on-Sphere.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf","spooky","wos","walkonsphere"],"hasliked":0,"parentid":"dstfD4","parentname":"Walk on Spooky Distance Field"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float get_value(sampler2D buffer, vec2 fragCoord, float freq) {\n    vec4 data = texelFetch(buffer, ivec2(fragCoord), 0);\n    return data.x * cos(get_t(iFrame)*2.*freq) / data.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    float uw0 = get_value(iChannel0, fragCoord, 4.);\n    float uw1 = get_value(iChannel1, fragCoord, 7.);\n    \n    float ut = uw0 + uw1;\n    fragColor = vec4(vec3(max(ut,0.), 0, max(-ut,0.)), 1.0 ) ;;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate\n    vec2 uv = normalize_uv(fragCoord, iResolution.xy);\n    \n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x + hash(q.y + hash(iFrame))));\n    \n    float lambda = 4.0;\n    \n    // fragColor = fColor;\n    if(get_t(iFrame) < 0.3) {\n        fragColor = wos_monte_carlo(uv, lambda);\n    } else if (get_t(iFrame) < 4.) {\n        vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        fragColor = data + wos_monte_carlo(uv, lambda);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159;\nconst float PI2 = 6.28319;\nconst float EPS = 0.0001;\nconst int MAX_WALKS = 20;\nconst int MAX_SAMPLES = 10;\n\n// misc function \nfloat get_t(int iframe) {\n  return 20.*(float(iframe)*0.0005);\n}\n\n// Scene geometry\nfloat circ_sdf(vec2 q, vec2 c, float r) {\n    return length(q-c)-r;\n}\nfloat rect_sdf(vec2 q, vec2 c, vec2 halfsize) {\n    vec2 d = abs(q-c)-halfsize;\n    float idist = length(max(d,0.));\n    float odist = min(max(d.x,d.y),0.);\n    return idist+odist;\n}\nfloat union_sdf(float d1, float d2) {\n    return min(d1,d2);\n}\nfloat sub_sdf(float d1, float d2) {\n    return max(d1,-d2);\n}\nfloat skull_sdf(vec2 uv) {\n    float d1 = circ_sdf(uv, vec2(.5,.6), .25);\n    float d2 = rect_sdf(uv, vec2(.5,.5), vec2(0.1, 0.3));\n    float eye1 = circ_sdf(uv, vec2(.58,.58), .05);\n    float eye2 = circ_sdf(uv, vec2(.42,.58), .05);\n    float head = sub_sdf(sub_sdf(union_sdf(d1,d2),eye1),eye2);\n    // float head = union_sdf(d1,d2);\n    float mouth = union_sdf(\n        union_sdf(circ_sdf(uv, vec2(.5,.45), .05),\n                  circ_sdf(uv, vec2(.5,.35), .05)),\n        rect_sdf(uv, vec2(.5,.4), vec2(.05, 0.05))\n    );\n    return sub_sdf(head, mouth);\n}\nvec2 kelvin_transform(vec2 x) {\n    if (length(x) < 0.00001) \n        return vec2(0);\n    return x / length(x)*0.3;\n}\n\n\n// from Alex Jacobson's Curve Inflation \n// https://www.shadertoy.com/view/7tyyzW\nint  seed = 1;\nvoid srand(int s) {\n    seed = s;\n}\nint randi(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\nfloat rand(void) {\n    return float(randi())/32767.0;\n}\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\nvec2 rand_s2(void) {\n    float theta = PI2*rand();\n    return vec2(cos(theta),sin(theta));\n}\nvec3 rand_s3(void) {\n    float z = 2.*rand()-1.;\n    float theta = PI2*rand();\n    return vec3(vec2(sin(theta),cos(theta))*sqrt(1.-z*z), z);\n}\n\n// misc\nvec2 normalize_uv(vec2 fragCoord, vec2 ires) {\n    vec2 uv = fragCoord/ires.xy;\n    if (ires.x > ires.y) {\n        uv.x *= ires.x / ires.y;\n        uv.x += .5 * (1. - ires.x / ires.y);\n    } else {        \n        uv.y *= ires.y / ires.x;\n        uv.y += .5 * (1. - ires.y / ires.x);\n    }\n    return uv;\n}\n\n// green function of ball at x B(x) of radius R\n// following https://dl.acm.org/doi/abs/10.1145/3386569.3392374\n// Supplementary B1. This evaluate G at a random sample.\nfloat G(float R) {\n    float r = R*sqrt(rand()+0.001);\n    return log(R/r)/PI2;\n}\nvec2 grad_G(float R) {\n    float r = R*sqrt(rand());\n    float theta = rand() * PI2;\n    vec2 dir = vec2(cos(theta),sin(theta));\n    return dir / PI2 * (1./(r*r) - 1./(R*R));\n}\n\n\n// return color value at point with inflated height z\n// https://www.shadertoy.com/view/7tyyzW\nvec4 shading(vec2 uv, float u, vec2 grad_u) {    \n    vec3 Kd = vec3(0.76, 0.31, 0.31); // diffuse\n    vec3 Ks = vec3(1.,1.,1.);         // specular \n    vec3 Kf = 0.4*Ks;\n    vec3 Ka = 0.1*Kd;               \n    \n    if(u <= 0.0) return vec4(Ka, 1.0);\n\n    float z = sqrt(u);\n    vec3 n = normalize(vec3(-grad_u*0.5/z,1));\n    \n    const int nlights = 2;\n    vec3 lights[nlights];\n    lights[0] = normalize(vec3(1.5,2.,1.));\n    lights[1] = normalize(vec3(-1.5,2.,1.));\n    vec3 Kl[nlights];\n    Kl[0] = vec3(1.,0.6,0.6);\n    Kl[1] = vec3(.6,0.6,1.0);\n    vec3 color = vec3(0.,0.,0.);\n    vec3 p = vec3(uv,z);\n    vec3 c = vec3(0.,0.,5.);\n    vec3 v = normalize(c-p);\n    for(int i = 0;i<2;i++) {\n        vec3 l = lights[i];\n        float d = max(dot(n,l),0.);\n        vec3 h = normalize(l+v);\n        float s = pow(max(dot(n,h),0.),100.);\n        color += Kl[i]*(Kd*d+Ks*s);\n    }\n    float NE = dot(n,v);\n    float f = pow(max(sqrt(1. - NE*NE),0.0), 50.);\n    color += Kf*f+Ka;\n    \n    return vec4(color,1.0);\n    \n}\n\nfloat main_sdf(vec2 uv) { \n    vec2 uv_kelvin = kelvin_transform(uv);\n    return -circ_sdf(uv, vec2(0.5), 0.3);\n}\n\nfloat DirichletBC(vec2 p, float lambda) {\n    float theta = atan(p.y-0.5,p.x-0.5);\n    return max(sin(theta*lambda),0.);\n    // return (p.x-0.3)/0.3-0.3;\n    // return 0.;\n    // return pow(p.x,3.) + p.x*p.x;\n}\n\nfloat wos(vec2 x, float lambda) {\n    float R = main_sdf(x);  \n    vec3 x_duff = vec3(x, 0);\n    \n    if (R <= 0.) return 0.;       // outside scene\n    float R1 = R;\n    vec3 v1;\n    \n    for (int k = 0; k < MAX_WALKS; k++) {\n        if (R < EPS) break;\n        x_duff += R * rand_s3();\n        R = main_sdf(x_duff.xy);\n    }\n    \n    return DirichletBC(x_duff.xy, lambda) * cosh(lambda*x_duff.z);\n}\n\nvec3 wos_boundary_termination(vec2 x) {\n    float R = main_sdf(x);  \n    vec3 x_duff = vec3(x, 0);\n    \n    if (R <= 0.) return x_duff;       // outside scene\n    float R1 = R;\n    vec3 v1;\n    \n    for (int k = 0; k < MAX_WALKS; k++) {\n        if (R < EPS) break;\n        x_duff += R * rand_s3();\n        R = main_sdf(x_duff.xy);\n    }\n    return x_duff;\n}\n\nvec4 wos_monte_carlo(vec2 x, float lambda) {\n    float u;\n    for (int i = 0; i < MAX_SAMPLES; i++) \n        u += wos(x, lambda);\n    u /=  float(MAX_SAMPLES);\n\n    return vec4(max(u,0.), 0, max(-u,0.), 1.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate\n    vec2 uv = normalize_uv(fragCoord, iResolution.xy);\n    \n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x + hash(q.y + hash(iFrame))));\n    \n    float lambda = 7.0;\n    \n    // fragColor = fColor;\n    if(get_t(iFrame) < 0.3) {\n        fragColor = wos_monte_carlo(uv, lambda);\n    } else if (get_t(iFrame) < 4.) {\n        vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        fragColor = data + wos_monte_carlo(uv, lambda);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}