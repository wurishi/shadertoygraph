{"ver":"0.1","info":{"id":"Wly3Rz","date":"1599124657","viewed":96,"name":"Noise parallax landscape ","username":"alarch","description":"Hmm :D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noiseparallaxlandscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MIN = -2147483648;\nint MAX = 2147483647;\n\nfloat noise1(int x, int y)\n{\n    int n;\n    n = x+y*57;\n    x = (n<<13) ^ n;\n    return ( 1.0 - float( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);\n \n}\n\nfloat smoothedNoise2D(int x, int y)\n{\n    int multiplier = 1;\n    float corners, sides, center;\n    corners = ( noise1(int(x-multiplier), int(y-multiplier))+noise1(int(x+multiplier), int(y-multiplier))+noise1(int(x-multiplier), int(y+multiplier))+noise1(int(x+multiplier), int(y+multiplier)) ) / 16.0;\n    sides   = ( noise1(int(x-multiplier), int(y))+noise1(int(x+multiplier), int(y))+noise1(int(x), int(y-multiplier))+noise1(int(x), int(y+multiplier)) ) /  8.0;\n    center  =  noise1(int(x), int(y)) / 4.0;\n    return corners + sides + center;\n}\n\n\nfloat interpol(float a, float b, float x)\n{\n    float ft, f;\n    ft = x * 3.1415927;\n    f = (1.0 - cos(ft)) * 0.5;\n    return  a*(1.0-f) + b*f;\n}\n\nfloat interpolatedNoise(float x,float y)\n{\n      float fractional_X,fractional_Y,v1,v2,v3,v4,i1,i2;\n      int integer_X,integer_Y;\n   \n      integer_X    = int(x);\n      fractional_X = x - float(integer_X);\n \n      integer_Y    = int(y);\n      fractional_Y = y - float(integer_Y);\n \n      v1 = smoothedNoise2D(integer_X,     integer_Y);\n      v2 = smoothedNoise2D(integer_X + 1, integer_Y);\n      v3 = smoothedNoise2D(integer_X,     integer_Y + 1);\n      v4 = smoothedNoise2D(integer_X + 1, integer_Y + 1);\n \n      i1 = interpol(v1 , v2 , fractional_X);\n      i2 = interpol(v3 , v4 , fractional_X);\n \n      return interpol(i1 , i2 , fractional_Y);\n \n}\n\nfloat fbmNoise(float x,float y, float freq)\n{\n    x = x*1000.0;\n    y = y*1000.0;\n    float total,p,amplitude;\n    int i,n;\n    total = 0.0;\n    p = 2.0;\n    n = 8;\n \n    float frequency;\n \n    for(i=0; i<=n;i++)\n    {\n        frequency = freq*(2.0,float(i));    \n        amplitude = p/(pow(2.0,float(i)));\n        total = total+interpolatedNoise(x*frequency/20.0,y*frequency/20.0)*amplitude;\n    }\n    return total;\n}\n\n// XORSHIFT NOISE CODE (1D value noise)\nint xorshift(in int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(inout int seed) {\n    seed = xorshift(seed);\n    return seed;\n}\n\nfloat nextFloat(inout int seed) {\n    seed = xorshift(seed);\n    // FIXME: This should have been a seed mapped from MIN..MAX to 0..1 instead\n    return abs(fract(float(seed) / 3141.592653));\n}\n\nfloat nextFloat(inout int seed, in float max) {\n    return nextFloat(seed) * max;\n}\n\nfloat linearInterpolate(float a,float b,float x)\n{\n\treturn  a*(1.0-x) + b*x;\n}\n\nfloat cosInterpolate(float a, float b, float x)\n{\n    float ft = x * 3.1415927;\n\tfloat f = (1.0 - cos(ft)) * 0.5;\n\treturn  a*(1.0-f) + b*f;\n}\n\nfloat smoothedNoise(int rngSeed, float x, float stepSize)\n{\n    stepSize = 1.0/stepSize;\n    vec2 var2;\n    var2.x = x;\n    int step = int(floor(x*stepSize));   //-fract(uv.x*10.0));\n    rngSeed = step-1; \n    nextFloat(rngSeed); \n    var2.y = nextFloat(rngSeed); \n    rngSeed = step; nextFloat(rngSeed);\n    float zz = nextFloat(rngSeed);                    \n    var2.y = cosInterpolate(var2.y, zz, (fract(x*stepSize)));\n    return var2.y;\n}\n\nfloat valueNoise(int rngSeed, float x, float persistence)\n{\n    int octave = 1;\n    float maxFreqLimit = 40.1; // max frequency of noise, multiple of octave. \n    float retVal = 0.0;\n    for(float i = 1.0; i<maxFreqLimit; i = i*float(octave))\n    {\n    \tretVal += smoothedNoise(rngSeed, x, persistence/i)/i;\n        octave = octave << 1;\n    }\n    return retVal/1.35; // WHY does this not be in the range 1.0 ... 0.1 ?\n   \n}   \n\nprecision lowp    float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv;\n\n    // same as vec2 uv = fragCoord/iResolution.xy;\n    uv.x = fragCoord.x/iResolution.x;\n    uv.y = fragCoord.y/iResolution.y;\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n        \n    // set Image aspect to square or you will get an oval\n    uv *= iResolution.xy  / iResolution.y;\n    // same as vec2 uv = fragCoord/iResolution.xy;\n    \n   \n    int rngSeed = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    \n    float blue = (nextFloat(rngSeed)+uv.y*0.5)-0.25; \n    float green; \n    float col2;\n    float bgNoise;\n    \n    float scaler=1.0;\n    \n    vec3 snow = vec3(0.0);\n    \n    for(float i=0.0;i<1.0;i=i+0.1)\n    {\n        float parallax = i*1.01;\n        float mountain = (12234.0+uv.x+parallax*float(iTime/2.0)/10.0)+(1234.0*i);\n        \n        // scale smaller as more distant\n        //mountain = 0.5+mountain*(i);\n        \n        float valueNoise = valueNoise(rngSeed, mountain, 0.5-(scaler/1.5));\n    \tfloat y = valueNoise/(2.4/scaler)+1.00;\n    \t\n        scaler = scaler + 0.1;\n    \n    \tif(((uv.y + 1.0+i) - y) < 0.001)\t\n    \t{\n     \t\tcol2 = 0.2+i*scaler/4.0;\n        \tbgNoise = 0.0;\n            \n            if((valueNoise > 0.8) && (((uv.y + 1.0+i) - y) > -(0.010/(1.0/scaler)))\t) \n            {\n                snow = vec3(1.0);\n            }\n            else\n            {\n                snow = vec3(0.0);\n            }\n            \n            //green = texture(iChannel1, vec2(uv.x+mountain, uv.y)).r;\n            //green = fbmNoise(mountain,uv.y+0.5, (1.0/scaler)*10.0)/2.0;\n    \t}\n    \telse\n    \t{\n            \n        \t// color/pattern background\n    \t\t\n    \t}\n    }\n    \n    if(col2 == 0.0) \n    {\n        bgNoise = blue; //smoothedNoise(rngSeed, uv.x, 0.01) + smoothedNoise(rngSeed, uv.y, 0.01);\n    }\n    \n    \n    \n    fragColor = vec4(snow.r, col2+snow.g, bgNoise/3.0+snow.b, 1.0);\n}\t\n","name":"Image","description":"","type":"image"}]}