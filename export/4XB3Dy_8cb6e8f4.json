{"ver":"0.1","info":{"id":"4XB3Dy","date":"1709339456","viewed":117,"name":"Ancient Runes","username":"goteguru","description":"variant of otaviogood's nice rune generator. Changes:\nOlder looking runes, spaces, repeating runes, aspect ratio, rune variants (small changes), procedural noise\nhttps://www.shadertoy.com/view/MsXSRn","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","font","letters","runes"],"hasliked":0,"parentid":"MsXSRn","parentname":"runes"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n#define saturate(a) clamp(a, 0., 1.)\n\n#define ASPECT 0.7\n#define ALPHABET 65.\n\nvec2 rnd2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( rnd2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( rnd2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( rnd2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( rnd2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// makes a thick line and passes back gray in x and derivates for lighting in yz\nvec3 ThickLine(vec2 uv, vec2 posA, vec2 posB, float radiusInv)\n{\n\tvec2 dir = posA - posB;\n\tfloat dirLen = length(dir);\n\tvec2 dirN = normalize(dir);\n\tfloat dotTemp = clamp(dot(uv - posB, dirN), 0.0, dirLen);\n\tvec2 proj = dotTemp * dirN + posB;\n\tfloat d1 = distance(uv, proj);\n\tvec2 derivative = (uv - proj);\n\n\tfloat finalGray = saturate(1.0 - d1 * radiusInv );\n\t// multiply derivative by gray so it smoothly fades out at the edges.\n\treturn vec3(finalGray, derivative * finalGray);\n}\n\n// makes a rune in the 0..1 uv space. Seed is which rune to draw.\n// passes back gray in x and derivates for lighting in yz\nvec3 Rune(vec2 uv, float variant)\n{\n    uv *= 1.1 ; // smaller runes\n    vec2 seed = vec2(variant*7., variant*3.);\n    vec3 finalLine = vec3(0.0, 0.0, 0.0);\n    if (fract(variant) < .2) return finalLine;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec2 posA = rnd2(seed);\n\t\tvec2 posB = rnd2(posA);\n \t\tseed = posB;\n        \n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tposA = fract(posA * 128.0);\n\t\tposB = fract(posB * 128.0);\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) posA.y = 0.0;\n\t\tif (i == 1) posA.x = 0.999;\n\t\tif (i == 2) posA.x = 0.0;\n\t\tif (i == 3) posA.y = 0.999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec2 snaps = vec2(2.0, 3.0);\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps;\t// + 0.5 to center it in a grid cell\n\t\tposB = (floor(posB * snaps) + 0.5) / snaps;\n        posA.x *= 0.6;\n        posB.x *= 0.6;\n\n\t\t//if (distance(posA, posB) < 0.0001) continue;\t// eliminate dots.\n\n\t\t// Dots (degenerate lines) are not cross-GPU safe without adding 0.001 - divide by 0 error.\n\t\tvec3 tl = ThickLine(uv, posA, posB + 0.001, 10.0);\n\t\tif (tl.x > finalLine.x) finalLine = tl;\n\t}\n\treturn finalLine.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    //uv = uv * (sin(iTime* 0.3)*.2 + .8);\t// zoom \n\tuv.x += iTime * 0.03;\t// scroll left with time\n    \n    vec2 variant = uv;\n    vec3 finalColor = texture(iChannel1, uv * vec2(1.0, -1.0)).xyz;\t// background texture\n\tfinalColor = finalColor * finalColor;\t// gamma correct\n\n\t//finalColor += ThickLine(uv, vec2(0.8, 0.2), vec2(0.8, 0.8), 8.0) * vec3(0.0, 10.0, 10.0);\n\t//vec2 noisev = texture(iChannel0, uv*.1).xy * 0.03 + texture(iChannel0, uv*2.).xy * 0.004;\n    float noisev = noise(uv*1.5) * 0.05   + noise(uv*20.) * 0.008;\n\tuv += noisev;\t// noise makes everything look more natural\n\n\t// make a grid for drawing the runes.\n\tuv *= 8.0;\n        \n    uv.x /= ASPECT; \n    vec2 rSpace = fract(uv);\n    rSpace.x *= ASPECT;\n\tvec2 newSeed = rnd2(floor(uv));\n    float letter = mod(newSeed * 300., ALPHABET).x ; // length of the alphabet\n       \n\n\tvec3 finalLine = Rune(rSpace, letter);\n\n\tfinalColor = saturate(\n            finalColor * (1.0 - pow(finalLine.x, 0.95)*0.83)\n        ) * (1.0+saturate(-finalLine.z)*78.0);\n\t//finalColor += vec3(mod(letter*7., ALPHABET)/ALPHABET,mod(letter*13.,ALPHABET)/ALPHABET,letter/ALPHABET);\t// view grid\n    //finalColor = vec3(noise(uv*1.5) * 1. + .5)*0.15;\n\n\tfragColor = vec4(sqrt(finalColor),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}