{"ver":"0.1","info":{"id":"MdjyRy","date":"1492632370","viewed":491,"name":"PBR texture repetition","username":"jbouny","description":"Aggregation of texture variation techniques applied in a PBR model (channel 2 is used as roughness/color input)","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["repetition","materials","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author : Jeremy Bouny\n// Created : April 2017\n//\n// Aggregation of texture variation techniques applied in a PBR model\n//  _____________________________________\n// |                  |                  |\n// | Standard texture |     Texture      |\n// |      repeat      |    variation I   |\n// |__________________|__________________|\n// |                  |                  |\n// |      Texture     |     Texture      |\n// |   variation II   |    variation V   |\n// |__________________|__________________|\n\n\n// Sources:\n// - Sebastien Berube - PBR model fork from https://www.shadertoy.com/view/ld3SRr\n// - Inigo Quilez - Texture variation I: https://www.shadertoy.com/view/4tsGzf\n// - Inigo Quilez - Texture variation II: https://www.shadertoy.com/view/lt2GDd\n// - Inigo Quilez - Texture variation V: https://www.shadertoy.com/view/Xtl3zf\n// License : Creative Commons Non-commercial (NC) license\n\nconst bool MULTI_VIEW = true;\nconst float TEXTURE_REPEAT = 40.0;\n\n//----------------------\n// Constants \nconst float GEO_MAX_DIST   = 50.0;\nconst int MATERIALID_SKY    = 2;\nconst int MATERIALID_SPHERE = 3;\nconst vec3  F_ALU_N  = vec3(1.600,0.912,0.695); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_ALU_K  = vec3(8.010,6.500,5.800); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst float ABL_LIGHT_CONTRIBUTION = 0.3; //[0-1] Additional ABL Light Contribution\n\n#define M_PI 3.1415926535897932384626433832795\n#define saturate(x) clamp(x,0.0,1.0)\n\n//PBR Equation for both (IBL) or (ABL), plastic or metal.\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, const vec3 ior_n, const vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //Distribution Term\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = 1.0; //Distribution term is externalized from IBL version\n    if(!bIBL)\n        D = (NdotH>0.)?alpha2/(PI*den*den):0.0; //GGX Distribution.\n\t\n    //Fresnel Term\n\tvec3 F;\n    if(metallic)\n    {\n        float cos_theta = 1.0-NdotV;\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t    /((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n    }\n    else //Dielectric (Note: R/G/B do not really differ for dielectric materials)\n    {\n        float F0 = pow((1.0 - ior_n.x) / (1.0 + ior_n.x),2.0);\n  \t\tF = vec3(F0 + (1.-F0) * pow( 1. - VdotH, 5.));\n    }\n    \n    //Geometric term (Source: Real Shading in Unreal Engine 4 2013 Siggraph Presentation p.3/59)\n    //k = Schlick model (IBL) : Disney's modification to reduce hotness (point light)\n    float k = bIBL?(roughness*roughness/2.0):(roughness+1.)*(roughness+1.)/8.; \n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    \n    float softTr = 0.1; // Valid range : [0.001-0.25]. Transition softness factor, close from dot(L,N) ~= 0\n    float angleLim = 0.15; // Valid range : [0-0.75]. Compensates for IBL integration suface size.\n    if(bIBL)\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr));\n    else\n        return D*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    return mix(c,c*6.0,fHDR);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01)\n{\n    vec3 linearGammaColor_sharp = PBR_HDRremap(pow(texture( iChannel1, sampleDir ).rgb,vec3(2.2)));\n    vec3 linearGammaColor_blur  = PBR_HDRremap(pow(texture( iChannel0, sampleDir ).rgb,vec3(1)));\n    vec3 linearGammaColor = mix(linearGammaColor_sharp,linearGammaColor_blur,saturate(LOD_01));\n    return linearGammaColor;\n}\n\n//Arbitrary axis rotation (around u, normalized)\nmat3 PBR_axisRotationMatrix( vec3 u, float ct, float st ) //u=axis, co=cos(t), st=sin(t)\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\nvec3 PBR_importanceSampling(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n    float phi = 2.0*M_PI*e2;\n    vec3 notColinear   = (abs(sampleDir.y)<0.8)?vec3(0,1,0):vec3(1,0,0);\n    vec3 othogonalAxis = normalize(cross(notColinear,sampleDir));\n\tmat3 m1 = PBR_axisRotationMatrix(normalize(othogonalAxis), cos(range), sin(range));\n\tmat3 m2 = PBR_axisRotationMatrix(normalize(sampleDir),     cos(phi),   sin(phi));\n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k)\n{\n    const float MIPMAP_SWITCH  = 0.29; //sampling angle delta (rad) equivalent to the lowest LOD.\n    const ivec2 SAMPLE_COUNT = ivec2(05,15); //(5 random, 15 fixed) samples\n    const vec2 weight = vec2(1./float(SAMPLE_COUNT.x),1./float(SAMPLE_COUNT.y));\n    float angularRange = 0.;    \n    vec3 vCenter = reflect(-V,N);\n    \n    //Randomized Samples : more realistic, but jittery\n    float randomness_range = 0.75; //Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              //valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[0]; ++i)\n    {\n        //Random noise from DaveHoskin's hash without sine : https://www.shadertoy.com/view/4djSRW\n        vec3 p3 = fract(vec3(fIdx*10.0+vCenter.xyx*100.0) * vec3(.1031,.11369,.13787)); \n    \tp3 += dot(p3.zxy, p3.yzx+19.19);\n    \tvec2 jitter = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x*randomness_range, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[0];\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    //Fixed Samples : More stable, but can create sampling pattern artifacts (revealing the sampling pattern)\n    fIdx = 0.0;\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[1]; ++i)\n    {\n        vec2 jitter = vec2( clamp(weight[1]*fIdx,0.0,0.50), fract(weight[1]*fIdx*1.25)+3.14*fIdx); //Fixed sampling pattern.\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[1];\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    return (totalRandom*weight[1]+totalFixed*weight[0])/(weight[0]+weight[1]);\n}\n\n// https://www.shadertoy.com/view/4tsGzf\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\nvec3 textureVariationI( sampler2D samp, in vec2 uv )\n{\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n\t\n    // derivatives (for correct mipmapping)\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n\tvec3 va = vec3(0.0);\n\tfloat w1 = 0.0;\n    float w2 = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec4 o = hash4( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + o.zw, ddx, ddy ).xyz;\n\t\tva += w*c;\n\t\tw1 += w;\n        w2 += w*w;\n    }\n\n    // contrast preserving average\n    float mean = textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 res = mean + (va-w1*mean)/sqrt(w2);\n    return res;\n}\n\nvec3 textureVariationII( sampler2D samp, in vec2 uv )\n{\n    vec2 iuv = floor( uv );\n    vec2 fuv = fract( uv );\n\n    // generate per-tile transform\n    vec4 ofa = hash4( iuv + vec2(0.0,0.0) );\n    vec4 ofb = hash4( iuv + vec2(1.0,0.0) );\n    vec4 ofc = hash4( iuv + vec2(0.0,1.0) );\n    vec4 ofd = hash4( iuv + vec2(1.0,1.0) );\n    \n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n\n    // transform per-tile uvs\n    ofa.zw = sign(ofa.zw-0.5);\n    ofb.zw = sign(ofb.zw-0.5);\n    ofc.zw = sign(ofc.zw-0.5);\n    ofd.zw = sign(ofd.zw-0.5);\n    \n    // uv's, and derivarives (for correct mipmapping)\n    vec2 uva = uv*ofa.zw + ofa.xy; vec2 ddxa = ddx*ofa.zw; vec2 ddya = ddy*ofa.zw;\n    vec2 uvb = uv*ofb.zw + ofb.xy; vec2 ddxb = ddx*ofb.zw; vec2 ddyb = ddy*ofb.zw;\n    vec2 uvc = uv*ofc.zw + ofc.xy; vec2 ddxc = ddx*ofc.zw; vec2 ddyc = ddy*ofc.zw;\n    vec2 uvd = uv*ofd.zw + ofd.xy; vec2 ddxd = ddx*ofd.zw; vec2 ddyd = ddy*ofd.zw;\n        \n    // fetch and blend\n    vec2 b = smoothstep(0.25,0.75,fuv);\n    \n    return mix( mix( textureGrad( samp, uva, ddxa, ddya ), \n                     textureGrad( samp, uvb, ddxb, ddyb ), b.x ), \n                mix( textureGrad( samp, uvc, ddxc, ddyc ),\n                     textureGrad( samp, uvd, ddxd, ddyd ), b.x), b.y ).xyz;\n}\n\n// https://www.shadertoy.com/view/Xtl3zf\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\nvec3 textureVariationV( sampler2D samp, in vec2 uv )\n{\n    float k = texture( iChannel3, 0.005*uv ).x; // cheap (cache friendly) lookup\n    \n    float l = k*8.0;\n    float i = floor( l );\n    float f = fract( l );\n    \n    vec2 offa = sin(vec2(3.0,7.0)*(i+0.0)); // can replace with any other hash\n    vec2 offb = sin(vec2(3.0,7.0)*(i+1.0)); // can replace with any other hash\n\n    vec2 dx = dFdx(uv), dy = dFdy(uv);\n    \n    vec3 cola = textureGrad( samp, uv + offa, dx, dy ).xyz;\n    vec3 colb = textureGrad( samp, uv + offb, dx, dy ).xyz;\n    \n    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );\n}\n\nvec3 sampleTexture(vec2 uv, int method)\n{\n\tuv *= TEXTURE_REPEAT;\n\tif (method == 1) return textureVariationI(iChannel2, uv);\n\telse if (method == 2) return textureVariationII(iChannel2, uv);\n\telse if (method == 3) return textureVariationV(iChannel2, uv);\n\telse return texture(iChannel2, uv).xyz;\n}\n\nstruct TraceData\n{\n    float rayLen; //Run Distance\n    vec3  rayDir; //Run Direction\n    vec3  normal; //Hit normal\n    int   matID;  //Hit material ID\n};\n\n//The main material function.\nvec3 MAT_apply(vec3 pos, TraceData traceData, int method)\n{\n    // Compute UV from sphere position\n\tfloat u = 0.5 + atan(pos.x, pos.z) / M_PI;\n\tfloat v = 0.5 - asin(pos.y) / M_PI;\n    \n    // Textures (roughness and color)\n    vec3 color = sampleTexture(vec2(u, v), method);\n    float roughness = length(color);\n    \n    // Tweak textures values\n    roughness *= roughness;\n    color *= vec3(0.8, 1.0, 0.3);\n    \n    //IBL and ABL PBR Lighting\n    vec3 rd  = traceData.rayDir;\n    vec3 V = normalize(-traceData.rayDir);\n    vec3 N = traceData.normal;\n    vec3 L = normalize(vec3(1,1,0));\n    vec3 col = PBR_visitSamples(V,N,roughness, true, F_ALU_N, F_ALU_K);\n    vec3 L0  = PBR_Equation(V,L,N,roughness+0.01, F_ALU_N, F_ALU_K, true, false);\n    col += PBR_HDRremap(vec3(1))*L0*ABL_LIGHT_CONTRIBUTION;\n\tcol *= color;\n    \n    //Anti-aliasing trick (normal-based)\n    vec3 backgroundColor = pow(texture( iChannel1, traceData.rayDir ).xyz,vec3(2.2)) * 1.0;\n    float aaAmount = 0.095;\n    float smoothFactor = 1.0-clamp(-dot(N,traceData.rayDir)/(aaAmount), 0.0, 1.0);\n    col = (dot(N,-traceData.rayDir)<aaAmount)? mix(col, backgroundColor, smoothFactor) : col;\n    \n    return traceData.matID==MATERIALID_SKY?backgroundColor:col;\n}\n\n//o=ray origin, d=ray direction\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    float t = 0.0;\n    float tmax = GEO_MAX_DIST;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<50; i++ )\n    {\n\t    dist = length(o+d*t) - 1.0;\n        if( abs(dist)<0.001 || t>GEO_MAX_DIST ) break;\n        t += dist;\n    }\n    \n    vec3 dfHitPosition  = o+t*d;\n    bool bBackground = (dist>0.01 || t>GEO_MAX_DIST);\n    \n    return TraceData(t,d,normalize(dfHitPosition),bBackground?MATERIALID_SKY:MATERIALID_SPHERE);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Camera & setup\n    float rotX = iMouse.z>0.?\n\t                  ((iMouse.x/iResolution.x)*2.0*3.14) :\n                      (iTime*0.2);\n    vec2 coordinates = fragCoord.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    int method = 0;\n    if (uv.x > 0.5) method += 1;\n    if (uv.y < 0.5) method += 2;\n    if (MULTI_VIEW) uv = mod(uv * 2.0, 1.0);\n    vec3 camO = vec3(cos(rotX),0.4,sin(rotX))*1.4;\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD,vec3(0,1,0)));\n    vec3 camU = cross(camR,camD);\n    vec2 xy = (uv - vec2(0.5, 0.25)) * vec2(iResolution.x/iResolution.y, 1.0) * 1.5;\n   \tvec3 dir =  normalize(xy.x*camR+xy.y*camU+camD);\n    \n    //Raytrace\n    TraceData geometryTraceData = TRACE_geometry(camO, dir);\n    vec3 ptGeo = (geometryTraceData.rayLen < GEO_MAX_DIST)? camO+dir*geometryTraceData.rayLen : vec3(0);\n    \n    //Material\n    vec3 c = MAT_apply(ptGeo,geometryTraceData, method).xyz;\n    \n    //Post-processing\n    vec2 uv2 = (uv - 0.5) * 1.3;\n    float sin2 = dot(uv2, uv2);\n    float vignetting = pow(1.0-min(sin2*sin2,1.0),2.);\n    c = pow(c*vignetting,vec3(0.4545)); //2.2 Gamma compensation\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}