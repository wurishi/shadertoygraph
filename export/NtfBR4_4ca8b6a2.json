{"ver":"0.1","info":{"id":"NtfBR4","date":"1650556628","viewed":86,"name":"color ray marching","username":"ph04","description":"color","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct DistColor {\n    float dist;\n    vec3 color;\n};\n\nDistColor sdRoundBox(vec3 p, vec3 sizes, float r, vec3 color) {\n    vec3 q = abs(p) - sizes;\n    float dist =  length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n\n    return DistColor(dist, color);\n}\n\nvec4 RGBAtoVEC4(int r, int g, int b, int a) {\n    return vec4(r, g, b, a) / 255.;\n}\n\nDistColor getDistance(vec3 currP) {\n    float pi = 3.14159265;\n    \n    float a = -pi * .25;\n    \n    float c = cos(a);\n    float s = sin(a);\n    \n    mat3 rXY = mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n    mat3 rYZ = mat3(1, 0, 0, 0, c, s, 0, -s, c);\n    \n    DistColor dMin = DistColor(128., vec3(0));\n    \n    int offset = 0;\n    \n    for (float i = -2.5; i < 2.5; i += .4) {\n        for (float j = -2.5; j < 2.5; j += 1.) {\n            float y, z;\n            \n            if (offset % 2 == 1) {\n                y = j;\n            } else {\n                y = j + .5;;\n            }\n            \n            vec3 center = vec3(i, y, 3./2.5 * y);\n    \n            DistColor dRoundBox = sdRoundBox(\n                rXY * rYZ * (currP - center),\n                vec3(.17, .17, sin(sqrt(i * i + j * j) - iTime * 3.) + 2.),\n                0.17,\n                RGBAtoVEC4(196, 93, 41, 255).xyz\n            );\n            \n            if (dRoundBox.dist < dMin.dist) {\n                dMin = dRoundBox;\n            }\n        }\n        \n        offset += 1;\n    }\n    \n    return dMin;\n}\n\nfloat rayMarch(vec3 cam, vec3 dir) {\n    float dO = 0.;\n    \n    for (int i = 0; i < 128; i++) {\n        if (dO > 128.) break;\n        \n        vec3 currP = cam + dO * dir;\n        \n        DistColor dS = getDistance(currP);\n        \n        if (dS.dist < .001) break;\n        \n        dO += dS.dist;\n    }\n    \n    return dO;\n}\n\nvec3 getLight(vec3 currP) {\n    vec3 light1 = vec3(0, 5, -13);\n    vec3 bgCol = vec3(0, 1, 0);\n\n    vec2 e = vec2(.001, 0);\n    \n    DistColor f_p = getDistance(currP);\n    \n    vec3 N = normalize(vec3(\n        getDistance(currP + e.xyy).dist - f_p.dist,\n        getDistance(currP + e.yxy).dist - f_p.dist,\n        getDistance(currP + e.yyx).dist - f_p.dist\n    ));\n    \n    vec3 L = normalize(light1 - currP);\n    \n    return clamp(dot(N, L), 0., 1.0) * f_p.color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cam = vec3(0, -.5, -12);\n    \n    vec3 dir = normalize(vec3(uv.xy, 1));\n    \n    float d = rayMarch(cam, dir);\n\n    if (d > 128.)\n        fragColor = RGBAtoVEC4(54, 131, 255, 255);\n    else {\n        vec3 currP = cam + d * dir;\n\n        vec3 col = getLight(currP);\n\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}