{"ver":"0.1","info":{"id":"csVyRG","date":"1697720510","viewed":29,"name":"Ray Tracing - TP M1","username":"Bulgus","description":"description","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane\n{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Capsule\n{\n    vec3 p1;   // Début de la capsule\n    vec3 p2;     // Fin de la capsule\n    float r; // Rayon de la capsule\n    int i;        // ID de texture\n};\n\nstruct Torus\n{\n    /*vec3 center;     // Centre du tore\n    float majorRadius; // Rayon majeur (distance du centre au milieu du tube)\n    float minorRadius; // Rayon mineur (épaisseur du tube)*/\n    float x;\n    float y;\n    int i;            // ID de texture\n};\n\nstruct Ellipsoid\n{\n    vec3 c; // Centre\n    vec3 r; // Rayon\n    int i; // ID de texture\n};\n\nstruct Box\n{\n    vec3 mini; // Coin inférieur gauche de la boîte\n    vec3 maxi; // Coin supérieur droit de la boîte\n    int i;    // ID de texture\n};\n\nstruct Cylinder \n{\n    vec3 c; // Centre du cylindre (axe des Y)\n    float r; // Rayon du cylindre\n    float h; // Hauteur du cylindre\n    int i;        // ID de texture\n};\n\nstruct Hit\n{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray\n{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n};\n\n// Calculer le point sur le rayon\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n///Transformations\n// Fonction de rotation autour de l'axe X\nvec3 RotationX(vec3 p, float angle)\n{\n    mat3 m = mat3(1.0, 0.0, 0.0,\n                  0.0, cos(angle), -sin(angle),\n                  0.0, sin(angle), cos(angle));\n    return m * p;\n}\n\n// Fonction de rotation autour de l'axe Y\nvec3 RotationY(vec3 p, float angle)\n{\n    mat3 m = mat3(cos(angle), 0.0, sin(angle),\n                  0.0, 1.0, 0.0,\n                  -sin(angle), 0.0, cos(angle));\n    return m * p;\n}\n\n//Fontion de rotation autour de l'axe Z\nvec3 RotationZ(vec3 p, float angle)\n{\n    mat3 m = mat3(cos(angle), -sin(angle), 0.0,\n                  sin(angle), cos(angle), 0.0,\n                  0.0, 0.0, 1.0);\n    return m * p;\n}\n\nvec3 Translation(vec3 pos, vec3 t)\n{\n    return pos + t;\n}\n\nvec3 Scale(vec3 pos, vec3 t)\n{\n    return pos*t;\n}\n\nfloat Scale(float pos, float t)\n{\n    return pos*t;\n}\n///Fin des transformations\n\n//Fonction de bruit de Perlin\nfloat Noise(float x, float y, float z)\n{\n    return fract(sin(dot(vec3(x, y, z), vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\nfloat vec3Noise(vec3 st) {\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 45.543))) * 43758.5453);\n}\n\nfloat Noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    float a = vec3Noise(i);\n    float b = vec3Noise(i + vec3(1.0, 0.0, 0.0));\n    float c = vec3Noise(i + vec3(0.0, 1.0, 0.0));\n    float d = vec3Noise(i + vec3(1.0, 1.0, 0.0));\n    float e = vec3Noise(i + vec3(0.0, 0.0, 1.0));\n    float g = vec3Noise(i + vec3(1.0, 0.0, 1.0));\n    float h = vec3Noise(i + vec3(0.0, 1.0, 1.0));\n    float k = vec3Noise(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (e - a) * u.z * (1.0 - u.x) +\n           (a - c - e + g) * u.x * u.y * (1.0 - u.z) + (h - g) * u.x * u.z * (1.0 - u.y) +\n           (k - b) * u.y * u.z * (1.0 - u.x) + (d - a) * u.x * u.y * u.z;\n}\n\n///Textures\nfloat SandTexture(vec3 uv)\n{\n    uv *= 10.0;\n    // Utiliser le bruit de Perlin pour créer un motif de sable\n    float noiseValue = Noise(uv.x, uv.y, uv.z);\n    float sandTexture = smoothstep(0.4, 0.6, noiseValue);\n    return sandTexture;\n}\n\n// cellSize : Taille d'une case\n// Effectue un modulo sur la somme des coordonnées du point divisée par la taille d'une case\nfloat VolumetricCheckersTexture(vec3 p, float cellSize)\n{\n    vec3 q = floor(p / cellSize);\n    return mod(q.x + q.y + q.z, 2.0);\n}\n\nfloat RadialColor(vec3 p) {\n    // Définir la largeur des bandes\n    float stripeWidth = 0.1;\n    // Utiliser l'opération modulo pour créer des bandes horizontales\n    float stripe = mod(p.y, stripeWidth * 2.0);\n    // Une bande sur deux\n    float color = (stripe < stripeWidth) ? 1.0 : 0.0;\n    return color;\n}\n\nfloat TextureConcentric(vec3 p, vec3 axis)\n{\n    // Projection du point sur l'axe\n    vec3 proj = dot(p, axis) * axis;\n    // Distance du point à l'axe\n    float r = length(p - proj);\n    return 0.5 + 0.5 * cos(3.0 * 3.1415927 * r);\n}\n\nfloat Turbulence(vec3 pos, float pixel_size) \n{\n    float x = 0.0;\n    float scale = 1.0;\n    while (scale > pixel_size) {\n        pos /= scale;\n        x += Noise(pos) * scale;\n        scale /= 2.0;\n    }\n    return x;\n}\n\nvec3 MarbleTexture(vec3 pos) \n{\n    vec3 rgb = vec3(0.0);\n    float x = sin((pos.y + 3.0 * Turbulence(pos, 0.0125)) * 3.14159);\n    x = sqrt(x + 1.0) * 0.7071;\n    rgb.g = 0.3 + 0.8 * x;\n    x = sqrt(x);\n    rgb.r = 0.3 + 0.6 * x;\n    rgb.b = 0.6 + 0.4 * x;\n    return rgb;\n}\n\n// Function to compute color\n// p : Point\n// i : Texture index\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 1)\n    {\n        float f = VolumetricCheckersTexture(p,2.);\n        vec3 col = vec3(1.0, 0.2, 0.9) + f * vec3(0.1);\n        return Material(col);\n    }\n    else if (i == 0)\n    {\n        float f = RadialColor(p);\n        vec3 col = vec3(0.2, 0.3, 0.9) + f * vec3(0.1);\n        return Material(col);\n    }\n    else if (i == 2)\n    {\n        float f = SandTexture(p); \n        vec3 col = vec3(0.8, 0.7, 0.4) + f * vec3(0.1);\n        return Material(col);\n    }\n    else if (i == 5)\n    {\n        //couleur unie\n        vec3 col = vec3(0.2, 0.5, 0.8);\n        return Material(col);\n    }\n    else if (i == 6)\n    {\n        vec3 col = MarbleTexture(p);\n        return Material(col);\n    }\n    else if (i == 7)\n    {\n        float f = TextureConcentric(p, vec3(1.));\n        vec3 col = vec3(0.0, 0.8, 0.2) + f * vec3(0.1);\n        return Material(col);\n    }\n    return Material(vec3(0)); // Valeur par défaut (noir)\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c; //Delta\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        // Le premier point de l'intersection, celui qui est visible.\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellip, out Hit x)\n{\n    vec3 oc=ray.o-ellip.c;\n    oc = oc / ellip.r;\n    vec3 dir = ray.d / ellip.r;\n    \n    float a = dot( dir, dir );\n    float b = dot( oc, dir );\n    float c = dot( oc, oc );\n    float d = b*b - a*(c-1.0);\n    if(d>0.)\n    {\n        float t=(-b-sqrt(d))/a;\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize((p-ellip.c)/ellip.r),ellip.i);\n            \n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x)\n{\n    // Calculer les points d'intersection des plans de la boîte\n    float t1x = (box.mini.x - ray.o.x) / ray.d.x;\n    float t2x = (box.maxi.x - ray.o.x) / ray.d.x;\n    float t1y = (box.mini.y - ray.o.y) / ray.d.y;\n    float t2y = (box.maxi.y - ray.o.y) / ray.d.y;\n    float t1z = (box.mini.z - ray.o.z) / ray.d.z;\n    float t2z = (box.maxi.z - ray.o.z) / ray.d.z;\n\n    // Trouver les points d'entrée et de sortie de la boîte\n    float tmin = max(max(min(t1x, t2x), min(t1y, t2y)), min(t1z, t2z));\n    float tmax = min(min(max(t1x, t2x), max(t1y, t2y)), max(t1z, t2z));\n\n    // Vérifier si le rayon intersecte la boîte\n    if (tmax >= tmin && tmax > 0.0)\n    {\n        // Point d'entrée du rayon dans la boîte\n        vec3 p = ray.o + tmin * ray.d;\n\n        // Calculer la normale en fonction de la face de la boîte intersectée\n        vec3 normal;\n\n        if (tmin == t1x) normal = vec3(-1.0, 0.0, 0.0);\n        else if (tmin == t2x) normal = vec3(1.0, 0.0, 0.0);\n        else if (tmin == t1y) normal = vec3(0.0, -1.0, 0.0);\n        else if (tmin == t2y) normal = vec3(0.0, 1.0, 0.0);\n        else if (tmin == t1z) normal = vec3(0.0, 0.0, -1.0);\n        else if (tmin == t2z) normal = vec3(0.0, 0.0, 1.0);\n\n        x = Hit(tmin, normal, box.i);\n        return true;\n    }\n\n    return false;\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cylinder, out Hit x)\n{\n    vec3 oc = ray.o - cylinder.c;\n    \n    float a = ray.d.x * ray.d.x + ray.d.z * ray.d.z;\n    float b = 2.0 * (oc.x * ray.d.x + oc.z * ray.d.z);\n    float c = oc.x * oc.x + oc.z * oc.z - cylinder.r * cylinder.r;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = -1.0;\n\n        if (cylinder.h < 0.0)\n        {\n            t = max(t1, t2); // Cylindre infini\n        }\n        else\n        {\n            float minY = cylinder.c.y;\n            float maxY = cylinder.c.y + cylinder.h;\n            \n            float y1 = ray.o.y + t1 * ray.d.y;\n            float y2 = ray.o.y + t2 * ray.d.y;\n            \n            if (y1 >= minY && y1 <= maxY)\n            {\n                t = t1;\n            }\n            else if (y2 >= minY && y2 <= maxY)\n            {\n                t = t2;\n            }\n        }\n\n        if (t > 0.0)\n        {\n            vec3 p = ray.o + t * ray.d;\n\n            // Calculer la normale\n            vec3 normal = normalize(vec3(p.x - cylinder.c.x, 0.0, p.z - cylinder.c.z));\n\n            x = Hit(t, normal, cylinder.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\n// Fonction de test d'intersection avec le tore\nbool IntersectTorus(Ray ray, Torus torus, out Hit x)\n{\n    float po = 1.0;\n    \n    float Ra2 = torus.x * torus.x;\n    float ra2 = torus.y * torus.y;\n\t\n    float m = dot(ray.o, ray.o);\n    float n = dot(ray.o, ray.d);\n\n    {\n        float h = n * n - m + (torus.x + torus.y) * (torus.x + torus.y);\n        if (h < 0.0) return false;\n    }\n    \n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * ray.d.z * ray.d.z + k;\n    float k1 = k * n + Ra2 * ray.o.z * ray.d.z;\n    float k0 = k * k + Ra2 * ray.o.z * ray.o.z - Ra2 * ra2;\n\t\n    if (abs(k3 * (k3 * k3 - k2) + k1) < 0.01)\n    {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0 / k0;\n        k1 = k1 * k0;\n        k2 = k2 * k0;\n        k3 = k3 * k0;\n    }\n\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n\n    float h = R * R - Q * Q * Q;\n    float z = 0.0;\n    \n    if (h < 0.0)\n    {\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    }\n    else\n    {\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\t\t\n    \n    z = c2 - z;\n\t\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n    \n    if (abs(d1) < 1.0e-4)\n    {\n        if (d2 < 0.0) return false;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if (d1 < 0.0) return false;\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\t\n    float result = 1e20;\n\n    h = d1 * d1 - z + d2;\n    if (h > 0.0)\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = -d1 + h - k3; t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        if (t1 > 0.0) result = t1; \n        if (t2 > 0.0) result = min(result, t2);\n    }\n\n    h = d1 * d1 - z - d2;\n    if (h > 0.0)\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = d1 + h - k3;  t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        if (t1 > 0.0) result = min(result, t1);\n        if (t2 > 0.0) result = min(result, t2);\n    }\n\n    float t = result;\n    if (t > 0.0)\n    {\n        vec3 p = Point(ray, t);\n        vec3 n = normalize(p * (dot(p, p) - torus.y * torus.y - torus.x * torus.x * vec3(1.0, 1.0, -1.0)));\n        x = Hit(t, n, torus.i);\n        return true;\n    }\n\n    return false;\n}\n\n\n// Intersection entre un rayon et une capsule\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x)\n{\n    // Intersection avec les deux demi-sphères aux extrémités de la capsule\n    vec3 pa1 = ray.o - cap.p1;\n    vec3 pa2 = ray.o - cap.p2;\n    \n    float a1 = dot(ray.d, ray.d);\n    float b1 = 2.0 * dot(pa1, ray.d);\n    float c1 = dot(pa1, pa1) - cap.r * cap.r;\n    float discriminant1 = b1 * b1 - 4.0 * a1 * c1;\n\n    float a2 = dot(ray.d, ray.d);\n    float b2 = 2.0 * dot(pa2, ray.d);\n    float c2 = dot(pa2, pa2) - cap.r * cap.r;\n    float discriminant2 = b2 * b2 - 4.0 * a2 * c2;\n    \n    // Intersection avec le cylindre central de la capsule\n    vec3 ba = cap.p2 - cap.p1;\n    vec3 oa = ray.o - cap.p1;\n    vec3 da = ray.d;\n\n    float a = dot(da, da) - dot(da, ba) * dot(da, ba) / dot(ba, ba);\n    float b = 2.0 * (dot(da, oa) - dot(da, ba) * dot(oa, ba) / dot(ba, ba));\n    float c = dot(oa, oa) - cap.r * cap.r - dot(oa, ba) * dot(oa, ba) / dot(ba, ba);\n    float discriminant = b * b - 4.0 * a * c;\n\n        //Corps\n        if (discriminant >= 0.0) {\n            float t = (-b - sqrt(discriminant)) / (2.0 * a);\n            // Vérifiez si le point d'intersection est à l'extérieur des demi-sphères\n            float h = dot(oa + t * da, ba) / dot(ba, ba);\n            if (t >= 0.0 && h >= 0.0 && h <= 1.0) {\n                vec3 intersectionPoint = Point(ray, t);\n                vec3 normal = normalize(intersectionPoint - (cap.p1 + ba * h));\n                x = Hit(t, normal, cap.i);\n                return true;\n            }\n        }\n\n        // Vérifiez si le rayon intersecte la capsule (cylindre + demi-sphères) et retournez le point d'intersection le plus proche\n        if (discriminant1 >= 0.0 || discriminant2 >= 0.0) {\n        float t1 = (-b1 - sqrt(discriminant1)) / (2.0 * a1);\n        float t2 = (-b2 - sqrt(discriminant2)) / (2.0 * a2);\n        float tmin = min(t1, t2);\n        float h = dot(oa + tmin * da, ba) / dot(ba, ba);\n        if (tmin >= 0.0) {\n            vec3 intersectionPoint = Point(ray, tmin);\n            vec3 normal;\n            if (tmin == t1){\n                normal = normalize(intersectionPoint - cap.p1);\n            }\n            else{\n                normal = normalize(intersectionPoint - cap.p2);\n            }\n            x = Hit(tmin, normal, cap.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n///////////////////////////////////////\n// Intersection plane\n// ray : Le rayon\n//   x : Retourne les informations d'intersection\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n\n// Intersection de la scène\n// ray : Le rayon\n//   x : Retourne les informations d'intersection\nbool Intersect(Ray ray,out Hit x)\n{\n\n    float rotationSpeed = 1.0;\n    float time = iTime;\n    float angle = time * rotationSpeed;\n\n    //Animation de la sphère\n    Sphere sph=Sphere(vec3(2.,4.,5.),1.,1);\n    sph.c = RotationZ(sph.c, angle);\n\n    //Spheres\n    Sphere sph1=Sphere(vec3(0.,0.,1.),1.,7);\n    const Sphere sph2=Sphere(vec3(2.,1.,0.),1.,6);\n    \n    //Plan\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),7);\n\n    //Ellipsoid\n    Ellipsoid ellipsoid1 = Ellipsoid(vec3(0.0, 2.0, 3.0), vec3(1.0, 3.0, 1.0), 1);\n    ellipsoid1.c = RotationZ(ellipsoid1.c, 3.14);\n    ellipsoid1.r = Scale(ellipsoid1.r, vec3(1,1,2));\n    \n    //Box\n    Box box1 = Box(vec3(1.5,3.0,1.0),vec3(3.0,5.0,2.0),5);\n\n    //Cylindre\n    const Cylinder cyl1 = Cylinder(vec3(4.0,-3.0,1.0),1.0,3.0,5);\n    \n    //Capsule\n    Capsule cap = Capsule(vec3(0.0,-9.0,1.0),vec3(0.0,0.0,0.0),2.,2);\n    cap.p1 = Translation(cap.p1, vec3(0.,2.,1.));\n    cap.p2 = Translation(cap.p1, vec3(0.,0.,3.));\n    cap.p1 = RotationZ(cap.p1, 1.5);\n    cap.p2 = RotationZ(cap.p2, 1.);\n\n    //Tore\n    const Torus tor1 = Torus(2.0, 0.5, 1);\n\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoid(ray,ellipsoid1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectBox(ray,box1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinder(ray,cyl1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if (IntersectCapsule(ray, cap, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if (IntersectTorus(ray, tor1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Matrice de rotation pour la caméra\n// ro : Origine de la caméra\n// ta : Cible de la caméra\nmat3 SetCamera(in vec3 ro, in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Direction de la caméra\n// seed : Graine aléatoire\n// n : Normale\nvec3 Hemisphere(int seed,vec3 n)\n\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n    return d;\n}\n\n// Fonction pour le calcul de l'occlusion ambiante\nfloat ComputeAmbientOcclusion(vec3 p, vec3 n) {\n    float occlusion = 0.0; // Compteur d'occlusion\n    int numSamples = 128; // Nombre d'échantillons\n    float Dmax = 0.5; // Distance maximale\n\n    for (int i = 0; i < numSamples; i++) {\n        // Générer une direction de rayon aléatoire dans un hémisphère autour de la normale\n        vec3 RandomDir = Hemisphere(i, n);\n        // Créer un rayon à partir du point en direction de la direction générée\n        Ray occlusionRay;\n        occlusionRay.o = p + 0.001 * RandomDir; // Offset pour éviter l'auto-intersection\n        occlusionRay.d = RandomDir;\n\n        // Vérifier l'intersection avec d'autres objets de la scène\n        Hit occlusionHit;\n        if (Intersect(occlusionRay, occlusionHit)) {\n            // Ajouter de l'occlusion si un objet est touché\n            //Calcul de la distance entre l'intersecton et le point d'origine\n            float distance = length(occlusionHit.t * occlusionRay.d);\n            if(distance < Dmax){\n                occlusion += 1.;\n            }\n        }\n    }\n    // Moyenne des échantillons d'occlusion et normalisation du résultat\n    occlusion /= float(numSamples);\n\n    return occlusion;\n}\n\n// Applique la couleur en fonction de la normale et de la matière\n// m : Material\n// n : normal\n// p : point\nvec3 Color(Material m,vec3 n, vec3 p)\n{\n\n    vec3 light=normalize(vec3(2,1.5,1));\n    Hit x;\n    if(!Intersect(Ray(p+n*0.01, light),x)) \n    //0.01 pour éviter les problèmes de collision avec le plan\n    {    \n        //Oclusion ambiante\n        float occlusion = ComputeAmbientOcclusion(p, n);\n        // diff est la composante diffuse\n        // vec3 col=m.d*diff+vec3(.2,.2,.2); est la couleur finale\n        // clamp permet de limiter la valeur entre 0 et 1\n        float diff=clamp(dot(n,light),0.,1.);\n        vec3 col=m.d*diff+vec3(.2,.2,.2);\n        \n        // Ajouter une composante spéculaire\n        vec3 r = 2.0 * dot(light, n) * n - light;\n        float v=clamp(dot(r,normalize(p)),0.,1.);\n        vec3 specular = m.d * pow(clamp(dot(r,light),0.0,1.0),28.0) * vec3(1.0,1.0,1.0);\n        col+=specular;\n        //vec3 specPhong=m.d*clamp(r*v,0.,1.);\n        //col+=specPhong;\n        return col * (1.0 - occlusion);\n    }\n    else{\n        return vec3(.2, .2, .2);\n    }\n}\n\nvec3 Shade(Ray ray)\n{\n    // Intersect contient toutes les détections de géométrie\n    Hit x;\n    bool idx = Intersect(ray, x);\n    \n    if (idx)\n    {\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n        \n        // Vérifiez si l'objet est une capsule (vous pouvez ajuster l'ID au besoin)\n        if (x.i == 3) {\n            // Retourne la couleur noire pour les capsules\n            return vec3(0.0, 0.0, 0.0);\n        }\n        else {\n            return Color(mat, x.n, p);\n        }\n    }\n    else\n    {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Convertit les coordonnées de pixel en [-1,1] et applique le ratio d'aspect \n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Controle de la souris\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    /////////\n    // Origine du rayon\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=SetCamera(ro,ta);\n    \n    // Rayon\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Rendu\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}