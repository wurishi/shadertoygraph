{"ver":"0.1","info":{"id":"4fdczS","date":"1730820606","viewed":39,"name":"inclinated waves","username":"Secretstar","description":"inclinated waves","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n// Funzione per generare le onde\nfloat waveFunction(vec3 p) {\n    float radius = length(p.xy); // Distanza dal centro\n    return sin(radius * 5.0 - iTime * 2.0) * 0.1; // Frequenza e movimento nel tempo\n}\n\n// Funzione per la forma delle onde con inclinazione\nfloat map(vec3 p) {\n    // Inclinazione del piano (modifica il valore per regolare l'inclinazione)\n    p.y -= 0.5 * p.x; // Inclina il piano verso il basso in direzione x\n    float waveHeight = waveFunction(p);\n    return p.z - waveHeight; // Elevazione dell'onda rispetto alla coordinata z\n}\n\n// Calcola la normale per l'illuminazione\nvec3 calcNormal(vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yxy * map(p + e.yxy) +\n        e.yyx * map(p + e.yyx) -\n        e.xyx * map(p - e.xyx)\n    );\n}\n\n// Funzione principale di ray marching\nfloat march(vec3 ro, vec3 rd, float near, float far) {\n    float t = near;\n    for (int i = 0; i < 100; i++) {\n        float d = map(ro + rd * t);\n        if (d < 0.001) return t; // Colpisce l'onda\n        if (t >= far) return far; // Oltre il raggio massimo\n        t += d; // Avanza lungo il raggio\n    }\n    return far; // Se non colpisce nulla\n}\n\n// Funzione per calcolare il colore basato sulla posizione\nvec3 doColor(vec3 p) {\n    float waveHeight = waveFunction(p);\n    return vec3(1.0, 0.4 + waveHeight * 0.5, 1.0); // Colore blu chiaro con variazione\n}\n\n// Funzione principale\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 2.0); // Posizione della camera\n    vec3 rd = normalize(vec3(uv, -1.0)); // Direzione del raggio\n    vec3 col = vec3(0.0); // Colore finale\n    \n    // Ray marching\n    float t = march(ro, rd, 0.0, 100.0);\n    if (t < 100.0) {\n        vec3 p = ro + rd * t; // Punto di intersezione\n        vec3 n = calcNormal(p); // Normale per l'illuminazione\n        vec3 lightPos = vec3(2.0, 5.0, 2.0); // Posizione della luce\n        vec3 li = lightPos - p; // Direzione della luce\n        float dif = clamp(dot(n, normalize(li)), 0.0, 1.0); // Illuminazione diffusa\n        col = doColor(p) * dif; // Colore illuminato\n    }\n    \n    // Imposta il colore del frammento\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}