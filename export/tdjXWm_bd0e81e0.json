{"ver":"0.1","info":{"id":"tdjXWm","date":"1554101244","viewed":208,"name":"Panomera Apollonian ","username":"smkgames","description":"Panomera Apollonian ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","distancefield","kleinian","apollonian","vr","panomera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define AA 1\n\nvec4 orb; \nvec4 brg;\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\tbrg = vec4(1000.0); \n\tfor( int i=0; i<8;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n        brg = max( orb, vec4(abs(p),r2) )/4.;\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec3 n){\n  return hsv2rgb(vec3(mod(n.z*.5,1.0),0.9,0.9));\n}\n\nvec2 fragCoordinate;\nvec3 panomeraRay(){\n    \n    vec2 pix=( fragCoordinate.xy*2.0 - iResolution.xy) / iResolution.x;\n\t\n    vec3 camP=vec3(\n        0.05 * sin(iTime*0.2 ),\n        0.05 * sin(iTime*0.15 ),\n        0.1*iTime\n    );\n\n\tvec3 camC= camP + vec3(\n        0.3 * sin(iTime*0.05),\n        0.3 * sin(iTime*0.06),\n        1.);\n\n    vec3 camA=vec3(0.3*sin(iTime*0.03),0.8,0.);\n\tvec3 camS=cross(normalize(camC-camP),camA);\n\tvec3 camU=cross(camS,normalize(camC-camP));\n    \n    vec3 camF = normalize(camC-camP );\n\n    // panoramic projection by aiming rays using angles\n    vec3 ray=normalize(\n        camS*sin(pix.x*3.5) + camF*cos(pix.x*3.5) +\n        camU*pix.y*3.14\n    );\n         \n    vec3 rayP=camP;\n    return ray;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, panomeraRay(), anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec4 art = brg;\n        vec3 pos = ro + t*rd;\n        \n\n        \n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n       vec3 colorful =getCol(vec3(t));\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n       // rgb = mix( rgb, colorful, clamp(6.0*tra.y,0.0,1.0) );\n      //  rgb = mix( rgb, colorful, pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n       \trgb = mix(rgb,colorful,art.y*5.);\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoordinate = fragCoord;\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 1., 1., 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1., 1., 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, panomeraRay(), anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\n","name":"Image","description":"","type":"image"}]}