{"ver":"0.1","info":{"id":"sd3GDB","date":"1630582186","viewed":66,"name":"Renderer_2D_sidps","username":"kingcrimson1112","description":"A Shader to render 2 vertex data to Screen","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","renderer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TO_INTERPOLATE 1\n#define RENDER_TRIANGLE 0\n\n// Image Settings\nfloat yScaling = 1.0f;\n\n// Scene Settings\nvec3 bgColor = vec3(0.05f);\nvec3 objectColor = vec3(0.85f,0.2f,0.25f);\n\n// Vertex Data\n#if RENDER_TRIANGLE\n// 1. Triangle\n// a. All the vertices of 2D Object\nvec3[3] vertices = vec3[3](\nvec3(0.0f, 0.5f, 0.0f),\nvec3(0.5f, -0.5f, 0.0f),\nvec3(-0.5f, -0.5f, 0.0f)\n);\n// b. The Index order for each triangle of the Object\nint[3] indices = int[3](\n0, 1 , 2\n);\n#else\n// 2. Rectangle\n// a. All the vertices of 2D Object\nvec3[4] vertices = vec3[4](\nvec3(0.5f, 0.5f, 0.0f),\nvec3(0.5f, -0.5f, 0.0f),\nvec3(-0.5f, -0.5f, 0.0f),\nvec3(-0.5f, 0.5f, 0.0f)\n);\n// b. The Index order for each triangle of the Object\nint[6] indices=int[6](\n0, 1, 2,\n2, 3, 0\n);\n#endif\n// The Color of each vertex of Object\nvec3[4] basicColors = vec3[4](\nvec3(0.25f, 0.1f, 0.95f),\nvec3(0.5f, 0.1f, 0.95f),\nvec3(0.25f, 0.8f, 0.95f),\nvec3(0.25f, 0.1f, 0.15f)\n/*vec3(1.0f),\nvec3(1.0f, 0.0f, 0.0f),\nvec3(0.0f, 1.0f, 0.0f),\nvec3(0.0f, 0.0f, 1.0f)*/\n);\n\n// Checks if target lies of the same side of (lineA <-> lineB) as lineC \nbool valid_point(vec2 lineA, vec2 lineB, vec2 lineC, vec2 target)\n{\n    bool status = false;\n    float m = (lineB.y - lineA.y) / (lineB.x - lineA.x);\n    if(lineB.x == lineA.x)\n    {\n        m = 9999.9f;\n    }\n    float c = lineB.y - (m * lineB.x);\n    float s1 = lineC.y- (m * lineC.x) - c;\n    float s2 = target.y- (m * target.x) - c;\n    if((s1 * s2) >= 0.0f)\n    {\n        status = true;\n    }\n    return status;\n}\n\n// Gets the Point Closest to X\nint get_closest_point(vec2 A, vec2 B, vec2 C, vec2 X)\n{\n    int index = -1;\n    float dA = distance(X, A);\n    float dB = distance(X, B);\n    float dC = distance(X, C);\n    if(dA <= dB && dA <= dC)\n    {\n        index = 0;\n    }\n    else if(dB <= dA && dB <= dC)\n    {\n        index = 1;\n    }\n    else if(dC <= dB && dC <= dA)\n    {\n        index = 2;\n    }\n    return index;\n}\n\n// Returns the Minimum of A, B and C\nfloat get_min(float A, float B, float C)\n{\n    return min(min(A, B), C);\n}\n\n\n// Returns the Maximum of A, B and C\nfloat get_max(float A, float B, float C)\n{\n    return max(max(A, B), C);\n}\n\n// Cycles the value of a in the cycle [minVal, maxVal]\nfloat cycle_float(float a, float minVal, float maxVal)\n{\n    float diff = maxVal - minVal;\n    if(a > maxVal)\n    {\n        float aDiff = a - maxVal;\n        float div = float(int(aDiff / diff));\n        a = minVal + (aDiff - (div * diff));\n    }\n    else if(a < minVal)\n    {\n        float aDiff = minVal - a;\n        float div = float(int(aDiff / diff));\n        a = maxVal - (aDiff - (div * diff));\n    }\n    return a;\n}\n\n// Returns the Interpolated color for the given f value\nvec3 get_time_color(float f, float minV, float maxV)\n{\n    return mix(basicColors[int(cycle_float(f, minV, maxV))],\n        basicColors[int(cycle_float(f + 1.0f, minV, maxV))],\n        f - float(int(f)));\n}\n\n\n// Gets the Color for the Pixel based on which triangle it is inside\nvec3 get_pixel_color(vec2 pos)\n{\n    // Set Default Colors\n    float offset = 2.0f * iTime;\n    if(offset >= 4.0f)\n    {\n        offset -= 4.0f;\n    }\n    #if RENDER_TRIANGLE\n    float size = 3.0f;\n    #else\n    float size = 4.0f;\n    #endif\n    vec3[4] colors = vec3[4](\n      get_time_color(offset, 0.0f, size),\n      get_time_color(offset + 1.0f, 0.0f, size),\n      get_time_color(offset + 2.0f, 0.0f, size),\n      get_time_color(offset + 3.0f, 0.0f, size)\n    );\n    vec3 col = bgColor;\n    for(int i = 0; (i+2) < indices.length(); i = (i + 3))\n    {\n        vec2 vertexA = vec2(vertices[indices[i]]);\n        vec2 vertexB = vec2(vertices[indices[i + 1]]);\n        vec2 vertexC = vec2(vertices[indices[i + 2]]);\n        bool validPoint = false;\n        validPoint = valid_point(vertexA, vertexB, vertexC, pos);\n        validPoint = (validPoint) ? (valid_point(vertexB, vertexC, vertexA, pos)) : validPoint;\n        validPoint = (validPoint) ? (valid_point(vertexC, vertexA, vertexB, pos)) : validPoint;\n        if(validPoint)\n        {\n#if !TO_INTERPOLATE\n            int index = get_closest_point(vertexA, vertexB, vertexC, pos);\n            col = colors[indices[i + index]];\n#else\n             float dA = distance(pos, vertexA);\n             float dB = distance(pos, vertexB);\n             float dC = distance(pos, vertexC);\n             float minVal = get_min(dA, dB, dC);\n             float maxVal = get_max(dA, dB, dC);\n             dA = 1.0f - smoothstep(minVal, maxVal, dA);\n             dB = 1.0f - smoothstep(minVal, maxVal, dB);\n             dC = 1.0f - smoothstep(minVal, maxVal, dC);\n             col = ((colors[indices[i]] * dA) + \n                   (colors[indices[i+1]] * dB) +\n                   (colors[indices[i+2]] * dC));\n#endif\n        }\n    }\n    return col;\n}\n\n// Gets the Pixel in Coordinate Space\nvec2 get_pos(vec2 fragCoord)\n{\n    // From (0, 0) to (1, 1)\n    vec2 pos = fragCoord / iResolution.xy;\n    // From (-1, -1) to (1, 1)\n    pos = (pos * 2.0f) - 1.0f;\n    // From (-Y, -Y) to (Y, Y)\n    pos *= yScaling;\n    // From (-X, -Y) to (X, Y)\n    pos.x *= (iResolution.x / iResolution.y);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get Pixel Position\n    vec2 pos = get_pos(fragCoord);\n    \n    // Pixel color\n    vec3 col = get_pixel_color(pos);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}