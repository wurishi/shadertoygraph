{"ver":"0.1","info":{"id":"wsGyWm","date":"1602967017","viewed":473,"name":"Low Pass Filtered Saw (sound)","username":"athibaul","description":"The response of a second order low-pass filter to a sawtooth wave can be computed exactly, or approximated in different ways. Musical example : [url=https://www.shadertoy.com/view/WsKyzy]Mirrors in Space[/url].","likes":14,"published":1,"flags":8,"usePreview":0,"tags":["sound","filter","saw","sawtooth","lowpass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See \"Common\" tab\n\n\n\n// Example of musical use:\n// \"Mirrors in Space\" \n// https://www.shadertoy.com/view/WsKyzy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tfloat dx = 0.1/iResolution.y;\n    \n    // Plot mainSound() function\n    float x1 = uv.x - dx;\n    float x2 = uv.x + dx;\n    float y = uv.y;\n    float time = round(iTime*50.)/50.;\n    float scale = 5.;\n    float fx1 = mainSound(0, x1/60. + time).x * scale;\n    float fx2 = mainSound(0, x2/60. + time).x * scale;\n    float alpha = (fx2-fx1)/(2.*dx),\n          beta  = (fx2+fx1)/(2.*dx);\n    float d = abs(beta*dx - y)/length(vec2(1., alpha));\n    \n    vec3 col = vec3(0.);\n    col = mix(col, vec3(1), smoothstep(3./iResolution.y,0.,d));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Several low-passed sawtooth waves are available\n// 1 : Approximation, symmetric\n// 2 : Approximation, asymmetric\n// 3 : Exact response of a second-order system\n#define USE_VERSION 3\n// Approximations assume resonances are attenuated in a single cycle.\n// This leads to smoother results than the exact version,\n// with less variation of volume due to strong resonances.\n\n#if   USE_VERSION == 1\n#define wave lpfSaw\n#elif USE_VERSION == 2\n#define wave lpfSaw2\n#elif USE_VERSION == 3\n#define wave lpfSaw3\n#endif\n\nfloat lpfSaw( float t, float f, float fc, float Q )\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    // First approximation : symmetric waveform\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - round(f*t);\n    float sgn = sign(t);\n    t = abs(t);\n    float v = (1.-exp(-omega_c*t/Q)*cos(omega_c*t))*sgn;\n    v *= (1.-2.*t);\n    return v;\n}\n\nfloat lpfSaw2( float t, float f, float fc, float Q )\n{\n    // Second approximation : we attenuate the resonance at the end of each cycle.\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    float v = 1. - 2.*t; // Basic saw\n    float v2 = -2.*exp(-omega_c*t/Q)*cos(omega_c*t); // Response of 2nd order system\n    v2 *= (1.-t); // Attenuate resonance\n    return v+v2;\n}\n\n\nfloat lpfSaw3(float t, float f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\n\n\n// Exponential interpolation from a (x=-1) to b (x=1)\n\n#define emix(a, b, x) exp(mix(log(a), log(b), x))\n#define exprange(x, a, b) emix(a, b, 0.5+0.5*x)\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 f = vec2(50., 50.2);\n    vec2 cutoff = exprange(asin(cos(time)), vec2(400., 500.), vec2(8000., 7000.));\n    vec2 Q = exprange(sin(0.62*time), 5., 50.) * vec2(1.,0.5);\n    // We can switch between the three versions of lpfSaw.\n    // In comparison with the first two approximate versions,\n    // the exact version exhibits stronger\n    // resonance on the first few harmonics when using a high quality factor,\n    // whereas lpfSaw2 smoothes them out (and lpfSaw even more).\n    return vec2(0.02) * vec2(\n        wave(time, f.x, cutoff.x, Q.x),\n        wave(time, f.y, cutoff.y, Q.y)\n    );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"// See Common tab","name":"Sound","description":"","type":"sound"}]}