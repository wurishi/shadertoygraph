{"ver":"0.1","info":{"id":"wsXXD7","date":"1551406273","viewed":250,"name":"Windows","username":"teraspora","description":"A mirrored zoom into and out of a Julia set of a compound trig-based function","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["juiaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FLT_MAX 3.402823466e+38\n\n// Zoom into a (mirrored) Julia set of a composed trig function, in GLSL\n// Created by John Lynch - Sep 2018;\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float E = 2.7182818284;\nconst float PI = 3.141592653589793234;\nconst float SCALE_PER_FRAME = 1.003;\n\n// Some useful colours:\n\nconst vec4 white =      vec4(1.,   1.,   1.  , 1.);\nconst vec4 black =      vec4(0.,   0.,   0.  , 1.);\nconst vec4 cyan =       vec4(0.0,  1.,   0.84, 1.);\nconst vec4 magenta =    vec4(1.0,  0.,   1.0 , 1.);\nconst vec4 blue =       vec4(0.0,  0.6,  0.84, 1.);\nconst vec4 gold =       vec4(0.89, 0.84, 0.66, 1.);\nconst vec4 orange =     vec4(1.0,  0.2,  0.0 , 1.);\nconst vec4 yellow =     vec4(1.0,  0.9,  0.0 , 1.);\nconst vec4 dark_blue =  vec4(0.0,  0.02, 0.38, 1.);\nconst vec4 crimson =    vec4(0.76, 0.0,  0.42, 1.);\nconst vec4 green =      vec4(0.1,  0.5,  0.25, 1.);\nconst vec4 rich_blue =  vec4(0.0,  0.55, 1.0 , 1.);\n\nvec4[] cols = vec4[](black, blue, black, gold, black, rich_blue, black, orange, black, yellow, black, orange, black, blue, black, orange, black);\nint numFirstColours = 12;\nbool modifiedColours = false;\n\nfloat[] mu = float[](1., 1., 1., 1., 1., 1., 1., 1., 1., 1.);\n\nconst vec2 ONE = vec2(1., 0.);\nconst vec2 I = vec2(0., 1.);\n\nfloat aspectRatio;\nvec2 zMin;    // corners of the region of the Complex plane we're looking at\nvec2 zMax;\nvec2 zSpan;\nvec2 zIncr;\nvec2 zPrevious;\n\nconst float escapeRadius = 6.0;\nconst float escapeRadius2 = 36.0;\nint exponent = 4;\nint maxIterations = 4;\nfloat t;\n\n\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// Colour fns.:\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n    \nfloat lightness(vec3 col) {\n    return rgb2hsl(col).b;\n}\n\nvec3 changeLightness(vec3 col, float newLightness) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.p = newLightness;\n    return hsl2rgb(colHSL);\n}\n    \nvec3 saturate(vec3 col) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.t = 1.0;\n    return hsl2rgb(colHSL);    \n}\n\nvec2 nmouse() {\n    return iMouse.xy / iResolution.xy;\n}\n\nfloat om(float x) {     // one minus x\n    return 1. - x;\n}\n\nvec3 om(vec3 v) {       // one minus v\n    return 1. - v;\n}\n\nfloat op(float x) {     // one plus x \n    return 1. + x;\n}\n\n// Normalised trig fns.:\nfloat nsin(float x) {\n    return op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n    return op(cos(x)) * 0.5;\n}\n\n// ======================== USEFUL FUNCTIONS ========================\nvoid updateGeometryVars() {\n    zSpan = zMax - zMin;\n    zIncr = zSpan / iResolution.xy;\n}\n\nvec2 xyToPixel(vec2 z, vec2 zMin, vec2 zMax) {\n    return (z - zMin) / (zMax - zMin) * iResolution.xy;\n}\n\nvec2 pixelToXy(vec2 pixel, vec2 zMin, vec2 zMax) {\n    return pixel / iResolution.xy * (zMax - zMin) + zMin;\n}\n\nvoid scale(float factor) {\n    vec2 halfDiag = (zMax - zMin) / 2.0;\n    vec2 centre = zMin + halfDiag;\n    zMin = centre - halfDiag / factor;\n    zMax = centre + halfDiag / factor;\n    updateGeometryVars();\n}\n\n// some complex functions...\nfloat modc(vec2 z) {\n    return length(z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nfloat x2(vec2 z) {\n    return z.x * z.x;\n}\n\nfloat y2(vec2 z) {\n    return z.y * z.y;\n}\n\nvec2 add(vec2 z, vec2 w) {\n    return vec2(z.x + w.x, z.y + w.y);\n}\n\nvec2 sub(vec2 z, vec2 w) {\n    return vec2(z.x - w.x, z.y - w.y);\n}\n\nvec2 prod(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 recip(vec2 z) {\n    float denom = z.x * z.x + z.y * z.y;\n        return denom != 0.0\n            ? vec2(z.x / denom, -z.y / denom) \n            : vec2(FLT_MAX, FLT_MAX);\n            // You may not like this default but I'd prefer not to return infinity.\n}\n\nvec2 quot(vec2 z, vec2 w) {\n    return prod(z, recip(w));\n}\n\nvec2 sqd(vec2 z) {\n    return prod(z, z);\n}\n    \nvec2 powc(vec2 z, int n) {\n    float nf = float(n);\n    bool neg = false;\n    vec2 result = z;\n    if (n < 0) {\n        neg = true;\n        n = -n;\n    }\n    if (n == 2) return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y);\n    if (n == 0) return ONE;\n    if (n == 1) return z; \n    for (int i = 1; i < n; i++) {\n        result = prod(result, z);\n    }\n    return neg ? recip(result) : result;\n}\n\n// Function templates:\nvec2 p(vec2 z) {\n    return powc(z, exponent);\n}\n\nvec2 fp(vec2 z, vec2 w, float newR) {\n    return add(p(polar(newR * mu[0], arg(z) * mu[1])), w);\n}\n\nvec2 fc(vec2 z, vec2 w, vec2 newC) {\n    return add(p(vec2(newC.x * mu[0], newC.y * mu[1])), w);\n}\n\nvec2 pc(vec2 z, vec2 w) {\n    return add(p(z), w);\n}\n\n\n// ======================= The functions to iterate ======================\n\nvec2 f0(vec2 z, vec2 w) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + w;\n}\n\nvec2 f54(vec2 z, vec2 w) {\n    float temp = w.y; w.y += w.x; w.x -= z.y; z.y += z.x; z.x -= temp;\n    return pc(z, w);\n}\n\nvec2 f392(vec2 z, vec2 w) {\n    return fp(z, w, mu[6] * E * sqrt(max(sin(z.x), sin(z.y))));                 // 392\n}\n\n// ======================= The grindstone ================================\nfloat iterate(vec2 z) {\n    int numIts = 0;\n    float realIts = 0.;\n    // vec2 z0 = z; // for Mandelbrot\n    vec2 z0 = vec2(sin(t / 96.), cos(t / 96.));       // for Julia\n    float zAbs = z.x * z.x + z.y * z.y;\n    float zAbsPrevious = zAbs;\n    zPrevious = z;\n    while (numIts < maxIterations && zAbs < escapeRadius) {\n        numIts++;\n        // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n        z = f54(z, z0);\n        z = f392(z, z0);\n        zAbsPrevious = zAbs;\n        zAbs = z.x * z.x + z.y * z.y;\n    }\n    if (zAbs < escapeRadius) {\n        realIts = float(numIts + 1) - (log(log(zAbs + 1.) + 1.) / log(log(escapeRadius + 1.) + 1.));\n    }\n    else {\n        float far = max(float(exponent), log(zAbs) / log(zAbsPrevious));\n        realIts = float(numIts) - (log(log(zAbs)) - log(log(escapeRadius))) / log(far);\n    }\n    return ++realIts;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime * 20.;\n    float mt = mod(t, 1000.);\n    t = mod(floor(t / 1000.), 2.) < .25 ? mt : 1000. - mt;\n    \n    float blackThreshold = 0.8 + (nmouse().y + 0.25); // 1.1; // Best varies; try between 1.0 and 1.3\n    vec2 offset = vec2(1.9, 0.29);\n    aspectRatio = iResolution.x / iResolution.y;\n    zMin = vec2(-2. * aspectRatio, -2.) + offset;    // corners of the region of the Complex plane we're looking at\n    zMax = vec2(2. * aspectRatio, 2.) + offset;\n    scale(exp2(t / 256.));\n    vec2 uv = fragCoord.xy;\n    uv = abs(uv -iResolution.xy / 2.);\n    vec2 z = pixelToXy(uv, zMin, zMax);\n    // z = abs(z);\n    // z.x = abs(z.x);\n    float its = iterate(z);\n    float nfc = float(numFirstColours);\n    float colourMappingFactor = (nfc - 1.) / float(maxIterations) * .4; \n    \n    float colourIndex = modifiedColours ? mod(its, nfc) : mod(its * colourMappingFactor, nfc); // map iteration count to a colour\n    int firstColourIndex = int(floor(colourIndex));\n    float interpolationFactor = mod(colourIndex, 1.);\n    \n    // Slight precautionary hack!    Or let's call it clamping!\n    if (firstColourIndex >= numFirstColours) {\n        firstColourIndex = numFirstColours - 1;\n        interpolationFactor = 1.;\n    }    \n    if (firstColourIndex < 0) {\n        firstColourIndex = 0;\n    }\n\n    vec3 col = mix(cols[firstColourIndex], cols[int(mod(float(firstColourIndex + 1), float(cols.length())))], interpolationFactor).rgb;\n        \n    col = saturate(col);\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}