{"ver":"0.1","info":{"id":"sltBWM","date":"1665738352","viewed":1782,"name":"VHS Tape Shader","username":"sp33s","description":"VHS Shader\n-------------------------------------------------------------------------------------\nA shader in which I tried to mimic VHS as true as possible :)\n\nClick mouse to A/B between effect and original.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["glitch","mask","vhs","unsharp","tape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// VHS Shader\n//\n// A shader in which I tried to mimic VHS as true as possible :)\n//\n// It's built up of a few passes:\n// - A:      Lowers horizontal resolution of luminance and color/chroma   \n// - B:      Applies unsharp mask to regain crisp + level/color balancing\n// - C:      Interlacing + subtle full screen noise blend\n// - D:      Glitches: some warps + white noise lines\n// - Image:  Final overall blur + TV vignette\n//\n// Pass A and B's Unsharp Mask are the bread and butter of the effect, rest is just minor balancing to taste.\n// It initially relied heavily on gaussian and box blur, but I achieved similar effects by blurring through mip maps.\n//\n// Click mouse to A/B between effect and original.\n//\n// Hope you like it :)\n\nconst float FINAL_BLUR_BIAS = 1.0;\n\nvec4 Televisionfy(in vec4 pixel, const in vec2 uv)\n{\n    float vignette = pow(uv.x * (1.0 - uv.x) * uv.y * (1.0 - uv.y), 0.25) * 2.2;\n    return pixel * vignette;;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if (iMouse.z <= 0.0)\n    {\n        fragColor = texture(iChannel0, uv, FINAL_BLUR_BIAS);\n        fragColor = Televisionfy(fragColor, uv);\n    }\n    else\n    {\n        fragColor = texture(iChannel1, uv);\n    }       \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Lower resolution of color and luminosity band\n\nvec4 Shrink(in vec2 fragCoord, const in float shrinkRatio, const in float bias)\n{\n    float scale = 1.0 / iResolution.x;\n    float numBands = iResolution.x * shrinkRatio;\n    float bandWidth = iResolution.x / numBands;\n    \n    // How far are we along the band\n    float t = mod(fragCoord.x, bandWidth) / bandWidth;\n    \n    // Sample current band in lower res\n    fragCoord.x = floor(fragCoord.x * shrinkRatio) / shrinkRatio;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 colorA = texture(iChannel0, uv, bias);\n\n    // Sample next band for interpolation\n    uv.x += bandWidth * scale; \n    vec4 colorB = texture(iChannel0, uv, bias);\n\n    return mix(colorA, colorB, t);\n}\n\n// Based on https://printtechnologies.org/wp-content/uploads/2020/03/pdf-reference-1.6-addendum-blend-modes.pdf\nvec3 ClipColor(in vec3 c)\n{\n    float l = GetLuminance(c);\n    float n = min(min(c.r, c.g), c.b);\n    float x = max(max(c.r, c.g), c.b);\n    \n    if (n < 0.0)\n    {\n        c.r = l + (((c.r - l) * l) / (l - n));\n        c.g = l + (((c.g - l) * l) / (l - n));\n        c.b = l + (((c.b - l) * l) / (l - n));\n    }\n    \n    if (x > 1.0)\n    {\n        c.r = l + (((c.r - l) * (1.0 - l)) / (x - l));\n        c.g = l + (((c.g - l) * (1.0 - l)) / (x - l));\n        c.b = l + (((c.b - l) * (1.0 - l)) / (x - l));\n    }\n    \n    \n    return c;\n}\n\nvec3 SetLum(in vec3 c, in float l)\n{\n    float d = l - GetLuminance(c);\n    c += d;\n\n    return ClipColor(c);\n}\n\nvec4 BlendColor(const in vec4 base, const in vec4 blend)\n{\n    vec3 c = SetLum(blend.rgb, GetLuminance(base));\n    return vec4(c, blend.a);\n}\n\nvec4 BlendLuminosity(const in vec4 base, const in vec4 blend)\n{\n    vec3 c = SetLum(base.rgb, GetLuminance(blend));\n    return vec4(c, blend.a);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 luma = Shrink(fragCoord, 0.5, 0.0); // In VHS the luma band is half of the resolution\n    luma = BlendLuminosity(vec4(0.5, 0.5, 0.5, 1.0), luma);\n    \n    vec4 chroma = Shrink(fragCoord,  1.0 / 32.0, 3.0); // In VHS chroma band is a much lower resolution (technically 1/16th)\n    chroma = BlendColor(luma, chroma);\n    \n    fragColor = chroma; \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DEFINE(a) (iResolution.y / 450.0) * a\n#define pow2(a) (a * a)\n#define PI 3.1415926535897932384626433832795\n#define THIRD 1.0 / 3.0\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n#define WHITE vec4(1.0)\n#define W vec3(0.2126, 0.7152, 0.0722)\n#define PHI 1.61803398874989484820459\n#define SOURCE_FPS 30.0\n\nfloat GetLuminance(vec3 color)\n{\n    return W.r * color.r + W.g * color.g + W.b * color.b;\n}\n\nfloat GetLuminance(vec4 color)\n{\n    return W.r * color.r + W.g * color.g + W.b * color.b;\n}\n\nfloat GetGaussianWeight(vec2 i, float sigma) \n{\n    return 1.0 / (2.0 * PI * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n}\n\nvec4 Blur(in float size, const in vec2 fragCoord, const in vec2 resolution, const in bool useGaussian, const in sampler2D source, const in float lodBias)\n{\n    vec4 pixel;\n    float sum;\n    \n    vec2 uv = fragCoord / resolution;\n    vec2 scale = vec2(1.0) / resolution;\n\n    if (!useGaussian)\n        size *= THIRD;\n    \n    for (float y = -size; y < size; y++)\n    {\n        if (fragCoord.y + y < 0.0) continue;\n        if (fragCoord.y + y >= resolution.y) break;\n    \n        for (float x = -size; x < size; x++)\n        {\n            if (fragCoord.x + x < 0.0) continue;\n            if (fragCoord.x + x >= resolution.x) break;\n\n            vec2 uvOffset = vec2(x, y);\n            float weight = useGaussian ? GetGaussianWeight(uvOffset, size * 0.25/*sigma, standard deviation*/) : 1.0f;\n            pixel += texture(source, uv + uvOffset * scale) * weight;\n            sum += weight;\n        }    \n    }\n    \n    return pixel / sum;\n}\n\nfloat GoldNoise(const in vec2 xy, const in float seed)\n{\n    //return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n    return fract(sin(dot(xy * seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// BlendSoftLight credit to Jamie Owen: https://github.com/jamieowen/glsl-blend\nfloat BlendSoftLight(float base, float blend) \n{\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec4 BlendSoftLight(vec4 base, vec4 blend) \n{\n\treturn vec4(BlendSoftLight(base.r,blend.r),BlendSoftLight(base.g,blend.g),BlendSoftLight(base.b,blend.b), 1.0);\n}\n\nvec4 BlendSoftLight(vec4 base, vec4 blend, float opacity) \n{\n\treturn (BlendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Unsharp mask + balancing pass\n\nvec4 UnsharpMask(const in float amount, const in float radius, const in float threshold, const in float preBlurBias, const in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 scale = vec2(1.0) / iResolution.xy;\n    \n    vec4 pixel = texture(iChannel0, uv, preBlurBias);\n    vec4 blurPixel =  texture(iChannel0, uv, preBlurBias + 1.0);// Blur(radius, fragCoord, iResolution.xy, false, iChannel0, preBlurBias * 2.0);\n    \n    float lumDelta = abs(GetLuminance(pixel) - GetLuminance(blurPixel));\n    \n    if (lumDelta >= threshold)\n        pixel = pixel + (pixel - blurPixel) * amount;\n    \n    return pixel;\n}\n\nvec4 ClampLevels(in vec4 pixel, const in float blackLevel, const in float whiteLevel)\n{\n    pixel = mix(pixel, BLACK, 1.0 - whiteLevel);\n    pixel = mix(pixel, WHITE, blackLevel);\n    \n    return pixel;\n}\n\nvec4 Saturation(vec4 pixel, float adjustment)\n{\n    vec3 intensity = vec3(dot(pixel.rgb, W));\n    return vec4(mix(intensity, pixel.rgb, adjustment), 1.0);\n}\n\nvec4 TintShadows(vec4 pixel, vec3 color)\n{\n    const float POWER = 1.5;\n    \n    // Curve is an approximation of Photoshop's color balance > shadows\n    if (color.r > 0.0)\n        pixel.r = mix(pixel.r, 1.0 - pow(abs(pixel.r - 1.0), POWER), color.r);\n    if (color.g > 0.0)\n        pixel.g = mix(pixel.g, 1.0 - pow(abs(pixel.g - 1.0), POWER), color.g);\n    if (color.b > 0.0)\n        pixel.b = mix(pixel.b, 1.0 - pow(abs(pixel.b - 1.0), POWER), color.b);\n        \n    return pixel;\n}\n\nconst float PRE_BLUR_BIAS = 1.0;\nconst float UNSHARP_AMOUNT = 2.0;\nconst float UNSHARP_THRESHOLD = 0.0;\nconst float BLACK_LEVEL = 0.1;\nconst float WHITE_LEVEL = 0.9;\nconst float SATURATION_LEVEL = 0.75;\nconst vec3 SHADOW_TINT = vec3(0.7, 0.0, 0.9);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float UNSHARP_RADIUS = DEFINE(20.0);\n\n    vec4 pixel = UnsharpMask(UNSHARP_AMOUNT, UNSHARP_RADIUS, UNSHARP_THRESHOLD, PRE_BLUR_BIAS, fragCoord);\n    \n    pixel = ClampLevels(pixel, BLACK_LEVEL, WHITE_LEVEL);\n    pixel = TintShadows(pixel, SHADOW_TINT);\n    pixel = Saturation(pixel, SATURATION_LEVEL);\n\n    fragColor = pixel;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Interlace + noise grain pass\n\nvec4 Noise(const in float grainSize, const in bool monochromatic, in vec2 fragCoord, float fps)\n{\n    float seed = fps > 0.0 ? floor(fract(iTime) * fps) / fps : iTime;\n    seed += 1.0;\n    \n    if (grainSize > 1.0)\n    {\n        fragCoord.x = floor(fragCoord.x / grainSize);\n        fragCoord.y = floor(fragCoord.y / grainSize);\n    }\n\n    fragCoord.x += 1.0;\n    \n    float r = GoldNoise(fragCoord, seed);    \n    float g = monochromatic ? r : GoldNoise(fragCoord, seed + 1.0);\n    float b = monochromatic ? r : GoldNoise(fragCoord, seed + 2.0);\n    \n    \n    return vec4(r, g, b, 1.0);\n}\n\nconst float NOISE_BLEND = 0.05;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float LINE_HEIGHT = DEFINE(2.0);\n    float NOISE_GRAIN_SIZE = DEFINE(4.0);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    bool updateOddLines = mod(float(iFrame), 2.0) == 0.0;\n    bool isOddLine = mod(floor(fragCoord.y), 2.0 * LINE_HEIGHT) >= LINE_HEIGHT;\n    \n    if (isOddLine && updateOddLines || !isOddLine && !updateOddLines)\n        fragColor = texture(iChannel1, uv);\n    else\n        fragColor = texture(iChannel0, uv);\n        \n    fragColor = BlendSoftLight(fragColor, Noise(NOISE_GRAIN_SIZE, true, fragCoord, SOURCE_FPS), NOISE_BLEND);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Warps + noise lines pass\n\nvec2 Tracking(const in float speed, const in float offset, const in float jitter, const in vec2 fragCoord)\n{\n    float t = 1.0 - mod(iTime, speed) / speed;\n    float trackingStart = mod(t * iResolution.y, iResolution.y);\n    float trackingJitter = GoldNoise(vec2(5000.0, 5000.0), 10.0 + fract(iTime)) * jitter;\n    \n    trackingStart += trackingJitter;\n    \n    vec2 uv;\n    if (fragCoord.y > trackingStart)\n        uv = (fragCoord + vec2(offset, 0)) / iResolution.xy;\n    else\n        uv = fragCoord / iResolution.xy;\n\n    return uv;\n}\n\nvec2 Wave(const in float frequency, const in float offset, const in vec2 fragCoord, const in vec2 uv)\n{\n    float phaseNumber = floor(fragCoord.y / (iResolution.y / frequency));\n    float offsetNoiseModifier = GoldNoise(vec2(1.0 + phaseNumber, phaseNumber), 10.0);\n    \n    float offsetUV = sin((uv.y + fract(iTime * 0.05)) * PI * 2.0 * frequency) * ((offset * offsetNoiseModifier) / iResolution.x);\n\n    return uv + vec2(offsetUV, 0.0);\n}\n\nvec4 WarpBottom(const in float height, const in float offset, const in float jitterExtent, in vec2 uv)\n{\n    float uvHeight = height / iResolution.y;\n    if (uv.y > uvHeight)\n        return texture(iChannel0, uv);\n        \n    float t = uv.y / uvHeight;\n    \n    float offsetUV = t * (offset / iResolution.x);\n    float jitterUV = (GoldNoise(vec2(500.0, 500.0), fract(iTime)) * jitterExtent) / iResolution.x; \n    \n    uv = vec2(uv.x - offsetUV - jitterUV, uv.y);\n    \n    vec4 pixel = texture(iChannel0, uv);\n    \n    pixel = pixel * t;\n       \n    return pixel;\n}\n\nvec4 WhiteNoise(const in float lineThickness, const in float opacity, const in vec4 pixel, const in vec2 fragCoord)\n{\n    if (GoldNoise(vec2(600.0, 500.0), fract(iTime) * 10.0) > 0.97) // Draw line?\n    {\n        float lineStart = floor(GoldNoise(vec2(800.0, 50.0), fract(iTime)) * iResolution.y);\n        float lineEnd = floor(lineStart + lineThickness);\n        \n        if (floor(fragCoord.y) >= lineStart && floor(fragCoord.y) < lineEnd)\n        {\n            float frequency = GoldNoise(vec2(850.0, 50.0), fract(iTime)) * 3.0 + 1.0;\n            float offset = GoldNoise(vec2(900.0, 51.0), fract(iTime));            \n            float x = floor(fragCoord.x) / floor(iResolution.x) + offset;\n            float white = pow(cos(PI * fract(x * frequency) / 2.0), 10.0) * opacity;\n            float grit = GoldNoise(vec2(floor(fragCoord.x /3.0), 800.0), fract(iTime));\n            white = max(white - grit * 0.3, 0.0);\n                        \n            return pixel + white;\n        }\n    }\n    \n    return pixel;\n}\n\nconst float TRACKING_SPEED = 8.0;\nconst float WAVE_FREQUENCY = 70.0;\nconst float TRACKING_JITTER = 20.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float TRACKING_HORIZONTAL_OFFSET = DEFINE(8.0);\n    //float TRACKING_JITTER = DEFINE(20.0);\n    \n    float WAVE_OFFSET = DEFINE(1.0);\n    \n    float BOTTOM_WARP_HEIGHT = DEFINE(15.0);\n    float BOTTOM_WARP_OFFSET = DEFINE(100.0);\n    float BOTTOM_WARP_JITTER_EXTENT = DEFINE(50.0);\n    \n    float NOISE_HEIGHT = DEFINE(6.0);\n\n    vec2 uv = Tracking(TRACKING_SPEED, TRACKING_HORIZONTAL_OFFSET, TRACKING_JITTER, fragCoord); \n    uv = Wave(WAVE_FREQUENCY, WAVE_OFFSET, fragCoord, uv);\n        \n    vec4 pixel = WarpBottom(BOTTOM_WARP_HEIGHT, BOTTOM_WARP_OFFSET, BOTTOM_WARP_JITTER_EXTENT, uv);\n    pixel = WhiteNoise(NOISE_HEIGHT, 0.3, pixel, fragCoord);\n    \n    fragColor = pixel;\n}","name":"Buffer D","description":"","type":"buffer"}]}