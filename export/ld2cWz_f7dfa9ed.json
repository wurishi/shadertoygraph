{"ver":"0.1","info":{"id":"ld2cWz","date":"1491732914","viewed":376,"name":"Parabolic motion","username":"ishiyama","description":"Comparison of Velocity Verlet, Euler, Runge-Kutta method using parabolic motion with various timesteps\nRed:\tEuler\nGreen: Runge-Kutta\nBlue: Velocity verlet\nGray: Ground-truth (analytic solution)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\tComparison of Velocity Verlet, Euler and Runge-Kutta method using parabolic motion\n\tRed:\tEuler\n\tGreen:\tRunge-Kutta\n\tBlue:\tVelocity Verlet\n\tGray:\tGround-truth (analytic solution)\n*/\n\nstruct Particle\n{\n    vec2\tmPosition;\n    vec2\tmVelocity;\n    vec3\tmColor;\n    float\tmRadius;\n    float\tmLineWidth;\n};\nconst vec2 gGravity = vec2(0.0, -9.8);\n\nfloat DistanceToLine(vec2 p, vec2 p0, vec2 p1)\n{\n\tvec2 a = p1 - p0;\n\tvec2 b = p - p0;\n\treturn distance(b, a * clamp(dot(a,b) / dot(a,a), 0.0, 1.0));\n}\n\nbool IntersectPointDisk(vec2 inPointPos, vec2 inDiskPos, float inRadius)\n{\n\treturn length(inPointPos - inDiskPos) < inRadius;\n}\n\nvoid VelocityVerlet(inout vec2 ioPos, inout vec2 ioVel, vec2 accel, float dt)\n{\n\tioPos += ioVel * dt + 0.5 * accel * dt * dt;\n\tioVel += accel * dt;\n}\n\nvoid Euler(inout vec2 ioPos, inout vec2 ioVel, vec2 accel, float dt)\n{\n\tioPos += ioVel * dt;\n\tioVel += accel * dt;\n}\n\nvoid RungeKutta4(inout vec2 ioPos, inout vec2 ioVel, vec2 accel, float dt)\n{\n\tvec2 p1 = dt * ioVel;\n\tvec2 v1 = dt * accel;\n\tvec2 p2 = dt * (ioVel + 0.5 * v1);\n\tvec2 v2 = dt * accel;\n\tvec2 p3 = dt * (ioVel + 0.5 * v2);\n\tvec2 v3 = dt * accel;\n\tvec2 p4 = dt * (ioVel + v3);\n\tvec2 v4 = dt * accel;\n\tioPos += (p1 + 2.0 * p2 + 2.0 * p3 + p4)/6.0;\n\tioVel += (v1 + 2.0 * v2 + 2.0 * v3 + v4)/6.0;\n}\n\nvec2 Analytic(vec2 initPos, vec2 initVel, vec2 accel, float time)\n{\n\treturn initPos + initVel * time + 0.5 * accel * time * time;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\tfloat w = iResolution.x/iResolution.y;\n\n\tvec3 col = vec3(0.1);\n\n    const float scale = 4.0;\n\tconst float num_coarse_grain = 4.0;\n    uv *= scale;\n    \n\tconst float life_time = 1.5 * 2.0;\n\tfloat line_width = 0.005 * scale;\n\tfloat radius = 0.05 * scale;\n    float rand_seed = floor(iTime/life_time);\n    vec2 init_vel = vec2(6.2, 10.6);\n    vec2 init_pos = vec2(-w * scale + radius, -1.0 * scale + radius);\n\n    const int numParticles = 4;\n    float end_time = mod(iTime, life_time);\n    float time_step = (1.0 + 6.0 * mod(rand_seed, num_coarse_grain))/60.0;\n\tParticle particle[numParticles];\n    \n    if (mod(rand_seed, 2.0 * num_coarse_grain) >= num_coarse_grain)\n    {\n\t    uv /= 2.0;\n    \tradius /= 2.0;\n    \tline_width /= 2.0;\n    \tuv += Analytic(init_pos, init_vel, gGravity, end_time + time_step - mod(end_time,time_step));\n    }\n        \n    for(int i = 0; i < numParticles; ++i)\n    {\n    \tparticle[i].mPosition = init_pos;\n    \tparticle[i].mVelocity = init_vel;\n        particle[i].mRadius\t= radius;\n        particle[i].mLineWidth = line_width;\n\t\n\t\tfor(float time = 0.0; time < end_time; time += time_step)\n\t\t{\n\t\t\tvec2 prev_pos = particle[i].mPosition;\n            switch(i)\n            {\n                case 0:\n                \tparticle[i].mRadius = radius * 2.0;\n                \tparticle[i].mLineWidth = line_width * 6.0;\n\t\t\t\t\tparticle[i].mColor = vec3(0.7, 0.7, 0.7);\n\t\t\t\t\tparticle[i].mPosition = Analytic(init_pos, init_vel, gGravity, time + time_step);\n                \tprev_pos = Analytic(init_pos, init_vel, gGravity, time);\n                \tbreak;\n                case 1:\n                \tparticle[i].mRadius = radius * 1.5;\n                \tparticle[i].mLineWidth = line_width * 3.0;\n                \tparticle[i].mColor = vec3(0.2, 0.2, 1.0);\n          \t\t\tVelocityVerlet(particle[i].mPosition, particle[i].mVelocity, gGravity, time_step);\n                \tbreak;\n\t\t        case 2:\n                \tparticle[i].mColor = vec3(1.0, 0.2, 0.2);\n\t\t  \t\t\tEuler(particle[i].mPosition, particle[i].mVelocity, gGravity, time_step);\n                \tbreak;\n\t\t        case 3:\n                \tparticle[i].mColor = vec3(0.0, 1.0, 0.2);\n\t\t  \t\t\tRungeKutta4(particle[i].mPosition, particle[i].mVelocity, gGravity, time_step);\n                \tbreak;\n                default:\n                \tbreak;\n            }\n            if (DistanceToLine(uv, prev_pos, particle[i].mPosition) < particle[i].mLineWidth)\n                col = particle[i].mColor;\n        }\n  \t\tcol = IntersectPointDisk(uv, particle[i].mPosition, particle[i].mRadius) ? particle[i].mColor : col;\n    }\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}