{"ver":"0.1","info":{"id":"Nttyzr","date":"1659162603","viewed":91,"name":"Floating Box","username":"jzimm","description":"box","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185\n#define PI 3.141592\n#define MAX_STEPS 54\n#define MAX_DIST 50.\n#define SURF_DIST 0.001\n\n#define SCENE_MAX_DIST 20.\n\nfloat Hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat Noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( Hash( i + vec2(0.0,0.0) ), \n                     Hash( i + vec2(1.0,0.0) ), u.x),\n                mix( Hash( i + vec2(0.0,1.0) ), \n                     Hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat ValueNoise(vec2 uv)\n{\n    float f = 0.;\n    uv *= 0.3;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*Noise( uv ); uv = m*uv;\n    f += 0.2500*Noise( uv ); uv = m*uv;\n    f += 0.1250*Noise( uv ); uv = m*uv;\n    f += 0.0625*Noise( uv ); uv = m*uv;\n    return 0.5 + 0.5*f;\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 Rot3d(vec3 a, vec3 b) {\n    vec3 v = cross(a, b);\n    float c = dot(a, b);\n    mat3 I = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);         \n    mat3 m = mat3(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);\n    return I + m + m * m / (1. + c);\n}\n\n// uv = pixel xy\n// p = camera position\n// l = lookat position\n// z = zoom\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat WaveHeight(vec2 p) {\n    return sin(p.x + iTime) * .3;\n}\n\nfloat WaveNoise(vec2 p) {\n    return ValueNoise(p + vec2(iTime, 0.0));\n}\n\n\nfloat DistWave(vec3 p) {\n    return p.y + WaveNoise(p.xz) + .5 * WaveHeight(p.xz);\n}\n\nfloat DistPlane(vec3 p) {\n    return p.y + WaveHeight(p.xz);\n}\n\nvec3 NormalPlane(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = DistPlane(p) - vec3(DistPlane(p - e.xyy),\n                                 DistPlane(p - e.yxy),\n                                 DistPlane(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetDist(vec3 p) {\n    float delay = .5; // delay\n    vec3 up = vec3(0, 1, 0);\n    \n    vec3 co = vec3(-1, 0.1, -1); // cube origin\n    vec3 cs = vec3(1, 1, 1); // cube size\n    vec3 cp = p - vec3(co.x, co.y-WaveHeight(co.xz), co.z); // cube position\n    \n    vec3 n = NormalPlane(vec3(co.x - delay, co.y, co.z - delay));\n    \n    cp *= Rot3d(n * .8, up);\n    \n    float dCube = sdBox(cp, cs);\n    \n    float d = DistWave(p);\n    d = min(d, dCube);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.; \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * dO;\n        dO += GetDist(p); // add dist of nearest collision\n        if(dO > MAX_DIST || dO < SURF_DIST) return dO;\n    }  \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    float d = GetDist(p);\n    vec3 n = d - vec3(GetDist(p - e.xyy),\n                      GetDist(p - e.yxy),\n                      GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(4, 8, 1);\n    ro.yz *= Rot(-m.y * PI + 1.);\n    ro.xz *= Rot(-m.x * TAU);\n    vec3 rd = GetRayDir(uv, ro, vec3(0, 2, 0), .5);\n    \n    vec3 col = vec3(1.0);\n    \n    float d = RayMarch(ro, rd);\n    vec3 n = GetNormal(ro + rd * d);\n    \n    if (d > MAX_DIST) {\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    vec3 p = ro + rd * d;\n    vec3 r = reflect(rd, n);\n    \n    col = vec3(r) * 0.5  + 0.5;\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}