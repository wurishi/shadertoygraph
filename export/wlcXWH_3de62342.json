{"ver":"0.1","info":{"id":"wlcXWH","date":"1580849676","viewed":135,"name":"MandleBrad","username":"bignobody","description":"Quick mandlebrot fractal while I'm waiting on a compile... Now with more layers.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mandlebrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Quick Mandlebrot shader, by request. Hi Brad!\nmat2 rot(float a)\n{\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));    \n}\n\n//Credit where due! Got this technique from davethomas426 here: https://www.shadertoy.com/view/4slcz8\nvec2 complexmulti(vec2 x, vec2 y)\n{\n\treturn vec2(x.x * y.x - x.y * y.y, x.x * y.y + x.y * y.x);   \n}\n\nvec2 mandle(vec2 z, vec2 c)\n{\n\treturn complexmulti(z,z)+c;\n}\n\nfloat iterate(vec2 uv, float toff, float thresh)\n{\n\tint maxI = 256;\n    int i = 0;\n    float le = 0.0;\n    vec2 c = uv;\n    vec2 z = uv;\n    while (i < maxI)\n    {\n\t\tz = mandle(z,c);\n        le = length(z);\n        if (le > thresh)\n        {\n            return (float (i)*((thresh * 0.02)+toff));\n        }\n        i ++;\n    }\n    return 0.7+toff;;\n}\n\nvec3 mandlayer(vec2 uv, float t)\n{\n\tuv *= sin(t*0.1)*3.0;\n    uv.x += sin(t*1.5) * 0.5;\n    uv.y += cos(t*1.5 + 10.0) * 0.10;\n    uv *= rot(t * 0.3);\n    float off = (sin(t)*0.5+0.5)*0.1;\n    float thresh = 2.0;\n\treturn vec3(pow(iterate(uv,0.0,thresh),4.0),pow(iterate(uv,-off,thresh),4.0),pow(iterate(uv,+off,thresh),4.0));\n     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0.0);\n    for (float i = 0.0; i < 1.0; i += 1.0/7.0)\n    {\n       col += mandlayer(uv * (i+1.0), iTime + i); \n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}