{"ver":"0.1","info":{"id":"sscSDn","date":"1632920609","viewed":181,"name":"Geometric Lanterns","username":"Flopine","description":"What a creativity boost it is! To be able to experiment on a new technique :D <3","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","repetition","animation","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Still exploring repetition trick presenting by Blackle on Perfect Pistons <3 \n// https://youtu.be/I8fmkLK1OKg\n// https://www.shadertoy.com/view/WtXcWB\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define od(p,d) (dot(p,normalize(sign(p)))-d)\n#define hash21(x) fract(sin(dot(x,vec2(13.4,32.7)))*134.5) \n\nvec2 edge (vec2 p)\n{\n    vec2 p2 = abs(p);\n    return (p2.x>p2.y) ? vec2((p.x<0.) ? -1. : 1., 0.) : vec2(0., (p.y<0.) ? -1. : 1.);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = max(abs(p),abs(p.yzx));\n    return min(p.x, min(p.y,p.z))-d;\n}\n\nfloat g1=0.;\nfloat prim1 (vec3 p, float size) \n{\n    float odile = od(p,size*.75);\n    g1 += 0.001/(0.001+odile*odile);\n    return min(odile,\n                max(-sc(p,size*.75),\n                     box(p,vec3(size))\n                   )\n               );\n}\n\nvec2 center;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    vec2 id = floor(p.yz)+.5;\n    p.y += (mod(id.y,2.)<=0.5) ? iTime*0.2 : -iTime*0.2;\n    center = floor(p.yz)+.5; \n    vec2 neighbour = center+edge(p.yz-center);    \n    \n    float size = clamp(hash21(center+0.5)/2.,0.1,0.36),\n    me = prim1(p-vec3(0.,center),size),\n    next = box(p-vec3(0.,neighbour),vec3(0.45));\n    \n    return min(me,next);\n}\n\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n)/eps,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(uv*3.,-30.), rd=vec3(0.,0.,1.), p=ro,\n    col = vec3(0.), l = normalize(vec3(1.5,-2.,-2.));\n\n    bool hit = false;\n    for (float i=0.;i<100.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {hit = true; break;}\n        d *= 0.95+dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.), ao = AO(0.1,p,n)+AO(0.2,p,n)+AO(0.38,p,n);\n        col = vec3(light)*ao/3.;\n    }\n\n    col += g1*0.2*vec3(0.45,.8,hash21(center));\n\n    fragColor = vec4(sqrt(clamp(col,0.,1.)),1.0);\n}","name":"Image","description":"","type":"image"}]}