{"ver":"0.1","info":{"id":"MXlfW2","date":"1728948442","viewed":48,"name":"Rolling hexagons (more accurate)","username":"Elsio","description":"boa sorte pra quem quiser tentar uma versão que generalize vários polígonos. Me  avise. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","animate","loopless","octagon","geometri","dodecagon","slip","heptagon","tetra","octogono","octagono","cabri","geogebra"],"hasliked":0,"parentid":"l3sfWj","parentname":"how to make it loopless? "},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pin(i) cos((i) * PI / 2. / K + vec2(0, 11)) * R.x / sqrt(2. + sqrt(3.))\n#define S(f) smoothstep(2. / r.y, .0, f)\n#define PI acos(-1.)\n#define r iResolution.xy\n#define R (.25 * vec2(1, cos(PI / K))) \n\n// Good luck! \n// if you try to change this value\n#define K 6.\n\nfloat Poly(vec2 p, float k, float ra, float d, bool fill) {\n    d = atan(p.y, p.x) - d;\n    d = mod(d, 2. * PI / k) - PI / k;\n    d = cos(d) * length(p) - ra;\n    return fill ? d + .002 : abs(d);\n}\n\nfloat seq(float t, bool g) {\n    return \n            + 23. \n            - mod(\n                (g ? t * 9. + 4. : t + 8.) + floor(t / 2.) * (g ? -8. : 8.), \n                12.\n              ) * 2.;\n}\n\nvoid hexagons(inout vec4 o, vec2 u, bool green){\n    float T = iTime * .35, t, a;\n          T = floor(T) * 2.\n              + smoothstep(green?.5:.75, green?.75:1., fract(T))\n              + smoothstep(green?.25:.0, green?.5:.25, fract(T));\n              \n    t = mod(floor(T), 2. * K);\n    a = seq(t + 1., green);\n    \n    vec2 p = pin(mod(14. * t + 84., 24.) + 1.);\n    t = fract(T) * 2. - 1.;\n    a += tanh(t * 5.) + .015;\n    a *= PI / K / 2.;\n    \n    o += S( Poly(\n                   u + p + vec2(cos(a), sin(a)) * R.x,\n                   K, R.y, a, true\n           )  ) * (green ? vec4(0, .25, 0, 0) : vec4(.75, 0, 0, 0));\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    o *= .0;\n    u = (u - r / 2.) / r.y;\n\n    hexagons(o, u, true);\n    hexagons(o, u, false);\n\n    // bg\n    o += S(  length(u) - (R.x + R.y + .03)) * vec4(0, .4, .2, 0)\n       + S( Poly(u, K * 2., R.x + R.y, PI / (2. * K), false) ) * .5;\n}\n","name":"Image","description":"","type":"image"}]}