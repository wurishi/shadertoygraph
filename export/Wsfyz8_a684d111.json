{"ver":"0.1","info":{"id":"Wsfyz8","date":"1584126520","viewed":133,"name":"Boble","username":"latel88","description":"Boble","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","multipass","culling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor ( const in vec2 uv )\n{\n    return texture( iChannel1, uv ).rgb;\n    \n}\n\nvec3 bloom ( const in vec3 color, const in int count, const in float radius, const in float force, const in vec2 uv )\n{\n\tfloat f = float(count);\n\t\n    vec3 col = vec3(0.);\n\tfloat totalw = 0.;\n\t\n\tfor (int x = 0; x < count; x++)\n\t{\n\t\tvec2 p = uv;\n\t\tfloat fi1 = float(x) / f;\n\t\tfloat dir = fi1 * CIRCLE;\n\n\t\tp += vec2(sin( dir ), cos( dir )) * radius;\n\t\t\n\t\tfor (int x = 0; x < count; x++)\n\t\t{\n\t\t\tvec2 u = p;\n\t\t\tfloat fi2 = mod( (f - float(x)) / f * 2., 1. );\n\t\t\tfloat dir = fi2 * CIRCLE;\n\n\t\t\tu += vec2(cos( dir ), sin( dir )) * (radius * fi2);\n            \n            if (hasInResolution( u, iResolution.xy ))\n            {\n                col += getColor( u ) * force;\n                totalw += 1.;\n\n            }\n\t\t\n\t\t}\n\n\t}\n\n\treturn (totalw > 0. ? col / totalw : col);\n\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    #ifdef DEBUG_MESHLIST\n    \tfragColor = texture(iChannel0, uv);\n    \n    #else\n        vec3 color = getColor( uv );\n\n        #ifdef EFFECT_BLOOM\n    \t    float force = calcUV( uv, 0.0 );\n    \n            color = bloom( color, 5, 0.025 * force, 0.75 + 0.75 * (1. - force), uv );\n    \t\t\n        #endif\n\n        fragColor = vec4(color, 1.0);\n    \n    #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Copy to https://wickedengine.net/2018/01/10/optimizing-tile-based-light-culling/\nbool hasAABB ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in int index, const in float fov, const in vec2 AABB_size, const in vec2 AABB_center )\n{\n    Mesh mesh = getMesh( index, iTime, MeshCount );\n    \n    Project proj = projectSphere( rdX, rdY, rdZ, ro, mesh.position, mesh.radius, fov );\n    \n    vec2 so = proj.uv;\n    float sr = proj.radius;\n    vec2 bo = AABB_center;\n    vec2 br = AABB_size;\n    \n\tvec2 vDelta = max( vec2(0.0), abs( bo - so ) - br );\n\n\treturn dot( vDelta, vDelta ) <= sr * sr;\n\n}\n\nvec4 compute ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in float fov, const in vec2 uv, const in vec2 resolution, const in vec2 coord )\n{\n    vec2 tile = vec2(TileSize);\n    vec2 tile_resolution = vec2(ivec2(listResolution / tile));\n    \n\tivec2 AABB_coord = ivec2(coord / tile_resolution);\n    vec2 AABB_size = 1.0 / tile * 2.0;\n\tvec2 AABB_center = vec2(AABB_coord) * AABB_size + AABB_size - 1.0;// -1.0 ~ 1.0\n    \n    ivec2 tile_start_coord = ivec2(vec2(AABB_coord) * tile_resolution);\n    ivec2 tile_end_coord =  ivec2(vec2(AABB_coord + 1) * tile_resolution);\n    \n    ivec2 tile_fix_resolution = tile_end_coord - tile_start_coord;\n    ivec2 tile_coord = ivec2(coord) - tile_start_coord;\n    \n  \tint index = tile_coord.y * tile_fix_resolution.x + tile_coord.x;\n\n    vec2 fix = vec2(\n        iResolution.x / min( iResolution.x, iResolution.y ),\n        iResolution.y / min( iResolution.x, iResolution.y )\n\n    );\n\n    AABB_size *= fix;\n    AABB_center *= fix;\n    \n    if (index == 0)//tile_coord == vec2(0, 0)\n    {\n        return vec4( 1, MeshCount / 4, 0.0, 0.0 );//mesh_length\n        \n    }\n    else\n    {\n        int mesh_index = (index - 1) * 4 + 1;\n        \n        int r = 0;\n        int g = 0;\n        int b = 0;\n        int a = 0;\n        \n        for (int index = 0; index < 4; index++)\n        {\n            if (!hasAABB( rdX, rdY, rdZ, ro, mesh_index + index, fov, AABB_size, AABB_center ))\n            {\n                continue;\n                \n            }\n            \n            switch (index)\n            {\n                case 0:\n                \tr = mesh_index;\n                \tbreak;\n                \n                case 1:\n                \tg = mesh_index + 1;\n                \tbreak;\n                \n                case 2:\n                \tb = mesh_index + 2;\n                \tbreak;\n                \n                case 3:\n                \ta = mesh_index + 3;\n                \tbreak;\n                \n            }\n\n        }\n        \n        return vec4(r, g, b, a);\n        \n    }\n    \n    return vec4(-1.0, -1.0, -1.0, -1.0);//none\n\t\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = listResolution;\n    vec2 coord = fragCoord;\n    \n    if (coord.x >= resolution.x || coord.y >= resolution.y)\n    {\n        fragColor = vec4(0.0);\n        \n        return;\n        \n    }\n\n    vec2 uv = coord.xy / resolution.xy;\n    Camera cam = createCamera( iMouse, iTime );\n    vec3 rdZ = yawPitchToDirection( cam.direction, vec2(0.5), 1.0 );\n    vec3 rdY = yawPitchToDirection( vec2(cam.direction.x, cam.direction.y - HALF), vec2(0.5), 1.0 );\n    vec3 rdX = normalize( cross( rdZ, rdY ) );\n\n    fragColor = compute( rdX, rdY, rdZ, cam.position, cam.fov, uv, resolution, coord );\n\t\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define DEBUG_CULLING\n//#define DEBUG_MESHLIST\n#define EFFECT_BLOOM\n\n#define FOV 0.5\n#define MeshMax 1200\n#define MARCH_STEP 40\n#define MARCH_DISTANCE 22.5\n\n#define QUATER 0.7853981633974483\n#define HALF 1.5707963267948966\n#define PI 3.141592653589793\n#define CIRCLE 6.283185307179586\n\n#define TS max( 1.0, sqrt( (iResolution.x * iResolution.y * 4.0) / float(MeshMax) ) )\n#define TileSize (TS - mod(TS, 2.0))\n#define listResolution (iResolution.xy - mod( iResolution.xy, vec2(TileSize) ))\n#define MeshCount int(min( float(MeshMax), floor( (listResolution.x * listResolution.y * 4.0) / float(pow(TileSize, 2.0)) ) ))\n\n#define hasInResolution(pos,rez) all(bvec2(all(greaterThanEqual(ivec2(pos),ivec2(0.0))),bvec2(all(lessThan(ivec2(pos),ivec2(rez))))))\n\nstruct Camera {\n\tvec3 position;\n\tvec2 direction;//pitch yaw\n\tfloat fov;\n\n};\n\nstruct Mesh {\n\tvec3 position;\n    float radius;\n    float morph;\n    \n};\n    \nstruct Project {\n    vec2 uv;\n    float radius;\n    \n};\n    \nfloat hash ( float p )\n{\n    return (fract( sin( p ) * CIRCLE ) - 0.5) / 0.5;\n    \n}\n  \nfloat hashAbs ( float p )\n{\n    return fract( sin( p ) * CIRCLE );\n    \n}\n\nfloat modI ( float a, float b )\n{\n    float m = a - floor( (a + 0.5) / b ) * b;\n    \n    return floor( m + 0.5 );\n    \n}\n\nfloat calcUV ( const in vec2 uv, const in float m )\n{\t\n\tfloat vig = (0.0 + 1.0 * 16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));\n\t\n\treturn max( m, 1. - pow( vig, 0.25 ) );\n\n}\n\nvec3 rotate( vec3 pos, vec3 axis,float theta )\n{\n    axis = normalize( axis );\n    \n    vec3 v = cross( pos, axis );\n    vec3 u = cross( axis, v );\n    \n    return u * cos( theta ) + v * sin( theta ) + axis * dot( pos, axis );   \n    \n}\n\n//Copy to https://www.shadertoy.com/view/MdlGz4\nvec3 yawPitchToDirection ( const in vec2 dir, const in vec2 uv , const in float fov )\n{\n\tfloat xCos = cos( dir.x );\n\tfloat xSin = sin( dir.x );\n\tfloat yCos = cos( dir.y );\n\tfloat ySin = sin( dir.y );\n\t\n\tfloat gggxd = uv.x - 0.5;\n\tfloat ggyd = uv.y - 0.5;\n\tfloat ggzd = fov;\n\t\n\tfloat gggzd = ggzd * yCos + ggyd * ySin;\n\t\n\treturn normalize( vec3(\n\t\tgggzd * xCos - gggxd * xSin,\n\t\tggyd * yCos - ggzd * ySin,\n\t\tgggxd * xCos + gggzd * xSin\n\t\t\n\t) );\n\n}\n\nbool  boundingSphere ( const in vec3 rd, const in vec3 ro, const in vec3 so, const in float sr )\n{\n    return length( cross( rd, so - ro ) ) <= sr;\n    \n}\n\nvec2 getAspect ( const in vec2 resolution )\n{\n    return resolution.xy / min( resolution.x, resolution.y );\n    \n}\n\n//Copy to https://www.shadertoy.com/view/MscSRr\nProject projectSphere ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in vec3 so, const in float sr, const in float fov )\n{\n\tvec3 vel = so - ro;\n\n\tfloat cx = dot( vel, rdX );\n\tfloat cy = dot( vel, rdY );\n\tfloat cz = dot( vel, rdZ );\n\t\n\tfloat dz = dot( vel, rdZ );\n    \n    float fix = 2.0 * fov;\n\n    return Project(\n\t\tvec2(\n            (cx / cz),\n\t\t\t(cy / cz)\n            \n        ) * fix, // -2.0 ~ 2.0\n\t\t(sr * distance(vec2(1.0), vec2(0.0)) / dz) * fix\n\t\t\n\t);\n\n}\n\nCamera createCamera ( const in vec4 mouse, const in float time )\n{\n    vec2 dir = vec2(0.0, -HALF);\n    \n    return Camera(\n        vec3(10.0, 15.0, 10.0) + vec3(1.0) + vec3(0.0, -20.0, 0.0),\n        dir,\n        FOV\n\n    );\n    \n}\n\nMesh getMesh ( const in int index, const in float time, const in int count )\n{\n    float tiny_sorting = float(index) / float(count);\n    float animationX =  time + 2.5 * float(index);\n    float animationY =  sin( (time + 2.5 * float(index)) * (0.25 + 0.75 * sin( HALF + 0.0789 * float(index) ) ));\n    float y = mod( hash( float(index) * 0.4 * float(index) ) - (0.25 + hashAbs( float(index) * 0.2) * 0.75) * animationX * 5.0, 10.0 );\n    float depth = 1.0 - (y / 10.0);\n    float morph = (depth < 0.775 ? max( 0.0, depth - 0.55) / 0.25 : 1.0);\n    \n    return Mesh(\n     \tvec3(\n            (sin( tiny_sorting * CIRCLE ) + 1.0),\n            y,\n            (cos( tiny_sorting * CIRCLE ) + 1.0)\n            \n        ) * vec3(10.0, 2.0, 10.0) + vec3(1.0, 0.0, 1.0),\n        0.25 + hashAbs( float(index) * 0.8 * float(index) ) * 0.75 + 0.5 * morph,\n        morph\n       \n    );\n    \n}\n\nint getMeshForm ( const in int index )\n{\n    return int( hashAbs( float(index) * 0.25 * float(index) ) * 4.0 );\n    \n}\n\nvec3 getMeshColor ( const in int index )\n{\n    return vec3(\n     \t0.75,\n        0.75,\n        0.75\n        \n    );\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float op ( float x1, float x2 )\n{\n    return x1 < x2 ? x1 : x2;\n    \n}\n\n//Copy to https://iquilezles.org/articles/distfunctions\nfloat sdSphere ( vec3 p, float sr )\n{\n    return length( p ) - sr;\n    \n}\nfloat sdRoundBox ( vec3 p, vec3 br, float r )\n{\n\tvec3 q = abs( p ) - br;\n\t\n    return length( max( q, 0.0 ) ) + min( max( q.x, max( q.y, q.z ) ), 0.0 ) - r;\n    \n}\nfloat sdHexPrism ( vec3 p, vec2 h )\n{\n    vec3 q = abs( p );\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n   \tvec3 pp = abs( p );\n    \n    pp.xy -= 2.0*min( dot( k.xy, pp.xy ), 0.0 ) * k.xy;\n    \n    vec2 d = vec2(\n       length( pp.xy - vec2(clamp( pp.x, -k.z * h.x, k.z * h.x ), h.x) ) * sign( pp.y - h.x ),\n       pp.z - h.y\n        \n    );\n    \n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n    \n}\nfloat sdRoundedCylinder ( vec3 p, float ra, float rb, float h )\n{\n\tvec2 d = vec2( length( p.xz ) -2.0 * ra + rb, abs( p.y ) - h );\n    \n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) ) - rb;\n    \n}\nfloat sdTorus ( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length( p.xz ) - t.x, p.y);\n    \n    return length( q ) - t.y;\n    \n}\n\nfloat map ( const in Mesh mesh, const in int index, const in vec3 pos )\n{\n    vec3 p = rotate(\n        pos - mesh.position,\n        vec3(\n            1.0,\n            1.0,\n            1.0\n        ),\n        iTime * (5.0 * hash( float(index) + 0.8 )) + hash( float(index) + 0.8 ) * 10.0\n        \n    );\n    \n    float h = 1e15;\n\n    switch (getMeshForm( index ))\n    {\n        case 0:\n            h = op( h, mix( sdSphere( p, mesh.radius * 0.75 ), sdRoundBox( p, vec3(mesh.radius * 0.375), 0.2 ), mesh.morph ) );\n            break;\n\n        case 1:\n            h = op( h, mix( sdSphere( p, mesh.radius * 0.75 ), sdHexPrism( p, vec2(mesh.radius * 0.75, mesh.radius * 0.75 * 0.5) ), mesh.morph ) );\n            break;\n\n        case 2:\n            h = op( h, mix( sdSphere( p, mesh.radius * 0.75 ), sdRoundedCylinder( p, mesh.radius * 0.375, mesh.radius * 0.375, 0.25 ), mesh.morph ) );\n            break;\n\n        case 3:\n            h = op( h, mix( sdSphere( p, mesh.radius * 0.75 ), sdTorus( p, vec2(mesh.radius * 0.5, mesh.radius * 0.25) ), mesh.morph ) );\n            break;\n\n    }\n    \n    return h;\n    \n}\n\nvec3 getNormal ( const Mesh mesh, const int index, const vec3 pos )\n{\n    float ep = 0.0001;\n    \n    return normalize( vec3(\n        map( mesh, index, pos ) - map( mesh, index, vec3(pos.x - ep, pos.y, pos.z) ),\n        map( mesh, index, pos ) - map( mesh, index, vec3(pos.x, pos.y - ep, pos.z) ),\n        map( mesh, index, pos ) - map( mesh, index, vec3(pos.x, pos.y, pos.z - ep) )\n        \n    ) );\n    \n}\n\nfloat phong ( vec3 rd, vec3 ld, vec3 normal, float fresnel, float roughness, float metallic )\n{\n\tvec4 parametes = vec4(0.1, fresnel, roughness, metallic);\n\tvec3 n = normal;\n\tvec3 invLight = ld;\n\tvec3 invEye = rd;\n\tvec3 halfLE = normalize( invLight - invEye );\n\n\tfloat rough = parametes.z;\n\tfloat alpha2 = pow( rough, 4.0 );\n\tfloat D = alpha2 / (PI * pow( dot( n, halfLE ) * dot( n, halfLE ) * (alpha2 - 1.0) + 1.0, 2.0 ));\n\tfloat fre = parametes.y + (1.0 - parametes.y) * pow( clamp( dot( invEye, halfLE ), 0.0, 1.0 ), 5.0 );\n\tfloat nv = clamp( dot( invEye, n ), 0.0, 1.0 );\n\tfloat nl = clamp( dot( invLight, n ), 0.0, 1.0 );\n\tfloat G = 1.0 / (nv + sqrt( alpha2 + (1.0 - alpha2) * nv * nv) ) / (nl + sqrt( alpha2 + (1.0 - alpha2) * nl * nl ));\n\tfloat specular = D * fre * G;\n\tfloat diffuse = (1.0 - fre) * clamp( dot( n, invLight ), 0.0, 1.0 ) / PI;\n\tfloat meta = parametes.w;\n\n\treturn clamp( mix( diffuse, specular, meta ), 0.0, 1.0 );\n\n}\n\nvoid marching ( const vec3 rd, const vec3 ro, const int index, inout float dist, inout vec3 col )\n{\n   \tMesh mesh = getMesh( index, iTime, MeshCount );\n\n    if (!boundingSphere( rd, ro, mesh.position, mesh.radius))\n    {\n        return;\n\n    }\n    \n    vec3 pos = ro;\n    float d = 1e10;\n    \n   \tfor (int i = 0; i < MARCH_STEP; i++)\n    {\n        float dst = length( ro - pos );\n        \n        if (dst > dist)\n        {\n            break;\n            \n        }\n        \n        d = op( d, map( mesh, index, pos ) );\n        \n        if (d > 0.0001)\n        {\n    \t\tpos += rd * d;\n            \n            continue;\n\n        }\n\n        dist = dst;\n\n        vec3 normal = getNormal( mesh, index, pos );\n        float depth = (1. - (dst / 22.5)) * 2.0;\n        vec3 color = getMeshColor( index );\n\n        color = color * mesh.morph;\n\n        col = vec3(0.75 * color * depth + 0.75 * phong( rd, vec3(0.5) - rd, normal, 1.0 - 0.25 * mesh.morph, 1.0 - 0.5 * mesh.morph, 1.0 - 0.75 * mesh.morph )) * depth;\n        \n        break;\n\n    }\n    \n}\n\nvec4 rendering ( const in vec3 rd, const in vec3 ro, const in vec2 uv, const in vec2 resolution, const in vec2 coord )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 tile = vec2(TileSize);\n\tivec2 AABB_coord = ivec2(coord / vec2(ivec2(iResolution.xy / tile)));\n    \n    vec2 tile_resolution = vec2(ivec2(listResolution / tile));\n    \n    ivec2 tile_start_coord = ivec2(vec2(AABB_coord) * tile_resolution);\n    ivec2 tile_end_coord =  ivec2(vec2(AABB_coord + 1) * tile_resolution);\n    \n    ivec2 tile_fix_resolution = tile_end_coord - tile_start_coord;\n    \n    vec4 mesh_length = texelFetch( iChannel0, tile_start_coord, 0);// tile_coord = vec2(0, 0);\n    \n    int start = int(mesh_length.r);\n    int end = int(mesh_length.g);\n    \n    #ifdef DEBUG_CULLING\n    \tint count = 0;\n    \n    #endif\n    \n    float dist = MARCH_DISTANCE;\n\n    for(int i = start; i < end; i++)\n    {\n        ivec2 tile_coord = ivec2(\n           modI( float(i), float(tile_fix_resolution.x) ),\n           floor( float(i / tile_fix_resolution.x) )\n\n        );\n\n        vec4 pixel = texelFetch( iChannel0, tile_start_coord + tile_coord, 0 );\n\n        #ifdef DEBUG_CULLING\n            if (pixel.r > 0.0 || pixel.g > 0.0 || pixel.b > 0.0 || pixel.a > 0.0)\n            {\n                count++;\n\n            }\n\n        #endif\n\n        if (pixel.r > 0.0)\n        {\n            marching( rd, ro, int(pixel.r), dist, col );\n\n        }\n        \n        if (pixel.g > 0.0)\n        {\n            marching( rd, ro, int(pixel.g), dist, col );\n            \n        }\n        \n        if (pixel.b > 0.0)\n        {\n            marching( rd, ro, int(pixel.b), dist, col );\n\n        }\n       \t\n        if (pixel.a > 0.0)\n        {\n            marching( rd, ro, int(pixel.a), dist, col );\n\n        }\n\n    }\n    \n    #ifdef DEBUG_CULLING\n        col += vec3(float(count) / 10.0, 0.0, 0.0);\n\n    #endif\n    \n    return vec4(col, 1.0);\n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    vec2 coord = fragCoord;\n    \n    vec2 uv = coord.xy / resolution.xy;\n    vec2 u = (uv - 0.5) * getAspect( resolution.xy ) + 0.5;\n    Camera cam = createCamera( iMouse, iTime );\n    vec3 rd = yawPitchToDirection( cam.direction, u, cam.fov );\n    \n    #ifdef DEBUG_MESHLIST\n        fragColor = texture(iChannel0, uv);\n\n    #else\n    \tfragColor = rendering( rd, cam.position, u, resolution, coord );\n    \n   \t#endif\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}