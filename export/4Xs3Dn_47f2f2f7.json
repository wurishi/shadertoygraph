{"ver":"0.1","info":{"id":"4Xs3Dn","date":"1707354106","viewed":131,"name":"4D slices","username":"zenzicubic","description":"3D slices through a 4D polytope","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["projection","kaleidoscope","4d","polytope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nWritten by Zenzicubic, 2024.\nSlices through a 4D kaleidoscope.\nSee \"Beautiful Math, Part 6: Visualizing 4D Regular\nPolytopes Using the Kaleidoscope Principle\" by Ouyang, Wang,\nand Zhao for more details.\n*/\n\nstruct Hit { \n    bool hit; \n    vec3 pt; \n};\n\n/*\nConstants and parameters.\n*/\n\n#define NUM_ITERS 10\n#define FOCAL_LEN 2.75\n#define AMBIENT .4\n#define INTENSITY .6\n\nconst vec3 ld = normalize(vec3(.2, .6, .5));\n\nvec3 eye;\nmat3 viewMat;\n\nvec4 v1, v2, v3, v4;\nfloat b, r, c = 1.;\n\nconst float ca = sqrt(5.) * .25 + .25;\nconst float cb = ca - .5;\n\n/*\nReflections and setting the root system.\n*/\n\nvoid setRootSys(int i) {\n    // Set the root system for the polytope\n    if (i == 0) {\n        // 5-cell\n        v1 = vec4(1., -1., 0., 0.);\n        v2 = vec4(0., 1., -1., 0.);\n        v3 = vec4(0., 0., 1., -1.);\n        v4 = vec4(1., 0., 0., -1.);\n    } else if (i == 1) {\n        // 8- and 16-cells\n        v1 = vec4(1., -1., 0., 0.);\n        v2 = vec4(0., 1., -1., 0.);\n        v3 = vec4(0., 0., 1., -1.);\n        v4 = vec4(0., 0., 0., 1.);\n    } else if (i == 2) {\n        // 24-cell\n        v1 = vec4(.5, -.5, -.5, -.5);\n        v2 = vec4(0., 1., -1., 0.);\n        v3 = vec4(0., 0., 1., -1.);\n        v4 = vec4(0., 0., 0., 1.);\n    } else {\n        // 120- and 600-cells\n        v1 = vec4(ca, -.5, cb, 0.);\n        v2 = vec4(-ca, .5, cb, 0.);\n        v3 = vec4(.5, cb, -ca, 0.);\n        v4 = vec4(-.5, -ca, 0., cb);\n    }\n}\n\nvoid reflectInPlane(vec4 nrm, inout vec4 pt, inout int j, inout bool fund) {\n    // Reflect in a given plane in the polytope\n    float dt = dot(nrm, pt);\n    if (dt < 0.) {\n        pt -= 2. * nrm * dt / dot(nrm, nrm);\n        j ++;\n        fund = false;\n    }\n}\n\nint mapToFund(vec3 sphPt) {\n    // Get point in R4\n    vec4 pt = vec4(r * sphPt, b);\n\n    // Map to fundamental region using reflections in planes\n    int j = 0;\n    bool fund;\n    for (int i = 0; i < NUM_ITERS; i ++) {\n        fund = true;\n        \n        reflectInPlane(v1, pt, j, fund);\n        reflectInPlane(v2, pt, j, fund);\n        reflectInPlane(v3, pt, j, fund);\n        reflectInPlane(v4, pt, j, fund);\n        if (fund) break;\n    }\n    \n    return j;\n}\n\n/*\nRay-sphere intersection.\n*/\n\nHit hitSphere(vec3 ro, vec3 rd) {\n    Hit hit;\n    hit.hit = false;\n    \n    // Compute coefficients and discriminant\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - 1.;\n    \n    float disc = b * b - c;\n    if (disc < 0.) return hit;\n    \n    // Solve and test solution\n    disc = sqrt(disc);\n    float t = min(-b - disc, disc - b);\n    \n    if (t < 0.) return hit;\n\n    // Compute point\n    vec3 pt = ro + rd * t;\n    hit.hit = true;\n    hit.pt = pt;\n    return hit;\n}\n\n/*\nRay-scene intersection.\n*/\n\nvec3 getRay(vec2 pt) {\n    // Gets a camera ray\n    pt = (2. * pt - iResolution.xy) / iResolution.y;\n    vec3 dir = normalize(vec3(pt, -FOCAL_LEN));\n    return viewMat * dir;\n}\n\nvoid computeViewMat(vec3 lookAt) {\n    // OpenGL-style view matrix\n    vec3 w = normalize(lookAt - eye);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    viewMat = mat3(u, v, -w);\n}\n\nvec3 getColor(vec2 pt) {\n    // Trace the sphere\n    vec3 rd = getRay(pt);\n    Hit hit = hitSphere(eye, rd);\n    \n    if (hit.hit) {\n        // Lighting\n        int j = mapToFund(hit.pt);\n        vec3 col = (j % 2 == 0 ? vec3(1., .733, 0.) : vec3(.361, .361, 1.));\n        \n        // Coloring\n        col *= AMBIENT + INTENSITY * max(0., dot(hit.pt, ld));\n        return col;\n    }\n    return vec3(.1);\n}\n\nvec3 multisample(vec2 pt) {\n    vec3 col = getColor(pt);\n    col += getColor(pt + vec2(.25, .25));\n    col += getColor(pt + vec2(-.25, .25));\n    col += getColor(pt + vec2(.25, -.25));\n    col += getColor(pt + vec2(-.25, -.25));\n    return col * .2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = .5 * iTime;\n    \n    b = .5 + .5 * sin(t);\n    r = sqrt(c * c - b * b);\n    eye = vec3(2. * cos(t), 3., 2. * sin(t));\n    computeViewMat(vec3(0.));\n    \n    setRootSys(3);\n    fragColor = vec4(multisample(fragCoord), 1.);\n}","name":"Image","description":"","type":"image"}]}