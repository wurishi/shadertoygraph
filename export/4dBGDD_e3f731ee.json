{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// draw the background image\n// return rgb = colour, a = snow-collision distance field\nvec4 Scene( vec2 pos )\n{\n\tvec4 result;\n\t\n\tresult.rgb = pow(vec3(.1,.2,.3),1.7*vec3(1.15-pos.y/iResolution.y));\n\tresult.a = 1000000.0;\n\t\n\tvec2 treePos = pos - vec2(iResolution.x*.7, iResolution.y*.9);\n\tfloat dist;\n\t\n\t// trunk\n\tif ( pos.y < iResolution.y*.5 )\n\t{\n\t\tdist = abs(treePos.x)-iResolution.y*.06;\n\t\tresult.a = min( result.a, dist );\n\t\tif ( dist < .0 )\n\t\t{\n\t\t\tresult.rgb = mix ( vec3(.3,.15,.1), vec3(.1,0,0), texture( iChannel0, pos*vec2(1.5,.3)/256.0 ).x );\n\t\t}\n\t}\n\t\n\t// xmas tree\n\tdist = abs(treePos.x)*sqrt(3.0)/2.0+treePos.y*.5;\n\tdist = max( dist, iResolution.y*.2-pos.y );\n\tresult.a = min( result.a, dist );\n\tif ( dist < 0.0 )\n\t{\n\t\tresult.rgb = mix( vec3(.1,.4,.05), vec3(.0,.2,.0), texture( iChannel0, vec2(pow(length(treePos)*.0001,.5),.4*atan(treePos.y,treePos.x)) ).x );\n\t}\n\t\n\t// ground\n\tdist = pos.y - iResolution.y*.06;\n\tresult.a = min( result.a, dist );\n\tif ( dist < 0.0 )\n\t{\n\t\tresult.rgb = mix ( vec3(.2), vec3(.05), texture( iChannel0, pos*.6/256.0 ).x );\n\t}\n\t\n\t// inflated santa\n\tfloat s = iResolution.y;\n\tdist = min( min( min( min( min(\n\t\t\tlength( pos - s*vec2(.2,.2) ) - s*.14,\n\t\t\tlength( pos - s*vec2(.09,.09) ) - s*.03 ),\n\t\t\tlength( pos - s*vec2(.31,.09) ) - s*.03 ),\n\t\t\tlength( pos - s*vec2(.05,.25) ) - s*.03 ),\n\t\t\tlength( pos - s*vec2(.35,.25) ) - s*.03 ),\n\t\t\tmax( abs(pos.x-s*.2)*sqrt(3.0)*.5+(pos.y-s*.45)*.5, -pos.y+s*.2 ) );\n\tresult.a = min( result.a, dist );\n\tif ( dist < 0.0 )\n\t{\n\t\tresult.rgb = mix ( vec3(.9,0,0), vec3(1,1,1),\n\t\t\t\t\t\t  smoothstep( 3.0, -3.0,\n\t\t\t\t\t\t\t\t max( sin(pos.y)*1.0+abs(pos.x-s*.2)*sqrt(3.0)*.5-(pos.y-s*.2)*.5, pos.y-s*.3 )\n\t\t\t\t\t\t\t));\n\t}\n\n\treturn result;\n}\n\nconst float wobbleAmplitude = 3.0;\nfloat Wobble( in float y )\n{\n\ty = floor(y);\n\treturn sin(y)*2.0+sin(y*1.68)*1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// divide the screen into columns, but wobble the columns to disguise them.\n\tfloat y = floor(fragCoord.y);\n\tfloat wobble = Wobble(y);\n\tconst float wind = .5;\n\t\n\tfloat column = floor(floor(fragCoord.x)-wobble+y*wind);\n\n\t// pretty debug mode!\n\t//fragColor = vec4(vec3(sin(column),sin(2.0*column),sin(3.0*column))*.5+.5,1.0); return;\n\t\n\t// now create snowflakes in each column, offset vertically by a random amount\n\tfloat flakeHeight = texture( iChannel0, (vec2(column,0)+.5)/iChannelResolution[0].xy, -100.0 ).x;\n\tflakeHeight -= iTime*.02;\n\tflakeHeight = fract(flakeHeight);\n\tflakeHeight = mix( -.5, 1.0, flakeHeight ); // allow more to settle, by extending the range off the bottom of the screen\n\tflakeHeight *= iResolution.y;\n\n\n\t// let it settle on objects\n\n\tvec4 scene = Scene(fragCoord);\n\n\tfragColor.rgb = scene.rgb; // background\n\t\n\t// early out: if flake is below this pixel\n\t// and we're not on an edge of the distance field\n\t// then we definitely don't have to draw snow\n\ty = floor(y);\n\tflakeHeight = floor(flakeHeight);\n\tif ( y > flakeHeight && abs(scene.a) > 4.0 )\n\t{\n\t\treturn;\n\t}\n\t\n\t// trace path of flake, to find where it will settle\n\tvec2 dir = normalize(vec2(wind,-1.0));\n\n\t// compute starting position at top of screen\n\t// this must depend only on column, so \n\tvec2 sp;\n\tsp.y = iResolution.y;\n\tsp.x = column-wind*sp.y;\n\t\n\tsp += vec2(1.0,1.0); // this makes settled snow line up better, I'm not sure why.\n\t\n\tvec2 p;\n\tfloat t = 0.0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tp = sp + t*dir;\n\t\t//p.x -= Wobble(floor(p.y)); // minus, because we're doing the opposite of pixel->column\n\t\tp = floor(p);\n\t\tfloat d = Scene(p).a;\n\t\tif ( d < .001 )\n\t\t\tbreak;\n\t\tfloat h = max( d - wobbleAmplitude, 1.0 ); // never step by less than a pixel\n\t\tt += h;\n\t}\n\n\tflakeHeight = max( flakeHeight, p.y );\n\n\tif ( floor(y) == floor(flakeHeight) )\n\t{\n\t\tfragColor.rgb += vec3 (.7);\n\t}\n\n\t/*if ( flakeHeight > p.y )\n\t{\n\t\tif ( floor(y) == floor(flakeHeight) ) // falling snow\n\t\t\tfragColor.rgb += vec3 (.7);\n\t}\n\telse\n\t{\n\t\tThis doesn't work on the floor, I don't know why. Something about the wobble.\n\t\tif ( length(p-fragCoord.xy) < 1.5 ) // settled snow\n\t\t\tfragColor.rgb += vec3 (.7);\n\t}*/\n\t\n\tfragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBGDD","date":"1387895064","viewed":370,"name":"Pixel Snow","username":"TekF","description":"Inevitable xmas shader!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pixels","festive"],"hasliked":0,"parentid":"","parentname":""}}