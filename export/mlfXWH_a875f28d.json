{"ver":"0.1","info":{"id":"mlfXWH","date":"1674683438","viewed":91,"name":"test - azavier","username":"azavier","description":"little testing area","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 bgcol(in vec3 dir) {\n  dir.xz *= rot(iTime*0.3);\n  return (dir*0.5+0.5)*1.;\n}\n\n// DISTANCE FUNCTIONS\nfloat sdfSphere(in vec3 p, in float r) { return length(p)-r; }\nfloat sdfBox(in vec3 p, in vec3 s) { return length(max(abs(p)-s, 0.)); }\n\n// SCENE DISTANCE FUNCTION\nmat2x2 rotScene() { return rot(PI/4.); }\nvoid rectify(inout float d, inout float i, in float ob, in float obm) {\n  float obc = step(ob, d);\n  \n  d = mix(d, ob, obc);\n  i = mix(i, obm, obc);\n}\nfloat[2] sdf(in vec3 p) {\n  float d = FAR;\n  float i = 0.;\n//SCENE START\n  //GROUND\n  float ground = p.y+1.;\n  rectify(d, i, ground, 1.0);\n  \n  //BOX\n  vec3 bp = p-vec3(0,1,0);\n  bp.xz *= rot(PI/4.);\n  bp.xz *= rotScene();\n  \n  bp.x -= 1.;\n  bp.y += 0.1*sin(iTime);\n  \n  bp.xz *= rot(iTime*0.5);\n  \n  float box = sdfBox(bp, vec3(0.3))-0.05;\n  rectify(d, i, box*0.75, 2.0);\n  \n  //SPHERE\n  vec3 sp = p-vec3(0.,1, 0.6);\n  sp.xz *= rot(PI/4.);\n  sp.xz *= rotScene();\n  \n  sp.x += 0.5;\n  sp.y += 0.1*cos(iTime);\n  \n  float sphere = mix(sdfSphere(sp, 0.4), sdfBox(sp, vec3(0.4))-0.1, sin(iTime*0.5)*0.5+0.5);\n  rectify(d, i, sphere*0.5, 3.0);\n  \n//SCENE END\n  return float[2](d, i);\n}\n\nvec3 normal(in vec3 p, in float pd) {\n\tvec2 d = vec2(0.001, 0);\n\tvec3 g = vec3(\n\t\tsdf(p - d.xyy)[0],\n\t    sdf(p - d.yxy)[0],\n\t    sdf(p - d.yyx)[0]\n\t);\n  return normalize(pd - g);\n}\n\nvec3 getTexel(in int matID, in Material mat, in vec3 p) {\n  switch(matID) {\n    case 0:\n      break;\n    case 1:\n      p.xz *= rotScene();\n      return material(1).albedo*(0.5+0.5*ceil(clamp(vec3(sin(1.5*p.x)+sin(1.5*p.z)), 0., 1.)));\n    default:\n      return mat.albedo;\n  }\n}\n\nfloat calcao(in vec3 p, in vec3 n){\n    float r = 0., w = 1., d;\n    \n    for (float i=1.; i<AO_SAMPLES+1.1; i++){\n        d = i/AO_SAMPLES;\n        r += w*(d - sdf(p + n*d)[0]);\n        w *= 0.5;\n    }\n    \n    return 1.-sat(r);\n}\n\nvec3 lighting(in vec3 p, in vec3 n) {\n  vec3 dif, amb = AMB_P;\n  float shadow = 1.;\n  for(int i = 0; i < lights.length(); i++) {\n    vec3 lv = lights[i].p - p;\n    float d = length(lv);\n    vec3 ld = normalize(lv);\n\n    float att = 1./(d*d); // ATTENUATION\n\n    amb += lights[i].col.rgb*att;\n    dif += lights[i].col.rgb*sat(dot(n, ld))*att*lights[i].col.a; // DIFFUSE\n    \n   #if SHADOWS == 1\n    float rd;\n    float tmpShadow = 1.;\n    float[2] data;\n    for(int step = 0; step < SHA_STEPS && rd < FAR; step++) {\n      data = sdf(p + n*HIT + ld*rd);\n    \n      if(data[0] < 0.)\n        break;\n    \n      tmpShadow = min(tmpShadow, smoothstep(-1., 1., PENUMBRA*data[0]/rd));\n      rd += data[0];\n    }\n    shadow += sat(max(tmpShadow, SHA_DARK));\n   #endif\n  }\n  \n  shadow *= recipLights;\n  \n  float ao = calcao(p, n);\n  \n  vec3 global = amb*AMBIENT + dif*DIFFUSE;\n  return mix(1.0, ao, float(AO))*mix(1.0, shadow, float(SHADOWS))*global;\n}\n\nfloat[3] trace(in vec3 ro, in vec3 rd, in int steps) {\n  float dist;\n  \n  for(int i = 0; i < steps; i++) {\n    float[2] d = sdf(ro + rd*dist);\n    \n    if(abs(d[0]) < HIT || dist > FAR)\n      return float[3](dist, d[1], d[0]);\n      \n    dist += d[0];\n  }\n}\n\nvec3 bounce(inout float[3] hit, inout vec3 ro, inout vec3 rd) {\n  vec3 bgcol = bgcol(rd);\n  \n  hit = trace(ro, rd, STEPS);\n  \n  Material mat = material(int(hit[1]));\n  \n  ro = ro + rd*hit[0];\n  vec3 n = normal(ro, hit[2]);\n  \n  rd = reflect(rd, n + mat.rough*randomVec3(ro)*0.1);\n  \n  vec3 texCol = getTexel(int(hit[1]), mat, ro);\n  \n  ro += n*HIT;\n  \n  texCol *= lighting(ro, n);\n  \n  //GAMMA CORRECTION\n  texCol = sqrt(sat(texCol));\n  //BG FOG\n  texCol = mix(texCol, bgcol, smoothstep(0., FAR*FAR, hit[0]*hit[0]));\n  \n  return texCol;\n}\n\nvoid surfcol(inout vec3 pixelColor, in vec3 ro, in vec3 rd) {\n  float[3] hit;\n  int bounces;\n  \n  for(bounces; hit[0] < FAR && bounces < BOUNCES; ++bounces) {\n    pixelColor += bounce(hit, ro, rd);\n    \n    if(material(int(hit[1])).rough == 1.)\n      break;\n  }\n  \n  pixelColor /= mix(1.0, float(bounces-1), step(2.0, float(bounces)));\n}\n\nvec3 PixelColor(in vec2 uv) {\n  vec3 pixelColor;\n  \n  vec3 ro = vec3(0, 1, 0.25);\n  \n  vec3 rd = normalize(vec3(uv*FOV, -1));\n\n  surfcol(pixelColor, ro, rd);\n    \n  return pixelColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  vec3 col;\n  \n #if AA > 1\n  vec2 AAO;\n  const float AA_INCREMENT = 1./float(AA);\n    \n  for(AAO.x = -0.5; AAO.x < 0.5; AAO.x += AA_INCREMENT)\n    for(AAO.y = -0.5; AAO.y < 0.5; AAO.y += AA_INCREMENT)\n      col += PixelColor(uv + AAO/iResolution.y);\n  \n  col /= float(AA*AA);\n #else\n  col += PixelColor(uv);\n #endif\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define HIGH_PERFORMANCE \n//#define MED_PERFORMANCE \n#define LOW_PERFORMANCE \n\n//SETTINGS\n#define FAR 50.\n#define HIT 0.01\n#define FOV 1.\n\n#define AMB_P vec3(0.01)\n\n#define AMBIENT 1.\n#define DIFFUSE 1.\n#define SPECULAR 1.\n#define EMISSIVE 1.\n\n#define SPEC_FALLOFF 40.\n\n#define AO 1\n#define AO_SAMPLES 4.4\n\n#define BOUNCES 10\n\n#define PENUMBRA 30.\n\n#define SHA_DARK 0.\n\n//END SETTINGS\n\n#define sat(a) clamp(a, 0., 1.)\n#define material(index) materials[index-1]\n#define light(index) lights[index-1]\n\n#define PI 3.14159265\n#define TAU 6.2831853\n\n#ifdef LOW_PERFORMANCE\n #define AA 1\n \n #define SHADOWS 0\n #define STEPS 180\n #define SHA_STEPS 0\n#endif\n#ifdef  MED_PERFORMANCE\n #define AA 1\n \n #define SHADOWS 1\n #define STEPS 180\n #define SHA_STEPS 80\n#endif\n#ifdef HIGH_PERFORMANCE\n #define AA 2\n \n #define SHADOWS 1\n #define STEPS 240\n #define SHA_STEPS 120\n#endif\n\nmat2x2 rot(in float a) { \n  float c = cos(a), s = sin(a);\n  return mat2x2(c, -s, s, c);\n}\n\nfloat Hash21(in vec2 hash) {\n  vec2 p = fract(hash*vec2(25.124, 85.124));\n  p += dot(p, p + 234.124);\n  return fract(p.x * p.y);\n}\n\nvec3 randomVec3(in vec3 point) {\n  vec3 ret;\n  ret.x = Hash21(vec2(point.x * point.y, point.z * point.y));\n  ret.y = Hash21(vec2(point.x * point.z, point.y * point.x));\n  ret.z = Hash21(vec2(point.y * point.z, point.z * point.y));\n  return normalize(ret);\n}\n\n// MATERIAL STRUCT & ARRAY\nstruct Material {\n  vec3 albedo;\n  float rough;\n  float metal;\n  float light;\n};\nMaterial[] materials = Material[](// v3_albedo, f_rough, f_metal, f_light\n  Material(vec3(1), 1., 0.4, 0.),\n  Material(vec3(0.01), 0., 1., 0.),\n  Material(vec3(0), 0., 1., 0.)\n);\n\nstruct Light {\n  vec4 col;\n  vec3 p;\n};\nLight[] lights = Light[](// v4_col, v3_p\n  Light(vec4(1,1,0.7,2), 2.*vec3(0.8,1,1)),\n  Light(vec4(0.7,1,1,2), 2.*vec3(1,1,1))\n);\nfloat recipLights = 1./float(lights.length() + 1);","name":"Common","description":"","type":"common"}]}