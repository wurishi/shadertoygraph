{"ver":"0.1","info":{"id":"NsVSzd","date":"1635228510","viewed":75,"name":"SimpleRayTracing","username":"liaozixin","description":"Achieve a simple ray tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","cg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Cam_Pos vec3(0, 0.78, -2.7)\n#define Cam_Look vec3(0, 1.2, 1.5)\n#define Bounce 2\n\n\n\nstruct Sphere\n{\n    vec3 c;\n    float r;\n};\n\nstruct Plane\n{\n    vec3 n;\n    vec3 c; \n    vec3 limit;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 col;\n};\n\nstruct Intersection\n{\n    bool happen;\n    vec3 pos;\n    vec3 n;\n    int type;\n    float dist;\n};\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nstruct Room\n{\n    Plane up;\n    Plane down;\n    Plane left;\n    Plane right;\n    Plane back;\n};\n\n\nIntersection GetIntersection(Ray r, Light l, Room room)\n{\n    Intersection p;\n    p.happen = false;\n    float depth = 100000000.;\n    \n    //intersect with Room\n    if (dot(-r.d, room.down.n) < 1. && dot(-r.d, room.down.n) > 0.)\n    {\n        p.dist= dot((room.down.c - r.o), room.down.n) / dot(r.d, room.down.n);\n        p.pos = r.o + p.dist * r.d;\n        p.n = room.down.n;\n        if (p.dist >= 0.)\n        {\n            if (p.pos.x > room.down.c.x - room.down.limit.x * 0.5 &&\n                p.pos.x < room.down.c.x + room.down.limit.x * 0.5 &&\n                p.pos.z > room.down.c.z - room.down.limit.z * 0.5 &&\n                p.pos.z < room.down.c.z + room.down.limit.z * 0.5)\n                {\n                    p.happen = true;\n                    p.type = 1;\n                    depth = min(depth, p.dist);\n                    return p;\n                }\n        }\n        \n    }\n    \n    if (dot(-r.d, room.up.n) < 1. && dot(-r.d, room.up.n) > 0.)\n    {\n       float tem = dot((room.up.c - r.o), room.up.n) / dot(r.d, room.up.n);\n       if (tem < depth && tem > 0.)\n       {\n           vec3 tem_pos = r.o + tem * r.d;\n           if (tem_pos.x > room.up.c.x - room.up.limit.x * 0.5 &&\n               tem_pos.x < room.up.c.x + room.up.limit.x * 0.5 &&\n               tem_pos.z > room.up.c.z - room.up.limit.z * 0.5 &&\n               tem_pos.z < room.up.c.z + room.up.limit.z * 0.5)\n           {\n               depth = tem;\n               p.pos = tem_pos;\n               p.n = room.up.n;\n               p.dist = tem;\n               p.happen = true;\n               p.type = 1;\n               return p;\n           }\n       }\n    }\n    \n    if (dot(-r.d, room.left.n) < 1. && dot(-r.d, room.left.n) > 0.)\n    {\n       float tem = dot((room.left.c - r.o), room.left.n) / dot(r.d, room.left.n);\n       if (tem < depth && tem > 0.)\n       {\n           vec3 tem_pos = r.o + tem * r.d;\n           \n           if (tem_pos.y > room.left.c.y - room.left.limit.y * 0.5 &&\n               tem_pos.y < room.left.c.y + room.left.limit.y * 0.5 &&\n               tem_pos.z > room.left.c.z - room.left.limit.z * 0.5 &&\n               tem_pos.z < room.left.c.z + room.left.limit.z * 0.5)\n           {\n               depth = tem;\n               p.dist = tem;\n               p.pos = tem_pos;\n               p.n = room.left.n;\n               p.happen = true;\n               p.type = 1;\n               return p;\n           }\n       }\n    }\n    \n    if (dot(-r.d, room.right.n) < 1. && dot(-r.d, room.right.n) > 0.)\n    {\n       float tem = dot((room.right.c - r.o), room.right.n) / dot(r.d, room.right.n);\n       if (tem < depth && tem > 0.)\n       {\n           vec3 tem_pos = r.o + tem * r.d;\n      \n           if (tem_pos.y > room.right.c.y - room.right.limit.y * 0.5 &&\n               tem_pos.y < room.right.c.y + room.right.limit.y * 0.5 &&\n               tem_pos.z > room.right.c.z - room.right.limit.z * 0.5 &&\n               tem_pos.z < room.right.c.z + room.right.limit.z * 0.5)\n           {\n               depth = tem;\n               p.dist = tem;\n               p.pos = tem_pos;\n               p.n = room.right.n;\n               p.happen = true;\n               p.type = 1;\n               return p;\n           }\n       }\n    }\n    \n    if (dot(-r.d, room.back.n) < 1. && dot(-r.d, room.back.n) > 0.)\n    {\n       float tem = dot((room.back.c - r.o), room.back.n) / dot(r.d, room.back.n);\n       if (tem < depth && tem > 0.)\n       {\n           vec3 tem_pos = r.o + tem * r.d;\n           \n           if (tem_pos.y > room.back.c.y - room.back.limit.y * 0.5 &&\n               tem_pos.y < room.back.c.y + room.back.limit.y * 0.5 &&\n               tem_pos.x > room.back.c.x - room.back.limit.x * 0.5 &&\n               tem_pos.x < room.back.c.x + room.back.limit.x * 0.5)\n           {\n               depth = tem;\n               p.dist = tem;\n               p.pos = tem_pos;\n               p.n = room.back.n;\n               p.happen = true;\n               p.type = 1;\n               return p;\n           }\n       }\n    }\n    return p;\n}\n\nvec3 Material(Intersection p)\n{\n    vec3 col = vec3(0);\n        \n    if (p.type == 1)\n    {\n        if (p.n.y > 0.)\n        {\n            vec2 uv = p.pos.xz * 5.;\n            uv = 0.5 * floor(uv);\n            col = vec3(fract(uv.x + uv.y) * 2.);\n            return col;\n        }\n       \n        else if (p.n.x < 0.)\n        {\n            col = vec3(0.0, 1.0, 0.0);\n            return col;\n        }\n        else if (p.n.x > 0.)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n            return col;\n        }\n        else if (p.n.z < 0.)\n        {\n            col = vec3(1.0, 0.75, 0.79);\n            return col;\n        }\n        else if (p.n.y < 0.)\n        {\n            col = vec3(1.0, 0.75, 0.79);\n            return col;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetLight(Intersection p, Light l, Room room)\n{\n    \n    vec3 view = normalize(Cam_Pos - p.pos);\n    float dist = length(l.pos - p.pos);\n    \n    vec3 light_dir = normalize(l.pos - p.pos);\n    vec3 n = p.n;\n    vec3 h = normalize(view + light_dir);\n    vec3 diffuse = l.col * 0.9 * max(0., dot(light_dir, n)) / pow(dist, 2.);\n    vec3 speular = l.col * 0.7 * pow(max(0., dot(n, h)), 20.);\n    vec3 ambient = l.col * 0.005;\n    \n    return diffuse + speular + ambient;\n}\n\n\nvec3 Shader(Ray r)\n{\n    vec3 col = vec3(0);\n    \n    Plane down;\n    down.c = vec3(0, 0, 0);\n    down.n = normalize(vec3(0, 1.5, 0) - down.n);\n    down.limit = vec3(3, 0, 3);\n    \n    Plane up;\n    up.c = vec3(0, 3, 0);\n    up.n = normalize(vec3(0, 1.5, 0) - up.c);\n    up.limit = vec3(3, 0, 3);\n    \n    Plane right;\n    right.c = vec3(1.5, 1.5, 0);\n    right.n = normalize(vec3(0, 1.5, 0) - right.c);\n    right.limit = vec3(0, 3, 3);\n    \n    Plane left;\n    left.c = vec3(-1.5, 1.5, 0);\n    left.n = normalize(vec3(0, 1.5, 0) - left.c);\n    left.limit = vec3(0, 3, 3);\n    \n    Plane back;\n    back.c = vec3(0, 1.5, 1.5);\n    back.n = normalize(vec3(0, 1.5, 0) - back.c);\n    back.limit = vec3(3, 3, 0);\n    \n    Room room;\n    room.up = up;\n    room.down = down;\n    room.left = left;\n    room.right = right;\n    room.back = back;\n    \n    Light l;\n    l.pos = vec3(0, 2.8, 0);\n    l.col = vec3(1.);\n    \n    int times = 0;\n    while (times < Bounce)\n    {\n        Intersection p = GetIntersection(r, l, room);\n        \n        vec3 tem_col = vec3(0);\n        if (p.happen == true)\n        {\n            tem_col = Material(p);\n            vec3 light = GetLight(p, l, room);\n            tem_col *= light;\n            col += tem_col;\n            \n            r.o = p.pos;\n            r.d = normalize(reflect(r.d, p.n));            \n        }\n        \n        if (p.type == 1 && abs(p.n.y) > 0.)\n        {\n           ++times; \n           continue;\n        }\n        break;\n    }\n    \n    return col;\n}\n\n\nRay InitCam(vec2 uv)\n{   \n    vec3 front = normalize(Cam_Look - Cam_Pos);\n    vec3 right = normalize(cross(vec3(0, 1, 0), front));\n    vec3 up = normalize(cross(front, right));\n    \n    float zoom = 0.85;\n    \n    vec3 screen_center = Cam_Pos + zoom * front;\n    vec3 uv_to_screen = screen_center + uv.x * right + uv.y * up;\n    \n    vec3 rd = normalize(uv_to_screen - Cam_Pos);\n    Ray r;\n    r.o = Cam_Pos;\n    r.d = rd;\n    return r;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalize uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    Ray r = InitCam(uv);  \n    vec3 col = Shader(r);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}