{"ver":"0.1","info":{"id":"MsVfRt","date":"1619816682","viewed":59,"name":"Repeating","username":"rift","description":"repeating","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst int MAX_STEPS = 128;\nconst float STEP_SCALE = 1.;\nconst float eps = 0.005; \n\nfloat sphere(vec3 p, vec3 center, float radius) \n{\n  return length(p - center) - radius;\n}\n\nfloat sinusoid(vec3 p)\n{\n  return cos(p.x*3.+sin(iTime)*0.7)* sin(p.y*3.+sin(iTime)*0.4) * cos(p.z*-3.0+sin(iTime)*0.4) \n          + 0.8*cos(p.x*18.+sin(iTime)*1.4) * sin(p.y*18.+sin(iTime)*0.4) * cos(p.z*-18.+sin(iTime)*0.8);\n}\n\nfloat scene(vec3 p)\n{\n    \n    return sphere(vec3(mod(p.x, 1.5) - 0.1 , mod(p.y,1.5) - 0.8,mod(p.z, 1.5) + 0.1), vec3(0.6,-0.1,1.0), 0.5)+0.06*sinusoid(p);\n}\n\nfloat march(vec3 origin, vec3 direction, float start, float end)\n{\n  float sceneDist = 0.0;\n  float rayDepth = start;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    sceneDist = scene( origin + direction * rayDepth);\n\n    if(rayDepth >= end) {\n      break;\n    }\n\n    rayDepth += sceneDist * STEP_SCALE;\n\n  }\n\n  return rayDepth;\n}\n\nvec3 getNormal(in vec3 p) \n{\n  \n  return normalize(vec3(\n    scene(vec3(p.x+eps,p.y,p.z))-scene(vec3(p.x-eps,p.y,p.z)),\n    scene(vec3(p.x,p.y+eps,p.z))-scene(vec3(p.x,p.y-eps,p.z)),\n    scene(vec3(p.x,p.y,p.z+eps))-scene(vec3(p.x,p.y,p.z-eps))\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 cameraPos = vec3(cos(-iTime)/2.+0.2, cos(iTime)/2.-0.4, iTime);\n  vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n  vec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n  vec2 screenCoords = vec2(2.0 * fragCoord.xy/iResolution.xy - 1.0) * aspectRatio;\n  float FOV = 0.5;\n\n  vec3 rayOrigin = cameraPos;\n  vec3 forward = normalize(cameraLookAt + cameraPos);\n  vec3 right = normalize(vec3(forward.z, 0.0, -forward.x));\n  vec3 up = normalize(cross(forward,right));\n  vec3 rayDir = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);\n\n  float clipNear = 0.0;\n  float clipFar = 25.0;\n\n  vec3 bgColor = vec3(0.0, 0.0, 0.0);\n\n  float dist = march(rayOrigin, rayDir, clipNear, clipFar);\n\n  if (dist >= clipFar) {\n    fragColor = vec4(bgColor, 1.0);\n    return;\n  }\n\n  vec3 surfacePos = rayOrigin + rayDir*dist;\n  vec3 surfaceNormal = getNormal(surfacePos);\n  \n  vec3 lightPos = cameraPos;//vec3(0.0,iTime,iTime);\n\n  vec3 lightDir = normalize(lightPos-surfacePos);\n\n  vec3 lightColor = vec3(1.,0.97,0.92);\n\n  vec3 ref = reflect(-lightDir, surfaceNormal);\n  float diffuse = max( 0.0, dot(surfaceNormal, lightDir) );\n  float specular = max( 0.0, dot( ref, normalize(cameraPos-surfacePos)) ); \n\n  vec3 spherecolor = vec3(abs(sin(iTime/2.))*0.5, abs(cos(iTime/2.))*0.5,abs(sin(iTime/4.))*0.5) * (diffuse*.7) + specular*0.01;\n  fragColor = vec4(spherecolor,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}