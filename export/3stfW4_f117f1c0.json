{"ver":"0.1","info":{"id":"3stfW4","date":"1605452171","viewed":41,"name":"Math Function","username":"Ovizro","description":"To solve some math questions.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * This is a simple example to draw math functions and geometries.\n *\n */\n\n#define ORIGIN \tvec2(-0.2, 0.0)\n#define SCALE \t3.0\n\n#define AXIS_WIDE 12.0 * SCALE\n#define GRID_SIZE 10.0\n\n#define LINE_WIDE 6.0 * SCALE\n#define AAA_LEVEL 2.0 * SCALE\n\n#define pixel vec2(1.0 / iResolution.xy)\n\n#define pow2(x) (x * x)\n#define pow3(x) (x * x * x)\n#define distance2(x) dot(x, x)\n\n#define plus(m, n) ((m + n) - m * n)\n#define nor(m, n) ((m + n) - 2 * m * n)\n\n//preset colors\nconst vec3 Red \t\t= vec3(1.0, 0.0, 0.0);\nconst vec3 Green \t= vec3(0.0, 1.0, 0.0);\nconst vec3 Blue \t= vec3(0.0, 0.0, 1.0);\nconst vec3 Yellow\t= vec3(251.0, 211.0, 55.0) / 255.0;\n\n//some conventional colors from http://zhongguose.com/\nconst vec3 YALV\t\t= vec3(150.0, 194.0, 78.0) / 255.0;\nconst vec3 YOUHUANG\t= vec3(252.0, 183.0, 10.0) / 255.0;\n\n\nstruct Screen {\n    vec3 color;\n    \n    vec2 uv;\n} frag;\n    \nstruct Grid {\n    float axis;\n    float grid;\n};\n\nstruct Triangle {\n    vec2 pos[3];\n    vec3 vertex[3];\n    \n    bool filled;\n    bool calculated;\n    float covering;\n};\n    \nstruct Quads {\n    vec2 pos[4];\n    vec3 vertex[4];\n    \n    bool filled;\n    bool calculated;\n    float covering;\n};\n\nstruct Circle {\n    vec2 center;\n    float r;\n    \n    bool filled;\n    bool calculated;\n    float covering;\n};\n    \n//helping function\nfloat sum2(vec2 var) {return var.x + var.y;}\nfloat sum3(vec3 var) {return dot(vec3(1.0), var);}\nfloat sum4(vec4 var) {return dot(vec4(1.0), var);}\n    \nfloat linearstep(float edge0, float edge1, in float x) {\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvec2 segment(vec2 edge0, vec2 edge1, vec2 s, in vec2 var) {\n    return smoothstep(edge0 - s, edge0 + s, var) - smoothstep(edge1 - s, edge1 + s, var);\n}\n\nfloat spread(float center, float range, in float x) {\n    return smoothstep(center - range, center, x) - smoothstep(center, center + range, x);\n}\n\nvec2 spread(vec2 center, vec2 range, in vec2 x) {\n    return smoothstep(center - range, center, x) - smoothstep(center, center + range, x);\n}\n\nfloat positive(in float var, float s) {\n    return smoothstep(0.0 - s, 0.0 + s, var);\n}\n\nvec2 positive(in vec2 var, vec2 s) {\n    return smoothstep(0.0 - s, 0.0 + s, var);\n}\n\nfloat det2(vec2 a, vec2 b) {\n    return a.s * b.t - a.t * b.s;\n}\n\nfloat circleIndex(vec2 v, float r) {\n    return pow2(r) - distance2(v);\n}\n\nfloat cycling(float edge0, float edge1, float cycle, float t) {\n    float wave = abs(fract(t / cycle) - 0.5) * 2.0;\n    return wave * (edge1 - edge0) + edge0;\n}\n\nfloat cycling(float edge0, float edge1, float cycle) {\n    return cycling(edge0, edge1, cycle, iTime);\n}\n\nfloat cycling(float edge0, float edge1) {\n    return cycling(edge0, edge1, 2.0);\n}\n\nfloat func(float fx) {\n    return spread(frag.uv.y, LINE_WIDE * sum2(pixel), fx);\n}\n\n//init screen setting\nvoid init() {\n    frag.color = vec3(0.0);\n    frag.uv = (gl_FragCoord.xy - (ORIGIN + 0.5) * iResolution.xy) / min(iResolution.x, iResolution.y) * 2.0 * SCALE;\n}\n\n//rasterize geometries\nfloat rasterizeL(vec2 pos1, vec2 pos2, in vec2 coord) {\n    vec2 v = pos2 - pos1;\n    float adj = det2(v, coord) + det2(pos1, pos2);\n    return spread(0.0, (pixel.x + pixel.y) * 3.0 * AAA_LEVEL, adj);\n}\n\nfloat rasterizeS(vec2 pos1, vec2 pos2, in vec2 coord) {\n    vec2 vi = min(pos1, pos2);\n    vec2 va = max(pos1, pos2);\n    vec2 d = min((va - vi) * 0.5 - LINE_WIDE * pixel, 0.0);\n    vi += d;\n    va -= d;\n    vec2 range = segment(vi, va, LINE_WIDE * pixel, coord);\n    return rasterizeL(pos1, pos2, coord) * range.x * range.y;\n}\n\nfloat rasterize(vec2 pos1, vec2 pos2, vec2 pos3, in vec2 coord) {\n    vec2 v1 = pos2 - pos1;\n    vec2 v2 = pos3 - pos1;\n    mat2 trans = inverse(mat2(v1, v2));\n    vec2 uv = trans * (coord - pos1);\n    const float extension = 0.0007;\n    return positive(1.0 - (uv.x + uv.y) + extension, sum2(pixel) * 0.707 * AAA_LEVEL)\n        * positive(uv.x + extension, pixel.x*AAA_LEVEL)\n        * positive(uv.y + extension, pixel.y*AAA_LEVEL);\n}\n\nfloat rasterizeL(vec2 pos1, vec2 pos2) {return rasterizeL(pos1, pos2, frag.uv);}\nfloat rasterizeS(vec2 pos1, vec2 pos2) {return rasterizeS(pos1, pos2, frag.uv);}\nfloat rasterize(vec2 pos1, vec2 pos2, vec2 pos3) {return rasterize(pos1, pos2, pos3, frag.uv);}\nfloat rasterize(vec2 pos[3]) {return rasterize(pos[0], pos[1], pos[2], frag.uv);}\n\n//build grid\nfloat axis(in vec2 coord) {\n    vec2 axis = spread(vec2(0.0), pixel * AXIS_WIDE, coord);\n    return plus(axis.x, axis.y);\n}\n\nfloat texgrid(in vec2 coord) {\n    const float blockSize = 2.0 / ceil(SCALE / 1.5);\n    vec2 block = fract(coord * blockSize + 0.5);\n    vec2 g = spread(vec2(0.5), pixel * GRID_SIZE, block);\n    return plus(g.x, g.y);\n}\n\nGrid buildGrid(const bool useGrid) {\n    vec2 uv = frag.uv;\n    Grid grid;\n    grid.axis = axis(uv);\n    if (useGrid) grid.grid = texgrid(uv);\n    return grid;\n}\n\nGrid buildGrid() {return buildGrid(true);}\n\n//build triangle\nTriangle buildTriangle(vec2 pos1, vec2 pos2, vec2 pos3, const bool filled) {\n    Triangle trig;\n    trig.calculated = false;\n    trig.pos = vec2[3](pos1, pos2, pos3);\n    trig.filled = filled;\n    return trig;\n}\n\n//build quads\nQuads buildQuads(vec2 pos1, vec2 pos2, vec2 pos3, vec2 pos4, const bool filled) {\n    Quads q;\n    q.calculated = false;\n    q.pos = vec2[4](pos1, pos2, pos3, pos4);\n    q.filled = filled;\n    return q;\n}\n\nQuads buildParallelogram(vec2 center, vec2 pos1, vec2 pos2, const bool filled) {\n    vec2 pos3 = center * 2.0 - pos1;\n    vec2 pos4 = center * 2.0 - pos2;\n    return buildQuads(pos1, pos2, pos3, pos4, filled);\n}\n\nQuads buildRectangle(vec2 center, vec2 vertex, const bool filled) {\n    vec2 pos2 = vec2(vertex.x, center.y * 2.0 - vertex.y);\n    return buildParallelogram(center, vertex, pos2, filled);\n}\n\nQuads buildRectangle(vec2 center, float a, float b, const bool filled) {\n    vec2 pos1 = center + vec2(a, b) * 0.5;\n    return buildRectangle(center, pos1, filled);\n}\n\nQuads buildSquare(vec2 center, float a, const bool filled) {\n    return buildRectangle(center, a, a, filled);\n}\n\nCircle buildCircle(vec2 center, float r, const bool filled) {\n    Circle c;\n    c.calculated = false;\n    c.center = center;\n    c.r = r;\n    c.filled = filled;\n    return c;\n}\n        \n//calculate geometries\nvoid calc(inout Triangle trig, bool filled) {\n    if (filled) {\n    \ttrig.covering = rasterize(trig.pos);\n    } else {\n        vec2 pos1 = trig.pos[0];\n        vec2 pos2 = trig.pos[1];\n        vec2 pos3 = trig.pos[2];\n        trig.covering = rasterizeS(pos1, pos2);\n        trig.covering = plus(trig.covering, rasterizeS(pos2, pos3));\n        trig.covering = plus(trig.covering, rasterizeS(pos3, pos1));\n    }\n    //if (trig.filled == filled) trig.calculated = true;\n}\n\nvoid calc(inout Quads q, bool filled) {\n    vec2 pos1 = q.pos[0];\n    vec2 pos2 = q.pos[1];\n    vec2 pos3 = q.pos[2];\n    vec2 pos4 = q.pos[3];\n        \n    if (filled) {\n        q.covering = min(rasterize(pos1, pos2, pos3) + rasterize(pos1, pos3, pos4), 1.0);\n    } else {\n        q.covering = rasterizeS(pos1, pos2);\n        q.covering = plus(q.covering, rasterizeS(pos2, pos3));\n        q.covering = plus(q.covering, rasterizeS(pos3, pos4));\n        q.covering = plus(q.covering, rasterizeS(pos4, pos1));\n    }\n    //if (q.filled == filled) q.calculated = true;\n}\n\nvoid calc(inout Circle c, bool filled) {\n    float adj = circleIndex(frag.uv - c.center, c.r);\n    if (filled) {\n        c.covering = positive(adj, AAA_LEVEL * sum2(pixel) * c.r);\n    } else {\n        c.covering = spread(0.0, LINE_WIDE * sum2(pixel) * c.r, adj);\n    }\n}\n\nvoid calc(inout Triangle t) {\n    calc(t, t.filled);\n    t.calculated = true;\n}\n\nvoid calc(inout Quads q) {\n    calc(q, q.filled);\n    q.calculated = true;\n}\n\nvoid calc(inout Circle c) {\n    calc(c, c.filled);\n    c.calculated = true;\n}\n\n//draw objects in screen space\nvoid draw(vec3 color, float blend) {\t\t//blend color\n    frag.color = mix(frag.color, color, blend);\n}\n\nvoid draw(vec4 color) {\t\t\t\t\t\t//blend color\n    draw(color.rgb, color.a);\n}\n\nvoid draw(vec2 pos1, vec2 pos2, vec3 color) {//render a line\n    float adj = rasterizeS(pos1, pos2);\n    draw(color, adj);\n}\nvoid draw(in Grid g, vec3 gridcolor) {\n    draw(gridcolor, g.grid);\n    draw(vec3(1.0), g.axis);\n}\n\nvoid draw(in Triangle t, vec3 color) {\n    if (!t.calculated) calc(t);\n    draw(color, t.covering);\n}\n\nvoid draw(in Quads q, vec3 color) {\n    if (!q.calculated) calc(q);\n    draw(color, q.covering);\n}\n\nvoid draw(in Circle c, vec3 color) {\n    if (!c.calculated) calc(c);\n    draw(color, c.covering);\n}\n\nvoid draw(vec2 point, vec3 color) {\t\t\t//render a point\n    Circle c = buildCircle(point, LINE_WIDE * sum2(pixel), true);\n    draw(c, color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    //init screen objcet\n\tinit();\n    \n    //prepare for triangle\n    Grid grid = buildGrid();\n    Circle c = buildCircle(vec2(-1.0, 0.0), 1.0, false);\n    \n    float time = 0.6 * iTime;\n    vec2 p0 = vec2(cos(time), sin(time));\n    vec2 p = p0 + c.center;\n    \n    Triangle t = buildTriangle(c.center, p, vec2(p.x, 0.0), true);\n    draw(t, Yellow);\n    \n    draw(grid, vec3(0.2, 0.6, 0.8));\n    draw(c, vec3(0.8));\n    \n    draw(p, c.center, vec3(0.8));\n    \n    //sine function\n    Circle s1 = buildCircle(vec2(0.0, p.y), 0.1, false);\n    draw(p, vec2(0.0, p.y), YALV);\n    draw(s1, YALV);\n    draw(YALV, func(sin(frag.uv.x + time)) * step(0.0, frag.uv.x));\n    \n    //cosine function\n    Circle c1 = buildCircle(vec2(0.0, p0.x), 0.1, false);\n    Circle c2 = buildCircle(vec2(0.0, -1.0), p.x, false);\n    calc(c2);\n    c2.covering *= max(sum2(-sign(frag.uv - c2.center)), 0.0);\n    draw(vec2(0.0, p.x - 1.0), vec2(0.0, p0.x), Red);\n    draw(p, vec2(p.x, -1.0), Red);\n    draw(c1, Red);\n    draw(c2, Red);\n    draw(Red, func(cos(frag.uv.x + time)) * step(0.0, frag.uv.x));\n    \n    Circle pc = buildCircle(p, 0.1, false);\n    draw(pc, Blue);\n\n    // Output to screen\n    fragColor = vec4(frag.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}