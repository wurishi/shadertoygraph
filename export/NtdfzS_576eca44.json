{"ver":"0.1","info":{"id":"NtdfzS","date":"1663424156","viewed":46,"name":"hw_1&2","username":"Ruslan_Maslyuk","description":"hw_1, hw_2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tank"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS   90\n#define MAX_DIST    30.0\n#define  eye     vec3 ( -2.0, 2.5, 15.0)\n#define  light   vec3  ( -2.0, 1.0, 12.0 )\n#define EPS 0.0001\n\nconst vec3 lightColor = vec3 ( 1.0 );\nconst float gamma = 4.0;\nconst float pi = 3.1415926;\nconst float FDiel = 0.02;\n\n\n\n\nmat3 rotateX(float val)\n{\n    float c = cos(val);\n    float s = sin(val);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float val)\n{\n    float c = cos(val);\n    float s = sin(val);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\nmat3 rotateZ(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat lengthInf ( in vec2 p )\n{\n    return max ( abs ( p.x ), abs ( p.y ) );\n}\n\nfloat length1 ( in vec2 p )\n{\n    return abs ( p.x ) + abs ( p.y );\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( abs(p.x), 8.0 ) + pow ( abs(p.y), 8.0 ), 1.0 / 8.0 );\n}\n\nfloat dSphere ( vec3 p, in vec3 center, in float radius )\n{\n\treturn length (p - center) - 1.0 * radius;\n} \n\nfloat dTorus_l1( vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat dTorus_LONG( vec3 p, vec2 t,  in vec3 h )\n{\n  vec3 q = p - clamp( p, -h, h );\n  return dTorus_l1(q, t);\n}\n\nfloat dBoxRounded ( in vec3 pos, in vec3 size, float r)\n{\n    vec3 q = abs(pos) - size;\n\n    return length(max(q,0.0)) - r + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dTrapezoidRounded( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float r )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) ) - r;\n}\n\nfloat dTrapezoidPrism ( in vec3 p, in vec3 a, in vec3 b, in float ra, float rb, float r, in float h)\n{\n    float d = dTrapezoidRounded(p.xy, a.xy, b.xy, ra, rb, r);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat dBoxRounded_crooked ( in vec3 pos, in vec3 size, float r, in bool up)\n{\n    const float k = 0.5; // or some other amount\n    float c = cos(k*pos.x);\n    float s = sin(k*pos.x);\n    mat2  m;\n    if (up)\n        m = mat2(c,s,-s,c);\n    else\n        m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy,pos.z);\n    \n    return dBoxRounded(q, size, r);\n}\n\n\nfloat dCylinder ( in vec3 pos, in vec3 a, in vec3 b, in float r, in mat3 m )\n{\n   \n    vec3  ba   = b  - a;\n    vec3  pa   = pos - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x    = length(pa*baba-ba*paba) - r*baba;\n    float y   = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\nfloat dTrack (in vec3 pos, in vec3 center_0 ,in vec3 a_0, in vec3 b_0, in float r, in mat3 m)\n{\n    float k = 0.3;\n    vec3 q = pos;\n    vec3 move_y_1 = vec3(0.0, 2.0, 0.0);\n    vec3 move_z_1 = vec3(0.0, 0.0, 0.45 + 0.15);\n       return \n            \n        min(\n            min(\n                                min(\n                                    min(\n                                        min(\n                                            min(\n                                                min (\n                                                    dCylinder(q, center_0 + a_0, center_0 + b_0, 1.0, m), \n                                                    dCylinder(q, center_0 + a_0 + move_y_1,center_0 + b_0 + move_y_1, 1.0, m)\n                                                    ),\n                                                dCylinder(q, center_0 + a_0 + 2.0 * move_y_1,center_0 + b_0 + 2.0 * move_y_1, 1.0, m)\n                                                ),\n                                            dCylinder(q, center_0 + a_0 + 3.0 * move_y_1,center_0 + b_0 + 3.0 * move_y_1, 1.0, m)\n                                            ),\n                                        dCylinder(q, center_0 + a_0 + move_z_1, center_0 + b_0 + move_z_1, 1.0, m)\n                                        ),\n                                    dCylinder(q, center_0 + a_0 + move_y_1 + move_z_1, center_0 + b_0 + move_y_1 + move_z_1, 1.0, m)\n                                ),\n                                dCylinder(q, center_0 + a_0 + 2.0 * move_y_1 + move_z_1, center_0 + b_0 + 2.0 * move_y_1 + move_z_1, 1.0, m)\n                            ),\n                            dCylinder(q, center_0 + a_0 + 3.0 * move_y_1 +  move_z_1, center_0 + b_0 + 3.0 *move_y_1 +  move_z_1, 1.0, m)\n                        );\n}\n\n\nfloat dCat (in vec3 q, in vec3 center_0 ,in vec3 a_0, in vec3 b_0, in float r, in mat3 m)\n{\n    float k = 0.3;\n    vec3 move_y_1 = vec3(0.0, 2.0, 0.0);\n    vec3 move_z_1 = vec3(0.0, 0.0, 0.45 + 0.15);\n    return \n        opSmoothUnion(\n            opSmoothUnion( \n               min(\n                    dBoxRounded(q - vec3(1.1,3.0, 1.0 - 0.3 - 0.45 ) - center_0, vec3(0.0,3.5,0.6), 0.1),\n                    dBoxRounded(q - vec3(-1.1,3.0, 1.0 - 0.3 - 0.45 ) - center_0, vec3(0.0,3.5,0.6), 0.1)\n                ),\n                dBoxRounded_crooked(q - vec3(0.0,7.0 + 0.35, 1.0 - 0.3 - 0.45 ) - center_0, vec3(1.2,(4.4 - 3.7)/4.0,0.6), 0.05, true), 0.5\n            ),\n            dBoxRounded_crooked(q - vec3(0.0, -1.0 - 0.35, 1.0 - 0.3 - 0.45 ) - center_0, vec3(1.2,(4.4 - 3.7)/4.0,0.6), 0.05, false), 0.5\n        );\n}\n\nfloat dTank_body (in vec3 q)\n{\n    return \n        min (\n            //min (\n               // min (\n                dTrapezoidPrism (q - vec3 (0.0,0.0,0.0 + 2.5 + 0.45/2.0), - vec3(0.45, 0.5 - 4.0, 0.0), - vec3(0.45-1.15 * sqrt(3.0/4.0) * 2.0, 0.5 - 4.0, 0.0), 4.6 - 1.15/2.0 - 0.3, 4.6, 0.01, 1.65),\n                    //dBoxRounded (rotateZ(1.0471975512) * (q - vec3(0.45, -0.5, 0.0 + 2.5 + 0.45/2.0)), vec3(0.0, 1.15, 1.6), 0.01),\n                    dBoxRounded (q - vec3(2.0, -1.6 + 4.0, 0.0 + 2.5 + 0.45/2.0), vec3(0.6, 4.05, 2.8), 0.01)\n            //    ),\n                //dBoxRounded (q - vec3(2.4, -0.5 + 4.0, 0.0 + 2.5 + 0.45/2.0), vec3(0.0, 4.6, 2.8), 0.01)\n            //),\n            //dBoxRounded ((q - vec3(0.45-1.15 * sqrt(3.0/4.0), -0.5 + 4.0 + 1.15/2.0 - 0.3, 0.0 + 2.5 + 0.45/2.0)), vec3(0.0, 4.6 - 1.15/2.0 - 0.3, 1.6), 0.01)\n        );\n        //dBoxRounded (rotateZ(-1.0471975512) * (q - vec3(0.45, 0.0 + 2.0 * (4.6 - 1.15/2.0 - 0.3), 0.0 + 2.5 + 0.45/2.0)), vec3(0.0, 1.15, 1.6), 0.01)\n                \n    \n    //return dTrapezoidRounded (q.xy, - vec2(0.45-1.15 * 0.5, 0.5 - 4.0), - vec2(0.45-1.15 * sqrt(3.0/4.0) * 2.0, 0.5 - 4.0), 4.6 - 1.15/2.0 - 0.3, 4.6, 0.01);\n}\n\nfloat dTank_canon(in vec3 q)\n{\n    float s = .25*sin(iTime);\n    return \n    min(\n        dTorus_LONG(q - vec3 ((2.6 + 4.0)/2.0 +0.2, 4.8 + 1.3, 0.0 + 2.5 + 0.45/2.0), vec2(0.4, 0.1), vec3( 0.0, 0.8,0.0)),\n        dTorus_LONG(q - vec3 ((2.6 + 4.0)/2.0 +0.2, 4.8 + 1.3 + 0.6 + 3.5, 0.0 + 2.5 + 0.45/2.0), vec2(0.2, 0.03), vec3( 0.0, 3.5,0.0))\n    );\n}\n\nfloat dTank_tower (in vec3 q)\n{\n    float s = .25*sin(iTime);\n    return \n  min(    //max(\n    min(\n    opSmoothUnion(\n        opSmoothUnion(\n            dCylinder(q,  vec3 (2.6, -1.4 + 4.0, 0.0 + 2.5 + 0.45/2.0), vec3 (4.0, -1.4 + 4.0, 0.0 + 2.5 + 0.45/2.0), 1.8, mat3(0))\n            ,dBoxRounded((q - vec3 ((2.6 + 4.0)/2.0 +0.1, -1.4 + 4.0 + 1.5, 0.0 + 2.5 + 0.45/2.0)), vec3((-2.6 + 4.0)/2.0 - 0.2, (-2.6 + 4.0)/2.0, 1.8 * 0.75), 0.1), 1.0\n        ),\n        dCylinder( q,  vec3 (4.0, -1.7 + 4.0, 0.0 + 2.5 + 0.45/2.0 + 0.3),  vec3 (4.4, -1.7 + 4.0, 0.0 + 2.5 + 0.45/2.0  + 0.3), 0.4, mat3(0)), .03\n     ),\n     dBoxRounded((q - vec3 ((2.6 + 4.0)/2.0 +0.2, -1.4 + 4.0 + 1.5 + (-2.6 + 4.0)/2.0 - 0.2 + 0.5, 0.0 + 2.5 + 0.45/2.0)), vec3((-2.6 + 4.0)/2.0 - 0.2, 0.1, 1.8 * 0.75), 0.01)\n ),\n dTank_canon ( q));\n            \n        //);\n\n}\n\nfloat sdf (in vec3 p, in mat3 m)\n{\n    float k = 0.3;\n    //p = rotateZ(3.14/2.0)*p;\n    vec3 q = m * p;\n    \n\t//return min(\n     //           dSphere(q, vec3(0.49, -0.35, -0.2), 2.0),\n      //          dSphere(q, vec3(0.49, -0.35, 0.2), 2.0)\n      //      );\nreturn\n    min(dTank_body(q),\n        dTank_tower(q)\n    ) - 0.02;\n          //return dBoxRounded(q, vec3(1.0,1.0,1.0), 1.0);\n    \n               \n}\n\nfloat sdf_cat (in vec3 p, in mat3 m)\n{\n    float k = 0.3;\n    //p = rotateZ(3.14/2.0)*p;\n    vec3 q = m * p;\n    \n\t//return min(\n     //           dSphere(q, vec3(0.49, -0.35, -0.2), 2.0),\n      //          dSphere(q, vec3(0.49, -0.35, 0.2), 2.0)\n      //      );\nreturn\n    \n            min(\n                min(    \n                    min (\n                        dTrack(q, vec3(0,0,0),  vec3(0.0, 0.0, -0.15),  vec3(0.0, 0.0, 0.15), 1.0, m),\n                        dTrack(q, vec3(0,0,5),  vec3(0.0, 0.0, -0.15),  vec3(0.0, 0.0, 0.15), 1.0, m)\n                    ),\n                    dCat(q, vec3(0.0,0.0,0.0),  vec3(0.0, 0.0, -0.15),  vec3(0.0, 0.0, 0.15), 1.0, m)\n                ),\n                dCat(q, vec3(0.0,0.0,5.0),  vec3(0.0, 0.0, -0.15),  vec3(0.0, 0.0, 0.15), 1.0, m)\n      \n    ) - 0.01;\n          //return dBoxRounded(q, vec3(1.0,1.0,1.0), 1.0);\n    \n               \n}\nvec3 trace ( vec3 from, vec3 dir, out bool hit_tank, out bool hit_cat, in mat3 m )\n{\n    vec3     p         = from;\n    float    totalDist = 0.0;\n    \n    hit_tank = false;\n    hit_cat = false;\n    \n    for (int steps = 0; steps < MAX_ITERS; steps++ )\n    {\n        float    dist_tank = 0.8 * abs(sdf (p, m));\n        float    dist_cat = 0.8 * abs(sdf_cat (p, m));\n        if ( dist_tank < 0.01 && dist_cat >= 0.01)\n        {\n            hit_tank = true;\n            break;\n        }\n        if ( dist_tank >= 0.01 && dist_cat < 0.01)\n        {\n            hit_cat = true;\n            break;\n        }\n        float dist = min(dist_tank, dist_cat);\n        totalDist += dist;\n        \n        if ( totalDist > MAX_DIST )\n            break;\n            \n        p += dist * dir;\n    }\n    \n    return p;\n}\n\n\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max(d * 0.5, EPS);\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 generateNormal_cat ( vec3 z, float d, in mat3 m )\n{\n    float e   = max(d * 0.5, EPS);\n    float dx1 = sdf_cat(z + vec3(e, 0, 0), m);\n    float dx2 = sdf_cat(z - vec3(e, 0, 0), m);\n    float dy1 = sdf_cat(z + vec3(0, e, 0), m);\n    float dy2 = sdf_cat(z - vec3(0, e, 0), m);\n    float dz1 = sdf_cat(z + vec3(0, 0, e), m);\n    float dz2 = sdf_cat(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\nfloat ambientOcclusion(in vec3 pos, in vec3 normal, mat3 m)\n{\n    float occ = .0;\n    float sca = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = .01+.12*float(i)/4.;\n        float d = sdf(pos+h*normal, m);\n        occ += (h-d)*sca;\n        sca *= .95;\n        if (occ > .35) \n            break;\n    }\n    return clamp(1.-3.*occ, 0., 1.)*(.5+.5*normal.y);\n}\n\nfloat ambientOcclusion_cat(in vec3 pos, in vec3 normal, mat3 m)\n{\n    float occ = .0;\n    float sca = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = .01+.12*float(i)/4.;\n        float d = sdf_cat(pos+h*normal, m);\n        occ += (h-d)*sca;\n        sca *= .95;\n        if (occ > .35) \n            break;\n    }\n    return clamp(1.-3.*occ, 0., 1.)*(.5+.5*normal.y);\n}\n\nconst vec3 lum = vec3 ( 0.2126, 0.7152, 0.0722 );\n\nfloat height ( in vec2 tx )\n{\n    return dot ( texture ( iChannel0, tx ).rgb, lum );\n}\nfloat height1 ( in vec2 tx )\n{\n    return dot ( texture ( iChannel1, tx ).rgb, lum );\n}\nvec3 bump ( in vec2 tx )\n{\n    float v  = height ( tx );\n    float vx = height ( vec2 ( tx.x, tx.y ) );\n    float vy = height ( vec2 ( tx.x, tx.y) );\n    \n    return normalize ( vec3 (  vx - v, vy - v, 0.5 ) );\n}\nvec3 bump1 ( in vec2 tx )\n{\n    float v  = height1 ( tx );\n    float vx = height1 ( vec2 ( tx.x, tx.y ) );\n    float vy = height1 ( vec2 ( tx.x, tx.y ) );\n    \n    return normalize ( vec3 (  vx - v, vy - v, 0.5 ) );\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n    \n\treturn triW / (triW.x + triW.y + triW.z);\n\n}\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\nproduct = clamp ( product, 0.0, 1.0 ); // saturate\nreturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\n\nfloat D_blinn(in float roughness, in float NdH)\n{\nfloat m = roughness * roughness;\nfloat m2 = m * m; float n = 2.0 / m2 - 2.0;\nreturn (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\nfloat D_beckmann ( in float roughness, in float NdH )\n{\nfloat m = roughness * roughness;\nfloat m2 = m * m;\nfloat NdH2 = NdH * NdH;\nreturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\nfloat m = roughness * roughness;\nfloat m2 = m * m;\nfloat NdH2 = NdH * NdH;\nfloat d = (m2 - 1.0) * NdH2 + 1.0;\nreturn m2 / (pi * d * d);\n}\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\nfloat k = roughness * roughness * 0.5;\nfloat V = nv * (1.0 - k) + k;\nfloat L = nl * (1.0 - k) + k;\nreturn 0.25 / (V * L);\n}\n\nvec3 cookTorrance ( in float nl, in float nv, in float nh, in float vh, in vec3 f0, in float roughness )\n{\nfloat D = D_GGX ( roughness, nh );\nfloat G = G_schlick (roughness, nl, nv );\nreturn f0 * D * G;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    bool hit_tank;\n    bool hit_cat;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 m = rotateX(6.0 * mouse.x) * rotateY(6.0 * mouse.y);\n    //m = rotateX(0.0)*rotateY(0.0);\n    vec2 scale = 35.0 * iResolution.xy / max (iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2(0.5,0.5));\n    vec3 dir = normalize( vec3(uv, 0) - eye);\n    vec4 color = vec4(0,0,0,1);\n    vec3 p = trace (eye, dir, hit_tank, hit_cat, m);\n    \n    if (hit_tank)\n    {\n        \n        //p = rotateZ(3.14/2.0)*p;\n        vec3 n = generateNormal(p, 0.001, m);\n        vec3 tx = getTriplanarWeights (n);\n        vec3 q = m*p;\n        vec4 cx = texture (iChannel0, q.yz);\n        vec4 cy = texture (iChannel0, q.zx);\n        vec4 cz = texture (iChannel0, q.xy);\n        vec3 base = vec4(cx*tx.x+cy*tx.y+cz*tx.z).xyz;\n        base = pow ( base, vec3 ( gamma ) );\n        \n        vec3 l = normalize(light - p);\n        vec3 v = normalize(eye - p);\n        \n        //float roughness  = texture ( iChannel0, q.yz/scale+0.5).x;\n        //float metallness = texture ( iChannel0, q.yz/scale+0.5).x;\n       \n        //n = bump((q).xy);\n        vec3 h = normalize((l + v));\n        float nl = max(0.0, dot(n, l));\n        float nv = max(0.0, dot(n, v));\n        float hn = max(0.0, dot(h, n));\n        float hl = max(0.0, dot(h, l));\n        float vh = max(0.0, dot(h, v));\n        float sp = pow(hn, 10.0);\n        color = 0.7 * vec4(nl) + 0.5 * sp * vec4(1.0,0.0,0.0,1);\n        //vec3 F0 = mix ( vec3 ( FDiel ), base, metallness );\n        //vec3 specFresnel = fresnel ( F0, nv );\n        //vec3 spec = cookTorrance ( nl, nv, hn, vh, specFresnel, roughness ) * nl / max ( 0.001, 4.0 * nl * nv);\n        //vec3 diff = (vec3(1.0) - specFresnel) * nl / pi;\n        //color = pow ( vec4 ( ( diff * mix ( base, vec3(0.0), metallness) + spec )* lightColor, 1.0 ), vec4 ( 1.0 / gamma ) );\n        //color = 0.33*vec4(235.0/255.0, 225.0/255.0, 1.0/255.0, 1)*vec4(nl) + 0.33 * sp * vec4(235.0/255.0, 225.0/255.0, 1.0/255.0, 1) \n        //    + 0.33*vec4(235.0/255.0, 225.0/255.0, 1.0/255.0, 1)*ambientOcclusion(p,n,m);\n        //color = pow ( vec4 ( ( diff * mix ( base, vec3(0.0), metallness) + spec )\n        //    * lightColor * 1.0, 1.0 ), vec4 ( 1.0 / gamma ) );\n        color*=(tx.x * cx + tx.y * cy + tx.z * cz);\n    }\n    else if (hit_cat)\n    {\n        \n       vec3 base = vec3 ( 143.0/255.0, 67.0/255.0, 0 );\n            base = pow ( base, vec3 ( gamma ) );\n            vec3 l = normalize(light - p);\n            vec3 v = normalize(eye - p);\n            vec3 q  =  m* p;\n            float roughness = texture ( iChannel1, q.yz/scale+0.5).x;\n            float metallness = texture ( iChannel1, q.yz/scale+0.5 ).x;\n            vec3 n = bump((q).xy);\n            \n            vec3 h = normalize(l + v);\n            \n            float nv = max ( 0.0, dot ( n, v ));\n            float nl = max ( 0.0, dot ( n, l ));\n            float nh = max ( 0.0, dot ( n, h ));\n            float hl = max ( 0.0, dot ( h, l ));\n            float vh = max ( 0.0, dot ( v, h ));\n            \n            vec3 F0 = mix ( vec3 ( FDiel ), base, metallness );\n            vec3 specFresnel = fresnel ( F0, nv );\n            vec3 spec = cookTorrance ( nl, nv, nh, vh, specFresnel, roughness ) * nl /\n            max ( 0.001, 4.0 * nl * nv );\n            vec3 diff = (vec3(1.0) - specFresnel) * nl / pi;\n            color = pow ( vec4 ( ( diff * mix ( base, vec3(0.0), metallness) + spec )\n            * lightColor, 1.0 ), vec4 ( 1.0 / gamma ) );\n           // color = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 1, 0, 0, 1 );\n    }\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}