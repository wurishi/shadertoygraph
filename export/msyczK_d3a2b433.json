{"ver":"0.1","info":{"id":"msyczK","date":"1696359826","viewed":77,"name":"03. Path","username":"Ladus","description":"Inktober 2023 Day 3","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["path","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat sideBarMask(float sideBarFromLeft, float barWidth, float tileBorder, vec2 globalSpace) {\n    float sideBarsMask = smoothstep(sideBarFromLeft-barWidth,sideBarFromLeft+tileBorder-barWidth,globalSpace.x);\n    sideBarsMask += smoothstep(sideBarFromLeft+tileBorder+barWidth,sideBarFromLeft+barWidth,globalSpace.x);\n    sideBarsMask -= 1.;\n    \n    return sideBarsMask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float loopingTime = fract(iTime / 5.);\n    float movementSpeed = 3.;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= .3;\n    \n    // Multiple the screenspace to allow for multiple cells\n    vec2 globalSpace = uv * 6.;\n    \n    // Morph global space to create approaching path\n    globalSpace.y = pow(globalSpace.y,2.0);\n    globalSpace.x *= (globalSpace.y*0.03+(sin((5.+globalSpace.y)*0.03)*3.)+0.1);\n    \n    // Animate the y axis to move forward\n    vec2 animatedGlobalSpace = globalSpace;\n    animatedGlobalSpace.y += loopingTime*2.*movementSpeed;\n    \n    vec2 gridId = floor(animatedGlobalSpace);\n    \n    // Offset the odd rows by half to form a tile pattern\n    float oddRows = floor(fract((animatedGlobalSpace.y)/2.)*2.);\n    vec2 offsetGlobalSpace = animatedGlobalSpace;\n    offsetGlobalSpace.x += oddRows/2.;\n    \n    vec2 gridUv = fract(offsetGlobalSpace);\n\n\n    //// Tile params\n    float tileBorder = 0.05;\n    float barWidth = 0.1;\n    float leftSidebarX = 0.85;\n    float rightSidebarX = 4.1;\n    \n    //// Create side bars        \n    float sideBarsMask = sideBarMask(leftSidebarX, barWidth, tileBorder, animatedGlobalSpace);\n    \n    sideBarsMask += sideBarMask(rightSidebarX, barWidth, tileBorder, animatedGlobalSpace);\n    \n\n    //// Create floor tile\n    float tiles = 0.0;\n    \n    tiles = smoothstep(0.,tileBorder, gridUv.x) *\n        smoothstep(0.,tileBorder, gridUv.y) *\n        smoothstep(0.,tileBorder, 1.-gridUv.x) *\n        smoothstep(0.,tileBorder, 1.-gridUv.y);\n    \n    float pathMask = smoothstep(1.+tileBorder,1.,animatedGlobalSpace.x) +\n        smoothstep(4.-tileBorder,4.,animatedGlobalSpace.x);\n    \n    // Invert mask\n    pathMask = mix(1.,0.,pathMask);\n    \n    float tilesMask = (tiles * pathMask);\n    \n    float value = tilesMask;\n\n    \n    //// Use masks to generate final colored image\n    // Add color to sidebar\n    vec3 color = sideBarsMask * hsb2rgb(vec3(0.2,1.,1.));\n    \n    // Add animated color to the tiles using the gridIds\n    color += tilesMask * hsb2rgb(vec3(fract(gridId.y/6.)+(loopingTime*1.),1.,1.));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}