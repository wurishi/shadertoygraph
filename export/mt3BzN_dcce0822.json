{"ver":"0.1","info":{"id":"mt3BzN","date":"1701013850","viewed":265,"name":"Plain Waves","username":"phbbt","description":"Just playing around and introducing myself to writing shaders. The code can handle arbitrary 2d -> 1d functions, with restrictions listed in code.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat rotationSpeed = 0.1;\nfloat gridWidth = 0.025;\n\n// f should take a 2d coordinate and return a value between 0 and `functionMax`\n// if the magnitude of the gradient is greater than the viewing angle there may be visual \n// artifacts\n// The visible coordinates are approximately [-scale, scale]\n\n// offset 5x modulated 2d sin\n/*\nfloat scale = 16.0;\nfloat functionMax = 1.0;\nfloat f(vec2 xy) {\n    float z = (sin(3.14*4.0*sin(iTime - 0.2*distance(xy, vec2(-1,0)))) + 1.0)/2.0 +\n              (sin(3.14*4.0*sin(iTime - 0.2 - 0.2*distance(xy, vec2(+0,0)))) + 1.0)/2.0 +\n              (sin(3.14*4.0*sin(iTime - 0.4 - 0.2*distance(xy, vec2(+1,0)))) + 1.0)/2.0 +\n              (sin(3.14*4.0*sin(iTime - 0.6 - 0.2*distance(xy, vec2(+2,0)))) + 1.0)/2.0 +\n              (sin(3.14*4.0*sin(iTime - 0.8 - 0.2*distance(xy, vec2(+3,0)))) + 1.0)/2.0;\n    z/=5.0;\n    return z;\n}\n*/\n\n// modulated 2d sin\nfloat scale = 10.0;\nfloat functionMax = 1.0;\nfloat f(vec2 xy) {\n    float z = (sin(3.14*4.0*sin(iTime - 0.2*length(xy))) + 1.0)/2.0;\n    return z;\n}\n\n/*\n// 2d sin\nfloat scale = 8.0;\nfloat functionMax = 1.0;\nfloat f(vec2 xy) {\n    float z = (sin(length(xy*2.0) - iTime) + 1.0)/2.0;\n    return z;\n}\n\n// static 2d gaussian\nfloat scale = 2.0;\nfloat functionMax = 1.0;\nfloat f(vec2 xy) {\n    float z = exp(-length(xy)*length(xy));\n    return z;\n}\n*/\n\n// step is theoretically the difference in pos between two adjacent pixels, if you\n// want to anti-alias a hard edge. Practically, it's linear blur radius\nfloat lineAlpha(float pos, float step_, float lineWidth) {\n    pos = fract(pos);\n    float scale = step_;\n    float rem = pos + step_ - 1.0;\n    if (rem > 0.0) {\n        step_ = rem;\n        pos = 0.0;\n    }\n        \n    return min(max(lineWidth - pos, 0.0), step_) / scale;\n}\n\n// draw grid with blur\nfloat lookupColor(vec2 xy, float gridScale) {\n    float lineWidth = 0.1;\n    xy /= gridWidth*gridScale;\n    \n    // theoretically, the step value should be determined by the slope at point of\n    // intersection. Because it's fixed instead the result is a flat look, as if this\n    // was a texture. This can also lead to aliasing.\n    float step_ = 0.1;\n\n    float lineAlphaX = lineAlpha(xy.x, step_, lineWidth);\n    float lineAlphaY = lineAlpha(xy.y, step_, lineWidth);\n    return lineAlphaX * (1.0-lineAlphaY) + lineAlphaY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = scale*(fragCoord - iResolution.xy / 2.0)/iResolution.y;\n    \n    vec3 camera = vec3(sin(iTime * rotationSpeed),1.5,cos(iTime * rotationSpeed));\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n\n    vec3 lookDir = lookAt - camera;\n    vec3 cameraX = normalize(cross(lookDir, up));\n    vec3 cameraY = normalize(cross(cameraX, lookDir));\n    \n    // scale camera location to make sure the view plane doesn't clip the function\n    camera = camera * (functionMax + 0.5*scale*cameraY.y) / camera.y;\n    \n    \n    // binary search based zero finding for function assuming function is non-negative\n    // this potentially skips over the first intersection\n    // works best if the slope of the function is less than the slope of look dir\n    \n    // orthographic perspective using lookdir\n    vec3 uvInWorldSpace = camera + uv.x*cameraX + uv.y*cameraY;\n    float maxStep = uvInWorldSpace.y / lookDir.y;\n    vec3 step_ = maxStep * lookDir * 0.5;\n    vec3 pos = uvInWorldSpace;\n\n    // lower numbers are 'blocky', higher is slower, but smooth.\n    // 12 or so looks completely smooth\n    int depth = 12;\n    \n    for (int i = 0; i < depth; i++) {\n        \n        if (f(pos.xz) - pos.y > 0.0) {\n            pos += step_;\n        } else {\n            pos -= step_;\n        }\n        step_ *= 0.5;\n    }\n    \n    \n    fragColor = vec4(lookupColor(pos.xz, scale));\n    // fragColor = vec4(pos.y);\n    fragColor = (pos.y/functionMax*0.8 + 0.2)*vec4(lookupColor(pos.xz, scale));\n}","name":"Image","description":"","type":"image"}]}