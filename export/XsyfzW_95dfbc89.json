{"ver":"0.1","info":{"id":"XsyfzW","date":"1527709698","viewed":978,"name":"Vorticity field 3D","username":"asiJa","description":"define velocity field in fluid as intersection of zero-surfaces of two scalar functions - inspired by Schrodinger smoke  [url]http://page.math.tu-berlin.de/~chern/projects/SchrodingersSmoke/[/url] but heavily simplified","likes":52,"published":1,"flags":0,"usePreview":1,"tags":["fluid","vortex","mushroom","nuke","toroidal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n// How I Learned to Stop Worrying and Love the Bomb\n\nThe idea is to express velocity field which rotate around vortex filament (in this case circle) using \ntwo scalar wavefunctions (although may be complex in general). \nVortex filament (core) is 1D curve produced by intersection of 2D surfaces for which psi1==0 and psi2==0\n\nv = ( psi1*grad(psi2) + psi2*grad(psi1) )/(psi1|**2 + |psi2|**2 + eps**2)\n\nReferences:\n * http://dl.acm.org/citation.cfm?doid=2601097.2601171\n   Smoke Rings from Smoke\n   10.1145/2601097.2601171\n\n * http://page.math.tu-berlin.de/~chern/projects/SchrodingersSmoke/\n * https://en.wikipedia.org/wiki/Vortex\n * https://en.wikipedia.org/wiki/Vector_potential\n\nbasically we define velocity field as rotation of some vector potential\nresp. nodal lines defined by two scalar functions\n\n/// NOTE: this is actually overkill, since advection by \ntoroidal vortex can be expressed analytically instead of numerical \nintegration of motion in velocity field. However, this way we can in \nprinciple do velocity field from any scalar function (e.g. from wrap noise or 3D texture)\nalthough it would be very costly\n\n*/\n\n\nvec4 psi1( vec3 p, float t ){\n    float val  = dot(p.xy,p.xy)-1.0;\n    vec3  grad = vec3( 2.0*p.xy, 0.0 );\n    return vec4(grad,val);\n}\n\nvec4 psi2( vec3 p, float t ){\n\t//float val  = p.z+fract(iTime*0.1)*2.0-1.0;\n    float val  = p.z-t;\n    vec3  grad = vec3(0.0,0.0,1.0);\n    return vec4(grad,val);\n}\n\nvec3 getVelocity( vec3 p, float t ){\n\tvec4 f1 = psi1(p, t);\n    vec4 f2 = psi2(p, t);    \n    //  v = ( psi1*grad(psi2) - psi2*grad(psi1) )/(psi1|**2 + |psi2|**2 + eps**2)\n    vec3 v  =  f1.xyz*f2.w - f2.xyz*f1.w;  // cross product\n    return v/( dot(v,v) + 0.01);           // normalize, + small safety epsilon\n}\n\nvec3 move(vec3 p,float dt, float t){\n\treturn p + getVelocity(p,t)*dt;\n}\n\n\nfloat Func( in vec3 p ){\n   \n    \n    //float t=cos(iTime*0.5);\n    float t=fract(-iTime*0.1);\n    \n    // move several iteration in the velocity field\n    float dt = -0.2*(1.0-t);\n    for(int i=0; i<16; i++){\n        p=move(p,dt, t);\n    };\n    \n    // 3D texture to be distorted\n/*\n    vec3 sv = sin(p*5.0);\n    return (  0.3/(1.0+dot(sv.yz,sv.yz)*16.0) \n           + 0.3/(1.0+dot(sv.xz,sv.xz)*16.0) \n           - 0.5/(1.0+dot(sv.xy,sv.xy)*16.0)\n           )\n        *(1.0-smoothstep( 0.7, 0.9, dot(p.xy,p.xy) ) \n*/        \n        \n/*\n        vec3 tex = (texture(iChannel0,p*0.17)-0.5).rgb;\n        return 0.1/(1.0 + 64.0*dot(tex.xy,tex.xy) )\n            *(1.0-smoothstep( 0.7, 1.2, dot(p.xy,p.xy) ) );\n*/\n    \n    p.z += t*1.5+0.5;    \n        \n    //vec3 tex = (texture(iChannel0,p*0.15)-0.5).rgb;\n    vec3 tex = 0.3*(texture(iChannel0,p*0.35).zxyw-2.0*texture(iChannel0,p*0.25)).rgb;\n        return 0.2/(1.0 + 100.0*dot(tex.xy,tex.xy) )\n            *(1.0-smoothstep( 1.3, 2.0, dot(p,p) ) );\n\n\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ){\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0,-1.0);\n    float  sh =  sqrt( h );\n\treturn vec2( -b-sh, -b+sh);\n}\n\nvec2 rot(in vec2 v,in vec2 u){ return vec2(v.x*u.x-v.y*u.y,v.x*u.y+v.y*u.x); }\n\n\nvoid cam(vec2 angs, inout vec3 ro, inout vec3 rd){\n    vec4 cam   = vec4( cos(angs), sin(angs) );\n    ro.yz = rot(ro.yz,cam.yw);\n    rd.yz = rot(rd.yz,cam.yw);\n    ro.xy = rot(ro.xy,cam.xz);\n    rd.xy = rot(rd.xy,cam.xz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2  p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    p.y += 0.3;\n   \n    /*\n\t// 2D DEBUG \n    vec3 pp = vec3(p.x, 0.0, p.y);\n    \n    float dt = 0.05;\n    for(int i=0; i<16; i++){\n        pp=move(pp,dt);\n    };\n    \n    fragColor =  vec4( sin(pp*20.0) ,1.0 );\n    */\n    \n    \n\tvec3 ro = vec3(0.0, 4.0, 0.0 );\n\tvec3 rd = normalize( vec3(p.x,-2.0,p.y) );\n    \n    /*\n    float phi   = iMouse.x*0.05 + iTime * 0.3;\n    float theta = iMouse.y*0.05;\n    vec2 camX = vec2( cos(phi), sin(phi) );\n    vec2 camY = vec2( cos(theta), sin(theta) );\n    ro.yz = rot(ro.yz,camY);\n    rd.yz = rot(rd.yz,camY);\n    ro.xy = rot(ro.xy,camX);\n    rd.xy = rot(rd.xy,camX);\n\t*/    \n\n    cam( vec2( iMouse.x*0.05+iTime*0.3,iMouse.y*0.05),ro,rd);\n    \n\n    \n    vec4 sph = vec4( vec3(0.0,0.0,0.0), 2.5 );\n    \n    vec2 tt = sphIntersect( ro, rd, sph );\n    \n    //vec3 mclr = vec3( 0.2,0.5,0.5 );\n    \n    vec4 clrsum = vec4(0.0);\n    float t = tt.x;\n    float it = 0.0;\n    if( tt.x>0.0 ){\n        for(int i=0; i<100; i++){\n            vec3 pos = ro + t*rd;\n        \tfloat f = Func( pos )*5.0;\n\n            \n            vec3 mclr = (f>0.0)?vec3(0.0,0.5,1.0):vec3(1.0,0.5,0.0);\n            \n            float dens = f*f;\n           \n\t\t\t// --- nonuniform walk occluding\n            float dt    = 0.05/(dens*8.0 + 1.0 );\n            //float dt    = 0.05/(sqrt(dens)*4.0 + 1.0 ); \n            float da    = dens*dt*4.0;\n            float wa    = 1.0-clrsum.a; wa=clamp(wa,0.0,1.0); \n            clrsum += vec4( mclr,3.0 ) * da * wa;\n            t += dt;\n            \n            it+= (1.0/64.0);\n            if( (t>tt.y) ) break;\n        }\n    }\n   //clrsum.rgb*=clrsum.rgb; clrsum.rgb *=4.0;\n    \n    clrsum.rgb *=2.0;\n\n    clrsum.rgb += (1.0-clrsum.a)*vec3(1.0,1.0,1.0); \n    clrsum.a=1.0;\n\nfragColor = clrsum;\n\n}","name":"Image","description":"","type":"image"}]}