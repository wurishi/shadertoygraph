{"ver":"0.1","info":{"id":"fd3cWs","date":"1654298411","viewed":75,"name":"Pride raster bars","username":"Kneebiter","description":"Raster bars redone the hard way.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rasterbars","pride"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * I sometimes wonder what old school effects would look like done in legit 3D. I hope you appreciate the joke too.\n *\n * Lighting model, primitives, and camera trimmed down from iq's primitives shader: https://www.shadertoy.com/view/Xds3zN\n **/\n \n#define barSize .5\n#define opU(d1,d2) ((d1.x<d2.x)?d1:d2)\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 map( in vec3 pos ) {\n    vec2 res = vec2( 1e10, 0.0 );\n\n    for(float i = 0.; i < 6.; i++) {\n        float localTime = iTime - (3.14159 * i/5.);\n        localTime *= 1.2;\n        res = opU( res, vec2( sdCapsule( pos-vec3(0,2. * cos(localTime), 2. * i * barSize), vec3(-10,0,0), vec3(10,0,0), barSize ), i ) );\n    }\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float t = tmin;\n    \n    for( int i=0; i<150; i++ ) {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) ) {\n            res = vec2(t,h.y);\n            break;\n        }\n        t += h.x;\n    }\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos ) {\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nvec3 rainbow_lookup(int c) {\n    vec3 col = vec3(0.);\n    if( c == 0 ) {\n        col = vec3(1.,0.,0.);\n    } else if ( c == 1 ) {\n        col = vec3(1.,.5,0.);\n    } else if ( c == 2) {\n        col = vec3(1.,.9,0.);\n    } else if ( c == 3 ) {\n        col = vec3(0.,.9,0.);\n    } else if ( c == 4 ) {\n        col = vec3(0.,0.,1.);\n    } else if ( c == 5 ) {\n        col = vec3(.8,0.,.8);\n    }\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec2 res = castRay(ro,rd);\n    \n    vec3 pos = ro + res.x*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n    \n    vec3 col = rainbow_lookup(int(res.y));\n    \n    // Lighting model/equations from iq: https://www.shadertoy.com/view/Xds3zN\n    vec3  lig = normalize( vec3(0, 0.6, -5) );\n    vec3  hal = normalize( lig-rd );\n    float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),50.0);\n    \n    vec3 lin = vec3(0.0);\n    lin += 0.55*amb*vec3(0.6,0.6,.8);\n    lin += 0.55*bac*vec3(0.25,0.25,0.25);\n    col = col*lin;\n    col += 1.00*spe*vec3(.8, .7, .5);\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    // Note: cv is not normalized in iq's shader: https://www.shadertoy.com/view/Xds3zN\n    // I believe it should be normalized, but offer no justification for why.\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = mod(iTime/2., 3.14159 * 2. + 3.) - 3.;\n    if (time < 0.) {\n        time = 0.;\n    }\n    \n    vec2 p  = (2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(20.*sin(time),0., -20.*cos(time));\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    mat3 camMat = setCamera(ro, ta, 0.);\n    vec3 rd = normalize(camMat * vec3(p, 8.0));\n  \n\n    vec3 col = render( ro, rd);\n    col = pow( col, vec3(0.7) );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}