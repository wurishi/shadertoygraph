{"ver":"0.1","info":{"id":"WljfRG","date":"1599337715","viewed":54,"name":"Chessboard Mover","username":"Jakim","description":"As the title says. \n\nAn example of simple shader for educational purporses (in Polish).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["chess","chessboard","mover"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265358979323846264338327950288;\n\nconst float subX = 8.89;\nconst float subY = 5.0;\n\nconst float tX = 1.5;\nconst float tY = 1.0;\n\n// ustawiamy dwa kolory, dla pol 'bialych' oraz 'czarnych'\nconst vec3 color1 = vec3(0.0, 0.0, 0.0);\nconst vec3 color2 = vec3(1.0, 1.0, 1.0);\n\nfloat modulo(float a, float m)\n{\n\treturn sign(m - mod(a, 2.0 * m));    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    /*\n\tspraw, by mapa pikseli byla w zakresie:\n       (0,0) -- lewy gorny rog\n\t   (1,1) -- prawy gorny rog\n\n\tdlatego dzielimy mape po wspolrzednych przez rozdzielczosc:\n\tfragCoord.x / iResolution.x\n\tfragCoord.y / iResolution.y\n\tw kodzie: w jednej linii: fragCoord / iResolution.xy:\n\n\tinnymi slowy linijka\n\t\tvec2 uv = fragCoord / iResolution.xy;\n\tjest rownowazna:\n\t\tvec2 uv;\n\t\tuv.x = fragCoord.x / iResolution.x;\n\t\tuv.y = fragCoord.y / iResolution.y;\n    */\n    \n    float f = modulo(uv.x * subX + tX * iTime, 1.0) * modulo(uv.y * subY + tY * iTime, 1.0);\n    \n    /*\n\tdla kazdego piksela wyznaczamy 'bialy' lub 'czarny' prostokat, tj. wartosc 0 lub 1.\n\tdo tego wspomagamy sie funkcjami: sign(x) oraz funkcja zwracajaca reszte z dzielenia mod(a, b);\n\tnp. mod(2.2, 1.0) daje reszte z dzielenia przez 1.0, czyli dokladnie czesc ulamkowa liczby dziesietnej:\n\t\tmod(2.2, 1.0) = 0.2 bo 2.2 = 2 * 1.0 + 0.2\n\n\tpolecam w wolframie naszkicowac wykres funkcji (jednej zmiennej):\n\t\ty = 0.5 + 0.5 * sign(1.0 - mod(x, 2.0)) [definicja funkcji pomocnicznej 'modulo']\n\tgdzie sign to funkcja znaku:\n\t\t          { -1, x < 0\n\t\tsign(x) = {  0, x = 0\n\t\t          {  1, x > 0\n\twartosc f dzieki temu przyjmuje zawsze jedna z wartosci: 0 lub 1 (albo 0.5 na krawedziach)\n\n\tparametry:\n\t\t* subX i subY okreslaja, na ile fragmentow podzielic ekran (poziomo oraz pionowo),\n\t\t* tX oraz tY okreslaja wspolczynniki predkosci dla przesuwania (za pomoca wbudowanej zmiennej iTime).\n\n\t*/\n    \n    vec3 col = f * color2 + (1.0 - f) * color1;\n    \n    /*\n\tponizsza funkcja zwraca kombinacje wypukla dwoch predefiniowanych kolorow: color1 oraz color2\n\twarto zwrocic uwage, ze gdy f = 0.0, to:\n\t\tcol = 0.0 * color2 + (1.0 - 0.0) * color1 = 0.0 * color2 + 1.0 * color1 = color1,\n\ta dla f = 1.0:\n\t\tcol = 1.0 * color2 + (1.0 - 1.0) * color1 = 1.0 * color2 + 0.0 * color1 = color2.\n\twartosci posrednie okreslaja kolory posrednie\n\t*/\n    \n    // zwracamy otrzymana szachownice\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}