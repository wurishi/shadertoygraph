{"ver":"0.1","info":{"id":"WtjBDK","date":"1691011656","viewed":31,"name":"Toys","username":"aumfer","description":"smithing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["attic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n\nvec3 background(vec3 rd) {\n    return texture(iChannel0, rd).rgb;\n}\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec3 diffuse;\n    float roughness;\n};\nSphere[] spheres = Sphere[](\n    Sphere( vec3(0), 1.0, vec3(0.2, 0.2, 0.2), 0.0 ),\n    Sphere( vec3(0), 0.5, vec3(0.2, 0.0, 0.0), 1.0 ),\n    Sphere( vec3(0), 0.5, vec3(0.0, 0.2, 0.0), 0.8 ),\n    Sphere( vec3(0), 0.5, vec3(0.0, 0.0, 0.2), 0.6 ),\n    Sphere( vec3(0), 0.5, vec3(0.2, 0.2, 0.0), 0.4 ),\n    Sphere( vec3(0), 0.5, vec3(0.0, 0.2, 0.2), 0.2 ),\n    Sphere( vec3(0), 0.5, vec3(0.2, 0.0, 0.2), 0.0 )\n);\n\nbool trace(vec3 ro, vec3 rd, out float t, out vec3 p, out vec3 N, out vec3 diffuse, out vec3 specular, out float roughness) {\n    N = vec3(0, 0, 1);\n    t = isect_plane(ro, rd, vec4(N, 0));\n    if (t > 0.0) {\n    \tdiffuse = vec3(0.01);\n    \tspecular = vec3(0);\n    \troughness = 0.0;\n        p = ro + rd * t;\n        diffuse *= mod(p, 1.0);\n    }\n    for (int i = 0; i < spheres.length(); ++i) {\n        Sphere s = spheres[i];\n        float d = isect_sphere(ro, rd, vec4(s.position, s.radius));\n        if (d > 0.0 && (t < 0.0 || d < t)) {\n            t = d;\n            p = ro + rd*t;\n            N = normalize(p - s.position);\n            diffuse = s.diffuse;\n            specular = vec3(0.04);\n            roughness = max(0.04, s.roughness);\n        }\n    }\n    return t > 0.0;\n}\n\nbool shade(inout vec3 ro, inout vec3 rd, out vec3 color) {\n    float t;\n\tvec3 p;\n\tvec3 N;\n\tvec3 diffuse;\n    vec3 specular;\n    float roughness;\n\tif (trace(ro, rd, t, p, N, diffuse, specular, roughness)) {\n\t\tvec3 V = -rd;\n\t\t//color = ImageBasedLightingMIS(diffuse, specular, roughness, p, V, N, floatBitsToUint(random2f()));\n        color = diffuse;\n\t\treturn true;\n\t}\n\tcolor = background(rd);\n\treturn false;\n}\n\nmat3 camera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //random_init2f(fragCoord);\n    float aspect = iResolution.x / iResolution.y;\n    \n    for (int i = 1; i < spheres.length(); ++i) {\n        float it = iTime + float(i)/2.0;\n        spheres[i].position = 2.0*vec3(sin(it), cos(it), 0.0);\n    }\n    \n\tvec3 total = vec3(0.0);\n    const int NUM_SAMPLES = 4;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n        vec2 p = snorm(fragCoord / iResolution.xy) * vec2(aspect, 1);\n        \n\t\tvec2 off = hammersley2d(i, NUM_SAMPLES);\n\t\t//vec2 off = random2f();\n\t\toff = snorm(off) / iResolution.xy;\n\t\tp += off;\n\n\t\tvec3 ro = vec3(0, 10, 10);\n\t\tvec3 ta = vec3(0, 0, 0);\n\t\tmat3 cam = camera(ro, ta, M_PI);\n\t\tvec3 rd = normalize(cam * vec3(p.xy, 2.5));\n\n\t\t//vec3 color = render(ro, rd);\n        vec3 color;\n        shade(ro, rd, color);\n\t\ttotal += color;\n\t}\n\ttotal /= float(NUM_SAMPLES);\n\n\t// tonemapping\n\ttotal = total / (total + vec3(1.0));\n\t// gamma\n\ttotal = pow(total, vec3(1.0 / 2.2));\n\n\tfragColor = vec4(total, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265358979323846;\nconst float M_PHI = 1.6180339887498948482045868343656;\nconst float FLT_EPSILON = 9.99999974737875E-06;\nconst float FLT_MAX = 3.402823466e+38F;\n\nfloat unorm(float v) {\n\treturn v * 0.5 + 0.5;\n}\nvec2 unorm(vec2 v) {\n\treturn v * 0.5 + 0.5;\n}\nvec3 unorm(vec3 v) {\n\treturn v * 0.5 + 0.5;\n}\nfloat snorm(float v) {\n    return v * 2.0 - 1.0;\n}\nvec2 snorm(vec2 v) {\n\treturn v * 2.0 - 1.0;\n}\nvec3 snorm(vec3 v) {\n\treturn v * 2.0 - 1.0;\n}\n\nfloat mincomp(vec2 v) { return min(v.x, v.y); }\nfloat maxcomp(vec2 v) { return max(v.x, v.y); }\nfloat mincomp(vec3 v) { return min(min(v.x, v.y), v.z); }\nfloat maxcomp(vec3 v) { return max(max(v.x, v.y), v.z); }\n\nfloat smin(float a, float b, float k) {\n    // https://iquilezles.org/articles/smin\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\n//==========================================================================================\n// sampling\n//==========================================================================================\n\nfloat radicalInverse_VdC(uint bits) {\n\tbits = (bits << 16u) | (bits >> 16u);\n\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\treturn float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d(uint i, uint N) {\n\treturn vec2(float(i) / float(N), radicalInverse_VdC(i));\n}\nvec2 hammersley2d(int i, int N) {\n\treturn vec2(float(i) / float(N), radicalInverse_VdC(uint(i)));\n}\n\n// https://www.shadertoy.com/view/MsdGzl\nvec3 cosineDirection(vec2 rnd, vec3 nor) {\n\t// compute basis from normal\n\t// see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n\t// (link provided by nimitz)\n\tvec3 tc = vec3(1.0 + nor.z - nor.xy*nor.xy, -nor.x*nor.y) / (1.0 + nor.z);\n\tvec3 uu = vec3(tc.x, tc.z, -nor.x);\n\tvec3 vv = vec3(tc.z, tc.y, -nor.y);\n\n\tfloat u = rnd.x;\n\tfloat v = rnd.y;\n\tfloat a = M_PI * 2.0 * v;\n\n\tvec3 d = sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0 - u)*nor;\n\td = normalize(d);\n\treturn d;\n}\n\nvec2 sampleSphericalMap(vec3 v) {\n\tconst vec2 invAtan = vec2(0.1591, 0.3183);\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n    uv *= invAtan;\n    uv += 0.5;\n    return uv;\n}\n\n//==========================================================================================\n// intersection\n//==========================================================================================\n\nfloat isect_sphere(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.0) {\n\t\treturn -1.0;\n\t}\n\th = sqrt(h);\n\treturn -b - h;\n}\n\nfloat isect_plane(vec3 ro, vec3 rd, vec4 p) {\n\tfloat t = -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n\treturn t;\n}\n\nfloat minT(float a, float b) {\n\tconst float zfar = -1.0;\n\treturn (a<b)? zfar: (b<0.)? (a>0.)? a: zfar: b;\n}\n\n// https://www.shadertoy.com/view/XtGXRz\nfloat isect_aabb(vec3 ro, vec3 rd, vec3 mins, vec3 maxs) {\n\tvec3 t1 = (mins - ro)/rd; //https://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm\n\tvec3 t2 = (maxs - ro)/rd;\n\tvec3 tn = min(t1, t2);\n\tvec3 tx = max(t1, t2);\n    float d = minT(mincomp(tx),maxcomp(tn)); //minT calculates the minimum positive, if n/a then returns zfar\n\treturn d;\n}\n\nfloat isect_triangle( vec3 orig\n                       , vec3 dir\n                       , vec3 vert0\n                       , vec3 vert1\n                       , vec3 vert2\n                       , out float u\n                       , out float v\n                       ) {\n    // Fast, Minimum Storage Ray-Triangle Intersection\n    //\n    // Tomas MÃ¶ller and Ben Trumbore. Fast, minimum storage ray-triangle intersection.\n    // Journal of graphics tools, 2(1):21-28, 1997\n    //\n    // http://www.jcenligne.fr/download/little3d/\n    //     jgt%20Fast,%20Minumum%20Storage%20Ray-Triangle%20Intersection.htm\n\n    const float JGT_RAYTRI_EPSILON = 0.000001;\n\tfloat t;\n\n    vec3 edge1, edge2, tvec, pvec, qvec;\n    float det, inv_det;\n\n    // Find vectors for two edges sharing vert0\n    edge1 = vert1 - vert0;\n    edge2 = vert2 - vert0;\n\n    // Begin calculating determinant - also used to calculate U parameter\n    pvec = cross(dir, edge2);\n\n    // If determinant is near zero, ray lies in plane of triangle\n    det = dot(edge1, pvec);\n\n    if (det > -JGT_RAYTRI_EPSILON && det < JGT_RAYTRI_EPSILON) {\n        return -1.0;\n\t}\n    inv_det = 1.0 / det;\n\n    // Calculate distance from vert0 to ray origin\n    tvec = orig - vert0;\n\n    // Calculate U parameter and test bounds\n    u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return -1.0;\n\t}\n\n    // Prepare to test V parameter\n    qvec = cross(tvec, edge1);\n\n    // Calculate V parameter and test bounds\n    v = dot(dir, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return -1.0;\n\t}\n\n    // Calculate t, ray intersects triangle\n    t = dot(edge2, qvec) * inv_det;\n\n    return t;\n}\n\n\n//==========================================================================================\n// indexing\n//==========================================================================================\n\nint index2d(ivec2 p, ivec2 bounds) {\n\tint index = p.x +\n\t\t\t\tp.y * bounds.x;\n\treturn index;\n}\nint index3d(ivec3 p, ivec3 bounds) {\n\tint index = p.x +\n\t\t\t\tp.y * bounds.x +\n\t\t\t\tp.z * bounds.x * bounds.y;\n\treturn index;\n}\nint index4d(ivec4 p, ivec4 bounds) {\n\tint index = p.x +\n\t\t\t\tp.y * bounds.x +\n\t\t\t\tp.z * bounds.x * bounds.y +\n\t\t\t\tp.w * bounds.x * bounds.y * bounds.z;\n\treturn index;\n}\n\n//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1(vec2 p) {\n\tp = 50.0*fract(p*0.3183099);\n\treturn fract(p.x*p.y*(p.x + p.y));\n}\n\nfloat hash1(float n) {\n\treturn fract(n*17.0*fract(n*0.3183099));\n}\n\nvec2 hash2(float n) { return fract(sin(vec2(n, n + 1.0))*vec2(43758.5453123, 22578.1459123)); }\n\nvec2 hash2(vec2 p) {\n\tconst vec2 k = vec2(0.3183099, 0.3678794);\n\tp = p*k + k.yx;\n\treturn fract(16.0 * k*fract(p.x*p.y*(p.x + p.y)));\n}\n\n//==========================================================================================\n// rng\n//==========================================================================================\n\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n\tx += (x << 10u);\n\tx ^= (x >> 6u);\n\tx += (x << 3u);\n\tx ^= (x >> 11u);\n\tx += (x << 15u);\n\treturn x;\n}\n// Compound versions of the hashing algorithm I whipped together.\nuint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }\nuint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }\nuint hash(uvec4 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w)); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct(uint m) {\n\tconst uint ieeeMantissa = 0x007FFFFFu;\t// binary32 mantissa bitmask\n\tconst uint ieeeOne = 0x3F800000u;\t\t// 1.0 in IEEE binary32\n\n\tm &= ieeeMantissa;\t\t\t\t\t\t// Keep only mantissa bits (fractional part)\n\tm |= ieeeOne;\t\t\t\t\t\t\t// Add fractional part to 1.0\n\n\tfloat  f = uintBitsToFloat(m);\t\t\t// Range [1:2]\n\treturn f - 1.0;\t\t\t\t\t\t\t// Range [0:1]\n}\n\n//uniform uvec4 random_seed;\n//uvec4 seed = random_seed;\nuvec4 seed = uvec4(0);\nvoid random_init1ui(uint x) {\n\tseed ^= uvec4(x, ~x, -x, -~x);\n}\nvoid random_init2ui(uvec2 x) {\n\tseed ^= uvec4(x.x, x.y, ~x.x, ~x.y);\n}\nvoid random_init2f(vec2 v) {\n\tuvec2 x = floatBitsToUint(v);\n\tseed ^= uvec4(x.x, x.y, ~x.x, ~x.y);\n}\nfloat random1f() {\n\treturn floatConstruct(hash(seed++));\n}\nvec2 random2f() {\n\treturn vec2(random1f(), random1f());\n}\nvec3 random3f() {\n\treturn vec3(random1f(), random1f(), random1f());\n}\nfloat normal1f() {\n\treturn sqrt(random1f()) * cos(random1f() * M_PI * 2.0);\n}\nvec2 normal2f() {\n\treturn vec2(normal1f(), normal1f());\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}