{"ver":"0.1","info":{"id":"NtBGRd","date":"1624457810","viewed":116,"name":"simple curve bezier closed","username":"jorge2017a1","description":"simple curve bezier closed","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["simplecurvebezierclosed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//modificado por jorge2017a1\n\n/* Signed Distance to Polyspline\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Got rid of the if(.) by using step functions\n// Update 2: Removed degenerate case (it is invisible).\n\n// (Un)Comment this for different look\n#define DRAW_GEOMETRY\n// More Segments = cooler; choose min. 2\n#define N 39\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Standard shadertoy fill color\nvec3 col(vec2 uv, float o)\n{\n    return 0.5 + 0.5*cos(o+uv.xyx+vec3(0,2,4));\n}\n\n//distance to quadratic bezier spline with parameter t\nfloat dist(vec2 p0,vec2 p1,vec2 p2,vec2 x,float t)\n{\n    t = clamp(t, 0., 1.);\n    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);\n}\n\n//minimum distance to quadratic bezier spline\nfloat spline2(vec2 p0, vec2 p1, vec2 p2, vec2 x)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;\n    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = - tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.) \n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return dist(p0,p1,p2,x,ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    vec3 t = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n    return min(\n        dist(p0,p1,p2,x, t.x),\n        min(\n            dist(p0,p1,p2,x,t.y),\n            dist(p0,p1,p2,x,t.z)\n        )\n    );\n}\n\n\nfloat polygonFiguraCerrada(vec2 x)\n{\n    \n\tfloat ret = 1., n = 0.;\n    \nvec2 pc1p1=vec2(.377,.555);\nvec2 pc1p2=vec2(.405,.493);\nvec2 pc1p3=vec2(.412,.426);\n\nvec2 pc2p1=vec2(.412,.426);\nvec2 pc2p2=vec2(.585,.379);\nvec2 pc2p3=vec2(.779,.380);\n\nvec2 pc3p1=vec2(.779,.380);\nvec2 pc3p2=vec2(.721,.498);\nvec2 pc3p3=vec2(.760,.591);\n\nvec2 pc4p1=vec2(.760,.591);\nvec2 pc4p2=vec2(.483,.571);\nvec2 pc4p3=vec2(.377,.555);\n\n\nvec2 p0;\nvec2 p1;\nvec2 p2;\n  \n    \n    for(int i=0; i<4; ++i)\n    {\n    \n       if (i==0)\n       {\n           p0=pc1p1;\n           p1=pc1p2;\n           p2=pc1p3;\n       \n       }\n       else if (i==1)\n       {\n           p0=pc2p1;\n           p1=pc2p2;\n           p2=pc2p3;\n\n       }\n       else if (i==2)\n       {\n       \n           p0=pc3p1;\n           p1=pc3p2;\n           p2=pc3p3;\n       }\n       else if (i==3)\n       {\n           p0=pc4p1;\n           p1=pc4p2;\n           p2=pc4p3;\n       }\n       \n    \n       \n        // Compute coefficients for quadratic equation\n        //float a = p2.y-2.*p1.y+p0.y, b = 2.*p1.y-2.*p0.y, C = p0.y-x.y;\n        float a = p2.y-2.*p1.y+p0.y;\n        float b = 2.*p1.y-2.*p0.y;\n        float C = p0.y-x.y;\n        \n        // Discriminant\n        float dis = b*b-4.*a*C;\n        \n        // Solution\n        if(dis == 0.)\n        {\n            float t = -b/2./a, \n                alpha = pow(1.-t,2.)*p0.x+2.*(1.-t)*t*p1.x+t*t*p2.x-x.x;\n            n += step(0., t)*step(t, 1.)*step(0., alpha);\n        }\n        else if(dis > 0.)\n        {\n            vec2 t = (-b*c.xx+c.xz*sqrt(dis))/2./a,\n                alpha = (c.xx-t)*(c.xx-t)*p0.x+2.*(c.xx-t)*t*p1.x+t*t*p2.x-x.x;\n            t = step(c.yy, t)*step(t, c.xx)*step(c.yy, alpha);\n            n += t.x+t.y;\n        }\n        \n        ret = min(ret, spline2(p0, p1, p2, x));\n    }\n    \n    return mix(ret, -ret, mod(n, 2.));\n}\n\n\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\n// Add the polygon to a scene\nvec4 scene(vec2 x)\n{\n    \n    \n    vec4 sdf1 = vec4(polygonFiguraCerrada(x), col(x, 3.+iTime*2.0));\n    sdf1 = add(sdf1, vec4(stroke(sdf1.x, .003), vec3(0.0) ));\n    \n    vec2 opc1=vec2(sdf1.x,1.0);\n   \n    vec2 resp=vec2(9999.9, -1.0);\n    resp=opU2(resp, opc1);\n \n    vec4 col=vec4(1.0);\n    if (resp.y==1.0)\n        col=vec4(sdf1.x,sdf1.gba);\n   \n    return col;\n    \n}\n\n// Draw everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    uv.y*=0.8;\n    uv.y+=0.4;\n    vec4 s = scene(uv);\n    vec3 col = mix(s.gba, vec3(1.0) ,  smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, s.x)  );\n \tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}