{"ver":"0.1","info":{"id":"4c3BWf","date":"1733526259","viewed":76,"name":"Inercia 2024 Shader Jam Cubes","username":"eimink","description":"My shader done during Inercia 2024 jam, not an exact version but adaptation for shadertoy","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float E = 0.001;\nconst int STEPS = 64;\nconst float FAR = 40.0;\n\nvec3 glow = vec3(0.0);\n\n\n\n\nvoid rot(inout vec2 p, float a){\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct MarchResult\n{\n  float id;\n  float t;\n  vec3 p;\n  vec3 n;\n  float d;\n};\n\nfloat box(vec3 position, vec3 dimensions){\n  vec3 b = abs(position)-dimensions;\n  return length(max(b, 0.0)) + min(max(b.x, max(b.y, b.z)), 0.0); \n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 scene(vec3 p){\n    float fGlobalTime = iTime;\n  vec3 pp = p;\n  vec3 ppp = p;\n  vec2 res = vec2(1.,0.);\n  vec2 res2 = vec2(1.,0.);\n  vec2 res3 = vec2(1.,0.);\n  for (float i = 0.0; i < 32.0; i+=1.0) {\n    rot(pp.xz, fGlobalTime*0.01);\n    rot(pp.zy, fGlobalTime*0.01);\n    float a = box(pp+vec3(0.+cos(fGlobalTime+i),0.+sin(fGlobalTime-i),15.0-i),vec3(1.,1.,1.0));\n    float b = box(pp+vec3(1.+sin(fGlobalTime+i),1.+sin(fGlobalTime-i),14.0-i),vec3(1.,1.,1.0));\n    float c = box(pp+vec3(2.+cos(fGlobalTime+i),2.+cos(fGlobalTime-i),13.0-i),vec3(1.,1.,1.0));\n    res = opU(res,opU(vec2(c,1),opU(vec2(b,1),vec2(a,1))));\n    rot(ppp.zy, fGlobalTime*0.01);\n    rot(ppp.zx, fGlobalTime*0.01);\n    float d = box(ppp+vec3(0.+cos(fGlobalTime+i),6.+sin(fGlobalTime-i),12.0-i),vec3(1.,1.,1.0));\n    float e = box(ppp+vec3(1.+sin(fGlobalTime+i),7.+sin(fGlobalTime-i),11.0-i),vec3(1.,1.,1.0));\n    float f = box(ppp+vec3(2.+cos(fGlobalTime+i),8.+cos(fGlobalTime-i),10.0-i),vec3(1.,1.,1.0));\n    res2 = opU(res2,opU(vec2(d,2),opU(vec2(e,2),vec2(f,2))));\n    \n    rot(p.zy, fGlobalTime*0.01);\n    rot(p.xz, fGlobalTime*0.01);\n    float g = box(p+vec3(0.+cos(fGlobalTime+i),12.+sin(fGlobalTime-i),9.0-i),vec3(1.,1.,1.0));\n    float h = box(p+vec3(1.+sin(fGlobalTime+i),13.+sin(fGlobalTime-i),8.0-i),vec3(1.,1.,1.0));\n    float j = box(p+vec3(2.+cos(fGlobalTime+i),14.+cos(fGlobalTime-i),7.0-i),vec3(1.,1.,1.0));\n    res3 = opU(res3,opU(vec2(j,3),opU(vec2(h,3),vec2(g,3))));\n  } \n  glow += vec3(0.85,0.08,0.45)*0.0012 / abs(res.x)+0.0001;\n  glow += vec3(0.02,0.08,0.45)*0.005/ abs(res2.x)+0.001;\n  glow += vec3(0.4,0.08,0.4)*0.002 / abs(res3.x)+0.0001;\n  return opU(res3,opU(res2,res));\n}\n\nvec3 calcNormal(vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(scene(pos+e.xyy).x-scene(pos-e.xyy).x,\n                           scene(pos+e.yxy).x-scene(pos-e.yxy).x,\n                           scene(pos+e.yyx).x-scene(pos-e.yyx).x ) );\n}\n\nMarchResult march(vec3 ro, vec3 rd)\n{\n  float t = E;\n  float id = 0.0;\n  vec3 position = ro;\n  for (int i = 0; i < STEPS;++i){\n    vec2 d = scene(position);\n    t +=d.x;\n    id = d.y;\n    position = ro+rd*t;\n    if (d.x < E || t > FAR) break;\n  }\n  MarchResult res;\n  res.t = t;\n  res.id = id;\n  res.p = position;\n  res.n = calcNormal(position);\n  return res;\n}\n\nvec3 colorize(MarchResult m, vec3 ld)\n{\n  float t = m.d;\n  vec3 p = m.p;\n  vec3 col = vec3(0.0);\n  if (m.id == 1.0)\n  {\n      col = vec3(1.0,.2,.8) + clamp(dot(m.n,ld),0.0,1.0);\n  }\n  else if (m.id == 2.0)\n  {\n      col = vec3(0.2,0.2,1.0) + clamp(dot(m.n,ld),0.0,1.0);\n  }\n  else if (m.id == 3.0)\n  {\n      col = vec3(0.4,0.1,0.4) + clamp(dot(m.n,ld),0.0,.5);\n  }\n  else col = vec3(0);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 v2Resolution = iResolution;\n  float fGlobalTime = iTime;\n  vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  vec2 uvv = -1.0 + 2.0*uv;\n  uvv.x *= v2Resolution.x / v2Resolution.y;\n    \n  vec3 rayOrigin = vec3(sin(fGlobalTime*.5)*10.,sin(fGlobalTime*2.)*2.-5.0,cos(fGlobalTime*.5)*20.-10.0);\n  vec3 lookAt = vec3(0.0, -5.0, 0.0);\n  \n  vec3 z = normalize(lookAt - rayOrigin);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  \n  vec3 rayDirection = normalize(mat3(x, y, z) * vec3(uvv, radians(60.00)));\n  \n  vec3 lightDirection = -rayDirection;\n  \n  vec3 col = vec3(0.0);\n  \n  MarchResult t = march(rayOrigin, rayDirection);\n  if ( t.t < FAR){\n    col = colorize(t,lightDirection);\n  }\n  \n  col = col + glow*0.01;\n  \n    col = smoothstep(0.0,1.0,col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bufB = texelFetch(iChannel1,ivec2(fragCoord),0);\n    vec4 bufA = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec3 col;\n    vec3 v2Resolution = iResolution;\n    vec4 pcol = vec4(0.0);\n    vec2 puv = vec2(20.0/v2Resolution.x, 20.0/v2Resolution.y);\n    vec4 kertoimet = vec4(0.1531, 0.12245, 0.0918, 0.051);\n    \n    pcol = bufB * 0.1633;\n    pcol += bufB * 0.1633;\n    for(int i = 0; i < 4; ++i){\n        pcol += texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * kertoimet[i] +\n        texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * kertoimet[i] +\n        texelFetch(iChannel1, ivec2(uv.x + (float(i)+1.0) * puv.y, uv.y + (float(i)+1.0) * puv.x),0) * kertoimet[i] +\n        texelFetch(iChannel1, ivec2(uv.x + (float(i)+1.0) * puv.y, uv.y + (float(i)+1.0) * puv.x),0) * kertoimet[i];\n      }\n      col = bufA.rgb;\n      col += pcol.rgb;\n      col *= 0.25;\n  \n      col = mix(col,bufA.rgb,0.25);\n    \n      col = smoothstep(0.0,1.0,col);\n\n      fragColor = mix(bufB,vec4(col,1.0),0.5);\n\n}","name":"Buffer B","description":"","type":"buffer"}]}