{"ver":"0.1","info":{"id":"tlsyz2","date":"1592554997","viewed":333,"name":"Hall Of Mirrors v0.3","username":"_pwd_","description":"Shiny boxes ...lots of","likes":18,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","reflection","refraction","cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4t2Gz3","filepath":"https://soundcloud.com/northcape/glasshouse","previewfilepath":"https://soundcloud.com/northcape/glasshouse","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Hall Of Mirrors\n// -> adding my 50 cents upon mu6k and XT95 origins by\n//\n//\n// mixing  30 torus by XT95 -> https://www.shadertoy.com/view/3dlcWl\n// with    origin by mu6k -> https://www.shadertoy.com/view/XdfGzS\n//\n\n\n#define object_speed_modifier 1.0\n#define render_steps 64\n#define offset1 4.5\n#define offset2 1.8\n#define att 12.\n\n// helpers\nfloat hash1(float s) { return fract(sin(s)*42422.42); }\nmat2 rot(float v) { float a = cos(v), b = sin(v); return mat2(a,b,-b,a); }\nfloat torus(vec3 p, vec2 q) { return length( vec2(length(p.xz)-q.x,p.y) ) - q.y; } \n\n// global + params\nfloat time;\nfloat id;\nvec3 glow;\nvec3 sync;\n\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat rnd(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n//Smooth min by IQ\nfloat smin( float a, float b )\n{\n    float k = 0.5;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// distance function\nfloat map( vec3 p ) {\n    // rotate the world\n\tp.xz *= rot(time* .1);\n\t//p.xy *= rot(time*.2);\n\n    \n    // small point light on the center\n\tfloat d =  length(p);\n\tglow += vec3(1.) / ( .1 + d*200.);\n    \n\tfloat t = iTime*object_speed_modifier+5.0;\n\tp.x += t;\t\n\tp.z += t*.4;\n\n\tfloat s = length(p);\n\n\tp.y  = abs(p.y);\n\tp.y -= 5.0;\n\t\n    d = 0.5-p.y;\n\t\n\tfor (int i=0; i<15; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\t\n\t\tp+=vec3(1.25-fi,0.0,1.75+fi);\n\t\tvec3 pm;\n\t\t\n\t\tfloat rep = 10.0 + sin(fi*2.0+1.0)*4.0 /* sync.g * 0.00005*/;\n\t\t\n\t\tpm.xz = mod(p.xz+vec2(rep*.5),vec2(rep))-vec2(rep*.5);\n\t\t\n\t\tfloat width  = 1.0  + sin(fi) * .8;\n\t\tfloat height = 2.0  + cos(fi) * 1.2 + ( sync.b * 0.3);\n\t\tfloat offset = -0.5 + cos(fi) * 1.8;\n\n\t\tvec3 df = abs(vec3(pm.x,p.y+1.0/width,pm.z))-vec3(width,height,width);\n\t\tfloat box = max(max(df.x,df.y),df.z);\n        \n\n\t\t//box= length(max(df,0.0)) + min(max(df.x,max(df.y,df.z)),0.0) - 0.095;\n        \n        // we accumulate the lighting here\n    \tfloat intensity = 1. / ( 1. + pow(abs(box*att),1.3));\n    \tif(i == 2 && id == 0.) {\n    \t\tglow += vec3(1.,.3,1.) * intensity;\n    \t} else if(i == 5 && id == 4.) {\n      \t\tglow += vec3(0.,0.,.6) * intensity; \n    \t} else if(i == 7 && id == 1.) {\n      \t\tglow += vec3(1.,1.,.1) * intensity;\n    \t} else if(i == 14 && id == 2.) {\n      \t\tglow += vec3(.1,1.,.1) * intensity;\n    \t} else if(i == 17 && id == 5.) {\n      \t\tglow += vec3(0.16,0.0,0.32) * intensity;            \n    \t} else if(i == 20 && id == 3.) {\n      \t\tglow += vec3(.1,1.,1.) * intensity;\n    \t}\n\n\t\td = min(d,box);\n\t}\n\n\treturn d;    \n    \n    \n}\n\n\nvec3 getNormal(vec3 p) {\n\tvec3 eps=vec3(.1,0,0);\n\treturn normalize(vec3(map(p+eps.xyy),map(p+eps.yxy),map(p+eps.yyx)));\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\n\tacc+=map(p+vec3(-0.5,-0.5,-0.5));\n\tacc+=map(p+vec3(-0.5,-0.5,+0.5));\n\tacc+=map(p+vec3(-0.5,+0.5,-0.5));\n\tacc+=map(p+vec3(-0.5,+0.5,+0.5));\n\tacc+=map(p+vec3(+0.5,-0.5,-0.5));\n\tacc+map(p+vec3(+0.5,-0.5,+0.5));\n\tacc+=map(p+vec3(+0.5,+0.5,-0.5));\n\tacc+=map(p+vec3(+0.5,+0.5,+0.5));\n\treturn acc*.05+.5;\n}\n\nfloat ao1(vec3 p, vec3 n, float d) {\n\n\tfloat s = sign(d);\n\tfloat o = s*.5+.5;\n\tfor (float i = 4.0; i > 0.; --i) {\n\t\to -= (i*d - map(p+n*i*d*s)) / exp2(i);\n\t}\n\treturn o;\n\t\n}\n\n//render background\nvec3 background(vec3 p,vec3 d) {\n\treturn vec3(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime + 10.;\n    \n    // uv stuff\n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n  \tv.x /= iResolution.y / iResolution.x;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    \n    \n    float fft = texture(iChannel0, vec2(.4, .25)).r * 2.; \n\tsync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n\tid = floor(hash1(floor(iTime*2.*hash(floor(time*.2))))*5.);\n    \n    // ray setup\n  \tvec3 ro = vec3(0.,0.,-4.);\n  \tvec3 rd = normalize(vec3(v, 1.));\n\trd.z -= length(rd)*.54; //lens distort\n    rd = normalize(rd);\n\trd = rotate_x(rd,1.5);\n\trd = rotate_y(rd,mouse.x*9.0+offset2);\n    \n    if( mouse.y != 0. )  rd = rotate_x(rd,mouse.y*9.0+offset1);\n    \n    // raymarching by distance field\n  \tvec3 p = ro + rd ;\n  \tglow   = vec3(.0);\n    \n    float dd;\n    vec3 sp = p;\n    \n  \tfor(int i=0; i<render_steps; i++) {\n        dd = map(p);\n    \tp += dd * rd;\n        if (dd<.001) break;\n  \t}\n\n    vec3 n   = getNormal(p);\n    float a  = ao1(p, n, 0.51);\n    float s  = ao1(p, n, -0.435);\n    vec3 cB  = vec3(a);\n\tfloat ao = amb_occ(p);\n    \n\trd=refract(rd,getNormal(p),1./.87);\n\tp+=rd;\n    \n    float ref=0.;\n    vec3 spec = vec3(0.);\n\tfloat intens=.1;\n\tfor (int i=0; i<render_steps; i++)\n\t{\n        dd = map(p);\n    \tp += dd * rd;\n\t\tif (dd>0.0 && ref>.5) {\n            ref=0.;\n\t\t\tif (dot(rd,n)<-.5) rd=normalize(refract(rd,n,1./.97));\n\t\t\tvec3 refl=reflect(rd,n);\n        }\n \t\tif (dd<0.0 && ref<.05) {\n            ref=1.;\n\t\t\tif (dot(rd,n)<-.05) rd=normalize(refract(rd,n,.97));\n\t\t\tvec3 refl=reflect(rd,n);\n        }       \n\t}    \n     \n    float duration = 15.; \n    float parabola = 0.75;\n    float saw = mod(time/duration,1.);\n\tparabola = 0.8-pow(4.*saw*(1.-saw),2.)*0.6;\n\n    // glow + background + vignetting + gamma correction\n  \tvec3 col = glow * s;\n\tcol *= 0.5;\n  \t\n    col += spec * spec;\n\n \tif (dd>0.1) col = background(sp,rd);\n   \n    col *= pow(uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .8)*2.;\n  \tcol = pow(col,vec3(1./2.2));\n    \n    col += 0.25*(0.5-rnd(uv.xy*time))*parabola;\t\n\n\n  \tfragColor = vec4( mix( col, cB, 0.3 ) * ao, 1. );\n}","name":"Image","description":"","type":"image"}]}