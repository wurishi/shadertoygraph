{"ver":"0.1","info":{"id":"tdlXR2","date":"1551897351","viewed":148,"name":"DE Mandelbrot","username":"BowToes","description":"Mandelbrot/Julia fractal rendered using distance estimation. The code's a bit of a mess.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Idea from https://tinyurl.com/yyxrzrog\nconst float i255 = 0.0039215682745;\nconst float len = 5.;\nvec3 plt[] = vec3[]\n    (\n        vec3(240.0, 010.0, 025.0)*i255,\n\t\tvec3(220.0, 200.0, 000.0)*i255,\n\t\tvec3(255.0, 000.0, 055.0)*i255,\n\t\tvec3(040.0, 060.0, 220.0)*i255,\n\t\tvec3(060.0, 020.0, 090.0)*i255,\n\t\tvec3(000.0, 000.0, 000.0)*i255\n    );\n\nfloat deMandel(float n, vec2 c, inout vec2 z, vec2 poz, vec2 poc, out float di, out float it)\n{\n    vec2 dz = vZero;\n    float dr, r, i = 0.0;\n    di = 1.;\n    for (; i < n && di > 0.; i++)\n    {\n        dz = 1.0+2.0*ml(z,dz);\n        z = pw(z,poz)+pw(c,poc);\n        r = dot(z,z);\n        di = H(256. - r);\n    }\n    it = i;\n    // The equation is supposed to be\n    // .5*sqrt(r/dot(dz,dz))*log(r)\n    // but I found this works well too\n    // not sure if a log is more efficient than a sqrt though\n    return .25*log(r/dot(dz,dz))*log(r);\n    // There's also\n    // return .5*inversesqrt(dot(dz,dz)/r)*log(r);\n    // I saw somewhere that inversesqrt is generally faster than sqrt?\n    // Not that the return statement is where optimization is most useful anyway\n}\n\nfloat mIter = 100.0;\nconst vec2 center = vZero;\nvec3 col;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.xy == vZero)\n        mIter = 1000.;\n    col = vec3(0.);\n    float t = (10. + iTime) / 4.;\n    // Offset palette index with time\n    float b = -2.*t;\n    // Vertical view height (vertical range = [-zoom, zoom])\n    float zoom = 1.;\n    // Transformed pixel coordinates\n    vec2 uv = transform(fragCoord.xy, iResolution.xy, center, zoom);\n    // Transformed mouse coordinates\n    vec2 mp = iMouse.xy == vZero ? 1.*cardioid(.25, 1.01*PI) + .25*vOne : \n    \ttransform(iMouse.xy, iResolution.xy, center, 1.);\n    //vec mc = .25*eix(t) - vOne;\n    vec2 mc = cardioid(.25, t) + .25*vOne;\n    \n    // z exponent\n    vec2 poz = vec2(2, 0);\n    vec2 poc = vec2(1, 0);\n    \n    vec2 c = mp;\n    vec2 z = uv;\n    vec2 zi = z;\n    \n    float di, it;\n    // Raw Distance estimate\n    float x = deMandel(mIter, c, z, poz, poc, di, it);\n    // Smoothness factor\n    float nu = -2.*log(0.5*log(dot(z,z)))/log(dot(poz, poz));\n    \n    // Palette index interpolant\n    float palettegrit = 10.;\n    float dx = log(abs((it + palettegrit) + nu))+b;\n    int id = int(dx);\n    col = di * plt[int(len)] + (1.-di)*max(vec3(0.),mix(plt[id%int(len)], plt[(id+1)%int(len)], fract(dx)));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define eix(x) vec2(cos(x), sin(x))\n#define EIX(x) (.5+.5*vec2(cos(x), sin(x)))\n#define EXP(x) (exp(-x*x))\n\n#define SIN(x) (.5*sin(x)+.5)\n#define COS(x) (.5*cos(x)+.5)\n\n\nconst float PI = acos(-1.);\nconst vec2 vOne = vec2(1.0, 0.0);\nconst vec2 vImag = vec2(0.0, 1.0);\nconst vec2 vUnit = vec2(1.0, 1.0);\nconst vec2 vZero = vec2(0.0, 0.0);\n\nfloat H(float x)\n{ return      ceil(clamp(x, 0., 1.)); }\nfloat H2(float x)\n{ return 1. - ceil(clamp(x, 0., 1.)); }\nfloat H3(float x)\n{ return \t  ceil(clamp(abs(x), 0., 1.)); }\nfloat H4(float x)\n{ return 1. - ceil(clamp(abs(x), 0., 1.)); }\n\n// z/w\nvec2 dv(vec2 a, vec2 b)\n{ return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x) / dot(b,b); }\n// z*w\nvec2 ml(vec2 a, vec2 b)\n{ return vec2 (a.x*b.x - a.y*b.y, a.x*b.y+a.y*b.x); }\n// z^a\nvec2 pw(vec2 a, float b)\n{\n    if (dot(a,a) == 0.)\n    {\n        if (b != 0.)\n            return vZero;\n        else\n            return vOne;\n    }\n    return pow(dot(a, a), .5*b)*eix(atan(a.y, a.x)*b);\n}\n// z^w\nvec2 pw(vec2 a, vec2 b) \n{\n    float t = atan(a.y, a.x);\n    float r = dot(a,a);\n    if (r == 0.)\n    {\n        if (dot(b,b) != 0.)\n            return vZero;\n        else\n            return vOne;\n    }\n    return pow(r, b.x/2.)*exp(-b.y*t)*eix(b.x*t+.5*b.y*log(r));\n}\n// 1/z\nvec2 rc(vec2 a)\n{ return vec2(a.x, -a.y) / dot(a,a); }\n\n// Parametric form for a cardioid\nvec2 cardioid(float a, float t)\n{ return 2.*a*(1.-cos(t))*eix(t); }\n// Normalizes fc (pixel coord) and centers on p with visible height of 2r\nvec2 transform(vec2 fc, vec2 iDim, vec2 p, float r)\n{ return r*(2.*fc - iDim)/iDim.y + p; }","name":"Common","description":"","type":"common"}]}