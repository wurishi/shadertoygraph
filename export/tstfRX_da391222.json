{"ver":"0.1","info":{"id":"tstfRX","date":"1605700317","viewed":117,"name":"Spherical Function Plotter","username":"csabix","description":"Useful for BRDFs. Use mouse RMB drag to rotate the sphere.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["importancesampling","brdf","sphericalfunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  return c.z * mix(K.xxx, clamp(abs(fract(c.xxx + K.xyz) * 6.0 - K.www) - K.xxx, 0.0, 1.0), c.y);\n}\n\nMaterial mat = METAL(.7,.5,.1,0.4);\nfloat alfa = radians(45.);\nvec3 v;\nfloat function(vec2 xy) {\n    vec3 n = vec3(0,0,1);\n    vec3 l = uniformSampling(xy).dir;\n    return brdf(n, l, v, mat).x * max(dot(n,l),0.);\n}\n\nstruct Ray {vec3 p, v;};\n\nRay Camera(in vec2 fragCoord) {\n    vec2 muv = iMouse.xy/iResolution.xy*vec2(2.*pi,1);\n    vec3 p = 2.5*vec3(sin(muv.x),muv.y, cos(muv.x));\n    vec3 forw = normalize(-p);\n    vec3 righ = normalize(cross(forw,vec3(0,1,0)));\n    vec3 upup = cross(righ, forw);\n   \tvec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    vec3 v = normalize(forw + righ*px.x+upup*px.y);\n    return Ray(p,v);\n}\n\nstruct Intersection {\n    float t;\n    vec2 uv;\n};\n    \nvec2 toSampleSpace(in vec3 p) {\n    p = normalize(p);\n    return vec2(atan(-p.y,-p.x), acos(p.z))/vec2(2.*pi,0.5*pi)+vec2(0.5,0);\n}\n\nIntersection intersectUnitSphere(Ray ray) {\n    //(p+tv)^2 - 1 = 0  -->  t^2 + 2pvt + pp-1 = 0 --> (t + pv)^2 = pvpv - pp + 1;\n    Intersection ret;\n\tfloat pp = dot(ray.p,ray.p), pv = dot(ray.p,ray.v);\n    float d = pv*pv-pp+1.;\n    if(d<0.) ret.t = -1.;\n    else     ret.t = -1.*sqrt(d)-pv;\n    vec3 p = ray.p + ret.t*ray.v;\n    ret.uv = toSampleSpace(p.xzy);\n    return ret;\n}\n\nvec2 PseudoRandom2D(in int i){\n    return fract(vec2(i*ivec2(12664745, 9560333))/exp2(24.0));\n}\n\nvoid drawSample(vec2 uv, vec2 xy, Sample sam, vec3 pointCol, inout vec3 origCol) {   \n    vec2 muv = toSampleSpace(sam.dir);\n#if WHAT_TO_ANIMATE == 2\n    muv = mix(xy, muv, .5*sin(1.31*iTime)+.5);\n#endif\n    float d  = length((uv-muv)*iResolution.xy);\n    float a = 2.*clamp(sam.weight,0.,1.)/(d*d*d);\n    origCol  = mix(origCol, pointCol, vec3(clamp(a,0.,1.)));    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor=vec4(0,0,0,1);\n    \n#if WHAT_TO_ANIMATE == 1\n\talfa = pi*0.5*(sin(iTime)*0.5+0.5);\n#endif\n    v = vec3(0, cos(alfa), sin(alfa));\n    \n#if WHAT_TO_ANIMATE == 3\n    mat.roughness = sin(iTime)*0.5+0.5+0.01;\n#endif\n    \n    Ray ray = Camera(fragCoord);\n    Intersection pt = intersectUnitSphere(ray);\n\n    if(pt.t>0.) uv = pt.uv;\n#if WHAT_TO_VISUALIZE == 1\n    float val = function(uv);//float val = uv.x*4.-2.; //see color range\n#endif\n    \n#if WHAT_TO_VISUALIZE == 2\n    const float divisor[] = float[](pi*pi,2.*pi,2.*pi);\n    float val = SAMPLE(uv,v,mat.roughness).weight/divisor[SAMPLING_METHOD];\n#endif\n    \n    vec3 hsv;\n    \n    if(val < 0.)\t\thsv = vec3(.5-val*.5, 1.          , .7/(1.5-val));\n    else if(val < 1.)\thsv = vec3(.5-val*.5, 1.          , 1.);\n    else\t\t        hsv = vec3(.5-val*.5, .7/(1.5+val), 1.);\n    fragColor.rgb = hsv2rgb(hsv);\n    \n    for(int i=0; i < 128; ++i) {\n        vec2 rand = PseudoRandom2D(i);\n        drawSample(uv, rand, SAMPLE(rand, v, mat.roughness), vec3(0), fragColor.rgb);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define WHAT_TO_ANIMATE 1\n//0 - Nothing. 45 degreee incoming angle, roughness of 0.5\n//1 - Light incoming angle\n//2 - Points interpolate between parameter space uniform and GGX\n//3 - Roughness between 0 and 1\n\n#define WHAT_TO_VISUALIZE 1\n//1 - BRDF\n//2 - Sample Weights\n\n#define SAMPLING_METHOD 2\n//0 uniform\n//1 cosine\n//2 GGX\n\nstruct Material {\n    vec3  color;        // [0,1/pi]\n    float roughness;    // [0,7]\n    vec3 emission;\t\t// [0, inf]\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};\n    \n#define LIGHT(r,g,b) Material(vec3(0), 1., vec3(r,g,b), 0.)\n#define METAL(r,g,b,m) Material(vec3(r,g,b), float(m), vec3(0,0,0), 0.9)\n#define NONMETAL(r,g,b,m) Material(vec3(r,g,b), float(m), vec3(0,0,0), 0.02)\n\nconst float pi = 3.1415926535897932384626433832795;    \n\nvec3 brdf(vec3 n, vec3 l, vec3 v, in Material mat)\n{\n    vec3 F0 = mat.color*mat.metalness;\n    vec3  h = normalize(l + v);\n\n    //CookTorrenceGeometry\n    float hn = max(dot(h, n), 0.0), vn = max(dot(v, n), 0.01);\n\tfloat ln = max(dot(l, n), 0.01), vh = max(dot(v, h), 0.0);\n    float G = min( 2.*hn*min( vn, ln)/vh, 1.0 );\n\n    //GGXDistribution\n    float hn2 = hn*hn, m2 = mat.roughness*mat.roughness;\n    float tmp = hn2*(m2-1.)+1.;\n    float D =  m2/(pi*tmp*tmp);\n\n    //SclickFresnel\n    vec3 F = F0 - (1.-F0)*pow(1.-hn,5.);\n\tvec3 specular  = D*F*G / (4. * vn * ln);\n\t\n\t// Lambertian BRDF\n\tvec3 diffuse = (1.-mat.metalness) * mat.color * (1. - F)/pi;\n    \n\treturn max(specular + diffuse,0.);\n}\n\nstruct Sample{\n    vec3 dir;\t\t// random direction\n    float weight;\t// weight of the sample\n};\t\t\t\t\t// typically multiplied by the domain and derivative of the mapping\n\n#if SAMPLING_METHOD==0\n#define SAMPLE(rand,v, roughness) uniformSampling(rand)\n#elif SAMPLING_METHOD==1\n#define SAMPLE(rand,v, roughness) cosineSampling(rand)\n#else\n#define SAMPLE(rand,v, roughness) GGXimportanceSampling(rand, v, roughness)\n#endif\n    \nSample uniformSampling(vec2 rand2d01)\n{\n    // uniform in phi and theta: 'classic' sphere parametrization\n    // thus, sin(theta) * dphi * dtheta is the weight\n    vec2 r = rand2d01*vec2(2.*pi,0.5*pi);\n    vec2 s = sin(r), c = cos(r);\n    return Sample(vec3(s[1]*vec2(c[0],s[0]),c[1]),\n                  s[1]*(pi*pi));\n}\n\nSample cosineSampling(vec2 rand2d01)\n{\n    vec2 r = rand2d01*vec2(2.*pi,-1)-vec2(0,-1);\n    float s = sqrt(1.-r.y*r.y);\n    return Sample(vec3(cos(r.x)*s, sin(r.x)*s, r.y),\n                  2.*pi);\n}\n\nSample GGXimportanceSampling(vec2 rand, vec3 v, float m) {\n    float m2 = m*m;\n    float a = 2.*pi*rand.x;\t\t\t\t\t\t\t\t//phi\n    float cb2 = abs((1.-rand.y)/(1.+(m2-1.)*rand.y));\t//cos(theta)^2\n    float cb = sqrt(cb2);\t\t\t\t\t\t\t\t//cos(theta)\n    float sb = sqrt(1.-cb2);\t\t\t\t\t\t\t//sin(theta)\n    \n    vec3 h = vec3(cos(a)*sb,sin(a)*sb,cb);\n    vec3 l = reflect(-v,h);\n    //float sq = cb2*(m2-1.)+1.;\n    \n    //float D = m2 /(pi*sq*sq); \n    //float PDF = m2*cb*sb/(pi*sq*sq); //=D(m)*cos(theta)*sin(theta)\n    l.z=abs(l.z);\n    float weight = 8.*pi * cb*sb*abs(dot(h,v));\n    return Sample(l, weight); //=PDF(m)/D(m)\n}\n\n\n//My old version for GGX importance sampling. My playground for sampling: https://www.shadertoy.com/view/tstfRX\nSample GGXimportanceSampling2(vec2 rand, vec3 v, float m) {\n    float m2 = m*m;\n    float a = 2.*pi*rand.x;\t\t\t\t\t\t\t  //phi\n    float cb2 = abs((1.-rand.y)/(1.+(m2-1.)*rand.y)); //cos(theta)^2\n    float cb = sqrt(cb2),sb = sqrt(1.-cb2);\t\t\t  //cos(theta),sin(theta)\n    vec3 h = vec3(cos(a)*sb,sin(a)*sb,cb);\n    vec3 l = reflect(-v,h);\n    //float sq = cb2*(m2-1.)+1.;\n    //float D = m2 /(pi*sq*sq); \n    //float PDF = m2*cb*sb/(pi*sq*sq); //=D(m)*cos(theta)*sin(theta)\n    float weight = 8.*pi * cb*sb * dot(h,l);\n    return Sample(l, max(weight,0.)); //=PDF(m)/D(m)\n}\n\n//My version for GGX importance sampling. My playground for sampling: https://www.shadertoy.com/view/tstfRX\nSample GGXimportanceSampling(vec2 rand2d01, vec3 n, vec3 v, float m) {\n\n    vec2 r = rand2d01*vec2(2.*pi,2)-vec2(0,1);\n    float s = sqrt(1.-r.y*r.y);\n    vec3 h = vec3(cos(r.x)*s, sin(r.x)*s, r.y);\n    float hn = dot(h,n);\n    \n    float cb2 = (1.-abs(hn))/(1.+(m*m-1.)*abs(hn));\t//cos(theta)^2\n    vec2 cs = sqrt(vec2(cb2,1.-cb2));\n    \n    h = normalize(h-hn*n);\n    h = normalize(h*cs.y + n*cs.x);\n    \n    vec3 l = reflect(-v,h);\n    \n    float weight = 8.*pi * cs.x * cs.y * dot(h,l);\n    return Sample(l, max(weight,0.)); //=PDF(m)/D(m)\n}","name":"Common","description":"","type":"common"}]}