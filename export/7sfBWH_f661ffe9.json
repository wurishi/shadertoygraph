{"ver":"0.1","info":{"id":"7sfBWH","date":"1644785673","viewed":90,"name":"Heart shaped box (Twitch)","username":"rimina","description":"Live coded during my stream 13th of February 2022. So Happy Valentine's day! <3\n\nThank you for the theme Eimink!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n\n//CappedCylinder function is from IQ and the AO method is from Flopine\n//https://iquilezles.org/articles/distfunctions\n//https://www.shadertoy.com/view/sdfyWl\n//thank you for your inspiring work <3\n\n//also huge thanks to the live coding community in general I've learned so much from you!\n\n\n#define PI 3.14159265\n\nconst float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 64;\n\nint M = 0;\n\n//https://iquilezles.org/articles/distfunctions\nfloat cappedCylinder(vec3 p, float h, float r){\n    vec2 d = abs(vec2(length(p.xz), p.y))-vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nvoid rot(inout vec2 p, float a){\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat heart(vec3 p, float height){\n    vec3 pp = p;\n    pp.x = abs(pp.x)-1.4;\n    rot(pp.xz, -PI*0.22);\n\n    float kaari = cappedCylinder(pp, 1.61, height);\n    pp -= vec3(-2., 0.0, 0.6);\n\n    float kulma = box(pp, vec3(2.0, height, 1.01));\n\n    return min(kaari, kulma);\n  \n}\n\nfloat scene(vec3 p){\n    vec3 pp = p;\n\n    pp += vec3(iTime, 0.0, 0.0);\n\n    pp.x = mod(pp.x+4.0, 8.0)-4.0;\n\n    rot(pp.yz, PI*0.22);\n    float heartBox =  heart(pp, 0.6);\n    pp -= vec3(0.0, 0.5, 0.0);\n    pp *= 0.98;\n    float heartLid = heart(pp, 0.2);\n    float hbox = min(heartBox, heartLid);\n\n\n    rot(pp.xz, 0.4);\n    vec2 m = mod(pp.xz, 4.0)-1.0;\n    if((m.y < -0.5 && m.y >-2.0) || (m.y > 0.25 && m.y < 0.75)){\n        M = 1;\n    }\n    else{\n        M = 0;\n    }\n\n    return hbox;\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = E;\n    vec3 p = ro;\n\n    for(int i = 0; i < STEPS; ++i){\n        float d = scene(p);\n        t += d;\n        p = ro + rd * t;\n\n        if(d < E || t > FAR){\n            break;\n        }\n    }\n\n    return t;\n}\n\nvec3 normals(vec3 p, float epsilon){\n    vec3 e = vec3(epsilon, 0.0, 0.0);\n\n    return normalize(vec3(\n        scene(p+e.xyy) - scene(p-e.xyy),\n        scene(p+e.yxy) - scene(p-e.yxy),\n        scene(p+e.yyx) - scene(p-e.yyx)\n    ));\n}\n\n//From Flopine <3\n//https://www.shadertoy.com/view/sdfyWl\nfloat ao(float e, vec3 p, vec3 n){\n    return scene(p+e*n)/e;\n}\n\nvec3 shade(vec3 p, vec3 rd, vec3 ld){\n    vec3 coll = vec3(0.8, 0.4, 0.5)*0.5;\n    vec3 cols = vec3(0.8, 0.0, 0.0);\n    float shiny = 20.0;\n\n    if(M != 0){\n    coll = vec3(1.0, 0.4, 0.5)*0.25;\n    shiny = 4.0;\n    }\n\n    vec3 n = normals(p, E);\n    float lamb = max(dot(n, ld), 0.0);\n    float a = max(dot(reflect(rd, ld), n), 0.0);\n    float spec = pow(a, shiny);\n\n    float aoc = ao(0.1, p, n) + ao(0.2, p, n) + ao(0.5, p, n);\n\n    return (coll * lamb + cols * spec)*aoc;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0 + 2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n  \n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rt = vec3(0.0, 0.0, -FAR);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x, y, z) * vec3(q, 1.0/radians(60.0)));\n\n\n\n    float t = march(ro, rd);\n    vec3 p = ro + rd*t;\n\n    vec3 ld = -z;\n\n    vec3 col = vec3(0.9, 0.7, 0.9);\n    if(t < FAR){\n    col = shade(p, rd, ld);\n    }\n\n    col = smoothstep(-0.2, 1.0, col);\n    col *= smoothstep(0.8, 0.1*0.799, distance(uv, vec2(0.5))*(0.6 + 0.1));\n  \n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}