{"ver":"0.1","info":{"id":"Md3XD4","date":"1459292823","viewed":289,"name":"Spline distance, polynomial opt","username":"JohanKohler","description":"Distance to quadratic bezier.\nUses a polynomial aproximation of cos(acos(x)/3)\nACos is a polynomial aprox on most GPU's so this should be faster.\nThe heavy lifting was done by Adrian Stephens.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["splinequadraticdistance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Distance to quadratic bezier.\n// Uses a polynomial aproximation of cos(acos(x)/3)\n// ACos is a polynomial aprox on most GPU's so this should be a bit faster.\n// The heavy lifting was done by my friend Adrian Stephens.\n\n#define COSSIN_THIRD_POLYNOMIAL\n\n\nfloat distanceSq(vec2 a, vec2 b)\n{\n    return dot(a-b,a-b);\n}\n\nfloat lengthSq(vec2 a)\n{\n    return dot(a,a);\n}\n\n\n\nvec2 cossin_third(float x ) \n{\n#ifdef COSSIN_THIRD_POLYNOMIAL\n    // polynomial aproximation of cos(acos(x)/3)\n    float c = (0.866017 +1.25203 * x + 0.431996 * x * x + 0.0161423 * x * x * x)\n        /(1.0 + 1.25325 * x + 0.312933 * x * x);\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n    \n#else\n    float c = cos(acos(x)/3.0);\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n#endif\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c )\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    \n    if(d >= 0.0) \n    {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    \n    vec2 cs = cossin_third(-sqrt(-27.0 / p3) * q / 2.0 );\n    float m = cs.x, n = cs.y * 1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n\n// Find the distance from a point to a bezier curve\nfloat dBezier(vec2 A, vec2 B, vec2 C, vec2 p )\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(solveCubic(k.x, k.y, k.z ), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = lengthSq(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, lengthSq(pos - p));\n    return sqrt(dis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dd = 10.0;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/(iResolution.y);\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/(iResolution.y),\n       \tvec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n\n\t// Define the control points of our curve\n  \tvec2 A = vec2(0.4, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n    \n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C)))) ;\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n\n    dd = min(dBezier(A, B, C, p ),dd );\n\n    // Visualize the distance field using iq's orange/blue scheme\n    vec4 col = vec4(1.0);\n    if (dd < 0.0)\n        col *= 0.5;\n    fragColor = col * (1.0 - exp(-4.0*abs(dd))) * (0.8 + 0.2*cos(140.*dd));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(dd)) );\n}","name":"Image","description":"","type":"image"}]}