{"ver":"0.1","info":{"id":"7td3RB","date":"1636324275","viewed":178,"name":"Orb Thingy","username":"SnoopethDuckDuck","description":"e","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"Nt3GDM","parentname":"aaaaaaaaaagergerg"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    \n    // zoom out, go up and down\n    float time = 0.6 * iTime;\n    uv *= 1.2;\n    uv.y += 0.04 * cos(iTime);\n   \n    float a = atan(uv.y, uv.x);\n    \n    float d = length(uv);\n    \n    float r1 = .5;       // largest radius\n    float r2 = .5 * .78; // interior radius\n    \n    // outer circle (1. -> lightest color)\n    float s1 = smoothstep(0., .03, r1 - d) - smoothstep(0.,0., r2 - d);\n\n    // offset circle for non-shadowed inner circle\n    float d2 = length(uv + .09 * vec2(-1, 1));\n\n    // 1./3. for shadow, 2./3. for non-shadowed bit\n    // (1./3. -> dark color, 2./3. -> mid color)\n    float s2 = step(d,r2) * (1. + step(d2, r2)) / 3.;\n    //float s2 = (1./3.) * step(d,r2) + (1./3.) * step(d, r2) * step(d2, r2);\n\n    // cba to comment this\n    float e = 0.08;\n    float r3 = (0.8 * r2 - e) + e * thc(4., thc(1., 4. * time) + time);\n    float s3 = smoothstep(-0.1, 0., r3 \n    + (r2-r3) * thc(4., 30. * length(uv) * thc(cos(time + 40. * length(uv)) * 4., a * 3. + time ) \n                  + 14. * a + 4. * time \n                  + 10. * thc(6.,1.2 * time) + a * 3.) - d);\n\n    float s = s1 + s2 - s3;\n    s = clamp(s, 0., 1.);\n    \n    vec3 col = lerpCol(0.25 * time, s);\n    // col = lerpCol(0.1 * time + .5 * a / pi, 1.);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.1415\n#define val 1.\n\nvec3 midCol(float t) {\n    float colTime = fract(val * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 220., 244.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(245., 208., 0.) / 255.;\n    else\n        col = vec3(219., 0., 255.) / 255.;\n    return col;\n}\n\nvec3 darkCol(float t) {\n    float colTime = fract(val * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 172., 246.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(236., 182., 0.) / 255.;\n    else\n        col = vec3(172., 0., 255.) / 255.;\n    return col;\n\n}\n\nvec3 lightCol(float t) {\n    float colTime = fract(val * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 255., 195.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(238., 243., 0.) / 255.;\n    else\n        col = vec3(255., 58., 235.) / 255.;\n    return col;\n}\n\nvec3 lerpCol(float t, float l) {\n    vec3 col;\n    // assuming 0 <= l <= 1\n    if (l < 1./3.) \n        col = mix(vec3(28, 28, 51) / 255., darkCol(t), vec3(3. * l));\n    else if (l < 2./3.)\n        col = mix(darkCol(t), midCol(t), vec3(3. * l - 1.));\n    else\n        col = mix(midCol(t), lightCol(t), vec3(3. * l - 2.));\n    \n    return col;\n}\n","name":"Common","description":"","type":"common"}]}