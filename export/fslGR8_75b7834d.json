{"ver":"0.1","info":{"id":"fslGR8","date":"1615836002","viewed":1170,"name":"Ray Marching Fractals","username":"ealitt","description":"Collection of fractals rendered with ray marching.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 10000\n#define MAX_DIST 10000.\n#define SURF_DIST 0.02\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nvec3 col = vec3(1.);\n\nstruct ray {\n    vec3 ori;\n    vec3 dir;\n};\n\n\nfloat smoothingFunc(float distA, float distB) {\n    float k = 3.;\n    float h = max(k - abs(distA-distB), 0.)/k;\n    return min(distA, distB) - h*h*h*k*1.0/6.0;\n}\n\nfloat sphereReflection(vec3 pt, vec4 obj) {\n    pt.y -= 1.;\n    pt.xz = mod(pt.xz, 2.) - vec2(1.);\n    return length(pt) - obj.w;\n}\n\nfloat sphere(vec3 pt) {\n    float radius = 1.;\n    vec4 sphere = vec4(0, radius, 0, radius);\n    //return abs(length(pt - sphere.xyz) - sphere.w); // hollow sphere distance estimator\n    //return max(0.0, length(pt - sphere.xyz) - sphere.w); // solid sphere with no interior (has artifacts)\n    return length(pt - sphere.xyz) - radius;\n}\n\n\n\nfloat infSphere(vec3 pt) {\n    // defined sphere\n    vec4 sphere = vec4(0, 1, 0, 1);\n    vec4 sphere2 = vec4(-2, 1, 6, 1);\n    \n    // sphere.w = radius of sphere\n    float sphereDist, sphereDist2;\n    sphereDist = length(pt - sphere.xyz) - sphere.w;\n    //sphereDist2 = length(pt - sphere2.xyz) - sphere2.w;\n    \n    //sphereDist = abs(length(pt - sphere.xyz) - sphere.w); // hollow sphere distance estimator\n    //sphereDist = max(0.0, length(pt - sphere.xyz) - sphere.w); // solid sphere with no interior (has artifacts)\n    \n    // mirrored version\n    sphereDist = sphereReflection(pt, sphere);\n    \n    // take the closer distance between sphere and plane\n    float DE;\n    //DE = max(sphereDist, sphereDist2 *(-1.));\n    \n    //DE = smoothingFunc(sphereDist, sphereDist2);\n    \n    DE = sphereDist;\n    \n    return DE;\n}\n\nfloat sdBox(vec3 pt, vec3 b) {\n    vec3 box = abs(pt) - b;\n    return length(max(box, 0.0)) + min(max(box.x, max(box.y, box.z)), 0.0);\n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nfloat sierpinskiPyramid(vec3 pt) {\n    vec3 ori = vec3(0.0,2.5,0.0);\n    vec3 a1 = vec3(1,1,1)+ori;\n\tvec3 a2 = vec3(-1,-1,1)+ori;\n\tvec3 a3 = vec3(1,-1,-1)+ori;\n\tvec3 a4 = vec3(-1,1,-1)+ori;\n    \n    vec3 c;\n    int n = 0;\n    float dist, d;\n    float scale = 2.;\n    while(n < 16) {\n        c = a1;\n        dist = length(pt - a1);\n        d = length(pt - a2);\n        if(d < dist) { \n            c = a2;\n            dist = d;\n        }\n        d = length(pt - a3);\n        if(d < dist) { \n            c = a3;\n            dist = d;\n        }\n        d = length(pt - a4);\n        if(d < dist) { \n            c = a4;\n            dist = d;\n        }\n        pt = scale * pt - c * (scale - 1.0);\n        n++;\n    }\n    \n    return length(pt) * pow(scale, float(-n));\n}\n\nfloat sierpinskiPyramidFold(vec3 pt) {\n    float r;\n    float offset = 1.;\n    float scale = 2.;\n    pt.y -= 2.5;\n    int n = 0;\n    while(n < 15) {\n        if(pt.x + pt.y < 0.) pt.xy = -pt.yx;\n        if(pt.x + pt.z < 0.) pt.xz = -pt.zx;\n        if(pt.y + pt.z < 0.) pt.zy = -pt.yz;\n        pt = pt * scale - offset*(scale - 1.0);\n        n++;\n    }\n    \n    return (length(pt) * pow(scale, -float(n)));\n}\n\nfloat mengerSponge(vec3 pt) {\n    float scale = 1.0;\n    float offset = -2.;\n    float iterations = 3.;\n\n    float dist = sdBox(vec3(pt.x, pt.y+offset, pt.z), vec3(scale));\n    \n    float s = 1.;\n    \n    float da, db, dc;\n    \n    for(int i = 0; i < 4; i++) {\n        vec3 a = mod(pt * s, 2.0) - 1.0;\n        s *= iterations;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        \n        da = max(r.x, r.y);\n        db = max(r.y, r.z);\n        dc = max(r.z, r.x);\n        \n        float c = (min(da, min(db, dc)) - 1.) / s;\n        if ( c > dist) dist = c;\n    }\n    \n    return dist;\n}\n\nfloat alteredMenger(vec3 pt){\n    float scale = 1.0;\n    float offset = -2.;\n    float iterations = 3.;\n\n    float dist = sdBox(vec3(pt.x, pt.y+offset, pt.z), vec3(scale));\n    \n    float s = 2.;\n    \n    float da, db, dc;\n    \n    for(int i = 0; i < 4; i++) {\n        vec3 a = mod(pt * s, 2.0) - 1.0;\n        s *= iterations;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        \n        r = (vec4(r, 1.0) * rotationX(20.)).xyz;\n        da = max(r.x+1.5, r.y);\n        r = (vec4(r, 1.0) * rotationY(80.)).xyz;\n        \n        da = max(da + r.x-0.5, r.y);\n        db = max(r.y, r.z);\n        dc = max(r.z+0.5, r.x);\n        \n        float c = (min(da, min(db, dc)) - 1.) / s;\n        if ( c > dist) dist = c;\n    }\n    \n    return dist;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotatePt(vec3 pt, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(pt, 1.0)).xyz;\n}\n\nfloat evolvingFractal(vec3 pt) {\n    //vec3 off = vec3(0.7, 0.5, 0.15);\n    //vec3 off = vec3(0.5, 0.85, 1.25);\n    vec3 off = vec3(1.);\n    float scale = 2.;\n    pt.y -= 2.5;\n    int n = 0;\n\n    while(n < 8) {\n        //pt = rotatePt(pt, vec3(1.), 31.); // snowflake\n        pt = rotatePt(pt, vec3(1), cos(10.+iTime*0.1));\n        \n        pt = abs(pt); // for cube\n        \n        if(pt.x + pt.y < 0.) pt.xy = -pt.yx;\n        if(pt.x + pt.z < 0.) pt.xz = -pt.zx;\n        if(pt.y + pt.z < 0.) pt.zy = -pt.yz;\n          \n        pt = rotatePt(pt, vec3(0.35,0.2,0.3), -90.+iTime*0.1);\n        \n        pt.x = pt.x * scale - off.x*(scale - 1.0);\n        pt.y = pt.y * scale - off.y*(scale - 1.0);\n        pt.z = pt.z * scale - off.z*(scale - 1.0);\n        \n        pt = rotatePt(pt, vec3(0.3,0.1,0.25), -70.+iTime*0.1);\n        \n        n++;\n    }\n    return (length(pt) * pow(scale, -float(n)));\n}\n\nfloat evolvingFractal2(vec3 pt) {\n    vec3 off = vec3(1.25);\n    float scale = 2.;\n    pt.y -= 2.5;\n    int n = 0;\n\n    while(n < 10) {\n        //pt = rotatePt(pt, vec3(1.), 31.); // snowflake\n        pt = rotatePt(pt, vec3(1.), sin(0.+iTime*0.1));\n        \n        pt = abs(pt); // for cube\n        \n        if(pt.x + pt.y < 0.) pt.xy = -pt.yx;\n        if(pt.x + pt.z < 0.) pt.xz = -pt.zx;\n        if(pt.y + pt.z < 0.) pt.zy = -pt.yz;\n          \n        pt = rotatePt(pt, vec3(0.35,0.2,0.3), -90.+iTime*0.1);\n        \n        pt.x = pt.x * scale - off.x*(scale - 1.0);\n        pt.y = pt.y * scale - off.y*(scale - 1.0);\n        pt.z = pt.z * scale - off.z*(scale - 1.0);\n        \n        pt = rotatePt(pt, vec3(0.3,0.1,0.25), -70.+iTime*0.1);\n        \n        n++;\n    }\n    return (length(pt) * pow(scale, -float(n)));\n}\n\n// distance from pt to closest object\nfloat getDist(vec3 pt) {\n    float DE;\n    \n    //DE = sphere(pt);\n    //DE = infSphere(pt);\n    //DE = sierpinskiPyramid(pt);\n    //DE = sierpinskiPyramidFold(pt);\n    //DE = mengerSponge(pt);\n    //DE = alteredMenger(pt);\n    //DE = evolvingFractal(pt);\n    DE = evolvingFractal2(pt);\n\n    // DE for ground plane\n    float planeDist = pt.y;\n    DE = min(DE, planeDist);\n    \n    return DE;\n}\n\nvec3 getNormal(vec3 pt) {\n    // distance of pt to closest object\n    float dist = getDist(pt);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 offset = dist - vec3(\n        getDist(pt - e.xyy),\n        getDist(pt - e.yxy),\n        getDist(pt - e.yyx));\n        \n    return normalize(offset);\n}\n\n// input: ray from camera\n// ouptut: distance from surface\nfloat rayMarch(ray r) {\n\n    // distance marched\n    float marchDist = 0.;\n    vec3 marchForward;\n    int i;\n    for(i = 0; i < MAX_STEPS; i++) {\n        // move in steps towards object along ray direction\n        marchForward = r.ori + r.dir * marchDist;\n        \n        // finds distance to object\n        float distToScene = getDist(marchForward);\n        \n        // update march distance variable\n        marchDist += distToScene;\n        \n        // if ray goes off to infinity\n        // or ray is close within specified surface distance\n        // then exit loop\n        if(marchDist > MAX_DIST || distToScene < SURF_DIST) break;\n    }\n    \n    //col = vec3(i)*0.1; // for a light shadow\n    //if(i < 6 && marchForward.y > 0.25 && (marchForward.x > 0.2 || marchForward.x < -0.2)) col = vec3(1., 0., 0.);\n    \n    return marchDist;\n}\n\n// input: point to be shaded\n// output: light value\nfloat getLight(vec3 pt) {\n    // define light source location\n    vec3 lightPos = vec3(-3, 8, -5);\n    //vec3 lightPos = vec3(-3, 20, -20);\n    \n    // make moving light\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    \n    // normalized light vector\n    vec3 lightVec = normalize(lightPos - pt);\n    \n    // normal direction from pt\n    vec3 ptNormal = getNormal(pt);\n    \n    //col += ptNormal;\n\n    // calculate diffuse\n    float dif = clamp(dot(ptNormal, lightVec), 0., 1.);\n    \n    // make shadow ray to calculate shadows\n    ray shadowRay = ray(pt + ptNormal*SURF_DIST*2., lightVec);\n    float shadowRayDist = rayMarch(shadowRay);\n    \n    // length: returns distance between points\n    // if shadow ray is occluded, ignore ray\n    if(shadowRayDist < length(lightPos - pt)) dif *= .01;\n    \n    return dif*1.25;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // centers uv\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rayDir\t= normalize(vec3(uv.x, uv.y, 1.));\n    \n    vec2 res\t= iResolution.xy;\n    vec3 camPos = vec3(0., 1.75, -6.);\n    //vec3 camPos = vec3(0., 10.75, -6.);\n    vec2 mPos\t= 3.5 * (iMouse.xy-.5*res) / res.y;\n    \n    camPos.yz = rotate(camPos.yz, mPos.y);\n    camPos.xz = rotate(camPos.xz, mPos.x);\n    rayDir.yz = rotate(rayDir.yz, mPos.y);\n    rayDir.xz = rotate(rayDir.xz, mPos.x);\n    // simple camera\n    ray r = ray(camPos,\n                rayDir);\n        \n    float dist = rayMarch(r);\n    \n    // 3 dim point where intersection is calculated from rayMarch\n    vec3 intersectPt = r.ori + r.dir * dist;\n    \n    // calculate diffuse lighting\n    float dif = getLight(intersectPt);\n    //if(dif == 0.) dif += 0.5;\n    \n    col *= vec3(dif);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}