{"ver":"0.1","info":{"id":"ls3XDf","date":"1461849955","viewed":474,"name":"itsa me mario","username":"omgs","description":"Singing Mario head\n(only tested with chrome64 on a windows machine)\n","likes":17,"published":1,"flags":96,"usePreview":0,"tags":["3d","sound","model","mario","singing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by omgs 2016\n// Singing Mario Head\n\n// Special thanks to IQ for sharing all the raymarching techniques with everyone\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an =  10.0*mouseX;\n\tcamPos = vec3(-4.5*sin(an),1.0+cos(2.0+iDate.w*0.5),-4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec3 rotx(vec3 p, float rx) {\n    float sinx = sin(rx);\n    float cosx = cos(rx);\n    return mat3(1., 0., 0., 0., cosx, sinx, 0., -sinx, cosx) * p;\n}\n\nvec3 roty(vec3 p, float ry) {\n    float sinx = sin(ry);\n    float cosx = cos(ry);\n    return mat3(cosx, 0., -sinx, 0., 1., 0., sinx, 0., cosx) * p;\n}\n\nvec3 rotz(vec3 p, float rz) {\n    float sinx = sin(rz);\n    float cosx = cos(rz);\n    return mat3(cosx, sinx, 0., -sinx, cosx, 0., 0., 0., 1.) * p;\n}\n\nvec3 rot(vec3 p, vec3 r) {\n    return rotx(roty(rotz(p, r.z), r.y), r.x);\n}\n\n\n\n\nvec2 doModel( vec3 p )\n{\n   \n    \n    const int arrsize=7;\n    float scene[arrsize];\n    float id=-1.;\n    vec3 porg=p;\n    //head\n    p.x = abs(p.x);   // <------ Thanks for tip iapafoto :)\n    \n    float s = sdEllipsoid(p, vec3(0.4, 0.44, 0.4)*3.);\n  //  s = smax(s,-sdEllipsoid(p+vec3(0.4,-0.5,1.15), vec3(0.3, 0.5, 0.2)*1.1 ) , .05); //rsocket\n    s = smax(s,-sdEllipsoid(p+vec3(-0.4,-0.5,1.15), vec3(0.3, 0.5, 0.2)*1.1 ) , .05); //lsocket\n    s = smin(s,sdEllipsoid(p+vec3(0.,0.1,1.45), vec3(0.4, 0.4, 0.4) ) , .05); //nose\n    s = smin(s,sdEllipsoid(p+vec3(0.,0.85,.4), vec3(0.6, 0.5, 0.6)*1.2 ) , 0.3); //chin\n    s = smin(s,sdEllipsoid(p+vec3(-0.8,0.35,.4), vec3(0.2, 0.4, 0.35)*1.3 ) , 0.3); //rcheek\n  //  s = smin(s,sdEllipsoid(p+vec3(0.8,0.35,.4), vec3(0.2, 0.4, 0.35)*1.3 ) , 0.3); //lcheek\n    //left ear\n \n\ts = smin(s,sdEllipsoid(roty(p+vec3(-1.15,-0.15,.25), 0.7 ), vec3(0.3, 0.35, 0.15)*1.2 ) , .05);\n    s = smax(s,-sdEllipsoid(roty(p+vec3(-1.35,-0.15,.3), 0.5 ), vec3(0.3, 0.35, 0.15)*0.9 ) , .06);\n        \n    //right ear\n   // s = smin(s,sdEllipsoid(roty(p+vec3(1.15,-0.15,.25), -0.7 ), vec3(0.3, 0.35, 0.15)*1.2 ) , .05);\n   // s = smax(s,-sdEllipsoid(roty(p+vec3(1.35,-0.15,.3), -0.5 ), vec3(0.3, 0.35, 0.15)*0.9 ) , .06);\n    \n    p=porg; \n    p.y += cos(p.x*5.)*0.1; //smiley wave for mouth\n     float musicBuf = texture(iChannel0,gl_FragCoord.xy/iResolution.xy).w;\n     \n    s = smax(s,-sdEllipsoid(p+vec3(0.,0.7+sin(0.01+iDate.w*(0.01+musicBuf*0.5) )*0.1 ,1.15), vec3(0.6-cos(0.01+iDate.w*(0.1+musicBuf*1.5) )*0.2, 0.1, 0.2)*1.1 ) , .05); //mouth\n    p=porg; //reset smiley wavey\n    \n    scene[0] = s;\n    //Lefteye\n    float s1 = sdEllipsoid(rotx(p+vec3(0.3,-0.3,.96),-0.25  ), vec3(0.3, 0.4, 0.1)*1.1); \n    scene[1] = s1;\n    //Righteye\n    float s2 = sdEllipsoid(rotx(p+vec3(-0.3,-0.3,.96),-0.25  ), vec3(0.3, 0.4, 0.1)*1.1); \n    scene[2] = s2;\n    //teeth\n    p.y += cos(p.x*5.)*0.1; //smiley wave for teeth\n    float s3 = udRoundBox( p+vec3(0,0.45,0.91), vec3(0.2,0.05,.001), 0.2 );\n    scene[3] = s3;\n     p=porg; //reset smiley teeth wave\n    \n    float s4 =   s = min(s,sdEllipsoid(p+vec3(0.,0.85,.76), vec3(0.4, 0.2, 0.3) )); //tounge\n    scene[4] = s4;\n    \n    p.y +=cos(-0.7+p.z*4.)*0.1; //wavey for hat\n    float s5 =   s = sdEllipsoid(rotx( p+vec3(0.,-.7,-.2),-0.8 ), vec3(1.1, 0.7, 1.4) )-0.02; //hat\n    p=porg;\n    s5 = smin(s5, s = sdEllipsoid(rotx( p+vec3(0.,-.75,.6),-0.5 ), vec3(.4, 0.05, .4) ),0.2 ); //cap\n    scene[5] = s5-0.07;\n    \n    p.y +=cos(p.x*4.)*0.2; //wavey for mustach\n    float s6 = udRoundBox( p+vec3(0,0.25,1.2), vec3(0.7,0.01,.001), 0.1 );\n    p.y +=cos(p.x*15.)*0.03; //wavey for mustach\n    s6 = smin(s6, udRoundBox( p+vec3(0,0.4,1.2), vec3(0.6,0.01,.001), 0.15 ) , 0.2);\n   \n      p.x = abs(p.x);\n   //  s6 = min(s6, udRoundBox(rotz( p+vec3(.84,-0.28,.55) , 1.9), vec3(0.35,0.12,.1), 0.05 ) ); //sideburn\n     s6 = min(s6, udRoundBox(rotz( p+vec3(-.84,-0.28,.55) , -1.9), vec3(0.35,0.12,.1), 0.05 ) );//sideburn\n    p=porg;\n    p.y +=cos(p.z*4.)*0.1; //wavey for hair\n    p.y +=cos(p.x*8.)*0.1; //wavey for hair\n     s6 = min(s6, sdCylinder( p+vec3(0,0.4,-0.17), vec2(1.15,.4) ) )-0.03;\n    p=porg;\n    \n     p.x = abs(p.x);\n     p.y +=cos(0.6+p.x*8.)*0.1; //wavey for \n     s6 = smin(s6, udRoundBox(rotz( p+vec3(-0.38,-0.68+sin(0.01+iDate.w*(0.1+musicBuf*0.2) )*0.005,.9),sin(0.01+iDate.w*(0.1+musicBuf*0.2) )*0.1 ), vec3(0.2,0.01,.001), 0.06 ) , 0.2);//eyebrow\n   //  p.y +=cos(-0.8+p.x*8.)*0.1;//wavey for eyebrow\n    // s6 = smin(s6, udRoundBox( p+vec3(0.38,-0.65,.9), vec3(0.2,0.01,.001), 0.06 ) , 0.2);//eyebrow\n     scene[6] = s6;\n    \n      float test=9999.0;  //return nearest object for material id\n    for(int i=0;i<arrsize;i++){\n        float test2=scene[i];\n        if(test2<test)\n        {\n            test=test2; \n         \tid = float(i);\n        }\n    }\n    \n    \n    return vec2(test,id);\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec2 obj = doModel(pos);\n    vec3 col;\n    \n    if(obj.y==0.) col = vec3(135./255.,60./255.,30./255.)*0.9;\n    \n    if(obj.y==1.) //eyeColor\n     {\n        col = vec3(0.3);\n        if(nor.x*nor.x*3.+nor.x*0.7 + nor.y*0.6 -.1 <0.12)col=vec3(0,0,0.1)+0.05;\n         if(nor.x*nor.x*3.+nor.x*0.5 + nor.y*0.6 -.1 <0.07)col=vec3(0,0,0)+0.01;\n \n    }\n    if(obj.y==2.)//eyeColor\n    {\n        col = vec3(0.3);\n          if(nor.x*nor.x*3.+nor.x*-0.7 + nor.y*0.6 -.1 <0.12)col=vec3(0,0,0.1)+0.05;\n         if(nor.x*nor.x*3.+nor.x*-0.5 + nor.y*0.6 -.1 <0.07)col=vec3(0,0,0)+0.01;\n\n    }\n    \n    if(obj.y==3.) col = vec3(0.3);\n    if(obj.y==4.) col = vec3(0.2,0,0);\n    if(obj.y==5.) col = vec3(0.2,0,0);\n    if(obj.y==6.) col = vec3(135./255.,69./255.,19./255.)-0.5; //mustach\n    return col;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n    vec3  lig = normalize(vec3(1.0,0.7,-0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    lin += vec3(0.50,0.50,0.50);\n\n    vec3 col = mal*lin;\n\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 5.0;          \n\tconst float precis = 0.001;       \n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<50; i++ )        \n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;            \n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 \n\tfloat h = 1.0;\n    for( int i=0; i<13; i++ )        \n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t ); \n\t\tt += clamp( h, 0.02, 2.0 );   \n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 ); \n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) );\n\tvec3 col;\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n    else \n    { col = texture(iChannel0,fragCoord.xy/iResolution.xy*2.5).xyz\n        *texture(iChannel0,-.3+fragCoord.xy/iResolution.xy).xyz+vec3(1.,0.,1.);\n    \tif(col.y>0.) col*=vec3(0.1,0.1,1.);\n    }\n\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsf3zl","filepath":"https://soundcloud.com/elhestia/super-mario-world-overworld","previewfilepath":"https://soundcloud.com/elhestia/super-mario-world-overworld","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"///////STARS IN BACKGROUND BY USER stebi\n///////// source : https://www.shadertoy.com/view/4tfGWr#\n\n// Parameters to play with:\nconst float segments = 5.0;\nconst float indent = 0.08;\nconst float softness = 0.;\n\n// constants\nconst float pi = 3.141592654;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - vec2(0.5, 0.5);\n    q *= normalize(iResolution).xy;\n    float distance = length(q);\n    float progress = (sin(iTime) + 1.0) / 2.0;\n    \n    vec4 col;\n    col = vec4(0,0,1,0);\n\n    float angle = (atan(q.y, q.x) + pi) / (2.0 * pi); // 0-1\n    \n    float segment = angle * segments;\n    \n    \n    float segmentI = floor(segment);\n    float segmentF = fract(segment);\n        \n    angle = (segmentI + 0.5) / segments;\n    if (segmentF > 0.5) {\n        angle -= indent;\n    } else\n    {\n        angle += indent;\n    }\n    angle *= 2.0 * pi;\n\n\tvec2 outline;\n\toutline.y = sin(angle);\n    outline.x = cos(angle);\n\n\tdistance = abs(dot(outline, q));\n    \n    col *= smoothstep(progress, progress + softness * progress, distance * 22.0);\n\n\tif(col.z< 0.4)col.xyz=vec3(0.0,0.2,0.1);\n    else col.xyz = vec3(1.);\n    \n    \n    vec3 music = texture(iChannel0,p*22.).xyz;\n    \n\n    float musicBuf = texture(iChannel1,p).w;\n\n    float mouth = musicBuf;\n    if(music.x > .5 && music.y > .61) mouth+=0.0001;\n\t\n    if(mouth>0.) mouth-=0.01;\n    \n    fragColor = vec4(col.xyz,mouth);\n}","name":"Buf A","description":"","type":"buffer"}]}