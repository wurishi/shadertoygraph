{"ver":"0.1","info":{"id":"DlBGW3","date":"1673981612","viewed":89,"name":"Conway's Game of Life (buffered)","username":"FliegendeWurst","description":"Really simple implementation of Conway's Game of Life, uses a texture to store which cells are currently alive / dead.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Conway's Game of Life\" by FliegendeWurst - January 2023\n//\n//\tLicensed under a Creative Commons Attribution 4.0 International License\n//\thttp://creativecommons.org/licenses/by/4.0/\n// ----------------------------------------------------------------------------------------\n\n// click on Buffer A above and follow the instructions to load another seed ...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Load a configuration by executing one of the commands below in the browser dev console.\n// source of this trick: https://www.shadertoy.com/view/lsGGDd\n// \n// four gliders:\n// gShaderToy.SetTexture(1, {mSrc:'https://i.imgur.com/x58NmzS.png', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n// Gosper glider gun:\n// gShaderToy.SetTexture(1, {mSrc:'https://i.imgur.com/mDucweL.png', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor *= 0.;\n    if (iFrame <= 30) {\n        vec2 pos = floor(fragCoord - 0.5 * vec2(iResolution) + 0.5 * vec2(iChannelResolution[1]));\n        bool alive = texelFetch(iChannel1, ivec2(pos), 0).x > 0.5;\n        fragColor = vec4(alive ? 1.0 : 0.0);\n        return;\n    }\n    bool alive = texelFetch(iChannel0, ivec2(fragCoord), 0).x > 0.0;\n    int neighborsAlive = 0;\n    ivec2 pos = ivec2(fragCoord);\n    for (int dy = -1; dy <= 1; dy++) {\n        for (int dx = -1; dx <= 1; dx++) {\n            if (dy != 0 || dx != 0) {\n                ivec2 finalPos = pos + ivec2(dx, dy);\n                // cyclical world:\n                finalPos += ivec2(iChannelResolution[0]);\n                finalPos %= ivec2(iChannelResolution[0]);\n                neighborsAlive += int(texelFetch(iChannel0, finalPos, 0).x);\n            }\n        }\n    }\n    if (!alive && neighborsAlive == 3) {\n        fragColor = vec4(1.0);\n    } else if (alive && (neighborsAlive < 2 || neighborsAlive > 3)) {\n        fragColor = vec4(0.0);\n    } else if (alive) {\n        fragColor = vec4(1.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}