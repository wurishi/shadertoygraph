{"ver":"0.1","info":{"id":"lddXDr","date":"1458876525","viewed":180,"name":"Deathly Hallows","username":"Hanley","description":"Symbol of Harry Potter and the Deathly Hallows.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\n// function PolygonDF (in pos, number of corners)\n    // return distance field\n\nfloat polygonDistanceField(in vec2 pixelPos, in int N) {\n    // N = number of corners\n    float a = atan(pixelPos.y, pixelPos.x) + PI/2.; // angle\n    float r = TWO_PI/float(N); // ~?\n\n    // shapping function that modulates the distances\n    float distanceField = cos(floor(0.5 + a/r) * r - a) * length(pixelPos);\n\n    return distanceField;\n}\n\nfloat stretchedPolygon(in vec2 st, in float r, in int N, in float stretch_n) {\n    float d; // distance field\n\n    // Triangle Outer\n    float stretchAmount = mix(1., 30., stretch_n);\n    float outerRadius = mix(r+0.01, r+0.05, stretch_n);\n    float outerMidRadius = mix(r+0.005, r-0.05, stretch_n);\n\n    vec2 st_stretched = st.xy;\n    st_stretched.x *= stretchAmount;\n    d = polygonDistanceField(st_stretched, N);\n\n    float triangleOuter = smoothstep(outerRadius, outerMidRadius, d);\n\n    return triangleOuter;\n}\n\n/**\n    Linear Mapping function from processing.\n*/\nfloat map(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\nfloat mapAndCap(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    float v = ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n    v = max( min(ostart,ostop), v);\n    v = min( max(ostart,ostop), v);\n    return v;\n}\n\n/**\n    float r - polygon radius\n    int N - polygon corners\n    float stretch_n - stretch amount, from 0. to 1.\n*/\nfloat stretchedPolygonOutline(in vec2 st, in float r, in int N, in float stretch_n) {\n    float d; // distance field\n\n    // Triangle Outer\n    float triangleOuter = stretchedPolygon(st, r, N, stretch_n);\n\n    // Triangle Inner // ~ could be factored in as stretchedPolygon in future\n    float innerStretchAmount = mix(1., 60., stretch_n);\n    float innerMidRadius = mix(r-0.005, r-0.05, stretch_n);\n    float innerRadius = mix(r-0.01, r-0.1, stretch_n);\n\n    vec2 st_stretchedInner = st.xy;\n    st_stretchedInner.x *= innerStretchAmount;\n    d = polygonDistanceField(st_stretchedInner, N);\n\n    float triangleInner = smoothstep(innerMidRadius, innerRadius, d);\n\n    // Triangle Outline\n    float triangleOutline = triangleOuter - triangleInner;\n\n    return triangleOutline;\n}\n\n/**\n    returns smallest absoluate angular difference - return value ranges from 0.0 to +Ï€. \n*/\nfloat minAngularDifference(in float angleA, in float angleB) {\n    // Ensure input angles are -Ï€ to Ï€\n    angleA = mod(angleA, TWO_PI);\n    if (angleA>PI) angleA -= TWO_PI;\n    if (angleA<PI) angleA += TWO_PI;\n    angleB = mod(angleB, TWO_PI);\n    if (angleB>PI) angleB -= TWO_PI;\n    if (angleB<PI) angleB += TWO_PI;\n\n    // Calculate angular difference\n    float angularDiff = abs(angleA - angleB);\n    angularDiff = min(angularDiff, TWO_PI - angularDiff);\n    return angularDiff;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n  \tvec2 u_mouse = iMouse.xy;\n  \tvec2 u_resolution = iResolution.xy;\n    \n    vec2 st = fragCoord.xy/u_resolution.xy; // pixel_n\n    st.x -= 0.2; // UPDATE: Centreing Tip from jackdavenport\n    st.x *= u_resolution.x / u_resolution.y; // quick aspect ratio fix\n    float t = u_time;\n\n    vec2 mouse_n = u_mouse.xy / u_resolution;\n    \n    // remap space from [0.,1.] to [-1.,1.]\n    st = st * 2.-1.;\n\n    // TIMELINE\n    float timeline = mod(t*.3, 1.);\n    // float shapeEntry = mapAndCap(pow(timeline, 2.), 0., 0.4, 0., 1.);// mix(0., 1., timeline*2.0);\n    float cirEntryProgress = mapAndCap(pow(timeline, 2.), 0., 0.25, 0., 1.);;\n    float triEntryProgress = mapAndCap(pow(timeline, 1.), 0.15, 0.9, 0., 1.);\n    float stretchProgress = mapAndCap(timeline, 0.75, 1.0, 0., 1.);\n    float exitFade = mapAndCap(pow(timeline, .35), 0.7, 1.0, 1., 0.);\n\n    // STRETCH\n    float stretchAmount = pow(stretchProgress, 4.);\n\n    // OUTLINES\n    float triangleOutline = stretchedPolygonOutline(st, 0.3, 3, stretchAmount);\n    float circleOutline = stretchedPolygonOutline(st, 0.3, 100, stretchAmount);\n    float midStroke = stretchedPolygon(st, 0.3, 3, 1.);\n\n    // LIGHT MASK\n    float curAngle = atan(st.y, st.x); // ranges [-Ï€,+Ï€]\n    float targetAngle;\n    float angularDiff;\n    float edge0, edge1;\n    float outlineFade;\n\n    // CIRCLE    \n    targetAngle = mix(0., TWO_PI, cirEntryProgress) + PI*.5; \n    angularDiff = minAngularDifference(curAngle, targetAngle);\n    edge0 = mix(0., PI, cirEntryProgress);\n    edge1 = mix(1., PI, cirEntryProgress*PI);\n    circleOutline *= 1. - smoothstep(edge0, edge1, angularDiff);\n    outlineFade = mix(0., 1., cirEntryProgress*10.);\n    circleOutline *= outlineFade;\n\n    // TRIANGLE\n    targetAngle = mix(0., TWO_PI, triEntryProgress) + PI*.5; \n    angularDiff = minAngularDifference(curAngle, targetAngle);\n    edge0 = mix(0., PI, triEntryProgress);\n    edge1 = mix(0., PI*PI*.75, triEntryProgress);\n    outlineFade = mix(0., 1., triEntryProgress*5.);\n    triangleOutline *= 1.-smoothstep(edge0, edge1, angularDiff);\n    triangleOutline *= outlineFade;\n\n    // Brightness\n    float b = (triangleOutline + circleOutline)*exitFade + midStroke;\n    vec3 color = vec3(b);\n    \n    fragColor = vec4(color, 1.0);\n    \n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"}]}