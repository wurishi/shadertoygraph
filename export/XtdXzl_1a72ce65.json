{"ver":"0.1","info":{"id":"XtdXzl","date":"1481217802","viewed":1233,"name":"Physically Based Rendering","username":"sergey_reznik","description":"- microfacet model (GGX correlated/Shlick)\n- analytical and image based lighting combined\n- importance sampling from environment map","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","microfacet","pbr","cooktorrance","pbs","physicallybased","importance","importancesamplign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SphereRows \t\t\t\t2\n#define SphereCols \t\t\t\t9\n#define NumSpheres \t\t\t\t(SphereRows * SphereCols)\n\n#define PI \t\t\t\t\t\t3.1415926536\n#define MAX_CUBEMAP_SAMPLES \t100\n\n#define USE_ANALYTICAL\t\t\t0\n#define USE_IBL \t\t\t\t1\n#define COLORIZE \t\t\t\t0\n\n#define HEIGHT_CORRELATED_SMITH true\n#define FRESNEL_SHLICK\t\t\tfalse\n\n#define DIFFUSE_SCALE \t\t\t1.0\n#define SPECULAR_SCALE \t\t\t1.0\n\nconst vec4 lightPosition = vec4(0.0, 40.0, 0.0, 0.0);\nconst vec3 lightColor = vec3(1.0);\nconst vec3 ambientColor = vec3(0.0);\n\nconst float spheresRadius = 2.5;\nconst float gap = 0.2;\n\nstruct Sphere\n{\n    vec3 cen;\n    float rad;\n} spheres[NumSpheres];\n\nstruct Material\n{\n    vec3 baseColor;\n    float roughness;\n    float metallness;\n} materials[NumSpheres];\n\nMaterial planeMaterial;\n\nstruct LightVariables\n{\n    float LdotN;\n    float VdotN;\n    float HdotN;\n    float HdotV;\n    float HdotL;\n    float shadow;\n    float roughness;\n    vec4 f0;\n};\n\nvoid prepareScene();\nfloat calculateSphereIntersection(in vec3 ro, in vec3 rd, in Sphere sph);\nfloat calculatePlaneIntersection(in vec3 ro, in vec3 rd);\nvec3 getNormal(in vec3 pos, in Sphere sph);\n\nfloat randomFloat(vec3 co);\nvec3 perpendicularVector(in vec3 nrm);\nvec3 randomDirection(in vec3 base, in vec3 u, in vec3 v, in float r2, in vec3 seed);\nvec3 sampleDiffuseEnvironment(in vec3 dir);\nvec3 sampleReflectedEnvironment(in vec3 dir, in float r, in float f0);\n\n#define SHADOW_SAMPLES 50\n\nfloat calculateShadow(in vec3 pos)\n{\n    vec3 n = normalize(lightPosition.xyz - pos * lightPosition.w);\n    vec3 u = perpendicularVector(n);\n\tvec3 v = cross(u, n);\n    vec3 dir = n;\n    \n    float result = 0.0;\n    for (int s = 0; s < SHADOW_SAMPLES; ++s)\n    {\n        dir = randomDirection(n, u, v, 0.02, dir + pos + result);\n\t    for (int i = 0; i < NumSpheres; ++i)\n        {\n    \t    result += float(calculateSphereIntersection(pos, dir, spheres[i]) > 0.0);\n        }\n    }\n    \n    return 1.0 - result / float(SHADOW_SAMPLES);\n}    \n\n    \nfloat D_GGX(float r4, float NoH)\n{\n    float d = NoH * NoH * (r4 - 1.0) + 1.0;\n    return r4 / (d * d);\n}\n\nfloat G_Smith(in float NoV, in float NoL, in float r4)\n{\n\tfloat Vis_SmithV = NoV + sqrt(NoV * (NoV - NoV * r4) + r4);\n    float Vis_SmithL = NoL + sqrt(NoL * (NoL - NoL * r4) + r4);\n    return 1.0 / (Vis_SmithV * Vis_SmithL);\n}\n\nfloat G_SmithJointApprox(float NoV, float NoL, in float r2)\n{\n\tfloat Vis_SmithV = NoL * (NoV * (1.0 - r2) + r2);\n    float Vis_SmithL = NoV * (NoL * (1.0 - r2) + r2);\n\treturn 0.5 / (Vis_SmithV + Vis_SmithL);\n}\n\nvec3 F_Fresnel(vec3 clr, float VoH)\n{\n\tvec3 clrSqrt = sqrt(clamp(vec3(0.0, 0.0, 0.0), vec3(0.99, 0.99, 0.99), clr));\n\tvec3 n = (1.0 + clrSqrt) / (1.0 - clrSqrt);\n\tvec3 g = sqrt(n * n + VoH * VoH - 1.0);\n    vec3 s = (g - VoH) / (g + VoH);\n    vec3 p = ((g + VoH) * VoH - 1.0) / ((g - VoH) * VoH + 1.0);\n\treturn 0.5 * s * s * (1.0 + p * p);\n}\n\nvec3 F_Shlick(in vec3 f0, in vec3 fd90, float VoH)\n{\n    return f0 + (fd90 - f0) * pow(1.0 - VoH, 5.0);\n}\n\nfloat microfacetSpecular(in LightVariables lv)\n{\n#if (USE_ANALYTICAL)\n    float r2 = lv.roughness * lv.roughness;\n    \n    float r4 = r2 * r2;\n    \n    float D = D_GGX(r4, lv.HdotN);\n    \n    float G = HEIGHT_CORRELATED_SMITH ? \n        G_SmithJointApprox(lv.VdotN, lv.LdotN, r2) : \n    \tG_Smith(lv.VdotN, lv.LdotN, r4);\n        \n    return D * G * lv.LdotN / PI;\n#else\n    return 0.0;\n#endif\n}\n\n\nfloat lambertDiffuse(in LightVariables lv)\n{\n    return lv.LdotN / PI;\n}\n\nvec3 shadeFragment(in vec3 pos, in vec3 nrm, in vec3 view, in Material mtl)\n{\n    vec3 light = normalize(lightPosition.xyz - pos * lightPosition.w);\n    vec3 h = normalize(view + light);\n    vec3 vr = reflect(-view, nrm);\n        \n    float m2 = 1.0; // mtl.metallness * mtl.metallness;\n    vec3 reflectance = vec3(0.04);\n    \n    vec3 diffuseColor = mtl.baseColor * (1.0 - m2);\n    vec3 specularColor = mix(reflectance, mtl.baseColor, mtl.metallness);\n    float maxF0 = max(specularColor.x, max(specularColor.y, specularColor.z));\n        \n    LightVariables lv;\n    lv.shadow = calculateShadow(pos + 0.001 * nrm);\n    lv.LdotN = max(0.0, dot(nrm, light));\n    lv.VdotN = max(0.0, dot(nrm, view));\n    lv.HdotN = max(0.0, dot(nrm, h));\n    lv.HdotV = max(0.0, dot(view, h));\n    lv.HdotL = max(0.0, dot(light, h));\n    lv.roughness = max(0.02, mtl.roughness * mtl.roughness);\n    lv.f0 = vec4(specularColor, maxF0);\n        \n    vec3 F = FRESNEL_SHLICK ? \n        F_Shlick(vec3(lv.f0.w), vec3(1.0), lv.VdotN) :\n        F_Fresnel(vec3(lv.f0.w), lv.VdotN);\n            \n    vec3 diffuse = diffuseColor * \n        sampleDiffuseEnvironment(nrm) * lambertDiffuse(lv);\n    \n    vec3 specular = F * specularColor *\n        (sampleReflectedEnvironment(vr, lv.roughness, lv.f0.w) + microfacetSpecular(lv));\n    \n    return (diffuse * DIFFUSE_SCALE + specular * SPECULAR_SCALE) * \n        (lightColor * lv.shadow) + ambientColor;\n}\n\n/*\n * Main image\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    prepareScene();\n    \n    float rotSpeed = 0.25;\n    float rotOffset = 3.0 * PI / 4.0 - PI / 6.0;\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n\tvec3 viewPoint = vec3(66.0 * cos(rotOffset + rotSpeed * iTime), \n                          55.0 + 25.0 * cos(rotOffset + 0.5 * rotSpeed * iTime), \n                          66.0 * sin(rotOffset + rotSpeed * iTime));\n    vec3 viewCenter = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize(viewCenter - viewPoint);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n\tvec3 rd = normalize(p.x * uu + p.y * vv + 6.0 * ww);    \n    \n    float tmin = 1.0e+10;\n    float t1 = calculatePlaneIntersection(viewPoint, rd);\n    if (t1 > 0.0)\n        tmin = t1;\n\n    Material material;\n    int sphereIndex = -1;\n    vec3 nrm = vec3(0.0, 1.0, 0.0);\n    for (int i = 0; i < NumSpheres; ++i)\n    {\n        float t2 = calculateSphereIntersection(viewPoint, rd, spheres[i]);\n        if ((t2 > 0.0) && (t2 < tmin))\n        {\n            tmin = t2;\n            nrm = getNormal(viewPoint + t2 * rd, spheres[i]);\n            material = materials[i];\n            sphereIndex = i;\n        }\n    }\n    \n    if (tmin > 10000.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec3 pos = viewPoint + tmin * rd;\n    vec3 linearColor = vec3(0.0);\n    if (sphereIndex == -1)\n    {\n        float fade = exp(-0.025 * length(viewPoint - pos));\n        linearColor = fade * shadeFragment(pos, nrm, normalize(viewPoint - pos), planeMaterial);\n    }\n    else \n    {\n    \tlinearColor = shadeFragment(pos, nrm, normalize(viewPoint - pos), material);\n    }\n    \n    fragColor = vec4(pow(linearColor, vec3(1.0 / 2.2)), 1.0);\n}\n\n/*\n * Service functions\n */\nfloat calculateSphereIntersection(in vec3 ro, in vec3 rd, in Sphere sph)\n{\n    vec3 dv = sph.cen - ro;\n\tfloat b = dot(rd, dv);\n\tfloat d = b * b - dot(dv, dv) + sph.rad * sph.rad;\n\treturn (d < 0.0) ? -1.0 : b - sqrt(d);\n}\n\nfloat calculatePlaneIntersection(in vec3 ro, in vec3 rd)\n{\n    return (-1.0 - ro.y) / rd.y;\n}\n\nvec3 getNormal(in vec3 pos, in Sphere sph)\n{\n    return normalize((pos - sph.cen) / sph.rad);\n}\n\nvoid prepareScene()\n{\n    int col = 0;\n    int row = 0;\n    float xStart = float(1 - SphereCols) * spheresRadius - float(SphereCols - 1) * gap;\n    float xPos = xStart;\n    float zPos = float(1 - SphereRows) * spheresRadius - float(SphereRows - 1) * gap;\n    \n    for (int i = 0; i < NumSpheres; ++i)\n    {\n    \tspheres[i] = Sphere(vec3(xPos, spheresRadius, zPos), spheresRadius);\n        xPos += 2.0 * (spheresRadius + gap);\n        \n        float tc = float(col) / float(SphereCols - 1);\n        float tr = float(row) / float(SphereRows - 1);\n        \n    #if (COLORIZE)\n        float r = 0.5 + 0.5 * cos(0.5 * PI * tc);\n        float g = 0.5 + 0.5 * sin(0.5 * PI * tr);\n        float b = sqrt(1.0 - (r * r * g * g));\n        materials[i].baseColor = pow(vec3(r, g, b), vec3(2.2));\n    #else\n        materials[i].baseColor = vec3(1.0);\n    #endif\n        \n        materials[i].roughness = tc;\n        materials[i].metallness = tr;\n        \n        ++col;\n        if (col == SphereCols)\n        {\n        \tzPos += 2.0 * (spheresRadius + gap);\n            xPos = xStart;\n            col = 0;\n            row++;\n        }\n\t}\n    \n    planeMaterial.baseColor = vec3(1.0, 1.0, 1.0);\n    planeMaterial.roughness = 0.33333;\n    planeMaterial.metallness = 0.75;\n}\n\nfloat randomFloat(vec3 co)\n{\n    return fract(sin(dot(co, vec3(12.9898, 78.233, 59.5789))) * 43758.5453);\n}\n\nvec3 randomDirection(in vec3 base, in vec3 u, in vec3 v, in float r2, in vec3 seed)\n{\n\tfloat phi = 2.0 * PI * randomFloat(seed);\n\tfloat Xi = randomFloat(seed * phi + phi);\n    \n\tfloat cosTheta = sqrt((1.0 - Xi) / ((r2 - 1.0) * Xi + 1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n\treturn normalize((u * cos(phi) + v * sin(phi)) * sinTheta + base * cosTheta);\n}\n\nvec3 perpendicularVector(in vec3 nrm)\n{\n\tvec3 componentsLength = nrm * nrm;\n    \n\tif (componentsLength.x > 0.5)\n\t{\n\t\tfloat scaleFactor = sqrt(componentsLength.z + componentsLength.x);\n\t\treturn nrm.zyx * vec3(1.0 / scaleFactor, 0.0, -1.0 / scaleFactor);\n\t}\n\telse if (componentsLength.y > 0.5)\n\t{\n\t\tfloat scaleFactor = sqrt(componentsLength.y + componentsLength.x);\n\t\treturn nrm.yxz * vec3(-1.0 / scaleFactor, 1.0 / scaleFactor, 0.0);\n\t}\n\t\n    float scaleFactor = sqrt(componentsLength.z + componentsLength.y);\n\treturn nrm.xzy * vec3(0.0, -1.0 / scaleFactor, 1.0 / scaleFactor);\n}\n\nfloat microfacetWeight(in float r2, in float f0, in float HoN, in float VoN, in float LoN)\n{\n    float r4 = r2 * r2;\n    \n    float D = D_GGX(r4, HoN);\n    \n    float G = HEIGHT_CORRELATED_SMITH ? \n        G_SmithJointApprox(VoN, LoN, r2) : \n    \tG_Smith(VoN, LoN, r4);\n    \n    vec3 F = FRESNEL_SHLICK ? \n        F_Shlick(vec3(f0), vec3(1.0), VoN) :\n        F_Fresnel(vec3(f0), VoN); \n                    \n    return (F.x * D * G) * (LoN / PI);\n}\n\nvec3 sampleReflectedEnvironment(in vec3 Wi, in float r, in float f0)\n{\n#if (USE_IBL)    \n    float r2 = r * r;\n    float samples = 0.0;\n    vec3 u = perpendicularVector(Wi);\n\tvec3 v = cross(u, Wi);\n    vec3 result = vec3(0.0);\n    vec3 Wo = Wi;\n    for (int i = 0; i < MAX_CUBEMAP_SAMPLES; ++i)\n    {\n        Wo = randomDirection(Wi, u, v, r2, Wo + result);\n        vec3 H = normalize(Wi + Wo);\n        float weight = microfacetWeight(r2, f0, dot(H, Wi), 1.0, dot(Wo, Wi));\n        result += weight * texture(iChannel0, Wo).xyz;\n        samples += weight;\n\t}    \n    return result / samples;\n\t// */\n#else\n    return vec3(0.0);\n#endif\n}\n\nvec3 sampleDiffuseEnvironment(in vec3 Wi)\n{\n#if (USE_IBL)\n    float samples = 0.0;\n    \n    vec3 u = perpendicularVector(Wi);\n\tvec3 v = cross(u, Wi);\n    vec3 result = vec3(0.0);\n    vec3 Wo = Wi;\n    for (int i = 0; i < MAX_CUBEMAP_SAMPLES; ++i)\n    {\n        Wo = randomDirection(Wi, u, v, 1.0, Wo + result);\n        float weight = dot(Wi, Wo);\n        result += weight * texture(iChannel0, Wo).xyz;\n        samples += weight;\n\t}    \n    return result / samples;\n#else\n    return vec3(1.0);\n#endif\n}","name":"Image","description":"","type":"image"}]}