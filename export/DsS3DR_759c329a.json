{"ver":"0.1","info":{"id":"DsS3DR","date":"1668036314","viewed":175,"name":"midnight","username":"Alien01","description":"Tools:\n    blossom by yx\n    Shader Minifier by LLB\n    Crinkler by Mentor & Blueberry","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["inercia","executablegraphics","inercia2022"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec2 uv1 = uv;\n    fragColor = texture(iChannel0,uv1);    \n}\n\n\n\n/**\n                            \n                            ~~ midnight / alien ~~\n\n                    Tools:\n                    Blossom by yx\n                    Shader Minifier by LLB\n                    Crinkler by Mentor & Blueberry\n                    Greetings to the ptscene and all who share their knowledge                            \n                    \n                            ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n*/\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float FAR = 1e6;\nfloat PI = acos(-1.);\n\nstruct Smat{\n    vec3 alb;\n    float spc;\n    float spr;\n    vec3 spcl;\n    float ior;\n};\n\nstruct Sri\n{\n    float dist;\n\tvec3 normal;\n    Smat material;\n};\n\n\nSmat GetZeroedMaterial(){\n    Smat ret;\n    ret.alb = vec3(0.);\n    ret.spc = 0.;\n    ret.spr = 0.;\n    ret.spcl = vec3(0.);\n    ret.ior = 1.;\n    return ret;\n}\n\nvoid PopulateMaterial(inout Smat mat, vec3 albedo, float specChance, float specRoughness, vec3 specColor, float ior){\n    mat = GetZeroedMaterial();\n    mat.alb = albedo;\n    mat.spc = specChance;\n    mat.spr = specRoughness;\n    mat.spcl = specColor;\n    mat.ior = ior;\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90){\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if(n1 > n2){\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0 - cosX*cosX);\n        if(sinT2 > 1.0)\n            return f90;\n        cosX = sqrt(1.0 - sinT2);\n    }\n    float x = 1.0f - cosX;\n    float ret = r0 + (1.0-r0) * x * x * x * x * x;\n    return mix(f0, f90, ret);\n}\n\nfloat RandomFloat01(inout uint state){return float(wang_hash(state)) / 4294967296.0;}\n\n\nfloat Rand(vec2 p) {\n    return fract(sin(dot(p, vec2(42312.23142, 831234.23124)))*214130.213213);\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * PI * 2.0 ;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(42312.23142, 831234.23124)))*214130.213213);\n}\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat plane( vec3 p, vec3 n, float h )\n{\n\treturn dot(p,n) + h;\n}\n\nfloat box3(vec3 p, vec3 b){\n\tvec3 d = abs(p)-b;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nvec2 backwallsdf(vec3 p) {\n\tfloat size = 25.;\n\tvec2 cell = pMod2(p.xy, vec2(size+1., size+1.));\n\tfloat height = 0.5;\n\t\n\theight *= rand(cell)*200.;\n\t\n\n\tfloat sdf = box3(p, vec3(size/2., size/2., height));\n\tfloat bsdf = plane(p, vec3(0.,0., -1), 10.);\n\tsdf = min(sdf, bsdf);\n\treturn vec2(sdf, rand(cell));\n}\n\nvec2 groundsdf(vec3 p) {\n\tp.y += 5.;\n\tfloat size = 10.;\n\tvec2 cell = pMod2(p.xz, vec2(size+0.5, size+0.5));\n\tfloat height =0.5;\n    \n\t// p.xz *= rot(rand(cell)*-0.4);\n\t// p.yz *= rot(rand(cell)* 0.5);\n\tp.y -= rand(cell*0.25)*2.;\n    \n\tfloat sdf = box3(p, vec3(size/2., height, size/2.));\n\tfloat bsdf = plane(p, vec3(0,1, 0), 0.5);\n\t    sdf = min(sdf, bsdf);\n    \n\treturn vec2(sdf, rand(cell*1.5));\n}\n\nvec2 map(vec3 p){\n\tvec2 backwall = backwallsdf(p);\n\tvec2 ground = groundsdf(p);\n\tp.z += 20.;\n    //p.z += min(iTime*0.2, 1000.0);\n    //p.x -= min(iTime*0.2, 1000.0);\n    p.y -= 280.;\n    float sp = length(p) - 50.;\n\tfloat fin =min(ground.x, backwall.x);\n    fin = min(fin,sp);\n    // fin = sp;\n    float mat = 1.;\n    if (fin == ground.x) {\n       mat = ground.y;\n    }\n    else if( fin == backwall.x) {\n         mat = backwall.y;\n   }\n   else if(fin == sp) {\n       mat = 0.;\n   }\n\t// fin = max(length(p) - 100, fin);\n\treturn vec2(fin, mat);\n\t// return length(p) - 10;\n}\n\nfloat Raymarch(in vec3 o, in vec3 d, float t_min, float t_max,  float pixel_radius, inout Sri hitInfo){\n\tfloat omega = 1.2;\n\tfloat t = t_min;\n\tfloat candidate_t = t_min;\n\tfloat candidate_error = FAR;\n\tfloat previousRadius = 0.0;\n\tfloat stepLength = 0.0;\n\tfloat functionSign =  map(o).x < 0. ? -1.0 : +1.0;\n\tint i;\n    float mat = 0.;\n\tfor(i = 0; i < 256; i++){\n        vec2 m = map(d*t+o);\n        mat = m.y;\n\t\tfloat signedRadius = functionSign * m.x;\n\t\tfloat radius = abs(signedRadius);\n\t\tbool sorFail = omega > 1.0 && (radius + previousRadius) < stepLength;\n\t\tif(sorFail) {\n\t\t\tstepLength -= omega * stepLength;\n\t\t\tomega = 1.0;\n\t\t}\n\t\telse {\n\t\t\tstepLength = signedRadius * omega;\n\t\t}\n\t\tpreviousRadius = radius;\n\t\tfloat error = radius/t;\n\t\tif(!sorFail && error < candidate_error) {\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!sorFail && error < pixel_radius || t > t_max)\n\t\tbreak;\n\t\tt += stepLength;\n\t}\n\n\tif(t> t_max || candidate_error > pixel_radius) {\n\t\treturn FAR;\n\t} \n     if(mat < 0.5) {\n\t    PopulateMaterial(hitInfo.material, \n        vec3(0.95f, 0.25f, 0.9f), 0.2, 0.7, vec3(0.1f, 0.5f, 0.48f) , 0.0);\n\n    } else if(mat < 1.5) {\n        \n        PopulateMaterial(hitInfo.material, \n        vec3(0.95f, 0.25f, 0.9f), 0.1, 0.65, vec3(0.6f, 0.9f, 0.8f) , 0.0);\n\n    }\n\treturn t;\n}\n\nvec3 GetColorFromRay(vec2 uv, in vec3 _ro, in vec3 _rd, inout uint rng, float pixel_radius, inout float rayDistance){\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 ro = _ro;\n    vec3 rd = _rd;\n    float dist=0.0;\n    for(int i = 0; i <= 15; ++i){\n        Sri hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = FAR;\n\t\tfloat d = Raymarch(ro, rd, 0.01, 5000.0, pixel_radius, hitInfo);\n        hitInfo.dist = d;\n\t\trayDistance = hitInfo.dist;\n        if(hitInfo.dist >= FAR){\n            ret+= 3.5*vec3(0.9, 0.25, 0.6) * throughput;\n            break;\n        }\n\n  \n        float specularChance = hitInfo.material.spc;\n\n        float rayProbability = 1.f;\n        if(specularChance > 0.0f){\n            specularChance = FresnelReflectAmount(\n                    1.0,\n                    hitInfo.material.ior,\n                    rd, hitInfo.normal, hitInfo.material.spc, 1.0f\n            );\n        }\n\n        float doSpecular = 0.0f;\n        float raySelectRoll = RandomFloat01(rng);\n        if(specularChance > 0. && raySelectRoll < specularChance){\n            doSpecular = 1.0f;\n            rayProbability = specularChance;\n        }\n        else {\n            rayProbability = 1.0f - (specularChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001f);\n\n        \n        ro = (ro + rd * hitInfo.dist) + hitInfo.normal * 0.0001f;\n\n        vec3 diffuse_rd = normalize(hitInfo.normal + RandomUnitVector(rng));\n\n        vec3 specular_rd = reflect(rd, hitInfo.normal);\n        specular_rd = normalize(mix(specular_rd, diffuse_rd, hitInfo.material.spr * hitInfo.material.spr));\n        \n        \n        rd = mix(diffuse_rd, specular_rd, doSpecular);\n\n        \n\n        throughput *= mix(hitInfo.material.alb, hitInfo.material.spcl, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = max(throughput.x, max(throughput.y, throughput.z));\n            if(RandomFloat01(rng) > p)\n                break;\n            throughput *= 1.0f / p;\n        }\n    }\n    return ret ;\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = gl_FragCoord.xy;\n\tvec3 ro = vec3(0, 40, -200.0);\n\tvec3 ta = vec3(-290, -90, -10);\n\t\n\n\tfloat pixel_radius = length(1.0/iResolution.xy);\n    vec3 cameraUp = vec3(0.0f, 1.0f, 0.0f);\n    vec3 cameraRight = vec3(1.0f, 0.0f, 0.0f);\n    uint rng = uint(uint(uv.x/iResolution.y) * uint(1973) + uint(uv.y/iResolution.x) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n        rng = uint(uint(uv.x/iResolution.y) * uint(1973) + uint(uv.y/iResolution.x) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n\tvec2 jitter = vec2(RandomFloat01(rng), RandomFloat01(rng)) - 0.5f;\n    vec3 rd;\n\tvec2 uvJittered = (uv+jitter)/iResolution.xy;\n\tvec2 screen = uvJittered * 2.0f - 1.0f;\n\tscreen.y /= (iResolution.x/iResolution.y);\n\trd = vec3(screen, 1.0f/tan(120.0f * 0.5f * PI / 180.0f));\n\trd.yz *= rot(0.2);\n\trd = normalize(mat3(cameraRight, cameraUp, vec3(0.0f, 0.0f, 1.0f)) * rd);\n    float angle = RandomFloat01(rng) * 2.0f * PI;\n    float dof = 0.5;\n\n\tvec2 offset = vec2(cos(angle), sin(angle)) * sqrt(RandomFloat01(rng))*dof;\n\tvec3 focalPoint = ro + rd * 100.0;\n\tro += offset.x * cameraRight + offset.y * cameraUp;\n    mat3 camera = setCamera(focalPoint * ro, ta, 0.0);\n\t// rd = normalize(focalPoint - ro ) ; \n    \n    rd = normalize( vec3(screen, -0.15 + 0.5 * length(screen*1.5) ) );\n    \n    rd.xy *= rot(0.29);\n    \n\tfloat dist;\n    vec3 color = GetColorFromRay(screen, ro, rd, rng, pixel_radius, dist) ;\n    color *= color;\n    \n    \n\tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor += vec4(color,1);\n\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    vec2 uv1 = uv;    \n\tvec4 tex=texture(iChannel0,uv1);\n\tvec3 color=tex.rgb/tex.a;\n\tfragColor.rgb = color;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}