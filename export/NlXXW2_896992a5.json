{"ver":"0.1","info":{"id":"NlXXW2","date":"1626597439","viewed":233,"name":"Game for Cactus Jam","username":"morimea","description":"[b]Playable - Mouse click on left or right button.[/b]\n\nMade for [url=https://itch.io/jam/cactus]Cactus Jam[/url] in 1 day.\n\nVulkan version [url=https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/cact_jam_jul2021.zip]Download exe[/url]\n","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["game","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by Danil (2021+) https://cohost.org/arugl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/NlXXW2\n\n// everything made for ~1 day+ so code is not very good\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n\n    float blend=smoothstep(20.5,22.35,iTime);\n    float blend2=smoothstep(21.5,25.35,iTime);\n\n    vec4 c1=texture(iChannel2,uv);\n    vec4 c2=texture(iChannel3,uv);\n    \n    \n    fragColor=mix(c1,mix(c1,c2,max(clamp(c2.r+c2.g+c2.b,0.,1.),blend2)),blend);\n    fragColor=clamp(fragColor,0.,1.);\n    \n    fragColor.rgb*=0.35+0.65*SS(0.,0.75,iTime);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// texture buffer\n\n// cactus and text from https://itch.io/jam/cactus\n// balloon https://opengameart.org/content/balloon-pop-sprite\n\n\n// Created by Danil (2021+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 mcol=vec3(0x00b6c4)/float(0xff);\n\n\nconst uint [] image_0_palette = uint[](\n0x524800ffu,0xfff060ffu,0x7c6d00ffu,0xfffce0ffu,0xfff7b4ffu,0x191600ffu,\n0xfae823ffu,0xfff497ffu,0xbfad00ffu,0x342e00ffu,0xfde400ffu,0xd8c403ffu,\n0x988605ffu,0x211d00ffu,0x000000ffu,0x00000000u\n);\nconst uint [] image_0_palette_data = uint[](\n0xfffeeeeeu,0xeeefffffu,0xfffffeebu,0xaaaa89eeu,0xfffffffeu,0x2aaaaaaau,\n0xa85effeeu,0xee0aaaaau,0xaaaaabeeu,0xf58eeaaau,0xaaaaaaaau,0xa2eecaeeu,\n0xaaaaaaaau,0xaaaabeeau,0xae0a16aau,0xaaaaaaaau,0x5eaae013u,0x34aaaaaau,\n0xaaa5eaaeu,0xea73471au,0xaaaaabeeu,0xaa5eba37u,0x766aaaaau,0x2ee9a9eeu,\n0xaa347aaau,0xaa8eefedu,0x5fee6677u,0xaaaa8eefu,0xffeeffeeu,0x9baabcdeu,\n0xefffffffu,0xfffeeeeeu,0xeeffffffu,0xfff00000u\n);\n\nconst uint [] image_1_palette = uint[](\n0x00000000u,0x000000ffu,0x92b333ffu,0xb4dd3fffu\n);\nconst uint [] image_1_palette_data = uint[](\n0x00000155u,0x55000000u,0x00005fffu,0xfd500000u,0x0007ffffu,0xefd40000u,\n0x007fffabu,0xfff40000u,0x007ebfffu,0xbff40000u,0x00555557u,0xfad00000u,\n0x00000007u,0xff400015u,0x5555555fu,0xfd5401ffu,0xffffffffu,0xfff41fffu,\n0xabffebffu,0xffd1ffffu,0xfffffffau,0xbf5fabffu,0xffffffffu,0xfd7fffffu,\n0xfffffffeu,0xf5fffffau,0xbfffffffu,0xd1ffabffu,0xfebfeabfu,0x417fffffu,\n0xfffffffdu,0x00555555u,0x555ffd50u,0x00000000u,0x007ff400u,0x00000555u,\n0x57fad000u,0x00007ffeu,0xffff4000u,0x0007faffu,0xfff40000u,0x0007ffffu,\n0xfd400000u,0x00055555u,0x50000000u\n);\n\n\nconst uint [] image_2_palette = uint[](\n0x00000000u,0x000000ffu,0x92b333ffu,0xb4dd3fffu\n);\nconst uint [] image_2_palette_data = uint[](\n0x00000555u,0x50000000u,0x17fffd50u,0x00001fbfu,0xfffd0000u,0x1fffffffu,\n0x50001bfau,0x556ffd00u,0x1ff54005u,0x7f901ff9u,0x000007e4u,0x07f90000u,\n0x01fd01fdu,0x0000007fu,0x407f4000u,0x001fd01fu,0x90000006u,0xa407f400u,\n0x0017f901u,0xfd00001fu,0xfe401500u,0x0007ff40u,0x00000001u,0xfe900000u,\n0x00155550u,0x0000015fu,0xff400000u,0x05ffffa5u,0x000001ffu,0xffffd000u,\n0x01ebe55fu,0xf400007fu,0xe401e900u,0x007f9400u,0x1f40007fu,0x90001fd0u,\n0x001fe400u,0x1ff40001u,0xff55fffdu,0x00007fffu,0xfffd0000u,0x07fffffdu,\n0x4000006au,0xfffff400u,0x000557ffu,0xfd000000u,0x01555fd0u,0x00000000u,\n0x07f40000u,0x00000079u,0x00000005u,0x55064000u,0x0057ffd0u,0x5000017fu,\n0xfefd4000u,0x01ffffffu,0xd400007fu,0xa557fd40u,0x015fe400u,0x7fd0007eu,\n0xe40007f4u,0x001fe400u,0x01ed0007u,0xf400007fu,0x4001fd00u,0x001fd000u,\n0x7f90015fu,0xf40007e4u,0x007ff500u,0x5455001fu,0xf9001f40u,0x0005e940u,\n0x06e40000u,0x554015f9u,0x00000000u,0x1fff5555u,0x40001fefu,0xfffff555u,\n0x07ffffffu,0xebffd1ffu,0xaffebfffu,0xfd157e95u,0x57ffff40u,0x1f900155u,\n0x5fd007e4u,0x000007e4u,0x01b95555u,0x4064007eu,0x7ffff544u,0x00055ffeu,\n0xfff50000u,0x06aaabfbu,0xd0000055u,0x556ff400u,0x00000005u,0x7d400000u,\n0x00001ad0u,0x00000000u,0x07f40000u,0x000001fdu,0x00000000u,0x007b4000u,\n0x0555557fu,0x900007ffu,0xffbfd000u,0x07ffebffu,0xf40001feu,0xffffeb40u,\n0x001aaaaau,0xaf900001u,0x55555554u,0x0001fff4u,0x1fd00000u,0x7fff47fdu,\n0x00001ffeu,0xf47a4000u,0x06f5fd07u,0xd00007f4u,0x6b40ed00u,0x01f91fd0u,\n0x3f40007au,0x47f40fd0u,0x001f91fdu,0x03f40007u,0xf47fd1fdu,0x0001fd1fu,\n0xf5ff4000u,0x1f51ffffu,0x500006f4u,0x1fffd000u,0x007901ffu,0xd4000015u,\n0x40155000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n0x00000155u,0x40000000u,0x01ffb400u,0x000001ffu,0xff400000u,0x001ffff4u,\n0x00000001u,0x5ffd0000u,0x0000017fu,0x90000000u,0x0007f400u,0x00000001u,\n0xfd000000u,0x00007f40u,0x00000000u,0x1fd01555u,0x55555fe4u,0x57fffffau,\n0xfff91fbfu,0xfffffffdu,0x07ffbfffu,0xfffa4055u,0x55555555u,0x40000000u,\n0x00000000u,0x00001555u,0x54000001u,0x57fffd00u,0x0001ffbfu,0xff500001u,\n0xfbfaaff5u,0x0001ffa5u,0x557f4001u,0xfbe4001fu,0xd0007f94u,0x0007f400u,\n0x1ed00006u,0xb40007f5u,0x5557fd00u,0x01ffffffu,0xfa40001fu,0xfbfffe40u,\n0x0001ffffu,0xbff40000u,0x155aabffu,0x40000001u,0x557fd000u,0x00000007u,\n0xf4000000u,0x0001fd00u,0x00000555u,0x55000000u,0x57ffff40u,0x00015fffu,\n0xeaf40001u,0xebeffffdu,0x00007fe5u,0x55550000u,0x1bd40000u,0x000007fdu,\n0x50000000u,0x01fafd50u,0x0000001fu,0xfffd0000u,0x00017fffu,0x50000001u,\n0xffff9000u,0x0001ffffu,0x90000000u,0x7ff55000u,0x00001fe4u,0x00000000u,\n0x07f50000u,0x000001ffu,0xd5555000u,0x007fffffu,0xf5000007u,0xfffffad0u,\n0x0000555fu,0xffe40000u,0x00015554u\n);\n\nconst uint [] image_3_palette = uint[](\n0x00000000u,0xecf939ffu\n);\nconst uint [] image_3_palette_data = uint[](\n0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x55500000u,0x00015555u,\n0x00000005u,0x50014000u,0x00054000u,0x50000005u,0x40501400u,0x00054014u,\n0x05000005u,0x40140500u,0x00014005u,0x01400000u,0x50014540u,0x00001400u,\n0x55400000u,0x01401500u,0x00000040u,0x05000000u,0x00000000u,0x00000000u,\n0x00000000u,0x00000001u,0x55000000u,0x00055550u,0x00000005u,0x40140000u,\n0x00014005u,0x00000001u,0x40014000u,0x00005001u,0x40000000u,0x14555400u,\n0x00000555u,0x55000000u,0x00500000u,0x00000000u,0x01500000u,0x00015554u,\n0x00000005u,0x55400000u,0x00014400u,0x00000000u,0x05000000u,0x00000500u,\n0x00000000u,0x05001500u,0x00000155u,0x55400000u,0x00555400u,0x00000005u,\n0x00000000u,0x00054000u,0x00000001u,0x40014000u,0x00005555u,0x50000000u,\n0x15554000u,0x00000140u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n0x00001550u,0x00000000u,0x55550000u,0x00005451u,0x40000000u,0x14505000u,\n0x00001414u,0x14000000u,0x05140500u,0x00000145u,0x05000000u,0x00550540u,\n0x00000015u,0x41000000u,0x00010000u,0x00000000u,0x00000000u,0x00000000u,\n0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n0x00000000u,0x00000000u,0x00000000u,0x05540000u,0x00001555u,0x40000000u,\n0x15005000u,0x00000500u,0x14000000u,0x05000500u,0x00000140u,0x05400000u,\n0x00500540u,0x00000015u,0x55400000u,0x00015500u,0x00000000u,0x00000000u,\n0x00000000u,0x00000000u,0x00000000u,0x00000555u,0x00000000u,0x01555540u,\n0x00000000u,0x00500000u,0x00000150u,0x00000000u,0x05400000u,0x00001500u,\n0x00000000u,0x54000000u,0x00001400u,0x00000000u,0x00000000u,0x00000001u,\n0x55000000u,0x00055550u,0x00000005u,0x45140000u,0x00014505u,0x00000001u,\n0x41414000u,0x00005140u,0x50000000u,0x14505000u,0x00000550u,0x54000000u,\n0x01541000u,0x00000010u,0x00000000u,0x00000014u,0x00000000u,0x55550000u,\n0x00015550u,0x00000000u,0x55000000u,0x00000500u,0x00000000u,0x01000000u,\n0x00000140u,0x00000000u,0x00550000u,0x00000015u,0x40000000u,0x00000000u,\n0x00000000u\n);\n\nuvec4 decodeval32(uint varz) {\n    return uvec4(varz>>24,(varz>>16)&0xffu,(varz>>8)&0xffu,(varz>>0)&0xffu);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n        \n    ivec2 ipx=ivec2(fragCoord);\n    float resize=texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).a;\n    \n    if(resize<-50.){\n        fragColor=texelFetch(iChannel0,ipx,0);\n        return;\n    }\n\n    if(ipx==ivec2(iResolution.xy)-1){\n        fragColor=vec4(0.,0.,0.,-100.);\n        return;\n    }\n    \n    ivec2 idx=ivec2(uv*texture_pixel_size);\n    \n    \n    vec4 c=vec4(0.);\n    ivec2 shift=ivec2(0);\n    ivec2 tidx=idx-shift;\n    if((tidx.y<=image_0_size.y)&&(tidx.x<image_0_size.x)&&(tidx.x>=0)&&(tidx.y>0)){\n        int local_idx=(image_0_size.y-(tidx.y%image_0_size.y))+(tidx.x%image_0_size.x)*image_0_size.y;\n        c=vec4(decodeval32(image_0_palette[(decodeval32(image_0_palette_data[local_idx/8])[((local_idx-(local_idx/8)*8)/2)%4]>>(4*(1-(local_idx%2))))&0xfu]))/float(0xff);\n    }\n    \n    shift=image_0_size;\n    shift.y=0;\n    tidx=idx-shift;\n    if((tidx.y<=image_1_size.y)&&(tidx.x<image_1_size.x)&&(tidx.x>=0)&&(tidx.y>0)){\n        int local_idx=(image_1_size.y-(tidx.y%image_1_size.y))+(tidx.x%image_1_size.x)*image_1_size.y;\n        \n        c=vec4(decodeval32(image_1_palette[((decodeval32(image_1_palette_data[local_idx/16])[((local_idx-(local_idx/16)*16)/4)%4])>>(6-2*(local_idx%4)))&0x3u]))/float(0xff);\n    }\n    \n    shift=image_1_size;\n    shift.x=0;\n    tidx=idx-shift;\n    if((tidx.y<=image_2_size.y)&&(tidx.x<image_2_size.x)&&(tidx.x>=0)&&(tidx.y>0)){\n        int local_idx=(image_2_size.y-(tidx.y%image_2_size.y))+(tidx.x%image_2_size.x)*image_2_size.y;\n        \n        c=vec4(decodeval32(image_2_palette[((decodeval32(image_2_palette_data[local_idx/16])[((local_idx-(local_idx/16)*16)/4)%4])>>(6-2*(local_idx%4)))&0x3u]))/float(0xff);\n    }\n    \n    shift=image_1_size+image_2_size;\n    shift.x=0;\n    tidx=idx-shift;\n    if((tidx.y<=image_3_size.y)&&(tidx.x<image_3_size.x)&&(tidx.x>=0)&&(tidx.y>0)){\n        int local_idx=(image_3_size.y-(tidx.y%image_3_size.y))+(tidx.x%image_3_size.x)*image_3_size.y;\n        \n        c=vec4(decodeval32(image_3_palette[((decodeval32(image_3_palette_data[local_idx/16])[((local_idx-(local_idx/16)*16)/4)%4])>>(6-2*(local_idx%4)))&0x3u]))/float(0xff);\n    }\n    \n    \n    fragColor = c;\n}\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\nconst float cact_speed=0.15;\n\nconst ivec2 image_0_size = ivec2(14, 19);\nconst ivec2 image_1_size = ivec2(23, 31);\nconst ivec2 image_2_size = ivec2(144, 25);\nconst ivec2 image_3_size = ivec2(100, 25);\n\nconst float texture_pixel_size=150.;\n\n\n#define SS(a,b,c) smoothstep(a,b,c)\n#define PI 3.141592653589793\n\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// using https://iquilezles.org/articles/distfunctions2d\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat opRound(in float d, in float r)\n{\n  return d - r;\n}\n\nfloat opOnion(in float d, in float r)\n{\n  return abs(d) - r;\n}\n\n\n// using https://iquilezles.org/articles/intersectors\n\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n\tvec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    t = 1e20;        \n    {\n    float b = od.x + od.y + od.z;\n\tfloat c = oo.x + oo.y + oo.z - ra2;\n\tfloat h = b*b - c;\n\tif( h>0.0 ) t = -b-sqrt(h);\n    }\n    {\n\tfloat a = dd.y + dd.z;\n\tfloat b = od.y + od.z;\n\tfloat c = oo.y + oo.z - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;\n    }\n\t}\n    {\n\tfloat a = dd.z + dd.x;\n\tfloat b = od.z + od.x;\n\tfloat c = oo.z + oo.x - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;\n    }\n\t}\n    {\n\tfloat a = dd.x + dd.y;\n\tfloat b = od.x + od.y;\n\tfloat c = oo.x + oo.y - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;\n    }\n\t}\n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat4 rotate( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nvec3 ptransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,1.0)).xyz; }\nvec3 ntransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,0.0)).xyz; }\n\n\n\n\n//https://www.shadertoy.com/view/ldsyz4\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000, 100000, 1000000);\n\nint PrintInt( in vec2 uv, in int value, const int maxDigits )\n{\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[clamp(maxDigits-iu-1,0,6)]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n// Created by Danil (2021+) https://cohost.org/arugl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// game\n\n\nfloat check_mouse_l(vec2 p){\n    float d=sdCircle(p+vec2(1.,0.57),0.26);\n    d=step(0.,d);\n    return d;\n}\n\nfloat check_mouse_r(vec2 p){\n    float d=sdCircle(p+vec2(-1.,0.57),0.26);\n    d=step(0.,d);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 ouv=uv;\n    \n    ivec2 ipx=ivec2(fragCoord);\n    \n    \n    vec4 vals=texelFetch(iChannel1,ivec2(0),0);\n    vec2 local_mouse=vec2(texelFetch(iChannel2,ivec2(0,0),0).xy);\n    \n    vec2 im=(2.0*(local_mouse)-iResolution.xy)/iResolution.xy;\n    \n    bool mouse_l=check_mouse_l(im)<0.5;\n    bool mouse_r=check_mouse_r(im)<0.5;\n    \n    float timer=vals.x;\n    bool is_end=vals.y<-50.;\n    float player_pos=vals.z;\n    bool click=vals.w<0.;\n    \n    vec4 vals2=texelFetch(iChannel1,ivec2(0,1),0);\n    float last_timer=vals2.x;\n    float smooth_rot=vals2.w;\n    \n    float tran_timer1=vals2.y+iTimeDelta*smoothstep(18.,28.,iTime);\n    float tran_timer2=vals2.z+iTimeDelta*smoothstep(40.,50.,iTime);\n    float speed_slow=1.-smoothstep(20.,21.,iTime)*(1.-smoothstep(25.,29.,iTime));\n    speed_slow=max(0.0001,speed_slow);\n    \n    if((!click)&&(!is_end)){\n        if(mouse_l)player_pos+=1.;\n        if(mouse_r)player_pos+=-1.;\n    }\n    click=mouse_l||mouse_r;\n    \n    \n    vec4 vals3=texelFetch(iChannel1,ivec2(0,2),0);\n    bool player_click=vals3.x<0.;\n    float move_timer=vals3.y;\n    float rnd_top=vals3.z;\n    float rnd_bot=vals3.w;\n    move_timer+=1.;\n    move_timer=mod(move_timer,floor(5.5/cact_speed));\n    \n    if((!player_click)&&(!is_end)){\n        if(mod(timer+0.25,1.)<.5){\n            if(rnd_bot*4.5-0.5<=(player_pos+2.))\n            if((move_timer<0.5)||(rand(vec2(iTime))<0.025))\n            player_pos+=-1.;\n        }else{\n            if(rnd_top*4.5-0.5<=5.-(player_pos+2.))\n            if((move_timer<0.5)||(rand(vec2(iTime))<0.025))\n            player_pos+=1.;\n        }\n    }\n    \n    if(click)player_click=true;\n    player_click=player_click&&vals.x!=0.;\n    \n    float player_step=0.23;\n    player_pos=clamp(player_pos,-2.,2.);\n    \n    if(smooth_rot<player_pos)smooth_rot+=iTimeDelta*(player_pos-smooth_rot);\n    else if(smooth_rot>player_pos)smooth_rot+=-iTimeDelta*(-player_pos+smooth_rot);\n    \n    uv.x+=timer;\n    \n    if(!is_end){\n        timer+=iTimeDelta*cact_speed*speed_slow;\n        vec2 sz=(vec2(image_0_size))/(texture_pixel_size);\n        float a1=texelFetch(iChannel1,ivec2(iResolution.xy*0.5-vec2(0.,(sz.y*0.15+player_step*player_pos))*iResolution.xy),0).a;\n        float a2=texelFetch(iChannel1,ivec2(iResolution.xy*0.5-vec2(0.,(-sz.y*0.25+player_step*player_pos))*iResolution.xy),0).a;\n        is_end=a1>1.5||a2>1.5;\n        last_timer=-1.;\n    }else{\n        if(last_timer<0.)last_timer=iTime;\n    }\n    \n    if(ipx==ivec2(0)){\n        fragColor=vec4(timer,is_end?-100.:0.,player_pos,click?-1.:1.);\n        return;\n    }\n    if(ipx==ivec2(0,1)){\n        fragColor=vec4(last_timer,tran_timer1,tran_timer2,smooth_rot);\n        return;\n    }\n    \n\n    \n    \n    vec3 col=vec3(0.);\n    float a=0.;\n    \n    if(floor(uv.x)>=1.){\n    \n        vec2 sz=(vec2(image_1_size))/(texture_pixel_size);\n        vec2 sz1=(vec2(image_0_size))/(texture_pixel_size);\n\n        vec2 tuv=uv;\n        float rnd=rand(vec2(floor(tuv.x+0.5)));\n        tuv.y*=0.27+0.85*rnd;\n        rnd_bot=rand(vec2(floor(tuv.x+0.5)+1.));;\n\n        if((fract(tuv.x+0.5)<sz.x)&&(tuv.y<sz.y)){\n            vec4 tx=texture(iChannel0,vec2(fract(tuv.x+0.5)+sz1.x,tuv.y));\n            col=tx.rgb;\n            a=tx.a;\n        }\n\n        tuv=uv;\n        rnd=rand(vec2(floor(tuv.x)));\n        tuv.y=1.-tuv.y;\n        tuv.y*=0.27+0.85*rnd;\n        rnd_top=rand(vec2(floor(tuv.x)+1.));\n\n        if((fract(tuv.x)<sz.x)&&(tuv.y<sz.y)){\n            vec4 tx=texture(iChannel0,vec2(fract(tuv.x)+sz1.x,tuv.y));\n            col=tx.rgb;\n            a=max(a,tx.a);\n        }\n    }\n    \n    a=clamp(a,0.,1.);\n    \n    \n    vec2 tuv=ouv;\n    tuv.y+=player_pos*player_step;\n    \n    vec2 sz=(vec2(image_0_size))/(texture_pixel_size);\n    \n    tuv.x+=-0.5+sz.x*0.5;\n    tuv.y+=-0.5+sz.y*0.5;\n    \n    if((tuv.x<sz.x)&&(tuv.y<sz.y)&&(tuv.x>0.)&&(tuv.y>0.)){\n        vec4 tx=texture(iChannel0,vec2(tuv.x,tuv.y));\n        col=mix(col,tx.rgb,tx.a);\n        a+=tx.a;\n    }\n    \n    \n    \n    \n    float id=float(PrintInt((ouv-vec2(0.7,0.8))*10.,int(timer/cact_speed),3));\n    id=clamp(id,0.,1.);\n    \n    col=mix(col,vec3(0.),id*0.75);\n    a=max(a,id);\n    \n    if(is_end){\n        vec2 sz=(vec2(image_3_size))/(texture_pixel_size);\n        vec2 sz1=(vec2(image_1_size+image_2_size))/(texture_pixel_size);\n        vec2 tuv=(ouv-0.5)*vec2(0.75,0.25)+0.5;\n        tuv.x+=-0.5+sz.x*0.5;\n        tuv.y+=-0.5+sz.y*0.5;\n\n        if((tuv.x<sz.x)&&(tuv.y<sz.y)&&(tuv.x>0.)&&(tuv.y>0.01)){\n            vec4 tx=textureLod(iChannel0,vec2(tuv.x,tuv.y+sz1.y),0.);\n            col=mix(col,tx.rgb*0.1,tx.a);\n            a=max(tx.a,a);\n        }\n    }\n    \n    fragColor=vec4(col,a);\n    \n    \n    if(ipx==ivec2(0,2)){\n        fragColor=vec4(player_click?-1.:1.,move_timer,rnd_top,rnd_bot);\n        return;\n    }\n    \n}\n\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// Created by Danil (2021+) https://cohost.org/arugl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// shader intersection template from https://www.shadertoy.com/view/WlSXRW\n\n\n\nconst vec3 colbg=vec3(0x00,0xb6,0xc4)/float(0xff);\nconst vec3 cold=vec3(0x46,0x48,0x45)/float(0xff);\nconst vec3 colp=vec3(0xf6,0xcd,0xe0)/float(0xff);\nconst vec3 colpl=vec3(0xf3,0x5f,0x73)/float(0xff);\nconst vec3 colg=vec3(0x92,0xb3,0x33)/float(0xff);\n\n\n#define AA 2\n\n\nvec3  box_size = vec3(0.75,0.54,0.375);\nfloat box_radius = 0.3;\n\n\nvec2 im_save=vec2(-1000.);\n\nvec3 draw_2d(vec2 p, out float dnor){\n    vec3 col = colbg;\n    \n    dnor=0.;\n    // I were planning to make box resizible dynamicly, this why *tb everywhere\n    vec2 tb=box_size.xy;\n    vec2 si = tb*1.15;\n    vec4 ra = vec4(box_radius/2.)*tb.y*2.5;\n    float d = 0.;\n    float d1 = 0.;\n    \n    vec2 tp=p+tb*0.65+vec2(0.2,0.)*tb+(vec2(0.075,0.115)*tb.y*2.5);\n    vec2 sz=vec2(image_1_size)/(texture_pixel_size);\n    if(all(lessThan(tp,sz))&&all(greaterThan(tp,vec2(0.)))){\n        vec2 sz1=(vec2(image_0_size))/(texture_pixel_size);\n        vec4 tcol=textureLod(iChannel0,tp+vec2(sz1.x,0.),0.);\n        tcol.a=clamp(tcol.a,0.,1.);\n        col=mix(col,tcol.rgb,tcol.a);\n    }\n    \n    tp=p+vec2(-1.,1.)*(tb*0.65+vec2(0.3,0.)*tb)+(vec2(0.075,0.115)*tb.y*2.5);\n    sz=vec2(image_1_size)/(texture_pixel_size);\n    if(all(lessThan(tp,sz))&&all(greaterThan(tp,vec2(0.)))){\n        vec2 sz1=(vec2(image_0_size))/(texture_pixel_size);\n        vec4 tcol=textureLod(iChannel0,tp+vec2(sz1.x,0.),0.);\n        tcol.a=clamp(tcol.a,0.,1.);\n        col=mix(col,tcol.rgb,tcol.a);\n    }\n    \n    float lsc=1.1;\n    tp=(p+vec2(0.,1.)*(tb*0.65+vec2(0.3,0.)*tb)+(vec2(0.325,0.12)*tb.y*2.5))*lsc;\n    sz=(vec2(image_2_size))/(texture_pixel_size);\n    if(all(lessThan(tp,sz))&&all(greaterThan(tp,vec2(0.)))){\n        vec2 sz1=vec2(image_1_size)/(texture_pixel_size);\n        vec4 tcol=textureLod(iChannel0,tp+vec2(0.,sz1.y*1.),0.);\n        tcol.a=clamp(tcol.a,0.,1.);\n        col=mix(col,tcol.rgb,tcol.a);\n        //col=vec3(1.);\n    }\n    \n    d=sdRoundedBox(p,si,ra);\n    d1=d;\n    if(d<0.){\n    d=SS(0.,0.01*tb.y*2.5,opOnion(d,0.06*tb.y*2.5));\n    d1=d;\n    }\n    else{\n    d1=SS(0.,0.2*tb.y*2.5,opOnion(d1,0.01*tb.y*2.5));\n    d=SS(0.,0.15*tb.y*2.5,opOnion(d,0.01*tb.y*2.5));\n    }\n    \n    \n    float tcb=sdBox(mod(p*MD(0.5),vec2(0.04*tb.y*2.5))-0.02*tb.y*2.5,vec2(0.01*tb.y*2.5));\n    tcb=SS(0.,0.02,tcb);\n    \n    dnor=max(dnor,tcb*(1.-d1));\n    \n    col=mix(col,mix(cold,col,tcb),1.-d);\n    \n    vec2 c1p=p+tb*0.65-vec2(0.,0.05*tb.y*2.5);\n    vec2 c2p=p+vec2(-1.,1.)*tb*0.65-vec2(0.,0.05*tb.y*2.5);\n    d=SS(0.,0.005,sdCircle(c1p,0.075*tb.y*2.5));\n    d=min(d,SS(0.,0.005,sdCircle(c2p,0.075*tb.y*2.5)));\n    \n    d1=1.-SS(0.,0.005,sdRhombus(c1p,vec2(0.08)));\n    d1=min(d1,SS(0.,0.005,sdRhombus(c1p+vec2(0.,-0.045*tb.y*2.5).yx,vec2(0.068))));\n    \n    d1=max(d1,1.-SS(0.,0.005,sdRhombus(c2p,vec2(0.08))));\n    d1=min(d1,SS(0.,0.005,sdRhombus(c2p+vec2(0.,0.045*tb.y*2.5).yx,vec2(0.068))));\n    \n    col=mix(col,mix(colp,colp*.8,d1*(1.-tcb)),1.-d);\n    \n    vec2 box_uv=tb*vec2(0.9,0.6);\n    \n    d1=sdRoundedBox(p-vec2(0.,tb.y*0.25),box_uv,vec4(ra.x*.5,0.01,ra.z*.5,0.01));\n    \n    box_uv*=0.8;\n    d=sdBox(p-vec2(0.,tb.y*0.25),box_uv);\n    float box_d=SS(0.,0.001,d);;\n    d=SS(0.,0.001,d1*d);\n    \n    \n    box_uv=.5*(p-(vec2(0.,tb.y*0.25)))/box_uv;\n    \n    col=mix(col,cold,1.-d);\n\n    col*=col;\n    \n    vec3 box_col=vec3(1.);\n    \n    vec2 num_pixels=vec2(60,30.);\n    vec4 gimg=textureLod(iChannel1,box_uv*0.98+0.5,0.);\n    gimg.a=clamp(gimg.a,0.,1.);\n    vec2 box_pixels=(box_uv+0.5)*num_pixels;\n    vec2 box_pixels_t=box_pixels;\n    ivec2 boxpx_id=ivec2(box_pixels);\n    box_pixels=fract(box_pixels)-.5;\n    \n    //gimg=textureLod(iChannel1,vec2(boxpx_id)/num_pixels,0.);\n    //gimg.a=clamp(gimg.a,0.,1.);\n    \n    float box_td=sdBox(box_pixels,vec2(0.35));\n    \n    box_td=1.-SS(-0.5+0.55*gimg.a,0.2,box_td);\n    \n    box_col=mix(box_col,cold+gimg.rgb*0.65,box_td);\n    \n    \n    float vignetteAmt = 1. - dot(box_uv * 1.0965, box_uv * 1.0965);\n    vignetteAmt=clamp(vignetteAmt,0.,1.);\n    box_col *= vignetteAmt;\n    \n    col=mix(box_col,col,box_d);\n    \n    \n    col=clamp(col,0.,1.);\n    col = col / 2. + col*col;\n    if(iTime<25.){\n    if(iMouse.w>0.)\n    im_save=(p+0.5)*iResolution.xy;}\n    else im_save=(p+0.5)*iResolution.xy;\n    \n    return col;\n}\n\n\n\nmat4  box_world_to_obj;\nmat4  box_obj_to_world;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(1e20,-1.0);\n    {\n    float t = (-1.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n    {\n    vec3 rdd = ntransform(box_world_to_obj, rd );\n    vec3 roo = ptransform(box_world_to_obj, ro );\n    float t = roundedboxIntersect(roo,rdd,box_size,box_radius);\n    if( t>0.0 && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\nvec3 getSkyColor( vec3 rd , vec3 lig) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(lig),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,64.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 vals=texelFetch(iChannel1,ivec2(0),0);\n    float timer=vals.x;\n    \n    vec4 vals2=texelFetch(iChannel1,ivec2(0,1),0);\n    float last_timer=vals2.x;\n    float smooth_rot=vals2.w;\n    \n    box_obj_to_world = rotate( normalize(vec3(0.0,1.0,0.0)), 0.2*smooth_rot*smoothstep(14.,24.,iTime)); \n    box_world_to_obj = inverse( box_obj_to_world );\n    ivec2 ipx=ivec2(fragCoord);\n    \n    float revt=1.;\n    \n    if(last_timer>0.)revt=1.-smoothstep(0.5,8.5,iTime-last_timer);\n    \n    vec2 mouse_local=texelFetch(iChannel3,ivec2(0),0).xy;\n    if(iTime<25.)mouse_local=(iMouse.w<=0.)?vec2(0.):iMouse.xy;\n    if(ipx==ivec2(0,0)){\n        fragCoord=mouse_local;\n    }\n    \n    vec2 screen_uv=(2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n    \n\t    vec3 ro = vec3(0.0, 0.08, 1.215 +1.*smoothstep(4.,22.5,timer/cact_speed)*revt);\n\t    vec3 rd = normalize( vec3(p,-1.5) );\n        \n        const vec3 lig = normalize(vec3(0.8,0.4,-0.6));\n        vec3 col = (vec3(0.408)*(1.0-0.3*length(p)) + 0.02*rd.y)*getSkyColor(rd,lig);\n\n        vec2 tm = intersect( ro, rd );\n        if( tm.y>0.0 )\n        {\n            float t = tm.x;\n            vec3 pos = ro + t*rd;\n            \n            if( tm.y<1.5 )\n            {\n                vec3 nor = vec3(0.0,1.0,0.0);\n                float sha = step( intersect( pos+0.01*nor, lig ).y, 0.0 );\n                col = mix( col*3.0*(vec3(0.2,0.3,0.4)+vec3(0.8,0.7,0.6)*sha), \n                       col, 1.0-exp(-0.02*t) );\n            }\n            else\n            {\n                vec3 bpos = ptransform(box_world_to_obj,pos);\n                vec3 bnor = roundedboxNormal(bpos,box_size,box_radius);\n                vec3 nor = ntransform(box_obj_to_world,bnor);\n                \n                vec3 lig = normalize(vec3(0.7,0.6,0.3));\n                vec3 hal = normalize(-rd+lig);\n                float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n                float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n\n                const float fr = 3.14159*7.5;\n                \n                float dnor;\n                col=draw_2d(bpos.xy,dnor);\n                \n                col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n\n                col += 0.74*pow(clamp(dot(hal,normalize(nor-2.5*dnor)),0.0,1.0),12.0)*dif;\n                \n                }\n        }\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    tot = clamp(tot,0.,1.);\n    tot = pow( tot, vec3(0.45) );\n    \n    fragColor = vec4( tot, 1.0 );\n    \n    fragColor += ((rand(screen_uv) - .5)*.107)*smoothstep(22.,23.,iTime);\n    \n    \n    if(ipx==ivec2(0,0)){\n        fragColor=vec4(im_save,0.,0.);\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// Created by Danil (2021+) https://cohost.org/arugl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n// using iq's intersectors: https://iquilezles.org/articles/intersectors\n\n#define AA 0\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0005\n\n\nvec2 im_save=vec2(-1000.);\nivec2 ipx=ivec2(-1);\n\nfloat tran_timer1=0.;\nfloat tran_timer2=0.;\n\nvec3 l1Pos = vec3(-1,1,1);\n\nvec4 bgcol=vec4(0.4);\n\n\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nRay SetCamera(vec2 uv)\n{\n    vec3 ro = vec3(0.,0.5-1.499*(1.-SS(0.2,5.8+5.*(1.-SS(0.2,5.8,tran_timer1)),tran_timer1)),0.);\n    //vec2 m = (iMouse.xy/iResolution.xy-0.5)*PI-PI*0.5;\n    float lt=tran_timer2;\n    vec2 m = (vec2(sin(lt*0.4),-0.5+0.75*cos(lt*0.25)))*PI*0.05-PI*0.5;\n    m.y = -m.y;\n    float fov=70.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n\n    rd = (rotY * rotX) * rd;\n    return Ray(ro,rd);\n}\n\nbool ParallelogramIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, out float tx, out vec3 norm)\n{\n    vec3 a = v0 - v1;\n    vec3 b = v2 - v0;\n    vec3 p = v0 - ro;\n    vec3 n = cross( a, b );\n    vec3 q = cross( rd, p );\n    float i = 1.0/dot( rd, n );\n    float u = dot( q, a )*i;\n    float v = dot( q, b )*i;\n    float t = dot( n, p )*i;\n    tx=-1.;\n    norm=vec3(0.,1.,0.);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return false;\n    vec3 normx = vec3( t, u, v );\n    if( normx.x>MIN_DIST && normx.x<MAX_DIST )\n    {\n    tx = normx.x;\n    vec3 nor = normalize( cross(v2-v1,v1-v3) );\n    norm = faceforward( nor, rd, nor );\n    return true;\n    }\n    return false;\n}\n\n\n// using https://iquilezles.org/articles/filterableprocedurals\n\nfloat filteredSquares( in vec2 p, in vec2 dpdx, in vec2 dpdy, float N)\n{\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    if(length(w)<=0.0)return 1.;\n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return i.x*i.y;\n}\n\nfloat filteredCrosses( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    const float N = 3.0;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    if(length(w)<=0.0)return 1.;\n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return 1.0-i.x-i.y+2.0*i.x*i.y;\n}\n\nvec3 get_pixels( in vec2 p)\n{\n    //p.y*=.25;\n    //p*=2.;\n    vec2 tp,dpdx,dpdy;\n    float n=3.;\n    tp=p;\n    tp+=0.5*1./n;\n    dpdx=dFdx(tp); dpdy=dFdy(tp);\n    float r = filteredSquares(tp, dpdx, dpdy, n);\n    n=4.25;\n    tp=p;\n    tp+=(0.5)*1./n+vec2(0.,.5);\n    dpdx=dFdx(tp); dpdy=dFdy(tp);\n    float g = filteredSquares(tp, dpdx, dpdy, n);\n    tp=p;\n    tp+=(0.5)*1./n+vec2(0.5,.0);\n    dpdx=dFdx(tp); dpdy=dFdy(tp);\n    g += filteredSquares(tp, dpdx, dpdy, n);\n    n=2.45;\n    tp=p;\n    tp+=(0.5)*1./n+0.5;\n    dpdx=dFdx(tp); dpdy=dFdy(tp);\n    float b = filteredSquares(tp, dpdx, dpdy, n);\n    return vec3(r, g, b)*vec3(0.985,1.,.65)*7.5;\n}\n\nvec4 get_texture(vec2 p){\n    vec2 op=p;\n    p.x*=1./(iResolution.x/iResolution.y);\n    vec2 tuv=(p+1.)*0.5;\n    tuv.y=1.-tuv.y;\n    vec2 ttuv=op+op.yx*vec2(1.,-1.);\n    vec3 px=get_pixels(ttuv*800.*(iResolution.y/450.));\n    float d=SS(0.489,0.499,abs(tuv.x-0.5));\n    d=max(d,SS(0.489,0.499,abs(tuv.y-0.5)));\n    if(iMouse.w>0.)\n    im_save=tuv*iResolution.xy;\n    \n    if(d>0.98)px=vec3(0.); //dfd edge protection\n    return vec4(mix(textureLod(iChannel2,tuv,0.).rgb*px*1.5*(1.-d),bgcol.rgb,d),1.);\n}\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    int obj_type;\n};\n\nvoid ParallelogramIntersectMin(vec3 ro, vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, inout bool result, \n                               inout HitInfo hit, int OBJ) {\n    float tnew;\n    vec3 normnew;\n    vec3 v3 = v1 + v2 - v0;\n    if (ParallelogramIntersect(ro, rd, v0, v1, v2, v3, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            hit.color= get_texture((ro+rd*tnew).zx);\n            hit.obj_type = OBJ;\n            result = true;\n        }\n    }\n}\n\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    hit.t = MAX_DIST;\n    hit.obj_type = 0;\n    hit.color=bgcol;\n    bool result = false;\n\n    vec3 v0 = vec3(-1.,-1.,-iResolution.x/iResolution.y); \n    vec3 v1 =  vec3(1.,-1.,-iResolution.x/iResolution.y); \n    vec3 v2 =  vec3(-1.,-1.,iResolution.x/iResolution.y); \n\n\n    ParallelogramIntersectMin(ro, rd, v0, v1, v2, result, hit,1);\n\n\n    return result;\n}\n\nconst float eps = 1e-3;\n\nvec3 getSkyColor( vec3 rd , vec3 lig) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(lig),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,64.));\n    return col;\n}\n\nvec3 render(Ray r)\n{\n    vec3 col = vec3(0.0);\n    vec3 objectcolor = vec3(1.0);\n    vec3 mask = vec3(1.0);\n    HitInfo hit;\n    hit.color=vec4(0.);\n    bgcol.rgb=getSkyColor(r.dir,normalize(l1Pos))*0.1;\n    {\n        if(minDist(r.pos, r.dir, hit)){\n            objectcolor = hit.color.rgb;\n            vec3 p = r.pos + r.dir * hit.t + hit.norm*eps;\n            vec3 sunDir = normalize(l1Pos-p);\n            //col = objectcolor;\n            col = objectcolor * (vec3(max(dot(hit.norm,sunDir),0.0)) + 0.05);\n        }else col = bgcol.rgb;\n    }\n    return col;\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 ret_col = vec3(0.0);\n    ivec2 ipx=ivec2(fragCoord);\n    vec2 mouse_local=iMouse.xy;\n    \n    vec4 vals=texelFetch(iChannel1,ivec2(0),0);\n    float timer=vals.x;\n    vec4 vals2=texelFetch(iChannel1,ivec2(0,1),0);\n    tran_timer1=vals2.y;\n    tran_timer2=vals2.z;\n    \n    if(ipx==ivec2(0,0)){\n        fragCoord=mouse_local;\n    }\n    #if AA>1\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n    vec2 uv = (fragCoord+o)/iResolution.xy * 2.0 - 1.0;\n    #else\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    #endif\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 col = render(SetCamera(uv));\n    ret_col += col;\n    #if AA>1\n    }\n    ret_col /= float(AA*AA);\n    #endif\n    ret_col = clamp(ret_col,0.,1.);\n    fragColor = vec4( clamp(pow(ret_col, vec3(0.84545)),vec3(0.),vec3(1.)), 1.0 );\n    \n    \n    if(ipx==ivec2(0,0)){\n        fragColor=vec4(im_save,0.,0.);\n    }\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}