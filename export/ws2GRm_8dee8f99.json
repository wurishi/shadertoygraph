{"ver":"0.1","info":{"id":"ws2GRm","date":"1548556368","viewed":236,"name":"Candyland Steps","username":"Elyxian","description":"Raymarching a stepped noise function. Because the heightmap has infinitely steep sections, a maximum step size is enforced on the raymarching, with some interval bisection stuff to prevent overstepping. This gives pretty good (but imperfect) results.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","canyon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPHEIGHT 1.0\n#define HSCALE 0.5\n#define VSCALE 8.0\n\n//#define STEPHEIGHT 0.2\n//#define HSCALE 0.3\n//#define VSCALE 2.0\n\nfloat saturate(float t) {return clamp(t, 0.0, 1.0);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n// RGB and HSV Conversion from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n\nvec3 increaseSaturation(vec3 c) {\n\t\n    float strength = 1.15;\n    \n    // Convert to hsv\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    vec3 hsv = vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    \n    // Increase saturation\n    hsv.y *= strength;\n    saturate(hsv.y);\n    \n    // Convert to rgb\n    vec4 K2 = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p2 = abs(fract(hsv.xxx + K2.xyz) * 6.0 - K2.www);\n    vec3 rgb = hsv.z * mix(K2.xxx, clamp(p2 - K2.xxx, 0.0, 1.0), hsv.y);\n    \n    return rgb;\n\n}\n\n// Hash function by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n    \n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\n// Standard value noise function\n\nfloat valueNoise(vec2 p) {\n    \n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(hash12(i), hash12(i + add.xy), f.x),\n        mix(hash12(i + add.yx), hash12(i + add.xx), f.x),\n        f.y);\n    return res;\n        \n}\n\n// The heightmap is 2d value noise but filtered into 'steps'\n\nfloat heightMap(vec2 p) {\n\t\n    float height = valueNoise(p * HSCALE) * VSCALE;\n    height = floor(height / STEPHEIGHT) * STEPHEIGHT;\n    return height;\n    \n}\n\nfloat raytrace(vec3 ro, vec3 rd) {\n\t\n    // Parameters\n    int maxSteps = 500;\n    float maxStepDist = 0.12;\n    float maxDist = 100.0;\n    int maxIterations = 10;\n    float eps = 0.01;\n    \n    // Initial Raymarching Steps\n    bool didHit = false;\n    float beforeDist = -1.0;\n    float afterDist = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < maxSteps && t < maxDist; i++) {\n        \n        beforeDist = afterDist;\n        afterDist = t;\n    \tvec3 p = ro + t * rd;\n        float height = heightMap(p.xz);\n        if (p.y - height < eps) {\n\t\t\tdidHit = true;\n            break;\n        }\n        \n        // Normally raymarching would just be done using 'p.y - height', however this does not\n        // take into account the proximity to the nearest cliff. To account for this, a maximum\n        // step size is imposed. Additionally, if the ray is currently above the maximum height\n        // of the heightmap, it can safely move forward by the distance to the top of the heightmap\n        //t += min(p.y - height, maxStepDist);\n        t += max(min(p.y - height, maxStepDist), p.y - VSCALE);\n        \n    }\n    if (!didHit) {\n    \treturn -1.0;\n    }\n    \n    // Use the interval bisection method to find a closer point, as moving forward by a fixed step\n    // size may have embedded the ray in a cliff\n    for (int i = 0; i < maxIterations; i++) {\n    \tfloat midVal = (beforeDist + afterDist) / 2.0;\n        vec3 p = ro + midVal * rd;\n        if (p.y < heightMap(p.xz)) {\n        \tafterDist = midVal;\n        }\n        else {\n        \tbeforeDist = midVal;\n        }\n    }\n    \n    // Return the midpoint of the closest point before the terrain, and the closest point after it\n    return (beforeDist + afterDist) / 2.0;\n    \n\n}\n\n/*vec3 getNormal(vec3 p) {\n    \n    // Central differences method to generate a normal vector\n    // This is imperfect for this non-continuous heightmap, and I believe\n    // this is the cause of the bad normal lighting\n    vec2 eps = vec2(0.005, 0.00);\n    vec3 normal = vec3(\n    \theightMap(p.xz + eps.xy) - heightMap(p.xz - eps.xy),\n\t\t2.0 * eps.x,\n\t\theightMap(p.xz + eps.yx) - heightMap(p.xz - eps.yx)\n    );\n    normal = normalize(normal);\n    return normal;\n    \n}*/\n\nvec3 getNormal(vec3 p) {\n    \n    // This is a somewhat hacky way of getting the normal for this heightmap\n    // The above getNormal function is imperfect due to the non-continous heightmap\n    \n    // Get the normal of the value noise (not the stepped heightmap)\n    \n    vec2 eps = vec2(0.005, 0.00);\n    vec3 normal = vec3(\n    \t(valueNoise((p.xz + eps.xy) * HSCALE) * VSCALE) - (valueNoise((p.xz - eps.xy) * HSCALE) * VSCALE),\n\t\t2.0 * eps.x,\n\t\t(valueNoise((p.xz + eps.yx) * HSCALE) * VSCALE) - (valueNoise((p.xz - eps.yx) * HSCALE) * VSCALE)\n    );\n    \n    // Work out whether the point is in a horizontal or vertical section\n    float stepEps = 0.012;\n    float stepSection = mod(p.y / STEPHEIGHT, 1.0);\n    bool isOnCliff = true;\n    if (stepSection < stepEps || stepSection > (1.0 - stepEps)) {\n    \tisOnCliff = false;\n    }\n    \n    // Adjust the normal accordingly\n    if (isOnCliff) {\n    \tnormal = vec3(normal.x, 0.0, normal.z);\n    }\n    else {\n    \tnormal = vec3(0.0, 1.0, 0.0);\n    }\n    \n    // Normalise and return the normal\n    normal = normalize(normal);\n    return normal;\n    \n}\n\nvec3 getDiffuse(vec3 p) {\n    \n    // Get which band the point belongs to\n    float eps = 0.01;\n    p.y += eps;\n    float height = floor(p.y / STEPHEIGHT) * STEPHEIGHT;\n    \n    // Color function from iq: https://www.shadertoy.com/view/Xds3zN\n    vec3 col = 0.45 + 0.35*sin(vec3(0.15,0.08,0.10)*(height*124.2));\n    \n    // Increase saturation\n    col = increaseSaturation(col);\n    \n    // Darken the lower colors\n    col = mix(vec3(0.0), col, 0.1 + 0.9 * (height / VSCALE));\n    \n    return col;\n    \n}\n\nvec3 getColor(vec3 p) {\n\t\n    // Directional light source\n    vec3 lightDir = normalize(vec3(0.8, 1.0, -0.8));\n    \n    // The intensity/color of light (all three values are the same for white light)\n    vec3 lightCol = vec3(1.0);\n    \n    // Applies the 'base color' of the light\n    vec3 baseLightCol = vec3(1.0, 1.0, 1.0);\n    lightCol *= baseLightCol;\n    \n    // Applies normal-based lighting\n    vec3 normal = getNormal(p);\n    float normalLight = max(0.05, saturate(dot(normal, lightDir)));\n    //float normalLight = max(0.1, step(0.5, dot(normal, lightDir)));\n    lightCol *= normalLight;\n    \n    // Gets the diffuse lighting\n    vec3 diffuse = getDiffuse(p);//vec3(0.368, 0.372, 0.901);\n    \n    // Get the final color\n    vec3 col = lightCol * diffuse;\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\t\n    vec3 skyCol = vec3(0.9, 0.9, 0.9);\n    float fogFalloff = 0.1;\n    float fogDist = 90.0;\n    \n    float t = raytrace(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    // If the terrain is hit\n    if (t >= 0.0) {\n    \t\n        // Get the color of the terrain\n        col = getColor(ro + t * rd);\n        \n        // Add the fog (better fog functions exist though)\n        float fogAmount = exp(fogFalloff * (t - fogDist));\n        col = mix(col, skyCol, fogAmount);\n        \n    }\n    \n    // If the terrain is not hit\n    else {\n        col = skyCol;\n    }\n    \n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, VSCALE + 2.0, 0.0) + vec3(1.0, 0.0, 1.0) * iTime * 0.5;\n    vec3 rd = normalize(vec3(p, 1.4));\n\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.16, -0.1):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Render and output the ray to screen\n    vec3 col = render(ro, rd);\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}