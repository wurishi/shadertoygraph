{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.14159265359\n#define RES iResolution\n#define PT iMouse\n#define smin smoothmin\n#define smax smoothmax\n\nfloat d0 = 120.;\n\n// Signed distance function for a plane\nfloat sdPlane(vec3 p, vec3 n, float h) {\n  return dot(p, n) + h;\n}\n\nfloat sdCylinder(vec3 p, in float r, in float h, in int hAxis) {\n  vec2 aR, aH;\n\n  if (hAxis == 0) { // x-axis\n    aR = p.yz, aH = vec2(p.x, 0.0);\n  } else if (hAxis == 1) { // y-axis\n    aR = p.xz, aH = vec2(p.y, 0.0);\n  } else { // z-axis\n    aR = p.xy, aH = vec2(p.z, 0.0);\n  }\n\n  vec2 d = vec2(length(aR) - r, abs(aH.x) - h / 2.0);\n\n  // Return the distance to the cylinder\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCuboid(vec3 p, vec2 a, float h) {\n  vec3 d = abs(p) - vec3(a.x, h, a.y);\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat smoothmin(float d1, float d2, float k) {\n  float h = max(k - abs(d1 - d2), 0.) / k;\n  return min(d1, d2) - h * h * k * (1. / 4.);\n}\n\nfloat smoothmax(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.) / k;\n    return max(d1, d2) + h * h * k * (1. / 4.);\n}\n\nfloat noise(vec2 p) {\n  float random = dot(p,vec2(12.235,78.37283));\n  random = sin(random);\n  random *= 4358.4346;\n  random += fract(iTime);\n  random = fract(random);\n  return 1.5 - random*4.5;\n}\n\nint partID = 1; // identifier for surfaces to apply specific color to\n\nfloat map(vec3 p) {\n\n  float m = 5.; // mod width\n  vec3 p0 = p; // pre-mod state\n\n  float ceilY = 8.; // ceiling,\n  p.y-=ceilY;\n  float ceiling = -p.y;\n\n  p = p0; // reset to pre-mod base\n\n  p.xz = mod(p.xz - m,2.*m) - m;\n  \n  vec3 p1 = p; // baseline for mods placed at the center of the columns (with mods in place)\n\n  float column = sdCylinder(p, .5, 9., 1); // the round columns\n\n  float flutes = 1.;\n  float fTimes = 24.;\n\n  for (float i = 0.; i < fTimes; i++) {\n    float fAngle = 2.*PI/fTimes*i;\n    p.z+= .5*cos(fAngle);\n    p.x+= .5*sin(fAngle);\n    float f = sdCylinder(p, 0., 7.7, 1) - .04;\n    \n    flutes = min(flutes, f);\n    p = p1; // reset to column baseline (with mods applied)\n  }\n\n  column = max(column,-flutes); // round column with etched flutes\n\n  p.y+=4.05;\n  float cRing = sdCylinder(p, .5, 0., 1) - .05;\n  column = min(column, cRing); // column with added ring around its circumference at the bottom\n\n  float bA = .5;\n  float bR = .15;\n  float baseH = 2.;\n  p.y += baseH + 2.*bR;\n  vec2 a = vec2(.5);\n  float base = sdCuboid(p, a, baseH) - bR; // tall cuboid base for the round column\n\n  float bd = bA+bR;\n  p.xz+=bd;\n  float bFlutes = 1.;\n\n  for (float i=0.;i<4.;i++) {\n    if (i == 1.) { p.x -=2.*bd; }\n    else if (i == 2.) { p.z -=2.*bd; }\n    else if (i == 3.) { p.x +=2.*bd; }\n\n    float bF = sdCuboid(p,vec2(0.),3.) - .35;\n    bFlutes = min(bFlutes, bF);\n\n  }\n\n  p = p1;\n  base = max(-bFlutes, base); // cuboid base with round flutes running down each vertical edge\n\n  p.y+=6.5;\n  float antiBev = sdCuboid(p,vec2(.55),2.2);\n  base = min(base, antiBev); // an extra cuboid sticking out of the flutes\n\n  column = smin(column,base, bR); // column is smoothly melted into the base\n\n  float floor = sdPlane(p, vec3(0.0, 1.0, 0.0), 2.2); // blank floor\n\n  float tiles = floor; // extra surface identical to the floor that colorful patterms will be cut out of \n\n  float pattern1 = min( // said pattern\n                    min(max(length(p.xz) - m - .125, 1. - length(p.xz) + m*2./3.),\n                    min(\n                      mix(abs(p.x),abs(p.z),.5) - m/3.5,\n                      max(abs(p.x),abs(p.z)) - m/2.5\n                      )\n                    ),\n                    -max(\n                      mix(abs(p.x), abs(p.z),.25),\n                      mix(abs(p.x), abs(p.z),.75)\n                    ) + 4.6\n                   );\n\n  tiles = max(tiles, pattern1); // the pattern is cut out\n\n  p = p1; // reset to column baseline\n\n  p.y-=6.2;\n\n  float cBase = sdCuboid(p, a, baseH+10.); // a cuboid at the top of the cylindrical column, similar to the one forming the base\n\n  p.y+=1.3;\n\n  p.y-=21.;\n  p.y/=25.;\n\n  float r = 1.;\n  float ovoid = sdSphere(p, r);\n  \n  cBase = max(cBase,ovoid); // an ellyptical spheroid is cut out of the cuboid\n\n  p = p1;\n\n  p.y-=4.;\n\n  float cRing2 = sdCylinder(p, .5, 0., 1) - .05; // another ring around the column's circumference is added at its top\n  cBase = min(cBase,cRing2); // the ring is melted into the cuboid\n\n  p = p0;\n  p.x-=m;\n  p.x = mod(p.x - m,2.*m) - m;\n  p.y-=ceilY;\n\n  float cRadius = m - .5; // radius of the arches in the ceiling\n  float ceilArcX = smax(abs(p.x), p.y, cRadius) - cRadius;\n\n  ceiling = max(ceiling,-ceilArcX); // a cylindrical shape is carved out of the ceiling along the X axis\n\n  p = p0;\n  p.z-=m;\n  p.z = mod(p.z - m,2.*m) - m;\n  p.y-=ceilY;\n\n  float ceilArcZ = smax(abs(p.z), p.y, cRadius) - cRadius; // // a similar cylindrical shape is carved out of the ceiling along the Z axis\n\n  ceiling = max(ceiling,-ceilArcZ);\n\n  float result = min(min(min(column, base), min(floor,ceiling)),cBase);\n\n  if (result == tiles) {\n    partID = 1;\n  }\n  else {\n    partID = 2;\n  }\n\n  return result;\n}\n\nvec3 norm(vec3 p) {\n  float h = 1e-3;\n  vec2 k = vec2(-1, 1);\n  return normalize(\n    k.xyy * map(p + k.xyy * h) +\n    k.yxy * map(p + k.yxy * h) +\n    k.yyx * map(p + k.yyx * h) +\n    k.xxx * map(p + k.xxx * h)\n  );\n}\n\nfloat raymarch(inout vec3 p, vec3 rd) {\n  float dd = 0.0;\n  for (float i = 0.0; i < 100.0; i++) {\n    float d = map(p);\n    if (d < 1e-4 || dd > d0) break;\n    p += rd * d;\n    dd += d;\n  }\n  return dd;\n}\n\n\nfloat shadow(vec3 p, vec3 lp) {\n    float shd=1., maxd=length(lp-p);\n    vec3 l=normalize(lp-p);\n    for (float i=1e-3; i<maxd;) {\n        float d=map(p+l*i);\n        if (d<1e-3) {\n            shd=.0;\n            break;\n        }\n        shd=min(shd,128.*d/i);\n        i+=d;\n    }\n    return shd;\n}\n\nvec3 render(vec3 p, vec3 rd) {\n  float d = raymarch(p, rd);\n\n  vec3 col = vec3(0);\n\n  if (partID == 1) {\n    col = vec3(-.25);\n  }\n  else {\n    col = vec3(0);\n  }\n\n  vec3 lp = vec3(5., -5, iTime);\n\n  if (d < d0) {\n    vec3 n = norm(p),\n         l = normalize(lp - p);\n    float diffuse = clamp(dot(l, n), 0., 1.),\n          reflective = clamp(dot(reflect(rd, n), l), .0, 1.0);\n    \n    col += diffuse*shadow(p+n*5e-2, lp);;\n    col = mix(col, vec3(1. + .1*cos(iTime*15.)), .5);\n  } else {\n    col += mix(\n      vec3(0.),\n      vec3(.01, .02, .03),\n      .5 - rd.z*1.5\n      );\n  }\n\n  float fogFactor = d / d0; // black fog imitating darkness\n  vec3 fogColor = -1.5 + vec3(0,-length(rd)*5.,0);\n\n  col = mix(col, fogColor, fogFactor);\n  col*=vec3(1.,.25,0);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * RES.xy) / RES.y;\n\n  float mouseX = (iMouse.x / iResolution.x) * 2.0 - 1.0;\n  float mouseY = (iMouse.y / iResolution.y) * 2.0 - 1.0;\n\n  vec3 ro = vec3(5. + 3.*cos(iTime/10.), -5.0*cos(iTime/3.), -5.0 + iTime);\n\n  // View angles based on mouse input\n  float angleX;\n  float angleY;\n  \n  if (iMouse.x > 0.) {\n      angleX = mouseX * PI; // Horizontal rotation\n      angleY = mouseY * PI * .5; // Vertical rotation\n  }\n  else {\n      angleX = 0.;\n      angleY = 0.;\n  }\n\n  // Calculate the forward direction\n  vec3 fwd = vec3(\n    cos(angleY) * sin(angleX),\n    sin(angleY),\n    cos(angleY) * cos(angleX)\n  );\n\n  // Calculate the right and up directions\n  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), fwd));\n  vec3 up = cross(fwd, right);\n\n  // Calculate the ray direction\n  vec3 rd = normalize(fwd + uv.x * right + uv.y * up);\n\n  float t = 0.0; // Total distance travelled\n\n  for (int i = 0; i < 80; i++) {\n    vec3 p = ro + rd * t; // Position along the ray\n    float d = map(p); // Current distance in the scene\n    t += d; // Total distance, updated by current distance\n\n    if (d < 0.001 || t > 100.0) break; // Break if close enough or too far\n  }\n\n  vec3 col = render(ro, rd);\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4Xcczn","date":"1734615243","viewed":54,"name":"Church of Torus, Temple of Cubus","username":"MackFitz","description":"An endless chapel of tall columns. A monument to the marriage of the circle and the square in its many forms. Fly through its dark halls in this interactive 3D demo. To start, CLICK ANYWHERE in the scene & move around freely!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["interactive","animation","cylinder","min","max"],"hasliked":0,"parentid":"","parentname":""}}