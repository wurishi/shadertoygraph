{"ver":"0.1","info":{"id":"3tBGRG","date":"1559889827","viewed":354,"name":"Rainbow Smoke","username":"depp","description":"Simple volumetric clouds with lighting and rainbow colors","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["clouds","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// Hash Without Sine 2 https://www.shadertoy.com/view/XdGfRR\nfloat hash13(in uvec3 q) {\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\nfloat hash13(in vec3 p) {\n\treturn hash13(uvec3(ivec3(p)) * UI3);\n}\n\nvec3 hash33(in uvec3 q) {\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p) {\n\treturn hash33(uvec3(ivec3(p)));\n}\n\nfloat noise(in vec3 p) {\n    vec3 vf = floor(p);\n    uvec3 i = uvec3(ivec3(vf));\n    vec3 f = p - vf;\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(dot(hash33(i + uvec3(0,0,0)), f - vec3(0.0,0.0,0.0)),\n                       dot(hash33(i + uvec3(1,0,0)), f - vec3(1.0,0.0,0.0)), u.x),\n            \t   mix(dot(hash33(i + uvec3(0,1,0)), f - vec3(0.0,1.0,0.0)),\n                \t   dot(hash33(i + uvec3(1,1,0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n           \t   mix(mix(dot(hash33(i + uvec3(0,0,1)), f - vec3(0.0,0.0,1.0)),\n               \t\t   dot(hash33(i + uvec3(1,0,1)), f - vec3(1.0,0.0,1.0)), u.x),\n               \t   mix(dot(hash33(i + uvec3(0,1,1)), f - vec3(0.0,1.0,1.0)),\n                       dot(hash33(i + uvec3(1,1,1)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z);\n}\n\nconst mat3 noisemat1 = mat3(\n\t-0.45579627,  0.75217353,  0.47590413,\n\t 0.03119306, -0.5208463 ,  0.85308038,\n\t-0.88953738, -0.40367575, -0.21393721);\nconst mat3 noisemat2 = mat3(\n\t 0.89766414,  0.22826049, -0.37695654,\n\t-0.03212991,  0.88702091,  0.46061001,\n\t 0.4395074 , -0.40136151,  0.80358085);\n\nvec3 noise3(in vec3 p) {\n\treturn vec3(noise(p), noise(noisemat1 * p), noise(noisemat2 * p));\n}\n\nfloat fogdensity(in vec3 pos, float r, vec2 sc) {\n    vec3 offset = noise3(1.2 * pos + vec3(8.0, sc));\n    offset += 0.5 * noise3(2.0 * pos + vec3(-8.0, sc));\n    float a = r - 5.0;\n    return clamp(3.0 * noise(pos * 0.6 + offset) - 0.2 - 0.2 * a * a, 0.0, 1.0);\n}\n\nvec4 fog(in vec3 pos, vec2 sc) {\n    float r = length(pos);\n    float density = fogdensity(pos, r, sc);\n    if (density < 0.001) {\n        return vec4(0.0);\n    }\n    vec3 lightdir = normalize(vec3(0.0, 0.0, 4.0) - pos);\n    vec3 pos2 = pos + 0.1 * lightdir;\n    float density2 = fogdensity(pos2, length(pos2), sc);\n    float occlusion = 1.0 - density2 * 2.0;\n    vec3 color = abs(pos);\n    color = smoothstep(\n        min(min(color.r, color.g), color.b),\n        max(max(color.r, color.g), color.b),\n        color);\n    return vec4(color * density * occlusion, density);\n}\n\nvec4 render(in vec3 origin, in vec3 dir, float jitter) {\n    vec2 sc = vec2(sin(iTime * 0.5), cos(iTime * 0.5));\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < 40; i++) {\n        float t = (float(i) + jitter) * 0.2;\n        vec3 pos = origin + t * dir;\n        vec4 fcolor = fog(pos, sc);\n        color += fcolor * (1.0 - color.a);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n    uv *= 0.6;\n\n    float s = sin(iTime), c = cos(iTime);\n    vec3 pos = vec3(s, -c, 0.0) * 4.0;\n    mat3 rot = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n    vec3 dir = vec3(-s, c, 0.0);\n    \n    float jitter = hash13(vec3(fragCoord, iTime * 60.0));\n    fragColor = render(pos, rot * normalize(vec3(1.0, -uv.x, uv.y + sin(iTime * 0.4))), jitter);\n}","name":"Image","description":"","type":"image"}]}