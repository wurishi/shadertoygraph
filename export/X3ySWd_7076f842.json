{"ver":"0.1","info":{"id":"X3ySWd","date":"1720788999","viewed":191,"name":"GLSL Mie Plotter","username":"martinsh","description":"GLSL implementation of BHMIE by Bohren and Huffmann in \"Absorption and scattering of light by small particles\" (ISBN 0-471-29340-7)","likes":16,"published":1,"flags":32,"usePreview":1,"tags":["clouds","scattering","rainbow","atmosphere","rayleigh","diffraction","mie","leeplot","mieplot"],"hasliked":0,"parentid":"4XK3zc","parentname":"Mie scattering in GLSL"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\t\t\t         GLSL Mie Plotter\n\t\t\t\t\tAssembled by Martins Upitis\n                (all credit goes to Ford Perfect ❤)\n\n----------------------------------------------------------------------------\n                             WHAT IS THIS?\n----------------------------------------------------------------------------\n    \"GLSL Mie Plotter\" outputs a LUT, sRGB & gamma corrected. My primary goal\n    is to use it as a Mie/Rayleigh phase for atmosphere and cloud/rainfall rendering\n    in game engines.\n    \n    Vertical axis corresponds to particle sphere (droplet) size in log scale\n    where top is the smallest drop and bottom - largest.\n    Horizontal axis is the scattering angle where right is angle away from light source\n    and left - towards the light direction.\n    Wait for the simulation to finish. Upper bar shows the simulation progress.\n    \n    For more info: https://www.philiplaven.com/index1.html (by Philip Laven)\n\n----------------------------------------------------------------------------\n                            BACKGROUND\n----------------------------------------------------------------------------\n\n    I am a traditional artist turned into to technical artist with a love\n    for GLSL shaders. I`m not a pure coder, so just a warning - I might be\n    doing some things wrong.\n    \n    Ever since I got interested in atmosphere rendering, \n    I felt like the general Mie scattering approach is lacking in nuances, \n    especially when particle sizes get higher - for simulation of rainbows,\n    glories, fogbows and cloud rendering. I started looking for a universal \n    approach that covers the full range of vapor/aerosol particle sizes. \n    \n    Philip Laven`s \"MiePlot\" [2] was my first go-to for Mie LUTs, but it felt\n    like the software was more meant for scientific/research oriented and\n    usable LUT calculation was extremely slow.\n    \n    After some research I found out about an artist Joost Rekveld, who\n    managed to calculate a LUT and combine it with GLSL shader for his art\n    installation \"Ursae Minoris\" [3]\n\n    Still the LUT was generated on CPU not GPU. \n    For some time I tried translating BHMIE code [4] to Shadertoy, but without\n    an intuitive understanding what is happening and no proper coding skills,\n    it was meant to fail.\n\n    \n    Then I found \"Mie scattering in GLSL\" By Ford Perfect [1]\n    Who did exactly what I had in mind!\n    \n    extras:\n    - SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#\n    - wavelength to XYZ math by sciecode [6]\n    \n    References and credits:\n    \n    [1] \"Mie scattering in GLSL\" by Ford Perfect https://www.shadertoy.com/view/4XK3zc\n    [2] \"MiePlot\" https://www.philiplaven.com/mieplot.htm\n    [3] \"Ursae Minoris\" by Joost Rekveld https://www.joostrekveld.net/?p=1838\n    [4] \"BHMIE\" https://github.com/cfinch/Mie_scattering/tree/master\n    [5] \"96-bit 8x12 Font\" by Flyguy https://www.shadertoy.com/view/Mt2GWD\n    [6] \"spectral iridescence\" by sciecode https://www.shadertoy.com/view/DtlfRX\n\n    \n----------------------------------------------------------------------------\n                             LIMITATIONS\n----------------------------------------------------------------------------    \n\n    - Getting out the LUT from shadertoy is tricky and you lose floating point precision.\n    - Rather heavy on any GPU, but considering that I used to plot this same LUT\n    for hours (in Philip Laven`s amazing MiePlot), this is a massive improvement.\n    \n----------------------------------------------------------------------------\n                             USER VARIABLES\n----------------------------------------------------------------------------      \n    - Look in Common Shader for tweakables\n    - Remember to press \"Reset Time\" ▌◀ button once you change parameters (I will think of a better way to re-simulate)\n    \n----------------------------------------------------------------------------\n                               CHANGELOG\n----------------------------------------------------------------------------      \n    14-07-2024 - Added Cauchy IOR calculator, added minimal particle size jitter.\n    15-07-2024 - Logscale grid for particle droplet radius and linear grid for scattering angle. Added simulation progress bar.\n    16-07-2024 - LUT resolution can be defined, simulation speed is not depending on window resolution now.\n*/\n\n//#define FONT_EFFECTS\n#define AUTO_FONT_SPACING\n\n#define FONT_SAMPLER iChannel1\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n// SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n    {\n        return 0.1f;\n    }\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )\n    {     \n        return 0.8f;\n    }\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n    \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n#ifdef FONT_EFFECTS    \n    float fShadowDistance;\n    vec2 vNormal;    \n#endif\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n#ifdef FONT_EFFECTS        \n    state.fShadowDistance = 1000000.0;\n    state.vNormal = vec2(0.0);    \n#endif    \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold;\n#ifdef FONT_EFFECTS        \n    bool bShadow;\n    vec2 vShadowOffset;\n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(8.0f, 8.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n#ifdef FONT_EFFECTS        \n    style.vShadowOffset = vec2(0);\n    style.bShadow = false;\n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n#ifdef FONT_EFFECTS            \n    vec3 vOutlineColor;\n    vec3 vHighlightColor;\n    float fOutlineWeight;\n    float fBevelWeight;\n    float fShadowSpread;\n    float fShadowStrength;\n    vec2 vLightDir;\n#endif    \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;\n#ifdef FONT_EFFECTS            \n    style.vOutlineColor = vec3(1);\n    style.vHighlightColor = vec3(0);\n    style.fOutlineWeight = 0.0f;\n    style.fBevelWeight = 0.0f;\n    style.fShadowSpread = 0.0f;\n    style.fShadowStrength = 0.0f;\n    style.vLightDir = vec2(-1.0f, -0.5f );\n#endif    \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;\n#ifdef FONT_EFFECTS            \n        state.vNormal = v.yz;\n#endif        \n    }\n\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fShadowDistance = SampleCharacter( iChar, vUV - style.vShadowOffset ).a;\n        if ( style.bBold )\n        {\n            fShadowDistance -= 0.025f;\n        }\n        \n        if ( fShadowDistance < state.fShadowDistance )\n        {\n            state.fShadowDistance = fShadowDistance;\n        }        \n    }\n#endif\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fSize = renderStyle.fFontWeight + renderStyle.fOutlineWeight;\n        float fBlendShadow = clamp( (state.fShadowDistance - fSize - renderStyle.fShadowSpread * 0.5) / -renderStyle.fShadowSpread, 0.0, 1.0);\n        color.rgb = mix( color.rgb, vec3(0.0), fBlendShadow * renderStyle.fShadowStrength);    \n    }\n\n    if ( renderStyle.fOutlineWeight > 0.0f )\n    {        \n        float fBlendOutline = GetFontBlend( state, style, renderStyle.fFontWeight + renderStyle.fOutlineWeight );\n        color.rgb = mix( color.rgb, renderStyle.vOutlineColor, fBlendOutline);\n    }\n#endif\n    \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n\t\n#ifdef FONT_EFFECTS            \n    if ( renderStyle.fBevelWeight > 0.0f )\n    {    \n        float fBlendBevel = GetFontBlend( state, style, renderStyle.fFontWeight - renderStyle.fBevelWeight );    \n        float NdotL = dot( state.vNormal, normalize(renderStyle.vLightDir ) );\n        float shadow = 1.0 - clamp(-NdotL, 0.0, 1.0f);\n        float highlight = clamp(NdotL, 0.0, 1.0f);\n        highlight = pow( highlight, 10.0f);\n        vCol = mix( vCol, vCol * shadow + renderStyle.vHighlightColor * highlight, 1.0 - fBlendBevel);\n    }\n#endif\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i<CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\n\nvoid PrintMessage( inout PrintState state, LayoutStyle style )\n{\n    uint strA[] = uint[] ( _H, _e, _l, _l, _o, _COMMA, _SP, _w, _o, _r, _l, _d, _PERIOD, _EOL );\n    ARRAY_PRINT( state, style, strA );\n\n    uint strB[] = uint[] ( _ITALON, _A, _B, _C, _1, _2, _3, _ITALOFF, _EOL );\n    ARRAY_PRINT( state, style, strB );\n    \n    uint strC[] = uint[] ( _BOLDON, _A, _B, _C, _1, _2, _3, _BOLDOFF, _SP );\n    ARRAY_PRINT( state, style, strC );\n}\n\n\n#define TILE_SIZE 1.0\n#define LINE_WIDTH 2.0\n\n//grid drawing functions\n\n//horizontal linear scale grid for angle in degrees visualization\nfloat grid_lin_scale(in float val,in float minVal,in float maxVal)\n{\n    float valRange = val_lin_scale(val,minVal,maxVal);\n  \n    float grid = 0.0;\n    float line = 0.0;\n    \n    float scales[6] = float[6](1.0, 5.0, 10.0, 90.0, 180.0, 360.0);\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        grid = 1.0 * abs(mod(valRange + 0.5*TILE_SIZE, TILE_SIZE * scales[i]) - 0.5) / fwidth(valRange) / LINE_WIDTH;\n    \tline = max(line, pow(2.0, float(i)) * (1.0 - min(grid, 1.0)));\n    }    \n    return line;\n}\n\n//vertical log scale grid for sphere radius visualization\n// The logarithmic frequency scale grid from the GLSL-based spectrum analyzer in my CreamTracker 64k softsynth tracker\n// Copyright (C) 2016 by Benjamin 'BeRo' Rosseaux\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\nfloat grid_log_scale(in float val,in float minVal,in float maxVal)\n{\n  float onePixel = LINE_WIDTH / iResolution.y;\n  float line = 0.;\n\n  float lowLog = log(minVal) / ln10;\n  float highLog = log(maxVal) / ln10;\n  float scale = 1.0 / (highLog - lowLog);\n  float valLogRange = exp(((val / scale) + lowLog) * ln10);\n  \n  float currentMajorDecade = exp(floor(log(valLogRange) / ln10) * ln10);\t\n  float nearestMajorDecade = exp(floor((log(valLogRange) / ln10) + 0.5) * ln10);\t\n  float nearestMinorDecade = floor((valLogRange / currentMajorDecade) + 0.5) * currentMajorDecade;\t\n  float nearestSubMinorDecade = floor((valLogRange / (currentMajorDecade * 0.1)) + 0.5) * (currentMajorDecade * 0.1);\t\n  //float ignoreFirstAndLastXFactor = step(onePixel, val) * (1.0 - step(1.0 - onePixel, val)); \n  float ignoreFirstAndLastXFactor = 1.0;\n  //line = mix(line, 0.0625, smoothstep(onePixel, 0.0, abs((((log(nearestSubMinorDecade) / ln10) - lowLog) * scale) - val)) * ignoreFirstAndLastXFactor);\n  line = mix(line, 0.15,   smoothstep(onePixel, 0.0, abs((((log(nearestMinorDecade) / ln10) - lowLog) * scale) - val)) * ignoreFirstAndLastXFactor);\n  line = mix(line, 0.5,    smoothstep(onePixel, 0.0, abs((((log(nearestMajorDecade) / ln10) - lowLog) * scale) - val)) * ignoreFirstAndLastXFactor);\n  return line;\n}\n\nvec3 progressBar(in vec2 uv)\n{\n    float bar = 0.0;\n    vec3 rgb = vec3(0.0);\n    float progress = min(float(iFrame) + MIN_WAVELENGTH, MAX_WAVELENGTH);\n    progress = linearScale(progress, MIN_WAVELENGTH, MAX_WAVELENGTH);\n    float p = float(uv.x<progress);\n    \n    if (uv.x < 1.0 && uv.x > 0.0)\n    if (uv.y > 1.015 && uv.y < 1.035)\n    if (uv.x < p)\n    \n    {\n        bar = uv.x;\n        float wl = val_lin_scale(bar,MIN_WAVELENGTH,MAX_WAVELENGTH);\n        vec3 xyz = wavelength2xyz(wl);\n        rgb = linear2srgb(xyz2rgb(xyz)+vec3(0.03));\n    }\n    return rgb;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 onePixel = vec2(2.0) / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 lutscale = (LUT_RESOLUTION/iResolution.xy);\n    vec2 texuv = fragCoord/iResolution.xy * lutscale; //LUT SCALE\n    \n    float AR = iResolution.x/iResolution.y;\n    uv.xy -= 0.5; // offset -0.5\n    texuv.xy -= 0.5*lutscale;\n    #ifdef SQUARE\n    uv.x *= AR; // fix aspect ratio\n    texuv.x *= AR;\n    #endif\n    \n    #ifndef FULLSCREEN    \n    uv *= vec2(1.1,1.1);\n    texuv *= vec2(1.1,1.1);\n    #endif\n    \n    uv.xy += 0.5; // offset it back\n    texuv.xy += 0.5*lutscale;\n  \n    float gridH = grid_lin_scale(uv.x,MIN_ANGLE,MAX_ANGLE)*0.2;\n    float gridV = grid_log_scale(1.0-uv.y,MIN_SIZE,MAX_SIZE);\n    float grid = gridV+max(gridH,gridV);\n  \n    vec2 vCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y );   \n   \n    vec2 vCanvasPixelSize = vec2(1.0);\n\n\tbool bScaleWithResolution = true;    \n    \n    if ( bScaleWithResolution )\n    {\n    \tvCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y ) * vec2(640.0, 360.0) / iResolution.xy;\n        vCanvasCoord -= vec2(640.0, 360.0)/2.0;\n        #ifndef FULLSCREEN\n        vCanvasCoord *= vec2(1.1,1.1);\n        #endif\n        #ifdef SQUARE\n        vCanvasCoord.x *= AR; // fix aspect ratio\n        #endif\n        vCanvasCoord += vec2(640.0, 360.0)/2.0;\n        \n    \tvCanvasPixelSize = vec2(640.0, 360.0) / iResolution.xy;\n        \n        //vec2 dVdx = dFdx(vCanvasCoord);\n        //vec2 dVdy = dFdy(vCanvasCoord);\n        //vCanvasPixelSize = vec2( length(vec2(dVdx.x, dVdy.x) ), length(vec2(dVdx.y, dVdy.y) ) );\n    }\n    \n    PrintState state = PrintState_InitCanvas( vCanvasCoord, vCanvasPixelSize );\n    LayoutStyle style = LayoutStyle_Default();\n    \n    #ifdef SQUARE\n    style.vSize.x *= AR;// fix aspect ratio\n    #endif\n    \n    //verical numbering\n    int vnums = int(log(MAX_SIZE-MIN_SIZE));\n    \n    for (int v = -1; v < vnums; ++v)\n    {     \n        state.vPos.x = vCanvasCoord.x-640.0-style.vSize.x/2.0;\n        float ypos = linearToLogScale(pow(10.0,float(v)), MIN_SIZE, MAX_SIZE)*360.0;\n        state.vPos.y = vCanvasCoord.y-ypos-style.vSize.y/4.0;\n        \n        float num = max(pow(10.0,float(v)),MIN_SIZE);\n        \n        Print( state, style, num ,1);\n    }\n    \n    //horizontal numbering\n    int hnums = int((MAX_ANGLE-MIN_ANGLE)/10.0);\n    \n    for (int h = int(MIN_ANGLE/10.0); h < int(MIN_ANGLE/10.0)+hnums+1; ++h)\n    {\n        float xpos = linearScale(float(h*10), MIN_ANGLE, MAX_ANGLE)*640.0;\n        \n        state.vPos.x = vCanvasCoord.x-xpos+style.vSize.x/2.0;\n\n        state.vPos.y = vCanvasCoord.y-360.0-style.vSize.y;\n\n        Print( state, style, int(max(float(h)*10.0,MIN_ANGLE)));\n    }\n    \n\n    RenderStyle renderStyle = RenderStyle_Default( vec3(1.0) );\n    vec3 col = xyz2rgb(texture(iChannel0,texuv).rgb)*EXPOSURE;\n    col = linear2srgb(col);\n    col = mix(col,clamp(1.0-col,vec3(0.0),vec3(1.0)),grid*GRID_OPACITY);\n    \n    \n    if (uv.x > 1.0 || uv.x < 0.0 || uv.y > 1.0 || uv.y < 0.0)\n    {\n        \n        col = vec3(0.0); //clear color\n        col += progressBar(uv);\n        #ifndef FULLSCREEN\n        RenderFont( state, style, renderStyle, col ); //render text\n        #endif\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Public Domain under http://unlicense.org, see link for details.\n\n// GLSL implementation of computations for Mie scattering by a homogeneous\n// sphere, mostly adapted from BHMIE.f by Craig F. Bohren and\n// Donald R. Huffman (with modifications by Bruce T. Draine) with some\n// elements of MIEV0.f by Warren J. Wiscombe.\n\n// Porting to GLSL introduced several known drawbacks, the blame \n// for which (along with whatever unknown ones) is entirely with me.\n// Do be advised against using this code for anything remotely \"serious\",\n// at least not without extensive prior testing.\n\n// In this GLSL port, all calculations are carried in single precision\n// (BHMIE.f uses double precision internally, though input and output\n// are single precision) and all use of arrays is avoided. Said use of\n// arrays in the original is twofold. Firstly, BHMIE computes the\n// coefficients for several angles and uses arrays for both output\n// and intermediates. This is avoided by changing this implementation\n// to provide results for single angle only. This introduces inefficiency,\n// as some things are calulated over and over, but such is the way of the GPU.\n// Secondly, as per [1], Mie scattering calcualtions are fundamentally\n// summations of a number of terms of a series, coefficients of which\n// involve several quantities related to Bessel functions. The problem\n// is that for some of these quantities the stable recurrences to compute\n// them are upwards, and for some of them downwards. Which means that\n// whatever direction your loop is structured, some of the recurrences\n// are backwards, so you end up storing precomputed coefficients for them\n// (or compute them each iteration, increasing run time to O(n^2)).\n// In this implementation we grudgingly use (potentially unstable) upwards\n// recurrences for everything. The investigation in [2] (carried, admittedly,\n// for double precision) indicates that upwards recurences provide acceptable\n// accuracy in certain regions. As a rule of thumb, you need all of the\n//     1. Relatively large (above 1) size parameter.\n//     2. But not too large (below several hundreds).\n//     3. Small imaginary part of refraction index, compared to the real part.\n// to be relatively safe. Functions implementing the condition tests\n// from [2] are provided to test if the input is considered safe.\n// NOTE: limited testing in float32 paints a considerably worse picture,\n// but is broadly similar. As long as you are content with relative error\n// on the scale of 10%, the region\n//     0.125<  x  <25\n//     1.050<Re(m)<10\n//     0.000<Im(m)<10\n// looks safe.\n// NOTE: the above generally holds for e.g. small (1..10 micrometres) water\n// droplets in clouds in visible spectrum.\n// Perhaps fancier calculation methods (see e.g. [3] and [4]) can help\n// mitigating errors.\n// For small x and |m|*x, Rayleigh-style approximation provides adequate\n// accuracy. Formula from [2] is provided.\n\n// NOTE: as run time is roughly proportional to the size parameter,\n// the computations for large particles can be slow.\n\n// References: \n//     [1] Bohren, Craig F. and Donald Ray Huffman. “Absorption and Scattering of Light by Small Particles.” (1998).\n//     [2] W. J. Wiscombe, \"Improved Mie scattering algorithms,\" Appl. Opt. 19, 1505-1509 (1980)\n//         https://opg.optica.org/ao/fulltext.cfm?uri=ao-19-9-1505&id=23949\n//     [3] Lentz, William. (1976). Generating Bessel Functions In Mie Scattering Calculations Using Continued Fractions. Applied optics. 15. 668-71. 10.1364/AO.15.000668. \n//     [4] Du, H. (2004). Mie-scattering calculation. Applied Optics, 43(9), 1951. doi:10.1364/ao.43.001951 \n\n//==============================================================================\n\n\n//==============================================================================\n// Function for calculating Mie scattering.\n\n// Input:\n//     x   - size parameter, 2*pi*r/lambda.\n//           NOTE: 2*pi*Nmedium*r/lambda, for arbitrary medium.\n//     m   - complex relative refraction index, Nparticle/Nmedium.\n//           IMPORTANT: following [1], we expect Im(m)>=0, whereas\n//           many texts adopt Im(m)<=0 convention.\n//     mu  - cosine of the scattering angle.\n// Output: matrix with the following 4 columns:\n//     [0] - S1 element of the amplitude scattering matrix (complex number).\n//     [1] - S2 element of the amplitude scattering matrix (complex number).\n//     [2] - vec2(Qext,Qsca) - efficiency factors for extinction and scattering.\n//     [3] - vec2(Gsca,0) - asymmetry parameter.\nmat4x2 mie(float x,vec2 m,float mu)\n{\n    vec2 y=x*m;\n    float pi0=0.0,pi1=1.0,pi;\n    vec2 s1=vec2(0.0,0.0);\n    vec2 s2=vec2(0.0,0.0);\n    float tau;\n    float psi0= cos(x);\n    float psi1= sin(x);\n    float chi0=-sin(x);\n    float chi1= cos(x);\n    vec2 xi1=vec2(psi1,-chi1);\n    float qext=0.0;\n    float qsca=0.0;\n    float gsca=0.0;\n    vec2 an=vec2(0.0,0.0);\n    vec2 bn=vec2(0.0,0.0);\n    vec2 an1 = vec2(0.0,0.0);\n    vec2 bn1 = vec2(0.0,0.0); \n#if 0\n    vec2 D=cdiv(csin(y)-cmul(y,cmul(y,csin(y))+ccos(y)),cmul(y,cmul(y,ccos(y))-csin(y)));\n#else\n    // The original expression is\n    //     D=(sin(z)-z*cos(z)-z*z*sin(z))/(z*z*cos(z)-z*sin(z))\n    // which we evaluate avoiding overflow.\n    float tc=cos(y.x);\n    float ts=sin(y.x);\n    \n    float hc=1.0+exp(-2.0*y.y);\n    float hs=1.0-exp(-2.0*y.y);\n    \n    vec2 cs=vec2(ts*hc, tc*hs);\n    vec2 cc=vec2(tc*hc,-ts*hs);\n    vec2 D=cdiv(cs-cmul(y,cmul(y,cs)+cc),cmul(y,cmul(y,cc)-cs));\n#endif\n\n    int nstop=int(round(x+4.0*pow(x,0.3333)+2.0));\n    \n    for(int k=0;k<nstop;++k)\n    {\n        float n=float(k+1);\n        float fn=(2.0*n+1.0)/(n*(n+1.0));\n        \n        float psi=(2.0*n-1.0)*psi1/x-psi0;\n        float chi=(2.0*n-1.0)*chi1/x-chi0;\n        vec2 xi=vec2(psi,-chi);\n        \n\n        vec2 an1=an;\n        vec2 bn1=bn;\n\n        \n        //Compute AN and BN:\n        an=(cdiv(D,m)+vec2(n/x,0.0))*psi-vec2(psi1,0.0);\n        an=cdiv(an,(cmul((cdiv(D,m)+vec2(n/x,0.0)),xi)-xi1));\n        bn=(cmul(m,D)+vec2(n/x,0.0))*psi-vec2(psi1,0.0);\n        bn=cdiv(bn,(cmul(cmul(m,D)+vec2(n/x,0.0),xi)-xi1));\n        \n        //Augment sums for Qsca and g=<cos(theta)>\n        qext=qext+((2.*n+1.)*(an.x+bn.x));\n        qsca=qsca+((2.*n+1.)*(dot(an,an)+dot(bn,bn)));\n        gsca=gsca+(((2.*n+1.)/(n*(n+1.)))* (an.x*bn.x+an.y*bn.y));\n        gsca=gsca+(((n-1.)*(n+1.)/n)*(an1.x*an.x+an1.y*an.y+ bn1.x*bn.x+bn1.y*bn.y));\n        \n        pi=pi1;\n        tau=n*mu*pi-(n+1.)*pi0;\n        s1=s1+fn*(an*pi+bn*tau);\n        s2=s2+fn*(an*tau+bn*pi);\n        \n        psi0=psi1;\n        psi1=psi;\n        chi0=chi1;\n        chi1=chi;\n        xi1=vec2(psi1,-chi1);\n        \n        pi1=((2.*n+1.)*mu*pi-(n+1.)*pi0)/n;\n        pi0=pi;\n        \n        D=cdiv(vec2(1.0,0.0),(cdiv(vec2(n+1.,0.0),y)-D))-cdiv(vec2(n+1.,0.0),y);\n    }\n    \n    gsca=2.0*(gsca)/qsca;\n    qsca=(2.0/(x*x))*qsca;    \n    qext = (4.0 / (x * x)) * s1.x;\n    float qback = pow(c_abs(s1) / x,2.0) / pi;\n    \n    return mat4x2(s1,s2,vec2(qext,qsca),vec2(gsca,qback));\n}\n\n// Criterion, from [2], for when accuracy of upwards recurrence is\n// good enough for Qext and Qsca.\nbool f1_test(float x,vec2 m)\n{\n    float t=m.x;\n    return\n        x>=1.0&&x<10000.0&&\n        t>=1.05&&t<=9.25&&\n        abs(m.y)<-8.0+t*t*(26.22+t*(-0.4474+t*t*t*(0.00204+t*-0.000175)));\n}\n\n// Criterion, from [2], for when accuracy of upwards recurrence is\n// good enough for S1 and S2.\nbool f2_test(float x,vec2 m)\n{\n    float t=m.x;\n    return\n        x>=1.0&&x<10000.0&&\n        t>=1.05&&t<=9.25&&\n        abs(m.y)<3.9+t*(-10.8+t*13.78);\n}\n\n// Approximation of scattering for small x.\n// Recommended for |m|*x<0.1.\n// Meaning of input and output are the same as above.\nmat4x2 mie_rayleigh(float x,vec2 m,float mu)\n{\n    vec2 D=cmul(m,m)+vec2(2.0,0.0)\n        +(vec2(1.0,0.0)-7.0/10.0*cmul(m,m))*x*x\n        -x*x*x*x/1400.0*(cmul(cmul(m,m),(8.0*cmul(m,m)-vec2(385.0,0.0)))+vec2(350.0,0.0))\n        +x*x*x*cmul(vec2(0.0,2.0/3.0),cmul(m,m)-vec2(1.0,0.0))*(1.0-1.0/10.0*x*x);\n    vec2 a1=cmul(cmul(vec2(0.0,2.0/3.0),cmul(m,m)-vec2(1.0,0.0)),\n        cdiv(vec2(1.0-1.0/10.0*x*x,0.0)+x*x*x*x/1400.0*(4.0*cmul(m,m)+vec2(5.0,0.0)),D));\n    vec2 b1=cmul(cmul(vec2(0.0,x*x/45.0),(cmul(m,m)-vec2(1.0,0.0))),cdiv(\n        vec2(1.0,0.0)+x*x/70.0*(2.0*cmul(m,m)-vec2(5.0,0.0)),\n        vec2(1.0,0.0)-x*x/30.0*(2.0*cmul(m,m)-vec2(5.0,0.0))));\n    vec2 a2=cmul(cmul(vec2(0.0,x*x/15.0),(cmul(m,m)-vec2(1.0,0.0))),cdiv(\n        vec2(1.0-x*x/14.0,0.0),\n        2.0*cmul(m,m)+vec2(3.0,0.0)-x*x/14.0*(2.0*cmul(m,m)-vec2(7.0,0.0))));\n    float T=dot(a1,a1)+dot(b1,b1)+5.0/3.0*dot(a2,a2);\n    float qext=6.0*x*(a1+b1+5.0/3.0*a2).x;\n    float qsca=6.0*x*x*x*x*T;\n    float gsca=1.0/T*dot(a1,a2+b1);\n    vec2 s1=3.0/2.0*x*x*x*(a1+(b1+5.0/3.0*a2)*mu);\n    vec2 s2=3.0/2.0*x*x*x*(b1+a1*mu+5.0/3.0*a2*(2.0*mu*mu-1.0));\n    return mat4x2(s1,s2,vec2(qext,qsca),vec2(gsca,0.0));\n}\n\n//==============================================================================\n\nvec3 plot(vec3 bg,vec3 fg,float x,bool border)\n{\n    float a=smoothstep(2.5*fwidth(x),0.0,abs(x));\n    if(border) fg*=a*a;\n    return mix(bg,fg,a);\n}\n\n//==============================================================================\n\n// get ior with respect to wavelength\n// ----------------------------------\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\nfloat calculateIOR(float wavelength, float A, float B) {\n    return A + (B / (wavelength * wavelength));\n}\n\n\nfloat mieplot(\nfloat lambda,// Light wavelength\nfloat theta,// Scattering angle, in radians.\nfloat r // Particle radius, in micrometres.\n)\n{  \n    lambda /= 1000.0; //in micron.\n    \n    float A = 1.3220;\n    float B = 0.00306;\n    \n    \n    float ior = calculateIOR(lambda, A, B);\n    float x=2.0*PI*r/lambda;  // Size parameter.\n    vec2 m=vec2(ior,0.000); // Relative refractive index particle/medium.    \n    float mu=cos(theta); //cos theta.\n    mat4x2 F=mie(x,m,mu);\n    vec2 s1=F[0]; //\n    vec2 s2=F[1]; //\n    float Qext=F[2].x; // Efficiency factor of extinction.\n    float Qsca=F[2].y; // Efficiency factor of scattering.\n    float Gsca=F[3].x;             // Asymmetry parameter.\n    float SSA=Qsca/Qext;           // Single-scattering albedo.\n    // We compute normalization constant for phase function,\n    // so that 1 = 2*π * ∫ p(θ)*sin(θ) dθ on [0;π].\n    // NOTE: if we average phase functions for several particle sizes,\n    // which is a common case, the computation needs to be different,\n    // since the functions are weighted according to Qsca (as well as\n    // probability denity for given size).\n    float W=PI*x*x*Qsca;\n    float p1=dot(s1,s1)/W; // Phase function for light perpendicular to the scattering plane.\n    float p2=dot(s2,s2)/W; // Phase function for light parallel to the scattering plane.\n    float p=0.5*(p1+p2);   // Phase functoin for unpolarized light.\n    return p;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/LUT_RESOLUTION; // <0, 1>\n    \n    if (uv.x > 1.0 || uv.x < 0.0 || uv.y > 1.0 || uv.y < 0.0)\n    { \n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    //max wavelength reached, done!\n    if(iFrame + int(MIN_WAVELENGTH) > int(MAX_WAVELENGTH))\n    {\n       fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n       return;\n    }\n     \n      \n    float rn = n8rand( vec3(fragCoord.xy,iTime)); //random noise\n    float s = (1.-uv.y)+(rn*2.0-1.0)*SIZE_JITTER; //small jitter for particle radius (do I also need to scale it in log?)\n    \n    float w = float(iFrame) + MIN_WAVELENGTH; //sweep through wavelengths\n    \n    // logscale dropsize\n    float lowLog = log(MIN_SIZE) / ln10;\n    float highLog = log(MAX_SIZE) / ln10;\n    float scale = 1.0 / (highLog - lowLog); \n    float size = exp(((s / scale) + lowLog) * ln10); //size in logscale\n    \n    //coord scale\n    float xscale = 1.0 / ((MAX_ANGLE - MIN_ANGLE)*PI/180.0);\n    float theta = uv.x/xscale + (MIN_ANGLE*PI/180.0);\n    \n    vec3 xyz = vec3(0);\n    \n    float flux = max(0.0,mieplot(float(w), theta, size));\n    \n    vec3 XYZ = wavelength2xyz(float(w)) * flux * (MAX_WAVELENGTH - MIN_WAVELENGTH);\n    \n    vec4 previous = texture(iChannel0, fragCoord/iResolution.xy);\n    XYZ = mix(previous.xyz, XYZ, 1.0 / float(iFrame + 1));\n    \n    fragColor = vec4(XYZ, 1.0);\n   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// -------------------------------------------------------------------------\n// USER VARIABLES\n// -------------------------------------------------------------------------\nconst vec2 LUT_RESOLUTION = vec2(512.0,256.0); //resolution of the lookup texture\n\nconst float MIN_SIZE = 0.3; //in micron (top of LUT)\nconst float MAX_SIZE = 1000.0; // in micron (bottom of LUT)\nconst float SIZE_JITTER = 0.02; //overlay grid opacity\n\nconst float MIN_WAVELENGTH = 380.0; //minimum light wavelength\nconst float MAX_WAVELENGTH = 700.0; //maximum light wavelength\n\nconst float MIN_ANGLE = 0.0; //degrees (left of LUT)\nconst float MAX_ANGLE = 180.0; //degrees (right of LUT)\n\nconst float EXPOSURE = exp2(-4.0); //final output exposure\nconst float GRID_OPACITY = 0.2; //overlay grid opacity\n\n// Uncomment to make the LUT square\n//#define SQUARE\n// Uncomment to render with no borders\n//#define FULLSCREEN\n\n// -------------------------------------------------------------------------\n// END OF USER VARIABLES\n// -------------------------------------------------------------------------\n\n// general constants\n#define PI 3.14159265\n#define ln10 2.3025850929 \n\n//random noise distributions by hornet\n//https://www.shadertoy.com/view/4ssXRX\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\nvec2 pcg2d_f(vec2 v)\n{\n    return (1.0/float(0xffffffffu)) * vec2(pcg2d( uvec2(floatBitsToUint(v.x), floatBitsToUint(v.y)) ));\n}\n\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec3 pcg3d_f( vec3 v )\n{\n    return (1.0/float(0xffffffffu)) * vec3(pcg3d( uvec3(floatBitsToUint(v.x),\n                  \t\t\t \t\t\t\t\t\t\tfloatBitsToUint(v.y),\n                  \t\t\t \t\t\t\t\t\t\tfloatBitsToUint(v.z)) ));\n}\n\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n//note: uniform pdf rand [0;1[\nfloat hash13n(vec3 p)\n{\n   \tp  = fract( p * vec3(5.3987, 5.4472, 6.9371) );\n    p += dot( p.yzx, p.xyz + vec3(21.5351, 14.3137, 15.3247) );\n    return fract( (p.x * p.y + p.z) * 95.4307 );\n}\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n    return pcg2d_f(n).x;\n    //return hash12n( n);\n\t//return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat nrand( vec3 n )\n{\n    return pcg3d_f(n).x;\n}\n\n\n// ==========================================\n\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncf( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\n// ==========================================\n\nfloat n1rand( vec3 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07 );\n\treturn nrnd0;\n}\nfloat n2rand( vec3 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07 );\n\tfloat nrnd1 = nrand( n + 0.11 );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\nfloat n3rand( vec3 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07 );\n\tfloat nrnd1 = nrand( n + 0.11 );\n\tfloat nrnd2 = nrand( n + 0.13 );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec3 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07 );\n\tfloat nrnd1 = nrand( n + 0.11 );\t\n\tfloat nrnd2 = nrand( n + 0.13 );\n\tfloat nrnd3 = nrand( n + 0.17 );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\n\nfloat n8rand( vec3 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07 );\n\tfloat nrnd1 = nrand( n + 0.11 );\t\n\tfloat nrnd2 = nrand( n + 0.13 );\n\tfloat nrnd3 = nrand( n + 0.17 );\n    \n    float nrnd4 = nrand( n + 0.19 );\n    float nrnd5 = nrand( n + 0.23 );\n    float nrnd6 = nrand( n + 0.29 );\n    float nrnd7 = nrand( n + 0.31 );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) / 8.0;\n}\n\nfloat n4rand_inv( vec3 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07 );\n\tfloat nrnd1 = nrand( n + 0.11 );\t\n\tfloat nrnd2 = nrand( n + 0.13 );\n\tfloat nrnd3 = nrand( n + 0.17 );\n    float nrnd4 = nrand( n + 0.19 );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n\n// Functions of complex variables.\nvec2 cmul(vec2 l,vec2 r)\n{\n    return vec2(l.x*r.x-l.y*r.y,l.x*r.y+l.y*r.x);\n}\n\nvec2 cdiv(vec2 l,vec2 r)\n{\n    return vec2(l.x*r.x+l.y*r.y,l.y*r.x-l.x*r.y)/(r.x*r.x+r.y*r.y);\n}\n\nvec2 csin(vec2 z)\n{\n    return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y));\n}\n\nvec2 ccos(vec2 z)\n{\n    return vec2(cos(z.x)*cosh(z.y),-sin(z.x)*sinh(z.y));\n}\n\nfloat c_abs(vec2 c)\n{\n\treturn sqrt(c.x*c.x + c.y*c.y);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value range functions, need to rename them\n\n//0-1 value to min-max range\nfloat val_lin_scale(in float val,in float minVal,in float maxVal)\n{\n    float scale = 1.0 / (maxVal - minVal);\n    float valRange = (val / scale) + minVal;\n    return valRange;\n}\n\n//range to linear 0-1 value\nfloat linearScale(float val, float minVal, float maxVal) {\n    // Ensure the input value is within the valid range\n    val = clamp(val, minVal, maxVal);\n    // Normalize the value to the [0, 1] range\n    return (val - minVal) / (maxVal - minVal);\n}\n\n//0-1 value to min-max log range\nfloat val_log_scale(in float val, in float minVal, in float maxVal)\n{\n    float lowLog = log(minVal) / ln10;\n    float highLog = log(maxVal) / ln10;\n    float scale = 1.0 / (highLog - lowLog);\n    float valLogRange = exp(((val / scale) + lowLog) * ln10);\n    return valLogRange;\n}\n\n//range to log 0-1 value\nfloat linearToLogScale(float val, float minVal, float maxVal) {\n    // Ensure the input value is within the valid range\n    val = max(val, minVal);\n\n    // Calculate the logarithmic value\n    float logMin = log(minVal);\n    float logMax = log(maxVal);\n    float logVal = log(val);\n\n    // Normalize the logarithmic value to the [0, 1] range\n    return (logVal - logMin) / (logMax - logMin);\n}\n\n// gamma correct\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\n// from https://www.shadertoy.com/view/DtlfRX\nfloat xFit_1931( float wave ) {\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave ) {\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave ) {\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\nvec3 wavelength2xyz(float w) {\n    return vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) );\n}\n    \nvec3 xyz2rgb(vec3 XYZ) {\n\treturn mat3(2.3706743, -0.5138850, 0.0052982, -0.9000405, 1.4253036, -0.0146949, -0.4706338, 0.0885814, 1.0093968) * XYZ;\n}\n","name":"Common","description":"","type":"common"}]}