{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// @eddbiddulph\n\n#define ONE vec2(1.0, 0.0)\n#define SEARCH_RECT 3\n\nfloat gauss(float x)\n{\n\treturn exp(-x * x);\n}\n\nfloat gaussPrime(float x)\n{\n\treturn gauss(x) * -2.0 * x;\n}\n\nvoid applyOrb(float fj, vec2 stroke_org, float dx, float dy, inout vec3 col, inout vec2 grad)\n{\n\tvec2 org = vec2(sin(fj + iTime * 0.3) * 10.0,\n\t\t\t\t\tcos(fj * 2.0 + iTime) * 8.0) * 1.5;\n\t\n\tvec2 delta = (stroke_org - org) * (0.2 + cos(fj) * 0.1);\n\t\n\tvec2 g = vec2(gauss(delta.x), gauss(delta.y));\n\t\n\tcol += g.x * g.y * mix(vec3(1.0, 0.5, 0.2),\n\t\t\t\t\t\t   vec3(0.3, 0.3, 0.7), cos(fj) * 0.5 + 0.5);\n\t\n\tgrad += vec2(gaussPrime(delta.x) * dx * g.y,\n\t\t\t\t gaussPrime(delta.y) * dy * g.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 t = (uv - vec2(0.5)) * 2.0 * 10.0;\n\tt.x *= iResolution.x / iResolution.y;\n\t\n\tfloat dx = dFdx(t.x), dy = dFdy(t.y);\n\t\n\tfragColor.rgb = vec3(0.4);\n\t\n\tvec2 ti0 = floor(t);\n\tvec2 tf0 = fract(t);\n\t\n\tfor(int y0 = -SEARCH_RECT; y0 <= +SEARCH_RECT; y0 += 1)\n\t\tfor(int x0 = -SEARCH_RECT; x0 <= +SEARCH_RECT; x0 += 1)\n\t\t{\t\t  \n\t\t\tint x = x0, y = y0;\n\t\t\t\n\t\t\tif(mod(ti0.y + float(y), 2.0) < 1.0)\n\t\t\t\tx = -x;\n\n\t\t\tvec2 ti = ti0 + vec2(x, y);\n\t\t\tvec2 tf = tf0 - vec2(x, y);\n\t\t\t\n\t\t\tvec2 stroke_org = ti + vec2(0.5) + vec2(cos(ti.x * 131.0), sin(ti.y * 445.0)) * 0.5;\n\t\t\tvec3 col = vec3(0.0);\n\t\t\tvec2 grad = vec2(0.0);      \n\n\t\t\tapplyOrb(0.0, stroke_org, dx, dy, col, grad);\n\t\t\tapplyOrb(1.0, stroke_org, dx, dy, col, grad);\n\t\t\tapplyOrb(2.0, stroke_org, dx, dy, col, grad);\n\t\t\tapplyOrb(3.0, stroke_org, dx, dy, col, grad);\n\t\t\tapplyOrb(4.0, stroke_org, dx, dy, col, grad);\n\t\t\t\n\t\t\tvec2 dir = normalize(grad + vec2(cos(ti.y), cos(ti.x)) * dx * dy * 0.3);\n\t\t\t\n\t\t\tvec2 dir_perp = vec2(dir.y, -dir.x);\n\t\t\t\n\t\t\tfloat d = dot(dir, tf - vec2(0.5));\n\t\t\tfloat d_perp = dot(dir_perp, tf - vec2(0.5)) + cos(d * 25.0) * 0.4;\n\t\t\t\n         \tfloat m = step(length(max(vec2(0.0), abs(vec2(d, d_perp)) - vec2(0.01, 1.5))),\n\t\t\t\t\t\t   \t0.7 + cos(ti.x * 100.0) * sin(ti.y * 400.0) * 0.4);\n\n\t\t\tfragColor.rgb = mix(fragColor.rgb, col, m);\n\t\t}\n\t\n\tfragColor.rgb = sqrt(fragColor.rgb);\n\tfragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdXGR4","date":"1363435131","viewed":1665,"name":"Dream Paint","username":"fizzer","description":"This shader combines stroke-like shapes positioned in a jittered grid pattern and orientated to align with a procedural gradient. The result feels a little dream-like to me, hence the title.","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["procedural","painterly"],"hasliked":0,"parentid":"","parentname":""}}