{"ver":"0.1","info":{"id":"tdjyWV","date":"1587448711","viewed":183,"name":"sparse noise","username":"jamelouis","description":"Procedural Noise using Sparse Gabor Convolution","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["sparsenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* noise.cpp\n *\n * Example code for the article\n *\n * Procedural Noise using Sparse Gabor Convolution.\n * Ares Lagae, Sylvain Lefebvre, George Drettakis and Philip Dutre.\n * ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2009) 28(3), 2009.\n *\n * If you use this code, please reference the article.\n *\n * This code produces an image 'noise.ppm' of anisotropic noise for the\n * parameters in the 'main' function. This image should be similar to the image\n * 'noise_reference.ppm'.\n *\n * This code allows to generate anisotropic/isotropic and periodic/nonperiodic\n * noise. Please refer to the comments in the code.\n *\n * This code is designed for brevity and clarity. It is significantly slower\n * than the GPU version.\n *\n * Please report bugs to the authors.\n *\n * Revision history\n *   2009-05-06  initial version\n */\n\n/* Copyright (c) 2009 by Ares Lagae, Sylvain Lefebvre,\n * George Drettakis and Philip Dutre\n * \n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nvec2 randState;\n\nfloat hash( const float n ) \n{\n     return fract(sin(n)*43758.54554213);\n}\n\n\nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    return randState.x;\n}\n\nvec2 co;\nfloat rand(){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat uniform_0_1()\n{\n    return rand2D();\n}\n\nuint poisson(float mean)\n{\n    float g = exp(-mean);\n    uint em = 0u;\n    float t = uniform_0_1();\n    while(t > g) {\n        ++em;\n        t *= uniform_0_1();\n    }\n    \n    return em;\n}\n\nconst float pi = 3.1415926f;\nconst float K = 1.0f;\nconst float number_of_impulse_per_kernel = 25.0f;\n\n\nfloat a_parm(in AppState as)\n{\n    return 0.05f + (as.a * 2.0 - 1.0) * 0.01;\n}\n\nfloat F0_parm(in AppState as)\n{\n   return 0.0625f + (as.F0 * 2.0 - 1.0) * 0.02;\n}\n\nfloat w0_parm(in AppState as)\n{\n    return  (as.w0 * 2.0) * pi;\n}\n\nfloat kernel_radius_parm(in AppState as)\n{\n    float a = a_parm(as);\n    return sqrt(-log(0.05f) / pi) / a;\n}\n\nfloat impulse_density_parm(in AppState as)\n{\n    float kernel_radius = kernel_radius_parm(as);\n    return number_of_impulse_per_kernel / (pi * kernel_radius * kernel_radius);\n}\n\nfloat number_of_impulses_per_cell_parm(in AppState as)\n{\n    float kernel_radius = kernel_radius_parm(as);\n    float impulse_density = impulse_density_parm(as);\n    return impulse_density * kernel_radius * kernel_radius;\n}\n\nfloat variance_parm(in AppState as)\n{\n    float a = a_parm(as);\n    float F_0 = F0_parm(as);\n    float impulse_density = impulse_density_parm(as);\n \treturn impulse_density * (1.0f/3.0f)* ((K*K)/(4.0f*a*a))*(1.0+exp(-(2.0f*pi*F_0*F_0) / (a*a)));\n}\n\nfloat gaussian_envelop(float x, float y, in AppState as)\n{\n    float a = a_parm(as);\n    return K * exp(-pi*a*a * (x*x+y*y));\n}\n\nfloat sinusoida_carrier(float x, float y, in AppState as)\n{\n    float F_0 = F0_parm(as);\n    float omega_0 = w0_parm(as);\n    return cos(2.0f * pi * F_0 * ( x*cos(omega_0) + y * sin(omega_0)));\n}\n\nfloat gabor(float x, float y, in AppState as)\n{\n    return gaussian_envelop(x, y, as) * sinusoida_carrier(x,y, as);\n}\n\nfloat cell(int i, int j, float x, float y, in AppState as)\n{\n    randState = vec2(i,j) / iResolution.xy;\n    float kernel_radius = kernel_radius_parm(as);\n    float number_of_impulses_per_cell = number_of_impulses_per_cell_parm(as);\n    uint number_of_impulses = poisson(number_of_impulses_per_cell);\n    float noise = 0.0f;\n    for(uint k=0u;k<number_of_impulses;++k){\n        float x_i = uniform_0_1();\n        float y_i = uniform_0_1();\n        float w_i = 2.0f*(uniform_0_1() - 0.5f);\n        float x_i_x = x - x_i;\n        float y_i_y = y - y_i;\n        if(((x_i_x * x_i_x)+(y_i_y*y_i_y))<1.0f) {\n            noise += w_i * gabor(x_i_x * kernel_radius, y_i_y * kernel_radius, as);\n            //float r = sqrt((x_i_x * x_i_x)+(y_i_y*y_i_y));\n            //noise += w_i * (0.5f + 0.5f*cos(pi*r));\n        }\n    }\n     return noise;\n }\n\nfloat noise2d(float x, float y, in AppState as)\n{\n    x /= kernel_radius_parm(as);\n    y /= kernel_radius_parm(as);\n    float int_x = floor(x), int_y = floor(y);\n    float fract_x = x - int_x, fract_y = y - int_y;\n    int i = int(int_x), j = int(int_y);\n    float noise = 0.0f;\n    for(int di=-1; di <= 1; ++di){\n        for(int dj=-1; dj<=1; ++dj) {\n            noise += cell(i + di, j + dj, fract_x - float(di), fract_y - float(dj), as);\n        }\n    }\n    return 0.5f + 0.5f * noise / (4.0 * variance_parm(as));\n}\n\nvoid drawChar(inout vec3 col, vec2 p, float c, in AppState as)\n{\n    vec2 scale = vec2(8., 16.);\n    p /= scale;\n    p.x = (p.x - .5) * .45 + .5;\n    float sdf = TextSDF(iChannel1, p, c);\n    if (c != 0.)\n    {\n        col = mix(vec3(1.0, 0.2, 0.36), col, smoothstep(-0.05, +0.05, sdf));\n    }\n}\n\nvoid drawSlider(inout vec3 col, vec2 p, in AppState as)\n{\n    float c1 = smoothstep(-0.05, +0.05, -Capsule((p-vec2(100.0, 48.)).yx, 1.5, 20.));\n    c1 = min(c1, Circle((p-vec2(80.0, 48.) - vec2(40. * as.a, 0.)), 2.5));\n    col = mix(col, vec3(1.0), c1);\n\n    c1 = smoothstep(-0.05, +0.05, -Capsule((p-vec2(100.0, 40.)).yx, 1.5, 20.));\n    c1 = min(c1, Circle((p-vec2(80.0, 40.) - vec2(40. * as.F0, 0.)), 2.5));\n    col = mix(col, vec3(1.0), c1);\n\n    c1 = smoothstep(-0.05, +0.05, -Capsule((p-vec2(100.0, 32.)).yx, 1.5, 20.));\n    c1 = min(c1, Circle((p-vec2(80.0, 32.) - vec2(40. * as.w0, 0.)), 2.5));\n    col = mix(col, vec3(1.0), c1);\n        \n    p -= vec2(124.0, 28.);\n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p/scale);\n\n    uint v = 0u;\n    v = t.y == 2. ? (t.x < 4. ? 97u : 0u): v;\n    v = t.y == 1. ? (t.x < 4. ? 12358u : 0u) : v;\n    v = t.y == 0. ? (t.x < 4. ? 12407u : 0u) : v;\n    v = t.x >= 0. && t.x < 2. ? v : 0u;\n\n    float c = float((v >> uint(8. * t.x)) & 255u);\n    p = (p-t*scale)/scale;\n    p.x = (p.x - .5) * .45 + .5;\n    float sdf = TextSDF(iChannel1, p, c);\n    if (c != 0.)\n    {\n        col = mix(vec3(0.8), col, smoothstep(-0.05, +0.05, sdf));\n    }\n}\n\nvoid drawRadio(inout vec3 col, vec2 p, in AppState as)\n{\n    col = mix(col, vec3(1.0), max(0.0,-Circle(p - vec2(80.0, 80.0), 4.0)));\n    col = mix(col, vec3(1.0), max(0.0,-Circle(p - vec2(80.0, 72.0), 4.0)));\n    col = mix(col, vec3(1.0), max(0.0,-Circle(p - vec2(80.0, 64.0), 4.0)));\n    col = mix(col, vec3(1.0), max(0.0,-Circle(p - vec2(80.0, 56.0), 4.0)));\n\n    col = mix(col, vec3(0.3), max(0.0,-Circle(p - vec2(80.0, 80.0) + vec2(0.0, as.t * 8.), 3.0))); \n\n    p -= vec2(85.0, 52.0);\n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p/scale);\n\n    uint v = 0u;\n    v = t.y == 3. ? (t.x < 4. ? 1937072455u : (t.x < 8. ? 1851877747u : 0u)) : v;\n    v = t.y == 2. ? (t.x < 4. ? 1970170195u : (t.x < 8. ? 1684631411u : 97u)) : v;\n    v = t.y == 1. ? (t.x < 4. ? 1868718407u : (t.x < 8. ? 114u : 0u)) : v;\n    v = t.y == 0. ? (t.x < 4. ? 1918988371u : (t.x < 8. ? 25971u : 0u)) : v;\n    v = t.x >= 0. && t.x < 12. ? v : 0u;\n\n    float c = float((v >> uint(8. * t.x)) & 255u);\n    p = (p-t*scale)/scale;\n    p.x = (p.x - .5) * .45 + .5;\n    float sdf = TextSDF(iChannel1, p, c);\n    if (c != 0.)\n    {\n        col = mix(vec3(0.8), col, smoothstep(-0.05, +0.05, sdf));\n    }\n}\n\nvoid drawAxis(inout vec3 col, vec2 p, in AppState as)\n{\n    float r = Arrow(p + vec2(iResolution.x / iResolution.y * 90.0,0.), pi/2.0, iResolution.x / iResolution.y * 90.0, 0.6);\n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-0.05, +0.05, r));\n    \n    r = Arrow(p + vec2(0.0, 90.0), pi, 90.0, 0.6);\n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-0.05, +0.05, r));\n    \n    drawChar(col, p - vec2(iResolution.x / iResolution.y * 86.0, -14.0), 120.0, as);\n    drawChar(col, p - vec2(-12.0, 80.0), 121.0, as);\n}\n\n\n\n\nvoid drawHormonic(inout vec3 col, vec2 p, in AppState as)\n{    \n    vec2 q = p;\n    Rotate(p, w0_parm(as));\n    \n    float r = Rectangle(p, vec2(60.0,0.6));\n    col = mix(vec3(0.90, 0.9, 0.56), col, smoothstep(-.05, +.05, r));\n    \n    p.y += cos(p.x / ( 2.0 * pi / F0_parm(as)) * 25.0 ) * 8.;\n    r = Rectangle(p, vec2(60.0, 0.6));\n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-.05, +.05, r));\n    \n    p = q;\n    Rotate(p, w0_parm(as));\n    p.y -= 12.0;\n    \n    r = 1.0 / (3.0*F0_parm(as));\n    float   r3 = Arrow(p, pi/2.0 , r, 1.0);\n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-0.05, +0.05, r3));\n    float   r4 = Arrow(p, pi+pi/2.0, r, 1.0);\n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-0.05, +0.05, r4));\n    \n    \n    drawChar(col, p - vec2(-26.0,1.0), 49.0, as);\n    drawChar(col, p - vec2(-18.0,1.0), 47.0, as);\n    drawChar(col, p - vec2(-10.0,1.0), 70.0, as);\n    drawChar(col, p - vec2(-2.0,1.0), 48.0, as);\n    \n    p = q;\n    r *= 6.0;\n    float theta = atan(-p.y, -p.x) + pi;\n    if(theta > w0_parm(as)) q = vec2(10.0);\n    float r1 = Circle(q, r);\n    float r2 = Circle(q, r+2.);\n    \n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-.05, +.05, r2 * r1));\n    drawChar(col, p - vec2(r+1.,1.0), 119.0, as);\n    drawChar(col, p - vec2(r+9.,0.0), 48.0, as);\n}\n\nvoid drawGaussian(inout vec3 col, vec2 p, in AppState as)\n{\n    float r = 1.0 / a_parm(as);\n    float r1 = Circle(p, r);\n    float r2 = Circle(p, r+1.);\n    \n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-.05, +.05, r2 * r1));\n    \n    float theta = atan(p.x, p.y);\n\tRepeat(theta, 0.4);\n    vec2 q = p;\n    if(theta > 0.0) q = vec2(10.0);\n    r = 1.5 * r;\n    r1 = Circle(q, r);\n    r2 = Circle(q, r+1.);\n    \n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-.05, +.05, r2 * r1));\n    \n    r = 1.0 / a_parm(as);\n\tfloat   r3 = Arrow(p, 3.0*pi/4.0 , r/2.0-2.0, 1.0);\n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-0.05, +0.05, r3));\n    float   r4 = Arrow(p, pi+3.0*pi/4.0, r/2.0-2.0, 1.0);\n    col = mix(vec3(0.90, 0.7, 0.36), col, smoothstep(-0.05, +0.05, r4));\n    \n    drawChar(col, p - vec2(-26.0,1.0)*r*0.03, 49.0, as);\n    drawChar(col, p - vec2(-18.0,1.0)*r*0.03, 47.0, as);\n    drawChar(col, p - vec2(-10.0,1.0)*r*0.03, 97.0, as);\n}\n\n\nvoid drawGUI(inout vec3 col, vec2 p, in AppState as)\n{\n   float r = Rectangle(p - vec2(106., 56.), vec2(36.0, 30.0));\n    col = mix(vec3(0.3), col, smoothstep(-0.05, +0.05, r));\n                       \n \n   if(as.t != 3.0)\n       drawAxis(col, p, as);\n   if(as.t == 1.0)\n       drawHormonic(col, p, as);\n   if(as.t == 0.0)\n       drawGaussian(col, p, as);\n    \n       \n   drawRadio(col, p, as);\n   drawSlider(col, p, as);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    co = fragCoord.xy;\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv *= 64.0f;\n    vec3 col = vec3(0.0);\n   \n    AppState as;\n    LoadState(iChannel0, as);\n    \n    if(as.t == 0.0)\n    \tcol = vec3(gaussian_envelop(uv.x, uv.y, as));\n   \telse if(as.t == 1.0)\n    \tcol = vec3(sinusoida_carrier(uv.x, uv.y, as));\n    else if(as.t == 2.0)\n\t\tcol = vec3(0.5*(gabor(uv.x, uv.y, as)+1.0));\n    else\n        col = vec3(noise2d(uv.x, uv.y, as));\n\n    vec2 p = fragCoord / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    p *= 100.0;\n    \n    drawGUI(col, p, as);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > 8.0 || fragCoord.y > 8.0) discard;\n    \n    AppState as;\n    if(iFrame == 0)\n    {\n        as.t = 3.0;\n        as.a = 0.5;\n        as.F0 = 0.5;\n        as.w0 = 3.1415/4.0;\n    }\n    else\n    {\n    \tLoadState(iChannel0, as);\n    }\n    \n    \n    vec4 p = iMouse / iResolution.xyxy * 2.0 - 1.0;\n    p.xz *= iResolution.x / iResolution.y;\n    p *= 100.0;\n    \n    vec4 sliderM = p - vec2(80.0, 56.0).xyxy;\n    if(sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -4. && sliderM.w < 4.){\n        as.t = 3.0;\n    }else if(sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= 4. && sliderM.w < 12.){\n        as.t = 2.0;\n    }else if(sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= 12. && sliderM.w < 20.){\n        as.t = 1.0;\n    }else if(sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= 20. && sliderM.w < 28.){\n        as.t = 0.0;\n    }else if(sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -12. && sliderM.w < -4.){\n        as.a = saturate(sliderM.x / 40.);\n    }else if(sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -12.){\n        as.F0 = saturate(sliderM.x / 40.);\n    }else if(sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -32. && sliderM.w < -20.){\n        as.w0 = saturate(sliderM.x / 40.);\n    }\n    \n    SaveState(fragColor, as); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ui \n/// https://www.shadertoy.com/view/4sSfzK\nstruct AppState\n{\n    float t;\n    float a;\n    float F0;\n    float w0;\n};\n    \nvec4 LoadValue(sampler2D tex, ivec2 uv)\n{\n    return texelFetch(tex, uv, 0);\n}\n\nvoid SaveValue(inout vec4 fragColor, in vec2 fragCoord, in vec4 color)\n{\n    fragColor = fragCoord.x == 0.0f && fragCoord.y == 0.0f ? color : vec4(0.0f);\n}\n\nvoid LoadState(sampler2D tex, out AppState as)\n{\n    vec4 t;\n    t = LoadValue(tex, ivec2(0,0));\n    \n    as.t = t.x;\n    as.a = t.y;\n    as.F0 = t.z;\n    as.w0 = t.w;\n}\n\nvoid SaveState(inout vec4 fragColor, in AppState as)\n{\n    vec4 t;\n    t.x = as.t;\n    t.y = as.a;\n    t.z = as.F0;\n    t.w = as.w0;\n    \n    SaveValue(fragColor, vec2(0,0), t);\n}\n\n// translation function\nvoid Rotate(inout vec2 p, float a)\n{\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// sdf function\nfloat Circle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Capsule(vec2 p, float r, float c)\n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat Rectangle(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat Arrow(vec2 p, float a, float l, float w)\n{\n\tRotate(p, a);\n\tp.y += l;\n\n\tfloat body = Capsule(p, w, l);\n\tp.y -= w;\n\n\tfloat tip = p.y + l;\n\n\tp.y += l + w;\n\tRotate(p, +2.);\n\ttip = max(tip, p.y - 2. * w);\n\tRotate(p, -4.);\n\ttip = max(tip, p.y - 2. * w);\n\n\treturn min(body, tip);\n}\n\nfloat TextSDF(sampler2D tex, vec2 p, float glyph)\n{\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n\treturn 2. * (texture(tex, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid Repeat(inout float p, float w)\n{\n\tp = mod(p, w) - 0.5f * w;\n}","name":"Common","description":"","type":"common"}]}