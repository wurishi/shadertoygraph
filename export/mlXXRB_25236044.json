{"ver":"0.1","info":{"id":"mlXXRB","date":"1674954057","viewed":60,"name":"Tree and Stone","username":"ianertson","description":"A tree and a stone","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","tree","happy","scene","summer","stone","warm","joy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define UP vec3(0, 1, 0)\n#define FORWARD vec3(0, 0, 1)\n#define LEFT vec3(1, 0, 0)\n#define ZERO min(0, int(iTime))\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 64\n\n\n#define ENTITY_NONE 0\n#define ENTITY_GROUND 1\n#define ENTITY_BOX 2\n#define ENTITY_ROCK 3\n#define ENTITY_TREE_BARK 4\n#define ENTITY_TREE_LEAFS 5\n\nvec3 noise(vec3 p) { return texture(iChannel3, p).xyz; }\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float depth;\n    int entity;\n    int skip;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.);\n    data.normal = vec3(0.);\n    data.uv = vec2(0.);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.entity = 0;\n    data.skip = 0;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat planeSDF(vec3 p, vec3 n) {\n    return dot(p, n)+0.5;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\nfloat rockSDF(vec3 p) {\n\n\n    vec3 n = vec3(0.0);\n    float freq = 0.04;\n    n += noise(p*freq)*1.1; freq *= 1.5;\n    n += noise((p*(n*2.))*freq); freq *= 1.5;\n    n += noise((p+(n*0.2))*freq); freq *= 1.5;\n    n += noise((p*(n*0.2))*freq); freq *= 1.5;\n\n    n /= 3.0;\n    \n   // n = (n+n2+n3)/3.0;\n    \n    n -= 0.5;\n    \n    n *= 0.5;\n    p += n;\n    \n    float mag = max(abs(n.x), max(abs(n.y), abs(n.z)));\n    \n    float s = sphereSDF(p, 0.5);\n    return s / (1.0+(mag*0.5));\n}\n\nfloat treeSDF(vec3 p, inout int entity, in int skip) {\n    entity = ENTITY_TREE_BARK;\n    \n    vec3 n = vec3(0.);\n    float freq = 0.009;\n    \n    n += noise(p*freq); freq *= 2.0;\n    n += noise(p*freq); freq *= 2.0;\n    n += noise(p*freq); freq *= 2.0;\n    \n    n /= 3.0;\n    \n    n -= 0.5;\n    \n    p += n;\n    \n    n = abs(n);\n    float mag = max(n.x, max(n.y, n.z));\n    \n    float bark = cylinderSDF(p, vec3(0.0), vec3(0.0, 2.0, 0.0), 0.25);\n    bark /= (1.0+mag);\n    \n    n = vec3(0.);\n    freq = 0.06;\n    \n    n += noise(p*freq); freq *= 1.0;\n    n += noise((p+n)*freq); freq *= 1.5;\n    n += noise(p*freq); freq *= 1.5;\n   \n    n /= 3.0;\n    n -= 0.5;\n    p += n*0.8;\n    float leafs = sphereSDF(p + vec3(0.0, -2.0, 0.0), 1.);\n    n = abs(n);\n    mag = max(n.x, max(n.y, n.z));\n    leafs /= (1.0 + mag);\n    \n    float minDist = FAR;\n    \n    if (bark < minDist && skip != ENTITY_TREE_BARK) { minDist = bark; entity = ENTITY_TREE_BARK; }\n    if (leafs < minDist && skip != ENTITY_TREE_LEAFS) { minDist = leafs; entity = ENTITY_TREE_LEAFS; }\n    \n   // float dist = min(bark, leafs);\n    \n    return minDist;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    int entity = 0;\n    \n    data.entity = ENTITY_GROUND;\n    \n    float ground = p.y+0.5;\n    \n    float box = FAR;\n    \n    //vec3 bmap = boxMap(p/FAR);\n \n    box = boxSDF((p + vec3(0.0, -(0.5 + 0.25), 0.0)), vec3(0.5));\n    box -= 0.25;\n    \n    int treepart = 0;\n    float tree = treeSDF(p + vec3(1.0, 0.5, -1.0), treepart, data.skip);\n    \n    float rock = rockSDF(p);\n    \n    float minDist = FAR;\n\n    if (data.skip != ENTITY_GROUND && ground < minDist) { minDist = ground; data.entity = ENTITY_GROUND; }\n   // if (data.skip != ENTITY_FLOWER && flower < minDist) {  minDist = flower; data.entity = ENTITY_FLOWER; }\n    if (data.skip != ENTITY_ROCK  && rock < minDist) { minDist = rock; data.entity = ENTITY_ROCK; }\n    if (data.skip != treepart && tree < minDist) { minDist = tree; data.entity = treepart; }\n    \n    return minDist;\n}\n\nvec3 getNormal(inout Data data, vec3 p, float s) {\n   vec2 e = vec2(s, 0.0);\n   return normalize(getDist(data, p) - vec3(\n       getDist(data, p-e.xyy),\n       getDist(data, p-e.yxy),\n       getDist(data, p-e.yyx)\n   ));\n}\n\nvec2 getUv(inout Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xz, abs(dot(n, UP)));\n    uv = mix(uv, p.xy, abs(dot(n, FORWARD)));\n    uv = mix(uv, p.zy, abs(dot(n, LEFT)));\n    return uv;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR || abs(next) >= FAR) break;\n    }\n    \n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    \n    float s = 0.09;\n    data.normal = getNormal(data, p, s);\n    data.uv = getUv(data);\n    data.dist = abs(dist);\n    data.depth = data.dist / FAR;\n    \n    return true;\n}\n\nvec3 grass(vec2 uv) {\n    return texture(iChannel0, uv).r * vec3(0.5, 0.8, 0.3);\n}\n\nvec3 stone(vec2 uv) {\n    float n = texture(iChannel0, uv).r;\n\n    return vec3(vec3(n)) * mix(vec3(1.0), vec3(210.,180.,140.)/255.0, 0.9);\n}\n\nvec3 bark(vec2 uv) {\n    vec3 albedo = texture(iChannel1, uv).rgb;\n    return albedo;\n}\n\nvec3 leafs(vec2 uv) {\n    vec3 color1 = vec3(0.5, 0.8, 0.3);\n    vec3 color2 = vec3(0.5, 0.6, 0.4);\n    float n = texture(iChannel0, uv).r;\n    float pwr = texture(iChannel0, 0.5*(uv+n)*(0.5)).r;\n    \n    vec3 color = mix(color1, color2, n);\n    \n    return color*pwr;\n}\n\nvec3 getDiffuse(in Data data) {\n    switch (data.entity) {\n        case ENTITY_GROUND: return grass(data.uv*0.5); break;\n        case ENTITY_BOX: return texture(iChannel1, data.uv).rgb; break;\n        case ENTITY_ROCK: return stone(data.uv); break;\n        case ENTITY_TREE_BARK: return bark(data.uv); break;\n        case ENTITY_TREE_LEAFS: return leafs(data.uv); break;\n    }\n    \n    return vec3(0.);\n}\n\n\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nvec3 render(vec3 ro, vec3 rd, inout Data data) {\n    vec3 col = vec3(0.);\n    vec3 blue = vec3(0.2, 0.5, 0.8);\n   \n    Light light = Light(vec3(2.0, 9.0, 0.0), vec3(0.9, 0.7, 0.5), 16.0);\n\n\n    \n    if (march(ro, rd, data)) {\n        vec3 normal =  data.normal;\n        \n        if (data.entity == ENTITY_ROCK || data.entity == ENTITY_TREE_BARK) {\n            vec3 n = vec3(0.0);\n            float freq = 0.5;\n            n += noise(data.point*freq); freq *= 2.0;\n            n += noise(data.point*freq); freq *= 2.0;\n            n += noise(data.point*freq); freq *= 2.0;\n            n /= 3.0;\n            \n            n -= 0.5;\n            \n            normal += n;\n        }\n        \n        vec3 L = normalize(light.pos - data.point);\n        vec3 refdir = normalize(reflect(rd, normal));\n        float LdotR = max(0.0, dot(refdir, L));\n        \n \n        float lightDist = distance(data.point, light.pos);\n        vec3 diffuse = getDiffuse(data) / M_PI;\n\n        \n        float NdotL = max(0.05, dot(normal, L));\n        \n        float att = NdotL * (\n            (pow(light.strength, 2.0) / max(0.001, pow(lightDist, 2.0)))\n        );\n        \n        diffuse.rgb *= light.color * att;\n        col += diffuse + pow(LdotR, 32.0);\n        \n        Data ocData;\n        dataInit(ocData);\n        \n\n        ocData.skip = data.entity;\n\n        if (march(data.point, L, ocData)) {\n            col.rgb /= TAU;\n        }\n       \n        \n\n    } else {\n        col.rgb += blue / M_PI;\n    }\n    \n    float fog = clamp(pow(data.depth, 2.0)*4.0, 0.0, 1.0);\n    col.rgb += \n       (mix(vec3(1.0), blue, clamp(3.0*max(0.0, dot(rd, vec3(0, 1, 0))), 0.0, 1.0)) * fog);\n    \n    col. rgb *= M_PI;\n    return col;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -4.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    \n    if (iMouse.z > 0.01 && iFrame > 16) {\n        ro.yz *= rot(m.y*TAU);\n        rd.yz *= rot(m.y*TAU);\n        \n        ro.xz *= rot(m.x*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        //ro.y += 2.0;\n        float moveT = T*0.5;\n        ro.x = cos(moveT)*M_PI*1.5;\n        ro.z = sin(moveT)*M_PI*1.5;\n        \n        if (iFrame > 16) {\n            ro.y += (0.5+(0.5*cos(moveT-2.)))*TAU;\n        }\n        //ro.y\n       rd = look(uv, vec3(0.0), ro);\n    }\n    \n    \n    rd = normalize(rd);\n    \n    ro.y = max(0.0, ro.y);\n    \n    Data data;\n    dataInit(data);\n\n    col += render(ro, rd, data);\n    \n\n\n    \n    col.rgb /= vec3(0.7389) + col.rgb;\n    col.rgb = pow(col.rgb, vec3(1.0 / 1.5));\n    O = vec4(col.rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}