{"ver":"0.1","info":{"id":"clKyWc","date":"1700738619","viewed":65,"name":"Cosmic rainbow disc","username":"tassel","description":"Cosmic rainbow disc","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["animated","rainbow","cosmic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MdtGz2","filepath":"https://soundcloud.com/nrwrecords/wice-star-fighter?si=fe8ce135bcbf44cba0d3195b0ba28422","previewfilepath":"https://soundcloud.com/nrwrecords/wice-star-fighter?si=fe8ce135bcbf44cba0d3195b0ba28422","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCosmic Rainbow shader - Playing around :)\nIt all started with a shader by @XorDev that you can find here: https://www.shadertoy.com/view/msjXRK\n\nMusic: Wice - Star Fighter by NewRetroWave Records / https://soundcloud.com/nrwrecords\n\nNote: Added audio spectrum effect\n*/\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0.0);\n\n    vec2 r = iResolution.xy;\n    vec2 p = (I - r * 0.6) * mat2(1, -1, 2, 2);\n\n    // Extract audio spectrum data from iChannel0\n    vec3 audioData = texture(iChannel0, vec2(iTime * 0.1, 0.5)).rgb;\n\n    for (float i = 0., a; i++ < 3e1;)\n    {\n        // Introduce a time variable for animation\n        float time = iTime * 0.5;\n\n        // Modify positions or colors over time\n        float radius = 0.2 + 0.1 * sin(time + i * 0.5);\n        vec2 offset = vec2(cos(time * 0.5), sin(time * 0.3)) * 0.2;\n\n        // Update position based on time and rotate in all axes\n        vec3 rotatedI = vec3(p / (r + r - p).y - offset, 0.0);\n        rotatedI.xy *= mat2(cos(time), -sin(time), sin(time), cos(time));\n        rotatedI.yz *= mat2(cos(time * 0.5), -sin(time * 0.5), sin(time * 0.5), cos(time * 0.5));\n        rotatedI.xz *= mat2(cos(time * 0.3), -sin(time * 0.3), sin(time * 0.3), cos(time * 0.3));\n\n        float distance = abs(length(rotatedI.xy) * 8e1 - i) + 4e1 / r.y;\n\n        // Use the audio spectrum to modulate the radius\n        radius *= audioData.y + 1.0;\n\n        // Increase the impact of audio amplitude on radius\n        radius *= audioData.r * 2.0;\n\n        // Update color based on time and create a rainbow gradient\n        float angle = atan(rotatedI.y, rotatedI.x) * ceil(i * 0.1) + i * i;\n        float colorFactor = clamp(cos(angle), 0.6, 10.0) * (cos(angle - i + 6.0) + 0.0);\n\n        // Rainbow gradient\n        vec3 rainbowColor = vec3(\n            sin(12.0 * colorFactor + 10.0),\n            sin(12.0 * colorFactor + 5.0),\n            sin(12.0 * colorFactor + 1.5)\n        ) * 0.2 + 0.3;\n\n        // Accumulate the color for each iteration\n        O += vec4(radius / distance * rainbowColor, 1.0);\n    }\n}\n\n\n/* Old shader without Music\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0.0);\n\n    vec2 r = iResolution.xy;\n    vec2 p = (I - r * 0.5) * mat2(1, -1, 2, 2);\n\n    for (float i = 0.0, a; i++ < 3e1;)\n    {\n        float time = iTime * 0.5;\n\n        // Modify positions or colors over time\n        float radius = 0.2 + 0.1 * sin(time + i * 0.5);\n        vec2 offset = vec2(cos(time * 0.5), sin(time * 0.3)) * 0.2;\n\n        // Update position based on time and rotate in all axes\n        vec3 rotatedI = vec3(p / (r + r - p).y - offset, 0.0);\n        rotatedI.xy *= mat2(cos(time), -sin(time), sin(time), cos(time));\n        rotatedI.yz *= mat2(cos(time * 0.5), -sin(time * 0.5), sin(time * 0.5), cos(time * 0.5));\n        rotatedI.xz *= mat2(cos(time * 0.3), -sin(time * 0.3), sin(time * 0.3), cos(time * 0.3));\n\n        float distance = abs(length(rotatedI.xy) * 8e1 - i) + 4e1 / r.y;\n\n        // Update color based on time and create a rainbow gradient\n        float angle = atan(rotatedI.y, rotatedI.x) * ceil(i * 0.1) + i * i;\n        float colorFactor = clamp(cos(angle), 10.0, 0.6) * (cos(angle - i + 6.0) + 0.0);\n\n        // Rainbow gradient\n        vec3 rainbowColor = vec3(\n            sin(12.0 * colorFactor + 10.0),\n            sin(12.0 * colorFactor + 5.0),\n            sin(12.0 * colorFactor + 1.5)\n        ) * 0.2 + 0.3;\n\n        // Accumulate the color for each iteration\n        O += vec4(radius / distance * rainbowColor, 1.0);\n    }\n}\n\n\n*/","name":"Image","description":"","type":"image"}]}