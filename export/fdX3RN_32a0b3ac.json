{"ver":"0.1","info":{"id":"fdX3RN","date":"1615556270","viewed":263,"name":"glowglobe","username":"ear7h","description":"A globe using heavily simplified natural earth coastal shapes\n\ncode to generate the points: https://github.com/ear7h/wkt2glsl","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["lines","globe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA sigmoid\n//#define AA heaviside\n#define PI 3.14159\n\nfloat heaviside(float x) {\n    if (x < 0.) {\n        return 0.;\n    }\n    \n    return 1.;\n}\n\n// is this AI?\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(2000. * -x));\n}\n\n\nfloat line(vec2 p, vec2 a, vec2 b, float w) {\n    vec2 ab = normalize(b - a);\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    float d0 = dot(ap, ab);// / length(ab);\n    float d1 = dot(bp, -ab);// / length(ab);\n    \n    \n\n    if (d0 < 0. || d1 < 0.) {\n        return 0.;\n    }\n    \n    return AA(w - distance(ab * d0, ap));\n}\n\n\n#define NPOINTS 95\n\nvec2 points[NPOINTS] = vec2[NPOINTS](\nvec2(-1.350071, 0.151329),\nvec2(-1.080026, 0.187023),\nvec2(-0.606153, -0.128163),\nvec2(-1.308068, -0.912157),\nvec2(0., 0.),\nvec2(-1.359290, 0.126079),\nvec2(-1.418080, -0.107108),\nvec2(-1.224600, -0.344815),\nvec2(-1.308068, -0.912157),\nvec2(0., 0.),\nvec2(-1.359290, 0.126079),\nvec2(-1.957946, 0.431767),\nvec2(-2.340104, 1.014439),\nvec2(-2.876051, 0.949532),\nvec2(-2.740894, 1.028329),\nvec2(-2.934083, 1.146158),\nvec2(-1.418611, 1.207105),\nvec2(-1.610887, 0.996358),\nvec2(-1.394743, 0.893755),\nvec2(-1.288749, 1.089850),\nvec2(-0.971859, 0.910131),\nvec2(-1.241009, 0.817193),\nvec2(-1.043757, 0.801462),\nvec2(-1.332559, 0.683296),\nvec2(-1.402914, 0.439930),\nvec2(-1.695413, 0.485725),\nvec2(-1.440703, 0.166961),\nvec2(0., 0.),\nvec2(-0.283736, 0.333301),\nvec2(-0.103498, 0.624130),\nvec2(0.589457, 0.540484),\nvec2(0.456766, 0.688770),\nvec2(0.725256, 0.724934),\nvec2(0.536667, 0.813028),\nvec2(0.392525, 0.635474),\nvec2(0.229364, 0.798256),\nvec2(0.281015, 0.662979),\nvec2(0.155141, 0.774339),\nvec2(-0.155314, 0.643482),\nvec2(0.149111, 0.996758),\nvec2(0.508199, 1.047687),\nvec2(0.417193, 1.152038),\nvec2(0.277155, 0.979205),\nvec2(0.098887, 1.022556),\nvec2(0.334824, 1.218544),\nvec2(0.645994, 1.114390),\nvec2(1.220683, 1.274788),\nvec2(1.264020, 1.154931),\nvec2(1.821279, 1.356085),\nvec2(3.117158, 1.211259),\nvec2(-3.141593, 1.203643),\nvec2(0., 0.),\nvec2(3.141593, 1.134110),\nvec2(2.736498, 0.890311),\nvec2(2.870605, 1.091714),\nvec2(2.358397, 0.955212),\nvec2(2.467533, 0.911739),\nvec2(2.253070, 0.612305),\nvec2(2.060235, 0.684244),\nvec2(2.123794, 0.492628),\nvec2(1.847984, 0.344738),\nvec2(1.835358, 0.150094),\nvec2(1.747036, 0.233994),\nvec2(1.819136, 0.022568),\nvec2(1.595529, 0.397325),\nvec2(1.353327, 0.139025),\nvec2(1.158424, 0.443752),\nvec2(0.837313, 0.523177),\nvec2(1.043814, 0.389392),\nvec2(0.758921, 0.220554),\nvec2(0.565892, 0.520999),\nvec2(0.890908, 0.185719),\nvec2(0.449957, -0.592446),\nvec2(0.265473, -0.472826),\nvec2(0.164137, 0.065180),\nvec2(-0.157163, 0.084342),\nvec2(-0.283736, 0.333301),\nvec2(0., 0.),\nvec2(-3.141593, -1.478527),\nvec2(-1.203159, -1.274254),\nvec2(-1.008995, -1.104281),\nvec2(-1.146072, -1.186019),\nvec2(-1.061638, -1.286225),\nvec2(-1.361772, -1.381984),\nvec2(-1.016174, -1.452436),\nvec2(-0.119873, -1.238002),\nvec2(2.357429, -1.139850),\nvec2(2.988122, -1.251340),\nvec2(2.788830, -1.412764),\nvec2(3.141593, -1.478527),\nvec2(0., 0.),\nvec2(-3.141593, 1.203643),\nvec2(-2.965307, 1.151520),\nvec2(-3.141593, 1.134110),\nvec2(0., 0.)\n\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec2 cur = points[0];\n    float sum = 0.0;\n    float r = 0.3;\n\n    \n    for (int i = 1; i < NPOINTS; i++) {\n        if (cur == vec2(0., 0.) || points[i] == vec2(0., 0.)) {\n            cur = points[i];\n            continue;\n        }\n            \n    \n        vec2 c1 = vec2(r * cos(-cur.x + iTime)*cos(cur.y), r * sin(cur.y));\n        cur = points[i];\n        vec2 c2 = vec2(r * cos(-cur.x + iTime)*cos(cur.y), r * sin(cur.y));\n        \n        sum += line(uv,c1,c2,0.5/iResolution.y);\n    }\n    \n    sum = min(sum, 1.);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col *= sum;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}