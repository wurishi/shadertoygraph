{"ver":"0.1","info":{"id":"WdXXDX","date":"1552298356","viewed":87,"name":"test more sphere","username":"twopointfive","description":"test sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["testsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define RAYCASTSTEPS 40\n\n#define EXPOSURE 0.9\n#define EPSILON 0.0001\n#define MAXDISTANCE 400.\n#define GRIDSIZE 8.\n#define GRIDSIZESMALL 5.\n#define MAXHEIGHT 10.\n#define SPEED 0.5\n\n#define time iTime\n\n\nconst mat2 mr = mat2 (0.84147,  0.54030,\n\t\t\t\t\t  0.54030, -0.84147 );\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\nvec2 hash2( float n ) {\n\treturn fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n}\nvec2 hash2( vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(2.1459123,3.3490423));\n}\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nvec3 hash3( vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [0,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn  fract(sin(p+20.)*537.543);\n}\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, \n                          out float dist, out vec3 normal ) {\n\tvec3  ds = ro - sph;\n\tfloat bs = dot( rd, ds );\n\tfloat cs = dot(  ds, ds ) - 1.0;\n\tfloat ts = bs*bs - cs;\n\t\n\tif( ts > 0.0 ) {\n\t\tts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\tnormal = normalize( (ro+ts*rd)-sph );\n\t\t\tdist = ts;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 visualTex2D_ground(vec2 uv)\n{\n    return  texture(iChannel0,uv).rgb;\n}\n\nvec3 visualTex2D_tree(vec2 uv)\n{\n     return  texture(iChannel1,uv).rgb;\n}\n\n// Scene\n\nvoid getMovingSpherePosition( vec2 grid, inout vec3 center ) \n{\n\t// falling?\n\tfloat s = 0.1+hash( grid ).x;\n\tfloat t = 14.*s + time/s;\n\t\n\tfloat y =  s * MAXHEIGHT * abs( cos( t ) );\n\tvec2 offset = grid ;\n\t\n\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n}\n\nvec3 trace(vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, \n           out float dist, out int material) \n{\n\tmaterial = 0; // sky\n\tdist = MAXDISTANCE;\n\tfloat distcheck;\n\t\n\tvec3 sphereCenter, col, normalcheck;\n\t\n\tif( intersectPlane( ro,  rd, 0., distcheck) && distcheck < MAXDISTANCE ) \n    {\n\t\tdist = distcheck;\n\t\tmaterial = 1;\n\t\tnormal = vec3( 0., 1., 0. );\n\t} \n\t\n\t\t\n\t// trace grid\n\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd) * GRIDSIZE;\n\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n\tvec3 mm = vec3(0.0);\n\t\n\tfor( int i=0; i<RAYCASTSTEPS; i++ )\n    {\n\t\tgetMovingSpherePosition( pos.xz, sphereCenter );\n\t\t\n\t\tif( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck )\n           && distcheck < dist ) \n        {\n\t\t\tdist = distcheck;\n\t\t\tnormal = normalcheck;\n\t\t\tmaterial = 2;\n\t\t}\n        \n        \n     /*   float res = sdSphere( ro-sphereCenter, 1);\n        if(res<)\n        {\n        }\n\t*/\n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n\t\tpos += mm * rs;\t\t\n\t}\n\t\n    intersection = ro + rd*dist;\n\t\t\n\tvec3 color = vec3( 0. );\n\tif( material == 1 ) \n    {\n\t\tcolor = visualTex2D_ground(intersection.xz/4.)*(1.5+dot(normal, vec3( 0.5, 0.5, -0.5) ));\n\t}\n    else if( material == 2 ) \n    {\n\t\tcolor = visualTex2D_tree(intersection.xy/20.2)*(1.5+dot(normal, vec3( 0.5, 0.5, -0.5) ));\n\t}\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 0.0;// + iTime;\n\t\n    vec3 ce = vec3( 4.6*cos(0.1*time + 6.0*mo.x), \n                   1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n\t// camera\t\n\t//vec3 ce = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time),\n    //GRIDSIZE*(time/SPEED) );\n\tvec3 ro = ce;\n\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\n\t\n\tfloat roll = -0.15*sin(0.5*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\t\n\t// raytrace\n\tint material;\n\tvec3 normal, intersection;\n\tfloat dist;\n\t\n\tvec3 col = trace(ro, rd, intersection, normal, dist, material);\n\n\n\tcol = pow( col, vec3(EXPOSURE, EXPOSURE, EXPOSURE) );\t\n\tcol = clamp(col, 0.0, 1.0);\n\t\n\t// vigneting\n\tcol *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n\tfragColor = vec4( col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}