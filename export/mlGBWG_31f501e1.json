{"ver":"0.1","info":{"id":"mlGBWG","date":"1702609858","viewed":67,"name":"FlowerBox screensaver Windows 95","username":"smarchevsky","description":"Raytraced Windows 95 FlowerBox screensaver with BVH\n\nBuffer A - generating mesh data\nNodes: (2 texels) vec4(bbMin, childLeft), vec4(bbMax, childRight)\nQuads: (1 texel) vec4(vertex indices 0...3)\nVertices (1 texel) vec4(xyz position, a - packed normal)\n","likes":1,"published":1,"flags":32,"usePreview":1,"tags":["screensaver"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raytraced FlowerBox screensaver\n\nmat3 setCamera( in vec3 rayOrigin, in vec3 target, float cameraRotation )\n{\n\tvec3 cw = normalize(target - rayOrigin);\n\tvec3 cp = vec3(sin(cameraRotation), cos(cameraRotation),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 getData(int index) // index of pixel, kinda pointer\n{\n    ivec2 dataPos = ivec2(index % DATA_WIDTH, index / DATA_WIDTH);\n    return texelFetch(iChannel0, dataPos, 0);\n}\n\nvec3 unpackR11G11B10(float packedValueFloat) {\n    uint packedValue = floatBitsToUint(packedValueFloat);\n    float r = float((packedValue >> 22) & 0x3FFu) / 1023.0;\n    float g = float((packedValue >> 11) & 0x3FFu) / 1023.0;\n    float b = float(packedValue & 0x3FFu) / 1023.0;\n\n    return vec3(r, g, b) * 2. - 1.;\n}\n\nIndexedQuad getIndexedQuad(int quadIndex)\n{\n    IndexedQuad quad;\n    ivec4 vertIndices = ivec4(getData(quadIndex)) + vertDataStart;\n    if(vertIndices[3] > vertDataEnd)\n        return quad;\n\n    vec4 data0;\n    \n    data0 = getData(vertIndices.r);\n    quad.v0.p = data0.rgb;\n    quad.v0.n = unpackR11G11B10(data0.a);\n   \n    data0 = getData(vertIndices.g);\n    quad.v1.p = data0.rgb;\n    quad.v1.n = unpackR11G11B10(data0.a);\n   \n    data0 = getData(vertIndices.b);\n    quad.v2.p = data0.rgb;\n    quad.v2.n = unpackR11G11B10(data0.a);\n\n    data0 = getData(vertIndices.a);\n    quad.v3.p = data0.rgb;\n    quad.v3.n = unpackR11G11B10(data0.a);\n\n    return quad;\n}\n\n// rt code from here\n// https://www.shadertoy.com/view/DtGGzR\n\nbool isect_tri(inout Ray ray, in IndexedTriangle tri, inout Hit hit) {\n\tvec3 e1 = tri.v1.p - tri.v0.p;\n\tvec3 e2 = tri.v2.p - tri.v0.p;\n    if(dot(cross(e1,e2), ray.direction) < 0.) return false; // backface culling\n\n\tvec3 P = cross(ray.direction, e2);\n\tfloat det = dot(e1, P);\n\tfloat inv_det = 1. / det;\n\tvec3 T = (ray.origin - tri.v0.p);\n\tfloat u = dot(T, P) * inv_det;\n\tif (u < 0.0 || u > 1.0)\n        return false;\n\n\tvec3 Q = cross(T, e1);\n\tfloat v = dot(ray.direction, Q) * inv_det;\n\tif (v < 0.0 || (v+u) > 1.0)\n        return false;\n\n\tfloat tt = dot(e2, Q) * inv_det;\n\n    if(ray.tEnd > tt && ray.tStart < tt )\n    {\n        vec3 c = vec3(u, v, 1.0 - u - v);\n        countTI++;\n        hit.position = (ray.origin + ray.direction * tt);\n        //hit.normal = normalize(cross(e1, e2));\n        hit.normal = normalize(tri.v0.n * c.z + tri.v1.n * c.x + tri.v2.n * c.y);\n       // hit.uv = tri.v0.t * c.z + tri.v1.t * c.x + tri.v2.t * c.y;\n\n        hit.isHit = true;\n        ray.tEnd = tt;\n        return true;\n    }\n    return false;\n}\n\nbool isect_quad(inout Ray ray, in IndexedQuad q, inout Hit hit) {\n    IndexedTriangle l, r;\n    l.v0 = q.v0, l.v1 = q.v2, l.v2 = q.v1;\n    r.v0 = q.v1, r.v1 = q.v2, r.v2 = q.v3;\n    if(isect_tri(ray, l, hit))\n        return true;\n    if(isect_tri(ray, r, hit))\n        return true;\n}\n\n\nNode getNode(int index)\n{\n    index *= 2;\n    vec4 data0 = getData(index + 0);\n    vec4 data1 = getData(index + 1);\n\tNode node;\n\n    node.bbMin  = data0.rgb;\n    node.childL = int(data0.a);\n    node.bbMax  = data1.rgb;\n    node.childR = int(data1.a);\n\n\treturn node;\n}\n\n\nbool slabs(in Ray ray, in vec3 minB, in vec3 maxB, inout float localMin) {\n    if(all(greaterThan(ray.origin, minB)) && all(lessThan(ray.origin, maxB)))\n        return true;\n\n    vec3 t0 = (minB - ray.origin)/ray.direction;\n    vec3 t1 = (maxB - ray.origin)/ray.direction;\n    vec3 tmin = min(t0, t1), tmax = max(t0, t1);\n    float tminf = max(max(tmin.x, tmin.y), tmin.z);\n    float tmaxf = min(min(tmax.x, tmax.y), tmax.z);\n\n    if (tminf > tmaxf)\n        return false;\n\n    localMin = tminf;\n    return tminf < ray.tEnd && tminf > ray.tStart;\n}\n\nint traceCloseHitV2(inout Ray ray, inout Hit hit)\n{\n    stackClear();\n    stackPush(0);\n    hit.isHit = false;\n    Node select;\n    IndexedQuad quad;\n    float tempt;\n    \n    if(hit.isHit)\n        return 0;\n   \n    for(int i = 0; (i < 230) && (stackSize() > 0); i++)\n    {\n#ifdef SHOW_BVH\n        ray.nodesVisited++;\n#endif\n        int currentIndex = stackPop();\n        if(currentIndex == -1)\n            return 0;\n        select = getNode(currentIndex);\n        if(!slabs(ray, select.bbMin, select.bbMax, tempt))\n            continue;\n        \n        // child are both either nodes or quads both\n        // so there is no reason to check left and right individually\n        if(isNode(select.childL) )\n        {\n            float leftMinT = 0.;\n            float rightMinT = 0.;\n            Node right = getNode(select.childR);\n            Node left = getNode(select.childL);\n            bool rightI = slabs(ray, right.bbMin, right.bbMax, rightMinT);\n            bool leftI  = slabs(ray, left.bbMin,  left.bbMax,  leftMinT);\n\n            stackPush(select.childL);\n            stackPush(select.childR);\n                \n            continue;           \n        }\n\n        // only quads left, no nodes here\n        int quadIndex = toQuadIndex(select.childR);\n        quad = getIndexedQuad(quadIndex);\n        isect_quad(ray, quad, hit);\n\n        quadIndex = toQuadIndex(select.childL);\n        quad = getIndexedQuad(quadIndex);\n        isect_quad(ray, quad, hit);        \n    }\n    return 0;\n}\n\nbool detectQuadBit(inout float a){\n    if(!isNode(int(a)))\n    {\n        a = float(toQuadIndex(int(a))- quadDataStart);\n        return true;\n    }\n    return false;\n}\n\nmat4x4 transforms[6] = mat4x4[6] (\nmat4x4( 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1),\nmat4x4( 0, 1, 0, 0,  0, 0, 1, 0,  1, 0, 0, 0,  0, 0, 0, 1),\nmat4x4( 0, 0, 1, 0,  1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 0, 1),\nmat4x4(-1, 0, 0, 0,  0,-1, 0, 0,  0, 0,-1, 0,  0, 0, 0, 1),\nmat4x4( 0,-1, 0, 0,  0, 0,-1, 0, -1, 0, 0, 0,  0, 0, 0, 1),\nmat4x4( 0, 0,-1, 0, -1, 0, 0, 0,  0,-1, 0, 0,  0, 0, 0, 1)\n);\n\nvec3 colors[6] = vec3[6] (\nvec3(1,0,0), vec3(0,0,1), vec3(0,1,1), vec3(0,1,0), vec3(1,0,1), vec3(1,1,0)\n);\n\nmat4 rotate(float angle, vec3 axis) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    mat4 rotationMatrix;\n\n    rotationMatrix[0] = vec4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.x * axis.z + axis.y * s, 0.0);\n    rotationMatrix[1] = vec4(oc * axis.y * axis.x + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0);\n    rotationMatrix[2] = vec4(oc * axis.z * axis.x - axis.y * s, oc * axis.z * axis.y + axis.x * s, oc * axis.z * axis.z + c, 0.0);\n    rotationMatrix[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    return rotationMatrix;\n}\n\nvec3 sourceDir = -normalize(vec3(1,0.5,-0.6));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    vec3 target = vec3(0, 0, 0); // target pos\n    vec3 lightDir = normalize(vec3(-1, -1, 1)); // target pos\n    \n    vec2 mo = vec2(0);\n\tfloat time = iTime * 1.5;\n    \n    vec2 p = -1.0 + 2.0 * fragCoord / iResolution.xy;\n    p.y *= iResolution.y / iResolution.x;\n\n    Ray ray;\n    float dist = 14.5;\n    ray.origin = target + dist * vec3(cos(0.1 * time + 7.0 * mo.x), 0.4, sin(0.1 * time + 7.0 * mo.x));\n    \n    ray.tStart = 0.0001;\n    ray.tEnd = 1000000.;    \n#ifdef SHOW_BVH\n    ray.nodesVisited = 0;\n#endif\n\n    mat3 cameraMatrix = setCamera( ray.origin, target, 0. );\n    ray.direction = cameraMatrix * normalize( vec3(p.xy,2.0) );\n\n    // bouncing stuff: https://www.shadertoy.com/view/tsXXRj\n    vec3 t = fract(iTime * 0.2 * vec3(.543,0.57,0.236)), b = (t*4.-max(t*8.-4.,0.)-1.) * 2.4;\n\n    Hit hit;\n    \n    vec3 initialOrigin = ray.origin + b;\n    vec3 initialDirection = ray.direction;\n    \n    bool wasHit = false;\n    vec3 outNormal, outColor;\n    mat4 rotationMatrix = rotate(iTime, vec3(1,1,1));\n    for(int i = 0; i < 6; ++i){\n        mat4 transform = transforms[i] * rotationMatrix;\n        ray.origin    = (transform * vec4(initialOrigin,   1)).xyz;\n        ray.direction = (transform * vec4(initialDirection,0)).xyz;\n        traceCloseHitV2(ray, hit);\n        if(hit.isHit){\n\n            outNormal = -transpose(mat3(transform)) * hit.normal;\n            outColor = colors[i];\n            wasHit = true;\n        }\n    }\n    \n    if(wasHit){\n        //fragColor.rgb = outNormal;\n        fragColor.rgb = outColor * (-dot(outNormal, sourceDir) * 0.3 + 0.7);\n        fragColor.rgb += pow(max(dot(-reflect(initialDirection, outNormal), sourceDir), 0.), 4.) ;\n\n    }\n    //fragColor.rgb = pow(fragColor.rgb * 0.7, vec3(.5));\n \n#ifdef SHOW_BVH\n    fragColor.rgb += vec3(sqrt(float(ray.nodesVisited)) * 0.05);\n#endif\n\n// #define DEBUG_OVERLAY\n# ifdef DEBUG_OVERLAY\n    int ptr = int(iMouse.x / 4.);\n    const vec2 fontSize = vec2(4,5) * vec2(5,3);\n    vec4 dataRGBA = getData(ptr).rgba; \n    bool isQuad = detectQuadBit(dataRGBA.w);\n    vec3 digits = vec3(0);\n    digits += PrintValue(fragCoord, vec2(10, 500+10), fontSize, float(ptr), 10., 0.); // pointer to pixel\n    digits += PrintValue(fragCoord, vec2(10, 500-30), fontSize, float(ptr / 2), 10., 0.); // as node index\n    digits += PrintValue(fragCoord, vec2(10, 500-50), fontSize, dataRGBA.x, 20., 3.);\n    digits += PrintValue(fragCoord, vec2(10, 500-70), fontSize, dataRGBA.y, 20., 3.);\n    digits += PrintValue(fragCoord, vec2(10, 500-90), fontSize, dataRGBA.z, 20., 3.);\n    digits += (isQuad ? vec3(1,0,0) : vec3(1)) * PrintValue(fragCoord, vec2(10, 500-110), fontSize, dataRGBA.w, 20., 3.);\n    fragColor.rgb += digits;\n    ivec2 coord = ivec2(fragCoord / 4.);\n    if(getDataIndex(coord) != -1)\n    fragColor = texelFetch(iChannel0, ivec2(coord), 0);\n#endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float fGridSizeInv = 1.f / float(gridSize);\nconst float planeScale = float(gridSize + 1) * fGridSizeInv;\n\nvec3 posFromUV(in vec2 uv){\n    vec3 pos = vec3(uv * 2. - 1., 1.);\n    float mag = sin(iTime * 0.5);\n    pos = mix(pos, normalize(pos), mag * 3.5 + 2.);\n    pos *= mag * 0.1 + 1.; // make cube a bit smaller, flower a bit bigger\n    return pos;\n}\n\nfloat packToR11G11B10(vec3 vec) {\n    uvec3 uvec = uvec3(clamp(vec, 0.0, 1.0) * 1023.0 + 0.5);\n    return uintBitsToFloat((uvec.r << 22) | (uvec.g << 11) | uvec.b);\n}\n\n// xyz - position, a - R11G11B10 packed normal\n// alternatives:\n// 2 texels per vertex vec4(pos, 0), vec4(normal, 0);\n// pack positions and normals as 16 bit values\nvec4 getVertexPositionAndNormal(int index) { \n    float p = float(index) / float(gridSize + 1);\n    vec2 uv = vec2(fract(p), floor(p) / float(gridSize + 1)) * planeScale;\n    vec3 pos = posFromUV(uv);\n    vec3 posDX = posFromUV(uv + vec2(0.01, 0.0 )); \n    vec3 posDY = posFromUV(uv + vec2(0.0 , 0.01));\n    \n    vec3 normal = -normalize(cross(posDX - pos, posDY - pos));\n    return vec4(posFromUV(uv), packToR11G11B10(normal * 0.5 + 0.5));\n}\n\n\nvec4 getVertexPosition(int index) { \n    float p = float(index) / float(gridSize + 1);\n    vec2 uv = vec2(fract(p), floor(p) / float(gridSize + 1)) * planeScale;\n    return vec4(posFromUV(uv), 0);\n}\n\nivec4 getQuadIndices(int index)\n{\n    index += index / gridSize; // offset to skip last column\n    return ivec4(0, 1, gridSize + 1, gridSize + 2) + index;\n}\n\nvoid getQuadAABB(int index, out vec3 bbMin, out vec3 bbMax) {\n    ivec4 quadIndices = getQuadIndices(index);\n    \n    vec3 v0 = getVertexPosition(quadIndices.r).rgb;\n    vec3 v1 = getVertexPosition(quadIndices.g).rgb;\n    vec3 v2 = getVertexPosition(quadIndices.b).rgb;\n    vec3 v3 = getVertexPosition(quadIndices.a).rgb;\n    \n    vec3 bbMin01 = min(v0, v1); vec3 bbMax01 = max(v0, v1);\n    vec3 bbMin23 = min(v2, v3); vec3 bbMax23 = max(v2, v3);\n    \n    bbMin = min(bbMin01, bbMin23);\n    bbMax = max(bbMax01, bbMax23);\n    \n    float extend = 0.01;\n    \n    // bbMin.z -= extend; bbMax.z += extend;\n    bbMin -= extend; bbMax += extend;\n}\n\nNode getNode(int nodeIndex)\n{\n    int level = int(floor(log2(float(nodeIndex + 1))));\n    bool isSquare = (level % 2 == 0);\n\n    int gridHeight = int(pow(2., float(level / 2)));\n    int gridWidth = gridHeight * (isSquare ? 1 : 2);\n   \n    int gridNum = gridWidth * gridHeight;\n\n    int thisGridIndex = nodeIndex - (gridNum - 1);\n    int thisGridX = thisGridIndex % gridWidth;\n    int thisGridY = thisGridIndex / gridWidth;\n\n    int quadNumWidth = gridSize / gridWidth;\n    int quadNumHeight = gridSize / gridHeight;\n\n    Node result;\n    result.bbMin = vec3(1e30); result.bbMax = vec3(-1e30);\n    int quadOffset = thisGridX * quadNumWidth + thisGridY * gridSize * quadNumHeight;\n    \n    for (int j = 0; j < quadNumHeight; ++j) {\n        for (int i = 0; i < quadNumWidth; ++i) {\n            int quadIndex = i + gridSize * j + quadOffset;\n            \n            vec3 quadBMin, quadBMax;\n            getQuadAABB(quadIndex, quadBMin, quadBMax);\n            \n            result.bbMin = min(result.bbMin, quadBMin);\n            result.bbMax = max(result.bbMax, quadBMax);\n        }\n    }\n\n    ivec2 childIndices;\n    childIndices[0] = thisGridY * gridWidth * 2 + thisGridX * (isSquare ? 2 : 1);\n    childIndices[1] = childIndices[0] + (isSquare ? 1 : gridWidth); // next right or next down\n\n    int offsetNext = gridNum * 2 - 1;\n\n    if (level != maxDepth) {\n        childIndices += offsetNext;\n        \n    } else { // is quad\n        childIndices[0] = thisGridIndex;\n        childIndices[1] = thisGridIndex + 1;\n        childIndices += quadDataStart;\n        childIndices = -childIndices;\n    }\n    \n    result.childL = childIndices[0];\n    result.childR = childIndices[1];\n\n    return result;\n}\n\n\nvoid mainImage( out vec4 outData, in vec2 fragCoord )\n{\n    outData = vec4(-1);\n    ivec2 coord = ivec2(ivec2(fragCoord));\n    int dataIndex = getDataIndex(coord);\n\n    if(dataIndex < nodeDataEnd){ // nodes\n        int subIndex  = dataIndex % 2;\n        int nodeIndex = dataIndex / 2;\n        Node node = getNode(nodeIndex);\n        \n        if(subIndex == 0){\n            outData = vec4(node.bbMin, node.childL);\n        } else {\n            outData = vec4(node.bbMax, node.childR);\n        }\n        \n\n    } else if(dataIndex < quadDataEnd){\n        outData = vec4(getQuadIndices(dataIndex - quadDataStart));\n    } else if(dataIndex < vertDataEnd){\n        outData = getVertexPositionAndNormal(dataIndex - vertDataStart);\n    }\n    \n\n    \n    //vec4 triangleData = fragCoord.y + vec4(0, fGridSize, 1, 0);\n    \n\n\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DATA_WIDTH 16\n#define INVALID_INDEX -1\n// #define SHOW_BVH\n\nconst int gridSize = 8; // 8x8=64, works with pow 2 scales\nconst int maxDepth = int(floor(log2(float(gridSize * gridSize)))); // 64 = 2^6 \n// const int primitiveBit = 1 << 16; // with this bit it is primitive, otherwise - node\n\n\nconst int texelsPerVertex = 1;  // vec4 (x, y, z, 0)\nconst int texelsPerQuad = 1;    // vec4 (v0, v1, v2, v3)\nconst int texelsPerNode = 2;    // vec4 (bMin, iLeft), vec4 (bMax, iRight)\n\n\n// e.g. 9x9 vertices, 8x8 quads, nodes: 1x1 + 2x1 + 2x2 + 4x2 + 4x4 + 8x4 + 8x8\nconst int vertDataSize = (gridSize + 1) * (gridSize + 1) * texelsPerVertex;\nconst int quadDataSize = (gridSize + 1) * (gridSize + 1) * texelsPerQuad; // quads are 9x9, last row and unused\nconst int nodeDataSize = gridSize * gridSize * 2 * texelsPerNode;\n\n// nodes, quads, vertices\nconst int nodeDataStart = 0;\nconst int nodeDataEnd   = nodeDataStart + nodeDataSize;\nconst int quadDataStart = nodeDataEnd;\nconst int quadDataEnd   = quadDataStart + quadDataSize;\nconst int vertDataStart = quadDataEnd;\nconst int vertDataEnd   = vertDataStart + vertDataSize;\n\n\nint getDataIndex (ivec2 pos) { return (pos.x < DATA_WIDTH) ? pos.x + pos.y * DATA_WIDTH : INVALID_INDEX; }\n\n////////////////////// STRUCTS ///////////////////\n\nstruct Node\n{\n    vec3 bbMin;\n    int  childL;\n    vec3 bbMax;\n    int  childR;   \n};\n\nstruct Vertex {\n    vec3 p;\n    vec3 n;\n};\n\nstruct IndexedTriangle\n{\n   Vertex v0;\n   Vertex v1;\n   Vertex v2;\n};\n\nstruct IndexedQuad\n{\n   Vertex v0;\n   Vertex v1;\n   Vertex v2;\n   Vertex v3;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float tStart;\n    float tEnd;\n#ifdef SHOW_BVH\n    int nodesVisited;\n#endif\n};\n\nstruct Hit\n{\n    vec3 position;\n    vec3 normal;\n    vec2 uv;\n    bool isHit;\n};\n\nbool isNode(int index) {return index > 0; }\nint toQuadIndex(int index) { return -index; }\n\n\n//------------------- STACK -----------------------\n\n#define MAX_STACK_SIZE 15\nint countTI = 0;\nint _stack[MAX_STACK_SIZE];\nint _index = -1;\nvoid stackClear() { _index = -1; }\nint stackSize() { return _index + 1; }\nvoid stackPush(in int node) { if(_index > (MAX_STACK_SIZE - 1)) return; _stack[++_index] = node; }\nint stackPop() { return _stack[_index--]; }\n\n\n/////////////////// DEDBUG ////////////////////////////\n\n\n//vec3 pal( in float t, in vec3 c, in vec3 d ) { return 0.5 + 0.5 * cos(6.28318 * (c * t + d)); }\n//vec3 rainbow(float t) { return pal(t, vec3(1.0), vec3(0.0,0.33,0.67)); }\n\n// https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\n","name":"Common","description":"","type":"common"}]}