{"ver":"0.1","info":{"id":"MsySzd","date":"1466356328","viewed":2641,"name":"Path tracer demo","username":"scott","description":"Drag the mouse to rotate. If you go full-screen or have a slow card, you may want to reduce SAMPLES.\nI ported smallpt to C#, then to WebGL, now to shadertoy!\n","likes":59,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","unbiased","smallpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 r = texture(iChannel0, uv);\n\t\n    // gamma\n    r = clamp(r,0.0,1.0);\n\tr = vec4( pow( r , vec4(1.0/2.2)));    \n    \n    fragColor =  r;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SAMPLES 25\n#define N_SPHERES 8\n#define DIFF 0\n#define REFR 1\n#define SPEC 2\n#define CHECK 3\n#define PHONG 4\n\n//-----------------------------------------------------------------------\n\nvec2 camAng;\n\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Sphere { float radius; vec3 position; vec3 emission; vec3 colour; int type;};\n\nSphere spheres[N_SPHERES];\n\t\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\n\n//-----------------------------------------------------------------------\nvoid SetupScene(void)\n//-----------------------------------------------------------------------\n{\n\t\tvec3 z = vec3(0.0,0.0,0.0);\n\t\tvec3 L1 = vec3(0.2,0.7,1.2) * 30.0;\n\t\tvec3 L2 = vec3(1.2,0.7,0.2) * 1.0;\n\t\t\n        spheres[0] = Sphere( 10000.0, vec3(50.0, 10000.0, 81.6),z,vec3(.5,.5,.5),  CHECK); // floor\n        spheres[1]= Sphere(    200.0, vec3(750.0,   450.0, 81.6), L1, vec3(1.0,1.0,1.0),      DIFF); //Light1\n\t\tspheres[7]= Sphere(    600.0, vec3(0.0,  750.0, 0), L2, vec3(1.0,1.0,1.0),      DIFF); //Light2\n        spheres[2] = Sphere(     16.5, vec3(27.0,16.5,47.0),      z, vec3(1.0,1.0,1.0)*.05, SPEC);//Mirr\n        spheres[3] = Sphere(     16.5, vec3(73.0,16.5,78.0),      z, vec3(1.0,1.0,1.0)*.999, REFR);//Glas\n        spheres[4] = Sphere(     10.0, vec3(11.0,10.0,100.0),     z, vec3(0.7,0.7,0.2)*.999, PHONG);//Yellow\n        spheres[5] = Sphere(      8.0, vec3(50.0,28.0,70.0),      z, vec3(0.6,0.1,0.8)*.999, PHONG);//Purple\n        spheres[6]= Sphere(      7.0, vec3(45.0,7.0,75.0),        z, vec3(0.0,0.1,0.9)*.999, DIFF);//Green\n}\n\n\n//-----------------------------------------------------------------------\nfloat SphereIntersect( float rad , vec3 pos , Ray r)\n//-----------------------------------------------------------------------\n\t{\n\t\tvec3 op = pos - r.origin;\n\t\tfloat eps = 0.01;\n\t\tfloat b = dot(op , r.direction);\n\t\tfloat det = b * b - dot(op,op) + rad * rad;\n        if (det < 0.0)\n\t\t\treturn 0.0;\n        \n\t\tdet = sqrt(det);\n\t\t\n\t\tfloat t1 = b - det;\n\t\tif( t1 > eps )\n\t\t\treturn t1;\n\t\t\n\t\tfloat t2 = b + det;\n\t\tif( t2 > eps )\n\t\t\treturn t2;\n\n\t\treturn 0.0;\t\n\t}\n\t\n\n//-----------------------------------------------------------------------\nbool Intersect(Ray r , inout float t , inout int id , inout Sphere s)\n//-----------------------------------------------------------------------\n{\n\t\tfloat d;\n\t\tfloat inf = 10000000.0;\n\t\tt   = inf;\n        for (int i = 0; i < N_SPHERES; i++)\n        {\n\t\t\td = SphereIntersect( spheres[i].radius , spheres[i].position , r );\n            if (d != 0.0 && d < t)\n            {\n\t\t\t\tt = d;\n                s = spheres[i];\n            }\n        }\n\t\treturn t < inf;\n\t}\n\n//-----------------------------------------------------------------------\nvec3 CalculateRadiance( Ray r , vec2 rng )\n//-----------------------------------------------------------------------\n{\n\t\tvec3 finalCol = vec3(0.0,0.0,0.0);\n        vec3 fCum = vec3(1.0,1.0,1.0);\n\n        for (int depth = 0; depth < 8; depth++)\n        {\n                float t = 0.0;                            // distance to intersection\n                int id = 0;                               // id of intersected object\n                Sphere obj;\n\t\t\t\tif (!Intersect(r, t, id, obj))\n                    break;\n\n                vec3 x = r.origin + r.direction * t;\n                vec3 n = normalize(x - obj.position);\n                vec3 nl = dot(n,r.direction) < 0.0 ? n : n * -1.0;\n                vec3 f = obj.colour;\n\n                float p = max(max(f.x,f.y),f.z);\n\n\t\t\t\trng.x = rand( rng );\n\t\t\t\t\n                if ( rng.x < p)\n                    f = f / p;\n                else\n                    break; //R.R.\n\n                fCum = f * fCum;\n            \trng.y = rand(rng);\n\n            \t\n                if ((obj.type==PHONG && rng.y < 0.7) || obj.type == DIFF || obj.type == CHECK) // Ideal DIFFUSE reflection\n                {\n\t\t\t\t\tif( obj.type == CHECK )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( (mod(x.x,80.0) < 40.0 && mod(x.z,80.0) < 40.0) || \n\t\t\t\t\t\t\t\t(mod(x.x,80.0) > 40.0 && mod(x.z,80.0) > 40.0) )\n\t\t\t\t\t\t\t\tfCum *= 0.3;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\n                    float r1 = 2.0 * 3.1415926536 * rand( rng ); rng.x = sin(r1 - float(iFrame));\n                    float r2 = rand( rng ); rng.y = sin(r2 + float(iFrame));\n                    float r2s = sqrt(r2);\n                    vec3 w = nl;\n\t\t\t\t\tvec3 u = normalize(cross( (abs(w.x) > .1 ? vec3(0.0, 1.0, 0.0) : vec3(1.0,1.0,1.0)) , w));\n\t\t\t\t\tvec3 v = cross(w,u);\n                    vec3 d = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.0 - r2));\n                    finalCol = finalCol + fCum * obj.emission;\n                    r = Ray(x, d);\n                    continue;\n                }\n                else\n                    if (obj.type == SPEC || obj.type == PHONG)            // Ideal SPECULAR reflection\n                    {\n                        finalCol = finalCol + fCum * obj.emission;\n                        r = Ray(x, r.direction - n * 2.0 * dot(n,r.direction));\n                        continue;\n                    }\n\n                // Ideal dielectric REFRACTION\n                Ray reflRay = Ray(x, r.direction - n * 2.0 * dot(n,r.direction));     \n\t\t\t\tbool into = dot(n,nl) > 0.0;                // Ray from outside going in?\n\n                float nc = 1.0;   // IOR of air\n                float nt = 1.5; // IOR of solid\n                float nnt = into ? nc / nt : nt / nc;\n                float ddn = dot(r.direction , nl);\n                float cos2t = 1.0 - nnt * nnt * (1.0 - ddn * ddn);\n\n                if (cos2t < 0.0)    // Total internal reflection\n                {\n                    finalCol = finalCol + fCum * obj.emission;\n                    r = reflRay;\n                    continue;\n                }\n\n                vec3 tdir = normalize(r.direction * nnt - n * ((into ? 1.0 : -1.0) * (ddn * nnt + sqrt(cos2t))));\n\n                float a = nt - nc;\n                float b = nt + nc;\n                float R0 = a * a / (b * b);\n                float c = 1.0 - (into ? -ddn : dot(tdir,n));\n                float Re = R0 + (1.0 - R0) * c * c * c * c * c;\n                float Tr = 1.0 - Re;\n                float P = .25 + .5 * Re;\n                float RP = Re / P;\n                float TP = Tr / (1.0 - P);\n\n\t\t\t\trng.y = rand(rng);\n\t\t\t\t\n                if( rng.y < P )\n                {\n                    r = reflRay;\n                    fCum = fCum * RP;\n                    finalCol = finalCol + fCum * obj.emission;\n                }\n                else\n                {\n                    r = Ray(x, tdir);\n                    fCum = fCum * TP;\n                    finalCol = finalCol + fCum * obj.emission;\n                }\n\t\t\t\t\n\t\t\t\t// we reached something bright, don't spawn any more rays\n                if (length( obj.emission ) > 100.0)\n                    break;\n\n            }\n\n            return finalCol;\n\t}\n\n\n\n\n\n\n//-----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n//-----------------------------------------------------------------------\n{\n    vec4 bufferB = texture(iChannel1, vec2(0.5,0.5) );\n    \n    camAng = bufferB.xy;    \n\n    SetupScene();\n\tfloat t = 0.0;\n\t\t\n\t\t// camera\n\t\tvec3 lookAt = vec3( 40.0 , 5.0 , 60.0 );\n\t\tfloat elev = camAng.y + 0.4;\n\t\tvec3 camLoc = lookAt + vec3( sin(camAng.x)*cos(elev), sin(elev) , cos(camAng.x)*cos(elev) ) * 90.0 ;\n\n\t\tRay cam = Ray( camLoc , normalize(lookAt - camLoc) );\n\n\t\tvec3 cy = vec3(0.0,1.0,0.0);\n\t\tvec3 cx = normalize( cross( cam.direction , cy ) );\n\t\tcy = normalize( cross( cam.direction , cx ) );\n\t\t\n\t\tcx *= iResolution.x / iResolution.y;\n\t\t\n\t\tcx *= 0.8;\n\t\tcy *= -0.8;\n\t\t\n\t\tvec3 r = vec3(0.0,0.0,0.0);\n\t\t\n\t\t// rng seeds\n\t\tfloat r1 = gl_FragCoord.x + iTime;\n\t\tfloat r2 = gl_FragCoord.y + sin( float(iFrame) );\n\t\t\n\t\tfor(int s=0;s<SAMPLES;s++)\n\t\t{\n\t\t\tr1 = 2.0 * rand(vec2(r1,r2));\n\t\t\tfloat dx = r1 < 1.0 ? sqrt(r1) - 1.0 : 1.0 - sqrt(2.0 - r1);\n            r2 = 2.0 * rand(vec2(r1,r2));\n            float dy = r2 < 1.0 ? sqrt(r2) - 1.0 : 1.0 - sqrt(2.0 - r2);\n\n\t\t\t\n            vec3 d = cx * ((dx + gl_FragCoord.x) / iResolution.x - .5) \n\t\t\t       + cy * ((dy + gl_FragCoord.y) / iResolution.y - .5) \n\t\t\t\t   + cam.direction;\n\t\t\t\t   \n\t\t\tRay ray = Ray( cam.origin + d * 10.0 , normalize(d) );\n\t\t\tr = r + CalculateRadiance( ray , vec2(r1,float(s)) );\n\t\t}\t\n\t\t\n\t\tr /= float(SAMPLES);\n\t\t\n\t\tvec4 c2 = vec4( r  , 1.0 );\n\t\t\n\t\tvec2 xy = gl_FragCoord.xy / iResolution.xy;\n\t\tvec4 c1 = texture(iChannel0, xy);\n\t\t\n    \tfloat fDelta = float(iFrame) - bufferB.z;\n    \n    \tif( fDelta < 1.0 )\n            fragColor = c2;\n    \telse\n\t\t\tfragColor = ( c1 * fDelta + c2 ) / (fDelta + 1.0);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    // vec4( camAngx , camAngy , timeWhenStoppedMoving , 0);    \n \n    vec4 old = texture(iChannel0, vec2(0.5,0.5) );\n    \n    \n    if( iMouse.z > 0.0 )\n        old = vec4( (iMouse.z-iMouse.x)/100.0 ,\n                    (iMouse.w-iMouse.y)/250.0 , float(iFrame) , 0.0);\n       \n    \n    fragColor = old;\n}","name":"Buffer B","description":"","type":"buffer"}]}