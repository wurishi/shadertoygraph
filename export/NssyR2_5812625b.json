{"ver":"0.1","info":{"id":"NssyR2","date":"1642396485","viewed":139,"name":"simple dice","username":"banbao990","description":"simple dice","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 单击屏幕左边右边切换形态\n// click the left/right of the screen to change style\n\n#define LIGHT_POSITION vec3(10.0, 0.0, 10.0)\n\n#define AA 1\n#define ZERO min(iFrame, 0)\n#define PI 3.1415926\n\n//-------------------------------------------------------------------------------\n// 辅助函数\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// https://iquilezles.org/articles/sfrand\nfloat sfrand( inout int mirand ) {\n    mirand = mirand*0x343fd+0x269ec3;\n    float res = uintBitsToFloat((uint(mirand)>>9)|0x40000000u );\n    return( res-3.0 );\n}\n\n// hash by Hugo Elias(哈希函数 uint)\nuint ihash( uint n ) {\n    n = (n << 13) ^ n;\n    n = (n*(n*n*15731u+789221u)+1376312589u)&0x7fffffffu;\n    return n;\n}\n\n// hash by Hugo Elias(哈希函数 float)\nfloat hash( int n ) {\n    n = (n << 13) ^ n;\n    n = (n*(n*n*15731+789221)+1376312589)&0x7fffffff;\n    return 1.0 - float(n)*(1.0/1073741824.0);\n}\n\nfloat noise( vec3 p ) {\n    ivec3 ip = ivec3(floor(p));\n    vec3  fp = fract(p);\n\n    vec3 w = fp*fp*(3.0-2.0*fp);\n\n    int n = ip.x + ip.y*57 + 113*ip.z;\n\n    return mix(mix(mix( hash(n+(0+57*0+113*0)),\n                        hash(n+(1+57*0+113*0)),w.x),\n                   mix( hash(n+(0+57*1+113*0)),\n                        hash(n+(1+57*1+113*0)),w.x),w.y),\n               mix(mix( hash(n+(0+57*0+113*1)),\n                        hash(n+(1+57*0+113*1)),w.x),\n                   mix( hash(n+(0+57*1+113*1)),\n                        hash(n+(1+57*1+113*1)),w.x),w.y),w.z);\n}\n\n// https://iquilezles.org/articles/fbm\n// Fractional Brownian Motion(分数布朗运动)\n// 自相似性\nfloat fbm( vec3 p ) {\n#if 0\n    // original code\n    return 0.5000*noise( p*1.0 ) +\n           0.2500*noise( p*2.0 ) +\n           0.1250*noise( p*4.0 ) +\n           0.0625*noise( p*8.0 );\n#else\n    // equivalent code, but compiles MUCH faster\n    float f = 0.0;\n    float s = 0.5;\n    for( int i = ZERO; i < 4; i++ ) {\n        f += s*noise( p );\n        s *= 0.5;\n        p *= 2.0;\n    }\n    return f;\n#endif\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min 1 (k=0.1)\n// 返回两者之间的较小值, 更加平滑\nfloat smin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0 - h); // mix(x,y,a)=x*(1-a)+y*a\n}\n\n// 返回两者之间的较大值, 更加平滑\nfloat smax(float a,float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// 返回旋转矩阵\nmat2 rotmat(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    // OpenGL 列优先\n    return mat2(c,s,-s,c);    // 用于右乘\n    // return mat2(c,-s,s,c); // 用于左乘\n}\n\n\n//-------------------------------------------------------------------------------\n// 基本图元\n// https://iquilezles.org/articles/distfunctions\n\n\n// 长方体\n// p: 相对长方体中心的坐标\n// b: 长方体 x,y,z 轴的放缩(初始为 [-1,1]^3)\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p) - s;\n}\n\n// 相当于长方体向外扩展 r\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//-------------------------------------------------------------------------------\n\nvec3 posForMat; // 当物体变换时, 凹凸贴图使用的随机数应该不变\n// 骰子 dice\nfloat sdDice(vec3 pos, out uint subMatId) {\n    const float s = 0.5;\n    \n    float dist = 1e10;\n    // 骰子本体\n    if (iMouse.x < iResolution.x/2.0) {\n        float d = max(sdSphere(pos, 1.3*s), sdBox(pos, vec3(s)));\n        if( d < dist) {\n            dist = d; subMatId = 21u;\n        }\n    } else {\n        const float r = 0.15;\n        float d = sdRoundBox(pos, vec3(s-r), r);\n        if( d < dist) {\n            dist = d; subMatId = 21u;\n        }\n    }\n    \n    {\n        float d, R2;\n        \n        // 1 (red, 1u)\n        R2 = s*0.25; // 1\n        R2 *= R2;\n        if(pos.y > 0.0 && dot2(pos.xz) < R2) {\n            subMatId = 1u;\n        }\n        \n        R2 = s*0.18;      // 2-6\n        R2 *= R2;\n\n        // 2 (blue, 2u)\n        if(    pos.z < 0.0 \n            && dot2(abs(pos.xy) - s*vec2(0.0, 0.35)) < R2){\n            subMatId = 2u;\n        }\n        \n        // 3 (blue, 2u)\n        if(pos.x > 0.0) {\n            if(    (dot2(pos.yz) < R2)\n                || (   sign(pos.y) == sign(pos.z) \n                    && dot2(abs(pos.yz) - s*vec2(0.35)) < R2)) {\n                subMatId = 2u;\n            }\n        }\n        \n        // 4 (red, 1u)\n        if(    pos.x < 0.0 \n            && dot2(abs(pos.yz) - s*vec2(0.33)) < R2){\n            subMatId = 1u;\n        }\n        \n        // 5 (blue, 2u)\n        if(pos.z > 0.0) {\n            if(    dot2(pos.xy) < R2\n                || dot2(abs(pos.xy) - s*vec2(0.35)) < R2) {\n                subMatId = 2u;\n            }\n        }\n        \n        // 6 (blue, 2u)\n        if(pos.y < 0.0) {\n            if(    dot2(abs(pos.xz) - s*vec2(0.3, 0.0 )) < R2\n                || dot2(abs(pos.xz) - s*vec2(0.3, 0.45)) < R2) {\n                subMatId = 2u;\n            }\n        }    \n    }\n    \n    return dist;\n}\n\n// 场景构建\nfloat map( vec3 pos, out uint sid, out uint subMat ) {\n    subMat = 0u;           // 击中的物体的材质\n    float mindist = 1e10;  // sdf 值\n    \n    // 地板\n    {\n        float d = pos.y - (-2.0);\n        if(d < mindist){\n            mindist = d;\n            sid = 1u; posForMat = pos;\n        }\n    }\n    \n    \n    // 骰子\n    {\n        uint kk;\n        vec3 p = pos;\n        p.xy *= rotmat(iTime);\n        \n        float d = sdDice(p, kk);  \n        if(d < mindist){\n            mindist = d;\n            sid = 2u; subMat = kk; posForMat = p;\n        }\n    }\n\n    return mindist;\n}\n\nvoid raycast( vec3 ro, vec3 rd, float tMin, float tMax,\n              out float resT, out vec3 resPos,\n              out uint resSurface, out uint subMat ) {\n    float t = tMin;\n    for(int i = ZERO; i < 256 && t < tMax; i++) {\n        resPos = ro + t*rd;\n        float h = map(resPos, resSurface, subMat);\n        if(h < 0.0001) {\n            resT = t;\n            return;\n        }\n        // 最简单的步进方式, 0.75 做一个步进限制\n        t += h*0.75;\n    }\n    // 没击中任何物体设置 resSurface=666u\n    resSurface = 666u;\n}\n\nvec3 calcNormal( vec3 pos ) {\n#if 0\n    // original code\n    const float eps = 0.0002;\n    uint kk, kk2;\n    vec3 nor = vec3(\n      map( pos.x+eps, pos.y, pos.z, kk, kk2 ) - map( pos.x-eps, pos.y, pos.z, kk, kk2 ),\n      map( pos.x, pos.y+eps, pos.z, kk, kk2 ) - map( pos.x, pos.y-eps, pos.z, kk, kk2 ),\n      map( pos.x, pos.y, pos.z+eps, kk, kk2 ) - map( pos.x, pos.y, pos.z-eps, kk, kk2 ));\n    return normalize(nor);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++) {\n        uint kk, kk2;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos + 0.0002*e, kk, kk2);\n        if( n.x + n.y + n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = ZERO; i < 128; i++) {\n        uint tt1, tt2;\n        float h = map(ro + rd*t, tt1, tt2);\n        // 就是最简单的 softshadow(没有改进)\n        // k=8.0\n        float s = clamp(8.0*h/t, 0.0, 1.0);\n        res = min( res, s );\n        // t += clamp( h, 0.02, 0.2 );\n        t += h;\n        if( t > tmax ) break;\n    }\n    res = res*res*(3.0 - 2.0*res); // 0.037 => 0.004\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i = ZERO; i < 5; i++ ) {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        uint tt1, tt2;\n        float d = map(pos + h*nor, tt1, tt2);\n        occ += (h - d)*sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);\n}\n\n// 材质\n// subMatID 为奇数则不需要 bump mapping\nvec3 shade( vec3 pos, vec3 rd, uint matID, uint subMatID, float dis ) {\n    // 没有击中任何物体\n    if( matID == 666u ) return vec3(0.1, 0.1, 0.2);\n\n    vec3 col = vec3(0.1 * dis);\n\n    // calc normal\n    vec3 nor = calcNormal( pos );\n\n    // bump mapping\n    // 对法线进行随机扰动\n#if 1\n    if(matID != 2u || subMatID <= 20u) {\n        vec3 p = posForMat;\n        const float kke = 0.0001;\n        float bumpa = 0.0075; // 越大则凹凸程度越大\n        bumpa *= 0.75;\n        bumpa /= kke;\n        float kk = fbm( 32.0*p );\n        nor.x += bumpa*(fbm( 32.0*vec3(p.x+kke, p.y, p.z) )-kk);\n        nor.y += bumpa*(fbm( 32.0*vec3(p.x, p.y+kke, p.z) )-kk);\n        nor.z += bumpa*(fbm( 32.0*vec3(p.x, p.y, p.z+kke) )-kk);\n        nor = normalize(nor);\n    }\n#endif\n\n    // materials\n    if( matID == 0u ) {\n        // ID=0, 全黑色\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    else if( matID == 1u ) {\n        // ID=1 地板\n        col = vec3(0.2);\n    }\n    else if( matID == 2u ) {\n        // bump mapping\n        // 1u 红色的点\n        if( subMatID == 1u ) col = vec3(0.5,0.0,0.0);\n        // 2u 蓝色的点\n        else if( subMatID == 2u ) col = vec3(0.0,0.0,0.5);\n\n        // no bump mapping\n        // 21u 骰子本体\n        if( subMatID == 21u ) col = vec3(0.6);\n    }\n\n    // shade\n    // blinn-phong\n    vec3  lig = normalize( LIGHT_POSITION  - pos );\n    vec3  hal = normalize( lig - rd );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 16.0);\n\n    float ao = calcAO(pos, nor); // AO\n    float ss = calcSoftshadow( pos, lig, 0.02, 20.0 ); // shadow\n    col *= (ao*0.05 + ss*(dif + spe*vec3(0.2)));\n\n    return col;\n}\n\n// 后处理\nvec3 post( vec3 col) {\n\n    // gamma correction\n    col = pow( col, vec3(0.4545) ); // 1/2.2=0.4545\n\n    return clamp(col, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize( -cross(cw,cp) ); // 左手系\n    vec3 cv =          ( -cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 computePixel(vec2 p) {\n    // y: [-1, 1]\n    // x: [-a, a], a=iResolution.x/iResolution.y\n    vec2 s = (2.0*p - iResolution.xy)/iResolution.y;\n\n    // camera, ray\n    float time = 32.0 + iTime*1.5;\n    vec3 ta = vec3( 0.0,0.0,0.0 );\n    float w = 1.0;\n    vec3 ro = ta + vec3( 4.5*cos(w*time), 2.0, 4.5*sin(w*time) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize(vec3(s, 3.0));\n\n    // 光线碰到的物体\n    float t;              // 时间\n    uint matID, sumMatID; // 材质\n    vec3 xyz;             // 位置\n\n    // raycast\n    // tMin 设置成 0.5 为了避免旋转的时候被遮挡住\n    raycast(ro , rd, 0.0, 24.0, t, xyz, matID, sumMatID );\n\n    // shade\n    vec3 col = shade( xyz, rd, matID, sumMatID, t );\n\n    // 光源\n    {\n        vec3 v1 =  LIGHT_POSITION - ro;\n        float lig_dist2 = dot(v1, v1);\n        float dist = dot(v1 ,rd);\n        float seg2 = lig_dist2 - dist*dist;\n#if 1\n        // 叠加雾状光源\n        // (1) 光源在物体前面 / 没有击中物体\n        if((dist > 0.0 && (dist < t || matID == 666u))) {\n            col += vec3(1.0, 0.95, 0.90)*exp2( -64.0*seg2 );\n        }\n#else\n        // 击中光源直接返回\n        #define R2 0.01\n        // (1) 光源在物体前面 / 没有击中物体\n        // (2) 击中光源\n        if((dist > 0 && (dist < t || matID == 666u)) && (seg2 < R2)) {\n            return vec3( 1.0, 0.95, 0.90 );\n        }\n#endif\n    }\n\n    // postprocess\n    col = post(col);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n#if AA<2\n    vec3 col = computePixel(fragCoord);\n#else\n    vec3 col = vec3(0.0);\n    for( int j = 0; j < AA; j++ ) {\n        for( int i = 0; i < AA; i++ ) {\n            vec2 of = vec2(i, j) / float(AA);\n            col += computePixel(fragCoord + of);\n        }\n        col /= float(AA*AA);\n    }\n#endif\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}