{"ver":"0.1","info":{"id":"wtXfzM","date":"1597262756","viewed":264,"name":"SuperStrat","username":"shau","description":"Model (with artistic license) of Stratocaster style guitar. The code takes a while to compile. Camera changes every 15 seconds","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["3d","guitar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/**\n * Model of Super-Strat style guitar with:\n * 25.5\" scale length\n * caramelised maple neck.\n * CBS era headstock\n * The curve blending was quite fun to work out\n * In hindsight it might has been easier to draw a Les Paul or Steinberger\n **/\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = ZERO; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec4 an = texture(iChannel1,AN/R);\n    vec3 col = vec3(0);\n    if (an.y>0.)\n    {\n        col += vec4(dof(iChannel0,U/R,texture(iChannel0,U/R).w),1.).xyz;\n        col /= an.y;\n    }\n    col = pow(col,vec3(1./2.4)); \n    \n    col *= an.x;\n    \n    C = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//CAMERA\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n \tfloat AT = mod(iTime,90.);\n    vec3 la = vec3(0,2.8,0),\n         ro = vec3(1.8,2.0,-4),\n         lp = vec3(-5,8.,-8);\n    float fl = 1., doff = 0.02;\n    \n    float fade = S(0.,2.,AT)   - S(13.,15.,AT) +\n                 S(15.,17.,AT) - S(28.,30.,AT) +\n                 S(30.,32.,AT) - S(43.,45.,AT) +\n                 S(45.,47.,AT) - S(58.,60.,AT) +\n                 S(60.,62.,AT) - S(73.,75.,AT) +\n                 S(75.,77.,AT) - S(88.,90.,AT);\n\n    if (AT>75.)\n    {\n        la = vec3(0,-17,0);\n        ro = vec3(-7,-27,-13);\n        lp = vec3(7,-8,-5);\n        doff = 0.004;\n        fl = 0.8;\n    }\n    else if (AT>60.)\n    {   \n        la = vec3(0,-20,0);\n        ro = vec3(7,-17,-12);\n        lp = vec3(-8,-20,-9);\n        doff = 0.002;\n        fl = 0.5;\n    }\n    else if (AT>45.)\n    {   \n        la = vec3(0,-12,0);\n        ro = vec3(7,-12,-30);\n        lp = vec3(10,10,-15);\n        doff = 0.0;\n        fl = 0.7;\n    }\n    else if (AT>30.)\n    {   \n        la = vec3(0,-20,0);\n        ro = vec3(-10,-18,-12);\n        lp = vec3(-7,8.,-8);\n        doff = 0.002;\n        fl = 0.6;\n    }\n    else if (AT>15.)\n    {   \n        la = vec3(0,-20,0);\n        ro = vec3(0,-20,-10);\n        lp = vec3(10,-26,-10);\n        doff = 0.001;\n        fl = 0.8;\n    }\n\n    float FAT = floor(AT*0.066666);\n    vec4 pan = texture(iChannel0,U/R);\n    \n    if (ivec2(U)==ivec2(0)) {\n        C = R.xyxy; //Reinder\n    } else {\n\n        if (U==LA)\n        {\n            C = vec4(la,fl);\n        }\n        else if (U==RO)\n        {\n            C = vec4(ro,doff);    \n        }\n        else if (U==LP)\n        {\n            C = vec4(lp,0);    \n        }\n        else if (U==AN)\n        {\n            float tick = pan.y + 1.;\n            if (pan.w != FAT || texelFetch(iChannel0, ivec2(0),0).xy != R.xy)\n            {\n                tick = 0.;    \n            }\n            C = vec4(fade,tick,0,FAT);    \n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//MODEL AND RENDERING\n\n#define EPS .001\n#define FAR 60.\n\n#define BD 1.\n#define CHROME 1.\n#define WOOD 2.\n#define PAINT 3.\n#define PLASTIC 4.\n#define WOUND 5.\n\n#define TS vec2(0.0625)\n#define PI 3.141592\n\n//SUPERSTRAT - TEXT\nconst vec2[10] text = vec2[](vec2(3.0,10.0),  //S\n                             vec2(5.0,10.0),  //U\n                             vec2(0.0,10.0),  //P\n                             vec2(5.0,11.0),  //E\n                             vec2(2.0,10.0),  //R\n                             vec2(3.0,10.0),  //S\n                             vec2(4.0,10.0),  //T\n                             vec2(2.0,10.0),  //R\n                             vec2(1.0,11.0),  //A\n                             vec2(4.0,10.0)); //T\n\n//extract letter from texture\nvec4 letter(vec2 uv, vec2 id, float s)\n{\n    vec4 l = vec4(0.0);\n    uv *= s;\n    uv += TS*id - vec2(0.5*s) + TS*0.5;\n    if (uv.x>(id.x*TS.x) && uv.x<((id.x + 1.0)*TS.x) && \n        uv.y>(id.y*TS.y) && uv.y<((id.y + 1.0)*TS.y))\n    {\n        l = texture(iChannel2, uv, -1.0);\n    }\n    return l;\n}\n\nfloat markers(vec2 uv)\n{\n    uv.x = abs(uv.x);\n \tfloat t = length(uv - vec2(0,-3.45)) - 0.1;\n    t = min(t, length(uv - vec2(0,-5.87)) - 0.1);\n    t = min(t, length(uv - vec2(0,-8.)) - 0.1);\n    t = min(t, length(uv - vec2(0,-9.9)) - 0.1);\n    t = min(t, length(uv - vec2(0.6,-12.35)) - 0.1);\n    t = min(t, length(uv - vec2(0,-14.47)) - 0.1);\n    t = min(t, length(uv - vec2(0,-15.68)) - 0.1);\n    t = min(t, length(uv - vec2(0,-16.76)) - 0.1);\n    t = min(t, length(uv - vec2(0,-17.73)) - 0.1);\n    return step(0.0,t);\n}\n\n//https://iquilezles.org/www/articles\nfloat sdEqTriangle(vec2 p) \n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, - k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nfloat pattern(vec2 uv, \n              float size, \n              float width) \n{\n    for(int i=ZERO; i<5; ++i) {\n\t\tuv *= rot(float(i)+1.6);\n        uv = abs(fract(uv/30. + .5) - .5)*30.; //NuSan\n\t\tuv -= size;\n\t\tsize *= 0.5;\n\t}\n    \n    return max(0.0, sign(-sdEqTriangle((uv+vec2(0.0,-0.5))*1.)) *\n                    sign(sdEqTriangle((uv+vec2(0.0,-0.5))*width)));\n}\n\n//Dave Hoskins hash without sin\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//Shane IQ\nfloat NZ(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*89.5),fract(sin(h+s.x)*89.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n//box functions from IQ\n//https://iquilezles.org/www/index.htm\nfloat boxIntersect(vec3 ro, vec3 rd, vec3 b) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * b;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return (tN > tF || tF < 0.0) ? -1.0 : tN;\n}\n\n//SDFs - IQ\n//https://iquilezles.org/www/articles\nfloat sdBox(vec3 p, vec3 b) \n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h)\n{\n  vec2 q = vec2(length(p.xy), p.z);\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// I don't enjoy swizzling so ...\nfloat sdXCapsule(vec3 p, float h, float r)\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdYCapsule(vec3 p, float h, float r)\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdZCapsule(vec3 p, float h, float r)\n{\n    p.z -= clamp( p.z, 0.0, h );\n    return length( p ) - r;\n}\nfloat sdXTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.yz)-t.x,p.x);\n    return length(q)-t.y;\n}\n\nfloat sdYTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdZTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nfloat sdXCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdYCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdZCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat smin(float a, float b, float k) \n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    float s = step(a.x,b.x);\n    return a*s + (1.-s)*b;\n}\n\nvec2 neck(vec3 p)\n{\n    float nt = sdBox(p - vec3(0,0.05,0), vec3(.86,0.1,0.1));    \n    const float ff = 17.817;\n    const float fw = 0.02725;\n    float f = FAR,\n          sl = 25.5,\n          nf = 0.0;\n    for (int i=ZERO; i<22; i++)\n    {\n        float fd = (sl/ff);\n        sl -= fd;\n        nf += fd;\n        f = min(f, sdXCapsule(p - vec3(-.8125 + p.y*fw*.5,-nf,0), 1.625 - p.y*fw,.06));\n    }\n    float nk = sdYCapsule(p - vec3(0,-19.0,0), 19.5, .86 - p.y*fw*.5);\n    float hl = sdBox(p - vec3(0,-17.5,0), vec3(.86 - p.y*fw*.5, 3., 1.2));\n    hl = smax(hl,-sdYTorus(p - vec3(0,-14.5,0),vec2(1.5,0.6)),0.4);\n    nk = smin(nk,hl,0.1);\n    nk = max(nk, -sdBox(p - vec3(0,-12.75,-1.), vec3(2,16,1)));\n    nk = max(nk, -sdBox(p - vec3(0,-20.6,0), vec3(4.0,2.0,4.0))); \n    vec3 q = p - vec3(1.25,6.5,0.5);\n    float hs = sdZCappedCylinder(q, 1.25, 0.5);\n    q.xy *= rot(-0.26);\n    hs = min(hs, sdBox(q - vec3(-0.5,-3,0), vec3(1.,3.0,.5)));\n    hs = min(hs, max(sdZCappedCylinder(p - vec3(-4.5,1.1,0.5), 7.01, 0.5), -p.x));\n    hs = max(hs, -sdBox(p - vec3(0,-3.0,0), vec3(10.0,4.95,2.)));\n    hs = min(hs,sdBox(p - vec3(0.45,1.1,0.5), vec3(2.,0.85,0.5)));\n    float sc = sdZCappedCylinder(p - vec3(1.82845,4.954712,0.5),0.5,0.5);\n    hs = min(hs, max(max(max(sc,-(p.y - 4.746631)),p.y - 5.329328),p.x - 1.82845)); \n    hs = max(hs, -sdZCappedCylinder(p - vec3(1.82845,4.954712,0.5), 0.4, 0.8));     \n    hs = max(hs, -sdBox(q - vec3(-2.5,-3,0), vec3(1.25,3.4,1.)));    \n    hs = max(hs, -sdYTorus(p - vec3(0,0.25,0), vec2(1.5,.7)));\n    hs = max(hs, -sdZCapsule(p - vec3(-1.5,0.25,-1), 2., .7));\n    float rht = max(sdYTorus(p - vec3(0,0.25,0), vec2(2.5,1.7)), -p.x);\n    hs = max(hs,-rht);\n    hs = max(hs, -sdZCapsule(p - vec3(2.5,0.25,-1), 2., 1.7));\n    nk = min(nk, hs);\n    nk = max(nk, -sdBox(p - vec3(0,5.,0.), vec3(3,4,.5)));\n    nk = max(nk, -sdXCapsule(p - vec3(-3.,1.0,-0.2), 6., .7));\n    vec2 nr = near(vec2(nk,WOOD),vec2(f,CHROME));\n    return near(nr,vec2(nt,PLASTIC));\n}\n\nvec2 screwHead(vec3 p)\n{\n    float t = sdEllipsoid(p, vec3(.125,.125,.05));\n    t = max(t, -sdBox(p - vec3(0,0,-0.2),vec3(.125,.02,.2)));\n    t = max(t, -sdBox(p - vec3(0,0,-0.2),vec3(.02,.125,.2)));\n    return vec2(t,CHROME);\n}\n\nvec2 pickups(vec3 p)\n{\n    p.y = abs(p.y);\n    vec3 q = p - vec3(0,1.7,0);\n    q.xy = abs(q.xy);\n    float t = sdZCappedCylinder(q - vec3(1,0.39,0), 0.375, .5);\n    t = min(t, sdBox(q - vec3(0,0.39,0), vec3(1.,0.375,.5)));\n    q = opRepLim(q - vec3(0.6,0,0),.4,vec3(1,0,0));    \n    return near(vec2(t,PLASTIC),vec2(sdZCappedCylinder(q - vec3(0,0.39,0),.12,.6),CHROME));\n}\n\nfloat saddle(vec3 p)\n{\n    float t = sdBox(p - vec3(0,-0.1,-0.14), vec3(0.16,0.375,.05));\n    t = max(t, -sdZCappedCylinder(p - vec3(0,0,0), 0.1, 0.4));\n    t = max(t, -sdBox(p - vec3(0,-0.2,0), vec3(0.1,0.2,0.4)));\n    t = min(t, sdBox(p - vec3(0,-0.375,-0.25), vec3(0.16,0.1,0.06)));\n    t = min(t, sdXCappedCylinder(p - vec3(0,0.2,-0.2), .1, .16));\n    t -= 0.04;\n    p.x = abs(p.x);\n    t = min(t, sdZCappedCylinder(p - vec3(0.1,0.2,0), 0.05, 0.4));\n    t = max(t, -sdZCappedCylinder(p - vec3(0.1,0.2,0), 0.02, 0.5));\n    t = min(t, screwHead(p.xzy - vec3(0,-0.25,-0.83)).x);\n    return min(t, sdYCappedCylinder(p - vec3(0,-0.5,-0.25), 0.06,0.2));\n}\n\nvec2 bridge(vec3 p)\n{\n    float t = sdBox(p - vec3(0,-0.0,0), vec3(1.3375,.75,.05));\n    t = min(t, sdBox(p - vec3(0,-0.05,0), vec3(1.4375,.7,.05)));\n    t = min(t, sdBox(p - vec3(1.575,-0.25,0), vec3(0.1375,0.5,0.05)));\n    t = min(t, sdBox(p - vec3(1.625,-0.3,0), vec3(0.1875,0.45,0.05)));\n    t = min(t, sdZCappedCylinder(p - vec3(1.7125,0.15,0.), 0.1, 0.05));\n    t = min(t, sdBox(p - vec3(0,-0.7,-0.2), vec3(1.4375,0.05,.2)));\n    t = min(t, sdBox(p - vec3(0,-0.7,-0.25), vec3(1.3375,0.05,.25)));\n    t = max(t, -sdZCappedCylinder(p - vec3(1.5,-0.4,0.), 0.12, 0.4));\n    p.x = abs(p.x);\n    t = min(t, sdZCappedCylinder(p - vec3(1.3375,0.65,0.), 0.1, 0.05));\n    t = min(t, sdYCappedCylinder(p - vec3(1.3375,-0.7,-0.4),  0.1, 0.05));\n    p = opRepLim(p - vec3(0.6375,0,0), .425, vec3(1,0,0));  \n    t = max(t, -sdZCappedCylinder(p,0.08,0.4)); //string holes?\n    t = min(t, screwHead(p - vec3(0,0.5,-0.1)).x);\n    t = min(t, saddle(p));\n    return vec2(t,CHROME);\n}\n\nvec2 tuners(vec3 p)\n{\n    float pf = floor((p.y - 0.275)*1.0526);\n    p.xy *= rot(-0.26);\n    p.y = abs(p.y);\n    p = opRepLim(p - vec3(0,1.425,0), 0.95, vec3(0,1,0));\n    float t = sdZCappedCylinder(p - vec3(0,0.,0), 0.125, 0.5);\n    t = min(t, sdEllipsoid(p - vec3(0,0.,-0.5), vec3(0.125,0.125,0.05)));\n    t = min(t, sdHexPrism(p - vec3(0,0.,-0.06), vec2(0.22,0.04)));\n    t = min(t, sdZCappedCylinder(p - vec3(0,0.,-0.01), 0.3125, 0.02));\n    t = max(t, -sdXCappedCylinder(p - vec3(0,0.,-0.375), 0.06, 0.6));\n    t = min(t,sdZTorus(p - vec3(0,0,-0.34),vec2(0.13,0.023 - pf*0.003)));  \n    p -= vec3(0,0.,0.6);\n    t = min(t, sdXCapsule(p - vec3(-1.19,0,0), 1.0, 0.09));\n    t = min(t, sdBox(p - vec3(-0.15,0.,0), vec3(0.3,0.4,0.1)));\n    p.yz *= rot(0.3 + hash11(pf) * 2.3);\n    float k = sdEllipsoid(p - vec3(-1.,0,0.), vec3(0.25,.5,0.14));\n    p.yz = abs(p.yz);\n    k = smax(k, -sdBox(p - vec3(-1.0,0.57,0), vec3(0.2)), 0.04);\n    p.yz *= rot(-0.1);\n    k = smax(k, -sdBox(p - vec3(-1,0.2,0.3), vec3(0.2,0.3,0.2)), 0.02);\n    return vec2(min(t,k),CHROME);\n}\n\nfloat wing(vec3 p)\n{\n    float b = max(sdZCappedCylinder(p - vec3(-1.1,-2,0),7.375,BD),-(p.x + 4.7243)); \n    b = min(b, sdZCappedCylinder(p - vec3(-3.25,-5.810265,0),3.0,BD));\n    b = max(b, -sdBox(p - vec3(0,5.810265,0), vec3(10.,10.,2.)));\n    return min(b, max(sdZCappedCylinder(p - vec3(3.9,-5.810265,0),10.15,BD), - (p.y + 5.810265)));\n}\n\nvec2 body(vec3 p)\n{\n    //curve blending\n    float lw = min(wing(p),max(sdZCappedCylinder(p - vec3(0.9,7.125,0),6.4,BD),(p.y - 7.125)));\n    lw = min(lw,max(sdZCappedCylinder(p - vec3(-2.2375,7.125,0),3.2625,BD),p.x + 3.875));\n    lw = min(lw,max(sdZCappedCylinder(p - vec3(-2.075,7.675,0),2.8,BD),(p.y - 7.675)));\n    lw = max(lw,-sdZCappedCylinder(p - vec3(-2.075,7.675,0),1.8,2.));\n    lw = min(lw,max(max(sdZCappedCylinder(p - vec3(-7.198975,1.786789,0),5.3,BD),-(p.y + 0.077173)),(p.y - 3.602882)));\n    lw = max(lw,-sdZCappedCylinder(p - vec3(-7.198975,1.786789,0),3.3,2.));\n    lw = max(max(max(lw,p.y - 9.19174),p.x),-sdBox(p - vec3(0,8.2,0),vec3(2.)));\n    lw = max(lw,-sdBox(p - vec3(-3.875,9.375,0),vec3(.5,.5,2.)));\n    lw = min(lw,sdZCappedCylinder(p - vec3(-4.375,8.875,0),0.5,BD));\n\tfloat rw = min(wing(vec3(-p.x,p.yz)),max(sdZCappedCylinder(p - vec3(-0.9,4.875,0),6.4,BD),p.y - 4.875));\n    rw = min(rw,max(sdZCappedCylinder(p - vec3(3.75,4.875,0),1.75,BD),-(p.x-4.)));\n    rw = min(rw,max(sdZCappedCylinder(p - vec3(2.5,5.375,0),2.5,BD),p.y - 5.375));\n    rw = max(rw,-sdZCappedCylinder(p - vec3(2.5,5.375,0),1.5,2.0));\n    rw = min(rw,max(max(sdZCappedCylinder(p - vec3(6.72306,0.682275,0),3.3,BD),-(p.y + 0.51715)), (p.y - 1.790697)));\n    rw = max(rw,-sdZCappedCylinder(p - vec3(6.72306,0.682275,0),2.3,2.));\n    rw = max(max(rw,p.y - 6.275),-p.x);\n    rw = max(rw,-sdBox(p - vec3(4.0,6.375,0),vec3(.5,.5,2.)));\n    rw = min(rw,sdZCappedCylinder(p - vec3(4.5,5.875,0),0.5,BD));\n    float t = min(min(lw,rw),sdBox(p - vec3(0.,-1.5,0.),vec3(1.1,7.875,BD)));\n    vec3 q = p;\n    q.z = abs(q.z);\n    t = smax(t,-sdBox(q - vec3(0,0,1.875),vec3(10.,10.,1.)),.2); \n    t = max(t, -sdBox(p - vec3(0,6,-2),vec3(1.13,2.0,2.)));\n    t = smax(t, -(length(p - vec3(-8,1.,7)) - 8.),.4);\n    q = p - vec3(0,0.8,0);\n    q.y = abs(q.y);\n    t = smax(t, -sdBox(q - vec3(0,1.7,-2.), vec3(1.35,.7,2.)),.1);\n    t = smax(t, -sdBox(q - vec3(0,1.7,-2.), vec3(1.6,.1,2.)),.1);    \n    q = p - vec3(3.8,-1,0);\n    q.xy *= rot(0.5);\n    t = max(t, -sdBox(q,vec3(0.03,0.7,2.)));\n    q = p;\n    q.yz *= rot(-0.1);\n    q.xy *= rot(.5);\n    q.xz *= rot(-.2);\n    t = smax(t,-sdBox(q - vec3(0,-0.,-4.3),vec3(10.,10.,2.)),.3);\n    return vec2(max(t,abs(p.x) - 7.),PAINT);\n}\n\nvec2 knob(vec3 p)\n{\n    float d = sin(.5+atan(p.x,p.y)*24.);\n    float t = min(sdEllipsoid(p - vec3(0,0,-0.25),vec3(.35,.35,.1)),sdZCappedCylinder(p,0.33+d*0.006,0.25));\n    return vec2(t,CHROME);\n}\n\nvec2 selector(vec3 p)\n{\n    p.xy *= rot(0.5);\n \tfloat t = sdRoundCone(p,.1,.15,.25);\n    p.y = abs(p.y);\n    return near(vec2(t,PLASTIC),screwHead(p - vec3(0,.9,0.4)));\n}\n\nvec2 strap(vec3 p)\n{\n    return vec2(max(max(sdYCappedCylinder(p,0.26,0.2),\n                        -sdYCappedCylinder(p,0.16,0.4)),\n                    -sdYTorus(p,vec2(.27,.1))),CHROME);\n}\n\nvec2 strings(vec3 p)\n{\n    float w = sdCapsule(p,vec3(-0.75,0.14,-0.11),vec3(-1.0625,-25.3,-0.11),0.023);\n    w = min(w,sdCapsule(p,vec3(-0.75,0.14,-0.11),vec3(-0.7,1.68,0.1),0.024)); \n    w = min(w,sdCapsule(p,vec3(-0.45,0.14,-0.11),vec3(-0.6325,-25.3,-0.11),0.018));\n    w = min(w,sdCapsule(p,vec3(-0.45,0.14,-0.11),vec3(-0.45,2.6,0.1),0.018));\n    w = min(w,sdCapsule(p,vec3(-0.15,0.14,-0.11),vec3(-0.2125,-25.3,-0.11),0.013));\n    w = min(w,sdCapsule(p,vec3(-0.15,0.14,-0.11),vec3(-0.2,3.5,0.1),0.013));\n    float u = sdCapsule(p,vec3( 0.15,0.14,-0.11),vec3( 0.2125,-25.3,-0.11),0.008);\n    u = min(u,sdCapsule(p,vec3( 0.15,0.14,-0.11),vec3( 0.04,4.4,0.1),0.008));\n    u = min(u,sdCapsule(p,vec3( 0.45,0.14,-0.11),vec3( 0.6325,-25.3,-0.11),0.0055));\n    u = min(u,sdCapsule(p,vec3( 0.45,0.14,-0.11),vec3( 0.38,3.2,0.13),0.0055));\n    u = min(u,sdCapsule(p,vec3( 0.38,3.2,0.13),vec3( 0.28,5.35,0.1),0.0055));\n    u = min(u,sdCapsule(p,vec3( 0.75,0.14,-0.11),vec3( 1.0625,-25.3,-0.11),0.0045));\n    u = min(u,sdCapsule(p,vec3( 0.75,0.14,-0.11),vec3( 0.65,3.2,0.13),0.0045));\n    u = min(u,sdCapsule(p,vec3( 0.65,3.2,0.13),vec3( 0.52,6.2,0.1),0.0045));\n    return near(vec2(w,WOUND),vec2(u,CHROME));\n}\n\nvec2 tree(vec3 p)\n{\n    p.x = abs(p.x);\n \tfloat t = sdBox(p,vec3(0.12,0.2,0.06));\n    t = min(t,sdBox(p - vec3(0,0.15,-0.17),vec3(0.12,0.05,.17)));\n    t = min(t,screwHead(p - vec3(0,-0.07,-.12)).x); \n    t = min(t,sdXCappedCylinder(p - vec3(0,0.15,-0.38),.1,.22));\n    t = max(t,-sdXTorus(p - vec3(0.14,0.15,-0.38), vec2(.1,0.03)));\n    return vec2(t,CHROME);\n}\n\nvec2 map(vec3 p) \n{\n    vec2 nr = near(body(p - vec3(0,-22.5,1.2)),neck(p));\n    nr = near(nr,pickups(p - vec3(0,-21.7,0.6)));\n    nr = near(nr,bridge(p - vec3(0,-25.5,0.24)));\n    nr = near(nr,tuners(p - vec3(-0.2,4.,0.48)));\n    nr = near(nr,selector(p - vec3(3.8,-23.5,-.1)));\n    nr = near(nr,knob(p - vec3(3.5,-25.5,-0.0)));\n    nr = near(nr,strings(p));    \n    nr = near(nr,tree(p - vec3(0.5,3,0.46)));\n    nr = near(nr,strap(p - vec3(0.,-32.,1.2)));\n    p.xy *= rot(-.5);\n    nr = near(nr,strap(p - vec3(2.7,-13.4,1.2)));\n    return nr;\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=ZERO; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//soft shadow variation - IQ\n//https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for(int i=ZERO; i<32; i++)\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break; \n    }\n    return clamp( res, 0.03, 1.0 );\n}\n\n//http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nvec2 relaxedMarch(vec3 ro, vec3 rd) {\n\n    const float PR = EPS;\n\n    float om = 1.3,\n          t = EPS,\n          ce = FAR,\n          ct = EPS,\n          pr = 0.0,\n          sl = 0.0,\n          fs = 1.0, //map(ro).x < 0.0 ? -1.0 : 1.0,\n          id = 0.0;\n\n    for (int i = ZERO; i < 120; ++i) {\n        vec2 si = map(ro + rd * t);\n        float sr = fs * si.x;\n        float r = abs(sr);\n        bool fail = om > 1.0 && (r + pr) < sl;\n        if (fail) {\n            sl -= om * sl;\n            om = 1.0;\n        } else {\n            sl = sr * om;\n        }\n        pr = r;\n        float err = r / t;\n        if (!fail && err < ce) {\n            ct = t;\n            ce = err;\n        }\n        if (!fail && err < PR || t > FAR) {\n            id = si.y;\n            break;\n        }\n        t += sl;\n    }\n\n    if (t>FAR || ce>PR) ct=-1.;\n\n    return vec2(ct,id);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (2.0*(U+hash11(17. + float(iFrame)*3.)-0.5) - R)/R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float dof = 0.0;\n    vec4 la = texture(iChannel3,LA/R),\n         lp = texture(iChannel3,LP/R),\n         ro = texture(iChannel3,RO/R),\n         an = texture(iChannel3,AN/R),\n         buf = texture(iChannel0,U/R);\n    \n    vec3 rd = camera(U,ro.xyz,la.xyz,la.w),\n         pc = vec3(0.2,0.1,0.0)*NZ(12.*rd+0.3)*.1/(1.0 + rd.y*rd.y*80.0)*4.;\n    \n    float bi1 = boxIntersect(ro.xyz - vec3(0,-22.5,1.),rd,vec3(6.2,9.9,1.3)),\n          bi2 = boxIntersect(ro.xyz - vec3(0,-4.,1.),rd,vec3(2.8,12.,1.3));\n    \n    if (bi1>0. || bi2>0.)\n    {\n        vec2 s = relaxedMarch(ro.xyz,rd);\n        if (s.x>0.0)\n        {\n            vec3 p = ro.xyz + rd*s.x,\n                 n = normal(p),\n                 rc = texture(iChannel1,reflect(rd,n)).xyz,\n                 ld = normalize(lp.xyz - p);\n            float woodnz = NZ(16.*vec3(p.x,p.y*0.08,p.z)),\n                  ao = AO(p,n),\n                  spec = pow(max(dot(reflect(-ld,n),-rd),0.0),4.0),\n                  spec2 = pow(max(dot(reflect(-ld,n),-rd),0.0),32.0),\n                  fres = pow(clamp(dot(n,rd) + 1.0,0.0,1.0),3.0),\n                  df = max(0.1,dot(ld,n)),\n                  sh = shadow(p + n*EPS,ld,0.,length(lp.xyz - p)),\n                  pt = pattern(p.xy - vec2(0.,-24.),5.,1.6);\n            \n         \tdof = length(la.xyz - p)*ro.w;   \n            \n            if (s.y==PAINT)\n            { \n                pc = df * (vec3(1.,0.2,0.0)*pt + vec3(0,0.1,0.3)*max(-n.y,0.) + rc*fres*0.4); \n                pc += vec3(0.04)*spec + vec3(1)*spec2;\n            }\n            else if (s.y==WOOD)\n            {\n                float m = markers(p.xy);\n                pc = df * (mix(vec3(0.3,0.1,0.06), vec3(0.1,0.025,0.0), woodnz*0.8)*m +\n                     vec3(0,0.1,0.3)* max(-n.y,0.));\n                vec2 luv = (p.xy - vec2(1.7,4.5));\n                luv *= rot(1.8);\n                luv *= rot2(luv.x*0.13);\n                float logo = 0.0;\n                for (int i=ZERO; i<10; i++)\n                {\n               \t\tlogo += letter(luv - vec2(float(i)*.3-1.35,0.),text[i],0.12).x;\n                }\n                pc *= S(0.08,0.,logo);\n                pc += vec3(0.1)*spec;\n                pc += vec3(0.3)*spec2*woodnz;\n                pc += vec3(1.0)*step(0.08,logo)*spec2;\n            }\n            else if (s.y==CHROME)\n            {\n                pc = rc*(1. - fres) + vec3(0,0.1,0.3)* max(n.y,0.);  \n            }\n            else if (s.y==WOUND)\n            {\n                pc = rc*(1. - fres) + vec3(0,0.1,0.3)*max(n.y,0.);\n                pc *= abs(sin(p.y*100.));\n            }\n            else if (s.y==PLASTIC)\n            {\n                pc = df * (vec3(0.01) + vec3(0,0.1,0.3)*max(-n.y,0.));\n                pc += vec3(1) * spec2;\n            }\n            \n            pc *= sh*ao;\n        }   \n    }\n    \n    if (an.y>0.) pc += buf.xyz;\n    \n    C = vec4(pc,dof);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define LA vec2(1.5,0.5)\n#define RO vec2(2.5,0.5)\n#define LP vec2(3.5,0.5)\n#define AN vec2(4.5,0.5)\n#define S(a, b, v) smoothstep(a, b, v)\n#define ZERO (min(iFrame,0))\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nmat2 rot2(float x){return mat2(cos(x), -sin(x), sin(x), cos(x));}","name":"Common","description":"","type":"common"}]}