{"ver":"0.1","info":{"id":"cdlGWf","date":"1666901080","viewed":145,"name":"particle pizza","username":"Mojomajor","description":"started out trying to make dust (in a windowbeam ) ended up with a pizza that evolves over time","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["particlespizza"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime*.2\n#define tau 6.2831\n\n#define pi 3.141592653589793\n// Number of FBM Octaves\n#define num_octaves 8 // 16\n\n\n//#define pi acos(-1.)\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    \n    return fract(sin(p)*18.5453);\n}\n\n\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbmN(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// Rotate a vec2\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x*c-vec.y*s, vec.x*s+vec.y*c);\n}\n\n// Hash13 Hash without Sine: https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p, float t)\n{\n    vec3 p3 = vec3(p, t);\n    p3  = fract(p3*0.1031);\n    p3 += dot(p3, p3.zyx+31.32);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// Value Noise\n/*\nfloat noise(vec2 p, float t)\n{\n    vec2 f = smoothstep(0.0, 1.0, fract(p));\n    p = floor(p);\n    float t0 = hash(vec2(0.0, 0.0)+p, t);\n    float t1 = hash(vec2(1.0, 0.0)+p, t);\n    float t2 = hash(vec2(0.0, 1.0)+p, t);\n    float t3 = hash(vec2(1.0, 1.0)+p, t);\n    return mix(mix(t0, t1, f.x), mix(t2, t3, f.x), f.y);\n}\n*/\n\n// manu210404's Improved Version\nfloat noise(vec2 p, float t)\n{\n    vec4 b = vec4(floor(p), ceil(p));\n    vec2 f = smoothstep(0.0, 1.0, fract(p));\n    return mix(mix(hash(b.xy, t), hash(b.zy, t), f.x), mix(hash(b.xw, t), hash(b.zw, t), f.x), f.y);\n}\n\n\n\n// Fractal Brownian Motion Noise\nfloat fbm(vec2 pos)\n{\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n    float t = 0.0;\n    for(int i = 0; i < num_octaves; i++)\n    {\n        t += atten;\n        value += noise(pos*scale, float(i))*atten;\n        scale *= 2.0;\n        atten *= 0.5;\n        pos = rotate(pos, 0.125*pi);\n    }\n    return value/t;\n}\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat dualfbm(in vec2 p)\n{\n    //get two rotated fbm calls and displace the domain\n\tvec2 p2 = p*.1;\n\tvec2 basis = vec2(fbm(p2-time*1.2),fbm(p2+time*1.38));\n\tbasis = (basis-.5)*.2;\n\tp += basis;\n\t\n\t//coloring\n\treturn fbm(p*makem2(time*0.2));\n}\n\n\n// Traditional Uniform Identifiers\n#define resolution iResolution\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 permute(in vec4 x)\n{\n return mod ((34.0 * x + 1.0) * x , 289.0);   \n}\n\n// the bottleneck\nvec2 celluar2x2( vec2 P) {\n    \n    float pp =  7.0; \n \tfloat K = 1.0/pp;\n\tfloat K2 = 0.5/pp;\n\tfloat jitter = 0.8 ; // jitter 1.0 makes F1 wrong more often\n\tvec2 Pi = mod(floor(P), 289.0) ;\n\tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute (Pi.x + vec4(0.0 , 1.0, 0.0, 1.0));\n\tp = permute (p + Pi.y + vec4(0.0 , 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, pp) * K + K2;\n\tvec4 oy = mod(floor(p * K) ,pp) * K + K2;\n\tvec4 dx = Pfx + jitter * ox;\n\tvec4 dy = Pfy + jitter * oy;\n\tvec4 d = dx * dx + dy * dy; // distances squared\n\t// Cheat and pick only F1 for the return value\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated , F2 not computed\n \n    \n}\n\nvoid DrawAParticleSet(inout vec4 color, vec2 uv, float size ){\n   float aCellLenght = size;\n   vec3 colorTint;\n   float randomSeed01 = rand(floor (uv /aCellLenght));\n   float randomSeed02 = rand(floor (uv /aCellLenght) + 5.0);\n   float randomSeed03 = rand(floor (uv /aCellLenght) + 10.0);\n    \n  \n    colorTint= vec3(randomSeed01, randomSeed02, randomSeed03);\n    \n   float circleLenght =abs(sin(iTime * randomSeed03 + randomSeed02))  * randomSeed01 * aCellLenght;\n   \n   float jitterFreedom = 0.5 - circleLenght;\n   float jitterAmountX =  jitterFreedom * (randomSeed03 *2.0 -1.0);\n   float jitterAmounty =  jitterFreedom * (randomSeed01 *2.0 -1.0); \n   vec2 coord =  fract(uv / aCellLenght);\n    \n    \n   coord -= 0.5;\n   float z = 0.0;\n   vec3 toReturn; \n   for(int i=0; i < 3; i++) {\n       z += 0.015 * celluar2x2(dualfbm(coord)*coord + iTime * 0.1).x  /*abs(sin(iTime * randomSeed01 + randomSeed01))*/;\n\t\tcoord += z;\n\t\ttoReturn[i] = 1.0 - smoothstep(circleLenght- 30.5/iResolution.y,\n                                       circleLenght, distance(coord, vec2(jitterAmountX, jitterAmounty)));\n\t}\n    \n   toReturn = mix(color.xyz, colorTint *toReturn, length(toReturn));\n   color = vec4(toReturn.xyz, 0.1);\n}\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(time+tau*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n// Screen UV Coordinates\n    //vec2 uv =1.0*(fragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n\n    float screenXLenght = iResolution.x/ iResolution.y;\n    \n    vec4 endColor = vec4(.0);\n    \n    uv.x -= screenXLenght/2.0; \n    uv.y -= 0.5;\n    uv += .2*time;\n    //vec3 color = vec3(dualfbm(10.0*uv));\n    vec3 color = vec3(fbm(10.0*uv))*vec3(dualfbm(uv*.5))+0.2;\n    // dust mode for particels aka: The Painter\n    //vec3 color = vec3(fbmN(10.0*fbm(uv)*uv));\n    vec2 stt = uv;\n    // art good! but will fade over time\n    \n    DrawAParticleSet(endColor, uv, 0.1+fbm(uv));\n    DrawAParticleSet(endColor, uv- 0.1, 0.15);\n    DrawAParticleSet(endColor, uv + 0.3, 0.17);\n    \n    //normal\n    /*\n    DrawAParticleSet(endColor, stt, 0.1);\n    DrawAParticleSet(endColor, stt- 0.1, 0.15); // just dots\n    DrawAParticleSet(endColor, stt + 0.3, 0.17);\n    */\n    \n    \n    /*\n    // the matrix color effect\n    endColor.r = pow(endColor.r,3./2.);\n    endColor.g = pow(endColor.g,4./5.);\n    endColor.b = pow(endColor.g,3./2.);\n\t*/\n    fragColor = vec4(endColor*vec4(color,1.));\n}","name":"Image","description":"","type":"image"}]}