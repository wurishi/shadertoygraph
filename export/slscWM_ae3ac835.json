{"ver":"0.1","info":{"id":"slscWM","date":"1648313546","viewed":60,"name":"cg_hw1","username":"fj6hom","description":"hw","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","rtx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STACK_SIZE 10\n\nconst float pi = 355.0/113.0-1.0/3748629.0;\nconst float phi = 1.61803398875;\nconst float sqrt2 = 1.41421356237;\n\nstruct Ray\n{\n    vec3 p_0;\n    vec3 v;\n    float t_min;\n    float t_max;\n    int level;\n};\nstruct Material\n{\n    vec3 color;\n    float roughness;\n    vec3 emission;\n    float metalness;\n    float ior;\n};\nstruct Trace\n{\n    float t;\n    vec3 n;\n    int material;\n    vec2 tex;\n};\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n};\n\nstruct Triangle\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    int material;\n};\nTrace intersect_triangle(Ray ray, Triangle triangle)\n{\n    vec3 ab = triangle.b - triangle.a;\n    vec3 ac = triangle.c - triangle.a;\n    vec3 ap = ray.p_0 - triangle.a;\n    vec3 f = cross(ray.v,ac);\n    vec3 g = cross(ap,ab);\n    \n    vec3 tuv = vec3(dot(g,ac),dot(f,ap),dot(g,ray.v));\n    tuv /= dot(f,ab);\n    \n    float t = ray.t_max;\n    if(            tuv.x  > 0.0\n        &&     1.0/tuv.y >= 1.0\n        &&     1.0/tuv.z >= 1.0\n        && tuv.y + tuv.z <= 1.0 ) t = tuv.x;\n    \n    vec3 normal = (normalize(cross(ab,ac)));\n    if(dot(normal,ray.v) > 0.0 ) normal *= -1.0;\n           \n    return Trace(t,normal,triangle.material,tuv.yz);\n}\n\nstruct Plane\n{\n    vec3 q_0;\n    vec3 n;\n    int material;\n};\nTrace intersect_plane(Ray ray, Plane plane)\n{\n    float t;\n    if( dot(plane.n,ray.v) == 0.0 ) t = ray.t_max;\n    //plane is parallel to the ray\n    \n    t = dot(plane.n, plane.q_0 - ray.p_0) / dot(plane.n,ray.v);\n    //if t>0 intersection is in front of camera\n    \n    vec3 normal = normalize(plane.n);\n    if(dot(normal,ray.v) > 0.0 ) normal *= -1.0;\n    \n    vec3 p = ray.p_0 + t*ray.v;\n    vec3 g1 = normalize(cross(normal,vec3(1)));\n    if( g1 == vec3(0) ) g1 = cross(normal,vec3(1,0,1));\n    vec3 g2 = normalize(cross(normal,g1));\n    \n    vec2 uv = vec2(dot(p,g1),dot(p,g2));\n    \n    return Trace(t,normal,plane.material,uv);\n}\n\nstruct Sphere\n{\n    vec3 c;\n    float r;\n    int material;\n};\nTrace intersect_sphere(Ray ray, Sphere sphere)\n{\n    vec3 pc = ray.p_0 - sphere.c;\n    \n    float a = dot(ray.v,ray.v);\n    float b = 2.0*dot(ray.v,pc);\n    float c = dot(pc,pc) - sphere.r*sphere.r;\n    \n    float D = b*b - 4.0*a*c;\n    \n    float t;\n    if( D < 0.0  )      t = ray.t_max;\n    else if( D == 0.0 ) t = -b/(2.0*a);\n    else if( D > 0.0  )\n    {\n        float numerator = -b - sqrt(D);\n        if( numerator > 0.0 ) t = numerator/(2.0*a);\n        else t = -(2.0*b + numerator)/(2.0*a);\n    }\n    \n    vec3 p = ray.p_0 + t*ray.v;\n    vec3 normal = normalize(p - sphere.c);\n    if( dot(normal,ray.v) > 0.0) normal *= -1.0;\n    \n    vec2 uv;\n    uv.x = (1.0 + atan(normal.x, normal.z)) / (2.0*pi);\n    uv.y = (1.0 + normal.y) / 2.0;\n    \n    return Trace(t,normal,sphere.material,uv);\n}\n\nstruct Tetrahedron\n{\n    Triangle sides[4];\n};\nTetrahedron construct_tetrahedron(vec3 a, vec3 b, vec3 c, vec3 d, int material)\n{\n    Tetrahedron t;\n    t.sides[0] = Triangle(a,b,c,material);\n    t.sides[1] = Triangle(a,b,d,material);\n    t.sides[2] = Triangle(a,c,d,material);\n    t.sides[3] = Triangle(b,c,d,material);\n    \n    return t;\n}\n\nvec3 get_direction(vec2 frag_coord, float x_fov, vec3 res)\n{    \n    vec2 coord = 2.0*frag_coord/res.xy - 1.0;\n    \n    float x_angle = tan(x_fov/2.0);\n    float y_angle = x_angle * (res.y / res.x);\n    coord = vec2((coord.x)*x_angle, (coord.y)*y_angle);\n    \n    return normalize(vec3(coord,1));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int ray_level = 2;\n\nconst int num_materials = 3;\nMaterial materials[num_materials];\n\nconst int num_planes = 1;\nPlane planes[num_planes];\nconst int num_spheres = 3;\nSphere spheres[num_spheres];\nconst int num_tetrahedrons = 1;\nTetrahedron tetrahedrons[num_tetrahedrons];\n\nconst int num_lights = 2;\nLight lights[num_lights];\n\nTrace raycast(Ray ray)\n{\n    Trace trace = Trace(ray.t_max,vec3(0),0,vec2(0));\n    Trace temp = Trace(ray.t_max,vec3(0),0,vec2(0));\n    for( int i = 0; i < num_planes; ++i )\n    {\n        temp = intersect_plane(ray,planes[i]);\n        if(    temp.t < trace.t\n            && temp.t > ray.t_min\n            && temp.t < ray.t_max ) trace = temp;\n    }\n    for( int i = 0; i < num_spheres; ++i )\n    {\n        temp = intersect_sphere(ray,spheres[i]);\n        if(    temp.t < trace.t\n            && temp.t > ray.t_min\n            && temp.t < ray.t_max ) trace = temp;\n    }\n    for( int i = 0; i < num_tetrahedrons; ++i )\n    {\n        for( int j = 0; j < 4; ++j )\n        {\n            temp = intersect_triangle(ray,tetrahedrons[i].sides[j]);\n            if(    temp.t < trace.t\n                && temp.t > ray.t_min\n                && temp.t < ray.t_max ) trace = temp;\n        }\n    }\n    return trace;\n}\n\n\nvec3 get_texture( vec2 uv )\n{\n    float x = sin(uv.x);\n    float y = cos(uv.y);\n    return vec3(x*x+y*y <= 1.0);\n}\nvec3 shade(Light light, Trace trace, Ray ray)\n{\n    Material material = materials[trace.material];\n    if( material.color == vec3(-1) )\n        return get_texture( trace.tex );\n\n    vec3 point = ray.p_0 + trace.t*ray.v;\n    vec3 direction = normalize(light.position - point);\n    float m = dot(trace.n,direction);\n       \n    vec3 diffuse = light.color / material.roughness * m;\n    diffuse += material.color * material.emission * m;\n    \n    vec3 reflected = reflect(direction,trace.n);\n    m = dot(reflected,ray.v);\n    \n    vec3 specular = vec3(0);\n    if( m > 0.0 ) specular = pow(m,1.0/material.metalness) * light.color;\n    \n    return material.color + diffuse + specular;\n}\nbool in_shadow(Light light, Trace trace, Ray ray)\n{\n    vec3 point = ray.p_0 + trace.t*ray.v;\n    vec3 l = light.position - point;\n    float dist = sqrt(dot(l,l));\n    \n    Ray shadow_ray = Ray(point+trace.n*1e-3,normalize(l),1e-3,1e3,0);\n    Trace shadow_trace = raycast(shadow_ray);\n    \n    if( shadow_trace.t < dist ) return  true;\n    else                        return false;\n}\n\n\nRay stack[STACK_SIZE];\nint stack_size = 0;\nvoid push_stack(Ray ray)\n{\n    stack[stack_size] = ray;\n    ++stack_size;\n}\nvoid pop_stack(int idx)\n{\n    if( idx >= STACK_SIZE || idx < 0 ) return;\n    stack[idx] = stack[stack_size-1];\n    --stack_size;\n}\n\nRay reflect( Trace trace, Ray ray )\n{\n    Material material = materials[trace.material];\n\n    vec3 point = ray.p_0 + trace.t*ray.v;\n    vec3 reflected = reflect(ray.v,trace.n);\n    \n    ray.p_0 = point+trace.n*1e-3;\n    ray.v = reflected;\n    ray.t_min = 1e-3;\n    ray.t_max = 1e3;\n    --ray.level;\n\n    return ray;\n}\nRay refract( Trace trace, Ray ray )\n{\n    Material material = materials[trace.material];\n\n    vec3 point = ray.p_0 + trace.t*ray.v;\n    vec3 refracted = refract(ray.v,trace.n,material.ior);\n    \n    ray.p_0 = point-trace.n*1e-3;\n    ray.v = refracted;\n    ray.t_min = 0.0;\n    ray.t_max = 1e3;\n    --ray.level;\n\n    return ray;\n}\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2);\nconst vec3 EyeStartPosition = vec3(0,1,-5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c0 = vec3(0);\n    vec3 c1 = vec3(2.0*sin(iTime/3.0),0,2.0*cos(iTime/3.0)) + c0;\n    vec3 c2 = vec3(0.5*sin(iTime*3.0),0,0.5*cos(iTime*3.0)) + c1;\n    \n// set material color to vec3(-1) to get texture    \n    materials[0] = Material(vec3(0.5),7.0,vec3(0.3),0.02,10.0);\n    materials[1] = Material(vec3(0,0.75,0.75),2.0,vec3(0.1),0.7,0.0);\n    materials[2] = Material(vec3(0.3,0,0.5),3.0,vec3(0.0),0.6,10.0);\n\n    planes[0] = Plane(vec3(0,-1,0),normalize(vec3(0,1,0)),0);\n    spheres[0] = Sphere(c0,1.0,1);\n    spheres[1] = Sphere(c1,1.0/3.0,2);\n    spheres[2] = Sphere(c2,1.0/9.0,0);\n    tetrahedrons[0] = construct_tetrahedron(15.0*vec3(-1,-1.0/sqrt2, 0),\n                                            15.0*vec3( 1,-1.0/sqrt2, 0),\n                                            15.0*vec3( 0, 1.0/sqrt2,-1),\n                                            15.0*vec3( 0, 1.0/sqrt2, 1),0);\n    \n    lights[0] = Light(vec3(0,5,5),vec3(0.75,1,1));\n    lights[1] = Light(vec3(-3,1,-3),vec3(1,1,0.75));\n\n//fix camera\n    // vec3 camera = vec3(0,0,-5);\n    // float x_fov = pi/phi;\n    // vec3 direction = get_direction(fragCoord,x_fov,iResolution);\n    // Ray ray = Ray(camera,direction,0.0,1e3);\n    \n//moving camera\n    vec3 eye; vec2 data;\n    Ray ray = Camera(fragCoord, eye, data);    \n    Trace trace = raycast(ray);\n    \n    push_stack(ray);\n    \n    vec3 col = vec3(0);\n    while( stack_size > 0 )\n    {\n        ray = stack[0];\n        trace = raycast(ray);\n        Material material = materials[trace.material];\n        \n        pop_stack(0);\n        \n        if( material.metalness >= 0.6\n            && material.roughness <= 3.5\n            && ray.level > 0) push_stack(reflect(trace,ray));\n        if( material.ior <= 1.0\n            && ray.level > 0) push_stack(refract(trace,ray));\n        \n        if( trace.t < ray.t_max )\n        {               \n            for( int i = 0; i < num_lights; ++i )\n            {\n                vec3 c = shade(lights[i],trace,ray);\n                if( in_shadow(lights[i],trace,ray) ) c *= 0.2;\n                c *= pow(0.9,float(ray_level-ray.level));\n                \n                col += c;\n            }\n            col /= float(num_lights);\n        }\n     }\n\n    fragColor = vec4(col,1.0);\n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}\n\n\n\n//the parts below are taken from the practice materials\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               normalize(w+px.x*u+px.y*v),\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               500.,\t\t\t\t\t\t//maxT\n               ray_level);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}