{"ver":"0.1","info":{"id":"43cGz2","date":"1716733459","viewed":76,"name":"number renderer!","username":"Calcilore","description":"it currently only supports up to base 10, but that's only because i only made the digits for up to base 10","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","numbers","font","digits","counting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// go to line 234 to change the number (iTime means time in seconds)\n// and go to line 235 to change the base you count in\n// you can only go up to base 10, later bases work but the digits\n// will be blank because i only have 0-9\n// \n// if you want to make new digits just add a new function next\n// to the others, then build the digit using the three \n// shape check funcitons:\n//\n// line(PASS_POS, offset_point_a, offset_point_b, PASS_SCALE)\n//     creates a line from point A to point B\n// \n// cir(PASS_POS, offset, radius, PASS_SCALE)\n//     creates a hollow circle from the center point (offset)\n//     and with a radius of radius\n// \n// arc(PASS_POS, offset, radius, start, end, PASS_SCALE)\n//     creates an arc from the center point (offset)\n//     with radius of radius and starting from start and going\n//     to end, start and end are in radians\n//     (0 being no rotation, TAU being 1 rotation)\n//     and rotation must not be negative\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = PI*2.0;\n\nvec2 uv;\n\n// |------------------|\n// |       Util       |\n// |------------------|\n\nfloat logx(float x, float n) {\n    float logBaseX = log2(x);\n    return log2(n) / logBaseX;\n}\n\nvec2 angleRadToPoint(float angle, float radius) {\n    return vec2(radius*sin(PI-angle), radius*cos(PI-angle));\n}\n\nbool isInAngle(float start, float end, float angle) {\n    if (start < end) { // normal\n        return angle < start || angle > end;\n    }\n    \n    // passes through 0 point, invert?\n    return angle < start && angle > end;\n}\n\n// |----------------------|\n// |  Distance Functions  |\n// |----------------------|\n\nfloat distanceSquared(vec2 a, vec2 b) {\n    vec2 disVec = a-b;\n    return disVec.x*disVec.x + disVec.y*disVec.y;\n}\n\n// i don't understand this code\nfloat distanceToLineSqr(vec2 a, vec2 b, vec2 pos) {\n    float lengthSqr = distanceSquared(a, b);\n    \n    // if a and b are the same\n    if (lengthSqr == 0.0) return distance(a, pos);\n    \n    // (i didn't write this comment)\n    // Consider the line extending the segment, parameterized as a + t (b - a).\n    // We find projection of point p onto the line. \n    // It falls where t = [(pos-a) . (b-a)] / |b-a|^2\n    // We clamp t from [0,1] to handle points outside the segment ab.\n    float t = clamp(dot(pos - a, b - a) / lengthSqr, 0.0, 1.0);\n    vec2 projection = a + t * (b - a);  // Projection falls on the segment\n    return distanceSquared(pos, projection);\n}\n\nfloat distanceToCircle(vec2 center, float radius, vec2 pos) {\n    float dis = distance(center, pos);\n    return abs(dis-radius);\n}\n\n// i do understand this code\nfloat distanceToArc(vec2 center, float radius, float start, float end, vec2 pos) {\n    // get angle to point from center\n    vec2 sub = pos - center;\n    float angle = PI-atan(sub.x, sub.y); // 0-TAU clockwise\n    \n    // if outside of arc bounds, get distance from closest end\n    // this gives the arc rounded edges\n    if (isInAngle(start, end, angle)) {\n        vec2 startPos = center + angleRadToPoint(start, radius);\n        vec2 endPos = center + angleRadToPoint(end, radius);\n    \n        float dis = min(distanceSquared(startPos, pos),\n            distanceSquared(endPos, pos));\n        return sqrt(dis);\n    }\n    \n    // this is the actual arc\n    return distanceToCircle(center, radius, pos);\n}\n\n// |-----------------------|\n// |  Inside Shape Checks  |\n// |-----------------------|\n\nbool line(vec2 origin, vec2 a, vec2 b, float scale) {\n    return distanceToLineSqr(origin+a*scale, origin+b*scale, uv) \n        < pow(0.01*scale, 2.0);\n}\n\nbool cir(vec2 origin, vec2 center, float radius, float scale) {\n    return distanceToCircle(origin+center*scale, radius*scale, uv) < 0.01*scale;\n}\n\nbool arc(vec2 origin, vec2 center, float radius, float start, float end, float scale) {\n    return distanceToArc(origin+center*scale, radius*scale, start, end, uv) < 0.01*scale;\n}\n\n// |---------------------------------------------------|\n// |  The digits, made up of lines, circles, and arcs  |\n// |---------------------------------------------------|\n\nbool zero(vec2 pos, float scale) {\n    const float offsetF = 0.05;\n    const vec2 offset = vec2(0.0, offsetF);\n    \n    // top arc, bottom arc, left wall, right wall\n    return arc(pos, -offset, 0.05, TAU*0.75, TAU*0.25, scale) ||\n        arc(pos, +offset, 0.05, TAU*0.25, TAU*0.75, scale) ||\n        line(pos, vec2(-offsetF, -offsetF), vec2(-offsetF, offsetF), scale) ||\n        line(pos, vec2(offsetF, -offsetF), vec2(offsetF, offsetF), scale);\n}\n\nbool one(vec2 pos, float scale) {\n    const vec2 offset = vec2(0.0, 0.1);\n    const vec2 topTip = (-offset)+vec2(-0.05, 0.05);\n    const vec2 bottom = vec2(0.05, 0.0);\n    \n    // stick, top bit, base\n    return line(pos, -offset, offset, scale) ||\n        line(pos, -offset, topTip, scale) ||\n        line(pos, offset-bottom, offset+bottom, scale);\n}\n\nbool two(vec2 pos, float scale) {\n    // very magic numbers\n    const vec2 offset = vec2(-0.0028, -0.05);\n    const float radius = 0.0535;\n\n    // top bit, stick, base\n    return arc(pos, offset, radius, TAU*0.83, TAU*0.35, scale) || \n        line(pos, offset+angleRadToPoint(TAU*0.35, radius), vec2(-0.05, 0.1), scale) ||\n        line(pos, vec2(-0.05, 0.1), vec2(0.05, 0.1), scale);\n}\n\nbool three(vec2 pos, float scale) {\n    const vec2 offsetT = vec2(0.0, -0.05);\n    const vec2 offsetB = offsetT*vec2(1.0, -1.0);\n    const float radius = 0.05;\n    const float outAngle = 0.85;\n    const float inAngle = 0.05;\n\n    // top, bottom\n    return arc(pos, offsetT, radius, TAU*outAngle, PI*(1.0-inAngle), scale) ||\n        arc(pos, -offsetT, radius, PI*inAngle, PI+TAU*(1.0-outAngle), scale);\n}\n\nbool four(vec2 pos, float scale) {\n    const vec2 offsetB = vec2(0.02, 0.1);\n    const vec2 offsetT = vec2(offsetB.x, -offsetB.y);\n    const vec2 leftPoint = vec2(-0.05, 0.05);\n    const vec2 rightPoint = vec2(-leftPoint.x, leftPoint.y);\n    \n    // stick, topleft bit, bottom bit\n    return line(pos, offsetB, offsetT, scale) ||\n        line(pos, offsetT, leftPoint, scale) ||\n        line(pos, leftPoint, rightPoint, scale);\n}\n\n\n// i should have used more constants\nbool five(vec2 pos, float scale) {\n    const float radius = 0.06;\n    \n    // top part, left part, arc\n    return line(pos, vec2(0.05, -0.1), vec2(-0.05, -0.1), scale) ||\n        line(pos, vec2(-0.05, -0.1), vec2(-0.05, -0.01), scale) ||\n        arc(pos, vec2(-0.01, 0.04), radius, PI+TAU*(1.0-0.615), TAU*0.615, scale);\n}\n\nbool six(vec2 pos, float scale) {\n    // top, stick, bottom\n    return arc(pos, vec2(0.0, -0.05), 0.05, TAU*0.75, TAU*0.125, scale) ||\n        line(pos, vec2(-0.05, -0.05), vec2(-0.05, 0.05), scale) ||\n        cir(pos, -vec2(0.0, -0.05), 0.05, scale);\n}\n\nbool seven(vec2 pos, float scale) {\n    // top, stick\n    return line(pos, vec2(0.05, -0.1), vec2(-0.05, -0.1), scale) ||\n        line(pos, vec2(0.05, -0.1), vec2(-0.05, 0.1), scale);\n}\n\nbool eight(vec2 pos, float scale) {\n    return cir(pos, vec2(0.0, -0.05), 0.05, scale) ||\n        cir(pos, vec2(0.0, 0.05), 0.05, scale);\n}\n\nbool nine(vec2 pos, float scale) {\n    return arc(pos, vec2(0.0, 0.05), 0.05, TAU*0.25, TAU*(0.75-0.125), scale) ||\n        line(pos, vec2(0.05, -0.05), vec2(0.05, 0.05), scale) ||\n        cir(pos, -vec2(0.0, 0.05), 0.05, scale);\n}\n\n// |-----------------------------------------------------------|\n// |  Here we calculate the digits and draw the correct digit  |\n// |-----------------------------------------------------------|\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // pixel coordinates: -0.5y is top +0.5 is bottom\n    // if square: 0.0x is left, +1.0x is right\n    // if not square right of screen is determined by aspect\n    // ratio, but y stays the same.\n    uv = (fragCoord - iResolution.xy / 2.0)/iResolution.y;\n    uv.y = -uv.y; // make +y down (my brain cant handle +y being up)\n    float width = iResolution.x/iResolution.y;\n    uv.x += width/2.0;\n    \n    // default background color\n    vec3 col = vec3(0.1);\n    \n    // number to render\n    float number = iTime;\n    float base = 10.0;\n    \n    // how many digits are in this number\n    int digits = int(logx(base, float(number)))+1;\n    \n    // which digit this pixel is rendering\n    float digitSize = width/float(digits+2);\n    int digitIndex = digits-1 - int(uv.x/digitSize);\n\n    // the value of the digit being rendered\n    // decimal digits dont round down properly\n    // so i add 0.0001 to them, it fixes the rounding issues\n    float digitF = number / pow(base, float(digitIndex));\n    int digit = int(digitIndex < 0 ? (digitF+0.0001) : digitF);\n    digit = digit % int(base);\n    \n    // draw the digit\n    vec2 drawPos = vec2(digitSize*(float(digits-digitIndex)-0.5), 0.0);\n    float scale = min(digitSize*4.0, 4.0);\n    \n    // decimal point\n    if (digitIndex == 0 && distance(uv, drawPos+vec2(0.11, 0.1)*scale) < 0.0125*scale) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    // draw the correct digit\n    bool on = false;\n    switch (digit) {\n        case 0: on = zero(drawPos, scale); break;\n        case 1: on = one(drawPos, scale); break;\n        case 2: on = two(drawPos, scale); break;\n        case 3: on = three(drawPos, scale); break;\n        case 4: on = four(drawPos, scale); break;\n        case 5: on = five(drawPos, scale); break;\n        case 6: on = six(drawPos, scale); break;\n        case 7: on = seven(drawPos, scale); break;\n        case 8: on = eight(drawPos, scale); break;\n        case 9: on = nine(drawPos, scale); break;\n    }\n    \n    if (on) {\n        col = vec3(1.0);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}