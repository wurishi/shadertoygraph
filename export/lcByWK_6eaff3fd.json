{"ver":"0.1","info":{"id":"lcByWK","date":"1723055551","viewed":30,"name":"Lines, circles, Bezier curve","username":"dsd","description":"Quadratic Bezier curve","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["line","interpolation","cyrcle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float asr = 16./9.;\n\nvec2 nuv;\nvec3 col;\n\nvec2 nx(vec2 v) {\n    return vec2(v.x*asr, v.y);\n}\n\nfloat dot2(vec2 v) {\n    return dot(v, v);\n}\n\nvoid smst(float edge, float x, vec3 x_col) {\n    float delt = fwidth(edge);\n    float alph = smoothstep(edge - delt, edge + delt, x);\n    col = mix(col, x_col, alph);\n }\n\nvoid draw_circ(vec2 c, float r, vec3 c_col) {\n    smst(length(nuv - c), r, c_col);\n}\n\nvoid draw_line(vec2 p1, vec2 p2, float thick, vec3 l_col) {\n    vec2 nup = nuv - p1, pp = p2 - p1;\n    float t = dot(nup, pp)/dot2(pp);\n    vec2 o = p1 + pp*clamp(t, 0., 1.);\n    smst(length(nuv - o), thick/2., l_col);\n}\n\nvec2 i_point(vec2 p1, vec2 p2, float t) {\n    return p1 + (p2 - p1)*t;\n}\n\n//slightly modified function from https://iquilezles.org/articles/distfunctions2d/ \"Quadratic Bezier - exact\"\nvoid draw_curve(vec2 p1, vec2 p2, vec2 p3, float thick, vec3 l_col) {\n    vec2\n        a = p2 - p1,\n        b = p3 - p2 - a,\n        c = 2.*a,\n        d = p1 - nuv;\n        \n    float\n        kk = 1.0/dot2(b),\n        kx = kk * dot(a,b),\n        ky = kk * (2.*dot2(a)+dot(d,b))/3.,\n        p = ky - kx*kx,\n        q = kx*(2.*kx*kx-3.*ky) + kk*dot(d,a),\n        h = q*q + 4.*p*p*p;\n        \n    float res;\n    if( h >= 0.) {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        float t = clamp(uv.x+uv.y-kx, 0., 1.);\n        res = dot2(d + (c + b*t)*t);\n    }\n    else {\n        float\n            z = sqrt(-p),\n            v = acos(q/(p*z*2.))/3.,\n            m = cos(v),\n            n = sin(v)*1.732050808;\n            \n        vec2 t = clamp(vec2(m+m,-n-m)*z-kx, 0., 1.);\n        \n        res = min(dot2(d + (c + b*t.x)*t.x),\n                  dot2(d + (c + b*t.y)*t.y));\n    }\n    smst(sqrt(res), thick/2., l_col);\n}\n\nvoid mainImage( out vec4 Col, in vec2 Crd )\n{\n\n    vec2 uv = Crd/iResolution.xy;\n    nuv = nx(uv);\n\n    col = vec3(uv.x);\n    \n    float r_big = .02;\n    vec3 p_big_col = vec3(1., 0., 1.);\n    \n    vec2 c1;\n    if (iMouse.xy == vec2(0)) c1 = vec2(.1, .9);\n    else c1 = iMouse.xy/iResolution.xy;\n    c1 = nx(c1);\n    vec2 c2 = vec2(.7);\n    c2 = nx(c2);\n    vec2 c3 = vec2(.3);\n    c3 = nx(c3);\n    \n    float t = (cos(iTime/2.) + 1.)/2.;\n    vec3 p_smal_col = vec3(1., 1., 0.);\n    float r_smal = .01;\n    \n    vec2 cs1 = i_point(c3, c1, t);\n    vec2 cs2 = i_point(c1, c2, t);\n    vec2 cs3 = i_point(cs1, cs2, t);\n    \n    vec3 cur_col = vec3(0., 1., 0.);\n    float c_thick = 0.012;\n    \n    vec3 ln_col = vec3(.8, .8, 0.);\n    float l_thick = 0.004;\n    \n    //draw_line(c3, c2, c_thick, cur_col);\n    \n    draw_line(c3, c1, l_thick, ln_col);\n    draw_line(c1, c2, l_thick, ln_col);\n    \n    draw_circ(c1, r_big, p_big_col);\n    draw_circ(c2, r_big, p_big_col);\n    draw_circ(c3, r_big, p_big_col);\n     \n    draw_line(cs1, cs2, l_thick, ln_col);\n    \n    draw_circ(cs1, r_smal, p_smal_col);\n    draw_circ(cs2, r_smal, p_smal_col);\n    draw_circ(cs3, r_big, cur_col);\n\n    draw_curve(c3, c1, c2, c_thick, cur_col);\n    \n    Col = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}