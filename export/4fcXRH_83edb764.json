{"ver":"0.1","info":{"id":"4fcXRH","date":"1713543686","viewed":68,"name":"Add vs Screen + Noise","username":"Nanerbeet","description":"Forked from Add vs Screen, added a little bit of noise to help with the banding.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["example","screen","blendmode"],"hasliked":0,"parentid":"4c3SRH","parentname":"Add vs Screen"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Add vs Screen\" by @XorDev\n    \n    Comparing Additive blending with screen blending.\n    Additive blending is just when you add color \"A\" to color \"B\": A+B\n    This is fine when the sum of the colors is less than 1, but when you\n    adding bright colors, you may notice nasty over exposure and color changes.\n    For example: vec3(1,0,0) + vec3(0,1,0) looks the same as vec3(1,1,0) + vec3(0,1,0)\n    \n    The simple fix here is to use screen blending: \n    https://en.wikipedia.org/wiki/Blend_modes#Screen\n    \n    The concept is to invert both colors, multiply them and then invert the results:\n    1 - (1-A) * (1-B)\n    This can be simplified to:\n    A + B - A * B\n    \n    \n    This means the total of each color channel smoothly approaches full-brightness, \n    and won't start clipping as soon as it add up to 1.\n    For example if A and B are both 0.5, you get an output of 0.5+0.5-0.25 or 0.75\n    \n    Note: If you're dealing with floating-point colors, it's better to use tonemapping:\n    shadertoy.com/view/ddVfzd\n    This technique is primarily for blending standard 8-bit, unorm textures.\n*/\n\n//Blend mode (0==Additive, 1==Screen)\n#define SCREEN int(iTime)&1\n#define NOISE_LEVEL 5.0\n\nfloat hash13(vec3 p3)\n{\n    //  from DAVE HOSKINS\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Resolution for scaling\n    vec2 res = iResolution.xy;\n\n    //Distance to point \"a\" and \"b\"\n    float la = length(fragCoord-res*vec2(.65,.5)) / res.y;\n    float lb = length(fragCoord-res*vec2(.40,.5)) / res.y;\n\n    \n    //Attenuate light\n    vec3 A = exp(-abs(la-.15) * vec3(4,10,14));\n    vec3 B = exp(-abs(lb-.25) * vec3(10,14,4));\n\n    //Blend additively or with screen blending\n    fragColor = vec4(A+B - A*B * float(SCREEN), 1.0);\n    \n    if (fragCoord.y / res.y < 0.5) {\n        // Adding noise at the bottom half of the image to reduce banding\n        fragColor += (hash13(vec3(fragCoord.x, fragCoord.y, iTime)) - 0.5f) * (NOISE_LEVEL / 255.0f);\n    }\n}","name":"Image","description":"","type":"image"}]}