{"ver":"0.1","info":{"id":"dslSDB","date":"1673075602","viewed":270,"name":"SDFVolumeTextureCloud","username":"Mario8664","description":"SDF Volume Texture form https://www.shadertoy.com/view/ddXSzX\nRender it as cloud.\n#define CLOUD in \"common\", or render it as a solid.\nControl camera using mouse and \"W\"\"S\" keys.\nPress \"Up\" to see the scaled shape.\nPress \"R\" to regenerate the texture.","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","volume","sdf","cloud","voxel"],"hasliked":0,"parentid":"ddXSzX","parentname":"SDFVolumeTexture(Voxelize)"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//voxelize texture from https://www.shadertoy.com/view/ddXSzX\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col;\n#ifdef DEBUG\n    fragColor = texture(iChannel0, uv);\n    return;\n#endif\n#ifdef CLOUD\n    #ifdef DITHER\n        //col = texture(iChannel0, uv / DOWNSCALE);\n        \n        uv /= DOWNSCALE;\n        vec2 os = vec2(0.0, 1.0);\n        vec2 o = vec2(1.0) / iResolution.xy;\n\n        vec4 c0 = texture(iChannel0, uv + o * os.xx);\n        vec4 c1 = texture(iChannel0, uv + o * os.xy);\n        vec4 c2 = texture(iChannel0, uv + o * os.yx);\n        vec4 c3 = texture(iChannel0, uv + o * os.yy);\n        col = (c0 + c1 + c2 + c3)*0.25;\n        //col.rgb = max(c0, max(c1, max(c2, c3))).rgb;\n        //col.a = min(c0, min(c1, min(c2, c3))).a;\n    \n        // Normalized pixel coordinates (from 0 to 1)\n        uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n        //Camera(the same as Buffer D)\n        vec2 m = texture(iChannel1, vec2(0.375)).xy;//Camera input\n        vec3 target = vec3(0.0, 0.0, 0.0);//Camera view target\n        float theta = m.x * 2.0 * PI;//Input to y-axis angle(0 ~ 2PI)\n        float fai = -(m.y - 0.5) * 0.8 * PI;//Input to local x-axis angle(-0.4Pi ~ 0.4PI)\n\n        //rotation vector(unit vector)\n        vec3 rotation = vec3(cos(theta), sin(fai) ,sin(theta));\n        rotation.xz *= cos(fai);\n\n        float dd = DISTANCE * texture(iChannel1, vec2(0.75)).x;\n        vec3 cameraPos = rotation * dd;\n        vec3 cameraForward = normalize(target - rotation);\n        vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n        vec3 cameraUp = cross(cameraRight, cameraForward);\n\n        vec3 ro = cameraPos;\n        vec3 rd = cameraForward * 2.0 + uv.x * cameraRight + uv.y * cameraUp;\n        rd = normalize(rd);\n\n        vec3 sb = skyBox(rd);\n    \n        col.rgb = sb * col.a + col.rgb;\n    #else\n        col = texture(iChannel0, uv);\n    #endif\n#else\n    col = texture(iChannel0, uv);\n#endif\n    // Output to screen\n    fragColor = col;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MOUSE_LERP 5.0\n#define MOUSE_STEP 0.5\n#define INIT vec2(0.6, 0.2)\n\n#define INITDISTANCE 0.2\n#define MINDISTANCE 0.01\n#define MAXDISTANCE 0.5\n#define ZOOM_LERP 5.0\n#define ZOOM_STEP 0.001\n\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_S 83\n#define KEY_R 82\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n//#define DEBUG\n#define CLOUD\n#define DITHER\n\n#define DISTANCE 10.0\n#define PI 3.1415926535897932384626\n#define LIGHT vec3(-1.0, 2.0, -1.0)\n#define SUNSIZE 0.01\n#define DOWNSCALE 2.0\n\nfloat hash(float x)\n{\n    x = 123.0 * fract(x * 67.0 + 0.1276795);\n    return fract(x*x);\n}\n\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash3d(vec3 p)\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 i = floor(pos);\n    vec3 f = fract(pos);\n    \n    vec3 u = f*f*(3.0-2.0*f);\n    \n    vec3 v0 = hash3d(i);\n    vec3 v1 = hash3d(i + vec3(1.0, 0.0, 0.0));\n    vec3 v2 = hash3d(i + vec3(0.0, 1.0, 0.0));\n    vec3 v3 = hash3d(i + vec3(1.0, 1.0, 0.0));\n    vec3 v4 = hash3d(i + vec3(0.0, 0.0, 1.0));\n    vec3 v5 = hash3d(i + vec3(1.0, 0.0, 1.0));\n    vec3 v6 = hash3d(i + vec3(0.0, 1.0, 1.0));\n    vec3 v7 = hash3d(i + vec3(1.0, 1.0, 1.0));\n    \n    float c0 = dot(v0, f);\n    float c1 = dot(v1, f - vec3(1.0, 0.0, 0.0));\n    float c2 = dot(v2, f - vec3(0.0, 1.0, 0.0));\n    float c3 = dot(v3, f - vec3(1.0, 1.0, 0.0));\n    float c4 = dot(v4, f - vec3(0.0, 0.0, 1.0));\n    float c5 = dot(v5, f - vec3(1.0, 0.0, 1.0));\n    float c6 = dot(v6, f - vec3(0.0, 1.0, 1.0));\n    float c7 = dot(v7, f - vec3(1.0, 1.0, 1.0));\n    \n    float lerpX0 = mix(c0, c1, u.x);\n    float lerpX1 = mix(c2, c3, u.x); \n    float lerpX2 = mix(c4, c5, u.x);\n    float lerpX3 = mix(c6, c7, u.x);\n    \n    float lerpY0 = mix(lerpX0, lerpX1, u.y);\n    float lerpY1 = mix(lerpX2, lerpX3, u.y);\n    \n    return mix(lerpY0, lerpY1, u.z);\n}\n\n//3d\nvoid Get3DInfo(in vec2 fragCoord, in vec2 resolution, out vec3 uvw, out ivec3 fragCoord3D, out int size)\n{\n    size = int(floor(pow(resolution.x * resolution.y, 1.0 / 3.0)));\n    ivec2 iFragCoord = ivec2(floor(fragCoord));\n    ivec2 iResolution = ivec2(floor(resolution));\n    \n    int size2D = size * size;\n    int pixelID = iFragCoord.x + iFragCoord.y * iResolution.x;\n    int tileID = pixelID / size2D;\n    int inTileID = pixelID % size2D;\n    fragCoord3D = ivec3(inTileID % size, inTileID / size, tileID);\n    uvw = vec3(fragCoord3D) / float(size);\n}\n\nvec4 texelFetch3D(in ivec3 fragCoord3D,in sampler2D tex,in int size,in ivec2 resolution)\n{\n    fragCoord3D = clamp(fragCoord3D, 0, size);\n    int size2D = size * size;\n    int pixelID = fragCoord3D.z * size2D + fragCoord3D.y * size + fragCoord3D.x;\n    ivec2 pixelID2D = ivec2(pixelID % resolution.x, pixelID / resolution.x);\n    return texelFetch(tex, pixelID2D, 0);\n}\n\n\nvec4 texelFetch3DWhiteBoard(in ivec3 fragCoord3D,in sampler2D tex,in int size,in ivec2 resolution)\n{\n    if(fragCoord3D.x >= size || fragCoord3D.y >= size || fragCoord3D.z >= size ||\n    fragCoord3D.x < 0 || fragCoord3D.y < 0 || fragCoord3D.z < 0)\n    {\n        return vec4(0.0);\n    }\n    int size2D = size * size;\n    int pixelID = fragCoord3D.z * size2D + fragCoord3D.y * size + fragCoord3D.x;\n    ivec2 pixelID2D = ivec2(pixelID % resolution.x, pixelID / resolution.x);\n    return texelFetch(tex, pixelID2D, 0);\n}\n\nvec4 texelFetchSmooth3D(in vec3 fragCoord,in sampler2D tex,in int size,in ivec2 resolution)\n{    \n    //vec4 c = texelFetch3D(fragCoord3D, tex, size, resolution);\n    \n    vec3 uv = fragCoord;\n    vec2 bias = vec2(0.5, -0.5);\n    \n    ivec3 id000 = ivec3(floor((uv + bias.yyy)));\n    ivec3 id001 = ivec3(floor((uv + bias.yyx)));\n    ivec3 id010 = ivec3(floor((uv + bias.yxy)));\n    ivec3 id011 = ivec3(floor((uv + bias.yxx)));\n    ivec3 id100 = ivec3(floor((uv + bias.xyy)));\n    ivec3 id101 = ivec3(floor((uv + bias.xyx)));\n    ivec3 id110 = ivec3(floor((uv + bias.xxy)));\n    ivec3 id111 = ivec3(floor((uv + bias.xxx)));\n    \n    vec4 c000 = texelFetch3D(id000, tex, size, resolution);\n    vec4 c001 = texelFetch3D(id001, tex, size, resolution);\n    vec4 c010 = texelFetch3D(id010, tex, size, resolution);\n    vec4 c011 = texelFetch3D(id011, tex, size, resolution);\n    vec4 c100 = texelFetch3D(id100, tex, size, resolution);\n    vec4 c101 = texelFetch3D(id101, tex, size, resolution);\n    vec4 c110 = texelFetch3D(id110, tex, size, resolution);\n    vec4 c111 = texelFetch3D(id111, tex, size, resolution);\n    \n    vec3 center000 = floor(uv + bias.yyy) + 0.5;\n    vec3 samplePos = uv - center000;\n    \n    vec4 c00 = mix(c000, c001, samplePos.z);\n    vec4 c01 = mix(c010, c011, samplePos.z);\n    vec4 c10 = mix(c100, c101, samplePos.z);\n    vec4 c11 = mix(c110, c111, samplePos.z);\n    \n    vec4 c0 = mix(c00, c01, samplePos.y);\n    vec4 c1 = mix(c10, c11, samplePos.y);\n    \n    vec4 c = mix(c0, c1, samplePos.x);\n    \n    return c;\n}\n\n\nvec3 skyBox(vec3 rd)\n{\n    //return texture(iChannel0, rd).xyz;\n    vec3 sky = mix(vec3(1.2), vec3(0.7, 0.8, 1.0), smoothstep(-0.3, 0.7, rd.y));\n    vec3 land = mix(vec3(0.0), vec3(0.2, 0.2, 0.3), smoothstep(-0.9, 0.3, rd.y));\n    vec3 skybox = mix(land, sky, smoothstep(-0.05, 0.1, rd.y));\n    \n    float sun = dot(rd, normalize(LIGHT));\n    sun = (sun - 1.0 + SUNSIZE) / SUNSIZE;\n    sun = clamp(sun, 0.0, 1.0);\n    sun = pow(sun, 5.0);\n    \n    return skybox + sun;\n    //return ceil(rd * 10.0) / 10.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat solid(vec3 uvw)\n{\n    mat3 rot = mat3( 0.00,  0.80,  0.60,\n                -0.80,  0.36, -0.48,\n                -0.60, -0.48,  0.64 );\n    float scale = 3.0;\n    float n = noise(scale * uvw) * 0.5 - 0.16;uvw = rot * uvw * 2.0;\n    n += noise(scale * uvw) * 0.25 - 0.05;uvw = rot * uvw * 2.0;\n    n += noise(scale * uvw) * 0.125 - 0.01;uvw = rot * uvw * 2.03;\n    n += noise(scale * uvw) * 0.0625;\n    return ceil(n+ 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0 || texelFetch(iChannel1, ivec2(KEY_R,1), 0).r > 0.5)\n    {\n         vec3 uvw;\n         ivec3 fragCoord3D;\n         int size;\n         Get3DInfo(fragCoord, iResolution.xy, uvw, fragCoord3D, size);\n    \n         float s = solid(uvw);\n    \n         fragColor = vec4(s, s, s, 1.0);\n    }\n    else\n    {\n         vec2 uv = fragCoord / iResolution.xy;\n         fragColor = texture(iChannel0, uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//distance transform\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uvw;\n    ivec3 fragCoord3D;\n    int size;\n    Get3DInfo(fragCoord, iResolution.xy, uvw, fragCoord3D, size);\n    \n    ivec3 ios = ivec3(-1, 1, 0);\n    vec3 os = vec3(-1.0, 1.0, 0.0);\n    float unit = 1.0 / float(size);\n    \n    if(iFrame == 0 || texelFetch(iChannel2, ivec2(KEY_R,1), 0).r > 0.5)\n    {\n        float c = texelFetch3D(fragCoord3D, iChannel0, size, ivec2(iResolution.xy)).r;\n        fragColor = vec4(c);\n        return;\n    }\n    \n    vec4 cn = texelFetch3D(fragCoord3D, iChannel1, size, ivec2(iResolution.xy));\n    \n    //if(iFrame > size * size)\n    //{\n    //    fragColor = cn;\n    //    return;\n    //}\n    \n    vec3 c0 = texelFetch3DWhiteBoard(fragCoord3D + ios.xzz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.xzz;\n    vec3 c1 = texelFetch3DWhiteBoard(fragCoord3D + ios.yzz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.yzz;\n    vec3 c2 = texelFetch3DWhiteBoard(fragCoord3D + ios.zxz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zxz;\n    vec3 c3 = texelFetch3DWhiteBoard(fragCoord3D + ios.zyz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zyz;\n    vec3 c4 = texelFetch3DWhiteBoard(fragCoord3D + ios.zzx, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zzx;\n    vec3 c5 = texelFetch3DWhiteBoard(fragCoord3D + ios.zzy, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zzy;\n\n    float cc0 = dot(c0, c0);\n    float cc1 = dot(c1, c1);\n    float cc2 = dot(c2, c2);\n    float cc3 = dot(c3, c3);\n    float cc4 = dot(c4, c4);\n    float cc5 = dot(c5, c5);\n    \n    vec3 c = c0;\n    float cc = cc0;\n    if(cc1 < cc)\n    {\n        c = c1;\n        cc = cc1;\n    }\n    if(cc2 < cc)\n    {\n        c = c2;\n        cc = cc2;\n    }\n    if(cc3 < cc)\n    {\n        c = c3;\n        cc = cc3;\n    }\n    if(cc4 < cc)\n    {\n        c = c4;\n        cc = cc4;\n    }\n    if(cc5 < cc)\n    {\n        c = c5;\n        cc = cc5;\n    }\n    \n    cc = sqrt(cc);\n    \n    if(cc < cn.a)\n    {\n        fragColor = vec4(c, cc);\n    }\n    else\n    {\n        fragColor = vec4(cn);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 i, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 lastil = texture(iChannel0, vec2(0.125));\n    \n    if(uv.x < 0.25)\n    {\n        i = vec4(0.0);\n        vec2 m = i.xy = iMouse.xy / iResolution.xy;\n        if(iMouse.w > 0.5 || iFrame == 0)\n        {\n            lastil.xy = m;\n        }\n        i.xy = m;\n        vec2 offset = (m - lastil.xy) * MOUSE_STEP;\n        i.zw = mix(lastil.zw, offset, MOUSE_LERP * iTimeDelta);\n    }\n    else if(uv.x < 0.5)\n    {\n        if(iFrame == 0)\n        {\n            i = vec4(INIT, 0.0, 0.0);\n        }\n        else\n        {\n            i = texture(iChannel0, vec2(0.375));\n            i.xy += lastil.zw;\n            i.x = fract(i.x);\n            i.y = clamp(i.y, 0.0, 1.0);\n        }\n    }\n    else\n    {\n        if(iFrame == 0)\n        {\n            i = vec4(INITDISTANCE, 0.0, 0.0, 0.5);\n        }\n        else\n        {\n            float wsInput = texelFetch(iChannel1, ivec2(KEY_W,0), 0).r - texelFetch(iChannel1, ivec2(KEY_S,0), 0).r;\n            wsInput = wsInput * 0.5 + 0.5;\n            i = texture(iChannel0, vec2(0.75));\n            i.w = mix(i.w, wsInput, ZOOM_LERP * iTimeDelta);\n            i.x -= (i.w * 2.0 - 1.0) * ZOOM_STEP;\n            i.x = clamp(i.x, MINDISTANCE, MAXDISTANCE);\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define FRESNEL 2.0\n#define AOSTEP 0.1\n#define ABSORTIONINSIDECLOUD 4.0\n#define ABSORTION 18.0\n#define CLOUDMARCH 32\n#define SUBMARCH 8\n#define LIGHTSTRENGTH 18.0\n#define AMBIENT vec3(0.3, 0.2, 0.1)\n\n#define SCENEOFFSET 0.000\n\nfloat yyInput = 0.0;\n\nvec2 rayBox(vec3 pos, vec3 boxmin, vec3 boxmax, vec3 rd)\n{\n    vec3 t0 = (boxmin - pos) / rd;\n    vec3 t1 = (boxmax - pos) / rd;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n\n    float d0 = max(tmin.x, max(tmin.y, tmin.z));\n    float d1 = min(tmax.x, min(tmax.y, tmax.z));\n\n    return vec2(d0, d1);\n}\n\n\nfloat getVoxelScene(vec3 pos, float size, float offset)\n{\n    vec3 texelCoord = (pos + 0.5) * size;\n    if(yyInput > 0.5)\n    {\n        offset += (noise(pos * 8.0) + 1.0) * 0.0025;\n        texelCoord *= 0.03;\n        texelCoord += vec3(2.8, 0.9, 1.2);\n    }\n    \n    float d = texelFetchSmooth3D(texelCoord, iChannel0, int(size), ivec2(iResolution.xy)).a;\n    return max(d - offset, 0.0);\n}\n\nfloat sampleCloud(vec3 pos, float size, float offset)\n{\n    float time = iTime * 0.02;\n    pos.z += texture(iChannel3, pos.xy * 4.0 + time).r * 0.01;\n    pos.x += texture(iChannel3, pos.yz * 4.0 + time + 0.33).g * 0.01;\n    pos.y += texture(iChannel3, pos.zx * 4.0 + time + 0.66).b * 0.01;\n    pos.z += texture(iChannel3, pos.xy * 0.5 + time).r * 0.04;\n    pos.x += texture(iChannel3, pos.yz * 0.5 + time + 0.33).g * 0.04;\n    pos.y += texture(iChannel3, pos.zx * 0.5 + time + 0.66).b * 0.04;\n    pos = clamp(pos, -0.5, 0.5);\n    return getVoxelScene(pos, size, offset);\n}\n\n\nfloat rayMarch(in int iter, in vec3 ro, in vec3 rd, in vec2 box, in float size, in float threshold, out float t, out float d)\n{\n    vec3 pos = ro + rd * t;\n    for(int i = 0; i < 32; i++)\n    {\n    \n#ifdef CLOUD\n        d = sampleCloud(pos, size, SCENEOFFSET);\n#else\n        d = getVoxelScene(pos, size, SCENEOFFSET);\n#endif\n        if(t > box.y)\n        {\n            break;\n        }\n        if(d<=(threshold) * t)\n        {\n            return 1.0;\n        }\n        t += d;\n        pos = ro + rd * t;        \n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    yyInput = texelFetch(iChannel2, ivec2(KEY_UP,2), 0).r;\n#ifdef DEBUG\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 uvw;\n    ivec3 fragCoord3D;\n    int size;\n    Get3DInfo(fragCoord, iResolution.xy, uvw, fragCoord3D, size);\n    \n    uv = fragCoord/iResolution.y;\n    float halfVoxel = 0.5 / float(size);\n    float z = 1.0 - fract(iTime * 0.5);\n    if(iMouse.z > 0.5)\n    {\n        z = clamp(iMouse.x / iResolution.x * 2.0 - 0.25, 0.0, 1.0);\n    }\n    \n    uv *= 2.0;\n    uv -= 0.25 + 0.3 * z;\n    vec3 uvslice = vec3(uv, z) - halfVoxel;\n    if(uvslice.x < 0.0 || uvslice.y < 0.0 || uvslice.x > 1.0 || uvslice.y > 1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec4 col = texelFetchSmooth3D(uvslice * float(size), iChannel0, size, ivec2(iResolution.xy));\n    fragColor = col.aaaa;// * float(size);\n#else\n\n    float size = floor(pow(iResolution.x * iResolution.y, 1.0 / 3.0));\n    // Normalized pixel coordinates (from 0 to 1)\n#ifdef CLOUD\n\n#ifdef DITHER\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (-iResolution.xy + 2.0*DOWNSCALE*fragCoord) / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    if(uv.x > (aspect + 0.1) || uv.y > 1.1)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n#else\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n#endif\n#else\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n#endif\n    //Camera\n    vec2 m = texture(iChannel1, vec2(0.375)).xy;//Camera input\n    vec3 target = vec3(0.0, 0.0, 0.0);//Camera view target\n    float theta = m.x * 2.0 * PI;//Input to y-axis angle(0 ~ 2PI)\n    float fai = -(m.y - 0.5) * 0.8 * PI;//Input to local x-axis angle(-0.4Pi ~ 0.4PI)\n\n    //rotation vector(unit vector)\n    vec3 rotation = vec3(cos(theta), sin(fai) ,sin(theta));\n    rotation.xz *= cos(fai);\n    \n    vec4 di = texture(iChannel1, vec2(0.75));\n    float dd = DISTANCE * di.x;\n    vec3 cameraPos = rotation * dd;\n    vec3 cameraForward = normalize(target - rotation);\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n    \n    vec3 ro = cameraPos;\n    vec3 rd = cameraForward * 2.0 + uv.x * cameraRight + uv.y * cameraUp;\n    rd = normalize(rd);\n    \n    vec4 col = vec4(skyBox(rd), 0.0);\n    vec2 box = rayBox(ro, vec3(-0.5), vec3(0.5), rd);\n    float t = max(box.x, 0.0);\n    \n    float d = 0.0;\n    float marched = rayMarch(32, ro, rd, box, size, 0.001, t, d);\n    vec3 pos = ro + rd * t; \n    if(marched < 0.5)\n    {\n        marched = rayMarch(16, ro, rd, box, size, 0.01, t, d);\n        pos = ro + rd * t;\n    }\n    if(marched < 0.5)\n    {\n        marched = rayMarch(8, ro, rd, box, size, 0.1, t, d);\n        pos = ro + rd * t;\n    }\n    \n    vec3 light = normalize(LIGHT);\n    \n#ifdef CLOUD\n#ifdef DITHER\n    col = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\n    if(box.y > box.x)\n    {\n        float t = max(t, 0.0);\n        float tstep = max(box.y - box.x, 0.0) / float(CLOUDMARCH);\n#ifdef DITHER\n        t += hash(vec3(fragCoord.xy, iTime)) * tstep;\n#endif\n        float transmittance = 1.0;\n        vec3 sumLight = vec3(0.0);\n        float sumDensity = 0.0;\n        for(int i = 0; i < CLOUDMARCH; i++)\n        {\n            pos = ro + rd * t;\n            float density = sampleCloud(pos, size, SCENEOFFSET);\n            if(density <= 0.0)\n            {\n                sumDensity += tstep;\n                transmittance = exp(-(sumDensity - tstep * 0.5) * ABSORTION);\n                \n                vec2 box = rayBox(pos, vec3(-0.5), vec3(0.5), light);\n                float stepInside = box.y / float(SUBMARCH);\n                vec3 subPos = pos;\n                \n                float subSumDensity = 0.0;\n                for(int j = 0; j < SUBMARCH; j++)\n                {\n                    float subDensity = sampleCloud(subPos, size, SCENEOFFSET);\n                    if(subDensity <= 0.0)\n                    {\n                        subSumDensity += stepInside;\n                    }\n                    subPos += stepInside * light;\n                }\n                float subTransmittance = exp(-subSumDensity * ABSORTIONINSIDECLOUD);\n                sumLight += tstep * subTransmittance * transmittance * LIGHTSTRENGTH + AMBIENT * tstep;\n                \n                if(transmittance < 0.01)\n                {\n                    break;\n                }\n            }\n            if(t > box.y)\n            {\n                break;\n            }\n            t += tstep;\n        }\n#ifdef DITHER\n        col.rgb = sumLight;\n        col.a = transmittance;\n#else\n        col.rgb = col.rgb * transmittance + vec3(sumLight);\n#endif\n    }\n#else\n    //do lighting\n    col.rgb += pow(max(box.y - box.x, 0.0) / 1.732050807568877, 0.3) * 0.1;//draw a volume\n    vec2 offset = vec2(10.0 / float(size), 0.0);     \n    offset.x = 0.001;\n    float diffuse = 1.0;\n    if(t - box.x < 0.001)\n    {        \n        vec3 man = abs(pos);\n        float maxn = max(man.x, max(man.y, man.z));\n        vec3 normal = sign(pos) * max(man - maxn + 0.001, 0.0);\n        normal = normalize(normal);\n        diffuse = dot(normal, light);\n    }\n    else\n    {\n        vec3 dpos = pos + offset.x * light;\n        dpos = clamp(dpos, -0.5, 0.5);\n        diffuse = (getVoxelScene(dpos, size, SCENEOFFSET) - d) / offset.x;\n    }\n    \n    diffuse = clamp(diffuse, 0.1, 1.0);\n    diffuse = pow(diffuse, 0.5);\n    \n    col.rgb = mix(col.rgb, vec3(diffuse), marched);\n    \n    //col = mix(col, vec3(1.0), clamp(ceil(box.y - t - 0.001), 0.0, 1.0) * marched);\n#endif\n    \n    // Output to screen\n    fragColor = col;\n#endif\n}\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}