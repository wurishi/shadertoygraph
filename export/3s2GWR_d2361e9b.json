{"ver":"0.1","info":{"id":"3s2GWR","date":"1548610796","viewed":186,"name":"Menger sponge Raymarched","username":"Myro","description":"a study on rendering 3D fractals with a basic raymarching renderer (menger sponge)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","color","animated","menger","orange","sponge","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// controls : click and drag to navigate\n\n// base raymarching rendering thing\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\n// raymarching primitives distance functions\n// https://www.shadertoy.com/view/Xds3zN\n\n// fractal by\n// https://iquilezles.org/articles/menger\n\n\n#define MARCHINGITERATIONS 128\n#define SMALLESTSTEP 0.1\n#define MARCHINGSTEP 0.5\n\n#define DISTANCE 3.0\n\n// cosine based palette, 4 vec3 params\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(0.01,0.01,0.01),vec3(0.0,0.10,0.20) );\n}\n\n// distance function for a box\n// input p : - the current path being traced\n// input b : - box vector (width/2, heigth/2, depth/2)\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// distance function for a tri-cross\n// input p : - the current path being traced\nfloat tricross( in vec3 p )\n{\n    // dividing by 0 to have an infinite value\n  \tfloat da = box(p.xyz,vec3(1.0/0.0,1.0,1.0));\n  \tfloat db = box(p.yzx,vec3(1.0,1.0/0.0,1.0));\n  \tfloat dc = box(p.zxy,vec3(1.0,1.0,1.0/0.0));\n  \treturn -min(da,min(db,dc));\n}\n\n// MAPPING FUNCTION ... \n// returns the distance of the nearest object in the direction p on the x coordinate \n// and the color on the y coordinate\nvec2 map( in vec3 p )\n{\n    //p = fract(p); \n   \tfloat d = box(p,vec3(1.0));\n\n   \tfloat s = 1.0;\n    float color=0.0;\n   \t// iterations for the fractal effect\n   \tfor( int m=0; m<3; m++ )\n   \t{\n        // stuff, idk\n\t\tvec3 a = mod( p*s, 2.0 )-1.0;      \n      \t// scaling factor (smaller at each iteration)\n      \ts *= 5.0;\n\t\t// moving the cross \n       \tvec3 r = 1.0 - 4.0 * abs(a) * (1.0+cos(iTime)*0.1);\n        \n        // scaling and moving the cross, does the funky animation part\n        r += vec3(cos(iTime*0.2), -sin(iTime*0.3), sin(iTime*0.5));\n\t\t\n        // scaling the cross\n      \tfloat c = -tricross(r)/s;\n\n\t\tcolor = 0.1;\n      \tif( c>d )\n      \t{\n      \t\td = c;        \n      \t\tcolor += 80.0*c* (float(m));\n      \t}\n    }\n\n   \treturn vec2(d,color);\n}\n\n\n// TRACING A PATH : \n// measuring the distance to the nearest object on the x coordinate\n// and returning the color index on the y coordinate\nvec2 trace  (vec3 origin, vec3 ray) {\n\t\n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    float c = 0.0;\n    \n    for (int i=0; i<MARCHINGITERATIONS; i++) {\n    \tvec3 path = origin + ray * t;\t\n    \tvec2 dist = map(path);\n    \t// we want t to be as large as possible at each step but not too big to induce artifacts\n        t += MARCHINGSTEP * dist.x;\n        c += dist.y;\n        if (dist.y < SMALLESTSTEP) break;\n    }\n    \n    return vec2(t,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    //ray direction (camera is at (0,0,0), view plane is at 0,0,1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    //ROTATING THE CAMERA (rotating the ray)\n    float rotAngle = iTime/3.0 + 6.28*iMouse.x / iResolution.x;\n    //rotation matrix around the y axis\n    ray.xz *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n    \n    //camera position (rays origin)\n    float camDist = DISTANCE * iMouse.y / iResolution.y;\n    vec3 origin = vec3 (camDist * sin(rotAngle),0.0,-camDist *cos(rotAngle));           \n    \n    //tracing the ray (getting the distance of the closest object in the ray direction)\n\tvec2 depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}","name":"Image","description":"","type":"image"}]}