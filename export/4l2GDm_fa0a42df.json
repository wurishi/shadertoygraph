{"ver":"0.1","info":{"id":"4l2GDm","date":"1429692307","viewed":246,"name":"Squircle landscape","username":"pixelzealot","description":"A scrolling landscape filled with every changing squircles and driven by music and some noise. Sun/moon cycle too because.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["landscape","squircle","timeofday"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define DEBUG 1\n\n\nmat2 rotate2D(float angle)\n{\n   \tfloat cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    \n    return mat2(\n        vec2(cosTheta, sinTheta), \n        vec2(-sinTheta, cosTheta));\n}\n\n// Noise shamlessly storen from iq\nfloat noise(vec3 x) \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat fbm(vec2 p)\n{\n\tp += vec2(1.0,0.1) * iTime*0.5;\n    \n    float f;\n    f  = 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\n// Sun\nfloat f(vec2 p, vec2 centre, float radius, float power)\n{\n    vec3 a = vec3(p, radius);\n    vec3 b = vec3(centre, 0.0);\n    return dot(pow(abs(a-b), vec3(power)), vec3(1.0, 1.0, -1.0));\n}\n\nvec2 grad(in vec2 x, vec2 centre, float radius, float power)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy, centre, radius, power) - f(x-h.xy, centre, radius, power),\n                 f(x+h.yx, centre, radius, power) - f(x-h.yx, centre, radius, power) ) / (2.0*h.x);\n}\n\n// Get sound frequency at a particular column at a particular sample in the column\nfloat getFreqOfColumn(float column, float s, float numSamples, vec2 grid)\n{\n    float sampleWidth = 1.0/numSamples;\n    float offset = (s-1.0) / (numSamples-1.0);\n    \n    float samplePos = column + (offset) / grid.x;\n\tsamplePos = mod(samplePos * 0.5, 1.0);\n    return texture(iChannel1, vec2(samplePos, 0.25)).x;\n}\n\nfloat squircle(vec2 uv, vec2 pos, float radius, float power)\n{\n\tfloat v = f(uv, pos, radius, power);\n    vec2  g = grad(uv, pos, radius, power);\n    float de = v / length(g);            \n    return de;\n}\n\nvoid addTC(in vec2 fragCoord, inout vec3 col, out float dayNightMult)\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= aspect;\n        \n    float gridSize = 30.0;\n    vec2 grid = vec2(gridSize, ceil(gridSize / aspect));\n    vec2 coord = floor(uv * grid) / grid;    \n\n    mat2 rotMat = rotate2D(iTime*0.25);\n    \n    vec2 sunPosition = rotMat * vec2(0.75, 0.0);\n    sunPosition += vec2(0.5*aspect, 0.1);\n    float sunMult = 1.0 - clamp(sunPosition.y-0.2, 0.0, 0.5);\n    float sun = squircle(uv, sunPosition, 0.1, 4.0 * sunMult);\n    \n    float sunBloom = squircle(uv, sunPosition, 0.3 * sunMult, 4.0 * sunMult)*2.0;\n    \n    vec3 sunColor = mix(vec3(1.0, 1.0, 0.5)*1.2, vec3(1.0, 0.4, 0.1), sunMult);\n    \n    vec2 moonPosition = rotMat * vec2(-0.75, -0.1);\n    moonPosition += vec2(0.5*aspect, 0.1);\n    \n    float moon0 = squircle(uv, moonPosition, 0.1, 2.0);\n    float moon1 = squircle(uv, moonPosition + vec2(0.08, 0), 0.12, 2.0);\n    float moon = max(moon0, -moon1);\n    vec3 moonColor = vec3(1.0, 1.0, 1.0);\n    \n    dayNightMult = clamp((sunPosition.y + 0.1) / 0.7, 0.0, 1.0);\n        \n    col = mix(vec3(0.01, 0.01, 0.1), col, dayNightMult); // Do sky\n    \n    sunColor = mix(col, sunColor, dayNightMult);\n    \n    col = mix(col, mix(sunColor, col, 0.5), 1.0 - smoothstep(0.0, 1.5/iResolution.x, sunBloom)); // Do sun bloom\n    col = mix(col, sunColor, 1.0 - smoothstep(0.0, 1.5/iResolution.x, sun)); // Do sun\n    \n    col = mix(col, mix(moonColor, col, 0.5), 1.0 - smoothstep(0.01, 0.02, moon)); // Do moon bloom\n    col = mix(col, moonColor, 1.0 - smoothstep(0.0, 1.5/iResolution.x, moon)); // Do moon\n    \n}\n\nvoid terrainLayer(\n    inout vec3 col, \n    in vec2 uv, \n    in float gridSize, \n    in float heightOffset, \n    in float radiusAdjust, \n    in vec2 freqAdjust,\n    in vec4 tintColor,\n    in float dayNightMult)\n{\n    float aspect = (iResolution.x / iResolution.y);\n    \n    vec2 grid = vec2(gridSize, ceil(gridSize / aspect));\n    vec2 coord = floor(uv * grid) / grid;\n    \n    float s0 = max(0.0, freqAdjust.x + getFreqOfColumn(coord.x, 1.0, 5.0, grid) * freqAdjust.y);\n    float s1 = max(0.0, freqAdjust.x + getFreqOfColumn(coord.x, 5.0, 5.0, grid) * freqAdjust.y);\n\n\tfloat n0 = fbm(vec2(coord.x, s0));\n    float n1 = fbm(vec2(coord.x + 1.0/grid.x, s1));\n\n    s0 = s0 + (n0 - 0.5);\n    s1 = s1 + (n1 - 0.5);\n    \n    float xx = abs(uv.x - coord.x) * grid.x;\n    float ySlope = mix(s0, s1, xx);\n    \n    float slopeOffset = (heightOffset+0.1)/grid.y;\n\n    #if 0\n    if (abs(uv.y - (ySlope + slopeOffset)) < 1.0/iResolution.y)\n    {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    float ySlope0 = mix(s0 + (n0 - 0.5), s1 + (n1 - 0.5), xx);\n    \n    if (abs(uv.y - (ySlope0 + slopeOffset)) < 1.0/iResolution.y)\n    {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n\t#endif\n    \n    // The actual line so it all joins nicely\n    if (uv.y < ySlope + slopeOffset)\n    {\n        float colAdjust = (coord.y - 0.0) * 0.75;\n        \n        // The background ground colour\n        col = (vec3(0.584, 0.271, 0.012) - colAdjust);\n        col = mix(col, tintColor.rgb, tintColor.a);\n        col *= mix(vec3(0.4, 0.4, 0.6), vec3(1.0), dayNightMult);\n    }\n    \n    float columnHeight = coord.y + (1.0/grid.y);\n    \n    // Space for a squircle\n\tif (columnHeight < (s0 + slopeOffset) && columnHeight < (s1 + slopeOffset))\n\t{\n        vec2 ab = uv;\n        \n \t\tvec2 c = 1.0 / grid;\n    \tvec2 p = mod(ab, c) - c*0.5;\n        p.y /= aspect;\n        \n        float powerAdjust = max(s0, s1);\n\n        float radius = (0.008 + 0.006 * powerAdjust) * radiusAdjust;\n\t    float power = 1.0 + 3.0 * powerAdjust;\n\n        float de = squircle(p, vec2(0.0), radius, power);\n        \n        float edge = (1.54 / radiusAdjust) / iResolution.x;\n        float darken = smoothstep(0.0, edge, abs(de));\n        \n        float colAdjust = (columnHeight - 0.1) * 0.5;\n        \n        // Inner colour + border\n        vec3 border = (vec3(0.584, 0.271, 0.012)*0.9 - colAdjust) * darken;\n        border = mix(border, tintColor.rgb, tintColor.a);\n\t\tcol = mix(col, border, 1.0 - smoothstep(0.0, edge, de));\n\t}    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec3 col = vec3(0,0,0);\n    float dayNightMult = -1.0;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x + iTime*0.1;\n    \n    float gridSize = 30.0;\n    vec2 grid = vec2(gridSize, ceil(gridSize / aspect));\n    vec2 coord = floor(uv * grid) / grid;\n    \n    // Sky blue\n    col = mix(vec3(0.529, 0.808, 0.98), vec3(0.529, 0.808, 0.98) * 0.6, coord.y);\n    \n\taddTC(fragCoord, col, dayNightMult);\n\n    vec2 uv0 = uv + vec2(iTime * 0.1, 0.0) + vec2(12.34, 0.0);\n    terrainLayer(\n        col, \n        uv0, \n        60.0, \n        12.0, \n        0.5, \n        vec2(0.00, 0.2), \n        vec4(0.0, 0.0, 0.0, 0.4), \n        dayNightMult);\n    \n    vec2 uv1 = uv + vec2(iTime * 0.4, 0.0);\n    terrainLayer(\n        col, \n        uv1, \n        30.0, \n        4.0, \n        1.0, \n        vec2(0.0, 0.77), \n        vec4(1.0, 1.0, 1.0, 0.0), \n        dayNightMult);\n\n    \n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}