{"ver":"0.1","info":{"id":"mtSXD3","date":"1676926434","viewed":92,"name":"PSF Bessel and Noise","username":"Shearpower","description":"Using Dave_Hoskins noise: hash11 and hash13\nhttps://www.shadertoy.com/view/4djSRW\n\nUsing bessel function from FabriceNeyret2:\nhttps://www.shadertoy.com/view/tlc3zM\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","psf","sensor","bessel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/tlc3zM\n// https://www.shadertoy.com/view/4djSRW\n// cf https://www.desmos.com/calculator/b4fa9jsmsq\n\n// https://www.shadertoy.com/view/tlc3zM\n#define S(v) smoothstep(1.5 * fwidth(v), 0.0, abs(v))\n\n// fifth-order polynomial approximation of Turbo based on:\n// https://observablehq.com/@mbostock/turbo\nvec3 turbo(float x) {\n    float r = 0.1357 + x * ( 4.5974 - x * ( 42.3277 - x * ( 130.5887 - x * ( 150.5666 - x * 58.1375 ))));\n\tfloat g = 0.0914 + x * ( 2.1856 + x * ( 4.8052 - x * ( 14.0195 - x * ( 4.2109 + x * 2.7747 ))));\n\tfloat b = 0.1067 + x * ( 12.5925 - x * ( 60.1097 - x * ( 109.0745 - x * ( 88.5066 - x * 26.8183 ))));\n    return vec3(r,g,b);\n}\n\n// First Order Bessel Function\n// https://www.shadertoy.com/view/tlc3zM\n// https://www.sciencedirect.com/science/article/pii/S2211379718300111\nfloat J1(float x)\n{\n    float xx = x * x;\n    float a = 1.0 + 0.12138 * xx;\n    float term0 = sqrt(a) * (46.68634 + 5.82514 * xx) * sin(x);\n    float term1 = -x * (17.83632 + 2.02948 * xx) * cos(x);\n    float denominator = (57.70003 + 17.49211 * xx) * pow(a, 3.0 / 4.0);\n    return (term0 + term1) / denominator;\n}\n\n// Airy Intensity\n// https://www.shadertoy.com/view/tlc3zM\n// https://en.wikipedia.org/wiki/Airy_disk#Mathematical_formulation\nfloat A(float x)\n{\n    float v = 2.0 * J1(x) / x;\n    return v * v;\n}\n\n// Noise\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Not using normalized coordinates except for positioning. Thank you, FabriceNeyret2.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)  // ---------------------------------------------\n{\n    // INPUTS\n    vec2 pos = vec2(100.0, -50.0);\n    float powerScale = 1.0;\n    float sizeScale = 10.0;\n    float plotScale = 150.0;\n    float noiseScale = 0.05;\n    bool plot = true;\n    bool plotBottom = false;\n    bool increasePower = false;\n    bool useTurbo = true;\n\n    // 2D Airy Bessel Function\n    vec2 offset = pos + iResolution.xy / 2.0;\n    float airyBessel = powerScale * A(length(fragCoord.xy - offset) / sizeScale);\n    if (increasePower) {\n        airyBessel = pow(airyBessel, 1.0/2.2);\n    }\n    if (useTurbo) {\n        fragColor = vec4(turbo(airyBessel), 0.0);\n    } else {\n        fragColor = vec4(vec3(airyBessel), 0.0);\n    }\n\n    // Time varying noise\n    float time = mod(iTime, 5000.0); // Prevents long run time patterns in the noise.\n    vec3 noisePos = vec3(fragCoord.xy, time*.3) + time * 500. + 50.0;\n    float noise = noiseScale * hash13(noisePos);\n    if (useTurbo) {\n        fragColor += vec4(turbo(noise), 0.0);\n    } else {\n        fragColor += vec4(vec3(noise), 0.0);\n    }\n\n    // 1D Airy Bessel Function\n    if (plot) {\n        float pNoise = noise * plotScale / 10.0;\n        float ratio = iResolution.y / iResolution.x;\n        float x = fragCoord.x - offset.x;\n        float y = 0.0;\n        if (plotBottom) { y = fragCoord.y - 10.0 - pNoise; }\n        else { y = fragCoord.y - offset.y - pNoise; }\n        fragColor.g += S(plotScale * powerScale * A(x / sizeScale) - y);\n    }\n}\n","name":"Image","description":"","type":"image"}]}