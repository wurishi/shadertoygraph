{"ver":"0.1","info":{"id":"ws2fDm","date":"1590225111","viewed":208,"name":"raytraced quaterion julia set","username":"Eriksonn","description":"uses distance estimation to sphere march onto a 4d fractal","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat Sq(float x)\n{\n\treturn x*x;\n}\nvec4 QuaternionMultiply(vec4 Q1, vec4 Q2)\n{\n\treturn vec4(\n    Q1.x*Q2.x-Q1.y*Q2.y-Q1.z*Q2.z-Q1.w*Q2.w,\n    Q1.x*Q2.y+Q1.y*Q2.x+Q1.z*Q2.w-Q1.w*Q2.z,\n    Q1.x*Q2.z-Q1.y*Q2.w+Q1.z*Q2.x+Q1.w*Q2.y,\n    Q1.x*Q2.w+Q1.y*Q2.z-Q1.z*Q2.y+Q1.w*Q2.x \n    );\n}\nvec2 DistanceEstimate(vec4 A)\n{\n    //change this 4d vector to change the shape of the julia set, or add some time based changes aswell if you want ;)\n    vec4 C = vec4(-0.76,0,-0.14,0);\n    vec4 DZ = vec4(1,0,0,0);\n    vec4 Z = A;\n    for(int i =0;i<100;i++)\n    {\n        DZ = 2.0*QuaternionMultiply(Z,DZ)+vec4(0.7,0,0,0);\n        Z = QuaternionMultiply(Z,Z)+C;\n        \n        if(length(Z)>100.0)\n        {\n            float r = length(Z);\n    \t\tfloat dr = length(DZ);\n    \t\treturn vec2(r*log(r)/(dr),i);\n            \n        }\n    }\n    return vec2(-1.0,0);\n    \n}\nvec4 GetQuat(vec3 V)\n{\n\treturn vec4(V.y,V.x,V.z,0.0);\n}\nvec3 HueColor(float H)\n{\n\treturn 0.5*(sin(H+vec3(0,2.094,4.188))+1.0);\n}\nvec3 GetColor(float Iter,float Hit,vec3 BaseColor)\n{\n    Iter-=0.0;\n    Iter=max(0.0,Iter);\n    vec3 Col = vec3(0.2,0.4,0.7)*(1.0-Hit)*0.8;\n    Col+=BaseColor*Hit;\n    Col+=vec3(1,1,1)*(1.0-exp(-Iter*0.004))*0.8;\n\treturn Col;\n}\nvec3 Ray(vec3 Pos,vec3 Vel)\n{\n    Pos+=Vel*(-Pos.x/Vel.x);//comment out this line to see the full 3d shape without the cross section in the middle\n    vec3 Background=vec3(0,0,0);\n    vec3 Color=vec3(0,0,0);\n    float CloudDensity=0.0;\n    float iter=0.0;\n\tfor(int i =0;i<400;i++)\n    {\n        vec4 Quat = GetQuat(Pos);\n        vec2 Output = DistanceEstimate(Quat);\n        float Dist = Output.x;\n        Dist = min(4.0,Dist)*0.5;\n        if(Dist<0.0004)\n        {\n        \treturn GetColor(iter,1.0,HueColor(Output.y*0.06)*0.7);\n        }\n        if(length(Pos)>10.0)\n        {\n        \treturn GetColor(iter,0.0,vec3(0,0,0));\n        }\n        iter+=exp(-4.0*Dist);\n        Pos+=Vel*Dist;\n    }\n    return GetColor(iter,0.0,vec3(0,0,0));\n}\nvoid RotateCamera(float Angle1,float Angle2,out vec3 V)\n{\n\tvec3 Out=vec3(0,0,0);\n    float Cos1=cos(Angle1);\n    float Sin1=sin(Angle1);\n    float Cos2=cos(Angle2);\n    float Sin2=sin(Angle2);\n    //camera rotations\n    V.yz = mat2(Cos2, Sin2, -Sin2, Cos2)*V.yz;\n    V.xz = mat2(Cos1, Sin1, -Sin1, Cos1)*V.xz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    uv*=1.0;\n    vec3 RayHeading=vec3(uv.y,uv.x,1);\n    \n    float Angle1=iTime/3.0;\n    float Angle2=0.7;\n    \n    RotateCamera(Angle2,0.0,RayHeading);\n    RotateCamera(0.0,Angle1,RayHeading);\n    \n    vec3 CameraPos=vec3(0,0,-2.0);\n    \n    RotateCamera(Angle2,0.0,CameraPos);\n    RotateCamera(0.0,Angle1,CameraPos);\n    \n    \n    vec3 RayPos=CameraPos+vec3(-0.2,0,0);\n    \n    RayHeading/=length(RayHeading);\n    vec3 col = Ray(RayPos,RayHeading);\n\t\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}