{"ver":"0.1","info":{"id":"3lfXzB","date":"1563319470","viewed":469,"name":"raymarch-simplex1","username":"hodapp","description":"Attempting to treat simplex noise as a distance bound. I don't yet know the Lipschitz constant, so I am not fully following the method in the Sphere Tracing paper, but this seems to run anyhow.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Starting point:\n// https://www.shadertoy.com/view/XsB3Rm\n\n// ray marching\nconst int max_iterations = 512;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// iq's distance function\nfloat sdSphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nvec3 opTwist(in vec3 p) {\n    const float k = 1.0;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdUnion( float d0, float d1 ) {\n    return min( d0, d1 );\n}\n\nfloat sdInter( float d0, float d1 ) {\n    return max( d0, d1 );\n}\n\nfloat sdSub( float d0, float d1 ) {\n    return max( d0, -d1 );\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sfDisp( vec3 p ) {\n    return sin(p.x)*sin(p.y)*sin(p.z) ;\n}\n\nvec3 sdTwist( vec3 p, float a ) {\n    float c = cos(a*p.y);\n    float s = sin(a*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 sdRep( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\nvec3 xform(in vec3 pt, in float w0) {\n    return vec3(snoise(vec4(pt, w0)),\n                snoise(vec4(pt, w0 + 1000.0)),\n                snoise(vec4(pt, w0 + 2000.0)));\n}\n\n// Based on https://iquilezles.org/articles/smin:\nfloat smax(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n    \n    const float l = 1.8;\n    \n    //p += 0.1*xform(p*2.0, 0.0);\n    \n    //p.z += iTime;\n    float th = 0.3; // (cos(iTime / 3.0) + 1.0) / 2.0;\n    \n    vec4 pt = vec4(p, iTime/9.0);\n    \n    return smax((snoise(pt) + th) / 1.0, length(p) - l, 0.1);\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 8.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ref = reflect( dir, n );\n    \n    vec3 Ks = vec3( 0.5 );\n    vec3 Kd = vec3( 1.0 );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n\t\t\n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -30.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        \n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F );\n\t}\n\n    final += texture( iChannel0, ref ).rgb * fresnel( Ks, n, -dir );\n    \n\treturn final;\n}\n\n\nbool ray_vs_aabb(vec3 o, vec3 dir, vec3 bmin, vec3 bmax, inout vec2 e ) {\n    vec3 a = ( bmin - o ) / dir;\n    vec3 b = ( bmax - o ) / dir;\n    \n    vec3 s = min( a, b );\n    vec3 t = max( a, b );\n    \n    e.x = max( max( s.x, s.y ), max( s.z, e.x ) );\n    e.y = max( min( t.x, t.y ), max( t.z, e.y ) );\n    \n    return e.x < e.y;\n}\n\n// ray marching\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {\n\tfloat t = 0.0;\n    float d = 10000.0;\n    float dt = 0.0;\n    for ( int i = 0; i < 128; i++ ) {\n        vec3 v = o + dir * t;\n        d = dist_field( v );\n        if ( d < 0.001 ) {\n            break;\n        }\n        dt = min( abs(d), 0.1 );\n        t += dt;\n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    if ( d >= 0.001 ) {\n        return false;\n    }\n    \n    t -= dt;\n    for ( int i = 0; i < 4; i++ ) {\n        dt *= 0.5;\n        \n        vec3 v = o + dir * ( t + dt );\n        if ( dist_field( v ) >= 0.001 ) {\n            t += dt;\n        }\n    }\n    \n    depth = t;\n    n = normalize( gradient( o + dir * t ) );\n    return true;\n    \n    return true;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 3.5 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    float depth = clip_far;\n    vec3 n = vec3( 0.0 );\n\tif ( !ray_marching( eye, dir, depth, n ) ) {\n\t\tfragColor = texture( iChannel0, dir );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n    \n    vec3 color = shading( pos, n, dir, eye );\n\tfragColor = vec4( pow( color, vec3(1.0/1.2) ), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n","name":"Common","description":"","type":"common"}]}