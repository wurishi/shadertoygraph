{"ver":"0.1","info":{"id":"XlSSW3","date":"1446691899","viewed":254,"name":"MatrixTree","username":"jt","description":"A tree-like structure without recursion, using trigonometric functions with fract for branching - suitable for ray-tracing :-)\n(see [url]https://www.shadertoy.com/view/MljXDV[/url], [url]https://www.shadertoy.com/view/ll2XDV[/url] for 2d variants).","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","implicitsurface","floor","fract","ceil","trigonometricfunctions","pow","sign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Matrix-Tree (a ray-traced Sine Tree) - written 2015-11-05 by Jakob Thomsen\n// A tree-like structure without recursion, using trigonometric functions with fract for branching - suitable for ray-tracing :-)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat mirror(float v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nfloat sinetree2d(vec2 v)\n{\n    v.x = mirror(v.x);\n    float n = 3.0; // fract(t / 6.0) * 6.0;\n    float br = pow(2.0, ceil(v.y * n));\n    float fr = fract(v.y * n);\n    float val = cos(pi * (v.x * br + pow(fr, 1.0 - fr) * 0.5 * sign(sin(pi * v.x * br))));\n    //return pow(0.5 - 0.5 * val, (fr * 1.5 + 0.5) * 100.0);\n    return 1.0 - pow(0.5 - 0.5 * val, (fr * 1.5 + 0.5) * 1.0);\n}\n\nfloat fn(vec3 v)\n{\n    return max(sinetree2d(v.xz), sinetree2d(v.yz));\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec3 tex(vec3 v)\n{\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    //x += 0.01 * time;\n    //y += 0.01 * time;\n    float d = exp(-pow(abs(z * 20.0 + sfract(-iTime, 4.0) * 5.0), 2.0));\n    z -= 0.05 * iTime;\n    x = (x * 8.0);\n    y = (y * 8.0);\n    z = (z * 8.0);\n    float q = 0.0;\n    q = max(q, comb(x, 10.0));\n    q = max(q, comb(y, 10.0));\n    q = max(q, comb(z, 10.0));\n    float w = 1.0;\n    w = min(w, max(comb(x, 10.0), comb(y, 10.0)));\n    w = min(w, max(comb(y, 10.0), comb(z, 10.0)));\n    w = min(w, max(comb(z, 10.0), comb(x, 10.0)));\n    return d +  max(w + vec3(0.0, q, 0.5 * q), 0.25 * clamp(vec3(0.0, v.z, 1.0 - v.z), 0.0, 1.0));\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime * 0.1;\n    //float phi = 2.0 * iMouse.x / iResolution.x - 1.0;\n    vec3 v = vec3(uv, depth);\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    v.z = iso.x * cos(phi) + iso.y * sin(phi);\n    v.y = iso.x * -sin(phi) + iso.y * cos(phi);\n    v.x = iso.z;\n\n    return v;\n}\n\n/*\nvec3 camera(vec2 uv, float depth)\n{\n    float t = iTime * 0.1;\n    vec3 v;\n    v.x = uv.x * cos(t) + uv.y * sin(t); // uv.x;\n    v.y = uv.x * -sin(t) + uv.y * cos(t); // uv.y;\n    v.z = depth;\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n\n    return iso;\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.1;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const int depth = 256;\n    float m = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for(int layer = 0; layer < depth; layer++) // slow...\n    {\n        vec3 v = camera(uv, 2.0 * float(layer) / float(depth) - 1.0);\n\n        if(abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0)\n            continue;\n\n        if(abs(fn(v)) < 0.05)\n        {\n            m = 2.0 * float(layer) / float(depth) - 1.0;\n            color = tex(v);\n        }\n    }\n    \n    //fragColor = vec4(color * vec3(m), 1.0);\n    fragColor = vec4(color, 1.0);\n}\n","name":"","description":"","type":"image"}]}