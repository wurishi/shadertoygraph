{"ver":"0.1","info":{"id":"3dsSDs","date":"1552568340","viewed":181,"name":"MusicFormatV0.00002","username":"znsoft333","description":"music format, try conver my old sequencer format","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["sequence","musicformat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define PI2 6.2831 \n#define char int\n#define ARRAY []=char[](\n#define bpm 150.0 \n#define instrNums 5\n#define trackLen 20\n#define tracks 5\n//every pattern is 16 bytes len\nconst char patterns ARRAY 45,0,0,0,52,0,0,0,48,0,0,0,45,0,0,0,52,0,0,0,48,0,0,0,45,0,0,0,52,0,0,0,47,0,0,0,54,0,0,0,51,0,0,0,47,0,0,0,54,0,0,0,51,0,0,0,47,0,0,0,54,0,0,0,0,0,0,0,0,0,0,0,0,0,57,0,0,0,64,0,0,0,0,0,0,0,62,0,0,0,59,0,0,0,0,0,0,0,0,0,0,0,54,0,0,0,50,0,0,0,0,0,57,0,0,0,67,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,63,0,0,0,57,0,0,0,67,0,0,0,59,0,0,0,69,0,0,0,63,0,0,0,0,0,0,0,0,0,0,0,66,0,0,0,59,0,0,0,69,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,0,0,0,0,57,0,67,0,64,0,0,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,66,0,62,0,0,0,59,0,69,0,0,0,33,33,33,0,0,0,33,33,33,0,0,0,33,33,33,0,34,34,34,0,34,34,34,0,34,0,34,34,0,0,0,0,38,0,38,38,0,0,0,0,38,38,0,0,38,38,38,38,39,39,39,0,39,39,39,0,39,39,39,0,0,0,0,0,35,0,0,0,35,0,0,0,0,0,35,0,35,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,102,0,0,0);\nconst char seqPat ARRAY 1,0,0,20,21,2, 5,0,20,21,3, 0,0,20,21,4,6,0,20,21,1,0,0,20,21,2,5,0,20,21,3,0,0,20,21,4,7,0,20,21,1,8,0,20,21,2,9,0,20,21,3,10,0,20,21,4,11,0,20,21,1,12,0,20,21,2,13,0,20,21,3,14,0,20,21,4,15,0,20,21,1,0,16,20,21,2,0,17,20,21,3,0,18,20,21,4,0,19,20,21,0,0,0,0,0);// here pattern sequence on tracks\nconst char instr  ARRAY 0,-1,0,0,57,31,16,13,0,63,0,0,0,0,0,0, 0,-2,0,0,41,31,16,13,0,63,0,0,0,0,0,0, 6,-3,0,0,16,0,0,0,0,7,0,0,0,0,0,0, 0,-4,16,0,94,22,0,36,0,0,0,0,0,0,0,0, 3,-5,0,126,20,8,0,37,0,0,0,0,0,0,0,0);\n\n#define bps 4. * bpm  / 60.0\n// if value of field < 0 that mean get value for this field from track number abs()\nstruct Instrument{\n/*\t0  int osc; //0 - sin; 1 - fract ; sqr ; noice ; saw ; saw * saw ; saw * sin ; FM\n    1  int note;\n    2  int toNote;//note decay\n    3  int offset;//not use\n    4  int volume;\n    5  int len;/// not use \n    6  int attack; /// not use \n    7  int decay; /// \n    8  int sustain; /// not use \n    9  int phase;\n    10 int delay; /// \n    11 int echos;/// not use if 0\n    12 int fade;\n    13 int reso;\n    14 int resoLevel;/// not use if 0\n    15 int filter;/// not use\n*/\n    char[16] alldata;\n};\n    \n\n//get position in sequence of patterns\nint getSeqPos(float t){\n   // return int(floor(bps * t/16.0)); \nreturn (int(floor(bps * t ))/16)% trackLen;\n}    \n//get position of note in pattern\nint getPatPos(float t){\n    return int(floor(bps * t))%16;\n\n}  \n//get position in note\nfloat getNotePos(float t){\n    return fract(bps * t);\n}    \n//get value from channel/track\nchar getCurValue(int seqPos, int patPos, int track){\n\tchar patN = seqPat[(track-1)+seqPos*tracks];\n    if(patN==0) return 0;\n\treturn patterns[(patN-1)*16+patPos];\n}\n  \n\n//calc note\nfloat ntof(float n)\n{\n\treturn 440.0 * pow(2.0, (n-127. ) / 12.0) * bps ;\n}\n   \n\nfloat FM(float t,float f,float p){\n\n    return sin(f*PI2*t+  // base freq\n                    (3.124+7.14*sin(t/PI2))\n                    *sin(p*f*PI2*t)// FM Modulation\n                   );\n\n}\n\nfloat tri(float t,float f, float p)\n{\n    return abs(fract(t * f - p) )*2.0-1.0;\n}\n\nfloat saw(float t,float f, float p)\n{\n\treturn fract(t * f + p) * 2.0 - 1.0;\n}\n\nfloat sqr(float t,float f, float p)\n{\n    return step(fract(t * f), p/31.)*2.0-1.0;\n}\n\nfloat sawmsaw(float t,float f, float p){\n\treturn (fract(t*(f-p))*fract(t*(f+p)))* 2.0 - 1.0;\n}\n\nfloat sinw(float t,float f, float p){\n\treturn sin( t*f*PI2+p/15.);\n}\n\nfloat noise(float t,float f, float p){\n\treturn fract(sin(t*f*PI2)*(p+1.5)*31.)*2.0-1.;\n}\n\nfloat decay2(float time,float len,float param){\n    return exp(param * time);\n\n}\n\nfloat zfilter(float h, float cut, float res,float time)\n{\n    h += fract(time * res);\n\treturn clamp(h * cut+h,-1.,1.);\n}\n\n\n\nfloat osc(int type,float time,float freq,float phase){\n    //0 - sin; 1 - fract ; sqr ; noice ; saw ; saw * saw ; saw * sin ; FM\n\tif(type == 0)return sinw(time, freq, phase);\n    if(type == 1)return tri(time, freq, phase);\n\tif(type == 2)return sqr(time, freq, phase);\n\tif(type == 3)return noise(time, freq, phase);\n    if(type == 4)return saw(time, freq, phase);\n\tif(type == 5)return sawmsaw(time, freq, phase);\n\tif(type == 6)return FM(time, freq, phase);\n\t\n    return 0.0;\n}\n\n\n\nfloat finstrument(float time,int type,float note,float offset,float phase,float decay,float notedecay,float cut,float res ){\n    float freq = ntof(note)+offset;\n    freq *= exp(notedecay * time);\n    float y = osc(type,time,freq,phase);\n\tif(cut!=.0&&res!=.0)\n        y = zfilter(y,cut, res,time);\n        y *= decay2(time,0.,decay);\n\treturn y;\n}\n\n\n\nfloat instrument(float time,int type,int note,int offset, int vol, int phase,int decay,int notedecay,int cut,int res){\n\tif(note ==0) return .0;\n    \n    float n = float(note);\n    float p = float(phase)/31.0;\n    float d = float(decay-63)/31.0;\n    float n2 = notedecay==0?0.: float(notedecay-63)/100.0;;\n    float c = float(cut)/63.0;\n    float r = float(res)/63.0;\n    float o = float(offset);\n    \n    \n    return finstrument(time,type,n,o,p,d ,n2,c,r);\n}\n\n\nvec2 getSample(Instrument i, float t){\nfloat n = getNotePos(t);\nfloat y = instrument(n,i.alldata[0], i.alldata[1], i.alldata[3], i.alldata[4],i.alldata[9],i.alldata[7],i.alldata[2],i.alldata[13],i.alldata[14]);\nreturn vec2(y);\n}\n\n\nInstrument createInstrument(int i, int s, int p){\n    Instrument ins;\n        for(int j=0;j<16;j++){\n        char value = instr[i*16+j];\n        if(value<0) value = getCurValue(s, p, -value);\n \t\t\tins.alldata[j]=value;\n        }\n    return ins;\n}    \n\n\n//vec2 getTrackSample(i,s,p,t){\n\n\nvec2 getSampleAll(float t)\n{\n    int s = getSeqPos(t);\nint p = getPatPos(t);\n\n    \n    vec2 smp = vec2(0.);\n    for(int i=0;i<instrNums;i++){\n\n        \n    Instrument ins = createInstrument( i, s, p);\n        //if(ins.alldata[1]==0)continue;\n        float d = 0.;\n        float amp =  float(ins.alldata[4])/255.;;\n        float da = float(ins.alldata[12])/64.;\n        float dd = float(ins.alldata[10])*bps;\n            for(int e=0;e<=ins.alldata[11];e++){// echoes\n    \t\t\tsmp += getSample(ins,t+d) * amp ;\n                amp =da; \n                d+=dd;\n            }\n    \n    \n    }   \n    return smp;\n}  \n\nvec2 mainSound( in int samp,float time)\n{\n\n    return getSampleAll( time);\n}","name":"Common","description":"","type":"common"}]}