{"ver":"0.1","info":{"id":"mscfRM","date":"1696965542","viewed":27,"name":"RayMarching_Course","username":"StereoBun","description":"Pikso","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pikso"],"hasliked":0,"parentid":"csGcz3","parentname":"Pikso"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb(float r, float g, float b){\n    return vec3(r/255.0, g/255.0, b/255.0);\n}\n\n\n\nfloat map(vec3 p) {\n    float radius = 1.0;\n    vec3 sPos = vec3(0.0, 0.0, 0.0);\n    return distance(p, sPos)*radius;\n}\n\n\nvec3 get_normal(vec3 p, float d) {\n    vec2 epsilon = vec2(0.01, 0.0);\n    return normalize(vec3(d) - vec3(map(p - epsilon.xyy), map(p - epsilon.yxy), map( p - epsilon.yyx)));\n    // Dérivé en 3D - Tangent regarding a position on sphere.\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.xx;\n    vec3 col = rgb(240.0, 207.0, 101.0);\n    vec3 camPos = vec3(0.0,0.0,-5.0);\n    \n    vec3 viewDir = normalize(vec3(uv.x,uv.y,1.));\n    vec3 p = camPos;\n    vec3 sPos = vec3(0.0,0.0,0.0);\n    float radius = 1.0;\n    \n    for (int i = 0; i < 128; ++i){\n        float dist = distance(p, sPos) - radius;\n        \n        if(dist < 0.001) {\n            //col = vec3(1., 0., 0.5);\n            col = get_normal(p, dist) * 0.5 + 0.5;\n            vec3 n = normalize(p * vec3(0.5, 0.5, 0.5));\n            col = (n*.5+.5) * vec3(0.5);\n            break;\n        }\n        p = p + viewDir*dist; \n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}