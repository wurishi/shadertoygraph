{"ver":"0.1","info":{"id":"XXjfzd","date":"1730571575","viewed":186,"name":"Exercising Dancers","username":"dray","description":"and an energetic shadow.\nMore humanoid mechanics + more music. Yes, I am still playing with this.\nAdd missing arm rotation. Finally tried AO!\nSome new FM synthesis. Sequencing and more Sequencing\n\n","likes":10,"published":1,"flags":8,"usePreview":0,"tags":["mechanics","music","dancer"],"hasliked":0,"parentid":"4f2fz3","parentname":"Simplified Green Dancer +sound"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I think too many systems could not handle this\n// so comment this out if you want to try full version\n#define ShortVersion\n/*\nEfficient sequencing is a challenge to keep character motion changes smooth.\nSome platforms compile fast and run slow - 0.1s compile, 9fps on old phone.\nSome compile slow and run fast - 8s compile, 40fps on laptop.\n*/\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define min3(A,B,C) min(A,min(B,C))\n#define min5(A,B,C,D,E) min(min(A,B),min(C,min(D,E)))\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nmat3 MAT3xz(float ANG) { return mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) ); }\nmat3 MAT3zy(float ANG) { return mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) ); }\nmat3 MAT3xy(float ANG) { return mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 ); }\n\n// *********************************************************************************\n\nstruct DAN {\n    float luarm, ruarm;   // spread arms apart 0-3 radians\n    float lelbow, relbow; // bend elbows arms forward 0-3 radians\n    float lelbowi, relbowi; // bend elbows arms across chest 0-3 radians\n    float lshoulder, rshoulder; // raise arms in front 0-3 radians\n    //float lrota, rrota; // upper arm rotation -1 - 1 radians\n    float lknee, rknee;  // bend knees 0-3 radians\n    float luleg, ruleg;  // spread legs apart 0-1.5 radians\n    float lhip, rhip;    // raise legs in front 0-3 radians\n    float spin;\n    float leanl, leanf;\n    float hop;\n    vec3 offset;\n    // result coordinates\n    vec3 _head, _hips; // body\n    vec3 _lshoulder,_lelbow, _lhand;\n    vec3 _rshoulder, _relbow, _rhand;\n    vec3 _lknee, _lhip, _lfoot;\n    vec3 _rknee, _rhip, _rfoot;\n    float _bottom;\n};\n\n#define DANIni(D) \\\n  D.luarm=0.; D.lelbow=0.; D.lelbowi=0.; D.lshoulder=0.; \\\n  D.ruarm=0.; D.relbow=0.; D.relbowi=0.; D.rshoulder=0.; \\\n  D.lhip=0.; D.luleg=0.; D.lknee=0.; \\\n  D.rhip=0.; D.ruleg=0.; D.rknee=0.; \\\n  D.spin=0.; D.leanl=0.; D.leanf=0.; D.hop=0.; D.offset=vec3(0);\n  \n\n// alternative to .5-.5*cos(P)\n//float tri(float i) {  return 1. - abs( fract(i)*2. - 1. ); }\n//#define cosp(P) SS(tri((P))) \n\n#define MOVE(FLD,P,L,H) FLD=((.5-.5*cos(P))*((H)-(L))+(L));\n#define HOP(D,V0,G,T)  STDY( D.hop, max( 0., (V0)*(T) - (G)*(T)*(T) ) );\n#define STDY(FLD,VAL) FLD = (VAL);\n\n// Compute an accumulated value from time\n#define ACCUM(MOD,OFF) (mod(base-(OFF),MOD)\n\n#define FOR(TIME) \\\n  es = tim < 0. ? 0. : tim > (TIME) ? 1. : SS(tim/(TIME)); \\\n  if ( tim > 0. ) tim -= TIME; \n\n#define REPEAT(TIME,CNT) \\\n  if ( tim > 0. && tim < (TIME)*(CNT) ) tim = mod(tim,TIME); \\\n  else tim -= (TIME)*(CNT);\n#define REPEATI(TIME,CNT) \\\n  if ( tim > 0. && tim < (TIME)*(CNT) ) \\\n    iter=floor(tim/TIME), tim = mod(tim,TIME); \\\n  else tim -= (TIME)*(CNT);\n\n#define WHEN(TIME,CODE) if ( tim > 0. && tim <= (TIME) ) { CODE; }\n\n\n// smooth step S curve\n//#define SS(C) ((C)*(C)*(3.-2.*(C)))\nfloat SS(float C) { return ((C)*(C)*(3.-2.*(C))); }\n\n#define RAMP(S,E)   ((S)+((E)-(S))*es)\n#define SRAMP(FLD,END) (FLD=RAMP(FLD,END));\n\n#define KneeBend1(D) SRAMP(D.lhip,1.); SRAMP(D.rhip,1.); SRAMP(D.lknee,2.3); SRAMP(D.rknee,2.3);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n#define KneeBend2(D) SRAMP(D.lhip,3.); SRAMP(D.rhip,3.); SRAMP(D.lknee,3.); SRAMP(D.rknee,3.);  SRAMP(D.luleg,0.1); SRAMP(D.ruleg,0.1);\n\n#define KneeBend(D) SRAMP(D.lhip,3.); SRAMP(D.rhip,3.); SRAMP(D.lknee,3.); SRAMP(D.rknee,3.);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n#define StraightLegs(D) SRAMP(D.lhip,0.); SRAMP(D.rhip,0.); SRAMP(D.lknee,0.); SRAMP(D.rknee,0.);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n\n#define RelaxArms(D) SRAMP(D.luarm,.1); SRAMP(D.ruarm,.1);  SRAMP(D.lelbow,.6); SRAMP(D.relbow,.6); \n\n#define CrossArmsFace(D) SRAMP(D.luarm,1.); SRAMP(D.ruarm,1.);  SRAMP(D.lelbow,1.8); SRAMP(D.relbow,1.5); SRAMP(D.lshoulder,1.5); SRAMP(D.rshoulder,1.5); \n\n// Now we can do it !!!!!\n#define CrossArms(D) ArmsSame(D,1.5,1.5,.6,.15,.5)\n\n#define ArmsSame(D,EL,ELI,SHO,OFF,OUT) \\\n  SRAMP(D.lelbow,EL); SRAMP(D.relbow,EL); /* out front */ \\\n  SRAMP(D.lelbowi,ELI); SRAMP(D.relbowi,ELI); /* across chest */ \\\n  SRAMP(D.lshoulder,(SHO)+(OFF)); SRAMP(D.rshoulder,(SHO)-(OFF)); /* arms up in front */ \\\n  SRAMP(D.ruarm,OUT); SRAMP(D.luarm,OUT); /* arms out */\n\n#define HandsInFront(D) ArmsSame(D,.6,0.,1.5,0.,1.)\n/*  \nSRAMP(D.luarm,1.); SRAMP(D.ruarm,1.);  SRAMP(D.lelbow,.6); SRAMP(D.relbow,.6);\\\nSRAMP(D.lshoulder,1.5); SRAMP(D.rshoulder,1.5);  */\n\n#define LArmDown(D) SRAMP(D.luarm,.1); SRAMP(D.lelbow,.1); SRAMP(D.lshoulder,.1);\n#define RArmDown(D) SRAMP(D.ruarm,.1); SRAMP(D.relbow,.1); SRAMP(D.rshoulder,.1);\n\n//#define HOP(D,V0,G,T)  STDY( D.hop, max( 0., (V0)*(T) - (G)*(T)*(T) ) )\n\n//#define STDY(FLD,VAL) FLD = tim <= 0. ? FLD : (VAL);\n\n#define WildArmsA(D) \\\n    MOVE(D.lelbow,iTime*1.5,.0,2.); \\\n    MOVE(D.relbow,iTime*2.,.0,2.); \\\n    MOVE(D.lshoulder,iTime*-3.,0.,2.); \\\n    MOVE(D.rshoulder,iTime*-2.5,0.,2.);\n\n#define WildArms(D) \\\n    MOVE(D.luarm,iTime*5.,0.,3.); \\\n    MOVE(D.ruarm,iTime*4.,0.,3.); \\\n    WildArmsA(D); \n    \n#define WildLLeg(D) \\\n    MOVE(D.lhip,iTime*5.,0.,1.); \\\n    MOVE(D.lknee,iTime*-7.,0.,1.); \\\n    MOVE(D.luleg,iTime*3.,0.,1.); \\\n    STDY( D.ruleg, -.075 ); \\\n    STDY( D.spin, iTime*5. );\n    \n#define WildRLeg(D) \\\n    MOVE(D.rhip,iTime*5.,0.,1.); \\\n    MOVE(D.rknee,iTime*-7.,0.,1.); \\\n    MOVE(D.ruleg,iTime*3.,0.,1.); \\\n    STDY( D.luleg, -.075 ); \\\n    STDY( D.spin, -iTime*4. );\n    \n#define StandUp(D) \\\n  SRAMP(D.luarm,0.); SRAMP(D.lelbow,0.); SRAMP(D.lelbowi,0.); SRAMP(D.lshoulder,0.); \\\n  SRAMP(D.ruarm,0.); SRAMP(D.relbow,0.); SRAMP(D.relbowi,0.); SRAMP(D.rshoulder,0.); \\\n  StraightLegs(D); \\\n  SRAMP(D.spin,0.); SRAMP(D.leanl,0.); SRAMP(D.leanf,0.);\n   \n#define LeftStep(D) SRAMP(D.luleg,0.); SRAMP(D.lknee,0.); SRAMP(D.ruleg,0.); SRAMP(D.rknee,0.); SRAMP(D.lhip,0.); SRAMP(D.rhip,0.);   \n\n#define ExtendRLeg(D) SRAMP(D.rhip,1.6) SRAMP(D.rknee,0.) SRAMP(D.ruleg,.5)\n#define ExtendLLeg(D) SRAMP(D.lhip,1.9) SRAMP(D.lknee,0.) SRAMP(D.luleg,.5)\n\n#define RaiseRLeg(D) SRAMP(D.rhip,.2) SRAMP(D.rknee,.5) SRAMP(D.ruleg,.2)\n#define RaiseLLeg(D) SRAMP(D.lhip,.2) SRAMP(D.lknee,.5) SRAMP(D.luleg,.2)\n\n#define RaiseRKnee(D) SRAMP(D.rhip,1.6) SRAMP(D.rknee,1.6) SRAMP(D.ruleg,.5)\n#define RaiseLKnee(D) SRAMP(D.lhip,1.6) SRAMP(D.lknee,1.6) SRAMP(D.luleg,.5)\n\n#define Lotusl(D) SRAMP(D.luleg,1.4) SRAMP(D.ruleg,.4)\n\n#define Lotus(D) SRAMP(D.luleg,1.4) SRAMP(D.ruleg,1.4)\n\n#define Walk1(D) SRAMP(D.luleg,0.); \\\n                 SRAMP(D.lknee,1.); SRAMP(D.lhip,1.); \\\n                  /*SRAMP(D.rshoulder,-.5)*/\n#define Walk2(D) SRAMP(D.luleg,0.); \\\n                 SRAMP(D.lknee,0.); SRAMP(D.lhip,.1); \\\n                 SRAMP(D.rknee,0.); SRAMP(D.rhip,-1.); \\\n                 /*SRAMP(D.ruleg,0.); SRAMP(D.rknee,.0); SRAMP(D.rhip,-.5); \\\n                 SRAMP(D.rshoulder,.5);*/\n#define Walk3(D) SRAMP(D.ruleg,0.); \\\n                 SRAMP(D.rknee,1.); SRAMP(D.rhip,1.);  \\\n                 /*SRAMP(D.lshoulder,-.5)*/\n#define Walk4(D) SRAMP(D.ruleg,0.); \\\n                 SRAMP(D.rknee,0.); SRAMP(D.rhip,.1); \\\n                 SRAMP(D.lknee,0.); SRAMP(D.lhip,-1.); \\\n                 /* SRAMP(D.luleg,0.); SRAMP(D.lknee,.0); SRAMP(D.lhip,-.5); \\\n                  SRAMP(D.lshoulder,.5) */\n\n#define Run1(D) SRAMP(D.leanf,.5) \\\n                SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.); \\\n                \\\n                SRAMP(D.lknee,1.); SRAMP(D.lhip,1.); \\\n                SRAMP(D.rshoulder,-.2) SRAMP(D.relbow,0.); \n#define Run2(D) SRAMP(D.lknee,0.); SRAMP(D.lhip,.1); \\\n                SRAMP(D.rknee,0.); SRAMP(D.rhip,-.3); \\\n                SRAMP(D.lshoulder,1.); SRAMP(D.lelbow,1.); \n#define Run3(D) SRAMP(D.rknee,1.); SRAMP(D.rhip,1.);  \\\n                SRAMP(D.lshoulder,-.2) SRAMP(D.lelbow,0.);\n#define Run4(D) SRAMP(D.rknee,0.); SRAMP(D.rhip,.1); \\\n                SRAMP(D.lknee,0.); SRAMP(D.lhip,-.3); \\\n                SRAMP(D.rshoulder,1.) SRAMP(D.relbow,1.); \n\n#define Bow(D) SRAMP(D.leanf,1.7)\n#define DeepBow(D) SRAMP(D.leanf,2.2)\n\n#define Fours(D) SRAMP(D.leanf,2.15) \\\n                 /*SRAMP(D.lshoulder,2.0) SRAMP(D.rshoulder,2.0)*/\n\n#define HandStand1(D) SRAMP(D.leanf,PI-.2) SRAMP(D.lshoulder,PI-.4) SRAMP(D.rshoulder,PI-.4) \\\n        SRAMP(D.rhip,-PI+.4)\n#define HandStand2(D) SRAMP(D.leanf,PI)    SRAMP(D.lshoulder,PI)    SRAMP(D.rshoulder,PI) \\\n        SRAMP(D.lhip,-PI+.5) \\\n        SRAMP(D.rknee,.7); SRAMP(D.lknee,.6);\n#define HandStand3(D) SRAMP(D.leanf,PI-.2) SRAMP(D.lshoulder,PI-.4) SRAMP(D.rshoulder,PI)    SRAMP(D.rhip,0.)\n#define HandWalk1(D)  SRAMP(D.lshoulder,PI+.4) SRAMP(D.rshoulder,PI-.4) \\\n        SRAMP(D.rknee,.8); SRAMP(D.lknee,.9);\n#define HandWalk2(D)  SRAMP(D.rshoulder,PI+.4) SRAMP(D.lshoulder,PI-.4) \\\n        SRAMP(D.rknee,1.2); SRAMP(D.lknee,1.4);\n\n#define Spin(D,X) SRAMP(D.spin,(X))\n\n// lshoulder here moves elbow forward without moving hand\n#define LHandHead(D) SRAMP(D.lelbowi,-2.6) SRAMP(D.luarm,2.) SRAMP(D.lelbow,0.) SRAMP(D.lshoulder,.5)\n#define RHandHead(D) SRAMP(D.relbowi,-2.6) SRAMP(D.ruarm,2.) SRAMP(D.relbow,0.) SRAMP(D.rshoulder,.5)\n\n#define LHandForehead(D) SRAMP(D.lelbowi,-2.6) SRAMP(D.luarm,2.) SRAMP(D.lelbow,0.) SRAMP(D.lshoulder,0.)\n#define RHandForehead(D) SRAMP(D.relbowi,-2.6) SRAMP(D.ruarm,2.) SRAMP(D.relbow,0.) SRAMP(D.rshoulder,0.)\n\n#define SINM(P,L,H) ((.5-.5*sin(P))*((H)-(L))+(L))\n#define COSM(P,L,H) ((.5-.5*cos(P))*((H)-(L))+(L))\n\n// Ramp from previous to new value\n#define RAMPINSPD 1.\n#define RAMPIN(FLD,VAL) FLD = mix( FLD, VAL, clamp(tim/RAMPINSPD,0.,1.) );\n// Ramp into circular motion\n#define SINMV(FLD,SPD,L,H) RAMPIN(FLD,SINM(SPD,L,H))\n#define COSMV(FLD,SPD,L,H) RAMPIN(FLD,COSM(SPD,L,H))\n\n#define BendLegs(m) \\\n  m.luleg=m.ruleg=.2; \\\n  m.rhip = m.lhip = ( m.lknee = m.rknee = SINM(iTime,.3,1.3) ) * .5;\n  \n#define BendLegs2(m) \\\n  RAMPIN(m.luleg,.2) RAMPIN(m.ruleg,.2) \\\n  { float tmp = SINM(iTime,.3,1.3); \\\n  RAMPIN(m.lknee,tmp) RAMPIN(m.rknee,tmp) \\\n  tmp *= .5; \\\n  RAMPIN(m.rhip,tmp) RAMPIN(m.lhip,tmp) \\\n  }\n\n#define Squat(m) \\\n  SRAMP(m.rhip,2.8) SRAMP(m.lhip,2.8) \\\n  SRAMP(m.rknee,2.8) SRAMP(m.lknee,2.8) \n\n#define Squat1(m) \\\n  SRAMP(m.rhip,PI*.25) SRAMP(m.lhip,PI*.25) \\\n  SRAMP(m.rknee,PI*.75) SRAMP(m.lknee,PI*.75)\\\n  SRAMP(m.leanf,.4) \\\n  SRAMP(m.lelbow,.8) SRAMP(m.relbow,.8) \n#define Squat2(m) \\\n  SRAMP(m.rhip,PI*.5) SRAMP(m.lhip,PI*.25) \\\n  SRAMP(m.rknee,PI*.6) SRAMP(m.lknee,PI*.75)\\\n  SRAMP(m.rshoulder,.1) SRAMP(m.lshoulder,1.)\n#define Squat3(m) \\\n  SRAMP(m.rhip,PI*.25) SRAMP(m.lhip,PI*.5) \\\n  SRAMP(m.rknee,PI*.75) SRAMP(m.lknee,PI*.6)\\\n  SRAMP(m.rshoulder,1.) SRAMP(m.lshoulder,.1)\n\n// *********************************************************************************\n\nDAN Jill, Bill;\n\nvoid animJill() {\n    DANIni(Bill);\n    DANIni(Jill);\n \n    if ( iTime > 150. ) return;\n\n    float tim = iTime; // + 50.; // mod(iTime,1118.);\n    float es = 1.; // smoothstep s-curve within current motion   \n\n    FOR(8.)\n    if ( iTime < 8. )\n    {\n    HOP(Jill, 15., 40., fract(tim*2.) )\n    MOVE(Jill.lelbow,tim*1.,.2,1.);\n    MOVE(Jill.relbow,tim*4.,.1,1.);\n    MOVE(Jill.lshoulder,tim*-4.,0.,2.2);\n    MOVE(Jill.rshoulder,tim*-1.,0.,1.8);\n    MOVE(Jill.luarm,tim*1.,0.,.5);\n    MOVE(Jill.ruarm,tim*3.,0.,1.5);\n    MOVE(Jill.rhip,tim*5.,0.,1.);\n    MOVE(Jill.rknee,tim*-7.,0.,1.);\n    MOVE(Jill.ruleg,tim*3.,0.,1.);\n    STDY(Jill.luleg, -.075 );\n    STDY(Jill.spin, -tim*4. );\n    MOVE(Jill.leanf,tim*1.5,-.5,.5);  \n    return;\n    }\n\n\n    FOR(1.)\n    Spin(Jill,1.)\n    FOR(1.)\n    HandStand1(Jill);\n    FOR(1.)\n    HandStand2(Jill);\n    FOR(.5)\n    HandWalk1(Jill)\n    REPEAT(1.,6.)\n    FOR(.5)\n    HandWalk2(Jill)\n    FOR(.5)\n    HandWalk1(Jill)\n    FOR(.5)\n    HandWalk2(Jill)\n    FOR(1.)\n    HandStand3(Jill);\n    FOR(1.)\n    StandUp(Jill)\n\n\nFOR(1.)\nSpin(Jill,-.7)\n//RAMPIN(Jill.spin,mod(iTime*4.,TAU))\n//SRAMP(m.ruleg,PI/2.) SRAMP(m.luleg,PI/2.)\nFOR(1.)\nSquat1(Jill)\nFOR(.5)\nSquat2(Jill)\nREPEAT(1.,6.)\nFOR(.5)\nSquat3(Jill)\nFOR(.5)\nSquat2(Jill)\n\n#ifndef ShortVersion\n\nFOR(.5)\nStandUp(Jill)\nBendLegs2(Jill)\nREPEAT(.5*(8.+10.),2.)\n\n//float iter;\n//REPEATI(.5,2000.)\n//FOR(5.)\n//SINMV(Jill.luarm,1.,.3,.8)\n//ArmsSame(Jill,0.,0.,.3+mod(iter,4.),.1,.0);//1.-2.*mod(iter,2.))\n\nFOR(.5)\nArmsSame(Jill,.5,.5,0.4,.1,.5)\nFOR(.5)\nArmsSame(Jill,.5,.5,0.6,.1,-.5)\nFOR(.5)\nArmsSame(Jill,.5,.5,0.8,.1,.5)\nFOR(.5)\nArmsSame(Jill,.5,.5,1.0,.1,-.5)\nFOR(.5)\nArmsSame(Jill,.5,.5,1.2,.1,.5)\nFOR(.5)\nArmsSame(Jill,.5,.5,1.4,.1,-.5)\nFOR(.5)\nArmsSame(Jill,.5,.5,1.6,.1,.5)\nFOR(.5)\nArmsSame(Jill,.5,.5,1.8,.1,-.5)\n\nFOR(.5)\nRelaxArms(Jill)\nFOR(.5)\nLHandHead(Jill)\n//FOR(.5) CrossArmsFace(Jill)\nFOR(.5)\nCrossArms(Jill)\nFOR(.5)\nRHandHead(Jill)\nFOR(.5)\nArmsSame(Jill,0.,0.,.6,.1,.1)\nFOR(.5)\nArmsSame(Jill,1.,0.,.6,1.2,.4)\nFOR(.5)\nArmsSame(Jill,1.,2.,.6,.1,.4)\nFOR(.5)\nArmsSame(Jill,0.,2.,.6,.4,.3)\nFOR(.5)\nArmsSame(Jill,0.,0.,.6,.1,.1)\nFOR(.5)\nLArmDown(Jill)\nFOR(.5)\nRArmDown(Jill)\nFOR(.5)\nArmsSame(Jill,0.,0.,.0,.0,.0)\n\n\n    FOR(1.)\n   // Spin(Jill,-1.)\n    StandUp(Jill)\n    Run1(Jill)\n    WHEN(20.,Spin(Jill,tim/4.))\n    REPEAT(.8,12.)\n    FOR(.2)\n    Run2(Jill)\n    FOR(.2)\n    Run3(Jill)\n    FOR(.2)\n    Run4(Jill)\n    FOR(.2)\n    Run1(Jill)\n\n\n    FOR(1.)\n    StandUp(Jill)\n    WHEN(20.,Spin(Jill,tim))\n    Spin(Jill,-.4)\n    FOR(.5)\n    Walk1(Jill)\n    REPEAT(2.,8.)\n    FOR(.5)\n    Walk2(Jill)\n    FOR(.5)\n    Walk3(Jill)\n    FOR(.5)\n    Walk4(Jill)\n    FOR(.5)\n    Walk1(Jill)\n\n\n    FOR(1.)\n    StandUp(Jill)\n    FOR(1.)\n    CrossArms(Jill);\n    KneeBend2(Jill);\n    Lotus(Jill);\n    WHEN(10.,WildArms(Jill);)\n    //FOR(1.)     ExtendRLeg(Naya)\n    //FOR(1.)     ExtendLLeg(Naya)\n    FOR(1.)  \n    Lotus(Jill);\n    FOR(6.)\n    FOR(1.)\n    KneeBend2(Jill);\n    FOR(1.)\n    KneeBend1(Jill);\n    FOR(1.)\n    StandUp(Jill)\n\n\n    REPEAT(11.,2.)\n    WHEN(11.,WildArms(Jill);)\n    FOR(1.)\n    SRAMP(Jill.leanl,.2)\n    FOR(1.)\n    SRAMP(Jill.leanl,0.)\n    FOR(1.)\n    KneeBend1(Jill);  \n    FOR(1.)\n    KneeBend2(Jill);\n    FOR(1.)\n    KneeBend2(Jill);\n    FOR(1.)\n    KneeBend1(Jill);\n    FOR(1.)\n    StraightLegs(Jill);\n    FOR(.5)\n    HandsInFront(Jill);\n    //ExtendRLeg(Jill);\n    RaiseRKnee(Jill);\n    FOR(.5)\n    StraightLegs(Jill);\n    FOR(.5)\n    RaiseLKnee(Jill);\n    FOR(.5)\n    StraightLegs(Jill);\n    FOR(1.)\n    RaiseRLeg(Jill);\n    LArmDown(Jill);\n    SRAMP(Jill.spin,6.28*.75) \n    FOR(1.)\n    RaiseLLeg(Jill)\n    RArmDown(Jill);\n    SRAMP(Jill.spin,0.)\n\n\n    //REPEAT(12.,1000.)\n    FOR(1.)\n    StraightLegs(Jill);\n    WHEN(1000.,\n      FOR(1.)\n      BendLegs(Jill)\n      SRAMP(Jill.leanl,.3*sin(iTime*PI))\n      SRAMP(Jill.leanf,.3*cos(iTime*PI))\n      ArmsSame(Jill,.2*sin(iTime*2.),.2+.2*sin(iTime*3.),.5+.5*sin(iTime*4.),.1*sin(iTime*5.),.4+.2*sin(iTime*6.))\n      )\n    FOR(12.)\n    //FOR(1.)\n    //StraightLegs(Jill);\n    \n/*      \n    FOR(0.)\n    SRAMP(Jill.leanl,-.3)\n    SRAMP(Jill.leanf,-.3)\n    REPEAT(4.,1000.)\n    FOR(1.)\n    SRAMP(Jill.leanl,.3)\n    FOR(1.)\n    SRAMP(Jill.leanf,.3)\n    FOR(1.)\n    SRAMP(Jill.leanl,-.3)\n    FOR(1.)\n    SRAMP(Jill.leanf,-.3)\n*/\n/*\n    Spin(Jill,-.5);\n    REPEAT(2.,1000.)\n    FOR(1.)  \n    Fours(Jill);\n    //SRAMP(Jill.lknee,2.) // SRAMP(Jill.rknee,2.)\n    FOR(1.)  \n    //SRAMP(Jill.lhip,-1.) // SRAMP(Jill.rhip,-1.)\n/*\n    FOR(1.)\n    ExtendRLeg(Jill)\n    //Spin(Jill,PI);\n    FOR(1.)  \n    StraightLegs(Jill);\n    FOR(1.)\n    ExtendLLeg(Jill)\n    Spin(Jill,0.);\n*/    \n/*\n    FOR(1.)  \n    StraightLegs(Jill);\n*/\n\n#endif\n\n    FOR(1.)\n    StandUp(Jill)\n    FOR(.5)\n    Bow(Jill)\n    FOR(1.)\n    StandUp(Jill)\n\n}\n\n// -----------------------------------------------------------------------------\n\n#define DSZ 20.\n\nvoid CompDancer(inout DAN m) {\n    m._hips = vec3(0,0,0); // origin !\n    mat3 rott =  MAT3zy(m.leanf) * MAT3xz( m.spin ) * MAT3xy(m.leanl);\n    m._head = m._hips + vec3(0,.33,0)*DSZ * rott;\n\n    vec3 shoulders = mix( m._hips, m._head, .8 );\n\n    mat3 sav = rott;\n  \n    // left arm\n    m._lshoulder = shoulders - vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.lshoulder ) * MAT3xy( m.luarm ) * rott;\n    m._lelbow = m._lshoulder + vec3(0,-.14,0)*DSZ * rott;\n    //rott = MAT3zy( -m.lelbow ) * rott;\n    rott = MAT3zy( -m.lelbow ) * MAT3xy( -m.lelbowi ) * rott;\n    m._lhand = m._lelbow + vec3(0,-.14,0)*DSZ * rott;\n  \n    rott = sav;\n\n    // right arm\n    m._rshoulder = shoulders + vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.rshoulder ) * MAT3xy( -m.ruarm ) * rott;\n    m._relbow = m._rshoulder + vec3(0,-.14,0)*DSZ * rott;\n    //rott = MAT3zy( -m.relbow ) * rott;\n    rott = MAT3zy( -m.relbow ) * MAT3xy( m.relbowi ) * rott;\n    m._rhand = m._relbow + vec3(0,-.14,0)*DSZ * rott;\n\n    rott = sav;\n\n    // left leg\n    m._lhip = m._hips - vec3(.025,0,0)*DSZ * rott;\n    rott =  MAT3xy( m.luleg - m.leanl ) * MAT3zy( -m.lhip -  m.leanf ) * rott;\n    m._lknee = m._lhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.lknee ) * rott;\n    m._lfoot = m._lknee + vec3(0,-.18,0)*DSZ * rott;\n\n    rott = sav;\n\n    // right leg\n    m._rhip = m._hips + vec3(.025,0,0)*DSZ * rott;\n    rott = MAT3xy( -m.ruleg - m.leanl ) * MAT3zy( -m.rhip  - m.leanf ) * rott;\n    m._rknee = m._rhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.rknee ) * rott;\n    m._rfoot = m._rknee + vec3(0,-.18,0)*DSZ * rott;\n\n    m._bottom = min5( m._lhand.y, m._rhand.y, m._lfoot.y, m._rfoot.y, m._hips.y-.035*DSZ/3. ) - m.hop /*+ .025*/;\n\n}\n\n/*\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdHat(vec3 pt,float high,float wide) {\n  float x=length(pt.xz);\n  if ( pt.y > 0. ) return pt.y\n}\n*/\n\nvec2 rot2d(vec2 inp,float ang) {\n  float ss = sin(ang);\n  float cc = cos(ang);\n  return vec2( inp.x * cc + inp.y * ss, inp.y * cc - inp.x * ss ); \n}\n\nfloat Dancer2(vec3 pt,DAN m,float xz) {\n    pt.xz = rot2d( pt.xz, xz );\n    pt += m.offset;\n    pt.y += m._bottom;\n    float dist = sdCapsule( pt, m._head, m._hips, .035*DSZ ); // body\n    float tmp;\n    //tmp = sdCone( pt, m._head.xz, .1 ); if ( tmp < dist ) dist = tmp;\n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); if ( tmp < dist ) dist = tmp;\n    ADD(m._lshoulder,m._lelbow,.02)\n    ADD(m._lhand,m._lelbow,.02)\n    ADD(m._rshoulder,m._relbow,.02)\n    ADD(m._rhand,m._relbow,.02)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n    return dist;\n}\n\n// Terrain -------------------------------------\n\nfloat rndd(vec2 pt) {\n  pt += vec2(13.43544,31.2434);\n  return fract( sin(mod(pt.x*pt.y,TAU)) * 89.367456 );\n}\n\n// smooth step S curve\n//float SS(float C) { return ((C)*(C)*(3.-2.*(C))); }\n\nfloat height(vec2 pt) { // 0-1\n    vec2 f = floor(pt);\n    vec2 r = fract(pt);\n    vec2 o = vec2(1,0);\n    float xf = SS(r.x);\n    return mix(\n       mix( rndd(f), rndd(f+o), xf ), // mid points of x edges\n       mix( rndd(f+o.yx), rndd(f+o.xx), xf ),\n       SS(r.y) );\n}\n\nvec3 thigh(vec3 pt) {\n  pt.y = height(pt.xz*.03)*10. + pt.z*.3 - 5.;\n  return pt;\n}\n\nfloat height2(vec3 pt) { return pt.y - height(pt.xz*.03)*10. - pt.z*.3 + 5.; }\n\nfloat Texture(vec2 pt) { return .5 + height(pt*50.)*.5; }\n\n// Map --------------------------------------------------------------\nvec3 shadoff;\nmat3 shadrot;\nbool who;\nfloat Danc(vec3 pt,DAN d) {\n  return Dancer2( (pt-vec3(0,0,-3)+shadoff)*shadrot-shadoff, d, 0. );\n}\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n\n    T( who?Danc(pt,Bill):Danc(pt,Jill) )\n    T( Dancer2( pt-thigh(vec3(-20,0,20)), Jill, iTime ) );\n    T( Dancer2( pt-thigh(vec3(20,0,20)), Jill, -iTime ) );\n    clr = 3.;\n    T( height2(pt) )\n    return hit;\n}\n\n#define ZERO (min(iFrame,0)) // trick to avoid loop unrolling\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = ZERO; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( pos.z < -80. ) return vec4( pos, 91. );\n        if ( obj.x < .01 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;   // .12 is distance to darken\n        float d = Dist( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    animJill();\n    CompDancer(Jill);\n    CompDancer(Bill);\n    \n    shadoff = vec3(0);\n    shadrot = mat3(1,0,0,0,1,0,0,0,1);\n    who = false; mod(iTime,15.)>10.;\n\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv *= .25; // fieldof view\n    //vec3 cam = vec3( 0., 10., -64.);\n    vec3 cam = vec3( 0.+sin(iTime*.3)*5., 10.+cos(iTime*.2)*3., -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n\n    vec4 hit = March( cam, camdir );\n\n    //vec3 Light = vec3( 20., 30, -30 );\n    vec3 Light = vec3( sin(iTime)*40., 30, -30 );\n    vec3 dir = normalize( Light - hit.xyz );\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, dir );\n    difu = .3 + .7*difu;\n    \n    vec4 shadow0 = March( hit.xyz+dir*.1, dir );\n    if ( shadow0.z > -10. ) difu *= .7;\n\n\nif ( hit.w == 3. ) {\n//shadoff = vec3( sin(iTime*3.)*5., sin(iTime*4.), sin(iTime*2.)*6.);\nshadoff = vec3( 0, -8,-8);\nshadrot = MAT3xy(pow(1.-cos(iTime),5.)*.3);\nwho = false;\n}\n\n    vec4 shadow = March( hit.xyz+dir*.1, dir );\n//shadoff = vec3(0);\n//shadrot = mat3(1,0,0,0,1,0,0,0,1);\n    \n    if ( shadow.z > -10. ) difu = .3;\n    \n    #define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    \n    O = color4(hit.w*.4);\n    \n    // ground pattern\n    if ( hit.w == 3. ) O = mix(O,vec4(0,.3,0,1),clamp(Texture(hit.xz*.1),0.,1.));\n    \n    float occ = calcAO( hit.xyz, norm );\n    \n    O *= difu * occ;\n    \n    // sky pattern\n    //if ( hit.w >= 90. ) O = vec4(.2,.4,.8,1.);\n    if ( hit.w >= 90. ) O=mix(vec4(.2,.4,.8,1.),vec4(1),clamp(height(U*vec2(.01,.1))*10.-9.,0.,1.));\n    \n    O = sqrt(O);\n    \n    float tt=iTime-154.;\n    \n    if ( tt > 0. )\n      O = mix( O, vec4(0), length(uv)*\n        tt*max(1.,tt*20.-200.));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI (3.14159265)\n#define TAU (PI*2.)\n\n#define COS(X) cos(mod(X,TAU))\n#define SIN(X) sin(mod(X,TAU))\n#define SINC(X) (SIN(X)/(X))\n\nint inoisei(int a) {\n  a = (a * 54321) ^ (a * 14873);\n  a ^= a >> 16; // graycode\n  a ^= a >> 8;\n  a ^= a >> 4;\n  a ^= a >> 2;\n  a ^= a >> 1;\n  return a & 65535;\n}  \n\nfloat noisei(int a) {\n  return float( inoisei(a) & 65535 ) / 65536. ;\n}\n\nfloat noise(float a) { return noisei(int(a*1234.)); }\n\n#define RND0(L,H,IN) (noisei(IN)*(H-L)+L)\n#define RND(L,H,IN) (noise(IN)*(H-L)+L)\n\n#define FS iSampleRate\n\nfloat tonnos(float t,float f) {\n    float a = t*f;\n    int b = int(a);\n    return mix(noisei(b),noisei(b+1),smoothstep(0.,1.,fract(a))); // crude filter\n}\n\n\n\n#define FMT(FC,VOL,Q) max( 0., VOL - max(FC/har,har/FC) * Q )\n\nfloat voice(float time,float fc,float f1,float v1,float q1,float f2,float v2,float q2/*,float f3,float v3,float q3*/) {\n  float oo = 0.;\n  int cnt = 0;\n  for ( float har = fc; har < 12e3 && cnt++ < 30; har += fc ) {\n    oo += sin(TAU*time*har) * fc/har * ( \n      FMT(f1,v1,q1)  + FMT(f2,v2,q2)  // + FMT(f2,v2,q2)\n    );\n  }\n  return oo;\n}\n\nfloat voiceN3(float time,float fc1,float fc2,float fc3,float f1,float v1,float q1,float f2,float v2,float q2) {\n  return voice(time,fc1,f1,v1,q1,f2,v2,q2)+voice(time,fc2,f1,v1,q1,f2,v2,q2)+voice(time,fc3,f1,v1,q1,f2,v2,q2);\n}\n\n#define OSC(L,H,F) ((sin(TAU*gtime*(F))+1.)*.5*((H)-(L))+(L))\n\nfloat note(float time,float rep,float phs,float att,float dur,float dec) {\n  float t=mod(time-phs-att,rep);\n  return t<att ? t/att : t<att+dur ? 1. : exp(-(t-att-dur)/dec);\n}\n\nfloat rhyt(float time,float rep,float phs,float dec) {\n  return note(time,rep,phs,.0002,.0,dec);\n}\n\nfloat ramp(float time,float rep,float lo,float hi) {\n  return fract(time/rep)*(hi-lo)+lo;\n}\n\nfloat stair(float val,float rise) {\n  return floor(val/rise)*rise;\n}\n\n\n#define ROUNDTO(X,Y) (round((X)/(Y))*(Y))\n\nfloat tonrmp(float time,float f1,float t1,float f2,float t2) {\n  t1=ROUNDTO(t1,f1);\n  t2=ROUNDTO(t2,f2);\n  return time<t1 ? f1 : \n    time<t2 ? f1+(f2-f1)*(time-t1)/(t2-t1)/2. :\n      f2;\n}\n\n// durations\n\n#define w 1.\n#define h .5\n#define q .25\n#define e .125\n#define x (e/2.)\n\n// 12-tone notes\n#define C D f f\n#define D E f f\n#define E F f\n#define F G f f\n#define G A f f\n#define A 440.\n#define B A s s\n#define X 0\n\n// octaves\n#define L * .5\n#define H * 2.\n\n// accidentals\n#define sh 1.05946\n#define fl 0.9438\n#define s * sh\n#define f * fl\n\n// -----------\n\n// A nod here to https://www.shadertoy.com/view/M32fzK - DerShade\n\nstruct GUIT {\n  float f1, f2, f3, f4, f5, f6;\n  float n1, n2, n3, n4, n5, n6;\n  float vol;\n  float fuz;\n};\n\n#define GUITini(G) \\\n  G.f1=G.f2=G.f3=G.f4=G.f5=G.f6=0.; \\\n  G.n1=G.n2=G.n3=G.n4=G.n5=G.n6=0.; \\\n  G.vol=1.; G.fuz=0.;\n\nfloat pow2n(float i,int n) { while ( --n > 0 ) i *= i; return i; }\n\n#define GNOTE(F,V,N) \\\n  (V) * clamp( SIN( TAU*(N)*(F)*1. + \\\n    (trb+pow2n(V,shp))*ndx * SIN( TAU*(N)*(F) \\\n    ) \\\n  ), fuzb, fuzc )\n\n//       * ( 1. - 1.*COS(TAU*N*1.) ) \\\n\n\n#define GVOL(N) ( (N) <= 0. ? 0. : exp( -1. * (N) ) )\n\nfloat GuitSnd(GUIT g) {\n  float o = 0.;\n  float v;\n  float fuzc = .6;\n  float fuzb = -1.9;\n  float trb = .24;\n  int shp = 5;\n  float ndx = 2.;\n  v = GVOL(g.n1);\n  o += GNOTE(g.f1,v,g.n1);\n  v = GVOL(g.n2);\n  o += GNOTE(g.f2,v,g.n2);\n  v = GVOL(g.n3);\n  o += GNOTE(g.f3,v,g.n3);\n  v = GVOL(g.n4);\n  o += GNOTE(g.f4,v,g.n4);\n  v = GVOL(g.n5);\n  o += GNOTE(g.f5,v,g.n5);\n  v = GVOL(g.n6);\n  o += GNOTE(g.f6,v,g.n6);\n  return clamp( o / 6. * (1.+g.fuz), -1., 1. ) * g.vol;\n}\n\n// finger placement on fret(less)board\n#define GFNG(G,a,b,c,d,e,f) G.f1=a; G.f2=b; G.f3=c; G.f4=d; G.f5=e; G.f6=f;\n\n// strumming - downward\n#define GSTR(G,S) \\\n  G.n1=tim-(S)*0.; G.n2=tim-(S)*1.; G.n3=tim-(S)*2.; \\\n  G.n4=tim-(S)*3.; G.n5=tim-(S)*4.; G.n6=tim-(S)*5.;\n\nfloat guit(float time) {\n\n  float tim = time;\n  float iter = 1.;\n\n// Trying animation sequencing tools for sound ...\n#define WHEN(T,CODE) if ( tim >= 0. && tim < (T) ) { CODE; }\n#define FOR(T,CODE) WHEN(T,CODE) tim -= (T);\n#define REPEAT2(TIME,CNT,CODE) \\\n  if ( tim > 0. ) { if ( tim < (TIME)*(CNT) ) tim = mod(tim,TIME); } \\\n  else tim -= (TIME)*(CNT);\n\n#define REPEAT(TIME,CNT) \\\n  if ( tim > 0. ) { if ( tim < (TIME)*(CNT) ) { iter=floor(tim/TIME); tim = mod(tim,TIME); } } \\\n  else tim -= (TIME)*(CNT);\n#define CHANGE(CODE) if ( tim >= 0. ) { CODE; }\n\n  GUIT g1;\n  GUITini(g1);\n  \n  CHANGE(g1.fuz=0.;g1.vol=3.;)\n\n#define STRUM(G,a,b,c,d,e,f,T,S,EX) \\\n  FOR(T, \\\n    GFNG(G,a,b,c,d,e,f); \\\n    GSTR(G,S); \\\n    EX; \\\n  )\n\n/*\n    E A D G B E\nG   G L,B L,D,G,B,G\nC   E L,C,E,G,C,E\n*/\n\n  //REPEAT(q,1000.)\n  //float shf=1.+SINC(time*123.); // pow(mod(iter*5.,12.),1. s / 12.) L;\n  //STRUM(g1, G*shf L,B*shf L,D*shf,G*shf,B*shf,G*shf,  q,x/4.,)\n  //STRUM(g1, E L,C,E,G,C H,E H, w,x*.5,)\n\n  REPEAT(w*2.,1000.)\n  //REPEAT(w*2.,8.);\n  float shf = mod(iter,8.) > 5. ? 3./4. : 1.;\n  shf *= float[](1.,sh s,3./4.,3./4. s s s)[ int(floor(iter/32.)) % 4 ];\n  FOR(w*2.,\n    GFNG(g1,E L*shf,A L*shf,D*shf,G*shf,B*shf,E H*shf);\n    FOR(q*6., GSTR(g1,q); )\n    FOR(q,)\n    FOR(e, GSTR(g1,0.); )\n    FOR(e, GSTR(g1,0.); g1.vol *= 1.5; )\n  )\n\n  return GuitSnd(g1);\n\n}\n\n// ------------\n\nvec2 mainSound( int samp, float time )\n{\n\n    float vc = 0.;\n    \n    if (time>150.) return vec2(0);\n    \n    \n    float xtime = time ;//- 48.;\n    if ( xtime > 0.) {\n        float yy=0.;  \n        if ( xtime > 8.*1. )\n        yy += tonnos(xtime, noisei(int(xtime/e)) > .5 ? 16000. : 2000.) * rhyt(xtime,e,0.,x*.7);\n        if ( xtime > 8.*0. ) {\n        yy += .8*tonnos(xtime, noisei(1+int(xtime/h)) > .5 ? 400. : 8000.) * rhyt(xtime,q,0.,x);\n        if ( xtime > 8.*2. ) {\n        yy += tonnos(xtime, stair(ramp(xtime+2.,w*2.,20000.,120.),2000.)) * rhyt(xtime,h,0.,q);\n        yy += sin(mod(time*TAU*12000.,TAU)) * rhyt(xtime,w,q+q+q,e);\n        if ( xtime > 8.*3. ) {\n\n        \n \n        xtime=mod(xtime,1.);\n        float fc = 880.;\n        float fc1=fc * (1. + SINC(xtime*40.)*.03*note(time,w*4.,0.,h,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc2=fc * (1. + SINC(xtime*30.)*.03*note(time,w*4.,0.,w,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc3=fc * (1. + SINC(xtime*35.)*.03*note(time,w*4.,0.,h+q,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        yy += .25*voiceN3( xtime,\n                  fc1, fc2*5./4., fc3*1.5,\n                  RND0(200.,1200.,int(time/4.)), //tonnos(time,1./w/8.)*1000.+250.,\n                  4., 3.,\n                  RND0(1200.,4800.,int(time/4.)), //tonnos(time+.1,1./w/8.)*3000.+350.,\n                  4., 3.)\n               * note(time,w*4.,q,q,h,q);\n               \n        } } }\n        vc = mix(vc,yy,1.);//clamp(0.,1.,(time-48.)/6.));\n    }\n    \n    //vc *= .6;\n    vc += guit(time);\n    \n    return .15*vec2(vc);\n}\n","name":"Sound","description":"","type":"sound"}]}