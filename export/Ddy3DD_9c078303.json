{"ver":"0.1","info":{"id":"Ddy3DD","date":"1682808027","viewed":63,"name":"Simple Raymarching Spheres","username":"jsdinnah","description":"My first SDF raymarcher with hard shadow casting :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raycasting","sphere","shadows","specular","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 400\n#define MAX_DIST 100.0\n#define EPSILON 0.01\nconst float CHECKER_SCALE = 4.0;\nconst vec3 FLOOR_COLOR1 = vec3(0.2, 0.2, 0.2);\nconst vec3 FLOOR_COLOR2 = vec3(0.8, 0.8, 0.8);\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r; // distance from the ray position to the sphere surface (with a radius r)\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat worldSDF(vec3 pos) {\n    float sphere = sphereSDF(pos - vec3(0, 2, 6), 1.0); // sphere at (0, 1, 0)\n    float sphere2 = sphereSDF(pos - vec3(17.0 + cos(iTime * 4.0), 1.0 + sin(iTime * 4.0), 40), 0.5); // sphere at (0, 1, 0)\n    float plane = pos.y; // distance from ray to plane. The height of the ray in space\n    return min(min(sphere, sphere2), plane); // return closest value \n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dist;\n        float ds = worldSDF(p);\n        dist += ds;\n        if (dist > MAX_DIST || ds < EPSILON) break;\n    }\n    return dist;\n}\n\nfloat checker(vec2 p) {\n    vec2 cell = floor(p);\n    return mod(cell.x + cell.y, 2.0);\n}\n\nvec3 getCheckerColor(vec3 pos) {\n    float checkered = checker(pos.xz * CHECKER_SCALE);\n    return mix(FLOOR_COLOR1, FLOOR_COLOR2, checkered);\n}\n\nvec3 getNormal(vec3 p) {\n    const float e = 0.00001;\n    const vec2 h = vec2(e, 0);\n    return normalize(vec3(worldSDF(p + h.xyy) - worldSDF(p - h.xyy),\n                          worldSDF(p + h.yxy) - worldSDF(p - h.yxy),\n                          worldSDF(p + h.yyx) - worldSDF(p - h.yyx)));\n}\n\nvec3 getLight(vec3 p) {\n    vec3 lightPos = vec3(0, 7, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 4.0;\n    vec3 l = normalize(lightPos-p); // vector that points from surface to light\n    vec3 n = getNormal(p); // surface normal at point p\n    \n    // diffuse\n    float diff = clamp(dot(n, l)*.5+.5, 0., 1.);\n    \n    //specular\n    vec3 cam = normalize(l - p);\n    vec3 r = reflect(-l, n);\n    float spec = 0.5 * pow(max(dot(cam, r), 0.0), 50.0);\n    \n    \n    // combine\n    vec3 final = (diff + vec3(0.9, 0.5, 0.02) * spec);\n    \n    // calculate hard shadows\n    float d = raymarch(p + n * EPSILON*2.0, l);\n    if (p.y < 0.01 && d < length(lightPos-p)) {\n        final *= 0.5;\n    }\n    \n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalize uv coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0); // black screen\n    \n    vec3 co = vec3(0, 1, 0); // Camera origin with height ch\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); // find the direction of the ray from the camera that passes through the screen plane\n    \n    // diffuse lighting & shadows\n    float d = raymarch(co, rd); // raymarch to get distance from camera to surface\n    if (d < MAX_DIST) { // If ray hit an object\n        vec3 ray = co + rd * d; // get the vector at distance d starting from the camera\n        \n        //col = getNormal(ray);\n        \n        \n        col = getLight(ray); // calculate diffuse lighting & shadows\n        \n        vec3 normal = getNormal(ray);\n        if (normal == vec3(0.0, 1.0, 0.0)) {\n            col *= getCheckerColor(ray);\n        }\n    } else { // If ray hit the sky\n        col = vec3(0.0); // Set the background color to black\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n    ","name":"Image","description":"","type":"image"}]}