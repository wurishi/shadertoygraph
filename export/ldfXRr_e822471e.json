{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//\n//\n// Hyborian Age by cedric voisin 2014\n//\n//\n\n// comment to stop cam motion or night/day cycle\n#define CAM_MOTION\n#define NIGHT_AND_DAY\n\n// in case you turn off day/night cycle, you can choose the hour of the day\n// 0.=dawn, pi/2=noon, pi=dusk, 3pi/2=midnight\n#define dayTimeOrigin .2\n\n// what you see\n#define maxHeight 5.\n#define swampHeight .15\n#define fov 30.\n#define screenWidth 10.\n#define camFocal 10.\n#define camTilt (-.2)\n\n// perf\n#define iLowRes 6\n#define iHighRes 6\n\n// global\nint idI;\n#define idBackground 0\n#define idField 1\n#define idSwamp 2\n#define idSky 3\n#define idClouds 4\n#define idSphere 5\n\nvec3 pCam, nCam, uCam, rCam, pEye;\nfloat thetaCam, phiCam, fCam, rSky;\n\nfloat time;\n#define PI 3.14\n\n//\n// setup routines\n//\n\nvec2 globalSetup(vec2 fragCoord){\n\tvec2 pct = fragCoord.xy / iResolution.xy;\n\tvec2 xy = -screenWidth/2.+screenWidth*pct;\n\txy.y *= iResolution.y/iResolution.x;\n\treturn xy;\n}\n\nvoid setupCam(vec3 p, float thetaCam, float phiCam, float f){\n\tpCam = p;\n\tfCam = f;\n\tnCam = vec3(cos(thetaCam)*cos(phiCam),cos(thetaCam)*sin(phiCam),sin(thetaCam));\n\tuCam = vec3(cos(thetaCam+PI/2.)*cos(phiCam),cos(thetaCam+PI/2.)*sin(phiCam),sin(thetaCam+PI/2.));\n\trCam = cross(nCam,uCam);\n\tpEye = pCam - fCam*nCam;\n}\n\n//\n// perlin\n//\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = screenWidth/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\n//\n// objects\n//\n\n// field(x,y)\nfloat field(vec2 p, int res){\n\tfloat z = maxHeight*pNoise(p, res);\n\treturn z;\n}\n\nfloat iField(vec3 pStart, vec3 dir, int res){\n\tvec3 p = pStart;\n\tfloat s = 0.;\n\tfloat h = 1.;\n\tfor (int i=0; i<250; i++){\n\t\th = p.z - field(p.xy, res);\n\t\tif (h<.1 || length(dir*s) > fov) break;\n\t\ts+=0.1*h;\n\t\tp=pStart+dir*s;\n\t}\n\tif (h >= .1) s = -1.;\n\treturn s;\n}\n\nvec3 nField(vec3 p, int res){\n\tvec2 dp = vec2(.0001,0.);\n\tvec3 dpx = vec3(2.*dp.x, 0., field(p.xy+dp.xy,res)-field(p.xy-dp.xy,res));\n\tvec3 dpy = vec3(0., 2.*dp.x, field(p.xy+dp.yx,res)-field(p.xy-dp.yx,res));\n\treturn normalize(cross(dpx,dpy));\n}\n\n// Swamp\nfloat iSwamp(vec3 pStart, vec3 dir){\n\tfloat s=(swampHeight-pStart.z)/dir.z;\n\tif (length(dir*s) > fov) s=-1.;\n\treturn s;\t\n}\n\n// clouds\nfloat iClouds (vec3 pStart, vec3 dir){\n\tfloat zClouds=15.;\n\tfloat s=(zClouds-pStart.z)/(dir.z+zClouds/fov);\n\tif (length(dir*s) > fov) s=-1.;\n\treturn s;\t\n}\n\n// Sky\nfloat iSky (vec3 dir){\n\tfloat s;\n\tvec3 d = pEye;\n\tfloat B = dot(dir,d);\n\tfloat C = length(d)*length(d)-rSky*rSky;\n\tfloat det2=B*B-C;\n\tif(det2>=0.){\n\t\ts = max(-B+sqrt(det2),-B-sqrt(det2));\n\t} else {\n\t\ts = -1.;\n\t}\n\treturn s;\n}\n\n//\n// routines\n//\n\nfloat shadows(vec3 pi, vec3 pSun) {\n\tfloat L=distance(pi, pSun)/10.;\n\tvec3 dpds=normalize(pSun-pi);\n\t\n\tconst int ni=20;\n\tfloat n=float(ni);\t\n\t\n\tfloat s=0.;\n\tfloat iShad = 1.;\n\t\n\tfor (int i=0;i<ni;i++){\n\t\tvec3 pt = pi+dpds*s;\n\t\tfloat h = pt.z - field(pt.xy, iHighRes);\n\t\ts+=L/n;\n\t\tif(h < 0.5) iShad*=.9;\n\t}\n\t\n\treturn iShad;\n}\n\nvec3 clouds(vec3 p, vec2 wind, vec3 colSky, vec3 colClouds, vec2 fragCoord){\n\tfloat grad=clamp(1.5-fragCoord.y / iResolution.y,0.,1.);\n\tvec2 stretch = vec2 (3.,1.);\n\treturn grad*mix(colSky, colClouds,field(.1*(p.xy+wind)*stretch,5));\n}\n\nfloat intersection(vec3 p, vec3 d, vec3 pLight, int res){\n\tfloat sit = 1000.*fov;\n\t\n\tidI = idBackground;\n\tfloat si = sit;\n\t\n\tsit = min(iField(p, d, res), si);\n\t\tif (sit >= 0. && sit < si){\n\t\tidI = idField;\n\t\tsi = sit;\n\t}\n\t\n\tsit = min(iSwamp(p, d), si);\n\t\tif (sit >= 0. && sit < si){\n\t\tidI = idSwamp;\n\t\tsi = sit;\n\t}\n\t\n\tsit = min(iClouds(p, d), si);\n\t\tif (sit >= 0. && sit < si){\n\t\tidI = idClouds;\n\t\tsi = sit;\n\t}\n\n\treturn si;\n}\n\n//\n// at last :-)\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // constants\n    time = iTime;\n    //\n    \n\tvec2 xy = globalSetup(fragCoord);\n\tfloat si;\n\t\n\t// time\n\tfloat camTime = 0.;\n\tfloat dayTime = dayTimeOrigin;\n\t#ifdef CAM_MOTION\n\t\tcamTime = .03*time;\n\t#endif\n\t#ifdef NIGHT_AND_DAY\n\t\tdayTime = .2*time+dayTimeOrigin;\n\t#endif\n\t\n\t// cam\n\tfloat zoCam = swampHeight + screenWidth*iResolution.y/iResolution.x;\n\tfloat camOrbit = 100.;\n\tfloat xCam = camOrbit*sin(camTime);\n\tfloat yCam = -camOrbit*cos(camTime);\n\tsetupCam(vec3 (xCam,yCam,zoCam),camTilt,camTime,camFocal);\n\t\n\t// sun\n\tfloat sunOrbit=2.*camOrbit;\n\trSky = sunOrbit;\n\tvec3 pSun = vec3(1.5*sunOrbit*sin(dayTime),sunOrbit*cos(dayTime),sunOrbit*sin(dayTime));\n\t\n\t// wind\t(speed)\n\tvec2 wind = vec2 (1.,-5.);\n\t\n\t// virtual screen\n\tvec3 pStart = pCam+xy.x*rCam+xy.y*uCam;\n\tvec3 dir = normalize(pStart-pEye);\n\t\n\t// ray march\n\tsi = intersection(pStart, dir, pSun, iLowRes);\n\tvec3 pi = pStart + dir*si;\n\tvec3 nor = nField(pi, iHighRes);\n\tvec3 norLowRes = nField(pi, iLowRes);\n\t\n\t// colors\n\tvec3 col = vec3(0.,0.,0.);\n\tvec3 colSky = vec3(.2,.5,1.);\n\tfloat redishClouds = pow(1.2-abs(pSun.y/sunOrbit),.5);\n\tvec3 colClouds = vec3(1.,1.*redishClouds,.9*redishClouds);\n\tvec3 colSun = vec3 (1.,1.,.7);\n\tvec3 colGrass = vec3(.1,.4,.1);\n\tvec3 colMountain = vec3(.7,.6,.5);\n\tvec3 colFog = vec3(.5,.6,.7);\n\tvec3 colField = colMountain;\n\tif (nor.z > .8) colField = colGrass;\n\t\n\t// night and day corrections\n\tcolSky*=smoothstep(-1.2,1.,sin(dayTime));\n\tcolFog*=smoothstep(-1.2,1.,sin(dayTime));\n\t\n\t// illuminations\n\tif (idI == idBackground){ // in principle, never used here\n\t\tfloat cBg=clamp(1.5-fragCoord.y / iResolution.y,0.,1.);\n\t\tcol += cBg*colSky;\n\t\tcol = mix (colSky, vec3(1.,1.,1.),field(xy,7));\n\t}\n\t\n\tif (idI == idField){\n\t\tfloat iShad = shadows(pi, pSun);\n\t\tfloat iSpec=.5+.5*dot(nField(pi, iHighRes),normalize(pSun-pi));\n\n\t\t// AO\n\t\tvec3 p;\n\t\tfloat sAmb=0.;\n\t\tfloat iAmb = 1.;\n\t\tfor (int i=0;i<5;i++) {\n\t\t\tfloat h = p.z - field (p.xy, iLowRes);\n\t\t\tif (h < sAmb) iAmb*=.8;\n\t\t\tsAmb+=float(i)*.2;\n\t\t\tp = pi + norLowRes*sAmb;\n\t\t}\n\n\t\tcol += .2*iSpec*colSun;\n\t\tcol += .2*nor.z*colSky;\n\t\tcol += iSpec*colField;\n\t\tcol *=iShad;\n\t\tcol *=iAmb;\n\t\tcol += .4*iSpec*colField*smoothstep(-.3,1.,sin(dayTime+PI)); // night light\n\t\t\n\t\tcol = smoothstep(0.,1.2,col);\n\t}\n\t\n\tif (idI == idSwamp){\t\t\n\t\tfloat iShad = shadows(pi, pSun);\n\t\t\n\t\t// clouds for fake reflection\n\t\tcol += clouds(pi, wind*time, colSky, colClouds, fragCoord);\n\t\t\n\t\t// moisture\n\t\tcol += 3.*mix (vec3(0.,.1,0.), vec3(.4,.7,.4),20.*pNoise(pi.xy,7));\n\t\t\n\t\t// foam\n\t\tcol += 1.*mix (vec3(0.,0.,0.), vec3(.9,1.,.9),pNoise(5.*pi.xy,7));\n\t\t\n\t\tcol *= iShad;\n\t\tcol = smoothstep(0.,3.,col);\n\t}\n\n\tif (idI == idClouds){\n\t\t// clouds\n\t\tvec3 colCloudsInSky = clouds(pi, wind*time, colSky, colClouds, fragCoord);\n\t\t\n\t\t// sky (sphere)\n\t\tfloat siSky = iSky(dir);\n\t\tvec3 piSky = pStart + dir*siSky;\n\t\tfloat theta = acos(piSky.z/rSky);\n\t\tfloat phi = abs(atan(piSky.y, piSky.x)); // symmetric sky because perlin(2pi)!=perlin(0)\n\t\tvec3 colSkySphere = mix(colSky, vec3(.05,.1,.3),field(20.*vec2(theta, phi),7));\n\t\t\n\t\t// stars\n\t\tfloat pN = pNoise(2000.*vec2(theta, phi),5);\n\t\tcolSkySphere += mix(colSky, vec3(1.,1.,1.),pN);\n\n\t\tcol = mix(colCloudsInSky, colSkySphere, smoothstep(-.5,2.,sin(dayTime+PI)));\n\t}\n\t\n\t// fog\n\tfloat cFog = 1.-smoothstep(.3*fov, fov, length(dir*si))+smoothstep(fov+1., fov+2.,length(dir*si));\n    col = mix(colFog, col, cFog );\n\n\tcol = clamp(col,0.,1.);\n\tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldfXRr","date":"1396281229","viewed":686,"name":"Hyborian Age","username":"cedric","description":"use and abuse of perlin noise^^\ni learned and stole from many shaders here and iq's website. Thanks to all !","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","terrain","perlin"],"hasliked":0,"parentid":"","parentname":""}}