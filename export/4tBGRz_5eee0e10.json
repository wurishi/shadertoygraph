{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float scl;\n\nfloat det(mat2 A) {\n    return A[0][0]*A[1][1] - A[1][0]*A[0][1];\n}\n\nvec2 warp(vec2 p) {\n\t\n\tvec2 o = vec2(4.0*cos(iTime), 4.0*sin(2.0*iTime));\n\t\n\tvec2 po = p-o;\n\tfloat r2 = dot(po,po);\n\tfloat dr = -0.7*exp(-r2/16.0);\n\treturn p + dr*po;\n\n}\n\n// change #if 0 to #if 1 to use built-in differencing\nmat2 jacWarp(vec2 p) {\n#if 0\n    return mat2(dFdx(warp(p)), dFdy(warp(p)))/scl;\n#else    \n\tvec2 h = vec2(0.001, 0.0);\n\tvec2 jx = (warp(p+h.xy) - warp(p-h.xy))/(2.0*h.x);\n\tvec2 jy = (warp(p+h.yx) - warp(p-h.yx))/(2.0*h.x);\n\treturn mat2(jx, jy);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    scl = 30.0 / iResolution.x;\n\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * scl;\n\t\n\tmat2 J = jacWarp(uv);\n\n    uv = warp(uv);\n\tfloat dJ = abs(det(J));\n\t\t\n\tuv = (fract(uv + 0.5) - 0.5);\n\t\n\tconst float rad = 2.0;\n\tfloat d = smoothstep((rad)*scl, (rad+1.0)*scl, length(uv)/sqrt(dJ));\n\tvec2 g = smoothstep(0.5*scl, 1.5*scl, abs(uv)/sqrt(dJ));\n\t\n\tfragColor.xyz = min(vec3(d), vec3(g.x, min(g.x, g.y), g.y));\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tBGRz","date":"1426462510","viewed":904,"name":"smooth warp","username":"mattz","description":"playing around to get correct antialiasing using partial derivatives of a warp based on finite differencing","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["grid","warp","finitedifferences"],"hasliked":0,"parentid":"","parentname":""}}