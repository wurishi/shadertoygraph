{"ver":"0.1","info":{"id":"3sGXDV","date":"1617390432","viewed":463,"name":"Raymarching SDF from a Cubemap","username":"edubart","description":"\nThis is an experiment of saving a SDF into a Cubemap so we can later raymarch it.\n\nIn blue the SDF defined by a function is raymarched.\nIn gray an SDF cached into cubemap is raymarched.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is an experiment of saving a SDF into a Cubemap.\n\nIn blue the SDF defined by a function is raymarched.\nIn gray a an SDF cached into cubemap is raymarched.\n\nHow it works:\nFirst the SDF is projected into the Cunemap and cached.\nLater instead of raymarching the scene SDF function, we raymarch the Cubemap.\n\nThe cubemap store the distance and normals that each projected ray goes towards.\nWe use that information to \"raymarch\" inside the cubemap, updating the distance every step.\n\nThis could be used to store SDF into Cubemaps as an optimization,\nbut there are major drawbacks, as this can't store holes or surfaces behind another,\na 3D texture would be needed for that.\n*/\n\n#define COMPARE\n\nfloat sd_cubemap(vec3 p) {\n    float d = textureLod(iChannel0, p, 0.0).w;\n    d -= 1.0 - length(p);\n    d *= 0.3;\n    return d;\n}\n\nfloat map2(vec3 p) {\n    float d = sd_sphere(p, 1.0);\n    if(d < BOX_DIST) {\n        d = sd_cubemap(p);\n#ifdef COMPARE\n        if(p.x < 0.0)\n        \td = map(p);\n#endif\n    }\n    return d;\n}\n\nvec3 getnormal2(vec3 p) {\n    return textureLod(iChannel0, p, 0.0).rgb;\n}\n\nfloat raymarch2(vec3 ro, vec3 rd) {\n    float t = SURF_DIST;\n    vec3 p;\n    for(int i=0;i<IMAGE_MAX_STEPS;++i) {\n        p = ro + rd * t;\n        float d = map2(p);\n        if(abs(d) < SURF_DIST)\n            break;\n        t += d;\n        if(t > MAX_DIST)\n            break;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(vec3(uv,-5.5));\n\tvec3 ro = vec3(0.,2.0,3.);\n    \n    float angle = 1.5*TAU * iMouse.x / iResolution.x + iTime;\n    rd.yz = rotate2d(rd.yz, TAU/11.);\n    ro.xz = rotate2d(ro.xz, -angle);\n    rd.xz = rotate2d(rd.xz, -angle);\n    \n    float t = raymarch2(ro, rd);\n    vec3 col = vec3(0.003);\n    if(t < MAX_DIST) {\n        vec3 p = ro + rd*t;\n    \tvec3 n = getnormal2(p);\n        col = vec3(0.5,0.5,0.5);\n#ifdef COMPARE\n        if(p.x < 0.0) {\n            n = getnormal(p);\n            col = vec3(0.1,0.1,1.0);\n        }\n#endif\n        vec3 ld = normalize(vec3(0.0, 1.0, 0.5));\n        float dif = clamp(dot(n, ld), 0.0, 1.0) + 0.3;\n        col *= dif;\n    }\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define CUBE_MAX_STEPS 128\n#define IMAGE_MAX_STEPS 128\n#define SURF_DIST 0.0001\n#define BOX_DIST 0.01\n#define MAX_DIST 10.0\n#define NORMAL_EPS 0.003\n#define PI  3.141592653589793\n#define TAU 6.283185307179586\n#define CUBEMAP_CACHE\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n  \tvec3 q = abs(p) - b;\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 rotate2d(vec2 p, float x) {\n    float s = sin(x), c = cos(x);\n    return mat2(c,-s,s,c) * p;\n}\n\nfloat map(vec3 p) {\n    p.x = abs(p.x);\n    float d = sd_sphere(p, 0.25);\n    vec3 q = abs(p - vec3(0.2, 0.15, 0.0));\n    d = min(d, sd_sphere(q, 0.12));\n    q = abs(p - vec3(0.11, 0.10, 0.16));\n    d = min(d, sd_sphere(q, 0.09));\n    q = abs(p - vec3(0.12, 0.12, 0.28));\n    d = max(d, -sd_sphere(q, 0.05));\n    q = abs(p - vec3(0.01, 0.0, 0.32));\n    d = max(d, -sd_sphere(q, 0.1));\n    return d;\n}\n\nvec3 getnormal(vec3 p) {\n    const float eps = NORMAL_EPS;\n    vec2 e = vec2(1.,-1.);\n    return normalize(e.xyy*map(p + e.xyy*eps) + \n                     e.yyx*map(p + e.yyx*eps) + \n                     e.yxy*map(p + e.yxy*eps) + \n                     e.xxx*map(p + e.xxx*eps));\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = SURF_DIST;\n    vec3 p;\n    for(int i=0;i<CUBE_MAX_STEPS;++i) {\n        p = ro + rd * t;\n        float d = map(p);\n        if(abs(d) < SURF_DIST)\n            break;\n        t += d;\n        if(t > MAX_DIST)\n            break;\n    }\n    return t;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n#ifdef CUBEMAP_CACHE\n    if(iFrame > 0) {\n        fragColor = textureLod(iChannel0, rayDir, 0.);\n        return;\n    }\n#endif\n    vec3 ro = normalize(rayDir);\n    vec3 rd = -normalize(rayDir);\n    float t = raymarch(ro, rd);\n    vec3 n = getnormal(ro + rd*t);\n    fragColor.w = t;\n    fragColor.rgb = n;\n}","name":"Cube A","description":"","type":"cubemap"}]}