{"ver":"0.1","info":{"id":"Msscz7","date":"1487606923","viewed":548,"name":"Fusioned Bismuth","username":"gam0022","description":"TokyoDemoFest 2017 GLSL Graphics Compo 3rd place\nhttp://gam0022.net/webgl/#raymarching_tdf2017","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Title: Fusioned Bismuth (TokyoDemoFest 2017 GLSL Graphics Compo 3rd place)\n// Copyright (c) 2017 gam0022\n// License: Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n//\n// Thanks\n// - DE used folding by gaz (https://www.shadertoy.com/view/Mlf3Wj)\n// - Just snow by baldand (https://www.shadertoy.com/view/ldsGDn)\n// - Sky and Ground by morgan3d (https://www.shadertoy.com/view/4sKGWt)\n\nprecision highp float;\n\n#define DEBUG 0\n#define SHADER_TOY 1\n\n// uniforms\n#if SHADER_TOY == 0\nuniform float iTime;\nuniform vec2 iMouse;\nuniform vec2 iResolution.xy;\n#endif\n\n// debug for camera\n#if DEBUG\nuniform bool debugCamera;\nuniform vec3 cameraPos;\nuniform vec3 cameraDir;\n#endif\n\n// consts\nconst float INF = 1e+10;\nconst float EPS = 1e-2;\nconst float EPS_N = 1e-3;\nconst float OFFSET = EPS * 100.0;\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float PIH = 1.57079632679;\nconst float PIQ = 0.78539816339;\n\n\n// globals\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\nfloat lTime;\n\n// ray\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\n// camera\nstruct Camera {\n\tvec3 eye, target;\n\tvec3 forward, right, up;\n\tfloat zoom;\n};\n\nRay cameraShootRay(Camera c, vec2 uv) {\n    c.forward = normalize(c.target - c.eye);\n    c.right = normalize(cross(c.forward, c.up));\n    c.up    = normalize(cross(c.right, c.forward));\n\n    Ray r;\n    r.origin = c.eye;\n    r.direction = normalize(uv.x * c.right + uv.y * c.up + c.zoom * c.forward);\n\n    return r;\n}\n\n// intersection\nstruct Intersection {\n\tbool hit;\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n\tvec2 uv;\n\tfloat count;\n\n\t//int material;\n\tvec3 color;\n\tfloat metalness;\n};\n\n//#define METAL_MATERIAL   0\n//#define MIRROR_MATERIAL  1\n\n\n// util\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// https://www.shadertoy.com/view/4sKGWt\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\n\tp.xy += 0.1 * lTime;\n\n\tfloat f = 0.5000 * noise(p); p = m2 * p * 2.02;\n\tf += 0.2500 * noise(p); p = m2 * p * 2.03;\n\tf += 0.1250 * noise(p); p = m2 * p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\nfloat easeInCubic( float t ) {\n\treturn t * t * t;\n}\n\nfloat easeInOutCubic(float t) {\n\treturn t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n}\n\nfloat gauss(float x) {\n\tfloat a = 50.0;\n\treturn exp(-x * x / a);\n}\n\n\n// Distance Functions\n\n// operations\n//vec3 opRep( vec3 p, float interval ) {\n//\treturn mod( p, interval ) - 0.5 * interval;\n//}\n#define opRep(p, interval) (mod(p, interval) - 0.5 * interval)\n\n//vec2 opRepLimit(vec2 p, float interval, float limit) {\n//\treturn mod(clamp(p, -limit, limit), interval) - 0.5 * interval;\n//}\n#define opRepLimit(p, interval, limit) (mod(clamp(p, -limit, limit), interval) - 0.5 * interval)\n\n// https://www.shadertoy.com/view/Mlf3Wj\nmat2 rotate(in float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 fold(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\nfloat smin(float d1, float d2, float k) {\n\tfloat h = exp(-k * d1) + exp(-k * d2);\n\treturn -log(h) / k;\n}\n\n// Distance Functions\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat dBar( vec2 p, float interval, float width) {\n\treturn length( max( abs( opRep( p, interval ) ) - width, 0.0 ) );\n}\n\n\n#define META_SCENE_END_TIME (32.0)\n#define UFO_SCENE_END_TIME (117.0)\n#define SNOW_SCENE_END_TIME (182.0)\n\nfloat dFract(inout vec3 p) {\n\tfloat radius = 1.0;\n\tfloat radiusScale = 0.45 * abs(sin(0.3 * lTime));\n\tfloat d = sdBox(p, vec3(radius));\n\tfor (int i = 0; i < 5; i++) {\n\t\tvec3 q = abs(p) + normalize(vec3(-1.0)) * radius * (1.0 + radiusScale);\n\t\td = min(d, sdBox(p, vec3(radius)));\n\t\tp = q;\n\t\tradius *= radiusScale;\n\t}\n\treturn d;\n}\n\nfloat dTree(vec3 p) {\n\tfloat scale = 0.6 * saturate(1.5 * sin(0.05 * (lTime - UFO_SCENE_END_TIME - 2.0)));\n\tfloat width = mix(0.3 * scale, 0.0, saturate(p.y));\n\tvec3 size = vec3(width, 1.0, width);\n\tfloat d = sdBox(p, size);\n\tfor (int i = 0; i < 10; i++) {\n\t\tvec3 q = p;\n\t\tq.x = abs(q.x);\n\t\tq.y -= 0.5 * size.y;\n\t\tq.xy *= rotate(-1.2);\n\t\td = min(d, sdBox(p, size));\n\t\tp = q;\n\t\tsize *= scale;\n\t}\n\treturn d;\n}\n\nfloat dSnowCrystal(inout vec3 p) {\n\tp.xy = fold(p.xy, 6.0);\n\treturn dTree(p);\n}\n\nfloat dMix(inout vec3 p) {\n\tfloat sphere = dSphere(p, 1.5);\n\tfloat box = sdBox(p, vec3(1.1));\n\tfloat d = mix(sphere, box, 0.5 + clamp(sin(PIQ * lTime), -0.5, 0.5));\n\treturn d;\n}\n\nfloat dMeta(inout vec3 p) {\n\t// copy from cameraControl\n\tvec3 target = vec3(0.0);\n\tfloat t1 = lTime - META_SCENE_END_TIME;\n\ttarget.y = clamp(-0.7 * t1, -2.8, 100.0);\n\n\tfloat a = max(0.0, 2.0 - lTime * 0.1) + cos(lTime * 0.3);\n\tfloat b = 0.2 * sin(lTime);\n\tfloat d1 = dSphere(p - target - vec3(a, 0, b), 1.0);\n\tfloat d2 = dSphere(p - target + vec3(a, 0, b), 1.0);\n\tfloat d = smin(d1, d2, 1.0);\n\treturn d;\n}\n\nfloat hWave(vec2 p, float t) {\n\tfloat h = 1.0;\n\tfloat a = 1.0;\n\tfloat b = 6.0;\n\n\tfor(float i = 0.0; i < 3.0; i++) {\n\t\tfloat f = pow(2.0, i);\n\t\th += 1.0 / f * (sin(f * a * p.x + b * t) + sin(f * a * p.y + b * t));\n\t}\n\n\treturn h;\n}\n\nfloat dWing(in vec3 p) {\n\tfloat t = lTime - META_SCENE_END_TIME;\n\tfloat l = length(p.xz);\n\tfloat fusion = gauss((lTime - META_SCENE_END_TIME - 5.0) * 2.0);\n\n\tfloat a = 0.1 + 0.06 * (1.0 + sin(PI * t + l));\n\tfloat b = min(0.2 * t, 10.0) * gauss(l) + 0.1 * fusion * hWave(p.xz, t);\n\tp.y += -b + 15.0;\n\n\tvec3 p1 = p;\n\tp1.xz = opRepLimit(p.xz, 1.0, 20.0);\n\n\tvec3 p2 = p;\n\tp2 = opRep(p, 0.5);\n\n\tfloat d =   sdBox(p1, vec3(0.2 + a * 3.0, 12.0 - a,       0.2 + a));\n\td = min(d,  sdBox(p1, vec3(0.4 - a,       13.0 - 4.0 * a, 0.1 + a)));\n\td = max(d, -sdBox(p1, vec3(0.3 - a,       14.0 - 4.0 * a, a)));\n\td = max(d, -sdBox(p2, vec3(0.8 * a, 1.0 - a, 0.8 * a)));\n\treturn d;\n}\n\nfloat dUfo(inout vec3 p) {\n\tfloat t = max((lTime - META_SCENE_END_TIME - 10.0) * 0.5, 1.0);\n\tfloat t1 = floor(t);\n\tfloat t2 = t1 + easeInOutCubic(t - t1);\n\n\tp.xz = fold(p.xz, min(t2, 10.0));\n\tp.z -= 0.5;\n\n\tfloat d = dWing(p);\n\t//float t3 = lTime - META_SCENE_END_TIME;\n\t//if (t3 < 10.0) {\n\t//\td -= mix(0.08, 0.0, saturate(t3 * 0.1)) * fbm(10.0 * p.xz + 5.0 * p.y);\n\t//}\n\treturn d;\n}\n\nfloat dScene(vec3 p) {\n\tif (lTime < UFO_SCENE_END_TIME - 2.0) {\n\t\tfloat d = dMeta(p);\n\t\td = smin(d, dUfo(p), clamp(lTime - META_SCENE_END_TIME, 1.0, 15.0));\n\t\treturn d;\n\t} else {\n\t\t//return dFract(p);\n\t\treturn dSnowCrystal(p);\n\t}\n}\n\nfloat dSceneBump(vec3 p) {\n\tfloat d = dScene(p);\n\n\tfloat t3 = lTime - META_SCENE_END_TIME;\n\tif (t3 < 10.0) {\n\t\td -= mix(0.08, 0.0, saturate(t3 * 0.1)) * fbm(10.0 * p.xz + 5.0 * p.y);\n\t}\n\n\treturn d;\n}\n\n\n// color functions\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, saturate(p - K.xxx), c.y);\n}\n\n//vec3 calcNormal( vec3 p ) {\n//\tvec2 e = vec2( 1.0, -1.0 ) * 0.001;\n//\treturn normalize(\n//\t\te.xyy * dScene( p + e.xyy ) + e.yyx * dScene( p + e.yyx ) +\n//\t\t\te.yxy * dScene( p + e.yxy ) + e.xxx * dScene( p + e.xxx ) );\n//}\n\n#define calcNormal(p, dFunc) normalize(vec2(EPS_N, -EPS_N).xyy * dFunc(p + vec2(EPS_N, -EPS_N).xyy) + vec2(EPS_N, -EPS_N).yyx * dFunc(p + vec2(EPS_N, -EPS_N).yyx ) + vec2(EPS_N, -EPS_N).yxy * dFunc(p + vec2(EPS_N, -EPS_N).yxy) + vec2(EPS_N, -EPS_N).xxx * dFunc(p + vec2(EPS_N, -EPS_N).xxx))\n\nfloat calcRate(float a, float b) {\n\treturn a / (a + b);\n}\n\nvoid setMaterialAndUv(inout Intersection intersection, vec3 p) {\n\t//intersection.material = METAL_MATERIAL;\n\n\tfloat d1 = dUfo(p);\n\tfloat d2 = dMeta(p);\n\tfloat rate = calcRate(abs(d1), abs(d2));\n\tintersection.metalness = rate;\n\n\tfloat t = lTime - META_SCENE_END_TIME;\n\tintersection.metalness = mix(intersection.metalness, 1.0, saturate(t * 0.05));\n\tintersection.metalness = mix(intersection.metalness, 2.0, gauss((t - 13.0) * 3.0));\n\n\t//if ( false && lTime <= META_SCENE_END_TIME ) {\n\t//\tintersection.material = MIRROR_MATERIAL;\n\t//} else {\n\t//\tdUfo(p);\n\t//\tintersection.material = METAL_MATERIAL;\n\t//\tintersection.uv = p.xz;\n\t//}\n}\n\nvoid intersectScene(inout Intersection intersection, inout Ray ray ) {\n\tfloat d;\n\tintersection.distance = 0.0;\n\tvec3 p = ray.origin;\n\n\tfor (float i = 0.0; i < 128.0; i++) {\n\t\td = dScene(p);\n\t\tintersection.distance += d;\n\t\tp = ray.origin + intersection.distance * ray.direction;\n\t\tintersection.count = i;\n\t\tif (abs(d) < EPS || intersection.distance > 100.0) break;\n\t}\n\n\tif (abs(d) < EPS) {\n\t\tintersection.hit = true;\n\t\tintersection.position = p;\n\t\tintersection.normal = calcNormal(p, dScene);\n\t\tsetMaterialAndUv(intersection, p);\n\t}\n}\n\nfloat calcAo(in vec3 p, in vec3 n){\n\tfloat sca = 1.0, occ = 0.0;\n\tfor(float i=0.; i<5.; i++){\n\t\tfloat hr = 0.05 + i * 0.08;\n\t\tfloat dd = dScene(n * hr + p);\n\t\tocc += (hr - dd) * sca;\n\t\tsca *= 0.5;\n\t}\n\treturn saturate(1.0 - occ);\n}\n\nfloat calcShadow(in vec3 p, in vec3 rd) {\n\tfloat d;\n\tfloat distance = OFFSET;\n\tfloat bright = 1.0;\n\tfloat shadowIntensity = 0.5;\n\tfloat shadowSharpness = 16.0;\n\n\tfor (int i = 0; i < 30; i++) {\n\t\td = dScene(p + rd * distance);\n\t\tif (d < EPS) return shadowIntensity;\n\t\tbright = min(bright, shadowSharpness * d / distance);\n\t\tdistance += d;\n\t}\n\n\treturn shadowIntensity + (1.0 - shadowIntensity) * bright;\n}\n\n\n// Just snow by baldand \n// https://www.shadertoy.com/view/ldsGDn\n#define LAYERS 50\n#define DEPTH .5\n#define WIDTH .3\n#define SPEED .6\n\nfloat screenSpaceSnow(vec2 uv) {\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tfloat acc = 0.0;\n\tfloat dof = 5.*sin(lTime*.1);\n\tfor (int i=0;i<LAYERS;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uv*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*lTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\ts += .01*abs(2.*fract(10.*q.yx)-1.);\n\t\tfloat d = .6*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .005+.05*min(.5*abs(fi-5.-dof),1.);\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/(1.+.02*fi*DEPTH));\n\t}\n\treturn acc;\n}\n\nvoid calcRadiance(inout Intersection intersection, inout Ray ray, int bounce) {\n\tintersection.hit = false;\n\tintersectScene(intersection, ray);\n\n\tif ( intersection.hit ) {\n\t\tfloat diffuse = clamp(dot(lightDir, intersection.normal), 0.2, 1.0) * 0.5 + 0.5;\n\t\tfloat specular = pow(saturate(dot(reflect(lightDir, intersection.normal), ray.direction)), 10.0);\n\t\tfloat ao = calcAo(intersection.position, intersection.normal);\n\t\tfloat shadow = calcShadow(intersection.position, lightDir);\n\n\t\tvec3 fleshNormal = calcNormal(intersection.position, dSceneBump);\n\t\tfloat fleshDiffuse = clamp(dot(lightDir, fleshNormal), 0.2, 1.0) * 0.5 + 0.5;\n\t\tvec3 fleshBase =  mix(vec3(1.0, 0.2, 0.2), vec3(0.3, 0.0, 0.0), fbm(2.0 * intersection.position.xz));\n\t\tvec3 flesh = fleshBase * fleshDiffuse * ao * shadow + 0.1 * specular;\n\n\t\tfloat v = (META_SCENE_END_TIME <= lTime && lTime <= UFO_SCENE_END_TIME) ? 0.8 : 0.5;\n\t\tvec3 metalBase = hsv2rgb(vec3(0.1 * intersection.count, 0.3 * sin(lTime), v));\n\t\tvec3 metal = metalBase * diffuse * ao * shadow + 0.1 * specular;\n\n\t\tintersection.color = mix(flesh, metal, intersection.metalness);\n\t\tintersection.normal = mix(fleshNormal, intersection.normal, intersection.metalness);\n\n\t\t// fog\n\t\tintersection.color = mix(intersection.color, 0.8 * vec3(0.7, 0.75, 0.8), min(1.0, pow(0.02 * intersection.distance, 2.0)));\n\t} else {\n\t\tvec3 sunnySky = vec3(0.4, 0.55, 0.8);\n\t\tvec3 cloudySky = vec3(0.7);\n\t\tvec3 cloud = vec3(1.0, 0.95, 1.0);\n\t\tvec3 base = mix(sunnySky, cloudySky, step(UFO_SCENE_END_TIME - 20.0, lTime)) * (1.0 - 0.8 * ray.direction.y) * 0.9;\n\n\t\t// Sun\n\t\tfloat sundot = saturate(dot(ray.direction, lightDir));\n\t\tbase += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 8.0);\n\t\tbase += 0.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 64.0);\n\n\t\t// Clouds\n\t\tfloat rd = ray.direction.y + 0.3;\n\t\tintersection.color = mix(base, cloud, 0.5 *\n\t\t\tsmoothstep(0.5, 0.8, fbm((ray.origin.xz + ray.direction.xz * (250000.0 - ray.origin.y) / rd) * 0.000008)));\n\n\t\tintersection.color = mix(intersection.color, vec3(0.7, 0.75, 0.8), pow(1.0 - max(rd, 0.0), 4.0));\n\t}\n\n\t// Whiteout\n\t//intersection.color = mix(intersection.color, vec3(1.0), gauss((lTime - UFO_SCENE_END_TIME) * 1.0));\n\tintersection.color = mix(intersection.color, vec3(1.0), gauss((lTime - SNOW_SCENE_END_TIME) * 0.5));\n}\n\nvoid cameraControl(inout Camera camera) {\n\t// iTime\n\tfloat t1 = lTime - META_SCENE_END_TIME;\n\tfloat t2 = t1 - 25.0;\n\tfloat t3 = t2 - 16.0;\n\tfloat t4 = t3 - 20.0;\n\n\tfloat t5 = lTime - UFO_SCENE_END_TIME;\n\tfloat t6 = t5 - 7.0;\n\tfloat t7 = t6 - 10.0;\n\n\t// blend\n\n\t// ufo\n\tfloat b1 = easeInOutCubic(saturate(t1 * 0.2));\n\tfloat b2 = easeInOutCubic(saturate(t2 * 0.4));\n\tfloat b3 = easeInOutCubic(saturate(t3 * 0.4));\n\tfloat b4 = easeInOutCubic(saturate(t4 * 0.2));\n\n\t// snow\n\tfloat b5 = easeInOutCubic(saturate(t5 * 0.2));\n\tfloat b6 = easeInOutCubic(saturate(t6 * 0.5));\n\tfloat b7 = easeInOutCubic(saturate(t7));\n\n\t// camera target\n\tcamera.target = vec3(0.0);\n\n\tcamera.target.y = clamp(-0.7 * t1, -2.8, 100.0);\n\tcamera.target.y = mix(camera.target.y, 1.0 + t2 * 0.3, b2);\n\tcamera.target.y = mix(camera.target.y, 0.0, b3);\n\tcamera.target.y = mix(camera.target.y, 0.0 + 0.6 * t4, b4);\n\n\tcamera.target.y = mix(camera.target.y, 0.0, b5);\n\tcamera.target.x = mix(camera.target.x, -0.7, b6);\n\tcamera.target.x = mix(camera.target.x, 0.0, b7);\n\n\t// camera position\n\tvec3 p0 = camera.target + vec3(0.0, 0.0, -5.0); // down\n\tvec3 p1 = vec3(1.0, 0.3 * abs(t1 - 0.5), 1.0);  // look down\n\tvec3 p2 = vec3(2.5 + t2 * 0.9, 0.5 + t2 * 0.1, 0.0); // side\n\tvec3 p3 = vec3(0.01, 4.0 + t3 * 0.2, 0.0); // zoom\n\tvec3 p4 = vec3(1.5, 10.0 + t4 * 0.1, 2.0); // leave\n\n\tvec3 p5 = vec3(0.0, 0.1, 6.0 - t5 * 0.3);\n\tfloat v = 0.3 + t5 * 0.07;\n\tvec3 p6 = vec3(1.7 * cos(v) - 1.0, 0.1, (0.5 + t6 * 0.01) * sin(v));\n\tvec3 p7 = vec3(0.0, 0.0, 0.5 + t7 * 0.1);\n\n\tcamera.eye = mix(p0,         p1, b1);\n\tcamera.eye = mix(camera.eye, p2, b2);\n\tcamera.eye = mix(camera.eye, p3, b3);\n\tcamera.eye = mix(camera.eye, p4, b4);\n\tcamera.eye = mix(camera.eye, p5, b5);\n\tcamera.eye = mix(camera.eye, p6, b6);\n\tcamera.eye = mix(camera.eye, p7, b7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// local iTime\n\tlTime = mod(iTime, SNOW_SCENE_END_TIME + 1.0);\n\n\t// fragment position\n\tvec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / min( iResolution.xy.x, iResolution.xy.y );\n\n\t// camera and ray\n\tCamera camera;\n\tcameraControl(camera);\n#if DEBUG\n\tif (debugCamera) {\n\t\tcamera.eye    = cameraPos;\n\t\tcamera.target = cameraPos + cameraDir;\n\t}\n#endif\n\n\tcamera.up = vec3(0.0, 1.0, 0.0);// y-up\n\tcamera.zoom = 1.3;\n\tRay ray = cameraShootRay(camera, uv);\n\n\tvec3 color = vec3(0.0);\n\tfloat reflection = 1.0;\n\tIntersection intersection;\n\n\tfor (int bounce = 0; bounce <= 2; bounce++) {\n\t\tcalcRadiance(intersection, ray, bounce);\n\n\t\tcolor += reflection * intersection.color;\n\t\tif (!intersection.hit /* || intersection.material != METAL_MATERIAL*/) break;\n\n\t\treflection *= (intersection.metalness * 0.7);\n\t\tray.origin = intersection.position + intersection.normal * OFFSET;\n\t\tray.direction = normalize(reflect(ray.direction, intersection.normal));\n\t}\n\n\tcolor += screenSpaceSnow(uv) * saturate((lTime - UFO_SCENE_END_TIME + 20.0) * 0.1);\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}