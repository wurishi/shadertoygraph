{"ver":"0.1","info":{"id":"3sdXzs","date":"1572654393","viewed":342,"name":"ShaderTober - Ride","username":"Flopine","description":"A small doodle with inktober's theme \"Ride\"","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define PI 3.141592\n#define tt (iTime*6.)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,16.1)))*1245.4);}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep*0.5) id = abs(id);\n    return id;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat g1 = 0.;\nfloat box (vec3 p, vec3 c)\n{\n    float d = length(max(abs(p)-c,0.));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat g2;\nfloat cyl (vec2 p, float r)\n{\n    float d = length(p)-r;\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nvec2 path(float t) \n{\n\tfloat a = sin(t*.2+1.5), b = sin(t*.2);\n\treturn vec2(a, a*b);\n}\n\nfloat cid;\nfloat SDF (vec3 p)\n{\n    p.xy -= path(p.z)*3.;\n    p.xy *= rot(p.z*0.15);\n    \n    vec3 pp = p;\n    \n    p += sin(p.yzx - cos(p.zxy));\n    p += sin(p.yzx/1.5 + cos(p.zxy)/2.)*.5;\n    float t = -length(p.xy)+6.;\n    \n    p = pp;\n    moda(p.xy, 6.);\n    p.x -= 3.;\n    float b = box(p,vec3(.2,0.2,1e10));\n    \n    p = pp;\n    p.xy *= rot(PI/6.);\n    cid = moda(p.xy, 6.);\n    p.y += sin(p.z)*0.5;\n    p.x -= 2.;\n   \tfloat c = cyl(p.xy, 0.3);\n    return min(min(c,t),b);\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.,0.,-5.+tt),\n        ta = vec3(0.,0.,tt);\n    \n    ro.xy += path(ro.z)*3.;\n\tta.xy += path(ta.z)*3.;\n       \n    vec3 rd = getcam(ro,ta, uv),\n    \tp = ro,\n    \tcol = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/ITER;\n            break;\n        }\n         d *= 0.6+dither*0.1;\n        p += d*rd;\n    }\n    \n    float t = length(ro-p);\n\tcol = vec3(shad)*0.5;\n\n   \n    col += g2 * 0.09* palette(cid, \n                        vec3(0.5),\n                        vec3(0.5),\n                        vec3(0.1+cid), \n                        vec3(0.,0.3,0.45)); \n    col -= g1*0.25;\n    \n    fragColor = vec4(pow(clamp(col,0.,1.),vec3(0.4545)),1.0);\n}","name":"Image","description":"","type":"image"}]}