{"ver":"0.1","info":{"id":"WltcW2","date":"1609942878","viewed":101,"name":"Projet de graphisme","username":"maulray","description":"Ma petite grenouille à chaussettes perdue dans l'espace pour le projet de graphisme de 3A à TELECOM Nancy.","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["space","lost","frog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlfXRN","filepath":"https://soundcloud.com/steezyasfuck/beats-to-sleep-to-lofi-hip-hop-mix","previewfilepath":"https://soundcloud.com/steezyasfuck/beats-to-sleep-to-lofi-hip-hop-mix","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\n\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt-Obs);\n   C.Horiz = normalize(cross(vec3(0.5, 0.5, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up\n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Material {\n    vec4 Kd;       // diffuse color\n    vec4 Ke;       // emissive color\n\n};\n\n// \\brief Shorthand for the zero vector\nconst vec4 zero4 = vec4(0.0, 0.0, 0.0, 0.0);\n\n// \\brief Creates a diffuse material\n// \\param[in] Kd the diffuse color\n// \\return the created Material\nMaterial diffuse(in vec4 Kd) {\n   return Material(Kd, zero4);\n}\n\n// \\brief Creates a light (emissive) material\n// \\param[in] Ke the color of the light\n// \\return the created Material\nMaterial light(in vec4 Ke) {\n   return Material(zero4, Ke);\n}\n\n\n\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\nObject scene[25];\n\nvoid init_scene() {\n   float beta = float(iFrame)/30.0;\n   float s = sin(beta);\n   float c = cos(beta);\n\n    //scaphendre\n   // scene[24] = Object(\n   //   Sphere(vec3(0.0, 0.0, 0.0),0.7),\n   //   diffuse(vec4(0.15, 0.15, 0.15, 1.0))\n   //);\n\n    //body\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5),\n      diffuse(vec4(0, 1, 0, 0))\n   );\n\n    //first leg\n   scene[1] = Object(\n      Sphere(vec3(-0.6*s, -0.6*c, -0.65),0.1),\n      diffuse(vec4(0,0, 1.0,0))\n   );\n\n\n   scene[3] = Object(\n      Sphere(vec3(-0.55*s, -0.55*c, -0.45),0.1),\n      diffuse(vec4(1, 0, 0,0))\n   );\n\n   scene[4] = Object(\n      Sphere(vec3(-0.4*s, -0.4*c, -0.35),0.1),\n      diffuse(vec4(0, 1.0, 0,0))\n   );\n\n    scene[5] = Object(\n      Sphere(vec3(-0.65*s, -0.65*c, -0.85),0.1),\n      diffuse(vec4(1, 0, 0,0))\n   );\n\n   scene[6] = Object(\n      Sphere(vec3(-0.7*s, -0.7*c, -1.05),0.1),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n    scene[7] = Object(\n      Sphere(vec3(-0.8*s, -0.8*c, -1.05),0.08),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n   //second leg\n\n   scene[8] = Object(\n      Sphere(vec3(0.7*s, 0.7*c, 0.40),0.1),\n      diffuse(vec4(0, 0, 1.0,0))\n   );\n\n\n   scene[9] = Object(\n      Sphere(vec3(0.55*s, 0.55*c,0.42),0.1),\n      diffuse(vec4(1.0, 0, 0,0))\n   );\n\n   scene[10] = Object(\n      Sphere(vec3(0.4*s, 0.4*c, 0.35),0.1),\n      diffuse(vec4(0, 1.0, 0,0))\n   );\n\n    scene[11] = Object(\n      Sphere(vec3(0.86*s, 0.86*c, 0.35),0.1),\n      diffuse(vec4(1.0, 0, 0,0))\n   );\n\n   scene[12] = Object(\n      Sphere(vec3(s, c, 0.30),0.1),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n    scene[13] = Object(\n      Sphere(vec3(1.08*s,1.08*c, 0.40),0.08),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n   //eyes\n   //finir les effets miroir et transparence\n\n    scene[14] = Object(\n      Sphere(vec3(-0.55*s, -0.55*c, 0.04),0.1),\n      diffuse(vec4(0, 1, 0,0))\n   );\n\n    scene[15] = Object(\n      Sphere(vec3(0.05*s, 0.05*c, 0.50),0.1),\n      diffuse(vec4(0, 1, 0,0))\n   );\n\n\n\n\n\n\n\n   //stars\n   scene[2] = Object(\n      Sphere(vec3(0.0, 7.0*s, 0.0),0.01),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[16] = Object(\n      Sphere(vec3(8.0*s, 3.0*c, 0.0),0.01),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n   scene[17] = Object(\n      Sphere(vec3(4.0*c, 0.0, 0.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[18] = Object(\n      Sphere(vec3(2.0*c, 1.0*s, 0.0),0.01),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[19] = Object(\n      Sphere(vec3(0.0, 2.0*c, 3.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[20] = Object(\n      Sphere(vec3(6.0*c, 10.0*s , 2.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[21] = Object(\n      Sphere(vec3(0.0, 4.0*s, 0.5),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[22] = Object(\n      Sphere(vec3(0.5*s, 9.0*c, 4.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec4(0.0, 0.0, 0.0,0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nvec4 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec4(0.0, 0.0, 0.0,0.0)) {\n      return material.Ke;\n   }\n\n   vec4 result = vec4(0.0, 0.0, 0.0,0.0);\n\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec4(0.0, 0.0, 0.0,0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n           float lamb = max(0.0, dot(E,N) / length(E));\n           result += lamb * material.Kd * scene[i].material.Ke;\n         }\n      }\n   }\n\n   return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene();\n\n   float beta = float(iFrame)/150.0;\n   float s = sin(beta);\n   float c = cos(beta);\n\n   Camera C = camera(\n       vec3(2.0, 2.0, 10.0*s),\n       vec3(0.5, 0.5, 0.3),\n       50.0\n   );\n   Ray R = launch(C, fragCoord);\n\n\n    // Time varying pixel color\n    vec3 col = 0.2+0.5*cos(iTime+vec3(2,0,4));\n\n    // Output to screen\n    fragColor = 0.7*vec4(col,1.0);\n\n   const float FARAWAY=1e30;\n   float t = FARAWAY;\n\n   vec3 P;  // Point courant\n   vec3 N;  // Normale\n   Material material; // Couleur\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t)\n          && cur_t < t\n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       }\n   }\n\n   if(t != FARAWAY) {\n      fragColor = lighting(P,N,material);\n   }\n\n}\n","name":"Image","description":"","type":"image"}]}