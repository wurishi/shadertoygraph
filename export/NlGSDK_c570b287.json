{"ver":"0.1","info":{"id":"NlGSDK","date":"1641324255","viewed":240,"name":"Fractal Spiral Animation","username":"Eriksonn","description":"Infinite looping julia set spirals","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["fractal","loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nint fractal_id=0;          // there are 3 different spirals\nfloat animation_speed=1.0; // at 1.0 it loops every second\nfloat rotation_offset=0.0; //in degrees\nint color_mode=0;          //0 is iteration based, 1 is distance based\nint palette_mode=0;        //3 different ways to map from iteration counts to the color palettes\nfloat color_offset=0.0;    //changes where the color starts, range is 0-1\nfloat color_scale=1.0;     //scales the rate at witch the colors change\nbool invert_colors=false;  //inverts the colors\nbool reverse_colors=false; //reverses the direction of the color palettes\nbool mirror_image=false;   //flips the image horizontally\nmat3 color_palette=mat3    //feel free to put custom color palette here\n(\n    vec3(1,0,0),\n    vec3(0,1,0),\n    vec3(0,0,1)\n);\n\n\n\nstruct Location\n{\n    vec2 C;\n    vec2 O;\n    int n;\n    float zoom;\n};\nLocation[3] Locations = Location[3](\nLocation(vec2(-0.154977553980223,-1.03808703243268),vec2(-0.156773443866831,-1.03737830985032),12,0.00008),\nLocation(vec2(-0.160755145244179,-1.03758449347635),vec2(0.0348636145887,0.0281293563132),8,0.001),\nLocation(vec2(-1.26490357067779,-0.0532356825045747),vec2(0.0513969989866,-0.120517042117),32,0.001)\n);\n\nfloat t;\nint n;\nfloat Qzoom;\nLocation Loc;\n\nvec2 Mult(vec2 a,vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 Exp(vec2 a)\n{\n    return exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\nvec2 Log(vec2 a)\n{\n    return vec2(log(dot(a,a))/2.0,atan(a.y,a.x));\n}\nfloat GetIter(vec2 Z)\n{\n    for(int i =0;i<1000;i++)\n    {\n        Z=Mult(Z,Z)+Loc.C;\n        \n        if(dot(Z,Z)>100.0)\n        {\n            return float(i)-log(log(dot(Z,Z))/2.0)/log(2.0);\n        }\n    }\n    return 0.0;\n}\nvec2 GetQ(vec2 Z,vec2 C,int n)\n{\n    vec2 Z0=Z;\n    vec2 Q=vec2(1,0);\n    for(int i =0;i<n;i++)\n    {\n        Z=Mult(Z,Z)+C;\n        Q=2.0*Mult(Z,Q);\n    }\n    return Q;\n}\nvec2 GetRotated(vec2 Z)\n{\n    vec2 LogQ=Log(GetQ(Loc.O,Loc.C,Loc.n));\n    Qzoom = LogQ.x;\n    Z=Mult(Z,Exp(-t*LogQ+vec2(0,rotation_offset*0.01745)));\n    Z*=Loc.zoom;\n    Z-=Loc.O;\n    return Z;\n}\nfloat GetLight(float iter,vec2 Z)\n{\n    float offset = 5.25/iResolution.x;\n    vec3 sun = vec3(1,1,0);\n    float iter2 = GetIter(GetRotated(Z+vec2(offset,0)));\n    float iter3 = GetIter(GetRotated(Z+vec2(0,offset)));\n    vec3 H1 = vec3(1,0,iter-iter2);\n    vec3 H2 = vec3(0,1,iter-iter3);\n    vec3 Cross = normalize(cross(H1,H2));\n    return dot(Cross,normalize(sun));\n}\nvec3 FancyColor(float h)\n{\n\th=mod(h,1.0);\n\th*=2.0;\n\tvec3 A = vec3(h*h,h,sqrt(h));\n\th=2.0-h;\n\tvec3 B = vec3(h*h,h,sqrt(h));\n\treturn min(A,B.zyx);\n}\nvec3 Color(float iter,float dist,vec2 Z,vec2 uv)\n{\n    float k =0.0;\n    vec3 col=vec3(0);\n    switch(color_mode)\n    {\n        case(0):\n        k=(iter-t*float(n))*0.05;\n        break;\n        case(1):\n        k=(log(dist)+Qzoom*t)*0.4;\n        break;\n    }\n    k*=color_scale;\n    k+=color_offset;\n    if(reverse_colors)\n    k=-k;\n    switch(palette_mode)\n    {\n        case(0):\n        col = vec3(cos(k*1.0+vec3(0,2.1,4.2)-0.5)*0.5+0.5);\n        break;\n        case(1):\n        vec3 g = vec3(cos(k*1.0+vec3(0,2.1,4.2)-0.5)*0.5+0.5);\n        col=g*g;\n        break;\n        case(2):\n        col=FancyColor(k*0.159+0.5);\n        break;\n    }\n    col = color_palette*col;\n    if(invert_colors)\n    {\n        col=vec3(1.0-col);\n    }\n    return col+GetLight(iter,uv)*0.2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 4.0*(fragCoord-iResolution.xy*0.5)/iResolution.x;\n    if(mirror_image)\n        uv.x*=-1.0;\n    Loc = Locations[fractal_id];\n    n=Loc.n;\n    t = mod(iTime*animation_speed,1.0);\n    //t=iTime*2.0-6.0;\n    //t=-sqrt(t*t+2.0);\n    vec2 Z=GetRotated(uv);\n    \n    vec2 Der=vec2(1,0);\n    for(int i =0;i<500;i++)\n    {\n        Der=2.0*Mult(Z,Der);\n        Z=Mult(Z,Z)+Loc.C;\n        \n        if(dot(Z,Z)>100.0)\n        {\n            float lz = length(Z);\n            float ld = length(Der);\n            float m = lz*log(lz)/(2.0*ld);\n            float s = float(i)-log(log(dot(Z,Z))/2.0)/log(2.0);\n            fragColor=vec4(Color(s,m,Z,uv),1);\n            break;\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"}]}