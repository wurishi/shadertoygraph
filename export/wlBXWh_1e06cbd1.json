{"ver":"0.1","info":{"id":"wlBXWh","date":"1565724323","viewed":176,"name":"Water ripples experiment","username":"sergei_am","description":"Water ripples fx shader, using several intermediate RTs for the water surface simulation.\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["simulation","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Water surface has (height, velocity) for each point\n// A step of the simulation goes like this:\n//\n//   avg_neighbor_height = (curr.height[-1,0] + curr.height[1,0] + curr.height[0,1] + curr.height[0,-1]) / 4\n//   next.height = curr.height + curr.velocity\n//   next.velocity = curr.velocity + (avg_neighbor_height - curr.height)*SPEED_FACTOR\n//   next.velocity *= DAMP_FACTOR\n//\n\nfloat saturate(float x)\n{\n    return clamp(x,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 N = compute_normalmap_from_water(iChannel0, fragCoord, iResolution, iTime);\n    \n    if(fragCoord.x/iResolution.x < 0.5)\n    {\n        fragColor.xyz = N;\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor.xyz = texture(iChannel1, uv + (N.xy*2.0 - 1.0)*0.2).xyz;\n    }\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = compute_water_simulation_step(iChannel0, fragCoord, iResolution, iTime);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = compute_water_simulation_step(iChannel0, fragCoord, iResolution, iTime);\n} \n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float AVG_FRICTION = 1.5;\nconst float VELOCITY_FRICTION = 0.98;\nconst float NORMAL_STRENGTH = 0.5;\n\n\n\nfloat generate_noise(in vec2 uv, in float iTime)\n{\n    float x = sin( uv.x * 14.23 + iTime*11.12 ) * sin( uv.y * 6.45 - iTime * 53.45);\n    x *= sin( uv.y * 13.0 + iTime*10.77) * sin( uv.x * 4.0 - iTime*43.23);\n    x = min( max( x - 0.96, 0.0 ) * 200.0, 1.0 );\n    \n    return x;\n}\n\nvec4 compute_water_simulation_step(sampler2D t, in vec2 fragCoord, in vec3 iResolution, in float iTime)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 su = vec2(1.0 / iResolution.x, 0.0);\n    vec2 sv = vec2(0.0, 1.0/iResolution.y);\n    \n    float noise = 1.0 * generate_noise(uv, iTime);\n    \n    float avg_height = (\n        texture(t, fract(uv + su)).x +\n        texture(t, fract(uv + sv)).x +\n        texture(t, fract(uv - su)).x +\n        texture(t, fract(uv - sv)).x\n\t) * 0.25;\n    \n    vec2 curr = texture(t, uv).xy;\n    \n    float height = curr.x;\n    float velocity = curr.y;\n    \n    height += noise;\n    \n    velocity += (avg_height - height) * AVG_FRICTION;\n    velocity *= VELOCITY_FRICTION;\n    height += velocity;\n   \n    return vec4(height, velocity, 0.0, 1.0);\n}\n\nvec3 compute_normalmap_from_water(sampler2D t, in vec2 fragCoord, in vec3 iResolution, in float iTime)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 su = vec2(1.0 / iResolution.x, 0.0);\n    vec2 sv = vec2(0.0, 1.0/iResolution.y);\n    \n    float curr = texture(t, uv).x;\n    \n    float x = texture(t, uv - su).x - curr;\n    float y = texture(t, uv - sv).x - curr;\n    \n    vec3 N = normalize(vec3(x,y,1.0/NORMAL_STRENGTH));\n    return N * 0.5 + 0.5;\n}","name":"Common","description":"","type":"common"}]}