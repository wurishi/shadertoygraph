{"ver":"0.1","info":{"id":"4cX3DM","date":"1703121332","viewed":64,"name":"Erlend Robaye's tessellation","username":"DjinnKahn","description":"Based on work from Erlend Robaye:\n[url]https://www.facebook.com/groups/391950357895182/permalink/1736772340079637/[/url]\n\nmouse x: controls count","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["hex","tessellation","wallpapergroup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 COLOR0 = vec3( 0.00, 0.00, 0.00 );\nconst vec3 COLOR1 = vec3( 0.93, 0.37, 0.00 );\nconst vec3 COLOR2 = vec3( 1.00, 1.00, 1.00 );\n\n// controls geometry of tesselation\nconst float TRIANGLE_SIZE = .08;\nconst vec2 P1 = vec2( 1.05, .35 );\n\n// \"size\" of the arrows\n//const float TESSELATION_SCALE = 10.;\n\n// constants\nconst vec2 O = vec2( 0., 0. );\nconst vec2 A = vec2( 2., 0. );\nconst vec2 C = vec2( 1., sqrt(3.)/3. );\nconst vec2 D = vec2( 1., sqrt(3.) );\nconst vec2 P2 = vec2( TRIANGLE_SIZE, sqrt(3.) * TRIANGLE_SIZE );\nconst vec2 P3 = vec2( P2.x, 0. );\n\nconst float PI = acos(0.) * 2.;\nmat2 rot( float a ) { return mat2( cos(a), sin(a), -sin(a), cos(a) ); }\n\nbool isClockwise( vec2 a, vec2 b, vec2 c )\n{\n    b -= a;\n    c -= a;\n    return b.x*c.y < b.y*c.x;\n}\n\nfloat signedDistToLine( vec2 p, vec2 line0, vec2 line1 )\n{\n    p -= line0;\n    vec2 n = normalize( line1 - line0 );\n    return n.y * p.x - n.x * p.y;\n}\n\n// returns either p or the mirror image of p across line(a,b)\nvec2 fold( vec2 p, vec2 a, vec2 b )\n{    \n    p -= a;\n    b -= a;\n    if ( b.x * p.y < b.y * p.x )\n        return p + a;\n    vec2 v = dot( p, b ) / dot( b, b ) * b;\n    return 2.*v - p + a;\n}\n\nvec3 combine( vec3 color0, vec3 color1, float d, float featherAmt )\n{\n    //const float FEATHER = .04;\n    return mix( color0, color1, smoothstep( -featherAmt, featherAmt, d ) );\n}\n\n// input `p`: coordinate inside 1/3 of an equilateral triangle\n// input `featherAmt`: controls blurriness/antialiasing\n//\n//                                                   P1'  \n//                                                  --*\n//                            (1, sqrt(3)/3)    ----   \\      Note:\n//                                          C---        \\     P1', P2', P3' are\n//                                       /  || \\         \\    P1, P2, P3 rotated \n//                                    /     ||    \\       \\   120 degrees about C\n//                                 /        | |      \\     \\\n//                              /           | |         \\   \\\n//                           /              |  |           \\ \\\n//            P2          /                 |  |              \\            P3'\n//             *-------/-----------------------*               \\ \\        *\n//             |    /                       |   P1              \\   \\   /\n//             | /                          |                    \\     \\\n//            /|                            |                     \\  /    \\\n//         O---*----------------------------*----------------------*---------A\n//       (0,0) P3                          (1,0)                   P2'       (2,0)\n// \nvec3 baseTriangle( vec2 p, float featherAmt )\n{\n    //if ( featherAmt > .05 ) return vec3( 0., 1., 0. ); // returns a good approximation of the code below\n    \n    vec3 col;\n    if ( p.x > P1.x + .05 )\n    {\n        p = rot(PI*-2./3.) * (p-C) + C;\n        col = combine( vec3( 0., 1., 0. ), vec3( 0., 0., 1. ), min( signedDistToLine( p, P2, P1 ), signedDistToLine( p, P3, P2 ) ), featherAmt );           ;\n    }\n    else\n    {    \n        col = vec3( 0., 1., 0. );\n        col = combine( col, vec3( 1., 0., 0. ), signedDistToLine( p, P2, P3 ), featherAmt );\n        col = combine( col, vec3( 1., 0., 0. ), min( signedDistToLine( p, C, P1 ), signedDistToLine( p, P1, P2 ) ), featherAmt );\n    }\n    \n    // when featherAmt is large, we'll just use an even mix of all 3 colors (vec3(1./3.))\n    const float FILTER_THRESHOLD_LO = .8;\n    const float FILTER_THRESHOLD_HI = 4.0;    \n    float fog = clamp( (1./featherAmt - 1./FILTER_THRESHOLD_LO) / (1./FILTER_THRESHOLD_HI - 1./FILTER_THRESHOLD_LO), 0., 1. );    \n    col = mix( col, vec3( 1./3. ), fog );\n    return col;\n}\n\n\n// combines 3 baseTriangle()s\nvec3 equilateralTriangle( vec2 p, float featherAmt )\n{\n    if ( isClockwise( O, C, p ) && isClockwise( C, A, p ) )\n        return baseTriangle( p, featherAmt );\n    if ( p.x < 1. )\n        return baseTriangle( rot(PI*2./3.) * (p-C) + C, featherAmt ).gbr;\n    return baseTriangle( rot(PI*-2./3.) * (p-C) + C, featherAmt ).brg;\n}\n\n// combines 2 equilateralTriangle()s\nvec3 parallelogram( vec2 p, float featherAmt )\n{\n    return equilateralTriangle( fold( p, D, A ), featherAmt );\n}\n\nvec3 erlendRobayeArrowTessellation( vec2 p, float featherAmt ) // tesselates the plane\n{\n    const mat2 SKEW = mat2( A.x, 0., .5*A.x, D.y );\n    vec2 uv = inverse( SKEW ) * p; // skewed grid (uv coordinates for the \"base\" parallelogram)\n    p = SKEW * fract( uv ); // unskew grid (convert back to model coordinates)\n    \n    vec2 cell = floor( uv );\n    float colorSwap = mod( cell.x - cell.y, 3. );\n    \n    vec3 col = parallelogram( p, featherAmt ); // col's components indicate how much of COLOR0, COLOR1, COLOR2 to use\n    col = colorSwap == 0. ? col : colorSwap == 1. ? col.brg : col.gbr; // comment this line to see the cells (parallelograms)\n    \n    return col.r * COLOR0 + col.g * COLOR1 + col.b * COLOR2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool useMouse = !(iMouse.x == 0. && iMouse.y == 0.);\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n\n    vec2 p = (fragCoord*2. - iResolution.xy) / iResolution.y;\n    p += vec2( .5, 0. ); // offset tunnel from center\n    \n    vec2 uv = vec2( atan( p.y, p.x ) / (2. * PI) + .5, log( length( p ) ) ); // tunnel effect\n    uv += iTime * vec2( .01, -.3 ); // movement\n    \n    float TESSELATION_SCALE = useMouse ? floor( mousePos.x * mousePos.x * 100. + 1. ) : 10.;\n    //float BASE_FEATHER_AMOUNT = useMouse ? mousePos.y * 10. : 1.8;\n    float BASE_FEATHER_AMOUNT = 1.8;\n    \n    float feather = BASE_FEATHER_AMOUNT / iResolution.y * TESSELATION_SCALE / length( p );\n    fragColor = vec4( erlendRobayeArrowTessellation( uv * vec2( 6., 1. ) * TESSELATION_SCALE, feather ), 1. );\n}","name":"Image","description":"","type":"image"}]}