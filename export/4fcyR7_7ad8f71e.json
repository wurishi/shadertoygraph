{"ver":"0.1","info":{"id":"4fcyR7","date":"1730376170","viewed":36,"name":"Blurry Balls","username":"henriquemf","description":"Animação com troca de cores e um \"blur\" nas esferas.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blur","colors","spheres","balls","animation","blurry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float x) {\n    return fract(sin(x) * 43758.5453123);\n}\n\nvec2 random2(vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n              dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat gradientNoise(vec2 st) { // gradient noise\n    vec2 grid = floor(st);\n    vec2 fractional = fract(st);\n    vec2 smoothInterpolation = fractional * fractional * (3.0 - 2.0 * fractional);\n\n    return mix(mix(dot(random2(grid + vec2(0.0, 0.0)), fractional - vec2(0.0, 0.0)),\n                   dot(random2(grid + vec2(1.0, 0.0)), fractional - vec2(1.0, 0.0)), smoothInterpolation.x),\n               mix(dot(random2(grid + vec2(0.0, 1.0)), fractional - vec2(0.0, 1.0)),\n                   dot(random2(grid + vec2(1.0, 1.0)), fractional - vec2(1.0, 1.0)), smoothInterpolation.x), smoothInterpolation.y);\n}\n\nfloat smoothClamp(float value, float minVal, float maxVal) {\n    return smoothstep(0.0, 1.0, (value - minVal) / (maxVal - minVal)) * (maxVal - minVal) + minVal;\n}\n\nvec2 applyNoise(vec2 position, float time, float radius) {\n    time = time / 4.0;\n    float noise1 = gradientNoise(position + time) + 0.5;\n    float noise2 = gradientNoise(position - time) + 0.5;\n\n    noise1 = smoothClamp(noise1, 0.0 + radius, 1.0 - radius);\n    noise2 = smoothClamp(noise2, 0.0 + radius, 1.0 - radius);\n\n    return vec2(noise1, noise2);\n}\n\nfloat smoothUnion(float distance1, float distance2, float k) {\n    float h = clamp(0.5 + 0.5 * (distance2 - distance1) / k, 0.0, 1.0);\n    return mix(distance2, distance1, h) - k * h * (1.0 - h);\n}\n\n// Função para gerar uma cor aleatória\nvec3 generateRandomColor(float seed) {\n    return vec3(hash(seed), hash(seed + 1.0), hash(seed + 2.0));\n}\n\nvec3 generateGradualColor(float index, float timeOffset) {\n    // Use um índice para determinar a fase da cor\n    float phase = (iTime + timeOffset) * 0.5; // Controla a velocidade de mudança da cor\n    return vec3(0.5 + 0.5 * sin(phase + index), \n                 0.5 + 0.5 * sin(phase + index + 2.0), \n                 0.5 + 0.5 * sin(phase + index + 4.0));\n}\n\nfloat blur(float distance, float radius) {\n    // Efeito de desfoque baseado na distância até a esfera\n    return smoothstep(0.0, radius, distance) * (1.0 - smoothstep(0.0, radius * 5.0, distance));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float finalResult = 0.0;\n    vec2 uv = (fragCoord - iResolution.xy) / iResolution.y;\n    vec2 fractionalUV = fract(uv * 5.0);\n    vec2 integerUV = floor(uv * 5.0);\n\n    float index = 100.0;\n    float accumulatedRadius = 0.0;\n    float radiusCap = 0.20;\n    float mergedDistance = 1000.0;\n    vec3 accumulatedColor = vec3(0.0); // Cor final que será usada para as esferas\n\n    while (accumulatedRadius < radiusCap) {\n        float noise1 = hash(float(index) + hash(length(integerUV)) + hash(length(fractionalUV))) * 100.0;\n        float noise2 = hash(float(index) + hash(length(integerUV)) - hash(length(fractionalUV))) * 100.0;\n        float randomNoise = hash(float(index) + hash(length(integerUV))) * 90.0;\n\n        float timeFactor = (sin(iTime * 2.0) + 1.0) / 2.0;\n        float mixFactor = 0.95 + timeFactor * 0.05;\n\n        float radiusNoise = mix((noise1 + noise2), randomNoise, mixFactor);\n        float radius = radiusNoise * 0.0028;\n        accumulatedRadius += radius;\n\n        vec2 centerPosition = uv + hash(float(index)) * 10.0;\n\n        vec2 noiseCenter = applyNoise(centerPosition, iTime, radius);\n        float distanceToSphere = length(fractionalUV - noiseCenter) - radius;\n        mergedDistance = smoothUnion(mergedDistance, distanceToSphere, 0.065);\n\n        // Cor gradual para a esfera atual\n        float timeOffset = index * 0.1; // Deslocamento de tempo único para cada esfera\n        vec3 sphereColor = generateGradualColor(index, timeOffset);\n        \n        // Aplica o desfoque à cor acumulada\n        float blurEffect = blur(distanceToSphere, radius * 1.5);\n        accumulatedColor += sphereColor * smoothstep(0.0, 0.1, radius) * blurEffect;\n\n        index += 1.0;\n    }\n\n    finalResult = smoothstep(0.0, 0.001, mergedDistance);\n    finalResult = 1.0 - finalResult;\n\n    fragColor = vec4(accumulatedColor * finalResult, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}