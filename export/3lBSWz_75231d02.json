{"ver":"0.1","info":{"id":"3lBSWz","date":"1565561583","viewed":709,"name":"The windmill problem","username":"hamtarodeluxe","description":"An illustration of the windmill problem. \nWe can prove that, in some configuration, the rotating line will infinitely use each point as a pivot.\n-> \"Common\" to edit points.\nhttps://www.youtube.com/watch?v=M64HUIJFTZM","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["2d","buffer","maths","windmill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Draw elements\nvec3 drawBg (vec2 uv)\n{\n    vec3 bg = mix(vec3(1.,.4,.2),vec3(.3,.4,1.), step(0.,uv.y));\n    bg *= pow(min(1.,abs(uv.y)/0.2), 0.075);\n\treturn bg;\n}\n\nfloat drawline (vec2 uv)\n{\n\treturn smoothstep(-0.01,0.0,uv.y)-smoothstep(0.0,0.01,uv.y);\n}\n\nfloat drawPoint(vec2 point, vec2 uv, float rad, float fade)\n{\n\treturn 1.-smoothstep(rad,rad+fade, length(uv-point));\n}\n\nfloat drawClick(vec2 point, vec2 uv, float rad0)\n{\n    float rad1 = rad0 +0.05;\n    float fade = 0.01;\n    vec2 d = uv-point;\n    float l = length(d);\n    float a = atan(d.y,d.x);\n\tfloat v = smoothstep(rad0-fade,rad0,l)-smoothstep(rad1,rad1+fade, l);\n    float slice = (2.0*3.14159)/10.;\n    a = mod(a+0.5*slice,slice)-0.5*slice;\n    float rad = 0.005/l;\n   \tv *=  smoothstep(-0.1-rad,-rad,a)-smoothstep(rad,rad+0.1, a);\n\n    return v;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5;\n    uv*=2.;\n    vec2 oldUv = uv;\n    uv.x /= iResolution.y/iResolution.x;\n   \n    vec4 line = texelFetch(iChannel0, ivec2(0,0),0);\n\n    // Transform uv according to line\n    vec2 uvL = uv; \n    uvL -= line.xy;\n    line.zw -= line.xy;\n    uvL *= rot(-atan(line.w,line.z));  \n    \n    // Background\n    vec3 col = drawBg(uvL);\n    \n    // Vignet\n    col *=  1./pow((pow(sqrt(dot(oldUv,oldUv)*.4),2.)+1.),3.); // Adapted from Keijiro\n    \n\t// Points\n    float p = 0.;\n    float ps = 0.;\n    vec4 data = texelFetch(iChannel0, ivec2(1,0),0);\n    int ptI0 = int(data.x);\n    int ptI1 = int(data.y);\n\n    for (int i=0; i<points.length(); i++)\n    {\n        float r = i == ptI0 ? 0.03:0.01;\n    \tp = max(p,drawPoint(points[i],uv,r,0.01));\n        ps = max(ps,drawPoint(points[i],uv,r,0.05));\n    }\n\t\n    // Click effect \n    float tclick0 = data.z;\n    float tclick1 = data.a;\n    \n    tclick0 = pow(tclick0*2.,0.5);\n    float rad = 0.15*tclick0;\n    float life = clamp(1.-tclick0,0.,1.);\n    p = max(p, life*drawClick(points[ptI0], uv, rad));\n    \n    tclick1 = pow(tclick1*2.,0.5);\n    rad = 0.15*tclick1;\n    life = clamp(1.-tclick1,0.,1.);\n    p = max(p, life*drawClick(points[ptI1], uv, rad));\n    \n\tcol *= pow((1.-ps),0.15);\n    col += vec3(p);\n    \n    // Windmill line\n    col += drawline(uvL);\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Compute pass\nvec4 rotateLine(vec4 line, vec2 pivot, float angle)\n{\n\tline -= vec4(pivot,pivot);\n    line.zw *= rot(angle);\n    line.xy *= rot(angle);\n\tline += vec4(pivot,pivot);\n    return line;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// line described with two points\n    vec4 line;\n    float pivotID;\n    float prevPivotID;\n    float tclick0, tclick1;\n    \n    if (iFrame<=1) // initialize\n    {        \n        pivotID = START_PIVOT_ID;\n        prevPivotID = 0.;\n      \tline = vec4(points[int(START_PIVOT_ID)],points[int(START_PIVOT_ID)]+vec2(0,1));\n        tclick0= tclick1 = 10.;\n    }else // fetch datas\n    {\n     \tline = texelFetch(iChannel0, ivec2(0,0),0);\n        vec4 data = texelFetch(iChannel0, ivec2(1,0),0);\n        pivotID = data.x;\n        prevPivotID = data.y;\n        tclick0 = data.z;\n        tclick1 = data.a;\n    }  \n    \n    for (int i=0; i<points.length(); i++)\n    {\n        // check distance to point\n        vec2 pt = points[i];\n        \n        vec2 dir1 = normalize(line.zw-line.xy);\n        float a1 = (line.w-line.y)/(line.z-line.x);\n        float b1 = line.y-a1*line.x;\n       \n        vec2 dir2 =  vec2(dir1.y, -dir1.x);\n        vec4 line2 = vec4(pt,pt+dir2);\n        float a2 = (line2.w-line2.y)/(line2.z-line2.x);\n        float b2 = line2.y-a2*line2.x;\n        \n        float isectx = (b2-b1)/(a1-a2);\n        float isecty = a2*isectx+b2;\n\n        float l = length(pt-vec2(isectx,isecty));\n        \n        if (i != int(pivotID) && i!= int(prevPivotID) && l<0.025)\n        {\n            prevPivotID = pivotID;\n        \tpivotID = float(i);\n            line = vec4(pt, pt+dir1);\n            tclick1 = tclick0;\n            tclick0 = 0.;\n            break;\n        }        \n     }\n  \t\n    vec2 pivot = points[int(pivotID)];\n    \n    line = rotateLine(line, pivot,-0.0075);\n    tclick0 += iTimeDelta;\n    tclick1 += iTimeDelta;\n    vec4 data =  floor(fragCoord) == vec2(0.,0.) ? line : vec4(pivotID, prevPivotID,tclick0,tclick1); \n    \n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// The windmill problem\n// https://www.youtube.com/watch?v=M64HUIJFTZM\n\n// Edit points here\nvec2 points[] = vec2[](\n                            vec2(+0.0, -0.2), \n                            vec2(-1.2, -0.5), \n                            vec2(+0.3, -0.6), \n                            vec2(+0.7, +0.3), \n                            vec2(+0.6, +0.5),\n    \t\t\t\t\t    vec2(+1.2, -0.3), \n                            vec2(-0.4, +0.6), \n                            vec2(-0.7, +0.5),\n    \t\t\t\t\t\tvec2(-1.5, +0.7)\n\t\t\t\t\t\t);\n\n// Index of the point the windmill starts at\n#define START_PIVOT_ID 0.\n\n\n// Utility\nmat2x2 rot(float angle)\n{\n  \n    return mat2x2(cos(angle), -sin(angle),\n\t\t\t\t  sin(angle), cos(angle));\n}\n","name":"Common","description":"","type":"common"}]}