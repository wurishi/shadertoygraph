{"ver":"0.1","info":{"id":"7sGBRD","date":"1657733260","viewed":649,"name":"Disco Sewers","username":"panna_pudi","description":"Continue doing tunnels","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["3d","tunnel","water","palette","glow","arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float NINE5 = 0.9510565, THREE0 = 0.309017, EIGHT09 = 0.80902,\n            FIVE8 = 0.58778525;\nconst vec3 FIRST_PLANE = vec3(0., -1., 0.),\n           SECOND_PLANE = vec3(NINE5, -THREE0, 0.),\n           THIRD_PLANE = vec3(FIVE8, EIGHT09, 0.),\n           FOURTH_PLANE = vec3(-FIVE8, EIGHT09, 0.),\n           FIFTH_PLANE = vec3(-NINE5, -THREE0, 0.);\n\n///////////////////////////////////////////////////////\nfloat pipe(vec3 p, float l, float w) {\n    float d = 1e9;\n    p = p.xzy;\n    p.y = abs(p.y);\n\n    {\n        vec3 q = p.yzx;\n        q.x -= l; q.y += 0.29;\n        q.yx *= rot(-PI / 4.);\n        const float an = 1. / sqrt(2.);\n        d = sd_capped_torus(q, vec2(an), 0.3, w);\n    }\n    d = min(d, sd_capped_cylinder(p, w, l));\n    d = min(d, sd_capped_cylinder(p - vec3(0., l, 0.), w + 0.02,  0.1) - 0.01);\n\n    p.xz = polar_mod(p.xz, 9.);\n    p.xz *= rot(-PI / 2.);\n    d = min(d, (length(p - vec3(w + 0.03, l, 0.0)) - 0.022));\n\n    return d;\n}\n           \nconst float PIPE_MOD_DIST = 10.;\nfloat rand_pipe(vec3 p, float id, float y) {\n    vec3 yoffset = cross(vec3(0., 0., 1.), FOURTH_PLANE);\n    yoffset.xy *= rot(3.7 * PI / 6.);\n\n    float l = rand_in_range(id, 1.5, PIPE_MOD_DIST / 3. - 0.5);\n    float w = (PIPE_MOD_DIST - l) / 3.;\n    float zoff = rand_in_range(id + 0.1, -w / 3., w);\n\n    p = p - yoffset * 0.15 * y - vec3(0., 0., zoff);\n    return pipe(p, l, 0.1);\n}\n\nfloat pipe_map(vec3 p) {\n    float id = floor((p.z + PIPE_MOD_DIST / 2.) / PIPE_MOD_DIST);\n    p.z = mod(p.z + PIPE_MOD_DIST / 2., PIPE_MOD_DIST) - PIPE_MOD_DIST / 2.;\n\n    p.xy *= rot(3.7 * PI / 6.);\n    p += vec3(0.55, 0.8, 0.);\n\n    float top = rand_pipe(p, id, 1.);\n    float bottom = rand_pipe(p, id + PI, -1.);\n\n    return min(top, bottom);\n}\n////////////////////////////////////////////////////\n\n// Thanks Tater! https://www.shadertoy.com/view/NlKGWK\nconst float ITERS_TRACE = 8., ITERS_NORM = 25.,\n\n            HOR_SCALE = 1.1, OCC_SPEED = 1.4, DX_DET = 0.65,\n\n            FREQ = 1.09, HEIGHT_DIV = 5.5, WEIGHT_SCL = 0.8, FREQ_SCL = 1.2,\n            TIME_SCL = 1.095, WAV_ROT = 1.21, DRAG = 0.6, SCRL_SPEED = 0.5;\nvec2 scrollDir = vec2(0, 1);\nvec2 wavedx(vec2 wavPos, float iters, float t){\n    vec2 dx = vec2(0);\n    vec2 wavDir = vec2(1,0);\n    float wavWeight = 1.0;\n    wavPos += t * SCRL_SPEED * scrollDir;\n    wavPos *= HOR_SCALE;\n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED * t;\n    for (float i = 0.; i < iters; i++) {\n        wavDir *= rot(WAV_ROT);\n        float x = dot(wavDir, wavPos) * wavFreq + wavTime;\n        float result = exp(sin(x) - 1.) * cos(x) * wavWeight;\n        dx += result * wavDir / pow(wavWeight, DX_DET);\n        wavFreq *= FREQ_SCL;\n        wavTime *= TIME_SCL;\n        wavPos -= wavDir * result * DRAG;\n        wavWeight *= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL, float(iters)) - 1.) * HEIGHT_DIV;\n    return dx / pow(wavSum, 1. - DX_DET);\n}\n\nfloat wave(vec2 wavPos, float iters, float t) {\n    float wav = 0.0;\n    vec2 wavDir = vec2(1, 0);\n    float wavWeight = 1.0;\n    wavPos += t * SCRL_SPEED * scrollDir;\n    wavPos *= HOR_SCALE;\n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED * t;\n    for (float i = 0.; i < iters; i++) {\n        wavDir *= rot(WAV_ROT);\n        float x = dot(wavDir, wavPos) * wavFreq + wavTime;\n        float wave = exp(sin(x)  - 1.0) * wavWeight;\n        wav += wave;\n        wavFreq *= FREQ_SCL;\n        wavTime *= TIME_SCL;\n        wavPos -= wavDir * wave * DRAG * cos(x);\n        wavWeight *= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL, float(iters)) - 1.) * HEIGHT_DIV;\n    return wav / wavSum;\n}\n\nvec3 wave_norm(vec3 p){\n    vec2 wav = -wavedx(p.xz, ITERS_NORM, iTime * 0.3);\n    return normalize(vec3(wav.x, 1.0, wav.y));\n}\n\nfloat water_map(vec3 p){\n    float d = 1e9;\n    p.y += 1.2;\n\n    float waters = p.y - wave(p.xz, ITERS_TRACE, iTime * 0.4);\n    d = min(d, waters);\n\n    return d;\n}\n////////////////////////////////////////////////////\n\nfloat GLOW = 0.;\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, 1e-6), intensity);\t\n}\n\nfloat light_map(vec3 p) {\n    float c = 5.;\n    p.z = mod(p.z + c / 2., c) - c / 2.;\n    \n    vec3 light_start = vec3(0.15, 1.25, 0.0);\n    vec3 light_end = vec3(1., .63, 0.0);\n    \n    float l = sd_capsule(p, light_start, light_end, 0.025);\n    GLOW += getGlow(l, 0.01, 1.7);\n    return l;\n}\n////////////////////////////////////////////////////\n\nHit trace(in vec3 ro, in vec3 rd) {\n    Hit hit = default_hit();\n    float plane_dist = 1e9;\n    bool wall = false;\n\n    wall = clamped_plane(ro, rd, FIRST_PLANE + vec3(0., 0.4, 0.), FIRST_PLANE, 1., plane_dist);\n    if (wall) {\n        vec2 waters;\n        march_macro(water_map, ro, rd, 100, plane_dist, plane_dist + 10., waters);\n        if (waters.y > 0.) {\n            vec3 norm = wave_norm(ro + rd * waters.x);\n            hit = _min(hit, Hit(waters.x, norm, 1));\n        }\n    }\n\n    wall = clamped_plane(ro, rd, SECOND_PLANE, SECOND_PLANE, 1., plane_dist);\n    if (wall) {\n        hit = _min(hit, Hit(plane_dist, -SECOND_PLANE, 2));\n    }\n    wall = clamped_plane(ro, rd, THIRD_PLANE * 0.8, THIRD_PLANE, 1., plane_dist);\n    if (wall) {\n        float wall2;\n        wall = clamped_plane(ro, rd, THIRD_PLANE * 1.1, THIRD_PLANE, 1., wall2);\n        if (wall) { hit = _min(hit, Hit(wall2, -THIRD_PLANE, 4)); }\n\n        // Only collect glow\n        vec2 lights;\n        march_macro(light_map, ro, rd, 5, plane_dist, plane_dist + 4., lights);\n    }\n    wall = clamped_plane(ro, rd, FOURTH_PLANE * 0.8, FOURTH_PLANE , 2., plane_dist);\n    if (wall) {\n        float wall2;\n        wall = clamped_plane(ro, rd, FOURTH_PLANE * 1.1, FOURTH_PLANE, 1., wall2);\n        if (wall) { hit = _min(hit, Hit(wall2, -FOURTH_PLANE, 4)); }\n        vec2 pipes;\n        march_macro(pipe_map, ro, rd, 100, plane_dist, plane_dist + 10., pipes);\n        if (pipes.y > 0.) {\n            vec3 norm;\n            get_norm_macro(pipe_map, ro + rd * pipes.x, norm);\n            hit = _min(hit, Hit(pipes.x, norm, 6));\n        }\n    }\n    wall = clamped_plane(ro, rd, FIFTH_PLANE, FIFTH_PLANE, 1., plane_dist);\n    if (wall) {\n        hit = _min(hit, Hit(plane_dist, -FIFTH_PLANE, 5));\n    }\n\n    return hit;\n}\n\n// https://www.elopezr.com/rendering-line-lights/\nvec3 segment_light(vec3 ro, vec3 rd, Hit hit, vec3 albedo,\n                   vec3 light_start, vec3 light_end, float n) {\n    vec3 hit_pos = ro + rd * hit.dist;\n    vec3 normal = hit.norm;\n    vec3 litSurface = vec3(0.0);\n    vec3 finalLightColor = vec3(0.0);\n\n    vec3 A = light_start;\n    vec3 B = light_end;\n    vec3 P = hit_pos;\n\n    float light_intensity = 2.0;\n    vec3 surface_reflection = reflect(-rd, normal);\n\n    vec3 rf = refract(rd, normal, 1. / 1.33);\n    vec3 sd = normalize(vec3(0, 0.3, -1.0));\n    float fres = clamp((pow(1. - max(0.0, dot(-normal, rd)), 5.0)), 0.0, 1.0);\n    float spec = 0.13;\n\n    vec3 surface_albedo = albedo;\n    surface_albedo = mix(surface_albedo, vec3(0.1), smoothstep(0.2, 0.9, length(P.xy) - 0.5)); \n\n    {\n        float t = 0.0;\n        vec3 diffuseMRP = mrp_diffuse(hit_pos, A, B, t);\n\n        finalLightColor = mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.5, 0.0), t) * 1.5;\n        //finalLightColor =\n        //    mix(spc(sin(iTime), 1.), spc(cos(iTime - PI / 3.), 1.), t);\n\n        vec3 light_dir = diffuseMRP - hit_pos;\n        light_dir = normalize(light_dir);\n\n        float NdotL = sat(dot(normal, light_dir));\n\n        float falloff = compute_falloff(hit_pos, diffuseMRP);\n\n        litSurface += (surface_albedo / PI) * finalLightColor *\n                      light_intensity * falloff * NdotL;\n    }\n\n    {\n        float t = 0.0;\n        vec3 specularMRP =\n            mrp_specular(hit_pos, A, B, surface_reflection, t);\n        finalLightColor = mix(vec3(1.0, .3, .5), vec3(1.0, 1.0, 0.0), t);\n        finalLightColor = mix(finalLightColor, vec3(1.0), 0.4);\n\n        vec3 light_dir = specularMRP - hit_pos;\n        light_dir = normalize(light_dir);\n\n        float NdotL = sat(dot(normal, light_dir));\n\n        vec3 H = normalize(-rd + light_dir);\n\n        float NdotH = sat(dot(normal, H));\n\n        float falloff = compute_falloff(hit_pos, specularMRP);\n\n        float surface_roughness = 0.1;\n        litSurface += 0.25 * vec3(pow(NdotH, pow(1000.0, 1.0 - surface_roughness))) *\n                      finalLightColor * light_intensity * falloff * NdotL;\n    }\n\n    return litSurface;\n}\n\nvec3 get_material(vec3 ro, vec3 rd, Hit hit) {\n    vec3 pos = ro + rd * hit.dist;\n    vec3 nor = hit.norm;\n    vec3 uvw = pos;\n    vec3 ddx_uvw = uvw + dFdx(uvw); \n    vec3 ddy_uvw = uvw + dFdy(uvw); \n\n    vec3 col;\n    switch (hit.mat_id) {\n        // water\n        case 1:\n            float spec = 0.5;\n            vec3 waterCol = sat(spc(spec - 0.1, 0.4)) *\n                (0.4 * pow(min(pos.y * 0.7 + 0.9, 1.8), 4.) *(rd.z * 0.15 + 0.85));\n            col = waterCol * 3.;\n            break;\n        // right wall\n        case 2: {\n            col = pattern_filtered(uvw, ddx_uvw, ddy_uvw, iTime, 1., iResolution.xy);\n            col = mix(col, vec3(0.), smoothstep(.5, 0., pos.y + 0.7));\n            break; }\n        // up right\n        case 3:\n            col = boxy_filtered(uvw, ddx_uvw, ddy_uvw, iTime);\n            break;\n        // up left\n        case 4:\n            col = boxy_filtered(uvw, ddx_uvw, ddy_uvw, iTime);\n            break;\n        // left wall\n        case 5:\n            col = pattern_filtered(uvw, ddx_uvw, ddy_uvw, iTime, 1., iResolution.xy);\n            col = mix(col, vec3(0.), smoothstep(.5, 0., pos.y + 0.7));\n            break;\n        case 6:\n            col = vec3(0.);\n            break;\n        default:\n            col = vec3(1.);\n            break;\n    }\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    Hit hit = trace(ro, rd);\n    vec3 albedo = get_material(ro, rd, hit);\n    vec3 pos = ro + rd * hit.dist;\n    float c = 5.;\n    float center = floor((pos.z + c / 2.) / c) * c;\n\n    vec3 light_start = vec3(0., 1.05, 0.0);\n    vec3 light_end = vec3(0.9, 0.4, 0.0);\n\n    light_start += vec3(0.0, 0.0, center);\n    light_end += vec3(0.0, 0.0, center);\n    \n    vec3 col = vec3(0.);\n    if (hit.dist < 1e9) {\n        col = segment_light(ro, rd, hit, albedo, light_start, light_end, center);\n        float neighbour = ((pos.z > center) ? 1.0 : -1.0) * c;\n        light_start += vec3(0., 0., neighbour);\n        light_end += vec3(0., 0., neighbour);\n        col += segment_light(ro, rd, hit, albedo, light_start, light_end, neighbour);\n\n        col = mix(col, vec3(0.), smoothstep(0.4, 0.9, length((ro + rd * hit.dist).xy) - 0.5));\n    }\n    \n    float fog = 1. - exp((15. - hit.dist) * .10);\n    col = mix(col, vec3(0.00), max(fog, 0.));\n    \n    return col;\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   \n    vec3 ro = vec3(.0, 0., -9.);\n    vec3 rd = normalize(vec3(uv, 1.));\n\n    ro.z += time;\n    \n    vec3 col = render(ro, rd);\n    \n    col += GLOW * mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.5, 0.0), 0.5);\n\n    col = ACESFilm(col);\n    col = pow(col, vec3(1. / 3.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float MIN_FLOAT = 1e-6;\nconst float MAX_FLOAT = 1e6;\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n#define sat(x) clamp(x, 0., 1.)\n#define S(a, b ,x) smoothstep(a, b, x)\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash11(float p) {\n    return fract(sin(p * 78.233) * 43758.5453);\n}\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nstruct Hit {\n    float dist;\n    vec3 norm;\n    int mat_id;\n};\n\nHit default_hit() {\n    return Hit(1e9, vec3(0.), -1);\n}\n\nHit _min(Hit a, Hit b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 rp = po - ro;\n        float t = dot(rp, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool clamped_plane(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, in float border, out float dist) {\n    vec3 orto = cross(pn, vec3(0., 0., 1.));\n    bool floor = plane_hit(ro, rd, po, pn, dist);\n    vec3 hit_pos = ro + rd * dist;\n    vec3 from_orig = po - hit_pos;\n    return floor && abs(dot(orto, from_orig)) < border;\n}\n\nfloat sd_capped_cylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sd_capped_torus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n    p.x = abs(p.x);\n    float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n    return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat sd_capsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n  return length(pa - ba * h) - r;\n}\n\nvec2 polar_mod(vec2 p, float n) {\n    float a = mod(atan(p.y, p.x), TAU / n) - PI / n;\n    return vec2(sin(a), cos(a)) * length(p);\n}\n\nfloat rand_in_range(float x, float a, float b) {\n    return a + hash11(x) * (b - a);\n}\n\n#define march_macro(func, ro, rd, steps, tmin, tmax, res)       \\\n    {                                              \\\n        float t = tmin;                            \\\n        for (int i = 0;; ++i) {                    \\\n            vec3 p = (ro) + (rd) * t;              \\\n            float d = func(p);                     \\\n            if (abs(d) < 0.001) {                  \\\n                res = vec2(t, 1.);                 \\\n                break;                             \\\n            }                                      \\\n            t += d;                                \\\n            if (t > (tmax) || i > (steps)) {       \\\n                res = vec2(t, -1.);                \\\n                break;                             \\\n            }                                      \\\n        }                                          \\\n    }\n\n\n#define get_norm_macro(func, p, res)                               \\\n    {                                                              \\\n        mat3 k = mat3(p, p, p) - mat3(0.0001);                     \\\n        res = normalize(vec3(func(p)) -                            \\\n                        vec3(func(k[0]), func(k[1]), func(k[2]))); \\\n    }\n\nmat3 get_cam(in vec3 eye, in vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nvec3 mrp_diffuse(vec3 P, vec3 A, vec3 B, out float t) {\n    vec3 PA = A - P, PB = B - P, AB = B - A;\n    float a = length(PA), b = length(PB);\n    t = sat(a / (b + a));\n\treturn A + AB * t;\n}\n\nvec3 mrp_specular(vec3 P, vec3 A, vec3 B, vec3 R, out float t) {\n    vec3 PA = A - P, PB = B - P, AB = B - A;\n\n    float t_num = dot(R, A) * dot(AB, R) + dot(AB, P) * dot(R, R) -\n                  dot(R, P) * dot(AB, R) - dot(AB, A) * dot(R, R);\n    float t_denom = dot(AB, AB) * dot(R, R) - dot(AB, R) * dot(AB, R);\n    t = sat(t_num / t_denom);\n\n    return A + AB * t;\n}\n\nfloat compute_falloff(vec3 position, vec3 light_position) {\n    float d = distance(position, light_position);\n    return 1.0 / (d * d);\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(2.0 * PI * (c * t + d));\n}\nvec3 spc(float n, float bright) {\n    return pal(n, vec3(bright), vec3(0.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n}\n\n\n/////////////////////////////////////////\nint MaxSamples = 10;\n\nfloat loop_noise(float x, float loopLen) {\n    // cycle the edges\n    x = mod(x, loopLen);\n\n    float i = floor(x);  // floored integer component\n    float f = fract(x);  // fractional component\n    float u =\n        f * f * f * (f * (f * 6. - 15.) + 10.);  // use f to generate a curve\n\n    // interpolate from the current edge to the next one wrt cycles\n    return mix(hash11(i), hash11(mod(i + 1.0, loopLen)), u);\n}\n\n// Hi Shane :x\nvec3 boxy(vec3 sp, float time) {\n    const vec2 sc = vec2(1. / 2., 1. / 4.);\n    float sf = .005;\n    vec2 p = rot(PI / 6.) * sp.zy;\n    float iy = floor(p.y / sc.y);\n    float rndY = hash21(vec2(iy));\n    vec2 ip = floor(p / sc);\n    p -= (ip + .5) * sc;\n\n    float a = atan(sc.y, sc.x) + PI / 9.;\n    vec2 pR = rot(-a) * p;\n    float tri = pR.y < 0.? -1. : 1.;\n    ip.x += tri * .5; \n\n    p = abs(p) - sc / 2.;\n    float shp = max(p.x, p.y);\n    shp = max(shp, -tri * pR.y);\n\n    vec3 texCol = vec3(.04) + hash21(ip) *.02;\n    texCol = mix(texCol, texCol * 2.5, (smoothstep(sf * 3.5, 0., abs(shp) - .015)));\n    texCol = mix(texCol, vec3(0), (smoothstep(sf, 0., abs(shp + .06) - .005))*.5);\n\n    if(abs(ip.y + 2.) > 7. && hash21(ip + .11) < .1){\n        float sh = max(.1 - shp/.08, 0.);\n        texCol = mix(texCol, vec3(0), smoothstep(sf, 0., shp));\n        texCol = mix(texCol, vec3(sh), smoothstep(sf, 0., shp + .02));\n        texCol = mix(texCol, vec3(0), smoothstep(sf, 0., shp + .04));\n        texCol = mix(texCol, spc(hash21(ip), 1.)*.2, smoothstep(sf, 0., shp + .06));\n    } \n    return texCol;\n}\n\n// iq https://www.shadertoy.com/view/MdjGR1\nvec3 boxy_filtered( in vec3 uvw, in vec3 ddx_uvw, in vec3 ddy_uvw, in float time ) {\n    int sx = 1 + int(clamp(4.0 * length(ddx_uvw - uvw), 0.0, float(MaxSamples - 1)));\n    int sy = 1 + int(clamp(4.0 * length(ddy_uvw - uvw), 0.0, float(MaxSamples - 1)));\n\n\tvec3 no = vec3(0.0);\n\n    for( int j=0; j < sy; j++) {\n        for( int i = 0; i < sx; i++) {\n            vec2 st = vec2(float(i), float(j)) / vec2(float(sx), float(sy));\n            no += boxy(uvw + \n                    st.x * (ddx_uvw - uvw) + st.y * (ddy_uvw - uvw), time);\n        }\n    }\n\n\treturn no / float(sx * sy);\n}\n\nconst float RECORD_PERIOD = 50.;\n\nvec3 pattern(vec3 p, float time, float n) {\n    p *= 100.;\n    vec2 uv = p.yz + vec2(2000., 2000.);\n    float num_seg = n;\n\n    float loop_length = RECORD_PERIOD;\n    float transition_start = RECORD_PERIOD / 3.;\n\n    float phi = atan(uv.y, uv.x + 1e-6);\n    phi = phi / PI * 0.5 + 0.5;\n    float seg = floor(phi * num_seg);\n    float width = sin(seg) + 8.;\n\n    float theta = (seg + 0.5) / num_seg * PI * 2.;\n    vec2 dir1 = vec2(cos(theta), sin(theta));\n    vec2 dir2 = vec2(-dir1.y, dir1.x);\n    \n    float radial_length = dot(dir1, uv);\n    float prog = radial_length / width;\n    float idx = floor(prog);\n\n    const int NUM_CHANNELS = 3;\n    vec3 col = vec3(0.);\n    for (int i = 0; i < NUM_CHANNELS; ++i) {\n        float off = float(i) / float(NUM_CHANNELS) - 1.5;\n        time = time + off * .015;\n\n        float theta1 = loop_noise(idx * 34.61798 + time,      loop_length);\n        float theta2 = loop_noise(idx * 21.63448 + time + 1., loop_length);\n\n        float transition_progress =\n            (time - transition_start) / (loop_length - transition_start);\n        float progress = clamp(transition_progress, 0., 1.);\n\n        float threshold = mix(theta1, theta2, progress);\n\n        float width2 = fract(idx * 32.721784) * 500.;\n        float slide = fract(idx * seg * 32.74853) * 50. * time;\n        float prog2 = (dot(dir2, uv) - slide) / width2;\n\n        float c = clamp(width  * (fract(prog)  - threshold),      0., 1.)\n                * clamp(width2 * (fract(prog2) + threshold - 1.), 0., 1.);\n\n        col[i] = c;\n    }\n    \n    return col;\n}\n\nvec3 pattern_filtered( in vec3 uvw, in vec3 ddx_uvw, in vec3 ddy_uvw, in float time, float n, vec2 res) {\n    float pixel_uv_size = res.y / 5.;\n    int sx = 1 + int(clamp(4.0 * length(ddx_uvw - uvw) * pixel_uv_size, 0.0, float(MaxSamples - 1)));\n    int sy = 1 + int(clamp(4.0 * length(ddy_uvw - uvw) * pixel_uv_size, 0.0, float(MaxSamples - 1)));\n    \n\tvec3 no = vec3(0.0);\n\n    for( int j=0; j < sy; j++) {\n        for( int i = 0; i < sx; i++) {\n            vec2 st = vec2(float(i), float(j)) / vec2(float(sx), float(sy));\n            no += pattern(uvw + \n                    st.x * (ddx_uvw - uvw) + st.y * (ddy_uvw - uvw), time, n);\n        }\n    }\n\n\treturn no / float(sx * sy);\n}","name":"Common","description":"","type":"common"}]}