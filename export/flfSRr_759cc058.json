{"ver":"0.1","info":{"id":"flfSRr","date":"1625757376","viewed":92,"name":"SDF - RAY 01","username":"pedrogarlaschi","description":"First Attempt of Ray Marching\nThanks to Yuri Artyukh and his great tutorial.\n\nFinally getting a better understanding of it. \n\nhttps://www.youtube.com/watch?v=q2WcGi3Cr9w&t=1872s","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","raymaching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 32\n// SDF function from a sphere\nfloat sdSphere(vec3 p , float r ){\n  return length(p)-r;\n}\n\nvec2 matcap(vec3 eye, vec3 normal) {\n  vec3 reflected = reflect(eye, normal);\n  float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\n  return reflected.xy / m + 0.5;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\treturn (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\n}\n\n// \nfloat f(vec3 p){\n    \n   \n   float px = ((iMouse.x / iResolution.x) * 2.) - 1.;\n   float py = ((iMouse.y / iResolution.y) * 2.) - 1.;\n   vec3 pRot = rotate(p , vec3(1. , 1. , 0.) , iTime * 0.8);\n    \n    float box = sdBox(pRot , vec3(0.20));\n    float sBox = sdSphere(p, 0.25);\n    float roundBox = smin(box,sBox,0.2);\n    \n    \n    float sphere = sdSphere(p - vec3(px  , py ,0.) , 0.2);\n    \n    return smin(roundBox,sphere,0.2);\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(f(p+h.xyy) - f(p-h.xyy),\n                           f(p+h.yxy) - f(p-h.yxy),\n                           f(p+h.yyx) - f(p-h.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord/(iResolution.x);\n    uv += vec2(0.,0.25);\n\n    vec3 camPo = vec3(0.,0.,2.);\n    vec3 rayPo = camPo;\n    vec3 ray = normalize(vec3((uv - vec2(0.5)) , -1));\n    \n    float t = 0.;\n    float tMax = 5.;\n\n    for(int i = 0 ; i < STEPS ; ++i){\n    \n        vec3 pos = rayPo + t * ray;\n        float h = f(pos);\n        if(h < 0.0001 || h > tMax)break;\n        t += h;\n    \n    }\n    \n    vec3 col = vec3(0.);\n    \n    if(t < tMax)\n    {\n        vec3 pos = rayPo + t * ray;\n        vec3 normal = calcNormal(pos);\n        \n        float diff = dot(vec3(0.1,0.  , 1.),normal);\n        col = vec3(diff);\n        vec2 matcapUV = matcap(ray , normal);\n        col = vec3(matcapUV,1.);\n        col = vec3(matcapUV,0.);\n        //col = texture( iChannel0, matcapUV ).xyz;\n       \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}