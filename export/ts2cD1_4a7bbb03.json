{"ver":"0.1","info":{"id":"ts2cD1","date":"1588137712","viewed":85,"name":"Mandelbrot with matrices","username":"iyadahmed","description":"follow for more!\nlet me know your thoughts on this in the comments!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","math","mandelbrot","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// please use this code as much as possible :)\n// a mention would be generous <3\n\n#define MAXITER 4096\n#define DEPTH 32\n#define FOCUS vec2(-0.81153120295763,  0.20142958206181)\n#define ZOOM 0.1\n#define eps .00001\n#define eps2 eps * eps\n\n\nvec3\ncolor(int iteration, float sqLengthZ) {\n    // If the point is within the mandlebrot set\n    // just color it black\n    if(iteration == MAXITER)\n        return vec3(0.0);\n \n    // Else we give it a smoothed color\n   \tfloat ratio = (float(iteration) - log2(log2(sqLengthZ))) / float(MAXITER);\n \n    // Procedurally generated colors\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), sqrt(ratio));\n}\n \nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord) { \n    \n    // C is the aspect-ratio corrected UV coordinate.\n    vec2 c_v = (-1.0 + 2.0 * fragCoord / iResolution.xy) * vec2(iResolution.x / iResolution.y, 1.0);\n \t\n    // Apply scaling, then offset to get a zoom effect\n    c_v = ((c_v - FOCUS) * ZOOM)+ FOCUS;\n    \n    // Represent complex numbers as matrices\n    mat2 der = mat2(1.0, 0.0, 0.0, 1.0);\n        \n\tmat2 c = mat2(c_v.x, -c_v.y,\n                  c_v.y, c_v.x);\n \tmat2 z = c;\n    \n    int j=0; //doesn't work on mobile without this :/\n \t\n    for (int i=0; i < MAXITER; i++){\n        \n        if (determinant(der) < eps2){\n        \tj = MAXITER;    \n            break;\n        }\n        \n        if (determinant(z) > 32.0) break;\n        der = der * 2.0 * z;\n        // The larger the square length(detirminant) of Z,\n        // the smoother the shading\n        \n        \n\t\t// Complex multiplication, then addition\n        \n \t\tz = z * z + c;\n        j++;\n    }\n \n    // Generate the colors\n    fragColor = vec4(color(j, determinant(z)), 1.0);\n \n    // Apply gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.5));\n}","name":"Image","description":"","type":"image"}]}