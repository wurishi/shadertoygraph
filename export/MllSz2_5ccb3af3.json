{"ver":"0.1","info":{"id":"MllSz2","date":"1438243988","viewed":385,"name":"Colored Smooth XOR Pattern","username":"tholzer","description":"Smoothing out a bit the discontinous XOR pattern and colorize it.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","hsv","xor","pattern","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Colored Smooth XOR Pattern\n// Smoothing out a bit the discontinous XOR pattern and colorize it.\n// 'Smooth XOR' created by inigo quilez - iq/2015\n//   https://www.shadertoy.com/view/ll2GWy\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix(vec3(1.0),clamp((abs(fract(h+vec3(3.0, 2.0, 1.0)/3.0)*6.0-3.0)-1.0), 0.0, 1.0),s)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = 256.0 * fragCoord.xy / iResolution.x + iTime;\n\n  float an = smoothstep( -0.5, 0.5, cos(3.14159*iTime) );\n  float x = 0.0;\n  for( int i=0; i<7; i++ ) \n  {\n    vec2 a = floor(p);\n    vec2 b = fract(p);\n  \n    x += mod( a.x + a.y, 2.0 ) \n      // the following line implements the smooth xor\n      * mix( 1.0, 1.5*pow(4.0*(1.0-b.x)*b.x*(1.0-b.y)*b.y,0.25), an );\n      \n    p /= 2.0;\n    x /= 2.0;\n  }\n  vec3 col = hsv(fract(0.1*iTime),1.,1.);\n  fragColor = vec4( col*x, 1.0 );\n}","name":"","description":"","type":"image"}]}