{"ver":"0.1","info":{"id":"7dfyzH","date":"1641689486","viewed":76,"name":"ollj's concerto number 019","username":"floopfloop","description":"https://www.shadertoy.com/view/XsBczV","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["sdf","cellshading","edge","occlusion","lipschitz","outline","hgsdf","toonshade","dynamiceps","sell","logeps","cellshade"],"hasliked":0,"parentid":"7tKXWt","parentname":"Fork 019 transp floopfloop 802"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// like a tiny beetle crawling over the palace of versailles,\n// floopfloop adapts ollj's https://www.shadertoy.com/view/XsBczV\n// to a format readable by mere mortals\n\n#define time iTime\n//#define time 1.\n\n//maximum raymarching iterations\n#define raymarch_iterations 256\n\n//epsilon?\n#define eps 2e-2\n\n//2d rotation r=3.14 -> half rotation roundrclockwise\n#define rotate_2d(r) mat2(cos(r),-sin(r),sin(r),cos(r))\n\n//because scaling a first derivative is fun and totally awesome, not!\n//return s3d sinusoidial \"blob_displacement\" of [p].\n#define blob(p) (sin(p.x)*sin(p.y)*sin(p.z))\n\n// returns distance of [p] to closest surface, defined by function.\n// if return value is made a vec4, .xyz can store additional texture values.\nfloat scene_distance(vec3 p) {\n    // scene repetition\n    p = fract(p);\n    \n    //blobbyness\n    float k = 20. * (sin(time * .5) * .5 + .9);\n    \n    // circle\n    float d = length(p - 0.5) - .2;\n    // plus sinusoidal blob\n          d += blob(k * p) * .1;\n          \n    return d;\n}\n\n// ollj's original comments:\n//toon-shading may multiply 2 distances by [0. < ghost_gloom.xy <= 1.]\n// one of the values should be [v == 1.]\n// the other should be [0 < n <= 1.]\n//setting only .y lower makes it gloomy, celshading dominates what is below it\n//setting only .x lower makes it ghosty, testure below celshading bleeds into its cel.\nvec2 slide_ghost_gloom() {\n\n    // mouse.x to centered uv coords\n    float m = iMouse.x / iResolution.x - .5;\n    \n    // if mouse not pressed, animate automatically\n    if (iMouse.z <= 0.) {\n        m = cos(time) * .5;\n    }\n    \n    // in full context, if the mouse is on the left, scale the outline dist (.y)\n    // otherwise, scale the surface dist (.x)\n    if(m < 0.) {\n        return vec2(1, 1. + m * 2.);\n    } else {\n        return vec2(1. - m * 2., 1);\n    }\n}\n\n// ollj's original comments:\n// calculate 2 distances at once is useful to:\n// - better visualize a distance field. -> analyze errors in the df easier.\n// - - it basically visualizes ONE first derivative!!!\n// - - as a transparent cartoon outline (half assed cellshading)\nvoid raymarch(vec3 ray_origin, vec3 ray_dir, inout float surface_dist, inout float outline_dist) {\n    \n    for(int i = 0;i < raymarch_iterations; ++i) {\n    \n        float scene_surface_dist = scene_distance(ray_origin + ray_dir * surface_dist);\n        float scene_outline_dist = scene_distance(ray_origin + ray_dir * outline_dist);\n        \n        // https://en.wikipedia.org/wiki/Lipschitz_continuity\n        float reciprocal_lipschitz = .5;\n        \n        vec2 ghost_gloom = slide_ghost_gloom();\n        \n        surface_dist += scene_surface_dist * reciprocal_lipschitz * ghost_gloom.x;\n        \n        if(eps - scene_outline_dist < 0.) {\n            //step forward\n            outline_dist += scene_outline_dist * reciprocal_lipschitz * ghost_gloom.y;\n        }\n    \n        // in practice, can be used to make outlines fade into the distance\n        //scene_surface_dist = pow(abs(scene_surface_dist), pow(abs(surface_dist), .5));\n    \n        if(scene_surface_dist < eps * .05) {\n            break;\n        }\n    }\n}\n            \nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    // frag coord to centered uv coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    // un-stretch the wider axis\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ray_origin = vec3(0,0,-.2);\n    vec3 ray_dir = normalize(vec3(uv, 1));\n    mat2 rot_mat = rotate_2d(time * .2);\n\n    // ollj: use same 2d rotation 2x on different axes\n    ray_dir.yz *= rot_mat;\n    ray_dir.xy *= rot_mat;\n\n    float surface_dist = 0.;\n    float outline_dist = 0.;\n\n    raymarch(ray_origin, ray_dir , surface_dist, outline_dist);\n\n    vec3 surface_coord = ray_origin + ray_dir * surface_dist;\n    \n    float outline_dist_squared = outline_dist * outline_dist;\n    float surface_dist_cubed = surface_dist * surface_dist * surface_dist;\n    // how does it work?? magnets\n    vec3 color = fract(surface_coord) * mod(surface_coord, 3.) * outline_dist_squared / surface_dist_cubed;\n\n    fragColor = vec4(color, 1);\n}\n            \n","name":"Image","description":"","type":"image"}]}