{"ver":"0.1","info":{"id":"NtGSWw","date":"1640805652","viewed":76,"name":"Milk's Mandelbrot Explorer","username":"Milk","description":"Mandelbrot set viewer!\n\nUse the arrow keys to move the viewport and the +/- or </> keys to zoom in and out.\n\n Might add more fractal choices and maybe a color picker if possible?\n\nAlso I think there is a bug in the coloring system, gotta work that out.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////\n//                                  //\n//    COME EXPLORE THIS FRACTAL!    //\n//                                  //\n//  ------------------------------  //\n//             CONTROLS             //\n//                                  //\n//  Use the arrow keys to control   //\n//  the viewport position           //\n//                                  //\n//  Use +/-|</> to zoom in and out  //\n//                                  //\n//////////////////////////////////////\n \n// The color palette to assign from. In order from fewest to most iterations to escape\n// GLSL is not dynamic so adjust the size of the array accordingly\nvec3[5] palette = vec3[](\n    vec3(0, 0, 0),\n    vec3(1.00, 0.49, 0.00),\n    vec3(1.00, 0.67, 0.00),\n    vec3(1.00, 0.84, 0.00),\n    vec3(1.00, 0.08, 0.00)\n);\n// The number of the colors in the palette to use (0 indexed)\nint NUM_COLORS = 5;\n\n// Iteration rules. I've found that the best number of iteration (aesthetically)\n// changes depending on how zoomed in you are. Further out too many iterations introduce\n// a lot of noise, in close too few iterations result in too little detail. \n// Zooming is exponential to not be painfully slow, so min and max help tame the scaling\n// of the number of iterations. The natural log of the zoom is multiplied by the ITERATIONS_MOD\n// varible to get the number of iterations at any zoom leve.\n//\n// Increase MIN_ITERATION if there is too little detail when zoomed all the way out (start zoom)\n// Decrease if image is too noisy\nint MIN_ITERATIONS = 100;\n// Increase MAX_ITERATION if there is too little detail at zoomed in very far (nearing precision limit)\n// Decrease if too noisy or (more likely) performance is bad at high zoom\nint MAX_ITERATIONS = 1200;\n// Fine tune for middle zoom detail levels and decrease if performance is bad before hitting max\nint ITERATIONS_MOD = 200;\nfloat ESC_RADIUS = 4.0f;\n\nvec2 GetOffset() {\n    return texelFetch(iChannel1, ivec2(0,0), 0).xy;\n}\n\nfloat GetZoom() {\n    return texelFetch(iChannel1, ivec2(0,1), 0).x;\n}\n\nvec2 getUV(vec2 fragCoord, vec2 sampleOffset) {\n    float uv1x = 1.0/ (iResolution.x/4.0);\n    float uv1y = 1.0/ (iResolution.y/4.0);\n    sampleOffset.x *= uv1x;\n    sampleOffset.y *= uv1y;\n    \n    vec2 uv = (fragCoord + sampleOffset) - (iResolution.xy * 0.5);\n\tuv /= min( iResolution.x, iResolution.y );\n    uv *= 2.5;\n    uv /= GetZoom();\n    uv += GetOffset();\n\n    return uv;\n}\n\nvec4 getColorAtUV(vec2 uv, int max_iterations) {\n        // Iterate the point to see if it is bound\n    int i = 0;\n    vec2 cur = vec2(0.0f, 0.0f);\n    while(i < max_iterations && pow(cur.x,2.0f) + pow(cur.y,2.0f) < ESC_RADIUS) {\n        i++;\n        vec2 next = vec2(\n            pow(cur.x, 2.0f) - pow(cur.y, 2.0f) + uv.x,\n            2.0f*cur.x*cur.y + uv.y\n        );\n        cur = next;\n    }\n\n    // Output to screen\n    int color_index = int(float(i)/float(max_iterations)*float(NUM_COLORS));\n    vec3 color = palette[color_index];\n    vec3 next_color = palette[min(color_index + 1, NUM_COLORS)];\n    float mix_ammount = mod((float(i)/(float(max_iterations)*float(NUM_COLORS))), 1.0);\n\n    return vec4(mix(color, next_color, mix_ammount), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = getUV(fragCoord, vec2(0,0));\n    vec2 uv2 = getUV(fragCoord, vec2(1,0));\n    vec2 uv3 = getUV(fragCoord, vec2(0,1));\n    vec2 uv4 = getUV(fragCoord, vec2(1,1));\n    \n    int max_iterations = min(max(int(log(GetZoom()) * float(ITERATIONS_MOD)), MIN_ITERATIONS), MAX_ITERATIONS);\n    \n    vec4 color = getColorAtUV(uv1, max_iterations);\n    color += getColorAtUV(uv2, max_iterations);\n    color += getColorAtUV(uv3, max_iterations);\n    color += getColorAtUV(uv4, max_iterations);\n    \n    color /= 4.0;\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Is(x) (ivec2(fragCoord) == x)\n#define LastPosition   ivec2(0, 0)\n#define LastZoom       ivec2(0, 1)\n\nconst float SPEED = 10.0f;\nconst float ZOOM_SPEED = 0.01;\n\nfloat MIN_ZOOM = 1.0;\n\nconst int KEY_LEFT         = 37;\nconst int KEY_UP           = 38;\nconst int KEY_RIGHT        = 39;\nconst int KEY_DOWN         = 40;\nconst int KEY_MINUS        = 189;\nconst int KEY_PLUS         = 187;\nconst int KEY_COMMA        = 188;\nconst int KEY_PERIOD       = 190;\n\nfloat IsKeyPressed(int key) {\n    return texelFetch(iChannel0, ivec2(key, 0), 0).x;\n}\n\n// Zoom\nvec4 CreateZoom(in float zoom, in float zoom_speed) {\n    zoom = max(zoom, MIN_ZOOM);\n    return vec4(zoom, zoom_speed, 0, 0);\n}\n\nfloat GetLastZoom() {\n    return texelFetch(iChannel1, LastZoom, 0).x;\n}\n\nfloat GetLastZoomSpeed() {\n    return texelFetch(iChannel1, LastZoom, 0).y;\n}\n\nvoid UpdateZoom(inout vec4 fragColor) {\n    float zoomInKeyPressed = max(IsKeyPressed(KEY_PLUS), IsKeyPressed(KEY_PERIOD));\n    float zoomOutKeyPressed = max(IsKeyPressed(KEY_MINUS), IsKeyPressed(KEY_COMMA));\n\n    float adjusted_zoom_speed = ZOOM_SPEED * GetLastZoom() * iTimeDelta;\n    float zoom_delta = (zoomInKeyPressed - zoomOutKeyPressed) * (GetLastZoomSpeed() + adjusted_zoom_speed);\n    fragColor = CreateZoom(\n        GetLastZoom() + zoom_delta,\n        GetLastZoomSpeed() + (ZOOM_SPEED * zoom_delta)\n    );\n}\n\n// Position\nvec4 CreatePosition(in vec2 position, in float speed) {\n    return vec4(position, speed, 0);\n}\n\nvec2 GetLastPosition() {\n    return texelFetch(iChannel1, LastPosition, 0).xy;\n}\n\nfloat GetLastSpeed() {\n    return texelFetch(iChannel1, LastPosition, 0).z;\n}\n\nvoid UpdatePosition(inout vec4 fragColor) {\n    float adjusted_speed = (SPEED/GetLastZoom()) * iTimeDelta;\n    float v_delta = (IsKeyPressed(KEY_UP) - IsKeyPressed(KEY_DOWN)) * adjusted_speed;\n    float h_delta = (IsKeyPressed(KEY_RIGHT) - IsKeyPressed(KEY_LEFT)) * adjusted_speed;\n    fragColor = vec4(\n        GetLastPosition() + vec2(h_delta, v_delta),\n        GetLastSpeed(),\n        0\n    );\n}\n\n// Init\nvec4 init(in vec2 fragCoord) {\n    if(Is(LastPosition)) {\n        return CreatePosition(vec2(0.0, 0.0), 0.0);\n    }\n    if(Is(LastZoom)) {\n        return CreateZoom(1.0, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(iFrame == 0) {\n        fragColor = init(fragCoord);\n        return;\n    }\n    \n    \n    if(Is(LastPosition)) {\n        UpdatePosition(fragColor);\n        return;\n    }\n    if(Is(LastZoom)) {\n        UpdateZoom(fragColor);\n        return;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}