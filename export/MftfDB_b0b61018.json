{"ver":"0.1","info":{"id":"MftfDB","date":"1733481606","viewed":178,"name":"A topology trick","username":"Cewein","description":"This shader showcase a topology trick. \nIt feature :\n  - a 3 key frame animation.\n  - Cook-Terance BRDF for physically based rendering\n  - procedural flooring, infinity shaper and animation.\n  - dirty anti aliasing using super sampling.","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing","pbr","topology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader made by Maximilien \"Cewein\", December 2024\n//\n// This shader showcase a topology trick.\n// It feature a 3 key frame animation.\n// Cook-Torrance BRDF for physically based rendering\n// procedural flooring, infinity shaper and animation.\n// dirty anti aliasing using super sampling.\n//\n// Possible improvement :\n// - better controle over the BRDF\n// - a proper SSBRDF\n// - switch to pathtracing and using restir + denoising\n//\n//\n// main help came from here : \n// https://digibug.ugr.es/bitstream/handle/10481/19751/rmontes_LSI-2012-001TR.pdf?sequence=1&isAllowed=y\n// https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n// https://iquilezles.org/articles/rmshadows/\n//\n//\n\n\n///// CONSTANT /////\n\n#define MAX_STEP 200\n#define MAX_DIST 200.0\n\n//Basic super sampling anti aliasing\n//It make the scene less aliased but is heavy on perf\n//proper use of mipmap here could have been more fun (i.e render the floor texture in as seperate buffer then mipmap it)\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n///// RAY MARCHING FUNCTION /////\n\n\n// Function to determine distance to the nearest object from a given position in the scene\n// return a vec2, x is the distance, y is the material\nvec2 map(vec3 pos) {\n    vec2 dm = vec2(0.0, 0.5);\n    float total = MAX_DIST;\n    \n    \n    //// GROUND\n    \n    float ground = pos.y;\n    if (total > ground)\n        dm.y = 2.5;\n    total = min(total, ground);\n\n    //// CHAIN         \n    vec3 chainPos = pos - vec3(0.0, 1.5, 0.0);\n    chainPos.xy *= rot(90.0);\n    \n    // paramteres\n    const float le = 0.13, r1 = 0.2, r2 = 0.09;\n    \n    // make a chain out of sdLink's\n    vec3 a = chainPos; a.y = fract(a.y    )-0.5;\n    vec3 b = chainPos; b.y = fract(b.y+0.5)-0.5;\n    \n    // evaluate two links\n    float chain = min(sdLink(a.xyz,le,r1,r2), sdLink(b.zyx,le,r1,r2));\n    \n    if (total > chain)\n        dm.y = 3.5;\n    total = min(total, chain);\n    \n    vec3 posTorus = opRepetition(pos, vec3(6.0,0.0,0.0));\n\n    //// ANIMATION OF THE TRICKS\n    float torus = mapTopoTrickAnimation(posTorus, iTime);\n    if (total > torus)\n        dm.y = 4.5;\n    total = min(total, torus);\n\n    dm.x = total;\n\n    return dm;\n}\n\n// Raymarching loop to trace the path of a ray in the scene\nhitPayload trace(hitPayload p) {\n    // Initialize ray distance\n    p.dist = 0.0;\n\n    // Iterate through a fixed number of steps\n    for (int i = 0; i < MAX_STEP; i++) {\n        // Calculate position along the ray\n        p.hitPos = p.orig + p.dist * p.dir;\n        \n        // Get distance to nearest object and debugging information\n        vec2 tmp = map(p.hitPos);\n        \n        // If ray is very close to an object, return hitPayload\n        if (tmp.x < 0.0001)\n            return p;\n        \n        // Update hitPayload with current step information\n        p.nbStep = i;\n        p.dist += tmp.x;\n        p.mat = tmp.y;\n        p.nbStep++;\n\n        // Terminate loop if ray travels beyond maximum distance\n        if (p.dist > MAX_DIST) {\n            p.mat = -1.0; // Set material to -1 to indicate no intersection\n            break;\n        }\n    }\n    \n    // Return final hitPayload after raymarching\n    return p;\n}\n\n///// SHADING FUNCTION /////\n\n// Calculates the surface normal at a given position using finite differencing.\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(0.0001, 0.0);\n    // Finite difference method to approximate the normal vector\n    return normalize(vec3(\n        map(pos + e.xyy).x - map(pos - e.xyy).x,\n        map(pos + e.yxy).x - map(pos - e.yxy).x,\n        map(pos + e.yyx).x - map(pos - e.yyx).x\n    ));\n}\n\n// Computes soft shadows using ray marching.\n// w is the soft shadow factor\n// code by iq : https://iquilezles.org/articles/rmshadows/\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float w) {\n    float res = 1.0;\n    float t = mint; \n    // Iterate through ray marching steps to compute shadow intensity\n    for (int i = 0; i < 256 && t < maxt; i++) {\n        float h = map(ro + t * rd).x; \n        // Update shadow intensity based on distance and width factor\n        res = min(res, h / (w * t));\n        t += clamp(h, 0.005, 0.50);\n        \n        if (res < -1.0 || t > maxt)\n            break;\n    }\n    res = max(res, -1.0);\n    // Smooth and normalize shadow intensity\n    return 0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res);\n}\n\n///// BRDF FUNCTION /////\n\n// Calculates the GGX distribution for microfacet-based shading.\nfloat distribution(vec3 n, vec3 h, float roughness) {\n    float a_2 = roughness * roughness;\n    return a_2 / (PI * pow(pow(max(dot(n, h), 0.0), 2.0) * (a_2 - 1.0) + 1.0, 2.0));\n}\n\n// Computes the Schlick-Beckmann geometry term.\nfloat geometry(float cosTheta, float k) {\n    return (cosTheta) / (cosTheta * (1.0 - k) + k);\n}\n\n// Computes the Smith's approximation for microfacet-based shading.\nfloat smiths(float NdotV, float NdotL, float roughness) {\n    float k = pow(roughness + 1.0, 2.0) / 8.0;\n    return geometry(NdotV, k) * geometry(NdotL, k);\n}\n\n// Computes the Fresnel-Schlick approximation for specular reflection.\nvec3 fresnel(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Computes the Fresnel-Schlick approximation for specular reflection with roughness.\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Computes the Cook-Torrance Bidirectional Reflectance Distribution Function (BRDF)\n// \n// p: Position vector\n// n: Surface normal vector\n// viewDir: View direction vector\n// lightDir: Light direction vector\n// albedo: Surface color (diffuse reflectance)\n// metalness: Metalness factor (0.0 for dielectric, 1.0 for metal)\n// roughness: Surface roughness factor\n// F0: Base color of the material (specular reflectance at normal incidence)\n// energyCompensation: Energy compensation factor to maintain energy conservation\nvec3 BRDF(hitPayload p, vec3 lightDir, vec3 albedo, float metalness, float roughness, vec3 F0, vec3 energyCompensation) {\n    \n    vec3 tangent = normalize(cross(vec3(1.0), p.hitPos));\n    vec3 bitangent = normalize(cross(p.normal, tangent));\n    \n    vec3 h = normalize(p.dir + lightDir); \n    float cosTheta = max(dot(h, p.dir),0.0001);\n    \n    // Lambertian diffuse reflectance\n    vec3 diffuse = albedo;\n\n    // Fresnel term (specular reflectance)\n    vec3 F = fresnelSchlickRoughness(cosTheta, F0, roughness);\n    \n    float NdotL = max(dot(lightDir, p.normal),0.0001);\n    float NdotV = max(dot(p.dir, p.normal),0.0001);\n    \n    // Compute the components of the BRDF\n    float D = distribution(p.normal, h, roughness * roughness);\n    float G = smiths(NdotV, NdotL, roughness * roughness);\n    float V = G / max(0.0001, (4.0 * NdotV * NdotL)); // Avoid division by zero\n    \n    // Specular reflectance component\n    vec3 specular = D * F * V;\n    \n    // Apply energy compensation\n    specular *= energyCompensation;\n    \n    // Combine diffuse and specular components\n    vec3 kD = (1.0 - F) * (1.0 - metalness);\n    return kD * diffuse + specular;\n}\n\n// This function translates a material to the correct color based on hit information.\nmaterial getMaterial(hitPayload p) {\n    // Calculate base color using sky gradient\n    vec3 color = vec3(0.5, 0.7, 1.0) - max(p.dir.y, 0.0) * 0.75;\n\n    // Initialize material with default values\n    material mat = material(color, 0.0, 1.0, 1.0);\n\n    // Check material type and adjust color and properties accordingly\n    if (p.mat > 2.0) { // Floor\n        \n        if(abs(p.hitPos.z) < 2.0)\n            mat = material(vec3(0.4), 0.0, 1.0, 1.0);\n        else if(abs(p.hitPos.z) < 2.5)\n            mat = material(vec3(1.0), 0.1, 0.9, 1.1);\n        else if(abs(p.hitPos.z) > 2.5)\n        {\n            //truchet pattern for fun\n            vec2 uv = p.hitPos.xz;\n            uv = abs(uv)*0.25;\n            vec2 coord = floor(uv);\n            \n            float rand = 2.0*(hash12(coord)-0.5);\n            vec2 gv = (fract(uv) -.5 );\n            \n            float width = 0.25;\n            float d = abs(abs(gv.x + (gv.y * sign(rand))) - 0.5);\n            \n            float mask = smoothstep(0.01,-0.01,(d-width));\n            \n            vec3 color = vec3(1.,.32,0.0) * mask ;\n            \n               \n            mat = material(color, (1.0-mask)+0.25, 0.75, 0.8);\n        }\n        \n        \n    }\n\n    if (p.mat > 3.0) {\n        // Red and shiny metal chain\n        color = vec3(1.75, 0.02, 0.01);\n        mat = material(color, 0.1, 0.1, 0.8); \n    }\n\n    if (p.mat > 4.0) { // Donut\n        // Blue donuts\n        // Ask me and I will try to bring you some\n        // and I promise no trick\n        \n        color = vec3(0.344, 0.782, .95);\n        mat = material(color, 0.4, 0.79, 1.4);\n    }\n\n    return mat;\n}\n\nvec3 render(hitPayload p, material mat)\n{\n    vec3 color = mat.albedo;\n    float roughness = mat.roughness;\n    float metalness = mat.metalness;\n    float IOR = mat.IOR;\n    \n\n    //perform ligthing\n    vec3 sky = vec3(0.5, 0.7, 1.) - max(p.dir.y,0.0)*0.75;\n    vec3 sunDir = vec3(.4,.5,0.73);\n    \n    float shadow = clamp( clamp(dot(p.normal, sunDir),0.0,1.0) * softshadow(p.hitPos + p.normal*1e-5, sunDir, 0.1, 5.0, 0.04), 0.1, 1.0 );\n    \n    vec3 F0 = vec3(pow(IOR - 1.0, 2.0) / pow(IOR + 1.0, 2.0));\n    vec3 energyCompensation = normalize(1.0 + F0 * (1.0 / 10.0 - 1.0));\n\n    color = BRDF(p, vec3(4.4,5.5,7.73), color, metalness,roughness, F0, energyCompensation) * 1.5 * shadow;\n\n    return mix(color, sky, smoothstep(50.0, MAX_DIST-10.0, p.dist));\n}\n\n\n///// RENDERING FUNCTION /////\n\n//this is the quick way to obtain a invervse view matrix\n//go to common to see alternative way with a long process\nmat4 getInvViewMatrix(vec3 ro, vec3 at)\n{\n    vec3 ww = normalize(at-ro); //front\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0))); // rigth;\n    vec3 vv = normalize(cross(uu,ww)); // up;\n    \n    return mat4(uu,0.,\n                vv,0.,\n                -ww,0.,\n                0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //init camera para\n    float angle = -180.0*0.1;\n    float height = 2.0;\n    \n    vec3 total = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates shifting when using AA\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.*(fragCoord+o)-iResolution.xy - 1.0)/iResolution.y;\n#else    \n        vec2 uv = (2.*fragCoord-iResolution.xy - 1.0)/iResolution.y;\n#endif\n    \n    //ray origin and look at point\n    vec3 ro = vec3(10.0 * cos(angle) - iTime*2.0, 2.0*height, 10.0 * sin(angle));\n    vec3 at = vec3(0.0 - iTime*2.0,1.5,0.0);\n    \n    //ray direction\n    vec3 rd = normalize(getInvViewMatrix(ro,at) * vec4(uv,-1.5,1.0)).xyz;\n    \n    //Using a struct make the code cleaner and\n    //will also shorten many function \n    hitPayload p = hitPayload(\n        ro, //postion aka origin at first\n        ro,\n        rd,\n        vec3(0.0),\n        -1.0, \n        0,\n        0.0\n    );\n        \n    \n    //preform ray-marching\n    p = trace(p);\n    \n    //compute normal and get color\n    p.normal = calcNormal(p.orig + p.dist * p.dir);\n    material mat = getMaterial(p);\n    \n    //render the picture\n    vec3 color = render(p, mat);\n    \n    //perform color grading\n    color = pow(color,vec3(0.4545));\n    \n    total += color;\n    \n#if AA>1\n    }\n    total /= float(AA*AA);\n#endif\n\n    fragColor = vec4(total,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///// STRUCTURE /////\n\nstruct hitPayload\n{\n    vec3 orig;\n    vec3 hitPos;\n    vec3 dir;\n    vec3 normal;\n    float mat;\n    int nbStep;\n    float dist;\n};\n\nstruct material\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n    float IOR;\n};\n\n///// CONSTANTE /////\n\nconst float PI = atan(1.0)*4.0;\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n///// SDF FUNCION /////\n//https://iquilezles.org/articles/distfunctions/\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n\nvec3 opRepetition( in vec3 p, in vec3 s)\n{\n    return p - s*round(p/s);\n}\n\n\n///// SDF OPERATION /////\n// https://iquilezles.org/articles/distfunctions/\n\nfloat opUnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat opSubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nmat2 rot(in float a)\n{\n    a *= 0.0174533;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat getTorusAngle(float pourcentage)\n{\n    return PI*(pourcentage);\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n    \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;    \n}\n\n///// ANIMATION /////\n// Calculates the animated surface for a topological trick.\n// This function generates a complex animation by interpolating between manually defined keyframes.\n// pos: Position vector\n// time: Current time value\nfloat mapTopoTrickAnimation(vec3 pos, float time) {\n    // Define positions for three keyframes\n    vec3 posA = pos;\n    vec3 posB = pos;\n    vec3 posC = pos;\n\n    // Define animation duration and compute timing based on current time\n    float totalTime = 1.0;\n    float timing = (cos(time/totalTime) + 1.0) * (totalTime / 2.0);\n    float firstPhase = smoothstep(0.0, totalTime / 2.0, timing);\n    float secondPhase = smoothstep(totalTime / 2.0, totalTime, timing);\n\n    // Define variables for keyframes of phase 0\n    vec3 posA0 = vec3(-0.75, 1.5, 0.0);\n    float rotA0_0 = -90.0;\n    float rotA0_1 = 45.0;\n\n    vec3 posB0 = vec3(0.75, 1.5, 0.0);\n    float rotB0_0 = 90.0;\n    float rotB0_1 = 45.0;\n\n    vec3 posC0 = vec3(0.75, 1.5, 0.0);\n    float rotC0_0 = -90.0;\n    float rotC0_1 = -45.0;\n\n    float angleA0 = 1.0;\n    float angleB0 = 0.60;\n    float angleC0 = 0.3;\n\n    float blendB0 = 0.1;\n    float blendC0 = 0.5;\n\n    // Define variables for keyframes of phase 1\n    vec3 posA1 = vec3(-0.3, 1.5, 0.75);\n    float rotA1_0 = -90.0;\n    float rotA1_1 = 0.0;\n\n    vec3 posB1 = vec3(0.3, 1.5, 0.75);\n    float rotB1_0 = 90.0;\n    float rotB1_1 = 0.0;\n\n    vec3 posC1 = vec3(0.0, 1.5, 0.3);\n    float rotC1_0 = -90.0;\n    float rotC1_1 = -90.0;\n\n    float angleA1 = 0.50;\n    float angleB1 = 0.50;\n    float angleC1 = 0.60;\n\n    float blendB1 = 0.4;\n    float blendC1 = 0.4;\n\n    // Define variables for keyframes of phase 2\n    vec3 posA2 = vec3(0.0, 1.5, 1.75);\n    float rotA2_0 = -90.0;\n    float rotA2_1 = -90.0;\n\n    vec3 posB2 = vec3(0.0, 1.5, 1.75);\n    float rotB2_0 = 90.0;\n    float rotB2_1 = 90.0;\n\n    vec3 posC2 = vec3(0.0, 1.5, -0.3);\n    float rotC2_0 = -90.0;\n    float rotC2_1 = -90.0;\n\n    float angleA2 = 0.50;\n    float angleB2 = 0.50;\n    float angleC2 = 0.8;\n\n    float blendB2 = 0.00;\n    float blendC2 = 0.4;\n\n    // Define variables for torus animation\n    float torus = 0.0;\n\n    // Perform animation for between phase 0 and 1\n    if (firstPhase < 1.0) {\n        // Interpolate positions between keyframes\n        posA -= mix(posA0, posA1, firstPhase);\n        posA.xy *= rot(mix(rotA0_0, rotA1_0, firstPhase));\n        posA.zy *= rot(mix(rotA0_1, rotA1_1, firstPhase));\n\n        posB -= mix(posB0, posB1, firstPhase);\n        posB.xy *= rot(mix(rotB0_0, rotB1_0, firstPhase));\n        posB.zy *= rot(mix(rotB0_1, rotB1_1, firstPhase));\n\n        posC -= mix(posC0, posC1, firstPhase);\n        posC.xy *= rot(mix(rotC0_0, rotC1_0, firstPhase));\n        posC.zy *= rot(mix(rotC0_1, rotC1_1, firstPhase));\n\n        // Interpolate angles for torus animation\n        float angleA = getTorusAngle(mix(angleA0, angleA1, firstPhase));\n        float angleB = getTorusAngle(mix(angleB0, angleB1, firstPhase));\n        float angleC = getTorusAngle(mix(angleC0, angleC1, firstPhase));\n\n        // Compute torus distance functions\n        float torusA = sdCappedTorus(posA, vec2(sin(angleA), cos(angleA)), 1.0, 0.3);\n        float torusB = sdCappedTorus(posB, vec2(sin(angleB), cos(angleB)), 1.0, 0.3);\n        float torusC = sdCappedTorus(posC, vec2(sin(angleC), cos(angleC)), 1.0, 0.3);\n\n        // Combine torus shapes with blending\n        torus = opUnionRound(torusA, torusC, mix(blendC0, blendC1, firstPhase));\n        torus = opUnionRound(torus, torusB, mix(blendB0, blendB1, firstPhase));\n    }\n\n    // Perform animation for between phase 1 and 2\n    if (secondPhase > 0.0) {\n        // Interpolate positions between keyframes\n        posA -= mix(posA1, posA2, secondPhase);\n        posA.xy *= rot(mix(rotA1_0, rotA2_0, secondPhase));\n        posA.zy *= rot(mix(rotA1_1, rotA2_1, secondPhase));\n\n        posB -= mix(posB1, posB2, secondPhase);\n        posB.xy *= rot(mix(rotB1_0, rotB2_0, secondPhase));\n        posB.zy *= rot(mix(rotB1_1, rotB2_1, secondPhase));\n\n        posC -= mix(posC1, posC2, secondPhase);\n        posC.xy *= rot(mix(rotC1_0, rotC2_0, secondPhase));\n        posC.zy *= rot(mix(rotC1_1, rotC2_1, secondPhase));\n\n        // Interpolate angles for torus animation\n        float angleA = getTorusAngle(mix(angleA1, angleA2, secondPhase));\n        float angleB = getTorusAngle(mix(angleB1, angleB2, secondPhase));\n        float angleC = getTorusAngle(mix(angleC1, angleC2, secondPhase));\n\n        // Compute torus distance functions\n        float torusA = sdCappedTorus(posA, vec2(sin(angleA), cos(angleA)), 1.0, 0.3);\n        float torusB = sdCappedTorus(posB, vec2(sin(angleB), cos(angleB)), 1.0, 0.3);\n        float torusC = sdCappedTorus(posC, vec2(sin(angleC), cos(angleC)), 1.0, 0.3);\n\n        // Combine torus shapes with blending\n        torus = opUnionRound(torusA, torusC, mix(blendC1, blendC2, secondPhase));\n        torus = opUnionRound(torus, torusB, mix(blendB1, blendB2, secondPhase));\n    }\n\n    // Return final torus shape\n    return torus;\n}\n///// USEFULL FUNCTION /////\n\nfloat saturate(float x){\n    return max(0.0, min(x, 1.0));\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}","name":"Common","description":"","type":"common"}]}