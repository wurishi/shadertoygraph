{"ver":"0.1","info":{"id":"dlBSDd","date":"1676776430","viewed":93,"name":"Car driving around cube","username":"ianertson","description":"Look around with the mouse :)\nYou can enable night mode by changing the `NIGHT_MODE` constant :D","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","materials","textures","lights","car"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set to `1` to enable night mode (must disable `DAYTIME_SIM` in that case)\n#define NIGHT_MODE 0\n\n// set to `1` to enable automatic daytime-nighttime simulation\n#define DAYTIME_SIM 0\n\n#if DAYTIME_SIM\n#define DAYTIME (0.5+(0.5*(cos((T*0.06)-M_PI))))\n#endif\n\n// set to `1` to have the camera always follow the car\n#define FOLLOW_CAR 0\n\n#define DEBUG 0\n\n#define NEAR 0.003\n#define FAR 80.0\n#define STEPS 96\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_CAR 3\n#define ID_CAR_PIPE 4\n#define ID_CAR_WHEEL 5\n#define ID_CAR_WHEEL_RIM 6\n#define ID_CAR_WINDOW 7\n#define ID_CAR_LIGHT 8\n\n#define CAR_COLOR rgb(211, 40, 5)\n\n#define NIGHT_COLOR rgb(50,101,142)\n#define NIGHT_STRENGTH 0.5\n#define DAY_COLOR vec3(0.97, 0.89, 0.79)\n#define DAY_STRENGTH 1.0\n\n\n#if DAYTIME_SIM\n\n#define LIGHT_COLOR mix(DAY_COLOR, NIGHT_COLOR, DAYTIME)\n#define LIGHT_STRENGTH mix(DAY_STRENGTH, NIGHT_STRENGTH, DAYTIME)\n\n#else\n#if NIGHT_MODE\n#define LIGHT_COLOR NIGHT_COLOR\n#define LIGHT_STRENGTH (NIGHT_STRENGTH)\n#else\n#define LIGHT_COLOR DAY_COLOR\n#define LIGHT_STRENGTH (DAY_STRENGTH)\n#endif\n#endif\n\n#define NUM_LIGHTS 3\n\n#define MOVEMENT 1\n\nfloat noise21(vec2 p, float seed) {return textureLod(iChannel2, p + (vec2(seed, seed)/256.), 0.0).r;}\nfloat pebble(vec2 p) { return textureLod(iChannel0, p / 512.0, 0.0).r; }\nfloat noise21(vec2 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    float n = 0.0;\n    #define ADV n += amp * noise21(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV;ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise23(vec2 p, float seed) {p += seed;return textureLod(iChannel3, p, 0.0).rgb;}\n\nvec3 noise23(vec2 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise21(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV;ADV;ADV;\n    #undef ADV\n    return n / div;\n}\n\n\nCar getCar() {\n    float a = T*0.5;\n    float mt = T*0.5;\n    \n    #if (MOVEMENT && !DEBUG)\n    vec3 velocity = vec3(cos(a), 0, sin(a)) * (1.0 + 0.2*(0.5+(0.5*cos(mt+1.20315+sin(mt-0.59231)))));\n    \n    vec4 roter = quatFor(normalize(velocity), vec3(0, 0, 1));\n    \n    float wt = T+sin((T*0.5+cos((T*0.1)+0.0931))-2.31999);\n    vec3 wobble = vec3(sin(wt*3.), cos(wt*3.), cos(wt*3.));\n    vec4 wq = quatFor(normalize(wobble), vec3(0, 1, 0));\n    \n    velocity.y += (0.007*(0.5+(0.5*(cos(wt*20.))))) * (0.0001+(0.5+(0.5*(sin(T*0.4)))));\n   \n    roter = mix(roter, roter*wq, 0.1*(0.5+(0.5*cos(T))));\n    roter = normalize(roter);\n    mat4 m = quaternionToMatrix(roter);\n\n\n    float len = TAU;\n    vec3 pos = velocity*len;\n    #else\n    vec4 roter = vec4(0.0);\n    mat4 m = mat4(1.0);\n    vec3 pos = vec3(0.0);\n    vec3 velocity = vec3(0.0);\n    #endif\n    \n    #if DEBUG\n    pos = vec3(0, 4, 0);\n    #endif\n    \n    return Car(pos, velocity, roter, m);\n}\n\n\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float t) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba)-t;\n}\n\nfloat groundSDF(vec3 p) {\n    return p.y;\n}\n\nfloat carSDF(vec3 p, vec3 trans, vec4 roter, inout int id) {\n    id = ID_CAR;\n    \n\n    vec3 size = vec3(2.0, 0.5, 1.0);\n    \n   \n    mat4 m = quaternionToMatrix(roter);\n    \n    p -= trans;\n    p = (vec4(p, 1.0) * m).xyz;\n    \n \n    \n    p.y += 0.2;\n //   p.xz *= rot(T*0.5);\n    \n    vec3 pos = vec3(0.0, size.y + 0.5, 0.0);\n    vec3 slope = vec3(0, float(p.y > pos.y)*0.5*cos(p.x*0.9)*max(0.0, 1.0-pow(abs(p.x), 2.0)*0.3), 0);\n    float body = boxSDF(\n        p - \n        pos -\n        slope -\n        vec3(0, float(p.y > pos.y)*0.3*-smoothstep(size.x-0.6, size.x, max(0.0, (abs(p.x)-max(0.0, p.x*0.23))*1.6)), 0),\n        \n        size\n    )-(0.02*abs(p.x));\n    \n    float bodyInside = (boxSDF(\n        p - \n        pos -\n        vec3(0, -0.16, 0) -\n        slope -\n        vec3(0, float(p.y > pos.y)*0.3*-smoothstep(size.x-0.6, size.x, max(0.0, (abs(p.x)-max(0.0, p.x*0.23))*1.6)), 0),\n        \n        (size*0.8)\n    )-(0.02*abs(p.x)));\n    \n    body = max(body, -(bodyInside));\n    \n    \n    \n    float wheelHoleR = 0.53;\n    vec3 wheelHolePos = vec3(abs(-size.x*0.53), pos.y-(wheelHoleR*1.1), abs(-0.6));\n    float wheelHole = sphereSDF(vec3(abs(p.x)*0.8, p.y*0.8, abs(p.z)) - wheelHolePos, wheelHoleR);\n    \n    body = max(body, -wheelHole);\n    \n    vec3 wheelPos =  vec3(0.3, 0.1, 0.3);\n    float wheel = torusSDF((vec3(abs(p.x), p.y, abs(p.z)) - wheelHolePos) - wheelPos, vec2(wheelHoleR/2., 0.1));\n    float wheelInside = sphereSDF((vec3(abs(p.x), p.y, abs(p.z)) - wheelHolePos  - wheelPos) - vec3(0, 0, -0.2), wheelHoleR*0.6);\n    \n    \n    float pipeR = 0.1;\n    float pipe = cylinderSDF(p - pos - vec3(size.x, -(size.y-(pipeR*0.5)), size.z-(pipeR*M_PI)), vec3(0.0), vec3(0.2, 0.0, 0), pipeR);\n    float pipeRInside = pipeR*0.8;\n    float pipeInside = cylinderSDF(p - pos - vec3(size.x+0.1, -(size.y-(pipeR*0.5)), size.z-((pipeR*M_PI))), vec3(0.0), vec3(0.2, 0.0, 0), pipeRInside);\n    \n    pipe = max(pipe, -pipeInside);\n    \n    vec3 winSize = vec3(size.x/5.0, (size.y/2.)-(((abs(p.x)*0.2)*max(0.0, 1.0-(cos(p.x*1.9)))) * float(p.y > size.y*3.)), 0.5);\n    float window = boxSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(winSize.x+0.09, (size.y*3.)-0.01, size.z-0.01), winSize);\n    \n    vec3 backP = p;\n    vec3 winSize2 = vec3(0.4, size.y/2., size.z/3.0);\n    vec3 offset = vec3(((size.x/2.)+0.3), (size.y*3.)+0.02, winSize2.z+0.09);\n    float a = 40.0;\n    backP.xy *= rot(radians(a));\n    offset.xy *= rot(radians(a));\n    float winBack = boxSDF(vec3(backP.x, backP.y, abs(backP.z)) - \n        offset, winSize2);\n        \n    vec3 frontP = p;\n    vec3 winSize3 = vec3(0.5, size.y/2., size.z/3.0);\n    vec3 frontOffset = vec3(-((size.x/2.)+0.12), (size.y*3.)+0.02, winSize3.z+0.09);\n    float aF = -40.0;\n    frontP.xy *= rot(radians(aF));\n    frontOffset.xy *= rot(radians(aF));\n    float winFront = boxSDF(vec3(frontP.x, frontP.y, abs(frontP.z)) - \n        frontOffset, winSize3);\n    //winBack += p.x*0.16*max(0.0, p.y);\n    \n    float headLight = boxSDF(vec3(p.x, p.y, abs(p.z)) - \n        pos - vec3(-(size.x-0.07), 0, size.z/2.), vec3(0.2, 0.1, 0.2));\n   // body = min(body, winFront);\n    body = max(body, -(winFront-0.01));\n    body = max(body, -(winBack-0.06));\n    body = max(body, (-(window-0.06)));\n    \n    float bFloor = boxSDF(p - pos - vec3(0.0, -size.y*0.16, 0.0), vec3(size.x, 0.05, size.z));\n    \n    body = min(body, bFloor);\n   \n    float dist = body;\n    \n    if (pipe < dist) { id = ID_CAR_PIPE; dist = pipe; }\n    if (wheel < dist) { id = ID_CAR_WHEEL; dist = wheel; }\n    if (headLight < dist) { id = ID_CAR_LIGHT; dist = headLight; }\n    \n    if (wheelInside < dist) { id = ID_CAR_WHEEL_RIM; dist = wheelInside; }\n    \n  //  if (winFront <= 0.02 || winBack <= 0.07 || window < 0.06) { id = ID_CAR_WINDOW; }\n    \n    return dist/2.2;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    float box = boxSDF(p - vec3(0, 1.0, 0), vec3(1.0));\n    int carPart = ID_CAR;\n    Car carObj = getCar();\n    float car = carSDF(p, carObj.pos, carObj.roter, carPart);\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(box, ID_BOX);\n    SAMPLE(car, carPart);\n    \n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data, vec3 p) {\n    vec3 n = data.n;\n    vec2 uv = vec2(0.0);\n    \n    if (data.id == ID_CAR || data.id == ID_CAR_PIPE || data.id == ID_CAR_WHEEL\n        || data.id == ID_CAR_WHEEL_RIM || data.id == ID_CAR_LIGHT) {\n        Car car = getCar();\n        \n        vec3 cpos = car.pos;\n     //   cpos = (vec4(cpos, 1.0) * car.m).xyz;\n        \n        p -= cpos;\n        \n        p = (vec4(p, 1.0) * (car.m)).xyz;\n        n = (vec4(n, 1.0) * (car.m)).xyz;\n    }\n    \n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    return uv;\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = dist;\n    data.n = getNormal(data, p);\n    data.uv = getUv(data, p);\n    \n    return true;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float near, float far) {\n    float dist = 0.0;\n    Data data = NEW_DATA;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= min(NEAR, near)) break;\n        if (abs(dist) >= min(far, FAR)) return 1.0;\n    }\n    return min(0.5, dist / max(0.1, 0.5+near));\n}\n\n\nvec3 stoneTexture(vec2 uv, inout Material m) {\n    vec3 col = vec3(0.0);\n    uv *= 16.0;\n    \n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    float r = noise21(uv, 8.82399, 0.06);\n    float g = max(0.0, 1.0 - ceil(min(lv.x, lv.y) - (0.06+((r*2.0-1.0)*0.09))));\n    \n    vec3 c1 = rgb(152, 87, 60);\n    vec3 c2 = rgb(156, 95, 73);\n    vec3 c3 = rgb(96, 56, 45);\n    vec3 c4 = rgb(185, 179, 165);\n    \n    vec3 alt = textureLod(iChannel3, (id/256.)*4., 0.0).rgb;\n    \n    \n    col = mix(col, c1*c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3*c3, alt.z);\n    col = mix(col, c4, r*(0.1+g*r));\n    \n    m.rough = (alt.x+alt.y+alt.z)/3.0;\n    m.spec = max(0.0, 1.0 - m.rough);\n    m.spec *= luma(col)*2.;\n \n    \n    return col;\n}\n\nvec3 metalTexture(vec2 uv, inout Material m) {\n    vec3 col = vec3(0.0);\n    float region = noise21(uv*2., 21.9311, 0.02);\n    region = max(0.0, 1.0-smoothstep(0.33, 0.46, region));\n    float invRegion = noise21(uv*1.9, 11.66381, 0.02);\n    invRegion = abs(invRegion - region);\n    float outlines = smoothstep(0.4, invRegion, 0.7);\n    vec3 c1 = rgb(190, 189, 187);\n    vec3 c2 = rgb(109, 110, 112);\n    vec3 c3 = rgb(55, 64, 68);\n    vec3 c4 = rgb(83, 31, 32);\n    col = mix(col, c4, outlines);\n    vec3 alt = noise23(uv, 3.92156, 0.16 * (0.5+region*0.5));\n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    float amp = (region + alt.x + alt.y + alt.z) / 4.0;\n    col *= (0.5+(amp*0.5));\n    float crust = noise21(uv * (0.5+(region*0.5)), 8.363 * region);\n    col *= (0.5+(crust*0.5)); \n    col += (max(0.0, 1.0-outlines)*crust*region*length(alt))/TAU;\n    \n    m.rough = max(0.77, (alt.x+alt.y+alt.z+crust+invRegion+region)/4.);\n    return col;\n}\n\n\n\nvec3 brushedMetalTexture(vec2 uv, inout Material m) {\n    vec3 col = vec3(0.0);\n    float region = noise21(uv*2., 7.77311, 0.02);\n    vec3 c1 = rgb(192, 191, 196);\n    vec3 c2 = rgb(161, 161, 161);\n    vec3 c3 = rgb(227, 218, 209);\n    vec3 c4 = rgb(150, 153, 146);\n    vec3 alt = noise23(uv + cos((uv.x*(16.0)+uv.y)), 1.1002156, 0.16);\n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    col = mix(col, c4*c4*c4, region);\n    \n    m.rough = alt.x*region;\n    return col;\n}\n\n\nvec3 roadTexture(vec2 uv, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    float region = noise21(uv, 4.149971999, 0.025);\n    region = clamp(1.0-smoothstep(0.6, 0.4, region), 0.0, 1.0);\n\n    vec3 c1 = rgb(201, 142, 86);\n    vec3 c2 = rgb(78, 72, 41);\n    vec3 c3 = rgb(105, 66, 37);\n    vec3 c4 = rgb(22, 11, 7);\n    \n    vec3 alt = vec3(\n        noise21(uv, 3.92815, 0.03),\n        noise21(uv, 7.33333, 0.09),\n        noise21(uv, 18.11366, 1.0)\n    );\n    \n    float grains = textureLod(iChannel2, uv, 0.0).r;\n    grains = clamp(pow(grains, 10.0)*2., 0.0, 1.0);\n    \n    col = mix(col, c1*c1, alt.x);\n    col = mix(col, c2*c2, alt.y);\n    col = mix(col, c3, alt.z);\n    col = mix(col, c4, region*0.6);\n    col = mix(col, c1, grains);\n    \n    float peb = pebble(uv*256.);\n    \n    col += peb*c3;\n    \n    \n    float amp = (alt.x + alt.y + alt.z + region) / 3.0;\n    col *= amp;\n    col = clamp(col, 0.0, 1.0);\n    \n     float puddles = (pebble(uv*8.) + noise21(uv*(0.7+((region+alt.x*alt.z)*0.02)), 6.93118754, 0.001))/1.6;\n     puddles = pow(puddles, 3.0)*1.6;\n    \n    m.spec = clamp((puddles+amp)/2., 0.0, 1.0);\n    m.rough = clamp(max(0.0, 1.0 -puddles)+((alt.x*alt.z)*0.5), 0.6, 1.0);\n    \n    return col;\n}\n\nvec3 grassTexture(vec2 uv, out float region, out float jitter, inout Material m) {\n    vec3 col = vec3(0.0);\n    region = noise21(uv, 34.291, 0.0002);\n    region = clamp(pow(region, 4.0)*4., 0.0, 1.0);\n    vec3 alt = noise23(uv + (region*0.5), 9.2391, 0.1);\n    vec3 c1 = rgb(58, 71, 27);\n    vec3 c2 = rgb(80, 79, 32);\n    vec3 c3 = rgb(146, 153, 92);\n    vec3 c4 = rgb(130, 178, 76);\n    vec3 c5 = rgb(191, 172, 71);\n    \n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    col = mix(col, c4, 0.1*region*length(alt));\n    \n    jitter = noise21(uv, 4.4321, 0.09);\n    \n    col = mix(col, c5*c5, jitter*jitter);\n    \n    col *= (0.33+(jitter*jitter));\n    \n    float amp = (region+length(alt)+jitter)/3.;\n    col *= amp;\n    \n    float vary = noise21(uv*0.5, 33.982815, 0.009)*M_PI;\n\n    float area = M_PI + vary;\n    float len = length(uv);\n    float j =  smoothstep(M_PI-(vary*0.5), TAU+area, len);\n    float j2 = smoothstep(TAU+area+(0.5*vary), M_PI+(vary*0.5), len);\n\n    j = clamp(j2*j*6., 0.0, 1.0);\n\n    Material roadMat = NEW_MATERIAL;\n    col = mix(col, roadTexture(uv, roadMat), j);\n    m.rough = mix(m.rough, roadMat.rough, j);\n    m.spec = mix(m.spec, roadMat.spec, j);\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    col += stoneTexture(uv*0.25, data.m);\n    \n    \n     float e = 0.05;\n    \n    vec3 n = normalize(luma(col) - vec3(\n        luma(stoneTexture(uv + vec2(e, 0), data.m)),\n        luma(stoneTexture(uv + vec2(0, e), data.m)),\n        0.05+luma(stoneTexture(uv + vec2(e, e), data.m))\n    ));\n    \n\n    \n    float d = dot(n, data.n);\n    vec3 t = cross(data.n, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(data.n, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(data.n, t));\n    mat3 tbn = mat3(t, b, -data.n);\n    n = normalize((tbn)*n);\n    data.n = normalize(mix(data.n, n, 0.33*max(0.0, dot(data.n, n))));\n\n\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.p.xz;\n    \n    float region = 0.0;\n    float jitter = 0.0;\n    col += grassTexture(uv, region, jitter, data.m);\n    \n    data.m.spec = luma(col)*region*jitter;\n    data.m.rough = 1.;\n    \n    \n   float e = 0.05;\n    \n    vec3 n = normalize(luma(col) - vec3(\n        luma(grassTexture(uv + vec2(e, 0), region, jitter, data.m)),\n        luma(grassTexture(uv + vec2(0, e), region, jitter, data.m)),\n        0.05+luma(grassTexture(uv + vec2(e, e), region, jitter, data.m))\n    ));\n    \n    float d = dot(n, data.n);\n    vec3 t = cross(data.n, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(data.n, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(data.n, t));\n    mat3 tbn = mat3(t, b, -data.n);\n    n = normalize((tbn)*n);\n    data.n = normalize(mix(data.n, n, 0.33*max(0.0, dot(data.n, n))));\n    \n    return col;\n    \n}\n\nvec3 getAlbedoCarWheel(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    return col;\n}\n\nvec3 getAlbedoCarWheelRim(inout Data data) {\n    vec3 col = vec3(0.0, 0.0, 0);\n    vec2 uv = data.uv;\n    \n    col += brushedMetalTexture(uv, data.m);\n    \n    return col;\n}\n\nvec3 getAlbedoCarPipe(inout Data data) {\n    vec3 col = vec3(0.0, 0, 0);\n    vec2 uv = data.uv;\n    \n    col += brushedMetalTexture(uv, data.m);\n    \n    return col;\n}\n\nvec3 getAlbedoCarBody(inout Data data) {\n    vec3 col = vec3(0, 0, 0);\n    Car car = getCar();\n    vec3 p = data.p - car.pos;\n    vec2 uv = data.uv;\n    \n    col += metalTexture(uv, data.m);\n    \n    float stripeHeight = 0.44;\n    float stripeY = 0.44;\n    \n    p = (vec4(p, 1.0) * car.m).xyz;\n    float py = max(0.0, p.y);\n    float px = max(0.0, p.x);\n    py += (0.05*cos(p.x*24.)*px);\n    float stripe = max(0.0, 1.0 - (smoothstep(stripeY, (py) - stripeHeight, py) + (1.0-smoothstep(stripeY, (py+0.2) - stripeHeight, py))));\n    stripe *= max(0.0, 1.0 - ((data.m.rough*data.m.rough)*0.8));\n  //  if (stripe > 0.0) {\n        vec3 sn = data.n;\n        sn = (vec4(sn, 1.0) * car.m).xyz;\n        if (abs(sn.z) >= 0.8) {\n            col = mix(col, mix(vec3(1.0, 0, 0), vec3(0, 1, 0), clamp((1.0/(0.2+(px*6.))), 0.0, 1.0)), stripe*stripe*3.);\n            data.m.spec = max(data.m.spec, stripe);\n        }\n   // }\n    \n    \n    col *= mix(CAR_COLOR, vec3(0.88), 0.3);\n    \n       float e = 0.05;\n    Material tmp = NEW_MATERIAL;\n    vec3 n = normalize(luma(col) - vec3(\n        luma(metalTexture(uv + vec2(e, 0), tmp)),\n        luma(metalTexture(uv + vec2(0, e), tmp)),\n        0.05+luma(metalTexture(uv + vec2(e, e), tmp))\n    ));\n    \n    float d = dot(n, data.n);\n    vec3 t = cross(data.n, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(data.n, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(data.n, t));\n    mat3 tbn = mat3(t, b, -data.n);\n    n = normalize((tbn)*n);\n    data.n = normalize(mix(data.n, n, 0.09*max(0.0, dot(data.n, n))));\n    \n    return col;\n}\n\nvec3 getAlbedoCarLight(inout Data data) {\n    vec3 col = vec3(0, 0, 0);\n    vec2 uv = data.uv;\n    \n    col += noise21(uv, 3.39281, 0.5) * vec3(0.97, 0.79, 0.39);\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_CAR_WHEEL: return getAlbedoCarWheel(data); break;\n        case ID_CAR_WHEEL_RIM: return getAlbedoCarWheelRim(data); break;\n        case ID_CAR_PIPE: return getAlbedoCarPipe(data); break;\n        case ID_CAR: return getAlbedoCarBody(data); break;\n        case ID_CAR_LIGHT: return getAlbedoCarLight(data); break; \n    }\n    \n    return vec3(0.48);\n}\n\nvec3 getSkyDay(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.22, 0.66, 0.9);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    vec2 uv = rd.xz/rd.y;\n    \n    uv += vec2(-T + sin(T), T + cos(T))*0.1;\n    \n    vec2 regionShift = vec2(sin(T*0.1), cos(T*0.1));\n    \n    float region = noise21((uv+regionShift)*0.25, 1.234, 0.001);\n    region = pow(region, 4.0)*3.;\n    \n    float t = (T*(0.5+(region*0.004)))*0.5;\n    \n    vec2 shift = vec2(cos(t), sin(t))*(0.5+region);\n    \n    float clouds = noise21(uv + shift, 6.357, 0.008) * (0.6+region*0.4);\n    \n    shift += vec2(cos(clouds*TAU), sin(clouds*TAU)) * 0.25;\n    \n    float highLayer = noise21(uv - (shift*0.5), 11.93215, 0.02)*(0.5+(region*0.5));\n    clouds = max(clouds, highLayer);\n    \n    clouds *= clamp(dotup*FAR, 0.0, 1.0);\n    clouds *= (0.5+(0.5*length(shift)));\n    \n    clouds = pow(clouds, 3.0)*3.;\n    \n    clouds = clamp(clouds, 0.0, 1.0);\n    \n    col = mix(col, vec3(1.), clamp(clouds*3., 0.0, 1.0));\n    \n    return col;\n}\n\nvec3 getSkyNight(in vec3 ro, in vec3 rd, in Light light) {\n    vec3 L = normalize(light.p);\n    float VdotL = max(0.0, dot(rd, L));\n    vec3 col = vec3(0.0);\n    float stars = texture(iChannel1, rd*16.).r;\n    float t = T*0.02;\n    float stars2 = texture(iChannel1, ((rd+(0.5*vec3(cos(t), sin(t), sin(t+3.9871))))+vec3(-1.291, 1.972, 3.331))*4.).r;\n    stars *= (0.16+stars2);\n    stars = pow(stars, 16.0);\n    col += stars;\n    float r = 0.1;\n    float f = r*0.02;\n\n    vec3 lp = light.p;\n    \n    vec2 uv = vec2(0.0);\n    uv.y = acos(rd.y);\n    uv.x = atan(rd.x, rd.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    \n    vec2 cv = vec2(0.0);\n    cv.y = acos(L.y);\n    cv.x = atan(L.x, L.z);\n    cv = cv * 2.0 - 1.0;\n    cv.x = 0.5 + cv.x / (M_PI);\n    cv.y = 0.5 - cv.y / M_PI;\n   \n  \n    float a = 1.0 - smoothstep(r-f, r+f, distance(uv, cv));  \n    float b = 1.0 - smoothstep(r-f, r+f, distance(uv + vec2(-0.05, 0.0), cv));\n    \n    float circle = max(0.0, a-b);\n    float pattern = texture(iChannel3, uv*2.).r;\n    vec3 moonTex = vec3(1.0);\n    return col + circle*light.c*light.s*moonTex;\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n    #if DAYTIME_SIM\n    \n    vec3 night = getSkyNight(ro, rd, light);\n    vec3 day = getSkyDay(ro, rd);\n    \n    return mix(day, night, DAYTIME);\n    \n    #else\n    #if NIGHT_MODE\n    return getSkyNight(ro, rd, light);\n    #else\n    return getSkyDay(ro, rd);\n    #endif\n    #endif\n}\n\nvec3 forEachLight(inout Data data, in Light light, vec3 ro, vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    vec3 att = getLightAtt(light, p, n);\n    \n    float distLight = distance(light.p, data.p);\n    float shadow = getShadow(data.p+(data.n*NEAR*3.), L, data.d, light.t == LIGHT_AMBIENT ? FAR : distLight);\n    \n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 lightEffect(inout Data data, in Light light, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n   // if (light.t == LIGHT_DIRE) return col;\n    float fa = light.t == LIGHT_AMBIENT ? 5.0 : 3.3;\n    float fb = light.t == LIGHT_AMBIENT ? 7.2 : 8.2;\n    \n    float k = max(0.0, 1.0 - smoothstep(fa, fb, data.d));\n    vec3 L = light.t == LIGHT_DIRE ? normalize(light.p - ro) : getLightDir(light, ro);\n    \n    float VdotL = cdot(rd, L);\n    \n    float f = 1.0;\n    \n    \n    if (light.t == LIGHT_DIRE) {\n        k += distance(ro, light.p) / data.d;\n        vec3 Ldir = light.d;\n        f *= max(0.07, cdot(L, normalize(Ldir + (L/2.))));\n        \n        f *= (1.0 / TAU) * 0.25;\n    }\n    \n    #if DAYTIME_SIM\n    float ambPwr = mix(4.0, 32.0, DAYTIME);\n    #else\n    #if NIGHT_MODE\n    float ambPwr = 32.0;\n    #else\n    float ambPwr = 4.0;\n    #endif\n    #endif\n    float pwr = (light.t == LIGHT_POINT || light.t == LIGHT_DIRE) ? 256.0 : ambPwr;\n    col += light.c * light.s * pow(VdotL, pwr) * max(0.0, 1.0 - k) * f;\n    \n    return col;\n}\n\nvec3 render(inout Data data, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    \n    Car car = getCar();\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), LIGHT_COLOR, vec3(0.0), LIGHT_STRENGTH, LIGHT_AMBIENT);\n    \n    \n    vec3 cpos = car.pos;\n    cpos = (vec4(cpos, 1.0) * car.m).xyz;\n    vec3 ldir = vec3(1., 0.5, 0);\n    ldir = (vec4(ldir, 1.0) * inverse(car.m)).xyz;\n    \n    float wx = 2.5;\n    float ws = 5.0;\n    vec3 hc = vec3(0.97, 0.77, 0.49);\n    \n    // left headlight\n    vec3 lpos = cpos - vec3(wx, -0.7, 0.5);\n    lpos = (vec4(lpos, 1.0) * inverse(car.m)).xyz;\n    lights[1] = Light(lpos, hc, ldir, ws, LIGHT_DIRE);  \n\n\n    // right headlight\n    lpos = cpos - vec3(wx, -0.7, -0.5);\n    lpos = (vec4(lpos, 1.0) * inverse(car.m)).xyz;\n    lights[2] = Light(lpos, hc, ldir, ws, LIGHT_DIRE);\n    \n    \n    float dotup = cdot(rd, vec3(0, 1, 0));\n    float primDist = FAR;\n    float rough = 0.0;\n    \n    for (int j = ZERO; j < 2; j++) {\n        vec3 mixF = vec3(1.0) * max(0.0, 1.0 - rough);\n        if (j > 0) {\n            vec3 f0 = vec3(0.04);\n            float NdotV = abs(dot(data.n, rd));\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough);\n            vec3 E = EnvBRDFApprox(vec3(0.2), rough*rough, NdotV);\n            mixF *= (F * E.x + E.y);\n        }\n        if (march(data, ro, rd)) {\n            if (j <= 0) {\n                primDist = data.d;\n            }\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                \n                col += forEachLight(data, light, ro, rd) * mixF;\n                col += lightEffect(data, light, ro, rd) * mixF;\n            }\n            \n            ro = data.p+(data.n*NEAR*2.2);\n            rd = reflect(rd, data.n);\n            //data.skip = data.id;\n            rough = data.m.rough;\n            if (rough >= 1.0) break;\n        } else {\n            col += getSky(ro, rd, lights[0]) * mixF;\n\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += lightEffect(data, light, ro, rd) * mixF;\n            }\n            break;\n        }\n    }\n    \n    float depth = primDist / FAR;\n    \n    #if DAYTIME_SIM\n        float fogFactor = max(0.0, 1.0 - clamp(dotup*2., 0.0, 1.0));\n        vec3 nightColor = col + (depth * max(0.0, smoothstep(0.4, -1., dotup))) / M_PI;\n        vec3 dayColor = col + smoothstep(0.09, 1.0, depth) * fogFactor;\n        \n        col = mix(dayColor, nightColor, DAYTIME);\n    #else\n    \n    #if NIGHT_MODE\n    float fogFactor = max(0.0, 1.0 - clamp(dotup*2., 0.0, 1.0));\n\n    col += (depth * max(0.0, smoothstep(0.4, -1., dotup))) / M_PI;\n    #else\n    float fogFactor = max(0.0, 1.0 - clamp(dotup*2., 0.0, 1.0));\n    \n    col += smoothstep(0.09, 1.0, depth) * fogFactor;\n    #endif\n    #endif\n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec2 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 1.1, -3.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    Car car = getCar();\n    \n    if (iMouse.z > 0.01) {\n        ro.z -= 3.0;\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    \n    #if DEBUG\n        ro = car.pos;\n        vec3 offset = vec3(0.0, 0, 6.0);\n        offset = (vec4(offset, 1.0) * inverse(car.m)).xyz;\n        ro -= offset;\n        rd = look(uv, car.pos, ro);\n        \n        if (iMouse.z > 0.01) {\n            ro.z -= 3.0;\n            ro.yz *= rot(m.y*TAU);\n            ro.xz *= rot(m.x*TAU);\n\n            rd.yz *= rot(m.y*TAU);\n            rd.xz *= rot(m.x*TAU);\n        }\n    #else\n\n    #if MOVEMENT\n    else {\n        vec3 ogRo = ro;\n        vec3 ogRd = rd;\n        ro.y += 6.0;\n        ro.z -= 5.;\n        \n        float d = distance(ro, car.pos);\n        \n        ro.z -= (TAU*smoothstep(19.0, 0.0, d))*2.;       \n        ro.z -= (TAU*smoothstep(19.0, 0.0, distance(ro, vec3(0.0))));\n        rd = look(uv, car.pos, ro);\n        \n        \n        {\n            vec3 followRo = ogRo;\n            vec3 followRd = ogRd;\n            followRo.xz = car.pos.xz;\n            followRo.y = M_PI;\n            \n            vec3 offset = vec3(-7.0, 0, 0.0);\n            offset = (vec4(offset, 1.0) * inverse(car.m)).xyz;\n            \n            followRo -= offset;\n            \n            #if FOLLOW_CAR\n            float mf = 1.0;\n            #else\n            float mf = clamp((0.5+(0.5*cos(T*0.5))), 0.0, 1.0);\n            #endif\n            vec3 dd = normalize(car.pos - ro);\n            float ra = atan(dd.y, dd.x);\n            followRd = normalize(vec3(uv.xy, 1.0));\n            \n            \n            ro = mix(ro, followRo, mf);\n            followRd = look(uv, car.pos, ro);\n            rd = normalize(mix(rd, followRd, mf));\n\n        }\n        \n    }\n    #endif\n    #endif\n    \n    ro.y = max(1., ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    \n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    col += DEBUG_TEXTURE(fc.xy/R.xy);\n    #else\n    col += render(data, ro, rd);\n    #endif\n    \n    col += (col*luma(col))/1.2;\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0/2.2));\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T ((iFrame <= 1 || iTime <= 0.00001) ? 28.27 : iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != data.skip && var < dist) { data.id = id_; dist = var; }\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114));}\n\n\nstruct Car {\n    vec3 pos;\n    vec3 vel;\n    vec4 roter;\n    mat4 m;\n};\n\nstruct Material {\n    float rough;\n    float spec;\n};\n\n#define NEW_MATERIAL Material(0.9, 1.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    vec3 d;\n    float s;\n    int t;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRE 2\n\nvec3 getLightDir(in Light light, vec3 p) {\n    if (light.t == LIGHT_AMBIENT) return normalize(light.p);\n    if (light.t == LIGHT_DIRE) return normalize(light.d);\n    return normalize(light.p - p);\n}\n\nvec3 getLightAtt(in Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    if (light.t == LIGHT_AMBIENT) return light.c * light.s * NdotL;\n    \n    if (light.t == LIGHT_DIRE) {\n        vec3 ld = L;\n        vec3 sd = normalize(light.p - p);\n        float cone = dot(sd, ld);\n        const float cutoff = 0.8;\n        return light.c * NdotL * smoothstep(cutoff, 1.0, cone);\n    }\n    \n    return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p) ,2.0)));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n  vec3 lookAt = point;\n  float zoom = 1.;\n  vec3 camForward = normalize(lookAt - ro);\n  vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n  vec3 camUp = -cross(camRight, camForward);\n  vec3 screenCenter = ro + camForward * zoom;\n  vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n  return normalize(screenIntersection - ro);\n}\n\nmat4 quaternionToMatrix(vec4 q)\n{\n    float xx = q.x * q.x;\n    float xy = q.x * q.y;\n    float xz = q.x * q.z;\n    float xw = q.x * q.w;\n\n    float yy = q.y * q.y;\n    float yz = q.y * q.z;\n    float yw = q.y * q.w;\n\n    float zz = q.z * q.z;\n    float zw = q.z * q.w;\n\n    mat4 result;\n    result[0][0] = 1.0 - 2.0 * (yy + zz);\n    result[1][0] = 2.0 * (xy - zw);\n    result[2][0] = 2.0 * (xz + yw);\n    result[3][0] = 0.0;\n\n    result[0][1] = 2.0 * (xy + zw);\n    result[1][1] = 1.0 - 2.0 * (xx + zz);\n    result[2][1] = 2.0 * (yz - xw);\n    result[3][1] = 0.0;\n\n    result[0][2] = 2.0 * (xz - yw);\n    result[1][2] = 2.0 * (yz + xw);\n    result[2][2] = 1.0 - 2.0 * (xx + yy);\n    result[3][2] = 0.0;\n\n    result[0][3] = 0.0;\n    result[1][3] = 0.0;\n    result[2][3] = 0.0;\n    result[3][3] = 1.0;\n\n    return result;\n}\n\nvec4 quatFor(vec3 dir, vec3 up)\n{\n    vec3 axis = normalize(cross(up, dir));\n    float angle = acos(dot(dir, up));\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n    vec4 q = vec4(axis * s, cos(halfAngle));\n    return normalize(q);\n}\n\nvec2 sphereUv(vec3 p) {\n    vec2 uv = vec2(0.0);\n    uv.y = acos(p.y);\n    uv.x = atan(p.x, p.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    return uv;\n}","name":"Common","description":"","type":"common"}]}