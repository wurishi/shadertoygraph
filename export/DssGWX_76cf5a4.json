{"ver":"0.1","info":{"id":"DssGWX","date":"1666886208","viewed":119,"name":"Oroan","username":"Gijlf","description":"invocation circle\n\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535898;\nconst float tau = pi * 2.0;\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 moda( vec2 p, float m, float r ) {\n    p = vec2( (atan(p.y, p.x) + pi) / tau, length(p));\n    p.x += r;\n    p.x = ( fract( p.x * m ) - 0.5 ) * (pi / (m * 0.5));\n    return p.y * vec2(cos(p.x), sin(p.x));\n}\n\nfloat vesica(vec2 p, float r, float d) {\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n        : length(p-vec2(-d,0.0))-r;\n}\n\nfloat hexagon(vec2 p, float r) {\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat h11(float x) {\n    x += 293.943;\n    return fract(fract(x * 464.934) * 245.93);\n}\n\n#define glyph_segment 6\nfloat glyph(vec2 p, float seed) {\n    vec2 o = vec2(0);\n    vec2 s = vec2(0);\n    float c = 10000.0;\n    for (int i=0; i<glyph_segment; i++) {\n        o += s;\n        float h = h11(float(i) + seed);\n        vec2 e = s + vec2(0.1,0) * rot( floor(h * 8.0) * (tau / 8.0) );\n        s = e;\n    }\n    s = vec2(0);\n    c = 10000.0;\n    p += o / float(glyph_segment);\n    for (int i=0; i<glyph_segment; i++) {\n        float h = h11(float(i) + seed);\n        vec2 e = s + vec2(0.1,0) * rot( floor(h * 8.0) * (tau / 8.0) );\n        float l = line(p, s, e);\n        float point = length(p - e) - 0.004;\n        float sel = step(h, 0.2);\n        c = min(mix(l, point, sel), c);\n        s = e;\n    }\n\n    return c;\n}\n\nfloat flower(vec2 p) {\n\n    float hex = hexagon(vec2(p.x,-p.y), 0.85);\n\n    vec2 al = vec2((atan(p.y,p.x) + pi) / tau, length(p));\n\n    const float m = 24.0;\n    float seed = floor(al.x * m);\n    float a = (fract( al.x * m ) - 0.5) * (pi / (m * 0.5));\n\n    const float grm = 8.0;\n    float b = (fract( al.x * grm ) - 0.5) * (pi / (grm * 0.5));\n    p = al.y * vec2(cos(b), sin(b));\n    p.x -= 0.4;\n    p = p.yx;\n\n    al = al.y * vec2(cos(a), sin(a));\n\n    al.x -= 0.8;\n    al *= 2.0;\n    al = al.yx;\n    float g = glyph(al, seed + 4.0) - 0.001;\n\n    vec2 vp = p;\n    float v0 = vesica(vp, 0.2,  0.11);\n    float v1 = vesica(vp + vec2(0.0, 0.04), 0.23, 0.12);\n    float v = max(v1, -v0);\n    float vc = abs(v);\n\n    vec2 pc = p + vec2(0.0, 0.05);\n    float c = length( pc );\n    float cl = abs(moda(pc, (grm-2.0) * 2.0, 0.0).y) - 0.05 * c;\n    cl = abs( max( -c + 0.03 , max(cl, -v)) );\n\n    return max(hex, min(min(g, cl), min(vc, c-0.02)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    col += smoothstep( 2.5/iResolution.y, 0.0, flower(uv * 2.));\n    fragColor = vec4(sqrt(col), 1);\n}","name":"Image","description":"","type":"image"}]}