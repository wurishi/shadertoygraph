{"ver":"0.1","info":{"id":"M3VGDt","date":"1718445730","viewed":75,"name":"Voxel Turtle","username":"dd2d","description":"This is my first voxel engine. Initially, I wrote all the code in the Godot Engine in 2 weeks and eventually I published it on the site. In the engine itself, it can draw over 1,000,000 cubes.\n\nThe first cube: https://www.shadertoy.com/view/WslGz4","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voxel","intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COUNT 168\n#define GRID_SIZE ivec3(7,3,8)\n\n#define EPSILON 0.00005\n#define BOX 0.4\n#define DBOX 0.8\n#define DIST 9.\n\n#define ORTHOGRAFIC 0\n\nconst int grid[] = int[](0,0,1,2,2,0,0, 0,0,1,0,2,0,0, 2,1,0,0,0,1,2, 0,1,0,0,0,1,0, 0,1,0,0,0,1,0, 0,1,0,0,0,1,0, 2,1,2,2,2,1,2, 0,0,0,1,0,0,0,\n                         0,0,3,2,3,0,0, 0,0,1,0,1,0,0, 0,0,4,4,5,0,0, 0,4,0,0,0,4,0, 0,5,0,0,0,5,0, 0,5,0,0,0,5,0, 0,0,4,4,4,0,0, 0,0,0,0,0,0,0,\n                         0,0,2,1,1,0,0, 0,0,1,2,1,0,0, 0,0,0,0,0,0,0, 0,0,5,4,5,0,0, 0,0,5,4,4,0,0, 0,0,5,5,4,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0);\n\n\nbool iBox(in vec3 ro, in vec3 rd, in vec3 txx0, in vec3 rad, out vec2 outT, out vec3 outNor, out vec2 outST){\n\tvec3 roo = -txx0 + ro, m = 1./rd, s = vec3((rd.x<0.)?1.:-1., (rd.y<0.)?1.:-1., (rd.z<0.)?1.:-1.);\n\tvec3 t1 = m*(-roo + s*rad), t2 = m*(-roo - s*rad);\n\tfloat tN = max( max( t1.x, t1.y ), t1.z ), tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.) return false;\n\tif( t1.x>t1.y && t1.x>t1.z ) { outNor = vec3(1.,0.,0.)*s.x; outST = roo.yz+rd.yz*t1.x; } \n\t\telse if( t1.y>t1.z ) { outNor = vec3(0.,1.,0.)*s.y; outST = roo.zx+rd.zx*t1.y; }\n\t\t\telse  { outNor = vec3(0.,0.,1.).xyz*s.z; outST = roo.xy+rd.xy*t1.z; }\n\toutT = vec2(tN,tF);\n\treturn true;\n}\n\nfloat gradBox(in vec2 p){\n\tvec2 w = fwidth(p) + 0.001;\n\tvec2 i = 2.*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n\treturn 0.5 - 0.5*i.x*i.y;\n}\n\nbool inside(in ivec3 v){\n\treturn !((v.x<0)||(v.y<0)||(v.z<0)||(v.x>GRID_SIZE.x-1)||(v.y>GRID_SIZE.y-1)||(v.z>GRID_SIZE.z-1));\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ta = BOX*vec3(GRID_SIZE-1);\n    \n    #if ORTHOGRAFIC\n        float an = -1.3;\n        vec3 ro = vec3(DIST*cos(an), 2., DIST*sin(an))+ta;\n        vec3 rd = lookAt(ro, ta, 0.)*normalize(vec3(0.,0.,1.));\n        ro = ro + vec3(3.*p, 0.);\n\t#else\n    float an = 0.3*iTime - 1.3;\n        vec3 ro = vec3(DIST*cos(an), 2., DIST*sin(an))+ta;\n        vec3 ww = normalize(ta-ro);\n        vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)) );\n        vec3 vv = cross(uu,ww);\n        vec3 rd = normalize(p.x*uu + p.y*vv + 2.*ww);\n    #endif\n\tvec2 tmin = vec2(10000.), tnf0 = vec2(100000.), uv = vec2(0.), buv0;\n\tvec3 nor = vec3(0.), pos = vec3(0.), bnor0;\n\tfloat oid = 0.; bool b0 = false; int pgrid;\n    \n\t// raytrace plane\n\tfloat h = (-ro.y-BOX*vec3(GRID_SIZE-1).y/2.)/rd.y;\n\tif( h>0. ){ tmin.x = h; nor.y = 1.; oid = 1.; pos = ro + rd*h; uv = pos.xz; }\n        \n\t//raytrace BOXS\n\tvec3 roo = ro, o_grid = BOX*vec3(GRID_SIZE-1);\n\tvec3 col2 = vec3(0.), col = vec3(0.54,0.78,0.9);\n    \n\tif( iBox(roo, rd, o_grid, BOX*vec3(GRID_SIZE), tnf0, bnor0, buv0) ){\n\t\tcol2 = vec3(0.01);\n\t\tvec3 n1 = ro + (tnf0.x + EPSILON)*rd, m1 = DBOX*round(n1/DBOX);\n\t\tivec3 v1 = ivec3(m1/DBOX);\n\t\tpgrid = v1.x + GRID_SIZE.x*(v1.z + GRID_SIZE.z*v1.y);\n\t\tif( grid[pgrid] != 0 ){\n\t\t\tb0 = iBox(ro, rd, m1, vec3(BOX), tnf0, bnor0, buv0);\n\t\t\tif( tmin.x > tnf0.x ){ tmin = tnf0; nor = bnor0; uv = buv0; oid = 2.; }\n\t\t}\n\t\tvec3 t = (m1 + sign(rd)*BOX - n1)/rd;\n\t\tvec3 c = abs(DBOX/rd);\n\t\t\n\t\tfor( int k=0;k<3;k++ ){\n\t\t\tvec3 ns = n1+(t[k] + EPSILON)*rd;\n\t\t\tfor( int i=1;i<GRID_SIZE[k];i++ ){\n\t\t\t\tvec3 ms = DBOX*round(ns/DBOX);\n\t\t\t\tv1 = ivec3(ms/DBOX);\n\t\t\t\tif( !inside(v1) ) break;\n\t\t\t\tint mpos = v1.x + GRID_SIZE.x*(v1.z + GRID_SIZE.z*v1.y);\n\t\t\t\tif( grid[mpos] != 0 ){\n\t\t\t\t\tb0 = iBox(ro, rd, ms, vec3(BOX), tnf0, bnor0, buv0);\n\t\t\t\t\tif( tmin.x > tnf0.x ){ tmin = tnf0; nor = bnor0; uv = buv0; oid = 2.; pgrid = mpos; }\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tns += c[k]*rd;\n\t\t\t}\n\t\t}\n\t}\n    \n\tvec3 tex = vec3(1.); vec3 mate = vec3(1.); \n\tvec3 lig = normalize(vec3(-2.,3.,-2.));//normalize(vec3(-2.*sin(0.1*iTime),3.,-2.*cos(0.1*iTime)));\n\t\n    if( tmin.x < 100. ){\n\t\t//vec3 lpos = vec3(10.,50.,-10.), lig = normalize(lpos-pos);\n\t\tpos = ro + tmin.x*rd;\n\t\tfloat occ = 1.;\n\t\tif( oid < 1.5 ){\n\t\t\tmate = vec3(0.96,0.93,0.8)*(0.8+0.1*gradBox(2.5/2.*uv+0.5))*vec3(0.6);\n\t\t}\n\t\telse{\n\t\t\tmate = vec3(0.9)*(0.8+0.1*gradBox(7.5*uv));\n\t\t\tocc  = (0.5 + 0.5*nor.y) * (clamp(pos.y,0.,1.));\n\t\t\tswitch( grid[pgrid] ){\n\t\t\t\tcase 1: tex = vec3(0.4,0.4,0.2); break;\n\t\t\t\tcase 2: tex = vec3(0.4,0.5,0.2); break;\n\t\t\t\tcase 3: tex = vec3(0.02,0.02,0.02); break;\n\t\t\t\tcase 4: tex = vec3(0.2,0.1,0.); break;\n\t\t\t\tcase 5: tex = vec3(0.3,0.2,0.); break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloat dif = clamp(pow(dot(nor,lig),0.25), 0., 1.); float diff = dif;\n\t\tif( iBox(pos, lig, o_grid, BOX*vec3(GRID_SIZE), tnf0, bnor0, buv0) ){\n\t\t\ttnf0.x = max(0., tnf0.x);\n\t\t\tvec3 n1 = pos + (tnf0.x + EPSILON)*lig, m1 = DBOX*round(n1/DBOX);\n\t\t\tivec3 v1 = ivec3(m1/DBOX);\n\t\t\tif( grid[v1.x + GRID_SIZE.x*(v1.z + GRID_SIZE.z*v1.y)] != 0 && inside(v1) ){ diff = 0.; }\n\n\t\t\tvec3 t = (m1 + sign(lig)*BOX - n1)/lig, c = abs(DBOX/lig);\n\t\t\tfor( int k=0;k<3;k++ ){\n\t\t\t\tvec3 ns = n1+(t[k] + EPSILON)*lig;\n\t\t\t\tfor( int i=1;i<GRID_SIZE[k];i++ ){\n\t\t\t\t\tvec3 ms = DBOX*round(ns/DBOX);\n\t\t\t\t\tv1 = ivec3(ms/DBOX);\n\t\t\t\t\tif( !inside(v1) ) break;\n\t\t\t\t\tif( grid[v1.x + GRID_SIZE.x*(v1.z + GRID_SIZE.z*v1.y)] != 0 ){ diff = 0.; break; }\n\t\t\t\t\tns += c[k]*lig;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcol = vec3(0.01)*occ + clamp(diff,0.1,0.9)*mate*tex;\n\t\tcol = mix(col, vec3(0.54,0.78,0.9), 1.-exp(-0.0005*tmin.x*tmin.x));\n\t}\n    \n\tfragColor = vec4(sqrt(col), 1.);\n}\n","name":"Image","description":"","type":"image"}]}