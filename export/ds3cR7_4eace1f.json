{"ver":"0.1","info":{"id":"ds3cR7","date":"1694904944","viewed":280,"name":"StarField X","username":"Domenic3000","description":"Starfield With nebulae","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["space","stars","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LAYERS 12.\n\nfloat fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nint hash(vec3 p) {\n    vec3 hashVec = vec3(dot(p, vec3(127.1, 311.7, 419.2)),\n                        dot(p, vec3(269.5, 183.3, 372.9)),\n                        dot(p, vec3(416.8, 238.7, 144.2)));\n    float hashValue = fract(sin(hashVec.x + hashVec.y + hashVec.z) * 43758.5453123);\n    return int(mod(hashValue * 12.0, 12.0));\n}\n\nfloat grad(int hash, vec3 p) {\n    // 12 possible 3D gradient directions\n        const vec3[12] gradients = vec3[12](\n        vec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\n        vec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\n        vec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1));\n\n    // Reduce the hash to one of the 12 gradient directions\n    int h = hash & 11;\n\n    // Compute the dot product\n    return dot(gradients[h], p);\n}\n\nfloat noise(vec3 p) {\n    vec3 Pi = floor(p);\n    vec3 Pf = p - Pi;\n    int ix0 = int(Pi.x);\n    int ix1 = ix0 + 1;\n    int iy0 = int(Pi.y);\n    int iy1 = iy0 + 1;\n    int iz0 = int(Pi.z);\n    int iz1 = iz0 + 1;\n    float n000 = grad(hash(vec3(ix0, iy0, iz0)), Pf);\n    float n001 = grad(hash(vec3(ix0, iy0, iz1)), Pf - vec3(0, 0, 1));\n    float n010 = grad(hash(vec3(ix0, iy1, iz0)), Pf - vec3(0, 1, 0));\n    float n011 = grad(hash(vec3(ix0, iy1, iz1)), Pf - vec3(0, 1, 1));\n    float n100 = grad(hash(vec3(ix1, iy0, iz0)), Pf - vec3(1, 0, 0));\n    float n101 = grad(hash(vec3(ix1, iy0, iz1)), Pf - vec3(1, 0, 1));\n    float n110 = grad(hash(vec3(ix1, iy1, iz0)), Pf - vec3(1, 1, 0));\n    float n111 = grad(hash(vec3(ix1, iy1, iz1)), Pf - vec3(1, 1, 1));\n    float fadePfX = fade(Pf.x);\n    float fadePfY = fade(Pf.y);\n    float fadePfZ = fade(Pf.z);\n    float nx00 = mix(n000, n100, fadePfX);\n    float nx01 = mix(n001, n101, fadePfX);\n    float nx10 = mix(n010, n110, fadePfX);\n    float nx11 = mix(n011, n111, fadePfX);\n    float nxy0 = mix(nx00, nx10, fadePfY);\n    float nxy1 = mix(nx01, nx11, fadePfY);\n\n    return mix(nxy0, nxy1, fadePfZ);\n}\n\nvec3 colorizeCloud(vec3 cloud) {\n    // Define colors\n    vec3 deepColor = vec3(0.075,0.506,0.475);\n    vec3 midDeepColor = vec3(0.420,0.020,0.345);  // new color\n    vec3 midColor = vec3(0.302,0.204,0.000);\n    vec3 midLightColor = vec3(0.110,0.404,0.412); // new color\n    vec3 lightColor = vec3(0.000,0.000,0.000);\n\n    vec3 color;\n    if(cloud.x < 0.25) {\n        color = mix(deepColor, midDeepColor, cloud.x * 4.0);\n    } else if(cloud.x < 0.5) {\n        color = mix(midDeepColor, midColor, (cloud.x - 0.25) * 4.0);\n    } else if(cloud.x < 0.75) {\n        color = mix(midColor, midLightColor, (cloud.x - 0.5) * 4.0);\n    } else {\n        color = mix(midLightColor, lightColor, (cloud.x - 0.75) * 4.0);\n    }\n\n    return smoothstep(0.6, 1., color * 2.1);\n}\n\n\nvec3 layeredNoise(vec3 p) {\n    p*= 2.;\n    float total = 0.7;\n    float frequency = 0.2;\n    float amplitude = 1.0;\n    float maxAmplitude = 0.8;\n    for(int i = 0; i < 10; i++) { // 3 octaves for example, adjust as needed\n        total += noise(p * frequency) * amplitude;\n        maxAmplitude += amplitude;\n        frequency *= 2.;\n        amplitude *= 0.5; // each octave has half the amplitude of the previous\n        p = p+vec3(i,0.2,0.5);\n    }\n    \n    vec3 cloud = vec3(total / maxAmplitude);\n    \n    vec3 cloudColor = colorizeCloud(cloud);\n    \n    return cloudColor;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat Star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = 0.05 / length(uv) + flare * max(0., 1.0 - abs(uv.x * uv.y * 1000.));\n    uv *= Rot(3.1415926535 / 4.);\n    m += 0.3 * flare * max(0.0, 1.0 - abs(uv.x * uv.y * 1000.));\n    m *= smoothstep(0.2, .01, d);\n    return m;\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(132.34, 465.39));\n    p+= dot(p, p+43.89);\n    return fract(p.x*p.y);\n} \n\nvec3 StarLayer(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    for(int y=-1;y<=1;y++) {\n        for(int x=-1;x<=1;x++){\n            vec2 offs = vec2(x, y);\n            float n = Hash21(id+offs);\n            float size = fract(n*597.13);\n            float star = Star(gv - offs - vec2(n, fract(n*23.45))+.5, smoothstep(.5, 0.5, size));\n            vec3 color = sin(vec3(0.463,0.216,0.804)*fract(n*956.64)*8.5+5.9)*.5+.5;\n            color *= vec3(0.231/(size*4.),0.306-(size/4.),0.063+(size/5.))*0.8;\n            \n            star *= sin(iTime*0.5+n*6.2831)*.5+1.;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\n\n// Helper function to convert RGB to HSV\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Helper function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Adjust Brightness, Contrast, Hue, Saturation\nvec3 adjustBCSH(vec3 col, float brightness, float contrast, float hue, float saturation) {\n    // Adjust brightness\n    col = col + brightness;\n\n    // Adjust contrast\n    col = (col - 0.5) * contrast + 0.5;\n\n    // Convert to HSV for hue and saturation adjustments\n    vec3 hsv = rgb2hsv(col);\n\n    // Adjust hue\n    hsv.x = fract(hsv.x + hue);\n\n    // Adjust saturation\n    hsv.y *= saturation;\n\n    // Convert back to RGB\n    col = hsv2rgb(hsv);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv2 = uv;\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    float t = iTime * .05;\n    uv += M;\n    uv *= Rot(t);\n    \n    vec3 col = vec3(0);   \n    for(float i = 0.; i<1.; i +=1./NUM_LAYERS) {\n        float depth = fract (i+t);\n        float scale = mix(20., .3, depth);\n        col += clamp(StarLayer(uv*scale+i*312.)*(depth*smoothstep(1., 0.98, depth)), 0., 1.);\n        vec3 clouds = layeredNoise(vec3(uv*scale+i*312.,1.0))*(depth*smoothstep(1., 0.90, depth));\n        clouds = .2*((clouds/2.)+smoothstep(.6, 1., clouds / 1.));\n        \n        col = clouds+(col*1.);\n        col = clamp(col, 0., 1.);\n    } \n    \n    // Adjust brightness, contrast, hue, and saturation\n    float brightness = 0.05;  // Example value, adjust as needed\n    float contrast = 2.2;    // Example value, adjust as needed\n    float hue = 1.+iTime*.05;         // Example value, adjust as needed\n    float saturation = 2.0;  // Example value, adjust as needed\n\n    col = adjustBCSH(col, brightness, contrast, hue, saturation);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}