{"ver":"0.1","info":{"id":"fdscDs","date":"1642936278","viewed":226,"name":"Holo-Britney","username":"PGRacer","description":"Cross your eyes until the images meet to see depth or turn off stereo on common line 73\nWASD+mouse to move around, but works best from approx. start position.\nProbably could do some work to not have to use such a small step fraction, but I'm lazy ;)","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","stereoscopic","hologram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"PGRacer - Raymarching Template\" by PGRacer. https://shadertoy.com/view/slVXDz\n// 2022-01-23 10:24:57\n\n// Fork of \"PGRacer - Raymarching Template\" by PGRacer. https://shadertoy.com/view/slVXDz\n// 2022-01-21 05:46:43\n\n//////////////////\n// IMAGE SHADER //\n//////////////////\n\nSDFSample Scene(vec3 p)\n{\n    p.z -= AvgComponents(texture(iChannel3, p.xy / vec2(1.44, 1.0) + vec2(0.5)).rgb) * -0.2;\n    \n    SDFSample sBox = Box(p, vec3(1.44, 1.0, 0.1));\n    sBox.d *= 0.1;\n    \n    return sBox;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 e = vec2(NORMAL_CHECK_OFFSET, 0);\n    \n\tvec3 n = Scene(p).d - vec3(\n\t\tScene(p - e.xyy).d,\n\t\tScene(p - e.yxy).d,\n\t\tScene(p - e.yyx).d\n\t\t);\n\treturn normalize(n);\n}\n\nSDFSample SampleScene(vec3 origin, vec3 rayDir, out vec3 p, out float distFromOrigin, out bool hit)\n{\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    p = vec3(0.0);\n    float prevDist = MAX_DIST;\n    SDFSample s;\n    \n    distFromOrigin = 0.0;\n    hit = false;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = origin + rayDir * distFromOrigin;\n\t\ts = Scene(p);\n\t\tdistFromOrigin += s.d;\n        \n        if (distFromOrigin >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (s.d < SURFACE_DISTANCE_TOLERANCE)\n\t\t{\n            hit = true;\n\t\t\tbreak;\n\t\t}\n        \n        prevDist = s.d;\n    }\n    \n    return s;\n}\n\nMaterialSample SampleSurface(SDFSample s, vec3 rayDir, vec3 normal)\n{\n    MaterialSample ms;\n    vec3 p = s.p * s.f;\n    ms.m = 0.0;\n    ms.s = 0.0;\n    normal = mul(s.r, normal);\n    \n    vec3 localNormal = mul(s.r, normal);\n    vec3 iridescent = vec3(NSin(localNormal.r), NSin(localNormal.g), NSin(localNormal.b));\n    \n    ms.c = texture(iChannel3,  p.xy / vec2(1.44, 1.0) + vec2(0.5)).rgb;\n    if (ms.c.g - (ms.c.r + ms.c.b) > 0.15)  {ms.c = BLACK; return ms;}\n    ms.c = mix(ms.c, abs(normal), 0.2);\n    \n    p = fract(p * 100.0);\n    float tol = 0.8;\n    // pseudo-mesh effect\n    if ((p.x < tol && p.y < tol) ||\n        (p.x < tol && p.z < tol) ||\n        (p.y < tol && p.z < tol))\n        ms.c = BLACK;\n    \n    return ms;\n}\n\nvec3 Render(vec3 camPos, vec3 camDir)\n{\n    float distFromOrigin = 0.0;\n    bool hit;\n\tbool outline;\n    \n    vec3 rayOrigin = camPos;\n    vec3 rayDir = camDir;\n    \n    SDFSample s;\n    vec3 p = vec3(0.0);\n    vec3 finalColor;\n    vec3 bgColor;\n    float reflectiveStrength = 1.0;\n    float mainDistRatio = -1.0;\n    int hitCount = 0;\n    MaterialSample ms;\n    \n    // Do raymarching\n    distFromOrigin = 0.0;\n    hit = false;\n\n    bgColor = BLACK;\n    s = SampleScene(rayOrigin, rayDir, p, distFromOrigin, hit);\n\n    vec3 color = BLACK;\n\n    float distRatio = distFromOrigin / MAX_DIST;\n    mainDistRatio = mainDistRatio < 0.0 ? distRatio : mainDistRatio;\n    vec3 normal = GetNormal(p);\n\n    float scalar = clamp(dot(-rayDir, normal), 0.0, 1.0);\n\n    // Apply color to pixel\n    if (hit)\n    {    \n        ms = SampleSurface(s, rayDir, normal);\n        return ms.c;\n    }\n    else\n    {\n        return bgColor;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alter resolution for old-school look\n    fragCoord *= RESOLUTION_RATIO;\n    fragCoord = floor(fragCoord) / RESOLUTION_RATIO;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Split-screen stereoscopy\n#if STEREO_ENABLED\n    bool leftEye = uv.x >= 0.5;\n    uv.x = fract(uv.x * 2.0);\n    uv.x *= 0.5;\n    uv -= vec2(0.25, 0.5);\n#else\n    uv -= vec2(0.5);\n#endif\n    \n    // Aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    // Camera Stuff\n    vec3 camPos = textureLod(iChannel0, vec2(0.5, 0.5)/iResolution.xy, 0.0).xyz;\n\n    // Camera look direction\n    vec3 camRot = textureLod(iChannel0, vec2(1.5, 0.5)/iResolution.xy, 0.0).xyz;\n    mat4 yawMat = MRotate(camRot.x, UP);\n    mat4 pitchMat = MRotate(camRot.y, RIGHT);\n    mat4 rollMat = MRotate(camRot.z, FORWARD);\n    mat4 rotMat = yawMat * pitchMat * rollMat;\n    vec3 camDir = mul(rotMat, normalize(vec3(uv.x, uv.y, 1.0)));\n    \n#if STEREO_ENABLED\n    // Stereo eye-positioning\n    camPos += mul(rotMat, ((leftEye ? LEFT : RIGHT) * INTERPUPILARY_DISTANCE * 0.5));\n#endif\n    \n    // Render the scene\n    vec3 color = Render(camPos, camDir);\n    \n#if SCAN_LINES_ENABLED\n    if (mod(fragCoord.y * RESOLUTION_RATIO, 2.0) < 1.0) color = BLACK;\n#endif\n        \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////\n// COMMON FUNCTIONS AND VALUES //\n/////////////////////////////////\n\n// RAYMARCHING\n#define MAX_STEPS 2000\n#define MAX_DIST 3.0\n#define SURFACE_DISTANCE_TOLERANCE 0.0001\n#define NORMAL_CHECK_OFFSET 0.001\n#define MAX_RAY_HITS 1\n\n// TIMING\n#define TIME iTime * 1.0\n\n// OUTLINE\n#define OUTLINE_WIDTH 0.0\n#define OUTLINE_DIST_COMP 0.7 // 0.0 lines shrink linearly with distance, 0.5 - lines stay same world-width at all distances, 1.0 - lines stay same screen width at distance \n\n// LIGHTING\n#define FADE_ATTENUATION 10.0\n#define AMBIENT_OCCLUSION_STEP_SIZE 0.006\n#define AMBIENT_OCCLUSION_STEP_COUNT 20.0\n#define AMBIENT_OCCLUSION_ATTENUATION 1.0\n#define SHADOW_CORRECTION 0.001\n#define DIFFUSE_REFLECTION 1\n#define REFLECTION_ANGLE_VARIANCE 1\n\n// SCENE START\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n\n// COMMON CONSTANTS\n#define TAU 6.283185\n#define PI  TAU / 2.0\n#define ROOT2 1.414213\n#define ROOT3 1.732051\n#define EULER 2.718282\n#define MIDENTITY mat4(1.0)\n\n// AXIAL VECTORS\n#define FORWARD vec3(0.0, 0.0, 1.0)\n#define BACKWARD vec3(0.0, 0.0, -1.0)\n#define LEFT vec3(-1.0, 0.0, 0.0)\n#define RIGHT vec3(1.0, 0.0, 0.0)\n#define UP vec3(0.0, 1.0, 0.0)\n#define DOWN vec3(0.0, -1.0, 0.0)\n\n// COLORS\n#define BLACK vec3(0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define BROWN vec3(0.5, 0.2, 0.0)\n#define DARK_GREY vec3(0.25, 0.25, 0.25)\n#define FUCHSIA vec3(1.0, 0.0, 1.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define LIGHT_GREY vec3(0.75, 0.75, 0.75)\n#define MEDIUM_GREY vec3(0.5, 0.5, 0.5)\n#define ORANGE vec3(1.0, 0.5, 0.0)\n#define PINK vec3(1.0, 0.5, 0.5)\n#define RED vec3(1.0, 0.0, 0.0)\n#define TURQUOISE vec3(0.0, 1.0, 1.0)\n#define WHITE vec3(1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\n\n// COLOR CORRECTION\n#define COLOR_BIT_DEPTH 8.0\n#define GAMMA 1.0\n#define CONTRAST 1.0\n#define SATURATION 1.0\n#define NEGATIVE 0.0\n#define TINT WHITE\n\n// RENDERING OPTIONS\n#define STEREO_ENABLED 1\n#define INTERPUPILARY_DISTANCE 0.15\n#define SCAN_LINES_ENABLED 0\n#define RESOLUTION_RATIO 1.0 // 0.0 will result in divide-by-zero, magnitude 1.0+ will have no effect.  negative values will shift pixels (-1,-1).\n\n// INPUT KEYS\n#define KEY_SHIFT   16\n#define KEY_CONTROL 17\n#define KEY_SPACE   32\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_A       65\n#define KEY_B       66\n#define KEY_C       67\n#define KEY_D       68\n#define KEY_E       69\n#define KEY_F       70\n#define KEY_G       71\n#define KEY_H       72\n#define KEY_I       73\n#define KEY_J       74\n#define KEY_K       75\n#define KEY_L       76\n#define KEY_M       77\n#define KEY_N       78\n#define KEY_O       79\n#define KEY_P       80\n#define KEY_Q       81\n#define KEY_R       82\n#define KEY_S       83\n#define KEY_T       84\n#define KEY_U       85\n#define KEY_V       86\n#define KEY_W       87\n#define KEY_X       88\n#define KEY_Y       89\n#define KEY_Z       90\n#define KEY_0       48\n#define KEY_1       49\n#define KEY_2       50\n#define KEY_3       51\n#define KEY_4       52\n#define KEY_5       53\n#define KEY_6       54\n#define KEY_7       55\n#define KEY_8       56\n#define KEY_9       57\n\n// MOUSE BUTTON INPUT\nbool IsNewClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y < 1.0;\n}\n\nbool IsPersistentClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y > 0.0;\n}\n\nbool IsNewRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y > 0.0;\n}\n\nbool IsPersistentRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y < 1.0;\n}\n\n// KEYBOARD INPUT\nbool ReadKey(sampler2D sampler, int key, bool toggle)\n{\n\treturn textureLod(sampler, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x > 0.0;\n}\n\n// TRANSFORMATIONS\nmat2x2 MRotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nmat4 MRotate(float angle, vec3 axis) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c,          0.0,\n                0.0,                               0.0,                               0.0,                               1.0);\n}\n\nmat4 MScale(vec3 s)\n{\n    return mat4(s.x, 0.0, 0.0, 0.0,\n                0.0, s.y, 0.0, 0.0,\n                0.0, 0.0, s.z, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 MScale(float s)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0 / s);\n}\n\nmat4 MTranslate(vec3 v)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0);\n}\n\nmat4 MTransInv(mat4 m)\n{\n    return transpose(inverse(m));\n}\n\nvec3 mul(mat4 m, vec3 v)\n{\n    return (m * vec4(v, 1.0)).xyz;\n}\n\nvec3 nmul(mat4 m, vec3 v)\n{\n    return (m * vec4(v, 0.0)).xyz;\n}\n\n// USEFUL MATH STUFF\nfloat SumComponents(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\nfloat SumComponentLength(vec3 v)\n{\n    return SumComponents(abs(v));\n}\n\nfloat AvgComponents(vec3 v)\n{\n    return (v.x + v.y + v.z) / 3.0;\n}\n\nfloat AvgComponentLength(vec3 v)\n{\n    return AvgComponents(abs(v));\n}\n\nfloat ComponentVariance(vec3 v)\n{\n    float mean = AvgComponentLength(v);\n    vec3 sqDiff = vec3(mean) - v * v;\n    float sum = SumComponents(sqDiff);\n    return sum / 3.0;\n}\n\nfloat NSin(float t)\n{\n    return sin(t) * 0.5 + 0.5;\n}\n\nfloat NCos(float t)\n{\n    return cos(t) * 0.5 + 0.5;\n}\n\nfloat TriangleWave(float t)\n{\n    return 2.0 * abs(2.0 * (t / TAU - floor(t / TAU + 0.5))) - 1.0;\n}\n\nfloat NTriangleWave(float t)\n{\n    return 2.0 * abs(t / TAU - floor(t / TAU + 0.5));\n}\n\nfloat SFract(float v)\n{\n    if (v >= 0.0)\n    {\n        return v - floor(v);\n    }\n    return -(v - ceil(v));\n}\n\nvec2 SFract(vec2 v)\n{\n    return vec2(SFract(v.x), SFract(v.y));\n}\n\nvec3 SFract(vec3 v)\n{\n    return vec3(SFract(v.xy), SFract(v.z));\n}\n\nfloat SMod(float v, float x)\n{\n    return x == 0.0 ? v : SFract(v / x) * x;\n}\n\nvec2 SMod(vec2 v, vec2 x)\n{\n    return vec2(SMod(v.x, x.x), SMod(v.y, x.y));\n}\n\nvec3 SMod(vec3 v, vec3 x)\n{\n    return vec3(SMod(v.xy, x.xy), SMod(v.z, x.z));\n}\n\nvec3 FlipX(vec3 p)\n{\n    return vec3(-p.x, p.y, p.z);\n}\n\nvec3 FlipY(vec3 p)\n{\n    return vec3(p.x, -p.y, p.z);\n}\n\nvec3 FlipZ(vec3 p)\n{\n    return vec3(p.x, p.y, -p.z);\n}\n\nvec3 AbsX(vec3 p)\n{\n    return vec3(abs(p.x), p.y, p.z);\n}\n\nvec3 AbsY(vec3 p)\n{\n    return vec3(p.x, abs(p.y), p.z);\n}\n\nvec3 AbsZ(vec3 p)\n{\n    return vec3(p.x, p.y, abs(p.z));\n}\n\nvec3 AbsXY(vec3 p)\n{\n    return vec3(abs(p.x), abs(p.y), p.z);\n}\n\nvec3 AbsXZ(vec3 p)\n{\n    return vec3(abs(p.x), p.y, abs(p.z));\n}\n\nvec3 AbsYZ(vec3 p)\n{\n    return vec3(p.x, abs(p.y), abs(p.z));\n}\n\nvec3 NegateX(vec3 p)\n{\n    return vec3(-p.x, p.y, p.z);\n}\n\nvec3 NegateY(vec3 p)\n{\n    return vec3(p.x, -p.y, p.z);\n}\n\nvec3 NegateZ(vec3 p)\n{\n    return vec3(p.x, p.y, -p.z);\n}\n\nvec3 NegateXY(vec3 p)\n{\n    return vec3(-p.x, -p.y, p.z);\n}\n\nvec3 NegateYZ(vec3 p)\n{\n    return vec3(p.x, -p.y, -p.z);\n}\n\nvec3 NegateXZ(vec3 p)\n{\n    return vec3(-p.x, p.y, -p.z);\n}\n\n// STRUCTS\nstruct MaterialSample\n{\n    vec3 c;\n    float m;\n    float s;\n};\n\nstruct SDFSample\n{\n    float d;\n    vec3 p;\n    int m;\n    float f;\n    mat4 r;\n};\n\nstruct LightSource\n{\n    vec3 p;\n    vec3 c;\n    float s;\n};\n\n// COMBINATIONS\nSDFSample Union(SDFSample d1, SDFSample d2)\n{\n    if (d1.d < d2.d) return d1; return d2;\n}\n\nSDFSample SmoothUnion(SDFSample s1, SDFSample s2, float smoothing)\n{\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / smoothing, 0.0, 1.0);\n    float dMix = mix(s2.d, s1.d, h) - smoothing * h * (1.0 - h);\n    return SDFSample(dMix, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample Difference(SDFSample s1, SDFSample s2, float c)\n{\n    float clearance = s2.d - c;\n    return SDFSample(s1.d > -clearance ? s1.d : -clearance, s1.p,  s1.m, s1.f, s1.r);\n}\n\nSDFSample SmoothDifference(SDFSample s1, SDFSample s2, float smoothing) {\n    float h = max(smoothing - abs(-s2.d - s1.d), 0.0);\n    return SDFSample(max(s1.d, -s2.d) + h * h  *0.25 / smoothing, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample BufferedUnion(SDFSample s1, SDFSample s2, float r)\n{\n    return Union(s1, SmoothDifference(s2, s1, r));\n}\n\nSDFSample Intersection(SDFSample s1, SDFSample s2)\n{\n    return SDFSample(s1.d > s2.d ? s1.d : s2.d, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample SmoothIntersection(SDFSample s1, SDFSample s2, float smoothing)\n{\n    float h = clamp(0.5 - 0.5 * (s2.d - s1.d) / smoothing, 0.0, 1.0);\n    float dMix = mix(s2.d, s1.d, h) + smoothing * h * (1.0 - h);\n    return SDFSample(dMix, s1.p, s1.m, s1.f, s1.r);\n}\n\nSDFSample Negation(SDFSample s1, SDFSample s2)\n{\n    return Difference(Union(s1, s2), Intersection(s1, s2), 0.004); // Seems to need a slight error correction\n}\n\nSDFSample SmoothNegation(SDFSample s1, SDFSample s2, float smoothing)\n{\n    SDFSample i = Intersection(s1, s2);\n    return Union(SmoothDifference(s1, i, smoothing), SmoothDifference(s2, i, smoothing)); // Doing the Differences separately and before the union preserves rotations\n}\n\n// DISTORTIONS\nvec3 Twist(vec3 p, float twist)\n{\n    float c = cos(twist * p.y);\n    float s = sin(twist * p.y);\n    mat2  m = mat2(c, -s ,s, c);\n    vec2 pT = m*p.xz;\n    vec3  q = vec3(pT.x, p.y, pT.y);\n    return q;\n}\n\nvec3 Bend(vec3 p, float bend)\n{\n    float c = cos(bend * p.x);\n    float s = sin(bend * p.x);\n    mat2  m = mat2(c, -s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec4 Elongate(vec3 p, vec3 h)\n{   \n    // Usage: dist = min(dist, w.w+DistFunc(w.xyz, ... ) );\n    // Where w is the output of this function\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat Layer(float d, float h)\n{\n    return abs(d) - h;\n}\n\nvec3 SpacialWave(vec3 p, vec3 c, float a, float f, float t)\n{\n    return (length(p - c) * (1.0 - a) + a * sin(length(p - c) * f + t)) * normalize(p - c) + c;\n}\n\n// Slicing\nfloat SliceXZ(vec3 p, float d)\n{\n    return max(abs(p.y), d);\n}\n\nfloat SliceXY(vec3 p, float d)\n{\n    return max(abs(p.z), d);\n}\n\nfloat SliceYZ(vec3 p, float d)\n{\n    return max(abs(p.x), d);\n}\n\n// Repetitions\nvec3 RepeatRange(in vec3 p, in vec3 c, in vec3 l)\n{\n    p -= c * 0.5 * (1.0 - mod(l, 2.0));\n    return p - c * (clamp(round(p / c), ceil(-l * 0.5), ceil(l * 0.5) - vec3(1.0)));\n}\n\nvec3 RepeatInfinite(in vec3 p, in vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat Extrusion(vec3 p, float d, float h)\n{\n    vec2 w = vec2(d, abs(p.y) - h * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 2D PRIMITIVES\nvec2 Circle(vec3 p, float r)\n{\n    return vec2(length(vec2(p.x, p.z)) - r, 0.0);\n}\n\nfloat Star5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// 3D PRIMITIVES - Mostly adapted from https://iquilezles.org/articles/distfunctions\nSDFSample SquareColumn(vec3 p, vec2 d)\n{\n    vec3 pO = abs(p);\n    return SDFSample(max(pO.x - d.x / 2.0, pO.z - d.y / 2.0), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Sphere(vec3 p, float r)\n{\n\treturn SDFSample(length(p) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample ISphere(vec3 p, float r)\n{\n    return SDFSample(r - length(p), p, 1, 1.0, MIDENTITY);\n}\n\nSDFSample Box(vec3 p, vec3 dimensions)\n{\n    vec3 pO = abs(p);\n\treturn SDFSample(length(max(abs(pO) - (0.5 * dimensions), 0.0)), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Disk(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Capsule(vec3 p, float h, float r)\n{\n\tvec3 a = vec3(0.0, h * 0.5, 0.0);\n\tvec3 b = vec3(0.0, -h * 0.5, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n    \n\treturn SDFSample(length(p - c) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Cylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);\n    return SDFSample(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), vec3(p.x, p.y, p.z), 0, 1.0, MIDENTITY);\n}\n\nSDFSample Tube(vec3 p, float h, float r, float t)\n{\n    float dHoop = abs(Circle(p, r).x) - t;\n    return SDFSample(Extrusion(p, dHoop, h), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Torus(vec3 p, float w, float r)\n{\n\treturn SDFSample(length(vec2(length(p.xz) - w, p.y)) - r, p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Hoop(vec3 p, float h, float rO, float rI)\n{\n    SDFSample c1 = Cylinder(p, h, rO);\n    SDFSample c2 = Capsule(p, h, rI);\n\treturn Difference(c1, c2, 0.0);\n}\n\nSDFSample Gyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    vec3 pO = p * repetition;\n    float avgRepetition = AvgComponentLength(repetition);\n    return SDFSample(abs(dot(sin(pO * bias.x), cos(pO.zxy * bias.y))) / avgRepetition - width, pO, 0, 1.0, MIDENTITY);\n}\n\nSDFSample BoxFrame(vec3 p, vec3 b, float e)\n{\n    vec3 pO = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n    float minimum = min(min(\n        length(max(vec3(pO.x,q.y,q.z),0.0))+min(max(pO.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,pO.y,q.z),0.0))+min(max(q.x,max(pO.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,pO.z),0.0))+min(max(q.x,max(q.y,pO.z)),0.0));\n      \n    return SDFSample(minimum, pO, 0, 1.0, MIDENTITY);\n}\n\nSDFSample Plane(vec3 p)\n{\n    vec3 pO = AbsY(p);\n    return SDFSample(pO.y, pO, 0, 1.0, MIDENTITY);\n}\n\nSDFSample InfiniteCone(vec3 p, float angle)\n{\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec2 q = vec2(length(p.xz), -p.y);\n    float d = length(q - c * max(dot(q, c), 0.0));\n    return SDFSample(d * ((q.x * c.y - q.y * c.x < 0.0) ? -1.0 : 1.0), p, 0, 1.0, MIDENTITY);\n}\n\nSDFSample CappedCone(vec3 p, float h, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return SDFSample(s * sqrt(min(dot(ca, ca), dot(cb, cb)) ), p, 0, 1.0, MIDENTITY);\n}\n\n// NOISE\n\nfloat N11(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n\nfloat N21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat N31(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\nvec3 N33(vec3 p)\n{\n    vec4 a = fract(p.xyzx * vec4(1278.67, 3134.61, 298.647, 134.489));\n    a += dot(a, a + 318.978);\n    return fract(vec3(a.x * a.y, a.y * a.z, a.z * a.w)) * 0.5;\n}\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 NNormal(vec3 d, vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n// BACKGROUNDS\nvec3 ColoredSpace(vec3 rayDir, vec2 res, float time)\n{\n    vec3 r3 = N33(floor(rayDir * res.y * 0.5) / res.y * 2.0);\n    float r1 = pow(N31(r3), 5.0);\n    float stars = smoothstep(0.95, 0.995, r1);\n    \n    vec3 v = vec3(NSin(time * 0.2496 + rayDir.r), NSin(time * 0.354 + rayDir.g), NSin(time * 0.4289 + rayDir.b));\n    v *= 0.2;\n    \n    v += mix(vec3(stars), r3 * stars, 0.66);\n    \n    return v;\n}\n\nvec3 GradientSky(vec3 rayDir)\n{\n\n#define SKY_BLUE vec3(0.3, 0.7, 1.0)\n#define HORIZON_ORANGE vec3(1.0, 0.5, 0.2)\n#define DARK_BLUE vec3(0.05, 0.0, 0.15)\n    float scalar = dot(normalize(vec3(rayDir.x, 0.0, rayDir.z)), normalize(rayDir));\n    scalar = 1.0 - scalar;\n    if (rayDir.y < 0.0) scalar = -scalar;\n    scalar = (scalar + 1.0) / 2.0;\n    \n    vec3 col = DARK_BLUE;\n    col = mix(col, HORIZON_ORANGE, smoothstep(0.499, 0.5, scalar));\n    col = mix(col, SKY_BLUE, smoothstep(0.49, 0.51, scalar));\n    \n    return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////\n// INPUT SHADER //\n//////////////////\n\n// CAMERA PARAMETERS\n#define INIT_CAM_POS vec3(-0.5, 0.0, -1.5)\n#define INIT_CAM_YAW PI * -0.1\n#define INIT_CAM_PITCH 0.0\n#define INIT_CAM_ROLL 0.0\n#define ROTATION_SPEED 8.0\n#define BASE_MOVE_SPEED 2.0\n#define MOVE_ACCELERATION 1.01\n\n// UPDATE AND RECORD INPUT\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if (int(fragCoord.y) == 0 )\n    {\n        if (int(fragCoord.x) <= 1)\n        {\n            // CAMERA CONTROLS\n            vec4 camPos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy, -100.0);\n            vec4 camRot = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0).xy;\n            \n            float yawAngle = camRot.x - ROTATION_SPEED * mousePosData.x / iResolution.x;\n            float pitchAngle = clamp(camRot.y + ROTATION_SPEED * mousePosData.y / iResolution.y, -PI / 2.0, PI / 2.0);\n            float rollAngle = camRot.z;\n\n            //if (ReadKey(iChannel1, KEY_Q, false))\n            //{\n            //    rollAngle -= ROTATION_SPEED * iTimeDelta;\n            //}\n\n            //if (ReadKey(iChannel1, KEY_E, false))\n            //{\n            //    rollAngle += ROTATION_SPEED * iTimeDelta;\n            //}\n            \n            if (camRot.w == 0.0 || ReadKey(iChannel1, KEY_F, false))\n            {\n                yawAngle = INIT_CAM_YAW;\n                pitchAngle = INIT_CAM_PITCH;\n                rollAngle = INIT_CAM_ROLL;\n            }\n            \n            if (int(fragCoord.x) == 0)\n            {\n                // CAMERA POSITION\n                vec3 moveDir = vec3(0.0);\n                \n                mat4 yawMat = MRotate(yawAngle, UP);\n                mat4 pitchMat = MRotate(pitchAngle, RIGHT);\n                mat4 rollMat = MRotate(rollAngle, FORWARD);\n                mat4 rotMat = yawMat * pitchMat * rollMat;\n                \n                float moveSpeed = camPos.w;\n                \n                if (camRot.w == 0.0 || ReadKey(iChannel1, KEY_F, false))\n                {\n                    // SET INIT MOVE SPEED\n                    moveSpeed = BASE_MOVE_SPEED;\n                }\n                \n                // ACCELERATE/DECELERATE\n                if (ReadKey(iChannel1, KEY_UP, false))\n                {\n                    moveSpeed *= MOVE_ACCELERATION;\n                }\n                if (ReadKey(iChannel1, KEY_DOWN, false))\n                {\n                    moveSpeed /= MOVE_ACCELERATION;\n                }\n                \n                // MOVEMENT\n                if (ReadKey(iChannel1, KEY_W, false))\n                {\n                    moveDir += mul(rotMat, FORWARD);\n                }\n                if (ReadKey(iChannel1, KEY_S, false))\n                {\n                    moveDir += mul(rotMat, BACKWARD);\n                }\n                if (ReadKey(iChannel1, KEY_A, false))\n                {\n                    moveDir += mul(rotMat, LEFT);\n                }\n                if (ReadKey(iChannel1, KEY_D, false))\n                {\n                    moveDir += mul(rotMat, RIGHT);\n                }\n                if (ReadKey(iChannel1, KEY_SPACE, false))\n                {\n                    moveDir += mul(rotMat, UP);\n                }\n                if (ReadKey(iChannel1, KEY_SHIFT, false))\n                {\n                    moveDir += mul(rotMat, DOWN);\n                }            \n\n                vec3 movement = vec3(0.0);\n                if (length(moveDir) > 0.0)\n                {\n                    movement = normalize(moveDir) * iTimeDelta * moveSpeed;\n                }\n\n                if (camRot.w == 0.0 || ReadKey(iChannel1, KEY_F, false))\n                {\n                    // ADD INIT POSITION\n                    camPos.xyz = INIT_CAM_POS;\n                    movement = vec3(0.0);\n                }\n                \n                fragColor = vec4(camPos.xyz + movement, moveSpeed);\n            }\n            else\n            {                \n                // CAMERA ROTATION\n                fragColor = vec4(yawAngle, pitchAngle, rollAngle, 1.0); // w value 1.0 means no longer first frame\n            }\n        }\n        else if (int(fragCoord.x) == 2)\n        {\n            // MOUSE CLICK\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);            \n            fragColor = vec4(iMouse.z, mouseClickData.x, IsNewClick(mouseClickData.xy) || IsPersistentClick(mouseClickData.xy) ? iMouse.xy : vec2(0.0));\n        }\n        else if (int(fragCoord.x) == 3)\n        {\n            // MOUSE MOVEMENT\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);\n            vec4 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mouseDelta = IsPersistentClick(mouseClickData.zw) ? iMouse.xy - mouseClickData.zw : vec2(0.0);\n            vec2 mouseCumulative = mousePosData.zw + mouseDelta;\n            fragColor = vec4(mouseDelta, mouseCumulative);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}