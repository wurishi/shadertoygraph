{"ver":"0.1","info":{"id":"ftfBRr","date":"1650604798","viewed":60,"name":"AStarShader","username":"GuanDao","description":"AStarSearch","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int WidthNum = 8;\nconst int HeightNum = 5;\nconst float TickTimer = 1.;\nbool[WidthNum * HeightNum] Map;\nbool[WidthNum * HeightNum] Blocker;\n// 已经解锁 f-cost 当前路程代价 指向的方向\nivec3[WidthNum * HeightNum] Search;\nhighp float lastTimer = 0.; \nivec2 startpos = ivec2(1,2);\nivec2 goalpos = ivec2(6,2);\n\nbool GetMapIndex(ivec2 pos,bool bBlocker)\n{\n\n    int len = pos.x + pos.y * WidthNum;\n    if (bBlocker)\n    {\n        if (Blocker[len])\n        {\n            return true;\n        }\n        else return false;\n    }\n    if (Map[len])\n    {\n        return true;\n    }\n    else return false;\n}\n\nbool IsMapBlock(ivec2 pos)\n{\n    return GetMapIndex(pos,true);\n}\n\nvoid SetMapIndex(ivec2 pos,bool bTrue,bool bBlocker)\n{\n    int len = pos.x + pos.y * WidthNum;\n    Map[len] = bTrue; \n}\n\n// 转化方位 左 -1 右 1 上 -2 下 2\nint GetVec2Dir(ivec2 dir)\n{\n    return dir.x + dir.y * 2;\n}\n\n// 转化方位\nivec2 GetDir2Vec(int dir)\n{\n    if (dir == 2)\n        return ivec2(0,1);\n    else if (dir == 1)\n        return ivec2(1,0);\n    else if (dir == -1)\n        return ivec2(-1,0);\n    else if (dir == -2)\n        return ivec2(0,-1);\n    return ivec2(0,0);\n}\n\nvec4 getGridColorByPos( ivec2 pos )\n{\n    SetMapIndex(pos,true,false);\n    // 给起点和终点上色\n    if (Search[pos.x + pos.y*WidthNum].x == 1)\n    {\n        vec4 fragColor = vec4(0.,1.,0.,cos(iTime));\n        return fragColor;\n    }\n    else if (Search[pos.x + pos.y*WidthNum].x > 2)\n    {\n        vec4 fragColor = vec4(1.,1.,0.,cos(iTime));\n        return fragColor;\n    }\n    else if (pos == goalpos)\n    {\n        vec4 fragColor = vec4(1.,0.,0.,cos(iTime));\n        return fragColor;\n    }\n    if (IsMapBlock(pos))\n    {\n        vec4 fragColor = vec4(.4);\n        return fragColor;\n    }\n    vec4 fragColor = vec4(GetMapIndex(pos,false),cos(iTime),1.0,1.0);\n    return fragColor;\n}\n\nvec4 grids( vec2 fragCoord )\n{\n    // split into 8x5 grid\n    vec2 wh = iResolution.xy / vec2(WidthNum,HeightNum);\n    vec2 uv = fragCoord / wh;\n    vec2 delta = 1. - abs(mod(uv,1.) -.5);\n    float deltanum = (delta.x + delta.y) / 2.;\n    // 坐标系切换到左上角\n    uv = vec2(uv.x,float(HeightNum)-uv.y);\n    //uv = vec2(int(uv.x)/WidthNum,int(uv.y)/HeightNum);\n    //vec4 fragColor = vec4(uv,cos(iTime),1.0);\n    vec4 fragColor = getGridColorByPos(ivec2(uv));\n    return fragColor * deltanum;\n}\n\n// 获取曼哈顿距离\nint GetManhattanDistance(ivec2 pos,ivec2 aimpos)\n{\n    return abs(pos.x - aimpos.x) + abs(pos.y - aimpos.y);\n}\n\n// 获取总代价\nint GetCost(ivec2 pos,ivec2 aimpos)\n{\n    return Search[pos.x + pos.y*WidthNum].y + GetManhattanDistance(pos,aimpos);\n}\n\nvoid SetPath(ivec2 pos)\n{\n    ivec2 pos_step = pos;\n    Search[pos_step.x + pos_step.y*WidthNum].x = 3;\n    while (Search[pos_step.x + pos_step.y*WidthNum].z != 0)\n    {\n        pos_step -= GetDir2Vec(Search[pos_step.x + pos_step.y*WidthNum].z);\n        if (Search[pos_step.x + pos_step.y*WidthNum].x == 2)\n            Search[pos_step.x + pos_step.y*WidthNum].x = 3;\n    }\n}\n\n// 解锁一个坐标\nbool UnlockPos(ivec2 pos,int cost,ivec2 dependpos)\n{\n    // 边界检测\n    if (pos.x >= WidthNum || pos.y >= HeightNum)\n        return false;\n    if (pos.x < 0 || pos.y < 0)\n        return false;\n    if (IsMapBlock(pos))\n        return false;\n    //if (pos == goalpos)\n    //    return false;\n    // 已经被解锁\n    if (Search[pos.x + pos.y*WidthNum].x > 1)\n        return false;\n    if (Search[pos.x + pos.y*WidthNum].x == 1)\n        if (Search[pos.x + pos.y*WidthNum].y > cost + 1)\n            return false;\n    Search[pos.x + pos.y*WidthNum].y = cost + 1;\n    Search[pos.x + pos.y*WidthNum].x = 1;\n    // 已经解锁周围的块了就别占资源了\n    if (dependpos == ivec2(-1))\n        // Search[pos.x + pos.y*WidthNum].z = 0;\n        return true;\n    Search[dependpos.x + dependpos.y*WidthNum].x = 2;\n    Search[pos.x + pos.y*WidthNum].z = GetVec2Dir(pos - dependpos);\n    return true;\n}\n\n// 处理邻居\nbool DealNeighbors(ivec2 pos)\n{\n    bool flag1 = UnlockPos(pos + ivec2(1,0),Search[pos.x + pos.y*WidthNum].y,pos);\n    bool flag2 = UnlockPos(pos + ivec2(0,1),Search[pos.x + pos.y*WidthNum].y,pos);\n    bool flag3 = UnlockPos(pos + ivec2(-1,0),Search[pos.x + pos.y*WidthNum].y,pos);\n    bool flag4 = UnlockPos(pos + ivec2(0,-1),Search[pos.x + pos.y*WidthNum].y,pos);\n    if (!(flag1 || flag2 || flag3 || flag4))\n        Search[pos.x + pos.y*WidthNum].x = 2;\n    return flag1 || flag2 || flag3 || flag4;\n}\n\n// 获取下一个总代价最小的坐标\nivec2 GetNextPos()\n{\n    int Mincost = 999;\n    ivec2 MinIndex = ivec2(-1);\n    for (int y = 0; y < HeightNum; ++y)\n    {\n        for (int x = 0; x < WidthNum; ++x)\n        {\n            if (Search[x + y*WidthNum].x == 1)\n            {\n                int cost = GetCost(ivec2(x,y),goalpos);\n                if (cost < Mincost)\n                {\n                    Mincost = cost;\n                    MinIndex = ivec2(x,y);\n                }\n            }\n            else if (Search[x + y*WidthNum].x == 3)\n                Search[x + y*WidthNum].x = 2;\n        }\n    }\n    return MinIndex;\n}\n\nvoid astarSearch()\n{\n    if (Search[goalpos.x + goalpos.y*WidthNum].x > 0)\n        return;\n    ivec2 pos = GetNextPos();\n    DealNeighbors(pos);\n    SetPath(pos);\n}\n\nbool checkTimer(float time_assasin)\n{\n    if (lastTimer <= time_assasin)\n    {\n        lastTimer += TickTimer;\n        return true;\n    }\n    return false;\n}\n\nvoid Timer()\n{\n    if (checkTimer(0.))\n    {\n        Blocker[1*WidthNum + 3] = true;\n        Blocker[2*WidthNum + 4] = true;\n        Blocker[3*WidthNum + 3] = true;\n        UnlockPos(startpos,-1,ivec2(-1));\n    }\n    while (checkTimer(iTime))\n    {\n        astarSearch();\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    Timer();\n    // Output to screen\n    fragColor = grids(fragCoord);\n}","name":"Image","description":"","type":"image"}]}