{"ver":"0.1","info":{"id":"lscSz8","date":"1457579686","viewed":228,"name":"Procedural menger","username":"sagar_unityDev","description":"Implementing raymarch technique.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// as learned from the excellent tutorial by @uint9\n// http://9bitscience.blogspot.de/2013/07/raymarching-distance-fields_14.html\n// distance functions by iq\n\nconst int RM_STEPS = 64;\nconst float RM_TOLERANCE = 0.001;\nconst float FOCAL_LENGTH = 1.2;\nconst float NEAR = 0.01;\nconst float FAR = 50.0;\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y + 1.6;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(100.,0.1,0.1));\n  float db = sdBox(p.yzx,vec3(0.1,100.,0.1));\n  float dc = sdBox(p.zxy,vec3(0.1,0.1,100.));\n  return min(da,min(db,dc));\n}\n \n\nfloat sdf(vec3 p) {\n  float plane = sdPlane(p);\n  float d = sdBox(p, vec3(1.0));\n  //float d = sdBox(p, vec3(2.0));\n    \n   float s = 1.0;\n   for( int m=0; m<3; m++ )\n   {\n      \n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = min(r.x,r.y);\n      float db = min(r.y,r.z);\n      float dc = min(r.z,r.x);\n      float c = (max(da,max(db,dc))-1.0)/s;\n\n      d = max(d,c);\n   }\n  \t\n  \n  return min(d, plane);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tsdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n\t\tsdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n\t\tsdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))));\n}\n\nfloat getShadow(vec3 p0, vec3 p1, float k) {\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0 * RM_TOLERANCE;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0;\n\tfor(int i = 0; i < RM_STEPS; ++i)\n\t{\n\t\tfloat d = sdf(p0 + rd * t);\n\t\tif(d < RM_TOLERANCE)\n\t\t\treturn 0.0;\n\t\tf = min(f, k * d / t);\n\t\tt += d;\n\t\tif(t >= maxt)\n\t\t\tbreak;\n\t}\n\treturn f;\n}\n\nvoid raymarch(vec3 ro, vec3 rd, out int steps, out float t) {\n\tt = 0.0;\n    for(int j = 0; j < RM_STEPS; ++j) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if(d < RM_TOLERANCE) {\n         \tsteps = j;   \n            break;\n        }\n        t += d;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eye = vec3(0, 0.5, -5.0);\n    vec3 up = vec3(0, 1.0, 0);\n    vec3 right = vec3(1.0, 0, 0);\n\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.y = uv.y * iResolution.y/iResolution.x;\n    \n    vec3 ro = eye;\n    vec3 rd = normalize(cross(right, up) * FOCAL_LENGTH + right * uv.x + up * uv.y);\n\n    vec4 lightColor1 = vec4(0.8, 1.0, 1.0, 1.0);\n    vec3 lightPosition1 = vec3(\n        sin(iTime) * 2.0,\n        2.0,\n        cos(iTime) * 2.0\n    );\n    vec4 lightColor2 = vec4(1.0, 1.0, 0.8, 1.0);\n    vec3 lightPosition2 = vec3(\n        cos(iTime) * 2.0,\n        2.0,\n        sin(iTime) * 2.0\n    );\n    \n    vec4 ambientColor = vec4(vec3(0.4),1.0);\n    vec4 color = vec4(0.9); // Sky color\n    \n    // rotate camera\n\tmat3 rot = rotationXY( vec2( 0.0, mod(iTime, 6.3)) );\n\trd = rot * rd;\n\tro = rot * ro;  \n\n    float t = 0.0;\n    int i = 0;\n    raymarch(ro, rd, i , t);\n    \n    vec3 p;\n    if(t > NEAR && t < FAR) {\n    \tp = ro + rd * t;\n        vec3 lightDirection1 = normalize(lightPosition1 - p);\n        vec3 lightDirection2 = normalize(lightPosition2 - p);\n        \n    \tfloat lightIntensity1 = 0.0;\n        float lightIntensity2 = 0.0;\n    \tfloat shadow1 = getShadow(p, lightPosition1, 8.0);\n        float shadow2 = getShadow(p, lightPosition2, 8.0);\n        \n        if(shadow1 > 0.0) {\n            lightIntensity1 = clamp(\n                dot(getNormal(p), lightDirection1), 0.0, 1.0\n            ) * shadow1;\n        }\n        if(shadow2 > 0.0) {\n            lightIntensity2 = clamp(\n                dot(getNormal(p), lightDirection2), 0.0, 1.0\n            ) * shadow2;\n        }\n        \n        color = smoothstep(\n            vec4(0.0),\n            vec4(1.8),\n            lightColor1 * lightIntensity1 +\n           \tlightColor2 * lightIntensity2 +\n           \tambientColor * (1.0 - lightIntensity1 * lightIntensity2));\n    }\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}