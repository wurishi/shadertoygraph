{"ver":"0.1","info":{"id":"WtlXD7","date":"1563226182","viewed":413,"name":"[twitch] Through the Bars","username":"NuSan","description":"Shader coded live on youtube:\nhttps://www.youtube.com/watch?v=zakmqumh8Rc\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ThroughTheBars.glsl","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadow","volumetriclighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on youtube:\nhttps://www.youtube.com/watch?v=zakmqumh8Rc\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ThroughTheBars.glsl\n(yes I still put [twitch] as a generic tag for live streaming ...)\n*/\n\n#define time iTime\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat donut(vec3 p, float r1, float r2) {\n  \n  return length(vec2(length(p.xy)-r1,p.z))-r2;\n  //return max(abs(length(p.xy)-r1)-r2,abs(p.z)-r2*0.5);\n  \n}\n\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\n\nfloat chain(vec3 p) {\n  \n  vec3 p2 = p-vec3(0,1.5,0);\n  p.y = rep(p.y,0.6);\n  p2.y = rep(p2.y,0.6);\n  float d = donut(p, 0.2,0.05);\n  d = min(d, donut(p2.zyx, 0.2,0.05));\n  \n  return d;\n}\n\nfloat map(vec3 p) {\n  \n  float d = 10000.0;//length(p-vec3(0,-1.5,-1.5))-0.8;\n  \n  // floor\n  d = min(d, -box(p-vec3(0,-2.5,0), vec3(10,4,10)));\n  \n  d = min(d, grid(p));\n    \n  // kifs for chains\n  for(int i=0; i<4; ++i) {    \n    float t=0.7 + float(i)*13.742;\n    p.xy *= rot(t);    \n    p.yz *= rot(0.2);\n    p.xy=abs(p.xy);\n    p.x-=1.7;\n  }\n  p.x = rep(p.x, 1.4);\n  \n  //p.z -= 1;\n  \n  d = min(d, chain(p));\n  \n  p.z += 1.0;\n  \n  \n  return d;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n// unused in the final shader\nvec3 volumetric(vec3 p) {\n  \n  vec2 uv = p.xz * 0.5;\n  \n  vec3 col = vec3(0);\n  vec2 grid = smoothstep(0.31,0.3,abs(fract(uv)-0.5));\n  vec2 cell = floor(uv);\n  col += min(grid.x, grid.y);\n  col *= vec3(rnd(cell),rnd(cell+72.23),rnd(cell+14.37));\n  \n  col *= curve(time*4.0 + rnd(cell)*98.62);\n  \n  col *= pow(clamp((p.y+1.0)*0.5,0.0,1.0),2.0);\n  \n  return col;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(sin(time*0.4)*0.4+0.2);\n  p.xz *= rot(sin(time*0.13)*1.3);\n  \n}\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n    p += l*d;\n    dd+= d;\n  }\n  return shad;\n}\n\nfloat getao(vec3 p, vec3 n, float d) {\n  return clamp(map(p+n*d)/d,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float rand=rnd(uv);\n\n  vec3 s=vec3(0,0,-5);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 lightpos = vec3(2,-1.0,0);\n  float t1 = time + curve(time*0.2)*12.7;\n  lightpos.yz *= rot(sin(t1*0.7)*0.7);\n  lightpos.xz *= rot(sin(t1*1.3)*0.7-1.5);  \n  \n  // main raymarch  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 100.0;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) break;\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n  }\n  \n  // volumetric raymarching\n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  for(int i=0; i<volsteps; ++i) {\n    if(stepdist>dd) {\n      break;\n    }\n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = shadow(lp, lv, ldistvol, 20, 0.01);\n    atcol += 0.3/(0.05+(ldistvol*ldistvol)) * shadvol;\n    //atcol += volumetric(lp)*0.1;\n    lp+=lr;\n    stepdist+=stepsize;\n  }\n  \n  float fog = 1.0-clamp(dd/maxdist,0.0,1.0);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(lightpos - p);\n  vec3 h=normalize(l-r);\n  float spec = max(dot(n,h),0.0);\n  float ldist = length(lightpos - p);\n  float fade = 1.0/(ldist*ldist);\n  \n  float shad = shadow(p + n * 0.2, l, ldist, 30, 0.01);\n  \n  vec3 col=vec3(0);\n  col += max(dot(n,l),0.0) * (1.7 + 5.0*pow(spec,5.0) + 10.0 * pow(spec,20.0)) * fog * fade * shad;\n  //col += pow(1-abs(dot(n,r)), 5) * fog * fade * shad;\n  \n  float ao = getao(p,n, 0.1) * getao(p,n, 0.4) * getao(p,n, 1.0) * (0.5 + 0.5 * getao(p,n, 2.0));\n  col += ao * 0.05;\n  \n  //col += volumetric(p);\n  \n  col += atcol;\n  //col += pow(at*0.12,4);\n  \n  //col *= 1.2-length(uv);\n  col = pow(col, vec3(0.4545));\n  col *= 1.2-length(uv);\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}