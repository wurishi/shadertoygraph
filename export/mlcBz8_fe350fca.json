{"ver":"0.1","info":{"id":"mlcBz8","date":"1700931398","viewed":33,"name":"Simple menger sponge","username":"darkfox","description":"menger sponge.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["menger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ユニフォーム\nuniform vec2 u_resolution;\nuniform float u_count;\n// 定数\nconst float pi = 3.14159;\nconst float TAU = atan(1.0) * 8.0;\nconst float eps = 0.00001;\nconst vec3 ex = vec3(1.0, 0.0, 0.0);\nconst vec3 ey = vec3(0.0, 1.0, 0.0);\nconst vec3 ez = vec3(0.0, 0.0, 1.0);\n\nconst vec3 khaki = vec3(0.94, 0.90, 0.55);\n\n// ベクトル取得関数\nvec2 fromAngle(float t){ return vec2(cos(t), sin(t)); }\n// 回転\nvoid rotX(out vec3 p, float theta){\n  p.yz *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\nvoid rotY(out vec3 p, float theta){\n  p.zx *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\nvoid rotZ(out vec3 p, float theta){\n  p.xy *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n// 普通の立方体\nfloat cube(vec3 p, float size){\n  p = abs(p) - size;\n  return max(max(p.x, p.y), p.z);\n}\n\n// 距離\nvec4 dist(vec3 p){\n  rotY(p, pi * iTime*0.3);\n  rotZ(p, pi * iTime*0.18);\n  vec3 col = khaki;\n// メンガースポンジやってみる\n  float ITERATION = floor(mod(iTime, 5.0));\n  for(int i = 0; i < 8; i++){\n    if(float(i) == ITERATION){ break; }\n    p = abs(p);\n    p.xy -= min(0.0, p.x - p.y) * vec2(1.0, -1.0);\n    p.xz -= min(0.0, p.x - p.z) * vec2(1.0, -1.0);\n    p.yz -= min(0.0, p.y - p.z) * vec2(1.0, -1.0);\n    p.z = 1.0 / 3.0 - abs(1.0 / 3.0 - p.z);\n    p.xy -= 2.0 / 3.0;\n    p *= 3.0;\n  }\n// できたらしい。丁寧にやった。\n  float t = cube(p, 1.0) / pow(3.0, ITERATION);\n  return vec4(col, t);\n}\n// レイマーチング\nvec4 march(vec3 eye, vec3 ray){\n  const float threshold = 0.001;\n  const float far = 20.0;  // 視認できる限界\n  const int limit = 64;\n  vec3 col = vec3(0.0);\n  float t = 0.0;\n  float d;\n  vec3 p = eye;\n  for(int i = 0; i < limit; i++){\n    col = dist(p).xyz;\n    d = dist(p).w;\n    if(d < threshold || d > far){ break; }\n    p += d * ray;\n    t += d;\n  }\n  if(d < threshold){ return vec4(col, t); }\n  return vec4(col, -1.0);\n}\n// 法線取得\nvec3 getNormal(vec3 pos){\n  float dx = dist(pos + eps * ex).w - dist(pos - eps * ex).w;\n  float dy = dist(pos + eps * ey).w - dist(pos - eps * ey).w;\n  float dz = dist(pos + eps * ez).w - dist(pos - eps * ez).w;\n  return normalize(vec3(dx, dy, dz));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 p = (fragCoord.xy*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 eye = vec3(0.0, 0.0, 5.0);\n  float d = 2.0;\n  vec3 ray = normalize(vec3(p, d) - eye);\t\n  vec3 light = normalize(vec3(1.0));\n  vec4 data = march(eye, ray);\n  float t = data.w;\n  vec3 col = vec3(0.0);\n  if(t > 0.0){ col = data.xyz; }\n  vec3 pos = eye + t * ray;\n  vec3 n = getNormal(pos);\n  col *= clamp(dot(n, light), 0.2, 1.0);\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}