{"ver":"0.1","info":{"id":"WttSzn","date":"1580291549","viewed":293,"name":"Psychedelic Spheres","username":"kstyler","description":"Practicing phong shading by making spheres that morph together with other spheres.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["phong","raymarch","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAXD = 400;\nconst float EPSI  =0.0001;\nint matId = 0;\nmat2 rotate(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat sm( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p,float size){\n    return length(p)-size;\n}\n\nfloat map(vec3 p,bool id){\n    float smo = 2.;\n    float sphere = sdSphere(p,1.);\n    float sphere2 = sdSphere(p+vec3(sin(iTime)*2.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere3 = sdSphere(p+vec3(sin(iTime)*2.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere4 = sdSphere(p+vec3(sin(iTime)*2.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere5 = sdSphere(p+vec3(sin(iTime)*2.,cos(iTime)*4.,cos(iTime)*4.),0.4);\n    float sphere6 = sdSphere(p+vec3(cos(iTime)*4.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere7 = sdSphere(p+vec3(cos(iTime)*4.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere8 = sdSphere(p+vec3(cos(iTime)*4.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere9 = sdSphere(p+vec3(sin(iTime)*4.,sin(iTime)*4.,sin(iTime)*4.),0.4);\n    float sphere10 = sdSphere(p-vec3(sin(iTime)*2.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere11 = sdSphere(p-vec3(sin(iTime)*2.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere12 = sdSphere(p-vec3(sin(iTime)*2.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere13 = sdSphere(p-vec3(sin(iTime)*2.,cos(iTime)*4.,cos(iTime)*4.),0.4);\n    float sphere14 = sdSphere(p-vec3(cos(iTime)*4.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere15 = sdSphere(p-vec3(cos(iTime)*4.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere16 = sdSphere(p-vec3(cos(iTime)*4.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere17 = sdSphere(p-vec3(sin(iTime)*4.,sin(iTime)*4.,sin(iTime)*4.),0.4);\n    \n\n    float plane =1.-(length(p)-550.);\n    float sp = sm(sphere9,sm(sphere8,sm(sphere7,sm(sphere6,sm(sphere5,sm(sphere4,sm(sphere3,sm(sphere2,min(sphere,plane),smo),smo),smo),smo),smo),smo),smo),smo);\n    float sp2 = sm(sphere17,sm(sphere16,sm(sphere15,sm(sphere14,sm(sphere13,sm(sphere12,sm(sphere11,sm(sphere10,min(sphere,plane),smo),smo),smo),smo),smo),smo),smo),smo);\n    float mn = min(sp,sp2);\n    if(id){\n       \n        if(mn == plane){\n            matId = 3;\n        }\n        else{\n            matId = 2;\n        }\n    }\n    return  mn;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(EPSI,0);\n    return normalize(vec3(map(p+e.xyy,false)-map(p-e.xyy,false),\n                            map(p+e.yxy,false)-map(p-e.yxy,false),\n                            map(p+e.yyx,false)-map(p-e.yyx,false)));\n}\nvec3 rayMarch(vec3 ro,vec3 rd, bool id){\n    \n    float tot = 0.;\n    float dst = 0.;\n    vec3 p;\n    for(int i = 0; i<MAXD; i++){\n        p = ro+rd*tot;\n        dst = map(p,id);\n        tot+=dst;\n        if(dst<EPSI || tot > float(MAXD)){\n            break;\n        }\n    }\n    if(dst > EPSI){\n       // matId = 1;\n    }\n    return p;\n}\nvec3 light(vec3 p,vec3 ro){\n    vec3 lightCol = vec3(1);\n    vec3 objCol = vec3(0);\n    vec3 lightPos = vec3(10,10,12);\n    vec3 viewDir = normalize(ro-p);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normal(p);\n    vec3 reflectDir = reflect(-l,n);\n    float diff = max(dot(l,n),0.);\n    float spec = pow(max(dot(viewDir,reflectDir),0.),25.);\n    float spcStr = 3.;    \n    float ambi = 0.45;\n    \n\n    \n    bool rm = length(rayMarch(p+n*EPSI*2.,l,false))<length(lightPos-p);\n    if(rm){\n        diff *= 0.1;\n    }\n    if(matId == 2){\n        objCol = vec3(1,0.9,0.);\n    }\n    \n    else if(matId == 3){\n    \n        objCol = vec3(0,0,0);\n    }\n    vec3 diffuse = lightCol*diff;\n    vec3 ambient = ambi*lightCol;    \n    vec3 specular = spcStr*spec*lightCol;\n    return (ambient+diffuse+specular)*objCol;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-0.5 * iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0,0,-20);\n    vec3 rd = normalize(vec3(uv,1.));\n    ro.zy*=rotate(iTime*2.);\n    rd.zy*=rotate(iTime*2.);\n    ro.xz*=rotate(iTime);\n    rd.xz*=rotate(iTime);\n    \n    vec3 p = rayMarch(ro,rd,true);\n    vec3 color = (light(p,ro));\n    if(matId == 1){\n        color = vec3(0);\n    }\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}