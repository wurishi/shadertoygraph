{"ver":"0.1","info":{"id":"McSGRd","date":"1705575041","viewed":84,"name":"3d boids simulation","username":"Mimka","description":"boids in 3d","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","flocking","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat sdSphere(vec3 p, float rad)\n{\n   return length(p) - rad;// distance to a sphere with the radious 1\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);// mix is an interpolation but for vectors\n}\n\nfloat dist(vec3 p, vec3 ro, vec3 rd)\n{\n    float result = 99999999.0f;\n    float numAround = 10.0;\n    float len = length(p); // p is the so far extended vector\n    \n    for (int i = 0; float(i) < numAround; i++)\n    {\n        vec3 rotatedDir = normalize(rd);\n\n        // Rotate the casting direction (rd) around the origin\n        rotatedDir.yz *= rotate2d(float(i) * 3.14159 * 2.0 / numAround);\n        \n        // i do not know why but I need to sutract the rorated vector\n        vec3 toSubtract = rd ;\n        toSubtract.yz*=rotate2d(float(i) * 3.14159 * 2.0 / numAround);\n\n        // Evaluate the distance function using the rotated direction; toSubtract is needed because we move when the offset is equal to the distance from the origin to the shape\n        float oct = sdOctahedron(ro + (len) * rotatedDir - toSubtract  , 1.0);\n        result = min(result, oct);\n    }\n\n    return result;\n}\n\nfloat distBoids(vec3 p)\n{\n    // use random positions to spawn boids\n    float result = 99999999.0f;\n    for(int i = 0; i<38; i++)\n    {\n       vec2 uv = vec2(float(i)/iResolution.x, 230.0f/iResolution.y);\n       vec3 pos = texture(iChannel0, uv).rgb; \n       float sph = sdSphere(p - pos*2.0 + vec3(0.0,0.0,3.0), 0.03);\n       result = min(result, sph);\n    }\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1) and put the center in the middle\n    vec2 uv = fragCoord/iResolution.xy*2.0f - 1.0f;\n    uv.x*=(iResolution.x/iResolution.y);\n    \n    // mouse\n     vec2 mouse = iMouse.xy/iResolution.xy*2.0f - 1.0f;// can be scaled for sensitivity\n    \n    // initialization \n    vec3 rayOrigin = vec3(0.0,0.0,-3.0);\n    // also uv * 1.5 makes the field of view bigger\n    vec3 rayDirection = normalize(vec3(uv * 1.5, 1.0));// this will spread the vectors from the origin to each point on the screen\n    \n    // rotate the coordinates vertically\n    rayOrigin.yz *= rotate2d(-mouse.y);\n    rayDirection.yz *= rotate2d(-mouse.y);\n    \n    // rotate the coordinates horizontally\n    rayOrigin.xz *= rotate2d(-mouse.x);\n    rayDirection.xz *= rotate2d(-mouse.x);\n    \n    vec3 finalColor = vec3(0);// final pixel color\n    \n    float totalDistance = 0.0;// total distance travelled\n    for(int i = 0; i < 80; i++)\n    {\n        vec3 positionAlongRay = rayOrigin + rayDirection*totalDistance; // distance traveled along the ray\n        float distToObject = distBoids( positionAlongRay );\n        totalDistance += distToObject;// steps along the ray by the safe distance to travel\n        if(distToObject<0.001 || distToObject>100.0)// early stop if close enough \n        {\n            break;\n        }\n        \n        \n    }// it is calculted for the current closest object\n    finalColor = vec3(totalDistance * 0.1);\n    \n    vec2 uvv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uvv).rgb;\n\n    //col += vec3(1, 0, 0);\n\n    // Output to screen\n    //fragColor = vec4(col, 1.0);\n\n    \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// this shader will be needed to begin the random assignment of the positions\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n     \n    \n    if(iFrame>0)\n    {\n        fragColor = vec4(vec3(0.0),1.0);\n        \n        // position stuff\n        \n        if(fragCoord.x<800.0 && int(fragCoord.y)==200)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),230);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.g, colComp.g,colComp.g),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.g, col.g,col.g),1.0);\n            }\n        }\n        if(fragCoord.x<800.0 && int(fragCoord.y)==201)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),230);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.r, colComp.r,colComp.r),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.r, col.r,col.r),1.0);\n            }\n        }\n        if(fragCoord.x<800.0 && int(fragCoord.y)==199)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),230);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.b, colComp.b,colComp.b),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.b, col.b,col.b),1.0);\n            }\n        }\n        \n        \n        // velocity stuff\n        if(fragCoord.x<800.0 && int(fragCoord.y)==100)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),130);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.g, colComp.g,colComp.g),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.g, col.g,col.g),1.0);\n            }\n        }\n        if(fragCoord.x<800.0 && int(fragCoord.y)==101)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),130);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.r, colComp.r,colComp.r),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.r, col.r,col.r),1.0);\n            }\n        }\n        if(fragCoord.x<800.0 && int(fragCoord.y)==99)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),130);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.b, colComp.b,colComp.b),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.b, col.b,col.b),1.0);\n            }\n        }\n        \n        // acceleration stuff stuff\n        if(fragCoord.x<800.0 && int(fragCoord.y)==300)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),330);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.g, colComp.g,colComp.g),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.g, col.g,col.g),1.0);\n            }\n        }\n        if(fragCoord.x<800.0 && int(fragCoord.y)==301)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),330);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.r, colComp.r,colComp.r),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.r, col.r,col.r),1.0);\n            }\n        }\n        if(fragCoord.x<800.0 && int(fragCoord.y)==299)\n        {\n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            \n            ivec2 toCompare =  ivec2(int(fragCoord.x),330);\n            vec3 colComp = fetchData(iChannel0, toCompare).rgb;\n            \n            if(!compare(col, colComp, 0.001))\n            {\n                fragColor = vec4(vec3(colComp.b, colComp.b,colComp.b),1.0);\n            }\n            else\n            {\n                fragColor = vec4(vec3(col.b, col.b,col.b),1.0);\n            }\n        }\n        \n    }\n    else\n    {\n        vec3 randPixelVal = vec3(rand(fragCoord));\n        fragColor = vec4(randPixelVal, 1.0);\n    }\n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// so far this shader creates pseudo random 3d vectors, and writes it in a texture(do to it it uses the A buffer)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n        fragColor = vec4(vec3(0.0),1.0f);\n        \n        // y = 200 - position\n        if(fragCoord.x<800.0 && int(fragCoord.y)==200)\n        {\n            \n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            vec3 colUpper = fetchData(iChannel0, ivec2(intCoord.x, intCoord.y+1)).rgb;\n            vec3 colLowwer = fetchData(iChannel0, ivec2(intCoord.x, intCoord.y-1)).rgb;\n            fragColor = vec4(vec3(colUpper.r,col.r,colLowwer.r),1.0);\n        }\n       \n        \n        // y = 100 - velocity\n        if(fragCoord.x<800.0 && int(fragCoord.y)==100)\n        {\n            \n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            vec3 colUpper = fetchData(iChannel0, ivec2(intCoord.x, intCoord.y+1)).rgb;\n            vec3 colLowwer = fetchData(iChannel0, ivec2(intCoord.x, intCoord.y-1)).rgb;\n            fragColor = vec4(vec3(colUpper.r,col.r,colLowwer.r),1.0);\n        }\n        \n        \n        // y = 300 - acceleration\n        if(fragCoord.x<800.0 && int(fragCoord.y)==300)\n        {\n            \n            ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n            vec3 col = fetchData(iChannel0, intCoord).rgb;\n            vec3 colUpper = fetchData(iChannel0, ivec2(intCoord.x, intCoord.y+1)).rgb;\n            vec3 colLowwer = fetchData(iChannel0, ivec2(intCoord.x, intCoord.y-1)).rgb;\n            fragColor = vec4(vec3(colUpper.r,col.r,colLowwer.r),1.0);\n        }\n       \n        \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec3 align(int nb, vec2 fragCoord)\n{\n    // avarage velocity\n    if(fragCoord.x<=float(nb))\n    {\n       vec3 steering = vec3(0.0);\n       int numBoids = nb;\n       float perception = 1.5;\n       float total = 0.0f;\n       vec3 myPos = fetchData(iChannel0, ivec2(int(fragCoord.x), 200)).rgb;\n       for(int i = 0; i < numBoids; i++)\n       {\n           \n           vec3 posOther = fetchData(iChannel0, ivec2(i, 200)).rgb;\n           \n           if(i!=int(fragCoord.x) && distance(myPos,posOther )< perception)\n           {\n               vec3 Vel = fetchData(iChannel0, ivec2(i, 100)).rgb;\n               steering+=Vel;\n               total+=1.0;\n           }\n       }\n       if(total > 0.0)\n       {\n           steering/=float(total);\n           //steering*=0.01;\n           steering*=5.0;\n           vec3 myVel = fetchData(iChannel0, ivec2(int(fragCoord.x), 100)).rgb;\n           vec3 difVec = steering - myVel;\n           steering = difVec * 0.3 ;\n       }\n       return steering;\n      }\n      return vec3(0.0);\n}\n\nvec3 cohesion(int nb, vec2 fragCoord)\n{\n    // avarage velocity\n    if(fragCoord.x<=float(nb))\n    {\n       vec3 steering = vec3(0.0);\n       int numBoids = nb;\n       float perception = 1.5;\n       float total = 0.0f;\n       vec3 myPos = fetchData(iChannel0, ivec2(int(fragCoord.x), 200)).rgb;\n       for(int i = 0; i < numBoids; i++)\n       {\n           \n           vec3 posOther = fetchData(iChannel0, ivec2(i, 200)).rgb;\n           \n           if(i!=int(fragCoord.x) && distance(myPos,posOther )< perception)\n           {\n               \n               steering+=posOther;\n               total+=1.0;\n           }\n       }\n       if(total > 0.0)\n       {\n           steering/=float(total);\n           steering = steering - myPos;\n           steering*=5.0;\n           vec3 myVel = fetchData(iChannel0, ivec2(int(fragCoord.x), 100)).rgb;\n           vec3 difVec = steering - myVel ;\n           steering = difVec * 0.3 ;\n       }\n       return steering;\n      }\n      return vec3(0.0);\n}\n\nvec3 separation(int nb, vec2 fragCoord)\n{\n    // avarage velocity\n    if(fragCoord.x<=float(nb))\n    {\n       vec3 steering = vec3(0.0);\n       int numBoids = nb;\n       float perception = 0.5;\n       float total = 0.0f;\n       vec3 myPos = fetchData(iChannel0, ivec2(int(fragCoord.x), 200)).rgb;\n       for(int i = 0; i < numBoids; i++)\n       {\n           \n           vec3 posOther = fetchData(iChannel0, ivec2(i, 200)).rgb;\n           \n           if(i!=int(fragCoord.x) && distance(myPos,posOther )< perception)\n           {\n               vec3 opDir = myPos - posOther;\n               opDir *= 1.0/distance(myPos,posOther );\n               steering+=opDir;\n               total+=1.0;\n           }\n       }\n       if(total > 0.0)\n       {\n           steering/=float(total);\n           steering*=6.0;\n           vec3 myVel = fetchData(iChannel0, ivec2(int(fragCoord.x), 100)).rgb;\n           vec3 difVec = steering - myVel ;\n           steering = difVec * 0.3 ;\n       }\n       return steering;\n      }\n      return vec3(0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uvv).rgb;\n    \n    // first we make the pixel of the same color as on the texture\n    fragColor = vec4(col, 1.0);\n    \n    // 230 - changing line for position\n    if(fragCoord.x<800.0 && int(fragCoord.y)==230)\n    {\n       ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n       \n       vec3 colCurr = fetchData(iChannel0, intCoord).rgb;\n       vec3 colLower = fetchData(iChannel0, ivec2(intCoord.x, 200)).rgb;\n       \n       \n       \n       vec3 myVel = fetchData(iChannel0, ivec2(intCoord.x, 100)).rgb;\n       vec3 moved = mod(colLower + myVel*0.003,5.0);\n      \n       \n       fragColor = vec4(moved, 1.0);\n       \n    }\n    \n    // 130 - changing line for velocity\n    if(fragCoord.x<800.0 && int(fragCoord.y)==130)\n    {\n       ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n       \n       vec3 colCurr = fetchData(iChannel0, intCoord).rgb;\n       vec3 colLower = fetchData(iChannel0, ivec2(intCoord.x, 100)).rgb;\n       \n       vec3 myAcc = fetchData(iChannel0, ivec2(intCoord.x, 300)).rgb;\n       colLower =  normalize(colLower + myAcc);\n       fragColor = vec4(colLower, 2.0);\n       \n    }\n    \n    // 330 - changing line for acceleration\n    if(fragCoord.x<800.0 && int(fragCoord.y)==330)\n    {\n       ivec2 intCoord =  ivec2(int(fragCoord.x),int(fragCoord.y));\n       \n       vec3 colCurr = fetchData(iChannel0, intCoord).rgb;\n       vec3 colLower = fetchData(iChannel0, ivec2(intCoord.x, 300)).rgb;\n       \n       vec3 flockForce =  cohesion(38, fragCoord) + align(38, fragCoord) + separation(38, fragCoord);\n       \n       fragColor = vec4(flockForce, 1.0);\n       \n    }\n\n    \n    \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// generates a pseudo random noise to be used later as a texture\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nbool compare(vec3 a, vec3 b, float diff)\n{\n    if(abs(a.x-b.x)<diff && abs(a.y-b.y)<diff && abs(a.z-b.z)<diff)\n    {\n        return true;\n    }\n    return false;\n}\n\n","name":"Common","description":"","type":"common"}]}