{"ver":"0.1","info":{"id":"McjGRt","date":"1704539068","viewed":38,"name":"Simple NTSC codec w/ alpha","username":"cabfiel","description":"it supports transparency now. why? why not!\nleft = rgb\nright = alpha","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["ntsc"],"hasliked":0,"parentid":"NsVcRt","parentname":"Simple NTSC codec"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple NTSC codec\n// Change Buffer A to whatever you want\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    if(uv.x > iMouse.x / iResolution.x)\n        fragColor = vec4(vec3(col.w),1.);\n    else\n        fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Encoder or Modulator\n// This pass converts RGB colors on iChannel0 to\n// a YIQ (NTSC) Composite signal.\n\n#define PI   3.14159265358979323846\n#define TAU  6.28318530717958647693\n\nconst mat3 rgb_to_yiq = mat3(0.299, 0.596, 0.211,\n                             0.587,-0.274,-0.523,\n                             0.114,-0.322, 0.312);\n\n// Alternative RGB to YIQ matrix\n// const mat3 rgb_to_yiq = mat3(0.299, 0.587, 0.114,\n//                              0.596,-0.274,-0.322,\n//                              0.211,-0.523, 0.312);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Chroma encoder oscillator frequency \n    float fc = iResolution.x;\n    \n    // Base oscillator angle for this dot\n    float t = float(fragCoord.x);\n    \n    vec4 px = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    vec3 rgb = px.rgb;\n\n    // Convert to YIQ\n    vec3 yiq = rgb_to_yiq * rgb;\n    \n    // Final oscillator angle\n    float f = fc * t;\n    \n    // Modulate IQ signals\n    float i = yiq.y * cos(f), // I signal\n          q = yiq.z * sin(f); // Q signal\n    \n    // Add to Y to get the composite signal\n    float c = yiq.x + (i + q); // Composite\n    \n    // Return a grayscale representation of the signal\n    fragColor = vec4(vec3(c), px.w);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Decoder or Demodulator\n// This pass takes the Composite signal generated on Buffer B\n// and decodes it\n\n#define PI   3.14159265358979323846\n#define TAU  6.28318530717958647693\n\n#define BRIGHTNESS_FACTOR        10.0\n\n// The decoded IQ signals get multiplied by this\n// factor. Bigger values yield more color saturation\n#define CHROMA_SATURATION_FACTOR 7.0\n\n// Size of the decoding FIR filter. bigger values\n// yield more smuggly video and are more expensive\n#define CHROMA_DECODER_FIR_SIZE  20\n#define LUMA_DECODER_FIR_SIZE  10\n\n// YIQ to RGB matrix\nconst mat3 yiq_to_rgb = mat3(1.000, 1.000, 1.000,\n                             0.956,-0.272,-1.106,\n                             0.621,-0.647, 1.703);\n\nfloat blackman(float n, float N) {\n    float a0 = (1.0 - 0.16) / 2.0;\n    float a1 = 1.0 / 2.0;\n    float a2 = 0.16 / 2.0;\n    \n    return a0 - (a1 * cos((2.0 * PI * n) / N)) + (a2 * cos((4.0 * PI * n) / N)) * 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Chroma decoder oscillator frequency\n    float fc = iResolution.x;\n    \n    float counter = 0.0;\n    \n    // Sum and decode NTSC samples\n    // This is essentially a simple averaging filter\n    // that happens to be weighted by two cos and sin\n    // oscillators at a very specific frequency\n    float alpha = texture(iChannel0, fragCoord / iResolution.xy).w;\n    vec3 yiq;\n    \n    // Decode Luma first\n    for (int d = 0; d < LUMA_DECODER_FIR_SIZE; d++) {\n        vec2 pos = vec2(fragCoord.x + float(d) - float(LUMA_DECODER_FIR_SIZE / 2), fragCoord.y);\n\n        vec3 s = texture(iChannel0, pos / iResolution.xy).rgb;\n\n        float t = fc * (fragCoord.x + float(d));\n        \n        // Apply Blackman window for smoother colors\n        float window = blackman(float(d), float(LUMA_DECODER_FIR_SIZE)); \n\n        yiq += s * vec3(BRIGHTNESS_FACTOR, 0.0, 0.0) * window;\n\n        //counter++;\n    }\n    \n    // Then decode chroma\n    for (int d = -CHROMA_DECODER_FIR_SIZE; d < CHROMA_DECODER_FIR_SIZE; d++) {\n        vec2 pos = vec2(fragCoord.x + float(d), fragCoord.y);\n\n        vec3 s = texture(iChannel0, pos / iResolution.xy).rgb;\n\n        float t = fc * (fragCoord.x + float(d));\n        \n        // Apply Blackman window for smoother colors\n        float window = blackman(float(d + CHROMA_DECODER_FIR_SIZE), float(CHROMA_DECODER_FIR_SIZE * 2 + 1)); \n\n        yiq += s * vec3(0.0, cos(t), sin(t)) * window;\n\n        counter++;\n    }\n\n    yiq /= counter;\n\n    // Saturate chroma (IQ)\n    yiq.yz *= CHROMA_SATURATION_FACTOR;\n\n    fragColor = vec4((yiq_to_rgb * yiq), alpha);\n}","name":"Buffer C","description":"","type":"buffer"}]}