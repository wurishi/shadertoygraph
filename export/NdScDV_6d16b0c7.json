{"ver":"0.1","info":{"id":"NdScDV","date":"1644177298","viewed":103,"name":"Ray Tracing - Spheres","username":"tucna","description":"Demonstration of the ray tracing.\n\nThe same using ray marching - https://www.shadertoy.com/view/fsjyzK","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 20.0\n#define SPHERE_RADIUS 0.5\n#define EPSILON 0.001\n\n// To simplify normal computation\n#define S1_CENTER vec3(-1.1, SPHERE_RADIUS, 4)\n#define S2_CENTER vec3( 0.0, SPHERE_RADIUS + 1.0, 3)\n#define S3_CENTER vec3( 1.1, SPHERE_RADIUS, 5)\n\nfloat DistanceToPlane(vec3 origin, vec3 direction)\n{\n    float dist = MAX_DIST + EPSILON;\n    vec3 n = vec3(0.0, 1.0, 0.0); // plane is XY thus the normal is pointing up\n    vec3 p = vec3(0.0, 0.0, 0.0); // point on the plane\n    \n    float denom = dot(n, direction);\n    if (abs(denom) > EPSILON)\n    {\n        float t = dot(p - origin, n) / denom;\n        if (t > 0.0)\n            dist = t;\n    }\n    \n    return dist;\n}\n\nfloat DistanceToSphere(vec3 origin, vec3 direction, vec3 center)\n{\n    /* \n        Equations\n        ---------\n        a = dot(B, B)\n        b = 2 ⋅ dot(B, A − C)\n        c = dot(A − C, A − C) − r2\n        \n        where A = origin; C = s1.xyz\n        \n        discriminant = b^2 - 4ac\n        \n        if discriminant > 0 then intersection\n    */\n    \n    // Sphere\n    vec3 rayCenter = origin - center;\n    float a = dot(direction, direction);\n    float b = 2.0 * dot(direction, rayCenter);    \n    float c = dot(rayCenter, rayCenter) - SPHERE_RADIUS * SPHERE_RADIUS;\n    \n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        return MAX_DIST + EPSILON; // intersection in the MAX distance a.k. no intersection\n    }\n    else\n    {\n        float dist = (-b - sqrt(discriminant)) / (2.0 * a);\n        \n        if (dist > EPSILON)\n            return dist;\n            \n        dist = (-b + sqrt(discriminant)) / (2.0 * a);\n        \n        if (dist > EPSILON)\n            return dist;   \n            \n        return MAX_DIST + EPSILON;\n    }\n}\n\nvec2 Closer(vec2 o1, vec2 o2)\n{\n    if (o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\nvec2 RayTrace(vec3 origin, vec3 direction)\n{\n\tconst vec4 s1 = vec4(S1_CENTER, SPHERE_RADIUS);\n\tconst vec4 s2 = vec4(S2_CENTER, SPHERE_RADIUS);\n    const vec4 s3 = vec4(S3_CENTER, SPHERE_RADIUS);\n            \n    // Spheres    \n    float t1 = DistanceToSphere(origin, direction, s1.xyz);\n    float t2 = DistanceToSphere(origin, direction, s2.xyz);\n    float t3 = DistanceToSphere(origin, direction, s3.xyz);\n    \n    // Plane\n    float t4 = DistanceToPlane(origin, direction);\n        \n    vec2 distAndObj = vec2(MAX_DIST, -1);\n        \n    distAndObj = Closer(distAndObj, vec2(t1, 1.0));\n    distAndObj = Closer(distAndObj, vec2(t2, 2.0));\n    distAndObj = Closer(distAndObj, vec2(t3, 3.0));\n    \n    distAndObj = Closer(distAndObj, vec2(t4, 0.0));\n    \n    if (distAndObj.x > MAX_DIST)\n        distAndObj.y = -1.0;\n   \n    return distAndObj;    \n}\n\nvec3 ApplyLight(vec3 albedo, vec3 normal, vec3 point)\n{    \n    vec3 sunDir = normalize(vec3(0.8, 0.4, -0.2));\n    \n    float sunDiffuse = clamp(dot(normal, sunDir), 0.0, 1.0);\n    float skyDiffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float bouncedDiffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n    \n    float d = RayTrace(point + normal * 0.01, sunDir).x;\n    float sunShadow = d < MAX_DIST ? 0.1 : 1.0;\n        \n    vec3 light = vec3(7.0, 4.5, 3.0) * sunDiffuse * sunShadow;\n    light += vec3(0.5, 0.8, 0.9) * skyDiffuse; // sky is blue\n    light += vec3(0.7, 0.3, 0.2) * bouncedDiffuse; // bounced is yellow from sun\n    \n    vec3 color = albedo * light;\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center UV\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = vec3(0.0, 1.0, 0.0); // position of the camera\n    vec3 rayDirection = normalize(vec3(uv, 1.0)); // shoot ray forward (left hand)\n\n    vec2 depthAndObject = RayTrace(rayOrigin, rayDirection);\n    vec3 point = rayOrigin + rayDirection * depthAndObject.x;\n        \n    // Sky\n    vec3 color = vec3(0.4, 0.75, 1.0) - 0.7 * uv.y;\n    color = mix(color, vec3(0.7, 0.75, 0.8), exp(-10.0 * uv.y)); // color on the horizont\n\n    if (depthAndObject.y == 0.0) // floor\n    {    \n        vec3 albedo = vec3(0.18, 0.18, 0.18);\n        vec3 normal = normalize(vec3(0.0, 1.0, 0.0));\n        color = ApplyLight(albedo, normal, point);\n    }\n    else if (depthAndObject.y == 1.0) // sphere 1\n    {\n        vec3 albedo = vec3(0.18,0.05,0.1);\n        vec3 normal = normalize(point - S1_CENTER);\n        color = ApplyLight(albedo, normal, point);\n    }\n    else if (depthAndObject.y == 2.0) // sphere 2\n    {\n        vec3 albedo = vec3(0.05,0.18,0.1);\n        vec3 normal = normalize(point - S2_CENTER);\n        color = ApplyLight(albedo, normal, point);\n    }\n    else if (depthAndObject.y == 3.0) // sphere 3\n    {\n        vec3 albedo = vec3(0.05,0.1,0.18);\n        vec3 normal = normalize(point - S3_CENTER);\n        color = ApplyLight(albedo, normal, point);\n    }\n    \n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Taken from https://www.shadertoy.com/view/3lGBDm\n// Exclusively for debug print\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n/*\n    // Output to screen       \n    if(iMouse.x > 0.0)\n\t{    \n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-52.0, 6.0);\n        vec2 vFontSize = vec2(8.0, 15.0);\n\t\tfloat fValue2 = iMouse.x / iResolution.x;\n\t\tfloat fDigits = 1.0;\n\t\tfloat fDecimalPlaces = 3.0;        \n\t\tfloat fIsDigit2 = PrintValue( (fragCoord - vPixelCoord2) / vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tcolor = mix( color, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = iMouse.y / iResolution.y;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue( (fragCoord - vPixelCoord3) / vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tcolor = mix( color, vec3(0.0, 1.0, 0.0), fIsDigit3);\n        \n        // Print \"d\"\n        vec2 mouseXY = iMouse.xy;\n        vec2 debugUV = (mouseXY - 0.5 * iResolution.xy) / iResolution.y;\n\n\t\tvec2 vPixelCoord4 = iMouse.xy + vec2(0.0, 30.0);\n        vec3 rO = vec3(0.0, 1.0, 0.0); // position of the camera\n        vec3 rD = normalize(vec3(debugUV, 1.0)); // shoot ray forward (left hand)\n\n        vec2 dAo = RayTrace(rO, rD);\n        vec3 p = rO + rD * dAo.x;\n        \n        vec3 a = vec3(0.18,0.05,0.1);\n        vec3 n = normalize(p - S1_CENTER);\n        float fValue4 = ApplyLight(a, n, p).w;        \n\n        float fIsDigit4 = PrintValue( (fragCoord - vPixelCoord4) / vFontSize, fValue4, fDigits, fDecimalPlaces);\n\t\tcolor = mix( color, vec3(0.0, 1.0, 0.0), fIsDigit4);        \n\t}\n*/    \n","name":"Common","description":"","type":"common"}]}