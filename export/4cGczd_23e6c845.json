{"ver":"0.1","info":{"id":"4cGczd","date":"1732220547","viewed":31,"name":"Uitvinding van het Wiel","username":"Mirtheamvm","description":"Uitvinding van het Wiel (~3500 v.Chr.)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["wiel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader for \"Invention of the Wheel\" with metallic and earthy tones representing the robustness and innovation of the wheel.\n\n// User parameters\nuniform float tech_input;      // Technology input for sigmoid function\n\n#define AA 2  // Set AA to 1 if your machine is too slow\n#define METHOD 3\n\n// Sigmoid function for technology growth\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// Function to compute the quaternion constant c based on the \"Invention of the Wheel\"\nvec4 computeC(float time) {\n    float health;\n    float freedom;\n    float interconnectivity;\n    float tech_factor = sigmoid(tech_input);\n\n    // CARE values for the \"Invention of the Wheel\"\n    if (time < 0.33) {  // Early phase\n        health = 4.0;\n        freedom = 5.0;\n        interconnectivity = 3.0;\n    } else if (time < 0.66) {  // Acceleration phase\n        health = 6.0;\n        freedom = 7.0;\n        interconnectivity = 6.0;\n    } else {  // Maturity phase\n        health = 7.0;\n        freedom = 8.0;\n        interconnectivity = 7.0;\n    }\n\n    // Normalize the CARE values and compute the quaternion constant\n    return vec4(\n        (5.0 + min(health, 8.5)) / 10.0 * (5.0 + min(freedom, 8.5)) / 10.0 * (5.0 + min(interconnectivity, 8.5)) / 10.0 * tech_factor,\n        0.8 * (5.0 + health) / 10.0 * sin(time * 0.7),\n        0.8 * (5.0 + freedom) / 10.0 * cos(time * 0.5),\n        0.8 * (5.0 + interconnectivity) / 10.0\n    );\n}\n\nvec4 qsqr(in vec4 a) {\n    return vec4(\n        a.x * a.x - a.y * a.y - a.z * a.z - a.w * a.w,\n        2.0 * a.x * a.y,\n        2.0 * a.x * a.z,\n        2.0 * a.x * a.w\n    );\n}\n\nconst int numIterations = 500; // Higher number of iterations for better detail\n\n// Function to map the fractal and limit bailout-radius to avoid disappearing\nfloat map(in vec3 p, out vec4 oTrap, in vec4 c, out float iteration) {\n    vec4 z = vec4(p, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    oTrap = vec4(abs(z.xyz), dot(z, z));\n\n    iteration = 0.0;\n    for (int i = 0; i < numIterations; i++) {\n        md2 *= 4.0 * mz2;\n        z = qsqr(z) + c;\n\n        // Add some noise for organic deformation\n        z.xyz += 0.3 * sin(6.0 * z.xyz + iTime * 0.05);\n\n        // Orbit trap to enhance visual detail\n        oTrap = min(oTrap, vec4(abs(z.xyz), dot(z, z)));\n        mz2 = dot(z, z);\n        iteration += 1.0;\n\n        // Increase the bailout threshold significantly to ensure the fractal never disappears\n        if (mz2 > 500.0) break;  // Significantly increased bailout threshold\n    }\n\n    // Return a smaller scaling factor to prevent it from vanishing\n    return 0.05 * sqrt(mz2 / md2) * log(mz2);  // Further reduced scaling factor from 0.25 to 0.05\n}\n\n// Function to get colors representing the wheel: metallic and earthy tones\nvec3 getWheelColor(float health, float freedom, float interconnectivity) {\n    float totalCARE = (health + freedom + interconnectivity) / 3.0;\n\n    // Define wheel-related colors\n    vec3 gray = vec3(0.5, 0.5, 0.5);  // Light gray (RAL 7040)\n    vec3 brown = vec3(0.47, 0.27, 0.23);  // Earthy brown (RAL 8007)\n    vec3 graphite = vec3(0.2, 0.2, 0.2);  // Dark gray (RAL 7024)\n    vec3 gold = vec3(1.0, 0.85, 0.3);  // Golden for innovation (RAL 1036)\n\n    // Gradual transitions between wheel-inspired colors\n    if (totalCARE <= 5.0) {\n        return mix(gray, brown, totalCARE / 5.0);  // Transition from gray to brown\n    }\n    if (totalCARE <= 6.0) {\n        return mix(brown, graphite, (totalCARE - 5.0));  // Transition from brown to graphite\n    }\n    if (totalCARE <= 7.0) {\n        return mix(graphite, gold, (totalCARE - 6.0));  // Transition from graphite to gold\n    }\n    return gold;  // Golden for the highest CARE values\n}\n\n// Function to adjust color based on the CARE-scores using wheel colors\nvec3 getColor(float iteration, float maxIteration, vec4 oTrap, float health, float freedom, float interconnectivity) {\n    float t = iteration / maxIteration;\n\n    // Get wheel-based color depending on CARE values\n    vec3 baseColor = getWheelColor(health, freedom, interconnectivity);\n    \n    // Add orbit trap influence to color for more visual complexity\n    baseColor += 0.2 * vec3(oTrap.x, oTrap.y, oTrap.z) * (1.0 - t);\n    return baseColor;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in vec4 c, out vec4 res, out float iteration) {\n    vec4 tmp;\n    float resT = -1.0;\n    float maxd = 25.0;  // Increased maximum distance\n    float h = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 500; i++) {\n        if (h < 0.0001 || t > maxd) break;\n        h = map(ro + rd * t, tmp, c, iteration);\n        t += h;\n    }\n    if (t < maxd) {\n        resT = t;\n        res = tmp;\n    }\n    return resT;\n}\n\n// Function to render the fractal and ensure it remains visible\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c, float health, float freedom, float interconnectivity) {\n    const vec3 sun = vec3(0.577, 0.577, 0.577);\n\n    vec4 tra;\n    float iteration;\n    float t = intersect(ro, rd, c, tra, iteration);\n\n    vec3 col;\n    if (t < 0.0) {\n        // Background gradient with a crÃ¨me color\n        col = vec3(0.94, 0.87, 0.78) * (0.7 + 0.3 * rd.y); // Beige background\n    } else {\n        vec3 mate = vec3(0.8, 0.0, 0.0) * 0.3;\n        vec3 pos = ro + t * rd;\n        vec3 nor = normalize(pos);  // Normal approximation\n\n        // Get color based on iteration count and orbit trap using wheel colors\n        col = getColor(iteration, float(numIterations), tra, health, freedom, interconnectivity);\n\n        // Add some subsurface scattering effect for an organic feel\n        float subsurface = clamp(dot(rd, nor) + 0.5, 0.0, 1.0);\n         col += mate * 0.4 * subsurface;\n\n    // Sun lighting\n    vec3 lig = sun;\n    float dif = clamp(dot(lig, nor), 0.0, 1.0);\n    col += mate * vec3(1.00, 0.85, 0.60) * dif;\n\n    // Soft shadows for a more organic look\n    float shadow = 0.8 + 0.2 * cos(t + iTime * 0.05);\n    col *= shadow;\n\n    // Add variation in brightness for more depth\n    col *= 0.8 + 0.2 * sin(iTime * 0.05 + iteration);\n}\n\nreturn pow(col, vec3(0.4545));  // Gamma correction for realistic brightness\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Parameters for animation\n    float time = iTime * 0.0025;  // Slower movement for a calmer effect\n    vec4 c = computeC(time);\n\n    // Set up the camera\n    float r = 3.0;  // Adjust zoom level here\n    vec3 ro = vec3(r * cos(0.3 + 0.37 * time), 0.3 + 0.8 * r * cos(1.0 + 0.33 * time), r * cos(2.2 + 0.31 * time));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    float cr = 0.1 * cos(0.1 * time);\n\n    // Compute camera direction vectors\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    // Ray direction\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec3 rd = normalize(p.x * cu + p.y * cv + 2.0 * cw);\n\n    // CARE parameters for the \"Invention of the Wheel\"\n    float health, freedom, interconnectivity;\n    if (time < 0.33) {\n        // Early phase\n        health = 4.0;\n        freedom = 5.0;\n        interconnectivity = 3.0;\n    } else if (time < 0.66) {\n        // Acceleration phase\n        health = 6.0;\n        freedom = 7.0;\n        interconnectivity = 6.0;\n    } else {\n        // Maturity phase\n        health = 7.0;\n        freedom = 8.0;\n        interconnectivity = 7.0;\n    }\n\n    // Render the scene with wheel-based color scheme\n    vec3 col = render(ro, rd, c, health, freedom, interconnectivity);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}