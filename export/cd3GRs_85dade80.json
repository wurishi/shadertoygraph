{"ver":"0.1","info":{"id":"cd3GRs","date":"1681452709","viewed":82,"name":"Perlin noise terrain","username":"Sergio_2357","description":"Perlin noise terrain\nClick the screen to see a pseudo-random island (right-up corner is bigger)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["generative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuint hash(uint s) {\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nfloat Fade(float t) {\n\treturn smoothstep(0.0, 1.0, t);\n}\n\nfloat Lerp(float t, float a, float b) {\n    return a + t*(b-a);\n}\n\nfloat randVal(uint x, uint y) {\n    uint rand = hash(x^y)^hash(x)^hash(y);\n    float fv = float(rand%1000000u)/1000000.0;\n    return fv;\n    /*int h = int(rand)%4;\n    if(h == 0)\n\t\treturn vec2(1.0, 1.0);\n\telse if(h == 1)\n\t\treturn vec2(-1.0, 1.0);\n\telse if(h == 2)\n\t\treturn vec2(-1.0, -1.0);\n\telse\n\t\treturn vec2(1.0, -1.0);*/\n}\n\nfloat perlinNoise(vec2 p) {\n    int xl = int(floor(p.x));\n    int xh = int(ceil(p.x));\n    int yl = int(floor(p.y));\n    int yh = int(ceil(p.y));\n    /*float v1 = dot(randVec(uint(xl), uint(yl)), p-vec2(xl, yl))*0.5+0.5;\n    float v2 = dot(randVec(uint(xh), uint(yl)), p-vec2(xh, yl))*0.5+0.5;\n    float v3 = dot(randVec(uint(xl), uint(yh)), p-vec2(xl, yh))*0.5+0.5;\n    float v4 = dot(randVec(uint(xh), uint(yh)), p-vec2(xh, yh))*0.5+0.5;*/\n    float v1 = randVal(uint(xl), uint(yl));\n    float v2 = randVal(uint(xh), uint(yl));\n    float v3 = randVal(uint(xl), uint(yh));\n    float v4 = randVal(uint(xh), uint(yh));\n    float xf = p.x-floor(p.x);\n    float yf = p.y-floor(p.y);\n    float u = Fade(xf);\n    float v = Fade(yf);\n    return Lerp(v, \n            Lerp(u, v1, v2),\n            Lerp(u, v3, v4));\n}\n\nmat2 rt = mat2(0.7071067, -0.7071067, 0.7071067, 0.7071067);\n\nfloat rotatedPerlinNoise(vec2 p) {\n    return (perlinNoise(p)+perlinNoise(p*rt+vec2(1000.0, 1000.0)))/2.0;\n}\n\nfloat fractalPerlinNoise(vec2 p) {\n    int steps = 3;\n    float val = rotatedPerlinNoise(p);\n    float sig = 0.4;\n    float sigmlt = 0.4;\n    float scale = 2.0;\n    float scalemlt = 2.0;\n    for (int i = 0; i < steps; i++) {\n        val = val*(1.0-sig)+sig*rotatedPerlinNoise(p*scale);\n        sig *= sigmlt;\n        scale *= scalemlt;\n    }\n    return val;\n}\n\nvec4 colFromGreyscale(float f) {\n    if (f > 0.8) return vec4(1.0, 1.0, 1.0, 1.0);\n    if (f > 0.7) return vec4(0.58, 0.36, 0.0, 1.0);\n    if (f > 0.5) return vec4(0.098, 0.498, 0.039, 1.0);\n    if (f > 0.3) return vec4(0.165, 0.863, 0.059, 1.0);\n    if (f > 0.25) return vec4(0.918, 0.941, 0.141, 1.0);\n    return vec4(0.141, 0.675, 0.941, 1.0);\n    vec4 col0 = vec4(0.7, 0.0, 0.0, 1.0);\n    vec4 col1 = vec4(1.3, 1.0, 0.0, 1.0);\n    vec4 res = col0*f+(1.0-f)*col1;\n    return res;\n}\n\nvec2 mousePs;\n\nvec2 pixelToSpace(vec2 p) {\n    p.x *= 10.0;\n    p.y *= 5.0;\n    p += mousePs*1.0;\n    p += vec2(35.0, 35.0);\n    return p;\n}\n\nvoid animateMouse() {\n    vec2 minp = iResolution.xy*3.0/4.0;\n    vec2 maxp = iResolution.xy;\n    mousePs = vec2(cos(iTime*0.009), sin(iTime*0.007))*(maxp-minp)+minp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mousePs = iMouse.xy;\n    if (iMouse.xy == vec2(0.0))\n        animateMouse();\n    \n    vec2 cp = uv-vec2(0.5, 0.5);\n    float dst = sqrt(cp.x*cp.x+cp.y*cp.y)/0.707;\n    dst = 1.0-dst;\n    dst *= sqrt(mousePs.x*mousePs.x+mousePs.y*mousePs.y)/sqrt(iResolution.x*iResolution.x+iResolution.y*iResolution.y)*1.5;\n    \n    uv = pixelToSpace(uv);\n    \n    float ht = fractalPerlinNoise(uv)*dst;\n\n    fragColor = colFromGreyscale(ht);\n}","name":"Image","description":"","type":"image"}]}