{"ver":"0.1","info":{"id":"Ml3SR8","date":"1478034154","viewed":229,"name":"SpaceShip from ValleyRace","username":"kuvkar","description":"closer look at the ship model that I used in ValleyRace https://www.shadertoy.com/view/MlKGWK  \nUse mouse for manual control.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ufo","valleyrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n Ship model that I used in https://www.shadertoy.com/view/MlKGWK\n*/\n\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\nconst float PI = 3.14159265358;\nconst float PI2 = 3.14159265358 * 0.5;\nconst float TWO_PI = 3.14159265358 * 2.0;\n\n\n// from IQ: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// from IQ: https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// plane looks down negative z axis. Orientation is controlled by rotation matrix.\nfloat traceQuad(in vec3 ro, in vec3 rd, in vec3 pp, in vec2 sizeXY, in mat3 rt, in vec3 pivot )\n{\n    pp += rt * pivot;\n    vec3 pn = rt * vec3(0.0, .0, -1.00);\n    float a = dot(pp - ro, pn);\n    float b = dot(rd, pn);\n    float t = a / b;\n    if (t < 0.0) return t;\n    vec3 hitp = ro + rd * t;\n    hitp = transpose(rt) * (hitp - pp); // to get to local coordinates\n    if(abs(hitp.x) > sizeXY.x) return -1.;\n    if(abs(hitp.y) > sizeXY.y) return -1.;\n\treturn t;\n}\n\n// just a small helper function for bounding box tracing\nfloat pmin(float m1, float m2)\n{\n    if (m1 >= 0.0 && m2 >= 0.0) { return min(m1, m2); } \n    return (m1 >= 0.0 && m2 < 0.0) ? m1 : m2;\n}\n\n// 6 quad checks\n// returns ray enter and exit hitpoints.\n// I'm using this as a bounding box to speedup the tracing process.\nvec2 traceBox(in vec3 ro, in vec3 rd, in vec3 bp, in vec3 size, in mat3 rt)\n{\n    vec4 piv = vec4(size, 0.0);\n    float f0 = traceQuad(ro, rd, bp, size.xy, rt, piv.wwz);\n\tfloat f1 = traceQuad(ro, rd, bp, size.xy * 1., rt, -piv.wwz);\n\tfloat f2 = traceQuad(ro, rd, bp, size.zy, rt * roty(PI2), piv.wwx);\n\tfloat f3 = traceQuad(ro, rd, bp, size.zy, rt * roty(PI2), -piv.wwx);\n\tfloat f4 = traceQuad(ro, rd, bp, size.xz, rt * rotx(PI2), -piv.wwy);\n    float f5 = traceQuad(ro, rd, bp, size.xz, rt * rotx(PI2), piv.wwy);\n        \n    float m = pmin(f0, f1); m = pmin(m, f2); m = pmin(m, f3); m = pmin(m, f4); m = pmin(m, f5);\n    if (m < 0.0) return vec2(m);\n    \n    vec2 ret = vec2(m, 1.0);\n    if (f0 > 0. && f0 != ret.x) ret.y = f0;\n    else if (f1 > 0. && f1 != ret.x) ret.y = f1;\n    else if (f2 > 0. && f2 != ret.x) ret.y = f2;\n    else if (f3 > 0. && f3 != ret.x) ret.y = f3;\n    else if (f4 > 0. && f4 != ret.x) ret.y = f4;\n    else if (f5 > 0. && f5 != ret.x) ret.y = f5;\n        \n    return ret;\n}\n\n// repeats space angularly.\nvec2 repeatPolarAngle(in vec2 ar, float angle)\n{\t\n    ar.x = mod(ar.x, angle);\n    vec2 p = vec2(cos(ar.x), sin(ar.x)) * ar.y;\n    return p;\n}\n\n// to polar coordinates\nvec2 polar(in vec2 p)\n{\n    return vec2(atan(p.y, p.x), length(p));\n}\n\n// ship shape slices\nconst float slice = PI * 0.15;\n\nvec2 g_rp_polar = vec2(0.0);\nvec3 g_shipPos = vec3(0.0);\nmat3 g_shipRotation = mat3(1.0);\nvec3 g_hitp_local = vec3(0.0);\nvec2 g_uv = vec2(0.0);\nvec3 lightDir = normalize(vec3(.0, 1.6, -1.0));\nfloat g_camT = 0.0; \nfloat g_shipT = 0.0;\nvec3 g_hitp = vec3(0.0);\n\n////////////////\n// ship model\n// basicly a box in a space that's repeated by angle\n//////////////////\nfloat map(in vec3 _rp)\n{\n    _rp -= g_shipPos;\n    _rp = _rp * g_shipRotation;\n//    _rp = _rp * g_model_correction;\n    g_rp_polar = polar(_rp.xz);\n    g_hitp_local = _rp;\n    \n    // ship shape is made by repeating the space in pie-shape fashion\n    vec2 rp_polar_real = polar(_rp.xz);\n\tvec2 rp_polar = abs(rp_polar_real);\n    \n    _rp.xz = repeatPolarAngle(rp_polar, slice);\n    \n    float m = sdBox( _rp, vec3(0.05, 0.0035, 0.05) * 4.0);\n    float m3 = sdBox((_rp + vec3(-0.15, -0.015, 0.)), vec3(0.005, 0.015, 0.012) * vec3(6.0, 4.0, 10.0));\n    \n    // 2 boxes mixed gives nicer shape\n\tm = mix(m, m3, 0.1);\n    // mixing with a sphere for a rounded shape\n    m = mix(m, length(_rp - vec3(0.0, 0.05, 0.)) - .2, 0.2);\n\treturn m;\n}\n\n// gradient\nvec3 grad(in vec3 rp, float sharpness)\n{\n    vec2 off = vec2(sharpness, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n\nfloat g_rayExitDistance; // distance for exitting the bounding box of ship\n\n// a bit hacky function to get the shading that I wanted.\nfloat lobe(float d, float wrap)\n{\n    d = d + wrap / (1.0 + wrap);\n    d /= sqrt(d);\n    return d;\n}\n\nbool traceShip(in vec3 ro, in vec3 rp, in vec3 rd, inout vec4 outColor)\n{\n    bool hit = false;\n    rp += rd * .3;\n    float dist = 0.0;\n    float fi = 0.0;\n    float closest = 999.0;\n    vec3 closestPos = vec3(0.0);\n    \n    for (int i = 0; i < 95; ++i)\n    {\n        fi = float(i);\n        dist = map(rp);\n        if (dist < closest)\n        {\n           closest = dist;\n           closestPos = rp;\n        }\n        \n        if(dist <= 0.00005)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * .35, 0.001);\n        float l = length(ro - rp);\n        if (l > g_rayExitDistance) break;\n    }\n    \n    // early out if not close enough to edge\n    // few iterations for better quality if surface was penetrated a lot.\n\t\n    for (int i = 0; i < 23; ++i)\n    {\n        rp += sign(dist) * max(abs(dist), 0.000001) * rd;\n        dist = map(rp) * 0.05;\n        if (abs(dist) < 0.00001) break;\n    }\n    \n    //hit = hit || dist < 0.0;\n    float rayLength = length(ro - rp);\n    \n    // anti-aliasing the outer edges.\n    float AA = dFdx(g_uv.x) * 2.;\n    \n    if(!hit) rp = closestPos;\n    \n    // depth test\n\tif (outColor.a < rayLength) return false;\n    ////////////////////////////////////////////////\n    //////////// UFO texturing and shading  ///////\n    ///////////////////////////////////////////////\n    \n    float X = (PI * 0.05 + PI + g_rp_polar.x) / (2.0 * PI);\n    float b = PI / slice * 4.0;\n    X = floor(X * b);\n    bool glass = false;\n    \n    vec4 albedo = (vec4(100,200,250, 0.0) / 256.0) * 0.9;\n\n    vec4 color = vec4(0.0);\n\tfloat roughness = 0.15;\n    float worness = 3.0;\n    float refl = 0.05;\n    \n    if (g_hitp_local.y > 0.0 && g_hitp_local.y < 0.025 && (X == 0.0 || X == 1.0 || X == 27.0 || X == 26.0))\n    {\n        albedo.rgb = vec3(.9, .9, .9);\n        glass = true;\n    }\n    \n       \n    vec3 yellow = vec3(.7, 0.2, 0.0);        \n    if (g_hitp_local.y <= -0.01) albedo.rgb = vec3(.1, .1, .0);\n    \n    else if (g_hitp_local.y <= 0.006) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x - 2.8) <= 0.02) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x + 2.8) <= 0.02) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x - .42) <= 0.08) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x + .42) <= 0.08) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x + .0) <= 0.08)  albedo.rgb = yellow;\n\n    bool engine = (X >= 12.0 && X <= 15.0);\n    if (g_hitp_local.y > -0.01 && g_hitp_local.y < 0.005 && engine)\n    {\n        color.rgb += (vec3(.85) + 0.35 * sin(abs(iTime * 40.0) )) ;\n    }\n\n    vec3 g = grad(rp, 0.001);\n\n    // Bump\n    if(!glass)\n    {\n        vec2 bmpUv = g_hitp_local.xz;\n        \n        vec3 bump = roughness * texture(iChannel2, bmpUv * 5.5).rgb;\n        \n        float bm = 75.0;\n        float damage = sin(bmpUv.y * bm * 0.6) * sin(bmpUv.x * bm) * 0.5;\n        damage += sin(bmpUv.y * bm * 0.3) * sin(bmpUv.x * bm * 0.3);\n        \n        damage = clamp(damage, 0.0, 1.0);\n        roughness += worness * roughness * damage;\n        bump += roughness * texture(iChannel2, g_hitp_local.yz * 5.5).rgb;\n        albedo = mix(albedo, vec4(0.6, 0.2, 0.0, .0), roughness * .8);\n        g = g + bump * 1.;\n        g = normalize(g);\n    }\n\n    float d = dot(g, lightDir);\n    d = clamp(d, 0.0, 1.0);\n    d = lobe(d, 0.2);\n    color += albedo * d;\n\t\n    // spec\n    float sp = glass ? 13.0 : 40.0;\n    vec3 H = normalize(-rd + lightDir);\n    float Sd = dot(H, g);\n    Sd = clamp(Sd, 0.001, 1.0);\n    Sd = lobe(Sd, 0.);\n    Sd = pow(Sd, sp) * 1.2;\n\t\n    vec3 envColor = texture(iChannel3, reflect(rd, g)).rgb;\n    color.rgb += glass ? 0.7 * envColor : envColor * max(0.0, (1.0 - roughness)) * refl;\n    \n    // fres\n    float SCL = 4.; \n    float PWR = 10.0;\n    \n    float Fd = dot(rd, g);\n    Fd = min(1.0, 1.0 + Fd) * 0.5;\n    Fd = lobe(Fd, 0.25);\n    \n    float F = SCL * pow(Fd, PWR);\n    vec3 FCol = vec3(0.1, 0.1, 0.1);\n\tcolor.rgb = mix(color.rgb, FCol, min(F, 1.0) );\n    \n    color += vec4(Sd);\n    \n    float colMix = smoothstep(AA, 0.0, closest);\n    outColor = mix(outColor, color, colMix);\n    outColor.a = rayLength;\n    g_hitp = rp;\n    return hit;\n}\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n// \nbool doShip(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    vec2 hitBox = traceBox(ro, rd, g_shipPos + vec3(0.0, 0.01, 0.0), vec3(0.24, 0.05, 0.21), g_shipRotation);\n    if (hitBox.x <= 0.) return false;\n    \n    // bug fix to where 2 seams meet\n    g_rayExitDistance = max (hitBox.y, 2.5);\n    \n    bool hit = traceShip(ro, rp, rd, color);\n    return hit;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_shipRotation = rotx(0.0);\n    g_shipPos = vec3(0.0, 0.0, 0.0);\n    \n    fragColor = vec4(0.01);\n    fragColor.a = 9999.0;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    g_uv = uv;\n\tuv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, .0, -.8);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    im -= vec2(0.5);\n    vec3 lkat = g_shipPos;\n    if(iMouse.z > 0.0)\n    {\n        rp = roty(-im.x * 8.0) * rp;\n        rp.y = im.y * 5.0;\n\n    }else\n    {\n        rp.y = sin(iTime * 0.5);\n        rp.x = cos(iTime * 0.5);\n    }\n    \n    \n\trd = normalize(lookat(rp,lkat) * rd);    \n    \n    fragColor.rgb = texture(iChannel3, rd * vec3(1.0, -1.0, 1.0)).rgb;\n    doShip(rp, rd, fragColor);\n    // contrast\n    fragColor = mix(fragColor, smoothstep(0.0, 1.0, fragColor), 0.6);\n    fragColor = sqrt(fragColor);\n    \n}","name":"Image","description":"","type":"image"}]}