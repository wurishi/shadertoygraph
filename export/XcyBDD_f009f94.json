{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float MAX_DIST=20.;\nconst float CAMD=4.;\nconst int RECT_LIMIT=50;\nconst int RECT_ARR=50;\n\n#define v vec3\n\nbool genn=false;\nfloat ha,va=.1;\nint hcount;\nstruct FVV3{\n  float f;\n  v c;\n  v v_;\n  float e;\n};\n\nstruct RECT{\n  v a;\n  v b;\n  v c;\n  v d;\n  v n;\n  v col;\n  float e;\n};\n\nRECT[RECT_ARR]rects;\n\nRECT vr(v sp,float w,float h,v c,float e){\n  return RECT(sp,sp+v(w,0.,0),sp+v(w,0.,h),sp+v(0,0.,h),v(0,1,0),c,e);\n}\nRECT hr(v sp,float w,float d,v c,float e){\n  return RECT(sp,sp+v(w,0,0),sp+v(w,d,0),sp+v(0,d,0),v(0,0,1),c,e);\n}\nRECT lr(v sp,float d,float h,v c,float e){\n  return RECT(sp,sp+v(0,d,0),sp+v(0,d,h),sp+v(0,0,h),v(1,0,0),c,e);\n}\nRECT rr(v sp,float d,float h,v c,float e){\n  return RECT(sp,sp+v(0,d,0),sp+v(0,d,h),sp+v(0,0,h),v(-1,0,0),c,e);\n}\n\nvoid gen(){\n  if(genn){\n    return;\n  }\n  genn=true;\n  for(int i=0;i<RECT_LIMIT;i++){\n    rects[i]=hr(v(-1,-1,.01),2.,2.,v(.1),.2);\n  }\n  rects[0]=hr(v(-3,-3,.01),6.,4.,v(.12),.6);\n  rects[1]=hr(v(0),.3,-.4,v(1),-1.);\n  rects[2]=vr(v(-1,.06,0),1.7,-5.,v(.3),.4);\n  rects[3]=vr(v(-1,.05,-.4),1.7,-.1,v(0.,.78,1.),1.);\n  rects[4]=vr(v(.2,.05,-.05),.2,-.3,v(.1843),.4);\n  rects[5]=hr(v(-.3,-.7,0),.4,-.4,v(1),-1.);\n  rects[6]=vr(v(-.8,.05,-.05),.9,-.3,v(.8),-1.);\n  rects[7]=lr(v(-1,.06,0),.4,-5.,v(.1),.4);\n  rects[8]=rr(v(.7,.06,0),.4,-5.,v(.1),.4);\n  hcount=9;\n  v c = v(.1843);\n\n  v vs=v(-.8,.05,-.55);\n  for(float r=0.;r<4.;r++){\n    for(float c=0.;c<5.;c++){\n      v ca =v(float(int((c +1.) * (r+.1) * 51212.3) % 25)/25., float(int((c +1.) * (r+1.) * 512312.3) % 26)/60., float(int((c +1.) * 512312.3) % 54)/60.);\n      rects[hcount]=vr(vs+v(c*.3,0,r*-.4),.2,-.3,c + ca, float(int((c +1.) * (r+.1) * 51212.3) % 25)/40.);\n      hcount++;\n    }\n  }\n  //rects[i]=hr(v(-1,-1,.01),2.,2.,v(.1),.2);\n}\n\nvoid car(){\n  if(cos(iTime)<0.){\n    return;\n  }\n  v o=v(5.*sin(iTime),-.6,0);\n  rects[hcount]=vr(o,.3,-.12,v(.3),.4);\n  rects[hcount+1]=vr(o+v(0,-.15,0),.3,-.12,v(.3),.4);\n  rects[hcount].n=-1.*rects[hcount].n;\n  rects[hcount+2]=hr(o+v(0,-.15,-.12),.3,.15,v(.3),.4);\n  \n  rects[hcount+3]=hr(o+v(0.,-.13,-.18),.2,.11,v(.3),.4);\n  rects[hcount+4]=RECT(o+v(0,-.15,-.12),\n  o+v(0,-.13,-.18),\n  o+v(.2,-.13,-.18),\n  o+v(.2,-.15,-.12),\n  v(0,1,0),v(.6),.4);\n  rects[hcount+5]=rr(o+v(0.3,-.15,0.),.15,-.12,v(.3),.4);\n  rects[hcount+6]=lr(o+v(0.,-.15,0.),.15,-.18,v(.3),.4);\n  ///(o+(v),o+v(w,0.,0),sp+v(w,0.,h),sp+v(0,0.,h),v(0,1,0),c,e);\n}\n\nbool isPointInRect(v p,v a,v b,v c,v d){\n  float c1=dot((b-a),(p-a));\n  float c2=dot((c-b),(p-b));\n  float c3=dot((a-b),(p-b));\n  float c4=dot((b-c),(p-c));\n  \n  return(c3>=0.)&&(c4>=0.)&&(c2>=0.)&&(c1>=0.);\n}\n\nfloat rect(v ro,v rd,v a,v b,v c,v d,v n){\n  float nl=-dot(ro-a,n);\n  if(nl<=0.){\n    return MAX_DIST;\n  }\n  float ang=dot(rd,n);\n  v p=ro+rd*nl/ang;\n  if(isPointInRect(p,a,b,c,d))return length(ro-p);\n  return MAX_DIST;\n}\nFVV3 rco(v ro,v rd){\n  v minv;\n  float mind=MAX_DIST;\n  v color;//  =  rd;\n  float emission;\n  FVV3 d;\n  \n  for(int pid=0;pid<RECT_LIMIT;pid++){\n    RECT r=rects[pid];\n    float d_=rect(ro,rd,r.a,r.b,r.c,r.d,r.n);\n    if(d_<mind){\n      mind=d_;\n      minv=r.n;\n      color=r.col;\n      emission=r.e;\n    }\n  }\n  //  color=v(emission);\n  if(emission<0.){\n    //color=v(.1);\n    \n    ro=ro+mind*rd;\n    rd=reflect(rd,-minv);\n    float mind2=MAX_DIST;\n    v color2=v(0);\n    float emission2=.0;\n    for(int pid=0;pid<RECT_LIMIT;pid++){\n      RECT r=rects[pid];\n      float d_=rect(ro,rd,r.a,r.b,r.c,r.d,r.n);\n      if(d_<mind2&&d_>.1){\n        mind2=d_;\n        minv=r.n;\n        color2=r.col;\n        emission2=r.e;\n      }\n    }\n    emission=emission2;\n    color=color2;//color * (emission + 1.) + (-emission) * color2;\n  }\n  d.v_=minv;\n  d.f=mind;\n  d.c=color;\n  d.e=emission;\n  return d;\n}\n\nmat3 camera(v e,v l){\n  v rl=v(0,0,1);\n  v f=normalize(l-e);\n  v r=normalize(cross(rl,f));\n  v u=normalize(cross(f,r));\n  \n  return mat3(r,u,f);\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{v col=v(.1);\n  if(genn){\n    col=v(.7);\n  }else{\n    gen();\n  }\n  car();\n  v offset=v(0);\n  vec2 uv=-(fragCoord-.5*iResolution.xy)/iResolution.y;\n  v ro=CAMD*normalize(v(0,-.6,-.1));\n  if(iMouse.z>0.){\n    ha=.01*iMouse.x;\n    va=.02*iMouse.y;\n    ro=CAMD*normalize(v(sin(ha),cos(ha),2.*sin(va)));\n  }\n  \n  v rd=normalize(camera(ro,v(0))*normalize(v(uv,2.)));\n  FVV3 rmr=rco(ro,rd);\n  float d=rmr.f;\n  if(d>=MAX_DIST){\n    float c=pow(10.,2.*dot(rd,v(rd.xy,0)))/100.;\n    \n    col=v(c*.57,c*.1,c*.65);\n    //col=normalize(ro)/2.+v(.5);\n  }else{\n    v p=ro+rd*d;\n    v normal=normalize(rmr.v_);\n    v lightPosition=v(5.*sin(iTime) + .3,1,-.2);\n    v lightDirection=normalize(lightPosition-p);\n    col=rmr.c*rmr.e;\n    if(cos(iTime)>0.){\n      col+=vec3(.6471,.5843,.4706)*dot(normal,lightDirection);\n    }\n  }\n  fragColor=vec4(col,1.);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcyBDD","date":"1734034230","viewed":67,"name":"cyberpunk","username":"rdinit","description":"3d scene with reflections","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""}}