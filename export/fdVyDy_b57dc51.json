{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define R iResolution\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    O = texture(iChannel0, I/R.xy)/2.;\n    O += texture(iChannel0, (I+vec2(1,0))/R.xy)/8.;\n    O += texture(iChannel0, (I-vec2(1,0))/R.xy)/8.;\n    O += texture(iChannel0, (I+vec2(0,1))/R.xy)/8.;\n    O += texture(iChannel0, (I-vec2(0,1))/R.xy)/8.;\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define W 14\n\n#define isIcon (!(iChannelResolution[1].y > 1.) || iChannelResolution[1].y < 350.)\nuint MRHI(uint l, uvec3 c){\n\n    return (\n    (((c.x)>>l) * 591558727u)^\n    (((c.y)>>l) * 1500450271u)^\n    (((c.z)>>l) * 3267000013u)^\n    (l        * 54218443u));\n}\n\n\n//Cubemap utils to convert between a 1024 x 1024 x 6 buffer coordinate to a cubemap ray direction\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\nint RayDirToInd(vec3 dir){\n    ivec3 XYFace = RayDirToXYFace(dir);\n    return XYFace.x + XYFace.y * 1024 + XYFace.z * 1024 * 1024;\n}\n\n\n//Functions to sample a particle coordinate from the cubemap as a 1024 x 6144 buffer and a 16384 x 384 buffer\n#define getters \\\nvec4 sampleIndex(int ind){\\\n    ivec3 XYFace = ivec3(ind%1024, (ind/1024)%1024, ind/(1024*1024));\\\n\treturn texture(iChannel0, XYFaceToRayDir(XYFace));\\\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dX3Rr"}],"inputs":[{"channel":0,"type":"cubemap","id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"getters\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int index = RayDirToInd(rayDir);\n    fragColor = sampleIndex(index)-0.0001;\n    \n    for(float m = 0.; m < 10.; m++){\n        float Time = float(iFrame)/60. + m/600.;\n        vec3 uv = vec3(cos(Time*3./2.2),sin(Time*5./2.1),cos(Time*7./2.));\n\n        float p = Time/1.33;\n        float y = Time/1.43;\n        \n        uv.yz = mat2(uv.yz,-uv.z,uv.y) * vec2(cos(p), sin(p));\n        \n        uv.xz = mat2(uv.xz,-uv.z,uv.x) * vec2(cos(y), sin(y));\n        uv = normalize(uv);\n        uv *= .6 + sin(Time)*.1;\n\n        for(uint i = 0u; i < uint(W); i++){\n           uint c = MRHI(i,uvec3(uv*(float(1<<W)/2.) + float(1<<W)/2.));     \n           if(int(c%(1024u*1024u*6u))==index){\n              fragColor=vec4(.75+.25*cos(vec3(2,3,4)*iTime),1);\n           }\n        }\n    }\n    if(iFrame<3){\n        fragColor = vec4(0);\n    }\n    \n}","name":"Cube A","description":"","type":"cubemap"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"cubemap","id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"getters\n\n#define R iResolution\n\n#define eps 1e-6\n\nvoid goThru(inout vec3 r0,inout uvec3 c, uint l, vec3 rd){\n    vec3 v0 =  1. - r0;\n    vec3 v1 = -1. - r0;\n    vec3 m0 = v0/rd;\n    vec3 m1 = v1/rd;\n    float b = 1e10;//10. + dot(abs(m0),vec3(1)) + dot(abs(m1),vec3(1));\n    m0 += b*vec3(lessThan(m0,vec3(eps)));\n    m1 += b*vec3(lessThan(m1,vec3(eps)));\n    vec3 m = min(m0,m1);\n    float lm = min(min(m.x,m.y),m.z);\n    \n    r0 += rd*lm;\n    \n    vec3 d = r0*vec3(greaterThan(abs(r0),vec3(1.-eps)));\n    \n    r0 -= 2.*d;\n    \n    if(dot(d,vec3(1))>0.){\n        c += uvec3(abs(d)*1.5)<<(l);\n    } else {\n        c -= uvec3(abs(d)*1.5)<<(l);\n    }\n    \n}\n\nvoid goUp(inout vec3 r0,inout uvec3 c, inout uint l, vec3 rd){\n    \n    vec3 r = r0;\n    vec3 d = r0*vec3(greaterThan(abs(r0),vec3(1.-eps)));\n    \n    vec3 t = vec3(greaterThan(c&(1u<<l),uvec3(0)));\n    \n    uint m = ~((2u<<l) - 1u);\n    \n    \n    r = -1. + t + (r+1.)/2.;\n    if(any(greaterThan(abs(r),vec3(1.-eps)))){\n        l++;\n        r0=r;\n        c &= m;\n    } else {\n        goThru(r0,c,l,rd);\n    }\n    \n}\nvoid goDown(inout vec3 r0,inout uvec3 c, inout uint l, vec3 rd){\n    vec3 cd = vec3(greaterThan(r0,vec3(0)));\n    l--;\n    c += uvec3(cd)<<l;\n    \n    if(abs(r0.x)>abs(r0.y) && abs(r0.x)>abs(r0.z)){\n        r0.yz = (fract(r0.yz)*2.-1.);\n    } else {\n        if(abs(r0.y)>abs(r0.z)){\n            r0.xz = (fract(r0.xz)*2.-1.);\n        } else {\n            r0.xy = (fract(r0.xy)*2.-1.);\n        }\n    }\n    \n    \n}\n\n\n\nvec4 march(vec3 r0,vec3 rd){\n    vec4 col = vec4(0);\n    vec3 r = r0;\n    \n    \n    vec3 a0 = abs(r0);\n    vec3 ad = abs(rd);// * a0/r0;\n    \n    vec3 v = a0 - 1.;\n    vec3 m = v/ad;\n    float lm = max(max(m.x,m.y),m.z);\n    r+=lm*rd;\n    a0 = abs(r);\n    if(a0.x>1. || a0.y >1. || a0.z > 1.){\n        a0 = abs(r+rd*1e-6);\n        if(a0.x>1. || a0.y >1. || a0.z > 1.){\n            return vec4(0); \n        }\n    }\n    \n\n    \n    uint l = uint(W);\n    uvec3 c = uvec3(0);\n    float y = 1.;\n    \n    goDown(r, c, l, rd);\n    goDown(r, c, l, rd);\n    \n    for(int n = 0; n < 100; n++){\n    \n        uint i = MRHI(l+1u,c);\n        vec4 s = sampleIndex(int(i%(1024u*1024u*6u)));\n        uvec3 cl = c; \n        if(s.w<.1  && l<uint(W-1)){\n            goUp(r, c, l, rd);\n        } else {\n        \n            i = MRHI(l,c);\n            vec4 sp = sampleIndex(int(i%(1024u*1024u*6u)));\n            \n            \n            if(sp.w<.1){\n                goThru(r, c, l, rd);\n            } else {\n                col += s*exp(-5.5+(float(W)-float(l))*.4)*y;\n                y*=.99;\n                goDown(r, c, l, rd);\n            }\n        }\n        //col += s*exp(3.-float(l)*.5);\n        if(any(bvec3(c & 0xfff00000u  ))) {\n            return col;\n        }\n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n\n        vec3 r0 = vec3((I-R.xy/2.)/R.y,1);\n        vec3 rd = vec3(0,0,-1);\n        \n        float p = 2.*(iMouse.y/R.y*2.-1.)*3.14/2. + iTime/23.45;\n        float y = 2.*(iMouse.x/R.x*2.-1.)*3.14 + iTime/14.;\n        \n        r0.yz = mat2(r0.yz,-r0.z,r0.y) * vec2(cos(p), sin(p));\n        rd.yz = mat2(rd.yz,-rd.z,rd.y) * vec2(cos(p), sin(p));\n        \n        r0.xz = mat2(r0.xz,-r0.z,r0.x) * vec2(cos(y), sin(y));\n        rd.xz = mat2(rd.xz,-rd.z,rd.x) * vec2(cos(y), sin(y));\n        \n        //r0 += .5;\n        rd /= length(rd);\n        r0 *= 2.;\n        O = march(r0,rd);\n        \n        //if(O.w>0.)\n        //   O = O/(pow(O.w,-.5)+O.w);\n    \n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"fdVyDy","date":"1655577483","viewed":203,"name":"Hash octree","username":"rory618","description":"Adaptation of \"Impossibly big canvas\" to 3D.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","hash","octree"],"hasliked":0,"parentid":"","parentname":""}}