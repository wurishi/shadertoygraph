{"ver":"0.1","info":{"id":"WsGyDW","date":"1602793174","viewed":146,"name":"Shader showdown@Assembly2020","username":"Exca","description":"Assembly 2020 shader showdown entry in the finals.\n\nNot exactly 100% as it looks in bonzomatic as no smoothed fft or continous fft exist.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["showdown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 getcam(vec3 cam, vec3 target ,vec2 uv, float fov)\n{\n  vec3 forward = normalize(target - cam);\n  vec3 right = normalize( cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward,right));\n  \n  return normalize(vec3(uv.x*right + uv.y*up + fov*forward));\n}\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod( p + 0.5*q,q)-0.5*q;\n}\n\nfloat U(float a, float b)\n{\n  \n  return min(a,b);\n}\n\nfloat C(float a, float b)\n{\n  return max(a,b);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p)-b;\n  return length( max(q,0.))+\n  min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat map(vec3 p, float fft, float fftS, float fftA, float phase)\n{\n  vec3 p1 = repeat(p, vec3(3.2));\n  vec3 p2 = p;\n  p2 +=vec3(\n    0.1*sin(iTime+p.x),\n    0.1*sin(iTime+p.y),\n    0.5*sin(iTime+p.z)\n  )*3.;\n  p2 = repeat(p2, vec3(0.25+sin(fftA*0.01)*.66));\n  \n  \n  \n  float s1 = sphere(p1, 1.25+(phase-2.55)*0.5*fftS*(40.+20.*sin(p.z*10.+p.x*14.)));\n  float s2 = sphere(p2, 0.25+fftS*0.5);\n  \n  \n  \n  float box = box( p, vec3(0.75));\n  \n  //s1 = box;\n  \n  return C(s1,s2);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float fft = max(0.,texture( iChannel0, vec2(0.15,0.5)).r*0.22-0.0905);\n  float fftS = length(mod(texture( iChannel0, vec2(0.14,0.5)).r,1.)-0.5)*0.01; //This is like this to actually have some effect.\n  float fftA = texture( iChannel0, vec2(0.16,0.5)).r*0.1;\n    //Run fftA with time since no continuous is in shadertoy\n   fftA = iTime*0.5;\n  \n  float time = iTime*0.9 + fftA;\n  float phase = mod( time*140./60.*2., 6.);\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  vec3 col = vec3(0);\n  vec3 cam = vec3(\n    0,\n    time,\n    2\n  );\n  vec3 target = vec3(\n    cos(time*0.052)*20.,\n    time+ cos(time*0.43)*4.5,\n    sin(time*0.257)*20.\n  );\n  \n  float t = 0.2;\n  vec3 rd = getcam(cam, target, uv, 2.0);\n  for(int i = 0; i < 100; i++)\n  {\n    vec3 p = cam + rd*t;\n    float r = map(p, fft, fftS, fftA, phase);\n    if(r < 0.01)\n    {\n      vec3 bc = vec3(\n        sin(time + p.x),\n        sin(time*1.1 + p.y),\n        sin(time*1.2 + p.z)\n      );\n      bc = abs(bc);\n      col += vec3(1)*0.01*bc;\n      \n    }\n    t+=max(0.03,r);\n    if(t > 100.)break;\n  }\n  \n  col += smoothstep(25., 50., t)*vec3(1,0.6,0.1)*(fftS*180.+fft*155.);\n  \n  fragColor = vec4(col,1.);\n    \n    \n    \n}\n\n","name":"Image","description":"","type":"image"}]}