{"ver":"0.1","info":{"id":"XcXcWX","date":"1721653253","viewed":122,"name":"spectral Soap bubble","username":"stduhpf","description":"Simple thin-film interference simulation, with a single internal bounce. I'm not sure how accurate it is.\nWorks better than I expected.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["simulation","interference","film","ibl","soap","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GAMMA\n#define DITHER\n\n\n#define tonemap(x) HLG_tm(x)\n// #define tonemap(x) ACES(x)\n// #define tonemap(x) HLG_tm(x)\n\nvec3 RRTAndODTFit(vec3 v) \n{\n    vec3 a = v * (v + 0.0245786);\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\nvec3 ACES(vec3 color){\n    const mat3 ACESInputMat = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    const mat3 ACESOutputMat = mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // left side: RGB, right side: spectral\n    vec4 col = texture(iChannel0,uv);if(col.a>0.)col/=col.a;\n    \n    // show relative difference\n    //vec4 col0 = texture(iChannel0,uv);col0/=col0.a;\n    //vec4 col1 = texture(iChannel1,uv);col1/=col1.a;\n\n\n    \n    fragColor = vec4(\n        #ifdef GAMMA\n        pow(\n        #endif\n            tonemap(col.rgb\n                   ///HLG_MAX\n                   #ifdef showOvershoot\n                   *16.-16.\n                   #endif\n                   )\n            #ifdef GAMMA\n            ,vec3(1./2.2))\n            #endif\n    ,1.0);\n    \n   #ifdef DITHER\n   vec4 noise = texture(iChannel3,(fragCoord)/iChannelResolution[3].xy);\n    //merge channels for better noise precision;\n    noise = noise*255./256.+noise.yzwx*255./(256.*256.);\n    noise+=noise.zwxy/(256.*256.); // the two last channels\n    \n    \n    const float prec = float((1<<8)-1); //8-bit color range: 0.->255.\n        \n    vec3 l = fragColor.rgb; //gamma-space value\n    vec3 lin = pow(l,vec3(2.2)); //linear-space value\n    \n    // get quantization \"bounds\"\n    vec3 lfg = floor(l*prec)/prec;\n    vec3 lcg = ceil(l*prec)/prec;\n    \n    // convert bounts to linear\n    vec3 lfl = pow(lfg,vec3(2.2));\n    vec3 lcl = pow(lcg,vec3(2.2));\n    \n    //vec3 xg = (l  -lfg)/(lcg-lfg); // == fract(l*prec)\n    vec3 xl = (lin-lfl)/(lcl-lfl);\n    \n    vec3 dithered = mix(lfg,lcg,step(noise.xyz,xl)); \n    fragColor.rgb = dithered;\n   #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// Background image (linear colors)\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = pow(texture(iChannel0,rayDir),vec4(2.2));\n\n    //increase dynamic range\n    fragColor.rgb = HLG(fragColor.rgb);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ANIMATE\n\nvec3 hash33(vec3 p){\n    return texture(iChannel3,p/iChannelResolution[3].xyz).xyz;\n}\n\nfloat simplex(vec3 p){\n    const float F = .33333333333;//(sqrt(n+1)-1)/n\n    const float G = .16666666667;//(1-1/sqrt(n+1))/n\n    \n    vec3 b = floor(p+dot(p,vec3(F)));\n    vec3 d = p - b + dot(b,vec3(G));\n    vec3 test = step(d,d.yzx);\n    \n    vec3 v1 = (1.-test)*test.zxy;   //it was a pain to estimate, i had to make a LUT and then simplify it\n    vec3 v2 = 1.-test*(1.-test.zxy);\n    \n    vec3 g1 = hash33(b);\n    vec3 g2 = hash33(b+v1);\n    vec3 g3 = hash33(b+v2);\n    vec3 g4 = hash33(b+1.);\n    \n    vec3 d2 = d - v1 + G;\n    vec3 d3 = d - v2 + F;\n    vec3 d4 = d - .5;\n    \n    vec4 dots = vec4(dot(d,g1),dot(d2,g2),dot(d3,g3),dot(d4,g4));\n    \n    vec4 g = max(.5-vec4(dot(d,d),dot(d2,d2),dot(d3,d3),dot(d4,d4)),0.);\n    g*=g;\n    return (64.*dot(g*g,dots));\n}\n\n\nfloat getWavelength(float frame){\n    const float spectrum_start = 380.;\n    const float spectrum_end = 780.;\n    \n    const float spectrum_range = spectrum_end-spectrum_start;\n    const float PHI = .5+.5*sqrt(5.);\n    \n    return fract(frame*PHI)*spectrum_range+spectrum_start;\n}\n\nconst float film_ior = 1.7;\nconst float film_thickness_min = 10.; //nm\nconst float film_thickness_max = 600.; //nm\n\n// exaggerated for artistic effect (real life sunlight has coherence lenghts of about 3 lambdas)  \nconst float coherence_length = 6.; // in lambdas\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*(fragCoord)-iResolution.xy)/iResolution.x;\n\n    vec3 ro = vec3(0.,0.,-.225);\n    vec3 rd = normalize(vec3(uv,1.));\n\n    vec4 noise = texture(iChannel1,fragCoord/iChannelResolution[1].xy);\n    vec2 dithering = (noise.rg*255.+noise.ba)/256.;\n    \n    vec4 i = iSphere(vec3(0),.1,ro,rd,false);\n    \n    //why isn't this working for the thumbnail???\n    if(iMouse.z<=0. || iMouse.x <= 0.)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = vec4(0.);\n    \n    float wl = getWavelength(float(iFrame)+dithering.x-dithering.y);\n    \n    float bg= RGBtoSPD(texture(iChannel2,rd).rgb,wl);\n    if(i.a>10.){\n        fragColor += vec4(spectrum_to_rgb(wl)*get_D65(wl)\n            *bg\n            ,1.);\n        return;\n    }\n\n    {\n        vec3 p = ro+rd*i.a;\n\n        vec3 n = i.xyz;\n        float r =0.;\n        r*=r;\n\n        float phase0 = 0.;\n        \n        #ifdef ANIMATE\n        float volnoise = simplex(p*8.+iTime*.05)*.5+.5; \n        #else\n        float volnoise = simplex(p*8.)*.5+.5; \n        #endif\n        // first refract\n        vec3 rdr = reflect(rd,n);\n        vec3 rrd = refract(rd,n,1./film_ior);\n        \n        if(dot(rrd,rrd)<.5){\n            // Total internal reflection on first surface (doesn't happen if film_ior>1.)\n            fragColor += vec4(spectrum_to_rgb(wl)*get_D65(wl)\n            *RGBtoSPD(texture(iChannel2,rdr).rgb,wl)\n            ,1.);\n        return;\n        }\n        \n        // assume no local curvature => 2 parallel plane surfaces\n       \n        // fisrt surface fresnel\n        float f0 = dielectricFresnel(-rd,n,1./film_ior);\n        \n        // second surface fresnel\n        float f1 = dielectricFresnel(-rrd,n,film_ior);\n\n        float d = -mix(film_thickness_min,film_thickness_max,volnoise)/dot(n,rrd);\n        \n        float internal_wl = wl/film_ior;\n        \n        //float phase1 = (PI+PI)*d/internal_wl;\n        \n        // + .5 because reflection casuses phase shift\n        float phase2 = (PI+PI)*(.5+(d+d)/internal_wl);\n        \n        float decoherence = exp(-(d+d)/(coherence_length*internal_wl));\n        \n        float reflInter = length(vec2(0,1)*f0 + vec2(sin(phase2),cos(phase2))*(1.-f0)*f1);\n        //intereference doesn't happen with incoherent light\n        reflInter = mix(f0+(1.-f0)*f1, reflInter, decoherence);\n\n        float reflCol = RGBtoSPD(texture(iChannel2,rdr).rgb,wl);\n\n         fragColor*=.95;\n         fragColor += vec4(spectrum_to_rgb(wl)*get_D65(wl)\n           * (reflCol*reflInter + bg*(1.-f1)*(1.-f0))\n            ,1.);\n\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\n\nmat3 getBasis(vec3 nor){\n    bool t = 1.-abs(nor.z)>.00001;\n    if(!t)\n        nor=nor.zxy;\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    return t?mat3(uu,vv,nor):mat3(uu.yzx,vv.yzx,nor.yzx);\n}\n\n\nvec4 iSphere(vec3 sp, float sr,vec3 ro, vec3 rd, bool backside) //intersection entre une sphere et un rayon\n{\n    vec3 p = sp-ro;\n    float d = dot(-rd,p);\n    float pp = dot(p,p);\n    float i = d*d- pp+sr*sr;\n    d = i>0.?(backside?sqrt(i):-sqrt(i))-d:-1000.;\n    if(d<0.)\n        i=-abs(i);\n\treturn vec4(normalize(rd*d-p),i>0.?d:1e6); //renvoie le vecteur normal au point d'intersection et la distance\n}\t\t\t\t\t\t\t\t\t//1e6 est un nombre tres grand\n\nfloat dielectricFresnel(vec3 I, vec3 N, float ior){\n    vec3 T = refract(-I,N,ior); \n    if(dot(T,T)<.5)return 1.;\n    float NdotI = dot(I,N),NdotTs = dot(T,-N)/ior;\n    float fresnel = (NdotI-NdotTs)/(NdotI+NdotTs);\n    fresnel*=fresnel;\n    float fresnel2 = (NdotTs-NdotI)/(NdotI+NdotTs);\n    fresnel2*=fresnel2;\n    return clamp(mix(fresnel,fresnel2,.5),0.,1.);\n}\n\n\n//// Dynamic range and tonemap\nconst float HLG_MAX = 2.; // peak brightness (>=1). Due to float precision issues, values above 5.4 can lead to invalid nubers \n// increasing past 3. will affect significantly only pixels with luninance exceeding 254./255.\n// HLG_MAX = sqrt(-log(1-HLG_SCALER*HLG_SCALER))/HLG_SCALER\n//this is an empirical fitting approximation of the solution, not the actual solution to this equation (I don't think there is a simple real solution)\nconst float HLG_SCALER = sqrt(1.-exp((1.-HLG_MAX)*3.92)); \n\nvec3 HLG(vec3 lin){ //increased dinamic range from image (assusmes color to be already in linear space)\n    if(HLG_SCALER<=0. || HLG_MAX <=1.)\n        return lin;\n    lin*=HLG_SCALER;\n    //luminance-based version(could also maybe work per channel, but it would mess with chromacity; so I perfer this way)\n    float lum = dot(lin,vec3(0.2126,.7152,.0722));\n    float l = lum;\n    if(l<=0.) return lin/HLG_SCALER;\n    l = (sqrt(-log(1.-l*l)));\n    if(isnan(l))l=lum;\n    return (lin*l/lum)/HLG_SCALER;\n}\n\n\nvec3 HLG_tm(vec3 o){ //how the HLG function assumes the HDR colors are encoded, can be used as bad tonemapping (still needs gamma correction after)\n    if(HLG_SCALER<=0. || HLG_MAX <=1.)\n        return o;\n    o=o*HLG_SCALER;\n    float l = dot(o,vec3(0.2126,.7152,.0722));\n    if(l<=0.)return vec3(0.);\n    float lum = sqrt(1.-exp(-l*l)); \n    vec3 lin = lum*o/l;\n    return lin/HLG_SCALER;\n}\n\n//// Spectrum locus (cie1931 numerical approximation)\n\nfloat gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y/=y<0.?s1:s2;\n    return al*exp(-y*y*.5);\n}\n\nvec3 lambdatoXYZ(float wl){\n    return .27*vec3( gaussian(wl, 1.056, 599.8, 37.9, 31.0)+gaussian(wl, 0.362, 442.0, 16.0, 26.7)+ gaussian(wl, -0.065, 501.1, 20.4, 26.2)\n                ,gaussian(wl, 0.821, 568.8, 46.9, 40.5)+gaussian(wl,0.286, 530.9, 16.3, 31.1)\n                ,gaussian(wl, 1.217, 437.0, 11.8, 36.0)+gaussian(wl, 0.681, 459.0, 26.0, 13.8));\n}\nconst mat3 xyz = mat3(\n\t3.240479, -1.537150, -0.498535,\n    -0.969256, 1.875992, 0.041556,\n    0.055648, -0.204043, 1.057311);\n\nvec3 spectrum_to_rgb(in float wl){\n    return lambdatoXYZ(wl)*xyz;\n}\n\n\n//// RGB to reflectance Spectrum (assumes true D65 lighting) \n\n//http://scottburns.us/wp-content/uploads/2018/09/RGB-components-comma-separated.txt\n//0:380->35:730\nconst float[] rho_R = float[36](0.021592459, 0.020293111, 0.021807906, 0.023803297, 0.025208132, 0.025414957, 0.024621282, 0.020973705, 0.015752802, 0.01116804, 0.008578277, 0.006581877, 0.005171723, 0.004545205, 0.00414512, 0.004343112, 0.005238155, 0.007251939, 0.012543656, 0.028067132, 0.091342277, 0.484081092, 0.870378324, 0.939513128, 0.960926994, 0.968623763, 0.971263883, 0.972285819, 0.971898742, 0.972691859, 0.971734812, 0.97234454, 0.97150339, 0.970857997, 0.970553866, 0.969671404);\nconst float[] rho_G = float[36](0.010542406, 0.010878976, 0.011063512, 0.010736566, 0.011681813, 0.012434719, 0.014986907, 0.020100392, 0.030356263, 0.063388962, 0.173423837, 0.568321142, 0.827791998, 0.916560468, 0.952002841, 0.964096452, 0.970590861, 0.972502542, 0.969148203, 0.955344651, 0.892637233, 0.5003641, 0.116236717, 0.047951391, 0.027873526, 0.020057963, 0.017382174, 0.015429109, 0.01543808, 0.014546826, 0.015197773, 0.014285896, 0.015069123, 0.015506263, 0.015545797, 0.016302839);\nconst float[] rho_B = float[36](0.967865135, 0.968827912, 0.967128582, 0.965460137, 0.963110055, 0.962150324, 0.960391811, 0.958925903, 0.953890935, 0.925442998, 0.817997886, 0.42509696, 0.167036273, 0.078894327, 0.043852038, 0.031560435, 0.024170984, 0.020245519, 0.01830814, 0.016588218, 0.01602049, 0.015554808, 0.013384959, 0.012535491, 0.011199484, 0.011318274, 0.011353953, 0.012285073, 0.012663188, 0.012761325, 0.013067426, 0.013369566, 0.013427487, 0.01363574, 0.013893597, 0.014025757);\n\nfloat RGBtoSPD(vec3 col, float wl){ //linear color input, obiously\n    float i = 35.*(wl-380.)/(730.-380.);\n    int index = int(i);\n    if(index<0) return col.b;\n    if(index>=35) return col.r;\n    float m = min(col.r,min(col.g,col.b));\n    return m+dot(col-m,mix(vec3(rho_R[index],rho_G[index],rho_B[index]),vec3(rho_R[index+1],rho_G[index+1],rho_B[index+1]),fract(i)));\n}\n\n\n//// D65 spectrum\n\nfloat blackbody(float wl, float T){\n    const float h = 6.62607015e-34; // Planck constant\n    const float k = 1.380649e-23; // Boltzmann constant\n    const float c = 2.99792458e8; // Speed of light\n   \twl*=1e-9; // convert nm to m\n\n    const float normalization_constant = 3.12245e-13; //such as 6500K lightsource is almost pure sRGB white, with luminance == 1.\n\n    return  2.*h*(c*c)/(wl*wl*wl*wl*wl*(exp(h*c/(T*wl*k))-1.))*normalization_constant;\n}\n\n\n//https://www.mtheiss.com/help/final/html/code/bk_d65_spectrum.htm\n//0:380->80:780\nconst float[] D65 = float[81](50.,  52.,  54.,  68.,  82.,  87.,  91.,  92.,  93.,  90.,  86.,  95., 104., 110., 117., 117., 117., 116., 114., 115., 115., 112., 108., 109., 109., 108., 107., 106., 104., 106., 107., 106., 104., 104., 104., 102., 100.,  98.,  96.,  96.,  95.,  92.,  88.,  89.,  90.,  89.,  89.,  88.,  87.,  85.,  83.,  83.,  83.,  81.,  80.,  80.,  80.,  81.,  82.,  80.,  78.,  74.,  69.,  70.,  71.,  73.,  74.,  68.,  61.,  65.,  69.,  72.,  75.,  69.,  63.,  55.,  46.,  56.,  66.,  65.,  63.) ;\n\nfloat get_D65(float wl){\n    float i = 80.*(wl-380.)/(780.-380.);\n    int index = int(i);\n    if(index<0) return blackbody(wl,6500.);\n    if(index>=80) return blackbody(wl,6500.);\n    \n    const float normalization_constant = .142358; // such as integration over the wole spectum gives vec3(1)\n\n    return mix(D65[index],D65[index+1],fract(i))*normalization_constant;\n}","name":"Common","description":"","type":"common"}]}