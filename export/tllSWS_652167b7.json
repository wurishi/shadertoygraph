{"ver":"0.1","info":{"id":"tllSWS","date":"1564172169","viewed":764,"name":"Surreal Cloud Flight","username":"peet","description":"My first muck about with volumetric rendering... so much fun! Looking forward to some more experiments ;-)\nUsing IQ's awesome 3D noise function.\nEdit: Tweaked visuals, improved performance","likes":39,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","noise","volume","cloud","volumetric","flight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define FLIGHT_SPEED 15.0\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n    vec4 fog;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's noise functions\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_ITERATIONS \t320\n#define MARCH_DELTA\t\t\t0.05\n#define MARCH_DELTA2\t\t1.01\n\nResult g_result;\n\nfloat mist(vec3 p, int LOD)\n{   \n    vec3 p2 = p;\n    p *= 0.2;\n    float weight = 0.25;\n    float totalweight = 0.0;\n    float value = 0.0;\n    for (int i=0; i<LOD; i++)\n    {\n        totalweight += weight;\n        value += noise(p)*weight;    \n        p *= 2.03;\n        weight *= 0.6;\n    }\n            \n    return (value/totalweight + abs(p2.y)*0.1 + abs(p.x)*0.0003 - 0.1);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult raymarch_query(Ray ray, int iterations, float delta)\n{\n    Result result = Result(ray.pos+ray.dir*10000.0, vec3(0.0, 0.0, 0.0), g_NoMaterial, vec4(0.0, 0.5, 0.0, 0.0));    \n    float dist = 0.0;\n    float fog=0.0;\n    float dstalpha = 0.0;\n    float srcalpha = 0.0;\n    const float densitythreshold = 0.70;\n    const float densityscale = 100.0/(1.0-densitythreshold);\n    \n    vec3 lighting = vec3(-1.0, -1.0, 1.0);\n    //vec3 lighting2 = vec3(1.0, 0.0, 1.0);\n    lighting = normalize(lighting);\n    \n\tfor (int i=0; i<iterations; i++)\n    {           \n        // the 2 values of the fog at the query position and one shifted slightly toward the light\n\t\tfloat v1 = mist(ray.pos, 6);\n\t\tfloat v2 = mist(ray.pos + lighting*0.3, 5);\n\t\t//float v3 = mist(ray.pos + lighting2*0.3);\n        \n\t\tfloat value=0.0;;\n        float vmax=0.7;\n        float vmin=0.5;\n            \n        if (v1 >= vmax)\n            value = 1.0;\n        else if (v1 <= vmin)\n            value = 0.0;\n        else\n            value = (v1-vmin)/(vmax-vmin);\n            \n        value=value*value;\n                        \n        // density is the value times the step\n       \n        float density = clamp(value*delta*0.7, 0.0, 1.0);\n        density*=clamp(delta*4.0, 0.0, 1.0);\n        // update the alpha\n        srcalpha = density;\n        \n        if (srcalpha>0.01)\n        {\n            // the colour of the fog is dependent on its density, dark grey = high density, white = low\n            vec3 fogcolour = mix(vec3(0.9), vec3(0.0, 0.0, 0.1), value); \n\n            // add light reflected from the sun\n            //fogcolour += clamp((v2-v1)*33.0, 0.0, 1.0)*vec3(1.0, 0.7, 0.3)*1.0;\n            //fogcolour += clamp((v3-v1)*6.0, 0.0, 1.0)*vec3(0.9, 0.0, 0.0)*1.0;\n\n            // some bi-directional lighting - totally unreal but looks really funky mixed with the fog colour\n            if ((v2-v1) >= 0.0)\n            {\n                fogcolour += (v2-v1)*(v2-v1)*250.0*vec3(1.0, 0.3, 0.0)*1.0;\n                fogcolour += pow((v2-v1), 3.0)*1000.0*vec3(1.0, 0.3, 0.0)*1.0;\n            }\n            else\n            {\n                fogcolour += (v1-v2)*(v1-v2)*66.0*vec3(0.0, 0.5, 1.0)*1.0;\n                fogcolour += pow((v1-v2), 3.0)*500.0*vec3(1.0, 1.0, 1.0)*1.0;\n            }\n            \n            \n            if (dstalpha == 0.0)\n            {\t// first sample with some density in it\n                result.fog.xyz = fogcolour;\n                dstalpha = srcalpha;\n            }\n            else\n            {\n                // modify the destingation alpha, based on the current srcalpha\n                float prevdstalpha = dstalpha;\n                dstalpha = dstalpha + srcalpha*(1.0 - dstalpha);\n                result.fog.xyz = mix(fogcolour, result.fog.xyz, prevdstalpha/dstalpha);\n                //result.fog.xyz += fogcolour*density;            \n            }\n        }\n        if (dstalpha>0.9)\n        {\n\t\t   \tresult.fog.w = dstalpha;\n    \t\treturn result;            \n        }\n             \n        ray.pos += ray.dir*delta;\n        delta*=MARCH_DELTA2;\n    }\n            \n   \tresult.fog.w = dstalpha;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 raymarch(Ray inputray)\n{\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    Ray ray=inputray;        \n    g_result = raymarch_query(ray, MARCH_ITERATIONS, MARCH_DELTA);\n    \n//    colour = vec3(g_result.fog.w);\t\n//    colour = g_result.fog.xyz;    \n    colour = mix(vec3(0.0, 0.15, 0.3), g_result.fog.xyz, g_result.fog.w);       \n    //colour = mix(vec3(0.0), g_result.fog.xyz, g_result.fog.w);       \n            \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Ray ray;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float speed = FLIGHT_SPEED;\n    float roll = 0.5;\n    float time = iTime + 4.0;\n    \n    float ft = time-1.0;\n\tvec3 p0 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0);  \n    ft+=0.5;\n\tvec3 p1 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0); \n    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);\n    dir = normalize(dir);\n    vec3 up = vec3(dir.x*roll, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = vec3(0.0, 0.0, time*speed) + p0;\n    ray.dir = dir*1.0 + up*uv.y + right*uv.x;\n    ray.dir = normalize(ray.dir);\n        \n    float dither = 0.0;\n    dither = 0.5*hash1(uint(fragCoord.x+iResolution.x*fragCoord.y)+uint(iResolution.x*iResolution.y)*uint(iFrame));//Updated with iFrame dimension    \n    ray.pos += ray.dir*dither;\n    \n    fragColor.xyz = raymarch(ray);  \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"}]}