{"ver":"0.1","info":{"id":"Ml2XRV","date":"1445151525","viewed":504,"name":"Textured Globe","username":"g4b0r","description":"I'm working on a texture mapped sphere with latitude and longitude lines. Could someone help me figure out how to anti-alias the latitude and longitude lines?","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","sphere","texturemapped"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"mat3 xrot(float angle) {\n    mat3 m;\n    m[0] = vec3(1.0, 0.0, 0.0);\n    m[1] = vec3(0.0, cos(angle), -sin(angle));\n    m[2] = vec3(0.0, sin(angle), cos(angle));\n    return m;\n}\n\nmat3 yrot(float angle) {\n    mat3 m;\n    m[0] = vec3(cos(angle), 0.0, -sin(angle));\n    m[1] = vec3(0.0, 1.0, 0.0);\n    m[2] = vec3(sin(angle), 0.0, cos(angle));\n    return m;\n}\n\nfloat intersectSphere(vec3 camera, vec3 ray, vec3 sphereOrigin, float sphereRadius) {\n    float radiusSquared = sphereRadius * sphereRadius;\n    float dt = dot(ray, sphereOrigin - camera);\n    if (dt < 0.0) {\n        return -1.0;\n    }\n    vec3 tmp = camera - sphereOrigin;\n    tmp.x = dot(tmp, tmp);\n    tmp.x = tmp.x - dt * dt;\n    if (tmp.x >= radiusSquared) {\n        return -1.0;\n    }\n    float distanceFromCamera = dt - sqrt(radiusSquared - tmp.x);\n    return distanceFromCamera;\n}\n\nvec4 render(vec2 uv, float time) {\n    vec3 lightPosition = vec3(0.0, 0.0, -25.0);\n    vec3 spherePosition = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 1.4;\n    vec3 cameraPosition = vec3(0.0, 0.0, -10.0);\n    \n    uv = uv * 2.0;\n    uv.y -= 1.0;\n    uv.x -= (1.0 / (iResolution.y / iResolution.x));\n    \n    vec3 pixelPosition = vec3(uv.x / 5.0, uv.y / 5.0, -9.0);\n    \n    vec3 ray = pixelPosition - cameraPosition;  // Generate a ray\n    ray = normalize(ray);\n    \n    ray = ray * xrot(time * 0.3) * yrot(time * 0.3);\n    cameraPosition = cameraPosition * xrot(time * 0.3) * yrot(time * 0.3);\n    \n    lightPosition = cameraPosition;\n    \n    float distance = intersectSphere(cameraPosition, ray, spherePosition, sphereRadius);\n    \n    if (distance > 0.0) {\n        \n        vec3 pointOfIntersection = cameraPosition + ray * distance;\n        vec3 normal = normalize(pointOfIntersection - spherePosition);\n        \n        float u = 0.5 + atan(normal.z, normal.x) / (3.1415926 * 2.0);\n        float v = 0.5 - asin(normal.y) / -3.1415926;\n        \n        float brightness = dot(normalize(lightPosition - spherePosition), normal);\n        if (brightness < 0.0) {\n            brightness = 0.0;\n        }\n        \n        vec4 outputColor = texture(iChannel0, vec2(fract(u), fract(v)));\n        \n        float x = u * 18.0;\n        float y = v * 10.0;\n        if (fract(x) < 0.1 || fract(y) < 0.1) {\n                outputColor *= 0.5;\n       \t}\n        return outputColor * brightness;\n    }\n    else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x /= iResolution.y / iResolution.x;\n\tfragColor = render(uv, iTime);\n}","name":"","description":"","type":"image"}]}