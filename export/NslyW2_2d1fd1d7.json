{"ver":"0.1","info":{"id":"NslyW2","date":"1642724748","viewed":109,"name":"Box Subtraction 3D","username":"kastorp","description":"green=naive with artifacts on the ground\nblue=correct sdf\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["box","subtraction","exterior"],"hasliked":0,"parentid":"sslyRB","parentname":"Box Subtraction (exterior)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(max(d.x,d.y),d.z),0.0);\n}\nfloat sdBoxS( in vec3 p, in vec3 b )\n{\n    vec3 d = max(abs(p)-b,0.);\n    return dot(d,d);\n}\n\n// this parameter should be 0 for AO and soft shadows and 1 for raymarching\nint alg;  //1=fast, 0=correct\n\n\n// b= primary box size\n// c= subtracted box center\n// b2= subtracted box size\nfloat sdBoxSub( in vec3 p,vec3 b, vec3 c,vec3 b2)\n{\n    //max(...)  for interior is exact\n    float de= max( sdBox(p,b),-sdBox(p-c,b2));\n     if(alg==1) return (de);\n    //symmetry (thanks Iq)\n    if( c.x<0.0 ) {c.x=-c.x; p.x=-p.x; }\n    if( c.y<0.0 ) {c.y=-c.y; p.y=-p.y; }\n    if( c.z<0.0 ) {c.z=-c.z; p.z=-p.z; }\n    \n    //if interior or no intersection, use the basic subtraction\n    if(de<0. || max(max(c.x-b2.x-b.x,c.y-b2.y-b.y),c.z-b2.z-b.z)>0.  ) return (de);\n \n    vec3 oMin= min(-b,c-b2),\n         oMax= max(b,c+b2),     //outer box\n         iMin= max(-b,c-b2),\n         iMax= min(b,c+b2);     //intersection box    \n\n    float di = 1e10;\n    //this part can be further simplified\n    if((b.x>=oMax.x))   di=min(di,sdBoxS(p -vec3((oMax.x+ iMax.x)*.5,0,0), vec3(abs(oMax.x -iMax.x)*.5,b.y,b.z) ));  \n    if((-b.x<=oMin.x))  di=min(di,sdBoxS(p -vec3((oMin.x+ iMin.x)*.5,0,0), vec3(abs(oMin.x -iMin.x)*.5,b.y,b.z) )); \n    if((b.y>=oMax.y))   di=min(di,sdBoxS(p -vec3(0,(oMax.y+ iMax.y)*.5,0), vec3(b.x,abs(oMax.y -iMax.y)*.5,b.z))); \n    if((-b.y<=oMin.y))  di=min(di,sdBoxS(p -vec3(0,(oMin.y+ iMin.y)*.5,0), vec3(b.x,abs(oMin.y -iMin.y)*.5,b.z) )); \n    if((b.z>=oMax.z))   di=min(di,sdBoxS(p -vec3(0,0,(oMax.z+ iMax.z)*.5), vec3(b.x,b.y,abs(oMax.z -iMax.z)*.5)));  \n    if((-b.z<=oMin.z))  di=min(di,sdBoxS(p -vec3(0,0,(oMin.z+ iMin.z)*.5), vec3(b.x,b.y,abs(oMin.z -iMin.z)*.5) ));  \n\n    return sqrt(di); \n}\n//--------------------------------------------------\n\nfloat map(vec3 p) {      \n    float d= p.y,t=iTime*.3; \n    p -= vec3(0.,.2,0.);\n    float dh =    sdBoxSub(p,vec3(.7,.2,.5),\n                  vec3(.6*sin(t),.3+.3*cos(t),.5*cos(t)),\n                  vec3(.4+.3*sin(t*3.1),.4+.2*cos(t*3.1),.4+.2*cos(t*3.1))\n                  );\n    d=   min(d,dh);\n    return d;\n}\n\nvec3 calcN(vec3 p) {\n\tfloat h = .001;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\treturn normalize(n);\n}\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=min(iFrame,0); aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos = nor * hr + pos;\n        totao += -(map(aopos)-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 1., t = .05;\n\tfor (float i = 0.; i < 40.; i++)\n\t{\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\treturn clamp(s, 0., 1.);\n}\n\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0,1., 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tfor (float i = 0.; i < 100.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .001  )break;\n        if(d >10.) break;\n\t\td += h; // No hit, so keep marching.\n\t} \n        \n   vec3 skyColor =  .5*vec3(.5, .6, .9),\n         col = skyColor - max(rd.y,0.)*.5,n=calcN(p);\n    col= (p.y>=0.01 && d<10.)?  vec3(1,0,0): alg>0? vec3(0,1,0):vec3(0,.5,.5);\n   \n    float ss = .8, sp = .2;\n       vec3 ld = -normalize(vec3(.5,1,1));\n    // IQ sss version\n    float sss = ss*0.2*clamp(0.5+0.5*dot(ld,n),0.0,1.0)*(2.0+dot(rd,n));\n    vec3 r = reflect(rd,n);\n    float diff = max(0.,dot(n,ld)),\n         amb = dot(n,ld)*.45+.55,\n         spec = pow(max(0.,dot(r,ld)),40.),\n         fres = pow(abs(.7+dot(rd,n)),3.),   \n         ao = calcAO(p, n);\n    // ligthing     \n    col = col*mix(1.2*vec3(.25,.08,.13),vec3(.984,.996,.804), mix(amb,diff,.75)) + \n          spec*sp+fres*mix(col,vec3(1),.7)*.4;\n    col += sss*vec3(1.,.3,.2);  \n    col += max(0.,dot(vec3(0,-1,0), n))*.1*skyColor;    \n    col *= mix(ao,1.,.0);\n    \n    // fade in distance\n    return mix( col, skyColor, smoothstep(3.,15., d) );\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tvec2 m= iMouse.z>0.? iMouse.xy:iResolution.xy*.5;\n    float t=-iTime*.5;\n    alg= fc.x<m.x?1:0;\n\tvec3 ro = vec3(1.*cos(t), .7 +3.*iMouse.y/iResolution.y, 1.*sin(t));\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, vec3(0,.5,0), uv)), vec3(.45)), fc), 0);\n}\n","name":"Image","description":"","type":"image"}]}