{"ver":"0.1","info":{"id":"XtdGDB","date":"1471643528","viewed":1661,"name":"Myrror","username":"nimitz","description":"Not to be confused with Arcanus.","likes":66,"published":1,"flags":32,"usePreview":1,"tags":["3d","fractal","tower","scene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Myrror by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XtdGDB\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tFractal geometry with cheap to render terrain and a sky\n\tbased on a failed experiment.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Myrror by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XtdGDB\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tFractal geometry with cheap to render terrain and a sky\n\tbased on a failed experiment.\n*/\n\n#define ITR 100\n#define FAR 68.\n#define time iTime\n\nfloat matid = 0.;\nfloat glw = 0.;\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\n\nfloat trinz(in vec3 p, in float spd)\n{\n    float z=1.2;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.;i<=3.; i++)\n\t{\n        p += (tri3(bp)*0.7+0.3+ time*spd);\n        bp *= 2.1;\n\t\tz *= 1.3;\n\t\tp *= 1.22;\n            \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.13;\n\t}\n\treturn rz;\n}\n\nfloat slength(in vec3 p){ return max(abs(p.x), max(abs(p.y), abs(p.z))); }\n//2dFoldings, inspired by Gaz/Knighty (see: https://www.shadertoy.com/view/4tX3DS)\nvec2 foldHex(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.5, 0.8657);\n    const vec2 pl2 = vec2(-0.8657, 0.5);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    return p;\n}\n\nfloat cycl(in float x)\n{\n    return mix(-abs(sin(x*7.31))*1.7+.7,abs(1.0+sin(x*4.0))*1.4-1.75, 0.7)*2.;\n}\n\n//The terrain is partially inspired by iq's \"Terrain Tubes\"\n//(https://www.shadertoy.com/view/4sjXzG)\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat terrain(in vec2 p)\n{\n    p *= 0.015;\n    vec2 bp =p;\n    float z = 1.0;\n\tfloat rz = 0.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n        rz += z*(cycl(p.x) + cycl(p.y));\n\t\tz *= 0.5 + 0.07*rz;\n        p = m2*p + (rz-0.5)*0.09;\n\t}\n    return rz;\n}\n\nfloat terrainHD( vec2 p )\n{\n    vec2 bp = p;\n    p *= 0.015;\n    float z = 1.0;\n\tfloat rz = 0.0;\n\tfor( int i=0; i<8; i++ )\n\t{\n        rz += z*(cycl(p.x) + cycl(p.y));\n\t\tz *= 0.5 + 0.07*rz;\n        p = m2*p + (rz-0.5)*0.09;\n\t}\n    \n    rz += 0.1*textureLod(iChannel1, 0.06*bp,0.0).x;\n    rz += 0.08*textureLod(iChannel1, 0.1*bp,0.0).x;\n    rz += 0.08*textureLod(iChannel1, 0.25*bp,0.0).x;\n\treturn rz;\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat map(vec3 p)\n{   \n  \tvec3 bp = p;\n    p.yz *= rot(1.5708);\n    p.xy = foldHex(p.xy);\n    p.x += 0.02;\n    p.y += 1.35;\n    p.xz = foldHex(p.xz);\n    \n\tvec4 z = vec4(-abs(p),1.1);\n    \n    for (int i=0; i<7; i++)\n    {\n        z.xyz = clamp(z.xyz, -.3, .92) * 2.0 - z.xyz;\n        z = z*2.36/clamp(dot(z.xyz, z.xyz), 0.25, 1.1)-vec4(0.45,0.3,1.33,0.);\n        z.xy*=rot(-0.085);\n    \tz.zy*=rot(0.025);\n    }\n    \n    //float d = (length(max(vec3(-10.), z.xyz)))/z.w;\n    float d = (slength(max(vec3(-10.), z.xyz)))/z.w;\n    \n    bp.xz += vec2(-1951.,717.5);\n    bp.y = abs(bp.y+5.7)-5.2;\n    float tr = bp.y+1.5-terrain(bp.xz);\n    d = min(d, tr);\n    \n    return d;\n}\n\n#if 0\nfloat mapHD(in vec3 p)\n{\n    return map(p);\n}\n#else\nfloat mapHD(vec3 p)\n{   \n    matid = 0.;\n  \tvec3 bp = p;\n    p.yz *= rot(1.5708);\n    p.xy = foldHex(p.xy);\n    p.x += 0.02;\n    p.y += 1.35;\n    p.xz = foldHex(p.xz);\n    \n\tvec4 z = vec4(-abs(p),1.1);\n    \n    for (int i=0; i<7; i++)\n    {\n        z.xyz = clamp(z.xyz, -.3, .92) * 2.0 - z.xyz;\n        z = z*2.36/clamp(dot(z.xyz, z.xyz), 0.25, 1.1)-vec4(0.45,0.3,1.33,0.);\n        z.xy*=rot(-0.085);\n    \tz.zy*=rot(0.025);\n    }\n    \n    //float d = (length(max(vec3(-10.), z.xyz)))/z.w;\n    float d = (slength(max(vec3(-10.), z.xyz)))/z.w;\n\n    bp.xz += vec2(-1951.,717.5);\n    bp.y = abs(bp.y+5.7)-5.2;\n    float tr = bp.y+1.5-terrainHD(bp.xz);\n    if (tr < d) matid = 1.;\n    d = min(d, tr);\n    \n    return d;\n}\n#endif\n\nfloat sign2( float x ) { return x>=0.0?1.0:-1.0; }\nfloat bisect(in vec3 ro, in vec3 rd, in float near, in float far)\n{\n    float mid = 0.;\n    float sgn = sign2(map(rd*near+ro));\n    for (int i = 0; i < 5; i++)\n    { \n        mid = (near + far)*.5;\n        float d = map(rd*mid+ro)*1.;\n        if (abs(d) < 0.005)break;\n        d*sgn < 0. ? far = mid : near = mid;\n    }\n    return (near+far)*0.5;\n}\n\nfloat march(in vec3 ro, in vec3 rd, out float itrc)\n{\n\tfloat precis = 0.006;\n    float h=precis*2.0;\n    float d = 0.;\n    float told = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        told = d;\n        d += h;\n\t    float res = map(ro+rd*d)*.85;\n        glw += clamp(1.0/h,0.,1.); //Additive glow\n        h = res;\n        itrc++;\n    }\n    #if 1\n    if (d < FAR)\n    \td = bisect(ro, rd, told, d);\n    #endif\n\treturn d;\n}\n\nvec3 normal(in vec3 p, in float d)\n{\n    float px = 1./iResolution.y;\n    vec2 e = vec2(-1., 1.)*.5*d*px;\n\treturn normalize(e.yxx*mapHD(p + e.yxx) + e.xxy*mapHD(p + e.xxy) + \n\t\t\t\t\t e.xyx*mapHD(p + e.xyx) + e.yyy*mapHD(p + e.yyy) );   \n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return 1./e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nfloat shadow(in vec3 ro, in vec3 rd)\n{\n\tfloat rz = 1.;\n    float d = 0.1;\n    for( int i=0; i<10; i++ )\n    {\n\t\tfloat res = map(ro + rd*d);\n        rz = min(rz, 8.0*res/sqrt(d));\n        d += max(res,0.1);\n        if(res<0.001 || d>1.) break;\n    }\n    return clamp(rz, 0., 1.);\n}\n\n//----------------------------------------------------\n//----------------------Sky---------------------------\n//----------------------------------------------------\nfloat noise2( in vec2 x ){return textureLod(iChannel0, x*.01,0.0).x;}\nfloat tri2(in float x){return abs(fract(x)-0.8)*2.;}\nmat2 m22 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm( in vec2 p )\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i <4.;i++ )\n\t{\n        rz+= tri2(noise2(p)*1.25)/z;\n        z *= 2.8;\n        p = p*2.6;\n       \tp*=m22;\n\t}\n\treturn rz;\n}\n\nvec3 sky(in vec3 rd, in vec3 lgt)\n{   \n    rd.y = abs(rd.y + 0.125);\n    float pt = .7/(rd.y+0.45);\n    \n    vec3 bpos = pt*rd;\n    bpos *= 2.;\n    vec2 p = bpos.zx;\n    vec4 col = vec4(0);\n    vec4 sum = vec4(0);\n    p*= 1.;\n    vec2 pp = p;\n    float tz = 0.;\n    float t= time + 500.;\n    for(float i=4.;i>=0.;i--)\n    {\n        p = bpos.zx + (i+1.)*0.003*t;\n        p += i*30.;\n        p*= ((4.-i)*0.2+0.8);\n        p *= 1.4;\n        \n        float rz= fbm(p);\n        float rg = rz;\n        vec3 clx = (sin(vec3(.95,4.1,3.8)+i*.1-1.25))*rz;\n        float ds = 1.;\n        for(float i=0.;i<3.;i++)\n        {\n            float dif2 = clamp(rg-fbm(p+lgt.zx*0.01*ds)*.85,0.05,1.)*rz*rz;\n            clx += dif2*1.*vec3(1,0.8,.6);\n            ds = ds*2.+1.;\n        }\n        col = vec4(clx,rz);\n\t\tcol.rgb *= col.a*1.5;\n\t\tsum = sum + col*(1. - sum.a);\n        \n        tz += rz;\n    }\n    sum.rgb *= 1.-(1.-clamp(rd.y*7.-.5,0.,1.))*vec3(1.0,.9,.75);\n    \n    return sum.rgb*0.9;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n//----------------------------------------------------\n\n//Based on: https://iquilezles.org/articles/fog\nvec3 fog(vec3 ro, vec3 rd, vec3 col, vec3 lgt, float ds)\n{\n    ro.y += 5.;\n    const float b= 0.4;\n    float den = 0.15*exp(-ro.y*b)*(1.0-exp( -ds*rd.y*b ))/rd.y;\n    return mix(col, vec3(0.08,0.06,0.3), clamp(den, 0.,.7));\n}\n\nvec3 shade(in vec3 pos, in vec3 ro, in vec3 rd, in vec3 lgt)\n{\n    vec3 col = vec3(0);\n    \n    float crv= curv(pos,.005);\n    float d= distance(ro,pos);\n    vec3 nor = normal(pos,d);\n    float mat = matid;\n    float shd = shadow( pos, lgt)*0.7+0.3;\n\n    \n    if (mat == 0.)\n    {\n        float dif = max(dot(nor,lgt),0.0)*shd;\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lgt)),0.0);\n        float fre = clamp(pow(1.0+dot(nor,rd),3.),0.,1.5)*shd;\n        vec3 haf = normalize(lgt - rd);\n        float spe = pow(clamp(dot(nor,haf),0.0,1.0),50.0)*shd;\n        float occ= crv*0.8+0.2;\n        occ *= trinz(pos*10., 0.0)+0.2;\n\t\tvec3 lcol = vec3(1.0,.9,0.9);\n        col  = 0.2*occ + dif*lcol + 0.2*bac*occ*lcol;\n        col *= pos.y*0.07+0.55;\n        col *= vec3(.4,.4,.2)+(trinz(pos*4.,0.)*.7+0.3);\n        col += .1*fre*vec3(1.0) + .2*spe*vec3(1.0);\n        col = clamp(col, 0.,1.);\n        col = pow(col,vec3(.9));\n        col -= sin(vec3(1.1,1.5,2.7)+crv*.3*(dif*0.9+0.1))*0.27;\n    }\n    else\n    {\n        float dif = (max(dot(nor,lgt),0.0)*0.65+0.2)*shd;\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lgt)),0.0);\n        float fre = clamp(pow(1.0+dot(nor,rd),3.),0.,1.5)*shd;\n        vec3 haf = normalize(lgt - rd);\n        float spe = pow(clamp(dot(nor,haf),0.0,1.0),50.0)*shd;\n        col  = 0.1 + dif*vec3(1.0,.95,0.9) + 0.3*bac*vec3(1.0);\n        col *= pos.y*0.06+0.65;\n        col *= vec3(.95,.95,1.);\n        col += .05*fre*vec3(1.,.7,1.) + .1*spe*vec3(1.0);\n        col = clamp(col, 0.,1.);\n        col = pow(col,vec3(.9));\n        col -= sin(vec3(2.,1.,2.4)+texture(iChannel1,pos.xz*0.01).r*.3 + .05)*0.33;\n    }\n    \n    col = fog(ro, rd, col, lgt, d);\n    \n    return clamp(col,0.,1.);\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 flare(in vec3 ro, in vec3 rd, in float t, in vec3 lpos)\n{\n    float dotl = dot(lpos - ro, rd);\n    dotl = clamp(dotl, 0.0, t);\n\n    vec3 near = ro + rd*dotl;\n    float ds = dot(near - lpos, near - lpos);\n    float prg = time*0.022;\n    ds *= sin(time*50.*sin(time))*(0.1-clamp(0.,0.097,prg*0.1))+(3.-clamp(0.,2.95,prg));\n\treturn (vec3(.3,0.4,1.) * .007/(ds*sqrt(ds)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.42,-0.0):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\tmo*= 4.7;\n    mo.y -= .3;\n    mo.y *= 0.2;\n    mo.x += time*0.04 + smoothstep(65., 100., time)*2.;\n    \n    mo.y += sin(time*0.07+1.5)*0.6;\n    mo.y *= smoothstep(-4.,10., time);\n    \n    vec3 ro = vec3(.9-sin(time*0.1+2.)*0.4,.9,2.6);\n    vec3 rd = normalize(vec3(p,-1.15));\n    rd.xy += sin(time*50.*sin(time*100.))*0.0008*smoothstep(0.,175.,time);\n    \n    ro.z += sin(time*0.1-1.5)*0.7;\n    ro.y += sin(time*0.07-1.7)*1.8;\n    \n    rd = rotx(rd,mo.y);\n    ro = roty(ro,mo.x), rd = roty(rd,mo.x);\n\t\n    vec3 lgt = normalize(vec3(-1., .4, -0.2));\n    float count = 0.;\n\tfloat rz = march(ro,rd, count);\n\t\n    vec3 col = vec3(1.,0.9,1.) * pow(max(dot(rd,lgt),0.),20.)*vec3(0.5,0.65,1.0)*0.8;\n    col += sky(rd, lgt).rgb;\n    vec3 pz = ro + rd*dot(-ro, rd);\n    pz = mix(pz,rd,.5);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        col = shade(pos,ro,rd,lgt);\n        col += pow(glw,0.75)*.005*vec3(.3,0.2,0.7)*smoothstep(-2.,-6.,pos.y);\n    }\n    else\n    {\n        col += pow(abs(glw),0.75)*.02*vec3(.4,0.3,0.9)*(trinz(vec3(pz*.5),0.1)*0.5+0.5);\n    }\n    \n    col += flare(ro,rd,rz,vec3(0,1.,0));\n    \n    vec2 r = q*2.0 - 1.0;\n    col *= smoothstep(2.,0.3,length(r*r*r*r)*1.);\n    col *= smoothstep(0.,3., time);\n    col = smoothstep(-0.13,1.,col);\n    \n    \n    col *= vec3(1.0,1.0,.9);\n    col = pow( col, vec3(1.15,.95,.95) );\n    \n    vec4 past = texture(iChannel2, q);\n    if (count != past.w && rz < FAR) col = mix(col, past.rgb, 0.5);\n    count = mix(count, past.w, clamp(0.2, 0.5, 0.5 - rz*0.01));\n    \n    col = mix(col, past.rgb, 0.2);\n    \n\tfragColor = vec4(col, count);\n}","name":"Buffer A","description":"","type":"buffer"}]}