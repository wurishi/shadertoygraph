{"ver":"0.1","info":{"id":"WtGBDw","date":"1614468257","viewed":171,"name":"procedural_turbo","username":"froxel","description":"Procedural approximation of Google's original Turbo colormap, with some extra parameters (see shader comments).","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["colormap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Procedural approximation of Google's original Turbo colormap [1]. Compared to\n// other approximations [2], this version is probably less accurate, but has extra\n// parameters for controlling darkness at high and low values, and how purplish\n// the blue end of the range should be.\n//\n// For a brighter, more purplish version that works well on dark backgrounds, try\n// these parameters: RED_FADE=0.5; BLUE_FADE=0.5; PURPLE_FACTOR=1.0\n//\n// References:\n// [1] https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html\n// [2] https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7\n//\n// Author: Fredrik Nysj√∂ (2021)\n\n#define COLORMAP 0         // 0=Turbo, 1=sRGB rainbow\n#define RED_FADE 0.5       // Darkening at low values\n#define BLUE_FADE 0.8      // Darkening at high values\n#define PURPLE_FACTOR 0.8  // Amount of purplish tint to blues\n#define NUM_STEPS 9        // Steps for discretized colormap\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{ \n    vec2 uv = fragCoord / iResolution.xy;\n    float n = max(1.0, float(NUM_STEPS) - 1.0);\n    if (uv.y < 0.5) uv.x = round(uv.x * n) / n;\n#if COLORMAP == 0\n    float rr = sin((uv.x - 0.33) * 3.141592);\n    float gg = sin((uv.x + 0.00) * 3.141592);\n    float bb = sin((uv.x + 0.33) * 3.141592);\n    float ss = (1.0 - uv.x) * (1.0 - uv.x) * PURPLE_FACTOR;\n    float r = clamp(rr * (1.0 - RED_FADE * bb * bb) + ss, 0.0, 1.0);\n    float g = clamp(gg * (1.0 - 1.0 * rr * rr * bb * bb), 0.0, 1.0);\n    float b = clamp(bb * (1.0 - BLUE_FADE * rr * rr), 0.0, 1.0);\n#elif COLORMAP == 1\n    float r = sqrt(clamp(sin((uv.x - 0.5) * 3.141592), 0.0, 1.0));\n    float g = sqrt(clamp(sin((uv.x + 0.0) * 3.141592), 0.0, 1.0));\n    float b = sqrt(clamp(sin((uv.x + 0.5) * 3.141592), 0.0, 1.0));\n#endif\n    fragColor = vec4(r, g, b, 1.0);\n}","name":"Image","description":"","type":"image"}]}