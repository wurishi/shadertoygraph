{"ver":"0.1","info":{"id":"ds3BDH","date":"1697104865","viewed":56,"name":"print10 inspired scrolling","username":"HaleyHalcyon","description":"a","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["commodorevic20"],"hasliked":0,"parentid":"cscBDr","parentname":"print10 inspired"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float nextPow2(float x) {\n    return exp2(\n        ceil(\n            log2(x)\n        )\n    );\n}\n\n#define HEX(x) vec3( ( ivec3(x) >> ivec3(16,8,0) ) & 255 ) / 255.\n\nvec3 color(float x){\n    const int colorCount = 8;\n    vec3[] c = vec3[](\n        HEX(0xb810b0),\n        HEX(0xe020c0),\n        HEX(0xf0e040),\n        HEX(0xc0ff80),\n        vec3(1),\n        HEX(0xa0ffe0),\n        HEX(0x7080F0),\n        HEX(0x8000a0)\n    );\n    x *= float(colorCount);\n    int lo = 1048576 + int(floor(x));\n    \n    return mix(\n        c[lo % colorCount],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}\n\n// random ints from 0 to 255\nint _rand[] = int[] (\n244,\t69,\t224,\t39,\t208,\t151,\t201,\t255,\t189,\t202,\t157,\t92,\t206,\t154,\t199,\t194,\t232,\t101,\t216,\t134,\t62,\t242,\t163,\t248,\t140,\t183,\t120,\t90,\t215,\t30,\t211,\t186,\t150,\t100,\t57,\t106,\t118,\t142,\t61,\t246,\t11,\t230,\t141,\t55,\t147,\t180,\t27,\t226,\t99,\t125,\t122,\t13,\t2,\t112,\t192,\t60,\t137,\t80,\t198,\t252,\t94,\t245,\t162,\t113,\t24,\t146,\t49,\t110,\t253,\t81,\t10,\t165,\t109,\t115,\t218,\t0,\t254,\t129,\t71,\t88,\t187,\t114,\t176,\t243,\t7,\t87,\t45,\t209,\t23,\t168,\t103,\t121,\t93,\t153,\t22,\t133,\t34,\t78,\t241,\t182,\t221,\t38,\t136,\t104,\t18,\t105,\t164,\t65,\t91,\t25,\t132,\t119,\t174,\t173,\t15,\t170,\t29,\t37,\t212,\t210,\t44,\t169,\t181,\t251,\t4,\t8,\t229,\t79,\t32,\t21,\t203,\t214,\t75,\t12,\t225,\t97,\t40,\t35,\t28,\t64,\t231,\t19,\t185,\t123,\t236,\t77,\t238,\t5,\t128,\t179,\t127,\t48,\t72,\t156,\t190,\t54,\t124,\t250,\t205,\t161,\t228,\t56,\t158,\t207,\t148,\t17,\t95,\t52,\t111,\t126,\t36,\t74,\t197,\t152,\t160,\t20,\t219,\t130,\t66,\t239,\t240,\t6,\t108,\t47,\t116,\t213,\t237,\t138,\t70,\t33,\t26,\t46,\t96,\t53,\t41,\t200,\t59,\t58,\t135,\t83,\t235,\t31,\t131,\t63,\t42,\t1,\t149,\t139,\t247,\t9,\t159,\t73,\t98,\t222,\t68,\t51,\t67,\t144,\t82,\t233,\t177,\t155,\t178,\t50,\t143,\t84,\t184,\t85,\t217,\t166,\t193,\t145,\t89,\t107,\t172,\t76,\t117,\t196,\t86,\t220,\t3,\t171,\t223,\t16,\t167,\t195,\t191,\t102,\t14,\t188,\t227,\t234,\t204,\t249,\t43,\t175\n);\n\nint randMask(int x, int y, int t) {\n    return 1 & (\n        _rand[255 & (\n            x + _rand[\n                255 & (\n                    y + _rand[\n                        255 & t\n                    ]\n                )\n            ]\n        )]\n    );\n}\n\n// The width of the lines, from 0.0 to 0.5\nconst float LINE_WIDTH = 0.12;\n\n// How many tiles in the repeating pattern.\n// Set this to 256,256 if disabling.\n// (the random numbers only go to up 255)\nconst ivec2 LOOP = ivec2(32, 32);\n\n// Whether to scroll the grid.\n#define SCROLL_GRID 1\n\n// How many tiles to move by.\n// Unless randomizing by time, keep this equal to LOOP a or multiple.\n// Positive is bottom left.\n#if SCROLL_GRID == 1\nconst ivec2 SCROLL_BY = ivec2(0, -16);\n#endif\n\n// After how many seconds to loop the animation\nconst float DURATION = 4.;\n\n// Whether to randomize based on time.\n// -1 is “no”.\n// Any other value is how many bits to shift the frame number by.\nconst int RAND_BY_TIME = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / DURATION);\n    // Pixels per tile. Formerly a const.\n    // Made not-const to take into account\n    // the current canvas size.\n    float fGRID_PX = nextPow2(\n        min(iResolution.y, iResolution.x)\n        / 32.\n    );\n    // Used for the grid.\n    vec2 uv = fragCoord / fGRID_PX;\n#if SCROLL_GRID == 1\n    uv += t * vec2(SCROLL_BY);\n#endif\n    // Used for the background effects.\n    vec2 uv2 = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    // Smoothing of the lines.\n    float w = 0.75 / fGRID_PX;\n    // Mask to use if the current cell is \\.\n    float bMask = smoothstep(\n        LINE_WIDTH + w, LINE_WIDTH - w,\n        abs(fract(uv.y + uv.x + .5) - .5)\n    );\n    // Mask to use if the current cell is /.\n    float fMask = smoothstep(\n        LINE_WIDTH + w, LINE_WIDTH - w,\n        abs(fract(uv.y - uv.x + .5) - .5)\n    );\n    // Brightness of the current cell.\n    int frame = 0;\n    if (RAND_BY_TIME >= 0) {\n        frame = iFrame >> RAND_BY_TIME;\n    }\n    float v = \n        mix(\n            bMask,\n            fMask,\n            float(randMask(\n                (256 + int(floor(uv.x))) % LOOP.x,\n                (256 + int(floor(uv.y))) % LOOP.y,\n                frame\n            ))\n        )\n    ;\n\n    vec3 col = color(\n        -0.6 * log(0.1 + length(uv2)) +\n        iTime\n    ) * v;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}