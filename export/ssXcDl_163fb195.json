{"ver":"0.1","info":{"id":"ssXcDl","date":"1643916972","viewed":227,"name":"Timely Focus","username":"UnstableLobster","description":"Each soul converges at its own pace\nAnd all paths shall eventually return back to the light  ","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Forward pathtracer\n    Infinite bounces, one per frame\n    Multiple paths per frame\n*/\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{  \n    SET_GLOBALS\n\n    O = B(pos);\n    O.xyz *= 60.0;\n    O = pow(O, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define texelLoop(a, p) texelFetch(a, ivec2(mod(p,R)), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define textureLoop(a, p) texture(a, mod(p,R)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define A(p) texel(ch0, p)\n#define B(p) texel(ch1, p)\n#define C(p) texel(ch2, p)\n#define D(p) texel(ch3, p)\n\n#define PI 3.14159265\n#define E 2.71828182846\n\n#define loop(i,x) for (int i = 0; i < x; i++)\n#define range(i, a, b) for (int i = a; i <= b; i++)\n\n#define snormalize(x) ((length(x) > 0.0) ? normalize(x) : x)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\n\n//----------//\n// Settings //\n//----------//\n#define maxPaths min(500, int(R.y))\n#define normalOffset 0.0003\n\n\n\n//---------//\n// Globals //\n//---------//\n#define SET_GLOBALS R = iResolution.xy; time = iTime; mouse = iMouse; deltaTime = iTimeDelta; tTime = float(iFrame)*(1.0/60.0);\nvec2 R;\nvec4 mouse;\nfloat time;\nfloat deltaTime;\nfloat tTime;\n\n\n\n//-------//\n// Scene //\n//-------//\n#define DIFFUSE 0\n#define MIRROR 1\n#define CLEAR 2\n#define FOG 3\n#define ABSORB 4\n\n#define WHITE vec3(1.0)\n\nstruct mapData\n{\n    float d;\n    float em;\n    int id;\n    vec3 color;\n    float density;\n    float ior;\n\n};\n\n//-- Shapes --\nfloat sdEquilateralTriangle( in vec2 p, float d)\n{\n    p /= d;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y) * d;\n}\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\nfloat sdSphere(vec2 p, float s)\n{\n     return length(p) - s;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n#define dot2(x) dot(x, x)\nfloat sdHeart( in vec2 p, float d )\n{\n    p /= d;\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return (sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0) * d;\n    return (sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y)) * d;\n}\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdBlobbyCross( in vec2 pos, float d, float he )\n{\n    pos /= d;\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y) * d;\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang),\n                sin(ang), cos(ang)); \n}\n\n//-- Operations\nmapData opSubstraction(mapData a, mapData b)\n{\n    b.d *= -1.0;    \n    if (a.d > b.d)\n        return a;\n    return b;\n}\nmapData opInnerUnion(mapData a, mapData b)\n{\n    if (abs(a.d) < abs(b.d))\n        return a;\n    return b;\n}\nmapData opUnion(mapData a, mapData b)\n{\n    if (a.d < b.d)\n        return a;\n    return b;\n}\n\n//-- Map\nmapData data;\nfloat map(vec2 p)\n{\n    mapData r = mapData(99999.9, 0.0, DIFFUSE, WHITE, 0.0, 1.0);\n\n    //light\n    //r = opUnion( r, mapData(sdSphere(p - vec2(3.4, 1.6)*1.6*0.1, 0.001), 1.0, DIFFUSE) );\n    //r = opUnion( r, mapData(sdSegment(p, vec2(-1.0, -3.0)*0.1, vec2(-2.0, -2.0)*0.1)-0.5*0.1, 0.025, DIFFUSE) );\n    //r = opUnion( r, mapData(sdSegment(p - vec2(15.0, -1.0), vec2(-1.0, -3.0), vec2(-2.0, -2.0))-0.5, 0.025, DIFFUSE) );\n    \n    //focus\n    r = opUnion( r, mapData(sdSphere(p - vec2(3.0, 2.0)*0.1, 1.55*0.1), 0.0, CLEAR, WHITE, 0.0, 1.62) );\n    r = opUnion( r, mapData(sdSphere(p - vec2(6.2, 1.5)*0.1, 0.85*0.1), 0.0, CLEAR, WHITE, 0.0, 1.6) );\n    \n    //mirror\n    r = opUnion( r, mapData(sdBox((p - vec2(-0.52, 0.0))*rot(0.1), vec2(0.15)), 0.0, MIRROR, WHITE, 0.0, 1.6) );\n    \n    //heart\n    r = opUnion( r, mapData(sdHeart(p - vec2(0.0, -0.275), 0.25), 0.0, ABSORB, saturate(vec3(1.000,0.753,0.796)*1.)*0.995, 100.0, 1.6) );\n    \n    \n    vec2 dir = normalize(vec2(6.2, 1.5)*0.1 - vec2(3.4, 1.6)*1.6*0.1)*0.15;\n    \n    //vesica\n    r = opUnion( r, mapData(sdVesica(p - vec2(0.825, -0.2)-dir, 0.1, 0.06), 0.0, CLEAR, WHITE, 0.0, 1.6) );\n    \n    //prism\n    r = opUnion( r, mapData(sdEquilateralTriangle((p - vec2(0.82, -0.2)-dir)*rot(0.8), 0.1), 0.0, CLEAR, WHITE, 0.0, 1.6) );\n    \n    //cubes\n    r = opUnion( r, mapData(sdBox(p - vec2(0.46, 0.0) + vec2(0.01, 0.0), vec2(0.1, 0.02)), 0.0, DIFFUSE, WHITE, 0.0, 1.6) );\n    r = opUnion( r, mapData(sdBox(p - vec2(0.46, 0.4) + vec2(0.01, 0.0), vec2(0.1, 0.02)), 0.0, DIFFUSE, WHITE*0.0, 0.0, 1.6) );\n    \n    //moon\n    r = opUnion( r, mapData(sdVesica((p - vec2(0.68, 0.3))*rot(-0.32), 0.1, 0.06), 0.0, CLEAR, WHITE, 0.0, 1.8) );\n    r = opUnion( r, mapData(sdMoon((p - vec2(0.83, 0.4))*rot(-0.2), -0.05, 0.15, 0.13), 0.0, MIRROR, WHITE, 0.0, 2.4) );\n     \n    /*r = mapData(99999.9, 0.0, DIFFUSE, WHITE, 0.0);\n    r = opUnion( r, mapData(sdEquilateralTriangle(p, 0.4), 0.0, CLEAR, WHITE, 0.0) );*/\n    \n\n    data = r;\n    \n    return r.d;\n}\n\n\n\n\n\n\n//------//\n// Rays //\n//------//\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    return unpackSnorm2x16(X);\n}\n\nfloat encode(vec2 x)\n{\n    uint X = packSnorm2x16(x);   \n    return uintBitsToFloat(X); \n}\n\nstruct ray\n{\n    vec2 o;\n    vec2 d;\n    vec3 e;\n};\n    \nray getRay(vec4 data)\n{\n    ray r;\n    \n    r.o = decode(data.x)*2.5;\n    r.d = decode(data.y);\n    r.e = vec3(decode(data.z), decode(data.w).x)*1.0;\n    \n    return r;\n}\n\nvec4 saveRay(ray r)\n{\n    return vec4(encode(r.o/2.5), encode(r.d), encode(r.e.xy/1.0), encode(vec2(r.e.z)/1.0));\n}\n\n\n\n\n\n\n\n\n\n//-------------\n// RNG https://www.shadertoy.com/view/wltcRS\n//-------------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nvec4 deRand(vec2 p, int frame)\n{\n    uvec4 t = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    pcg4d(t);\n    return vec4(t)/float(0xffffffffu);\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//-------------//\n// Raymarching //\n//-------------//\nvec2 normal(vec2 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec2\n    (\n        map(p+e.xy) - map(p-e.xy),\n        map(p+e.yx) - map(p-e.yx)\n    ));\n}\n\nbool march(vec2 ro, vec2 rd, out float t)\n{\n    t = 0.0;    \n    loop(i, 300)\n    {\n        float d = map(ro + rd*t); \n        //if (data.id == CLEAR)\n            //d = abs(d);      \n        t += abs(d);\n        \n        if (abs(d) < 0.0000001) return true;\n        if (t > 5.0)  return false;\n    }\n    return false;\n}\n\n\n\n\n//----------//\n// Sampling //\n//----------//\nfloat fresnel(vec2 I, vec2 N, vec2 iorFT) \n{ \n    float cosi = abs(dot(I, N));\n    float etai = iorFT.x;\n    float etat = iorFT.y; \n\n    float sint = etai / etat * sqrt(1.0 - cosi * cosi); \n    if (sint >= 1.0) return 1.0;\n\n    float cost = sqrt(max(0.0, 1.0 - sint * sint)); \n    float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n    float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n    return (Rs * Rs + Rp * Rp) * 0.5; \n}\n\n//-- Random Directions --\nvec2 cosineDirection(vec2 N)\n{\n    float s = rand() * 2.0 - 1.0;\n    float c = sqrt(1.0 - s*s);    \n    return normalize(N * c + vec2(-N.y, N.x) * s);\n}\nvec2 circleDirection()\n{\n    float x = rand()*2.0*PI;\n    return normalize(vec2(cos(x), sin(x)));\n}\nvec2 hemicircleDirection(vec2 N)\n{\n    vec2 s = circleDirection();\n    return s * sign(dot(s, N));\n}\n\n//-- Microfacet --\nfloat sampleVisibleNormal(float thetaMin, float thetaMax, float r)\n{\n    float a = tanh(thetaMin/(2.0*r));\n    float b = tanh(thetaMax/(2.0*r));\n    return 2.0*r*atanh( mix(a, b, rand()) );\n}\nvec2 roughNormal(vec2 I, vec2 N, float r)\n{\n    vec2 T = vec2(-N.y, N.x);\n    float sinAngle = dot(I, T);\n\n    float thetaMin = max(asin(sinAngle), 0.0) - PI*0.5;\n    float thetaMax = min(asin(sinAngle), 0.0) + PI*0.5;\n    \n    float thetaM = sampleVisibleNormal(thetaMin, thetaMax, r);\n    vec2 local = vec2(cos(thetaM), sin(thetaM));  \n    return normalize(N*local.x + T*local.y);\n\n}\nvec2 test(vec2 N, float r)\n{\n    if (rand() < 0.2)\n        N *= -1.0;\n\n    float thetaM = sampleVisibleNormal(PI*0.5, -PI*0.5, r);\n    vec2 local = vec2(cos(thetaM), sin(thetaM));  \n\n    return normalize(N*local.x + vec2(-N.y, N.x)*local.y);\n}\n\n//-- Sampling --\nvoid sampleDiffuse(vec2 normal, vec2 pos, inout ray r)\n{\n    r.d = cosineDirection(normal);\n    r.o = pos + r.d * normalOffset;\n    r.e *= data.color;\n    r.e *= 0.9;\n}\nvoid sampleMirror(vec2 normal, vec2 pos, inout ray r)\n{\n    //normal = roughNormal(r.d, normal, 0.05);\n    r.d = reflect(r.d, normal);\n    r.o = pos + r.d * normalOffset;\n    r.e *= data.color;\n    r.e *= 0.99;\n    if (data.d < 0.0) r.e *= 0.0;\n}\nfloat getRefractionIndex(float w)\n{\n    float wl = w/1000.0;\n    //return 1.55 + 0.05/(wl*wl);\n    return data.ior + 0.025/(wl*wl);\n}\nvoid sampleDielectric(vec2 normal, vec2 pos, float w, inout ray r)\n{\n    float ior = getRefractionIndex(w);\n    float cosi = dot(r.d, normal);\n    vec2 etav = (cosi < 0.0) ? vec2(1.0, ior) : vec2(ior, 1.0);\n    float eta = etav.x/etav.y;\n    vec2 lnormal = normal * -sign(cosi);\n    //lnormal = roughNormal(r.d, lnormal, 0.0);\n    \n    float f = fresnel(r.d, lnormal, etav);\n    \n    if (rand() > f) r.d = refract(r.d, lnormal, eta);\n    else            r.d = reflect(r.d, lnormal);\n    r.o = pos + r.d * normalOffset;\n    r.e *= data.color;\n    r.e *= 0.95;\n}\nvoid sampleAbsorb(vec2 normal, vec2 wpos, float w, float t, inout ray r)\n{\n    if (data.d > 0.0 && dot(r.d, normal) < 0.0) // Enter\n        sampleDielectric(normal, wpos, w, r); \n    else\n    {   \n        float lt = -log(rand()) / data.density;\n        lt = min(t, lt);\n        r.o = r.o + r.d*lt;\n\n        if (lt < t)\n            r.e *= data.color;\n        else\n            sampleDielectric(normal, wpos, w, r); \n    }\n}\n\n\n//----------\nbool reset(ray r)\n{\n    return (iFrame == 0 || length(r.e) < 0.0001);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid setRay(inout ray r, inout float w)\n{\n    r.o = vec2(3.4, 1.6)*1.6*0.1;\n    r.d = circleDirection();\n    \n    if (rand() < 0.0)\n    {\n        r.o = vec2(-0.5, 0.0);\n        r.d = normalize(vec2(2.0, 1.0));\n    }\n    \n    float t = (w - 340.0) / 390.0;\n    t = mix(0.05, 1.0, t);\n    r.e = pal(pow(t, 0.5), vec3(0.5),vec3(0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) )*0.1;\n    \n    if (t > 0.8) r.e.z *= 0.0;\n    r.e *= normalize( vec3(0.54, 0.42, 0.95) );\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{  \n    SET_GLOBALS\n    rng_initialize(pos, iFrame);\n    \n    //pos = floor(pos);\n         \n    ivec2 id = ivec2(pos);\n    if (id.x > 1 || id.y >= maxPaths) return;\n\n    ray r = getRay(A(id));\n    r.d = normalize(r.d);\n    \n    int frame = int(B(pos).w);\n    float w = mix(340.0, 730.0, deRand(pos, frame).y);  \n    \n    //current bounce\n    if (id.x == 0 && id.y < maxPaths && reset(r))\n        setRay(r, w);\n    //previous bounce\n    else if (id.x == 1 && id.y < maxPaths)\n    {\n        ray rt = getRay(A(ivec2(0, pos.y)));\n        \n        if (reset(rt))\n        {\n            rng_initialize(vec2(0.0, pos.y), iFrame);\n            int frame = int( B(vec2(0.0, pos.y)).w );\n            float w = mix(340.0, 730.0, deRand(vec2(0.0, pos.y), frame).y);\n            setRay(rt, w);\n        }\n        \n        O = saveRay(rt);\n        return;\n    }\n\n    float t;\n    if (march(r.o, r.d, t))\n    {\n        vec2 wpos = r.o + r.d*t;\n        vec2 wnormal = normal(wpos);\n        \n        map(wpos);\n        \n        if (data.id == DIFFUSE)      sampleDiffuse(wnormal, wpos, r);\n        else if (data.id == MIRROR)  sampleMirror(wnormal, wpos, r);\n        else if (data.id == CLEAR)   sampleDielectric(wnormal, wpos, w, r); \n        else if (data.id == ABSORB)  sampleAbsorb(wnormal, wpos, w, t, r);\n        else if (data.id == FOG)\n        {   \n            if (data.d > 0.0 && dot(r.d, wnormal) < 0.0) // Enter\n                r.o = wpos + r.d * normalOffset;\n            else\n            {   \n                float lt = -log(rand())/10.0 / ((1.0+w*0.001));\n                //float lt = -log(rand()) / (25.0 + (w)*0.0001);\n                lt = min(t, lt);\n\n                r.o = r.o + r.d*lt;\n                \n                if (lt < t)\n                {\n                    r.d = test(r.d, 0.5);\n                    r.e *= data.color * 0.99;\n                }\n                else\n                    r.o += r.d * normalOffset;\n                \n            }\n        }\n    }\n    else\n    {\n        r.o = r.o + r.d*2.0;\n        r.e = vec3(0.0);\n    }\n        \n    O = saveRay(r);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define mixSDF(a, b, t, r) mix(a, b, saturate(-t*r))\n\nbool reset(ray r)\n{\n    return (length(r.e) < 0.0001);\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{  \n    SET_GLOBALS\n    \n    O = B(pos);\n    float w = B(R-1.0).w;\n        \n    if (iFrame == 0)\n    {\n        O = vec4(0.0);\n        w = 0.0;\n    }\n    \n    vec2 uv = (pos-R*0.5)/(R.x*0.5); \n\n    float ratio = R.x*0.5;\n    float pixel = 1.0 / ratio;\n    \n    for (int i = 0; i < maxPaths; i++)\n    {\n        float fi = float(i);\n        \n        if (reset(getRay(A(ivec2(1, fi))))) continue;\n\n        ray a =  getRay(A(ivec2(0, fi)));\n        ray b =  getRay(A(ivec2(1, fi)));\n        float d = sdSegment(uv, a.o, b.o) - pixel;\n        \n        vec3 l = mixSDF(vec3(0.0), vec3(1.0), d, ratio) * b.e * ratio;    \n        \n        //remove line overlap\n        float s = length(uv - a.o) - pixel*1.1;\n        l = mixSDF(l, vec3(0.0), s, ratio);   \n\n        O.xyz = mix(O.xyz, l, 1.0 / (1.0+w) );\n        w += 1.0;\n    }\n    \n    //--\n    ivec2 id = ivec2(pos);\n    \n    //track total path draw count\n    if (id.x == int(R.x)-1 && id.y == int(R.y)-1)\n        O.w = w;\n    \n    //track path index\n    if (id.x == 0 && id.y < maxPaths)\n    {   \n        ray r = getRay(A(pos));   \n\n        if (length(r.e) < 0.0001)\n            O.w = floor(O.w +1.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}