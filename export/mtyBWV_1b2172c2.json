{"ver":"0.1","info":{"id":"mtyBWV","date":"1702486605","viewed":64,"name":"illusion in space","username":"nayk","description":"stars,space,rotate copy past","likes":4,"published":1,"flags":1,"usePreview":0,"tags":["rotate","space","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* /*original https://www.shadertoy.com/view/lslyRn, /* original https://www.shadertoy.com/view/lsyXDK https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DlycWR and other*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define TAU 6.28318530718\n\nconst vec4 colmod = vec4(0.0, 0.3, 1.0, 0.0);\nconst float freq = 3.0;\nconst float N = 10.0;\n\nmat2 scale(vec2 scl, float stretch) {\n    vec2 _scl = (vec2(1.0) / scl);\n\n    return mat2(\n        _scl.x, stretch,\n        stretch, _scl.y\n   \n    );\n}\n\nmat2 rotate(float angle) {\n    return mat2(\n        cos(angle),-sin(angle),\n        sin(angle),cos(angle)\n    );\n}\n\n#define C(t) ( vec3(1.5,.6,.6) + vec3(1.25,.38,-2.5) * cos(6.28318*(vec3(-3.142,-3.223,2)*(t)+vec3(.31,-1.42,1.75)))) //\n#define CS(a) vec2(cos(a),sin(a))\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam;\n p.xy*=mat2(cos(iTime*0.04),sin(iTime*0.04),-sin(iTime*0.04),cos(iTime*0.04));// the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.2-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.02,1.);\n}\n#define TAU2 radians(360.)\n\n//#define AUDIOREACT\n\nconst float nbCircle = 13.;\n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nfloat udTriangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n  vec2 ab = b - a; vec2 pa = a - p;\n  vec2 bc = c - b; vec2 pb = b - p;\n  vec2 ca = a - c; vec2 pc = c - p;\n   \n  float d0 = dot(perp(ab), pa);\n  float d1 = dot(perp(bc), pb);\n  float d2 = dot(perp(ca), pc);\n   \n  return min(min(d0, d1), d2);\n}\n\nfloat sdfTriangle(vec2 p)\n{\n    float radius = 1.2;\n    float angle = iTime * 0.8;\n    vec2 a = rotate( angle, radius);\n    vec2 b = rotate( TAU / 3. + angle, radius);\n    vec2 c = rotate( 2. * TAU / 3. + angle, radius);\n   \n    return udTriangle(p, a, b, c);\n}\n\nfloat radFilter(float v)\n{\n    return smoothstep(100. / iResolution.y, 0., abs(v-1.));\n}\n\nfloat distFilter(float v)\n{\n    return smoothstep(0., 0.5, v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\n    // Camera / ray setup\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\nconst float pi = 3.14159265358979323;\n\n\n    // Parameters\n    vec2 range = vec2(1.01, 4.);\n\n    float cameraSphereDistance = mix(range.x, range.y, .5 + .5 * cos(iTime));\n   \n    if(iMouse.z > .5)\n        cameraSphereDistance = mix(range.x, range.y, iMouse.x / iResolution.x);\n   \n    // Problem geometry\n    float innerConeHalfAngle = acos(1. / cameraSphereDistance);\n    float outerConeHalfAngle = pi / 2. - innerConeHalfAngle;\n    float b = sqrt(cameraSphereDistance * cameraSphereDistance - 1.);\n    float c = cos(outerConeHalfAngle) * b;\n    float e = sin(innerConeHalfAngle);\n\n    // Camera / ray setup\n \n    vec3 ro = vec3(0, 0, cameraSphereDistance), rd = normalize(vec3(uv * e * 1.2, -c));\n   \n    vec3 col = vec3(0);\n\n    // Ray-sphere intersection\n    vec2 is = vec2(1, 0);\n   \n    {\n       float b = 2. * dot(rd, ro);\n       float c = cameraSphereDistance * cameraSphereDistance - 1.;\n       float desc = b * b - 4. * c;\n       if (desc >= 0.)\n           is = (sqrt(desc) * vec2(-1, 1) - b) / 2.;\n    }\n\n    // Environment texture\n   \nvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float angle = atan(p.y, p.x);\n    float l = length(p) * nbCircle;\n    float circleId = floor(l);\n    #ifdef AUDIOREACT\n    float s = texture(iChannel0, vec2(0.5, 1. - circleId / nbCircle)).x;\n    #else\n    float s = 0.6;    \n    #endif\n    float modCircleId = mod(circleId, 2.);\n    float d = sdfTriangle(p);\n    d = distFilter(d);\n    float speed2 = mix(0.1, -0.1, modCircleId);\n    l+= sin((angle - iTime * speed2) * circleId * 5.) * 0.5 * d * s;\n    l = fract(l) * 2.;\n    float t2 = min(l, 2. - l);\n    t2 = radFilter(t2);\n    if(is.x > 0. && is.x <= is.y)\n    {\n        // Surface texture\n        vec3 rp = ro + rd * is.x;\n        rp.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n       rp.xy*=ma;\n        vec2 uv = vec2(atan(rp.z, rp.x), asin(rp.y)) / pi * 3.;\n        col = 1.5 + .5 * vec3(step(.5, fract(uv.x * 3. +\n                        .5 * step(.5, fract(uv.y * 3.)))));\n   \n    }\n\n  vec4 color = vec4(0.0);\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n\n\n    uv *= ratio; uv += 0.5;\n    vec4 O=fragColor;\n    vec2 u =fragCoord;\n   vec2 W = iResolution.xy,\n         U = (u - .5 * W) / W.y;\n\n  \n\n \n   \n    vec2 translate, uv2;\n   \n    for ( float i = 1.0; i <= N; i++ ) {        \n        float x = step(2.0, i);\n   \n        translate = vec2(\n            cos(iTime*0.1 + i) * i,\n            sin(iTime*0.1+ i)\n        );\n       \n        uv2 = uv + translate * 0.3;\n        color += 0.01/distance(uv2, vec2(0.5)) * i / 4.0;\n    }\n   \n \n    color += 0.01/distance(uv, vec2(0.5)) * 1.0;\n   \n   \n    // Jets\n    float f = sin(iTime * freq*0.1);\n   \n    uv -= 2.5;\n    uv *= rotate( TAU + (f / 5.0) );\n    uv *= scale( vec2(1.1), 1.05 + (f / 15.0));\n    uv += 0.5;\n   \n    float jd = distance(uv, vec2(0.5));\n    color += 0.01/jd * 1.0;\n   \n    // Setting color\n    fragColor = color * colmod;\n    fragColor+=O;\nvec3 from=vec3(1.,.5,0.5)*col+d;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n}\n\n","name":"Image","description":"","type":"image"}]}