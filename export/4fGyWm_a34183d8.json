{"ver":"0.1","info":{"id":"4fGyWm","date":"1731937423","viewed":88,"name":"procedural 2d lines ","username":"ademdj12","description":"this shader is for generating infinite field of lines connected and disconnected","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","line"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(\n        pointSpace(fragCoord + vec2(100., 0.) * iTime, iTime)\n    );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define QuadSize 10.\n#define seed 12.\n#define density .6\n// line sdf from :\n// https://www.shadertoy.com/view/3tdSDj\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn 1.-length(pa - h * ba);\n}\n\n\n// hash functions from :\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p = p + seed;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n    p = p + seed;\n\tvec3 p3 = fract((vec3(p.xyx)) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nfloat pointSpace(vec2 pos, float time){\n    \n    // curent pixel is inside ownerQuad\n    vec2 ownerQuadPos = (floor(pos / QuadSize))* QuadSize;\n    // for each quad there is a point \n    vec2 owenerGlobalPointPos = ownerQuadPos + hash22(ownerQuadPos) * QuadSize;\n    \n    // drawing lines\n    float lines = 0.0;\n\n    for(int i = 1; i < 9; i += 2){\n    \n        // calculating neighbor Quad position offset\n        vec2 offsetCord = vec2( (i % 3) - 1 , floor(float(i)/3.) - 1. );\n        // calculating neighbor Quad position\n        vec2 currentQuadPos = (offsetCord + floor(pos / QuadSize))* QuadSize;\n        // checking is neighbor quad is empty (cannot connect to)\n        if(hash12(currentQuadPos)<density || hash12(ownerQuadPos)<density ) continue;\n        // calculating the neighbor's point\n        vec2 globalPointPos = currentQuadPos + hash22(currentQuadPos) * QuadSize;\n        \n        \n        lines = max(line_segment(pos,globalPointPos,owenerGlobalPointPos),lines);\n    }\n    \n    \n    return lines;\n}","name":"Common","description":"","type":"common"}]}