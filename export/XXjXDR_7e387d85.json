{"ver":"0.1","info":{"id":"XXjXDR","date":"1710462451","viewed":110,"name":"Voronoi Walk on Spheres Gradient","username":"chronos","description":"Voronoi Walk on Spheres Gradient","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["grid","visualization","vector"],"hasliked":0,"parentid":"43jXDR","parentname":"Vector Grid Visualization"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Voronoi Walk on Spheres Gradient by chronos\n    ----------------------------------------------------\n    \n    Performing a walk on spheres on a distance field given by points on a jittered grid.\n    \n    Each voronoi cell node has a random value, which the walk on spheres algorithm interpolates.\n    \n    The result was a bit boring to look at so instead I used the direct gradient estimator given\n    in the siggraph paper \"Monte Carlo Geometry Processing:A Grid-Free Approach to PDE-Based Methods on Volumetric Domains\"\n    by Rohan Sawhney and Keenan Crane.\n\n    In principle, a walk on spheres on the jittered grid should be a bit more interesting than some other interpolations\n    because the walk isn't restricted to the cell neighborhood, it can go arbitrarily far,\n    albeit with lower probability the further it goes.\n\n*/\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nvec3 gradient_to_color(vec2 g)\n{\n    vec2 n = normalize(g);\n    float l = length(g);\n    vec3 N = normalize(vec3(10.*g, exp(-l*l * PI)));\n    return .5*N + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 bufA = texture(iChannel0, uv);\n    \n    // Note: Toggling SHOW_GRADIENT requires restart. ( see Common tab)\n    #if SHOW_GRADIENT\n    vec2 gradient = bufA.rg / bufA.a;\n    vec2 p = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec3 color = gradient_to_color(gradient);\n    #else\n    vec3 color = bufA.rgb / bufA.a;\n    #endif\n    \n    color = sRGBencode(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// RGB: color field\n// A: distance field\nvec4 field(vec2 p)\n{    \n    // initialize return values\n    vec3 color = vec3(0);\n    float sdf = 9e9;\n    \n    // Draw field\n    vec2 vor = voronoi(p);\n    color += vor.x;\n    sdf = vor.y;\n    \n    return vec4(color, sdf);\n}\n\nvec2 random_point_on_circle(vec2 center, float radius, float rnd)\n{\n    float angle = 2. * PI * rnd;\n    return radius * vec2(cos(angle), sin(angle)) + center;\n}\n\nvec4 march(vec2 p, int i)\n{\n    int total_steps_per_frame = max_steps * samples_per_frame;\n    for(int j = 0; j < max_steps; j++)\n    {\n        vec4 fieldval = field(p);\n\n        float dist = fieldval.a;\n\n        if(dist < threshold)\n        {\n            return vec4(fieldval.rgb, 1);\n        }\n\n        float rnd = hash(vec3(p, float(j + i * max_steps)/float(total_steps_per_frame) + float(iFrame)));\n        p = random_point_on_circle(p, abs(dist), rnd );\n    }\n    \n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 5.;\n    vec2 uv = zoom * (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = zoom * (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ps = zoom * 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    int total_steps_per_frame = max_steps * samples_per_frame;\n\n    float hitcount = 0.;\n\n    for(int i = 0; i < samples_per_frame; i++)\n    {\n        vec2 p = uv;\n        \n        #if SHOW_GRADIENT\n        vec4 fieldval = field(p);\n\n        float dist = fieldval.a;\n\n        float rnd = hash(vec3(p, iFrame * samples_per_frame + i));\n        p = random_point_on_circle(p, abs(dist), rnd );\n        \n        vec2 n = normalize(p - uv);\n        vec3 N = vec3(n, 0.);\n        #else\n        vec3 N = vec3(1);\n        #endif\n        \n        vec4 march_result = march(p, i);\n        hitcount += march_result.a;\n        color += march_result.rgb * march_result.a * N;\n    }\n    \n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = bufA + vec4(color, hitcount);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SHOW_GRADIENT 1\n\nconst float threshold = 0.00005;\nconst int max_steps = 20;\nconst int samples_per_frame = 25; \nconst float PI = 3.14159265;\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    p-=a; b-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nvec2 voronoi(vec2 p)\n{\n    vec2 grid_id = floor(p);\n    \n    float thickness = 0.02;\n    \n    vec2 nearest = grid_id;\n    float mindist = 9e9;\n    vec2 nearest_offset = vec2(0);\n    for(float i = -1.; i <= 1.; i++)\n    {\n        for(float j = -1.; j <= 1.; j++)\n        {\n            vec2 neighbor = grid_id + vec2(j, i);\n            vec2 point = \n                neighbor +\n                vec2(\n                    hash(vec3(neighbor, 0)),\n                    hash(vec3(neighbor, 1))\n                    );\n                    \n            \n            float d = length(p - point);\n            if(d < mindist)\n            {\n                mindist = d;\n                nearest = point;\n                nearest_offset = vec2(j, i);\n            }\n        }\n    }\n    \n    return vec2(hash(vec3(nearest_offset+grid_id, 0)), mindist);\n}","name":"Common","description":"","type":"common"}]}