{"ver":"0.1","info":{"id":"sdXXzN","date":"1618330428","viewed":39,"name":"HSL regions","username":"jonathanw12","description":"Determines which colours are part of a region in HSL","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n#define DEFAULT_HUE 0.5\n#define CHECKERBOARD_OPACITY 0.7\n#define HEIGHT 0.9\n#define GAP_ONE 0.23\n#define GAP_TWO 0.2\n#define BAR_WIDTH 0.05\n#define BLUR 0.03\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nbool shouldApplyCheckerboard(vec3 hsl) {    \n    if (hsl.y < 0.25) {\n        return true;\n    }\n    \n    if (hsl.x > 0.75 || hsl.x < 0.4) {\n        return true;\n    }\n    \n    if (hsl.z < 0.35) {\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 hsl2rgb(vec3 oldHsl, vec3 checkerboard) { \n    vec3 rgb;\n    \n    vec3 hsl = floor(oldHsl * 20.) / 20.;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    \n    if (shouldApplyCheckerboard(oldHsl)) {\n        return mix(checkerboard, rgb, CHECKERBOARD_OPACITY);\n    }\n    \n    return rgb;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord / iResolution.y;\n    float ratio = iResolution.y / iResolution.x;\n    vec3 color = vec3(1.);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(GAP_ONE + HEIGHT / 2., 0.5) - st;\n    float angle = atan(toCenter.y, toCenter.x);\n    float radius = length(toCenter) * 2.0 / HEIGHT;\n    \n    vec2 barMiddle = vec2(GAP_ONE + HEIGHT + GAP_TWO + BAR_WIDTH, 0.5);\n    float barSd = sdBox(st - barMiddle, vec2(BAR_WIDTH, HEIGHT / 2.));\n\n    vec2 uv = abs(1. - fract(st * 10. + iTime * 0.2) * 2.);\n    vec3 checkerboard = vec3(abs(smoothstep(0.5 - BLUR, 0.5 + BLUR, uv.x) - smoothstep(0.5 - BLUR, 0.5 + BLUR, uv.y)), 0., 1.);\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = mix(vec3(1.), hsl2rgb(vec3((angle / TWO_PI) + 0.5, radius, 0.5), checkerboard), 1. - step(1., radius));\n    color = mix(color, hsl2rgb(vec3(DEFAULT_HUE, 1., (st.y - 0.5) / HEIGHT + 0.5), checkerboard), 1. - step(0., barSd));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}