{"ver":"0.1","info":{"id":"WdtfDf","date":"1606153897","viewed":81,"name":"Transforming Shapes","username":"me_123","description":"It's cool","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float max_steps = 100.;\nfloat max_dist = 300.;\nfloat e = 0.0001;\nfloat camSize = 10.;\nvec3 lightPos = vec3(sin(0.1)*30.,10, cos(1.0)*10.);\nvec3 rep( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nfloat SDF(vec3 p) {\n    vec3 pp = p;//rep(p, 4., vec3(2000));\n    float shape1 = max(smax(box(pp, vec3(2.))-1., -sphere(pp, 0.7), 4.), sphere(p, 3.));\n    float shape2 = box(p, vec3(1.));\n    float shape3 = tor(p, vec2(2., 0.6));\n    float shape4 = sphere(p, 1.0);\n    float stime = (sin(iTime)+1.0)*0.5;\n    float o = mix(shape1+0.4, shape2, clamp(stime, 0.0, 0.2)*5.);\n    o = mix(o, shape3, (clamp(stime, 0.3, 0.6)-0.3)*5.);\n    o = mix(o, shape4, (clamp(stime, 0.7, 0.9)-0.7)*5.);\n    return o;\n}\nvec2 getDist(vec3 ro, vec3 rd) {\n    float d0 = 0.001;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        float ds = SDF(p);\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n            break;\n        };\n       \tc = p;\n    }\n    \n    return vec2(d0, steps);\n}\nvec3 getNormal(vec3 p) {\n    float d = SDF(p);\n    vec2 e = vec2(.0001, 0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy),\n    \tSDF(p-e.yxy),\n    \tSDF(p-e.yyx)\n    );\n    return normalize(n);\n}\nvec3 tex(vec3 p) {\n    vec3 t = vec3((mod(floor(p*4.), 2.)));\n    t = vec3(t.x+t.z, t.x, t.y);\n    return vec3(1);//clamp(t, 0.0, 1.0);\n}\nvec3 getLight(vec3 p, vec3 lightPos, vec3 rd, vec3 ro, vec2 ray) {\n    vec3 lp = normalize(lightPos-p);\n    vec3 norm = getNormal(p);\n    float l = length(p-lightPos)-1.0;\n    float dif = dot(norm, lp)/clamp(l/1., 1., 100.0)*6.;\n    float reflected = clamp(float((dot(reflect(rd, norm), lightPos)) - 10.0), 0.0, 1.0);\n    dif = (dif+(reflected/(l/2.)));\n    if (ray.x < max_dist) {\n        dif += clamp(min(ray.y/100., 0.5), 0.0, 0.25);\n        dif += 0.4;\n    }\n    dif /= 2.;\n    return tex(p)*vec3(clamp(dif, 0.0, 1.0));\n}\nfloat samples = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 mouse = ((iMouse.xy-.5*iResolution.xy)/iResolution.xy)*5.;\n    mouse.x *= iResolution.x/iResolution.y;\n    if (iMouse.x == 0.0) {\n        mouse.x = 0.5;\n    }\n    if (iMouse.y == 0.0) {\n        mouse.y = 0.5;\n    }\n    vec3 ro = vec3(sin(mouse.x)*camSize, (mouse.y)*camSize, cos(mouse.x)*camSize);\n    for (int i = 0; i < int(samples); i += 1) {\n        vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.xy);\n        uv.x *= iResolution.x/iResolution.y;\n        //uv.x += (hash(uv+float(i))-0.5)/(iResolution.y/2.);\n        //uv.y += (hash(uv+1.+float(i))-0.5)/(iResolution.x/2.);\n        vec3 at = vec3(0, 0, 0);\n        vec3 c_z = normalize(at-ro);\n        vec3 c_x = normalize(cross(vec3(0,1,0), c_z));\n        vec3 c_y = cross(c_z, c_x);\n        vec3 rd = normalize(uv.x * c_x + uv.y * c_y + 1.73 * c_z);\n        vec2 ray = getDist(ro, rd);\n        float dist = ray.x;\n        vec3 p = ro+rd*dist;\n        vec3 light = getLight(p, lightPos, rd, ro, ray);\n        vec3 ocol = (light);\n        if (dist < max_dist) {\n        \tocol += sqrt(ocol)/5.;\n            ocol /= 1.25;\n        }\n        col += ocol;\n    }\n    fragColor = vec4(col/samples,1.0);\n} \n","name":"Image","description":"","type":"image"}]}