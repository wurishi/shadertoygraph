{"ver":"0.1","info":{"id":"7lSyWd","date":"1650398115","viewed":114,"name":"sdf tests dai","username":"ph04","description":"a","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MAX_STEP 128\n# define MAX_DEPTH 128.\n# define STEP_SIZE .01\n\nstruct Light {\n    vec3 pos;\n};\n\nstruct Box {\n    vec3 pos;\n    vec3 sides;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n\nstruct Capsule {\n    float radius;\n    vec3 center1;\n    vec3 center2;\n};\n\nstruct Dick {\n    Capsule body;\n    Sphere ball1;\n    Sphere ball2;\n};\n\nfloat planeSDF(vec3 currP) {\n    return currP.y; // axis aligned\n}\n\nfloat boxSDF(vec3 currP, Box box) {\n    vec3 center = currP - box.pos;\n    vec3 flippedP = abs(center);\n    vec3 difference = flippedP - box.sides;\n    \n    return length(vec3(\n        max(difference.x, 0.),\n        max(difference.y, 0.),\n        max(difference.z, 0.)\n    ));\n}\n\nfloat sphereSDF(vec3 currP, Sphere sphere) {\n    return length(sphere.pos - currP) - sphere.radius;\n}\n\nfloat capsuleSDF(vec3 currP, Capsule capsule) {\n    vec3 AB = capsule.center2 - capsule.center1;\n    vec3 AP = currP - capsule.center1;\n    \n    float t = dot(AB, AP) / dot(AB, AB);\n    \n    t = clamp(t, 0., 1.);\n    \n    vec3 projection = capsule.center1 + t * AB;\n    \n    return length(currP - projection) - capsule.radius;\n}\n\nfloat dickSDF(vec3 currP, Dick dick) {\n    float body = capsuleSDF(currP, dick.body);\n\n    float dBall1 = sphereSDF(currP, dick.ball1);\n    float dBall2 = sphereSDF(currP, dick.ball2);\n    \n    return min(min(dBall1, dBall2), body);\n}\n\nmat2 rotation(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat getDistance(vec3 currP) {\n    Capsule body = Capsule(.2, vec3(0, 1.4, 6), vec3(0, 3.2, 6));\n    \n    Sphere ball1 = Sphere(vec3(-.2, 1.3, 6), .3);\n    Sphere ball2 = Sphere(vec3(.2, 1.3, 6), .3);\n    \n    Dick dick = Dick(body, ball1, ball2);\n    \n    Box box = Box(vec3(0, .5, 6), vec3(1, .5, .3));\n\n    float dPlane = planeSDF(currP);\n    float dDick = dickSDF(currP, dick);\n    currP += vec3(0, 0, 1);\n    currP.xz *= rotation(iTime);\n    float dBox = boxSDF(currP, box);\n    \n    return min(dPlane, min(dDick, dBox));\n}\n\nfloat rayMarch(vec3 cam, vec3 pixelRay) {\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n        if (dO > MAX_DEPTH) break;\n    \n        vec3 currP = cam + dO * pixelRay;\n    \n        float dScene = getDistance(currP);\n        \n        if (dScene < STEP_SIZE) break;\n        \n        dO += dScene;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 currP) {\n    vec2 e = vec2(.01, 0);\n    \n    float d = getDistance(currP);\n    \n    vec3 normal = d - vec3(\n        getDistance(currP - e.xyy),\n        getDistance(currP - e.yxy),\n        getDistance(currP - e.yyx)\n    );\n    \n    return normalize(normal);\n}\n\nfloat getLight(vec3 currP) {\n    Light light = Light(vec3(0, 6, 4));\n\n    vec3 normal = getNormal(currP);\n    \n    vec3 lightVector = normalize(light.pos - currP);\n    \n    return clamp(dot(normal, lightVector), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cam = vec3(0, 2, 0);\n    vec3 pixelRay = normalize(vec3(uv.xy, 1));\n    \n    float dS = rayMarch(cam, pixelRay);\n    \n    vec3 currP = cam + dS * pixelRay;\n    \n    float light = getLight(currP);\n    \n    fragColor = vec4(vec3(light), 1.);\n}","name":"Image","description":"","type":"image"}]}