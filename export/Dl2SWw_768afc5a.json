{"ver":"0.1","info":{"id":"Dl2SWw","date":"1676173798","viewed":112,"name":"pseudo-3D clouds test","username":"ianertson","description":"The clouds are not marched or 3D in anyway, just a flat plane.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["test","clouds","pseudo3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO (min(0, int(iTime)))\n#define NEAR 0.003\n#define FAR 200.0\n#define STEPS 128\n\n\nfloat getDist(vec3 p) {\n    float low = noise2D(iChannel3, (p.xz*0.1)+vec2(1.291, -2.84221), 0.9);\n    float high = noise2D(iChannel3, p.xz*0.26, 0.8);\n    float h = (high*0.5)+low;\n    return (p.y+6.) + (h*16.);\n}\n\nfloat getClouds(vec3 rd) {\n    vec2 uv = rd.xz/(0.5*(0.1+abs(rd.y)));\n    uv *= 3.0;\n    float dotup = clamp(max(0.0, dot(rd, vec3(0, 0.3, 0)))*20., 0.0, 1.0); \n    float tim = T*0.5;\n    float timeRand = noise2D(iChannel3, vec2(tim*0.001));\n    float region = noise2D(iChannel3, (uv*1.6)+(3.0*vec2((cos(tim*timeRand))+timeRand, timeRand+(sin(tim*timeRand)))), 0.6);\n    float empty = noise2D(iChannel3, (((uv+region+timeRand)-(2.0*vec2(cos(tim-(timeRand*60.)), sin(tim-(timeRand*60.)))))+vec2(1.2915, -3.3921))*0.5);\n    empty = pow(empty, 4.0)*3.;\n    region = clamp(pow(region, 7.5)*128.5, 0.0, 1.0);\n    float t = (tim-(mix(32.0, 0.5, region*0.5)))*(0.5+mix(0.2, 1.0, region*0.0005));\n    vec2 move = vec2(cos(t), sin(t)) * (0.5+(region*2.));\n    float clouds = noise2D(iChannel3, ((uv+move)*32.), 0.3);\n    clouds = max(clouds, pow(length(move), 2.0)*0.2);\n    clouds = pow(clouds, 2.0);\n    clouds += region*2.;\n    float overlap = max(0.0, 1.0-(90.*pow(abs((clouds-empty)), 2.0)));\n    clouds *= max(0.0, 1.0 - (empty*2.));\n    clouds += (smoothstep(0.1, 1., overlap) / M_PI)*0.5+max(0.0, 0.3-sqrt(region));\n    clouds *= clamp(pow(dotup, 3.), 0.0, 1.0);\n    return clouds;\n}\n\nvec3 getSky(vec3 L, vec3 ro, vec3 rd, inout float clouds) {\n    vec3 blue = vec3(0.2, 0.5, 0.9);\n    vec3 col = blue;\n    clouds = getClouds(rd);\n    col += clouds;\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    vec3 L = normalize(vec3(3, 2, 3));\n    vec3 LC = vec3(0.99, 0.97, 0.41);\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    dist = abs(dist);\n    float clouds = 0.0;\n    vec3 sky = getSky(L, ro, rd, clouds);\n    vec3 col = vec3(0.0);\n    if (!(dist >= FAR)) {\n        vec3 p = ro+rd*dist;\n        vec2 e = vec2(0.5, 0.0);\n        vec3 normal = normalize(getDist(p)-vec3(\n            getDist(p - e.xyy),\n            getDist(p - e.yxy),\n            getDist(p - e.yyx)\n        ));\n        float NdotL = max(0.0, dot(normal, L));\n        vec3 albedo = texture(iChannel2, p.xz*0.1).rgb;\n        vec3 diffuse = albedo / M_PI;\n        col += diffuse*NdotL;\n    } else {\n        col = sky;\n        dist = FAR;\n    }\n    vec3 p = ro+rd*(FAR/2.0);\n    float dotL = pow(max(0.0, dot(rd, L)), 8.0);\n    col += (LC*dotL)*max(0.0, 1.0-clouds);\n    float depth = dist / FAR;\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    col += (depth*depth)*max(0.0, 1.0-(dotup*3.));\n    return col;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\n#define NO(v) (0.5+(0.5*(v)))\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    vec3 ro = vec3(0, 1, -4.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    if (iMouse.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        rd = look(uv, vec3(sin(T*0.5), 3.*0.5+(NO(cos(T+M_PI))), 0), ro);\n    }\n    col += render(ro, rd);\n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n\nfloat hash21(sampler2D ch, vec2 p) {\n    return textureLod(ch, p/256., 0.).r;\n}\n\nfloat hash31(sampler2D ch, vec3 p) {\n    return hash21(ch, vec2(p.x*p.z, p.y));\n}\n\nfloat noise2D(sampler2D ch, vec2 p) {\n    vec2 id = floor(p);\n    vec2 lv = smoothstep(0.0, 1.0, fract(p));\n    \n    return mix(mix(hash21(ch, id), hash21(ch, id+vec2(1, 0)), lv.x),\n        mix(hash21(ch, id+vec2(0, 1)), hash21(ch, id+vec2(1, 1)), lv.x), lv.y);\n}\n\n\nfloat noise3D(sampler2D ch, vec3 p) {\n  vec3 id = floor(p);\n  vec3 lv = smoothstep(0.0, 1.0, fract(p));\n  return mix(\n      mix(mix(hash31(ch, id + vec3(0, 0, 0)), hash31(ch, id + vec3(1, 0, 0)), lv.x),\n          mix(hash31(ch, id + vec3(0, 1, 0)), hash31(ch, id + vec3(1, 1, 0)), lv.x),\n          lv.y),\n      mix(mix(hash31(ch, id + vec3(0, 0, 1)), hash31(ch, id + vec3(1, 0, 1)), lv.x),\n          mix(hash31(ch, id + vec3(0, 1, 1)), hash31(ch, id + vec3(1, 1, 1)), lv.x),\n          lv.y),\n      lv.z);\n}\n\nfloat noise2D(sampler2D ch, vec2 p, float freq) {\n    float n = 0.0;\n    float amp = 1.0;\n    float div = 0.0;\n    vec2 g = vec2(0.);\n    g += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    \n    return ((g.x / div) + (g.y/6.))/2.;\n}\n\nfloat noise3D(sampler2D ch, vec3 p, float freq) {\n    float n = 0.0;\n    float amp = 1.0;\n    float div = 0.0;\n    n += amp*noise3D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise3D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise3D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c);}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}","name":"Common","description":"","type":"common"}]}