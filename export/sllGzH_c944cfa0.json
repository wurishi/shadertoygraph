{"ver":"0.1","info":{"id":"sllGzH","date":"1621567313","viewed":98,"name":"Translate&Rotate&Scale","username":"xxxbbbooo","description":"a practice of translate,rotate and scale\ncode refers from the book of shaders\nhttps://thebookofshaders.com/08/","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["rotate","radar","scale","translate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141593\n#define TWO_PI 6.283185\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec3 drawPolygon(int n, vec2 st)\n{\n    // Angle and radius from the current pixel\n    float a = atan(st.x,st.y)+PI;\n    float r = TWO_PI/float(n);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor(.5+a/r)*r-a)*length(st);\n\n    return vec3(1.0-smoothstep(.35,.45,d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 st = uv*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    \n    float a, b, c = 0.;    \n    \n    // left triangle\n    vec2 st_tri = st*10. + vec2(10.+sin(iTime)*0.5, 0.);\n    st_tri = rotate2d(PI/2.)*st_tri;\n    vec3 col = drawPolygon(3, st_tri);\n    \n    // right triangle\n    st_tri = st*10. - vec2(10.+sin(iTime)*0.5, 0.);\n    st_tri = rotate2d(PI*3./2.)*st_tri;\n    col += drawPolygon(3, st_tri);\n    \n    // center circle\n    for (float i = 0.; i < 4.; ++i) {\n        a = 1.- smoothstep(1.-i*0.25-0.01, 1.-i*0.25, length(scale(vec2(1.))*st));\n        b = 1.- smoothstep(1.-i*0.25-0.05+0.01*i, 1.-i*0.25-0.04+0.01*i, length(scale(vec2(1.))*st));\n        if (i == 0.) {\n            c = (1.-step(abs(st.y-i*0.25), 0.1));\n        } else {\n            c = 1.;\n        }\n        col += vec3(0., (a - b)*c*0.4, 0.);\n    }\n    \n    // center spot\n    a = 1.- smoothstep(0.05, 0.06, length(st));\n    col += vec3(a*sin(iTime*4.), 0., 0.);\n    \n    // grid lines\n    a = smoothstep(-0.01, 0.0, st.x-st.y);\n    b = smoothstep(0.0, 0.01, st.x-st.y);\n    col += vec3(a-b);\n    \n    a = smoothstep(-0.01, 0.0, -st.x-st.y);\n    b = smoothstep(0.0, 0.01, -st.x-st.y);\n    col += vec3(a-b);\n    \n    // needle\n    a = box(rotate2d(iTime/2.+PI/2.)*st+vec2(0.5, 0.02), vec2(0.02, 0.95));\n    //vec3 shadow = vec3(0.3, 0.7, st.x);\n    if (a == 1.) {\n        col += vec3(0.3, 0.7, a);\n    }\n    \n    // obstruction\n    vec2 st_obs = st*10.+ vec2((sin(iTime*0.03)+cos(iTime*0.1))*5., cos(iTime*0.01)*5.);\n    a = 1.- smoothstep(0.1, 0.2, length(st_obs));\n    b = 1.- smoothstep(0.2, 0.3, length(scale(vec2(sin(iTime*2.)+1.5))*st_obs));\n    c = 1.- smoothstep(0.3, 0.35, length(scale(vec2(sin(iTime*2.)+1.5))*st_obs));\n    col += vec3(a+c-b, a+c-b, 0.);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}