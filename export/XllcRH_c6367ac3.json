{"ver":"0.1","info":{"id":"XllcRH","date":"1503613342","viewed":112,"name":"Raymarching noob","username":"Prototonca","description":"First try with raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VIEW_WIDTH 6.0\n#define CAM_DIST 6.0\n#define EPSILON 0.001\n#define MAX_MARCH_LENGTH 256\n#define SHAPE_N 2\n\nstruct RayState {\n    float d;\n    vec3 base_col;    \n};\n    \n    \n// ---- SHAPES ----\n    \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat udPlane(vec3 p) \n{\n    return abs(p.y);\n}\n\nfloat udWaves(vec3 p)\n{\n    return abs(p.y-(cos(length(p.xz-vec2(1.0))*20.0+iTime))*0.01);\n}\n// ---- OPERATIONS ----\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 opTrans( vec3 p, vec3 t)\n{\n    return p - t;\n}\n\nRayState opUrs(RayState o1, RayState o2)\n{\n    if (o1.d <= o2.d) return o1;\n    else return o2;\n}\n\n\n// ---- MAP SCENE ----\nRayState map(vec3 p)\n{\n    \n    if (SHAPE_N == 0)\n    {\n        vec3 q = fract(p) * 3.0 - 1.0;\n        q = abs(q);\n        return RayState(\n            q.x + q.y + q.z - 0.35,\n            vec3(0.3)\n        );\n    }\n    if (SHAPE_N == 1)\n    {\n        return RayState(\n            sdSphere(p, 0.25),\n            vec3(0.2)\n        );\n    }\n    if (SHAPE_N == 2)\n    {\n        RayState box = RayState(\n            udRoundBox(opTrans(p,vec3(-cos(iTime*1.4)*0.5,0.2,sin(iTime*1.4))), vec3(0.1, 0.1, 0.1), 0.05),\n            vec3(0.3, 0.2, 0.6)\n        );\n        \n        RayState plane = RayState(\n            udWaves(p),\n            vec3(0.0,0.0,0.0)\n        );\n        \n        RayState sphere = RayState(\n            sdSphere(opTrans(p,vec3(0.0,cos(iTime*1.2),sin(iTime*1.2)*0.5)),0.1),\n            vec3(0.1,0.5,0.1)\n        );\n        \n        RayState sphere2 = RayState(\n            sdSphere(opTrans(p,vec3(sin(iTime*1.2)*0.5,-cos(iTime*1.2),0.0)),0.1),\n            vec3(0.7,0.5,0.2)\n        );\n        \n        return opUrs(opUrs(opUrs(box, plane),sphere), sphere2);   \n    } \n}\n\n\nvec3 computeNormal(vec3 p) \n{\n    \n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + eps.xyz).d - map(p - eps.xyz).d,\n        map(p + eps.zxy).d - map(p - eps.zxy).d,\n        map(p + eps.yzx).d - map(p - eps.yzx).d\n    );\n    return normalize(nor);\n}\n\n\n\n// ---- LIGHTS ----\n\nvec3 dir_shadow(vec3 origin, vec3 light_dir)\n{\n    float t = 0.01;\n    \n    if(dot(-light_dir,computeNormal(origin))<0.01) {\n    \treturn vec3(0.0);\n    }\n    \n    for(int i=0; i<16; i++)\n    {\n        vec3 pos = origin - light_dir * t;\n        RayState rs = map(pos);\n\n        if(rs.d < EPSILON) \n        {\n            return vec3(-0.1/t);   \n        }\n\t\tif(rs.d < 0.0)\n        {\n            return vec3(0.0);\n        }\n        \n        t += rs.d * 0.8;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 dir_light(vec3 normal, vec3 light_dir) \n{  \n    return vec3(-dot(normal,light_dir));\n}\n\nvec3 ambient_light(vec3 base_col)\n{\n    return base_col;\n}\n\nvec3 black_fog(float depth)\n{\n    return vec3(-depth/(float(MAX_MARCH_LENGTH/3)));\n}\n\nvec3 light(RayState rs, vec3 p, vec3 normal, float depth)\n{\n    vec3 light_dir = vec3(cos(iTime), -1.0, sin(iTime));\n    return dir_light(normal, light_dir)*0.4 + ambient_light(rs.base_col) + black_fog(depth)*0.0 + dir_shadow(p, light_dir);\n}\n\n\n// ---- RAYMARCH ----\n\n\n\n\nvec3 trace(vec3 origin, vec3 rayDir)\n{\n    float t = 0.0;\n    for(int i=0; i<MAX_MARCH_LENGTH; i++)\n    {\n        vec3 pos = origin + rayDir * t;\n        RayState rs = map(pos);\n\n        if(rs.d < EPSILON) \n        {\n            vec3 normal = computeNormal(pos);\n\n            return light(rs, pos, normal, t);\n                \n        }\n\n        t += rs.d * 0.8;\n    }\n\n    return vec3(0.0); \n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 target = vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.2;\n    vec3 cameraPos = (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd = normalize(target - cameraPos);\n    vec3 worldUp = vec3(0.0,sign(cos(angleY)),0.0);\n    vec3 cameraLeft = normalize(cross(cameraFwd, worldUp));\n    vec3 cameraUp = normalize(cross(cameraLeft, cameraFwd));\n\n    float viewHeight = VIEW_WIDTH * iResolution.y / iResolution.x;\n    \n    // Ray\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(CAM_DIST,CAM_DIST,CAM_DIST))\n        - (cameraLeft * percent.x * VIEW_WIDTH)\n        + (cameraUp * percent.y * viewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n    \n    \n    fragColor = vec4(trace(cameraPos, rayDir), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}