{"ver":"0.1","info":{"id":"4dXyW8","date":"1487818365","viewed":98,"name":"MidTerm","username":"ideadnayou","description":"random stuff for grading ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["finals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pattern 10\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale(vec2 value)\n{\n    return mat2(value.x,0,0,value.y);\n}\n\nvec3 createSphere(vec2 pos, vec2 uv, float rad, vec3 color)\n{  \n    float x = step(distance(pos, uv) * distance(pos, uv), rad);\n        \n    return x * color;\n}\n\nvec3 createSphere2(vec2 pos, vec2 uv, float ratio, vec3 color)\n{\n    // Position\n    vec2 shapePos = vec2(pos.x*ratio,pos.y);\n    float dis = distance(shapePos, uv)*2.;\n    uv -= shapePos;\n\n\tfloat dist = step(dis,abs(sin(iTime))+.2);\n    \n    return dist * color;\n}\n\nvec3 create(vec2 pos, vec2 uv, float rad, vec3 mesh)\n{\n    float x = step(distance(pos, uv) * distance(pos, uv), rad);\n    x *= distance(pos, uv) + distance(pos, uv) + step(max(distance(pos, uv), distance(pos, uv)), rad);\n    x += step(pow(distance(pos, uv), distance(pos, uv)), rad);\n    \n    return x * mesh;\n}\n\nvec3 createPolygon(vec2 pos, vec2 uv, int sides, float ratio, vec3 color)\n{\n    // Position\n    vec2 shapePos = vec2(pos.x*ratio,pos.y);\n    uv -= shapePos;\n    uv *= rotate(-iTime);\n    uv *= scale(vec2(abs(sin(iTime))));\n    \n    // Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y)+PI;\n\tfloat rad = TWO_PI/float(sides);\n    \n    // Shaping function that modulate the distance\n\tfloat dist = cos(floor(.5+a/rad)*rad-a)*length(uv);\n    dist = step(dist,.2);\n    \n    return dist * color;\n}\n\nvec3 createPolygon2(vec2 pos, vec2 uv, int sides, float ratio, vec3 color)\n{\n    // Position\n    vec2 shapePos = vec2(pos.x*ratio,pos.y);\n    uv -= shapePos;\n    uv *= rotate(-iTime);\n    uv *= scale(vec2(abs(sin(iTime))));\n    \n    // Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y)+PI;\n\tfloat rad = TWO_PI/float(sides);\n    \n    // Shaping function that modulate the distance\n\tfloat dist = cos(floor(a/rad)*rad-a)*length(uv);\n    dist = step(dist,.2);\n    \n    return dist * color;\n}\n\nvec3 createRectangle(vec2 uv, vec2 pos, vec2 size, vec3 mesh)\n{ \n\tfloat x = step(pos.x + size.x/2., uv.x); \n    \tx -= step(pos.x - size.x/2., uv.x);\n    \n    float y = step(pos.y + size.y/2., uv.y); \n    \ty -= step(pos.y - size.y/2., uv.y);\n    \n    float num = x*y;\n\tvec3 color = num * mesh;\n\n   \n    return color;\n}\n#if pattern == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*5.;\n    \n    vec2 tileIdx = floor(uv);\n    \n    float move = step(1., mod(uv.x, 2.));\n    uv.y += move*iTime;\n    \n    move = step(1., mod(uv.y, 2.));\n    uv.x += move*iTime;\n   \t\n   \tuv = fract(uv);\n    uv.x *= r;\n    \n   \t\n    vec3 a = createPolygon(vec2(.5),uv,3,r,vec3(1.,0,1.));\n    a *= createSphere2(vec2(.5),uv,r,vec3(-1.,1.,1.));\n    a /= createRectangle(uv, vec2(.5*r,.5), vec2(.5), vec3(1.,1.,1.));    \n    \n    if (tileIdx.x == 0. && tileIdx.y == 0. ||\n      \ttileIdx.x == 1. && tileIdx.y == 1. ||\n        tileIdx.x == 2. && tileIdx.y == 2. ||\n       \ttileIdx.x == 3. && tileIdx.y == 3. ||\n       \ttileIdx.x == 4. && tileIdx.y == 4. ||\n       \ttileIdx.x == 0. && tileIdx.y == 4. ||\n       \ttileIdx.x == 1. && tileIdx.y == 3. ||\n       \ttileIdx.x == 2. && tileIdx.y == 2. ||\n       \ttileIdx.x == 3. && tileIdx.y == 1. ||\n       \ttileIdx.x == 4. && tileIdx.y == 0.)\n    {\n        vec2 shapePos = vec2(.5*r, .5);\n    \tfloat dis = distance(shapePos, uv)*2.;\n    \tuv -= shapePos;\n    \n    \tfloat angle = atan(uv.y,uv.x);\n   \t\tangle -= iTime*.1;\n        \n    \tfloat rad = cos(angle*5.+iTime) * floor(sin(angle*50.+iTime))*.5;\n    \n    \tfloat rad2 = floor(cos(angle*50.)*4.*cos(iTime*2.))*.3;\n    \n    \tfloat rad3 = fract(abs(sin(angle+iTime)))*6.;\n    \tfloat rad4 = fract(abs(sin(angle-iTime)))*6.;\n            \n   \t\tfloat value = step(rad,dis) * (step(rad2,dis));\n    \tvalue *= rad3 * rad4;\n    \n    \ta = createSphere(vec2(0),uv,.25,vec3(1.,0.,0.));\n    \ta += createSphere(vec2(0),uv,.1,vec3(-1.,1.,2.));\n    \ta /= value;\n        a *= createPolygon2(vec2(0),uv,3,r,vec3(1.,0,1.));\n    }\n    else\n    {\n        vec2 shapePos = vec2(.5*r, .5);\n    \tfloat dis = distance(shapePos, uv)*2.;\n    \tuv -= shapePos;\n    \n    \tfloat angle = atan(uv.y,uv.x);\n   \t\tangle -= iTime*2.;\n        \n        float rad = floor(cos(dis*8.-iTime)*sin(angle*3.))*8.+2.;\n        a *= rad;\n    }\n    \n    if (tileIdx.x == 0. && tileIdx.y == 1. ||\n      tileIdx.x == 4. && tileIdx.y == 1. ||\n      tileIdx.x == 0. && tileIdx.y == 3. ||\n      tileIdx.x == 4. && tileIdx.y == 3.)\n    {\n      a = create(vec2(-.4,.0),uv,.4*sin(iTime)+.25,vec3(1.,1.,0.));\n      a *= create(vec2(.4,0),uv,.4*sin(iTime)+.25,vec3(1.,0.,1.));\n    }\n    \n\tfragColor = vec4(vec3(a),1.0);\n}\n\n#elif pattern == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*5.;\n    \n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    uv.x *= r;\n    \n    vec3 a = createPolygon(vec2(.5),uv,5,r,vec3(1.,0,1.));\n    a *= createSphere2(vec2(.5),uv,r,vec3(-1.,1.,1.));\n    a *= createRectangle(uv, vec2(.5*r,.5), vec2(.5), vec3(1.,1.,1.));\n    \n    fragColor = vec4(vec3(a),1.0);\n}\n\n#elif pattern == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*3.;\n    \n    vec2 tileIdx = floor(uv);\n       \t\n   \tuv = fract(uv);\n    uv.x *= r;  \n    \n    vec2 shapePos = vec2(.5*r, .5);\n    float dis = distance(shapePos, uv)*2.;\n    uv -= shapePos;\n    \n    float angle = atan(uv.y,uv.x);\n   \tangle -= iTime*.1;\n        \n    float rad = cos(angle*5.+iTime) * floor(sin(angle*50.+iTime))*.5;\n   \tfloat rad2 = floor(cos(angle*50.)*4.*cos(iTime*2.))*.3;\n           \n   \tfloat value = step(rad,dis) * (step(rad2,dis));\n    \n   \tvec3 a = createSphere(vec2(0),uv,.25,vec3(1.,0.,0.));\n    a *= value;\n    a += createPolygon2(vec2(0),uv,8,r,vec3(1.,0,1.));\n    \n    fragColor = vec4(vec3(a),1.0);\n}\n\n#elif pattern == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*5.;\n    \n    vec2 tileIdx = floor(uv);\n    \n    float move = step(1., mod(uv.x, 2.));\n    uv.y -= move*iTime;\n    \n    float move2 = step(1., mod(uv.x, 2.));\n    uv.y -= move*iTime;\n    \n    move = step(1., mod(uv.y, 2.));\n    uv.x *= move*iTime;\n   \t\n   \tuv = fract(uv);\n    uv.x *= r;\n   \n   \tvec2 shapePos = vec2(.5*r, .5);\n   \tfloat dis = distance(shapePos, uv)*2.;\n    uv -= shapePos;\n    \n    float angle = atan(uv.y,uv.x);\n   \tangle -= iTime*2.;\n        \n    float rad = floor(cos(dis*1000.-iTime)*sin(angle*3.))*8.+2.;\n    vec3 a = createPolygon2(vec2(0),uv,9,r,vec3(1.,0,1.));\n    a *= rad;\n    \n    fragColor = vec4(vec3(a),1.0);\n}\n\n#elif pattern == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*5.;\n    \n    vec2 tileIdx = floor(uv);\n   \t\n   \tuv = fract(uv);\n    uv.x *= r;\n   \n   \tvec2 shapePos = vec2(.5*r, .5);\n   \tfloat dis = distance(shapePos, uv)*2.;\n    uv -= shapePos;\n    \n    float angle = atan(uv.y,uv.x);\n   \tangle -= iTime*2.;\n        \n    float rad = floor(cos(dis*1000.-iTime)+sin(angle*100.))*10.+5.;\n    \n    fragColor = vec4(vec3(rad),1.0);\n}\n\n#elif pattern == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*10.;\n    \n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    uv.x *= r;\n  \tvec2 shapePos = vec2(.5*r, .5);\n   \tfloat dis = distance(shapePos, uv)*2.;\n   \tuv -= shapePos;\n    \n   \tfloat angle = atan(uv.y,uv.x);\n   \tangle -= iTime*.1;\n        \n   \tfloat rad = cos(angle*5.+iTime) * floor(sin(angle*50.+iTime))*.5;\n    \n   \tfloat rad2 = floor(cos(angle*50.)*4.*cos(iTime*2.))*.3;\n    \n   \tfloat rad3 = fract(abs(sin(angle+iTime)))*6.;\n   \tfloat rad4 = fract(abs(sin(angle-iTime)))*6.;\n            \n   \tfloat value = step(rad,dis) * (step(rad2,dis));\n  \tvalue *= rad3 * rad4;\n    \n   \tvec3 a = createSphere(vec2(0),uv,5.,vec3(1.,0.,0.));\n   \ta *= value;\n   \ta *= createPolygon2(vec2(0),uv,4,r,vec3(1.,0,1.));\n    a += createPolygon2(vec2(0),uv,4,r,vec3(0.,1.,0));\n    \n    fragColor = vec4(vec3(a),1.0);\n}\n\n#elif pattern == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*50.;\n    \n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    uv.x *= r;\n  \tvec2 shapePos = vec2(.5*r, .5);\n   \tfloat dis = distance(shapePos, uv)*2.;\n   \tuv -= shapePos;\n    \n   \tvec3 a = createPolygon2(vec2(0.),uv,8,r,vec3(1.,0.,0.));\n    a -= createPolygon(vec2(0.),uv,8,r,vec3(1.,0.,1.));\n    a += createSphere2(vec2(0),uv,.25,vec3(0.,1.,1.));\n    \n  \n          \n\tfragColor = vec4(a,1.0);\n}\n\n#elif pattern == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*5.;\n    \n    vec2 tileIdx = floor(uv);\n    \n   \tuv = fract(uv);\n    uv.x *= r;\n    \n    vec2 shapePos = vec2(.5*r, .5);\n    float dis = distance(shapePos, uv)*2.;\n    uv -= shapePos;\n    \n    float angle = atan(uv.y,uv.x);\n   \tangle -= iTime*.1;\n        \n    float rad = cos(angle*5.+iTime) * floor(sin(angle*50.+iTime))*.5;\n    \n    float rad2 = floor(cos(angle*50.)*4.*cos(iTime*2.))*.3;\n    \n    float rad3 = fract(sin(angle*10.+iTime)) * floor(tan(angle*50.-iTime));\n    float rad4 = fract(abs(tan(angle-iTime)))*6.;\n            \n   \tfloat value = 1.- step(rad,dis) * (step(rad2,dis));\n    value *= rad3 * rad4;\n    \n    vec3 a = createSphere(vec2(0),uv,.5,vec3(1.,0.,0.));\n    a += createSphere(vec2(0),uv,.1,vec3(-1.,1.,1.));\n    a /= value;\n    a *= createPolygon2(vec2(0),uv,5,r,vec3(1.,0,1.));\n  \n          \n\tfragColor = vec4(vec3(a),1.0);\n}\n\n#elif pattern == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    uv = uv*5.;\n    \n    vec2 tileIdx = floor(uv);\n    \n   \tuv = fract(uv);\n    uv.x *= r;\n    \n    vec2 shapePos = vec2(.5*r, .5);\n    float dis = distance(shapePos, uv)*2.;\n    uv -= shapePos;\n    \n    float angle = atan(uv.y,uv.x);\n    angle -= iTime*2.;\n        \n    vec3 a = create(vec2(-.4,.0),uv,.4*sin(iTime)+.25,vec3(1.,1.,0.));\n    a += create(vec2(.4,0),uv,.4*sin(iTime)+.25,vec3(1.,0.,1.));\n          \n\tfragColor = vec4(vec3(a),1.0);\n}\n\n#elif pattern == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    \n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    uv.x *= r;\n    \n    vec2 shapePos = vec2(.5*r, .5);\n    float dis = distance(shapePos, uv)*2.;\n    uv -= shapePos;\n    \n    float angle = atan(uv.y,uv.x);\n   \tangle -= iTime*2.;\n        \n    float rad = floor(tan(dis*50.+iTime)-sin(angle*9.))*10.+2.;\n    vec3 a = createPolygon(vec2(0),uv,9,r,vec3(0.,1,0.));\n    a *= rad;\n    \n\tfragColor = vec4(vec3(a),1.0);\n}\n#endif","name":"Image","description":"","type":"image"}]}