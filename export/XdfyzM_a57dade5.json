{"ver":"0.1","info":{"id":"XdfyzM","date":"1487348027","viewed":465,"name":"Gradient overlay","username":"zeh","description":"* Dynamic radial gradient\n* Duotone image\n* Overlay of dynamic gradient atop duotone","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://iquilezles.org/apps/shadertoy/help.html\n\n// Gradient for coloring - hardcoded as 3\nvec4 gradient[3] = vec4[](\n    vec4(46.0 / 255.0,  66.0 / 255.0, 174.0 / 255.0, 0.88),\n    vec4(98.0 / 255.0, 150.0 / 255.0, 208.0 / 255.0, 0.66),\n    vec4(77.0 / 255.0, 198.0 / 255.0, 244.0 / 255.0, 0.85)\n);\n\nvec4 mapColor(vec4[3] colors, float phase) {\n    if (phase < 0.5) {\n        // First and second\n        float f = phase * 2.0;\n\t    return colors[0] * (1.0 - f) + colors[1] * f;\n    } else {\n        // Second and third\n        float f = (phase - 0.5) * 2.0;\n\t    return colors[1] * (1.0 - f) + colors[2] * f;\n    }\n}\n\nvec4 lerp(float f, vec4 a, vec4 b) {\n\treturn a + f * (b - a);\n}\n\nvec4 duotoneDark = vec4(23.0 / 255.0, 33.0 / 255.0, 49.0 / 255.0, 1);\nvec4 duotoneBright = vec4(161.0 / 255.0, 213.0 / 255.0, 248.0 / 255.0, 1);\n\nvec4 getDuotoneColor(float luma) {\n    // TODO: this should be pre-calculated\n    return lerp(luma, duotoneDark, duotoneBright);\n}\n\nfloat getLuma(vec4 color) {\n    return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n}\n\nvec4 createGradient(vec2 fragCoord) {\n    float maxRad = sqrt(iResolution.x * iResolution.x + iResolution.y * iResolution.y);\n\n    // Calculate current pixel's distance from top left\n    float vy = iResolution.y - fragCoord.y;\n\tfloat rad = sqrt(fragCoord.x * fragCoord.x + vy * vy);\n    \n    // Calculate phase: 0 for top left, 1 for bottom right\n    float f = rad / maxRad;\n\n    // Interpolate from desired array\n    //fragColor = vec4(f, f, f, 1);\n    return mapColor(gradient, f);\n}    \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 originalColor = texture(iChannel0, uv);\n\n    // Convert original to duotone\n    float luma = getLuma(originalColor);\n    vec4 duotoneColor = getDuotoneColor(luma);\n    \n    // Create the gradient\n    vec4 gradientColor = createGradient(fragCoord);\n    \n    // Performs overlay (simplified)\n    if (luma < 0.5) {\n    \tfragColor = 2.0 * duotoneColor * gradientColor;\n    } else {\n    \tfragColor = 1.0 - 2.0 * (1.0 - duotoneColor) * (1.0 - gradientColor);\n    }\n\n    //float f = sin(iTime) * 0.5 + 0.5;\n    float f = iMouse.xy == iMouse.zw ? 0.0 : 1.0;\n    fragColor = originalColor + f * (fragColor - originalColor);\n}\n\n","name":"Image","description":"","type":"image"}]}