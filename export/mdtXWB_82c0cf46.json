{"ver":"0.1","info":{"id":"mdtXWB","date":"1680399970","viewed":49,"name":"casual path tracing","username":"artefox","description":"casual path tracing","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["casualpathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EXPOSURE 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col *= EXPOSURE;\n    col = ACESFilm(col);\n    col = linearToSRGB(col);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MINDIST 0.01\n#define MAXDIST 10000.0\n#define FOV 90.0\n#define PI 3.14159265359\n#define BOUNCES 8\n#define NUDGE 0.01\n\nuint wangHash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat randomFloat01(out uint state)\n{\n    return float(wangHash(state)) / 4294967296.0;\n}\n \nvec3 randomUnitVector(out uint state)\n{\n    float z = randomFloat01(state) * 2.0 - 1.0;\n    float a = randomFloat01(state) * PI * 2.0;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nstruct mat\n{\n    vec3 a;\n    vec3 e;\n    float p;\n    float r;\n    vec3 s;\n    float ior;\n};\n\nstruct hit\n{\n    float d;\n    vec3 n;\n    mat m;\n};\n \nfloat scalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n \nbool quadTrace(ray r, out hit h, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 normal = normalize(cross(c - a, c - b));\n    if (dot(normal, r.d) > 0.0)\n    {\n        normal *= -1.0;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = r.o;\n    vec3 q = r.o + r.d;\n    \n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    \n    vec3 pos;\n    if (v >= 0.0)\n    {\n        float u = -dot(pb, m);\n        if (u < 0.0) return false;\n        \n        float w = scalarTriple(pq, pb, pa);\n        if (w < 0.0) return false;\n        \n        float denom = 1.0 / (u + v + w);\n        \n        u *= denom;\n        v *= denom;\n        w *= denom;\n        \n        pos = u * a + v * b + w * c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        \n        float u = dot(pd, m);\n        if (u < 0.0) return false;\n        \n        float w = scalarTriple(pq, pa, pd);\n        if (w < 0.0) return false;\n        \n        v = -v;\n        float denom = 1.0 / (u + v + w);\n        \n        u *= denom;\n        v *= denom;\n        w *= denom;\n        \n        pos = u * a + v * d + w * c;\n    }\n    \n    float dist;\n    if (abs(r.d.x) > 0.1)\n    {\n        dist = (pos.x - r.o.x) / r.d.x;\n    }\n    else if (abs(r.d.y) > 0.1)\n    {\n        dist = (pos.y - r.o.y) / r.d.y;\n    }\n    else\n    {\n        dist = (pos.z - r.o.z) / r.d.z;\n    }\n    \n\tif (dist > MINDIST && dist < h.d)\n    {\n        h.d = dist;        \n        h.n = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nfloat fresnel(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        float r0 = (n1 - n2) / (n1 + n2);\n        r0 *= r0; \n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1 / n2;\n            float sinT2 = n * n * (1.0 - cosX * cosX);\n\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0 - sinT2);\n        }\n        \n        float x = 1.0 - cosX;\n        float ret = r0 + (1.0 - r0) * x * x * x * x * x;\n \n        return mix(f0, f90, ret);\n}\n\nbool sphereTrace(ray r, out hit h, vec4 s)\n{\n\tvec3 m = r.o - s.xyz;\n\n\tfloat b = dot(m, r.d);\n\tfloat c = dot(m, m) - s.w * s.w;\n\n\tif(c > 0.0 && b > 0.0) return false;\n\n\tfloat d = b * b - c;\n\n\tif(d < 0.0) return false;\n    \n    bool fromInside = false;\n\tfloat dist = -b - sqrt(d);\n    \n    if (dist < 0.0)\n    {\n        fromInside = true;\n        dist = -b + sqrt(d);\n    }\n    \n\tif (dist > MINDIST && dist < h.d)\n    {\n        h.d = dist;        \n        h.n = normalize((r.o + r.d * dist) - s.xyz) * (fromInside ? -1.0 : 1.0);\n        return true;\n    }\n    \n    return false;\n}\n \nvoid sceneTrace(ray r, out hit h)\n{   \n    vec3 sceneTranslation = vec3(0.0, 0.0, 10.0);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0);\n    \n    {\n        vec3 A = vec3(-12.6, -12.6, 25.0) + sceneTranslation;\n        vec3 B = vec3(12.6, -12.6, 25.0) + sceneTranslation;\n        vec3 C = vec3(12.6, 12.6, 25.0) + sceneTranslation;\n        vec3 D = vec3(-12.6, 12.6, 25.0) + sceneTranslation;\n        \n        if (quadTrace(r, h, A, B, C, D))\n        {\n            h.m.a = vec3(0.9, 0.9, 0.9);\n            h.m.e = vec3(0.0);\n        }\n\t}    \n\n    {\n        vec3 A = vec3(-12.6, -12.45, 25.0) + sceneTranslation;\n        vec3 B = vec3(12.6, -12.45, 25.0) + sceneTranslation;\n        vec3 C = vec3(12.6, -12.45, 15.0) + sceneTranslation;\n        vec3 D = vec3(-12.6, -12.45, 15.0) + sceneTranslation;\n        \n        if (quadTrace(r, h, A, B, C, D))\n        {\n            h.m.a = vec3(0.9, 0.9, 0.9);\n            h.m.e = vec3(0.0);\n        }        \n    }\n\n    {\n        vec3 A = vec3(-12.6, 12.5, 25.0) + sceneTranslation;\n        vec3 B = vec3(12.6, 12.5, 25.0) + sceneTranslation;\n        vec3 C = vec3(12.6, 12.5, 15.0) + sceneTranslation;\n        vec3 D = vec3(-12.6, 12.5, 15.0) + sceneTranslation;\n        \n        if (quadTrace(r, h, A, B, C, D))\n        {\n            h.m.a = vec3(0.9, 0.9, 0.9);\n            h.m.e = vec3(0.0);\n        }        \n    } \n    \n    {\n        vec3 A = vec3(-12.5, -12.6, 25.0) + sceneTranslation;\n        vec3 B = vec3(-12.5, -12.6, 15.0) + sceneTranslation;\n        vec3 C = vec3(-12.5, 12.6, 15.0) + sceneTranslation;\n        vec3 D = vec3(-12.5, 12.6, 25.0) + sceneTranslation;\n        \n        if (quadTrace(r, h, A, B, C, D))\n        {\n            h.m.a = vec3(0.7, 0.2, 0.2);\n            h.m.e = vec3(0.0);\n        }        \n    }\n    \n    {\n        vec3 A = vec3(12.5, -12.6, 25.0) + sceneTranslation;\n        vec3 B = vec3(12.5, -12.6, 15.0) + sceneTranslation;\n        vec3 C = vec3(12.5, 12.6, 15.0) + sceneTranslation;\n        vec3 D = vec3(12.5, 12.6, 25.0) + sceneTranslation;\n        \n        if (quadTrace(r, h, A, B, C, D))\n        {\n            h.m.a = vec3(0.2, 0.2, 0.7);\n            h.m.e = vec3(0.0);\n        }        \n    } \n    \n    {\n        vec3 A = vec3(-5.0, 12.4, 22.5) + sceneTranslation;\n        vec3 B = vec3(5.0, 12.4, 22.5) + sceneTranslation;\n        vec3 C = vec3(5.0, 12.4, 17.5) + sceneTranslation;\n        vec3 D = vec3(-5.0, 12.4, 17.5) + sceneTranslation;\n        \n        if (quadTrace(r, h, A, B, C, D))\n        {\n            h.m.a = vec3(0.0);\n            h.m.e = vec3(1.0, 0.9, 0.7) * 20.0;\n        }        \n    }\n    \n\tif (sphereTrace(r, h, vec4(-9.0, -9.5, 20.0, 3.0) + sceneTranslation4))\n    {\n        h.m.a = vec3(0.9, 0.9, 0.5);\n        h.m.e = vec3(0.0);\n        h.m.p = 0.1;\n        h.m.r = 0.2;\n        h.m.s = vec3(0.9);\n        h.m.ior = 1.0;\n    } \n    \n\tif (sphereTrace(r, h, vec4(0.0, -9.5, 20.0, 3.0) + sceneTranslation4))\n    {\n        h.m.a = vec3(0.9, 0.5, 0.5);\n        h.m.e = vec3(0.0);\n        h.m.p = 0.2;\n        h.m.r = 0.7;\n        h.m.s = vec3(0.9);\n        h.m.ior = 1.0;\n    }    \n    \n\tif (sphereTrace(r, h, vec4(9.0, -9.5, 20.0, 3.0) + sceneTranslation4))\n    {\n        h.m.a = vec3(0.5, 0.9, 0.9);\n        h.m.e = vec3(0.0);\n    }          \n}\n \nvec3 color(ray r, out uint rngState)\n{\n    vec3 ret = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n     \n    for (int bounceIndex = 0; bounceIndex <= BOUNCES; ++bounceIndex)\n    {\n        hit h;\n        h.d = MAXDIST;\n        sceneTrace(r, h);\n        \n        if (h.d == MAXDIST)\n        {\n            ret += SRGBtoLinear(texture(iChannel1, r.d).rgb) * throughput;\n            break;\n        }\n         \n        r.o = (r.o + r.d * h.d) + h.n * NUDGE;\n\n        float pc = h.m.p;\n        if (pc > 0.0)\n        {\n            pc = fresnel(1.0, h.m.ior, r.d, h.n, h.m.p, 1.0);  \n        }\n\n        float doSpecular = (randomFloat01(rngState) < pc) ? 1.0 : 0.0;\n\n        vec3 diffuseDir = normalize(h.n + randomUnitVector(rngState));\n        vec3 specularDir = reflect(r.d, h.n);\n        specularDir = normalize(mix(specularDir, diffuseDir, h.m.r * h.m.r));\n        \n        r.d = mix(diffuseDir, specularDir, doSpecular);\n\n        ret += h.m.e * throughput;\n\n        throughput *= mix(h.m.a, h.m.s, doSpecular);\n        \n        float p = max(throughput.r, max(throughput.g, throughput.b));\n        if (randomFloat01(rngState) > p) break;\n        throughput *= 1.0 / p;\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    float camDist = 1.0 / tan(FOV / 2.0 * PI / 180.0);\n    \n    vec2 jitter = vec2(randomFloat01(rngState), randomFloat01(rngState)) - 0.5;\n    vec3 uv = vec3(((fragCoord + jitter) / iResolution.xy) * 2.0 - 1.0, camDist);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    ray r;\n    r.o = vec3(0.0);\n    r.d = normalize(uv - r.o);\n    \n    vec3 col = color(r, rngState);\n    \n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0, 0.25)).x > 0.1);\n\n    vec4 lastCol = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastCol.a == 0.0 || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / lastCol.a));\n    col = mix(lastCol.rgb, col, blend);\n    //col = vec3(uv.xy, 0.0);\n\n    fragColor = vec4(col, blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 linearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBtoLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}","name":"Common","description":"","type":"common"}]}