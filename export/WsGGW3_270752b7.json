{"ver":"0.1","info":{"id":"WsGGW3","date":"1571030520","viewed":115,"name":"TorusBlackHole","username":"JohnShadow","description":"Torus Black Hole algorithm, can make any shape of black hole, go ahead try it","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","torus","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float G = 6.67408e-11;\nconst float mass = 1.0e9;\nconst vec3 bhpos = vec3(0, 0, 0); \n\nfloat map(vec3 p)\n{\n    p = min(max(p, -256.0), 256.0);\n    p = mod(p, 32.0) - 16.0;\n\tfloat s = distance(p, vec3(0, 0, 0.0))-4.0;\n    return s;\n}\nfloat blackhole(vec3 p)\n{\n    vec3 p1 = p;\n    p.x = p1.y;\n    p.y = p1.x;\n\tvec2 t = vec2(5.0, 0.25);\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nvec3 getnormal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec3 holefeild (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( blackhole(p + vec3(eps, 0, 0) ) - blackhole(p - vec3(eps, 0, 0)),\n \t  blackhole(p + vec3(0, eps, 0) ) - blackhole(p - vec3(0, eps, 0)),\n\t  blackhole(p + vec3(0, 0, eps) ) - blackhole(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat calcGrav(float r, float m)\n{\n\treturn G * m/(r * r);\n}\nvec4 march(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori + dir;\n    float bhrad = 1.0;\n\tfor(int i = 0; i < 400; ++i)\n    {\n        float bh = blackhole(pos);\n        if(bh < bhrad)\n            return vec4(0.0);\n\t\tvec3 bhdir = holefeild(pos);\n        float grav = calcGrav(bh, mass);\n        float cs = map(pos);\n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * min((bh - bhrad), cs);\n\n        if(cs < 0.001)\n            return vec4(pos, cs);\n    }\n    return vec4(0.0);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(30.0 * sin(iTime * 0.5), 10.0, 30.0 * cos(iTime * 0.5));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec3 normal, color;\n    \n    // Time varying pixel color\n    vec4 hit = march(eye, worldDir);\n    normal = getnormal(hit.xyz);\n    if(hit.w != 0.0)\n        color = vec3(0.2, 0.7, 0.8) * max(dot(normal, normalize(vec3(0, 0.5, -0.5))), 0.1);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}