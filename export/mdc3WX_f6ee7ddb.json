{"ver":"0.1","info":{"id":"mdc3WX","date":"1677923514","viewed":166,"name":"printf Debugging Shaders v1.2.0!","username":"foodini","description":"I've switched the storage/retrieval of state information to using texelFetch, which takes integer-indexed pixel locations. Before, I was unaware that texelFetch existed and was doing everything with floats (x==0.5, y==0.5) and using Filter=nearest.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["debugging"],"hasliked":0,"parentid":"wdVBRh","parentname":"Printf Debugging For Shaders!!!!"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nPLEASE BE PATIENT. In the coming days, I'll set up some documentation on how\nyou can use this thing with your own shaders. I still have some minor\nrefinement on it before it'll be broadly useful.\n\nIf you want to just try replacing the render() method with what you'd usually\nhave in mainImage, and making the trace calls, it should all work out for you.\n\n*/\n\n\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C_r2l(c) out_color += char(U,64+c).xxxx; U.x+=.5\n#define C_l2r(c) out_color += char(U,64+c).xxxx; U.x-=.5\n\n#define _SPACE -32\n#define _MINUS -19\n#define _PERIOD -18\n#define _SLASH -17\n#define _A 1\n#define _B 2\n#define _C 3\n#define _D 4\n#define _E 5\n#define _F 6\n#define _G 7\n#define _H 8\n#define _I 9\n#define _J 10\n#define _K 11\n#define _L 12\n#define _M 13\n#define _N 14\n#define _O 15\n#define _P 16\n#define _Q 17\n#define _R 18\n#define _S 19\n#define _T 20\n#define _U 21\n#define _V 22\n#define _W 23\n#define _X 24\n#define _Y 25\n#define _Z 26\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nconst vec4 BLACK = vec4(0.0); \nconst vec4 WHITE = vec4(1.0);\n\nvec4 draw_float(in float f, in vec2 position, in float fract_digits, in float font_size, in vec2 uv) {\n    vec4 out_color = vec4(0.0);\n    bool negative = false;\n\n    if(f == reserved_float) {\n        return vec4(0.0);\n    }\n\n\n    if(f < 0.0) {\n        negative = true;\n        f = -f;\n    }\n\n    // Add juuuuust enough to f that we'll round off the last digit. It'll turn\n    // 0.999999 into 0.9999995 which will then round off to 1.000000. Given how\n    // often normalized axial vectors end up being <0.999999, 0.0, 0.0>, this is\n    // a good thing.\n    f += 5.0 * pow(10.0, -(fract_digits + 1.0));\n\n    vec2 U = (uv - position)*64.0/font_size;\n    // Not sure I can explain this. It has to do with the default-to-centering of the font system and\n    // the left-to-right nature of printing in most cases.\n    U.x += (0.50 + 0.25); \n\n    int fraction = int(fract(f) * pow(10.0, fract_digits));\n    for(float i=0.0; i<fract_digits; i+=1.0) {\n        C_r2l((fraction%10) - 16);\n        fraction /= 10;\n    }\n    C_r2l(_PERIOD); // decimal point\n    \n    int mantissa = int(f);\n    \n    do{\n        C_r2l(mantissa%10 - 16);\n        mantissa /= 10;\n    } while(mantissa != 0);\n    if(negative) {\n        C_r2l(_MINUS);\n    }\n    \n    return out_color;\n}\n\nvec4 draw_string(in int[10]s, in vec2 position, in float font_size, in vec2 uv) {\n    vec4 out_color = vec4(0.0);\n\n    vec2 U = (uv - position)*64.0/font_size;\n    // Not sure I can explain this. It has to do with the default-to-centering of the font system and\n    // the left-to-right nature of printing in most cases.\n    U.x += (0.25); \n\n    for(int i=0; i<10; i++) {\n        C_l2r(s[i]);\n    }\n\n    return out_color;\n}\n\n//They're all the same length (they all have trailing spaces) to make rendering simpler.\nint fps_string[10] = int[10](_F, _P, _S, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE);\nint normal_string[10] = int[10](_N, _O, _R, _M, _A, _L, _SPACE, _SPACE, _SPACE, _SPACE);\nint color_string[10] = int[10](_C, _O, _L, _O, _R, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE);\nint distance_string[10] = int[10](_D, _I, _S, _T, _A, _N, _C, _E, _SPACE, _SPACE);\nint iterations_string[10] = int[10](_I, _T, _E, _R, _A, _T, _I, _O, _N, _S);\n\n#define draw_vec4_debug_row(string, x_index) \\\n    do { \\\n        position.x = str_left_side; \\\n        position.y -= skip_down; \\\n        texel = get_val_at_index(x_index); \\\n        out_color += draw_string(string, position, font_size, uv); \\\n        position.x = val_left_side; \\\n        out_color += draw_float(texel.r, position, 6.0, font_size, uv); \\\n        position.x += skip_right; \\\n        out_color += draw_float(texel.g, position, 6.0, font_size, uv); \\\n        position.x += skip_right; \\\n        out_color += draw_float(texel.b, position, 6.0, font_size, uv); \\\n        position.x += skip_right; \\\n        out_color += draw_float(texel.a, position, 6.0, font_size, uv); \\\n    } while (false)\n\n#define draw_float_debug_row(string, x_index) \\\n    do { \\\n        position.x = str_left_side; \\\n        position.y -= skip_down; \\\n        texel = get_val_at_index(x_index); \\\n        out_color += draw_string(string, position, font_size, uv); \\\n        position.x = val_left_side; \\\n        out_color += draw_float(texel.x, position, 6.0, font_size, uv); \\\n    } while (false)\n\nvec4 debug_overlay(vec2 fragCoord) {\n    vec2 uv = fragCoord_to_uv(iResolution, fragCoord);\n    \n    vec4 out_color = BLACK;\n\n    float fps = 1.0/iTimeDelta;\n    vec2 position = vec2(1.0, -0.57);\n    float font_size = 2.9;\n    float char_width = font_size / 128.0;\n    float char_height = font_size / 64.0;\n    position.x -= char_width * 3.0;\n    out_color += draw_float(fps, position, 1.0, font_size, uv);\n    out_color += draw_string(fps_string, position, font_size, uv);\n\n    float str_left_side = -0.99;\n    float val_left_side = -0.33;\n    float first_row = 0.51;\n    float skip_right = 0.44;\n    float skip_down = char_height * 0.75;\n    position.y = first_row+skip_down;\n    vec4 texel;\n    \n    draw_vec4_debug_row(normal_string, x_index_user_a);\n    draw_vec4_debug_row(color_string, x_index_user_b);\n    draw_float_debug_row(distance_string, x_index_user_c);\n    draw_float_debug_row(iterations_string, x_index_user_d);\n    \n    if(iTime < 10.0) { \n        font_size = 6.0;\n\n        // \"Space to toggle Debug Overlay\"\n        position.x = -0.7;\n        position.y = -0.44;\n        vec2 U = (uv - position)*64.0/font_size;\n        C_l2r(_S);C_l2r(_P);C_l2r(_A);C_l2r(_C);C_l2r(_E);C_l2r(_SPACE);\n        C_l2r(_T);C_l2r(_O);C_l2r(_SPACE);\n        C_l2r(_T);C_l2r(_O);C_l2r(_G);C_l2r(_G);C_l2r(_L);C_l2r(_E);C_l2r(_SPACE);\n        C_l2r(_D);C_l2r(_E);C_l2r(_B);C_l2r(_U);C_l2r(_G);C_l2r(_SPACE);\n        C_l2r(_O);C_l2r(_V);C_l2r(_E);C_l2r(_R);C_l2r(_L);C_l2r(_A);C_l2r(_Y);\n    \n        // \"Mouse Click To Debug\"\n        position.x = -0.485;\n        position.y = -0.51;\n        U = (uv - position)*64.0/font_size;\n        C_l2r(_M);C_l2r(_O);C_l2r(_U);C_l2r(_S);C_l2r(_E);C_l2r(_SPACE);\n        C_l2r(_C);C_l2r(_L);C_l2r(_I);C_l2r(_C);C_l2r(_K);C_l2r(_SPACE);\n        C_l2r(_T);C_l2r(_O);C_l2r(_SPACE);C_l2r(_D);C_l2r(_E);C_l2r(_B);C_l2r(_U);C_l2r(_G);\n\n        // \"Arrows/WASD to Fine Tune\"\n        position.x = -0.58;\n        position.y = -0.58;\n        U = (uv - position)*64.0/font_size;\n        C_l2r(_A);C_l2r(_A);C_l2r(_R);C_l2r(_O);C_l2r(_W);C_l2r(_S);C_l2r(_SLASH);\n        C_l2r(_W);C_l2r(_A);C_l2r(_S);C_l2r(_D);C_l2r(_SPACE);C_l2r(_T);C_l2r(_O);C_l2r(_SPACE);\n        C_l2r(_F);C_l2r(_I);C_l2r(_N);C_l2r(_E);C_l2r(_SPACE);C_l2r(_T);C_l2r(_U);C_l2r(_N);C_l2r(_E);\n    }\n\n    return out_color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n\n    if(is_key_toggled(iChannel2, float(32.0) ))\n        return;\n\n    fragColor += debug_overlay(fragCoord);\n    \n    float empty_radius = 3.0;\n    float reticle_size = 20.0;\n    vec4 mouse = get_val_at_index(8.0);\n    if((abs(mouse.x - fragCoord.x) <= 2.5 || abs(mouse.y - fragCoord.y) <= 2.5) &&\n       (abs(mouse.x - fragCoord.x) > empty_radius || abs(mouse.y - fragCoord.y) > empty_radius) &&\n       (abs(mouse.x - fragCoord.x) < reticle_size && abs(mouse.y - fragCoord.y) < reticle_size)) {\n        if(abs(mouse.x - fragCoord.x) <= 1.0 || abs(mouse.y - fragCoord.y) <= 1.0) {\n            fragColor = vec4(1.0);\n        } else {\n            fragColor = vec4(0.0);\n        }\n    }\n    \n    return;\n    \n    // Wanna see what that font texture looks like?\n    fragColor.rgb = texture(iChannel1, fragCoord/iResolution.xy).xxx;\n    if(mod(iTime, 4.0) > 1.0)\n        fragColor.rgb = texture(iChannel1, fragCoord/iResolution.xy).yyy;\n    if(mod(iTime, 4.0) > 2.0)\n        fragColor.rgb = texture(iChannel1, fragCoord/iResolution.xy).zzz;\n    if(mod(iTime, 4.0) > 3.0)\n        fragColor.rgb = texture(iChannel1, fragCoord/iResolution.xy).www;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////\n////////////   DOCUMENTATION IS COMING IN THE NEAR FUTURE, TO HELP\n////////////   YOU USE THIS AS A FOUNDATION FOR YOUR OWN SHADERS!\n////////////\n\n//TODO:\n// * Add zoom. A single pixel is too small to get a good look at. I'd like to\n//   have a way to zoom pixels to 4x4, 8x8, etc.\n\nconst float reserved_float = -867.5309;\nvec4 debug_trace_value;\nint debug_trace_index;\nbool debug_trace_occurred;\n\nconst int x_index_user_a = 0;\nconst int x_index_user_b = 1;\nconst int x_index_user_c = 2;\nconst int x_index_user_d = 3;\nconst int x_index_mouse = 8;\nconst int x_index_max_valid = 8;\n\n//DEBUG_TRACE will not overwrite a previously-traced value in the current frame.\n#define DEBUG_TRACE(index, val) \\\n    do{\\\n        if(!debug_trace_occurred && index == debug_trace_index) {\\\n            debug_trace_value = val;\\\n            debug_trace_occurred = true;\\\n        }}while(false)\n//DEBUG_RETRACE will overwrite any value already recorded for this property.\n#define DEBUG_RETRACE(index, val) \\\n    do{\\\n        if(index == debug_trace_index) {\\\n            debug_trace_value = val;\\\n            debug_trace_occurred = true;\\\n        }}while(false)\n#define DEBUG_INCREMENT(index, val) \\\n    do{\\\n        if(index == debug_trace_index) {\\\n            if(debug_trace_val.x == reserved_float) \\\n                debug_trace_val = val;\\\n            else\\\n                debug_trace_val += val;\\\n        }}while(false)\n#define get_val_at_index(index)\\\n    texelFetch(iChannel0, ivec2(index, 0), 0);\n\nvec2 fragCoord_to_uv(in vec3 uniformResolution, in vec2 fragCoord) {\n    vec2 uv = fragCoord - uniformResolution.xy/2.0;\n    return uv*2.0/uniformResolution.x;\n}\n\nvec2 mouse_to_fragCoord(vec4 mouse) {\n    return mouse.xy + 0.5;\n}\n\nvec2 mouse_to_uv(in vec3 uniformResolution, vec4 mouse) {\n    return fragCoord_to_uv(uniformResolution, mouse_to_fragCoord(mouse));\n}\n\nbool is_key_newly_pressed(sampler2D channel, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.5);\n    float key = texture(channel, uv).r;\n\n    return key > 0.0;\n}\n\nbool is_key_toggled(sampler2D channel, float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.75);\n        float key = texture(channel, uv).r;\n\n        return key > 0.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdRoundedBox( in vec3 p, in vec3 r) {\n    return length(max(abs(p) - r, 0.0)) - 0.20;\n}\n\nfloat map( in vec3 p) {\n\treturn sdRoundedBox(p, vec3(0.2, 0.2, 0.2));\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map(p+h.xyy) - map(p-h.xyy),\n             map(p+h.yxy) - map(p-h.yxy),\n             map(p+h.yyx) - map(p-h.yyx) ) );\n    return normal;\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 1.0;\n\n    uv.y /= iResolution.x/iResolution.y;\n\n\tvec3 view_plane = vec3(vec2(0.0) + (uv * 3.0), 0.0);\n    float view_plane_scale = 2.0;\n    vec3 cam_position = vec3(4.0 * sin(iTime), 3.0 + sin(iTime), 4.0*cos(iTime));\n    vec3 cam_lookat = vec3(0.0);\n    vec3 cam_direction = cam_lookat - cam_position;\n    vec3 cam_up = vec3(0.0, 1.0, 0.0); // This is only approximate. We'll fix it in a second.\n    vec3 cam_right = normalize(cross(cam_up, cam_direction));\n    cam_up = normalize(cross(cam_direction, cam_right));\n    \n    vec3 ray_direction = normalize(\n        cam_direction + view_plane_scale * cam_up * uv.y + view_plane_scale * cam_right * uv.x);\n    vec3 ray_pos = cam_position;\n    float dist;\n    float i;\n    float total_dist = 0.0;\n    for(i=0.0; i<200.0; i+=1.0) {\n        dist = map(ray_pos);\n        if(dist < 0.0001 || dist > 1000.0) {\n            break;\n        }\n        total_dist += dist;\n        ray_pos += ray_direction * (dist * 0.999);\n    }\n    DEBUG_TRACE(x_index_user_c, vec4(total_dist));\n    DEBUG_TRACE(x_index_user_d, vec4(i));\n    vec3 col;\n    if(dist < 1000.0) {\n        vec3 normal = calcNormal(ray_pos);\n        DEBUG_TRACE(x_index_user_a, vec4(normal, 1.0));\n        col = normal;\n    } else {\n        col = vec3(0.0);\n    }\n    col = max(col, 0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    DEBUG_TRACE(x_index_user_b, fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    debug_trace_index = -1;\n    debug_trace_occurred = false;\n    ivec2 int_fragCoord = ivec2(fragCoord);\n    \n    if(int_fragCoord.y == 0 && int_fragCoord.x <= x_index_max_valid) {\n        //////////////////\n        // TODO: GET OFF THE MAGIC NUMBERS FOR NUM FIELDS AND MOUSE STORAGE LOCATION!!!!!!!\n        //////////////////\n        vec4 mouse = get_val_at_index(x_index_mouse);\n        if(int_fragCoord.x != x_index_mouse) {\n            debug_trace_index = int(fragCoord.x);\n            render(fragColor, mouse_to_fragCoord(mouse));\n        } else {\n            //////\n            // Sorry, but I had to choose between fidelity and speed. I can make it so that\n            // WASD will move by one pixel every frame, but it's very hard to adjust by just\n            // one pixel in that case. By looking at the keyboard texture's indication that\n            // a key went down in this frame and only moving on those events, it is easy to\n            // adjust by a single pixel. My first attempt at this was to count the number of\n            // frames since the last keystroke and do some math with the iFrameDelta to make\n            // the thing move only every 500ms, but it seems that when a shader is paused,\n            // it stops rendering entirely unless it gets a keyboard or mouse event. Having\n            // a key or button held down is not an event. Only going up or going down are,\n            // so I have no way of checking how long a key has been held down before moving\n            // the cursor, so we're currently stuck with the limited cursor motion mechanism\n            // we have here:\n            if(iMouse.z > 0.0) {\n                fragColor = iMouse;\n            } else {\n                fragColor = mouse;\n                fragColor.w += 1.0;\n                // I'm a dvorak user, so I support WASD or \",AOE\". A is the same on both.\n                if(is_key_newly_pressed(iChannel1, 38.0) || // ↑\n                   is_key_newly_pressed(iChannel1, 87.0) || // W\n                   is_key_newly_pressed(iChannel1, 188.0))  // ,\n                    fragColor.y += 1.0;\n                if(is_key_newly_pressed(iChannel1, 37.0) || // ←\n                   is_key_newly_pressed(iChannel1, 65.0))   // A\n                    fragColor.x -= 1.0;\n                if(is_key_newly_pressed(iChannel1, 40.0) || // ↓\n                   is_key_newly_pressed(iChannel1, 79.0) || // S\n                   is_key_newly_pressed(iChannel1, 83.0))   // O\n                    fragColor.y -= 1.0;\n                if(is_key_newly_pressed(iChannel1, 39.0) || // →\n                   is_key_newly_pressed(iChannel1, 68.0) || // D\n                   is_key_newly_pressed(iChannel1, 69.0))   // E\n                    fragColor.x += 1.0;             \n            }\n        } \n    } else {\n        render(fragColor, fragCoord);\n    }\n    \n    if(debug_trace_index >= 0) {\n        if(debug_trace_occurred) {\n            fragColor = debug_trace_value;\n        } else {\n            fragColor = vec4(reserved_float);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}