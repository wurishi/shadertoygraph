{"ver":"0.1","info":{"id":"ctjXWD","date":"1676092852","viewed":73,"name":"Sphere World Background","username":"sdfgeoff","description":"Simple world background to help with establishing orientation in a scene.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["basic","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float LENS = 0.5;\nconst float PI = 3.14159;\n\n\nconst float MAJOR_LINES = 6.0;\nconst float MAJOR_LINE_WIDTH = MAJOR_LINES * 0.002;\nconst float MINOR_LINES = MAJOR_LINES * 5.0;\nconst float MINOR_LINE_WIDTH = MINOR_LINES * 0.001;\nconst float MAJOR_LINE_INTENSITY = 0.03;\nconst float MINOR_LINE_INTENSITY = 0.05;\n\n\nfloat sphere_lines(float angle, float elevation) {\n    float lines = 0.0;\n    lines += clamp((abs(fract(elevation / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) /  MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) / MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(elevation / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) /  MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) / MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    return lines;\n}\n\n\n\n\n\nvec3 horizon(float angle, float elevation) {\n    float elevationPercent = (0.5 - elevation / PI) * 2.0;\n    vec3 baseColor = mix(vec3(0,0,0.8), vec3(0,0,0.2), elevationPercent);\n    vec3 horizonColor1 = mix(vec3(0,0.9, 0.2), vec3(0,0,0), pow(clamp(elevationPercent, 0.0, 1.0), 0.7));\n    vec3 horizonColor2 = mix(vec3(0.8, 0.0, 0.0), vec3(0,0,0), pow(clamp(elevationPercent * 2.0, 0.0, 1.0), 0.7));\n\n    return baseColor + horizonColor1 + horizonColor2;\n}\n\n\nvec3 world_background(vec3 rayDirection) {\n\n    float r2 = dot(rayDirection.xy, rayDirection.xy);\n    float elevation = acos(rayDirection.z / sqrt(r2 + rayDirection.z * rayDirection.z));\n    float angle = atan(rayDirection.y, rayDirection.x);\n\n    float lines = sphere_lines(angle, elevation);\n    vec3 col = horizon(angle, elevation);\n    col += lines;\n\n    return col;\n}\n\n\n\nmat4 Rx(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        vec4(1,0,0,0),\n        vec4(0,c,-s,0),\n        vec4(0,s,c,0),\n        vec4(0,0,0,1)\n    );\n}\nmat4 Ry(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        vec4(c,0,s,0),\n        vec4(0,1,0,0),\n        vec4(-s,0,c,0),\n        vec4(0,0,0,1)\n    );\n}\n\n\n\nmat4 get_camera_transform() {\n    vec2 pos = ((iMouse.xy / iResolution.xy) - 0.5) * 2.0;\n    mat4 rh = Ry(pos.x);\n    mat4 rv = Rx(-pos.y + PI/2.0);\n    \n    return rv * rh;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Render our geometry\n    mat4 camera_transform = get_camera_transform();\n    \n    vec3 start_point = camera_transform[3].xyz;\n    vec3 direction = normalize(vec3(uv * LENS, 1.0));\n    direction = (camera_transform * vec4(direction, 0.0)).xyz;\n\n    // Output to screen\n    fragColor = vec4(world_background(direction),1.0);\n}","name":"Image","description":"","type":"image"}]}