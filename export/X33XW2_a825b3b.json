{"ver":"0.1","info":{"id":"X33XW2","date":"1719551564","viewed":199,"name":"Vesa Timonen's rep-tile","username":"DjinnKahn","description":"facebook post of the tile: https://www.facebook.com/share/p/nxjK23wPS6HkcRb7/","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["zoom","loop","tile","infinite","rep","reptile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PLASTIC = 1.324717957244746;\nconst float PLASTIC_2 = pow( PLASTIC, 2. );\nconst float PLASTIC_3 = pow( PLASTIC, 3. );\nconst float PLASTIC_4 = pow( PLASTIC, 4. );\nconst float PLASTIC_5 = pow( PLASTIC, 5. );\nconst float PLASTIC_6 = pow( PLASTIC, 6. );\nconst float PLASTIC_7 = pow( PLASTIC, 7. );\nconst float PLASTIC_8 = pow( PLASTIC, 8. );\nconst float PLASTIC_9 = pow( PLASTIC, 9. );\n\nconst vec2 HEX0 = vec2( 1., 0. );\nconst vec2 HEX1 = vec2( .5, sqrt( .75 ) );\nconst mat2 TO_HEX0_HEX1 = inverse( mat2( HEX0, HEX1 ) );\n\n// a copy of the \"original\" tile appears as a subtile scaled by pow( PLASTIC, -8. )\n// the offset of the scaled copy is at RECURSE_PT\nconst vec2 RECURSE_PT = vec2( PLASTIC_7 - PLASTIC_3, PLASTIC_3 );\n// if we keep repeating the process of finding a scaled version of the \"original\" tile\n// we converge on the FIXED_PT\nconst vec2 FIXED_PT = mix( RECURSE_PT, vec2( 0. ), -1./(PLASTIC_8-1.) );\n\n// shape of the tile\nbool inTile( vec2 h ) // h is in hex coords\n{\n    if ( h.y < 0. ) return false;   \n    if ( h.x < 0. ) return false;\n    if ( h.x + h.y > PLASTIC_9 ) return false;  \n    if ( h.x + h.y > PLASTIC_8 && h.x < PLASTIC_6 ) return false;\n    return true;\n}\n\n// map subtile -> parent tile\nvec2 fromBigTile( vec2 h )\n{\n    return h.yx * PLASTIC;\n}\n// map subtile -> parent tile\nvec2 fromMediumTile( vec2 h )\n{\n    return mat2( 0., -1., 1., -1. ) * (h - vec2(PLASTIC_9, 0.)) * PLASTIC_2;\n}\n// map subtile -> parent tile\nvec2 fromSmallTile( vec2 h )\n{\n    return mat2( -1., 1., 0., 1. ) * (h - vec2(PLASTIC_7, 0.)) * PLASTIC_4;\n}\n\nconst int NO_TILE = -1;\nconst int SMALL_TILE = 0;\nconst int MEDIUM_TILE = 1;\nconst int BIG_TILE = 2;\nvec2 substitution( vec2 h, out int tileType )\n{\n    vec2 hh;\n    hh = fromBigTile( h );    if ( inTile( hh ) ) { tileType = BIG_TILE;    return hh; }\n    hh = fromMediumTile( h ); if ( inTile( hh ) ) { tileType = MEDIUM_TILE; return hh; }\n    hh = fromSmallTile( h );  if ( inTile( hh ) ) { tileType = SMALL_TILE;  return hh; }\n    tileType = NO_TILE;  \n    return h;\n}\n\nvec3 colorForTile( int tileType )\n{\n    if ( tileType == BIG_TILE ) return vec3( 1., 0., 0. );\n    if ( tileType == MEDIUM_TILE ) return vec3( 0., 1., 0. );\n    if ( tileType == SMALL_TILE ) return vec3( 0., 0., 1. );\n    return vec3( 0., 0., 0. );\n}\n\n// tile size\nfloat zoom( int tileType )\n{\n    if ( tileType == BIG_TILE ) return 1.;\n    if ( tileType == MEDIUM_TILE ) return 2.;\n    if ( tileType == SMALL_TILE ) return 4.;\n    return 999.;\n}\n\n// \nfloat bump( float x )\n{\n    return smoothstep( -2., 5., abs( x ) ) - smoothstep( 5., 32., abs( x ) );\n}\n\nvec3 go( vec2 h, float viewportZoom )\n{       \n    vec3 color = vec3( 0. );\n    int tileType;    \n    \n    float totalZoom = viewportZoom;\n\n    float colorScale = 1.;\n    while ( totalZoom < 50. )\n    {    \n        h = substitution( h, tileType );\n        color += colorForTile( tileType ) * bump( totalZoom ) * .15 * mix( 2., 0.2, totalZoom/20. );\n        totalZoom += zoom( tileType );\n    }\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n\n    vec2 h = TO_HEX0_HEX1 * uv;\n    \n    //float t = sin( iTime * 5. ) * .1; // test seamless looping\n    float t = iTime;\n    float viewportZoom = mod( t * 1.0, 4. ) * -2. - 16.;\n    \n    h *= pow( PLASTIC, viewportZoom );\n    h += FIXED_PT;    \n    \n    vec3 col = go( h, viewportZoom );    \n        \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}