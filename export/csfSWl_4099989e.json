{"ver":"0.1","info":{"id":"csfSWl","date":"1669779768","viewed":114,"name":"Game of Life Torus-verse","username":"Avicky","description":"Game of Life on a Torus","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["embam","julnelson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//first attempt at Torus. The plan is to run game of life on it. \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n      float t = iTime* .2;\n     \n     vec3 ro = vec3(0, 3, -3);\n     vec3 lookat = vec3(0);\n     float zoom = 1.;\n     \n     vec3 f = normalize(lookat-ro),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f, r),\n         c = ro + f* zoom,\n         i = c + uv.x * r + uv.y * u,\n         rd = normalize(i-ro);\n        \n    //float radius = 1.\n    float ds, d0;\n    vec3 p;\n    \n    for(int i=0; i<100; i++) {\n         p = ro + rd*d0;\n         ds = length(vec2(length(p.xz)-1.,p.y)) - .75;\n         if(ds<.001) break;\n         d0 +=ds;\n                              }\n    vec3 col = vec3(0);\n\n    if(ds<.001) {\n        float x = atan(p.x, p.z)+t;       //-p to pi\n        float y = atan(length(p.xz)-1.,p.y)+t;\n        col += sin(y*10.+x*20.);\n                }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n   int GetNeigbors(ivec2 p) { \n//ivec is a vector integer and p =position - how many neighbours are there  \n    int num = 0;\n                         \n   for(int y=-1; y<=1; y++) {\n       //Check the neighbour pixel by pixel staring with -1 for both x and y if alive or dead.\n       for(int x=-1; x<=1; x++)           {\n           if(x==0&&y==0) continue;\n           num += texelFetch(iChannel1, p+ivec2(x, y), 0).r > .5 ? 1 : 0; \n           \n           //if position + ivec is true then make cell alive,                                                                      //else dead. The pixels are initialised to black and white\n           //this call is checking the solidity of the color, if its 50% \n          //lighther than black then alive else dead.(first call to iChannel)\n                           }\n        \n                                   }\n    \n    return num;\n }  \n   \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec2 uv = fragCoord/iResolution.xy;\n     vec4 col = vec4(0);\n    // uv.x = abs(uv.x); \n    // uv.x -= .5;\n    //uv.y = abs(uv.y);\n     \n     if(iFrame<10)   //number of frame per second-\n            col = texture(iChannel0, uv);   //initialize color of red, change after the first 10 second.\n     else if(iFrame % SPEED != 0) // % operator divides iframe by 10, gives reminder - modula operation. After every 10 frames the, \n     //reminder = 0. This operation is to slow down the pixel movement so one can make sense of the acitivities on the screen.\n            col = texture(iChannel1, uv); // color is the color of background gotten from ichannel1 and texture coordinate.\n            \n     else {                // do life!     \n        bool alive = texelFetch(iChannel1, ivec2(fragCoord), 0).r > .5;// checking if the current pixel is alive - \n                                                                        //textelfetch takes pixel coordinate\n        int num = GetNeigbors(ivec2 (fragCoord));\n        \n       \n//LETS PLAY, GAME OF LIFE!!\n       int next = 0; //apply the rules. Start with a dead cell.\n        \n       if(alive && (num==2 || num==3)) //any cell with 2 or 3 life neigbours survives. rule (1)\n         next = 1;\n       else if(!alive && num==3)//if not but has 3 neigbours exactly, it survives to next generation.  rule (2)\n            next = 1;\n        else \n            next = 0;//the cell is dies. rule (3)\n            \n        col = vec4(next); \n   \n          \n    }\n    //Altering the funtion of the mouse\n        if(iMouse.z>0.5 && length (iMouse.xy/SIZE-fragCoord.xy)<BRUSH_SIZE) col = vec4(1); //if the pixel coordinate, fragcoord, is \n                                                 //smaller than 2 pixels,then put all of the values to one, give life to the dead cells.\n    \n  \n        fragColor = col;\n}\n\n  \n   \n   \n   \n   \n   \n   \n   \n ","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//global variable are kept in a common tab.\n\n#define SIZE 10.\n#define BRUSH_SIZE 1.\n#define SPEED 20 \n\n//size = pixel size\n//brush size = Mouse size\n//SPEED - controls the speed of the pixels. Inverse of speed, \n//the bigger is slower.","name":"Common","description":"","type":"common"}]}