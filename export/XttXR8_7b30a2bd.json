{"ver":"0.1","info":{"id":"XttXR8","date":"1526587748","viewed":96,"name":"bent camera and stuff","username":"jcolicchio","description":"i bent the camera around the x axis","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.14159265)\n#define TAU (PI*2)\n#define FOV (75.0)\n#define THRESH (0.01)\n#define MAX_STEPS (120)\n\nstruct Collision {\n    int id;\n    vec3 posInUnitSpace;\n    float dist;\n};\n\nfloat sdPlane(in vec3 p, in vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox(in vec3 p, in vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(in vec3 p, in float s )\n{\n  return length(p)-s;\n}\n\n// so our elements:\n// 0: backPlane\n// 1: sphere\n// 2: sphere\n// 3: box\n\n#define NONE (-1)\n#define PLANE0 (0)\n#define PLANE1 (1)\n#define SPHERE0 (2)\n#define SPHERE0_POS (vec3(cos(iTime)*100.0,-cos(iTime)*100.0,sin(iTime)*100.0+200.0))\n#define SPHERE0_R (100.0)\n#define SPHERE1 (3)\n#define BOX0 (4)\n#define BOX0_POS (vec3(0,cos(iTime)*100.0,200))\n\n#define BOX1 (5)\n#define BOX1_POS (vec3(-200,0,200))\n#define BOX1_SIZE (vec3(40,80,160))\n\n\n// i figured it out!\n// so if you want to bend around the x axis as you move forward with z\n// then you use z to generate the matrix\n// and multiply yz by m, because x remains unbent if you're bending around x\nfloat opCheapBendBox1(in vec3 p, out vec3 bentP)\n{\n    float c = cos(0.002*p.z);\n    float s = sin(0.002*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    bentP = vec3(p.x,m*p.yz);\n    return sdBox(bentP, BOX1_SIZE);\n}\n\nvec3 opCheapBendCamera(in vec3 p)\n{\n\tfloat c = cos(0.0007*p.z);\n\tfloat s = sin(0.0007*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(p.x,m*p.yz);\n}\n\nvoid compare(inout int curID, inout vec3 curPos, inout float curDist,\n             in int newID, in vec3 newPos, in float newDist) {\n    if(curID == NONE || newDist < curDist) {\n        curID = newID;\n        curPos = newPos;\n        curDist = newDist;\n    }\n}\n\n\nCollision dist(in vec3 pos, in int disabledID) {\n    // for a position in the world p\n    // find the nearest collision\n    \n    int curID = NONE;\n    vec3 curPos = vec3(0);\n    float curDist = 0.0;\n    int newID = NONE;\n    vec3 newPos = vec3(0);\n    float newDist = 0.0;\n    \n    if(disabledID != PLANE0) {\n        newID = PLANE0;\n        newPos = pos - vec3(0,0,300);\n        newDist = sdPlane(newPos, vec4(0,0,-1,0));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != PLANE1) {\n        newID = PLANE1;\n        newPos = pos - vec3(0,-108,100);\n        newDist = sdPlane(newPos, vec4(0,1,0,0));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != SPHERE0) {\n        newID = SPHERE0;\n\t    newPos = pos - SPHERE0_POS;\n\t    newDist = sdSphere(newPos, SPHERE0_R);\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != SPHERE1) {\n        newID = SPHERE1;\n        newPos = pos - vec3(100,0,100);\n        newDist = sdSphere(newPos, 40.0);\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != BOX0) {\n        newID = BOX0;\n        newPos = pos - BOX0_POS;\n        newDist = sdBox(newPos, vec3(50));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != BOX1) {\n        newID = BOX1;\n        newPos = pos - BOX1_POS;\n        vec3 bentPos;\n        newDist = opCheapBendBox1(newPos, bentPos);\n        compare(curID, curPos, curDist, newID, bentPos, newDist);\n    }\n    \n    return Collision(curID, curPos, curDist);\n}\n\nCollision map(inout vec3 pos, in vec3 ray, in int disabledID) {\n    for(int i=0;i<MAX_STEPS;i++) {\n        Collision c = dist(opCheapBendCamera(pos), disabledID);\n        pos += ray*c.dist;\n        if(c.dist < THRESH) {\n            return c;\n        }\n    }\n    return Collision(NONE,vec3(0),0.0);\n}\n\nvec4 texture(in Collision col, in vec3 pos) {\n    if(col.id == NONE) {\n        return vec4(0,0,0,1);\n    }\n    else if(col.id == PLANE0) {\n        vec2 uv = col.posInUnitSpace.xy*0.008;\n        return vec4(texture(iChannel0,uv).rgb,1);\n    }\n    else if(col.id == PLANE1) {\n        vec2 uv = col.posInUnitSpace.xz*0.0016-vec2(iTime/20.0,0.3);\n        return vec4(texture(iChannel1,uv).rgb,1);\n    }\n    else if(col.id == SPHERE0) {\n        return vec4(0,pos.z/300.0,0,1);\n    }\n    else if(col.id == SPHERE1) {\n    \treturn vec4(0,0,pos.z/300.0,1);\n    }\n    else if(col.id == BOX0) {\n        return vec4(pos.z/300.0,pos.z/300.0,0,1);\n    }\n    else if(col.id == BOX1) {\n        // the pos will be bended, i think?\n        // but i believe because we save the pos relative to box\n        // prior to bending it, it'll still be box units?\n        \n        return vec4((col.posInUnitSpace*-1.0/BOX1_SIZE),1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    vec3 pixel = vec3(uv*iResolution.xy, 0);\n    vec3 viewer = vec3(0,0,-tan(FOV/2.0*PI/180.0)*length(iResolution.xy)/2.0);\n    \n    vec3 ray = normalize(pixel - viewer);\n    \n    vec3 pos = viewer;\n    Collision col = map(pos, ray, NONE);\n    \n    // let's bounce it if it struck the green ball?\n    if(col.id == SPHERE0) {\n        vec4 base = texture(col, pos);\n        // get the normal given the position\n        vec3 sphereNorm = normalize(pos - SPHERE0_POS);\n        // reflect ray\n        vec3 reflectedRay = normalize(reflect(ray, sphereNorm));\n        col = map(pos, reflectedRay, SPHERE0);\n        vec4 refl = texture(col, pos);\n        fragColor = mix(base, refl, 0.8);\n    }\n    else {\n        fragColor = texture(col, pos);\n    }\n}","name":"Image","description":"","type":"image"}]}