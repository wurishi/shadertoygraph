{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec2 resolution;\nfloat time;\n\n\nvec2 local_coords(vec2 q) {\n\tvec2 r = -1.0 + 2.0 * q / resolution.xy;\n\tr.x *= resolution.x/resolution.y;\n\treturn r;\n}\n\nfloat negmod(float x, float y) {\n\treturn mod(x + y, y + y) - y;\n}\n\n//cylinder distance map\nfloat cylinder_dist(vec3 q) {\n\tvec3 qp;\n\tq.z += 0.3 * sin(q.y + q.x);\n\tq.x += 0.3 * cos(q.y + q.x);\n\tqp.x = negmod(q.x, 2.0);\n\tqp.y = negmod(q.y, 2.0);\n\tqp.z = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;\n \n  return length(qp.xz)- 0.1 + max(0.01 * (q.y + 5.0 * sin(q.z + q.x)), 0.0);\n}\n\n//sphere distance map\nfloat sphere_dist(vec3 q) {\n\tvec3 qp;\n\tq.x += 0.5 * cos(q.z * 0.1) + 0.5 * sin(q.x * 0.1) + 0.3 * sin(q.y + q.x);\n    q.y += 0.5 * sin(q.z) + 0.5 * cos(q.x);\n    q.z += 0.5 * sin(q.y * 0.1) + 0.5 * cos(q.x * 0.1) + 0.3 * cos(q.y + q.x);\n\tqp.x = negmod(q.x, 2.0);\n\tqp.y = negmod(q.y, 2.0);\n\tqp.z = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;\n\treturn length(qp) - 1.0\n\t\t+  0.1 * sin(q.x * 5.0 + 2.0 * q.z + 3.0 * q.y + time)\n\t\t+ 0.1 * cos(q.x * 2.3 + 4.1 * q.z + 1.8 * q.y + time*1.7)\n\t\t + max(0.1 * (q.y + 5.0 * sin(q.z + q.x) + 1.0), 0.0);\n}\n\nvec3 scene_color(vec3 q) {\n\tif (sphere_dist(q) < cylinder_dist(q))\n\t\treturn vec3(  0.1 * cos(1.5*q + time) + 0.7);\n\n\tvec2 qp;\n\tq.z += 0.3 * sin(q.y + q.x);\n\tq.x += 0.3 * cos(q.y + q.x);\n\tqp.x = negmod(q.x, 2.0);\n\tqp.y = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;\n\treturn vec3(dot(normalize(qp), vec2(0.5, -1.0))*0.2);\n}\n\n//scene render\nfloat scene(vec3 q) {\n\treturn min(sphere_dist(q), cylinder_dist(q));\n}\n\nvec3 path(float time) {\n\tvec3 p;\n\tp.x = 0.3 * cos(time) + 5.0 * cos(time * 0.2 + 9.8) + 10.0 * cos(time * 0.1 + 3.4) + 2.0;\n\tp.y = 0.25 * cos(time * 0.5) + 6.0 * cos(time * 0.3 + 3.4) + 9.0 * cos(time * 0.15 + 1.0) + 1.0;\n\tp.z = time;\n\treturn p;\n}\n\n//main loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\nresolution = iResolution.xy;\ntime = iTime;\n\t//convert screenspace to local space, preserving aspect ratio\n\tvec2 p = local_coords(fragCoord.xy);\n\n\tvec3 origin, track, dir;\n\t\n\t//set camera point\n\torigin = path(time);\n\ttrack = path(time + 1.0) + vec3(0.0, -0.1, 0.0);\n\tdir = normalize(track - origin);\n\t\n\tvec3 up = normalize(vec3(dir.x, 1.0, dir.z));\n\n\tvec3 rvec = normalize(cross(up, dir));\n\tvec3 uvec = normalize(cross(dir, rvec));\n\n\t//calculate projection ray\n\tvec3 ray = normalize(rvec * p.x + uvec * p.y + dir);\n\n\tvec3 q = origin;\n \tvec3 intr;\n\n \tfloat d = 0.0, t = 0.0;\nbool gave=  false;\n\n \tfor(int i = 0;(i < 85); i++)\n\t {\n\t  d = scene(q) * 0.65;\n\t  q += d * ray;\n\t  t += d;\n\t }\n\t intr = q;\n\n \tfloat fog = smoothstep(20.0, 40.0, t);\nvec3 sky = vec3(0.05) + abs(ray.y+1.0)*vec3(0.0,0.03,0.15);\nfloat sunprod = max(dot(ray, vec3(0.33,0.67,0.67)),0.0);\nvec3 sun =  vec3(0.8) * smoothstep(0.97, 0.99, sunprod) + vec3(0.05, 0.1, 0.1) * sunprod ;\n\n\tvec3 col = mix(scene_color(intr),sky+sun, fog);\nif (gave) col = vec3( 1.0,0.0,0.0);\n \tfragColor= vec4(col,1.0);\n }\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdl3R2","date":"1374620495","viewed":213,"name":"Blob Field","username":"choard1895","description":"This is one of the first distance field shaders I made when I was figuring them out. Very unpolished.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["moon","distance","field","cotton"],"hasliked":0,"parentid":"","parentname":""}}