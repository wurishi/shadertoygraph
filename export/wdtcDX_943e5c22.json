{"ver":"0.1","info":{"id":"wdtcDX","date":"1601996247","viewed":275,"name":"Fake Planet Atmosphere","username":"shicz86","description":"references:\nhttps://www.youtube.com/watch?v=OCZTVpfMSys\nhttps://www.youtube.com/watch?v=HFPlKQGChpE","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raysphereplanetatmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 planetCenter = vec3(0.,0.,2.3);\nvec3 atmosphereCenter = vec3(0.,0.,2.3);\nfloat planetRadius = .8;\nfloat atmosphereRadius = 1.;\n\nvec3 ambientLight = vec3(1.);\nvec3 lightIntensity = vec3(1.);\nfloat lightIntensityScale = 3.;\n\nvec3 rimLight = vec3(.21,.12,.5);\nfloat rimPower = 3.;\nfloat rimLightScale = 1.5;\n\nvec3 atmosphereCol1 = vec3(0.98,0.07,0.1);\nvec3 atmosphereCol2 = vec3(0.95,0.98,0.31);\n\nfloat thickness = .9;\n\nfloat EPSILON = 0.0001;\n\nfloat sdfSphere(in vec3 p,in vec3 center,in float radius){\n\treturn length(p-center)-radius;\n}\n\nvec2 N22(in vec2 p ){\n    return fract(sin(vec2(dot(p,vec2(234234.1,54544.7)),sin(dot(p,vec2(33332.5,18563.3)))))*323434.34344);\n}\n\nvec3 star(in vec2 st,in float scale){\n\tst *= scale;\n    \n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    vec2 tpos = N22(ipos);\n    \n    float dist = length(fpos-tpos);\n    float threshold = 0.02;\n    return vec3(1.-step(threshold,dist));\n}\n\nvec3 sphereNormal(in vec3 p,in vec3 center,in float radius){\n\treturn normalize(vec3(\n        sdfSphere(vec3(p.x+EPSILON,p.y,p.z),center,radius)-sdfSphere(vec3(p.x-EPSILON,p.y,p.z),center,radius),\n        sdfSphere(vec3(p.x,p.y+EPSILON,p.z),center,radius)-sdfSphere(vec3(p.x,p.y-EPSILON,p.z),center,radius),\n        sdfSphere(vec3(p.x,p.y,p.z+EPSILON),center,radius)-sdfSphere(vec3(p.x,p.y,p.z-EPSILON),center,radius)\n    ));\n}\n\nvec3 planetPhongLightingModel(in vec3 k_d,in vec3 k_s,in float shininess,in vec3 p,in vec3 eyePos,in vec3 lightPos,in vec3 lightIntensity){\n\tvec3 N = sphereNormal(p,planetCenter,planetRadius);\n    vec3 L = normalize(lightPos-p);\n    vec3 V = normalize(eyePos-p);\n    vec3 R = normalize(reflect(-L,N));\n    \n    float dotLN = dot(L,N);\n    float dotRV = dot(R,V);\n    if(dotLN<0.)\n    {\n        return vec3(0.,0.,0.); // light not visible from this point on the surface\n    }\n    if(dotRV<0.)\n    {\n        return lightIntensity*(k_d*dotLN); // light reflection in opposite direction as viewer,apply only diffuse component\n    }\n    return (k_d*dotLN+k_s*pow(dotRV,shininess))*lightIntensity;\n}\n\nvec3 phongIllumination(in vec3 k_a,in vec3 k_d,in vec3 k_s,in float shininess,in vec3 p,in vec3 eyePos,in vec3 lightPos){\n    vec3 color = ambientLight*k_a;\n    \n    color += planetPhongLightingModel(k_d,k_s,shininess,p,eyePos,lightPos,lightIntensity*lightIntensityScale);\n    \n    vec3 N = sphereNormal(p,planetCenter,planetRadius);\n    vec3 L = normalize(lightPos-p);\n    vec3 V = normalize(eyePos-p);\n    \n    // rim light\n    float rim = 1.-clamp(dot(V,N),0.,1.);\n    vec3 rimColor = rimLightScale*(rimLight*pow(rim,rimPower));\n    \n    float NDotL = 1.-(dot(L,N));\n    return color + rimColor*NDotL;\n}\n\nbool hit(in vec3 ro,in vec3 rd,in vec3 center,in float radius,out float t1,out float t2,out float t0){\n\tbool bHit = false;\n    t0 = dot(center-ro,rd);\n    vec3 p = ro+rd*t0;\n    \n    float y = length(center-p);\n    if(y<radius)\n    {\n    \tbHit = true;\n    \tfloat x = sqrt(radius*radius-y*y);\n        t1 = t0-x;\n        t2 = t0+x;\n    }\n    return bHit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.)); \n    \n    // star layer\n    vec2 st = fragCoord/iResolution.y;\n    col += star(st,25.);\n    \n    float t0,t1,t2;\n    bool bHit1 = hit(ro,rd,atmosphereCenter,atmosphereRadius,t1,t2,t0);\n    if(bHit1){\n        vec3 lightPos = vec3(4.0*sin(iTime),1.,4.0*cos(iTime));\n        \n        vec3 p1 = ro+rd*t1;\n        vec3 np1 = sphereNormal(p1,atmosphereCenter,atmosphereRadius); \n        \n        float NDotL = clamp(max(dot(normalize(lightPos),np1),0.),0.,1.);\n        vec3 atmosphereCol = mix(atmosphereCol1,atmosphereCol2,NDotL);\n        float alpha = clamp((t2-t1)*thickness,0.,1.);\n        \n        col = mix(col,atmosphereCol,alpha);\n        \n        float NDotL2 = exp(2.*NDotL-2.);\n\t\tcol = col*NDotL2;\n        \n        float t00,t11,t22;\n        bool bHit2 = hit(ro,rd,planetCenter,planetRadius,t11,t22,t00);\n        if(bHit2){\n            vec3 k_a = vec3(.1,.1,.25);\n            vec3 k_d = vec3(.1,.25,.65);\n            vec3 k_s = vec3(0.);\n            float shininess = 0.;\n\n            vec3 p2 = ro+rd*t11;\n            vec3 planetCol = phongIllumination(k_a,k_d,k_s,shininess,p2,ro,lightPos);\n\n            alpha = clamp((t11-t1)*thickness,0.,1.);\n\n            col = mix(planetCol,col,alpha+NDotL2*.5);\n            //col = mix(planetCol,col,alpha);\n        }\n    }\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}