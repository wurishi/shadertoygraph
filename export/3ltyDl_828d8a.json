{"ver":"0.1","info":{"id":"3ltyDl","date":"1610241276","viewed":150,"name":"Genuary2021 Day9: Interferences","username":"qw","description":"Entry for Day 9 of #Genuary2021 - see https://genuary2021.github.io/\nPrompt of the day: Interferences\n\nFlow map generated in Buffer A (2 circular wave patterns hitting each other), and in B: distorting an \"outrun\" style environment generated procedurally","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["distortion","interference","outrun","pattern","flowmap","genuary2021","genuary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI2 6.283\n\n\nvec2 FlowCircle(vec2 uv, vec2 pos, float radius, float freq, float rate){\n\n    float len = length(uv-pos);\n    vec2 dir = normalize(uv-pos);\n    float t = iTime * rate;\n    vec2 flowDir = dir * sin(t+len * PI2 * freq );\n    return flowDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     // Normalized pixel coordinates (from 0 to 1)\n    float height01 = fragCoord.y/iResolution.y;\n    vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n\n    vec2 circlePos1 = vec2(0.0,0.2);\n    vec2 circlePos2 = vec2(0.0,-0.4);\n\n    float radius = .04;\n    float len1 = length(uv-circlePos1);\n    float len2 = length(uv-circlePos2);\n    float mask = (len1 + len2) * clamp(.5-abs(uv.x -.0),0.,1.);\n    mask = clamp(mask,0.,1.);\n    \n    \n    float freq = 10.;\n    vec2 val = FlowCircle(uv, circlePos1, radius, freq, -2.);\n    val += FlowCircle(uv, circlePos2, radius, freq, -2.);\n    val /= 2.;\n    \n    //Scale -1 <-> 1 to 0 <-> 1 scale\n    val = (val *.5) +.5;\n    val = mix(vec2(.5), val, mask);//dist\n    \n    \n    fragColor = vec4(val.xy,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 Background(in vec2 uv){\n    \n    uv.x *= iResolution.x / iResolution.y; // Square ratio\n    float thick = .04;\n    float horiz = length( fract(uv.x * 10.) )- thick;\n    float verti = length( fract(uv.y * 10.) )- thick;\n    float result =  smoothstep( horiz - 1.5/iResolution.y, horiz , .1) +\n                     smoothstep( verti - 1.5/iResolution.y, verti , .1);\n\n    return vec3(1) * min(1.,result);\n}\n\nfloat HorizontalLine(vec2 pos, vec2 uv, float thickness){\n    if(uv.y > pos.y - (thickness*.5) &&\n        uv.y < pos.y + (thickness*.5) ){\n        return 1.;\n    }\n    return 0.;\n}\n\n\nvec3 Background2(in vec2 uv){\n    \n    vec3 result = vec3(0);\n    vec2 orig_uv = uv; \n    float ratio = iResolution.x / iResolution.y; // Square ratio \n    uv.x *= ratio;\n    \n    vec3 bottomGridCol1 = vec3(0.478, 0.015, 0.921); \n    vec3 bottomGridCol2 = vec3(0.996, 0.458, 0.996);\n    vec3 skyTopCol = vec3(0.070, 0.015, 0.345);\n    vec3 skyBtmCol = vec3(1, 0, 0.627);\n    vec3 sunBtmCol = vec3(1, 0.070, 0.309);\n    vec3 sunTopCol = vec3(1, 0.572, 0);\n    vec3 bgCol = vec3(0.1, 0.0, 0.2);\n    \n    float thick = .01;\n    vec2 bottomGridUV = uv;\n    \n    \n    bottomGridUV.y *=2.;\n    bottomGridUV.x += (.5 -orig_uv.x) * -4. * bottomGridUV.y;\n    \n    \n    float horiz = length( fract(bottomGridUV.x * 15.) )- thick;\n    float verti = length( fract(bottomGridUV.y * 15.) )- thick;\n    float bottomGrid =  smoothstep( horiz - 1.5/iResolution.y, horiz , .04) +\n                     smoothstep( verti - 1.5/iResolution.y, verti , .04);\n\n    float floorMask = (1.- step(0.8,bottomGridUV.y));\n    result += mix(bottomGridCol1,bottomGridCol2, clamp( bottomGrid,0.,1.) ) * floorMask;\n    \n    vec3 skyCol = mix(skyBtmCol, skyTopCol, orig_uv.y);\n    result += mix(skyCol, vec3(0), floorMask);\n    \n    \n    //BACKGROUND\n    float backgroundDetailMask = sin(uv.x * 15. )*.1 ;\n    backgroundDetailMask += sin(2.2+uv.x * 3.) * 0.4;\n    backgroundDetailMask += sin(uv.x * 2.) * 0.15;\n    float detailVerticalOffset = 1.85;\n    float backgrDetailL = backgroundDetailMask - (uv.y*4.) + detailVerticalOffset; \n    backgroundDetailMask = 1.-smoothstep( backgrDetailL - 1.5/iResolution.y, backgrDetailL , .04);\n    backgroundDetailMask = clamp( backgroundDetailMask - floorMask, 0.,1.);\n    \n    result = mix(result, bgCol, backgroundDetailMask);\n    \n    \n    //Sun \n    vec2 centeredUV = orig_uv;\n    centeredUV.x -=0.5;\n    centeredUV.x *= ratio;\n    vec2 sunPos = vec2(0.,.5);\n    float sunSize = .2;\n    float sunL = (length(centeredUV - sunPos) ) - sunSize ;\n    float sunMask = smoothstep(sunL - 1.5/iResolution.y, sunL, .1);\n    sunMask = clamp(sunMask - floorMask,0.,1.); // Mask with ground\n    //now mask some horizontal lines in the sun for that classic \"outrun\" look\n    sunMask = clamp(sunMask - floorMask,0.,1.); // Mask with ground\n     \n    sunMask = clamp( sunMask - HorizontalLine(vec2(0.,.445),uv, .040), 0.,1.);\n    sunMask = clamp( sunMask - HorizontalLine(vec2(0.,.51),uv, .025), 0.,1.);\n    sunMask = clamp( sunMask - HorizontalLine(vec2(0.,.57),uv, .015), 0.,1.);\n    sunMask = clamp( sunMask - HorizontalLine(vec2(0.,.61),uv, .009), 0.,1.);\n     \n    float sunColorGradientMask = ((uv.y*3.) - 1.2);\n    vec3 sunCol = mix(sunBtmCol,sunTopCol,sunColorGradientMask);\n    result = mix(result, sunCol, sunMask);\n    \n    \n    return vec3(result);\n\n}\n\n\n\nvec3 SampleFlow(vec2 uv){\n    \n    float strength = .1*iResolution.y;\n    vec2 sampleSize =   (vec2(1.) / iResolution.y) * strength;\n    \n    vec2 flowDir = ( texture(iChannel0,uv).rg);\n    flowDir -= vec2(.5);\n    flowDir *= 2.;\n                   \n    vec3 col = Background2( uv + vec2(flowDir * sampleSize));\n    //vec3 col = Background2( uv);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = (fragCoord)/iResolution.xy;\n\n    vec3 flow = texture(iChannel0,uv).rgb;\n\n    vec3 col = vec3(0);\n    if(iFrame == 0){\n        col+= texture(iChannel1,uv).rgb;\n    }else{\n        col += SampleFlow(uv);\n    }\n    \n    //See flow map\n  // col =  texture(iChannel0,uv).rgb;\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}