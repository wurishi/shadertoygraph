{"ver":"0.1","info":{"id":"WscyRl","date":"1601649343","viewed":812,"name":"PBR, IBL, AO, Shadow","username":"deadiablo","description":"PBR, IBL, AO, Shadow","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["shadow","ao","ibl","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define heightMapChannel iChannel0\n#define heightMapResolution iChannelResolution[0].xy\n#define DEPTH 30.0\n\n#define cubeMap iChannel1\n#define cubeMapResolution iChannelResolution[1].xy\n\n#define HEIGHT_LIGHT 35.0\n#define HEIGHT_PLANE 0.0\n\n#define LIGHT_RADIANCE 300.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define ALBEDO vec3(1.0, 1.0, 1.0)\n#define METALNESS 0.2\n#define ROUGHNESS 0.2\n\n#define DIFFUSE_LOD 8.0\n\n#define AO_SAMPLES 8.0\n#define AO_ATTENUATION 5.0\n#define AO_RADIUS 0.1\n#define AO_POWER 4.0\n\n#define SHADOW_STEPS 64.0\n#define SHADOW_POWER 8.0\n#define SHADOW_COLOR vec3(0.0)\n\nconst float PI = 3.14159265359;\n\n//HEIGHT MAP TO NORMAL MAP\nfloat getHeight(sampler2D heightMap, vec2 uv)\n{\n  \treturn texture(heightMap, uv).r;\n}\n\nvec3 normalFromHeight(sampler2D heightMap, vec2 uv, vec2 resolution, float depth)\n{    \n    vec2 delta = 1.0 / resolution;\n    //float height = getHeight(heightMap, uv);\n    //float dxHeight = height - getHeight(heightMap, uv + vec2(delta.x, 0.0));\n    //float dyHeight = height - getHeight(heightMap, uv + vec2(0.0, delta.y));\n    float dxHeight = getHeight(heightMap, uv - vec2(delta.x, 0.0)) - getHeight(heightMap, uv + vec2(delta.x, 0.0));\n    float dyHeight = getHeight(heightMap, uv - vec2(0.0, delta.y)) - getHeight(heightMap, uv + vec2(0.0, delta.y));\n  \treturn normalize(vec3(dxHeight, dyHeight, 1.0 / depth));\n}\n\n//AO\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat AOfromHeight(sampler2D heightMap, vec2 uv)\n{\n    float height = getHeight(heightMap, uv);\n    \n    float result = 0.0;\n    for (float f = 0.0; f < 1.0; f += 1.0 / AO_SAMPLES)\n    {\n        float randUoffset = random(vec2(f * 16524.56, f * 23532.43));\n        float randVoffset = random(vec2(f * 21384.12, f * 11835.78));\n        vec2 offset = vec2(randUoffset, randVoffset) * 2.0 - 1.0;\n        offset *= AO_RADIUS;\n        result += max(texture(heightMap, uv + offset).r - height, 0.0);\n    }\n    result /= AO_SAMPLES;\n    result = pow(1.0 - result, AO_POWER);\n    return result;\n}\n\n//Shadow\nfloat Shadow(vec3 lightPosition, sampler2D heightMap, vec2 uv)\n{\n    float height = getHeight(heightMap, uv);\n    float lightHeight = lightPosition.z / DEPTH;\n    float deltaZ = lightHeight - height;\n    \n    float shadow = 0.0;\n    \n    vec2 lightUV = lightPosition.xy / heightMapResolution;\n    vec2 offsetUV = (lightUV - uv);\n    \n    for (float delta = 0.0; delta < 1.0; delta += 1.0 / SHADOW_STEPS)\n    {\n        float pointHeight = getHeight(heightMap, uv + delta * offsetUV);\n        float rayHeight = height + delta * deltaZ;\n        shadow += max(0.0, pointHeight - rayHeight);\n    }\n    return clamp(shadow * SHADOW_POWER, 0.0, 1.0);\n}\n\n//PBR\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return a2 / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n} \n\nvec3 fresnelSchlick(vec3 F0, float cosTheta)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 offset = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 resolution = iResolution.yy;\n  \tvec2 uv = fragCoord.xy / resolution * 2.0 - offset;\n    \n    vec3 lightPoint = vec3((iMouse.xy / resolution * 2.0 - offset) * heightMapResolution, HEIGHT_LIGHT);\n    vec3 planePoint = vec3(uv * heightMapResolution, HEIGHT_PLANE);\n    \n    vec3 albedo = ALBEDO;\n    float metalness = METALNESS;\n    float roughness = ROUGHNESS;\n    float ao = AOfromHeight(heightMapChannel, uv);\n\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metalness);\n    \n    vec3 N = normalFromHeight(heightMapChannel, uv, heightMapResolution, DEPTH);\n    vec3 V = vec3(0.0, 0.0, 1.0);\n    \n    vec3 directLighting = vec3(0);\n    {\n        vec3 L = normalize(lightPoint - planePoint);\n        vec3 H = normalize(V + L);\n\n        float distance = length(lightPoint - planePoint);\n        float attenuation = LIGHT_RADIANCE * LIGHT_RADIANCE / (distance * distance);\n        vec3 radiance = LIGHT_COLOR * attenuation; \n\n        float NdotL = max(dot(N, L), 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n        float NdotV = max(dot(N, V), 0.0);\n\n        float D = DistributionGGX(N, H, roughness); \n        vec3 F = fresnelSchlick(F0, VdotH);      \n        float G = GeometrySmith(N, V, L, roughness);\n\n        vec3 numerator = (D * G) * F;\n        float denominator = 4.0 * NdotV * NdotL;\n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metalness;\n\n        vec3 specular = numerator / max(denominator, 0.001);   \n        vec3 diffuse = kD * albedo / PI * ao;\n        \n        vec3 color = (diffuse + specular) * radiance * NdotL;\n\n        color = color / (color + vec3(1.0));\n        directLighting = pow(color, vec3(1.0/2.2));  \n    }\n    \n    vec3 indirectLighting = vec3(0);\n    {\n        float NdotV = max(dot(N, V), 0.0);\n        vec3 F = fresnelSchlickRoughness(F0, NdotV, roughness);\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metalness;\n\n        vec3 irradiance = textureLod(cubeMap, N, DIFFUSE_LOD).rgb;\n        vec3 diffuseIBL = kD * albedo * irradiance * ao;\n\n        vec3 R = -reflect(V, N);\n        vec3 specularColor = textureLod(cubeMap, R, roughness * DIFFUSE_LOD).rgb;\n        vec3 specularIBL = specularColor * kS;\n\n        indirectLighting = diffuseIBL + specularIBL;\n    }\n\n    float shadow = Shadow(lightPoint, heightMapChannel, uv);\n    directLighting = mix(directLighting, SHADOW_COLOR, shadow);\n    \n    fragColor = vec4(directLighting + indirectLighting, 1.0);\n}","name":"Image","description":"","type":"image"}]}