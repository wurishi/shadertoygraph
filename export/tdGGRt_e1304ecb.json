{"ver":"0.1","info":{"id":"tdGGRt","date":"1570805919","viewed":147,"name":"metaball3d","username":"lewdoo","description":"Ray-marched metaballs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float _Gloss = 400.;\nfloat _BallCount = 6.;\n\n//controls ball positioning\nvec3 getSource(float i) {\n    i = (sin(i + .2) * 6.) + 2.;\n    return vec3(4., -2.,22.) \n           \t\t + vec3(dot(i,0.1)*sin(iTime*mod(i,5.0)*0.6)*4.0,\n                        dot(i,0.4)*sin(iTime*mod(i,3.)*0.4)*4.0, dot(i,0.2)*sin(iTime*mod(i,3.)*.5)*0.1);    \n}\n\n//controls the merging\nfloat metaField(in vec3 m, out vec3 normal) {\n    \n    normal = vec3(0,0,0);\n    float fieldi = 0.0;\n    \n    //mouse control of ball\n    \n    vec3 so = vec3((iMouse.xy / iResolution.xy - vec2(0.35, 0.55)) * 15., 22.);\n    float dis = length(m - so);\n    float s = 1. / (dis*dis);\n    vec3 l = normalize(m - so);\n    normal += l * s;\n    fieldi += s;\n    \n    for(float i=0.; i<_BallCount; i++) {\n        \n        vec3 source = getSource(i); //source is the ball position\n        float d = length(m - source); //d is the distance from the position to the current draw dist\n        \n        float size = 1. / (d*d); //how big i want that layer to draw\n        vec3 localNormal = normalize(m - source); //the normal of the blobs\n        \n        normal += localNormal * size;\n        fieldi += size;\n    }\n    \n    normal = normalize(normal);\n    return fieldi;\n}\n\n\nfloat rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out vec3 normal) {\n    \n    float\tmDist = 0.0;\n\n \tm = origin;   \n    \n    \n    \n    \n    for(int i=0; i<140; i++) {\n    \tfloat fieldIntensity = metaField(m, normal);\n        \n        if(fieldIntensity > 0.5) {\n            //return 1.;\n        }\n        //else if(fieldIntensity > 0.475 && fieldIntensity < 0.5){\n        //\treturn 0.8;\n        //}\n        else {\n            mDist += 0.2;\n        \tm = origin + ray * mDist;    \n        }\n    }\n    \n    float fieldIntensity = metaField(m, normal);\n    if(fieldIntensity > 0.5){\n    \treturn 1.;\n    }//returns the glow\n    else if(fieldIntensity > 0.01){\n    \treturn pow(fieldIntensity * 2.6, 2.);\n    }\n\treturn 0.;    \n}\n\nvec4 getCol(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light) {\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = dot(normal, -lightRay);\n\n    vec3 reflectedL  = reflect(lightRay, normal);\n    float hLight \t\t = pow(max(dot(reflectedL, -ray),0.0), _Gloss);\n\n    vec3 baseColor = vec3(0.2,0.5,0.8)*1.5 + normal * .4;\n\n    vec3 diff = baseColor * 0.5 * diffuse;\n    vec3 shine = vec3(1.0, 1.0, 1.0) * hLight;    \n    vec3 ambiant = baseColor * 0.7;        \n\n    return vec4(diff + shine + ambiant, 1.0);\n}\n\n\nmat3 rotXY(const in vec2 angle ) \n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\t\n\treturn mat3(c.y, 0.0, -s.y,\n\t\t\t\ts.y * s.x, c.x, c.y * s.x,\n\t\t\t\ts.y * c.x, -s.x, c.y * c.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    vec2 mo = vec2(0.5);\n\tmo = iMouse.xy/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    \n    vec3 ro = vec3(1.,.0,0.);\n\tro *= rotXY(vec2(-mo.x,-mo.y*1.5));\n    \n    vec3 cam = vec3(-.7, -.45, -0.4);\n    //cam.x += sin(iTime) * 0.5;\n    //cam.z += cos(iTime) * 0.5;\n    vec3 ray = normalize(vec3(uv, 1.) - cam);\n    vec3 light = vec3(-15.0, 5.0, 5.0);\n    \n    vec3 m;\n    vec3 normal;\n    \n    float r = rayMarching(cam, ray, m, normal);\n    if(r == 1.) {\n        fragColor = getCol(ray, m, normal, light);\n    }\n    else if(r != 0.){\n        vec4 outCol = vec4(vec3(r* 8.) * vec3(0.2,0.5,0.8)*1.1, 1.);\n    \tfragColor = outCol;\n    }\n    \n    vec2 st = uv;\n    st.y -= iTime * 0.002;\n    vec3 n = vec3(fract(sin(uv.x * 49.4758 + st.y *742.923) + uv.x * 253.5235 + sin(st.y * 238.432))) * 0.045;\n    vec3 cn = n + vec3(0.4, 0.4, 0.4) * 0.56;\n    float rim = 1. - pow(length(uv + vec2(0.6, 0.5)), 1.4) * 1.5;\n    //cn *= vec3(rim);\n    \n    fragColor += vec4(cn, 1.);\n    fragColor *= rim * 0.7;\n}\n\n\n//to lava lamp it just make fake groups and scroll them up with sin\n//then make a tier for on click that drags them all to the centre by different speeds- would look sick\n","name":"Image","description":"","type":"image"}]}