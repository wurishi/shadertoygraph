{"ver":"0.1","info":{"id":"wt2BWK","date":"1599904865","viewed":1135,"name":"reflection","username":"nerumae3","description":" ","likes":36,"published":3,"flags":8,"usePreview":0,"tags":["3d","raymarching","sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SPHERE 0.0\n#define MAT_FLOOR 1.0\n#define MAT_BOX 2.0\n#define bpm 138.\n#define pi acos(-1.)\n#define pi2 pi*2.\n#define rep(p,r) mod(p,r)-r*.5;\n#define repid(p,r) (floor((p) / r))\n#define saturate(x) clamp(x,0.,1.)\n\n#define beat iTime*bpm/60.\n#define speed 16.\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);   \n}\n\nfloat easeIn(float t) {\n    return t * t;\n}\n\nfloat easeOut(float t) {\n    return -1.0 * t * (t - 2.0);\n}\n\nfloat rand(float p)\n{\n    return fract(sin(p*43758.5453));  \n}\n\nfloat noise(vec2 p)\n{\n    vec2 i=floor(p),f=fract(p);\n    f=f*f*(3.-2.*f);\n    return mix(\n        mix(rand(i),rand(i+vec2(1.,0.)),f.x),\n        mix(rand(i+vec2(0.,1.)),rand(i+vec2(1.)),f.x),\n        f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float amp=.5,val;\n    for(int i=0;i<4;i++)\n    {\n        val +=noise(p)*amp;\n        amp *= .5;\n        p*=2.;\n    }\n    return val;\n}\n\nmat2 rot(float r)\n{\n    float s=sin(r),c=cos(r);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = pi/r - atan(p.x, p.y);\n    float n = pi2/r;\n    a = floor(a/n) * n;\n    return p * rot(a);\n}\n\nfloat luminace(vec3 col)\n{\n    return dot(vec3(0.298912,0.58611,0.114478),col);   \n}\n\nvec3 saturation(vec3 col,float scale)\n{\n    return mix(vec3(luminace(col)),col,scale);   \n}\n\nvec3 contrast(vec3 col,float scale)\n{\n    return (col-.5)*scale+.5;\n}\n\nvec3 colorCorrect(vec3 col){\n    col = saturation(col,1.4);\n    col = pow(col,vec3(2.5));\n    //col = pow(col,vec3(1.5));\n    col = col*vec3(.6,.9,1.0);\n    return col;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat vignette(vec2 p,float s){\n    p *= 1.-p.yx;\n    float vig = p.x*p.y*30.;\n    vig = clamp(pow(vig,s),.0,1.);\n    return vig;\n}\n\nfloat sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1,vec2 d2)\n{\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    \n    float t = iTime;\n    float start = step(0.,beat);\n    float end=saturate(beat-120.);\n    vec3 q = p;\n    \n    vec3 sp = vec3(0.,0.,-t*speed);\n    \n    q+=sp;\n    \n    float l1 = easeOut(1.-clamp(7.*.2-length(q.xz*.05)-t*.2,0.,1.));\n    float l2 = easeOut(clamp(64.*.8-length(q.xz*.05)-t*.8,0.,1.));\n    float l = 1.;\n    l = mix(l,l1,start);\n    l = mix(l,l2,end);\n    float d1 = sphere(q,.5*l);\n    \n    q=p;\n    \n    q+=sp;\n    for(int i=0;i<2;i++)\n    {\n        q = abs(q)-.25;\n        q.xz *= rot(1.);\n        q.xy *= rot(1.+iTime);\n        \n    }\n    float d2 = sdBox(q,vec3(.125,.5,.124)*l);\n    d1 = mix(d1,d2,pow(sin(fract(beat)*pi)*.5+.5,8.));\n    vec2 s = vec2(d1,MAT_SPHERE);\n    \n    q=p;\n    q= -abs(q);\n    vec2 fl = vec2(q.y+10.5*l+.05,MAT_FLOOR);\n    \n    //vec2 fl2 = vec2 (q.x+10.5*l+.05,MAT_FLOOR);\n    q=p;\n    q.xz = rep(q.xz,2.);\n    \n    //fl = opS(fl,fl2);\n    vec2 tri = vec2(1.);\n    \n    //q.xy *= rot(.2);\n    \n    q = p;\n    q.xy = pmod(p.xy,3.);\n    q.z = rep(p.z,10.);\n    vec2 box = vec2(sdBox(q-vec3(0.,5.,0.),vec3(.5)),MAT_BOX);\n    \n    q = p;\n    \n    q.y = abs(q.y)-2.1;\n    q.xz = rep(q.xz,14.);\n    for(int i=0;i<4;i++)\n    {\n        q = abs(q)-2.4;\n        q.xy *= rot(2.025+(1.-l));\n        \n    }\n    \n    vec2 w = vec2(sdBox(q,vec3(2.,1.2,.2)),MAT_BOX);\n    q=p;\n    vec2 d = opU(s,fl);\n    //d = opU(d,box);\n    d = opU(d,w);\n    return d;\n}\n\nvec4 volMap(vec3 p)\n{\n \tvec3 q = p;\n    q.xy *= rot(pi*.25);\n    float zid = repid(q.z,10.);\n    q.z = rep(q.z,10.);\n    \n    q = abs(q);\n    q.xy =abs(q.xy)-5.;\n    float d = length(q.xz)-.05;\n    d = min(d,length(q.yz)-.05);\n    float r0 = rand(zid);\n    vec3 col = vec3(.2,.8,.8)*(.1+0.9*exp(-13.*fract(beat*4.)))*.01;\n    return vec4(col,d);\n}\n\nvec4 volMap2(vec3 p)\n{\n    vec3 q=p;\n    q.xy = pmod(q.xy,3.);\n    //float d = sdCappedCylinder(q-vec3(0.,5.,0.),.1,2.1);\n    q.y -=5.;\n    \n    float d = length(q.yx)-.1;\n    \n    \n    vec3 col = vec3(.9,.2,.2)*(.00+1.*exp(-13.*fract(beat*.5)))*.2;\n    return vec4(col,d);\n}\n\nvec4 volMap3(vec3 p)\n{\n    vec3 q=p;\n    q.xy *= rot(pi);\n    q.xy = pmod(q.xy,3.);\n    //float d = sdCappedCylinder(q-vec3(0.,5.,0.),.1,2.1);\n    q.y -=5.;\n    float d = length(q.yx)-.1;\n   \n    \n    vec3 col = vec3(.2,.2,.9)*(.00+1.*exp(-13.*fract(beat*.5+.5)))*.2;\n    return vec4(col,d);\n}\n\nvec4 volMap4(vec3 p)\n{\n    vec3 q=p;\n    \n    //q.xz = rep(q.xz,14.);\n    \n    //float d = sdCappedCylinder(q-vec3(0.,5.,0.),.1,2.1);\n    //q.y =abs(q.y)-1.7;\n    vec3 id = repid(q,7.);\n    q.z = rep(q.z,7.);\n    \n    q.y = abs(q.y)-8.;\n    float d = length(q.zy)-.025;\n   \n    \n    vec3 col = vec3(.6,.4,.7)*.025*(0.01+1.*exp(-13.*fract(beat+.5)));\n    return vec4(col,d);\n}\n\nvec4 volMap5(vec3 p)\n{\n    vec3 q=p;\n\tvec3 sp = vec3(0.,0.,-iTime*speed);\n    q+=sp;\n\n    \n    float d = length(q)-.125;\n   \n    \n    vec3 col = vec3(.98,.2,.2)*.025;//*(0.01+1.*exp(-1.*fract(beat)));\n    return vec4(col,d);\n}\n\nvec3 normal(vec3 p)\n{\n  float e = 0.001;\n  vec2 k = vec2(1.,-1.);\n  return normalize(\n      k.xyy * map(p+k.xyy*e).x+\n      k.yxy * map(p+k.yxy*e).x+\n      k.yyx * map(p+k.yyx*e).x+\n      k.xxx * map(p+k.xxx*e).x\n    );\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.01;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 64; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n\nvec3 glow(vec3 ro,vec3 rd,float depth)\n{\n  float t = 0.01;\n  vec4 d;\n  float sd = depth/99.;\n  vec3 ac;\n  float[] parts = float[](0.,1.,0.,1.);\n  float part = parts[int(mod(beat*.125*.25,4.))];\n    \n    float[] parts2 = float[](1.,1.,0.,1.);\n  float part2 = parts2[int(mod(beat*.125*.25,4.))];\n  for(int i = 0;i<60;i++)\n  {\n      if(t>depth) break;\n      vec3 pos = ro+rd*t;\n      d = volMap(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.))*part2 * smoothstep(4.,12.,iTime);\n      \n      \n      d = volMap2(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.))*part;\n      \n      d = volMap3(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.))*part;\n      \n      d = volMap4(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.));\n      \n      d = volMap5(pos);\n      d.w = max(0.01,d.w);\n      ac += (d.rgb*sd)/(pow(d.w,2.));\n      \n      t += sd;\n  }\n  return ac;\n}\n\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (pi * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k)\n{\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickWithRoughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//Kaneta SkyColor \n//https://www.shadertoy.com/view/3lXfzS\nvec3 skyColor(vec3 rd, float roughness)\n{\n    vec3 baseColor = mix(vec3(0.3,0.5,0.8)*0.8, vec3(0.3,0.5,0.8) * 0.5, rd.y);\n    baseColor = mix( baseColor, vec3(0.2,0.5,0.85)*0.5, 1.0 - pow(1.0-max(-rd.y,0.0), 1.5));\n    vec3 skyColor = baseColor;\n    skyColor = mix( skyColor, vec3(0.9,1.1,1.2) * 1.5, pow( 1.0-max(rd.y,0.0), 8.0 ) );\n    skyColor = mix( skyColor, vec3(0.2,0.5,0.85)*0.2, 1.0 - pow(1.0-max(-rd.y,0.0), 6.0));\n    \n    return mix(skyColor, baseColor, pow(roughness, 0.1)) * 10.0;\n}\n\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 ambientLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float aoRange)\n{\n    vec3 diffuseIrradiance = skyColor(N, 1.0);\n    \n    vec3 diffuseAmbient = diffuseIrradiance * albedo * (1.0 - metalness);\n\n    vec3 R = reflect(-V, N);\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlickWithRoughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 specularIrradiance = skyColor(R, roughness);\n    vec3 specularAmbient = specularIrradiance * F;\n\n    float ambientOcclusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tambientOcclusion = min(exp2( -.8 * pow(ambientOcclusion, 2.0) ), 1.0) * min(1.0, 1.0+0.5*N.y);\n    diffuseAmbient *= ambientOcclusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), ambientOcclusion, roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 directLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 lightColor)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n    float HdotL = max(0.0, dot(H, L));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick(F0, HdotL);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n    vec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\tvec3 diffuseBRDF = kd * albedo / pi;\n\t\n\t//float shadow = shadow(pos + N * 0.01, L);\n    vec3 irradiance = lightColor * NdotL;// * shadow;\n\n\treturn (diffuseBRDF + specularBRDF) * irradiance;\n}\n\nvec3 lighting(vec3 ro,vec3 p,vec3 ray ,float depth,vec2 mat)\n{\n    vec3 col;\n    \n    vec3 n = normal(p);\n    float start = saturate(iTime-2.5);\n    vec3 ld = normalize(vec3(1.,1.,.2));\n    float NdotL = max(0.,dot(n,ld));\n    float metalness = .0;\n    float roughness = .0;\n    vec3 albedo = vec3(.5,.5,.5);\n    float checker = mod(floor(p.x)+floor(p.z),2.);\n    if(depth>200.)\n    {\n        return vec3(.1);   \n    }\n    else if(mat.y == MAT_SPHERE){\n        albedo = vec3(.25);\n        roughness = .1;\n        metalness = 1.;\n\t} else if(mat.y == MAT_FLOOR){\n        albedo = vec3(.025);\n        metalness = .5;\n    \troughness = .8;\n    } else if(mat.y == MAT_BOX){\n        albedo = vec3(.5,.5,.5);\n    \tmetalness = 1.;\n        roughness = 0.1;\n    } else {\n    \tcol = vec3(.1);\n    }\n    float aoRange = depth/30.;\n    \n    col += directLighting(p, albedo, metalness, roughness, n, -ray, normalize(ld), vec3(.98, 0.18, 0.18) * 10.*(sin(beat*pi*.25)*.5+.5));\n    \n    col += ambientLighting(p, albedo, metalness, roughness, n, -ray, depth / 30.0)*.05;\n    \n    col += glow(ro,ray,depth);\n    float fog = exp(-.0006*depth);\n    \n    vec3 fog2 = .02*vec3(1.,1.,1.4)*depth;\n    fog2 *= start*.5;\n    col = mix(vec3(.0),col+fog2,fog);\n\treturn col;\n}\n\nvoid trace(vec3 ro,out vec3 p, vec3 ray,out float t,out vec2 mat)\n{\n    t=0.01;\n    vec3 pos;\n    for (int i = 0; i < 99; i++) {\n        pos = ro + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.01) {\n        \tbreak;\n        }\n        t += abs(mat.x);\n    }\n    p = pos;\n}\n\nvec3 ray(vec2 p,vec3 ro,vec3 ta,float fov)\n{\n \tvec3 fo = normalize(ta - ro);\n    vec3 si = normalize(cross(vec3(0.,1.,0.),fo));\n    vec3 up = normalize(cross(fo,si));\n    return normalize(fo*fov+si*p.x+up*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float time = iTime*speed;\n    vec2 fbm = vec2(fbm(vec2(iTime*.1)),fbm(vec2(iTime*.1+100.)))*2.-1.;\n    vec3 camPos1 = vec3(0.,0.,-5.+time);\n    vec3 camPos2 = vec3(0.,-1.,2.+time);\n    vec3 camPos3 = vec3(.6,2.,-3.+time);\n    vec3 camPos4 = vec3(7.,-1.,-8.+time);\n    vec3[] Poss = vec3[](camPos1,camPos2,camPos3,camPos4);\n    \n    vec3 ro = vec3(0.,-1.,2.+time);\n    ro = mix(Poss[int(mod((beat-8.)*.125*.25,4.))],Poss[int(mod((beat-8.)*.125*.25+1.,4.))],smoothstep(0.,1.,saturate(mod(beat-8.,32.)-24.)));\n    ro.xy += fbm*2.;\n    vec3 ta = vec3(0.,0.,0.+time);\n    \n    vec3 ray = ray(p,ro,ta,1.2);\n\n    vec3 pos,rpos;\n    vec2 mat;\n    float t=0.01;\n    trace(ro,pos,ray,t,mat);\n    vec3 col = lighting(ro,pos, ray, t, mat);\n    vec3 n = normal(pos);\n    \n    ray = reflect(ray,n);\n    trace(pos,rpos,ray,t,mat);\n    col += lighting(pos,rpos+n*.01, ray, t, mat)*.5;\n\tcol = colorCorrect(col);\n    col = acesFilm(col*.3);\n    col = pow(col,vec3(1./2.2));\n    col *= vignette(uv,.5);\n    \n    //col *= step(abs(p.y),.8);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define bpm 138.\n#define pi acos(-1.)\n#define pi2 pi*2.\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43478.5453);\n}\nfloat rand(float p)\n{\n    return fract(sin(p*78.233)*43478.5453);\n}\nfloat noise(float p)\n{\n    float i=floor(p);\n    float f=fract(p);\n    f=f*f*(3.-2.*f);\n    return mix(rand(i),rand(i+1.),f);   \n} \n\nfloat fbm(float p)\n{\n    float amp=.5,val;\n    for(int i=0;i<4;i++)\n    {\n      val+=noise(p)*amp;\n      p*=2.;\n      amp*=.5;\n    }\n    return val;\n}\n\nfloat fm(float t,float f,float i,float r){\n    return sin(pi2*f*t+i*sin(pi2*f*t*r));\n}\nfloat sfm(float t,float f,float i1,float r1,float i2,float r2){\n    return sin(pi2*f*t+i1*fm(t,f,i2,r2)*r1);\n}\nfloat ssaw(float t,float f){\n    return rand(vec2(t))*0.02+sfm(t,f,0.8,1.8,.8,7.0)+sfm(t,f*1.008,0.8,1.8,0.8,6.0)+0.1*sfm(t,f,0.1,0.0,0.1,3.0);\n}\nfloat calf(float i){\n    return pow(2.0,i/12.0);\n}\n\nfloat sigcomp1d(float w,float s){\n  return (1.0/(1.0+exp(-s*w)) -0.5)*2.0;\n}\n\nfloat dist(float s, float d)\n{\n    return clamp(s * d, -1.0, 1.0);\n}\n\nfloat metalic(float t,float time)\n{\n    float o = 0.;\n    //o += mix(sin(time*pi2*440.*calf(4.)),fm(time,440.*calf(4.),1.,1.5),1.5)*.5;\n    float[] amps = float[](1.,1.,.25,1.);\n    float amp = amps[int(mod(t*.125*.25,4.))];\n    o+=fm(time,440.*calf(1.+12.+12.),.35,4.5+floor(sin(t*pi2*2.)))*((noise(time*pi2*220.*calf(2.)*.75))*1.-.25);\n    \n    o = o * exp(-7.*fract((t*.5+.5)))*.7*amp;// * smoothstep(1.,.75,fract(t*.25));\n    return o;\n}   \nfloat base(float t,float time)\n{\n    float o = 0.;\n    float note = 4.5;\n\to += fm(time,40.*calf(note),2.,1.);\n    o += sin(time*40.*calf(note+12.)*pi2)*.5;\n    //o += fm(time,40.*calf(5.+note),2.,1.);\n    //o += fm(time,40.*calf(31.+note),2.,1.5);\n    o *= .4;\n    o = dist(o,2.)*.5;\n    o = o * exp(-.75*fract(t*2.));\n\treturn o;\n}\n\nfloat saw(float t,float time)\n{\n    float o = 0.;\n    float[] notes = float[](-3.,-3.,-5.,-3.);\n    float note = notes[int(mod(t*4.,4.))]+2.;\n    float[] amps = float[](1.,1.,.5,1.);\n    float amp = amps[int(mod(t*.125*.25,4.))];\n    o += ssaw(time,220.*calf(0.+note))*.25;\n    o += ssaw(time,220.*calf(-5.+note))*.25*amp;\n    o += fm(time,220.*calf(-12.+note),1.,1.)*.5;\n    o = o * exp(-.25*fract(t*2.))*.25;\n\treturn o;\n}\n\nfloat hihat(float t,float time)\n{\n    float o = 0.;\n    \n    float[] notes = float[](-3.,-3.,-5.,-3.);\n    float note = notes[int(mod(t*2.,4.))];\n\n    o += sin(1760.*pi2*time*calf(24.+note))*.25;\n    o += noise(time*1e4)+fbm(time*1e4)*.5+rand(time)*.5;\n    o = o* exp(-11.*fract(t+.5))*.5; \n    //o = dist(o,2.)*1.;\n\treturn o;\n}\n\n//kick\n//https://www.shadertoy.com/view/ldfSW2\nfloat kick(float t, float time)\n{\n    \n    t = fract(t*1.)*.5;\n    float aa = 5.;\n    t = sqrt(t * aa) / aa; \t\n    float amp = exp(max(t - 0.15, 0.0) * -10.0);\n    \n       \n    float o = sin(t * 100.0 * pi2) * amp;\n    o = dist(o,1.);\n    return o;\n}\n\nfloat kickEcho(float t,float time)\n{\n    float amp = .5;\n    float o = 0.;\n    float[] kickamps = float[](0.,1.,0.,1.);\n    float kickamp = kickamps[int(mod(t*.125*.25,4.))];\n    for(int i=0;i<4;i++)\n    {\n      o+= kick(t+float(i)*.25,time)*amp;\n      amp*=.5;\n    }\n    return o*kickamp;\n}\n\nvec2 mainSound( in int samp,float time){\n    float o = 0.;\n    float t = time*bpm/60.;\n    \n    o += metalic(t,time);\n    o += base(t,time);\n    o += kickEcho(t,time);\n    //o += hihat(t,time);\n    o += saw(t,time);\n    \n    o = o*smoothstep(0.,4.,time);\n    o = o*smoothstep(64.,56.,time);\n    o*=1.0;\n    return vec2(o*.5);\n}","name":"Sound","description":"","type":"sound"}]}