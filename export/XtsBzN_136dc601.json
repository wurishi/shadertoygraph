{"ver":"0.1","info":{"id":"XtsBzN","date":"1513446740","viewed":134,"name":"CS123 Lab","username":"npolshakova","description":"Shadeee","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadertoylab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define DISPLACEMENT_FACTOR 0.1\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n   return sin(p.x) + sin(p.z);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 textX = texture(sam, p.yz);\n    vec4 textY = texture(sam, p.xz);\n    vec4 textZ = texture(sam, p.xy);\n    \n    n = vec3(abs(n.x), abs(n.y), abs(n.z));\n    \n    vec3 xVal = vec3(textX.x, textX.y, textX.z) * n;\n    vec3 yVal = vec3(textY.x, textY.y, textY.z) * n;\n    vec3 zVal = vec3(textZ.x, textZ.y, textZ.z) * n;\n    \n    return mix(xVal,yVal,zVal);\n    \n    //return vec3(0.5);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float closest = 0.0;\n    float plane = sdFloor(p);\n    float sphere = sdTwistedSphere(p);\n    if(plane < sphere) {\n        return PrimitiveDist(plane, PLANE);\n    } else {   \n    \treturn PrimitiveDist(sphere, SPHERE);\n    }\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    vec3 norm = vec3(0.0);\n    norm.x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    norm.y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    norm.z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    norm = normalize(norm);\n    return norm;\n    //return normalize(vec3(0.5));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    \n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        if (h < threshold) {\n            darkness = min(darkness, k * h / marchDist);\n            break;\n        }\n        marchDist += h * 0.7;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 50.0;\n    float threshold = 0.001;\n    \n    // Fill in the iteration count\n    for (int i = 0; i < 1000; i++) {\n        // Fill in loop body\n        vec3 position = ro + rd * marchDist;\n        PrimitiveDist d = map(position);\n        marchDist = marchDist + d.dist * 0.1;\n        if(d.dist < threshold) {\n            return PrimitiveDist(marchDist, d.primitive);\n        } \n        if(marchDist > boundingDist) {\n            return PrimitiveDist(-1.0, NO_INTERSECT);\n        }\n        \n    }\n    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(6.0 * sin(iTime * .3), 4.8, 6.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    vec2 uv = vec2(0.0);\n    // fragCoord and screen resolution\n    uv = vec2(2.0 * (fragCoord.x / iResolution.x) - 1.0,\n              2.0 * (fragCoord.y / iResolution.y) - 1.0);\n    //Scale uv.x by screenwidth/screenheight to preserve correct display ratio\n    uv.x = uv.x * iResolution.x/iResolution.y; \n \t//Modify rayDirection to contain uv as the xy coordinates, and focalLength as the z\n    vec3 rayDirection = vec3(0.0);\n    rayDirection.x = uv.x;\n    rayDirection.y = uv.y;\n    rayDirection.z = focalLength;\n    rayDirection = rayDirection.x * cameraRight + rayDirection.y * cameraUp + rayDirection.z * cameraForward;\n    rayDirection = normalize(rayDirection);  \n    \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}