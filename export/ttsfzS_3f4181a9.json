{"ver":"0.1","info":{"id":"ttsfzS","date":"1597088705","viewed":233,"name":"noimorphism","username":"ShaderLyf","description":"f(f)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noimorphism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define TWO_PI 6.2831853\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\nvec3 map1( vec2 p )\n{   \n    p *= 0.7;\n\n    float f = dot( fbm2( 1.0*(0.05*iTime + p + fbm2(-0.05*iTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) );\n\n    float bl = smoothstep( -0.8, 0.8, f );\n\n    float ti = smoothstep( -1.0, 1.0, fbm(p) );\n    return vec3(bl,bl,bl)  ;\n    //return mix( mix( vec3(0.50,0.00,0.00), \n                     //vec3(1.00,0.75,0.35), ti ), \n                     //vec3(0.00,0.00,0.02), bl );\n}\n\nfloat SmooSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a,b) - h*h/(k*4.0);\n}\n\nfloat sRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nfloat sphere(vec2 p,float size)\n{\n    return length(p)-size;\n}\n\nfloat smooU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat Cylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat Link( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.y, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat Prism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec3 pR45(vec3 p) \n{\n\t vec3 pos = vec3(p + vec3(p.y, -p.x,0))*sqrt(0.5);\n    return pos;\n}\n\nvec3 pR( vec3 p, float a) {\n\tvec3 pos = vec3(cos(a)*p + sin(a)*vec3(p.y, -p.x,0.0));\n    return pos;\n}\n\nfloat sminCu( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    vec2 q = p;\n\n    mat2 ma = mat2(sca.x,-sca.y,sca.y,sca.x);\n    p = ma*p;\n\n    float s = sign(p.x); p.x = abs(p.x);\n    \n    if( scb.y*p.x > scb.x*p.y )\n    {\n        vec2  w = p - ra*scb;\n        float d = length(w);\n        return vec3( d-rb, vec2(s*w.x,w.y)*ma/d );\n    }\n    else\n    {\n        float l = length(q);\n        float w = l - ra;\n        return vec3( abs(w)-rb, sign(w)*q/l );\n    }\n}\n\nvec2 map (vec3 pos)\n{\n    float sp = sphere(pos.xz,0.2);\n    \n    vec2 d1 = vec2(Cylinder(pos + vec3(0.69,0.01,1.6), 0.21,0.012,0.125),0.7); \n    \n    vec2 d2 = vec2(Cylinder(pos + vec3(0.69,0.01,-1.6), 0.21,0.012,0.125),0.7); \n    \n    //vec2 link1 = vec2(Link(pos + vec3(0.0,0.5,0.0), 0.7, 0.3,0.21),1.0);  \n    \n    float to = torus(pos+ vec3(-0.7,0.15,0.0), vec2(0.4,0.2));\n    vec2 link1 = vec2( to ,1.0);  \n    \n    \n    \n    \n    float outerEdge = rBox(pos+ vec3(0.,2.25,0.), vec3(1.33,2.17,2.4),0.11);\n    //float outerEdge = rBox(pos+ vec3(0.,2.25,0.), vec3(1.2,2.2,2.4),0.11);\n    \n    float rbo = rBox(pos+ vec3(-0.9,0.25,-1.68), vec3(0.11,0.23,0.2),0.2);\n    \n    float rbo2 = rBox(pos+ vec3(-0.9,0.25,1.68), vec3(0.116,0.23,0.2),0.1);\n    \n   // float f = dot( fbm2( 1.0*(0.05*iTime + pos.xy + fbm2(-0.05*iTime+2.0*(pos.zx + fbm2(4.0*pos.zx)))) ), vec2(1.0,-1.0) );\n    \n    vec2 colc = fbm2( 0.05*iTime+pos.xy+ fbm2(-0.05*iTime-2.0*(pos.zx)) ) *0.15;\n    \n    vec2 cola = 1.0*(0.05*iTime + pos.xy + fbm2(-0.05*iTime+2.0*(pos.zx + fbm2(4.0*pos.zx)))) ;\n    \n   //  d1.x = pMod1(pos.y,1.01);\n\n    //float d2 = pos.y;\n    \n     //float d0 = smooU(pos.y+colc.x, pos.y,0.01);\n     //old fb way\n    float d0 = sminCu(pos.y+ (colc.x*0.4), pos.y,0.05+0.05*abs(sin(iTime*0.5)));\n    \n    //float d0 = pos.y;\n    \n    //float d3 = smooU(colc.y*0.01,pos.y,0.3);\n    float d3 = smooU(d1.x,d0,0.35);\n    \n    float d4 = smooU(d2.x,d0,0.35);\n    \n    float dist = smin(d4,d3,0.02);\n    \n    //float l1 = smooU(link1.x,dist,0.06);\n    float edgeLink = substract(dist,outerEdge);\n    //float edgeLink = smin(dist,outerEdge,0.15);\n    \n    float l1 = smooU(edgeLink,d0,0.06);\n   // float l2 = smooU(rbo2,l1,0.06);\n    \n    //float pri = Prism(pR(pos.xzy+vec3(-0.1,0.15,-0.02),12.05)+vec3(0.,0.0,0.), vec2(0.3,0.01));\n    \n    float pri = torus(pos+vec3(0.,0.01,0.0),vec2(0.628,0.1));\n    \n    float l2 = smooU(pri,l1,0.05);\n    float l3 = smooU(rbo2,l2,0.05);\n    \n    //float link2 = smooU(rbo,l3,0.05);\n    float link2 = SmooSub(rbo,l3,0.05);\n    \n    float l4 = smooU(link2,l2,0.13);\n    \n    // animation\n    //float ta = 1.14;\n    //float tb = 0.14;\n    //float rb = 0.16;\n    \n    float ta = 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    float rb = 0.15*(0.5+0.5*cos(iTime*0.41+1.0));\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg1 = sdgArc(pos.xz,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);\n    float dgx = dg1.x+0.18;\n    vec2  gxy = dg1.xz;\n\n    \n    float d = smooU(dgx,dist,0.8);\n    \n   \n    \n   // return (d3<d1.x) ? vec2(d3,1.0) : d1;\n   // return colc;\n   // return colc;\n    return vec2(d,1.0);//+(colc*0.0);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0); \n    return normalize(vec3(map(pos+e.xyy).x-map(pos-e.xyy).x,\n                         map(pos+e.yxy).x-map(pos-e.yxy).x,\n                         map(pos+e.yyx).x-map(pos-e.yyx).x\n                         ));\n}\n\nfloat castShadow(vec3 ro,vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.001;\n    for (int i = 0; i <100; i++)\n    {\n        vec3 pos = ro+t*rd;\n        float h = map(pos).x;\n        res = min(res, 16.0*h/t);\n        if(h<0.0001)break;\n        t += h;\n        if (t>20.0)break;\n        \n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec2 marchRay (vec3 ro, vec3 rd)\n{\n    float m = -1.0;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n       vec3 pos = ro+t*rd;\n        \n       vec2 h = map(pos);\n        m = h.y;\n       if (h.x<0.001)\n           break;\n        t+=h.x;\n        if (t>20.0) break;    \n    }\n    \n    if (t>20.0) m=-1.0;\n    return vec2(t,m);\n}\n\n\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //float f = smoothstep(0.25,0.26,length(p));\n\tfloat an = 5.0*iMouse.y/iResolution.y;\n    vec3 ta = vec3(0.0,1.0,0.0);\n\n   // vec3 ro = ta+vec3(1.5*sin(an),1.5*cos(an),0.); // Ray origin - 2 back in z direction\n    vec3 ro = ta+vec3(0.02,2.0,0.0); // Ray origin - 2 back in z direction\n    \n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(vec3(p.x*uu + p.y*vv +1.9*ww)); // ray detect, becomes length of camera \n    vec3 col = vec3(0.1,0.1,1.0) - 0.7*rd.y;\n    col = mix(col, vec3(0.1,0.75,0.1),exp(-10.0*rd.y));\n    \n\n  \tvec2 tm = marchRay(ro,rd);\n    \n    \n    if (tm.y>0.0)\n    {\n        float t = tm.x;\n        vec3 pos = ro  + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 matte = vec3(0.18);\n        \n        if (tm.y<1.5)\n        {\n            matte = vec3(0.09,0.09,0.09);\n           // float f = -2.0+2.0*smoothstep(-0.2,0.2,sin(2.0*pos.x)+sin(2.0*pos.y)+sin(2.0*pos.z));\n            \n            float f = -1.0+2.0*smoothstep(-0.05,0.04,-pos.x);\n            \n           // matte+=0.3*f*vec3(0.12,0.12,0.12);\n            \n            matte+=0.3*vec3(0.1,0.12,0.12);\n            \n        }\n\n        \n        else if (tm.y<2.5)\n        {\n           // matte = vec3(0.2,0.1,0.2);\n        }\n        \n        \n        else //if (tm.y<3.5)\n        {\n          //  matte = vec3(0.4,0.4,0.4);\n        }\n        \n        \n    \n        col = vec3(0.03,0.03,0.03);\n       // float f = sin(18.0*pos.x)*sin(18.0*pos.z);\n      // \tcol+=f;\n        vec3 sun_dir = normalize(vec3(0.02,0.022,0.01));\n        //vec3 sun_dir = normalize(vec3(0.5*sin(iTime*0.2)+0.1,0.1+0.1*abs(sin(iTime*0.2)),abs(sin(iTime*0.02))));\n        float sun_dif = clamp (dot(nor,sun_dir),0.0,1.0);\n        float sun_sha = castShadow(pos+nor*0.001,sun_dir);\n        float sky_dif = sqrt(clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0));\n        float bou_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n        \n        \n        col = matte*sun_dif*vec3(0.2,0.2,0.2); \n        col += matte*sky_dif*vec3(0.5,0.8,0.9);\n        //col += matte*vec3(0.7,0.3,0.2)*bou_dif;\n        \n        vec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(7.0,4.5,5.0); // key light\n        lin += sky_dif*vec3(0.5,0.8,0.9);\n        \n        lin += matte*vec3(0.7,0.3,0.2)*bou_dif;\n        col = col*lin;\n    }\n    \n    col = pow(col,vec3(0.4545));\n    \n    vec2 uv3 = fragCoord.xy;\n\tfloat radius = 0.25 * iResolution.y;\n    vec2 center = iResolution.xy * 0.5;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    // the sound texture is 512x2\n    //uv2+=0.5;\n    uv2 *=0.5;\n\n    vec2 p1 = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    p1*=2.;\n\n    float e = 0.0045;\n\n    vec3 colc = map1( p1               ); float gc = dot(colc,vec3(0.233));\n    vec3 cola = map1( p1 + vec2(e,0.0) ); float ga = dot(cola,vec3(0.233));\n    vec3 colb = map1( p1 + vec2(0.0,e) ); float gb = dot(colb,vec3(0.233));\n    \n    vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n\n    vec3 col1 = colc;\n    col1 += vec3(0.0,0.7,0.6)*1.0*abs(2.0*gc-ga-gb);\n    col1 *= 1.0+0.2*nor.y*nor.y;\n    col1 += 0.05*nor.y*nor.y*nor.y;\n    \n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col1 *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    vec4 fragCo = vec4( col1, 1.0 );\n    \n    \n    vec3 red = vec3(fragCo.rgb);\n    vec4 cc = circle(uv3,center,radius*0.7,red);\n    // Output to screen\n    //fragColor = mix(vec4(col,1.0), cc, mix(0.0,1.0*abs(sin(iTime*0.2)),0.5*sin(iTime*0.2)));;\n   // fragColor = mix(vec4(col,1.0), cc, mix(cc.a,0.0,0.));\n    \n     //fragColor = mix(vec4(col,1.0), cc, 0.4);\n    \n    fragColor = vec4(col,1.0);\n   // fragColor = mix(vec4(col,1.0), cc, mix(cc.a,0.5,1.*abs(sin(iTime*0.2))));;\n}\n\n","name":"Image","description":"","type":"image"}]}