{"ver":"0.1","info":{"id":"DlG3Wz","date":"1683785413","viewed":38,"name":"径向渐变","username":"lvyerose","description":"径向渐变","likes":0,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\n#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))\n#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))\n#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)\n\nfloat gradientNoise(in vec2 uv)\n{\n    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(uv, magic.xy)));\n}\nconst vec3 COLOR0 = SRGB(255, 0, 114);\nconst vec3 COLOR1 = SRGB(0, 255, 200);\nconst vec3 COLOR2 = SRGB(197, 255, 80);\nvec3 sdgEllipse( vec2 p, in vec2 ab )\n{\n    // symmetry\n    vec2 sp = sign(p);\n\tp = abs( p );\n    \n    // determine in/out and initial value\n    bool s = dot(p/ab,p/ab)>1.0;\n\tfloat w = atan(p.y*ab.x, p.x*ab.y);\n    if(!s) w=(ab.x*(p.x-ab.x)<ab.y*(p.y-ab.y))? 1.570796327 : 0.0;\n    \n    // Newton root solver\n    for( int i=0; i<4; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    vec2  q = ab*vec2(cos(w),sin(w));\n\n    // compute distance and gradient (everything above\n    // could probably be replaced by something better)\n    float d = length(p-q);\n    return vec3( d, sp*(p-q)/d ) * (s?1.0:-1.0);\n}\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n     // animation\n    vec2 ab = vec2(0.5,0.1);\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgEllipse(p,ab);\n        float d = dg.x;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n         float t = smoothstep(0.0, 1.0, clamp(d, 0.0, 1.0));\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n       vec3 color = mix(COLOR1, COLOR2, t);\n\n    color = LINEAR_TO_SRGB(color);\n\n    // Add gradient noise to reduce banding.\n    color += (1.0/255.0) * gradientNoise(fragCoord) - (0.5/255.0);\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}