{"ver":"0.1","info":{"id":"ssf3W2","date":"1674873158","viewed":107,"name":"sphere_dof23","username":"edwardbraed","description":"simple dof implementation","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","dof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 blur(sampler2D tex, vec2 uv, float k, float ss)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    vec3 avg = vec3(0.0);\n    float hk = k * 0.5;\n    \n    float c = 1.0;\n    for(float x = 0.0 - hk; x < hk; x += 1.0)\n    {\n        for(float y = 0.0 - hk; y < hk; y += 1.0)\n        {\n            vec4 col = texture(tex, uv + s * vec2(x,y) * ss);\n            avg += col.rgb;\n            c = min(col.w, c);\n        }\n    }\n    return mix(texture(tex, uv).rgb, avg / (k * k), c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ss = 2.0; // sample step myltiplyer\n    float k = round(max(texture(iChannel0, uv).w * 5.0, 1.0));\n    \n    // Output to screen\n    fragColor = vec4(blur(iChannel0, uv, k, ss), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS_MARCH 64\n#define COLOR vec3(0.1, 0.7, 1.0)\n#define norm(a) (a + 1.0) * 0.5\n\n#define gray(rgb) (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114)\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nvec4 drwSphere(vec3 pos, vec3 ro, vec3 lv, vec3 rd)\n{\n    float dt = (iTime * 0.3 - floor(iTime * 0.3));\n    vec2 rt = vec2(pos.x + dt, pos.y);\n    vec3 col = texture(iChannel0, rt).rgb + COLOR * 0.3;\n    \n    vec3 v = normalize(pos - ro);\n    vec3 r = normalize(reflect(lv, normalize(pos)));\n    float s = pow(max(dot(r, v), 0.0), 10.0) * float(gray(col) > 0.65) * 2.0;\n    float l = max(dot(lv, normalize(pos)), 0.0) + s;\n    \n    return vec4(col * max(l, 0.2), 1.0 - (length(rd) / length(pos) - 0.5));\n}\n\nvec4 raymarch(vec3 ro, vec3 rd1, vec3 rd2, vec3 lv, float g)\n{\n    lv = normalize(lv);\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos1 = ro + rd1 * t;\n        vec3 pos2 = ro + rd2 * t;\n        float d1 = length(pos1) - 0.6;\n        float d2 = length(pos2) - 0.6;\n            \n        if(d1 < 0.001)\n            return drwSphere(pos1, ro, lv, rd1);\n        else if(d2 < 0.001)\n            return drwSphere(pos2, ro, lv, rd2);\n        \n        t += min(d1, d2);\n    }\n    \n    return vec4(COLOR * g, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // aspect ratio for correction rays..\n    vec2 aspect = calcAspect(iResolution.xy);\n    \n    float g = pow(1.0 - distance(uv, vec2(0.5)), 2.0) * 0.7;\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // origin direction (or pseudo camera position)\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // light vector\n    vec3 lv = vec3(1.0, 0.5, -2.0);\n    \n    // common uv ray direction\n    vec2 uvrd = vec2(mix(mix(dBl, dBr, uv.x),\n                         mix(dTl, dTr, uv.x), uv.y) * aspect);\n                       \n    float t = iTime* 0.5;\n    // position spheres 1 and 2\n    vec3 p1 = vec3(sin(t) / 1.5, 0.0, norm(cos(t) / 1.5));\n    vec3 p2 = vec3(sin(t - 3.0) / 1.5, 0.0, norm(cos(t - 3.0) / 1.5));\n    \n    // Output to screen\n    fragColor = raymarch(ro, vec3(uvrd + p1.xy, p1.z), \n                             vec3(uvrd + p2.xy, p2.z), lv, g);\n}","name":"Buffer A","description":"","type":"buffer"}]}