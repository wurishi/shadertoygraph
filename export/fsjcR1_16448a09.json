{"ver":"0.1","info":{"id":"fsjcR1","date":"1643198367","viewed":274,"name":"Particle simulation Buffer 1","username":"nebbul","description":"Exploring Buffers\n\nClick to attract the particles\n\nIdeas for improvement: \n* Wind Turbulence\n* Texturing\n* Spin\n* Inter-particle-collisions\n* SDF collision with some background shapes\n* Motionblur\n* UI Controls","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["circle","solver","buffer","velocity","particle","multipass","force"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A great starting point regarding buffer write functions come from:\n// https://www.shadertoy.com/view/4st3WS\n//\n// Colorization from\n// https://www.shadertoy.com/view/ll2GD\n//\n// force-based simlation inspiration from the Unreal Engine niagara solver\n//\n\n#define BUFFER_SHOW 1\n\n\n\n//--------------------------------\n// START KEEP SYNC WITH BUFFER A\n//--------------------------------\n#define BUFF_RES iChannelResolution[0].xy\nvec4 readTexel(in sampler2D buffer, in vec2 pos )\n{\n    return texture(buffer, (pos+.5)/BUFF_RES);\n}\n//--------------------------------\n// START KEEP SYNC WITH BUFFER A\n//--------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // define our UVs, 0-1\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    // use this to remap canvas height to 0-1 (for canvas relative positions)\n    float aspect = iResolution.y / iResolution.x;\n        \n    float shapeMask;\n    vec3 shapeColor;\n    \n    // read texels\n    int iter = int(BUFF_RES_X) * int(BUFF_RES_Y);\n    for(int i = 0 ; i < iter ; i++)\n    {\n        // read texel\n        state myState = getState(   readTexel(BUFFER, getTexel(i) ), // first grid\n                                    readTexel(BUFFER, getTexel(i) + vec2(0, BUFF_RES_Y) ));  // second grid\n                                    \n        \n        bool isCircle = true;\n        float currentShape;\n        \n        vec2 shapePosition = vec2(myState.position.x, myState.position.y * aspect);\n        \n        if(isCircle)\n        {\n            currentShape = circle(uv, shapePosition, myState.radius);\n        }\n        else\n        {\n            // box\n            currentShape = box(uv, shapePosition, vec2(myState.radius * 2.), 0.001);\n        }\n        \n        vec3 currentColor = gradient(vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.,1.,1.), vec3(0.,0.333,0.666), myState.color);\n        \n        // append color and shape, while fixing overlap\n        shapeColor += mix(vec3(0.,0.,0.), currentColor, max(currentShape - shapeMask, 0.));\n        shapeMask += mix(0., 1., max(currentShape - shapeMask, 0.));\n    }\n    \n    \n\t// Blend the two\n    // Background color RGBA\n\tvec4 bg_color = 0.1 * vec4(1., 1., 1., 1.) * gridTexture(fragCoord.xy/iResolution.xx * vec2(5., 5.)) + 0.1;\n    // foreground color RGBA\n\tvec4 fg_color = vec4(shapeColor.rgb, 1.0);\n    \n\tfragColor = mix(bg_color, fg_color, shapeMask);\n    \n    \n    if(BUFFER_SHOW == 1)\n    {\n        float scaler = 0.3;\n        vec2 uv_buff = (fragCoord.xy / iResolution.xy) * scaler;\n        if(fragCoord.x < BUFF_RES_X / scaler && fragCoord.y < (BUFF_RES_Y * 2.) / scaler)\n        {\n            fragColor = texture(BUFFER, uv_buff);\n        }\n        \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//--------------------------------\n// START KEEP SYNC WITH BUFFER A\n//--------------------------------\n#define BUFF_RES iChannelResolution[0].xy\nvec4 readTexel(in sampler2D buffer, in vec2 pos )\n{\n    return texture(buffer, (pos+.5)/BUFF_RES);\n}\n//--------------------------------\n// START KEEP SYNC WITH BUFFER A\n//--------------------------------\n\n// Writes a single component of a pixel in a buffer.\nvoid write1( inout float buffer, in float val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes two components of a pixel in a buffer.\nvoid write2( inout vec2 buffer, in vec2 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes three of the components.\nvoid write3( inout vec3 buffer, in vec3 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes all components of a texel (at once).\nvoid write4( inout vec4 buffer, in vec4 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    \n    vec4 buff = texture(BUFFER, uv);\n\n    // read + write texels\n    int iter = int(BUFF_RES_X) * int(BUFF_RES_Y);\n    for(int i = 0 ; i < iter ; i++)\n    {\n        vec2 texel = getTexel(i); // first grid\n        vec2 texel2 = getTexel(i) + vec2(0, BUFF_RES_Y); // second grid\n        \n        // initiate some random values\n        if(iFrame == 0)\n        {\n            // position, velocity\n            vec2 initPosition = rand2(iDate.w + float(i));\n            vec2 initVelocity = (rand2(iDate.w + float(i) + 1233.45) - vec2(0.5)) * vec2(2.);\n            initVelocity *= vec2(0.5); // just scale it down slightly\n            \n            write4(buff, vec4(initPosition, initVelocity), texel, fragCoord);\n            \n            //mass, radius, bounce, (one component free) - these are just generated on init, not really changed\n            float initRadius = remap(rand(iDate.w + float(i) + 96.54), 0., 1., 0.001, 0.02);\n            float density = 1.;\n            float initMass = 500. * initRadius; //(4.0 / 3.0) * PI * pow(initRadius, 3.) * density; // g / cm3\n            float initBounce = remap(rand(iDate.w + float(i) + 75.33), 0., 1., 0.7, 0.9);\n            float initColor = rand(iDate.w + float(i) + 6.44);\n            \n            write4(buff, vec4(initMass, initRadius, initBounce, initColor), texel2, fragCoord);\n        }\n        else\n        {\n            // read texel\n            state myState = getState(   readTexel(BUFFER, texel ), // first grid\n                                        readTexel(BUFFER, texel2 ));  // second grid\n\n            //--------------------------------\n            // START MODIFY THE TEXEL\n            //--------------------------------\n            // start with 0. acceleration, apply forces to get a new acceleration for this frame\n            vec2 acceleration = vec2(0., 0.);\n            \n            // apply the forces one after the other to get a final acceleration force\n            float windStrength = 0.;\n            applyForceWind(acceleration, myState.position, myState.mass, windStrength);\n            \n            vec2 gravity = vec2(0., -3.);\n            applyForceGravity(\tacceleration,\n                                gravity,\n                                myState.mass);\n                                \n            // add mouse control to attractor\n            float attractorStrength = 0.;\n            vec4 m = iMouse / iResolution.x;\n            if( m.z>0.0 ) // button is down\n            {\n                attractorStrength = 100.0;\n            }\n            vec2 attractorPosition = m.xy;//vec2(0.5, 0.5);\n            \n            float attractorRadius = 1.0;\n            \n            bool attractorFalloff = true;\n            float attractorFalloffExponent = 2.;\n            applyForceAttractorPoint(\tacceleration,\n                                        myState.position,\n                                        myState.mass,\n                                        attractorPosition,\n                                        attractorRadius,\n                                        attractorStrength,\n                                        attractorFalloff,\n                                        attractorFalloffExponent);\n\n            // some optional parameters\n            float drag = 0.;\n            float limitVelocity = 0.;\n            float limitAcceleration = 0.;\n            \n            // check collisions with new accelerations, but before solve\n            collideWithWallCheck(acceleration, myState.velocity, myState.position, myState.mass, myState.radius, myState.bounce, aspect);\n            \n            // calculate new position and velocity\n            solveForcesAndVelocity(myState.position, myState.velocity, acceleration, myState.mass, drag, iTimeDelta, limitVelocity, limitAcceleration);\n            \n            vec4 texelWrite;\n            texelWrite.xy = myState.position;\n            texelWrite.zw = myState.velocity;\n            //--------------------------------\n            // END MODIFY THE TEXEL\n            //--------------------------------\n\n            // write the new texel values\n            write4(buff, texelWrite, texel, fragCoord);\n        }\n    }\n    \n    fragColor = buff;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// -------------------------\n// START buffer stuff\n// -------------------------\n// Current buffer size for loading data.\n#define BUFFER iChannel0\n\n// the size of the buffer we write and read from\n// this also increase the amount of particles\n// particle count = X * Y\n#define BUFF_RES_X 16.\n#define BUFF_RES_Y 8.\n\n// get the texel coordinate, like a 2d flipbook\n// pass the index and it will get you the texel coordinate based on the dimensions BUFF_RES_X and BUFF_RES_Y\nvec2 getTexel(int index)\n{\n\tfloat cellIndex = float(index);\n\tfloat uCell = mod(cellIndex, BUFF_RES_X);\n\tfloat vCell = floor(cellIndex / BUFF_RES_X);\n\tvCell = mod(vCell, BUFF_RES_Y);\n\n\treturn vec2(uCell, vCell);\n}\n\n\n// -------------------------\n// END buffer stuff\n// -------------------------\n\nstruct state\n{\n    // first part of buffer\n    vec2 position;\n    vec2 velocity;\n    \n    // second part of buffer\n    float mass; \n    float radius;\n    float bounce;\n    float color;\n    \n    // third part of buffer???\n    // float spin;\n    // float mu; // friction cooefficiant??\n};\n\n// use a struct to make the code a bit easier to read\nstate getState(vec4 positionVelocity, vec4 massRadiusBounceColor)\n{\n    state myState;\n\n    myState.position = positionVelocity.xy;\n    myState.velocity = positionVelocity.zw;\n    myState.mass = massRadiusBounceColor.x;\n    myState.radius = massRadiusBounceColor.y;\n    myState.bounce = massRadiusBounceColor.z;\n    myState.color = massRadiusBounceColor.w;\n    \n    return myState;\n}\n\n// -------------------------\n// START generic\n// -------------------------\n#define PI 3.141592\n#define TAU 6.283185\n\nfloat mad(float a, float b, float c){ return (a * b + c); }\nvec2 mad(vec2 a, vec2 b, vec2 c){ return (a * b + c); }\n\nvec2 SafeNormalize(vec2 inVec)\n{\n    float dp3 = max(0.0001, dot(inVec, inVec));\n    return inVec * inversesqrt(dp3);\n}\nfloat remap(float x, float in_min, float in_max, float out_min, float out_max)\n{\n    return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);\n}\n\n// -----------------------------------------\n// use this tool to create a gradient:\n// http://dev.thi.ng/gradients/ \n// implementation based on:\n// https://www.shadertoy.com/view/ll2GD3\n// -----------------------------------------\nvec3 gradient(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return clamp(a + b * cos( TAU * (c * t + d ) ), vec3(0,0,0), vec3(1,1,1));\n}\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\nvec2 rand2(float n)\n{\n    return vec2(rand(n), rand(n + 114.233));\n}\n\n// math from Unreal Engine node BoxMask-3D\nfloat box(vec2 uv, vec2 pivot, vec2 bounds, float falloff)\n{\n\tvec2 p = abs(uv - pivot);\n\tp = max(p - (bounds * 0.5), 0.);\n\t\n\treturn 1.0 - min(length(p) / max(falloff, 0.00001), 1.0);\n}\n\n// Draw a circle at \"pos\" with radius \"rad\"\n// from https://shadertoyunofficial.wordpress.com/\n#define circle(v,v0,r)  smoothstep( 1.0/iResolution.y, -1.0/iResolution.y, length(v-(v0)) - (r) ) \n//\n// background grid from https://www.shadertoy.com/view/XtBfzz\nfloat gridTexture( in vec2 p )\n{\n    const float N = 2.0; // grid ratio\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N) );\n    //pattern\n    //return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}\n//\n// -------------------------\n// END generic\n// -------------------------\n\n// -------------------------\n// START Forces and simulation\n// -------------------------\n// the generic force function all other functions use to accelerate the point\nvoid applyForce(inout vec2 acceleration, vec2 force, float mass)\n{\n\t// A = F / M\n\tacceleration += force / mass;\n}\nvoid applyForceWind(inout vec2 acceleration, vec2 position, float mass, float strength)\n{\n    vec2 windVector = vec2(1., 0.); // do something fancier here, some animated vector noise would be nice\n    vec2 wind = windVector * strength;\n\tapplyForce(acceleration, wind, mass);\n}\nvoid applyForceGravity(inout vec2 acceleration, vec2 gravity, float mass)\n{\n\t// gravity should not be affected by mass!!\n    // this (1./mass) divide here counteracts this for the later force-application inside solveForcesAndVelocity()\n\tacceleration += gravity / (1./mass);\n}\nvoid applyForceFriction(inout vec2 acceleration, in vec2 velocity, float mass)\n{\n    // friction coefficient, let's just say this is a constant\n    float mu = 0.4;\n\t// direction of friction = opposite direction of velocity\n\tvec2 friction = -vec2(1.0) * SafeNormalize(velocity);\n\tfloat normal = mu * mass;\n\tfriction *= normal;\n\n\tapplyForce(acceleration, friction, mass);\n}\n// point attractor, ignores the mass of the attractor\nvoid applyForceAttractorPoint(inout vec2 acceleration, vec2 objPosition, float objMass, vec2 attractorPosition, float attractorRadius, float attractorStrength, bool falloffEnabled, float falloffExponent)\n{\n\tif(attractorStrength != 0.) // can also be negative, for a repulsion\n\t{\n\t\tvec2 force = attractorPosition - objPosition;\n\t\tforce += vec2(0.,0.0001); // prevent NaN when object is EXACTLY on top of attractor\n\n\t\tfloat dist = length(force);\n\n\t\tfloat falloff = falloffEnabled ? pow(dist, falloffExponent) : dist; // falloffExponent is usually 2\n\n\t\tfloat strength = objMass * attractorStrength * falloff;\n\n\t\tif(dist > attractorRadius) strength = 0.;\n\n\t\tforce = force / dist; // unit vector\n\t\tforce *= strength; // scaled force\n\n\t\tapplyForce(acceleration, force, objMass);\n\t}\n}\n\nvoid collideWithWallCheck(inout vec2 acceleration, inout vec2 velocity, inout vec2 position, float mass, float radius, float bounce, float aspect)\n{\n    float radiusWithAspect = radius * aspect;\n    \n    if(position.x - radiusWithAspect < 0.) {\n        // left wall\n        applyForceFriction(acceleration, velocity, mass); // apply some friction\n        velocity.x *= -1.; // flip speed, so it go in opposite direction\n        velocity *= bounce;\n        position.x = radiusWithAspect;\n    }\n    else if(position.x + radiusWithAspect > 1.) {\n        // right wall\n        applyForceFriction(acceleration, velocity, mass);\n        velocity.x *= -1.;\n        velocity *= bounce;\n        position.x = 1. - radiusWithAspect;\n    }\n    else if(position.y - radius < 0.) {\n        // ground\n        applyForceFriction(acceleration, velocity, mass);\n        velocity.y *= -1.;\n        velocity *= bounce;\n        position.y = radius;\n    }\n    else if(position.y + radius > 1.) {\n        // ceiling\n        applyForceFriction(acceleration, velocity, mass);\n        velocity.y *= -1.;\n        velocity *= bounce;\n        position.y = 1. - radius;\n    }\n}\n\nvoid solveForcesAndVelocity(inout vec2 position, inout vec2 velocity, vec2 force, float mass, float drag, float deltaTime, float limitVelocity, float limitAcceleration )\n{\n\tfloat m; // mass\n\tvec2 f; // force\n\tvec2 v; // velocity\n\n\tm = max(mass, 0.0001); // avoid division by zero\n\tm = 1. / m; // reciprocal in GLSL is what?\n\n\tf = m * force; // factor in mass, this is what the gravity force counter-acts\n\n\t// apply drag irrespective of mass\n\tv = mad(f, vec2(deltaTime), velocity); // apply force to velocity\n\tfloat d = -1. * clamp(deltaTime * drag, 0., 1.);\n\tv = mad(vec2(d), v, v);\n\n\t// optional velocity limit\n\tif(limitVelocity > 0.)\n\t{ \n\t\tfloat limit = limitVelocity;\n\t\tvec2 dir = SafeNormalize(v);\n\t\tfloat vel_length = clamp(length(v), 0.0, limit);\n\n\t\tv = dir * vel_length;\n\t}\n\n\t// optional acceleration limit\n\tif(limitAcceleration > 0.)\n\t{\n\t\tvec2 v_previous = velocity;\n\t\tfloat acc_limit = limitAcceleration;\n\t\tvec2 acc = v - v_previous; // find acceleration\n\n\t\tvec2 acc_dir = SafeNormalize(acc);\n\t\tfloat acc_length = clamp(length(acc), 0.0, acc_limit);\n\n\t\tacc = acc_dir * acc_length; // scale acceleration to an acceptable level\n\n\t\tv = acc + v_previous; // calculate new velocity\n\t}\n\n\tposition = mad(v, vec2(deltaTime), position);\n\tvelocity = v;\n}\n// -------------------------\n// END Forces and simulation\n// -------------------------","name":"Common","description":"","type":"common"}]}