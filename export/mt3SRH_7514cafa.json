{"ver":"0.1","info":{"id":"mt3SRH","date":"1685117007","viewed":98,"name":"curve potencial","username":"Irec","description":"potential of a uniformly charged wire","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["electric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define eps_ 1e-8\n#define nn 15\n#define optimize true\n\nfloat length_(vec2 v)\n{\n  return sqrt(v.x*v.x + v.y*v.y);   \n}\n\nfloat l2(vec2 v)\n{\n  return v.x*v.x + v.y*v.y;   \n}\n\n//===============================================================================\nbool pt_on_line( vec2 v0, vec2 v1, vec2 v2, inout float t0)\n{\n\n    vec2 v01 = v0 - v1;\n    vec2 v21 = v2 - v1;\n    float d = length(v21);\n    float s = v21.y/d;\n    float c = v21.x/d;\n    \n    mat2 m = mat2( c, s, \n                  -s, c );\n              \n    v01 *= m;\n    //v21 *= m;\n\n    bool b = abs(v01.y)< eps_;\n    t0 = v01.x/d;\n    if (b)\n    {\n      if (t0 < 0.0) \n      {\n          b = false;\n      }\n      if (t0 > 1.0)\n      {\n          b = false;\n      }\n    }\n    \n    return b;\n}\n\n\n//==============================================================================\nfloat fast_ln7(inout float x)\n{\n  float x1, x2;\n  x1 = (x - 1.0)/(x + 1.0);\n  x2 = x1*x1;\n\n  return  2.0*x1 +\n            (0.666666666666667*x1 +\n              (0.4*x1 +\n                (0.285714285714286*x1 +\n                  (0.222222222222222*x1 +\n                    (0.181818181818182*x1 +\n                      (0.153846153846153*x1 +\n                        (0.133333333333333*x1\n                        )*x2\n                      )*x2\n                    )*x2\n                  )*x2\n                )*x2\n              )*x2\n            )*x2;\n}\n\n//==============================================================================\nfloat log_(float x)\n{\n  return (x - 1.0 > 0.3) ? log(x) : fast_ln7(x);\n}\n\n//==============================================================================\nfloat line_potencial(vec2 v0,   // point in space\n                     vec2 v1,   // start line\n                     vec2 v2)   // end of line\n{    \n  vec2 va = v1;\n  vec2 vb = v2 - v1;\n  vec2 vl = va - v0;  \n\n  float g2 = dot(vb, vb);    \n  float a2 = dot(vl, vl)/g2; \n  float b  = (vl.x*vb.x + vl.y*vb.y)/g2; \n\n\n  float r12 = g2*a2;\n  float r22 = g2*(a2 + 2.*b + 1.);\n  float c1  = 0.5/sqrt(r12*r22);\n  float ca  = (r12 + r22 - g2)*c1;\n  float rs  = 0.;\n    \n  if (optimize && (ca > 0.9998))    \n  {\n    float r1 = sqrt(r12);\n    float r2 = sqrt(r22);\n    float gamma = r22/r12;\n\n    rs = 0.5*log_(gamma)/(r2 - r1);  \n  }\n  else\n  {\n    float g = sqrt(g2);\n    float a = sqrt(a2);\n\n    float t0;\n    // If the point lies on the line\n    if (pt_on_line(v0, v1, v2, t0))\n    {\n      rs = 0.;\n      float t1 = max(0., t0 - eps_);\n      float t2 = min(1., t0 + eps_);\n      float c1 = sqrt(a2 + 2.*b*t1 + t1*t1);\n      float c2 = sqrt(a2 + 2.*b*t2 + t2*t2);\n      \n      if (t1 > 0.) rs += log_(abs((c1 + t1 + b)/(a + b)));   \n\n      rs += 0.5*(t2 - t1)*(1./c1 + 1./c2);\n\n      if (t2 < 1.) rs += log_(abs((c2 + t2 + b)/(c1 + t1 + b)));\n\n      rs /= g;\n    }\n    else\n    {\n      float gamma = (sqrt(a2 + 2.*b + 1.) + 1. + b)/(a + b);\n\n      rs = log_(gamma)/g;  \n    }\n  }\n  return rs;  \n}\n\n\n//===============================================================================\nfloat summ(inout vec2 v0,         // Point coordinates\n           inout vec2 vs[nn + 1]) // Segment coordinates\n          \n{\n  float rs = 0.0;\n  float l  = 0.0;\n  for (int i = 0; i < nn; i++)\n  {\n    float dl = length(vs[i + 1] - vs[i]);\n    l  += dl;\n    rs += dl*line_potencial(v0, vs[i], vs[i + 1]);\n  }\n  rs /= l;\n  \n  float xx = 1.0;  \n  float dr = xx*rs - floor(xx*rs);\n  if (dr < 0.01) rs = 0.0;\n  \n  return rs;  \n}\n\n//===============================================================================\nvec3 heatMap(float greyValue) {   \n\tvec3 heat;      \n    heat.r = smoothstep(0.5, 0.8, greyValue);\n    if(greyValue >= 0.90) {\n    \theat.r *= (1.1 - greyValue) * 5.0;\n    }\n\tif(greyValue > 0.7) {\n\t\theat.g = smoothstep(1.0, 0.7, greyValue);\n\t} else {\n\t\theat.g = smoothstep(0.0, 0.7, greyValue);\n    }    \n\theat.b = smoothstep(1.0, 0.0, greyValue);          \n    if(greyValue <= 0.3) {\n    \theat.b *= greyValue / 0.3;     \n    }\n\treturn heat;\n}\n\n#define np 9\nfloat ps[np + 1] = float[np + 1](0.0, 0.14, 0.28,  0.42, 0.57, 0.65, 0.75, 0.90, 0.95, 1.0);\nfloat cr[np + 1] = float[np + 1](0.0, 0.25, 0.25,  0.0,  0.5,  0.7,  1.0,  1.0,  1.0,  1.0);\nfloat cg[np + 1] = float[np + 1](0.0,  0.0, 0.25,  0.7,  1.0,  1.0,  1.0,  0.0,  0.0,  1.0);\nfloat cb[np + 1] = float[np + 1](0.0,  0.5,  1.0,  0.9,  0.3,  0.0,  0.0,  0.0,  1.0,  1.0);\n\n\nint pos_index(in float p)\n{\n  int l = 0;\n  if (p <= ps[l]) { return l; }\n  int h = np;\n  if (p >= ps[h]) { return h; }\n  while(h - l > 1)\n  {\n    int n = (l + h)/2;\n    float y = ps[n];\n    if (y < p) { l = n; } else { h = n; }  \n  }\n  return l;\n}\n\nfloat smooth_(inout float p, inout float v0, inout float p0, inout float alpha)\n{\n  return v0 + alpha*(p - p0); // v0 + (v1 - v0)*(p - p0)/(p1 - p0);\n}\n\nfloat a[np + 1];\nfloat b[np + 1];\nfloat c[np + 1];\nfloat d[np + 1];\nfloat x[np + 1];\n\nint x_index(in float v)\n{\n  int l = 0;\n  if (v <= x[l]) { return l; }\n  int h = np;\n  if (v >= x[h]) { return h; }\n  while(h - l > 1)\n  {\n    int n = (l + h)/2;\n    float y = x[n];\n    if (y < v) { l = n; } else { h = n; }  \n  }\n  return l;\n}\n\nvoid make_spline(inout float vx[np + 1], inout float vy[np + 1])\n{\n  int n = np + 1;\n  int n_1 = n - 1;\n  \n  float alpha[np + 2];\n  float beta [np + 2];\n  \n  float al = 0.0;\n  alpha[0] = al;\n  float bt = 0.0;\n  beta [0] = bt;\n  \n  float x_1;\n  float x0  = vx[0];\n  float x1  = vx[1];\n  float hi0 = x1 - x0;\n  float y_1;\n  float y0  = vy[0];\n  float y1  = vy[1];\n  \n  float hi_1 = hi0; // h[-1] = h[0]\n  float cc = 2.0 * (hi0 + hi0);\n  float f  = 0.0;\n  float z  = 1.0/(hi_1*al + cc);\n  al = -hi0*z;\n  alpha[1] = al;\n  bt = (f - hi_1*bt)*z; // (0-A*0)/C;\n  beta[1] = bt;\n  int n1 = n - 2;\n  \n  for (int i = 1; i <= n1; i++)\n  {\n    int i1 = i + 1;\n    hi_1 = hi0;\n    x0   = x1;\n    x1   = vx[i1];\n    hi0  = x1 - x0;\n    y_1  = y0;\n    y0   = y1;\n    y1   = vy[i1];\n\n    cc = 2.0*(hi_1 + hi0);\n    f  = 3.0*((y1 - y0)/hi0 - (y0 - y_1)/hi_1);\n    z  = 1.0/(hi_1*al + cc); // 1.0/(AA*al + CC);\n    al = -hi0*z;\n    alpha[i1] = al;\n\n    bt = (f - hi_1*bt)*z;    // (F - AA*bt)*z;\n    beta[i1] = bt;\n  }\n  hi_1     = hi0;\n  cc       = 2.0 * (hi_1 + hi0);\n  f        = 0.0;\n  z        = 1.0/(hi_1*al + cc);  //1.0/(AA*al + CC);\n  alpha[n] = -hi0*z;\n  beta [n] = (f - hi_1*bt)*z;     //(F - AA*bt)*z;\n  \n  float cs[np + 1];\n  cc = 0.0;\n  cc = alpha[n]*cc + beta[n];\n  cs[n_1] = cc;\n  for (int i = n_1; i >= 1; i--)\n  {\n    cc = alpha[i]*cc + beta[i];\n    cs[i - 1] = cc;\n  }\n  \n  x0 = vx[0];\n  y0 = vy[0];\n  float c_1;\n  float c0 = cs[0];\n  for (int i = 1; i < n; i ++)\n  {\n    int i_1 = i - 1;\n    x_1  = x0;\n    x0   = vx[i];\n    hi_1 = x0 - x_1;\n    y_1  = y0;\n    y0   = vy[i];\n    c_1  = c0;\n    c0   = cs[i];\n    //a[i_1] = y_1;\n    b[i_1] = (y0 - y_1)/hi_1 - (c0 + 2.0*c_1)*hi_1/3.0; // (3_1)\n    c[i_1] = c_1;\n    d[i_1] = (c0 - c_1)/(3.0*hi_1);                   // (3_0)\n    //x[i_1] = x_1;\n  }\n  \n  x_1  = x0;\n  x0   = x0 + hi_1;\n  y_1  = y0;\n  y0   = 2.0*y0 - vy[n_1 - 1];\n  c_1  = c0;\n  c0   = 0.0;\n  //a[n_1] = y_1;\n  b[n_1] = (y0 - y_1)/hi_1 - (c0 + 2.0*c_1)*hi_1/3.0; // (3_1)\n  c[n_1] = c_1;\n  d[n_1] = (c0 - c_1)/(3.0*hi_1);                   // (3_0)\n  //x[n_1] = x_1;\n}\n\n\nvec3 interp_(in float p)\n{\n  int n = pos_index(p);\n  \n  float p0 = ps[n];\n  float p1 = ps[n + 1];\n  float a = 1.0/(p1 - p0);\n  \n  float r0 = cr[n];\n  float r1 = cr[n + 1];\n  float ar = (r1 - r0)*a;\n  \n  float g0 = cg[n];\n  float g1 = cg[n + 1];\n  float ag = (g1 - g0)*a;\n  \n  float b0 = cb[n];\n  float b1 = cb[n + 1];\n  float ab = (b1 - b0)*a;\n  \n  return vec3(smooth_(p, r0, p0, ar),\n              smooth_(p, g0, p0, ag),\n              smooth_(p, b0, p0, ab));\n}\n\n#define dl 0.01\n#define dt 0.015\n#define dw 0.02\n\n//===============================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; \n    \n    vec2 vs[nn + 1];\n    for (int i = 0; i <= nn; i++)\n        vs[i] = vec2(0.5 + 0.4*cos(0.1*iTime + 0.1*float(i)), 0.5 + 0.4*sin(2.5*iTime+ 0.3*float(i)));\n        \n    vec3 color;\n    if ((uv.x > dl)&&(uv.x < dl + dw))\n    {\n      if ((uv.y > dt)&&(uv.y < 1.0 - dt)) \n      { \n        color = interp_((uv.y - dt)/(1.0 - 2.0*dt));\n      }\n      else\n        { \n          float gray = 0.05*summ(uv, vs); \n          color = interp_(gray);\n        }\n    }\n    else\n      if (uv.x < 1.0 - dw - dl)\n      {\n        float gray = 0.05*summ(uv, vs); \n        color = (uv.x < 0.5) ? interp_(gray) : heatMap(gray);\n      }\n      else\n        if (uv.x < 1.0 - dl)\n        {\n          if ((uv.y > dt)&&(uv.y < 1.0 - dt)) \n          { \n            color = heatMap((uv.y - dt)/(1.0 - 2.0*dt));\n          }\n          else\n            { \n              float gray = 0.05*summ(uv, vs); \n              color = heatMap(gray);\n            }\n        }\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}