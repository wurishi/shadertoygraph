{"ver":"0.1","info":{"id":"ttSBRK","date":"1600281816","viewed":114,"name":"AV006_Pathtracing","username":"elefAntti","description":"Monte carlo path tracer based on https://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer","multibuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(0.45));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GROUND_HEIGHT 0.0\n#define FOCAL_LEN 2.0\n\n#define TIME iTime\n\n#define SPHERE_COUNT 30\n#define MATERIAL_COUNT 7\n\n#define LAMBERT 1\n#define METAL 2\n#define SHINY 3\n#define GLASS 4\n\n\nfloat raySphere(vec3 center, float radius, vec3 ray, vec3 rayOrigin)\n{\n    center -= rayOrigin;\n    float b = -dot(center, ray);\n    float c = dot(center,center) - radius*radius;\n    float D = b*b - c;\n    if(D < 0.0)\n    {\n        return 0.0;\n    }\n    else\n    {\n        return -b - sqrt(D);\n    }\n}\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n/*float noise(float x)\n{\n    return fract((sin(x * 102.1) * 1002.1 + sin(x * 53.0)* 3023.7));\n}                \n\nvec2 noise2(vec2 x)\n{\n  return vec2(noise(x.x), noise(x.y));\n}\n\nvec2 noise2(float x)\n{\n  return vec2(noise(x), noise(fract(noise(x * 5.0) * 11.0)));\n}\n\nvec3 noise3(float x)\n{\n    return vec3(noise(x), fract(noise(x * 5.0) * 11.0), fract(noise(x * 3.0) * 7.0));\n}*/\n\n#define noise(X) hash11(X * 1000.1)\n#define noise2(X) hash22(X * 1003.1)\n#define noise3(X) hash31(X * 2001.0)\n\nvec2 randomInUnitDisc(float seed)\n{\n    vec2 point = hash21(seed);\n\tfor(int i = 0; i < 200; ++i)\n    {\n        point = hash21(seed + float(i)) * 2.0 - vec2(1.0);\n        if(dot(point, point) < 1.0)\n        {\n            return point;\n        }\n    }\n    \n    return point;\n}\n\nvec3 randomInUnitSphere(vec3 seed)\n{\n    seed *= vec3(10.9, 223.0, 332.0);\n    vec3 point = hash33(seed);\n\tfor(int i = 1; i < 200; ++i)\n    {\n        point = hash33(seed + float(i)) * 2.0 - vec3(1.0);\n        if(dot(point, point) < 1.0)\n        {\n            return point;\n        }\n    }\n    \n    return point;\n}\n\nvec3 randomInHalfSphere(vec3 seed, vec3 facing)\n{\n    vec3 rnd = randomInUnitSphere(seed);\n    float projection = dot(rnd, facing);\n    if(projection > 0.0)\n    {\n        return rnd;\n    }\n    else\n    {\n        return rnd - 2.0*projection*facing;\n    }\n}\n\nfloat schlick(float cosine, float refIdx)\n{\n    float r0 = (1.0 - refIdx) / (1.0 + refIdx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nvec2 min2(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a:b;\n}\n\n\nvec3 sphereCenter2(int idx)\n{\n    return (noise3(float(idx) * 31.21) - vec3(0.5, 0.0, 0.5))\n        * vec3(15.0, 0.5, 15.0) + vec3(0.0, 0.2, 12.0);\n}\n\nfloat sphereRadius2(int idx)\n{\n    return sphereCenter2(idx).y + GROUND_HEIGHT;\n}\n\nconst int materialType[MATERIAL_COUNT] = int[MATERIAL_COUNT](\n    SHINY,\n    LAMBERT,\n    METAL,\n    LAMBERT,\n    GLASS,\n    GLASS,\n    LAMBERT\n);\n\nconst vec3 materialColor[MATERIAL_COUNT] = vec3[MATERIAL_COUNT](\n    vec3(0.1, 0.9, 0.1),\n    vec3(0.8, 0.3, 0.3),\n    vec3(0.3, 0.3, 0.3),\n    vec3(0.8, 0.8, 0.3),\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.9, 0.3, 0.9)\n);\n\nconst vec3 reflectionColor[MATERIAL_COUNT] = vec3[MATERIAL_COUNT](\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.8, 0.8, 0.5),\n    vec3(0.8, 0.8, 0.3),\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.9, 0.3, 0.9)\n);\n\nconst float materialFuzz[MATERIAL_COUNT] = float[MATERIAL_COUNT](\n    0.1,\n    0.1,\n    0.2,\n    0.0,\n    0.1,\n    0.0,\n    0.0\n);\n\nconst vec3 materialEmission[MATERIAL_COUNT] = vec3[MATERIAL_COUNT](\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.8, 0.8, 0.3),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\n\nconst float materialRefIdx[MATERIAL_COUNT] = float[MATERIAL_COUNT](\n    1.5,\n    1.5,\n    1.0,\n    1.0,\n    1.5,\n    1.5,\n    1.0\n);\n\nvec2 model(vec3 ray, vec3 rayOrigin)\n{\n    float groundDist =  -rayOrigin.y / ray.y;\n    vec2 hit = vec2(1000.0, -2.0);\n    if(groundDist > 0.0)\n    {\n         hit = min2(hit, vec2(groundDist, -1.0));\n    }\n    \n    for(int i = 0; i < SPHERE_COUNT; ++i)\n    {\n        float dist = raySphere(sphereCenter2(i), sphereRadius2(i), ray, rayOrigin);\n        if(dist > 0.0)\n        {\n            hit = min2(hit, vec2(dist, i));\n        }\n    }\n    return hit;\n}\n\nfloat viewpointAngle(float time)\n{\n    time /= 20.1;\n    float angle = pow(sin(time), 2.0) + time;\n    return angle - 20.0; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 jitteredCoord = fragCoord + hash23(vec3(fract(iTime), fragCoord));\n    vec2 uv = jitteredCoord - vec2(0.5, 0.5) * iResolution.xy;\n    uv /= iResolution.x;\n\n    vec3 ray = vec3(FOCAL_LEN);\n    ray.xy = uv;\n    ray = normalize(ray);\n    vec3 rayOrigin = vec3(0.0, 2.0, 0.0);\n    //rayOrigin.xy += randomInUnitDisc(uv.y * 5.0 + uv.x * 7.0) * 0.05;\n    \n    ray.yz *= rotate(0.2);\n    \n    \n    rayOrigin.z -= 10.0;\n    ray.xz *= rotate(viewpointAngle(TIME));\n    rayOrigin.xz *= rotate(viewpointAngle(TIME));\n    rayOrigin.z += 10.0;\n\n    vec3 col = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    vec3 emission = vec3(0.0);\n    \n    for(int bounce = 0; bounce < 10; ++bounce)\n    {\n        vec2 hit = model(ray, rayOrigin);\n\n        if(hit.y != -2.0)\n        {\n            vec3 hitpoint = rayOrigin + hit.x * ray;\n            vec3 normal = hit.y >= 0.0 ? normalize(hitpoint - sphereCenter2(int(hit.y))) : vec3(0.0, 1.0, 0.0);\n            \n            int materialIdx = int(hit.y) % (MATERIAL_COUNT - 1) + 1;\n            bool shouldReflect = (materialType[materialIdx] == METAL);\n            bool matte = false;\n            emission += attenuation * materialEmission[materialIdx];\n            \n            if(materialType[materialIdx] == SHINY || materialType[materialIdx] == GLASS)\n            {\n                float cosine = -dot(ray, normal);\n                float reflectProb = schlick(cosine, materialRefIdx[materialIdx]);\n                if(hash13(hitpoint * vec3(2100.32, 3201.0, 1702.1)) < reflectProb)\n                {\n                    shouldReflect = true;\n                }\n                matte = true;\n            }\n            \n            if(materialType[materialIdx] == GLASS && !shouldReflect)\n            {\n                float eta = 0.0;\n                vec3 outwardNormal =  vec3(0.0);\n                if(dot(ray, normal) > 0.0)\n                {\n                    eta = materialRefIdx[materialIdx];\n                    outwardNormal = -normal;\n                }\n                else\n                {\n                    eta = 1.0 / materialRefIdx[materialIdx];\n                    outwardNormal = normal;\n                }\n                vec3 refracted = refract(ray, normal, eta);\n                if(dot(refracted, refracted) < 0.001)\n                {\n                    shouldReflect = true;\n                }\n                else\n                {\n                    ray = refracted;\n                    ray += materialFuzz[materialIdx] * randomInUnitSphere(hitpoint * vec3(2100.32, 3221.0, 1652.1));\n                    ray=normalize(ray);\n                    rayOrigin = hitpoint + ray * 0.05;\n                    continue;\n                }\n            }\n            \n            if(shouldReflect)\n            {\n                ray = reflect(ray, normal);\n                ray += materialFuzz[materialIdx] * randomInUnitSphere(hitpoint * vec3(1041.2, 2431.0, 5652.1));;\n                ray = normalize(ray);\n                attenuation *= reflectionColor[materialIdx];\n            }\n            else if(matte)\n            {\n                vec3 seed = hitpoint * vec3(2334.0, 2121.0, 1121.0);\n                ray = normalize(randomInHalfSphere(seed, normal));\n                attenuation *= materialColor[materialIdx];\n            }\n            else\n            {\n                ray = normalize(normal + randomInUnitSphere(hitpoint * vec3(4330.2, 3521.0, 2881.1)));\n                attenuation *= materialColor[materialIdx];\n            }\n            \n            rayOrigin = hitpoint;\n            \n        }\n        else\n        {\n            col = mix(vec3(0.5, 0.7, 1.0), vec3(1.0), -ray.y) * attenuation + emission; \n            break;\n        }\n    }\n    \n    float speed = abs(viewpointAngle(TIME) - viewpointAngle(TIME - 0.03)) / 0.03;\n    float exposure = speed < 0.006 ? 0.96 : 0.8;\n    \n    vec4 oldColor = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = mix(vec4(col,1.0), oldColor, exposure);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"}]}