{"ver":"0.1","info":{"id":"wsdSz8","date":"1571510992","viewed":374,"name":"crystal_experimant","username":"skaplun","description":"Tried precompute rotation matrices - got performance degradation. Don't understand why this happens. ","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 64\n#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON 0.0001\n#define PI acos(-1.)\nfloat ang;\n\nconst vec3 color2 = vec3(0., 0., 1.);\nconst vec3 color3 = vec3(0., .35, 1.);\nconst vec3 color4 = vec3(1., .25, 0.);\n\nvec2 hash(vec2 st,float seed){\n\tst = vec2(dot(st,vec2(127.1,311.7)),\n\t          dot(st,vec2(269.5,183.3)));\n\treturn -1. + 2. * fract(sin(st) * seed);\n}\n\nfloat noise(vec2 st,float seed){\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t\n\tvec2 u = f*f*(3.-2.*f);\n\t\n\treturn mix(mix(dot(hash(i+vec2(0., 0.), seed), f-vec2(0., 0.)),\n\t\t\t\t   dot(hash(i+vec2(1., 0.), seed), f-vec2(1.,0.)),u.x),\n\t\t\t   mix(dot(hash(i+vec2(0., 1.), seed), f-vec2(0.,1.)),\n\t\t\t\t   dot(hash(i+vec2(1., 1.), seed), f-vec2(1.,1.)),u.x),u.y);\n}\nconst int octaves = 12;\nconst mat2 rot = mat2(cos(.75), sin(.75), -sin(.75), cos(.75));\nfloat fbm1(in vec2 _st){\n\tfloat result = 0.;\n\tfloat a = .95;\n\tfor(int i=0; i<octaves; i++){\n\t\tresult += a * noise(_st, 43758.5453123);\n\t\t_st *= rot * 2.31;\n\t\ta *= .4;\n\t}\n\treturn result + .5014;\n}\n\nfloat pattern(vec2 p, float m, out vec2 q, out vec2 r){\n    float t = iTime * 2.;\n    q = vec2(fbm1(p + m), fbm1(p + 1. - m));\n    r.x = fbm1(p + q + vec2(1.7, 9.2) + .15 * t);\n\tr.y = fbm1(p + q + vec2(8.3,2.8) + .12 * t);\n    return fbm1(p + r.xy);\n}\n\nvec4 colour(vec2 c, float m) {\n\tvec2 q, r;\n    float f = pattern(c, m, q, r) * 1.15;\n\tvec3 col = color2;\n\tcol = mix(col,color3,clamp(length(q),0.0,1.0));\n\tcol = mix(col,color4,clamp(length(r.x),0.0,1.0));\n\treturn vec4((f * f + .252) * col, f);\n}\n\nfloat hash(vec3 p){\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nmat3 rotZ(float a){\n\treturn mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.); \n}\n\nmat3 rotY(float a){\n\treturn mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a)); \n}\n\nmat3 rotX(float a){\n\treturn mat3(1., 0., 0., 0., cos(a), -sin(a), -sin(a), 0., cos(a)); \n}\n\nconst int ANG_CNT = 7;\nconst float SIZE = 2.;\nconst float CUTOFF_PLANE_DIST = 1.5;\nfloat world(vec3 p){\n\tfloat result = length(p) - SIZE;\n    \n    float angStep = 360./float(ANG_CNT);\n    for (int i=0; i<7; i++){\n\t\tfloat ang = angStep * float(i);\n        ang += hash(vec3(ang, float(i) * .17, .1731)) * 30.;\n        float xAng = 90. + (hash(vec3(ang, .17, .31))-.5) * 45.;\n        float clip = -(1.15 + (p * rotX(radians(xAng)) * rotZ(radians(ang))).y);\n    \tresult = max(result, clip);\n    }\n    \n    angStep = 120.;\n    for (int i=0; i<3; i++){\n\t\tfloat ang = angStep * float(i);\n        float xAng = 120. + (hash(vec3(ang, float(i) * .17, .131))-.5) * 40.;\n        float clip = -(1.2 + (p * rotY(radians(ang)) * rotZ(radians(xAng))).y);\n    \tresult = max(result, clip);\n    }\n    \n    for (int i=0; i<3; i++){\n\t\tfloat ang = angStep * float(i);\n        ang += hash(vec3(ang, i, 1.71)) * angStep;\n        float xAng = 60. + (hash(vec3(ang, float(i) * .71, .417))-.25) * 10.;\n        float clip = -(1.25 + (p * rotY(radians(ang)) * rotZ(radians(xAng))).y);\n    \tresult = max(result, clip);\n    }\n    \n    float clip = -(1.25 + (p * rotY(radians(230.)) * rotX(radians(55.))).y);\n    result = max(result, clip);\n    clip = -(1.4 + (p * rotY(radians(100.)) * rotX(radians(230.))).y);\n    result = max(result, clip);\n    clip = -(1.5 + (p * rotX(radians(220.))).y);\n    result = max(result, clip);\n    \n    return result;\n}\n\nfloat march(vec3 eye, vec3 marchingDirection, float start, float end, out float aa) {\n\tconst float precis = 0.001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float h = world( eye + marchingDirection * t );\n        if( h < precis ) break;\n        t += h;\n        aa = 1. - float(i)/float(64.);\n    }\n    return t;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)) - world(vec3(p.x - EPSILON, p.y, p.z)),\n        world(vec3(p.x, p.y + EPSILON, p.z)) - world(vec3(p.x, p.y - EPSILON, p.z)),\n        world(vec3(p.x, p.y, p.z  + EPSILON)) - world(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat2 r(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nbool marchCrystal(Ray ray, out vec3 color, out float dist){\n\tcolor = vec3(0.);\n    float glow = 0.;\n    dist = march(ray.origin, ray.direction, MIN_DIST, MAX_DIST, glow);\n    if (dist < MAX_DIST - MIN_FLOAT) {\n        vec3 startPoint = ray.origin + ray.direction * dist;\n        vec3 norm = estimateNormal(startPoint);\n        vec3 dir = refract(ray.direction, norm, 25.5);\n        vec3 innerColor = vec3(0.);\n        for(int i=0; i<20; i++){\n        \tvec3 p = startPoint + dir * (float(i) * .05);\n        \t\n            p.xz *= r(-ang);\n            vec4 n = colour(p.xy * 1., p.z);\n            if(n.a > .3){\n                innerColor += n.rgb * .075 * pow(1. - float(i)/20., .1);//mix(vec3(1., 0., 0.), vec3(0., 1., 0.), );\n            }\n        }\n        \n        color = innerColor * abs(dot(norm, ray.direction));\n        vec3 rr = reflect(ray.direction, norm);\n        color.xyz += .5 * pow(texture(iChannel0, rr).xyz, vec3(2.)).r;\n        \n        return true;\n    }\n    return false;\n}\n\nvec3 color(in vec2 fragCoord){\n\tang = (iResolution.x - iMouse.x) * .05;\n    vec3 eye = vec3(12. * sin(ang), 3., 12. * cos(ang));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., -.25, 0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    vec3 color;\n    float dist;\n    if(plane_hit(eye, worldDir, vec3(0., -2., 0.), vec3(0., -1., 0.), dist)){\n    \tvec3 p = eye + worldDir * dist;\n        float f = mod(floor(p.z) + floor(p.x), 2.);\n        color = .05 + f * vec3(.05);\n    \t\n        vec3 reflectedClr;\n        if (marchCrystal(Ray(p, reflect(worldDir, vec3(0., 1., 0.))), reflectedClr, dist))\n            color += .33 * reflectedClr;\n    }\n    \n    vec3 crystalClr;\n    float dist2;\n    if( marchCrystal(Ray(eye, worldDir), crystalClr, dist2) && dist2 < dist)\n    \tcolor = crystalClr.rgb; \n\n    return color;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(color(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n    \nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}","name":"Common","description":"","type":"common"}]}