{"ver":"0.1","info":{"id":"MlVyRm","date":"1535604816","viewed":287,"name":"Riemann Zeta","username":"Justaway","description":"Riemann zeta function calculated using the convergence of alternating series.  \nhttp://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nDon't know why I'm getting the artifacts.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["riemannzeta"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 20\n#define E 2.71828\n#define PI 3.14159\n\nconst float[20] ek = float[20](\n\t1048575.000000,1048555.000000,1048365.000000,\n    1047225.000000,1042380.000000,1026876.000000,\n    988116.000000,910596.000000,784626.000000,\n    616666.000000,431910.000000,263950.000000,\n    137980.000000,60460.000000,21700.001953,\n    6196.000488,1351.000122,211.000000,21.000000,1.000000);\n\nvec2 cpow(vec2 z1, vec2 z2)\n{\n\tfloat a2b2 = z1.x * z1.x + z1.y * z1.y;\n\tfloat t1 = pow(a2b2, z2.x / 2.0) * exp(-z2.y * atan(z1.y, z1.x));\n\tfloat t2 = z2.x * atan(z1.y, z1.x) + 0.5 * z2.y * log(a2b2);\n\treturn vec2(t1 * cos(t2), t1 * sin(t2));\n}\n\nvec2 cdiv(vec2 z1, vec2 z2)\n{\n\treturn z1 * mat2(z2, -z2.y, z2.x) / dot(z2, z2);\n}\n\nvec2 cprod(vec2 z1, vec2 z2)\n{\n\treturn vec2(\n\t\tz1.x * z2.x - z1.y * z2.y,\n\t\tz1.x * z2.y + z1.y * z2.x);\n}\n\nvec2 alt(int x)\n{\n\tfloat[2] tbl = float[2](1.0,-1.0);\n\treturn vec2(tbl[int(mod(float(x),2.0))],0.0);\n}\n    \nvec2 zeta(vec2 s)\n{\n\tvec2 sum1 = vec2(0.0);\n\tvec2 sum2 = vec2(0.0);\n\tvec2 k;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum1 += cdiv(alt(i - 1), cpow(k , s));\n\t}\n\tfor(int i = N + 1; i <= 2 * N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum2 += cdiv(cprod(alt(i - 1), vec2(ek[i - N - 1],0.0)), cpow(k,s));\n\t}\n    sum2 = cdiv(sum2, vec2(pow(2.0, float(N)), 0.0));\n    return cdiv(sum1 + sum2,vec2(1.0, 0.0) - cpow(vec2(2.0 ,0.0), vec2(1.0, 0.0) - s));\n\treturn vec2(0.0);\n}\n\nvec4 gradient(float theta)\n{\n    vec4 color = vec4(0.0);\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec4 plotDomain(vec2 z)\n{\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    vec2 z = uv * 13.0 + vec2(0.0, iTime * 2.0 - 2.0);\n    fragColor = plotDomain(zeta(z));\n}","name":"Image","description":"","type":"image"}]}