{"ver":"0.1","info":{"id":"4dlyD7","date":"1488727560","viewed":327,"name":"Simpe Waves Sim","username":"Razum","description":"My first shader! Created for RhythmoDynamics adepts. ","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GRID_COLOR 1.0, 1.0, 1.0, 0.2 //Color of grid(one distance unit - one grid segment) Last number - transparency\nconst vec4 GridColor = vec4 (GRID_COLOR);\n\nvec2 scr2Inner (vec2 fragCoord, float gridConst)\n{\n    return (fragCoord - iResolution.xy * 0.5)*gridConst;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    float gridWidth = texture(iChannel0, vec2(1.0, 1.0)/iChannelResolution[0].xy).r;\n    float gridConst = texture(iChannel0, vec2(1.0, 1.0)/iChannelResolution[0].xy).g;\n    \n    vec2 coords = scr2Inner (fragCoord, gridConst);\n    \n    fragColor = texture(iChannel0, uv);\n    \n    //Drawing grid\n    if (GridColor.a > 0.0001)\n        if (fract(coords.x) <  gridWidth ||\n            fract(coords.x) >= 1.0 - gridWidth ||\n            fract(coords.y) <  gridWidth ||\n            fract(coords.y) >= 1.0 - gridWidth)\n\n            fragColor = vec4(mix(fragColor.rgb, GridColor.rgb, GridColor.a), 1.0);\n        \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AMP_POW 0.0\n// 0.0 - Amplitude is constant on any dsistance from oscillator.\n// 1.0 - Amplitude proportional 1/r\n// 2.0 - Amplitude proportional 1/r^2\n// And so on...\n\n#define PHASE 1.0\n#define PHASE_TRESH2 0.01\n\n#define TIME_SMOOTH 0.02\n//Averaging coefficient between previous frame and current frame. Must be in range [0.0, 1.0]\n//1.0 - Shows only current frame\n//0.01 - Good for detect standing waves\n\n#define C 1.0\n// Wave speed\n\n#define W 1.2, 0.0\n// Wind vector\n\n#define GEN_RAD 0.1\n// Osillator radius\n\n#define GRID_CONST 0.01\n// Defines number of distance units in one pixel\n\n#define GRID_WIDTH GRID_CONST/1.9\n//Width of grid lines\n\n// Color components must be in range [0.0, 1.0]\n//                red green blue\n#define MAX_COLOR 0.6, 1.0, 0.3 //Color of maximum amplitude\n#define ZERO_COLOR 0.0, 0.0, 0.0 //Color of zero amplitude\n#define MIN_COLOR 1.0, 0.3, 0.3 //Color of minimum amplitude\n\n#define MAX_AMP 2.0 // Maximum amplitude. If value is greater, it will be painted same as MAX_AMP\n#define ZERO_AMP 0.0 // Pixels with this value will be pained in color of ZeroColor\n#define MIN_AMP -MAX_AMP // Minimum amplitude. If value is lesser, it will be painted same as MIN_AMP\n\n//========================================================================================================\n#define PI2 6.28318530718 //pi*2\n#define C2 C*C\n\n//========================================================================================================\n#define GEN_INIT(phase, freq, amp, x, y) waveGen(phase, freq, amp, vec2(x, y), wgConsts(PI2*freq/C, PI2*freq, PI2*phase))\n\n//========================================================================================================\nstruct wgConsts\n{\n    float c1;\n    float c2;\n    float f0;\n};\nstruct waveGen\n{\n    float phase;\n    float freq;\n    float amp;\n    vec2 position;\n    wgConsts consts;\n};\n\n//=====ARRAY OF Oscillators========================\n//aux consts:\n#define SHIFT 1.0\n#define FREQ 1.0\n#define RAD 0.383\n    \n//You can create any number of oscillators\n//GEN_INIT ({start phase(angle / 2PI, means PI angle = 0.5)},\n//\t\t\t{frequency}, \n//\t\t\t{amplitude(on distance 1 from oscillator)},\n//\t\t\t{coordinate x},\n//\t\t\t{coordinate y})\n//Coordinates (0, 0) always in center of screen\n//Example:\n/*waveGen genArray[] = waveGen[](\n    GEN_INIT (0.0, 1.0, 1.0, SHIFT + 0.8, 4.0),\n    GEN_INIT (0.1, 1.0, 1.0, SHIFT + 0.45, 3.0),\n    GEN_INIT (0.2, 1.0, 1.0, SHIFT + 0.2, 2.0),\n    \n    GEN_INIT (0.3, 1.0, 1.0, SHIFT + 0.05, 1.0),\n    GEN_INIT (0.4, 1.0, 1.0, SHIFT + 0.0, 0.0),\n    GEN_INIT (0.5, 1.0, 1.0, SHIFT + 0.05, -1.0),\n    \n    GEN_INIT (0.6, 1.0, 1.0, SHIFT + 0.2, -2.0),\n\tGEN_INIT (0.7, 1.0, 1.0, SHIFT + 0.45, -3.0),\n    GEN_INIT (0.8, 1.0, 1.0, SHIFT + 0.8, -4.0));*/\nwaveGen genArray[] = waveGen[](\n    GEN_INIT (0.0, FREQ, 1.0, 0.0, 0.0)\n);\n//=================================================\n\n//========================================================================================================\nconst vec3 GradMax = vec3 (MAX_COLOR);\nconst vec3 GradZ = vec3 (ZERO_COLOR);\nconst vec3 GradMin = vec3 (MIN_COLOR);\nconst vec2 Wind = vec2(W);\nconst float w2 = dot(Wind, Wind);\nconst float cw = C2 - w2;\n\n//========================================================================================================\nvec4 colorGrad (float value)\n{\n    if (value > ZERO_AMP) return vec4 (mix (GradZ, GradMax, (clamp (value, ZERO_AMP, MAX_AMP)-ZERO_AMP)/(MAX_AMP - ZERO_AMP)), 1.0);\n    else return vec4 (mix (GradMin, GradZ, (clamp (value, MIN_AMP, ZERO_AMP)-MIN_AMP)/(ZERO_AMP - MIN_AMP)), 1.0);\n}\n\nvec2 scr2Inner (vec2 fragCoord)\n{\n    return (fragCoord - iResolution.xy * 0.5)*GRID_CONST;\n}\n\nfloat wave (vec2 coord, float time, waveGen gen)\n{\n    if (distance(gen.position, coord) > GEN_RAD)\n    {\t\n        vec2 D = coord - gen.position;\n        float d = dot(D, -Wind);\n        float D2 = dot(D, D);\n        float dt = 0.0;\n        float amp = 0.0;\n\n        float discr = d*d + D2*cw;  \n        //return discr;\n        if (discr < 0.0) return 0.0;\n        discr = sqrt(discr);\n\n        if (cw == 0.0) dt = -D2/(2.0*d);\n        else dt = (d + discr)/cw;\n        //return dt;\n        \n        if (dt < 0.0) return 0.0;\n            \n        amp = gen.amp * pow(C*dt, -AMP_POW) * cos(gen.consts.f0 - (time - dt) * gen.consts.c2);\n        if (cw < 0.0)\n        {\t\n            dt = (d - discr)/cw;\n            amp += gen.amp * pow(C*dt, -AMP_POW) * cos(gen.consts.f0 - (time - dt) * gen.consts.c2);\n        }\n        \n        return amp;\n    }\n    \telse return gen.amp * cos(gen.consts.f0 - time * gen.consts.c2);\n}\n\nfloat phase (vec2 coord, float time, waveGen gen)\n{\n    if (distance(gen.position, coord) > GEN_RAD)\n    {\t\n        vec2 D = coord - gen.position;\n        float d = dot(D, -Wind);\n        float D2 = dot(D, D);\n        float dt = 0.0;\n        float pha = 0.0;\n        float pha2 = -1.0;\n        float pp2 = -1.0;\n\n        float discr = d*d + D2*cw;  \n        //return discr;\n        if (discr < 0.0) return 0.0;\n        discr = sqrt(discr);\n\n        if (cw == 0.0) dt = -D2/(2.0*d);\n        else dt = (d + discr)/cw;\n        //return dt;\n        \n        if (dt < 0.0) return 0.0;\n            \n        pha = mod ((gen.consts.f0 - (time - dt) * gen.consts.c2), PI2);\n        if (cw < 0.0)\n        {\t\n            dt = (d - discr)/cw;\n            pha2 = mod ((gen.consts.f0 - (time - dt) * gen.consts.c2), PI2);\n            pp2 = pow (pha2 - PHASE, 2.0);\n        }\n        \n        float pp = pow (pha - PHASE, 2.0);\n        \n        float tval = 0.0;\n                \n        if (pp < PHASE_TRESH2) tval = gen.amp * (1.0 - pp/PHASE_TRESH2);\n        if (pp2 > 0.0 && pp2 < PHASE_TRESH2) tval += gen.amp * (1.0 - pp2/PHASE_TRESH2);\n        return tval;\n    }\n    \telse return gen.amp;\n}\n\n//===MAIN=====================================================================================================\n\n#define field_func wave\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    //Kludge for transfer grid constant to \"Image\" code...\n    if (fragCoord.x < 3.0 && fragCoord.y < 3.0)\n    {\n    \tfragColor = vec4 (clamp(GRID_WIDTH, 0.0, 1.0), clamp(GRID_CONST, 0.0, 1.0), 0.0, 1.0);\n        return;\n    }\n    \n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    vec2 innerCoord = scr2Inner(fragCoord);\n    float amp = 0.0;\n    float time = iTime;\n    \n    int len = genArray.length();\n    int inGen = -1;\n    for (int i = 0; i < len; ++i)\n        if (distance(genArray[i].position, innerCoord) < GEN_RAD) inGen = i;\n\tif (inGen == -1) \n\t\tfor (int i = 0; i < len; ++i)\n        {\n            //amp += wave2(innerCoord, time, genArray[i]);\n            //alternate circular function\n            amp += field_func(innerCoord, time, genArray[i]);\n        }\n    else amp = field_func(innerCoord, time, genArray[inGen]);\n    \n    fragColor = mix (texture(iChannel0, uv),colorGrad(amp), TIME_SMOOTH);\n}","name":"Buffer A","description":"","type":"buffer"}]}