{"ver":"0.1","info":{"id":"WdjGDd","date":"1550320057","viewed":106,"name":"Floating Particle","username":"kuma720","description":"particle","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BUF0 iChannel0\n#define BUF1 iChannel1\n#define PARTICLE_CNT 40\n#define DATASIZE 50\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\nfloat smix( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdf( vec3 p , out int material) {\n    vec2 ratio = (1.0/iResolution.xy);\n    int rx = int( iResolution.x );\n\n    material = 1;\n\n    float len = 9999.;\n    for( int I=0 ; I<PARTICLE_CNT ; ++I) {\n        int idx = I * DATASIZE;\n        int y = idx / rx;\n        int x = idx - y*rx; \n    \tvec4 pos = texelFetch ( BUF0 , ivec2(x,y) , 0 );\n                           \n        //float l = length(p - pos.xyz) - 0.2;\n        float l = sdRoundBox( p - pos.xyz, vec3(0.1) , 0.01 );\n        len = smix( len , l ,  0.5 );\n     \n    }\n    \n    \n    vec4 map = texture( BUF1 , ( p.xz + vec2(5.,5.) ) * .1 ) ;\n    float l = max( p.y - map.y , 0. );\n    if ( l < len ) {\n        len = l;\n        material = 2;\n    }\n         \n    return len;\n    \n}\n\n//vec3 createnormal(vec3 p) {\n//  float e = 0.001;\n//  return normalize( vec3(\n//    sdf( vec3(p.x+e,p.y,p.z) ) - sdf( vec3(p.x-e,p.y,p.z) ) ,\n//    sdf( vec3(p.x,p.y+e,p.z) ) - sdf( vec3(p.x,p.y-e,p.z) ) ,\n//    sdf( vec3(p.x,p.y,p.z+e) ) - sdf( vec3(p.x,p.y,p.z-e) )\n//  ));\n//\n//}\n\n\nvec4 render( vec2 uv , vec3 eye , vec3 dir ) {\n\n  float len = 0.;\n  vec3 lightVec = vec3(1.,1.,1.);\n  vec3 lightColor = vec3( 0.1 , 0.3, 0.5 );\n\n  for ( int i = 0 ; i < 80 ; ++ i ) {\n    vec3 p = eye + dir * len;\n\t\n      int material = 0;\n    float l = sdf( p , material );\n    len += length( l ) ;\n\n    if ( l < 0.01 ) {\n        if ( material==1 ) {\n            return p.y * 4. * vec4(1.1,0.4,0.5,1.);\n        }\n        if ( material==2 ) {\n            return p.y * 2.5 * vec4( 0.3,0.6,1.4,1.) ;\n        }\n    }\n\n  }\n\n  return vec4( 0. , 0. , 0. , 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) ;\n\n    float t = iTime * .1;\n    vec3 eye = vec3( 5. , 5. , 5. );\n    vec3 center = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n   fragColor = render( uv , eye , worldDir );\n    \n//    fragColor += texture( BUF0 , uv ) * 5.;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BUF0 iChannel0\n#define BUF1 iChannel1\n#define DATASIZE 50\n\n\nvoid mainImage( out vec4 col, in vec2 fc )\n{\n    vec2 R = iChannelResolution[0].xy;\n    vec2 ratio = (1.0/R.xy);\n    \n    vec2 uv = fc * ratio;\n    \n    int rx = int( floor(R.x) );\n    int fcx = int( floor(fc.x) );\n    int fcy = int( floor(fc.y) );\n    int N = fcx + fcy * rx;    \n    int id = N / DATASIZE;\n    int type = N % DATASIZE;\n    \n    vec4 pos;\n    vec4 vel;\n    \n    int idx = (id * DATASIZE);\n\n    int idx0 = idx;\n    int y0 = idx0 / rx;\n    int x0 = idx0 - y0*rx; \n    pos = texelFetch ( BUF0 , ivec2(x0,y0) , 0 );\n        \n    int idx1 = (idx + 5);\n    int y1 = idx1 / rx;\n    int x1 = idx1 - y1*rx; \n    vel = texelFetch ( BUF0 , ivec2(x1,y1) , 0 );\n\n    \n    if ( fcx==x0 && fcy==y0 ) {\n    \tvec4 map = texture( BUF1 , ( pos.xz + vec2(5.,5.) ) * .1 ) ;\n        \n        if ( iFrame < 20 ) {\n            pos.x = uv.x * 10.;\n            pos.y = 1.;\n            pos.z = uv.y * 10.;\n            col = pos;\n            return;\n        }        \n        \n        pos = pos + vel;\n        \n        if ( pos.x < -5. ||  5. < pos.x || pos.z < -5. || 5. < pos.z ) {\n            pos.x = 0.;\n            pos.y = 5.;\n            pos.z = 0.;\n        }\n        \n       pos.y = max( pos.y , map.y + .1);\n        \n        col = pos;\n        return;\n    }\n    \n\n    if ( fcx==x1 && fcy==y1 ) {\n    \tvec4 map = texture( BUF1 , ( pos.xz + vec2(5.,5.) ) * .1 ) ;\n        \n        vel.x -= map.x;\n        vel.x *= 0.99;\n        vel.z -= map.z;\n        vel.z *= 0.99;\n        \n        if ( map.y < pos.y ) {\n        \tvel.y -= .01;\n        } else {\n        \tvel.y += ( map.y - pos.y ) * .05;\n        }\n        vel.y *= 0.95;\n        \n        col = vel;\n        return;\n    }\n\t\n    col = vec4( 0. );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float noise( vec2 v ) {\n  return fract( sin ( dot( v , vec2( 78.123 , 36.1226 ) ) ) * 64.314 );\n}\n\nfloat pnoise( vec2 uv ) {\n\n  vec2 a = fract( uv );\n  a = a * a * ( 3. - 2. * a );\n\n  //dirc\n  vec2 uv2 = floor( uv );\n  float w0 = noise ( uv2 ) ;\n  float w1 = noise ( uv2 + vec2( 1. , 0. ) ) ;\n  float w2 = noise ( uv2 + vec2( 0. , 1. ) ) ;\n  float w3 = noise ( uv2 + vec2( 1. , 1. ) ) ;\n\n  float g0 = dot( vec2(w0) , ( a - vec2(0.,0.) ) ) ;\n  float g1 = dot( vec2(w1) , ( a - vec2(1.,0.) ) ) ;\n  float g2 = dot( vec2(w2) , ( a - vec2(0.,1.) ) ) ;\n  float g3 = dot( vec2(w3) , ( a - vec2(1.,1.) ) ) ;\n\n  float h0 = mix( g0 , g1 , a.x );\n  float h1 = mix( g2 , g3 , a.x );\n  float h2 = mix( h0 , h1 , a.y );\n\n  float h = h2 + .1;\n\n  return h;\n}\n\nfloat fbm( vec2 uv ) {\n  float a = pnoise( uv + iTime * .4 );\n  a += pnoise( uv * 2. ) * 0.5 ;\n  a += pnoise( uv * 4. ) * 0.25 ;\n  a += pnoise( uv * 8. ) * 0.125 ;\n  a += pnoise( uv * 16. ) * 0.0625 ;\n  a += pnoise( uv * 32. ) * 0.03125 ;\n  return a;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 6.;\n    \n    float E = .001;\n    float l = fbm(uv + vec2( -E , 0. ) );\n    float r = fbm(uv + vec2(  E , 0. ) );\n    float u = fbm(uv + vec2( 0. , -E ) );\n    float d = fbm(uv + vec2( 0. ,  E ) );\n    float h = fbm(uv);\n    fragColor = vec4( r - l , h , d - u , 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}