{"ver":"0.1","info":{"id":"dlffW8","date":"1692854309","viewed":88,"name":"Hexagon tiling transition","username":"artrointel","description":"MIT License\nhttps://www.youtube.com/watch?v=VmrIDyYiJBA\n","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["hexagon","transition","pattern","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n// https://www.youtube.com/watch?v=VmrIDyYiJBA\n// \n// PUT any texture 0, 1 to see the transition effect if not exists\n\nconst float NUM_TILES = 10.0; // number of tiles [1.0, ~]\nconst float GRADIENT_SIZE = 2.0; // hexagon appearing gradient [0.0, ~] \nconst float DEPTH_FEELING = 10.0; // depth feeling by distortion of border of hexahon [1.0, ~]\n\nconst float SPEED_TEST = 0.2;\n\nconst vec2 MAKE_HEX_LINE = vec2(1, sqrt(3.0));\nconst vec2 HALF_HEX_LINE = 0.5 * MAKE_HEX_LINE;\n\nfloat hexDist(vec2 localUv) {\n    localUv = abs(localUv);\n    float dist = dot(localUv, normalize(MAKE_HEX_LINE));\n    return max(dist, localUv.x);\n}\n\nvec4 hexTiles(vec2 uv, float amount) {\n    uv *= amount;\n    vec2 a = mod(uv, MAKE_HEX_LINE) - HALF_HEX_LINE;\n    vec2 b = mod(uv - HALF_HEX_LINE, MAKE_HEX_LINE) - HALF_HEX_LINE;\n    \n    vec2 hex;\n    if (length(a) < length(b)) {\n        hex = a;\n    } else {\n        hex = b;\n    }\n    vec2 id = uv - hex;\n    return vec4(hex.x, hex.y, id.x, id.y); // hex(x,y) with id(x,y)\n}\n\nfloat getDiagonalLength(vec2 focus) {\n    float aspectRatio = iResolution.x / iResolution.y;\n    return length(vec2(\n            max(focus.x, (1.0 - focus.x)) * aspectRatio, \n            max(focus.y, (1.0 - focus.y))\n            ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // test the speed of transition with this progress in [0, 1]\n    float progress = abs((2.*mod(iTime*SPEED_TEST, 1.0)-1.0)); \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 tuv = fragCoord / iResolution.xy;\n    vec2 uv = tuv - 0.5;\n    uv.x *= aspectRatio;\n    \n    // click screen to set focus position\n    vec2 mouse = iMouse.xy;\n    if (length(mouse) < 10.0) {\n        mouse = iResolution.xy * 0.5;\n    }\n    vec2 focus = mouse / iResolution.xy - 0.5;\n    focus.x *= aspectRatio;\n    \n    vec4 hexData = hexTiles(uv, NUM_TILES);\n    vec2 hexLocalUv = hexData.xy / NUM_TILES;\n    vec2 hexId = hexData.zw / NUM_TILES;\n    float spreadSpeed = (1.0 + GRADIENT_SIZE) * getDiagonalLength(iMouse.xy/iResolution.xy);\n    float hexSize = progress * spreadSpeed - length(hexId - focus);\n    if (GRADIENT_SIZE > 0.0)\n        hexSize /= GRADIENT_SIZE;\n    \n    float stepMin = clamp(hexSize, 0.0, 1.0);\n    float stepMax = clamp(hexSize * DEPTH_FEELING, 0.0, 1.0);\n    float dist = smoothstep(stepMin, stepMax, hexDist(hexData.xy));\n    float distInv = 1.0 - dist;\n    float depth = clamp(distInv + dist * progress, 0.0, 1.0);\n    depth = pow(depth, DEPTH_FEELING);\n    \n    vec2 finalUv = tuv + hexLocalUv * (1.0 - depth);\n    \n    vec4 color = mix(texture(iChannel0, tuv), distInv * texture(iChannel1, finalUv), distInv);\n    fragColor = vec4(color.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}