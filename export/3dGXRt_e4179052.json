{"ver":"0.1","info":{"id":"3dGXRt","date":"1574759503","viewed":167,"name":"flying_dots","username":"skaplun","description":"Original - https://twitter.com/concinnus/status/1198300190643347456","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["projection","multipass","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float color = 1.;\n    color *= 1. - texture(iChannel0, fragCoord/iResolution.xy).x;\n    vec3[3] pp = getProjectedDots(fragCoord, iResolution.xy, iTime);\n    \n    color = min(color, smoothstep(.05 + pp[1].z * .025, .06 + pp[1].z * .025, distance(uv, pp[1].xy)));\n    color = min(color, smoothstep(.05 + pp[2].z * .05, .06 + pp[2].z * .05, distance(uv, pp[2].xy)));\n    color = min(color, smoothstep(.1, .11, distance(uv, pp[0].xy)));\n    \n    color = min(color, smoothstep(.015, .0175, dist2Line(pp[0].xy, pp[1].xy, uv)));\n    color = min(color, smoothstep(.015, .0175, dist2Line(pp[1].xy, pp[2].xy, uv)));\n    \n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define r(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nconst float PI = acos(-1.);\n\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\n//We create perspective matrix here, but use it like ortho. Need to be fixed. \nvec3[3] getProjectedDots(in vec2 fragCoord, in vec2 iResolution, in float iTime){\n\tiTime *= .5;\n    vec3 eye = vec3(0., 3., 20.);\n    vec3 viewDir = rayDirection(45., iResolution, fragCoord);\n    mat3 viewMatr = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.));\n    vec3 worldDir = viewMatr * viewDir;\n    \n    vec3 cp = vec3(0.);\n    vec3 p1 = vec3(.75, 0., 0.);\n    vec3 p2 = vec3(.5 + fbm1x(.37, iTime), .75 +  + fbm1x(.71, iTime) * .25, 0.);\n    {\n        float a = iTime * 5.;\n        p2.zy *= r(fbm1x(a * .25, iTime) * PI * 5.);\n        p1.xz *= r(a);\n        p1.xy *= r(radians(30.));\n        p2.xz *= r(a);\n        p2.xy *= r(radians(30.));\n    }\n    vec3 pcp = inverse(viewMatr) * cp;\n    vec3 pp1 = inverse(viewMatr) * p1;\n    vec3 pp2 = inverse(viewMatr) * p2;\n    \n    return vec3[3](pcp, pp1, pp2);\n}\n\nfloat dist2Line(vec2 a, vec2 b, vec2 p) { \n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.); \n\treturn length( p - b * h );                       \n}\n\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3[3] pp = getProjectedDots(fragCoord, iResolution.xy, iTime);\n    \n    vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float color = 0.;\n    \n    vec2 prevP1, prevP2,\n         midP1, midP2;\n    if(iFrame == 0){\n    \tprevP1 = midP1 = pp[1].xy;\n    \tprevP2 = midP2 = pp[2].xy;\n    }else{\n    \tprevP1 = texelFetch(iChannel0, ivec2(0), 0).zw;\n    \tprevP2 = texelFetch(iChannel0, ivec2(1, 0), 0).zw;\n        midP1 = texelFetch(iChannel0, ivec2(0), 0).xy;\n    \tmidP2 = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    }\n    \n    color = max(color, smoothstep(.02 + pp[1].z * .005, .015 + pp[1].z * .005, sdBezier(uv, pp[1].xy, midP1, prevP1)));\n    color = max(color, smoothstep(.03 + pp[2].z * .015, .02 + pp[2].z * .015, sdBezier(uv, pp[2].xy, midP2, prevP2)));\n    \n    float ch = texture(iChannel0, fragCoord/iResolution.xy).x * .975;\n\t\n    if(ivec2(fragCoord) == ivec2(0)){\n    \tvec4 ch  = texelFetch(iChannel0, ivec2(0), 0);\n\t\tfragColor.zw = ch.xy;\n        fragColor.xy = pp[1].xy;\n    }\n    else if(ivec2(fragCoord) == ivec2(1, 0)){\n    \tvec4 ch  = texelFetch(iChannel0, ivec2(1, 0), 0);\n\t\tfragColor.zw = ch.xy;\n        fragColor.xy = pp[2].xy;    \n    }\n    else{\n    \tfragColor = vec4(max(color, ch));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}