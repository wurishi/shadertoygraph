{"ver":"0.1","info":{"id":"csS3Dc","date":"1668444860","viewed":122,"name":"Smooth Noise Plot","username":"Tzapetto","description":"A plot of value noise using quadratic spline interpolation","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","plot","splines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash function with 1 input, 1 output\n// Taken from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p*.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// Normalizes screen coordinates uniformly so that (0, 0) is at the\n// center of the screen and the smallest dimension spans [-1, 1)\nvec2 normalizeScreenCoords(in vec2 screenCoords) {\n    return (2.*screenCoords - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\n\n// Quadratic B spline interpolating points from hash\nfloat valueNoise(float x) {\n    const float hash_x_scale = 0.3;\n    const float hash_y_scale = 1.8;\n    \n    float p = floor(x);\n    float w = fract(x);\n    float w_sq = w*w;\n    \n    float h0 = hash11(hash_x_scale * p);\n    float h1 = hash11(hash_x_scale * (p + 1.));\n    float h2 = hash11(hash_x_scale * (p + 2.));\n    \n    float v = h2 * w_sq * 0.5;\n    v += h1 * (0.5 + w - w_sq);\n    v += h0 * (w_sq - 2.*w + 1.) * 0.5;\n    \n    v = hash_y_scale * (v - 0.5);\n    \n    return v;\n}\n\n\n// Function to plot\nfloat f(float x) {\n    float v = valueNoise(4. * x);\n    \n    return v;\n}\n\n\n//\nfloat derivative(float x, float fx) {\n    float h = 1e-4;\n    \n    return (f(x + h) - f(x - h)) / (2.*h);\n    \n    // Less precise method using dFdx built-in\n    //float x_axis_scale = dFdx(x); // Essentially pixel size\n    //return dFdx(fx) / x_axis_scale;\n}\n\n\n// 1st order estimation of distance to function graph\nfloat distToGraph(vec2 uv, float fx) {\n    float tangent = derivative(uv.x, fx);\n    float tangent_sq = tangent*tangent;\n    return (uv.y - fx) / pow(1. + tangent_sq, 0.5);\n}\n\n\n// 1st order estimation of distance to function graph\nfloat distToGraph(vec2 uv, float fx, float dfdx) {\n    float tangent_sq = dfdx*dfdx;\n    return (uv.y - fx) / pow(1. + tangent_sq, 0.5);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates (from 0 to 1)\n    vec2 uv = normalizeScreenCoords(fragCoord.xy);\n\n    // Compute function value at x\n    float fx = f(uv.x);\n    float dfdx = derivative(uv.x, fx);\n    float dy = uv.y - fx;\n    \n    // Graph\n    float pixel_size = 2. / min(iResolution.x, iResolution.y);\n    float graph_half_width = 4.*pixel_size;\n    float graph_falloff = 3.*pixel_size;\n    float d = distToGraph(uv, fx, dfdx);\n    float graph_alpha = smoothstep(graph_half_width + graph_falloff, graph_half_width, abs(d));\n    vec3 graph_color = vec3(0.5);\n    graph_color += 1. - smoothstep(0., 2.*pixel_size, abs(d - 1.5*pixel_size));\n    \n    // Distance estimation is not good away from the graph\n    // so use a combination of d and dy\n    float weighted_d = (d + dy) / 2.;\n    \n    // Coloring\n    // Inspired by the coloring of 2D SDFs used by Inigo Quilez: https://iquilezles.org/articles/distfunctions2d/\n    \n    // Use different colors for the areas above and below the graph\n    vec3 above_color = vec3(0.9, 0.2, 0.7);\n    vec3 below_color = vec3(0.2, 0.3, 0.8);\n    vec3 color = (dy > 0.0) ? above_color : below_color;\n    \n    float wave = 0.5 + 0.5*cos(40.0*dy + 3.*iTime*sign(dy));\n    color *= 0.6 + 1.2*pow(wave, 100.);\n    \n    // Darkening based on distance\n    color *= 1.0 - exp(-1.5*abs(weighted_d));\n    \n    // Darkening based on derivative\n    float darkening_dfdx = 0.6 + 0.6*smoothstep(-4., 0., -dfdx);\n    color *= darkening_dfdx;\n    \n    // Add the graph\n    color = mix(color, graph_color, graph_alpha);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}