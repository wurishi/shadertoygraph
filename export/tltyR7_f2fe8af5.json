{"ver":"0.1","info":{"id":"tltyR7","date":"1700993468","viewed":58,"name":"Radar by Darko","username":"omegasbk","description":"Had some fun with plotting and making this simple radar.\nDisclaimer: quite an old shader I made public","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["radarfun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Darko Supe (omegasbk) 2021\n\n#define PI 3.1415926535897932384626433832795\n#define LINES_GRID_COUNT 25\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x * 100. + p.y * 5412.) * 4340.);\n}\n\nfloat noiseSmooth(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    lv = lv * lv * (3.0 - 2.0 * lv); // Sigmoid interpolation\n    \n    vec2 index = floor(uv);    \n\n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1, 0));\n    float top = mix(topLeft, topRight, lv.x);\n    \n    float botLeft = noise(index + vec2(0, 1));\n    float botRight = noise(index + vec2(1, 1));\n    float bot = mix(botLeft, botRight, lv.x);\n     \n    return mix(top, bot, lv.y);\n}\n\nvec4 drawCircle(vec2 uv, vec2 position, vec3 color, float radius, float thickness)\n{\n    float outer = 1. - smoothstep(radius, radius + 1.5/iResolution.y, distance(uv, position));\n    float inner = 1. - smoothstep(radius - thickness, radius - thickness + 1.5/iResolution.y, distance(uv, position));\n\n    vec4 finalColor = vec4(color, 1.) * (outer - inner);\n    return finalColor;\n}\n\nvec4 drawFullCircle(vec2 uv, vec2 position, vec4 color, float radius)\n{\n    float circle = 1. - smoothstep(radius, radius + 1.5/iResolution.y, distance(uv, position));\n    return color * circle;\n}\n\nfloat applyFade(vec2 uv, vec2 start, float len, float angle)\n{\n    vec2 rotPoint = len * vec2(cos(angle), -sin(angle)) + start; \n    return step(0., dot(rotPoint, uv - start));\n}\n\nvec4 drawLine(vec2 uv, vec2 start, vec4 color, float thickness, float len, float angle)\n{      \n    vec2 uvHeading = vec2(cos(angle) * (uv.y - start.y), -sin(angle) * (uv.x - start.x));\n    float fn = (1. - smoothstep(thickness, thickness + 1.5/iResolution.y, abs(uvHeading.y - uvHeading.x)));\n    \n    // Handle line start\n    vec2 rotPoint = len * vec2(cos(angle), -sin(angle)) + start;  \n    fn *= step(0., dot(rotPoint, uv - start));\n\n    //Handle line end\n    fn *= 1. - step(len, distance(uv, start));\n    \n    vec4 finalColor = color * fn;\n \n    return finalColor;\n}\n\nvec4 drawScanLine(vec2 uv, vec2 start, vec3 color, float thickness, float len, float angle)\n{  \n    float mapNoise = noiseSmooth((uv + sin(iTime / 20.)) * 15.) * noiseSmooth((uv + sin(iTime / 20.)) * 7.);\n\n    vec2 uvHeading = vec2(cos(angle) * (uv.y - start.y), -sin(angle) * (uv.x - start.x));\n    float fn = (1. - smoothstep(thickness, thickness + 1.5/iResolution.y, abs(uvHeading.y - uvHeading.x)));\n    \n    // Handle line start\n    vec2 rotPoint = len * vec2(cos(angle), -sin(angle)) + start;  \n    fn *= step(0., dot(rotPoint, uv - start));\n\n    // Handle scanner fader\n    float baseFade = dot(normalize(rotPoint), normalize(uv - start));\n    \n    vec2 rotFade = len * vec2(cos(angle + PI/2.), -sin(angle + PI/2.));\n    float maskFade = step(0., dot(normalize(rotFade), normalize(uv - start)));\n    \n    fn += clamp(baseFade - maskFade, 0., 1.) * mapNoise;           \n    fn += mapNoise / 3.;    \n    \n    //Handle line end\n    fn *= 1. - step(len, distance(uv, start));    \n    \n    vec4 finalColor = vec4(color * fn, 1.);\n \n    return finalColor;\n}\n\nvec4 drawLinesGrid(vec2 uv, vec2 start, vec4 color, float thickness, float len)\n{  \n    vec4 finalColor;\n    for (int i = 0; i < LINES_GRID_COUNT; i++)\n    {\n        finalColor += drawLine(uv, vec2(0., 0.), color, thickness, len, float(i) * 2. * PI / float(LINES_GRID_COUNT));\n    }\n    return finalColor;\n}\n\nvec4 drawCirclesGrid(vec2 uv, vec2 position, vec3 color, float radius, float thickness)\n{\n    vec4 finalColor;\n    \n    for (float i = radius; i > 0.; i-= (4. * thickness))\n    {\n        finalColor += drawCircle(uv, position, color, radius - i, thickness);\n    }\n    return finalColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;    \n\n    fragColor = drawCircle(uv, vec2(0., 0.), vec3(0., .9, .3), 0.44, 0.003);\n    \n    // Circle grid\n    fragColor += drawCircle(uv, vec2(0., 0.), vec3(0., .9, .3), 0.35, 0.001);\n    fragColor += drawCircle(uv, vec2(0., 0.), vec3(0., .9, .3), 0.25, 0.001);\n    fragColor += drawCircle(uv, vec2(0., 0.), vec3(0., .9, .3), 0.15, 0.001);\n    fragColor += drawCircle(uv, vec2(0., 0.), vec3(0., .9, .3), 0.05, 0.001);\n    \n    // Lines grid\n    fragColor += drawLinesGrid(uv, vec2(0., 0.), vec4(0., .9, .3, 1.), 0.00005, 0.45);\n    \n    // Scan line\n    fragColor += drawScanLine(uv, vec2(0., 0.), vec3(0., .9, .3), 0.0002, 0.45, iTime*2.);\n    \n    // Center cutout\n    fragColor -= drawFullCircle(uv, vec2(0., 0.), vec4(20., 20., 20., 20.), 0.05);        \n    \n    // Artifacts\n    fragColor -= drawCirclesGrid(uv, vec2(0., 0.), vec3(0., .1, .1), 0.44, 0.002);\n    \n    fragColor += drawFullCircle(uv, vec2(0.1, 0.2), vec4(0., .9, .3, 0.5), 0.005) * max(0.7, sin(iTime*2.+PI/2.)*2.);\n    fragColor += drawFullCircle(uv, vec2(0.0, -0.2), vec4(0., .9, .3, 0.5), 0.005) * max(0.7, sin(iTime*2.-1.2)*2.);\n    fragColor += drawFullCircle(uv, vec2(-0.3, 0.0), vec4(0., .9, .3, 0.5), 0.005) * max(0.7, sin(iTime*2.+PI+0.2)*2.);\n}","name":"Image","description":"","type":"image"}]}