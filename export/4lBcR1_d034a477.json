{"ver":"0.1","info":{"id":"4lBcR1","date":"1536710414","viewed":583,"name":"Octree Travesal","username":"tylerbata","description":"a test of my ray casting algorithm for octrees.  A circle rectangle test is used to simulate the tree.  This was abandoned because of too many issues with floating point precision.  :(","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ERROR 0.001\n#define MAX_STEPS 512.0\n\nfloat min3(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\nfloat max3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nfloat hitBox(vec3 ro, vec3 rd, vec3 box0, vec3 box1, float minMax) {\n\tvec3 pos0 = (box0 - ro) / rd;\n\tvec3 pos1 = (box1 - ro) / rd;\n\tfloat tmin = max3(min(pos0, pos1));\n\tfloat tmax = min3(max(pos0, pos1));\n    \n    float t = (bool(minMax))? tmax : tmin;\n\treturn (tmin < tmax && tmax > 0.0)? t : -1.0;\n}\n\n\n\nfloat rcc(vec4 sph, vec3 x0, vec3 x1) {\n    vec3 s = max(min(sph.xyz,x1), x0);\n    return (distance(sph.xyz, s) < sph.w)? 1.0 : 0.0;\n}\n\n\nvec3 heatMap(float greyValue) {   \n\tvec3 heat;      \n    heat.r = smoothstep(0.5, 0.8, greyValue);\n    if(greyValue >= 0.90) {\n    \theat.r *= (1.1 - greyValue) * 5.0;\n    }\n\tif(greyValue > 0.7) {\n\t\theat.g = smoothstep(1.0, 0.7, greyValue);\n\t} else {\n\t\theat.g = smoothstep(0.0, 0.7, greyValue);\n    }    \n\theat.b = smoothstep(1.0, 0.0, greyValue);          \n    if(greyValue <= 0.3) {\n    \theat.b *= greyValue / 0.3;     \n    }\n\treturn heat;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rd = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\t\n    \n    vec3 ro = vec3(0.35, 0.5, -0.45);\n\t//ro.xz = rotate2d(ro.xz, iTime*0.1);\n\t//rd.xz = rotate2d(rd.xz, iTime*0.1);\n\t\n    vec4 sph = vec4(cos(iTime)*0.25+0.5,0.5,sin(iTime)*0.25+0.5,0.3);\n    \n    vec3 col = vec3(0.0);//rd;\n    \n    \n    /*\n    float t = hitBox(ro, rd, vec3(0.0), vec3(1.0), 0.0);\n    float tMax = hitBox(ro, rd, vec3(0.0), vec3(1.0), 1.0);\n    //if(t > 0.0)col = vec3(t) / 16.0;\n    \n    \n    float lod = 4.0;\n    ro *= lod;\n    t *= lod;\n    tMax *= lod;\n\tvec3 rs = sign(rd);\n\tvec3 dd = 1.0 / abs(rd);\n\tvec3 sd;\n\tvec3 mask;\n    vec3 mapPos = vec3(floor(ro + rd*(t + ERROR)));\n    if(t > 0.0) {\n        \n        col = vec3(tMax) / lod / 8.0;\n        vec3 pos = mapPos / lod;\n        \n        while(t < tMax) { //DDA\n            pos = mapPos / lod;\n            \n\t\t\tif( bool( rcc(sph, pos, pos + 1.0/lod) ) )break;\n\t\t\tsd = (rs * (mapPos - ro + 0.5) + 0.5) *dd;\n\t\t\tmask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n   \t\t\tt = min3(sd);\n\t\t\tmapPos += mask * rs;\n\t\t}\n        \n        if( bool( rcc(sph, pos, pos + 1.0/lod) ) )col = mask;\n        \n    }\n    */\n    \n    \n    \n\n    //(rs * (mapPos - ro + 0.5) + 0.5) *dd;\n    \n    float lod = 2.0;\n    float LOD = 512.0;\n    vec3 rs = sign(rd);\n    vec3 dd = 1.0 / abs(rd);\n    vec3 ri = 1.0 / rd;\n    vec3 sd;\n    vec3 mask;\n    \n    vec3 exitPlane = sign(rd) * 0.5 + 0.5;\n    \n    vec3 sdExit = (exitPlane - ro) * ri;\n    \n    \n    \n    float t = hitBox(ro, rd, vec3(0.0), vec3(1.0), 0.0);\n    //vec3 sdExit = (rs * (vec3(1.0) - ro + 0.5) + 0.5) *dd;\n    float tExit = min3(sdExit);\n    \n    ro *= lod;\n    t *= lod;\n    tExit *= lod;\n    vec3 mapPos = vec3(floor(ro + rd*(t + ERROR)));\n    \n    vec3 sdMax;\n    vec3 pos;\n    \n    \n    \n    \n    \n    if(t > 0.0) {\n        float steps = 0.0;\n        float tMax = tExit;\n        pos = ro + rd*(t + ERROR);\n        mapPos = floor(pos);\n        col = vec3(tMax) / lod / 8.0;\n\n        //while (t + ERROR < tExit) {\n        for(int i = 0; i < 9999; i++) { //while loop error fix\n            if(t+ERROR > tExit)break;\n            steps += 1.0;\n            pos = mapPos / lod;\n            if( bool( rcc(sph, pos, pos + 1.0/lod) ) ) {\n                if(lod < LOD) { //SUB\n                    sdMax = (exitPlane + mapPos - ro) * ri;\n                    tMax = min3(sdMax);\n                    ro *= 2.0;\n                    t *= 2.0;\n                    lod *= 2.0;\n                    tExit *= 2.0;\n                    mapPos = floor( ro + rd*(t + ERROR) );\n                } else { //HIT\n                    break;\n                }\n            } else { //ADV\n                sd = (exitPlane + mapPos - ro) * ri;\n                mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n                t = min3(sd);\n                mapPos += mask * rs;\n                \n                if(t + ERROR > tMax) { //RESTART\n                    ro /= (lod / 2.0);\n                    t /= (lod / 2.0);\n                    tExit /= (lod / 2.0);\n                    tMax = tExit;\n                    mapPos = floor( ro + rd*(t + ERROR) );\n                    lod = 2.0;\n                }\n            }\n            if(steps > MAX_STEPS)break;  \n        }\n        \n        \n        \n        if( bool( rcc(sph, pos, pos + 1.0/lod) ) )col = mod(mapPos, 2.0);\n        \n        \n        col = heatMap(steps / MAX_STEPS);\n\n    }\n    \n    \n    \n    \n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}