{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Simplified version of https://www.shadertoy.com/view/lds3zn\n\n#define M_PI 3.1415926535\n\n//Light setup\nvec3 light = vec3(5.0, 5.0, 5.0);\n\n//Object setup\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0);\n//Functions \n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t//sphere at origin has equation |xyz| = r\n\t//sp |xyz|^2 = r^2.\n\t//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tfloat t;\n\tif(h < 0.0) \n\t\tt = -1.0;\n\telse\n\t\tt = (-b - sqrt(h)); //Again a = 1.\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph )\n{\n\treturn (pos - sph.xyz)/sph.w;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere(ro, rd, sph1); //Intersect with a sphere.\n\t\n\tif(tsph > 0.0)\n\t{\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\treturn id;\n}\n\nmat4 translate(vec3 v) {\n\treturn mat4(1.0, 0.0, 0.0, v.x,\n\t\t\t\t0.0, 1.0, 0.0, v.y,\n\t\t\t\t0.0, 0.0, 1.0, v.z,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n\t\t\t\t0.0, cosTheta, -sinTheta, 0.0,\n\t\t\t\t0.0, sinTheta, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(cosTheta, 0.0, sinTheta, 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t-sinTheta, 0.0, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(cosTheta, -sinTheta, 0.0, 0.0,\n\t\t\t\tsinTheta, cosTheta, 0.0, 0.0,\n\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 mouse0To2PI = iMouse.xy/iResolution.xy*2.0*M_PI;\n\t\n\t//generate a ray with origin ro and direction rd\n\tvec4 ro = vec4(0.0, 0.0, 1.5, 1.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0));\n\t\n\tmat4 rotY = rotateY(mouse0To2PI.x);\n\tmat4 rotX = rotateX(mouse0To2PI.y);\n\tmat4 translateIn = translate(-ro.xyz);\n\tmat4 translateOut = translate(ro.xyz);\n\tmat4 compound = translateIn * rotX * rotY * translateOut;\n\tro *= compound;\n\tlight.xyz = (vec4(light.xyz, 1.0) * compound).xyz;\n\n\t//intersect the ray with scene\n\tfloat t;\n\tfloat id = intersect(ro.xyz, rd, t);\n\t\n\tvec3 col = vec3(0.7); \n\t//Need some lighting and, so, normals.\n\tif(id > 0.5 && id < 1.5)\n\t{\n\t\t//If we hit the sphere\n\t\tvec3 pos = ro.xyz + t*rd;\n\t\tvec3 nor = nSphere(pos, sph1);\n\t\tfloat dif = max(0.0, dot(nor, normalize(light - pos))); //diffuse.\n\t\t\n\t\t//ao = 0.5 * (dot(nor, nPlane(pos)) + 1.0); complete formula. The one above is simplified.\n\t\tcol = vec3(1.0, 1.0, 1.0) * dif + vec3(0.2, 0.2, 0.2);\n\t}\n\t\n\tcol = sqrt(col);\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdXSD8","date":"1400542701","viewed":1857,"name":"Simple Sphere Ray Tracing","username":"slade","description":"A simple ray tracing shader that renders a sphere shape with just a little bit of fancy stuff with the mouse.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["simple","ray","sphere","tracing"],"hasliked":0,"parentid":"","parentname":""}}