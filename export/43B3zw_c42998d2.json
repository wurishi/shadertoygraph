{"ver":"0.1","info":{"id":"43B3zw","date":"1708286437","viewed":78,"name":"A burning memory","username":"int_45h","description":"messing with noise and transition effects","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define MIN_DIST .001\n#define STEPS 80\n#define FOV 60.\n\nfloat dot2(vec2 p){return dot(p,p);}\nfloat dot2(vec3 p){return dot(p,p);}\n\n// From https://iquilezles.org/articles/distfunctions/\nvec2 ud_tri(vec3 p, vec3 a, vec3 b, vec3 c, float id)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  float dist = sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n   return vec2(dist, id);\n}\n\nvec3 v0 = vec3(-1.0,-1.0, 0.0); // bl\nvec3 v1 = vec3( 1.0,-1.0, 0.0); // br\nvec3 v2 = vec3( 1.0, 1.0, 0.0); // tr\nvec3 v3 = vec3(-1.0, 1.0, 0.0); // tl\n\nvec2 get_dist(vec3 p)\n{\n    vec2 t1 = ud_tri(p, v0, v1, v2, 0.5);\n    vec2 t2 = ud_tri(p, v2, v3, v0, 1.5);\n    \n    vec2 tri = (t1.x < t2.x)\n        ? t1\n        : t2;\n        \n    return tri;\n}\n\n//https://learn.microsoft.com/en-us/archive/blogs/rezanour/barycentric-coordinates-and-point-in-triangle-tests\nvec2 get_tri_uv(vec3 P, vec3 p0, vec3 p1, vec3 p2)\n{\n    vec3 E1 = p1-p0;\n    vec3 E2 = p2-p0;\n    vec3 E3 = P-p2;\n    \n    float inv_det = 1./length(cross(E1,E2));\n    return vec2(\n        inv_det*length(cross(E3,E2)),\n        inv_det*length(cross(E3,E1))\n    );\n}\n\nvec3 get_normals(vec3 p)\n{\n    vec2 k = vec2(.01,.0);\n    return normalize(vec3(\n        get_dist(p+k.xyy).x-get_dist(p-k.xyy).x,\n        get_dist(p+k.yxy).x-get_dist(p-k.yxy).x,\n        get_dist(p+k.yyx).x-get_dist(p-k.yyx).x\n    ));\n}\n\nvec3 get_origin(float t)\n{\n    vec3 p1 = vec3(0.,0.,1.2);\n    vec3 p2 = vec3(0.,0.5,-1.);\n    return mix(p1, p2, t);\n}\n\nvec3 get_direction(float t, vec2 uv)\n{\n    vec3 d = normalize(vec3(uv,1.));\n\n    float roll1 = -20.*PI/180.;\n    float roll2 = 0.;\n    \n    vec3 dir1 = vec3(0.,0.,1.);\n    vec3 dir2 = vec3(0.,.2,1.);\n    \n    float r = mix(roll1, roll2, t);\n    vec3 dir = mix(dir1, dir2, t);\n    \n    d *= rot_z(r);\n    d *= look_at(dir);\n    \n    return d;\n}\n\nvec4 raymarch(vec2 uv)\n{\n    vec2 uv2 =(uv*2.-1.)*tan(FOV*PI/180.*.5);\n    uv2.y*=iResolution.y/iResolution.x;\n    \n    float fact = sin((iTime*.2)-PI/2.)*.5+.5;\n    \n    vec3 o = get_origin(fact);\n    vec3 d = get_direction(fact,uv2);\n    float t = 0.;\n    \n    vec4 c = mix(\n        vec4(.3),\n        vec4(.7*(fbm2D(uv*10.+iTime*.02,4)*.5+.5)),\n        d.y\n    );\n    \n    for (int i=0;i<STEPS;i++)\n    {\n        vec3 p = o+d*t;\n        vec2 dist = get_dist(p);\n        t+=dist.x;\n        \n        if (dist.x < MIN_DIST)\n        {\n            if (dist.y < 1.)\n            {\n                vec2 uv_tri = get_tri_uv(p, v1, v2, v0).yx;\n                vec4 s = texture(iChannel0, uv_tri);\n                if (s.a < .001)\n                    continue;\n                c = s;\n                //c = vec4(uv_tri, 0., 0.);\n                break;\n            }\n            else if (dist.y < 2.)\n            {\n                vec2 uv_tri = get_tri_uv(p, v3, v2, v0);\n                vec4 s = texture(iChannel0, uv_tri);\n                if (s.a < .001)\n                    continue;\n                c = s;\n                //c = vec4(uv_tri, 0., 0.);\n                break;\n            }\n            \n            break;\n        }\n    }\n    \n    return c;\n}\n\nvoid transform_img()\n{\n    vec3 s = vec3(1.,iResolution.y/iResolution.x,1.);\n    vec3 o = vec3(0.,0.,2.);\n    v0 = v0*s + o;\n    v1 = v1*s + o;\n    v2 = v2*s + o;\n    v3 = v3*s + o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    transform_img();\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = raymarch(uv);\n    \n    fragColor = color; \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 direction(vec2 s)\n{\n    float t = 2.*PI*hash12(s);\n    return vec2(cos(t), sin(t));\n}\n\nfloat perlin2D(vec2 uv)\n{\n    vec2 uv_grid = floor(uv);\n    vec2 uv_cell = fract(uv);\n    \n    float p0 = dot(direction(uv_grid + vec2(0.,0.)), uv_cell - vec2(0.,0.));\n    float p1 = dot(direction(uv_grid + vec2(0.,1.)), uv_cell - vec2(0.,1.));\n    float p2 = dot(direction(uv_grid + vec2(1.,0.)), uv_cell - vec2(1.,0.));\n    float p3 = dot(direction(uv_grid + vec2(1.,1.)), uv_cell - vec2(1.,1.));\n    \n    uv_cell = uv_cell*uv_cell*(3.-2.*uv_cell);\n    \n    return mix(\n        mix(p0,p2,uv_cell.x),\n        mix(p1,p3,uv_cell.x),\n        uv_cell.y\n    );\n}\n\nfloat fbm2D(vec2 uv, int octaves)\n{\n    float a = 1.;\n    float s = 1.;\n    \n    float n = 0.;\n    \n    for (int i=0;i<octaves;i++)\n    {\n        n += perlin2D(uv*s)*a;\n        a *= .5;\n        s *= 2.;\n    }\n    \n    return n;\n}\n\n// Vignette from https://www.shadertoy.com/view/lsKSWR\nfloat vignette(vec2 uv, float spread, float intensity)\n{\n    vec2 uv_prime = uv*2.-1.;\n    uv *= 1.-uv.yx;\n    \n    float v = uv.x*uv.y*intensity;\n    return pow(v, spread);\n}\n\nfloat screen_dist(vec2 uv)\n{\n    vec2 p = uv*2.-1.;\n    return length(p);\n}\n\nmat3 rot_x(float t)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(t), -sin(t),\n        0., sin(t), cos(t)\n    );\n}\n\nmat3 rot_y(float t)\n{\n    return mat3(\n        cos(t), 0., -sin(t),\n        0., 1., 0.,\n        sin(t), 0., cos(t)\n    );\n}\n\nmat3 rot_z(float t)\n{\n    return mat3(\n        cos(t), -sin(t), 0.,\n        sin(t), cos(t), 0.,\n        0., 0., 1.\n    );\n}\n\nmat3 look_at(vec3 d)\n{\n    vec3 front = normalize(d);\n    vec3 right = cross(front, vec3(0.,1.,0.));\n    vec3 up = cross(right, front);\n    \n    return mat3(right, up, front);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 fbm_transition(vec4 fg, \n                    vec4 bg,\n                    vec4 edge1,\n                    vec4 edge2, \n                    vec2 uv, \n                    float t,\n                    float o1,\n                    float o2)\n{\n    vec2 grid_size = vec2(10.,10.*iResolution.y/iResolution.x);\n    vec2 fbm_uv = uv*grid_size+iTime*.02;\n    \n    float mask = screen_dist(uv);\n    //float mask = 1.-vignette(uv,0.4,30.);\n    float n = fbm2D(fbm_uv, 6)*.5+.5;\n    \n    mask = clamp(mask * n, 0., 1.);\n    \n    vec4 color = fg;\n    t -= o1;\n    \n    if (mask <= (t+o1))\n    {\n        color = mix(edge1, color, (mask-t)/(o1));\n    }\n    if (mask <= (t+o2))\n    {\n        color = mix(edge2, color, (mask-t)/(o2));\n    }\n    if (mask <= t)\n    {\n        color = bg;\n    }\n    \n    return color;\n}\n\nvec4 burn_transition(vec4 fg, vec4 bg, vec2 uv, float threshold)\n{\n    vec4 tween1 = fg * .01;\n    vec4 tween2 = mix(\n        vec4(vec3(242, 137, 39)/255.99,1.),\n        vec4(vec3(242, 98, 41)/255.99,1.),\n        sin(iTime*PI)*.5+.5\n    );\n    \n    float offset1 = .15;\n    float offset2 = .04;\n    \n    return fbm_transition(\n        fg, \n        bg, \n        tween1,\n        tween2, \n        uv, \n        threshold, \n        offset1,\n        offset2\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 fg = texture(iChannel0, uv);//vec4(139, 96, 189, 0)/255.99;\n    vec4 bg = vec4(vec3(.1),0.);//vec4(92, 60, 130, 0)/255.99;\n    //vec4 tween2 = vec4(152, 102, 212, 0)/255.99;\n    \n    float threshold = (cos(iTime*.2+PI)*.5+.5)*1.2;\n    \n    fragColor = burn_transition(\n        fg, \n        bg, \n        uv, \n        threshold\n    );\n}","name":"Buffer A","description":"","type":"buffer"}]}