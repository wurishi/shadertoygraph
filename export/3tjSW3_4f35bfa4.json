{"ver":"0.1","info":{"id":"3tjSW3","date":"1567469152","viewed":260,"name":"Hex Grid Dots","username":"gressettd","description":"Playing with coloring hexagonal grid.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["grid","color","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SQRT3 = 1.73205; \nvec3 TRI30_60_90 = vec3(1.0, SQRT3, 2.0);\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\n\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\n// from https://iquilezles.org/articles/distfunctions2d\nfloat HexagonDistance(vec2 p, float r)\n{\n\tconst vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n\tp = abs(p);\n\tp -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n\tp -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n\treturn length(p)*sign(p.y);\n}\n\n\n// http://glslsandbox.com/e#43182.0\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\nvec4 HexagonGridId(vec2 p, float scale)\n{\n    p *= scale;\n    \n    vec4 center = floor(\n        vec4(p, \n             p - vec2(0.5, 1.0)) / TRI30_60_90.xyxy) + 0.5;\n    \n    vec4 h = vec4(p - center.xy*TRI30_60_90.xy, p - (center.zw + 0.5)*TRI30_60_90.xy);\n    return \n        dot(h.xy, h.xy) < dot(h.zw, h.zw) ? \n        \tvec4(h.xy, center.xy) \n          : vec4(h.zw, center.zw + 9.73);\n\n}\n\n\nvec4 ComputeHexagonGridPattern(vec2 p, float scale, float ccScale)\n{\n    vec4 h = HexagonGridId(p, scale);\n    float hexScale = 1.0/scale;\n    \n    float edgeDistance =  HexagonDistance(h.xy,hexScale);\n    float topo = fract(edgeDistance * ccScale);\n    \n    \n    return vec4(edgeDistance, topo, h.z, h.w);\n}\n\nfloat Map( float range_a_point, float a0, float a1, float b0, float b1 )\n{\n    return (((range_a_point - a0) * (abs(b1-b0)))/abs(a1-a0)) + b0;\n}\n\nfloat Gain(float x, float k) \n{ \n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k); \n    return (x<0.5)?a:1.0-a; \n}\n    \n\nvec4 ComputeHexBlobs(vec2 p, float grade, float scale)\n{\n\tvec4 h = HexagonGridId(p, scale);    \n    grade = clamp(grade,0.0,1.0);\n    grade += 1.2;\n   \n      \n    float cDistance = Gain(\n        clamp((1.0/grade) - (length(h.xy)),0.0,1.0),\n        grade * 0.8) \n        * grade;\n    \n    float blobDistance = cDistance;\n    return vec4(blobDistance, h.zw, pow(cDistance,2.22)); \n    \n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= float(iResolution.y) / float(iResolution.x);\n    uv += vec2(cos(iTime*0.2) + iTime*0.1,iTime * 0.05);\n\n    vec4 cc = ComputeHexBlobs(uv, 1.0 + 0.3*sin(iTime * 2.0), 10.0);\n    \n    \n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n    \n\n\n\tvec4 color;\n   \tcolor=ComputeWaveGradientRGB(Random2D(cc.yz), bias, scale, freq, phase);\n     color *= (cc.x + cc.w);\n    //color *= cc.x;\n    \n    \n    // Output to screen\n    fragColor = vec4(color.xyz,1.0);\n        \n   \n}","name":"Image","description":"","type":"image"}]}