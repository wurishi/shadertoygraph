{"ver":"0.1","info":{"id":"mdVXRh","date":"1680749089","viewed":127,"name":"Binary Array Debugger","username":"myth0genesis","description":"I know this isn't an original idea, but I couldn't seem to find any shaders that display an array of binary values, so I thought I'd put one up.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["binary","antialiasing","branchless","debug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// myth0genesis 2023\n\n// A branchless (except for the ellipse SDF), loopless binary debugger that prints\n// an arbitrary number of uints in binary form\n// Set \"numvals\" below to specify the number of values\n// you wish to debug and assign any uint values to\n// the \"tstval\" array in main().\n\nconst uint numvals = 18U;\n\nconst float ncells = 32.0;\nconst float csz = 1.0 / ncells;\nconst uint MB = 0x1U;\nconst uvec4 shft = uvec4(14U, 15U, 16U, 17U);\n\n// My own bijective 128-bit hash: https://www.shadertoy.com/view/mstXD2\nuvec4 bjhash128(uvec4 p) {\n    p ^= p >> shft;\n    p *= uvec4(0xEAF649A9U, 0x6AF649A9U, 0x050C2D35U, 0xAAF649A9U);\n    p ^= p.yzwx ^ p.zwxy;\n    p ^= p >> shft.yzwx;\n    p *= uvec4(0x21F0AAADU, 0x0D0C2D35U, 0xE8F649A9U, 0xD30332D3U);\n    p ^= p.yzwx ^ p.zwxy;\n    return p ^ p >> shft.wxyz;\n}\n\n// This is iq's SDF for an ellipse: https://www.shadertoy.com/view/4sS3zz\n// Chosen for uniform analytic antialiasing.\nfloat msign(float x) {\n    return (x < 0.0) ? -1.0 : 1.0;\n}\n\nfloat sdEllipse(vec2 p, vec2 ab) {\n\tp = abs(p); \n    if (p.x > p.y) {\n        p = p.yx;\n        ab = ab.yx;\n    }\n\t\n\tfloat l = ab.y * ab.y - ab.x * ab.x;\n\t\n    float m = ab.x * p.x / l; \n\tfloat n = ab.y * p.y / l; \n\tfloat m2 = m * m;\n\tfloat n2 = n * n;\n\t\n    float c = (m2 + n2 - 1.0) / 3.0; \n\tfloat c3 = c * c * c;\n\n    float d = c3 + m2 * n2;\n    float q = d  + m2 * n2;\n    float g = m  + m * n2;\n\n    float co;\n\n    if (d < 0.0) {\n        float h = acos(q / c3) / 3.0;\n        float s = cos(h) + 2.0;\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt(m2 - c * (s + t));\n        float ry = sqrt(m2 - c * (s - t));\n        co = ry + sign(l) * rx + abs(g) / (rx * ry);\n    } else {\n        float h = 2.0 * m * n * sqrt(d);\n        float s = msign(q + h) * pow(abs(q + h), 1.0 / 3.0);\n        float t = msign(q - h) * pow(abs(q - h), 1.0 / 3.0);\n        float rx = -(s + t) - c * 4.0 + 2.0 * m2;\n        float ry = (s - t) * sqrt(3.0);\n        float rm = sqrt(rx * rx + ry * ry);\n        co = ry / sqrt(rm - rx) + 2.0 * g / rm;\n    }\n    co = (co - m) / 2.0;\n\n    float si = sqrt(max(1.0 - co * co, 0.0));\n \n    vec2 r = ab * vec2(co, si);\n\t\n    return length(r - p) * msign(p.y - r.y);\n}\n\nfloat zero(vec2 p, vec2 ab) {\n    float d0 = sdEllipse(p, ab);\n    float d1 = sdEllipse(p, ab - 0.0025);\n    return max(d0, -d1);\n}\n\n// iq's SDF for a box: https://iquilezles.org/articles/distfunctions2d/\nfloat one(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Just returns a specified bit\nuint isltbit(uint x, uint bs) {\n    return MB & (x >> bs);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = vec2(fragCoord.x - 0.5 * iResolution.x, iResolution.y - fragCoord.y) / iResolution.x;\n    vec2 subuv = mod(uv, csz) - 0.5 * csz;\n    vec2 id = floor(vec2(-uv.x + 0.5, uv.y) * ncells);\n    \n    vec2 bin = vec2(zero(subuv, vec2(0.0065, 0.01)), one(subuv, vec2(0.0014, 0.01)));\n    \n    // Just some values thrown in to show how it works.\n    uint tmint0 = uint(iTime);\n    uint tmint1 = floatBitsToUint(floor(iTime));\n    uvec4 hsh0 = bjhash128(uvec4(tmint0, 0U, 0U, 0U));\n    uvec4 hsh1 = bjhash128(uvec4(tmint1, 0U, 0U, 0U));\n    \n    // Here the array of values to be tested are stored.\n    // You can set an arbitrary number of values to check with \"numvals\" above.\n    uint tstvals[numvals];\n    tstvals[0] = tmint0;\n    tstvals[1] = tmint1;\n    tstvals[2] = hsh0.x;\n    tstvals[3] = hsh0.y;\n    tstvals[4] = hsh0.z;\n    tstvals[5] = hsh0.w;\n    tstvals[6] = hsh1.x;\n    tstvals[7] = hsh1.y;\n    tstvals[8] = hsh1.z;\n    tstvals[9] = hsh1.w;\n    tstvals[10] = hsh0.x ^ hsh1.x;\n    tstvals[11] = hsh0.y ^ hsh1.x;\n    tstvals[12] = hsh0.z ^ hsh1.z;\n    tstvals[13] = hsh0.w ^ hsh1.w;\n    tstvals[14] = hsh0.x ^ hsh0.y;\n    tstvals[15] = hsh1.x ^ hsh1.y;\n    tstvals[16] = hsh0.z ^ hsh0.w;\n    tstvals[17] = hsh1.z ^ hsh1.w;\n    \n    float dst = bin[isltbit(tstvals[clamp(uint(id.y), 0U, numvals - 1U)], uint(id.x))];\n    vec3 col = vec3(0.0, 1.0, 0.0);\n    col = ((id.y >= 0.0) && (uint(id.y) < numvals)) ? (col - smoothstep(0.0, 0.002, dst) * vec3(0.0, 1.0, 0.0)) : vec3(0.0);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}