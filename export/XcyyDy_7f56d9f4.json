{"ver":"0.1","info":{"id":"XcyyDy","date":"1732434114","viewed":82,"name":"spaceship to infinity","username":"IVXX","description":"first shader","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","new","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2D rotation function\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// palettes\nvec3 paletteTime(float t)\n{\n    float speed = 0.5; \n    vec3 a = vec3(0.5, .5, .5);\n    vec3 b = vec3(0.5, .5, .5);\n    vec3 c = vec3(1. * sin(iTime / 3.) * speed, 1. * sin(iTime/ 3.) * speed, 1. * sin(iTime/ 3.) * speed);\n    vec3 d = vec3(0.3 * cos(iTime/ 3.) * speed, 0.416 * sin(iTime/ 3.) * speed, 0.557 * sin(iTime/ 3.) * speed);\n\n    return a + b *cos( 6.283185 * ( c*t+d) );\n}\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.5, .5, .5);\n    vec3 b = vec3(0.5, .5, .5);\n    vec3 c = vec3(0.5, 0.5, 0.5);\n    vec3 d = vec3(0., 0.208, 0.2785);\n\n    return a + b *cos( 6.283185 * ( c*t+d) );\n}\n\nvec3 paletteOther(float t)\n{\n    vec3 a = vec3(0.5, .5, .5);\n    vec3 b = vec3(0.5, .5, .5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.3, 0.416, 0.557);\n\n    return a + b *cos( 6.283185 * ( c*t+d) );\n}\n\n// shapes\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n\nfloat sdSpaceShip(vec3 p, float h, vec2 m){\n    float x = m.x;\n    float maxx = 1.;\n    float xscale = 0.075;\n    x = xscale * (x / abs(x)) * min(maxx, abs(x));\n   \n    float y = m.y;\n    float yscale = 0.075;\n    float maxy = 1.;\n    y = yscale * (y / abs(y)) * min(maxy, abs(y));\n    \n    // triangle\t(x , y, z)\n\tvec3 v1 = 1.0*vec3(0.0,0.0,1.0 * h);\n\tvec3 v2 = 1.0*vec3(1.0 * h,0.0,0.5 * h);\n\tvec3 v3 = 1.0*vec3(0.0,0.5 * h,0.0);\n\tfloat d1 = udTriangle( v1, v2, v3, p ) - 0.01;\n\n    // triangle 2 \n\tvec3 v4 = vec3(-1., 1., 1.) * v2;\n\tfloat d2 = udTriangle( v1, v4, v3, p ) - 0.01;\n\n    // triangle 3\n    // moving with the mouse has been removed\n    x = 0.;\n    y = 0.;\n    // causes errors currently\n    vec3 v5 = vec3((0.0 + x) * h, (0.625 + y) * h, 1.5 * h);\n    float d3 = udTriangle( v4, v5, v3, p ) - 0.01;\n    \n    // triangle 4,5,6\n    float d4 = udTriangle( v3, v2, v5, p ) - 0.01;\n    float d5 = udTriangle( v1, v5, v2, p ) - 0.01;\n    float d6 = udTriangle( v1, v5, v4, p ) - 0.01;\n\n    return min(d1,min(d2, min(d3, min(d4, min(d5,d6)))));\n\n}\n\nfloat triangleWave(float frequency, float amplitude) {\n    float t = mod(iTime * frequency, 1.); // Normalize time to [0, 1) based on frequency\n    return amplitude * (2.0 * abs(2.0 * t - 1.0) - 1.0); // Scale to [-amplitude, amplitude]           // Triangle wave pattern\n}\n\nstruct Result {\n    float dist;\n    bool b;\n};\n\n\n// map\nResult map(vec3 p, vec3 p2, vec2 m) {\n    Result r; \n\n    float movespeed = 0.25; \n    p.z += iTime * (4. * movespeed);\n    p.y += iTime * (1. * movespeed);\n    \n    vec3 q = p;\n    float spacingX = 1.15;\n    float spacingY = .35;\n    float spacingZ = 0.5;\n    \n    q.x = mod(p.x, spacingX) - spacingX/2.;\n    q.y = mod(p.y, spacingY) - spacingY/2.;\n    q.z = mod(p.z, spacingZ) - spacingZ/2.;\n   \n    float sphereDist = sdSphere(q, .15);\n    \n    // Spaceship\n    float frequency = 0.9;\n    float wiggle = 0.0015 * cos(iTime * 30.);\n    vec3 spaceshipPos = vec3(wiggle, -.35 + (0.05 * (1. - cos(iTime * frequency))), -1.25 - (0.75 *(1. - cos(iTime * frequency))));\n    float spaceshipDist = sdSpaceShip(p2 - spaceshipPos, 0.25, m); \n   \n    if (spaceshipDist < sphereDist) {\n        r.dist = spaceshipDist;\n        r.b = true;\n    } else {\n        r.dist = sphereDist;\n        r.b = false;\n    }\n    return r;\n}\n\nfloat gradientmap(vec3 p, vec2 m){ //edge detector only applied to the spaceship\n\n    // Spaceship\n    float frequency = 0.9;\n    float wiggle = 0.0015 * cos(iTime * 30.);\n    vec3 spaceshipPos = vec3(wiggle, -.35 + (0.05 * (1. - cos(iTime * frequency))), -1.25 - (0.75 *(1. - cos(iTime * frequency)))); \n    \n    return sdSpaceShip(p - spaceshipPos, 0.25, m);\n\n}\n\n\nvec3 gradient(vec3 pos, float dist, vec2 m) {\n        \n    float eps = 0.1;\n    float dx = gradientmap(vec3(pos + vec3(eps, 0., 0.)), m) - dist;\n    float dy = gradientmap(vec3(pos + vec3(0., eps, 0.)), m) - dist;\n    float dz = gradientmap(vec3(pos + vec3(0., 0., eps)), m) - dist;\n    \n    return normalize(vec3(dx,dy,dz));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2  m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    if (iMouse.z <= 0.) m = vec2(0);\n\n    \n    // initialize \n    int steplimit = 80;\n    vec3 rayorigin = vec3(0,0,-3);\n    \n    float raycamerafrequency = 0.;\n    float cameramove = max(1., triangleWave(0.45,1.) + 1.);\n    cameramove = 1.0; // doesnt work \n    \n    vec3 raydirection = normalize(vec3(uv * cameramove, 1));\n    vec3 col = vec3(0);\n\n    float totaldistance = 0.;\n    int i;\n    for (i = 0; i < steplimit; i++){\n        vec3 position = rayorigin + (raydirection * totaldistance);\n        vec3 position2 = position;\n \n        float rotationfrequency = .35;\n        position.xy *= rot2D(totaldistance * rotationfrequency);\n \n        Result result = map(position, position2, m);\n    \n        if (result.b == true) {\n            //float edge = length(gradient(position2, result.dist, m));\n            //col = vec3(edge);\n            col = mix(vec3(1., 1., 1.), vec3(.05, .05, .05), totaldistance * 0.01 + float(i) * 0.0125);\n        } else if (result.b == false) {\n            col = palette(totaldistance * 0.05 + float(i) * 0.015); // Sphere color palette\n        }\n    \n        totaldistance += result.dist;\n    \n        if (result.dist < .001 || totaldistance > 75.) break; // early stopping\n    }\n\n    // Output to screen\n    fragColor = vec4(col * 1., 1.0);\n}","name":"Image","description":"","type":"image"}]}