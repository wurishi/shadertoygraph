{"ver":"0.1","info":{"id":"NsKSWD","date":"1634815070","viewed":175,"name":"Cocoa vs Cream","username":"ax","description":"a design exercise using Moroz's great fluid sim shadertoy (https://www.shadertoy.com/view/WtfyDj)","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["particles","fluidsim"],"hasliked":0,"parentid":"WtfyDj","parentname":"Paint streams"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat border(vec2 p) {\n\n  float bound = -sdBox(p - iResolution.xy * 0.5, iResolution.y * vec2(0.45 * visible));\n  \n  float drain0 = -sdBox(p - iResolution.xy * 0.5, iResolution.x * vec2(2.0, 0.05));\n  float drain1 = -sdBox( Rot(0.5 * PI) * (p - iResolution.xy * 0.5), iResolution.x * vec2(2.0, 0.05));\n  float drain  = max(drain0, drain1);\n  \n  float X0 = sdBox( Rot( 0.25 * PI) * (p - iResolution.xy * 0.5), iResolution.x * vec2(0.01, 0.05));\n  float X1 = sdBox( Rot(-0.25 * PI) * (p - iResolution.xy * 0.5), iResolution.x * vec2(0.01, 0.05));\n  float X  = min(X0, X1);\n\n  return min(max(drain, bound), X);\n\n}\n\n#define h 1.\n\nvec3 bN(vec2 p) {\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvec3 mixN(vec3 a, vec3 b, float k) {\n  return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\n\nvec4 V(vec2 p) {\n  return texture(iChannel2, p/iResolution.xy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n  ivec2 ifxy = ivec2(fragCoord);\n  if ( skip(ifxy, iResolution.xy, vec2(visible)) ) {\n    fragColor = vec4(0.0 * vec3(0.8, 0.682, 0.533), 1.0);\n    return;\n  }\n\n  time = 0.1 * iTime;\n\n  vec4 pcData = texelFetch( iChannel1, ifxy, 0 );\n  PiC  pc     = decodePiC( pcData, fragCoord );\n    \n  //border render\n  vec3    Nb = bN(pc.X);\n  float bord = smoothstep(1.0 * border_h, border_h * 0.25, border(fragCoord));\n    \n  vec4 rho  = texture( iChannel2, fragCoord/iResolution.xy );\n  vec3 dx   = vec3(-2., 0., 2.);\n  vec4 grad = -0.5 * vec4(V(fragCoord + dx.zy).zw - V(fragCoord + dx.xy).zw,\n                          V(fragCoord + dx.yz).zw - V(fragCoord + dx.yx).zw);\n  vec2 N    = pow(length(grad.xz),0.2) * normalize(grad.xz+1e-5);\n    \n  float specular  = pow(max(dot(N, Dir(1.4)), 0.), 1.25);\n  float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n  float   a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n  float   b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n\n  vec3 col0 = vec3(0.95, 0.9, 0.8);  // Creme\n  vec3 col1 = vec3(0.24, 0.13, 0.1);  // Cocoa\n\n  vec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.5))*0.5 + 0.5);\n    \n  // Output to screen\n  fragColor = vec4(3.);\n  fragColor.xyz = mixN(fragColor.xyz, fcol.xyz*(1.5*b + specular * 2.5), a);\n  fragColor.xyz = mixN(tanh(fragColor.xyz), 1. * vec3(0.8, 0.682, 0.533), bord);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// a fluidsim artwork created while studying Moroz's fluid code\n//\n// fluid sim code based on 'Paint streams'\n// by Michael Moroz\n// (https://www.shadertoy.com/view/WtfyDj)\n//\n\n#define PI 3.14159265\n#define dt 0.5\n#define border_h 5.\n#define fluid_rho 0.5\n#define visible 0.9\n//#define MASS 1.0\n\n\nfloat time;\n\nmat2 Rot(float ang) {\n  return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang) {\n  return vec2(cos(ang), sin(ang));\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n// Checks if a node should be processed or not\n//\nbool skip(ivec2 p, vec2 res, vec2 ratio) {\n  ivec2  c = ivec2(0.5 * res);                 // Center \n  ivec2  r = ivec2(0.5 * ratio * vec2(res.y)); // valid region radius\n  ivec4 ok = ivec4(c - r, c + r);\n  if (p.x < ok.x || p.x > ok.z) return true;\n  if (p.y < ok.y || p.y > ok.w) return true;\n  return false;\n}\n\n\n// Data compression\n//\nuint pack(vec2 v) {\n  v = 65534.0 * clamp(0.5 * v + 0.5, 0., 1.);\n  return uint(round(v.x)) + 65535u * uint(round(v.y));\n}\n\nvec2 unpack(uint ui) {\n  vec2 v = vec2(ui % 65535u, ui / 65535u);\n  return clamp(v/65534.0, 0., 1.) * 2. - 1.;\n}\n\nvec2 decode(float x) {\n  uint ui = floatBitsToUint(x);\n  return unpack(ui); \n}\n\nfloat encode(vec2 v) {\n  uint ui = pack(v);\n  return uintBitsToFloat(ui); \n}\n\n\n// Particle-in-Cell struct and functions\n//\nstruct PiC {\n  vec2 X;\n  vec2 V;\n  vec2 M;\n};\n    \nPiC decodePiC(vec4 pcData, vec2 pos) {\n  PiC    pc; \n  pc.X = decode(pcData.x) + pos;\n  pc.V = decode(pcData.y);\n  pc.M = pcData.zw;\n  return pc;\n}\n\nvec4 encodePiC(PiC pc, vec2 pos) {\n  pc.X = clamp(pc.X - pos, vec2(-0.5), vec2(0.5));\n  return vec4(encode(pc.X), encode(pc.V), pc.M);\n}\n\n\nfloat Pf(vec2 rho) {\n//    return 0.2*rho.x; //gas\n    float GF = 1.;  //smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5 * rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\n\nfloat G(vec2 x) {\n  return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x) {\n  return exp(-length(x));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Momentum Exchange\n//\n// Computes per-particle physical quantity change due to Advection\n// \n// Per-cell delta is written to BufferA (iChannel0)\n//\n\nvec3 distribution(vec2 x, vec2 p, float k) {\n  vec2 omin = clamp(x - 0.5 * k, p - 0.5, p + 0.5);\n  vec2 omax = clamp(x + 0.5 * k, p - 0.5, p + 0.5); \n  return vec3( 0.5 * (omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(k*k) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  ivec2 ifxy = ivec2(fragCoord);\n  if ( skip(ifxy, iResolution.xy, vec2(visible)) ) {\n    fragColor = vec4(0.0);\n    return;\n  }\n\n  PiC delta;\n\n  for (int y = -2; y < 2; y++) {\n    for (int x = -2; x < 2; x++) {\n\n      vec2    nxy = fragCoord + vec2(x,y);    // neighbour xy (position)\n      vec4 npData = texelFetch(iChannel1, ivec2(nxy), 0);\n    \n      PiC npc  = decodePiC(npData, nxy);  // neighbor PiC\n      npc.X   += npc.V * dt;              // integrate position\n\n      float difR = 0.9 + 0.21 * smoothstep(fluid_rho * 0., fluid_rho * 0.333, npc.M.x);\n      vec3  D    = distribution(npc.X, fragCoord, difR);\n      // the deposited mass into this cell\n      float m    = npc.M.x * D.z;\n        \n      // add weighted by mass\n      delta.X   += D.xy * m;\n      delta.V   += npc.V * m;\n      delta.M.y += npc.M.y * m;\n        \n      // add mass\n      delta.M.x += m;\n\n    }\n  }\n    \n  // normalization\n  if (delta.M.x != 0.0) {\n    delta.X   /= delta.M.x;\n    delta.V   /= delta.M.x;\n    delta.M.y /= delta.M.x;\n  }\n  \n  fragColor = encodePiC(delta, fragCoord);\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// particle Pos (BufferB)\n//\n\nfloat border(vec2 p) {\n\n  float bound = -sdBox(p - iResolution.xy * 0.5, iResolution.y * vec2(0.45 * visible));\n  \n  float drain0 = -sdBox(p - iResolution.xy * 0.5, iResolution.x * vec2(2.0, 0.05));\n  float drain1 = -sdBox( Rot(0.5 * PI) * (p - iResolution.xy * 0.5), iResolution.x * vec2(2.0, 0.05));\n  float drain  = max(drain0, drain1);\n  \n  float X0 = sdBox( Rot( 0.25 * PI) * (p - iResolution.xy * 0.5), iResolution.x * vec2(0.01, 0.05));\n  float X1 = sdBox( Rot(-0.25 * PI) * (p - iResolution.xy * 0.5), iResolution.x * vec2(0.01, 0.05));\n  float X  = min(X0, X1);\n\n  return min(max(drain, bound), X);\n\n}\n\n\n#define h 1.\nvec3 bN(vec2 p) {\n  vec3  dx = vec3(-h,0,h);\n  vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n  vec3 r = idx.zyw * border(p + dx.zy)\n         + idx.xyw * border(p + dx.xy)\n         + idx.yzw * border(p + dx.yz)\n         + idx.yxw * border(p + dx.yx);\n  return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvoid runSim(sampler2D ch, inout PiC pc, vec2 fxy) {\n\n  vec2 F    = vec2(0.);  // SPH force\n  vec3 avgV = vec3(0.);\n\n  for (int y = -2; y <= 2; y++) {\n    for (int x = -2; x <= 2; x++) {\n    \n        vec2  npcPos  = fxy + vec2(x,y);\n        vec4  npcData = texelFetch(ch, ivec2(npcPos), 0);        \n        PiC   npc     = decodePiC(npcData, npcPos);\n\n        float avgP    = 0.5 * npc.M.x * (Pf(pc.M) + Pf(npc.M)); \n        vec2  dx      = npc.X - pc.X;\n        \n        F    -= 0.5 * G(1.0 * dx) * avgP * dx;\n        avgV += npc.M.x * G(1.0 * dx) * vec3(npc.V, 1.0);\n        \n    }\n  }\n    \n  avgV.xy /= avgV.z;\n\n  // Viscosity ?\n  F += 0.2 * pc.M.x * (avgV.xy - pc.V);\n    \n  // Rotating + Oscillating Gravity\n  F += pc.M.x * Rot(time) * vec2(0., -0.002 + 0.0005 * sin(time * 0.03));\n\n  // integrate\n  pc.V += F * dt / pc.M.x;\n\n  // Obstacles\n  vec3 N = bN(pc.X);\n  float vdotN = step(N.z, border_h) * dot(-N.xy, pc.V);\n  pc.V += 0.5 * (N.xy * vdotN + N.xy * abs(vdotN));\n  pc.V += 0.0 * pc.M.x * N.xy * step(abs(N.z), border_h) * exp(-N.z);\n    \n  if (N.z < 0.) pc.V = vec2(0.);\n    \n  // Velocity constraint\n  float v = length(pc.V);\n  pc.V /= (v > 1.) ? v : 1.0;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  ivec2 ifxy = ivec2(fragCoord);\n  if ( skip(ifxy, iResolution.xy, vec2(visible)) ) {\n    fragColor = vec4(0.0);\n    return;\n  }\n\n  time  = 0.1 * iTime;\n \n  // This CELL\n  vec4 pcData = texelFetch(iChannel0, ifxy, 0);\n  PiC  pc      = decodePiC(pcData, fragCoord);\n    \n  // runSim if cell not empty\n  if (pc.M.x != 0.0) runSim( iChannel0, pc, fragCoord );\n \n  // Non-overlapping fluid sources\n  float basicSize = 0.028 * iResolution.y;\n  if (length(pc.X - iResolution.xy * vec2(0.6, 0.5)) < basicSize * (1.0 + 0.6 * sin(5.3 * time)) ) {\n\n    pc.X = fragCoord;\n    pc.V = 0.5 * Dir(-PI * 1.0 + 1.2 * sin(0.4 * time));\n    pc.M = mix(pc.M, vec2(fluid_rho, 1.0), 0.5);\n\n  } else if (length(pc.X - iResolution.xy * vec2(0.4, 0.5)) < basicSize * (1.0 + 0.6 * sin(7.1 * time)) ) {\n\n    pc.X = fragCoord;\n    pc.V = 0.5 * Dir(-PI * 0.0 + 1.2 * sin(0.5 * time));\n    pc.M = mix(pc.M, vec2(fluid_rho, 1.0), 0.5);\n\n  } else if (length(pc.X - iResolution.xy * vec2(0.5, 0.3)) < basicSize * (1.0 + 0.6 * sin(6.7 * time)) ) {\n\n    pc.X = fragCoord;\n    pc.V = 0.5 * Dir(PI * 0.5 + 0.3*sin(0.6 * time) );\n    pc.M = mix(pc.M, vec2(fluid_rho, 0.0), 0.5);\n\n  } else if (length(pc.X - iResolution.xy * vec2(0.5, 0.7)) < basicSize * (1.0 + 0.6 * sin(4.7 * time)) ) {\n\n    pc.X = fragCoord;\n    pc.V = 0.5 * Dir(PI * 1.5 + 0.3*sin(0.7 * time) );\n    pc.M = mix(pc.M, vec2(fluid_rho, 0.0), 0.5);\n\n  }\n  \n  fragColor = encodePiC( pc, fragCoord );\n\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Compute density\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  ivec2 ifxy = ivec2(fragCoord);\n  if ( skip(ifxy, iResolution.xy, vec2(visible)) ) {\n    fragColor = vec4(0.0);\n    return;\n  }\n\n  vec4 pcData = texelFetch( iChannel1, ifxy, 0 );\n  PiC  pc     = decodePiC( pcData, fragCoord );\n    \n  vec4 rho = vec4(0.0);\n\n  for(int i = -1; i <= 1; i++) {\n    for(int j = -1; j <= 1; j++) {\n      \n      vec2 nPos    = fragCoord + vec2(i,j);\n      vec4 npcData = texelFetch(iChannel1, ivec2(nPos), 0);\n      PiC  npc     = decodePiC( npcData, nPos );\n\n      rho += 1. * vec4(npc.V, npc.M) * G((fragCoord - npc.X)/0.75);\n        \n    }\n  }\n    \n  fragColor = rho;\n\n}","name":"Buffer C","description":"","type":"buffer"}]}