{"ver":"0.1","info":{"id":"DtGXR1","date":"1685981578","viewed":31,"name":"Basic shader helper functions","username":"TastelessPledge","description":"From tutorial by: https://www.youtube.com/watch?v=f4s1h2YETNY\nTutorial creator: https://www.shadertoy.com/user/kishimisu\n\nhttps://iquilezles.org/\nhttps://graphtoy.com/\nhttp://dev.thi.ng/gradients/ from article: https://iquilezles.org/articles/palettes/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["basic","tutorial","fractals","explained","helper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159\n\n// Shapes\n// Basic: https://iquilezles.org/articles/distfunctions2d/\n// Cut-up: https://iquilezles.org/articles/distgradfunctions2d/\n// Gradient: https://iquilezles.org/articles/distgradfunctions2d/\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    // Test values: http://dev.thi.ng/gradients/\n    // Each value = vec3(red, green, blue)\n    \n    // a: y-Offset\n    // b: Amp\n    // c: Frequency\n    // d: x-Offset (phase)\n    \n    // Oscilates c times with phase of d\n    // Scaled and biased by a and b for ccontrast and brightness\n    // If palette needs to cycle over 0..1 exactly make c = [int] * 0.5\n    // For continuity make c = [int]\n    return a + b*cos( 2.0*PI *(c*t+d) );\n}\n\nvec3 usePalette(float t) {\n    // Test values: http://dev.thi.ng/gradients/\n    vec3 a = vec3(0.5, 0.5, 2.0);\n    vec3 b = vec3(0.5, 0.2, 0.5);\n    vec3 c = vec3(2.0, 3.0, 1.0);\n    vec3 d = vec3(1.358, 0.5, 0.5);\n    \n    return palette(t, a, b, c, d);\n}\n\n// !!! Very useful for testing:\n// Applies one value to the left half of the screen and another to the right side so you can see the difference side by side.\nfloat halfScreenValuePicker(float x, float leftVal, float rightVal) {\n    if (x < iResolution.x / 2.0) {\n        return leftVal;\n    }\n    return rightVal;\n}\n\n// Range canvas from -0.5 to 0.5\nvec2 centeredNormCanvas(vec2 fragCoord) {\n    return (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n}\n\nvec2 addSpatialRepetion(vec2 uv, float scale) {\n    return fract(uv * scale) - 0.5;\n}\n\n// pointOriginal: value of point when initilized\nfloat pointDistanceCurved(vec2 point, vec2 pointOriginal) {\n    return length(point) * exp(-length(pointOriginal));\n}\n\nfloat sinRings(float d, float t, float speed, float width) {\n    return sin(d*speed + t)/width;\n}\n\nfloat glow(float d, float intensity, float contrast) {\n    return pow(intensity / d, contrast);\n}\n\nvec3 scaleColorWithDistance(vec3 col, float d) {\n    return col * d;\n}\n\nvec3 invert(vec3 v) {\n    return vec3(1.0) - v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Range canvas from -0.5 to 0.5\n    vec2 uv = centeredNormCanvas(fragCoord);\n    // Original uv\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    // Iterate to create layers\n    // Increase limit to add more layers\n    for (float i = 0.0; i < 3.0; i++) {\n        // Add spatial repetion\n        // Non-int scalar for patterns\n        // -0.5 lines fract up with middle\n        uv = addSpatialRepetion(uv, 1.8);\n    \n        // Distance from center with slight curve added\n        float d = pointDistanceCurved(uv, uv0);\n        \n        // Rings changes with each iteration\n        vec3 col = usePalette(length(uv0) + i*1.5 + iTime*0.4);\n        \n        // Repeating rings in different phases with scalable with\n        d = sinRings(d, iTime, 8., 8.);\n        \n        // Inside also gives positive \n        d = abs(d);\n        \n        // Glow intensity, second: contrast\n        d = glow(d, 0.013, 2.);\n        \n        // Glow changes with distance\n        finalColor += scaleColorWithDistance(col, d);\n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}