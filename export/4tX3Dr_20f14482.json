{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float t = 16.0;//nr. sample per pixel\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[4];\nBox boxe[15];\nCylinder cylinder[4];\n//Material material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 cub, lcub;\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time;\nfloat f0, f1,f2,f3;\nvec2 cw = vec2(-0.4,0.1);\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {\n  \tvec2 r = rand2();\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( 1.0-r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y-cylinder.c.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\t/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}*/\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    //nor.y = 1.0*sign(hit.y-cylinder.c.y);\n    return nor;\n}\n\nvoid initscene()\n{\n    box0.min = vec3(-1.5, -1.2, -2.0);//room\n   \tbox0.max = vec3( 1.5,  1.2,  2.0);\n    \n    light = vec3(-0.0, 1.7, 0.6);\n\n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde\n   \tsfere[2].center_radius = vec4(0.0, -0.9,1.3,    0.5);//albastru\n    sfere[3].center_radius = vec4(light,    0.05);//albastru\n\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \t/*float tSphere = intersectSphere(ro, rd, sfere[0]);\n    if(tSphere < t) { t = tSphere;i=0;}\n   \ttSphere = intersectSphere(ro, rd, sfere[1]);\n    if(tSphere < t) { t = tSphere;i=1;}*/\n   \tfloat tSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n\n}\n\nvoid shadow(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \tfloat tSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n    \n    vec2 tRoom = intersectCube(ro, rd, box0);          \n   \tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    vec3 hit = ro + rd * t;  \n    if(hit.y > 0.9999 && hit.x<1.3 && hit.x>-1.3 && hit.z<1.99 && hit.z>1.0) t=10000.0;\n\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n\t\tmref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        if(normal.x>0.0)\n        { \n            mcol.xyz = vec3(0.95,0.05,0.05);\n        } \n        else if(normal.x<0.0)\n        { \n            mcol.xyz = vec3(0.05,0.95,0.05);\n        } \n\t}     \n\telse   \n\t{\n        \t if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==6) {normal = normalForSphere(hit, sfere[3]); mcol = vec4(0.9,0.9,0.9,10.0); mref = vec2(0.0,0.0);}\n    }  \n}\n\nvec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)\n{\n   vec3 color = vec3(0.0);\n   int id = -1;\n   i = false;\n   //vec3 toLight = (lightf-hit);\n   //float sqdist = dot(toLight,toLight);\n   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);\n   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;\n \n   if(diffuse>0.0)\n   {\n      float ldist =distance(lightf,hit);// sqrt(sqdist);\n      float sh = 1000.0;//distance(lightf,hit);\n      shadow(hit + normal * 0.0001, L, sh, id, true);           \n      if(sh>ldist)\n         {color += cl * (diffuse/(ldist))*0.32; i = true;}\n   }\n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n        vec3 hit = ro + rd * t;  \n        if(hit.y > 0.9999 && hit.x<1.3 && hit.x>-1.3 && hit.z<1.99 && hit.z>1.0) t=10000.0;\n    \n    \tintersectscene(ro, rd, t, id, true);\n    \n    \thit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.99),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.00001;\n         \n        vec2 rnd = rand2();\n        col *= mcol.xyz;\n       /* if(mcol.w>0.0) \n        {\n            if(i==0) {color = mcol.xyz; break;}\n            float df=max(dot(rd,-normal),0.0)*2.0; //if(tm==1) df *= 19.0;\n            color += col*mcol.xyz*mcol.w * df ;\n            //if(tm==1) color += col * 1.5;\n            break;\n        }*/\n\t\ttm = -1;\n        //if(rnd.x>abs(mref.x))//diffuse\n        {\n        \t//rd = CosineWeightedSampleHemisphere ( normal, rnd); \n            rd = cosWeightedRandomHemisphereDirection(normal);\n        \ttm = 0;   \n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0);\n            \n            bool isLight = false;\n            vec3 rnd = vec3(rand2(),rand2().x)*2.0-1.0;\n\n         \tvec3 lightf = light + rnd * sfere[3].center_radius.w;\n         \tvec3 dl = directLight(hit, normal, lightf, vec3(1.0,1.0,1.0), isLight);\n         \tcolor += col * dl*9.0;\n         \t//if(isLight) break;\n        }       \n        \n        ro = hit + rd * 0.0001; \n        \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n    \n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 3.0*cos(8.0*mo.x), -0.9 + 2.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time *= 0.2;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    //ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(-0.4,-0.8, 1.0); ta = vec3(-0.4,-0.8, 1.5);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.45) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tX3Dr","date":"1420663304","viewed":354,"name":"Scene bleeding","username":"predatiti","description":"This is a test of Reinder scene, to test color \"bleeding\". Is not like in reinder scene but i quess my render is corect because code is verified in time and i make test scene in different comercial render programs and the render is the same as my.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""}}