{"ver":"0.1","info":{"id":"dtVSWG","date":"1686334375","viewed":45,"name":"Psylocyborg","username":"kydenwilson","description":"A trippy shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["trippy","neon","rhombus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Credit to:\n//https://iquilezles.org/articles/\n//For the signed distance functions\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 4;\n\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n//https://iquilezles.org/articles/palettes/\nvec3 colorPallete( float t )\n{\n    vec3 a = vec3(-0.382, 0.968, 0.368);\n    vec3 b = vec3(-0.222, 1.258, -0.812);\n    vec3 c = vec3(2.398, 1.678, 2.758);\n    vec3 d = vec3(-0.092, 0.228, -0.312);\n\n    return a + b* cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 -iResolution.xy)/iResolution.y;    \n    \n    \n    //Define and Get the distance from the hidden rhombus\n    vec2 hiddenRhombus = vec2(99.0,99.0);\n    float distanceFromHiddenRhombus = abs(sdRhombus(uv,hiddenRhombus));\n    \n    //Define And Rotate The MainRhombus\n    float rhombusSize = iTime*0.02+1.0;\n    float theta = (iTime/10.0) - ((sin(iTime/10.0))*(distanceFromHiddenRhombus/20.0));\n    theta += distanceFromHiddenRhombus;\n    \n    float rhombusX1 = rhombusSize * cos(theta);\n    float rhombusY1 = rhombusSize * sin(theta);\n    \n    float rhombusX2 = rhombusSize * cos(theta+1.57079);\n    float rhombusY2 = rhombusSize * sin(theta+1.57079);\n    \n    //Define The MainRhombus Vectors\n    vec2 rhombusL = vec2(-rhombusX1, rhombusY1);\n    vec2 rhombusR = vec2(rhombusX1, -rhombusY1);\n    \n    vec2 rhombusU = vec2(rhombusX2, -rhombusY2);\n    vec2 rhombusD = vec2(-rhombusX2, rhombusY2);\n    \n    vec2[] rhombus = vec2[](rhombusL, rhombusU, rhombusR, rhombusD);\n    \n    vec3 finalColor = vec3(0.0,0.0,0.0);\n    vec2 fractalUV = uv;\n    \n    float uvLen = length(uv);\n    \n    for(float i = 0.0; i < 4.0; i++)\n    {\n        //Get The distance from the Mainrhombus\n        fractalUV = fract(fractalUV*(1.7 * (uvLen*0.7))) - 0.5;\n        float d = sdPolygon(fractalUV, rhombus);\n\n        //Normalize the distance\n        d = abs(sin(d*15.0)/(i+1.0));\n        //d = abs(sin(d));\n\n        //Change The Intensity Based on the Distance From the Rhombus\n        float colorIntensity = ((0.08*(3.0*(i+1.0)))/d) * (0.6/(length(uv)*2.0));\n        colorIntensity = pow(colorIntensity, 0.9);\n        // Time varying pixel color\n        //vec3 color = colorPallete(d + (length(fractalUV)*2.0) + (length(uv)*2.0) + i + iTime);\n        //vec3 color = colorPallete((sin(iTime/10.0)*d) + (uvLen * cos(iTime/10.0)) + ((i+1.0)*10.0)+(iTime/6.0));\n        vec3 color = colorPallete((sin(iTime/3.0)*d+d)*(uvLen+uvLen*cos(iTime/3.0))*((i+1.0)*(iTime/1000.0)*10.0)+(iTime/6.0));\n        color *= (colorIntensity/10.0) * (0.12/uvLen); \n        finalColor += color;\n        \n    }\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}