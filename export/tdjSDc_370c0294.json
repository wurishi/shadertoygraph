{"ver":"0.1","info":{"id":"tdjSDc","date":"1648783074","viewed":65,"name":"Ray Marching Lighting Test","username":"koi","description":"An old ray marching experiment. Drag the mouse around to move the camera.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","lighting","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 screenToViewport(vec2 coord) {\n    return (2.0*coord - iResolution.xy) / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = screenToViewport(fragCoord);    \n    vec2 mouse = screenToViewport(iMouse.xy);\n    \n    vec3 camPos = vec3(0.0, 0.0, -1.0);\n    vec3 camRot = vec3(-mouse.yx * PI, 0.0);\n    vec3 sunPos = normalize(vec3(1.0, 0.9, -0.6));\n    \n    vec3 ro = rotate(camPos, camRot);\n    vec3 rd = rotate(normalize(vec3(coord * tan(FOV / 2.0), 1.0)), camRot);\n    \n    //float d = raycast(ro, rd);\n    \n    vec3 col = vec3(1.0, 0.5, 1.0); // background colour\n\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS && d < MAX_RAY_DISTANCE; i++) {\n        vec3 pos = ro + rd * d;\n        \n        SdfInfo sdfInfo = sdf(pos);\n        float sd = sdfInfo.sd;\n        \n        if(sd < SDF_THRESHOLD) {            \n            switch(sdfInfo.id) {\n                case 0:\n                \tcol = vec3(1.0, 0.0, 0.0);\n                \tbreak;\n                case 1:\n                    col = vec3(0.0, 1.0, 0.0);\n                    break;\n            }\n            \n        \tvec3 normal = findNormal(pos);\n            \n\t\t\t// diffuse shading\n            float lfac = dot(sunPos, normal);\n            col *= max(lfac, 0.0)*0.5+0.5;\n            \n            // shadow rays\n            vec3 t = pos + normal * (SDF_THRESHOLD*2.0 - sd);\n            float srd = 0.0;\n            bool isInside = true;\n            for(int j = 0; j < MAX_SHADOW_STEPS && srd < MAX_SHADOW_RAY_DISTANCE; j++) {   \n                float ssd = sdf(t + sunPos*srd).sd;\n                srd += ssd;\n                \n                if(ssd < SDF_THRESHOLD) {\n                    if(!isInside) {\n                        col *= 0.5;\n                        break;\n                    }\n                } else {\n                    isInside = false;\n                }\n            }\n            \n            break;\n        }\n        \n        d += sd;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\nconst int MAX_STEPS = 1000;\nconst float MAX_RAY_DISTANCE = 100.0;\n\nconst int MAX_SHADOW_STEPS = 100;\nconst float MAX_SHADOW_RAY_DISTANCE = 10.0;\n\nconst float SDF_THRESHOLD = 0.0001;\nconst float NORMAL_EPSILON = 0.000001;\n\nconst float FOV = 2.0;\n\nstruct SdfInfo {\n    float sd;\n    int id;\n};\n\nvec3 rotate(vec3 p, vec3 e) {\n    mat3 Z = mat3(cos(e.z), sin(e.z), 0.0, -sin(e.z), cos(e.z), 0.0, 0.0, 0.0, 1.0);\n    mat3 Y = mat3(cos(e.y), 0.0, sin(e.y), 0.0, 1.0, 0.0, -sin(e.y), 0.0, cos(e.y));\n    mat3 X = mat3(1.0, 0.0, 0.0, 0.0, cos(e.x), sin(e.x), 0.0, -sin(e.x), cos(e.x));\n    return Z*Y*X*p;\n}\n\nfloat box(vec3 c, vec3 s){\n    vec3 ac = abs(c) - s;\n    return length(max(ac, 0.0)) + min(max(max(ac.x, ac.y), ac.z), 0.0);\n}\n\nfloat sphere(vec3 c, float r) {\n    return length(c) - r;\n}\n\nSdfInfo sdf(vec3 c) {\n    float sdBox = max(-sphere(c, 0.28), box(c, vec3(0.22)));\n    float sdFloor = c.y+0.22;\n    \n    float sd = sdBox;\n    int id = 0;\n    \n    if(sdFloor < sd) {\n        sd = sdFloor;\n        id = 1;\n    }\n    \n    return SdfInfo(sd, id);\n}\n\nvec3 findNormal(vec3 c) {\n    vec2 h = vec2(NORMAL_EPSILON, 0.0);\n    return normalize(vec3(\n        sdf(c + h.xyy).sd - sdf(c - h.xyy).sd,\n        sdf(c + h.yxy).sd - sdf(c - h.yxy).sd,\n        sdf(c + h.yyx).sd - sdf(c - h.yyx).sd\n    ));\n}","name":"Common","description":"","type":"common"}]}