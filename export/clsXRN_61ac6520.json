{"ver":"0.1","info":{"id":"clsXRN","date":"1719257421","viewed":57,"name":"Analytic Atmosphere (WIP)","username":"Tech_","description":"a","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    TODO: Calculate air number density based on temperature and pressure.\n    (https://physics.stackexchange.com/questions/232822/how-do-you-calculate-the-number-density-of-air-at-300k)\n*/\nconst float airNumberDensity = 2.54743; // [10^25 * m^-3]\n\n/* \n    Precomputed rayleigh coefficients using Eq. (1) from\n    https://augerlal.lal.in2p3.fr/pmwiki/uploads/Bucholtz.pdf\n    See \"scripts/atmosphere/atmosphereProperties.jl\" for details.\n*/\nconst float rayleighScatteringCoeff680nm = 5.8892198451829474e-6;\nconst float rayleighScatteringCoeff550nm = 1.3786965797162954e-5;\nconst float rayleighScatteringCoeff440nm = 3.3737659465668514e-5;\n\nconst vec3 rayleighScatteringCoeff = vec3(8.059375432e-06, 1.671209429e-05, 4.080133294e-05);\nconst vec3 rayleighAbsorptionCoeff = vec3(0.0);\n\nconst vec3 mieScatteringCoeff = vec3(3.996e-6);\nconst vec3 mieAbsorptionCoeff = vec3(4.4e-6);\n\n// https://ozonewatch.gsfc.nasa.gov/facts/ozone.html\nconst float ozoneConcentration = 6.0e-6; // [m^-3]\n\n// http://www.iup.physik.uni-bremen.de/gruppen/molspec/databases/referencespectra/o3spectra2011/index.html\nconst float ozoneCrossSection680nm = 1.36820899679147;\nconst float ozoneCrossSection550nm = 3.31405330400124;\nconst float ozoneCrossSection440nm = 0.13601728252538;\n\nconst float ozoneNumberDensity = airNumberDensity * ozoneConcentration;\nconst float ozoneAbsorptionCoeff680nm = ozoneCrossSection680nm * ozoneNumberDensity;\nconst float ozoneAbsorptionCoeff550nm = ozoneCrossSection550nm * ozoneNumberDensity;\nconst float ozoneAbsorptionCoeff440nm = ozoneCrossSection440nm * ozoneNumberDensity;\n\nconst vec3 ozoneAbsorptionCoeff = vec3(ozoneAbsorptionCoeff680nm, ozoneAbsorptionCoeff550nm, ozoneAbsorptionCoeff440nm);\n\nconst mat2x3 scatteringCoeffs = mat2x3(rayleighScatteringCoeff, mieScatteringCoeff);\nconst mat3 absorptionCoeffs = mat3(rayleighAbsorptionCoeff, mieAbsorptionCoeff, ozoneAbsorptionCoeff);\n\nconst float earthRadius = 6360.0e3; // [m]\nconst float atmosphereTopRadius = 6460.0e3; // [m]\n\n#define rcp(x) (1.0 / (x))\n#define max0(x) max(0.0, x)\n#define EPS 1e-6\n\nvec3 EvaluateLSICurve(vec3 x, float l, float s, float i)\n{\n    vec3 a = pow(x / l, vec3(2.0 * rcp(s)));\n    return i * pow(a / (a + 1.0), vec3(0.5 * s)) + (1.0 - i);\n}\n\n#define tonemapConfiguration TONEMAP_CINEMATIC\nvec3 TonemapPrism(vec3 color)\n{\n    /*\n        Custom parameterized tone.\n        Can yield a variety of different desired looks.\n\n        ~ Tech\n    */\n\n    const mat2x3 TONEMAP_CINEMATIC = mat2x3(\n        0.301020, 1.37, 0.95,\n        0.376284, 1.62, 1.00\n    );\n\n    const mat2x3 TONEMAP_NEUTRAL = mat2x3(\n        0.325, 1.0, 0.3,\n        0.813, 1.0, 1.0\n    );\n\n    vec3 toe       = EvaluateLSICurve(color, tonemapConfiguration[0][0], tonemapConfiguration[0][1], tonemapConfiguration[0][2]);\n    vec3 shoulder  = EvaluateLSICurve(color, tonemapConfiguration[1][0], tonemapConfiguration[1][1], tonemapConfiguration[1][2]);\n\n    return toe * shoulder;\n}\n\nvec3 LinearTosRGB(vec3 x)\n{\n    vec3 sRGBLo = x * 12.92;\n    vec3 sRGBHi = pow(abs(x), vec3(1.0 / 2.4)) * 1.055 - 0.055;\n    return mix(sRGBHi, sRGBLo, step(x, vec3(0.0031308)));\n}\n\nfloat IntersectSphere(vec3 rayPos, vec3 rayDir, float radius)\n{\n    float b = dot(rayPos, rayDir);\n    float c = dot(rayPos, rayPos) - radius * radius;\n\n    if (c > 0.0 && b > 0.0) return -1.0;\n\n    float d = b * b - c;\n\n    if (d < 0.0)    return -1.0;\n    if (d > b * b)  return -b + sqrt(d);\n\n    return -b - sqrt(d);\n}\n\nconst float PI          = acos(-1.0);\nconst float INV_PI      = 1.0 / PI;\nconst float TAU         = 2.0 * PI;\nconst float INV_TAU     = 1.0 / TAU;\nvec3 EquirectangularToView(vec2 coord)\n{\n    coord = coord * TAU - PI; \n    \n    float theta  = coord.x;\n    float phi    = coord.y * 0.5;\n    float cosPhi = cos(phi);\n    \n    return vec3(\n        cosPhi * cos(theta),\n        sin(phi)           ,\n        cosPhi * sin(theta)\n    );\n}\n\nconst float rayleighHeightScale = 8.0e3;\nconst float mieHeightScale = 1.2e3;\n\nfloat PhaseRayleighChandrasekhar(float cosTheta, float depolarizationFactor)\n{\n    float gamma = depolarizationFactor / (2.0 - depolarizationFactor);\n    return 3.0 / (16.0 * PI * (1.0 + 2.0 * gamma)) * ((1.0 + 3.0 * gamma) + (1.0 - gamma) * cosTheta * cosTheta);\n}\n\n/* e (energy parameter) ~3600 for atmosphere / ~2600 for clouds */\nfloat PhaseNishinaKlein(float cosTheta, float e) \n{\n    return e / (TAU * log(1.0 + 2.0 * e) * (-e * cosTheta + e + 1.0));\n}\n\nfloat PhaseIsotropic()\n{\n    return rcp(4.0 * PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec3 rL = normalize(vec3(cos(iTime * 0.4), sin(iTime * 0.4), 0.0));\n    \n    vec3 rD = EquirectangularToView(uv);\n\n    float VdotL  = dot(rD, rL);\n    float thetaZ = rD.y;\n\n    float earthDist              = IntersectSphere(vec3(0.0, earthRadius + 1.0, 0.0), rD, earthRadius);\n    \n    // if (earthDist < 0.0)\n    if (true)\n    {\n        const float ozoneTotalD = 876.240540213;\n    \n        const float rayleighT   = 1.6946 * rayleighHeightScale;\n        const float rayleighD   = rcp(1.6946);\n\n        float atmosphereDistRayleigh = IntersectSphere(vec3(0.0, earthRadius + 1.0, 0.0), rD, earthRadius + rayleighT);\n        float maxRayDepthRayleigh = earthDist > 0.0 ? earthDist : atmosphereDistRayleigh;\n        \n        float depthRatioRayleigh     = atmosphereDistRayleigh / rayleighT;\n        \n        float phaseRayleigh = PhaseRayleighChandrasekhar(VdotL, 2.842e-2);\n        float rayleighZ         = maxRayDepthRayleigh;\n        vec3 rayleighExtinction = rayleighD * rayleighScatteringCoeff\n                                + (mieHeightScale / rayleighT) * (mieScatteringCoeff + mieAbsorptionCoeff)\n                                + (ozoneTotalD / rayleighT) * ozoneAbsorptionCoeff;\n        /*vec3 scatteringRayleigh = rL.y * rayleighScatteringCoeff / rayleighExtinction\n                                * (1.0 - exp(-rayleighExtinction * rayleighZ * (rL.y + rcp(depthRatioRayleigh)) / rL.y))\n                                / (rL.y + rcp(depthRatioRayleigh));\n                                \n        vec3 scatteringRayleighMulti = scatteringRayleigh * exp(-1.0);\n        scatteringRayleighMulti      = scatteringRayleighMulti / (1.0 - min(vec3(1.0 - EPS), scatteringRayleighMulti));\n\n        const float mieT        = 1.6946 * mieHeightScale;\n        const float mieD        = rcp(1.6946);\n        \n        float atmosphereDistMie = IntersectSphere(vec3(0.0, earthRadius + 10.0, 0.0), rD, earthRadius + mieT);\n        float depthRatioMie     = atmosphereDistMie / mieT;\n        \n        float phaseMie          = PhaseNishinaKlein(VdotL, 3600.0);\n        float mieZ              = atmosphereDistMie;\n        vec3 mieExtinction      = mieD * (mieScatteringCoeff + mieAbsorptionCoeff)\n                                + (rayleighHeightScale / mieT) * rayleighScatteringCoeff\n                                + (ozoneTotalD / mieT) * ozoneAbsorptionCoeff;\n        vec3 scatteringMie      = rL.y * mieScatteringCoeff / mieExtinction\n                                * (1.0 - exp(-mieExtinction * mieZ * (rL.y + rcp(depthRatioMie)) / rL.y))\n                                / (rL.y + rcp(depthRatioMie));*/\n                                \n        vec3 scatteringRayleigh = rayleighScatteringCoeff / rayleighExtinction * (1.0 - exp(-rayleighExtinction * rayleighZ));\n\n        col += scatteringRayleigh * phaseRayleigh;\n    }\n\n    fragColor = vec4(LinearTosRGB(TonemapPrism(col * 0.4e1)), 1.0);\n}","name":"Image","description":"","type":"image"}]}