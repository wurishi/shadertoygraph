{"ver":"0.1","info":{"id":"4fcyW7","date":"1730772343","viewed":76,"name":"CapsuleTileIntersection","username":"ShadingKnight","description":"Use sdf for capsule culling.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lightculling"],"hasliked":0,"parentid":"Mfffzn","parentname":"SpotLightTileIntersection"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TILE_SIZE 32.0\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat map( in vec3 pos )\n{\n    pos.y += 0.4;\n    pos.xy = (mat2(4,3,-3,4)/5.0) * pos.xy;\n    vec3  capA = vec3(-0.3, 0.05 + 0.4 * sin(4.0 * iTime),-0.45 + 0.2 * cos(1.5 * iTime));\n    vec3  capB = vec3(0.3 + 0.3 * cos(3.0 * iTime), 0.45 + 0.3 * sin(2.5 * iTime), -0.4);\n    const float capR = 0.25;\n\n    return sdCapsule(pos, capA, capB, capR);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    const float tmax = 18.0;\n    vec2 o = vec2(-0.5, -0.5);\n    vec3 tot = vec3(0.0);\n    {\n        vec2 p = (2.0 * (floor(fragCoord / TILE_SIZE) * TILE_SIZE + o) - iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        \n        // ray differentials\n        vec2 pTop = (2.0 * ((floor(fragCoord / TILE_SIZE) + vec2(0.0, -1.0)) * TILE_SIZE + o) - iResolution.xy)/iResolution.y; \n        vec2 pRight = (2.0 * ((floor(fragCoord / TILE_SIZE) + vec2(1.0, 0.0)) * TILE_SIZE + o) - iResolution.xy)/iResolution.y; \n        vec3 rdTop = normalize( pTop.x*uu + pTop.y*vv + 1.5*ww );\n        vec3 rdRight = normalize( pRight.x*uu + pRight.y*vv + 1.5*ww );\n        \n        // raymarch\n        float t = 0.0;\n        for( int i = 0; i < 16; i++)\n        {\n            vec3 pos = ro + t * rd;\n            vec3 posTop = ro + t * rdTop;\n            vec3 posRight = ro + t * rdRight;\n            posTop += distance(pos, posTop) * rdTop;\n            posRight += distance(pos, posRight) * rdRight;\n            float offset = max(distance(pos, posTop), distance(pos, posRight));\n            float h = map(pos);\n            if(h < offset || t>tmax ) break;\n            t += h;\n        }\n        \n        vec3 col = vec3(0.0);\n        if( t>= tmax )\n        {\n            vec3 pos = ro + t * rd;\n            tot += vec3(0.2,0.3,0.4);\n        }\n    }\n    \n    {\n        // pixel coordinates\n        vec2 p = (2.0*(fragCoord +o)-iResolution.xy)/iResolution.y; \n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 normal = calcNormal(pos);\n            tot += 0.3 * dot(normalize(vec3(0.0, -1.0, 0.5)), normal) + vec3(0.2,0.3,0.4);\n            tot += vec3(0.5);\n        }\n    }\n    \n    // grid\n    if (uint(fragCoord.x) % uint(TILE_SIZE) == 0u\n    || uint(fragCoord.y) % uint(TILE_SIZE) == 0u)\n    {\n        tot = vec3(1.0, 1.0, 1.0);\n    }\n\n\tfragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}