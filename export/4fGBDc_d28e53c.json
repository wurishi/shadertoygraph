{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//Reference\n// https://www.shadertoy.com/view/sd2GDD\n// https://www.youtube.com/watch?v=GQ5Rup-Njso\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  vec3 offset = vec3(0, 0, -2);\n  return length(p - offset) - r;\n}\n\nfloat map(vec3 p) {\n  return sdSphere(p, 2.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = map(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    float r = 1.;\n    return normalize(\n      e.xyy * map(p + e.xyy) +\n      e.yyx * map(p + e.yyx) +\n      e.yxy * map(p + e.yxy) +\n      e.xxx * map(p + e.xxx));\n}\n\nvec3 colorMap(float t) {\n  float f[4] = float[4](0.1, 0.60, 0.9, 1.0);\n  vec3 c[4] = vec3[4](vec3(0.8196, 0.4667, 0.3255), vec3(0.9529, 0.6, 0.3451), vec3(0.992,0.729,0.455), vec3(0.9804, 0.8902, 0.7686));\n  for(int i = 0; i < 4; i++) {\n    if(t < f[i]) return c[i];\n  }\n\n}\n\n// iq's 3D noise function\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvec3 noise3(vec3 x) {\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\t noise(x+vec3(.11,47.43,19.17)),\n\t\t\t\t noise(x) );\n}\n\nvec3 fbm(vec3 p) {\n  vec3 f = vec3(0);\n  f += 0.5000*noise3(p); p = p*2.02;\n  f += 0.2500*noise3(p); p = p*2.03;\n  f += 0.1250*noise3(p); p = p*2.01;\n  f += 0.0625*noise3(p);\n  return f;\n}\nfloat drawSphere(in vec3 p){   \n    p = fract(p)-.5;    \n    \n    return dot(p, p);\n}\nint cellTileID(in vec3 p){\n    \n    int cellID = 0;\n    \n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    vec3 d = (vec3(.75)); // Set the maximum.\n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    return cellID;\n    \n}\n\nuint cube_8( in vec3 nor ) // 3:2:2:1\n{\n    vec3 mor; uint  id;\n                                    mor = nor.xyz; id = 0u;\n    if( abs(nor.y) > abs(mor.x) ) { mor = nor.yzx; id = 1u; }\n    if( abs(nor.z) > abs(mor.x) ) { mor = nor.zxy; id = 2u; }\n    uint is = (mor.x<0.0)?1u:0u;\n    vec2 uv = 0.5 + 0.5*mor.yz/abs(mor.x);\n    uvec2 iuv = uvec2(round(uv*vec2(7.0,3.0)));\n    return iuv.x | (iuv.y<<3u) | (id<<5u) | (is<<7u);\n}\nvec3 i_cube_8( uint data )\n{\n    uvec2 iuv = uvec2( data, data>>3u ) & uvec2(7u,3u);\n    vec2 uv = vec2(iuv)*2.0/vec2(7.0,3.0) - 1.0;\n    uint is = (data>>7u)&1u;\n    vec3 nor = vec3((is==0u)?1.0:-1.0,uv.xy);\n    uint id = (data>>5u)&3u;\n         if(id==0u) nor = nor.xyz;\n    else if(id==1u) nor = nor.zxy;\n    else            nor = nor.yzx;\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  vec3 rd = normalize(vec3(uv, -1));\n\n  float d = rayMarch(ro, rd);\n\n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * d;\n    vec3 normal = calcNormal(p);\n    //normal compression, pseudo, decrease level of normal using round\n    float n = 8.;\n    vec3 cellN = i_cube_8(cube_8(normal + fbm(p*10.)*0.3));\n    \n    vec3 noiseN = normalize(normal + fbm(p*10.)*0.5);\n    vec3 lp = vec3(4.*sin(iTime), 4.*cos(iTime*0.7), 2.);\n    vec3 ld = normalize(lp - p);\n    float diff = max(0., dot(noiseN, ld));\n    float spec = pow(max(0., dot(reflect(-ld, cellN), -rd)), 2.);\n    col = colorMap(diff);\n    int cellId = cellTileID(p*2.+fbm(p*10.)*0.9);\n    col *= mix(float(cellId) / 4., 1., 0.8+diff*0.2);\n    col *= 1.+spec*0.2;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n//* Note \n//! Currently use strong diffuse for metalic object which might not be accurate.","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fGBDc","date":"1734510137","viewed":73,"name":"Realistic Anime Metal","username":"Nekodigi","description":"Stylized yet realistic rusted material. It could look like stone or dirt but I call it a rusted metal for now.\nBased on this tutorial https://www.youtube.com/watch?v=GQ5Rup-Njso.","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["metal","material","cell","anime","realistic"],"hasliked":0,"parentid":"","parentname":""}}