{"ver":"0.1","info":{"id":"fltczX","date":"1660242030","viewed":73,"name":"2022-08-11-silmämuna","username":"leonarven","description":"20min exercise","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["exercise"],"hasliked":0,"parentid":"7tcczf","parentname":"2022-08-11-miukusilmä"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// @see https://www.shadertoy.com/view/4dS3Wd\n\n// @see Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013 @see https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n// ----------------------------------------------\n\n#define PI 3.1415926535\n\n#define OCTAVES 10\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 1.5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * abs( noise(st) - noise(-st*2.) );\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n\nvec3 eye_back_palette( float x, vec3 base) {\n\n    x += 127.;\n    x *= 11.;\n       \n    float dv = length( sin( x * 10. + base ) + sin(10. * (x * sin( base / 2.0 )) + base) + sin( sqrt( 100. * x + 1. ) + base ));\n \n    vec3 col = clamp( vec3( abs( sin( dv * PI ))*.7, abs( sin( dv * PI + 2. * PI / 3.)), abs( sin( dv * PI + 4. * PI / 3. ))), 0.0, 1.0 );\n    \n    return (col * base) / max(max(base.r,base.g),base.b);\n}\n\nvec3 eye( in float a, in float r, in vec2 uv, in bool frontside ) {\n\n    vec3 col = vec3(1);\n    \n    if (frontside) {\n        if (r < .3) {\n\n            // mykiö\n            return vec3(0);\n\n        } else if (r < 1.) {\n        \n            col = vec3(0);\n\n            // Värikalvo  \n            col += vec3( eye_back_palette( ( a + sin( noise( vec2(11.*a, r * 6.) )) / PI / 6. ) / (2.*PI), (vec3(96,49,1) / 255.) ) / 2. );\n\n            // Sisäsyrjän vaalea rengas\n            vec3 innr = vec3(119,142,64)/140. * (1. + sin(  noise( 123. + vec2( uv.x, uv.y ) * 6. )));\n\n            col += sqrt(innr) * max( 0., ((1. - (r + noise(vec2(a)) * .1) ) - .45) );           \n\n            // Vaaleita alueita ympäriinsä\n            col += (noise(vec2(a, r)*3.) + .5) / 5.;\n\n            // Vaaleita ja tummia pisteitä ympäriinsä\n            //col -= clamp( pow( (noise(vec2(a, r*.3)*40.)), 3.), -1., 0. );\n\n            // Tummia pisteitä ympäriinsä\n            col -= pow( (noise(vec2(a, r)*40.)), 2.) / 4.;\n\n            // Värikalvon sisäsyrjän gradientti mykiön mustaan\n            if (r < .325) col -= (1. - (r - .3) * 40.);\n\n            // Värikalvon ulkosyrjän tummentuva gradientti\n            if (r > .7) col *= cos( 7. * (r - .7) + ( noise(vec2(a / PI) * .10 ) ));\n\n            if (r < .95) return col;\n\n            // Värikalvon ulkosyrjän gradientti valkuaiseen\n            col = vec3( (r-.95) * 20. );\n        }\n    }\n    \n    \n    float blood = 1.2-fbm(vec2(r,a));\n    \n    blood *= blood*blood*blood*blood;\n\n    // valkuainen, jossa on verisuonia\n    \n    if (frontside) blood *= .2;\n    else blood = mix( 0.,blood,clamp(r-.4,0.,1.) );\n\n    col -= vec3(0,1,1) * blood;\n\n    // Häivytetään verta ulkosyrjällä\n    col = mix( col, vec3(1), pow( max(0., r-1. ), 2. ));\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 raycast( vec3 ro, vec3 rd) {\n    float dist = 0.;\n    \n    vec3 rp = ro;\n    \n    float radius = .5;\n    \n    for (int i = 0; i < 20; i++) {\n    \n        rp = ro + rd * dist;\n        \n        float _dist = distance( rp, vec3(0,0,0) ) - radius;\n\n        if (abs( _dist ) <= 0.001) {\n\n            /* silmä */\n            vec3 nor = normalize( rp - vec3(0,0,0) );\n\n            vec2 uv = nor.yz / .45;\n\n            float r = length( uv ); // [ 0, 1 ]\n\n            float a = atan(uv.y, uv.x) + PI; // [ 0, 2PI ]\n\n            return eye( a, r, uv, nor.x > 0. );\n            /* EOS silmä */\n            \n        } else {\n            dist += _dist;\n        }\n    }\n    \n    vec3 bg = vec3(135, 206, 235) / 255.;\n    vec3 col = bg;\n\n    if (rd.y <= -0.0001) {\n\n        vec2 fp = ro.xz + (-(ro.y + 1.) / rd.y) * rd.xz;\n\n\n\n        //col = vec3(cos(fp.x)/.2+.5, sin(fp.y)/.2+.5, 0.);\n        //col += vec3( int(fp.x) ^ int(fp.y) );\n        \n        col  = vec3(0,.4,0);\n        col += vec3(0,.5,0) * (sqrt(sqrt(fbm( fp.xy )))) / 5.;\n        col += vec3(0,.3,0) * (sqrt(sqrt(fbm( -fp.xy )))) / 5.;\n        \n            \n        col = mix( col, bg, min( 1., max( 0., (1. + rd.y * 2.5) * 1.1 )) );\n\n\n    //    if (rd.y > -.01) col +=  vec3( rd.y*-100. );\n\n\n\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat time = 32.0 + iTime*5.5;\n\n\n    vec3 trgPos = vec3(0,0,0);\n    vec3 camPos = trgPos + vec3( 4.5*cos(0.1*time), 1.3, 4.5*sin(0.1*time) ) * ( .6 + sin(time*.1 - PI/2.) / 5. );\n\n    mat3 camMat = setCamera( camPos, trgPos, 0.0 );\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 rd = camMat * normalize( vec3( p, 2.5 ) );\n\n    vec3 col = raycast( camPos, rd );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}