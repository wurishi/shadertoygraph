{"ver":"0.1","info":{"id":"llGcWD","date":"1536356777","viewed":223,"name":"Normal Using Derivative","username":"lgabriel13","description":"Calculating the normal of one or more spheres/planes using multi-variable derivatives","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","normal","derivative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//In the last couple of weeks i've been taking a look on some calculus and i've came up with the idea\n//of calculating the normals of a SDF map calculating the derivatives \"old school\", without recalculating \n//the map function six times.\n\n//I don't know how useful this might be for you, because if the map function \n//is complicated the derivative will be pretty hard (if not impossible) to be calculated.\n//But just for the sake of this demo I'm going to use the derivative (i'm only using a sphere and a plane which equations are easy to be derived).\n\n//Knowing that we are dealing with a sphere of radius r and positionated at (a, b, c) in world space that has the equation:\n//f(x,y,z) = (x-a)^2 + (y-b)^2 + (c-z)^2 - r^2;\n//It's gradient (derivative on all axis) is given by:\n//df/dx * i + df/dx * j + df/dz * k where i,j,k are the unit basis vectors of our world space\n//or in its vector form: [df/dx, df/dy, df/dz]\n//Differentiation on each axis is pretty simple: we are treating the dimensions that are not \n//derivied as scalars =>\n//grad(f) = [2*(x-a), 2*(y-b), 2*(z-c)] - gradient of a sphere\n\n//This also applies for a plane\n//f(x,y,z) = x * n.x + y * n.y + z * n.z - n.w;\n//grad(f) = [n.x, n.y, n.z]\n\n//PS: i don't know if this is the best implementation.\n\n//Return derivative (0 means that we hit a sphere while 1 means that we hit a plane)\nvec3 GetDerivative (vec3 point, int objType, vec3 n)\n{\n    //Sphere (defined at a position a,b,c with radius r)\n    //Function: f(x,y,z) = (x-a)^2 + (y-b)^2 + (z-c)^2 - r^2\n    //Derivative grad f(x,y,z) = [2(x-a), 2(y-b), 2(y-c)] \n    //In our case point is already x-a, y-b, z-c\n  \tif (objType == 0)    \n    \treturn normalize (2.0 * point);\n    \n    //Plane (defined by a normal and a distance\n    //Function: f(x,y,z) = dot (p, n.xyz) + n.w\n    //Derivative grad f(x,y,z) = [n.x, n.y, n.z]\n    if (objType == 1)\n        return n;\n        \n    \n    return vec3 (1.0, 0.0, 0.0);\n}\n\n\nvec3 GetNormal (vec3 point, int objType, vec3 n)\n{           \n    //An usual way of computing the gradient of our map is using the central difference.\n    //Another cool way is using the thetradeon technique\n    //For more infos you might want to read IQ's article about computing normals\n    //https://iquilezles.org/articles/normalsSDF\n    /*\n    vec3 normal = vec3 \n        (\n            MapSdf (vec3 (point.x + EPSILON, point.y, point.z)) - MapSdf (vec3 (point.x - EPSILON, point.y, point.z)),\n            MapSdf (vec3 (point.x, point.y + EPSILON, point.z)) - MapSdf (vec3 (point.x, point.y - EPSILON, point.z)),\n            MapSdf (vec3 (point.x, point.y, point.z + EPSILON)) - MapSdf (vec3 (point.x, point.y, point.z - EPSILON))\n        );\n    \n    return normalize (normal);*/\n    \n    //Get derivative of this object at x,y,z, with the necesary infos\n    return GetDerivative (point, objType, n);    \n}\n\n//Simple illumination\nvec3 GetColor (vec3 hitPoint, vec3 eyePos, Object objHit)\n{\n    //Create a simple light\n    vec3 lightPosition = vec3 (25.0, 25.0, -25.0);\n    vec3 lightColor = vec3 (0.6, 0.2, 0.2);\n    \n    vec3 lightToPointDir = normalize (vec3 (lightPosition - hitPoint));\n    vec3 lightDir = normalize (lightPosition);\n    \n    //Now we will need the normal\n    vec3 normal = GetNormal (objHit.position, objHit.type, objHit.n);\n    \n    //NdotL clamped\n    float nDotL = clamp (dot (normal, lightToPointDir), 0.0, 1.0);\n    \n    //I will use an albedo color for spheres and another one for the plane\n    vec3 albedo = objHit.type == 0 ? vec3 (0.7, 0.1, 0.2) : vec3 (0.2, 0.3, 0.6);\n        \n    //Get shadow\n    float shadow = GetShadow (hitPoint, lightDir, 0.01, MAX_DIST, iTime);\n        \n    //Very simple diffuse        \n\treturn albedo * lightColor * nDotL * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //Set up camera\n    float aratio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 originalUv = uv;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= aratio;\n    \n    vec3 lookAt = vec3 (1.5, -0.5, 0.0);\n    vec3 up = vec3 (0.0, 1.0, 0.0);\n    vec3 origin = vec3 (0.0, 0.5, -7.0);\n    float zoom = 2.0;\n\t\n    //Get ray\n \tRay currentRay = CreateRay (uv, lookAt, up, origin, zoom);                  \n    \n    Object objHit;   \n    vec2 raymarchResult = RayMarch (currentRay, MIN_DIST, MAX_DIST, objHit, iTime);\n    if (raymarchResult.x > MAX_DIST - EPSILON)\n    {\n        fragColor = GetBackgroundColor (originalUv, iTime);\n        return;\n    }\n    \n    \n    //We hit something\n    vec3 color = GetColor (currentRay.origin + currentRay.dir * raymarchResult.x, origin, objHit);    \n    \n    //Gamma\n    fragColor = pow (vec4 (color, 1.0), vec4 (1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STEPS 256\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\n//Struct that helps us to pass the needed data and the hit object\nstruct Object\n{\n    vec3 position; //position\n    vec3 n; //for the plane we will also need the normal\n  \tint type; //type - 0 = sphere 1 = plane\n    float dist;\n};\n\n//Ray\nstruct Ray\n{\n\tvec3 dir;\n    vec3 origin;\n};\n  \n   \n//SDF functions\nfloat PlaneSDF (vec3 p, vec4 n )\n{  \n  return dot(p,n.xyz) + n.w;\n}\n\nfloat SphereSDF (vec3 p, float r)\n{\n \treturn length (p) - r;   \n}\n\n//Union that also returns the object hit data\nfloat Union (Object a, Object b, out Object objectHit)\n{\n    if (a.dist < b.dist)\n    {\n        objectHit.position = a.position;\n        objectHit.n = a.n;\n        objectHit.type = a.type;        \n    } else \n    {\n    \tobjectHit.position = b.position;    \n        objectHit.n = b.n;\n        objectHit.type = b.type;        \n    }\n        \n\tobjectHit.dist = min (a.dist,b.dist);\t\n    \n    return objectHit.dist;\n}\n\n//Map sdf (needed time parameter because i can't access it in Common)\nfloat MapSdf (vec3 p, out Object objectHit, float time)\n{\n    //Sphere 1\n    Object sphere_01;\n    sphere_01.position = p - vec3 (0.0, 1.0 + sin (time * 0.25), 0.0);\n    sphere_01.dist = SphereSDF (sphere_01.position, 0.6);    \n    sphere_01.type = 0;\n    \n    //Sphere 2\n    Object sphere_02;    \n    sphere_02.position = p - vec3 (cos (time) * 2., .8, sin (time) * 2.);\n    sphere_02.dist = SphereSDF (sphere_02.position, 0.4);      \n    sphere_02.type = 0;\n    \n    //Plane\n    Object plane;\n    plane.n = vec3 (0.0, 1.0, 0.0);\n    plane.position = p;\n    plane.dist = PlaneSDF (p, vec4 (0.0, 1.0, 0.0, 1.0));\n    plane.type = 1;      \n     \n   \tfloat res = Union (sphere_01, sphere_02, objectHit);    \n   \tres = Union (objectHit, plane, objectHit);   \n    \n    return res;\n}\n\nvec2 RayMarch (Ray ray, float minDist, float maxDist, out Object objHit, float time)\n{\n    vec2 ret = vec2 (0.0, 0.0);\n\tfloat depth = minDist;    \n    for (int i=0; i<STEPS; i++)\n    {\n\t\tfloat dist = MapSdf (ray.origin + ray.dir * depth, objHit, time);\n        \n        if (dist<EPSILON)\n        {\n        \tret.x = depth;   \n            break;\n        }\n             \n        depth += dist;\n        \n        if (dist >= maxDist)\n        {\n            ret.x = depth;\n\t\t\tbreak;\n        }\n    }\n    \n    ret.x = clamp (ret.x, minDist, maxDist);\n    return ret;\n}\n\n//Get camera matrix\nmat3 GetCameraMatrix (vec3 lookAt, vec3 up, vec3 origin)\n{\n\tvec3 f = normalize (lookAt - origin);\n    vec3 l = normalize (cross (f, up));\n    vec3 u = normalize (cross (l, f));\n    \n    return mat3 (l, u, -f);\n}\n\n//Create ray\nRay CreateRay (vec2 uv, vec3 lookAt, vec3 up, vec3 origin, float zoom)\n{\n    Ray newRay;\n    newRay.origin = origin;\n    mat3 cameraMatrix = GetCameraMatrix (lookAt, up, origin);\n    newRay.dir = cameraMatrix * normalize (vec3 (uv.xy, -1.0 * zoom));\n\treturn newRay;\n}\n\n\n//Get shadow\nfloat GetShadow (vec3 ro, vec3 rd, float tmin, float tmax, float time)\n{\n \tfloat res = 1.0;\n    float t = tmin;\n    Object objHit;\n    for (int i=0; i<64; i++)\n    {\n\t\tvec3 currentPoint = ro + rd * t;\n        \n       \tfloat d = MapSdf (currentPoint, objHit, time);\n        \n        res = min (res, 10.0 * d/t);\n        \n        t +=d;\n        \n        if (t< EPSILON || t>tmax)\n        \tbreak;\n    }\n    \n    return clamp (res, 0.0, 1.0);\n}\n\n//Get background color (a simple transition between 4 colors)\nvec4 GetBackgroundColor (vec2 originalUV, float iTime)\n{\n    vec4 fragColor = vec4 (1.0);\n    vec3 bottomLeft = vec3 (0.2, 0.39, 0.58);\n    vec3 bottomRight = vec3 (0.29, 0.44, 0.56);\n    vec3 topLeft = vec3 (0.34, 0.72, 0.69);\n    vec3 topRight = vec3 (0.37, 0.78, 0.69);\n\n\n    vec3 interpolatedColor = mix (\n        mix (bottomLeft, bottomRight, originalUV.x),\n        mix (topLeft, topRight, originalUV.x),\n        originalUV.y\n    );\n\n    float y = originalUV.y * 0.3 - sin(iTime) * 0.35;\n\n    //Second gradient\n    vec4 secondColor = mix (vec4(0.882, 0.458, 0.439, 1.0), vec4(0.764, 0.643, 0.807, 0.0), y);\n\n    fragColor = mix (vec4 (interpolatedColor, 1.0), secondColor, originalUV.y);  \n    \n    return fragColor;\n}","name":"Common","description":"","type":"common"}]}