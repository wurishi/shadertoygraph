{"ver":"0.1","info":{"id":"WlXczs","date":"1592749703","viewed":171,"name":"Sincospi function","username":"scholarius","description":"Sincospi() function. \nComputes sine and cosine of pi times x, such that 90° angles are represented exactly (as integer multiples of 0.5).\nThe error is the distance between points on the circle computed with the custom and the builtin versions of sin/cos.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sin","pi","approximation","cos","function","error","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265;\n\n// The sincospi function (sin and cos PI times x)\n// 90° angles are represented exactly (integer multiplies of 0.5)\n\n// The polynomial covers the range of -90°..90° (instead of only 0..45°)\n// so that the range reduction is even simpler and less branchy.\n\nvec2 sincospi( float a )\n{\n    vec2 b = vec2( a - .5, a );\n    //*\n    vec2 x = .5 - abs( b - 2. * round( .5 * b ) );\n    /*/\n    vec2 x = abs( 2. * fract( .5 * b ) - 1. ) - .5;\n    //*/\n    vec2 x2 = x * x;\n    //*\n\treturn ( ( ( ( .0245732479 * x2 - .190367594 ) * x2 + .811703086 ) * x2 - 1.64493275 ) * x2 * x + x ) * 3.14159274;\n    /*/\n    return ( ( ( ( .0864348859 * x2 - .603019178 ) * x2 + 2.55088973 ) * x2 - 5.1677556 ) * x2 + 3.14159298 ) * x;\n    //*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * ( fragCoord - iResolution.xy / 2. ) / iResolution.y;\n\tfloat x = uv.x;    \n    \n    vec2 y = sincospi(x);        \n    vec2 invddx = 1. / max( vec2(1.), abs( PI * y.yx ) );\n\n    // compute error wrt. to builtin sin/cos\n    float error = min( 1., round( 16777216. * length( y - vec2( sin( PI * x ), cos( PI * x ) ) ) ) / 40. );\n    \n    vec3 d = vec3(1.);\n    d.x = min( d.x, .875 + .0625 * iResolution.y * abs( uv.y - round( uv.y * 10. ) / 10. ) );\n    d.x = min( d.x, .875 + .0625 * iResolution.y * abs( uv.x - round( uv.x * 10. ) / 10. ) );\n    d.x = min( d.x, .5 + .25 * iResolution.y * abs( uv.y - round( uv.y ) ) );\n    d.x = min( d.x, .5 + .25 * iResolution.y * abs( uv.x - round( uv.x ) ) );\n\n    d.x = min( d.x, .0 + .5 * iResolution.y * abs( error - uv.y ) / max( 1., fwidth( error ) ) );\n    d.y = min( d.y, -.5 + .5 * iResolution.y * abs( y.x - uv.y ) * invddx.x );\n    d.z = min( d.z, -.5 + .5 * iResolution.y * abs( y.y - uv.y ) * invddx.y );\n\n    fragColor.xyz = vec3( clamp( d.x, 0., 1. ) );\n    fragColor.xyz = mix( vec3(1,0,0), fragColor.xyz, clamp( d.y, 0., 1. ) );\n    fragColor.xyz = mix( vec3(0,.5,1), fragColor.xyz, clamp( d.z, 0., 1. ) );\n    fragColor.xyz = pow( fragColor.xyz, vec3(0.4545) );\n}","name":"Image","description":"","type":"image"}]}