{"ver":"0.1","info":{"id":"lc3Gz2","date":"1711992876","viewed":111,"name":"Halftone Pattern Shader","username":"AgateDragon","description":"Learn how to create a halftone shader, and change the look of the halftone pattern with different blend modes.\nhttps://agatedragon.blog/2024/04/01/halftone-shader-part-2/","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circle","halftone","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Options are 0 to 7\n#define OPTION 0\n\n// Colour options for mixing\nconst vec3 COL1 = vec3(0.12, 0.12, 0.8);\nconst vec3 COL2 = vec3(0.64, 0.8, 0.12);\n\n// Edge smoothing\nconst float SMOOTHING = 12.0;\n\nconst vec3 GREY_WEIGHTS = vec3(0.299f, 0.587f, 0.114f);\n\nfloat Overlay(float a, float b)\n{\n\tif(a < 0.5f) return 2.0f * a * b;\n\treturn 1.0f - 2.0f * (1.0f - a) * (1.0f - b);\n}\n\nvec3 Overlay(vec3 a, vec3 b)\n{\n\tfloat red = Overlay(a.r, b.r);\n\tfloat green = Overlay(a.g, b.g);\n\tfloat blue = Overlay(a.b, b.b);\n\treturn vec3(red, green, blue);\n}\n\nvec3 ScreenBlend(vec3 a, vec3 b)\n{\n\treturn 1.0f - (1.0f - a) * (1.0f - b);\n}\n\nfloat Circle(vec2 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalised pixel coordinates (from 0 to 1)\n    vec2 texCoord = fragCoord / iResolution.xy;\n    \n    // Calculate aspect ratio\n    float w = 1.0 / min(iResolution.x, iResolution.y);\n    \n    // Aspect ratio corrected UV coordinates\n    vec2 uv = fragCoord * w;\n\n    // Position and number of circles\n    float total = min(iResolution.x, iResolution.y) / 4.0;\n    vec2 pos = fract(uv * total);\n    pos -= 0.5;\n\n    // Current pixel colour\n    vec4 pixel = texture(iChannel0, texCoord);\n\n    // Convert to greyscale\n    float greyResult = dot(pixel.rgb, GREY_WEIGHTS);\n\n    // Get the distance to the circle centre\n    float radius = 1.0 - greyResult;\n    float c = Circle(pos, radius);\n\n    // Smoothing\n    float s = SMOOTHING * w;\n    c = 1.0 - smoothstep(s, -s, c);\n\n    // Output based on option\n    switch(OPTION)\n    {\n        case 0:\n        // Multiply\n        fragColour.rgb = pixel.rgb * c;\n        break;\n        case 1:\n        // Black and white multiply\n        fragColour.rgb = vec3(greyResult * c);\n        break;\n        case 2:\n        // Overlay\n        fragColour.rgb = Overlay(pixel.rgb, vec3(c));\n        break;\n        case 3:\n        // Black and white overlay\n        fragColour.rgb = Overlay(vec3(greyResult), vec3(c));\n        break;\n        case 4:\n        // Screen blend\n        fragColour.rgb = ScreenBlend(pixel.rgb, vec3(c));\n        break;\n        case 5:\n        // Black and white screen blend\n        fragColour.rgb = ScreenBlend(vec3(greyResult), vec3(c));\n        break;\n        case 6:\n        // Circles\n        fragColour.rgb = vec3(c);\n        break;\n        case 7:\n        // Mix\n        fragColour.rgb = mix(COL1, COL2, c);\n        break;\n    }\n    \n    // Set fragment alpha\n    fragColour.a = pixel.a;\n}","name":"Image","description":"","type":"image"}]}