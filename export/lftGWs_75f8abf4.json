{"ver":"0.1","info":{"id":"lftGWs","date":"1712278209","viewed":30,"name":"Phong_Lab5","username":"shishir_lc06","description":"Phong starter pack","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lab5"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float NEAR = 0.001;\nconst float FAR = 100.0;\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat sdCube(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0));\n}\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz) - r1, p.y);\n    return length(q) - r2;\n}\n\nfloat map(vec3 p)\n{\n    vec3 spherePosition = vec3(0.0, 0.0, 0.0);\n    float sphere = sdSphere(p - spherePosition, 1.0);\n\n    vec3 cubePosition = vec3(3.0, 0.0, 0.0); // Adjust cube position as needed\n    float cube = sdCube(p - cubePosition, vec3(0.5, 0.5, 0.5)); // Adjust cube size as needed\n\n    vec3 cylinderPosition = vec3(-3.0, 0.0, 0.0); // Adjust cylinder position as needed\n    float cylinder = sdCylinder(p - cylinderPosition, 0.5, 1.0); // Adjust cylinder radius and height as needed\n\n    vec3 torusPosition = vec3(-6.0, 0.0, 0.0); // Adjust torus position as needed\n    float torus = sdTorus(p - torusPosition, 1.0, 0.3); // Adjust torus major and minor radius as needed\n\n    vec3 sphere2Position = vec3(6.0, 0.0, 0.0); // Adjust second sphere position as needed\n    float sphere2 = sdSphere(p - sphere2Position, 0.7); // Adjust second sphere radius as needed\n\n    return min(min(min(min(sphere, cube), cylinder), torus), sphere2); \n}\n\n\n//float map(vec3 p)\n//{\n//    //float ground = p.y + 0.75;\n//    vec3 spherePosition = vec3(/*sin(iTime) * 3.0*/0.0, 0.0, 0.0);\n//    float sphere = sdSphere(p - spherePosition, 1.0);\n//    return sphere;\n//    //return min(sphere, ground);\n//}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phong(vec3 position, vec3 normal, vec3 cameraPosition,\n    vec3 lightPosition, vec3 lightColor,\n    float ambientIntensity, float diffuseIntensity, float specularPower) \n{\n    // 1. Calculate lighting vectors\n    // let N = normal\n    vec3 N = estimateNormal(position);\n    // let L = normalized vector from position to light\n    vec3 L = normalize(lightPosition - position);\n    // let V = normalized vector from position to camera\n    vec3 V = normalize(cameraPosition - position);\n\n    // let R = reflection of -L about axis N\n    vec3 R = reflect(-L, N);\n    \n    // 2. Calculate lighting vector similarities\n    // let dotNL = max between dot product of N & L and zero\n    float dotNL = max(0.0, dot(L, N));\n    // let dotVR = max between dot product of V & R and zero\n    float dotVR = max(0.0, dot(R, V));\n    \n    // 3. Apply ambient, diffuse, and specular contributions\n    // let C = base color (black)\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    // Add light color * ambient intensity to C\n    color += lightColor * ambientIntensity;\n    // Add light color * diffuse intensity * dotNL to C\n    color += lightColor * diffuseIntensity * dotNL;\n    // Add light color * dotVR to the power of specularPower to C\n    color += lightColor * pow(dotVR, specularPower);\n    // Output C\n    \n    //vec3 color = vec3(0.0, 0.0, 0.0);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, 1] --> [-1, 1]\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n       \n    // Ray origin\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    \n    // FoV of 90 degrees\n    float fov = tan(45.0 * 3.14 / 180.0);\n    \n    // Ray direction\n    vec3 rd = normalize(vec3(uv * fov, 1.0));\n    \n    // Distance along ray\n    float t = 0.0;\n    \n    for (int i = 0; i < 80; i++)\n    {\n        // Scene position\n        vec3 p = ro + rd * t;\n        \n        // Determine maxmimum safe stepping distance\n        float d = map(p);\n        \n        // Step along ray by distance d\n        t += d;\n        \n        // Intersection if distance is very close to surface (SDF --> -1)\n        if (d < NEAR) break;\n        \n        // No intersection if distance along ray exceeds view distance\n        if (t > FAR) break;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 n = estimateNormal(p);\n    \n    vec3 lightColor = vec3(1.0, 0.0, 0.0);\n    vec3 lightPosition = vec3(sin(iTime) * 5.0, 5.0, -5.0);\n    float ambient = 0.15;\n    float diffuse = 0.75;\n    float specular = 200.0;\n    vec3 lighting = phong(p, n, ro, lightPosition, lightColor, ambient, diffuse, specular);\n    \n    bool hit = t < FAR - EPSILON;\n    vec3 color = hit ? lighting : vec3(0.25, 0.25, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}