{"ver":"0.1","info":{"id":"7lcBD8","date":"1664829280","viewed":190,"name":"A multiple bouncing balls","username":"bowari","description":"You can change all the parameters in the common file.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------------\n// -------------------------------------- EVALUATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// Evaluate the sdf witch correspond to p_num\nfloat evaluate( in vec3 p_point, in float p_num ){\n    int num = int(p_num);\n    switch(num){\n        // box\n        case 0: return op_substraction(\n                        sdf_box(p_point, vec3(HEIGHT_BOX+SIZE_BOX)),\n                        sdf_box(p_point+vec3(0.,0.,-SIZE_BOX), vec3(HEIGHT_BOX,HEIGHT_BOX,HEIGHT_BOX+SIZE_BOX))\n                       );\n        default : return sdf_sphere(p_point-getVal((num-1)*5,iResolution.x),getVals((num-1)*5+4,iResolution.x).x);\n    }\n}\n\n// Evaluate the global sdf of the scene end return distance and num nearest primitive\nvec2 evaluateScene( in vec3 p_point, bool[int(NB_BALL)] p_shrinkScene){\n    float num, tmp, res = 1e10;\n    \n    //box\n    tmp = evaluate(p_point, 0.);\n    if(tmp<res){ num = 0.; res = tmp; }\n\n    for(float i=0.; i<float(NB_BALL) ;i++){\n        if(p_shrinkScene[int(i)]){\n            tmp = evaluate(p_point,i+1.);\n            if(tmp<res){ num = i+1.; res = tmp; }\n        }\n    }\n    \n    return vec2(res,num);\n} \n// ------------------------------------------------------------------------------------------\n// ---------------------------------------- SHADING -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// Evaluate scene and find normal by computing gradient at 'p_point'\nvec3 findNormal( in vec3 p_point, in vec2 p_hit ){\n\treturn normalize(vec3(evaluate( p_point + vec3( EPS, 0., 0. ), p_hit.y ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., EPS, 0. ), p_hit.y ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., 0., EPS ), p_hit.y ))\n\t\t\t\t\t -p_hit.x);\n}\n\n// find the shade of the primitive\nvec3 brdf( in vec3 p_wo, in vec3 p_wi, in vec3 p_normal, in float p_numOBJ ){\n    int num = int(p_numOBJ);\n    switch(int(num)){\n        case 0: return vec3(1.);            \n        default: return vec3(1.) * pow( max(0.,dot( p_normal, normalize(p_wi+p_wo) )), 128. ) + getVal((num-1)*5+3,iResolution.x);\n    }\n}\n\n// ********************  MAIN  *******************\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec2 uv = fragCoord/iResolution.xy;    // Normalized pixel coordinates (from 0 to 1)    \n    \n    // *** camera stuff ***\n    vec3 posCam = vec3(0.,0.,185.);\n    float focalDistance = 2.5;\n    float fovy = PI/3.;\n\n    vec3 w = normalize( posCam );\n    vec3 u = normalize( cross( vec3(0.,-1.,0.) ,w ) );\n    vec3 v = normalize( cross( w ,u ) );\n\n    float size = 2. * tan(0.5*fovy) * focalDistance;\n    \n    vec3 viewportV = v * size;\n    vec3 viewportU = u * size * (iResolution.x/iResolution.y);\n    vec3 viewportTopLeftCorner = posCam - w*focalDistance + 0.5*(viewportV - viewportU);\n    \n    // *** ray marching ***\n    float t=0., tMax=1000.;\n    vec2 hit;\n    vec3 point, \n         d=normalize( viewportTopLeftCorner + viewportU * uv.x + - viewportV * uv.y - posCam ), \n         invRayD = 1./d,\n         o=posCam, \n         color = CLEAR_COLOR;\n    bool[int(NB_BALL)] newScene;\n    for(int i=0; i<NB_BALL ;i++){\n        vec3 pos_ball = getVal(i*5,iResolution.x);\n        float radius_ball = getVals(i*5+4,iResolution.x).x;\n        newScene[i] = intersectAABB(invRayD,o,vec3[2](pos_ball-radius_ball,pos_ball+radius_ball),tMax); // warning\n    }\n\n    for(int nbStep=MAX_STEP; nbStep>0 ;nbStep--){\n        hit = evaluateScene(point = t*d + o, newScene); // hit = vec2(distance, num OBJ nearest)\n\n        if(hit.x<EPS){\n            vec3 normal = findNormal(o = point, hit);\n            o += normal*(EPS_OH-hit.x);\n            \n            // point Light\n            vec3 vec = vec3(0.,HEIGHT_BOX-SIZE_BOX*2.,0.)-o;\n            vec3 li = normalize(vec);\n            color = brdf(-d,li,normal,hit.y)*(10000./dot(vec,vec))*max(0.,dot(li,normal)); // ligth: color=vec3(1.) ; pow=20000\n            \n            break;\n        }\n        \n        t += hit.x;\n        if(t>tMax) break;\n    }\n    \n    // tone map (aces)\n    color = clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59 ) + 0.14), 0., 1.);\n    //cheap gamma correction\n    color = sqrt(color);\n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// --- RANDOM ---\n// https://www.shadertoy.com/view/7lG3D1\nuint pcg(){\n    uint state = seed*747796405U+2891336453U;\n    uint tmp  = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    return (seed = (tmp >> 22U) ^ tmp);\n}\n\nfloat rand(){return float(pcg())/float(0xffffffffU);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    seed = uint(iFrame*(int(iResolution.x*iResolution.y)))+uint(fragCoord.x+fragCoord.y*iResolution.x);\n    \n    ivec2 fc = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,fc,0);\n\n    int index = fc.x+fc.y*int(iResolution.x);\n    int num = index/5;\n\n    if(num<NB_BALL){\n        if(iFrame==0) {\n            float radius = RADIUS_MIN+rand()*(RADIUS_MAX-RADIUS_MIN);\n            float mass = DENSITY*FOUR_PI_THREE*radius*radius*radius;\n            float damp = mass*1.;\n            \n            setVal(index,5*num,vec3(0.));\n            setVal(index,5*num+1,(vec3(rand(),rand(),rand())-0.5)*2.*VELOCITY_BOUND);\n            setVal(index,5*num+2,vec3(0.));\n            setVal(index,5*num+3,vec3(rand(),rand(),rand()));\n            setVals(index,5*num+4,vec4(radius,mass,damp,HEIGHT_BOX-radius));\n        }else{\n            vec3 pos = getVal(5*num,iResolution.x);\n            vec3 vel = getVal(5*num+1,iResolution.x);\n            vec4 data = getVals(5*num+4,iResolution.x);\n            \n            vel += ( GRAVITY+(getVal(5*num+2,iResolution.x)-vel*data.z)/data.y )*iTimeDelta;\n            pos += vel; //*iTimeDelta;\n    \n            // collision box-ball\n            for(int i=0; i<3 ;i++){\n                if(pos[i]>data.w || pos[i]<-data.w){\n                    vel[i] *= -RESTITUTION;\n                    pos[i] = clamp(pos[i],-data.w,data.w);\n                }\n            }\n\n            setVal(index,5*num,pos);\n            setVal(index,5*num+1,vel);\n            \n            // colision ball-ball\n            if(index%5==2){\n                fragColor = vec4(0.);\n            \n                for(int i=0; i<NB_BALL ;i++){\n                    if(num==i) continue;\n                    float R = data.x+getVal(5*i+4,iResolution.x).x;\n                    vec3 vec = pos-getVal(5*i,iResolution.x);\n                    float d2 = dot(vec,vec);\n\n                    if( d2 < (R*R)){\n                        float d = sqrt(d2);\n                        fragColor += vec4(vec*1000000.*(R-d)/d,0.);\n                    }\n                }\n            }\n        }\n   }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ******************** GLOBAL VARIABLE ********************\n#define PI            3.14159265\n#define TWO_PI        6.28318530\n#define INV_PI        0.31830988\n#define FOUR_PI_THREE 4.18879020\n#define GRAVITY       vec3(0.,-9.81,0.)\n\n// --- ball ---\n#define NB_BALL 25\n#define DENSITY 25.\n#define RADIUS_MIN 10.\n#define RADIUS_MAX 20.\n#define VELOCITY_BOUND 20.\n#define RESTITUTION 0.99\n\n// --- box ---\n#define HEIGHT_BOX 90.\n#define SIZE_BOX 10.\n\n// --- others ---\nuint seed;\n#define MAX_STEP 100\n#define EPS 0.001\n#define EPS_OH 0.0015\n#define CLEAR_COLOR vec3(0.)\n\n// ******************** COMMON FUNCTIONS ********************\n#define setVal(p_iThread, p_iRef, p_val) if(p_iThread==p_iRef) fragColor = vec4(p_val,0.)\n#define setVals(p_iThread, p_iRef, p_val) if(p_iThread==p_iRef) fragColor = p_val\n#define getVal(p_iRef, p_xRes) texelFetch(iChannel0,ivec2((p_iRef)%int(p_xRes),float(p_iRef)/p_xRes),0).xyz\n#define getVals(p_iRef, p_xRes) texelFetch(iChannel0,ivec2((p_iRef)%int(p_xRes),float(p_iRef)/p_xRes),0)\n\nbool intersectAABB( in vec3 p_d, in vec3 p_o, in vec3[2] p_MinMax, in float p_tMax ){ \n    ivec3 s\t= ivec3( p_d.x<0., p_d.y<0., p_d.z<0. );\n\n\t// *** X axis ***\n\tfloat tmpMin, refMin = ((p_MinMax[s.x]).x - p_o.x) * p_d.x;\n\tfloat tmpMax, refMax = ((p_MinMax[1-s.x]).x - p_o.x) * p_d.x;\n\n\t// *** Y axis ***\n    if( (tmpMin=((p_MinMax[s.y]).y - p_o.y)*p_d.y)>refMax || refMin>(tmpMax=((p_MinMax[1-s.y]).y - p_o.y)*p_d.y) ) return false;\n    refMin = max( tmpMin, refMin );\n    refMax = min( tmpMax, refMax );\n\n\t// *** Z axis ***\n    if( (tmpMin=((p_MinMax[s.z]).z - p_o.z)*p_d.z)>refMax || refMin>(tmpMax=((p_MinMax[1-s.z]).z - p_o.z)*p_d.z) ) return false;\n    refMin = max( tmpMin, refMin );\n    refMax = min( tmpMax, refMax );\n\n\treturn (refMin<=p_tMax) && (refMax>=0.);\n}\n\n// --- OPERATION ---\nfloat op_union( in float p_sdf1, in float p_sdf2 ) {\n\treturn (p_sdf1<p_sdf2) ? p_sdf1 : p_sdf2;\n}\n\nfloat op_substraction( in float p_sdf1, in float p_sdf2 ) {\n    return (p_sdf1>-p_sdf2) ? p_sdf1 : -p_sdf2;\n}\n\n// --- SDF ---\nfloat sdf_sphere( in vec3 p_point, in float p_radius ){\n  return length(p_point)-p_radius;\n}\n\nfloat sdf_box( in vec3 p_point, in vec3 b ){\n  vec3 q = abs(p_point) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n","name":"Common","description":"","type":"common"}]}