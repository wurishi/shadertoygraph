{"ver":"0.1","info":{"id":"ltBfDD","date":"1515802183","viewed":180,"name":"quadratic bezier text","username":"dahart","description":"quadratic bezier text","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bezier","text","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float remap(float x, float min1, float max1, float min2, float max2) {\n    return clamp(min2 + (x - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\nconst vec2 X = vec2(1.0, 0.0);\nconst float PI = 3.14159265358979323;\nconst float fMaxFloat = intBitsToFloat(0x7f7fffff);\n\n//https://www.shadertoy.com/view/ltXSDB\n// Solve cubic equation for roots\n#if 0\n// original version for reference\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n#else \n// Solve cubic equation for roots\n// x^3 + ax^2 + bx + c = 0\n// Simplified via constant folding\nvec3 solveCubic(float a, float b, float c)\n{\n    a *= (1./3.);\n    b *= (1./3.);\n    float p = a*a - b;\n    float q =  a*(b/2. - p) - c/2.;\n    float d = q*q - p*p*p;\n    if(d >= 0.) { \n        float z = sqrt(d);\n        vec2 x = vec2(q+z, q-z);\n        vec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n        return vec3(uv.x + uv.y - a);\n    } else {\n        float snp = sqrt(p);\n        float v = acos(q / (p*snp)) * (1./3.);\n        float m = cos(v);\n        float n = sin(v) * sqrt(3.);\n        return vec3(m+m, -n-m, n-m) * snp - a;\n    }\n}\n#endif\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Find the signed distance from a point to a bezier curve\n// returns a vec4: (dist to boundary, dist to curve, sign, parameter [0-1])\nvec4 sdBezier(vec2 p, vec3 A, vec3 B, vec3 C)\n{    \n    //B = (4.0 * B - A - C) / 2.0;\n    // handle instability when B is midpoint between A and C\n    //B = vec3(mix(B.xy + vec2(1e-4), B.xy, abs(sign(B.xy * 2.0 - A.xy - C.xy))), B.z);\n    vec3 b = A - B * 2.0 + C;\n    //B.xy += 0.0001 * sign(b.xy);\n    \n    vec3 a = B - A;\n    b = A - B * 2.0 + C;\n    vec3 c = a * 2.0;\n    vec2 d = A.xy - p;\n    \n    vec3 k = vec3(3.*dot(a.xy,b.xy),2.*dot(a.xy,a.xy)+dot(d.xy,b.xy),dot(d.xy,a.xy)) / dot(b.xy,b.xy);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec3 it = vec3(1.0) - t;\n\n    mat3x3 pos;\n    pos[0] = A + (c + b*t.x)*t.x;\n    pos[1] = A + (c + b*t.y)*t.y;\n    pos[2] = A + (c + b*t.z)*t.z;\n\n    float[3] dis;\n    dis[0] = length(pos[0].xy - p) - pos[0].z;\n    dis[1] = length(pos[1].xy - p) - pos[1].z;\n    dis[2] = length(pos[2].xy - p) - pos[2].z;\n    \n    int whichMin = 0;\n    if (dis[1] < dis[whichMin]) whichMin = 1;\n    if (dis[2] < dis[whichMin]) whichMin = 2;\n        \n    return vec4(dis[whichMin], \n                dis[whichMin] + pos[whichMin].z,\n                signBezier(A.xy, B.xy, C.xy, p), \n                t[whichMin]);\n}\n\n// evaluate closest distance to a picewise quadratic bezier\n// p is the point to query distance from\n// n is how many control points\n// pts are the n control points\n// returns a vec4: (dist to fat curve boundary, dist to curve center, sign, parameter [0-1])\nvec4 sdCurve(vec2 p, int n, vec3[16] pts) {\n    vec4 d = fMaxFloat * X.xxxx, e;    \n    vec3 pp1 = mix(pts[0], pts[1], -0.001), pp2;\n    float oofn = 1.0 / (float(n));\n    for (int i = 0; i < n; i++) {\n        pp2 = 0.5 * (pts[i] + pts[i+1]);\n        e = sdBezier(p, pp1, pts[i], pp2);\n        pp1 = pp2;\n        //if (e.w < .99 && e.w > 0.01)\n        if (e.x < d.x) d = vec4(e.xyz, (e.w+float(i))*oofn);\n    }\n    return d;\n}\n\n// evaluate a piecewise quadratic bezier. \n// t is the parameter [0,1] for the entire curve.\n// n is how many control points\n// pts are the n control points\nvec3 evalCurve(float t, int n, vec3[16] pts) {\n    t *= float(n);\n    float pt = fract(t);\n    int c1 = int(t);\n    int c0 = max(0, c1 - 1);\n    int c2 = min(n-1, c1 + 1);\n    \n    vec3 p0 = mix(pts[c0], pts[c1], .5);\n    vec3 p1 = pts[c1];\n    vec3 p2 = mix(pts[c1], pts[c2], .5);\n    \n    return mix(mix(p0, p1, pt), mix(p1, p2, pt), pt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime + (iResolution.x + iMouse.x) / 100.;\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n\t//fragColor = texture(iChannel0, uv);\n    \n    // create a curve\n    vec3 curve1[16];\n    for (int i = 0; i < 16; i++) {\n        curve1[i].x = float(i)/10. + 0.1;\n        curve1[i].y = .1 * sin(float(i)*.7 - time) + .5;\n        curve1[i].z = .005 * float(i) + 0.05;\n    }\n    \n    // render the curve\n    vec4 d = sdCurve(uv, 15, curve1);\n    float edgeWidth = fwidth(d.x) * 2.;\n    if (d.x < edgeWidth) {\n\t    vec3 p = evalCurve(d.w, 15, curve1);\n        float aa = smoothstep(edgeWidth, 0., d.x);\n        \n        vec2 curve_uv = vec2(d.w, .5 - .5 * d.z * d.y / p.z);    \n        \n        const float nletters = 26.;\n        float word_u = clamp(remap(fract(curve_uv.x/1.5-time/19.), .0, 1., 0., 1.) * nletters - 1., 0., nletters-1.);\n    \tfloat word_v = remap(curve_uv.y*1.5-.25, .0, 1., 0., 1.);\n    \n    \tvec2 letter_uv = vec2( fract(word_u), word_v );\n\n    \tint a = 16*6 + 1 - 1;\n        int ltrs[] = int[](31,4,9,18,5,3,20,9,15,14,31,178,31,4,9,18,5,3,20,9,15,14,31,178,31,31);\n        int ltr = int(word_u);\n        int idx = a + ltrs[ltr];\n        int sx = idx % 16;\n        int sy = 16 - idx / 16 - 1;\n\n        vec2 fuv = (1./16.) * (letter_uv + vec2(sx, sy));\n        \n        // render text\n        if (letter_uv.x > .1 && letter_uv.x < .9) // avoid the fringing letter edges\n        \tfragColor += vec4(vec3(texture(iChannel0, fuv).r), 1.);\n        \n        fragColor.r = aa;\n        fragColor.g += clamp(curve_uv.y, 0., 1.) * aa; // dist to curve over curve radius\n        fragColor.b = float(int(mod(curve_uv.x, .1) < .05) ^ int(mod(curve_uv.y, .2) < .1)) * aa;\n    }\n}\n","name":"Image","description":"","type":"image"}]}