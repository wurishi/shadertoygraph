{"ver":"0.1","info":{"id":"dsGGW1","date":"1678450195","viewed":59,"name":"Generic line experiments","username":"gutza","description":"Experiments with lines","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["line","learning","snippet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nHeavily inspired from FabriceNeyret2's comments on https://www.shadertoy.com/view/dl2XW1\n\nThis shader illustrates two generic methods of\ndrawing lines; check out the various performance\ntests below (experiment with the PERF_LINES_* values.)\n\n*/\n\n#define CS(a) vec2(cos(a), sin(a))\n#define R iResolution.xy\n#define PI 3.141592653589793\n#define TAU PI*2.\n#define SQRT2 1.4142135623730951\n\n// Fastest but cumbersome to use (70000 => 99% GPU @ 60 fps on GeForce RTX 4090)\n// See performanceDemoBW()\n#define PERF_LINES_BW 0\n\n// Good performance and easy to use (43000 => 99% GPU @ 60 fps on GeForce RTX 4090)\n// See performanceDemoColor()\n#define PERF_LINES_COLOR 0\n\n// Poor performance (5000 => 99% GPU @ 60 fps on GeForce RTX 4090)\n// See performanceDemoAlias()\n#define PERF_LINES_AL 0\n\n#define PERF_FACTOR_BW sqrt(float(PERF_LINES_BW) + 1.) * 2.\n#define PERF_FACTOR_COLOR sqrt(float(PERF_LINES_COLOR) + 1.) * 2.\n#define PERF_FACTOR_AL sqrt(float(PERF_LINES_AL) + 1.) * 2.\n\n// ------------ METHOD 1 (anti-aliased, good performance) ------------\nfloat renderLines(float lines) {\n    return 1. - sqrt(smoothstep(0., SQRT2, lines));\n}\n\nfloat raw_segment(vec2 p, vec2 a, vec2 b) {\n    // Shift the origin to the starting point\n    p -= a, b -= a;\n    \n    // Project the current position on the line\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    \n    // Compute the distance from the current point to the segment\n    return length(p - b * h);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    return renderLines(raw_segment(p, a, b));\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b, float w) {\n    return renderLines(raw_segment(p, a, b) - w);\n}\n\nvec3 segment(vec2 p, vec2 a, vec2 b, vec3 col) {\n    return col * renderLines(raw_segment(p, a, b));\n}\n\nvec3 segment(vec2 p, vec2 a, vec2 b, float w, vec3 col) {\n    return col * renderLines(raw_segment(p, a, b) - w);\n}\n// ------------ /METHOD 1 (anti-aliased, good performance) ------------\n\n// ------------ METHOD 2 (aliased, poor performance) ------------\nbool aliasSegment(vec2 p, vec2 a, vec2 b) {\n    // line parametric equation:\n    // x = x0 + ab.x * t\n    // y = y0 + ab.y * t\n    //\n    a = floor(a);\n    b = floor(b);\n    // `+ 0.01` allows to render zero length lines (if `ab == (0, 0)`, `t` will\n    // be `nan`), and at same time it will not affect rendered pixel position,\n    // because it will keep shifted position in the same integer cell\n    b.x += 0.01;\n    p = floor(p);\n\n    vec2 ab = b - a;\n    // swap `x` and `y` if needed\n    // algorithm depends on which side is wider `x` or `y`, but both variants is\n    // similar just instead of `x` `y` is used, swapping allows simplify code,\n    // and get rid of `if` branching\n    int i = int(abs(ab.x) > abs(ab.y));\n    int xi = 1 - i;\n    int yi = i;\n    float t = (p[xi] - a[xi]) / ab[xi];\n    float y = round(a[yi] + ab[yi] * t);\n    // `x` should be rounded because `0.01` was added before, otherwise some\n    // tests will fail, line will not be rendered in some places\n    float minX = round(min(a[xi], b[xi]));\n    float maxX = round(max(a[xi], b[xi]));\n    return p[yi] == y && minX <= p[xi] && p[xi] <= maxX;\n}\n// ------------ METHOD 2 (aliased, poor performance) ------------\n\nvec3 qualityDemo(vec2 u)\n{\n    vec2\n        p1 = R / vec2(4,2),\n        p2 = p1 * vec2(3,1);\n\n    float\n        s = min(R.x, R.y) / 3.,\n        pxScale = s / 100.;\n\n    vec3 axis_color = vec3(0., .5, 1.);\n    float axis_width = 1.5;\n\n    vec3 lines = segment(u, p1 - vec2(s, 0), p1 + vec2(s, 0), axis_width,  axis_color);\n    lines = max(lines , segment(u, p1 - vec2(0, s), p1 + vec2(0, s), axis_width, axis_color));\n    \n    // zero length line, rendered as one pixel\n    lines = max(lines , segment(u, p1 + vec2(10, 10) * pxScale, p1 + vec2(10, 10) * pxScale));\n    \n    vec3 arrow_color = vec3(1.0, 0.3, 0.2);\n    lines = max(lines , segment(u, p1 + vec2(15, 15) * pxScale, p1 + vec2(50, 50) * pxScale, 5., arrow_color));\n    lines = max(lines , segment(u, p1 + vec2(15, 15) * pxScale, p1 + vec2(20, 25) * pxScale, 5., arrow_color));\n    lines = max(lines , segment(u, p1 + vec2(15, 15) * pxScale, p1 + vec2(25, 20) * pxScale, 5., arrow_color));\n    \n    float t = iTime / 3.;\n    lines = max( lines , segment(u, p2 - CS(t) * s, p2 + CS(t) * s, vec3(1., .8, 0.)));\n    float tShifted = iTime / 25. + TAU / 4.;\n    lines = max( lines , segment(u, p2 - CS(tShifted) * s, p2 + CS(tShifted) * s, axis_width,  axis_color));\n    tShifted += TAU / 4.;\n    lines = max( lines , segment(u, p2 - CS(tShifted) * s, p2 + CS(tShifted) * s, axis_width,  axis_color));\n    \n    return lines;\n}\n\nvec3 performanceDemoColor(vec2 u)\n{\n    vec3 lines = vec3(0);\n    vec2 cellSize = vec2(\n        float(iResolution.x) / PERF_FACTOR_COLOR,\n        float(iResolution.y) / PERF_FACTOR_COLOR\n    );\n    for (float x = 0.; x < iResolution.x; x += cellSize.x) {\n        for (float y = 0.; y < iResolution.y; y += cellSize.y) {\n            lines = max(lines, segment(u, vec2(x, y), vec2(x + cellSize.x, y + cellSize.y)));\n            lines = max(lines, segment(u, vec2(x + cellSize.x, y), vec2(x, y + cellSize.y)));\n        }\n    }\n    return lines;\n}\n\nvec3 performanceDemoBW(vec2 u)\n{\n    float lines = SQRT2;\n    vec2 cellSize = vec2(\n        float(iResolution.x) / PERF_FACTOR_BW,\n        float(iResolution.y) / PERF_FACTOR_BW\n    );\n    for (float x = 0.; x < iResolution.x; x += cellSize.x) {\n        for (float y = 0.; y < iResolution.y; y += cellSize.y) {\n            lines = min(lines, raw_segment(u, vec2(x, y), vec2(x + cellSize.x, y + cellSize.y)));\n            lines = min(lines, raw_segment(u, vec2(x + cellSize.x, y), vec2(x, y + cellSize.y)));\n        }\n    }\n    return vec3(renderLines(lines));\n}\n\nvec3 performanceDemoAlias(vec2 u)\n{\n    bool lines = false;\n    vec2 cellSize = vec2(\n        float(iResolution.x) / PERF_FACTOR_AL,\n        float(iResolution.y) / PERF_FACTOR_AL\n    );\n    for (float x = 0.; x < iResolution.x; x += cellSize.x) {\n        for (float y = 0.; y < iResolution.y; y += cellSize.y) {\n            lines = lines || aliasSegment(u, vec2(x, y), vec2(x + cellSize.x, y + cellSize.y));\n            lines = lines || aliasSegment(u, vec2(x + cellSize.x, y), vec2(x, y + cellSize.y));\n        }\n    }\n    return lines ? vec3(1) : vec3(0);\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n#if PERF_LINES_BW>0\n    O.xyz = performanceDemoBW(u);\n#elif PERF_LINES_COLOR>0\n    O.xyz = performanceDemoColor(u);\n#elif PERF_LINES_AL>0\n    O.xyz = performanceDemoAlias(u);\n#else\n    O.xyz = qualityDemo(u);\n#endif\n}","name":"Image","description":"","type":"image"}]}