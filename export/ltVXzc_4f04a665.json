{"ver":"0.1","info":{"id":"ltVXzc","date":"1485347355","viewed":551,"name":"SDF Interpolation","username":"Linus","description":"Signed distance field interpolation to interpolate between shapes.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==================\n\nconst bool RENDER_DISTANCE = false;\nconst bool RENDER_SHAPE = true;\n\n//==================\n\nstruct Figure {\n\tvec2  position;\n    float size;\n};\n\nvec2 rotateAround(vec2 vec, vec2 point, float angle) {\n    vec -= point;\n\tvec *= mat2(sin(angle), cos(angle), cos(angle), -sin(angle));\n    vec += point;\n    return vec;\n}\n    \nfloat signedCircleDistance(Figure circle, vec2 uv) {\n    \n\treturn length(circle.position - uv) - circle.size;\n}\n\nfloat signedSquareDistance(Figure square, vec2 uv) {\n    vec2 delta = abs(square.position - uv);\n \treturn max(delta.x, delta.y) - square.size;   \n}\n\nvec2 uvCoords(in vec2 fragCoord) {\n    float pixelsInUnit = min(iResolution.x, iResolution.y);\n    vec2 offset = ((pixelsInUnit - iResolution.xy) * 0.5) / pixelsInUnit;\n    return (fragCoord / pixelsInUnit) + offset;\n}\n\nvec4 signedDistanceToColor(float dist) {\n\tfloat intensity = 1.0 - exp(-abs(dist/20.0));\n    \n   \tvec4 distanceColor = vec4(\n    \tdist < 0.0 ? intensity : 0.0,\n        dist > 0.0 ? intensity : 0.0,\n        0.0, \n        0.0\n    );\n    vec4 shapeColor = vec4(smoothstep(1.0, 0.0, abs(dist) * 3.0 ));\n    \n    vec4 color;\n    if(RENDER_DISTANCE) { color += distanceColor; }\n    if(RENDER_SHAPE) { color += shapeColor; }\n    \n    return  color;\n}\n\nfloat signedDistanceFigureA(vec2 uv) {\n    uv = rotateAround(uv, vec2(50.0, 50.0), iTime / 12.0);\n    \n    Figure circle0 = Figure (vec2(50.0, 65.0), 15.0);\n    Figure square0 = Figure (vec2(50.0, 35.0), 25.0);\n    Figure square1 = Figure (vec2(22.5, 35.0), 15.0);\n    \n    return min(signedCircleDistance(circle0, uv), \n           min(signedSquareDistance(square0, uv),\n           \t   signedSquareDistance(square1, uv)\n           ));\n}\n\nfloat signedDistanceFigureB(vec2 uv) {\n    \n    uv = rotateAround(uv, vec2(50.0, 50.0), -iTime / 3.14);\n    Figure square0 = Figure (vec2(50.0, 50.0), 30.0);\n    Figure circle0 = Figure (vec2(70.0, 35.0), 20.0);\n    vec2 offset = vec2(sin(iTime) * 31.0, 0.0);\n    square0.position += offset;\n    circle0.position += offset;\n    \n    \n    return min(signedSquareDistance(square0, uv), signedCircleDistance(circle0, uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = uvCoords(fragCoord) * 100.0;\n    \n    Figure circle0 = Figure (vec2(50.0, 65.0), 15.0);\n    Figure square0 = Figure (vec2(50.0, 35.0), 25.0);\n    Figure square1 = Figure (vec2(50.0, 50.0), 30.0);\n    Figure square2 = Figure (vec2(40.0, 50.0), 10.0);\n    Figure circle1 = Figure (vec2(70.0, 35.0), 20.0);\n    \n    float distA = signedDistanceFigureA(uv);\n    float distB = signedDistanceFigureB(uv);\n    float t = cos(iTime / 2.0) * 0.5 + 0.5;\n    float distT = mix(distA, distB, t);\n    fragColor = signedDistanceToColor(distT);\n}","name":"Image","description":"","type":"image"}]}