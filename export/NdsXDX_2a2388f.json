{"ver":"0.1","info":{"id":"NdsXDX","date":"1619365799","viewed":97,"name":"magic ball - dodecahedron","username":"ademidenko","description":"1. Anti-aliasing\n2. Cubemap\n3. Textures\n4. Soft shaddows\n5. Ray-casting","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy; \n    \n    fragColor = texture(iChannel0, uv) / float(iFrame);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nstruct Ray { vec3 pos, dir; };\n\nstruct Material { // TODO: check Fresnel law\n    vec2 type; // (D, REFL); REFR = 1.0 - D - REFL; \n    vec3 color;\n    vec3 dif;\n    vec3 em;\n    vec3 sp;\n    float sh;\n};\n\nstruct Hit {\n    bool exists;\n    float t;\n    Ray ray;\n    Material mat;\n    vec3 normal;\n};\n\nstruct Box {\n    vec3 min, max;\n    Material mat;\n}; /* ? */\n\nstruct Plane {\n    vec4 coefs;\n    Material mat;\n};\n\nstruct Dodecahedron {\n    Material mat;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rad;\n    Material mat;\n};\n\nstruct Table {\n    vec4 coefs;\n    float rad;\n    Material mat;\n};\n\nstruct Light {\n    vec3 dif;\n    vec3 sp;\n};\n\nstruct Lamp {\n    Sphere body;\n    Light light;\n};\n\nstruct Cylinder {\n    float h, rad;\n    Material mat;\n};\n\nstruct Scene {\n    Table table;\n    Cylinder cyl;\n    Dodecahedron dod;\n    Lamp lamps[2];\n};\n\n// CONSTANTS\nconst vec3 CAMERA_POS = vec3(2., 4.0, 6.0);\n\nconst float PHI = (1.0 + sqrt(5.0)) / 2.0;\nconst float INF = 1e10;\n\nconst int DIFFUSION = 0;\nconst int EMISSION = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nconst Material NO_MAT = Material(vec2(-1.), vec3(-1.), vec3(-1.), vec3(-1.), vec3(-1.), 0.0);\nconst Ray NO_RAY = Ray(vec3(0), vec3(0));\nconst Hit NO_HIT = Hit(false, INF, NO_RAY, NO_MAT, vec3(0));\n\nconst float AIR_N = 1.;\nconst float GLASS_N = 1.5;\n\nconst float AMBIENT_STRENGTH = 0.5;\nconst int MAX_DEPTH = 10;\nconst float BRIGHTNESS_MULT = 0.5;\nconst int MAX_RAY_STEPS = 5000;\n\nconst float TABLE_TEXTURE_MULT = .3;\nconst float CYL_TEXTURE_MULT = .1;\n\n\nconst float LIGHT_BRIGHTNESS = 40.;\n\nconst float VOXEL_RESOLUTION = 16.;         \nconst float VOXEL_BRIGHTNESS = 2.;\nconst int VOXEL_NO_HIT = 0;\nconst int VOXEL_GROUND = 1;\nconst int VOXEL_WATER = 2;\nconst vec3 VOXEL_WATER_COLOR = VOXEL_BRIGHTNESS * vec3(.2, .2, 1);\nconst vec3 VOXEL_GRASS_COLOR = VOXEL_BRIGHTNESS * vec3(.2, 1, .2);\nconst vec3 VOXEL_GROUND_COLOR = VOXEL_BRIGHTNESS * vec3(.5, .3, .2);\n\nconst float VOXEL_OPACITY = .8;\n\nconst float VOXEL_SEA_LEVEL = -.7;\nconst Material VOXEL_MATERIAL = Material(\n            vec2(1., 0.),\n            vec3(0),   // color\n            vec3(1., 1., 1.),   // dif\n            vec3(.0, .0, .0),   // em\n            vec3(1., 1., 1.),   // sp\n                32.               // sh\n    );\n\nconst vec4[12] dCoefs = vec4[12](\n    vec4( 1,  PHI, 0,  PHI * PHI),\n    vec4(-1, -PHI, 0,  PHI * PHI),\n    vec4( 1, -PHI, 0,  PHI * PHI),\n    vec4(-1,  PHI, 0,  PHI * PHI),\n\n    vec4(0, -1, -PHI,  PHI * PHI),\n    vec4(0,  1,  PHI,  PHI * PHI),\n    vec4(0, -1,  PHI,  PHI * PHI),\n    vec4(0,  1, -PHI,  PHI * PHI),\n\n    vec4(-PHI, 0, -1,  PHI * PHI),\n    vec4( PHI, 0,  1,  PHI * PHI),\n    vec4( PHI, 0, -1,  PHI * PHI),\n    vec4(-PHI, 0,  1,  PHI * PHI)\n);\n\nfloat rand(float frame) {\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvec3 randVals, randDir;\n\nMaterial defaultMat(vec3 color) {\n    return Material(\n        vec2(1.0, 0.0),\n        color,\n        vec3(1.0, 1.0, 1.0),   // dif\n        vec3(0., 0., 0.),   // em\n        vec3(1.0, 1.0, 1.0),   // sp\n        31.0               // sh\n    );\n}\n\nfloat fresnelEq(float n1, float n2) {\n    return (n1 - n2) * (n1 - n2) / (n1 + n2) * (n1 + n2);\n}\n\nScene initScene() {\n    Scene scene;\n    scene.table = Table(\n        vec4(0., 1., 0., 1.7),\n        5.,\n        Material(\n            vec2(.9, .1),\n            vec3(.3, .3, 1.),   // color\n            vec3(1, 1, 1),   // dif\n            vec3(0., 0., 0.),   // em\n            vec3(1., 1., 1.),   // sp\n                32.               // sh\n        )\n    );\n\n    scene.cyl = Cylinder(\n        PHI, 1.5,\n        Material(\n            vec2(.6, .4),\n            vec3(.3, .3, 1.),   // color\n            vec3(1., 1., 1.),   // dif\n            vec3(0., 0., 0.),   // em\n            vec3(1., 1., 1.),   // sp\n                32.               // sh\n        )\n    );\n    \n    scene.lamps[0] = Lamp(\n        Sphere(\n            vec3(2., 3., .2), .3,\n            Material( vec2(1.0, 0.0), vec3(1, 1, 1), vec3(0), vec3(1.0, 1.0, 1.0), vec3(0), 1.0)\n        ),\n        Light( vec3(0.3, 1, 1), vec3(1, 1, 1))\n    );\n    \n    scene.lamps[1] = Lamp(\n            Sphere(\n                vec3(-.8, 1.4, -3.5), .3,\n                Material( vec2(1.0, 0.0), vec3(0, .75, 1.5), vec3(0), vec3(1.0, 1.0, 1.0), vec3(0), 1.0)\n            ),\n            Light( vec3(0.3, .75, 1.5), vec3(1, 1, 1))\n        ); \n        \n    scene.dod = Dodecahedron(\n        Material( vec2(0.0, 1. - fresnelEq(1.5, 1.)),\n            vec3(0.3, 0.3, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            vec3(0.3, 0.3, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            32.0 )\n    );  \n    \n    return scene;\n}\n/*\n\nvec3 getViewVec(vec3 cameraPos, vec2 fragCoord) {\n    vec2 aa_delta = vec2(rand(float(iFrame)), rand(float(iFrame + 5))); // Anti-Aliasing ;D\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy + (aa_delta - 0.5)) / iResolution.x;    \n    \n    vec3 front = normalize(-cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    return viewVec;\n}\n*/\n\nvec3 getViewVec(vec3 cameraPos, vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy + (aa_delta - 0.5)) / iResolution.x;    \n    return normalize(vec3(uv, -camPos.z) - camPos);\n}\n\nHit tracePlane(Ray ray, Plane plane) {      \n    vec4 p = vec4(ray.pos, 1);\n    vec4 d = vec4(ray.dir, 0);\n    // ax + by + cz + d = 0\n    // let coefs = vec4(a, b, c, d)\n    // dot(coefs, p + t * d) = 0\n    // dot(coefs, p) + t * dot(coefs, d) = 0\n    // t = - dot(coefs, p) / dot(coefs, d) \n    float t = - dot(plane.coefs, p) / dot(plane.coefs, d);\n    if (t < 0.0)\n        return NO_HIT;\n    return Hit(\n        true, \n        t,\n        ray,\n        plane.mat,\n        normalize(plane.coefs.xyz)\n    );\n}\n\nHit traceTable(Ray ray, Table table) {\n    Hit hit = tracePlane(ray, Plane(table.coefs, table.mat));\n    vec3 worldPos = ray.pos + hit.t * ray.dir;\n    if (dot(worldPos, worldPos) >= table.rad * table.rad) {\n        return NO_HIT;\n    } \n    return hit;\n}\n\nbool insideDodec(vec3 point) {\n    vec4 a = vec4(point, 1);\n    for (int i = 0; i < 12; i++) {\n        float nProj = sign(dCoefs[i].w) * dot(a, 3. * dCoefs[i]);\n            if (nProj < -1E-4)\n            return false;\n    }\n    return true;\n}\n\nHit traceDodecahedron(Ray ray, Dodecahedron dod) {    \n    vec4 p = vec4(ray.pos, 1);\n    vec4 d = vec4(ray.dir, 0);\n    Hit fHit = NO_HIT;    \n    for (int i = 0; i < 12; i++) {       \n        Hit hit = tracePlane(ray, Plane(dCoefs[i], dod.mat));\n        if (hit.t < fHit.t && insideDodec(ray.pos + hit.t * ray.dir))\n            fHit = hit;\n    }  \n    return fHit;\n}\n\nHit traceCylinder(Ray ray, Cylinder cyl) {\n    Hit hit = tracePlane(ray, Plane(vec4(0, 1, 0, cyl.h), cyl.mat));\n    if (hit == NO_HIT) { return hit; }\n    vec3 worldPos = ray.pos + hit.t * ray.dir;\n    if (dot(worldPos.xz, worldPos.xz) < cyl.rad * cyl.rad)\n        return Hit( true, hit.t, ray, cyl.mat,  normalize(vec3(0., 1., 0.)));\n    \n    float a = dot(ray.dir.xz, ray.dir.xz);\n    float b = dot(ray.pos.xz, ray.dir.xz);\n    float c = dot(ray.pos.xz, ray.pos.xz) - cyl.rad * cyl.rad;\n    float D = b * b - a * c;\n    if (D < 0.0) { return NO_HIT; }\n    float t1 = (-b - sqrt(D)) / a;\n    float t2 = (-b + sqrt(D)) / a;\n    if (t2 < 0.0) { return NO_HIT; }\n    float t = t1 < 0.0 ? t2 : t1;\n    worldPos = ray.pos + t * ray.dir;\n    if (worldPos.y > - cyl.h) { return NO_HIT; }\n    return Hit( true, t, ray, cyl.mat,  normalize(vec3(worldPos.x, 0, worldPos.z)));\n}\n\nHit traceSphere(Ray ray, Sphere sphere) {\n    vec3 pos = ray.pos - sphere.pos; // move (0, 0, 0) to center of sphere\n    // dot(pos + t * ray.dir, pos + t * ray.dir) == sphere.rad * sphere.rad\n    // dot(pos, pos) + 2 * t * dot(ray.dir, pos) + t * t * dot(ray.dir, ray.dir) == sphere.rad * sphere.rad\n    // t * t + 2 * t * dot(ray.dir, pos) + dot(pos, pos) - sphere.rad * sphere.rad == 0\n    float a = 1.0;\n    float b = dot(ray.dir, pos);\n    float c = dot(pos, pos) - sphere.rad * sphere.rad;\n    float D = b * b - a * c;\n    if (D <= 0.0) { return NO_HIT; }\n    float t1 = (-b - sqrt(D)) / a;\n    float t2 = (-b + sqrt(D)) / a;\n    if (t2 < 0.0) { return NO_HIT; }\n    float t = t1 < 0.0 ? t2 : t1;\n    vec3 normal = normalize(pos + t * ray.dir);\n    return Hit( true, t, ray, sphere.mat, normal);\n}\n\nbool inSphere(vec3 mapPos, float r) {\n    return length(mapPos) - r < 0.;\n}\n\nbool inWater(vec3 mapPos) {\n    return mapPos.y < VOXEL_SEA_LEVEL;\n}\n\nbool inGround(vec3 mapPos) {\n    float freqX, freqZ, ampX, ampZ;\n    vec3 shift =  vec3(2.55, .5, 0.95);\n    mapPos += shift;\n    freqX = 4.;\n    freqZ = 5.5;\n    ampX = 3. / mapPos.x / mapPos.x;\n    ampZ = .15 / mapPos.z;\n    return ampZ * sin(freqZ * mapPos.z) + ampX * sin(freqX * mapPos.x) > mapPos.y;\n}\n\nint terrainHit(vec3 mapPos) {\n    if (inGround(mapPos))\n        return VOXEL_GROUND;\n    if (inWater(mapPos))\n        return  VOXEL_WATER;\n    return VOXEL_NO_HIT;\n}\n\nHit traceVoxel(Ray ray) {\n\tvec3 mapPos = ((floor(ray.pos * VOXEL_RESOLUTION)  + .5)/ VOXEL_RESOLUTION);\n    vec3 deltaDist = 1. / abs(ray.dir);\n\tvec3 rayStep = sign(ray.dir) / VOXEL_RESOLUTION;\n\tvec3 sideDist =  deltaDist * (sign(ray.dir) * (mapPos - ray.pos) + .5 / VOXEL_RESOLUTION); // consider deleting VOXEL_RESOLUTION\n    vec3 mask;\n\n\tint i, voxelType;\n\tfor (i = 0; i < MAX_RAY_STEPS; i++) {\n        voxelType = terrainHit(mapPos);\n        if (inSphere(mapPos, 1.0) &&  voxelType != VOXEL_NO_HIT) break;\n\t\tmask = step(sideDist, sideDist.yzx) * step(sideDist, sideDist.zxy);\n\t\tsideDist += deltaDist * mask / VOXEL_RESOLUTION;\n\t\tmapPos += mask * rayStep;\n\t}\n    vec3 color;\n\tif (voxelType == VOXEL_WATER) \n        color = VOXEL_WATER_COLOR;\n    else if (mask.y == 1.)\n        color = VOXEL_GRASS_COLOR;\n    else if (mask.x == 1.)\n        color = VOXEL_GROUND_COLOR;\n    else\n        color = VOXEL_GROUND_COLOR;\n    if (i >= MAX_RAY_STEPS) { return NO_HIT; }\n    Material mat = VOXEL_MATERIAL;\n    mat.color = color;\n    return Hit( true, length(mapPos - ray.pos), ray, mat, mask * sign(-ray.dir));\n}\n\nHit traceScene(Ray ray,Scene scene) {\n    Hit hit = NO_HIT;\n    Hit tableHit = traceTable(ray, scene.table);\n    if (tableHit.t < hit.t) {\n        hit = tableHit;\n        vec3 worldPos = hit.t * hit.ray.dir + hit.ray.pos;\n        hit.mat.color = texture(iChannel0, worldPos.xz * TABLE_TEXTURE_MULT).rgb;\n    } \n    \n    Hit dodHit = traceDodecahedron(ray, scene.dod);\n    if (dodHit.t < hit.t) {\n        hit = dodHit;\n    }\n    \n    //Hit plHit = tracePlane(ray, Plane(vec4(1, 0, 1, 0), defaultMat(vec3(.75))));\n    //if (plHit.t < hit.t) {\n      //  hit = plHit;\n    //} \n    \n    Hit cylHit = traceCylinder(ray, scene.cyl);\n    if (cylHit.t < hit.t) {\n        hit = cylHit;\n        vec3 worldPos = hit.t * hit.ray.dir + hit.ray.pos;\n        hit.mat.color = texture(iChannel2, worldPos.xz * worldPos.y * CYL_TEXTURE_MULT).rgb;\n    }\n    \n    Hit voxHit = traceVoxel(ray);\n    if (voxHit.t < hit.t && randVals.y < VOXEL_OPACITY) {\n        hit = voxHit;\n    }\n\n    for (int i = 0; i < scene.lamps.length(); i++) {\n        Hit lampHit = traceSphere(ray, scene.lamps[i].body);\n        if (lampHit.t < hit.t) {\n            hit = lampHit;\n        }\n    }\n \n    return hit;\n}\n\nvec3 Id(Hit hit, Lamp lamp) {  \n    vec3 worldPos = hit.ray.pos + hit.t * hit.ray.dir;\n    vec3 toLamp = lamp.body.pos - worldPos;\n    float distSq = dot(toLamp, toLamp);\n    return hit.mat.dif * lamp.light.dif\n        * max(0.0, dot(hit.normal, normalize(toLamp))) / distSq * LIGHT_BRIGHTNESS;\n}\n\nvec3 Is(Hit hit, Lamp lamp) {    \n    vec3 worldPos = hit.ray.pos + hit.t * hit.ray.dir;\n    vec3 toLamp = lamp.body.pos - worldPos;\n    float distSq = dot(toLamp, toLamp);\n    vec3 R = reflect(normalize(toLamp), hit.normal);\n    vec3 E = hit.ray.dir;\n    return hit.mat.sp * lamp.light.sp\n        * pow(max(dot(R, E), 0.0), hit.mat.sh) / distSq * LIGHT_BRIGHTNESS;\n}\n\nvec3 Ia(vec3 dir) {\n    return AMBIENT_STRENGTH * textureLod(iChannel1, dir, 10.).rgb;\n}\n\nfloat occlusionMult(vec3 pos, Scene scene, int lamp_number) {\n    vec3 soft_shadow_term = randDir * scene.lamps[lamp_number].body.rad;\n    vec3 dir = scene.lamps[lamp_number].body.pos + soft_shadow_term  - pos;\n    float dist = length(dir);\n    dir /= dist;\n    Ray ray = Ray(pos, dir);\n    \n    Hit dodHit = traceDodecahedron(ray, scene.dod);\n    Hit cylHit = traceCylinder(ray, scene.cyl);\n    // Hit voxHit = traceVoxel(ray);\n    \n    float r = rand(float(iFrame + 5));\n    \n    if (cylHit.t < dist && r < dot(cylHit.mat.type.xy, vec2(1)) ||\n        dodHit.t < dist && r < dot(dodHit.mat.type.xy, vec2(1))) // ||\n        // voxHit.t < dist && r < dot(voxHit.mat.type.xy, vec2(1)))\n      return 0.;     \n    return 1.;\n\n}\n    \nvec3 computeLight(Hit hit, Scene scene) {\n    vec3 I = vec3(0);\n    for (int i = 0; i < scene.lamps.length(); i++) {\n       vec3 worldPos = hit.ray.pos + hit.t * hit.ray.dir;\n       I += occlusionMult(worldPos, scene, i) * (Id(hit, scene.lamps[i]) + Is(hit, scene.lamps[i]));\n    }\n    I += Ia(hit.ray.dir);\n    I += hit.mat.em;\n    vec3 color = hit.mat.color * I;\n    return color;\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n\n    Scene scene = initScene();\n    vec3 camPos = CAMERA_POS;\n    Ray ray = Ray(camPos, getViewVec(camPos, fragCoord));\n    Hit hit;\n    \n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n\n    for (int i = 0; i < MAX_DEPTH; ++i) {\n        hit = traceScene(ray, scene);\n        if (!hit.exists) {\n            fragColor.rgb = texture(iChannel1, ray.dir).rgb;\n            return;\n        }\n    \n        int finalType;\n        if (randVals.y < hit.mat.type.x)\n            finalType = DIFFUSION;\n        else if (randVals.y < hit.mat.type.x + hit.mat.type.y)\n            finalType = REFLECTION;\n        else\n            finalType = REFRACTION;\n        vec3 worldPos = hit.t * ray.dir + ray.pos;\n        fragColor = texture(iChannel0, worldPos.xz);\n        if (finalType == DIFFUSION) {\n            fragColor.rgb = computeLight(hit, scene);\n            break;\n        } else if (finalType == REFLECTION) {\n            ray.dir = reflect(ray.dir, hit.normal);\n            ray.pos = worldPos + ray.dir * 5e-5;\n        } else if (finalType == REFRACTION) {\n            ray.dir = refraction(ray.dir, hit.normal, n1, n2);\n            ray.pos = worldPos + ray.dir * 5e-5;\n            float tmp = n1;\n            n1 = n2;\n            n2 = tmp;\n        } \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}