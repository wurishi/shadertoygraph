{"ver":"0.1","info":{"id":"lfcyDr","date":"1730481823","viewed":81,"name":"Lamp Balls","username":"perubr12","description":"A blob shader using metaballs","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Funcao de hash\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Fucao de ruido 2D\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 u = f*f*(3.0-2.0*f); // Smoothstep for interpolation\n    \n    return mix(mix(hash(i + vec2(0.0, 0.0)), \n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)), \n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Tempo\n    float time = iTime;\n\n    //UV normalizado\n    vec2 uv = (fragCoord.xy-iResolution.xy) / iResolution.y;\n    uv.x += iTime * 0.05;\n    //Tamanho da grid\n    vec2 gridSize = vec2(5.0, 5.0);  \n    //Tamanho da celula\n    vec2 cellSize = 1.0 / gridSize;  \n    //Index da celula\n    vec2 cellIndex = floor(uv * gridSize);\n    //UV da celula\n    vec2 cellUV = (uv * gridSize) - cellIndex - 0.5;; \n    //Fator de ruido\n    float noiseFactor = 1.0;\n    //Offset de ruido\n    vec2 noiseOffset = cellIndex * 1.0;\n    \n    // Metaballs\n    vec2 p1 = vec2(0.1 * sin(time + noise(noiseOffset) * noiseFactor),\n                   0.5 * cos(time + noise(noiseOffset) * noiseFactor));\n                   \n    vec2 p2 = vec2(0.5 * cos(time + 2.0 + noise(noiseOffset + vec2(2.0)) * noiseFactor),\n                   0.3 * sin(time + 3.0 + noise(noiseOffset + vec2(3.0)) * noiseFactor));\n                   \n    vec2 p3 = vec2(0.3 * sin(time + 1.0 + noise(noiseOffset + vec2(4.0)) * noiseFactor),\n                   0.1 * cos(time + 4.0 + noise(noiseOffset + vec2(5.0)) * noiseFactor));\n                   \n    vec2 p4 = vec2(0.2 * cos(time + 3.0 + noise(noiseOffset + vec2(6.0)) * noiseFactor),\n                   0.4 * sin(time + 5.0 + noise(noiseOffset + vec2(7.0)) * noiseFactor));\n                   \n    vec2 p5 = vec2(0.4 * sin(time + 4.0 + noise(noiseOffset + vec2(8.0)) * noiseFactor),\n                   0.2 * cos(time + 6.0 + noise(noiseOffset + vec2(9.0)) * noiseFactor));\n\n\n    \n    //Offset para não ficar na borda\n    float offset = 0.5;\n    p1 *= offset;\n    p2 *= offset;\n    p3 *= offset;\n    p4 *= offset;\n    p5 *= offset;\n\n    //Distancia\n    float d1 = length(cellUV - p1);\n    float d2 = length(cellUV - p2);\n    float d3 = length(cellUV - p3);\n    float d4 = length(cellUV - p4);\n    float d5 = length(cellUV - p5);\n\n    //Adiciona um valor pequeno para evitar divisão por zero\n    d1 += 0.00000000001;\n    d2 += 0.00000000001;\n    d3 += 0.00000000001;\n    d4 += 0.00000000001;\n    d5 += 0.00000000001;\n    \n    // Tira vies de distribuição\n    float smallFactor = 0.0001; \n\n    //Raio dos Metaballs\n    float k1 = fract(sin(dot(cellIndex + vec2(0.1, 0.1), vec2(12.9898, 78.233)) + smallFactor)) * 0.03;\n    float k2 = fract(sin(dot(cellIndex + vec2(0.2, 0.2), vec2(39.346, 11.135)) + smallFactor)) * 0.03;\n    float k3 = fract(sin(dot(cellIndex + vec2(0.3, 0.3), vec2(20.514, 93.526)) + smallFactor)) * 0.03;\n    float k4 = fract(sin(dot(cellIndex + vec2(0.4, 0.4), vec2(41.321, 66.321)) + smallFactor)) * 0.03;\n    float k5 = fract(sin(dot(cellIndex + vec2(0.5, 0.5), vec2(10.765, 19.321)) + smallFactor)) * 0.03;\n\n    // Pesos Metaballs\n    float metaball = k1 / d1 + k2 / d2 + k3 / d3 + k4 / d4 + k5 / d5;\n    //Cria o blob\n    float blob = smoothstep(0.3, 0.3, metaball);\n    //Cria a borda do blob\n    float blobEdge = smoothstep(0.4, 0.5, metaball);\n    //Interpola o blob com a borda\n    float blob_final = smoothstep( blob,blobEdge, metaball);\n\n    //Criar cores\n    vec3 cellColor = vec3(\n        fract(sin(dot(cellIndex+0.01, vec2(12.9878, 78.233))) * 43758.5453), \n        fract(sin(dot(cellIndex, vec2(39.346, 11.135))) * 43758.5453),  \n        fract(sin(dot(cellIndex, vec2(20.514, 93.526))) * 43758.5453)  \n    );\n\n    vec3 cellColor2 = vec3(\n        fract(sin(dot(cellIndex+0.01, vec2(41.321, 66.321))) * 43758.5453), \n        fract(sin(dot(cellIndex, vec2(10.765, 19.321))) * 43758.5453),  \n        fract(sin(dot(cellIndex, vec2(20.514, 93.526))) * 43758.5453)  \n    );\n\n    vec3 cellColor3 = vec3(\n        fract(sin(dot(cellIndex+0.01, vec2(20.514, 93.526))) * 43758.5453), \n        fract(sin(dot(cellIndex, vec2(41.321, 66.321))) * 43758.5453),  \n        fract(sin(dot(cellIndex, vec2(10.765, 19.321))) * 43758.5453)  \n    );\n    //Aplica cor\n    vec3 color = cellColor * blobEdge+cellColor2*(1.0-blob_final)+cellColor*(blob)*0.1;\n\n    //Output\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}