{"ver":"0.1","info":{"id":"WlGyR3","date":"1611382263","viewed":891,"name":"Jump Flooding DT","username":"ming","description":"A study of the Jump Flooding algorithm. Forked from https://www.shadertoy.com/view/4syGWK\nFor simplicity this shader only conduct distance transform and try to make the code as easy to understand as possible.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["2d","jfa","dt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original shader https://www.shadertoy.com/view/4syGWK\n// Buffer A - conduct jump flooding iterations\n// Buffer B - cache the results for the last pass in each iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // calculate the distance to the nearest neighbour\n    ivec2 tc = ivec2(fragCoord + 0.5);\n    \n    float d = length(load0(tc).xy - fragCoord) / 64.0;\n    d = max(0.0, min(1.0, d));\n    \n    // apply gamma\n    d = pow(d, 1.0 / 2.2);\n    \n    store(fragColor,vec4(d,d,d,0.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    if (pass < 0.5) {\n        // init\n        vec2 uv = sprite_uv(fragCoord, iResolution.xy, iTime * 5.0);\n        vec4 color = texture(iChannel1, uv);\n        \n        // store the coordinate for non-empty pixels, otherwise zero\n        float lum = dot(color.rgb,vec3(0.299, 0.587, 0.114));\n        if (lum < 0.5) {\n            store(fragColor, vec4(fragCoord,0.0,0.0));\n        } else {\n            store(fragColor, vec4(0.0));\n        }\n    } else {\n        // JFA passes (for up to 4096x4096, 0 - 11)\n        float level = clamp(pass - 1.0, 0.0, 11.0);\n        int stepwidth = int(exp2(11.0 - level)+0.5);\n        \n        ivec2 tc = ivec2(fragCoord + 0.5);\n        \n        float best_dist = 999999.0;\n        vec2 best_coord = vec2(0.0);\n        vec2 center = vec2(tc);\n        \n        // search the 3x3 neighbours\n        for (int y = -1; y <= 1; ++y) {\n            for (int x = -1; x <= 1; ++x) {\n                ivec2 fc = tc + ivec2(x,y)*stepwidth;\n\t\t        vec2 ntc = load0(fc).xy;\n                \n                if ((ntc.x != 0.0) && (ntc.y != 0.0)) {\n                    // compare the squared distance\n                    vec2 diff = ntc - center;\n                    float d = dot(diff, diff);\n                    if (d < best_dist) {\n                        best_dist = d;\n                        best_coord = ntc;\n                    }\n                }\n            }\n        }        \n        store(fragColor,vec4(best_coord,0.0,0.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// 4096 = 2^12; and 1 init step\n#define pass_id() mod(float(iFrame),13.0);\n#define last_pass_id 12.0\n\nvec2 sprite_uv( in vec2 coord, in vec2 resolution, in float time )\n{\n    vec2 uv = coord / resolution.xy;\n    uv.x = clamp(uv.x * resolution.x / resolution.y - 0.3, 0.0, 1.0);\n    float ww = 40.0/256.0;\n    return floor(mod(time, 6.0)) * vec2(ww,0.0) + vec2(ww,1.0) * uv;\n}\n\n\nvoid store(out vec4 t, vec4 v) {\n    t = v;\n}\n\nvec4 load(sampler2D channel, vec2 res, ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / res;\n    return texture(channel, uv);\n}\n\n#define load0(p) load(iChannel0, iChannelResolution[0].xy, p)\n#define load1(p) load(iChannel1, iChannelResolution[1].xy, p)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    ivec2 tc = ivec2(fragCoord + 0.5);\n    \n    if (pass == last_pass_id) {\n        // update from Buffer A in every last pass in each iteration\n        store(fragColor,load0(tc));\n    }\n    else {\n        // otherwise keeps Buffer B's cached results\n        store(fragColor, load1(tc));\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}