{"ver":"0.1","info":{"id":"WllczX","date":"1592649587","viewed":153,"name":"U.F.B(Unidentified Flying Boze)","username":"kaiware007","description":"\"I saw it! The flying Boze!\"","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG1 6.0\n#define MAT_BG2 7.0\n#define MAT_CS 8.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\nvec2 opI( vec2 d1, vec2 d2 )\n{ \n    return (d1.x > d2.x) ? d1 : d2;\n}\n\nvec2 opPaint(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : vec2(d1.x, d2.y);\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float sc)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0 / sc);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.035, 0.01 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float sc)\n{    \n    float x = 0.05;\n    float z = -0.175;\n    float r = 0.0045 * sc;\n    float rb1 = 100. / sc;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, rb1), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -rb1), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float sc)\n{\n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.1) * sc, vec3(0.0175,0.0025,0.1) * sc, 0.001*sc);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp, sc);\n    d = opUnion(d, d2);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(d4, MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(mxp, sc);\n    vec2 cheep = vec2(d7, MAT_CHEEP);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp, sc);\n    eye.x = opUnion(eye.x, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    //head = opPaint(head, eye);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    //result = opPaint(result, cheep);\n    \n    return result;\n}\n\nvec2 sdCapsuleBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nvec2 sdUFBoze(vec3 p, float sc, float ms)\n{\n    return opU(sdBoze(p, sc, ms), vec2(sdCappedCone(p + vec3(0, 0.08 * sc, 0), 0.06 * sc, 0.5 * sc, 0.25 * sc), MAT_CS));\n}\n\nvec2 sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(MAX_DIST);\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    float rt = iTime * 10.;\n    \n    //result = sdBoze(rotate(p, M_PI, vec3(0,1,0)) + vec3(0,0.5,0),10., 1.0); // test\n    \n    p = rotate(p, M_PI-rt, vec3(0,1,0));\n    p = rotate(p, rt, normalize(vec3(cos(rt) * 0.2,1.0,sin(rt) * 0.2)));\n    \n    float defspd = 1.0;\n    float quick = 10.;\n    float spd = defspd * quick;\n    float rspd = 1./spd;\n    float ys = 1.3;\n    float rad = M_PI2 / 8.;\n    \n\n    vec3 r = vec3(5,2.0,1);\n    vec3 offset3 = noised(vec2(-iTime * rad * defspd, 0.))*r;\n    \n    float mt = mod(iTime, defspd * 2.);\n    if(mt >= defspd) \n    {\n        mt -= defspd;\n        float tt = (iTime - defspd) * spd;\n        float i = floor(tt)*rspd;\n    \tfloat t = -i * rad * spd;\n    \tfloat t2 = t - rad;\n\n        vec3 offset = mt <= rspd ? offset3 : hash31(t) * r - r * 0.5;\n        vec3 offset2 = mt >= (defspd - rspd) ? mix(hash31(t)*r - r * 0.5, offset3, fract(tt)) : mix(offset, hash31(t2)*r - r * 0.5, fract(tt));\n        result =  opU(result, sdCapsuleUFBoze(p, -offset, -offset2, 1.0, 1.0));\n    }else{\n    \tresult = opU(result, sdUFBoze(p + offset3, 1.0, 1.0));    \n    }\n    \n\treturn result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n          map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n          map(position + epsilon.yyx).x - map(position - epsilon.yyx).x);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).x;\n        if (h < 0.0001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec3 traceRay(in vec3 origin, in vec3 direction) {\n    float material = 0.0;\n\n    float t = 0.02;\n    \n    vec3 pos;\n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = origin + direction * t;\n        vec2 hit = map(pos);\n\n        t += hit.x;\n        material = hit.y;\n\n        count++;\n        if (hit.x <= 0.0001 || hit.x >= MAX_DIST) {\n        \tbreak;\n        }\n    }\n    /*\n    if (t >= MAX_DIST) {\n        t = MAX_DIST;\n        material = 0.0;        \n    }\n*/\n    return vec3(t, material, count);\n}\n\nvec3 subsurfaceTrace(vec3 origin, vec3 direction) {\n    vec3 density = pow(vec3(.7,.5,.4),vec3(.4));\n\tconst float confidence = .01;\n\tvec3 visibility = vec3(1.0);\n\t\n\tfloat lastVal = map(origin).x;\n\tfloat soft = 0.0;\n\tfor ( int i=1; i < 50; i++ )\n\t{\n\t\tif ( visibility.x < confidence )\n\t\t\tcontinue;\n\t\t\n\t\tfloat val = map(origin).x;\n\n\t\tvec3 softened = pow(density,vec3(smoothstep(soft,-soft,val)));\n//tweak this to create soft shadows, by expanding with each step (linearly)\n\t\t\n\t\tif ( (val-soft)*lastVal < 0.0 )\n\t\t{\n\t\t\t// approximate position of the surface\n\t\t\tfloat transition = -min(val-soft,lastVal)/abs(val-soft-lastVal);\n\t\t\tvisibility *= pow(softened,vec3(transition));\n\t\t}\n\t\telse if ( val-soft < 0.0 )\n\t\t{\n\t\t\tvisibility *= softened;\n\t\t}\n\n\t\tsoft += .1;\n\t\tlastVal = val+soft;\n\t\torigin += direction*.4;\n\t}\n\t\n\treturn visibility;\n}\n\nvec4 subsurface(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 100; ++i){\n        float d = map(p).x;\n        e += -d;\n        \n        if(d > -0.00001)\n            break;\n\n        p -= d*dir;\n    }\n    \n    return vec4(p, e);\n}\n\nvec3 materialColor(vec3 pos, vec3 mat, out float roughness, out float metalness)\n{\n    vec3 col = vec3(0);\n    \n    //float t = saturate(sin(iTime * 2.5)*0.25+0.25);\n    float m = 0.0;\n    //float m = mix(0.00001, 1., sin(iTime * 5.)*0.5+0.5);\n    //float r = mix(0.00001, 1., cos(iTime * 5.)*0.5+0.5);\n    float r = 0.3;\n\tif(mat.y == MAT_BLACK) {\n        col = vec3(0.1);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_FACE) {\n        col = vec3(1.0, 0.7, 0.6);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BROW) {\n        col = vec3(1.0, 0, 0.1);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_CHEEP) {\n        col = vec3(1.0, 0.3, 0.4);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BG1) {\n        vec3 index = floor(pos * 10.+ 0.5);\n\n        //float f = noise(index + iTime * 2.8);\n        //col = mix(vec3(1), vec3(0), f);\n        col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.1;\n        metalness = 0.0;\n    } else if(mat.y == MAT_BG2) {\n        vec3 index = floor(pos * 50.+ 0.5);\n\t\tfloat f = noise(index + iTime * vec3(2.8,-0.8,0.79));\n        //col = sinebow(f);\n        col = vec3(1,0.5,0.2);\n        //col = vec3(1.0,0,0) + vec3(-1,0,1) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.1;\n        metalness = 0.0;\n    } else if(mat.y == MAT_CS) {\n        col = vec3(0.9);\n        //col = vec3(1.0,0,0) + vec3(-1,0,1) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.1;\n        metalness = 0.8;\n    }\n    \n    return col;\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    //return vec3(0);\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, vec3 albedo, float roughness, float metallic) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 indirectHit = traceRay(pos, r);\n    vec3 indirectSpecular = vec3(0.);\n    \n    if (indirectHit.y > 0.0) {\n        vec3 indirectPosition = pos + indirectHit.x * r;        \n\t\tfloat reflength = length(indirectPosition - pos);\n        \n        indirectSpecular = materialColor(indirectPosition, indirectHit, roughness, metallic);\n\t\t\n        if(reflength >= 0.){\n            //vec3 sky = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        \tvec3 sky = 0.8 * SkyColor(r) * metallic;\n\n        \t// fog\n        \tindirectSpecular = mix(indirectSpecular, sky, 1.0 - saturate(exp2(-0.1 * reflength * reflength)));\n        }\n\t\t\n    }\n\t\n    // indirect contribution\n    vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n    vec3 specularColor = f0 * dfg.x + dfg.y;\n\tvec3 ibl = diffuseColor * indirectDiffuse * 1.0 + indirectSpecular * specularColor;\n    \n    color += ibl * indirectIntensity;\n\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, vec3 mat, vec2 uv)\n{\n    vec3 col = vec3(0);\n    vec3 sky = SkyColor(ray);\n    \n    float t = iTime * 1.0 + M_PI * 1.5;\n    float r = 2.0;\n    vec3 lightPos = vec3(0.6, 0.8, -0.0);\n    \n    if (mat.x >= MAX_DIST) {\n        col = sky;\n    } else {\n        if(mat.y > 0.0)\n        {\n            vec3 nor = norm(p);\n            float roughness, metalness;\n            col = materialColor(p, mat, roughness, metalness);\n\n            vec3 result = vec3(0.);\n            result = calcAmb(p, ray, nor, lightPos, vec3(0.98, 0.92, 0.89) * 3.0, col, roughness, metalness);\n            col = result;\n        }\n    }\n    \n    // Exponential distance fog\n    col = mix(col, 0.8 * sky, 1.0 - saturate(exp2(400.0-mat.x * mat.x)));\n\n    // Glow\n\tcol += (sinebow(iTime * 10.) +vec3(0.1)) * pow(saturate((mat.z * 3. - 10.) / float(MAX_MARCH)), 4.); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    vec3 mat = traceRay(p, ray);\n    \n    pos = p + mat.x * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI * 0.2;\n        float y = 0.05;\n        float r = 7.5;\n        vec3 ro = vec3(sin(t) * 0.25, y + cos(t * 2.13 + 3.5354) * 0.25, -r);\n        vec3 ta = vec3(0., y, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}