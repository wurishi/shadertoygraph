{"ver":"0.1","info":{"id":"XljSW1","date":"1443344835","viewed":512,"name":"Physically Accurate Wormhole ","username":"recursophile","description":"Modified from the shader by kig at https://www.shadertoy.com/view/ldS3DW\n\nThis shader is my first attempt at a basic wormhole. The central object is a spherical wormhole through to another scene with the same background, but tinted red.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["wormhole","astrophysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//Modified from the shader by kig at https://www.shadertoy.com/view/ldS3DW\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*vec3(0.4-0.1, 0.3-0.1, 0.2-0.1) +\n\t\tpow(sky, 1.0)*vec3(0.8, 0.8, 1.0);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec4 wormhole(vec3 incidence,vec3 normal){\n    \n    //Wormhole parameters\n\tfloat wormholeLength = 1.0;\n    float fogMaxVisibleRotations = 5.0;\n    \n    //Wormhole code\n    float normProj = dot(incidence, normal);\n    float tangentProj = 1.0 - normProj;\n    if(tangentProj == 0.0) return -vec4(incidence,1.0);\n    float pitch = normProj / tangentProj;\n    float rotations = wormholeLength / pitch;\n  \tvec3 axis = cross(incidence,normal);\n  \tfloat angle = rotations * 2.0 * M_PI;\n  \tmat3 R = rotationMatrix(axis,angle);\n    vec3 dir = R * incidence;\n    float visibility = clamp(1.0 - rotations / fogMaxVisibleRotations,0.0,1.0); \n    return vec4(dir, visibility);\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n\tfloat camPeriod = 10.0;\n\tvec3 ro = vec3(0.0, 0.0, -3.0 + 2.0 * sin(iTime * 2.0 * M_PI / camPeriod));\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tfloat t = sphere(ro, rd, p, 1.0);\n\tvec3 nml = normalize(p - (ro+rd*t));\n\tvec3 bgCol = background(iTime, rd);\n\t//rd = reflect(rd, nml);\n    vec4 wh = wormhole(rd,nml);\n    rd = wh.xyz;\n\tvec3 col = wh.w * background(iTime, rd) * vec3(1.0, 0.5, 0.5);\n\tfragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 );\n}","name":"","description":"","type":"image"}]}