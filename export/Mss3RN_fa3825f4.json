{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float box(vec3 p) {\n\tvec3 b = vec3(4.0, 4.0, 4.0);\n\tp = mod(p,b)-0.5*b;\n\t\n\treturn length(max(abs(p)-vec3(.5,.5,.5),0.0));\n}\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.02,.0,.0);\n\treturn normalize(vec3(\n\t\tbox(p+e.xyy)-box(p-e.xyy),\n\t\tbox(p+e.yxy)-box(p-e.yxy),\n\t\tbox(p+e.yyx)-box(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n\txy.y *= -iResolution.y / iResolution.x;\n\n\t\n\tvec3 ro = 2.0*normalize(vec3(cos(iTime),cos(iTime),sin(iTime)));\n    vec3 eyed = normalize(vec3(0.0) - ro);\n    vec3 ud = normalize(cross(vec3(0.0,1.0,0.0), eyed));\n    vec3 vd = normalize(cross(eyed,ud));\n\n\tconst float fov = 3.14 * 0.7;\n\tfloat f = fov * length(xy);\n\tvec3 rd = normalize(normalize(xy.x*ud + xy.y*vd) + (1.0/tan(f))*eyed);\n\n\n\tvec3 p = ro + rd;\n\n\tfloat d;\n\tfor(int i = 0; i < 42; i++) {\n\t\td = box(p);\n\t\tif(d < 0.05) break;\n\t\tp += d*rd;\n\t}\n\n\tif(d < 0.05) {\n\t\tvec3 n = normal(p);\n\t\tfragColor = vec4(abs(n).xyz,1.0);\n\t}\n\telse {\n\t\tfragColor = vec4(.2,.2,.2,1.0);\n\t}\n\t\t\n\n\t\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mss3RN","date":"1364792454","viewed":609,"name":"Raymarching simple","username":"kataho","description":"Simple raymarching made to learn this trick.\nYou can take and use lines creating ray direction for curved view plane.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}