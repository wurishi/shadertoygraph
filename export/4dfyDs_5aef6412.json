{"ver":"0.1","info":{"id":"4dfyDs","date":"1490231268","viewed":464,"name":"YAM - Yet Another Mandelbulb","username":"1vx_437312114","description":"Since mandelbulbs have become trendy again on shadertoys lately, here is my take. Based on  https://www.shadertoy.com/view/4sXcWj just with another map function. I commented the code extensively hoping it might help other people to start. Thanks to all.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","fractal","distancefield","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on https://www.shadertoy.com/view/ltfSWn\n// created by inigo quilez - iq\n// (see https://iquilezles.org/articles/mandelbulb for details)\n//\n// and the blog entry \"Distance Estimated 3D Fractals (V): The Mandelbulb & Different\n// DE Approximations\" by Mikael Hvidtfeldt Christensen\n// (see http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/)\n//\n//\n// Code for 4x rotated-grid SSAA for antialiasing taken from\n// https://www.shadertoy.com/view/XsXXWS by Morgan Mc Guire (Morgan3D)\n//\n// (take also a look at the excellent documented source code if you need a very good and very detailed\n// explanation of how to render mandelbulbs!)\n//\n//\n// For an explanation of how to archieve realistic looking outdoor lighting take a look at:\n//\n// https://iquilezles.org/articles/outdoorslighting\n//\n// and for raymarching in general: \"rendering worlds with two triangles\"\n//\n// https://iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to iq for the great tutorials, for shadertoy and everything else\n\n\n// set to true for antialiasing (enhances rendering quality but decreases speed by a factor of 4!)\n#define ANTIALIASING false\n\n\n// globals (are bad, i know, but make life sometimes easier :-) )\nfloat dr;\n\n//Fractal\nconst int   NUM_ITERATIONS  = 5;\nconst float SCALE           = 3.0; \n      vec3  OFFSET          = vec3(1.0, 1.0, 1.0);\n\t  mat3  m               = mat3(1,0,0,0,1,0,0,0,1);//Initialized in main function\n\n\n// background color function, computes skycolor based on ray direction (used, if the ray hits nothing)\nvec3 skyColor(vec3 rd)\n{\n    vec3 sunDir = vec3(0.0, -1.0, 0.0);\n    vec3 sunColor = vec3(1.6, 1.8, 2.2);\n\n    float sunAmount = max(dot(rd, sunDir), 0.0);\n    float v = pow(1.0 - max(rd.y, 0.0), 6.0);\n    vec3 sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\n\n    sky += sunColor * sunAmount * sunAmount * 0.25 + sunColor * min(pow(sunAmount, 800.0) * 1.5, 0.3);\n\n\n    return clamp(sky, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n}\n\n\n// signed distance field function (mandelbulb power 8)\nfloat map(vec3 p)\n{\n\tconst int itMax = 14;\n\n    vec3 w = p;\n\n    float r = 0.0;\n    float dist = 0.0;\n\n    dr = 1.0;\n\n\n    for(int it = 0; it < itMax; it++)\n    {\n        r = length(w);\n\n        if (r > 2.0)\n        {\n            dist = 0.5 * log(r) * r / dr;\n\n            break;\n        }\n\n        // extract polar coordinates\n        float theta = acos(w.z / r);\n        float phi =  atan(w.y, w.x);\n\n        // scale and rotate point\n        float rp2 = w.x * w.x + w.y * w.y + w.z * w.z;\n        float rp4 = rp2 * rp2;\n\n        float radPower = rp4 * rp4;\n        float phiPower = phi * 8.0;\n        float thetaPower = theta * 8.0;\n\n\n        // convert back to cartesian coordinates\n        float sinTheta = sin(thetaPower);\n        float sinPhi   = sin(phiPower);\n        float cosTheta = cos(thetaPower);\n        float cosPhi   = cos(phiPower);\n\n        w.x = radPower * sinTheta * cosPhi;\n        w.y = radPower * sinTheta * sinPhi;\n        w.z = radPower * cosTheta;\n\n        // add c\n        w += p;\n\n        // compute dr\n        float r2 = r * r;\n        float r4 = r2 * r2;\n        dr *= r4 * r2 * r * 8.0 + 1.0;\n    }\n\n    return dist;\n}\n\n\n// raymarching with distance field\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    const int maxStepCount = 256;\t// maximum no. of steps to march\n    const float tMax = 100.0;\t\t// maximum distance to march\n    const float epsilon = 0.0003;\t// determines precision (smaller values for more details\n    \t\t\t\t\t\t\t\t// and more noise due to holes from precision problems)\n\n\tfloat t = 0.0;\n\n    // march!\n    for(int i = 0; i < maxStepCount; i++)\n    {\n        // march forward along the ray, compute point p on ray for this step\n        vec3 p = ro + rd * t;\n\n        // get distance to nearest surface from distance field\n        float distance = map(p);\n\n        // if we're already marched too far (t > tMax),\n        // or we're close enough (less than epsilon) to the surface (we have \"hit\" it)\n        if ((t > tMax) || (distance < epsilon))\n            break;\n\n        // march further along the ray with the maximal distance possible,\n        // which is distance to the closest surface from the actual position\n        // taken from the signed distance field describing the mandelbulb\n        // this ensures, that we haven't gone too far, so that we are not already inside the mandelbulb\n        t += distance;\n    }\n\n    // if we're not exceeded the maximum marching distance, return ray parameter t for\n    // computating the hit surface position\n    if( t < tMax )\n   \t\treturn t;\n    else\n        return -1.0;\t// we missed it, signal this with -1.0\n}\n\n\n// cheap distance field soft shadow computation\n// (see article \"free penumbra shadows for raymarching distance fields\":\n// https://iquilezles.org/articles/rmshadows)\nfloat softShadow(vec3 surfacePoint, vec3 lightDir)\n{\n    vec3 origin = surfacePoint + 0.001 * lightDir;\n\n    vec3 ro = origin;\n    vec3 rd = lightDir;\n\n\n    const float k = 2.0; // 8.0\n    float res = 1.0;\n\tfloat t = 0.0;\n\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n\n        if (h < 0.0001)\n            return 0.0;\n\n        if (t > 100.0)\n            break;\n\n        res = min(res, k * h / t);\n        t += h;\n    }\n\n    return res;\n}\n\n\n// numerically approximate normal via discrete gradient computation (first order)\nvec3 computeNormal(vec3 surfacePoint)\n{\n    const float epsilon =  0.001;\n\n    vec3 epsX = vec3(epsilon, 0.0, 0.0);\n    vec3 epsY = vec3(0.0, epsilon, 0.0);\n    vec3 epsZ = vec3(0.0, 0.0, epsilon);\n\n    float dx = map(surfacePoint + epsX) - map(surfacePoint - epsX);\n    float dy = map(surfacePoint + epsY) - map(surfacePoint - epsY);\n    float dz = map(surfacePoint + epsZ) - map(surfacePoint - epsZ);\n\n    vec3 n = normalize(vec3(dx, dy, dz));\n\n    return n;\n}\n\n\n// cheap distance field ambient occlusion computation\nfloat computeAO(vec3 surfacePoint, vec3 normal)\n{\n    const float k = 5.0;\n    const float delta = 0.005;\n\n    float sum = 0.0;\n\n    for(float i = 0.0; i < 10.0; i+=1.0)\n    {\n        float factor = 1.0 / pow(2.0, i);\n        vec3 samplePoint = surfacePoint + normal * i * delta;\n\n        sum += factor * (i * delta - map(samplePoint));\n    }\n\n    return 1.0 - k * sum;\n}\n\n\n// compute fragment color by raymarching the whole scene, given 2D coords\nvec3 raymarch(vec2 point)\n{\n    // scene parameters\n    const vec3 cameraLookAt = vec3(0.0, 0.1, 0.0);\n\n    const vec3 light1 = vec3(  0.577, 0.577, -0.577 );\n\tconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\tconst float fov = 1.2;\t// change for bigger field of view\n\n\n    // compute aspect ratio 'corrected' pixel position\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 xy = -1.0 + 2.0 * point.xy / iResolution.xy;\n\n    vec2 s = xy * vec2(aspectRatio, 1.0);\n\n\n    // slow down time ... (and start 30 s later)\n    float time = iTime * 0.5 + 16.0;\n\n\t// some magic for camera movement ...  (time dependent camera radius and rotations)\n\tfloat r = 2.3 + 0.1  * cos(0.29 * time);\n    vec3  ro = vec3( r * cos(0.33 * time), 0.8 * r * sin(0.37 * time), r * sin(0.31 * time) ); // ray origin\n\tfloat cr = 0.5 * cos(0.1 * time);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\n    // compute orthonormal camera basis\n    vec3 cameraDir = normalize(cameraLookAt - ro);\n\tvec3 cameraRight = normalize(cross(cameraDir, cp));\n\tvec3 cameraUp = normalize(cross(cameraRight, cameraDir));\n\n    // compute ray direction for perspective camera\n\tvec3 rd = normalize( s.x  * cameraUp + s.y * cameraRight + fov * cameraDir );\n\n\n\tvec3 col;\n\tvec3 tra;\n\n    // intersect ray (ray origin (ro), ray direction (rd) with scene,\n    // get ray parameter t for determining hit surface point\n    float t = intersect(ro, rd);\n\t\t\n\t\t\n    // nothing hit -> background color based on ray direction\n    if( t < 0.0 )\n        col = skyColor(rd);\n\telse\n\t{\n        // hit at t, compute position, normal, reflection, usw. (see links above)\n\t\tvec3 pos = ro + t * rd;\n        vec3 nor = computeNormal(pos);\n        vec3 hal = normalize( light1 - rd);\n        vec3 ref = reflect( rd, nor );\n\n        // for using resoluts of orbit traps for color\n\t\tfloat trc = 0.1 * log(dr);\n\n        // position based color for 'colorful' coloration :-)\n        tra = vec3(trc, trc, 0) * abs(pos);\n\n\n        col = vec3(0.7, 0.2, 0.2);\n\t\tcol = mix( col, vec3(1.0, 0.5, 0.2), sqrt(tra.y) );\n\t\tcol = mix( col, vec3(1.0, 1.0, 1.0), tra.x );\n\n        // compute diffuse components from both lights\n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n\n        // add other lighting components (ambient occlusion, softshadows, specular)\n        // see iq article (https://iquilezles.org/articles/outdoorslighting)\n        float occ =  0.05 * computeAO(pos, nor);\n        float sha = softShadow(pos, light1);\n        float fre = 0.04 + 0.96 * pow( clamp(1.0 - dot(-rd, nor), 0.0, 1.0), 5.0 );\n        float spe = pow( clamp(dot(nor, hal),0.0, 1.0), 12.0 ) * dif1 * fre * 8.0;\n\n        // some color magic\n        // 'good artists copy, great artists steal' - this is stolen from:\n        // https://www.shadertoy.com/view/ltfSWn\n\t\tvec3 lin  = 1.5 * vec3(0.15, 0.20, 0.23) * (0.7 + 0.3 * nor.y) * (0.2 + 0.8 * occ);\n\t\t     lin += 3.5 * vec3(1.00, 0.90, 0.60) * dif1 * sha;\n\t\t     lin += 4.1 * vec3(0.14, 0.14, 0.14) * dif2 * occ;\n             lin += 2.0 * vec3(1.00, 1.00, 1.00) * spe * sha * occ;\n             lin += 2.0 * vec3(0.20, 0.30, 0.40) * (0.02 + 0.98 * occ);\n             lin += 2.0 * vec3(0.8, 0.9, 1.0) * smoothstep( 0.0, 1.0, ref.y ) * occ;\n\n\t\tcol *= lin;\n        col += spe * 1.0 * occ * sha;\n\t}\n\n\n    // cheap gamma correction (for gamma = 1.0 / 2.0, close to 'official' lcd screen gamma = 1.0 / 2.2)\n\tcol = sqrt( col );\n\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n\n\n\tif(!ANTIALIASING)\n\t\t// single sample for speed\n\t\tcolor = raymarch(gl_FragCoord.xy);\n\telse\n    \t// 4x rotated-grid SSAA for antialiasing\n    \t// (taken from https://www.shadertoy.com/view/XsXXWS by Morgan3D)\n\t\tcolor =   (\traymarch(gl_FragCoord.xy + vec2(-0.125, -0.375)) +\n\t\t\t \t\traymarch(gl_FragCoord.xy + vec2(+0.375, -0.125)) +\n\t\t\t\t\traymarch(gl_FragCoord.xy + vec2(+0.125, +0.375)) +\n\t\t\t \t\traymarch(gl_FragCoord.xy + vec2(-0.375, +0.125))\t) / 4.0;\n\n\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}