{"ver":"0.1","info":{"id":"MXSBDc","date":"1730006472","viewed":26,"name":"First Noise","username":"zleong","description":"first noise shader created ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    uv *= 1.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâ€™s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n\nfloat surflet(vec2 P, vec2 gridPoint) {\n    // Compute falloff function by converting linear distance to a polynomial\n    float distX = abs(P.x - gridPoint.x);\n    float distY = abs(P.y - gridPoint.y);\n    float tX = 1.0 - 6.0 * pow(distX, 5.f) + 15.0 * pow(distX, 4.f) - 10.0 * pow(distX, 3.f);\n    float tY = 1.0 - 6.0 * pow(distY, 5.f) + 15.0 * pow(distY, 4.f) - 10.0 * pow(distY, 3.f);\n    // Get the random vector for the grid point\n    vec2 gradient = 2.f * random2(gridPoint) - vec2(1.f);\n    // Get the vector from the grid point to P\n    vec2 diff = P - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * tX * tY;\n}\n\nfloat perlinNoise(vec2 uv) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tsurfletSum += surflet(uv, floor(uv) + vec2(dx, dy));\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pn = perlinNoise(fragCoord/100.0+iTime);\n    \n    float wn = WorleyNoise(vec2(pn,pn)*fragCoord/100.f);\n\n    vec3 col = vec3(wn);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}