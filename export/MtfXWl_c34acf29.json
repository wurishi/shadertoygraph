{"ver":"0.1","info":{"id":"MtfXWl","date":"1440503761","viewed":161,"name":"PT V - R, T, S","username":"Piperoman","description":"Test to rotate, translate and scale in 2D","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["test","tutorial","nolook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n// Description: COORDINATE TRANSFORMATIONS: ROTATION, TRANSLATION, SCALATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n////////////////////////////////////////////\n// Function declaration\n////////////////////////////////////////////\nvoid rotateCoordinateSystem(inout vec2 q, in vec2 r, in float angle);\nvoid drawSmoothAxis(inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor);\nvoid drawSmoothCircle(inout vec3 pixel, in vec2 r, in vec2 center, in float radius, in float lineThickness, in bool inside, in vec3 color);\nvoid rotateCoordinateSystem(inout vec2 csR, in vec2 cs, in float angle);\nvoid translateCoordinateSystem(inout vec2 csT, in vec2 cs, in vec2 translation);\nvoid scaleCoordinateSystem(inout vec2 csS, in vec2 cs, in vec2 scale);\n\n////////////////////////////////////////////\n// Function implementation\n////////////////////////////////////////////\n\n/**\n* Function to rotate r to q, angle\n* q is the rotated coordinate system proyection sin & cos\n*/\nvoid rotateCoordinateSystem(inout vec2 csR, in vec2 cs, in float angle)\n{\n\tcsR.x =   cos(angle) * cs.x + sin(angle) * cs.y;\n\tcsR.y = - sin(angle) * cs.x + cos(angle) * cs.y;\n}\nvoid translateCoordinateSystem(inout vec2 csT, in vec2 cs, in vec2 translation)\n{\n\tcsT.x = cs.x - translation.x;\n\tcsT.y = cs.y - translation.y;\n}\nvoid scaleCoordinateSystem(inout vec2 csS, in vec2 cs, in vec2 scale)\n{\n\tcsS.x = scale.x * cs.x;\n\tcsS.y = scale.y * cs.y;\n}\n/**\n* Function that draws an (anti-aliased) grid of coordinate system\n*/\nvoid drawSmoothAxis(inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor)\n{\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) \n    {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n        pixel = mix(pixel, gridColor, ret * 0.01 );\n\t}\n\t// Draw the axes\n    ret = 0.0;\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\t\n    pixel = mix(pixel, axesColor, ret * 0.4 );\n}\n\nvoid drawSmoothCircle(inout vec3 pixel, in vec2 r, in vec2 center, in float radius, in float lineThickness, in bool inside, in vec3 color) \n{\n    float value;\n    if(inside)\n    {\n        // Inside a circle\n        value = 1.0 - smoothstep( radius-lineThickness, radius+lineThickness, length(r-center));\n    }\n    else\n    {\n        // Out of a circle\n        value = smoothstep( radius-lineThickness, radius+lineThickness, length(r-center));\n    }\n    pixel = mix(pixel, color, value);\n}\n// initPoint (x0, y0)\n// size (width, height)\nvoid drawSmoothRectangle(inout vec3 pixel, in vec2 r, in vec2 center, in vec2 size, in float lineThickness, in bool inside, in vec3 color) \n{\n    vec2 initPoint;\n    initPoint.x = center.x - size.x/2.0;\n    initPoint.y = center.y - size.y/2.0;\n    vec2 bottomRight;\n    bottomRight.x = initPoint.x + size.x;\n    bottomRight.y = initPoint.y + size.y;\n    float value;\n\tvalue = smoothstep(initPoint.x-lineThickness, initPoint.x+lineThickness, r.x);\n\tvalue *= smoothstep(initPoint.y-lineThickness, initPoint.y+lineThickness, r.y);\n\tvalue *= 1.0 - smoothstep(bottomRight.y-lineThickness, bottomRight.y+lineThickness, r.y);\n\tvalue *= 1.0 - smoothstep(bottomRight.x-lineThickness, bottomRight.x+lineThickness, r.x);\n    \n    pixel = mix(pixel, color, value);\n}\n\n// Blue static\n// Red rotate\n// Green translate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 cs =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\t// C.S\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\t// Basic variables\n    vec3 blackColor = vec3(0.0);\n    vec3 grayColor = vec3(0.5);\n    vec3 whiteColor = vec3(1.0);\n    vec3 redColor = vec3(1.0, 0.0, 0.0);\n    vec3 greenColor = vec3(0.0, 1.0, 0.0);\n    vec3 blueColor = vec3(0.0, 0.0, 1.0);\n    vec3 purpleColor = vec3(0.4, 0.05, 0.5);\n\t\n\tvec3 pixel = whiteColor;\n\t\n\tvec2 csR = cs;\t\t// C.S rotated\n    vec2 csT = cs; \t\t// C.S translated\n    vec2 csS = cs; \t\t// C.S scaled\n    \n\tfloat angle = 0.2*PI*sin(iTime);\n    float scaleFactor = 2.0 * (PI/2.0 + sin(iTime) );\n    vec2 translation = vec2(0.5*sin(iTime), 0.0);\n    \n    rotateCoordinateSystem(csR, cs, angle);\n    translateCoordinateSystem(csT, cs, translation);\n    scaleCoordinateSystem(csS, cs, vec2(scaleFactor, scaleFactor));\n    \n    //vec2 tq = q + t;\n\t\n    // Axis static and rotates\n    drawSmoothAxis(pixel, cs, blueColor, blueColor);\t\t// Axis without rotate\n    drawSmoothAxis(pixel, csR, redColor, redColor);\t\t\t// Axis angle-rotated\n\t\n\t// Circles, Normal, rotated, translated, and scaled\n    drawSmoothCircle(pixel, cs, vec2(-1.1,0.3), 0.25, 0.05, true, blueColor);\n    drawSmoothCircle(pixel, csR, vec2(-1.1,0.3), 0.2, 0.01, true, redColor);\n    drawSmoothCircle(pixel, csT, vec2(-1.1,0.3), 0.15, 0.01, true, greenColor);\n    drawSmoothCircle(pixel, csS, vec2(0.0,0.0), 0.15, 0.001, true, grayColor);\n    \n    // Circles, Normal, rotated, translated, and scaled\n    drawSmoothRectangle(pixel, cs, vec2(0.5, 0.5), vec2(0.3, 0.3), 0.05, true, blueColor);\n    drawSmoothRectangle(pixel, csR, vec2(0.5, 0.5), vec2(0.22, 0.22), 0.01, true, redColor);\n    drawSmoothRectangle(pixel, csT, vec2(0.5, 0.5), vec2(0.22, 0.22), 0.01, true, greenColor);\n    drawSmoothRectangle(pixel, csS, vec2(0.5, 0.0), vec2(0.4, 0.4), 0.001, true, grayColor);\n\t\t\n\tfragColor = vec4(pixel, 1.0);\n}","name":"","description":"","type":"image"}]}