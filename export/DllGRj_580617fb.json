{"ver":"0.1","info":{"id":"DllGRj","date":"1672055425","viewed":172,"name":"Skeleton rig animated","username":"EisernSchild","description":"Animated skeleton rig based on inverse kinematics.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","intersection","animation","inversekinematics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Skeleton rig animated\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    \"Skeleton rig animated\"\n    \n    Here is the prototype of an animated skeleton rig based\n    on inverse kinematics.\n    \n    See how he walks over a transparent obstacle, a good \n    example of how inverse kinematics can also be used when \n    climbing stairs or on rough terrain. \n    \n    For the math behind Inverse Kinetics read the\n    tutorial linked to :\n    \"Inverse Kinematics Tutorial\"\n    https://www.shadertoy.com/view/ctf3R4\n*/\n\n// here we have 16 joints and 15 bones\n#define JOINTS_N  16\n#define BONES_N 15\n\n// Joint indices (hex)\n//\n//         9           0    - tail\n//         2           1    - neck\n//   5 4 3 1 6 7 8     2    - throat\n//                     3..8 - arm l/r\n//         0           9    - head\n//       a   d         a..f - foot l/r\n//       b   e\n//       c   f\n\n// joint sphere radii\nconst float afJRad[JOINTS_N] = float[JOINTS_N](\n        .08f, .05f, .02f,                   // tail, neck, throat\n        .07f, .05f, .06f, .07f, .05f, .06f, // arms\n        .1f,                                // head\n        .05f, .05f, .1f, .05f, .05f, .1f    // feet\n        );\n        \n// bone joint indices\nconst int anJointIdc[BONES_N * 2] = int[BONES_N * 2](\n    0x0, 0x1,            // 0    .... spine        (joint 0-1)\n    0x1, 0x2, 0x2, 0x9,  // 1, 2 .... neck, head   (joint 1-2, 2-9)\n    0x1, 0x3, 0x1, 0x6,  // 3, 4 .... shoulder l/r (joint 1-3, 1-6)\n    0x3, 0x4, 0x4, 0x5,  // 5, 6 .... arm_l        (joint 3-4, 4-5)\n    0x6, 0x7, 0x7, 0x8,  // 7, 8 .... arm_r        (joint 6-7, 7-8)\n    0x0, 0xa, 0x0, 0xd,  // 9, a .... hip l/r      (joint 0-a, 0-d)\n    0xa, 0xb, 0xb, 0xc,  // b, c .... foot_l       (joint a-b, b-c)\n    0xd, 0xe, 0xe, 0xf); // d, e .... foot_r       (joint d-e, e-f)\n    \n// bone lengths\nconst float afBoneL[BONES_N] = float[BONES_N](\n        .5f, .1f, .18f,        // spine, neck, head\n        .2f, .2f,              // shoulders\n        .3f, .15f, .3f, .15f,  // arms\n        .15f, .15f,            // hips \n        .45f, .35f, .45f, .35f // feet\n        );\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n};\n\n// infinite cylinder \n// by iq : https://iquilezles.org/articles/intersectors/\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// axis aligned box centered at the origin, with size boxSize \n// by iq : https://iquilezles.org/articles/intersectors/\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) //, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    //outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n    //                       step(t2,vec3(tF));  // ro inside the box\n    //outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\n// simple checkers\nfloat checkers_001(vec2 vUv, float fDist)\n{\n    return mix(0.3, smoothstep(0.005, 0.005 + fDist * 0.005, min(fract(vUv.x), fract(vUv.y))) * (max(mod(floor(vUv.x), 2.), mod(floor(vUv.y), 2.)) * .25 + .75),\n        (1. - smoothstep(0.995 - fDist * 0.005, 0.995, max(fract(vUv.x), fract(vUv.y)))));\n}\n\n// simple floor (little knobs)\nfloat floor_knobbed(vec2 vPos)\n{\n\tfloat fH = 1.0;\n\tfH -= (max(sin(vPos.x * .5 + PI * .5) + cos(vPos.y * .5 - PI * 2.), 1.25) - 2.0) * 0.25;\n\treturn fH;\n}\n\n// simple floor (little knobs)\nvec3 floor_knobbed_nor(vec2 vPos)\n{\n    // perturbe by y axis\n    const vec2 vEps = vec2(.1f , 0);\n    const float fBumpF = .5f;\n    vec3 vP = vec3(0.f, floor_knobbed(vPos), 0.f);\n    vec3 vPX = vec3(0.f, floor_knobbed(vPos + vEps.xy), 0.f);\n    vec3 vPZ = vec3(0.f, floor_knobbed(vPos + vEps.yx), 0.f);\n    return normalize(vec3((vPX.y - vP.y) * fBumpF / vEps.x, 1., (vPZ.y - vP.y) * fBumpF  / vEps.x));\n}\n\n// simple hash float1<-float2\nfloat hash12(vec2 vP)\n{\n\tvec3 vP3  = fract(vec3(vP.xyx) * .1031);\n    vP3 += dot(vP3, vP3.yzx + 33.33);\n    return fract((vP3.x + vP3.y) * vP3.z);\n}\n\n// function from : https://www.shadertoy.com/view/4dsSzr\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\nvec3 desertGradient(float t) {\n\tfloat s = sqrt(clamp(1.0 - (t - 0.4) / 0.6, 0.0, 1.0));\n\tvec3 sky = sqrt(mix(vec3(1, 1, 1), vec3(0, 0.8, 1.0), smoothstep(0.4, 0.9, t)) * vec3(s, s, 1.0));\n\tvec3 land = mix(vec3(0.7, 0.3, 0.0), vec3(0.85, 0.75 + max(0.8 - t * 20.0, 0.0), 0.5), (t / 0.4)*(t / 0.4));\n\treturn clamp((t > 0.4) ? sky : land, 0.0, 1.0) * clamp(1.5 * (1.0 - abs(t - 0.4)), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 cOut, in vec2 vXY )\n{\n    /// ------- KINEMATICS\n\n    float fTme = iTime * 3.f * .4f;\n\n    // joint positions\n    vec3 avJPos[JOINTS_N];\n    \n    // left or right foot standing ?\n    bool bLR = (mod(floor(fTme), 2.f) < 1.f);\n    // obstacle ?\n    float fObstacle = (mod(fTme, 4.f) <= 2.f) ? min(sin(mod(fTme, 2.f) * PI * .4f), .2f) : 0.f;\n    \n    // left/right current (foot) target\n    vec3 avTarget[2] = vec3[2](\n        vec3(-.2f, .1f, floor(fTme)),\n        vec3(.2f, fObstacle + .1f, floor(fTme))\n    );\n    avTarget[0] += (bLR) ? vec3(.0f, .0f, .5f) : \n                           vec3(.0f, sin(fract(fTme) * PI) * .2f, -.5f + fract(fTme) * 2.f); \n    avTarget[1] += (bLR) ? vec3(.0f, sin(fract(fTme) * PI) * .2f, -.5f + fract(fTme) * 2.f) : \n                           vec3(.0f, .0f, .5f); \n\n    // set tail position \n    avJPos[0] = vec3(0.f, .8f + sin(fract(fTme) * PI) * .1f, fTme);\n    avJPos[0] += (!bLR) ? vec3(.0f, sin(fract(fTme) * PI) * fObstacle, 0.f) : vec3(0.f);\n    \n    // set hips (a, d joints - 9, a bones) XZ to right target\n    IK_MidCenterRotate(\n                avJPos[0xa], avJPos[0x0], avJPos[0xd],\n                vec2(afBoneL[0x9], afBoneL[0xa]),\n                mix(avJPos[0] + vec3(1.f, 0.f, 0.f), vec3(avTarget[0x1].x, avJPos[0].y, avTarget[1].z), .5f) \n                );\n                \n    // clamp feet to target ( a...f joints - b..e bones).. interchanged z<=>y\n    IK_ClampToTarget(avJPos[0xa].xzy, avJPos[0xb].xzy, avJPos[0xc].xzy,\n                    vec2(afBoneL[0xb], afBoneL[0xc]),\n                    avTarget[0].xzy, 0.f);\n    IK_ClampToTarget(avJPos[0xd].xzy, avJPos[0xe].xzy, avJPos[0xf].xzy,\n                    vec2(afBoneL[0xd], afBoneL[0xe]),\n                    avTarget[1].xzy, 0.f);\n                    \n    // spine, neck, head off tail towards up vector for now (clamp throat z<=>y)\n    IK_EndeffectorToTarget(avJPos[0x0], avJPos[0x1], afBoneL[0], avJPos[0x0] + vec3(.0f, 1.f, .0f));\n    IK_ClampToTarget(avJPos[0x1].xzy, avJPos[0x2].xzy, avJPos[0x9].xzy,\n                    vec2(afBoneL[0x1], afBoneL[0x2]),\n                    (avJPos[0x1].xzy + vec3(0.f, sin(fTme) * .1f, .25f)), PI);\n                    \n    // set shoulders viseverca direction to hips\n    IK_MidCenterRotate(\n                avJPos[0x3], avJPos[0x1], avJPos[0x6],\n                vec2(afBoneL[0x3], afBoneL[0x4]),\n                mix(avJPos[0x1] + vec3(1.f, 0.f, 0.f), vec3(avTarget[0x1].x, avJPos[0x1].y, avTarget[0].z), .5f) \n                );\n        \n    // swing the arms ... z<=>y\n    IK_ClampToTarget(avJPos[0x3].xzy, avJPos[0x4].xzy, avJPos[0x5].xzy,\n                    vec2(afBoneL[0x5], afBoneL[0x6]),\n                    avJPos[0x3].xzy + vec3(-.1f, sin(fTme * PI) * .5f, -.35f), PI);\n    IK_ClampToTarget(avJPos[0x6].xzy, avJPos[0x7].xzy, avJPos[0x8].xzy,\n                    vec2(afBoneL[0x7], afBoneL[0x8]),\n                    avJPos[0x6].xzy + vec3(.1f, sin(fTme * PI) * -.5f, -.35f), PI);\n    \n    /// ------- CAMERA\n    \n    // get current camera position and lookat matrix (to tail)\n    float fCamDist = 4.6f;\n    vec4 vCamPos = vec4(avJPos[0], 0.f) + vec4(sin(iTime * .2f) * fCamDist, 3.5f + sin(iTime * .3f) * .5f, cos(iTime * .2f) * fCamDist, 0.f);\n    vec3 vCamLAt = avJPos[0];\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vCamLAt, vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    /// ------- RAYTRACING\n    \n    // get ray\n    vec3 vOri, vDir;\n    TransformRay(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // do raytracing\n    bool bLeftRight = ((vXY.x/iResolution.x) < .5f);\n    Intersection asI[JOINTS_N + 1];\n        \n    asI[0] = iPlane(vOri, vDir);\n    for (int nIx = 0; nIx < JOINTS_N; nIx++)\n        asI[nIx + 1] = iSphere(vOri, vDir, avJPos[nIx], afJRad[nIx]);\n    \n    // get lit primitive index\n    int nTI = 0;\n    float fTHit = asI[0].vTen.x;\n    for(int nI = 1; nI < JOINTS_N + 1; nI++)\n    {\n        if (asI[nI].vTen.x > 0.)\n        {\n            if (fTHit > 0.)\n            {\n                if (asI[nI].vTen.x < fTHit) nTI = nI;\n            }\n            else nTI = nI;\n            \n            fTHit = asI[nTI].vTen.x;           \n        }\n    }\n    \n    // hit attributes\n    PosNorm sAttr;\n    sAttr.vPosition = asI[nTI].vTen.yzw;\n    sAttr.vNormal = asI[nTI].vNen;\n    \n    /// ------- TEXTURE\n    \n    if (nTI == 0) // floor\n    {\n        if (abs(sAttr.vPosition.x) < .485f)\n        {\n            // floor with knobs\n            cOut = mix(vec4(desertGradient(.1f), 1.f), vec4(1.f), max(.4f, smoothstep(.37f, .42f, abs(sAttr.vPosition.x))));\n            sAttr.vNormal = floor_knobbed_nor(sAttr.vPosition.xz * 120.f);\n        }\n        else\n        {\n            // simple coloring (dessert gradient)\n            float fTile = hash12(floor(sAttr.vPosition.xz * 1.5f));\n            cOut = vec4(mix(desertGradient(fTile), vec3(1.f), .4f), 1.f);\n            cOut.xyz *= checkers_001(sAttr.vPosition.xz * 2.f, fTHit);\n        }\n    }\n    else\n        cOut = vec4(desertGradient(.7f), 1.f);\n    \n    /// ------- LIGHTING \n    \n    vec3 cLit = Phong_PointLight(sAttr.vPosition, vCamLAt + vec3(2.f, 5.f, .4f), vOri, cOut.xyz, vDir, sAttr.vNormal);\n\n    // occlusion (distance, ground)\n    float fOcc = (1. - fTHit * .01);\n    float fOccD = 0.f;\n    if (nTI == 0)\n        for(int nI = 0; nI < JOINTS_N; nI++)\n        {\n            float fDXZ = length(sAttr.vPosition.xz - avJPos[nI].xz);\n            if (fDXZ < afJRad[nI])\n                fOccD = (avJPos[nI].y < afJRad[nI] + .32f) ? max(fOccD, ((afJRad[nI] - fDXZ) / (afJRad[nI] * .5f)) * (afJRad[nI] + .32f - avJPos[nI].y)) : fOccD;\n        }\n    fOcc -= fOccD;\n    cLit *= fOcc;\n    \n    /// ------- BONE LASER BEAMS\n    \n    for(int nI = 0; nI < BONES_N; nI++)\n    {\n        // get infinite cylinder\n        vec2 vTHitB = cylIntersect(vOri, vDir, avJPos[anJointIdc[nI*2]], normalize(avJPos[anJointIdc[nI*2+1]] - avJPos[anJointIdc[nI*2]]), .02f);\n        if ((vTHitB.x > 0.f) && (vTHitB.x < fTHit))\n        {\n            // clamp cylinder between joints\n            float fTHitB = (vTHitB.x + vTHitB.y) * .5f;\n            vec3 vPB = vOri + vDir * fTHitB;\n            float fBA = length(avJPos[anJointIdc[nI*2]] - vPB);\n            float fBB = length(avJPos[anJointIdc[nI*2+1]] - vPB);\n            float fAB = length(avJPos[anJointIdc[nI*2]] - avJPos[anJointIdc[nI*2+1]]) * .89f;\n            if ((fBA < fAB) && (fBB < fAB))\n                cLit = mix(cLit, vec3(.5f, 1.f, .7f), pow(abs(vTHitB.x - min(vTHitB.y, fTHit)) / .02f, 1.2f) * .1f);\n        }\n    }\n    \n    /// -------- OBSTACLE\n    if ((mod(fTme, 4.f) < 2.f) && (mod(fTme, 4.f) > 1.f))\n    {\n        // get infinite cylinder\n        vec3 vTar = vec3(.2f, .1f, .5f + floor(fTme));\n        vec2 vTHitB = boxIntersection(vOri - vTar, vDir, vec3(.2f));\n        if ((vTHitB.x > 0.f) && (vTHitB.x < fTHit))\n        {\n            // clamp cylinder\n            float fTHitB = (vTHitB.x + vTHitB.y) * .5f;\n            cLit = mix(cLit, vec3(.0f, .7f, 1.0f), pow(abs(vTHitB.x - min(vTHitB.y, fTHit)) / .2f, 1.2f) * .1f);\n        }\n    }\n    \n\tcOut = vec4(clamp(cLit, 0.f, 1.f), 1.f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// EisernSchild 3D library\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// uses code with following rights :\n// Copyright (c) Microsoft\n// \n// SPDX-License-Identifier: MIT\n\n// ############################ Math\n\n#define PI 3.141592654f\n\n// Orthographic projection : ba = (b.an)an\nvec2 ortho_proj(vec2 vA, vec2 vB)\n{\n    vec2 vAn = normalize(vA);\n    return dot(vB, vAn) * vAn;\n}\n\nvec3 ortho_proj(vec3 vA, vec3 vB)\n{\n    vec3 vAn = normalize(vA);\n    return dot(vB, vAn) * vAn;\n}\n\n// rotate 2D\nvec2 rotate(vec2 vV, float fA) \n{\n\tfloat fS = sin(fA);\n\tfloat fC = cos(fA);\n\tmat2 mR = mat2(fC, -fS, fS, fC);\n\treturn mR * vV;\n}\n\n// ############################ Transform\n\n// y rotation matrix\nmat3 Rotate3dX(float fAng) \n{\n  float fS = sin(fAng);\n  float fC = cos(fAng);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, fC, fS,\n    0.0, -fS, fC\n  );\n}\n\n// y rotation matrix\nmat3 Rotate3dY(float fAng) \n{\n  float fS = sin(fAng);\n  float fC = cos(fAng);\n\n  return mat3(\n    fC, 0.0, -fS,\n    0.0, 1.0, 0.0,\n    fS, 0.0, fC\n  );\n}\n\n// z rotation matrix\nmat3 Rotate3dZ(float fAng) \n{\n  float fS = sin(fAng);\n  float fC = cos(fAng);\n\n  return mat3(\n    fC, fS, 0.f,\n    -fS, fC, 0.f,\n    0.f, 0.f, 1.f\n  );\n}\n\n// rotate vector by y axis\nvec3 RotateX(vec3 v, float fAng) { return Rotate3dX(fAng) * v; }\n// rotate vector by y axis\nvec3 RotateY(vec3 v, float fAng) { return Rotate3dY(fAng) * v; }\n// rotate vector by z axis\nvec3 RotateZ(vec3 v, float fAng) { return Rotate3dZ(fAng) * v; }\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;  \n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid TransformRay(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// ############################ Lighting\n\n// phong pointlight.. in Position Texel, Light, Camera, Material Color, Ray Direction, Normal\n// inspired by Shane's lighting model\nvec3 Phong_PointLight(vec3 vPosTex, vec3 vPosLig, vec3 vPosCam, vec3 cMat, vec3 vDir, vec3 vNor)\n{\n    const float fAmbient = .2f;\n    const float fAttenuation = .005f;\n        \n    // light direction, distance\n\tvec3 vLDir = vPosTex - vPosLig;\n\tfloat fLDist = max(length(vLDir), .001f);\n\tvLDir /= fLDist;\n\n\t// ambient, diffuse, attenuation, specular\n\tfloat fDif = max(dot(-vLDir, vNor), 0.f);\n\tfDif = pow(fDif, 2.f) * .6f + pow(fDif, 4.f) * .2f + pow(fDif, 8.f) * .2f;\n\tfloat fAtt = 1. / (1. + fLDist * fLDist * fAttenuation);\n\tvec3 vRef = reflect(vLDir, vNor);\n\tfloat fSpec = pow(max(dot(-vDir, vRef), 0.0), 32.f);\n\n\treturn clamp(((cMat * max(fDif, fAmbient)) + fSpec * .5f) * fAtt, 0.f, 1.f);\n}\n\n// ############################ Inverse Kinetics\n\n// if exactness is given, the target may not be hit exactly when rotated\n#define IK_EXACT 0\n\nvoid IK_EndEffectorToTargetAngles(\n    in vec3 vTar,     /* <= base to target local vector */\n    in float fA,      /* <= length of bone 1 */\n    in float fB,      /* <= length base->target (=length(vTar)) */\n    in float fC,      /* <= length of bone 0 */\n    out float fAlpha, /* <= local space rotation Z angle base joint */\n    out float fBeta,  /* <= local space rotation Z angle mid joint */\n    out float fGamma) /* <= local space rotation Y angle base joint */\n{\n    // triangle angles\n    \n    // arccos(b*b + c*c - a*a) / 2bc\n    fAlpha = acos((fB * fB + fC * fC - fA * fA) / (2.f * fB * fC) );\n    // arccos(a*a + c*c - b*b) / 2ac\n    fBeta = acos((fA * fA + fC * fC - fB * fB) / (2.f * fA * fC) );\n        \n    // triangle angles to local angles\n    \n    // arctan(cy-dy / length(ad))\n    fAlpha = fAlpha + atan(vTar.y/ length(vTar.xz));\n    // PI - beta\n    fBeta = abs(PI - fBeta);\n    \n    // Y rotation\n    \n    // -arctan(z / y)\n    fGamma = -atan(vTar.z / vTar.x);\n    fGamma = (vTar.x < 0.f) ? PI + fGamma: fGamma;    \n}\n\n// clamp end effector and mid joint between base joint and target\nvoid IK_ClampToTarget(\n                in    vec3 vJBaseP,  /*<= Base joint position */\n                inout vec3 vJMidP,   /*<= Mid joint position */\n                inout vec3 vJEEfP,   /*<= End effector joint position */\n                in    vec2 sBoneL,   /*<= Bone lengths (x - base; y - endeff) */\n                in    vec3 vTarget,  /*<= Target position */\n                in   float fRotMid   /*<= rotate mid joint around target axis */\n                )\n{\n    // get triangle lengths\n    vec3 vTar = vTarget - vJBaseP;\n    float fA = sBoneL.y;\n    float fB = length(vTar);\n    float fC = sBoneL.x;\n    \n    // target too far ?\n    if ((fA + fC) <= fB)\n    {\n        vTar = normalize(vTar);\n        vJMidP = vJBaseP + vTar * fC; \n        vJEEfP = vJMidP + vTar * fA;\n        return;\n    }\n    \n    // angles to local space rotations\n    float fAlpha, fBeta, fGamma;\n    \n    // calculate angles\n    IK_EndEffectorToTargetAngles(vTar, fA, fB, fC, fAlpha, fBeta, fGamma);\n\n    // mid joint rotation ?\n    if (fRotMid == 0.f)\n    {\n        // get joint positions\n        vJMidP = vJBaseP + RotateY(RotateZ(vec3(sBoneL.x, 0.f, 0.f), fAlpha), fGamma); \n        vJEEfP = vJMidP + RotateY(RotateZ(vec3(sBoneL.y, 0.f, 0.f), fAlpha - fBeta), fGamma);\n    }\n    else\n    {\n        // get joint positions... in x direction\n        vec3 vJMidP1 = RotateZ(vec3(sBoneL.x, 0.f, 0.f), fAlpha); \n        vJEEfP = vJMidP1 + RotateZ(vec3(sBoneL.y, 0.f, 0.f), fAlpha - fBeta);\n\n        // rotate mid to triangle, rotate x, rotate back, rotate y\n        float fAngBE = atan(vJEEfP.y / vJEEfP.x);\n        vJMidP = vJBaseP + RotateY(RotateZ(RotateX(RotateZ(vJMidP1, -fAngBE), fRotMid), fAngBE), fGamma);\n        #if (IK_EXACT == 0)\n        vJEEfP = vJMidP + normalize(vTarget - vJMidP) * sBoneL.y;\n        #elif (IK_EXACT == 1)\n        vJEEfP = vJMidP + RotateY(RotateZ(RotateX(RotateZ(vJEEfP - vJMidP1, -fAngBE), fRotMid), fAngBE), fGamma);\n        #else\n        vJEEfP = vJBaseP + RotateY(vJEEfP, fGamma);\n        #endif\n    }\n}\n\n// end effector to target, align base to opposite direction\nvoid IK_MidCenterRotate(\n                inout vec3 vJBaseP,  /*<= Base joint position */\n                in    vec3 vJMidP,   /*<= Mid joint position */\n                inout vec3 vJEEfP,   /*<= End effector joint position */\n                in    vec2 sBoneL,   /*<= Bone lengths (x - base; y - endeff) */\n                in    vec3 vTarget   /*<= Target position */\n                )\n{\n    vec3 vDir = normalize(vTarget - vJMidP);\n    vJEEfP = vJMidP + vDir * sBoneL.y;\n    vJBaseP = vJMidP - vDir * sBoneL.x;\n}\n\n// end effector to target\nvoid IK_EndeffectorToTarget(\n                in    vec3  vJBaseP,  /*<= Base joint position */\n                inout vec3  vJEEfP,   /*<= End effector joint position */\n                in    float fBoneL,   /*<= Bone length */\n                in    vec3  vTarget   /*<= Target position */\n                )\n{\n    vec3 vDir = normalize(vTarget - vJBaseP);\n    vJEEfP = vJBaseP + vDir * fBoneL;\n}\n\n// ############################ Intersection\n\n// intersection\nstruct Intersection\n{\n    // hit entry, exit (T + position)\n    vec4 vTen, vTex;\n    // normal entry, exit\n    vec3 vNen, vNex;\n};\n\nIntersection iPlane(in vec3 vOri, in vec3 vDir)\n{\n    // ortho project up-origin/up-dir\n    float fT = -vOri.y/vDir.y;\n    vec3 vHPos = vOri + fT * vDir;\n    \n    return Intersection( vec4(fT, vHPos), \n                        vec4(-fT, vHPos),\n                        vec3(0.f, 1.f, 0.f),\n                        vec3(0.f, -1.f, 0.f));\n}\n\nIntersection iSphere(in vec3 vOri, in vec3 vDir, in vec3 vCen, float fRad)\n{\n    // get local origin\n    vec3 vOriL = vOri - vCen;\n    \n    // ortho project local origin->direction\n    float fOD = dot(vOriL, vDir);\n    \n    // square distance origin->center minus radius\n    float fOR = dot(vOriL, vOriL) - fRad*fRad;\n    \n    // square hit center (!)\n    float fTHitS = fOD*fOD - fOR;\n    \n    // no intersection\n    Intersection sRet = Intersection( vec4(-1.f), vec4(-1.f), vec3(0.f), vec3(0.f));\n    if( fTHitS < .0f ) return sRet;\n    \n    // hit distance to center disk\n    fTHitS = sqrt(fTHitS);\n    \n    // hit vector + position\n    sRet.vTen.x = -fOD - fTHitS;\n    sRet.vTex.x = -fOD + fTHitS;\n    sRet.vTen.yzw = vOri + vDir * sRet.vTen.x;\n    sRet.vTex.yzw = vOri + vDir * sRet.vTex.x;\n    \n    // normals\n    sRet.vNen = normalize(sRet.vTen.yzw - vCen);\n    sRet.vNex = normalize(sRet.vTex.yzw - vCen);\n\n    // return with normals\n    return sRet;\n}","name":"Common","description":"","type":"common"}]}