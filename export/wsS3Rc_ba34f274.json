{"ver":"0.1","info":{"id":"wsS3Rc","date":"1549509099","viewed":273,"name":"Volumetric Sunbeams","username":"scratch13764","description":"Let it render, it takes under a minute at 60FPS but it varies. It layers each slice on top of the previous slices, and then checks each point for shadows. Basically a CT scan of the whole scene.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["light","volumetric","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ViewDist 15.\n#define StepSize 0.0025\n\nbool Intersect (vec3 p)\n{\n    float a = abs(p.z-3.)-.2;\n    a = max(a, .35-texture(iChannel1, p.xy/300.).x);\n    a = min(a, p.z + 3. - sin(p.x)/3. + sin(p.x+p.y)/5.);\n    if(a <= 0.) return true;\n    else return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    float frame = float(iFrame - 1);\n    if(frame > ViewDist/StepSize) discard;\n    float Dist = ViewDist-StepSize*frame;\n    vec3 Cam = vec3(0,-10,0);\n    vec3 RayStep = vec3(uv.x,1,uv.y);\n    vec3 Point = Cam+RayStep*Dist;\n    float Shade = 1.-Dist/ViewDist;\n    vec4 TextureCol = texture(iChannel2, Point.xy/2.);\n    if (Point.z < 0.) TextureCol *= vec4(1.,.8,.2,1);\n    vec4 PointCol = mix(vec4(.2,.2,.4,1), TextureCol, Shade);\n    \n    float Opacity = StepSize/120.;\n    float i = .05;\n    if (Intersect(Point)) Opacity = .65; //Using partial opacity for solid objects adds some antialaising\n    //Create fog\n    for(i; i <= 15.; i += 0.005)\n    {\n        if(Intersect(vec3(Point.x+i/3.,Point.y,Point.z+i)) || Point.z+i >= 3.) break;\n        if (abs(Point.z+i) < 2.5) i += 2.5-Point.z-i; //Jumps the big gap between the planes.\n    }\n    if(Point.z+i >= 3.) \n    {\n        if (Intersect(Point))\n        {\n            PointCol *= 1.5;\n        }\n        else\n        {\n            Opacity = StepSize/15.;\n            PointCol = vec4(1);\n        }\n    }\n    \n    \n    if (iFrame == 0) fragColor = vec4(.2,.2,.4,1); //Frame 1 color is black now.\n    else\n    fragColor = mix(texture(iChannel0,fragCoord/iResolution.xy), PointCol, Opacity);\n}","name":"Buffer A","description":"","type":"buffer"}]}