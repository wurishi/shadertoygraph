{"ver":"0.1","info":{"id":"NdtXD7","date":"1633994683","viewed":399,"name":"Journey to the Isle of the Dead","username":"SimonL","description":"Code by Simon LUCAS - 12/10/2021\nShader inspired by the painting \"Isle of the Dead\" from Arnold Boecklin (https://google.com/search?q=isle+of+the+dead)\n","likes":31,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","waves","fbm","water","painting","tree","island","rock","creative","isle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Simon LUCAS - 12/10/2021\n// Shader based on the painting \"Isle of the Dead\" from Arnold Boecklin (https://google.com/search?q=isle+of+the+dead)\n\n// Any advice is welcome, especially on performance and compile time. \n// I had to do some weird stuff to reach 60 fps on my PC but I have no clue how to reduce compilation time. \n// I hope it works well enough for you ^_^\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    // BLUR\n    vec2 n = vec2(noise3D(vec3(uv*100.,iTime))-0.5)/iResolution.xy;\n    fragColor.xyz += 0.85 * texture(iChannel0,uv + 2.* n).xyz;\n    fragColor.xyz += 0.10 * texture(iChannel0,uv + 4.* n).xyz;\n    fragColor.xyz += 0.05 * texture(iChannel0,uv + 8.* n).xyz;\n  \n    // GAMMA CORRECTION\n    fragColor.xyz = pow(fragColor.xyz,vec3(0.4545));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define rot(an) mat2(cos(an),-sin(an),sin(an),cos(an))\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat hash(vec2 p)\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\nvec3 hash3(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n\n// https://www.shadertoy.com/view/ld3Szs\nfloat noise3D(in vec3 p)\n{\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip;\n\tp = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/fbmsdf\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.5)\n    #define D(i,f,c) sdBox(f-c,vec3(RAD(hash(i+c)) ))\n    \n    return min(min(min(D(i,f,vec3(0,0,0)),\n                       D(i,f,vec3(0,0,1))),\n                   min(D(i,f,vec3(0,1,0)),\n                       D(i,f,vec3(0,1,1)))),\n               min(min(D(i,f,vec3(1,0,0)),\n                       D(i,f,vec3(1,0,1))),\n                   min(D(i,f,vec3(1,1,0)),\n                       D(i,f,vec3(1,1,1)))));\n\n}\n\nfloat sdFbm( vec3 p, float d )\n{\n   float s = 1.;\n   for( int i=0; i<3; i++ )\n   {\n       // evaluate new octave\n       float n = s*sdBase(p*0.5);\n\t\n       // add\n       n = smax(n,d-0.2*s,0.3*s);\n       d = smin(n,d      ,0.2*s);\n\t\n       // prepare next octave\n       p = mat3( 0.00, 1.60, 1.20,\n                -1.60, 0.72,-0.96,\n                -1.20,-0.96, 1.28 )*p;\n       s *= 0.5;\n   }\n   return d;\n}\n\nfloat fbm(in vec3 p, in float a, in float f, in vec3 off)\n{\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float n = pow(noise3D(p * frq-off),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n\n//https://www.shadertoy.com/view/WlfXRN\nvec3 inferno(float t) {\n\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Code by Simon LUCAS - 12/10/2021\n// Shader based on the painting \"Isle of the Dead\" from Arnold Boecklin (https://google.com/search?q=isle+of+the+dead)\n\n// Any advice is welcome, especially on performance and compile time. \n// I had to do some weird stuff to reach 60 fps on my PC but I have no clue how to reduce compilation time. \n// I hope it works well enough for you ^_^\n\n#define ANIM 1\n#define SAVE_PERF 1\n#define PREVISU 0\n#define SHOW_ITER 0\n\n#define TMAX 24.0\n#define IMAX 96\n\n#define TIME (iTime)\n\nfloat tree(in vec3 p, in vec2 id)\n{\n    id *= 0.01;\n    float x0 = hash(id);\n    float x1 = hash(id + 1.);\n    float x2 = hash(id + 59.);\n        \n    float an = pow(p.y * p.y * 0.03,sin(x0+TIME+165.153)*0.5+2.) + x0 * 0.1;\n    an += cos(noise3D(vec3(x0,TIME,0.)) * 3.141593) * 0.01;\n    \n    float s = 1. - x1 * 0.1;\n    float l = 1. + x2 * 1.;\n\n    p.x += 0.4*cos(x1 * 3.1415+2.);\n    p.z += 0.4*cos(x2 * 3.1415+1.);\n    \n    p.yx *= rot(an);\n\n    p.xz *= s;\n    p.y *= l;\n    \n    float d = 10000.;\n    \n    if(p.y < 1.)\n        d = length(p.xz) - 0.05;\n    \n    #define profile(x) pow(-1.5*x*x + 4.4*x,0.5)/(5.+2.*x)\n    \n    if(p.y < 3. && p.y > 0.3)\n        d = min(d,length(p.xz) - profile(p.y));\n    \n    p.y*=0.1;\n    d += noise3D(80.*p) * 0.01;\n    return d;\n}\n\nfloat grass(in vec3 p, in vec2 id)\n{\n    float x1 = hash(id/100. + 1.);\n    float x2 = hash(id/100. + 3.);\n\n    float s = 0.1 + x1 * 0.1;\n    float l = 0.01 + x2 * 0.1; \n\n    p.x += 0.04*cos(x1 * 3.1415+2.);\n    p.z += 0.04*cos(x2 * 3.1415+1.);\n\n    float d = 1000.;\n    if(p.y < 0.15 && p.y > 0.)\n        d = length(p.xz)-0.01+p.y*0.05;\n        \n    return d;\n}\n\n\nvec2 sdIsle( in vec3 p, in float osc )\n{\n    float d = 1000.;\n    float type = 1.;\n    vec2 id;\n    float s,dt;\n    vec3 ppp,pp = p;\n    \n    // STRUCTURES\n        // LEFT SIDE\n        pp.xz -= 5.;\n        pp.xz *= rot(3.141593*0.16);\n        \n        d = sdBox(pp - vec3(0.,0.95,-4.),vec3(0.2,0.95,5.))-0.15; \n        d = smin(d,sdBox(pp - vec3(0.,1.5,-6.5),vec3(0.2,1.5,1.)),1.1);        \n        d = smin(d,sdBox(pp - vec3(0.,1.5,-4.5),vec3(0.2,1.,1.)),0.8);     \n        d = smin(d,sdBox(pp - vec3(-0.6,0.4,-9.5),vec3(0.15,0.3,0.1)),0.95);\n        d = smin(d,sdBox(pp - vec3(-0.3,0.6,-9.),vec3(0.35,0.6,0.2)),0.75);\n        d = smax(d,-sdBox(pp - vec3(0.3,2.5,-9.1),vec3(0.15,0.3,0.2)),0.45);\n\n        // RIGHT SIDE\n        pp.xz *= rot(-3.141593*0.32);\n\n        d = smin(d,sdBox(pp - vec3(-4.,1.25,0.),vec3(5.,0.95,0.2)),1.);\n        d = smin(d,sdBox(pp - vec3(-3.,1.5,0.25),vec3(2.,1.45,0.5)),0.6); \n        d = smin(d,sdBox(pp - vec3(-6.,1.8,0.),vec3(2.,0.4,0.5)),0.8);      \n        d = smin(d,sdBox(pp - vec3(-8.0,0.5,-0.2),vec3(1.,0.4,0.5)),0.5);\n        d = smin(d,sdBox(pp - vec3(-9.,0.4,-0.8),vec3(0.2,0.4,0.2)),1.);\n        d = min(d,sdBox(pp - vec3(-10.,0.2,-1.5),vec3(0.1,0.2,0.1)));\n        \n        d  = sdFbm(pp-vec3(-4,0.,0.),d);\n        \n        // DOOR\n        dt        = sdBox(pp - vec3(-6.3,0.5,-0.1 ),vec3(0.4,0.75,0.5)); \n        float dtt =-sdBox(pp - vec3(-6.3,0.5,-0.7),vec3(0.33,0.6,0.4));\n\n        // FLOOR\n        pp = p;\n        pp.xz *= rot(3.141593*0.25);\n        ppp = pp;\n        ppp.x = abs(ppp.x);\n        d = min(d,sdBox(ppp - vec3(0.,0.08,2.),vec3(2.5,0.08,2.)));\n        d = min(d,sdBox(ppp - vec3(1.6,0.16,-0.),vec3(1.25,0.16,0.05))); \n        d = min(d,sdBox(ppp - vec3(0.45,0.18,-0.),vec3(0.15,0.18,0.15))); \n        d = min(d,sdBox(ppp - vec3(0.,0.04,-0.1),vec3(0.35,0.04,0.05)));\n\n        float pert = fbm(p*4.0,0.4,2.2,vec3(0.)) * 0.05;\n\n        d += pert;\n        dt+= pert * 0.25; // door\n\n        if(dt < d){\n            d = dt;\n            type = 4.;\n        }\n        d = max(d, dtt) ; // door\n    \n    \n    if(osc > 0.5){\n        // https://www.shadertoy.com/view/tlVGDc\n        float la = 0.07;\n        float lb = 0.55;\n        float h  = 0.1;\n        float ra = 0.1;\n        ppp = pp- vec3(1.25,0.,-1.25);\n        ppp.yz *= rot(sin(TIME*0.5)*0.07);\n        ppp.y += cos(TIME*0.5)*0.02+0.01;\n        ppp = abs(ppp);\n        \n        vec2 b = vec2(la,lb);\n        float f = clamp( (ndot(b,b-2.0*ppp.xz))/dot(b,b), -1.0, 1.0 );\n        vec2 q = vec2(length(ppp.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(ppp.x*b.y+ppp.z*b.x-b.x*b.y)-ra, ppp.y-h);\n        dt = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n        \n        if(dt < d){\n            d = dt;\n            type = 5.;\n        }\n    }\n    \n    // FOREST\n        pp -= vec3(0.3,0.08,1.5);\n        s = 0.5;\n        id = clamp(floor(pp.xz/s + 0.5),vec2(-2,-1),vec2(0.,5.));\n        pp.xz = pp.xz-s*id;\n\n        dt = 10000.;\n        for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n            dt = min(dt,tree(pp - s*vec3(i,0.,j),id + vec2(i,j)));\n        }}\n\n        if(dt < d){\n            d = dt;\n            type = 2.;\n        }\n    \n    \n    #if SAVE_PERF\n    \n    #else\n    // GRASS\n        s = 0.05;\n        id = clamp(floor(pp.xz/s + 0.5),vec2(-20,-18),vec2(10.,10.));\n        pp.xz = pp.xz-s*id;\n        pp.y -= 0.03;\n        \n        dt = 10000.;\n        for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n            dt = min(dt,grass(pp - s*vec3(i,0.,j),id + vec2(i,j)));\n        }}\n        if(dt < d){\n            d = dt;\n            type = 3.;\n        }\n    #endif\n    \n    return vec2(d,type);\n}\n\n\nvec2 sdIsleLow( in vec3 p, in float osc )\n{\n    float d = 1000.;\n    float type = 1.;\n    vec2 id;\n    float s,dt;\n    vec3 ppp,pp = p;\n    \n    {   // STRUCTURES\n        // LEFT SIDE\n        pp.xz -= 5.;\n        pp.xz *= rot(3.141593*0.16);\n        \n        d = sdBox(pp - vec3(0.,0.95,-4.),vec3(0.2,0.95,5.))-0.15;   \n        d = smin(d,sdBox(pp - vec3(0.,1.5,-6.5),vec3(0.2,1.5,1.)),1.1);    \n        d = smin(d,sdBox(pp - vec3(0.,1.5,-4.5),vec3(0.2,1.,1.)),0.8);        \n        d = smin(d,sdBox(pp - vec3(-0.6,0.4,-9.5),vec3(0.15,0.3,0.1)),0.95);\n        d = smin(d,sdBox(pp - vec3(-0.3,0.6,-9.),vec3(0.35,0.6,0.2)),0.75); \n        d = smax(d,-sdBox(pp - vec3(0.3,2.5,-9.1),vec3(0.15,0.3,0.2)),0.45); \n\n        // RIGHT SIDE\n        pp.xz *= rot(-3.141593*0.32);\n\n        d = smin(d,sdBox(pp - vec3(-4.,1.25,0.),vec3(5.,0.95,0.2)),1.); \n        d = smin(d,sdBox(pp - vec3(-3.,1.5,0.25),vec3(2.,1.45,0.5)),0.6);\n        d = smin(d,sdBox(pp - vec3(-6.,1.8,0.),vec3(2.,0.4,0.5)),0.8);      \n        d = smin(d,sdBox(pp - vec3(-8.0,0.5,-0.2),vec3(1.,0.4,0.5)),0.5);\n        d = smin(d,sdBox(pp - vec3(-9.,0.4,-0.8),vec3(0.2,0.4,0.2)),1.); \n        d = min(d,sdBox(pp - vec3(-10.,0.2,-1.5),vec3(0.1,0.2,0.1))); \n       \n        // FLOOR\n        pp = p;\n        pp.xz *= rot(3.141593*0.25);\n        ppp = pp;\n        ppp.x = abs(ppp.x);\n        d = min(d,sdBox(ppp - vec3(1.6,0.16,-0.),vec3(1.25,0.16,0.05))); \n        d = min(d,sdBox(ppp - vec3(0.45,0.18,-0.),vec3(0.15,0.18,0.15))); \n        d = min(d,sdBox(ppp - vec3(0.,0.04,-0.1),vec3(0.35,0.04,0.05)));\n\n    }    \n    \n    return vec2(d,type);\n}\n\n\nfloat sdSea( in vec3 pos )\n{\n    return pos.y-fbm(vec3(pos.x,0.,pos.z),1.,2.01,vec3(TIME*2.,-TIME,TIME*2.))*0.03;\n}\n\n\n#define EPS 0.001\n//https://iquilezles.org/articles/normalsSDF\nvec3 normalIsle( in vec3 pos, in float osc )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;\n    return normalize( e.xyy*sdIsle( pos + e.xyy, osc ).x + \n\t\t\t\t\t  e.yyx*sdIsle( pos + e.yyx, osc ).x + \n\t\t\t\t\t  e.yxy*sdIsle( pos + e.yxy, osc ).x + \n\t\t\t\t\t  e.xxx*sdIsle( pos + e.xxx, osc ).x );\n}\n\nvec3 normalIsleLow( in vec3 pos, in float osc )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;\n    return normalize( e.xyy*sdIsleLow( pos + e.xyy, osc ).x + \n\t\t\t\t\t  e.yyx*sdIsleLow( pos + e.yyx, osc ).x + \n\t\t\t\t\t  e.yxy*sdIsleLow( pos + e.yxy, osc ).x + \n\t\t\t\t\t  e.xxx*sdIsleLow( pos + e.xxx, osc ).x );\n}\n\nvec3 normalSea( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;\n    return normalize( e.xyy*sdSea( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sdSea( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sdSea( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sdSea( pos + e.xxx ) );\n}\n\n\nvec2 traceAll(in vec3 ro, in vec3 rd, in vec2 uv, in float osc)\n{\n    vec2 t = vec2(1.,1.);\n    vec3 pos;\n    vec2 hI;\n    float hS,h,type;\n    \n    // Select regions where to launch rays\n    bool b1 = uv.y > -0.4;\n    bool b2 = uv.y < -0.84 || uv.y > 0.86 || uv.x < -1.6 || uv.x > 1.63;\n    b2 = b2 || !(length((uv-vec2(-1.91,-0.54))*vec2(1.,0.65)) > 0.4);\n    b2 = b2 || !(length((uv-vec2(1.89,-0.59))*vec2(1.,0.65)) > 0.3);\n    b2 = b2 || !(length((uv-vec2(-1.61,0.74))*vec2(1.,1.)) > 0.4);\n    b2 = b2 || ((uv.y > 0.71)&&(uv.x > -0.6));\n    \n    if(rd.y < -0.0001){ // Sends the rays to the sea surface\n        t.x = (0.1 - ro.y)/rd.y;\n    }\n    if(!b2){ // Sends the rays to the structures of the island\n        t.x = min(t.x,min((-1.5 - ro.z)/rd.z, (-0.5 - ro.x)/rd.x));\n    }\n    int i=0;\n    for( ; i<96 && t.x < TMAX; i++ ) // Raymarch\n    {\n        pos = ro + rd*t.x;\n        hS = b1 ? 1000. : sdSea(pos);\n        hI = b2 ? vec2(1000.,1.): sdIsle(pos,osc);\n        h = min(hI.x,hS);\n        if( h<0.001 ) {t.y = hS == h ? 0. : hI.y; break;}\n        t.x += h;\n    }\n    \n    #if SHOW_ITER\n    t.y = float(i);\n    #endif\n    return t;\n}\n\nvec2 traceIsle(in vec3 ro, in vec3 rd, in float osc)\n{\n    vec2 h,t = vec2(1.0);\n    vec3 pos;\n    for( int i=0; i<26 && t.x < TMAX; i++ )\n    {\n        pos = ro + rd*t.x;\n        #if SAVE_PERF\n        h = sdIsleLow(pos,osc);\n        #else\n        h = sdIsle(pos,osc);\n        #endif\n        if( h.x<0.001 ) break;\n        t.x += h.x;\n        t.y = h.y;\n    }\n    return t;\n}\n\nvec3 sky(in vec3 rd)\n{\n    float i = fbm( rd*inversesqrt(rd.y),1.,2.01,vec3(0.,iTime*0.25,0.) ) * rd.y * 7.;\n    i = 1.-exp(-max(i-0.15,0.)*0.45);\n    return mix(vec3(0.067,0.078,0.095), vec3(0.322,0.329,0.278), i);\n}\n\nvec3 shadeIsle(in vec3 nor, in vec3 ld, in vec3 pos, in float type)\n{\n    vec3 dif = vec3(max(dot(nor,-ld),0.));\n    float att = smoothstep(0.,0.5,pow(distance(pos * vec3(0.153,0.337,0.153),vec3(0.4,0.1,0.4)),2.5));\n    \n    if( type == 1. ){ // ROCK\n        vec3 alb = mix(texture(iChannel1,pos.xy).xyz,mix(vec3(0.169,0.371,0.129),vec3(0.392,0.361,0.184),fbm(vec3(pos.xz,0.)*2.,1.,4.,vec3(0.))),abs(nor.y));\n        dif *= alb;\n    }\n    else if( type==2. || type == 3. ){ // TREE GRASS\n        dif = dif*mix(vec3(0.075,0.205,0.020),vec3(0.137,0.161,0.004),noise3D(vec3(pos.xz*5.,0.)));\n    }    \n    else if( type==4. ){ // DOOR\n        dif = dif*3.*texture(iChannel2,pos.xy).xyz;\n    } else {\n        dif = dif*vec3(0.051,0.039,0.035);\n    }\n    \n    return dif * att;\n}\n\nvec3 shadeSea(in vec3 nor, in vec3 ld, in vec3 pos, in vec3 rd, in float osc)\n{\n    // REFLECTION\n    vec3 rfl = reflect(rd,nor);\n    vec2 t = traceIsle(pos,rfl,osc);\n    \n    vec3 np = pos + rfl * t.x;\n    vec3 nn = normalIsleLow( np,osc );\n    vec3 col;\n    vec3 crfl;\n\tif ( t.x < TMAX )\n\t{\n     \tcrfl = shadeIsle(nn,ld,np,t.y)*0.9;\n\t} else {\n        crfl = sky(rfl);\n    }\n    \n    // COLOR\n\tfloat fre = pow(1.0-abs(dot(nor,rd)),5.0);\n    col = mix(vec3(0.027,0.035,0.039),crfl,fre);\n    // FOAM\n    col = mix(col,col+vec3(0.5),clamp(pos.y*20.-0.9,0.,1.));\n    // COAST\n    col = mix(vec3(0.5)+col,col,min(sdIsle(pos,osc).x * 10.,1.));\n    return col;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // CAMERA MOVEMENT\t\n    #if PREVISU\n    float an = 3.141593 * iMouse.x / iResolution.x *2.  - 3.141593;\n    #else\n    float an = 3.141593 + 3.141593/4. - 0.1;\n    #endif\n    vec3 ro = vec3( 14.5*sin(an), 1.1, 14.5*cos(an) );\n    ro.y += sin(iTime*0.5)*0.3;\n\n    vec3 ta = vec3( 0.0, 1.4, 0.0 );\n    // CAMERA\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,normalize(vec3(sin(iTime*0.3)*0.04,1.,0.0)) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // GENENERATE RAY\n    #if ANIM\n    float osc = cos(TIME*0.2+3.141593*0.5);\n    osc = osc*inversesqrt( osc*osc+0.0005 );\n    osc = osc*0.5 + 0.5;\n    #else\n    float osc = 0.;\n    #endif\n    p += hash3(iTime).xy*0.5/iResolution.xy;\n    vec3 rd = normalize( p.x*uu + p.y*vv + 7.*ww );\n    \n    #if PREVISU\n    vec3 ld = rd;\n    #else\n    #if ANIM\n    vec3 ld = mix(normalize(vec3(1. * cos(2.7),-2.,2. * sin(2.7))),normalize(vec3(1. * cos(2.7),-10.,2. * sin(2.7))),osc);\n    #else\n    vec3 ld = normalize(vec3(1. * cos(2.7),-2.,2. * sin(2.7)));\n    #endif\n    #endif\n\n    \n    // MISS COLOR\n    vec3 col = sky(rd);\n    \n    // RAYMARCH\n    vec2 t = traceAll(ro,rd,p,osc);\n    \n    #if SHOW_ITER\n    col = inferno(t.y/float(IMAX));\n    #else\n        \n    if( t.x < TMAX ) // INTERSECT SCENE\n    {\n        vec3 pos = ro + rd*t.x;\n        vec3 nor;\n        \n        float d = length(pos.xz);\n        \n        if(t.y > 0.){ // INTERSECT ISLE\n            nor = normalIsle(pos,osc);\n            float occ = clamp(0.4 + 0.6*nor.y, 0.0, 1.0);\n            col = shadeIsle(nor,ld,pos,t.y)*occ;\n        \n        } else { // INTERSECT SEA\n            nor = normalSea(pos);\n            col = shadeSea(nor,ld,pos,rd,osc);\n        }\n        \n        // SHADOW\n        float shadow = 1.;\n        t.x = 0.1;\n        for( int i=0; i<12 && t.x < TMAX; i++ )\n        {\n            pos = pos - ld *t.x;\n            float h = sdIsle(pos,osc).x;\n            \n            if( h<0.01 ) {\n                shadow = 0.;\n                break;\n            }\n            t.x += h;\n        }\n         \n        col *= shadow+0.1;\n        col = mix(col,vec3(0.067,0.078,0.110),1.-exp(-max((d-6.)*0.5,0.)));\n    }\n    \n    #if ANIM\n    col *= mix(vec3(1.5,0.9,0.6),vec3(0.357,0.392,0.684),osc);\n    #else\n    col *= vec3(1.5,0.9,0.6);\n    #endif\n    col = clamp(col,vec3(0.001),vec3(0.999));\n    #endif\n    \n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * (2.*(abs(0.5-osc))+49.)/50. + 0.5;\n    fragColor.xyz = mix(col,textureLod(iChannel0,uv,0.).xyz,0.75);\n\n}","name":"Buffer A","description":"","type":"buffer"}]}