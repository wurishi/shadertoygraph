{"ver":"0.1","info":{"id":"WsVBRh","date":"1606573539","viewed":70,"name":"My Shadow Shader","username":"PierceV32","description":"A shadow test, there are some issues with the shadows.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//frag0\n\nuniform sampler2D colorSampler;\nuniform vec2 size;\n\nconst float u_color_red = 1.0;\nconst float u_color_green = 0.0;\nconst float u_color_blue = 0.0;\nconst float u_orient_x = 0.0;\nconst float u_orient_y = 0.0;\nconst float u_orient_z = 0.0;\n\nconst float projA = 1.0101010101;\n\nconst float pi = 3.14159265359;\n\n//bool detect(vec2 pos)\n\n\n/*void main() {\n    vec3 frag = vec3(1.0);\n    float alpha = 1.0;\n\n\n    //vec2 pos = size * uv;\n    //vec2 inc = vec2(1.0)/size;\n    \n    \n    vec3 inputColor = texture2D(colorSampler, uv).rgb;\n    frag = inputColor;\n    \n    frag = vec3(1.0)-frag;\n\n    \n    gl_FragColor.rgb = frag;\n    gl_FragColor.a = alpha;\n\n}*/\n\n\n\n//NEWNEWNEW\n\nstruct Intersection\n{\n    vec3 pos;\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n    int tag;\n};\n\n\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat distance_from_box_rounded(in vec3 p, in vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat distance_from_box(in vec3 p, in vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distance_from_plane(in vec3 p, in vec3 n, float h)\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat distance_from_tet(vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat distance_from_triangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat distance_from_tet_2(vec3 p)\n{\n    //vertices\n    float scale = 3.0;\n    vec3 va = vec3(  0.0,  0.57735,  0.0 )*scale; //top center\n    vec3 vb = vec3(  0.0, -1.0,  1.15470 )*scale; //bottom back\n    vec3 vc = vec3(  1.0, -1.0, -0.57735 )*scale; //bottom right\n    vec3 vd = vec3( -1.0, -1.0, -0.57735 )*scale; //bottom left\n    \n    float dta = distance_from_triangle(p, va, vc, vd); //front\n    float dtb = distance_from_triangle(p, va, vd, vb); //left\n    float dtc = distance_from_triangle(p, va, vb, vc); //right\n    float dtd = distance_from_triangle(p, vd, vc, vb); //bottom\n    \n    float dist = dta;\n    if (dtb < dist) { dist = dtb; }\n    if (dtc < dist) { dist = dtc; }\n    if (dtd < dist) { dist = dtd; }\n    \n    return dist;\n}\n\nfloat distance_from_pyramid_2(in vec3 p)\n{\n    \n    //vertices\n    float scale = 2.0;\n    vec3 va = vec3(  0.0,  0.57735,  0.0 )*scale;\n    vec3 vb = vec3(  0.0, -1.0,  1.15470 )*scale;\n    vec3 vc = vec3(  1.0, -1.0, -0.57735 )*scale;\n    vec3 vd = vec3( -1.0, -1.0, -0.57735 )*scale;\n    \n    float a = 0.0;\n    float s = 1.0;\n    float r = 2.0;\n    float dm;\n    vec3 v;\n    for( int i=0; i<7; i++ )\n    {\n        float d, t;\n        d = dot(p-va,p-va);              v=va; dm=d; t=0.0;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }\n        d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }\n        d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }\n        p = v + 2.0*(p - v); r*= 2.0;\n        a = t + 4.0*a; s*= 4.0;\n    }\n\n    return vec2( (sqrt(dm)-1.0)/r, a/s ).x;\n}\n\nfloat distance_from_pyramid(in vec3 p)\n{\n    float Scale = 2.0;\n    int Iterations = 2;\n    vec3 z = p;\n    float v = 1.0;\n    float r = 1.0;\n    vec3 a1 = vec3(v,v,v);\n    vec3 a2 = vec3(-v,-v,v);\n    vec3 a3 = vec3(v,-v,-v);\n    vec3 a4 = vec3(-v,v,-v);\n    vec3 c;\n    int n = 0;\n    float dist, d;\n    \n    //NEW\n    while (n < Iterations) {\n        c = a1; dist = distance_from_sphere(z, c, r);\n        c = a2; d = distance_from_sphere(z, c, r); if (d < dist) { dist=d; }\n        c = a3; d = distance_from_sphere(z, c, r); if (d < dist) { dist=d; }\n        c = a4; d = distance_from_sphere(z, c, r); if (d < dist) { dist=d; }\n        z = Scale*z-c*(Scale-1.0);\n        //r = r / 2.0;\n        n++;\n    }\n\n    return dist; //length(z) * pow(Scale, float(-n));\n    \n    //OLD\n    /*while (n < Iterations) {\n        c = a1; dist = length(z-a1);\n        d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n        d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n        d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n        z = Scale*z-c*(Scale-1.0);\n        n++;\n    }\n\n    return length(z) * pow(Scale, float(-n));*/\n}\n\nvec3 op_rotate(in vec3 vector, in vec2 angle)\n{\n    vec3 v = vector;\n    v.yz = cos(angle.y)*v.yz+sin(angle.y)*vec2(-1.0,1.0)*v.zy;\n    v.xz = cos(angle.x)*v.xz+sin(angle.x)*vec2(-1.0,1.0)*v.zx;\n    return v;\n}\n\nvec3 op_twist(in vec3 p, in float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n/*vec3 op_transform(in vec3 p, in transform t, in sdf3d primitive)\n{\n    return primitive(invert(t)*p);\n}*/\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotationX( in float angle ) {\n    return mat4(    1.0,        0,            0,            0,\n                     0,     cos(angle),    -sin(angle),        0,\n                    0,     sin(angle),     cos(angle),        0,\n                    0,             0,              0,         1);\n}\n\nmat4 rotationY( in float angle ) {\n    return mat4(    cos(angle),        0,        sin(angle),    0,\n                             0,        1.0,             0,    0,\n                    -sin(angle),    0,        cos(angle),    0,\n                            0,         0,                0,    1);\n}\n\nmat4 rotationZ( in float angle ) {\n    return mat4(    cos(angle),        -sin(angle),    0,    0,\n                     sin(angle),        cos(angle),        0,    0,\n                            0,                0,        1,    0,\n                            0,                0,        0,    1);\n}\n\nconst int NUMBER_OF_STEPS = 360; //64\nconst float MINIMUM_HIT_DISTANCE = 0.002; //0.000007;\nconst float MAXIMUM_TRACE_DISTANCE = 512.0; //1000.0;\nconst float EPSILON = 0.01;\n\n\nIntersection ray_march_world_intersection(in vec3 pos, in bool is_shadow)\n{\n    \n    Intersection intersection;\n    \n    int tag = 0;\n    \n    float u_time = iTime;\n    \n    //vec3 sphere_pos_0 = vec3(0.0, 0.0, 0.0);\n    vec3 box_pos_0 = vec3(0.0, 1.0, 2.0);\n    //vec3 box_pos_1 = vec3(0.0, -2.0, 0.0);\n    \n    //rotate pos around sphere_pos_0\n    vec3 ray_pos_0 = pos;\n    ray_pos_0 -= box_pos_0;\n    float angle = u_time*0.9;\n    mat4 ray_rot_x = rotationX(angle*0.5);\n    mat4 ray_rot_y = rotationY(angle);\n    mat4 ray_rot_z = rotationZ(angle*0.2);\n    mat4 ray_rot = ray_rot_x * ray_rot_y * ray_rot_z;\n    //ray_pos_0 = (vec4(ray_pos_0,1.0)*ray_rot_x).xyz;\n    ray_pos_0 = (vec4(ray_pos_0,1.0)*ray_rot).xyz;\n    ray_pos_0 += box_pos_0;\n    \n    \n    //float dist_box_0 = distance_from_box(pos-box_pos_0, vec3(20.0, 0.1, 20.0), 0.0); //(vec4(pos,1.0)*box_rot_y).xyz-box_pos\n    float dist_box_1 = distance_from_box(ray_pos_0-box_pos_0, vec3(1.5));\n    \n    /*float theta_offset = u_time;\n    vec3 sphere_ray_pos = op_twist(ray_pos_0, -0.16);\n    float displacement_0 = sin(3.0 * sphere_ray_pos.x + theta_offset) * sin(4.0 * sphere_ray_pos.y + theta_offset) * sin(2.0 * sphere_ray_pos.z + theta_offset) * 0.15;\n    float displacement_1 = sin(2.0 * sphere_ray_pos.x + theta_offset * -0.5) * sin(3.0 * sphere_ray_pos.y + theta_offset * 0.3) * sin(1.5 * sphere_ray_pos.z + theta_offset * -0.6) * 0.10;\n    float dist_sphere_0 = distance_from_sphere(sphere_ray_pos, sphere_pos_0, 3.0) + displacement_0 + displacement_1;*/\n    \n    float dist_plane_0 = distance_from_plane(pos-vec3(0.0,-4.5,0.0), vec3(0.0, 1.0, 0.0), 0.0);\n    \n    //SET DISTANCE, DIFFUSE, TAG\n    //sphere\n    float distance_to_closest = dist_box_1;\n    vec3 diffuse = vec3(u_color_red, u_color_green, u_color_blue);\n    tag = 1;\n    //plane\n    if (dist_plane_0 < distance_to_closest) {\n        \n        if (is_shadow == false) {\n            distance_to_closest = dist_plane_0;\n            diffuse = vec3(1.0);\n            tag = 2;\n        } else {\n            //distance_to_closest = dist_box_1;\n            //diffuse = vec3(1.0);\n            //tag = 2;\n        }\n    }\n    \n    intersection.tag = tag;\n    intersection.pos = pos; //pos;\n    intersection.dist = distance_to_closest; //abs(distance_to_closest);\n    intersection.normal = vec3(0.0);\n    //intersection.normal = normalize(pos - sphere_pos);\n    intersection.diffuse = diffuse;//vec3(0.2, 0.3, 1.0);\n    \n    return intersection;\n}\n\nvec3 estimate_normal(in vec3 p)\n{\n    return normalize(vec3(\n        ray_march_world_intersection(vec3(p.x + EPSILON, p.y, p.z), false).dist - ray_march_world_intersection(vec3(p.x - EPSILON, p.y, p.z), false).dist,\n        ray_march_world_intersection(vec3(p.x, p.y + EPSILON, p.z), false).dist - ray_march_world_intersection(vec3(p.x, p.y - EPSILON, p.z), false).dist,\n        ray_march_world_intersection(vec3(p.x, p.y, p.z  + EPSILON), false).dist - ray_march_world_intersection(vec3(p.x, p.y, p.z - EPSILON), false).dist\n    ));\n}\n\nvec3 calc_normal(in vec3 p) // for function f(p)\n{\n    const float h = EPSILON; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*ray_march_world_intersection( p + k.xyy*h, false).dist +\n                      k.yyx*ray_march_world_intersection( p + k.yyx*h, false).dist +\n                      k.yxy*ray_march_world_intersection( p + k.yxy*h, false).dist +\n                      k.xxx*ray_march_world_intersection( p + k.xxx*h, false).dist );\n}\n\n/*\n float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n {\n     float res = 1.0;\n     for( float t=mint; t<maxt; )\n     {\n         float h = map(ro + rd*t);\n         if( h<0.001 )\n             return 0.0;\n         res = min( res, k*h/t );\n         t += h;\n     }\n     return res;\n }\n */\n\nconst vec3 camera_start_position = vec3(0.0, 0.0, -7.0);\nconst vec3 camera_position = camera_start_position;\n\nvec3 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    \n    //vec3 sphere_pos = vec3(0.0, 0.0, 2.0);\n    vec3 light_pos = vec3(200.0, 180.0, -100.0)*1000.0;\n    float ambient = 0.0;\n    float res = 1.0;\n    float ph = 1e20;\n    float k = 4.0;\n\n    bool should_light = true;\n    bool should_shadow = true;\n    bool should_soften_shadow = true;\n    bool should_use_better_soft_shadow = false;\n        \n    //nodes\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        bool shadow_is_detected = false;\n        \n        vec3 current_position = ro + total_distance_traveled * rd;\n        \n        Intersection ray_intersection = ray_march_world_intersection(current_position, false);\n        \n        //NEW ARTIFACT FIX TEST\n        /*if (ray_intersection.dist < 0.0) {\n            \n            total_distance_traveled -= ray_intersection.dist;\n            vec3 current_position = ro + total_distance_traveled * rd;\n            ray_intersection = ray_march_world_intersection(current_position);\n        }*/\n        \n        ray_intersection.normal = calc_normal(current_position);\n        \n        if (abs(ray_intersection.dist) < MINIMUM_HIT_DISTANCE) //abs()\n        {\n            //shadows\n            if (should_shadow == true && ray_intersection.tag == 2) {\n                \n                float shadow_distance_traveled = 0.0; //0.0;\n                vec3 shadowD = normalize(light_pos - current_position); //OLD\n                //vec3 shadowD = normalize(light_pos); //NEW TEST\n                vec3 shadow_position = current_position; //ORIGINAL --> // + shadowD*MINIMUM_HIT_DISTANCE/2.0 + ray_intersection.normal*MINIMUM_HIT_DISTANCE/2.0; /* (abs(ray_intersection.dist) + MINIMUM_HIT_DISTANCE) + rd * -(abs(ray_intersection.dist) + MINIMUM_HIT_DISTANCE);*/\n                /*if (ray_intersection.dist < 0.0) { //ARTIFACT FIX TEST\n                    shadow_distance_traveled += abs(ray_intersection.dist) + MINIMUM_HIT_DISTANCE/2.0;\n                }*/\n                \n                for (int j = 0; j < NUMBER_OF_STEPS; ++j)\n                {\n                    shadow_position += shadow_distance_traveled * shadowD;// + shadowD * MINIMUM_HIT_DISTANCE*1.0;//(ray_intersection.dist + MINIMUM_HIT_DISTANCE) + ray_intersection.normal * (ray_intersection.dist + MINIMUM_HIT_DISTANCE);\n                    //vec3 shadow_position = current_position + total_distance_traveled * shadowD;\n                    \n                    Intersection shadow_intersection = ray_march_world_intersection(shadow_position, true); //shadow //true\n                    \n                    float h = shadow_intersection.dist;\n                    \n                    \n                    float MINIMUM_SHADOW_HIT_DISTANCE = MINIMUM_HIT_DISTANCE*1.0;\n                    if (h < MINIMUM_SHADOW_HIT_DISTANCE/* && shadow_intersection.tag != 2*/) //was abs //SHADOW DETECTED\n                    {\n                        shadow_is_detected = true; //testing123\n                        //return mix(vec3(0.0), ray_intersection.diffuse, 0.3);\n                        if (should_soften_shadow == true) {\n                            return ray_intersection.diffuse * ambient; //(RES) USE THIS FOR SOFT SHADOWS, OTHERWISE THEY WONT WORK\n                        } else {\n                            return ray_intersection.diffuse * ambient;\n                        }\n                    }\n                    \n                    //RES\n                    if (/*shadow_intersection.tag != 2 &&*/ should_soften_shadow == true)\n                    {\n                        //res = min(res, k*h/float(shadow_distance_traveled)); //ORIGINAL\n                        if (should_use_better_soft_shadow == true) {\n                            /*float t = shadow_distance_traveled;\n                            float u = h;\n                            float y = u*u/(2.0*ph);\n                            float d = sqrt(u*u-y*y);\n                            res = min( res, k*d/max(0.0,t-y) );\n                            ph = u;\n                            if (res < ambient)\n                            {\n                                res = ambient;\n                            }*/\n                            \n                            //NEW TEST\n                            //res = min(res, abs(h)/1.7);\n                            res = abs(h);\n                            if (res < ambient || res < 0.05)\n                            {\n                                res = ambient;\n                            }\n                        } else {\n                            res = min(res, k*abs(h)/float(shadow_distance_traveled));\n                            if (res < ambient)\n                            {\n                                res = ambient;\n                            }\n                        }\n                \n                    }\n                                        \n                    if (shadow_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n                    {\n                        res = 1.0;\n                        break;\n                    }\n                    \n                    shadow_distance_traveled += h/2.0; //NO SHADOW WITHOUT THIS??\n                                        \n                }\n                \n                //soft shadow component code\n                return ray_intersection.diffuse * res;\n            }\n            \n            if (res < 1.0) {\n                shadow_is_detected = true;\n            }\n            \n            //lighting\n            if (should_light == true && shadow_is_detected == false) {\n                \n                //NEW BELOW\n                float shininess = 64.0;\n                                    \n                vec3 final = ray_intersection.diffuse * ambient; //ray_intersection.diffuse;\n                \n                vec3 v = current_position;\n                vec3 eye = camera_position;\n                vec3 n = ray_intersection.normal;\n                \n                vec3 ev = normalize(v - eye);\n                vec3 ref_ev = reflect(ev, n);\n\n                vec3 light_color = vec3(1.0, 0.9, 0.9);\n                    \n                vec3 vl = normalize(light_pos - v);\n                    \n                float diffuse  = max(0.0, dot( vl, n ));\n                float specular = max(0.0, dot( vl, ref_ev ));\n                specular = pow( specular, shininess );\n                        \n                final += light_color * ( ray_intersection.diffuse * diffuse + vec3(specular) );\n                final = pow( final, vec3(1.0/2.2) ); //pow( final, vec3(1.0/2.2) ); //GAMMA CORRECTION\n                \n                return final;\n                \n                //OLD BELOW\n                /*vec3 light_dir = normalize(light_pos-current_position);\n                vec3 surf_normal = ray_intersection.normal;\n                float diffuse = clamp(dot(surf_normal, light_dir), 0.0, 1.0);\n                float ambient = 0.2;\n                vec3 reflect_dir = reflect(light_dir, surf_normal);\n                vec3 camera_dir = normalize(camera_position-current_position);\n                float dot_camera_reflect = dot(camera_dir, reflect_dir);\n                float specular_intensity = pow(clamp(dot_camera_reflect, 0.0, 1.0), 64.0);\n                if (dot_camera_reflect < 0.0)\n                {\n                    specular_intensity = 0.0;\n                }\n                // k = surface // m = material // i = light\n                // c_final = k_amb*m_amb*i_amb + k_dif*m_dif*i_dif + k_spec*m_spec*i_spec\n                \n                // surface color\n                vec3 k_spec = vec3(1.0) * specular_intensity;\n                vec3 k_dif = ray_intersection.diffuse * diffuse;\n                vec3 k_amb = ray_intersection.diffuse * ambient;\n                \n                // material reflectance\n                vec3 m_spec = vec3(1.0);\n                vec3 m_dif = vec3(1.0);\n                vec3 m_amb = vec3(1.0);\n                \n                // light intensity\n                vec3 i_spec = vec3(1.0);\n                vec3 i_dif = vec3(1.0);\n                vec3 i_amb = vec3(1.0);\n                \n                vec3 c_final = k_amb*m_amb*i_amb + k_dif*m_dif*i_dif + k_spec*m_spec*i_spec;\n                //vec3 diffuse_color = ray_intersection.diffuse * diffuse;\n                return c_final;*/\n                \n            } else {\n                \n                return ray_intersection.diffuse;\n            }\n            \n        }\n        \n        //float distance_to_closest = distance_from_sphere(current_position, sphere_pos, 2.0);\n\n        //float light_dot = dot(normalize(current_position-sphere_pos), normalize(light_pos-sphere_pos));\n        \n        /*if (distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            return vec3(0.1*light_dot, 0.15*light_dot, light_dot);\n        }*/\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += ray_intersection.dist;\n    }\n    return vec3(0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = iResolution.xy;\n    \n    vec2 uv = fragCoord/size;\n    vec2 pixel = uv * 2.0 - 1.0;\n    \n    if (size.x > size.y) {\n        pixel.x *= size.x/size.y;\n    } else if (size.y > size.x) {\n        pixel.y *= size.y/size.x;\n    }\n    \n        \n    \n    //setup camera\n    vec3 ro = camera_position;\n    vec3 rd = vec3(pixel, 1.0);\n    \n    //rd = (vec4(rd,1.0)*cam_rot).xyz;\n\n    //color\n    vec3 shaded_color = ray_march(ro, rd);\n\n    fragColor = vec4(shaded_color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}