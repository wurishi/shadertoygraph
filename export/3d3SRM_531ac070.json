{"ver":"0.1","info":{"id":"3d3SRM","date":"1571624916","viewed":118,"name":"treatment","username":"Aman","description":"peaceful watery[1] universe\ndrag on the surface to make waves\n\n[1] fluid sim from wyattflanders.com/MeAndMyNeighborhood.pdf","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fluid","space","island","mirage","meandmyneighborhood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec3 cart_to_sphere(vec3 c) {\n    return vec3(sqrt(c.x*c.x+c.y*c.y+c.z*c.z), atan(c.y,c.x), atan(sqrt(c.x*c.x+c.y*c.y),c.z));\n}\n\nvec3 cart_to_cyl(vec3 c) {\n \treturn vec3(length(c.xy), atan(c.y, c.x), c.z);   \n}\n\nvec2 latlong(vec3 p) {\n    vec2 longitudeLatitude = vec2((atan(p.y, p.x) / 3.1415926 + 1.0) * 0.5,\n                                  (asin(p.z) / 3.1415926 + 0.5));\n    return longitudeLatitude;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n\n\n\nfloat sdf(vec3 p) { \n    p.xz = rotate(p.xz, iTime*0.1);\n    vec2 scale =vec2(4.9, 2.80) * 1.99; \n//    vec3 sph = 0.5 *  (cart_to_sphere(p.xzy)/vec3(1.0, 3.14159,3.14159)) + 0.5;\n  //  sph.z *= 2.0;\n    vec3 sph = 0.5 * (cart_to_cyl(p.xzy) / vec3(1.0, 3.14159, 2.0)) + 0.5;\n    vec4 fluid = texture(iChannel0, sph.yz);\n   // fluid.w = latlong(p).x;\n   // fluid.w = length(mod(sph.yz/vec2(3.14159/2.0, 3.14159), 1.0));\n    fluid.w = clamp(fluid.w, -0.8, 0.8);\n    float d = length(p) - 2.0;\n    \n    \n//    d += clamp(fluid.w * 0.4, 0.0, 1.0);\n  //  d = max(d, sdBox(p + vec3(0.0, 4.0, -10.0), vec3(4.9)));\n    return d - (fluid.w * 0.3) -clamp(fluid.x*0.1-fluid.y*0.1, -0.2, 0.2);\n    \n    }\n\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*h ) + \n                      k.yyx*sdf( p + k.yyx*h ) + \n                      k.yxy*sdf( p + k.yxy*h ) + \n                      k.xxx*sdf( p + k.xxx*h ) );\n}\n\n\nbool march(vec3 ro, vec3 rd, out vec3 hitPos, out float minDist) {\n    float over = 1.0;\n    minDist = 0.0;\n    float total = 0.0;\n    for(int i = 0; i < 50; i++) {\n        float d = sdf(ro) * over;\n        ro += d * rd;\n        total += d;\n        minDist += d;\n        if (d < 0.001*total) { hitPos = ro; return true; }\n        over *= 1.1;\n    }\n    return false;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    float t = 0.0;\n    for(int i = 0; i < 10; i++)\n    {\n        float h = sdf(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 texcoord)\n{\n    vec4 fluid = texture(iChannel0, texcoord/iResolution.xy);\n    \n    vec3 col = 1.0 * fluid.www;\n    vec2 uv = 2.0 * (texcoord/iResolution.xy) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(-3.0, 0, 3.0);\n    vec3 rd = getRay(ro, vec3(0.0), uv, 2.0);\n    //rd = normalize(rd - vec3(0.0, 0.3, 0.0));\n\n    vec3 hitPos;\n    float minDist;\n    fragColor.rgb = col;\n    fragColor.a = 1.0;\n    \n    if(march(ro, rd, hitPos, minDist)) {\n       //col = fluid.www;\n       vec3 nor = calcNormal(hitPos);\n       vec3 lightPos =ro + vec3(4.0, 5.0, 1.0);\n        vec3 surfPos = hitPos + nor * 0.01;\n        vec3 norcol = nor.zyx * 0.5 + 0.5;\n        norcol.g *= 0.00; norcol.b *= 3.0;\n        norcol = normalize(norcol);\n       vec3 light = clamp(dot(nor, (lightPos - surfPos)),0.0, 1.0) * norcol.rbr;\n       float shadow = softshadow(surfPos, normalize(lightPos - surfPos), 0.0, 10.0, 2.0) * 1.0;\n      //light *= clamp(shadow + 0.3, 0.0, 1.0)'\n       light = pow(mix(norcol.rbr, norcol.bbg*vec3(0.5), 1.0-shadow +0.1), vec3(2.2));\n   \n      \n       // col = light + 0.1 * col;\n        col = light ;\n        \n      \n\n        \n    }\n    \n    fragColor.rgb = col;\n    fragColor.a = 1.0;\n //fragColor.xy = gl_FraCoord.xy / iResolution.xy;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 cart_to_sphere(vec3 c) {\n    return vec3(sqrt(c.x*c.x+c.y*c.y+c.z*c.z), atan(c.y,c.x), atan(sqrt(c.x*c.x+c.y*c.y),c.z));\n}\n\n\nvec3 cart_to_cyl(vec3 c) {\n \treturn vec3(length(c.xy), atan(c.y, c.x), c.z);   \n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// Fluid simulation from\n// wyattflanders.com/MeAndMyNeighborhood.pdf\n//\n\nvec4 LOOKUP(vec2 c) {\n    vec2 uv = c / iResolution.xy;\n    uv.x = fract(uv.x);\n    if(uv.y < 0.0 || uv.y > 1.0) {\n         uv.y = fract(uv.y);\n         uv.x = 1.0 - uv.x;\n    }\n  return texture(iChannel0, uv.xy);\n}\n\nvec4 Field (vec2 position) {\n    // Rule 1 : All My Energy transates with my ordered Energy\n    vec2 velocityGuess = LOOKUP (position).xy;\n    vec2 positionGuess = position - velocityGuess;\n    return LOOKUP (positionGuess);\n}\n\n\nvoid mainImage( out vec4 Energy, in vec2 Me )\n{\n\n\n    Energy  =  Field(Me);\n    \n       vec4 m = iMouse;\n        // Mouse input  :  \n\n    if (iMouse.z > 0.) {\n\n        vec3 ro = vec3(-3.0, 0.0, 3.0);\n        vec3 rd = getRay(ro, vec3(0.0), (m.xy/iResolution.xy)*2.0 - 1.0, 2.0);\n        float dist = raySphereIntersect(ro, rd, vec3(0.0), 2.0);\n        if(dist > 0.0) {\n            vec3 spherePos = ro + rd * dist;\n            spherePos.xz = rotate(spherePos.xz, iTime*0.1);\n         //   vec3 sph = 0.5 *  (cart_to_sphere(spherePos.xzy)/vec3(1.0, 3.14159, 0.5 * 3.14159)) + 0.5;\n               vec3 sph = 0.5 * (cart_to_cyl(spherePos.xzy) / vec3(1.0, 3.14159, 2.0)) + 0.5;\n\n            if(length(sph.yz - (Me.xy/iResolution.xy)) < 0.01) {\n\n                Energy.w += 0.05;\n                vec2 mx = normalize((vec2(0.0001, 0.0001) + m.xy - m.zw))*0.1*Energy.w;\n                Energy.xy += vec2(-mx.x, mx.y);\n            }\n        }\n  \n    }\n    // Neighborhood :\n    vec4 pX  =  Field(Me + vec2(1,0));\n    vec4 pY  =  Field(Me + vec2(0,1));\n    vec4 nX  =  Field(Me - vec2(1,0));\n    vec4 nY  =  Field(Me - vec2(0,1));\n    \n    // Rule 2 : Disordered Energy diffuses completely :\n    Energy.b = (pX.b + pY.b + nX.b + nY.b)/4.0;\n    \n    // Rule 3 : Order in the disordered Energy creates Order :\n    vec2 Force;\n    Force.x = nX.b - pX.b;\n    Force.y = nY.b - pY.b;\n    Energy.xy += Force/4.0;\n    \n    // Rule 4 : Disorder in the ordered Energy creates Disorder :\n    Energy.b += (nX.x - pX.x + nY.y - pY.y)/4.;\n    \n    // Gravity effect :\n    //Energy.y -= Energy.w/300.0;\n    // Mass concervation :\n    Energy.w += (nX.x*nX.w-pX.x*pX.w+nY.y*nY.w-pY.y*pY.w)/4.;\n        \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}