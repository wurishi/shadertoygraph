{"ver":"0.1","info":{"id":"WdVGRc","date":"1570671540","viewed":254,"name":"Menger Sponge PBS","username":"saidwho12","description":"Just an exercise I did on stream https://www.twitch.tv/saidwho12","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","ifs","menger","sponge","pbr","pbs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_CUBEMAP_LOD 10.0\n#define EPSILON 0.002\n#define MAX_RAY_DISTANCE 1000.0\n#define MAX_RAY_ITER 256\n#define MAX_FOG_DISTANCE 150.0\n#define FOG_FALLOFF 125.0\n#define REFL_SAMPLES 16\n#define INV_REFL_SAMPLES (1.0 / float(REFL_SAMPLES))\n\nconst vec3 GLOBAL_UP = normalize(vec3(0,1,0));\n\n#define PI 3.14159\n#define PI_2 (PI+PI)\n#define INV_PI (1.0/PI)\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat udBox(in vec3 p, in vec3 b)\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox(in vec3 p, in vec3 b)\n{\n\tvec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdBox(in vec2 p, in vec2 b)\n{\n\tvec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nmat2 rotate(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nstruct Material\n{\n\tvec3 albedo;\n    float roughness;\n    float F0;\n    float ka;\n    float kd;\n    float ks;\n};\n\nconst Material mat0 = Material(vec3(1.0,0.25,0.25), 0.8, 0.95, 0.7, 0.5, 0.5);\nconst Material mat1 = Material(vec3(0.4), 0.4, 0.9, 0.4, 0.3, 0.7);\n    \nstruct HitRecord\n{\n\tfloat t;\n    float it;\n    vec3 normal;\n    vec3 pos;\n    Material mat;\n};\n\nstruct PointRecord\n{\n\tfloat t;\n    Material mat;\n};\n    \nPointRecord SampleSDF(in vec3 p)\n{\n    float t0 = MAX_RAY_DISTANCE;\n    \n    vec4 q = vec4(p, 1.0);\n    q.xyz -= vec3(0, 3, 0);\n    t0 = min(t0, udBox(q.xyz, vec3(3)));\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        t0 = max(t0, -sdBox(q.xy,vec2(1.0))/q.w );\n        t0 = max(t0, -sdBox(q.xz,vec2(1.0))/q.w );\n        t0 = max(t0, -sdBox(q.yz,vec2(1.0))/q.w );\n        //q.xyz = abs(q.xyz) - 2.0;\n        \n        //q.xy = rotate(radians(7.4)) * q.xy;\n        //q.xz = rotate(radians(-4.4)) * q.xz;\n        //q.yz = rotate(radians(2.82)) * q.yz;\n        q.xyz = mod(abs(q.xyz)-1.0, 2.0)-1.0;\n    \tq *= 3.0;\n    }\n    \n    float t1 = p.y;\n    float t = min(t0, t1);\n    \n    /*\n    t = min(t, p.y);\n    for(int i = 0; i < 4; ++i)\n    {\n        p.xy = rotate(radians(60.0)) * p.xy;\n        p = vec3(abs(p.x)-1.0, p.yz - vec2(0,0.5));\n        \n        if (i%3 == 0)\n        \tt = min(t, pastille(p));\n        else\n        \tt = max(t, -pastille(p));\n    }\n    */\n    \n    Material mat;\n    if (t == t0)\n    {\n    \tmat = mat0;\n    }\n    else if (t == t1)\n    {\n        mat = mat1;\n        p.xz -= 100.0;\n        p.xz *= .25;\n        bool b = bool((int(p.x)%2) ^ (int(p.z)%2));\n        if (b == true)\n        {\n            mat.albedo = vec3(0.6);\n        \tmat.roughness = 0.4;\n        }\n        else\n        {\n            mat.albedo = vec3(1.0);\n        \tmat.roughness = 0.9;\n        }\n    }\n    \n    return PointRecord(t, mat);\n}\n\nvec3 GetNormal(vec3 x)\n{\n\treturn normalize(vec3(\n    \tSampleSDF(x + vec3(EPSILON, 0, 0)).t - \tSampleSDF(x - vec3(EPSILON, 0, 0)).t,\n    \tSampleSDF(x + vec3(0, EPSILON, 0)).t - \tSampleSDF(x - vec3(0, EPSILON, 0)).t,\n    \tSampleSDF(x + vec3(0, 0, EPSILON)).t - \tSampleSDF(x - vec3(0, 0, EPSILON)).t\n    ));\n}\n\nHitRecord RayMarch(vec3 o, vec3 d)\n{\n    // raymarch loop\n    float t = 0.0;\n    int i = 0;\n    while (i < MAX_RAY_ITER && t <= MAX_RAY_DISTANCE)\n    {\n        float r = SampleSDF(o+d*t).t;\n        if (r < EPSILON) break;\n        t += r;\n        ++i;\n    }\n\n    if (i == MAX_RAY_ITER || t > MAX_RAY_DISTANCE) t = MAX_RAY_DISTANCE;\n    \n    HitRecord rec;\n    rec.t = t;\n    rec.it = (float(i)+0.5)/float(MAX_RAY_ITER);\n    rec.pos = o + d*rec.t;\n    rec.normal = GetNormal(rec.pos);\n    rec.mat = SampleSDF(rec.pos).mat;\n    \n    return rec;\n}\n\n\nfloat ReitzGgxIsotropicD(in vec3 wn, in vec3 wm, in float alpha)\n{\n    float NoH = dot(wn,wm);\n    \n    if (NoH <= 0.0) return 0.0;\n    \n    float alpha2 = alpha * alpha;\n    float NoH2 = NoH * NoH;\n    float den = NoH2 * alpha2 + (1.0 - NoH2);\n    return alpha2 / ( PI * den * den );\n}\n\nfloat ReitzGgxG1(in vec3 w, in vec3 wn, in vec3 wm, in float alpha)\n{\n    float NoV = dot(w, wn);\n    if (dot(w, wm) / NoV <= 0.0) return 0.0;\n    float NoV2 = NoV * NoV;\n    float tan2 = ( 1.0 - NoV2 ) / NoV2;\n    return 2.0 / ( 1.0 + sqrt( 1.0 + alpha * alpha * tan2 ) );\n}\n\nfloat ReitzGgxG2(in vec3 wm, in vec3 wo, in vec3 wi, in vec3 H, in float alpha)\n{\n    return ReitzGgxG1(wo, wm, H, alpha) * ReitzGgxG1(wi, wm, H, alpha); \n}\n\nfloat SchlickFresnel(in float NoX, in float F0)\n{\n\treturn F0 + (1.0 - F0) * pow(1.0 - NoX, 5.0);\n}\n\nvec3 SpherialToDir(vec2 sph)\n{\n\tfloat cosTheta = cos(sph.x);\n\tfloat sinTheta = sin(sph.x);\n\tfloat cosPhi = cos(sph.y);\n\tfloat sinPhi = sin(sph.y);\n\treturn vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosTheta);\n}\n\nfloat Rand(in float seed) {\n\treturn hash11(seed);\n}\n\nvec3 RandDirectionSize(vec3 normal, float size, in float seed)\n{\n\tfloat theta = Rand(seed) * PI_2;\n    float cosT = Rand(seed);\n    float sinT = sqrt(1.0 - cosT * cosT);\n\tvec3 tangent = normalize(cross(normal.yzx, normal));\n    vec3 binormal = cross(normal, tangent);\n\treturn normalize((tangent * cos(theta) + binormal * sin(theta)) * sinT * size + normal * cosT);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    float fov = radians(45.0);\n\tvec2 R = iResolution.xy, p = (u+u-R)/R.y * atan(fov*0.5);\n    \n    vec3 o = vec3(cos(iTime), 0.55, sin(iTime)) * 10.0;\n    vec3 cc = vec3(0,1.5,0);\n    o += cc;\n    vec3 cu = GLOBAL_UP; // up direction, normalized\n    vec3 cf = -normalize(o);\n    vec3 cr = normalize(cross(cf, cu));\n    cu = cross(cr, cf);\n    vec3 d = normalize(mat3(cr,cu,cf) * vec3(p,0.5));\n    \n    HitRecord rec = RayMarch(o,d);\n    \n    vec3 col = vec3(0);\n\n    vec3 bg = textureLod(iChannel0, d, MAX_CUBEMAP_LOD).rgb;\n    if(rec.t == MAX_RAY_DISTANCE)\n    {\n        col = bg;\n    }\n    else\n    {\n        // Material properties\n        float roughness = rec.mat.roughness;\n        float alpha = roughness * roughness;\n        vec3 albedo = rec.mat.albedo;\n        float ka = rec.mat.ka;\n        float ks = rec.mat.ks;\n        float kd = rec.mat.kd;\n        float F0 = rec.mat.F0;\n        \n        vec3 pos = rec.pos;\n\n        vec3 N = rec.normal;\n        vec3 B = normalize(cross(N,GLOBAL_UP));\n        vec3 T = normalize(cross(N,B));\n        mat3 TBN = mat3(T,B,N);\n        \n        float ao = 1.0 - pow(rec.it, 1.0);//pow(rec.it,0.8);\n        vec3 ambient = ka * ao * albedo * textureLod(iChannel0, N, MAX_CUBEMAP_LOD).rgb;\n        \n        //col = vec3(ao);\n        \n        // check shadow ray\n        vec3 L = normalize(vec3(0.3,1,0.5));\n        vec3 V = -d;\n\n        vec3 safePos = pos + N * EPSILON * 2.0;\n        HitRecord shadowRec = RayMarch(safePos, L);\n        bool shadow = shadowRec.t < MAX_RAY_DISTANCE;\n        \n        if (!shadow)\n        {\n            /*\n            vec3 diff = vec3(0.0);\n            vec3 refl = vec3(0.0);\n            \n            for (int i = 0; i < REFL_SAMPLES; ++i)\n            {\n                // generate random ray\n                float seed = ((float(i) + 0.5) / float(REFL_SAMPLES)) * 100.0;\n                vec3 sampleDir = RandDirectionSize(R, .1*roughness, seed);\n                \n                //vec2 sph = hash21( rand_x ) * vec2(PI_2, PI);\n                //vec3 hemiDir = SpherialToDir(sph);\n                //vec3 sampleDir = normalize(TBN * hemiDir);\n                vec3 Fi = vec3(0);\n                \n                //HitRecord reflRec = RayMarch(safePos, sampleDir);\n                \n                //if (reflRec.t < MAX_RAY_DISTANCE)\n                //{\n                //    Fi = reflRec.mat.albedo;\n                //}\n                //else\n                {\n                    //Fi = texture(iChannel0, sampleDir).rgb;\n                    Fi = textureLod(iChannel0, sampleDir, MAX_CUBEMAP_LOD * roughness).rgb;\n                }\n                \n                vec3 H = normalize(sampleDir + V);\n\n                float NoL = dot(N,sampleDir);\n                float VoH = dot(V,H);\n               \tfloat cosT = max(dot( sampleDir, N ), 0.0);\n                float sinT = sqrt( 1.0 - cosT * cosT);\n\n                float F = SchlickFresnel(NoV, F0);\n                float G = ReitzGgxG2(N, V, sampleDir, H, alpha);\n                float D = ReitzGgxIsotropicD(N, H, alpha);\n\n                float lambert = max(NoL,0.0) * INV_PI;\n                vec3 diffuse = bg * albedo * lambert;\n                \n                float specular = (F * G * sinT) / (4.0 * NoV * max(dot(H, N),0.0) + 0.05);\n                \n                diff += Fi * diffuse;\n                refl += Fi * specular;\n            }*/\n            \n            vec3 R = reflect(d,N);\n            vec3 LiDiff = textureLod(iChannel0, N, MAX_CUBEMAP_LOD).rgb;\n            vec3 LiSpec = textureLod(iChannel0, R, MAX_CUBEMAP_LOD * roughness).rgb;\n\n            vec3 H = normalize(L + V);\n\n            float NoV = dot(N,V);\n            float NoL = dot(N,L);\n            float VoH = dot(V,H);\n\n            float F = SchlickFresnel(NoV, F0);\n            float G = ReitzGgxG2(N, V, L, H, alpha);\n            float D = ReitzGgxIsotropicD(N, H, alpha);\n\n            float lambert = max(NoL,0.0) * INV_PI;\n            vec3 diffuse = bg * albedo * lambert;\n\n            float specular = (F * G * D) / (4.0 * NoV * max(dot(H, N),0.0) + 0.05);\n\n            vec3 diff = LiDiff * diffuse;\n            vec3 refl = LiSpec * specular;\n\n            col = (kd * diff + ks * refl) * 8.0;\n        }\n        \n        col += ambient;\n        \n        float fog = clamp((-rec.t + MAX_FOG_DISTANCE)/FOG_FALLOFF,0.0,1.0);\n        fog = 1.0-pow(fog, 5.0);\n        //float fog = exp(-0.5*z_depth);\n        col = mix(col, bg, fog);\n    }\n    \n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}