{"ver":"0.1","info":{"id":"MdyBRy","date":"1529414634","viewed":173,"name":"Party Sausage","username":"nr4","description":"Analytic spline distance: https://www.shadertoy.com/view/XsVBWw\nadapted to three dimensions and optimized. Still a little slow though :/ ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spline","quadratic","sausage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Party Sausage\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// changes: \n// - optimized three-zero case\n// - removed incompatible sinh(.) and tanh(.) calls\n// - added abs to specular (fixes smartphone bug)\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n//hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n//distance to spline with parameter t\nfloat dist(vec3 p0,vec3 p1,vec3 p2,vec3 x,float t)\n{\n    t = clamp(t, 0., 1.);\n    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);\n}\n\n// Determine zeros of k.x*x^2+k.y*x+k.z\nvec2 quadratic_zeros(vec3 k)\n{\n    if(k.x == 0.) return -k.z/k.y*c.xx;\n    float d = k.y*k.y-4.*k.x*k.z;\n    if(d<0.) return vec2(1.e4);\n    return (c.xz*sqrt(d)-k.y)/(2.*k.x);\n}\nvec3 cubic_zeros(vec4 k)\n{\n    if(k.x == 0.) return quadratic_zeros(k.yzw).xyy;\n    \n    // Depress\n    vec3 ai = k.yzw/k.x;\n    \n    //discriminant and helpers\n    float tau = ai.x/3., \n        p = ai.y-tau*ai.x, \n        q = -tau*(tau*tau+p)+ai.z, \n        dis = q*q/4.+p*p*p/27.;\n        \n    //triple real root\n    vec3 r;\n    if(dis > 0.) {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, \n            ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        r = vec3(ui.x+ui.y-tau);\n    }\n    else {\n        //three distinct real roots\n        float fac = sqrt(-4./3.*p), \n            arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n        r = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n    };\n    \n    r -= (r * r * r + ai.x * r * r + ai.y * r + ai.z) / (3. * r * r + 2. * ai.x * r + ai.y);\n    \n    return r;\n}\n\n//minimum distance to spline\nfloat dsp(vec3 p0, vec3 p1, vec3 p2, vec3 x)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec3 E = x-p0, F = p2-2.*p1+p0, G = p1-p0,\n    \tai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n    vec3 t = cubic_zeros(vec4(1., ai));\n\n    return min(\n        dist(p0,p1,p2,x, t.x),\n        min(\n            dist(p0,p1,p2,x,t.y),\n            dist(p0,p1,p2,x,t.z)\n        )\n    );\n}\n\nmat3 rot(vec3 p)\n{\n    vec3 cp = cos(p), sp = sin(p);\n    mat3 m = mat3(cp.y*cp.x, cp.x*sp.z+cp.z*sp.x*sp.y, sp.x*sp.z-cp.x*cp.z*sp.y, \n           -cp.y*sp.z, cp.x*cp.z-sp.x*sp.y*sp.z, cp.z*sp.x+cp.x*sp.y*sp.z, \n           sp.y, -cp.y*sp.x, cp.x*cp.y);\n    return m;\n}\n\nvec2 scene(vec3 x)\n{\n    vec3 p1 = -sin(iTime)*.3*c.xxx, \n        p2 = .4*rot(vec3(1.1,1.2,1.3)*iTime)*c.xxy,\n        p3 = sin(iTime)*.2*c.xxx;\n    return vec2(dsp(p1,p2,p3,x)-.06, 216.);\n}\n\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x, dx=1.e-4;\n    return normalize(vec3(scene(x+dx*c.xyy).x-s, scene(x+dx*c.yxy).x-s, scene(x+dx*c.yyx).x-s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //camera setup\n    vec2 uv = fragCoord/iResolution.xy-.5, s = c.xy;\n\tvec3 o = c.yyx+.3*vec3(cos(.5*iTime), sin(.5*iTime), 0.), rt = uv.x*c.xyy+uv.y*c.yxy, d = normalize(rt-o), x = c.yyy, col=c.yyy;\n\tfloat di = 0.;\n    \n    //raymarching\n    for(int i=0; i<100; ++i)\n    {\n        x = o + di*d;\n        s = scene(x);\n        if(s.x < 1.e-4)break;\n        if(i==99)\n        {\n            fragColor = vec4(mix(.2*c.xxx, .5*c.xxx, round(1.*(.5+.5*sin(6.*atan(uv.y/uv.x)+3.e-1*iTime)))/1.), 1.);\n            return;\n        }\n        di += s.x;\n    }\n\n    //colorize\n    vec3 n = normal(x), l = 2.*c.yyx, v = normalize(x-o), r = normalize(reflect(-l,n));\n    \n    col = .4*abs((rot(vec3(1.3, 1.45, 1.56)*(iTime+12.4*s.y))*.3*c.xyy))\n        + .4*abs((rot(vec3(1.3, 1.45, 1.56)*(iTime+3.6*s.y))*.4*c.xyy*dot(l, n)))\n        + abs((rot(vec3(1.3, 1.45, 1.56)*(iTime+15.1*s.y))*2.5*c.xxy*pow(abs(dot(r,v)), 5.)));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}