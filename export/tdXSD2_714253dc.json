{"ver":"0.1","info":{"id":"tdXSD2","date":"1552250070","viewed":70,"name":"mgr","username":"Maria_RG","description":"mgr","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mgr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float eps=0.01;\nint MAX = 1000;\n\nvec3[2] lights=vec3[2](vec3(6.0,5.0,-1.0),vec3(-3.5,-4.0, 8.0));\n\nstruct ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct material\n{\n    vec3 a;\n    vec3 d;\n    vec3 sp;\n    float sh;\n};\n\nstruct hit\n{\n    int reach;\n    vec3 point;\n};\n    \nstruct Sphere\n{\n\tvec4 vol;\n    material m;\n};\nstruct Torus\n{\n    vec3 c;\n\tvec2 rad;\n    material m;\n}; \nstruct Ellips\n{\n\tvec3 c;\n    vec3 r;\n    material m;\n};\n    \nstruct Hprism\n{\n\tvec3 c;\n    vec2 h;\n    material m;\n};\n    \nstruct Square\n{\n    vec3 c;\n\tvec2 rad;\n    material m;\n}; \n    \nstruct objects\n{\n\tSphere s;\n    Torus t;\n    Ellips e;\n    Hprism p;\n    Square q;\n};\n\nfloat sdSquare( vec3 p, vec2 t )\n{\n    float n=4.0;\n    float f=pow(p.z,n)+pow(p.x,n);\n    vec2 q = vec2(pow(f,1./n) -t.x,p.y);\n    f=pow(q.y,n)+pow(q.x,n);\n    return pow(f,1./n)-t.y;\n}       \n    \nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}    \n    \nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}  \n    \nfloat sdSphere( vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 opTx( vec3 p)\n{\n    mat3 m;\n    m[0]=vec3(cos(3.14),-sin (3.14),0.0);\n    m[1]=vec3(0.4,0.2,0.8);\n    m[2]=vec3(sin(3.14),cos (3.14),0.0);\n    \n    vec3 q = vec3(inverse(m)*p);\n    return q;\n}\n\nfloat opDisplace( vec3 p, float s )\n{\n    float d1 = sdSphere(p,s);\n    float d2 = sin(1.5*p.x)*sin(1.5*p.y)*sin(1.5*p.z) ;\n    return d1+d2;\n}\n\nint min2 (vec3 p,objects o,float d)\n{\n    int k=1;\n    float[5] e;\n    e[0]=opDisplace(p-(o.s.vol).xyz,o.s.vol.w);\n    e[1]=sdTorus(opTx(p-o.t.c),o.t.rad);\n    e[2]=sdEllipsoid(p-(o.e.c).xyz, o.e.r);\n    e[3]=sdHexPrism(p-(o.p.c), o.p.h);\n    e[4]=sdSquare(opTx(p-o.q.c),o.q.rad);\n    for(int i=1; i<6; i++)\n        if(e[i-1] <= d)\n        \tk=i;   \n    return k;\n}\n  \nfloat DE(vec3 p,objects o)\n{\n    float l;    \n    float m1=min(opDisplace(p-(o.s.vol).xyz,o.s.vol.w),sdTorus(opTx(p-o.t.c),o.t.rad));\n    float m2=min(sdHexPrism(p-(o.p.c), o.p.h),sdEllipsoid(p-(o.e.c).xyz, o.e.r));\n    l=min(m1,m2);\n    l=min(l,sdSquare(opTx(p-o.q.c),o.q.rad));\n    return l;\n}\n\n\nvec3 Normal_vec(vec3 z,objects o)\n{\n    vec3 z1 = z + vec3(eps, 0, 0);\n    vec3 z2 = z - vec3(eps, 0, 0);\n    vec3 z3 = z + vec3(0, eps, 0);\n    vec3 z4 = z - vec3(0, eps, 0);\n    vec3 z5 = z + vec3(0, 0, eps);\n    vec3 z6 = z - vec3(0, 0, eps);\n    float dx = DE(z1,o) - DE(z2,o);\n    float dy = DE(z3,o) - DE(z4,o);\n    float dz = DE(z5,o) - DE(z6,o);\n    return normalize(vec3(dx, dy, dz) / (2.0*eps));\n}\n\nvec3 dye(vec3 n, vec3 p, material m, ray r, vec3 l)\n{    \n    vec3 ambient = vec3(0.5) * m.a;\n\n    vec3 ldir=normalize(l-p);\n    float d = max(dot(n, ldir), 0.0);\n    vec3 diffuse = vec3(1.0) * (d * m.d);\n\n    vec3 viewDir = normalize(r.pos - p);\n    vec3 rDir = reflect(ldir, n);  \n    float spec = pow(max(dot(r.dir, rDir), 0.0), m.sh);\n    vec3 specular = vec3(0.15) * (spec * m.sp);  \n    vec3 col = vec3(ambient + diffuse + specular);\n    return col;\n}\n\nvec3 trace(const ray r,objects o)\n{\n\n    vec3 col=vec3(0);\n    hit h;\n    int j=0;\n    h.reach=0;\n    float t=0.0,k;\n    vec3 p=r.pos;\n    material m;\n    for(int j=0 ; j<MAX ; j++)\n    {\n        p = p + r.dir*t;\n        t=DE(p,o);\n        if(abs(t)>500.0)\n\t\t\tbreak;\n        if (abs(t)< eps)             \n        {\n            h.reach=min2(p,o,t);\n            h.point=p;\n            break;\n        } \n    }  \n    if (h.reach==0)\n        return col;\n    for(int i=0;i < 2;i++)\n    {\n        vec3 n = Normal_vec(h.point,o);\n        if (h.reach==1)\n            m=o.s.m;\n        if (h.reach==2)\n            m=o.t.m;\n        if (h.reach==3)\n            m=o.e.m;\n        if (h.reach==4)\n            m=o.p.m; \n        if (h.reach==5)\n            m=o.q.m;\n        col+=dye(n, h.point, m, r, lights[i]);\n    }\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ray r;\n    vec3 uv;   \n    uv.xy=fragCoord.xy-(iResolution.xy/2.0);\n    uv.z= -(iResolution.x);\n    r.pos = vec3(0.0, 0.0, 10.0);\n    r.dir =  normalize(vec3(uv.x, uv.y,uv.z));\n        \n    material bronze= material(vec3(0.2125,0.1275,0.054),vec3(0.714,0.4284,0.18144),vec3(0.393548,0.271906,0.166721), 0.2);\n    material jude=material(vec3(0.135 ,\t0.2225,0.1575),vec3(0.54 ,0.89 ,0.63) ,vec3(0.316228,0.316228,0.316228),0.1);\n    material emerald = material (vec3(0.0215,0.1745 ,0.0215),vec3(0.07568 ,0.61424,0.07568), vec3(0.633,0.727811,0.633), 0.6);\n    material pearl = material(vec3(0.25,0.20725,0.20725),vec3(1,0.829,0.829),vec3(0.296648,0.296648,0.296648),0.088);\n    material ruby = material(vec3(0.1745,0.01175,0.01175),vec3(0.61424,0.04136,0.04136),vec3(0.727811,0.626959,0.626959),0.6);\n    \n    Sphere s= Sphere(vec4(3.1,-1.5, -3.0, 1.1),bronze);\n    Torus t= Torus(vec3(-0.7,-0.5,-2.5),vec2(0.8,0.4),ruby);\n    Ellips e= Ellips(vec3(-3.0,-1.5,-0.5),vec3 (0.8,1.0,0.7),jude);\n    Hprism p= Hprism(vec3(-3.25,1.3, -2.0),vec2 (0.8,1.3),emerald);\n    Square q= Square(vec3(2.2,1.3,0.0),vec2(0.65,0.15),pearl);\n    objects o=objects(s,t,e,p,q);               \n    \n    vec3 colour=trace(r,o);\n    fragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}