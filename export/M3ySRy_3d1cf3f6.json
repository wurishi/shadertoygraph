{"ver":"0.1","info":{"id":"M3ySRy","date":"1720096546","viewed":119,"name":"Above the clouds 2","username":"mju","description":"fork for the shader from Duke","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["noise","volume","raymarch","cloud"],"hasliked":0,"parentid":"ll2SWd","parentname":"Above the clouds"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// \"Above the clouds 2\" by MJ\n//----------------------------\n// Original Above the Clouds by Duke : https://www.shadertoy.com/view/ll2SWd\n// Clouds lighting technique came from IQ's \"Clouds\" https://www.shadertoy.com/view/XslGRr shader\n// Raymarcher based on Shane's \"Fiery Spikeball\" https://www.shadertoy.com/view/4lBXzy shader (I think that his implementation is more understandable than the original :) ) \n// Some noises came from otaviogood's \"Alien Beacon\" https://www.shadertoy.com/view/ld2SzK shader\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n \n \n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define SpiralNoiseC(q) -abs(sin(q.y) + cos(q.x)) \n       \nconst vec3 sundir = normalize( vec3(-1.0,0.75,1.0) );\n// ro: ray origin\n// rd: direction of the ray\nconst vec3 ro = vec3(0., 0., -11.);\n\n// ld, td: local, total density \n// w: weighting factor\nfloat ld=0., td=0., w;\n\n// t: length of the ray\n// d: distance function\nfloat d=1., t=0.;\n\n// Distance threshold.\nconst float h = .1;\n\n\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) \n{\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\nfloat rand(vec2 co)\n{// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nconst float normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n\nconst vec4 iterx = vec4(1.,1.33733,1.788451,2.39174);\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    for (int i = 0; i < 4; i++)\n    {\n        n += (sin(p.y*iterx[i]) + cos(p.x*iterx[i])) / iterx[i];\n        //p.xy += vec2(p.y, -p.x) * nudge;\n        //p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        \n    }\n    return n;\n}\n\nfloat Clouds(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    //final -= SpiralNoiseC(p.xyz);\t// mid-range noise\n    \n    vec3 q = p.zxy*0.123+100.0;\n    final += SpiralNoiseC(q) *3.0;\t// large scale terrain features\n    \n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d, so not just a height map.\n    final -= SpiralNoise3D(p*49.0)*0.0078125;\t// small scale noise for variation\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\n   R(p.yz, -25.53);\n   \n   R(p.xz,iTime*0.1);\n   return Clouds(p) +  fpn(p*50.+iTime*5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n    // background sky     \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 col = vec3(0.675,0.785,0.825) - rd.y*vec3(0.2,0.1,0.2) ;\n    col += vec3(0.5,.3,0.05)*pow( sun, 8.0 );\n   \n    // clouds  \n    vec3 bgcol = col;\n    vec4 sum = vec4(0.0);\n   vec2 pos1 = ( fragCoord.xy / iResolution.xy );\n   vec2 seed = pos1 + fract(iTime);\n   t=1.+0.2*texture( iChannel0,seed, 0.0 ).y;\n   \n\n   float exp1 =1.0-exp(-0.0004*t*t); // replace this with the whole expression  if you want to see a falloff in the color of the clouds\n   // rm loop\n   for (int i=0; i<48; i++) {\n\t \n      vec3 pos = ro + t*rd;\n       \n      // Loop break conditions.\n      if(t>120. || sum.a > 0.99) break;\n       \n      // evaluate distance function\n      d = map(pos)*0.326; \n      \n      // fix holes deep inside clouds\n      d=max(d,-.4);\n       \n      // check whether we are close enough\n      if (d<0.4) \n      {\n        // compute local density and weighting factor \n      \tld = 0.1 - d;\n        \n      \tld *= clamp((ld - map(pos+0.3*sundir))/0.6, 0.0, 1.0 );\n        const float kmaxdist = 0.6;\n      \n          \n        w = (1. - td) * ld;   \n     \n      \t// accumulate density\n      \ttd += w;// + 1./90.;\n              \n      \tvec3 lin = vec3(0.845,0.884,0.91) + vec3(0.35, 0.25, 0.25)*ld;\n      \n      \tvec4 col = vec4( mix( vec3(1.15,1.0925,0.92), vec3(0.765), d ), kmaxdist );\n      \n      \n      \tcol.xyz *= lin;\n        col.xyz = mix( col.xyz, bgcol, exp1 );\n      \t// front to back blending    \n      \tcol.a *= 0.4;\n      \tcol.rgb *= col.a;\n      \tsum += col*(1.0-sum.a);\n        \n      }\n      \n      td += 1./70.;\n       \n      // enforce minimum stepsize\n      d = max(d, 0.04); \n      \n\t\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(1.+0.28*rand(seed*vec2(i)));\n       \n\t  \n      // step forward\n      t += d*.5;\n      \n      \n   }\n \n   \tsum = clamp( sum, 0.0, 1.0 );\n    col = vec3(0.675,0.785,0.825) - rd.y*vec3(0.5,0.25,0.5);\n    \n    col = col*(1.0-sum.w) + sum.xyz;\n    \n    // sun glare    \n\tcol += vec3(0.1,0.04,0.02)*pow( sun, 3.0 );\n   \n   fragColor = vec4(col, 1.0); \n}","name":"Image","description":"","type":"image"}]}