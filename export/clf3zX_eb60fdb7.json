{"ver":"0.1","info":{"id":"clf3zX","date":"1672343568","viewed":402,"name":"CoolVaporwave 1","username":"MrHAX00","description":"Decided to mess around with lerp etc. to see what I could make and it ended up becoming this vaporwave thing that is also an absolute spaghetti monster.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","retro","scanlines","normals","vaporwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord * .5), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat DistanceFromFloor(vec3 Point)\n{\n    vec2 GridId = floor(Point.xz);\n    vec2 LocalCoord = fract(Point.xz);\n    \n    float Hash1 = hash12(GridId);\n    float Hash2 = hash12(GridId + vec2(1., 0.));\n    float Hash3 = hash12(GridId + vec2(0., 1.));\n    float Hash4 = hash12(GridId + vec2(1., 1.));\n    \n    float Sum1 = Lerp(Hash1, Hash2, LocalCoord.x);\n    float Sum2 = Lerp(Hash3, Hash4, LocalCoord.x);\n    \n    return Point.y + (1. - Lerp(Sum1, Sum2, LocalCoord.y)) * .5;\n}\n\nvec3 GetFloorNormal(vec3 Point)\n{\n    vec2 GridId = floor(Point.xz);\n    vec2 LocalCoord = fract(Point.xz);\n    \n    float Hash1 = hash12(GridId);\n    float Hash2 = hash12(GridId + vec2(1., 0.));\n    float Hash3 = hash12(GridId + vec2(0., 1.));\n    float Hash4 = hash12(GridId + vec2(1., 1.));\n    \n    float Sum1 = Lerp(Hash1, Hash2, LocalCoord.x);\n    float Sum2 = Lerp(Hash3, Hash4, LocalCoord.x);\n    \n    vec3 ActualHit = vec3(LocalCoord.x, Point.y + (1. - Lerp(Sum1, Sum2, LocalCoord.y)) * .5, LocalCoord.y);\n    \n    vec3 Hit1 = vec3(LocalCoord.x, Point.y + (1. - Lerp(Sum1, Sum2, LocalCoord.y + .1)) * .5, LocalCoord.y + .1);\n    vec3 Hit2 = vec3(LocalCoord.x + .1, Point.y + (1. - Lerp(\n            Lerp(Hash1, Hash2, LocalCoord.x + .1),\n            Lerp(Hash3, Hash4, LocalCoord.x + .1),\n            LocalCoord.y\n        )\n    ) * .5, LocalCoord.y);\n    \n    return normalize(cross(Hit2 - ActualHit, Hit1 - ActualHit) * vec3(1., -1., 1.));\n}\n\nfloat GetDepth(vec3 RayOrigin, vec3 RayDirection)\n{\n    float Distance = DistanceFromFloor(RayOrigin);\n    \n    for (int i = 0; i < 200; i++)\n    {\n        float Got = DistanceFromFloor(RayOrigin + RayDirection * Distance) * .6;\n        Distance += Got;\n        if (abs(Got) < MinDistance || Distance > MaxDistance) break;\n    }\n    \n    return Distance;\n}\n\nvec3 DrawWorld(vec2 uv)\n{\n    vec3 RayDirection = normalize(vec3(uv, 1.)) * AxisAngle(vec3(1., 0., 0.), sin(iTime) * .05);\n    vec3 RayOrigin = vec3(0., 1., iTime);\n    \n    float Distance = GetDepth(RayOrigin, RayDirection);\n    vec3 Hit = RayOrigin + RayDirection * Distance;\n    vec3 Normal = GetFloorNormal(Hit);\n\n    float Wave = sin(length(Hit.xz - RayOrigin.xz) * .05 - iTime * pi * WaveFrequency);\n    Wave = Wave * Wave * Wave * Wave * dot(Normal, normalize(RayOrigin - Hit));\n    vec3 WaveSum = abs(vec3(Wave, 0., Wave));\n    \n    vec3 Lines = abs(fract(Hit) - .5) * vec3(1., 0., 1.) * 2.;\n    Lines = vec3(max(Lines.x, Lines.z)) * vec3(1., 0., 1.);\n    Lines = smoothstep(.8, .95, Lines * Lines);\n    \n    vec3 Sky = vec3(smoothstep(-.3, 1., uv.y) + abs(fract(uv.y * 150.) - .5) * .1) * vec3(1., 0., 1.);\n    return mix(Lines + WaveSum, Sky, smoothstep(0., .4, Distance / MaxDistance));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > iResolution.x * .5 || fragCoord.y > iResolution.y * .5) discard;\n    vec2 uv = (fragCoord * 2. - iResolution.xy * .5) / iResolution.y;\n    \n    float Height = .2 + sin(iTime) * .05;\n    \n    float Sun = smoothstep(1., .95, length(uv - vec2(-.2, Height)) * 6.) * max(0., ((uv.y + sin((uv.y - Height + uv.x * .2 - iTime * .01) * pi * 50.) * .05) - .13 + uv.x * .2) * 4. + .4 + smoothstep(.175, -.15, length(uv - vec2(-.2, Height + .05))));\n    \n    fragColor = vec4(mix(DrawWorld(uv), mix(vec3(1., 0., 1.), vec3(1., 1., 0.), smoothstep(0., .5, uv.y + Height + uv.x * .2)), Sun * .3), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MaxDistance 150.\n#define MinDistance .01\n#define WaveFrequency .3\n\n#define pi 3.1415926535897932384626433832795\n#define Lerp(a, b, t) (a - (a - b) * clamp(t, 0., 1.))\n\n//from Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33); //the * max section is added to create mountains\n    return fract((p3.x + p3.y) * p3.z) * max(2. - cos(p.x * .3) * 2., -.25);\n}\n\n//from https://www.shadertoy.com/view/Nl33W8\nmat3 AxisAngle(vec3 Axis, float Angle) {\n    float Sin = cos(Angle + pi * .5);\n    float Cos = cos(Angle);\n    return mat3(\n        Axis * Axis.x * (1. - Cos) + vec3(Cos, Axis.z * Sin, -Axis.y * Sin),\n        Axis * Axis.y * (1. - Cos) + vec3(-Axis.z * Sin, Cos, Axis.x * Sin),\n        Axis * Axis.z * (1. - Cos) + vec3(Axis.y * Sin, -Axis.x * Sin, Cos)\n    );\n}","name":"Common","description":"","type":"common"}]}