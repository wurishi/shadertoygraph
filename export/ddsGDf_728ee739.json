{"ver":"0.1","info":{"id":"ddsGDf","date":"1690161669","viewed":67,"name":"20221028-grid-study","username":"cfl997","description":"grid","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 如果当前像素位于网格线上，则此辅助函数返回1.0，否则返回0.0\nfloat IsGridLine(vec2 fragCoord)\n{\n\t// 定义我们想要的每个网格正方形的像素大小\n\tvec2 vPixelsPerGridSquare = vec2(16.0, 16.0);\n\t\n\t// fragCoord是着色器的一个输入，它定义了当前像素的像素坐标\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\t\n\t// 根据我们在每个网格正方形中的位置，在0-> 1的范围内获取一个值\n\t// Fract()返回值的小数部分，丢弃整数部分\n\t// 这有助于包装0->1范围内的数字\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);\n\t\n\t// 转换我们在方格内的0-> - 1坐标\n\t// 回到网格方格内的像素坐标 \n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n    // step（）返回0.0，如果第二个帕米特小于第一个，否则，否则为1.0\n    //因此，如果我们在网格线上，我们将获得1.0，否则我们会获得0.0\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\t\n\t// 通过取这两个值的最大值来合并x和y网格线\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\t// return the result\n\treturn fIsGridLine;\n}\n\n// 如果我们靠近鼠标指针，这个帮助函数返回1.0，否则返回0.0\nfloat IsWithinCircle(vec2 vPos, vec2 fragCoord)\n{\n\t// fragCoord是着色器的一个输入，它定义了当前像素的像素坐标\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\n\t// 我们计算我们离鼠标指针有多远\n\tfloat fPixelsToPosition = length(vScreenPixelCoordinate - vPos);\n\t\n\t// 如果与鼠标指针的距离小于8.0像素，则返回1.0，否则返回0.0\n\treturn step(fPixelsToPosition, 10.0);\n}\n\n// main is the entry point to the shader. \n// Our shader code starts here.\n// 这个代码为每个像素运行，以确定其颜色\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// 我们将把我们的最终颜色放在这里\n\t// initially we set all the elements to 0 \n\tvec3 vResult = vec3(0.0);\n\n\t// 我们基于IsGridLine()函数设置结果的蓝色组件\n\tvResult.b = IsGridLine(fragCoord);\n\n\t// 如果我们靠近鼠标坐标，则为1.0，否则为0.0\n\tfloat fIsMousePointerPixelA = IsWithinCircle(iMouse.xy,fragCoord);\n    \n    //float fIsMousePointerPixelA=0.;\n\t// 如果按下鼠标按钮\n\tif(iMouse.z >= 0.0)\n\t{\n\t\t//我们设置结果的绿色部分\n\t\tvResult.g = fIsMousePointerPixelA;\n\t}\n\telse\n\t{\n\t\t//我们设置结果的红色部分\n\t\tvResult.r = fIsMousePointerPixelA;\n\t}\n\n\tfloat fIsMousePointerPixelB = IsWithinCircle(abs(iMouse.zw),fragCoord);\n\tvResult.b = max(vResult.b, fIsMousePointerPixelB);\n\n\n    //着色器的输出是Fragcolor。\n    //这是我们写在此像素的屏幕上的颜色\n\tfragColor = vec4(vResult, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}