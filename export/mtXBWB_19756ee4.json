{"ver":"0.1","info":{"id":"mtXBWB","date":"1693406222","viewed":41,"name":"Complex Domain/Codomain Plot (1)","username":"Envy24","description":"https://www.youtube.com/watch?v=r1h3eNQ2YM0\nOther related shaders:\nhttps://www.shadertoy.com/view/msScWw\nhttps://www.shadertoy.com/view/mdlBRr\nhttps://www.shadertoy.com/view/mssfRr","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["domain","graph","plot","complex","codomain"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 3.0 )\n#define AA_UNIT                   ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nconst float num_of_lines = 256.;\n\nvec2 sample_circle(float t, vec2 pos, float r)\n{\n    r += sin(iTime) * .4;\n    t *= 2.*3.141592;\n    return pos + r * vec2(cos(t), sin(t));\n}\n\nvec3 grid(in vec2 NDC)\n{\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );       \n\n    return color;\n}\nfloat domainSDF(in vec2 NDC, float ar)\n{\n    float dt = 1./num_of_lines, min_d = 9e5; \n    vec2 E, B = sample_circle(0., vec2(0), 1.);\n    for (float l = 0.; l < num_of_lines; ++l)\n    {\n        E = sample_circle(dt * (l + 1.), vec2(0), 1.);\n        \n        min_d = min(min_d, segmentSDF(NDC, B, E, 0.));\n        \n        B = E;\n    }\n\n    return min_d;\n}\n\nvec2 f(vec2 z)\n{\n    vec2 zz = cmul(z,z),\n         zzzz= cmul(zz, zz);\n    \n    return cmul(z, zzzz) + cmul(z, zz);\n}\nfloat codomainSDF(in vec2 NDC, float ar)\n{\n    float dt = 1./num_of_lines, min_d = 9e5; \n    vec2 E, B = f(sample_circle(0., vec2(0), 1.));\n    for (float l = 0.; l < num_of_lines; ++l)\n    {\n        E = f(sample_circle(dt * (l + 1.), vec2(0), 1.));\n        \n        min_d = min(min_d, segmentSDF(NDC, B, E, 0.));\n        \n        B = E;\n    }\n\n    return min_d;\n\n    return 1.;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y * SCENE_SCALE,\n          o = ar * 0.5;\n    \n    vec2  NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2( 0, 0), false),\n         dNDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2( o, 0), false),\n         cNDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(-o, 0), false);\n    \n    float min_d = SC.x >= R.x*0.5 ? codomainSDF(cNDC, o) : domainSDF(dNDC, o);\n    vec3 curve_col = SC.x >= R.x*0.5 ? vec3(0,0,1) : vec3(0,.5,.5);\n    \n    vec3 color = SC.x >= R.x*0.5 ? grid(cNDC) : grid(dNDC);\n         color = mix(color, curve_col, SMAA(min_d));\n    \n    \n         color = mix(color, vec3(1,0,0), SMAA(vertical_lineSDF(NDC, 0.)));\n\n    O = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float linear_remap(float val, vec2 from, vec2 to)\n{\n    // inverse linear map from [from.x; from.y] to [0; 1].\n    val = (val - from.x) / (from.y - from.x);\n    // linear map from [0; 1] to [to.x; to.r].\n    return val * (to.y - to.x) + to.x;        \n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\n\n/*Conversion*/\nvec2 cartesian(vec2 z) { return z.x * vec2(cos(z.y), sin(z.y)); }\nvec2 polar(vec2 z) { return vec2(length(z), atan(z.y, z.x)); } // atan2 implementation: https://www.shadertoy.com/view/csf3Wl\n\n/*Complex arithmetic in Cartesian coordinates vec2(Re, Im)*/\nvec2 complex(float real) { return vec2(real, 0); }\nvec2 cadd(vec2 l, vec2 r) { return vec2(l.x+r.x, l.y+r.y); }\nvec2 csub(vec2 l, vec2 r) { return vec2(l.x-r.x, l.y-r.y); }\nvec2 cmul(vec2 z, float s) { return z*s; }\nvec2 cmul(float s, vec2 z) { return s*z; }\nvec2 cmul(vec2 l, vec2 r) { return vec2(l.x*r.x-l.y*r.y, l.y*r.x+l.x*r.y); }\nvec2 cdiv(vec2 l, vec2 r) { \n\tfloat inv = 1.0 / (r.x*r.x+r.y*r.y);\n\treturn inv * vec2(l.x*r.x+r.y*l.y, r.x*l.y-l.x*r.y);\n}\nvec2 conjugate(vec2 z) { return vec2(z.x, -z.y); }\nvec2 cexp(float theta) { return vec2(cos(theta), sin(theta)); } // Euler formula\n// source: https://www.shadertoy.com/view/DdsSRS\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\nvec2 csqrt(vec2 z) {\n  float t = carg(z);\n  return sqrt(length(z))*vec2(cos(0.5*t),sin(0.5*t));\n}\nvec2 ccbrt0(vec2 z) {\n  // Trigless Newton Raphson verson\n  float r = length(z);\n  z /= r; // Normalize z\n  vec2 u = z+vec2(1,0); // First approximation (when normalized)\n  for (int i = 0; i < 4; i++) {\n    u = normalize(u);\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n// https://www.shadertoy.com/view/ltjczK\n//vec2 clog(vec2 z) { return polar(vec2(log(z.x),z.y)); }\nvec2 cpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\nvec2 cpow(float n, vec2 z) { return vec2(exp(log(n)*z.x*cos(z.y)),log(n)*z.x*sin(z.y)); }\nvec2 cpow(vec2 z1, vec2 z2) { return cpow(exp(1.),cmul(clog(z1),z2)); }\n\n/*Complex arithmetic in Polar coordinates vec2(mag, theta)*/\nvec2 caddp(vec2 z1, vec2 z2) { return polar(cartesian(z1) + cartesian(z2)); }\nvec2 csubp(vec2 z1, vec2 z2) { return polar(cartesian(z1) - cartesian(z2)); }\nvec2 cmulp(vec2 l, vec2 r) { return vec2(l.x*r.x, l.y+r.y); }\nvec2 cdivp(vec2 l, vec2 r) { return vec2(l.x/r.x, l.y-r.y); }\nvec2 conjugated(vec2 z) { return vec2(z.x, -z.y); }\n\n/*Complex functions*/\n//sinz, cosz and tanz came from -> https://www.shadertoy.com/view/Mt2GDV\nvec2 csin(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(sin(z.x)*cosh,cos(z.x)*sinh));\n}\nvec2 ccos(vec2 z) {\n   z = cartesian(z);\n   float e1 = exp(z.y);\n   float e2 = exp(-z.y);\n   float sinh = (e1-e2)*.5;\n   float cosh = (e1+e2)*.5;\n   return polar(vec2(cos(z.x)*cosh,-sin(z.x)*sinh));\n}\nvec2 ctan(vec2 z) {\n    z = cartesian(z);\n    float e1 = exp(z.y);\n    float e2 = exp(-z.y);\n    float cosx = cos(z.x);\n    float sinh = (e1 - e2)*0.5;\n    float cosh = (e1 + e2)*0.5;\n    return polar(vec2(sin(z.x)*cosx, sinh*cosh)/(cosx*cosx + sinh*sinh));\n}\nvec2 lambert(vec2 z) {\n   vec2 sum = vec2(.0);\n   for (int i=1; i<15; i++)\n      sum += cartesian(cdivp(cpow(z,float(i)),csubp(vec2(1.,.0),cpow(z,float(i)))));\n   return polar(sum);\n}\n// More functions here: https://www.shadertoy.com/view/ltjczK","name":"Common","description":"","type":"common"}]}