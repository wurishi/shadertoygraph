{"ver":"0.1","info":{"id":"XtdXzH","date":"1478173845","viewed":510,"name":"Trilateral Blur Denoising","username":"ttoinou","description":"Upgrading https://www.shadertoy.com/view/MtcSzH with a before / after comparison on a given line to visualize denoising !\nNote : the denoising is done in 2D (not on the 1D line)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["blur","gradient","gaussian","comparison","bilateral","denoising","trilateral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see https://www.shadertoy.com/view/MtcSzH\n// for Trilateral Blur (previous buffer)\n\n// see https://www.shadertoy.com/view/ltG3WV\n// for line \n\n#define GAMMA       (2.2)\n#define pow3(x,y)   (pow( max(x,0.) , vec3(y) ))\n#define input       iChannel0\n#define output      iChannel1\n\n#define point1      (vec2(.8,.8-cos(iTime/2.)*.3-.3)) // (vec2(0.5,cos(iTime/8.*6.28)*.5+.5 ))\n#define point2      (iMouse.xy/iResolution.xy)\n#define lineMin     (-0.5)\n#define lineMax     (1.5)\n#define lineBlack   (0.5)\n#define pixelSize   (1./min(iResolution.x,iResolution.y))\n#define pointWidth  (3.*pixelSize)\n#define pointSmooth (2.*pixelSize)\n#define lineSmooth  (3.*pixelSize)\n#define aspect \t\t(vec2(1.,iResolution.y/iResolution.x))\n\n#define maxHeight \t\t(1024)\n#define histogramSmooth (2.5*pixelSize)\n#define histogramBlack  (1.)\n#define min3(a,b,c)     (min( (a) , min( (b) , (c) ) ))\n#define minvec3(x)     (min3( (x).r , (x).g , (x).b ))\n\nvec4 showPoint(vec4 colorOut,vec3 color,vec2 coord,vec2 point){\n    return mix(colorOut,vec4(color,1.),\n    \t\t   clamp(1. - max( length( (coord - point)*aspect ) - pointWidth, 0. )/pointSmooth,0.,1.));\n}\n\nvec2 closestPointFromLine(vec2 p,vec2 a,vec2 b,bool segment){\n    a -= p; b -= p;\n  \tvec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  \tfloat t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n    \n    if( segment ){\n    \tt = clamp(t,0.,1.);\n    }\n    \n    return (a+p)*(1.-t) + (b+p)*t;\n}\n\nvec3 sample_(vec2 pos,bool o){\n    if( o ){\n        return texture(output,pos).rgb;\n    } else {\n        return pow3(texture(input,pos).rgb,1./GAMMA);\n    }\n}\n\nvoid addBars(vec3 value,vec2 uv,out vec4 fragColor){\n    vec3 bars = value/4. - vec3(0.,-1./3.,-2./3.)+0.1;\n    bars = (1. - abs( (bars - uv.y) / histogramSmooth ));\n    fragColor.rgb += clamp(bars.rgb,0.,1.);\n    \n    float black = (1. - minvec3( abs(bars) )/histogramBlack);\n    fragColor *= 1. - clamp( black , 0. , 1. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.rgb = sample_(uv,true);\n    \n    // add points\n    fragColor = showPoint(fragColor,vec3(0.5,0.,0.),uv,point1);\n    fragColor = showPoint(fragColor,vec3(0.,0.,0.5),uv,point2);\n    \n    // add line\n    vec2 point12 = point2 - point1;\n    fragColor *= clamp(length(uv - closestPointFromLine(uv,point1,point2,false))/lineSmooth,0.,1.);\n    \n    // normalize line\n    vec2 a = point1;\n    vec2 ab = (point2 - point1);///length(point2 - point1);\n    \n    // mean computing\n    vec2 pos = mix(lineMin,lineMax,uv.x)*ab + a;\n    \n    // add histogram\n\taddBars(sample_(pos,false),uv,fragColor);\n\taddBars(sample_(pos,true)-vec3(0.4),uv,fragColor);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GAMMA        (2.2)\n#define pow3(x,y)    (pow( max(x,0.) , vec3(y) ))\n\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.rgb = pow3(texture(iChannel0,fragCoord/iResolution.xy).rgb,GAMMA);\n    // comment to remove random noise\n    fragColor.rgb += (hash33(vec3(fragCoord.xy,iTime))-.5)*0.1;\n    fragColor.a = 1.;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// continuous gradient\n// https://www.shadertoy.com/view/XtK3Dd\n#define GRADIENT_RADIUS (8)\n#define PI           (3.14159265359)\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\n#define gradientInput iChannel0\n#define gradientDirectionX (true)\n\n#define GRADIENT_RADIUSf float(GRADIENT_RADIUS)\n#define GRADIENT_RADIUSi22f 4./float(GRADIENT_RADIUS*GRADIENT_RADIUS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    \n    for( int i = -GRADIENT_RADIUS ; i <= GRADIENT_RADIUS ; i++ ){\n    \tfor( int j = -GRADIENT_RADIUS ; j <= GRADIENT_RADIUS ; j++ ){\n            fragColor += (gradientDirectionX ? float(i) : float(j))\n                *exp(-float(i*i + j*j)*GRADIENT_RADIUSi22f)/GRADIENT_RADIUSf\n                *texture(gradientInput,(fragCoord.xy+vec2(i,j))/iResolution.xy);\n        }\n        \n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// continuous gradient\n// https://www.shadertoy.com/view/XtK3Dd\n#define GRADIENT_RADIUS (8)\n#define PI           (3.14159265359)\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\n#define gradientInput iChannel0\n#define gradientDirectionX (false)\n\n#define GRADIENT_RADIUSf float(GRADIENT_RADIUS)\n#define GRADIENT_RADIUSi22f 4./float(GRADIENT_RADIUS*GRADIENT_RADIUS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    \n    for( int i = -GRADIENT_RADIUS ; i <= GRADIENT_RADIUS ; i++ ){\n    \tfor( int j = -GRADIENT_RADIUS ; j <= GRADIENT_RADIUS ; j++ ){\n            fragColor += (gradientDirectionX ? float(i) : float(j))\n                *exp(-float(i*i + j*j)*GRADIENT_RADIUSi22f)/GRADIENT_RADIUSf\n                *texture(gradientInput,(fragCoord.xy+vec2(i,j))/iResolution.xy);\n        }\n        \n    }\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define input \tiChannel0\n#define inputDX iChannel1\n#define inputDY iChannel2\n\n// my take on Trilateral Filtering\n// http://dl.acm.org/citation.cfm?id=882431\n\n// Upgrading Bilateral Blur with Gradient\n// https://www.shadertoy.com/view/MlVGW3\n#define RADIUS     (12)\n#define DIAMETER   (2*RADIUS+1)\n\n// bigger theses coeff the more we take into account the space concerned\n\n// shouldn't need to change it\n// close to 0 => square-shaped\n#define COORDCOEFF (1.41)\n\n// if theses two == 0. => filter is a gaussian blur\n// the closer to zero the blurier\n// the bigger the more selective\n#define LUMCOEFF   (8.)\n#define GRADCOEFF  (8.)\n\n// see line 84\n// not confident in my calculus in buffB & buffC\n#define LUMPLANECORRECTION (1.)\n\n#define GAMMA        (2.2)\n#define pow3(x,y)    (pow( max(x,0.) , vec3(y) ))\n#define LUMWEIGHT    (vec4(0.2126,0.7152,0.0722,0.3333))\n#define GRADIENT_RADIUS (8)\n\n#define GRADIENT_RADIUSf float(GRADIENT_RADIUS)\n#define GRADIENT_RADIUSi22f (4./float(GRADIENT_RADIUS*GRADIENT_RADIUS))\n#define PI           (3.14159265359)\n#define viewport(x) ( (x) /iResolution.xy)\n\n#define DX          (iMouse.x/iResolution.x)\n#define DY          (iMouse.y/iResolution.y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = viewport(fragCoord);\n    \n    vec4 thisColor = texture(input,uv);\n    vec4 thisGradX = texture(inputDX,uv);\n    vec4 thisGradY = texture(inputDY,uv);\n    \n    fragColor = vec4(0.);\n    vec4 diffColorToGradient;\n    vec4 diffGradientX;\n    vec4 diffGradientY;\n    float sum = 0.;\n    float coeff;\n    vec2 pos;\n    vec4 color = vec4(0.);\n    vec4 gradX = vec4(0.);\n    vec4 gradY = vec4(0.);\n    \n    float GradCoeff2 = GRADCOEFF*GRADCOEFF;\n    float LumCoeff2 = LUMCOEFF*LUMCOEFF;\n    float CoordCoeff2 = COORDCOEFF*COORDCOEFF/float(RADIUS*RADIUS);\n    \n    for( int i = -RADIUS ; i <= RADIUS ; i++ ){\n        for( int j = -RADIUS ; j <= RADIUS ; j++ ){\n            \n            pos = viewport(fragCoord.xy+vec2(i,j));\n            color = texture(input,pos);\n            gradX = texture(inputDX,pos);\n            gradY = texture(inputDY,pos);\n            \n            diffGradientX = thisGradX - gradX;\n            diffGradientY = thisGradY - gradY;\n            \n            diffColorToGradient = thisColor - color\n                // minus sign ? I must have made an error in buffB & buffC :-( \n                - (thisGradX*float(i) + thisGradY*float(j))*GRADIENT_RADIUSi22f*LUMPLANECORRECTION;\n            \n            coeff = exp( -(\n                // blur in coordinate space\n                float(i*i+j*j)*CoordCoeff2\n                // blur in distance to first local approximation\n                // instead of blur in color space\n                + dot(diffColorToGradient,diffColorToGradient)*LumCoeff2\n                // blur in gradient space\n                + dot( diffGradientX*diffGradientX + diffGradientY*diffGradientY , LUMWEIGHT )*GradCoeff2\n                ));\n            \n            \n            if( i == -RADIUS && j == -RADIUS ){\n            \tfragColor = color*coeff;\n            } else {\n            \tfragColor += color*coeff;\n            }\n            \n            sum += coeff;\n            \n        }\n    }\n    \n    // no need for uncertainty map (mix to thisColor based on sum log value)\n    // like in https://www.shadertoy.com/view/MlVGW3 ?\n\tfragColor = fragColor/sum;\n    \n\tfragColor.rgb = pow3(fragColor.rgb,1./GAMMA);\n    fragColor.a = 1.;\n}\n","name":"Buf D","description":"","type":"buffer"}]}