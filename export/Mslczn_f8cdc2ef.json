{"ver":"0.1","info":{"id":"Mslczn","date":"1486868185","viewed":295,"name":"Lonely Voxel","username":"SudoNhim","description":"Just reading through some of shane's code learning how to do surfaces. I'm going to integrate this into my voxel tracer :)","likes":9,"published":1,"flags":64,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dSGWG","filepath":"https://soundcloud.com/llama-lamp/ice-ice-polkka","previewfilepath":"https://soundcloud.com/llama-lamp/ice-ice-polkka","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel1, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel1, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat dfVoxel(vec3 p)\n{\n    vec3 cube = vec3(0.5, 0.5, 0.5);\n    return length(max(abs(p)-(cube - 0.1),0.0)) - 0.1;\n}\n\nvec3 nrmVoxel(vec3 p) \n{\n    p += 0.001 * normalize(p);\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy) - base,\n        dfVoxel(p+dd.yxy) - base,\n        dfVoxel(p+dd.yyx) - base\n    ));\n}\n\n// Stolen from shane's Voxel Corridor: https://www.shadertoy.com/view/MdVSDh# :)\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Stolen from shane's Voxel Corridor: https://www.shadertoy.com/view/MdVSDh# :)\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nvec3 lightVoxel(vec3 p, vec3 rd)\n{\n    vec3 n = nrmVoxel(p);\n    vec3 color = tex3D(iChannel1, p, n) * vec3(1.0, 0.7, 0.7);\n    vec3 bumpedN = doBumpMap(iChannel1, p, n, 0.02);\n    vec3 ldir = normalize(vec3(1.0));\n    float diffuse = max(0.0, dot(bumpedN, ldir));\n    float specular = pow(max(0.0, dot(-rd, reflect(-ldir, bumpedN))), 16.0);\n    return color * (diffuse + 0.3) + specular*0.3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float p = iMouse.x/iResolution.x*10.0;\n    vec3 ro = vec3(sin(iTime*0.5+p)*2.0, sin(iTime*0.3)+1.4, cos(iTime*0.5+p)*2.0);\n    ro = ro + ro*pow(iMouse.y/iResolution.y, 2.0)*10.0;\n    vec3 rd = normalize(-ro);\n    \n\tvec3 ax1 = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 ax2 = normalize(cross(rd, ax1));\n    \n    rd = normalize(rd*3.0 + ax1*uv.x + ax2*uv.y);\n    \n    // iq's cube intersection :)\n    vec3 cubeIntersect = (-ro -0.8*sign(rd))/rd;\n    float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    float incr = 0.0;\n    \n    for (int i=0; i<32; i++) {\n        incr = dfVoxel(ro + rd*dist)/2.0;\n        dist += incr;\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (incr < 0.05) {\n        fragColor.rgb = lightVoxel(dist*rd + ro, rd);\n    } else {\n     \tfragColor.rgb = sin(texture(iChannel0, vec2((uv.x+1.0)*0.5, 0.5)).r*vec3(9.3, 7.5, 5.9));   \n    }\n}","name":"Image","description":"","type":"image"}]}