{"ver":"0.1","info":{"id":"lfdyW8","date":"1730642011","viewed":118,"name":"DCT-II","username":"vchizhov","description":"Computes the (even) orthogonal discrete cosine transform of type 2. Applies the Laplacian in the cosine frequency domain. ","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["laplacian","dct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n        \n#if MODE==0 \n    vec4 s = texture(iChannel1,uv);   // power spectrum\n    vec4 col = abs(s)*20.0;\n#elif MODE==1\n    vec4 col = texture(iChannel0,uv); // verbatim reconstruction\n#elif MODE==2\n    vec4 s = texture(iChannel1,uv);   // Laplacian eigenvalues weighted spectrum\n    vec4 col = abs(s)*20.0;\n#elif MODE==3\n    vec4 col = texture(iChannel0,uv)*10.0; // 5-point stencil Laplacian convolved image\n#endif\n        \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // transforms the rows of the image\n    vec4 r = DCT_IIe_row_img_grey(iChannel3, fragCoord.xy, iResolution.xy);\n\n    fragColor = r;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // transforms the columns of the image\n    vec4 r = DCT_IIe_col(iChannel0, fragCoord.xy, iResolution.xy);\n    \n    \n#if MODE>1\n    // take into account the aspect ratio so that the Gaussian is isotropic\n    vec2 uv;\n    if (iResolution.y<=iResolution.x) // h<=w\n        uv = fragCoord.xy/iResolution.x;\n    else // h>w\n        uv = fragCoord.xy/iResolution.y;\n    // weigh with a Gaussian\n    //r = r * exp(-PI*PI*dot(uv,uv)*(STD*STD));\n    \n    int w = int(iResolution.x);\n    int h = int(iResolution.y);\n    int i = int(fragCoord.x);\n    int j = int(fragCoord.y);\n    \n    float l = -4.0* sin(PI*float(i)/(2.0*float(w)))*sin(PI*float(i)/(2.0*float(w)))  \n            -4.0 * sin(PI*float(j)/(2.0*float(h)))*sin(PI*float(j)/(2.0*float(h)));\n    r = r * l;\n    \n#endif\n    \n    fragColor = r;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // backtransforms the columns of the image\n    vec4 r = DCT_IIIe_col(iChannel0, fragCoord.xy, iResolution.xy);\n    \n    fragColor = r;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // backtransforms the rows of the image\n    vec4 r = DCT_IIIe_row(iChannel0, fragCoord.xy, iResolution.xy);\n\n    fragColor = r;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// README:\n\n// Applies the discrete cosine transform of type II even (DCT-IIe) \n// along the rows (bufA), along the columns (bufB)\n// and then applies the inverse discrete cosine transform (IDCT-IIe) \n// along the columns (bufC), and along the rows (bufD)\n// Note that IDCT-IIe = DCT-IIIe.\n// Note also that I have implemented the orthogonal versions of DCT-IIe and DCT-IIIe.\n\n// MODE==0 shows the power spectrum |hat{u}|^2\n// MODE==1 transforms and backtransforms (it is a sanity check)\n\n// If MODE>2 then the 5-point stencil Laplacian is applied in the cosine frequency domain\n// by multiplying the cosine transform of the 5-point stencil with the frequency \n// representation of the image hat{u}.\n\n// The convolution that occurs through this is one where the image is mirrored. \n// Contrast to convolution using the DFT, where the image is repeated (so toroidal convolution).\n\n// MODE==0: power spectrum\n// MODE==1: video\n// MODE==2: power spectrum of the weighted transform\n// MODE==3: frequency-space blurred video\n#define MODE 3\n\n\n#define PI 3.14159265358979323846264338327950288420\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //     \n//                  Discrete Cosine Transform of RGBA data                  //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n// For the definitions see: \n// https://en.wikipedia.org/wiki/Discrete_cosine_transform#Formal_definition\n// Note that I am using the orthogonal versions of the DCTs\n\nvec4 DCT_IIe_row_img_grey(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // DCT-IIe along the j-th row\n    float factor = PI*float(i)/float(w);\n    vec4 a = vec4(0);\n    for (int k=0; k<w; ++k)\n    {\n        vec4 s = texture(f, vec2(k,j)/res);\n        float t = (float(k)+0.5)*factor;\n        a = a + cos(t) * s;\n    }\n    // orthogonal \n    if (i==0)\n        a = a / sqrt(float(w));\n    else\n        a = a * sqrt(2.0/float(w));\n    return a;\n}\n\nvec4 DCT_IIe_row(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n\n    // DCT-IIe along the j-th row\n    float factor = PI*float(i)/float(w);\n    vec4 a = vec4(0);\n    for (int k=0; k<w; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(k,j), 0);\n        float t = (float(k)+0.5)*factor;\n        a = a + cos(t) * s;\n    }\n    // orthogonal \n    if (i==0)\n        a = a / sqrt(float(w));\n    else\n        a = a * sqrt(2.0/float(w));\n    \n    return a;\n}\n\nvec4 DCT_IIIe_row(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n\n    // DCT-IIIe transform along the j-th row\n    float factor = PI*(float(i)+0.5)/float(w);\n    vec4 a = vec4(0);\n    for (int k=0; k<w; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(k,j), 0);\n        float t = float(k)*factor;\n        a = a + cos(t) * s;\n        // orthogonal\n        if (k==0)\n            a = a / sqrt(2.0);\n    }\n    // orthogonal\n    a = a * sqrt(2.0/float(w));\n    \n    return a;\n}\n\nvec4 DCT_IIe_col(sampler2D f, vec2 xy, vec2 res)\n{\n    int h = int(res.y);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // DCT-IIe along the i-th column\n    float factor = PI*float(j)/float(h);\n    vec4 a = vec4(0);\n    for (int k=0; k<h; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(i,k), 0);\n        float t = (float(k)+0.5)*factor;\n        a = a + cos(t) * s;\n    }\n    // orthogonal \n    if (j==0)\n        a = a / sqrt(float(h));\n    else\n        a = a * sqrt(2.0/float(h));\n    \n    return a;\n}\n\nvec4 DCT_IIIe_col(sampler2D f, vec2 xy, vec2 res)\n{\n    int h = int(res.y);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // DCT-IIIe along the i-th column\n    float factor = PI*(float(j)+0.5)/float(h);\n    vec4 a = vec4(0);\n    for (int k=0; k<h; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(i,k), 0);\n        float t = float(k)*factor;\n        a = a + cos(t) * s;\n        // orthogonal\n        if (k==0)\n            a = a / sqrt(2.0);\n    }\n    // orthogonal \n    if (j==0)\n        a = a / sqrt(float(h));\n    else\n        a = a * sqrt(2.0/float(h));\n    \n    return a;\n}\n\n","name":"Common","description":"","type":"common"}]}