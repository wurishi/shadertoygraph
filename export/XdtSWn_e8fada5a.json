{"ver":"0.1","info":{"id":"XdtSWn","date":"1458714130","viewed":2401,"name":"Shader Lesson #10, saving state","username":"hubbe","description":"Illustrates how to save state between frames. A simple physics engine emulates 300 bouncing balls.\n","likes":37,"published":1,"flags":32,"usePreview":0,"tags":["educational"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of balls.\n#define BALLS 300\n\n// Radius of balls.\n#define R 0.01\n\n// This function returns where in iChannel0, the position of ball \"v\" is.\nvec2 BallVarPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    \n    fragColor = vec4(0,0,0,1);\n\n    // Iterate through all the balls, if this pixel is inside one of them,\n    // then assign the output pixel to that color.\n    for (int i = 0; i < BALLS; i++) {\n        vec2 pos = texture(iChannel0, BallVarPos(i)).xy;\n        float dist = length(uv - pos);\n        if (dist < R) {\n            vec3 rgb = vec3(mod(float(i) / 3.0, 1.0),\n                            mod(float(i) / 5.0, 1.0),\n                            mod(float(i) / 7.0, 1.0));\n            // Calculate normal vector for the ball.\n            vec3 norm = normalize(vec3((uv-pos).xy, - sqrt(R * R - dist * dist)));\n            // Incoming light.\n            vec3 sunray = normalize(vec3(-1.0,1.0,-1.0));\n            // Color\n            fragColor.xyz = rgb * (1.0 + dot(norm, sunray));\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Number of balls.\n#define BALLS 300\n\n// Radius of balls.\n#define R 0.01\n\n// This function returns where in iChannel0, the position of ball \"v\" is.\nvec2 BallVarPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\n\n// Given a position in iChannel0, return which ball position is stored there.\nint BallNum(vec2 xy) {\n  xy *= iChannelResolution[0].xy;\n  xy = floor(xy);\n  return int(xy.x + xy.y * iChannelResolution[0].x);\n}\n\n// Return a \"random\" number.\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // Figure out which ball we're currently processing.\n    int ball = BallNum(uv);\n    if (ball < 0 || ball >= BALLS) discard;\n\n    // The four channels are used to store position and speed of each ball.\n    vec4 posandspeed = texture(iChannel0, uv);\n    vec2 pos = posandspeed.xy;\n    vec2 speed = posandspeed.zw;\n\n    // Iterate through all the balls.\n    for (int i = 0; i < BALLS; i++) {\n\t\t// If it's the same ball, ignore it.\n        if (i == ball) continue;\n\n        // Get the position and speed of ball i.\n        vec4 p = texture(iChannel0, BallVarPos(i)); \n\n        // Calculate the distance between the centers of the two balls.\n        float dist = length(p.xy - pos);\n\n        // If it's smaller than the diameter, we have a collision.\n        if (dist < R * 2.0) {\n            vec2 collision_normal = normalize(pos - p.xy);\n            vec2 collision_tangent = vec2(collision_normal.y, -collision_normal.x);\n            // How fast *the other ball* is going in the \"collision_normal\" direction.\n            float a1 = dot(p.zw, collision_normal);\n            // How fast *this* ball is going in the \"collision_normal\" direction.\n            float a2 = dot(speed, collision_normal);\n            // How fast *this* ball is going in the \"collision tangent\" direction.\n            float b = dot(speed, collision_tangent);\n            // Our new speed.\n            speed = collision_normal * (a2 + (a1 - a2) * 0.9) + collision_tangent * b;\n            \n            // Also, move the ball away to make sure we're not colliding anymore.\n            pos = p.xy + (pos - p.xy) * R * 2.001 / dist;\n        }\n    }   \n\n    // Move the ball\n    pos += speed;\n    // Air resistance.\n    speed *= 0.9999;\n    // Gravity\n    speed.y -= 0.0001;\n\n    // If we reach the bottom, invert the speed in the y direction.\n    if (pos.y < 0.0) { pos.y = -pos.y; speed.y = abs(speed.y * 0.9); }\n\n    // If we reach left/right wall, invert the speed in the x direction. \n    if (pos.x < 0.0) { pos.x = -pos.x; speed.x = abs(speed.x * 0.9); }\n    if (pos.x > 1.0) { pos.x = 2.0 - pos.x; speed.x = -abs(speed.x * 0.9); }\n\n    // If this is the first frame, initialize position and speed to something random.\n    if (iFrame == 1) {\n        pos = vec2(rand(uv), rand(uv.yx));\n        speed = vec2((rand(uv + vec2(0.1))-0.5) / 30.0,\n                     (rand(uv + vec2(0.2))-0.5) / 30.0);\n    }\n    // Store position and speed in the output (which is also iChannel0).\n    fragColor = vec4(pos, speed);\n}","name":"Buf A","description":"","type":"buffer"}]}