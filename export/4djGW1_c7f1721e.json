{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by Vinicius Graciano Santos - vgs/2013\n// I've learned a lot about fractals in this series of blog posts:\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n\n#define TAU 6.283185\n\n// play with this value (try 3)\n#define SIDES 10\n\n// uncomment to see that the polygon lies within the unit circle.\n//#define UCIRCLE\n\nfloat fractal(in vec2 uv) {\n\tfloat c = cos(1.0/float(SIDES)*TAU);\n\tfloat s = sin(1.0/float(SIDES)*TAU);\n\t\n\tmat2 m = mat2(c, s, -s, c);\n\tvec2 p = vec2(1.0, 0.0), r = p;\n\t\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfloat dmin = length(uv - r);\n\t\tfor (int j = 0; j < SIDES; ++j) {\n\t\t\tp = m*p;\n\t\t\tfloat d = length(uv - p); \n\t\t\tif (d < dmin) {dmin = d; r = p;}\n\t\t}\n\t\tuv = 2.0*uv - r;\n\t}\n\t\n\treturn (length(uv-r)-0.15)/pow(2.0, 7.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat vig = 0.15 + pow(uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1);\n\t\n\tuv = -1.0+2.0*uv;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tfloat d = fractal(uv);\n\td = smoothstep(0.001, 0.015, d);\n\t\n\t#ifdef UCIRCLE\n\td *= 1.0-length(uv);\n\t#endif\n\t\t\n\tfragColor = vec4(vec3(pow(vig*d, 0.45)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4djGW1","date":"1387242910","viewed":2316,"name":"Sierpinski Polygon","username":"vgs","description":"I inserted some additional reference points into the Sierpinski Triangle algorithm and got this interesting result. Change the value in line 8 in order to generate other regular polygons. The Sierpinski Triangle can be produced with SIDES = 3.","likes":49,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","simple","sierpinski"],"hasliked":0,"parentid":"","parentname":""}}