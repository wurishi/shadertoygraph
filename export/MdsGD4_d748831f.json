{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Simple raymarcher\n// psde, 2013\n\nconst float EPSILON = 0.00001;\nconst int MAX_ITERATIONS = 256;\nconst float MAX_DEPTH = 128.0;\n\nstruct Camera\n{\n\tvec3 position;\n\tvec3 dir;\n\tvec3 up;\n\tvec3 rayDir;\n\tvec2 screenPosition;\n};\n\nstruct Material\n{\n\tvec3 color;\n};\n\t\nstruct MapResult\n{\n\tfloat dist;\n\tMaterial material;\n};\n\t\nstruct MarchResult\n{\n\tMapResult hit;\n\tvec3 position;\n\tvec3 normal;\n};\n\nCamera getCamera(in vec3 dir, in vec3 position, in vec3 up, in vec2 fragCoord)\n{\n\tCamera cam;\n  \tcam.dir = dir;\n\tcam.position = position;\n\tcam.up = up;\n  \tvec3 forward = normalize(cam.dir - cam.position);\n  \tvec3 left = cross(forward, cam.up);\n \tcam.up = cross(left, forward);\n \n\tvec3 screenOrigin = (cam.position+forward);\n\tcam.screenPosition = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n \tfloat screenAspectRatio = iResolution.x/iResolution.y;\n\tvec3 screenHit = screenOrigin + cam.screenPosition.x * left * screenAspectRatio + cam.screenPosition.y * cam.up;\n  \n\tcam.rayDir = normalize(screenHit-cam.position);\n\treturn cam;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n\t\t    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n\t\t    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n\t\t    0.0, 0.0, 0.0, 1.0);\n}\n\nMapResult combine(MapResult a, MapResult b)\n{\n\tif(a.dist < b.dist)\n\t{\n\t\treturn a;\t\n\t}\n\treturn b;\n}\n\nMapResult map_cube(vec3 position)\n{\n\tMapResult result;\n\tresult.material.color = vec3(1.0, 0.5, 0.2);\n\t\n\tfloat cube = length(max(abs(position) - vec3(1.2), 0.0)) - 0.1;\n\t\n\tfloat sphere = length(position) - 1.6 - (0.1 + sin(iTime) * 0.2);\n\t\n\tfloat d = max(cube, -sphere);\n\t\t\n\tresult.dist = d;\n\treturn result;\n}\n\nMapResult map_torus(vec3 position)\n{\n\tMapResult result;\n\tresult.material.color = vec3(0.0, 0.5, 0.8);\n\t\n\tposition = (rotationMatrix(vec3(0,0,1), iTime) * vec4(position, 1.0)).xyz;\n\tposition = (rotationMatrix(vec3(0,1,0), iTime) * vec4(position, 1.0)).xyz;\n\tposition = (rotationMatrix(vec3(1,0,0), iTime) * vec4(position, 1.0)).xyz;\n\t\n\tvec2 q = vec2(length(position.xz) - 2.5, position.y);\n\tresult.dist = length(q) - 0.2;\n\t\t\t\n\treturn result;\n}\n\nMapResult map_floor(vec3 position)\n{\n\tMapResult result;\n\tresult.dist = dot(position, vec3(0.0, 1.0, 0.0)) + 2.5;\n\tresult.material.color = textureLod(iChannel0, position.xz * 0.15, 0.0).rgb;\n\t\n\treturn result;\n}\n\nMapResult map(vec3 position)\n{\n\tMapResult result;\n\t\n\tresult = map_floor(position);\n\t\n\tresult = combine(result, map_cube(position));\n\tresult = combine(result, map_torus(position));\n\t\t\n\treturn result;\n}\n\nMarchResult raymarch(const in Camera cam)\n{\n\tMarchResult march;\n\t\n\tfloat depth = 0.0;\n\tfor(int i = 0; i < MAX_ITERATIONS; ++i)\n\t{\n\t\tmarch.position = cam.position + cam.rayDir * depth;\n\t\tmarch.hit = map(march.position);\n\t\t\n\t\t\n\t\tif(march.hit.dist <= EPSILON || depth >= MAX_DEPTH)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdepth += march.hit.dist;\n\t}\n\t\n\tif(depth < MAX_DEPTH)\n\t{\n\t\tvec3 eps = vec3(EPSILON, 0, 0);\n\t\tmarch.normal=normalize(\n\t\t\t   vec3(march.hit.dist - map(march.position-eps.xyy).dist,\n\t\t\t\t\tmarch.hit.dist - map(march.position-eps.yxy).dist,\n\t\t\t\t\tmarch.hit.dist - map(march.position-eps.yyx).dist));\n\t\t\n\t}\n\t\n\treturn march;\n}\n\nvec3 getColor(const in Camera cam, const in MarchResult march)\n{\t\n\tfloat lambert = dot(march.normal, -cam.rayDir);\n\t\n\tvec3 color = lambert * march.hit.material.color;\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\t\n\t// Set up camera\n  \tvec3 cam_dir = vec3(0,0,0);\n\tfloat t = (iTime+3.0) * 0.15;\n\tvec3 cam_position = vec3(sin(t + 1.0)*4.0, 5, cos(t)*4.0);\n\tvec3 cam_up = vec3(0,1,0);\n\t\n\tCamera cam = getCamera(cam_dir, cam_position, cam_up, fragCoord);\n\t\n\t// Raymarch\n\tMarchResult result = raymarch(cam);\n\t\n\tvec3 color = getColor(cam, result);\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdsGD4","date":"1371112980","viewed":347,"name":"Simple raymarcher","username":"psde","description":"My first simple raymarching experiment, trying to keep the code clean and simple. I think it is way to unflexible to work with, but the basics are there - maybe someone will learn something :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","beginner"],"hasliked":0,"parentid":"","parentname":""}}