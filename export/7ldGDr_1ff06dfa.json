{"ver":"0.1","info":{"id":"7ldGDr","date":"1663500998","viewed":78,"name":"snow floating","username":"Wally869","description":"snow floating","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    float distance = 999.0;\n    float temp;\n    vec2 posParticle;\n    Particle part;\n    float closestThreshold = 999.0;\n    for (int i = 0; i < NB_PARTICLES; i++) {\n        //posParticle = currentPosition(i, iTime);\n        //temp = (posParticle.x - uv.x) * (posParticle.x - uv.x) + (posParticle.y - uv.y) * (posParticle.y - uv.y);\n\n        part = getParticle(i);\n        \n        posParticle = getCurrentPosition(part, iTime);\n        \n        temp = (uv.x - posParticle.x) * (uv.x - posParticle.x) + (uv.y - posParticle.y) * (uv.y - posParticle.y);\n        \n        if (temp < distance) {\n           distance = temp < distance ? temp : distance;\n           closestThreshold = part.size;\n        }\n    }\n    \n    \n    vec4 inCol = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 outCol = vec4(0.0, 0.0, 0.0, 1.0);\n        \n    // Output to screen\n    float mask = distance < closestThreshold * 0.05 ? 1.0 : 0.0;\n    \n    \n    //fragColor = vec4(mask, mask, mask, 1.0);\n    \n    fragColor = mix(inCol, outCol, distance / (closestThreshold * 0.1));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// define initial position particle\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NB_PARTICLES 100\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// from https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\nstruct Particle {\n    vec2 initPos;\n    float size;\n    float amplitude;\n};\n\n\nParticle getParticle(int id) {\n    return Particle(\n        Hash12(float(id)),\n        Hash11(float(id)) * (0.001 - 0.0002) + 0.0002,\n        Hash11(float(id)) * 0.25\n    );\n\n}\n\nvec2 initialPosition(int id) {    \n    return Hash12(float(id));\n}\n\n\nvec2 initialPosition(vec2 pos) {\n    return vec2(hash(pos), hash(vec2(pos.y, pos.x)));\n\n}\n\n\nvec2 currentPosition(vec2 pos, float time) {\n    vec2 outPos = initialPosition(pos);\n    outPos.x += 0.1 * sin(time * 6.2830 * 0.1);\n    outPos.y = fract(outPos.y - time * 0.1);\n    \n    return outPos;\n}\n\nvec2 currentPosition(int idParticle, float time) {\n    vec2 outPos = initialPosition(idParticle);\n    outPos.x += 0.1 * sin(time * 6.2830 * 0.25);\n    outPos.y = fract(outPos.y - time * 0.5);\n    \n    outPos.y = outPos.y < -0.1 ? outPos.y = 1.1 : outPos.y;\n\n    \n    return outPos;\n}\n\n\nvec2 getCurrentPosition(Particle part, float time) {\n    vec2 outPos = part.initPos;\n    \n    outPos.x += part.amplitude * sin(time * 6.2830 * part.size * 100.0);\n    \n    outPos.y = fract(outPos.y - pow(part.size, 0.1) * time);\n        \n    return outPos;\n\n}","name":"Common","description":"","type":"common"}]}