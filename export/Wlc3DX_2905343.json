{"ver":"0.1","info":{"id":"Wlc3DX","date":"1577702838","viewed":384,"name":"Horizon Zero Dawn Clouds 3D ","username":"blindneko","description":"3D clouds based on GPU Pro 7 Real-Time Volumetric Cloudscapes. The frame rate is pretty slow because I generate 3D noise in real time. Some work is base on https://www.shadertoy.com/view/WddSDr by piyushslayer.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SampleCloudDensity(vec3 pos)\n{\n    vec4 low_frequency_noises = GetLowFrequencyPerlinWorleyNoise(pos);\n\n    // worley fbm noise\n    float low_freq_FBM = (low_frequency_noises.g * 0.625)\n                         + (low_frequency_noises.b * 0.25)\n                         + (low_frequency_noises.a * 0.125);\n    \n    // define the base cloud shape\n    float base_cloud = Remap(low_frequency_noises.r, -(1.0 - low_freq_FBM), 1.0, 0.0, 1.0);\n    base_cloud = Remap(base_cloud, .8, 1., 0., 1.);\n    return base_cloud * CLOUD_COVERAGE;\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nfloat Render(vec3 ro, vec3 rd)\n{\n    int sample_count = 2;\n    float density = 0.0;\n    float cloud_test = 0.0;\n    int zero_density_sample_count = 0;\n    vec3 p = ro;\n    vec3 step = rd;\n    vec3 weather_data;\n\n    for (int i = 0; i < sample_count; ++i)\n    {\n        if (cloud_test > 0.0)\n        {\n            float sampled_density = SampleCloudDensity(p);\n\n            if (sampled_density == 0.0)\n            {\n                zero_density_sample_count++;\n            }\n\n            if (zero_density_sample_count != 6)\n            {\n                density += sampled_density;\n                p += step;\n            }\n            else\n            {\n                cloud_test = 0.0;\n                zero_density_sample_count = 0;\n            }\n        }\n        else\n        {\n            cloud_test = SampleCloudDensity(p);\n\n            if (cloud_test == 0.0)\n            {\n                p += step;\n            }\n        }\n    }\n    return density;\n}\n\nvec4 integrate( in vec4 sum, in float dif, in float den)\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0, 0.6, 0.3)*dif;        \n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n    col.xyz *= lin;\n    //col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n   \tvec4 sum = vec4(0.0);\n    \n    float t = 0.0;\n    for (int i = 0; i < 30; ++i)\n    {\n     \tvec3 pos = ro + t * rd;\n        if (pos.y < -3. || pos.y > 2. || sum.a > 0.99)\n            break;\n        float den = SampleCloudDensity(pos);\n        if (den > 0.01)\n        {\n         \tfloat dif = clamp((den - SampleCloudDensity(pos + 2.5 * sundir))/0.6, 0.0, 1.0);\n            sum = integrate(sum, dif, den);\n        }\n        t += max(0.05, 0.02 * t);\n    }\n    \n    return clamp(sum, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = 4. * normalize(vec3(sin(3.*m.x), 0.4*m.y, cos(3.*m.x)));\n    vec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = SetCamera(ro, ta, 0.0);\n    \n \tvec3 rd = ca * normalize(vec3(p.xy, 1.5));\n    \n    \n    // test\n    vec3 col = vec3(0.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pos = ro + 2. * rd;\n    //pos = ro + vec3(p.x, -2.0, p.y);\n    //col += GetLowFrequencyPerlinWorleyNoise(pos).w;\n    //col += SampleCloudDensity(pos);\n    //fragColor = vec4(col, 1.0);\n    // test\n    fragColor = raymarch(ro, rd);\n    //fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n#define CLOUD_COVERAGE 0.85\n#define CLOUD_AMBIENT .01\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat hash13(vec3 p)\n{\n \tuvec3 q = uvec3(ivec3(p)) * UI3;\n    uint n = (q.x ^ q.y ^ q.z) * UI0;\n    return float(n) * UIF;\n    //p  = fract(p * .1031);\n    //p += dot(p, p.yzx + 33.33);\n    //return fract((p.x + p.y) * p.z);\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\n// Remap a value from original range to new range\nfloat Remap(float original_value, float original_min, float original_max, float new_min, float new_max)\n{\n    return new_min + (original_value - original_min) / (original_max - original_min) * (new_max - new_min);\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat GradientNoise(vec3 x, float freq)\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n    \n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n    \n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\nfloat WorleyNoise(vec3 uv, float freq)\n{\n \tvec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n     \tfor (float y = -1.; y <= 1.; ++y)\n        {\n         \tfor (float z = -1.; z <= 1.; ++z)\n            {\n             \tvec3 offset = vec3(x, y, z);\n                vec3 h = hash33(mod(id + offset, vec3(freq))) * .4 + .3;\n                h += offset;\n                vec3 d = p - h;\n                minDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    return 1. - minDist;\n}\n\nfloat Perlinfbm(vec3 p, float freq, int octaves)\n{\n \tfloat G = exp2(-0.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n     \tnoise += amp * GradientNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    return noise;\n}\n\nfloat Worleyfbm(vec3 p, float freq)\n{\n \treturn WorleyNoise(p * freq, freq) * .625 +\n           WorleyNoise(p * freq * 2., freq * 2.01) * .25 +\n           WorleyNoise(p * freq * 4., freq * 4.02) * .125;\n}\n\n// r-perlin_worley, g,b,a-worley at increasing frequencies\nvec4 GetLowFrequencyPerlinWorleyNoise(vec3 pos)\n{\n    //float coverage = hash13(pos) * .1 + CLOUD_COVERAGE;\n\tfloat coverage = CLOUD_COVERAGE + 0.1;\n    vec4 col = vec4(0.0);\n    \n    float freq = 4.;\n    \n    float perlin_worley = mix(1., Perlinfbm(pos, 4., 7), .5);\n    perlin_worley = abs(perlin_worley * 2. - 1.);\n    \n    col.g += Worleyfbm(pos, freq);\n    col.b += Worleyfbm(pos, freq * 2.01);\n    col.a += Worleyfbm(pos, freq * 4.02);\n    perlin_worley = Remap(perlin_worley, 0., 1., col.g, 1.);\n    perlin_worley = Remap(perlin_worley, 1. - coverage, 1., 0., 1.0) * coverage;\n    col.r += perlin_worley;\n    return col;\n}\n\nfloat GetCurlNoise(vec3 pos)\n{\n    return 1.0;\n}\n\nvec3 GetHigthFrequencyNoise(vec3 pos)\n{\n    return vec3(1.0);\n}\n\nfloat HG(vec3 inLightVector, vec3 inViewVector, float inG)\n{\n    float cos_angle = dot(normalize(inLightVector), normalize(inViewVector));\n    return (1.0 - inG * inG) / pow((1.0 + inG * inG - 2.0 * inG * cos_angle), 1.5) / (4.0 * 3.14159);\n}\n\nmat3 SetCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}","name":"Common","description":"","type":"common"}]}