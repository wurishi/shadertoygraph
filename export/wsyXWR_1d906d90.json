{"ver":"0.1","info":{"id":"wsyXWR","date":"1573753550","viewed":503,"name":"Repeating Celtic Pattern (360ch)","username":"FabriceNeyret2","description":"golfing + colorization of \"Repeating Celtic Pattern\" by Podis. [url]https://shadertoy.com/view/3syXDz[/url]\n( originally 1114 chars )\n\n( but I wouldn't call it Celtic ;-) )","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["hexagon","pattern","tiling","short","golf","3tweets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// colored golfing of \"Repeating Celtic Pattern\" by Podis. https://shadertoy.com/view/3syXDz\n// ( originally 1114 chars )\n\nfloat r1 = .40,     // original: .38\n      r2 = .41,     // original: .45\n      S =  .577;    // 1./sqrt(3.) \n#define p  10. / iResolution.x   // pixel width\n\n#define D(U,r) smoothstep(-p, p, r - length(U) ) // disc\n\nfloat C( vec2 U, vec2 d )   // --- draw one layer\n{\n    U.y *= S+S;\n    U -= d;\n    if ( mod(U.y, 2.) > 1.) U.x += .5;\n \n    U = fract(U) - S;\n    U.y += .1;      // required. why ?\n\tU.y /= S+S;\n    \n    float v = D(U, r2), a = 0.;\n    for ( ; a++ < 3.;  ) \n        v -= D(U + sin( a*2.1 + vec2(0,33) )*S, r2);\n\n   return v * D(U, r1);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = u*p, d = vec2(1,.65);\n    O = vec4( C(U, d-d ),\n              C(U, d/2.),\n              C(U, d   ),\n              1 );\n}","name":"Image","description":"","type":"image"}]}