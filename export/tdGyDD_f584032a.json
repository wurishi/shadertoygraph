{"ver":"0.1","info":{"id":"tdGyDD","date":"1602846228","viewed":777,"name":"Segment Tracing Fractal","username":"Bananaft","description":"Quick test, original: https://www.shadertoy.com/view/WdKczW\nFast gradient calculation: https://www.shadertoy.com/view/wdGyDD\nPaper on segment Tracing method:\nhttps://diglib.eg.org/bitstream/handle/10.1111/cgf13951/v39i2pp545-554.pdf?sequence=1&isAllowed=y","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SSAA\nconst int SSAA_Cnt = 1;\n#define showCost\n\n#define eps 0.0001\n#define size vec3(2.0,2.0,2.0)\n#define roundr 0.25\n#define global_k 1.25\n#define Lipschitz_GridSize 0.4\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat opTwist(vec3 p)\n{\n    float t = iTime;\n    float k = 0.45*sin(2.0*t); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdRoundBox(q,size,roundr);\n}\nfloat scene(vec3 pos)\n{\n   \tvec2 FcParams = vec2(2.18,-0.18);\n    vec3 CSize = vec3(1.4f,0.87f, 1.1f);\n    vec3 p = pos.xzy * 2.0f;\n    float scale = 1.0f;\n    \n    for( int i=0; i < 4;i++ )\n    {\n        p = 2.0f*clamp(p, -CSize, CSize) - p;\n        float r2 = dot(p,p);\n        //float r2 = dot(p,p+sin(p.z*.5)); //Alternate fractal\n        float k = max((2.f)/(r2), .17f);\n        p     *= k;\n        //p *=rot;\n        //p= p.yzx;\n        p+=vec3(0.2,0.2,-0.5);\n        scale *= k;\n    }\n\n    p = 2.0f*clamp(p, -CSize * 4.f, CSize * 4.f) - p;\n   \n    for( int i=0; i < 8;i++ )\n    {\n        p = 2.0f*clamp(p, -CSize, CSize) - p;\n        float r2 = dot(p,p);\n        //float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal\n        float k = max((FcParams.x)/(r2),  0.027f);\n        p     *= k;\n        scale *= k;\n        p.y += FcParams.y;\n    }\n    \n    float l = p.x;// length(p.xy);\n    //l = mix(l,l2,0.5);\n    float rxy = l - 4.0f;\n    float n = 1.0f * p.z;\n    rxy = max(rxy, -(n) / 4.f);\n    float dist = (rxy) / abs(scale);\n    dist *=.75f;\n \treturn dist;\n}\n\nvec3 calcGradient( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn (vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n           -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)))/(2.0*eps);\n}\nvec3 calcGradientCheap( in vec3 pos ,in float original)\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn (vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n           -vec3(original))/(eps);\n}\n\nfloat calcGradientDirAbs( in vec3 pos, in vec3 dir )\n{\n    return abs(scene(pos + dir*eps) - scene(pos - dir*eps))/(2.0*eps);\n}\n\nvec2 sceneK(vec3 start,vec3 end,vec3 dir)\n{\n    float dist = 0.0;\n    dist = scene(start);\n    \n    //vec3 gs = calcGradient(start);\n    //vec3 ge = calcGradient(end);\n    //vec3 gs = calcGradientCheap(start,dist);\n    //vec3 ge = calcGradientCheap(end,dist);\n    //float fds = abs(dot(gs,dir));\n    //float fde = abs(dot(ge,dir));\n    float fds = calcGradientDirAbs(start, dir);\n    float fde = calcGradientDirAbs(end, dir);\n\n    float lam = max(fds,fde);\n    \n    \n    return vec2(lam,dist);\n}\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;//min max intersect\n\tfloat t = mint;\n\n\tfor(int i=0;i<512;i++)\n\t{\n\t\tfloat d = scene(ro+rd*t);\n\t\tif (d < 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n        float ts = max(abs(d)/global_k, eps);\n\t\tt += ts;\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec2 calcIntersection2( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;\n\tfloat t = mint;\n\tfloat c = 1.5;\n\tfloat ts = (maxt - mint);\n    ts = min(ts,Lipschitz_GridSize);\n\tfor(int i=0;i<512;i++)\n\t{\n        vec3 pt = ro+rd*t;\n\t\tvec3 pts = ro+rd*(t + ts);\n        vec2 data = sceneK(pt,pts,rd);\n\t\tfloat dist = data.y;\n\t\tif (dist < 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n\t\tfloat k = data.x;\n\t\tfloat tk = abs(dist) / max(k,0.01);\n\t\ttk = max(abs(dist)/global_k,min(tk, ts));\n\t\tts = tk;\n\t\tif(tk >= 0.0)\n\t\t{\n\t\t\tt += max(tk, eps);\n\t\t}\n\t\tts = tk * c;\n        ts = min(ts,Lipschitz_GridSize);\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn normalize(vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n                     -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)));\n}\nvec3 illuminate( in vec3 pos , in vec3 camdir )\n{\n    return calcNormal(pos)*0.5+0.5;\n}\n\nvec3 background( vec3 rd )\n{\n\treturn texture(iChannel0, rd).rgb * texture(iChannel0, rd).rgb;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colAcc = vec3(0.0,0.0,0.0);\n    \n    float t = 1.5*iTime;\n    vec3 campos = vec3(10.0*sin(t*0.3),3.5*sin(t*0.5)+6.0,-10.0*cos(t*0.3));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n    #ifdef SSAA\n    for(int i=-SSAA_Cnt;i<SSAA_Cnt;i++)\n    {\n    for(int j=-SSAA_Cnt;j<SSAA_Cnt;j++)\n    {    \n    vec2 xy = (fragCoord.xy+0.5*(vec2(i,j)+vec2(0.5,0.5))/float(SSAA_Cnt) - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    #else\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y); \n    #endif\n\tvec3 camdir = normalize( camMat * vec3(xy,1.0) );\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n        float dist = 0.0;\n    float times = 256.0;\n    if(fragCoord.x/iResolution.x>0.501)\n    {        \n        vec2 data = calcIntersection2(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else if(fragCoord.x/iResolution.x<0.499)\n    {\n        vec2 data = calcIntersection(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    } else dist = -2.0;\n  \n    if (dist==-1.0)\n    {\n        col = background(camdir);\n    }\n    else if(dist == -2.0)\n    {\n        col = vec3(1.0,0.0,0.0);   \n    }\n    else\n    {\n    \tvec3 inters = campos + dist * camdir;\n    \tcol = illuminate(inters, camdir);\n    }\n    \n    float bannerHeight = 0.2;\n    float bannerOffset = 0.5*sin(iTime);\n    if(fragCoord.y/iResolution.y<0.5 +bannerOffset+ bannerHeight && fragCoord.y/iResolution.y>0.5+bannerOffset - bannerHeight)\n    {\n        #ifdef showCost\n        col = mix(vec3(0.0,1.0,0.0),vec3(1.0,0.0,0.0),times/64.0);   \n        #endif\n    }\n        col = pow(col, vec3(0.8));\n        colAcc+=col;\n        \n    #ifdef SSAA\n    }\n    }\n\tfragColor = vec4(colAcc/float(4*SSAA_Cnt*SSAA_Cnt),1.0);\n    #else\n    fragColor = vec4(colAcc,1.0);\n    #endif\n}","name":"Image","description":"","type":"image"}]}