{"ver":"0.1","info":{"id":"fssXzl","date":"1619207923","viewed":133,"name":"Pastel Town :)","username":"dluisnothere","description":"A scene inspired by a Pink City pixel art animation by Wannella on Tumblr!\n(Note: blinn phong lighting on clouds only seems to work on Mac)\nThe fps is a little ridiculous. If anyone has suggestions for how to improve the fps, please let me know!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pastel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///COLORS------------------------------------------------------\nconst vec3 SKY_PINK = vec3(1.0, 0.8, 0.89);\nconst vec3 SKY_MAUVE = vec3(0.784, 0.59, 0.76);\nconst vec3 WHITE = vec3(1.0, 0.95, 0.95);\nconst vec3 LIGHT_DAY = vec3(255.0, 196.0, 214.0) / 255.0;\nconst vec3 LIGHT_NIGHT = vec3(0.4, 0.0, 0.2);\nconst vec3 BUILDING1_BLUE = vec3(151.0, 230.0, 255.0) / 255.0;\nconst vec3 BUILDING2_ROSE = vec3(230.0, 181.0, 181.0) / 255.0;\nconst vec3 BUILDING3_ICE = vec3 (230.0, 230.0, 230.0) / 255.0;\nconst vec3 STREET_GRAY = vec3(64.0, 64.0, 64.0) / 255.0;\nconst vec3 TREE_GREEN = vec3(140.0, 189.0, 175.0) / 255.0;\n\n\n///OTHER CONSTANTS---------------------------------------------\nconst int RAY_STEPS = 256;\nconst vec3 LIGHTPOS = vec3(70.0, 150.0, 150.0);\nconst vec3 LIGHTPOS2 = vec3(55.0, 40.0, 5.0);\nconst vec3 EYE = vec3(60.0, 80.0, 60.0);\n\n//SHAPE VALUES\n#define GROUNDPLANE 0\n#define BUILDING1 1\n#define BUILDING2 2\n#define BUILDING3 3\n#define BUILDING11 5\n#define BUILDING21 6\n#define BUILDING31 7\n#define BUILDING12 8\n#define BUILDING22 9\n#define BUILDING32 10\n#define STREET 4\n#define CLOUD 11\n#define TREECAP 12\n#define TREETRUNK 13\n\n//Intersection\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n//TRANSFORMS---------------------------------------------------\n\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n//SDFs from IQ's site------------------------------------------\n\nfloat sdSphere(vec3 p, float r, vec3 c) {\n \treturn distance(p, c) - r;   \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n\n//NOISE FUNCTIONS----------------------------------------------\n\nvec2 random2(vec2 p) {\n    return fract(iTime * 0.000001 * sin(vec2(dot(p, vec2(121.1f, 311.8f)),\n                          dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat worleyNoise(vec2 uv)\n{\n    vec2 mainUv = uv;\n    vec2 uvInt = floor(mainUv);\n    vec2 uvFract = fract(mainUv);\n    float minDist = 1.0;\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = random2(uvInt + neighbor);\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            if (dist <= minDist) {\n                minDist = dist;\n                mainUv = (point + neighbor + uvInt) / (cos(iTime * 0.00001));\n            }\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\nfloat surflet3D(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2.x, 5.0) + 15.f * pow(t2.y, 4.0) - 10.f * pow(t2.z, 3.0);\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlin3D(vec3 p) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tfor(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet3D(p, floor(p) + vec3(dx, dy, dz));\n\t\t\t}\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n//INFINITE REPETITION------------------------------------------\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n//FINITE REPETITION--------------------------------------------\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return  q;\n}\n\n//SET UP SHAPES------------------------------------------------\n\n#define GROUNDPLANESDF sdBox(pos, vec3(35.0, 1.0, 35.0))\n\n#define BUILDING1SDF sdRoundBox(pos + vec3(8.0, -6.0, 6.0), vec3(5, 15, 5), 0.33)\n#define BUILDING2SDF sdRoundBox(pos + vec3(-25.0, -6.0, 6.0), vec3(5, 7, 5), 0.3)\n#define BUILDING3SDF sdRoundBox(pos + vec3(20.0, -6.0, -15.0), vec3(3, 14, 7), 0.13)\n#define BUILDING4SDF sdRoundBox(pos + vec3(10.0, -6.0, -10.0), vec3(3, 14, 3), 0.13)\n#define BUILDING11SDF sdRoundBox(pos + vec3(8.0, -6.0, -20.0), vec3(3, 10, 3), 0.13)\n#define BUILDING21SDF sdRoundBox(pos + vec3(-20.0, -6.0, -6.0), vec3(3, 5, 3), 0.13)\n#define BUILDING31SDF sdRoundBox(pos + vec3(17.0, -9.0, -30.0), vec3(3, 13, 3), 0.13)\n#define BUILDING12SDF sdRoundBox(pos + vec3(20.0, -9.0, 5.0), vec3(3, 16, 3), 0.13)\n#define BUILDING22SDF sdRoundBox(pos + vec3(10.0, -6.0, -30.0), vec3(4, 6, 4), 0.13)\n#define BUILDING32SDF sdRoundBox(pos + vec3(10.0, -6.0, 22.0), vec3(5, 10, 7), 0.13)\n\n#define TREE1CAPSDF treeCap(pos - vec3(25.0, 20.0, -25.0))\n#define TREE1TRUNKSDF treeTrunk(pos - vec3(25.0, 1.0, -25.0))\n#define TREE2CAPSDF treeCap(pos - vec3(-25.0, 20.0, -25.0))\n#define TREE3CAPSDF treeCap(pos - vec3(15.0, 20.0, 20.0))\n#define TREE2TRUNKSDF treeTrunk(pos - vec3(15.0, 1.0, 20.0))\n\n#define STREETSDF sdBox(pos + vec3(-5.0, -0.25, 0.0), vec3(6.0, 1.0, 35.0))\n\n//stolen from IQ's site \n//https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat clouds(vec3 pos) {\n    vec3 q = opRep(pos - vec3(20.0, 8.0, iTime), vec3(30.0, 20.0, 30.0));\n    \n\tfloat sph1 = sdSphere(q, max(worleyNoise(random2(vec2(5.0, 6.7))), 0.3) * 1.8, 0.1 * vec3(1.0, 3.0, 1.0));\n    \n    float sph2 = sdSphere(q - vec3(-0.7, 1.0, 1.7), worleyNoise(random2(vec2(5.0, 6.7))) * 2.0, 0.3 * vec3(1.0, 2.5, 1.0));\n    float fin = opSmoothUnion(sph1, sph2, 0.5);\n    \n    float sph3 = sdSphere(q - vec3( -0.2,0.0, 3.2), worleyNoise(random2(vec2(5.0, 6.7))) * 1.5, 0.2 *  vec3(0.7, 3.2, 0.8));\n    fin = opSmoothUnion(fin, sph3, 0.6);\n        \n    float sph4 = sdSphere(q - vec3(-1.7,0.0, 2.8), worleyNoise(random2(vec2(5.0, 6.7))) * 1.8, 0.2 *  vec3(-0.1, 2.4, 0.8));\n    fin = opSmoothUnion(fin, sph4, 0.6);\n    \n    float sph5 = sdSphere(q - vec3(1.6,0.3, 1.8), worleyNoise(random2(vec2(5.0, 6.7))) * 1.2, 0.2 *  vec3(-0.8, 2.7, 0.8));\n    fin = opSmoothUnion(fin, sph5, 0.6);\n    \n    return fin;\n}\n\nfloat treeCap(vec3 pos) {\n    float cone1 = sdCone(pos, vec2(1.0, 2.0), 15.0);   \n    \n    return cone1;\n}\n\nfloat treeTrunk(vec3 pos) { \n    float cap1 = sdVerticalCapsule(pos, 5.0, 1.0);\n    return cap1;\n}\n\nfloat sceneMap3D(vec3 pos, vec3 light)\n{\n    vec3 cv = vec3(5.0);\n    float t = GROUNDPLANESDF;\n    t = min(t, BUILDING1SDF);\n    t = min(t, BUILDING2SDF);\n    t = min(t, BUILDING3SDF);\n    t = min(t, BUILDING11SDF);\n    t = min(t, BUILDING21SDF);\n    t = min(t, BUILDING31SDF);\n    t = min(t, BUILDING12SDF);\n    t = min(t, BUILDING22SDF);\n    t = min(t, BUILDING32SDF);\n    t = min(t, STREETSDF);\n    \n    t = min(t, TREE1CAPSDF);\n    t = min(t, TREE1TRUNKSDF); \n    t = min(t, TREE2CAPSDF);\n    t = min(t, TREE3CAPSDF);\n    \n    float radius = 60.0;\n    if (pos.x > -radius && pos.x < radius && pos.y > -radius &&\n       pos.z > -radius * 1.5 && pos.z < radius)\n    {\n        t = min(t, clouds(pos));\n    }\n    \n    \n    return t;\n}\n\nbool inBounds(vec3 pos, vec3 bound1, vec3 bound2) {\n    float minX = min(bound1.x, bound2.x);\n    float minY = min(bound1.y, bound2.y);\n    float minZ = min(bound1.z, bound2.z);\n    \n    float maxX = max(bound1.x, bound2.x);\n    float maxY = max(bound1.y, bound2.y);\n    float maxZ = max(bound1.z, bound2.z);\n    \n    if (pos.x >= minX && pos.x <= maxX && \n        pos.y >= minY && pos.y <= maxY &&\n        pos.z >= minZ && pos.z <= maxZ) {\n        return true;\n    }\n    return false;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 light)\n{\n    t = GROUNDPLANESDF;\n    \n    float t2;\n    obj = GROUNDPLANE;\n    \n    if ((t2 = BUILDING1SDF) < t) {\n        t = t2;\n        obj = BUILDING1;\n    }\n    if ((t2 = BUILDING2SDF) < t) {\n        t = t2;\n        obj = BUILDING2;\n    }\n    if ((t2 = BUILDING3SDF) < t) {\n        t = t2;\n        obj = BUILDING3;\n    }\n    if ((t2 = BUILDING11SDF) < t) {\n        t = t2;\n        obj = BUILDING11;\n    }\n    if ((t2 = BUILDING21SDF) < t) {\n        t = t2;\n        obj = BUILDING21;\n    }\n    if ((t2 = BUILDING31SDF) < t) {\n        t = t2;\n        obj = BUILDING31;\n    }\n    if ((t2 = BUILDING12SDF) < t) {\n        t = t2;\n        obj = BUILDING12;\n    }\n    if ((t2 = BUILDING22SDF) < t) {\n        t = t2;\n        obj = BUILDING22;\n    }\n    if ((t2 = BUILDING32SDF) < t) {\n        t = t2;\n        obj = BUILDING32;\n    }\n    if ((t2 = STREETSDF) < t) {\n        t = t2;\n        obj = STREET;\n    }\n    if ((t2 = TREE1CAPSDF) < t || (t2 = TREE2CAPSDF) < t || (t2 = TREE3CAPSDF) < t) {\n        vec3 disrupt = vec3(pos.x + .05 * sin(iTime), pos.y + .1 * sin(iTime), pos.z);\n        float modify = perlin3D(disrupt);\n        if (modify > .5) {\n            t = t2;\n            obj = TREECAP;\n        }       \n    }\n    if ((t2 = TREE1TRUNKSDF) < t || (t2 = TREE2TRUNKSDF) < t) {\n        t = t2;\n        obj = TREETRUNK;\n    }\n    float radius = 60.0;\n    if (pos.x  < radius && pos.x > -radius && pos.y > -radius &&\n        pos.z > -radius * 1.5 && pos.z < radius)\n    {\n        if ((t2 = clouds(pos)) < t) {\n            t = t2;\n            obj = CLOUD;\n        }\n    }\n   \n    \n      \n}\n\n//Ray Marching -------------------------------------------------\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = EYE;\n    ref = vec3(0.0, 10.0, 0.0);\n    \n    float len = tan(0.3403392 * 0.75) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 light)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        \n        sceneMap3D(pos, m, hitObj, light);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n//Prenumbra Shadows--------------------------------------------\n\n// https://iquilezles.org/articles/rmshadows\n//Penumbra Shadows\nfloat softshadow( in vec3 ro, in vec3 rd, float tmin, float tmax)\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = tmin;\n    for( int i= 0; i<16; i++ )\n    {\n\t\tfloat h = sceneMap3D(ro + rd*t, LIGHTPOS);\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//Rendering----------------------------------------------------\n\nvec3 computeNormal(vec3 pos, vec3 light)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, light) - sceneMap3D(pos - epsilon.yxx, light),\n                            sceneMap3D(pos + epsilon.xyx, light) - sceneMap3D(pos - epsilon.xyx, light),\n                            sceneMap3D(pos + epsilon.xxy, light) - sceneMap3D(pos - epsilon.xxy, light)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightDir, vec3 view) {\n    float t;\n    float lambert = dot(n, lightDir) + 0.35;\n    \n    vec3 H = (view + lightDir) / .2;\n    \n    float blinn = pow(max(dot(normalize(H), n), 0.0), 10.f);\n    //blinn = max(pow(dot(normalize(H), n), 30.0), 0.0);\n    \n    vec3 LIGHTCOL = cos(0.5 * iTime) * LIGHT_DAY + (1.0 - cos(0.5 * iTime)) * LIGHT_NIGHT;\n    vec3 color = vec3(0.0);\n    \n    //penumbra shadows\n    \n    //STOLEN FROM TAUNTYBIRD'S AMAZING AND FAST ANIMAL CROSSING SHADER\n    float amb = sqrt(clamp( 0.5+0.5*n.y, 0.5, 1.0 )); //ambient lighting\n    float dif = clamp( dot( n, lightDir ), 0.0, 1.0 ); //diffuse lighting\n    float shadows = smoothstep( -0.2, 0.2, view.y ); //main shadows\n\n    dif *= softshadow( p, lightDir, 0.6, 4.0 );\n    shadows *= softshadow( p, view, 0.6, 2.5 );\n    \n    vec3 lin = vec3(0.0);\n    lin += 0.80*dif*vec3(1.30,1.00,0.80);\n    lin += 0.55*amb*vec3(0.40,0.60,1.15);\n    lin += 0.44*shadows*vec3(0.30, 0.70, 1.6);\n    \n    switch(hitObj) {\n        case GROUNDPLANE:\n            color = mix(WHITE * lambert, LIGHTCOL, 0.35);\n            break;\n        case BUILDING1:\n            color = 1.3 * mix(BUILDING1_BLUE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING2:\n            color = mix(BUILDING2_ROSE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING3:\n            color = mix(BUILDING3_ICE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING11:\n            color = 1.3 * mix(BUILDING1_BLUE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING21:\n            color = mix(BUILDING2_ROSE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING31:\n            color = mix(BUILDING3_ICE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING12:\n            color = 1.3 * mix(BUILDING1_BLUE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING22:\n            color = mix(BUILDING2_ROSE * lambert, LIGHTCOL, 0.2);\n            break;\n        case BUILDING32:\n            color = mix(BUILDING3_ICE * lambert, LIGHTCOL, 0.2);\n            break;\n        case STREET:\n            color = mix(STREET_GRAY * lambert, LIGHTCOL, 0.0);\n            break;\n        case CLOUD:\n            color = mix(WHITE + blinn, LIGHTCOL, 0.2);\n            break;\n        case TREECAP:\n            color = mix(TREE_GREEN + blinn, LIGHTCOL, 0.1);\n            break;\n        case TREETRUNK:\n            color = mix(WHITE * lambert, LIGHTCOL, 0.5);\n            break;\n        case -1:\n            break;\n    }\n    color *= lin;\n    return color;\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 light, vec2 uv)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, light);\n    \n    if(t == -1.0) {\n        vec3 daytimeSky = SKY_PINK;\n        vec3 nighttimeSky = SKY_MAUVE;\n        vec3 skyColor = cos(0.5 * iTime) * daytimeSky + (1.0 - cos(0.5 * iTime)) * nighttimeSky;\n        return Intersection(t, skyColor, vec3(eye + 1000.0 * dir), -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, light);\n    vec3 lightDir = normalize(light - isect); \n   \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(dir));\n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0, 1.0, 1.0));\n    \n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\n//Main Image-------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, ref;\n    vec3 eye = vec3(0, 5, 0);\n    \n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            Intersection light1 = sdf3D(dir, eye, LIGHTPOS, uv2);\n            aaIsects[idx++] = light1;\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//BUILDING DETAILS\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}