{"ver":"0.1","info":{"id":"7sfcD4","date":"1642086502","viewed":303,"name":"Median filter denoiser","username":"SadTShaders","description":"I am open for sugestions how to make it run faster. It applays median filter for each channel separately.","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["imageprocessing","film","movie","denoiser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//kernel size, for better perormance it should be reduced to 3\n#define DENOISING_MATRIX_SIZE 4\n#define DENOISING_SAMPLE_DISTANCE 0.0012\n\nconst int matrixLength = DENOISING_MATRIX_SIZE * DENOISING_MATRIX_SIZE;\n\n//array is very small, so i think this is fast option\nvoid insertionSort(inout vec3 arr[matrixLength]) \n{ \n    // sorting r g b channels separately\n    for(int index = 0; index < 3; index++)\n    {\n        int i, j; \n        float key;\n        for (i = 1; i < matrixLength; i++)\n        { \n            key = arr[i][index]; \n            j = i - 1; \n    \n            while (j >= 0 && arr[j][index] > key)\n            { \n                arr[j + 1][index] = arr[j][index]; \n                j = j - 1; \n            } \n            arr[j + 1][index] = key; \n        } \n    } \n}\n\n\nvec4 Denoise(vec2 uv){\n    vec3 matrix[matrixLength];\n    \n    vec2 noiseUV;\n    \n    for(int i = 0; i < matrixLength; i++){\n    \n        int x = (i % DENOISING_MATRIX_SIZE) - DENOISING_MATRIX_SIZE / 2;\n        int y = (i / DENOISING_MATRIX_SIZE) - DENOISING_MATRIX_SIZE / 2;\n        \n        noiseUV = uv + vec2(float(x) * DENOISING_SAMPLE_DISTANCE, float(y) * DENOISING_SAMPLE_DISTANCE);\n        \n        vec4 samp = texture(iChannel0, noiseUV);\n        matrix[i] = samp.rgb;\n    }\n    \n    insertionSort(matrix);\n    \n    //median\n    return vec4(matrix[matrixLength / 2], 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color;\n    \n    if(uv.x > .5)\n        color = Denoise(uv);\n    else\n        color = texture(iChannel0, uv);\n        \n    float divideBar = uv.x* (1. - uv.x);\n    divideBar -= .24996f;\n    divideBar *= -100000.;\n    divideBar = clamp(divideBar, 0., 1.);\n        \n    fragColor = color * divideBar;\n}","name":"Image","description":"","type":"image"}]}