{"ver":"0.1","info":{"id":"ltfSRX","date":"1665959853","viewed":65,"name":"raymarching/04","username":"kynd","description":"raymarching/04","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching04"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define t iTime\n#define res iResolution.xy\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nconst float sphereSize = 0.5;\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\n\nfloat distanceFunc(vec3 p){\n    return length(p) - sphereSize;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceFunc(p + vec3(  d, 0.0, 0.0)) - distanceFunc(p + vec3( -d, 0.0, 0.0)),\n        distanceFunc(p + vec3(0.0,   d, 0.0)) - distanceFunc(p + vec3(0.0,  -d, 0.0)),\n        distanceFunc(p + vec3(0.0, 0.0,   d)) - distanceFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - res) / min(res.x, res.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0,  0.0,  2.0);\n    vec3 cDir = vec3(0.0,  0.0, -1.0);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // ray\n    vec3 ray = normalize(vec3(sin(fov) * p.x, sin(fov) * p.y, -cos(fov)));\n    \n    // marching loop\n    float distance = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < 16; i++){\n        distance = distanceFunc(rPos);\n        rLen += distance;\n        rPos = cPos + ray * rLen;\n    }\n    \n    // hit check\n    if(abs(distance) < 0.001){\n        vec3 normal = getNormal(rPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        fragColor = vec4(vec3(diff), 1.0);\n    }else{\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}