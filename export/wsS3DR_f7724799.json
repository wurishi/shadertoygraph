{"ver":"0.1","info":{"id":"wsS3DR","date":"1562915437","viewed":182,"name":"rockwall","username":"valerysntx","description":"forked for `climbing rock-wall effect`","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["normal","supersampler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float zNear = 1.0;\nconst float zFar  = 10.0;\nconst int ITERATIONS = 20;\n\n#define SUPERSAMPLING \nfloat map(in vec3 m) {\n    \n\tvec3 sphereCenter = vec3(0.0, 0.0, 3.85);\n    float radius =3.6;\n    \n    float displacementSize = 0.118 + cos(iTime*0.125)* 0.4;\n    float displacement \t\t= sin(displacementSize*m.x)*sin(displacementSize*m.y)*sin(displacementSize*m.z) * 0.05;\n    \n    return length(m - sphereCenter) - radius + displacement; \n}\n\n\n\nvec3 computeNormalMap(in vec2 UV)\n{\n    float scale = 0.1;\n    vec2 eps = vec2(0.21, 0.0);\n    \n    float hx1 = texture(iChannel0, UV + eps.xy).x;\n    float hx2 = texture(iChannel0, UV - eps.xy).x;    \n    float hz1 = texture(iChannel0, UV + eps.yx).x;\n    float hz2 = texture(iChannel0, UV - eps.yx).x;    \n    \n    vec3 i = vec3(eps.x, 0.0, (hx2-hx1)*scale);\n    vec3 j = vec3(0.0, eps.x, (hz2-hz1)*scale);    \n    \n    return normalize(cross(i, j));\n}\n\n\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i< ITERATIONS; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.0001) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n\n    vec2 UV = ((normal.xy + 1.0) * 0.5) * (20.0 + cos(iTime*0.01)*5.0);\n    \n    vec3 pixel = texture(iChannel0, UV).xyz;\n    \n    vec3 normalMap = computeNormalMap(UV);\n    \n    vec3 k = normal;\n    vec3 i = normalize(vec3(-k.z, 0.0, k.x));\n    vec3 j = cross(k, i);\n    \n    mat3 local = mat3(i, j, k);\n    \n\tnormal = normalMap * local;    \n    \n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = max(.0, dot(normal, -lightRay));\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.20), 10.0);\n    \n    float ambiant = 1.;       \n    \n    vec3 render = pixel * (diffuse + ambiant) + hilight;\n    return vec4(render, 1.0);\n}\n\n\n// IQ's func <3\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.5, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\n\nvec4 run(in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= vec3(5.0*cos(iTime*0.5), 3.0, -10.0);\n    \n    vec3\tm;\n    \n    if(rayMarching(eye, ray, m)) {\n        vec3 normal = computeNormal(m);\n        return computeColor(ray, m, normal, light, eye);\n    }\n    else {\n        return vec4(0.0, 0, 0, 1.0);        \n    }\n    \n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    #ifdef SUPERSAMPLING\n    // 5x5 supersampling\n    for(float dx=-0.5; dx<=0.5; dx+=0.25) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.25) {\n            fragColor += run(fragCoord + vec2(-dx, -dy));\n        }\n    }\n    \n    fragColor = fragColor / pow(max(dot(vec2(0.0,0.0), fragColor.xy),40.0), 1.0);\n    \n    #else\n    fragColor = run(fragCoord);\n    #endif\n} \n\n    \n","name":"Image","description":"","type":"image"}]}