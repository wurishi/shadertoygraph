{"ver":"0.1","info":{"id":"ddGcRR","date":"1696384573","viewed":33,"name":"2D Noise with Cell Visualization","username":"AochiToxx","description":"Trying to make perlin noise in 2D.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Quintic function for smooth interpolation.\nfloat quintic(float t) {\n    // This function will take 't' from 0 to 1 and return a smoothed value, \n    // also between 0 to 1, that accelerates and decelerates smoothly. \n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\n// Extend the quintic smoothing to a 2D vector.\nvec2 quintic(vec2 t) {\n    // Smooth each component (x and y) of the vector separately.\n    return vec2(quintic(t.x), quintic(t.y));\n}\n\n// Function for a circle's signed distance field.\nfloat sdfCircle(vec2 p, float radius) {\n    // Calculate the distance from the point 'p' to the origin (center of the circle) \n    // and subtract the radius. This will give a value of 0 on the circle's boundary, \n    // negative inside the circle, and positive outside.\n    return length(p) - radius;\n}\n\n// Function to compute the distance from a point to a line segment.\nfloat sdfLineSegment(vec2 p, vec2 a, vec2 b, float thickness) {\n    // 'pa' is the vector from point 'a' to 'p'.\n    vec2 pa = p - a, \n    // 'ba' is the vector representing the line segment from 'a' to 'b'.\n         ba = b - a;\n    // 'h' is the projection of point 'p' onto the line segment normalized \n    // by the length of the segment.\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    // The main return value is the distance of 'p' from the segment minus \n    // the thickness of the segment.\n    return length(pa - ba*h) - thickness;\n}\n\n// Generate a pseudo-random gradient vector based on the input position.\nvec2 randomGradient(vec2 p){\n    // Shift the position a bit. This avoids getting a zero gradient at integral coordinates.\n    p = p + 0.01;\n    // Create a random number based on the dot product of 'p' and a constant vector.\n    float x = dot(p, vec2(123.4, 234.5));\n    float y = dot(p, vec2(234.5, 345.6));\n    vec2 gradient = vec2(x, y);\n    // Apply some trig functions to make the randomness more uniform.\n    gradient = sin(gradient);\n    gradient = gradient * 43758.5453;\n    // Animate the gradient by adding time.\n    gradient = sin(gradient + ( iTime / 4. ));\n    gradient = sin(gradient);\n    return gradient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to normalized coordinates on a [-1, 1] scale.\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = vec3(0.);\n    \n    // Multiply the UV by a factor (e.g., 10) to increase the number of \"cells\" or grid spaces.\n    uv = uv * 10.;\n    // 'gridId' represents the integer part, giving the top-left corner of each grid cell.\n    vec2 gridId = floor(uv);\n    // 'gridUv' represents the fractional part, giving the position within the grid cell.\n    vec2 gridUv = fract(uv);\n\n    // Calculate the positions of the corners of the current cell.\n    vec2 bl = gridId;\n    vec2 br = gridId + vec2(1., 0.);\n    vec2 tl = gridId + vec2(0., 1.);\n    vec2 tr = gridId + vec2(1., 1.);\n    \n    // For each corner of the cell, compute a random gradient vector.\n    vec2 gradBl = randomGradient(bl);\n    vec2 gradBr = randomGradient(br);\n    vec2 gradTl = randomGradient(tl);\n    vec2 gradTr = randomGradient(tr);\n\n    // Calculate vectors from the current UV point to each corner of the cell.\n    vec2 distFromPixelToBl = gridUv;\n    vec2 distFromPixelToBr = gridUv - vec2(1., 0.);\n    vec2 distFromPixelToTl = gridUv - vec2(0., 1.);\n    vec2 distFromPixelToTr = gridUv - vec2(1., 1.);\n    \n    // Compute the dot product of each gradient vector and the vector to the UV point. \n    // This gives us a value at each corner of the grid cell.\n    float dotBl = dot(gradBl, distFromPixelToBl);\n    float dotBr = dot(gradBr, distFromPixelToBr);\n    float dotTl = dot(gradTl, distFromPixelToTl);\n    float dotTr = dot(gradTr, distFromPixelToTr);\n    \n    // Smooth the 'gridUv' values using the quintic function. \n    // This ensures smooth transitions between the cells.\n    gridUv = quintic(gridUv);\n    \n    // Use the smoothed 'gridUv' values to interpolate between the dot products. \n    // This gives the final Perlin noise value for the current UV.\n    float b = mix(dotBl, dotBr, gridUv.x);\n    float t = mix(dotTl, dotTr, gridUv.x);\n    float perlin = mix(b, t, gridUv.y);\n    \n    // Display the ridged noise (a variation of Perlin noise).\n    float ridigNoise = 1. - abs(perlin);\n    ridigNoise = ridigNoise * ridigNoise;\n    color = vec3(ridigNoise);\n\n    // Render the final color.\n    fragColor = vec4(color,1.);\n}\n","name":"Image","description":"","type":"image"}]}