{"ver":"0.1","info":{"id":"ws23Wz","date":"1548656646","viewed":213,"name":"FlyingLines","username":"Sevapp","description":"FlyingLines","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float minDrawDist = 0.0;\nconst int   maxRayMarcs = 500;\nconst float cellSize    = 900.0;\nconst float ballRadius  = 120.0;\nvec4 color;\nvec3 camPos;\n\n// Thank, Íñigo Quílez...)\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat getDist(vec3 rayPos)\n{\n    rayPos.x -= sin(iTime) * 800.0;\n    rayPos.y -= cos(iTime) * 800.0;\n    rayPos.z += float(iFrame) * 20.0;\n    \n    vec3 vc = camPos + floor(-((camPos - rayPos) - ballRadius) / cellSize) * cellSize;\n    vec3 vl = vc; vl.x -= cellSize;\n    vec3 vr = vc; vr.x += cellSize;\n    vec3 vu = vc; vu.y -= cellSize;\n    vec3 vd = vc; vd.y += cellSize;\n    vec3 vb = vc; vb.z -= cellSize;\n    vec3 vf = vc; vf.z += cellSize;\n    \n    float r    = 50.0;\n    float dist = min(\n        min(\n            sdCapsule(rayPos, vl, vr, r),\n            sdCapsule(rayPos, vu, vd, r)\n        ),  sdCapsule(rayPos, vb, vf, r)\n    );\n    \n    float distToBall = distance(vc, rayPos) - ballRadius;\n    \n    if (distToBall <= 0.1) {\n        dist = distToBall;\n        color = vec4(abs(atan(iTime)), 0, abs(tan(iTime)), 1.0);\n    }\n    \n\treturn dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    const vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n\t    getDist(p - e.xyy),\n\t    getDist(p - e.yxy),\n\t    getDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 outputPixel = vec4(0.0);\n\t\n\tvec2 position = gl_FragCoord.xy;\n\t\n\tcamPos = vec3(\n\t\tiResolution.x / 2.0, \n\t\tiResolution.y / 2.0, \n\t\t-600.0\n\t);\n\t    \n\tvec3 rayPos = vec3(position, 0.0);\n\tvec3 rayVec = normalize(rayPos - camPos);\n\t\n\tcolor = vec4(abs(cos(iTime)), .2, abs(sin(iTime)), 1.0);\n\t\n\tvec3 curRayPos = rayPos * minDrawDist;\n\tfor (int i = 0; i < maxRayMarcs; i ++)\n\t{ \n\t\tfloat distToBall = getDist(curRayPos);\n\t\tif (distToBall < .1)\n\t\t{\n\t\t\tvec3  normal = getNormal(curRayPos);\n            float light  = dot(normalize(camPos - curRayPos), normal);\n           \t\n            light = clamp(light, 0.0, 1.0) + 0.02;\n\t\t\tlight *= 1000000.0 / pow(abs(curRayPos.z - camPos.z), 2.0);\n\t\t\toutputPixel = pow(light, 1.0 / 1.8) * color;\n\t\t\tbreak;\n\t\n\t\t} else\n\t\t{\n\t\t\tcurRayPos += rayVec * 30.0;\n\t\t}\n\t}\n\t\n\tfragColor = outputPixel;\n}","name":"Image","description":"","type":"image"}]}