{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n// simple scene with moving objects\n// this function gets duplicated between the image & sound parts of the code\nvec3 ObjectPos( float time )\n{\n    return vec3(10,.0,20.0)*sin( vec3(.5,2.0,.4)*time + vec3(0,0,1.7) );\n}\n\nvoid GetCamPosRot( out vec3 pos, out vec4 cs, float time )\n{\n    pos = vec3(8,.2,0);\n    vec3 target = ObjectPos(time-.5) + vec3(0,0,0);\n    \n    // reorient ray\n    vec3 dir = target-pos;\n    float l = length(dir);\n    float l2 = length(dir.xz);\n\t\n    //vec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n    cs = vec4( l2/l, -dir.y/l, dir.zx/l2 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // minimal ray tracer\n    float zoom = 1.0;\n    vec3 ray = vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n    \n    // get camera position & rotation\n    vec3 pos;\n    vec4 cs;\n    GetCamPosRot( pos, cs, iTime );\n    \n\tray.yz = ray.yz*cs.x+ray.zy*cs.y*vec2(-1,1);\n\tray.xz = ray.xz*cs.z+ray.zx*cs.w*vec2(1,-1);\n    ray = normalize(ray);\n    \n    vec3 col = vec3(.5);\n    \n    if ( ray.y < 0.0 )\n    {\n        // checkered floor, to give a better sense of position\n        vec2 p = pos.xz + ray.xz/(ray.y/-4.0);\n        col = mix( vec3(.4),vec3(.6),.5+.25*(sin(p.x)+sin(p.y)) );\n    }\n    \n    vec3 oPos = ObjectPos(iTime);\n    vec3 oDir = oPos-pos;\n    const float radius = .3;\n\tif ( dot(ray,oDir) > sqrt(dot(oDir,oDir)-radius*radius) )\n        col = vec3(.5,0,0);\n    \n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Ben Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n// simple scene with moving objects\n// this function gets duplicated between the image & sound parts of the code\nvec3 ObjectPos( float time )\n{\n    return vec3(10,.0,20.0)*sin( vec3(.5,2.0,.4)*time + vec3(0,0,1.7) );\n}\n\nvoid GetCamPosRot( out vec3 pos, out vec4 cs, float time )\n{\n    pos = vec3(8,.2,0);\n    vec3 target = ObjectPos(time-.5) + vec3(0,0,0);\n    \n    // reorient ray\n    vec3 dir = target-pos;\n    float l = length(dir);\n    float l2 = length(dir.xz);\n\t\n    //vec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n    cs = vec4( l2/l, -dir.y/l, dir.zx/l2 );\n}\n\n\nfloat EngineSound( float time, float dist )\n{\n    float sound = sin( tau*time*160.0 );\n    float t = time*4000.0;\n    sound += texture( iChannel0, ( vec2(t,t/64.0) + vec2(.5) )/64.0, -100.0 ).r*2.0-1.0;\n    float volume = 7.0 / max(10.0,dist*dist);\n    return sound*volume;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    // doppler\n    // animate source position of sound & camera\n    // then offset waveform by distance\n    // it should be as simple as that!\n\n    const float speedOfSound = 100.0; // this works as a scene scale, really\n\n    // get camera position & rotation\n    vec3 pos;\n    vec4 cs;\n    GetCamPosRot( pos, cs, time );\n    vec3 right;\n    right.y = 0.0;\n    right.xz = vec2(cs.z,-cs.w);\n    \n    // do each ear separately, the timing difference should read well...\n    float headRadius = .2;\n    vec3 leftEarPos = pos - headRadius*right;\n    vec3 rightEarPos = pos + headRadius*right;\n        \n    vec2 sound;\n    float dist = length( ObjectPos(time) - leftEarPos );\n    sound.x = EngineSound( time-dist/speedOfSound, dist );\n    dist = length( ObjectPos(time) - rightEarPos );\n    sound.y = EngineSound( time-dist/speedOfSound, dist );\n    \n    return sound;\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfSDX","date":"1407183906","viewed":632,"name":"Doppler","username":"TekF","description":"Simple trick to do the doppler effect: just offset time by the distance to the sound source. ","likes":19,"published":1,"flags":8,"usePreview":0,"tags":["sound","dopplereffect"],"hasliked":0,"parentid":"","parentname":""}}