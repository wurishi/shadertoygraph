{"ver":"0.1","info":{"id":"Mt2cRt","date":"1509858573","viewed":257,"name":"Simple 2D ray marching","username":"syaoming","description":"Spherical tracing with jittered sampling.\nLooks like a disk-shaped volumetric light.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////\n// Global variables\n\nconst float PI = 3.1417;\nconst float PI2 = PI * 2.0;\n\n// sampling constants\nconst int SAMPLE = 64;\nconst float SAMPLE_F = float(SAMPLE);\n\n// ray-marching constants\nconst int MAX_STEP = 20;\nconst float EPSILON = 1e-3; // small enough, because distance is in pixels\n\n// the disk light\nfloat radius = 50.0; // radius in pixel\nconst float intensity = 3.0;\n\n\n////\n// Functions\n\n// signed distance function, of the disk\nfloat sdf(float px, float py)\n{\n    // SDF of a 2D disk, at the center of screen\n    float x = px - iResolution.x / 2.0;\n    float y = py - iResolution.y / 2.0;\n    return sqrt(x * x + y * y) - radius;\n}\n\n// ray-marching for a ray; return light intensity if hitted.\nfloat ray_marching(float ox, float oy, float dx, float dy)\n{\n    // ray: origin (ox, oy), direction (dx, dy)    \n    for (int i = 0; i < MAX_STEP; i++)\n    {\n        float sd = sdf(ox, oy);\n        if (sd < EPSILON)\n        {\n            return intensity;\n        }\n        ox += dx * sd;\n        oy += dy * sd;\n    }\n    return 0.0;\n}\n\n// a fake-randon function; copied from some webpage\nfloat rand(vec2 seed)\n{\n    return fract(sin(dot(seed ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// jittered sampling for fragment (ox, oy)\nfloat sampling(float ox, float oy)\n{    \n    float ret = 0.0;\n\n    float dx = 0.0;\n    float dy = 0.0;\n    vec2 seed = texture(iChannel0, vec2(ox / iResolution.x, oy / iResolution.y)).xy;\n    for (int i = 0; i < SAMPLE; i++)\n    {\n        // modify the seed each iteration\n\t\tseed.x += 0.368;\n        seed.y += 0.082;\n        \n        // jitterred degree-sampling\n        float deg = (float(i) + rand(seed)) / SAMPLE_F * PI2;\n        dx = cos(deg);\n        dy = sin(deg);\n        \n        ret += ray_marching(ox, oy, dx, dy);\n    }\n    \n    return ret / SAMPLE_F;\n}\n\n// main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    // compute volumetic lighting\n    const vec3 light_color = vec3(1.0, .95, .9);\n    float intensity = sampling(fragCoord.x, fragCoord.y);\n    float alpha = clamp(intensity, 0.0, 1.0); // saturate\n    \n    // blend the volumic lighting with background\n    fragColor.xyz = light_color * alpha + fragColor.xyz * (1.0 - alpha);\n}","name":"Image","description":"","type":"image"}]}