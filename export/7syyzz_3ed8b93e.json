{"ver":"0.1","info":{"id":"7syyzz","date":"1654308753","viewed":46,"name":"final project cs77","username":"emilyzhou","description":"final project cs77","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["solarsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float map(vec3 p, settings setts)\n{\n    vec3 c = vec3(0.5,0.6,0.1);\n    return world_sdf(p, iTime, setts, c);\n}\n\n\n// TASK 4.1\nvec3 computeNormal(vec3 p, settings setts)\n{\n    vec3 one1 = vec3(p.x+EPSILON, p.y, p.z);\n    vec3 one2 = vec3(p.x-EPSILON, p.y, p.z);\n    vec3 two1 = vec3(p.x, p.y+EPSILON, p.z);\n    vec3 two2 = vec3(p.x, p.y-EPSILON, p.z);\n    vec3 three1 = vec3(p.x, p.y, p.z+EPSILON);\n    vec3 three2 = vec3(p.x, p.y, p.z-EPSILON);\n    vec3 norm = vec3(\n        map(one1, setts) - map(one2, setts),\n        map(two1, setts) - map(two2, setts),\n        map(three1, setts) - map(three2, setts)\n    );\n    return normalize(norm);\n}\n\n\n///////////////////////////////////////////\n/////// SPHERE TRACING CODE HERE:\n///////////////////////////////////////////\n\nbool sphere_tracing(ray r,\n                int max_iter,\n                settings setts,\n                out hit_record hit_loc,\n                out int iters)\n{\n    int itr = 0;\n    float t = 1.0;\n    float sdf = 0.0;\n    while (itr < max_iter) {\n        vec3 p = r.origin + r.direction * t;\n        vec3 mcolor = vec3(0.5,0.6,0.1);\n        sdf = world_sdf(p, iTime, setts, mcolor);\n        float step_size = sdf;\n        t = t + step_size;\n        if (sdf < EPSILON) {\n            hit_loc = hit_record(p, mcolor);\n            iters = itr;\n            return true;\n        }\n        itr = itr + 1;\n        \n    }\n    iters = itr;\n    return false;\n    \n    // TODO: implement sphere tracing\n    \n    // it should work as follows:\n    //\n    // while (hit has not occured && iteration < max_iters)\n    //     set the step size to be the SDF\n    //     march step size forwards\n    //     if a collision occurs (SDF < EPSILON)\n    //         return hit location and iteration count\n    // return false\n}\n\n///////////////////////////////////////////\n\nvec3 shade(ray r, int iters, settings setts, vec3 pcolor)\n{\n    vec3 p = r.origin;\n    vec3 d = r.direction;\n    \n   \n    if (setts.shade_mode == DIFFUSE_POINT)\n    {\n        vec3 light_pos = vec3(5.0, 5.0, 0.0);\n        vec3 light_intensity = vec3(12.0);\n        vec3 surface_color = vec3(0.5,0.6,0.1);\n        \n        //// TASK 4.2\n        vec3 n = computeNormal(p, setts);\n        vec3 l = computeNormal(light_pos-p, setts);\n        \n        float distancetoLight = distance(light_pos, p);\n        float distancePower = distancetoLight*distancetoLight;\n        float brightness = dot(l,n) * (1.0/distancePower);\n        return brightness* (surface_color + pcolor) *light_intensity;\n    }\n    else\n    {\n        return vec3(0.0);\n    }\n    \n    return vec3(0.0);\n}\n\n\nvec3 render(settings setts, vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (p.y < -0.95)\n    {\n        float val = cos(iTime * anim_speed);\n        return shade_progress_bar(p, iResolution.xy, val);\n    }\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= aspect;\n   \n    \n    // Rotate the camera\n    vec3 eye = vec3(0.0,5.0,0.5);\n    //vec3 eye = vec3(-3.0*cos(iTime*0.2), 2.0 + 0.5*sin(iTime*0.1), -3.0*sin(iTime*0.2));\n    vec3 dir = vec3(0.0, 0.0, 0.0) - eye;\n    vec3 up = vec3(0, 1, 0);\n    \n    \n    float focal_length = 2.;\n    \n    vec3 u,v,w;\n    compute_camera_frame(dir, up, u, v, w);\n    \n    ray r;\n    switch(projection_func) {\n        case PROJECTION_ORTHOGRAPHIC:\n            r = generate_ray_orthographic(uv, eye, u, v, w);\n            break;\n     \n        case PROJECTION_PERSPECTIVE:\n            r = generate_ray_perspective(uv, eye, u, v, w, focal_length);\n            break;\n    }\n    \n    \n    int max_iter = 1000;\n    \n    vec3 col = vec3(0.0);\n    \n    hit_record hit_loc;\n    int iters;\n    bool hit;\n    \n    if (sphere_tracing(r, max_iter, setts, hit_loc, iters))\n    {\n        r.origin = hit_loc.point;\n        col = shade(r, iters, setts, hit_loc.color);\n    }\n    \n\n    \n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(render(render_settings, fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// pre-defined constants\n#define EPSILON 1e-4\n#define PI 3.1415926535897932384626433832795\n\n\n// shade mode\n#define GRID 0\n#define COST 1\n#define NORMAL 2\n#define AMBIENT 3\n#define DIFFUSE_POINT 4\n#define ENVIRONMENT_MAP 5\n\nconst float sunRadius = 0.2f;\n\n\n//\n// Render Settings\n//\nstruct settings\n{\n    int shade_mode;\n};\n\nsettings render_settings = settings(DIFFUSE_POINT);\n\n\n\n//float anim_speed = 0.35;\nfloat anim_speed = 0.35;\nint cost_norm = 200;\n\nvec3 two_tone_color_a = vec3(0.6 * 1.0, 0.6 * 1.0, 0.0 * 1.0);\nvec3 two_tone_color_b = vec3(0.2 * 1.0, 0.1 * 1.0, 0.9 * 1.0);\n//vec3 two_tone_color_a = vec3(0.9,0.7,0.6);\n//vec3 two_tone_color_b = vec3(0.0);\nvec3 two_tone_dir = vec3(1.0, 1.0, 0.0);\n\n////////////////////////////////////////////////////\n// SDF evaluation code here:\n////////////////////////////////////////////////////\n\n// returns the signed distance to a sphere from position p\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\n\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    // TODO\n    float h = max(k - abs(d2-d1),0.0);\n    return min(d1, d2) - (h*h)/4.0*k;\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    // TODO\n    float h = max(k - abs(d2+d1),0.0);\n    return max(-d1,d2) + (h*h)/(4.0*k);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    // TODO\n    float h = max(k - abs(d2-d1),0.0);\n    return max(d1,d2) + (h*h)/(4.0*k); \n}\n\nfloat opRound(float d, float iso)\n{\n    // TODO\n    return d - iso;\n    \n   \n}\n\nstruct hit_record {\n    vec3 point; \n    vec3 color; \n};\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\n#define PROJECTION_ORTHOGRAPHIC 0\n#define PROJECTION_PERSPECTIVE  1\n\nint projection_func = PROJECTION_PERSPECTIVE;\n\n////////////////////////////////////////////////////\n// Write up your ray generation code here:\n////////////////////////////////////////////////////\nstruct ray { \n    vec3 origin;\n    vec3 direction;\n};\n\n// TASK 2.1\nvoid compute_camera_frame(\n    vec3 dir, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w ) {\n    w = -dir/length(dir);\n    u = cross(up,w) / length(cross(up,w));\n    v = cross(w,u);\n\n}\n\n\n// TASK 2.2\nray generate_ray_orthographic(vec2 uv, vec3 e, vec3 u, vec3 v, vec3 w) {\n    vec3 origin = e + uv.x*u + uv.y*v;\n    return ray(origin, -w);\n\n}\n\n// TASK 2.3\nray generate_ray_perspective(vec2 uv, vec3 eye, vec3 u, vec3 v, vec3 w, float focal_length) {\n    vec3 direct = (uv.x*u) + (uv.y*v) - focal_length*w + 0.9*w;\n \n    return ray(eye, direct/length(direct));\n}\n\n\n////////////////////////////////////////////////////\n\n// returns the signed distance to an infinate plane with a specific y value\nfloat sdPlane(vec3 p, float z)\n{\n    return p.z - z;\n}\n\nfloat world_sdf(vec3 p, float time, settings setts, inout vec3 pcolor)\n{\n    float mercOrbit = 0.7*0.7;\n    float sizeDown = 0.7;\n    float venOrbit = mercOrbit *1.1*sizeDown;\n    float earthOrbit = mercOrbit * 1.06*sizeDown;\n    float marsOrbit = mercOrbit * 1.5*sizeDown;\n    float jupOrbit = mercOrbit * 4.75*sizeDown;\n    float satOrbit = mercOrbit * 6.5*sizeDown;\n    float uranOrbit = mercOrbit * 10.6*sizeDown;\n    float neptOrbit = mercOrbit * 17.0*sizeDown;\n    \n    float mercRev = 4.0;\n    float venRev = mercRev/2.55;\n    float earthRev = mercRev/ 5.15;\n    float marsRev = mercRev/7.8;\n    float jupRev = mercRev/45.6;\n    float satRev = mercRev/122.36;\n    float uranRev = mercRev/369.6;\n    float neptRev = mercRev/732.2;\n\n    float dist = 100000.0;\n    float dist1 = 100000.0;\n    \n    pcolor = vec3(0.0, 0.0, 0.0); \n    \n    dist = sdPlane(p.xzy,  -0.3);\n    \n    float smallestDist = dist; \n    \n    dist1 = sdSphere(p - vec3(0.f, -0.2, 0.f), sunRadius); //SUN\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(1.0, 1.0, 1.0); //SUN's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //SUN\n    \n    dist1 = sdSphere(p - vec3(sin(time*mercRev)*mercOrbit, -0.2, cos(time*mercRev)*mercOrbit), sunRadius*0.3); //MERCURY\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.2, 0.5, 0.8); //MERCURY's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //MERCURY\n    \n    dist1 = sdSphere(p - vec3(sin(time*venRev)*venOrbit, -0.2, cos(time*venRev)*venOrbit), sunRadius*0.3); //VENUS\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.3, 0.3, 0.6); //VENUS's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //VENUS\n    \n    dist1 = sdSphere(p - vec3(sin(time*earthRev)*earthOrbit, -0.2, cos(time*earthRev)*earthOrbit), sunRadius*0.3); //EARTH\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.2, 0.4, 0.4); //EARTH's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //EARTH\n    \n    dist1 = sdSphere(p - vec3(sin(time*marsRev)*marsOrbit, -0.2, cos(time*marsRev)*marsOrbit), sunRadius*0.3); //MARS\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.7, 0.2, 0.1); //MARS's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //MARS\n    \n    dist1 = sdSphere(p - vec3(sin(time*jupRev)*jupOrbit, -0.2, cos(time*jupRev)*jupOrbit), sunRadius*0.3); //JUPITOR\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.0, 0.0, 0.1); //JUPITOR's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //JUPITOR\n    \n    dist1 = sdSphere(p - vec3(sin(time*satRev)*satOrbit, -0.2, cos(time*satRev)*satOrbit), sunRadius*0.3); //SATURN\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.0, 1.0, 0.1); //SATURN's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //SATURN\n    \n    dist1 = sdSphere(p - vec3(sin(time*uranRev)*uranOrbit, -0.2, cos(time*uranRev)*uranOrbit), sunRadius*0.3); //URANUS\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.2, 0.5, 0.8); //URANUS's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //URANUS\n\n\n    dist1 = sdSphere(p - vec3(sin(time*neptRev)*neptOrbit, -0.2, cos(time*neptRev)*neptOrbit), sunRadius*0.3); //NEPTUNE\n    if (dist1 < smallestDist) {\n        smallestDist = dist1; \n        pcolor = vec3(0.5, 0.5, 0.5); //NEPTUNE's color\n    }\n    dist = opSmoothUnion(dist, dist1, 0.1); //NEPTUNE    \n    \n    \n    return dist;\n}\n\n\n// The animation which you see is of a 2D slice of a 3D object. The objects exist in [-1, 1] space\n// and the slice is continuously moved along z=[-1,1] using a cosine. This method renders what the\n// current z value is as a progress bar at the bottom of the animation for reference.\nvec3 shade_progress_bar(vec2 p, vec2 res, float z)\n{\n    // have to take account of the aspect ratio\n    float xpos = p.x * res.y / res.x;\n    \n    if (xpos > z - 0.01 && xpos < z + 0.01) return vec3(1.0);\n    else return vec3(0.0);\n}","name":"Common","description":"","type":"common"}]}