{"ver":"0.1","info":{"id":"7lScWV","date":"1650235525","viewed":411,"name":"Neon Triangle Tunnel","username":"xaviershay","description":"A tunnel of glowing triangles.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","triangle","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A tunnel of glowing triangles.\n//\n// References:\n//\n//   Base raymarching setup and SDFs from IQ's live coding sessions/site\n//   https://www.youtube.com/watch?v=bdICU2uvOdU&ab_channel=InigoQuilez\n//\n//   Glow from\n//   https://www.shadertoy.com/view/7stGWj\n\n#define CAM_SPEED 0.5\n#define GATE_SPACING 3.0\n// #define SCENE_LENGTH 50.0\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.14159\n\nfloat sceneTime() {\n#ifdef SCENE_LENGTH\n  return mod(iTime, SCENE_LENGTH);\n#else\n  return iTime;\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdTriangle(in vec3 p, in float t)\n{\n  float d = MAX_DIST;\n\n  vec2 a = vec2(cos(PI / 2.0 + t), sin(PI / 2.0 + t));\n  vec2 b = vec2(cos(PI / 2.0 + t + 2.0 * PI / 3.0), sin(PI / 2.0 + t + 2.0 * PI / 3.0));\n  vec2 c = vec2(cos(PI / 2.0 + t + 4.0 * PI / 3.0), sin(PI / 2.0 + t + 4.0 * PI / 3.0));\n\n  d = min(d, sdCapsule(p, vec3(a, 0), vec3(b, 0), 0.03));\n  d = min(d, sdCapsule(p, vec3(b, 0), vec3(c, 0), 0.03));\n  d = min(d, sdCapsule(p, vec3(c, 0), vec3(a, 0), 0.03));\n\n  return d;\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r) {\n  return length(p - o) - r;\n}\n\n// https://github.com/Michaelangel007/easing\nfloat inOutBack( float edge0, float edge1, float p) {\n  p = clamp((p - edge0) / (edge1 - edge0), 0.0, 1.0);\n\n  float m=p-1.0;\n  float t=p*2.0;\n  float k = 1.70158 * 1.525;\n\n  if (p < 0.5) return p*t*(t*(k+1.0) - k);\n  else return 1.0 + 2.0*m*m*(2.0*m*(k+1.0) + k);\n}\n\nvec4 map(in vec3 p) {\n  float d = MAX_DIST;\n  //d = sdSphere( p, vec3(0, 0, 5.0), 2.0 );\n  //return vec4( d, p);\n\n  // Calculate a unique index for each triangle, so it can have its own random\n  // offset and spin.  I tried using SDF rep limit stuff to reduce number of\n  // calculations. Feel like it should be possible, and I got close but\n  // generated artifacts.\n  //\n  // This needs to match camera speed but then be divided by space between each\n  // triangle.\n  float tIndex = floor(sceneTime() * (1.0 / CAM_SPEED) / GATE_SPACING) - 6.0;\n\n  vec3 tPos = vec3(0, 0, tIndex * GATE_SPACING);\n\n  for (float i = 0.0; i < 12.0; i++) {\n    tPos += vec3(0.0, 0.0, GATE_SPACING);\n\n    float spinDelta = 7.0;\n    float spinTime = abs(sin((tIndex + i) * 453.32 + 3563.0)) * spinDelta;\n    float tAngle = sin((tIndex + i) * 2354.0 + 23.0) * 0.1;\n    tAngle = inOutBack(0.0, 0.7, mod(iTime, spinDelta + 0.7) - spinTime)\n      * 2.0 * PI / 3.0 + tAngle;\n    tAngle += sin(iTime * smoothstep(0.3, 0.6, sin((tIndex + i) * 356.4))) * 0.1;\n    d = min(d, sdTriangle(p - tPos, tAngle));\n  }\n\n  return vec4(d, p);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n\n    float tmax = MAX_DIST;\n    float t    = 0.001;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, 1e-6), intensity);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, inout float glow )\n{\n    vec4 res = vec4(-1.0);\n\n    float t = 0.001;\n    float tmax = 15.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec4 h = map(ro+t*rd);\n        // Calculate the glow at the current distance using the distance based\n        // glow function. Accumulate this value over the whole view ray The\n        // smaller the step size, the smoother the final result\n        //\n        // This means everything will glow equally/the same color.\n        glow += getGlow(h.x, 1e-3, 0.75);\n\n        if( h.x<1e-6 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n        if (t >= tmax) break;\n    }\n\n    return res;\n}\n\nvec3 normal(in vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(0.01, 0.0);\n\n  vec3 n = d - vec3(\n      map(p - e.xyy).x,\n      map(p - e.yxy).x,\n      map(p - e.yyx).x);\n\n  return normalize(n);\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n  // Introduce some motion in both the camera position and look direction.\n  vec3 ro = vec3(\n    sin(sceneTime() / 3.0) * 0.1,\n    sin(sceneTime() / 4.0) * 0.1,\n    sceneTime() * (1.0 / CAM_SPEED)\n  );\n  vec3 rd = normalize(vec3(\n    uv.x + sin(sceneTime() / 2.0) * 0.1,\n    uv.y + sin(sceneTime() / 2.3) * 0.09,\n    1.0\n  ));\n\n  // background\n  vec3 col = vec3(1.0+rd.y)*0.00;\n\n  float glow = 0.0;\n  float d = intersect(ro, rd, glow).x;\n\n  //vec3 glowColour = vec3(0.2, 0.5, 1.0);\n  //vec3 glowColour = vec3(0.502, 0.055, 0.075);\n  vec3 glowColour = vec3(1.0,0.05,0.3);\n  col = glow * glowColour;\n\n  if (d > 0.0) {\n    vec3 pos = ro + rd * d;\n    vec3 nor = normal(pos);\n    vec3 f0 = vec3(0.8);\n    vec3 mate = vec3(0.5);\n\n    // Some old lighting + shadow stuff. Doesn't interact with glow effect.\n    //// origin light\n#if 0\n    {\n      vec3 lightPos = vec3(0, 5, -10.0) + ro;\n      lightPos.xz += vec2(sin(iTime), cos(iTime) * 0.5);\n      vec3 l = normalize(lightPos - pos);\n\n      float dif = 0.5 + 0.5 * dot(nor, l);\n      dif *= 0.3;\n      vec3 ref = reflect(rd,nor);\n      //vec3 spe = vec3(0.9) * smoothstep(0.8, 0.9, dot(ref, l));\n      //float fre = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n      //spe *= f0 + (1.0 - f0)*pow(fre, 5.0);\n      //spe *= 7.0;\n      vec3 hal = normalize(l - rd);\n      float spe = clamp(dot(hal, nor), 0.0, 1.0);\n      spe = pow(spe, 32.0);\n\n      float shadow = clamp(calcSoftshadow(pos+nor*SURF_DIST*0.001, l, 80.0), 0.1, 1.0);\n      col += dif * mate;\n      col += spe * dif;\n      col *= shadow;\n      //col = vec3(spe);\n    }\n#endif\n\n  }\n  col = ACESFilm(col);\n  col = pow(col, vec3(0.4545)); // gamma correction\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}