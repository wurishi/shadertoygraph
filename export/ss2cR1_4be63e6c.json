{"ver":"0.1","info":{"id":"ss2cR1","date":"1643134118","viewed":271,"name":"Parasitic  Mussle","username":"panna_pudi","description":"Moved through checking 2 neighbours to 1 and then to 0","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","traversal","2022"],"hasliked":0,"parentid":"NdXyDf","parentname":"Parasitic Barnacle"},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parasitic Mussle by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane, z0rg, Tater\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// Thanks Tater for pointing out at the grid traversal method\n// https://www.shadertoy.com/view/flc3Rs\n\nvec2 noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod(iChannel1, (uv+0.5) / 256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec3 frame(vec2 uv) {\n    float shadow = texture(iChannel0, uv + vec2(-0.008, 0.014)).w;\n    vec4 frame = texture(iChannel0, uv);\n\n    vec3 col = vec3(98, 140, 135) / 255.;\n    col = mix(col, vec3(68, 44, 60) / 255., AAstep(0.9, shadow));\n    col = mix(col, frame.rgb, AAstep(0., frame.w));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy; float scale = .5;\n    \n    vec3 col = vec3(0.);\n    const int N = 1;\n    for (int i = -N; i <= N; i++) {\n        for (int j = -N; j <= N; j++) {    \n            col += frame(uv - vec2(i, j) / (iResolution.xy / scale));\n        }\n    }\n    float k = 2. * float(N) + 1.;\n    col /= k * k;\n    \n\tfloat t = floor(iTime * 100.0);\n\tvec2 tex = mix(noise(vec3(uv * 10.0, t)).xy, uv + t, .8);\n\tfloat grains = texture(iChannel2, tex).r;\n    grains = smoothstep(.1, .0, grains);\n\tcol *= vec3(1.0) - .1 * grains * grains;\n    \n    col = pow(col, vec3(1.2525));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\nconst float T_MAX = 28.;\nconst float EPS = 0.0001;\n\n#define AAstep(x0, x) clamp((x - x0) / (2. * 2. / iResolution.y), 0., 1.)\n\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\t\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n);\n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b),        rand(b + d.yx), f.x),\n               mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    return b;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// gaz gaz gaz gaz\nvec2 polarMod(vec2 p, float n) {\n    float a = mod(atan(p.y, p.x), TAU / n) - PI / n;\n    return vec2(sin(a), cos(a)) * length(p);\n}\n\n// tater tater\nfloat diplane(vec3 p, vec3 b, vec3 rd) {\n    vec3 dir = sign(rd) * b;\n    vec3 rc = (dir - p) / rd;\n    return rc.y + EPS;\n}\n\nfloat nolim(float p, float s) {\n    return p - s * round(p / s);\n}\n\nfloat noidlim(float p, float s) {\n    return round(p / s);\n}\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_disk(vec3 p, float r, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n    q = abs(q) - vec2(r, h);\n    return length(max(q, 0.)) + min(0., max(q.x, q.y));\n}\n\nfloat sd_segment(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    float k = dot(pa, ba) / dot(ba, ba);\n    return distance(p, mix(a, b, clamp(k, 0., 1.)));\n}\n\nvec2 chord(vec3 p, float c, float r, float f, float n) {\n    vec3 q = p;\n    q.xz = polarMod(q.xz, n);\n    vec2 d = vec2(sd_sphere(q - vec3(0., 0., r * f),\n                  c / 5. * f), 1.);\n\n    q = p;\n    q.xz *= rot(PI / n);\n    q.xz = polarMod(q.xz, n);\n    float a = 0.1 + n / 7.;\n    q.yz -= vec2(0.0, a * r * f);\n    d = _min(d, vec2(length(q.yz) - 0.05 * (f + 0.15), 1));\n\n    return d;\n}\n\nvec2 primitive(vec3 p, float c, float f, float t) {\n    p.xz *= rot(PI / 3. - t);\n    vec2 d = vec2(sd_sphere(p, c / 2. * f), 0.);\n    vec2 outter = chord(p, c, 2.5, f, 5.);\n    outter.y += 1.;\n    d = _min(d, outter);\n    \n    p.xz *= rot(PI + 2. * t);\n    d = _min(d, chord(p, c, 1.5, f, 3.));\n    return d;\n}\n\nvec3 ray_dir;\nfloat mat_id = -1.;\nfloat id;\nfloat map(vec3 p) {\n    vec2 d = vec2(1e9, -1.);\n    float t = iTime * 1.2;\n    vec3 rd = ray_dir;\n\n    float width = 1., n = 20.;\n\n    p.xy *= rot(PI / 3.);\n    rd.xy *= rot(PI / 3.);\n\n    p.y -= t + noise(t) * 1.5;\n\n    id = noidlim(p.y,  width);\n    p.y = nolim(p.y,  width);\n\n    float factor = smoothstep(width * n, 0., abs(id + t));\n    factor -= 0.1;\n\n    float radius = 8. * factor;\n\n    float phi = t * 0.2 + id * 1.5; // + noise(t * 0.5 - center);\n    p.xz += radius * vec2(cos(phi), sin(phi));\n    \n    vec2 me = primitive(p, width, factor, 3. * noise(t + id));\n    vec2 grid = vec2(diplane(p, vec3(width * .5), rd), -1.0);\n\n    d = _min(me, grid);\n\n    mat_id = d.y;\n    return d.x;\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.001);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nmat3 get_cam(vec3 eye, vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float hit = -1.;\n    float t = 5.;\n    for (int i = 0; i < 45; i++) {\n        float d = map(ro + rd * t);\n        if (abs(d) < EPS) {\n            hit = 1.;\n            break;\n        };\n        t += d;\n        if (t > T_MAX) break;\n    }\n    return vec2(t, hit);\n}\n\nfloat sd_square(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) - min(max(p.x, p.y), 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy * 2. - 1.)\n              * vec2(aspect, 1.);\n    float time = iTime;\n\n    vec3 ro = vec3(-8., -0., -13.);\n    vec3 target = vec3(-2., 0., 0.);\n    mat3 cam = get_cam(ro, target);\n    vec3 rd = cam * normalize(vec3(uv, 1.));\n    ray_dir = rd;\n\n    vec2 t = trace(ro, rd);\n\n    vec3 col = vec3(98, 140, 135) / 255.;\n    if (t.y > 0. && mat_id != -1.) {\n        vec3 pos = ro + rd * t.x;\n        vec3 nor = get_norm(pos);\n\n        vec3 albedo;\n        if (0. == mat_id) {\n            albedo = vec3(215, 251, 255) / 255.;\n        }\n        if (1. == mat_id) {\n            albedo = vec3(74, 89, 146) / 255.;\n        }\n        if (2. == mat_id) {\n            albedo = mix(vec3(86, 68, 76), vec3(101, 255, 79) / 1.2,\n                         mod(id, 2.)) / 255.;\n        }\n\n        col = albedo;\n    }\n\n    float d = sd_square(uv, vec2(0.95) * vec2(aspect * 1.02, 1.));\n    d = 0.01 - abs(d);\n    d = AAstep(0., d + 0.0025);\n    col = mix(col, vec3(0.), d);\n    \n    col = mix(col, texture(iChannel0, fragCoord / iResolution.xy).rgb, 0.25);\n    \n    fragColor = vec4(col, max(t.y, d));\n}","name":"Buffer A","description":"","type":"buffer"}]}