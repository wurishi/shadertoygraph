{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n#define EPSILON 0.00001\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = 2.0 * PI;\nconst float HALF_PI = 0.5 * PI;\n\nconst vec3 _X = vec3(1.0, 0.0, 0.0);\nconst vec3 _Y = vec3(0.0, 1.0, 0.0);\nconst vec3 _Z = vec3(0.0, 0.0, 1.0);\n\n// ray-plane intersection test\n// @return side of plane hit\n//    0 : no hit\n//    1 : front\n//    2 : back\nint intersect_plane (in vec3 ro, in vec3 rd, in vec3 po, in vec3 pd, out vec3 hit)\n{   \n    float D = dot(po, pd);       // re-parameterize plane to normal + distance\n    float tn = D - dot(ro, pd);  // ray pos w.r.t. plane (frnt, back, on)\n    float td = dot (rd, pd);     // ray ori w.r.t. plane (towards, away, parallel)\n    \n    if (td > -EPSILON  &&  td < EPSILON)  return 0;  // parallel to plane\n    \n    float t = tn / td;          // dist along ray to hit\n    if (t < 0.0)  return 0;     // plane lies behind ray\n    hit = ro + t * rd;          // got a hit\n    return (tn > 0.0) ? 2 : 1;  // which side of the plane?\n}\n\n// ray-sphere intersection\n// @return side of hit\n//    0 : no hit\n//    1 : outside\n//    2 : inside\nint intersect_sphere (in vec3 ro, in vec3 rd, in vec3 po, in float rad, out vec3 hit)\n{\n    float R = rad;\n    float RSq = R*R;\n\tvec3 d = ro - po;\n    float DSq = dot(d,d);\n\n    //float a = 1.0;\n    float b = 2.0 * dot(d, rd);\n    float c = dot(d,d) - RSq;    \n\tfloat descrim = b*b - 4.0*c;\n\n    if (descrim < 0.0)  return 0;  // no hit\n\n    float det = sqrt(descrim);\n    float t0 = (-b + det) / 2.0;\n    float t1 = (-b - det) / 2.0;\n    float t = min(t0, t1);\n\thit = ro + t * rd;\n    return (DSq > RSq) ? 1 : 2;    // outside | inside\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // [0, 1]\n    vec2 st = 2.0 * uv - vec2(1.0);             // [-1, 1]\n\n    float asp = iResolution.x / iResolution.y;\n    float inv_asp = iResolution.y / iResolution.x;\n    \n    // adjust st coords to range [-1, 1] in Y, [-asp, asp] in X\n    //\n  \t// really, this should do a check for the aspect to determine which\n    // axis to adjust, but we're working in landscape for now.\n    vec2 st_adj = vec2(st.x * asp, st.y);\n    \n    // camera settings\n    float dist = 2.0 + 0.5*sin(0.5*iTime);\n    float theta = 0.1230596391*iTime;\n    float cx = dist * sin(theta);\n    float cz = dist * cos(theta);\n    vec3 cam_ori = vec3(cx, 1.0+0.125*sin(0.215934771*iTime), cz);\n    vec3 cam_look = vec3(0.0, 0.50, 0.0);\n    vec3 cam_dir = normalize(cam_look - cam_ori);\n    \n    // over, up, norm basis vectors for camera\n  \tvec3 cam_nrm = cam_dir;\n    vec3 roll = vec3(0.0, 0.05*sin(1.215233*iTime), 0.0);\n    vec3 cam_ovr = normalize(cross(cam_dir, _Y) + roll);\n    vec3 cam_uhp = normalize(cross(cam_ovr, cam_nrm));\n    \n    // scene\n    vec3 po = vec3(0.0);\n    vec3 pd = vec3(0.0, 1.0, 0.0);\n    \n \t// ray\n    vec3 ro = cam_ori;\n\n    float cam_dist = 3.0;\n    vec3 rt = cam_ori + cam_dist*cam_dir;\n    rt += st_adj.x * cam_ovr;\n    rt += st_adj.y * cam_uhp;\n    vec3 rd = normalize(rt - cam_ori);\n    \n    vec3 hit;\n    int side = intersect_plane (ro, rd, po, pd, hit);\n\n    // sky\n    if (side == 0) {\n        fragColor = texture(iChannel1, rd);\n    }\n    \n    // plane\n    //  - figure out UV on plane to sample texture\n    vec3 dee = hit - po;\n    float tSize = 1.0 / 2.0;\n    vec2 p_uv = vec2(dot(dee, _X) * tSize, dot(dee, _Z) * tSize);\n\tvec4 tx_clr = texture( iChannel0, p_uv);\n    \n    if (side == 1)\n        fragColor = tx_clr;\n    else if (side == 2)\n        fragColor = tx_clr * vec4(0.5);\n    \n    // sphere\n    vec3 so = vec3(0.0, 0.5, 0.0);\n    float rad = 0.5;\n\n    // shaddow sample ray\n    if (side > 0) {\n\t    vec3 s_ro = hit;\n   \t\tvec3 s_rd = pd;\n    \tside = intersect_sphere (s_ro, s_rd, so, rad, hit);\n    \tif (side > 0)  fragColor *= 0.3;\n    }\n        \n    // sphere intersection & shading\n    side = intersect_sphere (ro, rd, so, rad, hit);\n    if (side > 0) {\n        vec3 hitNorm = normalize(hit - so);\n        float adj = dot(hitNorm, -rd);\n        fragColor = adj * vec4(0.0, 0.54, 0.78, 1.0);\n        \n\t\tfloat inv_adj = 1.0 - adj;\n        vec3 ref_ori = hit;\n        vec3 ref_dir = reflect(rd, hitNorm);\n        if (side == 2)\n            ref_dir *= -1.0;\n        vec4 tex_clr = pow(inv_adj, 0.75) * texture(iChannel1, ref_dir);\n        fragColor = mix(fragColor, tex_clr, 0.35);\n    }\n    \n    // vignette, 'cuz why not...\n    float r_in = 0.75;\n    float wid = 1.15;\n    float r_out = r_in + wid;\n    float d = length(st);\n    float adj = 1.0-smoothstep(r_in, r_out, d);\n    fragColor *= vec4(vec3(adj), 1.0);\n        \n}\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sjSD3","date":"1416640978","viewed":306,"name":"Simple Camera Model","username":"alan","description":"Just getting my feet wet with a simple ray-casting camera model.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sphere","camera","plane"],"hasliked":0,"parentid":"","parentname":""}}