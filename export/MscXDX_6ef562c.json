{"ver":"0.1","info":{"id":"MscXDX","date":"1461922271","viewed":818,"name":"Faux raytrace in 2D","username":"LaBodilsen","description":"Faking a raytracing scene with 2D functions. (work in progress)\n\njust a checkerboard floor with a red reflective sphere. \ntrying to recreate this: https://www.tjhsst.edu/~dhyatt/superap/sphere1.jpg\n(changed the title, as it might have tricked some)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sphere","checkerboard","floor","fauxraytracing","fauxphong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 27-05-2016: reworked the shadow to closer match my \"Real retracing in 3D\" shader\n// 27-05-2016: Added fake Ambient occlusion to the floor and sphere\n// 27-05-2016: reworked floor lightning\n// 27-05-2016: Adjusted reflection -  still wip\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(.8-sqrt(uv.y),0.,0.);\n    float size = (-uv.y+.1)/1.5;\n\tfloat time = iTime*.5;\n    float r = 0.6;\n\n    //floor\n    if (uv.y < .0){\n    color = vec3(0.,0.,0.);\n    color += vec3(mod(floor(uv.x/size+sin(time)) + floor(uv.y*20./size+time),2.)-.8-uv.y);\n\n    // Lightsource falloff on floor\n    color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-uv.x/6.,.6+uv.y/1.5))));\n    }\n\n    // Floor Ambient occlusion\n    color *= smoothstep(1.-length(vec2(uv.x+.3,uv.y*2.+1.2)),1.,length(vec2(.6,.6)));\n    \n\t// Shadow\n    vec2 sphe = uv;\n    sphe.y += (uv.y*1.3)+1.2;\n    sphe.x += (uv.y-uv.x/5.5)+1.;\n\tfloat radius = r-.17;\n    float shadow = step(length(sphe),radius);\n    if (shadow > radius){\n        float shadow = .5;//(length(sphe+(r/3.))*.7/r);\n        color *= shadow;\n    }\n\n    //Sphere\n    vec2 pos = vec2 (.3,.1);\n\tradius = 1.-step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r);\n    if (radius < r){\n        color = vec3(0.,0.,0.);\n    \tfloat light = 1.3-length(vec2(pos.x+uv.x-.2,(pos.y+uv.y-.2)))/.7;\n    \tfloat highlight = .05/length(vec2(pos.x+uv.x+uv.y/6.,pos.y+uv.y)-.2)-.2;\n\n        \n    \tcolor.r = step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r)*light;\n    \tcolor.gb += vec2(step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r)*highlight);\n\n\n        // reflection\n        if (uv.y < -cos(pos.x+.1+uv.x*1.2)/6.){\n\t\t\tvec2 uvrf = vec2(uv.x+pos.x,uv.y);\n            size = -cos(tan(sin(uvrf.x)*1.6)/.6)/10.+sin(-.01+pos.y+uvrf.y-3.12)-uvrf.y/5.;\n\t    \tcolor += vec3(mod(floor(cos(uvrf.y-1.5)+1.5*uvrf.x/size+sin(time)) + \n                              floor(-uvrf.y+uvrf.y*5./size+time+1.1),2.)-1.-uvrf.y);\n    \t    color.r += step(length(vec2(pos.x+uv.x,pos.y+uv.y)),r)*light*1.2;\n\n        }\n\n\t// Shadow reflection\n    vec2 sphe = uv*2.;\n    sphe.y += (uv.y-.25);\n    sphe.x += (uv.x+.5);\n\tfloat radius = r;\n    float shadow = step(3.-length(sphe),radius);\n    if (shadow > radius){\n        float shadow = .6;//(length(sphe+(r/3.))*.7/r);\n        color *= shadow;\n    }\n\t// Sphere ambient occlusion\n    color *= smoothstep(1.-length(vec2(uv.x+.3,uv.y*2.+2.)),1.,.6);\n\n    } \n\n\tfragColor = vec4(vec3(color.rgb),1);\n}\n\n\n","name":"Image","description":"","type":"image"}]}