{"ver":"0.1","info":{"id":"Ms3GRN","date":"1448321932","viewed":245,"name":"Prime visualization","username":"RenoM","description":"prime numbers","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["prime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float lim=1000.;\nvec2 R=iResolution.xy;\nfloat zoom=3.;\n\n/*\n\tEach pixel represents a value placed like so :\n\t\n\t7\n\t4  8\n\t2  5  9\n\t1  3  6  10      etc...\n\t\n\tPrime values are represented by green pixels.\n\tSimilarly to Ulam spiral we can see that some diagonals contain much more primes than others.\n*/\n\nbool isPrime(float n)\n{\n    n=floor(n);\n    if(n==2.)return true;\n    if (n==1.||mod(n,2.)==.0)return false;\n    for(float i=3.;i<=6000.;i+=2.)\n    {\n        if(i*i>n)\n            break;\n        if(mod(n,i)==.0)\n            return false;\n    }\n    return true;\n}\n\n/*float isPrime( float x )\n{\n\tif( x==1.0 ) return 0.0;\n\tif( x==2.0 ) return 1.0;\n\tif( x==3.0 ) return 1.0;\n\tif( x==5.0 ) return 1.0;\n\tif( x==7.0 ) return 1.0;\n\t\n\tif( mod(x,2.0)==0.0 ) return 0.0;\n\tif( mod(x,3.0)==0.0 ) return 0.0;\n\tif( mod(x,5.0)==0.0 ) return 0.0;\n\n\tfloat y = 7.0;\n\tfor( int i=0; i<200; i++ ) // count up to 6000\n\t{\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 6.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 6.0; if( y>=x ) return 1.0;\n        \n        \n        \n        // speeds up, slows down, or crashes your compiler, \n        // depending on your GLSL implementation:\n        \n        //if( (y*y) > x ) break; \n\t}\n\t\n\treturn 1.0;\n}*/\n\nvoid mainImage(out vec4 C,in vec2 U)\n{\n    vec2 u=floor(U/zoom);\n\tfloat n=(u.x+u.y+1.)*(u.x+u.y+2.)/2.-u.y;\n    C=vec4(0,isPrime(n)&&n<500.*iTime,0,1);\n}","name":"","description":"","type":"image"}]}