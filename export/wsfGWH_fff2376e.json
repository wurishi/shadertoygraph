{"ver":"0.1","info":{"id":"wsfGWH","date":"1546005707","viewed":1530,"name":"Rayleigh/Mie Day and Night Cycle","username":"Elyxian","description":"This is an attempt to implement the Nishita atmospheric scattering model for Rayleigh and Mie scattering as described by Scratchapixel\n\nSee https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sunset","sky","scattering","night","skybox","rayleigh","day","mei","scratchapixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Also see https://www.shadertoy.com/view/lslXDr by gltracy for another implementation\n\n// This is an attempt to implement the Nishita atmospheric scattering model for\n// Rayleigh and Mie scattering as described by Scratchapixel\n// see https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n\n// If you are trying to understand this implementation, reading the above link will help a lot\n\n// For another atmospheric scattering model, look at the Preetham model\n\n// By changing these constants, different/alien atmospheres can be achieved\n\n// This program is written with understanding in mind (hopefully) rather than performance. In\n// particular, the getSkyColor routine can be optimised so that the transmittance function does\n// not need to calculate redundant information (see the link above for information)\n\n// Mathematical Constants\nconst float PI = 3.14159265;\n\n// Planet Constants\nconst float EARTHRADIUS = 6360e3; // 6360e3\nconst float ATMOSPHERERADIUS = 6420e3; //6420e3\nconst float SUNINTENSITY = 20.0; //20.0\n\n// Rayleigh Scattering\nconst float RAYLEIGHSCALEHEIGHT = 7994.0; // 7994.0\nconst vec3 BETAR = vec3(3.8e-6, 13.5e-6, 33.1e-6);\n\n// Mie Scattering\nconst float MIESCALEHEIGHT = 1200.0; // 1200.0\nconst vec3 BETAM = vec3(210e-5, 210e-5, 210e-5);\nconst float G = 0.76;\n\n// --------------------------------------\n// ---------- Helper Functions-----------\n// --------------------------------------\n\n// Returns the matrix that rotates a given point by 'a' radians\n\nmat2 mm2(in float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n    \n}\n\n// The tone mapping function from Uncharted 2, as implemented by Zavie\n// From https://www.shadertoy.com/view/lslGzl\n\nvec3 Uncharted2ToneMapping(vec3 color) {\n    \n    float gamma = 2.2;\n    \n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n\n}\n\n// Returns the first intersection of the ray with the sphere (or -1.0 if no intersection)\n// From https://gist.github.com/wwwtyro/beecc31d65d1004f5a9d\n\nfloat raySphereIntersect(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {\n    \n    float a = dot(rayDirection, rayDirection);\n    vec3 d = rayOrigin - sphereCenter;\n    float b = 2.0 * dot(rayDirection, d);\n    float c = dot(d, d) - (sphereRadius * sphereRadius);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b + sqrt((b*b) - 4.0*a*c))/(2.0*a);\n    \n}\n\n// -------------------------------\n// ------- Main Functions --------\n// -------------------------------\n\n// The rayleigh phase function\nfloat rayleighPhase(float mu) {\n    float phase = (3.0 / (16.0 * PI)) * (1.0 + mu * mu);\n    return phase;\n}\n\n// The mie phase function\nfloat miePhase(float mu) {\n    float numerator = (1.0 - G * G) * (1.0 + mu * mu);\n    float denominator = (2.0 + G * G) * pow(1.0 + G * G - 2.0 * G * mu, 3.0/2.0);\n    return (3.0 / (8.0 * PI)) * numerator / denominator;\n}\n\n// Returns the expected amount of atmospheric scattering at a given height above sea level\n// Different parameters are passed in for rayleigh and mie scattering\nvec3 scatteringAtHeight(vec3 scatteringAtSea, float height, float heightScale) {\n\treturn scatteringAtSea * exp(-height/heightScale);\n}\n\n// Returns the height of a vector above the 'earth'\nfloat height(vec3 p) {\n    return (length(p) - EARTHRADIUS);\n}\n\n// Calculates the transmittance from pb to pa, given the scale height and the scattering\n// coefficients. The samples parameter controls how accurate the result is.\n// See the scratchapixel link for details on what is happening\nvec3 transmittance(vec3 pa, vec3 pb, int samples, float scaleHeight, vec3 scatCoeffs) {\n    float opticalDepth = 0.0;\n    float segmentLength = length(pb - pa)/float(samples);\n    for (int i = 0; i < samples; i++) {\n        vec3 samplePoint = mix(pa, pb, (float(i)+0.5)/float(samples));\n        float sampleHeight = height(samplePoint);\n        opticalDepth += exp(-sampleHeight / scaleHeight) * segmentLength;\n    }\n    vec3 transmittance = exp(-1.0 * scatCoeffs * opticalDepth);\n    return transmittance;\n}\n\n// This is the main function that uses the ideas of rayleigh and mie scattering\n// This function is written with understandability in mind rather than performance, and\n// redundant calls to transmittance can be removed as per the code in the scratchapixel link\n\nvec3 getSkyColor(vec3 pa, vec3 pb, vec3 sunDir) {\n\t\n    // Get the angle between the ray direction and the sun\n    float mu = dot(normalize(pb - pa), sunDir);\n    \n    // Calculate the result from the phase functions\n    float phaseR = rayleighPhase(mu);\n    float phaseM = miePhase(mu);\n    \n    // Will be used to store the cumulative colors for rayleigh and mie\n    vec3 rayleighColor = vec3(0.0, 0.0, 0.0);\n    vec3 mieColor = vec3(0.0, 0.0, 0.0);\n\n    // Performs an integral approximation by checking a number of sample points and:\n    //\t\t- Calculating the incident light on that point from the sun\n    //\t\t- Calculating the amount of that light that gets reflected towards the origin\n    \n    int samples = 10;\n    float segmentLength = length(pb - pa) / float(samples);\n    \n    for (int i = 0; i < samples; i++) {\n        \n    \tvec3 samplePoint = mix(pa, pb, (float(i)+0.5)/float(samples));\n        float sampleHeight = height(samplePoint);\n        float distanceToAtmosphere = raySphereIntersect(samplePoint, sunDir, vec3(0.0, 0.0, 0.0), ATMOSPHERERADIUS);\n    \tvec3 atmosphereIntersect = samplePoint + sunDir * distanceToAtmosphere;\n        \n        // Rayleigh Calculations\n        vec3 trans1R = transmittance(pa, samplePoint, 10, RAYLEIGHSCALEHEIGHT, BETAR);\n        vec3 trans2R = transmittance(samplePoint, atmosphereIntersect, 10, RAYLEIGHSCALEHEIGHT, BETAR);\n        rayleighColor += trans1R * trans2R * scatteringAtHeight(BETAR, sampleHeight, RAYLEIGHSCALEHEIGHT) * segmentLength;\n        \n        // Mie Calculations\n        vec3 trans1M = transmittance(pa, samplePoint, 10, MIESCALEHEIGHT, BETAM);\n        vec3 trans2M = transmittance(samplePoint, atmosphereIntersect, 10, MIESCALEHEIGHT, BETAM);\n        mieColor += trans1M * trans2M * scatteringAtHeight(BETAM, sampleHeight, MIESCALEHEIGHT) * segmentLength;\n        \n    }\n    \n    rayleighColor = SUNINTENSITY * phaseR * rayleighColor;\n    mieColor = SUNINTENSITY * phaseM * mieColor;\n    \n    return rayleighColor + mieColor;\n    \n}\n\n// Get the sky color for the ray in direction 'p'\nvec3 skyColor(vec3 p, vec3 sunDir) {\n    \n    // Get the origin and direction of the ray\n\tvec3 origin = vec3(0.0, EARTHRADIUS + 1.0, 0.0);\n\tvec3 dir = p;\n\n\t// Get the position where the ray 'leaves' the atmopshere (see the scratchapixel link for details)\n    // Note that this implementation only works when the origin is inside the atmosphere to begin with\n    float distanceToAtmosphere = raySphereIntersect(origin, dir, vec3(0.0, 0.0, 0.0), ATMOSPHERERADIUS);\n    vec3 atmosphereIntersect = origin + dir * distanceToAtmosphere;\n    \n    // Get the color of the light from the origin to the atmosphere intersect\n    vec3 col = getSkyColor(origin, atmosphereIntersect, sunDir);\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray from the origin\n    vec3 r = normalize(vec3(p, 0.9));\n    \n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.2,0.12):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    r.yz *= mm2(mo.y);\n    r.xz *= mm2(mo.x);\n    \n    // Calculates the position of the sum (as an angle from the origin)\n    //vec3 sunDir = normalize(vec3(0.0, 0.05, 1.0));\n    float timeScale = 0.2;\n    float time = (iTime - 10.0) * timeScale;\n    vec3 sunDir = normalize(vec3(sin(time), cos(time), 1.0));\n    \n    // Gets the appropriate skycolor for the ray\n    vec3 col = skyColor(r, sunDir);\n    \n    // Runs the color through a tone mapper\n    // Found here https://www.shadertoy.com/view/lslGzl and originally from Uncharted 2\n    col = Uncharted2ToneMapping(col);\n    \n    // Render the floor \n    if (r.y < 0.0) {\n    \t//col = vec3(0.1, 0.3, 0.1);\n        col = vec3(0.5, 0.5, 0.5);\n    }\n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}