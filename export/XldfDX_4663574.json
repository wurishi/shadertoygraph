{"ver":"0.1","info":{"id":"XldfDX","date":"1541855011","viewed":116,"name":"Boby Sponger","username":"dijame","description":"Bobick est une fusion potara (cf Dragon Ball Z), il s'agit de bob l'éponge et de patrick qui se mêlent pour ne former qu'un.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bobick"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\nvec3 scale(vec3 p, float s)\n{\n    return p * s;\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat blob(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Cone skeleton\n// p : point \n// o : origin of skeleton\n// h : size of cone\n// a : angle of adjacent/opposite\n// e : energy associated to skeleton\n// r : radius\nfloat cone(vec3 p, vec3 o, float e, float R)\n{\n\tvec2 q    = vec2( length( p.xz ), p.y );\n    float d1  = -p.y - o.z;\n    float d2  = max( dot(q,o.xy), p.y );\n    float res = length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n    return e * falloff(res,R);\n}\n\n// Line skeleton\n// p : point\n// l1 : first point of the line\n// l2 : second point of the line\n// e : energy associated to skeleton\n// R : large radius\nfloat line(vec3 p, vec3 l1, vec3 l2, float e, float R) \n{\n\tvec3 direction = normalize(l2 - l1);\n    vec3 l1p = p - l1;\n    \n    float dotProduct = dot(direction, l1p);\n    \n    if (dotProduct < 0.0) {\n\t\treturn e*falloff(length(p-l1),R);\n    } else if (dotProduct > length(l2 - l1)) {\n        return e*falloff(length(p-l2),R);\n    }\n    \n    // projection of p on the line\n    vec3 l1H = dotProduct * direction;\n    vec3 h = l1 + l1H;\n    \n\treturn e*falloff(length(p-h), R);\n}\n\n// Line skeleton with decrease\n// p : point\n// l1 : first point of the line\n// l2 : second point of the line\n// e : energy associated to skeleton\n// R : large radius\nfloat lineDecreasing(vec3 p, vec3 l1, vec3 l2, float e, float R, float minDecreasingRatio) {\n    \n\tvec3 direction = normalize(l2 - l1);\n    vec3 l1p = p - l1;\n    \n    float dotProduct = dot(direction, l1p);\n    \n    if (dotProduct <= 0.0) {\n\t\treturn e*falloff(length(p-l1),R);\n    } else if (dotProduct >= length(l2 - l1)) {\n        return e*falloff(length(p-l2),minDecreasingRatio * R);\n    }\n    \n    // projection of p on the line\n    vec3 l1H = dotProduct * direction;\n    vec3 h = l1 + l1H;\n    \n    float decreasingRatio = 1.0 - (dotProduct / length(l2-l1)) * (1.0 - minDecreasingRatio);\n    \n\treturn e*falloff(length(p-h), decreasingRatio * R);\n}\n\n// Circle skeleton\n// p : point\n// c : center\n// r : radius\n// n : circle normal\n// e : energy associated to skeleton\n// R : large radius\nfloat circle(vec3 p, vec3 c, float r, vec3 n, float e, float R) {\n    \n    vec3 delta = p - c;\n\tvec3 CQ = delta - (dot(delta, n) * n);\n    \n    vec3 K = c + r * normalize(CQ);\n    \n\treturn e*falloff(length(p-K), R);\n}\n\n// Half Circle skeleton\n// p : point\n// c : center\n// r : radius\n// n : circle normal\n// d : filled half direction\n// e : energy associated to skeleton\n// R : large radius\nfloat halfCircle(vec3 p, vec3 c, float r, vec3 n, vec3 d, float e, float R) {\n\n    float distance = 0.0;\n    \n    vec3 delta = p - c;\n    \n    if (dot(delta, d) < 0.0) {\n        vec3 orthoVec = cross(d, n);\n        \n  \t\treturn line(p, c -  orthoVec * r, c + orthoVec * r, e, R);   \n    } else {\n        vec3 CQ = delta - (dot(delta, n) * n);\n\n        vec3 K = c + r * normalize(CQ);\n\n        distance = length(p-K);\n    }\n    \n    return e*falloff(distance, R);\n}\n\n// Cuboid\n// p : point\n// c : center of cuboid\n// X : size of x edge\n// Y : size of Y edge\n// Z : size of z edge\n// e : energy asociated to skeleton\n// R : large radius\nfloat cuboid(vec3 p, vec3 c, float X, float Y, float Z, float e, float R)\n{\t\n    float x = abs(p.x- c.x);\n    float y = abs(p.y- c.y);\n    float z = abs(p.z- c.z);\n    \n    float distX = 0., distY = 0., distZ = 0.;\n    if (x > X/2.)\n        distX = x - X/2.;\n    if (y > Y/2.)\n        distY = y - Y/2.;\n    if (z > Z/2.)\n        distZ = z - Z/2.;\n    \n    float dist = sqrt(distX*distX + distY*distY + distZ*distZ);\n    \n    \n    //return e * falloff(max(max(x,y),z),R);       \n    return e * falloff(dist,R);     \n}\n\n// Cube\n// p : point \n// s : size of cube\n// e : energy associated to skeleton\n// s : size of cube\n// R : large radius\nfloat cube(vec3 p, vec3 s, float e, float R) {\n\treturn e * falloff(length(max(abs(p) - s, 0.0)), R);\n}\n\n// Tore\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// r : small radius\n// R : large radius\nfloat tore(vec3 p, vec3 c, float e, float r, float R)\n{\n    p.x = p.x - c.x;\n    p.y = p.y - c.y;\n    p.z = p.z - c.z;\n    float xz  = (sqrt((p.x*p.x) + (p.z*p.z)) - R);\n\tfloat yr  = (p.y*p.y)-(r*r);\n    float res = ((xz * xz) + yr);\n    return e * falloff(res,R);\n}           \n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n//Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a, float  b)\n{\n    return min(a,b);\n}\n\n// Private\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Deprived(float a, float b)\n{\n    return a-b;\n}\n\nfloat Interpolation(float a, float b, float c)\n{\n    return mix(a,b,c);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n    p.z=-p.z;\n    float tmp = p.x;\n    if(iTime < 10.) {\n        p.x = tmp - 10. + iTime;\n        p = scale(p,1.5);\n    }\n    else\n        p = scale(p,1.5);\n        \n    // Boby\n\tvec3 pabs = vec3(abs(p.x),p.y,p.z);\n    // Corps\n    float v = cuboid(p, vec3(0.0,0.0,0.0), 2.0,4.5,1.0,1.0, 4.0); \n    // Les yeux\n    //Les globes\n    float gb = blob(pabs,vec3(1.0,1.6,2.5),2.5,1.3);\n    // L'oeuil\n    float y = blob(pabs,vec3(1.0,1.6,2.5),2.5,1.3);\n\ty = Union(v,blob(pabs,vec3(1.05,1.65,3.0),3.5,0.55));\n    \n    v = Blend(v,gb);\n    v = Union(v,y);\n    // Les sourcils\n    v = Blend(v,cuboid(rotateZ(pabs,-0.55),vec3(0.0,3.0,2.15),0.12,0.3,0.1,1.0,.2));\n\tv = Blend(v,cuboid(pabs,vec3(1.0,2.75,2.15),0.12,0.3,0.1,1.0,.2));\n    v = Blend(v,cuboid(rotateZ(pabs,0.55),vec3(1.75,2.0 ,2.15),0.12,0.3,0.1,1.0,.2));\n    \n    // Le nez\n    v = Blend(v,line(p,vec3(0.0,.8,1.5),vec3(0.0,1.0,2.5),1.0,0.5));\n    \n    // Bouche\n    v = Deprived(v,Intersection(blob(p,vec3(0.0,-.8,1.5),50.0,1.),blob(p,vec3(0.0,-.3,1.5),50.0,1.)));\n    \n    // Les dents\n    //v = Union(v,cuboid(p,vec3(0.25,.1,1.15),0.3,0.4,0.15,1.0,1.0));\n    //v = Union(v,cuboid(p,vec3(-0.25,.1,1.15),0.3,0.4,0.15,1.0,1.0));\n\n    // Les manches\n    if( iTime < 25.){\n    \tv = Blend(v,cone(rotateZ(vec3(pabs.x - 2.5,pabs.y - 1.2,pabs.z),1.5), vec3(0.5,0.5,0.7), 0.6, .2));\n    \t// Les bras\n    \tv = Blend(v,line(pabs, vec3(3.5, 1.35, 0.0),vec3(6.1,1.5,0.0), .8, 0.8));  \n    } \n\n    // Les jambes\n    v = Blend(v,cone(rotateY(vec3(pabs.x - 0.5,pabs.y + 3.4,pabs.z),1.5), vec3(0.5,0.5,0.6), 0.6, .2));\n    v = Blend(v,line(pabs, vec3(1.0, -3.0, 0.0),vec3(1.0,-6,0.0), .8, 0.8));  \n    \n    v = Deprived(v,blob(pabs, vec3(1.9,-1.3,2.),1.0, 0.45));\n    v = Deprived(v,blob(pabs, vec3(1.4,-2.3,2.),1.0, 0.5));\n  \n  // PatPat  \n    if(iTime < 10.) {\n      p.x = tmp + 10. - iTime; \n      p = scale(p,0.9);\n    }  \n  if(iTime > 25.)  \n  \tp = scale(p,0.7);\n  // pieds\n  float g = lineDecreasing(vec3(abs(p.x) - 0.75,p.y,p.z) ,vec3( 0.0, -2.0, 0.0), vec3(1.0, -4.0, 0.0 + sin(4.0*iTime)),1.0,1.75, 0.3);\n\n  // buste\n  g = Blend(g,blob(p,vec3(0.0, -0.75 ,0.0),2.5,2.5));\n  // bras\n  g = Blend(g,lineDecreasing(vec3(-abs(p.x), p.y, p.z),vec3(-1.0, -0.25, 0.0), vec3(-3.0, 0.5, 0.0 + sin(4.0*iTime)), 1.0,1.25, 0.5));\n  // tete\n  g = Blend(g,lineDecreasing(p,vec3(0.0, 1.0, 0.0), vec3(0.0, 3.0, 0.0), 1.5, 1.5, 0.5));\n  // yeux\n  g = Blend(g, blob(vec3(abs(p.x) - 1.25, p.y, p.z), vec3(-0.9, 2.0, 0.5), 1.0, 0.5));\n  g = Blend(g, blob(vec3(abs(p.x) - 1.25, p.y, p.z), vec3(-0.9, 2.0, 0.7), 1.0, 0.1));\n    \n  // nombril\n  g = Deprived(g, blob(p, vec3(0.0, -1.5, 1.8), 1.0, 0.9));\n    \n  // sourcils\n  g = Union(g, line(vec3(abs(p.x) - 0.1, p.y, p.z), vec3(0.6, 2.7, 0.5), vec3(0.0, 2.75, 0.5), 0.7, 0.2));\n    \n  // bouche\n  g = Blend(g, halfCircle(p, vec3(0.0, 1.3, 0.8), 0.4, vec3(0.0, 0.0, -1.0), vec3(0.0, -1.0, 0.0), 1.0, 0.2));\n  \n if (iTime > 25.)\n    return Interpolation(g,v,0.6)-T;   \n else if(iTime > 20.)\n    return blob(p,vec3(0.0),1.0,exp(0.07*iTime)) - T;\n else if(iTime > 12.)\n   return (Interpolation(g,v,0.1 + sin(0.5*iTime))-T) * (0.25*iTime); \n else\n    return Blend(g,v) - T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p  = o + (t*u);\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o  : ray origin\n// u  : ray direction\n// h  : hit\n// s  : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float omega      = 1.2;\n    float t          = rA;\n    float c_t\t\t = rA;\n    float previous_v = 0.;\n    float stepL      = 0.;\n    float c_error    = 999.;\n\tfloat signe      = object(o) < 0. ? -1. : 1.;\n        \n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3  p   = o+(t*u);\n    float s_v = signe * object(p);   \n    float v   = object(p);\n    bool test = (omega > 1. && (v + previous_v) < stepL);  \n      \n    if(test) {\n        stepL  -= omega * stepL;\n        omega  =  1.0;\n    }\n    else {\n        stepL = s_v * omega; \n    }          \n      \n    previous_v  = v;\n    float error = s_v/t;\n    \n    if(!test && error < c_error){\n    \tc_t     = t;\n        c_error = error;\n    }\n\t\n      if (v > 0.) {\n\t\ts=i;\n        h = true;\n        break;\n      }\n    // Move along ray\n    t += max(stepL,0.15);        \n    // Escape marched far away\n      if (!test && t>rB)\n        break;\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\nvec3 objectColor() {\n  return mix(vec3(1.0, 0.3, 0.3), vec3(1.0, 1.0, 0.0), 0.25 * sin(0.5*iTime));\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos   = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n  vec3 c = vec3(0.0);\n  if(p.x < 0. && iTime < 12.)\t\n  \tc = vec3(1.0, 0.3, 0.3);\n  else if(p.x > 0. && iTime < 12.)  \n \tc = vec3(1.0, .5, 0.0);\n  else\n    c = objectColor();\n  \n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float ax=3.2;\n  float ay=0.0;  \n  if (iMouse.z > 0.0) {\n   \tax = iMouse.x / iResolution.x * 6.0 + 0.5;\n    ay = iMouse.y / iResolution.y * 6.0 + 0.5;  \n  }\n  ro = rotateY(ro, ax);\n  rd = rotateY(rd, ax);\n  //ro = rotateX(ro, ay);\n  //rd = rotateX(rd, ay);  \n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\t\n  //float t = Trace(ro,rd,hit,s);\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = vec3(1.0);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n    //rgb = vec3(0.5);  \n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}