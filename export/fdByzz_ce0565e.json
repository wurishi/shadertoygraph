{"ver":"0.1","info":{"id":"fdByzz","date":"1643147928","viewed":190,"name":"Smoother gamut compression","username":"bjornornorn","description":"Gamut compression","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gamut"],"hasliked":0,"parentid":"7sXcWn","parentname":"Gamut compression comparison"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat softness_scale = 0.2;\n\nvec3 toLms(float I, float hue, float sat)\n{\n    float a = cos(hue);\n    float b = sin(hue);\n    \n    float l_ = + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = - 0.0894841775f * a - 1.2914855480f * b;\n    \n    vec3 lms = vec3(l_,m_,s_);\n    \n    vec2 MC = findCenterAndPurity(lms);   \n    lms -= MC.x;    \n    lms *= sat;    \n    lms += I;\n    \n    return lms;\n}\n\nvec2 approximateShapeA(float L, float hue, float sat)\n{\n    vec3 lms = toLms(L, hue, sat);\n        \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1rYFDmHuv0MNzCHXQSwhBkJaMbTQzoXl3?usp=sharing\n    return vec2(\n        1.70021527e+00 + -8.21491826e-02*a +  1.73329721e-01*b +  1.73952306e-01*a2 +  4.95620904e-03*b2 + 1.94643985e-02*a3 +  2.39021796e-02*b3,\n        3.07593575e-01 + 1.70513225e-02*a +   7.21549478e-03*b +  1.99728079e-02*a2 + -1.25118676e-03*b2 + -7.99372300e-04*a3 + 1.21489709e-03*b3\n    );\n}\n\nvec2 approximateShapeB(float I, float hue, float sat)\n{\n    vec3 lms = toLms(I, hue, sat); \n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n\n    // softness_scale 0.2\n    // Estimated using https://colab.research.google.com/drive/1rYFDmHuv0MNzCHXQSwhBkJaMbTQzoXl3?usp=sharing\n    return vec2(\n        1.45502420e+00 + -7.65623334e-02*a +  2.26234241e-01*b +  6.25596210e-02*a2 +  3.16995726e-02*b2 + 4.46107711e-02*a3 +  3.49876286e-02*b3,\n        2.69987106e-01 + 1.69987106e-02*a +   1.00116716e-03*b +  1.02594717e-02*a2 + -6.08142494e-04*b2 + 2.29845394e-03*a3 + 2.13300284e-03*b3\n    );\n}\n\n\nvec3 compute(float I, float hue, float sat)\n{\n    vec3 lms = toLms(I, hue, sat);\n\n    lms = lms*lms*lms;\n    \n    float l = lms.x;\n    float m = lms.y;\n    float s = lms.z;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    \n    return rgbResult;\n}\n\nvec3 scurve3(vec3 x)\n{\n    return (3.0*x - x*x*x)/2.0;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    \n    float grey = 0.2;\n    \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n\n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    \n    float grey = 0.2;\n    \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    // soft clipping scaled to only affect colors outside gamut\n    float softness_scale = 0.25;\n    float softness = softness_scale*(maxX-1.0);\n\n    return grey + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = (fragCoord.x / iResolution.x)* 3.141592 * 2.;\n    float I = 2.0*fragCoord.y / iResolution.y;\n    I = I - floor(I);\n    float C = -0.5*log(0.5+0.5*sin(iTime));\n     \n    vec3 rgb;\n    \n    if (fragCoord.y / iResolution.y > 0.5)\n    {\n        vec2 ST = approximateShapeB(I, h, 1.0);\n   \n        float C_smooth = (1.0/((ST.x/I) + (ST.y/(1.0-I))));\n    \n        rgb = compute(I, h, C/sqrt(C*C/C_smooth/C_smooth+1.0));\n        rgb = softClipColor(rgb);\n    }\n    else\n    {\n        vec2 ST = approximateShapeA(I, h, 1.0);\n   \n        float C_smooth = (1.0/((ST.x/I) + (ST.y/(1.0-I))));\n        rgb = compute(I, h, C/sqrt(C*C/C_smooth/C_smooth+1.0));\n        rgb = softClipColorOutsideGamutOnly(rgb);\n        rgb = clamp(rgb,0.0,1.0);\n\n    }\n\n    fragColor.rgb = Srgb3(rgb);\n    fragColor.a = 1.;\n    \n    //fragColor = vec4(-1.0+2.0*vec3(length((2.0*(rgb-0.5))))/sqrt(3.0),1.0);   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}","name":"Common","description":"","type":"common"}]}