{"ver":"0.1","info":{"id":"4s2yRc","date":"1493136256","viewed":102,"name":"Firstshader_2","username":"Gwynbleidd","description":"Fragmentshader liczący kształt wykorzystując funkcje SDF. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot_v 1.0\n#define dark 1.0\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\nfloat cube (vec3 p)\n{\n    p = abs(p);\n    return max(p.x, max(p.y, p.z)) - 0.8;\n}\nfloat sdf(vec3 p)\n{\n //gdy 1   r\n  //  return sphere(p, 1.0);\n    // gdy 2 sfery\nreturn max(max (cube(p),sphere(p - vec3(-0.0, 0.0, 0.0), 1.0)),  -sphere(p, 0.95)); //min - suma, max - czesc wspolna\n// return max (cube(p),sphere(p - vec3(-0.0, 0.0, 0.0), 1.0)); //min - suma, max - czesc wspolna\n\n    //cube\n  //  return cube(p);\n} \nvec2 rot(vec2 p, float a)\n{\n  return cos(a) * p - vec2(p.y, -p.x) * sin(a);  \n}\nfloat sdf_rot(vec3 p)\n{\n    /*\n   p.y = p.y/(2.0*abs(cos(1.0*iTime+0.5))+1.0);\n   p.x = p.x/(2.0*abs(cos(1.0*iTime+0.5))+1.0);\n   p.z = p.z/(2.0*abs(cos(1.0*iTime+0.5))+1.0);\n\n   //*/ \n    \n   p.xz = rot(p.xz, iTime*0.5 * rot_v);\n   p.xy = rot(p.xy, iTime*0.5 * rot_v);\n   p.zy = rot(p.zy, iTime*0.7 * rot_v);\n\n    return sdf(p); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (fragCoord.xy - iResolution.xy * 0.5)/iResolution.x * 0.5;  //zrobienie kwadratu bo na tym polu pozniej pracujemy\n   \n    //definujemy kolory pikseli\n  \tvec3 cam = vec3(-50.0, 4.0*cos(1.0*iTime), 4.0*sin(1.0*iTime)); \n  //vec3 cam = vec3(   - 50.0, 0.0, -6.0*abs(cos(1.0*iTime))+3.0);   \n\t//vec3 cam = vec3(-25.0, 0.0, 0.0); \n    vec3 ray = vec3(1.0, uv.x, uv.y); // do robienia odleglosci\n    \n    float d = 0.0;\n    vec3 p;\n\tfor (int i = 0; i < 100; ++i) //sprawdzamy jak daleko jestesmy\n    {\n       p = 0.5*(cam + ray * d);\n        float nearest = sdf_rot(p);\n        d += nearest; \n        if (d > 1000.0 || nearest < 0.002) break;\n    }\n    \n    if (d > 1000.0)\n    {\n       // fragColor = vec4(0.85  ,0.45   ,0.62 , 0.55  );\n        fragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\n        return;\n    }\n\t// gradient daje normalna\n   \n   // p = cam + ray * d\n    \n    vec3 ldir = normalize(vec3(-60.0, 5.0 + 10.0*cos(1.0*iTime), 5.0 + 1.0*cos(1.0*iTime)));\n    //vec3 ldir = normalize(vec3(-20.0, 30.0, 20.0 ));\n    \n//Liczenie gradientu\n    vec2 delta = vec2(0.02, 0.0);\n    vec3 normal;\n    normal.x = sdf_rot(p + delta.xyy) - sdf_rot(p); //xyy - wektor 3d z wektora 2d\n    normal.y = sdf_rot(p + delta.yxy) - sdf_rot(p); //xyy - wektor 3d\n    normal.z = sdf_rot(p + delta.yyx) - sdf_rot(p); //xyy - wektor 3d\n    normalize (normal);   //zamiast pochodnej w gradiencie - normalizacja\n   \n    /*\n     dotproduct - dlugosc rzutu wektora na drugi (od 0 do 1 - 90  stopni)\n\t normalize wektor w kierunku o dlugosci 1\n   \t float en1 = clamp(dot(ldir, normal) , 0.0, 1.0);                         \n     float en1 = 20.0 * dot(ldir, normal);\n*/\n  float  en1 = 50.0 * clamp(dot(ldir,normal),0.0,0.02);\t\n//    float en1 = 1.0;\n        en1 *= dark ;\n        fragColor = vec4(0.85 * en1 ,0.15 * en1  ,0.62 * en1 , 0.55 * en1 ) ; // drugi 0.35 - rozowy\t\n}\n","name":"Image","description":"","type":"image"}]}