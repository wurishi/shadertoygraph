{"ver":"0.1","info":{"id":"4sKcWy","date":"1523212053","viewed":222,"name":"Galaxy in 2D","username":"jcg_","description":"a galaxy. Now without buffers","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","formulanimations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//modification of this shape https://iquilezles.org/articles/distance\n//Buffer 1\nfloat galaxy(vec2 uv,float t)\n{\n    float r = length(uv);\n    float theta = atan(uv.y,uv.x);\n    float res = .1-(r-1.+.7*sin(t+5.*theta+15.*r));\n    return res;// 1.-.1*length(uv);\n    \n}\n\n\n\nvec4 buffer1(vec2 fragCoord )\n{\n    vec4 fragColor;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.y/iResolution.x;\n    uv -= vec2(.5);\n    uv.x/=AR;\n    uv *= 2.;\n    //now uv is a square centered grid such that y=1 and y=-1 are the top and bottom of the screen\n    //fragColor.x = mod(length(uv),1.);\n    uv=rotate2D(0.2)*uv;\n    \n    vec2 Euv = uv;\n    Euv.y *= 7.;\n    vec2 Guv=uv*10.;\n    Guv.y *= 7.;\n    Guv /= 3.;\n    float res = galaxy(Guv*.2,iTime);\n    float G = clamp(res,0.,1.);\n    float G2 = clamp(pow(res-.1,3.),0.,1.);\n    \n    \n    \n    float E = pow(1.-clamp(length(Euv/3.),0.,1.),2.);\n    float ring=E;\n    float ring2 = E;\n    float core = 1./pow(length(uv),1.5);\n    float galaxyNoise = pNoise(uv*3.,8);\n    \n\tG =G*0.5+ 2.*(G+.2)*galaxyNoise;\n    \n    \n    G2 =cubicPulse(.5,.8,G2);\n    \n    \n    fragColor.rgb = G*vec3(0.3+pNoise(uv*8.,2))*vec3(67., 0., 145.)/255.;\n    fragColor.rgb += (.1+.2*hash12(uv))*G2*vec3(1.,0.3,0.5);\n    fragColor.rgb +=cubicPulse(0.5,0.2,ring)*vec3(.2);\n    fragColor.rgb += cubicPulse(.9,0.05,ring2)*vec3(.5+.15*hash12(uv));\n    fragColor.rgb += vec3(0.5,0,0)*core*galaxyNoise*0.2;\n    fragColor.rgb -= length(uv/10.);\n    fragColor.rgb = clamp(fragColor.rgb,0.,1.);\n    return fragColor;\n    \n}\n\n\n//Buffer 2\n\nfloat getDensity(vec2 uv)\n{\n    uv.y *= 10./3.;\n    return pow(length(uv)/20.,.8);\n}\n\nfloat star(vec2 uv,float rot)\n{\n    \n    uv *= 10.;\n    float p = .2;\n    float r=length(uv);\n    \n    float theta = atan(uv.y,uv.x)+rot;\n    return pow(1.-clamp(r-pow(pow(abs(cos(theta)),p)+pow(abs(sin(theta)),p),-1./p),0.,1.),12.);\n    \n}\n\nvec4 starfield(vec2 uv)\n{\n    vec2 cellPos = floor(uv/.2);\n    vec2 cellOffset = mod(hash22(cellPos)*123.534,.16)-vec2(.08);\n    if(hash12(cellPos) > getDensity(cellPos))\n    {\n    \tfloat s = star((mod(uv,.2)-vec2(.1)+cellOffset)*(0.5+3.*hash12(cellPos)),hash12(cellPos)*2314.);\n    \treturn vec4(s)*(vec4(0.5)+0.5*abs(vec4(cos(hash12(cellPos)),sin(hash12(cellPos)),0,0)));\n    }\n    return vec4(0.);\n}\n\nvec4 buffer2(vec2 fragCoord )\n{\n    \n    vec4 fragColor;\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.y/iResolution.x;\n    uv -= vec2(.5);\n    uv.x/=AR;\n    uv *= 2.;\n    vec2 uv2=mat2(1.,0.,0.,0.3)*rotate2D(0.2)*vec2(uv.x,uv.y);\n    uv=rotate2D(0.2)*uv;\n    fragColor = starfield(uv*2.);\n    fragColor.rgb += vec3(0.5)*star(uv2/3.,0.);\n    \n    return fragColor;\n    \n    \n    \n}\n\n//buffer 3\n\n\n    //https://iquilezles.org/articles/palettes\nvec4 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return vec4(a + b*cos( 6.28318*(c*t+d) ),1);\n}\n\n\nvec4 buffer3(vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec3 a=vec3(0.218, 0.786, 0.448);\n    vec3 b=vec3(0.417, 0.158, 0.081);\n    vec3 c=vec3(1.068, 1.648, 0.528);\n    vec3 d=vec3(0.308, 1.826, 4.425);\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.y/iResolution.x;\n    uv -= vec2(.5);\n    uv.x/=AR;\n    uv *= 3.;\n    uv=rotate2D(-0.2)*uv;\n    float ridgeIntensity = pow(ridged(uv*5.,9)+pow(pNoise(uv*5.,9),3.),5.);\n    float ridgePresence =pow(clamp(pNoise(uv*2.+vec2(10.,4.),8)-0.2,0.,1.),3.);\n    \n    \n    fragColor = ridgeIntensity*ridgePresence*pal(pNoise(uv+vec2(6.3,1.75),8),a,b,c,d);\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor=buffer1(fragCoord)+buffer2(fragCoord)+buffer3(fragCoord);\n    \n    float AR = iResolution.y/iResolution.x;\n    uv -= vec2(.5);\n    uv.x/=AR;\n    uv *= 2.;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n#define PI 3.141592654\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash12(i);\n\tfloat b = hash12(i + vec2(1.0, 0.0));\n\tfloat c = hash12(i + vec2(0.0, 1.0));\n\tfloat d = hash12(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat pNoise(vec2 p, int res){\n    mat2 m = mat2(0.8,-0.6,0.6,0.8);\n\tfloat persistance = .5;\n    float lac = 2.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n    float n = 0.;\n    float normK = 0.;\n\tfor (int i = 0; i<res; i++){\n        normK += amp;\n        n += amp*noise(p*f);\n        p=m*p;\n        f*=lac;\n        amp*=persistance;\n        \n\t}\n\tfloat nf = n/normK;\n\treturn nf;\n}\n\nmat2 rotate2D(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat billow(vec2 p, int res)\n{\t\n    return abs(2.*pNoise(p,res)-1.);\n    \n}\nfloat ridged(vec2 p, int res)\n{\n    return 1.-billow(p,res);\n}\n\n\n\n\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}