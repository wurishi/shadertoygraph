{"ver":"0.1","info":{"id":"tsXcDr","date":"1585138728","viewed":286,"name":"PATH OF LIGHT","username":"Ayoub","description":"An abstract raymarching shader of a black hole absorbing light and terrain.\nIf you want a nice experience put this music in the background www.youtube.com/watch?v=q86g1aop6a8&list=RDq86g1aop6a8&start_radio=1\nand put the shader in full-screen mode.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","space","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//An abstract raymarching shader of a black hole absorbing light and terrain.\n//If you want a nice experience put this music in the background \n//www.youtube.com/watch?v=q86g1aop6a8&list=RDq86g1aop6a8&start_radio=1\n//and put the shader in full-screen mode.\n\n\n\n#define rot_speed  0.03\n#define PI 3.14159265359\n\n#define hole_c vec2(0.0)\n#define hole_d 0.3\n\n\n//RAYMARCHING VARS\n#define MAX_STEPS 200\n#define MAX_DIST 70.0\n#define HIT 0.001\n\n//LIGHT PARAMS\n#define light_p vec3(0,-15.0,-20.0)\n#define light_c vec3(255,160,90)/vec3(255)\n\n//CAMERA SETUP\n#define fov 1.0\n#define cam_speed 0.3\n\n\nfloat light_intensity(){return 0.7*pow(sin(0.4*iTime),2.0);}\n\nvec3 background(vec2 uv)\n{\n    vec3 res;\n    //Distance to blackhole\n    float dist =distance(uv, hole_c);\n    //Normalized distance\n\tfloat test = dist / hole_d;\n    float rsf = smoothstep(test,0.5,0.7);\n    //Create rotation matrix\n    float step = mod(iTime * rot_speed - 2.0*rsf, 2.0*PI);\n    mat2 rot = mat2(vec2(cos(step),sin(step)),vec2(-sin(step),cos(step)));\n    vec2 suvs = uv - hole_c;\n    suvs*= rot;\n    \n\tres = vec3(texture(iChannel1, suvs).x);\n    \n    if(test< 1.0 && test > 0.95) //balck hole border\n    {\n        res += exp(light_c * test);\n    }\n    else if(test < 0.95) //black hole inner\n    {\n        res = smoothstep(0.13*test,0.0,0.1)*light_c;\n    }\n    else // glow\n    {\n        res+=exp(1.5+light_intensity()-test)*light_c; \n    }\n       \n    return res;\n}\n\nfloat terrainSDF(vec3 p)\n{\n    float sdetails =0.5*(texture(iChannel0, (0.1*p.xz) + vec2(0.4)).x);\n    float bdetails =6.0*(texture(iChannel0, (0.01*p.xz) + vec2(0.8)).x);\n    float curve = p.x / 8.0;\n    return (p.y +2.0  - pow(abs(curve),1.8) + sdetails + bdetails);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 offset = vec3(0.01,.0,.0);\n\tfloat ox = terrainSDF(p + offset.xyy) - terrainSDF(p - offset.xyy) ;\n\tfloat oy = terrainSDF(p + offset.yxy) - terrainSDF(p - offset.yxy) ;\n\tfloat oz = terrainSDF(p + offset.yyx) - terrainSDF(p - offset.yyx) ;\n\n\treturn normalize(vec3(ox, oy, oz)) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       \t\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //FINAL COLOR\n    vec3 color = background(uv);\n    \n    //RAYMARCHING ALGORITHM\n   \tfloat td = 0.0;\n    float d = 0.0;\n    \n    //Camera setup\n    float za = iTime*cam_speed; //animated z coordinate of the camera\n    vec3 p = vec3(uv, za);\n    vec3 co = vec3(0.0,-0.1 ,za-fov);\n    \n    //use this if you want the cam to be close to terrain and avoid colliding with it\n    //checking how far the camera is to the terrain\n    /*d = terrainSDF(co + vec3(0,-2.0,1.0));\n    if(d <= HIT)\n    {\n        p-=vec3(0,d,0);\n        co-=vec3(0,d,0);\n    }*/\n    \n    vec3 dir = normalize(p - co);\n    \n    //Raymarching loop\n    for(int i = 0; i <= MAX_STEPS; i++)\n    {\n        d = terrainSDF(p);\n        td+=d;\n        p += dir*d;\n        if(td >= MAX_DIST)\n        {\n            break;\n        }\n\n        if(d < HIT)\n        {\n            vec3 n = getNormal(p);\n            //LIGHT\n            float diffuse = 6.0*dot((normalize(p - light_p)), n) ;\n            color = light_intensity()  + diffuse * light_c;\n            color*= texture(iChannel1, 0.3*p.xz).xyz;\n            break;\n        }\n    }\n    //POST Processing the whole image\n    color*=light_c;\n    color+=vec3(0.07,0,0);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}