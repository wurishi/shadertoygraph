{"ver":"0.1","info":{"id":"ltVBWV","date":"1544144422","viewed":228,"name":"bouncy","username":"bitnenfer","description":"very boring scene but I wanted to try out multipass shaders for saving state","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2d","particles","balls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define coord(n) (n.xy) / iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 texCoord = vec2(fragCoord.x, 1.0 - fragCoord.y) + vec2(0.0, iResolution.y);\n    vec2 uv = coord(texCoord).xy;\n    vec3 color = vec3(sqrt(uv.y * 7.0)) * vec3(0.23, 0.23, 0.3);\n    \n    {\n        ivec2 mempos = ivec2(fragCoord);\n        for (int i = 0; i < MAX_BALLS * 2; i += 2)\n        {\n            ivec2 ballPosTexCoord = ivec2(i, 0);\n            vec4 texel = texelFetch(iChannel0, ballPosTexCoord, 0);\n            vec2 ballPos = coord(texel);\n            if (length(ballPos.xy - uv) < texel.z / length(iResolution))\n            {\n                float factor = max(0.0, pow(length(ballPos.xy - uv + vec2(0.02, -0.02)) / (texel.z / length(iResolution)), 1.0));\n                color = mix(vec3(0.9, 0.9, 0), normalize(vec3(texel.xyz)) * 0.4, sqrt(factor));\n                if (ballPosTexCoord == ivec2(MAX_BALLS * 2 - 2, 0))\n                {\n                    color = vec3(1,0.7,1) * max(0.0, (1.0 - factor));\n                }\n                if (texel.z > 26.0)\n                {\n                    float spec = pow(length(ballPos.xy - uv + vec2(0.02, -0.02)) / (texel.z / length(iResolution)), 6.0);\n                    color += vec3(0.05) * max(0.0, spec);\n                }\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 kPosTexCoord = ivec2(0, 0);\nconst ivec2 kVelTexCoord = ivec2(1, 0);\nconst float kMaxVel = 4.0;\nconst float kElasticity = 1.0;\nconst float kFloorFriction = 0.95;\nconst vec2 kAcceleration = vec2(0.0, 0.4);\n#define MAX_BALLS 200","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hash(vec3 p)\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return fract(sin(p)*43758.5453123);\n}\n\nvoid updateState(out vec4 simOutput, in ivec2 mempos, int indexOffset)\n{\n    for (int i = indexOffset; i < MAX_BALLS * 2; i += 2)\n    {\n        ivec2 ballPosTexCoord = ivec2(i, 0);\n        ivec2 ballVelTexCoord = ivec2(i + 1, 0);\n        vec4 ballPos = texelFetch(iChannel0, ballPosTexCoord, 0);\n        vec4 ballVel = texelFetch(iChannel0, ballVelTexCoord, 0);\n        float halfRad = ballPos.z * 0.5;\n        \n        if (ballPosTexCoord == mempos)\n        {\n            ballPos.xy += ballVel.xy;\n            if (ballPos.y > iResolution.y - halfRad)\n            {\n                ballPos.y = iResolution.y - halfRad;\n            }\n            else if (ballPos.y < halfRad)\n            {\n                ballPos.y = halfRad;\n            }\n            \n            if (ballPos.x < halfRad)\n            {\n                ballPos.x = halfRad;\n            }\n            else if (ballPos.x > iResolution.x - halfRad)\n            {\n                ballPos.x = iResolution.x - halfRad;\n            }\n            \n            simOutput.xy = ballPos.xy;\n            simOutput.z = ballPos.z;\n            break;\n        }\n        else if (ballVelTexCoord == mempos)\n        {\n            if (ballPos.y + ballVel.y > iResolution.y - halfRad)\n            {\n                ballVel.y *= -kElasticity;\n                ballVel.x *= kFloorFriction;\n            }\n            else if (ballPos.y + ballVel.y < halfRad)\n            {\n                ballVel.y *= -kElasticity;\n            }\n            \n            if (ballPos.x + ballVel.x < halfRad)\n            {\n                ballVel.x *= -kElasticity;\n            }\n            else if (ballPos.x + ballVel.x > iResolution.x - halfRad)\n            {\n                ballVel.x *= -kElasticity;\n            }\n            simOutput.xy = ballVel.xy + kAcceleration;\n            break;\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    #if defined(NOT_SHADERTOY)\n    vec4 mouse = iMouse;\n    #else\n    vec4 mouse = vec4(iMouse.x, (1.0-iMouse.y + iResolution.y), iMouse.z, (1.0-iMouse.w + iResolution.y));\n    #endif\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 simOutput = vec4(0.0, 0.0, 0.0, 1.0);\n    ivec2 mempos = ivec2(fragCoord);\n    \n    // Initial State\n    if (iFrame == 0 || iFrame % 1000 == 0)\n    {\n        for (int i = 0; i < MAX_BALLS * 2; i += 2)\n        {\n            ivec2 ballPosTexCoord = ivec2(i, 0);\n            ivec2 ballVelTexCoord = ivec2(i + 1, 0);\n            vec3 rand1 = hash(vec3(fragCoord, iTime));\n            vec3 rand2 = rand1 * 2.0 - 1.0;\n            \n            if (ballPosTexCoord == mempos)\n            {\n                vec2 pos = iResolution.xy * rand1.xy;\n                simOutput.xy = pos;\n                if (i == MAX_BALLS * 2 - 2)\n                {\n                    simOutput.z = 50.0;\n                }\n                else\n                {\n                    simOutput.z = 10.0 + 30.0 * rand1.z;\n                }\n                break;\n            }\n            else if (ballVelTexCoord == mempos)\n            {\n                vec2 vel = vec2(kMaxVel) * rand2.xy;\n                simOutput.xy = vel;\n                break;\n            }\n        }\n    }\n    // If the mouse is pressed we position the first ball\n    else if (mouse.z > 0.0)\n    {\n        if (ivec2(MAX_BALLS * 2 - 2, 0) == mempos)\n        {\n            vec2 initBallPos = mouse.zw;\n            vec4 ballPos = texelFetch(iChannel0, ivec2(MAX_BALLS * 2 - 2, 0), 0);\n            simOutput.xy = initBallPos;\n            simOutput.z = ballPos.z;\n        }\n        else if (ivec2(MAX_BALLS * 2 - 1, 0) == mempos)\n        {\n            float r = atan(mouse.w - mouse.y, mouse.z - mouse.x);\n            float speedFactor = (distance(mouse.xy, mouse.zw) / 200.0) * (kMaxVel * 3.0);\n            vec2 initBallVel = vec2(speedFactor * cos(r), speedFactor * sin(r));\n            simOutput.xy = initBallVel;            \n        }\n        else\n        {\n            updateState(simOutput, mempos, 2);\n        }\n    }\n    // Update state\n    else\n    {\n        updateState(simOutput, mempos, 0);\n    }\n    \n    fragColor = simOutput;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}