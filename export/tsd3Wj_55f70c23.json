{"ver":"0.1","info":{"id":"tsd3Wj","date":"1569358280","viewed":264,"name":"Ray Tracing Spheres","username":"StarikTenger","description":"Use mouse to move camera","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141693\n\nstruct Cam {\n  \tvec3 pos;\n\tvec2 dir;\n};\n\nstruct Sphere {\n\tvec3 pos;\n    vec3 col;\n    \n    float r;\n    float mirrorK;\n    bool chess;\n};\n    \nstruct Light{\n\tvec3 pos;\n    vec3 col;\n};\n    \nstruct System {\n    Cam cam;\n\tSphere spheres[10];\n    Light lights[5];\n};\n    \nstruct Data {\n\tvec3 pos;\n    vec3 dir;\n};\n\nfloat multiply(vec3 a, vec3 b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec2 rotate(vec2 v, float a){\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\nvec3 rotate(vec3 v, vec2 ang){\n    \n    vec2 p = rotate(vec2(v.x, v.z), ang.y);\n\tv = vec3(p.x, v.y, p.y);\n    \n    v = vec3(rotate(vec2(v.x, v.y), ang.x), v.z);\n\n    return v;\n}\n\nbool chess(vec3 pos){\n    float k = 10.;\n\treturn (sign(sin(pos.x*k)) == sign(sin(pos.y*k)));\n}\n\nbool sphereCollision(vec3 pos, vec3 dir, Sphere sp){\n\tvec3 d = dir / length(dir);\n    vec3 p = sp.pos - pos;\n    \n   \tfloat k1 = multiply(d, d);\n    float k2 = -2.0 * multiply(d, p);\n    float k3 = multiply(p, p) - sp.r*sp.r;\n    \n    float t1 = ( -k2 + sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    float t2 = ( -k2 - sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    \n    vec3 c1 = d * t1 + pos;\n    vec3 c2 = d * t2 + pos;\n    \n    if(k2 * k2 - 4.0 * k1 * k3 > 0.0 && (t1 > 0. || t2 > 0.) ){\n    \treturn true;   \n    }\n    return false;\n    //return mat2x3(c1, c2);\n}\n\nvec3 sphereCollisionC(vec3 pos, vec3 dir, Sphere sp){\n\tvec3 d = dir / length(dir);\n    vec3 p = sp.pos - pos;\n    \n   \tfloat k1 = multiply(d, d);\n    float k2 = -2.0 * multiply(d, p);\n    float k3 = multiply(p, p) - sp.r*sp.r;\n    \n    float t1 = ( -k2 + sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    float t2 = ( -k2 - sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    \n    vec3 c1 = d * t1 + pos;\n    vec3 c2 = d * t2 + pos;\n    \n    if(k2 * k2 - 4.0 * k1 * k3 > 0.0 || k2 * k2 - 4.0 * k1 * k3 > 0.0){\n    \t//return true;   \n    }\n    \n    if(t1 < t2)\n    \treturn c1;\n    else\n        return c2;\n}\nvec3 rayTrace(System sys, vec3 pos, vec3 dir){\n    vec3 colF = vec3(0, 0, 0);\n    float refK = 1.0;\n    for(int k=0; k<5; k++) {\n        dir = dir / length(dir);\n        vec3 nearestCollision = vec3(100000000., 0., 0.);\n        int nearestI = -1;\n        // Finding nearest sphere collision\n        for(int i=0; i<sys.spheres.length(); i++){\n            if(sphereCollision(pos, dir, sys.spheres[i])){\n                vec3 collision = sphereCollisionC(pos, dir, sys.spheres[i]);\n                if(distance(pos, collision) < distance(pos, nearestCollision)){\n                    nearestCollision = collision;\n                    nearestI = i;\n                }\n            }            \n        }\n        if(nearestI == -1) // Return if no collision detected\n            break;\n\n        // Continue from collision point\n        vec3 v = nearestCollision;\n        vec3 col = sys.spheres[nearestI].col * 0.05;\n        vec3 n = (v - sys.spheres[nearestI].pos ) / length(v - sys.spheres[nearestI].pos); // surface normal vector\n\n        // Calculating Lights\n        for(int i = 0; i<sys.lights.length(); i++){\n\n            vec3 d = (sys.lights[i].pos - v) / length(v - sys.lights[i].pos ); // direction to Light\n            bool spColl = false;\n            \n            for(int j=0; j<sys.spheres.length(); j++){\n                if (j == nearestI)\n                    continue;\n                if(sphereCollision(v + d*0.01, d, sys.spheres[j]) && \n                   distance(sphereCollisionC(v + d*0.01, d, sys.spheres[j]), v) < distance(sys.lights[i].pos, v))\n                    spColl = true;\n            }\n      \n            if(!spColl && (!sys.spheres[nearestI].chess || chess(v)))\n                col += max( multiply(n, d) * sys.lights[i].col * sys.spheres[nearestI].col, vec3(0., 0., 0.)) / pow(distance(sys.lights[i].pos, v), 2.0);\n        }\n        vec3 ray = (pos - v) / length(pos- v);\n        vec3 ref = 2.0 * n * multiply(n, ray) - ray;\n    \tcolF +=  col*refK;\n        pos = v+n*0.01;\n        dir = ref;\n        refK *= sys.spheres[nearestI].mirrorK;\n    }\n        \n    //col += rayTrace1(sys, v+n*0.01, ref) * sys.spheres[nearestI].mirrorK;\n    return colF;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    System sys;\n    \n    //// Camera\n    sys.cam.dir = vec2(2.*PI*(iMouse.x/iResolution.x - 0.5), PI/2.0*(iMouse.y/iResolution.y - 1.0));\n    sys.cam.pos = vec3(0,0,0.1) -  rotate(vec3(2.3, 0, 0), sys.cam.dir);\n    \n    //// Objects  \n    // Spheres\n    sys.spheres[0] = Sphere(vec3(0, 0, -1000.1), vec3(1., 1., 1.)*1., 1000., 0.1, true);\n    sys.spheres[5] = Sphere(vec3(0, 0, 1001.1), vec3(1., 1., 1.)*1., 1000., 0.0, false);\n    sys.spheres[1] = Sphere(vec3(0,0,0), vec3(1.0, 0.0, 0.0)*1.0, 0.20, 0.5, false);\n    sys.spheres[2] = Sphere(vec3(0,0,0), vec3(0.0, 1.0, 0.0)*1.0, 0.10, 0.5, false);\n    sys.spheres[3] = Sphere(vec3(0,0,0), vec3(0.0, 0.0, 1.0)*1.0, 0.15, 0.5, false);\n    sys.spheres[4] = Sphere(vec3(0,0,0), vec3(1.0, 1.0, 0.0)*1.0, 0.05, 0.5, false);\n    // Lights\n    sys.lights[0] = Light(rotate(vec3(0.8, 0.0, 1.0), vec2(iTime*0.11 + 0.0 * PI/3.0, 0)),  0.2*vec3(1.0, 1.0, 1.0));\n    sys.lights[1] = Light(rotate(vec3(0.8, 0.0, 1.0), vec2(iTime*0.11 + 2.0 * PI/3.0, 0)),  0.2*vec3(1.0, 1.0, 1.0));\n    sys.lights[2] = Light(rotate(vec3(0.8, 0.0, 1.0), vec2(iTime*0.11 + 4.0 * PI/3.0, 0)),  0.2*vec3(1.0, 1.0, 1.0));\n        \n    \n    sys.spheres[1].pos = vec3(0.3, 0.0, 0.2) + vec3(0, sin(iTime)*0.06, 0) ;\n    sys.spheres[2].pos = vec3(0.0, 0.3, 0.1)+ vec3(0, 0, sin(iTime*0.7)*0.1) ; ;\n    sys.spheres[3].pos = vec3(-0.3, 0.0, 0.1) + vec3(cos(iTime*0.85)*0.03, 0, 0) ;;\n    sys.spheres[4].pos = vec3(0.0, -0.4, 0.2) + vec3(0, 0, -sin(iTime*1.1)*0.1) ;;\n\n    \n    //// Rendering\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);    \n\n    // Time varying pixel color\n    //vec3 n = sys.cam.dir;\n    \n    \n    vec3 col = rayTrace(sys, sys.cam.pos, rotate(vec3(1.4, uv.x, uv.y * iResolution.y / iResolution.x), sys.cam.dir));\n\t    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}