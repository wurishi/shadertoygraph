{"ver":"0.1","info":{"id":"lsXBWH","date":"1495893542","viewed":428,"name":"Distressed Strands","username":"TinyTexel","description":"enjoy","likes":9,"published":1,"flags":40,"usePreview":0,"tags":["aaahhh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Distressed Strands\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat Hash(float v)\n{\n    return fract(sin(v) * 43758.5453);\n}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 uv0)\n{\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    //float r = 0.0;\n    //vec2 r2 = vec2(0.0);\n    //float count = 128.0;\n    //for(float i = 0.0; i < count; ++i)\n    //{\n    // r2.x += sin((dot(uv0, AngToVec(Pi / count * (i + (Hash(i*17.52179)-0.5))))*0.25 + Hash(i)*2.0) * Pi * 1.0);\n    // r2.y += cos((dot(uv0, AngToVec(Pi / count * (i + (Hash(i*17.52179)-0.5))))*0.25 + Hash(i)*2.0) * Pi * 1.0);\n    //}\n    //\n    //r2 /= count;\n    //\n    //r = col.r;\n    \n    float r = Pow2(col.r * 32.0);\n    \n    //r = pow(r, 4.0);\n    //r = max(r2.x*r2.x,r2.y*r2.y) * 4.0;\n    //r = Pow2(Pow2(r2.x)*8.0*2.0-01.0);\n    //r = r > 1.0 ? 1.0 : 0.0;\n    col = vec3(r);\n    col = mix(vec3(0.1, 1.0, 0.1)*r*r, vec3(1.0), r);\n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Distressed Strands\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n\n/*\n\ncamera controls via mouse + shift key\nlight controls via WASD\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat Hash(float v)\n{\n    return fract(sin(v) * 43758.5453);\n}\n\nfloat Hash(vec2 v)\n{\n\treturn Hash(v.y + v.x * 12.9898);\n}\n\nfloat Hash(vec3 v)\n{\n\treturn Hash(v.y + v.x * 12.9898 + v.z * 33.7311);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n    float lastTime  = ReadVar (4, 0);\n    \n    vec3 col = vec3(0.0);\n\n    float t = frameAccu * 1.36772;\n    \n    float r = 0.0;\n    float count = 64.0;\n    for(float i = 0.0; i < count; ++i)\n    {\n        vec2 h = Hash22I(vec2(i, frameAccu));\n        \n        vec2 vec = AngToVec(Pi / count * (i + (h.x-0.5)));\n        float x = dot(uv0, vec);\n        \n        r += sin((x + h.y*2.0) * Pi * 1.0);\n    }\n    \n    r /= count;\n    \n    //r *= 2.0;\n    \n    col = vec3(r);\n    \n\tvec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;  \n    //col = mix(colLast, col, 1.0 / (frameAccu + 1.0)); \n    float dt = Time - lastTime;\n    float a = dt / (dt + 2.0);\n    a = 0.02;\n\tcol = mix(colLast, col, a); \n    \n    outCol = vec4(col, 1.0);\n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n        WriteVar (Time, 4, 0);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Distressed Strands\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n\nfloat sAbs1(float x, float k) { return sqrt(x * x + k); }\n\nfloat sMin(float a, float b, float k) { return (a + b - sAbs1(a - b, k)) * 0.5; }\n\nfloat sMax(float a, float b, float k) { return -sMin(-a, -b, k); }\n\nfloat sClamp(float x, float a, float b, float k) { return sMin(b, sMax(a, x, k), k); }\n\nfloat Mod(float x, float m) { return fract(x / m) * m; }\n\nfloat snd(float time, float frq)\n{\n    return sClamp(pow(sin(6.2831*frq*fract(time)*0.99), 64.0), -0.25, 0.55, 0.04);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    //time = iTime;\n    //sclamp1[Power[Sin[440 *0.43*2 Pi t], 111], -0.25, 0.6, 1]\n   // float snd\n    vec2 r = vec2(snd(time * 0.23, 440.0), snd(time * 0.227, 440.0));// * vec2(0.25);\n    \n    r = mix(r, vec2(snd(time * 0.23, 220.0), snd(time * 0.227, 220.0)), 1.0);\n    r = mix(r, vec2(snd(time * 0.226, 110.0), snd(time * 0.232, 110.0)), 0.6);\n   // r = mix(r, vec2(snd(time * 0.22, 330.0), snd(time * 0.212, 330.0)), 0.15);\n\n\n    //r += vec2(snd(time * 0.23, 110.0), snd(time * 0.227, 110.0)) * vec2(0.4);\n    \n    return r;\n    //return vec2( sClamp(pow(sin(6.2831*440.0*time * 0.23), 241.0), -0.25, 0.4, 0.01) * 0.08 );\n   // return vec2( sClamp(pow(sin(6.2831*440.0*time * 0.01), 241.0), -0.25, 0.4, 0.1) * 2.0 );\n   // return vec2( sClamp(pow(sin(6.2831*440.0*time * 0.23), 111.0), -0.25, 0.25, 0.01) * 0.2 );\n\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}","name":"Sound","description":"","type":"sound"}]}