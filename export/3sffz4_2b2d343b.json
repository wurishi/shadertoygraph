{"ver":"0.1","info":{"id":"3sffz4","date":"1587740286","viewed":209,"name":"Digital beetroot.","username":"Logos","description":"Digital beetroot swiching between natural and alert state :D","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","sdf","orbit","digital","quaternion","trap","beetroot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Åšmietana (Logos) - 24.04.2020\n// Dobrzyca, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n\n//--- some globals ---//\n\nvec3 orbitTrap = vec3(10000.0);\n\n\n//--- camera stuff ---//\n\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\n//--- scene description ---//\n\nvec2 rotate(vec2 v, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    \n\treturn vec2(ca*v.x + sa*v.y, -sa*v.x + ca*v.y);\n}\n\n\nfloat spring_cyl(vec3 p)\n{\n    bool b = mod(iTime, 5.0) > 2.5;\n    \n\tp.xy  = rotate(b ? p.xy : p.yz, (1.5 + 0.05*sin(17.0*iTime - 2.1*p.z)) * p.z);\n\tp.xy -= vec2(-0.63564, -0.75968);\n\n\treturn max(abs(p.z) - 10.0, length(p.xy) - 0.14414);\n}\n\n\nfloat c3(vec3 p)\n{\n\treturn min(spring_cyl(p), spring_cyl(p.zyx));\n}\n\n\nfloat distanceToScene(vec3 pos)\n{\n\tfloat d = 10000.0;\n\tvec4  p = vec4(pos, 0.0);\n\tvec4 dp = vec4(1.0, 0.0, 0.0, 0.0);\n\tvec4  C = vec4(0.0303, -0.0303, 0.01516, 0.21);\n    \n\tfor (int i = 0; i < 6; i++)\n    {\n\t\tdp = 2.0*vec4(p.x*dp.x - dot(p.yzw, dp.yzw), p.x*dp.yzw + dp.x*p.yzw + cross(p.yzw, dp.yzw));\n\t\tp = vec4(p.x*p.x - dot(p.yzw, p.yzw), vec3(2.0*p.x*p.yzw)) + C;\n\n\t\tfloat r = c3(p.yxz);\n\t\td = min(d, 0.5 * r / length(dp));\n\n        float p2 = dot(p, p);\n\t\torbitTrap = min(orbitTrap, abs(p.zxy));\n\t\tif (p2 > 14.286) break;\n\t}\n\n\treturn 0.45*min(d, length(pos) - 0.9771);\n}\n\n\n//--- cheap normal computing ---//\n\nvec3 computeSurfaceNormal(vec3 p)\n{\n    float d = distanceToScene(p);\n    \n    return normalize(vec3(\n        distanceToScene(p + vec3(0.001, 0.0, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.001, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.0, 0.001)) - d));\n}\n\n\n//--- output color ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- camera setup ---//\n    \n    float rtime = 0.32165*iTime;\n    \n    vec2 p   = (-iResolution.xy + 2.0*fragCoord - 1.0) / iResolution.y;\n \tvec3 pos = vec3(25.0*cos(rtime), 25.0*sin(rtime), 10.0);\n    vec3 tar = vec3(0.0);\n    vec3 dir = setCamera(pos, tar) * normalize(vec3(p.xy, 11.6));  \n    \n    \n    //--- distance to nearest object in the scene ---//\n    \n\tfloat t = 0.0;\n\tfor(int i = 0; i < 256; i++)\n    {\n\t\tfloat d = distanceToScene(pos + t*dir);\n\t\tif(d < 0.0023) break;\n        \n\t\tt += d;\n\n        \n\t\t//--- early skip of background pixels ---//\n    \n        if (t > 35.0)\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n\t}\n    \n    \n    //--- output color depends on few things ---//\n    \n    //bool   b = mod(iTime, 4.0) > 2.0;\n    vec3  sn = computeSurfaceNormal(pos + t*dir);\t\t\t// surface normal\n    float dc = clamp(dot(sn, normalize(pos)), 0.0, 1.0);\t// diffuse component\n    float sr = pow(dc, 56.2);\t\t\t\t\t\t\t\t// specular reflection\n    \n\tfragColor     = 0.4*orbitTrap.xyzz;\n    fragColor    *= 0.75 + 0.5*dc;\n    fragColor    += sr;\n    \n}","name":"Image","description":"","type":"image"}]}