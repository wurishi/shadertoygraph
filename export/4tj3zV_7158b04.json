{"ver":"0.1","info":{"id":"4tj3zV","date":"1430501074","viewed":541,"name":"Starwars ship thing.","username":"alleycatsphinx","description":"Stuck in Shenzhen with too much free time, so I did a bit of modeling.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["instructionlimit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//ported from http://glslsandbox.com/e#24863.4\n#define resolution \t\t\t\tiResolution.xy\n#define time \t\t\t\t\tiTime\n#define mouse \t\t\t\t\tiMouse.xy\n\n#define ASPECT               \tresolution.x/resolution.y\n#define PHI                  \t.0001\n#define EPSILON                 .00002\n#define FOV                     2.\n#define FARPLANE                12.\n#define ITERATIONS              128\n\n#define PI                  \t(4.*atan(1.))       \n#define TAU                 \t(8.*atan(1.))   \n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tvec2 material_range;\n\tfloat steps;\n}; \n\nray         view(in vec2 uv);   \nray         emit(ray r);\nvec2        map(in vec3 position);\nvec3        derive(in vec3 p);\n\nfloat       sphere(vec3 position, float radius);\nfloat       cube(vec3 position, vec3 scale);\nfloat       torus( vec3 p, vec2 t );\nfloat       cylinder(vec3 p, float l, float r);\nfloat       cone(vec3 p, float l, vec2 r);\nfloat       icosahedral(vec3 p, float e, float r);\nfloat       partition_noise(vec2 uv);\nfloat       crossf(float x);\n\nfloat       hash(float x);\nvec2        hash(vec2 v);\n\nmat2        rmat(in float r);\n\nvec2        format_to_screen(vec2 uv);\n\n//overly complex viewing system for modeling - doesnt work on shadertoy due to shader inputs\n#define SCREEN_LEFT gl_FragCoord.x < resolution.x * .5\n#define SCREEN_BOTTOM   gl_FragCoord.y < resolution.y * .5\n#define MOUSE_LEFT  mouse.x < 20.5\n#define MOUSE_BOTTOM mouse.y < 20.5\n#define VIEW_SWITCH mouse.x > 20.1   \n#define PANEL_LEFT  (VIEW_SWITCH ? MOUSE_LEFT : SCREEN_LEFT)\n#define PANEL_BOTTOM    (VIEW_SWITCH ? MOUSE_BOTTOM : SCREEN_BOTTOM)\n#define UV      VIEW_SWITCH ? (gl_FragCoord.xy/resolution.xy) : fract(2.*(gl_FragCoord.xy/resolution.xy))\n#define TOP         vec3(0., 7., .49)\n#define TOP_V       vec3(0., 0., .5001)\n#define BOTTOM      vec3(0., -7., .49)\n#define BOTTOM_V    vec3(0., 0., .5001)\n#define SIDE        vec3(4.5, 0., 0.5)\n#define SIDE_V      vec3(0., 0., 0.5)\n#define BACK        vec3(0., 0., 6.)\n#define BACK_V      vec3(0., 0., 0.001)\n#define QUARTER     vec3(-2.5, 2.5, -2.75)\n#define ORIGIN_V    vec3(0., 0., 0.001)\n#define TURRET\t    vec3(1.5, 0.4, 2.5)\n#define TURRET_V    vec3(0., 0., 0.5)\n\n\n#define VIEWPOSITION    (PANEL_LEFT ? PANEL_BOTTOM ? TOP   : BACK   : PANEL_BOTTOM ? SIDE   : QUARTER)\n#define VIEWTARGET      (PANEL_LEFT ? PANEL_BOTTOM ? TOP_V : BACK_V : PANEL_BOTTOM ? SIDE_V : ORIGIN_V)\n\n//#define VIEWPOSITION      SIDE + vec3(0., 0., 2.)\n//#define VIEWTARGET        SIDE_V  + vec3(0., 0., -2.)\n//#define VIEWPOSITION      TURRET\n//#define VIEWTARGET        TURRET_V\n//#define VIEWPOSITION      BOTTOM\n//#define VIEWTARGET        BOTTOM_V\n\nvec2 map(in vec3 position)\n{    \n\t//panel aware view rotations\n\tif(true){\n\t\tif(PANEL_BOTTOM && PANEL_LEFT)\n\t\t{\n\t\t\tposition.zy *= rmat(mouse.x*12.56);\n\t\t}\n\t\telse\n\t\t{ \n\t\t\tposition.xz *= rmat(mouse.x*12.56);\n\t\t}\n\t}\n\tposition.z                  \t+= 1.5;\n\t\n\tfloat ship                  \t= FARPLANE;\n\t\n\n\t//main hulls\n\tvec3 hull_position          \t= position;\n\thull_position.x             \t= max(abs(position.x),.04);\n\t\n\t//laterial insets \n\thull_position.x             \t*= hull_position.z > .1     \n\t&& hull_position.z < 1.1 \n\t? 1.05 : 1.;\n\n\thull_position.x             \t*= hull_position.z > 1.85   \n\t&& hull_position.z < 2. \n\t? 1.025 : 1.;\n\t\n\thull_position.y             \t= abs(hull_position.y)*.75+position.z*.001;\n\t\n\t\n\tvec3 hull_scale             \t= vec3(1.);\n\thull_scale.x                \t= position.z*.3+.45, \n\thull_scale.y                \t= position.z*.05+.085;\n\thull_scale.y               \t+= -abs(max(abs(position.x*.87),position.z*.025)*.187);\n\thull_scale.z               \t= min(hull_position.y+4., 4.);\n\thull_scale.z               \t+= abs(position.y);\n\t\n\t\n\t//inner hull\n\tvec3 hull_inner_scale           = hull_scale;\n\thull_inner_scale.x          \t+= abs(position.x)*.03-.01-position.z * .0005;\n\thull_inner_scale.y          \t= position.z < 4.1 ? .05 : hull_inner_scale.y;\n\thull_inner_scale.z          \t+= abs(position.x)*.012 + .15;\n\t\n\tvec3 hull_inner_position        = hull_position;    \n\thull_inner_position.y           = abs(position.y)<abs(hull_position.y) ? position.y : hull_position.y; //delete?\n\n\tfloat hull_inner        \t= cube(hull_inner_position, hull_inner_scale);\n\t\n\t\n\tvec3 hull_outer_scale           = hull_scale * vec3(1.05,1.05, 1.031);\n\thull_outer_scale.y         \t+= position.y > .5 ? -position.z * .025 : 0.;\n\t\n\thull_position.y             \t= abs(hull_position.y-.05+position.z*.0025);\n\t\n\tfloat hull_outer            \t= cube(hull_position, hull_outer_scale);\n\n\thull_outer                  \t= max(hull_outer, -hull_inner);\n\tship                        \t= min(hull_outer, ship);    \n\n\tbool inner_hull             \t= hull_inner < hull_outer;\n\tbool outer_hull             \t= hull_inner > hull_outer;\n\t\n\tbool engines            \t= false;\n\tbool bridge_tower\t        = false;\n\tbool aft \t\t\t= false;\n\tbool domes \t\t\t= false;\n\t\n\t//hull details\n\tfloat forward_partitions        = partition_noise(floor(position.z*8.)/8.+position.yx*8.);\n\tfloat deck_partitions\t\t= partition_noise(floor(position.x*8.)/8.+position.yz*8.);\n\t\n\tfloat hull_plating          \t= partition_noise\n\t\t\t\t\t(\n\t\t\t\t\tfloor(position.xz*31.)/31.\n\t\t\t\t\t+floor(position.xz*63.)/63.\n\t\t\t\t\t+position.xz*2.5-.41\n\t\t\t\t\t+abs(position.z)*.2\n\t\t\t\t\t);\n\t\n\tfloat hull_panels       \t= max(hull_plating, .85) * 4.; \n\tfloat forward_panels       \t= max(forward_partitions, .85);\n\t\n\tfloat z_floor_noise        \t= hash\n\t\t\t\t\t(\n\t\t\t\t\tfloor(position.z*13.+position.z)/8.\n\t\t\t\t\t+floor(position.z*5.)/3.\n\t\t\t\t\t);\n\t\n\tz_floor_noise         \t\t= floor(z_floor_noise*8.)/8.;\n\t\n\tfloat outboard_partitions\t= partition_noise\n\t\t\t\t\t(\n\t\t\t\t\tfloor(position.x*16.)/8. +\n\t\t\t\t\tz_floor_noise +\n\t\t\t\t\tposition.yz * 8.*\n\t\t\t\t\tvec2(3.5, 1.2*(1.+hull_plating*.05))\n\t\t\t\t\t);\n\n\t\n\t//aft hull && engines\n\tif(inner_hull && hull_position.z > 4.0 && hull_position.y < .375)\n\t{   \n\t\t//aft structures\n\t\taft                 \t\t= true;\n\t\t\n\t\thull_inner\t\t\t= max(hull_inner-.05, -hull_outer);\n\t\tvec2 absxy\t\t\t= abs(position.xy*1.1);\n\t\tbool columns\t\t\t= mod(absxy.x-.25, .85) > .3625;\n\t\tbool spars\t\t\t= mod(absxy.x+absxy.y, .25) > .025 ^^ mod(absxy.x-absxy.y, .25) > .025;\n\n\t\thull_inner_scale.z\t\t+= columns || spars ? .00 : -.0125;     \n\n\t\thull_inner\t\t\t= cube(hull_inner_position, hull_inner_scale);\n\t\thull_inner\t\t\t+= columns && !spars ? -.05 : -0.;\n\t\thull_inner\t\t\t+= !columns && !spars ? fract((absxy.x-absxy.y)*16.+.9)*0.01 : 0.;\n\t\thull_inner\t\t\t+= spars ? 0.01 : 0.05;\n\t\thull_inner\t\t\t+= !spars && columns ? forward_panels*.005 : 0.;\n\t\thull_outer\t\t\t= max(hull_outer,-hull_inner);\n\n\t\t//main engines\n\t\tvec3 engine_position    \t= position.yzx;\n\t\tengine_position.z       \t= abs(engine_position.z) < .4 ? engine_position.z : abs(engine_position.z)-.8;\n\t\n\t\tengine_position         \t+= -vec3(0.,4.1,0.);\n\t\tfloat engine_angle      \t= atan(engine_position.x, engine_position.z)/TAU;\n\t\t\t\n\t\tfloat engine_contour    \t= clamp(engine_position.y*.5,.05,.15);\n\t\tengine_contour          \t= engine_position.y > .35 ? .2 : engine_contour;\n\t\t\t\n\t\tvec2 radii          \t\t= vec2(engine_contour, .25);\n\t\tfloat depth         \t\t= .21;\n\t\tfloat engine           \t \t= cone(engine_position, depth, radii);\n\t\n\t\tengine              \t\t+= fract(engine_position.y*8.)>.2 ? .01 : 0.;\n\t\tengine              \t\t+= fract(engine_angle*16.)>.1 ? .01 : 0.;\n\t\tengine_position.y      \t \t+= -.125;\n\t\tfloat engine_mask      \t \t= cone(engine_position, depth, radii);\n\t\tengine_mask            \t \t+= fract(engine_position.y*8.)>.2 ? .01 : 0.;\n\t\tengine              \t\t= max(engine, -engine_mask);    \n\t\t\n\t\t//booster engines\n\t\tvec3 booster_position   \t= position.yzx;\n\t\tbooster_position.x      \t= abs(booster_position.x)-.165;\n\t\tbooster_position.z      \t= abs(booster_position.z)-.4;\n\t\tbooster_position        \t+= vec3(0.,-4.15,0.);\n\t\tfloat booster_radius    \t= length(booster_position.xz);\n\t\tfloat booster_angle     \t= atan(booster_position.x, booster_position.z)/TAU;\n\t\tfloat booster_contour   \t= booster_position.y > .1 ? .115 : .15;\n\t\tfloat booster_length    \t= booster_radius < .065 ? .12  : .195 - booster_radius * booster_position.y;\n\t\tfloat booster           \t= cylinder(booster_position, booster_length , booster_contour);\n\t\t\n\t\tbooster             \t\t+= fract(booster_position.y*8.)>.8 ? .01 : 0.;\n\t\tbooster            \t\t+= fract(booster_angle*16.)>.1 ? .01 : 0.;\n\n\t\tfloat engines         \t\t= min(engine, booster);\n\t\tship               \t\t= min(engines, ship);\n\t}\n\t\n\t//conning tower\n\tfloat tower = FARPLANE;\n\tif(position.y > 0.)\n\t{                   \n\t\t//bridge\n\t\tvec3 bridge_position            = hull_position;\n\t\tbridge_position.y       \t+= -hull_position.z * .05 - .46;\n\t\tbridge_position.z          \t+= -3.8;\n\t\t\n\t\tvec3 bridge_scale          \t= vec3(1.);\n\t\tbridge_scale.x             \t= -bridge_position.z*.05+.8;\n\t\tbridge_scale.x             \t+= abs(bridge_position.y) < .035 ? outboard_partitions*-.025 : 0.;\n\t\tbridge_scale.y\t\t\t= -abs(bridge_position.x)*.1+.125;\n\t\tbridge_scale.z\t\t\t= -bridge_position.z*.01-abs(bridge_position.x)*.15+.25;\n\t\t\n\t\tfloat bridge\t\t\t= cube(bridge_position, bridge_scale);\n\t\t\n\t\tvec2 bridge_detail\t\t= hash(floor(hull_position.xy*8.)+floor(hull_position.xy*18.))+.25;\n\t\t\n\t\tvec3 bridge_decks_position      = bridge_position;\n\t\tbridge_decks_position.z         = mod(bridge_position.z, .0625)-.00375;\n\t\tbridge_decks_position.z         = max(abs(bridge_decks_position.z)*2., abs(bridge_position.z)-bridge_detail.x*.1)+.05;\n\t\tfloat bridge_decks          \t= cube(bridge_decks_position, bridge_scale);\n\t\tbridge_decks                \t+= -forward_panels*.001;\n\t\t\n\t\t//sensor bar\n\t\tvec3 sensor_bar_position        = bridge_position;\n\t\tsensor_bar_position.y           += -.22;\n\t\tsensor_bar_position.z           += -.07;\n\t\t\n\t\tvec3 sensor_bar_scale           = vec3(1.);\n\t\tsensor_bar_scale.x          \t= .4;\n\t\tsensor_bar_scale.y          \t= sensor_bar_position.z*.01+.015;\n\t\tsensor_bar_scale.z          \t= -abs(position.x)*.025+.075;\n\t\n\t\tfloat sensor_bar            \t= cube(sensor_bar_position, sensor_bar_scale);\n\t\tsensor_bar                  \t+= fract(sensor_bar_position.x*8.-.1)>.8 ? -.0025 : 0.;\n\t\tsensor_bar                  \t+= fract(sensor_bar_position.z*8.-.3)>.4 ? .0035 : 0.;\n\t\t\n\t\t\n\t\tvec3 sensor_bar_base_position   = sensor_bar_position;\n\t\tsensor_bar_base_position.y      += .08;\n\t\tsensor_bar_base_position.z      += -.02;\n\t\t\n\t\tvec3 sensor_bar_base_scale      = vec3(1.);\n\t\tsensor_bar_base_scale.x         = -sensor_bar_position.y*.5-sensor_bar_position.z*.6-abs(sensor_bar_position.x)*.25+.05;\n\t\tsensor_bar_base_scale.y         = .074;\n\t\tsensor_bar_base_scale.z         = .08+sensor_bar_position.y*-.5;\n\t\tsensor_bar_base_scale.z         += abs(sensor_bar_base_position.x)<.1\n\t\t\t\t\t\t&& abs(sensor_bar_base_position.y-.025)<.015            \n\t\t\t\t\t\t&& sensor_bar_base_position.z<-.1\n\t\t? -.005 : 0.;       \n\t\t\n\t\tfloat sensor_bar_base           = cube(sensor_bar_base_position, sensor_bar_base_scale);        \n\t\t\n\t\tsensor_bar                  \t= min(sensor_bar, sensor_bar_base);\n\t\t\n\t\t//ray domes\n\t\tvec3 ray_dome_position          = bridge_position;  \n\t\tray_dome_position.z         \t+= .06;\n\t\tray_dome_position.y         \t+= -.16;\n\t\tray_dome_position.y         \t*= 1.3;\n\t\tray_dome_position.x         \t= abs(ray_dome_position.x)-.625;\n\t\t\t\n\t\tfloat ray_domes             \t= icosahedral(ray_dome_position*1.1, 24., .11);\n\t\t\t\n\t\tvec3 support_position       \t= ray_dome_position;\n\t\tsupport_position.y          \t+= .07;\n\t\tfloat support               \t= cube(support_position, vec3(.06));        \n\t\tfloat support_mask          \t= cube(support_position, vec3(.065,.1,.065));       \n\t\t\t\n\t\tvec3 absp                   \t= abs(support_position);\n\t\tbool struts                 \t= absp.x<.06 ^^ absp.z>.06; \n\t\tbool spars                  \t=  fract(abs(absp.x-absp.y))>.02\n\t\t\t\t\t\t&& fract(abs(absp.z-absp.y))>.02;\n\t\t\n\t\tsupport                     \t+= spars && !struts ? .01 : -.015;\n\t\n\t\tsupport                     \t= max(support, -support_mask);\n\t\t\t\n\t\t//tower \t\n\t\tvec3 tower_position         \t= hull_position;\n\t\ttower_position.z            \t+= -4.045;\n\t\ttower_position.z            \t+= tower_position.z > 4. ? tower_position.y * .3 : 0.;\n\t\ttower_position.y        \t+= -.51;\n\t\t\n\t\tvec3 tower_scale            \t= vec3(1.);\n\t\ttower_scale.x               \t= -tower_position.y*.1+.15;\n\t\ttower_scale.y               \t= .2;\n\t\ttower_scale.z               \t= tower_position.z*.05;\n\t\ttower_scale.z               \t+= tower_position.z > .2 ? -tower_position.y*.6+.4 : tower_position.y*.25+.3;\n\t\ttower_scale.x               \t+= fract(tower_position.y*16.-z_floor_noise-.3) > .6 - z_floor_noise * .05 \n\t\t\t\t\t\t&& tower_position.z + tower_position.y * .5 - z_floor_noise * .15 < .15\n\t\t\t\t\t\t&& tower_position.y < .14\n\t\t\t\t\t\t? outboard_partitions * -.015 : 0.;\n\t\t\n\t\tfloat tower                 \t= cube(tower_position, tower_scale);\n\t\t\t\n\t\t\t\n\t\tvec3 tower_base_position    \t= tower_position;\n\t\ttower_base_position.y       \t+= .15;\n\t\ttower_base_position.z       \t+= .05;\n\t\t\t\n\t\tvec3 tower_base_scale       \t= tower_scale;\n\t\ttower_base_scale.x          \t= -tower_position.y*.13+.19;\n\t\ttower_base_scale.z          \t+= -.1;\n\t\ttower_base_scale.y          \t= tower_position.z*.05+.1;\n\t\t\t\n\t\tfloat tower_base            \t= cube(tower_base_position, tower_base_scale);\n\t\t\n\t\tfloat tower_vents       \t= position.z > 3.8 ? fract(position.y*32.)*.05 : 0.;\n\t\t\n\t\ttower                       \t+= abs(position.x) < .25-position.y*.1-.07 \n\t\t&& position.y < .93\n\t\t? tower_vents : 0.;\n\t\t\t\n\t\t//compositing\n\t\ttower                   \t= min(tower, tower_base);       \n\t\tbridge_decks               \t= min(bridge-.01, bridge_decks+.01);    \n\t\tbridge_decks               \t= min(bridge_decks, support);\n\t\tray_domes                  \t= min(ray_domes, sensor_bar);\n\t\tdomes                      \t= ray_domes < bridge;\n\t\ttower                      \t= min(tower, bridge_decks);\n\t\tbridge                     \t= min(bridge, ray_domes); \n\t\ttower                      \t= min(bridge,tower);\n\t\tbridge_tower               \t= tower < ship;\n\t\t\n\t\tship                \t\t= min(tower, ship);\n\t}\n\thull_inner              \t= max(hull_inner, -tower);\n\thull_inner             \t\t= max(hull_inner, -tower);\n\tship                \t\t= min(ship, hull_inner);\n\n\n\t//solar collector (round thing on the bottom)\n\tvec3 collector_position     \t= position;\n\tcollector_position.z        \t+= -2.8;\n\tcollector_position.xz       \t*= rmat(3.14/4.);\n\tcollector_position.y        \t+= abs(collector_position.x)-.0125 < 0. \n\t\t\t\t\t|| abs(collector_position.z)-.0125 < 0.\n\t\t\t\t\t? -.05 : 0.;\n\n\tcollector_position.y \t\t*= 2.;\n\tcollector_position.y    \t+= -hull_plating * .005 + .45;\n\t\n\tfloat collector_scale       \t= position.y < -hull_scale.y ? .45 : 0.;\n\t\n\tfloat collector             \t= sphere(collector_position, collector_scale);\n\tbool solar_collector        \t= collector < ship;\n\t\n\t\n\t//super structure for upper decks\n\tvec3 deck_position      \t= hull_position;\n\tvec2 absxz              \t= abs(position.xz*3.);\n\tif(position.y > 0. && !inner_hull)\n\t{\n\t\tbool indents    \t= fract(absxz.y*.35 + .2)>.1;\n\t\t\n\t\t//outboard offset\n\t\tdeck_position.x \t+= deck_position.z - deck_position.x * .06 > 1. + deck_position.x * .15    \n\t\t\t\t\t&& deck_position.z < 3.91 - deck_position.x * .985\n\t\t\t\t\t&& deck_position.x - deck_position.z * .135 < .2\n\t\t\t\t\t? -.3 : 0.;\n\t\n\t\t//lower decks\t\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x > 1.75 \n\t\t\t\t\t&& deck_position.z > 1.285\n\t\t\t\t\t&& deck_position.z + deck_position.x *.3 < 4.45   \n\t\t\t\t\t&& deck_position.x < .4 + deck_position.z * .15\n\t\t\t\t\t? -.025 : 0.;\n\t\t\t\n\t\t//gun decks\t\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x > 1.65 \n\t\t\t\t\t&& deck_position.z > 2.5\n\t\t\t\t\t&& deck_position.z + deck_position.x *.5 < 4.38\n\t\t\t\t\t&& deck_position.x < deck_position.z * .25 +.4\n\t\t\t\t\t? -.015 : 0.;\n\n\t\t//turrets\n\t\tvec3 turret_position    = hull_position - vec3(position.z * .2-.15,.045+hull_position.z*.01, 3.23);\n\t\t\n\t\tturret_position.z   \t= abs(abs(abs(turret_position.z)-.125)-.125)-.125;\n\t\tturret_position.x   \t= abs(turret_position.x)-.5;\n\t\t\t\n\t\n\t\tvec2 turret_radius  \t= vec2(.02, .02);\n\t\tturret_radius.x     \t= turret_position.y > .01 ? .04 : .01;\n\t\tturret_radius.y     \t= abs(turret_position.z) > .015 \n\t\t\t\t\t|| turret_position.x > .0025 \n\t\t\t\t\t? .001 : turret_radius.y+.005;\n\t\t\n\t\tfloat turret_depth  \t= .025;\n\t\t\n\t\tfloat turret        \t= cone(turret_position, turret_depth, turret_radius);\n\t\tvec3 barrel_position    = turret_position;\n\t\tbarrel_position.y   \t+= -.045;\n\n\t\t\n\t\tfloat barrel       \t= cube(barrel_position, vec3(.03,0.005,.005));\n\t\tturret          \t= min(turret, barrel);\n\n\t\tdeck_position.y     \t+= turret < .05 ? .01 : 0.;   \n\t\tship            \t= position.y > 0. ? min(ship, turret) : ship;\n\t\t\n\t\t\n\t\t//mid decks\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x        > 2.25 \n\t\t\t\t\t&& deck_position.z + deck_position.x *.4    < 4. \n\t\t\t\t\t&& deck_position.x + deck_position.z * .1   > .26    \n\t\t\t\t\t&& deck_position.x < .5 \n\t\t\t\t\t? -.05 : 0.;\n\t\t\n\t\t\n\t\t//upper decks\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .125 > 2.9\n\t\t\t\t\t&& deck_position.z + deck_position.x *.4    < 3.9 \n\t\t\t\t\t&& deck_position.x              \t    < .3 \n\t\t\t\t\t? -.02 : 0.;\n\t\t\n\t\t//midship deck\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .3   > .75\n\t\t\t\t\t&& deck_position.z + deck_position.x        < 2.19\n\t\t\t\t\t&& deck_position.x < .6 \n\t\t\t\t\t&& deck_position.x > -.25\n\t\t\t\t\t? -.01 : 0.;\n\t\t\n\t\t//midship hatches\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .3   > .85\n\t\t\t\t\t&& deck_position.z + deck_position.x        < 1.9\n\t\t\t\t\t&& deck_position.x < .55 \n\t\t\t\t\t&& deck_position.x > .25\n\t\t\t\t\t? -.01 : 0.;\n\t\n\t\n\t\t//bulwarks\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x        > .092\n\t\t\t\t\t&& deck_position.x - deck_position.z *.283  < .5\n\t\t\t\t\t&& deck_position.z  < 4.\n\t\t\t\t\t&& deck_position.x-deck_position.z*.25  > -.25\n\t\t\t\t\t&& indents\n\t\t\t\t\t? -.005 * hull_position.x : 0.;\n\t\t\n\t\t\n\t\t//sensor deck\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .5   > -.48  \n\t\t\t\t\t&& deck_position.z + deck_position.x        < .34   \n\t\t\t\t\t&& deck_position.x              < .28\n\t\t\t\t\t? -.014  : 0.;\n\t\t\n\t\t\n\t\t//forecastle\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * 5.5   > -1.45  \n\t\t\t\t\t&& deck_position.z + deck_position.x * 2.    < -.54   \n\t\t\t\t\t? -.01  : 0.;\n\t\n\t\t//upper deck superstructure\n\t\tvec3 deck_upper_position= hull_position;\n\t\tdeck_upper_position.y   = hull_position.y- .15 - deck_position.y*.05;\n\t\tdeck_upper_position.z   += -3.16;\n\t\t\n\t\tvec3 deck_upper_scale   = vec3(1.);\n\t\tdeck_upper_scale.x      = hull_scale.x-deck_position.x-.8;\n\t\tdeck_upper_scale.x      += deck_position.z < 2.7 ? deck_upper_position.z : 0.;\n\t\tdeck_upper_scale.x      += deck_position.z > 3.9 ? -deck_upper_position.z*2.7+2. : 0.;\n\t\tdeck_upper_scale.x      += deck_partitions*.025;\n\t\tdeck_upper_scale.y      = hull_scale.y;\n\t\tdeck_upper_scale.z      = .55 - forward_partitions*.015;\n\t\tdeck_upper_scale.z      += deck_position.z > 3. ? .4 : 0.;\n\t\t\n\t\tbool upper_deck_bounds  = deck_position.z - deck_position.x * .3   > .5\n\t\t\t\t\t&& deck_position.z + deck_position.x            < 1.9\n\t\t\t\t\t&& deck_position.x < .55 \n\t\t\t\t\t&& deck_position.x > .15;\n\t\t\n\t\tdeck_upper_scale.x  \t*= !upper_deck_bounds ? 1. : 2.4;\n\t\t\n\t\tfloat deck_upper    \t= cube(deck_upper_position, deck_upper_scale);\n\t\t\n\t\t\n\t\t//mid deck superstructure\n\t\tvec3 deck_mid_position  = hull_position;\n\t\tdeck_mid_position.y     = hull_position.y - .1;\n\t\tdeck_mid_position.z     -= 3.16;\n\t\t\n\t\n\t\t\n\t\tvec3 deck_mid_scale     = vec3(1.);\n\t\tdeck_mid_scale.x        = hull_scale.x-deck_position.x;\n\t\tdeck_mid_scale.x        += deck_position.z < 2.7 ? deck_mid_position.z : 0.;\n\t\tdeck_mid_scale.x        += deck_position.z > 3.9 ? -deck_mid_position.z*2.7+2. : 0.;\n\t\tdeck_mid_scale.x        += deck_partitions*.025;        \n\t\tdeck_mid_scale.y        = hull_scale.y;        \n\t\tdeck_mid_scale.z        = .93 - forward_partitions*.015;\n\t\t\n\t\tbool mid_deck_bounds    = deck_position.z - deck_position.x * .3   > .5\n\t\t\t\t\t&& deck_position.z + deck_position.x            < 1.9\n\t\t\t\t\t&& deck_position.x < .55 \n\t\t\t\t\t&& deck_position.x > .15;\n\t\t\n\t\tdeck_mid_scale.x\t*= !mid_deck_bounds ? 1. : 2.4;\n\t\n\t\tfloat deck_mid          = cube(deck_mid_position, deck_mid_scale);\n\t\n\t\tship                    = min(ship, deck_upper);\n\t\tship                    = min(ship, deck_mid);\n\t}\n\telse\n\t{\n\t\n\t\t//solar collector berth\n\t\tdeck_position.y \t*= deck_position.z - deck_position.x    > 1.9\n\t\t\t\t\t&& deck_position.z + deck_position.x    < 3.65\n\t\t\t\t\t&& deck_position.x                      < deck_position.z * .23 \n\t\t\t\t\t? .9 : 1.;\n\t\t\n\t\tdeck_position.y \t+= length(collector_position)-.55 < 0. ? .05 : 0.;\n\t\t\t\n\t\tvec2 absxz      \t= abs(position.xz*8.);\n\t\tbool indents    \t= fract(absxz.y*.35+.5)>.1;\n\t\tbool columns    \t= mod(absxz.y-.25-position.y, 1.) > .5 && abs(position.x) > .10;\n\t\tbool spars      \t= mod(absxz.x+absxz.y, 1.25) > .025 ^^ mod(absxz.x-absxz.y, 1.25) > .025;\n\t\t\n\t\t\n\t\t//fighter bays\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x        > .92\n\t\t\t\t\t&& deck_position.x - deck_position.z *.25   < .3\n\t\t\t\t\t&& deck_position.x -deck_position.z*.25     > .15\n\t\t\t\t\t&& deck_position.z                          < 4.\n\t\t\t\t\t&& indents && !spars\n\t\t\t\t\t? .01 * hull_position.x : 0.;\n\t\t\n\t\t\n\t\t//forward bay\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .5   > -.7   \n\t\t\t\t\t&& deck_position.x          < .2     \n\t\t\t\t\t&& deck_position.z          < -.3    \n\t\t\t\t\t? -.0125 - hull_plating * .0025 : 0.;      \n\t\t\n\t\t//main docking bay border\n\t\tdeck_position.y \t+= deck_position.z  > .25\n\t\t\t\t\t&& deck_position.z  < 1.25\n\t\t\t\t\t&& deck_position.x  < .45\n\t\t\t\t\t? -.01 : 0.;\n\t\t\n\t\t//main docking bay\n\t\tbool bay_area \t\t= deck_position.z   > .2\n\t\t\t\t\t&& deck_position.z  < 1.2\n\t\t\t\t\t&& deck_position.x  < .4;\n\t\t\n\t\t\n\t\tdeck_position.y \t+= bay_area ? -hull_position.x*0.25+.1 : 0.;\n\n\t\tdeck_position.y \t+= bay_area\n\t\t\t\t\t&& columns\n\t\t\t\t\t? -.01 : .0;\n\t\t\n\t\tdeck_position.y \t+= bay_area\n\t\t\t\t\t&& spars\n\t\t\t\t\t&& !columns\n\t\t\t\t\t? -0.004 : 0.;\n\t\t\t\n\t\t\t\t\t//main docking bay border\n\t\tdeck_position.y \t+= deck_position.z  > .75\n\t\t\t\t\t&& deck_position.z  < 1.95\n\t\t\t\t\t&& deck_position.x  < .45\n\t\t\t\t\t&& !spars\n\t\t\t\t\t? -abs(position.x)*.001 : 0.;   \n\t}\n\tdeck_position   \t\t+= -.005;\n\tship                    \t= min(ship, hull_inner);\n\t\n\tbool upper_decks        \t= hull_position.y != deck_position.y \n\t\t\t\t\t|| hull_position.x != deck_position.x \n\t\t\t\t\t|| hull_position.z != deck_position.z; \n\t\n\t\t\n\tvec3 deck_scale         \t= hull_scale;\n\t\n\tdeck_scale              \t*= position.y > 0. && position.z < 4. && upper_decks ? 1.01 : 1.;\n\tfloat decks             \t= cube(deck_position, deck_scale);\n\t\t\n\tship                    \t= position.y < -.075 && position.z < 4. ? max(hull_inner,decks) : ship;\n\tship                    \t= min(decks, ship);\n\tship                    \t= min(collector, ship);\n\t\n\t\n\t//border around the edge of the main hull\n\tvec3 border_mask_position   \t= abs(hull_scale);\n\tborder_mask_position.x      \t*= -abs(hull_position.x*1.5)+hull_position.z*.5+1.25;\n\tborder_mask_position.y      \t*= 1.1;\n\tborder_mask_position.z      \t+= position.z-hull_position.x*.1 < 4.5 ? .05 : 0.;\n\t\t\n\tfloat hull_border_mask      \t= cube(hull_position, border_mask_position);\n\t\n\tfloat hull_border           \t= abs(fract((hull_position.x*2.+hull_position.z*8.)*4.)-.5)*2.;\n\thull_border                 \t= min(hull_border, .1)*.005-.0035;\n\t\t\n\tbool border                 \t= hull_border_mask > hull_outer && !inner_hull && !upper_decks;\n\t\n\t\n\t\n\thull_border                 \t+= outboard_partitions * .00015;\n\toutboard_partitions         \t+= max(outboard_partitions, .85)*4.;    \n\t\t\n\tvec2 xz_floor_noise                \t= hash(floor(hull_position.xz*8.+deck_scale.y*4.+abs(8.-hull_position.zx*1.5)*vec2(32., 23.)));\n\txz_floor_noise                 \t= max(floor(xz_floor_noise*32.)-25., .0)*.025*(.25-position.x)*xz_floor_noise;\n\n\n\t//outboard hangar bays\n\tvec3 bay_positions         \t= position;\n\tbay_positions.z            \t+= -3.15;\n\tbay_positions.z            \t= mod(bay_positions.z+mod(bay_positions.z, 3. + bay_positions.z * .5), 3.4)-.5525;\n\tbay_positions.y           \t+= z_floor_noise * .025 + xz_floor_noise.y * .005 - .01;\n\t\n\tvec3 bay_scale             \t= vec3(1.);\n\tbay_scale.x             \t= 4.;\n\tbay_scale.y             \t= .0175 - (xz_floor_noise.x - xz_floor_noise.y) * hull_scale.x * .035 + z_floor_noise*position.x*.0025;\n\tbay_scale.y             \t+= position.z < 0.1 ? xz_floor_noise.x * .4 -.01 : 0.;\n\tbay_scale.y             \t+= abs(position.x) < .05 ? -.04 : 0.;\n\tbay_scale.z             \t= position.z*.095+.1+abs(position.x)*.1;\n\t\n\tfloat hangar_bays           \t= cube(bay_positions, bay_scale);\n\n\t\n\t//composite details\n\tbool wake_line          \t= abs(position.y)<.055;\n\t\n\thull_panels             \t*= border || bridge_tower ? .5 : 1.;\n\thull_panels             \t*= upper_decks ? .75 : 1.;\n\t\n\n\tfloat hull_inner_detail     \t= wake_line\n\t\t\t\t\t&& hangar_bays > 0.\n\t\t\t\t\t&& outboard_partitions<3.95\n\t\t\t\t\t? .01 : outboard_partitions *.001;\n\n\tfloat hull_detail_floor\t\t= floor(8.*crossf(position.z+crossf(position.z*5.)+crossf(position.y*3.))/3.);\n\thull_inner_detail       \t+= wake_line && hangar_bays > 0.\n\t\t\t\t\t&& outboard_partitions<3.95\n\t\t\t\t\t&& position.z > -1.4\n\t\t\t\t\t? -min(hull_detail_floor,.75)*.02 : 0.;\n\t\n\t//detailing\n\tship               \t\t+= wake_line ? (z_floor_noise < .1 ? -.0075 : 0.) : 0.;                  \n\tship               \t\t= max(ship, -hangar_bays);\n\tship               \t\t= border ? ship + hull_border : ship+ hull_border ;\n\tship               \t\t= bridge_tower || upper_decks ? ship + outboard_partitions *.0001 : ship;\n\tship               \t\t= (bridge_tower || outer_hull) && !border ? ship + hull_panels * .0025 : ship;  \n\tship               \t\t= !aft && !bridge_tower && inner_hull ? ship + hull_inner_detail: ship; \n\t\n\n\t//return distance and materials\n\tvec2 material_range         \t= vec2(0.);\n\tmaterial_range.y            \t= ship;\n\tmaterial_range.x        \t= 0.;\n\treturn material_range;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv         \t= UV;\n\tray r           \t= view(uv);\n\n\tr               \t= emit(r);\n\n\n\tfloat distanceFog   \t= clamp(r.material_range.y/FARPLANE, 0., 1.);\n\tfloat stepFog       \t= clamp(r.steps/float(ITERATIONS), 0., 1.);\n\tstepFog        \t \t= r.steps < 1. ? 1. : stepFog;\n\t\n\tvec4 result     \t= vec4(0.);\n\tresult          \t= pow(stepFog, .5) * vec4(1., 1.5, 1.,1.);\n\tresult.r        \t+= r.steps > float(ITERATIONS - ITERATIONS/4) ? 1. : 0.;\n\tresult      \t\t= pow(result,vec4(2.));\n\tresult      \t\t-= r.material_range.y*.012;\n\tresult.w   \t\t = 1.;\n\n\tfragColor = result;\n}// sphinx\n\nray emit(ray r)\n{\n\tfloat total_range       = r.material_range.y;\n\tfloat threshold     \t= PHI;\n\t\n\tfor(int i = 1; i < ITERATIONS; i++)\n\t{\n\t\tif(total_range < FARPLANE)\n\t\t{\n\t\t\tif(r.material_range.y < threshold && r.material_range.y > 0.)\n\t\t\t{\n\t\t\t\tr.material_range.x += r.material_range.y;\n\t\t\t\tr.material_range.y = total_range;\n\t\t\t\tr.steps            = float(i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthreshold          *= 1.04;\n\t\t\tr.position         += r.direction * r.material_range.y * .8;\n\t\t\tr.material_range   = map(r.position);\n\t\t\t\n\t\t\tif(r.material_range.y < 0.)\n\t\t\t{\n\t\t\t\tr.material_range.y -= threshold;\n\t\t\t\tthreshold *= float(i);\n\t\t\t}\n\t\t\ttotal_range        += r.material_range.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr.material_range.y = 1.+length(r.origin + r.direction * FARPLANE);\n\t\t\tr.material_range.x = 0.;\n\t\t\tr.steps            = float(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r;\n}\n\nvec2 format_to_screen(vec2 uv)\n{\n\tuv = uv * 2. - 1.;\n\tuv.x *= ASPECT;\n\treturn uv;\n}\n\n\nray view(in vec2 uv)\n{ \n\tuv = format_to_screen(uv);\n\n\tvec3 w          = normalize(VIEWTARGET-VIEWPOSITION);\n\tvec3 u          = normalize(cross(w,vec3(0.,1.,0.)));\n\tvec3 v          = normalize(cross(u,w));\n\n\tray r           = ray(vec3(0.), vec3(0.), vec3(0.), vec2(0.), 0.);\n\tr.origin        = VIEWPOSITION;\n\tr.position      = VIEWPOSITION;\n\tr.direction     = normalize(uv.x*u + uv.y*v + FOV*w);;\n\tr.material_range    = vec2(0.);\n\tr.steps             = 0.;\n\n\treturn r;\n}   \n\n\nfloat sphere(vec3 position, float radius)\n{\n\treturn length(position)-radius; \n}\n\nfloat cube(vec3 p, vec3 s)\n{\n\tvec3 d = (abs(p) - s);\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\treturn length(q)-t.y;\n}\n\nfloat cylinder(vec3 p, float l, float r)\n{\n\treturn max(abs(p.y-l)-l, length(p.xz)-r);\n}\n\nfloat cone(vec3 p, float l, vec2 r)\n{\n\tfloat m = 1.-(p.y*.5)/l;\n\treturn max(length(p.xz)-mix(r.y, r.x, m), abs(p.y-l)-l);\n}\n\nfloat icosahedral(vec3 p, float e, float r)\n{\n\tvec2 n = vec2(.577, -.577);\n\tfloat a = .357;\n\tfloat b = .934;\n\tfloat s = pow(abs(dot(p,n.yyy)),e);\n\ts += pow(abs(dot(p,n.yxx)),e);\n\ts += pow(abs(dot(p,n.xyx)),e);\n\ts += pow(abs(dot(p,n.xxy)),e);\n\ts += pow(abs(dot(p,vec3( 0.,a,b))),e);\n\ts += pow(abs(dot(p,vec3(0.,-a,b))),e);\n\ts += pow(abs(dot(p,vec3( b,0.,a))),e);\n\ts += pow(abs(dot(p,vec3(-b,0.,a))),e);\n\ts += pow(abs(dot(p,vec3( a,b,0.))),e);\n\ts += pow(abs(dot(p,vec3(-a,b,0.))),e);\n\ts = pow(s, 1./e);\n\treturn s-r;\n}\n//// END DISTANCE FIELD FUNCTIONS\n\n\n//// NOISE\n//via http://glsl.herokuapp.com/e#4841.11\nfloat partition_noise(vec2 p) \n{\n\tvec2 id;\n\t\n\tid = floor(floor(p)-.5);\n\t\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\t\n\tp.yx *= floor(hash(id) * 3.)-4.;\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\n\tp -= id;\n\n\tvec2 u = abs(p - .5) * 2.;\n\n\treturn max(u.x, u.y);\n}\n\nfloat hash(float v)\n{\n\treturn fract(fract(v*1234.5678)*(v+v)*12345.678);\n}\n\nvec2 hash(vec2 v) \n{\n\tvec2 n;\n\tn.x=fract(cos(v.y-v.x*841.0508)*(v.y+v.x)*3456.7821);\n\tn.y=fract(sin(v.x+v.y*804.2048)*(v.x-v.y)*5349.2627);\n\treturn n;\n}\n\nfloat crossf(float x)\n{\n\treturn abs(fract(x-.5)-.5)*2.;  \n}\n\n\nmat2 rmat(in float r)\n{\n\tfloat c = cos(r);\n\tfloat s = sin(r);\n\treturn mat2(c, s, -s, c);\n}\n","name":"Image","description":"","type":"image"}]}