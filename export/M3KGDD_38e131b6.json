{"ver":"0.1","info":{"id":"M3KGDD","date":"1717684996","viewed":32,"name":"Ray marching_learning","username":"Dimitar","description":"This is just me learning ray marching by doing stuff :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITTERATION 100\n#define MIN_DIST .01\n#define MAX_DIST 100.\n#define AMBIENT 0.01\n\nfloat GetDistance(vec3 p);\n\n/*SDF functions*/\n\nfloat sphereSDF(vec3 p,vec4 spherePosAndRadius)\n{\n    return length(p - spherePosAndRadius.xyz) -spherePosAndRadius.y;\n}\nfloat cubeSDF(vec3 p)\n{\n    p += vec3(0,0,-4.);\n    return length(max(abs(p) - vec3(.5),.0));\n}\n/*float coneSDF(vec3 p)\n{\n    p += vec3(2.,-.0,-2.5);\n     p = abs(p);\n    float r = .5;\n    float h = .5;\n    float alpha  = 40.;\n    float beta = 90. - acos(dot(normalize(p),vec3(0,1,0))); \n    float c = r*sin(alpha)/sin(180. - alpha + beta);\n    c = max(c,p.y);\n    float d = length(p) - c;\n    return d;\n    \n}*/\nfloat cilinderSDF(vec3 p)\n{\n p += vec3(0,-.0,-1.5);\n    vec3 c = vec3(vec2(.5),0.584);\n     p = abs(p);\n    vec2 d = vec2(length(p.xz),p.y) - vec2(c.x,c.y);\n    return length(max(d,.0));\n}\n\nconst vec3 lightPos = vec3(0,4.,-2.);\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(0.1,0);\n    float d = GetDistance(p);\n    vec3 normal =d - vec3(\n        GetDistance(p-e.xyy),\n        GetDistance(p-e.yxy),\n        GetDistance(p-e.yyx));\n        \n    return normalize(normal);      \n}\nvec3 CalcLight(vec3 p,vec3 camera)\n{\n   \n    vec3 ambient = vec3(1)*AMBIENT;\n    vec3 l = normalize(lightPos - p);\n    float diff = max(dot(GetNormal(p),l),.0);\n    vec3 camDir = normalize(camera - p);\n    \n    float spec =pow(max(dot(camDir,reflect(-l,GetNormal(p))),.0),32.);\n    return ambient + vec3(1)*diff + vec3(1)*spec;\n}\n\nfloat GetDistance(vec3 p)\n{\n    //vec4 spehere = vec4(0,0,2.,.5);\n    vec4 spehere = vec4(cos(iTime),sin(iTime),2.,.5);\n    vec3 sceneFloor = vec3(0,-1.,1);\n    float d = length(p - spehere.xyz) - spehere.w;\n    d = min(d,p.y - sceneFloor.y);\n    \n    return min(d,cubeSDF(p)); \n    \n}\n\n\nfloat RayMarch(vec3 rO, vec3 rd)\n{\n    float ds = 0.;\n    for(int i = 0;i <MAX_ITTERATION;i++)\n    {\n        vec3 p = rO + rd*ds;\n        ds += GetDistance(p);\n        if(ds <= MIN_DIST || ds >= MAX_DIST) break;\n    }\n    return ds;\n}\n\n/*mat3 rotate(float _angle)\n{\n    return mat3(cos(_angle),-sin(_angle),\n                )\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2. -1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //vec3 ro = vec3(-sin(iTime),0,-cos(iTime));\n    //vec3 ro = vec3(sin(iTime),-cos(iTime),0);\n    vec3 ro = vec3(0,0,0);\n    vec3 rd =normalize(vec3(uv,1.0));\n    vec3 col =vec3(1);\n    col = CalcLight(ro + rd*RayMarch(ro, rd),ro);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}