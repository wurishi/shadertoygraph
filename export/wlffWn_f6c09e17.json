{"ver":"0.1","info":{"id":"wlffWn","date":"1596445226","viewed":251,"name":"FieldFX 25/07 MS","username":"MonsieurSoleil","description":"Finals.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n\n#define time iTime/60.0*140.0\n#define mod01 floor(mod(time * 2.0, 4.0))\n#define mod02 floor(mod(time * 0.5, 8.0))\n#define mod03 floor(mod(time * 0.5, 4.0))\n\nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nstruct matter\n{\n  float m;\n  int type;\n  bool reflected;\n};\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) -s;\n  return max(p.x, max(p.y,p.z));\n}\n\n\n\nfloat opSmooth(float a, float b, float k)\n{\n  float h = clamp(0.5 - 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) + k*h*(1.0-h);\n}\n\nvec3 opRepLim(vec3 p, vec3 c, vec3 l)\n{\n  vec3 q = p-c*clamp(round(p/c), -l, l);\n  return q;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n  float mat01, mat02, mat03;\n  \n  vec3 p01 = p, p02 = p, p03 = p;\n  \n  \n  p03 = opRepLim(p03, vec3(1.55), vec3(55.0));\n  \n  p01.xy *= rot(sin(time * 0.1))* 0.5; \n  p01.zy *= rot(sin(time * 0.1))* 1.3; \n  \n  mat01 = -box(p01, vec3(5.0, 5.0, 5.0));\n  \n  p03.xy *= rot(sin(time * 2.0)) * 0.5;\n   p03.zy *= rot(sin(time * 2.0)) * 0.5;\n  mat01 = max(mat01, -box(p03, vec3(0.05 + abs(sin(mod01)) * 0.05 )));\n  \n  if(mat01 < 0.01)\n  {\n    mat.type = 1;\n  }\n  \n  if(mat.reflected)\n  {\n    p02.xy *= rot(sin(mod01));\n    \n    mat02 = box(p02, vec3(0.5));\n    mat02 = min(mat02, box(p02 + vec3(cos(time) * 1.0, sin(time) * 2.0, 0.0), vec3(0.4)));\n    mat02 = min(mat02, box(p02 + vec3(cos(time * .5) * 0.4, sin(time) * 2.0, 0.0), vec3(0.6)));\n\n  mat02 = min(mat02, box(p02 + vec3(cos(mod02) * 0.8, sin(mod02) * 5.0, 0.0), vec3(1.2 * mod03)));\n    \n    gg += 0.15/(0.05+abs(mat02));\n  }\n  \n  \n  mat.m = mat01;\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map(m01, p);\n  map(m02, p - uv.xyy);\n  map(m03, p - uv.yxy);\n  map(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 o = vec3(0.0, 2.0 * fract(time * 0.2), 4.0 * sin(time * 0.2)), t = vec3(1.0, 2.0, 0.0);\n  vec3 fr = normalize(t-o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  \n  vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n  vec3 p = dir * 0.5 + o;\n  \n  vec3 col = vec3(0.0);\n  matter mat;\n  float dd = 0.0;\n  \n  for(int i = 0; i < 150 ;++i)\n  {\n    map(mat, p);\n    \n    if(mat.m < 0.01)\n    {\n      if(mat.type == 1)\n      {\n        vec3 n = normals(p);\n        dir = reflect(dir, -n);\n        \n        mat.m = 0.5;\n        mat.reflected = true;\n      }\n      \n      mat.m = 0.5;\n    }\n    \n    col += gg * 0.00125 * mix(vec3(0.0,0.8, 1.0), vec3(1.0, 0.2, 0.0), sin(mod03));\n    \n    p += mat.m * dir * 0.85;\n    dd += mat.m * 0.85;\n  }\n  \n  float fog = clamp(dd/100.0, 0.0, 1.0);\n  vec3 sky = mix(vec3(0.3), vec3(0.1), uv.y);\n  col -= fog * sky;\n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}