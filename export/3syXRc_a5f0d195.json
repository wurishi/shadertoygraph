{"ver":"0.1","info":{"id":"3syXRc","date":"1574617373","viewed":118,"name":"RayMarchingCircle Complete","username":"KeeganPillow","description":"Fixed my raymarching by giving the collision amount an epsilon.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarch","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITS 256\n#define CIRCLE_RAD_MOD 50.0\n#define NEAR_THRESH 15.0\n#define COLLIDE_THRESH 0.001\n#define DEPTH_STEP_SIZE 1.0\n#define SHADOW_FALL 1.0\n//Finds the distance to a given circle\nfloat distToCirc(vec2 point, vec2 centerCirc, float radius)\n{\n    float dist = length(point - centerCirc);\n    \n    dist -= radius;\n    \n    if (dist < 0.0)\n    {\n        dist = 0.0;\n    }\n    \n   return dist;\n}\n\n//Finds the distance to a given circle\nvec2 closestToCirc(vec2 point, vec2 centerCirc, float radius)\n{\n    return normalize(centerCirc - point) * distToCirc(point, centerCirc, radius);\n}\n\nfloat SampleDepth(vec2 normedDir, vec2 start, float maxDepth, vec2 obj, float radius)\n{\n    //Logic\n    float dist;\n    \n    //Output\n    float depth = 0.0;\n\n    //Has hit\n    for (int i = 0; i < MAXITS; ++i)\n    {\n        //Find distance to nearest object from camera.\n        dist = distToCirc(obj, start, radius);\n        \n        if (dist > COLLIDE_THRESH)\n        {\n            depth = (radius * 2.0);\n            return depth;\n        }\n        if (depth > maxDepth)\n        {\n          return maxDepth;\n        }\n        \n        //Move in direction of raycast.\n        start += normedDir * DEPTH_STEP_SIZE;\n\n        //Add to the depth\n        depth += DEPTH_STEP_SIZE;\n    } //Repeat until distance covered, or collided.\n    return depth;\n}\n\n//Raymarching:\nfloat rayMarching (vec2 CamPos, vec2 pixPos, vec2 obj, float radius)\n{\n    //Logic\n    float dist = 0.0;\n    float totalDist = 0.0;\n    bool hit = false;\n    bool near = false;\n    vec2 Pos = CamPos;\n    \n    //Massage inputs\n    vec2 dirToPix = normalize(pixPos - Pos);\n    float distToCam = length(pixPos - Pos);\n    \n    //Output\n    float depth = 0.0;\n    \n    //Constants\n    const float depthStepSize = 1.0;\n    \n    //Stores the previous distance.\n    float prevDist = 1000.0f;\n    \n    vec2 closestPoint;\n    float distToClosest;\n    \n    //Loop\n    for (int i = 0; i < MAXITS; ++i)\n    {\n    \n        //Find distance to nearest object from camera.\n        dist = distToCirc(obj, Pos, radius);\n        \n        //If the object is hit, sample its depth\n        if (dist <= COLLIDE_THRESH) \n        {\n            return SampleDepth(dirToPix,\n                               Pos,\n                               length(Pos - pixPos),\n                               obj, \n                               radius);\n        }\n        \n        //Otherwise,\n         //Move in direction of raycast.\n         Pos += dirToPix * dist;\n         //Add to the total distance\n         totalDist += dist;\n            \n          //Find closest point for soft-shadows if close enough\n        if (dist < NEAR_THRESH)\n          {\n            near = true;\n          }\n        \n        if (totalDist >= distToCam)\n        {\n            \n            if (near && distToCam > (length(obj - CamPos)))\n            {\n                float dotted = dot(normalize((obj - CamPos)), dirToPix);\n                //depth = (radius * 2.0) * pow(dotted, SHADOW_FALL);\n                \n            }\n            break;\n        }\n        \n        prevDist = dist;\n    } //Repeat until distance covered, or collided.\n    \n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n  vec2 res = iResolution.xy;\n  vec2 mouse = iMouse.xy;\n    \n  //Object\n  vec2 obj = vec2(res.x / 2.0 + sin(iTime) * 20.0, res.y / 2.0);\n      \n  //Main loop:\n\n  //Camera is the mouse position.\n  vec2 camPos = mouse;\n  float radius = min(0.0, sin(iTime)) + CIRCLE_RAD_MOD;\n    \n    //Raymarch to pixel from cam position. \n  float depth = rayMarching(camPos, fragCoord, obj, radius);\n    \n  //Normalize depth\n  depth /= (radius * 2.0);\n  \n  float depthColor = 1.0 - depth;\n    \n  //Check if no object was hit\n  if (depth == 0.0)\n      {\n          \n          fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n  else\n      {\n          fragColor = vec4(depthColor,depthColor,depthColor, 1.0);\n      }\n}\n","name":"Image","description":"","type":"image"}]}