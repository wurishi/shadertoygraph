{"ver":"0.1","info":{"id":"wtjXR1","date":"1568059319","viewed":79,"name":"[MXPL] SDF construction","username":"matexpol","description":"Simple construction made by few SDF objects, drawn via raymarching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////// START OF CHANGEABLE CODE\n\n#define STRINGS_LENGTH 3.\n#define STRINGS_THICKNESS 0.02\n#define STRINGS_BASE_POSITION vec3(0., 3.5, 0.)\n#define STRINGS_COLOR (vec3(51.) / 255.)\n\n#define MAX_SWING_ANGLE 45.\n#define SWING_SPEED_MULTIPLIER 1.4\n\n#define WEIGHTS_RADIUS 0.15\n#define WEIGHTS_COLOR STRINGS_COLOR\n\n#define CENTRAL_SHAPE_POSITION vec3(0., 0.55, 0.)\n#define CENTRAL_SPHERE_RADIUS 0.95\n#define CENTRAL_SPHERE_COLOR (vec3(220., 0., 0.) / 255.)\n#define CENTRAL_HEXAGON_WIDTH 1.\n#define CENTRAL_HEXAGON_HEIGHT 1.5\n#define CENTRAL_HEXAGON_COLOR (vec3(0., 120., 0.) / 255.)\n\n// If string will be at this angle, holes will start to open\n#define HOLES_START_OPENING_ANGLE 35.\n// If string will be at this angle, holes will stop oppening\n#define HOLES_FULLY_OPENED_ANGLE 20.\n\n#define HOLE_MAX_RADIUS 0.25\n#define HOLE_COLOR vec3(1.)\n\n#define GAP_THICKNESS ((STRINGS_THICKNESS*2.)+0.05)\n#define GAP_COLOR HOLE_COLOR\n\nfloat getDistanceToCombinedSDF_String(const vec3 pointWS, const float stringSwingRotation,\n                                      const float stringRotation, out vec3 colorInMinDistance)\n{\n    // Matrix which rotates string around World.Up vector\n    mat4 stringRotationMatrix = createRotationMatrix(vec3(0., stringRotation, 0.));\n    // Matrix which enables string swinging\n    mat4 stringSwingRotationMatrix =\n        createRotateAroundPointMatrix(STRINGS_BASE_POSITION, stringSwingRotation * vec3(1., 0., 0.));\n    // Matrix which moves string to base position\n    mat4 stringTranslateMatrix = createTranslationMatrix(-STRINGS_BASE_POSITION + vec3(0., STRINGS_LENGTH/2., 0.));\n    vec3 stringPoint = (stringTranslateMatrix * stringSwingRotationMatrix * stringRotationMatrix *\n                        vec4(pointWS, 1.)).xyz;\n\n    SDFCylinderData stringSDF =\n        SDFCylinderData(STRINGS_LENGTH, STRINGS_THICKNESS, STRINGS_COLOR);\n    float stringSDFDistance = getDistanceToCylinderSDF(stringPoint, stringSDF);\n    \n    // Matrix which moves weight to position at the end of string\n    mat4 weightTranslateMatrix = createTranslationMatrix(-STRINGS_BASE_POSITION + vec3(0., STRINGS_LENGTH, 0.));\n    vec3 weightPoint = (weightTranslateMatrix * stringSwingRotationMatrix * stringRotationMatrix *\n                        vec4(pointWS, 1.)).xyz;\n    SDFSphereData weightSDF = SDFSphereData(WEIGHTS_RADIUS, WEIGHTS_COLOR);\n    float weightSDFDistance = getDistanceToSphereSDF(weightPoint, weightSDF);\n    \n    float resultDistance = getSDFUnion(stringSDFDistance, stringSDF.color,\n                                       weightSDFDistance, weightSDF.color, true, colorInMinDistance);\n    return resultDistance;\n}\n\nfloat getDistanceToCombinedSDF_CentralShape(const vec3 pointWS, out vec3 colorInMinDistance)\n{\n    mat4 centralShapeTranslation = createTranslationMatrix(-CENTRAL_SHAPE_POSITION);\n    vec3 centralShapePoint = (centralShapeTranslation * vec4(pointWS, 1.)).xyz;\n    \n    SDFSphereData centralSphereSDF = SDFSphereData(CENTRAL_SPHERE_RADIUS, CENTRAL_SPHERE_COLOR);\n    float centralSphereDistance = getDistanceToSphereSDF(centralShapePoint, centralSphereSDF);\n    \n    vec3 boxInCentralHexagonSize = vec3(CENTRAL_HEXAGON_WIDTH, CENTRAL_HEXAGON_HEIGHT,\n                                        sqrt(3.) * CENTRAL_HEXAGON_WIDTH);\n    SDFBoxData boxInCentralHexagonSDF = SDFBoxData(boxInCentralHexagonSize, CENTRAL_HEXAGON_COLOR);\n    // Matrix to rotate single box which creates hexagon\n    mat4 rotateBoxMatrix = createRotationMatrix(vec3(0., 60., 0.));\n    \n    float firstBoxInCentralHexagonDistance = getDistanceToBoxSDF(centralShapePoint, boxInCentralHexagonSDF);\n    centralShapePoint = (rotateBoxMatrix * vec4(centralShapePoint, 1.)).xyz;\n    float secondBoxInCentralHexagonDistance = getDistanceToBoxSDF(centralShapePoint, boxInCentralHexagonSDF);\n    centralShapePoint = (rotateBoxMatrix * vec4(centralShapePoint, 1.)).xyz;\n    float thirdBoxInCentralHexagonDistance = getDistanceToBoxSDF(centralShapePoint, boxInCentralHexagonSDF);\n    \n    vec3 hexagonColor;\n    float hexagonDistance = getSDFUnion(firstBoxInCentralHexagonDistance, boxInCentralHexagonSDF.color,\n                                        secondBoxInCentralHexagonDistance, boxInCentralHexagonSDF.color,\n                                        false, hexagonColor);\n    hexagonDistance = getSDFUnion(thirdBoxInCentralHexagonDistance, boxInCentralHexagonSDF.color,\n                                  hexagonDistance, hexagonColor, false, hexagonColor);\n    \n    float centralShapeDistance = getSDFIntersection(centralSphereDistance, centralSphereSDF.color,\n                       \t\t\t\t\t\t\t\thexagonDistance, hexagonColor, colorInMinDistance);\n    \n    return centralShapeDistance;\n}\n   \nfloat getDistanceToCombineSDF_Hole(const vec3 pointWS, const float stringSwingRotation,\n                                   const float stringRotation, out vec3 colorInMinDistance)\n{\n    float holesOpenedPercent = 1. - smoothstep(HOLES_FULLY_OPENED_ANGLE, HOLES_START_OPENING_ANGLE,\n                                               abs(stringSwingRotation));\n \n    // Cylinder hole opens only when it needs to pass string with weight\n    float holeRadius = holesOpenedPercent * HOLE_MAX_RADIUS;\n    // Matrix which translates hole to desired position and rotates cylinder so it will be parallel to floor\n    mat4 transformationMatrix = createTransformationMatrix(-CENTRAL_SHAPE_POSITION, vec3(90., 0., 0.));\n    // Matrix which rotates hole around World.up vector\n    mat4 upRotationMatrix = createRotationMatrix(vec3(0., stringRotation, 0.));\n    vec3 holePoint = (transformationMatrix * upRotationMatrix * vec4(pointWS, 1.)).xyz;\n    SDFCylinderData holeSDF = SDFCylinderData(CENTRAL_SPHERE_RADIUS*2., holeRadius, HOLE_COLOR);\n    float holeDistance = getDistanceToCylinderSDF(holePoint, holeSDF);\n    \n    // In additial to hole some gap for string is needed\n    float gapBoxThickness = holesOpenedPercent * GAP_THICKNESS;\n    vec3 gapBoxSize = vec3(CENTRAL_SPHERE_RADIUS*2., CENTRAL_SPHERE_RADIUS, gapBoxThickness);\n    vec3 gapBoxPosititon = -CENTRAL_SHAPE_POSITION - vec3(0., CENTRAL_SPHERE_RADIUS*0.5, 0.);\n    // Matrix which translates gap to desired position and rotates it correctly\n    transformationMatrix = createTransformationMatrix(gapBoxPosititon, vec3(0., 90. + stringRotation, 0.));\n    vec3 gapPoint = (transformationMatrix * vec4(pointWS, 1.)).xyz;\n    SDFBoxData gapSDF = SDFBoxData(gapBoxSize, GAP_COLOR);\n    float gapDistance = getDistanceToBoxSDF(gapPoint, gapSDF);\n    \n    // We need to unite cylindrical hole and rectangular gap \n    float fullHoleDistance = getSDFUnion(holeDistance, holeSDF.color,\n                                         gapDistance, gapSDF.color, false, colorInMinDistance);\n    \n    return fullHoleDistance;\n}   \n\nfloat getDistance(const vec3 pointWS, out vec3 colorInMinDistance, out int idOfHitSDF)\n{   \n    // First string with first weight\n    float firstStringSwingRotation = sin(iTime * SWING_SPEED_MULTIPLIER) * MAX_SWING_ANGLE;\n    float firstStringRotation = 0.;\n    vec3 firstStringColor;\n    float firstStringDistance = getDistanceToCombinedSDF_String(pointWS, firstStringSwingRotation,\n                                                                firstStringRotation, firstStringColor);\n    \n    // Second string with second weight\n    float secondStringSwingRotation = sin(iTime * SWING_SPEED_MULTIPLIER + (1./3.*PI)) * MAX_SWING_ANGLE;\n    float secondStringRotation = 1./3.*360.;\n    vec3 secondStringColor;\n    float secondStringDistance = getDistanceToCombinedSDF_String(pointWS, secondStringSwingRotation,\n                                                                 secondStringRotation, secondStringColor);\n    \n    // Union of two strings\n    float resultDistance = getSDFUnion(firstStringDistance, firstStringColor,\n                                       secondStringDistance, secondStringColor, false, colorInMinDistance);\n    \n    // Third string with third weight\n    float thirdStringSwingRotation = sin(iTime * SWING_SPEED_MULTIPLIER + (2./3.*PI)) * MAX_SWING_ANGLE;\n    float thirdStringRotation = 2./3.*360.;\n    vec3 thirdStringColor;\n    float thirdStringDistance = getDistanceToCombinedSDF_String(pointWS, thirdStringSwingRotation,\n                                                                thirdStringRotation, thirdStringColor);\n    \n    // Union of all strings\n    resultDistance = getSDFUnion(thirdStringDistance, thirdStringColor,\n                                 resultDistance, colorInMinDistance, false, colorInMinDistance);\n    \n    // Central shape (box-sphere intersection)\n    vec3 centralShapeColor;\n    float centralShapeDistance = getDistanceToCombinedSDF_CentralShape(pointWS, centralShapeColor);\n    \n    // Hole of first string\n    vec3 firstHoleColor;\n    float firstHoleDistance = getDistanceToCombineSDF_Hole(pointWS, firstStringSwingRotation,\n                                                           firstStringRotation, firstHoleColor);\n    \n    // Hole of second string\n    vec3 secondHoleColor;\n    float secondHoleDistance = getDistanceToCombineSDF_Hole(pointWS, secondStringSwingRotation,\n                                                            secondStringRotation, secondHoleColor);\n    \n    vec3 holeColor;\n    // Union of two holes\n    float allHolesDistance = getSDFUnion(firstHoleDistance, firstHoleColor,\n                                         secondHoleDistance, secondHoleColor, false, holeColor);\n    \n    // Hole of third string\n    vec3 thirdHoleColor;\n    float thirdHoleDistance = getDistanceToCombineSDF_Hole(pointWS, thirdStringSwingRotation,\n                                                           thirdStringRotation, thirdHoleColor);\n    \n    // Union of all holes\n    allHolesDistance = getSDFUnion(allHolesDistance, holeColor,\n                                   thirdHoleDistance, thirdHoleColor, false, holeColor);\n    \n    // Removed all holes from central shape\n\tcentralShapeDistance = getSDFDifference(centralShapeDistance, centralShapeColor, \n                                            allHolesDistance, holeColor, centralShapeColor);\n\n    // Union of central shape and both strings\n    resultDistance = getSDFUnion(centralShapeDistance, centralShapeColor,\n                                 resultDistance, colorInMinDistance, false, colorInMinDistance);\n    \n    // We have only one SDF object\n    idOfHitSDF = 0;\n    return resultDistance;\n}\n\n////////////////////////////////////////////// END OF CHANGEABLE CODE\n\nfloat getDistance(const vec3 pointWS)\n{\n    vec3 dummyColor;\n    int dummyIdOfSDF;\n    return getDistance(pointWS, dummyColor, dummyIdOfSDF);\n}\n\n// Basic ray march - returns distance to closest SDF object\nfloat marchRayBasic(const vec3 rayOrigin, const vec3 rayDir, const float distanceFromRayOrigin,\n                    out vec3 hitPointColor, out int hitPointSDFId)\n{\n    for (float distanceTraveledSoFar=distanceFromRayOrigin; distanceTraveledSoFar<MAX_RAY_LENGTH;)\n    {\n        vec3 hitPoint = rayOrigin + rayDir * distanceTraveledSoFar;\n        float curPointDistance = getDistance(hitPoint, hitPointColor, hitPointSDFId);\n        if (curPointDistance < MIN_DISTANCE_TO_ASSUME_RAY_HIT)\n         \treturn distanceTraveledSoFar;\n        distanceTraveledSoFar += curPointDistance;\n    }\n    return INVALID_DISTANCE;\n}\n\n// Returns distance from ray origin to floor, also returns checkerboarded color in hit point\nfloat calculateFloorColor(const vec3 rayDir, const vec3 rayOrigin, out vec3 checkerboardColor)\n{\n    // Floor is always directed up\n    vec3 floorPlaneNormal = FLOOR_NORMAL;\n    vec3 floorPlaneCenter = vec3(0., FLOOR_Z_POSITION, 0.);\n    \n    float angle = dot(floorPlaneNormal, rayDir);\n    // If floor and ray are not parallel\n    if (angle < -EPSILON)\n    {\n        // Some math to calculate intersection point between plane and ray\n        vec3 floorRayOriginVec = rayOrigin - floorPlaneCenter;\n        float distanceToIntersectionPoint = - dot(floorRayOriginVec, floorPlaneNormal) /\n            \t\t\t\t\t\t\t\t  dot(rayDir, floorPlaneNormal);\n        vec3 hitPoint = rayOrigin + distanceToIntersectionPoint * rayDir;\n        \n        // Checkerboard index of calculated intersection point\n        ivec3 hitPointCheckerboardIndex = ivec3(greaterThanEqual(mod(hitPoint, 2.), vec3(1.)));\n    \tcheckerboardColor = bool(hitPointCheckerboardIndex.x ^ hitPointCheckerboardIndex.z) ?\n                 \t\t\t     FLOOR_FIRST_COLOR : FLOOR_SECOND_COLOR;\n        \n        return distanceToIntersectionPoint;\n    }\n    \n    // Ray hasn't hit floor\n    return INVALID_DISTANCE;\n}\n\nvec3 calculateBackgroundColor(const vec2 fragCoord)\n{\n    vec2 screenUV = fragCoord / iResolution.xy;\n    return BACKGROUND_COLOR * smoothstep(1., 0., abs(.5 - screenUV.y));\n}\n\nvec3 calculateNormal(const vec3 hitPoint)\n{    \n    float normalX = getDistance(hitPoint + vec3(EPSILON, 0., 0.)) -\n        \t\t\tgetDistance(hitPoint - vec3(EPSILON, 0., 0.));\n    float normalY = getDistance(hitPoint + vec3(0., EPSILON, 0.)) -\n        \t\t\tgetDistance(hitPoint - vec3(0., EPSILON, 0.));\n    float normalZ = getDistance(hitPoint + vec3(0., 0., EPSILON)) -\n        \t\t\tgetDistance(hitPoint - vec3(0., 0., EPSILON));\n    return normalize(vec3(normalX, normalY, normalZ));\n}\n\nvec3 calculatePhong(const vec3 rayDir, const vec3 hitPoint, const vec3 hitNormal, const vec3 hitPointColor)\n{\n    float ambientValue = MATERIAL_AMBIENT_STRENGTH;\n    \n    vec3 invLightDir = normalize(LIGHT_POSITION - hitPoint);\n    float ndotl = max(dot(hitNormal, invLightDir), 0.);\n    float diffuseValue = MATERIAL_DIFFUSE_STRENGTH * ndotl;\n    \n    vec3 reflectDir = reflect(invLightDir, hitNormal);\n    float vdotr = max(dot(rayDir, reflectDir), 0.);\n    float specularValue = MATERIAL_SPECULAR_STRENGTH * pow(vdotr, MATERIAL_SHININESS);\n    \n    vec3 resultColor = (ambientValue + diffuseValue + specularValue) * LIGHT_COLOR * hitPointColor;\n    return resultColor;\n}    \n\nfloat calculateShadow(const vec3 hitPoint, const vec3 hitNormal)\n{\n    vec3 rayDir = normalize(LIGHT_POSITION - hitPoint);\n    // Affects maximum number of ray marching iterations (we don't want to calculate shader behind the light)\n    float distanceToLight = length(LIGHT_POSITION - hitPoint);\n    float rayDotNormal = dot(rayDir, hitNormal);\n    \n    // Accumulated soft shadows factor from all objects close enough to ray\n    float accumulatedSoftShadowsFactor = 1.;\n    // Used in loop to store value of minimum soft shadows factor of single object at ray's line\n    float minSoftShadowsFactor = 1.;\n    // Stores id of SDF which was the closest to ray in previous frames\n    int idOfPreviouslyClosestSDF = -1;\n    \n    // Ray from hit point to light position\n    for (float distanceTraveledSoFar=DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE_SHADOW;\n         distanceTraveledSoFar<distanceToLight;)\n    {\n        vec3 rayMarchPoint = hitPoint + rayDir * distanceTraveledSoFar;\n        vec3 rayMarchPointColor;\n        int rayMarchPointSDFId;\n        float rayMarchPointDistance = getDistance(rayMarchPoint, rayMarchPointColor, rayMarchPointSDFId);\n        \n        // If shadow ray hit something we want to have full shade\n        if (rayMarchPointDistance < MIN_DISTANCE_TO_ASSUME_RAY_HIT)\n        {\n            // Light is occluded by some objects, so we don't want soft shadows\n            accumulatedSoftShadowsFactor = 0.;\n            break;\n        }\n        \n        // Soft shadows factor of SDF identified by id idOfHitSDF\n        float curSoftShadowsFactor = PENUMBRA_FACTOR*rayMarchPointDistance/distanceTraveledSoFar;\n        \n        // We're constantly moving toward the light source\n        distanceTraveledSoFar += rayMarchPointDistance;\n        \n#if USE_SDF_IDS == 1\n        // If ID of closest SDF changes we need to reset min soft shadows factor\n        if (idOfPreviouslyClosestSDF != rayMarchPointSDFId)\n        {\n            accumulatedSoftShadowsFactor *= minSoftShadowsFactor;\n            minSoftShadowsFactor = 1.;\n            idOfPreviouslyClosestSDF = rayMarchPointSDFId;\n        }\n#endif\n        \n        minSoftShadowsFactor = min(minSoftShadowsFactor, curSoftShadowsFactor);\n    }\n    \n    accumulatedSoftShadowsFactor *= minSoftShadowsFactor;\n    \n    float shadowFactor = clamp(rayDotNormal * accumulatedSoftShadowsFactor, 1. - SHADOW_INTENSITY, 1.);\n    return shadowFactor;\n}\n\nfloat calculateAmbientOcclusion(const vec3 hitPoint, const vec3 hitNormal)\n{\n    float ambientOcclusionValue = 0.;\n    // Weight of first step is 1.\n    float curWeight = 1.;\n    for (float i=0.; i<AO_STEPS_NUMBER; i++)\n    {\n        float distanceFromHitPoint = AO_FIRST_STEP_DISTANCE_FROM_HIT_POINT +\n            \t\t\t\t\t\t AO_DISTANCE_BETWEEN_STEPS * i;\n        vec3 aoPosition = hitPoint + hitNormal * distanceFromHitPoint;\n        float aoDistance = getDistance(aoPosition);\n        float aoValueInStep = (distanceFromHitPoint-aoDistance) * curWeight;\n        ambientOcclusionValue += aoValueInStep;\n        curWeight *= AO_EACH_STEP_WEIGHT_MODIFIER;\n    }\n    ambientOcclusionValue *= AO_STRENGTH;\n    float result = clamp(1. - ambientOcclusionValue, 1. - AO_INTENSITY, 1.);\n    return result;\n}\n\nvec3 calculateReflections(const vec3 hitPoint, const vec3 hitNormal, const vec3 hitPointColorSoFar,\n                          const vec3 baseRayDir, const vec3 backgroundColor)\n{\n    vec3 reflectionRayDir = normalize(reflect(baseRayDir, hitNormal));\n    vec3 reflectionResultColor, reflectionHitPointColor;\n    int reflectionHitSDFId;\n    float distanceToReflectionRayHit = marchRayBasic(hitPoint, reflectionRayDir,\n\t\tREFLECTIONS_DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE,\n        reflectionHitPointColor, reflectionHitSDFId);\n    // If we haven't hit anything, we just hit sky\n    if (distanceToReflectionRayHit == INVALID_DISTANCE)\n        reflectionResultColor = backgroundColor;\n    else\n    {\n        vec3 reflectionHitPoint = hitPoint + reflectionRayDir*distanceToReflectionRayHit;\n        vec3 reflectionHitPointNormal = calculateNormal(reflectionHitPoint);\n        reflectionResultColor = calculatePhong(reflectionRayDir, reflectionHitPoint,\n                                         \t   reflectionHitPointNormal, reflectionHitPointColor);\n        reflectionResultColor *= calculateShadow(reflectionHitPoint, reflectionHitPointNormal);\n    }\n    // We want reflections only on floor, so if we're not on floor our reflection color is\n    // hit point color so far (reflection color won't break below mix instruction)\n    return mix(hitPointColorSoFar, reflectionResultColor, REFLECTIONS_INTENSITY);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 resultColor;\n#if QUALITY >= 2\n    // Sum of colors sampled by MSAA\n    vec3 allResultColors = vec3(0.);\n    for (int i=ALL_MSAA_SAMPLE_POINTS.length()-1; i>=0; i--)\n    {\n        fragCoord = trunc(fragCoord) + ALL_MSAA_SAMPLE_POINTS[i];\n#endif\n        // Color of the background - used when nothing else hasn't been hit\n        vec3 backgroundColor = calculateBackgroundColor(fragCoord);\n        \n        // Data of our main ray\n        vec3 rayOrigin, rayDir;\n        getRayData(fragCoord, iResolution, iTime, rayOrigin, rayDir);\n        \n        // Result of our main ray\n        vec3 hitPointColor;\n        int hitPointIdOfSDF;\n        float distanceToHitPoint = marchRayBasic(rayOrigin, rayDir, 0., hitPointColor, hitPointIdOfSDF);\n        vec3 hitPoint = rayOrigin + rayDir * distanceToHitPoint;\n        \n        vec3 hitPointNormal = FLOOR_NORMAL;\n        bool floorHit = false;\n        // We haven't hit any SDF, so maybe we hit floor?\n        if (distanceToHitPoint == INVALID_DISTANCE)\n        {\n            distanceToHitPoint = calculateFloorColor(rayDir, rayOrigin, hitPointColor);\n            floorHit = distanceToHitPoint != INVALID_DISTANCE;\n            hitPoint = rayOrigin + rayDir * distanceToHitPoint;\n        }\n        else\n            hitPointNormal = calculateNormal(hitPoint);\n        \n        // Values which blends between hit point color and background\n        float backgroundBlendValue = 1.;\n        // If we have hit some SDF or floor\n        if (distanceToHitPoint != INVALID_DISTANCE)\n        {\n            resultColor = calculatePhong(rayDir, hitPoint, hitPointNormal, hitPointColor);\n#if QUALITY >= 1\n            resultColor *= calculateShadow(hitPoint, hitPointNormal);\n            resultColor *= calculateAmbientOcclusion(hitPoint, hitPointNormal);\n            // We want to have reflections only on floor\n            if (floorHit)\n            \tresultColor = calculateReflections(hitPoint, hitPointNormal, resultColor, rayDir,\n            \t\t\t\t\t\t\t\t   \t   backgroundColor);\n#endif\n            backgroundBlendValue = smoothstep(FLOOR_START_FADING_EDGE, FLOOR_STOP_FADING_EDGE, distanceToHitPoint);\n        }\n        \n        resultColor = mix(resultColor, backgroundColor, backgroundBlendValue);\n        \n#if QUALITY >= 2\n        allResultColors += resultColor;\n    }\n    resultColor = allResultColors / float(ALL_MSAA_SAMPLE_POINTS.length());\n#endif\n    \n    // Gamma correction\n    fragColor = vec4(pow(resultColor, vec3(1./ 2.2)), 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// From 0 to 2 (highest)\n#define QUALITY 1\n// If 1 when ray will hit some SDF, it's ID will be returned. That give us ability to\n// (among others) use cumulative soft shadows (soft shadows from more than one objects)\n#define USE_SDF_IDS 0\n// If 1 simple positions of SDF will be used instead of complex matrix transformations.\n// Beside that in SDF struct there is additional place for SDF position.\n#define USE_SIMPLE_SDF_POSITIONS 0\n\n// Max length of the ray used in basic ray marching (depends on size of the biggest SDF)\n#define MAX_RAY_LENGTH 19.\n#define RAY_ORIGIN vec3(11.0, 5.0, 11.0)\n// If distance from point to SDF shape is smaller that this, we assume ray hittted something\n#define MIN_DISTANCE_TO_ASSUME_RAY_HIT 1e-3\n\n#define CAMERA_MOVEMENT_SPEED -30.\n#define CAMERA_INV_DISTANCE_MULTIPLIER 3.7\n\n#define BACKGROUND_COLOR (vec3(40., 80., 126.) / 255.)\n\n#define FLOOR_FIRST_COLOR vec3(0.9)\n#define FLOOR_SECOND_COLOR vec3(0.6)\n#define FLOOR_Z_POSITION -0.8\n#define FLOOR_NORMAL vec3(0., 1., 0.)\n#define FLOOR_START_FADING_EDGE 25.\n#define FLOOR_STOP_FADING_EDGE 50.\n\n// How many samplings ambient occlusion will have\n#define AO_STEPS_NUMBER 5.\n// How far from hit point first step of ambient occlusion needs to be performed\n#define AO_FIRST_STEP_DISTANCE_FROM_HIT_POINT 0.005\n// Value of distance between all AO steps\n#define AO_DISTANCE_BETWEEN_STEPS 0.02\n// How much weight of each step changes\n#define AO_EACH_STEP_WEIGHT_MODIFIER 0.95\n// Multiplier of AO effect\n#define AO_STRENGTH 3.\n#define AO_INTENSITY 0.99\n\n#define REFLECTIONS_INTENSITY 0.2\n\n#define SHADOW_INTENSITY 0.9\n// How soft soft-shadows will be\n#define PENUMBRA_FACTOR 24.\n\n#define LIGHT_COLOR vec3(1., 1., 1.)\n#define LIGHT_POSITION (vec3(40., 80., 60.)*0.2)\n\n#define MATERIAL_SHININESS 4.\n#define MATERIAL_AMBIENT_STRENGTH 0.04\n#define MATERIAL_DIFFUSE_STRENGTH 0.8\n#define MATERIAL_SPECULAR_STRENGTH 0.6\n\n// How smooth SDF union will be\n#define SDF_UNION_SMOOTHNESS 16.\n\n////////////////////////////////////////////// END OF CHANGEABLE CODE\n\n#define EPSILON 1e-5\n#define PI 3.1416\n\n// To start calculate soft shadows of given point, we're taking hit point and move it by this value in\n// direction of the light source\n#define DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE_SHADOW 1e-2\n// To start calculate reflections of given point, we're taking hit point and move it by this value in\n// direction of reflected camera direction\n#define REFLECTIONS_DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE 1e-2\n// Value used when we want to show that calculated distance is invalid\n#define INVALID_DISTANCE -1.\n\nconst vec2[] ALL_MSAA_SAMPLE_POINTS = vec2[](\n    vec2(6./16., 2./16.), vec2(14./16., 6./16.), vec2(2./16., 10./16.), vec2(10./16., 14./16.)\n);\n\n\n////////////////////////////////////////////// Basic SDF functions\n\nstruct SDFSphereData\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    vec3 position;\n#endif\n    float radius;\n    vec3 color;\n#if USE_SDF_IDS == 1\n    int id;\n#endif\n};\n    \nstruct SDFBoxData\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    vec3 position;\n#endif\n    vec3 size;\n    vec3 color;\n#if USE_SDF_IDS == 1\n    int id;\n#endif\n};\n    \nstruct SDFCylinderData\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    vec3 position;\n#endif\n    float height;\n    float radius;\n    vec3 color;\n#if USE_SDF_IDS == 1\n    int id;\n#endif\n};\n\nfloat getDistanceToSphereSDF(vec3 pointWS, const vec3 spherePosition, const float sphereRadius)\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    pointWS -= spherePosition;\n#endif\n    return length(pointWS) - sphereRadius;\n}\n    \nfloat getDistanceToSphereSDF(vec3 pointWS, const SDFSphereData sphereData)\n{\n    return getDistanceToSphereSDF(pointWS,\n#if USE_SIMPLE_SDF_POSITIONS == 1\n                                  sphereData.position,\n#else\n                                  vec3(0.),\n#endif\n                                  sphereData.radius);\n}\n\nfloat getDistanceToBoxSDF(vec3 pointWS, const vec3 boxPosition, const vec3 boxSize)\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    pointWS -= boxPosition;\n#endif\n    vec3 boxHalfSize = boxSize / 2.;\n    vec3 distanceToBox = abs(pointWS) - boxHalfSize;\n    return length(max(distanceToBox,0.0)) +\n           min(max(distanceToBox.x,max(distanceToBox.y,distanceToBox.z)),0.0);\n}\n\nfloat getDistanceToBoxSDF(vec3 pointWS, const SDFBoxData boxData)\n{\n    return getDistanceToBoxSDF(pointWS,\n#if USE_SIMPLE_SDF_POSITIONS == 1\n                               boxData.position,\n#else\n                               vec3(0.),\n#endif\n                               boxData.size);\n}\n\nfloat getDistanceToCylinderSDF(vec3 pointWS, const vec3 cylinderPosition,\n                               const float cylinderHeight, const float cylinderRadius)\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    pointWS -= cylinderPosition;\n#endif\n    float halfHeight = cylinderHeight * 0.5;\n    vec2 distanceToCylinder = abs(vec2(length(pointWS.xz),pointWS.y)) -\n        \t\t\t\t      vec2(cylinderRadius,halfHeight);\n  \treturn min(max(distanceToCylinder.x,distanceToCylinder.y),0.0) +\n           length(max(distanceToCylinder,0.0));    \n}\n\nfloat getDistanceToCylinderSDF(vec3 pointWS, const SDFCylinderData cylinderData)\n{\n    return getDistanceToCylinderSDF(pointWS,\n#if USE_SIMPLE_SDF_POSITIONS == 1\n                                    cylinderData.position,\n#else\n                                    vec3(0.),\n#endif\n                                    cylinderData.height, cylinderData.radius);\n}\n\n////////////////////////////////////////////// Functions to intersect/unite/substract different SDF\n\nfloat getSDFBlend(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                  const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                  const float blendValue, out vec3 resultColor, out int resultSDFId)\n{\n    float resultDistance = mix(distanceA, distanceB, blendValue);\n    resultColor = mix(distanceAColor, distanceBColor, blendValue);\n#if USE_SDF_IDS == 1\n    if (abs(resultDistance - distanceA) < abs(resultDistance - distanceB))\n        resultSDFId = distanceASDFId;\n    else\n        resultSDFId = distanceBSDFId;\n#endif\n    return resultDistance;\n}\n\nfloat getSDFBlend(const float distanceA, const vec3 distanceAColor,\n                  const float distanceB, const vec3 distanceBColor,\n                  const float blendValue, out vec3 resultColor)\n{\n    int dummyResultSDFId;\n    return getSDFBlend(distanceA, distanceAColor, 0, distanceB, distanceBColor, 0,\n                       blendValue, resultColor, dummyResultSDFId);\n}\n\nfloat getSDFIntersection(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                         const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                         out vec3 resultColor, out int resultSDFId)\n{\n    if (max(distanceA, distanceB) == distanceA)\n    {\n        resultColor = distanceAColor;\n        resultSDFId = distanceASDFId;\n        return distanceA;\n    }\n    resultColor = distanceBColor;\n    resultSDFId = distanceBSDFId;\n    return distanceB;\n}\n\nfloat getSDFIntersection(const float distanceA, const vec3 distanceAColor,\n                         const float distanceB, const vec3 distanceBColor,\n                         out vec3 resultColor)\n{\n    int dummyResultSDFId;\n    return getSDFIntersection(distanceA, distanceAColor, 0, distanceB, distanceBColor, 0,\n                              resultColor, dummyResultSDFId);\n}\n\nfloat getSDFUnion(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                  const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                  const bool useSmoothness, out vec3 resultColor, out int resultSDFId)\n{\n    bool distanceAIsCloser = false;\n    float resultDistance;\n    if (useSmoothness)\n    {\n     \tfloat res = exp(-SDF_UNION_SMOOTHNESS*distanceA) + exp(-SDF_UNION_SMOOTHNESS*distanceB);   \n        resultDistance = -log(max(EPSILON,res)) / SDF_UNION_SMOOTHNESS;\n        distanceAIsCloser = abs(resultDistance - distanceA) < abs(resultDistance - distanceB);\n    }\n    else\n    {\n        resultDistance = min(distanceA, distanceB);\n        distanceAIsCloser = resultDistance == distanceA;\n    }\n    \n    if (distanceAIsCloser)\n    {\n        resultColor = distanceAColor;\n        resultSDFId = distanceASDFId;\n    }\n    else\n    {\n        resultColor = distanceBColor;\n    \tresultSDFId = distanceBSDFId;\n    }\n    return resultDistance;\n}\n                              \nfloat getSDFUnion(const float distanceA, const vec3 distanceAColor,\n                  const float distanceB, const vec3 distanceBColor,\n                  const bool useSmoothness, out vec3 resultColor)\n{\n    int dummyResultSDFId;\n    return getSDFUnion(distanceA, distanceAColor, 0, distanceB, distanceBColor, 0,\n                       useSmoothness, resultColor, dummyResultSDFId);\n}\n                              \nfloat getSDFDifference(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                       const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                       out vec3 resultColor, out int resultSDFId)\n{\n    // Difference is just a intersection between shape A and inversion of shape B\n    return getSDFIntersection(distanceA, distanceAColor, distanceASDFId,\n                              -distanceB, distanceBColor, distanceBSDFId,\n                              resultColor, resultSDFId);\n}\n\nfloat getSDFDifference(const float distanceA, const vec3 distanceAColor,\n                       const float distanceB, const vec3 distanceBColor,\n                       out vec3 resultColor)\n{\n    // Difference is just a intersection between shape A and inversion of shape B\n    return getSDFIntersection(distanceA, distanceAColor, -distanceB, distanceBColor, resultColor);\n}\n\n////////////////////////////////////////////// Functions which helps with creating matrix that\n// can help with rotating/moving SDF\n\nmat4 createTranslationMatrix(vec3 position)\n{\n    mat4 translationMatrix = mat4(vec4(1., 0., 0., 0.), vec4(0., 1., 0., 0.),\n                                  vec4(0., 0., 1., 0.), vec4(position.x, position.y, position.z, 1.));\n    return translationMatrix;\n}\n\nmat4 createRotationMatrix(vec3 rotationEuler)\n{\n    // Input is in degrees, but to calculate everything property we need radians\n    vec3 rotationTheta = rotationEuler * (PI / 180.);\n    \n    vec3 cosTheta = cos(rotationTheta);\n    vec3 sinTheta = sin(rotationTheta);\n    \n    mat4 rotateAroundXMatrix = mat4(vec4(1., 0., 0., 0.), vec4(0., cosTheta.x, sinTheta.x, 0.),\n                             \t\tvec4(0., -sinTheta.x, cosTheta.x, 0.), vec4(0., 0., 0., 1.));\n    mat4 rotateAroundYMatrix = mat4(vec4(cosTheta.y, 0., -sinTheta.y, 0.), vec4(0., 1., 0., 0.),\n                                    vec4(sinTheta.y, 0., cosTheta.y, 0.), vec4(0., 0., 0., 1.));\n    mat4 rotateAroundZMatrix = mat4(vec4(cosTheta.z, sinTheta.z, 0., 0.), vec4(-sinTheta.z, cosTheta.z, 0., 0.),\n                                    vec4(0., 0., 1., 0.), vec4(0., 0., 0., 1.));\n    // Order of multiplication is crucial!\n    mat4 rotationMatrix = rotateAroundZMatrix * rotateAroundYMatrix * rotateAroundXMatrix;\n    \n    return rotationMatrix;\n}\n\n// Creates classic matrix which translates and then rotates\nmat4 createTransformationMatrix(vec3 position, vec3 rotationEuler)\n{\n    mat4 translationMatrix = createTranslationMatrix(position);\n    mat4 rotationMatrix = createRotationMatrix(rotationEuler); \n    \n    // Scale in case of ray marching needs to be applied in slightly different way, because\n    // result of getDistance function needs to be modified. So we're not adding\n    // scale matrix\n    \n    // Order of multiplication is crucial!\n    mat4 transformationMatrix = rotationMatrix * translationMatrix; // * scaleMatrix;\n    return transformationMatrix;    \n}\n\n// Creates matrix which rotates around given point\nmat4 createRotateAroundPointMatrix(vec3 point, vec3 rotationEuler)\n{\n    // When rotating around a point we need to use two translation matrices \n    mat4 translationMatrix = createTranslationMatrix(point);\n    mat4 secTranslationMatrix = createTranslationMatrix(-point);\n    mat4 rotationMatrix = createRotationMatrix(rotationEuler);\n    \n    return translationMatrix * rotationMatrix * secTranslationMatrix;\n}\n\n////////////////////////////////////////////// Function which creates basic ray\n\nvoid getRayData(const vec2 screenCoord, const vec3 iResolution, const float iTime,\n                out vec3 rayOrigin, out vec3 rayDir)\n{\n    vec2 screenUV = screenCoord / iResolution.xy;\n    vec2 screenPos = 2. * screenUV - 1.;\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    rayOrigin = RAY_ORIGIN;\n    vec3 rayTargetPoint = vec3(0.);\n    \n    // We want to move camera around center of the scene\n    float cameraAngle = iTime * CAMERA_MOVEMENT_SPEED;    \n    mat4 rotateCameraMatrix = createRotateAroundPointMatrix(vec3(0.), vec3(0., cameraAngle, 0.));\n    rayOrigin = (rotateCameraMatrix * vec4(rayOrigin, 1.)).xyz;\n        \n    vec3 worldUp = vec3(0., 1., 0.);\n    vec3 cameraForward = normalize(rayTargetPoint - rayOrigin);\n    vec3 cameraRight = normalize(cross(cameraForward, worldUp));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n    mat3 cameraMatrix = mat3(cameraRight, cameraUp, cameraForward);\n    \n    rayDir = normalize(cameraMatrix * vec3(screenPos, CAMERA_INV_DISTANCE_MULTIPLIER));\n}","name":"Common","description":"","type":"common"}]}