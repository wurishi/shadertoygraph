{"ver":"0.1","info":{"id":"dtfGW2","date":"1681393615","viewed":121,"name":"Hall of Mirrors + Distortion","username":"durden","description":"Adding a smooth noise distortion effect to hall of mirrors","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["mirror","redgiant","aftereffects","hallofmirrors","plugin","obsolete"],"hasliked":0,"parentid":"dsSGWm","parentname":"Hall of Mirrors"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Faithful remake of the deleted \"Hall of Mirrors\" effect by Red Giant\n// Recreated by MysteryPancake\n\nfloat random(float p) {\n  return fract(sin(p)*10000.);\n}\n\nfloat noise(vec2 p) {\n  return random(p.x + p.y*10000.);\n}\n\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\n\nfloat smoothNoise(vec2 p) {\n  vec2 inter = smoothstep(0., 1., fract(p));\n  float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  return mix(s, n, inter.y);\n  return noise(nw(p));\n}\n\nfloat movingNoise(vec2 p) {\n  float total = 0.0;\n  total += smoothNoise(p     - iTime);\n  total += smoothNoise(p*2.  + iTime) / 2.;\n  total += smoothNoise(p*4.  - iTime) / 4.;\n  total += smoothNoise(p*8.  + iTime) / 8.;\n  total += smoothNoise(p*16. - iTime) / 16.;\n  total /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n  return total;\n}\n\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Number of images to display\n\tint images = 8;\n\t// Scale factor per image\n\tfloat scale = 0.9 + cos(iTime * 2.0) * 0.1;\n\t// Rotation per image in degrees\n\tfloat rotation = sin(iTime * 0.5) * 45.0;\n\t// Position offset per image in normalized coordinates (0-1)\n\tvec2 offset = iMouse.z > 0.0 ? vec2(iMouse.xy / iResolution.xy) : 0.25 + vec2(cos(iTime), sin(iTime)) * 0.25;\n\t// Composite behind or in front\n\tbool behind = false;\n\n\tfloat rad = radians(-rotation);\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(0.0);\n    \n    \n    \n    // Modify that X coordinate by the sin of y to oscillate back and forth up in this.\n    //uv.x += sin(uv.y*10.0+iTime)/10.0;\n    float strength = .5;\n    uv.x += movingNoise(uv)*strength;\n    // The theory be that you turn this sucka into basically a graph \n\t// (like on them TI-80 whatevers)\n\t// The sin of y says that y at 0 is the start of your sin wave\n\t// Then the bottom of your image is the end of one sin wave\n\t// (go ahead and delete them 10s and give her a try)\n\t// This will show 3 images waving back and forth like the JUST DON'T CARE\n\t// That's because ya'll is waving the x from -1 to 1 (-1, 0, 1)\n\t// So we need to get all amplitude and freqency on this bitch\n\t// That's where the 10s come in, and they could be any one of them numbers\n\t// the multply by 10 increases the frequency making the waves tight or loose as ... well ... you know...\n\t// the divide by 10 decreases that amplitude til it's wavy as FUCK\n\t// So play around with them shits.\n\n\tfor (int i = 0; i < images; ++i) {\n\t\t// SCALING: Offset, apply scale, reset offset\n\t\tvec2 pos = uv - offset;\n\t\tpos /= pow(scale, float(i));\n\t\tpos += offset;\n\n\t\t// ROTATION\n\t\tfloat theta = rad * float(i);\n\t\tfloat cs = cos(theta);\n\t\tfloat sn = sin(theta);\n\t\t// Offset to center, fix aspect ratio\n\t\tpos -= vec2(0.5);\n\t\tpos *= iResolution.xy;\n\t\t// Rotate coordinate space\n\t\tpos = vec2(pos.x * cs - pos.y * sn, pos.x * sn + pos.y * cs);\n\t\t// Reset aspect ratio, reset offset\n\t\tpos /= iResolution.xy;\n\t\tpos += vec2(0.25, 0.5);\n\n\t\t// Prevent out of bounds bugs, could also be done with clamp\n\t\tif (pos.x >= 0.0 && pos.x <= 1.0 && pos.y >= 0.0 && pos.y <= 1.0) {\n\t\t\tvec4 color = texture(iChannel0, pos);\n            // Alpha blending, see shadertoy.com/view/msSGDm for working example\n\t\t\tif (behind) {\n\t\t\t\tfragColor += (1.0 - fragColor.a) * color;\n\t\t\t} else {\n\t\t\t\tfragColor = color + (1.0 - color.a) * fragColor;\n\t\t\t}\n\t\t}\n\t}\n}","name":"Image","description":"","type":"image"}]}