{"ver":"0.1","info":{"id":"ctB3zh","date":"1672803423","viewed":98,"name":"Implicit Graphs SDF AA Attempt 1","username":"Fasteroid","description":"An attempt at adding antialiasing to the previous shader.  The initial setup for JFA is supersampled.\n\nReferences:\nhttps://www.shadertoy.com/view/Mdy3DK - JFA: Points\nhttps://www.shadertoy.com/view/lsXGzf - Keyboard Input","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["2d","math","sdf","antialias","distance","desmos"],"hasliked":0,"parentid":"dtlGzB","parentname":"Implicit Graphs SDF"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int KEY_SPACE = 32;\n\n//============================================================\n\nvec4 getPixelA( in vec2 coord ){\n    return texture( iChannel0, coord / iResolution.xy);\n}\n\nvec4 getPixelB( in vec2 coord ){\n    return texture( iChannel1, coord / iResolution.xy);\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float radius = iMouse.x / 50.0;\n    if( radius == 0.0 ) radius = 3.0;\n\n    // get the data for this pixel\n    vec4 jfa_a = getPixelA( fragCoord );\n    vec4 jfa_b = getPixelB( fragCoord );\n   \n    float distA = JFA_getDistance( jfa_a );\n    float distB = JFA_getDistance( jfa_b );\n    \n    float dist = max(distA,distB);\n    \n    vec3 color = vec3( clamp(radius-dist,0.0,1.0) );\n    \n    if( texelFetch( iChannel2, ivec2(KEY_SPACE,0), 0 ).x > 0.0 ){\n        color = color * 0.25 + vec3( ( 64.0 + dist) / 128.0 ) * 0.75;\n    };\n    \n    fragColor = vec4(color, 1.0);\n    \n    // fragColor = vec4(0.0,0.0,20.0,0.0) + jfa * vec4(0.001,0.001,20.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    // periodic steps\n    float stepFrame1 = floor(float(iFrame) / c_frameStepDelay) - 1.0;\n    float stepFrame2 = stepFrame1 - c_maxSteps;\n    \n    bool tick = mod(float(iFrame), c_frameStepDelay) == 0.0;\n    \n    if ( tick && stepFrame1 == 0.0){\n        fragColor = Setup( fragCoord, 1.0, iChannelResolution[0].xy );\n    }\n    else if ( tick && stepFrame1 < c_maxSteps) {\n        fragColor = Step( fragCoord, stepFrame1, iChannelResolution[0].xy, iChannel0 );\n    }\n    else {\n        fragColor = getPixel(fragCoord, iChannelResolution[0].xy, iChannel0);\n    }\n        \n}\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    // periodic steps\n    float stepFrame1 = floor(float(iFrame) / c_frameStepDelay) - 1.0;\n    float stepFrame2 = stepFrame1 - c_maxSteps;\n    \n    bool tick = mod(float(iFrame), c_frameStepDelay) == 0.0;\n    \n    if ( tick && stepFrame1 == 0.0){\n        fragColor = Setup( fragCoord, -1.0, iChannelResolution[0].xy );\n    }\n    else if ( tick && stepFrame1 < c_maxSteps) {\n        fragColor = Step( fragCoord, stepFrame1, iChannelResolution[0].xy, iChannel0 );\n    }\n    else {\n        fragColor = getPixel(fragCoord, iChannelResolution[0].xy, iChannel0);\n    }\n        \n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// how many frames between steps.  1.0 = full speed.\nconst float c_frameStepDelay = 4.0;\n\n// how many JFA steps to do.  2^c_maxSteps is max image size on x and y\nconst float c_maxSteps = 10.0;\n\n\nfloat dsm_rpow(float x, float y) {\n    if (x >= 0.0) return pow(x,y);\n    else {\n        float m = mod(y, 2.0);\n        if (m == 0.0) return pow(-x, y);\n        else if (m == 1.0) return -pow(-x, y);\n        else return pow(x, y);\n    }    \n}\n\nfloat glesmos_f0(float x, float y) { return (((((0.8)*(dsm_rpow((tanh(((1.4)*(sin(((5.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))))),(4.0))))+(dsm_rpow((sin(((atan(y,x))+((2.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))),(2.0))))-(0.7))+((0.1)/((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0))))));}\n\n// use any implicit function here!\nfloat f0( in vec2 fragCoord, in vec2 canvasSize ){\n    vec2 uv = fragCoord.xy - canvasSize / 2.0;\n    uv = uv * 0.01;\n    return uv.x * uv.x - uv.y;\n} \n\n//============================================================\n\nvec4 getPixel( in vec2 coord, in vec2 canvasSize, in sampler2D iChannel0 ){\n    return texture( iChannel0, coord / canvasSize);\n}\n\n//============================================================\n\nconst vec2 JFA_kernel[9] = vec2[9]( \n    vec2(-1.0,1.0)  , vec2(0.0,1.0)  , vec2(1.0,1.0)  ,\n    vec2(-1.0,0.0)  , vec2(0.0,0.0)  , vec2(1.0,0.0)  ,\n    vec2(-1.0,-1.0) , vec2(0.0,-1.0) , vec2(1.0,-1.0)\n);\n\nconst vec2 AA_kernel[4] = vec2[4](\n    vec2(0.0,0.0),\n    vec2(0.0,1.0),\n    vec2(1.0,0.0),\n    vec2(1.0,1.0)\n);\n\nconst vec4 JFA_undefined = vec4(0.0);\n\nvec4 newJFA (in vec2 seed, in float dist){\n    vec4 jfa = vec4(0.0);\n    jfa.xy = seed;\n    jfa[2] = dist;\n    jfa[3] = 1.0;  // a valid jfa object\n    return jfa;\n}\n\nbool JFA_isUndefined( in vec4 jfa ){\n    return jfa[3] == 0.0;\n}\n\nvec2 JFA_getSeed( in vec4 jfa ){\n    return jfa.xy;\n}\n\nfloat JFA_getDistance( in vec4 jfa ){\n    return jfa[2];\n}\n\n//============================================================\n\n\n// 0\nvec4 Setup(in vec2 fragCoord, in float direction, in vec2 canvasSize){\n    vec2 sampleSum = vec2(0.0);\n    float sampleCount = 0.0;\n    \n    for (int n = 0; n < 4; n++) {\n    \n        vec2 sampleCoord = fragCoord + AA_kernel[n] * 0.25;\n\n        float wasSampled = float( int( f0(sampleCoord, canvasSize) * direction < 0.0 ) );\n\n        sampleCount = sampleCount + wasSampled;\n        sampleSum = sampleSum + sampleCoord * wasSampled;\n\n    }\n    \n    if( sampleCount > 0.0 ) return newJFA( sampleSum / sampleCount , 0.0);\n    else return vec4(0.0);\n}\n\n// 1\nvec4 Step(in vec2 fragCoord, in float level, in vec2 canvasSize, in sampler2D iChannel0){\n\n    level = clamp(level, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level)-1.0);\n    \n    float bestDistance = 9999.0;\n    vec2  bestCoord    = vec2(0.0);\n    \n    for (int n = 0; n < 9; n++) {\n        \n        vec2 sampleCoord = fragCoord + JFA_kernel[n] * stepwidth;\n        vec4 jfa         = getPixel( sampleCoord, canvasSize, iChannel0 );\n\n        if( JFA_isUndefined(jfa) ) continue;\n        \n        vec2  seed = JFA_getSeed(jfa);\n        float dist = length( seed - fragCoord );\n\n        if (dist < bestDistance)\n        {\n            bestDistance = dist;\n            bestCoord    = seed;\n        }\n            \n    }\n    \n    return newJFA(bestCoord, bestDistance);\n}\n\n//============================================================","name":"Common","description":"","type":"common"}]}