{"ver":"0.1","info":{"id":"7lsGWf","date":"1623103541","viewed":273,"name":"atmospheric experiment 2","username":"bloodnok","description":"work in progress experiment to get some sort of semi-realistic planetary atmospheres.\nMouse to drag the sun around.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n/*\n\t@geofftnz\n\n\tforking someone's raytraced sphere in order to do some material testing.\n\n    atmospheric scattering attempt\n\n*/\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\n\treturn n;\n}\n\n\nfloat pointRayDistance(vec3 ro, vec3 rd, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\tif (cosvu<0.0) return length(p-ro);\n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\n// intersection through participating media (like atmospheres)\nstruct iMediaIntersection\n{\n    float tnear;   // first intersection\n    float tfar;    // last intersection\n    uint mnear;    // material first hit (atmosphere?)\n    uint mfar;     // material on second hit (atmosphere or ground)\n    vec3 nor;      // normal at solid intersection (material dependent)\n};\n\n\n// intersect ray ro+rd with sphere sph, with a ground height sphgnd\niMediaIntersection mSphere(in vec3 ro, in vec3 rd, in vec4 sph, in float sphgnd){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.tfar = -1.0;\n    res.mnear = 0u;\n    res.mfar = 0u;\n    res.nor = vec3(0.0,0.0,0.0);\n    \n    // outer sphere intersection\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n    \n\tif (h >= 0.0)\n    {\n        float hsqrt = sqrt(h);\n        res.tnear = (-b - hsqrt) / 2.0;\n        res.mnear = 1u;  // atmospheric hit\n        \n        res.tfar = (-b + hsqrt)/2.0;\n        res.mfar = 1u;  // atmospheric exit\n        \n        // inner sphere intersection\n        r = sphgnd;\n        c = dot(oc,oc)-r*r;\n        h = b*b - 4.0*c;\n        \n        if (h >= 0.0){\n            // ground hit\n            res.tfar = (-b - sqrt(h)) / 2.0;\n            res.mfar = 2u;  // ground hit\n            res.nor = normalize(ro + rd * res.tfar - sph.xyz);  // ground normal\n        }\n    }\n\n    return res;\n}\n\n\n\nfloat iSphere (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b - sqrt(h))/2.0;\n\treturn t;\n}\n\nfloat iSphere2 (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b + sqrt(h))/2.0;\n\treturn t;\n}\n\nvec3 nSphere (in vec3 pos, in vec4 sph){\n\treturn (pos - sph.xyz) / sph.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd){\n\t//eq. of a plane, y=0 = ro.y + t*rd.y\n\treturn -ro.y/rd.y;\n}\n\nvec3 nPlane( in vec3 pos){\n\treturn vec3(0.0,1.0,0.0);\n}\n\n\n\nvec3 brdfRock(vec3 pos, vec3 norm, vec3 view, vec3 light, vec3 lightcol)\n{\n\t\n\t// perturb normal\n\tvec3 pnpos = pos * 100.0;\n\tvec3 pn = normalize(vec3(\tfbm(pnpos),fbm(pnpos.zxy + vec3(1.7,33.9,2.3)),fbm(pnpos.yzx + vec3(3.9,7.4,19.1)) ) - vec3(0.5));\n\tpnpos *= 20.0;\n\tvec3 pn2 = normalize(vec3(\tfbm(pnpos),fbm(pnpos.zxy + vec3(1.7,33.9,2.3)),fbm(pnpos.yzx + vec3(3.9,7.4,19.1)) ) - vec3(0.5));\n\t\n\tnorm = normalize(norm + pn * 0.02 + pn2 * 0.01);\n\t\n\t\n\tfloat a = sin(pos.y*17.0+fbm(pos * vec3(1.0,0.1,1.0)*3.5)*7.9) * 0.5 + 0.5;\n\tfloat b = sin(pos.y*9.3+fbm(pos * vec3(0.7,0.17,0.7)*7.58)*3.6) * 0.5 + 0.5;\n/*\t\nvec3(0.2549,0.1490,0.0863)\nvec3(0.2941,0.2000,0.1137)\nvec3(0.2941,0.1529,0.0980)\nvec3(0.3020,0.2000,0.1137)\nvec3(0.3216,0.2078,0.1686)\nvec3(0.3569,0.2078,0.1255)\nvec3(0.4196,0.2824,0.2275)\nvec3(0.4902,0.3961,0.2784)\nvec3(0.6549,0.5804,0.4667)\n\n\n\tvec3 c00 = vec3(0.2549,0.1490,0.0863);\n\tvec3 c10 = vec3(0.2941,0.2000,0.1137);\n\tvec3 c01 = vec3(0.3216,0.2078,0.1686);\n\tvec3 c11 = vec3(0.3569,0.2078,0.1255);\n*/\t\n\t\n\tvec3 c00 = vec3(0.2549,0.1490,0.0863);\n\tvec3 c10 = vec3(0.2941,0.2000,0.1137);\n\tvec3 c01 = vec3(0.2941,0.1529,0.0980);\n\tvec3 c11 = vec3(0.3020,0.2000,0.1137);\t\n\t\n\tvec3 diffCol = vec3(0.0);\n\tdiffCol = mix(mix(c00,c01,a),mix(c10,c11,a),b);\n\tdiffCol = mix(diffCol,vec3(0.2941,0.1529,0.0980),mod(a+b,0.3)*2.5);\n\tdiffCol = mix(diffCol,vec3(0.6549,0.5804,0.4667),mod(a*0.1,0.1)*0.2);\n\t\n\t\n\t// material\n\tfloat absorb = 0.5;\n\tfloat reflIntensity = 0.01;\n\tfloat diffIntensity = 1.0 - reflIntensity - absorb;\n\t\n\t\n\t// diffuse col\n\t//vec3 diffCol = vec3(0.6);\n\tvec3 ambCol = vec3(0.2,0.13,0.1);\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat roughness = 0.05;\n\tfloat diffuse = max(dot(norm, light),0.0) * diffIntensity;\n\tfloat ambient = 0.04;\n\t\n\tvec3 refl = reflect(-view,norm);\n\t//float fres = pow( clamp(1.0+dot(norm,-view),0.0,1.0), 2.0 );\n\tfloat ldotr = max(dot(light, refl),0.0);\n\tfloat spec = pow(ldotr,1.0/roughness) * reflIntensity;\n\t\n\t\n\tcol += lightcol * diffCol * ambCol * ambient * diffIntensity;\n\tcol += lightcol * diffCol * diffuse;\n\tcol += lightcol * spec;\n\t//col += skycol(refl) * fres;\n\n\treturn col;\n}\n\n\n// atmospheric scattering specifics\n\n// Rayleigh absorbtion constant.\nvec3 Kr = vec3(0.1287, 0.2698, 0.7216);\nfloat miePhase = 0.93;\nfloat ralPhase = -0.01;\nfloat absorbCoeff = 0.7;\n\nvec4 sph1 = vec4 (0.0,1.0,0.0,1.0);\nfloat sph1gnd = 0.92;  // radius of ground\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT){\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere (ro, rd, sph1); //intersect with sphere\n\tfloat tpla = iPlane (ro,rd); //intersect with plane\n\tif (tsph > 0.0){\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\tif (tpla > 0.0 && tpla < resT){\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\treturn id;\n}\n\n\niMediaIntersection mediaIntersect( in vec3 ro, in vec3 rd){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.mnear = 0u;\n    res.tfar = -1.0;\n    res.mfar = 0u;\n    \n    iMediaIntersection res2 = mSphere(ro,rd,sph1,sph1gnd);\n    res = res2;\n    \n    return res;\n}\n\n\n// mie/rayleigh phase - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n// sensible g: mie:0.97, ral:-0.01\nfloat phase(float alpha, float g){\n    float gg = g*g;\n    float a = 3.0*(1.0-gg);\n    float b = 2.0*(2.0+gg);\n    float c = 1.0+alpha*alpha;\n    float d = pow(1.0+gg-2.0*g*alpha, 1.5);\n    return (a/b)*(c/d);\n}\n\n// exponential absorbtion - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\nvec3 absorb(float dist, vec3 col, float f)\n{\n    vec3 c = col;    \n    c *= (vec3(1.0) - pow(Kr, vec3(f / max(dist,0.0000000001))));\n    c *= (vec3(1.0) - pow(vec3(0.05,0.7,0.9), vec3(f / max(dist*0.5,0.0000000001))));\n    c *= (vec3(1.0) - pow(vec3(0.01,0.85,0.9), vec3(f / max(dist*0.1,0.0000000001))));\n    return c;\n}\n\nfloat airDensity(float alt){\n    return 5.0 * exp(-7.0 * alt) * (1.0-alt);  // last factor is lies, but makes sure we end at 0.0 at edge of atmosphere\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 light = normalize( vec3(0.5,1.0,0.5));\n\tvec3 lightcol = vec3(10.0,9.0,8.0);\n\t//uv are the pixel coordinates, from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 lookAt = vec3(0.0, 1.0, 0.0);\n\tvec3 ro = vec3(0.0,1.1,2.0); //camera position\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\n\n\tvec2 nMouse = (iMouse.xy / iResolution.xy) * PI;\n\t//nMouse.x += 3.1415927;\n\tfloat th = nMouse.y; \n\tfloat ph = -nMouse.x * 2.0;\n\tlight.x = sin(th) * cos(ph);\n\tlight.z = sin(th) * sin(ph);\n\tlight.y = -cos(th);\n\tlight = normalize(light);\n\t\n\t\n\t//float id = intersect (ro,rd,t);\n    iMediaIntersection hit = mediaIntersect(ro,rd);\n\n\n    float sph1atmscale = 1.0 / (sph1.w - sph1gnd); \n\n\t\n\tvec3 col = vec3(0.5);\n    float density = 0.0;\n\t\n\tif (hit.tnear > 0.0){\n    \n        //col.g= 0.0; //(hit.tfar - 1.0) * 0.5;\n        //col.b = 0.0;\n        //col.r= 0.;//(hit.tfar - hit.tnear);\n        \n        \n\t\tvec3 pos = ro + hit.tnear*rd;\t//hit position\n    \n        if (hit.mnear == 1u){  // atmospheric hit\n        \n        \n            // calculate atmospheric height of mid-point in order to estimate path air mass.\n            //vec3 mpos = ro + rd * (hit.tnear * 0.5 + hit.tfar * 0.5);\n            //float malt = max(0.0,length(mpos - sph1.xyz) - sph1gnd) * sph1atmscale;\n            //float adensity = 4. * exp(-2.0 * malt);\n            //float athick = adensity * (hit.tfar - hit.tnear);\n            //col.r = adensity;\n            \n            // setup scattering            \n            float mie = phase(dot(rd,light),miePhase) * 0.005; // relative amount of Mie scattering.\n            float rayleigh = phase(dot(rd,light),ralPhase) * 1.4; // relative amount of Rayleigh scattering.\n                \n            // step through atmosphere, cast rays to lightsource to determine shadow.\n            float litDensity = 0.0;\n            float dt = (hit.tfar - hit.tnear) * 0.03;\n            float hh = hash(iTime + dot(rd,vec3(12.65898,37.3516781,17.651651)));  // add a little noise to the start of the ray traversal so smooth out banding.\n            \n            vec3 mieAccum = vec3(0.0);\n            vec3 rayleighAccum = vec3(0.0);\n            vec3 totalInflux = vec3(0.0);\n            \n            for(float t = hit.tnear + hh *0.015; t<hit.tfar-0.00001; t+=dt){\n            \n                vec3 apos = ro + rd * t;  // position along atmosphere ray\n                float alt = (length(apos - sph1.xyz) - sph1gnd) * sph1atmscale;  // altitude above ground (assume sph1 is only sphere in scene)                \n                \n                float lt = iSphere(apos, light, vec4(sph1.xyz,sph1gnd)); // cast ray to sun, intersect with ground. if lt < 0, then this point can see the sun\n                float sliceDensity = dt * airDensity(alt);  // estimate air mass over segment, based on altitude.\n                float litSlice = sliceDensity * (lt<0.0?1.0:0.0);  // ray miss == air mass lit directly by the sun\n\n                // calculate amount of light that has reached this point from the sun.\n                // need to estimate air-mass along the path from apos to intersection (apos + light * tsun)\n                //float tsun = iSphere(apos, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n                //float opticalDepthSun = (airDensity(alt) + airDensity((length((apos + light * tsun * 0.5) - sph1.xyz) - sph1gnd) * sph1atmscale)) * tsun;\n                //vec3 influx = absorb(opticalDepthSun, lightcol, absorbCoeff);\n                                \n                // for atmosphere samples getting sunlight directly, calculate lowest altitude.\n                //float tsun = iSphere(apos, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n                //float peakAirDensity = airDensity((pointRayDistance(apos,light,sph1.xyz)-sph1gnd) * sph1atmscale);                \n                //vec3 influx = absorb(peakAirDensity*0.001,lightcol,absorbCoeff);\n                \n                vec3 influx = vec3(0.0);\n                \n                // if we are in light, then calculate the amount of absorption along the path to the edge of the atmosphere\n                if (lt<0.0){\n                    // do another raycast towards the sun\n                    float tsun = iSphere2(apos, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n                    float dtl = tsun * 0.1; // keep it rather chunky, don't want to bog down\n                    float densitytosun = 0.0;\n                    \n                    for (float tl = 0.0; tl < tsun; tl += dtl){\n                        vec3 spos = apos + light * tl;  // raycasting from our atmosphere position in the outer loop, out to the edge of the atmosphere.\n                        densitytosun += dtl * airDensity((length(spos - sph1.xyz) - sph1gnd) * sph1atmscale);\n                    }\n                    \n                    influx = absorb(densitytosun,lightcol,absorbCoeff);                    \n                    \n                }\n                else\n                {\n                    influx = vec3(0.0); // todo: maybe fake multiple scattering here\n                }\n                \n                \n                //totalInflux += absorb(density,influx,absorbCoeff);\n                density += sliceDensity;  // accumulate optical depth\n                litDensity += litSlice;  // accumulate directly-it optical depth (for later debug)\n\n                mieAccum += absorb(density,influx * mie * litSlice,absorbCoeff);\n                \n                rayleighAccum += absorb(density,influx * Kr * rayleigh * litSlice,absorbCoeff);\n                \n            }\n        \n            vec3 acol = vec3(0.0);\n            //acol += vec3(0.4,0.05,0.02) * athick;\n            //acol += vec3(0.05,0.4,1.0) * litDensity;  // debug for atmosphere that can see the sun\n            acol += mieAccum;\n            acol += rayleighAccum;\n            //acol += vec3(1.0,0.0,0.0) * mie * 0.1;\n            //acol += vec3(0.01,0.001,0.0) * density;   // fake airglow\n            //acol += vec3(0.0,0.0,1.0) * litDensity;\n\n\n            //float prd = airDensity((pointRayDistance(ro,light,sph1.xyz)-sph1gnd) * sph1atmscale);\n            //acol += vec3(0.0,1.0,0.0) * prd;\n            //acol += absorb(prd,lightcol,absorbCoeff);\n            //col+=acol;\n            \n            //acol = vec3(0.0);\n            //float tsun = iSphere(ro, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n            //acol += vec3(0.0,1.0,0.0) * tsun;\n            //col += acol;\n            \n            \n            if (hit.mfar == 1u){ // atmospheric exit\n                //col = vec3(0.0);\n                col = acol;// + absorb(density,lightcol,absorbCoeff);  // todo: need extinction\n            }\n            else if (hit.mfar == 2u){ // ground hit\n                col = vec3(0.0);\n                col += acol;\n                col += absorb(density,brdfRock(pos,hit.nor,-rd,light,lightcol),absorbCoeff);// + brdfRock(pos,hit.nor,-rd,hit.nor,acol*5.0);                \n            }\n            \n            //col = totalInflux*0.001;\n        }\n\n\t}else{\n        col = vec3(0.0);\n\t}\n\n\n    // fake some sun glow (bloom / mie scattering in eye?)\n    float sunVisible = iSphere(ro, light, vec4(sph1.xyz,sph1gnd)); // cast ray to sun, intersect with ground\n    float mie_eye = phase(dot(rd,light),0.9995) * 0.001; // relative amount of Mie scattering.\n    col += absorb(density,lightcol,absorbCoeff) * mie_eye * (sunVisible > 0.0 ? 0.:1.);\n    \n\t\n\n// reinhardt HDR tonemapping\n\tfloat whitelevel = 2.0;\n\tcol = (col  * (vec3(1.0) + (col / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + col);\t\n\n// gamma\t\n\tcol = pow(col,vec3(1.0/2.0));\n\n\t\n\tfragColor = vec4(col,1.0);\n\t\n}\n","name":"Image","description":"","type":"image"}]}