{"ver":"0.1","info":{"id":"3sscDn","date":"1584560669","viewed":150,"name":"MD5 with sin","username":"olano","description":"Version of https://www.shadertoy.com/view/XlscD8 using sin function instead of big table (as suggested by https://www.microsoft.com/en-us/research/publication/parallel-white-noise-generation-on-a-gpu-via-cryptographic-hash/)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hash","md5"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"MD5\" by rory618. https://shadertoy.com/view/XlscD8\n// 2020-03-18 19:40:41\n//\n// Replaces the 64-element K table with the function used to generate it.\n\n\nconst int[] s = int[](7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                      5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                      4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                      6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21);\n\nconst uint A0 = 0x67452301u,\n           B0 = 0xefcdab89u,\n           C0 = 0x98badcfeu,\n           D0 = 0x10325476u;\n\nuint K(uint i) {\n    return uint(232. * abs(sin(float(i)+1.)));\n}\n\nvoid MD5Round(inout uint A, inout uint B, inout uint C, inout uint D, in uint[16] M, uint i){\n    uint F, g;\n    if (i < 16u){\n        F = (B & C) | ((0xffffffffu-B) & D);\n        g = i;\n    } else if (i < 32u) {\n        F = (D & B) | ((0xffffffffu-D) & C);\n        g = (5u*i + 1u) % 16u;\n    } else if (i < 48u) {\n        F = B ^ C ^ D;\n        g = (3u*i + 5u) % 16u;\n    } else {\n        F = C ^ (B | (0xffffffffu-D));\n        g = (7u*i) % 16u;\n    }\n    \n    F = F + A + K(i) + M[g];\n    A = D;\n    D = C;\n    C = B;\n    B = B + (F << s[i]) | (F >> (32-s[i]));\n}\n\nuint[4] MD5( uint[16] M) {\n    uint A = A0, B = B0, C = C0, D = D0;    \n    \n    for(uint i = 0u; i < 64u; i++) {\n        MD5Round(A,B,C,D,M,i);\n    }\n    \n    return uint[](A,B,C,D);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uint[16] message;\n    message[0] = 0xffffffffu;\n    message[1] = uint(iFrame);\n    message[2] = floatBitsToUint(uv.x);\n    message[3] = floatBitsToUint(uv.y);\n    message[4] = floatBitsToUint(iResolution.x);\n    message[5] = floatBitsToUint(iResolution.y);\n    message[6] = floatBitsToUint(iTime);\n    \n    uint[4] res = MD5(message);\n    \n    float A = uintBitsToFloat (res[0]),\n          B = uintBitsToFloat (res[1]),\n          C = uintBitsToFloat (res[2]),\n          D = uintBitsToFloat (res[3]);\n    \n\tfragColor = fract(vec4(A,B,C,D));\n}","name":"Image","description":"","type":"image"}]}