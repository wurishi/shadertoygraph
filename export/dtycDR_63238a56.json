{"ver":"0.1","info":{"id":"dtycDR","date":"1700091359","viewed":99,"name":"Spherebox","username":"doop","description":"Quick hacked up raytraced version of Tom Womack's spherebox http://www.chiark.greenend.org.uk/~twomack/visualise-spherebox.html\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hacked up raytraced version of Tom Womack's spherebox\n// at http://www.chiark.greenend.org.uk/~twomack/visualise-spherebox.html\n\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Light { vec3 color; vec3 dir; };\nstruct Material { vec3 color; float diffuse; float specular; };\nstruct Intersect { vec3 loc; vec3 N; Material material; float lambda; };\n\nstruct Object { int type; vec3 loc; Material mat; float radius; };\n#define T_SPHERE 0\n#define T_PLANE 1\nfloat mindist = 0.0001;\n//#define MOUSE\n\nconst float gamma = 2.2;\nconst float pi = 3.14159264358979323846;\nconst float yoff = 2.0;\nconst float tau = 2.0*pi;\n\nMaterial redMat = Material( vec3(1.0, 0.0, 0.2), 1.0, 0.01 );\nMaterial greenMat = Material( vec3(0.0, 1.0, 0.2), 1.0, 0.1 );\nMaterial blueMat = Material( vec3(0.0, 0.2, 1.0), 1.0, 0.1 );\nMaterial yellowMat = Material( vec3(1.0, 1.0, 0.2), 1.0, 0.1 );\nMaterial silverMat = Material( vec3(1.0, 1.0, 1.0), 1.0, 0.1 );\n\nMaterial planeDarkMat  = Material(  0.2 * vec3(1.0, 1.0, 1.0), 1.0, 0.05 );\nMaterial planeLightMat  = Material( 0.8 * vec3(1.0, 1.0, 1.0), 1.0, 0.05 );\n\nMaterial skyMat    = Material( vec3(0.0, 0.4, 0.8), 1.0, 0.0 );\n\n// struct Object { int type; vec3 loc; Material mat; float radius; };\n#define N_OBJECTS 46\nObject objects[N_OBJECTS];\nLight light;\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    mat3 R = mat3(\n         c, -s, 0.,\n         s,  c, 0.,\n        0., 0., 1.\n    );\n    return R;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return  mat3(\n         c, 0., -s,\n        0., 1., 0.,\n         s, 0.,  c\n    );\n}\n                \n\nvoid init_objects() {\n\n\n    objects[0] = Object( T_PLANE, vec3(0.,0.,0.), planeLightMat, 0.0 );\n\n    int objno = 1;\n    \n    // Large sphere in centre\n    \n    objects[objno++] = Object(\n        T_SPHERE,\n        vec3(0,0,0),\n        silverMat,\n        1.0\n    );\n    \n    float V3 = sqrt(3.0)-1.0;\n    for (float u=-1.; u<2.;u+=2.) { // effectively -1, 1\n        for (float v=-1.; v<2.;v+=2.) {\n            for (float w=-1.; w<2.; w+=2.) {\n                // One red sphere in each corner\n                objects[objno++] = Object(\n                    T_SPHERE,\n                    vec3(u*V3, v*V3, w*V3),\n                    redMat,\n                    1.0-V3\n                );\n                \n                // Each red sphere has three adjacent green spheres\n                float r2 = 0.1867023193402;\n                float a2 = 1.0-r2;\n                float b2 = 0.2921577655895;\n                vec3 cvecs[3];\n                cvecs[0] = vec3(a2,a2,b2);\n                cvecs[1] = vec3(a2,b2,a2);\n                cvecs[2] = vec3(b2,a2,a2);\n                \n                for (int i=0;i<3;i++) {\n                    objects[objno++] = Object(\n                        T_SPHERE,\n                        vec3(u,v,w) * cvecs[i],\n                        greenMat,\n                        r2\n                    );\n                }\n                \n            }\n        }\n     }\n\n    // Add the spheres in the middle of each face\n    float rr=0.127476703691;\n    float xx=1.-rr;\n    float yy=0.714077597159;\n    \n    vec3 w[12];\n    w[0] = vec3(-xx,-yy,0);\n    w[1] = vec3(-xx,yy,0);\n    w[2] = vec3(yy,-xx,0);\n    w[3] = vec3(yy,xx,0);\n    w[4] = vec3(-xx,0,-yy);\n    w[5] = vec3(-xx,0,yy);\n    w[6] = vec3(yy,0,-xx);\n    w[7] = vec3(yy,0,xx);\n    w[8] = vec3(0,-xx,-yy);\n    w[9] = vec3(0,-xx,yy);\n    w[10] = vec3(0,yy,-xx);\n    w[11] = vec3(0,yy,xx);\n    \n    for (int i=0;i<12;i++) {\n        objects[objno++] = Object(\n            T_SPHERE,\n            w[i],\n            yellowMat,\n            rr\n        );\n    }\n\n    float Yrot = 0.0;\n    float Zrot = 0.0;\n#ifdef MOUSE\n    vec2 mousepos = iMouse.xy / iResolution.xy;\n    float rsc = 2.0;\n    Yrot = mousepos.x * tau / rsc;\n    Zrot = -mousepos.y * tau / rsc;\n#else\n    float pz = 15.0;\n    float py = 15.0;\n    Yrot = iTime/py * tau;\n    Zrot = iTime/pz * tau;\n#endif\n    \n    mat3 M = rotateY(Yrot) * rotateZ(Zrot);\n    for (int i=0;i<N_OBJECTS;i++) {\n        objects[i].loc = M * objects[i].loc;\n        objects[i].loc.y += yoff;\n    }\n\n    light = Light( vec3(1.0, 1.0, 1.0), normalize(vec3( 0.0, -1.0, 0.5)) );\n}\n\nvec3 skyColor(vec3 dir) {\n#define N_SKY_COLORS 5\n\n    const float scale = 0.1;\n    vec3 skycolors[N_SKY_COLORS];\n    skycolors[0] = vec3(32.,48.,96.)/255.0;\n    skycolors[1] = vec3(88.,72.,128.)/255.0;\n    skycolors[2] = vec3(136.,80.,144.)/255.0;\n    skycolors[3] = vec3(248.,128.,176.)/255.0;\n    skycolors[4] = vec3(248.,192.,216.)/255.0;\n    \n    float rplane = sqrt(dir.x*dir.x + dir.z * dir.z);\n    float theta = clamp(atan(dir.y,rplane),0.0,0.5*pi);\n    float phi = theta/(0.5*pi*scale);\n    int col = int(floor(phi));\n    float x = phi-floor(phi);\n    \n    vec3 color = (1.0-x)*skycolors[col] + x*skycolors[1+col];\n    \n    \n    return color;\n}\n\n\nIntersect miss = Intersect( vec3(0.0), vec3(0.0), Material(vec3(0.),-1.,-1.), -1. );\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\n\nRay make_ray(vec3 viewer_pos, vec2 fc, mat4 view_matrix) {\n    // Take viewer pos, view matrix, and fragment coords\n    // Return a Ray in world coordinates\n    const float fov = radians(45.0);\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 s = 2.0*fc.xy/iResolution.xy - 1.0;\n    vec3 raydir0 = normalize(vec3(aspect*s.x,s.y,-1./tan(0.5*fov)));\n    \n    vec3 raydir = (view_matrix * vec4(raydir0,0.0)).xyz;\n    return Ray(viewer_pos, raydir);\n}\n\n\nIntersect intersect_hplane(Ray ray, Object obj) {\n // r = r0 + lambda*t\n // intersect Y so r0y + lambda * ty = 0\n // so lambda = -r0y/ty\n \n    if (ray.dir.y==0.0) { return miss; }\n    float lambda = -ray.origin.y / ray.dir.y;\n    \n    vec3 loc = ray.origin + lambda * ray.dir;\n\n    int xi = int(1.0*floor(loc.x))%2;\n    int yi = int(1.0*floor(loc.z))%2;\n    int floorcol = (xi+yi)%2;\n    \n    Material mat = obj.mat;\n    \n    if (0==floorcol) {\n        mat = planeDarkMat;\n    } else {\n        mat = planeLightMat;\n    }\n    \n    return Intersect( loc, vec3(0.0,1.0,0.0), mat, lambda);\n}\n\nIntersect intersect_sphere(Ray ray, Object obj) {\n    vec3 spherepos = obj.loc;\n    float a = obj.radius; // sphere radius\n    vec3 D = ray.origin - obj.loc;\n    vec3 t = ray.dir;\n    float b = dot(t,D);\n    float C = dot(D,D) - a*a;\n    float t2 = dot(t,t);\n    float discrim2 = b*b - t2*C;\n    if (discrim2<0.) { return miss; } // no intersection so return -ve\n    float discrim = sqrt(discrim2);\n    float lambda1 = discrim - b;\n    float lambda2 = - discrim - b;\n\n    if ( (lambda1<0.) && (lambda2<0.) ) {\n        return miss ; // intersection but behind us\n    }\n    \n    float lambda = -1.;\n    if (lambda1 < 0.) {\n        lambda = lambda2;\n    } else if (lambda2 < 0.) {\n        lambda = lambda1;\n    } else {\n        // Take whichever is smaller\n        lambda = (lambda2<lambda1) ? lambda2 : lambda1;\n    }\n    \n    lambda = lambda/t2;\n    \n    vec3 cpoint = ray.origin + lambda * t; // collision point\n    vec3 N = normalize(cpoint - obj.loc); // normal\n    return Intersect( cpoint, N, obj.mat, lambda);\n}\n\nIntersect intersect(Ray ray, Object obj) {\n    if (T_SPHERE==obj.type) { return intersect_sphere(ray, obj); }\n    if (T_PLANE==obj.type)  { return intersect_hplane(ray, obj); }\n    return miss;\n}\n\n\nIntersect raycast(Ray ray) {\n    Intersect best_hit = miss;\n    for (int i=0;i<N_OBJECTS;i++) {\n        Intersect new_hit = intersect(ray, objects[i]);\n        if (new_hit.lambda > 0.0) {\n            if (best_hit.lambda < 0.0) {\n                // There is no current hit, so take the new one\n                best_hit = new_hit;\n            } else {\n                // Take whichever is nearest the viewer, ie smaller lambda\n                if (new_hit.lambda < best_hit.lambda) {\n                    best_hit = new_hit;\n                }\n            }\n        }\n                \n    }\n    return best_hit; \n}\n\n#define N_ITERATIONS 5\nvec3 raycast_frag( Ray ray) {\n    vec3 mask = vec3(1.0);\n    vec3 color = vec3(0.0);\n\n\n    for (int i=0;i<N_ITERATIONS;i++) {\n        Intersect hit = raycast(ray);\n        if (hit.lambda > 0.0) {\n            // return hit.material.color; // uncomment to check what we're hitting without any lighting calcs\n            // we hit something\n            vec3 R0 = hit.material.color * hit.material.specular;\n            float dp = clamp(dot(hit.N,-ray.dir),0.0,1.0);\n            vec3 Reff = R0 + (1.0 - R0) * pow(1.0 - dp,5.0);\n            //return (Reff) * hit.material.color;\n            mask *= Reff;\n            \n            // Find the hit location, and adjust (\"bias\") it outwards\n            // slightly in the direction of the normal\n            \n            vec3 b_loc = hit.loc + mindist * hit.N;\n            \n            Ray tolight = Ray( b_loc, -light.dir );\n            Intersect ilight = raycast(tolight);\n            if (ilight.lambda < 0.0) {\n                // We don't hit anything if we shoot a ray off in the direction of the light\n                // Therefore there are no obstructions\n                // Therefore light hits this point\n                vec3 light_intensity = clamp(dot(hit.N,-light.dir),0.0,1.0) * light.color;\n                light_intensity *= hit.material.color * hit.material.diffuse;\n                light_intensity *= (1.0 - Reff) * mask / Reff;\n                color += light_intensity;\n            }\n            vec3 reflect_dir = normalize(ray.dir - 2.0 * dot(ray.dir,hit.N) * hit.N);\n            ray = Ray(b_loc, reflect_dir);\n            \n        } else {\n            // hit the sky\n            vec3 spotlight = vec3(1e4) * pow( clamp(dot(ray.dir,-light.dir),0.0,1.0),250.0);\n            // color += mask * ( skyMat.color + spotlight);\n            color += mask * ( skyColor(ray.dir) + spotlight);\n            \n            break; // Stop bouncing.\n        }\n    }\n    return color;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  init_objects();\n\n  vec3 viewer_pos = vec3(0,1,-4);  \n  mat4 view_matrix =  viewMatrix(viewer_pos, vec3(0,yoff,0), vec3(0,1,0) );\n\n  // Use quincunx oversampling for antialiasing\n #define N_SAMPLES 5\n #define ACTUAL_SAMPLES 1 // set to 5 to enable oversampling\n  vec3 samples[N_SAMPLES];\n  // First two elements are (x,y) offsets; third is weight\n  samples[0] = vec3(0.0, 0.0, 0.5);\n  samples[1] = vec3(-0.5,-0.5, 0.125);\n  samples[2] = vec3(-0.5, 0.5, 0.125);\n  samples[3] = vec3( 0.5,-0.5, 0.125);\n  samples[4] = vec3(-0.5, 0.5, 0.125);\n\n\n  vec3 frag = vec3(0.0);\n  \n  for (int i=0;i<ACTUAL_SAMPLES;i++) {\n      Ray ray = make_ray(viewer_pos, fragCoord.xy + samples[i].xy, view_matrix) ;\n      frag += raycast_frag(ray) * samples[i].z;\n  }\n  \n  float bscale = 5.0/float(ACTUAL_SAMPLES);\n  //frag = frag / bscale;\n\n  //fragColor = vec4(pow(raycast_frag(ray),vec3(1.0/gamma)),1.0);\n  fragColor = vec4(pow(frag,vec3(1.0/gamma)),1.0);\n  \n}\n\n","name":"Image","description":"","type":"image"}]}