{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":" \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n\n\nconst int NUM_LIGHTS = 3;\nconst int NUM_TRAILS = 3;\nconst int STICKMAN_PARTS = 5; // 5 spheres + 5 cylinders per stickman\nconst int NUM_SPHERES = 10 + STICKMAN_PARTS * (NUM_TRAILS +1); // Main + trails\nconst int NUM_CYLINDERS = 12 + STICKMAN_PARTS * (NUM_TRAILS+1);\nconst int NUM_PLANS = 2;\nconst int NUM_CONES = 3;\n\n\nconst int numSamples = 16;\n\nconst float gamma = 2.2;\nconst float PI = 3.141592653589793;\n\nconst float shininess = 32.0; // Higher values make the specular highlight smaller and sharper\nconst float specularStrength = 0.5; // Adjust this for the specular intensity\n\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vec3(0, 0, 1), C.View));\n    C.Up = normalize(cross(C.View, C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/2.0/tan(aperture * 3.1415 / 180.0 /2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n    vec2 offset = XY - vec2(C.W, C.H) * 0.5;\n    return Ray(C.Obs, normalize(C.z * C.View + offset.x * C.Horiz + offset.y * C.Up));\n}\n\n\nvec3 computeTangent(vec3 point, vec3 circleCenter, float circleRadius) {\n    // Compute the radius vector\n    vec3 radiusVec = normalize(point - circleCenter);\n\n    // Choose an arbitrary vector not collinear with radiusVec\n    vec3 arbitraryVec = vec3(0.0, 0.0, 1.0); // Default arbitrary vector\n    if (abs(dot(radiusVec, arbitraryVec)) > 0.999) {\n        arbitraryVec = vec3(0.0, 1.0, 0.0); // Use another vector if collinear\n    }\n\n    // Compute a perpendicular vector using cross product\n    vec3 tangentVec = normalize(cross(radiusVec, arbitraryVec));\n\n    // Ensure tangent vector is perpendicular and lies on the plane\n    tangentVec *= circleRadius;\n\n    return tangentVec;\n}\n\n\n///////////////////////////SPHERE/////////////////////////////////\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    float a = dot(R.Dir,R.Dir);\n    float b = 2.0*dot(R.Dir,(R.Origin - S.Center));\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R*S.R;\n    float delta = b*b - 4.0*a*c;   \n    if (delta > 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n    }\n    return delta > 0.0;\n}\n\n/////////////////////////////PLAN////////////////////////////////////////////////\n\nstruct Plan{\n   vec3 ori;\n   vec3 ab;\n   vec3 ord;\n   vec2 minx;\n   vec2 maxx;\n   vec2 miny;\n   vec2 maxy;\n};\n\n\nbool intersect_plan(Ray R, Plan P, out float t, out vec2 uv) {\n    vec3 normal = normalize(cross(P.ab, P.ord));\n    float denom = dot(R.Dir, normal);\n    if (abs(denom) < 1e-6) return false;\n\n    t = dot(P.ori - R.Origin, normal) / denom;\n    if (t <= 0.0) return false;\n\n    vec3 intersection = R.Origin + R.Dir * t;\n    vec3 planeOffset = intersection - P.ori;\n    uv = vec2(dot(planeOffset, normalize(P.ab)), dot(planeOffset, normalize(P.ord)));\n\n    return (P.minx[0] != 0.0 || uv.x >= P.minx[1]) &&\n           (P.maxx[0] != 0.0 || uv.x <= P.maxx[1]) &&\n           (P.miny[0] != 0.0 || uv.y >= P.miny[1]) &&\n           (P.maxy[0] != 0.0 || uv.y <= P.maxy[1]);\n}\n\n\n///////////////////////////////////////CYLINDER//////////////////////////////////////////////////////\n\nstruct Cylinder {\n    vec3 center;  // Center of the cylinder base\n    vec3 axis;    // Direction of the cylinder's axis (normalized)\n    float radius; // Radius of the cylinder\n    vec2 minx;\n    vec2 maxx;\n};\n\nfloat minimumDistanceBetweenRays(Ray ray1, Ray ray2) {\n    vec3 AB = ray2.Origin - ray1.Origin;\n\n    vec3 crossProd = cross(ray1.Dir, ray2.Dir);\n    float crossMag = length(crossProd);\n\n    if (crossMag == 0.0) {\n        return 0.0; // Rays are parallel, no perpendicular distance\n    }\n\n    float dotProd = dot(AB, crossProd);\n\n    return abs(dotProd) / crossMag;\n}\n\n\nbool sculptedCylCoord(Ray r, Cylinder cyl, float t) {\n    vec3 intersection = r.Origin + r.Dir * t; // Intersection point\n    vec3 offset = intersection - cyl.center; // Vector from cylinder base to intersection\n\n    // Project onto the cylinder's perpendicular plane\n    vec3 axisDir = normalize(cyl.axis);\n    float height = dot(offset, axisDir); // Projection along the cylinder axis\n    vec3 perp = offset - height * axisDir; // Vector perpendicular to the axis\n\n    // Compute angle in the XZ-plane\n    float theta = atan(perp.y, perp.x);\n\n    // Normalize theta to [0, 2Ï€]\n    theta = mod(theta + 2.0 * PI, 2.0 * PI);\n\n    // Custom radius as a function of theta\n    float rTheta = cyl.radius * (1.0 + 0.3 * cos(6.0 * theta)); // 6 points\n\n    // Check if the intersection is within the radius at this angle\n    return length(perp) <= rTheta;\n}\n\n\n\nbool coorCyl(Ray r, Cylinder cyl,float t){\n    vec3 intersection = r.Origin + r.Dir * t; // Intersection point\n    vec3 offset = intersection - cyl.center; // Vector from cylinder base to intersection\n\n    \n    // Compute height\n    float height = dot(offset, normalize(cyl.axis));\n\n    // Compute angle\n    vec3 perp = offset - height * normalize(cyl.axis); // Perpendicular component\n    \n    vec3 semiCylinderDir = normalize(cross(cyl.axis, vec3(1.0, 0.0, 0.0)));\n    if (length(semiCylinderDir) == 0.0) {\n        // Handle the special case where the axis is parallel to the x-axis\n        semiCylinderDir = normalize(cross(cyl.axis, vec3(0.0, 1.0, 0.0)));\n    }\n    // Project the perpendicular component onto the plane perpendicular to the cylinder's axis\n    vec3 projectedPerp = perp - dot(perp, cyl.axis) * cyl.axis; \n\n    // Calculate the angle of the projected perpendicular component\n    float angle = atan(projectedPerp.y, projectedPerp.x); \n\n    // Check if the intersection point is within the semi-cylinder\n    //if (dot(projectedPerp, semiCylinderDir) < 0.) {\n    //    return false; \n    //}\n\n    if ((cyl.minx[0] == 0.0 && height < cyl.minx[1]) ||\n        (cyl.maxx[0] == 0.0 && height > cyl.maxx[1])){\n        return false;\n    }\n    \n    \n    \n    //vec2 uv = vec2(height, angle); // Store height and angle as UV coordinates\n    \n    return true;\n}\n\n\nbool intersect_cylinder(Ray ray, Cylinder cyl, out float t, out vec2 uv, out bool inside) {\n    inside = false;\n    float dist = minimumDistanceBetweenRays(Ray(cyl.center,normalize(cyl.axis)),ray);\n   \n    if (dist>cyl.radius + 1e-4){\n        t=-1.;\n        return false;\n    }\n    \n    float t1;\n    float t2;\n    // Cylinder axis and normalized direction\n    vec3 v = normalize(cyl.axis);\n\n    // Vector from cylinder base to ray origin\n    vec3 w = ray.Origin - cyl.center;\n\n    // Compute projections\n    float p = dot(w, v);\n    float q = dot(ray.Dir, v);\n\n    // Components perpendicular to the cylinder axis\n    vec3 u = w - p * v;\n    vec3 m = ray.Dir - q * v;\n\n    // Quadratic coefficients\n    float a = dot(m, m);\n    float b = 2.0 * dot(u, m);\n    float c = dot(u, u) - cyl.radius * cyl.radius;\n\n    // Discriminant\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant >= 0.0) {\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n    bool inrangeT1 = coorCyl(ray,cyl,t1);\n    bool inrangeT2 = coorCyl(ray,cyl,t2);\n\n    bool validT1 = t1 > 0.0 && inrangeT1; //&& sculptedCylCoord(ray, cyl, t1);\n    bool validT2 = t2 > 0.0 && inrangeT2; //&& sculptedCylCoord(ray, cyl, t2);\n\n\n\n    if (validT1 || validT2) {\n        if (validT1 && (!validT2 || t1 < t2)) {\n            t = t1;\n            inside = t1>t2;\n        } else {\n            t = t2;\n            inside = t2>t1;\n        }\n        return true;\n    }\n}\n    \n    if (discriminant < 0.0) {\n        // No intersection\n        t = -1.0;\n        return false;\n    }\n\n   \n\n  return false;\n}\n\n\n\nvec3 cylinderNormal(Cylinder cyl, vec3 intersectionPoint) {\n    // Compute the vector from the cylinder base to the intersection point\n    vec3 V = intersectionPoint - cyl.center;\n\n    // Project V onto the cylinder's axis\n    vec3 axisProjection = dot(V, cyl.axis) / dot(cyl.axis, cyl.axis) * cyl.axis;\n\n    // Calculate the perpendicular vector (surface vector)\n    vec3 surfaceVector = V - axisProjection;\n\n    // Normalize the surface vector to get the normal\n    return normalize(surfaceVector);\n}\n\n//////////////////////////////////////Cone////////////////////////////////////////\n\nstruct Cone {\n    vec3 tip;    // Tip of the cone\n    vec3 axis;   // Direction from tip to base (should be normalized)\n    float height; // Height of the cone\n    float radius; // Radius at the base\n};\n\nvec3 coneNormal(Cone cone, vec3 point, bool inside) {\n    // Vector from tip to intersection point\n    vec3 cp = point - cone.tip;\n    vec3 v = normalize(cone.axis);\n    \n    // Calculate normal using the projection formula from the reference\n    vec3 n = normalize(cp * dot(v, cp) / dot(cp, cp) - v);\n    \n    return inside ? n : -n;\n}\n\nbool intersect_cone(Ray ray, Cone cone, out float t, out vec3 normal, out bool inside) {\n    t = -1.0;\n    inside = false;\n    \n    vec3 v = normalize(cone.axis);\n    float cosa = cone.height / sqrt(cone.height * cone.height + cone.radius * cone.radius);\n    float cosaSqr = cosa * cosa;\n    \n    // Vector from ray origin to cone tip\n    vec3 co = ray.Origin - cone.tip;\n    \n    // Calculate quadratic equation coefficients\n    float a = dot(ray.Dir, v) * dot(ray.Dir, v) - cosaSqr;\n    float b = 2.0 * (dot(ray.Dir, v) * dot(co, v) - dot(ray.Dir, co) * cosaSqr);\n    float c = dot(co, v) * dot(co, v) - dot(co, co) * cosaSqr;\n    \n    // Solve quadratic equation\n    float det = b * b - 4.0 * a * c;\n    if (det < 0.0) return false;\n    \n    float sqrtDet = sqrt(det);\n    float t1 = (-b - sqrtDet) / (2.0 * a);\n    float t2 = (-b + sqrtDet) / (2.0 * a);\n    \n    // Test both intersection points\n    bool hitFound = false;\n    vec3 cp;\n    \n    vec3 p1 = ray.Origin + t1 * ray.Dir;\n    vec3 p2 = ray.Origin + t2 * ray.Dir;\n    \n    vec3 cp1 = p1 - cone.tip;\n    vec3 cp2 = p2 - cone.tip;\n    \n    float h1 = dot(cp1, v);\n    float h2 = dot(cp2, v);\n    \n    bool valid1 = t1 > 0.0 && h1 >= 0.0 && h1 <= cone.height;\n    bool valid2 = t2 > 0.0 && h2 >= 0.0 && h2 <= cone.height;\n    \n    // Determine closest valid intersection\n    if (!valid1 && !valid2) return false;\n    \n    inside = valid1 && valid2;\n    t = valid1 ? t1 : t2;\n    if (valid1 && valid2) {\n        t = (t1 < t2) ? t1 : t2;\n    }\n    \n    // Calculate final intersection point and normal\n    vec3 hitPoint = ray.Origin + t * ray.Dir;\n    normal = coneNormal(cone, hitPoint, inside);\n    \n    return true;\n}\n\n\n//////////////////////////////////////Coloring////////////////////////////////////\n\nbool isInShadowFromLight1(Light L, vec3 inter, Sphere S[NUM_SPHERES], Plan P[NUM_PLANS],\n                          Cylinder C[NUM_CYLINDERS], Cone Co[NUM_CONES]) {\n    vec3 lightDir = normalize(L.pos - inter);\n    Ray shadowRay = Ray(inter + lightDir * 1e-3, lightDir); // Offset to avoid self-intersection\n\n    float t;\n    for (int j = 0; j < NUM_SPHERES; j++) {\n        if (intersect_sphere(shadowRay, S[j], t) && t > 0.0 && t < length(L.pos - inter)) {\n            return true; // Blocked by a sphere\n        }\n    }\n    vec2 uv;\n    for (int j = 0; j < NUM_PLANS; j++) {\n        if (intersect_plan(shadowRay, P[j], t, uv) && t > 0.0 && t < length(L.pos - inter)) {\n            return true; // Blocked by a plane\n        }\n    }\n    bool inner;\n    for (int j = 0; j < NUM_CYLINDERS; j++) {\n        if (intersect_cylinder(shadowRay, C[j], t, uv, inner) && t > 0.0 && t < length(L.pos - inter)) {\n            return true; // Blocked by a cylinder\n        }\n    }\n    \n    vec3 normal;\n    for (int j = 0; j < NUM_CONES; j++) {\n        if (intersect_cone(shadowRay, Co[j], t, normal, inner) && t > 0.0 && t < length(L.pos - inter)) {\n            return true; // Blocked by a cylinder\n        }\n    }\n    \n    return false; // No blockers found\n}\n\n\n\nvec3 getColor(vec3 color, float t, vec3 normal, Light L[NUM_LIGHTS], Ray R, Sphere S[NUM_SPHERES], Plan P[NUM_PLANS],\n              Cylinder C[NUM_CYLINDERS], Cone Co[NUM_CONES]) {\n    vec3 inter = R.Origin + R.Dir * t;\n    vec3 finalColor = vec3(0.0);\n\n    float ambientStrength = 0.25; \n    finalColor += ambientStrength * color * vec3(1.2); // Soft warm ambient\n\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        vec3 lightDir = normalize(L[i].pos - inter);\n        float distanceToLight = length(L[i].pos - inter);\n        \n        // Normal orientation handling\n        vec3 N = dot(normal, -R.Dir) < 0.0 ? -normal : normal;\n\n        if (!isInShadowFromLight1(L[i], inter, S, P, C, Co)) {\n            // Enhanced diffuse lighting\n            float diff = max(dot(N, lightDir), 0.0);\n            vec3 diffuse = 1.8 * diff * color * L[i].color; \n\n            // Brighter specular highlights\n            vec3 reflectDir = reflect(-lightDir, N);\n            vec3 viewDir = normalize(R.Origin - inter);\n            float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n            vec3 specular = 1.2 * specularStrength * spec * L[i].color; \n\n            float attenuation = 1.0 / (0.5 + 0.02 * distanceToLight + 0.005 * distanceToLight * distanceToLight);\n\n            finalColor += (diffuse + specular) * attenuation;\n        }\n    }\n\n    // Brightness preservation\n    float exposure = 1.5; \n    finalColor *= exposure;\n\n    // Soft tone mapping instead of hard clamp\n    finalColor = finalColor / (finalColor + vec3(0.8)); \n\n    // Gamma correction with brightness preservation\n    return pow(finalColor, vec3(1.0/2.2));\n}\n\n\n\n////////////////////////////StickMan/////////////////////////////////////////////////\n\n\nconst float TRAIL_LIFETIME = 1.5;\nconst vec3 FIRE_COLOR1 = vec3(1.0, 0.3, 0.1);\nconst vec3 FIRE_COLOR2 = vec3(0.8, 0.1, 0.0);\nconst float AFTERIMAGE_INTERVAL = 0.3; // Seconds between afterimages\n\nstruct Stickman {\n    vec3 position;\n    Sphere head;\n    Sphere leftHand;\n    Sphere rightHand;\n    Sphere leftFoot;\n    Sphere rightFoot;\n    Cylinder body;\n    Cylinder leftArm;\n    Cylinder rightArm;\n    Cylinder leftLeg;\n    Cylinder rightLeg;\n};\n\n\nconst float headRadius = 0.35;      // Radius of the head\nconst float bodyRadius = 0.13;      // Radius of the body (cylinder)\nconst float bodyHeight = 1.7;       // Height of the body (cylinder)\nconst float limbRadius = 0.1;       // Radius of the limbs (arms and legs)\nconst float handFeetRadius = 0.15;  // Radius of hands and feet\n\n\nStickman initStickman(vec3 position, bool resetAfterimages) {\n    Stickman s;\n    \n    s.position = position;\n\n    // Body (Cylinder)\n    s.body = Cylinder(\n        s.position + vec3(0.0, 0.0, bodyHeight / 2.0), // Center of the cylinder\n        vec3(0.0, 0.0, 1.0),                         // Axis (height direction)\n        bodyRadius,                                  // Radius\n        vec2(0.0, -bodyHeight / 2.0),               // Min X (0.0 means use the second value)\n        vec2(0.0, bodyHeight / 2.0)                 // Max X (0.0 means use the second value)\n    );\n\n    // Head (Sphere on top of the body)\n    s.head = Sphere(\n        s.position + vec3(0.0, 0.0, bodyHeight + headRadius / 2.0), // Position\n        headRadius                                                // Radius\n    );\n\n    // Hands (Spheres at the ends of the arms)\n    s.leftHand = Sphere(\n        s.position + vec3(-0.7, 0.0, bodyHeight * 0.7), // Position (a bit lower than the top)\n        handFeetRadius                                // Radius\n    );\n\n    s.rightHand = Sphere(\n        s.position + vec3(0.7, 0.0, bodyHeight * 0.7),  // Position (a bit lower than the top)\n        handFeetRadius                                // Radius\n    );\n\n    // Feet (Spheres at the ends of the legs)\n    s.leftFoot = Sphere(\n        s.position + vec3(-0.2, 0.0, -1.0),              // Position (bottom of the body)\n        handFeetRadius                                // Radius\n    );\n\n    s.rightFoot = Sphere(\n        s.position + vec3(0.2, 0.0, -1.0),               // Position (bottom of the body)\n        handFeetRadius                                // Radius\n    );\n\n    // Arms (Cylinders connecting body to hands)\n    s.leftArm = Cylinder(\n        s.position + vec3(0.0, 0.0, bodyHeight * 0.7),  // Start at body (a bit lower than the top)\n        s.leftHand.Center - (s.position + vec3(0.0, 0.0, bodyHeight * 0.7)), // Axis (direction to hand)\n        limbRadius,                                   // Radius\n        vec2(0.0, 0.0),                               // Min X\n        vec2(0.0, distance(s.leftHand.Center,(s.position + vec3(0.0, 0.0, bodyHeight * 0.7))))                                // Max X\n    );\n\n    s.rightArm = Cylinder(\n        s.position + vec3(0.0, 0.0, bodyHeight * 0.7),  // Start at body (a bit lower than the top)\n        s.rightHand.Center - (s.position + vec3(0.0, 0.0, bodyHeight * 0.7)), // Axis (direction to hand)\n        limbRadius,                                   // Radius\n        vec2(0.0, 0.0),                               // Min X\n        vec2(0.0, distance(s.rightHand.Center,(s.position + vec3(0.0, 0.0, bodyHeight * 0.7))))                                // Max X\n    );\n\n    // Legs (Cylinders connecting body to feet)\n    s.leftLeg = Cylinder(\n        s.position + vec3(0.0, 0.0, 0.0),               // Start at body (bottom)\n        s.leftFoot.Center - (s.position + vec3(0.0, 0.0, 0.0)), // Axis (direction to foot)\n        limbRadius,                                   // Radius\n        vec2(0.0, 0.0),                               // Min X\n        vec2(0.0, distance(s.leftFoot.Center,(s.position + vec3(0.0, 0.0, 0.0))))                                // Max X\n    );\n\n    s.rightLeg = Cylinder(\n        s.position + vec3(0.0, 0.0, 0.0),               // Start at body (bottom)\n        s.rightFoot.Center - s.position, // Axis (direction to foot)\n        limbRadius,                                   // Radius\n        vec2(0.0, 0.),                               // Min X\n        vec2(0.0, distance(s.rightFoot.Center,(s.position + vec3(0.0, 0.0, 0.0))))                                // Max X\n    );\n\n\n    return s;\n}\n\n// Define limb animation parameters at the top of your shader\nconst float walkSpeed = 4.0;      // Walking cycle speed\nconst float legSwing = 0.6;       // How far legs move\nconst float armSwing = 0.4;       // How far arms swing\nconst float SURF_START_TIME = 8.0; // After phase1+phase2 durations\nconst float CYLINDER_SPEED = 2.0;\nconst float WOBBLE_FREQ = 3.;\nconst float MAX_WOBBLE = 3.;\n\n// Rotation helper function\nvec3 rotateAroundAxis(vec3 point, vec3 center, vec3 axis, float angle) {\n    vec3 translated = point - center;\n    float c = cos(angle);\n    float s = sin(angle);\n    return center + translated * c + cross(axis, translated) * s + axis * dot(axis, translated) * (1.0 - c);\n}\n\nStickman animationMove(Stickman s, float time) {\n    const float WOBBLE_FREQ = 2.0;\n    const float MOVE_SPEED = 0.8;\n    \n    if (time > SURF_START_TIME) {\n        // Base continuous motion\n        float progress = time * MOVE_SPEED;\n        s.position.y += sin(progress) * 0.3; // Forward/back sway\n        \n        // Continuous wobble system\n        vec3 wobble = vec3(\n            sin(time * 1.8) * 0.3,    // X wobble\n            cos(time * 2.2) * 1.5,    // Y wobble\n            sin(time * 3.0) * 0.15    // Z bounce\n        );\n        \n        // Apply wobble with decaying amplitude\n        s.position += wobble * normalize(computeTangent(vec3(4.*sin(2.*iTime), 4.*cos(2.*iTime), 5.0+4.*cos(iTime)),\n                                    vec3(0.,0.,0.), 4.)) * (0.5 + 0.3 * sin(time * 0.5));\n    }\n    return initStickman(s.position, false); // Update all connected limbs\n}\n\nStickman animateStickman(Stickman s, float time) {\n    // Calculate walking phase with offset for arms\n    float phase = sin(time * walkSpeed);\n    float legPhase = phase;\n    float armPhase = -phase; // Arms swing opposite legs\n\n    // Update limb cylinders to follow new positions\n    vec3 armBase = s.position + vec3(0.0, 0.0, bodyHeight * 0.7);\n    \n    // Legs\n    vec3 legBase = s.position;\n    \n    // Surfing phase modifications\n    if (time > SURF_START_TIME) {\n        float surfTime = time - SURF_START_TIME;\n        vec3 moveDir = normalize(computeTangent(vec3(4.*sin(2.*iTime), 4.*cos(2.*iTime), 5.0+4.*cos(iTime)),\n                                    vec3(0.,0.,0.), 4.)); // Direction along the cylinder\n        \n        // Base instability parameters\n        float panic = clamp(surfTime * 0.5, 0.5, 1.5);\n        float wobbleX = sin(time * 4.7) * (0.3 + panic * 0.4);\n        float wobbleY = cos(time * 3.2) * (0.2 + panic * 0.3);\n        \n        // Arm flailing (panic rotation)\n        float armAngle = sin(time * 3.) * (1.0 + panic) * 0.5;\n        vec3 armRotAxis = normalize(vec3(1., 0.0, 0.));\n        \n        // Rotate arms in opposite directions\n        s.leftHand.Center = rotateAroundAxis(s.leftHand.Center + vec3(0.,0.,0.4*sin(time * 5.2)), armBase, armRotAxis, armAngle);\n        s.rightHand.Center = rotateAroundAxis(s.rightHand.Center + vec3(0.,0.,0.4*sin(2. + time * -4.6)), armBase, armRotAxis, -armAngle );\n\n        vec3 walkDir = normalize(computeTangent(vec3(4.*sin(2.*iTime), 4.*cos(2.*iTime), 5.0+4.*cos(iTime)),\n                                    vec3(0.,0.,0.), 4.)); // Hardcoded start->end direction\n        // Animate legs (world space movement)\n        s.leftFoot.Center += walkDir * legPhase * legSwing;\n        s.rightFoot.Center -= walkDir * legPhase * legSwing;\n    } else {\n        vec3 walkDir = normalize(vec3(0.0, -9.0, 3.0)); // Hardcoded start->end direction\n        // Animate legs (world space movement)\n        s.leftFoot.Center += walkDir * legPhase * legSwing;\n        s.rightFoot.Center -= walkDir * legPhase * legSwing;\n\n        // Animate arms (local space movement)\n        s.leftHand.Center += walkDir * armPhase * armSwing;\n        s.rightHand.Center -= walkDir * armPhase * armSwing;\n    }\n        \n    // Left Arm\n    s.leftArm.axis = s.leftHand.Center - armBase;\n    s.leftArm.maxx.y = length(s.leftArm.axis);\n        \n    // Right Arm\n    s.rightArm.axis = s.rightHand.Center - armBase;\n    s.rightArm.maxx.y = length(s.rightArm.axis);\n        \n    // Left Leg\n    s.leftLeg.axis = s.leftFoot.Center - legBase;\n    s.leftLeg.maxx.y = length(s.leftLeg.axis);\n        \n    // Right Leg\n    s.rightLeg.axis = s.rightFoot.Center - legBase;\n    s.rightLeg.maxx.y = length(s.rightLeg.axis);\n           \n\n  \n\n    return s;\n}\n\nvoid updateStickmanParts(inout Stickman s, int sphereIndex, int cylinderIndex, inout Sphere S[NUM_SPHERES], inout Cylinder Cy[NUM_CYLINDERS]) {\n    // Update spheres\n    S[sphereIndex] = s.head;       // Head sphere\n    S[sphereIndex + 1] = s.leftHand;  // Left hand sphere\n    S[sphereIndex + 2] = s.rightHand; // Right hand sphere\n    S[sphereIndex + 3] = s.leftFoot;  // Left foot sphere\n    S[sphereIndex + 4] = s.rightFoot; // Right foot sphere\n\n    // Update cylinders\n    Cy[cylinderIndex] = s.leftArm;   // Left arm cylinder\n    Cy[cylinderIndex + 1] = s.rightArm; // Right arm cylinder\n    Cy[cylinderIndex + 2] = s.leftLeg;  // Left leg cylinder\n    Cy[cylinderIndex + 3] = s.rightLeg; // Right leg cylinder\n    Cy[cylinderIndex + 4] = s.body;    // Body cylinder\n}\n\n\n\n\n\n\n///////////////////////////////MAIN//////////////////////////////////////////////////\n\n \nconst vec3 junctionPoint = vec3(-1.5, 1.0, 1.0); // Intersection of P[0] and P[1]\nconst float phase1Duration = 3.0; // Time to reach junction\nconst float phase2Duration = 5.12; // Time to climb P[0]\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialize the camera\n    Camera C = camera(\n        vec3(-5., 10., 15.4),\n        //vec3(-10.0, -5., 10.4),\n        vec3(1.1, 3.0, 6.0),\n        70.0\n    );\n\n    // Define lights\n    Light L[NUM_LIGHTS];\n    L[0] = Light(vec3(4., 8., 8.4), vec3(1.0, 0.0, 1.0));\n    L[1] = Light(vec3(4.,4.,25.), 0.3*vec3(1.0, 1.0, 1.0));\n    L[2] = Light(vec3(-20.0, 4.+20.*cos(iTime*0.2), 4.0), vec3(0.0, 1.0, 1.0));\n\n    vec3 col = vec3(0.0, 0.3, 0.8); // Default background color\n\n    // Initialize the ray\n    Ray r = launch(C, fragCoord);\n\n    // Define start and end positions\n    vec3 startPos = vec3(-1.5, 6.0, 1.0); // On P[1] (feet at z=0)\n    vec3 endPos = vec3(-1.5, -3.5, 5.2);  // On P[0]\n    \n    // Calculate movement path\n    float t = iTime;\n    vec3 currentPos;\n\n    \n    if(t < phase1Duration) {\n        // Walk along P[1] to junction\n        float phase = smoothstep(0.0, 1.0, t/phase1Duration);\n        currentPos = mix(startPos, junctionPoint, phase);\n        \n    } else {\n        if (t < phase1Duration + phase2Duration){\n        // Walk up P[0] from junction\n            float phase = smoothstep(0.0, 1.0, (t-phase1Duration)/phase2Duration);\n            currentPos = mix(junctionPoint, endPos, phase);\n        } else {\n            currentPos = vec3(4.*sin(2.*iTime), 4.*cos(2.*iTime), 6.8+4.*cos(iTime));\n            //currentPos = vec3(0.,0.,3.);\n        }\n    }\n\n\n    // Initialize stickman at currentPos and animate\n    Sphere S[NUM_SPHERES];\n    Cylinder Cy[NUM_CYLINDERS];\n\n    // Initialize stickman once with reset, then preserve\n    Stickman stickman;\n\n    stickman = initStickman(currentPos, true);\n\n    \n    // Create multiple \"ghost\" stickmen at time-offset positions\n    for(int i = 1; i <= NUM_TRAILS; i++) {  // Create 5 afterimages\n        float timeOffset = float(i) * 0.5;  // Each ghost is 0.5 seconds behind\n        float pastTime = max(0.0, iTime - timeOffset);\n        \n        // Calculate the position for this past time\n        vec3 ghostPos;\n        if(pastTime < phase1Duration) {\n            float phase = smoothstep(0.0, 1.0, pastTime/phase1Duration);\n            ghostPos = mix(startPos, junctionPoint, phase);\n        } else {\n            if (pastTime < phase1Duration + phase2Duration){\n                float phase = smoothstep(0.0, 1.0, (pastTime-phase1Duration)/phase2Duration);\n                ghostPos = mix(junctionPoint, endPos, phase);\n            } else {\n                ghostPos = vec3(4.*sin(2.*pastTime), 4.*cos(2.*pastTime), 6.8+4.*cos(pastTime));\n            }\n        }\n        \n        // Create and render ghost\n        Stickman ghost = initStickman(ghostPos, false);\n        ghost = animationMove(ghost, pastTime);\n        ghost = animateStickman(ghost, pastTime);\n        \n        int ghostSphereOffset = 5 + (i+1) * 5;  // Offset indices for each ghost\n        int ghostCylinderOffset = 7 + (i+1) * 5;\n        updateStickmanParts(ghost, ghostSphereOffset, ghostCylinderOffset, S, Cy);\n    }\n    \n    \n    \n\n    \n    // Animate and update\n    stickman = animationMove(stickman, t);\n    stickman = animateStickman(stickman, t);\n    updateStickmanParts(stickman, 5, 7, S, Cy);\n    \n\n    // Define the spheres\n    //S[1] = Sphere(S[0].Center + vec3(cos(iTime * 4.0), sin(iTime * 4.0), 0.0), 0.2);\n\n    \n\n    // Define the planes\n    Plan P[NUM_PLANS];\n    //P[0] = Plan(vec3(0.0, -3.0, 4.0), vec3(0.0, -1.0, 1.0), vec3(1.0, 0.0, 0.0),vec2(0.,-1.+min(-10.*cos(iTime),0.)),vec2(0.,1.+ max(3.*sin(iTime),0.)),vec2(1.,0.),vec2(1.,0.));\n    P[0] = Plan(vec3(0.0, -3.0, 4.0), vec3(0.0, -1.0, 1.0), vec3(1.0, 0.0, 0.0),vec2(0.,-7.),vec2(0.,1.+ max(3.*sin(iTime),0.)),vec2(1.,0.),vec2(1.,0.));\n    P[1] = Plan(vec3(0.,0.,0.),vec3(1.,0.,0.),vec3(0.,1.,0.),vec2(1.,0.),vec2(1.,0.),vec2(1.,0.),vec2(1.,0.));\n\n    // Define the cylinders\n    Cy[0] = Cylinder(vec3(4.*sin(2.*iTime), 4.*cos(2.*iTime), 5.0+4.*cos(iTime)),\n                   computeTangent( vec3(4.*sin(2.*iTime), 4.*cos(2.*iTime), 5.0+4.*cos(iTime)),\n                                    vec3(0.,0.,0.), 4.), 0.7,vec2(0.,-2.),vec2(0.,2.));\n    //Cy[1] = Cylinder(vec3(-8.0, 0.0, 15.), vec3(0., sin(iTime), cos(iTime)), 3.,vec2(0.,-2.),vec2(0.,2.));\n    //Cy[1] = Cylinder(vec3(-8.0, 0.0, 15.), vec3(0.,0.,1.), 3.,vec2(1.,-2.),vec2(1.,2.));\n    //Cy[2] = Cylinder(vec3(8.0, 0.0, 6.), vec3(cos(iTime) +2.*sin(iTime),cos(iTime) -2.*sin(iTime),  -cos(iTime))\n    //                , 0.3,vec2(0.,-2.),vec2(0.,2.));\n    //Cy[3] = Cylinder(vec3(-0.8, 0.0, 2.2), vec3(0.0, -1.0, 0.0), 0.2, vec2(1.0, 0.0), vec2(1.0, 0.0));\n    //Cy[4] = Cylinder(vec3(0.8, 0.0, 2.2), vec3(0.0, 1.0, 0.0), 0.2, vec2(1.0, 0.0), vec2(1.0, 0.0));\n\n\n\n    // Define Cones\n    Cone Co[NUM_CONES];\n    \n    vec3 cylPos = vec3(4.*sin(2.*iTime), 4.*cos(2.*iTime), 5.0+4.*cos(iTime));\n    vec3 cylDir = normalize(computeTangent(cylPos, vec3(0.,0.,0.), 4.));\n\n    // Position the cone at the front of the cylinder (offset by 2 units which is the cylinder's length)\n    vec3 conePos = cylPos - cylDir * -3.5;\n    // Create the cone using the same direction as the cylinder\n    Co[0] = Cone(conePos, -cylDir, 1.7, 0.82);\n    //Co[0] = Cone(vec3(0.,0.,5.),vec3(1., 1,1.),5.,1.);\n    //Co[1] = Cone(vec3(0.0, 0.0, 3.8), vec3(0.0, 0.0, 1.0), 0.3, 0.1);\n    \n    \n    // Track the closest intersection\n    float tClosest = 1e10;\n    vec3 closestColor = col;\n\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        float tSphere;\n        if (intersect_sphere(r, Sphere(L[i].pos,0.2), tSphere) && tSphere > 0.0 && tSphere < tClosest) {\n            tClosest = tSphere;\n            closestColor = getColor(L[i].color, tSphere, normalize((r.Origin + r.Dir * tSphere) - S[i].Center), L, r, S, P,  Cy, Co);\n        }\n        \n    \n    }\n\n    // Iterate over all spheres\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        float tSphere;\n        if (intersect_sphere(r, S[i], tSphere) && tSphere > 0.0 && tSphere < tClosest) {\n            tClosest = tSphere;\n            closestColor = getColor(vec3(1.0, 1.0, 0.0), tSphere, normalize((r.Origin + r.Dir * tSphere) - S[i].Center), L, r, S, P,  Cy, Co);\n        }\n    }\n    \n    \n    \n    // Iterate over all planes\n    for (int i = 0; i < NUM_PLANS; i++) {\n        float tPlan;\n        vec2 uv;\n        if (intersect_plan(r, P[i], tPlan, uv) && tPlan > 0.0 && tPlan < tClosest) {\n                if (mod(uv.x, 2.0) < 1.0 || mod(uv.y, 2.0) < 1.0) {\n                    if (mod(uv.x, 2.0) < 1.0 && mod(uv.y, 2.0) < 1.0) {\n                        closestColor = getColor(vec3(0.0, 0.0, 0.0), tPlan, normalize(cross(P[i].ab, P[i].ord)), L, r, S, P,  Cy, Co);\n                    } else {\n                        closestColor = getColor(vec3(1.0, 1.0, 1.0), tPlan, normalize(cross(P[i].ab, P[i].ord)), L, r, S, P,  Cy, Co);\n                    }\n                } else {\n                    closestColor = getColor(vec3(0.0, 0.0, 0.0), tPlan, normalize(cross(P[i].ab, P[i].ord)), L, r, S, P,  Cy, Co);\n                }\n                tClosest = tPlan;\n         }\n    }\n\n    // Iterate over all cylinders\n    for (int i = 0; i < NUM_CYLINDERS; i++) {\n        float tCyl;\n        vec2 uv;\n        bool inner;\n        if (intersect_cylinder(r, Cy[i], tCyl, uv, inner) && tCyl > 0.0 && tCyl < tClosest) {\n            tClosest = tCyl;\n\n            vec3 normal = cylinderNormal(Cy[i], (r.Origin + tCyl * r.Dir));\n            if (inner) normal = -normal;\n\n            closestColor = getColor(vec3(0.0, 0.0, 0.0), tCyl, normal, L, r, S, P, Cy, Co);\n        }\n\n    }\n        // Iterate over all cones\n    for (int i = 0; i < NUM_CONES; i++) {\n        float tCone;\n        bool inner;\n        vec3 normal;\n        if (intersect_cone(r, Co[i], tCone, normal, inner) && tCone > 0.0 && tCone < tClosest) {\n            tClosest = tCone;\n            // Reverse normal if the hit is from inside the cone for correct lighting\n            if (inner) normal = -normal;\n            closestColor = getColor(vec3(1.0, 0.0, 0.0), tCone, normal, L, r, S, P, Cy, Co); // Example color change\n        }\n    }\n\n    // Output the final color\n    fragColor = vec4(closestColor, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cVBWc","date":"1734535745","viewed":45,"name":"Stickman Parkour","username":"Junper","description":"finished","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"XfyBDV","parentname":"color bubble 2"}}