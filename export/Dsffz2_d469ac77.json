{"ver":"0.1","info":{"id":"Dsffz2","date":"1688936461","viewed":94,"name":"Ray-plane patch intersection","username":"Envy24","description":"Ray-plane patch intersection","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ray","intersection","plane","patch"],"hasliked":0,"parentid":"7dsfzl","parentname":"ray-axis aligned box intersectio"},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BACKGROUND (vec4(normalize(1.0 - rayDir), 1.0))\n#define R iResolution\n\nfloat shootRayInPlanePatch(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 origin,\n    vec3 right,\n    vec3 up,\n    vec2 half_size,\n    inout vec3 outNormal,\n    inout vec2 uv)\n{\n    vec4 r1 = vec4(right.x, up.x, -rayDir.x, ray.x - origin.x), // au+bv+ct = d\n         r2 = vec4(right.y, up.y, -rayDir.y, ray.y - origin.y), // eu+fv+gt = h\n         r3 = vec4(right.z, up.z, -rayDir.z, ray.z - origin.z); // ku+lv+mt = n\n\n    vec3 uvt = solve_linear_system33(r1, r2, r3);\n\n    //vec3 hit_point = origin + right * uvt.x + up * uvt.y;\n    //vec3 hit_point = ray + rayDir * uvt.z;\n    \n    // Output\n    outNormal = cross(right, up);\n    uv = uvt.xy;  \n\n    bool is_hit =\n        abs(uvt.x) < half_size.x &&\n        abs(uvt.y) < half_size.y &&\n            uvt.z > 0.;\n                \n    return \n        is_hit == true ?\n            uvt.z :\n            -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    /* Perspective camera with lookat. */\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n    camera = rotateAroundY(camera, iTime * 0.5);\n    camera = rotateAroundX(camera, 0.4);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n    \n    float size = 36.0;\n    float aspectRatio = R.x / R.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n\n\n    /* Ray tracing */\n    vec3 outNormal;\n    vec3 origin = vec3(0,0,0);\n    vec3 right = vec3(1,0,0);\n    vec3 up = vec3(0,1,0);\n    vec2 half_size = iResolution.xy / iResolution.y;\n    vec2 UV = vec2(0);\n    float t = shootRayInPlanePatch(ray, rayDir, origin, right, up, half_size, outNormal, UV);\n    /* Ray tracing */\n\n    /* Shading */\n    vec4 color = \n        t >= 0.0 ?\n            texture(iChannel0, (UV / half_size + vec2(1)) * 0.5):\n            //vec4(1,0,0,1) :\n            //normalize(vec4(t,t,t,1.0)) :\n            //vec4(outNormal, 1.0) :\n            //vec4((normalize(outNormal) + vec3(1.0)) * 0.5, 1.0) :\n            BACKGROUND;\n    /* Shading */\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/* Returns cosine modulated value in range [min, max]. */\nfloat cosOSC(in float min, in float max, in float T)\n{\n    float v = (cos(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec3 solve_linear_system33(vec4 r1, vec4 r2, vec4 r3) // plane-plane-plane intersection\n{\n    float delta = \n        determinant(mat3(\n            r1.x, r2.x, r3.x,\n            r1.y, r2.y, r3.y,\n            r1.z, r2.z, r3.z));\n    float inv = \n        delta == 0. ? // No solution (intersection)?\n            0. :\n            1. / delta; \n    \n    float delta1 = \n        determinant(mat3(\n            r1.w, r2.w, r3.w,\n            r1.y, r2.y, r3.y,\n            r1.z, r2.z, r3.z));\n            \n    float delta2 = \n        determinant(mat3(\n            r1.x, r2.x, r3.x,\n            r1.w, r2.w, r3.w,\n            r1.z, r2.z, r3.z));\n            \n    float delta3 =\n        determinant(mat3(\n            r1.x, r2.x, r3.x,\n            r1.y, r2.y, r3.y,\n            r1.w, r2.w, r3.w));\n            \n    // total: 39 muls, 20 subs/adds, 1 div\n    \n    return vec3(delta1, delta2, delta3) * inv;\n}","name":"Common","description":"","type":"common"}]}