{"ver":"0.1","info":{"id":"tlyGR3","date":"1579548772","viewed":98,"name":"RayMarch - Test","username":"funnbot","description":"Move with mouse and wasd,\n\nraymarching from the art of code and a mess of other tutorials.\n\nI will attempt to comment this and use readable variable names as it seems everyone else on shadertoy thinks single letter variables is fine.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NORMAL_EPS 0.1\n\n#define MAX_STEPS 100\n#define MAX_DIST 70.\n#define SURF_DIST .001\n\n\n\nstruct PointLight {\n\tvec3 position;\n    \n    float intensity;\n    float attenuation;\n    vec3 color;\n};\n\n#define SKY_COLOR vec3(.3, .36, .6)\n    \n#define AMBIENT 0.1\n#define AMBIENT_COLOR vec3(1, .9, .7)\n    \n#define SHADOW_FALLOFF .03\n#define SOFT_SHADOWS 0\n\nPointLight pointLight = PointLight(vec3(3, 3, -7), 40., 0.9, vec3(1, 1, 1));\n    \nfloat GetDist(vec3 point) {\n\tvec4 sphere = vec4(0, 0, 0, .6);\n    float distSphere = opRep(sdSphere(point, sphere), vec3(1, 1, 1));\n    \n    vec3 boxPos = vec3(0, 0.1, 0);\n    vec3 boxRot = vec3(45. * DEG_RAD, 45. * DEG_RAD, 0);\n    vec3 boxSize = vec3(.2);\n    \t\n    float distBox = sdBox(opTransform(point, boxPos, boxRot), boxSize);\n    \n    float plane = -1.;\n    float distPlane = point.y - plane;\n   \n    //return distBox;\n    return min(distPlane, distSphere);\n}\n\n\nvec3 GetNormal(vec3 point) {\n    // Get the distance from this point to the scene\n    float dist = GetDist(point);\n    // error to swizzle and get the individual errors of dist\n    vec2 eps = vec2(NORMAL_EPS, 0);\n    \n    vec3 closePoint = vec3(\n        // dist on x plane\n    \tGetDist(point - eps.xyy),\n        // dist on y plane\n        GetDist(point - eps.yxy),\n        // dist on z plane\n        GetDist(point - eps.yyx));\n    \n    vec3 normal = dist - closePoint;\n    \n    // normlize, length is known -> eps.x\n    return normal / eps.x;\n}\n\nfloat RayMarch(vec3 orig, vec3 dir) {\n    // Final distance to the scene\n\tfloat dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Move in direction by dist from origin\n    \tvec3 pos = orig + dir * dist;\n        float sceneDist = GetDist(pos);\n        dist += sceneDist;\n        if (dist > MAX_DIST) return -1.;\n        \n        if (sceneDist < SURF_DIST) break;\n    }\n    \n    return dist;\n}\n\nfloat GetShadow(vec3 point, vec3 normal, vec3 lightDir, vec3 viewDir, float lightDist) {\n\tfloat shadow = 0.0;\n    int shadowRays = 0;\n    \n    #if SOFT_SHADOWS == 0\n    \n    float dist = RayMarch(point + normal * 0.1, lightDir);\n    if (dist > 0.0) {\n        shadow = step(dist, lightDist);\n    }\n    shadowRays = 1;\n    \n    #else\n    \n    int rays = 5;\n    for (int i = 0; i < rays; i++) {\n        vec3 shadowOrig = point + normal * 0.1;\n        float rn = rand(viewDir.xy + float(i)) * 2.0 - 1.0;\n        vec3 shadowDir = lightDir + (rn * SHADOW_FALLOFF);\n        float dist = RayMarch(shadowOrig, shadowDir);\n        if (dist > 0.0) {\n            shadow += (lightDist - dist) / lightDist;\n        }\n    }\n    shadowRays += rays;\n    \n    #endif\n\t\n    return shadow / float(shadowRays);\n}\n\nvec3 GetLight(vec3 point, vec3 viewDir) {    \n    \n    //pointLight.position += vec3(sin(iTime)*5., 0, cos(iTime)*4.);\n    \n    // ambient\n    vec3 ambient = AMBIENT * AMBIENT_COLOR;\n    \n    // attenuation?\n    float lightDist = length(pointLight.position - point);\n    float attenuation = clamp(pointLight.intensity / pow(lightDist*pointLight.attenuation, 2.), 0.0, 1.0);\n    \n    // diffuse \n    vec3 lightDir = normalize(pointLight.position - point);\n    vec3 normal = GetNormal(point);\n    float diffuseIntensity = max(0.0, dot(lightDir, normal));\n    vec3 diffuse = attenuation * diffuseIntensity * pointLight.color;\n    \n    // specular\n    float specularStrength = 0.85;\n    float specularIntensity = 0.0;\n    // http://ogldev.atspace.co.uk/www/tutorial19/tutorial19.html\n    vec3 lightReflect = normalize(reflect(lightDir, normal));\n    float specularFactor = max(0.0, dot(viewDir, lightReflect));\n    if (specularFactor > 0.0) {\n    \tspecularFactor = pow(specularFactor, 32.);\n    }\n    vec3 specular = attenuation * specularStrength * specularFactor * pointLight.color;\n    \n    // shadow\n\tfloat shadow = GetShadow(point, normal, lightDir, viewDir, lightDist);\n\t\n    vec3 light = ambient + (diffuse + specular) * (1. - shadow);\n    return clamp(light, 0.0, 1.0);\n}\n\n#define MOUSE_TO_SCREEN(v2) (((v2) - 0.5 * iResolution.xy) / iResolution.y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Center the UV\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec4 mouseInp = texelFetch(iChannel0, ivec2(0, 1), 0);\n    vec4 keyInp = texelFetch(iChannel0, ivec2(0, 2), 0);\n    \n    \n    mat3 camRot = RotationMatrix(vec3(0, 1, 0), -mouseInp.x) * \n                      RotationMatrix(vec3(1, 0, 0), mouseInp.y);\n    vec3 camDir = camRot * normalize(vec3(uv, FOCAL_LENGTH));\n    \n    vec3 camPos = vec3(keyInp.x, keyInp.y, keyInp.z);\n    vec3 camOrig = vec3(0, 1, -6) + camPos;\n    \n    \n   \tfloat dist = RayMarch(camOrig, camDir);\n    \n    vec3 col = vec3(0);\n    if (dist < -0.5) col = SKY_COLOR - (camDir.y * 0.6);\n    else {\n    \tvec3 point = camOrig + camDir * dist;\n    \tcol = GetLight(point, camDir);\n       \n        float fog = dist / MAX_DIST;\n        col = mix(col, SKY_COLOR, fog);\n    }\n    \n    // Gamma correction\n    col = LinearToGamma(col);\n    fragColor = vec4(col, 1);\n    //fragColor = vec4(MOUSE_TO_SCREEN(iMouse.zw), 0, 1);\n    //fragColor = texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define DEG_RAD 0.01745329252\n\n#define FOCAL_LENGTH 1.7\n\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 RotationMatrix(vec3 axis, float angle) {\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    vec3 as = axis * sin(angle);\n    \n    return mat3(oc * axis.xxz * axis.xyx + vec3(c, -as.z, as.y),\n                oc * axis.xyy * axis.yyz + vec3(as.z, c, -as.x), \n                oc * axis.zyz * axis.xzz + vec3(-as.y, as.x, c));\n}\nvec3 LinearToGamma(vec3 rgb) {\n    return pow(rgb, vec3(0.454545));\n}\n\n// sphere -> (x, y, z, w) -> (xPos,  yPos, zPos, radius)\nfloat sdSphere(vec3 p, vec4 sphere) {\n\treturn length(sphere.xyz - p) - sphere.w;\n}\nfloat sdPlane(vec3 p, float planeY) {\n\treturn 1.0;\n}\nfloat sdBox(vec3 p, vec3 size) {\n\tvec3 q = abs(p) - size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opTransform(vec3 p, vec3 pos, vec3 angles) {\n\treturn p * RotationMatrix(vec3(1, 0, 0), angles.x) *\n        \t   RotationMatrix(vec3(0, 1, 0), angles.y) *\n               RotationMatrix(vec3(0, 0, 1), angles.z) - pos;\n}\nvec3 opRep(out vec3 p, vec3 period) {\n\treturn mod(p + 0.5 * period, period) - 0.5 * period;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Camera Controller\n\n#define LOOK_SPEED 0.02\n#define MOVE_SPEED 10.\n\n#define THIS_BUFFER_CHANNEL iChannel0\n#define KEYBOARD_CHANNEL iChannel1\n\n#define KEY_DOWN(idx) (texelFetch(KEYBOARD_CHANNEL, ivec2((idx), 0), 0).x)\n\n#define IS_COORD(x, y) (floor(fragCoord.xy) == vec2((x), (y)))\n#define COORD_DATA(x, y) (texelFetch(THIS_BUFFER_CHANNEL, ivec2((x), (y)), 0))\n\n#define MOUSE_DOWN() (step(0.5, iMouse.z))\n#define MOUSE_TO_SCREEN(v2) (((v2) - 0.5 * iResolution.xy) / iResolution.y)\n\nconst int KEY_W = 87, KEY_A = 65, KEY_S = 83,\n          KEY_D = 68, KEY_SPACE = 32, KEY_SHIFT = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 lookData = COORD_DATA(0, 1);\n    vec4 prevLook = COORD_DATA(1, 1);\n    \n    // Rotation\n    if (IS_COORD(0, 1)) {\n        lookData.xy = prevLook.xy + MOUSE_TO_SCREEN(iMouse.xy) * LOOK_SPEED;\n        fragColor = lookData;\n    // Prev Rotation\n    } else if (IS_COORD(1, 1)) {\n        \n    \tfragColor = lookData;\n    // Position\n    } else if (IS_COORD(0, 2)) {\n    \tvec4 posData = COORD_DATA(0, 2);\n        vec3 move = vec3(KEY_DOWN(KEY_D) - KEY_DOWN(KEY_A), 0,\n                         KEY_DOWN(KEY_W) - KEY_DOWN(KEY_S))\n\t\t\t\t      * MOVE_SPEED * iTimeDelta;\n        \n        mat3 camRot = RotationMatrix(vec3(0, 1, 0), -lookData.x) * \n                      RotationMatrix(vec3(1, 0, 0), lookData.y);\n        \n        posData += vec4(camRot * move, 1);\n        posData += vec4(0, KEY_DOWN(KEY_SPACE) - KEY_DOWN(KEY_SHIFT), 0, 0) \n            \t\t* MOVE_SPEED * iTimeDelta;\n        \n        fragColor = posData;\n        \n    } else fragColor = vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"}]}