{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float EPS = 0.03; // large epsilon to smooth edges and lower artifacts\nconst int MAXI = 150;\t \nconst float MAXD = 30.; \n\nvec3 hsv(float h,float s,float v) { \n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 repeater(vec3 p) {\n\tvec3 repeat = vec3(1.1);\n\treturn mod(p+ + vec3(.0,.0,-iTime),repeat) - 0.5 * repeat;\n}\n\nfloat scenedist(vec3 p){ \n\n\tfloat s2 = length(p)-2.;\n\n\n\tfloat s3 = length(max(abs(repeater(p)) -vec3(.2), .0)) - 0.2; \n\t\n\treturn max(s2, s3);\n}\n\nvec3 getNormal(vec3 pos){ \n\tvec2 eps = vec2(0.0, EPS);\n\treturn normalize(vec3( \n\t\t\tscenedist(pos + eps.yxx) - scenedist(pos - eps.yxx),\n\t\t\tscenedist(pos + eps.xyx) - scenedist(pos - eps.xyx),\n\t\t\tscenedist(pos + eps.xxy) - scenedist(pos - eps.xxy)));\n}\n\nvec3 renderworld(vec2 uv){ \n\t\n\tvec3 camPos = vec3(3.*sin(iMouse.x/iResolution.x*2.),-3.*cos(iMouse.x/iResolution.x*2.),2.);\n\tvec3 camTarg = vec3(0.);\n\tvec3 camUp = normalize(vec3(0.,0.,1.));\n\t\n\t// camera points to target from camera\n\t// remember that all directions must be normalised, or shit goes craycray\n\tvec3 camDir = normalize(camTarg - camPos);\n\t// right is perpendicular to up and forwards\n\tvec3 camRight = normalize(cross(camUp,camDir));\n\t// change UP to be relative to camera\n\tcamUp = normalize(cross(camDir,camRight));\n\t\n\t// This pixel will cast ray in the camera direction, but a bit up/down and sidewise\n\tvec3 rayDir = normalize(camDir+uv.x*camRight+uv.y*camUp);\n\t\n\t// the first distance we will jump\n\tfloat dist = scenedist(camPos);\n\t// must maintain the total or we will not know where we hit when we do\n\tfloat total = dist;\n\t\n\n\tvec3 c2 = hsv(.63,1.,smoothstep(-1.5,2.5,uv.y)); \n\n\t\n\t// now we march along the ray a lot\n\tfor(int i = 0;i<MAXI;i++){\n\t\tdist = scenedist(camPos+rayDir*total); // distance to closest thing (safe jump distance)\n\t\ttotal += dist;\t\t\t\t\t\t   // add it to our progress\n\t\tif(dist<EPS || dist>MAXD){continue;}   // quit if we hit something or are lost\n\t}\n\tvec3 dest = camPos+rayDir*total; // this is where we ended up\n\tvec3 c;\t\t\t\t\t\t\t // this will be our pixel colour\n\tif(dist<EPS){\t\t\t\t\t // if we score a hit\n\t\n\tfloat lum = dot(getNormal(dest), normalize(camPos));\n\tc = vec3(lum * 0.5, lum *0.2, lum*0.5) * sin( 100.* length(repeater(dest)))+vec3(pow(lum, 25.));         // we make colours\n\t\t\n\t}\n\telse\n\t{\n\t\tc = c2;// no hit, we are lost in the sky\n\t}\n\t\n\t\t\n\treturn mix(c, c2, clamp(0.8-(dest.z+1.0)/2.0, 0.0, 1.0)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(2.0,2.0/(iResolution.x/iResolution.y)); \n\t\n\tvec3 c = renderworld(uv);\n\t\n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdfSR2","date":"1403799895","viewed":281,"name":"Raymarching tweaks","username":"Lanza","description":"First tweaks with raymarching distance fields, based on \"Raymarch Tut Thingy\" by squeakyneb (https://www.shadertoy.com/view/MssXWM). Had fun with operation, repetition, (approximative) lighting, (very) simple volumetric texturing...\n\nQuick and dirty...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","repetition","simplevolumetrictexture"],"hasliked":0,"parentid":"","parentname":""}}