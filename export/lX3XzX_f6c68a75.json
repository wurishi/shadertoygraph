{"ver":"0.1","info":{"id":"lX3XzX","date":"1719333086","viewed":59,"name":"CLAUDE V13.5","username":"CDucree","description":"Generated by Claude 3.5 Sonnet. Took more than an hour... bid boooÂ³\n\n@IQ: Wouldn't it be interesting to put all high rated shaders into an LLM?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["aishader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tower with Rotating Arcs - Enhanced Shiny Material\n#define PI 3.14159265359\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define NUM_ARCS 15.0\n#define TOWER_HEIGHT 10.0\n#define ARC_SPAWN_INTERVAL 0.3\n\n// Simple hash function for pseudo-random numbers\nfloat hash(float n) { return fract(sin(n) * 43758.5453123); }\n\nfloat sdCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdArc(vec3 p, float innerRadius, float outerRadius, float height, float angle, float rotationAngle) {\n    p.xz = mat2(cos(rotationAngle), -sin(rotationAngle), sin(rotationAngle), cos(rotationAngle)) * p.xz;\n    vec2 polar = vec2(length(p.xz), atan(p.z, p.x));\n    polar.y = mod(polar.y + PI, 2.0 * PI) - PI;\n    float d = max(abs(polar.x - (innerRadius + outerRadius) * 0.5) - (outerRadius - innerRadius) * 0.5,\n                  abs(p.y) - height * 0.5);\n    return max(d, abs(polar.y) - angle * 0.5);\n}\n\nfloat scene(vec3 p) {\n    float tower = sdCylinder(p, TOWER_HEIGHT, 0.5);\n    \n    float time = iTime;\n    float descentSpeed = 2.0;\n    float rotationSpeed = 0.5;\n    \n    for (float i = 0.0; i < NUM_ARCS; i += 1.0) {\n        float arcTime = mod(time + i * ARC_SPAWN_INTERVAL, NUM_ARCS * ARC_SPAWN_INTERVAL);\n        float y = mod(TOWER_HEIGHT + 5.0 - arcTime * descentSpeed, TOWER_HEIGHT + 5.0) - 5.0;\n        \n        float rotationAngle = arcTime * rotationSpeed;\n        \n        float seed = i;\n        float randomAngle = hash(seed) * PI * 0.7 + PI * 0.3;\n        float arcRotation = hash(seed * 1.234) * 2.0 * PI;\n        \n        vec3 arcPos = vec3(p.x, p.y - y, p.z);\n        arcPos.xz = mat2(cos(rotationAngle), -sin(rotationAngle), sin(rotationAngle), cos(rotationAngle)) * arcPos.xz;\n        \n        float arc = sdArc(arcPos, 0.7, 1.2, 0.2, randomAngle, arcRotation);\n        tower = min(tower, arc);\n    }\n    \n    return tower;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    return normalize(vec3(\n        scene(p + e.xyy) - scene(p - e.xyy),\n        scene(p + e.yxy) - scene(p - e.yxy),\n        scene(p + e.yyx) - scene(p - e.yyx)\n    ));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = scene(p);\n        dO += dS;\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(3.0 * sin(iTime * 0.2), TOWER_HEIGHT * 0.5, -3.0 * cos(iTime * 0.2)) + 3.0;\n    vec3 lookAt = vec3(0, TOWER_HEIGHT * 0.5, 0);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(uv.x * r + uv.y * u + 1.5 * f);\n    \n    float d = rayMarch(ro, rd);\n    \n    vec3 col;\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 lightDir = normalize(vec3(1, 2, -3));\n        \n        // Diffuse\n        float diff = max(dot(n, lightDir), 0.0);\n        vec3 diffuse = vec3(0.1, 0.1, 0.1) * diff; // Darker base color for shinier look\n        \n        // Specular\n        vec3 reflectDir = reflect(-lightDir, n);\n        float spec = pow(max(dot(rd, reflectDir), 0.0), 256.0); // Increased exponent for sharper highlight\n        vec3 specular = vec3(1.0) * spec;\n        \n        // Reflection\n        vec3 reflected = reflect(rd, n);\n        vec3 envColor = texture(iChannel0, reflected).rgb;\n        \n        // Fresnel\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);\n        \n        // Combine components with increased reflectivity\n        col = diffuse * 0.5 + specular + mix(diffuse, envColor, fresnel) * 0.2;\n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    // Tone mapping and gamma correction\n    col = col / (1.0 + col);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}