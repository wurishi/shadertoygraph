{"ver":"0.1","info":{"id":"WsXGzj","date":"1546795570","viewed":1317,"name":"double vs single precision","username":"JoshScholar","description":" jesosk's simple-mandelbrot with a double precision library plugged in.  Single precision on the bottom. \n\nNote, the weird coding with the use of mix was to keep overly zealous compilers from optimizing the operations into orders which lose precision. ","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["math","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\t// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n\t//\n\t// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n\t// Substract: res = ds_add(a, b) => res = a + b\nfloat times_frc(float a, float b) {\n  return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat plus_frc(float a, float b) {\n  return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat minus_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\n// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n//\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\nvec2 add (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = plus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = plus_frc(plus_frc(plus_frc(minus_frc(dsb.x, e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Substract: res = ds_sub(a, b) => res = a - b\nvec2 sub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = minus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = minus_frc(plus_frc(plus_frc(minus_frc(minus_frc(0.0, dsb.x), e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat cmp(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 mul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = times_frc(dsa.x, split);\n  conb = times_frc(dsb.x, split);\n  a1 = minus_frc(cona, minus_frc(cona, dsa.x));\n  b1 = minus_frc(conb, minus_frc(conb, dsb.x));\n  a2 = minus_frc(dsa.x, a1);\n  b2 = minus_frc(dsb.x, b1);\n\n  c11 = times_frc(dsa.x, dsb.x);\n  c21 = plus_frc(times_frc(a2, b2), plus_frc(times_frc(a2, b1), plus_frc(times_frc(a1, b2), minus_frc(times_frc(a1, b1), c11))));\n\n  c2 = plus_frc(times_frc(dsa.x, dsb.y), times_frc(dsa.y, dsb.x));\n\n  t1 = plus_frc(c11, c2);\n  e = minus_frc(t1, c11);\n  t2 = plus_frc(plus_frc(times_frc(dsa.y, dsb.y), plus_frc(minus_frc(c2, e), minus_frc(c11, minus_frc(t1, e)))), c21);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n\n  return dsc;\n}\n\n// create double-single number from float\nvec2 set(float a) {\n  return vec2(a, 0.0);\n}\n\nfloat rand(vec2 co) {\n  // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\n// double complex multiplication\nvec4 dcMul(vec4 a, vec4 b) {\n  return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));\n}\n\nvec4 dcAdd(vec4 a, vec4 b) {\n  return vec4(add(a.xy,b.xy),add(a.zw,b.zw));\n}\n\n// Length of double complex\nvec2 dcLength(vec4 a) {\n  return add(mul(a.xy,a.xy),mul(a.zw,a.zw));\n}\n\nvec4 dcSet(vec2 a) {\n  return vec4(a.x,0.,a.y,0.);\n}\n\nvec4 dcSet(vec2 a, vec2 ad) {\n  return vec4(a.x, ad.x,a.y,ad.y);\n}\n\n// Multiply double-complex with double\nvec4 dcMul(vec4 a, vec2 b) {\n  return vec4(mul(a.xy,b),mul(a.wz,b));\n}\n\n\tvec4 dcSub(vec4 a, vec4 b) {\n\t\treturn vec4(sub(a.xy,b.xy),sub(a.zw,b.zw));\n\t}\n\t\n\t\nfloat PI = 3.14159265358979323846264;\n\nfloat scale = 2.0;\n//known deep coord\n//-1.74995768370609350360221450607069970727110579726252077930242837820286008082972804887218672784431700831100544507655659531379747541999999995\n//0.00000000000000000278793706563379402178294753790944364927085054500163081379043930650189386849765202169477470552201325772332454726999999995\n// -1.401,155,189,098,919,8\n\n//Hmm this way of breaking up numbers isn't really right\n//Needs a string to double representation routine\nvec4 offset = vec4(-1.749958,1e-6 - 6.837060935e-7, 2.787937e-18,0.65633794e-24);\n//vec4 offset = vec4(-1.4011551,8.90989198e-8, 0.0,0.0);\n\nconst int max_iterations = 1500;\nconst int max_colors = 50;\nconst float color_scale = 2.0;\nconst float inverse_max_colors = 1.0 / float(max_colors);\n\nconst int P = 2;\nconst float threshold = 200000.0;\n\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n\nvec4 color_ramp(int i) {\n    // Running the index through cos creates a continous ramp.\n    float normalized_mod = mod(float(i), float(max_colors)) * inverse_max_colors;\n\tfloat normalized_cos = (cos(normalized_mod * 2.0 * PI) + 1.0) * 0.5;\n    i = int(float(max_colors) * normalized_cos);\n\n    float factor = float(i) / float(max_colors);\n    float inverse_factor = 1.0 - factor;\n    // An arbritrary ramp of colors\n    return vec4(sqrt(sqrt(factor)), factor, inverse_factor * 0.5, 1.0);\n}\n\nvec4 color_from_ramp(int i, float f) {\n\tvec4 first = color_ramp(i);\n\tvec4 second = color_ramp(i + 1);\n    return first * (1.0 - f) + second * f;\n}\n\nvec4 color_from_iteration(vec4 z, int i) {\n    // Continuous coloring\n    vec2 len=dcLength(z);\n    float s = float(i) + log2(log(threshold)) - log2(log(len.x+len.y));\n    s *= color_scale;\n    int first = int(floor(s));\n    return color_from_ramp(first, s - float(first));\n}\n\nvec4 single_color_from_iteration(vec2 z, int i) {\n    // Continuous coloring\n    float s = float(i) + log2(log(threshold)) - log2(log(length(z)));\n    s *= color_scale;\n    int first = int(floor(s));\n    return color_from_ramp(first, s - float(first));\n}\n\nvec3 single_fractal(vec2 fragCoord)\n{\n\tvec2 c = vec2(\n        (fragCoord.x / iResolution.x) * 3.5 - 2.5,\n        (fragCoord.y / iResolution.y) * 2.0 - 1.0\n    );\n\n    c *= (scale / exp(iTime * 0.2));\n    c += vec2(offset.x,offset.z);\n\n    vec2 z = vec2(0.0, 0.0);\n    int final_i;\n    for (int i = 0; i < max_iterations; i++) {\n        final_i = i;\n\n        if (length(z) >= threshold) {\n            break;\n        }\n\n        // z^P + c, P = 2  gives us  z^2 + c\n        z = cx_mul(z, z) + c;\n    }\n\n\treturn single_color_from_iteration(z, final_i).rgb;\n}\nvec3 double_fractal( vec2 fragCoord)\n{\n    vec2 Threshold = set(threshold);\n    float scaletemp= (scale / exp(iTime * 0.2));\n\tvec4 c = vec4(\n        set((fragCoord.x / iResolution.x) * 3.5*scaletemp),\n        set((fragCoord.y / iResolution.y) * 2.0*scaletemp)\n    );\n\n    c = dcSub(dcAdd(c,offset),vec4(set(2.5*scaletemp),set(scaletemp)));\n\n\n    vec4 z = vec4(0.0, 0.0, 0.0, 0.0);\n    int final_i;\n    for (int i = 0; i < max_iterations; i++) {\n        final_i = i;\n\n        if (cmp(dcLength(z), Threshold)>0.) { break; } \n\n        // z^P + c, P = 2  gives us  z^2 + c\n        z = dcAdd(dcMul(z, z), c);\n    }\n\n\treturn color_from_iteration(z, final_i).rgb;\n}\nvec3 fractal( vec2 fragCoord)\n{\n    if (fragCoord.y<iResolution.y*.5) return single_fractal(fragCoord);\n    return double_fractal(fragCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfragColor.rgb  = fractal( fragCoord + vec2(0,0) );\n\tfragColor.rgb += fractal( fragCoord + vec2(.5,.0) );\n\tfragColor.rgb += fractal( fragCoord + vec2(.0,.5) );\n\tfragColor.rgb += fractal( fragCoord + vec2(.5,.5) );\n\tfragColor.rgb /= 4.0;}\n","name":"Image","description":"","type":"image"}]}