{"ver":"0.1","info":{"id":"MlVfWG","date":"1543946595","viewed":374,"name":"Cookie 2018 NuSan - Round 03","username":"NuSan","description":"Shader made live in 25 minutes during Cookie Demo Party 2018, round 03, finals","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","cookie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cookie 2018 NuSan - Round 03\n// Shader made live by NuSan in 25 minutes\n// during Cookie Demo Party 2018, round 03, finals\n// Slightly tweeked as the texture is not the same\n\n\n#define time iTime\n\n\nfloat sph(vec3 p, float r){\n  return length(p)-r;\n}\n\n\nfloat cyl(vec2 p, float r){\n  return length(p)-r;\n}\n\nvec3 rep(vec3 p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a,float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0); \n  return mix(a,b, k) - k * (1.0-k)*h;\n}\n\nfloat rnd(float t){\n  return fract(sin(t*423.23)*4568.232);\n}\n\nfloat curve(float t, float d) {\n  float g = t/d;\n  return mix( rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0, fract(g)), 10.0));\n}\n\nfloat map(vec3 p) {\n\n  vec3 rp = rep(p, 0.1);\n  vec3 rp2 = rep(p, 0.12);\n\n  float f = texture(iChannel0, p.xz * 0.05).x;\n\n  float v = clamp(length(p.xz)*0.5, 0.0, 1.0) * 1.5;\n\n  float m = -p.y + 0.1 + f*2.0 + v;\n\n  float o = -p.y + 2.1;\n\n  float c = cyl(rp.xz, 0.02);\n  float c2 = cyl(rp2.xz, 0.02);\n\n    float m2 = -p.y + 0.1 + f*2.0 + v;\n\n  c = smin(m+.2 - f*2.0, c, -0.2);\n    c = smin(m+.2 - f*2.0+0.1, c2, -0.2);\n\n  return min(c,min(m, o));\n}\n\n\n\nvec3 norm(vec3 p) {\n  float base = map(p);\n  vec2 off = vec2(0.01,0);\n  return normalize( vec3( base-map(p-off.xyy), base-map(p-off.yxy), base-map(p-off.yyx) ));\n}\n\nvec3 cam(vec3 p) {\n  float t = time;\n  p.xz *= rot(t);\n  p.yz *= rot(sin(t + curve(time+5.0,1.2)*0.5) * 0.1);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  uv.x += (curve(time+5.0, 0.7)-0.5) * 0.4;\n  uv.y += (curve(time+5.0, 0.8)-0.5) * 0.3;\n\n  vec3 ro = vec3(0,1,-5);\n  vec3 rd = normalize(vec3(-uv, 0.1 + curve(time, 0.2) * 2.0));\n\n  ro = cam(ro); \n  rd = cam(rd);\n  \n\n  vec3 p = ro;\n  float dd = 0.0;\n  for(int i=0; i<100; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=rd*d*0.5;\n    dd+=d*0.5;\n  }\n\n  vec3 n = norm(p);\n  vec3 l = normalize(vec3(-1));\n  vec3 h = normalize(l-rd);\n\n  float lum = max(0.0, dot(n,l));\n  float amb = -n.y*0.5+0.5;\n\n  vec3 col = vec3(0);\n\n  col += vec3(1,0.9,0.5) * lum * 0.5;\n  col += vec3(0.2,0.2,1.0) * amb * 0.2;\n  col += vec3(0.9,0.9,1.0) * lum * pow(max(0.0, dot(n,h)),30.0);;\n\n  col *= 3.0/dd;\n\n  col += vec3(1,0.5,0.2) * 0.1 * exp(dd*0.2);\n\n  float t2 = time + curve(time+85.0, 0.8) + curve(time+45.0, 1.3);\n\n\n  col.xy *= rot(t2);\n  col.zy *= rot(t2*0.7);\n  col.xz *= rot(t2*1.2);\n\n  col = abs(col);\n\n  col *= min(1.0,pow(1.0-length(uv*0.9),2.0) * 10.0);\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}