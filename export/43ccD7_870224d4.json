{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//precision highp float;\n//precision highp sampler2D;\n\n\n// Constants definition\n#define HORIZON_BASE 0.0\n#define CITY_NEAR_HEIGHT 0.14\n#define CITY_FAR_HEIGHT 0.19\n#define BUILDING_A_WIDTH 0.073\n#define BUILDING_B_WIDTH 0.031\n#define BUILDING_C_WIDTH 0.047\n#define FOG_DENSITY 0.7\n#define FOG_POWER 3.25\n#define SUN_HEIGHT 0.325\n#define SUN_SIZE 0.44\n#define SUN_GLOW 0.30\n#define STRIPES_HEIGHT 0.10\n#define STRIPES_WIDTH 0.22\n#define WIRE_WIDTH 0.05\n#define GRID_CELLS 4.0\n\n\n// Colors setup\nconst vec4 FOG_COLOR = vec4(1.0, 0.0, 1.0, 1.0);\nconst vec4 SKY_COLOR = vec4(0.18, 0.0, .45, 1.0);\nconst vec4 GROUND_COLOR = vec4(0.2, .0, 0.0, 1.0);\nconst vec4 CITY_NEAR_COLOR = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 CITY_FAR_COLOR = vec4(0.2, 0.2, 0.2, 1.0);\nconst vec4 SUN_COLOR = vec4(1.0, 0.45, 1.0, 1.0);\nconst vec4 SUN_OUTER_COLOR = vec4(1.0, 0.75, 0.43, 1.0);\nconst vec4 GRID_COLOR = vec4(1.0, 0.0, 0.75, 1.0);\nconst vec4 HILIGHT_COLOR = vec4(0.92, 0.65, 0.59, 1.0);\n\n\n\n/**\n * Direction of movement. The only reason to make it as a function is \n * to give a way to bind some kind of control, i.e. gravity sensor or joystick\n */\nfloat direction() {\n  return 1.0;\n}\n\n\nfloat getAspect() {\n    vec2 res = vec2(float(iResolution.x), float(iResolution.y));\n    return res.x / res.y;\n}\n\nfloat getXRange() {\n  return getAspect();\n}\n\n\n/**\n * Convert screen coords from pixels to normalized form with vertical range -1.0 .. 1.0\n */\nvec2 mapCoords(vec2 crd) {\n  vec2 res = vec2(float(iResolution.x), float(iResolution.y));\n  vec2 center = crd - (res * .5);\n  vec2 ret = 2.*center / res;\n  ret.x *= getAspect();\n  return ret;\n}\n\n\n/**\n * Cool pseudo random function\n */\nfloat rand(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n/**\n * Remap range to a linear transition 0.0 .. 1.0\n */\nfloat linearstep(float edge0, float edge1, float x) {\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\n\n/**\n * Background color, just plain sky and ground, divided by horizon line\n */\nvec4 background(vec2 uv) {\n  vec4 result = (uv.y > HORIZON_BASE) ? SKY_COLOR : GROUND_COLOR;\n  return result;\n}\n\n\n/**\n * Pseudo random buildings for a parallax plane\n */\n vec4 cityLineBuildings(vec2 uv, float height, float rShift, float xScale, float speed, vec4 color) {\n  float xShift = speed * iTime * direction();\n  float xPos = (uv.x * xScale) + xShift + rShift;\n  vec2 posA = vec2(floor(xPos / BUILDING_A_WIDTH), .0);\n  vec2 posB = vec2(floor(xPos / BUILDING_B_WIDTH), .0);\n  vec2 posC = vec2(floor(xPos / BUILDING_C_WIDTH), .0);\n  float buildingHeightA = rand(posA) * height;\n  float buildingHeightB = rand(posB) * height;\n  float buildingHeightC = rand(posC) * height;\n  float visibleHeight = max(buildingHeightC, max(buildingHeightA, buildingHeightB));\n  float match = (uv.y < HORIZON_BASE) ? .0 :\n                (uv.y >= visibleHeight) ? .0 : 1.0;\n\n  return vec4(color.xyz, match);\n}\n \n\n\nfloat getYScale(vec2 uv) {\n  float dist = (abs(uv.x) / getXRange());\n  //return (dist == 0.0) ? 0.0 : 1.0 / (dist);\n  return smoothstep(-2.0, 0.0, -abs(uv.x * 0.5));\n}\n\n\n/**\n * Composition of near and far city parallax planes\n */\nvec4 cityLine(vec2 uv) {\n  float yScale = getYScale(uv);\n  vec4 nearBack = cityLineBuildings(uv, (CITY_NEAR_HEIGHT - 0.002) * yScale, 0.0, 1.02, 0.1, HILIGHT_COLOR);\n  vec4 near = cityLineBuildings(uv, CITY_NEAR_HEIGHT * yScale, 0.0, 1.0, 0.1, CITY_NEAR_COLOR);\n  vec4 farBack = cityLineBuildings(uv, CITY_FAR_HEIGHT * yScale, 1000.0, 1.01, 0.05, HILIGHT_COLOR);\n  vec4 far = cityLineBuildings(uv, CITY_FAR_HEIGHT * yScale, 1000.0, 1.0, 0.05, CITY_FAR_COLOR);\n\n  return (near.w > 0.0) ? near :\n         (nearBack.w > 0.0) ? nearBack :\n         (far.w > 0.0) ? far : farBack ;\n}\n\n/**\n * Just a gradient to simulate some depth\n */ \nvec4 fog(vec2 uv) {\n    float angle = max(1.0 - abs(uv.y / FOG_DENSITY), 0.0);\n    float density = pow(angle, FOG_POWER);\n    return vec4(FOG_COLOR.xyz, density);\n}\n\n\n/**\n * Cloud stripes across the Sun\n */\nfloat stripes(vec2 uv) {\n    uv.y -= STRIPES_HEIGHT;\n    float clip = step(0.0, uv.y) * step(0.0, (STRIPES_WIDTH - uv.y));\n    float range = linearstep(0.0, STRIPES_WIDTH, uv.y) * clip;\n    float space = pow(range, 0.3) * 16.0;\n    float section = smoothstep(0.0, 1.0, abs(mod(space, 2.0) - 1.0));\n\n    return max(0.68, pow(section, 0.3));\n}\n\n/**\n * Shape of the Sun with outer glow\n */\nvec4 sunShape(vec2 uv){\n  float clip = step(0.0, uv.y); \n  vec2 center = vec2(0.0, SUN_HEIGHT);\n  float d = distance(uv, center);\n  float strp = stripes(uv);\n  float hit = step(d, SUN_SIZE) * strp;\n  float glowShape = 1.0 - hit;\n\n  float glow = 1.0 - clamp(0.0, 1.0, pow((d - SUN_SIZE), SUN_GLOW));\n  float combined = (hit + clamp(0.0, 1.0, glow));\n  float value = (strp == 1.0) ?  combined : min(combined, strp);\n  float clipped = value * clip;\n  vec4 color = mix(SUN_COLOR, SUN_OUTER_COLOR, smoothstep(0.0, SUN_SIZE, pow(d, 1.2)));\n  \n  \n  return vec4(color.xyz, clamp(0.0, 1.0, clipped));\n}\n\n\n/**\n * Index of grid cell, calculated from raw screen coords\n */ \nvec2 getCellIdx(vec2 fragCoord, float xShift) {\n    vec2 uv = mapCoords(fragCoord);\n    float space = linearstep(-1.0, 0.0, uv.y) * .9;\n\n\n    float xScale = (space == 1.0) ? 0.0 : 1.0 / (1.0 - space);\n    \n    float yScale = xScale * getYScale(uv);\n    \n    vec2 pos = vec2(uv.x * xScale, space * yScale);\n\n    pos.x += xShift;\n  \n    vec2 cellIdx = vec2((pos.x * GRID_CELLS), (pos.y * GRID_CELLS));\n    return cellIdx;\n}\n\n\n/**\n * Grid with cell edge detection\n */\nvec4 grid(vec2 fragCoord) {\n    float xShift = 0.8 * iTime * direction();\n    vec2 uv = mapCoords(fragCoord);  \n    \n    float clip = 1.0 - step(0.0, uv.y);\n\n\n\n\n    vec2 cellIdx = getCellIdx(fragCoord, xShift);\n    vec2 cellNear = getCellIdx(vec2(fragCoord.x, fragCoord.y - 1.0), xShift);\n\n    float edge = (floor(cellNear.y) != floor(cellIdx.y)) ? 1.0 : 0.0;\n    \n    vec2 cellPos = vec2 (mod(cellIdx.x, 2.0), mod(cellIdx.y, 2.0));\n\n\n    float wireX = 1.0 - smoothstep(0.0, WIRE_WIDTH, abs(cellPos.x - 0.5));\n    float wireY = 1.0 - smoothstep(0.0, WIRE_WIDTH, abs(cellPos.y));\n    return vec4(GRID_COLOR.xyz, max(edge, max(wireX, wireY)) * clip);\n}\n\n\n/**\n * Blend all layers together\n */\nvec4 compose(vec2 fragCoord) {\n  vec2 uv = mapCoords(fragCoord);\n  vec4 bg = background(uv);  \n  vec4 sun = sunShape(uv);  \n  vec4 skyLayer = mix(bg, sun, sun.w);\n  vec4 city = cityLine(uv);\n  vec4 fogC = fog(uv);\n  vec4 baseLayer = vec4(mix(skyLayer.xyz, city.xyz, city.w), 1.0);  \n  vec4 gridLayer = grid(fragCoord);\n  baseLayer = vec4(mix(baseLayer.xyz, gridLayer.xyz, gridLayer.w), 1.0);\n  vec4 result = vec4(mix(baseLayer.xyz, fogC.xyz, fogC.w), 1.0);\n  return result;\n}\n\n\n/**\n * Draw function\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 result = compose(fragCoord.xy);  \n\n    // Output to screen\n    fragColor = result;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"43ccD7","date":"1735143176","viewed":98,"name":"One more Outrun Sunset","username":"drLongman","description":"Recreation of good old Outrun Sunset picture. This is a truly example of oldschool coding way - pure 2D rendering, with very simple calculations.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["oldschool","nostalgia"],"hasliked":0,"parentid":"","parentname":""}}