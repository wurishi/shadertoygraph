{"ver":"0.1","info":{"id":"NlyfRV","date":"1665178401","viewed":260,"name":"Rainbow caustics w/ droplets","username":"skal","description":"Trying to be physically accurate.\nYou get to see the 1rst and 2nd rainbow angles, quite faint.\n\nSome real photos of the effect: http://labman.phys.utk.edu/phys222core/modules/m7/dispersion.html\n\nmouse: change light position\n'1' key: switch to point-light.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["water","caustics","rainbow","drop"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rainbow caustics visualisation.\n//\n// Each NUM_RAYS traced is a superposition of NUM_L wavelengths.\n// Paths are computed in BufferA and rendered in Image.\n//\n//\n// Interesting photos and explanations:\n//     https://atoptics.co.uk/fz1063.htm\n//     https://atoptics.co.uk/bows.htm\n//\n// Inspired by https://www.shadertoy.com/view/WsS3Rz\n//             https://www.shadertoy.com/view/Wsj3zh\n//             etc.\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n\n// Colors\nconst vec3 back_col   = vec3(.15, .15, .01);   // background color\nconst vec3 sphere_col = vec3(.2, .3, .8);      // droplet color\nconst vec3 ray_col0   = vec3(.70, .60, .20);   // default ray color\n\nvec3 sceneColor(vec2 uv, float dt) {\n  float l = length(uv - SCenter);\n  float sphere_mix = pow5(smoothstep(0., SRadius, l));\n  float circle_mix = smoothstep(1. * dt, 2. * dt, abs(l - SRadius));\n  vec3 col = mix(sphere_col, back_col, sphere_mix * circle_mix);\n  return col;\n}\n\nfloat segmentSDF(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 ba = b - a;\n  vec2 pa = p - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return smoothstep(0.017, -.52, length(pa - h * ba));\n}\n\nfloat circleSDF(in vec2 p, in vec2 c, float r1, float r2) {\n  return smoothstep(r1, r2, length(p - c));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// various spectrum functions\n// see also: https://www.shadertoy.com/view/ls2Bz1\n\nfloat r_mid_w = 1. / mid_w;\nfloat spectral_distrib(float w) {\n  float t = sig_w * (w * r_mid_w - 1.0);\n  return exp(-t * t);\n}\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n#define SWITCH(t, v1, v2) ((w - (t)) * ((w < (t)) ? v1 : v2))\nfloat xFit_1931(float w) {\n  float t1 = SWITCH(442.0, 0.0624, 0.0374);\n  float t2 = SWITCH(599.8, 0.0264, 0.0323);\n  float t3 = SWITCH(501.1, 0.0490, 0.0382);\n  return 0.362 * exp(-0.5 * t1 * t1) \n       + 1.056 * exp(-0.5 * t2 * t2)\n       - 0.065 * exp(-0.5 * t3 * t3);\n}\nfloat yFit_1931(float w) {\n  float t1 = SWITCH(568.8, 0.0213, 0.0247);\n  float t2 = SWITCH(530.9, 0.0613, 0.0322);\n  return 0.821 * exp(-0.5 * t1 * t1) \n       + 0.286 * exp(-0.5 * t2 * t2);\n}\nfloat zFit_1931(float w) {\n  float t1 = SWITCH(437.0, 0.0845, 0.0278);\n  float t2 = SWITCH(459.0, 0.0385, 0.0725);\n  return 1.217 * exp(-0.5 * t1 * t1) \n       + 0.681 * exp(-0.5 * t2 * t2);\n}\n\nvec4 spectrum(float w /* wavelength in nm - ~[360nm -> 800nm]*/) {\n  vec3 xyz = vec3(xFit_1931(w), yFit_1931(w), zFit_1931(w));\n  vec3 rgb = xyz * mat3( 3.240479, -1.537150, -0.498535,\n                        -0.969256 , 1.875991,  0.041556,\n                         0.055648, -0.204043,  1.057311);\n  return vec4(rgb, spectral_distrib(w));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec3 rainbow(float x) {  // cf. https://www.shadertoy.com/view/lsfBWs\n  float r = step(x, 2.) + 0.5 * step(5., x);\n  float g = max(1.0 - abs(x - 2.0) * 0.5, 0.0);\n  float b = (3.0 - 0.5 * x) * step(4., x);\n  return vec3(r, g, b);\n}\n\nvec4 simpleSpectrum(float w) {\n  float x = clamp(-2.8 + 9.5 * (max_w - w) / (max_w - min_w), 0., 6.);\n  vec3 a = rainbow(floor(x));\n  vec3 b = rainbow(floor(x) + 1.);\n  vec3 c = mix(a, b, fract(x));\n  return vec4(c, spectral_distrib(w));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec4 hueSpectrum(float w) {\n  float x = clamp(-1.2 + 2.5 * (max_w - w) / (max_w - min_w), 0., 1.);\n  vec3 c = (0.5 * cos(6.283 * (x + vec3(0., -.33333, .33333))) + 0.5);\n  return vec4(c, spectral_distrib(w));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat bump(float x) { return max(0., 1. - x * x); }\n\nvec4 fastSpectrum(float w) {\n  float x = clamp( (max_w - w) / (max_w - min_w), 0., 1.);\n  return vec4(\n    bump(3. * (x - 0.25)),\n\tbump(3. * (x - 0.50)),\n\tbump(3. * (x - 0.75)),\n    spectral_distrib(w));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec4 getRayColor(int ray_id) {\n  // return vec4(ray_col0, 1.)\n  float w = getWavelength(ray_id);\n  return spectrum(w);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n  float dt = 1. / min(iResolution.x, iResolution.y);\n  vec2 uv = fragCoord * dt;\n\n  r_mid_w = 1. / mix(400., 750., 0.5 + 0.5 * sin(iTime * 0.3));\n\n  int pos_limit = min(1 << DEPTH, int(iResolution.x));\n  int max_ray_id = min(MAX_RAY_ID, int(iResolution.y));\n  int max_pos = 1;\n  vec3 total_col = vec3(0.);\n  for (int ray_id = 0; ray_id < max_ray_id; ++ray_id) {\n    vec4 ray_col = getRayColor(ray_id);\n    int max_j = 1;\n    int pos = 1;\n    uint mask = 1u; \n    while (pos < pos_limit && mask != 0u) {\n      uint new_mask = 0u;\n      for (int j = 0; mask != 0u; ++j, mask >>= 1) {\n        for (; (mask & 1u) == 0u; ++j, mask >>= 1) { /* skip over dead rays */ }\n        vec4 dst = LOAD((pos + j)     , ray_id);\n        vec4 src = LOAD((pos + j) >> 1, ray_id + 0);\n        if (src.w > 0.) {\n          float d = segmentSDF(uv, src.xy, dst.xy);\n          total_col += ray_col.xyz * d * src.z * ray_col.w;\n          new_mask |= 3u << (2 * j);\n        }\n      }\n      pos += max_j;\n      max_j <<= 1;\n      max_pos = max(pos, max_pos);\n      mask = new_mask;\n    }\n  }\n\n  vec3 col = sceneColor(uv, dt);\n  col = mix(LightAmp * total_col, 2.5 * col, .40);\n\n  // DEBUG SECTION //\n  bool debug = (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5);\n  if (debug) {\n    const float iX = 20., iY = 20.;  // grid units\n    ivec2 pos = ivec2(int(fragCoord.x / iX), int((iResolution.y - fragCoord.y) / iY));\n    if (pos.x < max_pos && pos.y < MAX_RAY_ID) {\n      float grid_mix = min(step(1., mod(                fragCoord.x, iX)),\n                           step(1., mod(iResolution.y - fragCoord.y, iY)));\n      vec4 v = LOAD(pos.x, pos.y);\n      col = mix(vec3(.3, .8, .3), v.zzz, grid_mix);\n    }\n    float w = mix(min_w, max_w, fragCoord.x / iResolution.x);\n    vec4 S1 = spectrum(w);\n    vec4 S2 = simpleSpectrum(w);\n    vec4 S3 = hueSpectrum(w);\n    vec4 S4 = fastSpectrum(w);\n    if (fragCoord.y < 10.) {\n      col = S1.xyz;\n    } else if (fragCoord.y < 20.) {\n      col = S2.xyz;\n    } else if (fragCoord.y < 30.) {\n      col = S3.xyz;\n    } else if (fragCoord.y < 40.) {\n      col = S4.xyz;\n    } else if (fragCoord.y < 50.) {\n      col = S2.www;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Rainbow caustics visualisation.\n//\n// Each NUM_RAYS traced is a superposition of NUM_L wavelengths.\n// Paths are computed in BufferA and rendered in Image.\n//\n//\n// Interesting photos and explanations:\n//     https://atoptics.co.uk/fz1063.htm\n//     https://atoptics.co.uk/bows.htm\n//\n// Inspired by https://www.shadertoy.com/view/WsS3Rz\n//             https://www.shadertoy.com/view/Wsj3zh\n//             etc.\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nbool intersectSphere(inout Ray R, out vec2 N, vec2 center, float r2) {\n  vec2 n = center - R.O;\n  float b = dot(n, R.D);\n  float c = dot(n, n) - r2;\n  bool inSphere = (c <= eps);\n  if (!inSphere && b < 0.) return false;\n  float d = b * b - c;\n  if (d < 0.) return false;\n  d = sqrt(d);\n  float t0 = b - d;\n  float t1 = b + d;\n  float dist = inSphere ? t1 : t0;\n  if (dist < 1. * eps) return false;\n  R.O += dist * R.D;\n  R.inside = inSphere;\n  N = normalize(R.O - center) * (inSphere ? -1. : 1.);\n  return true;\n}\n\nbool traceScene(inout Ray R, out vec2 N) {\n  bool hit = intersectSphere(R, N, SCenter, SRadius * SRadius);\n  // hit = hit || intersectSphere(R, N, vec2(.3, .25), 0.081);  // 2nd sphere?\n  if (!hit) R = Ray(R.O + 5. * R.D, R.D, false);\n  return hit;\n}\n\nRay sourceRay(vec2 M, int ray_id, bool point_light) {\n  ray_id = ray_id % NUM_RAYS;\n  float frac = (float(ray_id) + 0.5) / float(NUM_RAYS);\n  \n  if (point_light) {\n    float t = mix(-.1, .1, frac);\n    return Ray(M, vec2(cos(t), sin(t)), false);\n  } else {\n    // vec2 u = normalize(SCenter - M);\n    vec2 u = normalize(vec2(1., 0.));\n    vec2 v = vec2(-u.y, u.x);\n    float amp = 0.5;\n    float t = mix(-1., 1., frac) * amp;\n    vec2 p = vec2(0., M.y) + v * t * amp;\n    return Ray(p, u, false);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// good summary:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\nvec3 refraction(in vec2 D, in vec2 n, in float r) {\n  float C = -dot(D, n);\n  float S = sqrt(max(0., 1. - r * r * (1. - C * C)));\n  vec2 nD = r * D + (r * C - S) * n;\n#if defined USE_SCHLICK_APPROX\n  // https://en.wikipedia.org/wiki/Schlick%27s_approximation\n  float f = mix(1., pow5(1. - C), sqr((r - 1.) / (r + 1.)));\n#else\n  // https://en.wikipedia.org/wiki/Fresnel_equations#Power_(intensity)_reflection_and_transmission_coefficients\n  vec2 P = vec2((r * C - S) / (r * C + S),    // s-polarization\n                (r * S - C) / (r * S + C));   // p-polarization\n  float f = 0.5 * dot(P, P);\n#endif\n  return vec3(nD.xy, /* reflection coeff = */ f);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nbool store(in vec4 v, in ivec2 pos, in ivec2 coord, out vec4 fragColor) {\n  bool stored = all(equal(pos, coord));\n  if (stored) fragColor = v;\n  return stored;\n}\n\n#define STORE(v, pos)                                              \\\n  if (store(v, ivec2(pos, ray_id), fragCoord, fragColor)) return;  \\\n  stack[pos] = v\n\nvoid storeRays(Ray R, int ray_id, in ivec2 fragCoord, out vec4 fragColor) {\n  float Rf = mix(Rf0, Rf1, getWave(ray_id));\n  float iRf = 1. / Rf;\n\n  vec4 stack[MAX_STACK];   // vec3 = [orig, I, keep_on_flag]\n  vec4 orig = vec4(R.O, 1., 1.);  // starting point\n  STORE(orig, /*pos =*/ 0);\n  stack[1] = vec4(R.D, 1., 0.);  // initial direction\n\n  int pos_limit = min(1 << DEPTH, int(iResolution.x));\n  int max_j = 1;\n  uint mask = 1u; \n  for (int pos = 1; pos < pos_limit && mask != 0u; pos += max_j, max_j <<= 1) {\n    uint new_mask = 0u;\n    for (int j = 0; mask != 0u; ++j, mask >>= 1) {\n      for (; (mask & 1u) == 0u; ++j, mask >>= 1) { /* skip over dead rays */ }\n      vec4 src = stack[(pos + j) >> 1];\n      vec4 dst = stack[(pos + j)     ];\n      Ray r = Ray(src.xy, dst.xy, false);\n      float I = dst.z;\n      vec2 n;\n      bool hit = traceScene(r, n);\n      if (hit) {\n        float eta = r.inside ? Rf :  iRf;\n        vec2 n_R = reflect(r.D, n);\n        vec3 n_D = refraction(r.D, n, eta);\n        float refr_I = I * (1. - n_D.z);\n        float refl_I = I * n_D.z;\n        stack[pos + max_j + 2 * j + 0] = vec4(n_R.xy, refl_I, 1.);\n        stack[pos + max_j + 2 * j + 1] = vec4(n_D.xy, refr_I, 1.);\n        new_mask |= 3u << (2 * j);\n      }\n      dst = vec4(r.O, I, hit ? 1. : 0. /* END */);\n      STORE(dst, pos + j);\n    }\n    mask = new_mask;\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  ivec2 iCoord = ivec2(fragCoord);\n  bool point_light = (texelFetch(iChannel1, ivec2(49, 0), 0).x > 0.5);\n  vec2 M = iMouse.xy / iResolution.yy;  // [0, ar] x [0, 1]\n  if (length(iMouse.xy) < 4.) {\n    float t = iTime * 0.3;\n    M = vec2(0.2 * cos(t) + .3, 0.4 * sin(t) + .5);\n    point_light = (mod(t, 12.56) > 6.28);\n  }\n\n  if (any(greaterThanEqual(fragCoord, kCoordMax))) return;\n\n  int ray_id = iCoord.y;\n#if defined STOCHASTIC\n  if ((ray_id / NUM_L) != (iFrame % NUM_RAYS)) {\n    fragColor = load(iChannel0, iCoord);\n    return;\n  }\n#endif\n\n  Ray R = sourceRay(M, ray_id, point_light);\n  storeRays(R, ray_id, iCoord, fragColor);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Rainbow caustics visualisation.\n//\n// Each NUM_RAYS traced is a superposition of NUM_L wavelengths.\n// Paths are computed in BufferA and rendered in Image.\n//\n//\n// Interesting photos and explanations:\n//     https://atoptics.co.uk/fz1063.htm\n//     https://atoptics.co.uk/bows.htm\n//\n// Inspired by https://www.shadertoy.com/view/WsS3Rz\n//             https://www.shadertoy.com/view/Wsj3zh\n//             etc.\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define NUM_L 8            // number of spectral samples per ray\n#define NUM_RAYS 20        // number of rays to cast\n#define DEPTH 7            // max recursion depth\n#define MAX_STACK (1 + (1 << DEPTH))\n#define MAX_RAY_ID (NUM_L * NUM_RAYS)\n// #define USE_SCHLICK_APPROX\n// #define STOCHASTIC\n\n// source light specs\n#define min_w 400.\n#define max_w 700.         // spectral bounds\n#define mid_w 480.         // spectral distribution peak\n#define sig_w 2.5          // ~spread of the distribution\n#define LightAmp 95.       // must be adapted with NUM_L\n\nfloat getWave(int id) { return (float(id / NUM_RAYS) + .5) / float(NUM_L); }\nfloat getWavelength(int id) { return mix(min_w, max_w, getWave(id)); }\n\n// https://en.wikipedia.org/wiki/Optical_properties_of_water_and_ice\n// Use Cauchy's equation instead?\nconst float Rf0 = 1.339;   //  η(water) / η(air) at min_w\nconst float Rf1 = 1.310;   // ... at max_w (the effect is exaggerated! Should be: 1.331)\n\n// some geometry\nconst vec2 SCenter = vec2(1.0, .5);\nconst float SRadius = 0.25;\nconst float eps = 1e-3;\n\n// 'global' variables\nvec4 load(in sampler2D channel, in ivec2 pos) { return texelFetch(channel, pos, 0); }\n#define LOAD(x, y) load(iChannel0, ivec2(x, y))\n\nconst vec2 kCoordMax = vec2(float(MAX_STACK), float(MAX_RAY_ID));\n\nstruct Ray {\n  vec2 O, D;  // origin, dir\n  bool inside;\n};\n\nfloat sqr(const float x) { return x * x; }\n\nfloat pow5(const float x) {\n  float x2 = sqr(x);\n  return x2 * x2 * x;\n}\n","name":"Common","description":"","type":"common"}]}