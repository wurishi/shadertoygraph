{"ver":"0.1","info":{"id":"wdtXW8","date":"1571922099","viewed":279,"name":"Flying Neon Balls Test","username":"Delvar","description":"Just a test of neon lights with basic black fog. \nUses the ray march process to accumulate the neon glow.\nAlso uses a dither function to modify the distance travelled to reduce banding.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test","balls","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================================================\n//  'Flying Neon Balls Test'\n//  https://www.shadertoy.com/view/wdtXW8\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tCredits: \n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://iquilezles.org/articles/distfunctions\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 20.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.001\n\n#define PI\t3.1415926535897932384626433832795\n\n#define DEBUG_RAY_DITHER\n#define DEBUG_CAMERA_FLY\n#define DEBUG_WHITE_NEON\n#define DEBUG_FLICKER\n//#define DEBUG_MORE_SHAPES\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel0\n//#define NOISE_TEXTURE_2D iChannel1\n\n// -- The Materials\n#define MAT_SKY 0\n//#define MAT_GROUND 1\n#define MAT_NEON 2\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n\tvec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance, fog;\n    vec3 neon;\n    int materialId;\n    int iteration;\n};\n\nstruct sphere {\n    vec3 origin;\n    float radius;\n};\n// ========== ==========\n    \n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HD 43758.5453123\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st*HE)*HD); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec3(HE,HF,HG)))*HD);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HH,HG))*HD);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HH))*HD);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin((st+vec3(HD,HH,HE))*vec3(HH,HE,HG))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\n//Quintic interpolation curve\nvec2 quinticInterpolation(vec2 x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\nfloat quinticInterpolation(float x) {\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    float bl = hash21(pointI + vec2(0.0,0.0) );\n    float br = hash21(pointI + vec2(1.0,0.0) );\n    float fl = hash21(pointI + vec2(0.0,1.0) );\n    float fr = hash21(pointI + vec2(1.0,1.0) );\n    //vec2 u = smoothstep(0.0,1.0,pointF);\n    vec2 u = quinticInterpolation(pointF);\n    float b = mix(bl,br,u.x);\n    float f = mix(fl,fr,u.x);\n\n    return mix(b,f,u.y);\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float b = hash11(pointI);\n    float f = hash11(pointI + 1.0 );\n    float u = quinticInterpolation(pointF);\n    return mix(b,f,pointF);\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    float pointF = fract(samplePoint);\n    float a = hash11(mod(pointI, wrap));\n    float b = hash11(mod(pointI + 1.0 ,wrap));\n    float u = quinticInterpolation(pointF);\n    return mix(a,b,u);\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n\n// All primitives are centered at the origin.\n\n//Sphere - exact\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n//Box - exact\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 position, float minSurfaceDistance, float time) {\n    rayMarchHit hit;\n    hit.distance = RAY_MAX_DISTANCE;\n    \n    float s1 = 5.0;\n    \n    vec3 id = hash33( floor((position+0.5*s1)/s1) );\n    vec3 positionRepeat = mod(position+0.5*s1,s1)-0.5*s1;\n\t\n    float s2 = (s1/10.0);\n    \n    float newDistance;\n    \n    #if defined(DEBUG_MORE_SHAPES)\n\tif (hash31(id) < 0.25) {\n    \tnewDistance= sdSphere(positionRepeat,s2);\n    } else if (hash31(id) < 0.5) {\n    \tnewDistance = sdBox(positionRepeat, vec3(s2));\n    } else if (hash31(id) < 0.75) {\n    \tnewDistance = sdTorus( positionRepeat, vec2(s2,s2*0.2) );\n    } else {\n        newDistance = sdCapsule( positionRepeat, vec3(0.0,-s2*0.5,0.0), vec3(0.0,s2*0.5,0.0) ,s2*0.25 );\n    }\n    #else\n    \tnewDistance= sdSphere(positionRepeat,s2);\n    #endif\n    \n    if (newDistance < hit.distance) {\n        hit.origin = position;\n    \thit.distance = newDistance;\n        hit.materialId = MAT_NEON;\n        #if defined(DEBUG_FLICKER)\n        \thit.neon = normalize(id+ vec3(0.001)) * ( 1.0-valueNoise1duw((time+hash31(id)*10.0)*100.0,200.0)*0.5); //add here to remove artifacts with 0 length Ids\n        #else\n        \thit.neon = normalize(id+ vec3(0.001));\n        #endif\n\t}\n\n    return hit;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    rayMarchHit hit;\n    float lastDistance = 0.0;\n    float accumilatedDistance = 0.0;\n\tvec3 accumilatedNeon = vec3(0.0);\n    \n    for(int i=0; i<maxSteps; i++) {\n\n        vec3 currentPoint = ray.origin + ray.direction*accumilatedDistance;\n        hit = GetRayMarchHit(currentPoint, minSurfaceDistance, time);\n        if (hit.distance > minSurfaceDistance) {\n            accumilatedNeon += (1.0-accumilatedDistance/maxDistance) * (hit.neon) * max(1.0-hit.distance/2.0,0.0) * 0.02;\n        } else {\n            #if defined (DEBUG_WHITE_NEON)\n            \taccumilatedNeon += vec3((1.0-accumilatedDistance/maxDistance));\n            #else\n            \taccumilatedNeon = abs(accumilatedNeon-vec3(0.005));\n            #endif\n        }\n\n\t\thit.iteration = i;\n\t\tlastDistance = hit.distance;\n        \n        #if defined (DEBUG_RAY_DITHER)\n        \taccumilatedDistance += mix(hit.distance*0.5,hit.distance*0.9, hash31(fract(currentPoint)));\n        #else \n        \taccumilatedDistance += hit.distance;\n        #endif\n        \n        if(accumilatedDistance >= maxDistance) {\n            hit.surfaceNormal = ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        }\n        //terminate if we are very close or bounce back out if we end up within an object. \n        else if(hit.distance >= 0.0 && hit.distance < minSurfaceDistance) {\n            break;\n        }\n    }\n    hit.distance = accumilatedDistance;\n    hit.neon = accumilatedNeon;\n    return hit;\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    vec3 r;\n    r.y = (sin(time/2.0)*0.5+0.5) + (sin(time/6.0)+1.0) + (sin(time/15.0)+1.0) + 3.0;\n    r.x = ( sin(time/15.0) * 20.0 ) + sin(time/6.0) * 5.0 + sin(time/2.0) * 3.0;\n\tr.z = ( cos(time/10.0) * 30.0 ) + sin(time/5.0) * 9.0 + sin(time/3.0) * 2.0;\n    return r;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n\t\tvec3 cameraPos2 = getCameraPath(time+1.5);\n        vec3 cameraPos3 = getCameraPath(time-1.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n        \n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0)*5.0;\n        roll = clamp(roll,-0.5,0.5);\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #else\n    return getCamera(vec3(1.0,1.0,0.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);    \n    #endif\n}\n\n// ========== ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n    //vec3 debugOverlay = vec3(0.0);\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    \n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray ray = getRay(uv, camera);\n    rayMarchHit hit = RayMarch(ray, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n\n    //float yaw3 = atan(ray.direction.x,ray.direction.z)/PI;\n    //debugOverlay = vec3(abs(fract( (yaw3-yaw1)*0.5+0.5)*2.0-1.0));\n\n    vec3 colour;\n\n    // ---- Render\n\t//Distance\n    colour = vec3(hit.distance/RAY_MAX_DISTANCE);\n    colour = vec3(hit.neon);\n    //colour = vec3(camera.yaw);\n\n    // ---- \n    float exposure = 1.0;\n    \n    // Gamma\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n\n    // colour grading\n    //colour = colour*vec3(1.0,0.8,1.0);\n    // compress        \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    fragColour = vec4(colour,1.0);\n    //ragColour = vec4(mix(colour,debugOverlay,0.5),1.0);\n        \n}","name":"Image","description":"","type":"image"}]}