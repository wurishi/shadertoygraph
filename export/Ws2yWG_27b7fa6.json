{"ver":"0.1","info":{"id":"Ws2yWG","date":"1587260358","viewed":86,"name":"ꙮ","username":"hclarke","description":"ꙮ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROT(v,x,a) v.x = rot(v.x, a)\nvec2 rot(vec2 v, float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    mat2x2 m = mat2x2(c, -s, s, c);\n    return m*v;\n}\n\nfloat megashape(vec3 pos, vec4 b, vec3 q) {\n    vec4 p = vec4(pos,0.);\n    ROT(p, zw, q.z*0.523598776);\n    ROT(p, yw, q.y*0.615479709);\n    ROT(p, xw, q.x*0.78539816339);\n    \n    vec4 d = abs(p) - b;\n    float pd =  max(max(d.x, d.y), max(d.z, d.w));\n    float rd = length(max(vec4(0.), d));\n    return min(0.,pd) +rd;\n}\n\nvec3 iso4d(vec4 p) {\n    return p.xyz;\n}\n\nfloat saw(float x, float w) {\n    x += 0.25;\n    x = fract(x-0.5) * 2. - 1.;\n    x *= 2.;\n    x = abs(x);\n    x -= 1.;\n    x *= 1. / w;\n    x = clamp(x,-1.,1.);\n    x = x * 0.5 + 0.5;\n    return x;\n}\n\nHit scene(vec3 pos) {\n    Hit h = default_hit();\n    h.albedo = vec3(.5);\n    h.smoothness = 0.99;\n    h.metallic = 1.;\n    h.specular = 0.8;\n    h.sd = 0.;\n    \n    float t= iTime * 0.1;\n    vec3 r = vec3(saw(t, 0.0625), saw(t*2., 0.125), saw(t*4., 0.25));\n    vec4 b = vec4(.5);\n    float u = iTime*.3;\n    h.sd = megashape(pos, b, r);\n    float neg = megashape(pos, b + vec4(0,0,0.5,0), r);\n    h.sd = max(h.sd, -neg) - 0.05;\n    \n    float sp = length(pos)-0.3;\n    if(sp < h.sd ) {\n     \th.sd = sp;\n        h.smoothness = 0.;\n        h.metallic = 0.;\n    }\n\treturn h;\n}\n    \nTrace trace(vec3 pos, vec3 dir, int iter, float angle) {\n    Trace t;\n    float dist = 0.;\n    pos += dir * dist;\n    float sina = 0.99;\n    float sd_min = 1024.;\n    for(int i = 0; i < iter; i += 1) {\n    \tfloat sd = SCENE_SD(pos);\n        dist += sd;\n        pos += dir*sd;\n        if(sd < sd_min) {\n        \tsd_min = sd;\n            t.pos = pos;\n        \tsina = (sd)/dist;\n        }\n        if(sd < -e.x) break;\n    }\n    \n    t.hit = scene(pos);\n    t.vis = saturate(asin(sina)/angle);\n    return t;\n}\n\nvec3 sky(vec3 pos, vec3 dir, float roughness) {\n    // this is real bad :)\n    float lod = saturate(roughness) * 2.;\n    vec3 h = texture( iChannel0, dir).xyz;\n    vec3 l = texture( iChannel1, dir).xyz;\n    if(lod < 1.) return mix(h,l,lod);\n    else return mix(l, vec3(1,1,1) * 0.5, lod-1.);\n}\n\nstruct Lighting {\n\tvec3 N;\n    vec3 L;\n    vec3 V;\n    vec3 H;\n    vec3 R;\n    Trace t;\n    vec3 sky;\n    vec3 skyR;\n    vec3 light;\n};\n    \nLighting simple_lighting(Trace t, vec3 dir, float lod) {\n    Lighting l;\n    l.N = SCENE_NORMAL(t.pos);\n    l.L = normalize(vec3(1,1,-1));\n    l.V = -dir;\n    l.H = normalize(l.V+l.L);\n    l.R = reflect(dir,l.N);\n    \n    l.t = t;\n    l.sky = vec3(0.5);\n    \n   \tl.skyR = vec3(0.5);\n    l.light = vec3(1);\n    return l;\n}\n\nvec3 lighting(Lighting l) {\n    Hit hit = l.t.hit;\n    \n    float ndotl = dot(l.N,l.L);\n    float ndotv = saturate(dot(l.N,l.V));\n    float ndoth = saturate(dot(l.N,l.H));\n    \n \tfloat diffuse = wrap_diffuse(ndotl, hit.wrap) / pi;   \n    diffuse *= (1.-hit.metallic);\n    \n    float f0d = hit.specular * 0.8;\n    \n    vec3 specColor = mix(vec3(f0d,f0d,f0d), hit.albedo, hit.metallic);\n    specColor = specular(saturate(ndotl), ndotv, ndoth, specColor, hit.smoothness);\n    specColor *= ndotl * 3.14195;\n    specColor = max(vec3(0,0,0),specColor);\n    specColor *= l.light;\n    \n    vec3 refl = l.skyR;\n    \n    float proughness = 1.0-hit.smoothness;\n    float roughness = proughness * proughness;\n    vec3 grazingColor = vec3(1,1,1) * saturate(hit.smoothness + mix(f0d, 1.0, hit.metallic));\n    refl *= 1.0 / (roughness*roughness+1.0);\n    refl *= fresnelMix(hit.albedo, grazingColor, ndotv);\n    \n    vec3 col = hit.albedo * diffuse * l.light + specColor + refl;\n    return mix(col, l.sky, saturate(l.t.vis));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera setup\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;\n    float time = iTime * 0.05;\n    vec3 pos = vec3(sin(time) * 3., 1, cos(time) * 3.);\n    vec3 focus = vec3(0,0,0);\n    vec3 fwd = normalize(focus-pos);\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(up,fwd));\n    up = normalize(cross(fwd,right));\n    vec3 dir = normalize(right*uv.x + up*uv.y + fwd);\n    \n    float ca = dot(dir, normalize(dir+dFdx(dir)));\n    float angle = acos(ca);\n    // tracing\n    Trace t = trace(pos, dir, 128, e.x);\n    \n    \n    Hit hit = t.hit;\n    \n    // lighting\n    Lighting l = simple_lighting(t,dir, e.x);\n    \n    l.sky = sky(t.pos + dir * 100., dir, e.x);\n    // reflection\n    if(hit.smoothness > 0.5) \n    {\n        float rough = square(1.-t.hit.smoothness);\n        float a = rough * 1.;\n        Trace tR = trace(t.pos+l.R*0.1, l.R, 64, e.x);\n        Lighting lR = simple_lighting(tR, l.R, 1.-t.hit.smoothness);\n        lR.sky = sky(tR.pos, l.R, 1.-t.hit.smoothness);\n        lR.skyR = sky(tR.pos, lR.R, 1.-t.hit.smoothness);\n        vec3 colR = lighting(lR);\n        l.skyR = mix(lR.sky, colR, smoothstep(.5, .99, t.hit.smoothness));\n    }\n    else {\n    \tl.skyR = sky(t.pos + l.R * 100., l.R, 1.-t.hit.smoothness);  \n    }\n    \n    // shadow\n   \tl.light *= trace(t.pos+l.L*0.01 + l.N * 0.01, l.L, 64, 0.1).vis;\n    \n    vec3 col = lighting(l);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 debug(float x) {\n\treturn vec3(fract(x), sign(x)*0.5+0.5, fract(-x));\n}\n// math\nconst float pi = 3.14195;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x,0.,1.);\n}\n\n// sdf functions\nfloat sd_union(float a, float b) {\n \treturn min(a,b);   \n}\n\nfloat sd_intersect(float a, float b) {\n \treturn max(a,b);   \n}\n\n// SDF stuff\nstruct Hit {\n    float sd;\n    vec3 albedo; // surface colour\n    float wrap;  // wrapped diffuse, good for fake translucency\n    float smoothness;\n    float metallic;\n    float specular;\n};\n    \nHit default_hit() {\n\tHit h;\n    h.sd = 1000.;\n    h.albedo = vec3(0,0,0);\n    h.wrap = 0.;\n    h.smoothness = 0.;\n    h.metallic = 0.;\n    h.specular = 0.5;\n    return h;\n}\n\n#define SCENE_SD(p) (scene(p).sd)\nconst vec2 e = vec2(0.0009765625, 0.0);\n#define SCENE_NORMAL(p) \\\n\t(normalize(vec3( \\\n    \tSCENE_SD(p+e.xyy) - SCENE_SD(p-e.xyy), \\\n    \tSCENE_SD(p+e.yxy) - SCENE_SD(p-e.yxy), \\\n    \tSCENE_SD(p+e.yyx) - SCENE_SD(p-e.yyx)  \\\n    )))\n\nHit mix(Hit a, Hit b, float x) {\n\tHit h;\n    h.sd = mix(a.sd, b.sd, x);\n    return h;\n}\n\nstruct Trace {\n \tHit hit;\n    vec3 pos;\n    float vis;\n};\n\n// lighting\nfloat wrap_diffuse(float ndotl, float wrap) {\n    float div = (1.+wrap)*(1.+wrap);\n \treturn saturate((ndotl+wrap)/div);\n}\nfloat visibility(float ndotl, float ndotv, float roughness) {\n    float rr = roughness * roughness;\n    float ll = ndotl * sqrt((-ndotl*rr+ndotl)*ndotl+rr);\n    float lv = ndotv * sqrt((-ndotv*rr+ndotv)*ndotv+rr);\n    return 0.5 / (ll+lv+1e-6);\n}\n\nfloat ndf(float ndoth, float roughness) {\n \tfloat d = (ndoth  * roughness - ndoth) * ndoth + 1.;\n    return roughness / (d*d+1e-7) / 3.14195;\n}\n\nvec3 fresnel(vec3 f0, float ndoth) {\n \tfloat t = (1.-ndoth);\n    t = t*t*t*t*t;\n    return f0 + (1. - f0)*t;\n}\n\nvec3 fresnelMix(vec3 f0, vec3 f90, float ndotv) {\n \tfloat t = (1.-ndotv);\n    t = t*t*t*t*t;\n    return mix(f0, f90, t);\n}\nvec3 specular(float ndotl, float ndotv, float ndoth, vec3 f0, float smoothness) {\n    float roughness = 1.-smoothness;\n    roughness *= roughness;\n \tfloat D = ndf(ndoth, roughness);\n    float V = visibility(ndotl, ndotv, roughness);\n    vec3 F = fresnel(f0, ndoth);\n    \n    return D*V*F;\n}","name":"Common","description":"","type":"common"}]}