{"ver":"0.1","info":{"id":"WtlcR7","date":"1591709702","viewed":201,"name":"[TWITCH] Wire Mess","username":"Flopine","description":"Shader made during a live stream on Twitch you can watch here: https://www.twitch.tv/flopine/videos\nI did this shader for my friend's videogame called Gentris: https://twitter.com/PiersBishopArt/status/1270294149200318470","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","isometric","orthographic","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// I did this shader for my friend's videogame called Gentris\n// https://twitter.com/PiersBishopArt/status/1270294149200318470\n\n#define ITER 64.\n#define PI acos(-1.)\n#define time(speed) fract(iTime*speed)\n#define anim(speed) easeInOutCirc(time(speed))\n#define lines(s, puv) smoothstep(s,s*lines_blur, abs(puv.y))\n\n// SHADER PARAMETERS\n#define BPM (125./60.)\n\n#define spheres_speed 0.6\n#define spheres_speedvariation .1\n\n#define lines_frequency 5.\n#define lines_thickness 0.1\n#define lines_blur 1.05\n#define lines_speed -(.2)\n\n#define color1 vec3(0.5,0.05,0.1)\n#define color2 vec3(0.1,0.8,0.5)\n#define backgroundcolor vec3(.0,.01,.04)\n#define light_position vec3(1.,1.,-2.)\n\nfloat easeInOutCirc (float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - (2. * x) * (2. * x))) / 2.\n        : (sqrt(1. - (-2. * x + 2.) * (-2. * x + 2.)) + 1.) / 2.;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float id = floor(a/per);\n    if (id >= rep*0.5) id = abs(id);\n    a = mod(a,per)-per*.5;\n    p = vec2(cos(a),sin(a)) * length(p);\n    return id;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat primitive1 (vec3 p, float s_speed)\n{\n    float per = 1.;\n    float thread = cyl(p.xzy, 0.03, 10.);\n\n    float radius = .07;\n    p.y += anim(s_speed);\n    p.y = mod(p.y,per)-per*.5;\n    float spheres = length(p)-radius; \n\n    float d = smin(thread,spheres,0.1);\n    return d;\n}\n\nvec3 new_p;\nfloat scene (vec3 p) \n{\n    p.yz *= rot(atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\n\n    mo(p.xz,vec2(1.));\n    p.x -= 0.5+sin(p.y)*.5;\n    mo(p.xz, vec2(.2));\n    p.xz *= rot(p.y*2.);\n    float pid = moda(p.xz, 4.);\n    p.x -= 0.2;\n\n    new_p = p;\n    float d =  primitive1(p, (pid * spheres_speedvariation - 1.) * spheres_speed);\n\n    return d;\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(scene(p)-vec3(scene(p-eps.xyy),scene(p-eps.yxy),scene(p-eps.yyx)));\n}\n\nfloat texture_threads (vec2 uv)\n{\n    uv.y += anim(lines_speed);\n    uv *= lines_frequency;\n    uv.y = fract(uv.y)-.5;\n    return clamp(1.-lines(lines_thickness, uv),0.,1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv,-80.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(light_position),\n        col = backgroundcolor;\n\n    bool hit = false;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = scene(p);\n        if (d<0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd*.7;\n    }\n\n    float mask = texture_threads(vec2(atan(new_p.z,new_p.x),new_p.y));\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = mix(color1, color2, mask);\n        col *= (dot(n,l)*.5+.5);\n    }\n\n    fragColor = vec4(sqrt(col),1.);\n}","name":"Image","description":"","type":"image"}]}