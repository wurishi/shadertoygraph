{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// If you don't hear the sound, please click on ⏸→⏮→▶.\n// 音が聞こえない場合、 ⏸→⏮→▶ を順にクリックしてください\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//-----------------GPUの処理能力に応じて変更-------------------\n#define AA 2\n//-----------------------------------------------------------\n\n// 乱数\n#define hash(x) fract(sin(x) * 43758.5453123)\n\n#define saturate(x) clamp(x, 0., 1.)\n#define linearstep(a, b, t) saturate( ( (t) - (a) ) / ( (b) - (a) ) )\n\n// 物体の種類\n#define SPHERE 0\n#define PILLAR 1\n\n// 物体の情報\nstruct objInfo {\n    float t;  // 物体表面まで飛ばしたレイの長さ\n    vec3 n;   // 法線ベクトル\n    int type; // 物体の種類\n    vec3 col; // 物体の色\n    vec3 em;  // 物体の発光色\n};\n\nconst int maxDepth = 4; // レイの経路の深さの最大値\nconst int gridItr = 20; // 2Dのgrid traversalのループ回数\nconst float PI = acos(-1.); // 円周率\nconst float PI2 = PI * 2.; // τ\nconst float EPS = 0.001; // パストレーシングなどに使う微小量\nconst float FAR = 1e5;\nconst float LOG10 = log(10.); // デシベル計算用\nconst float maxPillarHeight = 5.; // 柱の高さの最大値\nconst float lightSize = 0.5; // 光源（球体）の半径\nconst float BPM = 128.;\n\nfloat pathSeed = 0.; // パストレーシングで使う乱数のシード \nvec3 lightPos = vec3(0); // 光源（球体）の中心の座標\n\n// 1Dの乱数（シードを更新）\nfloat random() {\n    return hash(pathSeed++);\n}\n\n// 2Dの乱数\nfloat hash12(vec2 p) {\n    return hash(dot(p, vec2(12.9898, 78.233)));\n}\n\n// 3Dの乱数\nfloat hash13(vec3 p) {\n    return hash(dot(p, vec3(127.1, 311.7, 74.7)));\n}\n\n// 2次元の回転行列\nmat2 rotate2D(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// 球面とレイの交差判定関数\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.) {\n        return -1.;\n    }\n    return -b - sqrt(h);\n}\n\n// FFTを取得し、補正する\n// 参考: \"BonzomaticのFFTを丁寧に使う\" by 0b5vr\n// https://scrapbox.io/0b5vr/Bonzomatic%E3%81%AEFFT%E3%82%92%E4%B8%81%E5%AF%A7%E3%81%AB%E4%BD%BF%E3%81%86\nfloat fetchFFT(float x) {\n    //float xt = exp2(mix(-5., -1., x));\n    float xt = exp2(mix(-5., 0., x));\n    float v = texture(iChannel1, vec2(xt, 0)).x;\n    \n    v = 20. * log(v) / LOG10;\n    //v += 24. * x;\n    v += 4. * x;\n    \n    //v = linearstep(-60., 0., v);\n    v = linearstep(-10., 0., v);\n    return v;\n}\n\n// ベクトルvを回転軸axで角度aだけ回転\nvec3 rot3D(vec3 v, float a, vec3 ax) {\n    ax = normalize(ax);\n    return mix(dot(ax, v) * ax, v, cos(a)) - sin(a) * cross(ax, v);\n}\n\n// 画面上の座標からレイの方向を算出\nvec3 rayDir(vec2 uv, vec3 dir, float fov) {\n    dir = normalize(dir);\n    vec3 u = abs(dir.y) < 0.999 ? vec3(0, 1, 0) : vec3(0, 0, 1);\n    vec3 side = normalize(cross(dir, u));\n    vec3 up = cross(side, dir);\n    return normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI));\n}\n\n// 被写界深度\nvoid dof(inout vec3 ro, inout vec3 rd, vec3 dir, float L, float factor) {\n    float r = sqrt(random());\n    float a = random() * PI2;\n    vec3 v = vec3(r * vec2(cos(a), sin(a)) * factor, 0);\n    vec3 diro = vec3(0, 0, -1);\n    float d = dot(dir, diro);\n    float va = acos(d);\n    vec3 vax = abs(d) < 0.999 ? cross(dir, diro) : dir.yzx;\n    v = rot3D(v, va, vax);\n    ro += v;\n    rd = normalize(rd * L - v);\n}\n\n// vを天頂として極座標phi, thetaだけ回転させたベクトル\nvec3 jitter(vec3 v, float phi, float sinTheta, float cosTheta) {\n    vec3 zAxis = normalize(v);\n    vec3 xAxis = normalize(cross(zAxis.yzx, zAxis));\n    vec3 yAxis = cross(zAxis, xAxis);\n    return (xAxis * cos(phi) + yAxis * sin(phi)) * sinTheta + zAxis * cosTheta;\n}\n\n// 柱の高さ\nfloat height(vec2 p) {\n    //return hash12(p) * maxPillarHeight;\n    p += 0.5;\n    float L = length(p);\n    float a = (atan(p.y, p.x) + PI) / PI2;\n    float h = texture(iChannel0, vec2(a, L * 0.003)).a;\n    return h * maxPillarHeight;\n}\n\n// 3次元空間上の点ceを通り、normalを法線ベクトルとする平面とレイの交差判定関数\nfloat plaIntersect(vec3 ro, vec3 rd, vec3 ce, vec3 n) {\n    return -dot(ro - ce, n) / dot(rd, n);\n}\n\n// カメラ（ro）から物体表面までレイを飛ばし、レイの長さや法線ベクトルなどの情報を返す\nobjInfo castRay(vec3 ro, vec3 rd) {\n    objInfo sphere = objInfo(0., vec3(0, 0, 1), SPHERE, vec3(0), vec3(40));\n    objInfo pillarTop = objInfo(0., vec3(0, 1, 0), PILLAR, vec3(0.9), vec3(0));\n    objInfo pillarSide = objInfo(0., vec3(0, 0, 1), PILLAR, vec3(0.9), vec3(0));\n    \n    objInfo res = objInfo(-1., vec3(0, 0, 1), -1, vec3(0), vec3(0)); // 結果\n    \n    //vec2 ri = 1. / rd.xz;\n    vec2 ri = clamp(1. / rd.xz, -FAR, FAR);\n    vec2 rs = sign(rd.xz);\n    bool down = rd.y < 0.;\n    vec2 ID = floor(ro.xz); // 柱のID\n    \n    sphere.t = sphIntersect(ro, rd, lightPos, lightSize);\n    if(sphere.t < 0.) {\n        sphere.t = FAR;\n    }\n    //sphere.n = normalize(ro + sphere.t * rd - lightPos);\n    sphere.n = (ro + sphere.t * rd - lightPos) / lightSize;\n    \n    if(down && ro.y > maxPillarHeight) {\n        // 高さ最大の平面まではレイが柱に衝突しないので、あらかじめレイを進める\n        //float tBound = plaIntersect(ro, rd, vec3(0, maxPillarHeight, 0), vec3(0, 1, 0));\n        float tBound = (maxPillarHeight - ro.y) / rd.y;\n        pillarSide.t = min(tBound, FAR * 0.9);\n        ID = floor(ro.xz + pillarSide.t * rd.xz);\n    }\n    \n    bool quit = false;\n    for(int i = 0; i < gridItr; i++) { // 2Dのgrid traversalを行う\n        vec3 rp = ro + pillarSide.t * rd;\n        if(!down && rp.y > maxPillarHeight) {\n            // レイが高さ最大の平面を通り過ぎたので、柱に衝突することはない\n            quit = true;\n            break;\n        }\n        float h = height(ID);\n        if(rp.y < h) {\n            // レイが柱の側面に衝突\n            res = pillarSide;\n            break;\n        }\n        \n        vec2 frp = rp.xz - ID - 0.5;\n        vec2 v = (0.5 * rs - frp) * ri;\n        float s = step(v.x, v.y);\n        vec2 vCell = vec2(s, 1. - s);\n        float tCell = dot(v, vCell);\n        \n        //pillarTop.t = plaIntersect(ro, rd, vec3(0, h, 0), vec3(0, 1, 0));\n        pillarTop.t = (h - ro.y) / rd.y;     \n        if(!down) {\n            // レイが上昇している時は、柱の上面に衝突しない\n            pillarTop.t = FAR;\n        }\n        \n        //objInfo res = sphere.t < pillarTop.t ? sphere : pillarTop;\n        objInfo obs = pillarTop;\n        if(sphere.t < pillarTop.t) {\n            obs = sphere;\n        }\n        \n        pillarSide.t += tCell;\n        if(obs.t < pillarSide.t) {\n            // レイが柱の上面または光源（球体）に衝突\n            res = obs;\n            break;\n        }\n        \n        // 隣の柱に進む\n        vec2 st = vCell * rs;\n        ID += st;\n        pillarSide.n.xz = -st;\n    }\n    \n    if(quit && sphere.t < FAR) {\n        // レイが高さ最大の平面を通り過ぎ、光源（球体）に衝突\n        res = sphere;\n    }\n    \n    return res;\n}\n\n// パストレーシングをする\n// 参考: \"パストレーシング - Computer Graphics - memoRANDOM\" by Shocker_0x15\n// https://rayspace.xyz/CG/contents/path_tracing/\n// 参考: \"GLSL smallpt\" by Zavie\n// https://www.shadertoy.com/view/4sfGDB\n// コードは改変済み\nvec3 pathTrace(vec3 ro, vec3 rd) {\n    vec3 acc = vec3(0);\n    vec3 mask = vec3(1);\n    \n    for(int i = 0; i < maxDepth; i++) {\n        objInfo info = castRay(ro, rd);\n        if(info.t < 0.) {\n            break;\n        }\n        ro += info.t * rd + info.n * EPS;\n        \n        vec3 e = vec3(0);\n        // Next Event Estimation\n        vec3 l0 = lightPos - ro;\n        float cosA_max = sqrt(1. - lightSize * lightSize / dot(l0, l0));\n        float cosA = mix(cosA_max, 1., random());\n        vec3 l = jitter(l0, random() * PI2, sqrt(1. - cosA * cosA), cosA);\n        objInfo nee = castRay(ro, l);\n        if(nee.type == SPHERE) {\n            float omega = PI2 * (1. - cosA_max);\n            e += (nee.em * max(dot(l, info.n), 0.) * omega) / PI;\n        }\n        \n        acc += mask * (info.em * float(i == 0) + info.col * e);\n        mask *= info.col;\n        \n        float ur = random();\n        rd = jitter(info.n, random() * PI2, sqrt(ur), sqrt(1. - ur));\n    }\n    \n    return acc;\n}\n\n// 範囲[-1, 1.]の間で等間隔にn個の値を取る滑らかな階段状のノイズ\nfloat stepNoise(float x, float n) {\n    const float factor = 0.3;\n    float i = floor(x);\n    float f = x - i;\n    float u = smoothstep(0.5 - factor, 0.5 + factor, f);\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res /= (n - 1.) * 0.5;\n    return res - 1.;\n}\n\n// カメラの位置・ターゲットの座標を動かす\nvoid moveCamera(inout vec3 ro, inout vec3 ta, inout float fov) {\n    float Time = iTime * BPM / 60. * 0.5;\n    ro.y += stepNoise(Time, 2.) * 2.;\n    ro.xz *= rotate2D(iTime * 0.2);\n    ta.x += stepNoise(Time - 500., 3.) * 1.;\n    ta.z += stepNoise(Time - 1000., 3.) * 1.;\n    fov += stepNoise(Time - 1500., 2.) * 20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    lightPos = vec3(0, maxPillarHeight * 1., 0);\n    lightPos += sin(vec3(3, 4, 6) * iTime) * vec3(2, 0.5, 2);\n    \n    vec3 ro = vec3(0, maxPillarHeight + 2., 5); // カメラの位置（レイの原点）\n    vec3 ta = vec3(0, maxPillarHeight * 0.5, 0); // カメラのターゲットの座標\n    float fov = 60.;\n    moveCamera(ro, ta, fov); // dof() と moveCamera() を両方オフにするとなんかバグる…\n    vec3 dir = normalize(ta - ro); // カメラの向き\n    \n    //objInfo info = castRay(ro, dir);\n    //float tp = plaIntersect(ro, dir, vec3(0), vec3(0, 1, 0));\n    float tp = plaIntersect(ro, dir, ta, vec3(0, 1, 0));\n    if(tp < 0.) {\n        tp = FAR;\n    }\n    float L = tp; // 被写界深度の焦点まで伸ばしたレイの長さ\n    //L = info.t > 0. ? info.t : tp;\n    \n    for(int i = 0; i < AA; i++) { // アンチエイリアシング\n        for(int j = 0; j < AA; j++) {\n            vec2 of = vec2(i, j) / float(AA) - 0.5; // オフセット\n            \n            // 画面上の座標を正規化\n            vec2 uv = ((fragCoord.xy + of) * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n            \n            pathSeed += hash13(vec3(uv + of, fract(iTime * 0.1011)));\n            vec3 rd = rayDir(uv, dir, fov); // レイの向き\n            \n            // 被写界深度\n            vec3 ros = ro;\n            vec3 rds = rd;\n            dof(ros, rds, dir, L, 0.15);\n            \n            col += pathTrace(ros, rds); // パストレーシング\n        }\n    }\n    col /= float(AA * AA); // 色の平均をとる\n    col = clamp(col, 0., 1.);\n    \n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    \n    // 口径食（vignetting）\n    vec2 p = gl_FragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.5);\n    \n    // 保存したFFTを表示\n    //col += texture(iChannel0, p).a;\n    \n    float fft = fetchFFT(p.x);\n    if(p.y * 8. < fft) {\n        col += 0.3;\n    }\n    // FFTをalphaに保存\n    float tex = texture(iChannel0, (fragCoord.xy - vec2(0, 1)) / iResolution.xy).a;\n    float alpha = gl_FragCoord.y < 1. ? fft : tex;\n    \n    // パストレーシングで得られた色の分散を低減するために前のフレームの色を合成する\n    //col = mix(col, texture(iChannel0, p).rgb, 0.4);\n    \n    //if(col.r > 1. || col.g > 1. || col.b > 1.) col = vec3(1, 0, 0); // saturationチェック\n\n/*\n    // デバッグ用\n    col = vec3(0);\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 rd = rayDir(uv, dir, fov);\n    objInfo info0 = castRay(ro, rd);\n    if(info0.t > 0.) {\n        col += exp(-info0.t * info0.t * 0.01) * (info0.n * 0.5 + 0.5);\n        //col += exp(-info.t * info.t * 0.6);\n    }\n*/\n\n    fragColor = vec4(col, alpha);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcdfDs","date":"1733666328","viewed":273,"name":"[Inércia] Audio Reactive Pillars","username":"Kamoshika","description":"Shader Royale Jam (with live music by var.rho) @ Inércia 2024\nhttps://2024.inercia.pt/\n\nhttps://www.youtube.com/live/eKKZ9IMCmS0?si=-FnQqWat-uiyu1vw&t=900","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["raycasting","audio","globalillumination","visualizer","pathtracing","pillars"],"hasliked":0,"parentid":"","parentname":""}}