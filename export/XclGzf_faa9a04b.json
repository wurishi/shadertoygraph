{"ver":"0.1","info":{"id":"XclGzf","date":"1703301082","viewed":67,"name":"love from link","username":"linking","description":"Special love for special you\n特别的爱给特别的你","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fireworksromantic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//random value\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec3 burst(vec2 st, vec2 pos, float r, vec3 col)\n{\n    st -= pos;\n    r = 0.3 * r * r;\n\n    /// 发光效果\n    return (r / dot(st, st)) * col * 0.6;\n}\n\n/// s = p0 + ut + 0.5at^2\n/// 距离加速度公式\nvec2 get_pos(vec2 u, vec2 a, vec2 p0, float t, float ang)\n{\n    /// 根据初始位置、水平和垂直的速度、加速度来更新当前的位置\n    vec2 d = p0 + vec2(u.x * cos(ang), u.y * sin(ang)) * t + 0.5 * a * t * t;\n    return d;\n}\n\n// t 时刻的粒子速度\nvec2 get_velocity(vec2 u, vec2 a, float t, float ang)\n{\n    /// 根据加速度、当前水平和垂直的速度来更新当前的速度\n    return vec2(u.x * cos(ang), u.y * sin(ang)) + a * t;\n}\n//根据索引随机一个颜色\nfloat rand2(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n#define rad(x) radians(x)\nfloat np = 100.;\nfloat snp = 20.;\nfloat R = 0.032;\nfloat R_RATIO = 0.04;\nfloat ACC_RATIO = 0.03;\nfloat ANG = 90.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    float t = mod(iTime, 10.);\n\n    vec2 u = vec2(0.);                ///< 初速度\n    const vec2 acc = vec2(0.0, -9.8); ///< 重力加速度 acc\n    float ang = rad(ANG);             ///< 上升粒子的发射角度\n\n    vec3 particles = vec3(0.0); //particle\n\n    for (float i = 0.; i < np; i++)\n    {\n        float r = R;\n        vec2 rand = N22(vec2(i));\n\n        /// 初始位置\n        vec2 ip = vec2(sin(30.*rand.x) * aspect, -1. + r);\n\n        /// 真正初始化速度\n        u = vec2(sin(5.*rand.x), 5. + sin(4.*rand.y));\n\n        float t_i = t - i / 5.; ///< 时间差异化\n        vec2 s = get_pos(u, acc, ip, t_i, ang);\n        vec2 v = get_velocity(u, acc, t_i, ang);\n\n        /// 计算竖直向上的运动时间\n        float t_up = u.y * sin(ang) / abs(acc.y);\n        /// 根据时间计算出向上运动的最大高度\n        vec2 h_max = get_pos(u, acc, ip, t_up, ang);\n        \n        ///随机一个颜色\n        vec3 pcol = vec3(rand2(vec2(i, 0.0)), rand2(vec2(i, 1.0)), rand2(vec2(i, 2.0)));\n\n\n        if (v.y < -0.5) ///< 下落速度超过一定大小则消失\n        {\n            r = 0.0;    ///< 隐藏\n        }\n\n        particles += burst(uv, s, r, pcol); ///< 发射上升的粒子\n\n\n        /// 当粒子停止上升，且粒子的当前时间已经达到了上升的时间\n\n        if (v.y > -6.5 && v.y < 0.0 && t_i >= t_up /*&& SPAWN == 1*/)\n        {\n            /// 把一个圆根据角度分成若干份扇形\n            float unit = (360. / snp);\n            for (float j = 0.0; j < snp; j++)\n            {\n                float ang = rad(j * unit);\n\n                float r = 0.035;             ///< 心形粒子的半径\n                r -= (t_i - t_up) * R_RATIO; ///< 根据时间差来改变粒子的大小（变小）\n\n                float x = cos(ang); //coords of unit circle\n                float y = sin(ang);\n                /// 心形公式\n                y = y + abs(x) * sqrt( (8. - abs(x)) / 50.0 );\n                /// 心形速度向量，随着时间而变小\n                vec2 heart = vec2(x * x + y * y) * (0.4 / (t_i * sqrt(t_i)));\n\n                /// 根据心形的当前速度和加速度、初始位置等更新粒子的位置\n                vec2 S = get_pos(heart, acc * ACC_RATIO, h_max, t_i - (t_up), ang);\n                /// --------------------------------------------------\n\n                ///vec3 pcol = vec3(1.);\n                particles += burst(uv, S, max(0.0, r), pcol);\n            }\n        }\n\n    }\n\n    col = particles;\n\n    fragColor = vec4(col,  1.0);\n}","name":"Image","description":"","type":"image"}]}