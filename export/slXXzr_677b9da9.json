{"ver":"0.1","info":{"id":"slXXzr","date":"1625063278","viewed":198,"name":"Livitchuk Maxim, Practice 2021","username":"sliva0","description":"two tori","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["torus","celshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define MOUSE_CONTROL\n\n//Tech constants\n#define EPSILON 0.0001\n#define PI 3.14159265359\n\n//Render limits\n#define MAX_STEPS 500\n#define MAX_DIST 50.0\n\n#define EDGE_THICKNESS 0.015\n\nstruct Torus {\n  float R, r;\n  vec3 shift;\n  mat3 tr;\n  vec3 col;\n};\n\nTorus torus1 = Torus(\n  1.5, 0.4,\n  vec3(0.0, 0.0, 0.75),\n  mat3(\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n  ),\n  vec3(0.5, 0.3, 0.0)\n);\n\nconst Torus torus2 = Torus(\n  1.5, 0.4,\n  vec3(0.0, 0.0, -0.75),\n  mat3(\n    0.0, -1.0, 0.0,\n    1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0\n  ),\n  vec3(0.5, 0.3, 0.0)\n);\n\n\n\nvec2 torus_surface_coords(Torus tor, vec3 point) {\n  point = tor.tr * (point + tor.shift);\n   vec3 c = point;\n    c.x = 0.0;\n    c = normalize(c);\n    vec3 e = point - (c * tor.R);\n\n     return vec2(\n       atan(c.y, c.z),\n       atan(e.x, dot(e, c))\n     );\n}\n\nbool l_texture(vec2 c, float shift) {\n  c.x = mod(c.x, PI) - PI / 2.0;\n\n  float width = 0.05,\n        height = 1.0,\n        skew = (PI - c.y) / 20.0;\n\n   return (\n     abs(c.y - PI / 2.0) < height &&\n     (\n       abs(c.x - skew + shift) < width ||\n       abs(c.x + skew + shift) < width\n     )\n   );\n}\n\n    //depends on torus_surface_coords, l_texture\n    vec3 torus_color(Torus tor, vec3 point) {\n      vec2 c = torus_surface_coords(tor, point);\n\n      if (l_texture(c, -0.4) || l_texture(c, -0.1) || l_texture(c, 0.4))\n        return vec3(0.6, 0.4, 0.6);\n\n      float f = 1.0 / pow(abs(c.y), 0.5);\n       vec3 gradient = cos(iTime + vec3(f + c.x, f - c.x, f - c.x * 2.0));\n        return normalize(abs(gradient / 3.0) + tor.col);\n    }\n\n\n\nfloat torus_sdf(Torus tor, vec3 point) {\n  point = tor.tr * (point + tor.shift);\n   return length(vec2(length(point.yz) - tor.R, point.x)) - tor.r;\n}\n\n    //depends on torus_sdf, torus_color\n    vec3 define_color(vec3 point) {\n      if (torus_sdf(torus1, point) < torus_sdf(torus2, point))\n        return torus_color(torus1, point);\n      else\n        return torus_color(torus2, point);\n    }\n\n    float scene_sdf(vec3 point) {\n      return min(\n        torus_sdf(torus1, point),\n        torus_sdf(torus2, point)\n      );\n    }\n\n        float ray_walker(vec3 origin, vec3 direction, float stop) {\n          float depth = 0.0;\n          float min_dist = MAX_DIST;\n\n          for (int i = 0; i < MAX_STEPS; i++) {\n            vec3 point = origin + (depth * direction);\n            float dist = scene_sdf(point);\n\n              if (dist < EPSILON) // Hit\n                return depth;\n\n              min_dist = min(dist, min_dist);\n              if (dist > min_dist && min_dist <= EDGE_THICKNESS) // Edge hit\n                return 0.0;\n\n              depth += dist; // Step\n              if (depth >= stop) // Reached max\n                return stop;\n          }\n        }\n\n        float sdf_derivative(vec3 point, vec3 delta) {\n          return scene_sdf(point + delta) - scene_sdf(point - delta);\n        }\n\n            vec3 get_normal(vec3 point) {\n              return normalize(vec3(\n                sdf_derivative(point, vec3(EPSILON, 0.0, 0.0)),\n                sdf_derivative(point, vec3(0.0, EPSILON, 0.0)),\n                sdf_derivative(point, vec3(0.0, 0.0, EPSILON))\n              ));\n            }\n\n                vec3 compute_lighting(vec3 point, vec3 light_dir, vec3 light_color) {\n                  float intensity = dot(get_normal(point), normalize(light_dir));\n                  return light_color * intensity;\n                }\n\n\n\nvec3 ray_direction(float fov, vec2 size, vec2 coords) {\n  vec2 xy = coords - (size / 2.0);\n  float z = size.y / tan(radians(fov) / 2.0);\n   return normalize(vec3(xy, -z));\n}\n\nmat3 look_at(vec3 camera, vec3 target) {\n  vec3 f = normalize(target - camera);\n   vec3 s = cross(f, vec3(0.0, 1.0, 0.0));\n    vec3 u = cross(s, f);\n     return mat3(s, u, -f);\n}\n\nfloat compute_star(vec3 point, float scale) {\n  float p = 12.0;\n  vec3 d = point / scale;\n   return (\n     pow(mod(+d.x + d.y - d.z, 1.0), p) + \n     pow(mod(+d.x - d.y + d.z, 1.0), p) - \n     1.0\n   );\n}\n    \n    //depends on ray_direction, look_at, compute_star, ray_walker, compute_lighting, define_color\n    vec3 render(in vec2 coords) {\n      vec3 view_dir = ray_direction(60.0, iResolution.xy, coords);\n      float t = iTime / 3.0 + 1.0;\n\n      #ifdef MOUSE_CONTROL\n        vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n        vec3 origin = vec3(sin(mouse.x * 10.0), (mouse.y * 10.0), cos(mouse.x * 10.0)) * 10.0;\n      #else\n        vec3 origin = vec3(sin(t), 2.0 * cos(t), cos(t)) * 10.0;\n      #endif\n\n        mat3 view_transform = look_at(origin, vec3(0.0));\n        view_dir = view_transform * view_dir;\n          float dist = ray_walker(origin, view_dir, MAX_DIST);\n\n          if (dist > MAX_DIST - EPSILON) { // No hit\n            float a = compute_star(view_dir, 0.1),\n                  b = compute_star(view_dir, 0.05) * 2.0;\n            return vec3(a, a, b);\n          }\n\n          if (dist < EPSILON) // Edge hit\n            return vec3(1.0, 0.8, 0.0);\n\n          vec3 hit_point = origin + (dist * view_dir);\n            vec3 color = define_color(hit_point);\n            return compute_lighting(hit_point, origin, color);\n    }\n\n        void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n      fragColor = vec4(render(fragCoord), 1.0);\n    }","name":"Image","description":"","type":"image"}]}