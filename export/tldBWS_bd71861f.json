{"ver":"0.1","info":{"id":"tldBWS","date":"1613395501","viewed":112,"name":"[RGR] Ray marching 2D (v2)","username":"deeplo","description":"ray marching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S             smoothstep\n\n#define EPSILON 0.000001\n\n#define BG_COLOR      vec3(0.01,0.01,0.01)\n\n#define MAX_DISTANCE  100000.0\n#define MAX_RM_STEPS  256\n#define MIN_DISTANCE  0.00001\n\n#define SPHERE_CENTER1 vec2(0.0,-0.0)\n#define SPHERE_CENTER2 vec2(-0.66,-0.66)\n#define SPHERE_CENTER3 vec2(-0.05,0.55)\n#define SPHERE_CENTER4 vec2(1.0,0.5)\n#define SPHERE_RADIUS1 0.050\n#define SPHERE_RADIUS2 0.250\n#define SPHERE_RADIUS3 0.125\n#define SPHERE_RADIUS4 0.3\n\n#define BOX_CENTER  vec2(0.16,-0.48)\n#define BOX_SIZE    vec2(0.3,0.1)\n#define BOX_ANGLE   3.14159/4.0\n#define BOX_CENTER2 vec2(0.55,0.0)\n#define BOX_SIZE2   vec2(0.1,0.3)\n#define BOX_ANGLE2  -3.15159/10.0\n\n#define LIGHT_POWER 2.0\n#define LIGHT_RADIUS 0.05\n#define NB_RAYS 0.0\n\nstruct Sphere {\n    vec2 c;\n    float r;\n};\n\nSphere NewSphere(vec2 pos, float rad) {\n    Sphere s;\n    s.c = pos;\n    s.r = rad;\n    return s;\n}\n\n\n\n\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDistSphere(vec2 position, Sphere sph){\n    // get parameters\n    vec2 center  = sph.c;\n    float radius = sph.r;\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the sphere center\n    position -= center;\n    // compute length\n    d = length(position) - radius;\n    // Return distance\n    return max(0.0,d);\n}\n\nfloat GetDistAABB(vec2 position, vec2 center, vec2 size, float angle){\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the box center\n    position -= center;\n    // CHange origin according to box angle\n    position *= Rot(angle);\n    // compute length\n    d = length(max(abs(position)-size,vec2(0)));\n    // Return distance\n    return d;\n}\n\nfloat RayMarching(vec2 uv, vec2 rayOrigin, vec2 rayDirection){\n    // Init algo\n    float dMin         = MAX_DISTANCE;\n    float marchDist    = 0.0;\n    vec2  p            = rayOrigin;\n\n    // Ray Marching Loop\n    for(int i=0; i<MAX_RM_STEPS && dMin>=MIN_DISTANCE && marchDist<=MAX_DISTANCE;i++){\n        // Get minimum distance to spheres, from the computed position\n        float dMin1 = GetDistSphere(p, NewSphere(SPHERE_CENTER1, SPHERE_RADIUS1) );\n        float dMin2 = GetDistSphere(p, NewSphere(SPHERE_CENTER2, SPHERE_RADIUS2) );\n        float dMin3 = GetDistSphere(p, NewSphere(SPHERE_CENTER3, SPHERE_RADIUS3) );\n        float dMin4 = GetDistSphere(p, NewSphere(SPHERE_CENTER4, SPHERE_RADIUS4) );\n        // Get minimum distance to box\n        float dMin11 = GetDistAABB(p, BOX_CENTER, BOX_SIZE, BOX_ANGLE);\n        float dMin12 = GetDistAABB(p, BOX_CENTER2, BOX_SIZE2, BOX_ANGLE2);\n        // get minimum from all the minimum\n        dMin = dMin1;\n        dMin = min(dMin,dMin2);\n        dMin = min(dMin,dMin3);\n        dMin = min(dMin,dMin4);\n        dMin = min(dMin,dMin11);\n        dMin = min(dMin,dMin12);\n        // Increase total distance\n        dMin      *= 0.5;\n        marchDist += dMin;\n        // Set the next marching point (origin + direction * distance)\n        p = rayOrigin + rayDirection * marchDist;                \n    }\n    // Return contact distance\n    float dotLen = dot( (uv-p), normalize(rayDirection) );\n    float shadow = 1.0-S(-EPSILON,0.0,dotLen);\n    //float shadow = S(1.0,1.0+EPSILON,marchDist);\n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Background color\n    vec3 bg = BG_COLOR*uv.x;\n    vec4 col = vec4(bg,1.0);\n\n    // Ray origin (mouse position)\n    vec2 lightPos = iMouse.xy;\n    bool autoAnim = (lightPos == vec2(0));\n    // Normalize mouse position\n    lightPos = (2.0*lightPos-iResolution.xy)/iResolution.y;\n    \n    // Auto anim\n    if(autoAnim){\n        lightPos  = vec2(0.4*cos(iTime*2.0+3.14159/2.0),0.9*sin(iTime));\n        lightPos += vec2(0.10,0.0);\n    }\n    \n    // Check \n    vec2 rayOrigin = lightPos;\n    vec2 targetDirection = uv-rayOrigin;\n\n    // Light fading\n    float fading = length(targetDirection);\n    fading  = S(LIGHT_POWER,0.0,fading);\n    fading *= fading;\n\n    // Draw light source (disc)\n    float lightDist  = length(uv-lightPos);\n    float lightAlpha = S(LIGHT_RADIUS ,0.0, lightDist); \n\n    // throw multiple rays from the light circle\n    /*\n    float shadow = 0.0;\n    for (float angle=-3.14159/2.0; angle<=3.14159/2.0; angle += 3.14159/(NB_RAYS))\n    {\n        // Ray marching\n        vec2 lightSource    = rayOrigin + (normalize(targetDirection)*Rot(angle))*LIGHT_RADIUS;\n        vec2 lightDirection = uv - lightSource;\n        shadow += RayMarching(uv, lightSource, lightDirection);\n    }\n    shadow /= (NB_RAYS+1.0);\n    /*/\n    float shadow = RayMarching(uv, rayOrigin, targetDirection);\n\n    // Light field (using shadow) + light source\n    vec3 lightColor = vec3(abs(sin(iTime*0.1287))*0.5+0.5,\n                           abs(sin(iTime*0.5687))*0.5+0.5,\n                           abs(sin(iTime*0.3154))*0.5+0.5);\n    col.rgb += lightColor*fading*shadow;\n    col.rgb += lightColor * vec3(lightAlpha);\n\n\n    // Draw Sphere obstacles\n    float d0 = length(uv-SPHERE_CENTER1);\n    float cS = S(SPHERE_RADIUS1+EPSILON, SPHERE_RADIUS1, d0);\n    d0 = length(uv-SPHERE_CENTER2);\n    cS += S(SPHERE_RADIUS2+EPSILON, SPHERE_RADIUS2, d0);\n    d0 = length(uv-SPHERE_CENTER3);\n    cS += S(SPHERE_RADIUS3+EPSILON, SPHERE_RADIUS3, d0);    \n    d0 = length(uv-SPHERE_CENTER4);\n    cS += S(SPHERE_RADIUS4+EPSILON, SPHERE_RADIUS4, d0);    \n    // Draw Box obstacles\n    d0 = length(max(abs((uv-BOX_CENTER)*Rot(BOX_ANGLE))-BOX_SIZE,vec2(0)));\n    cS += S(EPSILON, 0.0, d0);\n    d0 = length(max(abs((uv-BOX_CENTER2)*Rot(BOX_ANGLE2))-BOX_SIZE2,vec2(0)));\n    cS += S(EPSILON, 0.0, d0); \n    // apply shadow on shapes\n    cS *= shadow+pow(fading,5.0);\n    col.rgb += vec3(cS);\n\n\n    // Output\n    fragColor = col;    \n}\n\n","name":"Image","description":"","type":"image"}]}