{"ver":"0.1","info":{"id":"4lGcRy","date":"1536699461","viewed":187,"name":"subversion sb","username":"nabr","description":"the basic idea here is to map a surface to a sphere \n\ntransparent blending : https://www.shadertoy.com/view/MlGczc\n\nthis shader is tsimplified version: https://www.shadertoy.com/view/4t3cWj\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","translucent","surface","opacity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// nabr\n// https://www.shadertoy.com/view/4lGcRy\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n#define pi (4. * atan(1.))\n#define tau (8. * atan(1.))\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n#define rmat(a, b) mat3(1, 0, 0, 0, cos(b), -sin(b), 0, sin(b), cos(b)) * mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a))\n#define time iTime\n\n\nfloat map(vec3 p )\n{\n\n    R(p.zy, time * .05); R(p.xy, time * .15);\n \n    float t = tau;\n\n    // start animation / scale, swirl\n    if (iMouse.z > 0.) \n    {\n\n        t = -mod(time, -tau) + 2.0;\n        \n        R(p.xy, pi + time * .25);\n\n        // make a spiral    \n        if (t > 0. && sin(time * .5) > 0.)\n            R(p.xz, p.y - 0.001 * pi + time);\n    }\n\n    #define wave(p, d, f, s) float(exp(1.0 - sin(length(cross(d, p)) / length(d) * f + s)))\n    \n    float f6 = 0.0;\n    f6 = wave(p * 1.42, p.yxz, 2.01, t);\n\n    float final = 0.0;\n    final = (pi * log(f6) / log(2. * tau));\n    \n    /* // cross-capped disk\n    f6 = wave(p , p-vec3(.1), 2., t);\n    final = f6;\n\t*/\n    \n    //fake translucent https://www.shadertoy.com/view/XtGyzD\n    float sp = length(p) - (t * 0.5);\n    float edge = 0.0051; //will help with aa by discard edges\n    final = -(0.001 - sqrt(edge+max(sp + final, -sp - final)));\n\n    float thickness = 1.5;\n    return pow(final, 2./thickness);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // ----------------------- CAMERA\n\n    vec2 st = 2. * (fragCoord.xy / iResolution.xy) - 1.;\n\n    float aspect = (iResolution.x / iResolution.y);\n\n    vec3 ro = vec3(0, 0, -8.);\n    vec3 lookAt = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n\n    float fov = 95.;\n    vec3 g = normalize(lookAt - ro.xyz);\n    vec3 u = normalize(cross(g, up));\n    vec3 v = normalize(cross(u, g));\n    u = u * tan(radians(fov * 0.5));\n    v = v * tan(radians(fov * 0.5)) / aspect;\n    vec3 rd = normalize(g + st.x * u + st.y * v);\n    \n    //\n    vec2 m = 2.5 * atan((pi * (iMouse.xy / iResolution.y) - 1.) * vec2(aspect));\n    float initialrot = .52;\n    mat3 rot = rmat(m.x, m.y-initialrot);\n    rd = rot * rd;\n    ro = rot * ro;\n\n\n    vec3 color = vec3(0);\n    float t = 0.0, d = 1.0;\n\n    #define MAX_DIST 100.0\n    #define MIN_DIST 0.001\n    #define STEPS 1.0/ 120.0\n\n    for (float i = 0.0; (i < 1.0); i += STEPS ) \n    {\n        vec3 p = ro + t * rd;\n        if (t > MAX_DIST || d < MIN_DIST) break;\n        float d = map(p);\n        //t += max(d, .09)* 0.075 ;\n    \tt += d * 0.085;\n    };\n\n    // ------- shade\n    vec3 ip = ro.xyz + rd * t;\n\n    // color bar\n    if (-(st.y) < 0.95) \n    {\n        color = t * vec3(.1);\n        (iMouse.z > 0.0)?  \n            color\n            :color *= map(ip - 0.02) + t*.001;\n    };\n\n\n    fragColor.rgb = rd + color;\n    fragColor.a = 1.0;\n\n}//nabr","name":"Image","description":"","type":"image"}]}