{"ver":"0.1","info":{"id":"ctsSzM","date":"1674505427","viewed":162,"name":"Paraboloid Grid Traced","username":"fizzer","description":"A somewhat hastily-made raytracer inspired by Jakob Thomsen's [url=https://www.shadertoy.com/view/dtlSzH]Planar Quadrilateral Grid Traced[/url] shader, using paraboloid surfaces instead of planar surfaces for cell geometry.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["grid","heightmap","paraboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is based on an idea presented in Jakob Thomsen's Planar Quadrilateral Grid Traced shader.\n// (https://www.shadertoy.com/view/cllSR4)\n//\n// In that shader, a heightfield is expressed as the sum of two piecewise-linear functions so that\n// each grid cell of the surface is a plane and ray intersection can be solved as a linear equation.\n//\n// Here I have extended the idea to use piecewise-quadratic functions. This means that the ray intersection\n// can be solved as a quadratic equation.\n//\n// This means that instead of planar patches, each cell has a paraboloid patch.\n//\n// Each of the larger shaded grid squares is a single paraboloid.\n//\n\nfloat fr = 2.;\n\n// The heightfield is defined as g(x) + h(y)\nfloat g(float x)\n{\n    return sin(x * fr + iTime) + 4.;\n}\n\nfloat h(float y)\n{\n    return sin(y * fr / 1.5 + iTime) + 4.;\n}\n\n// First derivative of g(x) and h(y), for shading.\nfloat gPrime(float x)\n{\n    return cos(x * fr + iTime) * fr;\n}\n\nfloat hPrime(float y)\n{\n    return cos(y * fr / 1.5 + iTime) * fr / 1.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n\n    // Set up ray.\n    vec3 ro = vec3(iMouse.x / iResolution.x * 40., 6, -iMouse.y / iResolution.y * 40.);\n    vec3 rd = vec3((fragCoord.xy - iResolution.xy / 2.) / iResolution.y, -1.);\n\n    float th = -.49;\n    rd.yz = mat2(cos(th), sin(th), -sin(th), cos(th)) * rd.yz;\n\n    // Set up uniform grid traversal.\n    vec2 dt = vec2(1) / rd.xz;\n    vec2 ct = vec2(max(sign(rd.xz), vec2(0)) - fract(ro.xz)) * dt;\n    dt = abs(dt);\n    vec3 hit_p = vec3(0);\n    float t0 = 0.;\n    for(int i = 0; i < 100; ++i)\n    {\n        float t1 = min(ct.x, ct.y);\n        vec2 uvq = floor(ro.xz + rd.xz * (t0 + t1) / 2.);\n        vec3 uv = ro + rd * t0 - vec3(uvq.x, 0., uvq.y);\n\n        // Fit a parabolic curve to the height function, restricted to the cell's domain.\n        vec3 abc0 = inverse(mat3(0., .25, 1., 0., .5, 1.,\n                                1., 1., 1.)) * vec3(g(uvq.x), g(uvq.x + .5), g(uvq.x + 1.));\n\n        vec3 abc1 = inverse(mat3(0., .25, 1., 0., .5, 1.,\n                                1., 1., 1.)) * vec3(h(uvq.y), h(uvq.y + .5), h(uvq.y + 1.));\n\n        // Express ray intersection test as quadratic equation.\n        float a = abc0.x * rd.x * rd.x + abc1.x * rd.z * rd.z;\n        \n        float b = (abc0.x * 2. * uv.x + abc0.y) * rd.x + \n                  (abc1.x * 2. * uv.z + abc1.y) * rd.z - rd.y * 2.;\n                  \n        float c = (abc0.x * uv.x + abc0.y) * uv.x + abc0.z + \n                  (abc1.x * uv.z + abc1.y) * uv.z + abc1.z - uv.y * 2.;\n\n        float discr = b * b - 4. * a * c;\n\n        if(discr >= 0.)\n        {\n            // Check each potential hitpoint in t order.\n            vec2 hits = (vec2(-1, +1) * sqrt(discr) - b) / (2. * a);\n            if(hits.x > hits.y)\n                hits = hits.yx;\n            bool found = false;\n            for(int j = 0; j < 2; ++j)\n                if(hits[j] >= 0. && hits[j] <= (t1 - t0))\n                {\n                    hit_p = ro + rd*(t0 + hits[j]);\n                    found = true;\n                    break;\n                }\n            if(found)\n               break;\n        }\n        \n        // Step to next cell in grid along the ray.\n        t0 = t1;\n        if(ct.x < ct.y)\n            ct.x += dt.x;\n        else\n            ct.y += dt.y;\n    }\n\n    // Get surface normal at hitpoint.\n    vec3 n = normalize(cross(vec3(1., gPrime(hit_p.x), 0.), vec3(0., hPrime(hit_p.z), 1.)));\n\n    // Some shading.\n    col = vec3(.5 + .5 * step(.5, fract(hit_p.x / 2. + .5 * step(.5, fract(hit_p.y / 2.)))));\n    col = mix(col, col * .75, (.5 + .5 * step(.5, fract(hit_p.x * 2. + .5 * step(.5, fract(hit_p.y * 2.))))));\n    col *= n * .5 + .5;\n\n    fragColor = vec4(sqrt(col), 1.);\n}","name":"Image","description":"","type":"image"}]}