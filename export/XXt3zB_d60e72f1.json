{"ver":"0.1","info":{"id":"XXt3zB","date":"1716684745","viewed":60,"name":"Hexagonal Football","username":"notrobot","description":"Proof that you can make a (soccer) football out of hexagons! (You might just need an infinite number of them)\nThis uses an inverse stereographic projection to map a hexagonal grid from the infinite plane onto the sphere.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid","raytraced","plane","hex","football","soccer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader displays a football made of hexagons, such that it looks similar to the UK's geometrically incorrect\n// football road signs from one angle. Since it's impossible to tile a football with a finite number of hexagons,\n// we use an infinite number of hexagons, which tile the entire sphere except for one point at infinity.\n// To tile the sphere we first tile the plane with hexagons, then map the plane to the sphere using an inverse\n// stereographic transform.\n//\n// Thanks to Matt Parker for inspiring this experiment with their Youtube video:\n// \"The mathematically impossible ball that shouldn't exist\"\n// https://www.youtube.com/watch?v=_cAl3FlQZ9Q\n//\n\nconst float PI = 3.141592653589793;\n\n// given a 2D coordinate, return the color index of the hexagon on the hex grid under that coordinate.\nint getHexColor(vec2 position)\n{\n    // convert the position into three coordinates along basis vectors at 60 degrees to one another.\n    const vec2 dir1 = vec2(1.0, 0.0);\n    const vec2 dir2 = vec2(cos(PI*2.0/3.0), sin(PI*2.0/3.0));\n    const vec2 dir3 = vec2(cos(PI*4.0/3.0), sin(PI*4.0/3.0));\n\n    float dist1 = dot(position, dir1);\n    float dist2 = dot(position, dir2);\n    float dist3 = dot(position, dir3);\n\n    vec3 hexPos = vec3(dist1, dist2, dist3);\n    \n    // convert to integer coordinates.\n    // take each coordinate modulo three\n    ivec3 tileColor = ivec3(fract(floor(hexPos)/3.0)*3.01);\n\n    // look up the triangle to see which of three colors it should be\n    // (could probably make this faster and clearer, it's just generated by trial and error)\n    int col = 0;\n\n    if ( \n       ((tileColor.x == 0) && (tileColor.y == 0) && (tileColor.z == 1))\n    || ((tileColor.x == 0) && (tileColor.y == 0) && (tileColor.z == 2))\n    || ((tileColor.x == 1) && (tileColor.y == 0) && (tileColor.z == 1))\n    || ((tileColor.x == 0) && (tileColor.y == 2) && (tileColor.z == 2))\n    || ((tileColor.x == 1) && (tileColor.y == 2) && (tileColor.z == 1))\n    || ((tileColor.x == 1) && (tileColor.y == 2) && (tileColor.z == 2))\n    )\n        col = 1;\n    else if (\n          ((tileColor.x == 1) && (tileColor.y == 1) && (tileColor.z == 2))\n        ||((tileColor.x == 2) && (tileColor.y == 0) && (tileColor.z == 0))\n        ||((tileColor.x == 2) && (tileColor.y == 1) && (tileColor.z == 2))\n        ||((tileColor.x == 2) && (tileColor.y == 0) && (tileColor.z == 2))\n        ||((tileColor.x == 0) && (tileColor.y == 1) && (tileColor.z == 2))\n        ||((tileColor.x == 1) && (tileColor.y == 0) && (tileColor.z == 0))\n        ||((tileColor.x == 1) && (tileColor.y == 1) && (tileColor.z == 0))\n    )\n        col = 2;\n\n    return col;\n}\n\n// Fire a ray and test if it intersects a sphere.\n// rayStart - start position of the ray.\n// rayDir - direction that the ray moves in. This is the vector it travels in one time unit.\n// sphereCentre - centre of the sphere to test against.\n// sphereRadius - radius of the sphere to test against.\n// hitDistance - outputs the time taken along the ray before it hits the sphere.\n// hitPosition - position in world coordinates of where the ray hits the sphere.\n// hitNormal - sphere local coordinates of where the ray hit. Can be used as a surface normal.\n// The function returns true if a hit occurred, false if the ray misses the sphere.\n// If the function returns false, the output values hitDistance, hitPosition, hitNormal must be ignored.\nbool rayHitSphere(vec3 rayStart, vec3 rayDir, vec3 sphereCentre, float sphereRadius, out float hitDistance, \n    out vec3 hitPosition, out vec3 hitNormal)\n{\n    hitDistance = 0.0;\n    hitPosition = vec3(0.0, 0.0, 0.0);\n    hitNormal = vec3(0.0, 0.0, 0.0); // dummy values.\n    \n    rayStart -= sphereCentre; // offset ray by sphere so treat as if sphere is at origin\n    \n    // P=ray start, D=ray direction, t=time, r = radius\n    // now solve |P+tD| == r\n    // (Px+tDx)^2 + (Py+tDy)^2 + (Pz+tDz)^2 - r^2 == 0\n    \n    // solve using the quadratic formula:\n    \n    // at^2 + bt + c == 0 iff\n    // t = (-b +- sqrt(b^2 - 4ac))/2a\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0*dot(rayStart, rayDir);\n    float c = dot(rayStart,rayStart) - sphereRadius*sphereRadius;\n    \n    float descriminant = b*b - 4.0*a*c;\n    if (descriminant < 0.0)\n        return false; // ray does not hit sphere\n    else\n    {\n        float sqrt_desc = sqrt(descriminant);\n        float t1 = (-b - sqrt_desc) / (2.0*a);\n        float t2 = (-b + sqrt_desc) / (2.0*a);\n        \n        if (t2 < 0.0) return false; // ray hit is behind the camera\n        \n        hitDistance = (t1 < 0.0) ? t2 : t1; // if t1<0, ray starts inside the sphere.\n        \n        vec3 hitOffset = (rayStart + rayDir * hitDistance);\n\n        hitPosition = hitOffset + sphereCentre;\n        hitNormal = hitOffset / sphereRadius;\n        \n        return true;\n    }\n}\n\n// Apply an inverse stereographic projection\n// by casting a ray from the top of the sphere to the point on the sphere\n// and continuing that ray until it hits the ground plane.\nvec2 inverseStereographicProjection(vec3 sphereNormal)\n{\n    float hitDistance;\n    vec3 sphereHitPos;\n    vec3 hitNormal;\n    \n    \n    vec3 sphereTop = vec3(0.0, 2.0, 0.0);\n    vec3 rayDir = (sphereNormal + vec3(0.0, 1.0, 0.0)) - sphereTop;\n    \n    rayHitSphere(sphereTop + rayDir*0.001, rayDir,\n        vec3(0.0, 1.0, 0.0), 1.0, hitDistance, sphereHitPos, hitNormal);\n   \n   return sphereHitPos.xz / (2.0 - sphereHitPos.y);\n}\n\n// rotate a 2d point around the origin by an angle\nvec2 rotate(vec2 point, float angle)\n{\n    return vec2(point.x * cos(angle) - point.y * sin(angle),\n                point.x * sin(angle) + point.y * cos(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv * 2.0 - vec2(1.0, 1.0); // rescale to -1..1\n    uv.y *= (float(iResolution.y)/float(iResolution.x)); // apply the aspect ratio\n    \n    // define the camera\n    vec3 cameraPoint = vec3(sin(iTime/4.0)*25.0, 10.0, cos(iTime/4.0)*25.0);\n    vec3 cameraLookAt = vec3(0.0, 5.0, 0.0);\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    // camera vectors (might be the wrong way round! didn't check)\n    vec3 cameraForward = normalize(cameraLookAt - cameraPoint);\n    vec3 cameraRight = normalize(cross(cameraForward, cameraUp));\n    vec3 cameraTrueUp = normalize(cross(cameraForward, cameraRight));\n    \n    // negative direction of infinitely far away light source\n    const vec3 lightDirection = normalize(vec3(1.0, 1.0, 0.0));\n    \n    // ray from camera into scene to trace\n    vec3 rayDirection = cameraForward + (cameraTrueUp * -uv.y) + (cameraRight * uv.x);\n    vec3 col;\n    \n    // position and radius of the football (sphere)\n    float bounceTime = fract(iTime/2.0); // each bounce is two seconds.\n    const float bounceHeight = 5.0;\n    float sphereRadius = 5.0;\n    // apply a quadratic curve to bounce on the spot.\n    vec3 sphereCentre = vec3(0.0, sphereRadius + bounceHeight - ((bounceTime-0.5)*(bounceTime-0.5)*4.0*bounceHeight), 0.0);\n    float spinAngle = iTime; // for rotating the ball so we see all the sides.\n    \n    float hitDistance;\n    vec3 hitPosition, hitNormal;\n    // do a ray-sphere intersection to see if the camera ray hits the football.\n    // as the ball is always above the plane, and so is the camera, we don't need a distance check.\n    if (rayHitSphere(cameraPoint, rayDirection, sphereCentre, sphereRadius, hitDistance, hitPosition, hitNormal))\n    {\n        // do simple lighting using the angle between the normal and direction to the light.\n        float matteIntensity = max(0.25,dot(lightDirection, hitNormal));\n\n        hitNormal.xy = rotate(hitNormal.xy, spinAngle);\n    \n        vec2 stereoPos = inverseStereographicProjection(hitNormal);\n        \n        int sphereHexColor = getHexColor(sphereCentre.xz + stereoPos * 6.0);\n        \n        vec3 albedo = vec3(0.0, 0.0, 0.0);\n\n        if (sphereHexColor == 0)\n            albedo = vec3(1.0, 1.0, 1.0); // white\n        else if (sphereHexColor == 1)\n            albedo = vec3(0.9, 0.9, 0.9); // slightly off-white\n        else if (sphereHexColor == 2)\n            albedo = vec3(0.0, 0.0, 0.0); // black\n        \n        \n        col = albedo * matteIntensity;\n    }\n    // if we are looking downwards, we will see the ground.\n    else if (rayDirection.y < 0.0)\n    {\n        // distance along ray to the point on the ground we see.\n        float distance = cameraPoint.y / -rayDirection.y;\n        \n        // point on the ground we are looking at.\n        vec3 groundHitPos = cameraPoint + rayDirection * distance;\n        \n        // ignore Y coordinate which is always zero.\n        vec2 tilePos = groundHitPos.xz;\n        \n        // look up hexagonal grid\n        int hexColor = getHexColor(tilePos);\n\n        // pick a color based on which hex tile we are looking at.\n        col = vec3(0.0, 0.0, 0.0);\n        if (hexColor == 0)\n            col = vec3(1.0, 1.0, 1.0);\n        else if (hexColor == 1)\n            col = vec3(0.0, 1.0, 0.0);\n\n        // cast a shadow ray from the ground towards the light source. If it hits the football, apply a shadow.\n        float unused1; vec3 unused2, unused3;\n        if (rayHitSphere(groundHitPos, lightDirection, sphereCentre, sphereRadius, unused1, unused2, unused3))\n            col *= 0.25; // darken our floor colour.\n\n        // add distance fog to remove aliasing close to horizon\n        col = mix(vec3(0.0, 0.0, 1.0), col, pow(0.98,distance));\n    }\n    else\n    {\n        col = vec3(0.0,0.0,1.0); // blue sky\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}