{"ver":"0.1","info":{"id":"XcV3Wz","date":"1712611479","viewed":54,"name":"Light Casters Base","username":"Smiley98","description":"Point, direction, and spot lights.\nIn other words, hella lit yo!!!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong","lighting","lightcasters"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float NEAR = 0.001;\nconst float FAR = 100.0;\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    float ground = p.y + 0.5;\n    vec3 spherePosition = vec3(/*sin(iTime) * 3.0*/0.0, 1.0, 0.0);\n    float sphere = sdSphere(p - spherePosition, 1.0);\n    //return sphere;\n    return min(sphere, ground);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// Point light --> attenuation. Direction light --> infinite. Spot light --> cutoff\nvec3 phong(vec3 position, vec3 normal, vec3 camera, vec3 light, vec3 color,\n    float ambient, float diffuse, float specular)\n{\n    vec3 N = normalize(normal);\n    vec3 L = normalize(light - position);\n    vec3 V = normalize(camera - position);\n    vec3 R = reflect(-L, N);\n    \n    float dotNL = max(0.0, dot(L, N));\n    float dotVR = max(0.0, dot(R, V));\n    \n    vec3 lighting = vec3(0.0, 0.0, 0.0);\n    lighting += color * ambient;\n    lighting += color * diffuse * dotNL;\n    lighting += color * pow(dotVR, specular);\n    return lighting;\n}\n\n// Phong but attenuated\nvec3 point_light(vec3 position, vec3 normal, vec3 camera, vec3 light, vec3 color,\n    float ambient, float diffuse, float specular, float radius)\n{\n    // To implement a point light:\n    // 1. Determine distance from fragment to light\n    // 2. Ensure distance is less than the light's radius\n    // 3. Apply phong and attenuate inversely proportional to distance (near = bright, far = dark).\n    \n    // Start by ensuring distance cannot exceed radius\n    //float dist = min(distance(position, light), radius);\n    // Divide by radius & subtract from 1 to make normalized value\n    //float t = 1.0 - (dist / radius);\n    \n    // Linear\n    //float attenuation = t;\n    \n    // Darker\n    //float attenuation = pow(t, 2.0);\n    \n    // Brighter\n    //float attenuation = 1.0 + log(t);\n    \n    // Contrast\n    float attenuation = smoothstep(radius, 0.0, length(light - position));\n\n    return phong(position, normal, camera, light, color, ambient, diffuse, specular) * attenuation;\n}\n\n// Phong but infinite\nvec3 direction_light(vec3 direction, vec3 normal, vec3 camera, vec3 color,\n    float ambient, float diffuse, float specular)\n{\n    // To implement a directional light:\n    // 1. Pass position as a zero-vector\n    // 2. Pass -direction as the light parameter\n    // 3. Forward all remaining parameters as-is to phong!\n\n    // Explanation:\n    // Direction lights have infinite range (as seen in lab 5), so no additional math is necessary.\n    // Within phong, we calculate the vector from fragment to light (L).\n    // By setting position (fragment) to zero, we make phong's light-vector solely our light (\"direction\").\n    // However, if we leave it as-is, L will be facing away from our normals.\n    // For example, if L = (0.0, 0.0, 1.0) and our sphere is in front of the camera, then its normals\n    // N = (0.0, 0.0, -1.0) because they're pointing backwards along z towards the camera since we can see the sphere).\n    // Dot(N, L) will be -1.0 because our vectors are opposite! Hence, we need to negate L (aka direction).\n    return phong(vec3(0.0, 0.0, 0.0), normal, camera, -direction, color, ambient, diffuse, specular);\n}\n\n// Phong but cut-off\nvec3 spot_light(vec3 position, vec3 direction, vec3 normal, vec3 camera, vec3 light, vec3 color,\n    float ambient, float diffuse, float specular, float radius, float cutoff)\n{\n    // To implement a spot light:\n    // 1. let L = unit vector from fragment to light (same as within phong)\n    // 2. let angle = similarity between -L and direction\n    // 3. Apply point-lighting if cutoff (cosine of half the light's FoV) is less than angle\n    vec3 L = normalize(light - position);\n    float t = dot(-L, direction);\n    if (cutoff < t)\n    {\n        return point_light(position, normal, camera, light, color, ambient, diffuse, specular, radius);\n    }\n    \n    // Explanation: we're comparing the angle between the light vector & light's direction with the light's FoV\n    // If we're within the FoV, apply lighting. Otherwise no lighting.\n    // Review the geometric dot-product formula and my FoV calculation if you want to understand the math:\n    // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n    // https://github.com/Smiley98/GC-Graphics/blob/w12-02-light-casters/Assets/Scripts/Detector.cs\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, 1] --> [-1, 1]\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    \n    // FoV of 90 degrees\n    float fov = tan(45.0 * 3.14 / 180.0);\n    \n    // Ray direction\n    vec3 rd = normalize(vec3(uv * fov, 1.0));\n    \n    // Distance along ray\n    float t = 0.0;\n    \n    for (int i = 0; i < 80; i++)\n    {\n        // Scene position\n        vec3 p = ro + rd * t;\n        \n        // Determine maxmimum safe stepping distance\n        float d = map(p);\n        \n        // Step along ray by distance d\n        t += d;\n        \n        // Intersection if distance is very close to surface (SDF --> -1)\n        if (d < NEAR) break;\n        \n        // No intersection if distance along ray exceeds view distance\n        if (t > FAR) break;\n    }\n    \n    float nsin = sin(iTime) * 0.5 + 0.5;;\n    vec3 p = ro + rd * t;\n    vec3 n = estimateNormal(p);\n    \n    //vec3 lightColor = n * 0.5 + 0.5;\n    vec3 lightColor = vec3(1.0, 0.0, 1.0);\n    vec3 spotLightPosition = vec3(sin(iTime) * 5.0, 5.0, 0.0);\n    vec3 spotLightDirection = vec3(0.0, -1.0, 0.0);\n    vec3 pointLightPosition = vec3(0.0, 3.0, sin(iTime) * 2.5);\n    float specular = 256.0;\n    \n    float radius = 15.0;\n    float cutoff = cos(radians(45.0 * 0.5));\n    \n    vec3 lighting = vec3(0.0, 0.0, 0.0);\n    lighting += point_light(p, n, ro, pointLightPosition, vec3(0.0, 1.0, 0.0), 0.1, 0.5, specular, radius);\n    lighting += spot_light(p, spotLightDirection, n, ro, spotLightPosition + vec3(0.0, 0.0, 0.0), lightColor, 0.1, 1.0, specular, radius, cutoff);\n    lighting += spot_light(p, spotLightDirection, n, ro, spotLightPosition + vec3(2.5, 0.0, 0.0), lightColor, 0.1, 1.0, specular, radius, cutoff);\n    lighting += spot_light(p, spotLightDirection, n, ro, spotLightPosition - vec3(2.5, 0.0, 0.0), lightColor, 0.1, 1.0, specular, radius, cutoff);\n    lighting += direction_light(vec3(0.0, 0.0, 1.0), n, ro, vec3(0.0, 0.0, 1.0), 0.1, 0.75, specular);\n    \n    bool hit = t < FAR - EPSILON;\n    vec3 color = hit ? lighting : vec3(0.25, 0.25, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}