{"ver":"0.1","info":{"id":"lsdXRS","date":"1460073953","viewed":332,"name":"Rock - Paper - Scissors","username":"aaecheve","description":"This is a 3 colored celullar automata growth model. Red wins Green, Green wins Blue, Blue wins Red.\n\nControls\nKeys: R, G, B change mouse draw color\nClick: Paint\n\nChange SMOOTHING define to vary kernel size, which affects speed and shape smoothness.","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RED     vec4(1.0,0.0,0.0,1.0)\n#define GREEN   vec4(0.0,1.0,0.0,1.0)\n#define BLUE    vec4(0.0,0.0,1.0,1.0)\n\n#define KEY_B\t(66.0 + 0.5)/256.0\n#define KEY_G\t(71.0 + 0.5)/256.0\n#define KEY_R\t(82.0 + 0.5)/256.0\n\n\nvec4 store_color_index();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    //fragColor = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n    //fragColor = store_color_index();\n}\n\nvec4 store_color_index()\n{\n    // read keyboard\n    float kR = texture( iChannel2, vec2(KEY_R,0.0) ).x;\n    float kG = texture( iChannel2, vec2(KEY_G,0.0) ).x;\n    float kB = texture( iChannel2, vec2(KEY_B,0.0) ).x;\n    \n    vec4 result = vec4(0,0,0,1);\n    \n    if(kR > 0.5)\n    {\n        result = RED;\n    }\n    \n    if(kG > 0.5)\n    {\n        result = GREEN;\n    }\n    \n    if(kB > 0.5)\n    {\n        result = BLUE;\n    }\n    \n    return result;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RED     vec4(1.0,0.0,0.0,1.0);\n#define GREEN   vec4(0.0,1.0,0.0,1.0);\n#define BLUE    vec4(0.0,0.0,1.0,1.0);\n\n#define BRUSH_RADIUS 0.1\n\n#define CURRENT_COLOR_INDEX (vec2(0.0 + 0.5, 0.0 + 0.5))\n#define MOUSE_INDEX (vec2(1.0 + 0.5, 0.0 + 0.5))\n\n#define B_BUFFER_SIZE iChannelResolution[1].xy\n// SMOOTHING > 0\n#define SMOOTHING (4)\n\n\n/* Forward declare because i'm lazy and dont want to reorder functions. */\nvec4 reset(vec2 fragCoord);\nvec4 grow(vec2 fragCoord);\nvec4 set_color(vec2 fragCoord, vec4 fragColor);\nfloat loop_coords(float coord, float resolution);\nmat4 _transpose(mat4 mat);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        fragColor = reset(fragCoord);\n    }\n    else\n    {\n        fragColor = grow(fragCoord);\n        fragColor = set_color(fragCoord, fragColor);\n    }\n}\n\nvec4 reset(vec2 fragCoord)\n{\n\treturn vec4(fragCoord/iChannelResolution[0].xy,\n                sin(fragCoord.x*fragCoord.y*100.0 + iDate.w)*0.5 + 0.5, 0.0);\n}\n\nvec4 grow(vec2 fragCoord)\n{\n    vec2 fragCoord_n = fragCoord.xy/iChannelResolution[0].xy;\n    \n    vec4 total_neigh = vec4(0,0,0,0);\n    \n    for(int i = 1; i <= SMOOTHING; i++)\n    {\n        float fi = float(i);\n        float left_neigh = loop_coords(fragCoord.x-fi, iChannelResolution[0].x)/iChannelResolution[0].x;\n        float right_neigh = loop_coords(fragCoord.x+fi, iChannelResolution[0].x)/iChannelResolution[0].x;\n\n        float down_neigh = loop_coords(fragCoord.y-fi, iChannelResolution[0].y)/iChannelResolution[0].y;\n        float up_neigh = loop_coords(fragCoord.y+fi, iChannelResolution[0].y)/iChannelResolution[0].y;\n        \n        total_neigh +=     texture(iChannel0, vec2(fragCoord_n.x, up_neigh));\n        total_neigh +=     texture(iChannel0, vec2(fragCoord_n.x, down_neigh));\n        total_neigh +=     texture(iChannel0, vec2(left_neigh, fragCoord_n.y));\n        total_neigh +=     texture(iChannel0, vec2(right_neigh, fragCoord_n.y));\n\n        total_neigh +=     texture(iChannel0, vec2(left_neigh, up_neigh));\n        total_neigh +=     texture(iChannel0, vec2(right_neigh, up_neigh));\n        total_neigh +=     texture(iChannel0, vec2(left_neigh, down_neigh));\n        total_neigh +=     texture(iChannel0, vec2(right_neigh, down_neigh));\n    }\n    \n    vec4 original_value = texture(iChannel0, fragCoord_n.xy);\n    \n    \n    float tr = total_neigh.r;\n    float tg = total_neigh.g;\n    float tb = total_neigh.b;\n    \n    float r = original_value.r;\n    float g = original_value.g;\n    float b = original_value.b;\n    float w = original_value.w;\n\n    vec4 greatest = vec4( float((1.0 + 2.0*g)*tr > tg && tr > tb),\n                   \t      float((1.0 + 2.0*b)*tg > tb && tg > tr),\n                          float((1.0 + 2.0*r)*tb > tr && tb > tg),0);\n    \n    greatest.w = (1.0 - greatest.x - greatest.y - greatest.z);\n    \n    float gx = greatest.x;\n    float gy = greatest.y;\n    float gz = greatest.z;\n    float gw = greatest.w;\n\n    float valid = b + g + r;\n    \n    mat4 greatest_mat = transpose(mat4(gx+gw,gx,0,0, 0,gy+gw,gy,0, gz,0,gz+gw,0, 0,0,0,0));\n    \n    return vec4(greatest);\n\treturn (1.0 - valid)*greatest_mat*original_value + valid*greatest;\n}\n\nvec4 set_color(vec2 fragCoord, vec4 fragColor)\n{\n    vec2 fragCoord_n = fragCoord.xy/iChannelResolution[0].xy;\n\tvec4 mouse = texture(iChannel1, MOUSE_INDEX / B_BUFFER_SIZE);\n    vec2 mouse_n = mouse.xy / iChannelResolution[0].xy;\n    \n    vec4 result = fragColor;\n    \n    if(mouse.z > 0.5)\n    {\n        float aspect_radio = iChannelResolution[0].y/iChannelResolution[0].x;\n        vec2 offset = mouse_n - fragCoord_n;\n        offset = vec2(offset.x, offset.y*aspect_radio);\n        float dist_2 = dot(offset, offset);\n        \n        if(dist_2 < BRUSH_RADIUS*BRUSH_RADIUS)\n        {\n            result = texture(iChannel1, CURRENT_COLOR_INDEX / B_BUFFER_SIZE);\n        }\n    }\n    \n    return result;\n}\n\nfloat loop_coords(float coord_n, float resolution)\n{\n    float max_value = (resolution - 0.5);\n    float loop_up = float(coord_n > max_value);\n    float loop_down = float(coord_n < 0.5);\n    return loop_down*max_value + (1.0 - loop_down - loop_up)*coord_n;\n}\n\nmat4 _transpose(mat4 mat)\n{\n    return mat4 (mat[0][0], mat[1][0], mat[2][0], mat[3][0],\n                 mat[0][1], mat[1][1], mat[2][1], mat[3][1],\n                 mat[0][2], mat[1][2], mat[2][2], mat[3][2],\n                 mat[0][3], mat[1][3], mat[2][3], mat[3][3]);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define RED     (vec4(1.0,0.0,0.0,1.0))\n#define GREEN   (vec4(0.0,1.0,0.0,1.0))\n#define BLUE    (vec4(0.0,0.0,1.0,1.0))\n\n#define KEY_B\t((66.0 + 0.5)/256.0)\n#define KEY_G\t((71.0 + 0.5)/256.0)\n#define KEY_R\t((82.0 + 0.5)/256.0)\n\n#define CURRENT_COLOR_INDEX (vec2(0.0 + 0.5, 0.0 + 0.5))\n#define MOUSE_INDEX (vec2(1.0 + 0.5, 0.0 + 0.5))\n\n#define B_BUFFER_SIZE (iChannelResolution[1].xy)\n\n//&& (v0.y > (v1.y - COMPARE_DELTA)) && (v0.y < (v1.y + COMPARE_DELTA))\n\nvec4 store_color();\nvec4 store_mouse();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if      (CURRENT_COLOR_INDEX == fragCoord) fragColor = store_color();\n    else if (MOUSE_INDEX == fragCoord)         fragColor = store_mouse();\n    else                                       discard;\n}\n\nvec4 store_color()\n{\n    // read keyboard\n    float kR = texture( iChannel0, vec2(KEY_R,0.0) ).x;\n    float kG = texture( iChannel0, vec2(KEY_G,0.0) ).x;\n    float kB = texture( iChannel0, vec2(KEY_B,0.0) ).x;\n    \n    vec4 result = texture(iChannel1, CURRENT_COLOR_INDEX / B_BUFFER_SIZE);\n    \n    if(iFrame == 0)\n    {\n        result = RED;\n    }\n    \n    if(kR > 0.5)\n    {\n        result = RED;\n    }\n    \n    if(kG > 0.5)\n    {\n        result = GREEN;\n    }\n    \n    if(kB > 0.5)\n    {\n        result = BLUE;\n    }\n    \n    return result;\n}\n\nvec4 store_mouse()\n{\n    return iMouse;\n}","name":"Buf B","description":"","type":"buffer"}]}