{"ver":"0.1","info":{"id":"3dlcW8","date":"1584962259","viewed":101,"name":"Undulating Lattice","username":"takumifukasawa","description":"Undulating Lattice","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","pointlight","csg","lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPS .0001\n#define NORMAL_EPS .0001\n#define PI 3.14159265359\n#define PI2 PI * 2.\n\n#define MAT_TUBE 1.\n\n#define saturate(a) clamp(a, 0., 1.)\n#define repeat(a, b) mod(a, b) - b * .5 \n\nprecision highp float;\n\n//---------------------------------------------------------------------------------------------\n// utils\n//---------------------------------------------------------------------------------------------\n\nbool checkMat(float material, float check) {\n\treturn material < (check + .5);\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot2(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\n//---------------------------------------------------------------------------------------------\n// sdf\n//---------------------------------------------------------------------------------------------\n\n// ra: radius\n// rb: round\n// h: height\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;\n}\n\n// a: begin pos\n// b: begin thin\n// ra: end pos\n// rb: end thin\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float r = mix(ra, rb, h);\n\treturn length(pa - h * ba) - r;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad) {\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.) / k1;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat smin(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn min(a, b) - h * h / (k * 4.);\n}\n\nfloat smax(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn max(a, b) + h * h / (k * 4.);\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = atan(p.x, p.y) + PI / r;\n    float n = PI * 2. / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\n//---------------------------------------------------------------------------------------------\n// raymarch\n//---------------------------------------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n    // dummy float max and min\n    vec2 res = vec2(10000., -10000.);\n\n    {\n        float d = 0.;\n\n        p.z -= iTime * .7;\n\n        p.xy = rot(iTime * .1 + p.z * .25) * p.xy;\n\n        vec3 _p1 = p;\n        float sphereRepeatNum = .5;\n        _p1 = repeat(_p1, sphereRepeatNum);\n        vec3 sphereId = floor(p / sphereRepeatNum);\n\t    d = sdElipsoid(_p1, vec3(.02 + sin(iTime * 1. + sphereId.z) * .2));\n\n        vec3 _p2 = p;\n        float tube1_repeat_num = .5;\n        vec3 tube1_id = floor(p / tube1_repeat_num);\n\t    _p2.yz = rot(PI * .5) * _p2.yz;\n        _p2.x += sin(iTime * 2. + p.x * 3. + p.z * 2.) * .04;\n        _p2.z += sin(iTime * 2. + p.z * 4. + p.x * 4.) * .04;\n\t    _p2 = repeat(_p2, tube1_repeat_num);\n\t\td = smin(\n            d,\n            sdCylinder(_p2, vec3(0., 0., .025)),\n            .08\n        );\n\n        vec3 _p3 = p;\n        float tube2RepeatNum = .5;\n        vec3 tube2Id = floor(p / tube2RepeatNum);\n\t    _p3.xz = rot(PI * .5) * _p3.yz;\n        _p3.y += sin(iTime * 2. + p.y * 3. + p.x * 2.) * .04;\n        _p3.z += sin(iTime * 2. + p.z * 4. + p.x * 4.) * .04;\n\t    _p3 = repeat(_p3, tube2RepeatNum);\n\t\td = smin(\n             d,\n             sdCylinder(_p3, vec3(0., 0., .025)),\n             .08\n         );\n\n        vec3 _p4 = p;\n        float tube3RepeatNum = .5;\n        vec3 tube3_id = floor(p / tube3RepeatNum);\n        _p4.x += sin(iTime * 2. + p.y * 3. + p.x * 2.) * .04;\n        _p4.z += sin(iTime * 2. + p.z * 4. + p.x * 4.) * .04;\n\t    _p4 = repeat(_p4, tube3RepeatNum);\n\t\td = smin(\n            d,\n            sdCylinder(_p4, vec3(0., 0., .025)),\n            .08\n        );\n\n        if(d < res.x) res = vec2(d, MAT_TUBE);\n    }\n    \n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n\tfloat tmin = .01;\n    float tmax = 80.;\n    float m = -1.;\n    float t = tmin;\n    for(int i = 0; i < 64; i++) {\n\t\tvec3 pos = ro + rd * t;\n        vec2 h = scene(pos);\n        m = h.y;\n        if(abs(h.x) < (.001 * t)) break;\n        t += h.x;\n        if(t > tmax) break;\n    }\n    if(t > tmax) m = -1.;\n    return vec2(t, m);\n}\n\n//---------------------------------------------------------------------------------------------\n// lightings\n//---------------------------------------------------------------------------------------------\n\nfloat calcOcculusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++) {\n    \tfloat h = .01 + .11 * float(i) / 4.;\n        vec3 opos = pos + h * nor;\n        float d = scene(opos).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2. * occ, 0., 1.);\n}\n \nvec3 fog(vec3 color, float dist, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-dist * b);\n  return mix(color, fogColor, fogAmount);\n}\n \n\n//---------------------------------------------------------------------------------------------\n// main\n//---------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(mouse * .5, 4.) + vec3(sin(iTime * 1.4) * .075, cos(iTime * .9) * .075, 0.);\n    vec3 target = vec3(ro.xy, ro.z - 3.) + vec3(cos(iTime * 1.2) * .075, sin(iTime * .7) * .075, 0.);\n    float fov = 1.5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n\tvec2 result = raymarch(ro, rd);\n\tvec3 color = vec3(0.);\n    \n    if(result.y > 0.) {\n\t    float depth = result.x;\n    \tfloat material = result.y;    \n   \n    \tvec3 position = ro + rd * depth;\n    \tvec3 normal = getNormal(position);\n    \n    \tvec3 objColor = vec3(0.);\n\n        if(checkMat(material, MAT_TUBE)) {\n            objColor = vec3(.1, .2, .5);\n        }\n\n        vec3 specularColor = vec3(.1, .2, .7);\n        \n    \tvec3 lightPos = vec3(0., 0., ro.z - 3.);\n        vec3 lightDir = normalize(lightPos);\n        float lightIntensity = .45;\n    \n    \tvec3 ambient = vec3(.01);\n        \n\t\t// point light\n\t\tvec3 toLightDir = normalize(lightPos - position);\n\t\tfloat diffuse = max(0., dot(normal, toLightDir));\n\t\tfloat d = distance(lightPos, position);\n\t\tvec3 k = vec3(0.06, 0.08, 0.09);\n\t\tfloat attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n        attenuation *= lightIntensity;\n  \n\t\tvec3 ref = reflect(-toLightDir, normal);\n\t\tfloat specular = max(0., dot(ref, normalize(ro - normal)));\n\t\tfloat specularPower = 32.;\n\t\tspecular = pow(specular, specularPower);\n        \n\t\tdiffuse *= attenuation;\n\t\tspecular *= attenuation;\n  \n\t\tcolor =\n            objColor * vec3(diffuse) +\n            specularColor * vec3(specular) +\n            ambient;        \n    }\n\n    // fog\n    color = fog(color, result.x, vec3(.05, .05, .1), .14);\n    \n    // gamma\n    color = pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}