{"ver":"0.1","info":{"id":"clXBzS","date":"1693067548","viewed":65,"name":"infinite corridors","username":"Amita","description":"infinite infinitely long hallways","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HALFHEIGHT 2.0\n#define TEXSCALE0 10.0\n#define TEXSCALE1 10.0\n#define TEXSCALE2 3.0\n#define WALLDIST 6.5\n#define WALLGAP 3.0\n#define PI 3.141592653589793\n#define PRECISION\n\n//Uncomment for wall debug mode\n//#define DEBUG 0.4\n\nmat3 curRot() {\n    vec2 mouse = (iMouse.zw == vec2(0.0) ? vec2(0.5) : iMouse.xy);\n    vec2 angle = -PI*vec2(2.0*mouse.x/iResolution.x - 1.0, mouse.y/iResolution.y - 0.5);\n    return mat3(\n        1.0,      0.0    ,    0.0     ,\n        0.0,cos(angle.y),-sin(angle.y),\n        0.0,sin(angle.y), cos(angle.y))\n    *mat3(\n        cos(angle.x),0.0,-sin(angle.x),\n            0.0     ,1.0,       0.0   ,\n        sin(angle.x),0.0, cos(angle.x));\n}\n\nfloat modfl(float x, float y) {\n    return mod(mod(x,y)+y,y);\n}\n\nfloat roundAway(float x, float sinal) {\n    return (sinal >= 0.0 ? ceil(x/WALLDIST) : floor(x/WALLDIST) )*WALLDIST;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 origin = texelFetch(iChannel3, ivec2(0,0), 0).xyz*1e3;\n    vec3 dir = vec3((fragCoord - iResolution.xy/2.0)/iResolution.y,1.0)*curRot();\n    vec3 pos = dir + origin;\n    \n    #if defined(DEBUG)\n    vec4 teste = vec4(0.0);\n    #endif\n    \n    vec3 end = pos + (HALFHEIGHT - abs(pos.y))*dir/abs(dir.y);\n    \n    vec3 parede = vec3(0.0);\n    if (abs(pos.x) < WALLGAP) {\n        //no corredor\n        if (dir.x > 0.0) {\n            parede = pos + dir*(WALLGAP - pos.x)/dir.x;\n            #if defined(DEBUG)\n            teste = vec4(0.0,1.0,1.0,1.0)*DEBUG; //colored cyan on debug mode\n            #endif\n        } else {\n            #if defined(DEBUG)\n            teste = vec4(1.0,0.0,0.0,1.0)*DEBUG; //colored red on debug mode\n            #endif\n            parede = pos + dir*(-WALLGAP - pos.x)/dir.x;\n        }\n        parede += dir*(roundAway(parede.z,dir.z) - parede.z)/dir.z;\n    } else if (pos.x > 0.0) {\n        if (dir.x > 0.0 || (dir.x/dir.z < (pos.x - WALLGAP)/modfl(pos.z,WALLDIST) && dir.x/dir.z > (pos.x - WALLGAP)/(modfl(pos.z,WALLDIST) - WALLDIST))) {\n            #if defined(DEBUG)\n            teste = vec4(0.0,1.0,0.0,1.0)*DEBUG; //colored green on debug mode\n            #endif\n            parede = pos + dir*(roundAway(pos.z,dir.z) - pos.z)/dir.z;\n        } else {\n            #if defined(DEBUG)\n            teste = vec4(1.0,0.0,1.0,1.0)*DEBUG; //colored magenta on debug mode\n            #endif\n            parede = pos + dir*(-WALLGAP - pos.x)/dir.x;\n            parede += dir*(roundAway(parede.z,dir.z) - parede.z)/dir.z;\n        }\n    } else {\n        if (dir.x < 0.0 || (dir.x/dir.z > (pos.x + WALLGAP)/modfl(pos.z,WALLDIST) && dir.x/dir.z < (pos.x + WALLGAP)/(modfl(pos.z,WALLDIST) - WALLDIST))) {\n            #if defined(DEBUG)\n            teste = vec4(1.0,1.0,0.0,1.0)*DEBUG; //colored yellow on debug mode\n            #endif\n            parede = pos + dir*(roundAway(pos.z,dir.z) - pos.z)/dir.z;\n        } else {\n            #if defined(DEBUG)\n            teste = vec4(0.0,0.0,1.0,1.0)*DEBUG; //colored blue on debug mode\n            #endif\n            parede = pos + dir*(WALLGAP - pos.x)/dir.x;\n            parede += dir*(roundAway(parede.z,dir.z) - parede.z)/dir.z;\n        }\n    }\n    \n    if (abs(parede.x) > WALLGAP && abs(parede.y) < HALFHEIGHT) { //parede\n        ivec2 pixelPos = ivec2(modfl(parede.x*iChannelResolution[1].x/TEXSCALE1,iChannelResolution[1].x),modfl(parede.y*iChannelResolution[1].y/TEXSCALE1, iChannelResolution[1].y));\n        fragColor = texelFetch(iChannel1, pixelPos, 0);\n        \n    } else if (end.y > 0.0) { // teto\n        ivec2 pixelPos = ivec2(modfl(end.x*iChannelResolution[0].x/TEXSCALE0,iChannelResolution[0].x),modfl(end.z*iChannelResolution[0].y/TEXSCALE0, iChannelResolution[0].y));\n        fragColor = texelFetch(iChannel0, pixelPos, 0);\n    } else { // ch√£o\n        ivec2 pixelPos = ivec2(modfl(end.x*iChannelResolution[2].x/TEXSCALE2,iChannelResolution[2].x),modfl(end.z*iChannelResolution[2].y/TEXSCALE2, iChannelResolution[2].y));\n        fragColor = texelFetch(iChannel2, pixelPos, 0);\n    }\n    \n    #if defined(DEBUG)\n    fragColor = teste + (1.0-teste.w)*fragColor;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592653589793\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define SPEED 5.0\n\nmat3 curRot() {\n    vec2 angle = -PI*vec2(2.0*iMouse.x/iResolution.x - 1.0, iMouse.y/iResolution.y - 0.5);\n    return mat3(\\\n    cos(angle.x),0.0,-sin(angle.x),\\\n        0.0     ,1.0,      0.0    ,\\\n    sin(angle.x),0.0, cos(angle.x) \\\n    );/*mat3(\\\n    cos(angle.y) , sin(angle.y),0.0,\\\n    -sin(angle.y), cos(angle.y),0.0,\\\n        0.0      ,      0.0    ,1.0); */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (fragColor.w == 0.0) {\n        fragColor = vec4(0.0,0.0,1.0e-4,1.0);\n    } else {\n        vec3 mover = iTimeDelta * vec3( \\\n            texelFetch(iChannel1, ivec2(KEY_RIGHT, 0),0).r - texelFetch(iChannel1, ivec2(KEY_LEFT, 0),0).r, \\\n            0.0, \\\n            texelFetch(iChannel1, ivec2(  KEY_UP , 0),0).r - texelFetch(iChannel1, ivec2(KEY_DOWN, 0),0).r  );\n        fragColor += vec4(SPEED*mover*curRot()*1e-3,0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}