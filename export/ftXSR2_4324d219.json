{"ver":"0.1","info":{"id":"ftXSR2","date":"1626021940","viewed":61,"name":"Game explosion","username":"qzole","description":"A simple explosion for a 2d space game","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","explosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nstruct Particle\n{\n    vec3 start;\n    vec3 end;\n    float maxRadius;\n    float lifetime;\n};\n\nstruct GradientCircleData\n{\n    vec2 center;\n    vec2 relativeFocus;\n    float radius;\n    float fillExponent;\n};\n\nfloat gradientCircle(in vec2 p, in GradientCircleData gcd)\n{\n    vec2 focus = gcd.center + gcd.relativeFocus * gcd.radius;\n    vec2 fromFocusToPoint = p - focus;\n    vec2 fromCenterToPoint = p - gcd.center;\n    vec2 toLineDirection = normalize(vec2(-fromFocusToPoint.y, fromFocusToPoint.x));\n    float lineDistance = dot(fromCenterToPoint, toLineDirection);\n    float radiusAtLine = sqrt(gcd.radius*gcd.radius - lineDistance*lineDistance);\n    vec2 zeroOnLine = gcd.center + toLineDirection * lineDistance;\n    vec2 edgeOnLine = zeroOnLine + normalize(fromFocusToPoint) * radiusAtLine;\n\n    float focusRadiusSquared = distanceSquared(edgeOnLine, focus);\n    float relativeDistance = sqrt(distanceSquared(p, focus) / focusRadiusSquared);\n\n    relativeDistance = pow(relativeDistance, gcd.fillExponent);\n    float focusIntensity = smoothstep(1.0, 0.0, relativeDistance);\n    return focusIntensity;\n}\n\nfloat expandingCircle(in vec2 p, in float t, in vec2 center, in float fromRadius, in float toRadius)\n{\n    float radius = mix(fromRadius, toRadius, t);\n    float d = 1.0 - smoothstep(0.98 * radius, radius, distance(p, center));\n    return d;\n}\n\nfloat explosionCircle(in vec2 p, in float t, in vec2 center, in float fromRadius, in float toRadius)\n{\n    if (t > 1.0) return 0.0;\n    float d = expandingCircle(p, pow(t, 0.5), center, fromRadius, toRadius);\n    vec2 offset = (fract(hash22(center)) * 2.0 - 1.0) * 0.1 * toRadius;\n    center += offset;\n    d -= expandingCircle(p, pow(t, 1.25), center, 0.0 * fromRadius, 1.15 * toRadius);\n    d *= smoothstep(0.0, 0.05, t);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= vec2(0.5);\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    float timeSource = iTime * 0.5;\n    float t1 = fract(timeSource) * 3.0;\n    float t2 = fract(timeSource - 0.1) * 2.87;\n    float t3 = fract(timeSource - 0.15) * 2.95;\n\n    vec3 col = vec3(0.0);\n    float alpha = 0.0;\n\n    const int particleCount = 30;\n    Particle particles[particleCount];\n    for (int i = 0; i < particleCount; ++i)\n    {\n        float rBase = float(i) + floor(timeSource) * float(particleCount);\n        float r = hash11(rBase);\n        Particle p = particles[i];\n        p.start = vec3(0.0);\n        p.end = vec3(r, 0.0f, 0.0);\n        r = hash11(r);\n        p.end = vec3((rotate2d(r * 2.0 * PI) * p.end.xy), 0.0);\n        r = hash11(r);\n        p.end = p.end + vec3(0.0, 0.0, r - 0.5);\n        r = hash11(r);\n        p.maxRadius = 0.25;\n        p.lifetime = 0.25;\n        \n        GradientCircleData gcd;\n        vec3 relativeOffset = p.end - p.start;\n        float t = fract(timeSource) / p.lifetime;\n        vec3 pos = p.start + pow(t, 0.75) * relativeOffset;\n        gcd.center = pos.xy;\n        float n1 = -1.0 + pow(t, 0.75) * 2.0;\n        float n2 = pow(n1, 2.0);\n        gcd.radius = max(p.maxRadius - n2 * p.maxRadius, 0.0);\n        gcd.relativeFocus = relativeOffset.xy * 0.5;\n        gcd.fillExponent = max(2.5 - t * 2.0, 0.25);\n        \n        float v = gradientCircle(uv, gcd) * 0.6;\n        \n        alpha = alpha * (1.0 - pow(v, 1.0)) + v;\n    }    \n\n    \n    \n    \n\n    \n    vec2 relativeOffset = vec2(0.2, 0.075);\n    vec2 pos = pow(t1, 0.75) * relativeOffset * 0.75;\n    float maxRadius = 0.3;\n    float n1 = -1.0 + pow(t1, 0.75) * 2.0;\n    float n2 = pow(n1, 2.0);\n    float radius = max(maxRadius - n2 * maxRadius, 0.0);\n    float exponent = max(2.5 - t1 * 2.0, 0.25);\n    //float radius = max(0.5 - pow((t1 - 0.5) * 2.0, 2.0), 0.0);\n    GradientCircleData c1 = GradientCircleData(\n        pos,\n        relativeOffset,\n        radius,\n        exponent\n    );\n    \n    float v1 = gradientCircle(uv, c1);\n    \n    \n    \n    float rad = 0.4 - length(mouse) * 0.45;\n    GradientCircleData c2 = GradientCircleData(\n        mouse,\n        mouse,\n        rad,\n        pow(1.0 / rad * 0.5, 1.5)\n    );\n    float v2 = gradientCircle(uv, c2);\n    \n    ////alpha = v1 * (1.0 - pow(v2, 1.0)) + v2;\n    //alpha = v2;\n    //alpha = v2 * (1.0 - pow(v1, 0.7)) + v1;\n    \n    col = texture(iChannel0, vec2(alpha, 0.5)).xyz;\n    ////col = mix(col, vec3(0.0), min(t1*t1, 1.0));\n    //col = mix(vec3(0.0), col, alpha);\n    //col.a = alpha;\n    //col = vec3(alpha);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat distanceSquared(vec2 a, vec2 b)\n{\n    vec2 c = a - b;\n    return dot(c, c);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat scale(float source, float minV, float maxV)\n{\n    return source * (maxV - minV) + minV;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Segment {\n    float pos;\n    vec3 color;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Segment segments[] = Segment[](\n        Segment(0.0, vec3(0.0, 0.0, 0.0)),\n        Segment(0.001, vec3(0.0, 0.0, 0.0)),\n        Segment(0.005, vec3(0.5, 0.0, 0.0)),\n        Segment(0.4, vec3(0.9, 0.0, 0.0)),\n        Segment(0.5, vec3(1.0, 1.0, 0.0)),\n        Segment(1.0, vec3(1.0, 1.0, 0.9))\n    );\n    vec2 rc = fragCoord / iResolution.xy;\n    int segment = 1;\n    for (; segment < segments.length(); ++segment)\n    {\n        if (rc.x < segments[segment].pos)\n        {\n            break;\n        }\n    }\n    segment -= 1;\n    float segmentSize = segments[segment + 1].pos - segments[segment].pos;\n    float mixValue = (rc.x - segments[segment].pos) / segmentSize;\n    vec3 color = mix(segments[segment].color, segments[segment + 1].color, mixValue);\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}