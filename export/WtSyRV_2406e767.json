{"ver":"0.1","info":{"id":"WtSyRV","date":"1594881981","viewed":70,"name":"A simple ray marching","username":"akanarika","description":"simple ray marching practice\n\n- (learning from https://youtu.be/Ff0jJyyiVyw)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define EPS .001\n#define MAX_DIST 200.\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dSphere(vec3 p, vec4 s) {\n\treturn length(s.xyz - p) - s.w;\n}\n\nfloat dPlane(vec3 p, float y) {\n    return p.y - sin(y);\n}\n\nfloat dCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 h = a + t * (b - a);\n    return length(p - h) - r;\n}\n\nfloat dCube(vec3 p, vec3 q, vec3 size) {\n\treturn length(max(abs(p - q) - size, 0.));\n}\n\nfloat dTorus(vec3 p, vec4 q, float r) {\n\tvec3 pxz = vec3(p.x, q.y, p.z);\n    return length(vec2(length(q.xyz - pxz) - q.w, p.y - q.y)) - r;\n}\n\nfloat dCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ap = p - a;\n    vec3 ab = b - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    vec3 c = a + t * (b - a);\n    vec3 cp = p - c;\n    float d = length(cp) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(d, y), 0.));\n    float i = min(max(d, y), 0.);\n    \n    return e + i;\n}\n\nfloat getDist(vec3 p) {\n    float d = dSphere(p, vec4(-10, 2, -9, 2));\n\td = min(d, dPlane(p, 0.));\n    d = min(d, dCapsule(p, vec3(-2, 1, -9), vec3(2, 1, -12), 1.));\n    d = min(d, dCube(p, vec3(10, 2, -10), vec3(2, 1, 3)));\n    d = min(d, dTorus(p, vec4(-5, .8, -3, 2), .8));\n    d = min(d, dCylinder(p, vec3(2, 1, -4), vec3(5, 1, -1), 1.));\n    return d;\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n\tfloat t = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * t;\n        float tt = getDist(p);\n        t += tt;\n        if (tt < EPS || tt > MAX_DIST) break;\n    }\n    return t;\n}\n\nvec3 getNormal(in vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(EPS, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat getLight(in vec3 p) {\n\tvec3 light = vec3(0, 10, -4);\n    light.xz += 5. * vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(light - p);\n    vec3 n = getNormal(p);\n    float dif = clamp(dot(l, n), 0., 1.);\n    if (rayMarch(p + EPS * 2. * n, l) < length(light - p)) return dif * .2;\n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y / 2.;\n\n    vec3 ro = vec3(0, 8, 10);\n    vec3 rd = normalize(vec3(uv.x, uv.y - .5, -1.));\n    \n    float t = rayMarch(ro, rd);\n    \n    vec4 col = vec4(getLight(ro + t * rd)) * vec4(.2, .6, .4, 1.);\n    fragColor = sqrt(col);\n}","name":"Image","description":"","type":"image"}]}