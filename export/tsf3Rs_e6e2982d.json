{"ver":"0.1","info":{"id":"tsf3Rs","date":"1547179595","viewed":207,"name":"limbs 2","username":"mds2","description":"modification of https://www.shadertoy.com/view/wssGRX with slightly better smoothed edges, and fewer limbs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","animation","tree","subsurface","skin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_DIST 4.0\n\n\n mat3 mat_a = mat3(0.8, 0.6, 0.0,\n                        -0.6, 0.8, 0.0,\n                        0.0, 0.0, 1.0) * mat3(0.96, 0.0, 0.28, 0.0, 1.0, 0.0, -0.28, 0.0, 0.96);\n\n mat3 mat_b = mat3(0.96, 0.0, -0.28, 0.0, 1.0, 0.0, 0.28, 0.0, 0.96) *\n    mat3(0.6, -0.8, 0.0,\n         0.8, 0.6, 0.0,\n         0.0, 0.0, 1.0);\n\n mat3 mat_c = mat3(0.8, 0.0, -0.6, 0.0, 1.0, 0.0, 0.6, 0.0, 0.8) *\n    mat3(1.0, 0.0, 0.0,\n         0.0, 0.96, -0.28,\n         0.0, 0.28, 0.96);\n\nconst float cutoff = 0.81; // ad-hoc, should be much larger\n\nfloat pill(in vec3 pt, in float l, in float r) {\n    vec3 to_core = abs(pt - vec3(0.0, 0.5 * l, 0.0));\n    to_core.y -= 0.5 * l;\n    to_core = max(vec3(0.0), to_core);\n    return length(to_core) - 2.0 * r;\n}\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nfloat sdf_3(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025);\n    return d;\n}\n\n\nfloat sdf_2(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025);\n    // d = s_min(d, 0.8 * sdf_3(1.25 * mat_a * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_3(1.25 * mat_b * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_3(1.25 * mat_c * (pt - off)), 0.025);\n    return d;\n}\n\nfloat sdf_1(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025);\n    d = s_min(d, 0.8 * sdf_2(1.25 * mat_a * (pt - off)), 0.025);\n    // d = s_min(d, 0.8 * sdf_2(1.25 * mat_b * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_2(1.25 * mat_c * (pt - off)), 0.025);\n    return d;\n}\n\nfloat sdf(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025); // temporary sdf\n    d = s_min(d, 0.8 * sdf_1(1.25 * mat_a * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_1(1.25 * mat_b * (pt - off)), 0.025);\n    // d = s_min(d, 0.8 * sdf_1(1.25 * mat_c * (pt - off)), 0.025);\n    return d;\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return h_inv *\n        vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             sdf(pt + vec3(0.0, h, 0.0)) - f,\n             sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat raymarch(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    for(int i = 0; i < 128; ++i) {\n        if (accum > MAX_DIST || s < 1.0e-3) {\n            return accum;\n        }\n        accum += 0.75 * s;\n        p = pt + accum * d;\n        s = sdf(p);\n    }\n    if (s > 1.0e-3) {\n        return MAX_DIST + 1.0;\n    }\n    return accum;\n}\n\nfloat raymarch_out(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    for(int i = 0; i < 2; ++i) {\n        if (accum > 1.0e-3 && s > -1.0e-3) {\n            return accum;\n        }\n        accum += 0.75 * max(abs(s), 1.0e-3);\n        p = pt + accum * d;\n        s = sdf(p);\n    }\n    if (s < -1.0e-3) {\n        return 1000.0;\n    }\n    return accum;\n}\n\nfloat ramp(in float a, in float b, in float x) {\n    float p = (x-a)/(b-a);\n    return clamp(p, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 6.0));\n    \n    vec3 orig = vec3(0.0, 0.25, -2.5);\n    \n    float theta = 0.1 * iTime;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    mat3 spin = mat3(ct, 0.0, st,\n                     0.0, 1.0, 0.0,\n                     -st, 0.0, ct);\n    \n    theta = 0.25 * sin(iTime);\n    vec2 trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n    mat_a =\n\t    mat3(ct, st, 0.0,\n                        -st, ct, 0.0,\n                        0.0, 0.0, 1.0) * mat3(0.96, 0.0, 0.28, 0.0, 1.0, 0.0, -0.28, 0.0, 0.96);\n\ttheta = 0.25 * sin(1.21 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.6 * trigs.x - 0.8 * trigs.y;\n    st = 0.8 * trigs.x + 0.6 * trigs.y;\n    \n    mat_b = \n        mat3(0.96, 0.0, -0.28, 0.0, 1.0, 0.0, 0.28, 0.0, 0.96) *\n    mat3(ct, -st, 0.0,\n         st, ct, 0.0,\n         0.0, 0.0, 1.0);\n    \n    theta = 0.25 * sin(0.93 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n    \n    mat_c = mat3(ct, 0.0, -st, 0.0, 1.0, 0.0, st, 0.0, ct) *\n    mat3(1.0, 0.0, 0.0,\n         0.0, 0.96, -0.28,\n         0.0, 0.28, 0.96);\n    orig = spin * orig;\n    dir = spin * dir;\n    \n    float dist = raymarch(orig, dir);\n    \n    float bright = 0.0;\n    \n    vec3 refl_color = vec3(1.0);\n    vec3 trans_color = vec3(1.0, 0.5, 0.4);\n    const vec3 light_dir = vec3(1.0, 0.0, 0.0);\n    float thru_dist = 1000.0;\n    vec3 n = dir;\n    if (dist < MAX_DIST) {\n        n = normalize(sdf_grad(orig + dir * dist));\n//        float inc \n        // bright = smoothstep(0.0, 0.2, abs(dot(dir, n)));\n        float dist_out = raymarch_out(orig + dir * (dist + 1.0e-2), dir);\n        bright = ramp(0.0, 1.0 / iResolution.y, dist_out);\n        dir = mix(dir, normalize(reflect(dir, n)), bright);\n        thru_dist = raymarch_out(orig + dir * (dist + 1.0e-2), light_dir);\n        refl_color = vec3(0.8, 0.7, 0.6);\n    }\n\n    vec3 col = (0.5 + 0.5 * bright) *\n        (0.2 * smoothstep(0.7, 1.0, dot(dir, light_dir)) + 0.7 * smoothstep(0.1, 1.0,\n                                                                      dot(n, light_dir)))*\n        refl_color;\n    \n    col += bright * (1.0 / max(abs(1.0 * thru_dist), 0.5)) * trans_color;\n\n    // Output to screen\n    fragColor =  vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}