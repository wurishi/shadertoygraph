{"ver":"0.1","info":{"id":"ftXyRf","date":"1648490624","viewed":47,"name":"Assignment_try","username":"mkwhimpi","description":"asd","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["as"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2.5*texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Credit for https://learnopengl.com/Lighting/Materials\nconst int spheresNo = 2;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\nconst int triangleNo = 1;\nTriangle triangles[triangleNo];\nconst vec4 notex=vec4(0.,0.,0.,0.);\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,0.3,1.5);\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax,s.mat,notex); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t,s.mat,s.tex);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t,plane.mat,plane.tex);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle)\n{\n\n    float denom= dot(cross(ray.v,triangle.c-triangle.a),triangle.b-triangle.a);\n    float t= 1./denom*dot(cross(ray.p0-triangle.a,triangle.b-triangle.a),triangle.c-triangle.a);\n    float u =1./denom*dot(cross(ray.v,triangle.c-triangle.a),ray.p0-triangle.a);\n    float v =1./denom*dot(cross(ray.p0-triangle.a,triangle.b-triangle.a),ray.v);\n    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 )\n    {\n        return TraceResult(vec3(0),ray.tmax,triangle.mat,triangle.tex);\n    }\n    else\n    {\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = cross(triangle.b - triangle.a,triangle.b-triangle.c);\n    if(dot(normalize(normal),ray.v) > 0.0001) normal = -normal;\n    return TraceResult(normal, t,triangle.mat,triangle.tex);\n    }\n   \n   \n\n\n}\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax,colors[1],notex);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < triangleNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n\n\n\n\n\nvec4 hitColor(Ray ray, TraceResult tr,PointLight light)\n{\n      //point on surface  \n    vec3 p = ray.p0 + ray.v*tr.t;\n    //normal vector of surface\n    vec3 n = tr.n;\n   \n    //from point to light //viewDir?\n    vec3 l = light.position-p;\n    float lightDist = length(l);\n    l /= lightDist; // normalized direction to the light\n    l=normalize(l);\n    Ray shadowray = Ray(p+0.001*n, 0.001, l, lightDist);\n                      /*     p0  , tmin , v,    tmax  */\n                      \n    TraceResult res = raycast(shadowray);\n    //-------\n\n    vec3 col= vec3(0.,0.,0.);\n\n        //sum\n        //col = (ambient+diffuse+specular);\n        //if(tr.tex != vec4(0.,0.,0.,0.)) return vec4(tr.tex); // to check if different then original texture\n\n\n    if(res.t==shadowray.tmax)\n    {\n       \n        vec3 v = -ray.v;\n        vec3 outp = brdf(n,l,v,tr.mat);\n        return vec4(outp,1.);\n        // vec3 outp = brdf(n,l,v,tr.mat);\n       \n\n        //sum\n        //col = (ambient+diffuse+specular);\n        //if(tr.tex != vec4(0.,0.,0.,0.)) return vec4(tr.tex); // to check if different then original texture\n        //return vec4(outp,1.);\n\n  \n\n    }\n    else return vec4(0.,0.,0.,1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Creating Light\n    PointLight l1;\n\n    l1.position=vec3(35.,15.,10.);   \n\n    \n    //-------------\n     vec2 uv = fragCoord.xy / iResolution.xy;\n     vec4 tex1 = texture(iChannel3,uv);\n\n    // Description of 2 spheres\n    spheres[0] = Sphere(vec3(5.f*sin(iTime*3.f)-8.,0, 2), 1.f,colors[1],notex);\n    spheres[1] = Sphere(vec3(10,2,5), 0.5f,colors[0],notex);\n    //planes\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)),colors[1],notex);\n    //triangles\n    triangles[0] = Triangle(vec3(0.0,0.0,-1.0),vec3(0.,0.,0.2),vec3(0.,1.,0.), colors[2],notex);\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n       \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result,l1);\n        \n\n\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Material {\n    vec3  color;        // [0, 1/pi]    reflective color\n    float roughness;    // [0, 7]       shininess\n    vec3 emission;\t\t// [0, inf]     light emitting surface if nonzero\n    float metalness; // [0.02, 0.05] for non-metals, [0.6, 0.9] for metals\n\n};\n// Materials\n#define LIGHTSRC(r,g,b)   Material(vec3(0,0,0)   , 1.     , vec3(r,g,b), 0. )\n#define METALLIC(r,g,b,m) Material(vec3(r,g,b)/pi,float(m), vec3(0,0,0), 0.9 )\n#define NONMETAL(r,g,b,m) Material(vec3(r,g,b)/pi,float(m), vec3(0,0,0), 0.02)\n#define TEXTURED(r,g,b,m) Material(vec3(r,g,b)/pi,float(m), vec3(0,0,0), 0.02)\n\nconst Material colors[] = Material[](\n    METALLIC(.1,.4,.1,0.03),\n    NONMETAL(.25,.1,1,.11),\n    NONMETAL(.1,1,.5,0.1),\n    LIGHTSRC(80,80,80)\n\n);\n\n\nstruct PointLight {\n    vec3 position;\n\n};\n\nuniform PointLight light;  \n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    Material mat;\n    vec4 tex;\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;    // normal\n    Material mat ;\n    vec4 tex;\n\n    \n};\nstruct Triangle{\n\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    Material mat;\n    vec4 tex;\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    Material mat;\n    vec4 tex;\n\n\n};\n\nvec3 brdf(vec3 n, vec3 l, vec3 v, in Material mat) {\n    vec3 F0 = mat.color*mat.metalness;\n    vec3  h = normalize(l + v);\n    //CookTorrenceGeometry\n    float hn = max(dot(h, n), 0.0), vn = max(dot(v, n), 0.01);\n\tfloat ln = max(dot(l, n), 0.01), vh = max(dot(v, h), 0.0);\n    float G = min( 2.*hn*min( vn, ln)/vh, 1.0 );\n    //GGXDistribution\n    float hn2 = hn*hn, m2 = mat.roughness*mat.roughness;\n    float tmp = hn2*(m2-1.)+1.;\n    float D =  m2/(pi*tmp*tmp);\n    //SclickFresnel\n    vec3 F = F0 - (1.-F0)*pow(1.-hn,5.);\n\tvec3 specular  = D*F*G / (4. * vn * ln);\n\t// Lambertian BRDF\n    vec3 diffuse = (1.-mat.metalness) * mat.color * (1. - F)/pi;\n\treturn max(specular + diffuse,0.);\n}\n\n\n//struct Value {float d; int mat;}; // 'SDF' now returns a distance and a material id to the closest object.\n\n","name":"Common","description":"","type":"common"}]}