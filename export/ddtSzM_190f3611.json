{"ver":"0.1","info":{"id":"ddtSzM","date":"1679594449","viewed":111,"name":"Raycast Pseudo 3D","username":"Famousghost","description":"Raycast3D in shader without textures and with low resolution and without collisions.\nMovement \"WSAD\"","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raycastdepthsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IS_3D_VIEW 1\n\nRectangle rect[8];\n\nRectangle creatRect(vec2 pos, vec2 size)\n{\n    Rectangle rect;\n    rect.position = pos;\n    rect.size = size;\n    return rect;\n}\n\nfloat sdRect(vec2 uv, vec2 size, vec2 pos)\n{\n    vec2 p = abs(vec2(uv.x - pos.x, uv.y - pos.y));\n    \n    return length(max(p - size, 0.0f));\n}\n\nfloat normalization(float value, float minValue, float maxValue)\n{\n    return (value - minValue) / (maxValue - minValue);\n}\n\nfloat remap(float value, float prevMin, float prevMax, float nextMin, float nextMax)\n{\n    float t = normalization(value, prevMin, prevMax);\n    return mix(nextMin, nextMax, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n    \n    vec2 mousePos = (iMouse.xy - 0.5f * iResolution.xy) / iResolution.y;\n    \n    vec4 posAndDir = texture(iChannel1, vec2(0.0f));\n   \n    rect[0] = creatRect(vec2(0.5f, 0.0f), vec2(0.1f, 0.5f));\n    rect[1] = creatRect(vec2(-0.5f, 0.0f), vec2(0.1f, 0.5f));\n    rect[2] = creatRect(vec2(0.3f, 0.2f), vec2(0.3f, 0.1f));\n    rect[3] = creatRect(vec2(0.0f, -0.3f), vec2(0.1f, 0.3f));\n    \n    rect[4] = creatRect(vec2(0.0f, 0.95f), vec2(2.0f, 1.0f));\n    rect[5] = creatRect(vec2(1.0f, 0.0f), vec2(0.3f, 2.0f));\n    \n    rect[6] = creatRect(vec2(0.0f, -0.95f), vec2(2.0f, 1.0f));\n    rect[7] = creatRect(vec2(-1.0f, 0.0f), vec2(0.3f, 2.0f));\n    \n    vec3 col = vec3(0.0f);\n    vec2 dir = normalize(uv - posAndDir.xy);\n    float screenDist = tan(radians(FOV * 0.5f)) / (iResolution.x * 0.5f);\n\n    for(int i = 0; i <= int(FOV); ++i)\n    {\n        Ray ray;\n        vec4 oneRay = texture(iChannel0, vec2(float(i), 0.0f) / iResolution.xy);\n        ray.origin = oneRay.xy;\n        #if IS_3D_VIEW\n        ray.direction = oneRay.zw / (dot(oneRay.zw, posAndDir.zw) + 0.0001f);\n        #else\n        ray.direction = oneRay.zw;\n        #endif\n        \n        float dist = 1.0f;\n        float minDist = 1000000.0f;\n        float displayRect = 1.0f;\n        float depth = 1.0f;\n        for(int j =0; j < 8; ++j)\n        {\n            vec2 t = raycastRect(ray, rect[j]);\n\n            if(t.x > 0.0f)\n            {\n                if(minDist > t.x)\n                {\n                    minDist = t.x;\n                    dist = step(length(uv - ray.origin), t.x);\n                }\n                float height = screenDist * WALL_HEIGHT / (minDist + 0.001f);\n                depth = remap(minDist, 0.0f, 1.0f, 1.0f, 0.0f);\n                displayRect = sdRect(uv, vec2(1.0f / FOV, height), vec2(remap(float(i), 0.0f, FOV, FOV, -FOV) / FOV, 0.0f));\n            }\n                \n\n         }\n         #if IS_3D_VIEW\n         if(displayRect == 0.0f)\n         {\n             col = vec3(depth);\n         }\n         #else\n         col += vec3(1.0f) * step(0.999999f, dot(dir, ray.direction)) * dist;\n         #endif\n\n    }\n\n   \n \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\n\nvec4 updateMovement()\n{\n    float wKey = texelFetch(iChannel0, ivec2(KEY_W, 0), 0).r;\n    float sKey = -texelFetch(iChannel0, ivec2(KEY_S, 0), 0).r;\n    float aKey = texelFetch(iChannel0, ivec2(KEY_A, 0), 0).r;\n    float dKey = -texelFetch(iChannel0, ivec2(KEY_D, 0), 0).r;\n    \n    return vec4(wKey, sKey, aKey, dKey);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(fragCoord.x <= 1.0f && fragCoord.y <= 1.0f)\n    {\n        if(iFrame == 0)\n        {\n            fragColor = vec4(0.0f, 0.0f, 1.0f, 0.0f);\n            return;\n        }\n        vec4 movement = updateMovement();\n        vec4 prevMovement = texture(iChannel1, vec2(0.0f));\n        vec2 dir = normalize(rotate(prevMovement.zw, (movement.b + movement.a) * ROTATION_SPEED * iTimeDelta));\n        vec2 pos = prevMovement.xy + (movement.x + movement.y) * dir * MOVEMENT_SPEED * iTimeDelta;\n        fragColor = vec4(vec2(clamp(pos.x, -0.8f, 0.8f), clamp(pos.y, -0.4f, 0.4f)), dir);\n    }\n    else\n    {\n        fragColor = vec4(0.0f);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define FOV 60.0\n#define ROTATION_SPEED 150.0\n#define MOVEMENT_SPEED 0.3\n#define WALL_HEIGHT 100.0\n\nvec2 rotate(vec2 pos, float angle)\n{\n    float ang = radians(angle);\n    return vec2(cos(ang) * pos.x - sin(ang) * pos.y, sin(ang) * pos.x + cos(ang) * pos.y);\n}\n\nstruct Ray\n{\n    vec2 origin;\n    vec2 direction;\n};\n\nstruct Corners\n{\n    vec2 minValue;\n    vec2 maxValue;\n};\n\nstruct Rectangle\n{\n    vec2 position;\n    vec2 size;\n    \n};\n\nCorners getMaxMinCornersValuesFromRectangle(Rectangle rect)\n{\n    Corners result;\n    result.minValue = rect.position - rect.size * 0.5f;\n    result.maxValue = rect.position + rect.size * 0.5f;\n    \n    return result;\n}\n\nvec2 raycastRect(Ray ray, Rectangle rect)\n{\n    Corners corners = getMaxMinCornersValuesFromRectangle(rect);\n    \n    float txMax = (corners.maxValue.x - ray.origin.x) / (ray.direction.x + 0.0000001f);\n    float tyMax = (corners.maxValue.y - ray.origin.y) / (ray.direction.y + 0.0000001f);\n    \n    float txMin = (corners.minValue.x - ray.origin.x) / (ray.direction.x + 0.0000001f);\n    float tyMin = (corners.minValue.y - ray.origin.y) / (ray.direction.y + 0.0000001f);\n    \n    float maxX = max(txMax, txMin);\n    float maxY = max(tyMax, tyMin);\n    \n    float minX = min(txMax, txMin);\n    float minY = min(tyMax, tyMin);\n    \n    float minMax = min(maxX, maxY);\n    float maxMin = max(minX, minY);\n    \n    if(maxMin < 0.0f)\n    {\n        return vec2(minMax);\n    }\n    \n    if(minMax < 0.0f)\n    {\n        return vec2(-1.0f);\n    }\n    \n    if(minMax < maxMin)\n    {\n        return vec2(-1.0f);\n    }\n    \n    return vec2(maxMin, minMax);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nRay createRay(vec2 origin, vec2 direction, int index)\n{\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = rotate(direction, float(index) * 0.5f);\n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x <= floor(FOV))\n    {\n        vec4 player = texture(iChannel0, vec2(0.0f));\n        Ray ray = createRay(player.xy, player.zw, int(2.0f * fragCoord.x - FOV));\n        fragColor = vec4(ray.origin, ray.direction);\n    }\n    else\n    {\n        fragColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}