{"ver":"0.1","info":{"id":"4fdcR7","date":"1730447836","viewed":51,"name":"Random Dot Spawner v1","username":"8InfinityTaco8","description":"This spawns random dots within a bounding sdf. \n\nmade some improvements based on advice given to me by: FabriceNeyret2\nas well as some other improvments \n\nI used a variant of this in my particle sim shader here: https://www.shadertoy.com/view/lfdcz7","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","particles","hash","bound"],"hasliked":0,"parentid":"XfdcR7","parentname":"Random Dot Spawner v0"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Random function\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// Utility functions\nfloat dot2(vec2 p) { return dot(p, p); }\n\nfloat vectorLength(vec2 p) {\n    return sqrt(dot(p, p));\n}\n\n// SDF Shapes Collection by: iq\nfloat triangleSDF(vec2 p, float size) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - size;\n    p.y = p.y + size/k;\n    if(p.x + k*p.y > 0.0) p = vec2(p.x-k*p.y, -k*p.x-p.y)/2.0;\n    p.x -= clamp(p.x, -2.0*size, 0.0);\n    return -vectorLength(p)*sign(p.y);\n}\n\nfloat sdEquilateralTriangle(in vec2 p, in float r) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x+k*p.y>0.0) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp(p.x, -2.0*r, 0.0);\n    return -length(p)*sign(p.y);\n}\n\nfloat sdHeart(in vec2 p) {\n    p = p * 1.5; \n    p.y = p.y + 0.4;\n    p.x = abs(p.x);\n    \n    if(p.y+p.x>1.0)\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat roundedBoxSDF(vec2 p, vec2 size, float radius) {\n    // Scale the space to make the box slightly larger\n    p = p * 0.9;\n    vec2 d = abs(p) - size + radius;\n    return (vectorLength(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius) * 1.1; // Multiply by 1.1 to make the boundary slightly more strict\n}\n\nfloat pillSDF(vec2 p, float len, float radius) {\n    p = p * 0.8;\n    p.y = abs(p.y);\n    float d = len - radius * 2.0;\n    vec2 q = p - vec2(0.0, d * 0.5);\n    return vectorLength(q) - radius;\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    p = p * 0.8;\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp(dot(p,ba)/dot(ba,ba), 0.0, r);\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// Function to get current SDF based on time\nfloat getCurrentSDF(vec2 p, float time) {\n    float cycleTime = 3.0;\n    int shape = int(mod(time / cycleTime, 6.0));\n    \n    vec2 adjustedP = p * 2.0;\n    \n    switch(shape) {\n        case 0:\n            return sdHeart(p) * 0.5;\n        case 1:\n            return sdEquilateralTriangle(adjustedP, 0.6);\n        case 2:\n            return roundedBoxSDF(adjustedP, vec2(0.3, 0.4), 0.1);\n        case 3:\n            return pillSDF(adjustedP, 0.7, 0.2);\n        case 4:\n            return sdStar5(adjustedP, 0.4, 0.6);\n        case 5:\n            return triangleSDF(adjustedP, 0.6);\n        default:\n            return 0.0;\n    }\n}\n\n// Constants for dot customization\n#define DOT_SPACING 100.0\n#define DOT_SIZE 0.02\n#define SPAWN_MAX vec2(0.5, 0.5)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 cell = floor(uv * DOT_SPACING);\n    vec2 cell_uv = (cell + 0.5) / DOT_SPACING;\n    \n    float sdf = getCurrentSDF(cell_uv, iTime);\n    \n    // Add a small threshold to make the spawn check more strict\n    float threshold = -0.001; // Small negative threshold\n    vec2 d = step(abs(cell_uv), SPAWN_MAX);\n    bool validSpawnPoint = d.x > 0.0 && d.y > 0.0 && sdf < threshold;\n    \n    float dist = vectorLength(uv - cell_uv);\n    float rnd = random(cell + floor(iTime / 3.0));\n    float dot_visible = (rnd > 0.5 && validSpawnPoint) ? 1.0 : 0.0;\n    float dot = dot_visible * smoothstep(1.5/iResolution.y, 0.0, dist - DOT_SIZE / DOT_SPACING);\n    float shape = smoothstep(1.5/iResolution.y, 0.0, -sdf) * 0.2;\n    float transition = smoothstep(0.0, 0.2, mod(iTime, 3.0));\n    \n    fragColor = vec4(vec3(dot + shape) * transition, 1.0);\n}","name":"Image","description":"","type":"image"}]}