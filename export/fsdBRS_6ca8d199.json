{"ver":"0.1","info":{"id":"fsdBRS","date":"1686899868","viewed":72,"name":"Proline Molecule","username":"TheTUFGuy","description":"mandelbrot explorer","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["chemistry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//General Instruction: Just focus on Set functions :) \n#define MAX_STEPS 1000\n#define MAX_DIST 200.0\n#define SURF_DIST 0.05\n#define MAX_OBJECTS 100\n#define carbon vec4(0.5,0.5,0.5,1.);\n#define nitrogen vec4(0.0,0.0,1.0,1.);\n#define oxygen vec4(1.0,0.1,0.1,1.);\n#define hydrogen vec4(1.0,1.0,1.0,1.);\n#define bond1 vec4(1.0,1.0,0.6,1.);\n#define bond2 vec4(0.0,0.9,0.9,1.);\n//comment out below line to get ball+stick\n//#define BALLSTICK 0\n#ifdef BALLSTICK\n#define csize 0.9\n#define nsize 1.2\n#define hsize 0.3\n#define osize 1.2\n#define bsize 0.0001\n#else\n#define csize 0.3\n#define nsize 0.35\n#define hsize 0.1\n#define osize 0.4\n#define bsize 0.07\n\n#endif\n\n\nfloat createMandelBulb(int dimensions, int limit, int maxiterations, vec3 p)\n{\n    return 0.0;\n}\n\n\nfloat createSphere(vec3 pos, float r, vec3 p)//takes in centre and radius\n{\n    return length(p-pos)-r;\n}\nfloat createCapsule(vec3 a, vec3 b, float r,vec3 p)//takes in two endpoints and radius\n{\n   vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r; \n}\nfloat createTorus(vec3 pos, float r, float t, vec3 p)//takes in centre, radius and thickness\n{\n    p-=pos;\n    float x = length(p.xz)-r;\n    return length(vec2(x,p.y))-t;\n}\nfloat createBox(vec3 origin, vec3 dim, vec3 p)//takes in centre and dimensions (no rotation implemented yet)\n{\n    p-=origin;\n    \n    vec3 q = abs(p) - dim;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvoid SetObjects(out int n,out float objects[MAX_OBJECTS],vec3 p)\n{\n    n=34; //number of objects(not more than 99 please!)\n    //update number of objects above and add the objects in the lines below using functions shown above\n    objects[0]=createSphere(vec3(2.1617,-0.9509,-0.1119+6.),osize,p);\n    objects[1]=createSphere(vec3(1.5688,1.2164,-0.4953+6.),osize,p);\n    objects[2]=createSphere(vec3(-0.7807,0.9314,0.770+6.),nsize,p);\n    objects[3]=createSphere(vec3(0.0834,-0.2476,0.7251+6.),csize,p);\n    objects[4]=createSphere(vec3(-0.7235,-1.3171,-0.0031+6.),csize,p);\n    objects[5]=createSphere(vec3(-1.9888,-0.6106,-0.4752+6.),csize,p);\n    objects[6]=createSphere(vec3(-1.6499, 0.8635,-0.3933+6.),csize,p);\n    objects[7]=createSphere(vec3( 1.3289, 0.1149,-0.0235+6.),csize,p);\n    objects[8]=createSphere(vec3( 0.3625,-0.5522, 1.7389+6.),hsize,p);\n    objects[9]=createSphere(vec3(-0.9873,-2.1429, 0.6671+6.),hsize,p);\n    objects[10]=createSphere(vec3(-0.1919,-1.7411,-0.8624+6.),hsize,p);\n    objects[11]=createSphere(vec3(-2.2798,-0.9157,-1.4848+6.),hsize,p);\n    objects[12]=createSphere(vec3(-2.8187,-0.8485, 0.2018+6.),hsize,p);\n    objects[13]=createSphere(vec3(-1.1204, 1.1932,-1.2945+6.),hsize,p);\n    objects[14]=createSphere(vec3(-2.5424, 1.4831,-0.2694+6.),hsize,p);\n    objects[15]=createSphere(vec3(-0.2509, 1.8003, 0.8023+6.),hsize,p);\n    objects[16]=createSphere(vec3( 2.9837,-0.7341,-0.6014+6.),hsize,p);\n    objects[17]=createCapsule(vec3(2.1617,-0.9509,-0.1119+6.),vec3(1.3289, 0.1149,-0.0235+6.),bsize,p);\n    objects[18]=createCapsule(vec3(2.1617,-0.9509,-0.1119+6.),vec3(2.9837,-0.7341,-0.6014+6.),bsize,p);\n    objects[19]=createCapsule(vec3(1.5688,1.2164,-0.4953+6.),vec3(1.3289, 0.1149,-0.0235+6.),bsize,p);\n    objects[20]=createCapsule(vec3(-0.7807,0.9314,0.770+6.),vec3(0.0834,-0.2476,0.7251+6.),bsize,p);\n    objects[21]=createCapsule(vec3(-0.7807,0.9314,0.770+6.),vec3(-1.6499, 0.8635,-0.3933+6.),bsize,p);\n    objects[22]=createCapsule(vec3(-0.7807,0.9314,0.770+6.),vec3(-0.2509, 1.8003, 0.8023+6.),bsize,p);\n    objects[23]=createCapsule(vec3(0.0834,-0.2476,0.7251+6.),vec3(-0.7235,-1.3171,-0.0031+6.),bsize,p);\n    objects[24]=createCapsule(vec3(0.0834,-0.2476,0.7251+6.),vec3(1.3289, 0.1149,-0.0235+6.),bsize,p);\n    objects[25]=createCapsule(vec3(0.0834,-0.2476,0.7251+6.),vec3(0.3625,-0.5522, 1.7389+6.),bsize,p);\n    objects[26]=createCapsule(vec3(-0.7235,-1.3171,-0.0031+6.),vec3(-1.9888,-0.6106,-0.4752+6.),bsize,p);\n    objects[27]=createCapsule(vec3(-0.7235,-1.3171,-0.0031+6.),vec3(-0.9873,-2.1429, 0.6671+6.),bsize,p);\n    objects[28]=createCapsule(vec3(-0.7235,-1.3171,-0.0031+6.),vec3(-0.1919,-1.7411,-0.8624+6.),bsize,p);\n    objects[29]=createCapsule(vec3(-1.9888,-0.6106,-0.4752+6.),vec3(-1.6499, 0.8635,-0.3933+6.),bsize,p);\n    objects[30]=createCapsule(vec3(-1.9888,-0.6106,-0.4752+6.),vec3(-2.2798,-0.9157,-1.4848+6.),bsize,p);\n    objects[31]=createCapsule(vec3(-1.9888,-0.6106,-0.4752+6.),vec3(-2.8187,-0.8485, 0.2018+6.),bsize,p);\n    objects[32]=createCapsule(vec3(-1.6499, 0.8635,-0.3933+6.),vec3(-1.1204, 1.1932,-1.2945+6.),bsize,p);\n    objects[33]=createCapsule(vec3(-1.6499, 0.8635,-0.3933+6.),vec3(-2.5424, 1.4831,-0.2694+6.),bsize,p);\n\n}\nvoid SetMat(out vec4[MAX_OBJECTS] mat,int n)\n{\n    //set material for each object as specified above\n    mat[0]=oxygen;\n    mat[1]=oxygen;\n    mat[2]=nitrogen;\n    mat[3]=carbon;\n    mat[4]=carbon;\n    mat[5]=carbon;\n    mat[6]=carbon;\n    mat[7]=carbon;\n    mat[8]=hydrogen;\n    mat[9]=hydrogen;\n    mat[10]=hydrogen;\n    mat[11]=hydrogen;\n    mat[12]=hydrogen;\n    mat[13]=hydrogen;\n    mat[14]=hydrogen;\n    mat[15]=hydrogen;\n    mat[16]=hydrogen;\n    mat[17]=bond1;\n    mat[18]=bond1;\n    mat[19]=bond2;\n    mat[20]=bond1;\n    mat[21]=bond1;\n    mat[22]=bond1;\n    mat[23]=bond1;\n    mat[24]=bond1;\n    mat[25]=bond1;\n    mat[26]=bond1;\n    mat[27]=bond1;\n    mat[28]=bond1;\n    mat[29]=bond1;\n    mat[30]=bond1;\n    mat[31]=bond1;\n    mat[32]=bond1;\n    mat[33]=bond1;\n    \n    //Don not touch\n    mat[n]=vec4(0.);\n}\nvoid SetCamera(out vec3 ro, out vec3 rd, vec2 uv)\n{\n    //Camera Position\n    ro =vec3(20.*sin(3.*iTime),0,6.+20.*cos(3.*iTime));\n    //Point at which the camera looks\n    vec3 lookAt = vec3(0,1,6);\n    //Zoom of camera (in terms of dist b/w screen and camera\n    float zoom =1.;\n    \n    \n    //Do not touch (unless you know what you are doing ofc :p)\n    vec3 f = normalize(lookAt-ro);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,r));\n    vec3 c = ro+f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    rd = i-ro;\n}\nvoid SetLight(out vec3 lightPos, out vec4 col, out float diff, out float ambF, out float specF)\n{\n    //Light Position\n    lightPos = vec3(4,10,9.0);\n    //Light Color\n    col =vec4(1.,1.,1.,1.);\n    //Diffusion Factor\n    diff = .5;\n    //Ambience Factor\n    ambF = 0.3;\n    //Specular Factor\n    specF = 0.7;\n    \n}\n\n\n\n\n\n//DO NOT TOUCH\nfloat GetDist(vec3 p)  //of objects from point p\n{\n    float objects[MAX_OBJECTS];\n    int n;\n    SetObjects(n,objects,p);\n    float d = MAX_DIST*1000.;\n    for(int i=0;i<n;i++)\n    {\n        d=min(d,objects[i]);\n    }\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.0;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p =ro+rd*dO;\n        float dS = GetDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST||dS<SURF_DIST) break;\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.001,0);\n    vec3 n = d-vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx));\n    return normalize(n);\n}\nvec4 GetLight(vec3 p, vec3 rd)\n{\n    \n    vec3 lightPos; vec4 col; float diffF,ambF,specF;\n    SetLight(lightPos,col,diffF,ambF,specF);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float diff = clamp(dot(n,l),0.,1.)*diffF;\n    //Shadow Calc\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) diff *= .1;\n    \n    vec3 v = normalize(rd*-1.);\n    vec3 r = reflect(-1.*l,n);\n    specF *= pow(max(dot(v,r),0.0),64.);\n    \n    return (specF+ambF+diff)*col;\n}\nvec4 GetMat(vec3 p)\n{\n    float objects[MAX_OBJECTS];\n    int n;\n    SetObjects(n,objects,p);\n    float d = MAX_DIST*1000.;\n    for(int i=0;i<n;i++)\n    {\n        d=min(d,objects[i]);\n    }\n    int i;\n    for(i=0;i<n;i++)\n    {\n        if(d==objects[i])\n        break;\n    }\n    vec4 mat[MAX_OBJECTS];\n    SetMat(mat,n);\n    return mat[i];\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro,rd;\n    SetCamera(ro,rd,uv);\n    float d = RayMarch(ro,rd);\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro+rd*d;\n        vec4 light = GetLight(p,rd);\n        vec4 material  = GetMat(p);\n        vec4 result = material*light;\n        fragColor = result;\n    }\n    else\n    fragColor = vec4(0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}