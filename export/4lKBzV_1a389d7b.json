{"ver":"0.1","info":{"id":"4lKBzV","date":"1543247981","viewed":130,"name":"CSG - Etape 10","username":"dacruzquen","description":"csg","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//link : \n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n    \nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n};\n    \nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \nconst int MAX_NB_BOUNCES = 5;\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\n\nconst vec3 light1Col = vec3(1,1,1);\nvec3 light1Pos = vec3(8,10,-12);\nconst float light1Pow = 0.8;\n\nconst vec3 light2Col = vec3(1,1,0.5);\nvec3 light2Pos = vec3(3,10,1);\nconst float light2Pow = 0.5;\n\nconst int NB_LIGHTS = 2;\n\nLightInfo lights[NB_LIGHTS];\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\n//Antialiasing parameters\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 5;\n\n//CSG parameters\nconst vec3 csgSphere1Pos = cameraTarget + vec3(-1.125,2,0);\nconst float csgSphere1Radius = 1.4;\n\nconst vec3 csgSphere2Pos = cameraTarget + vec3(1.125,2,0);\nconst float csgSphere2Radius = 1.4;\n\nconst vec3 csgSphere3Pos = cameraTarget + vec3(0,2.5,0);\nconst float csgSphere3Radius = 0.5;\n\nconst vec3 csgSphere4Pos = cameraTarget + vec3(0,2.4,-0.5);\nconst float csgSphere4Radius = 0.5;\n\nconst vec3 csgCol1 = vec3(1.0,0.5,0.0); //orange\nconst vec3 csgCol2 = vec3(0.4,1.0,1.0); //light cyan\nconst vec3 csgCol3 = vec3(1.0,0.0,1.0); //magenta\nconst vec3 csgCol4 = vec3(5.0,5.0,0.0); //hyper yellow\n\nconst Material csgMat = Material(0.2,1.0,0.1,90.0);\nconst int csgId = 3;\n\nint subObjectIdC = 0;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nfloat rayCSG(vec3 rayPos, vec3 rayDir, out vec3 intersecPt, out vec3 normal, out int subObjectId)\n{\n    //Our example CSG object is define like this : ((sphere1 AND sphere2) OR sphere3) - sphere4)\n\t\n    float distIn, distOut;\n    distIn = -1.0;\n    distOut = -1.0;\n    \n    //Intersection sphere 1\n    vec3 diff1 = rayPos - csgSphere1Pos;\n    \n    float a1 = dot(rayDir,rayDir);\n    float b1 = 2.0 * dot(diff1,rayDir);\n    float c1 = dot(diff1,diff1) - csgSphere1Radius * csgSphere1Radius;\n    \n    float di1 = b1*b1 - 4.0*a1*c1;\n    \n    float dist1IN, dist1OUT;\n    \n    if(di1 >= 0.0)\n    {\n        float sdi1 = sqrt(di1);\n        float den1 = 1.0 / (2.0 * a1);\n        float t11 = (-b1 - sdi1) * den1;\n        float t21 = (-b1 + sdi1) * den1;\n        \n        //sphere1IN = rayPos + t11 * rayDir;\n        //sphere1OUT = rayPos + t21 * rayDir;\n        dist1IN = t11;\n        dist1OUT = t21;\n        //normalS1 = normalize(intersecS1 - csgSphere1Pos);\n    }\n    else\n    {\n        dist1IN = -1.0;\n        dist1OUT = -1.0;\n    }\n    \n    \n    //Intersection Sphere 2\n    vec3 diff2 = rayPos - csgSphere2Pos;\n    \n    float a2 = dot(rayDir,rayDir);\n    float b2 = 2.0 * dot(diff2,rayDir);\n    float c2 = dot(diff2,diff2) - csgSphere2Radius * csgSphere2Radius;\n    \n    float di2 = b2*b2 - 4.0*a2*c2;\n    \n    float dist2IN, dist2OUT;\n    \n    if(di2 >= 0.0)\n    {\n        float sdi2 = sqrt(di2);\n        float den2 = 1.0 / (2.0 * a2);\n        float t12 = (-b2 - sdi2) * den2;\n        float t22 = (-b2 + sdi2) * den2;\n        \n        //sphere1IN = rayPos + t12 * rayDir;\n        //sphere1OUT = rayPos + t22 * rayDir;\n        dist2IN = t12;\n        dist2OUT = t22;\n        //normalS2 = normalize(intersecS2 - csgSphere2Pos);\n    }\n    else\n    {\n        dist2IN = -1.0;\n        dist2OUT = -1.0;\n    }\n    \n    //Intersection Sphere 3\n    vec3 diff3 = rayPos - csgSphere3Pos;\n    \n    float a3 = dot(rayDir,rayDir);\n    float b3 = 2.0 * dot(diff3,rayDir);\n    float c3 = dot(diff3,diff3) - csgSphere3Radius * csgSphere3Radius;\n    \n    float di3 = b3*b3 - 4.0*a3*c3;\n    \n    float dist3IN, dist3OUT;\n    \n    if(di3 >= 0.0)\n    {\n        float sdi3 = sqrt(di3);\n        float den3 = 1.0 / (2.0 * a3);\n        float t13 = (-b3 - sdi3) * den3;\n        float t23 = (-b3 + sdi3) * den3;\n        \n        //sphere3IN = rayPos + t13 * rayDir;\n        //sphere3OUT = rayPos + t23 * rayDir;\n        dist3IN = t13;\n        dist3OUT = t23;\n        //normalS3 = normalize(intersecS3 - csgSphere3Pos);\n    }\n    else\n    {\n        dist3IN = -1.0;\n        dist3OUT = -1.0;\n    }\n    \n    //Intersection Sphere 4\n    vec3 diff4 = rayPos - csgSphere4Pos;\n    \n    float a4 = dot(rayDir,rayDir);\n    float b4 = 2.0 * dot(diff4,rayDir);\n    float c4 = dot(diff4,diff4) - csgSphere4Radius * csgSphere4Radius;\n    \n    float di4 = b4*b4 - 4.0*a4*c4;\n    \n    float dist4IN, dist4OUT;\n    \n    if(di4 >= 0.0)\n    {\n        float sdi4 = sqrt(di4);\n        float den4 = 1.0 / (2.0 * a4);\n        float t14 = (-b4 - sdi4) * den4;\n        float t24 = (-b4 + sdi4) * den4;\n        \n        //sphere4IN = rayPos + t14 * rayDir;\n        //sphere4OUT = rayPos + t24 * rayDir;\n        dist4IN = t14;\n        dist4OUT = t24;\n        //normalS4 = normalize(intersecS4 - csgSphere4Pos);\n    }\n    else\n    {\n        dist4IN = -1.0;\n        dist4OUT = -1.0;\n    }\n    \n    //Sphere1 AND Sphere2\n    \n    if((dist1OUT < dist2IN) || (dist2OUT < dist1IN))\n    {\n        distIn = -1.0;\n    \tdistOut = -1.0;\n    }\n    else\n    {\n        distIn = max(dist1IN,dist2IN);\n        distOut = min(dist1OUT,dist2OUT);\n        if(distIn == dist1IN)\n        {\n        \tsubObjectId = 1;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere1Pos);\n        }\n        else\n        {\n            subObjectId = 2;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere2Pos);\n        }\n    }\n    \n    //(Sphere1 AND Sphere2) OR Sphere3\n    if(distIn > 0.0 && dist3IN > 0.0)\n    {\n        distIn = min(distIn,dist3IN);\n        distOut = max(distOut, dist3OUT);\n        if(distIn == dist3IN)\n        {\n        \tsubObjectId = 3;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere3Pos);\n        }\n    }\n    else\n    {\n        distIn = max(distIn,dist3IN);\n        distOut = max(distOut, dist3OUT);\n        if(distIn > 0.0)\n        {\n        \tif(distIn == dist3IN)\n        \t{\n        \t\tsubObjectId = 3;\n        \t    intersecPt = rayPos + distIn * rayDir;\n        \t\tnormal = normalize(intersecPt - csgSphere3Pos);\n       \t\t}\n        }\n        else\n        {\n            distIn = -1.0;\n    \t\tdistOut = -1.0;\n            subObjectId = 0;\n        }\n    }\n    \n    //((Sphere1 AND Sphere2) OR Sphere3) - Sphere4\n    if(distIn > 0.0 && dist4IN > 0.0)\n    {\n        if(distIn < dist4IN)\n        {\n            distOut = dist4IN;\n        }\n        else\n        {\n            if(distOut > dist4OUT)\n            {\n            \tdistIn = dist4OUT;\n            \tsubObjectId = 4;\n            \tintersecPt = rayPos + distIn * rayDir;\n        \t\tnormal = normalize(intersecPt - csgSphere4Pos);\n            }\n            else\n            {\n                distIn = -1.0;\n            }\n        }\n    }\n    else\n    {\n        if(distIn < 0.0)\n        {\n            distIn = -1.0;\n    \t\tdistOut = -1.0;\n            subObjectId = 0;\n        }\n        else\n        {\n            distOut = dist4IN;\n        }\n    }\n    \n    if(distIn >= 0.0)\n        return distIn;\n    \n    subObjectId = 0;\n    \n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V, LightInfo light)\n{\n    vec3 A = sphereMat.Ka * ambiantCol / float(NB_LIGHTS);\n    vec3 D = sphereMat.Kd * sphereCol * light.col * light.power * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * light.col * light.power  * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Méthode pas adaptée pour l'ajout d'objets, \n    // pour le CSG je m'inspire de la méthode ComputeNearestIntersection de https://www.shadertoy.com/view/XslcDM\n    \n    /*vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }*/\n    \n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = 1000000.0;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // Test the CSG object\n    vec3 intersecC, normalC;\n    float distC =  rayCSG(rayPos, rayDir,  intersecC,  normalC, subObjectIdC);\n    if ((distC > 0.0) && (distC < minDist))\n    {\n        objectId  =   csgId;\n        minDist   =     distC;\n\t    intersecI = intersecC;\n    \t  normalI =   normalC;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getCSGColorAtPoint(vec3 pt)\n{\n    switch(subObjectIdC)\n    {\n        case 1:\n        \treturn csgCol1;\n        case 2:\n        \treturn csgCol2;\n        case 3:\n        \treturn csgCol3;\n        case 4:\n        \treturn csgCol4;\n        default:\n        \treturn vec3(3);\n    }\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        case 3:\n        \tobjectMat = csgMat;\n        \treturn getCSGColorAtPoint(pt);\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        \n    \tvec3 V = -rayDir;\n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n        \n        vec3 c = vec3(0.);\n        \n        for(int i=0;i<NB_LIGHTS;i++)\n        {\n    \t\tvec3 L = normalize(lights[i].pos - intersecI);\n    \t\tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n        \n        \tfloat Ldist = distance(intersecI,lights[i].pos);\n        \n        \tfloat shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t\t//Phong shading to get the color of the surface point\n    \t\tc += computePhongShading(col, objMat, shadowFactor, normalI, L, R, V, lights[i]);\n        }\n        \n        \n        infos[nbBounces].shadedCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        //objId = objectId;\n        \n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadedCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n//De facto \"noise\" function, modified to supply two values\n//Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    light1Pos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;    \n    \n    \n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*iResolution.x),float(j)/(float(PIXEL_SAMPLING_SIZE)*iResolution.y));\n            //vec2 q =  vec2(float(i), float(j));\n            //vec2 n = noise2( fragCoord , q );\n            //vec2 offset = vec2(n.x/800., n.y/600.);\n\t\t\tresCol += RaytraceAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol,1);\n}","name":"Image","description":"","type":"image"}]}