{"ver":"0.1","info":{"id":"cdSyWd","date":"1688309844","viewed":55,"name":"Tiled Homogeneous Rasterization","username":"chronos","description":"Coarse rasterization for trivially accepting or rejecting tiles, or continuing fine rasterization step.\nThe method uses the same approach as regular homogeneous edge function rasterization.\nClick to move scene!\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tiled","rasterization","tiling","homogeneous","trivial","culling","accept","reject"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Set the USE_TRIANGLE_BOUNDS define for more aggressive tile rejection\n    Disable it to see \n    \n    With both defines enabled it *should* reject any tile with no overlap.\n*/\n\n#define USE_TRIANGLE_BOUNDS 1\n#define DETECT_BACKFACE 1\n\nfloat sample_edge_function(vec3 ray_dir, vec3 edge)\n{\n    return sign(dot(ray_dir, edge));\n}\n\nstruct tile\n{\n    vec2 vmin;\n    vec2 vmax;\n};\n\nmat3 vertex_transform = mat3(.5,0,0,0,.5,0,0,0,1);\n\nvec3 get_vertex(int vertex_index)\n{ \n    float t = iTime * 0.4;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy)/iResolution.y;\n    if(length(iMouse.xy)<10.) \n        mouse = 0.5 * vec2(cos(t), sin(t));\n    return vertex_transform * verts[vertex_index] + vec3(mouse,0.);\n    \n}\n\n// Classes: -1 trivially rejected, 0 accepted, +1 trivially accepted\nfloat classify_tile(tile t, ivec3 prim)\n{\n    vec2 top_left = vec2(t.vmin.x, t.vmax.y);\n    vec2 bot_left = vec2(t.vmin.x, t.vmin.y);\n    vec2 top_right = vec2(t.vmax.x, t.vmax.y);\n    vec2 bot_right = vec2(t.vmax.x, t.vmin.y);\n    \n    vec3 v0 = get_vertex(prim.x);\n    vec3 v1 = get_vertex(prim.y);\n    vec3 v2 = get_vertex(prim.z);\n    \n    vec3 v1xv0 = cross(v1, v0);\n    vec3 v2xv1 = cross(v2, v1);\n    vec3 v0xv2 = cross(v0, v2);\n    \n    // boolean value\n    bool bAllTrivialAccept = true;\n    \n    for(int edge_index = 0; edge_index < 3; ++edge_index)\n    {\n    \n        vec3 edge = vec3[3](v1xv0, v2xv1, v0xv2)[edge_index];\n\n        // Use sign of edge function to find the trivial accept vertex and trivial reject vertex\n        // trivial reject vertex is the one that gives the highest value(most inside halfspace) when sampling the edge function\n        // trivial accept vertes is the one that gives the lowest value (most outside halfspace) when sampling the edge function\n        \n        // For trivial accept \n        // X = edge.x >= 0 indicates leftmost vertices else rightmost vertices\n        // Y = edge.y >= 0 indicates bottommost vertices else topmost vertices\n        // the binary number YX gives the order: 0:top_right, 1:top_left, 2:bot_right, 3:bot_left\n        \n        int tile_vert_index = int(step(0., edge.x) + 2. * step(0., edge.y));\n\n        vec2 accept_vert = vec2[4](top_right, top_left, bot_right, bot_left)[tile_vert_index];\n        \n        // Trivial reject vertices are the diagonally opposite vertex:\n        vec2 reject_vert = vec2[4](bot_left, bot_right, top_left, top_right)[tile_vert_index];\n\n        float accept_sample = sample_edge_function(vec3(accept_vert, -1.), edge);\n        \n        float reject_sample = sample_edge_function(vec3(reject_vert, -1.), edge);\n        \n        bAllTrivialAccept = bAllTrivialAccept && (accept_sample >= 0.);\n                \n        // Early out trivial reject\n        if(reject_sample <= 0.) return -1.;\n    }\n    \n    #if USE_TRIANGLE_BOUNDS\n    {\n        vec2 vmin = -vec2(9e9), vmax=vec2(9e9);\n    \n        // The below logic should be easy to optimize. Multiply both sides in each comparison \n        // by the denominators to turn division into multiplies.\n        // The goal is just to sort the positions along both x and y to find the extrema.\n        // You can enumerate the 6 possible permutations of 3 elements per axis and determine which pair to use.\n        // Having z-divides here also goes against the spirit of having homogeneous-coordinate rasterization!\n        // Additionally, I've just flipped the sign of the z coordinates to avoid reflecting, since they are all currently negative.\n        // Therefore this will not work in the general case.\n        // It can be solved by using the homogeneous coordinate method again.\n        // I just haven't gotten around to it yet :)\n    \n        // leftmost and rightmost triangle bounds edges\n        bool v0_left_of_v1 = v0.x / -v0.z <= v1.x / -v1.z;\n        bool v0_left_of_v2 = v0.x / -v0.z <= v2.x / -v2.z;\n        bool v1_left_of_v2 = v1.x / -v1.z <= v2.x / -v2.z;\n\n        \n        if(v0_left_of_v1 && v0_left_of_v2) vmin.x = v0.x / -v0.z;\n        \n        if(!v0_left_of_v1 && v1_left_of_v2) vmin.x = v1.x / -v1.z;\n        \n        if(!v0_left_of_v2 && !v1_left_of_v2) vmin.x = v2.x / -v2.z;\n        \n        if(!v0_left_of_v1 && !v0_left_of_v2) vmax.x = v0.x / -v0.z;\n        \n        if(v0_left_of_v1 && !v1_left_of_v2) vmax.x = v1.x / -v1.z;\n        \n        if(v0_left_of_v2 && v1_left_of_v2) vmax.x = v2.x / -v2.z;\n\n\n\n        // bottommost and topmost triangle bounds edges\n        bool v0_below_of_v1 = v0.y / -v0.z <= v1.y / -v1.z;\n        bool v0_below_of_v2 = v0.y / -v0.z <= v2.y / -v2.z;\n        bool v1_below_of_v2 = v1.y / -v1.z <= v2.y / -v2.z;\n        \n        if(v0_below_of_v1 && v0_below_of_v2) vmin.y = v0.y / -v0.z;\n        \n        if(!v0_below_of_v1 && v1_below_of_v2) vmin.y = v1.y / -v1.z;\n        \n        if(!v0_below_of_v2 && !v1_below_of_v2) vmin.y = v2.y / -v2.z;\n        \n        if(!v0_below_of_v1 && !v0_below_of_v2) vmax.y = v0.y / -v0.z;\n        \n        if(v0_below_of_v1 && !v1_below_of_v2) vmax.y = v1.y / -v1.z;\n        \n        if(v0_below_of_v2 && v1_below_of_v2) vmax.y = v2.y / -v2.z;\n    \n    \n        if(t.vmin.x >= vmax.x || t.vmin.y >= vmax.y || t.vmax.x <= vmin.x || t.vmax.y <= vmin.y)\n            return -1.;\n        \n    }\n    #endif\n    \n    #if DETECT_BACKFACE\n    \n        if(dot(cross(v1, v0), v2) <= 0.) return -1.;\n    \n    #endif\n    \n    return bAllTrivialAccept ? 1. : 0.;\n}\n\n// Assumes camera is positioned at 0,0,0, looking down z axis\n// There's a lot of redundant computation here that could be optimized, but I left it like this for clarity.\n// @return reciprocal z = 1./z    Note that this number will be positive in front of camera, e.g the Z axis is not world z, but camera forward dir!\nfloat render_tri(ivec3 prim, vec3 ray_dir)\n{\n    vec3 v0 = get_vertex(prim.x);\n    vec3 v1 = get_vertex(prim.y);\n    vec3 v2 = get_vertex(prim.z);\n    \n    vec3 v1xv0 = cross(v1, v0);\n    vec3 v2xv1 = cross(v2, v1);\n    vec3 v0xv2 = cross(v0, v2);\n    \n    vec3 normal = normalize(cross(v1 - v0, v2 - v0));\n    \n    float step_size_along_normal = dot(normal, ray_dir); // should be negative, otherwise the ray dir is pointing away from the triangle!\n    \n    if(step_size_along_normal >= 0.) return 0.;\n    \n    float step_size_along_z = ray_dir.z; // also negative, so this cancels the negative step size from the step size along the normal when multiplied\n    \n    float step_along_z_per_step_along_normal = step_size_along_z / step_size_along_normal;\n    \n    float triangle_distance = dot(vec3(0) - v0, normal); // to camera at (0,0,0), should be positive\n        \n    float rcp_z = step_size_along_normal / (step_size_along_z * triangle_distance);\n    \n    float edge01 = sample_edge_function(ray_dir, v1xv0);\n    float edge12 = sample_edge_function(ray_dir, v2xv1);\n    float edge20 = sample_edge_function(ray_dir, v0xv2);\n    \n    float mask = step(0., edge01)  * step(0., edge12) * step(0., edge20);\n    \n    return rcp_z * mask; // if outside the triangle mask, given by the edge functions, then set rcp_z to be zero (infinitely far away)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    float rcp_z = 0.;\n    \n    // Current prim_idx to use\n    int prim_idx = (int(iTime) / 4) % num_prims;\n    \n    // Render the rest of the scene first as background\n    {\n        vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n        vec3 ray_dir = normalize(vec3(uv, -1.)); // camera looks down negative z\n\n        \n        int prim_id = 0;\n        for(int i = 0; i < num_prims; i++)\n        {        \n            if(i == prim_idx) continue; // skip to avoid z-fighting\n        \n            float candidate_rcp_z = render_tri(prims[i], ray_dir);\n\n            if(candidate_rcp_z > rcp_z) // When using reciprocal z, i.e 1./z, larger values are nearer.\n            {\n                rcp_z = candidate_rcp_z;\n                prim_id = i;\n            }\n        }\n\n        // The visibility buffer is now essentially the pair of values (rcp_z, prim_id) per pixel.\n        // We'll visualize it by looking up the \"material\" by prim_id and combining it with the z value.\n\n        color = 0.05 * vec3(rcp_z) * rgb_palette[prim_id];\n    }\n\n\n    // Render chosen triangle / primitive, and tile classification\n\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 ray_dir = normalize(vec3(uv, -1.)); // camera looks down negative z\n\n    int prim_id = 0;\n    \n    ivec3 prim = prims[prim_idx];\n    \n    float candidate_rcp_z = render_tri(prim, ray_dir);\n\n    if(candidate_rcp_z >= rcp_z) // When using reciprocal z, i.e 1./z, larger values are nearer.\n    {\n        rcp_z = candidate_rcp_z;\n        prim_id = prim_idx;\n    }\n    \n    color += vec3(candidate_rcp_z >= rcp_z && candidate_rcp_z > 0. )*.5;\n    \n    // Choose which tile size to use\n    int iter = int(iTime) % 4;\n    vec2 uv_subdiv_amount = vec2(1 << iter);\n    \n    // Break into tiles\n    tile t;\n    t.vmin = floor(uv_subdiv_amount * uv) / uv_subdiv_amount;\n    t.vmax = floor(uv_subdiv_amount * uv+1.) / uv_subdiv_amount;\n    \n    //\n    // Here we call the central function of this method!\n    // \n    float tile_class = classify_tile(t, prim);\n    \n    \n    // Visualize the results:\n    // Red: Trivially rejected\n    // Blue: Accepted\n    // Green: Trivially accepted\n    \n    float color_brightness = .2;\n    color += color_brightness * .5 * (abs(tile_class) + vec3(-tile_class,tile_class, 1.-2.*abs(tile_class)));\n    \n    // Visualize tile corners\n    vec2 verts[4] = vec2[4]( vec2(t.vmin.x, t.vmax.y), vec2(t.vmin.x, t.vmin.y), vec2(t.vmax.x, t.vmax.y), vec2(t.vmax.x, t.vmin.y));\n    float minvertdist = 9e9;\n    for(int k = 0; k < 4; ++k) minvertdist = min(minvertdist, distance(uv, verts[k]));\n    if(minvertdist < 0.005 && tile_class >= 0.) color = vec3(1);\n\n\n    \n    const float GAMMA = 2.2;\n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec3 verts[12] = vec3[12]\n\t(\n\t\tvec3(-1., -1., -1.), // 0\n\t\tvec3( 1., -1., -1.), // 1\n\t\tvec3( 1.,  1., -1.), // 2\n\t\tvec3(-1.,  1., -1.), // 3\n\t\tvec3(-1., -1., -2.), // 4\n\t\tvec3( 1., -1., -2.), // 5\n\t\tvec3( 1.,  1., -2.), // 6\n\t\tvec3(-1.,  1., -2.), // 7\n\t\tvec3(-2., -2., -1.), // 8\n\t\tvec3( 2., -2., -1.), // 9\n\t\tvec3( 2.,  2., -1.), // 10\n\t\tvec3(-2.,  2., -1.)  // 11\n\t);\n    \nconst int num_prims = 18;\nconst ivec3 prims[num_prims] = ivec3[num_prims]\n(\n    ivec3(0, 1, 5  ),\n    ivec3(0, 5, 4  ),\n    ivec3(1, 2, 5  ),\n    ivec3(2, 6, 5  ),\n    ivec3(2, 7, 6  ),\n    ivec3(2, 3, 7  ),\n    ivec3(4, 5, 6  ),\n    ivec3(4, 6, 7  ),\n    ivec3(0, 4, 3  ),\n    ivec3(3, 4, 7  ),\n    ivec3(8, 3, 11 ),\n    ivec3(8, 0, 3  ),\n    ivec3(8, 1, 0  ),\n    ivec3(8, 9, 1  ),\n    ivec3(1, 9, 2  ),\n    ivec3(2, 9, 10 ),\n    ivec3(3, 2, 11 ),\n    ivec3(2, 10, 11)\n);\n\nvec3 rgb_palette[num_prims] = vec3[num_prims]\n\t(\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(0., 1., 0.),\n\t\tvec3(0., 1., 0.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 0., 0.),\n\t\tvec3(1., 0., 0.),\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5\n\n\t);","name":"Common","description":"","type":"common"}]}