{"ver":"0.1","info":{"id":"lstBRH","date":"1524592714","viewed":188,"name":"PBR Cubes","username":"eyebrowsoffire","description":"Just trying out some physically based lighting techniques","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float kPi = 3.1415926535897932384626433;\n\n\nvec3 rotX(vec3 vector, float theta)\n{\n    float sint = sin(theta);\n    float cost = cos(theta);\n    mat3 transform = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cost, sint,\n        0.0, -sint, cost\n    );\n    \n    return vector * transform;\n}\n\nvec3 rotY(vec3 vector, float theta)\n{\n    float sint = sin(theta);\n    float cost = cos(theta);\n    mat3 transform = mat3(\n        cost, 0.0, -sint,\n        0.0, 1.0, 0.0,\n        sint, 0.0, cost\n    );\n    \n    return vector * transform;\n}\n\nvec3 rotZ(vec3 vector, float theta)\n{\n    float sint = sin(theta);\n    float cost = cos(theta);\n    mat3 transform = mat3(\n        cost, sint, 0.0,\n        -sint, cost, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    return vector * transform;\n}\n\n\nvec3 getNormal(vec3 pos, vec3 face)\n{\n    const float edgeMin = 0.15;\n    const float edgeMax = 1.0 - edgeMin;\n    const float scale = 1.0 / edgeMin;\n    vec3 fractional = fract(pos);\n        \n    // Take the values between 0.9 and 1.0 and normalize them.\n    vec3 upper = fractional - vec3(edgeMax);\n    upper = upper * step(0.0, upper);\n    upper *= -1.0 * scale;\n    \n    vec3 lower = fractional - vec3(edgeMin);\n    lower = lower * step(0.0, -1.0 * lower);\n    lower *= -1.0 * scale;\n    \n    vec3 edgeAdjust = upper + lower;\n    \n    float maxAngle = kPi / 4.0;\n    \n    vec3 normal = face;\n    \n    face = face;\n    \n    vec4 noise = 0.25 * ((texture(iChannel0, fractional) * 2.0) - 1.0);\n    \n    // Faces orthogonal to x\n    normal = rotZ(normal, noise.z + -1.0 * face.x * edgeAdjust.y * maxAngle);\n    normal = rotY(normal, noise.y + face.x * edgeAdjust.z * maxAngle);\n    \n    // Faces orthogonal to y\n    normal = rotX(normal, noise.x + -1.0 * face.y * edgeAdjust.z * maxAngle);\n    normal = rotZ(normal, face.y * edgeAdjust.x * maxAngle);\n    \n    // Faces orthogonal to z\n    normal = rotX(normal, face.z * edgeAdjust.y * maxAngle);\n    normal = rotY(normal, -1.0 * face.z * edgeAdjust.x * maxAngle);\n    \n    return normal;\n}\n\nbool voxelHit(vec3 voxel)\n{\n    return (length(mod(voxel, 5.0)) < 1.0);\n}\n\nvec2 getSurfacePos(vec3 pos)\n{\n    vec3 fractional = fract(pos);\n    \n    // One of the dimensions is going to be exactly 0.0. So we basically just\n    // want the others.\n    \n    if (fractional.x < 0.01)\n    {\n        return fractional.yz;\n    }\n    else if (fractional.y < 0.01)\n    {\n        return fractional.xz;\n    }\n    else\n    {\n        return fractional.xy;\n    }\n}\n\nvec3 fresnel(vec3 normal, vec3 outgoing, vec3 albedo, float metallic)\n{\n    vec3 F0 = vec3(0.95, 0.64, 0.54);\n    F0 = mix(F0, albedo, metallic);\n    \n    float dotNV = max(dot(normal, outgoing), 0.0);\n    \n    vec3 result = 1.0 - F0;\n    result *=  pow((1.0 - dotNV), 5.0);;\n    result += F0;\n    return result;\n}\n\nfloat geomRay(vec3 normal, vec3 v, float k)\n{\n    float dotNV = max(dot(normal, v), 0.0);\n    \n    float denom = 1.0 - k;\n    denom *= dotNV;\n    denom + k;\n    \n    return dotNV / denom;\n}\n\nfloat geom(vec3 normal, vec3 incoming, vec3 outgoing, float roughness)\n{\n    float k = roughness + 1.0;\n    k *= k;\n    k /= 8.0;\n    \n    return geomRay(normal, incoming, k) * geomRay(normal, outgoing, k);\n}\n\nfloat ndf(float roughness, vec3 normal, vec3 halfway)\n{\n    float roughness2 = roughness * roughness;\n    float dotNH = dot(normal, halfway);\n    float denom = roughness2 - 1.0;\n    denom *= dotNH * dotNH;\n    denom += 1.0;\n    denom *= denom;\n    denom *= kPi;\n    \n    return roughness2 / denom;\n}\n\nvec3 brdf(vec3 pos, vec3 normal, vec3 incoming, vec3 outgoing)\n{    \n    vec2 surfacePos = getSurfacePos(pos);\n    \n    vec3 albedo = texture(iChannel1, surfacePos).xyz;\n    \n    // We'll try to base the roughness and metallicness on the texture.\n    // Assume grayish colors (metal) are smoother than reddish/brownish\n    // colors (rust).\n    float chroma = max(max(abs(albedo.x - albedo.y), abs(albedo.y - albedo.z)), abs(albedo.x - albedo.z));\n    \n    float roughness = min(0.2 + 2.0 * chroma, 1.0);\n    float denom = 4.0 * dot(outgoing, normal) * dot(incoming, normal);\n    float metallic = 1.0 - chroma;\n    \n    vec3 halfway = normalize(incoming + outgoing);\n        \n    vec3 spec = vec3(1.0) * ndf(roughness, normal, halfway) * geom(normal, incoming, outgoing, roughness) * fresnel(normal, outgoing, albedo, metallic) / denom;\n    \n    vec3 diffuse = albedo * (1.0 - spec) / kPi;\n    return spec + diffuse;\n}\n\nvec3 getIrradiance(vec3 pos, vec3 lightPos, vec3 outgoing, vec3 normal)\n{    \n    vec3 incoming = normalize(pos - lightPos);\n    \n    vec3 baseLightColor = vec3(0.8, 0.8, 0.4);\n    float lightDistance = distance(pos, lightPos) / 7.0;\n    vec3 light = baseLightColor / (lightDistance * lightDistance);\n    \n    return brdf(pos, normal, incoming, outgoing) * light * dot(normal, incoming);\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDirection, vec3 lightPos)\n{\n    vec3 pos = rayOrigin;\n    vec3 voxel = floor(pos);\n    vec3 raySign = sign(rayDirection);\n    vec3 isPositive = max(vec3(0.0), raySign);\n    vec3 face;\n    \n    float dist = 0.0;\n    \n    for (float i = 0.0; i < 100.0; i++)\n    {\n        vec3 distanceToNext = abs((voxel + isPositive - pos) / rayDirection);\n        vec3 negativeDistanceToNext = -1.0 * distanceToNext;\n        vec3 smallestDimension = step(negativeDistanceToNext.x, negativeDistanceToNext)\n            * step(negativeDistanceToNext.y, negativeDistanceToNext)\n            * step(negativeDistanceToNext.z, negativeDistanceToNext);\n        voxel += smallestDimension * raySign;\n        \n        float smallestDistance = min(distanceToNext.x, min(distanceToNext.y, distanceToNext.z));\n        pos += smallestDistance * rayDirection;\n        \n        dist += smallestDistance;\n        \n        if (voxelHit(voxel))\n        {\n            face = normalize(smallestDimension * raySign);\n            break;\n        }\n\n    }\n    \n    if (dist > 50.0)\n    {\n        return vec4(0.0);\n    }\n    \n    vec3 normal = getNormal(pos, face);\n    \n    dist = length(pos - rayOrigin);\n    dist /= 5.0;\n        \n    return vec4(getIrradiance(pos, lightPos, rayDirection, normal), 0.0);\n}\n\nvec3 getCameraPosition()\n{\n    return vec3(1.0 * sin(0.3 * iTime), 2.0 * sin(iTime), iTime * 1.0);\n}\n\nvec3 getCameraLookAt()\n{\n    return normalize(5.0 * vec3(12.0 * sin(0.3 * iTime), 20.0 * cos(iTime), 1.0));\n}\n\nvec3 getCameraUp()\n{\n    vec3 cameraLookAt = getCameraLookAt();\n    vec3 right = cross(cameraLookAt + vec3(0.0, 1.0, 0.0), cameraLookAt);\n    \n    return normalize(cross(right, cameraLookAt));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n    \n    vec3 rayOrigin = getCameraPosition();\n    \n    vec3 cameraLookAt = getCameraLookAt();\n    vec3 cameraUp = getCameraUp();\n    vec3 cameraRight = cross(cameraUp, cameraLookAt);\n    vec3 rayPoint = (rayOrigin + cameraLookAt) + (cameraUp * uv.y) + (cameraRight * uv.x);\n    vec3 rayDirection = normalize(rayPoint - rayOrigin);\n    \n    vec3 lightPos = rayOrigin + 5.0 * cameraLookAt;\n    \n    fragColor = castRay(rayOrigin, rayDirection, lightPos);\n}","name":"Image","description":"","type":"image"}]}