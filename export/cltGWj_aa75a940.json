{"ver":"0.1","info":{"id":"cltGWj","date":"1694350295","viewed":16,"name":"1D Sliding Window","username":"tepSHATOY","description":"Figuring out a way to have smooth sliding window","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["window","sliding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 computeData(int index, float cellSize, float worldPos, bool point)\n{\n    vec2 uv;\n    uv.x = worldPos / cellSize;\n    uv.y = 1.0f;\n    \n    if (point)\n    {\n        uv.x = floor(uv.x) + 0.5f;        \n    }\n\n    // avoid wrapping around\n    uv.x = max(uv.x, 0.5);\n\n    if (index == 0)\n    {\n        uv.x /= float(textureSize(iChannel0, 0).x);\n        return texture(iChannel0, uv).rgb;\n    }\n    else\n    {\n        uv.x /= float(textureSize(iChannel1, 0).x);\n        return texture(iChannel1, uv).rgb;\n    }\n}\n\n#define DATA_SIZE 16\n#define GUTTER 1.0f\n\nstruct Grid\n{\n    // init\n    int index;\n    float cellSize;\n    \n    // data\n    int dataSize;\n    int dataOffset;\n    vec3 data[DATA_SIZE];\n};\n\nvoid updateGrid(inout Grid g, float centerPos)\n{\n    g.dataOffset = int(floor(centerPos / g.cellSize)) - g.dataSize / 2;\n    \n    for (int i=0; i<DATA_SIZE; i++)\n    {\n        float worldPos = (float(g.dataOffset + i) + 0.5f) * g.cellSize;\n        g.data[i] = computeData(g.index, g.cellSize, worldPos, true);\n    }    \n}\n\nvec3 sampleGrid(Grid g, float worldPos, bool point)\n{\n    float texcoord = ((worldPos / g.cellSize - float(g.dataOffset)) / float(g.dataSize));\n    \n    if (point)\n    {\n        int dataIndex = clamp(int(floor(texcoord * float(g.dataSize))), 0, g.dataSize - 1);\n        return g.data[dataIndex];\n    }\n    else\n    {\n        float i = texcoord * float(g.dataSize);\n        int i0 = int(floor(i - 0.5));\n        int i1 = i0 + 1;\n        i0 = clamp(i0, 0, g.dataSize - 1);\n        i1 = clamp(i1, 0, g.dataSize - 1);\n        return mix(g.data[i0], g.data[i1], max(i - float(i0) - 0.5, 0.0));\n    }\n}\n\nfloat getGridCenter(Grid g)\n{\n    return float(g.dataOffset + g.dataSize / 2) * g.cellSize;\n}\n\nbool inGridData(Grid g, float pos)\n{\n    float dataMin = float(g.dataOffset) * g.cellSize;\n    float dataMax = dataMin + float(g.dataSize) * g.cellSize;\n    return (dataMin <= pos && pos <= dataMax);\n}\n\n\nstruct ClipMap\n{\n    float viewerPos;\n    Grid grids[2];\n};\n\nClipMap initClipMap()\n{\n    ClipMap cm;\n    cm.viewerPos = cos(iTime*0.25) * 0.5 + 0.5;\n    \n    cm.grids[0].index = 0;\n    cm.grids[0].cellSize = 1.0 / 32.0;\n    cm.grids[0].dataSize = DATA_SIZE;\n    \n    cm.grids[1].index = 1;\n    cm.grids[1].cellSize = 2.0 * cm.grids[0].cellSize;\n    cm.grids[1].dataSize = DATA_SIZE;\n\n    // compute shared grid center pos\n    float maxCellSize = max(cm.grids[0].cellSize, cm.grids[1].cellSize);\n    float centerPos = floor(cm.viewerPos / maxCellSize) * maxCellSize;\n\n    updateGrid(cm.grids[0], centerPos);\n    updateGrid(cm.grids[1], centerPos);\n    \n    // pre blend grid 0\n    bool doPreblend = true;\n    if (doPreblend)\n    {\n        for (int i=0; i<DATA_SIZE; i++)\n        {\n            float worldPos = (float(cm.grids[0].dataOffset + i) + 0.5f) * cm.grids[0].cellSize;\n            float clipPos0 = (worldPos - cm.viewerPos) / (0.5 * float(cm.grids[0].dataSize) * cm.grids[0].cellSize - (maxCellSize + GUTTER * cm.grids[0].cellSize));\n            float absClipPos0 = abs(clipPos0);\n            float blendStart = 0.7f;\n            if (absClipPos0 > blendStart)\n            {\n                float t = clamp((absClipPos0 - blendStart) / (1.0 - blendStart), 0.0, 1.0);\n                cm.grids[0].data[i] = mix(cm.grids[0].data[i], sampleGrid(cm.grids[1], worldPos, false), t);\n            }\n\n            //if (i == 0 || i == 1 || i == DATA_SIZE - 1 || i == DATA_SIZE - 2)\n            //{\n            //    float worldPos = (float(cm.grids[0].dataOffset + i) + 0.5f) * cm.grids[0].cellSize;\n            //    cm.grids[0].data[i] = sampleGrid(cm.grids[1], worldPos, false);\n            //}        \n        }\n    }\n    return cm;\n}\n\nvec3 sampleClipMap(ClipMap cm, float worldPos)\n{\n    float maxCellSize = max(cm.grids[0].cellSize, cm.grids[1].cellSize);\n    \n    float clipPos0 = (worldPos - cm.viewerPos) / (0.5 * float(cm.grids[0].dataSize) * cm.grids[0].cellSize - (maxCellSize + GUTTER * cm.grids[0].cellSize));    \n    float absClipPos0 = abs(clipPos0);\n    if (absClipPos0 <= 1.0f)\n    {\n        return sampleGrid(cm.grids[0], worldPos, false);\n    }\n\n    float clipPos1 = (worldPos - cm.viewerPos) / (0.5 * float(cm.grids[1].dataSize) * cm.grids[1].cellSize - (maxCellSize + GUTTER * cm.grids[1].cellSize));\n    float absClipPos1 = abs(clipPos1);\n    if (absClipPos1 <= 1.0f)\n    {\n        return sampleGrid(cm.grids[1], worldPos, false);\n    }\n\n    return vec3(0, 0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ClipMap cm = initClipMap();\n\n    vec2 screenUv = fragCoord / iResolution.xy;\n    float worldPos = screenUv.x;\n    \n    vec3 color = vec3(0, 0, 0);\n    \n    float spacing = 1.0f / 5.0f;\n    if (screenUv.y < spacing)\n    {\n        // grid 0 data\n        color = computeData(0, cm.grids[0].cellSize, worldPos, true);\n    }\n    else if (screenUv.y < 2.0 * spacing)\n    {\n        // grid 1 data\n        color = computeData(1, cm.grids[1].cellSize, worldPos, true);\n    }\n    else if (screenUv.y < 3.0 * spacing)\n    {\n        // grid data\n        if (inGridData(cm.grids[0], worldPos))\n        {\n            color = sampleGrid(cm.grids[0], worldPos, false);\n        }\n        else if (inGridData(cm.grids[1], worldPos))\n        {\n            color = sampleGrid(cm.grids[1], worldPos, false);\n        }\n    }\n    else if (screenUv.y < 4.0 * spacing)\n    {\n        color = sampleClipMap(cm, worldPos);\n    }\n    \n    /*\n\n    // sliding window\n    SlidingWindow sw = initSlidingWindow(sampleTexcoord);\n        \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float spacing = 1.0 / 5.0f;\n    if (uv.y < spacing)\n    {\n        // point sampled\n        color = fgPointSampleColor(sampleTexcoord);\n    }\n    else if (uv.y < 2.0 * spacing)\n    {\n        // linear\n        color = fgSampleColor(sampleTexcoord);\n    }\n    else if (uv.y < 3.0 * spacing)\n    {\n        // sliding window ground truth        \n        if (inSlidingWindow(sw, sampleTexcoord))\n        {            \n            color = fgSampleColor(sampleTexcoord);\n        }\n    }\n    else if (uv.y < 4.0 * spacing)\n    {\n        if (inSlidingWindowData(sw, sampleTexcoord))\n        {\n            color = swPointSample(sw, sampleTexcoord);\n        }\n    }\n    else\n    {\n    }\n    */\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}