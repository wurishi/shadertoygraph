{"ver":"0.1","info":{"id":"ddcXRH","date":"1679379312","viewed":54,"name":"Test 15 - moving objects","username":"gorplex","description":"moving objects\ntesting physics values in buffers","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["test","demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Duplicated func in Buffer A and Image module\nvec4 objectData(int objectIndex) {\n    return texelFetch(iChannel0, ivec2(objectIndex, 0), 0);\n}\n\nfloat circle(vec2 p, float r, vec2 uv)\n{\n    return smoothstep(1.5/iResolution.y, 0., length(uv-p)-r);\n}\n\nvec3 objColor(int objIndex) {\n    return hsv2rgb_smooth(vec3(float(objIndex)/float(NUM_OBJECTS), 0.7, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    for(int i=0; i<NUM_OBJECTS;i++)\n    {\n        vec4 objectData = objectData(i);\n        vec2 pos = objectData.xy;\n        vec2 vel = objectData.zw;\n        \n        col += objColor(i)*circle(pos, .02, uv);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_OBJECTS 30\n\n#define DELTA_T .01\n#define MAX_VEL 0.75\n\n#define BOUNDRY_WIDTH 0.1\n#define BOUNDRY_FORCE 20.0\n#define MOUSE_FORCE 0.1\n\n#define PI 3.1415926538\n\n// Smooth HSV to RGB conversion \n// Source https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A runs physics calculations and stores velocity and position vetors\n\n//Duplicated func in Buffer A and Image module\nvec4 objectData(int objectIndex) {\n    return texelFetch(iChannel0, ivec2(objectIndex, 0), 0);\n}\n\n\nfloat random(float seed) {\n    return fract(sin(seed*3123.43758287) * 43758.5453123);\n}\n\nvec2 randomPos(float seed) {\n    return vec2(random(random(seed))*iResolution.x/iResolution.y, random(random(random(seed))));\n}\n\nfloat smoothStepBoundries(float x,  float maxBoundry) {\n    return 1.-smoothstep(0., BOUNDRY_WIDTH, x) -smoothstep(maxBoundry-BOUNDRY_WIDTH, maxBoundry, x);\n}\n\nvoid mainImage( out vec4 posVelData, vec2 uv ) {\n\n    //each pixel along x will physics update an object\n    int objectIndex = int(floor(uv.x));\n    if(uv.y > 0.5 || objectIndex > NUM_OBJECTS) discard;\n\n    \n    //init ===================================\n    if (iFrame < 5) {\n        //posVelData = vec4(randomPos(float(objectIndex)), normalize(randomPos(42560234.1235*float(objectIndex))));\n        posVelData = vec4(randomPos(float(objectIndex)), 0., -1.);\n    } else {\n    //phys update ===================================\n        vec4 objectData = objectData(objectIndex);\n        vec2 pos = objectData.xy;\n        vec2 vel = objectData.zw;\n        \n    //sum forces ===================================        \n        vec2 force = vec2(0.);\n        \n        //add boundry forces\n        force += BOUNDRY_FORCE*vec2(smoothStepBoundries(pos.x, iResolution.x/iResolution.y), smoothStepBoundries(pos.y, 1.));\n        \n        //add mouse effects\n        vec4 m = iMouse / iResolution.y;\n        // button is down\n        if( m.z>0.0 ) {\n            //TODO: add falloff?\n            force += MOUSE_FORCE*normalize(pos-m.xy)/dot(pos-m.xy, pos-m.xy);\n        }\n        \n        \n    //step update ===================================  \n        vel += force*DELTA_T;\n        vel = clamp(vel, -MAX_VEL, MAX_VEL);\n        pos = pos+vel*DELTA_T;\n        \n        //store data\n        posVelData = vec4(pos, vel);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}