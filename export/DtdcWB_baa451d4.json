{"ver":"0.1","info":{"id":"DtdcWB","date":"1700467268","viewed":17,"name":"toroidtest","username":"wangqiuyan","description":"toroidtest","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["toroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TOROID vec4(1.7,.25,0.4,0.0)\n#define SURFACE_DIST .001\n#define MAX_DIST 100.\nfloat getdist(vec3 p)\n{\n   //return length(vec2(length(p.xz)-TOROID.x,p.y))-TOROID.y;\n   \n    const float k = 2.0; // or some other amount\n    \n    float c = cos(k);\n    float s = sin(k);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz=vec2(m*p.xz);\n    vec3 p2 = vec3(xz.x,p.y,xz.y);\n    p2=p;\n   \n   //want to be swirl but not succeed still need to modify\n  // vec2 xy=vec2(length(p2.xz)-TOROID.x,p2.y-sin(k*p2.y));\n    vec2 xy=vec2(length(p2.xz)-TOROID.x,p2.y);\n   vec2 q=abs(xy)-TOROID.yz;\n   float r=TOROID.w;\n   return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e=vec2(0.01,0.0);\n    float d=getdist(p);\n    vec3 n=d-vec3(\n        getdist(p-e.xyy),\n        getdist(p-e.yxy),\n        getdist(p-e.yyx)\n    );\n    return normalize(n);\n}\nvec2 raymarching(vec3 ro, vec3 rd)\n{\n    float d0=0.0;\n    float dis=0.0;\n    for(int i=0;i<100;i++)\n    {\n        vec3 p=ro+d0*rd;\n        dis=getdist(p);\n        d0+=dis;\n        if(dis<SURFACE_DIST||d0>MAX_DIST)\n            break;\n       \n    }\n    return vec2(d0,dis);\n}\nvec3 getlight(vec3 p)\n{\n    vec3 lightPos=vec3(0.,9.,6.);\n \n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*12.;\n    vec3 l=normalize(lightPos-p);\n  \n    vec3 n=getNormal(p);\n    float dif=dot(n,l)*1.0;\n    vec3 ambient=0.1*vec3(0.6)*vec3(1.);\n    \n    //shadow on plane\n   // if(length(lightPos-p)>raymarching(p+n*SURFACE_DIST*2.,l).x)\n    //    dif*=0.1;\n   // dif=clamp(dif,-10.,1.);\n   \n    vec3 lightcol=vec3(dif);\n    return lightcol;    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //uv+=iMouse.xy/iResolution.xy;\n    fragColor.rgb=vec3(0.);\n   //fragColor=texture(iChannel0,uv+0.5);\n    vec3 col = vec3(0.0);    \n    \n    vec3 ro=vec3(0,6.,-8.),\n         lookat=vec3(0,0,3),\n         f=normalize(lookat-ro);\n         \n    ro.xz+=vec2(sin(iTime),cos(iTime));\n         \n    float zoom=1.;\n    \n    vec3 r=cross(vec3(0,1,0),f),\n         u=cross(f,r);\n   \n    vec3 c=ro+f*zoom,\n         i=c+uv.x*r+uv.y*u,\n         rd=normalize(i-ro);\n   \n   vec2 rm=raymarching(ro,rd);\n   float d0=rm.x;\n   float ds=rm.y;\n   if(ds>SURFACE_DIST)\n       return;\n       \n  \n   \n   \n   vec3 p=ro+rd*d0;\n   \n   vec3 lightcol=getlight(p);\n         \n\n    \n   \n    fragColor.rgb=clamp(lightcol,0.,1.);\n    \n\n  \n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}