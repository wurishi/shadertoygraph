{"ver":"0.1","info":{"id":"7lyyRK","date":"1693488268","viewed":105,"name":"Riemann Siegel formula","username":"guil","description":"Approximation of Riemann Zeta using Riemann Siegel formula smoothed by a sigmoid.\nValid for large abs(z.imag) \nKeys: 1 : Zeta, 2 : Zeta derivative, 3 : Siegel Z function by Zeta, 3 : Siegel Z function by RS, z : zoom, y double zoom,\nw : shift 500\n\n","likes":9,"published":1,"flags":16,"usePreview":0,"tags":["zeta","riemann","siegel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535897932;\nconst float LOG2 = 0.6931471805599453;\nconst float LOGPI = 1.1447298858494002;\nconst float LOG2PI = 1.8378770664093453;\n\n\n//------------------ ------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cinv(vec2 z) {return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cdiv1( vec2 a, vec2 b )  { float d = dot(b,b)+1e-35; return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cexp( vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog( vec2 z) {  return vec2( 0.5*log(z.x*z.x+z.y*z.y), atan(z.y,z.x)); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cpow( vec2 a, vec2 b ) {  return cexp(cmul(b,clog(a))) ;}vec2 cpow( float n, vec2 z ) {  return (n>0.)? pow( n, z.x )*vec2( cos(z.y*log(n)), sin(z.y*log(n)) )\n            :cpow(vec2(n,0),z); }\n\nvec2 csin( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\n\nvec2 ccos( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\nvec2 clogsin(vec2 z) {\n  if (abs(z.y)<8.0)return clog(csin(z));  \n  if (z.y > 0.) return vec2(z.y - LOG2, mod(1.5*pi-z.x, 2.0*pi) - pi);\n  else return vec2(-z.y - LOG2, mod(0.5*pi+z.x, 2.0*pi) - pi);\n  \n}\n//------------------------------------------------------------\n\n\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 col(vec2 u){\n    float r = u.x;\n    float v =min( exp(-r*.15),1.);\n    return hsv2rgb(vec3(u.y/(2.*pi),.5+.5*fract(r),.8))*v;\n}\n\n// Spouge's method for loggamma\nvec2 loggamma(vec2 z){\n    const int N = 8;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t       \n    s = clog(s); \n    s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    return s-clog(z);      \n}\n\n//Zeta with first Euler Maclaurin term \nvec2 zeta1(vec2 z){\n  const float N = 400.;\n  vec2 sum = vec2(0);\n  for(float i = 0.; i < N; i++)\n    sum += cpow(i+1.,-z);\n  return sum+cdiv(cpow(N+1.,vec2(1,0)-z),z-vec2(1,0))+ cpow(N+1.,-z)/2.;\n}\n\n\nvec2 logkhi(vec2 z){\n    return z*log(2.*pi)-vec2(log(pi),0)+clogsin(pi*z/2.)+loggamma(vec2(1.,0.)-z);\n}  \n\nvec2 logzeta(vec2 z){\n    if(z.x<.5)return logkhi(z)+clog(zeta1(vec2(1.,0.)-z));\n    return clog(zeta1(z));\n}\n\nvec2 zeta(vec2 z){    \n    return cexp(logzeta(z));\n}\n\nvec2 dzeta(vec2 z){\n    vec2 eps = vec2(1e-2);\n    return cdiv(zeta(z+eps)-zeta(z-eps),2.*eps);\n\n}\n\nfloat sigmoid(float x){\n    return 1./(1.+exp(-x));\n}\n\n//Riemann-Siegel formula smoothed by a sigmoid\n//Valid for 0<z.x<1 and abs(z.y) very large\n//http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nvec2 zeta6(vec2 z){\n  float m = sqrt(abs(z.y)/(2.*pi));\n  float N = m + 20.;\n  vec2 sum1 = vec2(0);\n  vec2 sum2 = vec2(0);\n  for(float i = 0.; i < N; i++){    \n    sum1 += sigmoid(m-i-1.)*cpow(i+1.,-z); \n    sum2 += sigmoid(m-i-1.)*cpow(i+1.,z-vec2(1,0));    \n  }    \n  return sum1 + cexp(logkhi(z)+clog(sum2));\n}\n\n\n//Î¸(t)\nfloat theta(float t){\n    return -t/2.*log(pi)+loggamma(vec2(.25,t*.5)).y;    \n}\n\n\n//Riemann Siegel Z function \nfloat Z(float t){\n    return cmul(zeta1(vec2(.5,t)),cexp(vec2(0,theta(t)))).x;    \n}\n\n//Riemann Siegel Z function \nfloat Z2(float t){\n    return cmul(zeta6(vec2(.5,t)),cexp(vec2(0,theta(t)))).x;    \n}\n\n\nbool keypress(int key) {\n    return texelFetch(iChannel3, ivec2(key,2),0).x != 0.0;\n}\n\n\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (2.*fragCoord - iResolution.xy-iMouse.xy) / iResolution.y+(iMouse.xy==vec2(0.,0.)?0.:.5);;  // Map y-coordinates to [-1;1]\n  float zoom = 12.;\n  if (keypress(90)) zoom = 4.0;//z\n  if (keypress(89)) zoom = 1.0;//y\n  if (keypress(85)) zoom = 24.0;//u\n  uv *= zoom;  // Zoom out\n  float shift = 0.;\n  if (keypress(87)) shift = 500.0;//w\n  if (keypress(88)) shift = 15000.0;//x\n  uv.x += shift+iTime;  // Move up in uv-space!\n  vec2 z = uv.yx;  \n    \n  if (keypress(49)) {//1\n      z=logzeta(z);\n      \n  } else if (keypress(50)){//2\n      z = clog(dzeta(z));\n  } else{\n      z=clog(zeta6(z));\n      \n  }\n  fragColor.rgb = col(z);\n  float size = 4.*zoom/iResolution.x;\n  if (mod(abs(uv.x),5.)<size)fragColor.rgb = vec3(0.5);\n  if (mod(abs(uv.y),5.)<size)fragColor.rgb = vec3(0.5);\n  if (abs(uv.y-.5)<size)fragColor.rgb = vec3(1);\n  vec2 z1 = vec2( cos(z.y), sin(z.y) );\n  fragColor.rgb += .8*vec3(exp(-20.*abs(z1.x)));\n  fragColor.rgb *= vec3(1.-.5*exp(-40.*abs(z1.y)));\n  \n  float x = abs(uv.x);\n  if (keypress(51)) {//3\n      float k = exp(-10.*abs(Z(x)-uv.y+.5));  \n      fragColor.rgb += vec3(k);\n      }\n  if (keypress(52)) {//4\n      float k = exp(-10.*abs(Z2(x)-uv.y+.5));  \n      fragColor.rgb -= vec3(k);\n      }\n  \n}\n\n","name":"Image","description":"","type":"image"}]}