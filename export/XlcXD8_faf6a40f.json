{"ver":"0.1","info":{"id":"XlcXD8","date":"1479177068","viewed":198,"name":"Sine on the normal of Sine","username":"cubby208","description":"I realize that this is a REALLY bad way to do this as far as efficiency goes. My problem is that the second line is basically a point on the normal of sin(x). I can not find an equation for the 2nd line.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["increaseitrforabettergraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITR 900 //INCREASE this number for a better graph, decrease for a faster one\nfloat col = 0.0;\nvec2 uv = vec2(0.0);\nfloat hue = 0.0;\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid colorPt(in vec2 pt, in float colo)\n{\n    if (length(uv-pt) < 0.001)\n    {\n\t\tcol = 1.0;\n        hue = colo;\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy / iResolution.xy;\n    \n    float tx1 = iTime;\n    float tx2 = iTime * 9.0;\n    for (int i = 0; i < ITR; i++)\n    {\n\t\tfloat x = (float(i) / float(ITR));\n        float dom = x * 4.0 * 3.141592 + tx1;\n        float by = sin(dom) * 0.4  + 0.5;\n        float d = (cos(dom) * 0.4 * 4.0 * 3.141592);\n        float a = atan(d) + (3.141592 / 2.0);\n        float dx = cos(a);\n        float dy = sin(a);\n        float disp = sin(x * 100.0) * sin(iTime * 1.0) * 0.02;\n        colorPt(vec2(x + (dx * disp), by + (dy * disp)), x);\n        colorPt(vec2(x, by), x);\n    }\n    \n    if (hue == 0.0)\n    {\n\t\tfragColor = vec4(vec3(col),1.0);\n    }\n    else\n    {\n        vec3 get = vec3(hue, 1.0, 1.0);\n\t\tfragColor = vec4(hsv2rgb(get), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}