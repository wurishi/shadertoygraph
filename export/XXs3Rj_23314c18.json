{"ver":"0.1","info":{"id":"XXs3Rj","date":"1713029215","viewed":836,"name":"Bezier Trefoil Knot","username":"etcher","description":"Bezier Trefoil Knot","likes":57,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----------------------------------------------------------------------------\n// Created by Evgenii Davydenko in 2024\n//\n// With the help of Inigo Quilez:\n//      https://www.shadertoy.com/view/ldj3Wh\n//      https://www.shadertoy.com/view/MdjGR1\n// -----------------------------------------------------------------------------\n\n// #define AA_ENABLED\n#define AA_LEVEL 2\n\n#define dot2(x)   dot(x, x)\n#define lerp(v0, v1, t)   mix(v0, v1, t)\n#define saturate(x)   clamp(x, 0.0, 1.0)\n\n#define remap(x0, x1, y0, y1, v)    ((v - x0) / (x1 - x0)  * (y1 - y0) + y0)\n#define remaps(x0, x1, y0, y1, v)   (saturate((v - x0) / (x1 - x0)) * (y1 - y0) + y0)\n#define linstep(x0, x1, v)          remap(x0, x1, 0.0, 1.0, v)\n#define linsteps(x0, x1, v)         remaps(x0, x1, 0.0, 1.0, v)\n#define hscan(x, p, c)              saturate(c * (linstep(0.0, 1.0, x) + p - 1.0) + p)\n\n#define iMouse01         (iMouse / iResolution.xyxy)\n\nconst int MAX_STEPS = 128;\nconst int MAX_STEPS_SHADOW = 16;\nconst float DIST_MAX = 16.0;\nconst float DIST_SURF = 0.001;\nconst float MARCH_FACTOR = 1.0;\nconst float VOID_VALUE = 100000.0;\n\nconst int TREFOIL_SEGMENTS = 15;\nconst float TREFOIL_THICKNESS = 0.7;\nconst vec3 TREFOIL_BBOX = vec3(4.0, 4.0, 1.6);\n\nconst vec3 LIGHT_POS = vec3(1.0, 3.0, 6.0);\n\nconst float GLOBAL_SPEED = 1.0;\n\nconst float PI = 3.141593;\nconst float PIHALF = PI * 0.5;\nconst float TAU = PI * 2.0;\n\nconst uint MAT_DEFAULT = 0u;\nconst uint MAT_BACK_PLANE = 1u;\nconst uint MAT_TREFOIL = 2u;\n\nstruct SDData\n{\n    float dist;\n    vec2 uv;\n    vec3 normal;\n    uint matId;\n};\n\nSDData SDData0()\n{\n    SDData res;\n    res.dist = VOID_VALUE;\n    res.uv = vec2(0.0, 0.0);\n    res.normal = vec3(0.0, 1.0, 0.0);\n    res.matId = MAT_DEFAULT;\n    return res;\n}\n\nstruct RayMarchData\n{\n    float marched;\n    SDData sdData;\n};\n\nRayMarchData RayMarchData0()\n{\n    RayMarchData res;\n    res.marched = 0.0;\n    res.sdData = SDData0();\n    return res;\n}\n\nstruct RenderData\n{\n    vec3 pos;\n    vec3 normal;\n    vec2 uv;\n    vec3 view;\n    uint matId;\n};\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nfloat toSrgb(float c)\n{\n    return (c < 0.0031308) ? c * 12.92 : 1.055 * pow(c, 0.41666) - 0.055;\n}\n\nvec3 toSrgb(vec3 c)\n{\n    return vec3(toSrgb(c.r), toSrgb(c.g), toSrgb(c.b));\n}\n\nfloat toLinear(float c)\n{\n    return (c < 0.04045) ? c * (1.0 / 12.92) : pow((c + 0.055) * (1.0 / 1.055), 2.4);\n}\n\nvec3 toLinear(vec3 c)\n{\n    return vec3(toLinear(c.r), toLinear(c.g), toLinear(c.b));\n}\n\nvec3 srgb255toLinear(vec3 c)\n{\n    return toLinear(c / 255.0);\n}\n\nmat3 rotX(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, c, s),\n        vec3(0.0, -s, c)\n    );\n}\n\nmat3 rotY(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        vec3(c, 0.0, -s),\n        vec3(0.0, 1.0, 0.0),\n        vec3(s, 0.0, c)\n    );\n}\n\nmat3 rotZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        vec3(c, s, 0.0),\n        vec3(-s, c, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec3 avg(vec3 a, vec3 b)\n{\n    return (a + b) * 0.5;\n}\n\nbool boxIntersection(Ray ray, vec3 bbox) \n{\n    vec3 m = 1.0 / ray.d;\n    vec3 n = m * ray.o;\n    vec3 k = abs(m) * bbox;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return ((tN > tF) || (tF < 0.0)) ? false : true;\n}\n\nmat3 camMtxWithInterestAndUp(vec3 camPos, vec3 camInterest, vec3 camUp)\n{\n    vec3 vecForward = normalize(camInterest - camPos);\n    vec3 vecRight = normalize(cross(vecForward, camUp));\n    vec3 vecUp = cross(vecRight, vecForward);\n    return mat3(vecRight, vecUp, vecForward);\n}\n\nRay rayCameraWithInterestUpWorldY(vec2 uv, vec3 camPos, vec3 camInterest)\n{\n    Ray ray;\n    ray.o = camPos;\n    ray.d = camMtxWithInterestAndUp(camPos, camInterest, vec3(0.0, 1.0, 0.0)) * normalize(vec3(uv, 1.0));\n    return ray;\n}\n\nSDData sdBackPlane(vec3 p, uint matId)\n{\n    SDData res;\n    res.dist = p.z;\n    res.matId = matId;\n    res.uv = vec2(p.x, p.y);\n    res.normal = vec3(0.0, 0.0, 1.0);\n    return res;\n}\n\nvec3 trefoil(float t)\n{\n    float t2 = 2.0 * t;\n    vec3 res = vec3(sin(t) + 2.0 * sin(t2), cos(t) - 2.0 * cos(t2), -sin(3.0 * t));\n    res = rotZ(0.86) * res;  // reorient vertically\n    return res;\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float t)\n{\n    float tInv = (1.0 - t);\n    return tInv * tInv * a + 2.0 * tInv * t * b + t * t * c;\n}\n\n// bezier derivative\nvec3 bezierDx(vec3 a, vec3 b, vec3 c, float t)\n{\n    float t2 = 2.0 * t;\n    return 2.0 * (t - 1.0) * a + 2.0 * (1.0 - t2) * b + t2 * c;\n}\n\n// return:\n//      x: distance to a closest point p on curve\n//      y: t bezier parameter at p\nvec2 sdBezier(vec3 pos, vec3 A, vec3 B, vec3 C)\n{\n    vec3 a = B - A;\n    vec3 b = A - 2.0 * B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot2(b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot2(a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float p = ky - kx * kx;\n    float p3 = p * p * p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float q2 = q * q;\n    float h = q2 + 4.0 * p3;\n    float t;\n\n    vec2 res;\n\n    if (h >= 0.0)\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        t = clamp((m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n    }\n    res = vec2(dot2(d + (c + b * t) * t), t);\n    res.x = sqrt(res.x);\n    return res;\n}\n\nfloat rand31(vec3 uv)\n{\n    return fract(sin(dot(uv, vec3(12.9898, 78.233, 471.169))) * 43758.5453);\n}\n\nSDData sdTrefoil(vec3 p, uint matId, bool calculateUVs)\n{\n    SDData res;\n\n    const float treParamDelta = TAU / float(TREFOIL_SEGMENTS);\n    vec3 a, b, c;\n    vec3 bezP, bezTA, bezBT, bezNO, bezBTPrev;\n    vec3 treNormal, treNormalOut;\n    vec2 bezSD;\n    float ad, uvYShift;\n\n    vec3 trePrev = trefoil(-treParamDelta - treParamDelta);\n    vec3 treCurr = trefoil(-treParamDelta);\n    vec3 treNext = trefoil(0.0);\n\n    a = avg(trePrev, treCurr);\n    b = treCurr;\n    c = avg(treCurr, treNext);\n    bezBTPrev = normalize(cross(b - a, c - a));\n    \n    vec2 uvOut = vec2(0.0);\n    float dmin = VOID_VALUE;\n    uvYShift = 0.0;\n\n    for (int i = 0; i < TREFOIL_SEGMENTS; i++)\n    {\t\n        // grow next segment\n        treCurr = treNext;\n        treNext = trefoil(treParamDelta * (float(i) + 1.0));\n        a = c;\n        b = treCurr;\n        c = avg(treCurr, treNext);\n\n        // bezier distance\n        bezSD = sdBezier(p, a, b, c);\n\n        // uv\n        bezP = bezier(a, b, c, bezSD.y);\n        bezTA = normalize(bezierDx(a, b, c, bezSD.y));\n        bezBT = normalize(cross(b - a, c - a));\n        bezNO = normalize(cross(bezBT, bezTA));\n        treNormal = normalize(p - bezP);\n        vec2 uv0 = vec2(dot(treNormal, bezNO), dot(treNormal, bezBT));\n\n        ad = acos(dot(bezBTPrev, bezBT));\n        if ((i == 1) || (i == 5) || (i == 6) || (i == 10) || (i == (11)))  // for 15 segments\n        {\n            ad = -ad;\n        }\n        uvYShift += ad;\n        \n        float uvY = atan(uv0.y, uv0.x);\n        uvY -= uvYShift;\n        float uvX = (float(i) + bezSD.y) / float(TREFOIL_SEGMENTS);\n\n        bezBTPrev = bezBT;\n\n        // thickness\n        float d = bezSD.x - TREFOIL_THICKNESS;\n        if (d < dmin)\n        {\n            dmin = d;\n            uvOut.x = uvX;\n            uvOut.y = uvY;\n            treNormalOut = treNormal;\n        }\n    }\n\n    res.dist = dmin;\n    res.matId = matId;\n    res.uv = (calculateUVs) ? uvOut : vec2(0.0);\n    res.normal = treNormalOut;\n    return res;\n}\n\nvoid combineSD(inout SDData currentSD, SDData nextSD)\n{\n    if (nextSD.dist < currentSD.dist)\n    {\n        currentSD = nextSD;\n    }\n}\n\nSDData scene(vec3 p, Ray ray)\n{\n    SDData res = SDData0();\n    SDData nextSD = SDData0();\n\n    nextSD = sdBackPlane(p - vec3(0.0, 0.0, -1.6), MAT_BACK_PLANE);\n    combineSD(res, nextSD);\n\n    if (boxIntersection(ray, TREFOIL_BBOX))\n    {\n        nextSD = sdTrefoil(p - vec3(0.0, 0.0, 0.0), MAT_TREFOIL, false);\n        combineSD(res, nextSD);\n    }\n\n    return res;\n}\n\n// return: true if ray hit the object\nbool rayMarch(Ray ray, inout RayMarchData rmData)\n{\n    bool res = true;\n    int i = 0;\n    for (i=0; i<MAX_STEPS; i++)\n    {\n        if (rmData.marched > DIST_MAX)\n        {\n            res = false;\n            break;\n        } \n        vec3 p = ray.o + ray.d * rmData.marched;\n        SDData sdData = scene(p, ray);\n        if (sdData.dist < DIST_SURF)\n        {\n            rmData.sdData = sdData;\n            res = true;\n            break;\n        }\n        rmData.marched += sdData.dist * MARCH_FACTOR;\n    }\n    return res;\n}\n\n// return:\n//    x: distance to edge\n//    y: wave index\nvec2 triangleWave(vec2 uv, vec2 dir)\n{\n    vec2 res = vec2(0.0);\n    float w;\n    w = dot(uv, dir);\n    res.y = floor(w);\n    w = 1.0 - abs(fract(w) - 0.5) * 2.0;\n    res.x = w * 3.0 / 2.0;\n    // res.x += 1.0;\n    return res;\n}\n\n// return:\n//    x, y, z: triangle index\n//    w: distance to center\nvec4 triangleGrid(vec2 uv)\n{\n    vec4 res = vec4(0.0);\n\n    const float rad60 = 60.0 * PI / 180.0;\n    const vec2 dirA = normalize(vec2(0.0, 1.0));\n    const vec2 dirB = normalize(vec2(sin(rad60), -cos(rad60)));\n    const vec2 dirC = normalize(vec2(-sin(rad60), -cos(rad60)));\n\n    vec2 waveA = triangleWave(uv, dirA);\n    vec2 waveB = triangleWave(uv, dirB);\n    vec2 waveC = triangleWave(uv, dirC);\n\n    res.x = waveA.y;\n    res.y = waveB.y;\n    res.z = waveC.y;\n    res.w = min(min(waveA.x, waveB.x), waveC.x);\n    \n    return res;\n}\n\nvec3 trianglePattern(vec2 uv)\n{\n    vec3 res = vec3(0);\n    \n    vec4 triGrid = triangleGrid(uv);\n\n    vec3 waveDir = normalize(vec3(1.0, 0.5, -0.3));\n    float waveFreq = 0.3;\n    float waveSpeed = 1.6 * 1.0;\n    float waveCoord = dot(waveDir, triGrid.xyz);\n    float waveRandShift = 1.0;\n    float wave;\n    float triRand = rand31(triGrid.xyz * 0.001);\n    wave = sin(waveCoord * waveFreq + waveRandShift * triRand + iTime * waveSpeed);\n    wave = remaps(-1.0, 1.0, 0.0, 1.0, wave);\n\n    float scanContrast = 8.0;\n    vec2 scanWaveRemap = vec2(0.7, 0.9);\n    float scanPos = remaps(0.0, 1.0, scanWaveRemap.x, scanWaveRemap.y, wave);\n    float scan = hscan(triGrid.w, scanPos, scanContrast);\n\n    res = vec3(scan);\n    return res;\n}\n\nvec3 trianglePattern2(vec2 uv)\n{\n    vec3 res = vec3(1.0);\n\n    const vec2 cPatternSpeed = vec2(1.0, 1.0);\n    vec2 uvTimeShift = iTime * cPatternSpeed;\n    uv += uvTimeShift;\n\n    vec4 triGrid = triangleGrid(uv);\n    vec4 triGridOrigin = triangleGrid(uvTimeShift);\n\n    float waveFreq = 0.15;\n    float waveSpeed = 1.5 * 1.0;\n    float waveCoord = length(triGrid.xyz - triGridOrigin.xyz);\n    float waveRandShift = 1.2;\n    float wave;\n    float triRand = rand31(triGrid.xyz * 0.001);\n    wave = sin(waveCoord * waveFreq + waveRandShift * triRand - iTime * waveSpeed);\n    wave = remaps(-1.0, 1.0, 0.0, 1.0, wave);\n\n    float scanContrast = 8.0;\n    vec2 scanWaveRemap = vec2(0.7, 0.9);\n    float scanPos = remaps(0.0, 1.0, scanWaveRemap.x, scanWaveRemap.y, wave);\n    float scan = hscan(triGrid.w, scanPos, scanContrast);\n    res = vec3(scan);\n\n    return res;\n}\n\nvec3 samplePatternWithFilter(vec2 uv, float ssFactor, float maxSamples, uint matId)\n{\n    vec3 col = vec3(0.0);\n\n    vec2 uvDDX = dFdx(uv); \n    vec2 uvDDY = dFdy(uv); \n    vec2 uvDDXYL = vec2(length(uvDDX), length(uvDDX));\n\n    vec2 samples = 1.0 + trunc(clamp(ssFactor * uvDDXYL, 0.0, maxSamples - 1.0));\n\n    for (float j=0.0; j<samples.y; j++)\n    {\n        for (float i=0.0; i<samples.x; i++)\n        {\n            vec2 st = vec2(i, j) / samples;\n            vec3 pat = (matId == MAT_TREFOIL) ?\n                trianglePattern(uv + st.x * uvDDX + st.y * uvDDY):\n                trianglePattern2(uv + st.x * uvDDX + st.y * uvDDY);\n            col += pat; \n        }\n    }\n\n\treturn col / (samples.x * samples.y);\n}\n\nvec3 renderMatTrefoil(RenderData renderData)\n{\n    vec3 col = vec3(1.0);\n\n    vec2 uv = sdTrefoil(renderData.pos, MAT_TREFOIL, true).uv;\n    uv.y = mod(-uv.y, TAU) / TAU;\n    uv.y += uv.x * 0.3575;  // stitching ends for 15 segments\n    uv.y = fract(uv.y + 0.65);\n    uv.x = fract(uv.x - 0.065);\n\n    const vec2 cPatternTiling = vec2(256.0, 32.0) * 0.7;\n    const vec2 cPatternSpeed = vec2(0.02, 0.1) * GLOBAL_SPEED;\n    uv += iTime * cPatternSpeed;\n    uv *= cPatternTiling;\n\n    col = samplePatternWithFilter(uv, 64.0, 8.0, MAT_TREFOIL);\n\n    float fresnel = saturate(1.0 - dot(renderData.view, renderData.normal));\n    fresnel *= fresnel;\n    fresnel *= fresnel;\n    fresnel *= fresnel;\n    col = remaps(vec3(0.0), vec3(1.0), vec3(fresnel), vec3(1.0), col);\n\n    return col;\n}\n\nvec3 renderMatBack(RenderData renderData)\n{\n    vec3 col = vec3(1.0);\n    vec2 uv = renderData.uv.xy;\n\n    const vec2 cPatternTiling = vec2(4.0);\n    uv *= cPatternTiling;\n\n    col = samplePatternWithFilter(uv, 32.0, 4.0, MAT_BACK_PLANE);\n    return col;\n}\n\nvec3 renderMaterials(RenderData renderData)\n{\n    vec3 col = vec3(1.0);\n\n    switch (renderData.matId)\n    {\n        case MAT_DEFAULT:\n            break;\n\n        case MAT_BACK_PLANE:\n            col = renderMatBack(renderData);\n            break;\n\n        case MAT_TREFOIL:\n            col = renderMatTrefoil(renderData);\n            break;\n    }\n\n    return col;\n}\n\nfloat renderAO(RenderData renderData)\n{\n    const int STEPS = 4;\n    const float RANGE = 2.0;\n    const float STEP_FADE = 0.25;\n\n    Ray ray;\n    ray.o = renderData.pos;\n    ray.d = renderData.normal;\n\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i=0; i<(STEPS+1); i++)\n    {\n        float h = RANGE * float(i) / float(STEPS);\n        float d = scene(ray.o + h * ray.d, ray).dist;\n        occ += max(h - d, 0.0) * sca;\n        sca *= STEP_FADE;\n    }\n    occ = saturate(occ);\n    occ = 1.0 - occ;\n    occ *= occ;\n    occ *= occ;\n    occ *= occ;\n    occ *= occ;\n    return occ;\n}\n\nfloat renderSoftShadow(RenderData renderData, vec2 shadMinMax, float lightAngle)\n{\n    float res = 1.0;\n\n    Ray ray;\n    ray.o = renderData.pos;\n    ray.d = normalize(LIGHT_POS - ray.o);\n\n    float t = shadMinMax.x;\n    int i;\n    for (i=0; (i < MAX_STEPS_SHADOW) && (t < shadMinMax.y); i++)\n    {\n        float h = scene(ray.o + t * ray.d, ray).dist;\n        res = min(res, h / (lightAngle * t));\n        t += max(h, 0.16);\n        if (res<-1.0 || t>shadMinMax.y)\n        {\n            break;\n        }\n    }\n    res = max(res, -1.0);\n    res = 0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res);\n    return res;\n}\n\nvec3 renderLighting(RenderData renderData, Ray ray, vec3 col)\n{\n    vec3 res = vec3(0);\n\n    vec3 sunColor = srgb255toLinear(vec3(255.0, 255.0, 255.0));\n    float sunIntensity = 0.9;\n    vec3 skyColor = srgb255toLinear(vec3(180.0, 200.0, 255.0));\n    float skyIntensity = 0.14;\n    vec3 backColor = srgb255toLinear(vec3(255.0, 255.0, 255.0));\n    float backIntensity = 0.05;\n    float fresnelIntensity = 0.2;\n\n    vec3 P = renderData.pos;\n    vec3 N = renderData.normal;\n    vec3 L = normalize(LIGHT_POS - P);\n    vec3 V = -ray.d;\n    float NdotL = dot(N, L);\n\n    float sha = renderSoftShadow(renderData, vec2(0.01, 8.0), 0.1);\n    float occ = renderAO(renderData);\n    float fre = 1.0 - saturate(dot(V, N)); \n    float dif = saturate(NdotL);\n    float bac = saturate(-NdotL);\n    float sky = linsteps(-1.0, 1.0, N.y);\n\n    vec3 brdf = vec3(0.0);\n    brdf += dif * sha * sunColor * sunIntensity;\n    brdf += sky * occ * skyColor * skyIntensity;\n    brdf += bac * occ * backColor * backIntensity;\n    brdf += fre * fre * fre * remaps(0.0, 1.0, 0.1, 1.0, occ * dif) * fresnelIntensity;\n\n    res = col * brdf;\n    return res;\n}\n\nRenderData initRenderData(RayMarchData rmData, Ray ray)\n{\n    RenderData res;\n    res.pos = ray.o + ray.d * rmData.marched;\n    res.normal = rmData.sdData.normal;\n    res.view = -ray.d;\n    res.uv = rmData.sdData.uv;\n    res.matId = rmData.sdData.matId;\n    return res;\n}\n\nvec3 render(RenderData renderData, Ray ray)\n{\n    vec3 col = vec3(1.0);\n    col = renderMaterials(renderData);\n    col = renderLighting(renderData, ray, col);\n    return col;\n}\n\n#ifdef AA_ENABLED\nbool mainImage_(out vec4 fragColor, vec2 fragCoord)\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n#endif\n{\n    vec3 col = vec3(0.0);\n    bool needAA = true;\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = iTime;\n    \n    // camera and rays (z-positive goes from the screen to eye)\n    const float zoom = 1.0;\n    const float camDolly = 8.0;\n    const vec3 camInterest = vec3(0.0, 0.45, 0.0);\n    const vec2 mouseSpeed = vec2(6.0, 3.0);\n\n    vec3 camPos = vec3(0.0, 0.45, camDolly);\n    \n    // scene\n    Ray ray = rayCameraWithInterestUpWorldY(uv * zoom, camPos, camInterest);\n    RayMarchData rmData = RayMarchData0();\n    bool isHitSomething = rayMarch(ray, rmData);\n    if (isHitSomething)\n    {\n        needAA = (fwidth(rmData.marched) >= 0.04) ? true : false;\n        RenderData renderData = initRenderData(rmData, ray);\n        col = render(renderData, ray);\n    }\n\n    // out col\n    col = toSrgb(col);\n    fragColor = vec4(col,1.0);\n    #ifdef AA_ENABLED\n    return needAA;\n    #endif\n}\n\n#ifdef AA_ENABLED\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const int AA = max(AA_LEVEL, 1);\n    float A = float(AA);\n    fragColor = vec4(0.0);\n    vec4 fragCol;\n    bool needAA = true;\n    float div = 0.0;\n    for (int x=0; (x<AA) && needAA; x++)\n    {\n        for (int y=0; (y<AA) && needAA; y++)\n        {\n            vec2 s = vec2(x,y) / A;\n            s += s * 0.5 - 0.5;\n            needAA = mainImage_(fragCol, fragCoord + s);\n            fragColor += fragCol;\n            div += 1.0;\n        }\n    }\n    fragColor /= div;\n}\n#endif\n\n","name":"Image","description":"","type":"image"}]}