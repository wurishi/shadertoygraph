{"ver":"0.1","info":{"id":"fdVXWR","date":"1634473440","viewed":150,"name":"SolidTux - Newton Fractal Color","username":"SolidTux","description":"Newton fractal for 4th order polynomial with coloring according to argument of result. Drag mouse to set 4th point.","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["fractal"],"hasliked":0,"parentid":"7dyXzm","parentname":"SolidTux - Newton Fractal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 4\n#define ITER 6\n#define ITERNORM 5\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923\n\nvec2 conj(in vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\nvec2 cmul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(in vec2 a, in vec2 b) {\n    return cmul(a, conj(b))/(b.x*b.x + b.y*b.y);\n}\n\nvec2 p(in vec2 z, in vec2[N] points) {\n    vec2 res = vec2(1., 0.);\n    for (int i=0; i<N; i++) {\n        res = cmul(res, z - points[i]);\n    }\n    return res;\n}\n\nvec2 pd(in vec2 z, in vec2[N] points) {\n    vec2 res = vec2(0., 0.);\n    for (int i=0; i<N; i++) {\n        vec2 tmp = vec2(1., 0.);\n        for (int j=0; j<N; j++) {\n            if (i!=j) {\n                tmp = cmul(tmp, z - points[j]);\n            }\n        }\n        res += tmp;\n    }\n    return res;\n}\n    \n\nvec2 newton(in vec2 z, in vec2[N] points) {\n    return z - cdiv(p(z, points), pd(z, points));\n}\n\nvec2 s(in vec2 x) {\n    vec2 z = 2.*(x/iResolution.xy - 0.5);\n    z.x *= iResolution.x/iResolution.y;\n    z *= mix(0.5, 1., 0.5*(sin(iTime) + 1.));\n    return z;\n}\n\nvec3 huergb(in float hue) {\n    vec3 color;\n    float h = mod(hue, 1.);\n    float f = mod(6. * h, 1.);\n    if (6. * h < 1.)\n    {\n        color = vec3(1., f, 0.);\n    } else if (6. * h < 2.)\n    {\n        color = vec3(1. - f, 1., 0.);\n    } else if (6. * h < 3.)\n    {\n        color = vec3(0., 1., f);\n    } else if (6. * h < 4.)\n    {\n        color = vec3(0., 1. - f, 1.);\n    } else if (6. * h < 5.)\n    {\n        color = vec3(f, 0., 1.);\n    } else\n    {\n        color = vec3(1., 0., 1. - f);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 z = s(fragCoord);\n    \n    // points and colors\n    vec2 points[N];\n    points[0] = vec2(sin(2.02*iTime), 0.62*cos(1.2*iTime)) + vec2(0.1, 2.);\n    points[1] = vec2(-1.76*sin(0.3*iTime), 1.3*cos(1.01*iTime)) + vec2(-0.7, 0.1);\n    points[2] = vec2(1.33*sin(1.02*iTime), -0.3*cos(1.7*iTime)) + vec2(0.3, -0.12);\n    if (iMouse.z > 0.) {\n        points[3] = s(iMouse.xy);\n    } else {\n        points[3] = vec2(0.11*sin(1.31*iTime), 0.05*cos(0.72*iTime)) + vec2(1.31, 0.1);\n    }\n    \n    // iterations\n    float dis = 2.;\n    float scale = 1.;\n    for (int i=0; i<ITER; i++) {\n        z = newton(z, points);\n        for (int i=0; i<N; i++) {\n            float cur = length(z - points[i]);\n            if (cur < dis) {\n                dis = cur;\n            }\n        }\n        if (dis < 0.05) {\n            scale = mix(0.1, 1., float(clamp(i, 0, ITERNORM-1))/float(ITERNORM-1));\n            break;\n        }\n    }\n    \n    // set color\n    float r = length(z);\n    float phi = 0.5*(1.+atan(z.y, z.x)/PI);\n    vec3 col = scale * huergb(phi);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}