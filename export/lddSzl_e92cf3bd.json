{"ver":"0.1","info":{"id":"lddSzl","date":"1461003766","viewed":329,"name":"First Attempt - Ray Marching","username":"Icohedron","description":"My first attempt at Distance Field Ray Marching after a few hours of research on the topic, as well as trial and error.\nI'm a newbie so don't be so harsh! Feedback is highly appreciated!","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","distancefield","phong","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Distance Field Ray Marching\n * Made by Icohedron\n *\n * I'm still learnin'.\n * The journey is more important than what you get in the end.\n *\n * Big thanks to Inigo Quilez's excellent articles and presentations\n * https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n * https://iquilezles.org/articles/rmshadows\n * https://iquilezles.org/articles/distfunctions\n *\n * I do not claim ownership for any of the code used below. (Variations of it have been used soooo many times already so...)\n * Feel free to use it yourself.\n\n * Tips? Tricks? Feedback is highly appreciated!\n */\n\n#define FOV 90.0\n#define MAX_STEPS 64\n#define STEP_PRECISION 0.001\n#define NORMAL_PRECISION  0.001\n#define SHININESS 8.0\n#define CLIP_FAR 32.0\n#define AO_SAMPLES 5.0\n#define SHADOW_ITERATIONS 32\n#define FOG_MULTIPLIER 0.08\n\n//// Primitive Shapes / Distance Fields ////\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdPlaneXZ(vec3 p) {\n\treturn p.y;\n}\n\n// 3D Fractal - \"Mandebulb\" by Mikael Hvidtfeldt Christensen\n// from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandelbulb(vec3 p) {\n\tvec3 z = p;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 32 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, 8.0-1.0)*8.0*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,8.0);\n\t\ttheta = theta*8.0;\n\t\tphi = phi*8.0;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=p;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n//// The Scene / Combined Distance Fields ////\n\nfloat map(vec3 p) {\n    float dist = sdPlaneXZ(p - vec3(1.0, -1.0, 0.0));\n    dist = min(dist, udRoundBox(p - vec3(-1.0, 0.0, 0.75), vec3(0.8), 0.1));\n    dist = min(dist, sdSphere(p - vec3(1.5, 0.0, 0.75), 1.0));\n    dist = min(dist, mandelbulb(p - vec3(0.0, 0.0, -1.5)));\n    return dist;\n}\n\n//// Distance Field Ray Marching ////\n\nfloat march(vec3 rOrigin, vec3 rDirection) {\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rOrigin + rDirection * totalDistance;\n        float dist = map(p);\n        totalDistance += dist;\n        if (dist < STEP_PRECISION) break;\n    }\n    return totalDistance;\n}\n\n//// Calculate Surface Normal ////\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(NORMAL_PRECISION, 0.0, 0.0)) - map(p - vec3(NORMAL_PRECISION, 0.0, 0.0)),\n        map(p + vec3(0.0, NORMAL_PRECISION, 0.0)) - map(p - vec3(0.0, NORMAL_PRECISION, 0.0)),\n        map(p + vec3(0.0, 0.0, NORMAL_PRECISION)) - map(p - vec3(0.0, 0.0, NORMAL_PRECISION))\n    ));\n}\n\n//// Ambient Occlusion ////\n\nfloat calcAmbientOcclusion(vec3 p, vec3 surfaceNormal) {\n   float r = 0.0;\n   float w = 1.0;\n   for (float i = 0.0; i <= AO_SAMPLES; i++)\n   {\n      float d0 = i / AO_SAMPLES;\n      r += w * (d0 - map(p + surfaceNormal * d0));\n      w *= 0.3;\n   }\n   return 1.0 - clamp(r, 0.0, 1.0);\n}\n\n//// Soft Shadows ////\n\nfloat softShadow(vec3 rOrigin, vec3 rDirection, float start, float end, float k) {\n\tfloat shade = 1.0;\n    float dist = start;\n    float stepDistance = end / float(SHADOW_ITERATIONS);\n    for(int i = 0; i < SHADOW_ITERATIONS; i++) {\n\t\tfloat h = map(rOrigin + rDirection * dist);\n        shade = min(shade, k * h / dist);\n        dist += clamp(h, 0.02, 0.1);\n        if (h < 0.001 || dist > end) break;\n    }\n    return clamp(shade, 0.0, 1.0);\n}\n\n//// Fog ////\n\nvoid applyFog(inout vec3 color, vec3 fogColor, float dist) {\n    float fogFactor = 1.0 - exp(-dist * FOG_MULTIPLIER);\n    color = mix(color, fogColor, fogFactor);\n}\n\n//// Phong Lighting /////\n\nvoid calcLighting(inout vec3 color, vec3 surfacePos, vec3 cameraPos) {\n    vec3 lightPos = vec3(3.0 * cos(0.75 * iTime), 2.0, 3.0 * sin(0.75 * iTime));\n    vec3 lightColor = vec3(0.9, 0.8, 0.75);\n    float lightIntensity = 2.0;\n    \n    vec3 surfaceNormal = getNormal(surfacePos);\n    vec3 lightVector = lightPos - surfacePos;\n    float distanceToLight = length(lightVector);\n    float attenuation = lightIntensity * min(1.0 / distanceToLight, 1.0);\n    lightVector = normalize(lightVector);\n    vec3 viewDirection = normalize(cameraPos - surfacePos);\n    \n    float NdotL = max(0.0, dot(surfaceNormal, lightVector));\n    float ambient = 0.1;\n    float diffuse = NdotL;\n    float specular = NdotL * pow(max(0.0, dot(reflect(-lightVector, surfaceNormal), viewDirection)), SHININESS);\n    \n    float ambientOcclusion = calcAmbientOcclusion(surfacePos, surfaceNormal);\n    float shadow = softShadow(surfacePos, lightVector, 0.02, distanceToLight, 16.0);\n    \n    color = max((ambient + ((diffuse + specular) * attenuation * lightColor)) * ambientOcclusion * shadow * color, ambient * ambientOcclusion * color);\n}\n\n//// MAIN FUNCTION ////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cPosition = normalize(vec3(sin(0.5 * iTime), 1.0, cos(0.5 * iTime))) * 4.0;\n    \n    vec3 cForward = normalize(cLookAt - cPosition);\n    vec3 cRight = normalize(cross(cForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cUp = normalize(cross(cForward, -cRight));\n    \n    float fovFactor = tan(radians(FOV / 2.0));\n    \n    vec3 cROrigin = cPosition;\n    vec3 cRDirection = normalize(cForward + cRight * uv.x * fovFactor + cUp * uv.y * fovFactor);\n    \n    float dist = march(cROrigin, cRDirection);\n    \n    vec3 fogColor = vec3(0.0);\n    if (dist >= CLIP_FAR) {\n        fragColor = vec4(fogColor, 0.0);\n        return;\n    }\n    \n    vec3 color = vec3(1.0);\n    calcLighting(color, cROrigin + cRDirection * dist, cPosition);\n    applyFog(color, fogColor, dist);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}