{"ver":"0.1","info":{"id":"X32fRG","date":"1730370151","viewed":36,"name":"Computer Graphics Class Project","username":"PedroBarao","description":"Project for Computer Graphics class","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["educational"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise1d(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat noise2To1(vec2 v) {\n    vec2 i = floor(v);\n    vec2 f = fract(v);\n    f = f*f*(3.0-2.0*f);\n    \n    float a = noise1d(i.x + i.y*57.0);\n    float b = noise1d(i.x + 1.0 + i.y*57.0);\n    float c = noise1d(i.x + (i.y + 1.0)*57.0);\n    float d = noise1d(i.x + 1.0 + (i.y + 1.0)*57.0);\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec3 randomColor(vec2 v){\n    return vec3(noise1d(v.x), noise1d(v.y), noise1d(v.x + v.y));\n}\n\nvec3 noise1To3(float k){\n    return vec3(noise1d(k), noise1d(k + 1.0), noise1d(k + 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    uv -= 0.5;\n    uv.x /= ratio;\n    \n    // Number of grid cells along x and y\n    float gridCount = 5.0;  // Increase grid size for more blobs\n    \n    // Scale UV to grid space\n    uv *= gridCount;\n    \n    // Use fract to get the fractional part of uv, creating a repeating grid\n    vec2 gridUV = fract(uv) - 0.5;\n    \n    // Determine the current cell by taking the floor of uv\n    vec2 cellID = floor(uv);\n    \n    // Circle radius and smoothstep parameters\n    float r = 0.001;\n    float k = 0.15;\n    \n    // Use noise1d to randomize the movement of blobs in each grid cell\n    float timeOffsetX = noise1d(cellID.x * 10.0 + cellID.y) * 6.2831;  // Randomize X movement\n    float timeOffsetY = noise1d(cellID.y * 10.0 + cellID.x) * 6.2831;  // Randomize Y movement\n    \n    // Randomized center position for each blob using noise1d\n    vec2 center1 = vec2(sin(iTime*noise1d(cellID.x) + timeOffsetX) * 0.3, cos(iTime + timeOffsetY) * 0.3);\n    vec2 center2 = vec2(sin(iTime*noise1d(cellID.x) + timeOffsetX + 1.0) * 0.2, cos(iTime + timeOffsetY + 1.0) * 0.2);\n    vec2 center3 = vec2(sin(iTime*noise1d(cellID.x) + timeOffsetX + 2.0) * 0.1, cos(iTime + timeOffsetY + 2.0) * 0.1);\n    vec2 center4 = vec2(sin(iTime*noise1d(cellID.x) + timeOffsetX + 3.0) * 0.1, cos(iTime + timeOffsetY + 3.0) * 0.1);\n\n    float sizeOffset1 = 0.1;// noise1d(cellID.x + cellID.y) * 0.1 + abs(sin(iTime))*0.005+0.01;\n    float sizeOffset2 = 0.1;// noise1d(cellID.x + cellID.y + 1.0) * 0.1 + abs(sin(0.8*iTime+1.0))*0.005+0.01;\n    float sizeOffset3 = 0.1;// noise1d(cellID.x + cellID.y + 2.0) * 0.1 + abs(sin(iTime + 2.0))*0.005+0.01;\n    float sizeOffset4 = 0.1;// noise1d(cellID.x + cellID.y + 3.0) * 0.1 + abs(sin(iTime + 3.0))*0.005+ 0.01;\n    \n    // Draw the blobs at randomized centers\n    float circle1 = smoothstep(\n        r + sizeOffset1+ k,\n        r + sizeOffset1,\n        length(gridUV - center1)\n    );\n    float circle2 = smoothstep(\n        r + sizeOffset2 + k,\n        r + sizeOffset2,\n        length(gridUV - center2)\n    );\n    float circle3 = smoothstep(\n        r + sizeOffset3 + k,\n        r + sizeOffset3,\n        length(gridUV - center3)\n    );\n    float circle4 = smoothstep(\n        r + sizeOffset4 + k,\n        r + sizeOffset4,\n        length(gridUV - center4)\n    );\n    \n    // Combine the circles (you can add more if needed)\n\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n\n    vec3 randomColor1 = mix(red, green, noise1d(cellID.x + cellID.y));\n    vec3 randomColor2 = mix(blue, yellow, noise1d(cellID.x + cellID.y + 1.0));\n    vec3 randomColor3 = mix(red, blue, noise1d(cellID.x + cellID.y + 2.0));\n    vec3 randomColor4 = mix(green, yellow, noise1d(cellID.x + cellID.y + 3.0));\n\n    vec3 finalCircleColor = circle1 * randomColor1 + circle2 * randomColor2 + circle3 * randomColor3 + circle4 * randomColor4;\n\n    finalCircleColor = finalCircleColor * finalCircleColor;\n    // Adjust the smoothstep for blob intensity\n    finalCircleColor = smoothstep(0.2, 0.5, finalCircleColor);\n\n\n    fragColor = vec4(finalCircleColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}