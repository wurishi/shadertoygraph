{"ver":"0.1","info":{"id":"ctV3zd","date":"1684485196","viewed":69,"name":"Lava lamp animation (DAYMODE)","username":"pwr_studio","description":"Based on:\nhttps://www.shadertoy.com/view/WttyRX","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["lavalamp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Configuration variables\nfloat left_offset = 0.005;  // Offset from the left\nfloat max_width = 0.7;      // Maximum width that blobs can travel\nint num_stationary_blobs = 30; // Number of stationary blobs\nint num_moving_blobs = 60;    // Number of moving blobs\nfloat thresh = 3000.;    // Threshold for metaball effect\n\n// Blob colors\nvec3 blob_color_center = vec3(144, 255, 54)/256.;\nvec3 blob_color_edge = vec3(127, 255, 64)/256.;\n// Background color\nvec3 bg_col = vec3(240, 245, 240)/256.;\n    \n// Random number generator\nfloat rand(int i) {\n    return fract(sin(float(i)*1.2564)*43758.5453);\n}\n\n// Function to get a random float between two values (a and b)\nfloat randomInRange(int seed, float a, float b) {\n    // The seed value is used to get a random number\n    float random = fract(sin(float(seed)*1.2564)*43758.5453);\n    // Convert this random number to the desired range [a, b]\n    float result = a + random * (b - a);\n    return result;\n}\n\n// Generate stationary blob data\nvec3 get_stationary_blob(int i, float time){\n    // Random size for each blob\n    float blob_size = randomInRange(i*100, 0.09, 0.11) + rand(i*100) * 0.1;\n    // Random position for each blob, clustered near the left\n    vec2 center = vec2(left_offset + left_offset * rand(i*100000), rand(i*10000));\n    // Return the blob data (center position and size)\n    return vec3(center.xy,blob_size);\n}\n\n// Generate moving blob data\nvec3 get_moving_blob(int i, float time){\n    // Random moving speed for each blob\n    float move_speed = 0.0005 + rand(i*10) * 0.06;\n    // Random size for each blob\n    float blob_size = randomInRange(i*100, 0.06, 0.14) + rand(i*100) * 0.1;\n    // Random time offset for each blob\n    float time_offset = rand(i*1000) * 3.14159 * 2.0;\n    // Random initial position for each blob, clustered near the left\n    vec2 center = vec2(left_offset + left_offset * rand(i*100000), rand(i*10000));\n    // Moving factor: the blob moves quickly in the beginning, then slows down, stops, and starts moving back\n    float moving_factor = sin(time*move_speed - time_offset);\n    // Apply the moving factor to the x coordinate\n    center.x += max_width * moving_factor;\n    // Return the blob data (center position and size)\n    return vec3(center.xy,blob_size);\n}\n\n// Main rendering function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n\n\n\n    // Normalize the fragment coordinates\n    vec2 uv = fragCoord/iResolution.xy;   \n    // Correct the aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    // Distance sum for metaball effect\n    float dist_sum = 0.;\n\n    // Generate and render stationary blobs\n    for (int  i = 0; i < num_stationary_blobs; i++){      \n        vec3 blob = get_stationary_blob(i,iTime);\n        float radius = blob.z;\n        vec2 center = blob.xy;       \n        // Correct the aspect ratio for the blob's center\n        center.x *= aspect;\n        // Calculate distance to blob center\n        float dist_to_center = max(length(center - uv)+radius/2.,0.);\n        // Calculate distance sum\n                // Calculate distance sum for metaball effect\n        float tmp =  (dist_to_center * dist_to_center) ;\n        dist_sum += 1. / (tmp*tmp);   \n    }\n\n    // Generate and render moving blobs\n    for (int  i = 0; i < num_moving_blobs; i++){      \n        vec3 blob = get_moving_blob(i,iTime);\n        float radius = blob.z;\n        vec2 center = blob.xy;       \n        // Correct the aspect ratio for the blob's center\n        center.x *= aspect;\n        // Calculate distance to blob center\n        float dist_to_center = max(length(center - uv)+radius/2.,0.);\n        // Calculate distance sum for metaball effect\n        float tmp =  (dist_to_center * dist_to_center) ;\n        dist_sum += 1. / (tmp*tmp);   \n    }\n    \n    // Start with background color\n    fragColor = vec4(bg_col, 1); \n\n    // Apply metaball effect\n    if (dist_sum > thresh){\n        // Calculate smooth transition from blob center to edge\n        float t = smoothstep(thresh, 0., dist_sum-thresh);\n        // Interpolate color between blob center and edge\n        vec3 col = mix(blob_color_center, blob_color_edge, t);\n        // Set fragment color\n        fragColor = vec4(col, 1);\n    }   \n}\n","name":"Image","description":"","type":"image"}]}