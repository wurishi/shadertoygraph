{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// complex multiplication\nvec2 cdiv(vec2 a, vec2 b) {\n    return cmul(a, conj(b)) / dot(b, b);\n}\n\nfloat simpleVectorPlot(vec2 uv, vec2 vec) {\n    return smoothstep(0.1, 0., 1.-float(length(vec) >  1e-3) + abs(dot(fract(uv*16.)-0.5, normalize(vec2(-vec.y, vec.x)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x;\n    vec2 mp = (2.*iMouse.xy-iResolution.xy)/iResolution.x;\n    vec2 mp0 = (2.0*texture(iChannel0, vec2(.5,.5)).xy - 1.0)*iResolution.xy/iResolution.x;\n    if (iMouse == vec4(0)) { // fair enough, a demo\n        mp = sin(vec2(1.8,2.5) * iTime) * .3;\n        mp0 = vec2(0.0,0.0);\n    }\n    \n    float d = length(uv - mp);\n    float sharp = 20.;\n    vec2 cloth_uv = uv - (mp-mp0) * exp(-sharp*d*d);\n    // analytic derviatives, because I need numeric derivatives later\n    vec2 partial1 = vec2(1.,0.) - (mp-mp0) * -sharp*2.*(uv.x-mp.x)*exp(-sharp*d*d);\n    vec2 partial2 = vec2(0.,1.) - (mp-mp0) * -sharp*2.*(uv.y-mp.y)*exp(-sharp*d*d);\n    mat2 cloth_stretch = mat2(partial1, partial2);\n    // compute eigenvalues and eigenvectors of the stretch\n    float p = (cloth_stretch[0][0] + cloth_stretch[1][1])/2.;\n    float q = determinant(cloth_stretch);\n    float stretch = sqrt(max(0.0, p*p - q));\n    float lambda1 = p + stretch;\n    float lambda2 = p - stretch;\n    vec2 ev11 = vec2(cloth_stretch[0][1], lambda2 - cloth_stretch[0][0]);\n    vec2 ev12 = vec2(lambda2 - cloth_stretch[1][1], cloth_stretch[1][0]);\n    vec2 ev21 = vec2(cloth_stretch[0][1], lambda1 - cloth_stretch[0][0]);\n    vec2 ev22 = vec2(lambda1 - cloth_stretch[1][1], cloth_stretch[1][0]);\n    vec2 ev1 = ev11;//(cloth_stretch[0][1] != 0.) ? ev11 : ev12;\n    vec2 ev2 = ev22;//(length(ev21) > length(ev22)) ? ev21 : ev22;\n    \n    // special positioning of the stripes to follow mp0\n    vec2 stripes = fract((cloth_uv - mp0 * 0.8)*4.) - 0.5;\n    \n    vec3 col = vec3(0.0);\n    // NOTE: these normalisations sometimes cause stability issues\n    vec2 n1 = normalize(ev2);\n    vec2 n2 = normalize(vec2(-ev1.y, ev1.x));\n    vec2 n = n1;\n    //vec2 c1 = cexp(vec2(0.,abs(dot(uv, n1)*10.)));\n    //vec2 c2 = cexp(vec2(0.,abs(dot(uv, n2)*120.)));\n    //col.xy = vec2(cdiv(c2, c1).x * stretch * 2.);\n    vec2 stripes1 = cos(stripes.xy*3.1415*2.);\n    vec2 stripes2 = cos((stripes.xy+vec2(stripes.y, -stripes.x))*3.1415*2.);\n    //stripes2 = (stripes2.xy + vec2(-stripes2.y, stripes2.x)) * 0.7071;\n    float c1 = sqr(stripes1 * n2);\n    vec2 n3 = (n2.xy+vec2(n2.y, -n2.x))*0.7071;\n    float c2 = sqr(stripes2 * n3);\n    float z = max(0.0, mix(c1, c2, min(abs(n2.x), abs(n2.y))) * stretch*stretch * 7.);\n    \n    // rendering\n    vec2 df = vec2(dFdx(z), dFdy(z));\n    vec3 normal = vec3(df, sqrt(1.0-dot(df, df)));\n    col.xyz = vec3(1.0)*(sqr(max(0.0, dot(normal, vec3(0.3, 0.6, 1.0))))*0.7+0.3);//*(max(0.0, length(df))+0.5);\n    //col.xyz = vec3(stretch);\n    //col.xyz = vec3(simpleVectorPlot(uv, ev1));\n    col.xyz *= 1.0 - 0.01*max(step(fract(cloth_uv.x * 20.0), 0.1), step(fract(cloth_uv.y * 20.0), 0.1));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec2 in_circle(vec2 pos, vec2 cpos, float r) {\n    vec2 rpos = pos - cpos;\n    float overshoot = length(rpos) - r;\n    if (overshoot > 0.0) {\n        return pos - normalize(rpos) * overshoot;\n    }\n    return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iFrame == 0) {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n    else if (iMouse.w > 0.0) {\n        fragColor = vec4(m,0.0,0.0);\n    }\n    else {\n        fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n        fragColor.xy = in_circle(fragColor.xy*iResolution.xy/iResolution.x, m*iResolution.xy/iResolution.x, 0.2)/iResolution.xy*iResolution.x;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"slXXWn","date":"1734469788","viewed":74,"name":"Pull Cloth","username":"weasel","description":"cloth wrinkles based on uv stretch (jacobian matrix of distortion)\nUse your mouse to pull the cloth.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["cloth"],"hasliked":0,"parentid":"","parentname":""}}