{"ver":"0.1","info":{"id":"stVXRy","date":"1641036221","viewed":89,"name":"3D PerlinNoise","username":"yoshimune","description":"Reference:\nhttps://postd.cc/understanding-perlin-noise/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 定数 ======================================================\n\nconst float scale1 = 3.0;\nconst float scale2 = 12.0;\n\nconst float intensity1 = 1.0;\nconst float intensity2 = 0.2;\n\nconst float speed1 = 0.25;\nconst float speed2 = 0.5;\n\nconst int repeat = 16;\n#define F_REPEAT float(repeat)\n\n// 擬似ランダムテーブル\nint[256] randomTable = int[](\n    151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n\n);\n\n// 勾配ベクトルテーブル\nvec3[12] gradTable = vec3[](\n    vec3(1.0,1.0,0.0),vec3(-1.0,1.0,0.0),vec3(1.0,-1.0,0.0),vec3(-1.0,-1.0,0.0),\n    vec3(1.0,0.0,1.0),vec3(-1.0,0.0,1.0),vec3(1.0,0.0,-1.0),vec3(-1.0,0.0,-1.0),\n    vec3(0.0,1.0,1.0),vec3(0.0,-1.0,1.0),vec3(0.0,1.0,-1.0),vec3(0.0,-1.0,-1.0)\n);\n\n\n\n// Hash =========================================================\n\nint inc(int n)\n{\n    return int(mod(float(n+1), F_REPEAT));\n}\n\nint[8] Hash(vec3 position)\n{\n    float x = mod(position.x, F_REPEAT);\n    float y = mod(position.y, F_REPEAT);\n    float z = mod(position.z, F_REPEAT);\n\n    int xi = int(clamp(floor(x), 0.0, 255.0));\n    int yi = int(clamp(floor(y), 0.0, 255.0));\n    int zi = int(clamp(floor(z), 0.0, 255.0));\n    \n\n    return int[](\n        randomTable[randomTable[randomTable[xi]+yi]+zi],                // 0:aaa\n        randomTable[randomTable[randomTable[xi]+inc(yi)]+zi],           // 1:aba\n        randomTable[randomTable[randomTable[xi]+yi]+inc(zi)],           // 2:aab\n        randomTable[randomTable[randomTable[xi]+inc(yi)]+inc(zi)],      // 3:abb\n        randomTable[randomTable[randomTable[inc(xi)]+yi]+zi],           // 4:baa\n        randomTable[randomTable[randomTable[inc(xi)]+inc(yi)]+zi],      // 5:bba\n        randomTable[randomTable[randomTable[inc(xi)]+yi]+inc(zi)],      // 6:bab\n        randomTable[randomTable[randomTable[inc(xi)]+inc(yi)]+inc(zi)]  // 7:bbb\n    );\n}\n\n\n// grad =========================================================\n// 計算の簡略化のため、勾配ベクトルを求めることと\n// 勾配ベクトルと距離ベクトルの内積をとることを同時に行っている\nfloat gradDot(int hash, vec3 position)\n{\n    int key = int(mod(float(hash), 16.0));\n    if(key == 0) { return position.x+position.y; }\n    if(key == 1) { return -position.x+position.y; }\n    if(key == 2) { return position.x-position.y; }\n    if(key == 3) { return -position.x-position.y; }\n    if(key == 4) { return position.x+position.z; }\n    if(key == 5) { return -position.x+position.z; }\n    if(key == 6) { return position.x-position.z; }\n    if(key == 7) { return -position.x-position.z; }\n    if(key == 8) { return position.y+position.z; }\n    if(key == 9) { return -position.y+position.z; }\n    if(key == 10) { return position.y-position.z; }\n    if(key == 11) { return -position.y-position.z; }\n    if(key == 12) { return position.y+position.x; }\n    if(key == 13) { return -position.y+position.z; }\n    if(key == 14) { return position.y-position.x; }\n    if(key == 15) { return -position.x-position.z; }\n    \n    return 0.0;\n}\n\n\n// fade =========================================================\n\nfloat fade(float t)\n{\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n// Perlin Noise =================================================\n\nfloat perlinNoise(vec3 position)\n{\n    int[8] h = Hash(position);\n    float xf = fract(position.x);\n    float yf = fract(position.y);\n    float zf = fract(position.z);\n\n    float u = fade(xf);\n    float v = fade(yf);\n    float w = fade(zf);\n\n\n    float x1 = mix(\n        gradDot(h[0], vec3(xf, yf, zf)),\n        gradDot(h[4], vec3(xf-1.0, yf, zf)),\n        u);\n            \n    float x2 = mix(\n        gradDot(h[1], vec3(xf, yf-1.0, zf)),\n        gradDot(h[5], vec3(xf-1.0, yf-1.0, zf)),\n        u);\n    \n    float y1 = mix(x1, x2, v);\n    \n    x1 = mix(\n        gradDot(h[2], vec3(xf, yf, zf-1.0)),\n        gradDot(h[6], vec3(xf-1.0, yf, zf-1.0)),\n        u);\n            \n    x2 = mix(\n        gradDot(h[3], vec3(xf, yf-1.0, zf-1.0)),\n        gradDot(h[7], vec3(xf-1.0, yf-1.0, zf-1.0)),\n        u);\n    \n    float y2 = mix(x1, x2, v);\n\n    return mix(y1, y2, w)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    uv = (uv * 2.0) - vec2(1.0, 1.0);              // -1 to 1\n    uv = uv * vec2(aspect, 1.0);\n    \n    float n1 = perlinNoise(vec3(uv.x * scale1, uv.y * scale1, iTime * speed1)) * intensity1;\n    float n2 = perlinNoise(vec3(uv.x * scale2, uv.y * scale2, iTime * speed2)) * intensity2;\n    float n = (n1+n2) * (1.0/(intensity1 + intensity2));\n    \n    n = (n + 1.0) * 0.5;   // 0 to 1\n    \n    fragColor = vec4(n,n,n,1.0);\n}","name":"Image","description":"","type":"image"}]}