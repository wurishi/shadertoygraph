{"ver":"0.1","info":{"id":"dlXBWN","date":"1692928320","viewed":43,"name":"SDF Gaussian Curvature","username":"sjz1","description":"find the Gaussian Curvature of sdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","gaussian","curvature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 originalPos;\nconst float EPSILON_MIN=0.0005;\nconst float EPSILONS=0.00001;\n\nfloat DE(vec3 p){\n    p=rot(p,vec3(iTime));\n    float d=min(sdSphere(p,1.),sdBox(p,vec3(0.5,0.5,2)));\n    d=min(d,sin(p.y*4.)*0.125+sdCone(p,vec2(1,1),2.));\n    return d;\n}\n\nfloat calcK(vec3 ro){//Gaussian Curvature\n\n    float EPSILON=max(EPSILONS*distance(ro,originalPos)*10.,EPSILON_MIN*5.);\n    \n    vec3 p=(vec3(1,1,1))*EPSILON;\n    vec3 q=(vec3(1,-1,-1))*EPSILON;\n    vec3 r=(vec3(-1,-1,1))*EPSILON;\n    vec3 s=(vec3(-1,1,-1))*EPSILON;\n    float s1=DE(ro+p+p);\n    float s2=DE(ro+p+q);\n    float s3=DE(ro+p+r);\n    float s4=DE(ro+p+s);\n    float s5=DE(ro+q+q);\n    float s6=DE(ro+q+r);\n    float s7=DE(ro+q+s);\n    float s8=DE(ro+r+r);\n    float s9=DE(ro+r+s);\n    float s10=DE(ro+s+s);\n    \n    mat3 H;\n    \n    vec3 p_=(vec3(1,1,1));\n    vec3 q_=(vec3(1,-1,-1));\n    vec3 r_=(vec3(-1,-1,1));\n    vec3 s_=(vec3(-1,1,-1));\n    \n    //Hessian\n    H[0]= (p_*(s1*p_+s2*q_+s3*r_+s4*s_).x\n           +q_*(s2*p_+s5*q_+s6*r_+s7*s_).x\n           +r_*(s3*p_+s6*q_+s8*r_+s9*s_).x\n           +s_*(s4*p_+s7*q_+s9*r_+s10*s_).x\n            );\n    H[1]= (p_*(s1*p_+s2*q_+s3*r_+s4*s_).y\n           +q_*(s2*p_+s5*q_+s6*r_+s7*s_).y\n           +r_*(s3*p_+s6*q_+s8*r_+s9*s_).y\n           +s_*(s4*p_+s7*q_+s9*r_+s10*s_).y\n            );\n    H[2]=  (p_*(s1*p_+s2*q_+s3*r_+s4*s_).z\n           +q_*(s2*p_+s5*q_+s6*r_+s7*s_).z\n           +r_*(s3*p_+s6*q_+s8*r_+s9*s_).z\n           +s_*(s4*p_+s7*q_+s9*r_+s10*s_).z\n            );\n    H/=2.*EPSILON;\n    \n    vec3 dDE=(s1*p_+s5*q_+s8*r_+s10*s_);\n    mat4 K=mat4(H[0][0],H[1][0],H[2][0],dDE.x,\n                H[0][1],H[1][1],H[2][1],dDE.y,\n                H[0][2],H[1][2],H[2][2],dDE.z,\n                dDE.x,dDE.y,dDE.z,0\n                );\n    return -determinant(K)/pow(dot(dDE,dDE),2.);\n    //Normal Curvature\n    /*vec3 dDE=s1*p+s5*q+s8*r+s10*s;\n    vec3 N=cross(n,dDE);\n    float t1=dot(p,N);\n    float t2=dot(q,N);\n    float t3=dot(r,N);\n    float t4=dot(s,N);\n    \n    float k=2/(dot(p,p)*pow(length(N),3));\n    k*=s1*t1*t1+s5*t2*t2+s8*t3*t3+s10*t4*t4\n        +2*(s2*t1*t2+s3*t1*t3+s4*t1*t4+s6*t2*t3+s7*t2*t4+s9*t3*t4);\n    return k*0.75;*/\n}\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\nfloat raycast( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro, rd, vec3(5) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<100 && t<tmax; i++ )\n        {\n            float h = DE( ro+rd*t );\n            if( abs(h)<(0.0001*t) )\n            { \n                res = t;\n                break;\n            }\n            t += h;\n        }\n    }\n    \n    return res;\n}\n// https://iquilezles.org/articles/normalsSDF\n#define ZERO (min(iFrame,0))\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*DE( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*DE( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*DE( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*DE( pos + e.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*DE(pos+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec2 Projection(vec2 p,float S){\n    #ifdef SphereProjection\n        if(length(p)==0) return p;\n        return normalize(p)*tan(length(p)*S);\n    #else\n        return p*S;\n    #endif\n}\nconst float FOV=0.5;\nvec3 F(float x,float y,vec3 Eye_Direction,vec3 Position){\n    vec3 n=normalize((rot(vec3(Projection(vec2(x,y),FOV),1),Eye_Direction)).xyz);\n    vec3 pos=Position;\n    originalPos=pos;\n    float t=raycast(pos,n);\n    if(t<-0.5) return vec3(0);\n    vec3 p=pos+t*n;\n    \n    float k=calcK(p);\n    return vec3(max(0.,k),max(0.,-k),0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv00=uv;\n    vec3 m=vec3(0,0,0);\n    vec3 p=vec3(0,0,-9);\n    vec3 col=F(2.*uv.x-1.,(2.*uv.y-1.)/iResolution.x*iResolution.y,m,p);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec2 rot(vec2 a,float theta){\n    return a.xx*vec2(cos(theta),sin(theta))+a.yy*vec2(-sin(theta),cos(theta));\n}\nvec3 rot(vec3 a,vec3 angle){\n    a.yz=rot(a.yz,angle.x);\n    a.xz=rot(a.xz,angle.y);\n    a.xy=rot(a.xy,angle.z);\n    return a;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdSphere(vec3 p,float r){\n    return length(p)-r;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p=abs(p)-b;\n  vec3 q=abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}","name":"Common","description":"","type":"common"}]}