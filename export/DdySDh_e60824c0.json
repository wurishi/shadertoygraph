{"ver":"0.1","info":{"id":"DdySDh","date":"1681605671","viewed":399,"name":"Collision Response V5","username":"mikolalysenko","description":"Now with rotations!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["collision","sdf","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contact detection code by Mikola Lysenko\n//\n//\n// Rendering code based on \"RayMarching starting point\" https://www.shadertoy.com/view/WtGXDD\n//      Martijn Steinrucken aka The Art of Code/BigWings - 2020\n\n\n#define CONTACT_ITERS 10\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\n// animation state\n\nbool hit = false;    \nvec3 qA = vec3(0);\nvec3 qB = vec3(0);\nvec3 minHit = vec3(0.);\n\n// body a state\nvec3 posA = vec3(0., 0., 0.);     // position\nvec4 rotA = vec4(0., 0., 0., 1.); // quaternion\nfloat mInvA = 0.;                 // inverse mass\nmat3 rInvA = mat3(                // inverse inertia tensor\n    0., 0., 0.,\n    0., 0., 0.,\n    0., 0., 0.);\n\n// a position shift\nvec3 linA = vec3(0., 0., 0.);     // relative translation update\nvec4 torA = vec4(0., 0., 0., 1.); // relative rotation update (multiplied)\n\n\n// body b state\nvec3 posB = vec3(0., 0., 0.);      // position\nvec4 rotB = vec4(0., 0., 0., 1.);  // quaternion\nfloat mInvB = 1.;                  // inverse mass\nmat3 rInvB = mat3(                 // inverse inertia tensor\n    1., 0., 0.,\n    0., 1., 0.,\n    0., 0., 1.);\n\n// b position shift\nvec3 linB = vec3(0., 0., 0.);\nvec4 torB = vec4(0., 0., 0., 1.);\n\n\n// quaternion subroutines\nvec4 quatMult(vec4 q1, vec4 q2) {\n    vec3 crossProduct = cross(q1.xyz, q2.xyz);\n    float dotProduct = dot(q1.xyz, q2.xyz);\n    return vec4(crossProduct + q1.w * q2.xyz + q2.w * q1.xyz, q1.w * q2.w - dotProduct);\n}\nvec4 quatConjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\nvec3 quatTransformVec(vec4 quat, vec3 vec) {\n    return quatMult(quatMult(quat, vec4(vec, 0.0)), quatConjugate(quat)).xyz;\n}\nvec4 axisAngleToQuat(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    float sinHalfAngle = sin(halfAngle);\n    vec3 axisNormalized = normalize(axis);\n    return vec4(axisNormalized * sinHalfAngle, cos(halfAngle));\n}\n\n// position transformations\nvec3 transformPosBoost(vec3 x, vec3 lin, vec4 tor, vec3 pos, vec4 rot) {\n    return quatTransformVec(quatMult(tor, rot), x - lin - pos);\n}\nvec3 invTransformPosBoost(vec3 x, vec3 lin, vec4 tor, vec3 pos, vec4 rot) {\n    return quatTransformVec(quatConjugate(quatMult(tor, rot)), x) + lin + pos;\n}\nvec3 transformPos (vec3 x, vec3 pos, vec4 rot) {\n    return quatTransformVec(rot, x - pos);\n}\nvec3 transformGrad (vec3 v, vec4 tor, vec4 rot) {\n    return quatTransformVec(quatConjugate(quatMult(tor, rot)), v);\n}\nvec3 transformA (vec3 x)      { return transformPos(x, posA, rotA); }\nvec3 transformABoost (vec3 x) { return transformPosBoost(x, linA, torA, posA, rotA); }\nvec3 invTransformABoost (vec3 x) { return invTransformPosBoost(x, linA, torA, posA, rotA); }\nvec3 transformAGrad (vec3 x)  { return transformGrad(x, torA, rotA); }\nvec3 transformB (vec3 x)      { return transformPos(x, posB, rotB); }\nvec3 transformBBoost (vec3 x) { return transformPosBoost(x, linB, torB, posB, rotB); }\nvec3 invTransformBBoost (vec3 x) { return invTransformPosBoost(x, linB, torB, posB, rotB); }\nvec3 transformBGrad (vec3 v) { return transformGrad(v, torB, rotB); }\n\n\n// standard sdf stuff\nfloat sdSphere( vec3 p, vec3 c, float s ) {\n  return length(p - c)-s;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdPlane (vec3 p) {\n    return p.y;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// shape signed distance functions\nfloat sdA (vec3 p) {\n    // return sdBox(p, vec3(1.));\n    return sdTorus(p, vec2(1.2, 0.35));\n    // return sdPlane(p + 0.5);\n}\nfloat sdB (vec3 p) {\n    // return sdBox(p, vec3(1.));\n    return sdTorus(p, vec2(1.2, 0.35));\n    // return sdSphere(p, vec3(0.), 0.3);\n}\n\n// boilerplate: gradients for shape sdfs\nvec3 gradA (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdA(p) - \n        vec3(sdA(p-e.xyy), sdA(p-e.yxy),sdA(p-e.yyx));    \n    return normalize(n);\n}\nvec3 gradB (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdB(p) - \n        vec3(sdB(p-e.xyy), sdB(p-e.yxy),sdB(p-e.yyx));    \n    return normalize(n);\n}\n\n//\n// begin actually interesting code\n//\nvec3 projIntersect (vec3 p, float depth) {\n    const vec2 e = vec2(.001, 0);\n    for (int i = 0; i < 6; ++i) {\n        vec3 pa = transformABoost(p);\n        vec3 pb = transformBBoost(p);        \n        float fa = sdA(pa);\n        float fb = sdB(pb);\n        if (max(fa, fb) < -depth) {\n            break;\n        }\n        if (fa > fb) {\n            vec3 n = fa - vec3(sdA(pa-e.xyy), sdA(pa-e.yxy), sdA(pa-e.yyx));    \n            p = invTransformABoost(pa - (fa + depth) * normalize(n));\n        } else {\n            vec3 n = fb - vec3(sdB(pb-e.xyy), sdB(pb-e.yxy), sdB(pb-e.yyx));\n            p = invTransformBBoost(pb - (fb + depth) * normalize(n));\n        }\n    }\n    return p;\n}\nvec3 findMin(vec3 p) {\n    p = projIntersect(p, 0.);\n    vec3 minPos = p;\n    float minDepth = 0.;\n    float lo = 0.;\n    float hi = 1.;\n    for (int i = 0; i < 8; ++i) {\n        float testDepth = 0.5 * (lo + hi);\n        p = projIntersect(p, testDepth);\n        float d = max(sdA(transformABoost(p)), sdB(transformBBoost(p)));\n        if (d < minDepth) {\n            minDepth = d;\n            minPos = p;\n            lo = testDepth;\n        } else {\n            hi = testDepth;\n        }\n    }\n    return minPos;\n}\nfloat updateContact (vec3 hit, vec3 norm, float d) {\n    vec4 qa = quatMult(torA, rotA);\n    vec4 qb = quatMult(torB, rotB);\n    \n    vec3 drotA = cross(hit - posA - linA, norm);\n    vec3 drotB = cross(hit - posB - linB, norm);\n    \n    vec3 wrotA = rInvA * drotA;\n    vec3 wrotB = rInvB * drotB;\n   \n    // calculate effective mass and impulse\n    float w1 = mInvA + dot(drotA, wrotA);\n    float w2 = mInvB + dot(drotB, wrotB);\n    float impulse = -2. * d / max(0.0001, w1 + w2);\n    \n    // update linear velocity\n    linA += impulse * mInvA * norm;\n    linB -= impulse * mInvB * norm;\n    \n    // update rotational velocity\n    qa += quatMult(vec4(0.5 * impulse * wrotA, 0.), qa);\n    torA = normalize(quatMult(qa, quatConjugate(rotA)));    \n    qb += quatMult(vec4(0.5 * impulse * wrotB, 0.), qb);\n    torB = normalize(quatMult(qb, quatConjugate(rotB)));\n    \n    return impulse;\n}\nfloat solveContact () {\n    float lambda = 0.;\n    for (int i = 0; i < 10; ++i) {\n        vec3 hitPos = 0.5 * (posA + linA + posB + linB);\n        float dlambda = 0.;\n        for (int outerIter = 0; outerIter < 5; ++outerIter) {\n            hitPos = findMin(hitPos);\n            \n            vec3 ta = transformABoost(hitPos);\n            vec3 tb = transformBBoost(hitPos);\n            float fa = sdA(ta);\n            float fb = sdB(tb);\n            float rad = max(fa, fb);\n            if (rad > 0.) {\n                break;\n            }\n            hit = true;\n            \n            // calculate hit normal\n            vec3 da = transformAGrad(gradA(ta));\n            vec3 db = transformBGrad(gradB(tb));\n            vec3 hitNorm = normalize(fa * da - fb * db);\n            \n            dlambda += updateContact(hitPos, hitNorm, rad);\n            if (abs(dlambda) < 0.01) {\n                break;\n            }\n       }\n       lambda += dlambda;\n       if (abs(dlambda) < 0.01) {\n           break;\n       }\n   }\n   \n   minHit = findMin(0.5 * (posA + posB + linA + linB));\n   qA = minHit + linA;\n   qB = minHit + linB;\n   \n   return lambda;\n}\n//\n// end actually interesting code\n//\n\n\n// --- scene stuff ----\n// debug lines\nfloat GetDistSolid(vec3 p) {\n    float d = 10000.;\n    // if (hit) {\n        d = min(d, sdSphere(p, qA, 0.05));\n        d = min(d, sdCapsule(p, qA, minHit, 0.005));\n        d = min(d, sdCapsule(p, qB, minHit, 0.005));\n        d = min(d, sdSphere(p, minHit, 0.07));\n    // }\n    return d;\n}\n\nfloat GetDistAlphaC(vec3 p) {\n    return max(sdA(transformA(p)), sdB(transformB(p)));\n}\n\nfloat GetDistAlpha(vec3 p) {\n    return min(sdA(transformABoost(p)), sdB(transformBBoost(p)));\n}\n// --- end scene stuff ----\n\n\n// ray marching boilerplate\nfloat RayMarchSolid(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistSolid(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\nfloat RayMarchAlphaC(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlphaC(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\nfloat RayMarchAlpha(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlpha(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\n// surface normal boilerplate\nvec3 GetNormalSolid(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistSolid(p) - \n        vec3(GetDistSolid(p-e.xyy), GetDistSolid(p-e.yxy),GetDistSolid(p-e.yyx));    \n    return normalize(n);\n}\nvec3 GetNormalAlphaC(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlphaC(p) - \n        vec3(GetDistAlphaC(p-e.xyy), GetDistAlphaC(p-e.yxy),GetDistAlphaC(p-e.yyx));\n    \n    return normalize(n);\n}\nvec3 GetNormalAlpha(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlpha(p) - \n        vec3(GetDistAlpha(p-e.xyy), GetDistAlpha(p-e.yxy),GetDistAlpha(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// camera\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // update animation\n    float tt = 0.1 * iTime - 0.02;\n    posB = vec3(3. * cos(tt), 0., 0.);\n    \n    rotB = axisAngleToQuat(vec3(1, 0, 0), 3. * tt);\n    // rotA = axisAngleToQuat(vec3(0, 1, 0), 10. * tt);\n    /*\n    rotB = \n        quatMult(\n            axisAngleToQuat(vec3(1., 0., 0.), 0.5 * tt),\n            axisAngleToQuat(vec3(0., 1., 0.), 0.13 * tt));\n     */\n     \n    // solve for intersections\n    solveContact();\n    \n    // set up view direction\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    // ray trace\n    vec3 col = vec3(0);\n    \n    // trace solids\n    float dSolid = RayMarchSolid(ro, rd);\n    if (dSolid < MAX_DIST) {\n        col = vec3(2., 0., 0.);\n    } else {\n        dSolid = MAX_DIST;\n    }\n    \n    // trace alpha layer 0\n    float dAlpha0 = RayMarchAlphaC(ro, rd);\n    if(dAlpha0<dSolid) {\n        vec3 p = ro + rd * dAlpha0;\n        vec3 n = GetNormalAlphaC(p);\n        vec3 r = reflect(rd, n);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        if (hit) {\n            col = mix(col, dif * vec3(1., 0.5, 0.2), 0.4);\n        } else {\n            col = mix(col, dif * vec3(0., 1., 1.), 0.3);\n        }\n    }\n    \n    // trace alpha layer 1\n    float dAlpha1 = RayMarchAlpha(ro, rd);\n    if(dAlpha1<dSolid) {\n        vec3 p = ro + rd * dAlpha1;\n        vec3 n = GetNormalAlpha(p);\n        vec3 r = reflect(rd, n);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = mix(col, vec3(dif), 0.2);\n    }\n    \n    // gamma correct and output\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}