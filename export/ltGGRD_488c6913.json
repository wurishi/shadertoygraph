{"ver":"0.1","info":{"id":"ltGGRD","date":"1473504333","viewed":101,"name":"Raymarch first test","username":"otah007","description":"First raymarch shader, quite pleased I managed to get anything on the screen at all!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 20.0\n#define MAX_STEPS 100\n#define EPSILON 0.01\n#define DISTANCE_BIAS 0.95\n#define RECURSION_LIMIT 4\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530717958647692\n\nfloat ssphere(vec3 position, float radius)\n{\n    return length(position) - radius;\n}\n\nfloat ubox(vec3 position, vec3 dimensions)\n{\n    return length(max(abs(position) - dimensions, 0.0));\n}\n\nfloat uroundbox(vec3 position, vec3 dimensions, float roundness)\n{\n    return length(max(abs(position) - dimensions, 0.0)) - roundness;\n}\n\nfloat storus(vec3 position, vec2 torus)\n{\n    vec2 q = vec2(length(position.xz) - torus.x, position.y);\n    return length(q) - torus.y;\n}\n\nfloat splane(vec3 position, vec4 normal)\n{\n    return dot(position, normal.xyz) + normal.w;\n}\n\nfloat ucube(vec3 position, float len)\n{\n    return ubox(position, vec3(len, len, len));\n}\n\nvec3 repeat(vec3 position, vec3 repeat)\n{\n    position = mod(position, repeat) - 0.5 * repeat;    \n    return position;\n}\n\nstruct object\n{\n    vec3 transform;\n    vec3 repeat;\n    float material;\n    int primitive;\n    vec4 data;\n};\n\nconst int n = 5;\nobject objects[5];\n\nvec2 scene(vec3 position)\n{   \n    vec2 result = vec2(FAR_CLIPPING_PLANE, 0.0);\n    \n    for (int i = 0; i < n; ++i)\n    {\n        object o = objects[i];\n        vec3 p = repeat(position - o.transform, o.repeat);\n        float d = 0.0;\n        \n        if (o.primitive == 0)\n            d = ssphere(p, o.data.x);\n        else if (o.primitive == 1)\n            d = ubox(p, o.data.xyz);\n\t\telse if (o.primitive == 2)\n            d = uroundbox(p, o.data.xyz, o.data.w);\n\t\telse if (o.primitive == 3)\n            d = storus(p, o.data.xy);\n\t\telse if (o.primitive == 4)\n            d = splane(p, o.data);\n        else\n            d = FAR_CLIPPING_PLANE;\n        \n        if (d < result.x)\n        {\n            result.x = d;\n            result.y = objects[i].material;\n        }\n    }\n    \n    return result;\n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float totalDistance = NEAR_CLIPPING_PLANE;\n    \n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec2 result = scene(position + totalDistance * direction);\n        \n        if (result.x < EPSILON)\n            return vec2(totalDistance, result.y);\n        \n        totalDistance += result.x * DISTANCE_BIAS;\n        \n        if (totalDistance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    \n    return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\nfloat shadow(vec3 origin, vec3 objectPos, float mint, float k)\n{\n    float result = 1.0;\n    vec3 direction = normalize(objectPos - origin);\n    float t = mint;\n    float maxt = abs(length(origin - objectPos)) - 0.1;\n    \n   for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float r = scene(origin + direction * t).x;\n        \n        if (r < EPSILON)\n            return 0.0;\n        \n        result = min(result, k * r / t);\n        \n        if (t + r > maxt)\n            return result;\n        \n        t += r * DISTANCE_BIAS;\n    }\n    \n    return result;\n}\n\nfloat ao(vec3 origin, vec3 norm)\n{\n    float ao = 1.0;\n   \t\n    for (int i = 0; i < 5; ++i)\n    {\n        float d1 = 0.02 * float(i) * float(i);\n        float d2 = scene(origin + norm * d1).x;\n        ao -= (d1 - d2);\n    }\n    \n    return ao;\n}\n\nvec3 normal(vec3 position, float smoothness)\n{\n    vec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(position + dn.xyy).x - scene(position - dn.xyy).x;\n\tn.y\t= scene(position + dn.yxy).x - scene(position - dn.yxy).x;\n\tn.z\t= scene(position + dn.yyx).x - scene(position - dn.yyx).x;\n\treturn normalize(n);\n}\n\nvec3 rotateX(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = vec.x;\n    v.y = (vec.y * cos(angle)) - (vec.z * sin(angle));\n    v.z = (vec.y * sin(angle)) + (vec.z * cos(angle));\n    return v;\n}\n\nvec3 rotateY(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = (vec.x * cos(angle)) + (vec.z * sin(angle));\n    v.y = vec.y;\n    v.z = (-vec.x * sin(angle)) + (vec.z * cos(angle));\n    return v;\n}\n\nvec3 rotateZ(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = (vec.x * cos(angle)) - (vec.y * sin(angle));\n    v.y = (vec.x * sin(angle)) + (vec.y * cos(angle));\n    v.z = vec.z;\n    return v;\n}\n\nvec3 materialToColour(float colour)\n{\n    if (colour == 0.0)\n        return vec3(0.7, 0.7, 0.7);\n    if (colour == 1.0)\n        return vec3(1.0, 0.0, 0.0);\n    if (colour == 2.0)\n        return vec3(0.0, 1.0, 0.0);\n   \tif (colour == 3.0)\n        return vec3(0.0, 0.0, 1.0);\n    if (colour == 4.0)\n        return vec3(1.0, 0.0, 1.0);\n    else\n        return vec3(0.0, 0.0, 0.0);\n}\n\n\nvec3 getFinalColour(vec3 intersection, vec3 norm)\n{\n    vec3 light = vec3(0.0, 3.0, -1.0);\n    vec3 lightDir = normalize(light - intersection);\n    vec3 intensity = vec3(1.0, 1.0, 1.0);\n    vec3 lambert = dot(norm, lightDir) * intensity;\n    float i = shadow(light, intersection, 0.5, 48.0);\n    float amb = ao(intersection, norm);\n\treturn lambert * i * amb;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 direction = normalize(vec3(uv, 2.5));\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse.x = mouse.x * 2.0 - 1.0;\n    mouse.y = mouse.y * 2.0 - 1.0;\n    vec3 cameraOrigin = vec3(0.0, 0.0, -10.0);\n    cameraOrigin = rotateX(cameraOrigin, mouse.y * TWO_PI * 0.5);\n    cameraOrigin = rotateY(cameraOrigin, mouse.x * TWO_PI);\n    direction = rotateX(direction, mouse.y * TWO_PI * 0.5);\n    direction = rotateY(direction, mouse.x * TWO_PI);\n    \n    objects[0].transform = vec3(0.0, 0.0, 0.0);\n    objects[0].repeat = vec3(0.0, 0.0, 0.0);\n    objects[0].material = 1.0;\n    objects[0].primitive = 0;\n    objects[0].data = vec4(1.0, 0.0, 0.0, 0.0);\n    \n    objects[1].transform = vec3(0.0, 0.5, 0.5);\n    objects[1].repeat = vec3(0.0, 0.0, 0.0);\n    objects[1].material = 2.0;\n    objects[1].primitive = 1;\n    objects[1].data = vec4(0.5, 0.25, 0.2, 0.05);\n    \n    objects[2].transform = vec3(0.0, -1.0 * sin(iTime), 0.0);\n    objects[2].repeat = vec3(2.5, 0.0, 2.5);\n    objects[2].material = 3.0;\n    objects[2].primitive = 3;\n    objects[2].data = vec4(0.5, 0.15, 0.0, 0.0);\n    \n    objects[3].transform = vec3(0.0, -4.0, 0.0);\n    objects[3].repeat = vec3(0.0, 0.0, 0.0);\n    objects[3].material = 4.0;\n    objects[3].primitive = 4;\n    objects[3].data = vec4(0.0, 1.0, 0.0, 0.0);\n    \n    objects[4].transform = vec3(0.0, 1.2, 0.8);\n    objects[4].repeat = vec3(0.0, 0.0, 0.0);\n    objects[4].material = 2.0;\n    objects[4].primitive = 0;\n    objects[4].data = vec4(0.4, 0.0, 0.0, 0.0);\n    \n    vec2 result;\n    vec3 materialColour;\n    vec3 intersection = cameraOrigin;\n    vec3 norm = direction;\n    vec3 colour = vec3(1.0, 1.0, 1.0);\n    \n    for (int i = 0; i < RECURSION_LIMIT; ++i)\n    {\n        result = raymarch(intersection, norm);\n        \n        if (result.y == 0.0)\n            break;\n        \n        materialColour = materialToColour(result.y);\n        intersection = intersection + norm * result.x;\n        norm = normal(intersection, 0.01);\n        colour *= getFinalColour(intersection, norm);\n    }\n    \n    colour *= materialColour;\n    \n    fragColour = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}