{"ver":"0.1","info":{"id":"lt23zc","date":"1431182637","viewed":278,"name":"Wondercube","username":"kuvkar","description":"Transforming fractal cube. Fractal model is based on iq's article  http://iquilezles.org/articles/menger/menger.htm\nRotate with mouse, looks nice at fullscreen.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PI 3.14159\n#define inf 999999.0\n\n// This sets switching to the second model on the transition.\nconst bool switchModel = true;\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotation;\n\nvec3 light = vec3(0.0, 0.0, -1.0);\nvec4 ambient = vec4(0.15);\nconst float boxs = 1.0;\n\n// distance functions: \n// https://iquilezles.org/articles/distfunctions\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox(in vec3 p,in vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz, vec3(inf, boxs, boxs));\n  float db = sdBox(p.yzx, vec3(boxs, inf, boxs));\n  float dc = sdBox(p.zxy, vec3(boxs, boxs, inf));\n  return min(da,min(db,dc));\n}\n\n\n// \"scene\"\nfloat colswitch = 0.0;\nconst float switchFreg = 4.0;\nbool model1 = true;\nint hititer = -1;\nvec4 basecolor = vec4(0.0, 0.5, 1.0, 0.0);\nvec4 secondarycol = vec4(0.1, 0.2, 0.2, 0.0);\n\n\nfloat map(in vec3 pos)\n{\n    pos *= rotation;\n    \n    float s = 1.0;\n    const int iter = 3;\n    \n    float m = udRoundBox(pos, vec3(boxs * 0.5), 0.4);\n    \n    for (int i = 0; i < iter; ++i)\n    {\n        vec3 a = mod(pos * s, 2.0) - 1.0;\n        \n        s *= 3.0;\n        float cr = 1.5;\n        if(model1 && switchModel)\n        {\n            cr = 2.0;\n        }\n        vec3 r = cr - 3.0 * abs(a);\n        float c = sdCross(r) / s;\n        \n        if(c > 0.0 && m < 0.0)\n        {\n        \thititer = i;\n        }\n        \n        \n        m = max(m, c);\n    }\n    return m;\n}\n\nvec3 grad(in vec3 p)\n{\n    vec2 offset = vec2(0.008, 0.0);\n    vec3 g = vec3(map(p + offset.xyy) - map(p - offset.xyy),\n\t\t\t\t  map(p + offset.yxy) - map(p - offset.yxy),\n\t\t\t\t  map(p + offset.yyx) - map(p - offset.yyx));\n    return normalize(g);\n                  \n}\n\n\nfloat ao (in vec3 pos, in vec3 norm)\n{\n    float dist = 0.01;\n    pos += norm * dist;\n    float m = map(pos);\n    float ao = clamp(m, 0.0, dist) / dist;\n    return ao;\n}\n\n\nbool trace(in vec3 o, in vec3 dir, inout vec4 color)\n{\n    color = vec4(0.0);\n    vec3 rp = o;\n    float m = 0.0;\n    float closest = 9999.0;\n    float t = iTime * 0.4 + 9.0;\n    colswitch = mod(t, switchFreg * 2.0);\n    bool firstpass = colswitch < switchFreg;\n\tvec4 bcol = vec4(0.0);\n    float mm = mod(t, switchFreg);\n    \n\tfor (int i = 0; i < 100; ++i)\n    {\n\n        // initial state setup\n        bcol = firstpass ? basecolor : secondarycol;\n        model1 = firstpass;\n        \n        float m = o.z + mm;\n        float dif = rp.z - m;\n\n\t\t// switch on sweep\n        if (dif < 0.0)\n        {\n            bcol = firstpass ? secondarycol : basecolor;\n            model1 = !firstpass;\n        }                \n        \n        m = map(rp);\n        closest = min(closest, m);\n        color = bcol;\n        if (m < 0.0)\n        {\n            // coloring\n            if(hititer == 1)\n            {\n            \tcolor = vec4(0.2, 0.4, 0.8, 0.0);\n            }\n\n            if(hititer == 2)\n            {\n            \tcolor = vec4(1., 1.0, 1.0, 0.0);\n            }\n            \n            vec3 norm = grad(rp);\n            // diffuse\n            float d = dot(light, norm);\n            d = clamp(d, 0.1, 1.0);\n            color *= d;\n            \n            // blinn-phong specular\n            vec3 H = normalize(-dir + light);\n            float spc = clamp(dot(H, norm), 0.0, 1.0);\n            \n            spc = pow(spc, 35.0) * 0.4;\n            color += spc * vec4(1.0, 1.0, 1.0, 0.0);\n            \n\t\t\t// ambient + ao            \n            color += ambient;\n            color *= mix(ao(rp, norm), 1.0, 0.5);\n            \n            // switch effect \n            float e = abs(dif);\n            float efsize = 0.05;\n            e = 1.0 - clamp(e, 0.0, efsize) / efsize;\n            color += e * texture(iChannel0, vec2(rp.z, rp.x) * 4.0).r;\n            return true;\n        }\n        \n        \n        rp += dir * max(m, 0.0001);\n        \n        if(rp.z > 1.0)\n        {\n    \t   // outer glow\t\n           float maxd = 0.03;\n           float glow = clamp( (maxd - closest), 0.0, closest) / closest;\n           color = vec4(0.0, 0.5, 1.0, 0.0) * (glow) * 0.5; \n           return glow >= 0.8;\n        }\n    }\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light = normalize(light);\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    rotation = mat3(1.0);\n    rotation *= roty(iTime * 0.2);\n    rotation *= rotx(iTime * 0.1);\n    \n    rotation *= roty(iMouse.x * 0.025);\n    rotation *= rotx(-iMouse.y * 0.025);\n    \n    vec3 o = vec3(0.0, 0.0, -3.0);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 0.6));\n    \n    if(!trace(o, dir, fragColor))\n    {\n        fragColor += vec4(0.9, 0.7, 0.5, 0.0) * (1.8 - pow(length(uv), 0.45));\n    }\n}","name":"","description":"","type":"image"}]}