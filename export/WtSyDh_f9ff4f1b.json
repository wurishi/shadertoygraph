{"ver":"0.1","info":{"id":"WtSyDh","date":"1596003838","viewed":272,"name":"The Birth of a Star","username":"romeosoft","description":"The Birth of a Star.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["star","accretiondisc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'\n\n          “If I can’t picture it, I can’t understand it.”\n*/\n// =========================================================\n#define resolution_3d\t0.02 \n#define depth_of_field\t30\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n// =========================================================\nfloat map(vec3 p) \n{ \n    float NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n    return NebNoise+0.03;\n}\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\nvec3 hsl2rgb(vec3 hsl)\n{\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n    \n    float c = (1.0 - abs(2.0 * l - 1.0)) * s;\n    float x = c * (1.0 - abs(mod(h / 60.0, 2.0) - 1.0));\n    float m = l - 0.5 * c;\n    \n    vec3 rgb;\n    \n    if (h < 60.0) {\n        rgb = vec3(c, x, 0.0);\n    } else if (h < 120.0) {\n        rgb = vec3(x, c, 0.0);\n    } else if (h < 180.0) {\n        rgb = vec3(0.0, c, x);\n    } else if (h < 240.0) {\n        rgb = vec3(0.0, x, c);\n    } else if (h < 300.0) {\n        rgb = vec3(x, 0.0, c);\n    } else {\n        rgb = vec3(c, 0.0, x);\n    }\n    \n    return rgb + m;\n}\nvec3 tempColor(float temp)\n{\n    // Calculate the maximum radiation wavelength using Wien's displacement law\n    float lambda_max = (2.8978e-3) / temp;\n    \n    // Map lambda_max to the hue value in the HSL color space\n    float hue = (lambda_max - 380.0) / (700.0 - 380.0);\n    \n    // Convert hue to RGB color\n    vec3 rgbColor = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    return rgbColor;\n}\n// ---------------------------------------------------------\n// 3D Image\n// ---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 pp = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    float eyer = 3.5;\n    float eyea = -((iMouse.x) / iResolution.x) * PI * 2.0;\n    float eyef = ((iMouse.y / iResolution.y) - 0.24) * PI * 2.0;\n\n    vec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n        \n    ROT(cam.xz, (0.5) * (iTime + 10.0)); // auto rotation\n\n    vec3 front = normalize(-cam);\n    vec3 left = normalize(cross(normalize(vec3(0.1, 1, -0.001)), front));\n    vec3 up = normalize(cross(front, left));\n    \n    vec3 camd = normalize(front + left * pp.x + up * pp.y);\n    \n    coord3 crd0 = uxy_c(UX, UY);\n    \n    // star\n    vec3 star_pos = vec3(0.0);\n    vec3 star_cor = vec3(1.0,0.5,0.25);\n    \n    float t = 0.0;\n    \n\tfloat td = 0.; // density\n    \n    const float h = 0.58;\n   \n    vec4 cor = vec4(0.0);\n    \n    for (int i = 0; i < depth_of_field; i++)\n    {\n        vec3 p = cam + camd * 0.5 + t * camd;\n        \n        float rxz = max(0.01, length(p.xz));\n        \n        {// the coordnate system\n            coord3 crd = c_x_q(crd0, angax_q(1.5 / rxz, UY));\n            //crd.o.y += mix(0., 1., rxz*rxz / 10.);\n            \n            p = p_x_c(p, crd);\n        }\n        \n        float d = max(map(p), 0.08);\n\n        if(cor.a > 0.99)\n            break;\n\n        float dis = max(length((star_pos - p)), 0.001);\n\n        float beta = exp(-0.5 / (0.01+rxz) + abs(p.y) * 5.5 );\n        \n        cor.rgb += (star_cor/((dis))/ 5./ beta);\n\n        if (d < h) \n        {  \n            td += (0.2 - td) * (h - d);\n\n            vec4 cloud_cor = vec4(tempColor(dis), td);\n            cloud_cor.a *= 0.158;\n            cloud_cor.rgb *= cloud_cor.a;\n           \n            cor = cor + cloud_cor * (1.0 - cor.a) / beta;  \n        }\n        t += max(d * 0.1 * max(min(length(dis),length(cam)),1.0), 0.02);\n    }\n    \n    cor = clamp( cor, 0.0, 1.0 );\n\n    cor.xyz = cor.xyz*cor.xyz*(3.0-2.0*cor.xyz);\n    \n    fragColor = vec4(cor.xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n*           Visualization of Natural Phenomena\n*\n*   \n*/\n\n#define PI 3.14156\n#define real float\n#define imag float\n#define quat quaternion\n#define crd3 coord3\n\n#define CSCREEN vec2(0.5,0.5)\n\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n#define RED vec3(1,0,0)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define YELLOW vec3(1,1,0)\n#define GREY vec3(0.5,0.5,0.5)\n\n#define XYZ0 vec3(0,0,0)\n#define UX vec3(1,0,0)\n#define UY vec3(0,1,0)\n#define UZ vec3(0,0,1)\n#define UC crd3(UX, UY, UZ, XYZ0)\n\n// ---------------------------------------------------------\n// Quaternion:\n// Quaternions are real mathematics numbers, \n// meaning there is number theory behind them.\n// ---------------------------------------------------------\nstruct quaternion\n{\n    real w, x, y, z;\n};\nquaternion angax_q(real ang, vec3 ax)\n{\n    quaternion q;\n    real halfang = 0.5 * ang;\n    real fsin = sin(halfang);\n    q.w = cos(halfang);\n    q.x = fsin * ax.x;\n    q.y = fsin * ax.y;\n    q.z = fsin * ax.z;\n    return q;\n}\nquaternion wv_q(real w, vec3 v)\n{\n   return quaternion(w, v.x,v.y,v.z);\n}\n// v x q\nvec3 v_x_q(vec3 v, quaternion q)\n{\n    // nVidia SDK implementation\n    vec3 uv, uuv;\n    vec3 qvec = vec3(q.x, q.y, q.z);\n    uv = cross(qvec, v);\n    uuv = cross(qvec, uv);\n    uv = uv * (2.0f * q.w);\n    uuv = uuv * 2.0f;\n\n    return v + uv + uuv;\n}\n// q x q\nquaternion q_x_q(quaternion q1, quaternion q2)\n{\n    quaternion q;\n\n    q.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;\n    q.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;\n    q.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;\n    q.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;\n    return q;\n}\nquaternion exp_q(quaternion q)\n{\n    vec3 v = vec3(q.x,q.y,q.z);\n    real r = length(v);\n    real tr = exp(q.w);\n    return wv_q(tr * cos(r), normalize(v) * (tr*sin(r)));\n}\n\n// ---------------------------------------------------------\n// Coordinate System:\n// A coordinate system in three-dimensional space \n// consists of an origin plus three orientation axes\n// c++ version : \n// https://github.com/panguojun/Coordinate-system-transformation\n// ---------------------------------------------------------\nstruct coord3\n{\n    vec3 ux, uy, uz; // three axial unit vectors\n    vec3 o;          // origin\n};\ncoord3 uxyz_c(vec3 _ux, vec3 _uy, vec3 _uz)\n{\n    coord3 c;\n    c.ux = _ux;\n    c.uy = _uy;\n    c.uz = _uz;\n    c.o = XYZ0;\n    return c;\n}\ncoord3 uxy_c(vec3 _ux, vec3 _uy)\n{\n    coord3 c;\n    c.ux = _ux;\n    c.uy = _uy;\n    c.uz = cross(_ux,_uy);\n    c.o = XYZ0;\n    return c;\n}\ncoord3 norm_c(coord3 c)\n{\n    c.ux = normalize(c.ux);\n    c.uy = normalize(c.uy);\n    c.uz = normalize(c.uz);\n    return c;\n}\n// p x c\nvec3 p_x_c(vec3 p, coord3 c)\n{\n    return c.ux * p.x + c.uy * p.y + c.uz * p.z + c.o;\n}\ncoord3 c_x_q(coord3 c, quat q)\n{\n    return coord3(\n        v_x_q(c.ux, q), v_x_q(c.uy, q), v_x_q(c.uz, q),\n        c.o);\n}\n// p / c\nvec3 p_z_c(vec3 p, coord3 c)\n{\n    vec3 v = p - c.o;\n    return vec3(dot(v, c.ux), dot(v, c.uy), dot(v, c.uz));\n}\nreal c_ax_dot(vec3 v, coord3 c)\n{\n    return dot(v, c.ux + c.uy + c.uz);\n}\nvec3 c_ax_cross(coord3 a, coord3 b)\n{\n    return vec3(\n        dot(a.uy, b.uz) - dot(a.uz, b.uy),\n        dot(a.uz, b.ux) - dot(a.ux, b.uz),\n        dot(a.ux, b.uy) - dot(a.uy, b.ux)\n    );\n}\ncoord3 c_flipx(coord3 c)\n{\n    c.ux = -c.ux;\n    return c;\n}\ncoord3 c_flipy(coord3 c)\n{\n    c.uy = -c.uy;\n    return c;\n}\ncoord3 c_flipz(coord3 c)\n{\n    c.uz = -c.uz;\n    return c;\n}\n\n// ---------------------------------------------------------\n// GRAD, DT\n// ---------------------------------------------------------\n#define delta_d 0.001\n#define delta_t 0.001\n\n#define GRAD_V(Fai, p, t) \\\n        vec3((Fai(p + vec3(delta_d,0.0,0.0), t) - Fai(p, t)) / delta_d,\\\n        (Fai(p + vec3(0.0,delta_d,0.0), t) - Fai(p, t)) / delta_d, \\\n        (Fai(p + vec3(0.0,0.0,delta_d), t) - Fai(p, t)) / delta_d)\n\n#define GRAD_C(A, p, t) \\\n        uxyz_c( \\\n        (A(p + vec3(1.0,0.0,0.0) * delta_d, t) - A(p, t)) / delta_d, \\\n        (A(p + vec3(0.0,1.0,0.0) * delta_d, t) - A(p, t)) / delta_d, \\\n        (A(p + vec3(0.0,0.0,1.0) * delta_d, t) - A(p, t)) / delta_d)\n\n#define DT(A, p, t) (A(p,t + delta_t) - A(p, t)) / delta_t\n\n// ---------------------------------------------------------\n// Space-Time Vector:\n// ---------------------------------------------------------\nstruct time\n{\n    float tr;          // real time（Expansion time）\n    float ti;          // imagine time（Phase time）\n};\nstruct space_time\n{\n    vec3 n;\n    time t;\n};\nvec3 space_time_v(space_time st)\n{\n    return st.n * exp(st.t.tr) * cos(st.t.ti);\n}\n\n// ---------------------------------------------------------\n// Vector Math\n// ---------------------------------------------------------\nvec3 crossdot(vec3 v1, vec3 v2) {\n    vec3 result;\n    result.x = v1.y * v2.z - v1.z * v2.y;\n    result.y = v1.z * v2.x - v1.x * v2.z;\n    result.z = v1.x * v2.y - v1.y * v2.x;\n    return result;\n}\n\n// ---------------------------------------------------------\n// random\n// ---------------------------------------------------------\n// iq's\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\nfloat noise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*157.0 + 113.0*p.z;\n\treturn mix(mix(mix(hash(n+0.0), hash(n+1.0),f.x),\n\t\tmix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n\t\tmix(mix(hash(n+113.0), hash(n+114.0),f.x),\n\t\t\tmix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat rrnd(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n\nconst float nudge = 0.739513;\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\nfloat SpiralNoiseC(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\n\t\tp.xy += vec2(p.y, -p.x) * nudge;\n\t\tp.xy *= normalizer;\n\t\tp.xz += vec2(p.z, -p.x) * nudge;\n\t\tp.xz *= normalizer;\n\t\titer *= 1.733733;\n\t}\n\treturn n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tn += (sin(p.y*iter*2.0) + cos(p.x*iter)) / iter;\n\t\tp.xz += vec2(p.z, -p.x) * nudge;\n\t\tp.xz *= normalizer;\n\t\titer *= 1.33733;\n\t}\n\treturn n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n\tfloat final = p.y + 2.5;\n\tfinal -= SpiralNoiseC(p.xyz*2.0);   // 中等噪声\n\tfinal += SpiralNoiseC(p.zxy*0.5123+100.0)*2.0;   // 大尺度特征\n\tfinal -= SpiralNoise3D(p);   // 更多大尺度特征，但是是3D的\n\n\treturn final;\n}","name":"Common","description":"","type":"common"}]}