{"ver":"0.1","info":{"id":"4t3czs","date":"1533608369","viewed":639,"name":"Quantized Colour","username":"morgan3d","description":"Testing the impact of bit depth and pixelization on colour palettes and different kinds of content; I'm considering a sRGBA 4:4:4:4 renderer to get 2x bandwidth for a low-fi rendering system.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["rainbow","bits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BITS           4\n#define PIXEL_SIZE     4\n#define ENCODE_IN_SRGB 1\n#define DITHER         1\n#define   BLUE_DITHER  1\n\nvec3 HSVToSRGB(float h, float s, float v) {\n    return vec3(v * (1. - s + s * clamp(abs(fract(h + 1.0)   * 6. - 3.) - 1., 0., 1.)),\n                v * (1. - s + s * clamp(abs(fract(h + 2./3.) * 6. - 3.) - 1., 0., 1.)),\n                v * (1. - s + s * clamp(abs(fract(h + 1./3.) * 6. - 3.) - 1., 0., 1.)));\n}\n\nvec3 SRGBToRGB(vec3 v) {\n    for (int i = 0; i < 3; ++i) {\n        if (v[i] <= 0.04045) {\n        \tv[i] /= 12.92;\n        } else {\n        \tv[i] = pow((v[i] + 0.055) / (1.055), 2.4);\n        }\n    }\n    return v;\n}\n\nvec3 RGBToSRGB(vec3 v) {\n    for (int i = 0; i < 3; ++i) {\n        if (v[i] <= 0.0031308) {\n            v[i] *= 12.92;\n        } else {\n        \tv[i] = (1.055) * pow(v[i], 1.0/2.4) - 0.055;\n        }\n    }    \n    return v;\n}\n\n\nfloat precisionFromBits(float b) {\n    return 1. / (pow(2., b) - 1.);\n}\n\n\nvec3 roundToPrecision(vec3 v, float p) {\n    return clamp(p * round(v / p), vec3(0.0), vec3(1.0));\n}\n\n// From https://www.shadertoy.com/view/MslGR8 by hornet\nvec3 dither(vec3 v, vec2 fragCoord, float p) {\n    #if BLUE_DITHER\n\t    return v + (texture(iChannel3, mod(fragCoord, 1024.0) / 1024.0).rgb - 0.5) * (p * 1.5);\n    #else\n    \n        //Calculate grid position\n        float grid_position = fract( dot( fragCoord.xy - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n\n        //Calculate how big the shift should be\n        float dither_shift = 0.25 * p;\n\n        //Shift the individual colors differently, thus making it even harder to see the dithering pattern\n        vec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); //subpixel dithering\n\n        //modify shift acording to grid position.\n        dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position); //shift acording to grid position.\n\n        //shift the color by dither_shift\n        return v + dither_shift_RGB + p * 0.5; \n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord = (floor((fragCoord - 0.5) / float(PIXEL_SIZE)) + 0.5) * float(PIXEL_SIZE);\n    \n    vec2 coord = fragCoord / iResolution.xy;\n\n    // Pack three input images\n    vec3 C = (coord.x < 0.5) ?\n         ((coord.y < 0.5) ?\n           HSVToSRGB(coord.x * 2.0, 1.0, coord.y * 2.0) :\n           HSVToSRGB(coord.x * 2.0, 2.0 - coord.y * 2.0, 1.0)) :\n    \t ((coord.y < 0.5) ?\n            texture(iChannel0, vec2(coord.x * 2.0 - 1.0, coord.y * 2.0)).rgb :\n            texture(iChannel1, coord * 2.0 - 1.0).rgb);\n\n    \n    if (abs(coord.x - 0.5) < 0.01) {\n        // Grayscale\n        C = vec3(coord.y);\n    }\n    \n    float p = precisionFromBits(float(BITS));\n    \n    #if ENCODE_IN_SRGB == 0\n    C = SRGBToRGB(C);\n    #endif\n    \n    #if DITHER\n    C = dither(C, fragCoord, p);\n    #endif\n    \n\tC = roundToPrecision(C, p);\n\n    #if ENCODE_IN_SRGB == 0\n    C = RGBToSRGB(C);\n    #endif\n    \n    \n    // Output to screen\n    fragColor = vec4(C, 1.0);\n}","name":"Image","description":"","type":"image"}]}