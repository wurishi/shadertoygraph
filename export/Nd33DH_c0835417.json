{"ver":"0.1","info":{"id":"Nd33DH","date":"1630012738","viewed":59,"name":"[Julia Sets]","username":"Langwedocjusz","description":"My first stab at drawing fractals ^^","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //Normalize coordinates to (-1;1):\n    uv = 2.0 * uv - 1.0;\n    //Aspect ratio correction:\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Rotate the entire plane:\n    mat2 rot = rotation2D(PI/2.0);\n    uv *= rot;\n    \n    //Maximal magnitude allowed before assuming divergence:\n    float R = 3.0; \n    \n    //Parameters of the function f(z) = z^n + c generating the set:\n    int n = 2;\n    vec2 c = vec2(0.285, 0.01);\n    \n    //Animation created by changing values of c, moving along a \"spiral\" on the complex plane:\n    float theta = iTime;\n    float r = sin(iTime / 100.0);\n    vec2 offset = r * vec2(cos(theta), sin(theta));\n    c += offset;\n    \n    //Actual drawing:\n    float value = Julia(uv, R, n, c);\n    vec3 color = Color(value);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//========Random maths==========================================\n\nconst float PI = 3.1415926535;\n\nfloat len2(vec2 v) {return dot(v,v);}\n\nfloat atan2(in float y, in float x){\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nmat2 rotation2D(float angle) {return mat2(cos(angle), -sin(angle),\n                                          sin(angle),  cos(angle));}\n\n//It's nicer to use chrome color picker with this:\nvec3 rgb(float x, float y, float z) {return vec3(x,y,z) / 255.0; }\n\n//=========Drawing the set==========================================================\n\n//Literally just translated pseudocode from the wiki: https://en.wikipedia.org/wiki/Julia_set\nfloat Julia(vec2 point, float R, int n, vec2 c) {\n    \n    vec2 zP =  point;\n    \n    int iterations = 0;\n    const int MAX_ITERATIONS = 92;\n    \n    while( (len2(zP) < R*R)  &&  (iterations < MAX_ITERATIONS)){\n        float temp = pow(len2(zP), float(n) / 2.0) * cos(float(n) * atan2(zP.y, zP.x)) + c.x;\n        zP.y = pow(len2(zP), float(n) / 2.0) * sin(float(n) * atan2(zP.y, zP.x)) + c.y;\n        zP.x = temp;\n        \n        iterations++;\n    }\n    \n    if (iterations == MAX_ITERATIONS){\n        return 1.0;\n    }\n        \n    else {\n        //To make sure output is normalized:\n        return float(iterations) / float(MAX_ITERATIONS);\n    }\n\n}\n\nvec3 Color(float value) {\n    //5 color palette:\n    vec3 white = vec3(1.0);\n    vec3 orange = rgb(255.0, 149.0, 0.0);\n    vec3 red = rgb(209.0, 23.0, 29.0);\n    vec3 blue = rgb(14.0, 5.0, 77.0);\n    vec3 black = vec3(0.0);\n    vec3 color;\n    \n    //Linear gradients:\n    if(value < 0.25){\n        value = 4.0 * value;\n        color = value * blue + (1.0 - value) * black;\n    }\n    else if (value <0.5){\n        value = 4.0 * value - 1.0;\n        color = value * red + (1.0 - value) * blue;\n    }\n    else if (value < 0.75){\n        value = 4.0 * value - 2.0;\n        color = value * orange + (1.0 -value) * red;\n    }\n    else {\n        value = 4.0 * value - 3.0;\n        color = value * white + (1.0 - value) * orange;\n    }\n    \n    return color;\n}\n","name":"Common","description":"","type":"common"}]}