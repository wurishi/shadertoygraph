{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Perlin Noise Sphere by Johannes Diemke 2012.\n//\n// description:\n// very simple and still impressive. the signed distance field is basically\n// sdf(p) := sdSphere(p) - scale * pnoise(p)\n// GLSL perlin noise implementation from taken from\n// https://github.com/ashima/webgl-noise\n//\n// UPDATE: uses now iqs fast 3d noise\n//\n// video:\n// http://www.youtube.com/watch?v=ntYFwDKEj4o\n//\n// contact:\n// johannes.diemke@uni-oldenburg.de\n\nfloat time\t = iTime * 0.2;\nfloat width  = iResolution.x;\nfloat height = iResolution.y;\n\nconst float DELTA  = 0.02;\nconst float PI\t   = 3.14159265;\n\nconst vec3 lightPosition  = vec3(0.1, 0.1, -1.0);\nvec3 cameraPosition = vec3(0.0, 2.0, -20.6);\nfloat aspect\t\t\t  = width / height;\n\n\n\nfloat sphere(vec3 position, float r) {\n\treturn length(position) - r;\n}\n\nvec3 rotateX(vec3 pos, float alpha) {\t\t\t\t\n\treturn vec3(pos.x,\n\t\t\t\tpos.y * cos(alpha) + pos.z * -sin(alpha),\n\t\t\t\tpos.y * sin(alpha) + pos.z * cos(alpha));\n}\n\nvec3 rotateY(vec3 pos, float alpha) {\n\treturn vec3(pos.x * cos(alpha) + pos.z * sin(alpha),\n\t\t\t\tpos.y,\n\t\t\t\tpos.x * -sin(alpha) + pos.z * cos(alpha));\n}\n\nvec3 translate(vec3 position, vec3 translation) {\n\treturn position - translation;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat snoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -100.0 ).xy;\n\t\n\tvec2 rj = texture( iChannel2, (uv+ 0.5)/256.0, -100.0 ).yx;\n\tvec2 rk = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).xy;\n\t\t\n\t\n\t//return mix( rg.x, rg.y, f.z );\n\treturn mix( rg.x * 4.0 + rk.x*0.7 + rj.x*0.5, rg.y * 4.0 + rk.y*0.7 + rj.y*0.5, f.z );\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nint colorIndex = 0;\n\n\nfloat function(vec3 position) {\n\t\n\tvec3 pos = rotateY(rotateX(position, time*2.0),time*1.5);\n\t\n\t//radius goes here\n\t//return opU(sphere(pos, 0.28)-0.38*snoise(vec3(pos*4.5+time*1.5)),\n\t//\t\t   udRoundBox( position-vec3(0.0,0.0,4.0), vec3(8.0,4.0,1.0), 0.2 ));\n\t\n\tfloat no = rand(fragCoord.xy);\n\t\n\t\n\tfloat minV = 20.0;\n\t\n\tfor(float i = 0.0; i < 30.0; i+=1.0)\n\t{\n\t\tfloat tempdis;\n\t\tfloat mm = mod(float(i),3.0);\n\t\tfloat s = sin(i);\n\t\tfloat c = cos(i);\n\t\tfloat t = tan(i);\n\t\tif(mm == 0.0)\n\t\t\ttempdis = sphere(pos-vec3(s,c,0.0), 0.18)-0.18*snoise(vec3(pos*4.5+time*1.5));\n\t\telse if (mm == 1.0)\n\t\t\ttempdis = sphere(pos-vec3(c,s,0.0), 0.18)-0.28*snoise(vec3(pos*4.5+time*1.5));\n\t\telse\n\t\t\ttempdis = sphere(pos-vec3(0.0,0.0,s*c), 0.28)-0.18*snoise(vec3(pos*4.5+time*1.5));\n\t\n\t\tif(tempdis < minV)\n\t\t\tminV = tempdis;\t\t\n\t}\n\t\n\treturn minV;\n}\n\nvec3 ray(vec3 start, vec3 direction, float t) {\n\treturn start + t * direction;\n}\n\nvec3 gradient(vec3 position) {\n\n\treturn vec3(function(position + vec3(DELTA, 0.0, 0.0)) - function(position - vec3(DELTA, 0.0, 0.0)),\n\tfunction(position + vec3(0.0,DELTA, 0.0)) - function(position - vec3(0.0, DELTA, 0.0)),\n\tfunction(position + vec3(0.0, 0.0, DELTA)) - function(position - vec3(0.0, 0.0, DELTA)));\n\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\t\n\tvec3 nearPlanePosition = vec3((fragCoord.x - 0.5 * width) / width * 2.0  * aspect,\n\t\t\t\t\t\t\t      (fragCoord.y - 0.5 * height) / height * 2.0,\n\t\t\t\t\t\t\t       0.0);\n\t\t\t\t\t\t\t  \n\tvec3 viewDirection = normalize(nearPlanePosition - cameraPosition);\n\t\n\tfloat t = 0.0;\n\tfloat distance;\n\tvec3 position;\n\tvec4 color = vec4(vec3(1.,0.2,0.4),1.0);// plasma();//vec4(0.0,0.2,0.0,1);\n\tvec3 normal;\n\tvec3 up = normalize(vec3(-0.0, 1.0,0.0));\n\t\n\t//cameraPosition -= vec3(0.1,0.0,0.0) * iTime;\n\t\n\tfor(int i=0; i < 40; i++) {\n\t\tposition = ray(cameraPosition,\tviewDirection, t) ;\n\t\tdistance = function(position);\t\n\t\n\t\t\n\t\tif(distance < 0.0002) {\n\t\t\t\n\t\t\t\t\n\t\t\tnormal = normalize(gradient(position));\n\t\t\t\n\t\t\tvec4 color1 = vec4(0.7, 0.9, 0.5,1.0);\n\t\t\tvec4 color2 = vec4(1.0, 0.1, 0.1,1.0);\n\t\t\t\n\t\t\tvec4 color3 = mix(color2, color1, (1.0+dot(up, normal))/2.0);\n\t\t\t\n\t\t\t//if(colorIndex == 1) color3 = vec4(float(0xAD)/255.0,float(0xFF)/255.0,float(0x2F)/255.0,1.0);\n\t\t\t//if(colorIndex == 2) color3 = plasma();\n\t\t\tcolor = color3*0.7 * max(dot(normal, normalize(lightPosition-position)),0.0) ;//+vec4(0.1,0.1,0.1,1.0);\n\n\t\t\t//specular\n\t\t\tvec3 E = normalize(cameraPosition - position);\n\t\t\tvec3 R = reflect(-normalize(lightPosition-position), normal);\n\n\t\t\t\n\t\t\tfloat specular = pow( max(dot(R, E), 0.0), \n\t\t                 39.0);\n\t\t\t\n\t\t\tfloat alpha = 1.0-clamp( pow(length(position-vec3(0.0,0.0,1.0)),3.0)*0.0018,0.0, 1.0);\n\t\t\t\n\t\t\tfloat ao = 1.0;//computeAO(position, normal);\n\t\t\t//color = vec4(color.xyz * ao, 1.0);\n\n\t\t\t//sss\n\t\t\tfloat sss = 1.0 ;//-computeAO(position,viewDirection)*3.0;\n\n\t\t\tfloat shad = 1.0;//computeShadow(position+normalize(lightPosition-position)*0.1);\n\n//\t\t\tif(dot(normalize(lightPosition-position), normal) < 0.0)\n//\t\t\t\tshad =0.3;\n\t\t\tfloat shadow =0.3+ 0.7 * shad;\n\n\t\t\t  color = vec4(color.xyz *shad+ color3.xyz*0.4*ao, 1.0);\n\n\n\t\t\tcolor +=vec4(0.6, 0.4,0.4,0.0)*specular *shad;\n\t\t\tcolor =mix( color,vec4(1.0, 0.5,0.1,1.0),(1.0-sss));\n\t\t\t\n\t\t\t// interation glow\n\t\t\tcolor += vec4(vec3(0.5, 0.8,0.1)*0.8*pow(float(i)/32.0*1.0, 2.0),1.0);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\tt = t + distance * 0.68;\n\t}\n\t\t\t\t\t\t\t\t  \t\t\t\t\t\t  \n\tfragColor = color;\t\t\t\t\t\t\t\t  \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":true,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldjGRW","date":"1384663922","viewed":200,"name":"new sijie","username":"tiansijie","description":"sijie","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sijie"],"hasliked":0,"parentid":"","parentname":""}}