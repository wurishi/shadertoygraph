{"ver":"0.1","info":{"id":"cl2fRh","date":"1694938869","viewed":49,"name":"skankandbass noise","username":"tintingai","description":"trying to recreate the animation of the youtube channel skankandbass : https://www.youtube.com/watch?v=3Rnff6X0veI","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"skankandbass noise\" by tintingai. https://shadertoy.com/view/7dlyzB\n// 2023-09-03 17:33:27\n\n/* src: \nhttp://www.cochoy.fr/pdfs/perlin-noise/perlin_noise.pdf\nhttps://www.shadertoy.com/view/MtGSRW\nhttps://iquilezles.org/articles/distfunctions2d\n*/\nconst float texture_width = 256.0;\n\nconst float VITESSE = 100.f;\nconst float FREQUENCE = 128.f;\nconst int MODULO = 7;\nconst int EPAISSEUR = 3;\n\nconst vec3 color0 = vec3(0.0);//vec3(0.5058, 0.5607, 0.9764);\nconst vec3 color1 = vec3(0.5);\nconst vec3 color_fence = vec3(1.0, 0.9, 0.0);\nconst vec2 window = vec2(0.45, 0.45);\n\n\nfloat cubic_interpolation(float t) {\n  return t*t*t*( t*(t*6.0 - 15.0) + 10.0);\n}\n\nvec3 color_noise(vec3 p){\n\tconst float texture_width = 256.0;\n\tvec4 v = texture(iChannel0, vec2((p.x+p.z) / texture_width, (p.y-p.z) / texture_width));\n    return normalize(v.xyz*2.0 - vec3(1.0));\n}\n\nfloat perlin_noise(vec3 p){\n    \n    /*get 8 nearest interger points*/\n    vec3 p0 = floor(p);\n    vec3 p1 = p0 + vec3(1.0, 0.0, 0.0);\n    vec3 p2 = p0 + vec3(0.0, 1.0, 0.0);\n    vec3 p3 = p0 + vec3(1.0, 1.0, 0.0);\n    vec3 p4 = p0 + vec3(0.0, 0.0, 1.0);\n    vec3 p5 = p0 + vec3(1.0, 0.0, 1.0);\n    vec3 p6 = p0 + vec3(0.0, 1.0, 1.0);\n    vec3 p7 = p0 + vec3(1.0, 1.0, 1.0);\n    \n    /*get color of this points*/\n    vec3 cp0 = color_noise(p0);\n    vec3 cp1 = color_noise(p1);\n    vec3 cp2 = color_noise(p2);\n    vec3 cp3 = color_noise(p3);\n    vec3 cp4 = color_noise(p4);\n    vec3 cp5 = color_noise(p5);\n    vec3 cp6 = color_noise(p6);\n    vec3 cp7 = color_noise(p7);\n    \n    /*get decimal part of p*/\n    float fx = p.x-p0.x;\n    float fy = p.y-p0.y;\n    float fz = p.z-p0.z;\n    \n    /*compute cubic_interpolation of the decimal part*/\n    float fx_inter = cubic_interpolation(fx);\n    float fy_inter = cubic_interpolation(fy);\n    float fz_inter = cubic_interpolation(fz);\n    \n    /* Calculate dot products and interpolate.*/\n    float p0p1 = (1.0 - fx_inter) * dot(cp0, (p - p0)) + fx_inter * dot(cp1, (p - p1)); /* between upper two lattice points */\n    float p2p3 = (1.0 - fx_inter) * dot(cp2, (p - p2)) + fx_inter * dot(cp3, (p - p3)); /* between lower two lattice points */\n    \n    float p4p5 = (1.0 - fx_inter) * dot(cp4, (p - p4)) + fx_inter * dot(cp5, (p - p5)); /* between upper two lattice points */\n    float p6p7 = (1.0 - fx_inter) * dot(cp6, (p - p6)) + fx_inter * dot(cp7, (p - p7)); /* between lower two lattice points */\n\n    float t1 = (1.0 - fy_inter) * p0p1 + fy_inter * p2p3;\n    float t2 = (1.0 - fy_inter) * p4p5 + fy_inter * p6p7;\n\n    /* Calculate final result */\n    return (1.0 - fz_inter) * t1 + fz_inter * t2;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    /*compute intensity from perlin noise and extract shade of gray in color_noise*/\n    float intensite = perlin_noise(vec3(fragCoord.xy, iTime*VITESSE)/ FREQUENCE);\n    vec3 color_noise = mix(vec3(0.0), vec3(1.0), intensite*0.5 + 0.5);\n    \n    /*recoordonate coords from -0.5 to 0.5 for x and y*/\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    /*create weirde shape with modulo*/\n    vec3 color = mix( color0, color1,    \n        smoothstep(0., 100./FREQUENCE, abs(mod(color_noise*100.+3.5/2.,7.)-3.5 )-3.5/2.) \n    );\n\n\n    \n    /*filter pixel outside the rectangle*/\n    if(uv.x < -window.x || uv.x > window.x) color = color0;\n    if(uv.y < -window.y || uv.y > window.y) color = color0;\n    \n    /*create yellow window / fence*/\n    float lenrec = sdBox(uv, window);\n    if( int(lenrec*iResolution.x) == 0) \n        color = color_fence;\n    \n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}