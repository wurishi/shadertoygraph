{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n\n// Divide the view into multiple viewports\n// Set global variables to replace iResolution and fragCoord for the local viewport\n// Returns index of which panel is being drawn for this pixel\n// in the range [0,numPanels.x*numPanels.y)\nvec2 view_Resolution;\nvec2 view_FragCoord;\nint view_Index;\nvec4 view_selectionRelativeMouse;\n/*bool SideMenu( ivec2 numPanels )\n{\n\t// arrange so that the main view and the side views have the same aspect ratio\n\tvec2 dims = vec2(\n\t\t\t\t\t\tiResolution.x/float(numPanels.x+numPanels.y), // main view is sv.y times bigger on both axes!\n\t\t\t\t\t\tiResolution.y/float(numPanels.y)\n\t\t\t\t\t\t);\n\n\n\t// which one is selected?\n\tivec2 viewIndex = ivec2(floor(iMouse.xy/dims));\n\n\tint selectedPanel = 0;\n\tif ( viewIndex.x < numPanels.x )\n\t{\n\t\tselectedPanel = viewIndex.y+viewIndex.x*numPanels.y;\n\t}\n\t\n\n\t// figure out which one we're drawing\n\tviewIndex = ivec2(floor(fragCoord.xy/dims));\n\n\tint index;\n\tvec4 viewport;\n\tif ( viewIndex.x < numPanels.x )\n\t{\n\t\tviewport.xy = vec2(viewIndex)*dims;\n\t\tviewport.zw = dims;\n\t\tindex = viewIndex.y+viewIndex.x*numPanels.y;\n\t}\n\telse\n\t{\n\t\t// main view, determined by where the last click was\n\t\tviewport.x = float(numPanels.x)*dims.x;\n\t\tviewport.y = 0.0;\n\t\tviewport.zw = dims*float(numPanels.y);\n\t\tindex = selectedPanel;\n\t}\n\t\n\t// highlight currently selected\n\tif ( index == selectedPanel && viewIndex.x < numPanels.x &&\n\t\t( fragCoord.x-viewport.x < 2.0 || viewport.x+viewport.z-fragCoord.x < 2.0 ||\n\t\t  fragCoord.y-viewport.y < 2.0 || viewport.y+viewport.w-fragCoord.y < 2.0 ) )\n\t{\n\t\tfragColor = vec4(1,1,0,1);\n\t\treturn false;\n\t}\n\t\n\t// compute viewport-relative coordinates\n\tview_FragCoord = fragCoord.xy - viewport.xy;\n\tview_Resolution = viewport.zw;\n\tview_Index = index;\n\n\tview_selectionRelativeMouse = fract(iMouse/dims.xyxy);\n\t\n\treturn true;\n}*/\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = view_FragCoord.xy - view_Resolution.xy*.5;\n\tray.z = view_Resolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec2 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p + f;\n\n#if (1)\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n\tvec4 rg = mix( mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+1.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn rg;\n}\n\nfloat DistanceField( vec3 pos );\n\nvec3 Normal( vec3 pos )\n{\n\tconst vec2 delta = vec2(0,.01);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\treturn normalize(grad);\n}\n\n\n// ----------------------\n\nfloat RippleHeight( vec2 pos )\n{\n\tvec2 p = pos+vec2(-1,.2)*iTime;\n\t\n\tp += vec2(1,0)*Noise(p).y; // more natural looking ripples\n\tfloat f = Noise(p).x-.5;\n\tp *= 2.0;\n\tp += vec2(0,-.5)*iTime;\n\tf += (Noise(p).x-.5)*.2;\n\tp *= 2.0;\n\tp += vec2(-3,0)*iTime;\n\tf += (Noise(p).x-.5)*.05;\n\t\n\tf = f*(1.0-exp2(-abs(pos.x)));\n\treturn f*1.0;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\treturn (RippleHeight(pos.xy)-pos.z)*.5;\n}\n\n// map a uv space onto a distorted surface\nvec2 UVMapping( vec2 target )\n{\n\t// need to march vertically to absorb vertical creases, and horizontally for horizontal ones\n\t// cheat, by seperating these two\n\tvec2 uv = vec2(0);\n\t\n\tconst int n = 16;\n\tconst float fudge = 1.0; // use values > 1 to allow for extra ripples we're not measuring\n\tvec2 d = target/float(n);\n\tvec2 l;\n\tl.x = RippleHeight( vec2(0,target.y) );\n\tl.y = RippleHeight( vec2(target.x,0) );\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tvec2 s;\n\t\ts.x = RippleHeight( vec2(d.x*float(i),target.y) );\n\t\ts.y = RippleHeight( vec2(target.x,d.y*float(i)) );\n\t\t//uv.x += sign(d.x)*sqrt(pow(fudge*,2.0)+d.x*d.x);\n\t\t//uv.y += sign(d.y)*sqrt(pow(fudge*,2.0)+d.y*d.y);\n\t\tuv += sign(d)*sqrt(pow(fudge*(s-l),vec2(2.0))+d*d);\n\t\tl = s;\n\t}\n\t\n\treturn (uv+vec2(0,1))/vec2(3.0,2.0);\n}\n\nvec3 Pattern( vec2 uv )\n{\n\tif ( view_Index == 0 )\n\t{\n\t\t// nyan cat\n\t\tfloat frame = 0.0;//floor(iTime*8.0)\n\t\tvec4 t = texture( iChannel1, uv*vec2(1.0/6.4,-1)+vec2(fract(frame/6.0)*.938,1) );\n\t\tfloat f = uv.y*5.5+1.9; //*tau\n\t\treturn mix( vec3(cos(f),-sin(f),-cos(f))*.5+.5, ToLinear(t.rgb), t.a );\n\t}\n\t\n\tif ( view_Index == 1 )\n\t{\n\t\t// gay pride (roughly)\n\t\tuv.y = floor(uv.y*6.0)/6.0+.3;\n\t\treturn vec3(cos(uv.y*tau),-sin(uv.y*tau),-cos(uv.y*tau))*.5+.5;\n\t}\n\n\tif ( view_Index == 2 )\n\t{\n\t\t// Sweden (because it's easy)\n\t\treturn mix( vec3(1,.6,0), vec3(.02,.1,.5), smoothstep(.095,.1,min(abs(uv.x-.4),abs(uv.y-.5))) );\n\t}\n\t\n//\tif ( view_Index == 3 )\n\t{\n\t\t// union jack\n\t\tvec3 b = vec3(0,0,.5);\n\t\tvec3 w = vec3(1);\n\t\tvec3 r = vec3(.8,0,0);\n\t\tvec3 col = b;\n\t\t\n\t\tuv = uv*2.0-1.0;\n\t\tcol = mix( w, col, smoothstep( .245,.255, min(abs(uv.y-uv.x-.05),abs(uv.y+uv.x-.05)) ) );\n\t\tcol = mix( r, col, smoothstep( .095,.105, min(abs(uv.y-uv.x),abs(uv.y+uv.x)) ) );\n\t\n\t\tfloat q = min(abs(uv.x*1.5),abs(uv.y));\n\t\tcol = mix( w, col, smoothstep( .245,.255, q ) );\n\t\tcol = mix( r, col, smoothstep( .145,.155, q ) );\n\t\t\n\t\treturn col;\n\t}\n}\n\n// xyz = normal, w = transmission from far side\nvec4 Weave( vec2 uv )\n{\n\tvec2 a = uv*vec2(3.0,2.0)*view_Resolution.y*.85;\n\tfloat h = (sin(a.x)+sin(a.y))*.25+.5;\n\t\n\th = h*.1; // transparency within the flag\n\t\n\t// edges\n\th = max(h,smoothstep(.495,.5,abs(uv.x-.5)));\n\th = max(h,smoothstep(.495,.5,abs(uv.y-.5)));\n\t\n\treturn vec4(0,0,0,h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// since Chrome 36 the extra logic for the SideMenu won't compile on some PCs (my work PC is ok, my home one is not)\n\tview_Resolution = iResolution.xy;\n\tview_FragCoord = fragCoord.xy;\n\tview_Index = 1;\n\tview_selectionRelativeMouse = iMouse/view_Resolution.xyxy;\n\n\t//if ( SideMenu( ivec2(1,4) ) )\n\t{\n\t\tvec3 pos, ray;\n\t\tCamPolar( pos, ray, vec3(1.5,0,0), vec2(-.8,-.5)+vec2(.9,1.5)*view_selectionRelativeMouse.yx, 10.0, 3.5 );\n\t\t\n\t\tfloat t = 0.0;\n\t\tfloat h = 1.0;\n\t\tfor ( int i=0; i < 20; i++ )\n\t\t{\n\t\t\tif ( h < .01 )\n\t\t\t\tbreak;\n\t\t\tfloat h = DistanceField( pos+t*ray );\n\t\t\tt += h;\n\t\t}\n\t\t\n\t\tpos += t*ray;\n\n\t\tvec2 uv = UVMapping( pos.xy );\n\t\t\n\t\tvec3 col = Pattern( uv );\n\t\t\n\t\tvec4 weave = Weave(uv);\n\t\t\n\t\tvec3 normal = Normal( pos );\n\t\t\n\t\tfloat nl = dot(normal,normalize(vec3(-3,1,-2)));\n\t\tfloat l = max( nl, .0 );\n\t\tfloat bl = (max( -nl, .0 ))*(weave.a*.0);\n\t\tcol *= (l + bl*vec3(1,.8,1))*vec3(1.2,1.1,1) + vec3(.1,.13,.2);\n\t\t\n\t\t//if ( uv.x < .0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 )\n\t\tcol = mix( col, vec3(.5,.65,.9)*(Noise(ray.xy*4.0).x*.3+1.0), weave.a );\n\t\t\n\t\tcol = mix( col, vec3(cos(uv.x*50.0)),smoothstep(0.015,0.01,abs(uv.x+.01))*smoothstep(1.01,1.0,uv.y));\n\t\t\n\t\tfragColor = vec4(ToGamma(col),1.0);\n\t}\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldX3DX","date":"1380476396","viewed":3941,"name":"Rippling Flag","username":"TekF","description":"March along the ripples of the flag to get a fairly good uv mapping that prevents the pattern stretching when the flag ripples.","likes":76,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","uvmapping"],"hasliked":0,"parentid":"","parentname":""}}