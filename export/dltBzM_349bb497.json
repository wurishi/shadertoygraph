{"ver":"0.1","info":{"id":"dltBzM","date":"1701185278","viewed":82,"name":"Mandelbulb SDF raymarcher","username":"BearKirb","description":"An unfinished mandelbulb sdf raymarcher.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","sdf","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/rmshadows\nfloat Mand(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float Bailout=2.0;\n    float Power=8.0;\n    int Iterations = 4;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\nfloat Sphere(vec3 center, float r, vec3 point){\nreturn length(center-point)-r;\n}\nfloat minMore(float t[2]){\nfloat mind = 10000000.0;\nfor(int i=0;i<t.length();i++){\nmind = min(mind,t[i]);\n}\nreturn mind;\n}\nfloat Plane( vec3 p, vec3 n, float h )\n{\n  n = normalize(n);\n  return dot(p,n) + h;\n}\nfloat Scene( vec3 pos )\n{\n   \n    float f3 = Mand(pos);\n\n    return f3;\n}\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n  vec3 po=rd;\n  int breaki=0;\n  float minDist=10000.0;\n    for( int i=0; i<124; i++ )\n    {\n  \n        po -= normalize(rd-ro) * Scene(po);\n      \n    if( Scene(po)<0.001){\n        if(distance(po,ro)<0.01){\n            return 1.0;\n            }else{\n            return 0.0;\n            }\n            }\n      \n      \n    }\n        \n    return 1.0;\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(22.987, 87.293))) *\n        43758.5453123);\n}\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*8e-6;\n    return normalize( e.xyy*Scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*Scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*Scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*Scene( pos + e.xxx ) );\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 8.0*(fragCoord-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, \n\t\t\t\t1 ) ); \n    vec3 pos = vec3(-0.0,0,-3.0); \n    \n  \n vec3 cameraPos = pos; \n    vec2 angle = vec2(iTime,.3);\nangle = -(iMouse.xy/iResolution.xy-.5)*3.14+vec2(3.14,0.0);\n\tRotate(pos,angle);\n \n\tRotate(ray,angle);\n    Rotate(cameraPos,angle);\n   \n    float minDist=100.0;\n    \n    for ( int i=0; i < 90; i++ )\n    {\n        float h = Scene(pos);\n   \n        if ( h < 0.001 )\n        {\n          \n            break;\n        }\n        pos += ray*(h);\n    }\n  \n \n      vec3 lightSource = vec3(10.0*cos(iTime),10.0,10.0*sin(iTime));\n    fragColor.rgb = vec3(0.0,0.0,0.0);\n  \n     \n        vec3 normal;\n      vec3 normal2;\n  \n        normal = calcNormal(pos);\n\n\n\n\t\tfloat light = (max(max(.0,dot(normal,-normalize(cameraPos-pos))),dot(normal,normalize(cameraPos-pos))));\n    \n        vec3 ballColor= vec3(0.1,0.1,0.1);\n       \n        vec3 lightCol = vec3(0.4,0.4,0.4);\n        vec3 ambient = vec3(sin(-normal.x*2.0),sin(normal.y*2.0),sin(normal.z*2.0));\n      \n        vec3 spec = lightCol*4.0;\n        vec3 total =  ((7.0*light*lightCol-0.1) + 4.0*pow(light,264.0)*spec)/2.0;\n        float dist = distance(pos,vec3(0,0,0))*1000.0-1000.0;\n          fragColor.rgb +=ambient/8.0+ vec3(0.4,0.4,0.4)+4.0*vec3(1.0/dist,0.4/dist,0.0); \n        fragColor.rgb *= (total);\n      \n     \n        \n     \n    \n    \n \n    fragColor.rgb = fragColor.rgb + random(ray.xy)/128.0;\n    // Output to screen\n  \n}","name":"Image","description":"","type":"image"}]}