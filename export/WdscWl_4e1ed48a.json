{"ver":"0.1","info":{"id":"WdscWl","date":"1585842504","viewed":252,"name":"smoothMinimum - springMounted","username":"netgrind","description":"smoothMinimum - springMounted - 639 Hz\nSoft sounds synthesized at the start of spring\ntuned to 639hz to foster connection, communication, and love in this isolated time\nhttps://soundcloud.com/sinefool/smoothminimum-springmounted-639hz","likes":15,"published":1,"flags":96,"usePreview":0,"tags":["ambient","smoothminimum","meditation","springmounted","639"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltjGDz","filepath":"https://soundcloud.com/sinefool/smoothminimum-springmounted-639hz","previewfilepath":"https://soundcloud.com/sinefool/smoothminimum-springmounted-639hz","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visual accompaniment to smoothMinimum - springMounted - http://sinefool.com\n\n// Switch from ray march to ray trace in buffer A if it is too heavy on your machine\n\n// Bloom from https://www.shadertoy.com/view/lsBfRc by robobo1221\n// Helix from https://www.shadertoy.com/view/MstcWs by tdhooper\n// Big thanks to iq for everything field related\n\nvec3 c0 = vec3(0., 0.11, .2);\nvec3 c1 = vec3(.2, .7, .8);\nvec3 c2 = vec3(.5, 1., .6);\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(.0);\n\tvec3 amt = vec3(2.);\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),amt)       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),amt) * 1.3      + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),amt) * 1.6      + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),amt) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),amt) * 2.2 \t   \t+ blur;\n\n    return blur * 24.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * 24., vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color = jodieReinhardTonemap(color);\n    \n    color = mix(c0, mix(c1, c2, max(0., color.r*2.-1.)), min(color.r*2., 1.));\n\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define TRACE\n\n#define line1 s_ m_ o_ o_ t_ h_ M_ i_ n_ i_ m_ u_ m_ crlf  s_ p_ r_ i_ n_ g_ M_ o_ u_ n_ t_ e_ d_\n#define chars 13.\n\nconst int iterationsMarch =64;\nconst float dist_epsMarch = .1;\nconst int iterationsTraceForm =512;\nconst int iterationsTraceText =128;\nconst float traceStep = .1;\nconst float dist_epsTrace = .1;\nconst float ray_max = -2.;\nconst float form_max = -20.;\n\nfloat rounding = 2.;\nfloat textWidth = .01;\nfloat text( vec3 pos )\n{\n    float f = sin(pos.y*.2*sin(iTime*.1)+pos.x*.1-iTime*.25+sin(iTime*.5-pos.y*.033)*.1+cos(iTime*.3+pos.y*.1)*.15)*.9+.9;\n    float smoothing = pow(smoothstep(5., 2., abs(pos.y)), 5.)*1.+.6;\n    smoothing += f;\n    float walls = sdBox(abs(pos)-vec3(0., 3.5+f*5., 0.), vec3(32.8, .0, .0));\n\n    pR(pos.zx, sin(iTime*.2-pos.x)*.01);\n    pos.x+=spacing.x*(chars-.75)*.5;\n    pos.y-= spacing.w*.5;\n    \n    float text = 100.;\n    float nr = 0.;\n    vec2 uv = pos.xy; \n    float width = textWidth;\n    line1;\n    // bubble the text\n    text = length(vec2(text, pos.z));\n    width+=(sin(iTime-pos.y+pos.x*.2)*width+width)*.1;\n    text-=width;\n    \n    text = smin(text, walls, smoothing);\n    \n    return text;\n    \n}\n\nfloat form( vec3 pos )\n{   \n    float walls = sdBox(pos, vec3(32.8, 16.6, 50.));\n    walls = sub( sdBox(pos, vec3(20.8, 13.8, 50.)-rounding)-rounding, walls);\n\n    pos.z += 10.;\n    vec3 p = pos;\n    \n    float s = smoothstep(19., 28., pos.y)*6.;\n    float w = sin(iTime*2.-pos.y*.5+cos(iTime*4.))*.2+s;\n    float box = length(pos.xz)-w-1.;//sdBox(pos, vec3(w, 200., w))-1.;\n    \n    w = smoothstep(1., 15.,abs(p.y))*7.;\n    pos.y += cos(iTime*1.+pos.y*.2)*.7;\n    float size = smoothstep(26., 10., pos.y)*.5+.5;\n    pos.y-=mod(iTime*1., 6.);\n    box = smin(box, length(pos.yxz - closestHelix(pos.yxz, 6., 3.+w))-size, 3.);\n    \n    pos = p;\n    pR(pos.xz,(iTime*.2)*sign(pos.y));\n    float i = pModPolar(pos.xz, 12.)*.0833333;\n    pos.y = abs(pos.y);\n    float circ = length(pos-vec3(15., 8.+sin(iTime*.4+i*6.28)*2., 0.))-1.;\n    \n    walls = smin(walls, box, .8);\n    walls = min(walls, circ);\n    return walls; \n}\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(0.01,0.0);\n   return normalize(vec3(\n      text(p + e.xyy) - text(p - e.xyy),\n      text(p + e.yxy) - text(p - e.yxy),\n      text(p + e.yyx) - text(p - e.yyx) ));\n}\nvec3 normalForm(vec3 p)\n{\n   const vec2 e = vec2(0.01,0.0);\n   return normalize(vec3(\n      form(p + e.xyy) - form(p - e.xyy),\n      form(p + e.yxy) - form(p - e.yxy),\n      form(p + e.yyx) - form(p - e.yyx) ));\n}\n\nvec4 traceText(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   float c = 0.;\n   #ifdef TRACE\n   for(int i=0; i<iterationsMarch; ++i) {\n   \t  float dist = text(p)-.1;\n      if (dist < dist_epsMarch) return vec4(p, c);\n      if (p.z < ray_max) return vec4(p, -c);\n      p += dist*ray_dir;\n      ray_len += dist;\n      float f = pow(smoothstep(2.2+sin(p.x*3.3-iTime+p.y*.5)*.2, -0., dist), 8.);\n      c = max(c, f*9.);\n   }\n   #else\n   for(int i=0; i<iterationsTraceText; ++i) {\n   \t  float dist = text(p);\n      if (dist < dist_epsTrace) return vec4(p, c);\n      if (p.z < ray_max) return vec4(p, -c);\n      p += traceStep*ray_dir;\n      ray_len += traceStep;\n      float f = pow(smoothstep(2.2+sin(p.x*3.3-iTime+p.y*.5)*.2, -0., dist), 8.);\n      c = max(c, f*9.);\n   }\n   #endif\n   return vec4(p, -c);\n}\nvec4 traceForm(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   #ifdef TRACE\n   for(int i=0; i<iterationsMarch; ++i) {\n   \t  float dist = form(p);\n      if (dist < dist_epsMarch) break;\n      if (p.z < form_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   #else\n    for(int i=0; i<iterationsTraceForm; ++i) {\n   \t  float dist = form(p);\n      if (dist < dist_epsTrace) break;\n      if (p.z < form_max) return vec4(0.0);\n      p += traceStep*ray_dir;\n      ray_len += traceStep;\n   }\n   #endif\n   return vec4(p, 1.0);\n}\n\nfloat shadeText(vec3 ray_start, vec3 ray_dir)\n{\n    vec4 hit = traceText(ray_start, ray_dir);\n   \tfloat color;\n   \tif (hit.w < 0.0) {\n    \tcolor = 0.;\n   \t} else {\n      \tvec3 dir = hit.xyz - ray_start;\n      \tvec3 norm = dNormal(hit.xyz);\n       \tcolor = max(0., dot(norm, vec3(sin(iTime)*.05, cos(iTime)*.05, 1.))*smoothstep(ray_max,0., hit.z));\n   \t}\n     color+=hit.w*.06*(1.-color);\n\treturn pow(color, 2.);\n}\n\nfloat shadeForm(vec3 ray_start, vec3 ray_dir)\n{\n    vec4 hit = traceForm(ray_start, ray_dir);\n   \tfloat color;\n   \tif (hit.w == 0.0) {\n      \tcolor = 0.;\n   \t} else {\n      \tvec3 dir = hit.xyz - ray_start;\n      \tvec3 norm = normalForm(hit.xyz);\n       \tcolor = norm.z*smoothstep(form_max,0., hit.z);\n   \t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy / iResolution.xy)*2.;\n    uv -= 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    float value = 0.;\n    if(max(abs(uv.x), abs(uv.y))<.95){\n        if(uv.y<-.525){\n            uv.y+=.73625;\n            \n            float cam_dist = 24.;\n            vec3 pos = vec3(0., 0., cam_dist);\n            \n            vec3 d = vec3(uv.xy, -1.);\n            vec3 dir = normalize(d);\n            value = shadeText(pos+(d*21.), dir);\n            uv.y*=4.65;\n            uv.x*=1.05;\n    \t\tvalue *= smoothstep(1., 0.,sqrt(pow(abs(uv.x), 20.) + pow(abs(uv.y), 4.)));\n            \n            \n        }else if( uv.y > -.475){\n            uv.y-=.23625;\n        \t\n            float cam_dist = 24.;\n            vec3 pos = vec3(0., 0., cam_dist);\n            \n            vec3 d = vec3(uv.xy, -1.);\n            vec3 dir = normalize(d);\n            value = shadeForm(pos, dir);\n            uv.y*=1.39;\n            uv.x*=1.05;\n    \t\tvalue *= smoothstep(1., 0.,sqrt(pow(abs(uv.x), 20.) + pow(abs(uv.y), 20.)));\n        }\n    }\n    // soft box edges\n    value= clamp(value, 0., 1.);\n   \tvec3 color = vec3(value*.1);//mix(c0, mix(c1, c2, max(0., value*2.-1.)), min(value*2., 1.));\n    \n   \tfragColor = vec4(color, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*********************************\n************ TEXT ************\n**********************************/\n\nconst vec2 size = vec2(.6, -.6);\nconst vec2 edge = vec2(size.x, 0.);\nconst vec2 xLine = vec2(0., 0.);\nconst vec4 spacing = vec4(size.x*5., size.x*1.5, 0., 3.5);\n\n//Space\n#define _ nr--;\n//Space\n#define _half nr-=.5;\n\n//Next line\n#define crlf uv.y += spacing.w; nr = 0.;\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat polysmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat powersmin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat sub( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n//font shapes\n\nfloat circle(vec2 uv){\n\treturn abs(length(uv)-size.x);   \n}\nfloat circleS(vec2 uv){\n\treturn abs(length(uv)-size.x*.5);   \n}\n\nfloat vert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x)));   \n}\nfloat halfvert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x*.5)));   \n}\nfloat hori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x),uv.y));   \n}\nfloat halfhori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x*.5),uv.y));   \n}\nfloat diag(vec2 uv){\n\treturn length(vec2(max(0.,abs((uv.y-uv.x))-size.x*2.),(uv.y+uv.x)*.75));   \n}\nfloat halfdiag(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x-uv.y)-size.x),uv.y+uv.x));   \n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    float x = circle(uv);\n    x = mix(x, min(vert(uv-edge), vert(uv+edge)), step(uv.y, 0.));\n    x = min(x, hori(uv-xLine));\n    return x;\n}\nfloat bb(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-xLine));\n    x = mix(min(circleS(uv-size.xx*.5),circleS(uv-size*.5)),x, step(uv.x, .5));\n    return x;\n}\nfloat cc(vec2 uv) {\n    float x = circle(uv);\n    float p = .8;\n    float a = atan(uv.x, abs(uv.y));\n    a = smoothstep(.7, 1.5707, a);\n   \tx += a;\n    uv.y = -abs(uv.y);\n    x = min(length(uv+size.x*vec2(-cos(p), sin(p))), x);\n    return x;\n}\nfloat dd(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv),x, step(uv.x, 0.));\n    return x;\n}\nfloat ee(vec2 uv) {\n    float x = cc(uv);\n    x = mix(circle(uv), x, step(uv.y, 0.));\n    x = min(x, hori(uv));\n    return x;\n}\nfloat ff(vec2 uv) {\n   \tfloat x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv), x, step(min(-uv.x, uv.y), 0.));\n    x = min(x, halfhori(uv+edge*.5));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = cc(uv);\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    x = min(x, halfhori(uv-edge*.5));\n    return x;\n}\nfloat hh(vec2 uv) {\n    float x = vert(abs(uv)-edge);\n    x = min(x, hori(uv));\n    //x = min(x, circle(uv+edge.yx));\n    //x = mix(x, min(length(uv-size.xy), length(uv-size.yy)), step(uv.y, size.y));\n    return x;\n}\nfloat ii(vec2 uv) {\n    return hh(uv.yx);\n}\nfloat jj(vec2 uv) {\n    float x = vert(uv-edge);\n    x = min(x, length(uv+edge));\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    return x;\n}\nfloat kk(vec2 uv) {\n    uv.y = abs(uv.y);\n    float x = circle(uv-edge.yx);\n    x = mix( length(uv-size.xx),x,step(uv.y, size.x)); \n    x = mix(x,min(vert(uv+edge), hori(uv)), step(uv.x, 0.));\n    return x;\n}\nfloat ll(vec2 uv) {\n    return min(vert(uv+edge), hori(uv+edge.yx));\n}\nfloat mm(vec2 uv) {\n    float f = vert(uv+edge);\n    uv.x = abs(uv.x);\n    float x = vert(uv-edge);\n    x = min(x, vert(uv-edge.yx*.5));\n    x = mix( circleS(uv-size.xx*.5),x, step(uv.y, size.x*.5));\n    x = min(x, f);\n    return x;\n}\nfloat MM(vec2 uv) {\n    uv.x -= size.x*1.25;\n    //uv.y -= size.x*.25;\n    uv.x = abs(uv.x);\n    float x = length(vec2(uv.x-edge.x*1.5,max(0.,abs(uv.y)-size.x*1.5)));   \n    uv.x -= size.x*0.75;\n    uv = rotate(uv, 1.9);\n    x = smin(x, length(vec2(max(0.,abs((uv.y-uv.x))-size.x*2.5),(uv.y+uv.x)*.75)), 20.);\n    return x;\n}\nfloat nn(vec2 uv) {\n    float x = circle(uv);\n    x = mix(min(vert(uv-edge), vert(uv+edge)), x, clamp(ceil(uv.y), 0., 1.));\n    return x;\n}\nfloat oo(vec2 uv) {\n    return circle(uv);\n}\nfloat pp(vec2 uv) {\n    float x = hori(uv);\n    x = min(x, hori(uv-edge.yx));\n    x = mix( circleS(uv+size.yy*.5),x, step(uv.x, size.x*.5));\n    x = min(x, vert(uv+edge));\n    return x;\n}\nfloat qq(vec2 uv) {\n    float x = circle(uv);\n    x = min(x, halfdiag(uv-size.xy*.5));\n    return x;\n}\nfloat rr(vec2 uv) {\n    float x = min(hori(uv-edge.yx), vert(uv+edge));\n    x = mix(x, circle(uv), step(0., min(-uv.x, uv.y)));\n    return x;\n}\nfloat ss(vec2 uv) {\n    float x = hori(uv-edge.yx);\n    x = min(x, halfhori(uv));\n    vec2 u = uv;\n    u+=vec2(-size.y*.5, size.y*.5);\n    x = mix(circleS(u),x, step(-edge.x*.5, uv.x));\n    \n    float x2 = hori(uv+edge.yx);\n    x2= min(x2, halfhori(uv));\n    u = uv;\n    u-=vec2(-size.y*.5, size.y*.5);\n    x2 = mix(x2,circleS(u),step(edge.x*.5, uv.x));\n    \n    return min(x,x2);\n}\nfloat tt(vec2 uv) {\n    /*float x = min(hori(uv+edge.yx), vert(uv+edge));\n    x = mix( circle(uv),x, step(0., max(uv.x, uv.y)));\n    x = min(halfhori(uv+edge*.5), x);*/\n    float x = min(vert(uv), hori(uv-edge.yx));\n    return x;\n}\nfloat uu(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = mix(circle(uv), vert(uv-edge),  step(0., uv.y));\n    return x;\n}\nfloat vv(vec2 uv) {\n    uv.x = abs(uv.x);\n    float p = .5;\n    uv *= mat2(cos(p), -sin(p), sin(p), cos(p));\n    float x = vert(uv-edge*.5);\n    return x;\n}\nfloat ww(vec2 uv) {\n    uv.y = -uv.y;\n    return mm(uv);\n}\nfloat xx(vec2 uv) {\n    return diag(abs(uv)*vec2(-1., 1.));\n}\nfloat yy(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = min(halfvert(uv+edge.yx*.5), circle(uv-edge.yx));\n    x = mix(x, length(uv-size.xx), step(size.x, uv.y));\n    return x;\n}\nfloat zz(vec2 uv) {\n    float x = min(hori(uv-edge.yx), hori(uv+edge.yx));\n    uv.x = -uv.x;\n    return min(x, diag(uv));\n}\nfloat bracketRight(vec2 uv){\n    uv.x-=size.x*1.5;\n    float p = 1.3;\n    uv.y = abs(uv.y);\n    float a = atan(uv.x, uv.y);\n    float x = abs(length(uv)-size.x*2.);\n    uv.y = -uv.y;\n    x = mix(x, length(uv+vec2(cos(p), sin(p))*size.x*2.), step(-.3, a));\n    return x;\n}\nfloat bracketLeft(vec2 uv){\n    uv.x = -uv.x;\n    return bracketRight(uv);\n}\nfloat semicolon(vec2 uv){\n    float y = length(uv-edge.yx);\n    uv+= vec2(size.x*.5, size.x*.75);\n    float x = circleS(uv);\n    float z = min(length(uv-edge.xy*.5),length(uv+edge.yx*.5));\n    x = mix(z, x, step(max(uv.y, -uv.x),0.));\n    x = min(x, y);\n    return x;\n}\nfloat dash(vec2 uv){\n    return halfhori(uv);\n}\n\n//Render char if it's up\n#define ch(l)  text=min(text,l(uv+vec2(nr, 0.)));nr-=spacing.x;\n\n//Make it a bit easier to type text\n#define a_ ch(aa);\n#define b_ ch(bb);\n#define c_ ch(cc);\n#define d_ ch(dd);\n#define e_ ch(ee);\n#define f_ ch(ff);\n#define g_ ch(gg);\n#define h_ ch(hh);\n#define i_ ch(ii);\n#define j_ ch(jj);\n#define k_ ch(kk);\n#define l_ ch(ll);\n#define m_ ch(mm);\n#define M_ ch(MM); _\n#define n_ ch(nn);\n#define o_ ch(oo);\n#define p_ ch(pp);\n#define q_ ch(qq);\n#define r_ ch(rr);\n#define s_ ch(ss);\n#define t_ ch(tt);\n#define u_ ch(uu);\n#define v_ ch(vv);\n#define w_ ch(ww);\n#define x_ ch(xx);\n#define y_ ch(yy);\n#define z_ ch(zz);\n#define brR ch(bracketRight);\n#define brL ch(bracketLeft);\n#define sc ch(semicolon);\n#define da ch(dash);\n\n\n/*********************************\n************ GEOMETRY ************\n**********************************/\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Cartesian to polar coordinates\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float a = atan(p.y, p.z); // angle around center\n    float r = length(p.zy); // distance from center\n    return vec3(x, a, r);\n}\n\n// Polar to cartesian coordinates\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n} \n\n// Repeat space along one axis\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec2 closestPointOnRepeatedLine(vec2 line, vec2 point){\n\n    // Angle of the line\n    float a = atan(line.x, line.y);\n\n    // Rotate space so we can easily repeat along\n    // one dimension\n    pR(point, -a);\n\n    // Repeat to create parallel lines at the corners\n    // of the vec2(lead, radius) polar bounding area\n    float repeatSize = sin(a) * line.y;\n    float cell = pMod1(point.x, repeatSize);\n\n    // Rotate space back to where it was\n    pR(point, a);\n\n    // Closest point on a line\n    line = normalize(line);\n    float d = dot(point, line);\n    vec2 closest = line * d;\n\n    // Part 2 of the repeat, move the line along it's\n    // perpendicular by the repeat cell\n    vec2 perpendicular = vec2(line.y, -line.x);\n    closest += cell * repeatSize * perpendicular;\n\n    return closest;\n}\n\n// Closest point on a helix\nvec3 closestHelix(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * 3.14159 * 2.);\n    vec2 closest = closestPointOnRepeatedLine(line, p.xy);\n\n    closest.y /= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*3.14159/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = (.25+sin(iTime)*.05) / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 off = vec4(.5/iResolution.xy, 0., 0.);\n    off.zw = -off.xy;\n    vec4 color =  texture(iChannel0, uv) *.5;\n    color += texture(iChannel0, uv + off.xy) *.125;\n    color += texture(iChannel0, uv + off.xw) *.125;\n    color += texture(iChannel0, uv + off.zw) *.125;\n    color += texture(iChannel0, uv + off.zy) *.125;\n    \n    fragColor = color;\n}*/","name":"Buffer B","description":"","type":"buffer"}]}