{"ver":"0.1","info":{"id":"fsGXRw","date":"1650113735","viewed":54,"name":"Ferris - Sphere Light Cookie","username":"Ferrisfox","description":"light cookie from cubemap","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define METALLIC  0.2\n#define SMOTHNESS 0.3\n\n#define sat(x) clamp(x,0.,1.)\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Cube( vec3 ro, vec3 rd ) {\n    vec3 d = abs((1. - ro*sign(rd))/rd);\n    return min(d.x,min(d.y,d.z));\n}\n\nfloat Sphere( vec3 ro, vec3 rd ) {\n    float r = .1;\n    r = r*r;\n\n    float l = length(ro);\n    float tc = dot(-ro,rd);\n    float d2 = l*l - tc*tc;\n    \n    if(d2 > r) return 9e9;\n    \n    float t1c = sqrt(.01-d2);\n    return tc-t1c;\n}\n\nfloat LightMask ( vec3 d ) {\n    d.xz *= Rot(iTime*.2);\n    vec3 t = texture(iChannel0, d).xyz;\n    float v = smoothstep(1.02,1.,dot(t,vec3(1.)));\n    return v;\n}\n\nvec3 RendSphere( vec3 p ) {\n    float m = LightMask(p);\n    return vec3(m);\n}\n\nvec3 CubeNormal( vec3 p ) {\n    vec3 n = abs(p);\n    float nn = max(n.x,max(n.y,n.z));\n    return step(nn,n)/-p;\n}\n\nfloat Ambient( vec3 p ) {\n    float a = 0.;\n    \n    vec3 n = CubeNormal(p);\n    \n    for (int i=0; i<6; i++) {\n        int ii = i%3;\n        vec3 ap = vec3(ii/2,0.,(2-ii)/2);\n        ap.y = 1.-ap.x-ap.z;\n        ap *= float(i%2)*2.-1.;\n        vec3 lv = ap-p;\n        vec3 ld = normalize(lv);\n        vec3 an = CubeNormal(ap);\n        \n        float l = 1./(1. + dot(p,p));\n        a += sat(dot(n, ld)*l)/(1. + dot(p,p))/6.;\n    }\n    return sat(a);\n}\n\nvec3 RendCube( vec3 p, vec3 rd ) {\n    vec3 n = CubeNormal(p);\n    float m = LightMask(p);\n    \n    vec3 ld = normalize(-p);\n    float ll = m/(1. + dot(p,p));\n    \n    float diff = dot(n,ld)*ll*(1.-METALLIC);\n    \n    //blinn-phong\n    //vec3 hv = normalize(ld + rd);\n    //float spec = sat(dot(hv,n));\n    \n    //blinn\n    vec3 rf = reflect(ld,n);\n    float spec = pow(sat(dot(rd,rf)),SMOTHNESS*100.) * METALLIC * m;\n    \n    float l = spec + diff;\n    l += Ambient(p);\n    \n    return vec3(l);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(0.,.1,-.9);\n    vec3 rd = normalize(vec3(uv*1.5,1.));\n    rd.xz *= Rot(-iTime * .1);\n    ro.xz *= Rot(-iTime * .1);\n    \n    float ds = Sphere(ro,rd);\n    float dc = Cube(ro,rd);\n    float d = min(ds,dc);\n    \n    vec3 p = rd * d + ro;\n    \n    vec3 n;\n    if (ds<dc) {\n        col = RendSphere(p);\n    } else {\n        col = RendCube(p, rd);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}