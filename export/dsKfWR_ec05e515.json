{"ver":"0.1","info":{"id":"dsKfWR","date":"1698173407","viewed":485,"name":"UNSTABLE FLAME","username":"alro","description":"There's nothing sacred about the Eternal Flame at Eremer. It's just that for seventy years nobody has managed to put the damn thing out. Eventually they made a plaque and started charging for admission.","likes":43,"published":1,"flags":32,"usePreview":0,"tags":["flame","fire","voxel","curl","volumetric","cubemap","glow","particle","compute","spark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Simulating a semi-Lagrangian flow in Cubemap A and visualising a \n    flame-like effect using voxels and camera facing particles in \n    Buffer B. Use mouse to move camera.\n    \n    Change resolution in Common\n    Try pausing and moving the camera\n    \n    Based on:\n        https://www.shadertoy.com/view/4dfGzs\n        https://www.shadertoy.com/view/tdjBR1\n        https://www.shadertoy.com/view/7d2XD3\n    \n    Interested in hearing about ways to improve performance and \n    ensure that it looks the same on all machines, irrespective of\n    framerate and simulation resolution.\n    \n    EDIT: Added ray marching mode. Toggle in BufferB\n*/\n\n\n//-------------------------------- Bicubic blur --------------------------------\n\n// https://www.shadertoy.com/view/Dl2SDW\n\n// Cubic B-spline weighting\nvec2 w0(vec2 a){\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nvec2 w1(vec2 a){\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nvec2 w2(vec2 a){\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nvec2 w3(vec2 a){\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 is the amplitude function\nvec2 g0(vec2 a){\n    return w0(a) + w1(a);\n}\n\n// h0 and h1 are the two offset functions\nvec2 h0(vec2 a){\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nvec2 h1(vec2 a){\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 bicubic(sampler2D tex, vec2 uv, vec2 textureLodSize, float lod){\n\t\n    uv = uv * textureLodSize + 0.5;\n    \n\tvec2 iuv = floor(uv);\n\tvec2 f = fract(uv);\n\n    // Find offset in texel\n    vec2 h0 = h0(f);\n    vec2 h1 = h1(f);\n\n    // Four sample points\n\tvec2 p0 = (iuv + h0 - 0.5) / textureLodSize;\n\tvec2 p1 = (iuv + vec2(h1.x, h0.y) - 0.5) / textureLodSize;\n\tvec2 p2 = (iuv + vec2(h0.x, h1.y) - 0.5) / textureLodSize;\n\tvec2 p3 = (iuv + h1 - 0.5) / textureLodSize;\n\t\n    // Weighted linear interpolation\n    // g0 + g1 = 1 so only one is needed for a mix\n    vec2 g0 = g0(f);\n    return mix( mix(textureLod(tex, p3, lod), textureLod(tex, p2, lod), g0.x),\n                mix(textureLod(tex, p1, lod), textureLod(tex, p0, lod), g0.x), g0.y);\n}\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n\n    vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n    vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n\n    vec4 floorSample = bicubic(s, uv, lodSizeFloor.xy, floor(lod));\n    vec4 ceilSample = bicubic(s, uv, lodSizeCeil.xy, ceil(lod));\n\n    return mix(floorSample, ceilSample, fract(lod));\n}\n\nvec4 getBlur(sampler2D s, vec2 uv, float blur){\n    float maxLod = floor(log2(iChannelResolution[0].x));\n    float lod = mix(0.0, maxLod-1.0, blur);\n    return textureBicubic(s, uv, lod);\n}\n\n//----------------------------- Tonemapping and output ------------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col += getBlur(iChannel0, uv, 0.2).rgb;\n    col += getBlur(iChannel0, uv, 0.3).rgb;\n    col += 0.5*getBlur(iChannel0, uv, 0.55).rgb;\n    col += 0.5*getBlur(iChannel0, uv, 0.6).rgb;\n    col /= 4.0;\n    \n    // Tonemapping\n    col = ACESFilm(col);\n    \n    // Gamma\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2023 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n\n// Side length of domain. Max 184\nconst uint width = 90u;\nconst uint maxIdx = width * width * width;\nconst vec3 scale = vec3(width);\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 remap(vec3 x, vec3 low1, vec3 high1, vec3 low2, vec3 high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// -------------------- Camera --------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = normalize(cross(xaxis, zaxis));\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n// ----------------- Data lookup -----------------\n\n// Morton code approach is not used\n// https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\nuint compact1By1(uint x){\n  x &= 0x55555555u;                  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  x = (x ^ (x >>  1u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x >>  2u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x >>  4u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x >>  8u)) & 0x0000ffffu; // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  return x;\n}\n\n// \"Insert\" a 0 bit after each of the 16 low bits of x\nuint part1By1(uint x){\n  x &= 0x0000ffffu;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\nuint encodeMorton2(uint x, uint y){\n  return (part1By1(y) << 1u) + part1By1(x);\n}\n\nuint decodeMorton2X(uint code){\n  return compact1By1(code >> 0u);\n}\n\nuint decodeMorton2Y(uint code){\n  return compact1By1(code >> 1u);\n}\n\nvec3 idxToPoint(uint idx){\n    return min(scale, vec3(idx % width, \n                           uint(float(idx)/float(width)) % width, \n                           uint(float(idx)/float(width * width))));\n}\n\nuint pointToIdx(vec3 p){\n    return uint(p.z * float(width * width) + p.y * float(width) + p.x);\n}\n\nvec3 idxToDir(uint idx){\n       \n    uint face = uint(float(idx)/float(1024u * 1024u));\n    //uint localIdx = idx % (1024u * 1024u);\n    vec2 fragCoord = vec2(idx % 1024u, uint(float(idx)/float(1024u)) % 1024u) + 0.5; //vec2(decodeMorton2X(localIdx), decodeMorton2Y(localIdx))+0.5;\n    vec2 uv = 2.0 * (fragCoord/1024.0) - 1.0;\n\n    vec3 rayDir;\n    switch(face){\n        case 0u: rayDir = vec3(1,  -uv.yx); break;\n        case 1u: rayDir = vec3(-1,  -uv.y, uv.x); break;\n        case 2u: rayDir = vec3(uv.x,  1,  uv.y); break;\n        case 3u: rayDir = vec3(uv.x,  -1,  -uv.y); break;\n        case 4u: rayDir = vec3(uv.x, -uv.y,  1); break;\n        case 5u: rayDir = vec3(-uv,  -1);  break;\n    }\n\n    return rayDir;\n}\n\nvec4 getDataInterpolated(vec3 p, samplerCube s){\n    \n    p = clamp(p, vec3(0), scale-1.0);\n    vec3 f = fract(p);\n    vec3 c = floor(p);\n            \n    return mix( mix(  mix(texture(s, idxToDir(pointToIdx(c+vec3(0,0,0)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,0,0)))), f.x),\n                      mix(texture(s, idxToDir(pointToIdx(c+vec3(0,1,0)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,1,0)))), f.x), f.y),\n                 mix( mix(texture(s, idxToDir(pointToIdx(c+vec3(0,0,1)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,0,1)))), f.x),\n                      mix(texture(s, idxToDir(pointToIdx(c+vec3(0,1,1)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,1,1)))), f.x), f.y), f.z);\n}\n\nvec4 getData(vec3 p, samplerCube s){\n    p += vec3(0.5 * scale);\n    p = clamp(p, vec3(0), scale-1.0);\n    return texture(s, idxToDir(pointToIdx(p)));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n#define CAMERA_DIST 2.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n                    // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(2.9, 1.7);\n                mouse = vec2(0);\n            }\n            \n            // Set value at first frames.\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Trace voxels and intersect particles\n*/\n\n// The voxel structure can be hidden slightly by shifting particles along their flow direction\n// but this will result in them being cut off\nconst float offset = 0.5;\n\n// WIP\nconst bool rayMarching = false;\n\n//-------------------------- AABB -------------------------\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 boxMin, vec3 boxMax){\n    float eps = 1e-4;\n\treturn  (p.x > boxMin.x-eps) && (p.y > boxMin.y-eps) && (p.z > boxMin.z-eps) && \n\t\t\t(p.x < boxMax.x+eps) && (p.y < boxMax.y+eps) && (p.z < boxMax.z+eps);\n}\n\nbool testAABB(vec3 org, vec3 dir, vec3 boxMin, vec3 boxMax){\n    return insideAABB(org, boxMin, boxMax);\n\tvec2 intersections = intersectAABB(org, dir, boxMin, boxMax);\n\t\n    if(insideAABB(org, boxMin, boxMax)){\n        intersections.x = 1e-4;\n    }\n    \n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n//-------------------------------- Blackbody --------------------------------\n\n// Blackbody code from https://www.shadertoy.com/view/WsccDH\n\n// Convert sRGB-int8 to linear RGB-float\nvec3 rgb(int r, int g, int b){\n    return pow(vec3(r,g,b)/255., vec3(2.2));\n}\n\nvec3 rgb(int a){\n    int r = (a>>16) & 0xff;\n    int g = (a>>8) & 0xff;\n    int b = a & 0xff;\n    return rgb(r,g,b);\n}\n\nvec3 colorFromTemperature( float t ){\n    // Convert a temperature in Kelvin to a color\n    vec3 col = vec3(0);\n    col = mix(col, rgb(0xff3800), clamp(t/1000.,0.,1.));\n    col = mix(col, rgb(0xff8912), clamp((t-1000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xffb46b), clamp((t-2000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xffd1a3), clamp((t-3000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xffe4ce), clamp((t-4000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xfff3ef), clamp((t-5000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xf5f3ff), clamp((t-6000.)/1000.,0.,1.));\n    return col*t/3000.0;\n}\n\n\n//-------------------------------- Particles --------------------------------\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n// https://www.shadertoy.com/view/lsfGDB\nvec3 intersectCoordSys(in vec3 ro, in vec3 rd, vec3 dc, vec3 du, vec3 dv){\n\tvec3 oc = ro - dc;\n\treturn vec3(\n        dot(cross(du, dv), oc),\n\t\tdot(cross(oc, du), rd),\n\t\tdot(cross(dv, oc), rd)) / \n        dot(cross(dv, du), rd);\n}\n\n//-------------------------------- Colour --------------------------------\n\n// Unbelievable mileage from this function\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 getGradient(float t){\n\n    t *= 1.0;\n    t += 0.5*iTime;\n\n    vec3 a = vec3(0.65);\n    vec3 b = 1.0 - a;\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.15,0.5,0.75);\n\n    return pow(a + b * cos(TWO_PI * (c * t + d)), vec3(2.2));\n}\n\n\n//-------------------------------- Voxels --------------------------------\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// https://www.shadertoy.com/view/4dfGzs\nvec3 traceVoxels(vec3 org, vec3 rayDir, inout vec3 totalTransmittance){\n    org *= 0.5 * scale;\n    \n\tvec3 cell = floor(org);\n\tvec3 delta = 1.0 / rayDir;\n\tvec3 dir = sign(rayDir);\n    \n    vec3 mask = vec3(0);\n\tvec3 axisDist = (cell - org + 0.5 + dir * 0.5) * delta;\n\t\n    // Create a coordinate system from the ray direction\n    vec3 n = -rayDir;\n    vec3 tangent;\n    vec3 bitangent;\n    pixarONB(n, tangent, bitangent);\n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n    \n    vec3 col = vec3(0);\n    \n    // Shift between clean red flame and sooty gradient flame\n    float mode = smoothstep(-0.1, 0.1, sin(0.5 * iTime));\n\t\n    for(int i = 0; i < 200; i++){\n    \n        vec4 data = getData(cell, iChannel1);\n        \n        if(data.a > 0.0){\n        \n            vec3 pos = cell + 0.5;\n            pos += remap(hash33(cell+iTime), vec3(0), vec3(1), vec3(-offset), vec3(offset));\n\n            vec3 intersection = intersectCoordSys(org, rayDir, pos, tangent, bitangent);\n\n            // Distance of intersection in disc uv space\n            float d = dot(intersection.yz, intersection.yz);\n            // Gradient in density\n            float s = smoothstep(0.0, 0.25, data.a);\n            \n            vec3 luminance = data.a * getGradient(data.a);\n            luminance = mix(luminance, colorFromTemperature(20000.0 * data.a), mode);\n            float glow =  mix(0.2, 0.5, s) * mix(0.2, clamp(getGlow(d, 0.25, 1.5), 0.0, 32.0), s);\n            luminance *= 2.0*glow;\n            \n            vec3 sampleSigmaE = 8.0 * vec3(mix(0.1, 0.001 + data.a, mode));\n            \n            vec3 transmittance = exp(-sampleSigmaE * glow);\n \n            col += totalTransmittance * luminance / sampleSigmaE; \n            totalTransmittance *= transmittance;\n            \n            if(length(totalTransmittance) <= 0.001){\n                totalTransmittance = vec3(0.0);\n                return col;\n            }\n        }\n        \n        // Create 1 for whichever component is smallest and 0 for others\n\t\tmask = step(axisDist.xyz, axisDist.yzx) * step(axisDist.xyz, axisDist.zxy);\n        // Step axis-delta amount along the minimum axis and 0 for others\n\t\taxisDist += mask * dir * delta;\n        // Increment cell\n        cell += mask * dir;\n\n        // Return when outside the domain\n        if( (dir.x < 0.0 && cell.x < -0.5*scale.x) || \n            (dir.x > 0.0 && cell.x >= 0.5*scale.x) || \n            (dir.y < 0.0 && cell.y < -0.5*scale.y) || \n            (dir.y > 0.0 && cell.y >= 0.5*scale.y) || \n            (dir.z < 0.0 && cell.z < -0.5*scale.z) || \n            (dir.z > 0.0 && cell.z >= 0.5*scale.z)){\n            return col;\n        }\n\t}\n\n\treturn col;\n}\n\nvec3 rayMarch(vec3 org, vec3 rayDir, inout vec3 totalTransmittance, float dist, float dither){\n    \n    org *= 0.5 * scale;\n    dist *= 0.5 * float(width);\n    \n    const float stepCount = 16.0;\n    float stepS = (dist/stepCount);\n    \n    vec3 p = org + rayDir * stepS * dither;\n    \n    vec3 col = vec3(0);\n    \n    // Shift between clean red flame and sooty gradient flame\n    float mode = smoothstep(-0.1, 0.1, sin(0.5 * iTime));\n\t\n    for(int i = 0; i < int(stepCount); i++){\n    \n        vec4 data = getDataInterpolated(p + 0.5 * scale, iChannel1);\n        \n        vec3 pos = p;\n        pos += remap(hash33(floor(p) + 0.5 + iTime), vec3(0), vec3(1), vec3(-offset), vec3(offset));\n        \n        // Distance to voxel centre\n        float d = length(floor(p) + 0.5 - pos);\n        // Gradient in density\n        float s = smoothstep(0.0, 0.25, data.a);\n        \n        if(data.a > 0.0){\n            \n            vec3 luminance = data.a * getGradient(data.a);\n            luminance = mix(luminance, colorFromTemperature(20000.0 * data.a), mode);\n            float glow = mix(0.2, clamp(getGlow(d, 0.75, 5.0), 0.0, 32.0), s);\n            luminance *= glow;\n            \n            vec3 sampleSigmaE = 8.0 * vec3(mix(mix(0.025, 0.1, s), 0.001 + data.a, mode));\n           \n            vec3 transmittance = exp(-sampleSigmaE * stepS * glow);\n \n            col += totalTransmittance * luminance / sampleSigmaE; \n            totalTransmittance *= transmittance;\n            \n            if(length(totalTransmittance) <= 0.001){\n                totalTransmittance = vec3(0.0);\n                return col;\n            }\n        }\n        \n\n        p += stepS * rayDir;\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //----------------- Define a camera -----------------\n\n    // Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(55.0, fragCoord, iResolution.xy);\n\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(targetDir, up);\n\n    // Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\n    vec3 col = 0.2 * vec3(0.1, 0.15, 0.25);\n    vec3 data;\n\n    vec2 intersections = intersectAABB(cameraPos, rayDir, vec3(-1.0-(1.0/scale)), \n                                                          vec3(1.0+(1.0/scale)));\n    if(intersections.x < intersections.y){\n        vec3 totalTransmittance = vec3(1);\n        vec3 p = cameraPos + rayDir * max(0.0, intersections.x);\n        \n    if(rayMarching){\n        float dither = 0.0;\n        const float goldenRatio = 1.61803398875;\n            if(iChannelResolution[2].xy == vec2(1024)){\n                float blueNoise = texture(iChannel2, fragCoord / 1024.0).r;\n                dither = fract(blueNoise + float(iFrame%32) * goldenRatio);\n            }\n            data = rayMarch(p, rayDir, totalTransmittance, intersections.y - intersections.x, dither);\n        }else{\n            data = traceVoxels(p, rayDir, totalTransmittance);\n        }\n        \n        \n        col = mix(data, col, totalTransmittance);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"/*\n    Update a density field with curl noise.\n*/\n\n// Using gyroid noise FBM by default\nconst bool gradientNoise = false;\n\n//-------------------------------- Rotations --------------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\nvec3 rotateX(vec3 p, float angle){\n    return rotate(p, vec4(sin(angle/2.0), 0.0, 0.0, cos(angle/2.0)));\n}\nvec3 rotateY(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, sin(angle/2.0), 0.0, cos(angle/2.0)));\n}\nvec3 rotateZ(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, 0.0, sin(angle/2.0), cos(angle/2.0)));\n}\n\n//---------------------------- Distance functions ----------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n//------------------------- Geometry -------------------------\n\nfloat getSDF(vec3 p){\n    p -= vec3(0.5, 0.25, 0.5);\n   \n    float dist = 1e5;\n    vec3 q = p;\n    \n    dist = sphereSDF(q, 0.25);\n/*\n    q = p;\n    q = rotateY(q, 3.0*iTime);\n    q.z = abs(q.z);\n    q.z -= 0.33;\n    q.y += 0.05*cos(5.0*iTime);\n    dist = min(dist, sphereSDF(q, 0.075));\n    \n    q = p;\n    q = rotateY(q, -3.0*iTime);\n\n    q.z = abs(q.z);\n    q.z -= 0.3;\n    q.y += 0.05*sin(5.0*iTime);\n    dist = min(dist, sphereSDF(q, 0.075));\n*/\n   \n    return dist;\n}\n\n//---------------------------- Noise ----------------------------\n\n// 5th order polynomial interpolation\nvec3 fade(vec3 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = fade(f);\n\n    return mix( mix( mix( dot( hash(i + vec3(0.0,0.0,0.0)), f - vec3(0.0,0.0,0.0)), \n              dot( hash(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0)), \n              dot( hash(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n    mix( mix( dot( hash(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0)), \n              dot( hash(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0)), \n              dot( hash(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\n//---------------------------- Gyroid ----------------------------\n\n// https://en.wikipedia.org/wiki/Gyroid\n// https://www.shadertoy.com/view/wddfDM\nfloat gyroid(vec3 p, float thickness, float bias, float frequency){\n    // Multpliers break repetition in the gyroid.\n    return clamp((dot(sin(p*0.5), cos(p.zxy*1.23) * frequency) - bias) - thickness, -3.0, 3.0)/6.0;\n}\n\nconst float fbmScale = 1.93;\nconst int octaves = 4;\n\nfloat fbm(vec3 p){\n\n    if(gradientNoise){\n        return noise(p);\n    }\n\n    // Rotation of the gyroid every iteration to produce a noise look\n    const float a = PI / float(octaves);\n    const mat3 m3 = fbmScale * mat3(cos(a), sin(a), 0, -sin(a), cos(a), 0, 0, 0, 1);\n\n    float weight = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float res = 0.0;\n    \n    for(int i = min(0, iFrame); i < octaves; i++){\n        res += amplitude * gyroid(p, 0.0, 0.0, frequency);\n        p *= m3;\n        weight += amplitude;\n        frequency *= 0.5;\n    }\n    \n    return res;\n}\n\n//---------------------------- Curl ----------------------------\n\n// https://atyuwen.github.io/posts/bitangent-noise/\nvec3 getCurl(vec3 p){\n    const float eps = 1e-4;\n    \n    p += vec3(0.125*sin(2.0*iTime), -5.0*iTime, 0.125*cos(2.0*iTime));\n\n    float dx = fbm(p + vec3(eps, 0, 0)) - fbm(p - vec3(eps, 0, 0));\n    float dy = fbm(p + vec3(0, eps, 0)) - fbm(p - vec3(0, eps, 0));\n    float dz = fbm(p + vec3(0, 0, eps)) - fbm(p - vec3(0, 0, eps));\n\n    vec3 noiseGrad0 = vec3(dx, dy, dz)/(2.0 * eps);\n\n    // Offset position for second noise read\n    p += 1000.5;\n\n    dx = fbm(p + vec3(eps, 0, 0)) - fbm(p - vec3(eps, 0, 0));\n    dy = fbm(p + vec3(0, eps, 0)) - fbm(p - vec3(0, eps, 0));\n    dz = fbm(p + vec3(0, 0, eps)) - fbm(p - vec3(0, 0, eps));\n\n    vec3 noiseGrad1 = vec3(dx, dy, dz)/(2.0 * eps);\n\n    noiseGrad1 = normalize(noiseGrad1);\n    noiseGrad1 = normalize(noiseGrad1);\n    vec3 curl = cross(noiseGrad0, noiseGrad1);\n\n    return normalize(curl)+vec3(0,0.8,0);\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    \n    vec3 rd = abs(rayDir);\n\n    uint face;\n    if(rd.x > rd.y && rd.x > rd.z){\n        face = rayDir.x > 0.0 ? 0u : 1u;\n    }else if(rd.y > rd.z){\n        face = rayDir.y > 0.0 ? 2u : 3u;\n    }else{\n        face = rayDir.z > 0.0 ? 4u : 5u;\n    }\n\n    uint idx = face * 1024u * 1024u + uint(fragCoord.y) * 1024u + uint(fragCoord.x); //encodeMorton2(uint(fragCoord.x), uint(fragCoord.y));\n    if(idx < maxIdx){\n        vec3 pos = idxToPoint(idx);\n        float source = smoothstep(0.0, -0.1, getSDF(pos/float(width)));\n        if(iFrame == 0){\n        \n            vec3 curl = iTimeDelta*getCurl(pos / 20.0);\n            fragColor = vec4(curl, source);\n        }else{\n            vec3 curl = iTimeDelta*getCurl(pos / 20.0);\n            vec3 p = pos - 80.0 * curl;\n            p = clamp(p, vec3(0), scale-1.0);\n            vec4 data = getDataInterpolated(p, iChannel0);\n\n            float value = mix(data.a - iTimeDelta / 200.0, source, 0.12);\n            fragColor = vec4(curl, max(0.0, value));\n       }\n   }else{\n       fragColor = vec4(0);\n   }\n}","name":"Cube A","description":"","type":"cubemap"}]}