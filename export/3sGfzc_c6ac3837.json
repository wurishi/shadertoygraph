{"ver":"0.1","info":{"id":"3sGfzc","date":"1607614493","viewed":148,"name":"digitful","username":"digitcrusher","description":"graphics card buster, enjoy :-)\n\nSet cast_rayc to 30 (line 126) and cast_sample_density to 2 (line 128) if you want the best visual quality and performance. Values of cast_rayc higher than one result in soft shadows.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","raycasting","lighting","shadows","soft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nfloat angle_to(vec2 a, vec2 b) {\n  return atan(b.y - a.y, b.x - b.x);\n}\n\nvec2 rotate_vec(vec2 vec, float angle) {\n  return vec2(cos(angle) * vec.x - sin(angle) * vec.y,\n              sin(angle) * vec.x + cos(angle) * vec.y);\n}\n\n// https://stackoverflow.com/questions/1119451/how-to-tell-if-a-line-intersects-a-polygon-in-c\nbool do_lines_intersect(vec2 a1, vec2 b1, vec2 a2, vec2 b2) {\n  float denom = (b1.x - a1.x) * (b2.y - a2.y) - (b1.y - a1.y) * (b2.x - a2.x);\n\n  if(denom == 0.0) return false; // the lines are parallel\n\n  float numer = (a1.y - a2.y) * (b2.x - a2.x) - (a1.x - a2.x) * (b2.y - a2.y);\n  float r = numer / denom;\n  float numer2 = (a1.y - a2.y) * (b1.x - a1.x) - (a1.x - a2.x) * (b1.y - a1.y);\n  float s = numer2 / denom;\n\n  return !((r < 0.0 || r > 1.0) || (s < 0.0 || s > 1.0));\n}\n\n\n\nconst int lightc = 3;\n\nstruct Light {\n  vec2 pos;\n  vec3 color;\n  float intensity;\n  float radius;\n} lights[lightc] = Light[](\n  Light(vec2(0.0, 0.0), vec3(0.8, 0.0, 0.0), 1.0, 1.0),\n  Light(vec2(0.0, 0.0), vec3(0.0, 0.7, 0.0), 1.0, 1.0),\n  Light(vec2(0.0, 0.0), vec3(0.0, 0.0, 1.0), 1.0, 1.0)\n);\n\nconst int obstaclec = 2;\nconst int obstacle_vertexc = 6;\n\nstruct Obstacle {\n  vec2 pos;\n  bool is_closed;\n  vec2 vertices[obstacle_vertexc];\n};\nObstacle obstacles[obstaclec] = Obstacle[](\n  Obstacle(vec2(70.0, 0.0), false, vec2[obstacle_vertexc](\n    vec2(-10.0, -20.0),\n    vec2(  0.0, -20.0),\n    vec2( 10.0, -10.0),\n    vec2( 10.0,  20.0),\n    vec2(  0.0,  10.0),\n    vec2(-10.0,  10.0)\n  )),\n  Obstacle(vec2(-70.0, 0.0), true, vec2[obstacle_vertexc](\n    vec2(-10.0, -20.0),\n    vec2(  0.0, -20.0),\n    vec2( 10.0, -10.0),\n    vec2( 10.0,  20.0),\n    vec2(  0.0,  10.0),\n    vec2(-10.0,  10.0)\n  ))\n);\n\nvec3 color_at(Light light, vec2 pos, int rayc, float dist_mul) {\n  float dist = (distance(pos, light.pos) - light.radius) * dist_mul / light.intensity;\n  vec2 tangent_offset = rotate_vec(normalize(light.pos - pos), PI / 2.0) * light.radius; // this is not the real tangent\n\n  int hit_rayc = 0;\n  for(int i = 0; i < rayc; i++) {\n    vec2 ray_target = light.pos;\n    if(rayc <= 1) {\n      ray_target = light.pos;\n    } else {\n      ray_target = light.pos + tangent_offset * (2.0 * float(i) / float(rayc - 1) - 1.0);\n    }\n\n    bool is_shadowed = false;\n\n    for(int j = 0; j < obstaclec && !is_shadowed; j++) {\n      for(int a = 0; a < obstacle_vertexc - (obstacles[j].is_closed ? 0 : 1) && !is_shadowed; a++) {\n        int b = (a + 1) % obstacle_vertexc;\n\n        vec2 vert1 = obstacles[j].vertices[a] + obstacles[j].pos;\n        vec2 vert2 = obstacles[j].vertices[b] + obstacles[j].pos;\n        if(vert1 == vert2) continue;\n\n        if(do_lines_intersect(vert1, vert2, pos, ray_target)) is_shadowed = true;\n      }\n    }\n\n    if(!is_shadowed) hit_rayc++;\n  }\n\n  return light.color / max(pow(dist + 1.0, 2.0), 1.0) * float(hit_rayc) / float(rayc);\n}\n\n// supersampling anti-aliasing type stuff\nvec3 supersampled_color_at(Light light, vec2 pos, int rayc, float dist_mul, int sample_density) {\n  if(sample_density == 1) {\n    return color_at(light, pos, rayc, dist_mul);\n  }\n\n  vec3 result = vec3(0.0);\n  for(int x = 0; x < sample_density; x++) {\n    for(int y = 0; y < sample_density; y++) {\n      vec2 offset = vec2(-0.5) + vec2(1.0) / float(sample_density) * (vec2(float(x), float(y)) + 0.5);\n      result += color_at(light, pos + offset, rayc, dist_mul) / float(sample_density * sample_density);\n    }\n  }\n  return result;\n}\n\n\n/*\n * Time complexity: O(W * H * L * S^2 * R * E)\n * W - width, H - height, S - sample density per fragment, L - light count, R - ray count for every fragment, E - number of all polygon edges\n * You could theoretically get rid of R from the equation if you were to assume that all the polygons are convex, I haven't figured out how to do that for concave ones yet.\n */\n\nvec4 frag_color = vec4(vec3(0.0), 1.0);\nvec2 frag_coord;\n\nconst int cast_rayc = 1;\nconst float cast_dist_mul = 0.01;\nconst int cast_sample_density = 1;\n\nvoid cast_light(Light light) {\n  frag_color.xyz += supersampled_color_at(light, frag_coord, cast_rayc, cast_dist_mul, cast_sample_density);\n}\n\nconst float spin_freq = 1.0;\nconst float spin_dist = 50.0;\n\nvoid mainImage(out vec4 final_frag_color, in vec2 orig_frag_coord) {\n  frag_coord = orig_frag_coord - iResolution.xy / 2.0;\n\n  cast_light(Light(iMouse.xy - iResolution.xy / 2.0, vec3(1.0, 1.0, 1.0), 1.0, 1.0));\n\n  for(int i = 0; i < lightc; i++) {\n    float angle = (iTime * spin_freq + float(i) / float(lightc)) * PI * 2.0;\n    lights[i].pos += vec2(cos(angle), sin(angle)) * spin_dist;\n    cast_light(lights[i]);\n  }\n\n  final_frag_color = frag_color;\n}","name":"Image","description":"","type":"image"}]}