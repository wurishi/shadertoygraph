{"ver":"0.1","info":{"id":"wtKyzV","date":"1611450214","viewed":138,"name":"early valentines (vlllll)","username":"valalalalala","description":"Cute procedural texture and geometry inspired by AoC's https://www.youtube.com/watch?v=dXyPOLf2MbU and https://www.shadertoy.com/view/4sccWr and IQ's https://www.youtube.com/watch?v=aNR4n0i2ZlM\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","texture","heart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"simple marcher\"                                          // //\n     //                                                            //  //\n    //  scene description goes here                               //   //\n   //  scene description goes here                               //    //   \n  //  scene description goes here                               //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////\n// scene controls\n#define RED vec3(1.,.1,.1)\n\n// sometimes less is more...\n#define GONZO_\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\n#define ZED   .0\n#define PI    3.141592653589793 \n#define PI2   6.283185307179586\n\n////////////////////////////////////////////////////////////////\n// ray marching\n\n#define STEPS 99\n#define CLOSE .001\n#define FAR   99.\n#define EPZ   vec2( ZED, CLOSE )\n\n////////////////////////////////////////////////////////////////\n\n#define FROM_SCREEN(uv)  ( ( 2. * uv - iResolution.xy ) / iResolution.y )\n#define MAP_11_01(v)     ( v * .5 + .5 )\n\n#define TRIG(a)    vec2( cos( a  * PI2 ), sin( a * PI2 ) )\n#define MAX3(v)    max( v.x, max( v.y, v.z ) )\n#define SUM3(v)    ( v.x + v.y + v.z )\n#define MODO(v,f)  ( mod( v + .5 * f, f ) - .5 * f )\n\n////////////////////////////////////////////////////////////////\n\nmat2 rotate2d( float angle ) {\n    vec2 t = TRIG( angle );\n    return mat2( t.x, -t.y, t.y, t.x ); //c-ssc\n}\n\n////////////////////////////////////////////////////////////////\n\n\nfloat lubDub() {\n    float t = iTime * 4.;\n    return abs(cos(t));\n    \n    float a = abs( cos( t ) );\n    float l = 2.5;\n    float m = -4.;\n    float b = -abs( sin( t * l + m ) );\n    float c = max( .0, a + b - .22 ) * 2.;\n    return min( c, 1. );\n}\n\nfloat getDistance( vec3 p ) {\n\n    #ifdef GONZO\n        // this is all problematic.. may revisit it sometime....\n        float scale = 10.;\n\n        vec3 q = p + .5 * scale;\n        vec3 f = mod(q,scale)  - .5 * scale;\n        vec3 i = floor( q / scale );\n    \n        float proxy = length(f);\n        if ( proxy > 2. ) return proxy;\n    \n        // offset x every other row\n        float e = step( 1., mod( i.y, 2. ) ) * 2. - 1.;\n        #if 1\n            f.xy *= rotate2d( SUM3( i ) * .33 + iTime * .3 );\n        #else\n            // dance my pretties! dance!\n            float o = .1 * abs( cos( iTime ) );\n            f.x += e * scale * o;\n            f.xy *= rotate2d(  SUM3( i ) * .33 + iTime * .3 );\n            f.x += e * scale * o;\n            f.z += e * scale * .25;\n        #endif\n    #else\n        float proxy = length(p);\n        if ( proxy > 4. ) return proxy;\n    \n        vec3 f = p;\n        f.xz *= rotate2d( iTime * .13 );\n    #endif\n    \n    /////////////////////////////////////////////////////////////\n    \n    f.xy = hearty( f.xy, - .4 );\n    f.y+=.33;\n    f.z *= ( 2. - ( f.y + 1. ) * .5 ) * 4.4;\n\n    float radius = .66;\n    float dub = abs(cos( (iTime+ f.y*.2 ) * 2.)) * .33;\n    radius += dub;\n    \n    float d = length( f ) - radius;\n    return d * .1;   // sort of suprisingly small fudge factor needed\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat march( vec3 a, vec3 ab ) {\n    float d = .0;\n    for ( int i = 0 ; i < STEPS ; i++ ) {\n        vec3 b = a + d * ab;\n        float n = getDistance( b );\n        d += n;\n        if ( abs( n ) < CLOSE || d > FAR ) break;\n    }\n    return d;\n}\n\nvec3 getDistances( vec3 a, vec3 b, vec3 c ) {\n    return vec3( getDistance( a ), getDistance( b ), getDistance( c ) );\n}\n\nvec3 getNormal( vec3 p ) {\n    return normalize( getDistance( p ) - \n        getDistances( p - EPZ.yxx, p - EPZ.xyx, p - EPZ.xxy )\n    );\n}\n\n////////////////////////////////////////////////////////////////\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( TRIG( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec2 getMouse() {\n    return true||iMouse.z > .0\n        ? FROM_SCREEN( iMouse.xy )\n        : vec2( .44 * cos( iTime * .44 ), .33 )\n    ;  \n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 texaco( vec2 uv ) {\n    return 2. * RED * ( .2 + hearts( uv, iTime * .5 ) );\n}\n\nvec3 colorHit( vec3 p ) {\n    vec3 n = getNormal( p );\n    //float q = max(n.x,max(n.y,n.z));\n    float l = max( .2, pow( MAP_11_01( MAX3(n) ), 2. ) );\n    \n    n = pow( abs(n), vec3( 4. ) );\n    n /= SUM3( n ); // pseudo normalize\n    \n    vec3 tX = texaco( MAP_11_01( p.yz ) );\n    vec3 tY = texaco( MAP_11_01( p.xz ) );\n    vec3 tZ = texaco( MAP_11_01( p.xy ) );\n\n    return l * ( n.x * tX + n.y * tY + n.z * tZ );\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    return .4 * texaco( MAP_11_01( uv * .5 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = FROM_SCREEN( fragCoord );\n    float view = 4.;\n    float zoom = 2.;\n\n    ////\n    \n    vec2 m = getMouse();  \n    vec2 t = view * TRIG( m.x );\n    \n    vec3 a = vec3( t.x, .0 * view * TRIG( m.y ).y, t.y );       \n    vec3 b = vec3( ZED );\n    vec3 ab = normalize( makeCamera( a, b, .0 ) * vec3( uv, zoom ) );\n\n    ////\n\n    float d = march( a, ab );\n    float hit = step( d, FAR );\n\n    vec3 p = hit * ( a + ab * d );\n    vec3 color = mix( colorMiss( uv ), colorHit( p ), hit );\n    \n    float foginess = pow( d / FAR, .33 ) * hit;\n    vec3 fog = vec3( .22, .11, .4 );\n    color = mix( color, fog, foginess );\n    \n    fragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat hash21( vec2 id ) {\n    vec3 v = fract( id.xyx * vec3( .1991, .234, .133 ) );\n    v += dot( v, v.yzx + vec3( 8.12, 2.34, 9.23 ) );\n    return fract( v.x * ( v.y + v.z ) );\n}\n\nvec2 hearty( vec2 uv, float blur ) {\n    float fatness = 1.33 - blur * .22;\n    float up = -.1; \n    float roundness = .7 + .3 * blur;\n    float steepness = .5 - .3 * blur;\n\n    uv.x /= fatness;\n    float y = steepness * ( pow( abs( uv.x ), roundness ) + up );\n    uv.y -= y;\n    return uv;\n}\n\nvec2 hearty( vec2 uv ) {\n    return hearty( uv, .0 );\n}\n\nfloat heart( vec2 uv, float blur ) {\n    float r = .22;    \n    float d = length( hearty( uv, blur ) ); \n    blur *= r * 1.33;\n    d = smoothstep( r + blur,r - blur - .1, d );\n    return d;\n}\n\nfloat hearts( vec2 uv, float time ) {\n    float t = cos(time * .33);\n    vec2 trig = vec2( cos( t ), sin( t ) );\n    uv *= mat2( trig.x, -trig.y, trig.y, trig.x );\n    uv += 7. * cos(time * .01);\n    \n    float scale = 3.2 + 3. * sin(time*.1);\n    \n    // this has to happen before the fract! see bos 09\n    uv.x += step(1., mod(uv.y*scale,2.0)) * 0.5;\n    \n    vec2 st = fract( uv * scale ) - .5;\n    vec2 id = floor( uv * scale );\n    \n    float q = hash21( id );\n    t = 4. * sin( 2. * time * q + q ) + q;\n    trig = vec2( cos( t ), sin( t ) );   \n    st *= mat2( trig.x, -trig.y, trig.y, trig.x );\n\n    float blur = pow(cos(time * 2.),2.);\n    \n    return heart( st, blur );\n}","name":"Common","description":"","type":"common"}]}